| sockaddr
| sockaddr_in
| sockaddr_in6


я хочу поговорить про эти структы. они играют фуажаментальную роль 
для функций bind() connect() listen() 
тоесть эти структы играют фундатменальную роль когда наша прога на си хочет с кемто
связаться по сети. 

инфо о них сидит в 

  $ man sockaddr

так вот эти штуки это структы. что такое структ - это такой тип данных. 
дело в том что у си каждая переменная имеет всегда какйто тип. это нужно комплиятору
для того чтобы он знал какие ассемблер команды он должен юзать для создания этой 
переменной( в частности  сколько байтов нужно для этой переменной в памяти ) 
и потом какие действия можно делать с этой переменной потом.   напрмиер тип данных int


   int a  = 10;

и этот тип занимает 4 байта в памяти. 
так вот структ sockaddr это тоже тип в памяти.  чем структ отличается от обычного типа (int, 
long int, char) данных - структ имеет внутри себя поля. имеется ввиду не сточки зрения 
ассемлеоа. с точки зрения ассемблера это будет просто кусок неперрывной памяти какйото 
длинннй скажем 16 байт. но для компилятора когда он создает ассемблер код данный тип 
имеет поля. тоесть скажем первые два байта это поле1, следущие два байта это поле2 итд.
с этими полями можно работать в си. к ним можно обращаться . их можно менять. туда можно
писать. читать. говоря с другой строны структ это когда мы берем несколько перменных 
разных типов и обеьединяем их в один кусок в памяти. в том числе в составе структа может
сидеть другой структ. 
так вот переходим к структу sockaddr 


 #include <sys/socket.h>

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };



для начала потсмиотрим какой у него размер


$ cat 320.c
#define _POSIX_C_SOURCE  200809L
#include <sys/socket.h>
#include <stdio.h>


int main() {


    struct sockaddr s1;
    dprintf (1, "sockaddr SIZE = %hi \n", sizeof(s1) );

}


 $ ./320.exe
sockaddr SIZE = 16 

итак размер этого структа 16 байт.

кстати что значит "include"  в тексте программы. это значит что мы хотим в нашем процессе
ммы хотим юзать функции которые входят не в состав нашего текста на си а в состав
другого файла шаред либрари (которая бинарный файл  плюс файл заголовка name.h) и 
наш бинарник будет так составлен компитлятором что при создании процессса из файла нашего
бинарника  в вирт адресное  пространство нашего процесса будут "подгружены"  замаплены
файлы шаред либрари. таким образом наш процессс он как бы включает в себя нетлоько код 
на си который написали мы но еще и код на си который написал ктото за нас. а мы включтли
его в состав нашей программы.

возвращаеися к нашему структу


  struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


щас мы узнаем размер типа  sa_family_t
смотри 320.с
и видим что 

sa_family_t SIZE = 2

итак получается что 



  struct sockaddr {
           sa_family_t     sa_family;  2  байта      /* Address family */
           char            sa_data[]; 14  байт    /* Socket address */
       };

в левом столюике указан тип поля. в правом имя поля. по имени мы обращаемся 
к полям. первое поле

		sa_family_t     sa_family   

это два байта . ну можно считать что это короткий int без знака
имя поля(по аналогии имя переенной) sa_family а его тип sa_family_t 

второе поле

		char     sa_data[]    

это поле имеет длину  14 байт. имя поля sa_data, тип char
что значит обозначение

      char vasya[]

это означает что эта переменная это массив. а что такое массив
это набор отдельных элементов каждый из которых имеет один и тот же тип и эти элементы
собраны в памяти в одну кучку. однако 
обозначение 

	      char vasya[]

это некоретное ошибочнок обозанчние. си прогаимма такое задание поля структа или обььявление массива в качестве переменной не позволит. выдаст ошибку. правлное обьявление массива
всегда выглядит так

		char vasya[14]

тоесть при обьявлении массива мы обязаны указать число элементов массива в скобочках.
vasya это имя массива. и то что левее это штука в данном случае char она обьясняет компиятору
тип каждого элемента этого массива. тип char означае что размер элемент 1 байт.
итак обозаение выше говорит о том что создай массив с именем vasya элемент в массиве имеет
размер 1 байт. и таких элементов в массиве 14 штук. тогда комплитятор создаст асемблер команду
которая создас в области памяти кусок из 14 байтов которые лежат непрвырывно в памяти рядышком.
в масиве еще раз скажу размер его указыается в виде количества элементов.

далее пока мы перехоим в другой документ. где я подробно рассматриваю вспомогательный 
материал касающийся массивов, поинтеров и тому подобнго. читай c-array-pointer.txt


cat 320.c
#define _POSIX_C_SOURCE  200809L
#include <sys/socket.h>
#include <stdio.h>


int main() {


    struct sockaddr s1;
    dprintf (1, "sockaddr SIZE = %hi \n", sizeof(s1) );  \\ размер структа целиком

    sa_family_t  a1;
    dprintf (1, "sa_family_t SIZE = %hi \n", sizeof(a1) ); \\ размер первого поля структа

    char vasya[10];
    dprintf (1, "char vasya[10] SIZE = %hi \n", sizeof(vasya) );

    
}


акецнтирую внимание 

    char vasya[10];
    dprintf (1, "char vasya[10] SIZE = %hi \n", sizeof(vasya) );

на экране
 $ ./320.exe
char vasya[10] SIZE = 10 

тоесть у нас была создана пееременная размером 10 байт.

я хочу тут ацентировать внимание на обьявлнии массива. как это делать

   char vasya[10];

10 это в масиве 10 элементов.  char означает как выгядит один элемент этого масива тоест
в данном сулчсе один элемент занимает 1 байт. потому что char это тип данных который
занимает 1 байт. vasya - это имя массива. по факту это перменная имеет тип поинтер  и
укзывает на адрес первого элемента массива. прадва несморя на то что vasya это поинтер
но если мы вот такое делаем 

   sizeof(vasya)

то будет показан не размер поинтера который 4\8 байт.  а будет показан именно
размер массива. 
а если вот так сделать 

	   sizeof(vasya[10])

то будет показан рамзер 10-го элемента массива. 
потому что vasya[10] укзаанное при создании массива покаывает его числоа эелментов.
   char vasya[10];
а  vasya[10] указанное уже после обьявления массива означает покажи мне 10-ый элемет
массива. это я про разный смысл скобоки [10]


мы можем заcунуть в эттот массив любые 10 байт. и тут надо наряду с массивами 
скзаать про стринги. стринг в си это такое значение которое состоит из ascii байтов и обязательно на конце последний байт это ноль байт 0x00. стринг в тексте си программы  выглядит как текст закоюненный в двойные кавычки. 

   "123456779"

когда коплиятор увидит эту штуку то он ее преооразует в набор байтов согласно ascii 
таблице и обязательно на конце прилепит 0x00 байт. я подчеркну что стринг это не тип 
переменной а это ОСОБЫЙ ВИД ЗНАЧЕНИЯ которое  суется в переменную. обычно стринг суется
в массив что логично.  например стинг суется в масив вот так 

    char vasya[10] = "123456789";


тоесть слева у нас записано - эй си создай массив из 10-ти элементов каждый из которого
имеет тип char тоесть занмиает 1 байт. и засунть в переменную vasya поинтер то есть адрес
на первый эелмент этого массива. и засунь в этот массив байты которые получаются если 
взять фразу 123456789 и преобразовать ее  в байтвы согласно ascii таблцие и еще в конце
добавь последний элемент 0x00
заметим еще раз что если мы в массив пихаем стринг то число символов внутри двойных
кавычек всегда на 1 меньше чем размер масива. потому что у нас внутри кавычек невиимо присутстуует
еще один элемент это ноль байт 0x00. поэтому у меня внури кавычек 9 симловоллов в этом примере.

так со стрингом разобрались. 
но повторюсь что наш массив необязан в себе содержать только стринг . в него можно
пихать любой набор байтов. 

как можно совать байты в масив. есть несколько спосособов.
один я уже показал. тоесть можно совать данные в массив на стадии создания массива.

второй метод иницлиазциии этого масива это опять же на стадии создания

    char kolya[10] = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '10'};

здесь я использовал одинакрные кавычки ''
а что они значат? а это тоже такой трюк комплиятоора. он ознаачает что возьми этот символ
и преобразуй его в  1 байт согласно таблице ascii
поэтому есть огромная разнциа между "" и '' с точки си.

 "1"  это стринг состоящий из двух симвлоов. первый это символ 1 тоесть байт 0x31
 а втоой символ который мы не видим но он будет создан коилттором это 0x00
 тоесть этот стринг это два байта   
 
 а '1' это 1 байт тоесть 0x31

поэтому между двойнми кавычками может быть дохрена симоловов.
а внутри одинакрным кавычк тлько один символ. 
одинарный симолвисползуется когда мы хотим присовим занчение переменной или элменту 
массив типа char

   char a = '1';

 но будет ошибка есдли я напишу

   char a = "1";

потмоу что слева стоит обалсть памяти размером 1 байт а справа два байта


следущий метод
можено внести даныне в массив чисто в форме байтов

    char kolya[10] = {0x01, 0xAA, 0xBB, 0xCC , 0x01, 0xEF, 0xA0, 0xE0, 0xEE, 0x0A};

а вот пример как иницлизировть массив с одинаковым заченнеим для всех 
элементов

 unsigned char kuku[10]={ [0 ... 9] = 0xAA };
 
    printf("\n");
    for (unsigned short int i=0; i<sizeof(kuku); i++) {
	dprintf (1, "kuku[%hhi] = %hhX\n", i, kuku[i] );
    }

тоест вот этоот кусок [0 ... 9] = 0xAA означает что для элементо 0-9 засунь значение 0xAA
вывод на экране
kuku[0] = AA
kuku[1] = AA
kuku[2] = AA
kuku[3] = AA
kuku[4] = AA
kuku[5] = AA
kuku[6] = AA
kuku[7] = AA
kuku[8] = AA
kuku[9] = AA


но надо понмиать что такой удобный метод венсенеия данных в массив в форме скобочки
когдам мы укаызаем все элеентм за раз он раобтает только есл мы это делаем 
прям на стадии обьявления массива. 
если мы егообявили. а уже после этого будет пытаться в него так внести данне то 
не полуится 
тоесть вот так выдаст ошиибку
    char kolya[10];
    kolya[10]= {0x01, 0xAA, 0xBB, 0xCC , 0x01, 0xEF, 0xA0, 0xE0, 0xEE, 0x0A}; 

потому что kolya[10] уже после обьявления массива одначает не массив а отделный элемент
номер 10. а мы ппытаетсся в элемент номер 10 размер корторого 1 байт засунуть целый масив
поэтому пошел нафиг.  

поэтому если мы уже создали массив пустой. то в него можно пихать даныне 
вот так 

	char kolya[10];
    kolya[0] = 'a';
    kolya[1] = 'A';
    kolya[2] = 'b';
    kolya[3] = 'B';
    kolya[4] = 'c';
    kolya[5] = '0xEE;
    kolya[6] = 'd';
    kolya[7] = 'D';
    kolya[8] = 'e';
    kolya[9] = 0xAA;


отмечаю что индексы (оффсет) внутри массива начинатся с нуля.


а вот как посмотреть контент этого массива в hex формате

   dprintf (1, "\n");
    for (unsigned short int i=0; i<sizeof(kolya); i++) {
	dprintf (1, "kolya[%hhi] = %hhX\n", i, kolya[i] );
    }


увидим на экране

kolya[0] = 61
kolya[1] = 41
kolya[2] = 62
kolya[3] = 42
kolya[4] = 63
kolya[5] = EE
kolya[6] = 64
kolya[7] = 44
kolya[8] = 65
kolya[9] = AA


хочу пояснить про формат dprintf\printf
на примере

    unsigned short int i = 10;
	dprintf (1, "%hhX\n", i );

у нас внутри printf\dprintf есть поле  с кавычкми двойными 

		"%hhX\n"

а есть  аргумент  это 
		
		i


так вот принтф он берет то что хранится в i тоесть байт или байты которые хрантся в 
переной i и потом этот байт какимто макааром отрисоывает на экране. и тут важно понимать
во первых какая длинна в байтах того что хранится в i. а чтоы это узнаиь надо значть ТИП 
переменной i. а для этого найдо найти ту строку где мы ее создавали

    unsigned short int i = 10;

отсюда мы понимает что в i лежит 2 байта. 
так вот принтф он возьмет 2 байта из памяти а далее внутри кавычек указано как эти 2 байта
нужно на экране рисовать 

	%hhX

где %hh означает что наш аргумент должен быть длинной  2 байта
а X означает что эти два байта на экране нужно нарисовать в виде hex числа
тоесть я хочу сказать что коода мы в принтф пихаем перетенные то ихняя длинна должна 
обязательно совпдаать с длинной модиифкиатора внутри кавычек "" иначе будет хуйня.
скажем у нас аргумент i имеет длинну 4 байта. а модиифкатор внутри кавычек трактует его
как 2 байта. поэтому за этим надо следить в принфт. чтобы на экране не получать хуйню.

еще малек про массивы
вот прмиер массива
он состоит из 10 элементов. каждый элемент это int тоесть он состоит из 4 байт.
значит его размер 40 байтов.

  //
   unsigned int b2[10]={1, 2, 3, 4, 5, 6, 7, 8, 9};
   dprintf (1, "\n"
	"b2[10] SIZE = %hhi \n"
	"адрес первого элемента в памяти = %p \n"
    "b2[0] = %hhX \n"
        , sizeof(b2), b2, b2[0] );


на экране увидим 
b2[10] SIZE = 40 (полный размер массива)  
адрес первого элемента в памяти = 0x7ffd8615a440 
b2[0] = 1  (занчние первггого элемента)


этим  я доказываю  что сам b2 это поинтер. это адрес на первый элемент массива.
и я покаываю то что запись b2[0] это УЖЕ НЕ ПОИНТЕР. а это именно уже значение такогото
элемента в данном случае значение лежащее в первом элементе. а какой размер у этого элемента?
а размер элемента такой как указано в определении массива

	 unsigned int b2[10]

тоесть слова  unsigned int  обозначаю размер ОДНОГО эелмента в массиве. поэтому когда мы
просим нам выдать значение одного элемента  b2[0] то си нам выдаст ровно столько байт
сколко указано при обьявлении маасива. то есть в данном случае 4 байта. этоможно 
проверить  вот так

    dprintf (1,"b2[0] SIZE = %hi\n", sizeof(b2[0]) );

на экране
b2[0] SIZE = 4

тоесть я хотел тут подчеркнуть что b2 это поинтер. а элемент b2[i] это уже не понинтер.
это уже значение которое лежит внуритри таогото элемента массива. его размер равен 
размеру элемента массива. размер одног элемента задается на стаадии оббябявления массива
поэтому если 

   unsigned int b2[10]={1, 2, 3, 4, 5, 6, 7, 8, 9};

то b2 это поинтер размером 4\8 байт  взавимисомти 32\64 бит
а b2[i] это unsigned int а не поинтер и размер  4 байта




ТЕПЕРЬ когда мы разобларались с массивами  
я возвращаюсь к  структу 	SOCKADDR


  struct sockaddr {
           sa_family_t     sa_family;  2  байта      /* Address family */
           char            sa_data[]; 14  байт       /* Socket address */
       };


и его второму полю которое обозначено неправильно потому что нужно вот так

           char    sa_data[14];

которое является массивом. размером массива 14 байт. 
каждый элемент массива имеет размер 1 байт.  
кажый элемент может быть любымт байтом. ограничений нет
На даный момент с точки зрения чистого си мы ввсего навсего узнали
что это структ ссотоит из двух полей. что первое поле имеет такое то имя и длину 2 байта
а второе поле имеет такое то имя и 14 байтов и что второе поле это массив из 14 элементов
каждый из которых длинной 1 байт.
вот что такое этот структ с точки зрения самого си.

для примера записываю раноднмые байты в наш структ

   //
    struct sockaddr s2;
    s2.sa_family   = 0xAAFF;  // запиывают два рандомных байта в первое поле

так как второе поле это массив где кажый элемент это char тоесть 1 байт 
то мне нужно в каждый эдемент пихать не более 1 байта.

    s2.sa_data[0]  = 0x01;  //пихаю 1 байт
    s2.sa_data[1]  = 0x02;  // ...
    s2.sa_data[2]  = 0x03;
    s2.sa_data[3]  = 0x04;
    s2.sa_data[4]  = 0x05;
    s2.sa_data[5]  = 0x06;
    s2.sa_data[6]  = 0x07;
    s2.sa_data[7]  = 0x08;
    s2.sa_data[8]  = 0x09;
    s2.sa_data[9]  = 0xAA;
    s2.sa_data[10] = 0xBB;
    s2.sa_data[11] = 0xCC;
    s2.sa_data[12] = 0xDD;
    s2.sa_data[13] = 0xEE;  // пихаю 1 байт в элемент с номером 13
    
    

    dprintf (1, "s2.sa_family = %hX \n", s2.sa_family );
    for (unsigned short int i=0; i<sizeof(s2.sa_data); i++) {
	dprintf (1, "s2.sa_data[%hi] = %hhX\n", i, s2.sa_data[i] );
    }

вижу на экране

s2.sa_family = AAFF 
s2.sa_data[0] = 1
s2.sa_data[1] = 2
s2.sa_data[2] = 3
s2.sa_data[3] = 4
s2.sa_data[4] = 5
s2.sa_data[5] = 6
s2.sa_data[6] = 7
s2.sa_data[7] = 8
s2.sa_data[8] = 9
s2.sa_data[9] = AA
s2.sa_data[10] = BB
s2.sa_data[11] = CC
s2.sa_data[12] = DD
s2.sa_data[13] = EE


также я замечу что структ это не поинтер. тоесть есть пременная тип поинтер а есть перменная
не поинтер. в чем разница. когда си конвертрует нащ текст в ассмеблер то  если в тексте на
си указана перменная непоинтер то делается вот так. берется адрес в памяти. далее там выдадется
то число байтов которое занимает перенная. и туда пихается значение.
например 

   int a = 0x10;

у нас int это тип размером 4 байта потэтому на ассбелере это будет наппример вот так

   mov eax, 0x10; \\ заносим в eax занчение 0x10
   push eax;      \\ суем значение в cтек. 

теперь наша перменная хранится в стеке по адресу (ebp-4)
тогда доступ к этой перменной будет вот такой
  
  lea eax, ebp-4; \\грузим в eax адрес который хранится в ebp  минус 4 байта
  mov ebx, [eax]; \\ грузим в ebx то что хранится по адресу ebp-4


если же мы создаем поинтер то мы его неможем созать без превариельного создавания 
самой перенной куда он укзазывает

  int a = 0x10;
  int *p = &a;

на ассебелере это будеттакой же код но добавится

  sub esp,4       \\сдвигаем верх стека там мы будем хранить поинтер
  mov [esp],eax   \\коприруем в стек по адресу esp адрес который записан в eax 
                  \\ а  в eax у нас лежит адрес пеерменной a




теерь когда мы разобралист со стркутом  с точки зрения си языка то 
теперь поймем для чего испльзуется этот структ. для каких данных. какой задачи.
структ как пременная используется чтобы предать парамтры в фунукции работы с сетью
такие как bind() , connect() , sendto(), 


	int bind(int socket, const struct sockaddr *address,
           socklen_t address_len);


	int connect(int socket, const struct sockaddr *address,
           socklen_t address_len);


	ssize_t sendto(int socket, const void *message, size_t length,
           int flags, const struct sockaddr *dest_addr,
           socklen_t dest_len);



где хрени вида
   const struct sockaddr *dest_addr
означают что в функцю нужно подсталять перменую которая имеет тип поинтер. а
этот поинтер имеет тип  const struct sockaddr
тоесть поинтер указыает на перенную котоаряа имеет тип  const struct sockaddr
тоесть например вот так

   struct sockaddr s1 ;       \\ создаем перееменную s1  с типом sockaddr
   struct sockaddr *p = s1;   \\ создаем поитер на перемнную s1


и уже этот поинтер p подставляем в функцию bind() вторым аргументом

   bind(arg1, p, arg3)

тоесть функция требует всталять в аргумент именно поинтер.
если мы не хотим создавать поинтер p в явном виде то можно заставить комлилятор
при взыовае фунции подтсавит адрес перееной s1 без создаия поинтера.

   bind(arg1, &s1, arg3)

но в любом случае у нас вторым аргументом будет вставлен адрес прееменной s1. 
подчеркиваю будет вставлен АДРЕС. второй аргумент это адрес. 

ну сейчас пока можно забыть про поинтер. важно куда он укзывает он укзывает на 
адрес где лежит переменная которая имеет тип struct sockaddr.
поэтому ппреед вызовом фукнции нам нужно сзооздать перменну с этим типом. 
а для этого нам надо понимать что это за тип.

далее. я поясню в чем разница между типами

	struct sockaddr s1;
	const struct sockaddr s2;


у s1 и s2 тип совпадает. только разциа в том что у s1 после того как мы туда 
занесли значение то его потом можно и повторно менть.
а если мы занесли значение в s2 то его менять нельзя. система недаст. 
он станет константой. не в том пане что числом. а втом плане что эта область данных
запрещена для модиицикации. тоесть мы один раз задаали значение и оно на всем 
порлтятяжении работы процесса бошльше менять неьльзя. зачем так делать. 
это можно делать для того что при подтставлнвокке пременнйо в функцию то функция может
случайно поменяь знаечение в этой пермтенной. а если мы в йукнцию пихаем константу то
фнкция может ее чиать но при все желении она не может ее менять. это такая зашита от того чтобы
фунция не поменяла эту пременную(котраря называется констаанта). 



далее. теперь вопрос а что же физически  хранится в этом структе? какие данные?
если мы говорим про использование этого  структа для фукнции bind() то у нее три 
параметра. первый это дескрптор сокета. второй параметр это наш поинтер наш структ и третий 
параметр это длинна этого структа. тоесть


  bind(дескриптр сокета, поинтер на наш структ, длинна структа)

спрашивается а зачем фнкции предвать размер нашего структа.
а дело в том что у нас тип поинтера который мы пишем в текте программыы это лишь инфорация
для компилятора. чтобы он на стадии создания кода следалил чтобы мы работали с типами 
чисто и коректно. а когда у нас уже готовый ассебмлкр код то поинтер из себя предстлввяет
всего навсего 4или 8 байт в памяти где лежит адрес на перменную. и поэтому если мы в 
фнкцию предаем адрес поинтера то фкнция имея этот поинтер никак не может опредеить какой
размер данных лежит по адресу за этим поинтером. это только комплиятор на стадии комплицяии
знал что поинтер указывал на преенную такого типа тоесть таокго размера. поэтому если мы 
преедаем в фукнцию поинтер то обычно отдельым аргументом преедется размер той структуры на который
этот поинтер указывает. чтобы фкцния знала сколкьо байт отттуда считывать!
единсвтнное замечение такое что вообще то функция же явно нам сообщает на какой тип поинтер
обязан указывать и будет странно если мы будем пытаться фкнции подсунуть поинтер на 
какойто левый тип. по крайней мере компиятор нам этого не даст при создании ассеблере коода.
поэтому по идее фкцния просто обязана читать то число байтов которое соотсвуетствует 
этому типу данных. тоесть если фкуцния заранее предполоагает что ей передали поинтер на тот
тип данных котоырй она укзаыает в своей специификации то нафиг ей нужен еще в явном виде
аругмент который разльянсяе размер типа данных на котоыйр указывает поинтер мне неочень ясно.
ладно.

так вот первое поле это декрпитор сокета. а второй поле поинтер на наш структ.
так вот что делает bind() она берет настройки указанные в нашем структе и с помощью ядра
пропсиывает эти настройки на этом сокете. а что же за настройки прописываются на сокете?
ну это часть параметров которые нужно знат ядру чтобы понимать какие пакеты из тех что 
прилетают или улетают из  компа нужно обрабатывать через указанный сокет.
дело в том что при работе с сетью наш процесс создает сокет. после того как он создан.
он как я его называют он голый. да он имеет некоторый тип. но в нем нет кучи параметров.
поэтому он не готов для работы. потому что что такое сокет. это кусок в паямти ядра
где будут находится и обрабываться некоторй пакеты из тех что влетают или вытелают из 
компа. так вот ядру нужно знать какие именно пакты нужно совать именно в этот сокет. 
а пока что наш сокет и сам об этом незнает. чтобы задать какой поток пакетов нужно
обарбывать на этом сокете - нужно внести  в сокет доп настройки. и эти настройки
туда вносятся по частям. одна из таких частей это вызов фкнции bind()
она читает из sockaddr часть этих настроек и сует их в сокет. но это будет еще не все
настройки. а только часть. но все равно хояття бы част настроек bind() туда сует.
у кажого сетевгого пакета обычно есть две части. одна часть идентиацирует параетры
нашего компа. а вторая часть идентиицфирует удаленный комп. так вот  bind( ) он указвается
ядру как выглдяит та часть пакета которая иденатциииурет наш комп. для примера. положим
мы работтаем с tcp+ip содеиненеим. тогда нам пакет содержит две части

первая часть IP нашего компа и tcp порт нашего компа
втоаря часть IP удаленного  компа и tcp порт нашего компа

так вот bind() он пропиывает на сокете в данном прмиерер   IP нашего компа и tcp порт нашего компа
и получается что ядро уже знает половину того как должен выгядеть сетеоовой пакет который будет
обарбываться на этом сокете. далее вызываются уже друигие команды котоыре пропиывают на сокте
вторую часть в пакете.  если у нас слушающих сокет то вызыватся listen() а если мы делаем
исходящий конект то ызывается connect()  и вот каждоая из этих фукций допиывает в сокет
вторую часть как выглдяит сеетеовой пакет. и тогда сокет получает полный набор данных для ядра
как выглядит сеетвой пакет. и грубо говоря наонец сокет можно исползовать и через него делать
сетевой конект и гонять через него сетевые пакеты. а наш процесс может рабоатт чеез эттот сокет
с сетью. это не совсем так но нехочу щас углулблсятся. наш сейчас фокус на самом структе SOCKADR

также важнопонять что в SOCKADDR если там содержится ip адрес а такое есть не всегда. то там
не вседа содержится адрес нашего компа. в ряде случаев там содержится адрес удаленного 
компа. а сокет для обрабоки потока требует два IP адреса. вторйо ip адрес попадает в настойки
сокета через вызывы других фукнций которые могут использовать этот структ иди другой структ.
тость я хочу скаазат то что чрез SOCKADDR мы можем преедть в сокет только часть нужных ппрамтеров
но не все. и то что если в sockaddr соедржится ip адрес то в одних случаях это dest ip 
а вдругих это source ip. у этго срукта  у него два поля


  struct sockaddr {
           sa_family_t     sa_family;  2  байта      /* Address family */
           char            sa_data[]; 14  байт       /* Socket address */
       };


содерижимое второго поля очень завсиит от содержимого первого поля. 
в первом  поле мы укаываем грубо говорят тип будущего сетевого соеиенеия. 
а во втором поле уже параметры (часть парамеров) для этого типа сетеового соедиенения.
так вот коечно же тебе уваажемый читатель хочется увидет конкретный примеры что же пихается
внутрь этого структа потому что пока что слишком много тумана. так вот как я счииаю что 
фнкции bind() и прочие котоыре треюует  в себя поинтер на этот структ они на самом деле
с этим структом нихуя не рабоают. и им абсолютно насрать на формат данного структа. да
в этом огромный прикол который я выяснил. поэтому нам и ненужно знать а что и как нужно было 
бы запиывать в этот структ. я щас оьясню. для начала я обяснию вспомогателный момент 
для понимамания. в си есть такой прикол. можно создать переенную создать на не поинтер. 
а потом можно на этот же адрес создать другой поинтер в котором пропсать что якобы он 
укзывает на перменную друогого типа.  показыаю


    int a = 0xAABBCCDD;
    int *p1 = &a;

мы создали перменую "a" котоаря скажем сидит по адрсу 1234 и в этмо адресе сидит 4 байта
в котоых записано число 0x10AABBCC .  впамяти это вбудет выгдядтеь вот так

  1234 0xDD
  1235 0xCC
  1236 0xBB
  1237 0xAA

(напоминаю что если у нас многбайтовое выржание то в памяти в младщий адрес запивыается самый
младщий байт) поэтому если у нас на бумаге число выгдядит как 0xAABBCCDD
а в памяти оно лежит наоброт как DD BB CC AA

так вот мы создали перменую котоаря скажем сидит по адрсу 1234 и начиная с этого адреса
сидит 4 байта данных.  адрес 1234 созраен в переменной p1
теерпрь я делаю вот так

	long int *p2 = (long int*)p1;

этим я создаю поинтер p2 в который будет записа адрес 1234 но мы комплятору говорим о том
чтобы он считал что якобы по адресу 1234 лежит не 4 а 8 байт. 
вот эта скобочка справа (long int*) она очень нужна без нее будет ошибка. без нее

	long int *p2 = p1;

комплиятор выдаст ошибку что мы пытаемся слева создать поинтер на один тип перменной
а справ у нас стоит поинтер на другой тип перменной. и самим поинтерам по барабану.
просто комплиятору не все равно.  так вот скобочка (long int*)p1 причем вот так тоже 
нельзя делать будет ошииька (long int*) p1
так вот скобочка это называется CASTING и она обязывает компилятор насрать на то что справа
стоит поинтер не того типа. она как бы говорит комплиятору (слушай чувак считай что после скобочки
стоит поинтер именно того типа который мы указали в этой скобочке). 
еще раз поясню что когда мы укаывзем тип  у поинтера то  сама перменная p2 она в памяти как занимала 4\8 байт содержа в себе просто напросто адрес на переенную так она и будет содержать то есть комплятор
он содвая поиентер он в нем тип переменной на которую он укзывает не сохраняет. поинтер 
физчиски тлоько содержит адрес  и все. а тип который мы укаызваем используется тлоько компидятором
на стадии компиляции чтобы удержать програмиста в коде програмровать хуйню. тем не менее
вот такую хуйню компятор разрещает делать. чтобы у нас было два поинтера. которые укзывают
на одну адрес паяти. и один поинтер будет говорит компиятору что там лежит 4 байта данныъ
а втррой говоиит что там лжеит 8 байт данных.  где эта хрент может пригодиися?
ну например воттакой глупый случай.
мы создаем перремнную 4 байта длинной. и делем на нее поинтер.

   int a = 0xAABBCCDD;
   int *p1 = &a;

а потом мы хотим прочитать из этой области данных только первый самый младщий байт.
тогда можно сддеть вот так

   char *p2 = (char *)p1;

тогда можно будет напечать этот первый из четырх байт лежащий в памяти вот так

   printf("%hhX \n", *p2);

на экране мы увидим тлько наш DD

тоеесть вот эта хрень *p2 она заставить коплиятор создать такой код на уровне асемблера
что будет считано из адреса (харняящегоося в поитере) только один байт. и этот байт будет
подставлен в принтф.  

вот эта хрень *p2 назвается  pointer derefrence. она говорит комплияттору чтобы он на этом
месте создал ассмебелер код который считаем данные из области памяти начиная с адреса 
укзаанного в поинтере. и момент истины состоит в том что сколко байт будет считано. а будет
считано то число байт которое указанов типе переенной при обявлении поинтера.
тоесть если при создании поинера указано вот так

int *p1 = ...

тоесть int, то  при *p1 будет считано 4 байта.
а если поитер был создан вот так

char *p1 = ...

то операция *p1  привеет к тому что копилтятор породит такой асебмлер код что будет
считано по тому же адресу всего 1 байт. таикм образом тип потера важен тем что 
он обьянсят комдиятору какой асеблер код нужно генениррвать если мы даем команду 

  *p1 

котоаря по руски значит что нужно считать из памяти содержимое которое хранистя начиная
с адреса указаноого в поинтере. и непонятно сколько байтов то нужно считать 1 или 10001.
это и здаает тип указанный при обьявлении поинтера.

тут важно уппоунять плодьбеку синтактсиуса си. такая же поббьема имеет место с массивами.
если мы пишем b[10] при обябвлении массива

   int b[10]

то число 10 заадает число элементов. а ели мы пишем b[10] уже полсле обьяление массива 
то [10] означает номер элементам массива

  b[10]  означает что мы хотми посмтреть соедежромое 10-го элемент массива.

так вот такая же хуйня есть и споинтерами.
если мы обьялвелем поинтер то хрень *p ничего незначи, точнее она значит то что перменная
p это поинтер. 

   int *p = .... 


а если мы юзаем *p уже после оббявления поинтера то *p означает нечто совем друное. 
а именно "эй компилятор сходи по адресу указаному в поинтере и счиатай ка сюда те байты
которые там хранятся. число байтов которое надо считать посмотри исходя из типа котоырй 
был укзан при обьявлении поинтера"!

поэтому нотация *p имеет два оазных значени в тексте на си . суки


так вот я кратко обозначу на счет SOCKADDR. в bind() мы передаем поинтер на нее.
так вот как на самом деле делают люди. они создают переменную у которой тип не sockaddr 
а другой тип. они заполняют туперемнную данными. и создают на нее поинтер. 
а потом они создают новый поинтер и говорят чтобы копитоор счиал что якобы по тому адресу
лежит структ SOCKADDR.  далее этот поинтер скармливыается в bind() , этот бинд он заранее
знает что ему передали поинтер на саоммо деле на другой тип по видом поинтерана  sockaddr
поэтому bind анализирует первые два байта по этому адресу . и на оснвое этого создает
свой поинтер в которого будет исходный тип на эту область памяи. например 

 создаю 
    struct sockaddr_in6  sa1    = ....;
    struct sockaddr_in6  *p_sa1 = &sa1;
    struct sockaddr      *p     = (struct sockaddr*) p_sa1;
    bind(..., p, ... )

код bind анализиует первые два байта. и понимает что на самом деле это поинтер на
sockaddr_in6 и он делает обратное преобразование

    struct sockaddr_in6  *p2     = (struct sockaddr_in6*) p;

и далее bind() испоьзует p2 для работы. как видно sockaddr чисто служит как фейк. 
я еще вернусь к этому вопросу подрбнее. спращивеся а зачем нужна такая хуета?
нужна она потому что при копиляттор при вызываео фукцнии проверяет совпдаение типов данных
у заголовка фукцнии и у аргумента. так вот для разых типов сетевых соденеиний у нас 
структ для сокета будет иметт разный размер и разный вид. вот я щас покажу

вот структ для IPv4 (+tcp\udp)

  struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };

вот структ для IPv6 (+tcp\udp)


       struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };

у них разные поля. разные хрени. разный размер.
и  с обоими структами должен bind() работать. но в специифкации bind мы должны указать 
тлько один тип аргумента. один тип структа. поэтмоу в специиццаии укызвается некйий фекйвовый
структ. чсто только для того чтобы коипилятор на стадии компдияции неругался.  потому
что в обих случаях по факту у нас всего навсего в фкнцию будет пеередан адрес. 
а потом успешно пройдя компдиицию от компиятора. и получив адрес уже функция анализирует
какой реальный структ кроется за этим фейквым. и исправляет. я так ссчитаю зачем и почему
и как это рабоает и зачем нужен структ sockaddr

и едиснвнное треования к sockaddr и другим струкатам это то что первые два байта увсех 
структов которые мы будем юзать должны быть по спецификации одинакоыве. тоесть
вот смотрим и сравнивем  вот два реальных структа 

       struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };

       struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


и вот этот фековый структ

 struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


и мы видим что первое поле у них у всех ПО ТИПУ одинаковое sa_family_t. поэтому через него
и происходит идентиацификация истиинного типа структа. ну итакже я напоминаю что у нас вместе
со структом поинером преедается в bind() и размер структа в трететем аргументе. а размер 
струкаттоже многое говорит о том что это за структ. потому что 

sockadr_in имет размер 16 байт
а 
sockadr_in6 имеет размер 28 байт. 

поэтому если  в фунцию посутил поинтер. и поступило что размер перенно на которую он ссылается
равен 16 значит это вреальности структ на  sockadr_in а если рамзер равен 28 то это поинер
на структ sockadr_in6

иначе всю эту шарманку не обьяснить.
если мы возьмем код програмы то мыувидим. 
чловек создает структ  sockadr_in6 для буудущего ipv6 конекта. этот структ имеетразмер 28 байт.
потом он на него создает поитер с типом sockaddr а мы знаем что этот тип имеет длинну 16 байт.
и этот поинтер передает в bind() . если бы бинд  в реаьности работал бы с этим поинтером
считая что за ним сидит sockaddr то он бы прочитал какакото мусор в размере 16 байт из 28 
необбхоимых. поэтмоу я считаю что  структ sockaddr он не исплзтктя в реаьности биндом. а нужен
только чтобы прскочить передать наш поинтер внутрь фнкции на этапе компилиации и все.



