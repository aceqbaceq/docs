| sockaddr
| sockaddr_in
| sockaddr_in6


я хочу поговорить про эти структы. они играют фуажаментальную роль 
для функций bind() connect() listen() 
тоесть эти структы играют фундатменальную роль когда наша прога на си хочет с кемто
связаться по сети. 

инфо о них сидит в 

  $ man sockaddr

так вот эти штуки это структы. что такое структ - это такой тип данных. 
дело в том что у си каждая переменная имеет всегда какйто тип. это нужно комплиятору
для того чтобы он знал какие ассемблер команды он должен юзать для создания этой 
переменной( в частности  сколько байтов нужно для этой переменной в памяти ) 
и потом какие действия можно делать с этой переменной потом.   напрмиер тип данных int


   int a  = 10;

и этот тип занимает 4 байта в памяти. 
так вот структ sockaddr это тоже тип в памяти.  чем структ отличается от обычного типа (int, 
long int, char) данных - структ имеет внутри себя поля. имеется ввиду не сточки зрения 
ассемлеоа. с точки зрения ассемблера это будет просто кусок неперрывной памяти какйото 
длинннй скажем 16 байт. но для компилятора когда он создает ассемблер код данный тип 
имеет поля. тоесть скажем первые два байта это поле1, следущие два байта это поле2 итд.
с этими полями можно работать в си. к ним можно обращаться . их можно менять. туда можно
писать. читать. говоря с другой строны структ это когда мы берем несколько перменных 
разных типов и обеьединяем их в один кусок в памяти. в том числе в составе структа может
сидеть другой структ. 

посмотрим как она выглядит
идем в  

   $ man sockaddr




   #include <sys/socket.h>

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };





так вот я считаю то что на экране это брехня. структура этой структуры другая.


щас я докажу. идем в sys/socket.h и смотрим что там написано

$ cat /usr/include/sys/socket.h | grep sockaddr -A10
   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
   `struct msghdr', and `struct linger' types.  */
#include <bits/socket.h>


идем и смотрим в   bits/socket.h и смотрим что там написано

$ cat /usr/include/bits/socket.h  | grep sockaddr -A 5
/* Get the definition of the macro to define the common sockaddr members.  */
#include <bits/sockaddr.h>

/* Structure describing a generic socket address.  */
struct __attribute_struct_may_alias__ sockaddr
  {
    __SOCKADDR_COMMON (sa_);  /* Common data: address family and length.  */
    char sa_data[14];   /* Address data.  */
  };


меня интересует вот эта часть

  {
    __SOCKADDR_COMMON (sa_);  /* Common data: address family and length.  */
    char sa_data[14];   /* Address data.  */
  };


причем я замечаю вот эту штуку
#include <bits/sockaddr.h>

иду туда и вижу там вот такое


#define __SOCKADDR_COMMON(sa_prefix) \
  sa_family_t sa_prefix##family


в общем с горем пополам собираю в кучу я считаю что усторойство структа sockaddr 
оно не вот такое


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


а вот такое


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];      /* Socket address */
       };


а это колосальная разница. 
в верхней записи у нас второе поле это флекс массив.
а в моей записи второе поле это массив с фиксиованной длинной. (длина 14 байт)
на данном этапе нужно много понять - что такое массив, что такое флекс массив. 
для этого нужно прочитать "от и до" статью c-array-pointer.txt
идем туда и читаем сверху до самого низа. 
прочитали всю ту статью дохрена узнали. вернулись сюда назад. теперь все знаем
про массивы. типы массивов. флекс массивы. поинтеры. 

теперь
что я еще имею в качестве дооводов моей версии. можно легко узнать какой размер в байтах
для типа sa_family_t

  printf ("%i \n", sizeof(sa_family_t) );

на экране 
  2

так вот если первое поле это 2 байта и если второе поле это флекс массив
как нам пишет мануал 


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


то тогда если я спрошу размер этого структа то размер флекс массива считается равным 0
и тогда размер всего структа вылезет как 2. 
а если устройство структа такое как я сказал 

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];      /* Socket address */
       };


то размер структа будет 2+14=16 байт.

проверяем

  printf ("%i \n", sizeof(struct sockaddr) );

на экране
  16

из чего я еще раз делаю вывод что состав структа sockaddr это вот именно такое

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];    /* Socket address */
       };



итак первое поле этого структа это переменнная типа с фиксированной длинной. 2 байта.
второе поле это массив с фиксрованной длинной
тип каждого элемента char (тоесть 1 байтдлинной) и элементов 14 штук

		char vasya[14]

это при условии если мы будем создавать переенную с этим типом путем статического создания.
если мы будем создавать переенную с этим типом динамическим путем то у нас тело массива
будет не 14 элементов а любое число элементов в завсимости от размера тела в памяти выделенного
под эту переменную. показываю на примере
создаем пременную статическим путем

  struct sockaddr sa1;

в этом случае наш sa1 имеет тело в памяти длиной 16 байт и второе поле имеет 14 элементов.

теперь создаем переменную димамическим путем

  struct sockaddr *sa2 = malloc (100);

в этом случае у нас тело переенной имет длину 100 байт. из них 2 идет на первое поле. 
а 98 идет на второе поле. и значит в массиве будет 98 элементов. 
вот такой момент.


а теперь еще один важный момент. у нас же поинтер на этот структ передается в конечном
итоге в ядро. и по идее внутрнее устройство того или иного структа задается внутри ядра. 
оно является архитектором внуттренностей структов. а скажем libc должно отражать в точности
архитектуру структов. так вот я нашел статьью

    https://lwn.net/Articles/997094/

между прочим она от 7 ноября 2024 года. тоесть свежак

так вот судя по статье в ядре данный структ определен на самомо деле по другому


    struct sockaddr {
        sa_family_t sa_family;
    union {
        char sa_data_min[14];
        DECLARE_FLEX_ARRAY(char, sa_data);
    };
    };


где  DECLARE_FLEX_ARRAY() macro jumps through some hoops needed to declare a flexible array within a union.

что по мне в упрошенном виде можно примерно вот так интерпетировать

    struct sockaddr {
        sa_family_t sa_family;
        char sa_data_min[];
    };


ровно то как об этом пишет man sockaddr. но это с точки зрения ядра. потому что 
с точки зрения libc структура имеет другой формат. вот что важно. и в чем прикол. дебильный.
единсвтенное что второе поле это не совсем флекс массив. а это флекс массив но у него есть
минимальный размер 14 байтов. меньше его он быть не может но может быть болльше.

и вот по мне то как sockaddr трактуется внутри ядра обьясняет офигенную загадку. 
а загадка вот в чем - я там ниже буду это рассматривать а щас пока наброски по главное.
если посмотреть на функции которые работают с сетью наример это bind()

 int bind(int socket, const struct sockaddr *address,  socklen_t address_len);

так вот видно что второй аргумент это поинтер на sockaddr

как я уже сказал с точки зрения libc структура сокаддр имеет два поля и второе поле
это массив 14 элементов длинной. 

дальше вот что важно. когда в реальной программе на си пишут код который должен сделать конект
через сеть. то данные не заносятся в переменную с типом sockaddr. данные всегда заносятся
в другие структы. например в структ sockaddr_in6 он имеет вот такую структуру

    struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


эта структура по своей длинее имеет чтото вроде 28 байтов. ее в программе заполняют.
а потом делаю непонятный ход конем. берут и говорят что поинтер который укаызвает на эту 
структуру надо считать что якобы в теле этой переменой находится другая структура а именно
структура sockaddr.
щас покажу на примере

  struct sockaddr_in6 sa1; \\ создали переменную
  sa1 .......  \\ заполняем ее поля
  struct sockaddr_in6 *p1 = &sa1 \\ создаем поинтер на sa1
  struct sockadd  *p2 = (struct sockadd  *)p1 \\ самая фишка

в последней строке происходит прикол. мы создаем поинтер p2 который укаывает на тело
переменной s1 но при этом мы утрвеждаем что поинтер p2 указывает на тело переменной
которая имеет тип sockaddr
это ж какой то бред. сравним эти две структуры


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];    /* Socket address */
       };



    struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


у нас у этих двух структура совпдает только первое поле. точнее его тип. это 2 байта.
а дальше полнейшее разногласие. и длина же не совпдает 14 байт  занимает второе поле
у sockaddr с точки зрения libc и 26 байт занимают все поля начиная со второго у sockaddr_in6
получается каакйоото дебилизм. мы готовим в памяти блок из 28 байт. а потом мы его обзываем
как бутто там сидит хрень из 16 байт. это же обрезание какоето. имеется ввиду с точки зрения
интепретирования. от того что мы создаем поинтер другого типа который укыывзает на туже 
область данных от этого сама область данных никак не меняется. 
но походу разгадка именно в том что в ядре sockaddr имеет другую струкутуру с точки 
зрения ядра чем с точки зрения libc



    struct sockaddr {
        sa_family_t sa_family;
    union {
        char sa_data_min[14];
        DECLARE_FLEX_ARRAY(char, sa_data);
    };
    };


c точки зрения ядра второе поле неограничивыается по длинее 14 байтами. а имеет размер 
минимум 14 байтов а максимум хрен знает.
поэтому у нас же код bind() выполняет в конечном итоге ядро. и мне кажется что код ядра
в итоге смотрит на первое поле которое имеет одну и туже длинну что у sockaddr что у 
sockadr_in6. смотрит что там написано. и интепретерирует остальные байты исходя именно из
значения первого поля. мне кажется в самой простой интепретации я считаю что это должно работаь
так. ядро анализиуерует первое поле. обнаруживает что оно равно AF_INET6 и исходя
из этого понимает что на самом деле нам подсунули sockaddr_in6 и ядро создает на лету
новый поинтер вот такой

  struct sockaddr_in6  *p3 = (struct sockaddr_in6  *)p2

где p2 это поинтер который был передан ядру. и таким образрм мы в программе готовили област
памяти как  sockaddr_in6 и ядро начинает видеть этотже кусок памяти ровно также как sockaddr_in6
мне кажется что тип sockaddr нужно только для того чтобы разные типы соакдров можно было в функцию
"передавать" используя единый тип. ведь аргумент у фукцнии должен иметь тип. он один. поэтому
был придуман фейковый или траспортный вид структа чисто для компилятора. потому что он 
сравнивает какой тип пеерменной пеедается в фнукцию через аргумент и совпадает ли тип этой
переменной с типом арумнта пропсианный в прототипе фукцнии. поэтому тип sockaddr это такой тип
фуфло. мы готовим область памяти на основе реального структа который отвечает данному типу 
соединения. например для ipv4 это sockaddr_in4, для ipv6 это sockaddr_in6 итп. потом мы 
через кастинг типов создаем поинтер на эту же область "пропаривая" компилятору что якобы 
поинтер указыает на sockaddr область. это дает возможно просунуть в функцию наш поинтер.
иначе бы пришлсь писать несклько видов фукнции bind() где вторым аргуметом были бы вот
эти конкнерерктные структы  sockaddr_in4 или  sockaddr_in6
а потом ядро исследуя перые 2 байта этого поинтера точнее первые 2 байта туда куда он укзывает
ядро понимает какой на самомо деле структ скрывается за маской sockaddr
мне кажется так ето работает. и так это обьясняет вот эту хрень с sockaddr
иначе это все чушь собачья. потому что мы подгтоваливаем в памяти тело с данными в соовтесвтиии
со специифкацией одного структа. а потом поинтер на эту область обвяляем с типом совершенно 
другого структа которй вобще не совпдаает с нашим структом. и по полям и по длине. едиснвтенное
что совпдает это первые 2 байта и все. 

поэтому теперь далее я пока отхожу от расстривания структа sockaddr
и посмотрим на структ sockaddr_in4 точнее он наываеся sockaddr_in



   struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };




но
прежде чем двинуться дальше со структом я расакажу как в целом работает установление
сетвеовго конекта в линукс. создается в памяти ядра кусок называется сокет. в нем будут находится
буфреры отпраки и приема из сети и всякие другие хрени которые нужны ядру чтобы обарабывать
некоторый конкрертный поток из сети. тоесть поток пакетов будет ядром приниматься из карты
и скалдыавться в сокет. а оттуда его будет читать процесс. и наоборот процесс пихает сво 
байты в сокет. а оттуда их берет ядро и пихает в сеть. прикол в том что  кода мы созаддаем
сокет то он полупустой - тоесть в нем нет кучи параметров.
сам сокет создается нпример вот так

		socket(AF_INET, SOCK_STREAM, 0)

после такой команды будет создан сокет и у него  уже будет часть настроек а именно
о том  что он будет обрабатывать ipv4+tcp поток. 
но этих параметров еще не достаточно ядру чтобы понять какой конкретно поток нужно совать 
в этот сокет. нужно как минимум еще две пары параетров. а именно IP:port на нашем компе
и IP:port на удаленном компе. так вот чтобы  программа могла обмениваться по сети ей нужно 
записать недотстающие параметры сетвого потока в сокет. тогда ядро будет точно значть какой
имнно сетевой поток нужно совать на этот сокет. и наша програма наконец получит доступ к этому
сетевому потоку через этот сокет. еще раз скажу что у нас есть много видов сетвы х потоков
и если мы хотим чтобы наша прога имела досутп к какмуто кнокрентному сетеовому потоку нужно об
этом обьяснить ядру. обьяснение начинается с того что мы создаем сокет. и при его создании
он имеет три аргумента. все эти три аргумента позволяют уже описать ядру некоторую часть 
всех параметров нужного нам сетевого потока. поэтому говорят был создан такой то тип сокета. 
сокет у нас тот же самый все время. только у него менятся параметры при которых он создается.
после создания егоные три параметра менять нельзя.  тот сокет котоырй я создал выше
он говоритт ядру что наша прграмма хочет получит достуа к сеетовому потоку с параметрами
ipv4+tcp.  но это все равно еще н еполное описание. остается передать в ядро насторйки
такие как IP:port нашего компа и IP:port уадленного компа. тогда ядро уже узнает все что
надо и начнет пихать сетеовой поток из сети в соккет. а из сокета прогармма сможет получать
этот поток в свою память. и наоборот - прграма будет пихать свои данные в сокет а ядро удет
оттуда их брать и пихать в сеть.  так вот IP:port нашего компа суется в сокет путем того 
что эти параметры записваются нами в структ SOCKADDR_IN. а потом мы создаем поинтер у которого
тип sockaddr и заставляем этот поинтер указыывать на нашу переменную которая имеет тип SOCKADDR_IN
и пихаем этот sockaddr поинтер в функцию.  этот поинтер пролезает в функцию. она анализирует
первые два байта в памяти куда указывает поинтер. видит там AF_INET понимает что мы имеем дело
с ipv4 и (как я понимаю) делает кастинг и меняет тип поинтера обратно на SOCKADDR_IN ,
далее ядро считыает параетры из sockaddr_in , и пихает их в сокет. 
вот пример как это происходит на практике в коде


    s = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(6789);
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");

    bind(s, (struct sockaddr *)&addr, sizeof(addr));


можно тоже самое но чуть по другому 343.c



    int s = socket(AF_INET, SOCK_STREAM, 0);  // создаем сокет

    struct sockaddr_in *addr = malloc( sizeof(struct sockaddr_in) ); // создаем поинтер на структ
                                                                     // причем мы не только поинтер создаем но и 
                                                                     // создаем тело в памяти на который указывает поинтер
    addr->sin_family = AF_INET;   // вбиваем в него параметры
    addr->sin_port = htons(6789);
    addr->sin_addr.s_addr = inet_addr("127.0.0.1");


    struct sockaddr *addr2 = (struct sockaddr *)addr; // создаем новый поинтер 
                                                      // который указывает на ту же память
                                                      // но якобы там лежит структ sockaddr
    bind(s, addr2, sizeof(addr));


очень важный момент вот в этой строке
struct sockaddr_in *addr = malloc( sizeof(struct sockaddr_in) );

потому что обяазтельно справа должен стоять маллок. щас я обьясню почему.
если я просто создам поинтер вот так
struct sockaddr_in *addr;

то компилятор создает в памяти поинтер. выделяет для него 4 байта в памяти. но внутри этих 
ячеек нет значения! там либо нули. либо там какойто мусор. тоесть у нас создано тело перменной
но она не проиницлиазированана. тоесть в ее тело не присвоено значение. положим там просто 
лежат нули. тоесть поинтер как бы равен addr=0
так вот дальше я начинаю пихать данные в ту область памяти на которую укзывает поинтер.
тоесть по адресу 0x0 я начинаю пихать даннные

    addr->sin_family = AF_INET;  

тоесть я начну пихать данные в тот адрес памяти куда мне никто пихать не разрешал.
поэтому я получу segmnetation fault

именно поэтому важно непросто создать поинтер а еще аллоцировать в памяти кусок. и начало
адреса этого куска записать в поинтер

struct sockaddr_in *addr = malloc( sizeof(struct sockaddr_in) );

вот тогда в поинтере будет записан некий адрес 1234 куда уже можно записывать.
и поэтому когда мы начнем писать

    addr->sin_family = AF_INET;  

то уже никакого сегментейшн фолт не будет.

для сравнения в том куске кода который я привел повыше
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;

там ненужно было делать маллок потому что мы создавали переменную тип структ а не поинтер
на структ. поэтому у нас комптлилятор он при создании addr он сам автоматом выделил в памяти
кусок под тело этой переменной. поэтому то маллок и ненужен. 
итак я еще раз повтрорю этот тезис - если я создаю переенную статическим способом. то 
для нее тело в памяти выделет коимпилятор. и маллок при этом ненужен.

    struct sockaddr_in addr;

а если я создаю поинтер. то под сам поинтер комплиятрор конечно выделит память. но поимомо
поинтера нужно создать в памяти блок на который этот поинтер будет указывать прежде чем
мы ссможем этим поинтером начать пользоваться. поэтому нужно юзать справа маллок

    struct sockaddr_in *addr = malloc( sizeof(struct sockaddr_in) );

ну либо же если я создаю понтер то можно не юзать маллок но тогда надо создать пременную
на которую он будет ссылаться в явном виде вот так

    struct sockaddr_in addr;
    struct sockaddr_in *p_addr = &addr;

либо

    struct sockaddr_in addr;
    struct sockaddr_in *p_addr;
    p_addr = &addr;


далее уже по тексту кода
я создаю новый поинтер который будет указвыать на тотже блок в памти который мы заполнили
до этого. но мы утверждаем что якобы в том куске памяти лежит sockaddr 
хот там по факту лежит sockadr_in
    struct sockaddr *addr2 = (struct sockaddr *)addr;

но мы делаем такой дебилизм чтобы просунуть наш поинтер в функцию маскируя наше тело под 
другой тип структа.

и вот наконец мы вызываем функцию bind

  bind(s, addr2, sizeof(struct sockaddr_in));

тут важно заметить кусок  sizeof(struct sockaddr_in) 
дело в том что нужно внутрь bind нужно передать реальную длинну тела переменной на которую
указывает поинтер. тоесть хотя у нас формально addr2 указывает якобы на область в памяти
которая имеет длинну sockaddr но это же наебка. поэтому важно что мы внутрь бинда сообщаем
настоящую длинну тела на которое укзывает поинтер. то мы сообщаем что поинтер указывает
на тело длиннной sockaddr_in а это большая разница. если бы в формуле написал вот так 

  bind(s, addr2, sizeof(*addr2));

то это была бы хуйня. потому что при опредеелении размера тела переменной то комплятор
опирается на тип который укаазан в свойствах переенной. так как у нас addr2 заявлно что укзывает
на sockaddr то размер *addr2 будет равен размеру sockaddr хотя по факту мы знаем что размер
*addr2 у нас равен размеру sockaddr_in 
еще раз я хочу обьяснить вот что. если я сделаю вот так (для примера)

    struct sockaddr_in *addr = malloc( 100 ); 

и если я напишу sizeof(*addr) то компилятор нам выдаст 16 тоесть размер sockaddr_in
а не 100. потому что когда компилятор опреееляет размер тела на который указыает поинтер 
то компилятор отталкивается не от реального размера тела переменной а от типа который указан 
в свойствах поинтера. 
так вот мне нужно внутрь bind передать реальный размер тела на который указывает поинтер.
поэтому  я пишу 

  bind(s, addr2, sizeof(struct sockaddr_in));

потому что мне нужно сообщить внутрь bind что поинтер addr2 указывает на тело размером  sockaddr_in
а если бы я написал sizeof( *addr2 ) то компилятор вставил бы размер sockaddr что нам ненужно
потому что это вранье. потому что тело на которое указывает поинтер имеет длину sockaddr_in

тип sockaddr в addr2 нам нужен как наебка. чтобы просунуть поинтер в функцию. мы просовываем внутрь
функции тело переменнной которая имеет в себе контент согласно формату sockaddr_in но мы 
маскируем поинтер как бутто он указвыает на тело которое заполнено по формату sockaddr
фунукция bind она проанализирует первые два байта тела переменной. увидит там AF_INET и понимает
что по факту тело заполенно по формату sockaddr_in. тогда bind меняет тип поинтера. и работает
с телом как и положено, как оно по факту заполнено по формату sockaddr_in 

в итоге через sockaddr_in мы просовываем в сокет такие настройки как IP адрес и  TCP порт.


можно заметить что у нас к этому моменту все равно часть параметров нужных для определения
конкретного сетевого соедиенения остаеттся неизвестной. а именно это неизвестно 
параметр IP:port удаленного компа. которые тоже нужно засунуть в сокет. это делается уже
другой командой. и тут два варианта - если мы делаем исходящее соединение  то это 
делается через connect(), но чтобы запустить connect то нужно для него еще раз заполнить
структ sockaddr_in

    addr->sin_port = htons(8080); \\порт куда стучимся
    addr->sin_addr.s_addr = inet_addr("127.0.0.1"); \\адрес на который стучимся

    connect(s, addr2, sizeof(struct sockaddr_in));

при этом конект дописывает вторую пару IP:port в сокет и тут же инициирует сетевое соединение
в сокете унас будет записано что локальный IP+port = 127.0.0.1:6789 и что удаленный IP+port=
=127.0.0.1:8080

показываю полное тело программы


 
    int s = socket(AF_INET, SOCK_STREAM, 0); \\создаю сокет

    struct sockaddr_in *addr = malloc( sizeof(struct sockaddr_in) ); \\создаю поинтер на структ
    addr->sin_family = AF_INET;   // вбиваем в структ параметры локальный IP и порт
    addr->sin_port = htons(6789);
    addr->sin_addr.s_addr = inet_addr("127.0.0.1");


    struct sockaddr *addr2 = (struct sockaddr *)addr; // создаем новый поинтер 
                                                      // который указывает на ту же память
                                                      // но якобы там лежит структ sockaddr

    // вызываю bind он запиываетв сокет   локальный IP и порт
    if ( bind(s, addr2, sizeof(struct sockaddr_in)) < 0 ){
          perror ("bind error ");
          return 1;

    }   ;


    // запиыаю в структ удаленный IP и порт
    addr->sin_port = htons(8080);
    addr->sin_addr.s_addr = inet_addr("127.0.0.1");

    // запиыаю в сокет удаленый IP и порт и создаю сеетвое соединение
    if ( connect(s, addr2, sizeof(struct sockaddr_in)) < 0 ){
           perror ("connect error");
           return 1;
    } ;


    sleep(60);



а вот что мы увидим в сокетах 

$ ss -4tnp | grep -E "Recv|34"
State   Local Address:Port   Peer Address:Port  Process                                     
ESTAB   127.0.0.1:8080       127.0.0.1:6789     users:(("345-server-ipv4",pid=408662,fd=4))
ESTAB   127.0.0.1:6789       127.0.0.1:8080     users:(("344.exe",pid=408661,fd=3))        


сотвесвтенно вторая строчка
она как раз опиывает свойства сокета нашего процесса который создавал конект
ESTAB   127.0.0.1:6789       127.0.0.1:8080     users:(("344.exe",pid=408661,fd=3))        


и здесь видно что в этом сокете параметры как раз точно такие какие мы в него совали
локальный ip и порт это   127.0.0.1:6789
а удаленный ip и порт это  127.0.0.1:8080

если бы я не вызывал bind() то ядро выбрало бы параметр локальный ip и порт само автоматом.



спрашивается а зачем фнкции предвать размер нашего структа.
а дело в том что размер теле перменной на которую указвыает поинтер он известен
только компилятору.  а вот когда уже ассемблер код выполняется и фнкция получает поинтер
то у нее нет инструментов чтобы как то понять какая длина у области памяти куда укаызвает
поинтер. поэтому обычно вместо с поинтером передается и длоинна тела переенной на которую
этот поинтер указывает. 
правда функция же сама знает какой тип аргумента она ждет. тип sockaddr . а значит по идее
размер тела на котоое поинтер указыает фукция должна знать. однако мы то уже знаем что
поинтер sockaddr это такая наебка. что на саммом деле за этим поинтером скрыается поинтер
на хрен знает какую структуру и какая у нее длина неизвсетно. поэтому мы и преедаем ддлину
тела при вызове bind()


итак уже я постарался обьяснить что структура sockaddr это структура наебка. никто такого
типа преенную не создает. никто эту структура не заполняет. если мы хотим сделать ipv4 
конект то мы создаем и заполняем структуру sockaddr_in

      struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };


можно увидеть что она содержит всебе ссылку на другую структуру in_addr 

       struct in_addr {
           in_addr_t s_addr;
       };

так вот заполняется sockaddr_in  , потом создается поинтер на тело этой структуры но при этом
поинтер утвержадает что якобы тело принадлежит sockaddr. итакой поинтер скармиливется 
в bind() или connect() а там эти фнции анализирует контент памяти и обратно преобразуют поинтер
к исходному типу sockaddr_in  поэтому работа идет именно с ним. 
по сути в sockaddr_in вставляется некий IP и порт.  если мы собираемся скорммить sockadr_in
в bind() то тоггда iP и порт относятся к параметрам локального компа. а если мы собираемся 
скормить sockaddr_in в  connect() то тогда IP и порт отноится к параметрам удаленного компа.

если мы собираеся раоботать с IPv6 то заполняем вот такой структ 

  struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


в состав которого входит структ

  struct in6_addr {
           uint8_t   s6_addr[16];
       };


физ смысл sockaddr_in6 в целом такойже как sockaddr_in , тоесть в него суется IPv6 и порт
и некоторые еще детали. а потом это скармилвеися в bind() и\или connect()
при скармилвании опять же мы создаем поинтер который утвержает что якобы у нас  в памяти лежит 
не структ sockaddr_in6 а структ sockaddr.  функции прииимают поинтер. анализируют первые два 
байта памяти и понимаю что там стоит AF_INET6 , и тода понимают что на самом деле поинтер указывает
на структ sockaddr_in6, меняют его тип и работают с памяттью как sockaddr_in6 как и пооложено.


вот такая примерно фигня с sockaddr, sockaddr_in, sockaddr_in6 и bind() и connect()


https://stackoverflow.com/questions/24817642/sockaddr-and-ipv6-address



https://stackoverflow.com/questions/58702609/size-of-struct-sockaddr


https://stackoverflow.com/questions/32596553/sockaddr-structure-sys-socket-h

https://stackoverflow.com/questions/9102453/sockaddr-in-undeclared-identifier



https://gist.github.com/inaz2/0e77c276a834ad8e3131


https://gist.githubusercontent.com/inaz2/0e77c276a834ad8e3131/raw/e7e602c6c64e34572fab43014595a82f718fdae3/server.c




https://gist.githubusercontent.com/inaz2/0e77c276a834ad8e3131/raw/e7e602c6c64e34572fab43014595a82f718fdae3/result.txt



https://gist.githubusercontent.com/inaz2/0e77c276a834ad8e3131/raw/e7e602c6c64e34572fab43014595a82f718fdae3/client.c




https://stackoverflow.com/questions/4160347/close-vs-shutdown-socket

https://stackoverflow.com/questions/11461106/socketpair-in-c-unix



https://superuser.com/questions/1267192/multiple-processes-listening-on-the-same-port-how-is-it-possible

https://stackoverflow.com/questions/35168025/better-approach-for-having-two-or-more-threads-listening-on-same-port


