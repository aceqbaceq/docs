| sockaddr
| sockaddr_in
| sockaddr_in6


я хочу поговорить про эти структы. они играют фуажаментальную роль 
для функций bind() connect() listen() 
тоесть эти структы играют фундатменальную роль когда наша прога на си хочет с кемто
связаться по сети. 

инфо о них сидит в 

  $ man sockaddr

так вот эти штуки это структы. что такое структ - это такой тип данных. 
дело в том что у си каждая переменная имеет всегда какйто тип. это нужно комплиятору
для того чтобы он знал какие ассемблер команды он должен юзать для создания этой 
переменной( в частности  сколько байтов нужно для этой переменной в памяти ) 
и потом какие действия можно делать с этой переменной потом.   напрмиер тип данных int


   int a  = 10;

и этот тип занимает 4 байта в памяти. 
так вот структ sockaddr это тоже тип в памяти.  чем структ отличается от обычного типа (int, 
long int, char) данных - структ имеет внутри себя поля. имеется ввиду не сточки зрения 
ассемлеоа. с точки зрения ассемблера это будет просто кусок неперрывной памяти какйото 
длинннй скажем 16 байт. но для компилятора когда он создает ассемблер код данный тип 
имеет поля. тоесть скажем первые два байта это поле1, следущие два байта это поле2 итд.
с этими полями можно работать в си. к ним можно обращаться . их можно менять. туда можно
писать. читать. говоря с другой строны структ это когда мы берем несколько перменных 
разных типов и обеьединяем их в один кусок в памяти. в том числе в составе структа может
сидеть другой структ. 
так вот переходим к структу sockaddr 


 #include <sys/socket.h>

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };



для начала потсмиотрим какой у него размер


$ cat 320.c
#define _POSIX_C_SOURCE  200809L
#include <sys/socket.h>
#include <stdio.h>


int main() {


    struct sockaddr s1;
    dprintf (1, "sockaddr SIZE = %hi \n", sizeof(s1) );

}


 $ ./320.exe
sockaddr SIZE = 16 

итак размер этого структа 16 байт.

кстати что значит "include"  в тексте программы. это значит что мы хотим в нашем процессе
ммы хотим юзать функции которые входят не в состав нашего текста на си а в состав
другого файла шаред либрари (которая бинарный файл  плюс файл заголовка name.h) и 
наш бинарник будет так составлен компитлятором что при создании процессса из файла нашего
бинарника  в вирт адресное  пространство нашего процесса будут "подгружены"  замаплены
файлы шаред либрари. таким образом наш процессс он как бы включает в себя нетлоько код 
на си который написали мы но еще и код на си который написал ктото за нас. а мы включтли
его в состав нашей программы.

возвращаеися к нашему структу


  struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


щас мы узнаем размер типа  sa_family_t
смотри 320.с
и видим что 

sa_family_t SIZE = 2

итак получается что 



  struct sockaddr {
           sa_family_t     sa_family;  2  байта      /* Address family */
           char            sa_data[]; 14  байт    /* Socket address */
       };

в левом столюике указан тип поля. в правом имя поля. по имени мы обращаемся 
к полям. первое поле

		sa_family_t     sa_family   

это два байта . ну можно считать что это короткий int без знака
имя поля(по аналогии имя переенной) sa_family а его тип sa_family_t 

второе поле

		char     sa_data[]    

это поле имеет длину  14 байт. имя поля sa_data, тип char
что значит обозначение

      char vasya[]

это означает что эта переменная это массив. а что такое массив
это набор отдельных элементов каждый из которых имеет один и тот же тип и эти элементы
собраны в памяти в одну кучку. однако 
обозначение 

	      char vasya[]

это некоретное ошибочнок обозанчние. си прогаимма такое задание поля структа или обььявление массива в качестве переменной не позволит. выдаст ошибку. правлное обьявление массива
всегда выглядит так

		char vasya[14]

тоесть при обьявлении массива мы обязаны указать число элементов массива в скобочках.
vasya это имя массива. и то что левее это штука в данном случае char она обьясняет компиятору
тип каждого элемента этого массива. тип char означае что размер элемент 1 байт.
итак обозаение выше говорит о том что создай массив с именем vasya элемент в массиве имеет
размер 1 байт. и таких элементов в массиве 14 штук. тогда комплитятор создаст асемблер команду
которая создас в области памяти кусок из 14 байтов которые лежат непрвырывно в памяти рядышком.
в масиве еще раз скажу размер его указыается в виде количества элементов.

далее пока мы перехоим в другой документ. где я подробно рассматриваю вспомогательный 
материал касающийся массивов, поинтеров и тому подобнго. читай c-array-pointer.txt

итак мы вернулись  из чтения про массивы, поинтеры, стринги.  теперь посмотрим на 

		char vasya[14]

это получается char массив из 14 элементов. тоесть это 14 переменных каждая из которых
имеет тип CHAR. размер массива 14 байтов.
по сути еще раз скажу что такое этот массив. это 14 штук  переменных собранный в одну 
кучу. каждая имеет 1 байт размер. с каждой из 14-ти мы можем обращаться и работать отдельно
а в чем разница этого массива с масивом

       short int vasya[14]

в том что это тоже 14 перемеменных , с каждой можно работать оттдельно. но кажоая из них
имеет размер 2 байта. массив это как база данных. при создании массива нужно для себя 
решаь какого размера будет каждый элемент. если нужно чтобы элемент был размера 1 байт то
тип CHAR , если нужно чтбоы размер был 2 байта то short int. итп.
тоесть смотрим размер отдельног элеента. и смотрим сколько элементов нам нужно суммарно.
так и создаем массив. предпопжложим в масиве мы будем хрнаить буквы. если это лат буквы
то каждая буква кодрируется одним байтом. поэтому тип CHAR. а если это русские буквы 
то каждая кодируется через 2 байта. поэтмоу это тип short int. если мы хотим поменять букву
то обарщаемся к элементу массива чрез индкс.
поэтому елси мы видим что  у нас задан массив

		char vasya[14]

это значит что внутри него такая инфомация что каждый элемент по своей природе занимает 
1 байт. и таким элементов у нас 14 штук. тоесть предпожложим у нас 14 кошек. и каждяа имеет
имя на основе лат буквы. и мы хотим иметть инфо статстику по их именам. вот для этого мы 
и держим такой массив. можно по другому сказать у нас 14 машин. и кждая имеет цвет который
кодирется числом от 0 по 255. или в hex 0х00 - 0хFF. и мы создаем базу в котрром будет 
отражаться цвет по каждой машине. тоесть этот массив он нам сообщает что есть 14 незавиисмых
сущностей каждая из которых имеет единый признак. и этот признак кодируется одним байтом.
и наш массив это база данных для этих сущностей по этому признаку. тоесть либо цвет 14-ти машин.
либо имена 14-ти кошек. тоесть я пытаюсь передать какой смысл несет такое обявление массива.

еще раз посмтрим на структ

  struct sockaddr {
           sa_family_t     sa_family;  2  байта      /* Address family */
           char            sa_data[]; 14  байт    /* Socket address */
       };


итак первое поле это два байта.
второе поле это массив из 14 однобайтовых элементов. с другой стороны второе поле это просто
напрсто 14 байт. итак в первое поле мы можем сунуь 2 байта. во второе поле 14 байтов.
вот такой структ.


в этом куске я показываю доказываю 
что общий размер структа 16 байт. первое поле 2 байьа
и второе поле 14 байт

cat 320.c
#define _POSIX_C_SOURCE  200809L
#include <sys/socket.h>
#include <stdio.h>
...
...
  //
    struct sockaddr s1;
    dprintf (1, "sockaddr SIZE = %hi \n", sizeof(s1) );
    dprintf (1, "sockaddr  sa_family SIZE = %hi \n", sizeof(s1.sa_family) );
    dprintf (1, "sockaddr  sa_data[] SIZE = %hi \n",  sizeof(s1.sa_data) );

на экране
sockaddr SIZE = 16 
sockaddr  sa_family SIZE = 2 
sockaddr  sa_data[] SIZE = 14 



замечу то что функция sizeof() это чисто директива компилятора. тоесть в самом боевом 
коде нет никакой инфо о размере типов или пеерменных. это чисто комплиятоор зная все типы 
и все перменные подставляет тупо число. 



отмечаю что индексы (оффсет) внутри массива начинатся с нуля.


хочу пояснить про формат dprintf\printf
на примере

    unsigned short int i = 10;
	dprintf (1, "%hhX\n", i );

у нас внутри printf\dprintf есть поле  с кавычкми двойными 

		"%hhX\n"

а есть  аргумент  это 
		
		i


так вот принтф он берет то что хранится в i тоесть байт или байты которые хрантся в 
переной i и потом этот байт какимто макааром отрисоывает на экране. и тут важно понимать
во первых какая длинна в байтах того что хранится в i. а чтоы это узнаиь надо значть ТИП 
переменной i. а для этого найдо найти ту строку где мы ее создавали

    unsigned short int i = 10;

отсюда мы понимает что в i лежит 2 байта. 
так вот принтф он возьмет 2 байта из памяти а далее внутри кавычек указано как эти 2 байта
нужно на экране рисовать 

	%hhX

где %hh означает что наш аргумент должен быть длинной  2 байта
а X означает что эти два байта на экране нужно нарисовать в виде hex числа
тоесть я хочу сказать что коода мы в принтф пихаем перетенные то ихняя длинна должна 
обязательно совпдаать с длинной модиифкиатора внутри кавычек "" иначе будет хуйня.
скажем у нас аргумент i имеет длинну 4 байта. а модиифкатор внутри кавычек трактует его
как 2 байта. поэтому за этим надо следить в принфт. чтобы на экране не получать хуйню.





также я замечу что структ это не поинтер. 

тоесть есть пременная тип поинтер а есть перменная
не поинтер. в чем разница. когда си конвертрует нащ текст в ассмеблер то  если в тексте на
си указана перменная непоинтер то делается вот так. берется адрес в памяти. далее там выдадется
то число байтов которое занимает перенная. и туда пихается значение.
например 

   int a = 0x10;

у нас int это тип размером 4 байта потэтому на ассбелере это будет наппример вот так

   mov eax, 0x10; \\ заносим в eax занчение 0x10
   push eax;      \\ суем значение в cтек. 

теперь наша перменная хранится в стеке по адресу (ebp-4)
тогда доступ к этой перменной будет вот такой
  
  lea eax, ebp-4; \\грузим в eax адрес который хранится в ebp  минус 4 байта
  mov ebx, [eax]; \\ грузим в ebx то что хранится по адресу ebp-4


если же мы создаем поинтер то мы его неможем созать без превариельного создавания 
самой перенной куда он укзазывает

  int a = 0x10;
  int *p = &a;

на ассебелере это будеттакой же код но добавится

  sub esp,4       \\сдвигаем верх стека там мы будем хранить поинтер
  mov [esp],eax   \\коприруем в стек по адресу esp адрес который записан в eax 
                  \\ а  в eax у нас лежит адрес пеерменной a




с точки зрения голого си наш структ это два поля. в первое поле мы можем
сунуть любые два байта. а во второе поле мы можем записать 14 любых байтов.



теперь когда мы разобралист со стркутом  с точки зрения си языка то 
теперь поймем для чего испльзуется этот структ. для каких данных. какой задачи.
структ как пременная используется чтобы предать парамтры в фунукции работы с сетью
такие как bind() , connect() , sendto(), 


	int bind(int socket, const struct sockaddr *address,
           socklen_t address_len);


	int connect(int socket, const struct sockaddr *address,
           socklen_t address_len);


	ssize_t sendto(int socket, const void *message, size_t length,
           int flags, const struct sockaddr *dest_addr,
           socklen_t dest_len);



где хрени вида
   const struct sockaddr *dest_addr
означают что в функцю нужно подсталять  поинтер. который указывает на тип struct SOCKADDR 
на слово const можно забить болт. 
так полуается если мы обьявим переменную с типом sockaddr то эту переменнную а точнее 
поинтер на нее нужно подставлять как аргумент в сетевые фукнции. тоест через этот структ
в сетевые фукнции передаются какито параметры.
прежде чем двинуться дальше со структом я расакажу как в целом работает установление
сетвеовго конекта в линукс. создается в памяти ядра кусок называется сокет. в нем будут находится
буфреры отпраки и приема из сети и всякие другие хрени которые нужны ядру чтобы обарабывать
некоторый конкрертный поток из сети. тоесть поток пакетов будет ядром приниматься из карты
и скалдыавться в сокет. а оттуда его будет читать процесс. и наоборот процесс пихает сво 
байты в сокет. а оттуда их берет ядро и пихает в сеть. прикол в том что  кода мы созаддаем
сокет то он полупустой.
сам сокет создается нпример вот так

		socket(AF_INET, SOCK_STREAM, 0)

после такой команды будет создан сокет и у него будут уже настройки 
о том  что он будет обабабвать ipv4+tcp поток. 
но этих параметров еще не достаточно ядру чтобы понять какой конкретно поток нужно совать 
в этот сокет. нужно как минимум еще две пары параетров. а именно IP:port на нашем компе
и IP:port на удаленном компе. так вот чтобы  программа могла обмениваться по сети ей нужно 
записать недотстающие параметры сетвого потока в сокет. тогда ядро будет точно значть какой
имнно сетевой поток нужно совать на этот сокет. и наша програма наконец получит доступ к этому
сетевому потоку через этот сокет. еще раз скажу что у нас есть много видов сетвы х потоков
и если мы хотим чтобы наша прога имела досутп к какмуто кнокрентному сетеовому потоку нужно об
этом обьяснить ядру. обьяснение начинается с того что мы создаем сокет. и при его создании
он имеет три аргумента. все эти три аргумента позволяют уже описать ядру некоторую часть 
всех параметров нужного нам сетевого потока. поэтому говорят был создан такой то тип сокета. 
сокет у нас тот же самый все время. только у него менятся параметры при которых он создается.
после создания егоные три параметра менять нельзя.  тот сокет котоырй я создал выше
он говоритт ядру что наша прграмма хочет получит достуа к сеетовому потоку с параметрами
ipv4+tcp.  но это все равно еще н еполное описание. остается передать в ядро насторйки
такие как IP:port нашего компа и IP:port уадленного компа. тогда ядро уже узнает все что
надо и начнет пихать сетеовой поток из сети в соккет. а из сокета прогармма сможет получать
этот поток в свою память. и наоборот - прграма будет пихать свои данные в сокет а ядро удет
оттуда их брать и пихать в сеть.  так вот IP:port нашего компа суется в сокет путем того 
что эти параметры записваются нами в структ SOCKADDR. а эта пременная пихается в фнкцию 
bind() а она пихает эти параметры в сокет.
делается это так:
мы пихаем IP:port наешего компа в пеерменную с sockaddr, 
   
   struct


 вот доставкой чего заниматся sockaaddr структ.
и вот куда это пихется и кем это пихается. можно заметить что у нас остается еще неизвестный
параметр IP:port удаленного компа. которые тоже нужно засунуть в сокет. это делается уже
другой командой. и тут два варианта - если мы делаем исходящее соединение 


 ядро еще не понимает какой конретно поток можно через этот сокет 
пропускать. 


тоесть поинтер указыает на перенную котоаряа имеет тип  const struct sockaddr
тоесть например вот так

   struct sockaddr s1 ;       \\ создаем перееменную s1  с типом sockaddr
   struct sockaddr *p = s1;   \\ создаем поитер на перемнную s1


и уже этот поинтер p подставляем в функцию bind() вторым аргументом

   bind(arg1, p, arg3)

тоесть функция требует всталять в аргумент именно поинтер.
если мы не хотим создавать поинтер p в явном виде то можно заставить комлилятор
при взыовае фунции подтсавит адрес перееной s1 без создаия поинтера.

   bind(arg1, &s1, arg3)

но в любом случае у нас вторым аргументом будет вставлен адрес прееменной s1. 
подчеркиваю будет вставлен АДРЕС. второй аргумент это адрес. 

ну сейчас пока можно забыть про поинтер. важно куда он укзывает он укзывает на 
адрес где лежит переменная которая имеет тип struct sockaddr.
поэтому ппреед вызовом фукнции нам нужно сзооздать перменну с этим типом. 
а для этого нам надо понимать что это за тип.

далее. я поясню в чем разница между типами

	struct sockaddr s1;
	const struct sockaddr s2;


у s1 и s2 тип совпадает. только разциа в том что у s1 после того как мы туда 
занесли значение то его потом можно и повторно менть.
а если мы занесли значение в s2 то его менять нельзя. система недаст. 
он станет константой. не в том пане что числом. а втом плане что эта область данных
запрещена для модиицикации. тоесть мы один раз задаали значение и оно на всем 
порлтятяжении работы процесса бошльше менять неьльзя. зачем так делать. 
это можно делать для того что при подтставлнвокке пременнйо в функцию то функция может
случайно поменяь знаечение в этой пермтенной. а если мы в йукнцию пихаем константу то
фнкция может ее чиать но при все желении она не может ее менять. это такая зашита от того чтобы
фунция не поменяла эту пременную(котраря называется констаанта). 



далее. теперь вопрос а что же физически  хранится в этом структе? какие данные?
если мы говорим про использование этого  структа для фукнции bind() то у нее три 
параметра. первый это дескрптор сокета. второй параметр это наш поинтер наш структ и третий 
параметр это длинна этого структа. тоесть


  bind(дескриптр сокета, поинтер на наш структ, длинна структа)

спрашивается а зачем фнкции предвать размер нашего структа.
а дело в том что у нас тип поинтера который мы пишем в текте программыы это лишь инфорация
для компилятора. чтобы он на стадии создания кода следалил чтобы мы работали с типами 
чисто и коректно. а когда у нас уже готовый ассебмлкр код то поинтер из себя предстлввяет
всего навсего 4или 8 байт в памяти где лежит адрес на перменную. и поэтому если мы в 
фнкцию предаем адрес поинтера то фкнция имея этот поинтер никак не может опредеить какой
размер данных лежит по адресу за этим поинтером. это только комплиятор на стадии комплицяии
знал что поинтер указывал на преенную такого типа тоесть таокго размера. поэтому если мы 
преедаем в фукнцию поинтер то обычно отдельым аргументом преедется размер той структуры на который
этот поинтер указывает. чтобы фкцния знала сколкьо байт отттуда считывать!
единсвтнное замечение такое что вообще то функция же явно нам сообщает на какой тип поинтер
обязан указывать и будет странно если мы будем пытаться фкнции подсунуть поинтер на 
какойто левый тип. по крайней мере компиятор нам этого не даст при создании ассеблере коода.
поэтому по идее фкцния просто обязана читать то число байтов которое соотсвуетствует 
этому типу данных. тоесть если фкуцния заранее предполоагает что ей передали поинтер на тот
тип данных котоырй она укзаыает в своей специификации то нафиг ей нужен еще в явном виде
аругмент который разльянсяе размер типа данных на котоыйр указывает поинтер мне неочень ясно.
ладно.

так вот первое поле это декрпитор сокета. а второй поле поинтер на наш структ.
так вот что делает bind() она берет настройки указанные в нашем структе и с помощью ядра
пропсиывает эти настройки на этом сокете. а что же за настройки прописываются на сокете?
ну это часть параметров которые нужно знат ядру чтобы понимать какие пакеты из тех что 
прилетают или улетают из  компа нужно обрабатывать через указанный сокет.
дело в том что при работе с сетью наш процесс создает сокет. после того как он создан.
он как я его называют он голый. да он имеет некоторый тип. но в нем нет кучи параметров.
поэтому он не готов для работы. потому что что такое сокет. это кусок в паямти ядра
где будут находится и обрабываться некоторй пакеты из тех что влетают или вытелают из 
компа. так вот ядру нужно знать какие именно пакты нужно совать именно в этот сокет. 
а пока что наш сокет и сам об этом незнает. чтобы задать какой поток пакетов нужно
обарбывать на этом сокете - нужно внести  в сокет доп настройки. и эти настройки
туда вносятся по частям. одна из таких частей это вызов фкнции bind()
она читает из sockaddr часть этих настроек и сует их в сокет. но это будет еще не все
настройки. а только часть. но все равно хояття бы част настроек bind() туда сует.
у кажого сетевгого пакета обычно есть две части. одна часть идентиацирует параетры
нашего компа. а вторая часть идентиицфирует удаленный комп. так вот  bind( ) он указвается
ядру как выглдяит та часть пакета которая иденатциииурет наш комп. для примера. положим
мы работтаем с tcp+ip содеиненеим. тогда нам пакет содержит две части

первая часть IP нашего компа и tcp порт нашего компа
втоаря часть IP удаленного  компа и tcp порт нашего компа

так вот bind() он пропиывает на сокете в данном прмиерер   IP нашего компа и tcp порт нашего компа
и получается что ядро уже знает половину того как должен выгядеть сетеоовой пакет который будет
обарбываться на этом сокете. далее вызываются уже друигие команды котоыре пропиывают на сокте
вторую часть в пакете.  если у нас слушающих сокет то вызыватся listen() а если мы делаем
исходящий конект то ызывается connect()  и вот каждоая из этих фукций допиывает в сокет
вторую часть как выглдяит сеетеовой пакет. и тогда сокет получает полный набор данных для ядра
как выглядит сеетвой пакет. и грубо говоря наонец сокет можно исползовать и через него делать
сетевой конект и гонять через него сетевые пакеты. а наш процесс может рабоатт чеез эттот сокет
с сетью. это не совсем так но нехочу щас углулблсятся. наш сейчас фокус на самом структе SOCKADR

также важнопонять что в SOCKADDR если там содержится ip адрес а такое есть не всегда. то там
не вседа содержится адрес нашего компа. в ряде случаев там содержится адрес удаленного 
компа. а сокет для обрабоки потока требует два IP адреса. вторйо ip адрес попадает в настойки
сокета через вызывы других фукнций которые могут использовать этот структ иди другой структ.
тость я хочу скаазат то что чрез SOCKADDR мы можем преедть в сокет только часть нужных ппрамтеров
но не все. и то что если в sockaddr соедржится ip адрес то в одних случаях это dest ip 
а вдругих это source ip. у этго срукта  у него два поля


  struct sockaddr {
           sa_family_t     sa_family;  2  байта      /* Address family */
           char            sa_data[]; 14  байт       /* Socket address */
       };


содерижимое второго поля очень завсиит от содержимого первого поля. 
в первом  поле мы укаываем грубо говорят тип будущего сетевого соеиенеия. 
а во втором поле уже параметры (часть парамеров) для этого типа сетеового соедиенения.
так вот коечно же тебе уваажемый читатель хочется увидет конкретный примеры что же пихается
внутрь этого структа потому что пока что слишком много тумана. так вот как я счииаю что 
фнкции bind() и прочие котоыре треюует  в себя поинтер на этот структ они на самом деле
с этим структом нихуя не рабоают. и им абсолютно насрать на формат данного структа. да
в этом огромный прикол который я выяснил. поэтому нам и ненужно знать а что и как нужно было 
бы запиывать в этот структ. я щас оьясню. для начала я обяснию вспомогателный момент 
для понимамания. в си есть такой прикол. можно создать переенную создать на не поинтер. 
а потом можно на этот же адрес создать другой поинтер в котором пропсать что якобы он 
укзывает на перменную друогого типа.  показыаю


    int a = 0xAABBCCDD;
    int *p1 = &a;

мы создали перменую "a" котоаря скажем сидит по адрсу 1234 и в этмо адресе сидит 4 байта
в котоых записано число 0x10AABBCC .  впамяти это вбудет выгдядтеь вот так

  1234 0xDD
  1235 0xCC
  1236 0xBB
  1237 0xAA

(напоминаю что если у нас многбайтовое выржание то в памяти в младщий адрес запивыается самый
младщий байт) поэтому если у нас на бумаге число выгдядит как 0xAABBCCDD
а в памяти оно лежит наоброт как DD BB CC AA

так вот мы создали перменую котоаря скажем сидит по адрсу 1234 и начиная с этого адреса
сидит 4 байта данных.  адрес 1234 созраен в переменной p1
теерпрь я делаю вот так

	long int *p2 = (long int*)p1;

этим я создаю поинтер p2 в который будет записа адрес 1234 но мы комплятору говорим о том
чтобы он считал что якобы по адресу 1234 лежит не 4 а 8 байт. 
вот эта скобочка справа (long int*) она очень нужна без нее будет ошибка. без нее

	long int *p2 = p1;

комплиятор выдаст ошибку что мы пытаемся слева создать поинтер на один тип перменной
а справ у нас стоит поинтер на другой тип перменной. и самим поинтерам по барабану.
просто комплиятору не все равно.  так вот скобочка (long int*)p1 причем вот так тоже 
нельзя делать будет ошииька (long int*) p1
так вот скобочка это называется CASTING и она обязывает компилятор насрать на то что справа
стоит поинтер не того типа. она как бы говорит комплиятору (слушай чувак считай что после скобочки
стоит поинтер именно того типа который мы указали в этой скобочке). 
еще раз поясню что когда мы укаывзем тип  у поинтера то  сама перменная p2 она в памяти как занимала 4\8 байт содержа в себе просто напросто адрес на переенную так она и будет содержать то есть комплятор
он содвая поиентер он в нем тип переменной на которую он укзывает не сохраняет. поинтер 
физчиски тлоько содержит адрес  и все. а тип который мы укаызваем используется тлоько компидятором
на стадии компиляции чтобы удержать програмиста в коде програмровать хуйню. тем не менее
вот такую хуйню компятор разрещает делать. чтобы у нас было два поинтера. которые укзывают
на одну адрес паяти. и один поинтер будет говорит компиятору что там лежит 4 байта данныъ
а втррой говоиит что там лжеит 8 байт данных.  где эта хрент может пригодиися?
ну например воттакой глупый случай.
мы создаем перремнную 4 байта длинной. и делем на нее поинтер.

   int a = 0xAABBCCDD;
   int *p1 = &a;

а потом мы хотим прочитать из этой области данных только первый самый младщий байт.
тогда можно сддеть вот так

   char *p2 = (char *)p1;

тогда можно будет напечать этот первый из четырх байт лежащий в памяти вот так

   printf("%hhX \n", *p2);

на экране мы увидим тлько наш DD

тоеесть вот эта хрень *p2 она заставить коплиятор создать такой код на уровне асемблера
что будет считано из адреса (харняящегоося в поитере) только один байт. и этот байт будет
подставлен в принтф.  

вот эта хрень *p2 назвается  pointer derefrence. она говорит комплияттору чтобы он на этом
месте создал ассмебелер код который считаем данные из области памяти начиная с адреса 
укзаанного в поинтере. и момент истины состоит в том что сколко байт будет считано. а будет
считано то число байт которое указанов типе переенной при обявлении поинтера.
тоесть если при создании поинера указано вот так

int *p1 = ...

тоесть int, то  при *p1 будет считано 4 байта.
а если поитер был создан вот так

char *p1 = ...

то операция *p1  привеет к тому что копилтятор породит такой асебмлер код что будет
считано по тому же адресу всего 1 байт. таикм образом тип потера важен тем что 
он обьянсят комдиятору какой асеблер код нужно генениррвать если мы даем команду 

  *p1 

котоаря по руски значит что нужно считать из памяти содержимое которое хранистя начиная
с адреса указаноого в поинтере. и непонятно сколько байтов то нужно считать 1 или 10001.
это и здаает тип указанный при обьявлении поинтера.

тут важно уппоунять плодьбеку синтактсиуса си. такая же поббьема имеет место с массивами.
если мы пишем b[10] при обябвлении массива

   int b[10]

то число 10 заадает число элементов. а ели мы пишем b[10] уже полсле обьяление массива 
то [10] означает номер элементам массива

  b[10]  означает что мы хотми посмтреть соедежромое 10-го элемент массива.

так вот такая же хуйня есть и споинтерами.
если мы обьялвелем поинтер то хрень *p ничего незначи, точнее она значит то что перменная
p это поинтер. 

   int *p = .... 


а если мы юзаем *p уже после оббявления поинтера то *p означает нечто совем друное. 
а именно "эй компилятор сходи по адресу указаному в поинтере и счиатай ка сюда те байты
которые там хранятся. число байтов которое надо считать посмотри исходя из типа котоырй 
был укзан при обьявлении поинтера"!

поэтому нотация *p имеет два оазных значени в тексте на си . суки


так вот я кратко обозначу на счет SOCKADDR. в bind() мы передаем поинтер на нее.
так вот как на самом деле делают люди. они создают переменную у которой тип не sockaddr 
а другой тип. они заполняют туперемнную данными. и создают на нее поинтер. 
а потом они создают новый поинтер и говорят чтобы копитоор счиал что якобы по тому адресу
лежит структ SOCKADDR.  далее этот поинтер скармливыается в bind() , этот бинд он заранее
знает что ему передали поинтер на саоммо деле на другой тип по видом поинтерана  sockaddr
поэтому bind анализирует первые два байта по этому адресу . и на оснвое этого создает
свой поинтер в которого будет исходный тип на эту область памяи. например 

 создаю 
    struct sockaddr_in6  sa1    = ....;
    struct sockaddr_in6  *p_sa1 = &sa1;
    struct sockaddr      *p     = (struct sockaddr*) p_sa1;
    bind(..., p, ... )

код bind анализиует первые два байта. и понимает что на самом деле это поинтер на
sockaddr_in6 и он делает обратное преобразование

    struct sockaddr_in6  *p2     = (struct sockaddr_in6*) p;

и далее bind() испоьзует p2 для работы. как видно sockaddr чисто служит как фейк. 
я еще вернусь к этому вопросу подрбнее. спращивеся а зачем нужна такая хуета?
нужна она потому что при копиляттор при вызываео фукцнии проверяет совпдаение типов данных
у заголовка фукцнии и у аргумента. так вот для разых типов сетевых соденеиний у нас 
структ для сокета будет иметт разный размер и разный вид. вот я щас покажу

вот структ для IPv4 (+tcp\udp)

  struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };

вот структ для IPv6 (+tcp\udp)


       struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };

у них разные поля. разные хрени. разный размер.
и  с обоими структами должен bind() работать. но в специифкации bind мы должны указать 
тлько один тип аргумента. один тип структа. поэтмоу в специиццаии укызвается некйий фекйвовый
структ. чсто только для того чтобы коипилятор на стадии компдияции неругался.  потому
что в обих случаях по факту у нас всего навсего в фкнцию будет пеередан адрес. 
а потом успешно пройдя компдиицию от компиятора. и получив адрес уже функция анализирует
какой реальный структ кроется за этим фейквым. и исправляет. я так ссчитаю зачем и почему
и как это рабоает и зачем нужен структ sockaddr

и едиснвнное треования к sockaddr и другим струкатам это то что первые два байта увсех 
структов которые мы будем юзать должны быть по спецификации одинакоыве. тоесть
вот смотрим и сравнивем  вот два реальных структа 

       struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };

       struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


и вот этот фековый структ

 struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


и мы видим что первое поле у них у всех ПО ТИПУ одинаковое sa_family_t. поэтому через него
и происходит идентиацификация истиинного типа структа. ну итакже я напоминаю что у нас вместе
со структом поинером преедается в bind() и размер структа в трететем аргументе. а размер 
струкаттоже многое говорит о том что это за структ. потому что 

sockadr_in имет размер 16 байт
а 
sockadr_in6 имеет размер 28 байт. 

поэтому если  в фунцию посутил поинтер. и поступило что размер перенно на которую он ссылается
равен 16 значит это вреальности структ на  sockadr_in а если рамзер равен 28 то это поинер
на структ sockadr_in6

иначе всю эту шарманку не обьяснить.
если мы возьмем код програмы то мыувидим. 
чловек создает структ  sockadr_in6 для буудущего ipv6 конекта. этот структ имеетразмер 28 байт.
потом он на него создает поитер с типом sockaddr а мы знаем что этот тип имеет длинну 16 байт.
и этот поинтер передает в bind() . если бы бинд  в реаьности работал бы с этим поинтером
считая что за ним сидит sockaddr то он бы прочитал какакото мусор в размере 16 байт из 28 
необбхоимых. поэтмоу я считаю что  структ sockaddr он не исплзтктя в реаьности биндом. а нужен
только чтобы прскочить передать наш поинтер внутрь фнкции на этапе компилиации и все.



