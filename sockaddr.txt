| sockaddr
| sockaddr_in
| sockaddr_in6


я хочу поговорить про эти структы. они играют фуажаментальную роль 
для функций bind() connect() listen() 
тоесть эти структы играют фундатменальную роль когда наша прога на си хочет с кемто
связаться по сети. 

инфо о них сидит в 

  $ man sockaddr

так вот эти штуки это структы. что такое структ - это такой тип данных. 
дело в том что у си каждая переменная имеет всегда какйто тип. это нужно комплиятору
для того чтобы он знал какие ассемблер команды он должен юзать для создания этой 
переменной( в частности  сколько байтов нужно для этой переменной в памяти ) 
и потом какие действия можно делать с этой переменной потом.   напрмиер тип данных int


   int a  = 10;

и этот тип занимает 4 байта в памяти. 
так вот структ sockaddr это тоже тип в памяти.  чем структ отличается от обычного типа (int, 
long int, char) данных - структ имеет внутри себя поля. имеется ввиду не сточки зрения 
ассемлеоа. с точки зрения ассемблера это будет просто кусок неперрывной памяти какйото 
длинннй скажем 16 байт. но для компилятора когда он создает ассемблер код данный тип 
имеет поля. тоесть скажем первые два байта это поле1, следущие два байта это поле2 итд.
с этими полями можно работать в си. к ним можно обращаться . их можно менять. туда можно
писать. читать. говоря с другой строны структ это когда мы берем несколько перменных 
разных типов и обеьединяем их в один кусок в памяти. в том числе в составе структа может
сидеть другой структ. 

посмотрим как она выглядит
идем в  

   $ man sockaddr




   #include <sys/socket.h>

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };





так вот я считаю то что на экране это брехня. структура этой структуры другая.


щас я докажу. идем в sys/socket.h и смотрим что там написано

$ cat /usr/include/sys/socket.h | grep sockaddr -A10
   AF_*, MSG_*, SOL_*, and SO_* constants, and the `struct sockaddr',
   `struct msghdr', and `struct linger' types.  */
#include <bits/socket.h>


идем и смотрим в   bits/socket.h и смотрим что там написано

$ cat /usr/include/bits/socket.h  | grep sockaddr -A 5
/* Get the definition of the macro to define the common sockaddr members.  */
#include <bits/sockaddr.h>

/* Structure describing a generic socket address.  */
struct __attribute_struct_may_alias__ sockaddr
  {
    __SOCKADDR_COMMON (sa_);  /* Common data: address family and length.  */
    char sa_data[14];   /* Address data.  */
  };


меня интересует вот эта часть

  {
    __SOCKADDR_COMMON (sa_);  /* Common data: address family and length.  */
    char sa_data[14];   /* Address data.  */
  };


причем я замечаю вот эту штуку
#include <bits/sockaddr.h>

иду туда и вижу там вот такое


#define __SOCKADDR_COMMON(sa_prefix) \
  sa_family_t sa_prefix##family


в общем с горем пополам собираю в кучу я считаю что усторойство структа sockaddr 
оно не вот такое


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


а вот такое


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];      /* Socket address */
       };


а это колосальная разница. 
в верхней записи у нас второе поле это флекс массив.
а в моей записи второе поле это массив с фиксиованной длинной. (длина 14 байт)
на данном этапе нужно много понять - что такое массив, что такое флекс массив. 
для этого нужно прочитать "от и до" статью c-array-pointer.txt
идем туда и читаем сверху до самого низа. 
прочитали всю ту статью дохрена узнали. вернулись сюда назад. теперь все знаем
про массивы. типы массивов. флекс массивы. поинтеры. 

теперь
что я еще имею в качестве дооводов моей версии. можно легко узнать какой размер в байтах
для типа sa_family_t

  printf ("%i \n", sizeof(sa_family_t) );

на экране 
  2

так вот если первое поле это 2 байта и если второе поле это флекс массив
как нам пишет мануал 


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


то тогда если я спрошу размер этого структа то размер флекс массива считается равным 0
и тогда размер всего структа вылезет как 2. 
а если устройство структа такое как я сказал 

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];      /* Socket address */
       };


то размер структа будет 2+14=16 байт.

проверяем

  printf ("%i \n", sizeof(struct sockaddr) );

на экране
  16

из чего я еще раз делаю вывод что состав структа sockaddr это вот именно такое

       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];    /* Socket address */
       };



итак первое поле этого структа это переменнная типа с фиксированной длинной. 2 байта.
второе поле это массив с фиксрованной длинной
тип каждого элемента char (тоесть 1 байтдлинной) и элементов 14 штук

		char vasya[14]

это при условии если мы будем создавать переенную с этим типом путем статического создания.
если мы будем создавать переенную с этим типом динамическим путем то у нас тело массива
будет не 14 элементов а любое число элементов в завсимости от размера тела в памяти выделенного
под эту переменную. показываю на примере
создаем пременную статическим путем

  struct sockaddr sa1;

в этом случае наш sa1 имеет тело в памяти длиной 16 байт и второе поле имеет 14 элементов.

теперь создаем переменную димамическим путем

  struct sockaddr *sa2 = malloc (100);

в этом случае у нас тело переенной имет длину 100 байт. из них 2 идет на первое поле. 
а 98 идет на второе поле. и значит в массиве будет 98 элементов. 
вот такой момент.


а теперь еще один важный момент. у нас же поинтер на этот структ передается в конечном
итоге в ядро. и по идее внутрнее устройство того или иного структа задается внутри ядра. 
оно является архитектором внуттренностей структов. а скажем libc должно отражать в точности
архитектуру структов. так вот я нашел статьью

    https://lwn.net/Articles/997094/

между прочим она от 7 ноября 2024 года. тоесть свежак

так вот судя по статье в ядре данный структ определен на самомо деле по другому


    struct sockaddr {
        sa_family_t sa_family;
    union {
        char sa_data_min[14];
        DECLARE_FLEX_ARRAY(char, sa_data);
    };
    };


где  DECLARE_FLEX_ARRAY() macro jumps through some hoops needed to declare a flexible array within a union.

что по мне в упрошенном виде можно примерно вот так интерпетировать

    struct sockaddr {
        sa_family_t sa_family;
        char sa_data_min[];
    };


ровно то как об этом пишет man sockaddr. но это с точки зрения ядра. потому что 
с точки зрения libc структура имеет другой формат. вот что важно. и в чем прикол. дебильный.
единсвтенное что второе поле это не совсем флекс массив. а это флекс массив но у него есть
минимальный размер 14 байтов. меньше его он быть не может но может быть болльше.

и вот по мне то как sockaddr трактуется внутри ядра обьясняет офигенную загадку. 
а загадка вот в чем - я там ниже буду это рассматривать а щас пока наброски по главное.
если посмотреть на функции которые работают с сетью наример это bind()

 int bind(int socket, const struct sockaddr *address,  socklen_t address_len);

так вот видно что второй аргумент это поинтер на sockaddr

как я уже сказал с точки зрения libc структура сокаддр имеет два поля и второе поле
это массив 14 элементов длинной. 

дальше вот что важно. когда в реальной программе на си пишут код который должен сделать конект
через сеть. то данные не заносятся в переменную с типом sockaddr. данные всегда заносятся
в другие структы. например в структ sockaddr_in6 он имеет вот такую структуру

    struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


эта структура по своей длинее имеет чтото вроде 28 байтов. ее в программе заполняют.
а потом делаю непонятный ход конем. берут и говорят что поинтер который укаызвает на эту 
структуру надо считать что якобы в теле этой переменой находится другая структура а именно
структура sockaddr.
щас покажу на примере

  struct sockaddr_in6 sa1; \\ создали переменную
  sa1 .......  \\ заполняем ее поля
  struct sockaddr_in6 *p1 = &sa1 \\ создаем поинтер на sa1
  struct sockadd  *p2 = (struct sockadd  *)p1 \\ самая фишка

в последней строке происходит прикол. мы создаем поинтер p2 который укаывает на тело
переменной s1 но при этом мы утрвеждаем что поинтер p2 указывает на тело переменной
которая имеет тип sockaddr
это ж какой то бред. сравним эти две структуры


       struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[14];    /* Socket address */
       };



    struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


у нас у этих двух структура совпдает только первое поле. точнее его тип. это 2 байта.
а дальше полнейшее разногласие. и длина же не совпдает 14 байт  занимает второе поле
у sockaddr с точки зрения libc и 26 байт занимают все поля начиная со второго у sockaddr_in6
получается каакйоото дебилизм. мы готовим в памяти блок из 28 байт. а потом мы его обзываем
как бутто там сидит хрень из 16 байт. это же обрезание какоето. имеется ввиду с точки зрения
интепретирования. от того что мы создаем поинтер другого типа который укыывзает на туже 
область данных от этого сама область данных никак не меняется. 
но походу разгадка именно в том что в ядре sockaddr имеет другую струкутуру с точки 
зрения ядра чем с точки зрения libc



    struct sockaddr {
        sa_family_t sa_family;
    union {
        char sa_data_min[14];
        DECLARE_FLEX_ARRAY(char, sa_data);
    };
    };


c точки зрения ядра второе поле неограничивыается по длинее 14 байтами. а имеет размер 
минимум 14 байтов а максимум хрен знает.
поэтому у нас же код bind() выполняет в конечном итоге ядро. и мне кажется что код ядра
в итоге смотрит на первое поле которое имеет одну и туже длинну что у sockaddr что у 
sockadr_in6. смотрит что там написано. и интепретерирует остальные байты исходя именно из
значения первого поля. мне кажется в самой простой интепретации я считаю что это должно работаь
так. ядро анализиуерует первое поле. обнаруживает что оно равно AF_INET6 и исходя
из этого понимает что на самом деле нам подсунули sockaddr_in6 и ядро создает на лету
новый поинтер вот такой

  struct sockaddr_in6  *p3 = (struct sockaddr_in6  *)p2

где p2 это поинтер который был передан ядру. и таким образрм мы в программе готовили област
памяти как  sockaddr_in6 и ядро начинает видеть этотже кусок памяти ровно также как sockaddr_in6
мне кажется что тип sockaddr нужно только для того чтобы разные типы соакдров можно было в функцию
"передавать" используя единый тип. ведь аргумент у фукцнии должен иметь тип. он один. поэтому
был придуман фейковый или траспортный вид структа чисто для компилятора. потому что он 
сравнивает какой тип пеерменной пеедается в фнукцию через аргумент и совпадает ли тип этой
переменной с типом арумнта пропсианный в прототипе фукцнии. поэтому тип sockaddr это такой тип
фуфло. мы готовим область памяти на основе реального структа который отвечает данному типу 
соединения. например для ipv4 это sockaddr_in4, для ipv6 это sockaddr_in6 итп. потом мы 
через кастинг типов создаем поинтер на эту же область "пропаривая" компилятору что якобы 
поинтер указыает на sockaddr область. это дает возможно просунуть в функцию наш поинтер.
иначе бы пришлсь писать несклько видов фукнции bind() где вторым аргуметом были бы вот
эти конкнерерктные структы  sockaddr_in4 или  sockaddr_in6
а потом ядро исследуя перые 2 байта этого поинтера точнее первые 2 байта туда куда он укзывает
ядро понимает какой на самомо деле структ скрывается за маской sockaddr
мне кажется так ето работает. и так это обьясняет вот эту хрень с sockaddr
иначе это все чушь собачья. потому что мы подгтоваливаем в памяти тело с данными в соовтесвтиии
со специифкацией одного структа. а потом поинтер на эту область обвяляем с типом совершенно 
другого структа которй вобще не совпдаает с нашим структом. и по полям и по длине. едиснвтенное
что совпдает это первые 2 байта и все. 

поэтому теперь далее я пока отхожу от расстривания структа sockaddr
и посмотрим на структ sockaddr_in4 точнее он наываеся sockaddr_in



   struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };



<<<<<<< остановился ТУТ



прежде чем двинуться дальше со структом я расакажу как в целом работает установление
сетвеовго конекта в линукс. создается в памяти ядра кусок называется сокет. в нем будут находится
буфреры отпраки и приема из сети и всякие другие хрени которые нужны ядру чтобы обарабывать
некоторый конкрертный поток из сети. тоесть поток пакетов будет ядром приниматься из карты
и скалдыавться в сокет. а оттуда его будет читать процесс. и наоборот процесс пихает сво 
байты в сокет. а оттуда их берет ядро и пихает в сеть. прикол в том что  кода мы созаддаем
сокет то он полупустой.
сам сокет создается нпример вот так

		socket(AF_INET, SOCK_STREAM, 0)

после такой команды будет создан сокет и у него будут уже настройки 
о том  что он будет обабабвать ipv4+tcp поток. 
но этих параметров еще не достаточно ядру чтобы понять какой конкретно поток нужно совать 
в этот сокет. нужно как минимум еще две пары параетров. а именно IP:port на нашем компе
и IP:port на удаленном компе. так вот чтобы  программа могла обмениваться по сети ей нужно 
записать недотстающие параметры сетвого потока в сокет. тогда ядро будет точно значть какой
имнно сетевой поток нужно совать на этот сокет. и наша програма наконец получит доступ к этому
сетевому потоку через этот сокет. еще раз скажу что у нас есть много видов сетвы х потоков
и если мы хотим чтобы наша прога имела досутп к какмуто кнокрентному сетеовому потоку нужно об
этом обьяснить ядру. обьяснение начинается с того что мы создаем сокет. и при его создании
он имеет три аргумента. все эти три аргумента позволяют уже описать ядру некоторую часть 
всех параметров нужного нам сетевого потока. поэтому говорят был создан такой то тип сокета. 
сокет у нас тот же самый все время. только у него менятся параметры при которых он создается.
после создания егоные три параметра менять нельзя.  тот сокет котоырй я создал выше
он говоритт ядру что наша прграмма хочет получит достуа к сеетовому потоку с параметрами
ipv4+tcp.  но это все равно еще н еполное описание. остается передать в ядро насторйки
такие как IP:port нашего компа и IP:port уадленного компа. тогда ядро уже узнает все что
надо и начнет пихать сетеовой поток из сети в соккет. а из сокета прогармма сможет получать
этот поток в свою память. и наоборот - прграма будет пихать свои данные в сокет а ядро удет
оттуда их брать и пихать в сеть.  так вот IP:port нашего компа суется в сокет путем того 
что эти параметры записваются нами в структ SOCKADDR. а эта пременная пихается в фнкцию 
bind() а она пихает эти параметры в сокет.
делается это так:
мы пихаем IP:port наешего компа в пеерменную с sockaddr, 
   
   struct


 вот доставкой чего заниматся sockaaddr структ.
и вот куда это пихется и кем это пихается. можно заметить что у нас остается еще неизвестный
параметр IP:port удаленного компа. которые тоже нужно засунуть в сокет. это делается уже
другой командой. и тут два варианта - если мы делаем исходящее соединение 


 ядро еще не понимает какой конретно поток можно через этот сокет 
пропускать. 


тоесть поинтер указыает на перенную котоаряа имеет тип  const struct sockaddr
тоесть например вот так

   struct sockaddr s1 ;       \\ создаем перееменную s1  с типом sockaddr
   struct sockaddr *p = s1;   \\ создаем поитер на перемнную s1


и уже этот поинтер p подставляем в функцию bind() вторым аргументом

   bind(arg1, p, arg3)

тоесть функция требует всталять в аргумент именно поинтер.
если мы не хотим создавать поинтер p в явном виде то можно заставить комлилятор
при взыовае фунции подтсавит адрес перееной s1 без создаия поинтера.

   bind(arg1, &s1, arg3)

но в любом случае у нас вторым аргументом будет вставлен адрес прееменной s1. 
подчеркиваю будет вставлен АДРЕС. второй аргумент это адрес. 

ну сейчас пока можно забыть про поинтер. важно куда он укзывает он укзывает на 
адрес где лежит переменная которая имеет тип struct sockaddr.
поэтому ппреед вызовом фукнции нам нужно сзооздать перменну с этим типом. 
а для этого нам надо понимать что это за тип.

далее. я поясню в чем разница между типами

	struct sockaddr s1;
	const struct sockaddr s2;


у s1 и s2 тип совпадает. только разциа в том что у s1 после того как мы туда 
занесли значение то его потом можно и повторно менть.
а если мы занесли значение в s2 то его менять нельзя. система недаст. 
он станет константой. не в том пане что числом. а втом плане что эта область данных
запрещена для модиицикации. тоесть мы один раз задаали значение и оно на всем 
порлтятяжении работы процесса бошльше менять неьльзя. зачем так делать. 
это можно делать для того что при подтставлнвокке пременнйо в функцию то функция может
случайно поменяь знаечение в этой пермтенной. а если мы в йукнцию пихаем константу то
фнкция может ее чиать но при все желении она не может ее менять. это такая зашита от того чтобы
фунция не поменяла эту пременную(котраря называется констаанта). 



далее. теперь вопрос а что же физически  хранится в этом структе? какие данные?
если мы говорим про использование этого  структа для фукнции bind() то у нее три 
параметра. первый это дескрптор сокета. второй параметр это наш поинтер наш структ и третий 
параметр это длинна этого структа. тоесть


  bind(дескриптр сокета, поинтер на наш структ, длинна структа)

спрашивается а зачем фнкции предвать размер нашего структа.
а дело в том что у нас тип поинтера который мы пишем в текте программыы это лишь инфорация
для компилятора. чтобы он на стадии создания кода следалил чтобы мы работали с типами 
чисто и коректно. а когда у нас уже готовый ассебмлкр код то поинтер из себя предстлввяет
всего навсего 4или 8 байт в памяти где лежит адрес на перменную. и поэтому если мы в 
фнкцию предаем адрес поинтера то фкнция имея этот поинтер никак не может опредеить какой
размер данных лежит по адресу за этим поинтером. это только комплиятор на стадии комплицяии
знал что поинтер указывал на преенную такого типа тоесть таокго размера. поэтому если мы 
преедаем в фукнцию поинтер то обычно отдельым аргументом преедется размер той структуры на который
этот поинтер указывает. чтобы фкцния знала сколкьо байт отттуда считывать!
единсвтнное замечение такое что вообще то функция же явно нам сообщает на какой тип поинтер
обязан указывать и будет странно если мы будем пытаться фкнции подсунуть поинтер на 
какойто левый тип. по крайней мере компиятор нам этого не даст при создании ассеблере коода.
поэтому по идее фкцния просто обязана читать то число байтов которое соотсвуетствует 
этому типу данных. тоесть если фкуцния заранее предполоагает что ей передали поинтер на тот
тип данных котоырй она укзаыает в своей специификации то нафиг ей нужен еще в явном виде
аругмент который разльянсяе размер типа данных на котоыйр указывает поинтер мне неочень ясно.
ладно.

так вот первое поле это декрпитор сокета. а второй поле поинтер на наш структ.
так вот что делает bind() она берет настройки указанные в нашем структе и с помощью ядра
пропсиывает эти настройки на этом сокете. а что же за настройки прописываются на сокете?
ну это часть параметров которые нужно знат ядру чтобы понимать какие пакеты из тех что 
прилетают или улетают из  компа нужно обрабатывать через указанный сокет.
дело в том что при работе с сетью наш процесс создает сокет. после того как он создан.
он как я его называют он голый. да он имеет некоторый тип. но в нем нет кучи параметров.
поэтому он не готов для работы. потому что что такое сокет. это кусок в паямти ядра
где будут находится и обрабываться некоторй пакеты из тех что влетают или вытелают из 
компа. так вот ядру нужно знать какие именно пакты нужно совать именно в этот сокет. 
а пока что наш сокет и сам об этом незнает. чтобы задать какой поток пакетов нужно
обарбывать на этом сокете - нужно внести  в сокет доп настройки. и эти настройки
туда вносятся по частям. одна из таких частей это вызов фкнции bind()
она читает из sockaddr часть этих настроек и сует их в сокет. но это будет еще не все
настройки. а только часть. но все равно хояття бы част настроек bind() туда сует.
у кажого сетевгого пакета обычно есть две части. одна часть идентиацирует параетры
нашего компа. а вторая часть идентиицфирует удаленный комп. так вот  bind( ) он указвается
ядру как выглдяит та часть пакета которая иденатциииурет наш комп. для примера. положим
мы работтаем с tcp+ip содеиненеим. тогда нам пакет содержит две части

первая часть IP нашего компа и tcp порт нашего компа
втоаря часть IP удаленного  компа и tcp порт нашего компа

так вот bind() он пропиывает на сокете в данном прмиерер   IP нашего компа и tcp порт нашего компа
и получается что ядро уже знает половину того как должен выгядеть сетеоовой пакет который будет
обарбываться на этом сокете. далее вызываются уже друигие команды котоыре пропиывают на сокте
вторую часть в пакете.  если у нас слушающих сокет то вызыватся listen() а если мы делаем
исходящий конект то ызывается connect()  и вот каждоая из этих фукций допиывает в сокет
вторую часть как выглдяит сеетеовой пакет. и тогда сокет получает полный набор данных для ядра
как выглядит сеетвой пакет. и грубо говоря наонец сокет можно исползовать и через него делать
сетевой конект и гонять через него сетевые пакеты. а наш процесс может рабоатт чеез эттот сокет
с сетью. это не совсем так но нехочу щас углулблсятся. наш сейчас фокус на самом структе SOCKADR

также важнопонять что в SOCKADDR если там содержится ip адрес а такое есть не всегда. то там
не вседа содержится адрес нашего компа. в ряде случаев там содержится адрес удаленного 
компа. а сокет для обрабоки потока требует два IP адреса. вторйо ip адрес попадает в настойки
сокета через вызывы других фукнций которые могут использовать этот структ иди другой структ.
тость я хочу скаазат то что чрез SOCKADDR мы можем преедть в сокет только часть нужных ппрамтеров
но не все. и то что если в sockaddr соедржится ip адрес то в одних случаях это dest ip 
а вдругих это source ip. у этго срукта  у него два поля


  struct sockaddr {
           sa_family_t     sa_family;  2  байта      /* Address family */
           char            sa_data[]; 14  байт       /* Socket address */
       };


содерижимое второго поля очень завсиит от содержимого первого поля. 
в первом  поле мы укаываем грубо говорят тип будущего сетевого соеиенеия. 
а во втором поле уже параметры (часть парамеров) для этого типа сетеового соедиенения.
так вот коечно же тебе уваажемый читатель хочется увидет конкретный примеры что же пихается
внутрь этого структа потому что пока что слишком много тумана. так вот как я счииаю что 
фнкции bind() и прочие котоыре треюует  в себя поинтер на этот структ они на самом деле
с этим структом нихуя не рабоают. и им абсолютно насрать на формат данного структа. да
в этом огромный прикол который я выяснил. поэтому нам и ненужно знать а что и как нужно было 
бы запиывать в этот структ. я щас оьясню. для начала я обяснию вспомогателный момент 
для понимамания. в си есть такой прикол. можно создать переенную создать на не поинтер. 
а потом можно на этот же адрес создать другой поинтер в котором пропсать что якобы он 
укзывает на перменную друогого типа.  показыаю


    int a = 0xAABBCCDD;
    int *p1 = &a;

мы создали перменую "a" котоаря скажем сидит по адрсу 1234 и в этмо адресе сидит 4 байта
в котоых записано число 0x10AABBCC .  впамяти это вбудет выгдядтеь вот так

  1234 0xDD
  1235 0xCC
  1236 0xBB
  1237 0xAA

(напоминаю что если у нас многбайтовое выржание то в памяти в младщий адрес запивыается самый
младщий байт) поэтому если у нас на бумаге число выгдядит как 0xAABBCCDD
а в памяти оно лежит наоброт как DD BB CC AA

так вот мы создали перменую котоаря скажем сидит по адрсу 1234 и начиная с этого адреса
сидит 4 байта данных.  адрес 1234 созраен в переменной p1
теерпрь я делаю вот так

	long int *p2 = (long int*)p1;

этим я создаю поинтер p2 в который будет записа адрес 1234 но мы комплятору говорим о том
чтобы он считал что якобы по адресу 1234 лежит не 4 а 8 байт. 
вот эта скобочка справа (long int*) она очень нужна без нее будет ошибка. без нее

	long int *p2 = p1;

комплиятор выдаст ошибку что мы пытаемся слева создать поинтер на один тип перменной
а справ у нас стоит поинтер на другой тип перменной. и самим поинтерам по барабану.
просто комплиятору не все равно.  так вот скобочка (long int*)p1 причем вот так тоже 
нельзя делать будет ошииька (long int*) p1
так вот скобочка это называется CASTING и она обязывает компилятор насрать на то что справа
стоит поинтер не того типа. она как бы говорит комплиятору (слушай чувак считай что после скобочки
стоит поинтер именно того типа который мы указали в этой скобочке). 
еще раз поясню что когда мы укаывзем тип  у поинтера то  сама перменная p2 она в памяти как занимала 4\8 байт содержа в себе просто напросто адрес на переенную так она и будет содержать то есть комплятор
он содвая поиентер он в нем тип переменной на которую он укзывает не сохраняет. поинтер 
физчиски тлоько содержит адрес  и все. а тип который мы укаызваем используется тлоько компидятором
на стадии компиляции чтобы удержать програмиста в коде програмровать хуйню. тем не менее
вот такую хуйню компятор разрещает делать. чтобы у нас было два поинтера. которые укзывают
на одну адрес паяти. и один поинтер будет говорит компиятору что там лежит 4 байта данныъ
а втррой говоиит что там лжеит 8 байт данных.  где эта хрент может пригодиися?
ну например воттакой глупый случай.
мы создаем перремнную 4 байта длинной. и делем на нее поинтер.

   int a = 0xAABBCCDD;
   int *p1 = &a;

а потом мы хотим прочитать из этой области данных только первый самый младщий байт.
тогда можно сддеть вот так

   char *p2 = (char *)p1;

тогда можно будет напечать этот первый из четырх байт лежащий в памяти вот так

   printf("%hhX \n", *p2);

на экране мы увидим тлько наш DD

тоеесть вот эта хрень *p2 она заставить коплиятор создать такой код на уровне асемблера
что будет считано из адреса (харняящегоося в поитере) только один байт. и этот байт будет
подставлен в принтф.  

вот эта хрень *p2 назвается  pointer derefrence. она говорит комплияттору чтобы он на этом
месте создал ассмебелер код который считаем данные из области памяти начиная с адреса 
укзаанного в поинтере. и момент истины состоит в том что сколко байт будет считано. а будет
считано то число байт которое указанов типе переенной при обявлении поинтера.
тоесть если при создании поинера указано вот так

int *p1 = ...

тоесть int, то  при *p1 будет считано 4 байта.
а если поитер был создан вот так

char *p1 = ...

то операция *p1  привеет к тому что копилтятор породит такой асебмлер код что будет
считано по тому же адресу всего 1 байт. таикм образом тип потера важен тем что 
он обьянсят комдиятору какой асеблер код нужно генениррвать если мы даем команду 

  *p1 

котоаря по руски значит что нужно считать из памяти содержимое которое хранистя начиная
с адреса указаноого в поинтере. и непонятно сколько байтов то нужно считать 1 или 10001.
это и здаает тип указанный при обьявлении поинтера.

тут важно уппоунять плодьбеку синтактсиуса си. такая же поббьема имеет место с массивами.
если мы пишем b[10] при обябвлении массива

   int b[10]

то число 10 заадает число элементов. а ели мы пишем b[10] уже полсле обьяление массива 
то [10] означает номер элементам массива

  b[10]  означает что мы хотми посмтреть соедежромое 10-го элемент массива.

так вот такая же хуйня есть и споинтерами.
если мы обьялвелем поинтер то хрень *p ничего незначи, точнее она значит то что перменная
p это поинтер. 

   int *p = .... 


а если мы юзаем *p уже после оббявления поинтера то *p означает нечто совем друное. 
а именно "эй компилятор сходи по адресу указаному в поинтере и счиатай ка сюда те байты
которые там хранятся. число байтов которое надо считать посмотри исходя из типа котоырй 
был укзан при обьявлении поинтера"!

поэтому нотация *p имеет два оазных значени в тексте на си . суки


так вот я кратко обозначу на счет SOCKADDR. в bind() мы передаем поинтер на нее.
так вот как на самом деле делают люди. они создают переменную у которой тип не sockaddr 
а другой тип. они заполняют туперемнную данными. и создают на нее поинтер. 
а потом они создают новый поинтер и говорят чтобы копитоор счиал что якобы по тому адресу
лежит структ SOCKADDR.  далее этот поинтер скармливыается в bind() , этот бинд он заранее
знает что ему передали поинтер на саоммо деле на другой тип по видом поинтерана  sockaddr
поэтому bind анализирует первые два байта по этому адресу . и на оснвое этого создает
свой поинтер в которого будет исходный тип на эту область памяи. например 

 создаю 
    struct sockaddr_in6  sa1    = ....;
    struct sockaddr_in6  *p_sa1 = &sa1;
    struct sockaddr      *p     = (struct sockaddr*) p_sa1;
    bind(..., p, ... )

код bind анализиует первые два байта. и понимает что на самом деле это поинтер на
sockaddr_in6 и он делает обратное преобразование

    struct sockaddr_in6  *p2     = (struct sockaddr_in6*) p;

и далее bind() испоьзует p2 для работы. как видно sockaddr чисто служит как фейк. 
я еще вернусь к этому вопросу подрбнее. спращивеся а зачем нужна такая хуета?
нужна она потому что при копиляттор при вызываео фукцнии проверяет совпдаение типов данных
у заголовка фукцнии и у аргумента. так вот для разых типов сетевых соденеиний у нас 
структ для сокета будет иметт разный размер и разный вид. вот я щас покажу

вот структ для IPv4 (+tcp\udp)

  struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };

вот структ для IPv6 (+tcp\udp)


       struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };

у них разные поля. разные хрени. разный размер.
и  с обоими структами должен bind() работать. но в специифкации bind мы должны указать 
тлько один тип аргумента. один тип структа. поэтмоу в специиццаии укызвается некйий фекйвовый
структ. чсто только для того чтобы коипилятор на стадии компдияции неругался.  потому
что в обих случаях по факту у нас всего навсего в фкнцию будет пеередан адрес. 
а потом успешно пройдя компдиицию от компиятора. и получив адрес уже функция анализирует
какой реальный структ кроется за этим фейквым. и исправляет. я так ссчитаю зачем и почему
и как это рабоает и зачем нужен структ sockaddr

и едиснвнное треования к sockaddr и другим струкатам это то что первые два байта увсех 
структов которые мы будем юзать должны быть по спецификации одинакоыве. тоесть
вот смотрим и сравнивем  вот два реальных структа 

       struct sockaddr_in {
           sa_family_t     sin_family;     /* AF_INET */
           in_port_t       sin_port;       /* Port number */
           struct in_addr  sin_addr;       /* IPv4 address */
       };

       struct sockaddr_in6 {
           sa_family_t     sin6_family;    /* AF_INET6 */
           in_port_t       sin6_port;      /* Port number */
           uint32_t        sin6_flowinfo;  /* IPv6 flow info */
           struct in6_addr sin6_addr;      /* IPv6 address */
           uint32_t        sin6_scope_id;  /* Set of interfaces for a scope */
       };


и вот этот фековый структ

 struct sockaddr {
           sa_family_t     sa_family;      /* Address family */
           char            sa_data[];      /* Socket address */
       };


и мы видим что первое поле у них у всех ПО ТИПУ одинаковое sa_family_t. поэтому через него
и происходит идентиацификация истиинного типа структа. ну итакже я напоминаю что у нас вместе
со структом поинером преедается в bind() и размер структа в трететем аргументе. а размер 
струкаттоже многое говорит о том что это за структ. потому что 

sockadr_in имет размер 16 байт
а 
sockadr_in6 имеет размер 28 байт. 

поэтому если  в фунцию посутил поинтер. и поступило что размер перенно на которую он ссылается
равен 16 значит это вреальности структ на  sockadr_in а если рамзер равен 28 то это поинер
на структ sockadr_in6

иначе всю эту шарманку не обьяснить.
если мы возьмем код програмы то мыувидим. 
чловек создает структ  sockadr_in6 для буудущего ipv6 конекта. этот структ имеетразмер 28 байт.
потом он на него создает поитер с типом sockaddr а мы знаем что этот тип имеет длинну 16 байт.
и этот поинтер передает в bind() . если бы бинд  в реаьности работал бы с этим поинтером
считая что за ним сидит sockaddr то он бы прочитал какакото мусор в размере 16 байт из 28 
необбхоимых. поэтмоу я считаю что  структ sockaddr он не исплзтктя в реаьности биндом. а нужен
только чтобы прскочить передать наш поинтер внутрь фнкции на этапе компилиации и все.



