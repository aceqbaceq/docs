| select

хотел я обсуить эту либц функцию.


зачем она нужна. мы в нее передаем массив из номеров файл дескприторов. например это 
массив [0 2 ]
далее наш процесс засыпает
тоест блокируется и ядро следит если хотя бы один дескпритор готов для операции чтения
или операции записи или в какотом дескприторе возникла ошибка. 
например полржим что в дескриптор 0 поступили данные. и из него получается можно будет будет
данные прочитать без блокирования. 
тогда ядро будит процесс. и на выходе возвра
щает массив с теми дескприторрами в которых чтото произошло. в данном случае это дескпрптор 0
тогда мы из кода процесса скаиурем массив находим что дескпртор 0 готов для чтения и можем 
спокойно запустить процесс чтения зная что там есть данные есть что читать и операция 
чтения как уверяет манул небудет блокирующей.  не очень понимаю как ядро может гарантиртвать не 
блокировку на опкрации чтения например. потому что при опраиции чтения мы указываем сколько
байт мы хотим прочитать. а если их столько нет то ядроже заблокирует чтение! непонятно.
в целом эта коанда кладет процесс в сон . а ядро следит непоизошло ли чтот на указанных
дескпроторах. если чтото прооисзошло то ядро будет процесс и возвраает массив дескприоров
с которым чтото произошло. 


синтаксис
 #include <sys/select.h>

 typedef /* ... */ fd_set;

 int select(int nfds, fd_set *_Nullable restrict readfds,
                  fd_set *_Nullable restrict writefds,
                  fd_set *_Nullable restrict exceptfds,
                  struct timeval *_Nullable restrict timeout);



fd_set *_Nullable restrict readfds  = в этом параметре передается указатель на массив в 
   котором записаны номера дескриптороа за которым мы просим ядро следить о том что в них
   пояивлись данные тоесть из них чтото можно будет прочитать


fd_set *_Nullable restrict writefds = аналогично здесь указываются номера дескприоров которые 
    мы хотим следить чтобы в них можно было чтот записать.  я вот не понимаю смысл условия
    при котором можно или нельзя писать в дескрпитор. может суть в том что ядро четко знает
    занято ли устройств само физическое на которое мы хотим писать. важно одно - что типа когда
    по мнению ядра в этот дескпритор писать можно то select() вернется из ядра к прцессу и
    можно запускать write() в десрипторы которые в переданном массиве помечены будут и операция
    write() небудет блокирующей

fd_set *_Nullable restrict exceptfds  - здесь прописыватся дескрптторы за котоыре мы хотим чтобы
    ядро следило нет ли ошибки на каком дескприторе. о каких ошибках идет речь хрен знаает


теперь представим вот что - в первый массив мы передали [0 1 3]  во втоорой массив [2 5 6]
в трейтий массив [0 10 12]
теперь мы находим среди этих дескрипторов число максимальное. это 12. так вот в  параметре
int nfds   мы указываем число на +1 больше. тоесть   13


struct timeval *_Nullable restrict timeout)  = в этом параметре указывается время в течени
которго ядро будет ждат наступления события хотя бы на одном дескрипторе. а если время исчерапно
то ядро вернется по таймауту. если указать NULL то время будет бесконечное.


итак мы суем в эту фнукцию три массива с дескрипторами , время которое ждать
и некое число которое (максимальный дескрпитор из всех массивов+1)  и  запускаем функцию

дескриптроры суются в массив (который не просто массив а struct) через спец командs(точнее
через МАКРОСЫ)

вот этот макорс он стирает все дескрипторы которые есть в структуре. 

         FD_ZERO(&readfds);

написано так 
This macro clears (removes all file descriptors from) set.  It should be employed as the first step in initializing a file descriptor set.

вот этот макрос он вставляет конкретный дескриптор уже в struct

         FD_SET(STDIN_FILENO,&readfds);



таким образом вот как надо это все собрать в кучу



int main() {
    fd_set readfds; 
    int ret;

    FD_ZERO(&readfds);
    FD_SET(STDIN_FILENO,&readfds);
    FD_SET(STDERR_FILENO,&readfds);

	max_fd = (STDERR_FILENO > STDIN_FILENO) ? STDERR_FILENO : STDIN_FILENO;

    ret = select(max_fd+1 , &readfds, NULL, NULL, NULL);
        




таким образом я че делаю. я обявляю наш struct в которм буду храниться дескпиторы
    fd_set readfds; 
потом я из него все удаляю хотя там ничего  и нет
    FD_ZERO(&readfds);
потом я в него вставляю два дескпртора а именно STDIN и STDERR через их макрос имена
    FD_SET(STDIN_FILENO,&readfds);
    FD_SET(STDERR_FILENO,&readfds);
далее я ищу какой десприптоо больше  из двух.
 	max_fd = (STDERR_FILENO > STDIN_FILENO) ? STDERR_FILENO : STDIN_FILENO;
и вот тпеперь когда все аргурменты подготовлены можно запускаьт и select()
    ret = select(max_fd+1 , &readfds, NULL, NULL, NULL);


также видно то что мы вставляем в select() только один struct на то место где мы просим
ядро мониторить дескрпиторы на готовность для чтения. тоесть что в них прилетели какието
данные. в общем мы подставляем только массив для мониторинга на чтение. 
остальные массивы два это NULL.
также последний параметр тоже NULL - это время. тоесть мы просим ядро ждать наступления 
события бесконечное время


далее когда в какото дескрипторе чтото прилетит то ядро возвращает управление процессу.
и тперь надо выяснить какой из дескпрорторв готов на чтение. делается это тоже с помощью
особых МАКРОСОВ
вот этот макрос проверяет что дескриптор с таким то номером  присутвует в структе
		FD_ISSET(0, &readfds)


на практие это выглядит вот так


        if (FD_ISSET(STDIN_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDIN: %s", buffer);
            }
        }



        if (FD_ISSET(STDERR_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDERR_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDERR: %s", buffer);
            }
        }


таким образом я проверяю о том если STDIN и\или STDERR  были возвращены селектом.
да - дело в том что ядро при возврашении от селекта оно модифицирет массив\структ 
который мы ему передали и возврааещает только те дескпрторы с которым чтото стало.
таким образом еще раз 
	FD_ISSET()
он проверяет есть ли таакой дескпритор в структе после возвращения управления от селекта
к процессу. если такой дескпртор есть , значит с ним чтот ослучилось в нашем случае 
значит в него прилетели данные и из него можно читать

еще момент. когда мы один раз использовали select() то для повторного использования
нужно повторно  убрать все дескприторы из структа и туда их заново напихать

         FD_ZERO(&readfds);
         FD_SET(STDIN_FILENO,&readfds);
         FD_SET(STDERR_FILENO,&readfds);

и только поле этго можно заново вызывать select()

еще момент- структ который мы юзаем он может иметь максимум 1024 дескриптора 
в этом огарнчиение селекта.

еще момент.  в функцию мы преедаем указатель на структ. поэтому когда функция запускается
то в нее копируется только копия указателя на структ. поэтмоу раземер структа в этом плане
не игает роли. но! далее ядро проверяет все дескрпиторы котоыре есть во всех переданных 
структах. потом ядро выидывает лишние дескприторы из структов при возврашении. поэтому чем
болше диескприоторов в структе\структах тем  дольше ядру приходится сканировать все дескпритаторы.
тоесть может поменяться один дескпритор но если у нас массив из 1024 десерипторов то ядру 
приется все их проверить. в этом проблема по скорости.
далее. значение которое селект возвращает
    ret = select(max_fd+1 , &readfds, NULL, NULL, NULL);
в данном случае в перемнную ret вот имеет какой смысл
   On success, select() and pselect() return the number of file descriptors contained in the three returned descriptor sets (that is, the total number of
   bits that are set in readfds, writefds, exceptfds).  The return value may be zero if the timeout expired before any file descriptors became ready.
   On error, -1 is returned, and errno is set to indicate the error; the file descriptor sets are unmodified, and timeout becomes undefined.

тоесть возвращается общее число дескрипторов (их сумма) из трех структов с которым чтот слусичлось 


вот вроде все рассказал про этоо seelect()

	man 2 select


программа которая все это делает 

	243.c

она правда чуть проше. она мониторит только fd/0 дескрпитор. тоесть одну штуку
а не два.  она монитторит если чтот оприлетело на fd/0 и если да то печатает на fd/1


ТЕПЕРЬ О ВАЖНОМ!:
я столкнулся с этим когда изучал select() с парадоксом который никак не мог понять. 
а потом понял. значит какой я парадокс увидел - вот внес я в структ который на чтение про
верять будем fd/0 и fd/2 запульнул select() , далее пуляем на наш процесс снаружи байты на fd/0(STDIN) , ядро  возвращает управление процессу. далее мы начинаем проерять  установлен ли 0
в структе. получаем что да установлен. мы читаем из fd/0 данные


        if (FD_ISSET(STDIN_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDIN: %s", buffer);
            }
        }



далее мы проверяем установлен ли 2 в структе


        if (FD_ISSET(STDERR_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDERR_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDERR: %s", buffer);
            }
        }


и получаем парадоксальное что да дескпритор 2 тоже был устанолвлен селектом. что за бред?
далее мы пробуем из него читать но на операции read() у нас происходит блокировка тоесть читать
оттуда окзаывается нечего. ну это и понятно потому что мы ничего в fd/2 не послылаи. но вот 
вопрос  наш select() установил нетолько  дескриптор 0  на который реально мы знаем что прилетели
байты но и дескприптор 2. почему? ведь на дескпритор 2 мы ничего не посылали!
так вот оказываетя вот в чем правда. у обычного проецесса у него все три стандартных дескпритора
0,1,2 они все ведут на один и тот же файл  /dev/pts/N
так вот когда байты прилетают к нашему процессу они прилетают из ядра. и прилетают они не на
дескриптор. они приетают на тот файл на который этот дескпритор смотрит. показываю
как это работает

граф экран--->fd/11 xterm fd/5<-----ядро---->/dev/ptmx <----- ядро ----> /dev/pts/15=fd/0 bash
 

значит мы тыкаем на экране граф черном кнопку. это все хавает ядро и оно через посреников
которые щас неважны присылает этот байт в процесс xterm через fd/11
xterm берет этот байт и  шлет его в файл /dev/ptmx погнятно что это не файл на диске а некая
абстрация от ядра но это неважно. важно то что процессу запрещено писать в файл напрямую для этого
у процесса есть дескриптор и поцесс просит ядро показывая дескпртор чтобы ядро записало в 
файл /dev/ptmx кусок байтов и памяти  процесса

 (xterm)    write (5, ....,....)

тоесть xterm он только видит из своего окопа только дескпритор 5. он не видит прям физ файл 
/dev/ptmx. его видит ядро! поэтому xterm  показывает ядру 5 и говорит запиши из моей памяти 
несколко байтов в тот файл который у меня занчится как 5.
таким образом я показал как байт с клавиатуры попадает внутрт xterm а оттуда в /dev/ptmx

	граф экран--->fd/11 xterm fd/5<-----ядро---->/dev/ptmx

просто путает то что  я знаю что /dev/ptmx это не файл на диске а виртуальный файл. 
а лучше прям думать что это файл на диске тогда сразу понятно какой смысл в fd/5 а какой 
в /dev/ptmx

итак у нас сейчас в файле /dev/ptmx записаны байты (кнопка 9 котрую я нажал на клаве)
но тепер вспоминаем что /dev/ptmx это не файл на диске а виртуальрый файл в памяти ядра. 
поэтому когда в него байты поступают то он на самом деле их пихает дальше в файл /dev/pts/15
это тоже вирт файл. но опять же проше считать что это файл на диске. а у нас этот файл 
открыт процессом баш и для баш  обозначение этого файла идет через fd/0  внутри баща

	/dev/ptmx <----- ядро ----> /dev/pts/15=fd/0 bash

значит и суть такая. у нас в файле /dev/pts/15 появились байты. грубо говоря файл имел нуле
вую длинну а стал имеьт какую то ненулевую
но! у нас пока что файл вырос в размерах! а в баш проецсс ничего пока не прилетело! 
вот аналогия открыли мы файл на диске в процесе-1

процесс-1
  ret = open("/tmp/1.txt")

у нас ядро процессу верруло что ret=10
далее мы через другой процесс-2 взяли и заисали в этот файл скажем 15 байт. 
так вот процессу-1 от того что файл /tmp/1.txt вырос в размерах ни холодно ни горячо. чтобы 
байты посутившие в файл /tmp/1.txt попали в процесс-1 он должен их прочитать через

  read(10,....)

тоест я хочу пдрчекнуть если у нас процесс открыл файл. а сэтим файлм чтото происходит в плане 
прибавления байтов то процессу от эттого ни холодно ни горячо. чтобы байты из файла попали в 
процесс ондолжен их отдлеьной командой и своей волей прочитать. иначе новые байты в файле 
так и останутся в файле но не в памяти процесса!
так вот возвращаеся к нашей ситуации

	/dev/ptmx <----- ядро ----> /dev/pts/15=fd/0 bash

у нас ядро увеличило размер файла   /dev/pts/15 , у нас этот файл открыт процессом bash
и в баще этот файл имеет указатель как fd/0  так вот теперь чтобы эти байты засосать в баш 
это в баще надо выполнить команду

  read(0,....)

и тода наконец байт от нажатия кнопки в черном экране наконец попал в bash процесс
а теперь я показываю одну вещь тонкую . у процесса есть три файл дескриптора обычно 0,1,2 
это значит условно что процесс открыл три файла на диске а 0,1,2  это ядро выдало процессу
талончики которые процесс будет предьявлять ядру вместо имен файлов когда будет просить ядро
чтото записать или прочитать из открытых файлов. есть огормная разница реальный файл на диске
который недоступен никоода процессу для прямого доступа , процесс невидит файл никогда . 
процесс слепой. процесс только видит у себя номерок 0, или номерок 1 или номерок 2. вот эти
номерки это все что видит процесс. и процесс идет к ядру и говорит  - слушай ядро возьми у меня
из памяти несколько байтов и запиши их в файл который я невижу но который условно называется 0.
ядро смотрит о каком реально файле идет речь. видит что номерок 0 это на самомо деле файл 
/tmp/1.txt и тогда ядро берет из памяти процесса байты взвалиает себе на плечо и уже идет к 
раельному файлу физически лежашему гдетотам и туда пихает эти байты. у процесса есть толкьо 
номерок 0 а файла нету. и у процесса есть байты в его памяти. файл же видит ядро. оно беерет
байты из памяти процесса и сличает какое реальное имя у файла соотвтсвующее номерку 0 которое
ядро показал процесс. пэтом есть огромная разница между fd/0 тоесть просто это число которое
хранится в памяти процесса. и реальным файлом которое видит только ядро. процесс реальный файл
невидит. неимеет никакого доступа. файл /tmp/1.txt лежит на диске и доступ к нему имеет только 
ядро. а номерок  0 лежит в памяти процесса. вот такая огромная разница между fd/0 и /tmp/1.txt
дескриптоор 0 это всего нвсего число которое сохранено в памяти процесса. и он имеет к нему
доступ.  а файл /tmp/1.txt лежит на диске. и к нему доступ имет только ядро. номерок 0
это тот параметр который процесс предеает ядру как обозначение с каким файлом на диске проецесс
просит ядро поработать и либо оттуда чтот считать и запихунть это в память прцоесса. либо 
чтобы ядро взяло байты из памяти прцоесса и записал в файл


 	 процесс fd/0+ байты в памяти <----ядро -----> /tmp/1.txt

так вот я взвраащаюсь к нашему башу. у него есть три дескпритора 0,1,2
значит процесс баш имеет три номерка каждй из которых  обясняет ядру  имя файл на диске.


  0 ----> /tmp/file1
  1 ----> /tmp/file2
  2 ----> /tmp/file3

 тоесть если процесс напшет

  read(0,&buf,15)

то таким образом процесс обьяснить ядру что ядро длжно залезть на файл /tmp/file1 
считать оттуда 15 байт и засунуть их в память процесса по адресу &buf

тоесть еще раз - то что у нас процесс имеет три дескпритор 0,1,2 означает что процесс может 
просить ядро прочитать  байты из трех файлов на диске  и записать это в памяь процесса.
сам процесс неимеет доступа к файлам этим. но может раотать с ними через ядро как посредник.
числа 0,1,2 как бы шифруют названия от пути к файлам на ФС.
итак я пояснил физ смысл дескрипторов. если у нас десять дескрпоров 0,1,2,3,4,5...10
то это значит что у даного процесса есть билетики от имен десяти файлов на диске. и он 
может просить прочитать чтото с этих файлов ядро подставляя в read() номеров вместо имени
файла. а ядро поймет про какой файл идет речь. так вот абсолбтно легко может быть ситация когда
все три дескпритора ведут на один и тот же файл

  0 ----> /tmp/file1
  1 ----> /tmp/file1
  2 ----> /tmp/file1

можно хоть сто раз выполнить 
  open(/tmp1/file1)

и ядро выдаст процессу сто номерков (файл деспроров) каждй из которых ведет на этот файл.
ядру похер. ну и получается то что если мы чтот записали в файл /tmp/file1 из другого процесса
то в нашем процессе мы можем это считать используя ядро и используя любой из дескприторов 
хоть 0 , хоть 1, хоть 2. это совершенно без разницы! потому что условно говоря дескпитор 
это как бы просто такой признак такой код который процесс предявьяет ядру вместо имени файла
а ядро уже отлично понимает что если ему показали 0 то на самом деел процесс просит ядро обра
титься к файлу с именем  /tmp/file1 и если у нас и  0 кодирует имя файла /tmp/file1
и 1 кодирует имя файла /tmp/file1 и 2 кодирует /tmp/file1 то совешенно без разницы какой из
этих номерков процесс испольщует при обращениик ядру в read()

		read(0,..)
		read(1,..)
		read(2,..)

у баш процесса дескприорторы 0,1,2 они обычно смотрят на файл  

	/dev/pts/N

например
	
	/dev/pts/15

да это не файл на диске а виртуальный. но  это без разницы. он такую же имеет суть как файл 
на жестком диске. 

  0 ----> /dev/pts/15
  1 ----> /dev/pts/15
  2 ----> /dev/pts/15


так вспоминаем что ядро засунуло байты в этот файл /dev/pts/15 тоесть размер файла бул нулевой
а стало какогто размера.  так вот процесс баш от того что на файле на диске произлшли изменения
ничего незнает. у него только есть талончики с номерами 0,1,2 котоые кодирую одно и тоже имесли я
файла а от того что в файле чтото изменилось башу об этом ниче не известно. он этот файл в глаза
не видел. и важно!- ядро видит что файл /dev/pts/15 связан с баш процессом. ядро видит что 
баш процесс имеет талончики 0,1,2 которые коируют имя этого файла но ядро увеличив размер файла
/dev/pts/15 автоматом эти байты внутпт проесса баш не пихает как это может интиутивно показаться!
даже потому что чтобы запихнуть байты из файла в память процесса , то процесс должен укзаать 
ядру в какое конкртеное место а пмяти процесса нужно байты запихать! поэтому ядро ничего неделает.
оно изменило контент файла /dev/pts/15 но както там брать какето байты из этого файла и пихать
их без запроса в какито процессы в их память ядро нихуя никога не будет. тоесть я хоетел таким
макаром подрнуть то что от того что какойто файл на диске имзенил свой коннтент это не озанчает
что этот контент будет ядром автомтом просунут в какие то бы нибыло процессы внезависмости 
ест у этих файлов дескрпиторы которые ведут на этот файл или нет.  повторюсь что для этого много
причин. если файл лежит на реланом диске то это блочное устройство и для того чтобы байты из 
файла попали в процесс ядро доолжно знать в какой процесс пихать байты потому что может быть 
туча процессов и все они имеют дескриптор или десприторы на этот файл. во вторых ядру надо 
знать в каокй кусок памяти процесса пихать байты из файла если мы хотим запрсать в процесс
или ядру нужно знать область памяти в процессе из которой надо взять байты чтобы запихнуть их
в файл. причем если файл лежит на блочном устостве то ядру также надо знать с какого оффсета
внутри этого файла нужно читать или писать байты. для этого есть хрен под названием курсор.
его можно менять со стороны процесса. двигать.если файл лежит на CHAR устройстве. то там 
насколкьо я понимаю запись идет всегда в хвост файла а чтение идет всегда с головы файла.
/dev/pts/N это char устройство. а скажем /dev/loop15 это char устройство
тоест работая с блочными файлами мы можем гулять туда сюда внутри файла  а с CHAR файлами
мы неможем со стороны процесса менять положение курсора которй задает позицию внутирии файла
начиная с которой надо рабтать. 
вот ка можно посмотеть тип файла через stat


   $ stat /dev/loop3
  File: /dev/loop3
  Size: 0         	Blocks: 0          IO Block: 4096   block special file

   $ stat /dev/pts/15
  File: /dev/pts/15
  Size: 0         	Blocks: 0          IO Block: 1024   character special file

вот мы видим написано  "block special file" или "character special file"
а что же он покажет для обычного файла который лежит внутри блочного устройства

  $ stat /tmp/1.txt 
  File: /tmp/1.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file

видим что это тип  регуляр файл

тоже самое можно смотреть чрез ls
 $ ls -1al /dev/loop3
brw-rw---- 1 root disk 7, 3 ноя 24 13:17 /dev/loop3

 $ ls -1al /dev/pts/15
crw--w---- 1 root tty 136, 15 ноя 22 21:58 /dev/pts/15

 $ ls -1al /tmp/1.txt 
-rw-r--r-- 1 noroot noroot 0 ноя 27 14:23 /tmp/1.txt

как видно тип файла обозначен самой левой буквой. регулчрный файл обозначается "-"

положение курсора после открытия файла можно двигать со стороны прцоесса через 

		lseek()

или чтото типа того.
насколько я полагаю если природа файла непозвоялет двигать внутри него курсор то ядро 
просто пошлет нахер вернут ошибку и все.

вобшем я пытался донести что если с физ файлом чтото происходит то это своршенно ничего
не взывает в процессах которые имеют дескприторы укзывающие на файл!
есть два совершенно незавимых механизма - измнеение контента файла и  попадание байтов 
из файла внутрь памяти процесса.  контент файла может мняться а байты из файла могут не попадать
в процесс. или файл может не меняться а байты из файла могут попадать в процесс. это два незави
симых незсвязанных механизма.

итак мы имеем файл 
	
	/dev/pts/15

в него ядро записало както новые байты.

есть процесс bash у которого есть три дескпитора которые кодируют имя этого файла со стороны
проесса для ядра. 

  0 ---->  /dev/pts/15
  1 ---->  /dev/pts/15
  2 ---->  /dev/pts/15


теперь скажу такую вещь. когда ядро меняет содержимое файла то оно где то там внутри своих 
кишок об этом делает пометку. когда мы со стороны процесса посылаем в ядро select() 
и в нем указываем дескпритор например 0 на предмет проверки возможности чтения и я точно пока
не понимаю критерии по которым решает ядро но видимо когда размер файла меняется скажем 
в бОльшую сторону то очеивдно что из этого файла есть что читать , а ведь тело файла в конечном
итоге внезависимости кто был закачик меняет ядро поэтому коечно оно всегда знает момент когда 
тело файла оно поменяло. а раз рзамер файла увеличился то из него можно чтото прочитать 
и тогда ядро возращается из select() и передает управления процессу и сообщает процессу о 
том что вот мол дескоиптор 0 , в том плане что из файла на который указывает деспритор 0 
можно успешно читать потому что туда прилетели данные. еще раз почрекрну на основе какго криетерия
ядро решает что вот теперт можно читать из файла неопнятно. ну вот так как в даном случае 
/dev/pts/15 это char файл то по дефолту он пустой по размеру. а если его размер увеличился то 
очевидно что появилось чтото что из него можчно прочитаь. также полягаю что чтение идет всегда
с головы файла. и также то что при чтении из этого файла его размер автоматом уменьшается.
таким образом если ктото навалиил байтов в этот файл. то ясно что есьт что читать и об этом
можо ссообщить. а если ктотто прочитал из файла то чиать там нечего. я так понимаю логику
работы ядра при обработке seelect()

а теперь тот самый штук к которому  я подовводил - вот я   селект() передал два дескпритора
0 и 2 на проверку что из них можно читать. селект() запустился и работает в коде ядра.
сам проецсс спит. в какйото момент ядро по заказу со стороны навалило  в файл /dev/pts/15 
несколько байтов. далее ядро обрабатывает селект() и  делает пометку что тпеперь  можно 
делаьт чтение и из дескриптора 0 и из дескриптора 2. почему ядро пометило что оба дескпритора
могут успешно быть исползованы для чтения из файла /dev/pts/15 ? а потому что оба этих 
дескриптора кодируют один и тот же файл! поэтому раз файл /dev/pts/15 наполнился байтами
то ядро просто напросто взяло  первый дескриптор котрырй мы всунули в слелект() 
это дескпритрр 0 . посморело какое имя файла он кодирует. это файл /dev/pts/15 потом ядро
проверило налился ли новый контент  в файл? ответ да. значит дескприттор 0 пригоден для 
успешного чтения. потому что он указыает на файл /dev/pts/15 а у него появился контент. 
потом ядро взяло следущий дескпритор 2. посморело какое имя он кодирует . получаило что кодирует
файл /dev/pts/15. проверило налился ли новый контент в этот файл? ответ да. тогда ядро пометило
что декприттор 2 пригодне для успешного чтения.
таким оразом если бы у процесса было 50 рзных деспрторов которые все "указывают"
или кодируют как я называют имя одного и тгоже файла /dev/pts/15 и мы бы все эти 50 
дескпрторов заунсули бы в select() то ядро при возврате из этого сисколла нам бы вернуло 
все 50 дескпртторов , что из них можно успешно читать.!
а дальше мы полуим прикол.
ядро вернулось из select() наш процесс начал выполнять свой код дальше.
и мы начинем в рамках нашего процесса  проверять все деескприторы которые мы засунули в 
сеелект() на предмет того какие деспритторы нам сисколл вернул с подверждегием что из них
можно успешно читать, что в файле сиящем за этим десприрорм есть данные. 
и мы берем первый дескрпттор который снунули в селеткт() - это десприптор 0 
и проверяем его

        if (FD_ISSET(STDIN_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDIN: %s", buffer);
            }
        }


и мы получим что да. селект() нам его вернул. и мы тогда читаем из файла который сидит
за этим дескрпиором.  при этом у нас так как /dev/pts/15 непоросто файл а особоый файл то
после того как мы с него конеткнт порчитаем то его размер станет равен нулю. (вот такие 
увительные файлы как воздушные шары. если мы из них читчаем то их размер сжимается до нуля.)

потом мы беерм ледущий десприпторк оторый мы сунули в селект() это десприптор 2.
и тоже проверяем.  вернул ли нам его селект()

        if (FD_ISSET(STDERR_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDERR_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDERR: %s", buffer);
            }
        }


и как я уже говорил что селект() конечно его вернул! тоест это нам синал от ядра что можно
без прбрем читать файл который сидит за этим дескрпитором. и мы начинем его чать
а читать там невчего! наш сискол  read() он просто повиснет заблокированный! потому что 
наш десприттор 2 уазывает на тот же файл /dev/pts/15 а он у нас к этому ммоенту уже сдулся
до нулевого размера!  и получается как бы парадокс - как же так если у нас селект() вернул
деспритор то ядро гарантиурет что в файле за этим депритором есть конетент байты и что 
комана чтения не будет блокирована поэтмоу. а мы получили обратное! но парадокса нет!
на момент возврата из ядра чтения из любого одного дескрпитрора хоть 0 хоть 2 будеет успешным.
потому что за каждй из них сидит файл с конетнотом! ядро не виновато что оба эти десприптора
смотрят на один и тот же файла. и это полбеды. беда в том что при чтении из этого файла его
контент сдувается. если бы это был обычнчй файл то чтение через 2 после того как мы почитали
чреез 0 успешно бы отработало! 

итак еще раз опишу якобы парадокс. селект() если возрващает номера десприоров то это означает что
ядро собщает что если читать файл из любого десприттора то чтение будет успешным. что каждый 
файл на котоырй указывают возвращенные деспритпоры имеет контент. и что чтение будет успешным
неблокирующим. мы имеем процесс с двумя дескприторами  0 и 2 ои указывают на один файл 
/dev/pts/15 мы суем 0 и 2 в селект() и запускаем его. далее мы суем в файл /dev/pts/15 со сторны
ядра байты. ядро на это регирует и возврашается из селекта в процесс. и возврвшает 
оба деспритора и 0 и 2. мы проверяем что 0 устанолвен. получаем ответ да. чиатем из 0. 
опрация успешная. потомц мы провреем что 2 тоже устнолвен. мы пробуем чиатть и наш 

 read(2,)

он блокируется. поотому что 2 указыаем на тот же файл что и 0. и мы уже проитали конетент 
файла /dev/pts/15 используя деспритор 0 . и ктгда мы читали такак этот файл особый то его
контент сдулся до нуля. поэтом несморя на то что селект нам верул деспрттор 2 чтения у нас
не получилось через него.!
так вот я говорю что на момент взрвата ядра из селекта успешное чтение было возможно из 
обоих дескприторов 0 и 2 которые вернул селект. если бы мы проверяли первым деспрттор 2 
и начали бы читаьт первым из файла через него то процесс чтения был успешным. 
ядро не виновато что мы указали два деспритра котоыре ведут на один файл. но даже не в этом
проблема а в том что файл то омсобый. при чтении из него его контент исчезает. поэтому последова
тельное чтение анчале чрез десприттор 0 проходит успешно а чтение из десерпитоо 2 уже приводит
к неудаче в том плане что read(2) будет заблокирован.
тоесть у нас срабатвыает сумма двух файторов - мы предали в селект несколько десприторов которые
смотреят в один файл. и то что файл этот необычный а сдувающийся до нуля при первом чтении
из него.

есть еще важный момент якобы парадокса другого. 
вот у нас есть процесс баш. у него 0 и 2 смотрят в /dev/pts/15
мы засунули 0 и  2 в селект и запустили. наш баш нахрится в спяшем состоянии. 
а дело в том что /dev/pts/15 это не просто файл который связан с xterm а это процесс 
связан с  процессом Xorg а тот связан с графическим окном. и вот наш баш спит но  я тыкаю
кнопки на клаве. и ядро берет эти кнопки эти байты и ловит их и шлет на Xorg
а тот шлет на xterm а тот шлет на /dev/pts/15 
далее ядро видит что файл этот измнился наполнися байтами и он видит что данный файл 
имеет деспритор 0 у баш процесса. и что баш процесс попросил ядро сообщить ему башу о том что 
из деспритор 0 можно читать. ну и дейситвельно из 0 баш может теперь читать потому что 
файл н акоторый 0 указывает имеет байты. тоже самое касается деприптора 2. что ядро видит
что процесс баша преедал ядру деспрттор 2 и попросил баш уедомть что можно читаь из 2 
потому что файл который уазывает на 2  полуиил новые байты. и так как 2 указывает на /dev/pts/15
и он получил нвоые байты то ядро в итоге будит баш. выходит из селект() и возвращает массив
из десприторов 0 и 2. у члоека который тыкнул кнопку на термиале возниукает дурацукая 
мысль что кнопка на котору он нажал прилетела на STDIN баш процесса. поэтому мол селект()
и вернулся.  и человек думает полагает что селект () вернулся тлоько с дескриптором 0
но когда начинает выполнясять вот такой код

        if (FD_ISSET(STDIN_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDIN: %s", buffer);
            }
        }



        if (FD_ISSET(STDERR_FILENO, &readfds)) {
            char buffer[256];
            int len = read(STDERR_FILENO, buffer, sizeof(buffer) - 1);
            if (len > 0) {
                buffer[len] = '\0';  // Null-terminate the string
                printf("FROM STDERR: %s", buffer);
            }
        }

 
то вдруг выясятес что селект() вернулся и с депритором 0 и с деапритормо 2!
и человек думает что за херня! я кнопка ведь прилетелела якобы на 0 на STDIN! тлоько 0
должен был венуться из селект() мол почему еще и 2 венулся? мол яже не сслал кнопку на
2  я же ее слал на 0!! и в этих суждегиях выражаетсся огромное неопнимаение что 
происходит при нажатии кнопки на граф окне черном. черное окно на экране это считай мы 
видим глазам ядро. между граф окном и клавой и башем огромная пропасть состоящая из

граф окно --- xorg --- xterm -- bash

но это еще не все.  рассотрим более подрбно цепочку между xterm и bash


xterm fd/5 --ядро--> /dev/ptms --ядро--> /dev/pts/15 <--- fd/0 
                                                     <--- fd/1    bash
                                                     <--- fd/2   


и тут надо все подробно обьяснить. во первых что такое файловый дескрпиттор. 
я считаю что тот номер который возрвшаает ядро пороцессу это ИМЯ ФАЙЛОВОГО ДЕСКПРИТОРРА.
сам файловый десприпттр создается  и сидит в памяти ядра. и STDIN это алиас к имени 
файлового дескприптора "0" . тоесть унунжно различать имя файлового десприпттора и файловый 
дескприптптор. и то что для некоторхы имен файловых десприпторов есть альтерантивные псевдонимы.
тоесть STDIN это псевдогим для имени файлового десприпттора 0.
а теперь как происходит скажем чтение из процесса файла.  процесс передает ядру имя 
файлового десприптора. ядро смотрит у себя в памяти в тело файлового десприпттора которые
у него сидит в его памяти. в нем находит иноду файла. лезет на сам файл. читает там кусок
и копирует этт кусок в память процесса. как видно байты кочуя от файла к  памяти процесса
минуют записвыание их в тело файлвого дескприптттора. поэтому когда говорят я записал 10 байтов 
на STDIN процесса-1 то это полная хуйня.  потому что макимум что можно сделтаь это заптсать
10 байтов в файл на который указывает файловый дескприпттор с именем STDIN\0
и когда мы записали в файл байты то процесс может их оттуда читать а может и не читать. 
в само тело файлового деприпттора с именем STDIN\0 ни внешний процесс ни сам процесс ни ядро
байты никак не записывает это невозможно. тоесть я хочу скаать чтовнешний процесс неможет 
запихнуть 10 байтов ни в память процесса, ни в тело файлового десприптора. это все невзможно.
максиум что взможно это внешний процесс может запитсать байты в файл на который указвыает 
тело файлового десприптоора. все.  ни в сам процесс невозможно впихнуть данные извне помимо 
и без ведома процесса. также невозможно впихнуть снаружи данные в тело файлового дескрипттоора 
по воле внешнего процесса. это все невозможно.! и если на файл указывает несколько тел 
файловых десприпторов. например тела файловых дескприпторов с именами 0,1,2 могут 
указывать на один файл.  и процесс может счиать данные из файла исполтьзуя любой дескприптторп
хоть 0 хоть 1 хоть 2. вопрос тогда если мы присалли байты в файл на который они смотрят то 
мы присали байты на файл котоырй относистя к каом дескприптрору? STDIN? STDOUT?STDERR? 
или сразу ко всем?

поэтому когда мы тыкаем кнопку на черном экране то можно максимум что сказать это то что
этот байт будет записан в файл на который укащывают сразу три тела файлоых десприпторов  имена
которых STDIN\STDOUT\STDERR !!
вот как в этом случае

xterm fd/5 --ядро--> /dev/ptms --ядро--> /dev/pts/15 <--- fd/0 
                                                     <--- fd/1    bash
                                                     <--- fd/2   



байты с кнопок прилетят в файл /dev/pts/15 на который указывают тела трех файловых десприпторов
fd/0 , fd/1, fd/2 

вот куда попадут байты. а дале процесс баш у котрого  хранятся имена 0,1,2 тел файловых 
десприпторов которые все ссмотрят на файл /dev/pts/15 он(баш) может либо считать этот файл 
либо не читать его вообще. а если читать то он (баш) может это сделать через имя любого 
из трех тел файловых дескприпторов. и через 0  и через 1 и через 2 !
так куда у нас кнопки с клавы были доставлены? они были доставлены в файл на который ссылаются
три тела файлоых десприпторов которые связана с процессом баш. вот только так!
если мы мониторим через selecct() и 0 и 1 и 2
то при посутплении данных в /dev/pts/15 у нас селеект веренет все три имени и 0 и 1 и 2 !
и как полчаетя трактоваять то что селект вернул нам 0,1,2 - это нужно трактовать так что 
во время возврата прилетели данные в файлы на которые указывают тела десприпторов с именами
0,1,2. но это совершенно не означает что какито байты прилетели в сами тела файловых десприпторов!
в тела ничего не прилетело! и в сам процесс ничего не прилетело! поэтому если мы видимчто
селект вернул 0,1,2 это совершенно незначит что к данному моменту данные поступили внутрь
процесса через тело файлового десприптооара с именем 0 и 1 и 2. даныне внутрт процесса 
вобще нихрена не поступили! также данные не поступили в тела файловых десприпторов! этго тоже нет!
что на самом деле произошло , очем сигнализирует 0,1,2 при возврате из селект. произошоло то что
поступили данные в файлы на которые указывают тела файловых десприпторов!  а посоольку они 
все указыат на один файл то получается что посутили данные в файл /dev/pts/15  все!

поэтому я обьсянсяю что и как происходит если я заупустил в темринале xterm прогу
которая запустила 

  select()

и в этом селекте прога указала мониторить 0,1,2

вот эта прога для примера 248.c


 $ cat 248.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/select.h>
#include <errno.h>
#include <unistd.h>

int main() {
    fd_set readfds;
    int ret;
    


         FD_ZERO(&readfds);
         FD_SET(STDIN_FILENO,&readfds);
         FD_SET(STDOUT_FILENO,&readfds);
         FD_SET(STDERR_FILENO,&readfds);


         ret = select(3, &readfds, NULL, NULL, NULL);
        
        if (ret == -1) {
            perror("select error");
            exit(1);
        }



        if (FD_ISSET(STDIN_FILENO, &readfds)) {
                printf("STDIN descriptor is returned\n");
        }


        if (FD_ISSET(STDOUT_FILENO, &readfds)) {
                printf("STDOUT descriptor is returned\n");
        }

        if (FD_ISSET(STDERR_FILENO, &readfds)) {
                printf("STDERR descriptor is returned\n");
        }




    return 0;
}


вот я ее запускаю
и ввожу 1 и тыкаю энтер
1

и она пишет на экране

STDIN descriptor is returned
STDOUT descriptor is returned
STDERR descriptor is returned


что произошоло. я в селект() засунул  имена десприпторов 0,1,2 в тот массив который проверяется
на возможность чтения. 
далее  я в терминале ввел 1 и нажал энтер
и получается что селект вернул массив из имен дескприпторов в кототоромы были номера 0,1,2
почему такой резлульат? потому что мое нажатие на кнопки было доставлено ядров в конечном
итоге до файла 

		  /dev/pts/15

имя это файла указана во всех трех телах файловых дескрппторов с именами 0,1,2
кгда байты прилетели в   /dev/pts/15 то ядро последовательно проверило то что все три тела
файл деспрпторов 0,1,2 смотрят на этот файл. и так как все три тела десприптора  это независимые
стркутуры в поле ядра то в кадждый десприпттор ядро записало информацию  о том что файл на котоырй
смотрит каждый десприпттор получил байты. а занчит из него можно чиатать. и поэтому селект() 
вернул все три имени 0,1,2 потому что с точки зрения каждго десприптоора файл на который он десприптор укзаываем изменился. поэтому об этом и рапортует селект(). а то что все три десприптора
укзыват на один файл то каждому десприптору на этот факт плевать и ядру тоже. 
если нам селект возвращает какието имена десприпторов то этонезначит что внутрт процесса поступили
какието байты через тела указанных деприпторов! нет! вунтр процса ничего не поступуло!
также это незначит что в тела самих деспрпиторов залились какето байты! этого нет! но это значит
что в теле десриптора имя корого вернулось ядро сделало запись о том что файл на котоырй он 
десприптор укзаывает изменился! вот что это значит. вот что значит физ смысл тех имен 
десприпторов котоые возвращаются селектом!





а что если файл на диске? как тогда селект() рабатает?

