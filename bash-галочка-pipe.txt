| bash
| >
| pipe



чем в баше галочка '>' отличается от пайпа '|'

когда мы запускаем какуто команду в баше он 
же как это делает. он себя клонирует в новый
процесс. потом он делает разные сисколыы маниупулируя
с файл дескрипторами. он их готовит. модицифирует.
когда файл дскексрипторы у процесса настроены как
надо тогда баш делает
 
   execve()

чтобы ядро заменило в этом процессе в памяти
бинарник баша на бинарник другой проги. таким обра
зом она уже будет иметь нужные подгтотоывленные 
файл дскрипторы. это для нее и за нее сделал баш
процесс.

так вот  символ галочка она же в полном виде
выглядит вот так

     N>/path/to/file


и это сообщает башу что в будуем процессе надо 
сделать так чтобы файл дескриптор fd/N "смотрел"
на файл путь к которому  /path/to/file

например 


   1>/tmp/2.txt

тогда в новом процессе fd/1 будет смотреть на 
файл /tmp/2.txt

что для этого на практкие делает баш.
он взывает 
    
   int q = open("/tmp/2.txt")

ядро создает для процесса новый дескриптор который
смотрит на   "/tmp/2.txt" а бащу возвращает его
номер в переменной q
далее баш обычно делает 

     dup2(q,1)

тоесть он просит чтобы ядро сделало так чтобы
дескрипто fd/1 смотрел на тот же файл на который
смотрт дескриптор q
таким образом наш fd/1 теперь смотрим на закааззный
/tmp/2.txt 
теперь тоько осатется избавиться от дексриптор q
и баш делает

      close(q)

вместо файла на диске (то что справа от галки)
можно указать номер дескриптора который уже есть
у процесса. если вместо файла мы указываем дескриптор
то чтобы баш это понял нужно его обозначить через &

       2>&1

иначае он подучает что 1 это имя файла  в теущей
рабочей папке у процесса.


это гоориивт башу что в новом процессе нужно 
сделать так чтобы дескриптор 2 смотрел на тот же 
файл что и декриптор 1
тогда башу еще проще он делает

       dup2(1,2)

и все.
также слева можно юзать дескрипторы которых у процеса
еще нет

     dup2(1, 10)

тогда ядро создаст этот новый дескриптор 10


в чем общая суть галочки. мы хотим чтобы в будущем
процессе у нас такой то дескриптор смотрел на такой
то файл. или мы хотим чтобы такйо то дескриптор 
смотрел на тот файл на который будет смотреть другой
дескриптор.  для примененеия галочки нам нужно знать
тот файл который мы хотим "открыть" или тот дескриптор
на который хотим "перенаправить" наш дескриптор.

а вот если мы хотим чтобы наш дескриптор смотрел 
не на файл а на буфер в ядре на который будет смотреть другой
дескриптор (обычно в другом процессе но не обяза
тельно) то нужен пайп.


как работает сисколл 

    pipe()

он создает буфер в ядре. и возвращает в процесс
два дескриптора. оба ссморят на этот буфер.
и если я запишу данные в один декриптор то они
попадут в ядро и можно их будет считать из 
дрргого дескриптора. в один можно только писать
из друого можно только читтать. дальш оебычно
что происходит процесс себя клонирует. и  в первом
процессе он закрыает один из демкриптров а в втором
процессе он закрывает второй. тогда получается
что один процесс пишет в один дескрипотор. а второй
процесс чтает из буфера ядра то что первый туда
записал.


галочка обычно прмиеняется для процессов которые
работают в терминале. и у них вывод или ввод идет
с терминала а мы хотим скажем чтобы вывод шел
на файл на диске. тоесть галочка часто прмиенстся
тогда когда мы хотим чтобы один из дксприороров
который выводил на экран выводил  в файл на диске.
тоеть говоря еще проще - если мы хотим перенарпавить
вывод в файл на диске юзают галочку

    echo "123" 1>/tmp/1.txt

а пайп обычно прмиентся тогда когда мы хотим чтобы
процесс чтото пишет в один дескриптор и это все
попадает  в другой пцроцесс через второй декриптор.
тоесть когда мы хотим чтобы инфо от одного процессса
попадала в другой процесс.
напрмиер 

    cat /tmp/2.txt | grep vasya

тогда у нас fd/1 прцоесса cat смотрит в пайп
в ядре
и fd/0 у процесса grep смотрит в пайп в ядре
пайп в отличии от галочки не привязывает декриптор
процесса к файлу на диске. он его привязывает 
к буферу в ядре. 
еще момент пайп в отличии от галочки раобтает 
с строго заданными дескрипторами ( я имею ввиду
не сисколл pipe() а то как баш обрабатывает 
его билти '|' тоесть баш через пайп связывает
fd/1 у левого процесса с fd/0 правого . левый и 
правый имеется ввиду порядок который они стоят 
слева и справа от палки '|')

   proc1 | proc2

баш получит два дескриптора от ядра через 
 fd1,fd2 = pipe()

и он клонирует fd1 в fd/1 процесса слева
и он клонирует fd2 в fd/2 процесса справа

