| STDIN
| STDOUT
| STDERR

в этих словах таится наебка

процесс (кусок кода)  может иметь "связь " в файлами во внеешнем мире.
для прцоесса эта связь выглядит так что в ядре для этого процесса есть таблица
с параметрами этого процесса. и там есть такая хрень как файл дескрптторы. 
для того чтбы процесс могут читать писать из файла в внешнем мире он должен попросить 
ядро "открыть" файл. после этого ядро выдает процессу номерок - файл дескпритор. это 
натуральное число 0,1,2,..21,100000 
далее используя это число прцоесс может просить ядро прочитать кусок из файла и просить 
ядро записать чтото в файл используя данные из области памяти прцоесса. итак дескпритор
это заменитель пути к файлу на диске  с точки зрения процесса. скажем номер  10
может за собой скрыать путь к файлу /tmp/1.txt
тоесть номер дескпритора это  заменитель имени файла . процесс показывает ядру этот номерок
и ядро понимает к какому файлу его просят обратиться

  fd1 = open("/tmp/1.txt")

 ядро говорит процессу fd1=10

 тогда

   read(10,21,....)

означает просьбу к ядру чтобы оно прочитало из файла /tmp/1.txt  21 байт.
ксатаи по кранкйей мере для файлов на диске ядро держит в совей памяти для каждого дескпритора 
такую хрень как курсор. дело в том что вопрос  с какой позиации внутри файла читаь 21 байт? 
с начала файла или сс ердины? за это ответчает курсор. его тоже можно двигать
позицию курсора можнов увидеть в папке fdinfo

殯  $ cat /proc/2128228/fdinfo/180
pos:	0
flags:	02500002
mnt_id:	30
ino:	405495695
lock:	1: POSIX  ADVISORY  WRITE 2128228 fe:00:405495695 1073741826 1073742335


в данном случае курсор равен 0.
курсор это смещение внутри файла от его начала

итак деспоиртор это всего навсего замасииованое имя для какогото файла на диске и нетолько
на диске. дескприор имеет вид натуралнгого числа. 

как у процесса может полявиться новый дескрипттор - для этого процесс должен попросить 
ядро открыть файл open() указав путь к нему на диске. и в ответ ядро выдает процссу новый дескпртор
от этого файла. еще можно пооткрывать файлы в одном процссе а потом клонировать этот процесс
и там заустить execve() и тогад получается что код бинарника который в exdcev() он сам 
ничего не октрывал. за него ктотот  открыл до этого !

далее  - если файл открыть. если у пцреосса есть деспоиктор то это освершено не значит что 
пцросс обязан чтот делать с файлом читать или писать. можно открыть файл и не делат с ним
НИХЕРНА!  открый файл ни к чем не обязывает! при откртиии файла через open() задатеся 
режи будуещей работы с файлом - чтение.,, запист или чтение + запись.   как можно узнать
в каком режиме открыть файл . а через proc папка fd

 Ị  $ ls -1al | head -n10

lr-x------ 1 noroot noroot  64 ноя 27 03:53 0 -> /dev/null
l-wx------ 1 noroot noroot  64 ноя 27 03:53 1 -> /dev/null
lrwx------ 1 noroot noroot  64 ноя 27 03:53 10 -> /memfd:mozreserved (deleted)
lrwx------ 1 noroot noroot  64 ноя 27 03:53 100 -> /home/noroot/.cache/mesa_shader_c...
lrwx------ 1 noroot noroot  64 ноя 27 03:53 101 -> /home/noroot/.cache/mesa_shader_c...
lrwx------ 1 noroot noroot  64 ноя 27 03:53 102 -> /home/noroot/.cache/mesa_shader_c...
lrwx------ 1 noroot noroot  64 ноя 27 03:53 103 -> /home/noroot/.cache/mesa_shader_c...

соотсвтвтенно видно что все файлы открыты в режиме rw

вот пример

 v   $ ./247.exe 
^C
 s ஑  $ cat 247.c
#include <stdio.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <fcntl.h> // for open
#include <unistd.h> // for close



void main (void) {


   int fd = open("/tmp/1.txt", O_RDONLY);
   sleep (120);

}


и вот видно 

 4 䊱  $ ls -1al  /proc/$(pidof 247.exe)/fd
lrwx------ 1 noroot noroot 64 ноя 27 20:05 0 -> /dev/pts/95
lrwx------ 1 noroot noroot 64 ноя 27 20:05 1 -> /dev/pts/95
l-wx------ 1 noroot noroot 64 ноя 27 20:05 10 -> 'pipe:[31414578]'
l-wx------ 1 noroot noroot 64 ноя 27 20:05 12 -> 'pipe:[31414579]'
lrwx------ 1 noroot noroot 64 ноя 27 20:05 2 -> /dev/pts/95
lr-x------ 1 noroot noroot 64 ноя 27 20:05 3 -> /tmp/1.txt


а именно

lr-x------ 1 noroot noroot 64 ноя 27 20:05 3 -> /tmp/1.txt

видно что права на файл r-x  
почему x я незнаю . но видно что есть r и нет w.
так что ядро сможет из файла только читать и не сможет писать


итак если есть процесс то мы можем вот так легко узнать к каким файлам
и какой доступ октрыт - толко чтение или запись или что




так вот обычно процесс имеет как минимум три дескпритоора  

	0
	1
	2

хотя может неиметь ни одного. но обычно имеет хотя бы эти три. так вот им дали буквнные названия

  0 = STDIN
  1 = STDOUT
  2 = STDERR

это чисто условные названия в голове людей. для процесса это по прежнему 0,1,2

так вот эти названия это охуенная наебка.
они какбы прразумевают что из файла 0 процесс будет толкьо читать. из файла 1 он будет
писать. и файл 2 он тоже будет писать о каких то проблемах. 
так вот на самом деле процесс вообще необязан ничего из этого делать!
во вторых процесс АБСОЛТНО СПОЙОНО МОЖЕТ И ЧИТАТЬ И ПИСАТЬ ВО ВСЕ ЭТИ ФАЙЛЫ И НАХУЙ ПОХУЙ
ЭТИ НАЗВАНИЯ. 

беру типичный процесс

 $ ls -1al /proc/$$/fd
lrwx------ 1 noroot noroot 64 ноя 27 20:10 0 -> /dev/pts/96
lrwx------ 1 noroot noroot 64 ноя 27 20:10 1 -> /dev/pts/96
lrwx------ 1 noroot noroot 64 ноя 27 20:10 2 -> /dev/pts/96


видно что для всех файлов 0,1,2 стоит rw
так что процесс чисто техгнически может ИЧИТАТЬ И ПИСАТЬ ПРИЧЕМ ВО ВСЕ ЭТИ ФАЙЛЫ!

так что эти названия это только рекомандяния для процесса! а будет ли он ей следовать 
это реешение самого процеса!!!



а вот программа которая доказывает что мы можем легко ПИСАТЬ в любой 0,1,2 
повторю в любой!

 %   $ cat 246.c
#include <stdio.h>

void main (void) {


    dprintf (0, "vasya\n");
    dprintf (1, "vasya\n");
    dprintf (2, "vasya\n");


}




  $ strace -e write ./246.exe
write(0, "vasya\n", 6vasya
)                  = 6
write(1, "vasya\n", 6vasya
)                  = 6
write(2, "vasya\n", 6vasya
)                  = 6
+++ exited with 6 +++


