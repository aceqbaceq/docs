| utf-8
| utf-16
| utf-32


пиздец состоит в том что с точки зрения регистров
цпу  хрень

 1111 1111

это не две отдеьные хрени 1111 и 1111 собранные
в одну кучку. нет.  хрень 1111 1111 это свореешнно
отдльная сущность.

вспминаем что биты это коэфииценты разложения числа
по стеменям двойки.  поэтому если у нас есть хрень 

 1111 1111

она виуаьно напрмианает шкаф в котором два
ящика однаковые по высоте (4 бита) но вес барахла
в этих ящиках чудовщино не сопоставим. левый ящик
высотой 4 бита имеет вес 240кг в то время как
правый ящик при высоте теже 4 бита имеет вес всего 15кг.


а память у нас это такой массив который в себе 
содержит кучу элементов по одному байту.
поэтому когда мы хотим в памяти сохранить хрень
длиной 16 бит

 1010 1011  1101 1011


то мы как бы не сохраняем саму хрень. а мы делаем
маппинг исходной хрени на две икуствнные хрени.
на две микрохрени по 1 байту длиной. 
тоесть условно говоря вот мы имеем исходное
число 

 1010 1011  1101 1011 = 43995

а мы его в памяти сохраняем в кодированном виде
в виде двух чисел 1010 1011=171   1101 1011=219
тоесть мы исхоное число 43995 сохраняем в памяти
не вв виде 43995 а в виде хрени двух чисел 171 и 219
поэтому тут вылезает ендинесс чтобы потом когда 
мы считваем 171 и 219 чтобы нам понимать это 
    171*(256)+219
или это 
    219*(256)+171


исходя из этого если у нас в памяти скажем сидит
два байта

  аддр1 аддр2
  219   171

и мы их рассматриваем как два отедных байта 
сидящих рядышком то это одно дело. 
а если мы их рассматриваем как закодированное двух
байтовое выражение то тут уже важно какой ендинесс
имеет этот сторадж.
потому что если это лоу ендинесс сторадж то 
у нас хранится число

  171*256+219

а если это биг ендинес сторадж то эти же байты хранят
число

  219*256+171

а все потому что память неможет хранить биты лююыми
кусками. по 8 бит по 16 бит по 32бита. она может
хранить только по 8 бит поэтому нас многобитвые
числа приходится совать в память не в прямом виде
а в "закодиорванном" апотом восстаналивать. 

отсюда вытекает важная хрень. если у нас есть 
кучка байтов на сторадже скажем в памяти

  11 22 33 44 55 66

то нам помимо этого надо еще знать это отдельные
байты или это единая хрень или это частиыне хрени
тоесть

  (11) (22) (33) (44) (55) (66)

или

    (11 22 33 44 55 66)

или

  (11 22) (33 44 55 66)

или

  (11 22) (33 44) (55 66)


кога мы знаем что это отдеьные байты то нас
ендинесс стораджа неволнует.
а если это нетак то нас сразу это волнует.
потому что чтобы восстановить многбайтовую хрень
нам это надо знать. тоесть. пусть у нас сторадж
лоу ендинесс тогда


  (11) (22) (33) (44) (55) (66)  = тоже самое

  (11 22 33 44 55 66) = 0х665544332211


  (11 22) (33 44 55 66) = 0х2211 и 0х66554433


  (11 22) (33 44) (55 66) = 0х2211 и 0х4433 и 0х6655



а если сторадж биг ендиан то все по другому.
тоесть память формаьно выглдяит как сторадж
однобайтовых элементов. физически так и есть.
но по факту там "запрятаны" многобайтовые хрени.
прада снаружи это никак не определить. тоест
нужно знать что начная с такогото адреса внутри
памяти "запрятан" 4-ехбайтовая хрень. 


  33 44 55 66

тогда эти отденые байты прячут в себе 0x66554433
(лоу енинесс сторадж)

тоесть фрмально вся память выгдяит как бутто
она хранит вот такое

  (11) (22) (33) (44) (55) (66)

 тоеть только байтики

а по с точки зрения программы она может 
прятать в себе вот такое

 (11 22) (33 44 55 66)

тоесть 

 0x2211  0x66554433


тоесть если у нас есть кучка байтов в памяти
или на бумаге. нужно обяательно еще узнавать
это массив из отдеьных байтов незавиимых или 
это многабтовая хрень спрятаная внутри этих байтов.


это очень важно и оно влезает например в unicode.

вот у нас есть код поинт U+0443 это 'у'
так вот она кодируется в UTF-8 вот так

      UTF-8    0xD1 0x83

здесь важно то что она кодируется массивом из 
двух отедьных байтов. тоесть это не единое двухбайто
вая хрень а это два отдеьных байта. так как это 
массив то у каждого элемента есть индекс. как
я понимаю то тут оно вот так 
   
   0xD1(индекс0) 0x83(индекс1)

тоесть вот так

  {  0xD1 , 0x83  }

так вот когда мы копируем этот масив на сторадж
у который кактой ендианесс то в обои случаях 
у нас в памяти эти эленты будут сидеть одинакого
в обоих случаях

  аддр1   аддр2
  0xD1    0x83  


тоесть так как это отденые байты то цпу их копирует
на стораж ровно  в таком порядке как у них идет
индексы в массиве. и ендианнесс тут не играет 
никакой роли. 

тоесть если мы хотим закодирвать символ у в ютф-8
на каком то сторадже то нам плеват на его ендинесс
нам нужно лишь обпеспечить то чтобы на этом сторадже
D1 сидел на этом сторадже в офсете левее чем 
83

получается в ектсте прогамы мы напишем

  char a [] = { 0xD1, 0x83}

это обьсинит комплиятору что у нас массив из 
двух отдельых байтов. и что у D1 инекс  0 
а у 83 индекс 1 поэтмоу в памяти они будут лежать
как 


  addr1   addr2
  D1      83



тот же самый символ у но в ютф-16
имеет вот такое хекс предствавление 

    UTF-16 0x0443


что здесь сущерсвтенно то что у нас тут два байта
но они не массив а это единая многобайтвая хрень.
где 04 это старщий байт а 43 это младщий байт (сог
ласно правилу как мы запиываем на бумаге).

тогда в память это дело нужно совать вот так

  char a [] = { 0x43, 0x04 }

либо за нас эт сделает комплиятор если мы
сдлелаем вот так


   short int i = 0х0443;


если бы у нас память был биг ендиан то 
тогда в нее по байтово это ужно было бы вставлять
вот так

  char a [] = { 0x04, 0x43 }


тоесть что важно заметить.
когда у мен символ кодирется массивов из отделных
байтов. то я эти байты сую на сторадж всегда 
в одном виде в независимости какой ендинесс
у страджа

  char a [] = { 0xD1, 0x83}

а если у мен сивол кодирвется многобайтовым 
выржением то совать его на сторадж в виде отденых
байтов нужно  взависимости от типа ендинесс этого
стораджа

  char a [] = { 0x43, 0x04 }  LE
  char a [] = { 0x04, 0x43 }  BE


этотже символ у кодиртс в ютф-32 как 
мнгггоайтовая хрень

   UTF-32    0x00000443

тогда если я хочу это зансуть коректно в память
побайтово то нужно вот так

  char a [] = { 0x43, 0x04, 0x00, 0x00 }  LE


если бы ютф-32 это кодиврание было бы как массив
из четрых однобайтовых хрееней   0x00 0х00 0х04 0х43
то тогда на ендинесс нам было бы все равно и 
всегда бы на стораж мы бы это пихали как


  char a [] = { 0x00 0х00 0х04 0х43 }  LE\BE


когамы в тексте програмы на си указваем мнгобайтовую
хрень то комплиятор знает что паять у нас LE поэтому
он автоматом создает нужную байтовую последваттеность
в памяти тоесть

    long int i2 = 0x11223344556677;

в итоге в памяти байты будут сидеть вот так

   77 66 55 44 33 22 11 

когда мы берем блок байтов в памяти и копируем
их в память или на сторадж или в файл то ОС
воспринимает этот блое байтов как массив отделных 
байтов. поэтому ОС копирует эти байты так чтобы 
у них был такойже оффсет как он был у этого байта
на исходном сторадже. при этом ендинесс целевого
стораджа не играет никкой роли. 


отсюда вытеакают такие моменты напрмиер вот 
у нас написано что utf-8  для 'у' это 0xD1 0x83
как это правло засунуть в память. это у нас масив
из байтов. значит просто в том же порядке что 
и офсет\индекс этого байта на бумаге. тоесть 
на бумге мы имеем  0xD1(инекс0) 0x83(индекс1)
значит  в память суем просто схраняя его индексый
порядок и плевать на ендиенсс

 char a []= { 0xD1, 0x83 }

а если бы он кодировая многбайтовым херью 0xD183
то в память нужно было бы совать вот так

 char a []= { 0x83, 0xD1 }


итак память это устройство которое предназначено
для хранения байтов. а для хранения массива битов
который больше чем байт память не предназначена. 
для этого типа надо извращаться. если у нас
есть массив состоящий из байтов то неважно какой
сторадж этот массив будет сохранен в память в таком
же порядке с таким же оффсетом как и индексы в массиве
тоесть если есть массив байтов

 байт1(индекс0) байт2(1) байт3(2)... байтН(Н)


то в память его цпу запишет в таком же порядке
начиная с того адреса с которого мы укажем

 адрес0  адрес1    адрес2      адресН
 байт1   байт2(1)  байт3(2)... байтН(Н)


ендинесс при этом памяти неважен. если цпу дать
массив состоящий из обычных байтов то у него нет
прблем КАК его сохранить в памяти. он начнет сохра
нять этот массив в память ровно в том порядке 
в котором байты лежат в исходном массиве. 

загвоздка взниуает у цпу как сохранить в памяти 
массив битов когда их число больше чем 8. например 
массив бит 16 штук. тоест массив по размеру
равный двум байтам. ну казалось бы хуйле тут думать.
берешь младшие 8 бит(младщий байт) и пихаешь в
память. потом берешь старшие 8 бит (старший байт)
и пихаешь в память. но почемуто нихуя. одни цпу
делают именно так. а вторые цпу делаю наоборот. 
они первым в память суют старший байт а следующим
суют в память младший байт. 
оно ведь откуда все получается. вот  унас в цпу
есть регистр. он размером 8 байт, или 16 или 32
или 64 бита. и вот мы даем команду сунуть этот
регистр в память. или наоборот мы даем адрес из
памяти. и говорим запиши из памяти в регистр.
если регистр 8 бит то прблем нет. из адреса
памяти прилетет 8бит (байт) и он в точности
соовествет регистру 1 байт. 
аесли у нас регистр 8 байт. то логично что из памяти
нужно прочитать 8 байт. но вопрос  в каком порядке
эти 8 байт нужно всталвят внутрь этого регистра?
по мне было бы логично так - первый байт в младшую
часть регистра, второй байт в более старшую часть
ргистра... самый последний 8 байт в самую сташую
часть регистра. но покмуто для каких то цпу это
так а какието почемуто наоборот. младщий байт
суют в самую старшую часть регистра.... а самый 
страший байт в самую младшую часть регистра. 
по мему это доблбоебизм. суть в том что когда регистр
размером 1 байт никких ендинесс не вылезает.
оно вылезает когда регистр размером 2 байта \ 4 байта
... 8 байт. возникает вопрос в каком порядке
нужно набить этот регистр байтами из памяти в каком
порядке. и наобророт в каком порядке нужно порезать
региста и набить им память. тут вылезает 
ендинесс. итак еще раз если мы копируем из 
памяти в регистр или из регистра в память и при 
этом размер регистра равен 1 байт. то никаких
ендинесс не вылезает. их нет. если нужно считать
1 байт из памяти в цпу или нужно записать из цпу
в память 1 байт то никаких проблем. никаких ендинесс
нет.

ендинесс возникает когда нужно скажем из 
цпу из регистра размером 4 байта записать 
контент этого регистра в память. вот и возникает
вопрос как нужно порезать контент регистра на куски
и в каком пордке эти куски нужно засунуть в память.
тоесть вот у меня регистр размером 4 байта
и я говорю считай 4 байта из памяти в этот регистр
начиная с адреса1. и вот вопрос - в каком порядке
нужно в этот регистр засунуть эти 4 байта. толи
в прямом порядке толи вобратном толи в каком. 
вот где вылезает ендинесс.

ксати походу ендинесс зависит от цпу а не от стора
джа. тоесть стоадж это просто склад с ячейками
ну они еще имеют номера но это никак не влияетна
ендеинесс. что туда и вкаком порядке класть решает
цпу. он опреляет ендинесс! это типа как человек
берет бумагу. и он на ней пишет буквытак как хочет
хочет спрвав налево хочет слева направо. итд.
ендинесс зависит от цпу. 

так ну насчет обмена

   цпу - память
   памят - цпу

стало понятно. где и как ту ендинесс


а что если мы копируем из куска памяти в файл или 
другой кусок памяти. 
насклоко я понимаю 
цпу делает так. он копирует из памяти в регистр
а потом
из регистра в другую память\файл\сторадж\железка. 
рассмотрим вначале копирование

   память - регистр - память


если у нас есть исходный много байтовый хрень
то в память она пишется как LE
а внутрь регистра многобайтового оно пишется как BE
тоест у регистра обычно есть страший байт младший 
байт. и в страший байт запишется имено старшая часть
исходного хрена а в младщий байт запишется младшая
часть исходного хрена. 

     LE        BE       LE
   память - регистр - память


в целом на саомом деле какой ендинесс  у регистра
нам неважно потмоу что в итоге запись идет в ту
же память  поэтмоу в итоге тот порядок байтов
который был  в исходном куске памяти такой же
порядок будет и в дестинейшен куске памяти
если регистра рамером 1 байт то у него никакого
ендинесс нету.
в итоге какой бы по размеру регистр ни был
ккой бы у него ендинес ни был если мы копируем
из памяти в память то это никак не полвяет на 
порядок байтов в куске памяти который сорс
на кусок памяти который дест. никакого нарушениея
порядка байтов не будет. 
в итоге скжаем у нас есть  адрес 6 
и за ним сидит 4 байта

  6   7   8   9   10 
  11  12  13  14  15

и мы копируем через регстра длиной 4 байта
по адресу 16. то мы получим такой же порядок 
байтов

 16  17  18  19  20 
 11  12  13  14  15


тоест если мы взяли какойто кусок исходной
памяти. скопироали его в регистр. а потом из 
региста записали это обратно  в память. то 
порядок байтов внутри исходного куска памяти
и порядок байтов внутри дестинейшен куска
памяти будет один и тотже.
тоесть вот мы взяли с помощью четерехбайтного
регстра скопировали 4 байта из одной области
памяти в двную област. при этом порядок байтов
в обоих кусказ остаенется темже. внезависимости
от размера регистра и его ендинесс.

поэтмоу если нам надо скоирирвать скажем 100МБ
байтов из области А в область Б мы можем сопокйоно
это делать через регистра смого большого размера
скажем 8 байт. при этом у нас порядок байтов
будет сохранен не смотря на все ендинессы.

есть еще какой момент. мы как засоываем байты 
в память. мы пишем пограмму в  текстовом виде на 
си. условного говоря мы пишеим прогармму на бумажке.
потом эту бмумажку читает компилтор и на освное нее
он заполняет цпу. а тот заполянет память. 
так вот человек (как цпу) он исползует бумажку(сторадж) для записи многобайтовой хрени в режиме 
БИГ ЕНДИАН. тоесть у нас положение слева на 
бумажке  - соотвесвтутет меньшему оффсету. а положение
справа на бумажке сответувует большему оффсету.
так вот когда мы пише на бумажке хекс то мы его
старший байт суем в меньший офсет а младий байт
суем в старший офсет. поэтмоу хекс на бумажке
запмывается в порядке БИГ ЕНДИАН

   0x5612

в этмо прмиере 56 это старший байт а 12 младший.
так вот мы эту бумажку этот сторадж даем компиялтору
он знает что этот сторадж хранит многбайтоввую хрень
в формате биг ендиан. поэтому он читает бумажку
видит 5612 и понимает что 56 это старший байт а
12 это младщий и тогда он сует команду на цпу
которая в итоге сует в память 12 в первый офсет
а 56 во второй. потому что цпу у нас сует в память
байты многбайтовой хрени в ЛОУ ЕНДИАН порядке.

поэтому многбайтовы хренив тексте программы будут
запмасны в память в обратном относиельно бумажки
порядке. 

а вот если мы на бумажке напишем массив. то 
массивы мы запиываем на бумажке в порядке лоу
ендиан 
   { 0x12, 0x13 , 0x14 }

поэтмуо копилятор засунет в память эти байты в точно
таком же прядлке

  0х12 0х13 0х14


собсвтенно а почему точно втаком же поряоке? ведь
у нас каждй жлемент это отдеьный байт поэтому их
в приницпе можно хранить в памяти как угодно. 
хоть от меньшего индекса к болшему хоть от 
большего к меншему. в принцие это уже с ендианесс
не свзяано. просто так сделали что в меншем офссете
в памяти хранят эемент с намиеньшим индексом а 
в большем офесте памяти хранят с набольщим имндексом.
вобем витоге так или иначе тот порядок байтов
который мы видим в масисве на бумажке будет
такойж порядок в памяти. 

если  у нас массив из элементов лина которого
ольше чем 1 байт напримре 


   { 0x1234, 0x5678 , 0x89А0 }

то сами эдменты в памяти будут лежат в томже 
поряке что написано на бумжаке. но в рамках
кажого элемента порядок будет наборот

   34 12  78 56   А0 89



так вот я возвораащаюсб к  тому что 
символ в ютф-8  кодируется массивом из однобатовых
элементов. которые может быть от одного до четрыех.

например "у" =  0хD0  0xAE 
еще раз символ у кодируется массивом из двух
однобайтоых элементов. нам нужно полуечается 
в память записать два байта. где D0  это элемент
у кторого игдекс меньше а AE у него ингдекс больше. 

можем это сделать на бумажке прям буквально

  { 0xD0, 0xAE }

мы редпиывем коплиятору чтобы он создал массив
где D0 имеет инккс меньше а AE инек бльше. 

а можно для этого на бумажке использовать манобайттвное  выржание 

   0xAED0

мы пользуемся тем что комплятор знает что на бумжаке
мы заыываем могобайтовое ыржание всегда в БИГ НЕДИНАН
порядке. так что он поймет что D0 младщий байт
и аAE старший. и он также запишет это число
в памяти в порядке

 D0 AE

то что нам надо.


но! представим что унас програма набумажке будет
апустькаться на разных цпу. и хер знает какая у них
там нединесс при работе с памятью поэтмому 
надежне на бумжаке указать просто массив


  { 0xD0, 0xAE }

потому что в этом случае неавжно какой у нас цпу
и как он рбоает с памятью в плане ендиенесс. потому
что при любом раскладе этот массив будет записан
в память точно вот в таком виде

 адрес1  adres2
 D0      AE

потмоу что так сохрнятся массивы в памяти. 
элемент который на бумажке имеет индекс меьше
будет лежать впамяти по адресу менше. так как кажый
эемегт равен 1 байт то при сохарнеии этого элмента
ниакой эндинесс проявлясят не будет. 

тоесть наша задача написать на бумжке так текс
прогармы чтобы на любом цпу с любой ендинесс 
у нас байты в массиве имели точно такие же индексы
как на бумажке.
и вот эта форма программы


char *p[] =   { 0xD0, 0xAE }


тоесть когда говорят про ютф-8 кодировку то 
ненужно говорить про ендинесс при этом. 
потому что у нас это массив из отдельных байтов. 
при сохрарнеии в памяти отдельных байтов никакой
ендинесс не проявяется. ендинесс проярется если
у нас есть обьект который по размеру боьше чем
1 байт. а у нас тут такого нет. у нас каждый обьект
размером 1 байт. у нас просто таких обьектов несколко.
комплятор запишет элементы этого массива так что 
если p это поинтер на начало массива то эленты
будет так сохаренны что
*p[0]= D0
*p[1]= AE

тоесть их индексы будут сохраены

тоетсть полуается то что если на бумажке у нас
байты выгялдят как

 D0 AE 

то и такойже порядок будет с ними в памяти

адр1  адр2
 D0   AE 

поэтому вобщем кодга пишут в юникод таблицах
что скаем сивол "у" в ютф-8 это   0x0D 0xAE
то несморя на то что тут у наснесколько байтов
ни о какой ендинесс при этом не упоминают. почему.
потому что неважно что у нескгко байтов. важно
то что среди них нет ни одной хрени длиной больше
чем 1 байт. поэтому об эндинесс речи вобще не идет.


а вот когда пишут что "у" в ютф-16 это 0x0443
то тут уже мы можем говоить про ендинесс. правда
она тут вылезает автоматом. так как на бумажке
многбатоый хекмы мы пишем на оснвое БИГ ЕНДИАН.
тоесть 04 старший а 43 младший байт. 

тогда в текст програмы более универсально будет
записать эту хрент не в виде массива а именно
в виде

  short int i1 = 0х0443

компилятор знает что на бумажке у нас биг ендиан
он знает что 04 старший а 43 малдший. и далее
уже исходя из типа цпу он сам правилно так 
создаст команы которые заснут эти байты в память
исходя из ендинесс цпу. тоесть если цпу у нас
литл ендиан то он засунет в памть вот так

  43 04

а если цпу имеет биг енинас в памяти то вот так

  04 43

соовтсвтенно мы на бумажке дали одну форму а он уже 
как надо это првреащает в отдельные байты в памяти.

правда вот где засада может быть. положим что 
у нас на комп поступил файл. и в этом файле у нас
идут байты ютф-16. и получется что эти байты 
будут итти в том порядке в каком порядке была
енднесс память на цпу который этот файл создал.
и получатеся при чтении эти байты попадут в память.
напрмиер вот у нас вот так в файле


  04 43

мы это побайтово прочитали в памятьь получили

  04 43

так как у нас скажем цпу имеет лоу енинесс то он 
читает два байта в регистр и получает

  4304
  ^
старший 
байт

а на исходном компе которй имет биг ендинесс
эта же оперци привела бы  к 

  0443
  ^
старший 
байт

поэтому по идее в файле нужен признак который
обьяснял на какой системе была записан этот ютф-16
байт код. 

на этот случай в файл вначале располазается маркер
BOM котоый обьясняет какой ендинесс был на исходной
компьбере.


на счет ютф-8
положим у нас есть файл 

11 22 33 44 55 66 

положим что это файл ютф-8 кодировка.
он читает этот файл в память
неважно какой ендинесс на компе есть
байты все равно будут в памяти так же сидеть

11 22 33 44 55 66 

далее мы читаем эти байты из памяти
и суем их в драйвер ттай. в его буфер

11 22 33 44 55 66

буфер тоже в памяти так что там они выглядят также

а далее он получается дарвер читает из этого
куска памяти по 1 байту и сует в терминал.
так что ютф-8 файл он отлично распознается на
компе с любым ендинесс

ютф-32 файл тоже полчается доолжен иметь BOM(BYTE ORDER MARKER). а елси его нет то подразуметяся что 
файл был созан на компе с LE.

вобещм вот такая мудоат с юникод и ендинесс.

 