| serial
| com
| console

есть такой элементарный вопрос как посмотреть список COM 
портов котоыре есть у компьютера когда на него установлен LINUX

как ни странно хуй найдешь ответ

а ответ вроде бы вот такой

# cat /proc/tty/driver/serial
serinfo:1.0 driver revision:
0: uart:16550A port:000003F8 irq:4 tx:19199 rx:23 RTS|CTS|DTR|DSR|CD
1: uart:unknown port:000002F8 irq:3
2: uart:unknown port:000003E8 irq:4
3: uart:unknown port:000002E8 irq:3


как я понимаю мы ищем строку в которой есть 16550A 
в нашем случае это строка "0:" значит на этом компе есть COM порт
который сидит на ttyS0 тоесть /dev/ttyS0  на него ведет

итак мы узнали что на нашем компе есть один serial порт и что чтобы 
до него достучаться надо обращаться на /dev/ttyS0

положим что я сижу внутри линукса. и я хочу изнутри линукса обратиться подклчитбся
постучаться на этот serial порт. понятно что если так сделать то я посту
чусь на драйвер ядра который эту железку обслуживает. так как это сделать?

# apt install  picocom
# picocom -b 9600 /dev/ttyS0




<=== тут надо расказать про console  по то как это происыватеся в grub
про то что процессы сидят и слушаю тоже tty порты поэтому вы будутее друг рдугу
мешать
про то что если какойто процесс открыл tty файл то это будет в его /proc/pid/fd
а значит можно найти через lsof


<==== надо расказать про то что что есть pci железки. к ним обращаются 
как то там хуй знает как. а есть ISA bus или еще есть LPC bus
и к ним тоже железки втыкаются. так вот я тут неочень ловлю все компоненты
этой цепочки но - дело вот в чем. у компа есть оперативная память RAM.
в нее он может писать\читать через асемблер команды mov ...
а на уровне железа это происходит так что есть шина (как она называется не знаю
типа некая ГЛАВНАЯ шина). она состоит из трех частей - я назовуих как
субшина адреса, субшина данных, субшина упрваляющих сигналов.
как цпу получает байт из RAM? 
он на субшине адреса выставляет адрес. потом на субшине сигналов выставляет
сигнал READ. и тогда RAM чипы обратнов цпу по субщине данных присылают байт.
все классно. но помимо железки под названием RAM у компа еще есть куча 
железок (клава, таймер, видеокарта итд). от них тоже нужно както байты доставлять
до компа. насклько я понимаю щас ситуция такая что у цпу есть отдельная шина
ведущая только в память. причем контроллер памяти вщит в сам цпу.
а шина ведущая к перифериы устройствам заходит в цпу по отдельным ножкам в него.
так вот перифериной устройство скажем клава или порт в который она втыкается
и контроллер клавы который есть на мат плате он с точки зрения цпу имеет 
несколько регистров в котлрые можно читать писать и буфер насколько то байт. 
так вот цпу надо как то иметь связь с этими регистрами и буфером. и вот 
я подхожу к главному моменту как это делается. есть ДВА способа. ИЛИ по крайней
мере было два. будем считать что есть два способа.
один способ называется I\O Memory Mapping. 
и состоит он в том что неким макаром железка регистрируется в системе
(где именно  я незнаю) и дальше происходит вот что. если мы на цпу
запускаем команду чтения\записи из RAM и делаем как все при этом 
полагается. используем команду mov ... 
цпу выствляет на субшине адрес RAM и выставляет на субщине сигналов команду READ 
то дальше происходит магия. этот запрос перехватывает IOMMU контроллер на мат
плате и если он видит что адрес RAM попадает в некий диапазон то он этот запрос
перенаправляет на железку! и получается с точки зрения асембера и цпу мы 
лезем в памятть а на самом деле мы попадаем на железку!
посмотреть какие адреса RAM на какую железку ведут в линуксе можно вот так
запускать эту команду нужно тлоько от root 
иначе она везде нули нарисует

	# cat /proc/iomem
feffc000-feffffff : Reserved
800000000-fffffffff : PCI Bus 0000:00
  800000000-8000fffff : PCI Bus 0000:01
    800000000-800003fff : 0000:01:00.5
      800000000-800003fff : virtio-pci-modern
    800004000-800007fff : 0000:01:00.4
      800004000-800007fff : virtio-pci-modern
  a1300000-a13fffff : PCI Bus 0000:04
    a1300000-a1303fff : 0000:04:00.0
      a1300000-a1303fff : nvme
  a1400000-a14fffff : PCI Bus 0000:03
    a1400000-a1403fff : 0000:03:00.0
    a1404000-a1404fff : 0000:03:00.0
      a1404000-a1404fff : r8169
  a1500000-a150ffff : 0000:00:14.0
    a1500000-a150ffff : xhci-hcd
  a1510000-a1517fff : 0000:00:04.0
    a1510000-a1517fff : proc_thermal
  a1518000-a151bfff : 0000:00:1f.3
    a1518000-a151bfff : ICH HD audio


тоесть этот способ он приносит данные в цпу на конечной стадии 
через шину по которой из RAM байты прилетают.

НО есть и второй способ как цпу может связаться с железкой.
для этого у цпу есть отдельные ножки которы ведут на отдельную шину.
I\O шину. получается у цпу помимо RAM адресной шины есть еще другая шина
I\O шина. и на ней тоже есть субшина адреса. (как пишут в книжках у цпу есть
второе адресное пространство).
и если на цпу использвать команды 
	IN ...
	OUT ...
то цпу понимает что мы хотим данные получить не на RAM шине 
а на I\O шине.
адрес на I\O шине называется (по идиотски) ПОРТ
суки не могли поболее понтному назвать.

как я понял железка которая подключается к I\O щине она както анонсирует
какой порт она хочет занять. таким образом если на cpu мы напишем
	IN port1
то I\O шина нас доставит к регистру или ячейке памяти на этой железке.
так как у железки обычно несколько регистром и буфер памяти такойто длинной
то железка анаонсирует на этой шине ДИАПАЗОН ПОРТОВ. так вот посмотреть
эти диапазоны можно воттак

# cat /proc/ioports 
0000-0cf7 : PCI Bus 0000:00
  0000-001f : dma1
  0020-0021 : pic1
  0040-0043 : timer0
  0050-0053 : timer1
  0060-0060 : keyboard
  0064-0064 : keyboard
  0080-008f : dma page reg
  00a0-00a1 : pic2
  00c0-00df : dma2
  00f0-00ff : fpu
  03f8-03ff : serial   <===== COM порт


в праовм столбике покзаана желзка. а в левом какой диапаззон адресов на I\O
шине она себе забрала. я только непонял что тут делает PCI. ну хер сним

# echo "obase=10; ibase=16; 03F8" | bc 
1016
root@cont0:/proc/tty# echo "obase=10; ibase=16; 03FF" | bc 
1023

значит адреса 1016-1023 это 8 адресов.
насколько  я понял ширина шины I\O это 8 бит. тоесть 1 байт.
значит COM порт занимает 8 байт. 


получается для сравнения клавиатура занимат 2 байта
  0060-0060 : keyboard
  0064-0064 : keyboard


тееперь собираем вместе две команды
# cat /proc/tty/driver/serial | grep 16550
0: uart:16550A port:000003F8 irq:4 tx:19199 rx:23 RTS|CTS|DTR|DSR|CD

# cat /proc/ioports  | grep serial
  03f8-03ff : serial  

и мы в итоге видим что в обоих командах фиурирует 3F8 значит 
речь идет об одной и тоже железке.

значит COM порт с точки зрения его /dev файла это /dev/ttyS0
и когда мы к нему обращаемся то драйвер этой железки в ядре будет
на цпу выставлять команды
	IN 0x3F8
	OUT 0x3F
чтобы достучаться до этой железки и использовать указанные порты чтобы адресовать
эту железку на шине I\O
во как!
мне как пользователю внутри линукса для связ с железкой порты знать получается
нет никакой нужды. мне главное знать /dev/ttyS0 имя!

так вот я на своем ноутбуке нашел вот такой COM порт
# cat /proc/tty/driver/serial  | grep 16550
4: uart:16550A mmio:0x8B801000 irq:20 tx:155 rx:1 brk:1 RTS|CTS|DTR

заметим что у него написано mmio:0x8B801000 это поидее значит
что достукиваться до него драйверу нужно не чрез I\O шину а через 
i\O memory maping о котором  я говорил вначале. 
провреим что про этот адрес есть в iommu

# cat /proc/iomem | grep -i 8B801000
  8b801000-8b801fff : 0000:00:1e.0
    8b801000-8b8011ff : lpss_dev
      8b801000-8b80101f : serial

из того что я нашел про lpss =  Intel® LPSS Inter-Integrated Circuit (I2C) Controllers

тоесть возможно 
	8b801000-8b8011ff lpss_dev 
это i2c шина
а на ней сидит некий com порт
     8b801000-8b80101f : serial

так вот согласно тому что выше его /dev/ это /dev/ttyS4

я к этому порту упешно конекчусь

# picocom  -b 9600  /dev/ttyS4
picocom v2.2

port is        : /dev/ttyS4
flowcontrol    : none
baudrate is    : 9600
parity is      : none
databits are   : 8
stopbits are   : 1
escape is      : C-a
local echo is  : no
noinit is      : no
noreset is     : no
nolock is      : no
send_cmd is    : sz -vv
receive_cmd is : rz -vv -E
imap is        : 
omap is        : 
emap is        : crcrlf,delbs,

Type [C-a] [C-h] to see available commands

Terminal ready


но дальше нихрена ничего непонятно что делать


дело все в том что если пытаться через picocom конектися к порту /dev/ttySN
за которым ничего нет то picocom пошлет тебя нахрен

значит я теперь расматривают lxd виртуалку. 
внутри нее есть COM порт /dev/ttyS0
# cat /proc/tty/driver/serial 
serinfo:1.0 driver revision:
0: uart:16550A port:000003F8 irq:4 tx:19522 rx:66 RTS|CTS|DTR|DSR|CD

более того в grub вот такое прописано
t# cat /boot/grub/grub.cfg | grep console | grep vmlinuz
	  linux	/boot/vmlinuz-5.15.0-1031-kvm root=PARTUUID=d72808d5-8a48-4c9c-85ce-ff3988b06ba4 ro  console=tty1 console=ttyS0

а что значит этот параметр ?
	console=ttyS0
который передается ядру при старте
а точнее параметры
	console=tty1 console=ttyS0
для этого я читаю вот это 
https://www.kernel.org/doc/Documentation/admin-guide/serial-console.rst
А ТАМ НАПИСАНО что этот параметр "console=" он сообщает ядру куда
при загрузке ему посылать сообщения статуса загрузки !
написано что если у нас указано несколько устройств то при загрузке
в оба устройства будет посылаться статус загрузки. но когда система
загрузиться то (как я понял) устройство /dev/console будет присобачено
к последнему устройству в списке то есть  в нашем случае к /dev/ttyS0

а что за хрень /dev/console?
я щас буду об этом читать. но из практики я вот что вижу 
на этой вирт машине - что порт ttyS0 его имеет открытым программа agetty

# lsof | grep ttyS0
agetty    2562   /dev/ttyS0
agetty    2562   /dev/ttyS0
agetty    2562   /dev/ttyS0

и действиельно 
# ls -1al /proc/2562/fd
lrwx------ 1 root root 64 May 13 11:46 0 -> /dev/ttyS0
lrwx------ 1 root root 64 May 13 11:46 1 -> /dev/ttyS0
lrwx------ 1 root root 64 May 13 11:46 2 -> /dev/ttyS0


значит 
$ lxc console cont0
To detach from the console, press: <ctrl>+a q


<=== как посмотеть список buS? как посмтреть железки пдкючнные к ISA или LBC bus?