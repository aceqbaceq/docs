linux
общее

--
ubuntu 20 
сука в два раза жирнее по диску чем ubuntu16
гораздо мнеее отзывчивый тяжелый

стал как и весь другой софт сразу занчительно неповоротливый тяжелый.
нахуй он такой нужен
тяжело натужно грузится
миллион служб. все как с другим софтом чем дальше тем хуевей
убунту 16 просто ракета по сравению

что нужно допилить напильиником в ubuntu 20:

	иодитский netplan 
	как его удалить - https://disnetern.ru/disable-netplan-ubuntu/
	причем netplan я удалидл. ifupdown пакет поставил но при этом
	настройки про dns из /etc/networkj/interfaces нихера не подсатыватся.
	в итоге нужно еще поставить # apt install resolvconf
	тогда настройки dns надо прорисывать в /etc/resolv.conf про dns
	как и когда то одавно!
		# cat resolv.conf
		nameserver 172.16.101.2
		nameserver 172.16.101.7
		domain mk.local
		search mk.local

	нужно пояс часовой сделать москва
	 sudo timedatectl set-timezone Europe/Moscow

	удалит floppy из системы.
	$ sudo rmmod floppy
				$ echo "blacklist floppy" | sudo tee /etc/modprobe.d/blacklist-floppy.conf
				$ sudo dpkg-reconfigure initramfs-tools
				
	
--


делаем чтобы можно было к нектиться к ФС

ceph auth get-or-create client.cephfs mon 'allow r' osd 'allow rwx pool=cephfs_metadata,allow rwx pool=cephfs_data' -o /etc/ceph/client.cephfs.keyring

ceph-authtool -p -n client.cephfs /etc/ceph/client.cephfs.keyring > /etc/ceph/client.cephfs

--

iperf

задача сделать тест скорости сети 
из между офисами.

далем на основе iperf

ставим на обоих компах iperf3
нужен именно он

# sudo apt-get install iperf3

стандартный iprf работает так, один конец запускаем в
виде сервера

(a)# iperf -p 49001 -s

-p 490001 = это порт на который сервер принимает запросы.
надо на файрволле открыть этот порт для входящих

второй конец работает клиентом

(b)# iperf -c 123.12.12.12 -p 49001 -R -i 5

-c 123.12.12.12 = адрес сервера
-i 5 = через сколько секунд выводить статистику на экран

еще можно указать ключ -t 10 = это значит что тест будет идти 10 секунд
если -t вобще неуказывать то тест будет идти бесконечно что удобно

самый главный ключ это -R и он есть только в iperf3
он дает то что клиент будет скачивать данные с сервера.
потому что по дефолту клиент подклчается к серверу и начинает UPLOAD 
данных на сервер. 
поэтому если мы хотим чтобы клиент DOWNLOAD данные с сервера нужен ключ -R

---

LINUX REMAP KEYS

купил мелкую клаву.
а на ней эти уроды убрали insert 
pgup pgdown end

как сделат ьтак чтобы жмешь наодну конопку а унее функция другой кнлопки


редактикрую файл

/usr/share/X11/xkb/keycodes/evdev

а если пром еще хочется узнать какой код у какой кнопки то 
хзапусти прогу xev

=============
ssh

known_hosts

что в этом файле на компе клиента.

когда мы конектимся к серверу 
то он нам присылыает свой публичный ключ.
так вот в known_hosts наш хост сохраняет хэш от этого публичного ключа + IP\hostname от этого сервера.
зачем мы это делаем = чтобы в следущий раз если мы стучим на этот сервер то заранее знать какой нам публичеый 
ключ ожидать. потому что злолдей может заглущить ориганлный сервер поставить себе его ip 
создать свой приватный \пубичный ключ  и совать их нам выдавая себя за оригинаьный сервер.

строчка в этом файле прдставляет собой вначале идет hostname\ip смотря что мы вбивали в команде ssh
причем оно указано не в открытом виде а виде тоже хэша. а потом идет хэш от публичного ключа того сервера

поскульку это хэши то дешифровать никак нельзя.

зато можно провнрить есть и в known_hosts запись о том или ином хосте.

$ ssh-keygen -F mail.ru

еще можно удлаить строчку из known_hosts

$ ssh-keygen -R mail.ru

если удалить весь файл то ничго страшного.
просто при стучании на серверы начнет выскакивать надпись дескать 
удаденный хост имеет такой то хэш пуличного ключа мол вы согласный что удалеенный хост это удаленный хост
вот и все последствия

=============
tty

про эту тему tty можно писать много и долго.
про эту тему уже разбросано несолько кусков по моей документации. 
я позже их соберу. а щас рассмотрим такую тему. вот если нажать ps aux

то в выводе идет список процессов и у каких то процессов указан знак вопроса "?"  в столбце tty а 
у каких то указано tty1 или tty7 или pts/0. pts небудем трогать пока считаем что это некая разновидость tty. так вот что же это значит что процесс имеет некий tty или не имеет его. на что
это вляет как это понять почуствовать. в чем разница и все такое.

если процесс в выводе ps имеет в свойствах tty это значит что у данного процесса в свойствах 
открытых файлов имеется устройство tty. пример

смотрим на ps для процесса 1180

$ ps aux | grep -E "TTY|1180"
USER       PID %CPU %MEM    VSZ   RSS   TTY      STAT   START   TIME   COMMAND
root      1180  0.6  0.5 1227504 89308  tty7     Rsl+   апр18   116:29  /usr/lib/xorg/Xorg

видим что ps показывает для 1180 что tty7

смотрим какие файловые дескрипторы открыты для процесса 1180 на proc
$ sudo ls -1al /proc/1180/fd/ | grep tty
lrwx------ 1 root root 64 мая  1 01:10 12 -> /dev/tty7

и видим что среди файловых дескрипторов есть /dev/tty7

файловый дескриптор это поток обмена информации между процессом и внешним миром. в него 
можно читать и писать. в данном случае у процесса поток номер 12 имеет 
бекендом  устройство /dev/tty7 тоесть у процесса есть канал обмена информацией между процессом
и устройством /dev/tty7 

таким образом если в ps мы видим что процесс имеет в своих свойствах tty устройство 
это значит что у процесса открыт канал связи с tty устройством.

что такое tty устройство - для начала  /dev/ устройства в целом что это такое. есть реальное физическое устройство железка. данные от железки поступают в ядро. а /dev/ устройства это кранчик
который торчит из ядра который позволяет программе из user space получит данные от железного устройства из ядра через этот кранчик /dev/ файла.  какая железка является бекендом для /dev/ttyX 
файла. в одном случае это COM порт. тоесть запись в /dev/ttyX файл пишет в COM порт и чтение из 
/dev/ttyX файла это принятие данных из COM порта.  
таким образом если у процесса есть файловый дескриптор который ведет в /dev/tty устройство это значит данный процесс может писать в COM порт или читать данные из COM порта.
цепочка тогда выглядтит так:

процесс -> файлоый дескриптор -> /dev/tty устройство -> ядро -> COM порт

и наоборот.

тоесть если у процесса есть tty устройство это значит что у процесса открыт канал связи с внешним миром через COM порт в обе стороны. тоесть с точки зрения процесса у него открыт файл на чтение 
и запись. бекендом данного файла явяляется tty файл бекендом которого является COM железка.

далее. чуть сложнее. раньше клавы и мониторы были вынесены за системный блок. то есть схема 
выглядела так. системный блок у него COM порт. в него идет провод от коробки под названием 
терминал. терминал это коробка у которой есть клава и экран вот сигнал от клавы на терминале 
поступал в системный блок через COM порт получается через /dev/tty файл. и также от системного блока
инфо которая была предназначена для вывода на экран она летела в /dev/tty файл от процесса в системном блоке потом в ядро и в COM порт оттуа по проводу в терминал а он(терминал) поступившую инфо  преобразовавл и выводил буквы на экран терминала.  таким образом COM порт это был порт 
через который инфо от клавы и монитора попадала в системный блок в обе стороны.
таким образом COM порт это был порт через который в процесс могл прилетать инфо от клавы и 
и от процесса инфо могла попадать на экран монитора. тоесть COM порт и tty устройство это устройство
через которое через который процесс имеет связь с живым юзером.

далее прикол в том что в ядро линукс встроен виртуальный терминал выглядит это так. процесс 
открывает файл /dev/ttyX устройство и начинает туда писать. данные летят в ядро. ядро направляет поток в драйвер виртуального терминала и он направляет его на экран монитора. и про клаву. поток из клавы летит в ядро. ядро направляет поток в драйвер вирт терминала. он обрабатывает поток и шлет
поток в /dev/tty файл и процесс чеерз этот файл получает поток от клавы внутрь себя. таким образом
если у процесса открыт на чтение запись файл /dev/tty{1..7} то это значит что даные с клавы летят в данный процесс и данные от процесса выводятся на экран.

таким образом отвечаем на изначальный вопрос в чем разница между процессом у которого открыт 
поток чтения записи в tty устройство от процесса у которого такого потока неоткрыто.
разница в том что процесс у которого отркыт поток обмена данным с tty устройством дает 
возможность чтобы инфо с клавы компа летели внутрь процесса и поток вывода от процесса в tty 
приводит к тому что инфо поступает на экран компа. таким образом tty поток дает воможность 
взаимодействовать процессу с живым юзером через экран и клаву.

во времена терминалов за каждый ttyX  портом скрвыался на том конце терминал со своей клавой 
и своим экраном. тоесть если было семь tty1-tty7 портов то это значит что было на том конце
семь терминалов, семь клавиатур и семь мониторов. поэтому если процесс 1 имел открытым tty1 то 
инфо с клавы 1 летело в процесс1 а если процесс2 имел открытым tty2 то инфо с клавы2 летело в процесс2. а какая же ситуация сейчас когда у нас на компе есть tty1-tty7 но при этом клава 
физически у компа одна. как же ядро понимает в какой tty посылать поток идущий с клавы.
я понимаю что дело выгляди так - вот мы тыкнули Ctrl-Alt-F1 значит ядро понимает 
что на данный момент мы "активировали" первый виртуальный терминал в ядре.значит поток букв от клавы
надо посылать в /dev/tty1 и значит тот процесс который читает с этого устройтва и будет получать
поток букв с клавы.  теперь про экран. пусть у нас семь процессов и каждый из них открыл свой tty
тоесть

pid 1 -> tty1
pid 2 -> tty2
...
pid 7 -> tty7

далее каждый из этих процессов постоянно чтото шлет записывает в свой tty. 
возникает вопрос какой из этих потоков выводить на экран. думаю что рабтает также.
что поток сохраняется в некий буфер в памяти ядра. для каждого tty свой буфер. далее
мы жмем Ctrl-Alt-F1 и ядро понимает что мы активировали первый виртальный терминал. 
тода ядро выводит на физический экран вывод из буфера памяти от tty1 устройства.
далее мы тыкаем Ctrl-Alt-F5 и ядро понимает что мы перключились на пятй виртуальный терминал
и ядро выводми на экран вывод из буфера памяти который хранит накопленный поток от tty5.
это была логика когда у нас линукс работает в текстовом init 3 режиме.
когда у нас графический режим то вместо tty используются pts устройства. и вместо Ctral-Alt-Fx
комбинаий исполщуется то что мы мышкой активируем то или иное окно.

таким образом есл вернтся в текстовый режим то полчается что ядро линукса оно биндит
виртальные терминалы(монитор и клава) в физическую клаву и физический монитор.

итак еще о чем нам говорит если у процесса  в списке открытых файлов есть tty устройство.
это нам говорит о том что данный проецесс подразумевает может контактировать с живым юзером
через клаву и монитор. через клаву процесс может получать от юзера нажатие кнопок а через монитор процесс может выводить инфо. если у процесса нет открытых tty файлов то работа данного процесса
не подразумевает контакт с живым юзером. с клавы он инфо принимать неможет и на экран выводиь 
инфо он тоже неможет. назовем это так : есть юзер интерактивные процессы и неинтерактивные.

вопрос а что если несколько процессов одновременно имеют откртытым один и тот же tty файл например tty2.
вот мы жмем кнопки на клаве в какой процесс летит поток от клавы. ответ такой что от того что 
процессом открыт файл еще незначит что он из него постоянно читает. 
если они оба постоянно пытаются из него читать то будет идти конкурентная борьба и часть букв 
будет попадать в один процесс а часть в другой. 

а что если они оба активно пишут в tty2. значит на экране будет идти смесь то одного процесса то 
от другого. тоесть. скажем первый шлет "aaaaaaaaaaaa" а второй шлет "bbbbbbbbbb"
на экране юзер буездет видеть чтото типа того "ababbbaabbabababbaab" тоесть будет тоже идти
конкуретная борьба.

но как я уже скаал от тооо что два процесса имеют открытым один tty2 это незначит что они оба
из него сейчас активно читают или пишут. пример откроем терминал в граф оболочке. и введем команду
$ tty
она покажет к какому устройству вирт терминала прикреплен данный виртуальный терминал.

$ tty
/dev/pts/21

pts это упрошенно говоря тоже некий аналог вирт терминала.

теперь вот что запустим

$ ps aux | grep 'pts/21'
vasya    15543  0.1  0.0  34112  5448 pts/21   Ss   02:53   0:00 bash
vasya    15557  0.0  0.0  48852  3772 pts/21   R+   02:54   0:00 ps aux


тут видно что два процесса имеют открытым один и тот же файл вирт терминала pts/21
но между ними конфликта нет. мы имели запущенный bash и в нем мы запустили команду ps aux
и баш что сделал. он породил новый процесс ps aux и при этом процесс bash 15543 ушел в состояние 
interruptible sleep. конечно статус в ps не является прям точной инфо потому что процесс может 
чтото делать по быстрому и потом уходить в состояние sleep тоесть это незначит что процесс прям
все время в этом состяонии. он был в том состоянии только на момент вывода ps. одномоментно.
но с высокой долей вероятности можно полагачть что 
  хотя bash 15543 и имеет открытым pts устройство но он из него ничего нечитает и в него 
ничего не выводит. поэтому на момент выполнения ps aux вывод на pts\21 был подчинен только 
процессу ps aux. поэтом конфликат никакого нет. поэтому нет никакой чехарды с потоком от клавы
 и потоком на монитор. но в целом его легко устроить если запустить какойто цикл который чтот выводит экран. а потом открыть другой терминал и начать слать мусор в /dev/pts/21 и тогда на экране
 первого терминала будет идти смешение вывода от цикла и от нашего ручного мусорного потока.


а вот интеренсый вопрос что происходит когда в bash мы запускаем команду  в
background режиме ( это такая фишка баша). например

$  (while true; do sleep 10; echo "111"; done)&

при этом будем наблдюдать интересуную картину с одной стороны мы имеем доступ
к консоли но в ней периодически будет появляться "111"

получаеся по факту у нас два процесса у которых один pts/22 и наш первый процесс он периодически
шлет в pts/22 инфо и она выскакивает на окне терминала. в тоже время мы тоже сидя за клавой
может чтото писать на терминале. тоесть мы имеем два процесса которые одновременно вывоводят в 
один терминал. насколько я понимаю что просиходит при запуске в баш команды в бекграунд режиме 
то форкается процесс в нем запускается команда но исходный баш процесс не помещается в режим sleep
а продолжает свою работу. 

 а вот еще пример

 $  ( while true; do     sleep 10; read var1; done )&

 тут получается что процесс должен считать с клавы. так вот у нас получится что есть 
 два процесса с одним pts и оба процесса в какойто момент времени будут читать с клавы
 так вот незнаю как но баш делает так что если бекграундный процесс лезет читать в то время как 
 исходный баш процесс читает ведь с клавы так вот бекграуден процесс тут же будет остановлен 
 башем.  с точки зрения статуса данный процесс будет переведен в статус "T" когда он попытается
 счиатть с клавы наряду с исходным баш процессом.


====
каналы 1 ,2 

по поводу пернаправления вывода

find / 2>/dev/null

что там происходит по капотом в этом случае. что за загадочные цифра 2.
на самом деле все просто. создаетя процесс который обслуживает find
и у него есть файловые дескприоры 

/proc/$$/fd/{0,1,2}

так вот мы башу закаываем чтобы он когда будет создавать процесс под команду find
чтобы он дескпритор 2 перенарпавил (тоесть что у него будет бекендом ) не на экран ( тоесть не на /dev/pts/17) а в /dev/null вот и все

$ sudo ls -1al /proc/20920/fd
lrwx------ 1 root root 64 мая 17 23:42 0 -> /dev/pts/32
l-wx------ 1 root root 64 мая 17 23:42 1 -> 'pipe:[1662807]'
l-wx------ 1 root root 64 мая 17 23:42 2 -> /dev/null


вот четко видно что 

2 -> /dev/null

что файловый дескриптор 2 ( в который процесс кидает поток с инфо о ошибках) совать в /dev/null

вот как работает под капотом вся эта хрень с перенапраавлением ввода вывода!















===
processes 'R' 'D' status
+ kernel mode

It is not 100% beatifull answer but it can give you a flavour. If you have some process that constantly in 'R' state - you can start to monitor two fields from procfs:

$ awk '{print $14, $15}' /proc/$$/stat 
you will see something like: 0 3915

The first number shows 'Amount of time that this process has been scheduled in user mode, measured in clock ticks' , the second one shows 'Amount of time that this process has been scheduled in kernel mode, measured in clock ticks'. (please have a look at man proc for the details).

However the point is if 3915 is growing fast and 0 is not growing it means the process is running under kernel mode right now. The more fast 3915 is growing the more we can be sure that the process is running under kerhel mode.

an example:

$ sudo dd if=/dev/nvme0n1p2 of=/dev/null bs=30M count=1000

    $ top

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                   
16691 root      20   0   45352  32712   2112 R  50,5  0,2   0:06.00 dd

  
$ awk '{print $14, $15}' /proc/16691/stat 
0 467

$ awk '{print $14, $15}' /proc/16691/stat 
0 512

$ awk '{print $14, $15}' /proc/16691/stat 
0 557

$ awk '{print $14, $15}' /proc/16691/stat 
0 594

$ awk '{print $14, $15}' /proc/16691/stat 
0 630

$ awk '{print $14, $15}' /proc/16691/stat 
0 666

$ awk '{print $14, $15}' /proc/16691/stat 
0 699
So we can say - yes, the process is running under kernel mode.

As for 'D' state:

As for 'D' state (correct me if i'm wrong) - it means the process in a "sleep" state. It is 'uninterruptible sleep' state anyway it is a sleep state , it means the code of the process (user space) or invoked kernel code via syscall IS NOT scheduled on cpu until some necessary data\structure is available. So i suppose the processes in 'D' state should be excluded from the review. Why? Because they just not executed on cpu at all. However there is a subtle moment. The process can switch between 'D' and 'R' states quickly so we can think the process is in 'D' state however it goes from time to time to 'R' state.

Let me give explanation in details: Very often people say that if a process in 'D' state it means it waits some I\O. It is not necessarily so.

Simple program in C.

$ cat 30.c
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {

    pid_t pid = vfork();

    if (pid == 0) {
    sleep(180);
    return 0;
    }

      printf("parent: I am exiting\n");

     return(0);
}
Compile.

$ gcc -o 30.exe 30.c
Launch.

$ ./30.exe
It uses vfork that creates a child process. The parent process will be blocked until child exits. Also the state of parent process will be 'D'.

$ ps  aux | grep 30.exe
vasya     6495  0.0  0.0  10700   964 pts/66   D+   03:30   0:00 ./30.exe
vasya     6496  0.0  0.0  10700   964 pts/66   S+   03:30   0:00 ./30.exe
So the parent doesnt do any i\o operations but have 'D' status.

Next - Lets have a look if process with 'D' uses cpu. So lets check if it really sleepls.

$ while true; do cat /proc/6495/stat | awk '{print $3, $14, $15}'; done
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
As we can see it is.

Next. Very often we can see a process is in 'D' state however "top" shows it consumes CPU. How is it possible? The quick answer - the process switches between 'D' and 'R' states. It can happen very quickly. Remember "top" reads all the information from procfs. By default "top" refreshes all the data every 3 seconds so if the process switched very often to 'D' state and not so often to 'R' state it will seem to us as the process lives all the time in 'D' state. However it is false assumption.

The next important point is that the state of the process is a property of instant moment. That is when we are talking about the process has "D" state we mean it is in this state at this particular time. However when we are talking about CPU consumption - it is not about property of instant moment of time. It is average value FOR SOME PERIOD OF TIME. Pls have a look at the picture:

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND
13416 vasya     20   0   24024   5308   2132 D  62,9  0,0   0:05.02    dd  

                                                                                                                  
We see that the state = 'D' %CPU = 62,9

It means that at the moment (right now) the state = 'D' It means right now process does not consume cpu cycles , however some time before the process was NOT in 'D' state and it was consuming cpu cycles. So for the simplicity "top" calculates the average for the last three seconds. It can be like so:

Now - 0%
1 sec ago - 62,9%
2 sec ago - 62,9%
3 sec ago - 62,9%

the average = (62,9%+62,9%+62,9%+0%)/(1+1+1) = 62,9%
So thats why "top" shows 62.9% of cpu usage in spite of the state of the process is 'D'.

To proof that 'dd' switches between 'D' and 'R' states:

$ while true; do cat /proc/13416/stat | awk '{print $3, $14, $15}'; done
R 0 745
R 0 745
D 0 746
D 0 746
D 0 746
D 0 746
D 0 746
D 0 746
R 0 746
R 0 746
R 0 746
R 0 747
R 0 747
R 0 747
R 0 748
D 0 748
D 0 748
D 0 748
D 0 748
R 0 748
R 0 748
R 0 749
D 0 749
R 0 749
R 0 749
D 0 750
D 0 750
D 0 750
D 0 750
D 0 750
D 0 750
R 0 750
R 0 751
R 0 751
R 0 752
R 0 752
R 0 752
D 0 752
D 0 752
D 0 752
D 0 752
D 0 752
R 0 753
R 0 753
D 0 753
D 0 753
D 0 753
D 0 753
R 0 754
R 0 754
R 0 755
R 0 755
D 0 756
D 0 756
About the meaning of $14 and %15 fields: As for "man proc":

$14 = Amount of time that this process has been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
$15 = Amount of time that this process has been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).

As you can see "dd" switches between 'R' and 'D' states. Thats why average cpu consumption is not 0%.

Also you can see that while the process really in 'D' state it does not consume cpu cycles neither for user mode nor for kernel mode.

As the final suggestion: if you have a process and want to know if it is running right now in user or kernel space --> start monitoring

$ cat /proc/13416/stat | awk '{print $3, $14, $15}';
If $14 is changing - it means the process in user space, if %15 is changing - it means the process is in kernel space

Hope it helps

Еще добавок про S и D состояния процесса.
Если у процесса состояние S то это означает две вещи: 
1. код программы (непосредственный код программы) шедулером больше неразмещается на цпу. Он физически больше непопадает на цпу.тоесть код процесса реально больше непопдает и неисполняется на цпу. а если процесс сделал сисколл тоесть вошел в ринг0 и код ядра. то тоже самое. и ядерный код неразмещен шедулером на цпу. таким образом ни юзерский
код процесса ни вызыванный код ядра через сисколл - ничего из этого на данный момент неразмещено на цпу. ( на данный
момент потому что статус это характеристика типа instant тоесть вот оно как прям щас)  

2. Плюс статус S означает что процесс принимает сигналы. таким образом например работу
процесса можно прервать прям щас.
что значит процесс принимает сигналы.значит что ядру разрешено
в таблицу процессов данному процессу записать свойство сигнал. а шедулеру разрешено тут же взять 
и запустить обработчик этого сигнала. тоесть по факту это нето что там код процесса чтото решает принимать ему или нет. это один кусок кода ядра разрешает другому куску кода ядра сделать 
изменнеие в таблице процессов для данного процесса. а шедулер увидев что в свойствах процесса
появилось своства сигнал запустити обрабочик сигнала. сам процеесс ничего нерешает.

Сразу скажу про статус 'D' он такой же самый только нет пункта два. тоесть 
нельзя процессу доставлять сигналы. запрещено. таким образом пока процесс имеет статус 'D' никак неповлиять на него через сигналы. (кроме ребута). Когда процесс выйдет из статуса 'D' то сигналы что ему слали (они сохраняются) будут ему наконец "доставлены".


далее. вверху я уже написал  на английском  но еще раз скажу:
если у процесса статус S или D то согласно пункту один код процесса шедулером неразмещается
на цпу и также если проецесс сисколл вызывал то его код тоже неразмещается на цпу. дело в том 
что да если процесс вызывал сисколл то как это работает в паре с шедулером? отображается ли 
работа ядерного кода в статусе процесса или нет. ответ да. когда вызывано ядро через сисколл 
то условно гооворя запускается функция просто она физически размещается не в коде программы
а в отдельных других файлах в которых код ядра (условно говоря либо в вбиблиотеке libc либо в ядре vmlinuz) так вот что там происходит. а ничего особого. цпу перекчается в ринг0. да там немного 
меняютсяс пара регистров , условно говоря ссылка на стек меняется но в целом ядерный код начинает
работать в окружении регистров и вирт памяти которая осталась от процесса. да ядерный код помимо 
вирт памяти процесса также может лазить в память ядра но в целом как пишут книжки ядерный код
работает в окружении процесса. и вот далее важно. один момент это то что вот на цпу работает ядерный код. далее происходит таймер интеррапт и цпу прерывает работу этого ядерного кода 
без проблем ему похер ядерный код или юзерский. далее появляется шедулер. и он как то понимает 
что этот ядерный код он относится к процессу и он во первых выдавливает этот код с цпу, сохраняет
все что нужно в свойствах процесса гдето в памяти причем ссылка на команду идет именно на 
ядернй код там где была остановка из за интерапта и шедулер обновляет статистику толтко что заюзанного  тайм слайса со стороны ядерного кода в статистику работы именно процесса.
так что мы имеем два момента , один это то что цпу когда ядерный код выполняет то его можно прервать
и второе что шедулер то время которое ядерный код работал по вызыву процесса зачисляет в статистику
самого процесса в procfs так что мы четко можем быть уверены что время работы ядерного кода на цпу
будет отражено именно в статиске процесса а значит мы увидим в top работу ядерного кода для процесса
в статистике процесса в плане cpu usage. иначе получалась дурацкая ситуация ядерный код по запросу
нашего процесса работает но мы невидим эту статистику в свойствах процесса и думали бы что процесс
прохлаждается . неважно в рамках нашего процесса код из нашей программы крутится на цпу и внешняя функция из ядра - по факту это все ресурсы запользованные нашим процессом так что статистика
должны отражаться в свойствах процесса. потмоу что было непонятно вот заустил процесс сисколл 
цпу перешел в режим ядра и где искать сколько cpu usage сейчас жрет этот сисколл. оказывается 
искать ненадо. его cpu usage засунут в свойства процесса как бутто это щас код из процесса 
и крутится на цпу. получается если мы в top видим что у процесса есть какйото cpu usage то 
мы неможем навскидку сказать это время когда цпу работал в юзер моде или в кернел моде 
потому что там указана их сумма. ( конечно надо понимать что в рамках процесса цпу в каждый момент времени работает либо в юзер моде либо в кернел моде но неодновременно).

также еще ращ скажу важно понимать что характеристика статус процесса типа "S"\"R"\"D"
это характиристика в конкретной точке времени. тоесть скажем прям щас. 
втоже время cpu usage в рамках команды top (потому что в procfs там нет этого параметра в чистом виде) это характеристика не про момент времени а за некоторый пропмежуток времени средняя величина.
Поэтому если мы видим что статус процесса S\D но в тоже время его cpu usage неравен нулю тут 
нет никакого противоречия потому что S\D статус относится к тому как это щас у процесса а его
cpu usage относится к промежутку времени между три секунды назад и щас. (три секунды это дефолтовое
время усреднения со стороны top). тоесть это значит что в моменты времени до нашего текущего
у процесса было переключение на статус R (это 100% и процесс жрал цпу. жрал это значт что он занимал кванты времени находясь на цпу своим кодом). вот поэтому и нет противорречия. да если щас статус S то прям щас процесс использует цпу на 0%. но еще раз top непоказывает на сколько % процесс
исполует цпу прям щас . потому что на самом деле нет такой характеристики на сколько % процесс занимает цпу прям щас. потому что прям щас процесс либо выполняется на цпу тоесть он его занял
либо он невыполняется. но процентов никаких нет в этом плане в природе. процент получается исходя
из совершенно другого если унас есть три промеждутка времени. ( это то как это работает со стороны шедулера) и скажем в первый промежуток у нас код находился на цпу на втором он ненаходился и на третьем он анаходидся то это значит что с точки зрения времени сколько процесс находился на цпу это будет 100%*(1+0+1)/3 =67% тоесть показатель cpu usage это показатель сколько времени процесс находился за заданный проемежуток времени на цпу ане то что прям сейчас цпу работат на 67% своей мощности. у цпу нет никакой мощности он либо работает щас на 100% либо нет. просто кажому процессу
дается небольшой квант времени. и cpu usage это отношение сколько таких квантов процесс находился на
цпу к общему числу квантов времени. поэтому никакого парадокса в top нет. вот как в этом примере

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND
 2185 vasya     20   0 3181856 282088  50380 S  25,9  1,7   377:25.95 cinnamon 

статус S это то как щас а 25.9%CPU это в среднем за последние 3 секунды.
почуствуй разницу между "щас" и "за последние три секунды"

еще подчеркну что cpu usage в точке щас такого понятия вобщемто нет. точнее оно есть
но оно неудобное. процессор щас либо занят CPU usage его 100% либо незанят и тогда 0%.
это нам ничего недает.

далее я еще раз  обсуждаю часть то что сказал выше  а часть нового:
также суперванжно добавить что процесс себя сам выдавить из цпу неможет. самс себя убрать из цпу
процесс неможет. нет ассемблерной команды которая бы выдавила процесс из цпу. вообще что значит
выдавить процесс из цпу. это значит что на какое то время код процесса небудет размещаться на цпу. а ведь только в этом случае процесс будет иметь статус S\D.
это может сделать толко шедулер ибо он в очередной квант времени сует код код процесса на цпу
а код других процессов несует.в юзерспейсе нет такой команды асемблера которая бы обратилась
к шедулеру и сказала мол все я закончила давай убирай меня из цпу. (этот факт что программа сама добровольно обратилась  к шедулеру и сказала мол я закончила раньше времени либо я буду ожидать наступление некоего события поэтому можешь пока выдавливать меня называется voluntary_ctxt_switches
тоесть это процесс сообщил добровольно шедулеру что он может выдавливать этот проецсс из цпу на какоето время. так вот я утверждаю что из кода юзерской программы это невозможно сделать, тоесть 
самому себя выдавить из цпу невозможно а даже если бы это было возможно то об этом бы незнал шедулер , шедулер бы считал что процесс отработал на цпу полный квант времени и статистика по процессу в procfs была все равно такая что как бутто он отработал полный квант в любом случае
сам код программы это сделать неможет работая в юзер спейсе он это может сделать только вызвав
ядерный код через сисколл. я несмотрел код сисколлов но я точно уверен что добровольная отдача обратно цпу а другими словами запрос к шедулеру о том чтобы он выдавил процесс из цпу и вставил другой находится в сисколлах. самый простой сисколл который может это сделать это nanosleep(), 
если в баше то это /bin/sleep, если через асемблер запускать то это сискол номер 35, если пишем на
C то там это вызывается через libc обертку sleep(), остальные сисколлы они там сами решают
когда они хотят сделать запрос к шедулеру чтобы он выдавил процесс из цпу.  еще раз напомню 
что добровольная отдача цпу что по факту никакая неотдача а запрос к шедулеру чтобы он выдавил
процесс из цпу назвыается voluntary_ctxt_switches. так вот я еще раз скажу что я считаю что 
это может сделать только сисколл. делает он это неспрашивая нас когда мы его вызываем например
наша програма  ждет нажатия кнопки для этого мы вызываем сисколл который этим занимается, сисколл
выставляет условие в ядро о том когда процесс надо будить и сисколл просит у шедулера выдавить
процесс из цпу и небудить до момента наступления нажатия кнопки. так и только так происходит voluntary_ctxt_switches . из кода программы юзерского мы так сделать неможем никак а может только 
вызывав сисколл. причем сисколл nanosleep() через него мы в явном виде заказываем выдаволение процесса с цпу на заданное время , другие же сисколлы сами определяют когда на какое время или до наступления какого условия выдавить процесс из цпу и делают запрос к шедулеру тоесть вызывася эти
сисколлы мы понятия неимеем как когда зачем и почему данный сисколл закажет выдавливание ( ака добровольный конекст свич) потому что мы вызываем эти сисколлы для других целей например прими нажатие от кнопки. цель этого длинного куска была втом чтобы обьяснить как на практике и откуда
получается добровльный контекст свич. оценить как часто сисколлы нашей программы заказывали
добровольное выдавливание можно через:

	$ cat /proc/$$/status | grep switch
	voluntary_ctxt_switches:	172
	nonvoluntary_ctxt_switches:	5

соответвенно nonvoluntary_ctxt_switches - это недобровольное выдавливание процесса из цпу 
со стороны шедулера. когда это происходит - тогда когда программа работает но ее тайм слайс 
так уж вышло закончился. тогда шедулер принудительно выдавилвает процесс из цпу. я бы еще добавил 
так что если процесс все время нахрится в состоянии 'R' то у него конечно будут только сплощные
nonvoluntary_ctxt_switches потому что его нужно будет постоянно выдавиливать. а если процесс
слабо нагруженный который часто в "S" то у него буду преимушественно voluntary_ctxt_switches.
оно ипонятно процесс сам по себе в состояние S перейти никак неможет, для этого он обязательнро 
должен вызывать сисколл в котоом наверняка будет выдавилвака процесса из цпу , слабонагруженность
это прямое следствие статуса S и выдавиливалки в сисколле том или ином.

посмотрим для примера статистику по процессам:

$ cat /proc/1/status | grep switch
voluntary_ctxt_switches:	  34780
nonvoluntary_ctxt_switches:	 1194

логично.

а тепер вот такую программу возьмем

$ cat 24.c
#include <stdio.h>
#include<unistd.h> 


int main () {

   /* local variable definition */
   pid_t pid;
   pid = getpid();
   printf ("pid = %d\n",pid);

   int a = 10;
   /* while loop execution */
   while( a < 20 ) {
   }

   return 0;
}

тоесть по факту это просто пустой бесконечный цикл.

компирлируем
$ gcc -o 24.exe 24.c

и сразу для интереса дизасемблиуриуем:
$ objdump -b elf64-x86-64 -M intel  -d 24.exe

000000000000068a <main>:
 68a:	55                   	push   rbp
 68b:	48 89 e5             	mov    rbp,rsp
 68e:	48 83 ec 10          	sub    rsp,0x10
 692:	e8 b9 fe ff ff       	call   550 <getpid@plt>
 697:	89 45 f8             	mov    DWORD PTR [rbp-0x8],eax
 69a:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
 69d:	89 c6                	mov    esi,eax
 69f:	48 8d 3d ae 00 00 00 	lea    rdi,[rip+0xae]        # 754 <_IO_stdin_used+0x4>
 6a6:	b8 00 00 00 00       	mov    eax,0x0
 6ab:	e8 b0 fe ff ff       	call   560 <printf@plt>
 6b0:	c7 45 fc 0a 00 00 00 	mov    DWORD PTR [rbp-0x4],0xa
 6b7:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
 6bb:	7e fa                	jle    6b7 <main+0x2d>
 6bd:	b8 00 00 00 00       	mov    eax,0x0
 6c2:	c9                   	leave  
 6c3:	c3                   	ret    
 6c4:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
 6cb:	00 00 00 
 6ce:	66 90                	xchg   ax,ax


на самом деле цикл while 
это вот эти две команды которые будут крутится вечно

 6b7:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
 6bb:	7e fa                	jle    6b7 <main+0x2d>

ну это чисто так для интереса мы дизасмлировали чтобы посмотрть как С програма будет
выглядит на асемблере.

так вот такая программа неимеет в своем цикле никаких сисколлов так что
эта программа хочет крутится на цпу все время (потому что без вызоыва сисколла программа 
претендует вечно занимать цпу ровно за этим и нужен шедулер), соттвенвенно статус у процесса будет R
все время и загрузка по цпу 100% птому что программа будет стремиться занимать все таймслоты что ей даст шедулер а шедулер будет вынужден выдалавить процесс хотя бы порой. вот щас это и проверим

запускаем
$ ./24.exe
pid = 20260


  PID USER      PR  NI    VIRT    RES    SHR     S  %CPU     %MEM     TIME+ COMMAND                
20260 vasya     20   0   10832    968    868     R  100,0     0,0   0:23.64 24.exe  


$ while true ; do cat /proc/20260/status | grep switch; sleep 1; done
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	73
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	73
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	79

видно что у программы нет ниодного добровольного отдачи цпу потому что да его и нет 
в коде програмы потому что у нас в цикле нет ниодного сисколла. так что щедулер 
исключтельно принудительно nonvoluntary выдавливает процесс из цпу.
цикл снятия статистики выдает ее раз в секунду ( а мы помним что щедулер срабаывает примерно
100 раз в секунду) так что из статистики видно что шедулер далеко некаждый раз выдавливает 
нащ процесс из цпу (иначе бы за секунду он это делал 100 раз а мы видим что за две секунды бывает
что и ни разу), так что программа резвится на цпу очень даже хорошо , лишь иногда шедулер
все таки выдавивет ее из цпу. отсюда мы делаем три вывода: 1) шедулер далеко не каждый тайм слайс (10мс) выдавливает процес из цпу, 2) если в коде программы нет сисколла ( у нас конечно есть в программе сисколлы но вне цикла while тоесть до них очередь недошла) то ни о каком добровольной 
отдаче цпу и речи неидет для этого обязательно нужно вызывать сисколл в коде программы. 3) даже если в системе есть свободные ресурсы то все равно время от времени шедулер выкидывает процесс
из цпу это значит что система недаст процессу 100% времени на цпу иногда всеже она будет
его на немного выдавливать. опять же незабываем что интеррапты приходят на цпу и немало и 
их обработка она же тоже жрет время цпу так что даже на многопроцессорной системе часть мощности
цпу будет вседа уходит по крайней мере на обработку интераптов( я так посмотрел в top цифра si и она доходит порой до 4%). так что будем ссчитать что в лучшем случае процесс может сидеть на цпу на уровне 96%.




пример с nanosleep
$ cat 37.c
#include<stdio.h>
#include<time.h>


int main()
{

     const struct timespec kuku = {300, 100};
     struct timespec kuku2 = {3, 100};

     nanosleep(&kuku, &kuku2);

    return 0;
}


через этот сисколл мы просим шедулер выдавить из цпу наш процесс на 300 секунд и еще 100мс
компилируем запускаем:
$ gcc -o 37.exe 37.c
$ ./37.exe

дальше интерсно я подождал скажем минуту а дальше смотрю статистику
$ cat /proc/24455/stat | awk '{print $3, $14, $15}'
S 0 0

про $14 и $15  я уточню интересное это сколько цифры . первая про юзер спейс вторая про кернел спейс. сколько времени процесс работал в юзер спейсе и в кернел спейсе тоесть сколько времени
процесс выполнял юзерский код а сколько времени проецесс выполнял сисколлы. так вот интересно тут
то что в каких единицах времени это меряется. в man proc написано что цифры обозначают clock tics
сразу скажу что это не цпу клоки и все такое. 1 clock tic это время между вызовами шедулера это 
один тайм слот. вот $14 и $15 показывают число тайм слотов в штуках которые процесс провел на цпу.
далее они предлагают число этих штук этих слотов поделить на sysconf(_SC_CLK_TCK) по дефолту
оно равно 100. тоесть 100 раз в сеунду срабывает таймер интеррапт и вызвается шедулер .таким 
образом если мы поделим тайм слоты на 100 то узнаем в секундах ( а в не в штуках слотов) процесс
прокрутился на цпу. 

  на мой взгляд поэтому немного странно получаенные цифры S 0 0. что как бутто процесс
  непровел на цпу ни единого тайм слота. хотя.. может быть %14 и %15 округляет до целых ведь процесс может провести на цпу толко часть тайм слота а потом попросить щедулер его выдавить.
  тайм слот очень большой целых 10мс. за это время туча кода может отработать. а наша программа
  мелкая и вся заточена под скорейшее выдавливание из цпу. так что может 0+0 это и реальная цифра 
  тоесть программа провел на цпу какоето время но существенно меньшее чем даже 1 тайм слот 10мс.


 теперь посмотрим на 

 $ cat /proc/24455/status | grep switch
voluntary_ctxt_switches:	1
nonvoluntary_ctxt_switches:	0

это было снято через минуту уже как программа была запущена.
тут мы видим что процесс ощутил на себе всего одно добровольное выдавливание из цпу.
и больше ни одного выдавливания небыло. это показывает то что цисло эти switch оно обозначает
сколько раз реально из цпу код процессы был выкинут. это значит что такое минимальное количество
раз код точно побывал на цпу и его выкинули. это незначит что ровно такое число процесс был
на цпу. число может быть гораздо больше скажем для постоянно работющего процесса. как я показал
выше шедулер постоянно рабоатающий проецесс при налиичии ресурсов выдавливает далеко некаждый 
цикл. так что сколько секунд или циклов (которые можно пересчитать в циклы умножив на sysconf(_SC_CLK_TCK) который обычно равен 100) процесс провел на цпу можно посчитать заглянув в 
$14 и $15. а в  voluntary_ctxt_switches и nonvoluntary_ctxt_switches указано реально 
сколько раз код был выкинут,выдавлен из цпу.

вот в нашем конкретном примере четко можно увидеть что код залетел на цпу был выкинут 
и больше код на цпу недопускался.

получается возьмум pid=1
$ cat /proc/1/stat  | awk '{print $14, $15}'
999 1390

получается на цпу он отработал всего (999+1390).100~24c при том что аптайм 12 дней. но тут нет 
парадокса потому что $14 и $15 это же то суммарное время когда код процесса реально работал на
цпу а процесс init он же постоянно спит 'S' так что все нормально. указано чистое время
сколько код процесса реально крутился на цпу. аптайм здесь ни при чем.

а вот если мы возьмем процесс который постоянно раотает статус R у него $14+$15 должны очень
точно совпдаать с временем как мы его запустили (при наличии ресурсов у компа то есть процесс
дейсвительно должен потоянго быть R )


запустим такую программу которая просто цикл
#include <stdio.h>
#include<unistd.h> 


int main () {

   /* local variable definition */
   pid_t pid;
   pid = getpid();
   printf ("pid = %d\n",pid);

   int a = 10;
   /* while loop execution */
   while( a < 20 ) {
   }

   return 0;
}


я запустил а далее

$ cat /proc/25506/stat | awk '{print $14, $15}'
1462 0

получаем что программа крутится на цпу ~15c и да это похоже на правду (засекал с секундомером).

а вот еще чуть позже  я посмотрел статистику для этого процесса
$ cat /proc/25506/stat | awk '{print $14, $15}'
10882 2
$ cat /proc/25506/status | grep swi
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	1246

получается что процесс отработал на цпу ~11c
из них он недобровольно (оно и понятно почему ) был выдавлен с цпу 1246 раз.

это значит что он неработал после этого хотя бы один цикл цпу прежде чем быть назначен обратно
это значит 1246\100 = 1.2с 

ну тоесть процесс отработал на цпу (10882+2) циклов а его выдавили из цпу 1246 раз. тут
конено возникает вопрос сколько времени занимает процесс выдавливания процесса из цпу
потом сколько времени процесс ждал пока его обратно засунуть на цпу потом время которое нужно
чтобы его всякие там регистры засунуть в цпу  это все потеря времени. ну если например предпололо
жить что что каждый раз когда его выдавили из цпу то весь процесс обратного его ожидания и сования
на цпу составил всего один цикл (хотя может и быстрее а может и медленее) тогда получается что 
с того момента как процесс запустили он простаивал 10% времени.

так в /proc/$$/stat  в поле $39  показывается номер ядра на котором раобтает процесс.
я запустил процесс и статистику снова. получил такое. 

~$ while true; do cat /proc/25919/stat | awk '{print $14, $15, $39}'; sleep 1; done
3301 0 1
3401 0 1
3502 0 1
3602 0 1
3703 0 1
3803 0 1
...
8730 0 1
8830 0 1

$ cat /proc/25919/status | grep swi
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	28


тоест процесс выдавливался шедулером 28 раз недобровольно.
но небыло смены цпу все время процесс работал на ядре номер 1.
получется процесс отработал на цпу ~8.8с и был выдавлен 28 раз.
если процесс выдавливания и обратгного размещеия считать занимал 1 цикл (что нефакт что это так по времени может меньше может больше) то получается что (28\8830) ~= 3% процесс простаивал. 
интересно.


далее будет частичное повторение уже сказанного и часть нового. 
про ассемблерную команду nop. которая ничего недалает. влияет ли ее применение на уменьшение  
cpu usage в выводе top. короткий ответ - нет нихрена невлияет вообще.
 если мы в программе разместим цикл с асемблерной
командой NOP которая по факту внутри цпу ничего неделает это нам ничего недаст потому что 
по факту цпу ничего неделает но с точки зрения шедулера код процесса все равно исполняется на цпу
формально команда nop это тоже команда. код неисполняется значит то что на цпу работает код от 
другого процесса а нето что на цпу выполняется NOP от данного процесса. 
как шедулер высчиывает цпу юзэж процесса он считает циклы цпу в течение которого код выполняется
на цпу (можноу ивдеть в procfs) , далее как top высиытает cpu uxsage  - он берет некий интервал. 
смотрит солько это в тиках цпу. а потом делит сколько тиков процесс сидел на цпу на число тиков на 
инетрвале. получем cpu usage %. здесь важно быол понять что из юзерсепейса процесс сам себя в состояние S перевести неможет так как для этого он должен удалить сам себя на какоето время 
из цпу.  насколько я понимаю дажебы если бы процесс мог такое сделать то об этом бы незнало ядро.
тоест скажем процесс некоей конмандй остановил свое выоплолнение на какое то время до момента
насутлпения таймер интеррапт на цпу. но при этом процесс его регистрвы все равно занимают
цпу а сам процесс неможет себя вычистить из цпу. но тем неменее на каком то интервале до настулпния
таймер интеррапт он бы невыполнялся но фишка в том что ядро и щедулер об этом бы незнали 
и  с их точки зрения процесс сидел на цпу все кванты времени поэтому перменые статистики в /pric/pid/ все равно бы были такие что как бутт процесс выполнылся на цпу. поэтмоу такое невозоможно 
через юзер код. а вопзомоно только если попрпоситьоб этом шедулер. тоесть нужно передать управление
шедулеру с прсобой вычистить регистры от этого процесса и загрузить туда другой и обновить
параметры статистикии  в процфс вот только тоггда для ядра процесс рельно неисоплнется на цпу
и его статус будет S. поэтому процесс состоящий из одиеих команд NOP будет выглядеть в 
top как процесс который на 100% жрет цпу. хотя казалось бы он ничего неделаеи. но это он 
неделает по факту. но с точки зреня шедулера на цпу лежат регистры именно нашео процесса,
выполняется порядок команда нашего процесса и другого процесса на цпу нележит в этот квант времени прэтому с тчоки зерения шедулера цпу занят нащим процессом. важно было разсянить этот экспримент.



двигаем дальше перехоим к рассмотрению переменной /proc/21944/syscall.
так как уже было сказано что если статус процесса R тоесть это означает 
что прям щас на цпу выполняется либо код программы (user space) либо код ядра вызыванный
через сисколл (кернел спейс) то нам непонятно нам хочется знать так щас что выполняется
код программы или кернел код. как это узнать. 

узнать это можно если посмотреть что покажет proc/$$/syscall
$ sudo cat /proc/21944/syscall

если там будет слово
running

это значит что на данный момент выполняется юзерский код программы.

strace при этом покажет вот это:
$ sudo strace -p 19356
strace: Process 19356 attached
strace: [ Process PID=19356 runs in x32 mode. ]


а если там будет вот чтото такое
270 0x1 0x7ffce82706c0 0x0 0x0 0x0 0x7ffce82705f0 0x7ffce82705b0 0x7f24978ceec9

тоэто значит что сейчас на цпу выполняется ядерный код вызыванный через сисколл

270 это номер сисколла котоый щас выполняется.
270 это pselect6 (согласно /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h) 

также убедиться в этом же можно если присодиниться к процессу через strace

$ sudo strace -p $PID
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

единственное что мы можем неуспеть то есть пока мы подкючимся процесс будет уже выполнять какото другой код.


а что покажет /proc/21944/syscall если у нас процесс спящий тоесть его статус 'S'\'D'.
отвечаю что он покажет номер сисколл который значит то что до того как процесс впал в спячку
цпу был занят выполнением этого сисколла. более того я утрвеждаю что именно этот сисколл и был
тем кодом который попросил шедулер вогнать процесс в спячку. я там далее ниже показал это 
на примере запущенной команды $ sleep 180

еще хочу добавить про /proc/pid/wchan вроде бы он вцелом показыает тоже самое что и /proc/pid/syscall но я читал  в инете что этот wchan порой показыает хрень так что на него лучше неполагаться.

итак подвеем итоги по /proc/pid/syscall.
если статус процесса "R" и цпу выполняет юзерский код то /proc/pid/syscall покажет "running"
если статус процесса "R" и цпу выполняет кернел код то /proc/pid/syscall покажет номер сискола
который щас исполняется
если статус процесса "S"/"D" то /proc/pid/syscall покажет номер сисколла который выполнялся на цпу
до того как процесс начал спать, более того это имено тот сисколл который попросил шедулер вогнать
процесс в сон, и конечно на данный момент этот сисколл невыполняется на цпу.


далее повтор того что уже сказано и возможно часть нового.
интересенйшая вещь. команда asm nop хотя она по факту ничего неделает на цпу но процес в цикле 
с этой командой будет показывать статуст R 100%. потому что cpu usage в top\proc происходит с той
точки зрения выполнялся ли код на цпу. а такак nop это все равно команда то с точки зрения шедулера
или другими словами ядра - код выполнялся, поэтому небудет нкиких 0% cpu usage. 0% cpu usage возможно толко 
тогда когда код процесса физиечески шедулером неразмещается на цпу. поэтому 
я скажу так что переменстить процсс в состояние S невомозможно без вызовы хоть какого то
сисколла в проетсейшем случае это sleep. нужн какойто ядерный код который соощит шедулеру о том 
что код этого роцеса ненадо пихать на цпу столко то времени либо до настулпнеия такого то события.
опа!!! поэтому можно быть 100% увреным что у всех проецссов в состоянии S в его /proc/$$/syscall 
стоит имя какого нибуль сисколла! именно этот сисколл и сунул процесс в состояние sleep говоря другими словами попросил щедулер исключить процесс из цпу либо на промежуток времени либо до наступления какогто события.

сделаем пример. команда sleep

$ sleep 180
процесс будет в состоянии S в течение 180 секунд.
посмотрим через strace какой сисколл щас она покажет
$ strace ...
...
nanosleep({tv_sec=180, tv_nsec=0}, 

посмотрим какой сисколл указан в /proc/$pid/syscall 
$ sudo cat /proc/29719/syscall
35 0x7fff0baec2f0 0x0 0x0 0x0 0x0 0x0 0x7fff0baec2e8 0x7fba62d9e774

номер 35. 
найдем имя этого сисколла
$ cat /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h | grep 35
#define __NR_nanosleep 35

совпадает с тем что показывает strace.
Получается что имя сисколла который показывает strace и который показывает /proc/$pid/syscall
если статус процесса 'S'\'D' то это не имя сисколла котрый щас выполняется на цпу . нет. это 
имя сисколла который выполнялся последним до того как процесс вошел в состояние 'S'\'D'.
по факту я утверждаю что именно этот сисколл и вогнял процесс в состояние 'S'\'D'.
существенно тут то что сисколл щас невыполняется. нет. он выполнялся до того как процесс вошел в
спящее состояние но щас он невыпоняется. также можно смело утверждать что именно выполнялся сисколл
а не чтото иное до того как процесс вошел в спящее состояние. и еще раз именно указанный сисколл
и вогнал процесс в спящее состояние. естственно не только сисколл 35 умеет вгонять процесс в спящее
состояние. таких сисколлов вагон. важно тут было понять то что значит имя сисколла который мы видим
в /proc/$pid/syscall если статус процесса 'S'\'D'. еще раз смысл найденного сисколла в том что это 
было последнее что выполнял цпу для данного процесса прежде чем процеесс вошел в спящее состояние.
сейчас код процесса ни юзерский ни сисколловый на цпу невыполняется , оно все вытеснено. и то что
именно этот сискоолл и вогнал процесс в спящее состояние.



далее опять повторение того что выше и может быть чуть нового.
nop только на powerconsumption влияет а на статус S и на цпу юзадж
с точки щрения шедулера никак! ведь ядро как определяет cpu usage - по числу таймслайсов в теччение которых код выполнялся\размещался (что одно и тоже) на цпу. пусть даже эта команды nop. nop невозвращает управление шедулеру ядру ОС. это такая же обычная команда как и любая другая. 
просто по факту цпу в это время ничего неделает. но с точки зрения шедулера это абсолютно неважно! вот это я хочу донести. шедулер меряет произвиодительность cpu usage для процессора исходя неиз того какие команды запускает процесс. на это шедулеру насрасть. шедулер меряет количество времени
в течение которого на цпу размещается любой код процесса. вот шедулер поместил код процесса на цпу
на 1 тайм слайс. процесс это время отработал. шедулер вытесняет код процесса (иногда оставляет но это щас неважно для простоты щас считаем что он каждый раз код вытесняет) и ставит себе галочку в 
/proc/pid/stat о том что процесс отработал на цпу +1 тайм слайс. а команда top читает это количество и делит его на три секунды (дефолтовый промежуток обнволения экрана у top). и таким 
макаром в top появляется cpu usage. тоесть в cpu usage играют рояль только тайм слайсы в течение
которых код процесса крутился на цпу. и шедулеру и top абсолютно насрать какой код крутился в те моменты будь это mov или nop или любое другое. поэтому применение циклов с nop никоим образом
неуменьшаем cpu usage для процесса. оно только уменьшает powerconsumption у цпу на которйы нам полностью насрать. единсвенйы вариант уменьшить цпу юзадж это когда наш процесс запустил команду
syscall и начад исполняться ядерный код и этот код сам решает на момент работы в таймслайсе что
уже ему сисколлу ненужен больше цпу либо на какоето время либо до момента наступлениея какогто
события и тогда сисколл обращается к шедулеру и просит его выдавить процесс из остатка таймслайса.
и вот только тогда и только по такой причине процесс на скольо то таймслайсов небудет размещаться 
шедулером на цпу. получется что на какоето время на какоето количество таймслайсов процесс больше
не размещается на цпу. он физически больше неисполняется. и это дает то что в ячейке отображения
статистики в /proc/pid/stat останавливаются поля $14 и $15 и только тогда у нас с точки зрения
top падает cpu usage. потому что если за 3 секунды у нас ненаступило приращение полей 14 и 15
то значит что 
100*[ 0/(100*3) ] = 0%  cpu usage за последние 3 секунды
где 
0 = дельта изменеия $14+$15
100 = число таймслайсов в секунду (сколько раз в секунду вызывается шедулер)
3 = интервал в секундах обновления экрана в top по дефолту

то есть мы делим количество таймслайсов которые процесс отработал за последнеи три секунды
и делим на общее число таймслайсов которые прошли за это время. это и есть как top высчитывает 
колонку %cpu usage. если процесс многотредовый то наверное в /proc/pid/stat поля $14 и $15
отображают суммарную статистику по таймслайсам для всех тредов. отсюда и получает в top цифры такие
как 200% , 400% , 1000% итд.


то как я щас себе это вижу. как процсс может попать на S состтояние.  через юзер спейс команды никак. никак сам себя процесс неможет выдавить из очереди на выполпнение шедулера. чобы это сделать
надо вызывать какойто сисколл который сформирует условие для шедулера\ядра о том что мол пока что 
меня ты с очереди выкинь то наступления некоего события. и только тошгда процесс будет шедудером выкинут из очереди на выполеннеи!

разница S и D тока в том что S разрешает прилет сигнала к процессу. а D нераазрешеает.
а так это оба процесса код которых неразмещен на цпу.

еще раз про voluntary_ctxt_switches, nonvoluntary_ctxt_switches.
оно показывает сколько прям раз код процесса находясь на цпу был выдавлен из цпу , либо добровольно
тоесть когда сисколл сам попросил об шедулер либо принудительно когда у процесса истек таймслайс
сработал таймер интеррапт запустился щедулер на этом цпу и он выдавил этот процесс из цпу.
важно здесь еще раз отметить что это не цисло сколько раз цпу проходясь по очереди runqueue доходил
до этого процесса и проверял мол ставить его на цпу или нет. это совсем нетак. во первых процесс
удаляется из runqueu а во вторых как уже сказал это неколичетсво проверок а реально число случаев
когда код процесса сидел на цпу и он был выгнан выдавлен вычищен из цпу.

на счет шедулера важнйы момент важный вопрос а как он работает в случае когда у нас много цпу в 
системе. вот на одном цпу сработал таймер интеррапт значит на этом цпу будет загружен шедулер 
и запущен. и понятно что на этом цпу шедулер сможет выдавить текущий процесс а что в это время
с другими ядрами? туда тоже шедулер в этот момент загружен или нет или щедулер на этом цпу 
сидя выдавливает процессы с других ядер . нет походу это все нетак. как я щас понимаю
когда сработал таймер интеррапт на текущем ядре и был загружен шедулер на текущее ядро 
то этот шедулер выдавливает процесс с текущего ядра только а другие ядра нетрогаются да и как
он их сможет тронуть если на тех ядрах произошел такойже таймер интеррапт. а это нет!
так что шедулер загружается на данное ядра. выдавливает процесс на данном ядре а на остальных 
ядрах работа в это время идет без изменений. потом на другом ядре происходит таймер 
интеррапт и на том другом ядре происходит индивидуальное выдавливание процесса. и так для каждого
ядра индививидуально согласно его индивидуальному срабатывания таймер интеррапт. других ядер 
это некасается. вот так я думаю работает система шедулинга в случае много ядерной машины.

==

bash, strace, 
fork, clone


поповоду того что баш если запускает команду из файла то он вначале себя 
форкает точнее испольуется сисколл clone() потом запускает execve.
убедимся на примере:

во первых если мы пишем

$ strace ls

то мы неувидим как баш делает fork ( при том что щас как я прочитал линукс неделает форк а
делает вместо него clone) но в любом случае мы это неувидим потому что как я понял strace создает 
из себя грубо говоря клон и в нем запускает уже коману и уже смотрит какие сисколы эта комнда будет
вызывать. а нам же нужно затрейсить наш баш в котором мы сидим  а не сам ls. поэтому нам надо 
отркыть второе окно и в нем запустить strace самого баша тот который  в первом окне через команду

$ sudo strace -f -p 26294   (где 26294 это pid баша из первого окна)
также можно сразу указать какие сисколлы мы хотим отслеживать

$ sudo strace -e clone,fork,execve -f -p 26294

так вот что меня удивляет.
у баш есть встроенные команды тоесть которые у него в его бинарнике /bin/bash зашиты
получается что если мы их будем запускать то башу форкать ничего ненадо. проверяем на while ибо он 
являетс builtin для баша. он встроен в бинарник баша.

(окно1) $ while :;do :; done
(окно2) $ здесь увидим пару ioctl и пару rt_sigaction

окей. все понятно все красиво. все совпадает.

а теперь пробуем команду echo

с одной стороны баш пишет что это его встроеный builtin

$ type echo
echo is a shell builtin

с другой стороны 

$ which echo
/bin/echo

и также через strace видно что запускается некий внешний файл /bin/echo :

$ strace echo $$
clone(..
execve("/bin/echo", ["echo", "26294"], 0x7ffcd2aa8898 /* 70 vars */) = 0

тоесть получается по дефолту баш при команде echo испольщует несвой билтин а внешнюю команду.
потом я приказал башу в явном использовать встроенный echo

(окно1) $ builtin echo $$
и тогда уже все отработало нормльно без clone и execve.

как заставить баш по дфеолту для команды echo исполтзовать свой билтин непонятно.

а вот уже как выглядит запуск ls который уже точно невстроенный

(окно1) $ ls

(окно2) 
$ clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb85ece9490) = 28795
strace: Process 28795 attached
[pid 28795] execve("/bin/ls", ["ls", "--color=auto"], 0x558216669510 /* 71 vars */) = 0
[pid 28795] +++ exited with 0 +++

здесь мы четко видим что при старте внешней команды баш иполтьзует clone+execve

=======

cpu 
power consumption

задача. надо получить сколько ватт жрет цпу.
поможет прога turbostat из пакета linux-common-tools.

$ sudo turbostat --quiet --show PkgWatt
PkgWatt
1.23
1.22

==========
blocked process
наконец нашел что же такое blocked process оказывается = A runnable process is one
that is not blocked; a blocked process is one that is sleeping, waiting for I/O from the
kernel. 
тоесть blocked процесс это процесс в состоянии 'D'

=========
OR и biwise OR (Bitwise inclusive or)

обыкновенный OR (обозначается || ) этот тот у которого на выходые true или false
пример:

2<5 || 5<1 = true

bitwise or (обозначается | ) = это логический OR только для битов, когда мы берем
один байт и второй байт и делаем побитовый OR. резулттатом является набор битов.

9 | 5 =  15

1010
0101
-----
1111
========
processes kill parent child

что было интересно.

вот есть процесс. этот процесс порождает другой процесс.
первый это парент второй это чайлд.

далее что будет если послать kill -15 паренту?  умрет ли автоматом при этом чайлд?

что я высснил на данный момент.
если написать самопимную программу на C которая делает fork() 
то kill -15 парента убивает парент но чайлд спокойно остатется жить дальше.

а вот если в качестве подопытной программы взять bash то тут (видимо в нем прописан
кастомный обработчик сигналов) все идет подругому. посылка kill -15 к паренту неприводит
ни к чему. парент продолжает спокойно жить. я так думаю что в баш прописан кастомный хендлер
для сигнала 15 в котором написано что если у баш есть чилдрены то тогда сигнал 15 парент должен
игнорировать. а вот если паренту послать сигнал -9 то тогда умирает и парен и чайлд.

вот так интересные результаты пока из эксперимнтов
=========
scheduler
run vs runnable

у нас в ps есть статус 'R'
про него написано что это состояние обозначает сразу два типа процессов - run и runnable.
тоесть это значит что либо процесс реально испольняется на цпу либо неисполняется а стоит в
очеред runqueue и ждет когда для него освободится цпу.


вопрос - а можно както узнать так процесс щас реаьно исполняется или он в очереди стоит ?
поиска в инете ответ я увидел что люди такой вопрос задают но ответа нет. так что я пришел к 
выводу что простого решения как это увидеть нет. едиснвенное решение что я видел это наисать ядерный модуль который будет сканировать что-то в ядре и на основе деталей статуса в таблице процессов или еще где то там (тоесть в ядре безусловно есть точная галочка о том что прроцесс щас реально исполняется на цпу или всеже в очереди стоит) получать такую инфо.
итак короткий ответ  - простого способа это узнать нет.

========
ps
FLAGS 1,4

у команды ps есть флаг -l
и в нем есть колонка F

$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000 13908  3866  0  80   0 -  8528 wait   pts/148  00:00:00 bash
4 R  1000 14966 13908  0  80   0 -  9525 -      pts/148  00:00:00 ps

о чем эта колонка? в ней могут быть числа 0,1,4,5.

по факту они описывают два свойства процесса.

флаг 1 =  в мане описывается так "fork but didnt exec". по факту это значит что процесс был получен путем запуска fork() на его родителе (или clone() о чем нет в 
man ps) но потом в этом процессе (который дочка для парента) небыл запущен execve

тоесть еще раз о чем цифра 1 в этой колонке. обычно как в системе получается новый процесс.
есть процесс А он хочет создать новый процесс. как он это делает. он берет и делает fork()
или clone() получаем дочку B. Далее в дочке B запускается execve(). таким образом мы получили новый процесс B в системе.  так вот флаг 1 нам сообщает что процесс B был создан через fork\clone
НО после этого execve небыл использован. когда на практике это может быть. очень просто. когда 
у нас был  к примеру запущен bash и мы в нем запускаем еще один bash. поскольку бинарник у нас
такой же /bin/bash то смысла выполнять execve нет смысла. execve нам нужен если у нового процесса
другой файл бинарника. например парент процесс у нас /bin/bash а из него мы запускаем /bin/ls

флаг 4 = он говорит о том что процесс запущен с правами root. пример

$ sudo bash
$ echo $$
$ ps -Al | grep $$
# ps -Al | grep -E "$$|PID"
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 15102 15101  0  80   0 -  7464 wait   pts/148  00:00:00 bash


флаг 5 = это когда одновременно и флаг 1 и флаг 4.

прикол еще раз скажу в том что ( я проверил на практике)  что флаг 1 у процесса нетолько 
когда был использован fork но и когда clone тоже. тоесть я бы сказал про флаг 1 по другому
неважно форк там или клон или еще что было примеенено у парента. главное что в текущем процессе
небыл применен execve. тоесть это флаг об отсуствии применнеия execve.


флаг 0 = гораздо хитрее что значит 0. 0 значит отсуствие обоих флагов обоих условий но что это значит на практике?
разве это значит что  какойто процесс был получен без применнеия fork\clone ? как такое возмжно? нет!! это значит что процесс был получаем с примененеием fork\clone и далее с помощью execve !!!!!! вот что !!! таким образом можно воббще забыть про эти упоминания форк хуерк он тут неиграет
никакой роли. флаг 0 означает что в текущем процессе был использован execve при его создании
а флаг 1 означает что execve небыл использован . вот и все! это обьяснение гораздо лучше мудацкого
обьяснения из man ps.


что еще интересно: чтобы вызывать clone() (чтобы успешно откомпилирвать файл  на *.c) 
нужно в C программе использовать следующие макросы:

#define _GNU_SOURCE
#include<sched.h> 


где define _GNU_SOURCE совершенно особая штука. (https://stackoverflow.com/questions/5582211/what-does-define-gnu-source-imply)


что еще паралельно интересно. что еси в C программе мы вызываем fork()
то пофакту вызывается сисколл clone() а не форк!!! и strace это показыавет. а дело вот в чем!: дело в том что в C прогармме
кода мы пишем fork() clone() и прочие типа сисколлы на самом деле мы вызываем не сисколлы а функции библиотки
LIBC. а вот уже те функции вызывают чистые сисколлы. так вот  
libc fork() он по факту вызывает  clone() сисколл.
загадка разгадана.  в ядре естественно есть сисколл fork() но чтобы его заюзать 
надо тогда писать программу на асемблере а не на C. еще раз важно понять что в C коде мы вызываем функции библиотек libC
(функции обертки) а не реальные сисколлы ядра. поэтому это еще вопрос какой сисколл ядра юзает 
функция обертка libc.

итак еще раз когда мы в программе на C пишем вызов fork() то fork в данном случае
это не сисколл fork ядра а функция fork LIBC которая в свою очередь обращается к некоторому сисколлу ядра. в случае функции fork LIBC она обращается к сисколлу ядра clone а не к сисколлу fork как это можно было бы ожидать. 

в целом я бы сказал что столбик F имеет мало какого важного значения мало что дает 
интересного полезного. 

=================
zombie

еще раз поговорить про зомби процесс.

как он получается.

вообще это статус процесса. в целом это нормальный статус процесса если он длится недолго.
и ненормально если длится долго.


как он получается. когда в ядро поступает запрос ( неважно откуда от самого процесса, через Ctrl+c, от другого процесса вобщем неважно) на уничтожение этого процесса из системы то 
система вычищает все кишки процесса но остается небольшой хвостик в таблице процессов в ядре
и в частности сохраняется код возврата говорящий о том нормально процесс завершил работу или с ошибкой и ядро далее шлет сигнал парент процессу SIGCHLD который сообщает процессу о том что
состояние дочернего процесса изменилось ( кстати необязательно в сторону что дочерний процесс склеил ласты , также SIGCHLD посылаетя ядром к парент процессу если напримр процесс был останолвен изза сигнала SIGSTP либо продолжил свою работу после сигнала  SIGCONT). Далее ядро вот как подразумевает: в коде программы может быть прописан хендлер обработчик сигнала SIGCHLD если так есть то при старте парент процесса ядро это учтет и зарегистрирует этот обработчик. так вот при в этом случае при поступлении в парент процесс SIGCHLD сигнала шедулер при следующем таймслайсе
запустить этот кастомный обработчик этого сигнала. в целом ос ожидает что в этом обработчике в итоге будет использован libc функция wait (которая в итоге юзает кернел сисколл wait4) и данная функция через сисколл считает код возврата дочернего процесса. как только ядро увидит этот факт 
то ядро считает что вот теперь то дочерний процесс можно полностью уничтожить. значит как только в ядро поступил запрос на удаление процесса и до момента когда парент процесс считает код возврата
дочернего процесса все это время дочерний процесс будет висеть в списке процессов имея статус Z.
так вот когда могут пойти проблемы - кастомный хендлер в парент процессе для сигнала SIGCHLD его нужно написать програмисту тоесть это обязанность создателя программы парент процесса. а если он этого несделает? тогда в строй вступает дефолтовый ядерный обработчик данного сигнала и фишка в том что дефолтовый обработчик по дефолту игнорирует данный сигнал. Поэтому получается что если парент программа неимеет своего кастомного обработчика да еще и правильно написанного ( с использованием libc wait() ) то тогда получается что код возврата от дочернего процесса небудет
прочитан парент процессом никогда. и значит что дочерний процесс будет висеть в статусе Z вечно.
уничтожить его через сигналы невозможно ибо он уже почти уничтожен и болльше его неуничтожить.
итак причина появления Z процессов это остутствие кастом хендлера сигнала SIGCHLD в парент процессе. тоесть нужно парент программу переписывать. правда есть еще такой выход - нужно 
остановить уничтожить парент процесс тогда у дочернего процесса поменяется номер парент процесса 
в лоховской литературе пишут что этим процессом 100% станет сразу процесс с pid=1. но это брехня
как написано в более правльно литература новым парентом станет некий ближайший к дочернему процессу процесс но совсем необязательно что это будет процесс с pid=1
по моей практике парентом станет совсем другой процесс.

пример.

вот у меня есть процесс 22.exe
и вот его дерево от дочернего процесса до его парента а далее парента того парента итп.

~$ pstree  -A  -s  -p 20834
systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(20614)---mc(20742)---bash(20744)---22.exe(20833)---22.exe(20834)

парентом для 20834 является pid=20833

еще раз в этом убедимся

$ ps -o user,pid,ppid,pgrp,sess,stat,cmd -p 20834
USER       PID  PPID  PGRP  SESS STAT CMD
vasya    20834 20833 20833 20744 S+   ./22.exe

уничтожаем парента 20833

$ kill -9 20833

$ ps -o user,pid,ppid,pgrp,sess,stat,cmd -p 20834
USER       PID  PPID  PGRP  SESS STAT CMD
vasya    20834  1718 20833 20744 S    ./22.exe

и мы видим интереснейшую картину что новым парентом стал далеко непроцесс с pid=1 нет.
новым парентом стал pid=1718

об этом редко где пишут.


если мы еще раз посмотрим на исходное дерево родительских отношений для исходного процесса

systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(20614)---mc(20742)---bash(20744)---22.exe(20833)---22.exe(20834)

то мы увидим что новый парент это вверх по цепочке , второй от начала.

вот это очень интересно что новый парент это не pid=1 как пишут во многих книжках.

почему в системе несколько systemd процессов это другой разговор. скажу только что 
systemd(1718) это systemd который запущен в системе вот с таким ключом

/lib/systemd/systemd --user

почему именно на этот процесс из всей цепочки пал выбор для нового парента пока тоже непонятно.

в любом двигаем дальше что это нам теперь дает. дает оно то что если у нового парента есть 
кастомный обработчик сигнала SIGCHLD а у  systemd он однозначно есть то тогда (как я понимаю) 
ядро еще раз направляет сигнал SIGCHLD уже к systemd(1718) и он считывает код возврата дочернего 
процесса и вот вуаля ядро наконец удаляет дочерний процесс (20834) из системы полностью и целиком
и списке процессов исчезает наш Z процесс.

в чем вообще прооблема с этим Z процессом кроме того что непорядок что он виисит в системе.
проблема в общемто только в том что он пока висит в статусе Z то он занимает номер в таблице процессов. на 32-битных ядрах всего был 32768 доступных номеров для процессов так что если 
наразмножится много Z процессов то система исчерпает возможность создавать новые процессы. незнаю
что при этом будет. кернел паник или что.

еще раз скажу что процес в статусе Z он уже непринимает сигналы так что его никаким $ kill -9 невырубить. 

через $ ps такой процесс будет иметь вид как <defunct> например

22.exe <defunct>

насколько я понял самый реальный случай откуда могут вылезат на практике Z процессы
это скажем апач который запускает типа скрипт баша чтоли а в этом скрипте есть скажем строка с grep
типа 

...

cat /....  | grep 

и далее там было написано где я этот пример встречал что апач может по таймауту грохнуть процесс
скрипта а как он его грохает ну конечно же  некоей командой килл и аналогичным сисколлом в итоге
ядро пошлет сигнал -15 процессу со скриптом по хорошему этот процесс со скриптом должен иметь 
хеендлер кастомный для сигнала -15 который убивает все дочерние процессы причем он должен вначале убить все дочерние процессы считать их код возврата и потом только сам закончить свое существование.
на практике наверное этого часто нет. и что в итоге. в итоге процесс со скриптом будет уничтожен
но в системе останется дочерний процесс тот который grep. далее что получается что раньше для 
grep праентом был процесс со скриптом а теперь ( кстати вопрос) парентом станет (наверное) процесс 
с апачем и он ( неужели? ) неиммет обработчика катомного для SIGCHLD сигналов и поэтому процесс с 
grep будет висеть как Z. помне этот пример какойто бред потому что мне кажется что новым парентом будет systemd и он грохнет этот grep без проблем. но даже если новым парентом будет апач то я думаю у него 100% есть свой хендлер для SIGCHLD процессов потому что он же сам порождает чайлдов так что у него просто обязан быть этот хендлер. вобщем вопрос как на живой практике люди ловят
стада Z процессов надо еще выяснить.

================
proc

это файловая система которая позволяет из юзерского пространства получить доступ ( а procfs 
выствпает как шлюз как интерфейс) к kernel data structures.  тоесть можно полазить в ядре
из юзер пространства

===
bash
terminal

(оффтопик что такое командная строка шел. дело в том что есть пробема чтобы запустить программу нужна программа.)

вот такая программа есть

$ cat 31.c
#include<stdlib.h>
#include<stdio.h>
#include<unistd.h>

int main ()
{
 while (1)
 {
 sleep (5);
 };

return 0;
}


она неделает ничего кроме того что просто бесконечно крутится в цикле
никаких сисколлов кроме nanosleep в ней нет.

если мы ее запустим то просто будет пустой экран.
однако на этом экране можно наимать на кнопки и буквы будут отображаться на экране.

вот так:
$ ./31.exe


eqwe
qwe
qwe
	w
	w
	we
	q
ewq
w
r
we
rqw
er
qwer
qwer
w


вопрос - в выводе на экран этих букв какито сисколлы участвуют? как это работает?
выясним это :

в первом окне выясняем pid текущего баща.
(окно1) $ echo $$
30194

во втором окне подключимся через strace к этому башу
(окно2) $ $ sudo strace -f -p 30194
strace: Process 30194 attached


далее в первом окне запускаем нашу программу
(окно1)$ $ ./31.exe

далее возвращаеимся на второе окно и смотрим что там показыает
(окно2): 
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0

и больше ничего. и это реально так потому что наща программа ничего кроме nanosleep неделает.


возврашаеися на первое окно и начинаем тыкать кнопки.на экране появляются буквы
(окно1) $ ./31.exe
wer
ewr
ewr
wer
wer
we
rq
q
r
qer
qer
q
qwr

возврашаемся на второе окно и смотрим появились ли какието сисколлы которые наша програма бы начала юзать (что было бы странно ведь у нас в коде программы нет ничего больше) . или signals которые бы начали прилетать в наш процесс и прерывать его. и видим что ничего нет.
как и прежде на окне2 просто мы видим висящие нанослипы.  отсюда я делаю вывод что прием 
нажатия кнопок с клавы и их печать в окне терминала с моей программой это все вина ядра. это код ядра выполняет. как походу это работает. мы тыкаем кнопку на клаве происходит cpu hardware interrupt. он вызывает перрываение работы моей программы (если комп однопроцессорный)  и запускается ISR (interrupt service routine) котторая код ядра. эта рутина принимает нажатие кнопки 
и далее ( что самое интересное) делает вывод этой литеры на стандартный вывод процесса который крутится в текущем активном терминале. тоесть ядро как букву приняло оно смотрит на данный момент
есть ли активный терминал? есть. а терминала неможет быть без запущенного там хотя бы одного процесса. тогда ядро берет стандартный вывод этого процесса и посылает туда литеру и она появляется
на экране.

щас мы это проверим. запустим программу еще раз и начнем читать из стандартного ввода для начала
нашего процесса. тоесть проверим то что когда мы ввели буквы и ядро их приняло через интеррапт 
то посылает ли ядро эти буквы в стандартный ввод нашего процесса.

значит на первом окне я ввожу символы
(окно1) $ ./31.exe
qeqwewqeqeqweqweqwe
9123879283791839137912731

на втором окне я вижу !
(окно2) $ while :; do cat /proc/25418/fd/0; done
qeqwewqeqeqweqweqwe
9123879283791839137912731


рабтает это так. пока я просто ввожу символы в fd/0 ничего неприходит. но как только 
я нажимаю Enter то сразу прилетает строка в fd/0 

тоесть схема работает так: вот у нас открыт терминал на компе и там крутится процесс ( потому что 
открыть терминал и чтоб там ниодин процесс некрутился невозможно). так вот прием символов с клавы 
и печать их на экране терминала работает автоматичеки в линуксе без участия программы которая крутится в терминале вообще!

даже еще интереснее. я заупстил процесс и всего каналы 0 (который кстаи только на примем)
1 и 2 ( которые на вывод) направил на /dev/null

$ ./31.exe 0</dev/null 1>/dev/null 2>/dev/null

проеряем:
$ ls -1al /proc/25816/fd
total 0
lr-x------ 1 vasya vasya 64 мая 30 16:35 0 -> /dev/null
l-wx------ 1 vasya vasya 64 мая 30 16:35 1 -> /dev/null
l-wx------ 1 vasya vasya 64 мая 30 16:35 2 -> /dev/null

далее я тцкаю кнопки на экране
$ ./31.exe 0</dev/null 1>/dev/null 2>/dev/null
wqe
qwe
qwe
qw
e
qwe
qwe
qw
e

и они отображаются.
соответсвенно так как у процесса все каналы /dev/null то прием и отображение кнопок 
на экане никак несвязано нис процессом ни с его каналами. это все чисто автономная система от процеса и раотает исключиеотно через код ядра. и вобще то логично! - терминал это как жесткий диск
это уже как бы реальная железка (просто она виртуальная . это как виртуальный диск) вобщем
окно терминала это для линукса реальная железка а примом инфо от железки и отправкой байтов на реальную желеку делает ТОЛЬКО код ядра. (так же как чтение в файл на диске например делает толкьо код ядра а программа может лишь об этом просит ядро)тоеть в случае диска картина


программа write() --(просьба о записи)-----> код ядра ---(реальная запись на железку)---> файл на диске
программа read()  --(просьба о чтении)-----> код ядра <--(реальное чтение с железки)---- файл на диске

тоже самое для терминала. ксатти вспомниает что терминал железный это нетолько экран это еще и клава. такчто терминал = окно+клава
значит терминал это такая железка которая как бы в своем лице имеет два порта , один порт на прием
информации из мира и второй порт на отсылку информации в мир. как например сетевая карта.
и задача ядра в том чтобы принимать из принимающего порта когда туда чтото приходит и отправлять
в отправляющий порт когда туда юзерская программа хочет чтото записать. вот что такое терминал как железка с точки зрения ядра.  получается что терминал как бы имеет минимум один хардвейр интеррапт
означающий что на принимающий порт поступил пакет ( с клавы пришло нажатие). и ядро должно это 
нажатие обработать тоесть принять этот байт (нажатие) внутрь себя как сетевая карта принимает пакет снаружи и ядро его забирает внутрь.

получается тогда работает так:  у нас активен терминал. ядро это знает. (незнаю как но ядро это знает). мы тыкаем на клаве кнопку. происходит hardware interrupt посколку клава это железка и она точно имеет линию interrupt. срабатывает цпу интеррапт , цпу запускает ISR(который код ядра).
этот isr считывает нажатие в форме байта типа того и этот байт улетает куда то там в ядро в какйото буфер. (заметим что участия кода процесса нет здесь вообще и дальше его небудет).
что делать дальше с этим байтом с клавы ядру? ядро видит что на данный момент окно терминала активно. значит это как бы означает что сигнал с клавы прилетел как бы с клавы этого виртуального терминала (потому что если активного терминала открытого нет на экране а напримр просто есть пустой рабочий стол Cinnamon то ядро также принимает нажатия с кнопок c клавы тоесть ничего неменятеся но при этом ничего непроисходит потому что к виртуальному терминалу к его виртуальной клаве это событие неимеет никаого отошения). Так вот ядро понимает что это нажатие клавы его нужно соотнести с терминалом открытым. так что же делать? нужно делать то что указано в модуле\драйвере терминала. если бы терминал был реаьным физичеким устройством то нажатие клавы железного терминала всегды бы поступало в ядро и обрабатывалось бы драйвером железного терминала вот что там в драйвере было бы написано то бы ядро с нажатием кнопки и делало бы. так как у нас терминал виртуальный то нажатие кнопки в термиале просходит только тогда когда окно терминала открыто на столе и активно. это логично. окей окно терминала открыто на столе . мы нажали кнопку на клаве.
ядро считало байт. и оно отправило этот байт ну вот туда -  в драйвер виртуального терминала.
и драйвер вирт терминала так настроен что он выводит этот байт на экран терминала в форме литеры.
выводит чисто через ядерный код тоесть его работа нам вообще невидна. к коду процесса это неимеет 
никакого значения. если бы можно было бы иметь запущенный терминал без единого процесса то 
все работало бы точно также. мы жали бы кнопки и на экране появлялись бы буквы. я бы сказал что ситема раотает так . сигнал с клавы счиывает ядро по цпу интерапту и посылает в драйвер терминала.
если бы это был реальный железный терминал то я считаю что это работало бы так : нажали кнопку
сработал цпу интеррапт и ядро приняло через ISR байт через порт терминала который принимает 
сигналы с внешнего мира. далее драйвер терминала обрабатывает этот байт и ядро отправляет в порт 
записи терминала литеру и эта литера отображается на термиале на его окне.тоесть между 
вводом буквы с клавы и выводом на экран находится ядро которое принимает байт с одного порта
и послыает байт на другой порт

нажатие клавы запись в порт1--->  ISR(ядро) чтение из порта1 в буфер--> драйвер терминала(ядро) забирает из буфера к себе , обрабатывает и пишет в порт2 терминала --->  терминал читает из порта2 и рисует на экране литеру.

возможно железные термиыл были сделаны так что при нажатии на кнопку происходила запись в порт 
тоесть отсылка байта в удаленную систему и автоматическая (реализованная на уровне железа терминала) печать символа на экране ,таким образом линуксу на той стороне ненужно было писать в порт2 для того чтобы символ напечатался на экране.


итак еще раз открыто у нас окно терминала. мы нажали кнопку. кнопка на клаве. клава это железка.
железка иммеет линию интерапта к цпу. железка запускает интерапт. цпу прерывается и запускает
ISR (котоырй код ядра). ISR считывает байт из железки и передает его драйверу терминала (тоже код ядра)  (если окно терминала неактивно то считанный байт непердается драйверу терминала ибо данное нажатие кнопки неоотносится  к терминалу). драйвер терминала рисует на экране литеру. таким образом мы видим что принятие кнопок с клавы и рисование букв на терминале это процесс сугубо общение железки и ядра. процесс его код вообще здесь ни капли неучаствует. 
а когда же на сцену вылезает процесс ? а вот когда и как. когда мы открывает терминал
то драйвер терминала создает в системе устройство /dev/tty1 или /dev/pts1 неважно. будем для 
простоты считать что это одно и тоже. так вот процесс который запущен в линуксе и который запущен в терминале для этого процесса ядро автоматом создает\открывает три файловых дескриптора.
что нам дает если у процесса есть открытый файловый дескриптор ( причем при его открытии можно указать он для чтения для записи или для и того и другого). это дает то что из кода программы
мы можем через сисколлы read() write() мы можем писать и читать из этих файлов. тоесть для процесса
это каналы общения  с внешним миром на чтение данных и запись данных. бекендом файлового дескриптора может быть любая железка - жесткий диск, флэшка, звуковая карта, мышка, терминал(клава +окно), сетевая карта, модем. процессу вообще невидно и непонятно с каким железым утсройством он связан. для процесса это все неизвестно и прозрачно. для него это просто открытый поток\файл в который можно пиисать байты или читать байты. ( еще раз важно понять что терминал это прежде всего железка с портами на запись и чтение . с линиями интерраптов. такое же как у сетевой карты или звуковой карты. просто так совпало что что природа человеческая нечуствует неосязает интерфейсы жесктого диска или сетевой карты но мы способы взаимодействовать и осязать интефейсы терминала. пальцами мы взаимодейтвуем с кнопками а глазами  с экраном. у звуковой карты мы осязаем звук. звук у звуковой карты это как экран у терминала. с точки же зрения ядра это железки у которых есть порты на чтение и запись. а уже железка нам дает возможрость конвертировать байты от ядра прилетеврие в порт записи в звуки или картинку или нажатие кнопок от человека в байты для ядра котоыре к ядру летят через порт записи на терминале).  итак если есть процесс ядро может сделать автоматом а можно через сисколлы в программе открыть файл на чтение запись (канал связи) у котрого бекендом будет какая то железка. так вот можно открыть файл дескриптор куда процесс может писать и читать бекендом которого файла является /dev/tty1 тоесть железка терминал. так же как в команде 
dd мы юзаем файл /dev/hda для чтени запииси в железку жесткий диск.
что такое /dev/ папка. это такие файлы в юзер спейсе куда юзеркие программы открыв дескриптор
могут начать чиатть и писать. это такой слой виртуализации такой гейт между юзерской программой
 и железкой. тоеть /dev/hda или /dev/tty1 абстраигирует железку от юзерской программы.

 и тогда если программа пишет в дескриптор 1 и ( который она до этого окрыла через сисколл )
а у этого дескриптора бекендом является /dev/tty1 то байты из программы летят в /dev/tty1
и что дальше? то что летят они пока что в ядро  а не в железку. в специальный буфер.
далее в ядре вступает в действие драйвер данной железки он видит поступление данных в буфер
и уже начинает делать реальную подготовку обработку и low-level отсылку этих данных на уже непосредественно железку выполня всякие там хитрые low-level команды и действия которые нужно сделать чтобы этот поток данных реально засунуть на железку. фишка тут в чатности в том что 
для программы все универсально и легко.  ей похеру куда она пишет - в звуковую карту, в сетевую ли карту, в терминал, в жесткий диск ли. для программы это выглядит всегда одинаково исползуется единый универсальный сисколл вызов.
 write (1, .....)

а уже ос, ядро, драйвер ядра делает всю конкретную low-level работу.  это очень круто с точки 
зрения написания юзер программ. этакий слой софт виртуализации.

тоесть схема такая

процесс (юзер код) ----- сисколл write(1,....) ---> ядро драйвер ---- low-level железка dependent код ----> реальная железка 

где 1 --символическая ссылка на --- /dev/tty1

таким образом кстати вот эти /dev/ файлы это не то что прямое окно к железке. нет.  это входной
гейт в буфер на чтение и\или запист потока байтов  за которым прикреплен драйвер. 
а уже драйвер этот поток каким то образом несет или ненесет реально до железки.
юзерская программа как бы это баально незвучала прямого доступа в обход ядра не имеет до реальных
железок. всегда ядро стоит как посредник как от программы до железки так и от железки до программы

программа <---> ядро <---> железка

и так всегда.

получается ядро оно с одной стоороны выполняет роль секьюрити то есть дает доступ недает итп.
и с другой стороны являюется виртуализирующим слоем типа API скрывая всю low-level конкретику 
общение с железкой и предоставляя юзерской программе некие генерализованные функции\точки\команды
по общению с железкой. 
тоесть вот у на 100 видов сетевых карт. записать в сетевую карту байт для программы всегда будет 
выглядеть едино: условно write(1,.......) а уже ос ядро будет выполнять всю ту сложную работу  
с low level командами асемблера скажем по записи байта в сетевую карту.

возвращаемся к процессу и терминалу.
значит открыли мы терминал. ядро драйвер вирт терминала создает в /dev/ устройство /dev/pts/16 или /dev/tty1 предоставляющее гейт для доступа юзерским программам  к этой железку.
внезависимости от процесса  ядро чеерз драйвер принимает нажатие кнопок от клавы когда 
термиал активен и ядро автоматом рисует в окне терминала принятые с клавы кнопки. и при этом происходит еще один очень важный штук. когда мы нажали кнопку и драйвер терминала ее принял
то помимо отрисовки этой литеры на экране драйвер терминала делает еще одну очень важную вещь
он записывает этот байт в /dev/pts/16 в файл который отвечает за терминал в юзерском пространстве.
зачем он это делает. а делает он это затем чтобы нажатие кнопки поступило нетолько в ядро но и было  продублировано и стало доступным юзерской программе. так как юзерская программа может 
читать из файла /dev/pts/16 . тоесть до этого мы видели исключетельно общение ядра и железки в обе стороны а юзерской программе было непрорваться к железке. и вот наконец ядро смилостивилось и 
получив байт с кнопки оно нетольько  свои дела делает (рисует литеру на экране) но и через файл
доступный для юзер спеейса дублирует туда это байт. 

схема
																																						код ядра отрисовка литеры в окне терм
                                                                           /
кнопка клавы при открытом терминале нажали  -----> ядро --> драйвер ядра->/
 																																				  \
 																																				 	 \ядро запись в /dev/pts


и далее

программа <---- read(0,...) --- /dev/pts

таким образом мы видим каким же образом у процесса юзерского появляется
возможность тоже получит доступ к байту с кнопки железной клавы.
только из за того что ядро кладет полученный им непосредственно с железки байт
в доступный для юзера файл.

также видно что отрисовка на экране идет автономно от 
файлов /dev/pts.  

как же программе считывать с /dev/pts ?
а вот как. программа вначале делает сисколл на открытие файла.

fp = fopen ("/dev/pts/4", "w+");

далее в fp ос возврашает дескриптор. (0,1, 2, итп)

и потом имея этот дескриптор можно через сисколл писать туда

fprintf(fp, "%s %s %s %d", "We", "are", "in", 2012);

также через write(0,....)
насколько я даже щас понимаю что скорей всего fprintf это libc wrapper для сисколла write()


таким образом любой процесс если откроет /dev/pts/4 
может туда писать. при этом в /proc/pid/fd  у процесса будет появлсяться файловй дескпритор
с бекендом /dev/pts/4
если у процесса есть файовй дескриптор  у которого на бекенде файл овтечающий за терминал железку
/dev/tty или /dev/pts то говорят что процесс работает в термиале или прикреплен к терминалу.
вот что значат эти загаочные слова работае в терминале прикреплен к терминалу. всео навсего 
то что процесс открыл файл на чтение запись бекендом которого явлется железка терминал.
таким же макаром если процесс пишет щас на жеткий диск то мжоно говорить что процесс прикреплен к
 жесктому диску или проесс работе в диске. но конечно загадрчнее и понтовее гвоорить что процесс
 работает в терминале или прикрелеен к терминалу.
 процесс работает на цпу вот где он работает. а в терминал железку он пишет или читает. вот иввсе
 вот и весь выебон и понты наведенные вокруг этого.  причем сам процесс и незнает куда он пишет
 на жесктйий диск в звуковую карту или в терминал потому что для процесса это все абстрагировано
 через единую форму

 fprintf(fp, "%s %s %s %d", "We", "are", "in", 2012);

 в любой момент процесс может закрыть этот дескриптор и открыть заново.

 причем по факту процесс всего навсего пишет в файл. и только то. а уже драйвер этого спец файла 
 из /dev/каталога реально пишет или читает с устройства.

 так что в терминале реально работает толкьо ядро. но никак не процесс. ха-ха-ха.

 поэтму становистя понятна наша исходная кратинка
о том что мы запустоли программу которая вообще никак неослуиживает ни клаву ни экран.
 а при этом у нас работает печат букв на экране терминала. 

 $ ./31.exe
wer
ewr
ewr
wer
wer
we
rq
q
r
qer
qer
q


процесс к появлению букв на экране и к приему кнопок с клавы неимеет никакого отношения.!
это все делае автономно ядро драйвер терминала.

все что происходит с процессом при команде  $ ./31.exe то что связано с терминалом это всего
навсего вот что:

ядро автоматом открывает три файла для процесса когда оно его создает
/proc/pid/fd/0 --> /dev/pts/4
/proc/pid/fd/1 --> /dev/pts/4
/proc/pid/fd/2 --> /dev/pts/4

вот это все что связывает процесс с терминалом. всего навсего ядро автоматом 
открывает три файла с бекендом на /dev/pts/4.  любой процесс после запуска при своем 
желании может это сделать и сам самостоятельно! ничего тут такого особого нету!
тоесть можно запустить программу и не в окне этого терминала ( например в окне терминала /dev/tty1) и при этом открыть файлы с бекендом на /dev/pts/4
что это даст? это даст то что когда мы будем сидеть в терминале /dev/pts/4 и нажимать кнопки
то процесс запущенный в /dev/tty1 будет принимать эти нажатия кнопок.

пример:

вот у нас открыт терминал /dev/pts/4

(окно 1)$ tty
/dev/pts/4


мы запускаем программу которая никак с чтением с кнопок неработает. просто пустой цикл while
и мы вводим в терминале буквы "wer"
(окно 1)$ ./31.exe
wer

а в другом окне другом терминале мы зарнее запускаем другой процесс который читает /dev/pts/4 
тоесть тот файл в который ядро дублирует нажатие кнопок с клавы и откуда уже может чиатть любая желающая программа

$ cat  /dev/pts/4
wer


и вуаля мы видим что в первом окне мы ввели wer и их отрисовало само ядро. без участия 
юзерской программы 31.exe

а во втором окне мы тоже видим wer который считала наша юзеркая программа которая незапущена в 
окне терминала (окно1) прочитала из /dev/pts/4 куда ядро кладет нажатия кнопок с клавиуатуры
терминала (окно1). 

вопрос а если десят процессов поставить читать из /dev/pts/4 то как оно будет ? какой процесс будет
получать нажатия кнопок? ответ - они все будут конкурировать. и рандомно то один процесс
будет показыват нажатую кнопку то другой процесс то третий. ибо как это будет работьа


команда cat  /dev/pts/4; 

если через strace помсмотеть она исполтзует read() сисколл.
если мы запустим в неколльких онках этот cat то рандомно то в одном окне то вдругом
(они будут конкурирова)  будет повявятся то что я буду печаать в окне1.
я проерил так и есть.

(забавно что можно открыть на чтение файл сразу нескольким процессам. а с другой стороны а почему
бы и нет).

так вот получается еси мы заупстили программу в окне терминала она ничего не лучше
других программ которые небыли запущенв в терминале в плане возможнсотй чиатть с этого терминала
и писат в этот терминал! единвтеное это то что ядро при создании процесса заупденного в окне 
этого терминала автоматом откроет три дескпритора от данного терминала. так что коду проесса этого длеать самому руками ненужно вот и все. но процесс незпуеннй в терминале может это сделать точно также только руками. вот ивсе.  а дальше процесс если хочет то он читает пищет в дескприорторы а если нехочет то и непишет. вот и все.! ну и еще такой момент что еси мы в терминале жмем Ctrl+C
то ядро шлет SIGINT процессу который был открыт в терминале ( вопрос как ядро отличает какой процесс было запущен в этом терминале а какой небыло а простооткрыл руками дескприоры темринала?)

так что теперь мы четко поняли. терминал это штука сама по себе. а процесс эта щтука сама по себе.
 и единсвтенное что меду ними может быть тонкий мостик  через /dev/pts и ядро между ними.
 а так это абсолютно разделенные сущности. а не какието неразделимые сиамские близнецы. нет такого 
 что процесс прям приращен к терминалу. такго нет вообще. 

 темринал живет сам по себе его обеспечивает и с ним напрямую говорит только ядро. 
 а процесс находится совершенно далеко в другой корзине.   и между етрминалом и процессом есть 
 тонкий телефонный мостик это ядро и файлик /dev/pts/4
 по факту с точки зрения программы ее связывает с терминалом только файлик (чтение запись) /dev/pts/4 это тоже само что любого человека свзыввает с магазином в америке только то что в телефоне
 человека есть номер этого магазина по которому можно позвонить. а когда процесс запускается
 в окне терминала это как то что ядро у человека телефоне при покупке телефона автомтом а адреной
 книжке записало номер этого магазина. вот и вся связь между магазином в америке и человеком на в африке.

 еще раз про то как происходит печать на окне терминала.
 если ядро хочет там печатать то оно печатает через свой код драйвер терминала.
 если процесс хочет печатать на окне терминала это это тоже самое если процесс хочет писать на диск
 тоесть сам процесс никапли это неможет делать. он должео поросить ядро  а оно уже может быть
 это сделает. как попросить - процесс должен сделать запись в /dev/pts/4
 тогда ядро его дравер терминала возьмет этот поток байтов из буфера и уже сделает low level 
 работу и дейсвительно пошлет на терминал и напечатает. когда самое ядро по своему желанию 
 печатает на терминале например в случае убианеим пороцесса по SEGFAULT то ядро непишет в /dev/pts/4 для этого. ему это ненадо. /dev/pts/4 это гейт для запроосов от юзерских порграмм.
 само ядро пишет на термиал напрямую. /dev/pts в этом вобще нучаствует когда ядро пишет на терминал.

 далее еще нюанс. команда cat читает из файла терминала через сисколл read()
проверяется легко
$ strace cat


 в чем его нюанс в  том что пока мы ненажали на enter в окне терминала в cat ничего неприлетит.
 так раотае сисколл read походу

 а вот bash читает из файла термиала через ддругой сисколл pselect6()
 это дает то что баш видиит получает в свои недра уже отдельный символ и нажатия на enter 
 уже абсолютно ненадо. 

 к чему это ведет. к  очен иенересуному результату.

 (окно1)$ tty
 /dev/pts/16

значит в окне 1 запущен bash который все время работает в pselect6()

 (окно2) cat /dev/pts/16

 тоесть во втором окне мы как и раньше воруем то что вводится с клавы в окне 1.
 так вот что непонятно.
 я сижу в окне 1 и ввожу на клаве (без enter)
 1234567890

 при этом в окне 1 непоявляется ни одна цифра кроме последней 0
  а все прердыдущие появляюстя в окне2
  тоесть

  (окно 1) $ 0

  (окно 2) $ $ cat /dev/pts/16
123456789

во первых уменя вопрос почему раньше нам нужно было в окне 1 вводить enter чтобы цифры появились в окне 2 а щас этого делать ненадо. а во вторых самое интереное почему  у нас в окне 1 нет цифр 123456789 если за их отображение отвечает ядро а не баш процесс?
( также упомояну по ходу что в ядре есть два селекта select и pselect6)

мне в этой истории непонтно почему кнопка нажимаемая а окне1 неотображается в окне1
то что она воруется на окно2 это окей (хотя и без enter) а вот почему она неотображатеся
в окне1 непойму. есть пока только одно предположение что баш юзает сисколл 

pselect6(1, [0], NULL, NULL, NULL, {[], 8}

который каким то образом влияет на драйвет терминала? по мне это херня вобщето.
хотя сисколл pselect6 это тоже ядерный код  как и драйвер терминала но он же всего навсего
работает с ... файловым дескриптором... кхмм... ну незнаю.. 

еще какой эксмеримент я сделал. 
язапустил баш вместе с strace в окне1 и начал нажимать кнопки.
четко видно вот что 

вот запустил баш. на экране такое окно1:

(окно1)$ 
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

начинаю нажтмать кнопки
если кнопка непрошла. если ее "перехватил" процесс в окне 2 то на окне1 ничего непросходит.
(что меня и непонятка вызывает).

а если кнопка прошла то мы видим в окне1:

(окно1)$
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, 

если еще одна конопка прошла то видим в окне1

(окно1)$
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, "1", 1)                         = 1
select(1, [0], NULL, [0], {tv_sec=0, tv_usec=0}) = 0 (Timeout)
write(2, "1", 11)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

а вот как выглядит стрейс баща коода мы неворумем символы из окна2

(окно1) $
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, "1", 1)                         = 1
select(1, [0], NULL, [0], {tv_sec=0, tv_usec=0}) = 0 (Timeout)
write(2, "1", 11)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {[], 8}


вроде вывод тот же самый. просто во втом случае движуха по сисколлам иидет при каждом
нажатии кнопки. а впервом случае жмеш кнопки а на экране ничего неменяте ся в плане 
сисколлов.

еще меня смущает что читается один байт
read(0, "1", 1)

а пишетс очемуто бащем 11 байт
write(2, "1", 11)
зачем 11 почему 11?

причемя я проверил уб баша все три канала 0 1 2 ведут на один бекенд

 0 -> /dev/pts/16
 1 -> /dev/pts/16
 2 -> /dev/pts/16

такое ощущение что когда бащ стартует то он (хотя звучит как бред)то он просит драйвер 
терминала невыводить автоматом нажатые кнопки на окно терминала.  а делает это сам 
при условии что он (баш процесс) считал этот символ из /dev/pts/
тоесть да вот реально. как бутто бащ кода стартует то он просит драйвер терминала
не дублировать принятые символы автоматом на экран. мол бащ будет сам этим заниматься.

кхм...
кстати там же есть драйвер терминала а есть типа тип терминала который исользуется прям щас в
этом окне терминала
$ echo $TERM
xterm-256color

вобще по терминалам нужно читать Digital VT220 Programmer Reference Manual - VT100.net
кстаи я думал что линукс драйвер терминала эмулирует vt200 а окаызется vt100,

так вот там я нашел такую штуку:

4.6.5 Send/Receive Mode (SRM)
Send/receive mode turns local echo on or off. When send/receive mode is reset (local echo on), every character sent from the keyboard automatically appears on the screen. Therefore, the host does not have to send (echo) the character back to the terminal display. When send/receive mode is set (local echo off), the terminal only sends characters to the application. The host must echo the characters back to the screen.

You can set or reset send/receive mode as follows.

Mode	Sequence	Action
Set	
9/11 3/1  3/2 6/8
CSI   1    2   h
Turns off (disables) local echo. When the terminal sends characters to the host, the host must echo characters back to the screen.
Reset	
9/11 3/1  3/2 6/12 
CSI   1    2   l
Turns on (enables) local echo. When the terminal sends characters, the characters are automatically sent to the screen.

тоесть терминал может автоматом рисовать на экране символ который мы послаи с клавы а может и нет.
что значит эти загадочные сиквенсы я незнаю но я нашел как бурать local echo 
другим способом

$ stty -echo

тогда да. все что пеаатаешь  - ничего на экране непоявляется. но по факту баш его видит. 
так вот предположение может баш при старте делает какито особые натройки текущего экрана 
терминала... тоесть

вот я сдеал 
$strace stty -echo
ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0
ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {B38400 opost isig icanon -echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon -echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon -echo ...}) = 0

тоесть походу через ioctl можно 
что такое ioctl это такой сисколл через который юзер программа может послать параметры на железку
(через ядро конечно) который специфичны для данной железки и которые нельзя послать другими обычными сисколлами. тоесть этим сиколом можно как бы лазить под капотом в конкретной железке
через юзерскую программу.

итак ioctl позволяет считывать настройки терминала тоесть линукс термина драйвера
и также подкручивать их. возмжоно вэтом и есть секрет.
баш старует . через ioctl подкручивает насйтроки текущего термиала  и поэтому мы видим такое 
повдеение.

через libc ioctl_tty wrapper 
можно указывая наш /dev/tty1 устройство можно у него подкручитваь его найтсройки. тоесть 
как я понимаю ядро кога создаем новый терминал то его свойтсва как железного устрйоства ядро
подкручитвает по дефолту. а мы можем через ioctl указывая /dev/tty1 подкручивать в нашу сторону.

получается через read() write() можно делть общие оперции с устройсвами в виде файлов
а с помощью ioctl() можно делать спеицифичекие для данной железки операции. тоесть ели бы мы работали с принтером. то read() write() это общие сисколлы для всех принтеров для общих оперции
чтени записи а ioctl можно былло бы юзать из юзеркой процеграммы чтобы делать настйроки принтера.
типа того. тоже самое для терминалов. таким макаром через ioctl можно подкручиват драйвер терминала
в ядре для конкретного нашего открытого окна терминала. вот походу баш это активно и делает при старте.

попробуем для начла считать настройки терминала через ioctl_tty

$ cat 42.c
#include <stdio.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <fcntl.h> // for open
#include <unistd.h> // for close
       int
       main(void)
       {
           int fd;
           struct termios tio2;

           fd = open("/dev/pts/16", O_RDONLY);
           ioctl(fd, TCGETS, &tio2);
           close (fd);
       }



 $ strace ./42.exe
 ioctl(3, TCGETS, {B38400 opost isig -icanon -echo ...}) = 0

отработала успешно. 

 что такое struct termios в коде 42.c

 смотрим

 $ cat /usr/include/bits/termios.h | grep struct -A 20
struct termios
  {
    tcflag_t c_iflag;		/* input mode flags */
    tcflag_t c_oflag;		/* output mode flags */
    tcflag_t c_cflag;		/* control mode flags */
    tcflag_t c_lflag;		/* local mode flags */
    cc_t c_line;			/* line discipline */
    cc_t c_cc[NCCS];		/* control characters */
    speed_t c_ispeed;		/* input speed */
    speed_t c_ospeed;		/* output speed */
#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
  };


еще смотрим
$ man termios 


ухты !!!!! получается  я напоролся еще на одну БОЛЬШУЮ тему (помимо signals , interrupts итп) - а именно драйвер терминала!  в книжке по libc это глава 17 - Low-Level Terminal Interface.


A struct termios records all the I/O attributes of a terminal.


вот такую программу частично я взял с сайта IBM

$ cat 43.c
#define _POSIX_SOURCE
#include <termios.h>
#include <stdio.h>
#include <unistd.h>

int main(void) {
  struct termios term;

  if (tcgetattr(STDIN_FILENO, &term) != 0)
    perror("tcgetatt() error");
  else {
    if (term.c_iflag & BRKINT)
      puts("BRKINT is set");
    else
      puts("BRKINT is not set");
    if (term.c_cflag & PARODD)
      puts("Odd parity is used");
    else
      puts("Even parity is used");
    if (term.c_lflag & ECHO)
      puts("ECHO is set");
    else
      puts("ECHO is not set");

    if (term.c_lflag & INPCK)
      puts("INPCK is set");
    else
      puts("INPCK is not set");

    if (term.c_lflag & IGNBRK)
      puts("IGNBRK is set");
    else
      puts("IGNBRK is not set");




    printf("The end-of-file character is x'%02x'\n",
term.c_cc[VEOF]);
  }
}

выволд на экран:
BRKINT is not set
Even parity is used
ECHO is set
INPCK is set
IGNBRK is set
The end-of-file character is x'04'

интересно..

(офф топик)
про puts и printf.  в чем разница. printf понимает символы форматирования а puts типа более простая
программа которая их непонимает. плюс puts в том что если мы незнаем будет ли у нас в переменной
символы форматирования то безопаснее юзать puts. примерно так судя по стековерфлоу.

из man puts:
 int puts(const char *s);
из man 3 printf:
 int printf(const char *format, ...);

еще полезняшка можно используя gcc получать нетолько .exe бинарник но и файл с ассемблером
чтобы недизассмблировать пример

$ gcc -o printf.exe printf.c -save-temps -masm=intel
тогда файл с кодом асемблера будет храниться в 
$ cat ./printf.s

еще момент. 
переменные в теле функции по крайней мере часть из них она размещается в стеке.
когда идет выход из функции то доступ к локальным переменным функции теряется. кактотак.
потому что все что в стеке то живет дышет меняется и движется.

(конец оффтопик)



а вот что делает баш при старте с настройками терминала. 
я использовал в strace флаг -v и смогу увидеть ioctk строки целиком необрезанные

$ strace  -v -e clone,ioctl bash

ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(2, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCGPGRP, [8315])           = 0
ioctl(255, TIOCSPGRP, [8317])           = 0
ioctl(255, TIOCGPGRP, [8317])           = 0
ioctl(255, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f07117c4490) = 8318
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=8318, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f07117c4490) = 8323
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=8323, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
ioctl(1, TCGETS, 0x7ffd59701040)        = -1 ENOTTY (Inappropriate ioctl for device)
ioctl(2, TCGETS, 0x7ffd59700fb0)        = -1 ENOTTY (Inappropriate ioctl for device)
ioctl(255, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCSPGRP, [8317])           = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0
ioctl(0, TCGETS, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


ксати видно что баш при старте еще создает парочку детей которые потом подыхают.

из man ioctl_tty вижу что

 TCGETS    struct termios *argp
              Equivalent to tcgetattr(fd, argp).
              Get the current serial port settings.


таким образом строки с TCGETS они нас неинеретсуют  ибо нас инерсуют строки которые меняют
дефолтовые настройки терминала.

тогда остаются строки

ioctl(255, TIOCGPGRP, [8463])           = 0
ioctl(255, TIOCSPGRP, [8465])           = 0
ioctl(255, TIOCGPGRP, [8465])           = 0

ioctl(255, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0

ioctl(255, TIOCSPGRP, [8465])           = 0

ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0

ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


причем я думаю что реально значение имеет последняя которая с SNDCTL_TMR_STOP or TCSETSW

сравним ее с теми анстройками которе есть изнаально утерминала

ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0

итак было:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

стало:
{c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}

разница реально есть.


сравним что делает xterm+./31-1.exe(самописная програма которая ничего неделает) при старте. видно что xterm  вызов SNDCTL_TMR_STOP or TCSETSW неиспольует (как баш)
и в итоге у терминала настройки выглядят так:

{c_iflags=0x500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

сравним с дефолтовыми

{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

они почти неотличаются. только вот этим флагом - c_iflags

так что я пока вот думаю что тот факт то когда мы запускаем хоть гном-терминал + 31-1.exe хоть xterm+31-1.exe потом мы ее стопим через -19 сигнал и при этом буквы на экране попрежнему можно вводить они работают.
а вот если мы берем баш и запускаем хоть bash хоть в xterm хоть в gnome-terminal то стоит 
нам баш застопить через -19 сигнал и уже нажатие кнопок непечатает на экране. тоесть как бутто получается что гажатие кнопок на экране обслуживает баш процесс что противорчечит тому что мы ране
писали что нажатие нокопок и печать на экарне осуживает ядро. так вот пртирворчения нет дело в том
что баш коода стартует он посылает в терминал (железку ) управяляющие команды которые 
в нем чтото пееркоючюат от дефолтовых настроек и он начинает печатать буквы только если условно 
говоря как я понимаб только при условии что баш их принял. а раз прцесс стоит то и наэаране пусто.

чтобы это доказать надо расшифровать строку


ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


двигаем дальше на чем бы мы ни закончили.
мы будем говорить о том же самом только может быть немного с другого примера:

команда kill.
я с ней игрался. я запустил ее в том же окне что и баш

$ kill -19 $$

и я ожидал что также как вслучае голого баша что после этого окно терминала перестанет
печатать символы при нажатии на кнопки. однако это на удивление оказалось нетак.
я начал разбираться. я думал что что баш отфоркает себя. запустит килл. килл остановит баш.
закончит свою работу (правда оставшись зомби ибо код возврата стоячий баш прочитать неможет ибо 
шедулер незпускает хендлер у стоячего процесса). но поскольку килл неменяет настройки терминала я полагал что экран терминал "зафризиться". ан нет. окей. я запустил всторенный в баш kill он там
тоже есть оказывается. тоесть при его вызове никакого форка непроисходит команда работает прям из процесса баша

$ builtin kill -19 $$

однако эфект был прежний. экран незафризился.
ответ оказался (забегая вперед) логичным баш при запуске команды даже если она встроенная
он сбрасывает настроки терминаола (через ioctl) в дефолтовые настройки. там что этим все и обьясняется. теперь длинное обьяснение: 

у баша есть встроенный kill тоесть ему ненужно форкаться и юзать /bin/kill
он может сразу сам из себя из своего процесса это сделать. я думал что баш 
единственная проблема в том что
по дефолту баш почемуто юзает не свой builtin kill а внешний /bin/kill
как заставить баш юзать всегда свои билтины я пока незнаю. но можно bash заставить
персонально выполгить именно builtin а не внешний файл.

(окно1)$  builtin kill -19 $$

так вот моя идея была в том чтобы остановить баш причем через встроенную команду kill 
в том же окне где крутится баш. я думал что это приведет к тому что печать кнопок на экране
прекратится как она прекращается если остановить баш из другого окна. однако я был удивлен
что если остановить баш из того же окна с помощью builtin kill (тоесть баш себя нефоркает и минимальные телодвижения делает по сисколлам в этом случае) то при этом печать символов на экране
работает! в чем же прикол. я затрейсил баш из другого окна и увидел что во время даже
запуска builtin команды ( тоесть без форка) баш производит изменнеие настроек терминала!(казалось бы зачем?)

(окно2)$ sudo strace -v -e ioctl -f -p 10396
strace: Process 10396 attached

ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0

сравним настройки котоыре бащ выставляет перед запуском builtin и дефолтовые настройки
терминала

изменнеые:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

дефолтовые:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

(как получить дефолтовые - достаточно запустить бащ в новом окней через strace и взять первый 
ioctl TGETS)

гоча! совпадает! значит баш когда форкается для запуска внешнего бинарника или когда баш даже 
выполняет свой встроенный builtin ( тоесть другими словами когда мы набрали коману в строке 
приглашения в баш и тыкаем enter на ее исполнение и неважно она встроенная или это внешний файл) то он когда команду запускает что мы набрали он изменяет настройки терминала на дефолтовые.
опишу дефолтовые настройки терминала которые для нас имеют значение:
	а) если мы вводим буквы с клавы то активирована опция local echo и терминал то что мы ввели с клавы сразу дублирует на экране (если local echo выключен то терминал принимает наши кнопки с клавы и сохраняет их в свой внутренний буфер ) 
	б) набранные буквы терминал шлет в линию в /dev/pts только после нажатия Enter. 

Вот на эти настройки баш сбрасывает термиал когда мы в строке баша запускаем команду.
А когда выпонение команды закончено и управление возврашается к процессу баша (когда мы снова можем набирать команду в строке) то баш снова меняет настройки терминала на кастомные. они имеют два важных последствия: 
	а) если мы нажали на кнопку в терминале то нажатие воспринимается но на экране символ непечатается (режим local echo off). 
	b) терминал шлет в /dev/pts (в линию) букву как только она была нажата ( а не когда был нажат Enter. тоесть в дефолтовом режиме мы вводим строку и она лежит целиком в памяти терминала и неотправляется в /dev/pts до тех пор пока мы не введем Enter а в кастомном режиме кторый баш задает как только ударли по букве на клаве терминал мгновенно отправляет байт о букве в /dev/pt поэтому в дефолтовом режиме данные приложению (башу или другому) попадают только в форме строк целиком а в кастомном баш режиме данные летят в /dev/pts к внешнему приложению мгновенно побуквенно.  )

В кастомном режиме терминала (что задает баш когда мы находимся в режиме ввода командв командной строке) чтобы буквы печаатались на экране баш должен их отправлять в /dev/pts только тогда буква
печатается на экране. баш так и делает. как только он получает букву через /dev/pts он тутже вызывает сисколл write(2,) и печататет эту букву на экране. 

для нас конечно оба эти режимы в конечном итоге выглдядят одинаково но в том то и дело что 
под капотом они рабоают совсем по разному. вот это вылезает когда мы стопим баш в терминале
и у нас пропадает печать наших букв в окне терминала или если мы стопим какоето другой процесс
в окне терминала и у нас при этом буквы отлично печатаются на экране. вот она разгадка!!


итак еще раз: у нас есть терминал.  это желещка как жесткий диск или видеокарта и чтобы с ним работать нужен драйвер код в ядре. у нас терминал виртуальный но это особо роли неиграет 
он для ядра остаетая такой же железкой. терминал это клава и экран в одной железке. когда  у нас
окно терминала активно то ядро "маунтит" нашу реальную клаву в виртуальную клаву от терминала другим словами нажатия от кнопок летят в драйвер терминала. и по поводу экрана  - когда мы шлем 
данные в терминал ( об этом щас поговорим) то драйвер терминала шлет буквы в графическое окно
на физическом экрана ноутбука. для юзерского процесса связь с терминалом идет через /dev устройство ( также как есть при связт юзерского процесса с лююбой другой железкой. связь всегда идет через /dev устройство). для принятия нажатия кнопок процесс читает из /dev/pts а для 
печати на экране процесс пишет в /dev/pts. тоесть для программы  процесс  работы с терминалом
это чтение или запись в /dev/pts файл. между файлом /dev/pts и железкой(терминалом) находится ядро. оно принимает данные из терминала и пересылает их в /dev/pts и оно же принимает данные из /dev/pts и шлет их на терминал. в этом роль ядра. железка же (терминал) получив данные от ядра 
делает уже непосредственную печать на экране железки(терминала) тоесть железка трансформруем полученный поток байтов уже в физические символы на физическом экране. и здесь как видно что ядро только передает данные на железку и все а за само отображение на экране отвечает уже неядро а сама железка. и тоже самое про клаву железка принимает и транформирует механическое нажатие клавиш в поток байтов которые железка(терминал) уже шлет в ядро ( а ядро в /dev/pts чтобы приложение в юзер спейсе увидело получило). Таким образом работа с клавой и преоброзвание кнопок в поток байтов это не ядро делает а сама железка. ядро лишь принимает поток байтов. и еще важно что при желании 
можно подкручивать настройки железки. это все приводит к тому что мы можем настроить чтобы железка неслала в ядро нажатые кнопки пока ненажат Enter или наоборот чтобы железка мгновенно слала в ядро каждую нажату кнопку. Это все настройки самой железки. не ядро. ядро здеь неучаствует. также видно что и программа (баш например ) к этому неимеет никакого отношения. это все настройки самой железки. также можно настроить на железке чтобы нажатая кнопка сразу дублировалась на экране а можно настроить наоборот что нажатые кнопки небудут печататься на экране. Поэтому очень важно понимать что в случае "баш работает в черном окне терминала" у нас три компонента участвуют а выглядит все это как нечто единое. 

	bash ---- ядро ---- терминал (железка)   

каждый компонент играет свою роль. 

важно понимать что bash работает в юзерспейсе и непосредственно с терминалом невзаимодействует а делает это через ядро а конкретно через файл /dev/pts/x

	bash(user space) ---/dev/pts/x--- ядро ---- терминал

поэтому между нажатием кнопки на клаве на терминале и тем что это нажатие долетело до баша
должна произойти целая серия событий.
тоже самое между посылом байта из баша и отрисовываеием литеры на экране терминала должна
прозойти целая серия событий.

поээтому происходит целый ряд событий целый оркестр с момента как мы нажали кнопку на клаве
и как она отрисовалась (или неотрисовалась) в черном окне терминала с приглашением от bash

опять же хочу заметить что для терминала нажатие кнопки и отрисовыванием символа на экране
это в целом два независящих события поэтому если мы хотим чтобы они происходили один за другим то 
это еще надо настроить.

поправка такая еще - я там выше написал что ядро неиграет никакой роли в работате терминала кроме
как отправка байтов и получение. это и есть так если бы у нас терминал был реальной настоящей 
железкой (как это было много лет назад когда были реальные железные терминалы). а щас терминал 
виртуальный поэтому да в конечно итоге функцмонал железного терминала тоже обеспечивает ядро. условно говоря есть драйвер терминала в ядре для которого терминал это железка как настоящая с которой есть некий програмнй интерфейс и порты взаимодействия (через виртуальный com порт) и есть
еще кусок кода ядра который уже непосресдтвенно эмулирует живой железный терминал. но на мой взгляд  для более четкого понимания как все работает лучше представлять что мы имеем реальный железный терминал который через com порт соединяется с системным блоком компа. ( да то есть раньше комп выглядел так что был системный блок и несколько терминалов подключенных через COM порты к сстемному блоку. терминал был  ящиком железным в котором была обьедиенная  в одно целое экран и клава). таким образом между ядром и терминалом только летали байты а отрисовку на себя брала уже железка и прием кнопок с клавы и отсылку в систм блок брала на себя железка. соотвесвтенно 
уже на железке на терминале можно было например ввести строку и отредактировать еще не отправив
в системный блок. также на терминале можно было выбирать (наверное) шрифты цвета и всяке другие 
графические настройки внезависимости от системного блока от ядра. условно говоря терминал это был содеинное в одно три компоенента : граф карта , клава, монитор.  современный комп все это разьединил на три разные устройства каждое из которых коммуницируем  с ядром через свой порт.  а раньше они все сидели на одном COM порту который их соединял с сист блоком тоесть с ядром.


так вот bash он может делать настройки терминала через обращение к ядру черещ сисколлы ioctl_tty, ioctl а ядро тогда получив эти сисколлы подручивает настройки на терминале. что баш активно и делает постоянно. при своем старте. при своем окончании работы. при запуске команды. для 
нас это остаетается все невидимо и прозрачно если только нетрейсить работу баша или незастопить 
его процесс. и тогда мы обнаружим что нажатие кнопок в термирале приводит к тому чтобы они печатались на экране. вот тутто оно и вылезает!

опишем еще раз как работает связь взаимодействия между термиалом и юзерским процессом (приложением):

мы жмем кнопку на клаве это событие принимает обрабатывает терминал (железка если у нас железка или эмулятор терминала особый кусок кода в ядре что существенно что юзерский процесс  к этому неимеет никакого отношения и контроля над этим. единственный контроль который юзерскрйи процесс может сделать это заранее через сисколл ioctl попросить ядро покрутить настройки на терминале которые потом дествуют автономное без участия юзерского процесса). так вот мы нажали на кнопку 
терминал это принял и переработал в байт информации и положил в свой внутренний буфер ( если это желещка то в буфер железки если это виртуальный терминал то в буфер в ядре). далее если на терминале выставлены дефолтовые настройки то байт информации о нажатии клавы непередается в драйвер терминала ( непутать эмулятор терминала и драйвер терминала. эмулятор терминала эмулирует поведеие железки для кода ядра. а драйвер терминала принимает байты от эмулятора терминала либо реального терминала и пересылает их в /dev/pts файл чтобы юзерское приложение могло взаимодействоать с терминалом через ядро. дальше будем для простоты изложения счиать что терминал реальный железный а том мудота описания будет зашкаливать). так вот мы нажали кнопку ее считал терминал и положил в форме байта в свой буфер. далее если настройки натерминале дефолтовые то 
ничегоне произойдет  а именно терминал нестанет отправлять этот байт в COM порт в ядро. тоесть ядро неимеет представления на данный момент что была нажата кнопка а приложение тем более.
далее мы виваем еще несколько кнопока и они тоже записываются в буфер терминала. также в дефолтовой настройке терминала при нажатии на кнопку она автомтом отрисываоается на экране.
обо всем об этом ядро и приложение недогаюываются. они об этом незнают. далее мы можем нажимая спец копки на клаве даже редактировать введенную строку в терминал. об этом тоже ни ядро ни приложение незнают. потому что обовсем об этом по дефолту он недоакладывает в ядро а ядро соответвенно неможет доложить приложению. и наконец мы тыкаем на клаве Enter. это историческое событие потому что теперь терминал шлет всю эту строку в ядро через COM порт. ядро принимает 
байты. в свой драйвер терминала.  приложение по прежнему нифига незнает ни очем.  а между тем у
нас на терминале уже во всю светится та строка что мы ввели. но это абсолютно незначит что эта строка уже в памяти приложения. итак драйвер получил байты о кнопках и он отсылает их в /dev/pts/x.
и вот теперь юзер процесс может считать из /dev/pts и узнать о том что была нажат клава и какие кнопки.  опять же от того что драйвер ядра направил байты от кнопок в /dev/pts незначит что
приложение их автоматом получило. нет. приложение должно самостоятельно сделать запрос на чтение из /dev/pts  а если приложение сейчас занимается чемто другим и не делает запрос на чтение так 
оно и опять же без понятия о том что были нажаты кнопки. на практике приложение делает особоый 
сисколл типа select/pselect и засыпает переходит в S состояние. этот сисколл он следит за тем 
что в /dev/pts появились данные. таким макаром приложение может следить за тем что в /dev/pts прилетели кнопки. итак приложение заюзало при своем старте такой сисколл и он сработал , юзер программа будится и делает запрос на чтение.  и вот только теперь наконец нажатые кнопки 
смогли попасть в программу. !  соовтсветвенно когда теримнал с дефолтовым настроками то в программу
прилетает только строка целиком а непобуквенно. причем на экране терминала уже все нарисовано и 
только потом после Enter буквы появляются в приложении(опять же появляются только если в приложении настроен правильный сисколл а так могут еще хрен знает сколько времени непоявляться а на экране есть). соотсвтенно при такой схеме приложению ненужно обратно посылать эти буквы на /dev/pts с целью чтобы они отрисовались на экране терминала потмоу что они там уже есть. если их заново послать то тогда байты пройдя цепочку посредников обратно нарисут на терминале дубликат той же строки. а смысл? поэтому данная схема имеет свои плюсы и и минусы.

как уже сказал что у терминала можно подкручивать настройки. юзерская программа это может сделать
если исползует сискол  ioctl , ioctl_tty  с параметрами. тогда (через ядро) терминал будет подкручен и начнет работать по другому.

такую подкрутку делает баш. что он делает. баш когда стартует он делает ряд ioctl и меняент на 
терминале настройки. что меняется: если мы нажали кнопку то терминал немедленно (недожидаясь Enter) шлет байт с буквой в COM порт тоесть байт сразу улетает в ядро а оттуда в /dev/pts файл 
а  баше также настроен сисколл который ждет прилета инфо в /dev/pts таким образом нажатая кнопка на терминале мгновенно оказывается в недрах баша. минус такой схемы в том что баш должен предоставлять (как я понимаю ) встроенный редактор чтобы можно было редактировать строку символов (ведь раньше это можно было делать средствами самого терминала а теперь нет). вторая настройка касающаяся терминала состоит в том что после нажатия кнопки терминал автоматом ее неотображает на экране. вместо этого теперь баш когда он получил кнопку то он сразу шлет обратно в /dev/pts этот же байт. терминал принимает этот байт и отрисовывает. такая схема дает некую синхронность в том плане что все что мы нажали сразу оказывается в кишках ( в памяти) баша а то что он получил он отправляет обратно и мы это видим на экране. так что получается что то что на экране уже в кишках баша а что в баше то уже на экране.

но еще раз подчеркну что при такой схеме баш(юзер процесс) никак не играет роли в функции принятия кнопок с клавы или в отображении символов на экране.    

описанная схема работы баша обьясняет феномены такие как:
	- если мы в одном окне откроем баш который привязан к /dev/pts/x а во втором окне запустим 		cat  /proc/pts/x  и потом в первом окне начнем нажимать кнопки то часть наших нажатий отобразится на втором экране и только часть в экране баш. тоесть второе окно будет как бы красть часть наших нажатий. тоесть например мы нажали на клаве 123456 а увидим в окне1 и окно2
	вот что
	 (окно1) $  25
	 (окно2) $ cat /dev/pts/23
	 			136
	 как так вышло.
	 мы жмем на клаву в терминале окна1 и символ мгновенно улетает в /dev/pts на выходе из этого файла в юзерспейсе за его содержимое сражаются одноверменно два процесса bash и cat.
	 и только ктото один (по рандомному закону) считает очередную букву. когда то это будет баш когда то это будет cat. поскольку в терминале где баш он отключил автоматическую печать той кнопки которая была нажата то в этом окне будут печататьс только те симоволы которые баш получил из /dev/pts и обратно сам направил. вот символы 2 и 5 они все таки долеетели до баша (cat их несмог своровать) и баш их автоматом отправил обратно в /dev/pts терминал окна 1 их получил и напечатал. вот почему так все отработает. 
	 	Если бы баш включил local echo on настройку на терминале то тогда все наши нажатые в терминале окна1 кнопки 123456 они бы напечатались бы автоматом внезавимисоти от того что 
	 	из этого доолетело то баша. правда бы при этом кнопки 2 и 5 они бы два раза напеатались 
	 	один раз из за опции local echo on и второй раз из за того что баш их прислал обратно 
	 	через /dev/pts тоесть выглядело бы картина общая тогда бы так
	 (окно1) $  12234556
	 (окно2) $ cat /dev/pts/23
	 			136
	 
	 при этом еще раз подчеркну что баш внутри себя бы имел информацию толлько о нажатии на 2 и 5
	 а об остальных кнопках баш бы бы без понятия. тоесть если бы мы вводили вместо цифр буквы скажем  ls -1 то мы бы увидели (дублируем второй и пятый символ)

	 (окно1) $  lss -11
	 (окно2) $ cat /dev/pts/23
	 			l 
	 и мы бы непонимали что за хрен в командной строке баша откуда и почему. 
	 и если бы мы даже отредактировали то что там по факту осталось бы а недрах баша неясно.
	 и было бы непонятно после Enter почему линукс ругается на синтаксис что он неверный команды.
	 поэтому башу очень важно в режиме ввода команды в строке чтобы отображамый текст на экране
	 терминала в точности соотвествовал тому что реально долетело до баша. 
	 тоесть вот в этом случай
	 (окно1) $  25
	 (окно2) $ cat /dev/pts/23
	 			136
	 хотя до баша у нас долетела лишт только часть нажатий но хотя бы мы четко знаем и баш знает что внутри баша только 25 и на экране 25. полное соотвесвтие между оперативной памятью баша
	 и строкой на экране.

	 Поэтому когда баш запустился и мы увидели его приглашение в командную строку к этому моменту
	 баш уже подкрутил терминал на две вещи - выключил local echo и нажатие кнопки на терминале
	 мгновенно летит в /dev/pts. зачем он это сделал еще раз для того чтобы было четкое совпадение
	 того что напечатано на экране и того что сидит в памяти в окне терминала. Думаю теперь однозначно понятно что вообще говоря и особенно при дефолтовых настройках терминала то что мы видим на экране и то что долетело до приложения и сидит в его кишках это совсем необязано совпадать. ( а ведь интуитивно мы думаем что это одно итоже. что окно терминала это как бы окно в кишки баша или другого приложения а это совсем нетак.) баш можно представить как поле боя с танками самолетами. а окно терминала как карту. с одной стороны юзер генерал может двигать войска по окну терминала потом через ядро эти приказы летят к полю боя ( процесс)
	 но совершенно нефакт что либо одно долетело туда либо резултатты обратно. так что может получаться так что в окне терминала одно (карта поля боя) а на поле боя другое (кишки терминала). а интуитивно кажется что это одно и тоже. что это окно терминала это как бинокль или микроскоп напрямую в кишки баша. нет. скорее это карта на стене которая нарисована согласно телеграммам  с поля боя и нашим движениям руки двигающим фигурки на карте. может быть рассогласование. вот в чем подстава.

	 двигаем дальше.  такой режим терминала недефолтовый кастомный удобен и нужен только башу
	 на момент ввода команд но совершенно нефакт что он нужен программам которые он запускает
	 плэтому как только мы ввели команду отредоактировали и нажали Enter то баш перед тем как выполнять команду сбрасывает насторйки терминала(через сисколл ioctl) на дефолтовые. тоесть на терминале обратно включается local echo on и терминал посылает в ядро нажатые кнопки 
	 только после нажатия Enter. это в частности приводит к тому что когда мы запустили программу
	 в баше и он  там работает то мы можем нажимать кнопки в это время в терминале и они 
	 отрисовываются сразу. пример

	 $ ./39.exe
	 13
	 3 1
	 2213
	 1231
	 23214
	 14
	 1
	 4332
	 4


	 баш сбарывает настроки терминала на дфолтовые даже когда запускает свои builtin команды
	 пример такой команды:

	 $ builtin echo "1"

	 мы помним что когда выоплняется запущенная внешняя команда то это делается через создание
	 дочернего процесса clone+execve и на время работы чайлда баш впадает в спячку через wait.
	 когда команда отработала и дочений процесс сдох и произошел возврат в оживший процесс баш то 
	 баш опять меняет настройки терминала с дефолтовых на кастомные и так каждый раз.

	 соовтственно если исползовался builtin команда то дочернего процесса нет. просто когда builtin выполнился то бащ тоже убирает дефолтоые наторройки терминала и выставляет кастомные.

	 что мы имеем в остатке по практическим случаям:
	 	- если у нас в окне есть баш в котором ничего невыполняется  а просто висит
	 		приглашение командной строки и мы возьмем и застопим(из другого окна) процесс этого баша через SIGSTOP то в нашем исходном окне при нажатии на кнопки они перестанут печататься на экране. хотя по факту их нажатие фиксируется терминалом и направляется
	 		в ядро а оттуда в /dev/pts просто такак у нас local echo off то терминал недублирует
	 		их на экране а только пересылает в /dev/pts а так как баш остановлен то он обратно и 
	 		не пересылает буквы лежащие в /dev/pts поэтмоу на экране и пусто. но еще раз скажу нажатия кнопок фиксируются терминалом ( потому что терминал его эмулятор это ядерный код и он работает как прежде. то что баш остановлен терминалу глубоко пофиг. вот это важно еще раз понять. кнопки терминалом принимаются фиксируются и отправляются на /dev/pts через ядро. так что потери нажатий нет. в этом можно легко убедиться разблокировав баш через SIGCONT и мы тут же увидим на экране всю ту абрадакабру которую мы набрали в слепую. итак еще раз нажатия фиксируются нетеряются терминалом потому что его работа 
	 		обеспечивается ядром искючительно ядром. в том что кнопки фиксруются можно убедитьс разблокировав обратно баш. итак нажатия мы непотеряли. а то что они непечатаются когда бащ стоит здесь баш напрямую ни причем. он на это напрямую никак не влияет. просто до этого баш через ioctl настроил терминал чтобы он при нажатии на кнопку автоматом ее нерисовал на экране (потому что нажатие и отображение на экране это вооще то два разных события и мы можем настройками либо установить автопечать на терминале либо октлючить так вот баш заранее отключил) поэтому оно и нерисуется при нажатии. но нераюотающий баш здесь ни причем. когда он работает авторисование также неработало просто когда баш работал он это со своей строны компенсировал присылая обратно в /dev/pts полученные буквы. терминал их получал и печатал возникала иллюзия что нажатие на кнопку и печать на экране это как бы одно событие неразрываное. а так как баш остановлен то он не посылает обратно ничего на терминал)
	 	- если мы в баш запустили какую то долгоиграющую команду(если она недолгоиграющая то мы просто не успеем кнопки понажимать) то в это время при нажати на 
	 		кнопки на экране будут печататься символы. Это то к чему мы привыкли. ни баш ни команда запущенная к обработке и отрисовке этих символов неимеет никакого отношения. это чисто работает терминал. при запуске команды сам баш сбраывает настройки термиала
	 		на дефолтовые и если после этого команда неменяет настройки то просто нажатые символы их терминал только печатает на экране но нешлет в /dev/pts и только если мы нажмем Enter то терминал их пошлет в /dev/pts ну а там уже дело работающей команды читать из /dev/pts или нечитать. если команда небудет читать то эти символы выскочат в строке баша когда команда закончит свое действие и баш вернется обратно из спящего состояния. 	
	 вообще это интересная тема. если ты нажал на кнопки в терминале и ничего невидишь на экране 
	 это еще незначит что кнопки были не восприняты терминалом. а если ты видишь на экране символы в терминале это ще незначит что терминал отослал эти символы в /dev/pts а если и отослал это еще незначит что приложение их прочитало.

	 кстати еще момент. вот мы остановили наш баш через SIGSTOP (из другого окна) и окно его терминала "зафризилось" тоесть мы нажимаем на кнопки а на экране нет символов. можно легко убедиться что символы продолжают летеь от терминал в /dev/pts достаточно открыть второе окно и там ввести

	 $ cat /dev/pts/x

	 потом вернуться в первое окно нажимать там кнопки. потом вернуться во второе окно и мы там увидим все кнопки что мы нажали. тоесть терминал продолжает как прежде принимать кнопки
	 и посылать их в ядро  драйверу терминала а он в /dev/pts . так что терминал продожает рабоать кнопки нетеряются и замороженый баш на это никак невлияет и неможет повлиять. терминал это терминал ( эмулятор обслуживает ядерный код который условно говоря работает всегда и его неостановить неотключить потому что интеррапты неотключить) и он работает всегда вне зависимости
	 от того работают или зависли или остановлены юзер процессы связанные  с этим терминалом. надо четко понимать что терминал это одно а процесс это совсем чтот другое. кажется что терминал и процесс юзерский это чтото единое спаянное неразрываеное. это совсем нетак. связь между терминалом и юзерской программой это как связь между двумя людьми в разных городах которые обмениваются друг с другом телеграммами. все таки когда мы смотрим в черный экран мы смотрим в терминал (его обслживает ядерный код или даже это может быть железка) и все эти буквы на экране
	 это все терминал и только терминал. юзеркий процесс где то там  за дальними далями. просто юзерский процесс присылает телеграммы через ядро о том что бы он хотел чтобы терминал нарисовал 
	 на экране. вот какая связь между буквами на экране терминала и процессом. а нам кажется что мы 
	 видим буквы вот буквально как бутто это кишки баша. это совсем нетак. 

	 ффффууууухххх... вот так описание. вот баш вот так молодец. и терминал тоже тот еще молодец.

====================================
Posix
Single unix specification  (SUS) = X/Open Common Application Environment Specification
"Unix System V Interface Definition" (SVID)
ABI

Posix и SUS сейчас это одно и тоже.

и еще такое

POSIX:2008 = IEEE Std. 1003.1-2008 = SUSv4 = The Open Group Specification Issue 7.

posix включает в себя несколько томов:
	- Base Definitions
	- System Interfaces
	- Shell & Utilities
	-  Rationale

обычно если это pdf файл то там все тома сразу включены.
прикольно что они дают опредеение для файла а для иноды нет. зато в тексте спокойно
пользуются термином инода. недебилы ли?


далее
нашел стстатью computerworld 26 октября 1987 года.

там сказано что тогда было два документа "Unix System V Interface Definition" (SVID) 
который разработала AT&T. 

POSIX документ о томже самом но его разработал институт IEEE.

цель этих документов описаать стандарт взаимодействия между юзерской программой (user space )
и ОС (кернел спейс). тоесть описат те стандарты и инструменты которые предоставляет
ядро ОС для программы которая сидит в user space и видит эти инструменты с которыми можно общаться по определенным стандартам. тоесть для юзерской программы общение с ядром 
выглядит исключительно через инстурменты которые ядро предоставило в user space.
итак идея еще раз какая. есть ядро внутри себя оно может взаимодевтсивовать как хочет, но в сторону userpspace ядро ОС которая совместима с POSIX должно предоставлять определенные
инструменты таким обоазом с точки зрения user space программы любая ОС совместимая с posix
выглядит одинаково.  условно говоря доступ к файлу с точки зрения user space программы
дожлен выгляеть как /fodler/folder/fodler/filename

итак еще раз posix опиывет стандарт интерфейса между user and os. другими словами ядро предоставляет в userspace набор инстурментов с конкртеными характеристиками. таким образом неважно как ос выглядит на уровне кернел моде главное что для юзер программы любая posix совместимая ос выдает один и тот же набор инструментов поэтому выглядит одинаково.

таким образом юзер программа взаимодейтсивет с posix набором инстурментов(в user mode) и похеру что там по капотом у ос ( в кернел моде) . появляется portability программ между posix 
совместимымми ОС.

важно еще и то что если у нас есть несколко наших программ то друг с дружкой они будут 
взаимодейтсивовать (IPC) через опять же интерфейсы инструменты которые предоставляет ОС,
таким образом нетолько одна программа но и связка программ будет успешно взаимодействоввать
друг с другом как в одной posix os так и в другой. потому что еще раз - все межпроцессное
взпимодейтсвие всегда идет все равно через некоторые инстурменты(видные в user space) которые предоставляет ядро. а эти ipc инстрменты тоже оговорены в posix. 

возврашаемся к SVID - в статье сказано что в SVID указано много чего hardware specific 
что уменьшает portabilty насколько я понял уже речь идет о портабилити ОС а не user программы. в плане того что ОС будет  привязана к конкретному железу. В любом случае там
сказано что в SVID слишком много конкретики что делает его менее сильным в плане portability 
насколко я понимаю уже в плане железа на котором может работать ОС соответвующая SVID чем это есть у ОС которая соответсвтует POSIX.

поэтмоу немогу понять почему ABI привязывается к SVID а не к POSIX ?

в википедии abi опреляется как то что у нас есть две программы уже откомпилированные
и они друг с другом через железо могут обмениваться инфой. тоесть одна хочет другой
чтото передать , делает она это через железо определенным образом , вторая программа
хочет принять от первой инфо и она знает как первая использовала железо (условно говоря
первая прога положиме в регистр intel RAX ).  тоесть abi пропсиывает для бинарных программ
протокол обмена данными через железо - как это делать конкретно.

API описывает тот же обмен данными между двумя прогами но ! на уровне source code.
получается программист должен знать API, компилятор должен знать ABI.

как уже написал если мы пишем на C то это забота компилтора все делать как ABI пропсиывает.
(если только мы в C source неиспользуе вставки из головго асемблера)

api - дает возможность программам обмениваться информацияей друг с другом на уровне исходников. вообще это дебильное определение. тут смысл на самом деле такой - вот у нас есть ОС которая как бы одна программа. а есть наше user приложение которое друая программа.
ОС предоставляет некий набор инструментов на уровне source code для юзер программ.
если у нас будет две ОС у которых в кернел моде все работает по разному но в юзер спейс
они предоставляют одни и теже инстурменты , то для юзер приложения эти две ос идентичны,
поэтому мы берем source код нашей user проги несем в любую ос, компилируем там компилятором
от той ОС и она там работает на одном и том же source код. вот что значит блядь что api дает портабилити на уровне source code. когда мы говорим про api это значит что есть одна программа которая придумала api и его предоставляет и есть другая программа которая подчиняется этому api и следует ему. api это набор инстурментов верхнего уровня абстракции,
эти инструменты позволяют программа обмениваться инфо гвоорить на одном языке на верхнем
уровне абстракции на уровне языков программирования типа C. API конкретика описывается 
в source код первой программы и потом также отображается в source код другой программы.
условно говоря в первой программе мы говорим что у нас есть функция A и у нее есть один параметр который имеет тип целого. чеерз эту функцию мы будем обмениваться данными. это началось api.

A C standard library is a wrapper around the system calls of the Linux kernel; the combination of the Linux kernel System Call Interface and a C standard library is what builds the Linux API.

POSIX является api. но и нетолько там есть и еще доп контент.

посдення версия posix (читается ПАЗИКС): POSIX.1, 2013 Edition


api = это когда у нас одна программа порождает высокоуровневые сущности через которые другие программы могут обращаться к первой и они могут обмениваться данными. что это за сущности. 
наверное например это функции. функция это высокоуровнневая абстракция. 
первая программа поставляет функцию которая имеет один параметр и он скажем целого типа.
если вторая программа обратться к этой функции то сможет получить кусок данных от первой
программы или передать свой кусок данных для первой программы. вот эта функция и есть уже сущность составляющая API от первой программы. итак у API есть обяазательно поставщик
программа которая рождает и обеспечивает существование и работу некоторго набора высокоуровненвых сущностей через которые друние прграаммы могут комуницировать с программой
поставщиком. api обьекты создаются на базе высокоуровневых языков программирования.
итак конкретика api обьекта описывается текстовымм кодом на ввысокоуровневом языке 
прогрммирования. захера нужен api. это прослойка между программой один и внешним миром.
эта прослойка во первых дает связь межу программой и другими программами, и во вторыъ
эта прослойка абстрагирует скрыает внутреннюю кухню первой программы от внешнего мира.
тоесть программа один внутри может меняться но для наружных программ все выглядит всегда
одинаково. один пример это база данных (программа один). она наружу выкидывает набор api функций через которые можно к базе сделать запрос. а уже получив запрос база данных хитрым способом копается в кишках собирая ответ. таким образом для внешей программы внутренности
базы данных скрыты поэтому изнутри мы можем менять базу данных хоть сто раз надень как она там копается в своих кишках при поиске данных. второй пример ядро ОС. мы можем менять его сто раз на день его внутренний процессы но для юзер программы функции через которе ядро 
принимает заказы остаются теми же самыми. поэтому замена кишок ядра никак не влияет на source код юзер программы ибо ядро наружу выставляет всегда один и тот же набор функций.
условно говоря запорожец превратился со временем в бмв под капотом но для водителя это по прежнему руль и три педали. таким макаром у нас со временем ОС становится все более современной и звездатой ( поддерживает новые процесоры большие диски новые видеокарты) но при этом юзерскую программу ( редактор текста) переписывать на уровне source код ненадо. надо 
только перекомпилировать. 

когда мы слышим api то сразу надо спросить api для какой программы? потому что api без
программы источника которая предоставляет api небыавет. итак есть программа источник
она предоставляет набор функций и инструментов которые и составляют api множество.
итак api это неверный термин потмо что у api всегда есть два обьекта - первый это источник
api некая программа например ядро линукс. или веб сервер. второй обьект это набор инструментов
которые и составляют множество обьектов api. зачем все это. чтобы другие программы могли 
подключиться к этим инстурментам и через их помощь получить даные от первой программы или 
засунуть внутрь свои данные. поскольку программа это source код  ( как один из вариантов)
то физическим носителем api обьектов является source код высокоуровненовго язык програмирования, получается что более высокоабстрактные сущности api строятся на тех сущностях менее абстрактных который предоставляет язык программирования. 
прикол api  в том что он скрывает абстрагирует конкретику и внутренности как програаммы один 
от внешней программы так и внутренности внешней программы от программы один. 
на практике обычно важно то что мы написали программу юзерскую ( редактор) в форме source код на языке выскоуровневом програмировния и больше нехотим в нее вкладываться менять ее код.
тогда как бы неменяолсь ядро ОС со временем (линукс) нам ненужно менять код редактора 
текста он по прежнему работает хоть на старом линуксе хоть на новом на уровне source код.тоесть его только надо будет перекомпилировать. в этом и есть желаемая фишка.
потому что хоть внутрености программы один (ядраос) меняются но сисколлы которые ядро
предосталвяет остаются темиже. поэтому для юзер программы все api обьекты выглядят без 
изменений.

 
posix описывает api предоставляемое ядром(кодом раотающем в ринге0) UNIX подобной  ОС для user space программ(ринг3). таким образом если мы написали юзер программу которая взаимодейтствует
с posix api инструментами то эта программа должна работать без необходимости имзенения ее
source кода во всех ОС которые отвечают posix api. (единственное что юзер программу
нужно будет на каждой ос компилировать своим родным для ос компилятором, тоесть откомпиирванная на одной ос бинарник уже необязан работать на другой ос. только source код является перееносимым что уже круто.).
но posix описывает нетолько api которое предтвляет ядро ОС но и ряд дополнительных вешей. в целом получается что posix описывает как должна выглядеть вести себя ОС на уровне верхних абстракция на уровне сущностей выского уровня абстракции. вести себя и предоставлять эти 
сущности. например сущность  - командный интерпретатор. или терминал.



abi - описывает как конкретно две откомпилированые программы должны обмениваться данными 
через реальное железо. тоесть условно говоря если одна программа хочет передать 
данные в другую программу то она должна положить число в регистр EAX.тогда вторая программа
уже знает что данные лежат в EAX.
за реализацию ABI отвечают компиляторы на практике.

вообще это очень непросто понять все участников api или abi. какие стороны компоненты 
принимают участие в этих темах.  в случае api это точно две программы и язык программирования
через который две программы представлены в виде source код, в теле этих sourc кодов запрограмимрованы высокоуровненвые api сущности через менее высокоуровненвые сущности языка
программирования.

в случае abi это две программы и цпу. программы представлены на практике в форме  машинного кода который в свою очередь зависит от  типа цпу (intel 32bit, intel 64bit, arm 32bit, motorola). поэтому на каждый тип цпу свой abi документ. сущностями abi которе составляют его обьекты это  с одной стороны абстрактные сущности кода программы (функции нпример) а с другой стороны это сущнсости цпу (регистры) , ячейки памяти в RAM.

в вики написано что linux api предоставляет ядро и группа библиотек GLIBC.
тоесть носителем создавателем api является неодна программа а несколько - ядро и GLIBC.
ядро предоставляет в юзер спейс сисколлы а глибс функции обертки которые уже в свою очередь 
обращаются к сисколлам ядра.
пользовательккая программа может обращаться как напрямую к сисколлам ядра так и к 
glibc функциям.

что интересно прогарммы мы пишем на C. и язык C нам недает возможность обращатся к 
сисколлам. он только дает возможность обращатся к функциям glibc. а если мы хотим
из C обратиться к сисколлу ядра то надо в текст на C вставлять код на асемблере. 
с другой стороны кто сказал что язык программирования у юзер программы обязан быть C высокоуровневый. ассемблер тоже язык программирования. дауж.. намешали..




====

linux
static library vs dynamic library.

во время компиляции проги можно указать чтобы все библитеки которые ей нужны 
были вмонтированы в тело проги. тогда бинарник становится автономным. все куски кода
которые ему нужны будут вмонтированы в тело бинарника.  так вот вмонтирована в тело 
нашей прграммы будет библиотека в статическом виде.

статическая библиотека или динамичекая орпделеятеся на стадии компилировагния этой библиотеки
из исходного кода на стадии компиляции. берем исхоный код бибиотки компилируем с некоторыми
флагами и на выходе получаем либо файл который статическая библиотека либо файл
который на выходе динамическая библиотека.

файл который статическая библиотека будет использован для вмонтирования в тело 
другой программы при ее компиляции если мы укажем флагами при компилияции что мы хотим 
все библиотеки вмонтировать в тело программы. тогда комипилятор найдет все библиотеки 
которые нужны проге в их статическом виде и вмонтирует.

если же наша програ юзает библиотеку и мы при компиляции нашей проги укажем что
мы хотим чтобы наша прога юзала динамические библиотеки то тогда компилятор в теле нашей 
проге ее бинарника только сделает некие пометки а тело библиотеки небудет вклюать в тело 
нашей проги. зато потом когда прога запускется на выполнение динамический линкер 
найдет нужную билиотеку на диске или в памяти компа и "подключит" эту библиотеку как ссылку налету.

таким образом статиеская библиотекаа или динамическая определяется флагами при компилированиия
бибиотеки.  далее. статическая библиотека предназначена чтобы быть вмонтированной в тело 
программы в состав которой ее хотят включить. а динамическая библиотека предназначена для 
того чтобы загрузить ее в память компа а потом другие проги которые ее юзают при запуске динамиеским линкером будут в форме ссылки в памяти на нее слинкованы.

в чем плюс динамической библиотеки. если у нас 100 процессов и каждй юзает некую  библиотеку
то нуна только одна копия ее в памяти. а проги все которые запущены просто на нее ссылаются.

если бы у нас проги имели в своих телах эту библиотеку вмонтрованную то тогда бы в памяти 
сидело 100 копий этой библиотеки.

---------
===========================================
- как опредитедть что сидим на виртуалке 
ответ: cat /proc/cpuinfo | hyper
если есть слово hypervisor значит мы сидит на виртуаке а не реальном железном сервере
еще раз подчеркну что слово hypervisor неозначает что цпу поддверживает виртуализацию за это
ответчаюь другие флаги. этотфлаг именно означает что мы сидим под гипервизором.
====================================================

nestat
lsof
pid 
socket
network

- определить какой процесс открыл данный сетевой сокет
ответ: через netstat
$ sudo netstat -tnlp
Proto  Local Address           Foreign Address         State       PID/Program    
tcp    192.168.122.1:53        0.0.0.0:*               LISTEN      23404/dnsmasq   

видно что сокет 192.168.122.1:53 открыт проецессом с pid=23404
также замече что ключ -tnlp показывает только TCP сокеты(потому что -t = TCP. а если мы 
хотим также видеть UDP сокеты то нужно добавить ключ -u (UDP)
тоесть netstat -tnlpu
также можно это все увидеть через lsof
# lsof -i -a -n -P

- обратный вопрос. берем pid как узнать какие сетевые сокеты он открыл.
ответ через lsof

# lsof -i -a -n -P -p 23404
COMMAND   PID            USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
dnsmasq 23404 libvirt-dnsmasq    3u  IPv4 5278937      0t0  UDP *:67 
dnsmasq 23404 libvirt-dnsmasq    5u  IPv4 5278940      0t0  UDP 192.168.122.1:53 
dnsmasq 23404 libvirt-dnsmasq    6u  IPv4 5278941      0t0  TCP 192.168.122.1:53 (LISTEN)

вот еще удобная команда если знаем порт
# lsof -i:22
COMMAND  PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
sshd    1109 root    3u  IPv4 19288701      0t0  TCP *:ssh (LISTEN)
sshd    1109 root    4u  IPv6 19288703      0t0  TCP *:ssh (LISTEN)

====

про цифры
про биты
система счисления
битность
bit



скажем у нас есть система счисления то есть колчество цифр (знаков) которые мы можем 
юзать для обозначения цисла.
например у нас есть 10 знаков\цифр =  0 1 2 3 4 5 6 7 8 9

о знаках\цифрах мы договорились.

теперь смотрим сколько чисел мы можем обозначит через эту систему десяти цифр при условии
что можно использовать для обозначения числа только одну цифру. 

 ноль   = 0
 один   = 1
 два    = 2
  ...   = ...
девять  = 9

количество цифр в числе обозначим как n (битность).

получается в десятичной системе ( 0 1 2 3 4 5 6 7 8 9 ) при битности n=1
мы можем закодировать числа от ноля до девяти.

посмотрим сколько мы можем закодировать чисел если битность два n=2 (две цифры в числе)

ноль = 0
один = 1
...  = ...
девять = 9
десять = 10
....
девяносто девять = 99

итак если битность n=2 то макс число это девяность девять (99).

далее ставится важный вопрос если у нас битность n то какое макс число можно получить 
в этой битности. ответ 10^n-1

проверяем:

n=1 , макс число = 10^1-1=9 и это правильно
n=2, макс число = 10^2-1 = 99 и это правильно

это мы узнали макс число в зависимости от биности. а теперь еще хотим узнать 
не макс число а количество чисел которое мы получаем в данной битности.

для n=1 мы заметили что мы можем закодировать числа от 0 ... до 9 
и их количество равно 10

для n=2 числа будут от 0 до 99, и их колчество равно 100

далее утверждается что для битности n количество получаемых чисел = 10^n

для n=1  10^1=10
для n=2  10^2=100

далее утверждатеся что если у нас система счислений не десятичная а некая другая
например двоичная ( 0 1 ) или шестнадцатиричная ( 0 1 2 3 4 5 6 7 8 9 A B C D E F)
то 

макс (max)число для битности n = S^n-1
где S это количество знаков в системе счисления
а количество чисел (summa) закодированных в через битность n = S^n

например

S=10, n =2
max = 10^2-1=99
summa = 10^2 = 100

S=2, n=2
max = 2^2-1 =3
summa = 4

S=16, n=2
max = 16^2-1=255
summa = 256

зачем нам все это надо.
нам нужно уметь легко понимать имея некоторую битность и двоичную либо шестнадцтраричную
систему - сколько при этом будет закодировано суммаоно чисел и какое макс число.

первый практический пример.
если битность n это количество проводов. и каждый провод обозначает свой бит на шине 
адреса в памяти то нам надо знать какой адрес будет иметь ячейка с макс адресом
и сколько всего ячеек можно адресовать через сколько бит.

например

S=2, n=8
max = 2^8-1 = 255 байт (это макс адрес ячейки в памяти)
summa = 2^8 = 256 ( вот столько байт мы можем адресовать для хранения данных)

S=2, n=32
summa = 2^32 = 4294967296 байт. это 4Gb ячеек. поэтому цпу у которого 32проводка на шине
адреса может адресовать максиум 4Gb памяти.

другой пример.
в юникоде каждая буква имеет свой 4 и 5 значный номер в hex формате.

вопрос сколько букв можно закодировать при таком раскладе

S=16, n=4
summa = 16^4 = 65 536 букв

S=16, n=5
summa = 16^5 = 1 048 576 (примерно миллион)


 а если у нас S=2 и битность 7 то

 summa = 2^7 = 128 букв тогда можно закодировать через двоичную систему и 7 бит

====================================
man

цветной вывод манов на экране.
раскрасить

засунуть в ~/.bashrc


export LESS_TERMCAP_mb=$'\e[1;32m'
export LESS_TERMCAP_md=$'\e[1;32m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;31m'


====================================
man
info 
doc

на счет где искать инфо по команде варианты

первый способ
$ man name
$ man 7 name

второй способ
$ info name

третий способ
и еще в /usr/share/doc/name
полазить

=======================================
bash
type

полезная штука чтобы узнать та команда
что мы вводим она встроенная или внешняя

$ type -t gcc
file
$ type  gcc
gcc is /usr/bin/gcc
$ type -t env
file
$ type -t type
builtin
$ type -a type
type is a shell builtin
$ type -a gcc
gcc is /usr/bin/gcc
$ type -a printf
printf is a shell builtin
printf is /usr/bin/printf

чтобы незапоминать ключи лучше всегд посмотреть в man bash

=======
bash
hash
type

оказывается что каждый раз когда мы вводим команду в баше
он ее ищет в $PATH ( и это понятно) но потом самое главное он найденный путь запоминает.
и уже при повторном вызове.

посмотреть можно через hash (bash builtin) 

$ hash -l
hash: hash table empty

$ env

$ hash -l
builtin hash -p /usr/bin/env env

$ gcc

$ hash -l
builtin hash -p /usr/bin/gcc gcc
builtin hash -p /usr/bin/env env



следущая задача. мы хотим понять вот у нас есть команда . мы хотим понять 
где она лежит на диске а точнее откуда ее будет брать basр при запуске.
If you want to see the path to your program i suggest to use "$type -p" :

$ type gcc
gcc is hashed (/usr/bin/gcc)
$ type -p gcc
/usr/bin/gcc
-p key description:

If the -p option is used, type either returns the name of the disk file that would be executed if name were specified as a command name, or nothing if ``type -t name'' would not return file

Sometimes -p key is not enough. -a key will help:

$ type -p printf
$ type -a printf
printf is a shell builtin
printf is /usr/bin/printf


далее вот у нас есть команда мы хотми понять это встроенный в баш builtin 
или это внешнаяя команда используем type -t



$ type -t echo
builtin

ключ -p показывает где на диске баш будет искать команду
но так как echo это встроеный builtin то ключ -p покажет пустое место
$ type -p echo

а вот так как gcc это уже внешняя команда  то ключ -p покажет где ее будет брать bash
$ type -t gcc
file
$ type -p gcc
/usr/bin/gcc

если мы хотим проверить то что программа является и билтином и внешней командой
то ключ -a

$ type -a echo
echo is a shell builtin
echo is /bin/echo


это показывает что echo есть как в форме внешней команды 
так и внутри в баш в форме builtin

кстати. вот видно что у баш есть свой билтин echo. но это незначит что если мы напишем

$ strace echo ...

то будет исползован баш билтин. команда strace походу недогадывается об этом поэтому
она запустить внешний echo. 

============
bash
help
builtin

если у нас есть какойто builtin из баша
и мы хотми по нему прочитаь справку  один вариант это man bash и там листать вниз 
до описания билтина а второй вариант

$ help имя_builtin

пример

$ help type

=============
unset 

что она делает.
это bash builtin. 

она уничтожает обьявленную переменную баша.

тоесть

создали переменную в баше
$ ww=10
$ set | grep ww
ww=10

удаляем эту переменную
$ unset ww
$ set | grep ww

инфо об unset ищи в man bash

===
bash
readonly

в баш можно назначать ридонли переменные
для этого есть всторенный билтин reeadonly.
кстати он может покзаать спмсок ридонли переменных ключ -p

$ readonly -p

declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath"
declare -ir BASHPID
declare -ar BASH_REMATCH=()
declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
declare -ir EUID="1000"
declare -ir PPID="3866"
declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor"
declare -ir UID="1000"


=================
$ echo $BASHPID
15962
$ echo $$
15962
=================

bash
builtin 
fc


встроенная команда fc
позволяет выдать список команд без номера.
типа аналог history

показать последние 10 команд
$ fc -l -10
2008	 ls
2009	 fc -l -10
2010	 fc -l -100
2011	 fc -l -10
2012	 ls -1
2013	 ls 
2014	 ls -1
2015	 ls
2016	 fc -l -10
2017	 ls -1


но еще она умеет выполнять команды из history.
выполнить все команды из history начиная с команды номер 2014
$ fc -s 2014

справка по fc

$ help fc
$ man bash



=====
bash 
subshell

обозначается как
$ ( command1; command2...)

перед тем как отвечать на вопрс что такое субшелл и зачем оно нужен ответиим на другое.
вот у нас есть сеанс баш это процесс. и в мы в нем запускаем внешнюю команду. что при этом
происходит. баш себя клонирует в новый процесс. потом в новом процессе запускается execve с бинарников внешней команды. далее поскольку это новый процесс независящий от парент процесса
то чтобы ни делалла внешняя команда в новом процессе это никак невлияет на наш исходный баш процесс. никак. 

если мы в текущем сеансе\процессе баша запустим невнешнюю команду а builtin то баш себя
форкать небудет а будем выполнять эту команду в текущем процессе. со всеми вытекающими. какими? например мы с помощью builtin меняем некоторую переменную. и она в итоге будет изменена в текущем сеансе баша. 

а теперь вопрос- а если мы хотим запустить bash builtin но чтобы при этом он смоге поменять 
ничего в нашем текущем процессе баша (переменные и все остальное) - вот для этого и исползуется
субшелл.

что такое субшелл. это баш берет и клонирует себя (форкает). но далее execve он невыполняет в дочернем процессе. действительно а зачем если дочерний процесс уже баш. таким образом с одной стороны дочерний бащ (он же субщелл) получит в наличие все переменные котрые были в парент процессе с другой стороны чтобы ни делалось в дочернем процессе оно уже никак не полвияет на парент процесс. так вот далее в дочернем процессе выполняются все команды которые находятся в скобках.

$ ( command1; command2...)

естствеенно что если в скобках у нас одни buitin то они будут выполенны все в субщелл процессе
а если там есть внешние команды то субшелл еще раз форкнется и выполним execve в дочернем от себя процессе. но важно то что если в субшелле только buitin команды то они максимум могут 
поменять переменные в субшелле а в парент процессе они ничего поменят немогут. 
Итак еще раз если у мы запускаем внешнюю команду то она в текущем баше поменять точно ничего
неможет потому что баш выполняет внешнюю команду через fork+execve тоесть в новом дочернем процессе. так что внешнаяя команда никогда ничего в нашем баше поменять неможет. а вот билтин
команда выполняется в текущем процессе баша и она может много чего поменяь в текущем процессе баша например каккуюто переменную. если мы нехотим этого. если  мы хотим себя от этого 100% предохрнаить то надо запустить билтин команду в субшелле. ради этого субшелл и былпридуман.

пример

$ qq=10
$ echo $qq
10

в первой строке вы запустили билтин. и он нам создал\изменилт переменную в нашем 
текущем процессе.


$ echo "текущий процесс pid=$BASHPID. qq=$qq"; ( echo -n "субшелл pid=$BASHPID. "; qq=20; echo -e "qq=$qq"); echo "текущий процесс pid=$BASHPID, qq=$qq"

текущий процесс pid=20328. qq=10
субшелл pid=21200. qq=20
текущий процесс pid=20328, qq=10

мы видим что в парент процессе qq=10
в субшелл процессе мы поменяли и qq=20
однако после этого в парент процессе qq по прежнему равен 10.

вот для этого и был придуман субшелл. тоесть если мы хотим 100% быть уверенными что 
наши buitin команды неизменят наш текущий процесс то тогда их надо засунуть в субшелл.


Также можно заметить что я использовал $BASHPID а не привычный $$. почему?
потому что - согласно практике выянилось что переменная $$ невсегда показыает коректный pid процесса.

пример

$ echo $$
21006
$ (echo $$)
21006

что за херня. ведь мы же знаем что субшелл это новый процесс.почему одинаковый pid покзывает.

пробуем другой способ

$ echo $BASHPID
21006
$ (echo $BASHPID)
21092

вот уже похожде на правду.

вот что man bash нам пишет про $ и BASHPID:

 $      Expands to the process ID of the shell.  In a () subshell, it expands to the process ID of the current shell, not the subshell.

 BASHPID
              Expands to the process ID of the current bash process.  This differs from $$ under certain circumstances, such as subshells that do not require bash to be re-initialized.

таким образом даже в мане написано что $$ в субшелле показывает неверный pid процесса.
а BASHPID всегда показыает верный pid процесса. а мы и работаем в субшелл поэтому я 
использовал BASHPID которы всегда показывает верный pid процесса.

далее про субшеллы - нашел в man bash фразу:
 Builtin commands that are invoked as part of a pipeline are  also  exe‐
       cuted in a subshell environment.  Changes made to the subshell environment cannot affect the shell's execution environment.

тоесть если у нас есть pipe между builtin то они оба выполняются не в текущем процессе
а оба выполняются в отдельных субшеллах. это важно . я проверил через strace и это подтвердиолось.
пример

$ ds=10 | echo $ds

$ echo $ds


как видим везде пусто. а теперь обьяснение.
первая строка. у нас есть два билтина и они разделены пайпом. раз есть пайп то как мы уже прочитали в man то что делает наш баш. он берет клонирует себя два раза из текущего состояния.
тоесть текущий баш имеет pid=12,
создается pid=13 и pid=14 и вывод из pid=13 прписывается в ввод pid=14,
далее в pid=13 запускается ds=10 
и в pid=14 запускается echo $ds

тут важно понять что pid=13 и pid=14 получены из pid=12 на момент когда там небыло никакого
ds=10. дададада! дело в том что ds=10 будем запущен в pid=13 а pid=12 неимеет никакого понятия об ds=10.

итак еще раз. мы имеем пустой pid=12 наш головной баш. в нем нет переменной ds=10.
потому что эта команда она еще небыла запущена мы ее только собираемся запускать.
далее мы ввели две команды через пайап и тыкнули энтер. баш эти команды невыполняет. нет.
он вначале себя клонирует два раза. поэтому и головной баш и его два клона они абсолютно
одинаковы в том плане что в них пока нет никакого ds=10.
далее уже в дочернем процессе pid=13 баш запускает то что слева от пайпа тоесть ds=10. и там он появляется. в pid=14 он запускает echo $ds но pid=14 неимеет никакого ds у себя поэтому выовод первой строчки пустой! также так как вывод ds=10 пустой то совершенно неимеет роли что вывод из pid=13 направлен на ввод pid=14. тем более что echo он ничего нечитает из станадартного ввода. вот из за всего этого вывод первой строчки пустой! таким образом пееременная ds=10 она будет создана только в pid=13 но ее небудет ни в pid=12 ни в pid=14.
и именно из за этого вторая строка тоже пустая! потому что в pid=12 нет никакого ds=10 !

вот как ! и все это именно из за того что если мы имеем пайп то команда слева и справа обе будут запущены в отдельных процессах и неважно это внешние команды или builtin. таким образом builtin невсегда выполняется в текущем процессе! вот это я и хотел показать!

я проверял через strace что билтины справа и слева дейтсвительно запускаются в
 отдельных процессах

=================

bash

{ ..;}

такие кавычки это просто визуальная оформлялка группировка команд.
тоесть что есть эти кавычки что их нет. все равно. команды внутри этих ковычек исполняются
в текущем процессе если это билтины.

$ echo $BASHPID
23616
$ { echo $BASHPID; }
23616

вот. видно что и так и так это один процесс

чем она еще удобна  - тем что можно удобно вводить много строчные команды  неиспользуя знак "\"

$ { echo 1;
> echo 2;}
1
2


==================

bash

(( ... ))

двойные скобки.

это билтин.предназначены для вычисления арифметических операций.
неимеют ничего общего с одинарными скобками которые субшелл.
в мане написано что расчеты идут исходя о том что операнды это fixed-width integers.
это точная копия билтина let "expression" 

сразу скажу про let
let "expression" это полный аналог (( expression )) 
при использовании let обязательно  нужно использовать двойные кавычки иначе будет мудота потому что иначе нужно будет экранировать спецсимволы а это ужасно неудобно
ненужный оверхед которого нет у двойных скобок.

$ let  "5>4"  && echo "5>4   # проходит без проблем
$ let  5>4  && echo "5>4"    # ошибка
bash: let: expression expected
$ let  5\>4  && echo "5>4"   # прошло но нужно экранировать
5>4

что интересно в man bash про let совсем неуказано что нужно юзать двойные кавычки.
там сказано что 
 let arg [arg ...]
а в man bash про двойные кавычки (ищи по слову compound) там указано что  (( expression))
это полная аналогия let "expression". тоесть описание двойных кавычек как бы намекает что в let надо использовать двойные кавычки.
также прикольно то что если у нас двойные кавычки (()) то понятно как напечатать на экран
их резултат
$ echo $(( 3+ 5))
8

а как распечатать на экран если мы спользуем let я непонимаю
$ echo let "3+5"
let 3+5




двигаем дальше
поддерживаются все простые мат операции +-*/^

$ (( 3+5 ))
$ (( 3-5 ))
итп

но вывода никакого нет на экран.так что в таком виде от команды мало толку. единственное что
если внутри сравнние что можно использовать то что команда возвращает резульатат 0 или 1 в зависимости от того true внутри или false

пример
$ (( 5 > 4 ))

результатом будет код возврата либо 0 либо 1

$ (( 5 > 4 )) && echo "5>4"
5>4

теперь переходим к выводу на экран.
$ echo $(( 3+5 ))
8
наконец получили вывод на экран.


также важно отметить что внутри скобок (( )) если мы обращаемся к переменной то 
знак доллара ненужен. это первая особенность (( )) и переменных внутри них.
$ n=10; (( n+1 ))

еще важный момент про (( )) и переменные это то что часть команд неменяет переменные(что логично) а часть команд внутри (()) меняет переменные! это вторая особеность двойных скообок и переменных внутри них.

щас я приведу команды которые меняют переменные внутри скобок
= *= /= %= += -= <<= >>= &= ^= |=
и  id++ id-- ++id --id
я щас ниже обьясную что каждая команда значит. важно главное щас понять что 
если знак равно испольуется то переменная будет изменена. а если знака равно  внутри нет
значит переменная небудет изменена. но есть одно исключение вот эти команды 
id++ id-- ++id --id они хотя и неимеют знака "=" но они меняют переменную.
начинаю расшифрроввывать что эти команды значат


			 id++ id--
              variable post-increment and post-decrement
       ++id --id
              variable pre-increment and pre-decrement


$ n=16; echo $(( n++  )); echo $n
16
17
$ n=16; echo $(( ++n  )); echo $n
17
17

как видно переменная изменилась, причем знака "=" нет и также обращение к переменной 
идет без знака доллара.


разницы между этими командами нет в конечном итоге
на переменную. есть разница в выводе echo (пока незнаю почему)

тоесть видно что пеерменная n=17  вобоих случаях( и это главное). но echo покажет разный результат.(это второстепенное хотя и любопытно)

еще раз подчеркну что переменная меняется при этом к ней обращение идет без знака доллара $
и без знака "="
$ a=2334
$ (( a++ ))
$ echo $a
2335


еще пример на эту тему
$ a=2334
$ (( a=a+1 ))
$ echo $a
2335



расшифровываю операции:
       = *= /= %= += -= <<= >>= &= ^= |=
              assignment


рассмотрим первое =
$ echo $(( a=5 ))
5
$ echo $a
5

тоесть это просто операция присваивания

дальше интереснее *=
фишка этого обозначения в том что это операция умножения и присвоения одновременно.
тоесть

(( a*=5 )) эквивалентно (( a=a*5 ))

пример
$ a=10
$ echo $(( a=a*10 ))
100
$ echo $a
100
$ a=10
$ echo $(( a*=10 ))
100
$ echo $a
100

отсюда видно что я доказал что (( a*=5 )) эквивалентно (( a=a*5 ))

Так вот далее по аналогии все оставшиеся операции /= %= += -= <<= >>= &= ^= |=
это арифметическое действие и присвоение. тоесть 

/= это деление и присвоение
%= нахождение остатка и присвоение
+= суммирование и присвоение
-= отнимание и присвоение
<<= это сдвиг влева на некоторое число бит и присвоение
>>= сдвиг вправо и присвоение
&= битовый AND и присвоение
^= битовый XOR и присвоение
|= битовый OR и присвоение

примеры
деление и присвоение
$ a=10
$ echo $(( a/=5 )); echo $a
2
2

остаток от деления и присвоение
$ a=10
$ echo $(( a%=3 )); echo $a
1
1

сумммирование и присвоение
$ a=10;echo $(( a+=3 )); echo $a
13
13

отнимание и присвоение
$ a=10;echo $(( a-=3 )); echo $a
7
7

сдвиг влево и присвоение
$ a=3;echo $(( a<<=1 )); echo $a
6
6

обращаю внимание что при сдвиге слева новый бит он нулевой 
тоесть 
было   11
стало 110

сдвиг вправо и присвоение
$ a=15;echo $(( a>>=1 )); echo $a
7
7

было 
1111
стало
0111


битовый AND и присвоение
$ a=15;echo $(( a&=6 )); echo $a
6
6

тоесть 
15=1111 AND 
 6=0110 
---------
   0110 


битовый XOR и присвоение
$ a=15;echo $(( a^=6 )); echo $a
9
9

тоесть 
15=1111 XOR 
 6=0110 
 -------
   1001 

битовый OR и присвоение
$ a=15;echo $(( a|=6 )); echo $a
15
15

тоесть 
15=1111 OR 
 6=0110 
 -------
   1111


далее. еще обращаю вимание на важный момент:
 операции id++ id-- они увеличивают\уменьшениют на один значение переменной
и переприсваивает это значение этой переменной
несмотря на то что id++ id-- не имеет никакого знака равно как скажем вот здесь "+="
тоесть помне было бы более правильно если бы вместо "id++" было "id++="
это совпадало бы по синтаксису с *= /= %= += -= <<= >>= &= ^= |=
из этого  я бы  сформулировал правило о том что переменную меняет только 
та команда у которой есть = за исключением id++ id-- они меняют переменную хотя
в себе несодержат =
нам очень важно понимать поменяет ли (( выражение)) переменную внутри или нет.

примеры на эту тему
здесь пример меняет переменую потому что есть знак =
$ a=15;echo $(( a*=6 )); echo $a
90
90

вот пример где значение перменной меняется хотя знака "=" нет
также интересно отметить что echo $(( a++ )) возвращает 15 а не 16
$ a=15;echo $(( a++ )); echo $a
15
16

меняем переменную потому что здесь есть "="
$ a=15;echo $(( a=16 )); echo $a
16
16

еще хороший пример. значение перемменной неменяется потому что нет знака "="
$ a=15;echo $(( a>>1 )); echo $a
7
15

а вот пример когда уже битовый сдвиг плюс переприсвоение переменной происходит потому что 
есть знак "="
$ a=15;echo $(( a>>=1 )); echo $a
7
7

операции которые еще поддерживаются:
       - +    unary minus and plus

что такое унарная мат операция. это операция которая требует только один аргумент 
( в отличие от обычной мат операции которая требует два аргумента).
по факту унарный минус это такая операция которая делает то что если у нас есть
какой то аргумент то унарный минус из него создает число противоположное. тоесть
было 2 стало -2. было  -2 стало -(-2). унарный плюс вобще по мне нихера неделает ибо
он ничего неменяет. унарный минус и плюс это операция высшего порядка выполняется первой.
примеры
$ n=10; echo $(( -n ))
-10

$ n=-10; echo $(( -n ))
10
важно отметить что сама переменная n неменяется.

как баш отличает унарный минус от бинарного(стандартного ) минуса.... хм.. незнаю.
но вот пример
$ n=-10; echo $(( 1 - -n ))
-9

здесь один минус бинарный а второй унарный. по сути мы имеем 1- -(-10)=1-10=-9




следущая операция:
       ! ~    logical and bitwise negation
переходим к булевым операциям и битовым операциям одноврмеенно

по поводу двойных скобок в man bash сказано - If the value of the expression is non-zero, the return status is 0; а 0 это булевский TRUE.
таким образом если у нас неноль то код возврата TRUE
примеры
$ (( 1 )) && echo true || echo "false"
true
$ (( 100 )) && echo true || echo "false"
true
$ (( -100 )) && echo true || echo "false"
true
$ (( 0 )) && echo true || echo "false"
false
$ (( 5>4 )) && echo true || echo "false"
true
$ (( 5<4 )) && echo true || echo "false"
false

так вот ! это булевский NOT

$ (( ! 1 )) && echo true || echo "false"
false

важно то что ! нельзя  ставить вполтную к числу  обязатеьно отдельно.
$ (( !1 )) # здесь получаем ошибку
bash: !1: event not found

еще пример
$ (( ! 5>4 )) && echo true || echo "false"
false

переходим к "~" bitwise negation тоесть эта операция которая унарная кстати и она что делает
она берет число в бинарном виде и нули превращает в единицы а единицы в нули.
скажем было 0000 стало 1111.

закончил вот на этом
$ echo $(( ~ 0 ))
-1
$ echo $(( ~ 1 ))
-2
$ echo $(( ~ 100 ))
-101
типа что за прикол? 
============================
============================
щас будем разбирать. 

начнем с того как на компе кодируются отрицательные числа.
во первых надо понять что в конечном итоге все данные на компе имеют вида байта или нескольких байт тоесть это некоторый кусок битов. 01010101010101010101010101010
поскольку все операции идут  в цпу то будем рассматривать в качестве хранилища этих битов регистр общего назначения в цпу. 32 бита или 64 бита. будь это отрицательное для нас число 
или положительное внутри регистра в любом случае никакого знака минус небудет. там будет сидеть 32 либо 64 бита нулей и единиц 010101010101010101001.

разберемся какой вид имеет отрицательное для нас число внутри регистра.
вопросы: 
"понимает" ли цпу какое число в его регистре положительное или отрицательное?
навскдку действительно непонятно как обьяснять цпу или он сам это понимает отрцательное
число лежит в регистре или положительное?
как цпу работает с отрицательными числами как он арифм операции с ними выполняет?
начнем разбирать.

section .text
global _start

_start:
    mov ax, 0xA1
    sub ax, 0x30


    xor rdi, rdi
    mov rax, 60d
    syscall


тут я вспоминаю что 16 битный регистр AX состоит из двух 8битных регистров AH и AL
        AX
------------------
| AH    |   AL   |
------------------

из программы я увидел что AL это дейтсвиельно младший байт в AX
(gdb) print /x $ax
$3 = 0xa1
(gdb) print /x $ah
$4 = 0x0
(gdb) print /x $al
$5 = 0xa1


тоесть поскольку 0xA1 это 8битное число. то оно должно быть загружено в младший байт
и мы видим что AH=0 а AL=0xa1

после операции substraction
мы имеем

(gdb) print /x $al
$6 = 0x71

(gdb) print /t $al
$9 = 1110001

$ echo "obase=16;ibase=16; A1-30" | bc
71

$ echo "obase=2;ibase=16; 71" | bc
1110001


здесь все понятно все ожидаемо. A1 > 30 поэтому результат точно положительный. 
здесь пока все понятно. бинарный вид ответа полностью понятен. 

теперь отнимем наоборот 0x30-0xA1 тоесть от меньшего числа отнимаем большее число.результат заведомо отрицательный.

кстати вот флаги после SUB операции:
(gdb) info registers eflags
eflags         0x206	[ PF IF ]


итак отнимаем 0x30-0xA1
смотрим состояние регистров после операции SUB
		 0x0000000000400080 <+0>:	mov    ax,0x30
=>	 0x0000000000400084 <+4>:	sub    ax,0xa1


(gdb) print /x $al
$3 = 0x8f

(gdb) info registers eflags
eflags         0x293	[ CF AF SF IF ]

0x30=00110000
0xA1=10100001

отнимаем
	00110000
	10100001
  ---------
 я вычитать бинарно неумею но комп на выдал в качестве ответа
  10001111

поступим от обратного. прибавим ответ к вычитаемому

10001111
10100001
---------
00110000

в итоге да мы получили то число из которого вычитали.
правда происходит активация флага переполнения.
итак стало понятно что делает комп когда вычитает большее число из меньшего.
он срабатывает как одометр на машине.

мы отнимали 0x30-0xA1 это  48-161. комп по идее должен был отработать при отнимании
как одометр. тоесть идея какая мы имеем счетчик на 48км и нам надо проехать 161 км.
и одометр работает в обратную сторону. тоест машина проедет 48км счетчик при этом станет 0.
и потом он начнет откручиваться в обратнку сторону еще 161-48 км = 113км и счетчик будет показывать вначале 0 потом 255(max число для 8бит регистра) потом 254 итд.
значит в итоге счетчик  должен показать 255-113+1=143
сверяем с ответом от цпу . его ответ 
(gdb) print /x $al
$3 = 0x8f

0x8f = 143(dec)
совпало!

теперь стало совершенно понятно как в цпу работает побитовое отнимание. 
оно работает как одометр машины который крутится в обратную сторону когда едет машина.
тут важно отметить что через регистры общего назначения происходят арифметически операции
для целых чисел с точки зрения цпу. ну или давай скажем так цпу незнает ни что такое целые
числа ни что такое с плавающей точкой ни что такое числа положительные ни что такое числа
отрицательные. для него этого ничего нет. у него только есть регистры с битами.
далее мы натарвливаем команду на цпу такую как SUB подсоввывая в качестве источников данных
биты из регистров общегон назначения и цпу далее манипулирует битами в этих регистрах 
согласно некоторых микросхемам транзисторов внутри. для цпу суть операций выглядит в том
что он берет оттуда биты маниплирует ими и обратно помещает некотрый набор битов вот и все.
для цпу нет никаких чисел у цпу нет таких абстракций. у него есть набор битов и он ими должен както сманипулировать согласно команде которую ему указали. на выходе получает набор битов.
а дальше это уже наше дело человека както интерпретировать эти биты.  так вот получается
что если каждый бит в регистре цпу мы уже как человеки будем ставить в соотвествие с цифрой на одометре(просто одометр с бинарными цифрами 0 и 1 а не  с десятичными 0 1 2 3 4 5 6 7 8 9) то мы увидим что данные биты кодируют целые положительные числа. есть прямое соотвествие.
тоесть создатели цпу они так внутри создали микросхемы что биты в регистрах общего назначения
имеют смысл целых чисел  через двоичную запись при условии что мы над ними выполняем
арифметические операции. тоесть при запуске команды 
	sub ax, 0xA1
цпу так запрограммирован изнутри что биты начинают иметь физический смысл целых чисел 
положительных. и над ними производится операция вычитания.
итак еще раз ответ на вопрос есть ли внутри цпу целые числа или положительные числа
или отрицательные числа - внутри цпу есть биты. биты это как лампочки на елке 
это просто биты просто лампочки висящие на грозди. они в целом к числам неимеют отношения.
так же как пять слонов стоящих вряд они к числу 5 неимеют отношения прямого. это мы люди
делаем такое абстрактное соотношение.  но создатели цпу так настроили эти биты что 
в целом есть прямая связь между положительными целыми числами в двоичном формате 
и битами в регистре. пример
mov ax, 0xA1

здесь мы говорим чтобы в регистр AX было записано число. но число это абстрактное понятие в голове людей это не банан не апельсин это обьбект которого нет в природе в физ форме в физ виде. это либо клякса на бумаге либо картинка в голове у человека. у цпу нет мозга так что 
когда мы просим  в цпу записать число по факту мы просим в регистре активировать определенные
биты которые физически представляют собой какито транзисторы с какимто физ характеристиками
которые мы там хотим выставить. но вот если мы представим что внутри цпу есть биты
и если мы соотнесем биты в цпу с битами на бумаге у чисел в двоичной системе то тогда
мы как бы можем сказать что внутрь цпу было записано число. 
теперь надо понять а что за числа мы можем записать в регистр. 
мы видим в команде число 0xA1. это шестнадцатеричное число. но еще раз хочу подчеркнуть
что мы нечисло пихаем в регистр. просто hex число это удобная форма для записи на бумаге
для програмирования того факта что мы просим в регистре активировать биты. тоесть
 в под капотом наша команда 
mov ax, 0xA1
она просит выставить биты
mov ax, 1010 0001

просто в битовой форме было бы неудобно писать команды.
так вот возникает вопрос можно ли как то наладить соотвесвтие между битами 
и числами. если мы будем использовать двоичную систему счисления чисел то она 
волшебным образом совпадает с битовой картинкой.

поговорим про двоичную систему счисления.
система счисления это система обозначения числа.
десятичная система выглядит так

12356 = (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0

таким образом привычная нам форма записи числа это на самом деле коэффициенты
многочлена.прикол.

так вот в двоичной системе число обозначаетс вот так и вот его какой смысл
этого обозначения:

01010 = (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0

отрицательное число в одной и другой системе счисления(дурацкое слово лучше бы слово 
обозначение использовали)

-12356 = - { (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0 }
-01010 = -  { (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0 }

как мы видим в двоичной системе счисления в математике также спокойно есть знак минус.

теперь обозначение чисел с плавающей точкой

12356.23 = [ (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0 ] +[ (2)*10^-1 + (3)*10^-2 ]
 + 
и точно тоже самое для двоичной системы счисления!

01010.01 = [ (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0 ] + [ (0)*2^-1 + (1)*2^-2 ]

как видим в математике в двоичной системе счисления нет проблем ни с минусом ни с 
дробными числами!

возвращаемся к цпу. создатели цпу что касается регистров общего назначения они ( я утверждаю )
запрограммировали так обработку битов внутри цпу что они представляют собой ровно теже биты теже коэффициенты в многочлене что и биты в двочиной системе обозначения числа за исключением
того что никакой внутри цпу хрени которая бы отвечала за знак минус нет и никакой хрени 
которая бы отвечала за дробную часть числа в двоичном представлении тоже внутри цпу 
нет при условии что мы говорим про регистры общего назначения.
таким образом биты в регистрах общего назначения можно соотнести с числами обозначаемыми 
через двоичную систему счисления\обозначения при условии что у нас нет знака минус и что нет дробной части. тоесть мы получается говорим только про целые положительные числа.
вот это вот и есть физический смысл битов внутри регистров общего назначения!
таким образом регистр общего назначения по своему физ смыслу это всегда целое положительное
число записанное в двоичной форме! и создатели цпу настроили схемы обработки битов внутри 
этих регистров как обработку чисел. поскольку битвая форма регистра нам позволяет 
обозначить только число положительное ибо минуса в цпу нет носителя и также в регистре 
нет носителя дробной части (регистры общего назначения) то поэтому математические\арифеметичекие операции могут иметь место только по своему физическому смыслу
только с целыми положительными числами. тоесть регистр по своей природе через себя может 
показать только целое положительное число в двоичной форме. никакого другого числа регистр общего назначения показать неможет у него нет для этого носителей минуса и дробной части.
теперь мы поняли\доказали что физ смысл битов в регистре это биты числа в двоичной системе обозначения\счисления причем это число получается является только положительным 
и только целым. 
в самом деле вот берем число -01010101.0101010
оно и отрицательное и дробное мы его никак в регистр всунуть неможем ибо у регистра
нет ни носителя "-" ни носителя дробной части. я говорю о регистре общего назначения.
так создатели цпу и сделали! ну а раз нет внутри регистра ни носителя минуса ни носителя
дробной части то внутренние схемы цпу они рассматривают биты регистра как целое положительное
число и никак иначе.
в самом деле как может быть результатом арифмт операций над двумя положительными целыми
числами отрицательное дробное число если этот резулльтат надо записать запихать в этот же регистр а у него нет таких хреней носителей чтобы отобразить минус или дробную часть.
поэтому как работает операция вычитания на общих регистрах. если одно число больше другого
то все биты обнуляются а потом они в обратном порядке отматываются то есть в точности как работает одометр в намашине если его крутить в обратном направлении.тоже самое касется сложения двух чисел кога результта превышает битность регистра. регистр доходит до макс значения потом обнуляется и начинает заново набирать. точно как одометр.
таким образом между цпу и регистром и математичкой двоичных чисел есть соотвествие но неполное. в математике если из меньшего вычесть большее то появляется минус. в цпу
происходит нечто другое. тоже самое касается деления или случая когда результат превышает
битность исходных чисел. во всех этих случаях между математичкой и цпу нет соотвествия.
цпу ведет себя тут кастомно.  в случае сложения и вычитания он ведет себя как одометр.

- более детально прояснить еще раз физ смысл результата сложения 
реультат прервышает битность регистра

что касаетя операции сложения то тут точно схемы цпу настроены так что 
биты регистра обрабатываются ALU цпу в точном соотвесвтии с логикой сложения целых положительных числе в двочином обозначении. только еще есть вот такой момент - 
вот мы складыаем 200 и 255. 200 уже лежит в регистре а 255 мы к нему прибавляем.
регистр максимум может нести на себе число 255. так вот
цпу он докручивает регистр с 200 до 255. потом он его обнуляет и потом еще его докручивает
прибавляет  к нему такое число чтобы суммарная докрутка от 200 до 255 и потом от 0 до числа X 
составила бы число 255 которое мы прибавляем. вот каков физ смысла того числа в регистре которое мы получаем при операции суммирования когда ответ превысил бы битность регистра.
для операции вычитания тоже самое только одометр откручивается в обратную сторону.

итак в случае арифм операций над регистром его биты обраюатываются цпу в точности такойже
как обрабатывались бы биты двоичного положительного целого числа!
тоесть в случае арифм операций биты в регистре это непросто биты а символы в двоичной записи для целого положительного числа. так их обрабатывает ALU цпу и результат арифмт операции 
записыватся в биты регистра в точности как выглядела бы двоичная запись результата (если результата невызывает ситуация переполнения). если переполнение то я описал выше.


теперь оставим случай арифм операций и рассмотрим просто операцию записи в регистр
	mov ax, 0xA1
можно ли в этом случае сказать что биты  в регистре соответвуют символам в двоичном
числе. 0xA1 это целое положтельное число записанное в шестнадцатеричной форме которое затем
комп преобразует в целое положитеьное число завписанрое в двоичной форме и согласно этой форме
цпу выставляет биты. поэтому из этого  я считаю что нетолько в случае арифм операций но и в случае записи числа в регистр обшего назначения его биты можно трактовать как символы двоичной записи числа получается что и в этом случае это положительное целое число записанное в двоичной форме в регистр в форме битов.

таким образом на мой взгляд биты внутри регистра общего назначения это непросто лампочки
это реально всегда целое положительное число. так их можно всегда трактовать. 

отсюда следует вывод что для работы с отрицательными числами или дробными числами регистры обшего назначения непригодны. и чтобы нам както работать например с целыми отрицатеьльными
числами на  базе регистра нам нужно както дополнительно изголяться.  это похоже на то что у нас есть экран телевизора но входной сигнал это азбука морзе поэтому нам нужно както получая азбуку морзе самим руками ее преобразоывать в картрнку на экране и наоборот. имея картинку на экране нам нужно ее както самим трансфорировать в азбуку морзе и уже именно ее пихать в радиоэфир. также и программа если она хочет работать с отрицательными числами то ей както надо
изголиться чтобы это делать на базе исключительно только положительных чисел с которыми работает цпу на базе регистра. его ALU микросхемы.

нутоесть для примера опишу работы с дробными числами. вот наша програма хочет сложить
1.23 и 2.45. как ей это сделать на базе регистров общего назначения и блока ALU цпу который умеет только складывать целые числа. программа должны вначале сунуть в регистр дробную часть
и потом прибавить к ней другую дробную часть

mov ax,23
add ax,45

далее прогармма должна считать эту цифру. далее также сложить целые части

mov ax,1
add ax,2

считать это число. и отобразить на экране 3.78
таким образом на базе целых положительных чисел мы провернули операцию сложения дробных чисел.

похожую мудоту программа должна суметь сделать для отрицательных чисел.


итак еще раз важный вывод микросхемы цпу настроены так что они обарабывают биты регистров
общего назначения (особенно во время арифм операций. кстати говоря арифм операция уже по крайней мере подразумевает что мы работаем с числами а не лампочками) как обрабатываются биты
у целых положительных числе в двоичном исчислении. каждый бит регистра соотстветует биту
в двоичном числе. это очень важный вывод. ( а то я тут встречаю выскзывания что цпу понятия не имеет ни о числах ни очем . мол у него просто идет обработка битов. обработка битов да но логика обработки этих битов вточности следует обработке битов у аналогичного двоичного числа!
поэтому биты внвутри регистра общего назначения это непросто биты это целое положительное 
число в двоичном виде!
)

а как же нам тогда на практие складывать числа результат сложения которых будет больше
чем размер регистра например

100+200.

первый вариант так как мы будем иметь высталвенный на цпу флаг переполнения то мы можем
просто слать нахер тогда в порграмме. мол слишклом большие числа.
точно незнаю но можно вот как. мы словим флаг переполнения и получим число в регистре 44
( потмоу что регистр со 100 докрутит до 255 потом обнулит и еще докрутит до 44).
и тогда можно на экране в простейше случае вывести мол ответ это 255+44+1.
плюс один это потому что был переход с 255 на ноль. он сьел одну единицу.
где 255 это макс число для регистра 8бит мы его знаем заранее из размера регистра
и 44 мы получили лажещим в регистре.да конечно это неконечный красивый ответ но почти ответ
лучше чем ничего.

переходим к отрицательным числам.
10-200

mov al,10d
sub al,200d

 в результате в al будет лежать 66d (вначале окрутится 10 до нуля. потом ноль до 255 и потом еще до 66. всего будет прокручено на -200)

как нам из полученного результата +66 понять что ответ -100 пока непонятно.

пока оставим и передвигаемся  к теме как мы сами для себя ( не цпу а именно мы) могли бы
обозначать отрицательные числа используя для этого положительные числа цпу. тоесть энкодинг 
отрицательных чисел сугубо для нашей пользовательсктй программы используя положительные
числа цпу. 


один вариант это взять старший бит и кодировать  отрицательное число через  выставление старшего бита  в 1. а оставшиеся биты использовать для абсолютного значения.

тогда можно иметь такую кодировку

1001 = -1
1010 = -2

такой тип кодирования назыается "Sign-Magnitude representation".
переводится примерно как "кодирование по схеме знак-величина"

получается что мы при таком кодировании
цпу видит биты 1001 как число 9 наша же программа для себя понимает это как число -1
цпу видит биты 1010 как число 10 наша же программа для себя понимает это как число -2

сразу про минус такого кодирования. 
мы неможем выполнять арифметические операции на цпу для наших чисел потому что с точки 
зрения программы мы складываем -1 + -2  а точки зрения цпу мы будем складывать 9 + 10
ну и вот посмотрим что мы будем получать. 

1001
1010
-----
0011 с флагом переполнения
 
с точки зрения цпу мы получили число +3. с точки зрения нашей программы мы тоже получили 
число +3 потому что старший бит неравен единице. по модулю правильно по знаку неправильно.
но по идее наша программа может учитывать
то что сработал флаг переполнения и это может быть нашей программе сигналом что число получено
отрицательное а не положительное.

а вот еще пример тогда рассмотрим.

1001 = -1
0010 =  2

сложим
1001
0010
----
1011

получили с точки зрения цпу 11 с точки зрения программы получили -3 а должны же были 
получить +1

так ну походу приходим к выводу что получать верные ответы при арифм операциях 
при схеме кодирования "sign-magnitude" неполучается при использовании ALU на цпу который
работает с класическими положительными числами. так что от такой схемы надо отказаться 
либо делать на цпу отдельный ALU блок который бы распознавал и работал бы именно с этой кодировкой.тоесть игнорировал бы старший бит при арифм операциях. по факту такую кодировку
неиспользуют в жизни в итоге. 

ну так уже для добавки скажу что 
есьт еще один минус у этой кодировки
у нас появляется два нуля.

0000 = 0
1000 = -0

что как бы неклево.


еще скажу что описанная выше схема кодирования отрицательных чисел характерна тем что 
старши бит отвечает только за кодирования(наличие или отсуствиие) знака минус. больше этот бит
никакого значения на себе ненесет. фишка в том что предтавленная (ниже) другая система кодирования отрицательных чисел  тоже имеет старший бит выставленный в 1 если число отрицательное но этот старший бит нетолько в себе несет признак о том есть ли минус
у числа или нет но и также участввует в кодировании величины числа. это важно. потому что
у представленной выше схемы если заменить старший бит с 1 на ноль то мы автоматом легко получаем из -5 сразу 5. та схема что ниже у нее если заменить старщий бит с 1 на ноль то 
это повлияет нетолько назнак но  и на величину числа такчто вот так вот просто прервратить -5 в 5 уже неработает.

Далее. рассматриваем следущйю схему кодирования отрциалеььельных чисел через положительные.
она назыавется "первая обратная форма" - "1's Complement Representation".
перевод литературный а недословынй. дословный по мне какойто хреновый.
суть схемы:
		старший бит если он 1 обозначает что число отрицательное (для нашей программы а не для цпу
для цпу по прежнему число положительное).
		если старший бит 0 то оставшиеся биты обозначают величину.
пример
0100 = старщий бит 0 значит число положительное. оставшиеся биты 100 обозначают величину 4
значит для нашей проги это число +4. для цпу это тоже +4
		если старший бит 1 то число для программы считается отрицательным (для цпу оно по
прежнему положительное) а оставшиеся биты показывают величину но их нужно инвертировать и 
только после этого смотреть виличину.
пример
1010 = старщий бит 1 значит это число с минусом для нашей проги. оставшиеся биты 010 мы 
их инвертируем получаем 101 и вот теперь уже смотрим что это за число . это 5 значит 
для нашей проги это число -5. для компа же по прежнему это число 9.
	как на практике программа могла бы работать  с такой кодировкой. вот она из памяти в регистр
считала байт. пусть у нас 4битная память и 4битный регистр. получила 1010. далее программа
видит что цпу выставил sign флаг который сигнализирует что старший бит равен 1. окей.
программа поняла что это отрицательное число. далее программа вычленяет все младшие биты
и делает их инвертирование для этого тоже есть на цпу команда. и далее уже мы получаем наше искомое отрицательное число ибо минус мы вычислили и модуль числа мы получили. 
получается с точки зрения записать в память и прочитать из памяти и распознать какое 
отрицательное число туда записали ранее эта схема работает пригодна.


		нарисуем табличку чисел в такой кодировке

биты |для      | для 
     |программы| цпу
0000 	0 				0
0001 	1 				1
0010 	2 				2
0011 	3 				3
0100  4 				4
0101  5 				5
0110  6 				6
0111  7 				7
1000  -7 				8
1001 	-6 				9
1010 	-5 				10
1011 	-4 				11
1100 	-3 				12
1101 	-2 				13
1110 	-1 				14
1111 	-0 				15


еще раз подчеркну что для цпу по прежнему все биты это сгубо положиельные числа.
это для нашей программы числа стали иметь другое значение. тоесть если программа 
считала их регистра число 14 то она для себя понимает что это для нее число -1
и наоборот если программа хочет записать в регистр число -1 то она его согласно таблице
перекодирует и сует в регистр число 14 . поому что это только для нашей программы -1 это -1
а в цпу нет нкиаких -1. там есть только 14 который имеет вид 1110.
тоесть программа тарктует битовую запись одним образом а цпу другим. 

виден минус такого кодирования в том что у нас два нуля.
биты |для      | для 
     |программы| цпу
0000 	 0 				0
1111 	-0 				15

еще минус в том что (согласно инфо от книжек) что неполучается извратится и 
получать верные ответы при арифм операциях используя ALU цпу для положительных чисел.
поэтому от такой кодировки тоже отказались в программах. потому что наша задача нетолько 
записыать в память регистры наши "отрицательные"  числа но и выполнять над ними арифм 
операции исползуя ALU cpu. а если мы будем получать неверные ответы то смысла нет.

рассмотрим следущую схему кодирования отрицательных чисел через положитеьльные.
схема называется "вторая обратна схема" "2s complement representation"
схема такая же самая как предыдущая но чуть чуть другая.
	старший бит если 0 то число считается положительное если 1 то отрицательное
	если старший бит 0 то оставиишиеся биты кодируют величину
	если старший бит 1 то оставшиеся биты кодируеют величину но чтобы ее узнать надо 
инвертировать биты и прибавить единицу.
пример для отрицательного числа
1010 = старший бит 1 значит знак минус. оставшиеся биты 010 мы их инвертирует полчаем 101
и прибавляем единицу тоесть
101
001
---
110

это число 5. значит итоговое число это -5

распишем таблицу в этой кодировке

биты |для      | для 
     |программы| цпу
0000 	0 				0
0001 	1 				1
0010 	2 				2
0011 	3 				3
0100  4 				4
0101  5 				5
0110  6 				6
0111  7 				7
1000  -8 				8
1001 	-7 				9
1010 	-6 				10
1011 	-5 				11
1100 	-4 				12
1101 	-3 				13
1110 	-2 				14
1111 	-1 				15


сразу здесь замечаем что положительные для нашей программы числа они и для цпу ровно 
такие же самые. то есть 0-7 для нашей проги это 0-7 для цпу. тут все просто.

сразу видна фишка что теперь у нас один ноль в этой кодировке а не два. это хорошо.
втора фишка наконец то мы ее получили мы можем складывать и вычитать числа пользуясь ALU цпу
и получать верные ответы с точки зрения нашей программы. еще раз фишка в том что с точки зрения цпу и его АЛУ мы имеем только положртельные целые числа и выолняем с ними арифм операции. а так счастливо совпадает что полученный результат верно кодирует число уже  с точки
зрения нашей программы. 
пример.
хотим в нашей проги посчитать 4+(-5).
согласно табллице
4(для нашей программы)=0100=(для цпу это тоже 4)
-5(для нашей проги)=1011(для цпу это 11)

суем в один регистр 0100
во второй регистр суем 1011
далее просим цпу сложить эти числа.
еще раз подчеркну что цпу складывает не 4 и -5 а 4 и 11

0100
1011
----
1111

получили 1111
для цпу это 15
но наша программа считывает это число заглядыает в таблицу понимает что получили -1
 а это то что нам надо потому что в математике 4-5=-1

еще пример
хотим в программе почитать -2-6= -2 + (-6)
-2 согласно таблице = 1110 суем его  в первый регистр (для цпу это число 14)
-6 согласно таблице = 1010 суем его во второй регистр ( для цпу это число 10)

скадываем эти числа пользуясь АЛУ цпу. цпу считает по факту что склдаыает 14 и 10
1110
1010
-----
1000 с флагом переполнения

флаг переполнения игнорируем.
получили 1000 . согласно таблице для цпу это число 8 а для программы это -8
и по математика -2-6=-8

получили поразительную вещь. хитро кодирую  отрицательные числа с точки зрения нашей программы
в положительные числа для цпу и используя АЛУ цпу для обработки положительных чисел 
мы получаем верные ответы с точки зрения арифметики над отрицательными числами! круто!
это значит что нам ненужно внутри цпу заводить доп микросхемы для распознавания класса отрицательных чисел  и ненужен блок арифм операций над отрицаттеьными числами.
это очень хорошо. единственное что на данном этапе это верно для целых чисел и для операций
сложения вычитания. как там обстоят дела с дробными числами и с операциями умножения деления
я пока незнаю.  но четко видно что складывать и выичтать целые отрицательные числа мы уже можем на цпу пользуясь его аппаратом обработки положительных чисел. цпу понятия неимеет обрабатывая положительные числа что по факту для нашей прогармы он получает отрицательные числа.

мы можем вычислаять такие примеры как
2-6= 2+ (-6)
6-2= 6+ (-2)
2+6
2-(-6)=2+6
-2-6=(-2) + (-6) 

также совершенно понятно важное дополение что для каждого размера регистра (сколлько в нем бит) у нас есть некоторый диапазон чисел с которым мы можем работать и получаеть коректные ответы. если мы выходим за этот диапазон то мы будем получать некоректные ответы и тогда 
надо сигнализировать что мы этот случай посчитать неможем.
для n=4 бит наш диапазон это [-8;7] это значит что аргументом в примерер могут быть 
только числа из этого диапазона
например
-8+7 = коретный вариант
4-6 = коректный вариант
-9+1 = некоректный вариант потому что через 4 бита мынеможем запрограмировать число -9

ну это понятно. но есть еще условие что резулттат примера неможет тоже выходит за рамки [-8;7]
потому что результатто у нас тоже записывается  в регистр из тех же 4 бит. а если результат превыешает 4 бита то как мы можем его отобразить? никак. пример

-8-4= -8 + (-4)= -12 результат (число) превышает диапазон. значит тут надо писать что ошибка.
посмотрим как это на практике.
-8 = 1000
-4 = 1100


1000
1100
----
0100 и флаг переполнения а флаг sign сброшен
получили сточки зрения цпу 4 и сточки зрения программы тоже 4. а нам надо было -12.
поскольку мы складывали два отрицательных числа то мы точно знаем что должно получиться 
отрицательное число. а поскольку флаг sign сброшен ( так как старший бит 0) то мы в программе
понимаем что мы превысили лимит снизу. значит выдаем ошибку в программе.

еще пример 
7+2=9. 9 число оно тоже выходит за диапазон [-8;7]
смотрим

0111
0010
-----
1001 

флаг переполнения неустановлен
флаг sign установлен

получили 1001 для цпу это 9 для программы это -7. причем флага переполнения нет.
но флаг sign устанолвен. так как мы знаем что сумма положительных чисел должны быть 
положительна то мы в программе понимаем что мы превысили лимит сверху. выдаем ошибку.

итак получается правило флаг переполнения мы игнорируем.
если складываем два положительных числа и получаем устанолвенный sign флаг 
значит мы превысили лимит сверху. выдаем ошибку.
если мы складыаем два отрицательных числа и получили сброшенный флаг sign то мы 
превысили лимит снизу и выдамем ошибку.

круто!
тогда действиельно если наша программа использует "вторую обратная схема" (мне кажется по русски эта схема называетс схема дополнения до двух но это неточно) то мы можем успешно
складыать и вычитать положтельные и отрицательные целые числа. диапазон чисел определяется
размером в битах регистра.
при n=4 это [-8;7]
при n=8 это [-128;127]

при n=k это [-0.5(2^k);{0.5(2^k)}-1]
заметим что 0.5(2^k)=(2^k)/(2^1) = 2^(k-1) значит преобразуем формулу
при n=k это [-2^(k-1);2^(k-1) - 1 ]

визуально удобная формула выглядит так
при n=k , [-z,z-1], где z=2^(k-1)


получается при n=16, z=2^15=32768 ,значит [-32768;32767]

при n=64, z=2^63, значит это [-2^63; 2^63-1] 
или 
[9 223 372 036 854 775 808; 9 223 372 036 854 775 807]



теперь надо понять почему "вторая обратная схема" дает верный результат 
при арифметических операциях.

для этого рассмотрим на первом шаге вспоминаем о чем я говорил гораздо выше - что происходит с регистром когда мы в него слкадываем число которое превышает его размер. регистр 
работает как одометр на машине. тоесть

1111
0001 +
-------
0000

когда на одометре максмимаьная цифра и мы добавляем еще один то одометр откручивается
до начала до нуля а потом идет все сначала.


0000
0001 -
-------
1111

когда на одометер ноль и мы если его скручиваем на 1 назад то на нем вылезаем 
максимальное число.

так работат арифметика на регистре при проходжении за максимум и минимум.


на втором шаге(чтобы понять почему работает арифметика "второй обратной схемы") рассмотрим еще одну кодировку:
называется она "одометрная кодировка" предложена в книге по асемблеру BOB NEVELN.
пусть у нас есть одометр. из пяти цифр и сейчас он показыавает 99 999км и мы проезжаем 2 километра.
одометр прокрутится в 00 000 и далее прокрутится и покажет  00 001 км. а теперь рассмотрим 
уровеннеие из математики (забудем про одометр на время)

x + 2 = 1
в математике x= -1

значит в математике у нас было -1 мы к нему добавляем 2 и получаем 1.

возвращаемся к одометру у нас было 99 999. мы проехали 2 километра и он показал нам 1.

возникает идея о том что если мы будем  считать показание 99 999 на одометре
как -1 для нашей программы то добавояя километры на одометре мы получим на одометре 
ровно тоже число которое мы получим считая уравнение в математике тоесть.

в математике

-1 + 10 = 9

на одометре

99 999 + 10 = 9

таким образом 99 999 на одометре сооответвует -1 для нашей программы в математике.

возьмем на одометре показание 99 998 . добавим на одометре 3 киломтра получим на одометре показание 1 . тоесть

99 998 + 3 = 1


рассмотрим математику уравнение

x + 3 = 1 
получаем x=-2

теперь рассмотрим пример когда к -2 мы прибавляем 10

-2 + 10 = 8

рассмотрим когда мы к одометре 99 998 добавляем 10 километров

99 998 + 10 = 8

таким образом мы видим что добавление к 99 998 любого числа дает тот же ответ как добавление 
в математике к -2 того же числа. 

это нам дает что что вот мы хотим узнаь сколько будет

-2 +100.
мы выставляем на одометре 99 998 и проезжаем на машине 100 километров и сколько он покажет
такой ответ и есть. одометр покажет 98км

значит -2 + 100 = 98

таким образом мы можем составить таблицу соотвесвтия между отрицателным числом из математики
и показанием на одемтре

-1 				99 999
-2 				99 998
-3 				99 997
-99 999 	1
-100 000 	0


таким образом мы получаем через одометр примитивный калькулятор. если нам надо решить пример
-3 + 15. мы лезем в таблицу смотрим какое число соответвует -3

-3 соотвствует 99 997
мы выставляем на одометре 99 997. далее мы проезжаем 10 километров (ну или условно говоря делаем 10 щелчков на одометре) и та цифра что он высветит это ответ.
одометр покажет 12
значит -3 + 15 = 12

таким образом мы имеем некиий суммирующий калькулятор в форме одометра. он по своей природе
умеет суммировать только положительные числа. но мы исхитрились его приспособить для суммирования отрицательных чисел с положительными.

далее мы замечаем что одометр это 5 битное устройство , 5 битное число с десятичной системой счисления.
а в цпу у нас есть такой же одометр это регистр. у него скажем 4 бита и двоичная система счисления. и главное что АЛУ цпу он работат с регистром при операции сложения ровно также
как одометр на машине очем мы выше говорили.

рассмотрим регистр показывает 

1111 = 15
мы добавляем +2 это 0010

1111
0010 +
------
0001

получаем 1 
таким образом если верхний одометр имел диапазон от 0 до 99 999 
то наш регисррвый одометр имеет диапазон от 0 до 15.
при прохождении 15 он обнуляется ровно также как одометр машины при прохождении 99 999 он обнулялся.


так вот из вернего примера мы видим что 
на регистре было 15 потом прибавили 2 и получили 1. 
в математике x+2=1 имеет место когда x=-1

значит по аналогии -1 из математики соотсвтетует 15 на регистре. прибавляя на цпу к 15 число
Y мы будем получать ответ аналогичный как тому как в математике -1 + Y

-1 +y ( в математике)
15 +Y ( на цпу в регистре)

ссотавляем таблицу

-1		15  1111
-2		14  1110
-3		13 	1101
-4		12 	1100
-5		11 	1011
-6		10 	1010
-7		09  1001
-8		08 	1000
-9		07 	0111
-10		06 	0110
-11		05 	0101
-12		04 	0100
-13		03 	0011
-14		02  0010
-15		01 	0001
-16		00 	0000

в левой колонке наше число из математики которое интересует нашу программу
вторая колонка это число в регистре внутри цпу которое соответвует первой колонке
третья колонка это битовая картинка внутри регистра

хотим узнать сколько будет -14 + 10
согласно таблице для числа -14 надо на регистре положить число 02 или в битовом виде 0010

а далее надо прибавить к тому что лежит в регистре то что мы хотим прибавиить в нашем случае
это 10 . 10 = 1010

получается с точки зрения цпу мы прибавляем 14 и 10

0010
1010
-----
1100 нет флага переполнения

1100 это 12 а согласно таблице это также может быть -4

получается в целом хорошая схема и она как работает но возникает непонятка с результатом
как его трактовать. толимы получили 12 то ли -4. 

рассмтоим еще пример когда модуль отрциательного числа меньше положительного

-4 + 10

согласно таблице для -4 в регистр надо засунуть  12 =	1100
10 = 1010

значит надо приавляем на цпу к 12 число 10

1100
1010  +
------
0110  есть флаг переполнения

получили число либо -10 либо 6

тогда из этих двух примеров можно такое правило создать для программы.
если флаг переполенния сраотал то трактуем полученное число как отрицательное
а если флаг переполенния невыставлен то трактует резултат как положительное число.

получается при такой кодировке "кодировка одометра" можно успешно получать ответы
для арифметичских задач складываний отрицательного числа с положительным.

но есть проблема в том что если мы читаем из памяти в регистр байт то нашей программе
непонятно тли это положителное число толи отрицательное.
тоесть когда мы знаем число отрцаительное потом ишем по таблице ему соотсвтеие 
и потмо склдываем и проверяем флаг перпполения то мы точно знаем как трактовать результат. 
а вот если мы из памяти считали байт то тут нет никаких зацепок как его тарктовать то ли как
политеьное число толи как отрциательное. 

поэтому кодировку одометра надо модифицировать. 

еще раз скажу зачем нам этот огород с кодировкой отрцаттельного числа  в положительное. 
огород нужен затем чтобы внутри цпу ненужно было создавать транзисторные схемы специально 
под отрицатлеьные числа. мы хотим обойтись схемой в цпу которая умеет работать только с положительными числами. это упростит нам усттойство цпу.


итак надо модифицировать "кодировку одометра"

тогда идут на следуший шаг. до сих пор мы использовали четыре бита для кодирования числа.
теперь из всего множества чисел которые мы использовали на преддыдущем шаге мы будем
для кодирования отрицательных чисел использовать невсе а только те у которых так вышло
что старший бит равен 1. тогда половина все чисел будет кодироовать отрицаттельные числа
для нас ( для цпу по прежнему все числа положртельные) а половина для нашей программы
будет кодировать положительные числа. да мы лиштимся половины диапазона но исчезнет
неоднозначность мол это положительное число или отрицательное и при этом сохранится
также механизм о том что если мы будем складывать положительные (для цпу) числа которые ( для нас) выглядят как отрицательные с другими числами то результат будет верный.( при этом мы будем исползовать встроенный в цпу механизм сложения положитльных чисел несоздава в цпу отдельный блок по обработке отрицательных чисел).

итак берем нашу прежнюю таблица

1111 = ( для цпу это прежнему 15)
1110 = ( для цпу это прежнему 14)
1101 = ( для цпу это прежнему 13)
1100 = ( для цпу это прежнему 12)
1011 = ( для цпу это прежнему 11)
1010 = ( для цпу это прежнему 10)
1001 = ( для цпу это прежнему 09)
1000 = ( для цпу это прежнему 08)

0111 = ( для цпу это прежнему 07)
0110 = ( для цпу это прежнему 06)
0101 = ( для цпу это прежнему 05)
0100 = ( для цпу это прежнему 04)
0011 = ( для цпу это прежнему 03)
0010 = ( для цпу это прежнему 02)
0001 = ( для цпу это прежнему 01)
0000 = ( для цпу это прежнему 00)

и для каждого числа мы находим его отрицательный эквивалент но не для каждого 
а только для тех числе у которых старший бит 1.
получаем


1111 = ( для цпу это прежнему 15) | для программы это -1
1110 = ( для цпу это прежнему 14) | для программы это -2
1101 = ( для цпу это прежнему 13) | для программы это -3
1100 = ( для цпу это прежнему 12) | для программы это -4
1011 = ( для цпу это прежнему 11) | для программы это -5
1010 = ( для цпу это прежнему 10) | для программы это -6
1001 = ( для цпу это прежнему 09) | для программы это -7
1000 = ( для цпу это прежнему 08) | для программы это -8

0111 = ( для цпу это прежнему 07) | для программы это 7
0110 = ( для цпу это прежнему 06) | для программы это 6
0101 = ( для цпу это прежнему 05) | для программы это 5
0100 = ( для цпу это прежнему 04) | для программы это 4
0011 = ( для цпу это прежнему 03) | для программы это 3
0010 = ( для цпу это прежнему 02) | для программы это 2
0001 = ( для цпу это прежнему 01) | для программы это 1
0000 = ( для цпу это прежнему 00) | для программы это 0

теперь если мы из памяти скачаем байт то мы однозначно можем сказать что это за число
для нашей программы. только появилась небольшая  проблемка что 
если раньше мы могли отрицательное число брать от -1 до -15 то теперь только от -1
до -8 для наших примеров вида -8 + Y


для цпу по прежнему все эти биты это сугубо положительные числа
от 0 до 15. 
мы же в своей программе можем использовать числа от 0 по 07 как положительные трактуя их как 
числа от 0 по 07

а числа от 08 по 15 мы можем в нашей программе трактовать как числа от -8 до -1

при этом мы теперь имеем однозначность теперь понятно какое положительное (для цпу)
число кодирует положительное число для нашей программы а какое положительное (для цпу)
число кодирует отрицательное для нашей программы число.

теперь наша программа может выполнять арифметические действия с отрицательными числами
используя блок сложения на цпу для положительных чисел и полученный результат наша программа
теперь может одноазначно трактовать что это точно либо положительное либо отрицательное число.
пример

мы хотим через нашу программу сложить -7+4.
наша программа смотрит в таблицу и видит что -7 соответствует число 09 (1001)
тогда наша программа кладет в первый регистр цпу число 09 а во второй регистр число 4(0100)
и дальше просит цпу их сложить.

1001
0100 +
------
1101 флаг переполнения невыставлен. флаг sign выставлен

далее наша программа смотрим  в таблицу и видит что
1101 = для нашей программы это -3. 

данное число наша программа должна для себя трактовать как -3.
и она на экран выводить -3. получено отрицательное число потому что его старший бит 1.

и согласно математике -7+4=-3

тоесть все верно.
ну а с точки зрения цпу он сложит 9 и 4 и получил 13. но это 13 для цпу а наша программа
имеет волность трактовать полученное число как мы хотим. 

обозначим диапазон числе который можно получить для регистра размером n бит.
в рамках этих бит мы можем закодировать положительные числа [-(2^(n-1); (2^(n-1))-1] 
об этом и выше говорил.
пример n=4.  [-8; 7]

далее. вот мы научились прибавлять к отрицательному числу положительное.
как мы это делаем. мы берем отрицательное число. находим по таблице соотвутетвюущий
ему положительное число в байтовом виде и суем в регистр. и далее с даем команду
цпу добавиьт к тому что в регистре еще другое положительеное число

mov al, 0x7
add al, 0x5

проблема в том что мы ищем первое число которое нужно положить в регистр по таблице.
нужна какая то аналиическая формула как это сделать.
если это число положительное то число P которо в регистр класть найти очень просто 
это просто наше исходное число в бинарном виде. 

а вот если исходное число отрицательное то на бумаге эта формула выглдит так

P=2^n-N

P = число которое мы ищем которое хоти поолжить  в регистр.
N = положительное число обратно к нашему отрицательному
n = битность регистра. 

Также хочу подчеркнуть что первый бит у P всегда будет 1.(ествесвтенно если исходное число
отрицательное. если положительное то ноль)


для n=4 
P=16-N

окей. для числа -7 обратное ему число N=7
P=16-7=9 = 1001
mov al, 11d

значит на бумаге мы имеем формулу а как нам заставить сам комп высчитывать это P 
вместо нас. модифицируем формулу

P=16-N=(15-N)+1

рассамотрим 15-N
возьмем N=1, N=5, N=7.
обращаю внимание что N у нас положительное потому что оно обратное число к нашему 
отрцаительному.

поскольку N  у нас положительное то мы можем его представить в виде битов в регистре
и выполнить операцию вычитания в двоичном виде на бумаге ( на цпу неможем потому что наш цпу на данный момент неимеет блока вычитания положительных чисел поэтому пока только на бумаге).

Еще раз почему  я невыбрал чтобы N был отрицательный. почему  я выбрал чтобы N был обратный к нашему числу. потому что я хотел чтобы N был положительный. почему. потому что если N отрицательный то в двоичной системе настоящей число отрицательное к положительному найти 
очень легко. тоесть если у нас 0001 то ему отрицательное это -0001 а вот когда мы 
говорим про бинарный вид числа в регистре у нас там нет никаки минусов. там мы работает
только с положртельными числами поэтому я выбрал чтобы N 	был положитеьный.
схема такова. 

у нас ест число -7 в десятичной записи. ему обратное в десятичной это 7. и мы мгновенно также
можем записать как будет выгляеть 7 уже внутри регистра это 0111. тоест положителность
числа N дает возомность его засунунть в регистр. 


итак имеем числа -1 тогда N=1, тогда его вид в регистре 0001
число -5 тогда N=5 , тогда его вид в регисре 0101
число -7 тогда N=7, тогда его вид в регистре 0111

далее рассмтриваем формулу 15-N
в двоичной записи эта операция выглядит как

для N=1
1111
0001 -
-------
1110

для 
N=5
1111
0101 -
--------
1010

для 
N=7
1111
0111 -
--------
1000

на цпу мы ее выполнить неможем потому что по условиям у нас в цпу нет блока вычитания
одного положртельного числа из другого пэтому мы ее делаем пока только 
на бумаге.

но можно заметить одну интересуню вещь. что ответ в бинарном виде 
всегда является инвертасией битов из числа которое мы отнимали. тоесть

N=1 = 0001
ответ = 1110

N=5 = 0101
ответ = 0101

N=7 = 0111
ответ = 1000

так вот утверждается в кнжижке что так буде всгда для любого аргумента.
если мы отнимаем в 4 битном числе от 15 другое полржителное число то 
ответ можно найти мгновенно путем инверсии битов.

и тут чудо. значит мы можем добавить в цпу такой блок в ALU который умеет 
инвертировать биты в регистре. 

тоесть 15-N = NOT N 
где NOT N это bitwise not для N

тоесть если 
N = 0000 
то 
NOT N = 1111

тогда возврашаемся к формуле
если у нас есть отрицательное число(которое мы неможем засунуть в регистр) и мы хотим найти положительное число P (которое 
мы уже можем записать в регистр) то P можно найти по формуле

P=(15-N)+1

где N это положительное число обратное к нашему отрицательному.тоесть если наше число -7 то N=7.

поскольку мы уже выыснили что (15-N) = NOT N
то формула преобразуется в 

P= NOT N + 1

таким образом мы нашли формулу по которой мы не из таблицы руками а на цпу с помощью его ALU 
можем автоматм красиво получать число P для заданного отрицательного числа зная его обратное положительное число N.

пример.
отрицательное число =  -8
для него его обратное число N=8
значит мы берем и грузим в регистр число 8

mov al,8d

далее мы к нему применяем bitwise NOT

not al

далее мы к нему прибавляем 1

add al,1 

и таким макаром у нас щас в al число P которое согласно таблице соответсует числу -8.


рассмотрим на примере
число -7
N=7 = 0111
NOT 0111 = 1000
прибавим единицу 

1000
0001 +
-----
1001

полученное число 1001(9 dec) это искомое число P для -7.
проверяем по таблице
1001 = ( для цпу это прежнему 09) | для программы это -7
все верно.


расмормим обратную задачу. у нас есть число P в двоичном виде из регистра.
как нам понять какое число оно кодирует?

смотрим на формулу

P= NOT N + 1    # она про то чтобы зная N найти P

теперь выведу обратную формулу
N = NOT (P -1)  # она позволяет зная P найти N

проверим на практике.
P= 1001
N = NOT (1001-0001) = NOT 1000 = 0111  = 7
значит искомое число отрицательное равно -7



ВНИМАНИЕ! ВАЖНЫЙ КУСОК. 
примеры на bash
(собственно именно из за него и началось изучение кодирования отрцаеттельных чисел)

тут очень важно сразу сказать что  баш имеет размер переменной 64бита. а не 4бита как я все это время тут рассматриваю. 

далее важные примеры на эту же тему
на примере bash:

у bash есть bitwise NOT обозначается как ~
$ (( ~число  ))

у bash двочиное число вбивается как
$ (( 2#0001))

все вместе NOT 0001
$ echo  $(( ~ 2#0001 ))

наша задача угадать что будет на выхлопе.
прикол в чем баш берет число которое мы ему дали и применяет к нему инверсию битов. полученный байт баш невыводит в бинарном виде. нет. он воспринимает его как P. как 
число в регистре. поэтому для этого P баш находит N. и потом выводит его на экран в
виде -N

наша задача - мы задаем начальное число N1. и нужно предсказать какое число -N2 
баш распечатает на экране.

значит после выполнения команды в регистре будет лежать байт
P=NOT N1

и  у нас есть формула которая зная P позволяет расчитать его N
N2 = NOT (P -1)

подставляем P из первой формулы во вторую получаем
N2 = NOT (NOT N1  -1)

формулу получили. 
приступаем к конкретным случаям N1.

N1=00..0001

тут суперважно вспомнить и понять что баш выеляет по число 8 байтов. а не 4бита
как я это тут делаю в примерах. почему это важно .потому что 
 я вот ввел и получил
 $ (( ~ 2#0001))
-2

далее я подумал что результатом NOT 0001 является 1110 
и да это верно если размер регистра 4 бита (но это совершенно неверно если 
размер регистра 64 бита щас мы это увидим). ну я и подумал а дайка  я башу сразу подсуну
это число 2#1110 и посмотрю что он напечаатаем. должен же -2

я ввел и получил
~$ echo $(( 2#1110  ))
14

и такой типа непонял почему 14 вместо -2 . а все потому что для 64битого регистра операция

NOT 0001 = 1111111......1110 но никак не 1110

поэтому мне нужно было печатать число
$ echo $(( 2#1111111111111111111111111111111111111111111111111111111111111110 ))
-2

а  я задал печатать совем другое число
$ echo $(( 2#1110  ))
14
которое аналогично
$ echo $(( 2#0000000000000000000000000000000000000000000000000000000000001110  ))
14

поэтому и получил 14 вместо -2

почуствуй разницу между числами
1111111111111111111111111111111111111111111111111111111111111110
и
0000000000000000000000000000000000000000000000000000000000001110
 

после примеения к нему NOT в регистре окажется как уже сказал число 1111111111111111111111111111111111111111111111111111111111111110
по таблице можно найти что ему соотвевтвует -2

но расчитаем по формуле а не по таблице
N2=NOT (NOT 0001  -1) =  NOT (11..1110  -0001) = NOT (11..1101) = 0010 = 2
значит на экране баш должен напечатать -2

проверяем
$ echo $(( ~ 2#0001))
-2
все правильно.


следущий пример
N1=00..1010

после примеения к нему NOT в регистре окажется число 
1111111111111111111111111111111111111111111111111111111111110101
по таблице можно найти что ему соотвевтвует -11 

распечатаем напрямую это число. проверим как баш его интерпретирует
$ echo $(( 2#1111111111111111111111111111111111111111111111111111111111110101  ))
-11

все верно!

но теперь расчитаем -11 через формулу
N2=NOT (NOT 1010  -1) =  NOT (11..0101  - 0001) = NOT (11..0100) = 1011 = 11
значит на экране баш должен напечатать -11

проверяем
$ echo $(( ~ 2#1010))
-11
все правильно.

тут еще важно отметить что так как у нас регистр 64бита то конечно -11 входит в
в диапазон! это если бы регистр был 4 бита то -11 там бы и в помине небыло.


вопрос почему я указываю числа в баш в бинарном виде.
это чтобы точно гарантировать какое бинарное число баш кладет в регистр.
ведь если я укажу число в десятичном формате то баш его вначале преобразоывает в бинарный вид по непонятно какому правилу и только потом кладет в регистр. если же указваем число сразу вбинарном виде то баш ровно  в таком виде и кладет число в регистр. это очено важно.если я указал (( 2#0001 )) то баш засунет  в регистр именно этот набор бит.
а если я укажу (( 1 )) то еще нефакт что баш засунет в регистр 0001

щас  я покажу почему это важно. 
поставим число в десятичном виде.
возьмем предыдущий пример N1=1010. преобразуем в десятичны вид N1=10(dec)

$ echo $(( ~ 2#1010 ))
-11

$ echo $(( ~ 10 ))
-11

ну чтож хорошо получили одно и тоже.



рассмотрим следущий пример.
N1= -4

значит как будет дейтсовтаь баш. он небудет пихать в регистр -4 потому
что это невомозжно. он вначале по таблице 
заменит -4 на некоторое бинарное положительное число (вопрос какое).
и именно его засунет в регистр.
посмотрим что будет
$ echo $((  ~ -4 ))
3



расчитаем что тогда он должен показаьть
по моим понятияем баш -4 превршащат по таблице в 11..1100

N1=11..1100

у нас здесь P=NOT N1= 00..0011

далее по формуле мы уже неможем считать потмоу что формула расчитана
на нахождение N при условии что P имеет старший бит устанолвенный в 1
а наш P имеет старший бит сброшенный.

так что наша формула по нахождению N тут неприменима!

конец теме примеров на баш. далее опять возрвщаемся к искуственным регистрам на 4 бита.
ВНИМАНИ! КОНЕЦ ВАЖНОГО КУСКА.

насколько я понимаю расмотренная выше модифицрованная методика кодирования методом одометра
это и есть "вторая обратная схема кодирования"

?????????????????????????????/
закончил тут.
рассмотреть то что я непонял здесь 
https://www3.ntu.edu.sg/home/ehchua/programming/java/datarepresentation.html
у них какаято друная методика второй схемы кодировагия а именно:
for negative integers, the absolute value of the integer is equal to "the magnitude of the complement of the (n-1)-bit binary pattern plus one" (hence called 2's complement).

ихний пример
1000 0001 типа равен -127(Dec)

посчитаем по моей методике
P=1000 0001

N = NOT (P -1) = NOT (1000 0001 - 0000 0001) = NOT (1000 0000) = 0111 1111 = 127(dec)
значит исходное число по моей методике это -127
кхм.. ответ совпал с ихним. 

P=1 111 1111
N= NOT (1111 1111 - 0000 0001) = NOT (1111 1110) = 0000 0001 = 1
значит число равно -1

их ответ 
0000000+1=1 итого -1
кхм совпало.
почемуто формулы разные а ответс совпдаате! надо разобарсят !

????????????????????????????
Далее. я тут сразу еще скажу то что совершенно очевидно что при такой системе кодирования
чисел старший бит который показывает знак это нетолько бит отвечающий за знак это также 
бит который тоже участвует в кодировании величины числа.это совершенно очевидно. тоесть если взять 
1011 = ( для цпу это прежнему 11) | эквивалент -5
это число и заменить его старший бит с 1 на ноль то мы получим 0011 и согласно верхней
таблице мы получили 
0011 = ( для цпу это прежнему 03)
тоесть у нас было -5 а получили 03
тоесть я хотел сказать что если мы заменяем старший бит с 1 на ноль то мы неполучили 5.
типа было -5 а стало 5. и совершенно понятно почему! конечно так и должно быть.

далее книжку по асемблеру от BOB NEVELN пишет что для цпу информация в регистре она всегда
положительная. а число может быть отрицательным только в интерпретации программы.
ну это мы уже поняли.

итак мы научились к отрицательному числу прибавлять положительное.
берем отрцаительное число находим по таблицк какое положительное число надо
засунуть в регистр. и запускаем на цпу операция сложения.
возникает вопрос как нам на уровне программы\компа\цпу научиться находить число 
из таблицы без таблицы.  


16-x = (15-x) +1

15-x = NOT x

-x = NOT x + (-15)

x=7 = 0111
NOT x= 1000
-15 =0001

-7 = 1000 + 0001 = 1001

1000
0001
-----
1001


Дальше в этой книжке описывается просто поразтельная вещь- а как же нам научиться отнимать 
число от другого числа при этом пользуясь все тем же в цпу блоком который производить сложение. ибо нехочется цпу усложнять новыми транзисторными схемами . и они придумали поразителную схему.

хотим отнять 5-3. замечаем что 
5 - 3 = 5+(-3)

значит теперь мы перевели задачу об отнимании в задачу о сложении. только есть загвоздка
нужно научиться 3 переводить в -3. далее книжка пишет что эта операция нетак проста что это непорсто заменить операция заменить старший бит с 1 на ноль. ( и я тоже согласен с этим).
как показала формула выше чтобы получить для цпу эквивалент -3 это надо выполнить операцию

P = 2^n-N.
скажем у нас 4 битный регистр. тогда
P=16-3
и тут мы уперлись в том что на цпу нужно иметь блок отнимания. типа тупик. но дальше кникжа
пишет что во первых восопользуемся формулой

16-3 = (15-3) +1

далее посмотрим как выглядит отнимание 15-3 на бумаге

1111
0011
-----
1100

так вот присмотримся к 3 и результату
3          = 0011
результат  = 1100

так вот книжка утверждает что при отнимании от 1111 любого числа результатом будет число
которое получается из отнимаемого числа просто операцией замены каждого нуля на единицу
и каждой единица на ноль в отнимаемом числе тоесть.

мы отнимали 3 от 15. 3 это 0011 значит ответ будет 1100 (заменили в тройке все нули на единицы а все единицы на тройки). тогда получается что надо в цпу добавить очень простой блок которйы будет в отнимаемом числе менять биты на наоборот.
с помощью этого блока мы научили цпу отнимать 15-3
смотрим наверх чтобы получить 16-3 нам надо получить 15-3 ( это мы уже можем) и потом еще 
к результатут добавит единицу . для добавления единицы тоже в цпу можно пристроить очень простой блок.

таким образом добавив блок инвертирования битов и блок добавления единицы мы научили цпу
отнимать числа . тоесть

мы хотим отнять 12-4 грузим 12 и 4 в регистры. и даем команду на асемблере мол отнимай.
что делает цпу.


он начинает превращать 4 в -4

-4 = (15-4) +1

4 у нас это 0100
инвертруем на нем биты и получаем чему равно 15-4 = 1011
далее добавляем единицу
1011
0001
-----
1100

это мы получили аналог -4 = 1100

теперь выполняем операция сложения

12 + (-4)
12= 1100
-4= 1100

выполняем сложение

1100
1100
-----
1000 

получили переполнение но это неважно


с точки зрения unsigned integer 1000  это 8.
значит 12-4=8

что меня смущает 12 относится к unsigned intger диапазону а -4 относится к signned integer 
дапазону. как же мы можем смешивать две кодиовки?

зато стало понятно откуда взялась эта формула. что 

если a>0 то -a можно получить в битовом виде через :
-a = (~ a) + 1
где ~ это bitwise NOT.

формулу можно немного и преобразовать
(~ a) = -a-1
получаем тогда типа что если a=0 . то 
(~ 0) = -1

а скажем 
(~ 6) = -6-1 = -7

в баше ровно это и видим:
$ echo $(( ~0 ))
-1
$ echo $(( ~6 ))
-7

в книже по асемблеру процесс инвертации битов в регистре и добавление единицы назыается процессом two's complementation ( переводится как я понимаю дополнение до двух).
по факту это получается алгоритм битовой обработки числа в двоичной форме чтобы получить 
из положительного числа его отрицательную форму с точки зрения кодирования signed integer в битовом виде. таком что сложение на блоке сложения на цпу всегда дает верный результат внезависимости от того что подразумевает программа которая засунулу это число в регистр
толи программа имеет ввиду что это signed int или unsigned int.


у меня остался вопрос - меня смущает 12 относится к unsigned intger диапазону а -4 относится к signned integer 
дапазону. как же мы можем смешивать две кодиовки? тут даже два вопроса.
а как нам отнимать не 4 а например 14 потому что -14 в кодировке со старшим битом 
такого числа там нет. вторйо вопрос если мы взяли 12 из одной кодиовки а -4 из другой
то ответ как интерперретировать к какой кодировке его относить. по мне самый просто ответ
это то что и левое число и правое должны быть взяты из одной кодровки. и наверное
эта кодировка это signed int та при которой минусовые числа имеют старший бит равный 1. 
для 4 битов это диапазон чисел от -8 до 7

если же мы берем числа в диапазоне unsigmed int. то тут непонятно.
числа от 0 до 15.
отнимаем 1-15
насколько я понимаю в этом случае исползуется кодировка когда у нас отрицательное число
необьязано иметь 1 в старщем бите.тоесть кода у нас комбинация битов может трактоваятся
программой и как полжительное число и как отрицательное.
и тут проблема как трактовать полученный ответ. я так понимаю что на это влияет бит переполнения.

берем 15 и превращаем его в -15

1111 =15
инвертируем биты и добаляем 1 получаем
0001

складываем 1 и -15

0001
0001
-----
0010

бит переплонения при этом несработал

0010 это эквивалент -14 ( при условии что мы нетребуем старший бит чтобы был равен 1)
но как нашей программе отличить это -14 или 2. я пока только могу сказаьт что бит переполнения
не срабатывает в этом примере. 

попробуем другой пример

12 -4

4 это  0100
-4 это 1011+0001

1011
0001
-----
1100

12 это 1100

скалдываем

1100
1100
-----
1000

приэтом сработал флаг переполнения

1000 это 8 либо -8

из этих двух примеров я делаю вывод что наша программа может опредеить брать положительное
число или отрицательное вот как: если бит сработал переполения то брать положительный вариант числа. а если флаг переполнения несработал то брать отрицательнй вариант числа.


1-15=0010(2 либо -14) и флаг переполнения несработал
флаг переполнения несработал значит берем отрицательнйы вариант -14
итого 1-15=14

12-4=1000(8 либо -8) и флаг преполнения сработал 
флаг преполнения сработал значит берем пооложительнй вариант 8
итого 12-4=8

замечу что когда мы отнимаем числа в диапазоне unisgned integers то для кодирования
отрицательного числа у нас уже нет требования чтобы старший бит был равен 1
фактически мы работам сразу с двумя диапазонами от 0 до 15 и от -15 до 0
когда набор бит может одновременно быть трактован и положительным и отрицательным числом.
и тогда задача программы на основе флага переполенения понимать какой число с плюсом илли минусом в ответе она получено.


попробуем отнять чисала  с диапазона signed untegers от -8 до 7

-8-7

-8-7=(-8) + (-7)

8 =  1000
-8 = 0111+0001

0111
0001
-----
1000 флаг переполнения получен

7 =  0111
-7 = 1000 + 0001

1000
0001
-----
1001 флаг переполнения неполучен

значит -8 = 1000
-7 = 1001

складываем

1000
1001
-----
0001 флаг переполнения получен

0001 это 1 либо -15

вспоминаем правило: если бит сработал переполения то брать положительный вариант числа. а если флаг переполнения несработал то брать отрицательнй вариант числа.

но у нас тут прикол в том что флаг переполнения сработал два раза так что может быть 
это тоже обозначает что надо брат отрицательный вариант. 

тогда 0001 интерпретриуем как -15
тогда
-8-7=-15

ну как то так но не очень понятно.
====================================
====================================

 

       **     exponentiation
       * / %  multiplication, division, remainder
       + -    addition, subtraction
       << >>  left and right bitwise shifts
       <= >= < >
              comparison
       == !=  equality and inequality
       &      bitwise AND
       ^      bitwise exclusive OR
       |      bitwise OR
       &&     logical AND
       ||     logical OR
       expr?expr:expr
              conditional operator
       expr1 , expr2
              comma




послесловие:

если мы хотим присвоить значение в переменную тогда

$ n=$(( 5 + 4 ))
$ echo $n
9

 а впот пример показывает что расчеты идут только как с целыми числами, никакой 
 дробности нет
$ echo $(( 10 / 3 ))
3

обратим внимание на этот синтаксис
expr1 , expr2
              comma

пример на эту тему

$ a=1;b=3
$ (( a=a+10, b=b+a ))
$ echo $a
11
$ echo $b
14




можно использовать в скобках нетлоько дсесятичые числа но и hex и бинари 
делается через 

(( 2#01010101 )) - бинарное число
(( 16#a134f )) - hex число

посмотреть всегда можно в man bash искатьпо слову arithmetic evaluation

$ echo $(( 2#101 ))
5

$ echo $(( 16#F ))
15

в каком виде баш хранит переменные? какие есть типы переменнух у баша?
цитрую из книжки по башу:
Unlike many other programming languages, Bash does not segregate its variables by "type." Essentially, Bash variables are character strings, but, depending on context, Bash permits arithmetic operations and comparisons on variables. The determining factor is whether the value of a variable contains only digits.

итак если у баша перменные эти всегда strings. но с ними можнр делаь операции порой как
с integer то возникает вопрос насчет формата печати переменных.
так вот формат в котором будет распечатана переменная зависит от прогаммы которая
печаатет переменну.

у echo  всегда будет в dec формате.
потому что echo переменые выводит всегда в dec формате

printf может вывести переменную в hex формате

$ q=$(( 16#f ))
$ printf "%x\n"  $q
f

итак надо различать тот вид в котором перменная хранися в памяти 
и тот вид в котором она напечаатана. это разное.


далее рассмотрим такую штуку:
<< >>  left and right bitwise shifts

$ (( n>>4 )) 
эта штука берет число автоматом его переделывает в бинарный вид и далее сдвигает все биты
направо на 4 бита.

рассмотрим на примере n=15 (0000 1111)
при сдвиге вправо на 4 бита получим конечно ноль
$ n=15; echo $(( n>>4 ))
0
$ n=15; echo $(( n>>3 ))
1
$ n=15; echo $(( n>>2 ))
3
при сдвиге на один бит получим 111 тоесть семь
$ n=15; echo $(( n>>1 ))
7

что еще важно. (( n>>4 )) она двигает биты но саму переменую неменяет.
$  n=15; echo $(( n>>1 )); echo $n
7
15



дале рассмотрим такую штуку:
 expr?expr:expr
              conditional operator
 это ternary(тройной в переводе) оператор. 
 его смысл: An expression a ? b : c evaluates to b if the value of a is true, and otherwise to c

 пример
$ (( a=5<4?5:4 ))
$ echo $(( a=5<4?5:4 ))
4
$ echo $a
4

итак смысл если 5<4 то тогда присвоить a=5 иначе присвоить a=4





$ { let n&=9; }
[1] 13696
=9: command not found
[1]+  Done                    let n
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ let n\&=9;
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ echo $n
9
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ n=15
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ let n\&=9;
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ echo $n
9
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ 


далее рассмотрим такую штуку:
 - +    unary minus and plus

 

=====
bash
parameter expansion

смотри в man bash по слову "patameter expansion"

один из примеров по этой теме.а именно 
${parameter/pattern/string}


$ a=2334
$ (( a++ ))
$ echo $a
2335

$ echo ${a/23/BB}
BB35

получается что параметром может быть перменная. она указывается без знака
доллара.
что делается - в параметре ищется паттерн и когда он найден то он заменяется на string

в 2335 искался 23 и когда его нашли то его заменили на BB

======
bash
variable

при обьявлении еременой нельзя использовать пробелы. будет ошибка

$ a=1

$ a= 1
1: command not found

$ a = 1
a: command not found

=========
bash
declare

позволяет обьявить переменную точнее ее тип.

обьявить integer переменую
$ declare -i a

проверить какой тип у обьявленной переменной
$ declare -p a
declare -i a

$ a=12
$ echo $a
12


при попытке integer переменной присвоить неinteger значение , ее значение будет сброшено в ноль
$ a=e3
$ echo $a
0


оьявляем переменную у которой все буквы мелкие. если введем большую букву 
то она автоматом будет переделана в мелкую
$ declare -l kk
$ kk="qw12e12"
$ echo $kk
qw12e12
$ kk="QWE123kfjUOIU12"
$ echo $kk
qwe123kfjuoiu12


обьявляем переменну в котоой буквы все заглавные
$ declare -u UU
$ echo $UU
12kewfjewlkjbvvbbbb
$ UU="12kewfjewlkjBVVBBBB"
$ echo $UU
12KEWFJEWLKJBVVBBBB

это очень удобно для применения с bc и hex числами потому что bc понимает только 
когда hex числа ему скармиливаются только через заглавыне буквы

кстати на счет того как это внешняя программа /bin/echo получает переменную и понимает 
ее.например

$ /bin/echo $p

ведь дело в том что /bin/echo понятия не иммет ни о какой переменной $p. у него нет 
этой переменной в памяти. 

а дело в том что баш себя форкает. однако при этом дочерний процесс это все тот же баш
и далее этот дочерний баш он просто берет занчение переменной $p и подстлавяет число в 
execve

exeve("/bin/echo","...", число)

таким образом команде /bin/echo всего навсего нужно распечатать просто число которое к ней поступило в качестве первого параметра. тоесть я хочу сказать что /bin/echo понятия неимеет
ни о какой переменной $p. это баш выхывает execve и подставляет туда значение в форме уже 
готовой цифры. да безусолвно есть еще механизм что баш в execve пихает я массив  envp[]

int execve(const char *filename, char *const argv[],
                  char *const envp[]);

в котором содержатся все глобальные переменные баша но там небудет переменной $p.
итак еще раз.

есть команда

$/bin/echo $p

она неимеет к баш никакого отношения. чисто внешний бинарник.
скорей всего его код имеет вид

int main(int argc, char *argv[]){}

или вид

int main(int argc, char *argv[], char *envp[])

в любом случае наш параметр $p попадет  в argv[]. 
как это произойдет. баш себя форкнет то есть склонирует и создат свою копию.
и эта копия запустит execve ("/bin/echo",["/bin/echo", 20],NULL)
так вот фишка в том что в /bin/echo попадает не $p а уже его числовое значение ибо баш 
в execve подставить уже значение $p поэтому /bin/echo вообще понятия неимеет ни о каком $p
он просто на вход получает готовое число.
таким образом при запуске внешних программ сам баш раскрывает все переменные а во внешние 
программы он передает уже готовые числа\значения. вот откуд ответ на вопрос " а откуда echo 
знает о переменной $p".
ну я конечно молчу если используется не внешний файл /bin/echo а башевский builtin echo.там еще проще.


также замечу что баш передает внешней программе все глобальные переменные через третий парметр в execve ( не все переменные а именно только глобальные)

это  выглядит вот както так

execve("/bin/ls", ["ls", "--color=auto"], ["CLUTTER_IM_MODULE=xim", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "LC_MEASUREMENT=ru_RU.UTF-8", "MC_SID=29047", "LESSCLOSE=/usr/bin/lesspipe %s %"..., ...", "GTK_IM_MODULE=ibus", "LC_TIME=ru_RU.UTF-8", "OLDPWD=/home/vasya/Asm", "_=/bin/ls"]) = 0

для того что бы внещнаяя программа могла их принять у нее в ее main() должен быть указан третий параметр

int main(int argc, char *argv[], char *envp[])

но этот способ счиатется ненадежным непереносимым. более наежный способ это то что 
у внешней прграммы должны быть указана глобальная перменная

extern char **environ;
int main(int argc, char *argv[]) 

тогда при вызове башем execve ядро когда будет создавать пространство памяти 
для ноового процесса создать там переменную environ и в нее запишет весь массив из третей переменной execve. такой способ считвается переносимым.

это ответ на вопрос как же из баша переменные передаются другим программамам.

========================

zabbix
/etc/passwd

история - в заббиксе можно увидеть часто алерт вида   "/etc/passwd has been changed"

как работает item от этого триггера  : zabbix использует линукс команду cksum. что она делает - она вычиясляет crc от файла.
тоесть этот crc он высчитывается от байтового содержания файла. ( а от имени файла и от его времени изменения crc независит что тоже важно).

$ cksum /etc/passwd
2207685566 3268 /etc/passwd

2207685566 первое число это crc32 число(контрольная сумма).
3268 это разер файла в баайтах

я проверил - изменение имени файла реально не влияет на cksum
также изменение времен ( acccess time, modify time) без изменения контента файла(через touch -a -m /etc/passwd)  тоже невлияет на cksum

таким образом еще раз - cksum вычисляет crc от файла и на это влияет только содержимое файла а имя файла и  время доступа к файлу никак на это невлияет.


итак мы поняли что если триггер сработал значит 100% контент файла /etc/passwd был точно имзенен.

если мы руками там ничего неменяли тоесть еще один вариант -  так кто же  засунул нового юзера либо сменил 
пароль в /etc/passwd. так вот оказыается что это случается когда мы устаналиваем новый пакет.
примером такого пакета явялется пакет ntp. при установке этого пакета он долавбяет в /etc/passwd  нового юзера ntp

ntp:x:129:136::/nonexistent:/usr/sbin/nologin

вот и разгадка алерта!

так вот - когда файл /etc/passwd будет изменен то это время изменения останется в *time файла. тоесть

# stat /etc/passwd
.....
Access: 2022-11-12 01:51:02.857747523 +0600
Modify: 2022-11-12 01:51:02.857747523 +0600
Change: 2022-11-12 01:51:02.872747584 +0600

так вот если алерт вылез. и непонятно почему и откуда. то полезно взять время модификации файла passwd 
и проверить а ровно в это время не был ли установлен в системе НОВЫЙ ПАКЕТ!?!?!?!?!?!?!!?!?

для yum это:
# tail /var/log/yum.log 
Nov 12 01:51:02 Installed: autogen-libopts-5.18-5.el7.x86_64
Nov 12 01:51:03 Installed: ntpdate-4.2.6p5-29.el7.centos.2.x86_64
Nov 12 01:51:04 Installed: ntp-4.2.6p5-29.el7.centos.2.x86_64


и вот мы увидели что ровно втоже время когда был модифицирован passwd файл ставился в системе пакет ntp. вот из
за этого и оттуда файл passwd и был изменен!


для apt это:

# stat /etc/passwd
.....
Access: 2022-11-12 01:48:49.161664596 +0600
Modify: 2022-11-12 01:48:49.145662840 +0600
Change: 2022-11-12 01:48:49.149663279 +0600


# tail -n 40 /var/log/apt/history.log
Start-Date: 2022-11-12  01:48:47
Commandline: apt-get install ntp
End-Date: 2022-11-12  01:48:55

вот! во время модификации passwd устаналвился пакет ntp который его и поменял!

Итого: если заббикс выплюнул алерт то полезно проверить может быть во время модификации passwd в системе был установлен некоторый интересный пакет наример ntp,
который лезет сам в passwd и туда всталяет своего служебного юзера.


что еще хочется сказать. 
алерт забикса он в целом полезен. но он вообще нераскрывает  кто когда как и на что поменял файл /etc/passwd

========================================

если вылезает такая шибка

update-initramfs: Generating /boot/initrd.img-5.4.0-91-generic
W: Possible missing firmware /lib/firmware/rtl_nic/rtl8125a-3.fw for module r8169
W: Possible missing firmware /lib/firmware/rtl_nic/rtl8168fp-3.fw for module r8169
W: Possible missing firmware /lib/firmware/i915/tgl_dmc_ver2_04.bin for module i915
W: Possible missing firmware /lib/firmware/i915/skl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/bxt_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/kbl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/glk_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/kbl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/icl_guc_33.0.0.bin for module i915
update-initramfs: Generating /boot/initrd.img-5.4.0-84-generic

о том что нехватает какойто firmare
что делать

качаем эти firmware с сайта ядра.
mkdir rtl8125b_fw
cd rtl8125b_fw
wget https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/rtl_nic/rtl8125b-2.fw
wget https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/rtl_nic/rtl8168fp-3.fw
sudo cp *.fw /lib/firmware/rtl_nic/
sudo update-initramfs -u

и обноавляем initramfs

аналогично на сайте  в папке i915 лежат недостющие для него firmware

https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/i915/

=====
как узнать какое устройство работает на каком драйвере

$ lspci -vv -nn | grep -E "..:..\..|modules"

пример вывода:
00:02.0 VGA compatible controller [0300]: Intel Corporation Device [8086:3ea0] (rev 02) (prog-if 00 [VGA controller])
	Kernel modules: i915

00:04.0 Signal processing controller [1180]: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem [8086:1903] (rev 0c)
	Kernel modules: processor_thermal_device

00:12.0 Signal processing controller [1180]: Intel Corporation Device [8086:9df9] (rev 30)
	Kernel modules: intel_pch_thermal

видно название железки и обслуживающий ее драйвер (модулья ядра)

====

apropos

полжим мы хотим найти man по какйото теме в линуксе. 

тогда можно заюзать apropos . пишут что каждый маг содержит ключевые солова и апропос
ищет нам статьи мана по ключевым словами. пример хотим почитать про firmware

$ apropos firmware
bootctl (1)          - Control the firmware and boot manager settings
btcflash (8)         - firmware flash utility for BTC DRW1008 DVD+/-RW recorder.
hex2hcd (1)          - firmware converter
hp-firmware (1)      - Firmware Download Utility
nvme-fw-commit (1)   - Used to verify and commit a firmware image.
nvme-fw-download (1) - Download all or a portion of an nvme firmware image.
nvme-fw-log (1)      - Send NVMe Firmware log page request, returns result and log
rpl8 (8)             - Firmware loader for DVD drives
[vasya@lenovo docs]$ 

-----


initramfs
firmware
driver


когда мы обновляем initramfs то может выскочить на экране что у нас нехватает /lib/firmware/.. файлов
из пакетов искать это мудота. там бывает нет тог что надо. простой выход скачать их отсююда https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/refs/

а потом просто копируемфайлы в папку /lib/firmware

что за хрень firmware. 

вот здесь пишут https://wiki.ubuntu.com/Kernel/Firmware  что  каждый а может и не каждый драйвер состоит из двух частей одна часть это модуль ядра. фишка модуля ядра в том что от него есть исходный код. 
а вторая часть это готовый бинарник без исходного кода который зоветмя фирмвейр. и этот бинарнтик надо 
закачивать внутрь железки. почему его там нет изналачально непонятно. и вот так как это бинарник без исхоных кодов то начтнается мудота где его взять ибо это же линукс. тут у всего должны быть исходные коды.
поэтому их придодися качать отдебно.

как проверить какие firmware по факту были загружены

# dmesg -T | grep -e 'firmware'
[Чт дек 29 17:03:26 2022] [drm] Finished loading DMC firmware i915/kbl_dmc_ver1_04.bin (v1.4)
[Чт дек 29 17:03:30 2022] ath10k_pci 0000:02:00.0: firmware ver WLAN.TF.2.1-00021-QCARMSWP-1 api 6 features wowlan,ignore-otp crc32 42e41877

----
cron

была следдущая тупая залупа

задание cron не отрабатывало только потому что файл крона в /etc/cron.d/file имел 
неправильные permissions  ! тоесть обязательно надо чтобы root.root и никак по другому.

вот такой ебнутый cron по архитектуре.

догадка пришла тогда когда посмотрел journalctl -f -u crond

----

cron

по дефолту все крон джобы исполняются от root
и только если мы укажем в строке крон джоба другого юзера то джоб будет 
исполнятся не от рута.

-----

как нам удалить переменную из баша которую мы обьявили чеерз export
ответ unset

пример
$ export vasya =1
$ set | grep vasya
$ unset vasya
$ set | grep 

-------

ufw настройка файрволла

как настроить файрволл

по большому счету либо ufw на хосте либо докер. но чтото одно.
потому что докер лезет в настройки iptabes и создает правила в обход ufw.
ессли же актииивировать MANAGE_BUILTINS=yes то ufw стирает часть прпавил докера
и он неможет запускать контейнеры. поэтмоу на лицо явный конфликт. 
а если использовать MANAGE_BUILTINS=no то толку от ufw ноль. ибо докер 
открыает порты и пиздец. поэтому либо докер+внешний файрволл. 
либо ufw и никакого докера. единственное что если мы будем на хосте запускать 
докер контейнер который не открыавет порты то тогда ufw можно использовать 
на хосте ибо докер неменяет сет правила при этом. соотсвтенно ufw надо юзать
с опцией MANAGE_BUILTINS=yes 
это кратно. а подробности ниже.




супер важная вещь что  ufw по дефолту контролирует только часть правил iptables.
а чтобы ufw контролировал все правила целиком то надо выставить
# cat /etc/default/ufw
MANAGE_BUILTINS=yes
и перезагрузка сервиса. об этом читай в linux-general.txt
возможно это может мешать докеру. это надо выяснять.


далее  отключить ipv6 на ufw 
# sudo nano /etc/default/ufw
IPV6=no
      

типовой набор команд активации ufw:

   98  ufw default deny incoming
   99  ufw default allow outgoing
  100  ufw allow 22/tcp
  102  ufw show added numbered
  103  ufw enable
  104  ufw allow 80/tcp
  105  ufw allow 443/tcp
  106  ufw reload
  108  ufw status numbered
  111  ufw status verbose
   11  ufw allow in  on <interface> to any  (это правило юзать чтобы разрешить все входящие на 
   интерфейс который будет отвечать за локалку)


Status: active

     To                         Action      From
     --                         ------      ----
[ 1] 22/tcp                     ALLOW IN    Anywhere                  
[ 2] 80/tcp                     ALLOW IN    Anywhere                  
[ 3] 443/tcp                    ALLOW IN    Anywhere        


как настроить через него nat и port forward

https://gist.github.com/kimus/9315140


ДАЛЕЕ: КАК активировать NAT :

/etc/default/ufw
DEFAULT_FORWARD_POLICY="ACCEPT"


в sysctl 
net.ipv4.ip_forward=1


далее сказано что надо разместить вот этот кусок вначале файла /etc/ufw/before.rules до блока *filter
однако в man ufw (который тоже хороший документ) сказано что этот кусок нужно разместить в конце
этого файла после блока *filter




# NAT table rules
*nat
:POSTROUTING ACCEPT [0:0]

# Forward traffic through eth0 - Change to match you out-interface
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE

# don't delete the 'COMMIT' line or these nat table rules won't
# be processed
COMMIT


перегружаем правила готово
# ufw reload


однако тут выясняется прикол. если мы сделаем пару перезагрузок ufw 
то мы заметим что правила каасающиеся NAT они размножаются это мможно увидеть через iptables-save



будет вот чтото типа такого

*nat
:PREROUTING ACCEPT [385:22237]
:INPUT ACCEPT [63:3370]
:OUTPUT ACCEPT [5:368]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
COMMIT



это же жесть!

так вот я нашел разьяснение = https://bugs.launchpad.net/ufw/+bug/364558
цитирую 

Thank you for using ufw and taking the time to report a bug. This is by design to make sure ufw doesn't step on other applications' rules. From /usr/share/doc/ufw/README.gz:

The primary chains are ufw-before-*, ufw-after-* and ufw-reject-*. The
treatment of iptables' built-in chains can be controlled with the
MANAGE_BUILTINS configuration option (in /etc/default/ufw). By default this is
set to 'no', which means that other than adding the primary chains, the
built-in chains will remain untouched. This also means that these primary
chains will stay in the table, even after disabling ufw. This is to make sure
that the primary chains don't move around other non-ufw rules and chains. To
completely flush the built-in chains with this configuration, you can use:

# /usr/share/ufw/ufw-init flush-all

Alternately, ufw may also take full control of the firewall by setting
MANAGE_BUILTINS=yes in /etc/defaults/ufw. This will flush all the built-in
rules and delete the non-built-in rules on start, stop and reload.


поэтому я выбрал решение

MANAGE_BUILTINS=yes in /etc/defaults/ufw

вот при таком раскладе уже перезагрузка ufw недает разможения правил в iptables-save

также при отключенной опции и наличии докера  наш файрволл теряет весь смысл потому что докер
будет вставлять свои цеопчки и контейнеры будут выставлены наружу!!!


еще один важный момент про связь между ufw и docker
если у нас выставлена опция MANAGE_BUILTINS=no
то если мы стартуем контейнер 
# docker run -it --rm -d -p 80:80 --name web2 nginx
то докер добавляет сам правила в таблицу iptables и таким макаром 
открывает на хосте порты наружу! все файрволл пробит изнутри.
а что будет если перезагрузить ufw ?
# ufw reload
будет то что ufw нетрогает правила докера  и порт открытый через докер 
останется открытым!


а если у нас выставлена опция MANAGE_BUILTINS=yes
тогда при запуске ufw он стирает часть правил докера
и при попытке запуска докера  увидим вот что 

# docker run -it --rm -d -p 80:80 --name web2 nginx

f2de59cccf062b2a6cd320d3a0106c657e54ee99ed02a06b80abb4f8a2eec4b1
docker: Error response from daemon: driver failed programming external connectivity on endpoint web2 (27b91c86e25636fbdbda98dedc2e3a59312c1bf5532d62dcd37b14f809d151d8):  (iptables failed: iptables --wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 --dport 80 -j ACCEPT: iptables: No chain/target/match by that name.
 (exit status 1)).

если мы перезапустим сервис докера
# systemctl restart docker

то он создаст свои стертые правила и тогда уже можно успешно запустить контейнер 

# docker run -it --rm -d -p 80:80 --name web2 nginx

и у нас опять порт открыт наружу !
а что будет если перезапустить ufw? он сотрет часть правил докера 
и это приведет вот к чему = с самого хоста доступ в контенер по порту будет работать
но снаружи доступа к порту контейнера нет.

если наша задача закрыть порт контейнера снаружи то тогда надо при каждом новом запуске
или перезапуске контейнера перезапускать ufw!!а это полная фигня а не продакшн.


============




----------

parted, expand, grow, extend


вот если мы увеличили размер диска в гипервизоре

далее мы обнвоили об этом инфо через

# rescan-scsi-tool

далее надо как то через parted изменить раздел 


# lsblk -f  -o name,size
NAME    SIZE
sda      24G
├─sda1  953M
├─sda2    1G
├─sda3    2G
└─sda4 18,4G




расширяем раздел sda4

# parted /dev/sda
(parted) resizepart 4 100%
Warning: Partition /dev/sda4 is being used. Are you sure you want to continue?
Yes/No? Yes                                                               



# lsblk -f  -o name,size               
NAME    SIZE
sda      24G
├─sda1  953M
├─sda2    1G
├─sda3    2G
└─sda4 20,1G


удобство в том что resizepart 4 100% даем то что ненужно руками вбирвать размер хвоста
мы просто говорим расширь на все сколько можешь


и далее после расширения партиции надо еще расширить ФС

# xfs_grows  /mount_pint
или
# resize2fs /device


--------------

netplan

типовая настройка

ip адрес
если мы настраиваем сет карту через netplan вот конфиг типовой

# cat /etc/netplan/00-installer-config.yaml 
network:
  ethernets:
    eth0:
      optional: true
      addresses:
      - 81.81.81.81/28
      nameservers:
        addresses:
        - 8.8.8.8
        search: []
      routes:
      - to: default
        via: 81.81.81.80
    eth1:
      optional: true
      addresses:
      - 10.10.10.1/24
      nameservers:
        addresses:
        - 8.8.8.8
        search: []
  version: 2


и здесь я укажу очень важную опцию 
optional: true
смысл ее в том что при такой настройке линукс небудет ждать пока указанный интерфейс будет полностью сконфигурирован
и готов к работе (согласно man netplan) - что это по факту значит "будет полностью готов к работе"
но по факту если этой настройки нет то  при загруке убунты у нас загрузка останавливается на фразе

"job is running for wait for network to be configured.." 

и так висит 30-60 секунд.
а вот с этой настройкой такой хуйни нет и вртуалка грузится мгновенно.

а вот кстати как проверить скорость интернета из команднйо строки

# apt-get install -y speedtest-cli


---
mysql
mariadb

делаем

# ps aux | grep mariadb


вопрос как узнать на данный момент база запущена из сервиса или руками.
так вот ответ такой  - если база работает  потому что ее запустили из сервиса то в процессах этот процесс будет иметь очень простой вид

ps aux | grep mariadb
mysql     531425 24.1 20.2 7798524 2066700 ?     Ssl  20:33   7:12 /usr/sbin/mariadbd

а вот если прцоесс был запущен руками то вид будет совершенно другой сложный.

# ps aux | grep mariadb
mysql     493096 48.4 85.4 12509856 8709908 ?    Sl   мар23 1592:12 /usr/sbin/mariadbd --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/mysql/plugin --user=mysql --skip-grant-tables --log-error=/var/log/mysql/error.log --open-files-limit=16364 --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/run/mysqld/mysqld.sock --port=3306

ну и конечно эо можно проверить через банальный

# systemctl status mariadb
и он покажет работает ли сервис сейчас на данный момент или он упал.

----------

mariadb
mysql

проверить текущий статус  ведет ли mysql\mariadb бинарный лог


> show variables like 'log_bin';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | ON    |
+---------------+-------+
1 row in set (0,001 sec)



посмотреть список бинарных логов

> SHOW BINARY LOGS;
+--------------------+------------+
| Log_name           | File_size  |
+--------------------+------------+
| mariadb-bin.000071 |          0 |
| mariadb-bin.000072 |          0 |
| mariadb-bin.000073 |          0 |
| mariadb-bin.000074 |          0 |
| mariadb-bin.000075 |          0 |
| mariadb-bin.000076 |          0 |
| mariadb-bin.000077 |          0 |
| mariadb-bin.000078 |          0 |
| mariadb-bin.000079 |          0 |
| mariadb-bin.000080 |          0 |
| mariadb-bin.000081 |          0 |
| mariadb-bin.000082 |          0 |
| mariadb-bin.000083 |          0 |
| mariadb-bin.000084 |          0 |
| mariadb-bin.000085 | 1048585914 |
| mariadb-bin.000086 |  995604484 |
+--------------------+------------+


как отключить
идем в конфиг и 

[mysqld]
skip-log-bin = true 


---------------------

mariadb
mysql

slow query log

как проверить что он щас активирован


> show variables like 'slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | ON    |
+----------------+-------+



как это выключить без перезапуска 

>  SET GLOBAL slow_query_log = 'OFF';

но чтобы проверить сработало или нет то  надо обязательно 
выйти из мускула и обратно зайти. 

> show variables like 'slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | OFF   |
+----------------+-------+


а если не выйти\зайти то будет показывать 
что якобы по прежнему все работает.


а как через конфиг отключить?
ну вроде вот так - просто закоментить

#slow_query_log          = 1
#slow_query_log_file     = /var/log/mysql/mariadb-slow.log
#log_slow_rate_limit    = 1000
#log_slow_verbosity      = query_plan
#log_slow_admin_statements

----------

mariadb
mysql

> show variables like 'general_log';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| general_log   | OFF   |
+---------------+-------+


----------------

ipv6
ubuntu

как отключить

net.ipv6.conf.all.disable_ipv6=1
net.ipv6.conf.default.disable_ipv6=1
net.ipv6.conf.lo.disable_ipv6 = 1

-------------

logrotate

интерснейший момент.

как заставить лог ротейт ртейтить логи нетолько в указанной папке но и в ее подпапках

/var/log/basedir/*.log /var/log/basedir/*/*.log {
    daily
    rotate 5
}


в этом примере будут обработаны файлы нетолько в папке /var/log/basedir/
но и в во всех папаках вида /var/log/basedir/XXX

это круто!

---------------------
logrotate

 пример 


конфиг логротетйат:


# export d1="/etc/logrotate.d/mysql-backup" && touch $d1 && chown 0.0 $d1 && chmod 644 $d1

# cat mysql-backup 
/var/backups/mysql/*.gz {
    rotate 40
    daily
    dateext
    nocompress
    notifempty
    nocreate
    missingok
}



daily = срабатывает раз в день. ( вобще ежедненво это самый минимальный кусок времени когда логротейт сразбаывает. быстрее он неможет)

dateext = доабвляеть к архивному файлу тайм стамп (день месяц год)

nocompress  = несжимать архив потому что он уже и так сжат

notifempty = неархивирвать пустые файлы

nocreate = когда зааривхировал файл (он же его переимноваые и исходный иссчезает) то несозадвать новый. ибо незачем

missingok = если исходного файла нет то окей. номрально.это значит что логротейт сработал и убрал исходный файл а новый архив через крон
таки не появился. ну и хер сним

rotate 40 = хранить 40 архивных копий. а 41-ю удалять.


как проверить что logrotate будет рабооать, а вот только так:

# logrotate -v /etc/logrotate.d/mysql-backup  -f 

-f = завсталвяет насильно срабаывает ротейт. иначе он нихера делать неубутдет этого.

установка закончена.

===
ubuntu 

если завситли окна как презапусить cinanmon :


от прав простого юзера

$ cinnamon --replace -d :0.0

как отчлюит apport (котоырй краш дампы снимает)

# systenctl stop apport && systemcl diable apport


красота!

====
| snap

отключчить автоматическое оновление снапов

дело в том что по дефолту так там установлено что 4 раза в день система пытается обновить
каждый снап пакет. и это приводит к диким тормозам то бишь открываешь top 
и там висит бинарник snapd и жрет более 100%. и таких бинарников там может быть два например.
нахер это надо.

чтобы отключить обновление снапов надо :

# sudo systemctl stop snapd.service
# sudo systemctl mask snapd.service

чтоб вернуть обоатно

# sudo systemctl unmask snapd.service
# sudo systemctl start  snapd.service
# sudo snap refresh

приэтом сами снапы родолжают работать !

но это вреод как херноввый алгоритм остановки автоообновлений. более нормальный вариант это 
# snap refresh --hold=forever

===
| snap
еще очень полезная вещь про snap это то что если мы юзаем lxd контейнеры.
то нам внутри этих контейнеров то нам там обычно snap ненужен.
поэтому если запустили контейенр то нужно внутри него удалит snap иначе эта падла
будет проверять snap пакеты на новые версии и охиренно грузить процессор.

выглядит это так. смотри в top и видим там 100% загрузку цпу у процесса snapd и\или snapfuse
это точно значит что snap заимается обновланием. а это нам нахер ненадо.
поэтому внутри lxd корнтенера надо выполнить

# apt-get purge -y snapd*
===

| LXDE

есть такая легкая граф оболочка.
она по дефолту стоит в lubuntu
но ее без проблем можно поставит на классический убунту.
	# apt install lxde

и еще надо если нет поставит такую хрень как
	# apt install  lightdm

далее вот что . когда мы загрузили комп. и у нас экран где мы указываем логин пароль.
там сверху справа надо логином юзера есть белый круг. мы на него тыкаем и там есть список
граф оболочек которцю надо загрузить. там выбираем LXDE. и вуаля. мы в нее загрузися.

еше есть такой прикол что кнопка logout когда мы в LXDE зашли в убунту 18 ( в лубунту с этим проблем нет)
неработает. как быть. закрываем все окна у текушего юзера. и перезагружаем службу lightdm

# systemctl restart lightdm

и мы попадем обратно в окно где надо вводить логин пароль. тоесть таким макаром мы как бы 
добьемся функции logout


далее.
как убрать сраный "update notifier"
надо зайти в /etc/xdg/autostart
и удалить файл upd-*
суки


далее. 
как добавить русскуб клаву. 
в лубунту там есть раздел клава в панели управления. если же мы запустили lxde в убунту18
то делать нужно совсем по другому.

права кнопка на панели задач - "add\remove panel items" - add - "keyboard layout hadler" - ...
дальше уже понятно



===
| AC
| power
| battery

утилита для мониторинга уровня заряда мышки, аккумулятора

список устройств с аккумуляторами
$ upower -e
/org/freedesktop/UPower/devices/line_power_ADP0
/org/freedesktop/UPower/devices/battery_BAT0
/org/freedesktop/UPower/devices/mouse_hidpp_battery_3
/org/freedesktop/UPower/devices/DisplayDevice



$ upower -i /org/freedesktop/UPower/devices/battery_BAT0
  native-path:          BAT0
  vendor:               LGC
  model:                L18L3PF1
  serial:               2267
  power supply:         yes
  updated:              Вс 17 сен 2023 19:53:21 (24 seconds ago)
  has history:          yes
  has statistics:       yes
  battery
    present:             yes
    rechargeable:        yes
    state:               fully-charged
    warning-level:       none
    energy:              35,5 Wh
    energy-empty:        0 Wh
    energy-full:         37,07 Wh
    energy-full-design:  36 Wh
    energy-rate:         0,00280338 W
    voltage:             12,381 V
    percentage:          95%
    capacity:            100%
    technology:          lithium-polymer
    icon-name:          'battery-full-charged-symbolic'


$ upower -i /org/freedesktop/UPower/devices/line_power_ADP0
  native-path:          ADP0
  power supply:         yes
  updated:              Вс 17 сен 2023 18:03:20 (6649 seconds ago)
  has history:          no
  has statistics:       no
  line-power
    warning-level:       none
    online:              yes
    icon-name:          'ac-adapter-symbolic'


$ upower -i            /org/freedesktop/UPower/devices/mouse_hidpp_battery_3
  native-path:          hidpp_battery_3
  model:                Wireless Mouse M315/M235
  serial:               4009-b9-50-a6-d3
  power supply:         no
  updated:              Вс 17 сен 2023 19:52:52 (95 seconds ago)
  has history:          yes
  has statistics:       yes
  mouse
    present:             yes
    rechargeable:        yes
    state:               discharging
    warning-level:       none
    battery-level:       normal
    percentage:          55%
    icon-name:          'battery-good-symbolic'





$ upower -i           /org/freedesktop/UPower/devices/DisplayDevice
  power supply:         yes
  updated:              Вс 17 сен 2023 19:51:21 (201 seconds ago)
  has history:          no
  has statistics:       no
  battery
    present:             yes
    state:               fully-charged
    warning-level:       none
    energy:              35,5 Wh
    energy-full:         37,07 Wh
    energy-rate:         0,00280338 W
    percentage:          95%
    icon-name:          'battery-full-charged-symbolic'


| youtube

альтернативный плеер ютуба.

https://freetubeapp.io/#download
там есть бинарник для убунту



===

| cpu
| hyper-threading

статья = https://www.baeldung.com/linux/disable-hyperthreading


можно посмотеть через lscpu что у нас с гипертрейдингом.

а еще можно проверить что HT активировано вот так

# cat /sys/devices/system/cpu/smt/active
1

если 1 то гипертрединг актиирован


далее смотрим вот такое
$ grep -H . /sys/devices/system/cpu/cpu*/topology/thread_siblings_list 
/sys/devices/system/cpu/cpu0/topology/thread_siblings_list:0-1
/sys/devices/system/cpu/cpu1/topology/thread_siblings_list:0-1
/sys/devices/system/cpu/cpu2/topology/thread_siblings_list:2-3
/sys/devices/system/cpu/cpu3/topology/thread_siblings_list:2-3

отсюда мы видим записи вида 0-1 это значит что  cpu0 это реальное ядро. 
а  cpu1 это гипетредингвое ядро.
таким макаром мы понимаем что ядра 1 и 3 это фиктивные гипетрединговые ядра.

так вот щас мы будем их выключать налету.

# echo 0 | sudo tee /sys/devices/system/cpu/cpu1/online
# echo 0 | sudo tee /sys/devices/system/cpu/cpu3/online

после этого в top исчезнут гипертрединовые ядра.
ура


статья пишет что отключать их онлайн неочень желаттельно.
а включать обратно их онлайн типа категорически ненадо.

| 5GHz

обнаружил такой прикол. 
конекчусь к вай фай точке через 5GHz и имею 50% потери пакетов даже в рамках локалки
котрую обеспечивает эта точка.

конекчусь через эту точку по частоте 2GHz и все окей.



| cpu 
| turbo
| power
| scale
| MHZ
| temperature


у интел есть такая фича. если у нас многоядерный проц. но  в данный момент у
нас запущена толькоо одна программа. тоесть по факту может три ядра спать а одно ядро
работать то за счет этого можно на какйото времы повысить частоту одного ядра гораздо 
выше чем его обычная частота. 

есть такая прграмма i7z

вот что она покаызаевает

Cpu speed from cpuinfo 1799.00Mhz
cpuinfo might be wrong if cpufreq is enabled. To guess correctly try estimating via tsc
Linux's inbuilt cpu_khz code emulated now
True Frequency (without accounting Turbo) 1799 MHz
  CPU Multiplier 18x || Bus clock frequency (BCLK) 99.94 MHz

Socket [0] - [physical cores=4, logical cores=4, max online cores ever=4]
  TURBO ENABLED on 4 Cores, Hyper Threading OFF
  Max Frequency without considering Turbo 1898.94 MHz (99.94 x [19])
  Max TURBO Multiplier (if Enabled) with 1/2/3/4 Cores is  39x/38x/37x/37x


штатная частота 1800 MHZ у ядер. но  она может повысистя в рамках TURBO фичи до 39x
тоесть частота шины 100 Mhz * 39 = 3900 MHZ. нехило.

так вот чтобы отклбчить эту фичу можно налету

# "echo 1 >  /sys/devices/system/cpu/intel_pstate/no_turbo"
все. тпеперь у нас турбо фича выключена. прчием сразу для всех ядер.

правдп i7z почемуто все равно будет показывать что якобы TURBO фича активирована.

статья где можго почитать про стейты процессора - https://www.kernel.org/doc/html/v5.0/admin-guide/pm/intel_pstate.html . однако это очень длтинная и скушная статья

она посвяена драйверу intel_pstate который рулит состояниями процессора.

а более кокнретная и полезная статья это 
 вот тут об этом написано - https://wiki.archlinux.org/title/CPU_frequency_scaling


далее я поговрю про управление частотй цпу и его темперауторй как следствие опираясь 
на все тутже статью из archlinux
значит ситуация такая. есть драйвер который управляет частотой цпу и как следствие это влияет
на температуру цпу. 

драйверов обычно два: acpi-cpufreq либо intel_pstate
на более новых убунтах по дефолту работает более новый драйвер intel_pstate
а если его отключить то начинает работать драйвер acpi-cpufreq

как выяснить какой драйвер управляющий частотой работает щас:
# cat /sys/devices/system/cpu/cpufreq/policy*/scaling_driver 
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate

итак это текущий драйвер управляющий частотой.

как его вырубить чтобы активировать драйвер acpi-cpufreq
идем в 
# cat    /etc/default/grub | grep -v '#'

GRUB_CMDLINE_LINUX_DEFAULT="... intel_pstate=disable ... "

тоесть надо вставить intel_pstate=disable  в /etc/default/grub

далее надо запустить обноавление граба

# update-grub
либо 
# update-grub2


у меня граб2
# dpkg -l | grep grub
ii  grub-common                                   2.06-2ubuntu7.2    

однако у меня даже # update-grub
тоже прокатило.


итак как опрелить как драйвер щас отвечает за частотй цпу узнали.
как выбрать какой из них будет работаь узнали.

как узнать текущую сейчашнюю часоту цпу на компе.
0)
# cat /proc/cpuinfo | grep MHz
cpu MHz		: 400.012
cpu MHz		: 400.000
cpu MHz		: 400.000
cpu MHz		: 400.005
cpu MHz		: 400.007
cpu MHz		: 400.000
cpu MHz		: 400.005
cpu MHz		: 400.002

1) 
# i7z
насколько я понимаю i7z показывает частоту только на реальных ядрах.
гипетрединговые ядра он не показывает
Current Frequency 802.24 MHz [99.73 x 8.04] (Max of below)
        Core [core-id]  :Actual Freq (Mult.)      C0%   Halt(C1)%  C3 %   C6 %   C7 %  Temp      VCore
        Core 1 [0]:       802.24 (8.04x)           1    4.07       0       0    95.7    54      0.6649
        Core 2 [2]:       797.60 (8.00x)        3.31    2.49       1       1    94.5    53      0.6666



2) втоорой вариант 
# cat /sys/devices/system/cpu/cpufreq/policy*/scaling_cur_freq
400011
400019
400026
400016
400010
400009
400025
400014


тут тоже есть свой прикол.
если у нас работает драйвер acpi-cpufreq то у нас помимо счетчика scaling_cur_freq еще один счетчик
cpuinfo_cur_freq
якобы и тот и тот показывает текущу частоту на ядре. однако это не так.
опыты показывают что scaling_cur_freq  показывает реальную частоту а cpuinfo_cur_freq показывает
некую хрень. попытки найти почемутак и что же насамаом деле поркаызвает cpuinfo_cur_freq
ичего недали.  статьи в инетер пишут прямо противоположное.

также эксперимент показывает что и /proc/cpuinfo и i7z показывают именно теже данные 
что в счетчике scaling_cur_freq

еще раз подчеркну что если драйвер intel_pstet то счетчика cpuinfo_cur_freq вообще нет.
он появляется в /sys если драйвер часоты acpi-cpufreq

далее. распишу
что значат все эти счетчики:
affected_cpus
base_frequency
cpuinfo_max_freq
cpuinfo_min_freq
cpuinfo_transition_latency
energy_performance_available_preferences
energy_performance_preference
related_cpus
scaling_available_governors
scaling_cur_freq
scaling_driver
scaling_governor  (туту надо написать то что если мы меняем говерное для одного цпу то автоматом
оно становится тааиким же доля других цпу)
scaling_max_freq
scaling_min_freq
scaling_setspeed

во первых они лежат в папке  /sys/devices/system/cpu/cpufreq/policy0 под каждое ядро своя папка
поехали
	# cat scaling_driver 
intel_pstate

	# cat scaling_driver 
acpi-cpufreq

в нем прописан драйвер который управляет частотой ядра.
также важно то что в зависимости от того какой драйвер в этой папке бывают несколько 
разные счетчики.

# cat base_frequency 
1600000
покаызвает штатную частоту ядра по паспорту

# cat bios_limit 
800000
это незнаю что значит.

# cat cpuinfo_max_freq 
1600000
по мне это тоже самое. макс частота я дра по паспорту

# cat cpuinfo_min_freq
400000
минимальная частотп по паспотрту

# cat cpuinfo_transition_latency 
10000
не знаю что значит

# cat scaling_available_governors  
performance powersave

# cat scaling_available_governors
conservative ondemand userspace powersave performance schedutil 

в зависимости от драйвера  "scaling_available_governors"  показвает доступные говернеры.
гавернер - это такой переключатель который влияет как будет изменяться частота цпу в зависиомтси 
от нагрузки. тоесть 

performance = означает что все время частота ядра прддреживается на максимуме
powersave = означает что все время частота ядра поддежвается на минимуме
забегая вперед скажу что если драйвер "acpi-cpufreq" то гавернер "powersave" работак как надо.
а если драйвер "intel_pstate" то гавернер "powersave" работает как то хреново.  а именно - на холостом
ходу частота несколко выше чем минимальная . скажем минималрая 400МГЦ а он ее делает 600-700.
а при росте нагрузки на цпу частота начинает потихоньку повышаться. 

ondemand = означает что при повышении наггрузки частота цпу будет повышаться. а при сбросе нагрузки
то частота будет сбратсываться до минимальной.

если драйвер intel_pstate то всего два гавернера доступно performance powersave


# cat scaling_cur_freq
400021
показывает текущую частоту цпу. 
этот счетчик постоаянно слегка плавает.  почму. потому что скорость цпу складывается
из двух цифр. одна это коэффициент умножения внутри цпу. а вторая это частота шины цпу.
так вот коэффициуент (напрмиер он равен 8) он постоянный. а частота шины цпу почемуто плавает 
то она 97Mhz то она 100Mhz. из за этого и скорость цпу постоянно несколко плавает.

если у нас дрвайвер  acpi-cpufreq
то у нас есть ещеодин счетчик

# cat  cpuinfo_cur_freq 
800000
по идее оно тоже должно оказывать текущую скорсть ядра. ооднако 
по факту непнятно что значит этот счетчик. если scaling_cur_freq постяоно плавает. то этот 
счетчик всегда застывший. 
эти оба счетчика могут отличаться. я искал в инете  . там статьи противоречат друг другу. 
в одних пишут что один счтечик более верный. вторые пишут что второй счетчик более верный.
если драйвер intel_pstate то в нем cpuinfo_cur_freq вобще отсутствует.
из прктики я выяснил что и /proc/cpuinfo и i7z они пользуются scaling_cur_freq
также atop показыает две цифры
	avgf  800MHz | avgscal  30%
как я понял avgf берется из cpuinfo_cur_freq
а avgscal берется из  scaling_cur_freq (правда показыает не частоту а процент от макс частоты)

в итоге я когда хочу понять какя же частота щас на ядре смотрю на scaling_cur_freq

# cat scaling_max_freq
400000
показыает на какую макс частоту гавернер может переключать цпу. фишка в том что 
этот параметр можно менять налету руками

# echo "800000" | tee  scaling_max_freq
таким макаром можно налету менять верхнюю планку работы цпу

# cat scaling_min_freq
400000
минималная часотат до которой гавернер может опускать часоту ядра. 
ее тжое можно менять на лету.

если драйвер acpi-cpufreq тоесть еще один счетчик
# cat scaling_available_frequencies
2601000 2600000 2500000 2300000 2200000 2100000 2000000 1800000 1700000 1600000 1400000 1300000 1200000 1100000 900000 800000 
она покзаывает по каким частотам может скакать процессор

отталкиываясь от нее понятно что scaling_max_freq неможет быть больше чем 2601000
и scaling_min_freq неможет быть ниже  800000


таким макаром- как можно управлять частотй цпу. можно руками урезать макс и минимальную частоту
ядра. и после этогго мговновеенно ядро будет работаь на заданной частоте. наприммер

# echo "400000" | tee scaling_min_freq
# echo "400000" | tee scaling_max_freq

теперь внезависимости от гавернера у нас ядро зажато в частоте 400 МГЦ.
все гавернеры дергают частоты на цпу именно в заданных рамках 
	scaling_min_freq << текущая частота << scaling_max_freq
 
гавернеры играю ту роль что они позволяют автоматом переключать часоты на цпу автоматом.
powersave гавернер хорош тем что он вне зависимрсти от нагрузки на цпу должен держать частоту 
равной scaling_min_freq (который мы можем в любой момент менять руками)
на драйвере acpi-freq этот гавернер так и рабоатет. а на драйвере intel_pstep этот гавернер
рабоатте как то непонятно.  при остуствии нагрузки частота держится повыше чем минимальная.
но не минималгая. а при нагрузке частта потихоньку начинает расти. 


еще прикол - если мы поменяли гавернер для одного ядра то автомтаом лтинукс меняем гавернер 
для всех ядер

performance гавернер должен держать частоту равной  scaling_max_freq вне зависимости от нагрузки нацпу.
scaling_max_freq тоже можно менять на лету руками.

ondemand - он при отстуствии нагрузки понимжает частоту до минимальной scaling_min_freq
а при возвраостании гарузки на цпу поываывашает ее до scaling_max_freq

гавернеры - можно менять налету. то есть  перкключать их можно с одного на другой в любое время




далее я опишу важный прикол. на одном ноутбуке на убунту 18 я юзаю драйвер intep_pstep
а надругом буке на убунту 22 я юзаю драйвер acpi-freq. 
почему? потмуо что я выяснил ужаснейший прикол. если мы комп суем в супенд
# systemctl suspend
а потом выходим из ждущего реима то (внимание)  частота на компе взлетает до максимума
и насрать на гавернер и на параметр scaling_max_freq. частота будет максимальная и похер на все.
я пробовать менять при этом гавернеры на разные. похеру. часатота держится максимлаьной.

мне удалось добавится чтобы система невыбывалась после выхода из суспенда только вот в таких кониугряциях
как пложено:

intel_pstate +  Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz + Ubuntu 18 + 5.10.0-051000-generic 
acpi-cpufreq +  Intel(R) Core(TM) i5-4210M CPU @ 2.60GHz + Ubuntu 22 + 6.2.0-32-generic


как узнать макс заводскую частотуу ядра.
# lscpu | grep "CPU max"
CPU max MHz:                        2601,0000

насколко я понимаю это число берется из 
# cat cpuinfo_max_freq
2601000

как можно оперативно отсолеживать частоту теукущую на цпу

# i7z
либо
# cat /proc/cpuinfo | grep "cpu MHz"
cpu MHz		: 798.086
cpu MHz		: 798.088
cpu MHz		: 798.088
cpu MHz		: 798.082


далее
еще цпу может переключаться в турбо режим. это кодга у нас на скжаем одном ядре частота повышается
сущесвтенно выше чем шаттная за счет того что остальные ядра при этом ненагуржены.
об еще будет ниже. эту фичу можно отключить.


соотвесвтенно чем ниже частота цпу тем ниже его температура


значит мы поняли что есть драйвер intel_pstate или acpi-freq и он упоаляет частотой.
мы выставляем гавернер. и драйвер уже дергает динамческий частоту ядра.

в целом этого уже достаотточно. 

еще такой момент как температутра цпу. посмтреть ее можно через # i7z либо # sensors
так вот чем меньше частота на цпу и чем меньше на цпу нагрузка тем меньше грееется цпу.

так вот все что  яописал выше оно за температурой неследит у цпу. да если цпу перегревается то внутри
самого цпу есть мехагизм защиты от перегрева. но еще раз - тот драйвер что я описал он не следит
за тспераератутрой цпу. он следит за нагрузкой на цпу и в зависиости от высатлвенного гавернера меняет частоту.

так вот есть еще программы которые сидят выше над всем этим которые следят за тепературой 
и если цпу перегревается то они чтото меняют. ну я так думаю что они могут менять - навернре
они меняют сам гавернер. и меняеют  scaling_min_freq  и scaling_max_freq
но это теория. что они меняют в случае напгрева я пока незнаю.

так одна из таких программ следящих за темереператорой это thermald.
скажу сразу програма полное дерьмо.  у нее менаубеический xml конфиг. который при этом
еще и не понятно что и как в нем менять. поэтому просто стираем эту праарашу и все.

# apt-get purge -y thermald


есть другая прогрмма аналогичная cpupower
работате она ии нет я не знаю потому что с ней есть другая проблема - чтобы ее поставить это мудежь.
показываю

]# cpupower
WARNING: cpupower not found for kernel 5.10.0-051000

  You may need to install the following packages for this specific kernel:
    linux-tools-5.10.0-051000-generic
    linux-cloud-tools-5.10.0-051000-generic


так вот у меня на убунту18 стоит "кастомное" ядро от самого canonical.
и к этому ядру нихрена нет пакетов 

 # linux-tools-5.10.0-051000-generic
 # linux-cloud-tools-5.10.0-051000-generic

поэтому я ее просто не могу поставить.

также прикол в том что по крайней мере так было раншье - что в убунте по дефолту стояло 
сразу несколько таких программ. то есть cpupower и  thermald одновременно. 
и они мешали друг другу.

ниже щас будет материал которйы частично повтоярет то что было уже описано выше.

меня порадовала возможность руками задать верхнюю часоту процессора налету

# echo 400000 | tee /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq

она установить что верхнаяя часотта для cpu0 может быть 400 MHZ
таким макаром надо пройти по всем ядрам.

далее они пишут что есть такая хрень как governor.
для каждого ядра его можно посмотреть тут 
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
powersave
powersave
powersave
powersave
powersave
powersave
powersave
powersave


вот тут можно посмотреть какие виды power governor доступны на данный момент 
для перкключения
# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors 
conservative ondemand userspace powersave performance schedutil

его можно изменить на лету. и тогда линукс будет динамически менять частоту на ядре. 
задать говернор можно налету вот так

# echo "powersave" | tee  /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor


виды гавернеров
- performance: это значит что ядро будет работать на макс штатной частоте все время.
максимальная частота берется отсюда 
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq
600000
600000
600000
600000

а вот так можно поменять макс частоту на которую цпу может переключаться 
# echo "800000" | tee  /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq
800000
# cat  /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq
800000
800000
800000
800000


- powersave:  это значит что ядро будет работать на мин часоте 
мин частота берется отсюда
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq
400000
400000
400000
400000
400000
400000

моя практика показал что с этим гавернером  хуйня
тоесть у меня на всех ядрах стоит гавнер= powersave
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
powersave
powersave
powersave
powersave
powersave
powersave
powersave
powersave

тоесть он должен все время держать частоту минимальной.
вот моя минимальная частота
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq
400000
400000
400000
400000
400000
400000

однако эта сука держит частоту в районе 600 MHZ


установка cpupower:
# sudo apt install linux-tools-$(uname -r) linux-cloud-tools-$(uname -r)


atop
он показыавает две вещи в плане cpu
 curf  400MHz | curscal  25%
 первое число  я даже не знаю откуда он берет. потому то 
 частота по факту плавает. а он все время покаызавает ровное число.
 curscal видимо это тоже самое число но впроцентном отношении к макс штатной частоте
 вобщем атоп как показатель ткущей часаоты так себе программа


есть графическаая прога которая покаызает темпреатуру процессаора в GIU это 

# apt-get install psensor

она берет цифры из lm-sensors проги

далее про C-states и P-states
я напоролся на статью небезызвестного мне швейцарца которы это расписсывает.
итак. мы хотим понизить мощность которую жрет цпу (а значит и его теспературу поппутно).
он пишет что мощность падает пропорционально частоте и по квадрату падения вольтажа.
понимажть мощность можно двумя путями. либо вырубать цпу целиком либо вырубать его подсистемы. и за 
это отвеачают C-states. а можно понижать часоту и вольтаж его подистем  этим занимаюстя P-states.
сама стстья - https://metebalci.com/blog/a-minimum-complete-tutorial-of-cpu-power-management-c-states-and-p-states/

C0 - означает банальано просто режим когда цпу херачить на полной сокрости. 
начиная с C1 уже идет реально остановка ядра.  С-состояния происхдоят только тогда когда цпу
нечего исполнять то есть во время idle промежутка времени. тогда просихдоит C-state. остановка
цпу. во время C-state команды на нем не исполняются. за исключением как я сказал режима C0 - это шататный режим кодга процессор херачит. чем больше цифра скажем C7 тем более глубойикий уровень  энергосбережения впдаает
в ядро цпу. в статье есть картинка. 

далее чуак упоминает что cpuid покажет какие C-states доступны в цпу

# apt-get install cpuid

      number of C0 sub C-states using MWAIT    = 0x0 (0)
      number of C1 sub C-states using MWAIT    = 0x2 (2)
      number of C2 sub C-states using MWAIT    = 0x1 (1)
      number of C3 sub C-states using MWAIT    = 0x2 (2)
      number of C4 sub C-states using MWAIT    = 0x4 (4)
      number of C5 sub C-states using MWAIT    = 0x1 (1)
      number of C6 sub C-states using MWAIT    = 0x1 (1)
      number of C7 sub C-states using MWAIT    = 0x1 (1)

как программически войти в c-state. для этого нужно в привигированном режиме запустить комнаду 
MWAIT.


тепер переходим к P-sattes.
читаю такую интерсную вещь
It is possible to use P-states in Intel Xeon E3–1200 v5 in either OS/Operating System controlled (Intel SpeedStep® Technology) or HW/Hardware controlled (Intel® Speed Shift Technology) mode. The information below about P-states is specific to Intel Xeon E3–1200 v5 Family, however, I guess it is same or similar for other modern processors.

если у нас  OS controller p-states то переход осуществлется так - мы пишем в регистр какой режим
хотим активировать. цпу вычисляет какой вольтаж гужен для этого п-стетйта . и цпу переходит в этот режим.

переходы между p-states просходят оченб быстро в отличие от C-states

далее я выясняил что с 4 версии линукса он поддеживает hWP (hardware p states) и что драйвер intel_pstate
как раз таки если он активировался то значит у нас  актививрованы hardware p-states.
также для того чтобы шарманка заработала нужен прцоессор i5. и надо чтобы в биосе эта фича
была актвивирована. она там должна называться "Intel Speed Shift" (не путать с "Intel speed step")

а вот как проверить в журнале линукса что HWP активиорван

# sudo journalctl -b | grep pstate
сен 17 23:19:04 lenovo kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.10.0-051000-generic root=UUID=aa7152b0-f48f-4f20-ad1a-7e0c404584d3 ro systemd.unified_cgroup_hierarchy intel_pstate=enable quiet splash vt.handoff=1

сен 17 23:19:04 lenovo kernel: Kernel command line: BOOT_IMAGE=/boot/vmlinuz-5.10.0-051000-generic root=UUID=aa7152b0-f48f-4f20-ad1a-7e0c404584d3 ro systemd.unified_cgroup_hierarchy intel_pstate=enable quiet splash vt.handoff=1

сен 17 23:19:04 lenovo kernel: intel_pstate: Intel P-state driver initializing

сен 17 23:19:04 lenovo kernel: intel_pstate: HWP enabled

получается "journalctl -b"  это полный аналог или некий аналог dmesg -T
показывает лог при загрузке


Starting with kernel 5.7, the intel_pstate driver selects passive mode aka intel_cpufreq for CPUs that do not support hardware-managed P-states (HWP), i.e. Intel Core i 5th gen. or older.


далее я напоролся на стаью от RedHat о частотах цпу и их управлением
	https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/tuning-cpu-frequency-to-optimize-energy-consumption_monitoring-and-managing-system-status-and-performance#doc-wrapper


вот как в этой стьте описывают C,P,T стейты:
	Sleep (C-states)
	Frequency and voltage (P-states)
	Heat output (T-states or thermal states)

еще раз скажу что переклчение через P стетйты идет очень быстро
а C стейты таковы что чем более энергосерегающий режим заюзан тем болльше времени 
нужно цпу чтобы из него выйти.

есть утилита turbostat которая инфо по цпу дает.
но там чтото очень много на экране она рисует. вагон информации.

далее много внимания прмиеняетя утиите cpupower

посмтреть доступные гавернеры
# cpupower frequency-info --governors
analyzing CPU 0:
  available cpufreq governors: performance powersave
 

далее перетирается утилита perf


 Performance counter stats for 'system wide':

        170895,68      msec cpu-clock                 #    7,999 CPUs utilized          
            20584      context-switches          #    0,120 K/sec                  
               130     cpu-migrations            #    0,001 K/sec                  
             1357      page-faults               #    0,008 K/sec                  
     1413179341        cycles                    #    0,008 GHz                    
       716176297       instructions              #    0,51  insn per cycle         
       144742230       branches                  #    0,847 M/sec                  
         7298401       branch-misses             #    5,04% of all branches        

      21,363827428 seconds time elapsed


это тот самый perf кооорым я обнаружил когда vmware жестко тормозил




возвращаемся к cpupower

# cpupower idle-info
CPUidle driver: intel_idle
CPUidle governor: menu
analyzing CPU 0:

Number of idle states: 9
Available idle states: POLL C1 C1E C3 C6 C7s C8 C9 C10
покажывает все C-стетйы доступные 


посмотреть гавернер , драйвер 
# cpupower frequency-info
analyzing CPU 0:
  driver: intel_pstate
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency:  Cannot determine or is not supported.
  hardware limits: 400 MHz - 1.60 GHz
  available cpufreq governors: performance powersave
  current policy: frequency should be within 400 MHz and 1.60 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: Unable to call hardware
  current CPU frequency: 628 MHz (asserted by call to kernel)
  boost state support:
    Supported: yes
    Active: yes


далее
позврлоляет задать чтобы комп работал на мин частоте
# cpupower set  --perf-bias 15
но пока непонял раотает ли оно реально

проврить применилось ли оно к процу
# cpupower -c all info -b
analyzing CPU 0:
perf-bias: 15
analyzing CPU 1:
perf-bias: 15
analyzing CPU 2:
perf-bias: 15
analyzing CPU 3:
perf-bias: 15
analyzing CPU 4:
perf-bias: 15
analyzing CPU 5:
perf-bias: 15
analyzing CPU 6:
perf-bias: 15
analyzing CPU 7:
perf-bias: 15


вот еще одна команда  смотреть статистику
# cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6  || C0   | Cx   | Freq || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,21|  1,03| 61,11|  0,00||  1,27| 98,73|  1010||  0,01|  1,51|  0,42|  0,22|  0,70|  0,00|  8,79|  0,11| 86,98
   4|  0,21|  1,02| 61,11|  0,00||  1,00| 99,00|   891||  0,00|  0,00|  0,00|  0,01|  0,60|  0,00|  9,89|  0,00| 88,51
   1|  0,08|  1,43| 61,11|  0,00||  2,25| 97,75|  1011||  0,00|  1,20|  0,07|  0,07|  0,38|  0,00|  7,08|  3,97| 84,97
   5|  0,08|  1,43| 61,11|  0,00||  0,89| 99,11|   996||  0,00|  0,12|  0,51|  0,04|  1,22|  0,00|  6,67|  0,00| 90,57
   2|  0,10|  0,67| 61,11|  0,00||  3,54| 96,46|  1165||  0,00|  0,00|  0,04|  0,05|  0,60|  0,00|  7,65|  0,00| 88,13
   6|  0,10|  0,67| 61,11|  0,00||  1,27| 98,73|  1318||  0,00|  0,00|  0,61|  0,08|  0,32|  0,00|  4,20|  0,00| 93,53
   3|  0,15|  0,91| 61,11|  0,00|| 11,93| 88,07|  1549||  0,00|  1,73|  0,04|  0,17|  1,05|  0,05|  6,86|  0,06| 78,09
   7|  0,15|  0,90| 61,11|  0,00||  0,72| 99,28|   986||  0,00|  1,68|  0,16|  0,01|  0,73|  0,00|  6,56|  0,00| 90,18


прикольно. типа подробная статиктика по CPU стеейтам

далее они пишут что эта команда вывела сразу инфо по нескольким "мониторам"
спмсок мониторов можно получить вот так

# cpupower monitor -l
Monitor "Nehalem" (4 states) - Might overflow after 922000000 s
C3	[C] -> Processor Core C3
C6	[C] -> Processor Core C6
PC3	[P] -> Processor Package C3
PC6	[P] -> Processor Package C6
Monitor "Mperf" (3 states) - Might overflow after 922000000 s
C0	[T] -> Processor Core not idle
Cx	[T] -> Processor Core in an idle state
Freq	[T] -> Average Frequency (including boost) in MHz
Monitor "Idle_Stats" (9 states) - Might overflow after 4294967295 s
POLL	[T] -> CPUIDLE CORE POLL IDLE
C1	[T] -> MWAIT 0x00
C1E	[T] -> MWAIT 0x01
C3	[T] -> MWAIT 0x10
C6	[T] -> MWAIT 0x20
C7s	[T] -> MWAIT 0x33
C8	[T] -> MWAIT 0x40
C9	[T] -> MWAIT 0x50
C10	[T] -> MWAIT 0x60


отсюда следует что доступны мониторы:
Nehalem
Mperf
Idle_Stats

тогда можно сделать вот так

# cpupower monitor -m Nehalem

    | Nehalem                   
 CPU| C3   | C6   | PC3  | PC6   
   0|  0,02|  0,32| 68,61|  0,00
   4|  0,02|  0,32| 68,61|  0,00
   1|  0,08|  0,98| 68,61|  0,00
   5|  0,08|  0,98| 68,61|  0,00
   2|  0,04|  0,85| 68,61|  0,00
   6|  0,04|  0,85| 68,61|  0,00
   3|  0,06|  0,34| 68,61|  0,00
   7|  0,06|  0,36| 68,61|  0,00

# cpupower monitor -m Mperf
    | Mperf              
 CPU| C0   | Cx   | Freq  
   0|  1,65| 98,35|   631
   4|  1,70| 98,30|   659
   1|  0,83| 99,17|   789
   5|  0,55| 99,45|   631
   2|  0,83| 99,17|   679
   6|  0,24| 99,76|   638
   3|  0,76| 99,24|   622
   7|  1,29| 98,71|   634

# cpupower monitor -m Idle_Stats
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  0,60|  0,00|  0,00|  0,08|  0,00|  6,61|  0,08| 88,60
   4|  0,00|  0,00|  0,02|  0,02|  0,71|  0,00|  6,99|  0,00| 87,42
   1|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,42|  0,15| 95,32
   5|  0,00|  1,18|  0,05|  0,03|  0,71|  0,00| 10,51|  0,00| 82,35
   2|  0,00|  0,00|  0,01|  0,06|  0,22|  0,00|  8,88|  0,00| 89,56
   6|  0,00|  1,60|  0,06|  0,01|  0,02|  0,00|  9,39|  0,00| 75,09
   3|  0,00|  0,37|  0,02|  0,04|  0,35|  0,00|  1,72|  0,00| 92,89
   7|  0,00|  0,00|  0,00|  0,00|  0,07|  0,00|  3,11|  0,00| 95,03



описание С стейтов

C0
In this state, the CPU is working and not idle at all.

C1, Halt
In this state, the processor is not executing any instructions 
but is typically not in a lower power state. The CPU can continue 
processing with practically no delay. All processors offering C-states 
need to support this state. Pentium 4 processors support an enhanced C1 
state called C1E that actually is a state for lower power consumption.

C2, Stop-Clock
In this state, the clock is frozen for this processor 
but it keeps the complete state for its registers and caches,
 so after starting the clock again it can immediately start processing again.
  This is an optional state.

C3, Sleep
In this state, the processor goes to sleep and does not need to 
keep its cache up to date. Due to this reason, 
waking up from this state needs considerably more time 
than from the C2 state. This is an optional state.

узнать какой драйвер активен
# cpupower frequency-info --driver
analyzing CPU 0:
  driver: intel_pstate


 доступные гавернеры
 # cpupower frequency-info --governor
analyzing CPU 0:
  available cpufreq governors: performance powersave

про powersave гавернер интересно написано
powersave
It forces the CPU to use the lowest possible clock frequency.
 This frequency is statically set and does not change.
  This governor offers maximum power savings, but at the cost of
   the lowest CPU performance. The term "powersave" can sometimes be 
   deceiving though, since in principle a slow CPU on full load
    consumes more power than a fast CPU that is not loaded.
     As such, while it may be advisable to set the CPU to use 
     the powersave governor during times of expected low activity,
      any unexpected high loads during that time can cause the system 
      to actually consume more power. The Powersave governor is more of
       a speed limiter for the CPU than a power saver. It is most useful 
       in systems and environments where overheating can be a problem.



# cpupower  frequency-info
по деолфту покзвыает инфо только про ядро номер ноль.
чтоы опсмореть инфо про все ядра нужно

# cpupower -c all frequency-info


как задать гавернер и верхнюю и нижнюю частоту между которыми будет скакать цпу
# cpupower frequency-set --governor powersave  -d 400MHz -u 1000MHz

проверяем что получислось

# cpupower frequency-info 
analyzing CPU 0:
  driver: intel_pstate
  ...
  current policy: frequency should be within 400 MHz and 1000 MHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: 686 MHz (asserted by call to kernel)
 
 я походу начинаю догонять почему powersave недержит часоту на уровне 400МГЦ.
 потому что было написано что цпу если работет на высокой часототе с меньшей нагрузкой
 жрет меньше чем на меньше частоте но с большей нагрузкой.


в итоге что касается cpupower то всего  две у него главные команды
		# cpupower frequency-set --governor powersave  -d 400MHz -u 1000MHz
		# cpupower set  --perf-bias 15



так вот конфиг pupower я ненашел  в убунте.
тогда я нашел как засунуть его запуск в systemd вот здесь 
		https://sleeplessbeastie.eu/2015/11/09/how-to-set-cpu-governor-at-boot/



# cat<<EOF > /etc/systemd/system/cpupower.service 
[Unit]
Description=CPU powersave
[Service]
Type=oneshot
ExecStart=/usr/bin/cpupower -c all frequency-set --governor powersave  -d 400MHz -u 1000MHz
[Install]
WantedBy=multi-user.target


# systemctl daemon-reload
# systemcl enable cpupower

тип сервиса oneshot тоесть он одноразово отрабатвает при загрузке



на счет вентилятора на цпу. на ноутбуке lenovo программа sensors (или sensors-detect) нихуя ненаходит
датчик вентилятора. поэтому он работает сука сам по себе. а работает он походу так - пока температура 
до 40 градосов не поднялась он не включается. 
по поводу как это настрвиается там где это сделано по человечески смотри тут  - https://wiki.archlinux.org/title/fan_speed_control



далее
тутже я опишу как сделат так чтобы выход из suspend не происходил из за нажатия мышки usb.
нашел тут - https://ubuntu-mate.community/t/how-to-disable-usb-wake-from-suspend/23163

# cat<<EOF> /etc/systemd/system/acpi-wake.service 
[Unit]
Description=ACPI Wake Service
Before=sleep.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c "for i in $(cat /proc/acpi/wakeup| grep enabled| awk '{print $1}'| xargs); do [ $i != PBTN ] && echo $i| tee /proc/acpi/wakeup; done"

[Install]
WantedBy=sleep.target
EOF

# ln -s /etc/systemd/system/acpi-wake.service  /etc/systemd/system/sleep.target.wants/acpi-wake.service
# systemctl daemon-reload

работает эта хрень так что она срабатывает ровно за мгновение до того как комп
впадет в suspend это как бы pre suspend.
он переводит все хрени в /proc/acpi/wakeup в disabled состояние. а хрени что там 
лежат они являются штуками которые могут выводит из suspend. мы их всех отключаем 
за исключением power button. 

проверяем
# systemctl suspend

я узнал что у thinkpad t440p он не может войти в suspend
он ругался что некое устроуство мешает перейти в suspend.
в  итоге оказалось что его тачпад этому мешает. мне тачпад нахер не встрался на нем.
я его просто нахер выкючил. для этого
		# cat /etc/modprobe.d/rmi.conf 
			blacklist rmi-smbus


далее. у меня на работал переход в suspend для thinkpad t440p если закрыть его крышку ( в  литературе она назыывается LID).
чтобы исправти эту хуйню надо сделат вот что :
1) надо поставить пакет 
		# apt install pm-utils

2) надо исправить файл
		# cat /etc/systemd/logind.conf | grep -v '#'
		[Login]
		HandleLidSwitchDocked=suspend
		HandleSuspendKey=suspend
		HandleLidSwitch=suspend
		HandleLidSwitchDocked=suspend

3) перезагрузить службу
		# systemctl restart systemd-logind

теперь можно протестировать закрываем крышку. по идее он наконец должен начать 
впадать в suspend

в целом я 
попроьвал разобратся с /proc/acpi/wakeup но как обычно это сложно плюнул и забил.


далее. 
как быстро выямнить какой гавернер у нас выставлен. чтобы не лазит руками в /sys
		# cpupower frequency-info



далее.
я узнал что есть утилита 
	# inxi
она предназначена чтобы лузры юзеры могли легко через эту утилиту собрать всю инфо о компе
чтобы отправить ее более умным калдырям.
вобщем inxi милая утилита
напрмиер
# inxi -C
CPU:       Quad core Intel Core i5-8265U (-MT-MCP-) cache: 6144 KB
           clock speeds: max: 1600 MHz 1: 840 MHz 2: 1070 MHz 3: 936 MHz 4: 1128 MHz 5: 1003 MHz 6: 1143 MHz
           7: 860 MHz 8: 856 MHz

# inxi -s
Sensors:   System Temperatures: cpu: 34.0C mobo: N/A
           Fan Speeds (in rpm): cpu: N/A


далее. 
как вручную сменить яркоть экрана а вот так
# echo "2100" >  /sys/class/backlight/intel_backlight/brightness


далее.
я выяснил что все LED индикаторы компа сидят в папке
/sys/class/leds
при этом на финкпаде папка которая отвечает за подсвекутп клавиатуры находистя в папке
/sys/class/leds/tpacpi::kbd_backlight

а чтобы включить подсветку надо сделать так
# echo  1 > /sys/class/leds/tpacpi::kbd_backlight/brightness

и тут я пришел к другой мысли - если прошелкивание всех подпапок в /sys/class/leds
не приводит к тому чтобы клава засветилась то значит в ней нет подсветки.
также на всех ideapad у котоых клава с подсветкой должны на кнопке "space" дллжны иметь значок
подсветки. если его нет то клава не имеет подстветки.   в инете я нашел что кокнертно на мой idepad
есть как я понял альтеранативные клавы в которых уже есть подсветка. и на их конпке "space" есть занчок
подсветки.  активируется подсвтетка через "Fn+Space" причем внезависимости от драйверов. тоесть
если оно есть то должно всегда активроваться через комбинацию этих клавищ.


на счет гавернеров что я выяснил из практики. плюс тут также надо уточнять на каком драйвере
работает гавернер. во первых гавернер это производная тоесть свтойство драйвера. тоесть именно драйвер
является поставщиком списока гавернеров. причем также важно что у разных драйверов гавернеры могут
иметь одинаковые имена но это не значит что они будут давать одинаковое поведение. 
у драйвера acpi-freq он создает целую кучу гавернеров
		# cat scaling_available_governors 
			conservative ondemand userspace powersave performance schedutil 
а драйвер intel_pstate у него всего два гавернера: performance и powersave
так вот powesave у acpi-freq работает по дргому чем у драйвера intepl_psstate.
powersave у драйвера acpi-freq реально все время держит частоту на уровне нижней заданной частоты
тоесть если мы задали 
	# cpupower frequency-set -g powersave -d 800MHz -u 1200MH
а потом запустили стресс тест 
	# stress --cpu 2  --vm-bytes 128M --timeout 30
то все это время частота будет держаться равной 800МГц.
а если у нас драйвер intel_pstate то фиг там. если мы у него задали гавернер powersave
	# cpupower frequency-set -g powersave -d 400MHz -u 1200MHz
то во первых даже в хоолостом состоянии частота будет находится на уровне 600МГц а не 400МГц
(может потому что у меня была запуещена гарфическая среда. а если ее потушить то будет в районе 400МГц).
но если запустить стресс тест то частота через какоето время уйдет в 1200МГЦ
потом когда тест закочнится то частота обратно вертся на уровне 600МГц. поэтому это да эт powersave
но совсем не такой как у дарйвера acpi-freq

минимальную частоту можно помимо cpupower также задать руками для кждого ядра через
/sys/..../scaling_min_freq
просто через cpupower это удобнее. а так пофакту он всего навсего за нас лезет в /sys и там меняет эти 
датчики.

также важно отметиь что драйвер intel_pstate он более хитрый чем драйвер acpi-freq потому что у него 
на /sys есть своя отдельная секция (своя отдельная папка)
		/sys/devices/system/cpu/intel_pstate
и в этой папке у него есть два счетчика 
		max_perf_pct
    min_perf_pct 


эти счетчики ограничивают макс частоту и мин частоту. 
при этом те счетчики ограичеия частоты которые я назвал выше которые лежат в другой папке и 
относятся к ядрам
		/sys/devices/system/cpu/cpufreq/policy*/scaling_max_freq
		/sys/devices/system/cpu/cpufreq/policy*/scaling_min_freq
они тоже есть. и тоже ограничвают верхнбб и нижню частоту
возникает вопрос . как они соотносятся? 
ответ такой что max_perf_pct и min_perf_pct  - они более главные. причем надо замеит что max_perf_pct и min_perf_pct они влияют сразу на все ядра одноврменно а счетчики scaling_max_freq и scaling_min_freq они 
у каждого ядра свои.  так вот max_perf_pct и min_perf_pct  - они более главные. и это значит что 
макс скорсть ядра не может быть больше чем  max_perf_pct , тоесть scaling_max_freq он может быть меньше чем
max_perf_pct. но никак не больше. аналогично для счетчиков для частоты снизу. тоесть 
работае вот такое правило
		scaling_max_freq <= max_perf_pct
если scaling_max_freq будет выставлен больше чем max_perf_pct то система это проионорирует
и все равно будет выставлять макс частоту на основе max_perf_pct

аналогично для
				scaling_min_freq >= min_perf_pct
тоесть scaling* неможет быть ниже чем min_perf_pct

также замечу что 
		/sys/devices/system/cpu/cpufreq/policy*/scaling_max_freq
		/sys/devices/system/cpu/cpufreq/policy*/scaling_min_freq
занчения в них указываются в мегагерцах
а в 
		max_perf_pct
    min_perf_pct 
занчения указываются в процентах. за 100%  берется так назыаемая макс часатота возожмная у ядра.
та которая может быть после применения турбо буста. для примера.
# lscpu
Model name:          Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz
CPU max MHz:         3900,0000
CPU min MHz:         400,0000

у него штатная частота это 1600NHZ
а турбочастота это 3900-4000MHZ.
так вот за 100% будет взято 4000 MHZ. и сооовсвтенно скажем 10% это 400МГЦ.
поэтому если мы выставим 
		max_perf_pct = 30
то это 30% от 4000МГЦ тоесть это 1200МГЦ
тоесть здес важно понимать что в max_perf_pct и min_perf_pct ставятся проценты и за 100%
берется не штатная частота 1600МГЦ как могло интуитвино показаться а турбо часатота 4000МГЦ.
также посмтреть какая штатная частаота а какая турбо у цпу можно через i7z

# i7z
  TURBO ENABLED on 4 Cores, Hyper Threading ON
  Max Frequency without considering Turbo 1898.94 MHz (99.94 x [19])
  Max TURBO Multiplier (if Enabled) with 1/2/3/4 Cores is  39x/38x/37x/37x
  Real Current Frequency 398.96 MHz [99.94 x 3.99] (Max of below)


таким макаром я на данный момент обьяснил то что: 
1) scaling_max_freq и scaling_min_freq = часатота ставится в мегагцерацах
	max_perf_pct и min_perf_pct = часатота ставится в процентрах.
	за 100% берется не шататная часатота ядра а его турбочасатота.
	узнать турбочастаоут можно либо через lscpu либо чеерз i7z
	либо на сайте интела по нвазванию цпу

2) max_perf_pct и min_perf_pct они превалируют над анаологичными счетчкиками scaling_max_freq и scaling_min_freq


3) что гавернеры это произовадная от драйвера. у каждого драйвера свой спмсок гавернеров.
и если даже навзение гавернера у додного дарйвера совпдает с навзанием у другого даррайврера
это незанчит что эти гавернеры работают одинакоово.


далее. у каждго цпу есть заводской нижний порог часатоты. мы неможем замедлить процессор
медленнее чем этот нижний порог. скажем у одного цпу это 400МГЦ у другого это 800МГЦ.
поэтому скажем если цпу имеет турбо часатоту 4000МГц и у него минимальная нижняя часатота с завода
это 400МГц то миимальной занчение котрорые мы можем выставит для min_perf_pct это 10.
тоесть 10% от 4000МГЦ это будет 400МГц. если мы будем пытаться его вытсватьи в 5% к примеру
то это ничего недаст. там будет стоять 10% по преженму.

теперь возвращаюсь к powersave гавернеру.
у обоих драйеров есть гавернер с таким названеием. 
повторю то что если мы выставили нижнюю часатоту равную минимальной возможно нижней часатоте
то если у нас гавернер powersave от драйвера acpi-freq то эта связка будет держать часатоту равной 
минимально выставленной во что бы то ни стало. а если у нас гавернер powersafe от драйвера intel_pstate
то там часатота будет плавать. я бы сказал что  powersave от intel_psatte работает в точности как 
гавернер ondemand от драйера acpi-freq. тоеть по возможности частаота держится визу но как только нагрузка
растет то она будет повышена. поэтому по факту даже на мин нагрузке powersave от intel_psatte будет 
держать часатоту всегда повыше чем наша мин часатота. скажем вы задаи мин часатот 400МГЦ а он будет
ее держатьв районе 600МГЦ.

покажу на примере "powersave+intel_pstate"
турбо частоат = 4000МГЦ
# cat min_perf_pct 
10  (тоетст это 400МГЦ)
# cat max_perf_pct 
30  (тоесть это 1200МГЦ)

# cpupower frequency-set -g powersave -d 400MHz -u 1200MHz

# cat scaling_min_freq 
400000
# cat scaling_max_freq 
1200000

# cat scaling_driver 
intel_pstate
# cat scaling_governor 
powersave

и вот какая в итоге например будет итоговая частота
# cat scaling_cur_freq 
618766

тоесть не 400МГЦ а 618МГЦ

прмиер с "pwowersave+acpi-freq"
# cat scaling_driver 
acpi-cpufreq
# cat scaling_governor 
powersave
# cat scaling_min_freq 
800000
# cat scaling_max_freq 
1200000

и в итоге факическая частота будет
# cat scaling_cur_freq 
798183

тоесть мы задали 800МГЦ он держит 798МГц

итак мы уяснили на какой часатоте будет держать комп гаверне powersave в случае
обоих драйверов. еще раз скажу что powersave от acpi-freq он реальнорабоатет как powersave
а powersave от intel_psate он рабоатет по факту как ondemadn от acpi-freq

но еще также интересно как себя ведет гавернер performance котоырй есть тоже у обоих 
драйверов. 
так вот там очень инересно. если перключится на этот гавернер то оба они детвуют одинакоово. 
они устанавливают на цпу турбо часатоту. и пытаютя ее макс удержать. поэтому пока позволяет 
температура на чипе то процессор  со штатной часатотой 1.6ГГц он будет работать на частаоте 4.0ГГц.
я это проерил на практике. ка только перелючаю на performance гавернер то часатота на ядрах сразу
влетает в космос в турбо частоту. это хороо видно в i7z

# cpupower frequency-set -g performance -d 400MHz -u 4000Mhz

на всякий случай проясню такой вопорос - как связь между гаверер и драйвер. гавернер это порожение
драйвера. без драйвера нет гавренера. спсок гавернеров и их повдеение определяется драйвером. дарйверов
два acpi-freq и intel_pstate

как ыбстро узнать какой драйвер щас , какой гавренер и какой диапазон частот задан
# cpupower frequency-info
  driver: intel_pstate
  current policy: frequency should be within 400 MHz and 1.20 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: 686 MHz (asserted by call to kernel)

еще пример на другом прцоессоре:
# cpupower frequency-info
  driver: acpi-cpufreq
  hardware limits: 800 MHz - 2.60 GHz
  current policy: frequency should be within 800 MHz and 1.20 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: 800 MHz (asserted by call to hardware)

для core-i5 комфортная температура ксати 40-60 градусов.


еще раз также покажу как нам сохранить настройки по гавернру и часатота.
для этого надо создать служба systemd


# cat<<EOF >/etc/systemd/system/cpupower.service 
[Unit]
Description=CPU powersave
[Service]
Type=oneshot
ExecStart=/usr/bin/cpupower -c all frequency-set --governor powersave  -d 400MHz -u 1000MHz
[Install]
WantedBy=multi-user.target
EOF



это все очень интеерсно.





$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$


ноутбук lenovo как у него настроить принудительно вентилятор ?

далее.
на счет насттройки вращения вентилятора. на thinkpad удалось настроить чтобы он вращался
тогда когда нужно. по деолфту в динуксе эта сука вобще не вращалась и цпу перегревался.
как это сделать 


вклбчить конвесрватиное сохранение батарейик бука
First make sure the ideapad_laptop kernel module is loaded, with the lsmod command.
If it is, run the following command as root to enable Battery Conservation Mode:
# echo 1 > /sys/bus/platform/drivers/ideapad_acpi/VPC2004:00/conservation_mode

описать как я успешно настроиил управление вентилятором на финкпаде!
отключаить wake по usb (/bin/sh -c "for i in $(cat /proc/acpi/wakeup|grep enabled|awk '{print $1}'|xargs); do [ $i != PBTN ] && echo $i|tee /proc/acpi/wakeup;done")
включить на финкпаде засыпание по закрыванию крышки!


еще одна утилита управлением питанием цпу
# x86_energy_perf_policy -r
cpu0: EPB 15
cpu0: HWP_REQ: min 4 max 10 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0
cpu0: HWP_CAP: low 1 eff 7 guar 16 high 39
...
покзавает профиль питания цпу. 
както отличается от гавернеров и intel_pstep

устновить новый профиль
# x86_energy_perf_policy  power

виды профилей
  normal  default Set a policy with a normal balance between performance and energy efficiency.  The processor will  tolerate  minor  performance  compromise  for
       potentially significant energy savings.  This is a reasonable default for most desktops and servers.  "default" is a synonym for "normal".

  performance Set a policy for maximum performance, accepting no performance sacrifice for the benefit of energy efficiency.

  balance-performance Set a policy with a high priority on performance, but allowing some performance loss to benefit energy efficiency.

  balance-power Set a policy where the performance and power are balanced.  This is the default.
  
  power Set a policy where the processor can accept a measurable performance impact to maximize energy efficiency.





что такое powetop ?
дальнейшее обсуждение:
https://unix.stackexchange.com/questions/87522/why-do-cpuinfo-cur-freq-and-proc-cpuinfo-report-different-numbers
https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.10/

tlp ?


https://wiki.archlinux.org/title/Hardware_video_acceleration


| laptop
| sn
| serial number

как узнать серийный номер ноутбука

# dmidecode



===
| tlp

дока - https://linrunner.de/tlp/usage/index.html

установка в уунту

# apt-get install tlp

проверка что tlp арботает
# tlp-stat -s
...
State          = enabled



===

| ip
| proc

как узнать ip на компе неимея команды ip 
используя только proc


# cat /proc/net/fib_trie

===
| apt-get update

вылвзииит ошибка

E: dpkg was interrupted, you must manually run 'sudo dpkg --configure -a' to correct the problem. 


решение
dpkg --configure -a


===

| terminal
| controlling terminal
| sigHUP

основной вопрос чем отличается sigterm от sighup
для этого надопонять в какой ситуации  у нас возникают эти сигналы.


навскидку sigerm это сигнал который шлет юзерский процесс другому процессу (через сисколл ествесттвенно) для того чтобы завершить тот другой процесс в штатном режиме. также
этот сигнал может послать и кусок ядра.

sighup шлется процессу когда ядро считает что  потеряна связь с его controlling terminal.
вначале я опишу все по простому. у нас в линуксе открыт терминал (черный экран) у него
в /dev есть соотсвстующий ему файл tty или pts.
узнать это можно вот так

$ tty
/dev/pts/68


далее мы в терминале  запускаем команду. эта команда будет в своих своствах 
иметь тот же самый терминал. этот терминал для нее назыается контрольным терминалом.
наскольк я понял в свойствах процесса может быть указан либо контрольный терминал
либо никакого терминала. терминала который бы был неконтрольным и был в своствах 
процесса такого терминала нет. итак в свойствах процесса либо есть терминал либо совсем
нет. если терминал есть то это контрглнеый термианал.

как узнать есть ли у прцоесса терминал контроьный или его нет и его номер

$ ps -p 579207
    PID TTY          TIME CMD
 579207 pts/66   00:00:00 sleep

команда ps когда покаызает свойства процесса то в столце "TTY" укаызает наличие 
контрольного терминала у процесса и его номер.


так вот самое главное - если мы черное окно терминала закроем то ( тут я точно незнаю)
то ли сам терминал пошлет все процессам которые были в его окне запущены сигнал SIGHUP
либо само ядро при уничтожении терминала пошлет все процессам SIGHUP сигнал.
таким оразрм в конечном итоге при закрытии окна терминала всем прцоессам которые были запущегны через окно этого терминала будет послан сигнал sighup. вот когда наступает
это событие. ну а дальше - sighup это сигнал который можно проигнорировать. поэтому 
если в процессе который был запузен в окне терминала стоит обработчик который может 
слать нахер этот сигнал то процесс будет продолжать работать. а если там нет кастомного
обработчика этого сигнала то  будет исползоваться дефолтовый ядерный обраблочткичик этого 
сигнала который будет уничтожать этот процесс. таким обоаом по дефолту  при поступлении
сигнала sighup в процесс этот процесс будет ядром уничтожен.

показают на примере.
открывают окно терминала. и в нем запускаю кучу башей

$ tty
/dev/pts/67

$ bash
$ bash
$ bash
$ bash
$ bash

$ ps aux | grep "pts/67"
vasya     579407  2.0  0.2  70532 45988 pts/67   Ss   05:15   0:00 bash
vasya     579421  1.1  0.2  70536 46040 pts/67   S    05:15   0:00 bash
vasya     579434  1.0  0.2  70536 46120 pts/67   S    05:15   0:00 bash
vasya     579447  1.3  0.2  70536 45852 pts/67   S    05:15   0:00 bash
vasya     579460  1.3  0.2  70536 45988 pts/67   S    05:15   0:00 bash
vasya     579480  1.3  0.2  70540 46032 pts/67   S    05:15   0:00 bash
vasya     579493  1.6  0.2  70540 46168 pts/67   S    05:15   0:00 bash

вот мы видим 7 процессов  укоторых контроный терминал pts/67

теперь  я закрывают окно терминала и по идее все эти бащ процессы будут уничтожены

$ ps aux | grep "pts/67"
пусто

значит все совпало. как только мы закрыли окно терминала pts/67
то все процессы у которых этот терминал был контршьным терминалом были уничтожены системой.
еще раз почему они были уничтжены - птому что к ним всем был направлен сигнал SIGHUP
и либо в баше стоит обрабочик который в ответ на этот сигнал просит ядро уничтожить
этот процесс либо был задействтвван дефолтовый ядерный обрабочик этого сигнала который
уничтожает этот проецесс.


нахуй этот SIGHUP нужен? а нужен он истоически вот для чего - это сейчас у нас терминал
это просто программа  с черным экраном раоботаюшая локально на нашем компе а раньше все было
иначе - раньше терминал это была  реальная железка с клавой и экраном и проводом serial к 
мейнфрейму. терминал не имеел ни памяти ни цпу он имел только клаву экран и  срведство связи 
с мейнфрейом на котором уже были цпу и память. так вот через терминал юзер запускал программы
на мейнфрейме. и если мейнфрейм считал что связь с терминалом потеряна то надо было уничтожить все те программмы которые были запущены  сэтого терминала. таким обоазом 
кажый процесс имел свойства с какого термиала он был запущен. и при падении связи между 
мейнфреймом и терминалом все эти проги дожны быть уничтожены. при падении связи с терминалом
какойто кусок ядра понимал что связт нет. и он слал все процессам принадлежащим этому терминалу сигнал SIGHUP. тогда шедулер когда доходил до таких процессов то он вместо того
чтобы их пихать на цпу их убивал. также как я понимаю когда человек заканчивать сессию
на терминале с мейфнфрейомм либо жал кнопку либо послыла команду на мейнфрейм о том что 
он заканиывает сессию что видим тоже слало сигнал SIGHUP. теперь я думаю все стало понятен 
смысл всей этой шарманки.

если мы запуакмаем из терминала пргармму и нехотим чтобы она была убита после того
как терминал буде закрыть то надо заюзать прогу nohup

пример

$ tty
/dev/pts/67
$ nohup sleep 200

$ ps aux | grep sleep
vasya     580035  0.0  0.0  14588   836 pts/67   S+   05:26   0:00 sleep 200

видим что наш процесс sleep 200 имеет в своих свойствах указанный коонтрьный терминал 
pts/67

закрыаем теперь окно терминала

проверяем была ли убита при этом программа

$ ps aux | grep sleep
vasya     580035  0.0  0.0  14588   836 ?        S    05:26   0:00 sleep 200

видим что небыла. прогармма продорлжает работать. а столбец который показыает 
номер контрщлного терминала для процесса стоит "?"


далее еще интереный момент - я всегда думал что если у процесса есть контрльный терминал
то это значит что в /proc/$PID/fd есть  файловые дескрипторы которые ведут 
в /dev/pts/67

однако оказалос что это не всегда так...
а именно
беерм запускаем процесс

$ sleep 600

$ ps aux | grep "sleep 600"
vasya     580496  0.0  0.0  14588   832 pts/73   S+   05:34   0:00 sleep 600

видим что у него контролный терминал это pts/73

идем в proc для этого процесса

$ ls -1al  /proc/580496/fd
total 0
dr-x------ 2 vasya vasya  0 июл 24 05:35 .
dr-xr-xr-x 9 vasya vasya  0 июл 24 05:35 ..
lrwx------ 1 vasya vasya 64 июл 24 05:36 0 -> /dev/pts/73
lrwx------ 1 vasya vasya 64 июл 24 05:36 1 -> /dev/pts/73
lrwx------ 1 vasya vasya 64 июл 24 05:36 2 -> /dev/pts/73

видим что да у процесса открыто три файла (0,1,2) все они ведут в терминал pts/73


а тепер посмтрим какая ситуация коггда мы запускаем комнду с nohup

$ nohup sleep 700
$ ps aux  |  grep "sleep 700"
vasya     580624  0.0  0.0  14588   832 pts/75   S+   05:37   0:00 sleep 700

видим что для процесса указано что у него в свойствах указан терминал pts/75
идем в proc и что мы там видим


$ ls -1al  /proc/580624/fd
total 0
dr-x------ 2 vasya vasya  0 июл 24 05:38 .
dr-xr-xr-x 9 vasya vasya  0 июл 24 05:38 ..
l-wx------ 1 vasya vasya 64 июл 24 05:38 0 -> /dev/null
l-wx------ 1 vasya vasya 64 июл 24 05:38 1 -> /home/vasya/nohup.out
l-wx------ 1 vasya vasya 64 июл 24 05:38 2 -> /home/vasya/nohup.out


мы видим что у нас открыто три файла (0,1,2) но ни один из них не ведет в терминал!!!

посморим что за файл nohup.out
$ stat /home/vasya/nohup.out 
  File: /home/vasya/nohup.out
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 24918099    Links: 1

видим что это "regular empty file"
тоесть это прям обычный файл физически лежащий на диске. 

таким образом я не очень понимаю связь этого процесса с терминалом.  дело в том 
что всегда утверждалось что если в свойствах прцоесса указано что у него есть
контрльный терминал то это мол всегда значит что процесс может читать с терминала (через его спец файл /dev/pts/75) либо писать на терминал

а тут мы видим что такой процесс не может ни читать с термиала ни писать на него 
потому что у него неоткрто устройство терминала.... да.. вот это непонятно...

===

| bench
| benchmark
| unixbench


из статьи на habr
 вылезла утилита для замера бенчмарка unixbench
есть только в виде снапов

# snap install unixbench

если у нас много ядер то надо запускать в много ядероом реижиме

# unixbench -c 4
где 4 это число ядер на компе об этом написано тут https://github.com/kdlucas/byte-unixbench/blob/master/UnixBench/USAGE

а тут написано что значит каждый тест https://github.com/kdlucas/byte-unixbench

в целом это бенчмарк связки цпу-память-ос

резульатты на лэптопе

------------------------------------------------------------------------
Benchmark Run: Fri Jul 28 2023 13:38:38 - 14:03:46
8 CPUs in system; running 4 parallel copies of tests

Dhrystone 2 using register variables       66298940.7 lps   (10.0 s, 7 samples)
Double-Precision Whetstone                    10849.2 MWIPS (9.8 s, 7 samples)
Execl Throughput                               6776.4 lps   (29.5 s, 2 samples)
File Copy 1024 bufsize 2000 maxblocks        707440.0 KBps  (30.0 s, 2 samples)
File Copy 256 bufsize 500 maxblocks          180685.6 KBps  (30.0 s, 2 samples)
File Copy 4096 bufsize 8000 maxblocks       1606002.7 KBps  (30.0 s, 2 samples)
Pipe Throughput                             2452775.6 lps   (10.0 s, 7 samples)
Pipe-based Context Switching                 212090.1 lps   (10.0 s, 7 samples)
Process Creation                              11992.4 lps   (30.0 s, 2 samples)
Shell Scripts (1 concurrent)                  18533.0 lpm   (60.0 s, 2 samples)
Shell Scripts (8 concurrent)                   2501.5 lpm   (60.0 s, 2 samples)
System Call Overhead                        2347375.8 lps   (10.0 s, 7 samples)

System Benchmarks Index Values               BASELINE       RESULT    INDEX
Dhrystone 2 using register variables         116700.0   66298940.7   5681.1
Double-Precision Whetstone                       55.0      10849.2   1972.6
Execl Throughput                                 43.0       6776.4   1575.9
File Copy 1024 bufsize 2000 maxblocks          3960.0     707440.0   1786.5
File Copy 256 bufsize 500 maxblocks            1655.0     180685.6   1091.8
File Copy 4096 bufsize 8000 maxblocks          5800.0    1606002.7   2769.0
Pipe Throughput                               12440.0    2452775.6   1971.7
Pipe-based Context Switching                   4000.0     212090.1    530.2
Process Creation                                126.0      11992.4    951.8
Shell Scripts (1 concurrent)                     42.4      18533.0   4371.0
Shell Scripts (8 concurrent)                      6.0       2501.5   4169.1
System Call Overhead                          15000.0    2347375.8   1564.9
                                                                   ========
System Benchmarks Index Score                                        1932.1

---------------

| grep 
пидец нахуй блядь.
вот что выяснил

вот у нас есть файл

$ cat 1.txt 
1
2
3


опция -C N покзаывает N строчек сверху и снизу от найденной строки . тоест

$ grep -C1 "2" 1.txt
1
2
3

так вот пиздец в том что можно убрать "C" и оставти толко "-1"
пример

$ grep -1 "2" 1.txt
1
2
3

ниге ни в man нни в info я об этом ненашел. суки блядь ебаные.

дале ключи -r и -R в чем разница. вроде как в том что -r неследует симлинкам а -R следует.

таким оюоразом

# grep -r2 "vasya"  = grep -r -C 2 "vasya"


====

| passwd
| shadow
| пароли


про пароли в линуксе.
пароли хрантся в /etc/shadow
запись имеет несколько полей. поля разделяются двоеточиями ":"
описание полей  смотри в man shadow 

пример записи для юзера vasya2

$ sudo cat /etc/shadow |  grep vasya2:

я разделил поля с двоеточиями доп пробелами

vasya2 : $6$BbSw9Q10$L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh. : 19430 : 0 : 99999 : 7 :::

так вот второе поле это пароль. пароль сохранен в виде хэша.

$6$BbSw9Q10$L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh.

хотя не совсем. в форме хэша. пароль тоже имеет несколкьо полей внутри себя.
поля внутри пароля разделяются через знак доллара "$"
я добавил доп пробелы чтобы показать поля внутри пароля

$ 6 $ BbSw9Q10 $ L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh.



как я понял первое поле  в данном случае "6" показыает тип хэша 
виды хэшей. виды хэшей можно посмтреть через 

$ man openssl-passwd

там видим

  -crypt
           Use the crypt algorithm (default).


  -1  Use the MD5 based BSD password algorithm 1.

  -apr1
           Use the apr1 algorithm (Apache variant of the BSD algorithm).

  -aixmd5
           Use the AIX MD5 algorithm (AIX variant of the BSD algorithm).

  -5
  -6  Use the SHA256 / SHA512 based algorithms defined by Ulrich Drepper.  See <https://www.akkadia.org/drepper/SHA-crypt.txt>.



итак -6 это SHA512

как я понял никак нельзя указать линуксу какой иенно хэш алгоритм юзать. 
он всегда юзает -6 при запист пароля в /etc/shadow


но это еще не все. второе поле это так называемый "salt"
в данном случае он равен "BbSw9Q10"
итак в чем собсвтенно дело. вот мы придумали пароль выбрали хэш  и в итоге у
нас в /etc/shadow записан логин, тип хэша, и хэш.
так вот прикол в том что юзеры часто юзают короткие и повторяющиеся пароли. поэтому 
скажем ктото стырил на shadow далее он взял все возможные пароли длинной скажем 10 символов
и для всех них вычисли хэши и ему остается только сравнить свою таблицу предпогтолыенных хешей
с нашим shadow. и пароль будет вычислен скажем так. ттгда и был придуман "salt". 
salt это любой набор символов (байтов). так вот мы берем пароль прибавляем к нему salt 
и уже от этого набора симвлов(байтов) вычисляем хэш. это дает то что взломщик паролей
теперь должен взять этот salt и для этого salt сгенерерировать заново таблицу хэшей.
как я понимаю генерация таблиц хэшей (rainbow таблицы) это затратаня операция. 
итак у нас получается что тот же самый пароль но сразными salt будет в итоге выдывать 
разные хэши. поэтому под каждый salt взломщик должен генерировать таблицу хэшей
индиивидуально. а это затрудняет взлом. 

вопрос а как же сам линукс сверяет наш пароль с тем что в shadow. 
как я уже сказал второе поле содержит salt причем в окрытом виде. 

тоесть 
6 = это тип  хэша
BbSw9Q10 = это наш salt записанный в открытом виде
L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh. = 
а это уже наш хэш который был вычилен путем обьединения нашего пароля и salt

гениально. возникает вопрос а откуда взялся salt ведь мы при генерации проля в линуксе
никакой salt неуказыаем. ответ - как я понимаю линукс сам автоматом генерирует salt.
вобщем то удобно. 


проверим теорию с практикой. изменим пароло для vasya2 на "temp"

# passwd vasya2

получаем

vasya2:$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0:19568:0:99999:7:::

мы имеем для пароля
$ 6 $ CWvpCyfP $ owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0

значит алгоритм хэширование 6 тоесть SHA512
salt = CWvpCyfP
пароль мызнаем "temp"

сгеннеирериуем руками теперт хэш учитывася все эти данные и проверим получим 
ли мы такой эе хэш как в shadow


$ openssl passwd -6 -salt CWvpCyfP temp
$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0


сравниваем с тем что в shadow
$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0

полное совпдание! теория совпала с праткикой!

кстати прикол что комагда выглядит как 
$ openssl passwd
а ман у нее выглядит как
$ man openssl-passwd 

вобще меня на тему shadow навеля это супер статья https://tbhaxor.com/linux-file-permissions/

сравним как выглядит хэш для разных алгоритмов хэша

$ openssl  passwd -crypt temp
lEMHJ3vYIIqsE

$ openssl  passwd -crypt  temp
nKMXOc5hv9SPQ

$ openssl  passwd -crypt  temp
/AWbmhJcae/bk

$ openssl  passwd -crypt  temp
ktB79OAgyDRv6

$ openssl  passwd -crypt  temp
wO46gShM1T1cI

видно что пароль один и тотже  а хэш разный. видимо он в себя включает 
и salt котоырй автоматом генерируется


$ openssl  passwd -1 temp
$1$UktQ/3s9$a/n2XHoslh.6hwApLdvtV0

$ openssl  passwd -apr1  temp
$apr1$yefESuP3$.W8joK2N12pRHrwHQULKN/

$ openssl  passwd -aixmd5  temp
whIbFfIj$Taivy0xyFOh9ps8Z2dKab.

видно что все три алогритма юзают автосгененирровынный salt (второй столбик с раздели
телем $)


$ openssl  passwd -5  temp
$5$doWL/NwAisNd2cwS$Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3

$ openssl  passwd -6  temp
$6$QEe4qtY9ShP6jVnR$RIzSSyJx0VvrAVjK/6fj.co5fFnapX50ZVaJXNr75Ah0GNWO.rmSr5j76xEuAEQHc6OaQPTSuSEgSFOUKlHY31

в последнем сслучае salt=QEe4qtY9ShP6jVnR
сегенерируем хэш тип 6 

$ openssl  passwd -6 -salt QEe4qtY9ShP6jVnR temp
$6$QEe4qtY9ShP6jVnR$RIzSSyJx0VvrAVjK/6fj.co5fFnapX50ZVaJXNr75Ah0GNWO.rmSr5j76xEuAEQHc6OaQPTSuSEgSFOUKlHY31

видно что совпало. мы верно определили salt

===
| filebeat 


проверить что конфиг верный
#filebeat test config

но это тоьлко провека что гланый конфиг верный flebeat.yml
а то что у тебя в модулях верно все (/etc/filbeat/modules.d) которые тоже конфиги эта сука так
не проверяет. чтобы проверить что и в модулях все окей надо останвоить filebeat 

# systemctl stop filebeat
и

# sudo filebeat -e -c /etc/filebeat/filebeat.yml

если он не напишет что 
Exiting: Failed to start crawler: creating module reloader failed: could not create module registry for filesets: error unpacking module config :error creating config from fileset nginx/access: error unpacking configuration

pзначит чвсе окей. 
иначе у тебя ориибка в конфиге модуля 




проверить что ест связь с эластиком
# filebeat test output
elasticsearch: http://10.113.151.1:5080/api/default/...
  parse url... OK
  connection...
    parse host... OK
    dns lookup... OK
    addresses: 10.113.151.1
    dial up... OK
  TLS... WARN secure connection disabled
  talk to server... OK
  version: 8.9.0


запускаем айлбит

# systemctl start filebeat
и нао чуть подождить. он падает не сразу
проверяем

# jouralctl -f -u filebeat



дефолтовый частоат  с которой он проверяет файлы логов это 10с.
настраивается через scan_frequency



прописать  путь к модуля иначе их не актививровать
# cat filebeat.yml

filebeat.config.modules:
  path: ${path.config}/modules.d/*.yml

  reload.enabled: false


после этго можно активовть модуль

# filebeat modules enable  elasticsearch



как выгддяит как пример конфиг модуля nginx

.d# cat /etc/filebeat/modules.d/nginx.yml 
- module: nginx
  access:
    enabled: true
    var.paths:     
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/access.log"
        - "/home/magento/magento2-sandbox.magestage.net/log/access.log"


  error:
    enabled: true
    var.paths:  
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/error.log"
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/error.log"


  ingress_controller:
    enabled: false
    #var.paths:


 важно отметть      что  как я пути прописал. 
 это очен удобно. только надо кавычки ставить чтобы не было ошибоок!
 





===


| SUID
| SGID

во первых в целом про классические file permisons в линуксе (далее просто пермишнс).
для каждого файла этот пермишнс по длинее составляет 3бита*4=12бит
в каждой тройке быты отвеча за разрешение на чтеиние+запись+исполнение=rwx
одна тройка откчает за пермишнсы для владельца обьекта, вторая зя пермишнсы
для группы владельца обьекта и третья тройка битов оотвечате за преминсы для всех остальных
кто полезет к обьекту. четверткая тройка битов имеет особые значения - один бит
отвечает за SUID признак, второй за SGID признак и третий бит за признак "sticky бит".

начнем с SUID бита. что это такое . за что он отвечает что дает.
соглаасно wiki SUID пеерводится как SetUID. забегая вперед скажу что 
сейчас мы говорим про некие атрибуты файла. а далее мы будем говорить о атрибутах запущеного
процесса и у неготоже есть атрибут SUID но он переводится совершенно по другому тоест
это совершенно другой обьект и переводится он как SavedUID но сокращенно выглядит точно
также SUID. итак возвращаемся к файлу , что такое SetUID флаг.
этот бит он как бы устанавливает UID.
что такое UID куда он его устанавливает  и с чем это все едят. Если у файла установлен
бит x скажем для владеьца файла то такой файл разршено "исполнять" . пускай это ELF файл
по своему типу. так вот мы в командной строке указываем путь к файлу и баш вызовет сисколл
который загрузит тело файла в оперативку и передаст на исполнение код этого файла. так вот
у нас возникнет родится новый процесс в системе.  и для этого процесса ядро создаст 
три атрибута UID(EUID), RUID, SUID.

RUID - это id юзера который запустил этот процесс. 
UID или EUID (что одно и тоже) - это id юзера который показывает что этот процессу 
можно делать какими полномочиями этот процесс обладает. именно UID/EUID используется
ядром для сравнения чего хочет сделать процесс с тем что ему позволено делать.

тут надо сказать то что в самом простом случае когда у нас линукс создал процесс по нашму
запросу из файла то у этого процесса RUID=UID\EUID то есть процесс в баше запустил вася
и процесс обладает прававми васи. все красиво логично и просто. более того внезавимости 
от того кто владелец файла процесс будет иметь тот UID который юзер запустил этот файл.
тоесть скажем файл /bin/ex1 его владелец root.root  и сидит вася в баше и тыкает 
этот файл и процесс будет создан с UID=vasya а не с UID=root . потому что вобще то действительно есть фундаментальный вопрос - если мы создаем процесс из файла то какой
UID должен иметь этот процесс? и логичный ответ UID должен быть того юзера который
этот файл запускает. чтобы непривилигорованный юзер мог создаваь только непривилигированные
процессы. тоесть обратим внимание на очень интересуную вещь у нас есть обьект файл и у нас
есть обьект процесс. в целом это две разные несвязанные сущности. у процесса есть UID 
этот UID обозначает какие действия может делать этот процесс в системе.  UID у процесса как бы выражает владельца этого процесса.
у файла тоже есть  владалец у которого есть UID. и этот UID для файла регулирует кто с этим
файлом может менять его содержимое. а теперь фундаментальный вопрос  вася тыкает на файл
у которого владелец петя - тогда какой UID надо присобачивать для процесса который сделан
на основе этого файла?ну и как я уже сказал при создании процесса на основе файла 
плевать кто владелец файла какой UID у владельца файла - новый процесс будет иметь UID 
ттого юзера который тыкнул на этот файл. поэтому нам обычно плевать кто создал файл
и кто его владелец ибо это влияет только на то кто может редактировать тело файла на диске
и UID процесса обычно зависит совсем от друогого - кто запустил файл. итак есть UID у файла
который регулирует кто может редактировать тело файла.  и есть UID у процесса который
обозначает полномочия этого процесса тоесть что этот процесс может или неможет делать 
в системе.  файл похож на рецепт торта. а процесс похож на повара который готовит этот торт.
так вот рецепт мог написать один и только ему разрешено менять этот рецепт. а готовить 
по рецепту может уже другой еинственное что еще вопрос разрешит ли системе готовить
этому другому этот торт в данном конкретном случае.  итак у нас есть вася который 
имеет UID=123 и он запустил файл и создался процесс и обычно по деолфту ядро создат процесс
с 

UID/EUID=123
RUID=123
SUID=123

RUID - показывает кто создавал процесс. кто тыкнул на файл
UID\EUID- показывает что этому процессу разрешено делать. именно с этим полем ядро всегда
сравнивает что процесс хочет делать с тем что ему разрешено.
SUID- это некое предыдущее значение UID. об этом позже.


спрашивается нахера иметь три сущности UID\RUID\SUID. почему не завсети одну.
ответ такой что когда процесс работает то он с помощью сисколлов может менять эти атрибуты.
например процесс может поменять UID налету. скажем схема такая. сидит root и он 
запустил процесс через файл. процсс запустился он имеет UID=0 и этот процесс имеет
типа неограниченные права. он выполянет какието привилигированные операции а дальше
ему уже ненужно иметь такие мощные права и тогда процесс взывает сисколл и просит у ядра
изменить UID на какйото котоый имеет уже минимальные права скажем UID=100500
и тогда ядро меняет UID у процесса и с точки зранеия безопаснтсти это очень хорошо
потому что и сам процесс если код криовй неможет ничего сломать ни какойнибудь взломщик
который както влез в этот процесс неможет через него чтото поломать в системе. 
так вот перехожу к SUID что если мы в работющем процессе через сисколл сменили UID то
преыдудщее значение UID будет засунуто забэкаплено в SUID. зачем так делают об этом ниже
но кратно затем что в ряде случаев ядро позволит процессу еще раз поменять UID но не на произвольный а только на тот кооторый в SUID. но об этом ниже. возгкает вопрос а какой 
SUID на стадии когда мы только запустили процесс ведь никаокго предыдущего занчение в UID еще не было. ответ такой что на старте прцоессе SUID=UID.
также вопрос а можно ли сменить RUID - ведь по идее он ранит инфо кто запутил процесс.
если мы сменим RUID то как бы теряется смысла этого поля. пока что навскидку я вижу что 
RUID все время остается один и тот же но это не точно это надо проверять. там ниже я покажу
как эти атрибуты менятся на лету.

переходим к SUID биту атрибуту у файла. переводится SetUID. (не путать с SUID атрибутом
процесса. suid файла и suid процесса это разные хрени и относятся они к разным обьектам в том числе). так вот SUID файла он не имеет отношения к разграничению прав кто и что может делать
с телом файла. этот атрибут показывает что если файл запустил петя а владельцем файла
укзаан root то процесс должен быть создан с UID=root. таикм образом если у файла выставлен
SUID атрибут то при создании процесса уже играет роялт не кто этт файл тыкнул а кто его 
владелец. 

@@@@ закончил тут

простой юзери будучи вдаледбецем файла неможет сменить его владельца. но может менять
chmod. и может добавить SUID бит. в баше файлы с SUID битом подсвечиваются красным.
если бы юзер мог менять влаеднца на рут. то он мог бы записать в файл любой вредный код.
потом снметьи воадедьца на root. потом преилеить SUID бит и заустит этот код от рута.
кто может выставлять SUID бит?
на скрипты этот бит нерабтает. кроме bash -p ?
прикол sudo touch > 1.txt создаст файл с владельцем vasya! а не root
и только sudo bash && touch 2.txt создаст файл с владельцем root. это прикол
что еще я воде выяснмил из практики. если на файле стоит  даже 777 то менять 
его атрибуты может толкьо владелец. (может еще ктото из группы - проверял). но не лбой
юзер. даже если стоит 777. тоесть премишнсы к файлу опсывают что можно делать внути
файла с его телом. но не с его атрибутами внешними. также прикольно то что вот у нас
есть на папку влаледец вася. он в папке может делать что хочет. в этой папке root
создает файл с влаледльцем root и 777. вася неможет менять пермишнсы на файле. 
но он может его удалить из этой папки. потому что право удалить файл прописывается не 
в пермишнсах файла а в пермищнсах папки в которйо лежит файл. 
таким оюрахлм на самом деел файл как бы имеет три сферы разнымх перминсов:
- кто может мождицифицировать тело файла
- кто может удалять файла
- кто может модициифровать атрибуты его тела 
это разные пермищнсы они просываются в разных местах. и это тоже прикол.
также перминс о том кто может запускать этот файл (x) пропсиыватся в пермишнсах тела файла.










shared librru suid  = гнихуя не дает
suid н файл - в процессах все равно сказано что запустл вася
SGID на папку дает что фалы будет создваны с группой папки алвдедькца
а SUID на папку нихуя не даст

suid на pipg - нахйуй?
suid на симлинк что дает ?

rwsrw-r-x – SUID bit set and the binary is executable
rwSrw-r-x – SUID bit set and the binary is not executable


When you run a SUID bit enabled file, it is being executed with the user-id current user but with an effective id of the owner of that file.
это реьный прикол. файл будео в прцоессах запущен от васи но по факту он буедт 
работать по рутом. это пздц.

The SUID bit is ignored in most of the Unix/Linux so it will not affect the files you create in the directory. But when you set the SGID bit on the directory and then create a file inside it, the group of the new files will be the same as the group of directories.

$ chmod g+s,o+rwx mydir
$ stat -c "%A %n" mydir
drwxr-srwx mydir

при смене владедьца файла через chown SUID бит автоматом сбратсывается\убирается.
и его надо заново активировать!

rwSrw-r-x = вот это означает что SUID усановлен но x бит не устанволен
а 
rwsrw-r-x = это ознаает что и x и suid биты устаовлены


bash скрипы и вообще все файлы кооыер исполнятся интрепреторрами на них suid бит
недействуеи . почему? вот статяь https://unix.stackexchange.com/questions/364/allow-setuid-on-shell-scripts



lsof показывает параметры заущенных процесоов. он берет это из proc.
поэтому можно идти в proc и там все увидеть либо смоетреть через lsof
lsof это некий фронтед визуализатор для /proc/$PID папки



$  sudo lsof -p  32145   2>/dev/null
COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
ping    32145 vasya  cwd    DIR  259,2     4096 24909215 /home/vasya
ping    32145 vasya  rtd    DIR  259,2     4096        2 /
ping    32145 vasya  txt    REG  259,2    64424 25690241 /bin/ping
ping    32145 vasya  mem    REG  259,2 10281936 23337573 /usr/lib/locale/locale-archive
ping    32145 vasya  mem    REG  259,2   144976 13250066 /lib/x86_64-linux-gnu/libpthread-2.27.so
ping    32145 vasya  mem    REG  259,2    14560 13250054 /lib/x86_64-linux-gnu/libdl-2.27.so
ping    32145 vasya  mem    REG  259,2  2030928 13250051 /lib/x86_64-linux-gnu/libc-2.27.so
ping    32145 vasya  mem    REG  259,2    97072 13250067 /lib/x86_64-linux-gnu/libresolv-2.27.so
ping    32145 vasya  mem    REG  259,2   219304 23339395 /usr/lib/x86_64-linux-gnu/libnettle.so.6.5
ping    32145 vasya  mem    REG  259,2   206872 13243527 /lib/x86_64-linux-gnu/libidn.so.11.6.16
ping    32145 vasya  mem    REG  259,2    22768 13243485 /lib/x86_64-linux-gnu/libcap.so.2.25
ping    32145 vasya  mem    REG  259,2    26616 23343542 /usr/lib/x86_64-linux-gnu/libgtk3-nocsd.so.0
ping    32145 vasya  mem    REG  259,2   179152 13245746 /lib/x86_64-linux-gnu/ld-2.27.so
ping    32145 vasya    0u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    1u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    2u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    3u   raw             0t0  1576046 00000000:0001->00000000:0000 st=07
ping    32145 vasya    4u  raw6             0t0  1576048 00000000000000000000000000000000:003A->00000000000000000000000000000000:0000 st=07



$ sudo ls -1al /proc/32145/fd
total 0
dr-x------ 2 root  root   0 июл 30 18:19 .
dr-xr-xr-x 9 vasya vasya  0 июл 30 18:18 ..
lrwx------ 1 root  root  64 июл 30 18:19 0 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 1 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 2 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 3 -> 'socket:[1576046]'
lrwx------ 1 root  root  64 июл 30 18:19 4 -> 'socket:[1576048]'


видно что пинг процесс имеет открытыми два файла которые сокеты. 

тепрь понятна фраза что пинг открыает два raw сокета. по факту это озрнчает что
он делает сисколлыы которые ему открывают два файла которые на бекенде ведут в ядро в сокеты.
и видимо этот сисколл может делать только процесс от рута.

что странно - без SUID  пинг пошлет нахер
$ stat ./ping
  File: ./ping
  Size: 64424     	Blocks: 128        IO Block: 4096   regular file
Device: 10302h/66306d	Inode: 10095974    Links: 1
Access: (0755/-rwxr-xr-x)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-07-30 17:57:55.329820506 +0600
Modify: 2023-07-30 17:53:59.694022907 +0600
Change: 2023-07-30 17:57:41.981829605 +0600
 Birth: -
[vasya@lenovo #7]$ ./ping -c 3 8.8.8.8
ping: socket: Operation not permitted

если же запускаем ping с SUID
$ stat /bin/ping
  File: /bin/ping
  Size: 64424     	Blocks: 128        IO Block: 4096   regular file
Device: 10302h/66306d	Inode: 25690241    Links: 1
Access: (4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)

то видно что ни uid ни euid абсолютно не равны root !!!!
$ ps -p 12226  -o pid,uid,euid,cmd
  PID   UID  EUID CMD
12226  1000  1000 ping 8.8.8.8

и это я понять не могу.!
может этот пинг он стартует. открыает сокет. потом содает форк непривлигированный а 
потом сам себя киляет ??

я запустил ручную  c программу и она в итоге ее процесс имеет UID=65534 (nobody)
как это происходит на уровне сисколлов непонятно птому что при запуске ее
через strace она запускается под васей. 


systemtap - но под нее надо там мудить чтобы она заработалал



ruid = тот кто запустил
uid=euid= какие права у процесса
suid = хранит предыдущий uid

вот эта стаьья = https://www.osso.nl/blog/setuid-seteuid-uid-euid/

и поэтому наступила разгадка насчет пинга. я четко установил вот что :
если у нас у файла владелец "UID=vasya, GID=pupkin"и у файла установлен бит SUID
то 100% процесс будет запущен так что  ps покажет что UID=vasya (вне зависимости от 
того какой юзер из своей консоли нажал на этот файл) тоест например

сидит у на петя в своей консоли 

(petya) $ ./file

то процесс в ps буде виден как 

UID      COMMAND
vasya    ./file


соотвесвтенно если файло владеет root  и запускает его petya то ps покажет что 

UID    COMMAND
root   ./file


теперь я возвращаюсь к конкретному примеру программа ping
у нее владелец root и  SUID установлен .
это значит что если простой юзер запускает команду ping то она вобще то 
должна в ps быть показано что ее UID=root 
однако этого не происходит. потому что как я полагаю что тут уже другой момент.
когда пинг запустился то он реально работает а UID=root
под ним он открыает сокеты. а потом уже ему ненадо иметь такие права
и он сам запускает сисколл наример setuid и понижает права до простого юзера. 
вот и разгадка. именно поэтому мы видим в ps что пинг работает под простым юзером а не root.
вот она разгадка!!

что еще примечательно из второстепенного что поле UID в ps это не юзер который запустил
программу! нет! это показаны эффективные права процесса. тоесть UID это тоже самое что EUID.
а поле которое показыает кто запустил команду это RUID
а есть еще поле SUID. и в ps это совсем не бит SUID. нет. это показан так называемый
saved uid - предыдущее значение uid в случае если процесс в ходе своей работы через сисколлы
постоянно меняет uid. 

это дает еще доп интересный вывод что вот мы смотрим ps -p $PID
и видим некоторый UID. так вот так как процесс может его менять то соверешенно не факт 
что этот же самый процесс чере 10 минут покажет тот же самый UID в ps


| samba
| smb

отлчная стаять я как быстро настроить samba сервер.
чтобы потом можно быо к нему под виндой зайти

https://linuxize.com/post/how-to-install-and-configure-samba-on-ubuntu-18-04/






| nmap
| scan

как быстро найти все хосты в сети LAN

$ nmap -sn 192.168.0.0/24

===





