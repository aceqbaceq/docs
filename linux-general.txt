linux
общее

--
ubuntu 20 
сука в два раза жирнее по диску чем ubuntu16
гораздо мнеее отзывчивый тяжелый

стал как и весь другой софт сразу занчительно неповоротливый тяжелый.
нахуй он такой нужен
тяжело натужно грузится
миллион служб. все как с другим софтом чем дальше тем хуевей
убунту 16 просто ракета по сравению

что нужно допилить напильиником в ubuntu 20:

	иодитский netplan 
	как его удалить - https://disnetern.ru/disable-netplan-ubuntu/
	причем netplan я удалидл. ifupdown пакет поставил но при этом
	настройки про dns из /etc/networkj/interfaces нихера не подсатыватся.
	в итоге нужно еще поставить # apt install resolvconf
	тогда настройки dns надо прорисывать в /etc/resolv.conf про dns
	как и когда то одавно!
		# cat resolv.conf
		nameserver 172.16.101.2
		nameserver 172.16.101.7
		domain mk.local
		search mk.local

	нужно пояс часовой сделать москва
	 sudo timedatectl set-timezone Europe/Moscow

	удалит floppy из системы.
	$ sudo rmmod floppy
				$ echo "blacklist floppy" | sudo tee /etc/modprobe.d/blacklist-floppy.conf
				$ sudo dpkg-reconfigure initramfs-tools
				
	
--


делаем чтобы можно было к нектиться к ФС

ceph auth get-or-create client.cephfs mon 'allow r' osd 'allow rwx pool=cephfs_metadata,allow rwx pool=cephfs_data' -o /etc/ceph/client.cephfs.keyring

ceph-authtool -p -n client.cephfs /etc/ceph/client.cephfs.keyring > /etc/ceph/client.cephfs

--

iperf

задача сделать тест скорости сети 
из между офисами.

далем на основе iperf

ставим на обоих компах iperf3
нужен именно он

# sudo apt-get install iperf3

стандартный iprf работает так, один конец запускаем в
виде сервера

(a)# iperf -p 49001 -s

-p 490001 = это порт на который сервер принимает запросы.
надо на файрволле открыть этот порт для входящих

второй конец работает клиентом

(b)# iperf -c 123.12.12.12 -p 49001 -R -i 5

-c 123.12.12.12 = адрес сервера
-i 5 = через сколько секунд выводить статистику на экран

еще можно указать ключ -t 10 = это значит что тест будет идти 10 секунд
если -t вобще неуказывать то тест будет идти бесконечно что удобно

самый главный ключ это -R и он есть только в iperf3
он дает то что клиент будет скачивать данные с сервера.
потому что по дефолту клиент подклчается к серверу и начинает UPLOAD 
данных на сервер. 
поэтому если мы хотим чтобы клиент DOWNLOAD данные с сервера нужен ключ -R

---

LINUX REMAP KEYS

купил мелкую клаву.
а на ней эти уроды убрали insert 
pgup pgdown end

как сделат ьтак чтобы жмешь наодну конопку а унее функция другой кнлопки


редактикрую файл

/usr/share/X11/xkb/keycodes/evdev

а если пром еще хочется узнать какой код у какой кнопки то 
хзапусти прогу xev

=============
ssh

known_hosts

что в этом файле на компе клиента.

когда мы конектимся к серверу 
то он нам присылыает свой публичный ключ.
так вот в known_hosts наш хост сохраняет хэш от этого публичного ключа + IP\hostname от этого сервера.
зачем мы это делаем = чтобы в следущий раз если мы стучим на этот сервер то заранее знать какой нам публичеый 
ключ ожидать. потому что злолдей может заглущить ориганлный сервер поставить себе его ip 
создать свой приватный \пубичный ключ  и совать их нам выдавая себя за оригинаьный сервер.

строчка в этом файле прдставляет собой вначале идет hostname\ip смотря что мы вбивали в команде ssh
причем оно указано не в открытом виде а виде тоже хэша. а потом идет хэш от публичного ключа того сервера

поскульку это хэши то дешифровать никак нельзя.

зато можно провнрить есть и в known_hosts запись о том или ином хосте.

$ ssh-keygen -F mail.ru

еще можно удлаить строчку из known_hosts

$ ssh-keygen -R mail.ru

если удалить весь файл то ничго страшного.
просто при стучании на серверы начнет выскакивать надпись дескать 
удаденный хост имеет такой то хэш пуличного ключа мол вы согласный что удалеенный хост это удаленный хост
вот и все последствия

=============
tty

про эту тему tty можно писать много и долго.
про эту тему уже разбросано несолько кусков по моей документации. 
я позже их соберу. а щас рассмотрим такую тему. вот если нажать ps aux

то в выводе идет список процессов и у каких то процессов указан знак вопроса "?"  в столбце tty а 
у каких то указано tty1 или tty7 или pts/0. pts небудем трогать пока считаем что это некая разновидость tty. так вот что же это значит что процесс имеет некий tty или не имеет его. на что
это вляет как это понять почуствовать. в чем разница и все такое.

если процесс в выводе ps имеет в свойствах tty это значит что у данного процесса в свойствах 
открытых файлов имеется устройство tty. пример

смотрим на ps для процесса 1180

$ ps aux | grep -E "TTY|1180"
USER       PID %CPU %MEM    VSZ   RSS   TTY      STAT   START   TIME   COMMAND
root      1180  0.6  0.5 1227504 89308  tty7     Rsl+   апр18   116:29  /usr/lib/xorg/Xorg

видим что ps показывает для 1180 что tty7

смотрим какие файловые дескрипторы открыты для процесса 1180 на proc
$ sudo ls -1al /proc/1180/fd/ | grep tty
lrwx------ 1 root root 64 мая  1 01:10 12 -> /dev/tty7

и видим что среди файловых дескрипторов есть /dev/tty7

файловый дескриптор это поток обмена информации между процессом и внешним миром. в него 
можно читать и писать. в данном случае у процесса поток номер 12 имеет 
бекендом  устройство /dev/tty7 тоесть у процесса есть канал обмена информацией между процессом
и устройством /dev/tty7 

таким образом если в ps мы видим что процесс имеет в своих свойствах tty устройство 
это значит что у процесса открыт канал связи с tty устройством.

что такое tty устройство - для начала  /dev/ устройства в целом что это такое. есть реальное физическое устройство железка. данные от железки поступают в ядро. а /dev/ устройства это кранчик
который торчит из ядра который позволяет программе из user space получит данные от железного устройства из ядра через этот кранчик /dev/ файла.  какая железка является бекендом для /dev/ttyX 
файла. в одном случае это COM порт. тоесть запись в /dev/ttyX файл пишет в COM порт и чтение из 
/dev/ttyX файла это принятие данных из COM порта.  
таким образом если у процесса есть файловый дескриптор который ведет в /dev/tty устройство это значит данный процесс может писать в COM порт или читать данные из COM порта.
цепочка тогда выглядтит так:

процесс -> файлоый дескриптор -> /dev/tty устройство -> ядро -> COM порт

и наоборот.

тоесть если у процесса есть tty устройство это значит что у процесса открыт канал связи с внешним миром через COM порт в обе стороны. тоесть с точки зрения процесса у него открыт файл на чтение 
и запись. бекендом данного файла явяляется tty файл бекендом которого является COM железка.

далее. чуть сложнее. раньше клавы и мониторы были вынесены за системный блок. то есть схема 
выглядела так. системный блок у него COM порт. в него идет провод от коробки под названием 
терминал. терминал это коробка у которой есть клава и экран вот сигнал от клавы на терминале 
поступал в системный блок через COM порт получается через /dev/tty файл. и также от системного блока
инфо которая была предназначена для вывода на экран она летела в /dev/tty файл от процесса в системном блоке потом в ядро и в COM порт оттуа по проводу в терминал а он(терминал) поступившую инфо  преобразовавл и выводил буквы на экран терминала.  таким образом COM порт это был порт 
через который инфо от клавы и монитора попадала в системный блок в обе стороны.
таким образом COM порт это был порт через который в процесс могл прилетать инфо от клавы и 
и от процесса инфо могла попадать на экран монитора. тоесть COM порт и tty устройство это устройство
через которое через который процесс имеет связь с живым юзером.

далее прикол в том что в ядро линукс встроен виртуальный терминал выглядит это так. процесс 
открывает файл /dev/ttyX устройство и начинает туда писать. данные летят в ядро. ядро направляет поток в драйвер виртуального терминала и он направляет его на экран монитора. и про клаву. поток из клавы летит в ядро. ядро направляет поток в драйвер вирт терминала. он обрабатывает поток и шлет
поток в /dev/tty файл и процесс чеерз этот файл получает поток от клавы внутрь себя. таким образом
если у процесса открыт на чтение запись файл /dev/tty{1..7} то это значит что даные с клавы летят в данный процесс и данные от процесса выводятся на экран.

таким образом отвечаем на изначальный вопрос в чем разница между процессом у которого открыт 
поток чтения записи в tty устройство от процесса у которого такого потока неоткрыто.
разница в том что процесс у которого отркыт поток обмена данным с tty устройством дает 
возможность чтобы инфо с клавы компа летели внутрь процесса и поток вывода от процесса в tty 
приводит к тому что инфо поступает на экран компа. таким образом tty поток дает воможность 
взаимодействовать процессу с живым юзером через экран и клаву.

во времена терминалов за каждый ttyX  портом скрвыался на том конце терминал со своей клавой 
и своим экраном. тоесть если было семь tty1-tty7 портов то это значит что было на том конце
семь терминалов, семь клавиатур и семь мониторов. поэтому если процесс 1 имел открытым tty1 то 
инфо с клавы 1 летело в процесс1 а если процесс2 имел открытым tty2 то инфо с клавы2 летело в процесс2. а какая же ситуация сейчас когда у нас на компе есть tty1-tty7 но при этом клава 
физически у компа одна. как же ядро понимает в какой tty посылать поток идущий с клавы.
я понимаю что дело выгляди так - вот мы тыкнули Ctrl-Alt-F1 значит ядро понимает 
что на данный момент мы "активировали" первый виртуальный терминал в ядре.значит поток букв от клавы
надо посылать в /dev/tty1 и значит тот процесс который читает с этого устройтва и будет получать
поток букв с клавы.  теперь про экран. пусть у нас семь процессов и каждый из них открыл свой tty
тоесть

pid 1 -> tty1
pid 2 -> tty2
...
pid 7 -> tty7

далее каждый из этих процессов постоянно чтото шлет записывает в свой tty. 
возникает вопрос какой из этих потоков выводить на экран. думаю что рабтает также.
что поток сохраняется в некий буфер в памяти ядра. для каждого tty свой буфер. далее
мы жмем Ctrl-Alt-F1 и ядро понимает что мы активировали первый виртальный терминал. 
тода ядро выводит на физический экран вывод из буфера памяти от tty1 устройства.
далее мы тыкаем Ctrl-Alt-F5 и ядро понимает что мы перключились на пятй виртуальный терминал
и ядро выводми на экран вывод из буфера памяти который хранит накопленный поток от tty5.
это была логика когда у нас линукс работает в текстовом init 3 режиме.
когда у нас графический режим то вместо tty используются pts устройства. и вместо Ctral-Alt-Fx
комбинаий исполщуется то что мы мышкой активируем то или иное окно.

таким образом есл вернтся в текстовый режим то полчается что ядро линукса оно биндит
виртальные терминалы(монитор и клава) в физическую клаву и физический монитор.

итак еще о чем нам говорит если у процесса  в списке открытых файлов есть tty устройство.
это нам говорит о том что данный проецесс подразумевает может контактировать с живым юзером
через клаву и монитор. через клаву процесс может получать от юзера нажатие кнопок а через монитор процесс может выводить инфо. если у процесса нет открытых tty файлов то работа данного процесса
не подразумевает контакт с живым юзером. с клавы он инфо принимать неможет и на экран выводиь 
инфо он тоже неможет. назовем это так : есть юзер интерактивные процессы и неинтерактивные.

вопрос а что если несколько процессов одновременно имеют откртытым один и тот же tty файл например tty2.
вот мы жмем кнопки на клаве в какой процесс летит поток от клавы. ответ такой что от того что 
процессом открыт файл еще незначит что он из него постоянно читает. 
если они оба постоянно пытаются из него читать то будет идти конкурентная борьба и часть букв 
будет попадать в один процесс а часть в другой. 

а что если они оба активно пишут в tty2. значит на экране будет идти смесь то одного процесса то 
от другого. тоесть. скажем первый шлет "aaaaaaaaaaaa" а второй шлет "bbbbbbbbbb"
на экране юзер буездет видеть чтото типа того "ababbbaabbabababbaab" тоесть будет тоже идти
конкуретная борьба.

но как я уже скаал от тооо что два процесса имеют открытым один tty2 это незначит что они оба
из него сейчас активно читают или пишут. пример откроем терминал в граф оболочке. и введем команду
$ tty
она покажет к какому устройству вирт терминала прикреплен данный виртуальный терминал.

$ tty
/dev/pts/21

pts это упрошенно говоря тоже некий аналог вирт терминала.

теперь вот что запустим

$ ps aux | grep 'pts/21'
vasya    15543  0.1  0.0  34112  5448 pts/21   Ss   02:53   0:00 bash
vasya    15557  0.0  0.0  48852  3772 pts/21   R+   02:54   0:00 ps aux


тут видно что два процесса имеют открытым один и тот же файл вирт терминала pts/21
но между ними конфликта нет. мы имели запущенный bash и в нем мы запустили команду ps aux
и баш что сделал. он породил новый процесс ps aux и при этом процесс bash 15543 ушел в состояние 
interruptible sleep. конечно статус в ps не является прям точной инфо потому что процесс может 
чтото делать по быстрому и потом уходить в состояние sleep тоесть это незначит что процесс прям
все время в этом состяонии. он был в том состоянии только на момент вывода ps. одномоментно.
но с высокой долей вероятности можно полагачть что 
  хотя bash 15543 и имеет открытым pts устройство но он из него ничего нечитает и в него 
ничего не выводит. поэтому на момент выполнения ps aux вывод на pts\21 был подчинен только 
процессу ps aux. поэтом конфликат никакого нет. поэтому нет никакой чехарды с потоком от клавы
 и потоком на монитор. но в целом его легко устроить если запустить какойто цикл который чтот выводит экран. а потом открыть другой терминал и начать слать мусор в /dev/pts/21 и тогда на экране
 первого терминала будет идти смешение вывода от цикла и от нашего ручного мусорного потока.


а вот интеренсый вопрос что происходит когда в bash мы запускаем команду  в
background режиме ( это такая фишка баша). например

$  (while true; do sleep 10; echo "111"; done)&

при этом будем наблдюдать интересуную картину с одной стороны мы имеем доступ
к консоли но в ней периодически будет появляться "111"

получаеся по факту у нас два процесса у которых один pts/22 и наш первый процесс он периодически
шлет в pts/22 инфо и она выскакивает на окне терминала. в тоже время мы тоже сидя за клавой
может чтото писать на терминале. тоесть мы имеем два процесса которые одновременно вывоводят в 
один терминал. насколько я понимаю что просиходит при запуске в баш команды в бекграунд режиме 
то форкается процесс в нем запускается команда но исходный баш процесс не помещается в режим sleep
а продолжает свою работу. 

 а вот еще пример

 $  ( while true; do     sleep 10; read var1; done )&

 тут получается что процесс должен считать с клавы. так вот у нас получится что есть 
 два процесса с одним pts и оба процесса в какойто момент времени будут читать с клавы
 так вот незнаю как но баш делает так что если бекграундный процесс лезет читать в то время как 
 исходный баш процесс читает ведь с клавы так вот бекграуден процесс тут же будет остановлен 
 башем.  с точки зрения статуса данный процесс будет переведен в статус "T" когда он попытается
 счиатть с клавы наряду с исходным баш процессом.


====
каналы 1 ,2 

по поводу пернаправления вывода

find / 2>/dev/null

что там происходит по капотом в этом случае. что за загадочные цифра 2.
на самом деле все просто. создаетя процесс который обслуживает find
и у него есть файловые дескприоры 

/proc/$$/fd/{0,1,2}

так вот мы башу закаываем чтобы он когда будет создавать процесс под команду find
чтобы он дескпритор 2 перенарпавил (тоесть что у него будет бекендом ) не на экран ( тоесть не на /dev/pts/17) а в /dev/null вот и все

$ sudo ls -1al /proc/20920/fd
lrwx------ 1 root root 64 мая 17 23:42 0 -> /dev/pts/32
l-wx------ 1 root root 64 мая 17 23:42 1 -> 'pipe:[1662807]'
l-wx------ 1 root root 64 мая 17 23:42 2 -> /dev/null


вот четко видно что 

2 -> /dev/null

что файловый дескриптор 2 ( в который процесс кидает поток с инфо о ошибках) совать в /dev/null

вот как работает под капотом вся эта хрень с перенапраавлением ввода вывода!















===
processes 'R' 'D' status
+ kernel mode

It is not 100% beatifull answer but it can give you a flavour. If you have some process that constantly in 'R' state - you can start to monitor two fields from procfs:

$ awk '{print $14, $15}' /proc/$$/stat 
you will see something like: 0 3915

The first number shows 'Amount of time that this process has been scheduled in user mode, measured in clock ticks' , the second one shows 'Amount of time that this process has been scheduled in kernel mode, measured in clock ticks'. (please have a look at man proc for the details).

However the point is if 3915 is growing fast and 0 is not growing it means the process is running under kernel mode right now. The more fast 3915 is growing the more we can be sure that the process is running under kerhel mode.

an example:

$ sudo dd if=/dev/nvme0n1p2 of=/dev/null bs=30M count=1000

    $ top

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                   
16691 root      20   0   45352  32712   2112 R  50,5  0,2   0:06.00 dd

  
$ awk '{print $14, $15}' /proc/16691/stat 
0 467

$ awk '{print $14, $15}' /proc/16691/stat 
0 512

$ awk '{print $14, $15}' /proc/16691/stat 
0 557

$ awk '{print $14, $15}' /proc/16691/stat 
0 594

$ awk '{print $14, $15}' /proc/16691/stat 
0 630

$ awk '{print $14, $15}' /proc/16691/stat 
0 666

$ awk '{print $14, $15}' /proc/16691/stat 
0 699
So we can say - yes, the process is running under kernel mode.

As for 'D' state:

As for 'D' state (correct me if i'm wrong) - it means the process in a "sleep" state. It is 'uninterruptible sleep' state anyway it is a sleep state , it means the code of the process (user space) or invoked kernel code via syscall IS NOT scheduled on cpu until some necessary data\structure is available. So i suppose the processes in 'D' state should be excluded from the review. Why? Because they just not executed on cpu at all. However there is a subtle moment. The process can switch between 'D' and 'R' states quickly so we can think the process is in 'D' state however it goes from time to time to 'R' state.

Let me give explanation in details: Very often people say that if a process in 'D' state it means it waits some I\O. It is not necessarily so.

Simple program in C.

$ cat 30.c
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {

    pid_t pid = vfork();

    if (pid == 0) {
    sleep(180);
    return 0;
    }

      printf("parent: I am exiting\n");

     return(0);
}
Compile.

$ gcc -o 30.exe 30.c
Launch.

$ ./30.exe
It uses vfork that creates a child process. The parent process will be blocked until child exits. Also the state of parent process will be 'D'.

$ ps  aux | grep 30.exe
vasya     6495  0.0  0.0  10700   964 pts/66   D+   03:30   0:00 ./30.exe
vasya     6496  0.0  0.0  10700   964 pts/66   S+   03:30   0:00 ./30.exe
So the parent doesnt do any i\o operations but have 'D' status.

Next - Lets have a look if process with 'D' uses cpu. So lets check if it really sleepls.

$ while true; do cat /proc/6495/stat | awk '{print $3, $14, $15}'; done
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
As we can see it is.

Next. Very often we can see a process is in 'D' state however "top" shows it consumes CPU. How is it possible? The quick answer - the process switches between 'D' and 'R' states. It can happen very quickly. Remember "top" reads all the information from procfs. By default "top" refreshes all the data every 3 seconds so if the process switched very often to 'D' state and not so often to 'R' state it will seem to us as the process lives all the time in 'D' state. However it is false assumption.

The next important point is that the state of the process is a property of instant moment. That is when we are talking about the process has "D" state we mean it is in this state at this particular time. However when we are talking about CPU consumption - it is not about property of instant moment of time. It is average value FOR SOME PERIOD OF TIME. Pls have a look at the picture:

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND
13416 vasya     20   0   24024   5308   2132 D  62,9  0,0   0:05.02    dd  

                                                                                                                  
We see that the state = 'D' %CPU = 62,9

It means that at the moment (right now) the state = 'D' It means right now process does not consume cpu cycles , however some time before the process was NOT in 'D' state and it was consuming cpu cycles. So for the simplicity "top" calculates the average for the last three seconds. It can be like so:

Now - 0%
1 sec ago - 62,9%
2 sec ago - 62,9%
3 sec ago - 62,9%

the average = (62,9%+62,9%+62,9%+0%)/(1+1+1) = 62,9%
So thats why "top" shows 62.9% of cpu usage in spite of the state of the process is 'D'.

To proof that 'dd' switches between 'D' and 'R' states:

$ while true; do cat /proc/13416/stat | awk '{print $3, $14, $15}'; done
R 0 745
R 0 745
D 0 746
D 0 746
D 0 746
D 0 746
D 0 746
D 0 746
R 0 746
R 0 746
R 0 746
R 0 747
R 0 747
R 0 747
R 0 748
D 0 748
D 0 748
D 0 748
D 0 748
R 0 748
R 0 748
R 0 749
D 0 749
R 0 749
R 0 749
D 0 750
D 0 750
D 0 750
D 0 750
D 0 750
D 0 750
R 0 750
R 0 751
R 0 751
R 0 752
R 0 752
R 0 752
D 0 752
D 0 752
D 0 752
D 0 752
D 0 752
R 0 753
R 0 753
D 0 753
D 0 753
D 0 753
D 0 753
R 0 754
R 0 754
R 0 755
R 0 755
D 0 756
D 0 756
About the meaning of $14 and %15 fields: As for "man proc":

$14 = Amount of time that this process has been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
$15 = Amount of time that this process has been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).

As you can see "dd" switches between 'R' and 'D' states. Thats why average cpu consumption is not 0%.

Also you can see that while the process really in 'D' state it does not consume cpu cycles neither for user mode nor for kernel mode.

As the final suggestion: if you have a process and want to know if it is running right now in user or kernel space --> start monitoring

$ cat /proc/13416/stat | awk '{print $3, $14, $15}';
If $14 is changing - it means the process in user space, if %15 is changing - it means the process is in kernel space

Hope it helps

Еще добавок про S и D состояния процесса.
Если у процесса состояние S то это означает две вещи: 
1. код программы (непосредственный код программы) шедулером больше неразмещается на цпу. Он физически больше непопадает на цпу.тоесть код процесса реально больше непопдает и неисполняется на цпу. а если процесс сделал сисколл тоесть вошел в ринг0 и код ядра. то тоже самое. и ядерный код неразмещен шедулером на цпу. таким образом ни юзерский
код процесса ни вызыванный код ядра через сисколл - ничего из этого на данный момент неразмещено на цпу. ( на данный
момент потому что статус это характеристика типа instant тоесть вот оно как прям щас)  

2. Плюс статус S означает что процесс принимает сигналы. таким образом например работу
процесса можно прервать прям щас.
что значит процесс принимает сигналы.значит что ядру разрешено
в таблицу процессов данному процессу записать свойство сигнал. а шедулеру разрешено тут же взять 
и запустить обработчик этого сигнала. тоесть по факту это нето что там код процесса чтото решает принимать ему или нет. это один кусок кода ядра разрешает другому куску кода ядра сделать 
изменнеие в таблице процессов для данного процесса. а шедулер увидев что в свойствах процесса
появилось своства сигнал запустити обрабочик сигнала. сам процеесс ничего нерешает.

Сразу скажу про статус 'D' он такой же самый только нет пункта два. тоесть 
нельзя процессу доставлять сигналы. запрещено. таким образом пока процесс имеет статус 'D' никак неповлиять на него через сигналы. (кроме ребута). Когда процесс выйдет из статуса 'D' то сигналы что ему слали (они сохраняются) будут ему наконец "доставлены".


далее. вверху я уже написал  на английском  но еще раз скажу:
если у процесса статус S или D то согласно пункту один код процесса шедулером неразмещается
на цпу и также если проецесс сисколл вызывал то его код тоже неразмещается на цпу. дело в том 
что да если процесс вызывал сисколл то как это работает в паре с шедулером? отображается ли 
работа ядерного кода в статусе процесса или нет. ответ да. когда вызывано ядро через сисколл 
то условно гооворя запускается функция просто она физически размещается не в коде программы
а в отдельных других файлах в которых код ядра (условно говоря либо в вбиблиотеке libc либо в ядре vmlinuz) так вот что там происходит. а ничего особого. цпу перекчается в ринг0. да там немного 
меняютсяс пара регистров , условно говоря ссылка на стек меняется но в целом ядерный код начинает
работать в окружении регистров и вирт памяти которая осталась от процесса. да ядерный код помимо 
вирт памяти процесса также может лазить в память ядра но в целом как пишут книжки ядерный код
работает в окружении процесса. и вот далее важно. один момент это то что вот на цпу работает ядерный код. далее происходит таймер интеррапт и цпу прерывает работу этого ядерного кода 
без проблем ему похер ядерный код или юзерский. далее появляется шедулер. и он как то понимает 
что этот ядерный код он относится к процессу и он во первых выдавливает этот код с цпу, сохраняет
все что нужно в свойствах процесса гдето в памяти причем ссылка на команду идет именно на 
ядернй код там где была остановка из за интерапта и шедулер обновляет статистику толтко что заюзанного  тайм слайса со стороны ядерного кода в статистику работы именно процесса.
так что мы имеем два момента , один это то что цпу когда ядерный код выполняет то его можно прервать
и второе что шедулер то время которое ядерный код работал по вызыву процесса зачисляет в статистику
самого процесса в procfs так что мы четко можем быть уверены что время работы ядерного кода на цпу
будет отражено именно в статиске процесса а значит мы увидим в top работу ядерного кода для процесса
в статистике процесса в плане cpu usage. иначе получалась дурацкая ситуация ядерный код по запросу
нашего процесса работает но мы невидим эту статистику в свойствах процесса и думали бы что процесс
прохлаждается . неважно в рамках нашего процесса код из нашей программы крутится на цпу и внешняя функция из ядра - по факту это все ресурсы запользованные нашим процессом так что статистика
должны отражаться в свойствах процесса. потмоу что было непонятно вот заустил процесс сисколл 
цпу перешел в режим ядра и где искать сколько cpu usage сейчас жрет этот сисколл. оказывается 
искать ненадо. его cpu usage засунут в свойства процесса как бутто это щас код из процесса 
и крутится на цпу. получается если мы в top видим что у процесса есть какйото cpu usage то 
мы неможем навскидку сказать это время когда цпу работал в юзер моде или в кернел моде 
потому что там указана их сумма. ( конечно надо понимать что в рамках процесса цпу в каждый момент времени работает либо в юзер моде либо в кернел моде но неодновременно).

также еще ращ скажу важно понимать что характеристика статус процесса типа "S"\"R"\"D"
это характиристика в конкретной точке времени. тоесть скажем прям щас. 
втоже время cpu usage в рамках команды top (потому что в procfs там нет этого параметра в чистом виде) это характеристика не про момент времени а за некоторый пропмежуток времени средняя величина.
Поэтому если мы видим что статус процесса S\D но в тоже время его cpu usage неравен нулю тут 
нет никакого противоречия потому что S\D статус относится к тому как это щас у процесса а его
cpu usage относится к промежутку времени между три секунды назад и щас. (три секунды это дефолтовое
время усреднения со стороны top). тоесть это значит что в моменты времени до нашего текущего
у процесса было переключение на статус R (это 100% и процесс жрал цпу. жрал это значт что он занимал кванты времени находясь на цпу своим кодом). вот поэтому и нет противорречия. да если щас статус S то прям щас процесс использует цпу на 0%. но еще раз top непоказывает на сколько % процесс
исполует цпу прям щас . потому что на самом деле нет такой характеристики на сколько % процесс занимает цпу прям щас. потому что прям щас процесс либо выполняется на цпу тоесть он его занял
либо он невыполняется. но процентов никаких нет в этом плане в природе. процент получается исходя
из совершенно другого если унас есть три промеждутка времени. ( это то как это работает со стороны шедулера) и скажем в первый промежуток у нас код находился на цпу на втором он ненаходился и на третьем он анаходидся то это значит что с точки зрения времени сколько процесс находился на цпу это будет 100%*(1+0+1)/3 =67% тоесть показатель cpu usage это показатель сколько времени процесс находился за заданный проемежуток времени на цпу ане то что прям сейчас цпу работат на 67% своей мощности. у цпу нет никакой мощности он либо работает щас на 100% либо нет. просто кажому процессу
дается небольшой квант времени. и cpu usage это отношение сколько таких квантов процесс находился на
цпу к общему числу квантов времени. поэтому никакого парадокса в top нет. вот как в этом примере

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND
 2185 vasya     20   0 3181856 282088  50380 S  25,9  1,7   377:25.95 cinnamon 

статус S это то как щас а 25.9%CPU это в среднем за последние 3 секунды.
почуствуй разницу между "щас" и "за последние три секунды"

еще подчеркну что cpu usage в точке щас такого понятия вобщемто нет. точнее оно есть
но оно неудобное. процессор щас либо занят CPU usage его 100% либо незанят и тогда 0%.
это нам ничего недает.

далее я еще раз  обсуждаю часть то что сказал выше  а часть нового:
также суперванжно добавить что процесс себя сам выдавить из цпу неможет. самс себя убрать из цпу
процесс неможет. нет ассемблерной команды которая бы выдавила процесс из цпу. вообще что значит
выдавить процесс из цпу. это значит что на какое то время код процесса небудет размещаться на цпу. а ведь только в этом случае процесс будет иметь статус S\D.
это может сделать толко шедулер ибо он в очередной квант времени сует код код процесса на цпу
а код других процессов несует.в юзерспейсе нет такой команды асемблера которая бы обратилась
к шедулеру и сказала мол все я закончила давай убирай меня из цпу. (этот факт что программа сама добровольно обратилась  к шедулеру и сказала мол я закончила раньше времени либо я буду ожидать наступление некоего события поэтому можешь пока выдавливать меня называется voluntary_ctxt_switches
тоесть это процесс сообщил добровольно шедулеру что он может выдавливать этот проецсс из цпу на какоето время. так вот я утверждаю что из кода юзерской программы это невозможно сделать, тоесть 
самому себя выдавить из цпу невозможно а даже если бы это было возможно то об этом бы незнал шедулер , шедулер бы считал что процесс отработал на цпу полный квант времени и статистика по процессу в procfs была все равно такая что как бутто он отработал полный квант в любом случае
сам код программы это сделать неможет работая в юзер спейсе он это может сделать только вызвав
ядерный код через сисколл. я несмотрел код сисколлов но я точно уверен что добровольная отдача обратно цпу а другими словами запрос к шедулеру о том чтобы он выдавил процесс из цпу и вставил другой находится в сисколлах. самый простой сисколл который может это сделать это nanosleep(), 
если в баше то это /bin/sleep, если через асемблер запускать то это сискол номер 35, если пишем на
C то там это вызывается через libc обертку sleep(), остальные сисколлы они там сами решают
когда они хотят сделать запрос к шедулеру чтобы он выдавил процесс из цпу.  еще раз напомню 
что добровольная отдача цпу что по факту никакая неотдача а запрос к шедулеру чтобы он выдавил
процесс из цпу назвыается voluntary_ctxt_switches. так вот я еще раз скажу что я считаю что 
это может сделать только сисколл. делает он это неспрашивая нас когда мы его вызываем например
наша програма  ждет нажатия кнопки для этого мы вызываем сисколл который этим занимается, сисколл
выставляет условие в ядро о том когда процесс надо будить и сисколл просит у шедулера выдавить
процесс из цпу и небудить до момента наступления нажатия кнопки. так и только так происходит voluntary_ctxt_switches . из кода программы юзерского мы так сделать неможем никак а может только 
вызывав сисколл. причем сисколл nanosleep() через него мы в явном виде заказываем выдаволение процесса с цпу на заданное время , другие же сисколлы сами определяют когда на какое время или до наступления какого условия выдавить процесс из цпу и делают запрос к шедулеру тоесть вызывася эти
сисколлы мы понятия неимеем как когда зачем и почему данный сисколл закажет выдавливание ( ака добровольный конекст свич) потому что мы вызываем эти сисколлы для других целей например прими нажатие от кнопки. цель этого длинного куска была втом чтобы обьяснить как на практике и откуда
получается добровльный контекст свич. оценить как часто сисколлы нашей программы заказывали
добровольное выдавливание можно через:

	$ cat /proc/$$/status | grep switch
	voluntary_ctxt_switches:	172
	nonvoluntary_ctxt_switches:	5

соответвенно nonvoluntary_ctxt_switches - это недобровольное выдавливание процесса из цпу 
со стороны шедулера. когда это происходит - тогда когда программа работает но ее тайм слайс 
так уж вышло закончился. тогда шедулер принудительно выдавилвает процесс из цпу. я бы еще добавил 
так что если процесс все время нахрится в состоянии 'R' то у него конечно будут только сплощные
nonvoluntary_ctxt_switches потому что его нужно будет постоянно выдавиливать. а если процесс
слабо нагруженный который часто в "S" то у него буду преимушественно voluntary_ctxt_switches.
оно ипонятно процесс сам по себе в состояние S перейти никак неможет, для этого он обязательнро 
должен вызывать сисколл в котоом наверняка будет выдавилвака процесса из цпу , слабонагруженность
это прямое следствие статуса S и выдавиливалки в сисколле том или ином.

посмотрим для примера статистику по процессам:

$ cat /proc/1/status | grep switch
voluntary_ctxt_switches:	  34780
nonvoluntary_ctxt_switches:	 1194

логично.

а тепер вот такую программу возьмем

$ cat 24.c
#include <stdio.h>
#include<unistd.h> 


int main () {

   /* local variable definition */
   pid_t pid;
   pid = getpid();
   printf ("pid = %d\n",pid);

   int a = 10;
   /* while loop execution */
   while( a < 20 ) {
   }

   return 0;
}

тоесть по факту это просто пустой бесконечный цикл.

компирлируем
$ gcc -o 24.exe 24.c

и сразу для интереса дизасемблиуриуем:
$ objdump -b elf64-x86-64 -M intel  -d 24.exe

000000000000068a <main>:
 68a:	55                   	push   rbp
 68b:	48 89 e5             	mov    rbp,rsp
 68e:	48 83 ec 10          	sub    rsp,0x10
 692:	e8 b9 fe ff ff       	call   550 <getpid@plt>
 697:	89 45 f8             	mov    DWORD PTR [rbp-0x8],eax
 69a:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
 69d:	89 c6                	mov    esi,eax
 69f:	48 8d 3d ae 00 00 00 	lea    rdi,[rip+0xae]        # 754 <_IO_stdin_used+0x4>
 6a6:	b8 00 00 00 00       	mov    eax,0x0
 6ab:	e8 b0 fe ff ff       	call   560 <printf@plt>
 6b0:	c7 45 fc 0a 00 00 00 	mov    DWORD PTR [rbp-0x4],0xa
 6b7:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
 6bb:	7e fa                	jle    6b7 <main+0x2d>
 6bd:	b8 00 00 00 00       	mov    eax,0x0
 6c2:	c9                   	leave  
 6c3:	c3                   	ret    
 6c4:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
 6cb:	00 00 00 
 6ce:	66 90                	xchg   ax,ax


на самом деле цикл while 
это вот эти две команды которые будут крутится вечно

 6b7:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
 6bb:	7e fa                	jle    6b7 <main+0x2d>

ну это чисто так для интереса мы дизасмлировали чтобы посмотрть как С програма будет
выглядит на асемблере.

так вот такая программа неимеет в своем цикле никаких сисколлов так что
эта программа хочет крутится на цпу все время (потому что без вызоыва сисколла программа 
претендует вечно занимать цпу ровно за этим и нужен шедулер), соттвенвенно статус у процесса будет R
все время и загрузка по цпу 100% птому что программа будет стремиться занимать все таймслоты что ей даст шедулер а шедулер будет вынужден выдалавить процесс хотя бы порой. вот щас это и проверим

запускаем
$ ./24.exe
pid = 20260


  PID USER      PR  NI    VIRT    RES    SHR     S  %CPU     %MEM     TIME+ COMMAND                
20260 vasya     20   0   10832    968    868     R  100,0     0,0   0:23.64 24.exe  


$ while true ; do cat /proc/20260/status | grep switch; sleep 1; done
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	73
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	73
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	79

видно что у программы нет ниодного добровольного отдачи цпу потому что да его и нет 
в коде програмы потому что у нас в цикле нет ниодного сисколла. так что щедулер 
исключтельно принудительно nonvoluntary выдавливает процесс из цпу.
цикл снятия статистики выдает ее раз в секунду ( а мы помним что щедулер срабаывает примерно
100 раз в секунду) так что из статистики видно что шедулер далеко некаждый раз выдавливает 
нащ процесс из цпу (иначе бы за секунду он это делал 100 раз а мы видим что за две секунды бывает
что и ни разу), так что программа резвится на цпу очень даже хорошо , лишь иногда шедулер
все таки выдавивет ее из цпу. отсюда мы делаем три вывода: 1) шедулер далеко не каждый тайм слайс (10мс) выдавливает процес из цпу, 2) если в коде программы нет сисколла ( у нас конечно есть в программе сисколлы но вне цикла while тоесть до них очередь недошла) то ни о каком добровольной 
отдаче цпу и речи неидет для этого обязательно нужно вызывать сисколл в коде программы. 3) даже если в системе есть свободные ресурсы то все равно время от времени шедулер выкидывает процесс
из цпу это значит что система недаст процессу 100% времени на цпу иногда всеже она будет
его на немного выдавливать. опять же незабываем что интеррапты приходят на цпу и немало и 
их обработка она же тоже жрет время цпу так что даже на многопроцессорной системе часть мощности
цпу будет вседа уходит по крайней мере на обработку интераптов( я так посмотрел в top цифра si и она доходит порой до 4%). так что будем ссчитать что в лучшем случае процесс может сидеть на цпу на уровне 96%.




пример с nanosleep
$ cat 37.c
#include<stdio.h>
#include<time.h>


int main()
{

     const struct timespec kuku = {300, 100};
     struct timespec kuku2 = {3, 100};

     nanosleep(&kuku, &kuku2);

    return 0;
}


через этот сисколл мы просим шедулер выдавить из цпу наш процесс на 300 секунд и еще 100мс
компилируем запускаем:
$ gcc -o 37.exe 37.c
$ ./37.exe

дальше интерсно я подождал скажем минуту а дальше смотрю статистику
$ cat /proc/24455/stat | awk '{print $3, $14, $15}'
S 0 0

про $14 и $15  я уточню интересное это сколько цифры . первая про юзер спейс вторая про кернел спейс. сколько времени процесс работал в юзер спейсе и в кернел спейсе тоесть сколько времени
процесс выполнял юзерский код а сколько времени проецесс выполнял сисколлы. так вот интересно тут
то что в каких единицах времени это меряется. в man proc написано что цифры обозначают clock tics
сразу скажу что это не цпу клоки и все такое. 1 clock tic это время между вызовами шедулера это 
один тайм слот. вот $14 и $15 показывают число тайм слотов в штуках которые процесс провел на цпу.
далее они предлагают число этих штук этих слотов поделить на sysconf(_SC_CLK_TCK) по дефолту
оно равно 100. тоесть 100 раз в сеунду срабывает таймер интеррапт и вызвается шедулер .таким 
образом если мы поделим тайм слоты на 100 то узнаем в секундах ( а в не в штуках слотов) процесс
прокрутился на цпу. 

  на мой взгляд поэтому немного странно получаенные цифры S 0 0. что как бутто процесс
  непровел на цпу ни единого тайм слота. хотя.. может быть %14 и %15 округляет до целых ведь процесс может провести на цпу толко часть тайм слота а потом попросить щедулер его выдавить.
  тайм слот очень большой целых 10мс. за это время туча кода может отработать. а наша программа
  мелкая и вся заточена под скорейшее выдавливание из цпу. так что может 0+0 это и реальная цифра 
  тоесть программа провел на цпу какоето время но существенно меньшее чем даже 1 тайм слот 10мс.


 теперь посмотрим на 

 $ cat /proc/24455/status | grep switch
voluntary_ctxt_switches:	1
nonvoluntary_ctxt_switches:	0

это было снято через минуту уже как программа была запущена.
тут мы видим что процесс ощутил на себе всего одно добровольное выдавливание из цпу.
и больше ни одного выдавливания небыло. это показывает то что цисло эти switch оно обозначает
сколько раз реально из цпу код процессы был выкинут. это значит что такое минимальное количество
раз код точно побывал на цпу и его выкинули. это незначит что ровно такое число процесс был
на цпу. число может быть гораздо больше скажем для постоянно работющего процесса. как я показал
выше шедулер постоянно рабоатающий проецесс при налиичии ресурсов выдавливает далеко некаждый 
цикл. так что сколько секунд или циклов (которые можно пересчитать в циклы умножив на sysconf(_SC_CLK_TCK) который обычно равен 100) процесс провел на цпу можно посчитать заглянув в 
$14 и $15. а в  voluntary_ctxt_switches и nonvoluntary_ctxt_switches указано реально 
сколько раз код был выкинут,выдавлен из цпу.

вот в нашем конкретном примере четко можно увидеть что код залетел на цпу был выкинут 
и больше код на цпу недопускался.

получается возьмум pid=1
$ cat /proc/1/stat  | awk '{print $14, $15}'
999 1390

получается на цпу он отработал всего (999+1390).100~24c при том что аптайм 12 дней. но тут нет 
парадокса потому что $14 и $15 это же то суммарное время когда код процесса реально работал на
цпу а процесс init он же постоянно спит 'S' так что все нормально. указано чистое время
сколько код процесса реально крутился на цпу. аптайм здесь ни при чем.

а вот если мы возьмем процесс который постоянно раотает статус R у него $14+$15 должны очень
точно совпдаать с временем как мы его запустили (при наличии ресурсов у компа то есть процесс
дейсвительно должен потоянго быть R )


запустим такую программу которая просто цикл
#include <stdio.h>
#include<unistd.h> 


int main () {

   /* local variable definition */
   pid_t pid;
   pid = getpid();
   printf ("pid = %d\n",pid);

   int a = 10;
   /* while loop execution */
   while( a < 20 ) {
   }

   return 0;
}


я запустил а далее

$ cat /proc/25506/stat | awk '{print $14, $15}'
1462 0

получаем что программа крутится на цпу ~15c и да это похоже на правду (засекал с секундомером).

а вот еще чуть позже  я посмотрел статистику для этого процесса
$ cat /proc/25506/stat | awk '{print $14, $15}'
10882 2
$ cat /proc/25506/status | grep swi
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	1246

получается что процесс отработал на цпу ~11c
из них он недобровольно (оно и понятно почему ) был выдавлен с цпу 1246 раз.

это значит что он неработал после этого хотя бы один цикл цпу прежде чем быть назначен обратно
это значит 1246\100 = 1.2с 

ну тоесть процесс отработал на цпу (10882+2) циклов а его выдавили из цпу 1246 раз. тут
конено возникает вопрос сколько времени занимает процесс выдавливания процесса из цпу
потом сколько времени процесс ждал пока его обратно засунуть на цпу потом время которое нужно
чтобы его всякие там регистры засунуть в цпу  это все потеря времени. ну если например предпололо
жить что что каждый раз когда его выдавили из цпу то весь процесс обратного его ожидания и сования
на цпу составил всего один цикл (хотя может и быстрее а может и медленее) тогда получается что 
с того момента как процесс запустили он простаивал 10% времени.

так в /proc/$$/stat  в поле $39  показывается номер ядра на котором раобтает процесс.
я запустил процесс и статистику снова. получил такое. 

~$ while true; do cat /proc/25919/stat | awk '{print $14, $15, $39}'; sleep 1; done
3301 0 1
3401 0 1
3502 0 1
3602 0 1
3703 0 1
3803 0 1
...
8730 0 1
8830 0 1

$ cat /proc/25919/status | grep swi
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	28


тоест процесс выдавливался шедулером 28 раз недобровольно.
но небыло смены цпу все время процесс работал на ядре номер 1.
получется процесс отработал на цпу ~8.8с и был выдавлен 28 раз.
если процесс выдавливания и обратгного размещеия считать занимал 1 цикл (что нефакт что это так по времени может меньше может больше) то получается что (28\8830) ~= 3% процесс простаивал. 
интересно.


далее будет частичное повторение уже сказанного и часть нового. 
про ассемблерную команду nop. которая ничего недалает. влияет ли ее применение на уменьшение  
cpu usage в выводе top. короткий ответ - нет нихрена невлияет вообще.
 если мы в программе разместим цикл с асемблерной
командой NOP которая по факту внутри цпу ничего неделает это нам ничего недаст потому что 
по факту цпу ничего неделает но с точки зрения шедулера код процесса все равно исполняется на цпу
формально команда nop это тоже команда. код неисполняется значит то что на цпу работает код от 
другого процесса а нето что на цпу выполняется NOP от данного процесса. 
как шедулер высчиывает цпу юзэж процесса он считает циклы цпу в течение которого код выполняется
на цпу (можноу ивдеть в procfs) , далее как top высиытает cpu uxsage  - он берет некий интервал. 
смотрит солько это в тиках цпу. а потом делит сколько тиков процесс сидел на цпу на число тиков на 
инетрвале. получем cpu usage %. здесь важно быол понять что из юзерсепейса процесс сам себя в состояние S перевести неможет так как для этого он должен удалить сам себя на какоето время 
из цпу.  насколько я понимаю дажебы если бы процесс мог такое сделать то об этом бы незнало ядро.
тоест скажем процесс некоей конмандй остановил свое выоплолнение на какое то время до момента
насутлпения таймер интеррапт на цпу. но при этом процесс его регистрвы все равно занимают
цпу а сам процесс неможет себя вычистить из цпу. но тем неменее на каком то интервале до настулпния
таймер интеррапт он бы невыполнялся но фишка в том что ядро и щедулер об этом бы незнали 
и  с их точки зрения процесс сидел на цпу все кванты времени поэтому перменые статистики в /pric/pid/ все равно бы были такие что как бутт процесс выполнылся на цпу. поэтмоу такое невозоможно 
через юзер код. а вопзомоно только если попрпоситьоб этом шедулер. тоесть нужно передать управление
шедулеру с прсобой вычистить регистры от этого процесса и загрузить туда другой и обновить
параметры статистикии  в процфс вот только тоггда для ядра процесс рельно неисоплнется на цпу
и его статус будет S. поэтому процесс состоящий из одиеих команд NOP будет выглядеть в 
top как процесс который на 100% жрет цпу. хотя казалось бы он ничего неделаеи. но это он 
неделает по факту. но с точки зреня шедулера на цпу лежат регистры именно нашео процесса,
выполняется порядок команда нашего процесса и другого процесса на цпу нележит в этот квант времени прэтому с тчоки зерения шедулера цпу занят нащим процессом. важно было разсянить этот экспримент.



двигаем дальше перехоим к рассмотрению переменной /proc/21944/syscall.
так как уже было сказано что если статус процесса R тоесть это означает 
что прям щас на цпу выполняется либо код программы (user space) либо код ядра вызыванный
через сисколл (кернел спейс) то нам непонятно нам хочется знать так щас что выполняется
код программы или кернел код. как это узнать. 

узнать это можно если посмотреть что покажет proc/$$/syscall
$ sudo cat /proc/21944/syscall

если там будет слово
running

это значит что на данный момент выполняется юзерский код программы.

strace при этом покажет вот это:
$ sudo strace -p 19356
strace: Process 19356 attached
strace: [ Process PID=19356 runs in x32 mode. ]


а если там будет вот чтото такое
270 0x1 0x7ffce82706c0 0x0 0x0 0x0 0x7ffce82705f0 0x7ffce82705b0 0x7f24978ceec9

тоэто значит что сейчас на цпу выполняется ядерный код вызыванный через сисколл

270 это номер сисколла котоый щас выполняется.
270 это pselect6 (согласно /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h) 

также убедиться в этом же можно если присодиниться к процессу через strace

$ sudo strace -p $PID
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

единственное что мы можем неуспеть то есть пока мы подкючимся процесс будет уже выполнять какото другой код.


а что покажет /proc/21944/syscall если у нас процесс спящий тоесть его статус 'S'\'D'.
отвечаю что он покажет номер сисколл который значит то что до того как процесс впал в спячку
цпу был занят выполнением этого сисколла. более того я утрвеждаю что именно этот сисколл и был
тем кодом который попросил шедулер вогнать процесс в спячку. я там далее ниже показал это 
на примере запущенной команды $ sleep 180

еще хочу добавить про /proc/pid/wchan вроде бы он вцелом показыает тоже самое что и /proc/pid/syscall но я читал  в инете что этот wchan порой показыает хрень так что на него лучше неполагаться.

итак подвеем итоги по /proc/pid/syscall.
если статус процесса "R" и цпу выполняет юзерский код то /proc/pid/syscall покажет "running"
если статус процесса "R" и цпу выполняет кернел код то /proc/pid/syscall покажет номер сискола
который щас исполняется
если статус процесса "S"/"D" то /proc/pid/syscall покажет номер сисколла который выполнялся на цпу
до того как процесс начал спать, более того это имено тот сисколл который попросил шедулер вогнать
процесс в сон, и конечно на данный момент этот сисколл невыполняется на цпу.


далее повтор того что уже сказано и возможно часть нового.
интересенйшая вещь. команда asm nop хотя она по факту ничего неделает на цпу но процес в цикле 
с этой командой будет показывать статуст R 100%. потому что cpu usage в top\proc происходит с той
точки зрения выполнялся ли код на цпу. а такак nop это все равно команда то с точки зрения шедулера
или другими словами ядра - код выполнялся, поэтому небудет нкиких 0% cpu usage. 0% cpu usage возможно толко 
тогда когда код процесса физиечески шедулером неразмещается на цпу. поэтому 
я скажу так что переменстить процсс в состояние S невомозможно без вызовы хоть какого то
сисколла в проетсейшем случае это sleep. нужн какойто ядерный код который соощит шедулеру о том 
что код этого роцеса ненадо пихать на цпу столко то времени либо до настулпнеия такого то события.
опа!!! поэтому можно быть 100% увреным что у всех проецссов в состоянии S в его /proc/$$/syscall 
стоит имя какого нибуль сисколла! именно этот сисколл и сунул процесс в состояние sleep говоря другими словами попросил щедулер исключить процесс из цпу либо на промежуток времени либо до наступления какогто события.

сделаем пример. команда sleep

$ sleep 180
процесс будет в состоянии S в течение 180 секунд.
посмотрим через strace какой сисколл щас она покажет
$ strace ...
...
nanosleep({tv_sec=180, tv_nsec=0}, 

посмотрим какой сисколл указан в /proc/$pid/syscall 
$ sudo cat /proc/29719/syscall
35 0x7fff0baec2f0 0x0 0x0 0x0 0x0 0x0 0x7fff0baec2e8 0x7fba62d9e774

номер 35. 
найдем имя этого сисколла
$ cat /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h | grep 35
#define __NR_nanosleep 35

совпадает с тем что показывает strace.
Получается что имя сисколла который показывает strace и который показывает /proc/$pid/syscall
если статус процесса 'S'\'D' то это не имя сисколла котрый щас выполняется на цпу . нет. это 
имя сисколла который выполнялся последним до того как процесс вошел в состояние 'S'\'D'.
по факту я утверждаю что именно этот сисколл и вогнял процесс в состояние 'S'\'D'.
существенно тут то что сисколл щас невыполняется. нет. он выполнялся до того как процесс вошел в
спящее состояние но щас он невыпоняется. также можно смело утверждать что именно выполнялся сисколл
а не чтото иное до того как процесс вошел в спящее состояние. и еще раз именно указанный сисколл
и вогнал процесс в спящее состояние. естственно не только сисколл 35 умеет вгонять процесс в спящее
состояние. таких сисколлов вагон. важно тут было понять то что значит имя сисколла который мы видим
в /proc/$pid/syscall если статус процесса 'S'\'D'. еще раз смысл найденного сисколла в том что это 
было последнее что выполнял цпу для данного процесса прежде чем процеесс вошел в спящее состояние.
сейчас код процесса ни юзерский ни сисколловый на цпу невыполняется , оно все вытеснено. и то что
именно этот сискоолл и вогнал процесс в спящее состояние.



далее опять повторение того что выше и может быть чуть нового.
nop только на powerconsumption влияет а на статус S и на цпу юзадж
с точки щрения шедулера никак! ведь ядро как определяет cpu usage - по числу таймслайсов в теччение которых код выполнялся\размещался (что одно и тоже) на цпу. пусть даже эта команды nop. nop невозвращает управление шедулеру ядру ОС. это такая же обычная команда как и любая другая. 
просто по факту цпу в это время ничего неделает. но с точки зрения шедулера это абсолютно неважно! вот это я хочу донести. шедулер меряет произвиодительность cpu usage для процессора исходя неиз того какие команды запускает процесс. на это шедулеру насрасть. шедулер меряет количество времени
в течение которого на цпу размещается любой код процесса. вот шедулер поместил код процесса на цпу
на 1 тайм слайс. процесс это время отработал. шедулер вытесняет код процесса (иногда оставляет но это щас неважно для простоты щас считаем что он каждый раз код вытесняет) и ставит себе галочку в 
/proc/pid/stat о том что процесс отработал на цпу +1 тайм слайс. а команда top читает это количество и делит его на три секунды (дефолтовый промежуток обнволения экрана у top). и таким 
макаром в top появляется cpu usage. тоесть в cpu usage играют рояль только тайм слайсы в течение
которых код процесса крутился на цпу. и шедулеру и top абсолютно насрать какой код крутился в те моменты будь это mov или nop или любое другое. поэтому применение циклов с nop никоим образом
неуменьшаем cpu usage для процесса. оно только уменьшает powerconsumption у цпу на которйы нам полностью насрать. единсвенйы вариант уменьшить цпу юзадж это когда наш процесс запустил команду
syscall и начад исполняться ядерный код и этот код сам решает на момент работы в таймслайсе что
уже ему сисколлу ненужен больше цпу либо на какоето время либо до момента наступлениея какогто
события и тогда сисколл обращается к шедулеру и просит его выдавить процесс из остатка таймслайса.
и вот только тогда и только по такой причине процесс на скольо то таймслайсов небудет размещаться 
шедулером на цпу. получется что на какоето время на какоето количество таймслайсов процесс больше
не размещается на цпу. он физически больше неисполняется. и это дает то что в ячейке отображения
статистики в /proc/pid/stat останавливаются поля $14 и $15 и только тогда у нас с точки зрения
top падает cpu usage. потому что если за 3 секунды у нас ненаступило приращение полей 14 и 15
то значит что 
100*[ 0/(100*3) ] = 0%  cpu usage за последние 3 секунды
где 
0 = дельта изменеия $14+$15
100 = число таймслайсов в секунду (сколько раз в секунду вызывается шедулер)
3 = интервал в секундах обновления экрана в top по дефолту

то есть мы делим количество таймслайсов которые процесс отработал за последнеи три секунды
и делим на общее число таймслайсов которые прошли за это время. это и есть как top высчитывает 
колонку %cpu usage. если процесс многотредовый то наверное в /proc/pid/stat поля $14 и $15
отображают суммарную статистику по таймслайсам для всех тредов. отсюда и получает в top цифры такие
как 200% , 400% , 1000% итд.


то как я щас себе это вижу. как процсс может попать на S состтояние.  через юзер спейс команды никак. никак сам себя процесс неможет выдавить из очереди на выполпнение шедулера. чобы это сделать
надо вызывать какойто сисколл который сформирует условие для шедулера\ядра о том что мол пока что 
меня ты с очереди выкинь то наступления некоего события. и только тошгда процесс будет шедудером выкинут из очереди на выполеннеи!

разница S и D тока в том что S разрешает прилет сигнала к процессу. а D нераазрешеает.
а так это оба процесса код которых неразмещен на цпу.

еще раз про voluntary_ctxt_switches, nonvoluntary_ctxt_switches.
оно показывает сколько прям раз код процесса находясь на цпу был выдавлен из цпу , либо добровольно
тоесть когда сисколл сам попросил об шедулер либо принудительно когда у процесса истек таймслайс
сработал таймер интеррапт запустился щедулер на этом цпу и он выдавил этот процесс из цпу.
важно здесь еще раз отметить что это не цисло сколько раз цпу проходясь по очереди runqueue доходил
до этого процесса и проверял мол ставить его на цпу или нет. это совсем нетак. во первых процесс
удаляется из runqueu а во вторых как уже сказал это неколичетсво проверок а реально число случаев
когда код процесса сидел на цпу и он был выгнан выдавлен вычищен из цпу.

на счет шедулера важнйы момент важный вопрос а как он работает в случае когда у нас много цпу в 
системе. вот на одном цпу сработал таймер интеррапт значит на этом цпу будет загружен шедулер 
и запущен. и понятно что на этом цпу шедулер сможет выдавить текущий процесс а что в это время
с другими ядрами? туда тоже шедулер в этот момент загружен или нет или щедулер на этом цпу 
сидя выдавливает процессы с других ядер . нет походу это все нетак. как я щас понимаю
когда сработал таймер интеррапт на текущем ядре и был загружен шедулер на текущее ядро 
то этот шедулер выдавливает процесс с текущего ядра только а другие ядра нетрогаются да и как
он их сможет тронуть если на тех ядрах произошел такойже таймер интеррапт. а это нет!
так что шедулер загружается на данное ядра. выдавливает процесс на данном ядре а на остальных 
ядрах работа в это время идет без изменений. потом на другом ядре происходит таймер 
интеррапт и на том другом ядре происходит индивидуальное выдавливание процесса. и так для каждого
ядра индививидуально согласно его индивидуальному срабатывания таймер интеррапт. других ядер 
это некасается. вот так я думаю работает система шедулинга в случае много ядерной машины.

==

bash, strace, 
fork, clone


поповоду того что баш если запускает команду из файла то он вначале себя 
форкает точнее испольуется сисколл clone() потом запускает execve.
убедимся на примере:

во первых если мы пишем

$ strace ls

то мы неувидим как баш делает fork ( при том что щас как я прочитал линукс неделает форк а
делает вместо него clone) но в любом случае мы это неувидим потому что как я понял strace создает 
из себя грубо говоря клон и в нем запускает уже коману и уже смотрит какие сисколы эта комнда будет
вызывать. а нам же нужно затрейсить наш баш в котором мы сидим  а не сам ls. поэтому нам надо 
отркыть второе окно и в нем запустить strace самого баша тот который  в первом окне через команду

$ sudo strace -f -p 26294   (где 26294 это pid баша из первого окна)
также можно сразу указать какие сисколлы мы хотим отслеживать

$ sudo strace -e clone,fork,execve -f -p 26294

так вот что меня удивляет.
у баш есть встроенные команды тоесть которые у него в его бинарнике /bin/bash зашиты
получается что если мы их будем запускать то башу форкать ничего ненадо. проверяем на while ибо он 
являетс builtin для баша. он встроен в бинарник баша.

(окно1) $ while :;do :; done
(окно2) $ здесь увидим пару ioctl и пару rt_sigaction

окей. все понятно все красиво. все совпадает.

а теперь пробуем команду echo

с одной стороны баш пишет что это его встроеный builtin

$ type echo
echo is a shell builtin

с другой стороны 

$ which echo
/bin/echo

и также через strace видно что запускается некий внешний файл /bin/echo :

$ strace echo $$
clone(..
execve("/bin/echo", ["echo", "26294"], 0x7ffcd2aa8898 /* 70 vars */) = 0

тоесть получается по дефолту баш при команде echo испольщует несвой билтин а внешнюю команду.
потом я приказал башу в явном использовать встроенный echo

(окно1) $ builtin echo $$
и тогда уже все отработало нормльно без clone и execve.

как заставить баш по дфеолту для команды echo исполтзовать свой билтин непонятно.

а вот уже как выглядит запуск ls который уже точно невстроенный

(окно1) $ ls

(окно2) 
$ clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb85ece9490) = 28795
strace: Process 28795 attached
[pid 28795] execve("/bin/ls", ["ls", "--color=auto"], 0x558216669510 /* 71 vars */) = 0
[pid 28795] +++ exited with 0 +++

здесь мы четко видим что при старте внешней команды баш иполтьзует clone+execve

=======

cpu 
power consumption

задача. надо получить сколько ватт жрет цпу.
поможет прога turbostat из пакета linux-common-tools.

$ sudo turbostat --quiet --show PkgWatt
PkgWatt
1.23
1.22

==========
blocked process
наконец нашел что же такое blocked process оказывается = A runnable process is one
that is not blocked; a blocked process is one that is sleeping, waiting for I/O from the
kernel. 
тоесть blocked процесс это процесс в состоянии 'D'

=========
OR и biwise OR (Bitwise inclusive or)

обыкновенный OR (обозначается || ) этот тот у которого на выходые true или false
пример:

2<5 || 5<1 = true

bitwise or (обозначается | ) = это логический OR только для битов, когда мы берем
один байт и второй байт и делаем побитовый OR. резулттатом является набор битов.

9 | 5 =  15

1010
0101
-----
1111
========
processes kill parent child

что было интересно.

вот есть процесс. этот процесс порождает другой процесс.
первый это парент второй это чайлд.

далее что будет если послать kill -15 паренту?  умрет ли автоматом при этом чайлд?

что я высснил на данный момент.
если написать самопимную программу на C которая делает fork() 
то kill -15 парента убивает парент но чайлд спокойно остатется жить дальше.

а вот если в качестве подопытной программы взять bash то тут (видимо в нем прописан
кастомный обработчик сигналов) все идет подругому. посылка kill -15 к паренту неприводит
ни к чему. парент продолжает спокойно жить. я так думаю что в баш прописан кастомный хендлер
для сигнала 15 в котором написано что если у баш есть чилдрены то тогда сигнал 15 парент должен
игнорировать. а вот если паренту послать сигнал -9 то тогда умирает и парен и чайлд.

вот так интересные результаты пока из эксперимнтов
=========
scheduler
run vs runnable

у нас в ps есть статус 'R'
про него написано что это состояние обозначает сразу два типа процессов - run и runnable.
тоесть это значит что либо процесс реально испольняется на цпу либо неисполняется а стоит в
очеред runqueue и ждет когда для него освободится цпу.


вопрос - а можно както узнать так процесс щас реаьно исполняется или он в очереди стоит ?
поиска в инете ответ я увидел что люди такой вопрос задают но ответа нет. так что я пришел к 
выводу что простого решения как это увидеть нет. едиснвенное решение что я видел это наисать ядерный модуль который будет сканировать что-то в ядре и на основе деталей статуса в таблице процессов или еще где то там (тоесть в ядре безусловно есть точная галочка о том что прроцесс щас реально исполняется на цпу или всеже в очереди стоит) получать такую инфо.
итак короткий ответ  - простого способа это узнать нет.

========
ps
FLAGS 1,4

у команды ps есть флаг -l
и в нем есть колонка F

$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000 13908  3866  0  80   0 -  8528 wait   pts/148  00:00:00 bash
4 R  1000 14966 13908  0  80   0 -  9525 -      pts/148  00:00:00 ps

о чем эта колонка? в ней могут быть числа 0,1,4,5.

по факту они описывают два свойства процесса.

флаг 1 =  в мане описывается так "fork but didnt exec". по факту это значит что процесс был получен путем запуска fork() на его родителе (или clone() о чем нет в 
man ps) но потом в этом процессе (который дочка для парента) небыл запущен execve

тоесть еще раз о чем цифра 1 в этой колонке. обычно как в системе получается новый процесс.
есть процесс А он хочет создать новый процесс. как он это делает. он берет и делает fork()
или clone() получаем дочку B. Далее в дочке B запускается execve(). таким образом мы получили новый процесс B в системе.  так вот флаг 1 нам сообщает что процесс B был создан через fork\clone
НО после этого execve небыл использован. когда на практике это может быть. очень просто. когда 
у нас был  к примеру запущен bash и мы в нем запускаем еще один bash. поскольку бинарник у нас
такой же /bin/bash то смысла выполнять execve нет смысла. execve нам нужен если у нового процесса
другой файл бинарника. например парент процесс у нас /bin/bash а из него мы запускаем /bin/ls

флаг 4 = он говорит о том что процесс запущен с правами root. пример

$ sudo bash
$ echo $$
$ ps -Al | grep $$
# ps -Al | grep -E "$$|PID"
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 15102 15101  0  80   0 -  7464 wait   pts/148  00:00:00 bash


флаг 5 = это когда одновременно и флаг 1 и флаг 4.

прикол еще раз скажу в том что ( я проверил на практике)  что флаг 1 у процесса нетолько 
когда был использован fork но и когда clone тоже. тоесть я бы сказал про флаг 1 по другому
неважно форк там или клон или еще что было примеенено у парента. главное что в текущем процессе
небыл применен execve. тоесть это флаг об отсуствии применнеия execve.


флаг 0 = гораздо хитрее что значит 0. 0 значит отсуствие обоих флагов обоих условий но что это значит на практике?
разве это значит что  какойто процесс был получен без применнеия fork\clone ? как такое возмжно? нет!! это значит что процесс был получаем с примененеием fork\clone и далее с помощью execve !!!!!! вот что !!! таким образом можно воббще забыть про эти упоминания форк хуерк он тут неиграет
никакой роли. флаг 0 означает что в текущем процессе был использован execve при его создании
а флаг 1 означает что execve небыл использован . вот и все! это обьяснение гораздо лучше мудацкого
обьяснения из man ps.


что еще интересно: чтобы вызывать clone() (чтобы успешно откомпилирвать файл  на *.c) 
нужно в C программе использовать следующие макросы:

#define _GNU_SOURCE
#include<sched.h> 


где define _GNU_SOURCE совершенно особая штука. (https://stackoverflow.com/questions/5582211/what-does-define-gnu-source-imply)


что еще паралельно интересно. что еси в C программе мы вызываем fork()
то пофакту вызывается сисколл clone() а не форк!!! и strace это показыавет. а дело вот в чем!: дело в том что в C прогармме
кода мы пишем fork() clone() и прочие типа сисколлы на самом деле мы вызываем не сисколлы а функции библиотки
LIBC. а вот уже те функции вызывают чистые сисколлы. так вот  
libc fork() он по факту вызывает  clone() сисколл.
загадка разгадана.  в ядре естественно есть сисколл fork() но чтобы его заюзать 
надо тогда писать программу на асемблере а не на C. еще раз важно понять что в C коде мы вызываем функции библиотек libC
(функции обертки) а не реальные сисколлы ядра. поэтому это еще вопрос какой сисколл ядра юзает 
функция обертка libc.

итак еще раз когда мы в программе на C пишем вызов fork() то fork в данном случае
это не сисколл fork ядра а функция fork LIBC которая в свою очередь обращается к некоторому сисколлу ядра. в случае функции fork LIBC она обращается к сисколлу ядра clone а не к сисколлу fork как это можно было бы ожидать. 

в целом я бы сказал что столбик F имеет мало какого важного значения мало что дает 
интересного полезного. 

=================
| djvu
| jpg

как взять кучу jpg файлов  и превратить их в многостраничный djvu файл

значит заходим в папку с .JPG файлами и превращаем их в .DJVU файлы
причем  я написал строку команд которая конвертрует кучу  этих файлов в несколько потоков
поэтому на 8-ми процессорах у нас в 8 раз быстрее. а это очень экономит время
конвертация из jpg в djvu идет через утилиту c44

    $ CPU_N="6"; DPI="50"; for i in `ls *.JPG`  ; do echo "$i --> ${i%.JPG}.djvu" ; c44  -dpi "$DPI"   $i   ${i%.JPG}.djvu &  { while [[  $( ps aux | grep c44 | grep -v grep | wc -l )  -eq "$CPU_N" ]] ; do  sleep 1 ; done ; };      done;   { while [[  $( ps aux | grep c44 | grep -v grep | wc -l )  -ge 1 ]] ; do  echo "ждите..."; sleep 1 ; done ; }; echo "готово" 
    
пиздец этой утилиты c44 состоит в том что во первых она сука переворачивает исходную страаницу. 
ты такой думаешь ну хуйс ним я щас поверную исхдную страницу и тогда djvu получится нужно ориетации. а хуй там.
это проблема решается на следущем щаге другой утилитой.
и вторая проблема в том что параметр c44 -dpi 100 он по факту нихуя ниечего полезного неделает. птому что 
утиита c44 она беерет исходный jpg и его рзмер в точках не меняет. поэтому от того что я выставляяю c44 -dpi 300
или c44 -dpi 100 нихуя ни на что не влияет. размер выходного файла будет одинаковый. и его размер в пикселаях будет
одинаковый. и его степень размытости тоже будет одинаковая. только едиснтвенное в сойствах файла будет 
указано что у него 300 dpi. нахуя это нужно непонятно. ононичего по факту не дает сука.
свойтва файла можно посмотреть вот так

$ djvudump modulus-1#2.djvu 
  FORM:DJVM [67015338] 
    DIRM [1448]       Document directory (bundled, 170 files 170 pages)
    FORM:DJVU [258295] {2101.djvu} [P1]
      INFO [10]         DjVu 4032x3024, v24, 70 dpi, gamma=2.2
      BG44 [52056]      IW4 data #1, 74 slices, v1.2 (color), 4032x3024
      BG44 [72448]      IW4 data #2, 15 slices
      BG44 [133745]     IW4 data #3, 10 slices


видим что указан размер страницы в пикселах и dpi 4032x3024, v24, 70 dpi
еще раз подчеркну какой бы dpi в c44 -dpi ты ни указал это нина что сука не влияет на выходе на самом деле.
поэтому если скажем нужен размер на выходе меньше то нужно уменьшать исходные .JPG файлы


кстати как посмотет совйства .JPG файла

    $ exiv2 2101.JPG 
File name       : 2101.JPG
File size       : 1803899 Bytes
MIME type       : image/jpeg
Image size      : 4032 x 3024
Exif Resolution : 4032 x 3024
White balance   : Auto
Thumbnail       : image/jpeg, 7553 Bytes


Итак мы получили кучу djvu файлов.
теперь их нужно слепить в один файл мультиистраничный .таже если его погтом пихать на гитхаб
то у гитхаба ограничение на размер файла 100МБ. а в djvu утилитах я не нашел как жерразрезать гтоовый 
мульиистанчный файл на несоклько кусков. поэтому приходится склеивать два djvu файла руками. 
скливаем вот так

    $ djvm -c "./02/modulus-1#2.djvu"     `ls -1 *.djvu | head -n +170`
    $ djvm -c "./02/modulus-2#2.djvu"     `ls -1 *.djvu | tail -n +171`

тоесть первый 170 файлов суются в modulus-1#2.djvu
а остальнлые файлы суются в modulus-2#2.djvu

получили два djvu мультистраниный файла. но это еще не все. помнишь я вговорил что c44 ебанутый
он разворачивыает исходные файлы. теперь их нужно повернуть обратно.
тогда

    $  djvused  "./02/modulus-1#2.djvu"  -e 'set-rotation -45; save'
    $  djvused  "./02/modulus-2#2.djvu"  -e 'set-rotation -45; save'
    
причем утилита тоже ебнутая мы поворачиываем на 90 гардусов но почемуто нужно указатьт 45.


И ВОТ наконец мы из кучи JPG файлоы получили два файла djvu многостранияных. аминь аллилуця.






=================
| zombie
| signals
| SIGCHLD
| SIGTERM
| SIGINT


zombie

еще раз поговорить про зомби процесс.

как он получается.

вообще это статус процесса. в целом это нормальный статус процесса если он длится недолго.
и ненормально если длится долго.


как он получается. когда в ядро поступает запрос ( неважно откуда от самого процесса, через Ctrl+c,
от другого процесса вобщем неважно) на уничтожение этого процесса из системы то 
система вычищает все кишки процесса но остается небольшой хвостик в таблице процессов в ядре
и в частности сохраняется код возврата говорящий о том нормально процесс завершил работу или
с ошибкой и ядро далее шлет сигнал парент процессу SIGCHLD который сообщает процессу о том что
состояние дочернего процесса изменилось ( кстати необязательно в сторону что дочерний процесс склеил ласты 
, также SIGCHLD посылаетя ядром к парент процессу если напримр процесс был останолвен изза сигнала SIGSTP 
либо продолжил свою работу после сигнала  SIGCONT).  
Далее ядро вот как подразумевает: в коде программы
может быть прописан хендлер обработчик сигнала SIGCHLD если так есть то при старте парент процесса 
ядро это учтет и зарегистрирует этот обработчик. так вот при в этом случае при поступлении в парент 
процесс SIGCHLD сигнала шедулер при следующем таймслайсе
запустить этот кастомный обработчик этого сигнала. в целом ос ожидает что в этом обработчике в 
итоге будет использован libc функция wait (которая в итоге юзает кернел сисколл wait4) и 
данная функция через сисколл считает код возврата дочернего процесса. как только ядро увидит этот факт 
то ядро считает что вот теперь то дочерний процесс можно полностью уничтожить. значит как только в ядро
поступил запрос на удаление процесса и до момента когда парент процесс считает код возврата
дочернего процесса все это время дочерний процесс будет висеть в списке процессов имея статус Z.
так вот когда могут пойти проблемы - кастомный хендлер в парент процессе для сигнала SIGCHLD его
нужно написать програмисту тоесть это обязанность создателя программы парент процесса. 
а если он этого несделает? тогда в строй вступает дефолтовый ядерный обработчик данного сигнала и фишка
в том что дефолтовый обработчик по дефолту игнорирует данный сигнал. Поэтому получается что если 
парент программа неимеет своего кастомного обработчика да еще и 
правильно написанного ( с использованием libc wait() ) то тогда получается что код возврата 
от дочернего процесса небудет
прочитан парент процессом никогда. и значит что дочерний процесс будет висеть в статусе Z вечно.
уничтожить его через сигналы невозможно ибо он уже почти уничтожен и болльше его неуничтожить.
итак причина появления Z процессов это остутствие кастом хендлера сигнала SIGCHLD в парент процессе.
тоесть нужно парент программу переписывать. правда есть еще такой выход - нужно 
остановить уничтожить парент процесс тогда у дочернего процесса поменяется номер парент процесса 
в лоховской литературе пишут что этим процессом 100% станет сразу процесс с pid=1. но это брехня
как написано в более правльно литература новым парентом станет некий ближайший к дочернему 
процессу процесс но совсем необязательно что это будет процесс с pid=1
по моей практике парентом станет совсем другой процесс.
после этого можно надеяться что новый парент процесс имеет коректный обработчик SIGCHLD
сигнала и нужно тогда послать SIGCHLD сигналл новому паренту руками
    $ kill -17 $PARENT_ID
и тогда новый парент прочитает код вовзрата у зомби процесса (название ебанутое какой долбоеб
придумал) и этот проесс исчезнет. только возикает вопрос а можно ли узнать какой процесс
был родительским у зомби процесса и является родительсикм на данный момент?
щас посмотрим
   
пример.

вот у меня есть процесс 22.exe

вот его  код

$ cat 22.c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include<sys/wait.h>
#include<unistd.h>
#include<time.h>
#include <sys/types.h>


pid_t pid;
int finished=0;

int main(void)
    {

       pid = fork();

        if (pid == -1)
        {
           exit(1);
           } 

        else if (pid == 0)
        {

           time_t starttime = time(NULL);
           time_t seconds = 60; 
           time_t endtime = starttime + seconds;
 
              while (starttime < endtime) {
               sleep(180);
               printf("child: i am running...\n");
               starttime = time(NULL);
               }
           exit(0);
            }

        else if (pid > 0)
        {
          pid_t pid_p = getpid();
          printf("parent: parent PID=%d...\n", pid_p);
          printf("parent: child PID=%d...\n", pid);
             }




    while(!finished)
        {
        printf("parent:i am running...\n");
        sleep(1);
        }
    }

$



и вот его дерево от дочернего процесса до его парента а далее парента того парента итп.

~$ pstree  -A  -s  -p 20834
systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(20614)---mc(20742)---bash(20744)---
---22.exe(20833)---22.exe(20834)

парентом для 20834 является pid=20833

еще раз в этом убедимся

$ ps -o user,pid,ppid,pgrp,sess,stat,cmd -p 20834
USER       PID  PPID  PGRP  SESS STAT CMD
vasya    20834 20833 20833 20744 S+   ./22.exe

уничтожаем парента 20833

$ kill -9 20833

$ ps -o user,pid,ppid,pgrp,sess,stat,cmd -p 20834
USER       PID  PPID  PGRP  SESS STAT CMD
vasya    20834  1718 20833 20744 S    ./22.exe

и мы видим интереснейшую картину что новым парентом стал далеко непроцесс с pid=1 нет.
новым парентом стал pid=1718, об этом редко где пишут.

еще важно отметить что из за того что парент у процесса сдох
это не значит что у ребенка будет Z статус потому что чего бы ему менять свой статус,
статус Z получается тогда когда либо сам процесс в данном случае дочерний по своей
воде хочет завершить работу и тогда он сам вызывает сисколл exit(). в моем коде
этого нет, либо дочерний процесс делает чтото нето и его ядро начинает рубить посылая
шедулеру сигнал SIGINT\SIGHUP\SIGTERM\SIGKILL но тут процесс дочерний не делает
ничего плохого, либо в дочерний процесс по какойто другой причине прилетает сигнал
SIGINT\SIGHUP\SIGTERM\SIGKILL, но в данном случае от того что парент процесс был убит
это совершенно не порождает сигналы от ядра к чайлд процессу, также у нас у парент
процесса все хендлеры сигналов дефолтовые а это значит что при заканчивании работы у 
процесса он не ищет своих чайлдов и не пытается их грохнуть. поэтому чайлд процесс
продолжить работаь как ни в чем ни бывало!
также интересно отметить что уничтожение парент процесса хоть через сигнал -9 хоть 
через сигнал -15 неуничтожает автоматом дочерние процесса. я проверил конечно
так и есть. от того что мы шлем паренту 15 сигнал это не приводит к тому чтобы 
чайлду был послан сигнал на уничтожение. чайлд продолжит работать как ни в чем ни бывало.




если мы еще раз посмотрим на исходное дерево родительских отношений для исходного процесса

systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(20614)---mc(20742)---bash(20744)
------22.exe(20833)---22.exe(20834)

то мы увидим что новый парент это вверх по цепочке , второй от начала.

вот это очень интересно что новый парент это не pid=1 как пишут во многих книжках.

почему в системе несколько systemd процессов это другой разговор. скажу только что 
systemd(1718) это systemd который запущен в системе вот с таким ключом

/lib/systemd/systemd --user

почему именно на этот процесс из всей цепочки пал выбор для нового парента пока тоже непонятно.

в любом случае двигаем дальше. что нам теперь дает то что у чайлда теперь парентом
является процесс systemd. дает оно то что у нового парента есть 
кастомный обработчик сигнала SIGCHLD а у  systemd он однозначно есть,
и этот обработчик качественный. то есть если в systemd процесс прилетит сигнал SIGCHLD,
этот обработчие запускает сисколл wait()\waitpid() и в systemd возвращается код завершения
дочернего процесса, и тогда ядро полностью уничтожает дочерний процесс. 
но чтобы в systemd прилетел сигнал SIGCHLD нужно в дочерний процесс послать сигнал SIGTERM\SIGINT\SIGKILL. тогда ядро поочти полностью уничтожит дочерний процесс оставив
в своей памяти кусочек данных от дочернего процесса  а сам процесс получит статус Z.
и также ядро пошлет в парент процесс сигнал SIHCHLD.

так что если мы после убиения нашего исходного парента (22.exe(20833))
нам остается послать сигнал SIGTERM\SIGINT\SIGKILL чайлду (22.exe(20834))
тогда я говорю вот что случится - ядро грохнет почти поолносью чайлд процесс 20834
по крайней мере уже код этого процесса уже не будет соваться шедулером на цпу, 
от чайлд процесса в памяти не останется ничего кроме кусочка некоторых служебных структур
в памяти ядра об чайлд процессе. с точки зрения щедулера процесс получит статус Z,
далее ядро пошлет новому парент процессу (systemd) сигнал SIGCHLD. обработчик сигнала
SIGCHLD у процесса systemd будет запущен и этот обработчик запустит сис колл wait()\waitpid()
который заставить ядро доставить в systemd код завершения работы чайлда (20834) а это 
в свою очередь заставить ядро уже полностью уничтожить все остатки от чайлд процесса. 

кстати хочу добавить что для сигнала SIGKILL написать свой кастомный обработчик
для процесса нельзя. не получится. тоесть обработчик SIGKILL он всегда только идет
дефолтовый ядерный. это важно. ядерный обрабтчки сигнала SIGKILL абсолютно не занимается
поиском чайлд процессов того процесса на который направлен SIGKILL и 
поэтому уничтожения чайлд процессов при этом НЕ происходит.


 
в чем вообще прооблема с этим Z процессом кроме того что непорядок что он виисит в системе.
проблема в общемто только в том что он пока висит в статусе Z то он занимает номер в таблице процессов.
и то что сколько то ядерной памяти он занимает.
на 32-битных ядрах всего был 32768 доступных номеров для процессов так что если 
наразмножится много Z процессов то система исчерпает возможность создавать новые процессы. незнаю
что при этом будет. кернел паник или что.

еще раз скажу что если процес в статусе Z то уже бесполезно шедулеру слать
сигналы об этом процессе. ядро видя что процесс находится в состоянии Z
небудет ничего далее с ним делать при поступлении любых сигналов. на цпу уже код
процесса засовываться не будет. ядро будет ждать пока какой нибудь процесс не вызывет
сисколл wait()\waitpid() чтобы вернуть тому процессу код заверщения работы чайлда.
и только после того как ядро увидит что какйото процесс забрал код завершения работы
Z процесса - только тогда ядро уже полностью вычистить все что осталось от Z процесса
из памяти. 
так что его никаким $ kill -9 невырубить. 
когда я говорю процесс не принимает сигналы то это означает что если 
пошлем сигнал этому процессу то ядро больше не будет вызывать ни хендлер этого сигнала
ни кастомный если он был ни дефолтовый если его не было у процесса.

через $ ps такой процесс будет иметь вид как <defunct> например

22.exe <defunct>

насколько я понял самый реальный случай откуда могут вылезат на практике Z процессы
это скажем апач который запускает типа скрипт баша чтоли а в этом скрипте есть скажем строка с grep
типа 

...

cat /....  | grep 

и далее там было написано где я этот пример встречал что апач может по таймауту грохнуть процесс
скрипта а как он его грохает ну конечно же  некоей командой килл и аналогичным сисколлом в итоге
ядро пошлет сигнал -15 процессу со скриптом по хорошему этот процесс со скриптом должен иметь 
хеендлер кастомный для сигнала -15 который убивает все дочерние процессы причем он должен вначале
убить все дочерние процессы считать их код возврата и потом только сам закончить свое существование.
на практике наверное этого часто нет. и что в итоге. в итоге процесс со скриптом будет уничтожен
но в системе останется дочерний процесс тот который grep. далее что получается что раньше для 
grep праентом был процесс со скриптом а теперь ( кстати вопрос) парентом станет (наверное) процесс 
с апачем и он ( неужели? ) неиммет обработчика кастомного для SIGCHLD сигналов и поэтому процесс с 
grep будет висеть как Z. помне этот пример какойто бред потому что мне кажется что новым парентом 
будет systemd и он грохнет этот grep без проблем. но даже если новым парентом будет апач
то я думаю у него 100% есть свой хендлер для SIGCHLD процессов потому что он же сам 
порождает чайлдов так что у него просто обязан быть этот хендлер. 
вобщем вопрос как на живой практике люди ловят стада Z процессов надо еще выяснить.


значит я тут еще дальше поговорю про эту всю ситуацию
смотрим на примере все того же 22.c
как видно из текста программы в ней нет своего кастомного хендлера никаких сигналов.
это значит что при запуске этого кода ядро назначит хендлером всех сигналов
свои дефолтовые хендлер
но для начала я напомню себе что за сигналы SIGHUP, SIGINT, SIGTERM
и чем они отличаются. значит про SIGHUP есть статья про в этом файле выше. ищу ее читаю.
вспоминаю. в общем получается что SIGHUP это в настоящее время сигнал когда ядро считает 
что с терминалом в котором был запущен процесс есть проблема. типа потеряна связь с этим 
терминалом. например окно терминала закрыли. тогда  толи сам терминал толи ядро шлет
всем процессам у которых в свойствах было прописан этот терминал сигнал SIGHUP. 
ксатти когда пишут слово контрольный терминал то это сука значит просто терминал. нет никаких 
неконтрольных термиалов. в свойствах процесса либо указан его контроььный терминал тоесть
терминал с которго его запустили либо никакого терминала. зачем было ебать мозг называя терминал
контрольным термиало непонятно. вобще сигналы это большая тема.
кстаи что значит процесс имеет терминал в своих свостйвах. это значит что у процесса открыты файлы
которые ведут на устройство терминала. и значит процесс может писать на терминал и чиать с терминала.
а так как термиал это устройство взаимодетйисвя с человеком то получается процесс подрузамуевает
взаимодейтсивие с человеоком. в контраст демоны не имеют терминалов в свойствах  и нне подразумевают этого.
но это не всегд так. если заустить процесс через nohup то в его свойствах будет указано что он имеет
терминал а по факту среди открытых файлов небудет терминала. пример
вот я запукаю sleep в терминале
в его совойствах проесса указан терминал

$ ps -p 2092
  PID TTY          TIME CMD
 2092 pts/4    00:00:00 sleep

и видно что он имеет откртым файлы ведущие в терминал
$ ls -1al /proc/2092/fd
0 -> /dev/pts/4
1 -> /dev/pts/4
2 -> /dev/pts/4

теперь запускаем чеерз nohup
во первых проверяю какое дерево процессов получаю. есть ли там сам nohup
$ pstree 2644 -Aspl
...---bash(12509)---sleep(2644)
тоесть видно что nohup тоесть он работает не так как sudo, он замещает очевидно
свой бинарник бинарником sleep

теперь смотрим есть ли sleep в свойствах терминал

$ ps -p 2644
  PID TTY          TIME CMD
 2644 pts/4    00:00:00 sleep

проверяем есть ли у него откртыйтые фалы ведушие в терминад
$ ls -1al /proc/2644/fd
0 -> /dev/null
1 -> /home/vasya/git/docs/nohup.out
2 -> /home/vasya/git/docs/nohup.out
8 -> 'pipe:[12875464]'


видино что нет. непонтно тогда почему в его свойствах процесса указан терминал.
что за хрень. если он неможет ни пиать в терминал ни читать.

вот что пишет дока по LIBC про sighup 
    (https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html)
The SIGHUP (“hang-up”) signal is used to report that the user’s terminal is disconnected, 
perhaps because a network or telephone connection was broken. 
This signal is also used to report the termination of the controlling process 
on a terminal to jobs associated with that session; 
this termination effectively disconnects all processes in the session 
from the controlling terminal. For more information, see Termination Internals.

итак sighup как я и сказал появляется тогда когда есть проблема с терминалом 
с которого был запуещен процесс. у меня только вопрос - если терминал запущен локально
на компе то все понятно как ядро опредляет жив терминал или нет. скажем мы тыкаем на крестик
в терминале и самоеже ядро и уничтожает терминал поэтому ядро знает что с терминалом 
проблема.  а если у нас терминал это железка. то как ядро узнает о проблемах со 
связью с темрианалом непонятно. 

вообше как я прочитал тамже почти все сигналы по своей сути говорят о том что прогу
надо закрывать. просто они эту инфо несколько персонализируют и пэтому дают возможность
хендлеру чуть иначе закрывать прогу делая и неделая какието дейтсивя при закрытии.

выше в своей же сиатье я прочитал то что sighup его можно блокировать можно игнорироватью. 
в чем разница. если игнорировать то если он прилеел то мы ничего неделаем. как бутто и небыло
сигнала. а еслим блокировать то он продолжает висеть в свойствах процесса но мы временно запрещаем
ядру запускать хендлер а вместо  этого просим шедулер запустить код процесса. позже 
прдразуевается что код процесса разбокирует сигнал тоесть разрешит ядру запустить хендлер
и сигнал который там ждет будет обработан. 
также я прочитал у себя выше что если есть кастомный хендлер то якобы при первом поступлпнии
сигнала будет запущен кастомынй хендлер.  а при повтором якобы уже дефолтовый хедлер 
будет запущен. щас проверим
на практике не подтверждилось

$ cat 01.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void sig_handler(int sig_num)
{
if(sig_num == SIGINT)
{
printf("\n Vasya! ты послал вменя сигнал siginit!Caught the SIGINT signal\n");
}
else
{
printf("\n Caught the signal number [%d]\n", sig_num);
}

// Do all the necessary clean-up work here

//exit(sig_num);
}

int main(void)
{
//Register signal handler through the signal() function
signal(SIGINT, sig_handler);

while(1)
{
//simulate a delay -- as if the program is doing some other stuff
sleep(1);
}

return 0;
}


прога выставляет кастомный хенлер для SIGINT который 
просто печатает на экране мессагу но программу не закрывает.
кстати SIGINT это сигнал который шлется процессу который запущен в этом терминале 
и в с этого же терминала мы тыкаем на клаве Ctrl+C тогда драйвер терминала шлет процессу SIGINT,
запускаю эту прогу, тыкаю Ctrl+C либо шлю сигнал через
    $ kill -2 $pid
и у меня каждый раз пеаатется моя мессага
     Vasya! ты послал вменя сигнал siginit!Caught the SIGINT signal
и нет такого чтобы это отработало толко  1 раз а потом бы отрабатываел штатный хендлер ядра.
такого нет. так что не подвержлилось то что "также я прочитал у себя выше что если есть кастомный хендлер то якобы при первом поступлпнии
сигнала будет запущен кастомынй хендлер.  а при повтором якобы уже дефолтовый хедлер 
будет запущен."

я проверил еще один момент.  я запустил прогу в терминале
    $ nohup slepp 140
а потом закрыл этот терминал
и прога продолжада работать. это доказывает то что когда мы закрываем терминал
тыкая на крестик то ядро шлет процессу сигнал именно SIGHUP
и если хендлер процесса шлет нахер этот сигнал то процесс продолжит работать.
тоесть при закрытии терминала на кретик процессу шлется именно сигнал SIGHUP и никакой другой.

так вот насчет сигнала SIGINT. его можно послать через kill а можно через Ctrl+C
и тут возникает исторический вопрос  как ядро узнает какому процессу послать SIGINT
дело в том что  у нас может быть много процессов и все они были запущены из одного терминала
у них у всех в своствах будет один и тот же терминал. так кому из них послыть сигнал SIGINT?
и тут выходит на сцену такое свойство процесса как "foreground process group" эта штука
имеет привязку к конкретному терминалу. щас я буду делати разбирать. однако главное состоит в том
что вот у нас куча процессов была запущена на терминале. так вот процесс может принадлжеать
либо не принадлежать к "foreground process group". если процесс принадлежить к нему тогда
все что прилетает на терминал с клавы драйвер терминала шлет как я понял всем процессам которые
принадлежать к "foreground process group". и если эти процессы чтото срут на stdout то 
это разрешено передавать на терминал. соотвесвтенно если мы нажали Ctrl+C  то ядро пошлет SIGINT
всес процессам которые на этом термиале принаджлежать к "foreground process group"
пэтоум еслт я запущу процесс через 
    $ sleep 130 &
а потом тыкну CTrl+C то он неполетит к тому процессу. потому что он очевидно не принадлежит к
"foreground process group" !!!! охуеть!

возникает вопрос вот у нас есть процесс. можно както из баша проверить принадлежит
ли он к terminal foreground group или нет. как я понял - нет, из баша никак это не узнать.
зато можно узнать из C.

$ cat 119.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>


int main(void)
{

pid_t pid = getpid();
printf ("PID = %i \n", pid);
int fd = open ("/proc/self/fd/0", O_RDONLY);


if ( fd < 0 ) {
        printf("Opening file : Failed\n");
        printf ("Error no is : %d\n", errno);
        printf("Error description is : %s\n",strerror(errno));
        exit (1);
} 





pid_t fgrp = tcgetpgrp(fd);
pid_t pgrp = getpgrp();

if ( pgrp  == fgrp ) {
	printf("process foregrounded\n");
	printf ("foreground GROUP  = %i \n", fgrp);
} else {
	printf("process backgrounded\n");
}


sleep (600);

exit (0);



}



значит как я понял из описания про tcgetpgrp(fd), она либо возвращает ошибку в форме -1
либо она возвращает номер группы которая входит в terminal foreground  group
либо она возвращает некое рандомное число >1. возникает вопрос - так как же понять 
из ее ответа если число >1 это номер форегранд груп или это просто мусор. ответ такой как
я понял что надо взять номер pgroup (не путать с gid ) и сравнить  с тем что вернуло tcgetgrp
если они совпдаают значит это реально номер foreground group.
проеряем

запускаем процесс в фореграунде
$ ./119.exe
PID = 28024 
foreground код возврата  = 28024 
pgrp  = 28024 
process foregrounded




запукаеи проесс в бекграунде
$ ./119.exe &
[2] 28052
$ PID = 28052 
foreground код возврата  = 4073 
pgrp  = 28052 
process backgrounded

работает

теперь мы знаем ответ на вопрос когда мы в терминале жмем Ctrl+С то ядро шлет SIGINT 
тем процессам которые входят в prgroup который является "terminal foreground group"

приколно значит внутри терминала процессы делятся на те что входят в TFG (terminal foreground group)
и те что нет.

из того что я прочитал если процесс который не входит в TFG пытается писать на терминал то ядро
ему присылает сигнал SIGTTOU , если хендлер процесса этот сигнал отвергает игнориует
тогда идет запись на терминал. 
немного по другому про чтение. если процесс котоый не входит в TFG пытается чиатть из терминала
то ему приетает сиганл SIGTTIN , и по идее хендлер процесса должен оставноить процесс (SIGSTOP)
а если сигнал игнориуется то сисколл считывания вернет ничего и код возврата будет ошибочный (ERRNO).

тоесть похорошему программа которая пытается читать или писать ей нужно при каждой такой транзацкции 
проверять находится ли она в TFG. если нет то ждать пока она в ней появится чтоли.

соотвесвтенно джобы в баше основаны на TFG. если мы запускаем прцоесс через & то баш 
его пихает в отдельный pgrpup который не входит в TFG. 

итак про разницу я говорил между SIGHUP, SIGTERM, SIGINT. ну SIGKILL понятно этот сигнал
его процесс не может заблокировать или игнорирвать. тут все понятно.
SIGHUP это сигнал который посывлется процессам при закрытии терминала на крестик.
SIGINT посылается при нажатии Ctrl+C в терминале процессам которые входят в TFG данного 
терминала.  SIGTERM считется самый органичный сигнал для заврешение процесса. по крайней
мере если сам прцоесс вызывает вннутри вызывает сисколл exit\return то явдро пошлет
процессу именно сигнал SIGTERM. значит будем юзать именно его для шатаного завершение
работы.

насклоько я понима если мы закрываем трминал на крестик то ко ввсем процессам которые были запущены
в темрианале ядро шлет SIGHUP.


SIGHCHLD послывется ядром к парент процессу если дочерний процесс либо завершил работу
либо дочерний процесс получил сигналы SIGSTP , SIGCONT. но чаще всего приходится иметь
дело именно когда дочерний процесс завершил работу. по дефолту если у парент процесса нет 
кастом хендлера для SIGCHLD то системный хеднлер он игнориует этот сигнал ,
это означает что если мы написали программ на C и не включили в нее наш кастонмый хендлер 
длля SIGCHLD и если мы юзаем CLONE и если мы убьем дочерний процесс то он зависент в статус Zombie
потому что наш парент процесс не будет обрабатывать его SIGCHLD сигнал а значит не будет
запускать wait() функцию а значит не будет считывать код заврешения дочереннего процесса.
а занчит ядро будет держать ошметки дочеренго процесса в памяти.
возврааешаетмся к 22.c

$ cat 22.c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include<sys/wait.h>
#include<unistd.h>
#include<time.h>
#include <sys/types.h>


pid_t pid;
int finished=0;

int main(void)
    {

       pid = fork();

        if (pid == -1)
        {
           exit(1);
           } 

        else if (pid == 0)
        {

           time_t starttime = time(NULL);
           time_t seconds = 60; 
           time_t endtime = starttime + seconds;
 
              while (starttime < endtime) {
               sleep(5);
               //printf("child: i am running...\n");
               starttime = time(NULL);
               }
           exit(0);
            }

        else if (pid > 0)
        {
          pid_t pid_p = getpid();
          printf("parent: parent PID=%d...\n", pid_p);
          printf("parent: child PID=%d...\n", pid);
             }




    while(!finished)
        {
        //printf("parent:i am running...\n");
        sleep(15);
        }
    }


    
я его запускаю. и убиваю дочерний процесс. 
и я ожидаю что наш доченй процесс зависнет со статусом зомби. потому что 
наш парент неимеет своего хендделера для SIGCHLD а системный хендлер игнриует этот сигнал.
значит парент не считает код вовзарата. 

$ ./22.exe 
parent: parent PID=401...
parent: child PID=402...


$ ps -p 401,402 -o pid,tty,stat,cmd
  PID TT       STAT CMD
  401 pts/26   S+   ./22.exe
  402 pts/26   Z+   [22.exe] <defunct>


вот видно что чайлд 402 завис со статусом Z



теперь я модифиицирую 22.c  в 120.c в который я ввтсавляют кастомнй хендлер SIGCHDL


$ cat 120.c
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>
#include<sys/wait.h>
#include<unistd.h>
#include<time.h>
#include <sys/types.h>
#include <signal.h>

pid_t pid;
int finished=0;


void zombie_hunter(int sig)
    {
    int status;
    waitpid(pid, &status, 0);
    printf ("got  SIGCHLD \n");
    printf("parent: Got status %d from child\n",status);
    }




int main(void)
    {

       signal(SIGCHLD,zombie_hunter);

       pid = fork();

        if (pid == -1)
        {
           exit(1);
           } 

        else if (pid == 0)
        {

           time_t starttime = time(NULL);
           time_t seconds = 60; 
           time_t endtime = starttime + seconds;
 
              while (starttime < endtime) {
               sleep(5);
               //printf("child: i am running...\n");
               starttime = time(NULL);
               }
           exit(0);
            }

        else if (pid > 0)
        {
          pid_t pid_p = getpid();
          printf("parent: parent PID=%d...\n", pid_p);
          printf("parent: child PID=%d...\n", pid);
             }




    while(!finished)
        {
        //printf("parent:i am running...\n");
        sleep(15);
        }
    }


    
что важно омтетить что при вызове
    waitpid(pid, &status, 0);
нужно указать pid дочеренего процесса. тоесть если у нас 100 дочерних процессов
и у нас прилетел SIGCHDCL то нам надо в парент процессе опросить все пиды всех дочених 
процесов потмоу что мы незнаем какой из дочерних наебунлся. иначе не ссработает. иначе
дочерний процецсс так и останется зомбти.

запускаю прогармуу

$ ./120.exe
parent: parent PID=1875...
parent: child PID=1876...


потом на другом терминале я убиваю 1876
и  на пермов терминале я вижу


got  SIGCHLD 
parent: Got status 15 from child


тоесть наш парент получил SIGCHLD.
и мы запустили waitpid с pid дочеренго процесса. 
и мы считали его код завешения. видим что код завреершения 15 это как раз значит
что дочерний пцроесс умер из за того что ему прилетел kill -15

далее я проверяю есть ли у меня висящий зомби дочерний прцоесс

$ ps -p 1875,1876  -o pid,tty,stat,cmd
  PID TT       STAT CMD
 1875 pts/26   S+   ./120.exe

и  видно что нет.
теория совпала с правктикой

кстати что это за S+
а вот что это значит

               <    high-priority (not nice to other users)
               N    low-priority (nice to other users)
               L    has pages locked into memory (for real-time and custom IO)
               s    is a session leader
               l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
               +    is in the foreground process group


тоеть S означает что процесс sleep это понятно а "+" означает что процесс работате в форегрануден

а вот для баша ткущего

$ ps -p $$  -o pid,tty,stat,cmd
  PID TT       STAT CMD
24628 pts/53   Ss   bash -rcfile .bashrc

видим что он "s" - session лидер. что  такое лидер сессии надо чиать отделно.

выяcним какие еще процессы работают в форегранудене

$ ps a  -o pid,tty,stat,cmd  | grep "+" | grep -v -E "man|bash|pager|mc|grep|ps" 
 4573 tty7     Rsl+ /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth ...
 9509 tty2     Ss+  /sbin/agetty -o -p -- \u --noclear tty2 linux
24197 tty1     Ss+  /sbin/agetty -o -p -- \u --noclear tty1 linux
24823 pts/38   S+   watch cat /proc/12673/fdinfo/70

еще раз подчеркну что  смысл говорить о том что процесс работает в форегрануден или бекгрануден
имеет толко если среди откртых файлов в процессе есть файлы терминала.
значит где то у нас есть открыто окно терминала. и в нем этот процесс должен на данный момент
срать на stdout на окно терминала и приимать наши кнопки с терминала в себя.
что касается agetty на tt1 и tty2 это понятно. если нажать на Ctrl+Alt+F1\F2
то мы попдем в tty1\tty2 и там висит пригладение к паролю. это наши агетти.
про watch тоже попнятно.  но не сосвсем понятно про  tty7 потому что Ctrl+Alt+F7 это граф 
режим. и как бы в нем нет визуально терминала tty7... непонятно..

тажке стоит заметить что убиение парента на вызывает автоматом убиниее детей. 
также убаинеие деетей не вызывает автоматом убиеение родителей.

возвращаюсь к 22.exee там где нет кастом хендлера для SIGCHLD.

запускаю
он порождает чайлда
видно кто у проецессов парент
$ ps -p 3417,3418  -o pid,ppid,tty,stat,cmd
  PID  PPID TT       STAT CMD
 3417  4073 pts/26   S+   ./22.exe
 3418  3417 pts/26   S+   ./22.exe

убиваю чаайлда
получаем зомби
$ kill 3418
$ ps -p 3417,3418  -o pid,ppid,tty,stat,cmd
  PID  PPID TT       STAT CMD
 3417  4073 pts/26   S+   ./22.exe
 3418  3417 pts/26   Z+   [22.exe] <defunct>

теперь убивают парента и автоматом ядро переназначаем паренту у зомби процесса
на какойто более верхний процесс

$ kill 3417

далее вопрос этому парент процессу ядро посылает автоматом SIGCHLD или нет?

$ ps -p 3417,3418  -o pid,ppid,tty,stat,cmd
  PID  PPID TT       STAT CMD

судя по всему да при переназначении парента ему ядро тоже посываелает автомтом SIGCHLD
потому что видно что зомби процеса нет. тоесть новый парент прочитал код возврата
у 3418 и поэтому система его закрыла.
еще раз почеркну что при вызове waitpid нужно указать pid чайлда. иначе не сработает. 
тоесть нужно знать pid чайлда.

поэтому суммарный алгоритм если есть зомби процесс что делать:
    1) через ps найти кто его парент и послать этому паренту руками SIGCHLD(-17)
        $ kill -17 $parent_id
    если это не помогает то надо убить парент, тогда ядро назначит чайлду нового
    парента и по идее должно автоматом это вылечить от зомби. если нет то повторяем пункт 1.

    
===============
| logitech
| mouse
| battery 

как проверить из команднйо строки уровень зарядки батарйи на мышке

$ upower --dump

покажет  не только щарядку мышки а вообще все что еть на батарейркиках

$ upower --dump
Device: /org/freedesktop/UPower/devices/line_power_ADP0
  native-path:          ADP0
  power supply:         yes
  updated:              Сб 06 янв 2024 15:16:41 (287340 seconds ago)
  has history:          no
  has statistics:       no
  line-power
    warning-level:       none
    online:              yes
    icon-name:          'ac-adapter-symbolic'

Device: /org/freedesktop/UPower/devices/battery_BAT0
  native-path:          BAT0
  vendor:               LC018
  model:                L18L3PF1
  serial:               2267
  power supply:         yes
  updated:              Вт 09 янв 2024 23:05:25 (16 seconds ago)
  has history:          yes
  has statistics:       yes
  battery
    present:             yes
    rechargeable:        yes
    state:               charging
    warning-level:       none
    energy:              21,71 Wh
    energy-empty:        0 Wh
    energy-full:         37,07 Wh
    energy-full-design:  36 Wh
    energy-rate:         0,00719749 W
    voltage:             11,413 V
    percentage:          58%
    capacity:            100%
    technology:          lithium-polymer
    icon-name:          'battery-good-charging-symbolic'

Device: /org/freedesktop/UPower/devices/mouse_hidpp_battery_0
  native-path:          hidpp_battery_0
  model:                Wireless Mouse M315/M235
  serial:               4009-b9-50-a6-d3
  power supply:         no
  updated:              Вт 09 янв 2024 23:05:20 (21 seconds ago)
  has history:          yes
  has statistics:       yes
  mouse
    present:             yes
    rechargeable:        yes
    state:               discharging
    warning-level:       critical
    battery-level:       critical
    percentage:          5%
    icon-name:          'battery-caution-symbolic'

Device: /org/freedesktop/UPower/devices/DisplayDevice
  power supply:         yes
  updated:              Вт 09 янв 2024 21:21:25 (6256 seconds ago)
  has history:          no
  has statistics:       no
  battery
    present:             yes
    state:               charging
    warning-level:       none
    energy:              21,71 Wh
    energy-full:         37,07 Wh
    energy-rate:         0,00719749 W
    percentage:          58%
    icon-name:          'battery-good-charging-symbolic'

Daemon:
  daemon-version:  0.99.7
  on-battery:      no
  lid-is-closed:   no
  lid-is-present:  yes
  critical-action: HybridSleep
[vasya@lenovo load-average]$ 
[vasya@lenovo load-average]$ 
[vasya@lenovo load-average]$ upower --dump
Device: /org/freedesktop/UPower/devices/line_power_ADP0
  native-path:          ADP0
  power supply:         yes
  updated:              Сб 06 янв 2024 15:16:41 (287421 seconds ago)
  has history:          no
  has statistics:       no
  line-power
    warning-level:       none
    online:              yes
    icon-name:          'ac-adapter-symbolic'

Device: /org/freedesktop/UPower/devices/battery_BAT0
  native-path:          BAT0
  vendor:               LC018
  model:                L18L3PF1
  serial:               2267
  power supply:         yes
  updated:              Вт 09 янв 2024 23:05:25 (97 seconds ago)
  has history:          yes
  has statistics:       yes
  battery
    present:             yes
    rechargeable:        yes
    state:               charging
    warning-level:       none
    energy:              21,71 Wh
    energy-empty:        0 Wh
    energy-full:         37,07 Wh
    energy-full-design:  36 Wh
    energy-rate:         0,00719749 W
    voltage:             11,413 V
    percentage:          58%
    capacity:            100%
    technology:          lithium-polymer
    icon-name:          'battery-good-charging-symbolic'

Device: /org/freedesktop/UPower/devices/mouse_hidpp_battery_0
  native-path:          hidpp_battery_0
  model:                Wireless Mouse M315/M235
  serial:               4009-b9-50-a6-d3
  power supply:         no
  updated:              Вт 09 янв 2024 23:06:49 (13 seconds ago)
  has history:          yes
  has statistics:       yes
  mouse
    present:             yes
    rechargeable:        yes
    state:               discharging
    warning-level:       none
    battery-level:       normal
    percentage:          55%                            <===================
    icon-name:          'battery-good-symbolic'
  History (charge):
    1704820009	55,000	discharging

Device: /org/freedesktop/UPower/devices/DisplayDevice
  power supply:         yes
  updated:              Вт 09 янв 2024 21:21:25 (6337 seconds ago)
  has history:          no
  has statistics:       no
  battery
    present:             yes
    state:               charging
    warning-level:       none
    energy:              21,71 Wh
    energy-full:         37,07 Wh
    energy-rate:         0,00719749 W
    percentage:          58%
    icon-name:          'battery-good-charging-symbolic'

Daemon:
  daemon-version:  0.99.7
  on-battery:      no
  lid-is-closed:   no
  lid-is-present:  yes
  critical-action: HybridSleep
 


    

================
| load average

вот у нас есть процессы со статусом R и D
вот мы сидим и снимаем число этих процессов в какие то моменты времени.
это можно сравнить с тем что с дерева падают яблоки. в момент t0 у нас упало 3 яблока
в момент t0+dt у нас упало 1 яблок в момент t0+2*dt упало 0 яблок.
на самом деле яблоки падают непрерывно но мы неможем их фиксировать неперрывно мы
можем снимать эти данные только дискретно в отдельные моенты времени. тогда мы что делаем
мы считаем что если мы снимаем показания через равные интервалы dt  и если у нас
есть какоето показание в момент t1 то мы считаем что это же показание остается таким же
на всем отрезке [t1-0.5*dt; t1+0.5*dt]. получаем такие столбики. далее мы хотим найти среднее.
тоесть надо найти площадь этой фигуры ссостоящей из стоолбиков (график такой по оси X
у нас время скажем в секундах. по оси Y  у нас число яблок в штуках). мы находим площадь 
фигуры и делим на интевал времени суммарный на котором расматрвиаем. скажем 60с (1 минута).
в итоге мы получим горизональную линию которая на этом же интевале 60с образует график
такой же по площади. 

в итоге load average  как бы покаызвает среднее значение сколько яблок падает 
в момент  t2 находящийся внутри этого интервала 60c точнее это даже не момент t2 
а это интервал [t2-(differental)t; t2+(differential)t]
где differential это реально из математики дифференциал. тоесть крошечный отрезок вокруг t2.
таким образом вот это среднее значение, эта горизонтальная палка ее высота будет зависеть от ДВУХ
временных величин 
    1) как часто мы снимаем данные , тоесть насколко много точек на графике,
      тоесть насколько маленький dt мы берем
    2) насколько большой суммарный интевал мы берем.
чем более короткий dt и чем более короткий сумарнй интервал тем более точно мы будем получать 
среднее значение к реальному физическому.

вот эта величина и есть load average. только вместо яблок идут число процессов со статусом R или D.
размерность этой величины это штуки\секунду


поэтому когда мы говорим LA то мы должны говорить что LA=X на суммарном интервале 
усреднения 1мин\5мин\15минут при частоте снятия показаний скажем 1 секунда.

у нас же когда говорят LA то упоминают только первый показатель времени 1м\5м\15м
а про второй вобще молчат.
но LA невозможно определить используя только один парарметр времени

значит вот я из этого файла /usr/src/*headers*/include/linux/sched/loadavg.h
следует что второй интервал времени котоырй испольует ядро в расчетах это 5 секунд!

    $ cat loadavg.h
    #define EXP_1		1884		/* 1/exp(5sec/1min) as fixed-point */
    #define EXP_5		2014		/* 1/exp(5sec/5min) */
    #define EXP_15		2037		/* 1/exp(5sec/15min) */


итак когда мы говорим про LA за  1 минуту мы имеем ввиду усреднение на интервале 60с
при частоте сбора данных каждые 5 секунд. получается что мы считаем что в течение -2.5 секунды
влево и +2.5секунды вправо у нас значение не меняется отнсиельно того что мы замеряли



щас попробую нарисовать график показать графически как работает расчет шарманки


 Y (число процессов, штуки)
 
 ^
 |
 |
 |                          --*--
 |                          |   |
 |                          |   |
 |      --*--               |   |
 |      |   |               |   |
 |      |   |          --*--|   |
 |      |   |          |   ||   |
 |      |   |     --*--|   ||   |
 |      |   |     |   ||   ||   |
 | --*--|   |     |   ||   ||   |
 | |   ||   |--*--|   ||   ||   |
 | |   ||   ||   ||   ||   ||   |
 ----|----|----|----|----|----|----|----|----|-->  X  (time, сек)
 0  t0        t2         t4        t6

 
на счет того как оценить LA большое или нет. скажем LA =15
это много или мало. чтобы это понять надо кое что знать о самом компе.
надо сравнивать LA с число ядер на компе. если ядер меньше чем LA то это плохо.
потому что получается что скажем в какойто момент времени у нас число процессов 
которые готовы для выполнения на цпу равно 15 штук а если число ядер скажем 10 
то оставшиеся 5 процессов стоят и ждут в очереди. если же ядер 30 штук то все окей.
15 процессов будут крутится на 15-ти ядрах из 30-ти.
если у нас LA=5 а число ядер 2 то опять же это уже плохо. потому что получается всреднем
в каждый момент времени у нас число процессов которые хотят попасть на цпу 5 штук
а ядер всего два. значит три проццесса будут ждать в очереди. 
правда опять же если у нас LA=1 а число ядер равно 5 то не стоит думать что это 100% 
доказывает что все хорошо. потому что чистто математически возможная такая картина.
на короткий срок скажем унас образуется 10 процессов которые хотят выполняться на цпу. 
а потом на длитеьный срок у нас нет ни одного процесса. и тогда у нас LA=1 
но как понятно у нас тоже будет на момент этого пика нехватка ресурсов цпу.

что делать если LA  у нас типа зашкаливает в этом отношении. нужно либо увеличивать 
число ядер. либо увеличивать мощность самих ядер. увеличение числа ядер дает то что мы можем
одноврмененно болше процессов раскидать по ядрам. а увелчиние  мощности ядра дает то что
обьем времени который нужен чтобы выполнить некий квант работы уменьшается. тоесть 
за единицу времени наше ядро способно через себя прогнать большее количество процессов.

однако жопа еще состоит в том что у нас в LA входят нетолько R процессы но и D процессы.
и вот если это так то это значит что эти процессы ждут ответа от например дисковой системы.
и значит тогда надо ускорять дисковую систему. 

так вот когда у нас  LA составляют только R процессы то мы легко можем проанализировать
численное значение LA. больше оно или маленькое. а если в LA входят и D процессы то 
тут уже число хрен что нам скажет. тоесть если LA=5 и оно накручено только R процессами и 
у компа 2 ядра. то мы четко знаем что надо либо число ядер увеличить хотя бы до 5. либо надо 
увелчиить мощность ядер хотя бы в 2.5 раза. тоесть мы можем както колчественно проанализировать 
что нам надо делать. 
а вот если LA=5 и это все за счет D процессов то хрен знает во солько раз нужно
увеличить скорсть дисковой системы. тоеть 5 процессов ( всреднем) висят и ждут ответа от диска 
или дисков.  а если LA образован смесью из D и R процессов и это равно 5 то что тут
можно скзаать численно? что и во сколько раз нужно ускорять ?


далее я запустил вот такую программу которая использует vfork
для создания дочернего процесса и сама впадает при этом в D состояние
пока дочерний процесс не закончит свою работу. по факту это дает то что мы получаем
в системе D прцоесс который нихеран неделает не грузит систему. с другой
стороны это нам дает +1 процесс который участвует в формировании LA.
это гораздо удобнее для тестов чем гонять цпу на нагрузке или читать с диска.

$ cat 30.c
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {

    pid_t pid = vfork();

    if (pid == 0) {
    sleep(300);
    return (0);
    }

      printf("parent: I am exiting\n");

     return(0);
}


так вот я запустил эту прогу. получил процесс со статусом D
далее я отслеживал LA(1 min)
и оказалось что если процесс R\D появился то 
    LA достигает LA=1 не через 1 минуту а через 5 минут.
    а через 1 минуту он достигает всего 62-63% от того что должен (а остальные 40% надо ждать еще 4 мин)
а если процесс R\D исчез то оказалось что 
    LA(1min) падает до нуля за 4 минуты
    а за одну минуту он падает на ~60% ( а значит на оставшиеся 40% еще 3 минуты надо ждать)


это дает пиздецовый вывод - пусть комп имеет 1 цпу. и мы запустили процесс R или D 
которпый уже шарашит 1 минуту. тоесть система загружена на 100% уже одну минуту. тоесть у нее
за эту минуту по всем понятиям средняя загрузка  равна 1 но LA нам покажет всего навсего 0.62-0.63
тоесть LA показывает не среднюю загрузку а полную хрень имеющую какую связь с загрузкой
но она точно и близко не соотсветстует срденей. получается что если мы имеем LA(1min)=N
то как я понимаю чтобы узнать среднюю загрузку системы за последнюю минуту нужно сделать 
дополниельное мат вычисление 
    средняя реальная загрузка (за 1 последнюю минуту) = LA (1min) / 0.62 = N /0.62

тоесть например мы имеем что LA(1min) = 5
значит реальная средняя загрузка за последнюю минуту = 5 / 0.62 = 8
но! это верно только если за последнюю минуту нагрузка реально LA рос и рос и рос и рос
тоесть  это верно если в течение последней минуты какието появились новые процессы R и D
которые всю эту минуту работали. потому что если например у нас было скажем три процесса которые
работали и мы их вырубили то LA будет понижаться от 3 до 0 в течение минимум двух минут. тоесть
система будет уже две минуты работать полностью на холостом ходу а LA будет все еще высокий между 3 и 0.
таким образом LA он как высокоинерционное колесо если +1 новый процесс появилися и он раобтает и работает
то LA в конце концов через 5 минут прибавит +1. а если у нас процесс исчез то LA через минуты две
в конце концов убавит у себя 1. тоесть если нагрузка спала и не поднимается неколько минут то 
LA в конце концов упадет на ноль.  а если у нас повилось 3 новых процесса R\D то lA в конце концов
минут через пять станет LA(старое значение)+5  но это все требует большое время заведомо намного
большее чем одна минута если мы говорим про LA (1 min).  а уж как себя LA ведет если у нас процессы R\D 
то появляются то исчезают быстро в течение одной минуты то и говорить не приходится. 
Тоесть важно понять что то число которое показывает LA (1min) оно и близко не отражает среднее
число процессов R\D за последнюю минуту!!!! вот я говорю даже в самых простых случаях - в системе
за последнюю минуту все время работает +1 R\D процесс. что очевидно означатает что средняя
загрузка по процессам за последнюю минуту равна 1 ( при условии что до этого система вообще 
была idle). а LA нам покажет 0.62 
И обратная ситуация. система уже может стоять последнюю минуту вообще idle. тоесть средняя
загрузка по процессам равна очеивдно нулю. но LA будет показывать какую то ненулевое значение.
LA (1min) покажет среднее значние по процессам верное только если последние 5 минут нагрузка 
прибавилась и не менялась. или если последние 2 минуты нагрузка упала и неменялась. тоесть в очень
частном случае.  поэтому смотреь на LA (1min) видеть число и думать что это есть среднее число
процессов R\D за последнюю минуту это полная хрень это совершенно не так.  это быват так только 
в очень неольшом числе очень частных случаев. тоесть LA (1min) дает какоето представление
о числе процессов за последнее время но ничего конкретного в числах понять из LA нельзя!!!!!
я говорю корень состоит в том что LA меняется очень инерционно как маховик поэтому возможно 
более реалный физ смысл LA(1min) если он и есть то это средняя число процесов R\D но не за одну
минуту последнюю а за последние 5 минут. это будет гораздо более близко к истине!
я бы еще как сказал - если нагрузка начала расти то вначале LA прибавляет бодро свое 
значение но недостаточно бодро. в самом лучше случае он и то через минуту опаздывает на 40%
считай в два раза!  тоесть LA при увелчинеии нагрузки никак не может разогнаться до нужного
значения. а когда нагрузка падает никак не может замедлиться до нужного значения.
получается в случае повышения нагрузки среднее значене процессов за последнюю минуту
надо увеличивать в диапазоне от 1 до 1.67 тоесть реальное среднее = LA(1min)*k
где k это число которое лежит в диапазоне [1;1.67] но какое конкретно брать k из 
этого диапазона неизвестно и не узнать. тоесть мы видим что нагрузка растет 
и что LA(1min) = 5. значит в реальности среднее значение процеоссов R\D за последнюю
минуту лежит в диапазоне [5; 5*1.67] а более точно сказать невозможно.
тоже самое если мы видим что нагузка начала падать это значит что LA скручивается вниз 
недостаточно быстро и рельное среденее число процесов за последнюю минуту
лежит в диапазоне [0; LA*0.62]
тоесть если LA=5 и мы видим что нагузка падает то в реальности среднее за минуту = [0; 5*0.62]
тоесть оно где то здесь но точнее сказать невозможно. тоесть может быть это 3  может быть это 0
а может быть это чтото посредине. вот такой охуенный показатель LA(1min).
а если нагрузка меняется по более сложному закону ( вплане повышения нагрузки или понимжения)
то тогда вобще хер понятно как из LA можно хоть примерно получить реальное среднее значение.
Если обобщать если мы не хотим смотреь понижается нагрузка на систему или повышается
то эти две крайности можно обьединть  в  одну что среднее = [0; LA*1.67]
что оно лежит где то в этом дипазоне. но это же такой широкий диапазон что пиздец как это нам 
нихера не дает.
Единсвтенное что точно можно сказать что глядя на LA если он намного намного намного ниже
чем число цпу в системе то по цпу у нас система не страдает. скажем если у нас ядер 20
а LA=5, скажем 5*1.67=8 и получется что в 8 намного ментше что 20. и типа все окей.
но при этом ( LA =5 и ядер 20) очень даже запросто могут быть случаи когда все плный приздец. а
именно. у нас может быть 1-8 процессов которые ждут диск и имеют статус D. 
и что толку что у нас 20 ядер. это нихуя не играет роли. и система будет мега тормозить.
второй случай когда есть приложение монопоточное. оно грузит цпу на 1 тред. на одного ядро.
все. и пиздец. все тормозит  также. у нас может быть короткий пик пусть на 1-2 секунды на 40 процессов 
и в течение этого пика у нас тоже будет мегаторможение а LA(1мин) будет попрежнему 5. 
так что у нас даже когда LA относительно маленькое относиельно числа ядер все равно может
быть пиздец по перфомансу сервера!
если же приложение на сервере строго многопоточное и от диска не зависит то да если LA=5 
 а ядер 20 то тогда да. можно сказать что все окей с нагрузкой. прикидываешь сверху что 
 среднее лежит в диапазоне [0;  5*1.67] = [0;8] и понимаеш что за последнюю минуту
 средняя реаьная нагрузка были в дипазоне от нуля до 8. а это гораздо мнеьше чем 20.
 
 какая связь между средним числом  процессов  R\D и lA(5min) и LA(15 минут) я не тестировал.
 это надо отделно тестировать их связь с реальными цифрами.

вот еще пример. вот у нас ноутбук. с ssd диском. у него 4 реальных ядра. 
и 4 гипертрединг ядра. и LA(1min)=2.
что можно скзаать. положим что мы  в основном просто с хромом шаримся поэтому D процесов
просто небудет. остаются R процессы. берем диапзон сверху [0;2*1.67] = [0; 3.5]
гипетрединовые ядра сразу отбраываем ибо они шлак. значит у нас при 4 ядрах 
реальная средняя лежжит где то от нуля до 3.5 поэтому точно непонятно. либо все круто
либо все награни макс мощности. поэтому для этого нуотбука я бы скзаал что точно безопаный 
LA(1min) это 0.5-0.7  при таком LA можно не париться.

получется LA(5min) и LA(15min) это колеса (маховики) которые обладают еще большей инерцией.
их еще более тяжело раскруить а потом еще более тяжело погасить. 

я приступил к изучению  LA(5min)
я запустил нагрузку
через 5 минут он достиг 62% от реального числа R\D
а через 20.5-21  минуту он наконец достиг числа процессов  R\D

далее я убрал нагрузку и LA(5min) показал среднее число 
процессов через только 17.5-20 минут 

тогда ориентровочно ( я не проверял) LA(15min) это ~LA(45-60min)

 я щас поставлю экспеоимермент. я запущу 20 D процессов в течение 1 минуты.
а потом 4 минуты будет нулевая нагрузка. посмотрим какой LA(1min) он покажет через 5 минут.
в итоге через 6 минут LA(1min) показал ноль!

вобще этот lA это полная хуня. вот у нас нагрузка пошла вверх зашкаливает.
но сказать сколкьо она хуй скажешь. только через ммиуту она для LA(1min) достгнет всего 62%
а до этого времени что делать? как высиываеть на практкие? понятоно что если она будет
шарашить 1 минуту и мы ее подождлем то тогда над будет домножить на 1.67. а если она
до этого момент уже исчезнет? как тогда высчитывать?
иннерция у колеса своебразная- прибавляется lA быстро но до какогоо порога
а потом уже еле еле ползет до конца. и убавляется при исчезновааеннии нагрузки вначале быстро падает
до некотрого порога а потом падает еле еле. 
тоесть при скачке нагрузк и ее ударжании в первую минуту доходит до 62% а потом остальные 
4 минуты тащится до 100%. конечно после 5 минут значение соответвует среднему показаетелю
числа процессов за последнюю минуту. а если мы говорим про LA после первой минуты
то он будет показывать только 62% от среднего числа за последнюю минуту. так это надо еще 
минуту эту подождать. да еще чтоб нагрузка не исчезла. в итоге непонятно 
если я имею LA(1min) что он показывает прям щас? какой физ смысл имеет это число.
в вслучае увелчиеия нагрузк график LA представляет собой график логарифма.
а в случае падения перевурнутый логарифм.
получается если нагрузка подскакивает но держися мало то LA просто не успевает до нее разогнаться.
а если нагрузка падает но держится мало LA просто неуспевает до нее упасть

походу я понял как "работает" LA(1min) - вот у нас пошла нагрузка 20процессов.
после 30 секунд он берет 45% от 20 получает 9 и прибавляет к LA =LA0+9.
проходит еще 30 секунд он берет высчитывает 45% от 9 и получает 4 и прибавляет к 9 получаем
LA=(LA0+9)+ 4. если LA0=0 то LA=13
если при этом нагрузка спала то аолгоритм обратный. через 30 секунд высчиываем 45% от 13 получаем 5.85
и отнимаем от 13 получаем LA=13-5.85=7.15
если наргрузки по прежнему нет то через 30 секунд высчитвыаем 45% от 7.15 и отнимаем 
LA=7.15-45%*7.15=3.9
притаком алгоритме видно что если нагрузка держится то ее вклад с течением времени все меньше и меньше.
и тоже самое для сброшенной нагрузки - сброс нагрузки вначале приводит к бытсрому провалу. но чем
дольше нагрузки нет тем все меньше отимается от LA.

еще такой экспримент 10 процессов работали 1 минуту а потом нет. 
при этом получил вот такой LA
1m LA=6.30   2m LA=2.25  3m LA=0.73 4m LA=0.23 5m LA=0
из чего я родил такое эмпричиеское правило. если нагрузка пошла то 
в первую минуту LA вырастает на 63% от числа процессов а все последущие минуты растет на 63% 
от дельты приращения.
а если нагрузка спала то от текущего значения LA отнимается 63%

если нагрузка постоянная то lA в конечном итоге приходит к значению равному этому числу процессов.
для lA(1min) это через 5 минут. и дальше не растет.

механизм реально похож на маховик. если появляется новый крутящий момент то он на началном 
этапе приводит к крутому ускорению врашения. но оченб быстро перестает ускорять. 
а при уменшении силы вращения маховик прододжает вращаться по инерции какото время. на сразу 
останвливется.


в итоге я вывел такой эмприрической закон начинаем с lA=0
если у нас заработало N процессов то 
    после  первые 30 с +38% от N
    следущие      30 с +27% ot N
    следущие      30 с +11% ot N
    следущие      30 с +9%  ot N
    
вот прооисходит ускорения маховика.
а если у нас процессы пропали то маховик замеляется по закону
    каждые 30 с  LA  уменьшается до  37% от текущего значения
    
получается ускоряется маховик (LA) по одному закону а замедляется по другому.
вопрос как тогда это приравнять за какой период он типа находит среднее значение ?


 
если мы рассмотрим ситуациюкогда у нас идет только разгон LA 
и заглянем в таблицу

    после  первые 30 с +38% от N
    следущие      30 с +27% ot N
    следущие      30 с +11% ot N
    следущие      30 с +9%  ot N
 
то видно что в зависимости от  временной точки у нас LA показывает число процессов 
для совершенно разных времнных интервалов.
у нас по факту в каждой временной точе среднее число процессов = N 
оно не меняется. а согласно LA 

    в первые   30с   LA=0.38*N   Реальный средний K за 30с равен N  значит LA показывает среднее число 
процессов для интервала 30c/0.38=79с, тоесть эти 30с и 49с до этого.

    в следущие 30с   LA=0.65*N   Реальный средний K равен N за последние 60с
    а LA показывает среднее число 0.65N значит LA как бы его высчитал для другого промежутка
    а именно 60c/0.65=92с, тоесть эти 30с и 62с до этого.

    в следущие 30с   LA=0.76*N   Реальный средний K равен N за последние 90с
    а LA показывает среднее число 0.76N значит LA как бы его высчитал для другого промежутка
    а именно 90c/0.76=118с, тоесть эти 30с и 88с до этого.
    
насколько я понимаю в коцне концов через 5 минут LA=N и он будет показывать 
среднее для промежутка последних 5 минут. наконец LA покажет то что соответствует
дейтисвительности.

таким образом    LA показывает среднее число процессов соотвствующее дейсивтельнссти 
но  интервала усреднение времени все время разный в зависимости от точки во времени. 
это означает что интервал усредренеия времени все время разный и его невозоможно
узнать гляда на LA


wiki 
EWA[n+1] = A*p[n+1]+(1-A)*EWA[n],  0<A<1

B=1-A, A=1-B, 0<B<1

EWA[n+1] = EWA[n]*B+p[n+1]*(1-B)

LA(t) = LA(t-t0)*B+n(t)*(1-B)

если n(t)=0, LA(t) = LA(t-t0)*B, B=exp(-5/60)=0.92

LA(t)=LA(t-t0)*0.92



loadavg.c
EWA[n+1] = EWA[0]*p[n+1] + nr_active*(1 - p[n])

 
a[n] = a[0] * exp^n + nr_active * (1 - exp^n)
 
 
plot  "data.dat" using 1:2 title 'Column',  "data" using 1:3 title 'Beam'


 
 
ксатти вот статья где можно почиттаь более точно как этовсе высчитывается 
    ( https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html )
    

    
теперь я покажу файлы\программы которые я использовал чтобы протерстировать LA
и нарисовать графики

вот этот файл это программа которая при запуске создаст нам процесс со
статусом D

$ cat 30.c
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {

    pid_t pid = vfork();

    if (pid == 0) {
    sleep(5);
    _exit(0);
    }

      //printf("parent: I am exiting\n");

     return(0);
}


компилируем ее вот так
$ gcc -o 30.exe 30.c



следущая программа она создает в рандомно количестве процессы со статусом R (через stress)
и со статусом D (через 30.exe)
ее запускаем первой

$ cat 2.bash 
#!/bin/bash

# иницаидилизация
max_D=20   # макс число D процессов генерируемых за один промежуток времени
max_R=10   # макс число R процессов ...
time=50    # число промежутков времени
step=5     # длинна промежутка времени


for i in $(seq "$time")
do

    # запуск D процессов
    unset i; i=$(shuf -i 0-"$max_D"  -n 1)  # число D процессов

    if [[ "$i" -gt 0 ]]; then
	for i in $(seq $i); do 
	    ~/C/./30.exe & 
	done
    fi


    # запуск R процессов
    unset i; i=$(shuf -i 0-"$max_R"  -n 1)  # число cpu спайков

    if [[ "$i" -gt 0 ]]; then
	for i in $(seq $i); do 
	    a=$(shuf -i 1-"$step"  -n 1)  # длинна спайка
	    stress --cpu 1 --timeout "$a" 1>/dev/null &
	done
    fi

    sleep ""$step
done



вот эта программа  считывает реальный LA(load average) а также высчитывает 
его руками. также она высчитывает среднее число процессов за минуту (усредняет на интервале 
минута) и это все она ыводит на экран а также записывает в файла ./data
ее запускаем второй

$ cat 1.bash 
#!/bin/bash


# блок инициализации
k=13  # по скольким точкам усредняем
time=$((k*5))   # число промежутков времени
step=5    # длинна одного промежутка в секундах
e=$(awk -t '{print $1}' < /proc/loadavg)
t=0
t_array=();
p_array=();
LA_array=();
e_array=();



# препринт
printf "\nt-время\np-число R\D процессов\np_LA-реальный LA\nc_LA-расчетный LA \n\n"
printf "%3s | %4s | %5s | %5s | \n" "t" "p" "p_LA" "c_LA"      # p_LA реальный LA, c_LA расчетный LA
printf "%s\n" "----------------------------"




# основной блок вычислений
for i in $(seq $time)
  do 
    p=$(ps a -o stat | grep -E "R|D" | wc -l); p_array+=("$p")
    LA=$( awk -t '{print $1}' < /proc/loadavg | tr  -d "\n"); LA_array+=("$LA")
    [[ "$i" -gt 1 ]] &&  e=$( printf "%.2f" $( bc -l <<< "scale=2; $e*e(-5/60)+$p*(1-e(-5/60))" | tr "." "," ) | tr "," "." ); e_array+=("$e")

    printf "%3s | %4s | %5s | %5s | \n" "$t" "$p" "$LA" "$e"

    sleep "$step"
    t_array+=($t); let t+=("$step")
 done




# вычисление среднего арифетического
a_array=() # среднее арифметическое число процессов за одну минуту
for  (( c=0; c<"${#p_array[@]}"; c+="$k" )); do 
    a_sum=0

    for j in $(seq 0 1 "$(( k-1 ))"); do
	let a_sum=a_sum+"${p_array[c+j]}"
    done

    average=$( printf "%.2f" $( bc <<< "scale=2; $a_sum/$k" | tr "." "," ) | tr "," "." );

    for j in $(seq 0 1 "$(( k-1 ))"); do
        a_array+=($average)
    done

done




# вывод суммарной инфо на экран и в файл
printf "\n\nвывод суммарной инфо \n"
printf "\nt-время\np-число R\D процессов\np_LA-реальный LA\nc_LA-расчетный LA\na_array-среднее арифметическое \n\n"
printf "%3s | %4s | %5s | %5s | %8s |\n"     "t" "p" "p_LA" "c_LA" "a_array"      # p_LA реальный LA, c_LA расчетный LA a_a среднее арифметическое
printf "%s\n" "---------------------------------------"


[[ -f "./data" ]] && true > ./data
for  (( c=0; c<"${#p_array[*]}"; c++ )); do 
    printf "%3s | %4s | %5s | %5s | %8s | \n"      "${t_array[c]}" "${p_array[c]}"  "${LA_array[c]}" "${e_array[c]}" "${a_array[c]}"
    printf "%3s %4s %5s %5s %8s \n"      "${t_array[c]}" "${p_array[c]}"  "${LA_array[c]}" "${e_array[c]}" "${a_array[c]}" >>  ./data
done



когда эта программа закончиит работу то будет создан файл ./data
с точками. тогда запускаем gnuplot и риусем на основе 
этого файла график

$ gnuplot
> set xtic 10 
> set style line 12 lc rgb 'blue' lt 1 lw 2
> set grid xtics ytics mxtics mytics ls 12
> set grid
> plot  "data" using 1:2 title 'Processes number real' w linespoints lw 2,\
"data" using 1:3 title 'LA real' w linespoints lw 2,\
"data" using 1:4 title 'LA calc' w linespoints lw 2 ,\
"data" using 1:5 title 'Processes number average' w linespoints lw 2

в итоге у нас будет график на котором нарисовано 4 линии. с реальным LA, с расчетным LA
с средне арифметическим число процессов , число процессов снятых каждые 5 секунд



в этих файлах много полезного зашито.
кстати их можно найти в гите в docs/load-average папке




a1 = b*a0  + a[1] * (1 - b)
    
a2 = a1 * b + a[2] * (1 - b) =  ( b*a0  + a[1]*(1-b) )* b + a[2] * (1-b) = 
непонятная хуйня...

что такое EMA. 
у нас есть x1...xn. мы к ним присобачиваем коэффициеенты веса
w1...wn и высчяитываем вот такое

    EMA =  (w1*x1+w2*x2+...+wn*xn) / (w1+...+wn)
причем выбираем w1..wn такие что wn самый большой а w1 самый мелкий. 
w=w(n) выбираем так что оно убывает по экспненциальному закону.
тогда у нас дальние по вреени члены x имеют очень малый вес. а ближние
по времени члены имеют очень большой вес. (насколько большой? чему равен w1?)

а есть еще такая хуйня что берутся не все члены x начная с самого начала
а только последние по времни сколько то штук. это называется окно.
а у нас в LA как высчитывается ? с окном или со всеми членами ?




вот такое нашел.  непонимаю откуда они это взяли
From a mathematical viewpoint, the load average is calculated right from 
when the system started and decays exponentially. ( с этим  я согласен)
Thus technically, the load average shown for the 1st minute includes 63% of the load 
assessed in the last minute and 37% of the load assessed from the start of the system.
     

если LA(1min) всебе содержит на 63% чегото там за последнюю минуту а на 37% то что было до того.
это обьсяняет ту инерционность которую имеет LA. обясняет почему увеличение нагрузки
не приводит к быстрому увеличению LA. потому что тот хвост мелких значений до этого он
недает быстро увеличить LA.

если лиукс высиыватет LA учиывая  все R\D за весь аптайм. это прсто пиздц. нахуй это нужно
кому это в голову пришло???!?!?!?!!?!? зачем мне учитывать члены которые были месяц наазад ?!?!?!?!?!

далее эти сукии пишут что в la(15min) там 63% loaad от поседние 15 минут а осталное 37%
это за остальнео время. по поему это полная хуня. если бы la(15) содрежлата 67% от 15минут
то при поной нагрузке она бы росла бытсрее чем LA(1min) но этого нихуя не набоюдается

я щас отвлкусь в сторону и посмтрю на исходную формулу каноническую

EMA[t] = a*f[t] + (1-a)*EMA[t-1]

из нее вот что видно. положим a=0.05 тогда

    EMA[t] = (0.05)*f[t] + (0.95)*EMA[t-1]

при таком коэфициента у нас новый LA на 95% является перетаскиванием предыдущего LA!!!!
и только 5% идет вклад нового числа проессов! это так просто и так гениально видно!
и возьмем наоборот

    EMA[t] = (0.95)*f[t] + (0.05)*EMA[t-1]

в таком случае новый LA это на 95% результат текущего числа R|D процессов
и тольлко на 5% это старый хвост!!!

пока двинаю далее

EMA[t] = O*f[t] + (1-O)*EMA[t-1], O = константа

O=1-1/(e^(5/60))=1-e^(-1/12)

EMA[t] = (1-e^(-1/12))*f[t] + (e^(-1/12))*EMA[t-1]

1 1 1 1 1 1 1 1 1 1 1 1
n=12
p=0.9

w(i)=p^(n-i), w0=1
w1=p^(12-1)=p^11
w2=p^(12-2)=p^10
w3=p^9
..
w11=p^1
w12=1

EMA(1)=p^11+p^10+p^9+p^8+p^7+p^6+p^5+p^4+p^3+p^2+p^1+1
       ------------------------------------------------ = 1
       p^11+p^10+p^9+p^8+p^7+p^6+p^5+p^4+p^3+p^2+p^1+1

       
 1 1 1 1 1 1 1 1 1 1 1 2
 
 EMA(2)=p*EMA(1)+(1-p)*2=0.9+0.1*2=0.9+0.2=1.1=0.9*(1)+(0.1)*2=1.1
 








далее я нписал прогарму ктоаря показывает  как выглдят веса
и их ссмаау за минуту
из  чего видно что члены до 4 а то и 5ятой минуты вносят в вклад
в среднее. но никак не за  1 минуту!


$ cat wi.bash 
#!/bin/bash

sum=0; 
sum_array=();

for i in $(seq 0 1 60);  do 
    wi=$( bc -l <<< "scale=11; e(-$i/12)") 
    printf  "t=%-4s %-.2f \n"      "$(( i*5 ))"     $( tr "." "," <<< "$wi")
    sum=$(bc <<< "scale=11; $sum+$wi")
    [[ "$i" -gt  0   &&  $(( "$i" %  12 )) -eq 0  ]] &&  { printf  "минута %s\nsum=%.3f\n------\n"   "$(( i/12 ))" $( tr "." "," <<< "$sum" ) ; sum_array+=( "$sum" ); let sum=0; } 
done



megasumma=0; for i in ${sum_array[@]}; do  megasumma=$( bc <<< "scale=11; $megasumma + $i"); done

echo ""
for i in ${sum_array[@]}; do
    printf  "sum(i)=%.2f | %.2f%% \n"    "$( tr '.' ',' <<< $i )"    "$( bc <<< "scale=11; 100*$i/$megasumma" | tr  '.' ',' )"
done





$ ./wi.bash 
t=0    1,00 
t=5    0,92 
t=10   0,85 
t=15   0,78 
t=20   0,72 
t=25   0,66 
t=30   0,61 
t=35   0,56 
t=40   0,51 
t=45   0,47 
t=50   0,43 
t=55   0,40 
t=60   0,37 
минута 1      (через каждую минуту  w падает в e раз, тоесть в 3 раза почти)
sum=8,274
------
t=65   0,34 
t=70   0,31 
t=75   0,29 
t=80   0,26 
t=85   0,24 
t=90   0,22 
t=95   0,21 
t=100  0,19 
t=105  0,17 
t=110  0,16 
t=115  0,15 
t=120  0,14 
минута 2
sum=2,676
------
t=125  0,12 
t=130  0,11 
t=135  0,11 
t=140  0,10 
t=145  0,09 
t=150  0,08 
t=155  0,08 
t=160  0,07 
t=165  0,06 
t=170  0,06 
t=175  0,05 
t=180  0,05 
минута 3
sum=0,984
------
t=185  0,05 
t=190  0,04 
t=195  0,04 
t=200  0,04 
t=205  0,03 
t=210  0,03 
t=215  0,03 
t=220  0,03 
t=225  0,02 
t=230  0,02 
t=235  0,02 
t=240  0,02 
минута 4
sum=0,362
------
t=245  0,02 
t=250  0,02 
t=255  0,01 
t=260  0,01 
t=265  0,01 
t=270  0,01 
t=275  0,01 
t=280  0,01 
t=285  0,01 
t=290  0,01 
t=295  0,01 
t=300  0,01 
минута 5
sum=0,133
------

sum(i)=8,27 | 66,57% 
sum(i)=2,68 | 21,53% 
sum(i)=0,98 | 7,92% 
sum(i)=0,36 | 2,91% 
sum(i)=0,13 | 1,07% 


0,08(8,27*A+2,68*B+0,98*C+0,36*D+0,13*E)=N
0.67*A+0.21*B+0.076*C+0.029*D+0.010*E=N
но это верно при улсовии что внутри одной минуты нагрузка постоянна!
но это же не так в общем случае

прроверяю

  ( 1 1 1 1 1 1 1 1 1 1 1000 ) LA=80,71
  ( 1000 1 1 1 1 1 1 1 1 1 1 ) LA=32,65

тоеть даже в рамках одной минуты у нас сосвем разный LA
и даже в рамка х одной минут не пуолчится выкрчтится усреднением.

полчтееатеся елиси нагрзуа внутри минуты сильно пргыает вобщен ничо нельзя скаать.
а если она ровная внутри хотя бы каждой минуты то 

    0.67*A+0.21*B+0.078*C+0.029*D+0.010*E=N
    
по  факту это LA через 5 минут. и если A=b=c=D=E то N должен быть равен A
проверяем A*(0.67+0.21+0.078+0.029+0.010)=A*0.997=N
сходится

если A это нагрузка за последнюю минуту. и мы же ее знаем потому что мы ее прям щас видим.
вобщем непонятно...
непонято то что если у нас нагрузка скачет как хочет то LA намнихера недает.

LA(1min)<= 0.63 означает что цпу либо 
    работал на среднем r=0.95 
    и его      busy time=95% времени от минуты
    по  паттерну ( 1 1 1 1 1 1 1 1 1 1 0 )
    тоесть  у нас средний r не превышает единицу
    цпу работает почти все время без отдыха.
    простаивающих процессов нет
    
    либо в самом начале этой минуты у нас 
    была двухкратная перегрузка (если в среднем за минуту усреднять)
    но цпу работал всего 5% от времени
    тесть средний r=2 cpu busy time=5% и событие произошло давно в самом начале минуты
    паттерн ( 21  0 0 0 0 0 0 0 0 0 0 )
    я говорю что перегрузка состиавила два  а не 21 потому что 21/12 сэмплов ~2
    вот этот 21 можно перераспределить
    
    есть еще паттерн
    ( 0  0 0 0 0 0 0 0 0 0 8 ) тоже дает LA=0.63
    но этот патерн нас устрвиает потому что у него средний r за минуту = 8/12 <1 
    
    получается при LA<= 0.63  у нас  busy time может доходить до 100% что плохо
    но либо средний r<=1 а значит в среднем нет процессов ждущих
    либо он может доходить до среднео 2хкратного превышения но эта нагрузка носит спорадический
    характер. то есть бузи тайм не 100%. тоесть при это LA возоможны перегрузки но они 
    кратковременные
    еще пример такого паттерна
    (10 9 1 0 0 0 0 0 0 0 0 0 ), LA=0.62, перегрузка двухкратная r=2
    в принципе  в такого рода перегрузке нет проблемы. главное что их ядро успевает
    отстрелить за один два сэмпла. хотя.. если бы ядро цпубыло быстрее то оно бы
    еще бытстрее отстреливло эти таски и очередь была бы короче. непонятнр..
    в люом случае понято что при таком паттерне эти таски короткие что цпу успевает
    их отсрелить быстро. 
    
    по идее если мы видим бльше значение r в сэмплах но при это у нас продолжают
    оставаться слоты в busy time то по идее особой проблемы нет. так как короткие тасики
    успевают отсреливаться в один слот или в несколько слотов. нам главное чтобы
    цпу не забивался тасками так чтобы у нас слотов временных не осталось. 
    тоесть по идее нужно смотреть lA вкупе с busy time. если у нас процессы только 
    с R (без D) и у нас есть еще тайм слоты пустые то тогда это значит что цпу еще 
    свободно все это ворочает. 
    мне кажается повторюсь что LA нужно смотреть вместе с busy time. 
    если мы зашли на комп а там lA=100 то нужен график как развиатслся LA и ккак при этом 
    разивался busy time. может так быть что на компе на 1с запустилось 100 коротких процессов. 
    и потом цпу все время был idle. ну и значит проблемы никакой нет.
    
    
кстати 
    $ taskset -c 4 ./vasya.exe
позволяет запускать прогу на оопределеном ядре


кстати /proc/$pid/wchan
там указан сисколл который щас выполянется процессом. а если никакой
сисколл не выполняется то там идет  просто число 0

/proc/$pid/status
там  и число тредов, и umask процесса. 
и сколько раз он был выдалвен добровоьно или приудительно с цпу

кстати в man proc
есть инфо о статусах процесса 

  (3) state  %c
                        One of the following characters, indicating process state:

                        R  Running

                        S  Sleeping in an interruptible wait

                        D  Waiting in uninterruptible disk sleep

                        Z  Zombie

                        T  Stopped (on a signal) or (before Linux 2.6.33) trace stopped

                        t  Tracing stop (Linux 2.6.33 onward)

                        W  Paging (only before Linux 2.6.0)

                        X  Dead (from Linux 2.6.0 onward)

                        x  Dead (Linux 2.6.33 to 3.13 only)

                        K  Wakekill (Linux 2.6.33 to 3.13 only)

                        W  Waking (Linux 2.6.33 to 3.13 only)

                        P  Parked (Linux 3.9 to 3.13 only)

вау! а вобщето еще есть I статус


еще прикол

    $ a="1 2"
    $ printf "%s \n" $a
    1 
    2 

    $ printf "%s \n" "$a"
    1 2 

тоесть баш перед вызвовром принтф подставлявем вместо $a ее значение получаем

    printf "%s \n" 1 2

поэтому у нас в %s улетает на 1+2 а только 1.
а еслимы ставим "$a" то баш подставляет 1 2 перед вызовром printf 
но при вызывое exec он их сует в один аргумент!!! охиреть!!!

команда котоар смотрит сколько тиков цпу процесс сожрал. 

$ while true; do printf "%s\r" "$(awk '{print $14 " " $15}' < stat)";   done
121 1244


первое число это работа в юзер спейсе второе число это работа в кернле сппейсе.


я запустил такую прогу

$ cat 122.c
#include <stdio.h>
#include <time.h>
#include<unistd.h>

long timediff(clock_t t1, clock_t t2) {
    long elapsed;
    elapsed = ((double)t2 - t1) / CLOCKS_PER_SEC * 1000;
    return elapsed;
}

int main(void) {
    clock_t t1, t2;
    int i;
    long elapsed;


while(1) {
    long settime = 50;   
    t1 = clock();
    for (i=0; i < 10000000000; i++) {
	t2 = clock();
	elapsed = timediff(t1, t2);
	if (elapsed>=settime)
	     {
		//printf("set time reached\n"); 
        	break;}

    }

    sleep(5);


     // printf("elapsed: %ld ms\n", elapsed); 

}

    return 0;
}


что она делает. она крутит цикл ~50ms
а потом засыпает на 5 секунд

далее смотрю ее статистику работы
отлваливаю момент когда у нее статус R
и еще печаатаю ее тики на цпу   в юзер спейсе и кернел спейсе

$ while true;do  ((  $(ps -p "$(pidof 122.exe)" -o stat  |  grep -E "R|R+"; echo $?)   ))  ||  printf "%s | SUCCESS | %s\n" "$(date)" "$(awk '{print $14 " " $15}' < /proc/$(pidof 122.exe)/stat)"; done
Вс янв  7 18:27:37 +06 2024 | SUCCESS | 498 1557
Вс янв  7 18:27:43 +06 2024 | SUCCESS | 498 1563
Вс янв  7 18:27:48 +06 2024 | SUCCESS | 500 1566
Вс янв  7 18:27:53 +06 2024 | SUCCESS | 502 1569
Вс янв  7 18:27:58 +06 2024 | SUCCESS | 503 1572
Вс янв  7 18:28:03 +06 2024 | SUCCESS | 505 1575
Вс янв  7 18:28:08 +06 2024 | SUCCESS | 506 1579


видно что она перходи  в состояние R каждые 5 сккунд.
все осталне времы она спит. в top она висит но так как она работает ультра короткое время
то top ее перфоманас показыает как 0,0% тоесть она жрет милииминиум цпу. но не ноль конечно.

ксати  ps ее статус не R и S а R+ и S+ это значит что она в терминале рабоает в фореграунед груп.
в итоге + значит что прога запущена с терминала.

а вот я потавил чтобы прога работала 5мс.
и вот что мы видим

$ while true;do  ((  $(ps -p "$(pidof 122.exe)" -o stat  |  grep -E "R|R+"; echo $?)   ))  ||  printf "%s | SUCCESS | %s\n" "$(date)" "$(awk '{print $14 " " $15}' < /proc/$(pidof 122.exe)/stat)"; done


Вс янв  7 18:57:58 +06 2024 | SUCCESS | 0 1
Вс янв  7 18:58:08 +06 2024 | SUCCESS | 0 2
Вс янв  7 18:58:18 +06 2024 | SUCCESS | 0 3
Вс янв  7 18:58:53 +06 2024 | SUCCESS | 2 5
Вс янв  7 18:59:43 +06 2024 | SUCCESS | 3 9
Вс янв  7 19:00:23 +06 2024 | SUCCESS | 4 11
Вс янв  7 19:01:03 +06 2024 | SUCCESS | 5 15
Вс янв  7 19:01:18 +06 2024 | SUCCESS | 5 16
Вс янв  7 19:02:38 +06 2024 | SUCCESS | 6 23
Вс янв  7 19:04:43 +06 2024 | SUCCESS | 8 34
Вс янв  7 19:05:03 +06 2024 | SUCCESS | 9 36

тоесть поидее когда она цикл 5мс крутит это чисто юзер спейс.
и это должно занимать не более одного тика (тик это тайм слайс котоырй обычно выделяется ядром
для одного кванта рабты процесса после котрого процесс обычно выдалвылиывается из цпу)

и так как обычно тайм слайм по длинне это 

значит я прочитал что длинна слаайса это джиффи и он равен 1/CONFIG_HZ

$ grep CONFIG_HZ < ./config-5.4.0-91-generic  | grep -v '#'
CONFIG_HZ_250=y
CONFIG_HZ=250

1/250=0.004c = 4мс

значит надо прогу сократить до 3мс чтобы она всегда сама успевала доскакать до sleep
котоый уже сам отдаст упавление шедулеру обратно


я подпраил прогу на 3мс

$ while true; do grep "volunt"   <  /proc/$(pidof 122.exe)/status; sleep 1; echo "" ;done
voluntary_ctxt_switches:	63
nonvoluntary_ctxt_switches:	8

прога стала в осовном успевать сама отдавать слайс шедулеру

смотрю сколько джиффи он же clock ticks процесс провел внутри цпу 
в юзер спейсе и kernel space

]$ while true; do printf "%s\r" "$(awk '{print $14 " " $15}' < /proc/$(pidof 122.exe)/stat)";   done
5 13
6 17
6 18

не очен понятно. у меня цикл работает 3мс. а потом на 5с прога идеет в слип
по идее каждые 5с у нее должен вырастать юзер тик. 
потому что цикл запускаетя заново.
однако почему то в статистике это не так.
тик приьавлется только через 4 цикла.

$ while true; do printf "%s %s\n" "$(date)" "$(awk '{print "   " $14 " " $15}' < /proc/$(pidof 122.exe)/stat)"; sleep 5;   done
Вс янв  7 19:43:36 +06 2024    14 39
Вс янв  7 19:43:41 +06 2024    14 39
Вс янв  7 19:43:46 +06 2024    14 40
Вс янв  7 19:43:51 +06 2024    14 40
Вс янв  7 19:43:56 +06 2024    15 40
Вс янв  7 19:44:01 +06 2024    15 40
Вс янв  7 19:44:06 +06 2024    15 40


далее я переделао прогу она работает 3мс и 3с потом спит.
так вот понятно что такую прогу очень трудно отловить в списке ппроцессов коогда она 
переодит в состояние R. потому что это всего навсего окно 3мс. поробуй попади в это окно.
поэтому вот этот резулаьтат понятен

$ while true;do  ((  $(ps -p "$(pidof 122.exe)" -o stat  |  grep -E "R|R+"; echo $?)   ))  ||  printf "%s | SUCCESS | %s\n" "$(date)" "$(awk '{print $14 " " $15}' < /proc/$(pidof 122.exe)/stat)"; done
Вс янв  7 19:51:32 +06 2024 | SUCCESS | 1 2
Вс янв  7 19:51:53 +06 2024 | SUCCESS | 1 4
Вс янв  7 19:52:02 +06 2024 | SUCCESS | 1 5

тоесть это не значит что процесс имеет статус R только раз в 20 секунд. нет. просто его хер 
отловишь в этом статусе в списке процессов!!!

получается если у нас процесс работает маленькими квантами. то его хрен заметит loadaverage!
и топ тоже его не заметит. потому что если процесс скажем работает 10-50мс а потом спит скажем 5с 
то он никогда почти и никак не будет попадать ни в топ ни в поле данных для load average.

а этом плане cpu busy time гораздо более чесный таймер потому что - время цпу разделена на тики.если
цпу обрабатывает код юзер или кернел то ядро об этом заносит инфо в /proc/timer_list
а если цпу неработает никкой код в тик то это тоже запмывается туда. поэтому также как каждлая деньга
в банке также и каждый тик цпу он записыеся куда был потарчен. поэтом бузи тайи посчитать очень легко.
надо просуммировать все тики и подедить на общий размер времени. все тики цпу они расписаны.
поэтому по бузи тайму отчетность точная. правда эта отечентность касается цпу а не процессов.
тоесть это другая сущнность. но мы в конечном итоге процсы сравниваем с цпу все равно.
итак бузитайм это точная характерстика. 

если мы возьмем одтделрый проецесс то у него тоже есть точная статикиа /proc/pid/stat*\
там указано скольк тиков он отрабтал на цпу. это тоже точаня статкистика.


статисткиа комнды top она соверщенно убогая в том плане что мы видим картину
в момент времени а потом чрез дельту времени. а что просиходи на компе между дельтами
мы не знаем. это выпадает. а нам кажется что если щас топ показал что у нас 2 процесса имеет R
и через 5секунда у нас 1 процесс имеет R то значит что на компе якобы ничего больше не 
проиходит. это охуенная иллюзия.
вот в чем прикол.  так вот loadaverage сеэмплиует даннные тоже по 5с. поэтмоу он 
изначално рабтает с очень грубым непрврадовдобным полем процессов R

кстати вот эта штука
$ cat  /proc/loadavg 
0.50 0.27 0.22 1/1288 18448

ее последий столбик покаывзает какой было число у последнего сосзданного процесса.
можно запустить эту штуку в мониторинг и будет видно сколько за 1 или 5 секунд 
создается новых процессов. а ведь каждлый созднный процесс это же +1r
это же должно менять статистику лоад аверадж.

но  я гворю если эти процессы отрабатывабт сверх быстро то они хотя и были созданы в системе
но они в статитику load average врядли попадут. они невидимки. а они же имеют прямое отношение
к лоад аверадж!  если эти процесы сверх быстрые то они дают малый вклад в бузи тайм хотя там 
они точно будут учтены! но они напряумую должны бы были увиыватья в лоад аверадж и вляеть
на его показание. таким образом корокие прцоессы они невидимы для лоад аверадж хотя они к нему
имеют проямое отноеше. но эти процессы фиусируются в бузи тайм. 

Я БЫ сказал что бузи тайм являтся у компа важнейшей первейщей характеритстикой. в самом лучшем случае
с разбикой по ядрам. вдруг у на какйто сингтред процесс завис. 

а вот если бузи тайм маленькй то можно и на счет числа процессов со статусом R п
потому что те что со статусом D те коечно как раз надо смотреть независимо от бузи итайма цпу.
помне аолгоритм такой. 

число процссов D надо смотреть всегда
число проецссов R надо смотерьт если полный бузи тайм ядра 95%
отделно надо следить чтобы отделные ядра не уходили в 95% бузи тайм (проблемные синго тред
процессы)

еслли процесс работает 3мс из 5с то веротянсть того что его замтеиитит LA составляет
3/(1000*5)= 3/5000 = 0.06%

вот я запустил 20 процесов каждый работает 3мс и спит 5с.
путь они все на одном ядре крутятся. тогда в сумме они жрут 60мс на интервале 5с
это +1.2% к бузитайму.


вот я начал их ловить  со статусом R


$ while true;do  [[ a=$(pidof 122.exe | xargs -L1 -I% ps -p % -o stat | grep -E "R|R+" | wc -l) -gt 0 ]] &&  printf "%s | re=%s |%s\n" "$(date)" "$a" "SUCCESS "; done
Вс янв  7 20:36:54 +06 2024 | re=1 |SUCCESS 
Вс янв  7 20:36:59 +06 2024 | re=1 |SUCCESS 
Вс янв  7 20:36:59 +06 2024 | re=1 |SUCCESS 
Вс янв  7 20:37:04 +06 2024 | re=2 |SUCCESS 
Вс янв  7 20:37:09 +06 2024 | re=1 |SUCCESS 
Вс янв  7 20:37:14 +06 2024 | re=1 |SUCCESS 
Вс янв  7 20:37:19 +06 2024 | re=1 |SUCCESS 


видно что они спорадически отлавливаются. по одной две штуки.
так это я их монитору так часто как позволяет баш.

а вот как они ловятя если их мониторить чрез 5с как это делает LA
тоесть я дбавляю чтобы искать только каждые 5 секунд. и система из вобще не 
встречает оно и понятно. вероятность столкновения 60/5000= 1%
а между прочим у проца украли 1% его времни. но никто не заметил.

запустил еще 40 процессов. иттого уже 60 штук. это 180мс они выжирают из 5с. это 3.6% от бузи тайм цпу
значит мой скрипт наконце начал их встречать 


Вс янв  7 20:41:44 +06 2024 | re=1 |SUCCESS 
Вс янв  7 20:42:25 +06 2024 | re=1 |SUCCESS 

это r+1 на двух сэмплах из 12ти. причем однократно. LA этого даже не почуствует

запустил еще +60 процесов. и того их уже 120 штук на одном ядре
это 7% от бузи тайма ядра.

система их поймала 3 раза за минуту. словил r=1
и на этом все закончилось.

увеличл вдвое. теперь их 240 штук. это  14% . 
чрез nmon  я вижу что юзер спейс цпу занят на 4-6% . почему меньше незнаю

опять же это мало что дало. vmstat с сэмплом 5с ниего невилит и мой скрипт тоже 
словил только один раз за минуту два сэмпла.
в итоге он стал ловить по 1 сэмплу за 5с  это 1\12 процесса в минуту
а между прочим ядро уже занято на 14%=4 юзер спес+11 кернел спейс. однако
я говорю что монитооринг через 5с ничго пракически не видит. то есть комп нагружен
но это через процессы невидно. видно только чрез бузи тайм

еще 60 запстил. итого уже 300 штук
еще поднял на 100 итого 400 штук

довел до 600 штук
еще довел до 800  штук это уже цпу пашет на 50% бузи тайм
еще довел до 1100 штук

витоге оно начало ловиться
--
Вс янв  7 21:28:19 +06 2024 | re=1 |SUCCESS 
Вс янв  7 21:28:24 +06 2024 | re=2 |SUCCESS 
Вс янв  7 21:28:30 +06 2024 | re=1 |SUCCESS 
Вс янв  7 21:28:35 +06 2024 | re=1 |SUCCESS 
--
Вс янв  7 21:28:45 +06 2024 | re=3 |SUCCESS 
Вс янв  7 21:28:50 +06 2024 | re=1 |SUCCESS 
Вс янв  7 21:28:55 +06 2024 | re=1 |SUCCESS 
--
--
Вс янв  7 21:29:11 +06 2024 | re=1 |SUCCESS 
Вс янв  7 21:29:16 +06 2024 | re=2 |SUCCESS 
Вс янв  7 21:29:21 +06 2024 | re=1 |SUCCESS 
--
Вс янв  7 21:29:32 +06 2024 | re=1 |SUCCESS 
Вс янв  7 21:29:37 +06 2024 | re=1 |SUCCESS 
--
Вс янв  7 21:29:47 +06 2024 | re=1 |SUCCESS 
Вс янв  7 21:29:52 +06 2024 | re=1 |SUCCESS 
Вс янв  7 21:29:57 +06 2024 | re=2 |SUCCESS 
Вс янв  7 21:30:03 +06 2024 | re=2 |SUCCESS 
--
--



в итоге получается почти что в среднем за 1 минуту он стабильно
ловит по сэмплам  r=+1

значит LA должен доползти до LA0+1. 

при том что цпу у меня уже работает на 67% по бузи тайм.
тоесть что мы имеем -у нас в системе работает огромадная куча процессов.
просто они коротккие так что их трудно словить но цпу занят по самую  крышу.
значит  у нас эта 1100 штук процесов просыпается каждые 5 секунд другое дело что 
они были запущены пачками. по 100-200 штук. будем считать что в течение 5 секунд в разное время
просыпается по ккрайней мере 100 процессов. значит в минуту просыпается 100*12 = 1200 процессов.
но ни топ ни vmstat ни лоад аверадж этого невидят. получается по отчетности vmstat, top, loadaverage
система в полном шоколаде работает на холостом ходу. а по факту она хуячит . и цпу бузи тайм
у нас 67%.

сэмплиорвание по 5с подразумевает что если в момент t0 ничего не происходит то и в отрезке
[t0-2.5; t0+2.5] тоже ничего не присходит. а это полная хуня.

чтобы процесс попал в сэмплирование надо чтобы у него гаратрованная минимальная длина работы была  
5 секунд если это одноразовое срабатываение (отработал и сдох) тогда он попадет в сэплирование
тоесть процесс дожен работаьт от 5сеундндо и дольше чтобы ему гарантрованно попдатаь
в сэмплиорвание. иначе то попал то не попал.
если попал в сэмплиорвание то система счиатет что процесс автомтом работает 5с. тоесть что 
слева от t0 он отработал 2.5с  и справ от t0 он отработал 2.5с

   +++++
*****|*****|

все процссы которые не попали в сэмпливароние считаются не существующиими 
и в лоад аверадж они тоже не попадают. ни в vmstat никуда. ни в топ.
они сидят все в /proc/ но чтобы понять как часто они переходят в R это надо этот proc
супер часто сканировать както. супер часто и супер быстро.

lA он вобще смешной. он получается с одной стороны пропускает кучу реальо работащих про
цессов. тоесть они есть а для него их нет. а с другой стороны на систему уже нагрузки нет
а LA продолжает показывать нагрузку. ну хотя понятно LA показывает нагрузку не за счейчас.
а за среднее с учетом прошлого. поэтому он грубо гвоорят ниже чем это есть сейчас
и выше чем это есть сейчас очень часто показыает. потмоу что он не про сейчас. 
он в общем то про то как было ДО этого. а не как сейчас. да.. 
если был 0 а шас +100. то он учитывая интервал усредненеия покажет меньше чем 100.
если щас 0 а было 100 то он покажет боольше чем 0 потому что в прошлом было чтото. 
тоесть LA показывает как было ДО сейчас. а не то как это еесть сейчас. 


итак LA работает только с длинными процессами длинной как минуим 5с. это всего 
навсего подмножество от реального множества процессов. если какойто процесс влетит 
рандомно в сэмпл то ну его влияние сразу начнет пропадать на следущем сэмпле.
потому что каждый следущий интервал LA (через 5сек) она падает на 8% от своей высоты вниз. и ее обратно
затаскивает наверх только наличие нагрузки. если нагрузка была одноразовая то ее влияние быстро
исчезнет на графике. правда если при этом новые рандомные влезут чушки то они ее поднимут.
нов в целом LA это постянно падающая кривая котрую нужно постоянно обратно затаскивать наверх.
она на следущем сэмпле взмывает наверх на 0.08 от каждого r=1 который попал в сэмпл.
потмоу что 
    LA(n)=LA(n-1)*0.92  + 0.08 r(t) = LA(n-1) - 0.08 * LA(n-1) + 0.08*r(t))

поэтому она со дной стороны постоянно падает. с другой стороны ее постоянно подпирают обратно.

возараащаюсб к основоному вопросу о  том что LA работает не с реалным множеством процессов.
а только  с его субмножеством. только с длинными процессами котоыре отработали минимум 5с "непрерывно"

поэтому LA (1) работает только с длинными процессами. предсотавляет информацию только про них.
а что это за инфомрация. это типа средне число процессов длинных которое работало на компе 
до этого момента. если щас top показывает что R процесов 15 а LA =5 это значит что 
наггрузка на систему возросла. если щас top показывает 4 а lA показывает 10 значит 
нагрузка на систему упала. LA показывает ну типа некую изваршенную среднюю за последние 5 минут. 
причем делает некую приоритизацию на lA за последнюю минуту. ей веса больше. 

значит еще раз отреальной ситуации к lA. 
есть процесы которые просыпаются и получают статус R( про D  ядаже молчу) и это происходит
постоянно в любой момент времени. LA просывается 1 раз в 5 минут и читает текущее число R процессов.
получается что LA работает только с субмножество значений r(t). выбирая из них 
субвыборку (r(k*t0), k=1,2,3.....
таким образом  все что находится вне этой выборки для LA несуществует. тоесть это уже офигенное 
искажение от реальной ситуации. значит сэмплируя по 5 с LA как бы считает что значение полученное
это адекватная средняя за 5с. этакий столбик шириной 5с. далее находится взвешенное среднее
от этих сэмплов.

    (w1*x1+w2*x2+....wn*x) / (w1+...+wn)

    w(n)=p*w(n-1), p=e(-1/12) для LA(1min), w(0)=1
    
    w1+w2+...wn=12.5 при любом большом n
    
    
я посчитал w1...wn  и видно что они вобщеем то нулевого значения
после 5-ой минуты ну если конечно все что до пятой минуты не давало LA=1000000
тоесть все что после 5-ый минуты можно вобщем то игнорировать. оно не влияет.

итак LA берет особую выборку от исходных процессов. и далее используя веса
находит некое среднее. веса приводят к тому что все сэмплы позднее чем 5 минут. тоесть
сэмплы старше чем 60 штук  уже не играют роли.  таким образом LA пказывает усредение 
за последение 5 минут. усреднение идет по 60-ти сэмплам. каждый сэмпл берется 
с весом. таким макааром сэмплыт которые ближе к текущему моменту они имеют бОльший вес
а сэмплы котоыре дальше от текущего момент имеют меньший вес. 

мы уже сказали что текущая моедль она как бы предлагает что число процессов внутри сэмпла 5 секундного 
считается консатнтой. так вот следуий этап это поведение системы в пределах одной минуты.
если число r(n) внутри минуты остатеся постоянным то  вклад каждой минуты 
в конечный  LA выглядит вот так

        0.010*E + 0.029*D + 0.078*C + 0.21*B + 0.67*A=LA
        
                    ---------->  timeline
        
тоесть E=r(n)=const на пятой минуте , D r(n)=const2 четвертая минута, C r(n)=const3 третья минута
Br(n)=const4 это вторая минута , Ar(n)=const5 это первая минута от теекущего момента.

причем еще важный момент что A мы знаем потому что LA(n)
а A=f(n). тоесть из этой формулы мы знаем LA(n) он у нас на экране 
в топ нарислван и мы знаем A=f(n) это то число R которе мы щас видим в топ.

таким образом

       ( 0.010*E + 0.029*D + 0.078*C + 0.21*B ) = LA - 0.67*A
       
справа мы все знаем. а слева это стоит на момент времени LA(t0-4min) 
где t0 - это текущий момент.  тоесть если у нас щас LA=10
и текущее значение r(n)=5 то LA(t0-1минута назад)=10-0,67*5=6.65
тоесть мы узнали какой LA был одну минут назад. вопрос тлоько в том а что это нам дает ?
какой физ смысл это дает нам? типа это срденее число процессов за 2-ю + 3-ю + 4-ю минуты ?
опять же скажу что это верно только в случае если за последнюю минуту нагрузка была 
строго константа. 

это можно получить еще с другой формулы которая интеративная

когда p такое большое то согласно формуле
        LA(n)= p*LA(n-1) + (1-p)*r(n) ~=  0.92*LA(n-1) + 0.08*r(n)
это общая формула верная при любых нагрузках r(n)
если мы вощьмем  что r(n)=const для послених 12-ти n и просуммиируем то мы полуич мтоже самое
что 

        LA(-1 минуту назад )= ~=  LA(n) - 0.67*Const

        
    а вот если нарука последнюю минуту прыгала то все то мы можем узнать это то что 
    
    LA (-5  секунда назал ) = LA(n) - 0.08*f(n)

    
мне нравится коментарциий который дали разработчкиия ядра можт даже тот же самый торвальдс проо lA

$ curl -s https://raw.githubusercontent.com/torvalds/linux/v4.8/kernel/sched/loadavg.c | head -n 7
/*
 * kernel/sched/loadavg.c
 *
 * This file contains the magic bits required to compute the global loadavg
 * figure. Its a silly number but people think its important. We go through
 * great pains to make it work on big machines and tickless kernels.
 */
 
 
 тут вдруг у мен пршло сомпние - а как часто ядро собирает f(n) может чаще чем
 5 минут? 
 
 но врдоде нет
 
 So, uptime is sampled every 5 seconds which is the linux kernel’s 
 intrinsic timebase for updating the load average calculations.
 отсьда 
    ( https://www.fortra.com/resources/guides/unix-load-average-part-1-how-it-works)
    
LA он не про загрузку цпу. он про число процессов готовых к R. 
cсвязано ли это с загрузкой цпу на предыдущем этапе? и да и нет.
но и неважно. важно чтобы в кждый момент цпу хватало.
прцоецесс   переходит из S в R потому что  либо:
    - произошло жеелезное событиее (нажали кнопку, поилетел сетеовй пакет) ( назависит от нагрузки на цпу)
    - другой процесс чтот досчитал (зависит от скоости цпу)
    - ббольше людей пришло на сайт ( внешнее событие)
    - если цпу слабый то приходящее событие в момент t0 не успевает разгрести его цпу
    и тогда на момент t0+1 у нас помимо процессов R за счет внешниз событий остались
    процессы от предудушего события
    
таким макаром число процессов R в момент t0 показывает изначальную природу загрузки
а загрузка цпу (bisy time) показывает нагрузку на исполниетеле , тоесть это вторичная
нагрузка.

тоесть есть конверейн по которму еду разобрраные роботы - это перчиная нагрузка это 
число процессов R, а есть человек который берет с конверейра роотов и крутит им мозги.
это вторичная загрузка. это загрузка цпу. конвейре это перчиная нагрузка на систему
а загрузка человека это наколько успешно исполнитель справляется с этой нагрузкой.

интересно.... никогда об этом не думал..

LA(n)=0.92*y(n-1)+0.08*f(n) = 1*y(n-1)-0.08*y(n-1)+0.08*f=1*y(n-1)+0.08*(f(n)-y(n-1))

получается что новый LA поползет ли он вниз или полезет наверх зависит 
от того если новый f(n) больше или меньше по высоте чем старый LA(n-1)
пример

    LA(n-1)=5, f(n)=10. раз f(n) > LA(n-1) значт LA(n) полезет наверх
    LA(n)=5+0,08*(10-5)= 5+delta полез наверх
    
    LA(n-1)=5, f(n)=0. раз f(n) < LA(n-1) значт LA(n) полезет вниз
    LA(n)=5+0,08*(0-5)= 5-delta полез вниз
    
это как раз обьясняет почум ели у нас LA < f новый и f дежртся монтотнно то lA будет 
до него ползти пока не дползет

получается такая картина  . LA это как бутоо маховик а LA его скорость вращения.
f(n) это к нему прилагается разгонябщий другой маховик тоже со скоростью. если прикладвыемвый
маховик более быстрый то он разгоняет наш маховик. а если он более медленный то он тормозит
наш махоивик. урвоень торможения разговна зависит от инерции. коотоаря задаетя чреез (1-p)
где p=0.92

пример

наш LA=10 вращается со скростю 10м\с к нему прикалываюи диск со скростю 12 м\с
тогда ноая скрость нашего маховика будет 10+0.08*(12-10)= 10+1.6
0.08 это прям реально инерция. когда приклывают более быстрый диск тоему приходится стараться 
чтобы разогнаь нашдиск. но из за инерции более бстрый диск не может разогнат нащ диск до своей 
скорости 12 м\с а может только на часть. до 10+1.6. 
в физике это бььсянется тем что тому диску нужно времся. а времени у нас нет. достаточного.
получется 0.08 это степень инецри нашего диска. либо это кратковременность времени на котрый
два диска соединяют.

а когда прикоывают более медленный. то он тормозит наш диск. но не может затормозить до велчиины
своей скорости. поэтом наш диск тормозится в сооовесвтии с инецрие то есть. если наш диск
12 м\с а их 10м\с то их диск хочет затомрзить на ш диск до 10 м\с но из а инеции и едостточтности времнеи
он тморзмт его тольк на (12-10)*0.08

получается что график одинаково растет и падает по оси Y при условии что между 
LA(n-1) и fa(n) одинакоая разнциа

la=10 fa=12  la(n+1)=10+(12-10)*0.08=10+2*0.08

la=12 fa=10  la(n+1)=12+(10-12)*0,08=12-2*0.08

именно поэтому когда LA приближается к f(n)=const и между ними уменьшаяется разница
то замедлется процесс прилиения LA к fa

итак LA(n-1) все время пытается догнать f(n). если f(n) сидит выше чем LA(n-1)
то LA(n) подрастает

если f(n) стал ниже чем LA(n-1)  то la(n-1) вслед за ним в догонку опускается

получается каждый новый LA это резултат сгибания старого LA на велиину 
пропоцриалную разнице между  старым LA и новым f(n)

тоесть новый f(n) гнет стрвй LA то в одну сторону то в другую.
если он выше то гнет его наверх ели он ниже то гнет его вниз.
получается там где граик la(n) как бутто получается следщиум образом - если f(n) сверху
то это занчит что как бутто он ударил снизу наверх по LA(n) и согнул его носом верх
если f(n) ниже чем la(n) то он бьет по la(n) и прогибает его вниз.
тоесть  на гараифке f(n) нам неважно где там пики идут внищ или вверх.
нам важно в каком месте f(n) выше графика la(n) а  в каком ниже. вот что важно
вот что влияет на la(n)

для тех n где f(n) > la(n) (выше) там f выталкивает гнет  la наверх
для тех n где f(n) <la(n) (ниже) там f бьет гнет  la вниз

сила удара f сила прогиба la зависит отразницы между f(n) и la(n-1)

la порождлается из f(n). наоборот помоему неверно. чисто по графику
из формулы тоже самое.
    
    LA(n)=0.92*y(n-1)+0.08*f(n)
    
поэтму обратная задача какая то нереальная. как из la поолучить fn
по крайней мере ни при таком коэфиценте 0.08 при fn.
также я уже занчю что ema он la был придуман как сглаживающая функция для аргументовой
фугкции. тоесть есть исходаня высокочастотная функция a(n)
и мы хотим найти функцию ее сглаживающую и это ema(n). 
поэтму помемупытаться оплучить из сгалживающй функции исходную это лаха какаято.
тем более при 0.08 кофэицинте.
поэтому физ счмылс EMA это сглаживание. как минум это значение у нее точно есть
может есть и другие. там мужик писал про время разрядки кондентсатора.


====

EMA это фильтр котоырй пытается вырезать флуктуации.
1min это выбор p такой что через 1 мин w(t0+1min) становится wn таким что w(t0+1min)/w(t0)=e(-1)
тоесть в момент t0 у нас есть некотоырй w1*x1
проходит время и у нас наступет момент t0+1min тогда наш w1*x1 сдвигается и становистя w(t0+1min)*x(t0+1min)

было w1*x1*w2*x2+......wn*xn

      ^
      |
      следим за ним
      
стало w1*x1+w2*x2+....w(t0+1min)*x(t0+1min)+....wnxn
                             
                             ^
                             |
                             вот он теперь здесь
                        
так вот согдасно формуле w(n)=w(n-1)*p

мы побирам так p чтобы w(t0+1min)/w1=1/e(1)

как частное следсив еесли нагрущка стла равна нулю то через 1 мин значениея LA упадет в e(1) раз.



с одной стооны EMA пытается среди стохатичских данных выявить тренд
из дергающихся данных флукутирующих выявитьтренд вокруг которого все дераегтся
выделить нулевую гармонику. несущую частоту




3 5 1 = 3

3 3 3 =3

0.5*1 + 0.5^2*5+0.5^3*3=0.5(1+0.5*5+0.25*3)=0.5*(0.25+0.75)=0.5

0.5*3+0.5^2*3+0.5^3*3=0.5(3+0.5*3+0.25*3)=0.5*3(1+0.5+0.25)=1.5*(1.75)=5.25

    
если у нас summa(wi*xn) то посдатвлять вместо xn его среднее x_sr нельзя


сренне арифметчиеское это  кода все w(n)=1 
    1*x1 + 1*x2 + 1*x3+...+1*xn
    -----------------------------  = ср арифм
            summa (wi)
            
        
 вто время как LA придает индиыидуалные w(n) 
     w1*x1 + w2*x2 + w3*x3+...+1*xn
    -----------------------------  = LA
            summa (wi)
    
    
    w(n)=p*w(n-1)
    p=0.92
    при том что summa(wi)=12.5
    
    
    модифиируужю
    
     w1*x1 + w2*x2 + w3*x3+...+w(n-1)*x(n-1)
    ----------------------------------------  + 0.08*x(n) = LA
            12.5
    
    
    
средняя арифм еще вопрос ка считать. есть точка t0 от нее как отчитываьб. 
влево вправо (tn-0.5m, tn+0.5) или (tn-1min; tn)

как я пнима мы счииываем ср арифс для отрезка (tn-1min; tn)
так вот оно же в формуле LA выгоядит как


     1*x1 + 1*x2 + 1*x3+...+1*x(1min)
    ----------------------------------------  = ср арифм для точки x(n)
            12.5
    
    
    
втоже время реально эта хрень в LA считатся по другой формуле


     w1*x1 + w2*x2 + w3*x3+...+w(1min)*x(min)
    ------------------------------------------------  + ... = LA
              12.5
    
    
одно в другое нкиак не прверращается. поэтому график LA никак не может состветсвать 
гарфику среднего арифстетичсткго!


откуда взялась LA. 
дело в том что нам не всегда нужно чтобы все члены ряда имели один вес.

это анаалог взвещенной среднй с определнной длинной окна. 
в этом ввещенном ряду коэфиыиценты таковы что есть даже физ смысл
физ ссмысл такой то мы хотим выделить первую гармонику в высокочастотсном сигнале.

по факту если мы имеем щас LA то это аналогично если бы до этого 5 минут 
работал с нуля сигнал мощностью LA. 


чтотакое арифм среденее. мы находим площадь фигуры состояющую из столбиков.
и потом мы ищем высотку прямоугльника с той же площадью. и его вытсота это и есть
арифм среденее.

что такое ввешенное среднее. мы находим площаль тех же столбиков. 
только у нас при это выоста столюика не исходная а скорективраонная .
а в итоге мы нахддим площаь и потом тоже ищем выосоту пряоугльника тойже площади.
 
                                                  1  2  3 4  5  6  7  8    9  10  11  12
    1 2  3  4 5  6  7  8   9  10  11   12  13 |  14 15 16 17 18 19 20 21   22 23  24  25
1m  0 1  2  3 4  5  6  7   8   9  10   11  12 |  13 14 15 16 17 18 19 20   21 22  23  24
    0 5 10 15 20 25 30 35  40  45 50   55  60 |  65 70 75 80 85 90 95 100 105 110 115 120 

   
   
   
как работает EMA..
при p=0.92 как я считал выше wi таковы что фактически все члены wi которые левее чем 5 минут влево
от текущего момента они этим коэфициентами превращаются в ноль. поэтому работа идет 
с r(t) втееие посоедних 5-ти минут.
далее ema как бы совими коэифицнтами режет реальне аплтуды своими коэфициантамми  и вычисляет среднее арифм
от изуродванным показтелей. потому что wi*xi= 1*(wi*x) то есть походеж на форулу арифм среденего
но с изуродванным коэфициантами. поэтому LA никак не может быть средним ни для последней 1 минуты
ни для последних 5 минут. эта вещь сама всебе. ее никак по среднее аарифметиеское назагнать.

еще у нас есть кратоквременные процессы которе не поадают в выборку r(t) для LA!
поэтому ла еможет показывать правду !

LA это картина сколоько людей приходит в жэк.
а загрузка цпу это картина загруженности  домкома жэка.

LA это сколько людей пришло в магазин
загрузка цпу это загрузка кассирш на кассе


параметр 1 мин 
о чем он
    - 1min это скорость падения коэфициентов пдаает  wi через минуту упадет в 1\e
    - связанное с этим же если дать прямой импульс то через 1мин он дотстиненет 63% тоесть A*e(-1)

    
    
ema смысла позволяет ловить тренд в акцимях например. 
уловить поворот.




хочу кое что поясниьб. только для этого я будут нумеровать xn не с хвоста с головы. тогда



вот полная форума точная для любого случая

ema = (0.92)^k*xn + .... + 1*x0
      ---------------------------
                 12.5
                 
                 


                 
выделим из нее первум минуту
и еще я 12.5 перенсесу влево чтобы удонее было заапсывать


 ema = (0.92)^k*xn + .... + [ (0.92)^12* x12 +...+ (0.92)^2* x1 + 1* x0 ]
            ------------         ----------------------------------------------
                12.5                              12 .5


в квадратный скобках то как считвается эта хрень для первой минуты.
сооветсвенно если мы воьмем форулу среденего арфим дляпервой минуты

    1* x12 + 1* x11 + ... + 1* x1
   -----------------------------------
                 12

тоесть ответа на вопос как бы так можно связать среднее арфим за 1 ппосле минутту от r(t)
и ema(t) = ответ никак если r(t) это некая рандоманя фунция
            
                 
если мы теперь сравним то что в квадртаной скобке и нашу форм для сред арифм
и попытаемя наайти связь межуду ними. тоесть между тем как ведет себя среднее арифм на
инервале 1 минута с r(t) и  то как себя велет LA(t) на промежутке 1 минута.
между ними мы не омжет найти никкой связи. пэтому это нверно что ema покаывзает средене арифм
за 1 посл миниту.


есл же  r(t)=const на протяжении 1 минуты. то  мы полуич флоулму
    LA(t)=LA(t-1min)*0.37 + 0.67* f(t)
    
ноэто сверелнено частрный случай



LA и f они >=0 получается когда f максимвльный то LA(-1мин) минимальный
а когда f минималны то LA(1-mib) макс.  посморим

LA(-1min)=0
0*0.37+0.67*f=LA
f=(LA/0.67)~=1.49*LA

например la=10 , f=14.9

f=0
LA(-1min)+0=lA
LA(-1,min)=lA

получаетс что f лежит в  дипаазоне    0 =< f  <= (1.49)LA

тоесть  если у нас есть lA и мы считаем что f у нас бы л потсоянный за после минуиуту. то 
зная LA щас мы можем знать в каком диапазоне мог лежит это f
пусть LA=0.31 тогда

            0<=  f <= 0.46
            
            
    если у ннас цпу имеет 2 ядра то для него безоапсные LA это 
    
    f <=2
    
    2=1.49*LA
    LA= 1.34
    
    если LA поднимается выше чем 1.34 это потенциально может означать что
слишкмо много r ролджается в системе для этого цпу. он их не успевает обабраывтаь. и часть из
них стоит в очереди

но опяьт же эта вся оцентка держится на полной хуйне о том что нагрузка за послленюю минуту была 
константа. а это  хуйня.

более того это еще хуйня и потому что LA захвается лишь малую толку r(t) а значит даже елси LA~0
можно так устроить r(t) что цпу будет загруен на90%и будет куча r стоящиз  в чреели 
а lA будет низкий. так что этот lA это хуйня полная.

коефирцент 1min,5min,15min 
какую роль играет.

если r(t)=const  то  формула

 LA(t)=LA(t-1min)*0.37 + 0.67* f(t)
   
   будет иметь дурнеи коэфициенты.
   
   
также  это дает то что при lA(0)=0 и f=const  у нас LA дорастет до f через разное время.
для LA(1min)  это 5мин.  для других lA это другое.

тажке этот коефр влияет на фоурлму

LA(n)=LA(n-1)*0.92+ 0,08 *f(n)

зедесь тоже удут доугие коэфициенты.


в формуле w1x1+wn*xn
          ------------   этот параметр  вляет на график  w=w(n)
          summan (wi)
      
потому что w(n)=0.92*w(n-1)
      


а это вляиет вот на что. если у нас f(t)=const 
то LA уменьшится либо увелчится в 0.92 раза через 1 минуту.
      
соовтетено для LA(5min) он при f=const уввлитиячсатся\уменьшается  в 0.94 раза через 5 минут.

теость 1min\5min\15min влияет и на время и на велчичну коснатныты.

в lA(1min) вкоалад новго f(n) идет с кооэфи всего 8%
в(la5min) вклад нового f(n) идет 2%
в(la15min) вклад нового f(n) идет 0.5%


кофицинты в формуле wi*xi


потом что summa (wi)= (1-w^n)/(1-w) ~ 1/(1-w) при больших n

для la=1min
$ bc -l <<< "scale=5; 1/( 1-e(-5/(1*60) ) )"
12.50625
длф la=5min
$ bc -l <<< "scale=5; 1/( 1-e(-5/(5*60) ) )"
60.49606
для la=15min
$ bc -l <<< "scale=5; 1/( 1-e(-5/(15*60) ) )"
180.50541

подставлявю наверх в деноминатор
получаю




для lA(1min)=    (0.9^n)xn  ... + (0.9^2)x2 +  (0.92^1)x1  + (1)*x0
                ---------------------------------------------------
                                     12,5
                                     
                                     
для lA(5min)=    (0.94^n)xn  ... + (0.94^2)x2 +  (0.94^1)x1  + (1)*x0
                ---------------------------------------------------
                                     60.5

                                     
для lA(15min)=    (0.994^n)xn  ... + (0.994^2)x2 +  (0.994^1)x1  + (1)*x0
                ---------------------------------------------------
                                     180.5
       
       
                                     
полуается для одног и того же x(n)=f=f(n) распределения 
у нас за счет коэфициантов исходная фукция ужимается более бысто и чудовищно когда
мы идем налево по времени тоесть  все боольше и больше роль играет только первый член 
условно говоря. а отсльыне вобще нихера роли не играют но даже и первы член делится все на боольшее
число. таким образом в la(15min) супер главную роль играет только первые члены всего ряда. 
а остальыне вобще низера никкой ролий.  но даже из перых членов берут только чуть чуть. выжиая 
из f(n) только его супер низкаочасттную составляющую

в La(1min) члены слева тоже играют роль. и сам x0 тоже играет более заметную роль. 
тоесть LA(1min) будет расти быстрее и меняься более живее от f(n)
la(15min) бдт расти супер междленно и менсять будет очень неохотно.

la(15min) выдаелет из  f(n) только очень низкочатстонюу составляюую
а la(1min) захыватывает и более высокочатсноые гармникни

что я бы сказал если r(n)  очень выскочастотный то можно ориенится на lA(1min)
если сигнал мало частотный то можно ориентирватся  и на LA(15min)
кстаи чем менен высокочасттный сигнал тем показания LA(1min) будет совдать с LA(15min)

$ uptime
 16:47:22 up 89 days, 18:37,  4 users,  load average: 0,13, 0,14, 0,16
 
 можно взять какойто сигнал f(n) 
 посчттать длля него руками wi*xi/summa (wi) и сравнить как силно они будут отливаться.
 при разной степени прыжков сигнала
 
 
 
 
 
пусть у нас  r(t) за предыдшую минут был 

r(t)= ( 0(0c) 0(5c) 0(10c)..... 10(60c))

средняя за минуту =10/12=0.83

а LA будет равен 0.8

потому что исходя из формула 
LA(n)=LA(n-1)*0,37+0.63*r(n)=0*0.92+0,08*10= 0.8

если полагать что сигнал был равномерным то по моей оценке сверху
                  0 =< r(t) <= (0.8*1.49)=2,23
                  
вот у меня оценка новая появилась что среднее r за минуту  и lA(1min) 
свзяаны вот так
    r_s(1min) <= 1.49*LA(1min)
    

у нас есть  постоянынй сигнал f(t)=const в тчение 1 минуты и  унас есть L(0) и L(60)
я нашел оценку что 
                           0 =< f =<  1.49 L(60)
                           
    а тперт надо сравнить  LA от прямого сигнала который явлется средним 
    и LA от реальной f(t)
    
вот у нас есть провзволтный сигнал в тчееие минуты. и от него есть средняя.
на основе средней можно посмтрить миллион сигналов, с этой средней. но с точки зрения LA
самый сильный сигнал это сигнал в виде 

    ( 0 0 0 0 0 0 0 0  0 0  r_s)
    
где r_s это средняя от оригинального сигнала.
от такого сигнала LA будет максимальным

пусть La(0) точно равен 0.
задача. есть  r среднее. на интверале 1 мин. како флрмы дожен ыть сигнал 
чтобы он макс поднял LA. 

( 1 1 1 1 1 1 1 1 1 1 1 1 ) LA = 0.63
( 0 0 0 0 0 0 0 0 0 0 0 12) LA = 0.96

r_s=1
равномерый сигнал даст LA = 0.63*(r_s)=0.63
( 1 1 1 1 1 1 1 1 1 1 1 1 ) LA = 0.63


пиковый сигнал даст LA=0.08(r_s*12)=12*0.08=0.96
( 0 0 0 0 0 0 0 0 0 0 0 12) LA = 0.96

а  вот еще интересно
La(0)=100

( 1 1 1 1 1 1 1 1 1 1 1 1 ) LA = 40.59
( 0 0 0 0 0 0 0 0 0 0 0 12) LA = 37.75
 
интерсно получается что LA если покызвает число то оно показывает число r
которое бы было средним на интервале 1 минута и форма сигнала в теение минуты была бы по форме
и если бы до этой минуты LA(0) был равен нулю.

( 0 0 0 0 0 0 0 0 0 0 0 12*r_s)


действтльно для такой формы сигнала r_s=12*r_s/12
а его LA будет равен
L(60)=0+0.08*12*r_s=0.96*r_s ~= r_s

получаем мы полуими один lA через 1 мин при lA(0)=0 
и вот таки патернах

( A  A  A A A A A A A A A A )  LA=0.63*A


( 0 0 0 0 0 0 0 0 0 0 0 B) LA = (B/12) = B* (5/60)

B/12=0.63*A

B=0.63*12*A


B = e(-1)*12*A



( A  A A A A A A A A A A )   | r_srednee=A | LA=A*0.63   
    
(0 0 0 0  0 0 0 0  0 0 0 B)  | r_sr=B/13   | LA=0.08*B


делаем чтобы r_sr одног было равно r_sr другого
A=B/13
если A=1 то B=13

( 13 0 0 0   0 0 0 0   0 0 0 0    0 ) | LA=0.42 
(  1 1 1 1   1 1 1 1   1 1 1 1    1 ) | LA=0.63   
(  0 0 0 0   0 0 0 0   0 0 0 0   13 ) | LA=1.04


тоесть средняя одинаковая. но LA разный.



у всех у этих сигналов оодраинковая r_srednayaay = 1
тоесть я утверждаю что если есть r_sredntya на интврвлае 1 минуиаю
то максимвльный LA можно выжать вот из эттоо сигнала


( 0 0 0 0 0 0 0 0 0 0 0 13) LA  = 1.04


итак если есть  средний r_s то из такого среднего сигнала масксимльный LA который
можно выжать будет вот при такой форме сигнала

( 0 0 0 0 0 0 0 0 0 0 0 Q ) 
где Q=13*r_s
при этом его LA =1.04*(r_s)
это все верно при lA(0)=0

получается если у нас есть r_s для интервала 1мин который имеет любую форму.
то максимльный LA котоырй он может породить сигнал LA в пределах 
                           0.42*rs  <  LA   <= 1.04*rs

получается что если мы видим LA то какоу бы ни был сигнал по форме он порожждает LA 
в промежутке
                   0.42*rs  <  LA   <= 1.04*rs
важно то что мы имеем связь между LA и средним от сигнала.
едиснвтенное мы незнаем куда попал LA
значит если мы имеем из практики LA то средняя от сигнала колбелебся в пределах 
если это ниэний LA то  0.42*rs=LA, rs=LA/0.42=2.38LA
если это верний LA то 1.04*rs=lA, rs=LA/1.04=0.96LA
значит rs лежит в пределах

                  0.96LA  =< rs =<  2.38*LA    (1)
                если округлить то
                rs=[LA;2.38LA]

а если мы точно занем что форма синала была равномерная то 
                             rs = 1.49LA       (2)
что конено же поадает в интервал формулы 1.
ВНИМАНИЕ! это все верно при условии что и LA(-1min)=0  !!
а ели LA(-1min)<>0 это надо отдельно думать

самая большая ошибка вычисления rs на оснвое lA это в случае 
когда набор сэмплов отностельно текущего момента вот такой формы

( 13 0 0 0   0 0 0 0   0 0 0 0    0 ) | LA=0.42 | rs=1, LA/rs=0.42 ==> 
                rs=LA/0.42=2.38*LA
если LA=1.04 например то rs=2.47

ноесли для LA=1.04 сигнал был воттакой ( а мы это не можем выяснить)
( 0 0 0 0 0 0 0 0 0 0 0 13) LA  = 1.04
то по нашей формуле мы берем же с запасом rs=2.47
а по факту он был rs=1 тоесть мы промахнулись в 2.5 раза.

вот еше пример
( 13 0 0 0 0 0 0 0 0 0 0 13) LA  = (13+13*e(-1))/12.5=1.42 | r_sr по факту=26/13=2
выиляем прикидочное r_s а основе LA
    1.42*2.38=3.38
    3.38/2=1.69 ошибка в 1.7 раз.
    
можно конечно брать по формуле rs = 1.49LA
считая что это редкий случай когда у нас вперди нули а только сзади чтото стоит. 
тогда rs=1.42*1.49=2.11 
2.11/2=1.05  , ошибка 5%

тоеесть если брать по формлуе rs=2.38*lA то это мы перстраховаыеся считая что кажый раз
у нас паттерн вида


( 13 0 0 0   0 0 0 0   0 0 0 0    0 ) | LA=0.42 |rs=1 фактический| rs_расчетныйй=LA*2.38


напомню два другх паттерна
(  1 1 1 1   1 1 1 1   1 1 1 1    1 ) | LA=0.63  |rs=1  фаткчисчйи | rs_расчктный=LA*1.5
(  0 0 0 0   0 0 0 0   0 0 0 0   13 ) | LA=1.04  | rs=1 фактичеи| rs_расчетный=LA


а вот еще ример

( 13 1 0 3 0  10 0 7 0  11 5 0 13 )  LA=3.41 | rs_факт=4.85
если мы считаем по формуле r_s=2.38*lA=8.12  (очень бошая ошибка)
если считваем по форуле r_s=1.49*LA=5.08 
это очень хороо согласуется с 4.85

я все больше приожжу к выводу что надо rs выситывать по формуле
        
            rs=LA*1.49
            
тогда для двухядераного безопасный LA < 1.34
      для етрыехядеранго это       LA < 2.68

но опять же это хйня. потому что у нас просто может быть куча скоростельных процессов
ттпа 
 0 15 0 32 0 16 0 11 , у нас будет выскойи LA(1min). и выскойи средний r_s типа 5
 но это хуйня потому что главное что бузи тайм маленький. а просто куча коротких процессов.
дело в том что процессы могут быть короткие и дллинные. если они короткие то нам похеру.
потому что они в очереди не стоят а быстро отсредивают. а если они длинные то да - то они стоят 
в очереди. если есть свободыне тайм слоты в плане бузти тайма то LA(1min) выскойи как бы похуй получается.
надо смотреть на бузи тайм. есдитам полно слотов свбодных .то похеру на LA(1min).

в этом плане я думаю надо перходит к la(5min) и la(15min) они наверно от них больше толку
в  этом плане.оини  я думаю уже боольше будут кореливроват с бузи тайоммо.



еще пример
v=( 13 0 0 0 0  0 0 0 0  0 0 0 1 ) LA=0.46  | rs_реальное=1.07
считаем  rs=0.46*1.49=0.69 отличается существенно от 1.07 в пороцентах

ошибка в расчете rs будет тем больше когда на хвосте стоит xn очень большие 
по сравнению с тем что стоит на месте x0 потому что большие xn на хвосте серьезно 
увеличивают средний фактический rs  а LA по факту вобще от этого хвоста не растет. тоесть 

так что строго говоря rs лежит внутри отрезка [0<0.96LA<1.49LA<2.38LA]
какой хош коэфициент для расчета такой и бери
если загрузка более менее ровная без дырок и провалов то 1.49LA

еще LA похожи на как уже говорил на три жернова которрые имеют разную инерцию.
и их раскручивают  процессы.чем больше процееесов тем они быстрее крутятся. 1min
самый маленький и самый легкий. 15min самый большой. его хрен раскрутишь но и хрен 
остановишь. 
1min у него нагрузка (при ее остуствии) спадает в 3 раза каждую минуту..
у 15мин нагрзука спадет  в 3 раза каждые 15 минут. 




t   | r      | ema    | ema_it |  la_p    | ema_5min | ema_15min |
0   | 0      | 0.00   | 0.00   |  undef   | 0.00     | 0.00      |
5   | 13     | 0.00   | 1.04   |  undef   | 0.21     | 0.07      |
10  | 1      | 0.00   | 1.04   |  undef   | 0.23     | 0.08      |
15  | 0      | 0.00   | 0.95   |  undef   | 0.22     | 0.08      |
20  | 3      | 0.00   | 1.12   |  undef   | 0.27     | 0.09      |
25  | 0      | 0.00   | 1.03   |  undef   | 0.27     | 0.09      |
30  | 10     | 0.00   | 1.75   |  undef   | 0.43     | 0.15      |
35  | 0      | 0.00   | 1.61   |  undef   | 0.42     | 0.15      |
40  | 7      | 0.00   | 2.04   |  undef   | 0.53     | 0.18      |
45  | 0      | 0.00   | 1.87   |  undef   | 0.52     | 0.18      |
50  | 11     | 0.00   | 2.60   |  undef   | 0.69     | 0.24      |
55  | 5      | 0.00   | 2.80   |  undef   | 0.76     | 0.27      |
60  | 0      | 0.00   | 2.57   |  undef   | 0.75     | 0.27      |
^минута 0
------
t   | r      | ema    | ema_it |  la_p    | ema_5min | ema_15min |
65  | 13     | 0.00   | 3.41   |  undef   | 0.95     | 0.34      |

^^^
|||
!!!(разобрться с 12 -13 точек в ema.bash!!!!))  <=====!!!!
$$$$$$$$$$$$$$$$$$$$$$$$
                            
получается что сигнал можно представть как сумму = несущая (возможно это средняя арифм) +
+ паразитный сигнал. 

за 1 минуту EMA приближается на 67* от расстояние которое есть между ней 
и несущей и при этом также получает +8% от амлитуды паразитного сигнала.
мы не знаем несущую и не знаем аплитуду паразитного сигнала.


9 - (10 13 13 12 10)

5*n  =2*pi
---
400

n=(2*pi)*400/5 = 480с период = 8 минут

2pi*k=13

k=2pi/13

2*pi*12*k=2*ppi



c((5/60)*(2*3.14)*$j), j=0..12 за 1 минуту , это период = 1 минута

я померял если сигнал имеет  период 2 минуты то  у него амлитуда падает в "e" раз на выходе

в трединге 0.08 соотвстует тому что это по их мнмнеию EMA для 26 дней. тоесть 26 точек.
через 26 точек при прямом сигнале ema достигает 0.83-0.84 от исходного сигнала
так как у меня 13 точек это одн минута то понятия терейдкров наша la(1min) это la за две минуты.

la(1min) так сделана что через 1 минуту данные которые поступили 1 минуту назад в формуле
 w1*x1+w2*x2...  теряет вес в 3 раза тоесть в "e" раз" по сравннеию когда эта же точка 
 была в положении "момент прям щас".
  тоесть  если у нас есть "момент щас" и есть цеоячкака данных от щас до минус бесконечнсоти
  w1*x1+ w2*x2 +w3*x3....
  то все точки что лежат левее одной минуты они имеют вес меньше минимум в e раз (30% от исходной амплиутуды) 
  и меньше.
  также я почитал что все что лежит левее 5минут имеет вес 0.4% от освего исходного веса.
  и детсивтелно какой бы у нас ни был LA если мы пустим прямой сигнал то через 5 минут
  LA станет ему равно на 99%
  тоесть с одной сторны EMA считает все значения от начала и до минус бесконечости
  но по факту дальше пятой минуты назад нелезет.
  
  
  в линуксе есть время на которое программе выделяется слайс времени. если она 
  добровольно не отдает цпу то через время джиффи срабатывает таймер интерапт 
  и просыпаетая щедулер и забирает у процесса цпу. время джиффи равно 1секунда поделить 
  на ядерную переменную HZ. чемуона равна можно найти в в /boot/config
  в ней указано сколько раз в минуту срабаывает этот джиффи.
  у меня это равно 250
  HZ=250
  значит  в секунду 250 раз просыпаетя интеррапт таймер (хотя щас же тиклес ядра которые 
  просто так не прсываются если холостой ход я имею ввду). это получается каждые 4мс.
  и когда он просывается он прибаляет +1 джиффи где то там внутри. я думаю где то в /proc/
  можно посмотреть
  
  
  синус с T=60с наш фильтр гасит на 84%.
  синус с T=30с наш фильтр гасит на 92%.
  при чем сдвига фазы для таких волн не происходит на выходе в отличие от 
  длинных волн где она происоди!
  
  
  также   часатота сэмплирования 5с. это значит что мы этим сеплированием можем снимать точки 
  с графика у которго период T >= 10-15с
  
  наколко я понял low pass
  filtere -  унего 
  сдвиг фазы это фунд явление.
  
  
  u=(2*A/pi) summa (An)
  
  (-1)^m * cos(2pi*(2m+1)*x/L)/(2m+1)
  
  ====
  
  
  a =10
  p=100
  
  max=a+0.08*p
  min=a-0.08*p
  
j=0  jj= 0 1 2 3 4 5 7 8 9 10 11 12   
j=1  jj+(12*j+1)

0+0 1 2 3 4 5 6 7 8  9 10 11 12+0

0+12 1+1 2 3 4 5 6 7 8  9 10 11 12+12 = 12 .. 24

0+24 1 2 3 4 5 6 7 8  9 10 11 12+24= 24 36

  
0 1 2 3 4 5 6 7 8 9 10 11 12    j=1
                              0+13 1 2 3 4 5 6 7 8 9 10 11 12+13   j=2
                                                                  0+26 1 2 3 4 5 6 7 8 9 10 11 12+26  j=3
                                                                  
                                                                  
                              
                              

аксимоы:
осциляции(апилитуда) на коротких T гораздо выше чем на длинных T.
осциялции имеют частоту не больше чем 1/5с
EMA работает так что чем больше T тем больше фазовый сдвиг !

особенность  - если граик r(t) негладки а имеет верт  ступень. то 
EMA неуспевает и на графике будет треуголник 63% после 1 минуты. а не кквартадная ступенька
(этот случай надо думать отдельно)

прикол в том что ema не толкьо уменьшает аплиутду у синусоид даже у 
синусоид с длинным T но и  смещает фазу
поэтому по EMA вобще то трудно восстанвить r(t) для длинных волн.
в этом плане график средней аривметической выглядит гораздо выгоднее
опэтому граифие средней аоирифм и ema не совпдаает. потмоу что ema сдвинута по фазе
и имеет умегьшенную амплитуду

частоты T=5с T=10с мы исключаем потому что на этих частотах у нас
мы не можем сигнал полноценно сэмплировать
так что это базовый ассампшн что на компе нет частот T<=10. мы так полагаем.
иначе мы не можем их нормально сэмплировать


T=20м. сдвигфазы +1м вправо (фаза сдвинута)
T=40м. сдвигфазы +1м вправо (фаза сдвинута)
сдвиг впраов означает что графикк LA показывает данные в точке не за текущее время 
а за -1 мин назад
    
LA(1min) времено сдвига лаг (фазвый шифт) (запазываение) = 1 мин.
и самый херовый фильтр от помех
тоесть интегрирует (фильтрует) он быстро но есть смысл в нем только если помехи слабые

LA не про среднее - он про вырезание нищкочатсногго сигнала в каше из смеси низкчасттотног
с выскочастсностным.

я так порнимаю что LA 1min его можно юзать только если у нас низкочастный сигнал имеет
очень маленькую помеху по амплитуде. иначе результат каща. 



получается вот еще какой момент - у нас la(1min)  имеет фаза шифт 1мин.
ноееть еще такой момент что через 5 минут у нас сжкаем прямоуголльнлый импусль дорастает 
до полноценной высоты. и вообще для синусоиды ее значение повтоярется через T интервал. 
возникает вопрос - а можно ли пользоваться граификом la в точке считая что это значение через 5 минут 
или T минут назад? 
ответ нет. потому что есьи сигнал исхощный состоит из одной синусоиды. то ее значеение повтоярется 
каждые 5 минут только дляя синусоидся T=5 минут. а для другой кажые T минут. но если в исходном сигнале  
у нас куча синусоид то каждая из них повтоится толькко через свой T интервал. поэтому на графике
надо пользоваться только одним параметром сдвина это тот сдвиг который общий для все синусоид 
это 1минута. правла прикол еще в том что есть часть синусоид у которых сдвин идет в промежутке
[0;1мин] это пиздец


еше вот  что
вот мы имеем такую АЧХ
слева период в с.
справа это уменьшение амплитуды и сдвиг фазы

(15/60))   # сдвиг фазы +0.0м| амплитуда   7%
(20/60))   # сдвиг фазы +0.0м| амплитуда   7%
(25/60))   # сдвиг фазы +0.0м| амплитуда  11%
(30/60))   # сдвиг фазы +9с| амплитуда 11%

1)  "      # сдвиг фазы +18c| амплитуда 26%
2)  "      # сдвиг фазы +30c | амплитуда 43%
4)  "      # сдвиг фазы +30c| амплитуда 64%
5)  "      # сдвиг фазы +1.0м|  амплитуда 70%
10) "      # сдвиг фазы +1.0м|  амплитуда 87%



15) "      # сдвиг фазы +1.0м| амплитуда 93%
20) "      # сдвиг фазы +1 мин| амплитуда 95%
40) "      # сдвиг фазы +1 мин| амплитуда 99%
100)"      # сдвиг фазы +1 мин| амплитуда 99%


так вот я бы сказал что у нас есть три полосы частот.
первая полоса это где амплитуда эфективно подавляется почти до нуля. это то что нам надо
третья полоса частот это где амплитуда сохранятся почти в первозданном виде это тоже то что 
нам надо. и фаза сдвигается на одну велчиину 1мин. это не супер но хотя единый сдвиг

LA(15min) отличается тем что T при котором амплитуда не искажется сдвигается вправо в сторону
еще большего T. тоесть ели у LA1min это T=15 то  у LA15min это T условно говоря T=140 минут
T при котором от амплитуды остается скажем 10% тоже смещается вправо.  получается мы лучше гасим
выскоие частоты но и полезный сигнал с которым мы можем работать 
сдвигается в сторону более с длиным периодом.


итак беру эту хрень


(15/60))   # сдвиг фазы +0.0м| амплитуда   7%
(20/60))   # сдвиг фазы +0.0м| амплитуда   7%
(25/60))   # сдвиг фазы +0.0м| амплитуда  11%
(30/60))   # сдвиг фазы +9с| амплитуда 11%


1)  "      # сдвиг фазы +18c| амплитуда 26%
2)  "      # сдвиг фазы +30c | амплитуда 43%
4)  "      # сдвиг фазы +30c| амплитуда 64%
5)  "      # сдвиг фазы +1.0м|  амплитуда 70%
10) "      # сдвиг фазы +1.0м|  амплитуда 87%



15) "      # сдвиг фазы +1.0м| амплитуда 93%
20) "      # сдвиг фазы +1 мин| амплитуда 95%
40) "      # сдвиг фазы +1 мин| амплитуда 99%
100)"      # сдвиг фазы +1 мин| амплитуда 99%



возникает все таки вопрос - как же нам  разделить эту полосу на куски.
а именно куда деть вот этот кусок

5)  "      # сдвиг фазы +1.0м|  амплитуда 70%
10) "      # сдвиг фазы +1.0м|  амплитуда 87%

дело в том что у этого куска достаточно большая все еще амплитуда остаететя и все 
еще сдвиг фазы 1 минута.
но  я все таки решил что этот кусок нужно засунуть во  вторую полосу. полоса стремных частот.






тогда 
отталкивась имнно только от гащения амплитуды.  тогда выкидыавют среднюю полосу частот
получаю



(15/60))   # сдвиг фазы +0.0м| амплитуда   7%
(20/60))   # сдвиг фазы +0.0м| амплитуда   7%
(25/60))   # сдвиг фазы +0.0м| амплитуда  11%
(30/60))   # сдвиг фазы +9с| амплитуда 11%




15) "      # сдвиг фазы +1.0м| амплитуда 93%
20) "      # сдвиг фазы +1 мин| амплитуда 95%
40) "      # сдвиг фазы +1 мин| амплитуда 99%
100)"      # сдвиг фазы +1 мин| амплитуда 99%



получааем то что  график LA будет сдвинут на 1мин вправо.
 велчиина LA  будет 0.93 от исходного r(t) при условии что r(t) входит в полосу три.
что касается помехи r(t) - то ее вклад по амплитуде будет  10% от исходной величины в значение LA.
а какая будет фаза у этой составлвяющей , ее сдвиг это нам похеру так как по амплитуде будет 
мнималный вкллад.

далее я пока рассмотрю пока что пример когда исходный r(t) прдесталвен в виде всего двух 
синусоид одна отвчает за проезный сигнал а вторая за помеху

    r(t)= A*(Sin ( полезного сигнала) + B*Sin(помехи)


то тогда формула LA будет иметь вид

    LA1min= 0.93*A*(Sin ( полезного сигнала) + 0.1*B*Sin(помехи)
или это примерно равно


    LA1min= A*(Sin ( полезного сигнала) + 0.1*B*Sin(помехи)


так вот дальше важно вот что понять - мы хотим с помощью графика LA 
восстановить вида графика r(t) для полезного сигнала    A*(Sin ( полезного сигнала)  . 
потому что у нас нет графика r(t) для полезного сигнала.

если мы сравним фрмулу r(t) для полезнго сигнала


         r(полезного сиала) = A*(Sin ( полезного сигнала)
         
         LA1min= A*(Sin ( полезного сигнала) + 0.1*B*Sin(помехи)


мы увидим что они поразительно похожи. за исключением того что у LA есть еще 
компоненты отвечающая за влияние от помехи. так вот мы хотим чтобы помеха была такова чтобы 
ее влияние наа LA было минимально вменяемое. для этого надо чтобы амплитуда от помехи
была скажем в 10 раз меньше чем амплитула от полезного сигнала. тогда у нас график LA
будет из себя представлять график r(поленого синала) но с небольшим волнообразным искажением.
тодга у нас появлется требование

            (0.1*B)/A <= 10
откуда
            B <= A
            

если же у нас B >>> A ( много больше ) то тогда график LA будет из себя представлять очень 
сильно искаженный график полезного сигнала. и толку тогда от него ?

также важно помнить что LA(1min) имеет смещение по фазе +1min.  тоеть каждая его точка
показыает не то что есть сейчас а то что было -1min назад.

значит я проверил - в целом если поолезный сигнал лежит в диапазоне 
15) "      # сдвиг фазы +1.0м| амплитуда 93%
20) "      # сдвиг фазы +1 мин| амплитуда 95%
40) "      # сдвиг фазы +1 мин| амплитуда 99%
100)"      # сдвиг фазы +1 мин| амплитуда 99%
а помехи лежат в диапазоне
(15/60))   # сдвиг фазы +0.0м| амплитуда   7%
(20/60))   # сдвиг фазы +0.0м| амплитуда   7%
(25/60))   # сдвиг фазы +0.0м| амплитуда  11%
(30/60))   # сдвиг фазы +9с| амплитуда 11%
тоесть если полезный ссиогнал лежит там где надо 
и помеха лежит там где надо 
то можно в целом на графике разглядеть несущую даже 
при отношении помехи к сигналу как

    (помеха):(полезный сигнал) = 16:1
    
    

расмотреть еще раз прямоугльный импулс. я понимаю так что процеблема 
у него в вертикаьной ножке. чтобы ее реализовать нужны выскочастаотныые синусы.
а у EMA их нет. поэтому вместо ножки идет плаваня кривая.


w*t= (2pi/T)*t, t=0,5,10,15c=n*5=k*5

w*t= (2pi/T)*k*5=(2pi*5/T)*k=(2pi*V)*5*n=w*5*n

w*t, t=0,5,10,15,20=5*n

w*5*n=2pi*f*fs*n, n=1, 2pi*f

sin w*T =0


2*pi*
------ *t
  T

  
 w*t = rad.
 
 w=rad/s  t=s
 
 если w=1  1rad/s  2pi*f=1
 f=1/2*pi=1/6 T=6s
 
 sin (1*t)
 
 2pi*1=2pi
 
 
 2pi*f*t, f=1. t=1 wt=2pi  полный оборот 
 
f=2 оборота в с.

2pi
---- *t,    t=1  угол равен 2pi
 1

 
 t=0.5  угол равен pi 
 
 2pi*f*n*5,   
 
 
 2pi* (1/60)*5*n = (1/60)*2pi*5*n  =  2*pi*(5/60)*n  =  T=1м,  phi=(pi/6)*n, f=1/60
                   (1/120)*2pi*5*n =   T=2м
 
 2pi*(5/60)/1
        
        
        
sin(phi)=sin(w*t)

phi=wt=2pi*f*t=2pi*f*(5*n)=2pi*f*(5*n)= 
5=Ts= fs^(-1)

2pi*f*(5*n)=2pi*f*fs^(-1)*n= 2pi*(f/fs)*n= (w/fs)*n


k=w/2pi, w=k*2pi
                  
                               
                                



          f*2pi*n             w*n
phi =  -----------------  =  -----
            fs                fs

fs=2pi


T=5m   ((2*3.14)*$tt*(5/60)/5) = ((2*pi) * (1/(60*5))) * ($tt*5)
    

    
разобрался с частотой отрезания. для  p=0.08 это T(среза) = 377с
у меня на основе замера руками это где то T=300с. вобщем совпало.


        
очен важная щтука:
lA он смотрит сколько  тредов  И  процессами имеют R|D!!!
потмоу что одтн процесс можетиметь 100 тредов.  тред это проецсс
но имеет оющую память. а так это тот же процесс.
команда top   покаывает только головной процесс у тредов и покаывает
суммарную загрузку цпу для всех тредов всумме от этого прцоесса.
vmstat он покаызет тоже треды а не процессы. 
тоесть еси унас 1 проецес и в нем 6 тредов и они все пашут. то vmstat покажет 6 а не 1
ps -L покажет треды.
так что если считаю рукмми R|D то надо считать треды!!


                    
важная добавка - эту штуку EMA ее в мире электронных сигналов используют для того чтобы натйи ФОРМУ
СИГНАЛА  котоырй засран помехой. еще раз -  с ее помощью ищут форму. цель это форма сигнала.
а когда мы ищем среднее арифмечтиеское то мы ишем не форму а среднюю энергетическую составляющую
сигнала. тоесть это две абсолютноразные по задачам функции. средняя аричметиекая не ищет форму
исходого сгнала. а EMA ищет именно форму! просто она ее ищет в исходном сигнале пытаясь вычлениить 
форму полезного сигнала. форму форму фомру!!! ее основаня цель найти форму!!! оригианлрную форму!!
срееддняя арифметическое неищет форму исходную. ему на это  насрпть. он уже имеет форму , он ищет 
средний энергетический комопнент этой формы



жопа состоит в том что если r(t) это синус. то la выдает тоже синус.
а вот если r(t) это ступенька. то тут пизда. потому что la выдает не ступеньку а хуйню.
а ступенка это частая форма r(t) и что я не могу понять так это то что по идее ступенька
имеет спектр основной в районе низкийх частот. поэтому я не могу поняь какгго хуя EMA так уродует 
ступеньку на выходе. тоесть глядя на lA мы хуй поймем что  r(t) в этом месте это была ступенька.сука.

что ксется сигналов со ступеньками я выяснил из практики что почпмуто у них сдвига фазы нет.
так что это прикол. плюс аплитуда не успевает вырасти за минуту более чем до 63%.
если идет регулярный забор и ступенек то будет рисовать труегольную хрень. и она будет
болаться посередине ступенки

если сигнал треуголны то LA рисует конечно же не его. а плавную хрень. по форме совсем не треу
гольник.  идет некая волна посередине треугольника.сдвига фазы тоже нет.

если появтелсяется ступенька наверх то растет по экспоненте выпоклостью вверх.
если встречает ступеньку вниз то паадает по экспоненте выпуколстью вниз



я рассмотрел случаи:
1) синусы
   а) которые лежат в хорошей области полезного сигнала
       тоесть у таких  апиутуда уменьшается до 93-99% и фаза смещается на 1 минуту
       тоесть для таких восставноить сигнал просто - надо подвинуть график на 1 минуту влево
       и макс значения la умножить на LA* (1/0.93)  а миним значения умножить на LA*(1*0.93)
       тоесть надо график растянуть и вверх и вниз
    б) те которые лежат в высокочастной области там от аплитуды остактся <11% и фаза
       не смещается. это помехи которые мы обраезаем
 
2) квадрат
     этот сигнал искажается в некую кривулину. если квадрат идет на рост то график за 1 минуту
     представляет собой кспоненту выгнутую вверх и ее максиум через 1 минуту это 63% от  R2-R1.
     где R1 это R до того как появился квадрат. а R2 как он повяился. 
     причем свдага фазы нет. если это крвадрат идущий вниз то это экспнеты падающая  за 1
     минуту на 63% от R2-R1
     
     
3) треуголтник
    сдвтина фазы нет. ведет себя примерно как и квадратны сигнал
    
    
    
двойной LA  посмотрел - он нам особо не дает. он еще больше сглаживает перывичный LA



на синус LA реагирует с опоздаением 1 минута а на излом регирует мгнвенно!
тоесть получается прикол - есои в LA влетает  синус ему нужна 1 минута чтобы его накопить
и выдать если влетает кдвадрат то ему надо 5 минут чтобы его накопить и выдать 


если есть излом и выпуклость наверх при россте вверх или выпуклость вниз приросте вниз
это значит там r=const изменился. и значение LA сильно отличатся того что она рисует.

прямоугльный импулс это набор отдельных стоячих одиночных вертикльных испульсов.
и получается что к LA такие палки очень плохо передают импусльс. синусы это тоже набор стоячих
палок но у них величина меняется плавно. от них LA принимает импусльс лучше. 
а от стоячих палок принимает его плохо.тоесть


      |-----------
      |
------|


его аналог

       ||||||||||||
       ||||||||||||
-------||||||||||||

и эти одиночные палки бьют по lA пытаются его раскрутить.
но наэто надо время. поэтому есть  лаг.

синус тоже самое но у него палки переменной длинны.

там где  у LA излом там значит прямоульный импульс появился и через 1 минуту LA достигент только 67%
от высоты ступеньки. тоже самое когда R(t) упал. там исзлом и через 1 минуту LA лостигнет только 67%
от высоты ступеньки. тоесть надо еще мысленно доьавлять 30% вверх от высоты перепада и 30% вниз.

по факту LA вот как работает он беерт столбики r(t) отпливет у них все острые верхушки
а в себя вбирает только жирное основение стоолбика. вот  как он работает

поэтому если мы меем график R(t) то можно мысленно со всех пиков спилить все острые пики
это и будет график LA

тлоко при этом сдвиается фаза. и для ряда колебаний к сожалению изментся аплиутада.

важно что при изломе ( при поодозрении на ступеньку) надо на 1.49 умножать не величину LA
а найти разницу между пиком и основением излома. и эту дельтку умножать на 1.49.
ну или поделиьт на 0.67  как удобнее и приавиьт к основанию излома. 

ывжно еещ раз  понять что нужно не абсолютную координату LA делить на 0.67. а нужно
искать дельту между точкой излома и величинй LA через минуту. и эту дельту делитьна 0.67
а потом приставлять к основанию излома.!
тоесть елси мы просто весь граик LA поделим на 0.67 мы получим соверешнно нетот график. он будет
бешено завышен

я бы сказал так - смотрим на гарфик LA. если видим пик вверз с изломом и выпуклостью на наверх
как у эскмоенты то надо кривую заменить на прямоульный импульс по величине на 50% больше.
если мы видим кривую падающшую вниз то это место надо замнееить прямоуьльным вырезом котоырй по высоте
на 50% больше идет вниз.

высокоасчастаотные помехи могу скрыть излом. и его будет незаметить 
поэтому величина пика запросто может быть в 2 раза больше. 
когда я говорю пик то над иметь ввиду величина в течение +1 мин от основания излома.
тоесть после излома нужно не искать глазами где в целом заканчивается пик. нет.
нужно смотреть до скольки дорос график через +1минуту. это величина пика.
причем мы говорим не про велииану пика в исходном r(t) а в низкочастоном сигнале

если сумма амплтуд помех  к сумме аплитуд полезного сигнала 3:1
то уже помехи ощутимо искажают форму LA и уже изломы не видно нихрена. 
физически это означает то что если мы посмотрим на исхдный график r(t) то у кажого стоолбика
есть жирненькое основание и острые иглы пиков. и вот нужно чтобы жирненькая часть графика r(t)
была не хуже чем 1:3 иначе будет плохой защумленный график LA. и понему полезный сигнал плохо
уже бцдет восставнолене.
щасс покажу на карткпе

           |
 |         |
 |         ||               ||||
 ||        || ||            ||||
 ||||      |||||            ||||
/||||\____/||||||\__________||||

вот глядя на каждый пик мы вилим у  него жирненокое оснвоение. это как раз та часть котоаря
отвечает за полезный сигнал. и острые выбросы.  чем больше у пика в его площади составляет 
жиренькое оснвение и чем меньше у него острых лучей и чем меньше у этих лучей макс высота
тем график LA будет иметь большую схожесть с полезным сигналом. такж как я понимаю 
отношеие 3:1  это видимо отрнлоение высоты жирной части пика к высоте лучей. если лучи
очень длинные то пизда

ну и вторая пизда это то что LA очень плохо переварвает прямоулные импульсы. 
LA лучше всего перваривает пики имеющий форму синусоиды. поэтому если это острый тонкий пик
или это жирный прямоульный импульс - вот тут LA существенно их искажает.
ну то что он острые пики режет  - это окей. а то что он прямоугльные иипусльсы режет это 
уже нам плохо.





осатется рассмотреть следущие случаи:

4) частоты лежащие в средней части спектра. котоыре ни то ни се.
а именно у них амлитуда падает в интервале от 93% до 11%. фаза  смещается  от 1 минуты
до 0 минут.

перехожу  к стремному среднему спектру для исслоедвания
минимальынй T=15 у которого LA сохраняет амплитуду хотя бы до 93% ~=100%
все что ниже я считаю это помехи.
у T=15 у него пик наблюдается на промежутке 7.5минут.
при таком T у нас если мы возьмем отдельную минуту то кривая от этого сигнала будет монотонная
тоесть она будет либо только расти либо только падать. а такого чтобы от этой кривой в клетке
размером 1 минута был изгиб это редкость(только там клетка где у нас пик)
Если у нас в полезный сигнал добавляются синусы у которых еще  больше T >=15 то они 
будут приводт к тому что поленый сигнал будет увеличивать свой суммарный T еще больше
и значт в клетке размером 1 минута сигнал тем более от такого поленого сиганла будет монтоннный.
безе перегибов.  значит при таком раскладе перегибы в клетке устраивают только ПОМЕХИ.
тлоько надо еще помнить про прямоульноые сигналы.


ТОГДДА алгоритм дешифровки LA такой. беру график LA. сдвинаю его на 1 минуту влево.
потом беру каждую отдеелную минуту. приглядываюсь. если там есть характераная кривая для проямоу
гольного импульса то  я  нахожу основание излома. потом отсчиывают +1 минуту. сморю какой перепад
и заменяют 1 минуту на прямоульноый импульс с высотой +50%. тоже самое если кривая падает вниз.
если же нет признаков приямоугольного импулса то я смотрю на кривую. у нее недолжно быть перегибов.
если они есть это помехи. значит нужно мысленно кривульку заменить на некую монотонную кривую.
это и буде полезный сигнал. 



LA ьерет и как бы отпилвает все острые пики от r(t). и замеяет их на толстенкьие
пимпочки. узкий пик становится нашлепкой


   |
   |
  ||
  ||                                                             
  ||            становится после пераобразования lA ===>          ___
  |||                                                            /||||
  ||||                                                           /||||\
 /||||\                                                          /||||\
/|||||\                                                         /|||||\



плюс особое отншение LA  к прямоушгльным импуслсам

ДАЛЕЕ: надо прдолдлижть исселодвение влияние синусов из проблемного
среднй части спекрта.



и тут я еще кое что понял. вот мы смотрим на график. если мы на нем виден 
какой нибудь крупнцй кусок синсоиды.ее холма. скажем интервал времени от одного края 
ходма до другого 2минуты или 3 минуты. щас покажу


      _______
     /       \
    /        \
---/          \      .
               \----//
    
----------------------------------------------------
   t1         t2
   
   

так вот  если t2-t1 скжаем 2 минуты то на этом интервале времнеи доминировала 
синусоида с полупериодом T/2=2 минуты.  далее я смотрббю в АЧХ LA и нахожу что 
для этой синуслоиды идет подавление амплитуда до 64%.  так вот основание
этого стоолбитка  оно обусловалено синосидами более выского порядка. а вот высотка
холма кога уже видна синусоида обосонваноа синусоидой с T=4с. значит надо высоту холма
начинная от линии излома улвеоить в 2 раза. тога мы узнаем как выглядео r(t) в этом месте.

щас покажу



     /       \
    /   h2   \
---/          \      .
               \----//
        h1   
----------------------------------------------------
   

тоесть я к тому что h1 трогать не надо. он обусловлен 
синусом с T>4м. прчием хер знает каким. а вот h2 обсуслволен синусом с T\2=2мин.
и так как lA гасит такой синус до 64% то h2 нужно изменить как h2/0.64. и присобачить. 
тогда получмм исходнй R(t) для частот T>4м

если мы у LA в течение 7.5 можем выделить какойто постоянный кусок по высоте. 
то это обусловлено частотами T>=15 для которых амплитада сохраняется. значит этот R точно
был у исходного сигнала. остальная соатвляющая чатсь графика LA обуслвоалвиается 
синусами с меньшмм периодом. 
чем меньше на компе выбросов тем плавнее будет его LA график.
чем меьньше на компе постоянно работающх процессов и чем больше стохастических 
тем у него график LA будет как расческа выглядеть.

елси мы видим на грфаке LA макростурктуру (холм) длинной 1 минута значит T/2=1м, T=2м
для этой частаоты lA уменшает амплитуду до 43%
если хоолм имет длину 2м то это T=4м , для него lA умньшает амплтилуу до 64%
если холм 3 миннту то это T=6м у него lA осталяет 85% амплитуды. 

зная это можно домножить холм на этот коэфициент и получить r(t) на этом куске для T/2 >= той
ширины которой это холм.

тоесть надо на графике LA искать макростурктуры - холмы. смотеть какой у них 
размер по вермени. умножать на 2. получать T. смотеть в таблицу. понмтмать какой амплифай.
и восстанвливаьт R(t) на этмо куске
пример

чтобы холм на себя обратил внмимание он дожен быть либо широким либо узким ( от 2 минут) 
но очень высоким по срваенпию с друигим кусками графмка.


получается если у нас есть холм. у холма есть наклонная левая поверхность. то в течение этой 
наклонной поверхноси 100% херачила какаято повышенная нагрузка. величина наклонной леовой поврхности
холма это T/4. смотрит амплитуду соовтетвюущего синуса и домножаем на коэфициент. и значит в этом
месте стоял такой бугор R(t). та часть ходма которая прпва котоарая падает - там нагрукза уывала.
как убывала хер знает. нам главное пики ловить. нарастание нагрузки.


в зависимости от мощности нагрузки (высоты столбов) и длительности нагрузки у холма левая
его часть будет более крутая или менее крутая и по длине по вермени будет разное. это все 
соовтсутет соответсбующему синусу на его T/4.

если график r(t) в какойто точке теряет гладкость (супер резкий скачок например квадратный импульс) там
и LA меняет гладкость. это прям особые точки внимания. так как синус идет плавно то в точке его появления
у нас нет нарущения гладоксти. а так как  квадратный импусль негладки то в его точке мгнвоенно
на LA в этом же месте по времени происходит нарушеие гладкости. 
еше прикол в том что нарастание r(t) в форме синуса приводит  к тому что на LA кривая растет тоже 
как синус  причем синус будет иметь тот же период. но будет сдвиг по фазе. от нуля для высокочастотных
функций до  1 минуты для низкочасатных.
первый T который будет сдвиг 1 мин это T=6 мин.
видимо логика такая  чем более плавнй синус тем долтше надо времени LA чтобы собрать с него энергию.
у коротких синусов он это делает макс быстро. 
а если у нас квадртынй импулсь то он порождает не синус а экспоненту на выходе.

смотрим на график LA. если мы видим что график резко пошел вверх - то значит в этом месте был пик.
чем круче растет наклонная слева у пика тем больше был по амплитуде пик. чем длинее наклонная по времени
тем он дольше по вреени действиовал. как только пик закончит действиовать то наклонная закончится.
тоетсь



пускать скажеи LA выглядит вот так
   _____
  /
 /
/



тоогла пик был вот такой 



||
||
||
||
||
||
|| _____
|/
|/
/


велчину пика можно высчитать если мы возьмем t в течение которого la рос. умножим на два получим
полупериод. умножим еще надва получим период. потом смотрим в таблицу АЧХ и делаем вывод
насколько % LA погасил аимплитулу.


если после пика нагрузка закончилась и упла то пик сразу станет падать. а если нагрузка 
продолжала быть то наклонная перейдет в гор линию. кстати тут надо внимательно смотреть 
не был ли это пряомуогцльный квадрат имаульс.

покольку линия сама поястнгннно хочет упать это значит что ели на графике идет гор прямая
это значит что в это время все время долбит r(t) в нее

поскольку я значб что если пик ударил то на каждые 5с этого пика у насриуется как 0.92la+0.08(пика)
таким макаром для коротких пиков из рафика можно легко узнать  величину пика.
если  грубо огнцеиивать то если унас есть скачок на 5с. то надо на графке взять этот скачок умножить
его в 10 раз и мы узнаем как был удар пика r(t) в этом сэмпле.

как найти виеличину скачка на длинее 5с. пусть у нас есть t0 и 2t0 тоеть у нас есть две точки соседние.
и мы вииим что la резко вырос. нам очется знать какой был пик r(t).
тогда надо взять   0.9*la(t0)  отнять la(2t0)  и умножить на 10 или если точнее поделить на 0.08

 скачок  r(2t0)-la(2t0) = [la(2t0)-0.9*la(t0)]/0.08
тоемть сколько нужно прибавить к la(2t0) чтобы получить r(2t0)
 
 
и мы узнаем сколлько нужно прибавить к la(2t0) чтобы увидеть r(t) в точке 2t0
       
если  польем перешел в горизонт значит нагрузка осталась.
если подьем перешел в падение значит нагрузка резко спала.

падения la можно в принципе не рассматривать( с ними отдельная ебала).  а вот пики обязательно.


если график La(t) растет по сравеннию с преддыдущей точкой la то это 100% значит
что на новой точке r(t) стал больше чем он был наа старой


если нагрузка высокаохаотичная - то графики R и LA они не совпадают.
точнее так - если у нас есть график R(t) котооый снят со сверх частным сэмплированием
то он будет более точно отражать правду про r(t). а вот LA он же основан на r(t)
снятом через 5с. поэтому если у нас график r(t) снят тоже через 5с. то его сравнивать 
с LA нужно очень сковзь пальцы. потому что LA подскочит только если в его выбору r попадет
какойто r. тоесть LA он строттся на суб поле от R(t) и нефакт что ваш график r(t) совпдаает
с графиком r(t) на котоырй опирается la. поэтому если r(t) очень хаоттчный. и мы нарисуем наш r и la
то  на каких промежутках la будет отражать r нашего графика а на каких то нет. 
поэтому если у нас r снят редко с крупным сэмплом то он нам мало поомжет его сравнить  с la.
и также если у нас есть подробный r и мы нанем видим что на какомто куске у нас была нагрука R а LA 
это не отразил - этотоже номрално. потому что еще раз - la высчиывтается на некотором незначителном
субполе от реальнго R. поэтому нам трудно получить  такой же r на основе которого рабтает la.
еслр у нас высокохаотичная нагрузка.это надо учитывать!
поэжтму надо отталкиваться от чего то  одного - либо от lA либо от r(t).
еще раз скажу - потому что эти графиик зачатсую буудут противоречит дргу другу.

в этом плане грораздо ополезнее график busy time. он в себя включает все r(t),
просто если у нас постоянно buysy time 99% то можно расширить детализацию добавив LA к нему.
тоесть la это дополенние к busy time. но не наоброт.

у нас r(t) мы снимаем на одних точках времени. а LA снимает r(t) для себя в другие 
моент времени.

с r(t) нужно мучтться. то ли ты его снял полно. то лли не снял. хотя все равно ты его не снимешь
полно. а busytime показывает 100% полный результат.







ДАЛЕЕ: 
000) снимать график busy time
00) вопрос la1min подавляет все синусы R(t) у которых  T<=30с. 
значит на 15-ти секундах отставшийся R(t)  в среднем доходит меняется от 0 до max(или min) и опятьь до 0.
значит в среднем за 7.5с у нас оставищийся R(t) меняется от 0 до макс или  от мин до 0.
тоесть на интервале 7.5с оставшийся R(T) монотонный. тоесть LA(1min) обрезает исходный сигнал R(t)
так что на интервале 7.5с он всреднем монтонный, некостната но монотонный. 
и что ??? непонятно....
тоесть я знаю что LA1min вырезает часть исходного R(t) даже знаю какую часть. но 
какой в этом физ смысл хер знает. тоесть наш исхдный сигнал получется на кажом интервале 7.5c
это как бы сумма монотонная компонента + помеха. и он помеху удаляет. 
непонятно...
тоесть он конечно в этомм смысле сглаживает график R(t) потому то исходнй график может 
быть все время не монотонным условно говоря. но как в этом смысл физический?...
тоесть та часть r(t) ситается мусором помехами. но тоже неявляется помехами. так какой смысл в этом?
опять же - все что 30с<T<15мин имеет искаженную уменьшенную амплитуду. тоесть их значение 
тоже получаетс считается несерьезным. тоесть LA действует так:
    - берет R(t) 
    - сигналы с T<30с считвает полнейшим мусором
    - сиггалы с   30с<T<15 мин считает малозначителными
    - сигналы с     15мин =<T считает полноценными 
    - рисует график. 
    
Тоесть LA он часть напгуррузки вырезает. часть искажает. часть отсавляет. и рисует нам
такой суммарнй график r(t).... в чем прикол непонятно. ну понятно что он его сглаживает + искажает.

тоесть la1min считает что осциляции R(t) котоыре чаще чем 7.5с считает случайными и вырезает их.
и что? какой в этом смысл? что мы при этом видим? какую особую величину?
дело в том что частые осциялции они как добавляют к r амплитулу так ее и уменбшают. 
непонятно...
типа если r(t) котоыйр монотонный на 7.5с восприимать как тренд которы стоит за осцилями. 
и типа если мы хотим разглядеть этот тренд?(как это делают в биржевых сводках??)
типа если у нас есть частые осцияляции и мы хотим понимать какой тренд скрывается за осцияляциями
за прошедшие 7.5 секунд? 

типа логика lA1min нам показать какой тренд скрыватся за осцияляциями? стала ли нагрузка на комп
выше или ниже. ведь если высокие осцияляции r(t) то это нам навскидку непонятно. так что ли?
таков физ смысл la ?
так как у нас как я показал вырезаются высокие частоты и R(t) ставноисят монотонным на интервале 7.5с.
а LA у нас счтается каждые 5 секунд. и по факту x1*w1+....+xn*wn как я высчиывал уже после 5 минут
там все члены нули. то получается что lA1min показывает изменнеие трнеда нагрузки на комп 
за последние 5 минут или как... непонимаю..непонятнр....

по другрму я бы скаал что LA никакой не тред а показывает график R(t) 
но с обрезынными короткими по времени (высокочастатными) выбросами пиками. 
так как короткие пики типа мало вляют на бизи тайм. тоесть хоть процессов и много
 но они все мгнвоенно проскаваиют на цпу. и его бизи тайм особо не нагружают. действиелно. 
 если у нас есть 1 процесс который постяно виисит на ядре это жопа.
 а если у нас 100 коротких прцоессов и все проскочили за 0.05 секунды то онинеимеют никакого
 значения. нам нужны только те процессы котоыре дейтивтелно надолго засирают время у цпу. 
 тоесть да - нам неинтерсын процессы будь их хоть миллион в момент t0 если они все короткоживущие
 и цпу их обрабтает за 0.01мс. нам нужны долгоители. ибо только они убивабт время на цпу.
 
 на счет 7.5с. на этом промжутке чисо процесов может либо монтонрос расти либо
 монтонно падать. но что это значит ?
 
 LA обрезает все острые выбросы узких пиков на R(t) тоесть она убирает их рассмотрения 
 все короткоживущие процессы. или добавляет их в себя с очень маленьких коэфициентом.
 
 он обрезает резкое увеличение нагрузки за короткий срок. срезает пики. 
 а показывает он типа среднее число процессов которые работали примерно 7.5 минут и дольше.
 
 резкие всплески это короткоживущие процессы. это точно. 
 кривая T=15 минут. это те процессы котоыре рождаются  в течение 7.5 минут. а потом 
 они умирают в течение 7.5 минут. если счтать что тот кто родиисял первым  у умирает первым то
 они все проживут по 7.5 минут. а  процесс с T=2 мин. у него процессы живут по 2 минуты. для таких 
 коротыей LA делает уменьшенный коэфициент. 
 
 поэтому когда синус T=15 растет то в каждый момент времени la показывает солько долго играющих
 процессов появилось.  а когда он пдает то он показыает сколоко таких процессов осталось еще.
 
 полуучется LA  он ранжирует. 
 для процессов с временем жизни T>=7.5 минут он их число оставлвяет как есть.
 для всех осталных он вводит уменьшенный коэфициент.
 ну и для процессов у которых времяжизни 7.5 секунд он вводит  коэфиц 11%
 
 поэтому LA1min покааывет статистику за последние 7.5минут.  
 
 
 еще раз поговоим об интерпетации. для просттты пока выкинем средний спектр синусов
 где LA их в себя принимает но с уменьшаеющим коэфиицентом.
 
 берем то LA  имеет только два спектар - выскоеи частоты где он их уничтожает
 и н изкиечастоты где он без изменеий их высирает.
 
 также считаем что сигнал r(t) меняется для простоты только синусоидально.
 тогда наш R(t) он разывается на два спектра. один спектр будет уничтожен
 а второй будет высран без измненеий.
 
 
 пусть у нас есть такой R(t). как можно трактовать такой R(t) если он в натуре
 было высран самим компьтером. 
 елси у нас короткий пик = это значит что у нас народилась куча процессов но они все были короткодействую
 щие. 
 
 если у нас пологий и длинный по времени пик это значит что скорей всего нагрузка вначале 
 медленно росла а потом медленно падала. (мы говорим о синусоидах).
 
 как по другому можно траковато такую синусоиду. по сравнени с узкой синусоидой с узким пиком это значит
 что процессы появлылись но исчезали не сразу что у них был  большой период жизни. 
 длинну синсовиду по сравнению с короткй синусоидой можно как трактовать - что кажое увеличнеие
 длинной синусоиды порджало +1 долгоживущий процесс. в момент t=0 их 0
 потом в deltat он такой 1. потом еще deltatt их уже два.  в момент T/4 их будет макмимум скажем
 10 штук. причем самый первый уже проработал T/4 времени. а самый последний пока что проработал 0 времени.
 зато когда синусоида начнет падать то первым умрет самый старый а еще через T/4 умрет самый молодой. 
 тоесть у нас есть гарнтированная нагрузка и от  0 до T/4 и от T/4 до T/2
 а у короткой синусоиды такая нагрузка гарантирована только на сверх короткий период. тоесть динная
 синусоида она гарантиурет длинную нагрузку. а короткая только короткую. 
 так вот нас интерсует нагрузка толкь длиннымм процессами. потому длиные процессы они реально 
 грузят цпу по вермени бузитайм на него влияя. а короткие процессы хоть их в штуках и много
 но они на бузитайм не влияют. поэтому если нагрузка растет медленно то LA ожидает что 
 это будут долгоиграющие процессы. а если нагрузка растет быстро то LA ожидает что это 
 будут короткие проецссы. 
 
 и его значение в точке это число на данный момент раютающи на компе долгоиграющих 
 процессов. которые по его прогнозу долго появлялись и долго будут исчезать. 
 суть действиетлно такая. только 0.08% от нового R всасывется в LA. поэтому он работае по статистике.
 если новое R выросло на 100. то велика вероятнсть что это короткий пик. и поэтому он от него
 берет 8%. а если это новая синусоида у которой на самом деело амплитуда +10000000 и минимальный 
 сдвиг фазы тоже даст +100 то эта синусоида на дительной дистанции доберет. а короткий пик уже исчезнет. 
 там походу по другому R(t) немоет расти быстрее чем такое то число. для синусоид с T>15с будет 
 все засасыавться. а у пиков будет захыватсяь ттлоько маленкий хваостик.
 
 принматеся праадигма что долгоиграющие процессы они не могут на компе рождаться с выскоим рейтом 
 рождения. это скорее всего именно короткоживущие процессы. 
 
 конечно длинный синус может акуратно дорасти до T/4 максимуму и полностью пропасть. тогда будет облом
 с долгоиграющими процессами. 
 
 LA хорошо сьедает меделенно растущий синус. полагая что это долго играющий процесс.  и что
 за меелнном подьемом будет меделнный спуск. и процессы долгоигарющие. и нагурзка на комп 
 гарантрована.  и плохо есть резко растущий пик полагая что он скорей всего исчезнет
 уже через секунду поэтмоу его и есть нечего. поэтому LA это сумма процессов которые в системе приабалвялись
 медленно. и велика вероятнсоть что это именно долгоиграюзщие процессы. это получается 
 с одной стороны резултат за последние 7.5 минут. с другой стороны это предикшн на следущие 7.5. минут.
 
 когда мделнные синуса доросли до маквиума то LA в максимуме. если после этого нагрузка R(t) просто исчезла.
 то LA будет падать но медленно. тоесть то что LA показывает количество медленно появлявщихся процессов
 таким образом показывая какова нагрузка щас медленными процессами это понятно. LA справделиво полагает
 что дергающаяся в агоии короткая синусоида она очень скоро пройдет и на нее обращать внимания ненадо.
 так как она очень скоро перестанет влиять на нагрузку. а вот вопрос у меня кодга унас вдруг R(T)
 исчез. то почему LA непадает мгновенно. 
 значит с одной стороны LA показыает не текущую нагрузку на систему как она есть по факту
 а уменьшенную нагрузку со стороны тлоько части процессов зато долгоиграющих. которые будут грузить
 систему нетлоько прям щас а скорее всего и далее. 
 
 
 итак про LA.
 положи у нас R(t) это график имеющий форму синусов. 
 тогда нам легко узнать какой будет форма после того как эти синусы обработает LA.
 положим унас синуссы из первой и третьей полосы. тоесть это длинный сигнал с T>=15
 у корого не меняется амплитуда и это короткие сигналы у которых амлпитуа уменошается до 7%.
 логика LA такова - она начинает жрать очередной кусок R(t). если фронт роста сигнала резкий
 значит это скорее вссего помеха. тоесть это народились короткоживущщие процессы. что значит
 короткоживущие - потому что они просят цпу сделать чотото очень простое. поэтоуму хотбь их и куча
 но они все отработают и помрут мгновенно. поэтому такие процессы воспринимть всерьерз ненадо
 они на цпу на его бузитайм влияния не окажут. поэтому если фронт роста сигнала R(t) крутой
 то LA увеличивается лишь на капельку. если же рост сигнала плавный такой как у синуса T>=15.
 то такой сигнал LA засасывает целиком неменяя амплитуду его. тако сигнал такие процесссы LA считает
 что они с высоко долей вероятности долго играющие .по крайнкй мере они не короткоживущие. 
 именно они нагрузят нам систему основательно. а помеха она скоро уйдет и мы о ней забудем.
 сигнал T=15мин он нарастает от нуля до MAX за T/4=3.75мин плюс также надо помнить что 
 у LA есть лаг 1 минута для таких синусов. итого синус T=15мин. дорастет от нуля до максимума 
 за 4.75 минуты.  что значит лаг 1 минута. это  значит что при поступлении синуса на LA он первую 
 минуту будет показывать хрень. и только после 1 минуты 
 LA начинает показывать и нужную фазу и амплитуду(на самом деле 93% от амплитуды)
 который имел R(t) минус одну минуту назад. тоесть
 мы сдвигаем LA на  1 минуту назад. и после этого  наш график LA 
 начнет совпадать  с R(t)  так что первая минута LA выдает мусор и только потом...
итак наш LA показывает сколько медленных качественных процессов было на компе 1 минуту назад на тот момент.
если на тот момент синус был ноль то и у нас будет 0 на выходе  у lA. далее мы начинаем 
двигаться по времени по графиуку R(t) и через 3.75+1мин=4.75 мы будем иметь у LA максимум R(t)
если r(t) это синус с T=15мин.

тоесть LA(t=0+1мин+3.75) будет показывать сколько меделнных процессов работало на компе
в точке t=0+3.75мин которые он накопил за проомежуток [0;3.75min].
тоесть на компе один проецесс к тому времени уже отработал 3.75min. второй чуть менше
третий еще тчуть меше. и последний был запущен олько что. в целом они все работали на тот момент
и давали MAX. я пока щас заюуду что LA  имеет лаг 1 минуту. как бутто он его не имеет и сразу покаызвыет
что надо. начинаем двигтся далше по вреемени и синус наинает падать это значит что наши длиные 
процессы начинают исчезать. la падает также. они могу исчезать двумя путями либо потихньку самые старые
процессы умирают. либо старые ратают до усрачки а те что новые они помирают первыми. нам неважно. 
реузльтат один и тот же. и еще чеез 3.75 они все помрут и R(t/2)=0 и LA(T/2)=0
получается что LA(t) показывает сколько долгих процессов работает на компе котоыре родились на 
этом компе за период времени T/2 от конкретного синуса. получается T/2 >=7.5мин
но тут я вспоминаю что w1*x1+w2*x2 ... оно равно нулю уже как раз в раййоне 7.5мин и далее. 
поэтому это означает что LA(T) показывает число долгих процессов котоыре работают на компе
которые были рождены в интервале последних 7.5 минут. но так как у нас есть лаг 1мин. то это 
значит что LA поккаызвает число медленных процессов рожденных
на компе в интервале [сейчас-7.5min; сейчас-1min] 
значит как это работает. LA начинает жевать синусоиду и через минуту он выдает и фазу и амплитуду(93%)
такую же как в исходном R(T). LA имеет опрееделенный предел по поводу роста фронта сигнала R(T)
если он не превышает такой то уровень то сишнал считается хорощим , тоесть процессы которые рождаются
с такой скростью считаются хорошими что они еще долго на компе ппроработают поэтому их аплитуда и фаза
сохраняется в LA. а если сигнал растет резко. резче чем некотоыйр предел котоырй зависит от коэфициента
альфа то сигнал считается что он сокрей всего мусорный он является мусорным пиком. и от него в LA пролазиит
лишь малая часть. лоигка такая что большая часть коротких процессов она имеет крутой пик роста
и они легкий процесы и они цпу почти не грузят. он их мгнвоенно отсретливает и поэтому их аплитуду 
плюсовать в lA нет смысла. так ккак эти процессы не влияют на бузи тайм цпу. и что эта помеха скороа
закончится. таким образом короткий но резкий пик почти не полвияет на LA. а плавный синус передаст  
всю свою амплитуду в LA. LA при фильтрации опирается на резкость роста фронта сигнала. обычно 
полезные долгие проессы они не появляютс на компе по 100 штук за секунду. так появяляются толкьо 
флуктуации. если синусоида имеет некоторое значение которые покаызает число процессов работающих 
на компе то вопрос как долго эти процессы работают на компе к тому моменту. прикинем
если щас на компе время t0, пусть у нас R(t0)=0. значит самое малое время что проработал процесс
это 0 секунд. либо процесс только что погас проработав T/2 времени. то есть с прошлого нуля. 
пусь  R(t0)=b, значит столко процессов набежало 
за врремя либо t0-delta где delta это такое время что R(t0-delta)=0 либо t0-T/2+delta
где R(t0-T/2+delta)

если мы говорим о минимальном возможном времени то это t0-delta.  унас t0 это максимум 7.5 минут
t0-delta=7.5 минут - delta, где delta < T/4, минималный T=15минутб 
          0=<  delta =<  3.75 минуты

тоесть это процссы которые само малое отраболи время delta, тоесть  в интервале
[7.5мин-1мин-delta, 7.5минут-1мин]

если ткущее время t0 то [t0-1мин-delta, t0-1мин]
          
                        R(t)=0<----"0<=delta<=T/4<=6.5минмин"-------<---1мин---------|t0

 
что интерсно если LA за 1 митуту достигает текущего значения синуса.
то в случае прямоуголного сигнала lA достигает 67% от высоты сигнала. а 99% высоты за 5 минут.
прямуоугльный сигнал имеет крутой фронт поэтому он максимльно попадает под подрзрения мусорного сигнала.
что ксется макс высоты синуса то она будет достинута LA через T/4+1мин. и зависит от T  сигнала. 
минималный синус это 15/4мин. а  максимальный синус неоаграничен по T.

таким образом LA претдостваляет собой число процессов долгоиграющих которые работали на компе 
минуту назад от текущего момента. работали они  уже к тому моменту по времени delta
    
            "0<=delta<=T/4"

как видно delta может быть очень малентким. в чем же тогде его долгиграищность
она в том что учиывая что фронт роста r(t) плавный то la ожидает что в дальнейшем эти процессы 
продолжать свою работу по крайней мере в течение T/2 периода. поэтому оно полагает что это долго играю
щий будущий процесс. по крейней мере эттот процсс который может еще недолго отработал отличаатся 
от быстроиграбщего тем что у быстроигращих процессов фронт роста сигнала бешеный и с ними очент
велика вероятсность что они быстро играющие. 

поэтому термин долгигращий процесс это не факт что он долго отыграл хотя такое и может быть если 
delta уже большое , а это предположениее о том что процесс скорее всего доолго играющий оснваный 
на том что рост фронта у эттих процессов существенно отлличается от роста фронта мусорных процессов.

время которео процесс уже отработал зависит от конкретной синусоиды. 
этоможет быть как 0с так T/4  

интерсно если синус имеет T=100 минут. 
и вот мы доползли до его T/4=25 минут. и у него R(t)=N
получается да. в этом N будут процессы кооторые отработали 100минут.
таким образом долго игорающий процесс может отработать   к нашему моменту
любое количество времни от кроешечного delta_t до херовой тучи времени. собсвтерно когда
мы имеем r=1 или lA=1 то оба этих процесса могут работать от начала волдчения компа. 
поэтому какогто конерктнго промежутка времени нельзя одозначить для того числа которое 
стоит в LA. там могут быть процессы из очень давнего аптайма. в случае T=15 там конечно
все процессы зануляются макисиум через T/2=7.5 минут. 
а если мы возьемм скажем T=1000минут. у него T/2=500минут. значит такой процесс
может иметь аптайм 500 минут и так далее. а может это только что родившийся процесс с аптйомм
еще почти ноль. главное что оличает эти проецссы это то что у них плавный фронт роста 
и а это в теоририи некий гарант что это долго играющий процесс. в отличие от мусорных 
короткиз процессов с мощным фронтом роста. 

если вместо R(t) взять график дневного освещения либо дневнйо температуры то там это понять легче.
у нас есть плавные главные аккорды котоыре идут в течение дня. а есть флуктуации темпреатуры
или освещения. так вот нам в lA флуктуации ненужны. а правилная температура и правилнео оосвещение
будет менять плавным фронтом. тоже самое если взят отжимания. истинный скилл будет расти 
плавно. а всякий мусорные флуктуации будут резкиеи и короткие.

что касется случая когда фронт не растет а падает. если он падает плавно то это окей.
значит наш правлльный процесс дейтсвтиельно умер в нужно время в нужно месте.
если фронт упал резко то есть большой шанс что это тоже просто говно флукуация. напрмиер если бы 
фиусировали дневную освязщенность то это могла быть муха котоаря села на фотоелемент или туча которая
закрыла солнце, если бы это были ожимания то скажем мы не выспались. тоесть если фроно упал резко
то это тоже может считать как помеха которая временно исказила правилный сигнал. поэтому вот так прям
сразу уменьшать LA нет смысла. есл у нас рабтает куча правильным долгих процессов типа сервисов
то также как маловерятно что они будут заупскться пачками также маловерятено что они обвалятся пачками.
если фронт резко упал значит возожно какаято помеха временная и фронт щас также резко восстановится. 
поэтому LA и не падает при резком паднии фрронта. 

получется LA это количество правильным долгих прцоессов котоыре работают на компе (тока не щас а минуту назад) 
и если на следующей итерации не будет помех то это же количество долгих процессов ожидается 
что продолжит работу на следущей интерации. 

ну а дальше вмешиваеся еще два фактора. первй это то что даже самая высокая частота гасится всего
до 7%. (самая выскоая частао с котором может работать la1min это (1/12) Гц.  все что
выше уже несущесвтует для la1min). второй момент это то что от 5c < T <1 5минут у нас аплитуда
гасится плавно. поэтому у нас  с разных синусов в lA будет попадать какойто коэфициент от ихних
аплитуд. тоесть будет вклад от более коротких процессов чем T>=15мин.  тоесть грубо говоря
LA=5 и в нем скажем 3 это процессы которые ожидается что будут работать 15мин и более. настоящие
длинные процессы. а остальные 2 это вклад от всякой шелупони с периодами от 5с до 14.99минуты.

и чем больше амплитуда у шелупони и помех  и чем меньше она у основного сигнала тем LA будет
больше состоять из мусора.


насколько я ппонимаю это не длинный синус порождоает длинные процессы а длинные процессы
они тлоько и могут попасть в длинный синус. они образуют этот длинный синус.ну тоесть 
невозможно нарисовать график R(t) на котром есть 5 длинных процессов котоыре бы можно было математ
ически задать коротким синусом.  их можно нарисовать только через длинный синус.


>>>
если есьт R(t) и мы хотим в его точке посчитать LA(t0) то идет ряд w1*x(t0)+w2*x(t0-dt)+...
так вот из всего R(t) длингого рядоа в реальностиработает  только последние 5-7 минут.
остальное нули. это можно легко показать 

w(i+1)=w(i)*p
нао показать  как убывают кофжицимнеты


значит четко видно  что из xn  в формуле summa (wi*xi+...+) у нас от функции испольуется только
последние 5 минут. не более. это первый момент тоесть толко последние 5 минут дают вклад в LA.
второй момент - wi*xi ужимает на график. далее находится сумма этого нового графика 
и делится на 12.5 
если синус дергается слишком часто - то за первые 5 минут у нас будет график над осью X
и график под осью X, в итоге для синуса в высокой частотой у нас не получается никак получить 
амплитуду. потому что сумма элементов никак не может достигнуть 12.5 из за наличия части графика
под осью X.  и даже когда она вся над осью X только для синуса начиная с определенного T у нас 
график достигает наконцец 12.5

так вот практика показала что сдеформиоранный график wi*xi набирает в сумме 12.5 только 
если R(t) в течение 5 последнх минут целиком лежит над осью X это дает  то что сдеформиораный 
график тоже лежит над остю X и и мало того надо чтобы r(t) лежал достатно высоко
над остю X тогда сдеформированный график наконец 
сможет наборать 12.5
итак еще раз. чтобы сдержфированный график wi*xi набрал в сумме 12.5 надо чтобы он весь целиком
лежал над остью X для этого исходный график r(T) длжен последние 5 минут тоже целиком лежить
над осью X. но этого мало. надо чтобы r(t) лежад достатноно высоко все эти 5 минут только тогда
сдеформированный гафик наберет 12.5
Требовние чтобы весь график лежат над остью X последние 5 минут выдвигвает требованеи чтобы
T/4 было как минимум 5 минут. тоесть T>=20минут

так что да - практика это показала. 0) практика поазала что функция r(t) имеет значение
только ее последение 5-ть минут. все что левоее 5минут нихрнена ни на что не влияет.
что 1) r(t) доджен лежать строго над осью X втечение
последниех 5 минут. только в этом
случае сдеформированный wi*xi достигнет 12.5 
это приводит к тому что T/4 у синуса должеен быть как минуим 5 минут. тоесть T>=20минут
но этого мало , нужно 2) нужно чтобы r(t) на протяжении
последних 5-ти минут лежал достаточно высоко над остьбю X тлоько тогда его сдеофоимрованный wi*xi
сможет в сумме достигнуть 12.5

расморим на примерах. T=15 минут. у него r(t) не лежит над осью X в течение 5-ти последних минут.
и вот последствие он достигает только 92% от амплитуды.
T=20минут. он целиком лежит над остью X в течение 5-ти минут последних. и он достигает 95%
T=40 минут достигает 99% от амплитуды исходной


так конечно как ни крути EMA это текущая функция r(now)...r(0) у которой извратили амплитуду,
сложили, и поделили на 12.5 , причем за последние 5 минут. берем последние 5 минут функции. 
уродуем у нее амплитуду. складываем, делим на 12.5. поэтому EMA формируют только послендние 5 минут.

надо узнать за 5 минут у нас сумма wi достигает ли 12.5
ответ - оно равно 12.46

получется EMA получается когда у нас функция берется на интервале 5 минут. потому что все 
что левее 5 минут там у нее изуродваная амплитуда равна 0.
и делится на 12.5 
у нас summa(wi) достигает 12.5 на интервале 7 минут. но повторю что после 5 минут
все амплитуды изуродванные будут равны 0.


>> ema помнить только посдение 5 минут r(t) и при этом запзлывет на 1 минуту. 

>>  содной стороны EMA счтается по итеративной формуле а сдругой стороны по формул wi*xi
также мы занем что EMA запаздывает на 1 минуту. также мы занем что wi*xi помнит только последние 5
минут r(t). вопрос - если я возьму r(t) как синус с T=40минут это значит что от 0 до max 
он растет за 10минут что >>> чем 4минуты (5минут память -1 минута задержка). вопрос 
если я воьму  этот синус так что он с момента 0 до 4минуты достигает максимуму - успеет ли
EMA посчитанная по формуле wi*xi схватить этот максмум на 5-ой минуте?
я проверил - в приницпе работает.  тоесть у меня синус он имеет четверь периода на 10 минут.
я сдвинул фазу так что максиуум пришелся на 4 минуту. мой же LA высчитывается на 5-ой минуте.
и оно показыает 98.4% от максимума. значит проблем неь ни с памятью на 5 минут. ни с запазывадеием
на 1 минуту. 
получается EMA это вот что = EMA она берет сигнал r(t) за последние 5 минут. все что позже 5
минут оно превращает в ноль. далее мы можем r(t) на инервале 5 минут предтсвать как сумму синусов
с постоянной амплидой и частотой. и EMA он у синусов r(t) у которых T>=15минут неуродует 
фазу а оставляет ее почти нетронутой (95%) тоесть EMA берет такие синусы и высирает из себя
их "ровно такими же" единственно что с запаздываеним на 1 минуту. тоесть EMA(t0)=RR(t0-1min)
где RR это часть сигнала R(T) с длинными синусами. тоесть если мы имеем EMA(t0) то мы
берем R в интервале [t0-5min;t0] разбиваем его на длинные синусы и короткеи синусы и средние синусы
так вот EMA(t0) показыввает сумму длинных синусов R в момент времени t0-1min. теость если 
у нас R(t1)=Rk(t1)+Rs(t1)+Rd(t1) то Rd(t1)=EMA(t1+1min)
тоесть в числоовом эквиваленте EMA показывает сумму всех R у которхы T>=15мин на момент времени
t0-1min. тоесть если R(t) преставить на интервале последних 5 минут как сумму длиных синусов
и сумму остальных синусов то EMA(now) показывает значение суммы  длинных синусов в в момент R(now-1min)
длинные синумы стартут с момеента (now-5min) и заканчиваются на now-1min 
а что показвает R длинных синусов в момент now-1min он показывает сколько процессов стартануло
в в момент now-5min работало и продолжало работать на период [now-5min;now-1min] и на момент
времени (now-1min). что значать процессы котороые стартанули в рамках длинного синуса - ну это 
процессы которые уже проработали T/4 (при T>=15мин) или не проработали еще столько но 
скорей всего столько проработают. тоесть это вероятнее всего длинноработающие процессы. 
тоесть EMA вычленяеет некуб состалвющую из сигнала R(T) его длинносуществующие сигналы. и когда
этот синус движется по фазе то одни длинноживущие процессы исчезают отработав 3.75мин
а другие их замещающие влзникают взамен. EMA покаызвает эти проецссы правда с запозданием по фазе 
на 1 минуту. длинные процессы плохи тем что они сильно грузят систему (цпу). тоесть
если щас EMA=10 то он показывает что на данный момент у нас в системе работает 10 процессов которые
либо уже отработали 3.75 минуты ( и щас сдохнут) либо еще не отработали это время но будут верояетнне
всего столько работать далее. прибавление EMA покызвае увеличение таких длинных процессов убавление
EMA покаывзает что число таких долгожителей уменьшилось.  EMA покзывает это число не на данный момент
а на момент минуту назад. 

отделный случай прямоугльный импульс. он неможет расти быстрее чем синус T=20минут. так и есть. 
прямуоугльный импусль приводит EMA к 100% через 5 минут. тоесть прямоугльный импусль аналогичен 
синусу T=20мин. который можем словить за 4 минуты плюс +1мин смещение фазы. 

синус T=20мин это самый быстрый рейт роста EMA. тоесть если мы подсунем к EMA этот синус то он вырастет 
до него
за 5 минут фомально показывая его фазу за 4 минуты( 1 минута идет на лаг)

прямуоульный импульс это считай сумма синуса T=20 мин плюс все остальное синусы
выскочастоотные которое отфильтровывается по идее.


EMA работает как сортирощик отделяя короткоживущие процессы от долгоживущих.
короткоживущие они даже если их много мало грузят цпу. долгоживущие если даже их мало
очень даже грузят цпу.

К сожалениею EMA запаздвыает на 1 минуту. 
ТАкже EMA имеет память 5 последних минут. с учетом лага то 4 последних минуту начиная с 1 минуты 
назад.

таким образом елси у нас есть EMA(t0) = 10 
тоэто значит что наш сигнал R(t) в период [t0-5min; t0-1min] можно представить в виде 
короких синусов и длинных сунусов R([t0-5min; t0-1min]) = summa(Rкороткие) + summa(Rдлинные)
и наш EMA показывает сумму Rдлинные в момент времени [t0-1min]
итак момент времени мы знаем. число мы знаем. физическое значение этого число число 
процессов которые представляют собой смесь таких процессов которые либо уже отработали 4 минуты( а может 
и больше но как минимум 4 минуты) либо еще не отработали 4 минуты но по всем понятияем должны 
далее в течение по крайней мере следущих 4 минут (а может и более) продолжать еще работать. 
сколько конкретно уже отработало а сколько еще будет - это нам неизвестно. это в целом такая смесь 
которую можно назвать "процессы которые уже отработали по краней мере 4 минуты или будут далее работать
еще по крайней мере 4 минуты скорее всего"
это вытекает из свойств синуса T>=15мин. на его полупериоде (7.5мин) каждый процесс 
отработает 4 минуты (3.75мин если точнее) 
тоесть 15*sin(T=15мин) описывает 15 процессов которые за следущие 7.5мин отработают по 3.75мин(прибли
зительно 4мин) каждый.

если EMA=0 это значит что щас на компе не работает ни один процесс который либо уже имеет возраст
как минимум 4 минуты либо еще не имеет этого возраста но скорее всего отработает еще как минимум 4 минуты.
тоесть есть может бытьдругие процессы котоорые более короткоживущие. плюс не забываем лаг в 1 минуту.

интересный момент - берем даже правильоный синус T=15 мин. вот он дорос от 0 до max. но EMA 
в этой точке времени еще нам не подтвердит этот max. потому что часть процессов еще очень молодые
EMA ждет еще минуту наблюдая как себя ведут эти процессы. их число не должно падать быстрее чем 
этот синус. если за минуту после тогокак синус достиш максимума число процессов упадет значительно
это покажет что процссы были нетакие уж длинные те котрорые возникли последними. и это повляет на EMA
тоесть у нас два варианта.
1) имеем синус T=15мин ,за время [0:4] синус дорос до max и далее он падает как положено
по законму этого синуса еще 1 минуту. тошда EMA в точке (now) покажет число max указывая
что в момент now-1min у нас все процессы в количестве max были долгоиграющие

2)  тоже самое только после того как синус дорос до максимума у нас нагрузка упала в ноль. и 
мы за ней наблбдали 1 минуту. тогда EMA покажет число меньше чем max указывая на то что
в момент времени now-1min далеко не все процессы даже рожденные правильным синусом были качественные
и долгоиграющие. получается что если число процессов растет быстрее чем функция T=15 мин 
то эти проецессы избыточнце счииаются мусором. 
вот какая картина. унас r(t)=0. в какойто момент у нас повляется R(t)=sin(t=15мин) он растет.
через 4 минуты он достигнет максимума но EMA достигнет этого макимума через 5 минут. тоесть R(t)
будет в этот момент уже падать в течение 1 минуты.  причем падать правильно. именно это доказваает 
EMA что в момент now-1min процессы которые были тогдарлждены они все долговременные. а если за последенюю
минуту R(t) бдует падать слишком быстро это привеет что EMA будет меньше чем max. так как это еей
покажет что не все рожденные процессы были долговременные. а только часть. 
посмотрим на сколлко % падает sin(t=15мин) за время 1min после прохождления максимума
я проверил через  1 мин после проходжения максимума r(t) для синуса T=15мин имеет 92% от максимума.
тоесть если за 1 мин падение составило не более 8% значит на предыдущем этапе (-1мин) все процессы
были долгоиграющие. правла дальше функция падает быстрее по равннению со своим предущим велиичной
уже на 33%. и я заметил одну интересную вещь. если мы посмотрим на график дискретного синуса мы увидим
что когда он поднимается от нуля то за каждый шаг он прирастает быстро а чем ближе к верщине тем прирастает
медленно. и падает он также вначале медленно а потом быстрее. как бутто это гооворит о том что когда 
он поднимается от нуля  к вершине у него рождаются медленные процессы. а чем ближе к вершине тем процессы
более короткоживущие. поэтому погибают они в обратно порядке. вначале короткоживущие коих мало.
а последними уже долгоживущие. получается что на полупериоде у синуса внизу рождаются процессы которые
работают по T/2 времени. а те которые рождаются у вершины живут очень мало. тоесть даже медленный синус
это не набор одинаково живущих процессов с длинной работы T/4 а смесь длинноживущих T/2 и вплоть 
до короткоживущих по времени tжизни >>> 0 ... кхм..... дауж.
ко времени когда синус поднимается к верщине у него нижние процессы отраютают T/4 но предполгаается
что они отработают в итоге T/2
если синус падает быстрее чем положено за 1 минуту после верщины то это значит что те процессы которые
родились за последнюю минуту до вершины были еще более короткие чем преполагалось. а если он и далее
падает еще быстрее за следующую минуту то значит процецссы которые были рождены между минус 2 минуы до вершины
и минус 1 минуа до вершины тоже были более короткие. а если он упадет до нуля и будет так держаться 
4 минуты после вершины. то это покажет что процессы которые были рождены с самого начала тоже 
оказались более короткие чем полагалось.

тоесть елси у нас sin(T=16мин)  у него макс в T=4мин значит в T=[8min:9min] у нас происходит проверка
тех процессов которые были запущены между 0min и 1min

если у нас на 5-ой минуты R(t) упал в 0. то EMA(5min)=0.32
если у нас R(t) прдолжает лежат на 6-ой минете то EMA(6min)=0.12
если лежит на 7-ой минуту EMA(7min)=0.04
если лежит на 8-ой минуте то EMA(8min)=0.02

то длинный синус который дорос до верха полноценно но потом обвалился  - в этот момент показания LA
непонятно какой несут физ смысл. я только могу сказать в оправдение тут то что  врамках разложения
сигнала на синусы в некотором интервале означает что синус не может оборваться. это нарушение нашей
модели. синус должен обязтельно дойти до конца рассматриваемого интервала. тоесть обвал после
вершины синуса это некоректно. значит я в синусы некоректно разложил.
так- ну растущая ступенька примерно понятно как в синусы разлагаается. а вот падающая ступенька - непонятно.
походу  пьемы падающая ступенька аналогична падающему синусу головой вниз

вобщм прямогульны импусльмы надо рассматривать отдельно

также я не затронул тему про то что есть полоса частот где синусы не задавиваются  а 
имет амплитуду от 10% до 90%. и это жопа.


самое трудное - это понять физ смысл короттких синусов и длинных синусов. что они значат 
с точки зрения процессов r(t)
короткий синус по идее точно говорит про коротко живущие проецссы.

про короткие синусы
при T<=26с у нас от амплитуды остается 11% это значит что на интервале 13 секунд у нас
r(t) доходит от нула до максимума и опять до нуля. тоесть процесс рождается и умирает.
время его жизни получается ну от 0с до 26с максимум. разброс внутри непонятен. смещение фазы
порядка 0с. получается на интервале 6.5c этот синус доходит до максимума. этот выброс
доходит до максимума. тоесть это выглядит так что у нас один сэмпл внуле. второй сэмп максимум. 
следущий сэмп в нуле. следущий максимум. типа того. 
тоесть все синусы которые короче чем этот "типа гасятся".
прикол еще в том что мы не имем права при таком сэплинге рассматривать синусы у которых T<15секунд.
иначе сэмплинг не будет их коректно схватыать. тоесть наши помехи ограничены как ни смешно 
в интервале   
            15с < T <= 26с

тоесть мы полагаем что у нас нет таких выбросов у которых T < 15с
тоесть выброс котоырй доходит от нуля до максимума за 3.75с 

правда прикол в том что прямоульный сигнал очень даже имеет синусы в запрещенном интервале.!


забавно то что мы помехой считаем сигналы которые обязательно чередуют свою амплитуду  от 
нуля до макс за интервал  <13с  
хорший сигнал мы считаем такой который меняет от нуля до макс за интервал >15мин
то что посреедине - это ад.

я бы сказал что EMA1min вырезает из компа процессы у которых длинна жизни короче чем 13с. 
опять же остоой в том что вырезает но не совсем. скорее уменьшает их количество до 7-11%
правда проблема еще в том что все процессы которые  15мин<T<26с они добавляются в EMA с некоторым 
уменьшенным коэфиицентом. и даже помехи T<=26с они тоже добавляются в EMA с некотрым уменьшеным
коэфициентом. еще фаза другая у промежуточным частот. не  1 мин а меньше. тоесть низкие частоты (помехи)
проявляются на графике EMA сразу а низкие частоты с опозданием 1мин.
тоесть получается что EMA в точке t0 она состоит из низкочастотных компонентов которые 
были актуальны 1минута назад и помех которые актуальны прям щас. 
это жопа. (это надо проверить на примере)

тоесть суммарно я бы сказал что EMA показывает на 1 минуту назад по времени
число процессов которые имели на тот момент свойтва:
    1) они на тот момент имели статус R|D
    2) часть из них отработала минимум 4 минуты к тому моменту
    3) другая часть отработала какое то время но они будут по идее работать дальше
        чтобы суммарно отработать 4 минуты тоесть эта некая претензия на будущий
        обьем работы.эта претензия на обьем работы на следущие 4 минуты.типа 
        того что часть указанным процессов в EMA будет работать еще 4 минуты.
    4) процессы которые имели к тому моменту меньший срок жизни чем 4 минуты
       и которые по идее будут работать меньше чем 4 минуты далее,
       они тоже добавляются к сожалению с уменьшенным коэфициентом,
       даже самые выскочастотные мусорные проецессы и те добалвяются с уменьшеным коэфициентом.
        И вот этот пункт он ставит крест на числовой конкретике которую бы можно было получать
       через эту EMA. Если  у нас синусы в мусорной зоне и в средней зоне имеют
       значительные амплитуды то наша EMA будет иметь некое непредсказумое значение. 
       А ведь мы пытаемся через EMA найти отсортировать чило процессов с долгим сроком
       жизни. а получается так что если мусора много то он конвертируеется в длинные процессы
       как бы тоже. это пиздец. Причем дополниельный пиздец в том что чем более выскочастотный
       процесс тем он влияет на EMA прям щас а не с опозданием 1минута.  Тоесть EMA щас 
       это сумма долгих процессов минут назад и коротких процессов (с уменьшенным коэфициантом) которые
       работают щас. И на самом дополнительно это сумма синусов в средней частотной полосе у которых
       самый разнообразный сдвиг фазы. Тоесть длинный синус уехжает в EMA на 1 мин впреед. короткий
       синус влияет на EMA щас. промежуточные синусы влияют на EMA которая лежит между щас и +1мин вперед.
       это жесть.
       
>> попробвать лучше понять EMA если считать что R(t) это температура. 
возможно там есть ключ к понимаю 
надо это сделать <<<!!!

2023.24.07 15:00  17.7
                  23.6 (далее пишу темература на новый день в одно время 15:00)
                  22.7
                  24.1
                  18.6
                  17.1
                  23.3
                  22.8
                  26.4
                  23.9
                  26.8
                  28.0
                  28.4
                  30.2
                  29.5
                  25.2
                  24.3
                  24.7
                  23.5
                  20.5
                  18.6
                  21.8
                  24.2
                  25.0
                  27.2
                  24.3
                  26.5
                  20.6
                  21.0
                  19.1
                  18.6
                  16.4
                  17.2
                  16.6
                  19.0
                  19.2
                  15.4
                  19.7
                  23.7
                  

                  

>> открыл такую вещь. LA если мы высчитываем на основе wi*xi тоесть по классике
то реакция на ступеньку для n=10 и n=100 это не одно и тоже.
( 0 0 0 0 0 0 ) + ( 1 ) = один LA
и
( 0 0 0 0 00 0 0 0 0 0 0 ....... 00 ) + (1) =  другой LA

я сделал очень важное открытие. LA у нас если мы считаем его по главной формуле wi*xi 
то если у нас есть множество состоящее слева из нулей  разной длительности а справа у нас 
множество состоящее из единиц длительностью 1 минута то LA будет одинаковый только если 
множество нулей по длительности >=6 минут. Тоесть на самом деле мы всегода работаем с окном
минимум 7 минут. если у нас r(t) задан в течение 1 минуты то это значит слева незримо к нему
присоединяем окно из 6 минут из нулей (либо  это ненули а первое знаечение r(t)).
и дело вот в чем: если у нас вот так выглядит множстево r(t)
r(t) = ( 0 0 0 .....0 ) + ( 1 1 1 1 1 1)
где множстество нулей может иметь разную длинну а множстве единиц одного размера скажем 1 минута
то внезаивимости от числа нулей  верхняя часть выражения для LA w1*x1+...+wn*xn 
она все время одна и таже, но нижняя часть w1+w2+...+wn она все время разная поэтому в целом 
LA для r(t) = ( 0 0 0 .....0 ) + ( 1 1 1 1 1 1) он должен быть все время разный в зависимоси от числа 
нулей. но так как в знаменателе стоит убывающая хрень то если у нас множстево нулей по длине равно
6 минут или более то тогда у нас знаменатель всегда один и тот же ~=12.5 
тоесть хотя формально LA можно высчитать для множества которое по длинне любой длины например 
длина 1 минута. но я бы сказал что если мы считаем LA то мы всегда операируем окном минимум 7 минут 
исходных данных! почему? поому что если у нас окно исходных данных 7 минут и более то если мы к этому
окну доавим некий импульс например квадратный импусль длинной 1 минута то у нас всегда отклик LA будет
один и тот же для этого импульса если за ним стоит данных 6 минут или более. а если у нас данных 
стоит меньше чем 6 минут то отклик системы на наш эталонный импусль может быть совереенно разный.
это очень неудобно. потому что LA вот для таких двух множстев будет разный

r(t)=( 0 0 ) + ( 1 1 1 )
r(t)=( 0 0 ...... ...... 0 0 0 0 ) + ( 1 1 1 )

но есть и еще причина почму надо считать что мы работаем всегода минимум с 7 минутами данных.
потому что итерационная формула тоеть не та которая основаня wi*xi а итерациооная
    ema(n)=(1-p)*ema(n-1)+p*r(n)
она верна только если мы наше множество данных минимум по длинне 7 минут.если данных меньше чем
7 минут эта формула неработает. она неверна. она сходится с основной формулой , с определением как говориися
толко если мносжтво данных минимум 7 минут.

поэтому если скажем у нас есть таблица температур за 1 минуту то ее надо расширть налево до 7 минут.
6 минут надо забить первым значением из таблицы температур.  формально мы вообще то типа делаем неверно.
мы искажем исходные данные и получаем LA который не соотвевтует тому LA который бы мы посчитали 
по класической формуле за 1 минуту. но я повторюсь о том что у нас LA на компе с линуксом высчитывается
через итерационную формулу. а она начинает давать верный результат толко если у нас множество данных 
накопиль минимум на 7 минут. тоесть на компе с линуксом вот мы включили комп. и он сразу начинает счиатать
LA по итерационной формуле. это значит что как бы подразумевается что линукс как бвы автоматом присатраивает
к нашим реаьным данных слева таблицы на 7 минут с нулями. тоест комп до того как мы его включили уже 
как бы работал 7 минут r=0 и LA=0 на момент t=0

        
поэтому если у нас данным еще меньше 7 минут то иитерационая формула она неприменима. 
она применима только посл того как данные накопилиь до 7 минут. до этого момент надо юзать класическую формулу.
если же у нас данных меньше чем на 7 минут а мы уже применяем итрацилную формулу то это значит 
что мы мысленно доавяем слева к намшим данным таблицу до 7 минут длинной наполенную первым число r(0)

если у нас данных меньше чем на 7 минут то я бы сразу бы считал по итерационой формуле
либо добалял слева массив из 7 минут наполенных r(0) потому что хотя это в целом и неверно но 
если мы будем начинать с la=0 то LA будем целых 7 минут выходит на равновесное положение. а мы хотим
это сделать как можно быстрее.  я бы сказал так что если у нас данных <7минут то я бы нашел среднее
арифметическое SMA на тех данныз что есть и если мы пользуеся итерацоннрй форулой то взял 
бы LA(0)=SMA а если формулой wi*xi то слева прилепил бы таблицу на 7 минут из (SMA... SMA)
таким макаром наша LA на интервале до 7 минут будет как бы формально неверной зато она будет мало прыгать
и уже будет находится близко от равновесного положения на которое она выйдет толко к концу 7-ой минуты 
реальных данных.

а так конечно понятно что 

LA=0 от r(t)=( 0 0 0 ............... 0 )  при любом наборе нулей
но формально LA будет разный вот для этих множеств

LA от r(t)=( 0 0 0 ............... 0 )  + (1)
LA от r(t)=(1)


зато LA будет совершенно одинакоый для множстев

LA от r(t)=( 0 0 0 ............... 0 )  + (1)
LA от r(t)=( 0 0 0 ............... 0 0 0 0 0 0 0 )  + (1)
если длинна множсетв с нулями в обоих случая >=7 минут

поэтому когда говорят что если на линуксе дать квадратный импульс то LA через минуту достигнет 66% от него
это верно только если линукс уже проработал 7 минут. 
если он прораобтал меньше 7 минут то он покажет конечно тоже самое но это вообще то неверно потому что 
в линуксе LA если он работает до 7 минут вычисляется по формуле которая неприменима тоесть итерационная.

поэтому елси у нас множстево имеет меньше 7 минут по времени надо четко понимать по какой формулн 
высчитывать LA. и надо понимать по какой формуле LA высчитал кото другой для этого множстева. этот другой
мог исползовать непримениую к этому случаю формулу итерационную как это делает линукс.
после того как комп пораобтал 7 минут эта проблема исчезает

поэтмоу еси мы хотим посчитать отклик системы если в нее подать постоянный сигнал длительностью 1 минута
надо четко понимать мы хотим посчитать отклик в системе коотоаяр уже проработала 7 минут или еще
не проработала.  если система прорабоалала 7 минут то считать можно по обоим формулам : класической
и итерациоонной. если система не прораобтала 7 минут то итерационная непримениама. рпименима только 
классческая. но также надо понимать что если мы говорим про линукс то он покзвыает в этот период неверный LA
и чтобы подогнать под то что он показывает нужно слева к данным прибавит фейковый массив из нулей длителностью
7 минут. 

поэтому линукс польщуясь интеационной формулой как бы всегда полагает что комп уже отработал 7 минут. 
если комп не отработал то линукс как бы прибавляет слева массив из нулей длтительностью 7 минут.

так как на EMA в коенчном итоге влияеет R(t) за последние 7 минут. то этот неравлнй подход  через 7 минут
становится неважным и начинает показыват правльные данные. 

так вот в частности какой прикол из этоого если у нас есть  вот такой массив
r(t)= ( 0 ) + ( 1 1 1 1 1 1 1 1 1 1 1 1 1)

то LA( r(t) )  = 0.96

тесть если у нас начальный массив данных очень мелкий и мы в нем подаем r(t)=const
то LA посчитанный по всем правилам покажет то что LA через 1 минуту как появился сигнал r(t)=const
выдет не на 66% от этой константы а на 96% !!! но такой отклик системы будет только в пределах
когда у нас комп поработал меньше минуты и мы LA посчитали математически правилным путем а не как 
это делает линукс на этом промежутке времени неправильно.

тоесть еще раз - лиункс считает LA используя итерационную форулу . а она применима толко 
если массив данных 7 минут и более уже накопился. если он менее 7 минут то иткрцинная форула 
показывает совершенно енверный LA. но это все становится неважно после 7 минут. после 7 минут
она начинат покзывать верный LA даже несмотря на то что до этого покзывала хрень. 

поэтому когда люди говорят что подак постоянный сигнал на линукс LA через минут дстигнет 66% 
это вообще то верно толькпо при суловии что комп уже проработал 7 минут. если комп проабьал мнеее 7 минут
то LA можт достигнуть и 96% от нагрузки. но опть же - в линуксе мы этого не обнаружим потому что 
у них LA считается на этом участке неверно. поэтмоу в линуксе когда бы ты ни подал постоянну нагрузку
всегда через минуут LA достигент 66% от константы.

именно поэтому когда я в самом начале изучения LA пытадсяполучить 66% от конст 
на массиве данных (0) + ( 1 1 1 1 1 1 1 1 1 1 1 1 1 ) я никак не мог получить 66%
это очеень важно все понимать. виной все потому что линукс для такого множства юзает 
итерацинную формулу. а этого делать нельзя !!! но линукс делает. 

>>>>>>   насколоя помню дело обстоит вот так - если мы натрвалваем на ema низкочастотный синус
то ema сдвинает его фазу на 1 мин впреед. тоесть ema у такого синуса убегает на 1 мин вперед

у среднечастоного синуса ema убегает на 0.5 мин вперед

у выскочатстоного синуса ema никула не сдвигается амлпитуда уменьшается до 11%

значит ema в точке t0 показвыает сумму r(t) низкочастотные синусы 1 минуту назад. + среднечастотные 
синумы за пол минуты назад + низкочасатотные синусы за сейчас. значение ema по величине 
складывается так : 95% от суммы амплитуд длинных синусов + 11-50% от суммы амплитуд средних синусов
+ 0-11% от амплитуда коротких синусов
Тоесть мы берем сигнал r(t) за последние 7 минут. рисуем его как сумма синусоид коротких, длинных
и средних. находим чему равно значение длинныз в момент now-1min (это будет A), находим чему равно значение
средних синусов в момент now-0.5min (это будет B) плюс находим чему равно значение коротких синусов сейчас.
(это будет C) .

далее A нужно умножить на 0.95 , B умножить на 0.5 и C умножит на 0.11 , далее сложить 
и мы полуичм EMA в точке now
   ema(now) = A*0.95+ B*0.5+ C*0.11
   
если говорить про обратную задачу - у нас есть EMA в точке now. что мы можем сказать 
про R(t) - ?

 0 5 10 15 20 25 30 35 40 45 50 55 60 | 65 70 75 80 85 90 95 100 105 110 115 120
 1 2  3  4 5  6   7  8  9 10 11 12 13 | 1  2  3  4  5  6  7  8    9  10  11   12
 1 2  3  4 5  6   7  8  9 10 11 12 13   14 15 16 17 18 19 20 21   22 23  24  25
 0 ...                             12   13 ...                               24
 
 
 далее
 формула
 
 An=(2/T)*B*tau*[sin (wn*tau*0.5)]/(wn*tau*0.5)
 
 
 wn=n*(2pi)/Tбаз, n=1,2,3
 An=(2/(n*pi))*sin(n*pi*0.25)
 
 
>>> вывел такое правило. у нас три близких синуса могут на картинке дать холм 
который имеет новый T. тоесть суммрование трех синусов (T=10м + T=5м + T=3м ) дает
новый синус с T~=2.4м и он получается по высоте такой крутой. 
вобщем синус вроде норм но мы в него входим с прямой. и когда мы входим в него с прямой
то у LA идет излом на входе в его первый склон и на выходе со второго склона. 
таким макаром меряем время между тем когда LA начал расти и когда он началл падать (от основания
его левой наклонной вверх то вершины) и получаем примерно какой T/2 у исходного R(t).
далее смотрим у меня полулось 2.2м. потом смотрим в таблицу какой сдвиг фазы для такого R(t) и 
сколько по амплитуде нужно прибавить. для 2.2м это 27с и 40%. хотя сдвиг фазы можно в приицпе
не смотреть. пик r(t) нахрдистя примерно посередине наклонной вверх у LA. а пик надо поднять на LA/0.65

кстати насчт того почему полка r=const выходит на нее через 7 минут. потому что 
A*w1+A*w2+...+A*wn=A*(w1+...+wn)

LA=A*(w1+...+wn)
   -------------- =A при любом количестве n. хоть малом хоть больщом. 
     (w1+...+wn)

просто прикол в том что линукс применяем итерациуонную формулу которая неработает на малых n
поэтому переходит от 0 до 1 скажем занимает 7 минут. потому что итерациооная формула 
работает только минимум на окне 7 минут. если мы воьзлем данные за 7 минут и примени класическую формулу

LA =   (r1*w1+r2*w2+r3*w3+...+rk*wk) + (A*w(k+1) + A*w(k+2) + ... A)
       ------------------------------------------------------------
          w1+...+wk+w(k+1)+...wn

если w(k+1) ... wn составляют по длинне 7 минут то их сумма дает 12.5 тогда 
    (A*w(k+1) + A*w(k+2) + ... A)=A*12.5
    
так как wk лежит левее чем 7 минут то эти коэфииценты все практически равны нулю так что 
сумма (r1*w1+r2*w2+r3*w3+...+rk*wk) практически равна нулю. 
а нижняя сумма в занменателе всегда равна 12.5 при большом n поэтому

         0 + A*12.5
LA = -------------------------  = A
            12.5


тоесть видно почему при больщих n при появлении полки  в нагрузке нужно 5-7 минут чтобы LA 
стал равен этому A

а если  у нас r(t) это не полка а синус которые растет гораздо медленее то ему  минимум 10 минут
и sin(T=20минут) чтобы дорасти до максимума функции. 

получется если у нас R(t) монотонно растет на интервале то LA может дорасти до R(t) в самом 
быстром случае за 5-7 минут при условии что r(t)=Const
если функция растет медленнее как например синус то LA дорастет до максмума самое быстрое за 10 минут.
если рост идет по законму sin(T=20мин)  . если LA встречает полку то  у него происходит излом.
если LA встречает синус излома нет. значит если LA на картинке растет менее чем 5-7 минут в случае 
излома  в основании или менее 10 минут в случае без излома в основании это значит что LA недорос 
до максимума функции не успел. потому что он уперся уже в понижении функции. это значит что если нагрузка
идет в форме синусов то LA будет у них уменьшать амплитуду. и тем сильнее чем короче синус. и только
начиная с синуса T=20 он не будет у них уменьшать амплитуду но чтобы ему дорасти до максимума 
ему надо ...


во первых у ema  на ее значение в точке (now) влияет только график r(t) за последние 7 минут.
все что левее 7 последних минут не влияет. 
действиететльно

LA(now)=  summa (wi*xi (за период [-inf;now-7min]) + summa (wi*xi (за период [now;now-7min]))
          ------------------------------------------------------------------------------------------
                                        12.5

                                       
левая сумма она практически равна нулю поэтому
на LA(now) влияют только члены за последние 7 минут

LA(now) =  summa (wi*xi (за период [now;now-7min]))
          ------------------------------------------------------------------------------------------
                                        12.5

но это все верно если мы считаем по клачиеской форуле. так как ей 
для расчета нужны только r(t).                                       
а если мы считаем LA(now) через итерациоонную формулу. нам на начальном шаге нужно предыдущее
значение ema(n-1). 

    ema(n)=0.92*ema(n-1)+0.08*r(n)

причем итерационная формула начинает давать ответ ema(n) совпадающий с классической
формулой только на том этапе когда n и r(n) у нас начинаются с 7 минуты !
если мы возьмем момент времени скажем t=2 минуты и возьмем посчитаем ema(n) по классической
формуле и потом посчитаем e(n+1) по классической формуле . а потом возьмем посчитаем e(n+1)
по итерацифооной формуле то у нас 
       ema(n+1) (по классической формуле) получится неравен ema(n+1) посчитанный по итерациооной формуле.
       
потому что итерационняа формула начинает давать правильный ответ совпдаающий с классической формулой
только для n>= 7мин.
       
тоесть чтобы восполтзоваться итерационной формулой нужно соблюсти ряд условий:
1) нужно дождаться того момента коогда пройдет достаточно времени с того момента как 
заработлаа функция. и получить много x(n) так много чтобы x(n) принадлежали как минимум
интервалу времени 7 минут. а можно и больше. 
2) после эторго нужно над этими x(n) посчитать ema(n) по классической формуле.
3) и только после этого можно начать использовать неклаччиесккую формулу а итерационной
    ema(n+1)=ema(n)*(1-p) + p*x(n)

как мы в часотсности видим для старта работы итеарационной формулы нам нужно начальное ema(n) 
которое мы должны посчитать из классичекой формулы!
итерационная формула сама из себя начальный ema(n) родитть не может!

поэтому еще раз. если у нас есть функция r(t) и мы хотим начать узнавать ее ema(t) нам нужно 
вначале взять функцию на интервале [0:7min] и высчитать ema(7min) по классичисекой формуле

            w1*x(0)+.....wn*x(7min)
ema(7min) = ---------------------
                    12.5


и тольлко тогда можно начать узнавать ema для t>7min через итерационную формулу

ema(7min+step) = ema(7min)(посчитаный из классической формулы) * (1-p) + p*r(7min+step) 

вау!

из этого следует очень важный вывод - если у нас есть x(t) мы не можем прям сразу со старта
считать ema(t) по итерационной формуле. во первых потому что итерационная формула может считать 
новое значение только имея предыдущее занчение. а на старте у нас нет никакого предыдудущего значения.
ну окей - мы можем вычислить самый перввй ema(0) по классической формуле
  
                1*x(0)
  ema(t=0)= -------------------- = x(0)
                 1
                 
                 
но даже имея начальный ema(t=0) мы не можем начать считать следущий ema через итерационную формулу!
потому что итерационная фрмула начнет давать правильны ответ совпадаюий с клаччисеским ответом
только начиная с момента t>7min поэтому первые 7 минут нужно ema считать по классике и только 
потом можно переключиться на итерационную формулу!

также получается что если у нас дана фаункция только на отрезке t<7min то на этом отрезке
ни в одной точке совершенно нельза считать ema по итерационной формуле
вот картинка

 t ---------------- t<= 7 минут (еma можно считать только по классичке)------->-----
 ------t>7 минут (ema можно считать по итерационной формуле) --->



так вот в чем прелесть ema. если мы хотим узнать ema в ее лубой точке t
то нам ненужен ее полный хвост. чтобы посчитать ее EMA в точке t надо взять 
только ее последние 7 минут и посчитать ema по классической формуле. 
потому что исходя из классической формулы EMA в точке t зависист только от промежутка
времени t[now-7min: now]

если же у нас есть  данные по функции более чем за последние 7 минут то мы можем при желании
пойти чуть другим путем. первые с конца 7 минут мы считаем ema по классике а потом для ускорения 
вычислений мы оставшееся время считаем по итеративной формуле. скажем мы хотим посмтреть как ведет
себя график EMA для фугкции на интервале 15 минут. первые 7 минут высчитываем ema по классике
а оставщееся время уже можем досчитать более быстрым способом итеративно

мы можем тоже начать считать по итеративной формуле сразу полагая что 
до того как наша реальная r(t) нагрузка возникла на компе была виртуалная нагрузка в течение 
7 минут равная некоей константе тогда к нашему моменту ema(-5с)=Const
Тогда расчет для первой реальной точки r(0) это как бы будет расчет для множества r(t) 
которые явлются вот таким гибридом

r(t)= ( A A A A A A ..... A A A ) + ( r(0) )

где A - это множество на длинне 7 минут постоянной нагрузки A  
плюс первое реальное значение.


круто!

линукс счтает ema сразу пользуясь итеративной формулой как бы предполагая что выключения компа
он имел последние 7 минут до включения компа r(t)=0 и la(-5с)=0
это неправильно. так как до включения компа комп не был включен и r(t) несущестовало.
но через 7 минут как комп у нас поработал это становится похуй ибо la(t) начинает давать 
все равно верный результат.



теперь когда я научился понимать когда по какой формуле считать. и вообще порнимать все это
дело возникает очень важный на практике вопрос - как ведет себя EMA когда она идет например 
по нагрузке r=const и напарывается на синус.
все это на происходит на промежутке 7 минут.

значит что я открыл теперь дполнительно когда я узнал как правилно считать EMA.
оказалось что EMA это как бы функция из двух частей. - одна ее часть это на первых 3-4 минутах.
поведение EMA на этом куске существенно отличается от ее поведения на втором оотрезке [4; +inf]
искажение амплитуды и смещение фазы у EMA на первом отрезке [0;4] и на втором отрезке [4;+inf]
существенно разные.  

поэтому тут я прихожу к фундаметальному вопросу :
пусть у нас есть точка t0 в ней ema(t0)=ema0
далее мы имеем уже r(t) на отрезке 7 минут. так вот возникает вопрос - насколько 
можно считать ema по классической формуле на этих последних 7 минутах если поведение ema 
как я выяснил на трех-четырех минутах ведет себя совсем не так как ведет себя ema на отсальных минутах. 
а так как мы знаем что наши 7 минут они не первые а сущесвтенно дальше то получается что 
то что я говорил ранее - что на EMA влияет только последние 7 минут - оказалось как бы нетак...
получается такая вещь - что если мы берем какой то кусок r(t) где то там далеко 
впереди напрмиер t=[500,520]  то чтобы получить ровно те самые настоящие числа ema которые на этом куске
показало бы классическое ema если бы ему подсунули xn на полном участке расчета t=[0;520]
то нужно брать t=[500-4мин;520].
тоеть если мы хотми узнать ema на каком то последнем участке функции r(t) то мы неможем просто 
взять последие 7 минут. потому что если мы на этих 7-ми минутах начнет в лоб считать ema по классике
то первые 4 минуты мы будем получать EMA которые несоотвувтуют ema который бы мы получили в этих же
точках если бы начали высчиывать ema по классике но на полном учатске времени. итак еще раз
пусть  у нас t=[0, 50]
мы посчитали в каждой точке ema как положено работая с полным массивом t=[0,50]
далее мы хотим посчитать ema на последних 7-ми минутах но используя не весь массив t=[0,50]
а какой то существенно меньший промежутов времени. так вот мы должны учитывать что если мы возьмем
последние 7 минут и начнем на них через классичекую формлу счиатть ema то показания за первые 3-4 минуты
будут фуфелом. чтобы посчитать ema такой какой он есть за последние 7 минут надо взять последние
7+4 минуты = 11 минут. посчитать на ней по классике ema. и тогда график ema на интервале (последние 7 минут)
будуо соответсвтовать правде. а первые 4 минуты это  будет фуфел но он нужен чтобы получить верный ema 
на оставщихся 7-ми минутах.
поэтому - если мы хотим посчитать значение EMA в точке (now) то надо взять r(t) на интервале t=[now-4min;now]
посчитать на этом множесвте EMA по классике, тогда все значения на этом интервале будут фуфелом 
но единственно настоящее знаение EMA будет EMA(now).

если мы хотим узнать EMA (now) через итеративную форумулу то надо взять функуию r(t) на интервале
последних 7 минут. потому что раньше этого интервала итеративная формула неработает. далее 
надо через классичскую формулу посчитать EMA(now) тогда в момент времени (now+5с) мы уже можем
узать итертивруную формулу

    EMA(now+5с)=ema(now)*(1-p) + p*r(now+5с)
    
и во всех последующие t>7мин
Если у нас t>7мин и если мы знаем ema в момент времени t1 котоырй принадлжеит этому интервалу 
и мы знаем ema(t1) то тогда мы можем через итертивную формулу узнать все последующие EMA
Итак - если у нас есть R(t) но не сначала ее работы а где то с конца. сколько то посоедних минут.
и если мы хотим начать получать ema такие как если бы мы знали r(t) на всем интервале ее работы
то классическая формула нам позволяет это сделать если унас есть последние 4 минуты работы r(t).
зная поседние 4 минуты мы начнем получать акатульные значения ema.
если мы хотим использовать иртеративную формулу. то нам надо иметь последние 7 минут работы r(t).

Если у нас есть график R(t) за последние скажем 15 минуты  и мы хотим посмотреть какие ema 
были на протяжении этого графика то чтобы получить настоящие цифры EMA 
нам надо заюзать класическую формулу на этом множестве. При этом значеие EMA которые мы будем получать
первые 4 минуты - будут мусором. и только оставшиеся 11 минут мы будем получать верные EMA цифры.
посльку вычсление EMA через классическую формулу отнимаем много времени то через 7 минут надо уже
подключать итеративую формулу. общий алгоритм такой.
есть график r(t) за последние N минут , причем N>=4 минуты как минимум. тогда
Для первых 7 минут мы считаем по классике для оставшихся минут мы считаем по итеративной формуле.
И также помним что первые 4 минуты надо игнрировать полученные EMA так как они будут фуфел.

например мы хотим посмтреть EMA для последних 2 минут. 
значит нам надо либо 4м+2м=6м последних r(t) чтобы посчитать по классике 
либо на надо 7м+2м=9минут последних r(t) чтобы посчитать по классике+итеративная формула
либо нам надо последних 2м но нам также надо ema(now-2m) чтобы по ней рассчитать эти две 
минуты.

но все таки учитывая что в любой отдалеьнной точке t>7min  у нас всегда верна и класическая
формула но посчитаная на полном множестве t=[-inf; now]
тоесть
      summa (wi*xi+ ...на интервале [-inf;now-7min)) +  summa (wi*xi+ ...на интервале [now-7min;now))
LA =--------------------------------------------------------------------------------------------------
                           12.5

и поскулку первя сумма равна точно практически нулю то я скажу вот что:
если мы хотим узнать EMA в точке(t0) то по расчету по классике нужно 7минут до этого r(t) иметь.
тоест t=[t0-7min;t0] и во всех точках мы получим фуфел но вточке t0 и в последующих мы уже получим
истину. причем в последующих точка уже можно юзать итеративную формулу.
Итак если я хочу посмотрет настойщий график EMA за последние 5 минут. томне надо последних 7м+5м=12минут
тогда на множестве 7 минтах с хвоста[now-12min,now-5min] я высчитвыаю по классике ema в точке (now-5min) 
ema(now-5min), а далее уже строю график интерсующих меня ema используя итеративную формулу как мало ресурсо
жрущую.

>>> !!! по идее это должно значить на практике вот что:
    - я беру реальный график r(t). на полном множсетве. я вычияляю по нему реалный EMA в точке (now)
далее я беру последние 7 минут r(t) вычисляю по нему ema(now) и оно должно совпасть.
    - также я беру итерационную формулу подставляю в нее в качестве la0=r(now-7min) 
далее я высчитываю ema(now) и он тоже должен совпасть с эталонным значением.

     - также надо подумать про такой вопрос у нас есть R(t) за последние 7 минут. и у нас есть 
некий la0 в точке r(now-7min) по идее должно быть так что какой бы там la0 ни был он все равно 
должен через итерационную формулу в точке (now) показать оодно и тоже эталонное значение.
это надо все проверить на практике. это бы доказало что на ema в точке now влияет всего навсего
только последние 7 минут графика r(t). и не вляет оставщийся хвост. и не влияет la0(now).
но при этом надо четко помнить что таким макаром мы можно получить на интервале 7 последних минут
только одну точку ema в точке (now) чтобы получить на всех последних 7 минутах правдиный график нужно
7+7=14 минут графика r(t) последнего. это все надо провертть в следущий раз


итак первое утверждение  я проверил и оно работает: 
    "я беру реальный график r(t). на полном множсетве. я вычияляю по нему реалный EMA в точке (now)
далее я беру последние 7 минут r(t) вычисляю по нему ema(now) и оно должно совпасть."

я взял реальные графики r(t) на длинне 15 минут. посчитал там 
реальный ema(t). потом я взял только хвост этих графиков за последние 7 минут. и посчитал ema по 
классической формуле. и получается обсчитав только хвост r(t) я получил в точке r(15мин) ровно такое
же ema как оно есть в реальности когда мы считем используя полный временной набор. 
также я увидел еще раз то что высчитывая ema по хвосту r(t)  первые 3.5-4 минуты (тоесть 
это моменты времени с 8-ой минуты по 11.5-12 минута если мы говорим про исходный временной отсчет)
ema которое мы получем 
оно мусорное. а вот дальше оно уже неотличается от настоящего. но я по прежнему буду придерживаться того
подхода что если мы взяли хвост за последение 7 минут и считаем на нем по классичекой формуле ema то 
надо считать что мы получим настоящий ema только на конце самом на конце 7-ой минуты с хвоста, хотя
как уже сказал мы начнем получать настоящий ema уже начиная с 5-ой минуты с хвоста. тоесть еще раз 
покажу на картинке

вот у нас исходная временная шкала 

0 |------------------------------------------------------------------------------------------------->15мин

15 минут я взял чисто для примера. 

я на ней считаю ema как положено использя полный временной набор. получаю ema(t).
далее я беру только последние 7 минут r(t)


                                  7min|------------------------------------------------------------->15мин

и высчитываяю ema(t) на этом умегьшенном временном наборе r(t) 
так вот как показал экспримент вначале я буду получать мусор а не  истинный ema и потом начну
получать уже такойже ema настоящий который  я получил считая на полном временной наборе.
и выглядит это так с 7-ой по 12 минуту я получаю неверный ema, а далее уже получается такой же
верный ema как я считал когда на полном временном множестве r(t)

        здесь неверный ema                     здесь верный ema
7min|----------------------------->13min|-------------------------------->15мин


но я перестраховываюсь и считаю что при расчете ema по хвосту 7 последних минут я буду получать верный
ему только в самом конце 15-ый минуты.



далее я проверил и подтвердид следущее утверждение:
    "также я беру итерационную формулу подставляю в нее в качестве la0=r(now-7min) 
далее я высчитываю ema(now) и он тоже должен совпасть с эталонным значением."



далее рассматрваию следущиее утверждение
     "также надо подумать про такой вопрос у нас есть R(t) за последние 7 минут. и у нас есть 
некий la0 в точке r(now-7min) по идее должно быть так что какой бы там la0 ни был он все равно 
должен через итерационную формулу в точке (now) показать оодно и тоже эталонное значение.
это надо все проверить на практике. это бы доказало что на ema в точке now влияет всего навсего
только последние 7 минут графика r(t). и не вляет оставщийся хвост. и не влияет la0(now).
но при этом надо четко помнить что таким макаром мы можно получить на интервале 7 последних минут
только одну точку ema в точке (now) чтобы получить на всех последних 7 минутах правдиный график нужно
7+7=14 минут графика r(t) последнего. это все надо провертть в следущий раз"

оказалось что оно не совсем верное.
у нас в t=now-7min график имел r(now-7min)=10
я взял ema(now-7min)=-100 как начальное значение для вычислений по итерацилнной формуле. у меня 
в точке now ema почти сошлась с настоящией в точке (now) тоже самое касаеься когда я взял ema(now-7min)=100
сошлась также с той степенью точности - тоесть почти.
а когда я взял ema(now-7min)=-1000 то уже хрень сходится в точке now. 
ТАКИМ ОБРАЗОМ надо подумать и понять почему классичкская формула применяемая на хвосте
r(t) сходится к рельному емa в точке now а итерациаооная нет. для итерационной важно задать правильный
ema  на левой части хвоста


значит я выяснил вот что : 
если у нас есть промежуток времени [0;t]  и на нем  фунция r(t)
то 
                           summa (wi*xi)
LA= ------------------------------------------------------------------
                              12.5
                              

    
пусть для определенности t=30min.
возьмем и разделим члены в сумме на две группы. в левой будут стоять члены принадлжещие времени 
t=[0;10min] а в правой сумме члены которые принадлежпт t=[10min+5s;30min]




               summa (wj*xj)   +       summa (wi*xi)
LA(30min)= ------------------------------------------------------------------
                              12.5

                        
                        
у суммы wi*xi коэфициенты wi начинаются с 1 
у суммы wj*xj коэфициенты начинаются с нутипа примрно e(-240/12)
                        

возьмем  и разделим эти две суммы вот так


             summa (wj*xj)           summa (wi*xi)
LA(30min)=  ----------------- +   --------------------
               12.5                   12.5



исходное выражение мы этим никак не изменили. 
         
сумма которая стоит справа она в точности аналогична LA для функции r(t) так если бы она начиналась 
с момента времени t=10min+5s а до этого как бы функции вообще не сущестовало.
         
а левая сумма чуть по хитрее. мы ее щас возьмем и добавим к ней 0 ничего в ней непоменяв но 
это нам даст кое что

      summa (wj*xj)      summa (wj*xj) + ...... + 0.92^1*0+1*0    
 ----------------- =  --------------------------------------------  
         12.5                    12.5
                        
тоесть мы неизменили эту сумму но теперь можно заметить что эта формула аналогична формуле 
LA в точке LA(30min) для такой функции которая на интервале t=[0,10min] аналгична исходной
функции а на интервале t=[10min+5s;30min]  функция равна нулю.

тоесть левая сумма по своему физ смыслу равна такому LA от нашей исходной функции как бутто 
мы взяли нашу исходную функцию на отрезке [0,10min] а потом начали ее двигать влево а всего новые 
значения у нее были 0. если я возьму нашу функцию на t=[0;10min] и вычислю для нее LA(10min)
то ее новый la в точке t=30min при условии что она двигалась влево имея при этом все время 0
можно вычислить по формуле

LA(n+1)=0.92*LA(n-1)+0
la(0)=High
la(1)=0.92*High
la(2)=0.92^2*High
la(n)=0.92^n*High

la(0)=High
la(5s*1)=0.92*High
la(5s*2)=0.92^2*High
la(5s*3)=0.92^3*High
la(t)=High*0.92^(t/5), t=в секундах

а именно
la(30min)=la(10min)*0.92^(t/5)
где t это то время в течение которого наша функция имела 0.

тоесть наша левая сумма 



      summa (wj*xj)      summa (wj*xj) + ...... + 0.92^1*0+1*0    
 ----------------- =  -------------------------------------------- =  la(10min)*0.92^(t/5)   
         12.5                    12.5

         
тоест наша левая сумма зависит от lA на момент разреза функции и от того сколько времени
прошло с момента разреза. чем больше времени прошло и чем меньше был LA на момент разреза
тем эта левая сумма быстрее обращается в практически ноль.

зачем я это разбираю. дело в том что я хочу понять если у меня есть больщой интервал времени t=[0, +10000]
то как сильно назад мне надо отрезать хвост чтобы хвост был почти равен нулю. и тогда левая сумма 
равна нулю. и мне чтобы посчитать LA на данный момент ненужно знать функуию на всем t а достаточно
знать ее на какомто последнем участке.

пусть у меня скажем LA(10min) = 10 000 хотя такой нагрузки на компе быть то не может. чтобы r был 
равен 10 000. и пусть скажем я хочу чтооы сумма левая была равна 0.01 тггда

10 000 * 0.92^(t/5)=0.01
тогда t получается равен 840 секунд или 14 минут.
тоесть это говорит о том что если у нас был r(t) и он достиг высокого значения 10 000. а потом 
прошло 14 минут. то этот набор r(t) через 14 минут внесет вклад в общий LA через 14 минут всего 
как 0.01 в абсолютном значении. тоесть получается что с большой долей точности можно утверждать что 


LA(now) = LA(за последние 14 минут) +- 0.01

таким образом если мы считаем LA не через итеративную формулу а по классической то нам достатчно иметь
r(t) за последние 14 минут. и тогда мы с огромной точностью можем рачсчитать LA в момент сейчас 
не имея полного набора всех r(t) а используя только r(t) за последеие 14 минут.
таким образом когда я рантше утверждал что нам достатчно тольо 7 минут иметь. я был неправ. 
тогда я утверждаю. если же мы хотим использовать итерационную формулу то я бы описал так алгоритм.
берем 14 минут последних у функции. первые  7 минут считаем по классике. остальное время юзаем итерационную
формулу. 7 минут я взял из того соображения что через 7 минут знаменатель summa(wi) стаблизируется
и достигает своего максимума. и классическаая формула преварщается в итерациоонную. 

кстати чем характерен LA1min - тем что у него для длинных волн у которых он не уродует
амплитуду он дает задержку фазы 1 минута! еще через 1 минуту r(t) в сумме wi*xi
получает такой wi что wi*xi падает в e(1) раз. 

ну  а вообще это прикол что LA(now)= LA(t=0;t_разреза)*[0.92^((now-t_разреза)/5)] + LA(t_разреза;now),
если выбрать t_разреза так что now-t_разреза>=14мин то левое слагаемое <= 0.01 тоесть ~= 0
и им можно пренебречь. тогда

    LA(now)= LA(r(now-14min;now))

    
если же точка разреза такова что она ближе чем 14 минут. то тогда LA который в ней есть
нужно уменьшить вот в такое количество раз LA(t=0;t_разреза)*[0.92^((now-t_разреза)/5)]=
=LA(t=0;t_разреза)*[e^((now-t_разреза)/60)]
    если delta_t=1min то LA=LA(t_разреза)*e(-1)=LA(t_разреза)*0.37~=LA(t_разреза)/3
    если delta_t=2min то LA=LA(t_разреза)*e(-2)=LA(t_разреза)*0.14~=LA(t_разреза)/9
    если delta_t=3min то LA=LA(t_разреза)*e(-3)=LA(t_разреза)*0.05~=LA(t_разреза)/27
    итд

проблема анализа LA через сумму LA до разреза и LA после разреза  в  том кстати
еще что ema на периодах меньше чем 5 минут ведет себя спцифически
    
    
после такого анализа. можно переходит  к следущему шагу - анализиовать реакцию EMA 
на вход в горб синуса. этим займусь в следущий раз.



====
при каких своствах валидна итеративная формула?

про разрез функции. когда общий t=7min.  когда слева 7 мин, когда слева и справа по 7 мин.

про то коогда реально влидна формулы la(t)=0+la(last 14min)
la(t)=la1(t)+la2(t)
где la1 для функции такая что до t1 она r(t) а потом 0. 
а la2 такая что до t1 она 0 а потом r(t)


про то какое значение функция достигает на пике синуса при пересечении его боковой стенки

о том что смеещение фазы 1 мин говорит о том что до этого момента у нас ema это не исходный синус
а только после уже синус. но он может до эттго не дотянуть. потому что исходный синус может исчезнуть

сама по себе одинарная точка ema нам почти нихрена не дает. к ней можно придти за последнюю
минуту совреренно разными путями r(t). одинарная точка опчти беспоелезна в плане r(t).
единственное что можно получить оцентку что за последнюю минуту средняя r(t) 
лежала в пределах  0 <= r_sr(t) <= 2.62*LA(now). это едиснтенное что дает одна точка la.
другое дело когда у нас есть множество точек ema  только их график. если есть график
ema(t) то мы можем вычислить r(t) в кажой точке путем r(t)= [ema(t)-0.92*ema(t-1)]/0.08
если на графике ema(t) проглядывается какая то макромструктура(какойто явный холм) то значит
в исходном r(t) был либо r=const на этмо участке либо был какойто синус на этом участке.

про то что ema(t)=ema(t-1)+0.08[r(t)-ema(t-1)]
и это гооврит о том что если r(n+1)>ema(n) то ema(n+1)>ema(n) тоесть. если ema растет 
то r(n) на этом участке всегда выше ema(n-1).
если же ema падает на участке t то на нем r(n+1) всегда ниже ema(n)
тоесть до тех пор пока у нас r(t) больше выше чем ema(t) то ema будет подниматься. 

точка ema(now) явялтся суммой трех отдельных синусов: 0.95*значение длинного синуса в момент времени
одна минута назад + 0.5*значение среднего синуса пол минуты назад + 0.10*значение короткого синуса
в момент сейчас. тоесть если представить что наш r(t) это сумма трех групп синусов - длинных t>=15min
средних и коротких (T<=30с) , каждоый из которых имеет свою фазу и амплиутуду. то ema является их суммой 
их значений помноженных на разные коэифиценты для каждлй группы да еще и взятые в разные друг
относиельно друа моменты времени. я бы сказал что ema(now) показывает сумму длинных средних и  коротких 
процессов на данный момент  работащих на компе сейчас. но их число суммируется с индивиуадьными 
коэфиициентами. число кротких процессов берется с мелким коэифицентом, число длинным с большим коэфициентом.
это значит что набить величину ema могут как те так и другие. большое колчиество быстрых могут 
набить такое же число как малое число долгих.
если мы посмтрим на график ema(t) то чем он плавнее тем у нас наргрузка состоит из большого числа
долгих процессов и мелкого числа коротких прцоессов. чем унас график более дергарющийся рваный 
значит у нас на компе дохрена коротких процессов. импульнсных коротких нагрузок. 
ябы так сказал. если у нас на графике ema есть какая то плавная кривая с большой аплиутудой 
значит на компе основную роль играют долгие процессы.  если у нас плавной кривой с амплтудой значительной
нет ну или не амплитуда а равновесная линия типа ema=10 а вместо этого унас постоянно дергающаяся кривая
сильно презннаая как пила с коротким перидном - значит на компе основую роль играю стохастические
короткие процессы. как опилки.

вот у нас есть какойто LA на гарфике. за ним идет график r(t). 
в кажой следующей точке LA растет там где r(t) его больше и la пдает таам где r(t) его 
меньше. это факт. чтобы LA стабильно начал падать нужно чтобы r(t) был постянно ниже его на этом учаске
. чтобы la навал стабильно расти нужно чтоыб r(t) был стабильно выше его на этом участке. это факт.
если r(t) стабильно из себя предсталвяет чистую синусовиду то ema начинает выдавать тоже по форме синсоиду
которая имеет тот же период. и искаженную амплиду. но синусоида начинает литься из ema нераньше чем
пройдет время западывания. которое разное для разных длин синусоид. для длинных синусоид запаздываеие
когда из ema начнет литься такая же по t синусоида максимальное - 1 минута. для короткх синусоид
оно равно почти ноль тоест почти сразу выходит. а что до этого происходит? ema поглощая синусоиуду
до этго момента высирает некий горб но это не синусоида. так вот если синусоида короткая а время запаздвыания
большое то никакой синусоиды ema из себя не высрет!

LA сам по себе постоянно пытаетая упасть. через минуту вклад la0 в la(t0+1min) составляет (1/3)*la0
остльная часть в la(t0+1min) составляет разгон за счет r(t) на участке 1min.

одно очен интересное свойство
если мы видим что la монтонооо падает на участке 1 минута например. то надо сравнить la0 и la(+1min)
если la(1min)/la0=1/3 то 100% на этом участке r(t) был равен 0 !!!!!
и другое свойство. тоесть la не может упасть на участке 1 мин быстрее чем в 3 раза. это невозможно.
из за того свойства что у нас r(t) не бывает меньше нуля. поэтому если мы видим что на участке 1 мин
ema монтоноо падает. и за 1 мин оно падает в 3 раза. значит на этом куске r=0. 

также если у нас на участке 1 мин скажем r(t) монотонно растет то макс монотонный рост r(t) который
может дать это r(t)=+Const. тогда LA на этом участке 1 мин прибавится как la(now)/la(-1min)=1.63
итак если мы видим монтононны рост ema на участке 1 мин и  la(now)/la(-1min)=1.63 значит на этом 
участке была сутпенька  r=r(to)+ [la(now)-la(-1min)]/0.63

если у нас нагрузка это r(t)=Const+f1. где f1 это реально выскочастотное колебание то 
ema будет представлять собой ema=Const+ff1, где ff1 это умеьшенная в 10 раз это же колебание. которое
будет вращатся вокруг равновесной Const

если у нас R(t) предсталвяет собой набор долгоигращих процессов. скажем их 3 штуки и они работают
часы. плюс набор короткииграющих процессов число которых не превышает скажем 10 то ema легко покажет
это графически наглядно. графие будет выглядеть как прямая линия y=3 вокруг которой будет вращаться
маленькая синусоида с амлитудой 1. тоесть в приницпе можно будет разглядеть закономрноть.

да ema может работать как фильтр. таких процессов. на графике. проблема только в том что все зависит
от распделеления - амплитуда коротких процессов, амлиуда средних процессов. амплиуда длиныъ 
процессов. если у нас дохрена коротких и средних и мало длинных наш график будет прсдетслвять собой
дерганый хаос. и все.

если у нас есть тока t0 и в ней la0. далее мы расстриваем кусок t=[t0;+1,min]
так вот вот la(+1min) он на 1\3 состоит из la0. это в него вклад того что было до t0
а delta=[la(+1min) - (1/3)la0] эта величина это сугубо вклад r(t) за последнюю минуту.
поэтому кстати если delta=0 это означает что r(t) был равен нулю. 
поблема в том что прирост la за 1 минуту со стороны фнукции вида 
  | 0, t<t0
f=| r(t). t0<t<+1min

он будет разный в зависимости от вида r(t) на участке. 

поэтому я предалгаю такой подход:
беру график ema и ищу на нем зону монотонного роста. пусть это будет [t1,t2]=[6.5,8]  t2-t1=1.5мин
далее я пользуюсь вот каким свойством:

r(t)=r1(t)+r2(t)

      { r(t), t<t1
r1(t)={ 0,    t1<t<t2
      
      { 0, t<t1
r2(t)={ r(t),    t1<t<t2


LA(r(t))=LA(r1(t))+LA(r2(t))

LA(t1)=LA0(с графика) + 0 = 0.3+0=0.3
LA(t2)=0.3*[e(-1/12)*(90/5))+LA(r2(t2))=1.5

LA(r2(t2))=1.5-0.3*e(-1.5)=1.5-0.23=1.5-0.16=1.34


LA=1.34 это la в точке t2 

                  { 0, t<t1
для функции r2(t)={ r(t),    t1<t<t2


график я себе вижу так что это  примерно это синусоида на восьмую периода !!.
тоесть когда он растет от 9 до пика. а потом обрывается.
T/8=1.5 значит T=9м.
смотрим чего достигает ema у такой синусоиды на времени T/8 (под пиком) y=0.735*A
значит 1.34=0.735*A
A= 1.82
значит на участке t=[t1't2] график r(t) примерно равен r(t)=1.82*Sin(T=9мин) который
растет от 0 до A

еще мжоно на этом участке апроксимировать r=Const. из учета что 
через 1 мин у нас одстигается 63% от Сonst. из графика следует что la(+1min)=1.1
значит Cpnst=1.75


что нам дает график EMA(t)
1) мы взяв точку можем грубо оценить среднее r(t) за последнюю минуиу
2) мы можем по нему восстановить исходный r(t)
3) сам график ema как бы производит сортировку процессов на короткоживущие, средние и 
долгоживущие. и он пытается отфильтровать короткие, уменьшить число средних и не меняет
число длинных.
к сожадению ema(t) это не сумма коротких длинных и средних процессов со своими
коэфцинтами в точке t. это сумма длинных мунуту назад, сумма коротких сейчас и смумма средних
пол минуты назад. да еще с кофициантами.
если унас только длинные и только кроткие и короткие имеют небольшие аплиутуды тогда халява. 
тргда ema покаызвает число длинных процессов минуту назад плюс неболльшая погрешность за счет помех.

и тепер ьнадо разобраться что значат длинные синусы. как их период связан с длиннной процесса.
синус R(T=9min) на интервале [0;T/4]=2.25m(там где онмонотонно растет)
у нас 75% процессов от апилитуды r(t) (который мы воостановли
используя EMA график)   отработает за это время  по крайней мере 1 минуту.
Тоесть если R(t) имеет форму синуса T=9m то на интервале роста от 0 до A( за 2.25м)
будет 7 процессов отработающих минимум 1 минуту. это значит что на интервале [0;T/4] у компа с 7-цпу
будет загрузка минимум 50% busy time.

T=20мин, только 5% от всех процессов запущенных
на компе за это время T/4=5мин отработает меньше 1мин.если r(T/4)=10 значит только 1 процесс отра
ботает за это время меньше минуты. остальные 95% процессов (9штук ) проработают за это время больше минуты.
1минута/5м=20% , если у нас 9-ти процессорный цпу то он это время будет занят >= 20% по бузи тайм.
чтобы узнать точное число нужно узнать площадь синуса на T/4 и поделить на площадь прмямуогольрика(5m*9цпу).
S=2pi*10/4=2*3*10/4=15  S/(45)=33%. Итак бузи тайм 9-ти процссорного цпу на T/4 составит при этой нагрузке
33%.
если цпу 4-процессорный то через 1.3мин у нас весь цпу будеь занят на 100% и так будет длиться 
до конца 5-ти минут. а полный бузит тайм за T/4 составит:
 
        bt= [ (5m-1.3m)*4+S(синуса от 0м до 1.3м) ] / 4cpu*5m ~= [ 14.8 + 1.5 ] / 20 = 82%
        
Если унас есть график R(t) и есть цпу с числом ядер =N то мы проводим гор черту на графике R(T)
и смотрит сколько % времени у нас график R(t) находится над чертой по отношению к общему времени.
и мы делаем вывод насколько у нас система будет перегружена. будет ли это редко или это будет
постоянно.

как можно добтться чтобы LA(now) был равен 1.
1) иметь la(-1min)=0 и дать r(t)=Const= 1.5 на интервадле [-1min;now] и через минуту мы получим la=1
2) можно дать R(t)=0 на интервале [-1min;nowи ] и иметь la(-1min)=3 тогда в точке now мы получим la=1
можно изголятсья по разному - главная суть в том что если la(now)=1 это не значит ни то что 
средняя за последнюю минуту равна 1 , ни то что минимльная за посл минуту равна 1.
все это полная хуйня.

la это wi*xi за 14 посл минут

ema спиливыает как пики наверх так и провалы вниз.

если ema встречает полку наверх то она за минуту долезает до 63% от Const-la0
если ема встречает провал то падает за минуту до (la0-Const)*37%
если встречает горб синуса то за T/4 долезает до определенной величины этого горба.

поэтмоу ema сглаживает спиливыает пики выброшенные вверх у r(t) и сглаживает его провалы вниз.

она берет исхоный сигнал разбивает его на синусоиды. если синусоида длинная то ema после 
некотрого лага начинает высирать эту синусоиду с уменьенной амплитудой. тоесть она у нее сдивгает фазу
и уменшает амплитуду. EMA это винигрет. короткие синусы  она фазу нетргает  и сильно умншает 
амлитуду. длинные синусы она удлинняет фазу и нетрогает ампилитуду.  средние синуса самый отстой
она меняет фазу и по разному меняет амплитуду. в  итге у нас на выходу синусы по разному изурдованы
по фазе и амплитуде. пробблема опяьтже в том что у синосов есть разный лаг на котором его ema 
должна жрать чтобы начать из себя высрать синус. если ema ест синус а он закончился то она неуспеет
начать высирать синус. она просто высрет некий горб. не синисоидальный. 
например если ema жрет синус T=20 минут то она только через 1 минуту начнет высирать из себя
этот синус. а до этого на выходе просто будет некий горб. 

как же интпретировать ema? совершенно четко видно что это как бы скорость вращения маховика. 
если по нему долбануть кратким пиком. то влияние от этого пика еще потом видно очень долго. 
чобы быть более точным.
пусть la=0. потом мы долбанули пиком. r(t)=100 e(n+1)=8
так вот посмриим сколько надо время чтобы это 8 уменьшилось до 0.1
la=8*e(-t/5)=0.1
так вот надо 2 минуты. 
а если la0=1000 то надо 9 минут.

если r это число процессов которое
работает прям щас на компе и одновременно это всыпапание зерен в колесо. 
а ema это сколько щас зерен в колесе. или скажем это сколько процессов работает в колесе.
если мы регулярно подсыпаем в колесо зерна то у нас в колесе образуются долгоживущие зерна.
другим словами внутри колеса появляются долгоиграющие процессы. ведь если зерна неподсыпать
то значит долгоиграющих процессов на компе нет!

скажем у нас в колесе 0 зерен. t=0. ema=0, у нас r(0)=100 у нас на цпу 100 процессов
мы берем эти зерна и всыпаем в колесо ema. она внутрь принимает только 8 зерна.
остальные зерна она считает корткоживущими. тоесть она считает что 92% процессов родивщихся щас
короткими. настолько короткиими что их цпу обработает за следущие  5секунд и поэтому их даже не стоит
рассматривать.
через 5с колесо из себя выбрасывает 8% зерен тоесть  1 зерно. потому что ema считает что этот %зерен
цпу обработает за следущие 5 секунд.

EMA это предсказательная машина! она показывает сколько процессов(зерен) доживет до следущего
исполения на цпу. (через 5с)
если EMA показывает что 1 это значит что она считает что этот 1 процесс доживет до следущего исполнения на цпу.

ema считает что 92% всех новых процессов будут выполнены и убиты раньше чем пройдет 5с. поэтому 
при следущем 5с их уже на цпу не будет ибо они будут выполенны и закрыты убиты. 
пусть ema(-5c)=0. у нас r(0)=10
тогда ема считает что 9 процесссов такие коротки что цпу их выполнит меньше чем за 5с и они 
умрут. поэтому он берет только  1 зерно 
ema(0)=1
это предсказание ema что в t=5c унас из этих 10-ти процессов останется в живых только один!

$ a=10;for i in $(seq 0 1 40); do echo -n "t=$(( i*5 )) | ";  printf "%.0f \n"  $(   bc -l <<< "scale=11; ($a*0.08)*e(-$i/12)"  | tr "." "," )  ; done
t=0 | 1 
t=5 | 1 
t=10 | 1 
t=15 | 1 
t=20 | 1 
t=25 | 1 
t=30 | 0 

это показывает что ema считает что из 10-ти проецссов рожденных в t=0 по мнению ema 9 процессов 
буду убиты меньше чем за 5с. а 1 процесс проживет 25с<t<30с.
пока что для простоты понимания  я буду окргулять ema и рассмативать только целые значения ema


$ a=100;for i in $(seq 0 1 40); do echo -n "t=$(( i*5 )) | ";  printf "%.0f \n"  $(   bc -l <<< "scale=11; ($a*0.08)*e(-$i/12)"  | tr "." "," )  ; done
t=0 | 8 
t=5 | 7 
t=10 | 7 
t=15 | 6 
t=20 | 6 
t=25 | 5 
t=30 | 5 
t=35 | 4 
t=40 | 4 
t=45 | 4 
t=50 | 3 
t=55 | 3 
t=60 | 3 
t=65 | 3 
t=70 | 2 
t=75 | 2 
t=80 | 2 
t=85 | 2 
t=90 | 2 
t=95 | 2 
t=100 | 2 
t=105 | 1 
t=110 | 1 
t=115 | 1 
t=120 | 1 
t=125 | 1 
t=130 | 1 
t=135 | 1 
t=140 | 1 
t=145 | 1 
t=150 | 1 
t=155 | 1 
t=160 | 1 
t=165 | 1 
t=170 | 0 


взяли r=100. 92% по мнению ema не проживет и 5с.
8  доживут до следущих 5с
в итоге 
    1 процесс прожил 5с.
    1 процесс прожил 15с
    1 проесс прожил  25с
    1 процесс прожил 35с
    1 процсс  прожил 50с
    1 процесс прожил 70с
    1 процесс прожил 105с
    1 процесс прожил 170с

ema каждый раз показывает свой прогноз только на следущие 5с не далее.
значение ema говорит - я предсказываю до следущих 5с доживет столько то зерен

оказывается y=y0*e(-t/lambda) это процесс распада(погибания) элеметарых частиц. 
lambda по физ смыслу обозначает время в течение которого y упадет в e(примерно в три) раз.
в физике он почему то называтся "время жизни" по мне хуцня полная а не термин. потому что частицы
разваливаются каждую секунду. просто через время lambda их останетя в сумме в три раза меньше. поэтому
какой нахуй "время жизни". характерное время - это да. потому что частицы они умирают не единоразово группой
через время ламбда а потихоньку за все время от 0 до лямбда. в нашем случае lambda=60с.
есть еще время=период полураспада. это то время за которое у нас число частиц упадет не в три раза а в  два.
тоесть после время лаямбда у нас остается частиц N/e а через время "период полураспада" у нас остается
N/2 . нам в нашей задаче это время нахуй не интересно. кстати что характено lambda описвыает время 
через которое останется N/e частиц.тоесть описывает оставшиеся частицы а не погибшие. мелочь но надо
это понимать.

физика явления понятно - пусть у нас есть шарики. и они шарахаются по комнате. воздущные. а на поверхности
шариков наклеены иголки. если шариков много то вероятность их столкновения друг с другом высока и они
сразу дохуя друг друга поубивают. а если шариков осталось мало то они летают и дргу с другом не 
соприкаасаются. поэтому степень их выжиывания связана не со воеменем а с столкновением друг  с дугом.
а это связано с их числом. все очень просто и понятно.

непонятно почму эту фоункцию прилепили к нашим процессам r(t) ведь 
умрет процесс  или нет завиисит не от того есть ли другие процессы на компе. а от того
чего этому процессу надо сделать. простую задачу или сложную.

как я и оказался прав ema покывазет число выживших шариков\проецессов на данный момент.
почему то ema считает что новые шарики r(t) таковы что 92% их не доживет даже до следущих 5с.
а про остальные она считает что они умирают по законму умирания элементарных частиц.

la=la0*e(-t/60) это закон умирания элем частиц. и это закон изменнемя la при r(t)=0.
при таком законе у нас кждые 5с остается 92% от частиц что были в предыдущей.
или другими словами мы считаем что каждые 5с у нас умирает 8% частиц.

LA(n)=0.92*la(n-1)+0.08*r(n)

значит мы считаем вот что: что у нас в ema цпу(жернове) лежат процессы и каждую итерацию
этот цпу(жернов) перерабатывает 8% из тех процессов что там есть. плюс мы каджую итерацию
докидываем туда процессов. но мы считаем что из числа новых r(t) до следующей итерации 
недоживут 92%.

еще раз: мы постулируем - r(t) это число новых процессов на компе. новых! новых частиц. новых зерен.
мы постулируем что 92% от новых r(t0) у нас t=t0+5с не доживет 92%. потому что они короткие. 
они простые. они слабые. они быстрые. 

итак мы постулируем что в каждый r(t) момент времени 92% это супер короткие процессы длинной менее 5с.

далее мы хотим прояснить- а что же  остальными 8% ? они насколько долгожители? мы хотим знать.

и мы говорим так - мы будем эти процессы бросать в жернов. и каждые 5с там будет умирать 8% процессов.
а поскольку мы будем постоянно докидывать 8% от r(n) то ema будет по разному меняться. 

на каждой итерации у ema убавляется 8% от тех процессов чтобы были  на предыдудущем этапе. 
и тлько потом прибавлвяется 8% от новых. потому что новым процессам гарантрованно что они проживут следущие 5с.

пример 

r(t)=10 , 10

t=-5с ema=0
t=0  ema убивает 8% того что было. но не было ничего 0.92*ema(-5c)=0
     ema отбарывывет 92% от 10. говоря что они не проживут и 5с.
     ema забирает внутро 8% тоесть 1 утверждая что он проживет до следущих 5с.
     ema=0+1=1
     
t=5c ema убивает 8% от того что у нее есть 0 и добавляет 8% от 10 тоеесть 1
     ema=1+1=2
у нас из 20-ти процессов создарных за 10с в ema пояивлось 2 процесса которые доживут 
точно до следущих 5с

итак r(t) - показывает новые зерна, атомы , процессы которые по факту возникают в системе.
но мы незнаем какие из них тяжелые(mysql, chrome) а какие просто мелкие флуктуации системы.
мы утверждаем что 92% от r(t) это короткие процессы короче 5 секунд.
что касается оставшихся 8% от r(t) это уже разговор особый.

EMA считает что эти процессы мешают жить друг другу. и время их жизни зависит от того насколько их
много. чем больше этих процессов тем они живут короче.
EMA показывает сколько у нее сейчас этих процессов есть в лукошке. это число показывает что данные
процессы точно проживут еще 5с. именно это физ смысл числа EMA - число процессов которые точно 
доживут до следущих 5с в ее лукошке.

на следущей итерации ema убивает 8% от процессов в лукошке и сообщает им что они доживут до следущих
5с. после этого она добаввяет 8% от новых r(t) в лукошко и сообщает что они тоже доживут 
до следущих 5с.  в этом физ смысл числа EMA !

la1min vs la5min vs la15min отличется тем что EMA убивает 8% от того что лежит в лукошке каждые 5с, 
25с и 75с  а оставщимя гарантирует что они доживут до следущих 5c, 25с, 75с, 

вернеся к ema1min.
у нас же флрмула

ema(n+1)=p*ema(n-1)+(1-p)*r(t)
если p=0 это значит что мы считаем что у нас аюсолютно все процессы в r(t) являются ултрабыстрыми
то есть короткими и они все недоживут до следущих 5с. 
таким образом при p=0   у нас все процессы r(t) считаются одинаковыми. они все короткие. и они
все не доживут до слеущих 5с. 
таким образом (1-p) нам задает число "процессов дольше 5с" в каджый момент времени r(t)
а ema их сортирует дальнйшим образом. 



процессы поставляют частицы. частицы имеют срок жизни разный.
ema берет 8% частиц. потому что 92% частиц живут менее 5с.
ema в себе содрержит часттцы которые проживут точно до следущих 5с.
частицы друг другу мешают и к следущему 5с они убивают 8% себя в коробке. 
поэтому ема удаляет 8% из того что есть. и прибавляет 8% новых. эти частицы доживут до след 5с.
если есть процесс который каждый раз добавляет новую частичку то 

есть банк. все там хотят хранить деньги. но банк не может у всех принять деньги. но банк 
хочет чтобы все были равны. также он хочет чттобы и бедные и богатые имели равные права в банке.
банк разрешает каждому принести в день 1 монету. и банк у каждого примет эту монету. банк берет 92%
с моменты единоразово как оброк. и кладет 8% с этой монеты на хранение. далее за каждый день хранения
моенты (каждые 5с) банк сдирает 8% себе в карман. ema показывает сколлько монет сейчас лежит 
в банке на хранении. 

еще одна аналогия. есть банк. есть город. все хотят хранить деньги в этом банке.
но банк не может  у всех принять. но он хочет все сделать по честному. каждому можно в
день принести по одной монете. пусть это будут рубли. при принятии монеты банк коневертирует
эти рубли в доллары (поэтому все и хотят там деньги хранить). по курсу 8%. тоесть 1 монета 
превращается в 0.08 доллара. таким образом если человек имеет 100р то ему надо
сходить  в банк 100 раз. и его 100р в итоге сконевертруются в 8 долларов. 
банк за каждый 5с хранения берет мзду с каждого доллара - 8%. тоесть каждый день (5с) каждый доллар
в банке уменьшается на 8%. ema показывает сколько долларов  в банке хранится прям щас.
наша задача это имея график ema(t) определить сколько богатеев ходило и складывало деньги 
в банк подряд столько то дней. 
теперь примеры- если есть человек(процесс) и он имеет 100р. то он проходит в банк 100 раз 
(  100*5с, в момент t=0 в банке $0 и 0 человек пришло.) он туда перетаскает 100р или $8
за это время его вклад  в банке будет меняться вот так

далее я выяснил что r*0.08 = показывает число в минутах сколько минут процесс проработал в системе.
тоесть  ( 1 1 1 1 1 1 1 1 1 1 1 1 1 ) =1*0.08+1*0.08+...+1*0.08=1.04 на графике EMA. и прошла 1 
минута на интервале времени. значит EMA показывает своим значением сколько времени в минутах процесс
прожил на компе ( сколько времени в минутах процесс таскал единички в банк EMA )
тоесть компонент r(n)*0.08 он прибавляет к EMA время в размере 5с но не  в секундах а в минутах.
правда 5/60=0.08(3) но это ~=0.08
далее. если у нас в момент (n) есть два процесса котоыре работали значит будет +2*5с тоесть
+2*0.08, тоесть каждый раз прибавляяя r(n)*0.08 к ema прибавляется время которое процессы 
то ли на интервале [-5c;now] проработали то ли на интервале [now;+5с] отработают. в любом случае 
это время котрое бы процессы отожрали бы на цпу в минутах.
теперь вопрос - если процесс работает бесконечно то что EMA разве бесконечно растет? ответ нет.
оно работает в окне где то 14 минут. 
так - с компонентом r*0.08 разобрались.тоест каждую итерацию к EMA честно прибавляется то время
которое процессы между [-5с;now] отработали на компе в минутах. стало понятно что ema показывает 1) время
2) в минутах. так как r(t) показывает время в секундах то стало понятно откуда 0.08


теперь самое сложное - разобраться с компонентом 0.92*EMA(n-1)

r(t) показывает скольлко процессов работало в промежутке (-5с;now]


 -------|---|
          5c now


тоесть +r*0.08  берет  5с умножает на число процессов и прибавляет эти секунды к EMA. 
правда прибавляет не в секундах. а в минутах. переводя в минуты. путем умножения на 0.08.
по факту это происходит с ошибкой. потому что вместо прибавляения 5с он прибавляет 4.8с
потому что 5с в формате минут это 
        $ bc -l <<< "scale=11; 5/60"
        .08333333333

а линукс использует вместо правильного множителя вот такой
        $ bc -l <<< "scale=11; (1-e(-1/12))"
        .07995558537

        

вот это множитель он эквивалентен  4.80с
        $ bc -l <<< "scale=11; 60*(1-e(-1/12))"
        4.79733512220


вобщем +r*0.08 это мы прибавляем примерно по ~5с для каждого процесса r(t) к EMA.
тоесть 2*0.08 означает что за прошедшие 5с у нас на компе процессов отработал +10c 
только 10с мы прибавляем в форме минут. 
значит этот компонент нам прибавляет время сколько времени работал процессор за счет
нагрузки из за процессов. число выражается в минутах.

насколько я понимаю накопленное время в EMA оно делится на группы. в каждой группе 1 минута отдельная.
тоесть если ema=10 значит внутри нее 10 отдельных групп в каждой находится  1 минута.
тоесть унас как бы 10 процессов отработали за последнюю минуту. так вот член 0.92*EMA(n-1)
он говорит о чем. проходит 5с. и у нас у каждой отельной минуты отнимается эти 5с. у каждой.

(10*600-10*5)/60 = 9.1(6)
0.92*10=9.2

убавляет он по 4.8с за итерацию . тоесть по факту в линуксе есть 100% ошибка о том что функция
использует кофэииенты подразуменвающие сбор сэмплов с интервалом 4.8с. 
а они собираются каждые 5с.


RC*(y(n+1)-y(n))
----------------- = -y(n+1)
      h

  
tau*(y(n+1)-y(n))
----------------- = -y(n+1)
      h


y(n+1)=-h*y(n)
       -------- + y(n) = -h+tau 
          tau            ------- y(n)
                          tau


         tau - h                 
y(n+1)=-------------  y(n)
            tau              
                          
                          
                          
tau*(q2-q1)/h=-q1
q2=-q1*h/tau+q1=(-h+tau)*q1
                --------
                   tau
                   

q2=(55/60)*q1


y=y0*e(-lambda*t)
 яхочу чтобы при t=60, y/y0=e(-1)
 
 -1=-lambda*60
 lambda=1/60
 
 t=n*5
 
 y=y0*e(-1/60*5*n)=y0*(e(-5/60))^n
 y=y0*(e(-5/60))^n, n=0,1,3...
 
 
 y(n+1)=y(n)*e(-5/60)
 
 y'(t)=-lambda*y0*e(-lambda*t)=-lambda*y(t)
 
 
 y(n+1)-y(n-1)
 ------------- = -lambda * y(n-1)
        h
 
 y(n+1)= -lambda * y(n-1) * h + y(n-1) = y(n-1) * [ 1 - lamda*h ]
 
 y(n+1)=y(n) * [1 - lambda*h ] 
 
 
 
значит разноствное уравнеени для функции
    y=y0*e(-lambda*t)
вот такое
     y(n+1)=y(n) * [1 - lambda*h ] 
значит обратное тоже верно. в линуксе разностное уравнение
     y(n+1)=y(n) * e(-5/60)

     1-lambda*h=e(-5/60)
     lambda=(1-e(-5/60))/h=(1-e(-5/60))/5
     
значит исходаня фунация 
        y=y0*e(-lambda*t) = y0*e(-[(1-e(-5/60))/5]*t)
узнаем когда y/y0=e(-1)
[(1-e(-5/60))/5]*t=1
t=1/[(1-e(-5/60))/5]

$ bc -l <<< "scale=11; 1/((1-e(-5/60))/5)     "
62.53471822028

получается линукс на самом деле работает с ema(1.04min)  а не с ema(1min) 

а мужик из книжки говорит что 
    1-lambda*h=12/13
    lambda=(1-12/13)/5=1/13.5=1/65
    
y=y0*e(-t/65)
найдем когда y/y0=e(-1)
-t/65=-1
t=65с
тоесть у неготоже уебанский расчет.

мой же расчет говорит что надо 

 y(n+1)=y(n) * [1 - lambda*h ] 
 y(n+1)=y(n) * [1 - h/60 ] = y(n) *  55/60= y(n)*(11/12)
 y=y0*e(-t/60)
 тогда в t=60 y/y0=e(-1)
 а в итерациооной формуле
 y(0)=y0
 y(1)=y0*(11/12)
 y(2)=y0*(11/12)^2
 y(n)=y0*(11/12)^n
 y(12)=y0*(11/12)^12
 
 $ bc -l <<< "scale=11; (11/12)^12  "
.35199562798

 $ bc -l <<< "scale=11; e(-1)  "
.36787944117

ошибка 4.3%

походу линукс ставил своей целью не чтобы оригинальная функция падала в e(-1) 
а чтобы ее приближение падало на 1 минуте в e(-1)



 
 


                                        
                                            
если h=5 то 
y(n+1)=y(n)* (11/12) = y(n)*0.91(6)
 
 
 
 y=y0*e(-lambda*t)=y0*e(-lambda*n*5), 
 n=12 y/y0=e(-1)
 e(-1)=e(-lambda*12*5)
 lamda=1/60
 y=y0*e((-1/60)*n*5)=y0*e(-(5/60)*n)
 
 
 




 tau*[ y(n+1)-y(n) ]
 --------------------  + y(n) = C*V(n)
        h
                   

                   

 
 [ y(n+1)-y(n) ]  + (h* y(n))/tau = (h*C*V(n)) / tau
        

        
[ y(n+1) ]   + (h* y(n))/tau -y(n) = (h*C*V(n)) / tau


y(n+1)   +  =  y(n) [ 1 -h /tau  ]   +    (h*C*V(n)) / tau


y(n+1)     =  y(n) [ tau - h  ]        +     (h*C*V(n)) 
                    ------------------        ---------
                             tau                 tau
 
 
y(n+1) = y(n)*(55/60) + (5/60)*V(n)*C

U(n+1) = U(n)*(11/12) + (1/12) *V(n)

U(n+1) = U(n)*0.92 + 0.08*V(n)

 

 
ema(t) позвоялет в изврашенной форме передать форму исходного r(t).
типа вырезая выскокие частоты. сдвигая средние и длинные. это пиздец.
если есть только длиьнные и короткие то отлично. наличие средних это пиздец

ema к сожалению не просто "сглаживыает" она сука сдвигает фазы!



значит получается что  EMA это график напряжения на виртуальном конденсаторе.
почему берется не V  а 0.08V я пока не понимаю. хрен с ним. Какая свзь межлу напрямжением
на конденсаторе и нарпженим на компе? связь такая что конденсатор ставят в сеть с потсонным напряжем
чтобы можно было коменсировать краткие провалы напряжения. а в сеть с перменных V для
того чтобы фильтровать используя конденсатор напряжение входное в сети. насколко я понимаю 
мы подключаем к когденсатому пралелально осциллограф и смотрим "очиещенный" от высоких частот 
сигнал. проблема опять же в том что в одной конфигуарции капаситор фильррует высокие частоты
а в другой конфигурации низкие.
вроде бы  я нашел доказаелсьво - https://blog.prosig.com/2003/04/28/data-smoothing-rc-filtering-and-exponential-averaging/
что эат формула имнно для случая когда конлеснатор фильируе выскоие часоты.

соласо расчтеат tau=57.5с для alpha=0.92
период обреза = 5.75м
при таком раскдаже рекмоердует искать сигнал с T>=10м тоогда от такого сигнала обрежется 
только 15%.

я провеирил - полезный сишнал T=10,15мин.(A=4) плюс мусорный на T=15,20с(A=2)
ну нормал работает. но и так глазами видно и без всяких фильтров.


интерсно что полуается что tau=60с это именно то смещение фазы для длинных синусов. 
так как синусы эти растут медленно. то может из за этого капаситор медленно 
накапливает ихний заряд(напряжение)?

но в итоге я не понимаю - что нам дает фильтрация сигнала r(t) по низким частотам?
нахер она нужна на практкие нам? ну убрали мы из сигнала высокие частоты. ну увидели низкие.
да еще со смещением фазы. да еще с уменьшем аплитуды. что дальше? что с этим делать? какой
смысл это для нас?

тест все эти ema и частоты обрезные . alpha ,lambda, кпаситоры выбираься только 
для того чтобы очистать сигнал r(t). но нахуй это нам надо ?


конденсатор ставять только и только для того - чтобы очистить сигнал от высоких частот.
поэтому возникает вопрос - нахрена это нам в линуксе. что нам это дает. что нам дает график
низких частот? пока непонятно. конденсатор не ставят больше ни для чего. тоесть 
этот график является окончательным. чтото там из него вырезать. или пыататься восстановить
по нему исходншый графк - это все фуфел. конденсатор для этого не ставится. 
так что главнй вопрос - что дает графки "отрезанных" высоких частот ??
тоесть этот график его нунежно преобрраывать. его нужно понять зачем он нужен.
а так реально - это график раскркученного колеса. или горящего костра.
также понятно что чем быстрее он крутится тем система больше нагружена.
еще важно то что график от этого конденсатора - его важная подзадача это передать форму
сигнала. тоесть в нем важна не цифра конкнрентная. не среднее. в нем важна сама форма. 
его задача передать форму.
также дополеннение- та цифра которую показывает ema она как бы говорит о том что 
если бы комп начал работать с нуля 5 минут назад то ему надо было бы чтобы на нем работало
столько процессов чему равен EMA сейчас. и в самом худшем случае он будет работать даже при нулевом
дальнейшем r(t)=0 еще 14 минут. тоесть он как бы говорит вот щас я показываю тебе 10.
это эквивлаентно тому что я взял всю нагрузку за последние 14 минут и если бы я начал рабоать с нуля
5 мину назад то надо было бы чтобы работало 10 процессов последние 5 минут. и даже если 
дальше будет r(t)=0 то я не занулюсь еще 14 минут. вопрос только в том - что за суммарная нагрзука 
за последние 14 минут?. вобщем нам это на практкие ничего не дает.
ксатаи ролть конденсатора еще и в том что вначале система его заряжает. а если толкающая v(t)
исчезла то он начинает возвращать U,I,q обратно в контур. но нам то какой от этого смысл в 
нашей задаче?
маленькие практические выводы такие: 

    - если ema при очередной 5с итерации упал значит r(t) в этот момент
меньше чем ema. 

    - если ema хотя бы стоит на месте значит r(t) ~= ema ! 
      щас докажу  
          ema(n-1)*0.08 = r(n)*0.08
             ema(n-1)=r(n)
             
    - если ema выросло значит r(t)>ema(n-1)

    - если ema упал на ~8% (попробуй посчитать на лету округляем до 10%) значит текущий r(t)=0

    - еще интересный момент. так как у нас r(t) всегда натуральное. тоесть 1,2,3 4, 100,...
    а из предыдущего пункта следует что если ema(n-1)<r(t) оно падает а если ema(t)>r(t)
    то оно растет. так вот так как у нас ema очень редко бывает ровно целым. оно всегда дробное
    то совершенно четко понятно что если у нас ema=1.3 и на следущем шаге он уменьшился 
    то это значит что r(t) текущий был меньше чем округленное верх до ближайщего целого в данном случае 2.
    тоесть. видим ema=1.3  ближайшее вверх целое к нему это 2. если ema на следущем шаге уменьшиться
    значит текущий r(t) был <2. еще пример ema(now)=0.6 ближайшее челое к нему это 1. если на ближайшем
    шаге ema уменьшился значит он был меньше 1. 
    еще пример у нас ema=5.4 . ближайше к нему вверх целое это 6. если следущий ema уменьшился значиь
    текущий r(t) < 6. а если ema непросто уменьщился а на 8% (смотри преддыдуий пункт) то текущий r(t)вообще
    равен 0! тоесть смотрим на текущий ema. скажем ema=1.3
    и мы себе говорим  если следущий r(t) будет <=1 или ниже то ema уменьшится. если следущий r(t) будет
    >=2 то ema увеличится.  тоесть ema очень нестабильное число. оно не может удеоживаться на одном 
    значении никак. особенно из за того что r(t) принимает только целые значения. поэтому когда ema не целый
    скажем 1.2 он либо будет упорно падать до 1. либо будет упорно расти до 2. 
    
    
     
    - Если бы последние 5 минут была бы постоянно в каджый момент времени нагрузка +1
то ema прибавил бы +1 к графику минимум. тоесть невозожмно иметь последние 5 минут в каждом сэмпле
+1(мжно и больше) и не прибавить +1 к EMA. тоесть если  у нас EMA не добирает сколько то до скажем 1
тоесть равно 0.7 то это значит что последние 5 минут у нас не было процесса который бы работал все 5 минут.
есто только процессы короче чем 5 минут. да их может быть много и обратно неверно - что если у нас
ema=2 то это значит что последние 5 минут стабильно было минимум 2 процесса работающих. это знаение
могло выстраться за последние пару итераций. зато верна еще раз скажу оценка сверху. тоесть 
если у нас щас EMA=5.2 то это точно значит что последние 5 минут у нас небыло 6 процессов которые 
бы стабильно работали все 5 минут.  тоесть еще раз вот у нас EMA=5.6 на текущий момент.
я утверждаю что оценка ограничивающая сверху говорит о том что за последние 5 минут на компе 
неработало 6 длинных процессов. это невозможно. могло быть много коротких процессов которые если их 
сложить и усреднить за 5 минут то они дадут 6 например но нам не это важно. ничего нельзя сказать 
про короткие процессы точнее можно но будет очень большой диапазон разброса. например столбик из r(-5min)=150
даст ema(now)=1 и этот же столбик r(-5c)=150 даст 12. а ведт и тот и другой столбик дают среднее в 5 
процессов за 5 минут. но это хуйня. в зависимсоти от того где стоит этот стоолбик он дает соверщенно
разный вклад в ema. я утверждаю что если у нас ema=3.3 то это доказывает что за последение 5 минут
у нас не могло работать на компе 4 процесса таких что они работали в каждый сэмпл времени 
этих 5-ти минут. еще пример ema=0.78 это значит что за последние 5 минут на компе не было даже 1-го процесса
который бы работал на компе каждый квант времени. тоееть все процессы на компе в течение последниех 5-ти
минут работали точно меньше 5-ти минут. тоесть все были коротыщи!!!
потому что если у нас ест вектор
    ri(t)= ( 1 1 1 1 1 ..... 1) на интервале 5 минут то просто невозможно чтобы ema не прибавил +1.
кстати это совершенно не значит что еали у нас ema=5.4 то за последние 5 минут
у нас всегда было  миниум 4 или 3  или 2. есть такие хитрые синусодидальные нагрузки
при которые за 5 минут даже la=1 нет на всем протяжении. поэтому еще раз скажу верна только 
оценка сверху. о том что R>=6 на всем протяжении последних 5 минут быть не могло

  - Если говорить про статистику за последнюю минуту и у нас EMA=3.4  
мы умножаем в голове это чило на 1.58 (или делим на 0.63) получаем число 5.4 округляем в сторону большего
целого тоесть это 6.0 . и я утверждаю что за последнюю минуту такого не может быть чтобы на компе работало 
6 процессов таких что они работали каждый в каждый сэмпл этой минуты и при этом  у нас EMA не достигло 6.
это невозможно. потому что если даже у нас EMA=0 в миуннуту назад. и было 6 процссов кажый из которых
работал каждый сэмпл то наш EMA обязан было достичь 6.  одна только проблема что умножать на 1.58 
в уме непросто.
еще пример EMA=0.7 округляем вверх до ближайшего целого вверх, это 1 - значит за последние 5 минут у унас небыло 
ни 1-го длиного процесса котоый бы отработал все 5 минут,все процессы были короче 5 минут.
также 0.7 домножаем на 1.58, 0.7*1.58=1,06 округляем до блиайжшего целого вверх 2, 
я утвержаю. что за прошедшую минуту у нас на компе небыло двух длинных процессов которые бы 
отработали каждую секунду это минуты. конечно же у нас могла быть куча коротких процесов. о них речи не идет.

  
- если ema постоянно скачет между целыми числами - это значит что постоянной нагрзуки
  из длинных процессов нет.а есть только выстрелы.
  
 
    
    

далее идет шлак но я оставлю для истории.
    
    
модель работы EMA такова:

1) физ процесс. модель проеццеса
рассматривается что в эл контуре есть три куска: батарейка которая насыпает новые процессы (частицы)
(добавляет новые частицы в контур),
сопротилвние которое убивает линейное количество этих новых частиц, и конденсатор из которого частицы
выливаются как из дырявого ведра.

2) о чем говорит дискретная формула EMA.
она показывает количество частиц сейчас находящихся в системе.
как она их считает - она рассматривает физ процесс. а он такой:
батарейка рождает новые частицы и бросает их в контур. Закон рождения новых частиц  задается R(t)
R(t) показывает сколько новых частиц было вброшено в контур именно сейчас. Далее идет модель дискретизации -
она постулирует что далее на интервале +5с (отрезок дискретизации) у нас R(t) неменяется. Это нам
гарантирует что в течение между now и now+5c у нас новые процессы частицы не рождаются. Мы точно 
можем быть уверены что если щас r(t)=10 то у нас щас родилось новых 10 частиц и между сейчас и сейчас+5с
новые частицу не появятся. значит мы знаем сколько новых частиц  у нас добавилось в контур на промежутке
между щас и щас+5с. Далее частицы попадают на сопротивление. И на этом сопротивлении у нас умирает 
92% от этих частиц. тоесть умирает число частиц линейно пропрорциональное их числу. они входят в сопроти
вление и там умирают. на выходе из сопротивления у нас выживает 8% от вошедших частиц. в формуле
EMA за это отвечает кусок 0.08*r(n)  Возникает вопрос почему мы домножаем на 0.08 ведь оно
очень даже связано с цифрой 5/60=0.08 дело вот в чем мне кажется что этой модели сопротивление 
в цепи подбирается так что оно выжигает 92% всех новых частиц и оставляет только 8%. 
Если мы рассмотрим другую физ систему - у нас есть насос он вкачивает воду в трубу. вкачивает
со скоростью r(t) кубометров в секунду. далее у нас в трубе идет дырка. и из этой дырки
выливается на пол число воды пропорциональное влитой воде. дырка выбрана так по размеру что из 
нее вылиывается 92% от влитой воды и только 8% успевает пройти дальше. продолжаю размышлять 
на счет 0.08 и 5/60. Когда у нас в систему добавляет 0.08*r(t) то это показывает время которое
эти процессы R(t) прожили в минутах , дейтсивттельно 5с/60с=0.08 от минуты. Я думаю это говорит о том 
что EMA показывает некоторую величину в минутах. Я думаю что R(t) показвыает сколько частиц
насыпано добавленов с контур за прошедшие 5с. если у нас момент (now) то R(now)
показывает что с момента [-5c,now] в системе существует +R(now) частиц 
тоесть EMA показывает сколько (каких то!) частиц в системе сущесвтует СЕЙЧАС. С другой стороны
R(now)*0.08 это сколько ВРЕМЕНИ сожрали процессы за 5с если это время выражать в минутах.
полуучается R(t) это скорость насыпания новых частиц выраженная в  (частиц\МИНУТУ) 
с другой стороны R(t) это (сожранное время\МИНУТУ) так как мы работаем на интервале 5с
то нам чтобы узнать сколько новых частиц насыпалось за эти 5с или сколько времени было сожрано
за эти 5с нужно умножить R(t) на 5/60 
Итак получается что EMA считает что R(t) это график нарисованный в минутах а не секундах.
если бы у нас интервал сэмплиорвания был 3с то я уверен что в формуле EMA это было бы тогда
не (5/60)*r(n) а  (3/60)*r(n)

итак с точки зрения насыыпания частиц 0.08*R(now) нам показал сколько частиц добавилось в систему
на сейасчашний момент с предыдущего момента. тоесть с этой точки зрения EMA показывает изменнеие 
системы отталкиваясь от предыдудщего момента и заканчивая настоящим она берет предыдущий момент
и отталкиваясь от него производит сдвиг в текущий момент. в том моменты было сколько то каких то
частиц и вот мы сдвигаемся в наш now момент при этом у нас насыпается в систему дополнительно
0.08*R(now) частиц. В этом смысле R(t) показвает сколько частиц было добавлено в систему с предыдущего
момента (-5c) до настоящего момента. Но график R(t) нарисован по оси t не масштабе секунд  а в масштабе
минут. Так считает EMA при расчете.

Итак с момента (-5c) до момента (now)  у нас в систему всыпалось 0.08*r(t) частиц
и поэтому с того момента к настоящему в системе прибавилось +0.08*r(t) частиц 

с точки зрения времени. у нас в момент (-5с) родилось R(t)  новых процессов и к моменту (now) 
они прожили в системе 5с. тоесть R(n)*5c или если выражать в минутах R(n)*(5/60) или
0.08*R(t) 

с точки зрения сопротивленияю мы в момент (-5с) всыпали в систему R(t) зарядов но 
к моменту now тоесть за 5с сопротивление сожрало эти заряды линейно тоесть сожрало зарядо пропорциаонально
их числу и их осталось 0.08*r к этому моменту

Итак мы имеем либо число добавившихся зарядов которые были добавлены в систему 5с назад
и потом их за 5с сьело сопроивление и в итоге выжило 0.08*R от добавленного числа,
либо мы имеем число добаввившихся зарядов которые не ело сопротивоение но их всыпали оказывается
гораздо более медленно, 
либо мы имеем время выраженное в минутах которое новые процессы прожили на системе за последние 5с.

что будет если этот шаг продолжать и продолжать. мы всыпаем новые частицы и их число растет
растет и растет и EMA показывает сколлько суммарно ВСЫПАННЫХ И ВЫЖИВШИХ частиц есть в контуре 
сейчас. если мы будем продолжать проецесс скжем 30с то EMA покажет нам сколько  суммарно всыпанных
частиц у нас есть за это время в контуре 

либо она показыавет сколько времени в минутах прожили новые процессы на компе. причем в рамках
этой модели каждый процесс после того как он проработал между (-5c) до now он тутже умирает. поэтому
процесс только народившийс в (-5c) и проживщий между (-5c,now) он тут же умирает. поэтому в дальней
шем времени они не вносят никакого вклада. поэтому накоплеие
времени дает только новые процессы. 

так вот что касается частиц - то они пройдя сквозь сопротивление в итоге попадают в конденсатор.
и именно число частиц в конденсаторе и показывает EMA. итак EMA показвает число частиц именно в конд
енсаторе. на данный момент. 


итак мы рассмотрели моменты времени (-5c) , (now)
двигается теперь в момент времени (+5c)


рассмотрим  что такое конденсатор- это дырявое ведро. что важно ведро большое а дырка очень маленькая.
это ее отличает от сопротивления. 
если сопротивление это плоская труба с напором у которой огоромадная дыра в полу, 
 где заряды которые летят по трубе погибают линейно от своего
исходного числа то конденсатор это огромное ведро с малюсенькой дыркой. поэтому из этого кондесатора
заряды выливаются уже не с линейным закном а экспоненциальным. 

так вот EMA она покзывает число зарядов внутри контенсатора. на шаге (+5с) 
из ведра выльется 8% зарядов котоыре там были. тоест в ведре останется 0.92 *(от того что было)
плюс у нас в конденсатор приплыло доп число зарядов из трубы 0.08*r(n)
значит  теперь у нас в конденсаторе число зарядов равно

ema(n)=0.92*ema(n-1)+0.08*r(n)

итак заряды у нас вливаются в контур. по закону r(t) далее они гибнут лятят через сопротивроение
и там линейно гибнут и долебтает до капаситора тлоько 0.08*r(t) а капаситоре за это время вылиывается
по эксп закону 0.92 от тог что там было. итак цикл выгляди так. оставляем в ведре  0.92 зарядов от того
что есть. заливаем новые заряды r(t) и добавляем  в ведро 0.08*r(n) и тепер мы знаем сколко зарядов
у нас в ведре сейчас.


что касатеся процессов и времени. тут все хитрее и сложнее.
тут имеет место две модели.  одна модель считает что процессы r(t) появились не сейчас
а 5с назад. это значит что к моменту сейчас они уже отработали в симтеме каждый по 5с. 
вторая модель считает что процессы r(t) появилис в системе именно сейчас и тогда делает предсказание.
она говорит о том что 92% процессов которые родились щас они не проживут и 5с. и она их откидывает.
а 8% проживут по крайней мере 5с. и она прибавлляет их ЧИСЛО к себе.

рассаотим обе моддели отдельно.
момент (now) значит появились новые процессы r(t) появились не сейчас
5с назад. это значит что к моменту сейчас они уже отработали в симтеме каждый по 5с. 
EMA приьавляет это время к себе в мошну 5с*r(t) только она время считает в минутах.
r(t)*0.08
до того как эти процессы увидела ema  они были молодые. тоесть они точно жили.
как только их увидела ema то она их переводит в статус старых процессов и
считает про эти процессы вот что. она считает что далее старые процессы будут жить по следу
щему закону - каждый такой процесс будет умирать. и тут  к сожалению опять возможно две инерптре
тации. 
  а)  каждый процесс будет стареть с одинаковой скоростью. тоесть было у нас 3 процесса. 
      на следущую итерация каждый из них постареет на 8%. тоесть было 3
      станет 3*0.92 
      и каждый из них потребит времени тогда (3*0.92)5с
но процессы не стареют. они квантовые существа. они либо есть либо нет . значит
  б) среди старых процессов есть распрееление кто сколко проживет. по экспоеннете.
     если у нас 1 процесс то он проживет 0 полных минут.
     если у нас 3 процесса то  2 проживут 1 полную минуту а 1 ноль полных минут
     если у нас 27 процессов то 18 проживут 1 полную минуту  6 проживут 2 полные минуты 
                             2 проживут 3 полные минуты ,  1 проживет 0 полных минут
        (потому что закон r(t) будет ema(now)=27, ema(+1min)=9, ema(+2min)=3, ema(+3min)=1 ema(+4min)=0
     и так далее.
     это нам дает то что если у нас есть N процессов то следущую 1 полную минуту точно проработает
     ( так думает EMA) N-1 процессов.
     
     
пока оставлю эти размышления. буду отталкиваться что EMA в природе описыает процессы в эдектро 
контуре с источгиком энегии, сопротивлением , конденсатором. это реальный процесс. и там ema  работает
с зарядом частицами которые как 2 капли аналог процессов. 
EMA говорит о том что те частицы которе у нее лежат в конденсаторе будут там оставться по закону

ema(0)=N
ema(+5c)=0.92N
ema(1+min)=N/3

тоесть глядя на EMA можно точно знать что через 5с  в конденсаторе останется 0.92*N 
а через минуту там останется N/3 частиц. Если частицы это процессы. то это значит что 92% процессов
точно отработает следущие полные 5с.
а 33% процессов точно отработают следущую 1 полную минуту.
также в этой модели мы полагаем что в каждом новом r(t)  у нас 92% частиц недоживут до следущих 5с.
а тлоько 8% доживут.  таким образом EMA(now) показвыает сколко частиц сидит сецчас в конденсаторе

я думаю EMA(t) такова что она считает что в кажом R(t) у нас 92% R(t) это процессы которые 
не проживут и  5с. остальные 8% проживут 5с и более. и это распределение у оставшихся 
выглядит так что 0.92 от оставшихся проживет по краней мере еще 5с а N-1 от оставихся проживет
по крайней мере еще 1 минуту.  если r(t)=5 то через 5 минут EMA=5 это значит что 
по ее мнению 92% от 5 будет работать через 5с. а 5/3 процессов будет работать через 1 минуту

тоесть елси на компе формироват r(t) таким хитрым оразом чтобы часть новых процессов а точнее 92% были
короткие <5c а остальная часть процессов была бы тоже хитрая. тоесть опять же большая часть это
процессы длинной 5с. и малая часть процессов длинных. то наш ema будет в такой системе 
каждые 5с будет показывать сумму из новых процессов созданных и тех процессов которые будут работать
как минимум следущие 5с.

так как реальное распрееление быстрых и коротких процессов в каждом r(t) отличется от того что 
думает ema то поэтому r(t) и ema(t) не совпдадают.
потому что процессы r(t) ведут себя как хотят в компе а электроны в  контуре с соприивлением
и конденсатором выбора не имеют. 

ema модуелиуеи ситуацию как если бы на компе сувая r(t) в ema мы говорим что было бы если бы мы r(t)
засунули в контур сопротивление+конденсатор. если бы r(t) обрабатывал не цпу а контур сопротивение+кондеснатор

R(t) реаьный комп процесс. мы заускаем q(t) на реальном элктро контуре. получаем на конденсаторе
реалный ema(t). между ema(t) точно есть реальная связь с q(t) значит есть и реальная связь
между ema(t) и r(t) я хочу понять эту связь.

r(t) можно разбить на синусы. и кстаии говоря синус сигнал он такой как раз и есть
тоесть - он порождает сразу и короткие и длнные процессы. ровно так как надо ema(t).
тоесть - если мы на компе будем создавать r(t) в форме синуса то нам придется его создавать 
путем того что создавать короткие проецссы и длинные. с опредленными жизнями. 

на контуре заряды. у компа процессы. и то и то атомарная вещь.
на компе есть процессы которые живут мало и доолго. в контуре есть зардяды которые живут долго 
или мало. там это зависит от везения. на компе это зависит от сущности процесса.

в контуре ema(t) показывает число зарядов которые прожили уже какое то время на компе 
и\или которые еще там проживут такое то время.  значит для компа ema показыает тоже самое.!!
что такое r(t) это число активных тасков на данный момент. это есть заряды.
если мы будем анализировать r(t) то мы поймем по этим таскам какой длинны были процессы.
ema анализирует заряды тоесть таски но не процессы.

таски это пасажиропоток в метро новоприходящих пассажиров. он от цпу не зависит. это
нечто внешнее.  ema говорит о том что если есть график r(t) новых пассажиров входящих 
в метро то 92% из них пришли просто проводить знакомых и поэтому в поезд они не войдут.
оставшиейся 8% пасажиров будут вылезать из электрички по закону - на каждой станции 
будет вылезать 8% от тех кто сидит. а если ктоо подсаживается походу остановок
то тоже самое 92% провожающих. остальные из вновь залезших вылезают на ближайшей 
станции по 8%. R(t) это график новых пасажиров по отношению к прошлой станции. а не
общее число пасажиров которые залезли в поезд с момена отхода от вокзала. тоесть r(t) это не 
общее количество насыпанных зарядов с момета 0. это число насыаных зарядов с момета
последней остановки. если r(t) параеллный горизонут то r2(t) кторые покзаывает общее число
зарядов намыпаннных с момоента 0 это y=k*x. это наклонная прямая. ema на кажом шаге
работае с его производной. R(t) это призводная от r2(t)
если бы небыло кондеснатора то ema показывала бы просто сумму r(t) уможенную на коэфициент 0.08
а график общего числа зарядов прошедших систему это было бы растущая сумма R(t)*k
а число число выживших зарядов к сейчас это было бы  ema(n)=ema(n-1)+R(t)*0.08
потому что раз нет капаситора то нет и вылившихся зарядов. они тоько на сопртивении частчино бы согорали
и все.

ema показывает некую инфо о том какой был r(t) до натофщего момента. причем заметим 
ema(t) это напряжение на конденстаоре а r(t) напрможние на батарее. итак зная ema(t) можно
кое что сказать про r(t) в прошлом.
есть и другой момент. если мы уберем r(t)=0 то конденсатор продолжит иметь u(t) и давать
его в сеть. заметим что ema это u(t) на конденсаторе. поэтмоу нет ничего удвительного 
что u(t) <> 0 после того как r(t) =0. потому что  r(t) это напржоение на батраее
а ema(t) это напрможеие на кпаситоре! поэтому глупо смотреть на la график и видеть что он 
неравен нулю втовремя как на компе r(t) стал равен нулю. это совреенно нормально.  r(t) 
это график на батарее а ema(t) график на коноденсаторе ! по факту ema(t) это фильтр сигнала r(t)
котоырй колбасит ряд фурье сигнала r(t). где то умненьшает а гдето сдвигает фазу.
ema(t) это свертка сигнаоа r(t) за какоето время назад. прэтому глялдя на ema(t) можно кое что 
скзаать про то какой был сигнал r(t) в прошлом в том числе по отношению к текущему сигналу.

ema это как звук ревущего мотора - чем она бльше тем громче ревет мотора компа.
типа того.  показывает как много процессов родилось в системе.
цифра ema в грубом приближении показывает среднее число процессов которые постоянно
все время работали последние 5 минут. тоесть
елси у мы запустим r(t)=1 в течение 5 минут то la станет раавно 1 через 5 минут la(+5min)=1
тоетсь если мы видим что la=1 это незначит что он просто всего навсего сейачс равен 1.
это была бы фигня. все гораздо хуже. это значит что посоедние 5 минут  у нас все время !!! хреначил r=1.
тость la=1 незначит что r(now)=1 это мелочь. это значит что так уже херачит целых 5 минут!
la это как большое. если оно вращается со скростью 1. это значит что маленькое колесико 
которое вращалось со скоростью 1 минута его так раскручивало уже целых 5 минут!
если la=1 это значит что система уже давынм давно херачит на r(t)=1 
если la=1 это знчит что целых 5 последних минут у нас есть 1 процесс который все это время работает.!
конечно это грубое простецкое приближение. но оно дает качествуенную мгновенную картинку конкретную
картнку что физически значит la=N
опять же грубо - если LA=N то примерно 0.63*N а еще более грубо 0.5*N это нагрузка в течение
всей последней минуты. тоесть 
если la=1 то значит последнюю минуту все время r(t)=0.5
опять же это все неверно всегда, но качетвенно зачастую это так 
la  ema это накопитель энергии за какоето время назад. как колесо большое. поэтому 
его цифра дает ощущение нагрузки за перод от какогтто времени назад до щас.
интегралная характеристика. более конкретно - велеичина нагрузки за 1 и 5 последних минут.
  если LA=N, то 0.5N это нагрзука за 1 минуту   а N это нагрузка за 5 минут
  

у нас ест насос который зкачивает воду и ест дырявое контейнер из которого
воода вытекает.ema покзывает текущее занчение водвы в контейнере.
надо сфокурсивать на прешлом - если у нас есть уровень воды ema то 
какое было в прошлом r(t) насосоа?.

получается что la1min la5min и la15min их разница в том что мы натралвием
наш сигнал r(t) в три контура с конденсатором. в первом контур такой что 
когдесатор разряжется в 3 раза за 1 мин, во втором за 5 мин
и в третьем за 15 мин. вот и весь смысл этих 1min 5min 15min
в первом контуре конденсатор заряжается до R=const (это напряжение кстати) 
за 5min.

l1min соотвесвенно он же ema1min показывает напряжение на конденсаторе.
осталось дело за малым - выянсить что можно сказать о характере r(t) 
это напряжение на батарее по характеру и числам la1min


значит за счет 0.08*r(now) ema аккумулирует в себе то полное время которое 
процессы проработали в системе. тоесть 5 процессов раобтаюищих 1 минуту 
просумаириуеются в ema  в виде 5*12*5/60=5 тоесть ema будет в себе содержать 
за 1 минуту своей работы число 5 которео означает что процессы на компе проработали 
5 минут. тоесть это хорошо что ема полносью считает то время которо процессы 
проработали на компе. если бы не член 0.92EMA то la содержал бы в себе
нагрузку за последние столько то времени. если бы эти придурки просто обнуляли
бы la каждую минуту. то все было бы классно. итак если мы вливаем из ведра
каждые 5с столько ведер воды то ema их считает и прибавляет к себе.
вот у нас проработало 5 проецсов за 5с. они прорработали 5*5с=25с или 25/60=0.42 минуты
а потом она начинает это время отнимать. уменьшать. ema=N показвыает время в минутах.
когда ema берет вклад в рублях она преобразует его в доллары.
казалосьбы хранит это время да плюсуй в чем поблема и нам выводи. 
чем дальше от этого момента тем отработанное время обесценивается. тоесть если щас 5 процессов
отработали 5с. это будет 0.42минуты. то через 1 минуту это время будет уже засчиыаться как в 3
раза меньше. кстати 12.5 на который делится ema в формуле wi*xi это перевод отработатнного
времени в минуты. EMA согласно формуле wi*xi это всего навсего сумма отработанного времени
процессами в минутах с таким приколом что чем дальше отработатнное время тем оно обесценивается
для настояего момента. если бы все wi были =1 то ema было бы просто отработанное время на компе
процессами за весь аптайм. в минутах. 


из того что узнал раньше.
 если у нас LA=N
 то среднее за последнюю минуту лежит в диапазоне
                 N <= r_sredneee <= 2.38*N
но опятб же среднее ни о чем не говорит. 
может быть 4000 процессов которые все короткие и выстерлили в посление 5с. и отработали
за 5с. r_srednee это ни о чем. главное какой был бузи тайм. какие были сами процессы короткие 
или длинные.







далее.
я могу на основе то го что la падате на 8% если r=0 узнавать солько времени
за миунут r=0; я сделал такую программу










далее. ema растте и падает по разным закоонам.
она растет нелнено и падает нелинейно.
если подат нагрузку 5 то через минуту ema достигнет 2/3 от 5 тоест 3.33
а если тут же убрать нагрузку то она упадет в 3 раза и станет 1.11
тоесть ema колесо разгоняется быстро а тормозит мелленеее!


если мы три раза сделаем вот так

1 минута 5
2 минута 0
3 минута 5
4 минута 0 

у нас будет


1 минута 5  la=2/3*5=3.33
2 минута 0  la=la(p)*1/3=1.11
3 минута 5  la=3.33+1.11*1/3=3.7
4 минута 0  la=3.7/3=1.23

если бы разгон и томрожение работали одинаково то оно было бы вконце равно нулю

как бы мы легко не толкнули он будет тоормозить после этого минут 14

за 1 минуту la разгонятся до 2\3 от R тоесть как бутто идет усредненеие по 3-ем минутам.
а если мы снимем нагрузку то она будет продожать быть еще минут 14. тоест как бутто
усреденеие идет по 15 минутам.

ускоряющая сила усреднеяется по 5-ти минутам вперед. а замеллящая сила 
усредняется по 15 минутам назад
а текущий LA яляется суммой замеляющейся силы и ускооряющейся.

текушйи LA это 1\3 от   la(-1min) и на 2\3 от lA за эту минуту.

если la разогнять минуту а потом боросить на минуту то в конце  у нее останется 2\9 
от того чем ее разгоняли.этакая несгораемся сумма. 5*2\9=1.11 это 22% 

LA покзывает 2\3 от R котормы до этого как бутто разгоняли комп
через минуту он показывает 1\3 той LA тоеесть 1\3*2\3 той R и 2\3 нового R

будем разгоняь только констнами.


1минута R=1 la=1\3=0.33
2 минута R=2 la=1\3*1\3+2*2\3=0.11+3.33=3.44
3 минута R=0 la=1\3*3.44=1.44

при наборе разгона  за минуту LA а потом при торможении за 2-ю минуту 
LA потреяет 1\3 от того до чего разгонися. и в итоге сохранить только 22% от того чтобыло изначально.
тоеть толко 1\5 часть вновь пртобретенного явялется чемто твердым у LA.
LA=твердая часть и мягкая часть.

LA это как матрешка. чем у нее более нижняя часть тем она более неубиваетя. пример.

LA=10 ==> 10-7 это мягкая часть она умерет за след минуту
7-2.5 оно умрет за вторую миунту
2.5-0.8 оно умрет за третьюю минуту
итд.
и то что у основания оно не урмет хер знает сколько вплоть до 14 минуты.
если ema это скрость. то трение у нее зависит от скорости. чем больше скорость тем нелинейно быстро
растет трение. чем меньше скорсть тем нелинейно быстро трение падает.

EMA похожа на пресс. она беерет новые R(t) и пресует их в себя. при этом верхние слои совесем рыхлые
но чем ниже слой он конечно более тонкий. но зато более твердый. это выгляди так

ema=10

10-7 бумага
7-2.5 дерево
2ю5-0.8 металл
0.8-0ю2 алмаз
0ю2 -0.6 атомная твердость.

у ema такой прицнип - все что толко что легко пришло такж легко уцйдет. все что пришло давно
оно каменеет от времени и хрен ты потом из нее это выковырееяешьт.

услвно говоря выковырять у ema первые 2\3 легко
дальше 1\5 сложнее , еще 1\5 тяжело, еще 1\5 супер тяжело. итд.

у ema нелиность времени. чтобы прокопать следущий -5 от нее это надо кажый раз
затратить в 2-3 раза больше усилий чем на прошлые -5

пэтому когда мы смотрим на значене EMA=N=10 то мы должны понимать что 
у нее первые 3 это резулттат послеенй минуты. вторые 3 это резульатат следущих 3 минут.
еще 3 это результат следующих 10 минут. следцщий 1 это резульатт прошлых 20 минут. итд.

Если у нас ema(now) то она состоит из 1\3 от r_sr которые его ракручивало 2 минуты назад
и 2\3 от r_s которе его раскручивало эту минуту.


1 минута R=1 la=2\3=0.67
2 минута R=2 la=1\3*2\3+2*2\3=14/9=1.55
3 минута R=0 la=1\3*1.55=0.51

LA это резултат нагрузок за последние 14 минут. они делают вот такой вклад

описыаю в обратно порядке 
1-я минута 2\3*R_sr_1
2-я минута 1\3*R_sr_2
3-я минута 1\9*R_sr_3
4-я минута 1\27*R_sr_4
5-я минута 1\81*R_sr_5
...
14-я минута (1\3)^13*R_sr_5= [6*10^(-7)] * R_sr_5 

вот какая приблительно связь между LA и нагрузками R за предыдущее время.

пример 

1- миннута с конца R=1
2-я R=2
3-я R=0

R=(-inf) ->[ 1 2 0 ]<- (now)

LA=1*1/9+2*1/3+2/3*0=1/9+4/9+0=5/9=0.55

получается просто по единичному LA хуй что скажешь так как в нем история за последние 14 минут!
если же у нас есть LA за минуту назад. и LA за сейчас 
тогда уже можно чтото сказать на счет типа средней нагрузки за эту миуту

LA(0)=2 , La(now)=3

значит lA(now)=2*1/3+3*r_sr_1
тогда 
        lA(now)=2*1/3+3*r_sr_1
        La(now)=3
тогда
        2/3+3*r_sr_1min=3
        r_sr_1=1-2/9=0.77
        
тоесть ну можно предположить что последнюю минуту на комме была средняя нагрузка 0.77
хотя еси честно то важна не средня нагрузка. а то сколько процессов было коротких легких 
и сколько тяжелых.   и насколко одни были легкие а вторые тяжелые. исходя из этого можно
понять бузи тайм. хотя с дургой стороны его можно и так посмтреть через vmstat
причем 0.77 это как бы число тяжелых процессов если мы имим разгоняли комп.

вопрос а как ema реаиигиурет на разгон длинными и короткими процесами - ответ по разному.
завсиит от времени короткости процесов. и их количества. корокие по времени высокие пики 
она срезает эфективно. но опять же- если он будет на конце таймалайна - то его доля в EMA будет заметная.
например R=12 идет в последенй точке. его вклад будет 1. тоесть эти 12 процессов коротких прцоессов
котоыре сьели всего нвсего 5с времени. они получается с точки зрения ema эквиваленты 1.67 
тяжелого процесса который бы рабоал все 13 точек. а например R=12 в первой точке даст всего навсего
0.36 к EMA. тоесть его эквивлаент 0.6 тяжелого процесса который бы работал всю последнюю минуту. 
тоесть одна и таже пачка короткиех процессов которые отрабтал на компе 5с их вклад в LA 
соврещенно разные. отличается в 3 раза. поэтому это все такие умозриетлные упрощения 
как бы нам по EMA предсказать r(t). EMA это свертка. если конечно взять график EMA тогда 
можно используя формулу

    ema(n)=0.92*ema(n-1)+0.08*R
покорпеть и восстановит всю исходную форму сигнала за последнюю минуту точно.
но вроде как свертка неиспользуется для таких целей. она должна выдавать какуюто интегрльную
полезуню инфо о сигнале R(t).

если унас есть две точки EMA и больше ничего (незнаем r(t))
то по ним мы не можем сказать падал ли или рос  R(t)
на этих точками. мы только можем сказать был ли выше или ниже R(now) относительно
ema(n-1)  ивсе что можно скзаать. 

пример

ema1=10
ema2=12

что можно скзатаь? можно скзат что ema1 был точно ниже чем r(now). однако 
какой был r(1) хер знает. был ли он болше или меньшечем r(now)
могло быть вот так


ema1=10  R=13
ema2=12  R=11


хотя R упал. но так как он все еще был выше чем ema1 то ema2 вырос. 
вот и все что нам дают две точки.
ну и еще вот это можно в голове держать
    LA это резултат нагрузок за последние 14 минут. они делают вот такой вклад
    описыаю в обратно порядке 
    1-я минута 2\3*R_sr_1
    2-я минута 1\3*R_sr_2
    3-я минута 1\9*R_sr_3
    4-я минута 1\27*R_sr_4
    5-я минута 1\81*R_sr_5
    ...
    14-я минута (1\3)^13*R_sr_5= [6*10^(-7)] * R_sr_5  (если R_sr_5=10 000 то этот член равен 0.06)


вот у нас есть LA. это получается некая интегральная история об R(t) за последние 14 минут.
к сожалению нельзя сказать где в этой истории были какие R(t). 
это могла быть бещеная нагрузка в прошлом а щас по нулям. это могло быть нагрузка по нулям в прошлом
а щас не по нулям. только оастется догадываться. увы...  можно тольо делать предположения. 
например можно предроложить что вся нагрузка было исключтетлно полследнюю минууту. ну тогда
это самая верхнняя оценка. берем LA и делим на 0.63 получаем какая бы была бы загрузка 
если бы нагрузка было ттолко поледнюю минуту. и  в форме ( а форма играет огоромную роль) постоянного
R=Const.

LA=(2/3)*LA(за посл 1 минуту) + (1\3)*LA(за вторую минуту назад) + (1\9)*LA(за третью минуту назад)+
...+ ((1\3)^13)*LA(за четрынадцатую  минуту назад)

сотвесвтенно невозможно сказать на каком участке назад была какая кариинка R(t) и какая минута
дала самый большой вклад.  можно тлоько предолагать если мы имеем только одну точку смотря
в вывод top.
если есть LA за какую то миуту назад. то уже можно больше сказать определенного за промежуток
между той точкой и настоящим моментом про характер R(t)
напрмиер 

la(-1min назад)=5
la(now)=1.67
тогда это значит что за эту минуту R(t)=0  t=[now;-1min]

если LA=N и у нас N маленькое. и ведет себя стабильно. ну скорей всего последню минуту
нагрузка была мелкая. тогда можно предположить какой LA был минуту назад. 
LA(-1min)= LA(now)*3

Если LA у нас ведет себя стабильно. значит r(t) в этой окрестности времени прктически 
совпдает с LA. поэтому она стабильна. ну тогда например можно положить что последние 5 минут
нагрузка была более менее ровная и стабильная. и равна R(t)=LA(now)
дейтсивтелно это важное замеание. LA стабильная тоько когда она примерно равна R(t).
а это происходит только если обычно последние 5 минут агрузка была более менее ровная.
хооя конечно все может быть сложнее. например у нас за минуту было R=5 тогда LA=3.33
после этого R=0 одну минуту тогда LA=1.11 а после этого R(t)=1 потоянно. тогда LA будет
тоже постоянно. тоесть как видно r(t) менялся но LA стала постоянна. 
LA  унас часто дробная величина. а r всегда целое. а LA очень болезненно регариурет 
на разницу между собой и R. поэтому если есть хотьт какая то разница между LA и R
то LA будет дергаться очень ощутимо. наприер LA=0.23 
а ближашие R=0 или R=1 поэтому LA будет дергать очень даже сильно стремясь либо к 0
либо к 1.
далее. LA как напряжение на кондеснаторе всегда стремится к равновесию с R(t) (напряжение на батарее)
чем ближе LA к R(t) тем стабильнее LA. LA похож на собаку которая бегает за сосиской R(t)
но собака не может прям сразу достать до уровня сосиски. это идет с запозданием. а елси
сосика постоянно дергается поэтому этого может и не настать. 
прикол еще в том что как уже скзаал что R(t) строго целые числа (наутуральные) а LA
всегда почти дробное. поэтому LA очень чусвиетельно к изменнеию R(t).
еще есть такой момент. если был высер наверх выстрел R(t) то la очень легко падает вниз если 
это был временный выстрел. тоесть что касается возвращения к исходной нагрузке если исчезло
R(t) то этопроисходит в какойто степени бодро. за минуту LA падает в 3 раза в случае исчезноевения
поддержки r(t) в какой то степени LA в этом плане ему помогает свое значение опирать на последние
данные R(t) нежели чем на те что были в хвосте. однако это не факт. исходя из формулы

LA=(2/3)*LA(за посл 1 минуту) + (1\3)*LA(за вторую минуту назад) + (1\9)*LA(за третью минуту назад)+
...+ ((1\3)^13)*LA(за четрынадцатую  минуту назад)

это верно тоько если нагрузка не сильно прыгает.
но запросто может быть такая ситуация. у нас 60 минут работает r=5
тоггда LA=5. потом он падает на минуту до R=0, тогда через минуту равен LA=1.67
а далее R=2, тогда он через минуту он дорастет до LA=1.89 при этом в этом LA
от R=1 часть составляет только 0.22 а 1.67 это часть от нагрузки до этого.
так как EMA это напряжение на конедснаторе то если у на батарейке возникает резкий
высокий узкий пик то это провоцирует пик подзарядки в сторону коненсаторе. 
 U(батарейки)-U(конденсатора)=delta q * R
тоесть изменение заряда пропорционально пику (разнице между напряжением батарейки и коднедсатора)
конденсатор тоесть отстрои быстро реагирует на этот пик. но поскольку между батарейкой
и коднесатором сидит R и кондесатор имеет C то изменение U которое получит конденсатор
будет заметно меньше чем чем исходный delta U между батарейй и когденастором. поэтому выскойй 
узкий пик R(t) отражается в таком же пике по фазе на конденсаторе но по амплиутде конечно гораздо 
меньше. потмоу что надо нетолько разнца в напряжении но и время потому что надо чтобы натекло 
много заряда который бы вызвал такое же повышение U на конденсаторе.
тоесть например

U_батарейки = 10
U_коленсатора = 1

R=100
C=10

в итоге delta_q= (10-1)/100=0.09
а приращение U на коненсаторе будет U_коненсатора=1+0.09/10 = 1+0.009 
вот почему я думаю в формуле стоит r*0.08. это как раз умньешнеи делты напряжения за счет
сопртивления и емкости. 

а если пик ниже но зато он по времени жирный - вот это реально вызывает серьезно изменение зарряда
а значии существенное изменнеие U_кондесатора

LA это у нас не просто напряжение это у нас интегратор  ( канистра дырявая) для хранения R(t)
за определенное время. так что это у нас шумящий мотор. если он ракручен значит комп пашет.
если он маленький значит комп спит.

LA1min быстрее зарыжается но и быстро разряжается. тоесть он ловвит все помехи. но заржявалется
быстрее. LA15min заряжается очень долго. но и разряжается очень медленно. то есть la1min
он в себя вбирает сликшмо много высоких частот. а la15min он показвает только низкий частоты.
но не понятно что с временеим регаиорвания. тоесть условно - la1min он через 3 минуты уже в 27 раз
забыл что было до того. а la15min он я думаю только через час сдуется. тоесть если R=0 то 
la15min условно говоря тлько через час сдуется до нуля. показывая нам исключетельно старый 
вольтаж. от старой нагрузки.

la1min набирает весь свежий вольтаж и частично сливает старый вольтаж от старых R(t)
я считаю что конденсатор когда волтаж сливает в сеть то он условно говоря сливает прежде всего
старые заряды. а оставляет новые.

LA напминает собой емкость где есть старая жидкрость. и есть средняя и есть новая.
каждый 5с вбирается новая жидкость. и также сливается частично старая жидкость и LA это смесь 
и старого и нового. этакий виинигрет всего свежего и также уже протухщего.
хотя  с точки зрения фильтрации сигнала - все наоборот. там нужно брать как можно меньше нового
чтобы отфильтровать длинночастотный контент.  тоесть все завсисит для чего хотеть испольовать LA

еще раз посмотрим на упрощенную формулу

LA=(2/3)*LA(за посл 1 минуту) + (1\3)*LA(за вторую минуту назад) + (1\9)*LA(за третью минуту назад)+
...+ ((1\3)^13)*LA(за четрынадцатую  минуту назад)

LA за 15 минуту уже можно считать равным нулю.


LA(за X 1 минуту) означает тот LA который был раскручен функуией R(t) именно на этом 
промежутке времени

LA хранит историю частично за весь период работы. не за сейас и не за прошлую минуту - у него
есть ошметки за всю историю. поэтому так трудно его анализировать.

поэтому когда R(t)=0 то физ смысл EMA  в том что из него как из протухшего ведра выливается старый U
который он собирал и хранил все это время.


так ну хорошо LA это сумма LA на всех участках. а какой смысл LA на отдельном участке?
во первых LA=0 для R(t)=0 . тоесть елси на участке R(t)=0 то LA=0. поэтому смысл этого понятен.
а если R(t)=Const на участке то LA=0.63*Const

теперь по поводу закона об участках.

у нас есть то что мы неработали. и вот r(t) начиает работать . 
первая минута. 

        LA(0;1min)=LA(0m;1min)

далее добавляется +1мин. точно известно что при этом верно

        LA(0;2min)=(1/3)*LA(0;1min)+LA(2min:3min)


добаялем еще минуту 

        LA(0;3min)=(1/3)*LA(0;2min)+LA(2min:3min)
подставляю
        LA(0;3min)=(1/3)*[(1/3)*LA(0;1min)+LA(2min:3min)]+LA(2min:3min)=
        =(1/9)*LA(0;1min)+(1/3)*LA(2min:3min)++LA(2min:3min)
итого
        LA(0;3min)=(1/9)*LA(0;1min)+(1/3)*LA(2min:3min)+LA(2min:3min)
добавляем еще минуту

        LA(0;4min)=(1/3)*LA(0;3min)+LA(3min:4min)=
        = (1/3)*[(1/9)*LA(0;1min)+(1/3)*LA(2min:3min)+LA(2min:3min)]+LA(2min:3min)=
        = (1/27)*LA(0;1min)+(1/9)*LA(2min:3min)+(1/3)*LA(2min:3min)+LA(2min:3min)
        
таким макаром для четрныдацамти минут будет иметь
только я щас поменяю обозначение будут писать для поледней минуты как (now)
для второй минуты с конца (now-1min) итд до (now-14min)
        LA(0;14min)=LA(now)+(1/3)*LA(-1min)+(1/9)*LA(-2min)+(1/27)*LA(-3min)+
        +...+((1/3)^13)*LA(-13min)
практика покзывает что дальше этого нет смысла. если LA(-13min)=10 000 что нераельно 
то оно через 14 минут даст LA всего 0.06.

сравнимю в формулой кооторую раньше написал

LA=(2/3)*LA(за посл 1 минуту) + (1\3)*LA(за вторую минуту назад) + (1\9)*LA(за третью минуту назад)+
...+ ((1\3)^13)*LA(за четрынадцатую  минуту назад)

в ней  я ошибся , правилная форула такая 

LA=(1)*LA(за посл 1 минуту) + (1\3)*LA(за вторую минуту назад) + (1\9)*LA(за третью минуту назад)+
...+ ((1\3)^13)*LA(за четрынадцатую  минуту назад)

итак LA предстлаявет собой сумму всех LA за все время.
отдеьный LA представляет собой экивалент R(t) на том участке если правда R(t) там был по форме
горизонтальаня линия. тогда LA будет 0.63*R(t) на том участке
еслиформа r(t)=0 то LA тоже равен нулю. а если форма сложная r(t) на участке то трудно поставить
тогда сотвесвтие между LA и r(t) на участке. так то физика понятка. r(t) это U на батарейрке
а ema(t) это U на конденсаторе. но хотелось бы понимать на уровене чисел. какой физ смысла числа LA
в отношении r(t). поэтмоу в упрощенной форме считаем что r(t) на участке это некая горизонтальная
линия. и LA повтоярет эту гор линию с коэфиицентом 0.63.
так то понятно есть R(t) напряжение оно наливает в корнденстаор. в него переливается какойто
коэфициен этого R(t). главное я опять же забывают что LA это наряжение на конеднсаторе.
а r(t) на батрейкер то ест на компе. поэтому ничего удивтетльного что при r(t)=0 у нас вылиывается
U из конденсатора. хотелось бы понимать сответвтствие между ema и r(t) на участке на цифрах.
итак LA это налитое в когденсатор часть от r(t). как вода перелитая частино из ведра в рукомойник.
формула показывает что в момент (now) в коденсаторе есть как часть r(t) за последнюю минуту
так и части остаются от прыдыдущих минут. поэтому если мы хотим чтото понять про r(t) на 
последней минуте нам нужно из ema(t) удалить мысленно все части которые там за предыдущие минуты.
ema(t) представляет собой интеграл r(t) за все время но с определнным кофэициентом для каждого участка.
если r(t) это график сколько воды лили в трубу каждую секунду то ema(now) предсталвяет 
собой сколько в иттоге воды щас есть в когденсаторе. прикол в том что если воды не подливать в трубу
то вся вода из кондесатора вытечет. если б вода из конденсатора не вылиывалась то LA на участке
был бы равен ообьему воды влитой в трубу тоесть R_sr на участке умножить на ширину учаска 
по времени. а так как вода ывалиывается провпорионально тому что у нее уже щас есть то связь
сколкьо воды будет в конденсе при вливании R(t) будет завситеть нетолько от обьема воды 
на участке ( r_sr*(ширину участка))  но и от формы R(t) вливания воды.
если r(t) это форма воды. то LA на участке это ее обьем который успел залиться в конденсатор.
тоест это именно некий интеграл от R(t) обьемная характеристка. когда форма воды заливающася
самая простая R(t)=Const то на этом интрелвале залвая такую воду у нас в когднесаторе останется
не (r_sr*ширину интервала)  а 0.62*Const то смотриа у нас ширина интервала это 1мин это 60с
значит обьем воды в этом интеравле это R_sr*60c а в  итоге у нас в конденсато зальется всего
навсего воды R_sr*0.63 это и потому что из коненсаора вода обратно вытекает. и потому что 
ее труднее запихивать когда она там набиарется и потому что сопртивление (кран) мешает заливать.
так что вместо R_sr*60 у нас зальется лишь малая часть этой воды R_sr*0.63
тут важно понять еще раз что LA это напряжение и R(t) это напряжение. R(t) это высота воды
в банке с батарейкой а LA(t) это высота воды в банке с конденсатором. между ними трубка узкая
и кран с ржавыми колесами. разность давления вызывает перетекание жидкости через кран. 
по тонкой струйке. чем больше набирается воды в конденсатор тем тоньше туда течет струя
из батареки. плюс коднденсатор имеет некую емкость тоесть шиирину поэтому скажем условно 
говоря тот обьем воды который перекает  в конденсатор он вызывает изменеиние высоты жидкости в 
коденсаторе пропорциогальное этому обьему переткшей жидкости. но чтобы давление полностью вырвнялось
слева и справа нужно время. а если R(t) быстро меняется то давление не успевает сравняться. 
поэтому изменение давления на конденсаторе оно будет пропорционально разности давлений между 
ними и времени сколько перекачка идет. Если r(t) это быстрая амплитуда то она успевает залить мало
воды даже незнаю в точнсоти из чего главным образом  - что разность давлений нетакая большая
либо из за недостаточности времени когда у нас R(t) становится меньше чем LA и вода начинает 
обратно из конденсатора выливыаться оборатно. итак R(t) это высота воды в банке 
в батарейке а LA(t) это высота воды в банке с кондесатором.
в зависимости от того где уровень выше оттуда вода и переливается то в конденсатор
то из конденсатора. когда R(t)=0 то в батарейке ноль воды по высоте и из конденсатора
вода начинает вылыивться обратно.LA1min таков что если R(t)=0 то за 1 минуту из когдесатора
выльется 2\3 воды по высоте.
итак есть стакан с R(t) который описывает высоту в этом стакане. он сообщается с другим стаканом 
конденсатором. уровень воды в нем это LA(t) в завсисомсти где уровень выще вода либо вливается
в конденсатор либо вылиывается обратно.
таким образом LA(t) это r(t) но в другом сосуде.  один влияет на другой. 
но если r(t) меняем мы то LA(t) меняется  в зависимости от нас.
возвращаемся к формуле
        LA(0;14min)=LA(now)+(1/3)*LA(-1min)+(1/9)*LA(-2min)+(1/27)*LA(-3min)+
        +...+((1/3)^13)*LA(-13min)

порятно что уровень воды в стакане щас является следствием всех R(t) которые были 
до этого. 

    LA(X)  в этой формуле это высота воды в коненсаторе в  конце очередной минуты

формула показывает что высота воды сейчас состоит из высот воды от каждой прошлой
минуты с неким коэфициентом. видно что чем дальше от сейчас тем меньше осталось воды
в конденсаторе от прошлых минут. хотя надо понимать что если в последение минуты
воды было мало а в прошлые моменты воды было много то даже несмотрят на низкие 
коэфиыиенты вода сейчас в конеденсаторе будет тода обусловаоелена именно
старой водой а не новой.
видно что ели мы хотим найти уровень воды который обслудловлено последней минутой то 
нужно из LA(now) убрать все воды которые в конденс есть иза за прошлых моментов.

когда R(t)=0 то из конесатора вода начинает вылиываться. урорвень начинает понижаться.
LA(t) в этот момент показывает ту воду которая в нем была и ее понижение.

никак не могу привыкнуть что LA(t) это вода не на компе ( батарейке) а на другом обьеткте - на
когдегсаторе. поэтому когда R(t)=0 непогнятно потоянно что это такое LA показыает.

пллучается если у нас есть LA(now)=0 - уровень воды в когденс сейчас. и мы будем держать 
в батарейке уровень воды R(t)=Const то через 1 минуту в конденсе будет уровень воды 
всего навсего Const*0.62. Тоесть будет чуть больше половины от уровня воды на батарейке.

при каждой миниитерации у нас вначалев кондесаторе вода выливается понижается уровень
на 8% а затем повышается на 8% от уровня воды на батарейке.

lA(t) это аналог R(t) но в другом сосуде.

Есои R(t) меняется очень часто от времени то в коненсе эти изменения будут отражаться в очень 
мало мере. потому что если у нас есть delta h между батарейкой и конденсом то нужно время 
чтобы вода перетекла в нужном обьеме чтобы уровень воды в конденсаторе LA(t) стал 
таким же r(t) как на батарейке. действиельно. если R(t)=10м
а LA(t)=1m то определнно нужно время чтобы вода перетека и уровень в конденсе стал 10m
разностная формуле это очень точно отражает

    ema(n)=ema(n-1)+0.08*[ r(n)-ema(n-1) ]  --> изенеие в конденсе за 5с
    
тоесть за дельта_т времени в конденс уровент воды повышается пропорционально
разнице уровенй воды между батарейкой и конденсом с некоторым кофициентом который
обусловлен величиной дырки между ними и величиной контейнера конденса. тоесть разница давлений 
порождает скорость потока воды. а ширина площади когденса влияет сколько delta h высоты воды
прибавляет в конденсе на единицу влитой воды через трубу. если кондекс имеет мелкую площадь
то та же самая дельта давлений тот есть тот же самый обьем воды будет приводить 
к более мощному прибавлению высоты воды в конденсе.

итак что же конкретно значит цифра в LA(t)=N например LA(now)=10
что значит обьем цифры?  у нас комп работает все это время. и r(t) это высота жидкости 
в некоей банке. она меняется. из за этого в некий виртуальный коднденсатор натекает тоже 
уровень жидкости. это и есть LA(t). ее величина является следвствием всего времени работы
компа и конкретной форму R(t) за все время работы компа. вода то вкачиватеся в этот вирт кондестаор
то выкачивается. Если у нас высота LA(now)=10  и у нас на компе R(t)=15
и он таким будет держаться 5 минут. то через 5 минут LA(now+5min) тоже станет = 15
Если LA(now)=10 и мы в течение минуты обеспечим R(t)=0 то через 1 минуту получим
LA(now+1min)=10/3=3.3 а если мы будем так держать 5 минут то мы получим через 5 мин
LA(now+5min)=10/3/3/3/3/3=10/(81*3)=0.04
LA спокойно принимает дробные значения. в то время как R(t) принимает только натуралные 
значения. LA очень чуствиелльно к разнице давлений. Поэтому так как R(t) всегда натуарльное (1,2,3...)
а LA почти всегда дробное то LA постоянно находится в динамическом измененениии.
стоит только поменться R(T) и начинаются долгие процессы выравнивания LA(t). тоесть
если даже R(t)=Const то надо очень много время чтобы LA выровнял свой уровень воды с R(t) котоырй
всего навсего константа. а так как r(t) постяонно меняется то la(t) в итоге имеем сложную завиисимость
от r(t)

например la(0)=0 r(1min)=5=Const  r(2min)=0=Const через 2 минуты lA(+2min)=5*2/9=1.11
критическое значение имеет не сама величиана r(t) а текущая разница LA(now)-R(now)
чем она больше тем более значительная часть R(t) сравняется с LA(T) за единичный интервал
времени скажем 5с.чем меньше разница LA(now)-R(now) тем более незначительное будет изменнеие
LA(t+delta_t) и если R(Const) то выравнивание воды в конденсе займет охирительное время
хотя казалось бы что уровень почти не отличатеся в горшках. 

теперь по поводу что конктено значит цифра 10 например LA(now)=10
что можно из нее скзаать ? что можно сказать из нее про R(t) ?
и тут дело вот в чем - надо понаблюдать. если эта цифра держится стабильно то это одно.
если она скачем то это другое. 
как я уже сказал - LA очень чуствителен к разнице между LA(now)-R(now)
и та как R(t) имеет толко значеня 1,2,3,4 а LA(now) при этом за корокиеи прлмежутки времени
получает лишь небоьшое колиество воды и выравнивает разницу высот очен медленно это измеряется
минутами чтобы выровняться то это приводит к тому что для того чтобы LA=10 был стабильным надо 
чтобы R(t) уже значииельное время неменялся. тоест на компе дооожно быть 10 стабьльных 
долгоигращих процесса. с незанчительными флуктуациями. поэтмоу если LA=10 держится твердо
то значит на компе уже минут 5 работает порядка 10 долгих процесса.
если же LA постоянно дергается то надо смотреть как сильно он дергается. 
LA может легко быть 10 вот в такой ситуации- la=7 потом 
на следущие 5с у нас R=37 тогда

    ema(next)=7+(37-7)*0.08 = 7+3=10

тоесть один пик коротких процессов может поднять LA легко. 
С другой стороны это может быть обратная ситуация. у нас когда то была нагрузка.
она накачала высокий lA а уже давно r(t) после этого низкий. например
минуту назад lA(-1min)=30
а последнюю минуту R(t)=0=Const 
тогда la(now)=30/3=10

тоесть вот эта форула

LA(0;14min)=LA(now)+(1/3)*LA(-1min)+(1/9)*LA(-2min)+(1/27)*LA(-3min)+
        +...+((1/3)^13)*LA(-13min)

она говорит о том что любой в целом кусок r(t) за все времы компа дает вклад
в текушее занчение LA(now) и какой это кусок и как он выглядел абсолютно неизвестно
если у нас просто ест одна точка LA(now)
Это как у нас есть значние интеграла в точке. Что при этом мы можем сказат о функции?

есть еще одна очент важное свойтсво  - так как r(t) и LA(t) это уровень воды то
если у нас r(t)=A например r(t)=5 то скоько бы времени он недержался таким то 
LA при этом максиму достигнет только LA=5 и выше никак не поднимется. Однако
если у нас щас LA(now)=5 это совершенно незначит что все время до этого у нас максиальный 
R(t) был 5. конечно нихрена.  он мог быть хоть 100 хоть 200. а потом просто понизился 
и LA тоже понизился. 
Другое дело если у нас есть график в каждой точке на отрезае t=[t0,t1]
и мы видим на этом графике что la(max)=10 а la(min)=3  но опять же -- нам это не доказывает
что на этом отрезке не было R больше чем 10. конечно нет. согласно формуле

ema(n)=ema(n-1)+0.08(r-ema(n-1))

следует то что r=0.92[ema(n)-ema(n-1)]
                 ----------------------  
                       0.08

тоесть мы можем опрееилиь на отрезке t=[t0,t1] какой у нас был макс пик R(t)
надо взять самый высокий пик la(t) на этом отрезке и подставить в формулу. 

тоесть ситуация как раз другая. надо смотреь не на график ema(t) а смотреть на график 
R(t). так как самый нижний уровень воды это 0. то если у нас есть график R(t) то согласно формуле

    ema(n)=ema(n-1)+0.08*R*(t)


то тогда макс величиан ema от такого графика R(t) может достигнуь 8% от max(R(t)) на отрезке 
t=[t0,t1] плюс значение ema в предыдущей точке.
я тут скажу так. если у нас есть R(T) с момента включения компа и у этого r(t) есть max(R(t))
то la на этом промежутке времени как не может превысиь этот max. это факт. 
а так елси у нас етс отрезок  t=[t0,t1] и в его левой точке la(t0)=A
и есть график R(t) на этом отрезке  и у него есть max(R(t))
то на этом отрезке LA максимум что может достигнуть это A+max(R(t))
и то это будет в том случае если отрезок длинный а R(t)=Const.
тогда LA достигнет A+max(R(t)) через 5 минут.

итак возврашается к примеру LA(now)=10 что это на практике значит?
по самой цифре ничего не скажешь. ясно одно - на какомто этапе времени наш R(t) был равен 10.
это факт. но непонятно как давно и как долго. то ли это было давно и R(t) был намного выше 10.
или это было недавно и он очень долго держал этот уровень. это все непонятно и неивестно.
ясно только что в какойто момент это было. один вариант - нагрузка была еше выше и она упала.
друной вариант нагрузка постоянная и тогда она уже давно такая. или это это ряд мощных пиковых 
значений недавно. 
кстати пики с выскомии значенями R(t) не так и страшно. это просто могут быть какието улльтра 
легкие процессы которые пачками отарабватывают за 5с. тоеть не так важно число процессов
как то насколько долго они выжирают время. 30 процессов в течение 1с каждые 15 секунд это фигня
по сравнению с 3-мя процессами которые сидят на цпу все время.
нас похорошему инерсует не число процессов а то насколко унас много тяжелых процессов.
если cсигнал r(t) неочент забит помехами с выскомими ампиьутудами мы можем разглядеть эти 
процессы через график LA. потому что он до какойто степени как раз таки на пики реагирует 
неохотно более сильно реагируя на длительные воздейтсвия чем на короткие выскоие пиики.

итак на счет LA(now)=10

положим что у нас бывают выбросы R=30
а скажем более равноевесное значение это R=1.5

посмтрим как долго надо чтобы выйти на LA=10

l(0)=1.5
через 1 минуту ema будет равен

l(+1min)=(30-1.5)*0.63+1.5=19.45
тоесть нужно гораздо меньше минуты. щас скажу точнее
t LA
0 1.5
5 3.8
10 5.9
15 7.8
20 9.6

тоесть надо 20с и дело в шляпе.

можно другой патерн рассмотреть

r(t)=1.5 30 1.5 1.5 30 1.5 1.5 30

$ ema=1.5; r=( 1 30 0 1 30 1 1 30 1 0 30 1 30 0 ) ; for i in $(seq 0  5 60); do ema=$(bc <<< "scale=1; $ema*0.92+0.08*${r[$(($i/5))]:-1.5}"); echo "$(( $i  ))  ${r[$(($i/5))]:-1.5}  $ema"; done
t  R   LA
0   1  1.46
5  30  3.74
10  0  3.44
15  1  3.24
20 30  5.38
25  1  5.02
30  1  4.69
35 30  6.71
40  1  6.25
45  0  5.75
50 30  7.69
55  1  7.15
60 30  8.97

тоесть мы достигли 9 за минуту. но посмотрим страшная ли это нагрузка
у нас пики по 30 короткие. всего 5с максимум. тоесть мы незнаем они все отраабтывают 
за 5с или за 0.1с   в любом случае максимум они жрут 5с. а между этими пиками
идут мизерная нагрузка R=1 который тоже непонятно - может оно ест 5с а может 0.1с
для этого надо смотреть дополниельно busy time.
а так формально LA=9 который выглядит так как бутто у нас 9 процессов работает последние 5 минут
непрервыно. но это совсем не так. маленькие короткие процессы нам набили выскокий lA.
а так lA=9 или LA=10 показывает что в какойто момент у нас R(t)=9 был. но как давно это было
и как долго неизвестено. нужен график LA(t) 
итак еще раз lA=9 показывает что коода унас R(t)=9 был. и больше мы ничего незнаем.
безусловно что мызнаем что если что то LA падает за 1 минуту в 3 раза если R(t) подскочил 
а потом упал. или то что на мотоноой нагрузке нужно 5 минут чтобы доайти от 0 до 9.
но как я уже показал если у нас на компе есть кучка коротких но много процессов. то 
они могут за 20-60 секунд нам легко поднять la до 9. однако это не означает что комп
перегружен.
ксатти в чем пизда - если сморим  в top или в ps aux то надо смотреть 
не процессссы а треды . потому что оодин процесс может иметь лимон тредов.
и каждый из них лезет на цпу. поэтому в top выгляди так что у нас 1 процесс 
висит  в статусе R ты думаешь о шокладно. а на самом деле у него 10 тредов
как это ест у хрома. и он сука в итооге имеет 6 тредов с R статусом. приплыли.
получается  что R(t) это как некий насос. если он херачит работает причем правилным 
рисунком то в конденсатор накачивыается столб воды. а как только R(t) перестает качать 
то столб воды начинает понижаться. да этопохоже на движок или колесо. пока на газ давишт
там ревет. как с газа снял то успокаивается.
там где la растет там r(t) всегда выше лежит. там где la падает 
там r вегда ниже лежит. оно и понятно. растет или падет график la означает куда течет
вода из конденса либо в него в случае роста либо из него в случае падения. а рост или 
паление определяется разницей давлений. 
так что я отрыл из практики если у нас есть LA в некоторой точке (t)
то если дальнейший R(t) меняется вниз или вверх на 0.5  относиельно этого LA
тоесть амплитуда 0.5 то этот LA практически неменяется , тоесть 
если у нас LA(t0)=4.3 то если дальше идет R(t) такой что 
разница по модулю |(R-LA)| <= 0.5  
то LA практически не меняется. на него эти R не влияют.  в данном случае для LA=4.3 
это будут R(t)=4 и 5. Правда еще важный момент они должны регулярно чередоваться. если будет 
слишком много подряд 4 или 5 то LA конечно начнет смещаться. посмотрим на основе формулы 
как это выглядит.

la0=4.3
R=5 la=0.92*4.3 + 0.08*5=4.35 то разнца составила 0.05

и детсиельно посмотрим на основе другой формулы
la(n)=la(n-1)+(r-la(n-1)*0.08=4.3+(0.7)*0.08=4.3+0.056 , 0.056 ~=0.1
   а 0.1 это вообще практически нихрена в рамках единицы. поэтому если LA
   идет в коридоре +-0.5 тоесть LA=скажем 7.3 а Rменяется регулярно в коридоре 7 или  8
   а средння между 7 и 8  это 7.5 а 7.5 и 7.3 это очент близко так что очевидно что 
   LA будет недергаться а крутится вокруг 7.5. но вернемся к нашему примеру
   
R=4 la=0.92*4.35 + 0.08*4=4.32 
R=5 la=0.92*4.32 + 0.08*5=4.37
R=4 la=0.92*4.32 + 0.08*5=4.34
в итоге через минут 5 он выйдет на равновесную 4.5
и будет там крутитсья. 

я еще пример рассмотрел когда la0=0.5
и R=0, 1
так в итоге LA вышел на 0,46; 0.50 и он их чередовал и все.

таким образом когда LA смещается в результате очереной 5с итерации. то если дальше
R лежит в коридоре +-0.5 то LA больше дергаться небудет.!
и что здесь еще замечаттнльно это то что соверщенно четко понятно из такого поведения LA
какой паттерн R(t) его окружает. еще раз если у нас очердной LA=N 
то его равновесное состояние это LA=N и чтобы в нем быть ему надо чтобы R(t) дальнейший
лежал в коридоре R(t)=N+-0.5 если R(t) такой коридор обеспечивает LA то он уже 
дергаться не будет. это и есть его равновесное состояние. или говоря другими словами
если есть LA=N и дальше у нас | delta(R(t)-LA) | < 0.5 то LA проходя через такой r(t)
его не почуствует. R(t) на LA не повлияет.
когда у нас R(t) выглядиит как ( 3 4 3 4 3 4 3 4 3 4 )
то это же синусоида вида y=3.5+0.5*Sin(T=10с) соотвественно как себя ведет LA
это у нас сумма двух функций y=Const и y=Sinx  . как ведет себя LA при столкновении с константой
я уже знаю. она будет на нее выходить но так как мы уже на нее вышли оказывается то она будет 
держаться на ней. нанизываться на нее. а синус даст то что она будет отклоняться по синусу
то туда то сюда. но так как у синуса средняя равно нулю то отклонение будет в сумме нулевое 
и гулять вокруг равновесной y=3.5 амплитуда синуса исходного будет уменьшена в 0.08 раз то есть
считай в 10 раз. такое уменьшение для такого короткого синуса я уже видел на практике. все сходится.
но все таки я вернусь к трактовке попроще. если у нас LA=N и R(t) лежит в коридоре одного 
квадратика на графике тоесть R=N+-0.5 то LA такой R не почуствует. такой R этот LA неизменит.
это его равновесное состояние. в таком коридоре изменнеия R(t) наш LA чуствует себя как равноевес
ное состояние.
кстати получается что если у нас R колбелется по какому то закону между R=0 
и R=2 например. тоесть R=(0 2 0 2 2 2 0 2 2 2 2 0 2  0 ) то пофакту это похоже 
на сумму функций R(t)= Const+ 1*Sin(T=такойто) = 1 + 1*Sin ()
тоесть это прохождение через равновесное состояние y=1 и синус с амплитудой 1.
ну или это группа синусов у всех амплитуда 1 просто разные частоты.
исходя из этого la(t) будет колебаться вокруг равновесного состояния y=1 и смещаться
вниз вверх только не на амплитуду 1  как это есть у исходного R(t) 
сигнала  а амплитуда будет ~= в 10 раз меньше то есть 0.2 тоесть LA будет вот так гулять
LA= 1 + summa ( 0.05*Sin (wi*t) ) тоесть он будет гулять в диапазоне LA=1+-0.5
вот и синусы обрели смысл
если R(t) такой что он предсталяет собой некую константу и синусы и все это длиится досаточно 
долго то Ema найдет его равновесную. займет ее. потом она сожмем амплитуду этих синусов в 10 раз
и будет колебаться по закону Const+summa [(A/10)*Sin (n*t))]

да. пркольно что вот эти вот точки
R=(0 2 0 2 2 2 0 2 2 2 2 0 2  0 )
это на самом деле как бы снятые точки с графика синусов. офигеть.

тогда получается что график
R=(0 1 0 1 2 3 4 5 3 3 2 1 ) это на самом деле как бы
слепок из суммы констант и синусов щас покажу

R=(0 1 0 1) это R=0.5+0.5*Sin

R=(2 3 4 5 3 3 2 1 ) это R=3.5+1.5*Sin 

соотвасвтнно суммарно это 

R=(0 1 0 1)  R=0.5+0.5*Sin  при t=[0с:15с]
R=(2 3 4 5 3 3 2 1 )  R=3.5+1.5*Sin при  t=[20с:55с]

получется этот R(t) это одна равновесная плюс помеха из синуса и она переходит в другую 
равновесную плюс помеха из синуса. соовттвенно LA сколько успеет за это время перелезть с одной
горизонт палки на другую столко и успеет. а у синусов она сожмет амплитуды в 10 раз.
так она ползет по этому графику.

соотввенно когда la двигается она как работает - вот она сдвинулась по оси Y 
в какое то значение LA=N. плюс минус 0.5 от R она далее вообще не почуствует
это ее железный коридор. если же R(t) следущий существенно нележит в этом коридоре 
то LA сдвинется тогда на новое равновесное положение. и так до тех пор пока она 
не выйдет на такой R который будет далее лежать именно в этом ее равноевесном коридоре.

EMA похожа на лошадь которую пинают то вверх то вниз кулаками через r(t) и она смещается
под градом ударов но толко на 10% от разницы между ней и новым R(t), так вот это ее 
смещение на 0.08*r которое примерно равно 0.1*r оно вот что подразумевает. оно подразумевает
что новый сигнал R(t) кторый кроется в следущем сэмпле он в себе содержит не более 10% колебания
тоесть помехи. а остальная часть у него это постоянная по оси Y составляющая. так подразумевает
EMA поэтому она смещается на 10% в сторону очередного R(t) , у него она считает 90% 
это помехи а 10% это реальноый постоянный полезный сигнал которые не дергается. 
и если дальге реально r(t) дергается не более чем в коридоре 10% то EMA наконец то 
попадает на равновесную и ее пеерстает швырять. а если R(t) еще нетакой то EMA на следущем сэмпле
ее швырнет опять вверх или вниз. внадежде что наконец этот сэмпл дергается далее не более 
чем на 10%. другая интерпереатация если высота воды в R(t) в батарейке далее колеблется 
не более чем в пределах 10% тоесть по 5% в ту или иную сторону вверх или вниз то движения воды
между батарейкой и капаситором почти не будет. и между капистором и батарейкой натупает 
равновесие по давлению.

пример LA=20, 
R=20+-2

тогда LA и R будут в равновесии. LA будет колебатьая по закону LA=20+-0.2

далее если у нас R упал откуда то до R=0 то для EMA это реально значит что далее 
равновесная это 0. и она будет к ней максимально стремться так быстро как может.
когда она достигнет 0.5 то будет уже дальше очень мделенно приближаться к нулю. 



!! далее план такой  разбираю график. пытаюсь еще лучше понять как движется LA
при столновении с R(t) чтобы еще лучше понимать значение именно цифры конкретного
значения у LA=N, чтобы движение LA через r(t) прям чуствовать. чтоб понимать сввязь 
между  delta la за минуту  в зависимости от  формы R(t)
насколтко я понимаю для LA сигнал R(t) это набор прямых горизонтальных (еще возможно 
наклонных) и на них нанизаны синусы. синуса она сжимает. а вот на гор прямые она тяжело
ползет. надо сделать сигнал в виде R(t)=k*x и посмтреть как она него взбирается.
я думаб что так как квадртаны импусль это синус на который добавлены синусы с нечетными
частотами я думаю что треугльный импусль это это тоже синус плюс другие синусы с особыми
частоаттами. в квадратном импульсе ширина импульса это T\2 большого синуса.
в треугльном я думаю там полуширина трегольника это T\4 главного синуса


о чем говоит h мы не знаем рисунрк R(t) но если мы его предположим
то значения прдут

рисунок r(t) зааеет однозначно ринсуок ла(т)
и наоброт рисуноу ла(т) задает риснуок р(т)

если есть рисунрок r(t) он однзнаочно опделедяет рисноуно la(t)
если есть риснок la(t) он однознкчно опщеляет риснуо r(t)
если есть две оочки la(t) и еси мы предпождиим рисунок la(t) мы узнаем рсиунок r(t)
если есть дна точка la(t) нам нужно от нее назад мысленно задать риснуок la(t) и 
мы узнаем рсиснок r(t). или надо задать форму r(t) тогда придет прридеи рисунок r(t) 
тость цифры

если ес ьдве точкти ла(т) и если мы предподожим риснок ла(т) прт этом то 
мы точно узгнаем ринок р(т)
пример

la(0)=0.64
la(1min)=1.19
придумаем рисунок laa(t)  la=k*x+b
тгдда рисунок r(t) будет вот такой


la=k*t+b
0.64=k*0+b
1.19=k*60+b

1.19-0.64=k*60
k=0,0092
b=0.64

la=0,0092*t+0.64


0.6400 0.6860


ema(n)=0.92*ema(n-1)+r(t)*0.08=ema(n-1)+0.08*(r-ema(n-1))
получааем 
ema(n)-ema(n-1)=0.08*(r-ema(n-1))
разница между новым la и старым la это разница между старым la и r поделенная на 10.
или новый la это 0.92 старого плююс 8% от r ~- 90% от старого плюс 10% от нового r


r=(ema(n)-0.92*ema(n-1)/0.08 = (0.6860-0.92*0.6400)/0.08= 1.215


получил удвительную вещь. если La это наклонная прямая то R это тоже наклонная прямая
причем она иммет тот же самый наклон. только лежит выше.!!

дейсивтельно если 

y(n)=k*n+b
и
y(n)=y(n-1)*0.92+0.08*r(n)

подставляем

k*n+b=(k*(n-1)+b)*0.92+0.08*r(n)
тогда
r(n)=(k*n+b-0.92*k(n-1)-0.92*b)/0.08 = ( k*n + b - 0.92*k(n-1) - 0.92*b ) / 0.08 =
= ( k*n + b - 0.92*k*n + 0.92*k  - 0.92*b ) / 0.08 = ( k*n - 0.92*k*n   + 0.92*k  + b - 0.92*b ) 0.08=
= (   (k*n - 0.92*k*n)    + 0.92*k  + (b - 0.92*b)  ) 0.08 = 
= ( 0.08*k*n + 0.92*k +0.08*b ) / 0.08 = k*n +(0.92/0,08)*k + b = k*n +(0.92/0,08)*k + b = 
= k*n + 11.5*k + b

r(n)= k*n + 11.5*k + b

итак

    y(n)=k*n+b
    r(n)= k*n + 11.5*k + b
    
проверим 
l(0)=0.64, l(12)=1.1920,
0.64=0*k+b ====> b=0.64
1.1920=k*12+0.64 ====> k= 0.046

y=0.046*n+0.64
значит
r=k*n + 11.5*k + b= 0.046*n + 11.5*0.046 + 0.64 = 0.046*n + 1.1619

    y=0.046*n+0.64
    r=0.046*n + 1.1619

найдем r(12)=1.7139 это похоже

 а теперь вот что наклон кривой la нам виден из графика. хочется узнать каков размер 
 перепада. тогда из графика la сразу понятно как рисовать график r. надо рисоват прямую 
параелную линии la только нужно вверх отступить на велчичину перепада

 r(n)-l(n)=  k*n + 11.5*k + b -( k*n+b ) = k*n + 11.5*k + b - k*n-b  = 
 = + 11.5*k 
 
 получается перепад равен
 
    r(n)-l(n)= 11.5*k 
 
    
итак имеем три формулы

        y(n)=k*n+b
        r(n)= k*n + 11.5*k + b
        r(n)-l(n)= 11.5*k 


пусть у нас есть la_0 и la_n это крайние занчение на каком то интервале от n=0 до n=12
где 12 отвечает за интервал 1 минута
тогда 
    
 y(n)=k*n+b 
 
 la_0=k*0+b   ==> b = la_0
 la_n=k*n+b   ==> la_n=k*n+la_0  ==> k=(la_n-la_0)/n = (la_n-la_0)/12
 
 итого
    y(n)=[(la_n-la_0)/12]*n + la_0
    

    
    
    
    тогда у нас уже 6 основных формул
    !!!!!
    
        y(n)=k*n+b
        r(n)= k*n + 11.5*k + b
        r(n)-l(n)= 11.5*k 

        y(n)=[(la_n-la_0)/12]*n + la_0
        r(n)=[(la_n-la_0)/12]*n + [ (11.5/12)(la_n-la_0) + la_0 ]
        r(n)-l(n)= (11.5/12)*[(la_n-la_0)
    
        где la0 - это LA значение в какойто точке
        а la_n это значение LA через минуту. тоесть минутный интервал.
        в плане перепада интерсно , получается что сдвиг r над la 
        это 96% от разницы на концах (la_n-la_0)

        также насколько я понимаю если у нас графики LA и r постоены от t
        то это аналогично деформации масштаба по оси X это значит что величина Y
        перепада останется точно такой же. изменится лишь наклон. 
        
        То есть финальное правило - если у нас есть график la(n) или la(t) 
        и на нем в течение минуты la имеет вид наклонной прямой то график r который
        работал на этом интервале имеет вид точно такой же наклонной линии только 
        его надо поднять на величину (11.5/12)*[(la_n-la_0), где la_0 это la
        в левой точке минутного интервала, и la_n это правая точка минутного интервала
        
        например la(левая)=0 la_n(+1мин)=5 значит на этом интервале график r имеет
        форму такой же линии. нужно график la сдвинуть вверх на 5 в каждой точке.
        или если быть более точным на 4.79
        
        Еще один очень важный момент. Вот у нас дан минутный интервал и на нем известна
        из графика наклонная линия LA. так вот из нее мы можем определить график R во всех
        точках этого интервала кроме самой левой. потому что 
            ema(n)=ema(n-1)0.92+0.08*r(n)
        тоесть из формулы видно что чтобы знать r(n) нужно знать ema в предыдущей точке (n-1)
        поэтому мы не можем опреелить какой был r(0). ну и ладно. но это надо четко понимать

!!!!!!
 
 
 
 
 

проверим нрвую формулу для r(n)
 $  la_0="0.64"; la_n="1.1920"; n="12";  bc <<< "  scale=11;    ($la_n-$la_0)/(12*$n) +  (11.5/12)*($la_n-$la_0) + $la_0    " 
1.17283333332

проверим перепад
$  la_0="0.64"; la_n="1.1920"; n="12";  bc <<< "  scale=11;    (11.5/12)*($la_n-$la_0)    " 
.52899999999

рабоатет!




la(now) это свертка R(t) t=[-inf, now]


таикм оборазом я теперь знаю как ведет себя la если график 
    - r(t) квадратный импульс,
    - r(t)=0,  (частный случай квадратного импулсьса)
    - r(t)= наклонная линия.

Кстати приходит понимание как реагирует LA на разрывы графика R(t)
если график R(t) гладкий то LA(t) тоже гладкий. Если R(t) это синусоида то 
LA(t) выдает типа синусоиду или синусоиду. Если R(t) это разрыв как в случае квадратного 
импульса то LA(t) реагиурет на это экспонентой причем не на уровне одной точки там где 
разрыв в большущим интервалом с экспонентой. кстати если R(T) может иметь разрывы. то LA(t)
неможет иметь разрывов. она везде непрервыная. она места разрыввов у R(T) склеивает экспонентами.




вовзвращаюсь к  тезисам:


Если у нас есть одна точка LA(now) мы хотимиз нее
получить  рисунок R(t) но получить не можем.
Но если мы предположим каков был характер рисунка R(t) то  цифровые значения тут же придут


рисунок r(t) зааеет однозначно ринсуок ла(т)
и наоброт рисуноу ла(т) задает риснуок р(т)

рисунок r(t) сразу определяет рисунок la(t)
и наоборот рисунок la(t) задает рисунок r(t)
если мы знаем одно то сразу можем получить другое


Рисунок R(t) однозначно задает LA(t).
тоесть если мы знаем R(t) то мы сразу знаем какой есть LA(t)


если есть точка la(t) то из нее рисунок r(t) не получить
есть есть точка r(t) из нее рисунок la(t) не получить


если есть рисунрок r(t) он однзнаочно определяет  рисунок la(t)
если есть риснок la(t) он однозначно определяет рисунок r(t)
если есть две точки la(t) и если мы предположим характер  рисунка la(t) - например 
у нас есть две точки la(t) слева и справа. если мы нарисуем (предположим) 
как выглядела кривая la(t) на этом отрезке то мы сразу узнаем рисунок r(t)

если есть одна точка la(t) нам нужно от нее назад мысленно задать риснуок la(t)
или мысленно назад задать характер графика r(t) и 
мы узнаем рисунок r(t) в цифрах. 



теперь примеры.
у нас есть одна точка la(now)=5 
что можно сказать об r(t) до этого ? для этого надо предположить какой был r(t) или la(t)
до этого? потому что точного ответа нет. один вариант - у нас все это время комп более менее равномерно
работал. тогда la=5 дает то что все это время комп работал с R(t)=Const=5 и это для
компа 2-цпу большая перегрузка. Можно предположить что у нас когда то была большая нагрузка
а потом она упала до нуля. тогда Используем то что каждую минуту la падает в три раза, 
также надо предположит а сколько минут у нас комп уже имеет R(t)=0 , пусть у нас R(t)=0 последнюю
минуту. тогда LA(-1min)=15 , что можно скзаать какой был R(t) тогда? для этого опять же 
надо уточнить  а какую форму имел R(t) тогда? положим что там был R(t)=Const все это время.
значит тогда R(t)=15 на интервале t=[-13min,-1min] и R(t)=0 при t=[-1min;0]
Может быть что угодно. Например все это время комп работал ну нуле R=0 но за последние 5с
у него выскочил пик R(now)=62 , тогда наш LA(now) будет равен 5.
Тоесть одна точка LA незначит нихрена. Она никак нам не может раскрыть ни амплитуду R(t)
ни ее рисунок. Чтобы чтото сказать нам придется ПРОФАНТАЗИРОВАТЬ хотя бы какой формы был сигнал r(t)
до этого. тогда мы сможем дать цифры для r(t).
более того если у нас la одна точка и она маленькая то это тоже нам нихуя не дает. ничего.
пусть la(now)=0.1 Это может означать какой угодно график r(t) до этого. как  я говорил максимум
что мы знаем по одной точке что 

               0 < r_srednee_1min < 2.63*LA(now)
               
это все что мы можем сказать!
нам нужно предположить какая была форма рисунка r(t) тогда можно это все наполнить цифрами.
напрмиер мы полгааем что комп все это время работал более менее равномено. тогда La(now) 
неменялось и R_sr(t) за все это время = 0.1 , тоесть комп небыл нихрена ненагружен.
Или. Комп был под нагрузкой но последнююю минуту r(t)=0 тогда мы знаем что la(-1min)=0.3
но опять же чтобы скзаать какой r(t) был раньше чем 1мин нужно предполжить каакой там был 
рисунок r(t)
итак что можно выжать из одной точки la мы разобрались. кокнетный физ смысл одна точка мало имеет.
если r(t) имел некоторую простую форму то LA(t) тогда отражает среднюю от r(t) на этом участке. 
но это только в частных случаях r(t). вот еще формула

LA(0;14min)=LA(now)+(1/3)*LA(-1min)+(1/9)*LA(-2min)+(1/27)*LA(-3min)+
        +...+((1/3)^13)*LA(-13min)

если r(t) это график высоты воды в кувшине в который мы то подливаем воду то отливаем 
то la(t) это график воды в другом сообщающемся кувшине. - чем больше работы по вливанию воды
в r(t) мы проведем тем больше воды перельется в кувшин с la(t). la(t) это некий аналог работы
которая была совершена через r(t). хотя la(t) имеет ту же размерность что r(t) но все же 
по своей сути la(t) больше отражает энергию проделанной работы r(t) на промежутке времени
нежели просто высоты в кувшине. еще такая идея - когда мы из r(t) воду забираем то 
ее высота падает и в la(t). la(t) это фнукция на всем протяжежении времени. если мы возьмем
отрезок то там можно рассмореть delta_la(delta_t) тогда цифровое значение la(t) показывает 

берем бутылку R(t) открвыаем крышку и из нее херачит вода со скоростю 1 кубометр\с
потом скрость воды начинает падать. и через 1 минуту скорсость воды из бутылки 1\3 кубомтетр\с
еще через минуту скрость воды из бутылки 1\9 кубометр \с.
я беру еще бутылку и ставлю и открываю. у меня суммарная обьем воды вытекающий
из бытылок это 1+1\27 кубометра в сек. получается что закон вытекания из бытлки он такой.
вначале это 1 кубометр в секунду. через 5с это 0.92 кубометра в сек.
так вот я что делаю. я беру новую бытлк. и открываю. у меня обьем воды вытекаюищий щас
это кубомер в сек. через 5с я добаволю +1 новую бутылку. у меня суманый обьем 
вытек воды в сек щас это 1+0.92*1, через 5 с (15с) я ставлю еще одну бутылку
у нас сумарный обьем вытек воды это  1+0.92*1 + 0.92*0.92*1
я посчитал если у нас бутылка изначально выдает 1кубометр в сек. и если эта уэтой бутылки
скорость падает по закону  1\e за 1 минуту то макс скорость истечения кубометров 
в сек которую можно достичь постоянно выставляяя по новой бутылке каждые 5с это 12.5 кубометров
в сек.  это получается сумма 1+0.92*1+0.92*0.92*1 
в которой каждый член прибавляется через 5с. 
по факту это формула суммы экспоненты которая имеет вид
y=e^(-t/60). соовсвтенено я в нее подставляю t=0,5,10,15,20,25,30
и суммирую. и получаю 12.5 кубометров в секунду.
получается если  я возьму бутылку которая херачит из себя не 1 кубометр в секунду
а 1\12.5 кубометра в секунду то у меня эта сумма будет равна 1 тогда.
дальше  я делаю вот что. повторяю тоже самое что делал. только с новыми бутылками.
и еще у меня R(t) это не константа а это r(t) график. и тогда  мой поток в кубометрах 
на данный момент можно узнать по формуле ema

ema(n)=ema(n-1)*0.92+0.08*r(t)

значит фишка в чем. если будет ставить r(t) со старыми бутылками то получается что 
бутылки с 1 кубометром будет приводить  к 12.5. а если ставить (1\12.5)*r(t) = 0.08*r(t)
то использование 1 кубометровых бутылок будет давать сумма равную 1.

соответсвенно если r(t)=3 то это означает что мы исползуем три бутылки по литру мощности.
они будут давать 3 в сумме. 

полуается пользуяюсь это формулой если мы домножим на 12.5 то мы всегда узнаем реальную 
выходную струю у таких бытылок. 

теперь понятно откудв взялися этот 0.08 коэфииуент.
ксати мы плоучетс в формуле summa (wi*xi)/12.5 мы просто внесли 1/12.5 внутрь
каждого xn

итак r(t) это число новых выставленных бутылок. 
ema(t)*12.5 это мощность выливаемой воды в кубометрах в сек прям щас.
получается елси мы будем ставить неболее чем по 1 банке каждые 5с
мы не получим поток быстрее чем 12.5 кубометров в сек. это предел.

теперь понятно что физричеки значит ema если r это бутылки с водой. 
теперь понятно что значит ema(now)=10 
это значит что сейчас из бутылок воде херачит с сумарным потоком 10*12.5 кубометров в сек.
и конечно если мы знаем тлько одну точку то конечно нельзя сказать  мы только что поставили 
120 бутылок и открыли. или мы их расставляли какоето время по какому то закону.
у нас есть сумаарный поток и все. замечу что если ставить по 1 банке каждые 5с то поток
достигнет 12.5 только через 60 выставленных банок. а чтобы поток стал равен 
не пойму. если эксенненетат начинется в единичке тоесть банка высирает из себя
1 кубометр то интеграл эксененты это 12.5 или сумма экспоенненты. 
мы делим сумму на 12.5  и получаем форулу ema



ema(n)=ema(n-1)*0.92+(r(t)/12.5)

если все r(t) равны 1 то ema=1

получается ema домноженный на 12.5 нам показывает истинную суумму какой обьем
воды вытекает сейчас. то еть есл ema=1 то на саоммо делео вода вытекает как 12.5 кубов 
в секунду.

получается вот у нас ema=0 мы берем банук одну и ставим. мы знаем что у нас вода будет 
хлестать как 1 кубометр. соглано фомурле получеаем

ema(n)=0+1/12.5=0.08

умгжаем на 12.5 и получаем 1 тоесть дейтстиельно щас вода хлещет как 12.5.

если ema=10  то это значит что щас вода хлещет как 120.5 
проверяем. берем r=10.

ema=0+10\12.5=0.8

умножаем 0.8 на 12.5  получаем 10. 
тоесть мы получаем 10 бытылок. ниче не понимаю.. сука

итак еще раз у меня есть сумма    w0*x(0)+...w3*x(now-10s)+w2*x(now-5s)+w1*x(now)
или в другой форме
    w0*x(0)+...w3*x(n-2)+w2*x(n-1)+w1*x(n)      [1]

если все x=1 то эта суума равна 12.5 при n>=60
и она же говорит о том что если мы взяли n банк и кажоая из них льет по 1 кубометру
то выставив 60 банок в течение 5минут  я получу поток 12.5 кубометров в сек. 
значит в форумулу подставляются банки. их число. а сумма выдает тот поток который щас 
суммарно хуярит с банок.

оказалось что этот поток можно считаь через итерационную формулу

для этого делим наш [1] на 12.5 

summa (n) 
----------  = summa2(n),  оказывается что summa 2  можно посчитать вот так
  12.5



  summa2(n)=summa2(n-1)*0.92 + (1\12.5)*x(n)

подставляем


summa(n)        summa (n-1) *0.92           x(n)
----------  = ---------------------    + ------------
12.5             12.5                      12.5


получаем 

        summa(n)=0.92*summa(n-1) + x(n)    [2]

и действиельо если все x(n)=1 то summa(n)=12.5

положим что summa(n-1)=0 и x(n)=1 
тогда summa(n)=0+1 = 1 
и дествительно так. таков будет поток.
а если x(n)=10 то 
summa(n)=10


итак [2] покзывает тот поток воды который щас льется. а как он образован.
толи этощас банок понаставлили свежых. то ли это по истории банки расставили и они все дотекают
это хер знает. 

теперь надо понять какое отноение банки имеют к процессам.
положим банка это процесс. если бы банки были дровами то это было бы понятно.
они бы вначале горели яркно и сильно. а когда прошло много время то 
от них толку было бы ноль. но прикол в том что процессы они не горят. когда
мы добавили банку то она делает какюу то полезную работу потом. дрова тоже ее делают.
а процессы то нихера неделают. их делают на цпу а сами то они нихера неделают.
тоесть процесс это дожлна быть какая то банка , что если ее добавили в систему
она должна чтото делать потом и делать долго. предположим что процесс он же банка начинает
жрать цпу. его мощности. модель при этом такая - вначале процесс жрет очень много мощности
но чем дальше тем почти ничего. его аппетит падает по экспоненте. 
получается 1 процесс начинает добавленный вначале жрет 1 единицу какото там процессорной
мощнности. а чем дальше тем все меньше и меньше. получается если добавлять по  1 процессу 
каждые 5с. то в конце концов суммано на цпу будет отжираться каждую секуду 12.5 единиц
какойто там мощности. тоест процессы как черви  празитные. мы его закидываем в систему и он 
начинает жадно сосать кровь. но чем дальге по времени тем он делает это все меньше и меньше.
поэтому 60 червей наброощенных в систему за последние 5 минут 
будут сейчас в итоге жрать 12.5 единиц мощности на цпу. процессы похожи на гавно.
свежеее силно воняет. а старое засохшее уже слабо. так вот ema показывает уровень вони.
тоесть 60 каках дают 12.5 единиц вони. где 1 единица это степень максимальной вони 
от одной какахи.  ema хорошо подходит для подсчета какойто мощности которую выдают некие 
банки. наприме дрова, или батарейка, или человек  у которого работосопосбность падает 
от времени. а процессы очень плохо подходят в эту модель. они нихуя не производят. если 
под проиводвтвом понимать то что они жрут время на цпу. только если так?
возможно вот такая модель подойдет ?  - мы считаем что новый процесс сожрет 5с следущего 
времени на цпу. а еще в следущий сэмпл уже он сожрет на цпу 92% от времени. и так 
до тех пор пока он не усохнет и несожрет на цпу 0.01 от 5с. тоесть типа 
вот родился новый процесс. ema считает что он будет жрать на цпу следущие 5с целиком.
проходит 5с. ема счтает что этот процесс далье отожрет только 92% от 5с сэмпла следущего. 
и та далее. и через минуту этот процесс будет жрать на цпу (5\3)с 
прикол в том что процессы так неработают вообще. а наша типа задача чтобы поток отжираменого
времени на цпу в системе рос как можно больше. если новый процесс выдает единицу ( по аналогии
с 1 кубометром из бутылки) то логично предположить что эта единица это 5с времени которыые
этот процесс сожрет в следущие 5с на цпу. получается если мы набросали 60 штук процессов
за 5 последних минут. и ema нам показывает 12.5 то это означает что эти процессы в следущие 5с
выжрут 12.5*5=60секунд времени на цпу за следущие 5с. тоесть типа нам надо 12 ядер
чтобы их всех обслужить. если бы это были дрова то было бы все понятно. что система обогрета
в размере 12.5 единиц тепла от размера тепла одной дровины на максимуме. а что придумать 
про процессы вобще непонятно. процессы ничего недают вообще и из того что падало бы поэкспоенте
тем более.

ema идеально подходит для квантовых величин типа банок. которые при вскрытии излучают
непрервную велчину которая падает по времени. и ema находит суумму этой непрервыной
величины по всем квантовым. 

получается корнденсатор это такое помещение куда приносит банки с водой. их протыкают оставляют.
а потом просто берут сумму по времени по всем этим банкам. получается на макс заряде 
судя по этой модели из конденсатора вытекает макс количество воды но и заливают в него 
тоже макс кол-во воды. а выглядит это как равноевесное состояние типа ничо не происходит.
судя по разностной формуле. EMa покаывзает сколько воды осталось в помещении 
при уссловии что из стархы банок уже мало вытекает а из новых хуярит по полной.

тоесть когдая  говоирил выше что мы берем банку и из нее и ее открываем и ставим
то мы плюсуем с одной стороны можно сказать скорость воды котоая херачит из банки
с другой стороны ее полным аналоом является уровень жидкости по высоте в  этой банке.
вначале у банки макс скорость истечение и макс уровень воды. а через 100 шагов
у нее и струя слабая и уровень воды в жопе.  поэтому это одно и тоже.
так вот ENA показывает либо сумманую струю ее расходв куобометрах которая истекает.
либо сумарную высоту столба которая еще остался в банках.
в начале зарядки конленса у него мало банок но они имеют макс высоту. в итоге
потенициала у него мало зато полных банок много. а когда он макс заряжен у него
банок дохуя но из них куча банок пустые. тоесть конесатор имеет макс уровень потенциала
когда в тоже время из него истекает макс колво воды в секунду. вот такой прикол. 
типа чтобы больше иметь надо больше отдавать.
получается r(t) в модели констатора это такие автомноые банки. каждя из которых содержит 1Вольт
потеницала. и они текут. просто со стороны батарейки встречный напор более мощный.
а точнее ровно такой же. поэтому сумано выглляди как бутоо конденс в стат равнвесии. а оно 
сугубо динамичекое.  как елси бы мы сверху лили со шланга воду. а снизу она беешено вылиывается.
а посредение чтото остатеся. 

Тоесть EMA это получается вот что - у нас есть некие дискретные сущности (банки)
котоыре добавляют в какоето помещение (коонденсатор) и каждая такая сущность она как только 
ее добавили она начинает терять тот контент который в нее заключен (вода вытекающая из банки),
и теряет она этот свой контент строго по закону падения по экспоненете от времени.
типа это как куски навоза которые мы добавляем на пол в комнате. и каждый из них одинаковый и сильно
воняет вначале но с тчением времени вонь уменьшается. и мы их добавляем штука за щтукой.
и EMA это сумма которая суммирует эти какахи а точнее вонь от них суммарную.  это и есть EMA.

например. у нас есть абрикосина. у нее масса 1грам. мы ее кладем на солнце. и она наинает терять 
свою массу по экспоненте. EMA покзывает сумму ее живого веса. далее мы начинаем накладывать 
эти абрикосины друг рядом с другом. и EMA покажет нам сумму ихнего веса в момент t.
вот и и все что такое EMA.  r(t) в ее формуле это сколько новых абрикосин мы добавли в 
момент tn а точнее это масса добавленных абрикосин на момент добавления.  
сущности (масса светимость вонь горячесть) 
пример.  у нас есть крыша. на неее мы будем добавлять абрискосины. каждая инзанчально весит 1грам.
и на солнце теряет свой вес по экспоеннте. так что за минуту в  3 раза.
t=0  r=1 ema=1*r(0)=1*1=1
мы добавили одну абрикосину. r=1 это вес этой одной абрикосины на момент ее добавки
t=5 r=0 тоесть мы не доавли новых абрикос. наш r(0) теперь ставнится r(-5) при этом у него
новый коэфицент тогда 
    ema=0*r(0)+0.92*r(-5s)=0*0+0.92*1=0.92
t=10 r=5 мы доавили 5 новых абрикос при этом r=5 это не абрикосы в штуках это их суммарный вес.
потому что именно вес у них падает по экспоненете а не штуки. при этом унас члены опять сдвинаются
тоесть r(-5) ставноистя как r(-10) и  у него меняется коэфиикнент. r(0) ставоится r(-5) 
итого ema=1*r(0)+0.92*r(-5s)+0.92*0.92*r(-10s)=1*5+0.92*0+0.92*0.92*1=5.8
итак ema(10)=5.85 покаывзает сколько грамм веса суммарно занимают наши абрикосы.
и так далее. если бы у нас все r(t)=Const=1 то вес неподнимется выше 12.5
ema (+inf)=1*1+0.92*1+.....0.92^p*1= 12.5
тоест макс вес абрикос может быть только 12.5 при таком паттерне r(t)

вот что такое EMA!!! это сумма чего то гниющего. каких то дискретныех хреновин у которых 
есть какой то ценный контент который падает по экспоненеты для каждой такое хреновины по 
времени. а EMA покаывазе сумму этого контента. тоесть чтобы использовать ema надо иметь 
несколко условий. 1) надо иметь дикретные хрени. 2) надо чтобы эти хрени имели какойто 
ценный контент который они излучают или содержат 3) надо чтобы для каждоый такой хрени
ее контент падал уменьшаялся исчезал по закону экспоненты от времени. Только при соблдении
всех эти улосвий мы можем юзать EMA. для чего? чтобы иметь сумму этого ценного контента 
в любой момент времени. также из свойств ema вытекает то что все сущности (абрикосы и банки
с водой и дрова ) они должны быть абсолютно одинаковые. соверешнно одинаковые. неотличимые.
как копейки в деньгах. если они разные то это уже неподходит для EMA. и они все должны
сгнивать по одному закону. все что их отливает это то что какието из них повлябся на сцене
раньше а какието позже. вот и все.




теперь 
Осталось придумать как сюда процессы присобачить. чтобы это имело какойто физ смысл.
дело в том что r(t) это таски котоыре появляются со стороны процесссов на компе для обработки
цпу. да у нас есть выплоненние усвсловия 1. тоест у нас есть дискретные хрени. 
но не пойму какой у процесса есть ценный контент котоыр выражается в цифрах и которых 
протухает по времеи по экспоненте ? согласно свойству ema все проццессы которые появлются в r(t)
они все с точки зрения ema аболдтно неотличимо одинаковые. как мелкие козьи какашки. нет 
никаких ни длинных процессов ни короткиех. этого ничего нет. они все как атомы -аболютно
одинаковые. и у них чтото должно при появлении быть на макимуе а потом начать гнить по времени
по экспоненете. разное у них только время выброса на точку. и все. 
возьмем теже самые дрова. как только дрова появяются в печке они начинаюь давать тепло.
и мак колво в самом наале когда у них макс площадь поверхности. каждая дровина одинаковая. 
и умирает одинаково. а тепло суммарное  в печке это сумма страых дров и новых кажды из которых 
дает свой вклад в общее тепло. это как тепло от кучи одинаковых батареек. какието почти рарзяди
лись а какието еще на максимуме. ema посчитет от них тепло. если дров не подкидывать общее
тепло быстро просрется(если только у нас в печке небудет накопителя тепла типа радиатора) 
поэтому надо дрова постоянно побрасывать. а вот что делать с процессами? кстати на счет графка
теспературы. земля постоянно остывает. а солнце бросает на землю свои тепловые какашки.
только непонятно что за носители теплау солнца? а так получается что земля макс излучает
тепло в товремя как на ней макс тепло. тоесть сильно нагретая земля и теряет тепло очень легко 
без постоянной тепловой подпитки. получается что как бутто солнце кидает на землю некие тепловые
банки. кажоая из котоых упав на землю начинет тут же экспонениально остывать. их отличавает 
только время приземления на землю. и их смешанная сумма дает суммарное тепло. видимо так.
с людит тоже все понятро. ребенок имеет макс здоровья тлько неясно как это в цифрах
а далее он его теряет по экспоеннте. поэтому тут можно юзать EMA измеряя общее числр 
здовроья. 

возвращаюсь к процессам. 
опть же что не сходится между процссами и EMA.   в случае банок воды, абрикос, потенциала
там сущность после появление в r(t) добавляется в пул существ сидящих в банке и никуд не 
исчезает а сидит в банке вечно, потихоньку помирая и выдывая свой контент. а на компе
каждый процесс котоырй мелькнул в момент t0 его уже нигде нету на компе если он
не пявился в другой ммоент времени. нет никакого остаточно следа. его просто нет. 
сущности у EMA это как какашки. если они упали то они тут уже навсегда. а процессы r(t)
на компе таким свойствао не обладают. они никуда не добавляются. они никуда не 
присыхают. даже атомыне частицы добавленные  в коробку и те распадаются. 
а процессы вот он есть и его уже нет, он никуда не дбавляется. он сразу появился и 
сразу исчез.
хрент в том что дрова после того как появились в r(t) тоесть в печке они там лежат 
продлжают греть нетолько в момент появления в r(t) но и далее. а процессы после
появление вr(t) в момент t0 далее их в компе уже нигде нет. и они на компе нихера несуществуют
и не делают ничего. тоесть взяли одно полено в момент t=5 бросили в печь. оно там лежит в печи 
и после t=5. и продлжает выделятьтепло. если же процесс появилися  в r(t0=5) то далее 
в t=10 и позже его уже на компе нет абсолютно. он никакого влкдаа в комп неделает. 
поэтмоу я не понимаю. если частицы вбросили в коробку то оони там лежат и частично 
разагаются. процессы на компе не лежат и не разлагаются. они погибают тутже.

Еще два важных свойства EMA - 1) она показывает чтото что происходит прямо сейчас.
не в прошлом не когда а прямо сейчас, например сколько тепла выделяется прямо сейчас дровами,
сколко воды вытекает из банок прямо сейчас. ЕЩЕ раз - это EMA показывает число чего то 
что происходит прямо сайчас. например сколько волтов на конденсаторе прямо сейчас.  с  одной
стоороны сущности в нее добавляются все время. но ему вобем то неебет этот аспект. 
то число которое она показвает это чтото что происхдоит имено сейчас - вес всеъ абрикосов
на крыше прямо сейчас. величина светимости люминофора прямо сейчас. вонь говня сейчас.
2) все сущности которые попадают в EMA они живут вечно. дрова в печке живут вечно. дрова
неисчезают не умирают. они просто дают нетак много. 

так вот процессы на компе они живут очень мало. они умирают сразу. я не вижу ничего того условия
что процессы живут вечно. если в кондесатор накидали порции потенциала то эти накидки 
живут вечно и потихоньку теряют часть своего потенциала. абрикосы все лежат на крыше
навсегда. 

с процессами все нетак. 

EMA показывает сумму сколько воды в кондесаторе сейчас. это минус из той воды что вылилась из 
банок которые будут выливать ее вечно плюс вода в новых банках.
EMA это сумма тока во всех разряженных почти батареках плюс ток новых батаркееек.

ema(n) = 0.92*ema(n) +r = ema(n-1)+ (r-ema(n-1))

delta ema = r-ema(n-1) = r-0.08*ema(n-1)
              --------
                 12.5
                 
                 
                r=0.08*ema(n-1)
                 
ema(n) по сравнению  с ema(n-1) всегда меньнше на 8%
тоесть прсходит сдвиг и ema уменошается на 8% и дболавляется к голове 1*xn
поэтому если xn > 8% от ema(n-1) то новые ema повысится  иначе понизится.

у нас есть ema=10
на слеудшуем шаге он становиися 9.2 если xn <0.8 то ема понизится. 

потмуо что 9.2+0.7 это меньше чем 10

так как wi это кофидциенты экспоненты то если r=const то рано или поздно
сумма ema продвинется вправо и выйдет на сумму экспоненты вида wi*Const 
а это рано или поздно даст 12.5*Const
так как exp вначале очент круто пдает то summa очень резво реагирует 
на изменение первого члена. тоест очередного xn

сумма новой эксопненты будет болше или меньше старой эксопнеты зависит от того 
что новый xn будет ли он больше 8% от старойэксоенты или меньше. 

если рисовать график не суммы а summa/12.5 заменив ее на summa2 то
 тогда
 
 ema(n)=0.92(ema(n-1))+ 0.08*r
 тогда 
 ema(n)-ema(n-1)=0.08*(r-ema(n-1))
 
 тоесть будет ли растит ema или падать зависит оттого что r новый 
 больше или меньше старого ema. 
 
 ema это сумма ряда xn с экспненицальным коэфицантами. деленный на 12.5
 
 вернусь к основной форусмуле summa (wi*xi)
 или ema(n)=0.92ema(n-1)+r(n)
 если xi=1 то summa=12.5 тоесть если класть по 1 абрикосе каждые 5с 
 то макс масса будет 12.5 грамм
 
 если xт новый на  < 8% от текущего ema то график нового ema упадет на величтину r-0.08*ema(n-1)
 тоесть 

ema это сумма всех абрикос которые лежат на крыше. за один раз мы добавляли разное 
число абрикос. у них у всех уменьшилась масса. ema это ткущеая сумма всех абрикос.
приулосвии что у них масса ументшается по экспоненете по времени. это физ смысла ема
xn это некая хрень обладающая свойством потенциальности то есть у если она целиковая
то у нее сгорит 8% или ее можно порезать на куски. и каждый кусок сгниет на свои 8% 
и в итоге это будет все теже 8%. 
тоесть что одна бакашка 5 литролвая опустеет на 8% что их разделить на 5 мелких балкоашек
они опустеют на свои индвиальные 8% а витоге цифра будет такая же самая.

любой xn=N у уменьшатеся по законму N, N*0.92, 0.92*0.92*N , ..... 0.92*0.92*0.92*...0.92*N
остаьыне xk на него никак не влияют. и вот я очем раздели N на k+m тогда 
N*0.92=0.92*(k+m)=0.92*k+0.92*m тоест от каждого из них вощьмеся свой 8%. а виттоге
одно и тоже . получается каждлая абрикоса за каждый шаг теряет 8% от своей массы. 
важно лишь то как давно она пояивлась. велиична xn отражает либо число абрикос котоые все одинаковые
которые наочердном шаге добавили. либо либо инвдиуальный размер абрикосины хотя тут это 
без разницы. но я скорее предпочту то что оно показывает чило абрикосин новых положенных 
на стол за шаг. тоесть xn=3 и xn=1 покаыает лишь число абрикосин. а так
они все одинаковые. 

тогда r(t)=5 или r(t)=10 это 5 или 10 процессов. котоыре при этом все одинаковые.
xn=1 это некая характеристика абрикосы. снормрованная на 1=100% 
и далее эта характиеристка начинает угасть. по законму x(n)=x(n-1)*0.92 
чем меньше от абрсиковы остается тем меньше у нее в абсолютном значении снимается. тлоько 
процент констарта
тоест если xn=1 это светимость 100% светлячка  то xn=3 это светимость 100% от трех светлячков.
а EMA это общая светимость от всех светлячкой. причем мы имеем если класть xn=1 постоянно
то макс светимость будет 12.5 или 1200% от светимости одног свтелячка. вот что показывает 
EMA. она работае с аддитивной величиной. исходным является ее 100% покаатель. и она покзывает 
сколко в итоге % от этого номаргальгошо показателя у нас есть щас. аддивттивного.
услвного говоря у нас есть кирпич. номинальная масса xn=1
и они со временем тончают. тогда ema покажет какая масса в % есть щас у всех кирпичей лежащих 
в команте. если это 2 то это 200% от номинального. тоесть ema показывает не абсолютное 
значение а опять же процентное. или обезразмерренное.

если у нас вода хлещет из банки с изначльным безразмерным скорстью 1.
то xn=1 и ema=12.5 показывает что вода хлещет в 12.5 раз быстррее чем безразмерное значение 1.
абсолютное значение xn нас не интерсует даже. потому что величичины менются в процентах 
а не в абоюдюютных значених.

итак у нас есть процесс. когда он новый то у него есть некая велиичина равная 1.
тогда xn=1 если xn=3 это значит что у нас 3 процесса добавилось. и их величина сложилась.
потом этот процесс продолджает жить. и его эта велиичина умирает со скорстью 1/3 в минуту.
все выглядит так как бутто в момент t=0 процесс отработал на компе за 5с все 5с. 
тоесть 100% в следущие 5с он продолжает жить и отработает на компе уже 92% от 5с. 
через минуту он отрабтает на очередном 5с цикле 5\3с тоесть он продолжает жить и его нагрузка
на цпу упала в 3 раза. тоесть процесс похож на муравья он появился и начал крутить колесо.
и чем дольше он живет тем слабее крути колесо. можно еще представить xn=1 так что родившисяся
процесс оказывает некоторео усилие на цпу, нагрузку. через миунту он продолжает ее оказывать
но уже в размере 1\3. тоест в отдичие отреального мира процессы в мире EMA на компе роджаются 
и продолжают крутить цпу потом очень долгое время. такиим образом ema это суммарная нагрузка 
которую все процессы начиная с момента аптайма продолжают оказывать на цпу. если 1 процесс
только рожденный оказывает на цпу нагрузку ( в условных единицах ) 1 то значит EMA=10 означает
что в данный момент вся сумма старых и новых процессов оказывает на цпу суммарную нагрузку как
10 новых процессов. прикол в том что EMA изнаально такова что она работает по природе с величинами
которые офиегенно потенциальны тоесть они могу дробиться и суммироватся бесконечно. например 
такие как масса или светимость. поэтому там нет проблем что у нас положили два абрикоса  а в итоге
от них откаждого осталось по 0.0001г а вот с процессами такая херня не получается. 
только если с длительностью работы процесса. если за 1 принять время 5с в течение которых 
новый процесс грузит цпу. то тогда EMA=10 означает что в данный момент нагрзука на систему
такая что процессы хотят потребит на цпу 10*5с = 50с. тоесть нужен типа 10 ядерный процессор
я пока не вижу номральной аналогии для процессов и EMA во первых потому что процессы 
не живут на компе после того как они пропали из r(t) во вторых их нагрузка совершенно разная
в завимисмости от типа процесса. а ema требует чтобы прцесс жил с момента рожддения до бесконечности
и чтобы у него была падающая от времеи по эксопенте некая харктетиркисика.
у процесса нет ни массы ни светимости, он не живет после того прошел его r(t0)


в итоге я выяснил то что классическая сумма плоха тем что 
там у нас получается на одной банке r=1  можно разогнать систему до 12.5
и получается вот что чтобы ее поддерживать на такой скрости светимости высоте
то нам достоточно в дальнейшем поддерживает r на уровне 12.5*0.08=1
тоесть систему у нас светится на 12 единиц а мы за терн подкладываем всего одну
баночку. при этом понятно что на одной банке мы будем разгонять систему 5 минут.
а теперь вот что берем и однократно выставляем r=40 тогда колесо разгоняется 
до 40+(-12.5*0.08) получаем новый la=51.5
а чтобы его удерживать нужно всего лишт 51.5*0.08=4.12
выставляем далее r="4,12" и спокойно крутим колесо на уровне 51.5  это жесть.

они поделили сумму на 12.5 и теперь тогда она очнь жескто реагирует если у нас 
достигунто равенвесное состояние то если я хотя бы 5с не выставлю r=LA то сразу
получу обвал. вобщем  вэтом куске я хотел сказать что можно выставить кучу банок
типа r=100. а потом подерживать больгшую скорость колеса выставляяя маленткий r=5
например. это в целом логично если все процессы одинаковые. но это не так. 
как раз таки если есть выброс то эти тощие процессы а он считает что это мы выставили
100 жирных банок. и конечно у нас LA поднимется мощно. ведь унас сразу из 100 банок
льется поток по максимуму.


но щас о другом даже.
если LA=N то для его поддежвания надо всего 8%. так вот можно к LA=N идти 
двумя путями. путь первый выставить R=10 и идти 5 минут к LA=10*12.5=125
и потратить и время и банок 12*5*10=600 банок.
а можно по другому можно выставит R=125 и и сразу выйти на a=125
при этом мы и время сэконосили и банок потратили всего 125 штук вместо 600 !!!!
и это при том что вобще то потеницал величиан аддитивная. как то по дргому должно
работа. и главное что корооткий всслплеск порождает наоброт - кучу тощих процессов.
у которых воды то как раз и нет.  также если предположить что LA показывает
число банок котторые нужно проставиь на длинне 5 минут. то это неверно. потому что 
на ддине 5 минут надо будет выставить 10*5*12=600 банок.а мы можем поднятся
до того же LA за 125 банок. 

поу=лучается что каждый ema \la отлиьчается только тем наскольк дырявый конеденсатор. - 
сколько нужно банок чтобы поддерживать поток например ema=0.92 говоит что нам нужно 8%банок
при данном LA. LA это у нас светимость.

значит что я обнаружил.чем отличается ema0.92 ema0.5 ema0.99
r=1

ema=0.5 набирает свой максимум    1.9 за 0.5 минут, ток компенасации  50%LA= 0.99


ema0.920 набирает свой максимум  12.4 за  5 минут,  ток компесации   8.0%LA = 0.99

ema0.983 набирает свой максимум  58.4 за 25 минут , ток компенасации 1.7%LA = 0.99

ema0.994 набирает свой максимум 165.1 за 65 минут , ток компенасации 0.6%LA = 0.99




выводы: если кондесатор  дырявый то его свойства:
            максимум меньше
            набирает максимум быстрее 
            теряет воду быстрее
            абсолютное значение тока возврата у все одинаковое
            
получается r задает абсолютную величину тока компенсации.    


рассморю подробно

ema0.920 набирает свой максимум  12.4 за  5 минут,  ток компесации   8.0%LA = 0.99

r у нас определяет то какой равновесный LA мы получим если будем этим r долбить.
дело в том что r задает максимльное число воды которая вылиывается  к следущему 5секунд
мы можем закомпенсировать. например r=2 значит мы можем каждые 5с компенсиоровать(доливать) 2
литра воды. тоесть у нас вылиывается 2литра воды а мы коменсируем 2литра воды. 
так вот двум литрам вылиывающейся воды за 5с соотвествует LA=2/0.08=25 
будет так: LA=25 выливающаяся вода будет 8%25=2 , 2 вылиывается а из r=2 она компенсируется.
таким образом меняя r мы меняем максимум LA
до какого LA может разогнать текущий r легко запомнить вот так - r=1 разговняет до 12.4
значит r=N разгоняет до LA=12.4*r

для r=1 теор макс LA=12.5 значит за 5 мин он доходит до 99.3% от теор макс
далее я поставил r=100 и он за след 5 мин дошел до 99.3% от теор макс 1250
тоесть растет он от одного r до другого хорошо и ровно и за 5минут всегда, ему хватает.
тоесть при росте ошибка недобора составит 0.7%


посмотрим как он падает я взял r=100 и потом падаю до r=1
за 5 минут он упал до 17.918 а нужно до 12.5 
еще за 4 минут(итого 9 минут) он упал до a=12.5781  это ошибка получается 0.7%
еще за 1 минут(итого 10 минут)он упал до a=12.5306  это ошибка получается 0.3%

итого получается он растет до равновесного положения   5 минут
                  а падает до равноевесного положения 10 минут
можно конечно и до 9 минут падать чтобы получить туже ошибку что и при росте на 5 минут.
но по моему проше запомнить что рост идет 5 минут а падение 10 минут.
да уж..
                  
чтобы разогняться до 12.4 равномерными банками нужно:
при r=1 : t=5min summa банок 60 штук
при r=13: t=5с   summa банок 13 штук

таким макаром если это проециорвать на процессы то получается что процесс одинарный
процесс который работал 5 минут дал такую же светимость как 13 коротких процессов 
которые работали всего 5с и на систему никакого реально воздейвия не оказали. пиздец.
в этом пиздец примеения концепции ema  к процессам потмоу что ema строго подразумевает 
что все банки абрикосы частицы и потенциалы они аболслютно одинаовые. а у нас тут совершенно не так.
у нас тут есть маленькие банки которые жрут не более долей секунд на цпу за пятис секундную 
итерацию и есть огромадные банки которые каждая жрет целыех 5секунд в одно лицо. и их вместе
лепить это пиздец.

получается если разгоняться маленкьими банками до какойо светимости ты мы пока до не
дойдем мы еще кучу энерии в космос высветим потеряем тоесть. а если разгонсятся болльшим
числом банок то мы очень мало потеряем из их энергии пока идем до нужно светимости. 
поэтому большим числом банок разгонсяться до светимости экономенее. меньше батарекк потратишь.
ибо банка это как батарейка. то есть мы получается для разгона до светимости 12.4 по одной банке
потратили 60 банок, тоесть мы закинули 60 единиц энергии , потеряли 47 банок при этом
чтобы осталось 12.4. тоесть вливая воду по немножку у нас утекло очень много воды наружу
пока мы набрали 12.4 в конденсаторе. (то что в конденсаторе это полезная энергия. то что улетело
это в трубу). вбросив же сразу 13 банок из них ничего не успело утечь и мы сразу получили нужную
светимость. 

теперь на счет того что разгонятся быстрее чем тормозиться обратно. 
расмотрю вначале на примере таком что мы вначале разогнались с r="0" до r="1"
за 5минут. а потом замедлились с r="1" до r="0" за 5 минут.
проанализируею на оснвое  графика экспоненты
это выгляди так - у нас ест график экснененты. когда мы растем то мы закрашиваем площадь
по графиком двигаясь с каждым шагом 5с направо по этому гарфику на 5с напраов за каджый
шаг времени. через 5 минут площадь по гарфиком набиарет 12.4 в сумме
потом когда мы начинаем тормозить то это означает что наши новые xn всегда равны нулю
на гррафике это значит что мы опять же начинаем с x=0 и с каждым шагом опять же ползем
направо отрезая сектор за сектором под графиком только вотличие от того когда мы разгонялись
теперь мы не закрашиваем этот сектора наоборот мы его вырезаем. таким оббразом площадь графика
котоаря закрашена правее она станвоится все меньше в сумме. а! это не совсем так. мы нетлоько 
вырезаем сектор слева мы еще и добавляем один сектор с хвоста графика. а так как в хвосте 
еще есть площадь то у нас с одной стороны площадь суммарно офиеннено падает и немного
еще прибавляется. поэтому торможение по времени получается дольше чем разгон.
при торможении с r=1 на r=0 мы за 5 минут опустия до la=0.076 вместо ожидаемого la=0
тоесть разница составит 7.6% тоесть за 5 минут график даже не смотря на то что мы 
ему обрубили голову наберет +0.076 к площади. я имею ввиду к той площади которая лежала 
между отрубенной головой и телом которое осталось. 
покажу на формулах

когда у нас la=12.4 это t=[0;5min] это n=[0;60] выглядит вот так

p=0.92
la =  1*1+   [p(-1)]*1+     [p(-2)]*1+    ...     +[p(-60)]*1

теперь начинаем замедляться. у нас новый la будет получен из старого путем того что 
у нас перый член r(0) будет равен 0 теперь мы его отрезали и на конце суммы появиится +1 член 
[p(-61)]*1  потому что у нас время прибавилось было 300с а стало 305с. значит прибавился и полслдений
член при n=61

la =  1*0+  (((  [p(-1)]*1+     [p(-2)]*1+    ...     +[p(-60)]*1  ))))   + ( [p(-61)]*1 )

в я втройные скобки взял те члены в новом la которые перкочевали из старого.
на следшей итерации у нас отрежется еще одир головной член и прибавиться +1 член в конце


la =  1*0+ [p(-1)]*0+ (((     [p(-2)]*1+    ...     +[p(-60)]*1  ))))   + ( [p(-61)]*1  + [p(-62)]*1 )
 
 
таким макаром новый la будет отличаться от исходного котоырй был  равен 12.4 тем что 
у него все больше исчезают головные члены котоыре конечно же самый тяжелые и поэтому график
будет по площади конечно падать но за счет приаращения членов в конце хотя они и маленькие 
площади но за дополниельные 5 минут которые график будет падать там нарастится некоторый хвост
который немного добавить графику все такие площади. как уже сказал сумма этого хвоста
будет равна 0.076 это составляет 7.6% от нуля.  конено по сранению с исходной площадью 12.4 это ни о чем но учитывая 
что мы стермились к нулю то это конечно имеет значение. поэтому падение за тоже время 
невызывает то что мы опустимся обратно откуда начали. LA будет боольше. 
Насколько я понимаю если у нас LA=N а это на графике высота экоспсопненты  в точке x=0 
то по если мы начинаем падат с этого графика то площадь его хвоста который мы насобираем
через 5 минут составит N*7.6%. проверяю:

r=  1 : падаю 5 минут : LA(+5min)=0.076   это 7.6% от 1
r=  2 : падаю 5 минут : LA(+5min)=0.154   это 7.6% от 1
r=100 : падаю 5 минут : LA(+5min)=7.746   это 7.7% от 100

тоесть да все верно.

чтобы упасть до 99.3% от положенного LA нужно в итоге времени составило 9 минут
с ошибкой 0.04%, возникает соблазн падать 8 минут но там ошибка 0.23%
итак если мы выросли за 5 минут то  падать обратно до нуля составит 9 минут. 
я считаю что проще запомнить что падать 10 мину. формула 5/10 гораздо проще.


так. а если падать не до нуля. а до некоторого r напрмиер у нас было r=100
а мы падаем до r=99 --> после падения 10 минут ошибка составила 0.05%

Итого я более менее постулирую:
    Рост      до равновесного LA идет  5мин , ошибка меньше процента  (при r=Const)
    Падение   до равновесного LA идет 10 мин, ошибка меньше процента  (при r=Const) 
    Причем неважно как падает до того значения или до другого
    
    

Осталось бы понять как это оььбяснить с энергетической точки зрения. 
воможно тут дело в том что рост потенциала зависит от нас мы его сами делаем 
вбрасвывая руками новые банки с потенциалом по некоторму законму r(t)
а падает потенциал уже по своему закону. неудвительно что они не совпдадают.
хотя когда мы наращиываем потенциал он же тоже падает в это время по своему закону,
получается за кажодую итерацию когдмы мы даволяем новую банку потенциала а он при этом 
часть потенциала теряет то он падает по эксопненты а мы добалвляя банки одинакового размера
по факту наращиываем потенциал нелинейно по времени.  я имею ввиду ту часть часть банки 
очередной которая остается после того как из нее возьмут ту част которая иде на покрытие провала.
покажу на примере

t=0  r=0 ema=0
t=5  r=1 ema=1
t=10 r=1 при этом ema протекла на 0.08 мы отнимаем из r 1-0.08 и на повыешение потенциала остатеся
            0.92 
ит так далее 
на конечном этапе у нас
t=5min r=1 ema=12.41 она протекла  на 0.993 и почти вся банка r идет на устранение протечки

вобшем трудно понять. ясно точно одно - если  у нас в конденсе щас есть накоелнвй потенциал LA
то он через 5с протечет на долю от своего значения тоесть это будет 8% от его LA

значит я заменил исходный закон роста r=1=Const на изменчичивый
и получил что уже на периоде 10 мин идет дорастание 
а закон такой r(n)=1-ema(n-1)*0.0005

тоесть формула такая

ema(n-1)=ema*0,92+( 1-ema(n-1)*0.0005 )
r(n)=1-ema(n-1)*0.0005



$ a=$(bc <<< "scale=10; 12.5*0");t=0
$ r0="1" ; p=$(   bc -l<<<"scale=11;    e(-5/(1*60))"   ); \
min=10; for i in $(seq 0 1 $(($min*12))); \
do  \
r=$( bc <<< "scale=11; $r0-$a*0.0005" )   ; \
a=$(  bc <<< "scale=4; ($p*$a + $r)/1"  ); \
q=$(bc<<<"scale=2;( 100*(1-$p) )/1"  );   \
echo -e "r=$r a=$a" "a*$q%="$( bc<<<"scale=3; $a*$q/100"  ); \
let t=$t+1;  (( "$t" % "13" )) ||  echo -e "-->  +1min\np=$p"; done; echo ""; \
p=$(   bc -l<<<"scale=3;    e(-5/(1*60))"   );


поэтому в приницпе ответ такой - что растет бытсрее чем падает потмоу что мы растем руками
по своему закону а падает оно по своему.

ну хорошо - если r=const то растем за 5
если r=const то падаем за 10
работаем с батарейками . накаидываем их.
что это нам дает по факту теперь ?

LA получается это суммарная светимость батареек набросанных по пути от сейчас и до 
начала времен. Если у нас есть LA(now) суммарная светимость на данный момент 
проходит 5с и у нас потенциал светимость падает на 8% и мы кидаем батарейку или батарейки
в итоге наша суммарная светимость будет составлять сумму из того что осталось от светимости
плюс что осталось от нашей новой батарейки после того как она устранила протечку. 
батарйки реально это высота столбика воды и неважно это оодин большой столбик или 100
маленьких. это получается чисто дискретаная величина энергии. хочешь разбивай на 100 кусков
хочешь храни одним сумма одна и таже. тоестт можно даже не думать о струйках воды которые бьют
с разной скорстью.можно рассматривать банки с водой. высота в каждой банке падает пропорциаонально
ее индвииуаьной высоте.
если у нас было la=100. тоесть 100см воды. через 5с останется 92см. далее батарейка это 1см воды.
скажем у нас 12 новых баратреек добавили  значит в итоге 92+12=104см новый уровень.
что интересно. я говорю можно предтавить что у нас стала одна большая колба на 104см
а можно представить что у нас колба 92см так и стоит протекшая а мы просто рядом поставили
баночку на 12см.
теперь рассмотрим процесс так как бутто в одном случае мы добавили 12см а вдругом нет.

случай когда мы не добавили 12см воды
t=0   la=100    r=0
t=5c  la=92см   r=0
t=10c la=84.5см 


случай когда мы добавили 12см
t=0   la=100                  r=0
t=5c  la=92см+12см            r=12
t=10c la=84.5см+11.04=95,54


мы видим что  в момент t=10 уже после того как мы подлили 12см и выждали еще 5с
у нас уровень воды выше 95,54 чем когда мы не подлили 84.5см ,
я это к чему говорю - если мы подлили воды и ее стало 104см то конечно это нам повысило 
уровень на сразу закрадывается мысль о том что это увеличить обьем воды который теперь 
выльется на следущем этапе и что возможно если бы не подлили то на следущем этапе
так как воды выльется в процентах меньше то у нас возможно уровень будет выше.
тоесть 

la=92см (воду не подливали) на следущем этапе выльется 8% от 92
la=104см(воду подлили) на следущем этапе вылтьется 8% от 104

8% от 92  < 8% от 104

и ты такой думаешь раз 8% от 92 меньше то возможно 92 - 8% от 92 в итоге даст 
более выской уровень чем 104 - 8% от 104  но этого не будет. так как можно заметить что 
104см это можно аналог что у нас как была банка с 92см так и осталась и она протечет
на следущем эатпе с такой же силой. зато у нас добавилсь доолнельная банка 12см
и она по любому доавбить что то в итоге. тоесть

104см = (92 + 12) значит 8% от (92+12) это 8% от 92  плюс 8% от 12

а теперь сравниваем 

случай банки без добавления. было 92 станет 92-8% от 92
случай банки с добавлением было 104 стало (92- 8%от92) +  (8% от 12)

второй случай даст итоговый уровень всегда выше чем первый. тоесть мораль басни такова - 
если мы подлили воду в конденсатор то он по любому будет иметь далее более выскойи уровень
чем если мы в него не подлили.

еще по другому я это проанаизирую

  у нас есть la(now)  я к нему подливаю B
  на следущем этапе у меня в банке останется 0.92 (la(now)+B)
  а если бы  я ничего не подливал у меня бы осталось на следущем эатпе 0.92(la(now))
  при какой B у меня будет верно следушее неравенсотсво
    
        0.92(la(now))  > 0.92 (la(now)+B)
преобразую
        0.92(la(now))  > 0.92 (la(now)) + 0.92(B)
перенесу
        0  > 0.92

откуда видно что ни при каких обстоятельствах доливание воды не ускоряет падение уровня
воды в конденсаторе. безусловно в кубомтетрах из него начнет выливаться больше. но это неважно.
если мы сравним график la(t)  на отрезке [t0;+inf] где t0 это когда мы  в одном случае 
подллиили воду а в друогом нет то мы увидим что в каждый момент времени граифик там 
где мы подлили воду он выше. значит вода будет вылиываться дольше из той колбы где уорвень воды
выше.
Действииельно если у нас есть две колбы у одной уровень A а у другой B
причем A < B
что можно скзаать какая колба будет вылиываться дольше? конечно та у которой уровень воды выще!
всегда!! потому что опять же колбу B можно разбить на две колбы

B = С +D, где C имеет такой же уровень как A

тогдда у нас колба B это по факту вытекающая такая же колба  A и еще доп колба D

и значит в любой момент времени если в настоящей колбе A уровень воды h1
то в колбе B уровень воды h1+d1 где d1 уровен в колбе D  хорошо - в колбе B 
уровень воды будет всегда выше чем в колбе A . Но тут приходит вопрос - а может они выльются в 
итоге за одно и тоже время на самом деле?

давай посчитаем.

пусть колба A=10 колба B=10+0.5

и пусть она вытекает как у нас есть что за 1минуту в 3 раза. тогда
я думаю что да, они все вытекую за одно время , на бесконечности, но 
до бесконечности уровень будет всегда выше у колбы B

колба A
    $ bc -l <<< "scale=11;  10/e(21)    "

колба B
    .00000000758
    $ bc -l <<< "scale=11;  10.5/e(21)    "
    .00000000796

получается очень интересная вещь  - доливание воды в кондесатор  оно строго говоря
не изменяет время за которое из него вытечет вся воды. она суммарно вытечет из него за одно 
время если он полный или слабо полный. ЭТО НЕ ПОМЕНЯЕТСЯ. поменяет то что у него если мы дольем воды
то в каждый момент времени ее уровень будет выше чем по сравнению если бы мы ее не долили.
ВСЕГДА. это гениально. еще раз добавление воды в коненсатор не влияет на его время полного вытекания
воды из него. оно останется точно таким же равным бесконечности. но это повлияет на уровень 
воды у него. она будет всегда гораздо выше дальше по времени по сравнению если бы мы не долили.
возникает крутое противинтуитивное штука типа как это так у нас вылиывается вода из бочки.
в одной бочке вода выше а в  другой ниже. конечно же мол та в которой ниже обесточится быстрее. 
оказвыавется нет. окказывается одинаково. жесть.
плюс уровень воды в бочке где мы долили всегда будет выше по времеени чем там где мы
не долили.

возьмем пример.

        A=1     B=30
t=1m    1/3     10
t=2m    1/9     3
t=3m    1/27    1
t=4m    1/81    1/3
t=5m    1/273   1/9

а дальше у нас происходит прикол - если у нас A и B содержать дискретные частицы - тогда 
да в ведре A они кончатся быстрее, но если мы работаем с веществеными числами то так как 
они бексонечно могу делиться то оба этих ведра будут вытекать одинаково бесконечно долго. жесть.
но еще что интересно - что высокозаполненное ведро даже  в случае дискретных частиц вытечет
последним. тоесть мелкое ведро вытечет первым. из картинки видно что ведро станет 
неполнено как ведро A на 4-ой минуте. поэтому для дискретных частиц следует что ведро B будет 
вытекать дольше. 

а вот еще так рассмотрим

   дано A и B. причем A<B
далее они протекают по закону 
    A(n)=A(n-1)*alpha
    B(n)=B(n-1)*alpha

apha некоторе число меньше нуля alpha=[0;1] тгда 


    A=A0*e(-alpha*t), B=B0*e(-alpha*t), A0<B0 посмотрим может ли так быть что 
    при каком то t0 у на будет A>B
    
    A0*e(-alpha*t0) > B0*e(-alpha*t0)
при условии что A0<B0

сокрашаем обе части на e(-alpha*t0) 
получаем 

        A0 > B0
    
получаем проиворечие. значит все верно. - более запоненное ведро будет всегда иметь
более высокий уровень.  полностью они вытекут за одинаковое бесконечное время. 
но если в обоих лежат дискретные частицы то более высокое ведро вытечет дольше.

Итак ВЫВОД:
    если есть два ведра с водой. одно ниже другое выше по заполненности
    то при вытекании более заполненное будет иметь уровень вседа выше
    
    если  в них вещественные числа то выткать они будут одинаково бесконечно время
    
    есди дискретные числа то первым опустошится более мелкое ведро
    
если рассматривать с точки зрения процентов. то все просто - оба числа уменьшаюся на один 
и тот же процент долю. в каждй момент времени от каждого остается одна и та же доля.
если доля не может быть меньше какого то значения то мелкий пирог исчезнет первым. ппздец.


итак любое подливание воды в конденсатор приводит к тому что его дальнейший уровень 
будет всегда выше по сравненнию если бы мы в него неподлили . еще раз почему- потому что 
подлитый кондесатор можно преставит как сумму исходного неплитого и доп кружки.
далее мы отпускаем их по времени  у нас очевиедно что в подлитом конденаторе уровень 
будет состоять из такого же неподллитого кондесатора плюс добавок из кружки. пиздец.
тоесть вот эта fвот интуативая идея - не подливай воду в коденсатор! из него начнет
вытекать еще быстрее и уровень начнет падать еще быстрее ! это полная хуйня оказывается!


итак наконце  я возврад-щаюсь к основной теме. 
есть LA=N что он значит. если у нас есть батарейка с зарядом 1. или  у нас есть кружка 
с размером 1литр. и мы их както накидываем в конденсатор то LA=N покзывает что щас у нас 
в конденсаторе N литров воды.  как их туда закидывали по времени и сколько этого 
мы узнать не можем. у нас есть какойто дискретный обьект - абрикоса, батарейка, кружка с потен
циалом. у которых есть какая то величина равная 1 для этого обьекта. мы их вскрываем 
и бросаем по времени. а LA показывает сумму сколько этого есть сейчас. хоорроий пример есть 
банка с водой. если ее открыть то в ней уровень 1. а через минуту он в ней 1\3. 
так вот lA(now) покзыает сколько литиов воды есть сейчас сумммарно измеренное в 
этих номинальных едиинциах. это покзвыает lA(N)
от чего эта цфира зависит ? она зависит от двух моментов:
    1) как быстро из отдельной банки вытекает вода.
    2) от графика как мы по времени добавляли новые банки
    
если у нас из банки вода вытекает в e раз за время tau и если мы 
хотим получать данные каждые h секунд то тогда вода будет вытекать из отдельной банки
по закону

H(t)=H0 * e(-t/tau), H0 начальный уровень воды

далее если мы берем и начинаем вскрываь и добавлять эти банки 
в нашу систему по закону H1=R(t) который показывает сколько банок мы добавяли НОВЫХ 
в тот или иной момент 
то тогда суммарный обьем сколько литров воды у нас щас осталось в сумме по всем 
банкам покажет LA по формуле

LA(n)=LA(n-1)* (  tau/(tau+h)    )  + R(n)

h это интервал сэмплирования в секунлах - как часто мы будем снимать данные или получать 
n это номер интервала. h и n связаны с временем t 
    t=h*n, n=0,1,2,3...
    
в нашем конретном случае h=5с tau~=60с значит

                LA(n)=LA(n-1)*0.92 + R(n)


уменьшится или увлечится уровень воды на очередном этапе зависит от 

          delta = [ LA(n)-LA(n-1) ]=   R(n) - 0.08*ema(n-1)


тоесть если в предыдущий момент(-5s) у нас в системе оставалось N литров воды вбанках.
то к этому моменту из них вылилось 8% тоесть 8%N , если наше свежее подливание воды R меньше
этой величины то обьем воды N в итоге уменьшится. а если больше то увеличится.

                    8%N (<>=??) R

пример в системе есть 10л воды
проходит 5с. в системе стало 10-8%10=9.2 литра воды.
значит щас надо доавить 0.8 литра воды чтобы уровень остался тот же.
отсюда мы видим что чтобы в системе в течение 5с поддерживать постоянный уровень надо 
доливать 8% от N тоесть отосительно немного. значит на интервале 1 минута нам надо будет
суммарно подлить 0.8*LA(now)*12=0.96*LA(now) тоесть чтобы поддерживать текущий 
уроввень воды за минуту нам нужно потратить примерно такой же уровень воды. 
если lA =10 значит за минуту надо будет подлить 9,6 литра ~= 10 вот о чем говорит lA
например. обьем 10 литров надо будет подлить суммарно при условии что мы будем подливать
равными частями.  посмотрим а что будет если мы подольем эти 9.6 литра сразу за один 
раз. а потом уже подливать не будем до конца минуты


t=0   R=?     LA=10
t=5s  R=9.6   LA=0.92*10+9.6 = 18.8
t=10s R=0     LA=0.92*18.8=17.2
t=15s R=0     LA=15.9
t=20s R=0     LA=14.6
t=25s R=0     LA=13.5
t=30s R=0     LA=12.4
t=35s R=0     LA=11.4
t=40s R=0     LA=10.5
t=45s R=0     LA=9.6
t=50s R=0     LA=8.9
t=55s R=0     LA=8.2
t=60s R=0     LA=7.5

понятно как бы все выглядело если бы я подливал эти 9.6 в тевение минуты
малыми кусками

t=0   R=?     LA=10
t=5s  R=0.8   LA=10
t=10s R=0.8   LA=10
t=15s R=0.8   LA=10
t=20s R=0.8   LA=10
t=25s R=0.8   LA=10
t=30s R=0.8   LA=10
t=35s R=0.8   LA=10
t=40s R=0.8   LA=10
t=45s R=0.8   LA=10
t=50s R=0.8   LA=10
t=55s R=0.8   LA=10
t=60s R=0.8   LA=10

спрашивается что за хрень мы залили в обоих случая по 10 литров суммарно ( потратили 10 
батареек которые стоят деньги) но видно что в первом случае уровень упал ниже.

во первых я скажу вот что . если бы мы вобще ничего не подлили то роувень бы щас упал 
вобще сильно а именно в 3 раза тоесть если на всем протяжении минуты у нас R=0 то 
t=60s LA=10/e~=3 поэтому в этом плане наш  первый график где мы вылили 10 литров сразу 
как я ранее постулировал привел к тому что  LA=7.5 точно выше чем LA=3
даже если бы мы подлили всего один раз на пятой секунде любой обем воды то уровень на 60-й
секунде будет выше чем просто голове ведро которое вылывается 60с.

проаналузируем графики для этого я их совмещу


t=0   R=?     LA=10                  W_v     R=?     LA=10
t=5s  R=9.6   LA=0.92*10+9.6 = 18.8   0.8    R=0.8   LA=10
t=10s R=0     LA=0.92*18.8=17.2           R=0.8   LA=10
t=15s R=0     LA=15.9                     R=0.8   LA=10
t=20s R=0     LA=14.6                     R=0.8   LA=10
t=25s R=0     LA=13.5                     R=0.8   LA=10
t=30s R=0     LA=12.4                     R=0.8   LA=10
t=35s R=0     LA=11.4                     R=0.8   LA=10
t=40s R=0     LA=10.5                     R=0.8   LA=10
t=45s R=0     LA=9.6                      R=0.8   LA=10
t=50s R=0     LA=8.9                      R=0.8   LA=10
t=55s R=0     LA=8.2                      R=0.8   LA=10
t=60s R=0     LA=7.5                      R=0.8   LA=10


 я переформулирую ситуацию. 
 возьмем правый левый график 
 есть ведро размером 10 в t=0s на следущем этапе я добавил ведро размером 9.6
 рассмотрим как протекали эти ведра. у меня LA это сумманйый уровень.
 LA1 это исходное ведро а LA2 это подлиттое 9.6 ведро
 
t=0   R=?     LA=10                    LA1=10    V1=?
t=5s  R=9.6   LA=0.92*10+9.6 = 18.8    LA1=9.2   V1=.80
t=10s R=0     LA=0.92*18.8=17.2        LA1=8.4   V1=.74
t=15s R=0     LA=15.9                  LA1=7.7   V1=.68
t=20s R=0     LA=14.6                  LA1=7.0   V1=.63 
t=25s R=0     LA=13.5                  LA1=6.4   V1=.58
t=30s R=0     LA=12.4                  LA1=5.8   V1=.53
t=35s R=0     LA=11.4                  LA1=5.3   V1=.49 
t=40s R=0     LA=10.5                  LA1=4.8   V1=.45 
t=45s R=0     LA=9.6                   LA1=4.4   V1=.41 
t=50s R=0     LA=8.9                   LA1=4.0   V1=.38 
t=55s R=0     LA=8.2                   LA1=3.6   V1=.35 
t=60s R=0     LA=7.5                   LA1=3.3   V1=.32 

так а это ведро LA=9.6 
t=10 8.83 .77 
t=15 8.12 .71 
t=20 7.47 .65 
t=25 6.87 .60 
t=30 6.32 .55 
t=40 5.81 .51 
t=45 5.34 .47 
t=50 4.91 .43 
t=55 4.51 .40 
t=60 4.14 .37 
 
значит V1 это сколько воды вылилось из исходного 10 литрового ведра. эта вода
никак на перерасход вылитой воды не влияет.
влияет только вода дополнительно вылившаяся за счет вылиывания из ведра 9.6
но V1 это вода которую как раз таки нужно было скоменсировать и ее сумма 6.93
тоесть сумма V1=6.93.  и действиельно как я уже сказал если бы мы вообще 
ничего не подливали то через 1 миунут уровень воды бы остался 10/3=3л
итак было 10 вылилось 7 осталос бы 3. кстати это показывает еще одну потрясающую вещь.
если мы хотели чтобы через 60с у нас был уровень воды 10 то надо было дождатьс конца
итерации и на последнем шаге влить 7 литров воды
Тоесть если сравнивать самый экномный сопособ чтобы через 60с уровень воды был прежний это
ни наливать скопом вначале. ни лиить равномерно все время. а это влить 7литров в конце.
это даже экономенее чем 10 литров равномерно по 1 литру. но тут возникает интересный 
вопрос - если вода которая ест в коденсаторе это свет который освещает команту то нам 
конечно выгоднее чтобы свет светился как можно ярче и равномернее и экономенее поэтому 
понятно что если мы сидели в темноте все эти 60с то мы сэкономили батареи. зато сидели в
темноте. а потом сэкономленные бататери закиули уже в конце. тоесть 7 батарей против
10 мы сэконосили за счет того что сидели в темноте.

сравним сколько энергии мы получили бы полезной с затратами кстати
если греть равномерно то за минуту мы получили измененеие потенциала 
то за минуту мы получили 13*10=130 условных единиц света за цену 10 батарей
когда мы сидели в темноте то получилли бы 76 условных елиница света за 7 батарей
а когда я закинул 9.6 сразу то за минуту мы получили 159 единиц света за 10  батарей


вобщем вот здесь я пока останвливаюсь. надо проанализировать хороенько эту ситуация -
- а именно - расход топлива когда залили вначале 10 , когда задили 7 вконце. кодга
заливали равномерно. какую получили светимость. связь между расходом баатрей, светимостью.
получается прикол. залили 10 внаале - получили болше светимости в начале и мало светимости
в конце. залили 10 равномерно получили равеномрную светимость. залили в конце сэкономили
батареи но была херовая светимость в тевение 60с. какая связь между равномерносьтью светимости
, между суммой светимости и из расходванным батарейкаами ? 

мы когда ставим банку то нам в ней интересует уровень воды в этой банке. уровень воды это и
есть светимость. нас не интерует струя. нас интересует тупо наличие воды. так вот 
из кажой банки через минуту выльется 2\3 банки. и останется 1\3 которая и будет опяь же светимостью
затолкать воду оббратно мы не можем. но мы можем поставить рядом еще одну банку с водой. 
за минуту из новой банки тожн выльется 2\3 а 1\3 остается которая и обеспечивает светосилу.

поэтому если мы добавил +1 банку то надо понимать что в течение минуты от нее будет толку 
с максимума до 1\3.  2\3 вытечет. компенсируующая банка она не заталкивает воду туда 
откуда она вылезла. она тупо стоит рядом. и уроввень воды в ней уже прибавляеся к обещй массе
без заталкивания. 
если у нас la=10 то надо понимать что у нас 2\3 через минуту потеряется , но это суммарно 
если мы не будем каждый цикл 5с добавлять ( не доливать а прям дбавлять ) воду. 
поэтому. если наша цель вооствноить уровень воды к концу минуты то тут действие такое - за 1 миуту
у нас потеряется 2\3 воды значит 7. значит в конце минут просто поставим +7 банок и все.
если мы хотим как то заранее это предоавтиратить однокарным вливанием то нам надо добавить столко 
банок вначале вот что. у нас есть банка на 10. из них 7 выльеться. значит нам надо чтобы
добавленная банка была такого размера чтобы кога из нее 2\3тожевыльется к конце минуты то 
оставлшаяся 1\3 составляляа 2\3 от 10 то есть 7 это 1\3 значит новая банка размером 21.
итак как будет
у нас есть банка на 10. и я добавляю банку на 21.
к концу минуты от 10-ки осатется 3. а от 21 остается 7 эта 7 компенсирует ту 7 которая вытекал 
от 10-ки.
в итоге у нас будет 10 в конце.  а вытечет соовтавтенно 7 и 14. получается у нас за минуту при 
таком раскладе на каждую единицу свечения добавленную у нас вытекает 2 единицы наружу. тоесть 
если мы хотим светится на +1 единицу то надо обеспечить вытекание 2 единиц. итого банка нужна
на 3 единицы. но это только для случая кгда мы однократно добавили вначале минуты.
если мы расстривем цикл из 5с. минимальый. тот тут такая математкаи. если мы доблавяем 10 единиц
светимости то через 5с из нее вытечет 1 единица светимости. тоесть если мы хотим чтобы следущие 
5с у нас добавилось 9 единиц светимости то надо еще накинуть 1 единицу сверху на счет вытекания. 
пример

ставим банку 10.
через 5с у нас осталось 9. 
чтобы поддерживать светимость 9 и дальше надо добавлять 1 банку постоянно. я думаю что 
прежде чем искать закон статисткии на длинну минуты вначале надо внимательно рассмотреть 
закон на интервале 5с и два раза по 5с. потом на интервале 3 раза по 5с. а минута это уже потом
это потмоу что 12 интервалов это сложно.


если у нас есть 10
она вытекает на 1. значит минимум надо поддржку 1.

la=10 r=0
la=9, r=1 la=10
la=9, r=1, la=10

хотим добавит светимость до 20
la=9, r=11 la=20
теперь у нас две банки на 10 и на 11. одна вытекат на 1 а вторая  на 1.1 значит 2.2
la=17.8 r=2.2 la=20

была светимость 10 доливка 1
стала светимость 20, однократное вливание 11, доливка 2.2. 
однократное вливание состоит из прошлого регулярного вливания и дельты +10. 
итого. если у нас есть LA=N а мы хотим скажем в 2 раза поднять. то то надо взять размер 
доливки от N тоесть 8%N +N для уже самого сдвига на дельту. пример

LA=10, хотим 20. доливка к 10 это 1. 10 на сдвиг дельты. итого 11 на доливку.
через 5с что будет . в плане того уровня который у нас будет . 10-ка превоараттится в 9-ку
у нас будет 9-ка. и мы еще поставим 1 банку чтобы компенсировать потерю. и того 
у нас уже стоит 10-ка. и еще одну банку потавим 10-ку. и того у нас 20-ка.

еще пример. 
есть 20
хотим 40. 
через 5с будет 18. ставим еще 2 банки на компенсаицию. уже 20. и еще 20 итого 22.
было 20 плюс R=2+20=22 стало 40
надо посмтреть как мы можем получить светимость 2.для начала.
как можно получить 2.
либо 

было 0 поставил R=2
либо был 1 . протечка 0.1   в итоге поставил R=0.1+1 стало 2

LA=1 R=?
LA=1-0.1 R=0.1+1 LA=2
получается тогда вот что если у нас  LA=N то значит когда то -100%  у нас было 
R=2 либо R=2.1 без этого в LA=N не перелезть никак. 
связь междку LA и r(t)

la=0      R=1
la=1-0.1  R=0.1  LA=1
la=1-0.1  R=0.1  LA=1
la=1-0.1  R=0.1  LA=1

LA=1 три раза по 5с. значит на это надо было потратить 3 раза по R=0.1 это затраты
энергии.и однократно надо было R=1 итого суммарно на 3*5с у нас потрачено 1+3*0.1

LA=1 в течение 3*5c LA=( 1 1 1)
оно стоило таких затрат батареек R= ( 1 0.1 0.1 0.1 )
вот такая связь между R и LA

посмотрим для LA от 0 до 2

R=0  LA=0
LA=1 R=1                (L:R:t|  1 : 1   :    -   )       | зажгли LA=+1 цена R=1
LA=1-0.1 R=0.1 LA=1     (L:R:t|  1 : 1.1 :   5c*2 )       | lA=1 работае 1*5с потратил R=+0.1
LA=1-0.1 R=0.1 LA=1     (L:R:t|  1 : 1.2 :   5c*3 )       | LA=1 отработал 2*5с потратил R=+0.1
LA=1-0.1 R=0.1 LA=1     (L:R:t|  1 : 1.3 :   5c*4 )       | LA=1 отработал 2*5с потратил R=+0.1
LA=1-0.1 R=2.1 LA=1+1   (L:R:t|  2 : 1.4+2 : 5c*5 + 5c*1 )| зажег LA=+1 цена R=2 ...

если мы знаем что у нас светимость 1 длилась 25с это значит что когда то где 
там у нас было потрачено на ее инциацию и поддержвание : 
        на инициацию R=1 и на поддержание R=0.1*(число 5с интервалов-1) = 0.4
        значит на поддержание LA=1 в течение 25с у нас ушло R=1.4 батареек.
        и так на каждую единицу светимости в течение стольких то 5c длительности.
        

LA=(1-0.1)+(1-0.1) R=0.1+0.1  LA=1+1   (L:R:t|  2 : 1.5+2.1 : 5c*6 + 5c*2 ) |

имеем LA(now)=2 = ( 1 1 1 1 2 2 )
к этому моменту потратили R=1.5+2.1=3.7 батареек
как это можно получить из lA(t) ==> 1+5*0.1+2+1*0.1=1+0.5+2+0.1=3.6


можно еще так посчиать: считаем сколько у нас единиц по времени в 5с интервале.
зажечь единицу стоит 1. ее поддержание стоит 0.1 интервалы берем минус 1.
тогда 

LA ( 1 1 1 1 ) ==> R=1+3*0.1=1.3

по поводу двойки все тоже самое только в 2 раза дороже. еще надо учесть что 
в той точке гда зажигается новый LA там еще надо заплаить за протечку с предыдущей точки.
тоесть если у нас lA ( 1 2 ) то в точке где зажигаем 2 надо будет дполнилно оидать протечку 
от единицы прошлой тоесть 0.1
ненужно платить при зажигании только когда зажигаем после LA=0 тоесть в ситуации 
LA= ( 0 N ) 

итоого 
LA (2 2 ) ===> зажечь стоит 2. поскольку перед 2 стоит 1 
то нужно дополниельно заплаить R=0.1 и поддержание 0.2  ===> R= 2+0.1+0.2*1 = 2.3

тогда

LA ( (1 1 1 1) (2 2) ) ==> R=(1+3*0.1) + (2+0.2*1) = 1.3+2.3=3.6

таким макаром глядя на LA график становистя понятно сколько на него было потрачено 
батареек на этот график свечения. правда этот метод он дает ответ про суммарное количство
батареек потраченное на суммарное количество обеспеченного освещения суммарного.
тоесть если переставить точки на графике LA местами LA ( (1) (2 2) (1 1 1) )
тоесть стоолбики на графике можно переставлять местами резултат расхода R батареек будет 
тот же самый. хотя не совсем. - в местах прыжка LA там же будет тогда разный  обьем 
протечек тоесть  ( 1 3 ) или ( 3 1 ) будет разный R(t) при прыжке тоесть когда у нас
(1 3 ) в точке 3 протечка будет 0.1 от 1 предыдущей а когда (3 1 ) то в точке 1 
будет протечка 0.3 хотя вот - что это все наважно. потому что в случае 
( 1 2 3) за протечку двйоки заплтит 3-ка в ( 3 2 1 ) за протечку 2-ки заплатит единица.
в общем только в самой левой точке (t=0) и самой правой точке  могут оказаться не те 
наколадные расходы. в общем мелочь. можно столбики перставлять. хотя..... не уверен.
если у нас вот так идет ( 1 1 3 3 ) то в этом случае зажигать тройку R=3 нужно один раз.
а потом тольео поддерживать а вот тут (1 3 1 3 ) здесь зажигать тройку нужно два раза. 
это совершенно другие энергетичекие расходы. щас проверю на практике.

R=0  LA=0
LA=6 R=6                (L:R:t|  6 : 6   :    -   )       | 
LA=6-0.6 R=0.6 LA=6     (L:R:t|  6 : 6.6 :   5c*1 )       | 

LA=( 6 6 ) затраты R=6.6

обьем затраченных банок это понятная штука. просто сумма R.
хочется ввести какойто показатель обьема светимости. тоесть как обьем LA по времени
числово оценить.

LA=( 1 1 1 1) затраты R=1+3*0.1=1.3
LA=( 2 2 2 2) затраты R=2+3*0.2=2.6
LA=( 6 6 6 6) затраты R=6+3*0.6=7.8


я бы тогда так опрееделил обьем светимости. берем монотонный промежуток тоесть там
где LA не меняется по значение ( 1 1 1 1) или (2 2 2 2 ).
и суммарный обьем светмости  будет склывадться из суммы этих обьемов светимостей.
так вот на монотонном участке обьем светимсти определяем вот так 

LA=( 1 1 1 1) затраты R=1+3*0.1=1.3  LA*t(обьем светимости) = 1*4
LA=( 2 2 2 2) затраты R=2+3*0.2=2.6  LA*t(обьем светимости) = 2*4
LA=( 6 6 6 6) затраты R=6+3*0.6=7.8  LA*t(обьем светимости) = 6*4


обьем светимости надо писать именно указывая и аплитуду и длинну по времени
потому что у нас есть точка поджига. потому что 6*4=24 это может быть 1*24 или 6*4
а затраты энергии будут разные

LA=( 1 .(24 штуки). 1)  LA*t(обьем светимости) = 1*4  затраты R=1+13*0.1=2.3
LA=( 6 6 6 6)           LA*t(обьем светимости) = 6*4  затраты R=6+3*0.6=7.8

тоесть соверщенно разные затраты поэтому "LA*t =" только в виде "амплитуда*время"

таким макаром LA(now)=N нам почти ничего не говорит , мы знаем что что в этой точке 
был какойто R который мы незнаем но он оплатил протечку с прошлого LA и также обеспечил дельту.
тоесть   
    [ ema(n)-R ] = 8%*ema(n-1)
из того что в формуле мы знаем только текущий ema(n) и все. 
можно также сказать что когда то этот N был подожжен через R=N плюс была оплачена 
протечка в тот момент с предыдущего LA. походу это все что можно скзать из одной точки.
R=N мог состояться как в этой точке так и в любой другой до этого. мы только знаем 
что это было. но не знаем когда. вот и все что мы знаем. если это было сейчас то тогда 
про друние моменты времени мы нихрена незнаем. а если это было когда до этого. то 
все равно мы незнаем ничего что было между тем моментом и этим моментом.
напрмиер LA=10 мы только знаем что когда то был R=(10+оплата протечки) это все 
что нам дает эта точка. 

если есть график LA(t) по нему можно посчитать и какой был R(t) конкретно . и сколько
банок было потрачено на поддержвание такой светимости.

еще раз по поводу цифры  в LA=N
если r(t) показывает частицы которые насыпаются в контенер то LA(t)=N показывает сколько 
таких частиц щас есть в контенере. 
если r(t) показывает напряжение (банка внутри которой есть некий уровень напряжения) то LA=N 
покзывает сколкьо этого напряжения (как высота воды в бутылке) сейчас суммарно есть в
конеднесаторе. 
тоесть еще раз r(t) это график емкостей (банок) одинкового размера внутри которыех есть
некоторый уровень или количество чегото там. с обезразмераенным размером 1.  котоыйр начинает
опускаться как только мы их засыпаем в контейнер. так вот la(t) имеет туже размерность что 
и r(t) если r(t) показывает сколько таких банок засыпается новых в систему (типа как банки с водой
внутри кооторых уровень 100% заполенности обозначатеся как 1 поэтому число банок r*(t) совпдает
с оберазмеренным уровенм жидкости или напряжения или массы или чисел частиц с числом засыпаемых
банок. и так как уровнив этих банках можно суммировать то LA=N показывает сколько таких обезразме
ренных уровней высот ест сейчас в контейенере. размер 1 соотвествует этому уровню в одной новой банке.
поэтому если r(t) это некая характертика одного процесса то lA=N показывает каков суммарный 
уровень этих характеристик щас есть в контейнере принимая за 1 тот обьем котоый имеет новенький
процесс. когда я говорю процесм я имею ввиду ту хрень которая фигурирует в r(t) тоесть это 
запись в ps aux | grep R|D . фишка в том что эта сущность эта банка она должна существовать 
в системе после того как она пояивилась в r(t0) и далее. а у процессов ничего такого нет. 
также у нее доожно быть чтото что угасает со временем. а упроцесса этого ничего нет. 
поэтому я пока в прострации. тоесть с коденсатором например понятно. мы на батарейку насыпаем
банки с напряжением и они переезжают в конденсатор. и там деградируют от времени. 
если мы насыпаем частицы новые то тоже понятно.  если мы воду наливаем из шланга 
в бочку то тоже понятно. вода заливаетя в бочку и там потом существует. а процессы 
они никуда не заливаются. они нигде не остаются.  у них ничего не деградирует.  если 
сонце светит на землю тоже можно представит что тепло на землю придетает в банках.
но в случае процссов нет принимающей стороны. нет того самого виртуального конденсатора. 
тоесть есть генератор процессов это да. но нет принимающей хрени которая бы их акумуировала.
мне кажется что ответ вот в чем  - походу они используют la для процессов исходя
из вот чего - для качественной оценки как сильно система забомблена генерацией процессов. 
тоесть используется то свойство что если R(T) сильно херачит где r(t) это напряжение или 
это банки  с водой то на кондесаторе будет держаться высокий уровен la(t) 
исходя из этого получается не нужно искать никакого физ ссмысла аналогии как процессы
могут где то там попадать или застревать. логика как я понял применения этой формулы для 
процессов именно вот какая - мы знаем что если бомбить напряженеим конденсатор то 
напряжение на нем будет высокое если его постоянно заряжать тоесть заебывать. типа как в машине
мы нажимаем на педаль газа. по этой же аналогии предлагается научится оценивать степень
генерации r(t) процессов и степень заебанности от них компа.
тоесть надо прям представит что процессы они не исчезают с компа они в нем застревают 
как капли дождя на стекло упавшие  и как то там заебывают комп. но сохнут со временем. 
и исходя из этого научиться понимать насколько сильно то ли был заебан комп 
то ли щас заебан. учитывая то что LA(now) ничего не покаывает прото что было он показывает 
только про то что есть. 
насколко я теперь понимаю видимо подразумевается вот какая схема - если на реальной системе
банки они усыхают но существуют реально прям щас. то с процессами видимо предполагается
представлять что степень их усыхания покзывает время насклько давно процесс появлялся в
системе. тогда LA(now) покзывает заебанность компа процессами за последние 14 минут.
насколько я понимаю временной параметр процессов (как далеко вглубь по времени нужно 
их вытаскивать в ema(now)) надо полагать из того параметра что ema падает в e раз 
на интервале 1 минута. 
тоесть то что в обычных системах является усыханием хараектеристики обьекта который щас живой
с процессами этот праметр усыхания нам как бы намекает про историю процесоов. тоесть 
еще раз скажу чтотипа lA(now) показывает нам суммарное влияние от процессов котоыре не только 
щас живы а всех процессов которые были живы последние 14 минут.
это полная хуйня. буду думать дальге как присобачить процессы к ema
навсидку это полная хуйня. потому что число процессов не может усыхать а их время как давно 
они работали на компе тоже херня. типа la=1 означает что на компе за последние 14 минут суммарно
когда то работал 1 процесс тоест r=1 было. и что? или la=5 означает что на компе 
когда то запосление 14 минут был r=5 и что ?
что реально важно у функции ema если она равна N la=N то это точно занчит что коогда
то на компе r(t) был равен N да еще не просто N а плюс еще компенсация протечки.
тоесть если комп все время имеет r(t) =[0;3] то максимльный lA может быть только 3 но никак 
не 5 хоть усрись.  а ведь реально la=N всего навсего озанчает что КОГГДА ТО на компе 
r(t0) был равен N+(ток утечки) и все. блльше нихрена это не значит.тепер мне кажется 
я начинаю понимаьб. из каких то мелких r(t0)<N r(t1)<N ты никак не насобираешь
через сумму la(now)=N это очень важное свойство.для понимания.
тоеть когда то r(t) прошел через r(t5)=N это факт. и то это в случае если 5с до этого был la=0
а так еще и больше было. еще важный момент  если LA=12.5 то это совершенно не значит
что у нас когда то r(t) был равен 12.5, это могло быть запросто то что долгое время
работал r(t)=1. тоесть я сглючил если r(t) =8 это соверешно не гарнатирует что когда
то обязателно было r(t)=8 это могло не быть. а просто какоето время отработал r(t)=1 !
так что все еще сложнее. даже la=2 совершенно не знаичит что был r(t)=2 
запросто могло быть что просто r(t)=1 поработал какое то время.



1. подержание LA=10 требует 1 единицу новой батареи бенизина в сек времени.
поддержание LA=1 требует всего 0.1 еиницу батарей подрабрасывать в сек в топку.
поэтому высокая скорость требует высоких затрат новых баатарей в сек (большой расход
бензина в сек). зато проезжаешь больше расстояния в сек времени. тоесть
высокий уровень воды(h,q) он дает более высокий уровень оставшейся воды в банке. а оставщийся
уровень воды дает скорость машины или скорость истеения воды из бочки. а чем она больше (именно
оставшйися уровень) тем машина проезжает больше или водяной столб за большего давления
проминает больше бумаги как пресс. тоесть чем выще столб воды тем больше полезной работы он может
сделать за сек времени. но чем больше столб воды тем больше он потеряет своей высоты в след 
момент. поэтому чтобы этот столб держать нужно больше подкидывать новых батарей в сек времени.
поэтому 
    высокий текущий h ---> больше полезной работы в сек времени
    высокий текущий h ---> больше потери в абс единицах за сек времени. значит ---->
       ----> больше новых батарей нужно закидывать в ед времени. 

увеличение числа батарей в секунду закивыаемых в печь увеличивает текущее значение живой
энергии в топке. а значит скорость полезной работы возрастает. сильнее жмем на газ(закидваем батареи
бензина в больших количествах ) то быстрее едет машина в сек времени 

2. энергия вытекает по такому закону что каждая палочка энергии взаимодействует с каждой другой 
палочкой. и от каждого у них происходит взаимное истточивание. поэтому размер потери энергии 
пропорционален обьему энергии в печке. поэтому - они говорят нас много ! мы щас сделаем много 
работы. типа нас 100! мы сделаем щас 100 единиц полезной работы. однако через 5с они говорят 
нас 100 значит каждая источится на 100:1 тоесть на 0.1 от своей величины. и через 5с от 100
остается 90. они сдеали болше полезной работы но и сдохло больше. больше Е дает боьше полной 
работы за 5с. но и погибают они после этого боольше. это выглядит так - они первую часть 5с
все мирно работают. так как их много то они в суме делают много рабты. а конце они дерутся. 
и так как их много то погибает много. 

3. концепция EMA подразумевает что у нас есть юниты которые чтот ускоряют делают полезную работу.
процессы же это нечто наоборот .оно тормозит сситему. поэтоум оно совсем не подходит 
для оценки через ema. единственнре что призодит  это то что есть машина которая мчится 100 км\ч
а процессы это даже не тормоз который нажал отпустил. это камни которые попадают в тормоза.
и тогда машина тормозит. но не просто тормозит она пережевывает камни. поэтому каждый камень
полсе того как попал он еще там живет и продолжает тормозить. тогда высокий ema показывает 
насколько много камней у нас еще есть в тормозах и нассколко сильно машины тормозит. типа такое - 
r(t) это число камней щас в тормозах.  каждый камень коода попал начинает измельчаться.
отставшееся число камней вызывает эффект замедление пропорциланльый обьему камней. 

4. стало понятно почему мыло внаачале быстро заканчивается а в конце медленно.
я за delta_t которые не меняется (еще аналог это сколько раз я провожу по мылу ладонью
например максимум 5 раз). количество мыла которое смыливается с мыла пропорционально
площади мыла. чем больше площадь мыла тем больше частиц снимется с мыла. если мы 5 раз проведем
по мылу малой площади снимется 100 частиц а если мы проведем ладонью 6 раз по мылу 
бьлой площади то снимется 100 000 частиц. поэтому чем меньше мыла тем с него и менше снимеаеся
за одно время или за равное количество прокрутов. поээтому и энергия тратится медленнее
чем ее меньше.

чтобы поддеоживать выскокую мощность хим реакции надо чтобы была как можно больше пло
щадь соприконенвения двух веществ. она тем больше чем больше число вещества в среде.
в ходе реакции эти вещества расходуются те которые как раз законтачили. поэтому высокая
полезная мощность реации приводит в такому же мощному понижению числа вещества. поэтому 
для прддержания этой скорости надо мощно доливать новое вещество чтобы заменить сгоревшее!

если мы вкидываем энергию батарейками  или стандатными единицаами 1 , то LA показывает
сколько энергии осталось от вкинутой за все время. что значит заканчиваюся баатарейки - 
это потому что часть этой энергии используется на полезную работу. фишка в том что 
мощность полезной работы от вкинутой энергии пропорциональна числу этой энергии. поэтому 
если мы вкинули 10 единиц енергии то в полезную работу првератитя 1 единицы. а 
если мы вкинем 100 единиц то в полезную мощность превратится 10 единиц. с одной стороны 
у нас будет сделна поленая работа с другой стороны она же и потратится. и ее нужно будет восполнять.
доливать. тоесть - мы занесли в кастрюлю 100 единиц энергии. за 5с из них прореагиоовало
1 единица энергии и превратилась в поезную работу. котоаря нас понесла в космос. 
если мы хотим еще быстрее лететьв космос мы заносим 1000 единиц из них  в полезную раоту
превратилось 100 единиц. которые нас понесли в космос  . но они же и потратилсиь. и их нужно
восстановить. иначе в следущий терн у нас прореагирует меньшеая часть энеоргии. и мы полетим
медленно.  ! хорший пример заряд q на конденсаторе. за время dt у нас в конденсаторе прореагиуерут
8% от общего числа q. поэтому чем боьлше q тем больше в штуках зарядов вытечет из конденса.
и они же как раз делают полезную работу - они греют сопротивление. поэтому если мы хотим
чтобы сопротивение грелось все время также быстро нам нужно доливать на кодесантор
этт же обьем потреянных зарядов.!


ema1min  alpha=0.92004441463 ,делитель  12.50, выходит через  5 минут на 99.76% от  12.5 при r=1
ema5min  alpha=0.98347145382 ,делитель  60.50, выходит через 30 минут на 99.75% от  60.5 при r=1 
ema15min alpha=0.99445984801 ,делитель 180.50, выходит через 90 минут на 99.76% от 180.5 при r=1 


напоминаю что la1min это не ema1min. la1min это Q(t) от ema1min. la1min=ema1min/12.5
тоже самое для 
    la5min=ema1min/60.5
    la15min=ema15min/180.5
    
получается что в простых случаях la1min это r_sr за 5 минут
la5min это r_sr за 30минут
la15min это r_sr за 90минут




вставка:
       %%%%%%%%%%%%%%%%



r:
было 0 

l: 0

r: залили +5 r=5
l: стало 8% от 5      5*8%=0.4

r: стало 2 r=2 (отлили 3)
l: стало  la=0.4*92%+2*8%=0.528


0.4/5=8%
3*0.08=0.24

la это должен быть некий аналог обьема работы который мы сдлали влиывая
и вылиывая воду из кувшина баатарейики


если r(t) это расвтор вода + спирт. = 92% воды и 8% спирта. то 0.08*r
это каждый r(t) это новая банка с раствором. он ее в себя забирает и отбирает 
только спирт. так что внутри кондесатора только спирт. 

тоесть la(t) это обьем спирта от всего тогообьема r(t) который прошел
через конденсатор

что проиходитпотом с эти спиртом?

если r(t) это смесь породы и угля  = 92% породы и 8 угля.
ema в себя засаывает только уголь. поэтому то что она показывает это 
суммарное количество угля на данынй момент в нее внутри. 

уголь почемуто портится по 8% за каждый цикл.
почему?

забуем пока про смесь пусть ema=0.92ema(n-1) + v(t)
кидаем толлкьо чистый уголь

la - смещение пружины. 
0.08*r - это неэфективность усилия. 

0.08(r-ema(n-1)) = delta ema

r(t) это шарик или капля одной и тожей массы которая падает с высоты r(t)
при удале ее пот эегргия преобзаует в кинет. и эта энергия через коэф передается
пружине. энергия шарика пропорциональная высоте. тоесть увеличили высоту
в 2 раза и энергия увеличиалось в 2 раза. 
la- смещение прцжины оно хотя имеет туже размерночть (метры) что и r(t) 
но посути явялется экивалентом энергии. 

E=0.5*k*x^2
x=(E*2/k)^0.5=(g*h/k)^0.5= [(g/k)^0.5] * h^0.5

x=[(E2-E1)^0.5]*1.7
  -----------        =  [(g/k)^0.5] * (h2-h1)^0.5 = Z*(h2-h1)^0.5
      k^0.5


F_sum=(F2-F1)=-kx+Const

E=gh= Int ( F_sum*ds)



приношу деньги в банк. делаю вклад. деньги  рублях.
деньги переводятся в доллары и кладутся на счет. 
и потом за каждый доллар что у меня на счету банк берет процент. 8% берет он 
себе. ema покаызает сколько долларов суммарно щас хранится в банке

пусь я приношу сразу в долларах. тогда нет конвертаиции.
итак люди приносят доллары. и потом за 5с с них берут процент.
их деньги тают. ema позвыает сумммму этих денег.

другой вариант. у нас на счету 1 000 000 доларов.
через 5с у нас осталось 920 000 долларов. и люди принесли еще 10 000
в итоге стало 930 000 о чем гвоорит эта цаифра? и какая связь с потоком
приносимых денег?


t=0  ema=0        r=10
t=5  ema=9.2      r=0
t=10 ema=13.46    r=5
t=15 ema=13.54    r=1

ema=0.92*ema(n-1)+r


стоии мы со шлангом над бочкой которая может вместить любой обьем.
у бочки снизу дырка, мы поливаем со шланга сверху. в зависимости от потока 
воды в бочке установится равновесный режим. когда число воды которая утекает 
равно числу вводы которяа втекает.и будет какойто уровень воды в бочке.
изменнеие потока воды в секунду будет менять этот равновесный уровень.

коднесанасаторная аналогия более сложная так как вода поступает не сверху
а имено через дырку внизу. но мы нельем со шланга а у нас сообащющиеся сосуды.э
и схема такая - в кажый момент времени мы менем или не меняем уровень воды 
в нашем сосуде. и меряем уровень воды в сосуде с конденсатором. 
если мы неменяе у нас уровень то вода в конце концов выровянется. 


конец вставки %%%%%%%%%%%%%%%%%%%%%%%




кстати я научился как быстро найти коэифициент 0.92 точно.
у нас графки это эксопненты которая падает по закону 
la=e(-t/L) где L это такой промежуток времени за который у нас la падает на e.
а падает он так когда t=1min для ema1min. значт -1=-60c/L
L=60с значит la(t)=e(-t/60), так как t=n*5c то 
la(n)=e(-5n/60)
так вот коэфициент 0.92 в разностной форуле e(n)=e(n-1)*0.92+r(n)  он покаызвает падения
экспоеннты за 5с. значит в формулу la(n) надо подставить 5c тоесть n=1
la(1)=e(-5/60) 'это как раз и будет 0.92 ну типа того. дело в том что как я показал там 
усебя на бумажках связь между реальной функцией и ее разностным аналогом не совсем такая и
на самом деле вот этот коэфицент 0.92 который называется alpha он равен

                tau
      alpha  =  ----- , 
                tau +h 
 
 
tau это интерал на котормо e падает в e раз а h это интервал сэмплиорвания
значит alpha=60c/(60+5)=60/65=12/13=0,923076923077
а e(-5/60)=0.9200444146

что не совсем одно и тоже.

тоесть идея в чем если есть функция y=e(-t/tau)
то ее разностный аналог это 

y(n+1)=y(n)*alpha

где

                tau
      alpha   = ----- , 
                tau +h 



поэтому если мы подставим наш 0.92 в формулу для альфа. учтем что h=5c 
то мы обнаружим что на самом деле разнотная формула

la(n+1)=l(n)* [e(-5/60)]

ей соответствует tau=alpha*h/(1-alpha)= (e(-5/60) * 5)  / (1-e(-5/60)) = 57.53
тоесть  в линуксе юзается экспоенента  в la1min которая на самом деле падает не на 
интервале 1 минута на на интервале 57сек. хотя через разностную формулу у нас все четко 
падает через минуту. как я понимаю фишка в том что так совпало что наша разностная формула
падает на интервале 60с. но если мы будем уменьшать h и переситывать alpha то в итоге мы
выйдем на разностоной формуле на tau=57.53 а не 60. вот я думаю в чем разгадка. ибо разнотное
уравнение это приближение , чтобы оно точно совпало нужно h устремлять к нулю. ну а так 
да текущее разложение падает на e в интервале 60с



возникает вопрос - как EMA определяет короткие проессы от длинных. грубо говорят EMA фиксирует
число процессов а потом анализирует их длинну. 


!! задание: надо сформировать такую плавающую нагрузку из проессов которые работают по 4 минуты r(t)
и сравнить наскоько точно EMA отражает их.

>> следущий шаг - надо понять на счет 5 минут. обязательно ли
чтобы sum(sinx) был неизменный в течение 5 последних минут....
могу ли я создать произволььную функцию вида
t=[-inf; -5] f(t)=0
t=[-5;0] f(t)=sum(синусов)
t=[0; +inf] f(t)=0



            
00) надо взять график  с рельным R посчитать от него la 
и поучться находть R используя график LA

0) LA работает если у нас нагрукза с T=5,10с ????
1) загрузить еще несколько реальных LA. и продолжить закрепляьт 
свое умение дешифровать график LA.
2) полный физ смысл lA ?


4.5) надо понять какой физ смысл несут r(t) у которых T>=15минут
котоыре попадают в полезный сигнал.  такой сигнал меняется от 0 до своего максимума
в течение 7.5  минут максимум. 


5) когда у нас случай номер 1) но еще при этом добавляется квадрат(скачок).тоесть
до этого я как рассмтривал. у нас есть устоявщися la и в следущий момент начинает наваливаться 
синус. а надо рассмотреть случай когда у нас есть некотоыйр la и тут начинает наваливаться сигнал
вида 
    LA(t0+t) = A*sin()+Const
    
    
следущие шаги:
1) проблеманя вторая полоса спектра
2) la1min vs la5min vs la15min
3) каков физ смысл сигнала котоырй очищен?
4) double EMA ( расмотерел. он ничего недает. он еще более сголажваеи LA)

средняя арифм находит выысотку столбика прмямоуглника на том же отрезке x 
чтобы в итоге была такая же плошадь


=====
$ cat 6.py 
#!/usr/bin/env python3

import numpy as np
from matplotlib import pyplot as plt




x=np.linspace(0, 10, 12*10)   # start, stop, step
y=np.sin((2*np.pi/1)*x)       # radians


plt.plot(x, y)
plt.grid()
plt.show()




если y=const имеет в спектре линию w=0, A=Const мне непонятно почму
этот сигнал через IIr филтр проходит струдом постепенно нарастая. в чем прикол? 
непонтяно!



                             
пример 

r_s=1  форма=( 12 0 0 0 0 0 0 0 0 0 0 0 ) LA=0.38
r_s=1  форма=( 0 0  0 0 0 0 0 0 0 0 0 12) LA=0.96


получается что если у нас 2 процессорный комп 
то лучше бы чтобы LA был вот такой
                rs <= 2
                rs <= 2.62LA

2.62LA=2, LA=0.76
тоесть 100% безопасный LA это LA=0.76
        rs <= 0.76
если же мы типа принимаем что нагузка равномреная то 
                
            rs <=2
            rs = 1.49LA 
            
            1.49LA<=2
            LA=1.34
            
            rs <= 1.34
            
а то что пиздлят в инете о том что если lA=1  то средняя была 1 это верно толко
в случае формы 

r_s=1  форма=( 0 0  0 0 0 0 0 0 0 0 0 12) LA=0.96

и все! при других  формах это утвреждение невернр!
а ну и еще слуачай такой что 

L(n-1)=A
f(n)=A
L(n)=0.92*A+0.08*A=1*A
но я этот случай когда L(-1)<>0 еще не разбираол!!

понятно что LA лежит всегда между  xmin <= LA <= xmax
но это нам ничего недает. у нас 
xmin=0 xmax=12  ну коенчно 0<LA<12


раасмотрим случай y(0)=y0
f(t)=const=0

Y(n)=0.92*Y(n-1)+0.08*0=0.92*Y(n-1)

p=0.92

Y(n)=p*Y(n-1)
y(0*t0)=l0
y(1*t0)=p*l0
y(2*t0)=p*p*l0
y(3*t0)=p*p*p*l0=(p^3)*l0
y(k*t0)=l0*(p^k)
0.92=e^(-1/12)
y(k*t0)=l0*(e(-k/12))
y(k*t0)=l0/( e(k/12) )
e(k/12)=l0/y(kt0)
k/12=ln(l0/y(kt0))

    k=12*ln(l0/y(kt0))
    t=60*ln(l0/y(kt0)), где y(kt0)=это тот конечный la который мы хотим получить.
    
    
    
    
l0=0.99, y(kt0)=0.1, k=27.5, t = 5*27.5 = 137,5c = 2м 17с

  
я проерил на практие - все четко работает.
прикол опть же в том что я 100% пдтвеераждаю что LA собирает данные четко раз  в 5 секунд.
все что мимо этого мгновнеия его LA просто не видит.

вот я запуска эту команду чтобы дать нагрузку
пока я не увиелчил таймаут до 3с его LA никак не мог поймать

 $ for i in $(seq 1 1 12);do stress --cpu 1 --timeout 3  &>/dev/null & done

например я имею 0.08=l0
тоода после запуска я должен получить ближайщий LA 
    LA(n+1)=l0*0,92+0,08*12=1.0520
    LA(n+1)=1.0336
    
проверяю
    0.08 0.15 0.13 13/1247 32703
    1.04 0.34 0.19 1/1223 32705

совпало нормал !

проверял и обратное.
если уменя l0=1.19
и нагрузки нет r(n)=0 то какой будет ближайщий сэмпл la?
    LA(n+1)=l0*0.92+0*0.08
    LA(n+1)=l0*0,92=1,19*0,92=1,0948=1,09

    
провверяю
1.19 0.45 0.24 2/1224 312
1.09 0.44 0.24 1/1224 314

все совпало!


далее
вот интересный момент. вот у нас идут нули 

....0 0 00 0 0 0 0 0 0 0 0 0 0 

и вот у нас случается пик
....0 0 0 0 0 00 0 0 0 00  0 0 12

он приводит к тому что La c нуля переходит в
LA=0*0.92+0,08*12=0.96

дальше у нас опятю же отсутссвуте нагрузка

.....0 0 0 0 00 00 12
.....0 0 0 0 00 00 12  0
.....0 0 0 0 00 00 12  0  0
.....0 0 0 0 00 00 12  0  0  0 



формально это вынлядит вот так в формуле котоаря другая

        ....+(0.92^3)*0    +(0.92^2)*0   +(0.92^1)*0+(1)*12
        ------------------------------------------------------
                                 12.5
                                 

так вот этот 12 начинает передивагсять по формуле влеви и унего начинает менять коэфиицента
                                                    
                                                    |
        ....+(0.92^3)*0    +(0.92^2)*0   +(0.92^1)*12+(1)*0
        ------------------------------------------------------
                                 12.5

                                 
                                      |
        ....+(0.92^3)*0    +(0.92^2)*12   +(0.92^1)*0+(1)*0
        ------------------------------------------------------
                                 12.5


                                 
                       |
        ....+(0.92^3)*12    +(0.92^2)*0   +(0.92^1)*0+(1)*0
        ------------------------------------------------------
                                 12.5
                                 
                                 
меня интерсует вопрос что будет с LA через минуту

                        
                                  ... . 12
                                ... 12  0
                             ... 12  0  0
                                      ...
                                      ...
                                      ...
   12  0  0  0  0  0  0  0  0  0  0  0  0 

значит у нас 13 точек. промежутков 12 штук. тоесть промежутки образуют 60с
когда 12 был в голове это было время t=t0
кода 12 окаазлся в хвоесте то это было время t=t0+60c=60c
тоесть мы берем LA в момент t0 LA(t0)
и потом ждем 12 промежутков по 5с и меряем на 12-ом промежутке. 
по времени это t=t0+60
тоеть еси t0=0 то t1=60
если t0=10  то t1=70
тоесть между t1-t0 ровно 60с

LA(60)      (0.92^12)*12      
====== =    ------------- = 0.92^12 = e((-5/60)*12)=e(-1) =1/e ~= 0.3678 ~= 0.37
LA(0)        1*12

тоеть через 1min от LA остается ~1/3 от ее значения.
условно говоря
                                       1min    1min  1min 1min
                                       <---- <---- <---- <----    
                                   |         |      |    |    |
                                   
                                  (0.1)....(0.3)....1....3....10
   
   
значит LA(1min) имеет то свойство что если есть всплеск r(t0) 
то LA подскочит в t0 а потом будет падать и в момент t0+1min LA затухнет в e(1) раз это почти в  3 раза
тоесть
имеем до t0 имеем LA=0
в момент t0 имеет r(t0)=A и подскок LA до LA(t0)=0.08*A
а далее LA начинает падать 
пусть A=10
                    t0                           (1.00)*10=10   ---------
                    +1*t0                        (0.92)*10=9.2          |
                    +2*t0                        (0.85)*10=8.5          |
                    +3*t0                        (0.78)*10=7.8          |
                    +4*t0                        (0.72)*10=7.2          |
                    +5*t0                        (0.66)*10=6.6          |---
                    +6*t0                        (0.61)*10=6.1          |dt=60c, 3.7/10=1/e
                    +7*t0                        (0.56)*10=5.6          |---
                    +8*t0                        (0.51)*10=5.1          |
                    +9*t0                        (0.47)*10=4.7          |
                    +10*t0                       (0.43)*10=4.3          |
                    +11*t0                       (0.40)*10=4.0          |
                    +12*t0                       (0.37)*10=3.7  ---------
                    
                    
                
                
итак если у нас нет нагрузки то LA падает у нулю. через 1 мин он падает в "e" раз
что касается роста то при ровной нагрузке LA тоже падает только не к низу а кверху!
падает к LA=Const. как бутто там ноль. как бутто там точка притяжения. и падает он так
за 1 минуту расстояние между LA(t) и LA=Const должно уменшиться в "e" раз.
тоесть LA(t0)=l0,  LA(t0+1min)=Const-(Const-LA)/e
пусть la(t0)=0, LA(t0+1min)=Const-(Const)/e=Const(1-e(-1))~=Const(1-0.37)~=Const*0.63
если Const=10 то LA(t0+1min)=6.3
    LA(t0)=0
    LA(t0+1min)=6,3
    
так как LA "падает" к LA=10 то после одной минуты расстояние меджу LA и 10 стало 10-6.3=3.7
тоесть я говорю что расстояние уменьшилось в "e" раз.

Получается по идее график что растет под постоянной нагрузкой
что падает при остуствии нагрузки с одинаковой скоростью. 

проверим расчетом. как я уже писал выше присотсвувтии нагрузки график упадет от l0 
до y1 за время

        t=60*ln(l0/y1))   (1)

пусть l0=10, y1=0.1 тогда t= 276с = 4м36с

рассмотрим обратный процесс. мы сидим в нуле l0=0. даем нагрузку f(n)=10=Const
через сколько времени LA достигнет LA=(10-0.1)=9,9
у нас для роста есть такая формула

    LA(n+1)=LA(0)*p^n+(1-p^n)*Const
    

пусть 9.9=y1

y1=0+(1-p^n)*C
1-p^n=y1/C
p^n=(1-y1/C)
p=e(-1/12)
e(-n/12)=(1-y1/C)
-n/12=ln(1-y1/C)
n=-12ln(1-y1/C)
t=-60ln(1-y1/C)

$ bc -l <<< "scale=4; -60*l(1-9.9/10)"
276.3060

получили тоже самое. тока я щас хочу от минуса в формуле избаитсья


e(-n/12)=(1-y1/C)
1/e(n/12)=(1-y1/C)
e(n/12)=1/(1-y1/C)
n=12*ln(1/(1-y1/C))
t=60*ln(1/(1-y1/C))

        t=60*ln(C/C-y1)


значит вот они две формулы

                t=60*ln(l0/y1))   (1)  # в случае падения графика когда f(n)=0
                t=60*ln(C/C-y1)   (2)  # в случае подьема графика когда f(n)=C
                y1 это величина которую хотим достичь.
                

                

далее прмиеры

  t |    p |  p_LA |  c_LA |  a_array |
---------------------------------------
  0 |   22 |  1.77 |  1.77 |    undef | 
  5 |    2 |  1.79 |  1.79 |    undef | 
 10 |   21 |  3.32 |  3.33 |    undef | 
 15 |    3 |  3.38 |  3.30 |    undef | 
 20 |   19 |  4.87 |  4.56 |    undef | 
 25 |    2 |  4.72 |  4.36 |    undef | 
 30 |   18 |  5.78 |  5.45 |    undef | 
 35 |    0 |  5.40 |  5.01 |    undef | 
 40 |   17 |  6.41 |  5.97 |    undef | 
 45 |    0 |  5.90 |  5.49 |    undef | 
 50 |    5 |  5.82 |  5.45 |    undef | 
 55 |    0 |  5.52 |  5.01 |    undef | 
 60 |   14 |  6.36 |  5.73 |     9.46 | 
 65 |    1 |  6.01 |  5.35 |     7.85 | 
 70 |   12 |  6.73 |  5.88 |     8.62 | 
 75 |    1 |  6.35 |  5.49 |     7.08 | 
 80 |   19 |  7.36 |  6.57 |     8.31 | 
 85 |    0 |  7.09 |  6.04 |     6.85 | 
 90 |   21 |  8.45 |  7.24 |     8.31 | 
 95 |    1 |  8.09 |  6.74 |     7.00 | 
100 |   19 |  9.12 |  7.72 |     8.46 | 
105 |    0 |  8.55 |  7.10 |     7.15 | 
110 |   17 |  9.39 |  7.89 |     8.46 | 
115 |    2 |  8.88 |  7.42 |     8.23 | 



t=60, LA=5.73, 

  
используя формулу

                  1.04LA  =< rs =<  2.63*LA    (1)

поулчается 
    rs <= 2.63*5.73 
    rs <= 15
    
исходя из графика реальный rs=9.46 это попадает в диапазон rs<=15

кстати аарифм среднее скользящее это арифм среднее но  в определенном окне.
ксатти арифм среднее можно посчитать по формуле(кстати в этом плане неопнятно почепу 
экпонетциальаня средня называется скользящей. у нее нет окна. она рабоатет со всеми 
x1.xn от и до)

    SMA(n) =SMA(n-1) -x(n-n0)/n +x(n)/n

x(n-n0) - это самая рання точка по времени которая была  в SMA(n-1) усреднении,
тоесть это не в текущем усреденении самая ранняя точка в предыдущем

    
я лучше вот так буду ее юзать
    SMA(n) =SMA(n-1)  +x(n) -x(n-n0)
                      ------------
                           n


t=65, lA=5.35
значит расчетный r_sr <= 5.35*2.63=14

высчтываем r_sr 
получается 
x(n-n0)=x(t=0)=22
r(n)=1

r_s(t=65) =9.46 +(1-22)/13 = 9.46-1/13=7.84
согласно таблице r_s(t=65)=7.85 ну это видимо из за округления

      7.84 < 14 
      
значит расчетный r_sr попал в диапазон

понятно почму линукс не использлвал SMA . потому что им бы пришлсь для расчета SMA(t0+5s)
пришолось бы хранить помимо  SMA(t0) еще каджый раз f(t0-13s) хотяэто по мне не такая уж
большая прблема.


еще ложные утверждоения: если у нас LA=N то за поседнюю минуту в очереди не было 
процессов боольше чем N это полная хуня.
пример 
    ( 00 0 0000000 12) LA=0.96
тоесть 12 намного бльше чем 0.96

второе ложное утвреждение - что lA=среднему арифметическому за последнюю минуту.



                
     
    $$$$$$$

    
    

    $$$$$$$

        



где r(n) отличается от r(n-1) тем что это берутся сэмплыт отличающиеся 5с по времени.
и видно что с появлением нового элемента r(n) от него берется только 8%. тоесть новый элемент
влияет на LA очень мало. тоесть этакривая при данном p является очень нечуствительной при имзении r(n).
тоесть когда у нас r начинает резко расти то LA реагирует очень вяло сопротивляется как маховик
котррый имеет инерцию. верно и обратное. когда у нас r(n) пропало упало то lA будет сопротивлсяться
и продолжать ббыть еше высоким. поэтому график r(n) и график LA(N) будет отличаться кординально.
тоесть имя график LA(n) нихера непонятно какой был исходный r(n) это непонять
имея r(n) можно вычитать LA(n) что сосвтенно мы и делаем. но нас то интересует обаная задача
мы имеем LA(n) и нам хочется понять какой был r(n) в прошлом.

понятно что график средней арифметической он будетпросто горизонатальная линия проходящая через ноль.
а LA не будет прямая линия. вот пример
    https://stats.stackexchange.com/questions/286640/definition-of-the-function-for-exponentially-decaying-weighted-average
это тоже будет синусоида но она будет отличаться от исходной синусоиды сильно.

LA имеет ряд точных свойств. если у нас скажем шарашит постоянный r(n)=Const
то LA никогда не может превысить LA <= Const.
также LA всегда LA >=0 тоесть елси мы имеем LA=10 мы можем точно сказать что среди поля r(n)
на котрормо выитывался LA все они подчинялст правилу r(n) <= 10 это 100%.

ну в случае синуса еще можно понть почему так берут LA. но у нас график r(n) всегда положиетлльный.
почему они не вычистывали простое арифемтечиеское я не понимаю.  


    

        
    
        
но фишка в том что эта формула верна только если r(n) в пределах минут остатеся констатой.
а если это не так. то формула идет нахуй. и надо считаьт по общей формуле
    
    (w1*x1+w2*x2+....wn*x) / (w1+...+wn) = LA

поэтому в общем случае абсолбтно непонятно сколько % каджлая минута 
вносит в LA.  замечу что 

    


    чтобы гарнатировать что у нас ядре вобще не бывает среднего числа r >1 то тогдда LA должен 
    лежать в диапазоне <=0.35
    
    но тогда паттерн будет между тремя крайними

    
    ( 12 0 0 0 0 0 0 0 0 0 0 0 0 ) <-- ... -> ( 0 0 0 0 0 0 0 0 1 1 1 1 ) <---.. --> ( 0 .... 4 )
    тоесть среднее число не првышает r=1 но процессор большую часть времнеи стоит
    
    
    

    
либо цпу работал мало времени и был большой выброс r по такоу паттерун
( 20 0 0 0 0 0 0 0 0 0 0 0 )

вот что гарантирует LA(1min) <= 0.6



  
я тут рассмотрел w(n) или w(i) как хочешь называй. однако по факту каждый член выглядит как

    w(n)*x(n)        w(n)
    --------- =   ---------- * x(n) 
    summa(w)       summa(w)
    
summa (w(n)) при больших n стремится к 12.5 для случая когда p=e(-1/12)~0.92 как это есть для lA(1min)

значит


    w(n)*x(n)        w(n)               1
    --------- =   ---------- * x(n) =   ----- * w(n) * x(n) = [0.08 * w(n)] * x(n)
    summa(w)       summa(w)             12.5


получается 

    LA = [0.08*w(1)]*x(1) + [0.08*w(2)]*x(2)+...[0.08*w(n)]*x(n)

где каждый x(n) это семпл r взятый через каждые 5 секунд.

на самом деле 0.08 можно вынести за скобки и тогда моя верхня таблица по прежнему
имеет силу для анализа как глуубоко назал по времени надо учитывать члены последовательности.
тоесть 0.08 на это не влияет. 
    

также 0.08 не влияет на вот эти проценты

 66,57% 
 21,53% 
 7,92% 
 2,91% 
 1,07% 

    
о том какой вклад в суммарный результат приводит ккаждая минута.
тоесть левую и праву частьможно сократть на 0.08 и это никак не влияет 
на проценнрое сооотошение.

далее я взял все x(n) равным 1. тогда на  проценты влияют только коэфициенты ц(т) и для них
и посчитал проценты. 
вопрос а ессли x(n) все разные разве процент сохраится ???

зато ясно одно что 

    [0.08*w(n)]*x(n) = 0.08 * 1 * x(last) = 0.08 * x(last)
    
тоесть последний 5-секундный сэмпл вносит вклад в LA как 8% от него.
тоесть если мы знаем наш текущий r. то 8%*r ушло в состав текущего lA. 




ВОПРОС-насколько правомерный проценты если у нас x(n) внутри минуты  неравный единице?
непонятно..... <================

 я тут рачсотрел два патерна
 
 (1 1 1 1 5) LA=3,52
 (5 1 1 1 1) LA=1,04
 
 среднее арифметичкоское  одинковое но lA совереное разное. так что 
 LA неельзя трактовать как средннее число процессо за 5 минут!!
 также видно что набор скорости идет мделнее чем сброс. если воспринимать
 это как маховик. 
 
 еще пример
 ( 4 1  2 8  2  ) LA=3,37, рачстный рукми LA=3.2813
 
 не могу поняь почему вот эта штука все раввно работает
 
 66,57% 
 21,53% 
 7,92% 
 2,91% 
 1,07% 

 
 
 
 
 



    
из чего видно что по крайней мере 5 последних минуты вносят самый мощнй вклад
в EMA. вносят они в соотношении тех процентов что указаны
тоесть последнняя минута дает 67% вклад в  LA. втоаря с конца дает 22% вклад в LA третья дает 8% 
следдущие две можно на них забить а можно не забить.
причем я уже молчу что внутри каждлй минуты каждый сэмпл имеет тоже свой вес. как это видно.


главное что это полная хуйня что LA образован последней минутой. хуйня полная.
он образован полсденими 3-5 минутами. причем в неравной пропорцции. как в отношении каждой
минуты в целом. так и внутри каждой минуты вклад каждого сэмпла имеет свой вес индивидульаный.

тоесь ябы сказал так. если у нас есть график r(t) за последние 3-5 минут.
то можно руками посчитать LA(1min). надо взять среднее за каждую минуту из пяти последних.
и назначив этим средним за каждую минуту веса

| 66,57% 
| 21,53% 
| 7,92% 
| 2,91% 
| 1,07% 

найти средне взвещенное. и мы получим примерн наш LA (1min)

66,57% * ( среднее за последнюю минуту) +
21,53% * ( среднее за предпоследнюю минуту ) +
7,92%  * ( среднее за третью с конца минуту ) ~= LA (1min)

четвертую пятую с конца тоже можно брать если там охиренные средние. 
а если нет то можно и не брать.

скажем у меня вот такая нагрузка была r(t)= (1 2 3 1 1)
нагрузка шла слева направо
каждая цифра это в течение одной минуты. тоесть вначале одна минута r=1
потом еще минута r=2 потом еще минута r=3 потом еще минута r=1 потмо еще минута r=1
пощитаем наш теоричеческий ручной LA

    0.67*1+ 0.22*1 +0.08*3 = 0.67+0.22+0.24 = 1.13

на практике LA через 5 минут был равен 1.20 
то есть совпдаение просто отличное для расчетов на коленке.

получаетс что вклад средней за последнюю минуту в LA составляет ~67%
а вклад всего остального составляет ~33%
причем что важно неважно как росла нагрузка как она менялась потому что мы щас считаем EMA
не наоснове итеративной формула а на основ формулы w1*x1+w2*x2+...wn*xn
так что это верно в любом случае.
более того. я только что написал что все что идет до последней минуты то есть со второй с конца
до начала работы компа этот влкад составляет 33%. так как экспоненты незануляется никогда
то формально все члены r(t) начиная с самого начала работы компа формально вносят вклад.
но как видно из моих расчетов для коэфициуентов. в последние 5 минут входит я бы сказал 99% 
как миниум всего LA. так что в LA вносит реальнйы вклад последние 5 минут и все! я имею
ввду la(1min). так что зная r(t) за последние 5 минут. и даже зная его за последние 3 минуты
можно с большоой точностью узнать LA посчитать его руками.
причем я сказал что достаточно посчитать среднее арифм внутри каждой минуты и применить к ним 
проценты что я получил. в целом это подходит. но ели мы хотим еще большей точности то 
надо внутри каждой минуты (за последние 5 минут) все разбить на интервалы по 5 сек. и 
к кажому такому куску подставить эти экспоеннциалные коэфифиценты. и посчитать средневзвещенное
с этими коэфицикентами. 

    w1*x1+w2+x2+....+wn*xn
    ---------------------- =LA 
    w1+w2+...wn
    
где w1-wn это коэфициенты посчитанные выше
а x1-xn это показания r(t) за последние 5 минут с сэмплированием 5 сек

а можно посчитать с меьшей точностю за то прям рукамт по формуле

66,57% * rs(t0) + 21,53% * rs(t1) + 7,92% *rs(t2) + 2,91% *rs(t3) + 1,07 * rs(t4)  ~= LA (1min)


где t0 - это последняя минута
t4 - это пятая с конца минута
rs это r среднее арифметическое за соооветствующую минуту


так вот что еще интересно. то что если мы возьмем даже простую нагрузку
за последние 5 минут но поменяемв ней местами куски то у нас средне арифметичское
не поменятся. а вот LA очень даже поменяется

один пример у нас уже есть
     r(t)= (1 2 3 1 1)
     LA (посчитанны строго ) = 1.20
     LA (посчитанное руками ) = 1.13
     среднее арифм за 5 минут = 1.6
     
меняем местами эти куски
     r(t)= (1 1 1 2 3)
     LA (посчитанны строго ) = 2.49    
!!!! почуствуй разницу с преддыущим LA
считаем теперь руками.

66,57% * 3 + 21,53% * 2 + 7,92% *1 + 2,91% *1 + 1,07 * 1 = 2.55  = LA посчитанынй руками
иттого 
     LA (посчитанное руками ) = 2.55
как видно ручной расчет даже при учете того что  я внутри каждой минуты просто вычиялсяю среднее
арифм а не экспоенцаильное влияете так вот ручной расчет показывает отличнй резульат с точным
расчетом!
ну и среднее арифметеиесоке у нас осталось тем же саммым
    среднее арифм за 5 минут = 1.6

итак подвожу итог по этим двум случаям

     r(t)= (1 2 3 1 1)
     LA (посчитанны строго ) = 1.20
     LA (посчитанное руками ) = 1.13
     среднее арифм за 5 минут = 1.6

     r(t)= (1 1 1 2 3)
     LA (посчитанны строго ) = 2.49    
     LA (посчитанное руками ) = 2.55
     среднее арифм за 5 минут = 1.6

как видно средне арифм похер . оба слуая для него одинаковые
а вот на LA это влияет очень значительно. порядок нагрузки.

еще один вывод второстпенный. так как  у нас EMA(n)=EMA(n-1)*k1+f(n)*k2
то это значит что если текущий EMA[n]=0 то в этот момент f(n) неможет быть неравен нулю.
потому что EMA(n-1) всегда >=0 и если у нас f(n) <>0 то мы никак не сможет получить EMA(n) 
равным нулю.

и вот теперь можно перейти к главному вопросу - если у нас на эаркне линукса 
мы видим в данный момент какойто LA(1min)=N что мы можем из этого скаать ?
по мне можем сказат на самом деле очень мало
смотрим в формулу
    LA(1min) = N
    0,6657*A + 0,2153*B + 0,0792*C + 0,0291*D + 0,0107*E = N
подчеркиваю что A это последняя минута. а E это пятая с конца от текущей минуты
тоесть тайлай тайкой

    (начальный момент) E-->D-->C-->B-->A (текйщу ммометнт)

так вот 
пусть N=23.03
и тут куча вариантов

    0,6657*1 + 0,2153*100 + 0,0792*10 + 0,0291*1 + 0,0107*1 = 23.03
    тоесть A=1, B=100, C=10, D=1, E=1

а может быть вот так

    0,6657*17 + 0,2153*42 + 0,0792*30 + 0,0291*5 + 0,0107*6 = 23.03
    тоесть A=17, B=42, C=30, D=5, E=6
    
и как видно зная LA это нихрена нам недает в плане понять какая была средняя нагрузка
за последнюю минуту! 
невозможно опредедить какую часть от LA составляет вклад последей минуты для примера.
потому что 

    A = N-(0,2153*B + 0,0792*C + 0,0291*D + 0,0107*E)
        --------------------------------------------- ~= 1.49*N - 0.32*B - 0.12*C - 0.04*D - 0.02*E
                          0,67

поэтому незная ни B ни C ни D ни E опредедить A зная только N невомзонжно!!!
можно только это узнать в частных случаях. но опять же полтому что мы тогда знаем и B и C
и D и E. тоесть случай нппимер комп стоят полчаса холостой и мы дали на него нагрузку только в послед
нюю минуту. тогдаа B=C=D=E=0 тогда
    
    A = 1.49*N 

скажем если N=2, тогда A=2.98~3. тоесть если мы жахнули r=3 то через минуту получим LA(1min)=2
или если N=0.63 значит A=0.94~1, если мы жахнули r=1 то через миуту мы получим LA(1min)=0.63

итак зная LA(1min) в общем случае это нам нихрена не дает понять  какоая была нагрузка
за последнюю минуту. суки.а не то как об этом пишут везде.
единсвтенное что примерно можно понять зная LA(1min) это то что примерно такая же средняя
арифметическая нагрузка за послдение 5 минут. тоесть если LA(1min)=10 значит средняя нагрузка
за последие 5 минут примерно равна 10. вот и все что дает нам этот сраный LA(1min)

также можно еще один  частный случай расмотреть. положим у нас полчаса уже шарашить 
одна и таже нагрузка. значит за последие 5 минут A=B=C=D=E тогда
подставляем

    A = 1.49*N - 0.32*A - 0.12*A - 0.04*A - 0.02*A
    1,5A = 1,49 N
    A=0,993*N
    A=N

что на практике мы и видим всегда!

витоге стало понятно из чего LA складывается. 
тоесть зная нагрузку последние 5 минут можно легко высчтвать LA. но эта задача на пратаике
неимеет никакйо пользы.
и стало понятно обратная задача если мы
знаем LA ччто нам это дает. ответ - почти ничего. задача на практике нужная.
но LA нам недает ответ вобщемто ни на что. кроме частных случаев.
единственное повторюсь что из lA можно выжать в общем случае это то что он показывает среднюю
нагрузку за последение 5 минут. ! все !!
LA(5min) показывает среднюю нагрузку за последние 25 минут
LA(15min) показваывает среднюю нагрузку за псоледние 75 минут.

вот ивсе по этой теме !!!!

поэтому если мы зашли на комп и увидели три цифры
    $   cat /proc/loadavg 
    0.42 0.25 0.24

то это нам говорит что примерно 
    за посление  5 минут срденя нагрузка R|D была 0.42 процесса в сек
    за посление 25 минут срденя нагрузка R|D была 0.25 процесса в сек
    за посление 75 минут срденя нагрузка R|D была 0.24 процесса в сек
    

такой еще момент. вот у нас щас есть LA(1min)=N
и у нас есть текущее занчение r. так вот это текущий r сделал в данный lA вклад в размере
8%*r. остальные 92% в него вложили все осталные сэмплы пятисекундные.так что я о том что текущий 
r последний он нам нихрена недает в плане понимания про все остальное. про то какая была нагрузка
скажем за последнюю минуту.

при равномерной нагрузке N
    LA(1min)  через 1  мин достигает 63% *N
    LA(5min)  через 5  мин достигает 63% *N
    LA(15min) через 15 мин достигает 63% *N

    
вот и все что мы с этого знаем !!!







                          
     
приколно что итеративная фрмула EMA она высчитываетс на практкие лешче
но он нихера ничего не помоае понятть. 
а класическая формула через w1*x1+w2*x2... она высчитывается на практкие сложене
зато она позволяет это сделать в ллюбой момент. и все помаогает понять окуда в LA ноги
растутё!!!!






на счет экспоненциальной средней скользящей EMA ( в дальнейшем уду называть ее
экспо средняя). ее каноническая форма вычисления в итеративной форме 
согласно вики выглядит как

EMA[t] = a*f[t] + (1-a)*EMA[t-1]
но вики посылаем нахуй
вот по этой ссылке 
    ( https://stats.stackexchange.com/questions/286640/definition-of-the-function-for-exponentially-decaying-weighted-average )
дана другая формула
    EMA[t] = p*EMA[t-1] + (1-p)*f[t]

где f[t] - это функция которую мы усредняем.
p - это константа 0 < p < 1 

как выбрать эту константу это отделрная тема.  так вот что я хочу сказать.
при вычислении LA у линукса они юзают формулу .
смотрим в loadavg.c 
    ( https://github.com/torvalds/linux/blob/master/kernel/sched/loadavg.c)
    
    avenrun[n] = avenrun[0] * exp_n + nr_active * (1 - exp_n) 

немного поменяем вид
    avenrun[n] = exp_n * avenrun[0] + (1 - exp_n)*nr_active  

сравниваем  с верхней
    EMA[t] = p*EMA[t-1] + (1-p)*f[t]

почти одно итоже
p=exp_n 
а что такое avenrun[0] хуй знает

exp_n = e^(-5/60) для la(1min)


O*la(-1)+(1-O)*r(t)=0,92*la(-1)+0,08*r(t)

y(t)=(1-o)*x+o*y(t-1)=x-o*x+o*y(t-1)=o(x+y(t-1))+x

o=y(t)-x(t) / x(t)+y(t-1)

1  p^(-1) p^(-2) p^(-3) p^(-4) p^(-5) ... p^(-12)
p=e^q
1  e^(-q1) e^(-2q) e^(-3q) e^(-4q) e^(-5q) ... e^(-12q)

e^(-12q)=e^(-1)
12q=1
q=1/12


e^(-n*q)=e^(-1)

-n*q=-1

n*q=1

q=1/n


1 e^(-1q)  e^(-2q) .... e^(-nq)

e^(-nq)=e^(-1)

-nq=-1

q=1/n

n=T/s

q=1/(T/s)=s/T

s<<T

s=5s
T=60s

q=5/60

1 e^(-1/12)  e^(-2/12) e^(-3/12).... e^(-12/12)

p=e^(1/12)

Y(t)=[e^(-1/12)] * f(t) + [1-e^(-1/12)] * Y(t-1)



l(t)=l(t-1)e^(-5/60)
l(0)=l0

l(5)=l0*e^(-5/60)
l(10)=l0*e^(-5/60)*e^(-5/60)=l0*e^(2*(-5/60))=l0*e^(-10/60)
l(15)=l0*e^(-10/60)*e(-5/60)=l0*e^(-15/60)

l(t)=l0*e^(-t/60)

l(T)=l0*e^(-1)




Y(t)=p*Y(t-1)+ (1-p)*f(t).
пусть у нас в ммоент t=0 f(t)=0 и далее он тоже 0

Y(0)=Y0

Y(t)=p*Y(t-1)+0
Y(t)=p*Y(t-1)

пусть p=e(^-q)
Y(0)=Y0
Y(t0)=p*Y0
Y(2t0)=p*p*Y0=Y0*p^2
Y(kt0)=Y0*p^k

пусть kt0=60c,
пусть t0=5с
тогда k=1...12

Y(12*5)=Y0*p^12

далее мы выбираем что p=e^(-q)
тогда
p^12=e^(-q)*12=e^(-12q)

Y(12*5)=Y0*e^(-12q), q=константа
мы хотим чтобы -12q был равен -11 . тогдаа -12q
    -12q=-1
q=1/12

тогда p=e^(-q)=e^(-1/12), тогда

Y(t)=e^(-1/12)*Y(t-1)
и как мы только что выяснили при t=T=60c  у нас
Y(60)=Y(T)=Y0*e^(-1*12/12)=Y0*e(-1) ~ 37% Y0
тоесть при отсусвти нагрузки через время T Y(T) сосавить 37% от Y0
тоесть
    Y(T)=0.37*Y0
как эту формулу можно проинтепретировать 
если у нас есть Y0 а потом нагрузка исчезла стала равна нулю.
то график начинает падать. за 1 минуту он падает на 0.63(две трети) от высоты графика.
ну или говорят по другому от него остается одна треть
тоесть скажем Y0=10
значит через минуту это будет 10*0.37 ~ 3.70
еще через минуту от него останется одна треть от оставшегося 3.70*0.37=1.36
важно заметить что чем меньше остается от Y тем медленнее он начинает уменьшатся.
итак еще раз при исчезновени наггрузки Y начинает падать так что за 1 минуту он теряет 2\3 от себя.
и чем больше по высоте Y тем он теряет в абсолютной величине больше. чем меньше у него
остатеся высота тем в абсолбном значении он теряет все меньше. и в итоге он хрен никогда
не достигнет нуля.


теперь смотрим другой пример
пусть у нас в n=0 Y=0 и мы подаем нагрузку постоянную f(n)=C


Y(n)=p*Y(n-1)+ (1-p)*f(n).
в n=0 Y(0)=0
и пусть f(n)=const=C

Y(n)=p*Y(n-1)+ (1-p)*C


Y(0)=0
Y(1)=p*0+ (1-p)*C = (1-p)*C
Y(2)=p*((1-p)*C))+ (1-p)*C= (1-p)*C * (p+1)
Y(3)=  p*(1-p)*C*(p+1)+ (1-p)*C = (1-p)*C* [ p*(p+1) +1 ] =
= C*(1-p)*(p^2+p+1)=C*(1-p^3)


значит финаьная формула
        Y(0)=0, где n=0
        Y(n)=C*(1-p^n), где n=1,2,3,4,5....

и тут возникает вопрос. n- это просто порядковый номер элемента в множестве.
f(n) это порядковый номер элемента который мы берем для формулы снаружи.
а Y(n) это элемент который мы вычисляем. вознкает вопрос а где тут время?
а времени тут нет и небудет. вопрос как часто нам нужно брать из системы элементы f
тоесть число процессов. ответ такой - нужно брать так часто как мы сами этого хотим. 
дело в том что множество f мы составляем сами. если мы будем брать f каждую секунду
или каждый час оба множества будут верные. для кажого из них будет получатся свой набор Y
и оба будут правилные. дело вот в чем. у нас есть на компе некий поток f(t).
мы выбираем некторые моенты времени t0,t1,t2,t3,...tn и в эти моменты мы считываем
из системы f0, f1, ... fn.  мы сформировали множество. на основе тех t которые мы сами 
захотели взять. далее уже никаких t у нас нет у нас есть множество из fn элементов.
и мы для каждого fn находим его Yn. соотвсвтенно в зависиомсти от исходного множества котоырй
мы сформировали у нас будет получаться и набор Yn разный. и каждый из них будет правилный. 
дело тут в другом. вот у нас есть физическое явление - поток льющихся f. если мы 
будем брать f(t) слишком редко то наше множжество fn будет мало соотвествовать нашему
исходному потоку f. и поэтому полученные Yn тоже будут в итоге малосоответстовать тому потому
Y(t) который в теори можно было бы вычсчитать если бы мы могли собрать все f(t) которые льются.
Это легко понять рна примере если бы Y у нас высчитывал обычное среднее арифметическое.
если мы будем брать сльшком малый набор fn= от f(t) то полученный Y(n) у нас будет очень 
херово находить среднее для реального f(t).
поэтому ответ -  а как часто нам надо брать fn от f(t) - нужно брать как можно чаще
тогда наш Y(n) будет формировать ответ похожий на правду.

кстати  в формуле Y(n) неявно присутвтует t вот как 
мы когда выбираем fn мы их выбираем вот как f(1)=f(t1), f(2)=f(t2), f(3)=f(t3)
значит можно написать такую функцю которая выразит n=n(t) поэтому
    Y(n)= Y[n(t)]
    
так вот удобно снимать данные из системы через равные промежутки времени тоесть
 f(n=1) = f(t=10)
 f(n=2) = f(t=20)
 
тогда t=n*10, тогда n=t/10 где   n=1,2,3,4,5,....
10это t0 интервал сэмплирования.
    n=t/t0
    
подставляем

        Y(t/t0)=C*(1-p^(t/t0)), где t=t0, 2t0, 3t0, 4t0
    
далее в линуксе ядро сэмплирует через 5 тоеть t0=5
значит
    
            Y(t/5)=C*(1-p^(t/5)), где t=5, 10, 15, 20

далее мы хотим то что чтобы через 1 минуту у нас Y упал бы на величину C*(1-e(-1))
тогда

    Y(60/5)=C*(1-p^(60/5))=C*(1-e(-1))
тогда
    1-p^(12)=1-e(-1)
тогда
    p^12=e(-1)
    
значит
    p=e^(-1/12)
действельно
    p^12=e^(-1/12)(12)=e^(-1)
значит формула принимате вид

        Y(t/5)=C*(1-e^(-1/12)*(t/5)) где t=5, 10, 15, 20
        Y(t/5)=C*(1-e^(-t/60))
или через n, n=t/5
    Y(t/t0)=C*(1-p^(t/t0)) = C*(1-e^(-1/12)*n)
    Y(n) = C*(1-e^(-1/12)*n)
    
проверяем. берем t=60. значит n=12
    Y(12)=C*(1-e(-1/12)*12)=C*(1-e(-1))

повторюсь что вопрос как нам часто брать f(t) и формировать из низ f(n) 
нам даже рещать нунужно. в линуксе ядро это делает кажые 5 секунд. так что 
за нас уже решили.

итак вот эта формула
            Y(t)=C*(1-e^(-t/60)), где t=5,10,15,20,.....
            Y(n)=C*(1-e^(-1/12)*n) , где n=1,2,3,...
она выражает какой будет LA в любой точке t=5,10,15,20 или n=1,2,3,...
при условии что у нас в t=0 у нас Y=0 и при условии что f(t)=const=C

зададимся вопросом сколько процентов будет через 1 миунту jn C
        Y(12)=C*(1-e(-1/12)*12)=C*(1-e(-1)) ~ 0.63*C = 63% * C

таким образом если у нас в t=0 у нас LA=0 и мы дали нагрузку  в районе r=10
у нас через 1 минуту LA достигнет 6.3

вопрос а когда у нас Y достигнет C ?
        Y(t)=C*(1-e^(-t/60))=C
        1-e(-t/60)=1
        1/e(t/60)=0
        это хрень решения не имеет. но возьмем вот так
        1/e(t/60)=0.1
        e(t/60)=10
        t/60=ln(10)
        t=60*ln(10)
        t=138c
        а если взять
        1/e(t/60)=0.01
        t/60=ln(100)
        t=60*ln(100)
        t=276с
итого я считаю что Y(300с)=С
300с это 5 минут.

итак если мы дади рановемерную наргузку  C то Y(t) достгнет этого C через ~ 5 минут

получсется если мы дали равномерную нагрузку r=C то LA(1min) дорастет до нее примерно за ~ 5 минут
и если мы сбросили нагрузку то LA(1min) упадет в ноль тоже примерно за 5 минут 


итак я приходу вот к какому выводу. LA(1min) это средняя экспоененицаильная скользаящая.
А средняя экспоененциальная скользаящая согласно определению это
сумма процессов умноженных на веса и поеделенная на суму этих весов. 
так вот я выше показал выше что как это сделано влиунксе когда коэффициенте p=e(-1/12) то 
эти коэфицианты неравны нулю тоесть вносят вклад только только максимум за послдение 4-5 минут.
все что до этого уже не играет роли. пэтому я утверждаю что LA(1min) это некая средняя
по процессам за последние 5 минут. вот каков физ смысла LA(1min).
LA(5min) это средняя попроецессам за посоедение 25 минут. 
LA(15min) это средянн по процессам за посдегие 75минут.
когда я вгорворю средняя то это конечно не сосвем средняя. потому что у простой средней арифм
вест при каждом члеене=1 а тут у нас у первог члена вес=1  а остальных он все ниже и ниже.
такчто это некая извращенная средняя. опять же надо понимать что линукс собирает множество f(t)
только в точках через 5 секунд. все что просходит меджу этим точками абсолютно не попдает 
в поле зрения f(t) для LA. поэтому скажем если мы запустим хитриый процесс который будет
сильногузить проц в течение двух секунд каждые 2-3 секунды то такая нагрузка никогда не попадет
в поле зрения LA! тоесть что я имею ввиду. LA собирает показания r=f(t)  в моменты времени
t=0c,5c,10c,....
мы запускаем прогу которая будет грузить цпу ровно 1.5-2с а потом в ноль. какая то часть этой нагрузки
будет попадать в t=0c,5c,10c,.... а какая то нет! поэтому LA будет работаь только с частичным полем
нагрузки на комп. в ообще в любом случае так как LA берет точки через каждые 5с то все что просихдоит
с компом между этим точками аболстно нее попадает в поле зрения LA. если комп нагружен 
монтонно то это не проблема. а если комп нагружен сильно дерганно то LA будет собирать тоько
часть картины. это как дорожная камера. если она считает проезжабщие автомтобили но работает
не все время а только 0.5 каждые 5с. то эта камера насчитает только малую часть от всех
авто пробезажающих мимо этой камеры! также и сиутация с lA!
итак из всего множсетва исхоных данных в LA  попдает лишь малая часть. а значит кариину уже
искажается. во  вторых из тех данных что попали учитваются только данные за поледние 5 минут.
более старые члены уже неигарют роли. это происходит за счет того что веса убывают по экспоенете.
таким оразом lA высчтаеь  среднее за
    1) последние 5 минут
    2) делает это используя веса тоесть извращеным образом
    3) учитывает только малую часть данных за последние 5 минут
    
что еще важно понять. если мы изменим интрвал сэмлиорвания. тоеесть вместо 5с будем
брать данные кажые 2с то при неизменном коэфициенте у нас LA изменися! 
получается вот какая картина. у нас скажем в компе в течение  минут рабтает 1 процесс
непереставаая. если мы будем снимать дынне кажые 5с то у нас будет один LA (1min)
а если мы будем данные снимать каждые 2с то у нас LA полуитс совсем другой!
это как ? если бы мы приенили такой пдохдод для простгого среднего арифметичеоскогого
тооно осталось бы прежним. 

еще раз что такое LA - формально мы берем все значения r за весь период времени работы компа.
и вычисляем почти что среднее арифметиеское. но не совсем потому что формула такая
    ( w1*r1+w2*r2+...+wn*rn ) / (w1+w2+...+wn)
но тут начинаются приколы: во первых мы берем не все поле  r(t) а только часть 
при сэмплировании через 5с. а значит мы теряем часть картины. во вторых кожфициенты
падают по экспоненицальному закону и я посчитал что то как это сделано влиунксе 
коэф сколько нибудь отличаются от нуля только первые 4-5 минут. 
таким обрахом LA(1min) это некое извращенное среднее арифм высчитываемое на частичном поле r(t)
когдя  я говорю частичное я имею ввиду что во первых они взяты с шагом 5с. и второе что 
из за весов значение имеют только члены за последние 5 минут. таким обрзам LA(1min) 
это некое среднее арифетеичкое для r за последние 5 минут. и то при условии что r несильно
меняется в течение каждых 5-ти секунд. вот какой физ смысла LA(1min) на лиунуксе.

$$$$$








        
        
это отличная формула она позволяет высчитать Y для любого n
где n это порядковый номер f(n) и Y(n)




возьмем полный интервал времени 60с
и интервал сэмплинга пусть t0=5с
тогда k=1...12

пусть у нас  p=e^(-q)=e^(-1/12)
тогда

Y(12*5c)=C*(1-p^12)=C*(1-e^(12*(-1/12))=C*(1-e(-1))=C*(1-e(-1)) ~ 0.63* C* тоесть 63%

итак если у нас сэмплинг 5c если нагрузка постоянная и f(t)=Const=C если
начальный Y(0)=0 если коэфициент p выбран так что p=e^(-1/12)
то через 1 минуту Y будет равен 63% от C
            Y(60c)= C* 0,63 
            Y(60c)= C* 63%

            
а если t=60*5c то 
Y(60*5c)=C*(1-p^60)=C*(1-e^(-1/12)*(60)=C*(1-e(-5))=C* 99.3% 
тоесть на 5 мин мы достигнем 100% C

насколько я понимаю эту форуулму

Y(n)=a0 * e^n + a * (1 - e^n)

она говорит вот о чем. если  у нас в момент времени t(0) Y(0)=Y0
и у нас f(t)=Const  = C то y(n) у нас это 

Y(n)=Y0 * e^n + C * (1 - e^n)

тогда если у нас сэмплинг 5c/60c и и мы нахдимся в t=T то у нас
Y(T)=C* 63% + Y0* 37%

тоесть коэффициент p выбирается так чтобы при остуствии нагрузки
если у нас сэмлинг это t0/T то при достижении T чтобы у нас Y(T) стал 37% от Y0
я так понял. эту хрень.

вобщем же случае когда f(t) меняется это хрен посчитаешь. я имею ввиду чему будет
равен Y(T) в завимиости от Y(0) и f(T).
 
 в общем случае можно тольк то скзаать что Y(t)=p*Y(t-1)+(1-p)*f*(t)
если p=e^(-1/12) то тогда текущий LA это на 8% зависит от f(t) и на 92% зависиит от Y(t-1)




 
a3 = a2 * e + a * (1 - e)
 *    = (a0 * e^2 + a * (1 - e) * (1 + e)) * e + a * (1 - e)
 *    =  a * (1 - e) * (1 + e + e^2)
 
 
a[n]=a0 * e^n + a * (1 - e^n)









далее
в целом получется что у нас для LA(1min) за 1 минуту график предстелсвяет собой суму
двху процессов. с одной стороны график падает на 67% от высоты Y0 что был а потом растет на 67% от f(t)=C
тогда для первой минуты Y0=0, тогда 
Y(0+1) = (0-0.67*0)+0.67*C=0.67*C
для второй минуты
Y(1+1)=(0.67*C-0.67*0.67*C)+0.67*C=0.23*C+0.67*C=0.9C
для третьей минуты 
Y(2+1)=(0.9C-0.67*0.9C)+0.67*C=0.97C
для четвертой минуы
Y(3+1)=(0.97C-0.67*0.97C)+0.67C=0.33C+0.67C=0.99C
для пятой минуты
Y(4+1)=1.0*C

таким макаромы видим что если у нас Y(0)=0 и f(t)=const=C
то LA достигнет этого C через пятть минут.


это жначит что для LA(5min) как я понмаю он его достинет через 5*5=26  минут
а для LA(15min) он его достгнет через 15*5=75 минут (1ч15мин)

получетя в случе возросшшей нагрузки равномерной по времени нагрузке LA(1min) показывакт 
среднее число процессов за 5 минут. 
LA(5min) показывает среденее число процессов за 15min
LA(15min) покаызвает средене число процессов за 45 минут

если это нагрузка равномерная по времени и упавшая намрмпример она упала до нуля. 
то LA придует к нулю гораздо быстррее. дейсвтетльно
пускай было C и упало в ноль тогда
LA(0+1)= (C-0.67*C)=0.37*C
LA(1+1)=0.37C-0.67*0.37*C=0.13C
LA(2+1)=0.13C-0.67*0.13*C=0.09C
LA(3+1)=0.9C-0.67*0.09*C=0.06C
LA(4+1)=0.06C-0.67*0.06*C=0.04C
LA(5+1)=0.04C-0.67*0.04*C=0.03C
LA(6+1)=0.04C-0.67*0.04*C=0.02C




ИТОГО:
КОНЕЧНЫЙ ЭССЕ ВЫВОД РАСКАЗ ЧТО ТАКОЕ EMA НА САМОМ ДЕЛЕ:
выше я оставил весь путь изучения EMA. также в гит есть djvu
книжка тоже пропоиск что же такое EMA. лежит в 

~/git/docs/load-average/EMA-loadaverage-100.djvu

начну возможно c далека.
у нас есть банки с водой или батарейки. первое важное правило это они 
все одинаковые. это обязательно строго. они все строго одинаковые.
еще раз это очень обязательное условие.

так. ответ на вопрос - зачем в линуксе в качестве la испольщуется
не функция EMA а функция расхода q(t).
ответ вот почему - функция EMA она показывает сколько воды у нас щас
есть в банках в системе. но нам по факту обьем воды на практике неинтересен.
от знания его величины нам нет никакого толка.  что нам реально нужно 
на практике знать это значение q(t). потому что эта величина нам показывает
какой обьем энергии\воды будет за следущие 5с потрачен на полезную работу.
тоесть условно говоря какой обьем воды в кубометрах натечет из банок.
или сколько тепла выделится за следущие 5с. с точки зрения математики
функция q(t) особеннна тем что ее поведение (взлетит она на следущие 5с 
вверх или упадет или останется тойже) зависит в точности от следущего значения
r(t). тоесть если r(t+dt)>q(t) то новое значение q(t+dt) возрастет
а если r(t+dt)<q(t) то q(t+dt) упадет. это нам дает мгновнный интсрумент для 
качественной оценки как изменился r(t) по времени. например 

мы видим что q(t0)=1 через 5с мы видим что q(t0+5с)=1.3 так как q возрос
то мы сразу знаем что текущий r(t0+5с) он точно больше чем r=1

если мы видим что q(t0)=1 а через 5с мы видим что q(now)=0.9 то мы мгнвенное
получаем оценку текущего r(now) мы точно знаем что r(now)<1

если бы  в линксе использовалась ema в качестве la то из ее поведения невоможно
без мат вычислений налету пониать как меняется r(t)

еще одна причина почему в качесвет la в линуксе юзается q(t) а не ema
это потому что q(t) нам также налету позволяет получить оценку каков средний
r(t) за посление 5min, 30min, 90min. 
тоесть la1min=r_srednee (за 5мин).  la5min=r_srednee (за 30мин).
la15min=r_srednee (за 90мин).
единственное что расхожжждение между средним r(t) на указанных интервалах
и показаниями la будут тем лучше совпдаать чем у нас r(t) на указанных
интервалах имеет форму r(t)=const
если же r(t) на этих интервалах сущесвтенно отличается от r(t)=const
то тогда показания la будут офигенно отличаться от r_srednee.

в люом случае фунция EMA недает даже этого.

вот три причины почему в линуксе в качестве la испольщуется q(t) а не ema(t)


также с точеи зрения если бы r(t) был банками с водой или батрейками
то почему нас интерсует именно q(t) еще одна причина - показания q(t) полезны 
тем что они показыают какого размера батарейку надо вкинут в систему через 5с
чтобы 
    1) обьем полезной работы за следущие 5с оставался таким же.
      тоесть если мы будем вкидывать r(t) таким же как q(t) наша сисема
      станет энергетически стабилтной константой. и оьемп полезной работы
      который си теме выполняет стоже станет константой
    2) показания q(t) показывают такой бьем батарееек который надо вкнутт
      на данном этапе чтобы весь обьем этой батарейки ушел искчлюетельно
      на полезную работу. это тоже оень полезная иформация. 
      например у нас в системе 100 литров воды. и текущий q(t)=8
      это значит что за 5с вытечет 8 литров воды которая вращает жернов
      мелиницы. если мы вкинем в систему +8 литров воды. то за 5 следу
      щих секунд все эти 8 лиров воды уйдут на вращение колеса а не тупо
      на наполение самого резервуара сводой от которого надо толку 
      никакого.

тоесть если это конеденсаторня система. то нас мало интеерует
гафик напряжения на кондесанторе. нас инерсует график потери напряжения 
на конденсаторе за след 5 секунд. потому что по нему мы можем делать
оценки характера напряжения на батарее.  вот.

надо четко понимать что EMA показывает количество воды имеющееся в
системе щас. а q показывает сколько воды утечет из системы в течение следущих 5с



      
вот причины почему так полнзно смотреь на график q(t) по савренеию 
чем смотреть на гафрик ema(t)



$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


| ffmpeg
| mp3
как перекодировать файл с понижением битрейта.
    $ ffmpeg -v debug -i "input.file" -c:libmp3lame -b:a 32k \
             -ac 1 -ar 44100 -vn "out.file"
             
-ac 1 = это значит один канал моно.

в убунту бывает неставится ffmpeg  не резолвит депенденси.
тода ставим через aptitude. там тыкаем N. и предложит понизить версию
бибилиотеки. и наконец поставит

почему то вышеобозначенная команда успешно отрабоатла на убунту22
а на убунту18 послала нахуй. 
поэтому на убунту 18 сработала другая команда

 $ ffmpeg    -i rassel.mp3     \
             -codec:a libmp3lame    -b:a 32k  \
              -ar 44100    -ac 1     rassel-out.mp3

далее
как резрезать (split) mp3 файл на куски

$ ffmpeg -i rassel-out.mp3 -f segment -segment_time $((40*60)) -c copy out%03d.mp3

параметр -segment_time указывает время в секундах




| lxde
как сделать так чтобы размер курсора от мыши был большой.
идем в меню 

"preferences" - "customize look and feel" - "mouse cursor"
и выбираем тему DMZ White. фишка ее в том что она  позволяет задавать
разные размеры кусроров. а именно эта тема имеет доступные размеры: 24, 32, 48
однако  размер задается не через мменю.
теперь надо идти и править файл 

~/.config/lxsession/LXDE/desktop.conf

и в нем надо вот такое проставить

[GTK]
iGtk/CursorThemeSize=48
sGtk/CursorThemeName=DMZ-White


и сразу без перезагрузки мы получим новый размер курсора от мыщи.

теперь возникает вопрос - а как узнать доступные размеры для той или 
иной темы курсоров? ответ такой что по дефолту нихрена нету таких 
инструментов.  во первых где хранятся файлы курсоров 
        /usr/share/icons

причем эта папка хранит как просто значки. так и курсоры.
тему с курсорами можно отличить вот так - заходим в папку например 
/usr/share/icons/Breeze_Snow/cursors
и видим в ней cursors
это значит что эта хрень содержит именно курсоры.
так вот когда мы нашли тему с курсорами , которую можно подставит 
вот сюда "preferences" - "customize look and feel" - "mouse cursor"
но как я уже сказал нам надо знать доступные размеры курсоров для этой темы.
дело в том что каждлая тема содержит только определенные размеры.
например 24, 36, 48

так вот есть инстурмент который позволяет узнать доступные размеры.
но его надо комплириоать руками. тоесть
    - идем сюда   https://github.com/drizt/xcursor-viewer
    - качаем 
    - устанавливем пакет qt5-default
    - $ cmake .
    - $ make
получили бинарник xcursor-viewer
это оно и есть. запускаем. открыаеваем папку /usr/share/icons/
и он покажет для каждого курсора доступные размеры. гоча.

об этом прорчитал вот тут https://unix.stackexchange.com/questions/482367/how-to-get-the-available-x-cursor-sizes
а вот тут написано что через gimp можно создать новые размеры
для курсоров. только придется потрудииться изрядно
https://ubuntuforums.org/showthread.php?t=2492080




| lxterminal

полная хуйня.
его прикол в том что по неведомой причине когда в нем тыкаешь кнопки 
то между ними дикая пауза как бутто в резину все уходит.
я думал это чтото с компом. оакзаывает этопросто этот ебаный терминал

в xterm или в gnome-terminal такой хуйни нет!


     
================

| wg
| wireguard

как его запустить после перезагрузки компа

$ wg-quick up ~/wireguard/wg0.conf


$ cat  ~/wireguard/wg0.conf 
[Interface]
PrivateKey = 2222222222222222222222222=         # приватный ключ эттого компа
Address = 10.66.66.5/32                         # VPN LAN этого компа
DNS = 1.1.1.1

[Peer]
PublicKey = 3333333333333333333333333H0=        # публиый ключ удаленного VPN сервера
PresharedKey = 5555555555555555555555558=       # прешаред кей
Endpoint = 14.14.14.14:60805                    # WAN IP удаленного VPN сервера
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25


==========================







================
| gnuplot

удобная прога ртсовать графики если ему написать просто формулу
или подсунуть файл с цифрами

$ gnuplot
> plot x
> plot sin(x)

как сделать так чтобы сетка (grid) имела по оси  x  засечки чеерез нужные расстояния.
>  set xtic 10 
в этом случае засечки будут идти через 10
(замечу что xtic а не xtick!!!)

как сделать так чтобы цвет линий у сетки был заданный
вначале нужно определить стиль линии
> set style line 12 lc rgb 'blue' lt 1 lw 1
lw это толщина линии 
lt незнаю что это
12  это имя линии. именно по этому имени мы приклеим эту линию к сетке

вот так эта линия приклеливается к сетке
> set grid xtics ytics mxtics mytics ls 12

а вот так активируетется сама сетка
> set grid

а вот так рисуется график когда точки мы указали из файла
> plot  "data" using 1:2 title 'Processes number real' w linespoints lw 2,\
"data" using 1:3 title 'LA real' w linespoints lw 2,\
"data" using 1:4 title 'LA calc' w linespoints lw 2 ,\
"data" using 1:5 title 'Processes number average' w linespoints lw 2

этот граифик нриусует 4 линии. 
где
    "data" = это имя файла откуда читать точки
    using 1:2 = это означает что для этого графика нужно в файле брать второй столбик для координат Y
        (точки в столбике 1 автомтоматом беретуся для оси X)
    title 'Processes number real' = это названия графика
    w linespoints = это стиль линии  которой рисовать график. в данном случае это сплошная линия
        с наненсеннымми на нее точками
    lw 2 = толщина линии
    
таким макаром эта команда наиисует 4 графика


далее. как сделать так чтобы налету изменить данные в файле.
например. у меня точки x идут от нуля до нескольких тысяч. я хочу их смасшабирвать в формате 1:60
чтобы получить не секунды а минуты. это можно сделат ьвот так

>  plot  "data" using ($1/60.):4 title 'LA calculated' w linespoints lw 2


($1/60.):4 = этот кусок озанчаео что график строится так что по оси Y откладываются точки 
из 4-го столбика из файла "data" а по оси X откладываются точки с 1-го столбика причем
они на лету делятся на 60. охуенно!!!




 


================
| bc

с ним есть пролема.
он не умеет считат возведение в степень если степень дробная

$ bc <<< "2^3"
8
$ bc <<< "2^3.4"
Runtime warning (func=(main), adr=9): non-zero scale in exponent
8

но есть выход. если запутсить bc -l то он начинает понимать экспоненту и натуральный
логарифм. причем аргумент экспоенты может быть уже дробный

$ bc -l <<< "e(2.4)"
11.02317638064160165223

теперь нам всего навсего надо перейти от a^b к экспоненте. по формуле
    ( https://www.linuxquestions.org/questions/programming-9/bc-and-exponents-containing-decimals-and-fractions-755260/)
    
x=a^^b
ln(x)=ln(a^^b)
ln(x)=b*ln(a)
exp(ln(x))=exp(b*ln(a))
x=(exp(b*ln(a))

значит 2^^3.4 это e(3.4*l(2))

2^3.4 = 10,5560632862 (посчттал на калькуляторе)

считаем через формулу и bc
    $ bc -l <<< "e(3.4*l(2))"
    10.55606328618315407469

сработало

а еще есть мат пакет для убунту 
    # apt-get install octave
правда он раотает только в граф режиме. там можно всю математику считать

    
================
| proc

это файловая система которая позволяет из юзерского пространства получить доступ ( а procfs 
выствпает как шлюз как интерфейс) к kernel data structures.  тоесть можно полазить в ядре
из юзер пространства

===
bash
terminal

(оффтопик что такое командная строка шел. дело в том что есть пробема чтобы запустить программу нужна программа.)

вот такая программа есть

$ cat 31.c
#include<stdlib.h>
#include<stdio.h>
#include<unistd.h>

int main ()
{
 while (1)
 {
 sleep (5);
 };

return 0;
}


она неделает ничего кроме того что просто бесконечно крутится в цикле
никаких сисколлов кроме nanosleep в ней нет.

если мы ее запустим то просто будет пустой экран.
однако на этом экране можно наимать на кнопки и буквы будут отображаться на экране.

вот так:
$ ./31.exe


eqwe
qwe
qwe
	w
	w
	we
	q
ewq
w
r
we
rqw
er
qwer
qwer
w


вопрос - в выводе на экран этих букв какито сисколлы участвуют? как это работает?
выясним это :

в первом окне выясняем pid текущего баща.
(окно1) $ echo $$
30194

во втором окне подключимся через strace к этому башу
(окно2) $ $ sudo strace -f -p 30194
strace: Process 30194 attached


далее в первом окне запускаем нашу программу
(окно1)$ $ ./31.exe

далее возвращаеимся на второе окно и смотрим что там показыает
(окно2): 
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0

и больше ничего. и это реально так потому что наща программа ничего кроме nanosleep неделает.


возврашаеися на первое окно и начинаем тыкать кнопки.на экране появляются буквы
(окно1) $ ./31.exe
wer
ewr
ewr
wer
wer
we
rq
q
r
qer
qer
q
qwr

возврашаемся на второе окно и смотрим появились ли какието сисколлы которые наша програма бы начала юзать (что было бы странно ведь у нас в коде программы нет ничего больше) . или signals которые бы начали прилетать в наш процесс и прерывать его. и видим что ничего нет.
как и прежде на окне2 просто мы видим висящие нанослипы.  отсюда я делаю вывод что прием 
нажатия кнопок с клавы и их печать в окне терминала с моей программой это все вина ядра. это код ядра выполняет. как походу это работает. мы тыкаем кнопку на клаве происходит cpu hardware interrupt. он вызывает перрываение работы моей программы (если комп однопроцессорный)  и запускается ISR (interrupt service routine) котторая код ядра. эта рутина принимает нажатие кнопки 
и далее ( что самое интересное) делает вывод этой литеры на стандартный вывод процесса который крутится в текущем активном терминале. тоесть ядро как букву приняло оно смотрит на данный момент
есть ли активный терминал? есть. а терминала неможет быть без запущенного там хотя бы одного процесса. тогда ядро берет стандартный вывод этого процесса и посылает туда литеру и она появляется
на экране.

щас мы это проверим. запустим программу еще раз и начнем читать из стандартного ввода для начала
нашего процесса. тоесть проверим то что когда мы ввели буквы и ядро их приняло через интеррапт 
то посылает ли ядро эти буквы в стандартный ввод нашего процесса.

значит на первом окне я ввожу символы
(окно1) $ ./31.exe
qeqwewqeqeqweqweqwe
9123879283791839137912731

на втором окне я вижу !
(окно2) $ while :; do cat /proc/25418/fd/0; done
qeqwewqeqeqweqweqwe
9123879283791839137912731


рабтает это так. пока я просто ввожу символы в fd/0 ничего неприходит. но как только 
я нажимаю Enter то сразу прилетает строка в fd/0 

тоесть схема работает так: вот у нас открыт терминал на компе и там крутится процесс ( потому что 
открыть терминал и чтоб там ниодин процесс некрутился невозможно). так вот прием символов с клавы 
и печать их на экране терминала работает автоматичеки в линуксе без участия программы которая крутится в терминале вообще!

даже еще интереснее. я заупстил процесс и всего каналы 0 (который кстаи только на примем)
1 и 2 ( которые на вывод) направил на /dev/null

$ ./31.exe 0</dev/null 1>/dev/null 2>/dev/null

проеряем:
$ ls -1al /proc/25816/fd
total 0
lr-x------ 1 vasya vasya 64 мая 30 16:35 0 -> /dev/null
l-wx------ 1 vasya vasya 64 мая 30 16:35 1 -> /dev/null
l-wx------ 1 vasya vasya 64 мая 30 16:35 2 -> /dev/null

далее я тцкаю кнопки на экране
$ ./31.exe 0</dev/null 1>/dev/null 2>/dev/null
wqe
qwe
qwe
qw
e
qwe
qwe
qw
e

и они отображаются.
соответсвенно так как у процесса все каналы /dev/null то прием и отображение кнопок 
на экане никак несвязано нис процессом ни с его каналами. это все чисто автономная система от процеса и раотает исключиеотно через код ядра. и вобще то логично! - терминал это как жесткий диск
это уже как бы реальная железка (просто она виртуальная . это как виртуальный диск) вобщем
окно терминала это для линукса реальная железка а примом инфо от железки и отправкой байтов на реальную желеку делает ТОЛЬКО код ядра. (так же как чтение в файл на диске например делает толкьо код ядра а программа может лишь об этом просит ядро)тоеть в случае диска картина


программа write() --(просьба о записи)-----> код ядра ---(реальная запись на железку)---> файл на диске
программа read()  --(просьба о чтении)-----> код ядра <--(реальное чтение с железки)---- файл на диске

тоже самое для терминала. ксатти вспомниает что терминал железный это нетолько экран это еще и клава. такчто терминал = окно+клава
значит терминал это такая железка которая как бы в своем лице имеет два порта , один порт на прием
информации из мира и второй порт на отсылку информации в мир. как например сетевая карта.
и задача ядра в том чтобы принимать из принимающего порта когда туда чтото приходит и отправлять
в отправляющий порт когда туда юзерская программа хочет чтото записать. вот что такое терминал как железка с точки зрения ядра.  получается что терминал как бы имеет минимум один хардвейр интеррапт
означающий что на принимающий порт поступил пакет ( с клавы пришло нажатие). и ядро должно это 
нажатие обработать тоесть принять этот байт (нажатие) внутрь себя как сетевая карта принимает пакет снаружи и ядро его забирает внутрь.

получается тогда работает так:  у нас активен терминал. ядро это знает. (незнаю как но ядро это знает). мы тыкаем на клаве кнопку. происходит hardware interrupt посколку клава это железка и она точно имеет линию interrupt. срабатывает цпу интеррапт , цпу запускает ISR(который код ядра).
этот isr считывает нажатие в форме байта типа того и этот байт улетает куда то там в ядро в какйото буфер. (заметим что участия кода процесса нет здесь вообще и дальше его небудет).
что делать дальше с этим байтом с клавы ядру? ядро видит что на данный момент окно терминала активно. значит это как бы означает что сигнал с клавы прилетел как бы с клавы этого виртуального терминала (потому что если активного терминала открытого нет на экране а напримр просто есть пустой рабочий стол Cinnamon то ядро также принимает нажатия с кнопок c клавы тоесть ничего неменятеся но при этом ничего непроисходит потому что к виртуальному терминалу к его виртуальной клаве это событие неимеет никаого отошения). Так вот ядро понимает что это нажатие клавы его нужно соотнести с терминалом открытым. так что же делать? нужно делать то что указано в модуле\драйвере терминала. если бы терминал был реаьным физичеким устройством то нажатие клавы железного терминала всегды бы поступало в ядро и обрабатывалось бы драйвером железного терминала вот что там в драйвере было бы написано то бы ядро с нажатием кнопки и делало бы. так как у нас терминал виртуальный то нажатие кнопки в термиале просходит только тогда когда окно терминала открыто на столе и активно. это логично. окей окно терминала открыто на столе . мы нажали кнопку на клаве.
ядро считало байт. и оно отправило этот байт ну вот туда -  в драйвер виртуального терминала.
и драйвер вирт терминала так настроен что он выводит этот байт на экран терминала в форме литеры.
выводит чисто через ядерный код тоесть его работа нам вообще невидна. к коду процесса это неимеет 
никакого значения. если бы можно было бы иметь запущенный терминал без единого процесса то 
все работало бы точно также. мы жали бы кнопки и на экране появлялись бы буквы. я бы сказал что ситема раотает так . сигнал с клавы счиывает ядро по цпу интерапту и посылает в драйвер терминала.
если бы это был реальный железный терминал то я считаю что это работало бы так : нажали кнопку
сработал цпу интеррапт и ядро приняло через ISR байт через порт терминала который принимает 
сигналы с внешнего мира. далее драйвер терминала обрабатывает этот байт и ядро отправляет в порт 
записи терминала литеру и эта литера отображается на термиале на его окне.тоесть между 
вводом буквы с клавы и выводом на экран находится ядро которое принимает байт с одного порта
и послыает байт на другой порт

нажатие клавы запись в порт1--->  ISR(ядро) чтение из порта1 в буфер--> драйвер терминала(ядро) забирает из буфера к себе , обрабатывает и пишет в порт2 терминала --->  терминал читает из порта2 и рисует на экране литеру.

возможно железные термиыл были сделаны так что при нажатии на кнопку происходила запись в порт 
тоесть отсылка байта в удаленную систему и автоматическая (реализованная на уровне железа терминала) печать символа на экране ,таким образом линуксу на той стороне ненужно было писать в порт2 для того чтобы символ напечатался на экране.


итак еще раз открыто у нас окно терминала. мы нажали кнопку. кнопка на клаве. клава это железка.
железка иммеет линию интерапта к цпу. железка запускает интерапт. цпу прерывается и запускает
ISR (котоырй код ядра). ISR считывает байт из железки и передает его драйверу терминала (тоже код ядра)  (если окно терминала неактивно то считанный байт непердается драйверу терминала ибо данное нажатие кнопки неоотносится  к терминалу). драйвер терминала рисует на экране литеру. таким образом мы видим что принятие кнопок с клавы и рисование букв на терминале это процесс сугубо общение железки и ядра. процесс его код вообще здесь ни капли неучаствует. 
а когда же на сцену вылезает процесс ? а вот когда и как. когда мы открывает терминал
то драйвер терминала создает в системе устройство /dev/tty1 или /dev/pts1 неважно. будем для 
простоты считать что это одно и тоже. так вот процесс который запущен в линуксе и который запущен в терминале для этого процесса ядро автоматом создает\открывает три файловых дескриптора.
что нам дает если у процесса есть открытый файловый дескриптор ( причем при его открытии можно указать он для чтения для записи или для и того и другого). это дает то что из кода программы
мы можем через сисколлы read() write() мы можем писать и читать из этих файлов. тоесть для процесса
это каналы общения  с внешним миром на чтение данных и запись данных. бекендом файлового дескриптора может быть любая железка - жесткий диск, флэшка, звуковая карта, мышка, терминал(клава +окно), сетевая карта, модем. процессу вообще невидно и непонятно с каким железым утсройством он связан. для процесса это все неизвестно и прозрачно. для него это просто открытый поток\файл в который можно пиисать байты или читать байты. ( еще раз важно понять что терминал это прежде всего железка с портами на запись и чтение . с линиями интерраптов. такое же как у сетевой карты или звуковой карты. просто так совпало что что природа человеческая нечуствует неосязает интерфейсы жесктого диска или сетевой карты но мы способы взаимодействовать и осязать интефейсы терминала. пальцами мы взаимодейтвуем с кнопками а глазами  с экраном. у звуковой карты мы осязаем звук. звук у звуковой карты это как экран у терминала. с точки же зрения ядра это железки у которых есть порты на чтение и запись. а уже железка нам дает возможрость конвертировать байты от ядра прилетеврие в порт записи в звуки или картинку или нажатие кнопок от человека в байты для ядра котоыре к ядру летят через порт записи на терминале).  итак если есть процесс ядро может сделать автоматом а можно через сисколлы в программе открыть файл на чтение запись (канал связи) у котрого бекендом будет какая то железка. так вот можно открыть файл дескриптор куда процесс может писать и читать бекендом которого файла является /dev/tty1 тоесть железка терминал. так же как в команде 
dd мы юзаем файл /dev/hda для чтени запииси в железку жесткий диск.
что такое /dev/ папка. это такие файлы в юзер спейсе куда юзеркие программы открыв дескриптор
могут начать чиатть и писать. это такой слой виртуализации такой гейт между юзерской программой
 и железкой. тоеть /dev/hda или /dev/tty1 абстраигирует железку от юзерской программы.

 и тогда если программа пишет в дескриптор 1 и ( который она до этого окрыла через сисколл )
а у этого дескриптора бекендом является /dev/tty1 то байты из программы летят в /dev/tty1
и что дальше? то что летят они пока что в ядро  а не в железку. в специальный буфер.
далее в ядре вступает в действие драйвер данной железки он видит поступление данных в буфер
и уже начинает делать реальную подготовку обработку и low-level отсылку этих данных на уже непосредественно железку выполня всякие там хитрые low-level команды и действия которые нужно сделать чтобы этот поток данных реально засунуть на железку. фишка тут в чатности в том что 
для программы все универсально и легко.  ей похеру куда она пишет - в звуковую карту, в сетевую ли карту, в терминал, в жесткий диск ли. для программы это выглядит всегда одинаково исползуется единый универсальный сисколл вызов.
 write (1, .....)

а уже ос, ядро, драйвер ядра делает всю конкретную low-level работу.  это очень круто с точки 
зрения написания юзер программ. этакий слой софт виртуализации.

тоесть схема такая

процесс (юзер код) ----- сисколл write(1,....) ---> ядро драйвер ---- low-level железка dependent код ----> реальная железка 

где 1 --символическая ссылка на --- /dev/tty1

таким образом кстати вот эти /dev/ файлы это не то что прямое окно к железке. нет.  это входной
гейт в буфер на чтение и\или запист потока байтов  за которым прикреплен драйвер. 
а уже драйвер этот поток каким то образом несет или ненесет реально до железки.
юзерская программа как бы это баально незвучала прямого доступа в обход ядра не имеет до реальных
железок. всегда ядро стоит как посредник как от программы до железки так и от железки до программы

программа <---> ядро <---> железка

и так всегда.

получается ядро оно с одной стоороны выполняет роль секьюрити то есть дает доступ недает итп.
и с другой стороны являюется виртуализирующим слоем типа API скрывая всю low-level конкретику 
общение с железкой и предоставляя юзерской программе некие генерализованные функции\точки\команды
по общению с железкой. 
тоесть вот у на 100 видов сетевых карт. записать в сетевую карту байт для программы всегда будет 
выглядеть едино: условно write(1,.......) а уже ос ядро будет выполнять всю ту сложную работу  
с low level командами асемблера скажем по записи байта в сетевую карту.

возвращаемся к процессу и терминалу.
значит открыли мы терминал. ядро драйвер вирт терминала создает в /dev/ устройство /dev/pts/16 или /dev/tty1 предоставляющее гейт для доступа юзерским программам  к этой железку.
внезависимости от процесса  ядро чеерз драйвер принимает нажатие кнопок от клавы когда 
термиал активен и ядро автоматом рисует в окне терминала принятые с клавы кнопки. и при этом происходит еще один очень важный штук. когда мы нажали кнопку и драйвер терминала ее принял
то помимо отрисовки этой литеры на экране драйвер терминала делает еще одну очень важную вещь
он записывает этот байт в /dev/pts/16 в файл который отвечает за терминал в юзерском пространстве.
зачем он это делает. а делает он это затем чтобы нажатие кнопки поступило нетолько в ядро но и было  продублировано и стало доступным юзерской программе. так как юзерская программа может 
читать из файла /dev/pts/16 . тоесть до этого мы видели исключетельно общение ядра и железки в обе стороны а юзерской программе было непрорваться к железке. и вот наконец ядро смилостивилось и 
получив байт с кнопки оно нетольько  свои дела делает (рисует литеру на экране) но и через файл
доступный для юзер спеейса дублирует туда это байт. 

схема
																																						код ядра отрисовка литеры в окне терм
                                                                           /
кнопка клавы при открытом терминале нажали  -----> ядро --> драйвер ядра->/
 																																				  \
 																																				 	 \ядро запись в /dev/pts


и далее

программа <---- read(0,...) --- /dev/pts

таким образом мы видим каким же образом у процесса юзерского появляется
возможность тоже получит доступ к байту с кнопки железной клавы.
только из за того что ядро кладет полученный им непосредственно с железки байт
в доступный для юзера файл.

также видно что отрисовка на экране идет автономно от 
файлов /dev/pts.  

как же программе считывать с /dev/pts ?
а вот как. программа вначале делает сисколл на открытие файла.

fp = fopen ("/dev/pts/4", "w+");

далее в fp ос возврашает дескриптор. (0,1, 2, итп)

и потом имея этот дескриптор можно через сисколл писать туда

fprintf(fp, "%s %s %s %d", "We", "are", "in", 2012);

также через write(0,....)
насколько я даже щас понимаю что скорей всего fprintf это libc wrapper для сисколла write()


таким образом любой процесс если откроет /dev/pts/4 
может туда писать. при этом в /proc/pid/fd  у процесса будет появлсяться файловй дескпритор
с бекендом /dev/pts/4
если у процесса есть файовй дескриптор  у которого на бекенде файл овтечающий за терминал железку
/dev/tty или /dev/pts то говорят что процесс работает в термиале или прикреплен к терминалу.
вот что значат эти загаочные слова работае в терминале прикреплен к терминалу. всео навсего 
то что процесс открыл файл на чтение запись бекендом которого явлется железка терминал.
таким же макаром если процесс пишет щас на жеткий диск то мжоно говорить что процесс прикреплен к
 жесктому диску или проесс работе в диске. но конечно загадрчнее и понтовее гвоорить что процесс
 работает в терминале или прикрелеен к терминалу.
 процесс работает на цпу вот где он работает. а в терминал железку он пишет или читает. вот иввсе
 вот и весь выебон и понты наведенные вокруг этого.  причем сам процесс и незнает куда он пишет
 на жесктйий диск в звуковую карту или в терминал потому что для процесса это все абстрагировано
 через единую форму

 fprintf(fp, "%s %s %s %d", "We", "are", "in", 2012);

 в любой момент процесс может закрыть этот дескриптор и открыть заново.

 причем по факту процесс всего навсего пишет в файл. и только то. а уже драйвер этого спец файла 
 из /dev/каталога реально пишет или читает с устройства.

 так что в терминале реально работает толкьо ядро. но никак не процесс. ха-ха-ха.

 поэтму становистя понятна наша исходная кратинка
о том что мы запустоли программу которая вообще никак неослуиживает ни клаву ни экран.
 а при этом у нас работает печат букв на экране терминала. 

 $ ./31.exe
wer
ewr
ewr
wer
wer
we
rq
q
r
qer
qer
q


процесс к появлению букв на экране и к приему кнопок с клавы неимеет никакого отношения.!
это все делае автономно ядро драйвер терминала.

все что происходит с процессом при команде  $ ./31.exe то что связано с терминалом это всего
навсего вот что:

ядро автоматом открывает три файла для процесса когда оно его создает
/proc/pid/fd/0 --> /dev/pts/4
/proc/pid/fd/1 --> /dev/pts/4
/proc/pid/fd/2 --> /dev/pts/4

вот это все что связывает процесс с терминалом. всего навсего ядро автоматом 
открывает три файла с бекендом на /dev/pts/4.  любой процесс после запуска при своем 
желании может это сделать и сам самостоятельно! ничего тут такого особого нету!
тоесть можно запустить программу и не в окне этого терминала ( например в окне терминала /dev/tty1) и при этом открыть файлы с бекендом на /dev/pts/4
что это даст? это даст то что когда мы будем сидеть в терминале /dev/pts/4 и нажимать кнопки
то процесс запущенный в /dev/tty1 будет принимать эти нажатия кнопок.

пример:

вот у нас открыт терминал /dev/pts/4

(окно 1)$ tty
/dev/pts/4


мы запускаем программу которая никак с чтением с кнопок неработает. просто пустой цикл while
и мы вводим в терминале буквы "wer"
(окно 1)$ ./31.exe
wer

а в другом окне другом терминале мы зарнее запускаем другой процесс который читает /dev/pts/4 
тоесть тот файл в который ядро дублирует нажатие кнопок с клавы и откуда уже может чиатть любая желающая программа

$ cat  /dev/pts/4
wer


и вуаля мы видим что в первом окне мы ввели wer и их отрисовало само ядро. без участия 
юзерской программы 31.exe

а во втором окне мы тоже видим wer который считала наша юзеркая программа которая незапущена в 
окне терминала (окно1) прочитала из /dev/pts/4 куда ядро кладет нажатия кнопок с клавиуатуры
терминала (окно1). 

вопрос а если десят процессов поставить читать из /dev/pts/4 то как оно будет ? какой процесс будет
получать нажатия кнопок? ответ - они все будут конкурировать. и рандомно то один процесс
будет показыват нажатую кнопку то другой процесс то третий. ибо как это будет работьа


команда cat  /dev/pts/4; 

если через strace помсмотеть она исполтзует read() сисколл.
если мы запустим в неколльких онках этот cat то рандомно то в одном окне то вдругом
(они будут конкурирова)  будет повявятся то что я буду печаать в окне1.
я проерил так и есть.

(забавно что можно открыть на чтение файл сразу нескольким процессам. а с другой стороны а почему
бы и нет).

так вот получается еси мы заупстили программу в окне терминала она ничего не лучше
других программ которые небыли запущенв в терминале в плане возможнсотй чиатть с этого терминала
и писат в этот терминал! единвтеное это то что ядро при создании процесса заупденного в окне 
этого терминала автоматом откроет три дескпритора от данного терминала. так что коду проесса этого длеать самому руками ненужно вот и все. но процесс незпуеннй в терминале может это сделать точно также только руками. вот ивсе.  а дальше процесс если хочет то он читает пищет в дескприорторы а если нехочет то и непишет. вот и все.! ну и еще такой момент что еси мы в терминале жмем Ctrl+C
то ядро шлет SIGINT процессу который был открыт в терминале ( вопрос как ядро отличает какой процесс было запущен в этом терминале а какой небыло а простооткрыл руками дескприоры темринала?)

так что теперь мы четко поняли. терминал это штука сама по себе. а процесс эта щтука сама по себе.
 и единсвтенное что меду ними может быть тонкий мостик  через /dev/pts и ядро между ними.
 а так это абсолютно разделенные сущности. а не какието неразделимые сиамские близнецы. нет такого 
 что процесс прям приращен к терминалу. такго нет вообще. 

 темринал живет сам по себе его обеспечивает и с ним напрямую говорит только ядро. 
 а процесс находится совершенно далеко в другой корзине.   и между етрминалом и процессом есть 
 тонкий телефонный мостик это ядро и файлик /dev/pts/4
 по факту с точки зрения программы ее связывает с терминалом только файлик (чтение запись) /dev/pts/4 это тоже само что любого человека свзыввает с магазином в америке только то что в телефоне
 человека есть номер этого магазина по которому можно позвонить. а когда процесс запускается
 в окне терминала это как то что ядро у человека телефоне при покупке телефона автомтом а адреной
 книжке записало номер этого магазина. вот и вся связь между магазином в америке и человеком на в африке.

 еще раз про то как происходит печать на окне терминала.
 если ядро хочет там печатать то оно печатает через свой код драйвер терминала.
 если процесс хочет печатать на окне терминала это это тоже самое если процесс хочет писать на диск
 тоесть сам процесс никапли это неможет делать. он должео поросить ядро  а оно уже может быть
 это сделает. как попросить - процесс должен сделать запись в /dev/pts/4
 тогда ядро его дравер терминала возьмет этот поток байтов из буфера и уже сделает low level 
 работу и дейсвительно пошлет на терминал и напечатает. когда самое ядро по своему желанию 
 печатает на терминале например в случае убианеим пороцесса по SEGFAULT то ядро непишет в /dev/pts/4 для этого. ему это ненадо. /dev/pts/4 это гейт для запроосов от юзерских порграмм.
 само ядро пишет на термиал напрямую. /dev/pts в этом вобще нучаствует когда ядро пишет на терминал.

 далее еще нюанс. команда cat читает из файла терминала через сисколл read()
проверяется легко
$ strace cat


 в чем его нюанс в  том что пока мы ненажали на enter в окне терминала в cat ничего неприлетит.
 так раотае сисколл read походу

 а вот bash читает из файла термиала через ддругой сисколл pselect6()
 это дает то что баш видиит получает в свои недра уже отдельный символ и нажатия на enter 
 уже абсолютно ненадо. 

 к чему это ведет. к  очен иенересуному результату.

 (окно1)$ tty
 /dev/pts/16

значит в окне 1 запущен bash который все время работает в pselect6()

 (окно2) cat /dev/pts/16

 тоесть во втором окне мы как и раньше воруем то что вводится с клавы в окне 1.
 так вот что непонятно.
 я сижу в окне 1 и ввожу на клаве (без enter)
 1234567890

 при этом в окне 1 непоявляется ни одна цифра кроме последней 0
  а все прердыдущие появляюстя в окне2
  тоесть

  (окно 1) $ 0

  (окно 2) $ $ cat /dev/pts/16
123456789

во первых уменя вопрос почему раньше нам нужно было в окне 1 вводить enter чтобы цифры появились в окне 2 а щас этого делать ненадо. а во вторых самое интереное почему  у нас в окне 1 нет цифр 123456789 если за их отображение отвечает ядро а не баш процесс?
( также упомояну по ходу что в ядре есть два селекта select и pselect6)

мне в этой истории непонтно почему кнопка нажимаемая а окне1 неотображается в окне1
то что она воруется на окно2 это окей (хотя и без enter) а вот почему она неотображатеся
в окне1 непойму. есть пока только одно предположение что баш юзает сисколл 

pselect6(1, [0], NULL, NULL, NULL, {[], 8}

который каким то образом влияет на драйвет терминала? по мне это херня вобщето.
хотя сисколл pselect6 это тоже ядерный код  как и драйвер терминала но он же всего навсего
работает с ... файловым дескриптором... кхмм... ну незнаю.. 

еще какой эксмеримент я сделал. 
язапустил баш вместе с strace в окне1 и начал нажимать кнопки.
четко видно вот что 

вот запустил баш. на экране такое окно1:

(окно1)$ 
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

начинаю нажтмать кнопки
если кнопка непрошла. если ее "перехватил" процесс в окне 2 то на окне1 ничего непросходит.
(что меня и непонятка вызывает).

а если кнопка прошла то мы видим в окне1:

(окно1)$
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, 

если еще одна конопка прошла то видим в окне1

(окно1)$
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, "1", 1)                         = 1
select(1, [0], NULL, [0], {tv_sec=0, tv_usec=0}) = 0 (Timeout)
write(2, "1", 11)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

а вот как выглядит стрейс баща коода мы неворумем символы из окна2

(окно1) $
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, "1", 1)                         = 1
select(1, [0], NULL, [0], {tv_sec=0, tv_usec=0}) = 0 (Timeout)
write(2, "1", 11)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {[], 8}


вроде вывод тот же самый. просто во втом случае движуха по сисколлам иидет при каждом
нажатии кнопки. а впервом случае жмеш кнопки а на экране ничего неменяте ся в плане 
сисколлов.

еще меня смущает что читается один байт
read(0, "1", 1)

а пишетс очемуто бащем 11 байт
write(2, "1", 11)
зачем 11 почему 11?

причемя я проверил уб баша все три канала 0 1 2 ведут на один бекенд

 0 -> /dev/pts/16
 1 -> /dev/pts/16
 2 -> /dev/pts/16

такое ощущение что когда бащ стартует то он (хотя звучит как бред)то он просит драйвер 
терминала невыводить автоматом нажатые кнопки на окно терминала.  а делает это сам 
при условии что он (баш процесс) считал этот символ из /dev/pts/
тоесть да вот реально. как бутто бащ кода стартует то он просит драйвер терминала
не дублировать принятые символы автоматом на экран. мол бащ будет сам этим заниматься.

кхм...
кстати там же есть драйвер терминала а есть типа тип терминала который исользуется прям щас в
этом окне терминала
$ echo $TERM
xterm-256color

вобще по терминалам нужно читать Digital VT220 Programmer Reference Manual - VT100.net
кстаи я думал что линукс драйвер терминала эмулирует vt200 а окаызется vt100,

так вот там я нашел такую штуку:

4.6.5 Send/Receive Mode (SRM)
Send/receive mode turns local echo on or off. When send/receive mode is reset (local echo on), every character sent from the keyboard automatically appears on the screen. Therefore, the host does not have to send (echo) the character back to the terminal display. When send/receive mode is set (local echo off), the terminal only sends characters to the application. The host must echo the characters back to the screen.

You can set or reset send/receive mode as follows.

Mode	Sequence	Action
Set	
9/11 3/1  3/2 6/8
CSI   1    2   h
Turns off (disables) local echo. When the terminal sends characters to the host, the host must echo characters back to the screen.
Reset	
9/11 3/1  3/2 6/12 
CSI   1    2   l
Turns on (enables) local echo. When the terminal sends characters, the characters are automatically sent to the screen.

тоесть терминал может автоматом рисовать на экране символ который мы послаи с клавы а может и нет.
что значит эти загадочные сиквенсы я незнаю но я нашел как бурать local echo 
другим способом

$ stty -echo

тогда да. все что пеаатаешь  - ничего на экране непоявляется. но по факту баш его видит. 
так вот предположение может баш при старте делает какито особые натройки текущего экрана 
терминала... тоесть

вот я сдеал 
$strace stty -echo
ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0
ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {B38400 opost isig icanon -echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon -echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon -echo ...}) = 0

тоесть походу через ioctl можно 
что такое ioctl это такой сисколл через который юзер программа может послать параметры на железку
(через ядро конечно) который специфичны для данной железки и которые нельзя послать другими обычными сисколлами. тоесть этим сиколом можно как бы лазить под капотом в конкретной железке
через юзерскую программу.

итак ioctl позволяет считывать настройки терминала тоесть линукс термина драйвера
и также подкручивать их. возмжоно вэтом и есть секрет.
баш старует . через ioctl подкручивает насйтроки текущего термиала  и поэтому мы видим такое 
повдеение.

через libc ioctl_tty wrapper 
можно указывая наш /dev/tty1 устройство можно у него подкручитваь его найтсройки. тоесть 
как я понимаю ядро кога создаем новый терминал то его свойтсва как железного устрйоства ядро
подкручитвает по дефолту. а мы можем через ioctl указывая /dev/tty1 подкручивать в нашу сторону.

получается через read() write() можно делть общие оперции с устройсвами в виде файлов
а с помощью ioctl() можно делать спеицифичекие для данной железки операции. тоесть ели бы мы работали с принтером. то read() write() это общие сисколлы для всех принтеров для общих оперции
чтени записи а ioctl можно былло бы юзать из юзеркой процеграммы чтобы делать настйроки принтера.
типа того. тоже самое для терминалов. таким макаром через ioctl можно подкручиват драйвер терминала
в ядре для конкретного нашего открытого окна терминала. вот походу баш это активно и делает при старте.

попробуем для начла считать настройки терминала через ioctl_tty

$ cat 42.c
#include <stdio.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <fcntl.h> // for open
#include <unistd.h> // for close
       int
       main(void)
       {
           int fd;
           struct termios tio2;

           fd = open("/dev/pts/16", O_RDONLY);
           ioctl(fd, TCGETS, &tio2);
           close (fd);
       }



 $ strace ./42.exe
 ioctl(3, TCGETS, {B38400 opost isig -icanon -echo ...}) = 0

отработала успешно. 

 что такое struct termios в коде 42.c

 смотрим

 $ cat /usr/include/bits/termios.h | grep struct -A 20
struct termios
  {
    tcflag_t c_iflag;		/* input mode flags */
    tcflag_t c_oflag;		/* output mode flags */
    tcflag_t c_cflag;		/* control mode flags */
    tcflag_t c_lflag;		/* local mode flags */
    cc_t c_line;			/* line discipline */
    cc_t c_cc[NCCS];		/* control characters */
    speed_t c_ispeed;		/* input speed */
    speed_t c_ospeed;		/* output speed */
#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
  };


еще смотрим
$ man termios 


ухты !!!!! получается  я напоролся еще на одну БОЛЬШУЮ тему (помимо signals , interrupts итп) - а именно драйвер терминала!  в книжке по libc это глава 17 - Low-Level Terminal Interface.


A struct termios records all the I/O attributes of a terminal.


вот такую программу частично я взял с сайта IBM

$ cat 43.c
#define _POSIX_SOURCE
#include <termios.h>
#include <stdio.h>
#include <unistd.h>

int main(void) {
  struct termios term;

  if (tcgetattr(STDIN_FILENO, &term) != 0)
    perror("tcgetatt() error");
  else {
    if (term.c_iflag & BRKINT)
      puts("BRKINT is set");
    else
      puts("BRKINT is not set");
    if (term.c_cflag & PARODD)
      puts("Odd parity is used");
    else
      puts("Even parity is used");
    if (term.c_lflag & ECHO)
      puts("ECHO is set");
    else
      puts("ECHO is not set");

    if (term.c_lflag & INPCK)
      puts("INPCK is set");
    else
      puts("INPCK is not set");

    if (term.c_lflag & IGNBRK)
      puts("IGNBRK is set");
    else
      puts("IGNBRK is not set");




    printf("The end-of-file character is x'%02x'\n",
term.c_cc[VEOF]);
  }
}

выволд на экран:
BRKINT is not set
Even parity is used
ECHO is set
INPCK is set
IGNBRK is set
The end-of-file character is x'04'

интересно..

(офф топик)
про puts и printf.  в чем разница. printf понимает символы форматирования а puts типа более простая
программа которая их непонимает. плюс puts в том что если мы незнаем будет ли у нас в переменной
символы форматирования то безопаснее юзать puts. примерно так судя по стековерфлоу.

из man puts:
 int puts(const char *s);
из man 3 printf:
 int printf(const char *format, ...);

еще полезняшка можно используя gcc получать нетолько .exe бинарник но и файл с ассемблером
чтобы недизассмблировать пример

$ gcc -o printf.exe printf.c -save-temps -masm=intel
тогда файл с кодом асемблера будет храниться в 
$ cat ./printf.s

еще момент. 
переменные в теле функции по крайней мере часть из них она размещается в стеке.
когда идет выход из функции то доступ к локальным переменным функции теряется. кактотак.
потому что все что в стеке то живет дышет меняется и движется.

(конец оффтопик)



а вот что делает баш при старте с настройками терминала. 
я использовал в strace флаг -v и смогу увидеть ioctk строки целиком необрезанные

$ strace  -v -e clone,ioctl bash

ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(2, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCGPGRP, [8315])           = 0
ioctl(255, TIOCSPGRP, [8317])           = 0
ioctl(255, TIOCGPGRP, [8317])           = 0
ioctl(255, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f07117c4490) = 8318
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=8318, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f07117c4490) = 8323
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=8323, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
ioctl(1, TCGETS, 0x7ffd59701040)        = -1 ENOTTY (Inappropriate ioctl for device)
ioctl(2, TCGETS, 0x7ffd59700fb0)        = -1 ENOTTY (Inappropriate ioctl for device)
ioctl(255, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCSPGRP, [8317])           = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0
ioctl(0, TCGETS, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


ксати видно что баш при старте еще создает парочку детей которые потом подыхают.

из man ioctl_tty вижу что

 TCGETS    struct termios *argp
              Equivalent to tcgetattr(fd, argp).
              Get the current serial port settings.


таким образом строки с TCGETS они нас неинеретсуют  ибо нас инерсуют строки которые меняют
дефолтовые настройки терминала.

тогда остаются строки

ioctl(255, TIOCGPGRP, [8463])           = 0
ioctl(255, TIOCSPGRP, [8465])           = 0
ioctl(255, TIOCGPGRP, [8465])           = 0

ioctl(255, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0

ioctl(255, TIOCSPGRP, [8465])           = 0

ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0

ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


причем я думаю что реально значение имеет последняя которая с SNDCTL_TMR_STOP or TCSETSW

сравним ее с теми анстройками которе есть изнаально утерминала

ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0

итак было:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

стало:
{c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}

разница реально есть.


сравним что делает xterm+./31-1.exe(самописная програма которая ничего неделает) при старте. видно что xterm  вызов SNDCTL_TMR_STOP or TCSETSW неиспольует (как баш)
и в итоге у терминала настройки выглядят так:

{c_iflags=0x500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

сравним с дефолтовыми

{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

они почти неотличаются. только вот этим флагом - c_iflags

так что я пока вот думаю что тот факт то когда мы запускаем хоть гном-терминал + 31-1.exe хоть xterm+31-1.exe потом мы ее стопим через -19 сигнал и при этом буквы на экране попрежнему можно вводить они работают.
а вот если мы берем баш и запускаем хоть bash хоть в xterm хоть в gnome-terminal то стоит 
нам баш застопить через -19 сигнал и уже нажатие кнопок непечатает на экране. тоесть как бутто получается что гажатие кнопок на экране обслуживает баш процесс что противорчечит тому что мы ране
писали что нажатие нокопок и печать на экарне осуживает ядро. так вот пртирворчения нет дело в том
что баш коода стартует он посылает в терминал (железку ) управяляющие команды которые 
в нем чтото пееркоючюат от дефолтовых настроек и он начинает печатать буквы только если условно 
говоря как я понимаб только при условии что баш их принял. а раз прцесс стоит то и наэаране пусто.

чтобы это доказать надо расшифровать строку


ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


двигаем дальше на чем бы мы ни закончили.
мы будем говорить о том же самом только может быть немного с другого примера:

команда kill.
я с ней игрался. я запустил ее в том же окне что и баш

$ kill -19 $$

и я ожидал что также как вслучае голого баша что после этого окно терминала перестанет
печатать символы при нажатии на кнопки. однако это на удивление оказалось нетак.
я начал разбираться. я думал что что баш отфоркает себя. запустит килл. килл остановит баш.
закончит свою работу (правда оставшись зомби ибо код возврата стоячий баш прочитать неможет ибо 
шедулер незпускает хендлер у стоячего процесса). но поскольку килл неменяет настройки терминала я полагал что экран терминал "зафризиться". ан нет. окей. я запустил всторенный в баш kill он там
тоже есть оказывается. тоесть при его вызове никакого форка непроисходит команда работает прям из процесса баша

$ builtin kill -19 $$

однако эфект был прежний. экран незафризился.
ответ оказался (забегая вперед) логичным баш при запуске команды даже если она встроенная
он сбрасывает настроки терминаола (через ioctl) в дефолтовые настройки. там что этим все и обьясняется. теперь длинное обьяснение: 

у баша есть встроенный kill тоесть ему ненужно форкаться и юзать /bin/kill
он может сразу сам из себя из своего процесса это сделать. я думал что баш 
единственная проблема в том что
по дефолту баш почемуто юзает не свой builtin kill а внешний /bin/kill
как заставить баш юзать всегда свои билтины я пока незнаю. но можно bash заставить
персонально выполгить именно builtin а не внешний файл.

(окно1)$  builtin kill -19 $$

так вот моя идея была в том чтобы остановить баш причем через встроенную команду kill 
в том же окне где крутится баш. я думал что это приведет к тому что печать кнопок на экране
прекратится как она прекращается если остановить баш из другого окна. однако я был удивлен
что если остановить баш из того же окна с помощью builtin kill (тоесть баш себя нефоркает и минимальные телодвижения делает по сисколлам в этом случае) то при этом печать символов на экране
работает! в чем же прикол. я затрейсил баш из другого окна и увидел что во время даже
запуска builtin команды ( тоесть без форка) баш производит изменнеие настроек терминала!(казалось бы зачем?)

(окно2)$ sudo strace -v -e ioctl -f -p 10396
strace: Process 10396 attached

ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0

сравним настройки котоыре бащ выставляет перед запуском builtin и дефолтовые настройки
терминала

изменнеые:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

дефолтовые:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

(как получить дефолтовые - достаточно запустить бащ в новом окней через strace и взять первый 
ioctl TGETS)

гоча! совпадает! значит баш когда форкается для запуска внешнего бинарника или когда баш даже 
выполняет свой встроенный builtin ( тоесть другими словами когда мы набрали коману в строке 
приглашения в баш и тыкаем enter на ее исполнение и неважно она встроенная или это внешний файл) то он когда команду запускает что мы набрали он изменяет настройки терминала на дефолтовые.
опишу дефолтовые настройки терминала которые для нас имеют значение:
	а) если мы вводим буквы с клавы то активирована опция local echo и терминал то что мы ввели с клавы сразу дублирует на экране (если local echo выключен то терминал принимает наши кнопки с клавы и сохраняет их в свой внутренний буфер ) 
	б) набранные буквы терминал шлет в линию в /dev/pts только после нажатия Enter. 

Вот на эти настройки баш сбрасывает термиал когда мы в строке баша запускаем команду.
А когда выпонение команды закончено и управление возврашается к процессу баша (когда мы снова можем набирать команду в строке) то баш снова меняет настройки терминала на кастомные. они имеют два важных последствия: 
	а) если мы нажали на кнопку в терминале то нажатие воспринимается но на экране символ непечатается (режим local echo off). 
	b) терминал шлет в /dev/pts (в линию) букву как только она была нажата ( а не когда был нажат Enter. тоесть в дефолтовом режиме мы вводим строку и она лежит целиком в памяти терминала и неотправляется в /dev/pts до тех пор пока мы не введем Enter а в кастомном режиме кторый баш задает как только ударли по букве на клаве терминал мгновенно отправляет байт о букве в /dev/pt поэтому в дефолтовом режиме данные приложению (башу или другому) попадают только в форме строк целиком а в кастомном баш режиме данные летят в /dev/pts к внешнему приложению мгновенно побуквенно.  )

В кастомном режиме терминала (что задает баш когда мы находимся в режиме ввода командв командной строке) чтобы буквы печаатались на экране баш должен их отправлять в /dev/pts только тогда буква
печатается на экране. баш так и делает. как только он получает букву через /dev/pts он тутже вызывает сисколл write(2,) и печататет эту букву на экране. 

для нас конечно оба эти режимы в конечном итоге выглдядят одинаково но в том то и дело что 
под капотом они рабоают совсем по разному. вот это вылезает когда мы стопим баш в терминале
и у нас пропадает печать наших букв в окне терминала или если мы стопим какоето другой процесс
в окне терминала и у нас при этом буквы отлично печатаются на экране. вот она разгадка!!


итак еще раз: у нас есть терминал.  это желещка как жесткий диск или видеокарта и чтобы с ним работать нужен драйвер код в ядре. у нас терминал виртуальный но это особо роли неиграет 
он для ядра остаетая такой же железкой. терминал это клава и экран в одной железке. когда  у нас
окно терминала активно то ядро "маунтит" нашу реальную клаву в виртуальную клаву от терминала другим словами нажатия от кнопок летят в драйвер терминала. и по поводу экрана  - когда мы шлем 
данные в терминал ( об этом щас поговорим) то драйвер терминала шлет буквы в графическое окно
на физическом экрана ноутбука. для юзерского процесса связь с терминалом идет через /dev устройство ( также как есть при связт юзерского процесса с лююбой другой железкой. связь всегда идет через /dev устройство). для принятия нажатия кнопок процесс читает из /dev/pts а для 
печати на экране процесс пишет в /dev/pts. тоесть для программы  процесс  работы с терминалом
это чтение или запись в /dev/pts файл. между файлом /dev/pts и железкой(терминалом) находится ядро. оно принимает данные из терминала и пересылает их в /dev/pts и оно же принимает данные из /dev/pts и шлет их на терминал. в этом роль ядра. железка же (терминал) получив данные от ядра 
делает уже непосредственную печать на экране железки(терминала) тоесть железка трансформруем полученный поток байтов уже в физические символы на физическом экране. и здесь как видно что ядро только передает данные на железку и все а за само отображение на экране отвечает уже неядро а сама железка. и тоже самое про клаву железка принимает и транформирует механическое нажатие клавиш в поток байтов которые железка(терминал) уже шлет в ядро ( а ядро в /dev/pts чтобы приложение в юзер спейсе увидело получило). Таким образом работа с клавой и преоброзвание кнопок в поток байтов это не ядро делает а сама железка. ядро лишь принимает поток байтов. и еще важно что при желании 
можно подкручивать настройки железки. это все приводит к тому что мы можем настроить чтобы железка неслала в ядро нажатые кнопки пока ненажат Enter или наоборот чтобы железка мгновенно слала в ядро каждую нажату кнопку. Это все настройки самой железки. не ядро. ядро здеь неучаствует. также видно что и программа (баш например ) к этому неимеет никакого отношения. это все настройки самой железки. также можно настроить на железке чтобы нажатая кнопка сразу дублировалась на экране а можно настроить наоборот что нажатые кнопки небудут печататься на экране. Поэтому очень важно понимать что в случае "баш работает в черном окне терминала" у нас три компонента участвуют а выглядит все это как нечто единое. 

	bash ---- ядро ---- терминал (железка)   

каждый компонент играет свою роль. 

важно понимать что bash работает в юзерспейсе и непосредственно с терминалом невзаимодействует а делает это через ядро а конкретно через файл /dev/pts/x

	bash(user space) ---/dev/pts/x--- ядро ---- терминал

поэтому между нажатием кнопки на клаве на терминале и тем что это нажатие долетело до баша
должна произойти целая серия событий.
тоже самое между посылом байта из баша и отрисовываеием литеры на экране терминала должна
прозойти целая серия событий.

поээтому происходит целый ряд событий целый оркестр с момента как мы нажали кнопку на клаве
и как она отрисовалась (или неотрисовалась) в черном окне терминала с приглашением от bash

опять же хочу заметить что для терминала нажатие кнопки и отрисовыванием символа на экране
это в целом два независящих события поэтому если мы хотим чтобы они происходили один за другим то 
это еще надо настроить.

поправка такая еще - я там выше написал что ядро неиграет никакой роли в работате терминала кроме
как отправка байтов и получение. это и есть так если бы у нас терминал был реальной настоящей 
железкой (как это было много лет назад когда были реальные железные терминалы). а щас терминал 
виртуальный поэтому да в конечно итоге функцмонал железного терминала тоже обеспечивает ядро. условно говоря есть драйвер терминала в ядре для которого терминал это железка как настоящая с которой есть некий програмнй интерфейс и порты взаимодействия (через виртуальный com порт) и есть
еще кусок кода ядра который уже непосресдтвенно эмулирует живой железный терминал. но на мой взгляд  для более четкого понимания как все работает лучше представлять что мы имеем реальный железный терминал который через com порт соединяется с системным блоком компа. ( да то есть раньше комп выглядел так что был системный блок и несколько терминалов подключенных через COM порты к сстемному блоку. терминал был  ящиком железным в котором была обьедиенная  в одно целое экран и клава). таким образом между ядром и терминалом только летали байты а отрисовку на себя брала уже железка и прием кнопок с клавы и отсылку в систм блок брала на себя железка. соотвесвтенно 
уже на железке на терминале можно было например ввести строку и отредактировать еще не отправив
в системный блок. также на терминале можно было выбирать (наверное) шрифты цвета и всяке другие 
графические настройки внезависимости от системного блока от ядра. условно говоря терминал это был содеинное в одно три компоенента : граф карта , клава, монитор.  современный комп все это разьединил на три разные устройства каждое из которых коммуницируем  с ядром через свой порт.  а раньше они все сидели на одном COM порту который их соединял с сист блоком тоесть с ядром.


так вот bash он может делать настройки терминала через обращение к ядру черещ сисколлы ioctl_tty, ioctl а ядро тогда получив эти сисколлы подручивает настройки на терминале. что баш активно и делает постоянно. при своем старте. при своем окончании работы. при запуске команды. для 
нас это остаетается все невидимо и прозрачно если только нетрейсить работу баша или незастопить 
его процесс. и тогда мы обнаружим что нажатие кнопок в термирале приводит к тому чтобы они печатались на экране. вот тутто оно и вылезает!

опишем еще раз как работает связь взаимодействия между термиалом и юзерским процессом (приложением):

мы жмем кнопку на клаве это событие принимает обрабатывает терминал (железка если у нас железка или эмулятор терминала особый кусок кода в ядре что существенно что юзерский процесс  к этому неимеет никакого отношения и контроля над этим. единственный контроль который юзерскрйи процесс может сделать это заранее через сисколл ioctl попросить ядро покрутить настройки на терминале которые потом дествуют автономное без участия юзерского процесса). так вот мы нажали на кнопку 
терминал это принял и переработал в байт информации и положил в свой внутренний буфер ( если это желещка то в буфер железки если это виртуальный терминал то в буфер в ядре). далее если на терминале выставлены дефолтовые настройки то байт информации о нажатии клавы непередается в драйвер терминала ( непутать эмулятор терминала и драйвер терминала. эмулятор терминала эмулирует поведеие железки для кода ядра. а драйвер терминала принимает байты от эмулятора терминала либо реального терминала и пересылает их в /dev/pts файл чтобы юзерское приложение могло взаимодействоать с терминалом через ядро. дальше будем для простоты изложения счиать что терминал реальный железный а том мудота описания будет зашкаливать). так вот мы нажали кнопку ее считал терминал и положил в форме байта в свой буфер. далее если настройки натерминале дефолтовые то 
ничегоне произойдет  а именно терминал нестанет отправлять этот байт в COM порт в ядро. тоесть ядро неимеет представления на данный момент что была нажата кнопка а приложение тем более.
далее мы виваем еще несколько кнопока и они тоже записываются в буфер терминала. также в дефолтовой настройке терминала при нажатии на кнопку она автомтом отрисываоается на экране.
обо всем об этом ядро и приложение недогаюываются. они об этом незнают. далее мы можем нажимая спец копки на клаве даже редактировать введенную строку в терминал. об этом тоже ни ядро ни приложение незнают. потому что обовсем об этом по дефолту он недоакладывает в ядро а ядро соответвенно неможет доложить приложению. и наконец мы тыкаем на клаве Enter. это историческое событие потому что теперь терминал шлет всю эту строку в ядро через COM порт. ядро принимает 
байты. в свой драйвер терминала.  приложение по прежнему нифига незнает ни очем.  а между тем у
нас на терминале уже во всю светится та строка что мы ввели. но это абсолютно незначит что эта строка уже в памяти приложения. итак драйвер получил байты о кнопках и он отсылает их в /dev/pts/x.
и вот теперь юзер процесс может считать из /dev/pts и узнать о том что была нажат клава и какие кнопки.  опять же от того что драйвер ядра направил байты от кнопок в /dev/pts незначит что
приложение их автоматом получило. нет. приложение должно самостоятельно сделать запрос на чтение из /dev/pts  а если приложение сейчас занимается чемто другим и не делает запрос на чтение так 
оно и опять же без понятия о том что были нажаты кнопки. на практике приложение делает особоый 
сисколл типа select/pselect и засыпает переходит в S состояние. этот сисколл он следит за тем 
что в /dev/pts появились данные. таким макаром приложение может следить за тем что в /dev/pts прилетели кнопки. итак приложение заюзало при своем старте такой сисколл и он сработал , юзер программа будится и делает запрос на чтение.  и вот только теперь наконец нажатые кнопки 
смогли попасть в программу. !  соовтсветвенно когда теримнал с дефолтовым настроками то в программу
прилетает только строка целиком а непобуквенно. причем на экране терминала уже все нарисовано и 
только потом после Enter буквы появляются в приложении(опять же появляются только если в приложении настроен правильный сисколл а так могут еще хрен знает сколько времени непоявляться а на экране есть). соотсвтенно при такой схеме приложению ненужно обратно посылать эти буквы на /dev/pts с целью чтобы они отрисовались на экране терминала потмоу что они там уже есть. если их заново послать то тогда байты пройдя цепочку посредников обратно нарисут на терминале дубликат той же строки. а смысл? поэтому данная схема имеет свои плюсы и и минусы.

как уже сказал что у терминала можно подкручивать настройки. юзерская программа это может сделать
если исползует сискол  ioctl , ioctl_tty  с параметрами. тогда (через ядро) терминал будет подкручен и начнет работать по другому.

такую подкрутку делает баш. что он делает. баш когда стартует он делает ряд ioctl и меняент на 
терминале настройки. что меняется: если мы нажали кнопку то терминал немедленно (недожидаясь Enter) шлет байт с буквой в COM порт тоесть байт сразу улетает в ядро а оттуда в /dev/pts файл 
а  баше также настроен сисколл который ждет прилета инфо в /dev/pts таким образом нажатая кнопка на терминале мгновенно оказывается в недрах баша. минус такой схемы в том что баш должен предоставлять (как я понимаю ) встроенный редактор чтобы можно было редактировать строку символов (ведь раньше это можно было делать средствами самого терминала а теперь нет). вторая настройка касающаяся терминала состоит в том что после нажатия кнопки терминал автоматом ее неотображает на экране. вместо этого теперь баш когда он получил кнопку то он сразу шлет обратно в /dev/pts этот же байт. терминал принимает этот байт и отрисовывает. такая схема дает некую синхронность в том плане что все что мы нажали сразу оказывается в кишках ( в памяти) баша а то что он получил он отправляет обратно и мы это видим на экране. так что получается что то что на экране уже в кишках баша а что в баше то уже на экране.

но еще раз подчеркну что при такой схеме баш(юзер процесс) никак не играет роли в функции принятия кнопок с клавы или в отображении символов на экране.    

описанная схема работы баша обьясняет феномены такие как:
	- если мы в одном окне откроем баш который привязан к /dev/pts/x а во втором окне запустим 		cat  /proc/pts/x  и потом в первом окне начнем нажимать кнопки то часть наших нажатий отобразится на втором экране и только часть в экране баш. тоесть второе окно будет как бы красть часть наших нажатий. тоесть например мы нажали на клаве 123456 а увидим в окне1 и окно2
	вот что
	 (окно1) $  25
	 (окно2) $ cat /dev/pts/23
	 			136
	 как так вышло.
	 мы жмем на клаву в терминале окна1 и символ мгновенно улетает в /dev/pts на выходе из этого файла в юзерспейсе за его содержимое сражаются одноверменно два процесса bash и cat.
	 и только ктото один (по рандомному закону) считает очередную букву. когда то это будет баш когда то это будет cat. поскольку в терминале где баш он отключил автоматическую печать той кнопки которая была нажата то в этом окне будут печататьс только те симоволы которые баш получил из /dev/pts и обратно сам направил. вот символы 2 и 5 они все таки долеетели до баша (cat их несмог своровать) и баш их автоматом отправил обратно в /dev/pts терминал окна 1 их получил и напечатал. вот почему так все отработает. 
	 	Если бы баш включил local echo on настройку на терминале то тогда все наши нажатые в терминале окна1 кнопки 123456 они бы напечатались бы автоматом внезавимисоти от того что 
	 	из этого доолетело то баша. правда бы при этом кнопки 2 и 5 они бы два раза напеатались 
	 	один раз из за опции local echo on и второй раз из за того что баш их прислал обратно 
	 	через /dev/pts тоесть выглядело бы картина общая тогда бы так
	 (окно1) $  12234556
	 (окно2) $ cat /dev/pts/23
	 			136
	 
	 при этом еще раз подчеркну что баш внутри себя бы имел информацию толлько о нажатии на 2 и 5
	 а об остальных кнопках баш бы бы без понятия. тоесть если бы мы вводили вместо цифр буквы скажем  ls -1 то мы бы увидели (дублируем второй и пятый символ)

	 (окно1) $  lss -11
	 (окно2) $ cat /dev/pts/23
	 			l 
	 и мы бы непонимали что за хрен в командной строке баша откуда и почему. 
	 и если бы мы даже отредактировали то что там по факту осталось бы а недрах баша неясно.
	 и было бы непонятно после Enter почему линукс ругается на синтаксис что он неверный команды.
	 поэтому башу очень важно в режиме ввода команды в строке чтобы отображамый текст на экране
	 терминала в точности соотвествовал тому что реально долетело до баша. 
	 тоесть вот в этом случай
	 (окно1) $  25
	 (окно2) $ cat /dev/pts/23
	 			136
	 хотя до баша у нас долетела лишт только часть нажатий но хотя бы мы четко знаем и баш знает что внутри баша только 25 и на экране 25. полное соотвесвтие между оперативной памятью баша
	 и строкой на экране.

	 Поэтому когда баш запустился и мы увидели его приглашение в командную строку к этому моменту
	 баш уже подкрутил терминал на две вещи - выключил local echo и нажатие кнопки на терминале
	 мгновенно летит в /dev/pts. зачем он это сделал еще раз для того чтобы было четкое совпадение
	 того что напечатано на экране и того что сидит в памяти в окне терминала. Думаю теперь однозначно понятно что вообще говоря и особенно при дефолтовых настройках терминала то что мы видим на экране и то что долетело до приложения и сидит в его кишках это совсем необязано совпадать. ( а ведь интуитивно мы думаем что это одно итоже. что окно терминала это как бы окно в кишки баша или другого приложения а это совсем нетак.) баш можно представить как поле боя с танками самолетами. а окно терминала как карту. с одной стороны юзер генерал может двигать войска по окну терминала потом через ядро эти приказы летят к полю боя ( процесс)
	 но совершенно нефакт что либо одно долетело туда либо резултатты обратно. так что может получаться так что в окне терминала одно (карта поля боя) а на поле боя другое (кишки терминала). а интуитивно кажется что это одно и тоже. что это окно терминала это как бинокль или микроскоп напрямую в кишки баша. нет. скорее это карта на стене которая нарисована согласно телеграммам  с поля боя и нашим движениям руки двигающим фигурки на карте. может быть рассогласование. вот в чем подстава.

	 двигаем дальше.  такой режим терминала недефолтовый кастомный удобен и нужен только башу
	 на момент ввода команд но совершенно нефакт что он нужен программам которые он запускает
	 плэтому как только мы ввели команду отредоактировали и нажали Enter то баш перед тем как выполнять команду сбрасывает насторйки терминала(через сисколл ioctl) на дефолтовые. тоесть на терминале обратно включается local echo on и терминал посылает в ядро нажатые кнопки 
	 только после нажатия Enter. это в частности приводит к тому что когда мы запустили программу
	 в баше и он  там работает то мы можем нажимать кнопки в это время в терминале и они 
	 отрисовываются сразу. пример

	 $ ./39.exe
	 13
	 3 1
	 2213
	 1231
	 23214
	 14
	 1
	 4332
	 4


	 баш сбарывает настроки терминала на дфолтовые даже когда запускает свои builtin команды
	 пример такой команды:

	 $ builtin echo "1"

	 мы помним что когда выоплняется запущенная внешняя команда то это делается через создание
	 дочернего процесса clone+execve и на время работы чайлда баш впадает в спячку через wait.
	 когда команда отработала и дочений процесс сдох и произошел возврат в оживший процесс баш то 
	 баш опять меняет настройки терминала с дефолтовых на кастомные и так каждый раз.

	 соовтственно если исползовался builtin команда то дочернего процесса нет. просто когда builtin выполнился то бащ тоже убирает дефолтоые наторройки терминала и выставляет кастомные.

	 что мы имеем в остатке по практическим случаям:
	 	- если у нас в окне есть баш в котором ничего невыполняется  а просто висит
	 		приглашение командной строки и мы возьмем и застопим(из другого окна) процесс этого баша через SIGSTOP то в нашем исходном окне при нажатии на кнопки они перестанут печататься на экране. хотя по факту их нажатие фиксируется терминалом и направляется
	 		в ядро а оттуда в /dev/pts просто такак у нас local echo off то терминал недублирует
	 		их на экране а только пересылает в /dev/pts а так как баш остановлен то он обратно и 
	 		не пересылает буквы лежащие в /dev/pts поэтмоу на экране и пусто. но еще раз скажу нажатия кнопок фиксируются терминалом ( потому что терминал его эмулятор это ядерный код и он работает как прежде. то что баш остановлен терминалу глубоко пофиг. вот это важно еще раз понять. кнопки терминалом принимаются фиксируются и отправляются на /dev/pts через ядро. так что потери нажатий нет. в этом можно легко убедиться разблокировав баш через SIGCONT и мы тут же увидим на экране всю ту абрадакабру которую мы набрали в слепую. итак еще раз нажатия фиксируются нетеряются терминалом потому что его работа 
	 		обеспечивается ядром искючительно ядром. в том что кнопки фиксруются можно убедитьс разблокировав обратно баш. итак нажатия мы непотеряли. а то что они непечатаются когда бащ стоит здесь баш напрямую ни причем. он на это напрямую никак не влияет. просто до этого баш через ioctl настроил терминал чтобы он при нажатии на кнопку автоматом ее нерисовал на экране (потому что нажатие и отображение на экране это вооще то два разных события и мы можем настройками либо установить автопечать на терминале либо октлючить так вот баш заранее отключил) поэтому оно и нерисуется при нажатии. но нераюотающий баш здесь ни причем. когда он работает авторисование также неработало просто когда баш работал он это со своей строны компенсировал присылая обратно в /dev/pts полученные буквы. терминал их получал и печатал возникала иллюзия что нажатие на кнопку и печать на экране это как бы одно событие неразрываное. а так как баш остановлен то он не посылает обратно ничего на терминал)
	 	- если мы в баш запустили какую то долгоиграющую команду(если она недолгоиграющая то мы просто не успеем кнопки понажимать) то в это время при нажати на 
	 		кнопки на экране будут печататься символы. Это то к чему мы привыкли. ни баш ни команда запущенная к обработке и отрисовке этих символов неимеет никакого отношения. это чисто работает терминал. при запуске команды сам баш сбраывает настройки термиала
	 		на дефолтовые и если после этого команда неменяет настройки то просто нажатые символы их терминал только печатает на экране но нешлет в /dev/pts и только если мы нажмем Enter то терминал их пошлет в /dev/pts ну а там уже дело работающей команды читать из /dev/pts или нечитать. если команда небудет читать то эти символы выскочат в строке баша когда команда закончит свое действие и баш вернется обратно из спящего состояния. 	
	 вообще это интересная тема. если ты нажал на кнопки в терминале и ничего невидишь на экране 
	 это еще незначит что кнопки были не восприняты терминалом. а если ты видишь на экране символы в терминале это ще незначит что терминал отослал эти символы в /dev/pts а если и отослал это еще незначит что приложение их прочитало.

	 кстати еще момент. вот мы остановили наш баш через SIGSTOP (из другого окна) и окно его терминала "зафризилось" тоесть мы нажимаем на кнопки а на экране нет символов. можно легко убедиться что символы продолжают летеь от терминал в /dev/pts достаточно открыть второе окно и там ввести

	 $ cat /dev/pts/x

	 потом вернуться в первое окно нажимать там кнопки. потом вернуться во второе окно и мы там увидим все кнопки что мы нажали. тоесть терминал продолжает как прежде принимать кнопки
	 и посылать их в ядро  драйверу терминала а он в /dev/pts . так что терминал продожает рабоать кнопки нетеряются и замороженый баш на это никак невлияет и неможет повлиять. терминал это терминал ( эмулятор обслуживает ядерный код который условно говоря работает всегда и его неостановить неотключить потому что интеррапты неотключить) и он работает всегда вне зависимости
	 от того работают или зависли или остановлены юзер процессы связанные  с этим терминалом. надо четко понимать что терминал это одно а процесс это совсем чтот другое. кажется что терминал и процесс юзерский это чтото единое спаянное неразрываеное. это совсем нетак. связь между терминалом и юзерской программой это как связь между двумя людьми в разных городах которые обмениваются друг с другом телеграммами. все таки когда мы смотрим в черный экран мы смотрим в терминал (его обслживает ядерный код или даже это может быть железка) и все эти буквы на экране
	 это все терминал и только терминал. юзеркий процесс где то там  за дальними далями. просто юзерский процесс присылает телеграммы через ядро о том что бы он хотел чтобы терминал нарисовал 
	 на экране. вот какая связь между буквами на экране терминала и процессом. а нам кажется что мы 
	 видим буквы вот буквально как бутто это кишки баша. это совсем нетак. 

	 ффффууууухххх... вот так описание. вот баш вот так молодец. и терминал тоже тот еще молодец.

====================================
Posix
Single unix specification  (SUS) = X/Open Common Application Environment Specification
"Unix System V Interface Definition" (SVID)
ABI

Posix и SUS сейчас это одно и тоже.

и еще такое

POSIX:2008 = IEEE Std. 1003.1-2008 = SUSv4 = The Open Group Specification Issue 7.

posix включает в себя несколько томов:
	- Base Definitions
	- System Interfaces
	- Shell & Utilities
	-  Rationale

обычно если это pdf файл то там все тома сразу включены.
прикольно что они дают опредеение для файла а для иноды нет. зато в тексте спокойно
пользуются термином инода. недебилы ли?


далее
нашел стстатью computerworld 26 октября 1987 года.

там сказано что тогда было два документа "Unix System V Interface Definition" (SVID) 
который разработала AT&T. 

POSIX документ о томже самом но его разработал институт IEEE.

цель этих документов описаать стандарт взаимодействия между юзерской программой (user space )
и ОС (кернел спейс). тоесть описат те стандарты и инструменты которые предоставляет
ядро ОС для программы которая сидит в user space и видит эти инструменты с которыми можно общаться по определенным стандартам. тоесть для юзерской программы общение с ядром 
выглядит исключительно через инстурменты которые ядро предоставило в user space.
итак идея еще раз какая. есть ядро внутри себя оно может взаимодевтсивовать как хочет, но в сторону userpspace ядро ОС которая совместима с POSIX должно предоставлять определенные
инструменты таким обоазом с точки зрения user space программы любая ОС совместимая с posix
выглядит одинаково.  условно говоря доступ к файлу с точки зрения user space программы
дожлен выгляеть как /fodler/folder/fodler/filename

итак еще раз posix опиывет стандарт интерфейса между user and os. другими словами ядро предоставляет в userspace набор инстурментов с конкртеными характеристиками. таким образом неважно как ос выглядит на уровне кернел моде главное что для юзер программы любая posix совместимая ос выдает один и тот же набор инструментов поэтому выглядит одинаково.

таким образом юзер программа взаимодейтсивет с posix набором инстурментов(в user mode) и похеру что там по капотом у ос ( в кернел моде) . появляется portability программ между posix 
совместимымми ОС.

важно еще и то что если у нас есть несколко наших программ то друг с дружкой они будут 
взаимодейтсивовать (IPC) через опять же интерфейсы инструменты которые предоставляет ОС,
таким образом нетолько одна программа но и связка программ будет успешно взаимодействоввать
друг с другом как в одной posix os так и в другой. потому что еще раз - все межпроцессное
взпимодейтсвие всегда идет все равно через некоторые инстурменты(видные в user space) которые предоставляет ядро. а эти ipc инстрменты тоже оговорены в posix. 

возврашаемся к SVID - в статье сказано что в SVID указано много чего hardware specific 
что уменьшает portabilty насколько я понял уже речь идет о портабилити ОС а не user программы. в плане того что ОС будет  привязана к конкретному железу. В любом случае там
сказано что в SVID слишком много конкретики что делает его менее сильным в плане portability 
насколко я понимаю уже в плане железа на котором может работать ОС соответвующая SVID чем это есть у ОС которая соответсвтует POSIX.

поэтмоу немогу понять почему ABI привязывается к SVID а не к POSIX ?

в википедии abi опреляется как то что у нас есть две программы уже откомпилированные
и они друг с другом через железо могут обмениваться инфой. тоесть одна хочет другой
чтото передать , делает она это через железо определенным образом , вторая программа
хочет принять от первой инфо и она знает как первая использовала железо (условно говоря
первая прога положиме в регистр intel RAX ).  тоесть abi пропсиывает для бинарных программ
протокол обмена данными через железо - как это делать конкретно.

API описывает тот же обмен данными между двумя прогами но ! на уровне source code.
получается программист должен знать API, компилятор должен знать ABI.

как уже написал если мы пишем на C то это забота компилтора все делать как ABI пропсиывает.
(если только мы в C source неиспользуе вставки из головго асемблера)

api - дает возможность программам обмениваться информацияей друг с другом на уровне исходников. вообще это дебильное определение. тут смысл на самом деле такой - вот у нас есть ОС которая как бы одна программа. а есть наше user приложение которое друая программа.
ОС предоставляет некий набор инструментов на уровне source code для юзер программ.
если у нас будет две ОС у которых в кернел моде все работает по разному но в юзер спейс
они предоставляют одни и теже инстурменты , то для юзер приложения эти две ос идентичны,
поэтому мы берем source код нашей user проги несем в любую ос, компилируем там компилятором
от той ОС и она там работает на одном и том же source код. вот что значит блядь что api дает портабилити на уровне source code. когда мы говорим про api это значит что есть одна программа которая придумала api и его предоставляет и есть другая программа которая подчиняется этому api и следует ему. api это набор инстурментов верхнего уровня абстракции,
эти инструменты позволяют программа обмениваться инфо гвоорить на одном языке на верхнем
уровне абстракции на уровне языков программирования типа C. API конкретика описывается 
в source код первой программы и потом также отображается в source код другой программы.
условно говоря в первой программе мы говорим что у нас есть функция A и у нее есть один параметр который имеет тип целого. чеерз эту функцию мы будем обмениваться данными. это началось api.

A C standard library is a wrapper around the system calls of the Linux kernel; the combination of the Linux kernel System Call Interface and a C standard library is what builds the Linux API.

POSIX является api. но и нетолько там есть и еще доп контент.

посдення версия posix (читается ПАЗИКС): POSIX.1, 2013 Edition


api = это когда у нас одна программа порождает высокоуровневые сущности через которые другие программы могут обращаться к первой и они могут обмениваться данными. что это за сущности. 
наверное например это функции. функция это высокоуровнневая абстракция. 
первая программа поставляет функцию которая имеет один параметр и он скажем целого типа.
если вторая программа обратться к этой функции то сможет получить кусок данных от первой
программы или передать свой кусок данных для первой программы. вот эта функция и есть уже сущность составляющая API от первой программы. итак у API есть обяазательно поставщик
программа которая рождает и обеспечивает существование и работу некоторго набора высокоуровненвых сущностей через которые друние прграаммы могут комуницировать с программой
поставщиком. api обьекты создаются на базе высокоуровневых языков программирования.
итак конкретика api обьекта описывается текстовымм кодом на ввысокоуровневом языке 
прогрммирования. захера нужен api. это прослойка между программой один и внешним миром.
эта прослойка во первых дает связь межу программой и другими программами, и во вторыъ
эта прослойка абстрагирует скрыает внутреннюю кухню первой программы от внешнего мира.
тоесть программа один внутри может меняться но для наружных программ все выглядит всегда
одинаково. один пример это база данных (программа один). она наружу выкидывает набор api функций через которые можно к базе сделать запрос. а уже получив запрос база данных хитрым способом копается в кишках собирая ответ. таким образом для внешей программы внутренности
базы данных скрыты поэтому изнутри мы можем менять базу данных хоть сто раз надень как она там копается в своих кишках при поиске данных. второй пример ядро ОС. мы можем менять его сто раз на день его внутренний процессы но для юзер программы функции через которе ядро 
принимает заказы остаются теми же самыми. поэтому замена кишок ядра никак не влияет на source код юзер программы ибо ядро наружу выставляет всегда один и тот же набор функций.
условно говоря запорожец превратился со временем в бмв под капотом но для водителя это по прежнему руль и три педали. таким макаром у нас со временем ОС становится все более современной и звездатой ( поддерживает новые процесоры большие диски новые видеокарты) но при этом юзерскую программу ( редактор текста) переписывать на уровне source код ненадо. надо 
только перекомпилировать. 

когда мы слышим api то сразу надо спросить api для какой программы? потому что api без
программы источника которая предоставляет api небыавет. итак есть программа источник
она предоставляет набор функций и инструментов которые и составляют api множество.
итак api это неверный термин потмо что у api всегда есть два обьекта - первый это источник
api некая программа например ядро линукс. или веб сервер. второй обьект это набор инструментов
которые и составляют множество обьектов api. зачем все это. чтобы другие программы могли 
подключиться к этим инстурментам и через их помощь получить даные от первой программы или 
засунуть внутрь свои данные. поскольку программа это source код  ( как один из вариантов)
то физическим носителем api обьектов является source код высокоуровненовго язык програмирования, получается что более высокоабстрактные сущности api строятся на тех сущностях менее абстрактных который предоставляет язык программирования. 
прикол api  в том что он скрывает абстрагирует конкретику и внутренности как програаммы один 
от внешней программы так и внутренности внешней программы от программы один. 
на практике обычно важно то что мы написали программу юзерскую ( редактор) в форме source код на языке выскоуровневом програмировния и больше нехотим в нее вкладываться менять ее код.
тогда как бы неменяолсь ядро ОС со временем (линукс) нам ненужно менять код редактора 
текста он по прежнему работает хоть на старом линуксе хоть на новом на уровне source код.тоесть его только надо будет перекомпилировать. в этом и есть желаемая фишка.
потому что хоть внутрености программы один (ядраос) меняются но сисколлы которые ядро
предосталвяет остаются темиже. поэтому для юзер программы все api обьекты выглядят без 
изменений.

 
posix описывает api предоставляемое ядром(кодом раотающем в ринге0) UNIX подобной  ОС для user space программ(ринг3). таким образом если мы написали юзер программу которая взаимодейтствует
с posix api инструментами то эта программа должна работать без необходимости имзенения ее
source кода во всех ОС которые отвечают posix api. (единственное что юзер программу
нужно будет на каждой ос компилировать своим родным для ос компилятором, тоесть откомпиирванная на одной ос бинарник уже необязан работать на другой ос. только source код является перееносимым что уже круто.).
но posix описывает нетолько api которое предтвляет ядро ОС но и ряд дополнительных вешей. в целом получается что posix описывает как должна выглядеть вести себя ОС на уровне верхних абстракция на уровне сущностей выского уровня абстракции. вести себя и предоставлять эти 
сущности. например сущность  - командный интерпретатор. или терминал.



abi - описывает как конкретно две откомпилированые программы должны обмениваться данными 
через реальное железо. тоесть условно говоря если одна программа хочет передать 
данные в другую программу то она должна положить число в регистр EAX.тогда вторая программа
уже знает что данные лежат в EAX.
за реализацию ABI отвечают компиляторы на практике.

вообще это очень непросто понять все участников api или abi. какие стороны компоненты 
принимают участие в этих темах.  в случае api это точно две программы и язык программирования
через который две программы представлены в виде source код, в теле этих sourc кодов запрограмимрованы высокоуровненвые api сущности через менее высокоуровненвые сущности языка
программирования.

в случае abi это две программы и цпу. программы представлены на практике в форме  машинного кода который в свою очередь зависит от  типа цпу (intel 32bit, intel 64bit, arm 32bit, motorola). поэтому на каждый тип цпу свой abi документ. сущностями abi которе составляют его обьекты это  с одной стороны абстрактные сущности кода программы (функции нпример) а с другой стороны это сущнсости цпу (регистры) , ячейки памяти в RAM.

в вики написано что linux api предоставляет ядро и группа библиотек GLIBC.
тоесть носителем создавателем api является неодна программа а несколько - ядро и GLIBC.
ядро предоставляет в юзер спейс сисколлы а глибс функции обертки которые уже в свою очередь 
обращаются к сисколлам ядра.
пользовательккая программа может обращаться как напрямую к сисколлам ядра так и к 
glibc функциям.

что интересно прогарммы мы пишем на C. и язык C нам недает возможность обращатся к 
сисколлам. он только дает возможность обращатся к функциям glibc. а если мы хотим
из C обратиться к сисколлу ядра то надо в текст на C вставлять код на асемблере. 
с другой стороны кто сказал что язык программирования у юзер программы обязан быть C высокоуровневый. ассемблер тоже язык программирования. дауж.. намешали..




====

linux
static library vs dynamic library.

во время компиляции проги можно указать чтобы все библитеки которые ей нужны 
были вмонтированы в тело проги. тогда бинарник становится автономным. все куски кода
которые ему нужны будут вмонтированы в тело бинарника.  так вот вмонтирована в тело 
нашей прграммы будет библиотека в статическом виде.

статическая библиотека или динамичекая орпделеятеся на стадии компилировагния этой библиотеки
из исходного кода на стадии компиляции. берем исхоный код бибиотки компилируем с некоторыми
флагами и на выходе получаем либо файл который статическая библиотека либо файл
который на выходе динамическая библиотека.

файл который статическая библиотека будет использован для вмонтирования в тело 
другой программы при ее компиляции если мы укажем флагами при компилияции что мы хотим 
все библиотеки вмонтировать в тело программы. тогда комипилятор найдет все библиотеки 
которые нужны проге в их статическом виде и вмонтирует.

если же наша програ юзает библиотеку и мы при компиляции нашей проги укажем что
мы хотим чтобы наша прога юзала динамические библиотеки то тогда компилятор в теле нашей 
проге ее бинарника только сделает некие пометки а тело библиотеки небудет вклюать в тело 
нашей проги. зато потом когда прога запускется на выполнение динамический линкер 
найдет нужную билиотеку на диске или в памяти компа и "подключит" эту библиотеку как ссылку налету.

таким образом статиеская библиотекаа или динамическая определяется флагами при компилированиия
бибиотеки.  далее. статическая библиотека предназначена чтобы быть вмонтированной в тело 
программы в состав которой ее хотят включить. а динамическая библиотека предназначена для 
того чтобы загрузить ее в память компа а потом другие проги которые ее юзают при запуске динамиеским линкером будут в форме ссылки в памяти на нее слинкованы.

в чем плюс динамической библиотеки. если у нас 100 процессов и каждй юзает некую  библиотеку
то нуна только одна копия ее в памяти. а проги все которые запущены просто на нее ссылаются.

если бы у нас проги имели в своих телах эту библиотеку вмонтрованную то тогда бы в памяти 
сидело 100 копий этой библиотеки.

---------
===========================================
- как опредитедть что сидим на виртуалке 
ответ: cat /proc/cpuinfo | hyper
если есть слово hypervisor значит мы сидит на виртуаке а не реальном железном сервере
еще раз подчеркну что слово hypervisor неозначает что цпу поддверживает виртуализацию за это
ответчаюь другие флаги. этотфлаг именно означает что мы сидим под гипервизором.
====================================================

nestat
lsof
pid 
socket
network

- определить какой процесс открыл данный сетевой сокет
ответ: через netstat
$ sudo netstat -tnlp
Proto  Local Address           Foreign Address         State       PID/Program    
tcp    192.168.122.1:53        0.0.0.0:*               LISTEN      23404/dnsmasq   

видно что сокет 192.168.122.1:53 открыт проецессом с pid=23404
также замече что ключ -tnlp показывает только TCP сокеты(потому что -t = TCP. а если мы 
хотим также видеть UDP сокеты то нужно добавить ключ -u (UDP)
тоесть netstat -tnlpu
также можно это все увидеть через lsof
# lsof -i -a -n -P

- обратный вопрос. берем pid как узнать какие сетевые сокеты он открыл.
ответ через lsof

# lsof -i -a -n -P -p 23404
COMMAND   PID            USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
dnsmasq 23404 libvirt-dnsmasq    3u  IPv4 5278937      0t0  UDP *:67 
dnsmasq 23404 libvirt-dnsmasq    5u  IPv4 5278940      0t0  UDP 192.168.122.1:53 
dnsmasq 23404 libvirt-dnsmasq    6u  IPv4 5278941      0t0  TCP 192.168.122.1:53 (LISTEN)

вот еще удобная команда если знаем порт
# lsof -i:22
COMMAND  PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
sshd    1109 root    3u  IPv4 19288701      0t0  TCP *:ssh (LISTEN)
sshd    1109 root    4u  IPv6 19288703      0t0  TCP *:ssh (LISTEN)

====

про цифры
про биты
система счисления
битность
bit



скажем у нас есть система счисления то есть колчество цифр (знаков) которые мы можем 
юзать для обозначения цисла.
например у нас есть 10 знаков\цифр =  0 1 2 3 4 5 6 7 8 9

о знаках\цифрах мы договорились.

теперь смотрим сколько чисел мы можем обозначит через эту систему десяти цифр при условии
что можно использовать для обозначения числа только одну цифру. 

 ноль   = 0
 один   = 1
 два    = 2
  ...   = ...
девять  = 9

количество цифр в числе обозначим как n (битность).

получается в десятичной системе ( 0 1 2 3 4 5 6 7 8 9 ) при битности n=1
мы можем закодировать числа от ноля до девяти.

посмотрим сколько мы можем закодировать чисел если битность два n=2 (две цифры в числе)

ноль = 0
один = 1
...  = ...
девять = 9
десять = 10
....
девяносто девять = 99

итак если битность n=2 то макс число это девяность девять (99).

далее ставится важный вопрос если у нас битность n то какое макс число можно получить 
в этой битности. ответ 10^n-1

проверяем:

n=1 , макс число = 10^1-1=9 и это правильно
n=2, макс число = 10^2-1 = 99 и это правильно

это мы узнали макс число в зависимости от биности. а теперь еще хотим узнать 
не макс число а количество чисел которое мы получаем в данной битности.

для n=1 мы заметили что мы можем закодировать числа от 0 ... до 9 
и их количество равно 10

для n=2 числа будут от 0 до 99, и их колчество равно 100

далее утверждается что для битности n количество получаемых чисел = 10^n

для n=1  10^1=10
для n=2  10^2=100

далее утверждатеся что если у нас система счислений не десятичная а некая другая
например двоичная ( 0 1 ) или шестнадцатиричная ( 0 1 2 3 4 5 6 7 8 9 A B C D E F)
то 

макс (max)число для битности n = S^n-1
где S это количество знаков в системе счисления
а количество чисел (summa) закодированных в через битность n = S^n

например

S=10, n =2
max = 10^2-1=99
summa = 10^2 = 100

S=2, n=2
max = 2^2-1 =3
summa = 4

S=16, n=2
max = 16^2-1=255
summa = 256

зачем нам все это надо.
нам нужно уметь легко понимать имея некоторую битность и двоичную либо шестнадцтраричную
систему - сколько при этом будет закодировано суммаоно чисел и какое макс число.

первый практический пример.
если битность n это количество проводов. и каждый провод обозначает свой бит на шине 
адреса в памяти то нам надо знать какой адрес будет иметь ячейка с макс адресом
и сколько всего ячеек можно адресовать через сколько бит.

например

S=2, n=8
max = 2^8-1 = 255 байт (это макс адрес ячейки в памяти)
summa = 2^8 = 256 ( вот столько байт мы можем адресовать для хранения данных)

S=2, n=32
summa = 2^32 = 4294967296 байт. это 4Gb ячеек. поэтому цпу у которого 32проводка на шине
адреса может адресовать максиум 4Gb памяти.

другой пример.
в юникоде каждая буква имеет свой 4 и 5 значный номер в hex формате.

вопрос сколько букв можно закодировать при таком раскладе

S=16, n=4
summa = 16^4 = 65 536 букв

S=16, n=5
summa = 16^5 = 1 048 576 (примерно миллион)


 а если у нас S=2 и битность 7 то

 summa = 2^7 = 128 букв тогда можно закодировать через двоичную систему и 7 бит

====================================
man

цветной вывод манов на экране.
раскрасить

засунуть в ~/.bashrc


export LESS_TERMCAP_mb=$'\e[1;32m'
export LESS_TERMCAP_md=$'\e[1;32m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;31m'


====================================
man
info 
doc

на счет где искать инфо по команде варианты

первый способ
$ man name
$ man 7 name

второй способ
$ info name

третий способ
и еще в /usr/share/doc/name
полазить

=======================================
bash
type

полезная штука чтобы узнать та команда
что мы вводим она встроенная или внешняя

$ type -t gcc
file
$ type  gcc
gcc is /usr/bin/gcc
$ type -t env
file
$ type -t type
builtin
$ type -a type
type is a shell builtin
$ type -a gcc
gcc is /usr/bin/gcc
$ type -a printf
printf is a shell builtin
printf is /usr/bin/printf

чтобы незапоминать ключи лучше всегд посмотреть в man bash

=======
bash
hash
type

оказывается что каждый раз когда мы вводим команду в баше
он ее ищет в $PATH ( и это понятно) но потом самое главное он найденный путь запоминает.
и уже при повторном вызове.

посмотреть можно через hash (bash builtin) 

$ hash -l
hash: hash table empty

$ env

$ hash -l
builtin hash -p /usr/bin/env env

$ gcc

$ hash -l
builtin hash -p /usr/bin/gcc gcc
builtin hash -p /usr/bin/env env



следущая задача. мы хотим понять вот у нас есть команда . мы хотим понять 
где она лежит на диске а точнее откуда ее будет брать basр при запуске.
If you want to see the path to your program i suggest to use "$type -p" :

$ type gcc
gcc is hashed (/usr/bin/gcc)
$ type -p gcc
/usr/bin/gcc
-p key description:

If the -p option is used, type either returns the name of the disk file that would be executed if name were specified as a command name, or nothing if ``type -t name'' would not return file

Sometimes -p key is not enough. -a key will help:

$ type -p printf
$ type -a printf
printf is a shell builtin
printf is /usr/bin/printf


далее вот у нас есть команда мы хотми понять это встроенный в баш builtin 
или это внешнаяя команда используем type -t



$ type -t echo
builtin

ключ -p показывает где на диске баш будет искать команду
но так как echo это встроеный builtin то ключ -p покажет пустое место
$ type -p echo

а вот так как gcc это уже внешняя команда  то ключ -p покажет где ее будет брать bash
$ type -t gcc
file
$ type -p gcc
/usr/bin/gcc

если мы хотим проверить то что программа является и билтином и внешней командой
то ключ -a

$ type -a echo
echo is a shell builtin
echo is /bin/echo


это показывает что echo есть как в форме внешней команды 
так и внутри в баш в форме builtin

кстати. вот видно что у баш есть свой билтин echo. но это незначит что если мы напишем

$ strace echo ...

то будет исползован баш билтин. команда strace походу недогадывается об этом поэтому
она запустить внешний echo. 

============
bash
help
builtin

если у нас есть какойто builtin из баша
и мы хотми по нему прочитаь справку  один вариант это man bash и там листать вниз 
до описания билтина а второй вариант

$ help имя_builtin

пример

$ help type

=============
unset 

что она делает.
это bash builtin. 

она уничтожает обьявленную переменную баша.

тоесть

создали переменную в баше
$ ww=10
$ set | grep ww
ww=10

удаляем эту переменную
$ unset ww
$ set | grep ww

инфо об unset ищи в man bash

===
bash
readonly

в баш можно назначать ридонли переменные
для этого есть всторенный билтин reeadonly.
кстати он может покзаать спмсок ридонли переменных ключ -p

$ readonly -p

declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath"
declare -ir BASHPID
declare -ar BASH_REMATCH=()
declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
declare -ir EUID="1000"
declare -ir PPID="3866"
declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor"
declare -ir UID="1000"


=================
$ echo $BASHPID
15962
$ echo $$
15962
=================

bash
builtin 
fc


встроенная команда fc
позволяет выдать список команд без номера.
типа аналог history

показать последние 10 команд
$ fc -l -10
2008	 ls
2009	 fc -l -10
2010	 fc -l -100
2011	 fc -l -10
2012	 ls -1
2013	 ls 
2014	 ls -1
2015	 ls
2016	 fc -l -10
2017	 ls -1


но еще она умеет выполнять команды из history.
выполнить все команды из history начиная с команды номер 2014
$ fc -s 2014

справка по fc

$ help fc
$ man bash



=====
bash 
subshell

обозначается как
$ ( command1; command2...)

перед тем как отвечать на вопрс что такое субшелл и зачем оно нужен ответиим на другое.
вот у нас есть сеанс баш это процесс. и в мы в нем запускаем внешнюю команду. что при этом
происходит. баш себя клонирует в новый процесс. потом в новом процессе запускается execve с бинарников внешней команды. далее поскольку это новый процесс независящий от парент процесса
то чтобы ни делалла внешняя команда в новом процессе это никак невлияет на наш исходный баш процесс. никак. 

если мы в текущем сеансе\процессе баша запустим невнешнюю команду а builtin то баш себя
форкать небудет а будем выполнять эту команду в текущем процессе. со всеми вытекающими. какими? например мы с помощью builtin меняем некоторую переменную. и она в итоге будет изменена в текущем сеансе баша. 

а теперь вопрос- а если мы хотим запустить bash builtin но чтобы при этом он смоге поменять 
ничего в нашем текущем процессе баша (переменные и все остальное) - вот для этого и исползуется
субшелл.

что такое субшелл. это баш берет и клонирует себя (форкает). но далее execve он невыполняет в дочернем процессе. действительно а зачем если дочерний процесс уже баш. таким образом с одной стороны дочерний бащ (он же субщелл) получит в наличие все переменные котрые были в парент процессе с другой стороны чтобы ни делалось в дочернем процессе оно уже никак не полвияет на парент процесс. так вот далее в дочернем процессе выполняются все команды которые находятся в скобках.

$ ( command1; command2...)

естствеенно что если в скобках у нас одни buitin то они будут выполенны все в субщелл процессе
а если там есть внешние команды то субшелл еще раз форкнется и выполним execve в дочернем от себя процессе. но важно то что если в субшелле только buitin команды то они максимум могут 
поменять переменные в субшелле а в парент процессе они ничего поменят немогут. 
Итак еще раз если у мы запускаем внешнюю команду то она в текущем баше поменять точно ничего
неможет потому что баш выполняет внешнюю команду через fork+execve тоесть в новом дочернем процессе. так что внешнаяя команда никогда ничего в нашем баше поменять неможет. а вот билтин
команда выполняется в текущем процессе баша и она может много чего поменяь в текущем процессе баша например каккуюто переменную. если мы нехотим этого. если  мы хотим себя от этого 100% предохрнаить то надо запустить билтин команду в субшелле. ради этого субшелл и былпридуман.

пример

$ qq=10
$ echo $qq
10

в первой строке вы запустили билтин. и он нам создал\изменилт переменную в нашем 
текущем процессе.


$ echo "текущий процесс pid=$BASHPID. qq=$qq"; ( echo -n "субшелл pid=$BASHPID. "; qq=20; echo -e "qq=$qq"); echo "текущий процесс pid=$BASHPID, qq=$qq"

текущий процесс pid=20328. qq=10
субшелл pid=21200. qq=20
текущий процесс pid=20328, qq=10

мы видим что в парент процессе qq=10
в субшелл процессе мы поменяли и qq=20
однако после этого в парент процессе qq по прежнему равен 10.

вот для этого и был придуман субшелл. тоесть если мы хотим 100% быть уверенными что 
наши buitin команды неизменят наш текущий процесс то тогда их надо засунуть в субшелл.


Также можно заметить что я использовал $BASHPID а не привычный $$. почему?
потому что - согласно практике выянилось что переменная $$ невсегда показыает коректный pid процесса.

пример

$ echo $$
21006
$ (echo $$)
21006

что за херня. ведь мы же знаем что субшелл это новый процесс.почему одинаковый pid покзывает.

пробуем другой способ

$ echo $BASHPID
21006
$ (echo $BASHPID)
21092

вот уже похожде на правду.

вот что man bash нам пишет про $ и BASHPID:

 $      Expands to the process ID of the shell.  In a () subshell, it expands to the process ID of the current shell, not the subshell.

 BASHPID
              Expands to the process ID of the current bash process.  This differs from $$ under certain circumstances, such as subshells that do not require bash to be re-initialized.

таким образом даже в мане написано что $$ в субшелле показывает неверный pid процесса.
а BASHPID всегда показыает верный pid процесса. а мы и работаем в субшелл поэтому я 
использовал BASHPID которы всегда показывает верный pid процесса.

далее про субшеллы - нашел в man bash фразу:
 Builtin commands that are invoked as part of a pipeline are  also  exe‐
       cuted in a subshell environment.  Changes made to the subshell environment cannot affect the shell's execution environment.

тоесть если у нас есть pipe между builtin то они оба выполняются не в текущем процессе
а оба выполняются в отдельных субшеллах. это важно . я проверил через strace и это подтвердиолось.
пример

$ ds=10 | echo $ds

$ echo $ds


как видим везде пусто. а теперь обьяснение.
первая строка. у нас есть два билтина и они разделены пайпом. раз есть пайп то как мы уже прочитали в man то что делает наш баш. он берет клонирует себя два раза из текущего состояния.
тоесть текущий баш имеет pid=12,
создается pid=13 и pid=14 и вывод из pid=13 прписывается в ввод pid=14,
далее в pid=13 запускается ds=10 
и в pid=14 запускается echo $ds

тут важно понять что pid=13 и pid=14 получены из pid=12 на момент когда там небыло никакого
ds=10. дададада! дело в том что ds=10 будем запущен в pid=13 а pid=12 неимеет никакого понятия об ds=10.

итак еще раз. мы имеем пустой pid=12 наш головной баш. в нем нет переменной ds=10.
потому что эта команда она еще небыла запущена мы ее только собираемся запускать.
далее мы ввели две команды через пайап и тыкнули энтер. баш эти команды невыполняет. нет.
он вначале себя клонирует два раза. поэтому и головной баш и его два клона они абсолютно
одинаковы в том плане что в них пока нет никакого ds=10.
далее уже в дочернем процессе pid=13 баш запускает то что слева от пайпа тоесть ds=10. и там он появляется. в pid=14 он запускает echo $ds но pid=14 неимеет никакого ds у себя поэтому выовод первой строчки пустой! также так как вывод ds=10 пустой то совершенно неимеет роли что вывод из pid=13 направлен на ввод pid=14. тем более что echo он ничего нечитает из станадартного ввода. вот из за всего этого вывод первой строчки пустой! таким образом пееременная ds=10 она будет создана только в pid=13 но ее небудет ни в pid=12 ни в pid=14.
и именно из за этого вторая строка тоже пустая! потому что в pid=12 нет никакого ds=10 !

вот как ! и все это именно из за того что если мы имеем пайп то команда слева и справа обе будут запущены в отдельных процессах и неважно это внешние команды или builtin. таким образом builtin невсегда выполняется в текущем процессе! вот это я и хотел показать!

я проверял через strace что билтины справа и слева дейтсвительно запускаются в
 отдельных процессах

=================

bash

{ ..;}

такие кавычки это просто визуальная оформлялка группировка команд.
тоесть что есть эти кавычки что их нет. все равно. команды внутри этих ковычек исполняются
в текущем процессе если это билтины.

$ echo $BASHPID
23616
$ { echo $BASHPID; }
23616

вот. видно что и так и так это один процесс

чем она еще удобна  - тем что можно удобно вводить много строчные команды  неиспользуя знак "\"

$ { echo 1;
> echo 2;}
1
2


==================

bash

(( ... ))

двойные скобки.

это билтин.предназначены для вычисления арифметических операций.
неимеют ничего общего с одинарными скобками которые субшелл.
в мане написано что расчеты идут исходя о том что операнды это fixed-width integers.
это точная копия билтина let "expression" 

сразу скажу про let
let "expression" это полный аналог (( expression )) 
при использовании let обязательно  нужно использовать двойные кавычки иначе будет мудота потому что иначе нужно будет экранировать спецсимволы а это ужасно неудобно
ненужный оверхед которого нет у двойных скобок.

$ let  "5>4"  && echo "5>4   # проходит без проблем
$ let  5>4  && echo "5>4"    # ошибка
bash: let: expression expected
$ let  5\>4  && echo "5>4"   # прошло но нужно экранировать
5>4

что интересно в man bash про let совсем неуказано что нужно юзать двойные кавычки.
там сказано что 
 let arg [arg ...]
а в man bash про двойные кавычки (ищи по слову compound) там указано что  (( expression))
это полная аналогия let "expression". тоесть описание двойных кавычек как бы намекает что в let надо использовать двойные кавычки.
также прикольно то что если у нас двойные кавычки (()) то понятно как напечатать на экран
их резултат
$ echo $(( 3+ 5))
8

а как распечатать на экран если мы спользуем let я непонимаю
$ echo let "3+5"
let 3+5




двигаем дальше
поддерживаются все простые мат операции +-*/^

$ (( 3+5 ))
$ (( 3-5 ))
итп

но вывода никакого нет на экран.так что в таком виде от команды мало толку. единственное что
если внутри сравнние что можно использовать то что команда возвращает резульатат 0 или 1 в зависимости от того true внутри или false

пример
$ (( 5 > 4 ))

результатом будет код возврата либо 0 либо 1

$ (( 5 > 4 )) && echo "5>4"
5>4

теперь переходим к выводу на экран.
$ echo $(( 3+5 ))
8
наконец получили вывод на экран.


также важно отметить что внутри скобок (( )) если мы обращаемся к переменной то 
знак доллара ненужен. это первая особенность (( )) и переменных внутри них.
$ n=10; (( n+1 ))

еще важный момент про (( )) и переменные это то что часть команд неменяет переменные(что логично) а часть команд внутри (()) меняет переменные! это вторая особеность двойных скообок и переменных внутри них.

щас я приведу команды которые меняют переменные внутри скобок
= *= /= %= += -= <<= >>= &= ^= |=
и  id++ id-- ++id --id
я щас ниже обьясную что каждая команда значит. важно главное щас понять что 
если знак равно испольуется то переменная будет изменена. а если знака равно  внутри нет
значит переменная небудет изменена. но есть одно исключение вот эти команды 
id++ id-- ++id --id они хотя и неимеют знака "=" но они меняют переменную.
начинаю расшифрроввывать что эти команды значат


			 id++ id--
              variable post-increment and post-decrement
       ++id --id
              variable pre-increment and pre-decrement


$ n=16; echo $(( n++  )); echo $n
16
17
$ n=16; echo $(( ++n  )); echo $n
17
17

как видно переменная изменилась, причем знака "=" нет и также обращение к переменной 
идет без знака доллара.


разницы между этими командами нет в конечном итоге
на переменную. есть разница в выводе echo (пока незнаю почему)

тоесть видно что пеерменная n=17  вобоих случаях( и это главное). но echo покажет разный результат.(это второстепенное хотя и любопытно)

еще раз подчеркну что переменная меняется при этом к ней обращение идет без знака доллара $
и без знака "="
$ a=2334
$ (( a++ ))
$ echo $a
2335


еще пример на эту тему
$ a=2334
$ (( a=a+1 ))
$ echo $a
2335



расшифровываю операции:
       = *= /= %= += -= <<= >>= &= ^= |=
              assignment


рассмотрим первое =
$ echo $(( a=5 ))
5
$ echo $a
5

тоесть это просто операция присваивания

дальше интереснее *=
фишка этого обозначения в том что это операция умножения и присвоения одновременно.
тоесть

(( a*=5 )) эквивалентно (( a=a*5 ))

пример
$ a=10
$ echo $(( a=a*10 ))
100
$ echo $a
100
$ a=10
$ echo $(( a*=10 ))
100
$ echo $a
100

отсюда видно что я доказал что (( a*=5 )) эквивалентно (( a=a*5 ))

Так вот далее по аналогии все оставшиеся операции /= %= += -= <<= >>= &= ^= |=
это арифметическое действие и присвоение. тоесть 

/= это деление и присвоение
%= нахождение остатка и присвоение
+= суммирование и присвоение
-= отнимание и присвоение
<<= это сдвиг влева на некоторое число бит и присвоение
>>= сдвиг вправо и присвоение
&= битовый AND и присвоение
^= битовый XOR и присвоение
|= битовый OR и присвоение

примеры
деление и присвоение
$ a=10
$ echo $(( a/=5 )); echo $a
2
2

остаток от деления и присвоение
$ a=10
$ echo $(( a%=3 )); echo $a
1
1

сумммирование и присвоение
$ a=10;echo $(( a+=3 )); echo $a
13
13

отнимание и присвоение
$ a=10;echo $(( a-=3 )); echo $a
7
7

сдвиг влево и присвоение
$ a=3;echo $(( a<<=1 )); echo $a
6
6

обращаю внимание что при сдвиге слева новый бит он нулевой 
тоесть 
было   11
стало 110

сдвиг вправо и присвоение
$ a=15;echo $(( a>>=1 )); echo $a
7
7

было 
1111
стало
0111


битовый AND и присвоение
$ a=15;echo $(( a&=6 )); echo $a
6
6

тоесть 
15=1111 AND 
 6=0110 
---------
   0110 


битовый XOR и присвоение
$ a=15;echo $(( a^=6 )); echo $a
9
9

тоесть 
15=1111 XOR 
 6=0110 
 -------
   1001 

битовый OR и присвоение
$ a=15;echo $(( a|=6 )); echo $a
15
15

тоесть 
15=1111 OR 
 6=0110 
 -------
   1111


далее. еще обращаю вимание на важный момент:
 операции id++ id-- они увеличивают\уменьшениют на один значение переменной
и переприсваивает это значение этой переменной
несмотря на то что id++ id-- не имеет никакого знака равно как скажем вот здесь "+="
тоесть помне было бы более правильно если бы вместо "id++" было "id++="
это совпадало бы по синтаксису с *= /= %= += -= <<= >>= &= ^= |=
из этого  я бы  сформулировал правило о том что переменную меняет только 
та команда у которой есть = за исключением id++ id-- они меняют переменную хотя
в себе несодержат =
нам очень важно понимать поменяет ли (( выражение)) переменную внутри или нет.

примеры на эту тему
здесь пример меняет переменую потому что есть знак =
$ a=15;echo $(( a*=6 )); echo $a
90
90

вот пример где значение перменной меняется хотя знака "=" нет
также интересно отметить что echo $(( a++ )) возвращает 15 а не 16
$ a=15;echo $(( a++ )); echo $a
15
16

меняем переменную потому что здесь есть "="
$ a=15;echo $(( a=16 )); echo $a
16
16

еще хороший пример. значение перемменной неменяется потому что нет знака "="
$ a=15;echo $(( a>>1 )); echo $a
7
15

а вот пример когда уже битовый сдвиг плюс переприсвоение переменной происходит потому что 
есть знак "="
$ a=15;echo $(( a>>=1 )); echo $a
7
7

операции которые еще поддерживаются:
       - +    unary minus and plus

что такое унарная мат операция. это операция которая требует только один аргумент 
( в отличие от обычной мат операции которая требует два аргумента).
по факту унарный минус это такая операция которая делает то что если у нас есть
какой то аргумент то унарный минус из него создает число противоположное. тоесть
было 2 стало -2. было  -2 стало -(-2). унарный плюс вобще по мне нихера неделает ибо
он ничего неменяет. унарный минус и плюс это операция высшего порядка выполняется первой.
примеры
$ n=10; echo $(( -n ))
-10

$ n=-10; echo $(( -n ))
10
важно отметить что сама переменная n неменяется.

как баш отличает унарный минус от бинарного(стандартного ) минуса.... хм.. незнаю.
но вот пример
$ n=-10; echo $(( 1 - -n ))
-9

здесь один минус бинарный а второй унарный. по сути мы имеем 1- -(-10)=1-10=-9




следущая операция:
       ! ~    logical and bitwise negation
переходим к булевым операциям и битовым операциям одноврмеенно

по поводу двойных скобок в man bash сказано - If the value of the expression is non-zero, the return status is 0; а 0 это булевский TRUE.
таким образом если у нас неноль то код возврата TRUE
примеры
$ (( 1 )) && echo true || echo "false"
true
$ (( 100 )) && echo true || echo "false"
true
$ (( -100 )) && echo true || echo "false"
true
$ (( 0 )) && echo true || echo "false"
false
$ (( 5>4 )) && echo true || echo "false"
true
$ (( 5<4 )) && echo true || echo "false"
false

так вот ! это булевский NOT

$ (( ! 1 )) && echo true || echo "false"
false

важно то что ! нельзя  ставить вполтную к числу  обязатеьно отдельно.
$ (( !1 )) # здесь получаем ошибку
bash: !1: event not found

еще пример
$ (( ! 5>4 )) && echo true || echo "false"
false

переходим к "~" bitwise negation тоесть эта операция которая унарная кстати и она что делает
она берет число в бинарном виде и нули превращает в единицы а единицы в нули.
скажем было 0000 стало 1111.

закончил вот на этом
$ echo $(( ~ 0 ))
-1
$ echo $(( ~ 1 ))
-2
$ echo $(( ~ 100 ))
-101
типа что за прикол? 
============================
============================
щас будем разбирать. 

начнем с того как на компе кодируются отрицательные числа.
во первых надо понять что в конечном итоге все данные на компе имеют вида байта или нескольких байт тоесть это некоторый кусок битов. 01010101010101010101010101010
поскольку все операции идут  в цпу то будем рассматривать в качестве хранилища этих битов регистр общего назначения в цпу. 32 бита или 64 бита. будь это отрицательное для нас число 
или положительное внутри регистра в любом случае никакого знака минус небудет. там будет сидеть 32 либо 64 бита нулей и единиц 010101010101010101001.

разберемся какой вид имеет отрицательное для нас число внутри регистра.
вопросы: 
"понимает" ли цпу какое число в его регистре положительное или отрицательное?
навскдку действительно непонятно как обьяснять цпу или он сам это понимает отрцательное
число лежит в регистре или положительное?
как цпу работает с отрицательными числами как он арифм операции с ними выполняет?
начнем разбирать.

section .text
global _start

_start:
    mov ax, 0xA1
    sub ax, 0x30


    xor rdi, rdi
    mov rax, 60d
    syscall


тут я вспоминаю что 16 битный регистр AX состоит из двух 8битных регистров AH и AL
        AX
------------------
| AH    |   AL   |
------------------

из программы я увидел что AL это дейтсвиельно младший байт в AX
(gdb) print /x $ax
$3 = 0xa1
(gdb) print /x $ah
$4 = 0x0
(gdb) print /x $al
$5 = 0xa1


тоесть поскольку 0xA1 это 8битное число. то оно должно быть загружено в младший байт
и мы видим что AH=0 а AL=0xa1

после операции substraction
мы имеем

(gdb) print /x $al
$6 = 0x71

(gdb) print /t $al
$9 = 1110001

$ echo "obase=16;ibase=16; A1-30" | bc
71

$ echo "obase=2;ibase=16; 71" | bc
1110001


здесь все понятно все ожидаемо. A1 > 30 поэтому результат точно положительный. 
здесь пока все понятно. бинарный вид ответа полностью понятен. 

теперь отнимем наоборот 0x30-0xA1 тоесть от меньшего числа отнимаем большее число.результат заведомо отрицательный.

кстати вот флаги после SUB операции:
(gdb) info registers eflags
eflags         0x206	[ PF IF ]


итак отнимаем 0x30-0xA1
смотрим состояние регистров после операции SUB
		 0x0000000000400080 <+0>:	mov    ax,0x30
=>	 0x0000000000400084 <+4>:	sub    ax,0xa1


(gdb) print /x $al
$3 = 0x8f

(gdb) info registers eflags
eflags         0x293	[ CF AF SF IF ]

0x30=00110000
0xA1=10100001

отнимаем
	00110000
	10100001
  ---------
 я вычитать бинарно неумею но комп на выдал в качестве ответа
  10001111

поступим от обратного. прибавим ответ к вычитаемому

10001111
10100001
---------
00110000

в итоге да мы получили то число из которого вычитали.
правда происходит активация флага переполнения.
итак стало понятно что делает комп когда вычитает большее число из меньшего.
он срабатывает как одометр на машине.

мы отнимали 0x30-0xA1 это  48-161. комп по идее должен был отработать при отнимании
как одометр. тоесть идея какая мы имеем счетчик на 48км и нам надо проехать 161 км.
и одометр работает в обратную сторону. тоест машина проедет 48км счетчик при этом станет 0.
и потом он начнет откручиваться в обратнку сторону еще 161-48 км = 113км и счетчик будет показывать вначале 0 потом 255(max число для 8бит регистра) потом 254 итд.
значит в итоге счетчик  должен показать 255-113+1=143
сверяем с ответом от цпу . его ответ 
(gdb) print /x $al
$3 = 0x8f

0x8f = 143(dec)
совпало!

теперь стало совершенно понятно как в цпу работает побитовое отнимание. 
оно работает как одометр машины который крутится в обратную сторону когда едет машина.
тут важно отметить что через регистры общего назначения происходят арифметически операции
для целых чисел с точки зрения цпу. ну или давай скажем так цпу незнает ни что такое целые
числа ни что такое с плавающей точкой ни что такое числа положительные ни что такое числа
отрицательные. для него этого ничего нет. у него только есть регистры с битами.
далее мы натарвливаем команду на цпу такую как SUB подсоввывая в качестве источников данных
биты из регистров общегон назначения и цпу далее манипулирует битами в этих регистрах 
согласно некоторых микросхемам транзисторов внутри. для цпу суть операций выглядит в том
что он берет оттуда биты маниплирует ими и обратно помещает некотрый набор битов вот и все.
для цпу нет никаких чисел у цпу нет таких абстракций. у него есть набор битов и он ими должен както сманипулировать согласно команде которую ему указали. на выходе получает набор битов.
а дальше это уже наше дело человека както интерпретировать эти биты.  так вот получается
что если каждый бит в регистре цпу мы уже как человеки будем ставить в соотвествие с цифрой на одометре(просто одометр с бинарными цифрами 0 и 1 а не  с десятичными 0 1 2 3 4 5 6 7 8 9) то мы увидим что данные биты кодируют целые положительные числа. есть прямое соотвествие.
тоесть создатели цпу они так внутри создали микросхемы что биты в регистрах общего назначения
имеют смысл целых чисел  через двоичную запись при условии что мы над ними выполняем
арифметические операции. тоесть при запуске команды 
	sub ax, 0xA1
цпу так запрограммирован изнутри что биты начинают иметь физический смысл целых чисел 
положительных. и над ними производится операция вычитания.
итак еще раз ответ на вопрос есть ли внутри цпу целые числа или положительные числа
или отрицательные числа - внутри цпу есть биты. биты это как лампочки на елке 
это просто биты просто лампочки висящие на грозди. они в целом к числам неимеют отношения.
так же как пять слонов стоящих вряд они к числу 5 неимеют отношения прямого. это мы люди
делаем такое абстрактное соотношение.  но создатели цпу так настроили эти биты что 
в целом есть прямая связь между положительными целыми числами в двоичном формате 
и битами в регистре. пример
mov ax, 0xA1

здесь мы говорим чтобы в регистр AX было записано число. но число это абстрактное понятие в голове людей это не банан не апельсин это обьбект которого нет в природе в физ форме в физ виде. это либо клякса на бумаге либо картинка в голове у человека. у цпу нет мозга так что 
когда мы просим  в цпу записать число по факту мы просим в регистре активировать определенные
биты которые физически представляют собой какито транзисторы с какимто физ характеристиками
которые мы там хотим выставить. но вот если мы представим что внутри цпу есть биты
и если мы соотнесем биты в цпу с битами на бумаге у чисел в двоичной системе то тогда
мы как бы можем сказать что внутрь цпу было записано число. 
теперь надо понять а что за числа мы можем записать в регистр. 
мы видим в команде число 0xA1. это шестнадцатеричное число. но еще раз хочу подчеркнуть
что мы нечисло пихаем в регистр. просто hex число это удобная форма для записи на бумаге
для програмирования того факта что мы просим в регистре активировать биты. тоесть
 в под капотом наша команда 
mov ax, 0xA1
она просит выставить биты
mov ax, 1010 0001

просто в битовой форме было бы неудобно писать команды.
так вот возникает вопрос можно ли как то наладить соотвесвтие между битами 
и числами. если мы будем использовать двоичную систему счисления чисел то она 
волшебным образом совпадает с битовой картинкой.

поговорим про двоичную систему счисления.
система счисления это система обозначения числа.
десятичная система выглядит так

12356 = (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0

таким образом привычная нам форма записи числа это на самом деле коэффициенты
многочлена.прикол.

так вот в двоичной системе число обозначаетс вот так и вот его какой смысл
этого обозначения:

01010 = (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0

отрицательное число в одной и другой системе счисления(дурацкое слово лучше бы слово 
обозначение использовали)

-12356 = - { (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0 }
-01010 = -  { (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0 }

как мы видим в двоичной системе счисления в математике также спокойно есть знак минус.

теперь обозначение чисел с плавающей точкой

12356.23 = [ (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0 ] +[ (2)*10^-1 + (3)*10^-2 ]
 + 
и точно тоже самое для двоичной системы счисления!

01010.01 = [ (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0 ] + [ (0)*2^-1 + (1)*2^-2 ]

как видим в математике в двоичной системе счисления нет проблем ни с минусом ни с 
дробными числами!

возвращаемся к цпу. создатели цпу что касается регистров общего назначения они ( я утверждаю )
запрограммировали так обработку битов внутри цпу что они представляют собой ровно теже биты теже коэффициенты в многочлене что и биты в двочиной системе обозначения числа за исключением
того что никакой внутри цпу хрени которая бы отвечала за знак минус нет и никакой хрени 
которая бы отвечала за дробную часть числа в двоичном представлении тоже внутри цпу 
нет при условии что мы говорим про регистры общего назначения.
таким образом биты в регистрах общего назначения можно соотнести с числами обозначаемыми 
через двоичную систему счисления\обозначения при условии что у нас нет знака минус и что нет дробной части. тоесть мы получается говорим только про целые положительные числа.
вот это вот и есть физический смысл битов внутри регистров общего назначения!
таким образом регистр общего назначения по своему физ смыслу это всегда целое положительное
число записанное в двоичной форме! и создатели цпу настроили схемы обработки битов внутри 
этих регистров как обработку чисел. поскольку битвая форма регистра нам позволяет 
обозначить только число положительное ибо минуса в цпу нет носителя и также в регистре 
нет носителя дробной части (регистры общего назначения) то поэтому математические\арифеметичекие операции могут иметь место только по своему физическому смыслу
только с целыми положительными числами. тоесть регистр по своей природе через себя может 
показать только целое положительное число в двоичной форме. никакого другого числа регистр общего назначения показать неможет у него нет для этого носителей минуса и дробной части.
теперь мы поняли\доказали что физ смысл битов в регистре это биты числа в двоичной системе обозначения\счисления причем это число получается является только положительным 
и только целым. 
в самом деле вот берем число -01010101.0101010
оно и отрицательное и дробное мы его никак в регистр всунуть неможем ибо у регистра
нет ни носителя "-" ни носителя дробной части. я говорю о регистре общего назначения.
так создатели цпу и сделали! ну а раз нет внутри регистра ни носителя минуса ни носителя
дробной части то внутренние схемы цпу они рассматривают биты регистра как целое положительное
число и никак иначе.
в самом деле как может быть результатом арифмт операций над двумя положительными целыми
числами отрицательное дробное число если этот резулльтат надо записать запихать в этот же регистр а у него нет таких хреней носителей чтобы отобразить минус или дробную часть.
поэтому как работает операция вычитания на общих регистрах. если одно число больше другого
то все биты обнуляются а потом они в обратном порядке отматываются то есть в точности как работает одометр в намашине если его крутить в обратном направлении.тоже самое касется сложения двух чисел кога результта превышает битность регистра. регистр доходит до макс значения потом обнуляется и начинает заново набирать. точно как одометр.
таким образом между цпу и регистром и математичкой двоичных чисел есть соотвествие но неполное. в математике если из меньшего вычесть большее то появляется минус. в цпу
происходит нечто другое. тоже самое касается деления или случая когда результат превышает
битность исходных чисел. во всех этих случаях между математичкой и цпу нет соотвествия.
цпу ведет себя тут кастомно.  в случае сложения и вычитания он ведет себя как одометр.

- более детально прояснить еще раз физ смысл результата сложения 
реультат прервышает битность регистра

что касаетя операции сложения то тут точно схемы цпу настроены так что 
биты регистра обрабатываются ALU цпу в точном соотвесвтии с логикой сложения целых положительных числе в двочином обозначении. только еще есть вот такой момент - 
вот мы складыаем 200 и 255. 200 уже лежит в регистре а 255 мы к нему прибавляем.
регистр максимум может нести на себе число 255. так вот
цпу он докручивает регистр с 200 до 255. потом он его обнуляет и потом еще его докручивает
прибавляет  к нему такое число чтобы суммарная докрутка от 200 до 255 и потом от 0 до числа X 
составила бы число 255 которое мы прибавляем. вот каков физ смысла того числа в регистре которое мы получаем при операции суммирования когда ответ превысил бы битность регистра.
для операции вычитания тоже самое только одометр откручивается в обратную сторону.

итак в случае арифм операций над регистром его биты обраюатываются цпу в точности такойже
как обрабатывались бы биты двоичного положительного целого числа!
тоесть в случае арифм операций биты в регистре это непросто биты а символы в двоичной записи для целого положительного числа. так их обрабатывает ALU цпу и результат арифмт операции 
записыватся в биты регистра в точности как выглядела бы двоичная запись результата (если результата невызывает ситуация переполнения). если переполнение то я описал выше.


теперь оставим случай арифм операций и рассмотрим просто операцию записи в регистр
	mov ax, 0xA1
можно ли в этом случае сказать что биты  в регистре соответвуют символам в двоичном
числе. 0xA1 это целое положтельное число записанное в шестнадцатеричной форме которое затем
комп преобразует в целое положитеьное число завписанрое в двоичной форме и согласно этой форме
цпу выставляет биты. поэтому из этого  я считаю что нетолько в случае арифм операций но и в случае записи числа в регистр обшего назначения его биты можно трактовать как символы двоичной записи числа получается что и в этом случае это положительное целое число записанное в двоичной форме в регистр в форме битов.

таким образом на мой взгляд биты внутри регистра общего назначения это непросто лампочки
это реально всегда целое положительное число. так их можно всегда трактовать. 

отсюда следует вывод что для работы с отрицательными числами или дробными числами регистры обшего назначения непригодны. и чтобы нам както работать например с целыми отрицатеьльными
числами на  базе регистра нам нужно както дополнительно изголяться.  это похоже на то что у нас есть экран телевизора но входной сигнал это азбука морзе поэтому нам нужно както получая азбуку морзе самим руками ее преобразоывать в картрнку на экране и наоборот. имея картинку на экране нам нужно ее както самим трансфорировать в азбуку морзе и уже именно ее пихать в радиоэфир. также и программа если она хочет работать с отрицательными числами то ей както надо
изголиться чтобы это делать на базе исключительно только положительных чисел с которыми работает цпу на базе регистра. его ALU микросхемы.

нутоесть для примера опишу работы с дробными числами. вот наша програма хочет сложить
1.23 и 2.45. как ей это сделать на базе регистров общего назначения и блока ALU цпу который умеет только складывать целые числа. программа должны вначале сунуть в регистр дробную часть
и потом прибавить к ней другую дробную часть

mov ax,23
add ax,45

далее прогармма должна считать эту цифру. далее также сложить целые части

mov ax,1
add ax,2

считать это число. и отобразить на экране 3.78
таким образом на базе целых положительных чисел мы провернули операцию сложения дробных чисел.

похожую мудоту программа должна суметь сделать для отрицательных чисел.


итак еще раз важный вывод микросхемы цпу настроены так что они обарабывают биты регистров
общего назначения (особенно во время арифм операций. кстати говоря арифм операция уже по крайней мере подразумевает что мы работаем с числами а не лампочками) как обрабатываются биты
у целых положительных числе в двоичном исчислении. каждый бит регистра соотстветует биту
в двоичном числе. это очень важный вывод. ( а то я тут встречаю выскзывания что цпу понятия не имеет ни о числах ни очем . мол у него просто идет обработка битов. обработка битов да но логика обработки этих битов вточности следует обработке битов у аналогичного двоичного числа!
поэтому биты внвутри регистра общего назначения это непросто биты это целое положительное 
число в двоичном виде!
)

а как же нам тогда на практие складывать числа результат сложения которых будет больше
чем размер регистра например

100+200.

первый вариант так как мы будем иметь высталвенный на цпу флаг переполнения то мы можем
просто слать нахер тогда в порграмме. мол слишклом большие числа.
точно незнаю но можно вот как. мы словим флаг переполнения и получим число в регистре 44
( потмоу что регистр со 100 докрутит до 255 потом обнулит и еще докрутит до 44).
и тогда можно на экране в простейше случае вывести мол ответ это 255+44+1.
плюс один это потому что был переход с 255 на ноль. он сьел одну единицу.
где 255 это макс число для регистра 8бит мы его знаем заранее из размера регистра
и 44 мы получили лажещим в регистре.да конечно это неконечный красивый ответ но почти ответ
лучше чем ничего.

переходим к отрицательным числам.
10-200

mov al,10d
sub al,200d

 в результате в al будет лежать 66d (вначале окрутится 10 до нуля. потом ноль до 255 и потом еще до 66. всего будет прокручено на -200)

как нам из полученного результата +66 понять что ответ -100 пока непонятно.

пока оставим и передвигаемся  к теме как мы сами для себя ( не цпу а именно мы) могли бы
обозначать отрицательные числа используя для этого положительные числа цпу. тоесть энкодинг 
отрицательных чисел сугубо для нашей пользовательсктй программы используя положительные
числа цпу. 


один вариант это взять старший бит и кодировать  отрицательное число через  выставление старшего бита  в 1. а оставшиеся биты использовать для абсолютного значения.

тогда можно иметь такую кодировку

1001 = -1
1010 = -2

такой тип кодирования назыается "Sign-Magnitude representation".
переводится примерно как "кодирование по схеме знак-величина"

получается что мы при таком кодировании
цпу видит биты 1001 как число 9 наша же программа для себя понимает это как число -1
цпу видит биты 1010 как число 10 наша же программа для себя понимает это как число -2

сразу про минус такого кодирования. 
мы неможем выполнять арифметические операции на цпу для наших чисел потому что с точки 
зрения программы мы складываем -1 + -2  а точки зрения цпу мы будем складывать 9 + 10
ну и вот посмотрим что мы будем получать. 

1001
1010
-----
0011 с флагом переполнения
 
с точки зрения цпу мы получили число +3. с точки зрения нашей программы мы тоже получили 
число +3 потому что старший бит неравен единице. по модулю правильно по знаку неправильно.
но по идее наша программа может учитывать
то что сработал флаг переполнения и это может быть нашей программе сигналом что число получено
отрицательное а не положительное.

а вот еще пример тогда рассмотрим.

1001 = -1
0010 =  2

сложим
1001
0010
----
1011

получили с точки зрения цпу 11 с точки зрения программы получили -3 а должны же были 
получить +1

так ну походу приходим к выводу что получать верные ответы при арифм операциях 
при схеме кодирования "sign-magnitude" неполучается при использовании ALU на цпу который
работает с класическими положительными числами. так что от такой схемы надо отказаться 
либо делать на цпу отдельный ALU блок который бы распознавал и работал бы именно с этой кодировкой.тоесть игнорировал бы старший бит при арифм операциях. по факту такую кодировку
неиспользуют в жизни в итоге. 

ну так уже для добавки скажу что 
есьт еще один минус у этой кодировки
у нас появляется два нуля.

0000 = 0
1000 = -0

что как бы неклево.


еще скажу что описанная выше схема кодирования отрицательных чисел характерна тем что 
старши бит отвечает только за кодирования(наличие или отсуствиие) знака минус. больше этот бит
никакого значения на себе ненесет. фишка в том что предтавленная (ниже) другая система кодирования отрицательных чисел  тоже имеет старший бит выставленный в 1 если число отрицательное но этот старший бит нетолько в себе несет признак о том есть ли минус
у числа или нет но и также участввует в кодировании величины числа. это важно. потому что
у представленной выше схемы если заменить старший бит с 1 на ноль то мы автоматом легко получаем из -5 сразу 5. та схема что ниже у нее если заменить старщий бит с 1 на ноль то 
это повлияет нетолько назнак но  и на величину числа такчто вот так вот просто прервратить -5 в 5 уже неработает.

Далее. рассматриваем следущйю схему кодирования отрциалеььельных чисел через положительные.
она назыавется "первая обратная форма" - "1's Complement Representation".
перевод литературный а недословынй. дословный по мне какойто хреновый.
суть схемы:
		старший бит если он 1 обозначает что число отрицательное (для нашей программы а не для цпу
для цпу по прежнему число положительное).
		если старший бит 0 то оставшиеся биты обозначают величину.
пример
0100 = старщий бит 0 значит число положительное. оставшиеся биты 100 обозначают величину 4
значит для нашей проги это число +4. для цпу это тоже +4
		если старший бит 1 то число для программы считается отрицательным (для цпу оно по
прежнему положительное) а оставшиеся биты показывают величину но их нужно инвертировать и 
только после этого смотреть виличину.
пример
1010 = старщий бит 1 значит это число с минусом для нашей проги. оставшиеся биты 010 мы 
их инвертируем получаем 101 и вот теперь уже смотрим что это за число . это 5 значит 
для нашей проги это число -5. для компа же по прежнему это число 9.
	как на практике программа могла бы работать  с такой кодировкой. вот она из памяти в регистр
считала байт. пусть у нас 4битная память и 4битный регистр. получила 1010. далее программа
видит что цпу выставил sign флаг который сигнализирует что старший бит равен 1. окей.
программа поняла что это отрицательное число. далее программа вычленяет все младшие биты
и делает их инвертирование для этого тоже есть на цпу команда. и далее уже мы получаем наше искомое отрицательное число ибо минус мы вычислили и модуль числа мы получили. 
получается с точки зрения записать в память и прочитать из памяти и распознать какое 
отрицательное число туда записали ранее эта схема работает пригодна.


		нарисуем табличку чисел в такой кодировке

биты |для      | для 
     |программы| цпу
0000 	0 				0
0001 	1 				1
0010 	2 				2
0011 	3 				3
0100  4 				4
0101  5 				5
0110  6 				6
0111  7 				7
1000  -7 				8
1001 	-6 				9
1010 	-5 				10
1011 	-4 				11
1100 	-3 				12
1101 	-2 				13
1110 	-1 				14
1111 	-0 				15


еще раз подчеркну что для цпу по прежнему все биты это сгубо положиельные числа.
это для нашей программы числа стали иметь другое значение. тоесть если программа 
считала их регистра число 14 то она для себя понимает что это для нее число -1
и наоборот если программа хочет записать в регистр число -1 то она его согласно таблице
перекодирует и сует в регистр число 14 . поому что это только для нашей программы -1 это -1
а в цпу нет нкиаких -1. там есть только 14 который имеет вид 1110.
тоесть программа тарктует битовую запись одним образом а цпу другим. 

виден минус такого кодирования в том что у нас два нуля.
биты |для      | для 
     |программы| цпу
0000 	 0 				0
1111 	-0 				15

еще минус в том что (согласно инфо от книжек) что неполучается извратится и 
получать верные ответы при арифм операциях используя ALU цпу для положительных чисел.
поэтому от такой кодировки тоже отказались в программах. потому что наша задача нетолько 
записыать в память регистры наши "отрицательные"  числа но и выполнять над ними арифм 
операции исползуя ALU cpu. а если мы будем получать неверные ответы то смысла нет.

рассмотрим следущую схему кодирования отрицательных чисел через положитеьльные.
схема называется "вторая обратна схема" "2s complement representation"
схема такая же самая как предыдущая но чуть чуть другая.
	старший бит если 0 то число считается положительное если 1 то отрицательное
	если старший бит 0 то оставиишиеся биты кодируют величину
	если старший бит 1 то оставшиеся биты кодируеют величину но чтобы ее узнать надо 
инвертировать биты и прибавить единицу.
пример для отрицательного числа
1010 = старший бит 1 значит знак минус. оставшиеся биты 010 мы их инвертирует полчаем 101
и прибавляем единицу тоесть
101
001
---
110

это число 5. значит итоговое число это -5

распишем таблицу в этой кодировке

биты |для      | для 
     |программы| цпу
0000 	0 				0
0001 	1 				1
0010 	2 				2
0011 	3 				3
0100  4 				4
0101  5 				5
0110  6 				6
0111  7 				7
1000  -8 				8
1001 	-7 				9
1010 	-6 				10
1011 	-5 				11
1100 	-4 				12
1101 	-3 				13
1110 	-2 				14
1111 	-1 				15


сразу здесь замечаем что положительные для нашей программы числа они и для цпу ровно 
такие же самые. то есть 0-7 для нашей проги это 0-7 для цпу. тут все просто.

сразу видна фишка что теперь у нас один ноль в этой кодировке а не два. это хорошо.
втора фишка наконец то мы ее получили мы можем складывать и вычитать числа пользуясь ALU цпу
и получать верные ответы с точки зрения нашей программы. еще раз фишка в том что с точки зрения цпу и его АЛУ мы имеем только положртельные целые числа и выолняем с ними арифм операции. а так счастливо совпадает что полученный результат верно кодирует число уже  с точки
зрения нашей программы. 
пример.
хотим в нашей проги посчитать 4+(-5).
согласно табллице
4(для нашей программы)=0100=(для цпу это тоже 4)
-5(для нашей проги)=1011(для цпу это 11)

суем в один регистр 0100
во второй регистр суем 1011
далее просим цпу сложить эти числа.
еще раз подчеркну что цпу складывает не 4 и -5 а 4 и 11

0100
1011
----
1111

получили 1111
для цпу это 15
но наша программа считывает это число заглядыает в таблицу понимает что получили -1
 а это то что нам надо потому что в математике 4-5=-1

еще пример
хотим в программе почитать -2-6= -2 + (-6)
-2 согласно таблице = 1110 суем его  в первый регистр (для цпу это число 14)
-6 согласно таблице = 1010 суем его во второй регистр ( для цпу это число 10)

скадываем эти числа пользуясь АЛУ цпу. цпу считает по факту что склдаыает 14 и 10
1110
1010
-----
1000 с флагом переполнения

флаг переполнения игнорируем.
получили 1000 . согласно таблице для цпу это число 8 а для программы это -8
и по математика -2-6=-8

получили поразительную вещь. хитро кодирую  отрицательные числа с точки зрения нашей программы
в положительные числа для цпу и используя АЛУ цпу для обработки положительных чисел 
мы получаем верные ответы с точки зрения арифметики над отрицательными числами! круто!
это значит что нам ненужно внутри цпу заводить доп микросхемы для распознавания класса отрицательных чисел  и ненужен блок арифм операций над отрицаттеьными числами.
это очень хорошо. единственное что на данном этапе это верно для целых чисел и для операций
сложения вычитания. как там обстоят дела с дробными числами и с операциями умножения деления
я пока незнаю.  но четко видно что складывать и выичтать целые отрицательные числа мы уже можем на цпу пользуясь его аппаратом обработки положительных чисел. цпу понятия неимеет обрабатывая положительные числа что по факту для нашей прогармы он получает отрицательные числа.

мы можем вычислаять такие примеры как
2-6= 2+ (-6)
6-2= 6+ (-2)
2+6
2-(-6)=2+6
-2-6=(-2) + (-6) 

также совершенно понятно важное дополение что для каждого размера регистра (сколлько в нем бит) у нас есть некоторый диапазон чисел с которым мы можем работать и получаеть коректные ответы. если мы выходим за этот диапазон то мы будем получать некоректные ответы и тогда 
надо сигнализировать что мы этот случай посчитать неможем.
для n=4 бит наш диапазон это [-8;7] это значит что аргументом в примерер могут быть 
только числа из этого диапазона
например
-8+7 = коретный вариант
4-6 = коректный вариант
-9+1 = некоректный вариант потому что через 4 бита мынеможем запрограмировать число -9

ну это понятно. но есть еще условие что резулттат примера неможет тоже выходит за рамки [-8;7]
потому что результатто у нас тоже записывается  в регистр из тех же 4 бит. а если результат превыешает 4 бита то как мы можем его отобразить? никак. пример

-8-4= -8 + (-4)= -12 результат (число) превышает диапазон. значит тут надо писать что ошибка.
посмотрим как это на практике.
-8 = 1000
-4 = 1100


1000
1100
----
0100 и флаг переполнения а флаг sign сброшен
получили сточки зрения цпу 4 и сточки зрения программы тоже 4. а нам надо было -12.
поскольку мы складывали два отрицательных числа то мы точно знаем что должно получиться 
отрицательное число. а поскольку флаг sign сброшен ( так как старший бит 0) то мы в программе
понимаем что мы превысили лимит снизу. значит выдаем ошибку в программе.

еще пример 
7+2=9. 9 число оно тоже выходит за диапазон [-8;7]
смотрим

0111
0010
-----
1001 

флаг переполнения неустановлен
флаг sign установлен

получили 1001 для цпу это 9 для программы это -7. причем флага переполнения нет.
но флаг sign устанолвен. так как мы знаем что сумма положительных чисел должны быть 
положительна то мы в программе понимаем что мы превысили лимит сверху. выдаем ошибку.

итак получается правило флаг переполнения мы игнорируем.
если складываем два положительных числа и получаем устанолвенный sign флаг 
значит мы превысили лимит сверху. выдаем ошибку.
если мы складыаем два отрицательных числа и получили сброшенный флаг sign то мы 
превысили лимит снизу и выдамем ошибку.

круто!
тогда действиельно если наша программа использует "вторую обратная схема" (мне кажется по русски эта схема называетс схема дополнения до двух но это неточно) то мы можем успешно
складыать и вычитать положтельные и отрицательные целые числа. диапазон чисел определяется
размером в битах регистра.
при n=4 это [-8;7]
при n=8 это [-128;127]

при n=k это [-0.5(2^k);{0.5(2^k)}-1]
заметим что 0.5(2^k)=(2^k)/(2^1) = 2^(k-1) значит преобразуем формулу
при n=k это [-2^(k-1);2^(k-1) - 1 ]

визуально удобная формула выглядит так
при n=k , [-z,z-1], где z=2^(k-1)


получается при n=16, z=2^15=32768 ,значит [-32768;32767]

при n=64, z=2^63, значит это [-2^63; 2^63-1] 
или 
[9 223 372 036 854 775 808; 9 223 372 036 854 775 807]



теперь надо понять почему "вторая обратная схема" дает верный результат 
при арифметических операциях.

для этого рассмотрим на первом шаге вспоминаем о чем я говорил гораздо выше - что происходит с регистром когда мы в него слкадываем число которое превышает его размер. регистр 
работает как одометр на машине. тоесть

1111
0001 +
-------
0000

когда на одометре максмимаьная цифра и мы добавляем еще один то одометр откручивается
до начала до нуля а потом идет все сначала.


0000
0001 -
-------
1111

когда на одометер ноль и мы если его скручиваем на 1 назад то на нем вылезаем 
максимальное число.

так работат арифметика на регистре при проходжении за максимум и минимум.


на втором шаге(чтобы понять почему работает арифметика "второй обратной схемы") рассмотрим еще одну кодировку:
называется она "одометрная кодировка" предложена в книге по асемблеру BOB NEVELN.
пусть у нас есть одометр. из пяти цифр и сейчас он показыавает 99 999км и мы проезжаем 2 километра.
одометр прокрутится в 00 000 и далее прокрутится и покажет  00 001 км. а теперь рассмотрим 
уровеннеие из математики (забудем про одометр на время)

x + 2 = 1
в математике x= -1

значит в математике у нас было -1 мы к нему добавляем 2 и получаем 1.

возвращаемся к одометру у нас было 99 999. мы проехали 2 километра и он показал нам 1.

возникает идея о том что если мы будем  считать показание 99 999 на одометре
как -1 для нашей программы то добавояя километры на одометре мы получим на одометре 
ровно тоже число которое мы получим считая уравнение в математике тоесть.

в математике

-1 + 10 = 9

на одометре

99 999 + 10 = 9

таким образом 99 999 на одометре сооответвует -1 для нашей программы в математике.

возьмем на одометре показание 99 998 . добавим на одометре 3 киломтра получим на одометре показание 1 . тоесть

99 998 + 3 = 1


рассмотрим математику уравнение

x + 3 = 1 
получаем x=-2

теперь рассмотрим пример когда к -2 мы прибавляем 10

-2 + 10 = 8

рассмотрим когда мы к одометре 99 998 добавляем 10 километров

99 998 + 10 = 8

таким образом мы видим что добавление к 99 998 любого числа дает тот же ответ как добавление 
в математике к -2 того же числа. 

это нам дает что что вот мы хотим узнаь сколько будет

-2 +100.
мы выставляем на одометре 99 998 и проезжаем на машине 100 километров и сколько он покажет
такой ответ и есть. одометр покажет 98км

значит -2 + 100 = 98

таким образом мы можем составить таблицу соотвесвтия между отрицателным числом из математики
и показанием на одемтре

-1 				99 999
-2 				99 998
-3 				99 997
-99 999 	1
-100 000 	0


таким образом мы получаем через одометр примитивный калькулятор. если нам надо решить пример
-3 + 15. мы лезем в таблицу смотрим какое число соответвует -3

-3 соотвствует 99 997
мы выставляем на одометре 99 997. далее мы проезжаем 10 километров (ну или условно говоря делаем 10 щелчков на одометре) и та цифра что он высветит это ответ.
одометр покажет 12
значит -3 + 15 = 12

таким образом мы имеем некиий суммирующий калькулятор в форме одометра. он по своей природе
умеет суммировать только положительные числа. но мы исхитрились его приспособить для суммирования отрицательных чисел с положительными.

далее мы замечаем что одометр это 5 битное устройство , 5 битное число с десятичной системой счисления.
а в цпу у нас есть такой же одометр это регистр. у него скажем 4 бита и двоичная система счисления. и главное что АЛУ цпу он работат с регистром при операции сложения ровно также
как одометр на машине очем мы выше говорили.

рассмотрим регистр показывает 

1111 = 15
мы добавляем +2 это 0010

1111
0010 +
------
0001

получаем 1 
таким образом если верхний одометр имел диапазон от 0 до 99 999 
то наш регисррвый одометр имеет диапазон от 0 до 15.
при прохождении 15 он обнуляется ровно также как одометр машины при прохождении 99 999 он обнулялся.


так вот из вернего примера мы видим что 
на регистре было 15 потом прибавили 2 и получили 1. 
в математике x+2=1 имеет место когда x=-1

значит по аналогии -1 из математики соотсвтетует 15 на регистре. прибавляя на цпу к 15 число
Y мы будем получать ответ аналогичный как тому как в математике -1 + Y

-1 +y ( в математике)
15 +Y ( на цпу в регистре)

ссотавляем таблицу

-1		15  1111
-2		14  1110
-3		13 	1101
-4		12 	1100
-5		11 	1011
-6		10 	1010
-7		09  1001
-8		08 	1000
-9		07 	0111
-10		06 	0110
-11		05 	0101
-12		04 	0100
-13		03 	0011
-14		02  0010
-15		01 	0001
-16		00 	0000

в левой колонке наше число из математики которое интересует нашу программу
вторая колонка это число в регистре внутри цпу которое соответвует первой колонке
третья колонка это битовая картинка внутри регистра

хотим узнать сколько будет -14 + 10
согласно таблице для числа -14 надо на регистре положить число 02 или в битовом виде 0010

а далее надо прибавить к тому что лежит в регистре то что мы хотим прибавиить в нашем случае
это 10 . 10 = 1010

получается с точки зрения цпу мы прибавляем 14 и 10

0010
1010
-----
1100 нет флага переполнения

1100 это 12 а согласно таблице это также может быть -4

получается в целом хорошая схема и она как работает но возникает непонятка с результатом
как его трактовать. толимы получили 12 то ли -4. 

рассмтоим еще пример когда модуль отрциательного числа меньше положительного

-4 + 10

согласно таблице для -4 в регистр надо засунуть  12 =	1100
10 = 1010

значит надо приавляем на цпу к 12 число 10

1100
1010  +
------
0110  есть флаг переполнения

получили число либо -10 либо 6

тогда из этих двух примеров можно такое правило создать для программы.
если флаг переполенния сраотал то трактуем полученное число как отрицательное
а если флаг переполенния невыставлен то трактует резултат как положительное число.

получается при такой кодировке "кодировка одометра" можно успешно получать ответы
для арифметичских задач складываний отрицательного числа с положительным.

но есть проблема в том что если мы читаем из памяти в регистр байт то нашей программе
непонятно тли это положителное число толи отрицательное.
тоесть когда мы знаем число отрцаительное потом ишем по таблице ему соотсвтеие 
и потмо склдываем и проверяем флаг перпполения то мы точно знаем как трактовать результат. 
а вот если мы из памяти считали байт то тут нет никаких зацепок как его тарктовать то ли как
политеьное число толи как отрциательное. 

поэтому кодировку одометра надо модифицировать. 

еще раз скажу зачем нам этот огород с кодировкой отрцаттельного числа  в положительное. 
огород нужен затем чтобы внутри цпу ненужно было создавать транзисторные схемы специально 
под отрицатлеьные числа. мы хотим обойтись схемой в цпу которая умеет работать только с положительными числами. это упростит нам усттойство цпу.


итак надо модифицировать "кодировку одометра"

тогда идут на следуший шаг. до сих пор мы использовали четыре бита для кодирования числа.
теперь из всего множества чисел которые мы использовали на преддыдущем шаге мы будем
для кодирования отрицательных чисел использовать невсе а только те у которых так вышло
что старший бит равен 1. тогда половина все чисел будет кодироовать отрицаттельные числа
для нас ( для цпу по прежнему все числа положртельные) а половина для нашей программы
будет кодировать положительные числа. да мы лиштимся половины диапазона но исчезнет
неоднозначность мол это положительное число или отрицательное и при этом сохранится
также механизм о том что если мы будем складывать положительные (для цпу) числа которые ( для нас) выглядят как отрицательные с другими числами то результат будет верный.( при этом мы будем исползовать встроенный в цпу механизм сложения положитльных чисел несоздава в цпу отдельный блок по обработке отрицательных чисел).

итак берем нашу прежнюю таблица

1111 = ( для цпу это прежнему 15)
1110 = ( для цпу это прежнему 14)
1101 = ( для цпу это прежнему 13)
1100 = ( для цпу это прежнему 12)
1011 = ( для цпу это прежнему 11)
1010 = ( для цпу это прежнему 10)
1001 = ( для цпу это прежнему 09)
1000 = ( для цпу это прежнему 08)

0111 = ( для цпу это прежнему 07)
0110 = ( для цпу это прежнему 06)
0101 = ( для цпу это прежнему 05)
0100 = ( для цпу это прежнему 04)
0011 = ( для цпу это прежнему 03)
0010 = ( для цпу это прежнему 02)
0001 = ( для цпу это прежнему 01)
0000 = ( для цпу это прежнему 00)

и для каждого числа мы находим его отрицательный эквивалент но не для каждого 
а только для тех числе у которых старший бит 1.
получаем


1111 = ( для цпу это прежнему 15) | для программы это -1
1110 = ( для цпу это прежнему 14) | для программы это -2
1101 = ( для цпу это прежнему 13) | для программы это -3
1100 = ( для цпу это прежнему 12) | для программы это -4
1011 = ( для цпу это прежнему 11) | для программы это -5
1010 = ( для цпу это прежнему 10) | для программы это -6
1001 = ( для цпу это прежнему 09) | для программы это -7
1000 = ( для цпу это прежнему 08) | для программы это -8

0111 = ( для цпу это прежнему 07) | для программы это 7
0110 = ( для цпу это прежнему 06) | для программы это 6
0101 = ( для цпу это прежнему 05) | для программы это 5
0100 = ( для цпу это прежнему 04) | для программы это 4
0011 = ( для цпу это прежнему 03) | для программы это 3
0010 = ( для цпу это прежнему 02) | для программы это 2
0001 = ( для цпу это прежнему 01) | для программы это 1
0000 = ( для цпу это прежнему 00) | для программы это 0

теперь если мы из памяти скачаем байт то мы однозначно можем сказать что это за число
для нашей программы. только появилась небольшая  проблемка что 
если раньше мы могли отрицательное число брать от -1 до -15 то теперь только от -1
до -8 для наших примеров вида -8 + Y


для цпу по прежнему все эти биты это сугубо положительные числа
от 0 до 15. 
мы же в своей программе можем использовать числа от 0 по 07 как положительные трактуя их как 
числа от 0 по 07

а числа от 08 по 15 мы можем в нашей программе трактовать как числа от -8 до -1

при этом мы теперь имеем однозначность теперь понятно какое положительное (для цпу)
число кодирует положительное число для нашей программы а какое положительное (для цпу)
число кодирует отрицательное для нашей программы число.

теперь наша программа может выполнять арифметические действия с отрицательными числами
используя блок сложения на цпу для положительных чисел и полученный результат наша программа
теперь может одноазначно трактовать что это точно либо положительное либо отрицательное число.
пример

мы хотим через нашу программу сложить -7+4.
наша программа смотрит в таблицу и видит что -7 соответствует число 09 (1001)
тогда наша программа кладет в первый регистр цпу число 09 а во второй регистр число 4(0100)
и дальше просит цпу их сложить.

1001
0100 +
------
1101 флаг переполнения невыставлен. флаг sign выставлен

далее наша программа смотрим  в таблицу и видит что
1101 = для нашей программы это -3. 

данное число наша программа должна для себя трактовать как -3.
и она на экран выводить -3. получено отрицательное число потому что его старший бит 1.

и согласно математике -7+4=-3

тоесть все верно.
ну а с точки зрения цпу он сложит 9 и 4 и получил 13. но это 13 для цпу а наша программа
имеет волность трактовать полученное число как мы хотим. 

обозначим диапазон числе который можно получить для регистра размером n бит.
в рамках этих бит мы можем закодировать положительные числа [-(2^(n-1); (2^(n-1))-1] 
об этом и выше говорил.
пример n=4.  [-8; 7]

далее. вот мы научились прибавлять к отрицательному числу положительное.
как мы это делаем. мы берем отрицательное число. находим по таблице соотвутетвюущий
ему положительное число в байтовом виде и суем в регистр. и далее с даем команду
цпу добавиьт к тому что в регистре еще другое положительеное число

mov al, 0x7
add al, 0x5

проблема в том что мы ищем первое число которое нужно положить в регистр по таблице.
нужна какая то аналиическая формула как это сделать.
если это число положительное то число P которо в регистр класть найти очень просто 
это просто наше исходное число в бинарном виде. 

а вот если исходное число отрицательное то на бумаге эта формула выглдит так

P=2^n-N

P = число которое мы ищем которое хоти поолжить  в регистр.
N = положительное число обратно к нашему отрицательному
n = битность регистра. 

Также хочу подчеркнуть что первый бит у P всегда будет 1.(ествесвтенно если исходное число
отрицательное. если положительное то ноль)


для n=4 
P=16-N

окей. для числа -7 обратное ему число N=7
P=16-7=9 = 1001
mov al, 11d

значит на бумаге мы имеем формулу а как нам заставить сам комп высчитывать это P 
вместо нас. модифицируем формулу

P=16-N=(15-N)+1

рассамотрим 15-N
возьмем N=1, N=5, N=7.
обращаю внимание что N у нас положительное потому что оно обратное число к нашему 
отрцаительному.

поскольку N  у нас положительное то мы можем его представить в виде битов в регистре
и выполнить операцию вычитания в двоичном виде на бумаге ( на цпу неможем потому что наш цпу на данный момент неимеет блока вычитания положительных чисел поэтому пока только на бумаге).

Еще раз почему  я невыбрал чтобы N был отрицательный. почему  я выбрал чтобы N был обратный к нашему числу. потому что я хотел чтобы N был положительный. почему. потому что если N отрицательный то в двоичной системе настоящей число отрицательное к положительному найти 
очень легко. тоесть если у нас 0001 то ему отрицательное это -0001 а вот когда мы 
говорим про бинарный вид числа в регистре у нас там нет никаки минусов. там мы работает
только с положртельными числами поэтому я выбрал чтобы N 	был положитеьный.
схема такова. 

у нас ест число -7 в десятичной записи. ему обратное в десятичной это 7. и мы мгновенно также
можем записать как будет выгляеть 7 уже внутри регистра это 0111. тоест положителность
числа N дает возомность его засунунть в регистр. 


итак имеем числа -1 тогда N=1, тогда его вид в регистре 0001
число -5 тогда N=5 , тогда его вид в регисре 0101
число -7 тогда N=7, тогда его вид в регистре 0111

далее рассмтриваем формулу 15-N
в двоичной записи эта операция выглядит как

для N=1
1111
0001 -
-------
1110

для 
N=5
1111
0101 -
--------
1010

для 
N=7
1111
0111 -
--------
1000

на цпу мы ее выполнить неможем потому что по условиям у нас в цпу нет блока вычитания
одного положртельного числа из другого пэтому мы ее делаем пока только 
на бумаге.

но можно заметить одну интересуню вещь. что ответ в бинарном виде 
всегда является инвертасией битов из числа которое мы отнимали. тоесть

N=1 = 0001
ответ = 1110

N=5 = 0101
ответ = 0101

N=7 = 0111
ответ = 1000

так вот утверждается в кнжижке что так буде всгда для любого аргумента.
если мы отнимаем в 4 битном числе от 15 другое полржителное число то 
ответ можно найти мгновенно путем инверсии битов.

и тут чудо. значит мы можем добавить в цпу такой блок в ALU который умеет 
инвертировать биты в регистре. 

тоесть 15-N = NOT N 
где NOT N это bitwise not для N

тоесть если 
N = 0000 
то 
NOT N = 1111

тогда возврашаемся к формуле
если у нас есть отрицательное число(которое мы неможем засунуть в регистр) и мы хотим найти положительное число P (которое 
мы уже можем записать в регистр) то P можно найти по формуле

P=(15-N)+1

где N это положительное число обратное к нашему отрицательному.тоесть если наше число -7 то N=7.

поскольку мы уже выыснили что (15-N) = NOT N
то формула преобразуется в 

P= NOT N + 1

таким образом мы нашли формулу по которой мы не из таблицы руками а на цпу с помощью его ALU 
можем автоматм красиво получать число P для заданного отрицательного числа зная его обратное положительное число N.

пример.
отрицательное число =  -8
для него его обратное число N=8
значит мы берем и грузим в регистр число 8

mov al,8d

далее мы к нему применяем bitwise NOT

not al

далее мы к нему прибавляем 1

add al,1 

и таким макаром у нас щас в al число P которое согласно таблице соответсует числу -8.


рассмотрим на примере
число -7
N=7 = 0111
NOT 0111 = 1000
прибавим единицу 

1000
0001 +
-----
1001

полученное число 1001(9 dec) это искомое число P для -7.
проверяем по таблице
1001 = ( для цпу это прежнему 09) | для программы это -7
все верно.


расмормим обратную задачу. у нас есть число P в двоичном виде из регистра.
как нам понять какое число оно кодирует?

смотрим на формулу

P= NOT N + 1    # она про то чтобы зная N найти P

теперь выведу обратную формулу
N = NOT (P -1)  # она позволяет зная P найти N

проверим на практике.
P= 1001
N = NOT (1001-0001) = NOT 1000 = 0111  = 7
значит искомое число отрицательное равно -7



ВНИМАНИЕ! ВАЖНЫЙ КУСОК. 
примеры на bash
(собственно именно из за него и началось изучение кодирования отрцаеттельных чисел)

тут очень важно сразу сказать что  баш имеет размер переменной 64бита. а не 4бита как я все это время тут рассматриваю. 

далее важные примеры на эту же тему
на примере bash:

у bash есть bitwise NOT обозначается как ~
$ (( ~число  ))

у bash двочиное число вбивается как
$ (( 2#0001))

все вместе NOT 0001
$ echo  $(( ~ 2#0001 ))

наша задача угадать что будет на выхлопе.
прикол в чем баш берет число которое мы ему дали и применяет к нему инверсию битов. полученный байт баш невыводит в бинарном виде. нет. он воспринимает его как P. как 
число в регистре. поэтому для этого P баш находит N. и потом выводит его на экран в
виде -N

наша задача - мы задаем начальное число N1. и нужно предсказать какое число -N2 
баш распечатает на экране.

значит после выполнения команды в регистре будет лежать байт
P=NOT N1

и  у нас есть формула которая зная P позволяет расчитать его N
N2 = NOT (P -1)

подставляем P из первой формулы во вторую получаем
N2 = NOT (NOT N1  -1)

формулу получили. 
приступаем к конкретным случаям N1.

N1=00..0001

тут суперважно вспомнить и понять что баш выеляет по число 8 байтов. а не 4бита
как я это тут делаю в примерах. почему это важно .потому что 
 я вот ввел и получил
 $ (( ~ 2#0001))
-2

далее я подумал что результатом NOT 0001 является 1110 
и да это верно если размер регистра 4 бита (но это совершенно неверно если 
размер регистра 64 бита щас мы это увидим). ну я и подумал а дайка  я башу сразу подсуну
это число 2#1110 и посмотрю что он напечаатаем. должен же -2

я ввел и получил
~$ echo $(( 2#1110  ))
14

и такой типа непонял почему 14 вместо -2 . а все потому что для 64битого регистра операция

NOT 0001 = 1111111......1110 но никак не 1110

поэтому мне нужно было печатать число
$ echo $(( 2#1111111111111111111111111111111111111111111111111111111111111110 ))
-2

а  я задал печатать совем другое число
$ echo $(( 2#1110  ))
14
которое аналогично
$ echo $(( 2#0000000000000000000000000000000000000000000000000000000000001110  ))
14

поэтому и получил 14 вместо -2

почуствуй разницу между числами
1111111111111111111111111111111111111111111111111111111111111110
и
0000000000000000000000000000000000000000000000000000000000001110
 

после примеения к нему NOT в регистре окажется как уже сказал число 1111111111111111111111111111111111111111111111111111111111111110
по таблице можно найти что ему соотвевтвует -2

но расчитаем по формуле а не по таблице
N2=NOT (NOT 0001  -1) =  NOT (11..1110  -0001) = NOT (11..1101) = 0010 = 2
значит на экране баш должен напечатать -2

проверяем
$ echo $(( ~ 2#0001))
-2
все правильно.


следущий пример
N1=00..1010

после примеения к нему NOT в регистре окажется число 
1111111111111111111111111111111111111111111111111111111111110101
по таблице можно найти что ему соотвевтвует -11 

распечатаем напрямую это число. проверим как баш его интерпретирует
$ echo $(( 2#1111111111111111111111111111111111111111111111111111111111110101  ))
-11

все верно!

но теперь расчитаем -11 через формулу
N2=NOT (NOT 1010  -1) =  NOT (11..0101  - 0001) = NOT (11..0100) = 1011 = 11
значит на экране баш должен напечатать -11

проверяем
$ echo $(( ~ 2#1010))
-11
все правильно.

тут еще важно отметить что так как у нас регистр 64бита то конечно -11 входит в
в диапазон! это если бы регистр был 4 бита то -11 там бы и в помине небыло.


вопрос почему я указываю числа в баш в бинарном виде.
это чтобы точно гарантировать какое бинарное число баш кладет в регистр.
ведь если я укажу число в десятичном формате то баш его вначале преобразоывает в бинарный вид по непонятно какому правилу и только потом кладет в регистр. если же указваем число сразу вбинарном виде то баш ровно  в таком виде и кладет число в регистр. это очено важно.если я указал (( 2#0001 )) то баш засунет  в регистр именно этот набор бит.
а если я укажу (( 1 )) то еще нефакт что баш засунет в регистр 0001

щас  я покажу почему это важно. 
поставим число в десятичном виде.
возьмем предыдущий пример N1=1010. преобразуем в десятичны вид N1=10(dec)

$ echo $(( ~ 2#1010 ))
-11

$ echo $(( ~ 10 ))
-11

ну чтож хорошо получили одно и тоже.



рассмотрим следущий пример.
N1= -4

значит как будет дейтсовтаь баш. он небудет пихать в регистр -4 потому
что это невомозжно. он вначале по таблице 
заменит -4 на некоторое бинарное положительное число (вопрос какое).
и именно его засунет в регистр.
посмотрим что будет
$ echo $((  ~ -4 ))
3



расчитаем что тогда он должен показаьть
по моим понятияем баш -4 превршащат по таблице в 11..1100

N1=11..1100

у нас здесь P=NOT N1= 00..0011

далее по формуле мы уже неможем считать потмоу что формула расчитана
на нахождение N при условии что P имеет старший бит устанолвенный в 1
а наш P имеет старший бит сброшенный.

так что наша формула по нахождению N тут неприменима!

конец теме примеров на баш. далее опять возрвщаемся к искуственным регистрам на 4 бита.
ВНИМАНИ! КОНЕЦ ВАЖНОГО КУСКА.

насколько я понимаю расмотренная выше модифицрованная методика кодирования методом одометра
это и есть "вторая обратная схема кодирования"

?????????????????????????????/
закончил тут.
рассмотреть то что я непонял здесь 
https://www3.ntu.edu.sg/home/ehchua/programming/java/datarepresentation.html
у них какаято друная методика второй схемы кодировагия а именно:
for negative integers, the absolute value of the integer is equal to "the magnitude of the complement of the (n-1)-bit binary pattern plus one" (hence called 2's complement).

ихний пример
1000 0001 типа равен -127(Dec)

посчитаем по моей методике
P=1000 0001

N = NOT (P -1) = NOT (1000 0001 - 0000 0001) = NOT (1000 0000) = 0111 1111 = 127(dec)
значит исходное число по моей методике это -127
кхм.. ответ совпал с ихним. 

P=1 111 1111
N= NOT (1111 1111 - 0000 0001) = NOT (1111 1110) = 0000 0001 = 1
значит число равно -1

их ответ 
0000000+1=1 итого -1
кхм совпало.
почемуто формулы разные а ответс совпдаате! надо разобарсят !

????????????????????????????
Далее. я тут сразу еще скажу то что совершенно очевидно что при такой системе кодирования
чисел старший бит который показывает знак это нетолько бит отвечающий за знак это также 
бит который тоже участвует в кодировании величины числа.это совершенно очевидно. тоесть если взять 
1011 = ( для цпу это прежнему 11) | эквивалент -5
это число и заменить его старший бит с 1 на ноль то мы получим 0011 и согласно верхней
таблице мы получили 
0011 = ( для цпу это прежнему 03)
тоесть у нас было -5 а получили 03
тоесть я хотел сказать что если мы заменяем старший бит с 1 на ноль то мы неполучили 5.
типа было -5 а стало 5. и совершенно понятно почему! конечно так и должно быть.

далее книжку по асемблеру от BOB NEVELN пишет что для цпу информация в регистре она всегда
положительная. а число может быть отрицательным только в интерпретации программы.
ну это мы уже поняли.

итак мы научились к отрицательному числу прибавлять положительное.
берем отрцаительное число находим по таблицк какое положительное число надо
засунуть в регистр. и запускаем на цпу операция сложения.
возникает вопрос как нам на уровне программы\компа\цпу научиться находить число 
из таблицы без таблицы.  


16-x = (15-x) +1

15-x = NOT x

-x = NOT x + (-15)

x=7 = 0111
NOT x= 1000
-15 =0001

-7 = 1000 + 0001 = 1001

1000
0001
-----
1001


Дальше в этой книжке описывается просто поразтельная вещь- а как же нам научиться отнимать 
число от другого числа при этом пользуясь все тем же в цпу блоком который производить сложение. ибо нехочется цпу усложнять новыми транзисторными схемами . и они придумали поразителную схему.

хотим отнять 5-3. замечаем что 
5 - 3 = 5+(-3)

значит теперь мы перевели задачу об отнимании в задачу о сложении. только есть загвоздка
нужно научиться 3 переводить в -3. далее книжка пишет что эта операция нетак проста что это непорсто заменить операция заменить старший бит с 1 на ноль. ( и я тоже согласен с этим).
как показала формула выше чтобы получить для цпу эквивалент -3 это надо выполнить операцию

P = 2^n-N.
скажем у нас 4 битный регистр. тогда
P=16-3
и тут мы уперлись в том что на цпу нужно иметь блок отнимания. типа тупик. но дальше кникжа
пишет что во первых восопользуемся формулой

16-3 = (15-3) +1

далее посмотрим как выглядит отнимание 15-3 на бумаге

1111
0011
-----
1100

так вот присмотримся к 3 и результату
3          = 0011
результат  = 1100

так вот книжка утверждает что при отнимании от 1111 любого числа результатом будет число
которое получается из отнимаемого числа просто операцией замены каждого нуля на единицу
и каждой единица на ноль в отнимаемом числе тоесть.

мы отнимали 3 от 15. 3 это 0011 значит ответ будет 1100 (заменили в тройке все нули на единицы а все единицы на тройки). тогда получается что надо в цпу добавить очень простой блок которйы будет в отнимаемом числе менять биты на наоборот.
с помощью этого блока мы научили цпу отнимать 15-3
смотрим наверх чтобы получить 16-3 нам надо получить 15-3 ( это мы уже можем) и потом еще 
к результатут добавит единицу . для добавления единицы тоже в цпу можно пристроить очень простой блок.

таким образом добавив блок инвертирования битов и блок добавления единицы мы научили цпу
отнимать числа . тоесть

мы хотим отнять 12-4 грузим 12 и 4 в регистры. и даем команду на асемблере мол отнимай.
что делает цпу.


он начинает превращать 4 в -4

-4 = (15-4) +1

4 у нас это 0100
инвертруем на нем биты и получаем чему равно 15-4 = 1011
далее добавляем единицу
1011
0001
-----
1100

это мы получили аналог -4 = 1100

теперь выполняем операция сложения

12 + (-4)
12= 1100
-4= 1100

выполняем сложение

1100
1100
-----
1000 

получили переполнение но это неважно


с точки зрения unsigned integer 1000  это 8.
значит 12-4=8

что меня смущает 12 относится к unsigned intger диапазону а -4 относится к signned integer 
дапазону. как же мы можем смешивать две кодиовки?

зато стало понятно откуда взялась эта формула. что 

если a>0 то -a можно получить в битовом виде через :
-a = (~ a) + 1
где ~ это bitwise NOT.

формулу можно немного и преобразовать
(~ a) = -a-1
получаем тогда типа что если a=0 . то 
(~ 0) = -1

а скажем 
(~ 6) = -6-1 = -7

в баше ровно это и видим:
$ echo $(( ~0 ))
-1
$ echo $(( ~6 ))
-7

в книже по асемблеру процесс инвертации битов в регистре и добавление единицы назыается процессом two's complementation ( переводится как я понимаю дополнение до двух).
по факту это получается алгоритм битовой обработки числа в двоичной форме чтобы получить 
из положительного числа его отрицательную форму с точки зрения кодирования signed integer в битовом виде. таком что сложение на блоке сложения на цпу всегда дает верный результат внезависимости от того что подразумевает программа которая засунулу это число в регистр
толи программа имеет ввиду что это signed int или unsigned int.


у меня остался вопрос - меня смущает 12 относится к unsigned intger диапазону а -4 относится к signned integer 
дапазону. как же мы можем смешивать две кодиовки? тут даже два вопроса.
а как нам отнимать не 4 а например 14 потому что -14 в кодировке со старшим битом 
такого числа там нет. вторйо вопрос если мы взяли 12 из одной кодиовки а -4 из другой
то ответ как интерперретировать к какой кодировке его относить. по мне самый просто ответ
это то что и левое число и правое должны быть взяты из одной кодровки. и наверное
эта кодировка это signed int та при которой минусовые числа имеют старший бит равный 1. 
для 4 битов это диапазон чисел от -8 до 7

если же мы берем числа в диапазоне unsigmed int. то тут непонятно.
числа от 0 до 15.
отнимаем 1-15
насколько я понимаю в этом случае исползуется кодировка когда у нас отрицательное число
необьязано иметь 1 в старщем бите.тоесть кода у нас комбинация битов может трактоваятся
программой и как полжительное число и как отрицательное.
и тут проблема как трактовать полученный ответ. я так понимаю что на это влияет бит переполнения.

берем 15 и превращаем его в -15

1111 =15
инвертируем биты и добаляем 1 получаем
0001

складываем 1 и -15

0001
0001
-----
0010

бит переплонения при этом несработал

0010 это эквивалент -14 ( при условии что мы нетребуем старший бит чтобы был равен 1)
но как нашей программе отличить это -14 или 2. я пока только могу сказаьт что бит переполнения
не срабатывает в этом примере. 

попробуем другой пример

12 -4

4 это  0100
-4 это 1011+0001

1011
0001
-----
1100

12 это 1100

скалдываем

1100
1100
-----
1000

приэтом сработал флаг переполнения

1000 это 8 либо -8

из этих двух примеров я делаю вывод что наша программа может опредеить брать положительное
число или отрицательное вот как: если бит сработал переполения то брать положительный вариант числа. а если флаг переполнения несработал то брать отрицательнй вариант числа.


1-15=0010(2 либо -14) и флаг переполнения несработал
флаг переполнения несработал значит берем отрицательнйы вариант -14
итого 1-15=14

12-4=1000(8 либо -8) и флаг преполнения сработал 
флаг преполнения сработал значит берем пооложительнй вариант 8
итого 12-4=8

замечу что когда мы отнимаем числа в диапазоне unisgned integers то для кодирования
отрицательного числа у нас уже нет требования чтобы старший бит был равен 1
фактически мы работам сразу с двумя диапазонами от 0 до 15 и от -15 до 0
когда набор бит может одновременно быть трактован и положительным и отрицательным числом.
и тогда задача программы на основе флага переполенения понимать какой число с плюсом илли минусом в ответе она получено.


попробуем отнять чисала  с диапазона signed untegers от -8 до 7

-8-7

-8-7=(-8) + (-7)

8 =  1000
-8 = 0111+0001

0111
0001
-----
1000 флаг переполнения получен

7 =  0111
-7 = 1000 + 0001

1000
0001
-----
1001 флаг переполнения неполучен

значит -8 = 1000
-7 = 1001

складываем

1000
1001
-----
0001 флаг переполнения получен

0001 это 1 либо -15

вспоминаем правило: если бит сработал переполения то брать положительный вариант числа. а если флаг переполнения несработал то брать отрицательнй вариант числа.

но у нас тут прикол в том что флаг переполнения сработал два раза так что может быть 
это тоже обозначает что надо брат отрицательный вариант. 

тогда 0001 интерпретриуем как -15
тогда
-8-7=-15

ну как то так но не очень понятно.
====================================
====================================

 

       **     exponentiation
       * / %  multiplication, division, remainder
       + -    addition, subtraction
       << >>  left and right bitwise shifts
       <= >= < >
              comparison
       == !=  equality and inequality
       &      bitwise AND
       ^      bitwise exclusive OR
       |      bitwise OR
       &&     logical AND
       ||     logical OR
       expr?expr:expr
              conditional operator
       expr1 , expr2
              comma




послесловие:

если мы хотим присвоить значение в переменную тогда

$ n=$(( 5 + 4 ))
$ echo $n
9

 а впот пример показывает что расчеты идут только как с целыми числами, никакой 
 дробности нет
$ echo $(( 10 / 3 ))
3

обратим внимание на этот синтаксис
expr1 , expr2
              comma

пример на эту тему

$ a=1;b=3
$ (( a=a+10, b=b+a ))
$ echo $a
11
$ echo $b
14




можно использовать в скобках нетлоько дсесятичые числа но и hex и бинари 
делается через 

(( 2#01010101 )) - бинарное число
(( 16#a134f )) - hex число

посмотреть всегда можно в man bash искатьпо слову arithmetic evaluation

$ echo $(( 2#101 ))
5

$ echo $(( 16#F ))
15

в каком виде баш хранит переменные? какие есть типы переменнух у баша?
цитрую из книжки по башу:
Unlike many other programming languages, Bash does not segregate its variables by "type." Essentially, Bash variables are character strings, but, depending on context, Bash permits arithmetic operations and comparisons on variables. The determining factor is whether the value of a variable contains only digits.

итак если у баша перменные эти всегда strings. но с ними можнр делаь операции порой как
с integer то возникает вопрос насчет формата печати переменных.
так вот формат в котором будет распечатана переменная зависит от прогаммы которая
печаатет переменну.

у echo  всегда будет в dec формате.
потому что echo переменые выводит всегда в dec формате

printf может вывести переменную в hex формате

$ q=$(( 16#f ))
$ printf "%x\n"  $q
f

итак надо различать тот вид в котором перменная хранися в памяти 
и тот вид в котором она напечаатана. это разное.


далее рассмотрим такую штуку:
<< >>  left and right bitwise shifts

$ (( n>>4 )) 
эта штука берет число автоматом его переделывает в бинарный вид и далее сдвигает все биты
направо на 4 бита.

рассмотрим на примере n=15 (0000 1111)
при сдвиге вправо на 4 бита получим конечно ноль
$ n=15; echo $(( n>>4 ))
0
$ n=15; echo $(( n>>3 ))
1
$ n=15; echo $(( n>>2 ))
3
при сдвиге на один бит получим 111 тоесть семь
$ n=15; echo $(( n>>1 ))
7

что еще важно. (( n>>4 )) она двигает биты но саму переменую неменяет.
$  n=15; echo $(( n>>1 )); echo $n
7
15



дале рассмотрим такую штуку:
 expr?expr:expr
              conditional operator
 это ternary(тройной в переводе) оператор. 
 его смысл: An expression a ? b : c evaluates to b if the value of a is true, and otherwise to c

 пример
$ (( a=5<4?5:4 ))
$ echo $(( a=5<4?5:4 ))
4
$ echo $a
4

итак смысл если 5<4 то тогда присвоить a=5 иначе присвоить a=4





$ { let n&=9; }
[1] 13696
=9: command not found
[1]+  Done                    let n
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ let n\&=9;
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ echo $n
9
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ n=15
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ let n\&=9;
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ echo $n
9
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ 


далее рассмотрим такую штуку:
 - +    unary minus and plus

 

=====
bash
parameter expansion

смотри в man bash по слову "patameter expansion"

один из примеров по этой теме.а именно 
${parameter/pattern/string}


$ a=2334
$ (( a++ ))
$ echo $a
2335

$ echo ${a/23/BB}
BB35

получается что параметром может быть перменная. она указывается без знака
доллара.
что делается - в параметре ищется паттерн и когда он найден то он заменяется на string

в 2335 искался 23 и когда его нашли то его заменили на BB

======
bash
variable

при обьявлении еременой нельзя использовать пробелы. будет ошибка

$ a=1

$ a= 1
1: command not found

$ a = 1
a: command not found

=========
bash
declare

позволяет обьявить переменную точнее ее тип.

обьявить integer переменую
$ declare -i a

проверить какой тип у обьявленной переменной
$ declare -p a
declare -i a

$ a=12
$ echo $a
12


при попытке integer переменной присвоить неinteger значение , ее значение будет сброшено в ноль
$ a=e3
$ echo $a
0


оьявляем переменную у которой все буквы мелкие. если введем большую букву 
то она автоматом будет переделана в мелкую
$ declare -l kk
$ kk="qw12e12"
$ echo $kk
qw12e12
$ kk="QWE123kfjUOIU12"
$ echo $kk
qwe123kfjuoiu12


обьявляем переменну в котоой буквы все заглавные
$ declare -u UU
$ echo $UU
12kewfjewlkjbvvbbbb
$ UU="12kewfjewlkjBVVBBBB"
$ echo $UU
12KEWFJEWLKJBVVBBBB

это очень удобно для применения с bc и hex числами потому что bc понимает только 
когда hex числа ему скармиливаются только через заглавыне буквы

кстати на счет того как это внешняя программа /bin/echo получает переменную и понимает 
ее.например

$ /bin/echo $p

ведь дело в том что /bin/echo понятия не иммет ни о какой переменной $p. у него нет 
этой переменной в памяти. 

а дело в том что баш себя форкает. однако при этом дочерний процесс это все тот же баш
и далее этот дочерний баш он просто берет занчение переменной $p и подстлавяет число в 
execve

exeve("/bin/echo","...", число)

таким образом команде /bin/echo всего навсего нужно распечатать просто число которое к ней поступило в качестве первого параметра. тоесть я хочу сказать что /bin/echo понятия неимеет
ни о какой переменной $p. это баш выхывает execve и подставляет туда значение в форме уже 
готовой цифры. да безусолвно есть еще механизм что баш в execve пихает я массив  envp[]

int execve(const char *filename, char *const argv[],
                  char *const envp[]);

в котором содержатся все глобальные переменные баша но там небудет переменной $p.
итак еще раз.

есть команда

$/bin/echo $p

она неимеет к баш никакого отношения. чисто внешний бинарник.
скорей всего его код имеет вид

int main(int argc, char *argv[]){}

или вид

int main(int argc, char *argv[], char *envp[])

в любом случае наш параметр $p попадет  в argv[]. 
как это произойдет. баш себя форкнет то есть склонирует и создат свою копию.
и эта копия запустит execve ("/bin/echo",["/bin/echo", 20],NULL)
так вот фишка в том что в /bin/echo попадает не $p а уже его числовое значение ибо баш 
в execve подставить уже значение $p поэтому /bin/echo вообще понятия неимеет ни о каком $p
он просто на вход получает готовое число.
таким образом при запуске внешних программ сам баш раскрывает все переменные а во внешние 
программы он передает уже готовые числа\значения. вот откуд ответ на вопрос " а откуда echo 
знает о переменной $p".
ну я конечно молчу если используется не внешний файл /bin/echo а башевский builtin echo.там еще проще.


также замечу что баш передает внешней программе все глобальные переменные через третий парметр в execve ( не все переменные а именно только глобальные)

это  выглядит вот както так

execve("/bin/ls", ["ls", "--color=auto"], ["CLUTTER_IM_MODULE=xim", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "LC_MEASUREMENT=ru_RU.UTF-8", "MC_SID=29047", "LESSCLOSE=/usr/bin/lesspipe %s %"..., ...", "GTK_IM_MODULE=ibus", "LC_TIME=ru_RU.UTF-8", "OLDPWD=/home/vasya/Asm", "_=/bin/ls"]) = 0

для того что бы внещнаяя программа могла их принять у нее в ее main() должен быть указан третий параметр

int main(int argc, char *argv[], char *envp[])

но этот способ счиатется ненадежным непереносимым. более наежный способ это то что 
у внешней прграммы должны быть указана глобальная перменная

extern char **environ;
int main(int argc, char *argv[]) 

тогда при вызове башем execve ядро когда будет создавать пространство памяти 
для ноового процесса создать там переменную environ и в нее запишет весь массив из третей переменной execve. такой способ считвается переносимым.

это ответ на вопрос как же из баша переменные передаются другим программамам.

========================

zabbix
/etc/passwd

история - в заббиксе можно увидеть часто алерт вида   "/etc/passwd has been changed"

как работает item от этого триггера  : zabbix использует линукс команду cksum. что она делает - она вычиясляет crc от файла.
тоесть этот crc он высчитывается от байтового содержания файла. ( а от имени файла и от его времени изменения crc независит что тоже важно).

$ cksum /etc/passwd
2207685566 3268 /etc/passwd

2207685566 первое число это crc32 число(контрольная сумма).
3268 это разер файла в баайтах

я проверил - изменение имени файла реально не влияет на cksum
также изменение времен ( acccess time, modify time) без изменения контента файла(через touch -a -m /etc/passwd)  тоже невлияет на cksum

таким образом еще раз - cksum вычисляет crc от файла и на это влияет только содержимое файла а имя файла и  время доступа к файлу никак на это невлияет.


итак мы поняли что если триггер сработал значит 100% контент файла /etc/passwd был точно имзенен.

если мы руками там ничего неменяли тоесть еще один вариант -  так кто же  засунул нового юзера либо сменил 
пароль в /etc/passwd. так вот оказыается что это случается когда мы устаналиваем новый пакет.
примером такого пакета явялется пакет ntp. при установке этого пакета он долавбяет в /etc/passwd  нового юзера ntp

ntp:x:129:136::/nonexistent:/usr/sbin/nologin

вот и разгадка алерта!

так вот - когда файл /etc/passwd будет изменен то это время изменения останется в *time файла. тоесть

# stat /etc/passwd
.....
Access: 2022-11-12 01:51:02.857747523 +0600
Modify: 2022-11-12 01:51:02.857747523 +0600
Change: 2022-11-12 01:51:02.872747584 +0600

так вот если алерт вылез. и непонятно почему и откуда. то полезно взять время модификации файла passwd 
и проверить а ровно в это время не был ли установлен в системе НОВЫЙ ПАКЕТ!?!?!?!?!?!?!!?!?

для yum это:
# tail /var/log/yum.log 
Nov 12 01:51:02 Installed: autogen-libopts-5.18-5.el7.x86_64
Nov 12 01:51:03 Installed: ntpdate-4.2.6p5-29.el7.centos.2.x86_64
Nov 12 01:51:04 Installed: ntp-4.2.6p5-29.el7.centos.2.x86_64


и вот мы увидели что ровно втоже время когда был модифицирован passwd файл ставился в системе пакет ntp. вот из
за этого и оттуда файл passwd и был изменен!


для apt это:

# stat /etc/passwd
.....
Access: 2022-11-12 01:48:49.161664596 +0600
Modify: 2022-11-12 01:48:49.145662840 +0600
Change: 2022-11-12 01:48:49.149663279 +0600


# tail -n 40 /var/log/apt/history.log
Start-Date: 2022-11-12  01:48:47
Commandline: apt-get install ntp
End-Date: 2022-11-12  01:48:55

вот! во время модификации passwd устаналвился пакет ntp который его и поменял!

Итого: если заббикс выплюнул алерт то полезно проверить может быть во время модификации passwd в системе был установлен некоторый интересный пакет наример ntp,
который лезет сам в passwd и туда всталяет своего служебного юзера.


что еще хочется сказать. 
алерт забикса он в целом полезен. но он вообще нераскрывает  кто когда как и на что поменял файл /etc/passwd

========================================

если вылезает такая шибка

update-initramfs: Generating /boot/initrd.img-5.4.0-91-generic
W: Possible missing firmware /lib/firmware/rtl_nic/rtl8125a-3.fw for module r8169
W: Possible missing firmware /lib/firmware/rtl_nic/rtl8168fp-3.fw for module r8169
W: Possible missing firmware /lib/firmware/i915/tgl_dmc_ver2_04.bin for module i915
W: Possible missing firmware /lib/firmware/i915/skl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/bxt_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/kbl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/glk_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/kbl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/icl_guc_33.0.0.bin for module i915
update-initramfs: Generating /boot/initrd.img-5.4.0-84-generic

о том что нехватает какойто firmare
что делать

качаем эти firmware с сайта ядра.
mkdir rtl8125b_fw
cd rtl8125b_fw
wget https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/rtl_nic/rtl8125b-2.fw
wget https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/rtl_nic/rtl8168fp-3.fw
sudo cp *.fw /lib/firmware/rtl_nic/
sudo update-initramfs -u

и обноавляем initramfs

аналогично на сайте  в папке i915 лежат недостющие для него firmware

https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/i915/

=====
как узнать какое устройство работает на каком драйвере

$ lspci -vv -nn | grep -E "..:..\..|modules"

пример вывода:
00:02.0 VGA compatible controller [0300]: Intel Corporation Device [8086:3ea0] (rev 02) (prog-if 00 [VGA controller])
	Kernel modules: i915

00:04.0 Signal processing controller [1180]: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem [8086:1903] (rev 0c)
	Kernel modules: processor_thermal_device

00:12.0 Signal processing controller [1180]: Intel Corporation Device [8086:9df9] (rev 30)
	Kernel modules: intel_pch_thermal

видно название железки и обслуживающий ее драйвер (модулья ядра)

====

apropos

полжим мы хотим найти man по какйото теме в линуксе. 

тогда можно заюзать apropos . пишут что каждый маг содержит ключевые солова и апропос
ищет нам статьи мана по ключевым словами. пример хотим почитать про firmware

$ apropos firmware
bootctl (1)          - Control the firmware and boot manager settings
btcflash (8)         - firmware flash utility for BTC DRW1008 DVD+/-RW recorder.
hex2hcd (1)          - firmware converter
hp-firmware (1)      - Firmware Download Utility
nvme-fw-commit (1)   - Used to verify and commit a firmware image.
nvme-fw-download (1) - Download all or a portion of an nvme firmware image.
nvme-fw-log (1)      - Send NVMe Firmware log page request, returns result and log
rpl8 (8)             - Firmware loader for DVD drives
[vasya@lenovo docs]$ 

-----


initramfs
firmware
driver


когда мы обновляем initramfs то может выскочить на экране что у нас нехватает /lib/firmware/.. файлов
из пакетов искать это мудота. там бывает нет тог что надо. простой выход скачать их отсююда https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/refs/

а потом просто копируемфайлы в папку /lib/firmware

что за хрень firmware. 

вот здесь пишут https://wiki.ubuntu.com/Kernel/Firmware  что  каждый а может и не каждый драйвер состоит из двух частей одна часть это модуль ядра. фишка модуля ядра в том что от него есть исходный код. 
а вторая часть это готовый бинарник без исходного кода который зоветмя фирмвейр. и этот бинарнтик надо 
закачивать внутрь железки. почему его там нет изналачально непонятно. и вот так как это бинарник без исхоных кодов то начтнается мудота где его взять ибо это же линукс. тут у всего должны быть исходные коды.
поэтому их придодися качать отдебно.

как проверить какие firmware по факту были загружены

# dmesg -T | grep -e 'firmware'
[Чт дек 29 17:03:26 2022] [drm] Finished loading DMC firmware i915/kbl_dmc_ver1_04.bin (v1.4)
[Чт дек 29 17:03:30 2022] ath10k_pci 0000:02:00.0: firmware ver WLAN.TF.2.1-00021-QCARMSWP-1 api 6 features wowlan,ignore-otp crc32 42e41877

----
cron

была следдущая тупая залупа

задание cron не отрабатывало только потому что файл крона в /etc/cron.d/file имел 
неправильные permissions  ! тоесть обязательно надо чтобы root.root и никак по другому.

вот такой ебнутый cron по архитектуре.

догадка пришла тогда когда посмотрел journalctl -f -u crond

----

cron

по дефолту все крон джобы исполняются от root
и только если мы укажем в строке крон джоба другого юзера то джоб будет 
исполнятся не от рута.

-----

как нам удалить переменную из баша которую мы обьявили чеерз export
ответ unset

пример
$ export vasya =1
$ set | grep vasya
$ unset vasya
$ set | grep 

-------

| ufw настройка файрволла

как настроить файрволл

ВАЖНО СРАЗУ ПОНИМАТЬ ЧТО UFW ЭТО ПИЗДЕЦ поделка. 
в чем этот пиздец читай ниже.

по большому счету либо ufw на хосте либо докер. но чтото одно.
потому что докер лезет в настройки iptabes и создает правила в обход ufw.
ессли же актииивировать MANAGE_BUILTINS=yes то ufw стирает часть прпавил докера
и он неможет запускать контейнеры. поэтмоу на лицо явный конфликт. 
а если использовать MANAGE_BUILTINS=no то толку от ufw ноль. ибо докер 
открыает порты и пиздец. поэтому либо докер+внешний файрволл. 
либо ufw и никакого докера. единственное что если мы будем на хосте запускать 
докер контейнер который не открыавет порты то тогда ufw можно использовать 
на хосте ибо докер неменяет сет правила при этом. соотсвтенно ufw надо юзать
с опцией MANAGE_BUILTINS=yes 
это кратно. а подробности ниже.




супер важная вещь что  ufw по дефолту контролирует только часть правил iptables.
а чтобы ufw контролировал все правила целиком то надо выставить
# cat /etc/default/ufw
MANAGE_BUILTINS=yes
и перезагрузка сервиса. об этом читай в linux-general.txt
возможно это может мешать докеру. это надо выяснять.


далее  отключить ipv6 на ufw 
# sudo nano /etc/default/ufw
IPV6=no
      

типовой набор команд активации ufw:

   98  ufw default deny incoming
   99  ufw default allow outgoing
  100  ufw allow 22/tcp
  102  ufw show added numbered
  103  ufw enable
  104  ufw allow 80/tcp
  105  ufw allow 443/tcp
  106  ufw reload
  108  ufw status numbered
  111  ufw status verbose
   11  ufw allow in  on <interface> to any  (это правило юзать чтобы разрешить все входящие на 
   интерфейс который будет отвечать за локалку)


Status: active

     To                         Action      From
     --                         ------      ----
[ 1] 22/tcp                     ALLOW IN    Anywhere                  
[ 2] 80/tcp                     ALLOW IN    Anywhere                  
[ 3] 443/tcp                    ALLOW IN    Anywhere        


как настроить через него nat и port forward

https://gist.github.com/kimus/9315140


ДАЛЕЕ: КАК активировать NAT :

/etc/default/ufw
DEFAULT_FORWARD_POLICY="ACCEPT"


в sysctl 
net.ipv4.ip_forward=1


далее сказано что надо разместить вот этот кусок вначале файла /etc/ufw/before.rules до блока *filter
однако в man ufw (который тоже хороший документ) сказано что этот кусок нужно разместить в конце
этого файла после блока *filter




# NAT table rules
*nat
:POSTROUTING ACCEPT [0:0]

# Forward traffic through eth0 - Change to match you out-interface
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE

# don't delete the 'COMMIT' line or these nat table rules won't
# be processed
COMMIT


перегружаем правила готово
# ufw reload


однако тут выясняется прикол. если мы сделаем пару перезагрузок ufw 
то мы заметим что правила каасающиеся NAT они размножаются это мможно увидеть через iptables-save



будет вот чтото типа такого

*nat
:PREROUTING ACCEPT [385:22237]
:INPUT ACCEPT [63:3370]
:OUTPUT ACCEPT [5:368]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
COMMIT



это же жесть!

так вот я нашел разьяснение = https://bugs.launchpad.net/ufw/+bug/364558
цитирую 

Thank you for using ufw and taking the time to report a bug. This is by design to make sure ufw doesn't step on other applications' rules. From /usr/share/doc/ufw/README.gz:

The primary chains are ufw-before-*, ufw-after-* and ufw-reject-*. The
treatment of iptables' built-in chains can be controlled with the
MANAGE_BUILTINS configuration option (in /etc/default/ufw). By default this is
set to 'no', which means that other than adding the primary chains, the
built-in chains will remain untouched. This also means that these primary
chains will stay in the table, even after disabling ufw. This is to make sure
that the primary chains don't move around other non-ufw rules and chains. To
completely flush the built-in chains with this configuration, you can use:

# /usr/share/ufw/ufw-init flush-all

Alternately, ufw may also take full control of the firewall by setting
MANAGE_BUILTINS=yes in /etc/defaults/ufw. This will flush all the built-in
rules and delete the non-built-in rules on start, stop and reload.


поэтому я выбрал решение

MANAGE_BUILTINS=yes in /etc/defaults/ufw

вот при таком раскладе уже перезагрузка ufw недает разможения правил в iptables-save

также при отключенной опции и наличии докера  наш файрволл теряет весь смысл потому что докер
будет вставлять свои цеопчки и контейнеры будут выставлены наружу!!!


еще один важный момент про связь между ufw и docker
если у нас выставлена опция MANAGE_BUILTINS=no
то если мы стартуем контейнер 
# docker run -it --rm -d -p 80:80 --name web2 nginx
то докер добавляет сам правила в таблицу iptables и таким макаром 
открывает на хосте порты наружу! все файрволл пробит изнутри.
а что будет если перезагрузить ufw ?
# ufw reload
будет то что ufw нетрогает правила докера  и порт открытый через докер 
останется открытым!


а если у нас выставлена опция MANAGE_BUILTINS=yes
тогда при запуске ufw он стирает часть правил докера
и при попытке запуска докера  увидим вот что 

# docker run -it --rm -d -p 80:80 --name web2 nginx

f2de59cccf062b2a6cd320d3a0106c657e54ee99ed02a06b80abb4f8a2eec4b1
docker: Error response from daemon: driver failed programming external connectivity on endpoint web2 (27b91c86e25636fbdbda98dedc2e3a59312c1bf5532d62dcd37b14f809d151d8):  (iptables failed: iptables --wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 --dport 80 -j ACCEPT: iptables: No chain/target/match by that name.
 (exit status 1)).

если мы перезапустим сервис докера
# systemctl restart docker

то он создаст свои стертые правила и тогда уже можно успешно запустить контейнер 

# docker run -it --rm -d -p 80:80 --name web2 nginx

и у нас опять порт открыт наружу !
а что будет если перезапустить ufw? он сотрет часть правил докера 
и это приведет вот к чему = с самого хоста доступ в контенер по порту будет работать
но снаружи доступа к порту контейнера нет.

если наша задача закрыть порт контейнера снаружи то тогда надо при каждом новом запуске
или перезапуске контейнера перезапускать ufw!!а это полная фигня а не продакшн.


DHCP
как разрешить чтобы он работал когда у нас ноутбуе это dhcp клиент а на вай фай точке dhcp 
сервер. значит DHCP сервер он сидит и слушает на 67\UDP порту
а клиент принимает от сервера пакеты на 68\UDP порту.
если у нас сервер это 192.168.0.1 то надо на буке разрешить
   исходящие   на  192.168.0.1 + 67 порт UDP
   входящие    от  192.168.0.1 на 68\UDP 

правила задаются как 

# ufw allow  in from 192.168.0.1     to any             port 68 proto udp
# ufw allow out from any             to 192.168.0.1     port 67 proto udp

если все правильно то правила касающиеся DHCP 
должны выглдеть так

    # ufw status verbose
    To                         Action      From
    --                         ------      ----
    68/udp                     ALLOW IN    192.168.0.1               
    192.168.0.1 67/udp         ALLOW OUT   Anywhere        

далее вот что добалвю.
ufw он не умеет разрешать icmp трафик. как то  так. 
а мне надо было разрешить этот трафик на определенынй хост.
так что делать?
а вот что . надо файл отредактировать

    # cat /etc/ufw/before.rules | grep icmp | grep 192.168.0.1
        #allow icmp to 192.168.0.1
        -A ufw-before-input  -p icmp -s 192.168.0.1 --icmp-type echo-reply  -j ACCEPT
        -A ufw-before-output -p icmp -d 192.168.0.1 --icmp-type echo-request  -j ACCEPT

    # ufw reload
    

как добавить доступ к веб морде Archer C24 у него веб морд работате
искючетельно по HTTP

 #  ufw allow in  from 192.168.0.1  port 80   to any             proto tcp
 #  ufw allow out from any                    to 192.168.0.1     port 80 proto tcp


 
как выглядит таблица когда все настроено

# ufw status numbered
Status: active

     To                         Action      From
     --                         ------      ----
[ 1] XXX.XXX.XXX.XXX 60805/udp  ALLOW OUT   Anywhere                   (out)
[ 2] Anywhere                   ALLOW OUT   Anywhere on wg0            (out)
[ 3] Anywhere on wg0            ALLOW IN    Anywhere                  
[ 4] 68/udp                     ALLOW IN    192.168.0.1               
[ 5] 192.168.0.1 67/udp         ALLOW OUT   Anywhere                   (out)
[ 6] Anywhere                   ALLOW IN    192.168.0.1 80/tcp        
[ 7] 192.168.0.1 80/tcp         ALLOW OUT   Anywhere                   (out)


но надо поммниить что это не все правила остальные 
надо смотреть в /etc/ufw/*.rules
или через 
    $ iptables-save
    

    
============

| archer c24

у него почемуто нет возможнсоти загрузить в веб морду сертиификат
 и сделать HTTPS поэтому веб морда доступна только по HTTP

как добавить правила в iptables

 #  ufw allow in  from 192.168.0.1  port 80   to any             proto tcp
 #  ufw allow out from any                    to 192.168.0.1     port 80 proto tcp

 
============




----------

parted, expand, grow, extend


вот если мы увеличили размер диска в гипервизоре

далее мы обнвоили об этом инфо через

# rescan-scsi-tool

далее надо как то через parted изменить раздел 


# lsblk -f  -o name,size
NAME    SIZE
sda      24G
├─sda1  953M
├─sda2    1G
├─sda3    2G
└─sda4 18,4G




расширяем раздел sda4

# parted /dev/sda
(parted) resizepart 4 100%
Warning: Partition /dev/sda4 is being used. Are you sure you want to continue?
Yes/No? Yes                                                               



# lsblk -f  -o name,size               
NAME    SIZE
sda      24G
├─sda1  953M
├─sda2    1G
├─sda3    2G
└─sda4 20,1G


удобство в том что resizepart 4 100% даем то что ненужно руками вбирвать размер хвоста
мы просто говорим расширь на все сколько можешь


и далее после расширения партиции надо еще расширить ФС

# xfs_grows  /mount_pint
или
# resize2fs /device


--------------

netplan

типовая настройка

ip адрес
если мы настраиваем сет карту через netplan вот конфиг типовой

# cat /etc/netplan/00-installer-config.yaml 
network:
  ethernets:
    eth0:
      optional: true
      addresses:
      - 81.81.81.81/28
      nameservers:
        addresses:
        - 8.8.8.8
        search: []
      routes:
      - to: default
        via: 81.81.81.80
    eth1:
      optional: true
      addresses:
      - 10.10.10.1/24
      nameservers:
        addresses:
        - 8.8.8.8
        search: []
  version: 2


и здесь я укажу очень важную опцию 
optional: true
смысл ее в том что при такой настройке линукс небудет ждать пока указанный интерфейс будет полностью сконфигурирован
и готов к работе (согласно man netplan) - что это по факту значит "будет полностью готов к работе"
но по факту если этой настройки нет то  при загруке убунты у нас загрузка останавливается на фразе

"job is running for wait for network to be configured.." 

и так висит 30-60 секунд.
а вот с этой настройкой такой хуйни нет и вртуалка грузится мгновенно.

а вот кстати как проверить скорость интернета из команднйо строки

# apt-get install -y speedtest-cli


---
mysql
mariadb

делаем

# ps aux | grep mariadb


вопрос как узнать на данный момент база запущена из сервиса или руками.
так вот ответ такой  - если база работает  потому что ее запустили из сервиса то в процессах этот процесс будет иметь очень простой вид

ps aux | grep mariadb
mysql     531425 24.1 20.2 7798524 2066700 ?     Ssl  20:33   7:12 /usr/sbin/mariadbd

а вот если прцоесс был запущен руками то вид будет совершенно другой сложный.

# ps aux | grep mariadb
mysql     493096 48.4 85.4 12509856 8709908 ?    Sl   мар23 1592:12 /usr/sbin/mariadbd --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/mysql/plugin --user=mysql --skip-grant-tables --log-error=/var/log/mysql/error.log --open-files-limit=16364 --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/run/mysqld/mysqld.sock --port=3306

ну и конечно эо можно проверить через банальный

# systemctl status mariadb
и он покажет работает ли сервис сейчас на данный момент или он упал.

----------

mariadb
mysql

проверить текущий статус  ведет ли mysql\mariadb бинарный лог


> show variables like 'log_bin';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | ON    |
+---------------+-------+
1 row in set (0,001 sec)



посмотреть список бинарных логов

> SHOW BINARY LOGS;
+--------------------+------------+
| Log_name           | File_size  |
+--------------------+------------+
| mariadb-bin.000071 |          0 |
| mariadb-bin.000072 |          0 |
| mariadb-bin.000073 |          0 |
| mariadb-bin.000074 |          0 |
| mariadb-bin.000075 |          0 |
| mariadb-bin.000076 |          0 |
| mariadb-bin.000077 |          0 |
| mariadb-bin.000078 |          0 |
| mariadb-bin.000079 |          0 |
| mariadb-bin.000080 |          0 |
| mariadb-bin.000081 |          0 |
| mariadb-bin.000082 |          0 |
| mariadb-bin.000083 |          0 |
| mariadb-bin.000084 |          0 |
| mariadb-bin.000085 | 1048585914 |
| mariadb-bin.000086 |  995604484 |
+--------------------+------------+


как отключить
идем в конфиг и 

[mysqld]
skip-log-bin = true 


---------------------

mariadb
mysql

slow query log

как проверить что он щас активирован


> show variables like 'slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | ON    |
+----------------+-------+



как это выключить без перезапуска 

>  SET GLOBAL slow_query_log = 'OFF';

но чтобы проверить сработало или нет то  надо обязательно 
выйти из мускула и обратно зайти. 

> show variables like 'slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | OFF   |
+----------------+-------+


а если не выйти\зайти то будет показывать 
что якобы по прежнему все работает.


а как через конфиг отключить?
ну вроде вот так - просто закоментить

#slow_query_log          = 1
#slow_query_log_file     = /var/log/mysql/mariadb-slow.log
#log_slow_rate_limit    = 1000
#log_slow_verbosity      = query_plan
#log_slow_admin_statements

----------

mariadb
mysql

> show variables like 'general_log';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| general_log   | OFF   |
+---------------+-------+


----------------

ipv6
ubuntu

как отключить

net.ipv6.conf.all.disable_ipv6=1
net.ipv6.conf.default.disable_ipv6=1
net.ipv6.conf.lo.disable_ipv6 = 1

-------------

logrotate

интерснейший момент.

как заставить лог ротейт ртейтить логи нетолько в указанной папке но и в ее подпапках

/var/log/basedir/*.log /var/log/basedir/*/*.log {
    daily
    rotate 5
}


в этом примере будут обработаны файлы нетолько в папке /var/log/basedir/
но и в во всех папаках вида /var/log/basedir/XXX

это круто!

---------------------
logrotate

 пример 


конфиг логротетйат:


# export d1="/etc/logrotate.d/mysql-backup" && touch $d1 && chown 0.0 $d1 && chmod 644 $d1

# cat mysql-backup 
/var/backups/mysql/*.gz {
    rotate 40
    daily
    dateext
    nocompress
    notifempty
    nocreate
    missingok
}



daily = срабатывает раз в день. ( вобще ежедненво это самый минимальный кусок времени когда логротейт сразбаывает. быстрее он неможет)

dateext = доабвляеть к архивному файлу тайм стамп (день месяц год)

nocompress  = несжимать архив потому что он уже и так сжат

notifempty = неархивирвать пустые файлы

nocreate = когда зааривхировал файл (он же его переимноваые и исходный иссчезает) то несозадвать новый. ибо незачем

missingok = если исходного файла нет то окей. номрально.это значит что логротейт сработал и убрал исходный файл а новый архив через крон
таки не появился. ну и хер сним

rotate 40 = хранить 40 архивных копий. а 41-ю удалять.


как проверить что logrotate будет рабооать, а вот только так:

# logrotate -v /etc/logrotate.d/mysql-backup  -f 

-f = завсталвяет насильно срабаывает ротейт. иначе он нихера делать неубутдет этого.

установка закончена.

===
ubuntu 

если завситли окна как презапусить cinanmon :


от прав простого юзера

$ cinnamon --replace -d :0.0

как отчлюит apport (котоырй краш дампы снимает)

# systenctl stop apport && systemcl diable apport


красота!

====
| snap

отключчить автоматическое оновление снапов

дело в том что по дефолту так там установлено что 4 раза в день система пытается обновить
каждый снап пакет. и это приводит к диким тормозам то бишь открываешь top 
и там висит бинарник snapd и жрет более 100%. и таких бинарников там может быть два например.
нахер это надо.

чтобы отключить обновление снапов надо :

# sudo systemctl stop snapd.service
# sudo systemctl mask snapd.service

чтоб вернуть обоатно

# sudo systemctl unmask snapd.service
# sudo systemctl start  snapd.service
# sudo snap refresh

приэтом сами снапы родолжают работать !

но это вреод как херноввый алгоритм остановки автоообновлений. более нормальный вариант это 
# snap refresh --hold=forever

===
| snap
еще очень полезная вещь про snap это то что если мы юзаем lxd контейнеры.
то нам внутри этих контейнеров то нам там обычно snap ненужен.
поэтому если запустили контейенр то нужно внутри него удалит snap иначе эта падла
будет проверять snap пакеты на новые версии и охиренно грузить процессор.

выглядит это так. смотри в top и видим там 100% загрузку цпу у процесса snapd и\или snapfuse
это точно значит что snap заимается обновланием. а это нам нахер ненадо.
поэтому внутри lxd корнтенера надо выполнить

# apt-get purge -y snapd*
===

| LXDE

есть такая легкая граф оболочка.
она по дефолту стоит в lubuntu
но ее без проблем можно поставит на классический убунту.
	# apt install lxde

и еще надо если нет поставит такую хрень как
	# apt install  lightdm

далее вот что . когда мы загрузили комп. и у нас экран где мы указываем логин пароль.
там сверху справа надо логином юзера есть белый круг. мы на него тыкаем и там есть список
граф оболочек которцю надо загрузить. там выбираем LXDE. и вуаля. мы в нее загрузися.

еше есть такой прикол что кнопка logout когда мы в LXDE зашли в убунту 18 ( в лубунту с этим проблем нет)
неработает. как быть. закрываем все окна у текушего юзера. и перезагружаем службу lightdm

# systemctl restart lightdm

и мы попадем обратно в окно где надо вводить логин пароль. тоесть таким макаром мы как бы 
добьемся функции logout


далее.
как убрать сраный "update notifier"
надо зайти в /etc/xdg/autostart
и удалить файл upd-*
суки


далее. 
как добавить русскуб клаву. 
в лубунту там есть раздел клава в панели управления. если же мы запустили lxde в убунту18
то делать нужно совсем по другому.

права кнопка на панели задач - "add\remove panel items" - add - "keyboard layout hadler" - ...
дальше уже понятно



===
| AC
| power
| battery

утилита для мониторинга уровня заряда мышки, аккумулятора

список устройств с аккумуляторами
$ upower -e
/org/freedesktop/UPower/devices/line_power_ADP0
/org/freedesktop/UPower/devices/battery_BAT0
/org/freedesktop/UPower/devices/mouse_hidpp_battery_3
/org/freedesktop/UPower/devices/DisplayDevice



$ upower -i /org/freedesktop/UPower/devices/battery_BAT0
  native-path:          BAT0
  vendor:               LGC
  model:                L18L3PF1
  serial:               2267
  power supply:         yes
  updated:              Вс 17 сен 2023 19:53:21 (24 seconds ago)
  has history:          yes
  has statistics:       yes
  battery
    present:             yes
    rechargeable:        yes
    state:               fully-charged
    warning-level:       none
    energy:              35,5 Wh
    energy-empty:        0 Wh
    energy-full:         37,07 Wh
    energy-full-design:  36 Wh
    energy-rate:         0,00280338 W
    voltage:             12,381 V
    percentage:          95%
    capacity:            100%
    technology:          lithium-polymer
    icon-name:          'battery-full-charged-symbolic'


$ upower -i /org/freedesktop/UPower/devices/line_power_ADP0
  native-path:          ADP0
  power supply:         yes
  updated:              Вс 17 сен 2023 18:03:20 (6649 seconds ago)
  has history:          no
  has statistics:       no
  line-power
    warning-level:       none
    online:              yes
    icon-name:          'ac-adapter-symbolic'


$ upower -i            /org/freedesktop/UPower/devices/mouse_hidpp_battery_3
  native-path:          hidpp_battery_3
  model:                Wireless Mouse M315/M235
  serial:               4009-b9-50-a6-d3
  power supply:         no
  updated:              Вс 17 сен 2023 19:52:52 (95 seconds ago)
  has history:          yes
  has statistics:       yes
  mouse
    present:             yes
    rechargeable:        yes
    state:               discharging
    warning-level:       none
    battery-level:       normal
    percentage:          55%
    icon-name:          'battery-good-symbolic'





$ upower -i           /org/freedesktop/UPower/devices/DisplayDevice
  power supply:         yes
  updated:              Вс 17 сен 2023 19:51:21 (201 seconds ago)
  has history:          no
  has statistics:       no
  battery
    present:             yes
    state:               fully-charged
    warning-level:       none
    energy:              35,5 Wh
    energy-full:         37,07 Wh
    energy-rate:         0,00280338 W
    percentage:          95%
    icon-name:          'battery-full-charged-symbolic'


| youtube

альтернативный плеер ютуба.

https://freetubeapp.io/#download
там есть бинарник для убунту



===

| cpu
| hyper-threading

статья = https://www.baeldung.com/linux/disable-hyperthreading


можно посмотеть через lscpu что у нас с гипертрейдингом.

а еще можно проверить что HT активировано вот так

# cat /sys/devices/system/cpu/smt/active
1

если 1 то гипертрединг актиирован


далее смотрим вот такое
$ grep -H . /sys/devices/system/cpu/cpu*/topology/thread_siblings_list 
/sys/devices/system/cpu/cpu0/topology/thread_siblings_list:0-1
/sys/devices/system/cpu/cpu1/topology/thread_siblings_list:0-1
/sys/devices/system/cpu/cpu2/topology/thread_siblings_list:2-3
/sys/devices/system/cpu/cpu3/topology/thread_siblings_list:2-3

отсюда мы видим записи вида 0-1 это значит что  cpu0 это реальное ядро. 
а  cpu1 это гипетредингвое ядро.
таким макаром мы понимаем что ядра 1 и 3 это фиктивные гипетрединговые ядра.

так вот щас мы будем их выключать налету.

# echo 0 | sudo tee /sys/devices/system/cpu/cpu1/online
# echo 0 | sudo tee /sys/devices/system/cpu/cpu3/online

после этого в top исчезнут гипертрединовые ядра.
ура


статья пишет что отключать их онлайн неочень желаттельно.
а включать обратно их онлайн типа категорически ненадо.

| 5GHz

обнаружил такой прикол. 
конекчусь к вай фай точке через 5GHz и имею 50% потери пакетов даже в рамках локалки
котрую обеспечивает эта точка.

конекчусь через эту точку по частоте 2GHz и все окей.


==



| opera
ее установка в ubuntu
я изрядно поебался с этим.

если ставить из snap то при запуске вылезает ошибка на экране вида уже не помню какого
а если при этом посмотреть journalctl -f 
то мы увидим ошибку :
	snap Failed to add PIDs to scope's control group Permission denied

я нашел пост что это изза корявого snap
цитирую 
(https://serverfault.com/questions/478946/how-can-i-create-and-use-linux-cgroups-as-a-non-root-user)

If you have recent enough Linux distribution you should be able to run processes in transient (temporary) cgroups, e.g.

$ systemd-run --user --scope /bin/bash
However, systemd is broken in many Linux distributions Ubuntu versions prior 21.10 and that fails with something like

systemd[2601]: run-rbe547d13ad2c41d7857ea9e660e51ab9.scope: Failed to add PIDs to scope's control group: Permission denied

The reason for this failure is that running transient cgroups without root requires support for cgroupv2 but Canonical really wants to push snap and using cgroupv2 would have broken snap until the snap had been patch enough. Ubuntu 21.10 is the first Ubuntu release that has smart enough snap to work with cgroupv2 so any older Ubuntu version is intentionally broken for transient cgroups to allow snap to run at all.

I guess distributions that do not even try to support the misfeature called snap will have much less problems supporting cgroupv2 and this should work with older distribution versions, too.

поэтому опера из snap на ubuntu 18 неработает.

если ее ставить из пакетов то надо найти такую версию которая при установке не будет 
ругаться что ей не хватает установленных зависимостей
для ubuntu 18 это версия https://download3.operacdn.com/ftp/pub/opera/desktop/90.0.4480.80/linux/

когда наконец мы ее поставили из пакета то еще один прикол - ютуб видео работают а 
видео с сайтов где кино нет. это потому что нужно в убунту поставить пакет с кодеками.
ставится оно так :
(https://gist.github.com/mkaraki/684cd27d6e09c19f986de03f63a55b5c)
	# sudo apt-get update
	# sudo apt-get install -y chromium-codecs-ffmpeg-extra
  # Import to opera
	# sudo ln -sf /usr/lib/chromium-browser/libffmpeg.so /usr/lib/x86_64-linux-gnu/opera/libffmpeg.so

это просто пиздец.
потом заходим на сайт = https://html5test.com/
и смотрим указано ли там что наш браузер теперь поддерживает H.264
если да. то сайты с кино должны заработать.

опера это пиздец. установка.


| laptop
| sn
| serial number

как узнать серийный номер ноутбука

# dmidecode



===
| tlp

дока - https://linrunner.de/tlp/usage/index.html

установка в уунту

# apt-get install tlp

проверка что tlp арботает
# tlp-stat -s
...
State          = enabled



===

| ip
| proc

как узнать ip на компе неимея команды ip 
используя только proc


# cat /proc/net/fib_trie

===
| apt-get update

вылвзииит ошибка

E: dpkg was interrupted, you must manually run 'sudo dpkg --configure -a' to correct the problem. 


решение
dpkg --configure -a


===

| terminal
| controlling terminal
| sigHUP

основной вопрос чем отличается sigterm от sighup
для этого надопонять в какой ситуации  у нас возникают эти сигналы.


навскидку sigerm это сигнал который шлет юзерский процесс другому процессу (через сисколл ествесттвенно) для того чтобы завершить тот другой процесс в штатном режиме. также
этот сигнал может послать и кусок ядра.

sighup шлется процессу когда ядро считает что  потеряна связь с его controlling terminal.
вначале я опишу все по простому. у нас в линуксе открыт терминал (черный экран) у него
в /dev есть соотсвстующий ему файл tty или pts.
узнать это можно вот так

$ tty
/dev/pts/68


далее мы в терминале  запускаем команду. эта команда будет в своих своствах 
иметь тот же самый терминал. этот терминал для нее назыается контрольным терминалом.
наскольк я понял в свойствах процесса может быть указан либо контрольный терминал
либо никакого терминала. терминала который бы был неконтрольным и был в своствах 
процесса такого терминала нет. итак в свойствах процесса либо есть терминал либо совсем
нет. если терминал есть то это контрглнеый термианал.

как узнать есть ли у прцоесса терминал контроьный или его нет и его номер

$ ps -p 579207
    PID TTY          TIME CMD
 579207 pts/66   00:00:00 sleep

команда ps когда покаызает свойства процесса то в столце "TTY" укаызает наличие 
контрольного терминала у процесса и его номер.


так вот самое главное - если мы черное окно терминала закроем то ( тут я точно незнаю)
то ли сам терминал пошлет все процессам которые были в его окне запущены сигнал SIGHUP
либо само ядро при уничтожении терминала пошлет все процессам SIGHUP сигнал.
таким оразрм в конечном итоге при закрытии окна терминала всем прцоессам которые были запущегны через окно этого терминала будет послан сигнал sighup. вот когда наступает
это событие. ну а дальше - sighup это сигнал который можно проигнорировать. поэтому 
если в процессе который был запузен в окне терминала стоит обработчик который может 
слать нахер этот сигнал то процесс будет продолжать работать. а если там нет кастомного
обработчика этого сигнала то  будет исползоваться дефолтовый ядерный обраблочткичик этого 
сигнала который будет уничтожать этот процесс. таким обоаом по дефолту  при поступлении
сигнала sighup в процесс этот процесс будет ядром уничтожен.

показают на примере.
открывают окно терминала. и в нем запускаю кучу башей

$ tty
/dev/pts/67

$ bash
$ bash
$ bash
$ bash
$ bash

$ ps aux | grep "pts/67"
vasya     579407  2.0  0.2  70532 45988 pts/67   Ss   05:15   0:00 bash
vasya     579421  1.1  0.2  70536 46040 pts/67   S    05:15   0:00 bash
vasya     579434  1.0  0.2  70536 46120 pts/67   S    05:15   0:00 bash
vasya     579447  1.3  0.2  70536 45852 pts/67   S    05:15   0:00 bash
vasya     579460  1.3  0.2  70536 45988 pts/67   S    05:15   0:00 bash
vasya     579480  1.3  0.2  70540 46032 pts/67   S    05:15   0:00 bash
vasya     579493  1.6  0.2  70540 46168 pts/67   S    05:15   0:00 bash

вот мы видим 7 процессов  укоторых контроный терминал pts/67

теперь  я закрывают окно терминала и по идее все эти бащ процессы будут уничтожены

$ ps aux | grep "pts/67"
пусто

значит все совпало. как только мы закрыли окно терминала pts/67
то все процессы у которых этот терминал был контршьным терминалом были уничтожены системой.
еще раз почему они были уничтжены - птому что к ним всем был направлен сигнал SIGHUP
и либо в баше стоит обрабочик который в ответ на этот сигнал просит ядро уничтожить
этот процесс либо был задействтвван дефолтовый ядерный обрабочик этого сигнала который
уничтожает этот проецесс.


нахуй этот SIGHUP нужен? а нужен он истоически вот для чего - это сейчас у нас терминал
это просто программа  с черным экраном раоботаюшая локально на нашем компе а раньше все было
иначе - раньше терминал это была  реальная железка с клавой и экраном и проводом serial к 
мейнфрейму. терминал не имеел ни памяти ни цпу он имел только клаву экран и  срведство связи 
с мейнфрейом на котором уже были цпу и память. так вот через терминал юзер запускал программы
на мейнфрейме. и если мейнфрейм считал что связь с терминалом потеряна то надо было уничтожить все те программмы которые были запущены  сэтого терминала. таким обоазом 
кажый процесс имел свойства с какого термиала он был запущен. и при падении связи между 
мейнфреймом и терминалом все эти проги дожны быть уничтожены. при падении связи с терминалом
какойто кусок ядра понимал что связт нет. и он слал все процессам принадлежащим этому терминалу сигнал SIGHUP. тогда шедулер когда доходил до таких процессов то он вместо того
чтобы их пихать на цпу их убивал. также как я понимаю когда человек заканчивать сессию
на терминале с мейфнфрейомм либо жал кнопку либо послыла команду на мейнфрейм о том что 
он заканиывает сессию что видим тоже слало сигнал SIGHUP. теперь я думаю все стало понятен 
смысл всей этой шарманки.

если мы запуакмаем из терминала пргармму и нехотим чтобы она была убита после того
как терминал буде закрыть то надо заюзать прогу nohup

пример

$ tty
/dev/pts/67
$ nohup sleep 200

$ ps aux | grep sleep
vasya     580035  0.0  0.0  14588   836 pts/67   S+   05:26   0:00 sleep 200

видим что наш процесс sleep 200 имеет в своих свойствах указанный коонтрьный терминал 
pts/67

закрыаем теперь окно терминала

проверяем была ли убита при этом программа

$ ps aux | grep sleep
vasya     580035  0.0  0.0  14588   836 ?        S    05:26   0:00 sleep 200

видим что небыла. прогармма продорлжает работать. а столбец который показыает 
номер контрщлного терминала для процесса стоит "?"


далее еще интереный момент - я всегда думал что если у процесса есть контрльный терминал
то это значит что в /proc/$PID/fd есть  файловые дескрипторы которые ведут 
в /dev/pts/67

однако оказалос что это не всегда так...
а именно
беерм запускаем процесс

$ sleep 600

$ ps aux | grep "sleep 600"
vasya     580496  0.0  0.0  14588   832 pts/73   S+   05:34   0:00 sleep 600

видим что у него контролный терминал это pts/73

идем в proc для этого процесса

$ ls -1al  /proc/580496/fd
total 0
dr-x------ 2 vasya vasya  0 июл 24 05:35 .
dr-xr-xr-x 9 vasya vasya  0 июл 24 05:35 ..
lrwx------ 1 vasya vasya 64 июл 24 05:36 0 -> /dev/pts/73
lrwx------ 1 vasya vasya 64 июл 24 05:36 1 -> /dev/pts/73
lrwx------ 1 vasya vasya 64 июл 24 05:36 2 -> /dev/pts/73

видим что да у процесса открыто три файла (0,1,2) все они ведут в терминал pts/73


а тепер посмтрим какая ситуация коггда мы запускаем комнду с nohup

$ nohup sleep 700
$ ps aux  |  grep "sleep 700"
vasya     580624  0.0  0.0  14588   832 pts/75   S+   05:37   0:00 sleep 700

видим что для процесса указано что у него в свойствах указан терминал pts/75
идем в proc и что мы там видим


$ ls -1al  /proc/580624/fd
total 0
dr-x------ 2 vasya vasya  0 июл 24 05:38 .
dr-xr-xr-x 9 vasya vasya  0 июл 24 05:38 ..
l-wx------ 1 vasya vasya 64 июл 24 05:38 0 -> /dev/null
l-wx------ 1 vasya vasya 64 июл 24 05:38 1 -> /home/vasya/nohup.out
l-wx------ 1 vasya vasya 64 июл 24 05:38 2 -> /home/vasya/nohup.out


мы видим что у нас открыто три файла (0,1,2) но ни один из них не ведет в терминал!!!

посморим что за файл nohup.out
$ stat /home/vasya/nohup.out 
  File: /home/vasya/nohup.out
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 24918099    Links: 1

видим что это "regular empty file"
тоесть это прям обычный файл физически лежащий на диске. 

таким образом я не очень понимаю связь этого процесса с терминалом.  дело в том 
что всегда утверждалось что если в свойствах прцоесса указано что у него есть
контрльный терминал то это мол всегда значит что процесс может читать с терминала (через его спец файл /dev/pts/75) либо писать на терминал

а тут мы видим что такой процесс не может ни читать с термиала ни писать на него 
потому что у него неоткрто устройство терминала.... да.. вот это непонятно...

===

| bench
| benchmark
| unixbench


из статьи на habr
 вылезла утилита для замера бенчмарка unixbench
есть только в виде снапов

# snap install unixbench

если у нас много ядер то надо запускать в много ядероом реижиме

# unixbench -c 4
где 4 это число ядер на компе об этом написано тут https://github.com/kdlucas/byte-unixbench/blob/master/UnixBench/USAGE

а тут написано что значит каждый тест https://github.com/kdlucas/byte-unixbench

в целом это бенчмарк связки цпу-память-ос

резульатты на лэптопе

------------------------------------------------------------------------
Benchmark Run: Fri Jul 28 2023 13:38:38 - 14:03:46
8 CPUs in system; running 4 parallel copies of tests

Dhrystone 2 using register variables       66298940.7 lps   (10.0 s, 7 samples)
Double-Precision Whetstone                    10849.2 MWIPS (9.8 s, 7 samples)
Execl Throughput                               6776.4 lps   (29.5 s, 2 samples)
File Copy 1024 bufsize 2000 maxblocks        707440.0 KBps  (30.0 s, 2 samples)
File Copy 256 bufsize 500 maxblocks          180685.6 KBps  (30.0 s, 2 samples)
File Copy 4096 bufsize 8000 maxblocks       1606002.7 KBps  (30.0 s, 2 samples)
Pipe Throughput                             2452775.6 lps   (10.0 s, 7 samples)
Pipe-based Context Switching                 212090.1 lps   (10.0 s, 7 samples)
Process Creation                              11992.4 lps   (30.0 s, 2 samples)
Shell Scripts (1 concurrent)                  18533.0 lpm   (60.0 s, 2 samples)
Shell Scripts (8 concurrent)                   2501.5 lpm   (60.0 s, 2 samples)
System Call Overhead                        2347375.8 lps   (10.0 s, 7 samples)

System Benchmarks Index Values               BASELINE       RESULT    INDEX
Dhrystone 2 using register variables         116700.0   66298940.7   5681.1
Double-Precision Whetstone                       55.0      10849.2   1972.6
Execl Throughput                                 43.0       6776.4   1575.9
File Copy 1024 bufsize 2000 maxblocks          3960.0     707440.0   1786.5
File Copy 256 bufsize 500 maxblocks            1655.0     180685.6   1091.8
File Copy 4096 bufsize 8000 maxblocks          5800.0    1606002.7   2769.0
Pipe Throughput                               12440.0    2452775.6   1971.7
Pipe-based Context Switching                   4000.0     212090.1    530.2
Process Creation                                126.0      11992.4    951.8
Shell Scripts (1 concurrent)                     42.4      18533.0   4371.0
Shell Scripts (8 concurrent)                      6.0       2501.5   4169.1
System Call Overhead                          15000.0    2347375.8   1564.9
                                                                   ========
System Benchmarks Index Score                                        1932.1

---------------

| grep 
пидец нахуй блядь.
вот что выяснил

вот у нас есть файл

$ cat 1.txt 
1
2
3


опция -C N покзаывает N строчек сверху и снизу от найденной строки . тоест

$ grep -C1 "2" 1.txt
1
2
3

так вот пиздец в том что можно убрать "C" и оставти толко "-1"
пример

$ grep -1 "2" 1.txt
1
2
3

ниге ни в man нни в info я об этом ненашел. суки блядь ебаные.

дале ключи -r и -R в чем разница. вроде как в том что -r неследует симлинкам а -R следует.

таким оюоразом

# grep -r2 "vasya"  = grep -r -C 2 "vasya"


====

| passwd
| shadow
| пароли

известно что пароль юзера хранится в /etc/shadow
но там не все так просто,
дело в том что оказывается используется целая серия спец техник чтобы сделать задачу 
вычисления пароля хрен какой сложной.
поэтому прежде чем лезть в /etc/shadow отойдем в сторону:
самая простая техника хранитть пароль на компе так чтобы его затруднить взломать это хэширование его.
хэш эта такая функция f(A)=B где A это пароль а B это хэш. фишка в том что природа это функции такова 
что зная A можно относительно быстро вычислить B. тоесть зная пароль мы быстро узнаем для него хэш.
так вот природа функции такова что типа нет возможности составить обратную функцию которая бы нам позволила
зная зная B хэш вычислить пароль A.
таким макаром мы можем на компе хранить пароли в виде хэша. если ктото узнает хэши то он не может 
составить алгориттм чтобы на основе этих хешей узнать пароли. таким образом наличие хэшей 
у  злодея не дает ему возможность вычислить пароли. в тоже время когда юзер с клавы вводит парольь то ядро
вычисляет по нему хэш и сранивает с хешем что хранится в файле. если хеши совпали значит юзер ввел
верный пароль. таким образом хеш позволяет системе быстро понять ввел ли юзер верный пароль и при этом 
сам пароль не хранится на компе. и если злодей завладел хешами это ему не дает ничего. почти ничего.
дело в том что злодей имея хеши с нашего компа может сделать вот что. он выбирает длинну пароля.
потом он берет первый рандомный пароль вычисляет от него хеш и сравнивает с хещем из файла. если хеши
совпали то пароль найден. посокольку хеш вычисляется относительно быстро и поскольку юзеры часто придумывают
короткий и простой пароль то методом перебора можно подобрать пароль очень даже быстро. если юзер использует 
длинный пароль и в котором еще всякие спецсимволы тогда методом перебора злодей хрен подберет пароль.
таким образом сам алгоритм хеша очень надежный и напрямую вычислить по нему исходный пароль невозможно
но если пароль короткий и простой то его можно подобрать методом перебора очень быстро. это похоже 
как бутто мы имеем сейф. на нем три ручки. сам сейф хрен взломаешь. но если мы выбрали что сейф должен быть 
открыт если мы покрутили ручки три раза то подобрать пароль методом тыка будет быстро. а если мы выбрали 
что сейф может быть открыт если покрутть сейф 250 раз то методом тыка хрен подберешь пароль.
значит в итоге становится ясно что сложность "взлома" пароля при хешировании зависит от двух моментов.
во первых от сложности найти обратный алгоритм для функции хеширования и во вторых от того насколько 
длинный и сложный пароль будет использован. с первым моментом все понятно оно очень надежно. 
а вот со вторым моментом все хуже. юзер всегда хочет придумать короткий и просто пароль.
значит надо как то исправить. 

и тут на помощь приходит первая спец техника = key stretching или password stretching.
эта хрень берет пароль юзера и его модифицирует так что он становится значительно длиннее 
и сложнее. работает на практике это например так (https://en.wikipedia.org/wiki/Key_stretching)
мы берем пароль юзера и вычисляем от него хеш . и этот хеш как бы становится новым паролем.
поскольку хеш по своей длинне это длинная хрень. всегда длинная хрень. скажем 256 байт или 512 байт
длинной. тоесть мы берем пароль длинной 3 байта. вычисляем от него хеш. получаем хрень длинной 
256,512 байт. получается новый "пароль" гораздо длиннее и сложнее. теперь имея такой "новый пароль"
мы вычисляем от него хеш и сохраняем его в файле. так написано в вики. правда тут этот механизм
по факту все таки не приводит по мне к удлиннению пароля.  потому что с точки зрения подбора пароля
через механизм перебора все стало лишь слегка труднее а не значительно труднее. злодей теперь
доллжен всего навсего взять предполагаемый пароль и вычислить от него хеш но не один раз а два раза.
поэтому я не согласен что такой механизм как бы нам удлинняет длинуу пароля. это хрень собачья.
единственное что этот механизм зотрудняет подбор пароля через перебор но с другого бока а именно. 
если возьмем пароль юзера и вычислим от него хеш скажем 100 000 раз и потом запишем финалный хеш 
в файл то злодей должен будет когда перебирать пароли то вычислять для каждого кандидата хеш 100 000 раз.
проверим насколлько быстро может современный цпу высчитать хеш 10 000 раз 

    $ i=1; time ( while [ $i -le 10000 ]; do let "i+=1";  echo 1 | sha256sum >/dev/null; done )

оказалось что это занимает 62 секунды.
получается что если мы возьмем пароль из клавы  потом высчитаем от него хеш 10000 раз 
и запишем финальный хеш в /etc/shadow то чтобы система могла проверить правильный ли пароль ввел 
юзер ей придется тоже вычислить хеш 10 000 раз. и проверить вычисленный хеш с тем что  в файле. 
и это займет 1 минуту. тоесть юзер будет ждать входа в систему 1 минуту. это минус.
но зато злодей который захочет подобрать пароль по хешу должен будет при переборе  для каждого
кандидата пароля высчитывать 10 000 хешей и ждать 62с. а это очень долго. получается что скажем
на 1 ядерном процессоре он за сутки сможет перебрать только 1 440  кандидатов под пароль. 
а за пол года можно перебрать 259 200 штук
если мы используем для пароля символы ASCII который 127 штук то таким макаром за пол года нельзя
будет перебрать все варианты для пароля длинной даже 3 символа. тоесть
    $ echo "127^1" | bc
    127
    $ echo "127^2" | bc
    16129
    $ echo "127^3" | bc
    2 048 383

таким макаром если мы согласимся терпеть что при входе юзера система должна будет считать 10 000 хешей чтобы проверить верность пароля и и юзер должен ждать 1 минуту то грубо говоря юзер может иметь пароль всего 4 символа и его нихрена нельзя будет подобрать даже за полгода на одноядерном цпу.
если же юзер будет иметь пароль длинной 8 символов то сложность подбора (время подбора ) его пароля возрастет в 127*127*127 ~ 1 000 000 раз. 
неплохо. 
последнее что хочу сказать про key strengthen (password strengthen) это то что по мне как обычно
выбрано очень хуевая терминология для данной технологии. с паролем ничего не стренгсится. усложняется
по времени алгоритм проверки коректности пароля. тоесть
    вводим пароль ---> алгоритм проверки = время
чем более трудоемкий по времени процесс проверки коректности введенного пароля
тем сложнее его подобрать брут форсом. 
тоест в статье в википедии говорится о том что якобы эта техника "удлинняет" длинну пароля. 
и из за этого его подобрать сложнее. по мне такое обьяснение полнаяхуйня.
пароль не удлинняется. а увеличивается по времени алгоритм проверки коректности введенного пароля.
это и приводит к тому что подобрать пароль путем перебора становится по времени гораздо дольше.
рассмотрю более реальный пример для практики в том смысле что ждать 62 секунды для проверки
коректности это очень долго поэтому рассмотрю вариант когда мы снижаем число хешей  с 10 000 до 1 000
тогда время проверки сокрашается до 2.6с это время юзер уже может подождать при входе в систему.
при таком алгоритме злодей методом перебора может перебрать 
тогда за 1 минуту брутфорсом можно перебрать 23 пароля.
значит за полгода можжно перебрать вариантов паролей
    $ echo "60*24*30*6*23" | bc
    5 961 600

если мы используем для пароля символы ASCII которых 127 штук то пароль длинной 3 символа
имеет вариантов
    $ echo "127^3" | bc
    2 048 383
значит за полгода можно подобрать пароль только если он состоит из 3 символов по длинне.
ну и чуть чуть перебрать варианты паролей длинной 4 символа.
но в целом за полгода можно будет сломать только пароль длинной всего 3 символа длинной.
таким макаром я думаю я закончил над темой "key strengthen"

таким макаром на данный момент с точки зрения как нам сохранять пароль на компе 
мы пока что приходим к схеме условно такого вида. мы берем пароль , вычисляем от него хеш 
скажем на основе sha-256 одну тысячу раз и записываем этот хещ в /etc/shadow
и это нам как бы дает такую штуку что подобрать пароль длинной даже 4 символа нельза на 
компе через перебор даже за пол года.
но тут выходит на сцену другой способ  поиска пароля - через заранее высчитанные хеши. 
то есть мы берем 1 000 компьютеров. и начинаем на каждом брать варианты пароля , высчитывать от него
1 000 хешей и суммарный хеш записывать  в базу данных. таким макаром посчитав один раз все варианты
хещей для паролей скажем 8 символов мы будем иметь таблицу. и тогда посчитав такую таблицу один раз
мы потом просто будем брать хеш из /etc/shadow и искать этот хеш  в нашей таблице.
и тут нам в спасение приходит следущая техника

техника salt
техника состоит в том что мы берем пароль юзера из клавиатуры и добавляем к нему некоторый дополни
тельный хвост. хвост можно брать либо на основе имени юзера либо некий рандомный 
например исходный пароль "12df" мы  к нему добавляем salt "rf45@4ff"
таким образом новый пароль "12dfrf45@4ff"
а далее действуем по ранее описанному алгоритму вычисляем для этого пароля 1000 хешей.
это нам дает то что теперь наша заранее высчитанная таблица хешей для некоторого множества паролей
стала теперь неактуальной. нам надо брать и высчитывать эту таблицу заново. поскольку таблица 
высчитывалась из расчета того что ее можно многократно использовать для поиска не только одного пароля
а для поиска разных паролей тоесть чтобы одну заранее высчитанную таблицу можно было использовать 
много раз неоднократно теперь это не возможно потому что если для двух паролей испольуется два разных
salt то это делает таблицу хешей высчитанную для одного salt бесполезной для поиска пароля 
который юзает другой salt. таким образом злодей в случае использования salt вынужден будет для
подбора пароля вернуться в предыдущему методу - методу перебора.

таким образом я обсудил две техники "key strengthen" и "salt"
теперь для записи пароля в /etc/shadow мы делаем вот что:
мы берем пароль, потом мы к нему добавляем рандомный salt, потом мы от этого высчитываем 1000 хешей
и  записываем этот хеш в /etc/shadow

как вычислить sha-256 хеш:
    $ echo -n password123 | openssl dgst -sha256
    (stdin)= ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
либо
    $ echo -n password123 | sha256sum 
    ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f  -


дальше перехожу уже к линуксу на практике. как он хранит пароли и как он 
проверяет верность пароля когда юзер его ввел.
пароли хрантся в /etc/shadow
описание поле смотрим в 
    $ man shadow
а именно
запись имеет несколько полей. поля разделяются двоеточиями ":"
пример записи для юзера vasya2
    $ sudo cat /etc/shadow |  grep vasya2:
я разделил поля с двоеточиями доп пробелами

vasya2 : $6$BbSw9Q10$L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh. : 19430 : 0 : 99999 : 7 :::

первое поле это тип хэша,
второе поле это пароль. точнее это достаточно сложная хрень

$6$BbSw9Q10$L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh.

поля внутри этой хрени разделяются через знак доллара "$"
я добавил доп пробелы чтобы показать поля внутри пароля

$ 6 $ BbSw9Q10 $ L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh.

первое поле  в данном случае "6" показыает тип хэша 
виды хэшей. виды хэшей можно посмтреть через 
    $ man openssl-passwd

там видим

  -crypt
           Use the crypt algorithm (default).

  -1  Use the MD5 based BSD password algorithm 1.

  -apr1
           Use the apr1 algorithm (Apache variant of the BSD algorithm).

  -aixmd5
           Use the AIX MD5 algorithm (AIX variant of the BSD algorithm).

  -5
  -6  Use the SHA256 / SHA512 based algorithms defined by Ulrich Drepper.  See <https://www.akkadia.org/drepper/SHA-crypt.txt>.



итак -6 это SHA512

как я понял никак нельзя указать линуксу какой иенно хэш алгоритм юзать. 
он всегда юзает -6 при запист пароля в /etc/shadow если мы юзаем 
    $ passwd vasya2
хотя все таки можно заюзать другой хеш если мы сформируем строчку в /etc/shadow
вручную. (об этом гораздо далее смотри ниже)

второе поле это так называемый "salt"
в данном случае он равен "BbSw9Q10"
гениально. возникает вопрос а откуда взялся salt ведь мы при генерации проля в линуксе
никакой salt неуказыаем. ответ - как я понимаю линукс сам автоматом генерирует salt.
вобщем то удобно. 
salt указан в открытом виде.
проверим теорию с практикой. изменим паролоь для vasya2 на "temp"
    # passwd vasya2

получаем

vasya2:$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0:19568:0:99999:7:::

тогда мы имеем 
$ 6 $ CWvpCyfP $ owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0

значит алгоритм хэширование 6 тоесть SHA512
salt = CWvpCyfP
пароль мы знаем "temp"

сгенеририуем "руками" теперь хэш учитывася все эти данные и проверим получим 
ли мы такой же хэш как в shadow

$ openssl passwd -6 -salt CWvpCyfP temp
$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0


сравниваем с тем что в shadow
$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0

полное совпдание! теория совпала с праткикой!

кстати прикол что команда выглядит как 
$ openssl passwd
а ман у нее выглядит как
$ man openssl-passwd 

вобще меня на тему shadow навеля это супер статья https://tbhaxor.com/linux-file-permissions/

сравним как выглядит хэш для разных алгоритмов хэша

$ openssl  passwd -crypt temp
lEMHJ3vYIIqsE

$ openssl  passwd -crypt  temp
nKMXOc5hv9SPQ

видно что пароль один и тотже  а хэш разный. видимо он в себя включает 
и salt котоырй автоматом генерируется

$ openssl  passwd -1 temp
$1$UktQ/3s9$a/n2XHoslh.6hwApLdvtV0

$ openssl  passwd -apr1  temp
$apr1$yefESuP3$.W8joK2N12pRHrwHQULKN/

$ openssl  passwd -aixmd5  temp
whIbFfIj$Taivy0xyFOh9ps8Z2dKab.

видно что все три алогритма юзают автосгененирровынный salt (второй столбик с раздели
телем $)


$ openssl  passwd -5  temp
$5$doWL/NwAisNd2cwS$Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3

$ openssl  passwd -6  temp
$6$QEe4qtY9ShP6jVnR$RIzSSyJx0VvrAVjK/6fj.co5fFnapX50ZVaJXNr75Ah0GNWO.rmSr5j76xEuAEQHc6OaQPTSuSEgSFOUKlHY31

в последнем сслучае salt=QEe4qtY9ShP6jVnR
сегенерируем хэш тип 6 

$ openssl  passwd -6 -salt QEe4qtY9ShP6jVnR temp
$6$QEe4qtY9ShP6jVnR$RIzSSyJx0VvrAVjK/6fj.co5fFnapX50ZVaJXNr75Ah0GNWO.rmSr5j76xEuAEQHc6OaQPTSuSEgSFOUKlHY31

видно что совпало. мы верно определили salt

итак на первый взгляд вроде бы мы разгадали что значит строка в /etc/shadow
однако это нихуя не так.
дело в том что - вот возьмем строку вида
$ openssl  passwd -5  temp
$5$doWL/NwAisNd2cwS$Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3

пароль = temp
5 - значит sha-256
salt = doWL/NwAisNd2cwS
хэш  = Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3

так вот если мы возьмем пароль "temp" прилепим к нему salt 
и потом вычислим от него sha-256 то мы нихуя не получим то что стоит в поле хеш.
а все потому что команда "openssl password ..." и команда "passwd .." они используют
системную библиотеку crypt(3) так вот она невычисляет хеш однократно. нет.
согласно 
    $ man 3 crypt
цитирую
Since glibc 2.7, the SHA-256 and SHA-512 implementations support a user-supplied number of hashing rounds, defaulting to 5000.

тоесть эта функция вычисляет хеш 5000 раз. 
поэтому если мы хотим проверить хеш руками то нам надо его вычислить 5000 раз.
я этим займусь но чуть ниже потому что 
есть еще один прикол состоит в том что хеш-256 эта хрень должна иметь по определению 256 байт
но если мы помотрим на хеш
    Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3
то мы легко увидим что его длинна всего 43 байта
    $ echo "Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3" | awk '{print length }'
    43

что за хуйня? оказывается дело вот в чем. нам нужно хеш засунуть в файл текстовый. но 
сам алгоритм хеш sha-256 он сформирует последовательность из 256 байт но прикол в том 
что далеко некаждый байт в этой последовательности является печатным\текстовым согласно ASCII
кодировки а это типа хреново потому что /etc/shadow имеет вид текстового файла по своему формату. поэтому после того как получен чистый хещ sha-256 происходит дополнительная хрень --> хеш транформируется в чистый 
текст но и тут подьбека перекодирование в текст идет не через base64 а через такую хуйню как radix64.
итак еще раз когда мы запускаем команду passwd то она вызывает glibc функцию crypt
которая берет пароль, придумывает для него рандомный salt. потом она вычисляет хеш 5000 раз.
обычно это хеш sha-512 и в конце этого она преобразует этот хеш в чистый текст через radix64.
и вот то что получается уже запсывается в /etc/shadow

значит два следущих шага которые надо сделать
1) получить чистый хеш sha-256\512 и руками его трансформировать в radix64
2) руками вычислить хеш 5000 раз
3) полностью руками сформировать строку в /etc/shadow для юзера vasya2 и пароль temp


разбираю "1)".
разбираюсь что такое кодировка radix64.
согласно этой статье 
    https://medium.com/swlh/base64-encoding-algorithm-42abb929087d
утверждается что слово radix означает основание системы счисления. тоеть бинарное счисление
это radix-2. (цифры 0 и 1). а система счисления radix-10 это 0..9
а radix-64 это счисление на основе символов в размере 64 штуки. (0..63).
я правда не понял навскидку символы обязательено цифры или нетолько.
из этой же сттатьи утверждаетс что radix64 и base64 это одно и тоже.
статью я только начал читать но не дочитал.
зато я нашел нечто более короткое по теме. 
    https://superuser.com/questions/1629013/what-kind-of-encoding-is-this-sha256-variant
во первых sha-256 дает не 256 байт на выходе а 256 бит то есть 32 байта.
также sha-512 дает на выходе 64 байта
итак sha-256 выдает  на выходе поток байтов длинной 32 байта.
пример
    $ echo -n "1" | sha256sum  | awk '{print $1}'
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b

значит то что мы получили на выходе команды sha256sum это поток байтов длинной 32 байта
расписанный в текстовом виде в hex формате
важно осознать что я только что описал
на выходе получаем поток байтов в размере 32 штук, но так как эти байты нужно как то 
перевести в печатные символы. дело в том что брать байты и тупо пытаться их отрисовать на экране
через ASCII или UTF кодировку для них не выход. они берут байтовый поток и конвертируют его 
в печатные символы в hex виде. тоесть вот мы видим на экране 
    6b....
мы видим печатные символы которые по факту отображают поток байтов который на основе
кодировки ASCII\UTF (для первых 127 символов ASCII кодировка совпадает с UTF-8 которая по факту
используется в линуксе поэтому мы можем спокойоно работать с ASCII кодировкой вместо UTF) был преобразован 
терминалом в печатные символы. таким макаром выполним обратное преобразование из печатных символов
в байтовый поток.
ASCII:
    6 = 36(hex)
    b = 62(hex)

таким макаром печатные символы на экране 6b соотвествуют потоку байтов 3662
действительно проверим это 
    $ echo -n "6b" | od -t x1
    36 62

так вот я так долго описывал эту шнягу чтобы сказать что на самом деле преобразоывать печатные
символы в поток байтов ненужно! потому что sha256sum уже показывает 
чистый байтовый поток причем да через печатные символы но в hex формате.
тоесть 
вот мы видим
    $ echo -n "1" | sha256sum  | awk '{print $1}'
    6b...
это значит что перый байт в байт потоке 6b(hex) тоесть печатные символы 6b ненужно преобразовывать 
в байты через ascii кодировку. 6b это уже и есть первый байт потока 6b(hex)
итак 
    $ echo -n "1" | sha256sum | awk '{print $1}'
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b
нам уже сразу показывает какой истинный хеш (поток байтов)

тогда я нихуя не понимаю почему статьи до этого писали что sha256sum вычисляет хеш.
получает байтовый поток и потом его перекодирует в текстовые символы через кодировку radix-64
которая по одной статье это ничто иное как base64 кодировка а по другой статье это некая 
другая кодировка. пиздец. кстати hex формат это base16 кодировка. ебаааать.

ладно. теперь надо понять как нам вычислить хеш от хеша.
для начала
    $ echo -n "1" | sha256sum -t
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b  -
    $ echo -n "1" | sha256sum 
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b  -

из чего следует что по дефолту sha256sum  работает в текстовом режиме. так и написано в
man
далее
    $ echo -n "1" | sha256sum -b
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b *-

видно что мы получили тот же хеш хотя мы вычисляем в бинарном режиме.
что за пизец. вчем разница текствго режима и бинарного? оказывается в линуксе разницы нихуя никакой.
(https://stackoverflow.com/questions/17988090/what-are-the-differences-between-md5-binary-mode-and-text-mode)

в итоге мы забываем про эту хуйню текстовый режиме, бинарный режиме. разницы нкиакой.
по факту число "1" это 31(hex) байт который летит в sha256sum
и тот вычисляет хеш от этого байт потока

    $ echo -ne "\x31"
    1
 
    $ echo -ne "\x31" | sha256sum
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b *-
 
как видно хеш тот же самый.
тоесть еще раз хеш вычисляется не от числа "1" нет. это печатный символ который 
на основе ascii представляет собой байт 31(hex) и именно от этого байта вычисляется хеш.

теперь кода мы поняли от чего вычисляется хеш и что мы получаем на выходе то для
того чтобы посчитать новый хеш от первго хеша у нас проблема.
потому что нам нужно полученный base16 хеш
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b *-
преобразоывать в bin хеш ( в поток байтов ) и только после этого его можно направлять на sha256sum
если же мы просто напросто направим   6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 
в sha256sum то получим не то что надо . потому что мы направим не поток байтов нужных нам 
а поток ascii символов у которых байтовый поток их кодирующий совершенно другой.
и я нашел для этого команду

$ echo -n  "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b" | xxd -r -p | od -t x1
0000000 6b 86 b2 73 ff 34 fc e1 9d 6b 80 4e ff 5a 3f 57
0000020 47 ad a4 ea a2 2f 1d 49 c0 1e 52 dd b7 87 5b 4b
0000040

видно что символы превратились  в нужный поток байтов

в итоге вот команда которая вычисляет хеш от хеша потока байтов 31h (символ "1")

$  echo -n  "$(echo -n "1" | sha256sum| awk '{print $1}' )" | xxd -r -p | sha256sum | awk '{print $1}'
9c2e4d8fe97d881430de4e754b4205b9c27ce96715231cffc4337340cb110280

awk нужен потому что sha256sum выдает падла не только хеш но некую хрень во втором столбце
которая нам нахен ненужна. поэтому ее нужно отрезать.

таким образом radix64 отвалился сам собой ибо sha256sum вообще его нахен неиспользует.
и пункт "1)" я выполнил.

что касается пункта "2)" то хеш от хеша я вычислил. 
теперь остается написать программу которая вычислить хеш от хеша 5000 раз.
этим сейчас и замемсся

итак я написал такой скрипт

$ cat 1.bash 
#!/bin/bash
			    # переменные
p="temp"       # password
n=10000        # число хешей
salt="jwAMQACK"


			    # тело скрипта
echo "пароль = $p"
echo "salt = $salt"
sp=$salt$p
echo "salt\пароль = $sp"
echo "макс число хешей = $n"
start=$(date +%s)  		# начало выполнения скрипта
echo "salt\пароль в hex = $(echo $sp | xxd -p)"

h1=$( echo -n "$sp" | xxd -p ) 	# конвертируем пароль в base16 (hex) формат
for i in $(seq 1 1 $n)
do
  h2=$( echo -n "$h1" | xxd -r -p | sha512sum | awk '{print $1}'  )
  h1=$h2
echo -ne "текущий хеш $i-ый  = $h2 \r"

c1=$( echo -n $h1 | cut -b 1-4 )
if [ "$c1" = "9263" ];then echo "gotcha!";break;fi

done
echo ""
end=$(date +%s)
echo "Время выполнения скрипта: $(($end-$start)) секунд"


его вывод на  экран

$ ./1.bash 
пароль = temp
salt = jwAMQACK
salt\пароль = jwAMQACKtemp
макс число хешей = 10000
salt\пароль в hex = 6a77414d5141434b74656d700a
текущий хеш 271-ый  = 2f752fcba2c5d118016dbdf0214599ffa977ab73227e1dd215b5052689aed9c235e7d8c3c221ccc8e3cd548928a147f9a38f39327d5eb91ca9950ecdef9030cd 
Время выполнения скрипта: 10 секунд


далее я хотел бы перейти к /etc/shadow
по идее остается добавить salt к скрипту и попоробовать воспроизвести работу библиотеки crypt(3)
но перед этим посмотрим на 

    $ openssl passwd -5 -salt CWvpCyfP 1
    $5$CWvpCyfP$vqBpX.PqU0cw/1GbfU0s.brWw7a8kMEk8c/4zPIvRv3

мы видим в нем хеш 
    vqBpX.PqU0cw/1GbfU0s.brWw7a8kMEk8c/4zPIvRv3

и тут очевидно что мы видим что наш хеш показан точно не в формате base-16
это либо base64 или чтото ему подобное.

тут я расскажу что такое base64 кодирование. хорошо описано тут - (https://superuser.com/questions/1629013/what-kind-of-encoding-is-this-sha256-variant)
работает это так. берется поток байтов где байт это 8-бит в виде битов. потом этот поток разбивается на куски 
по 6 бит. а далее каждый каждый такой 6-битный блок заменяется на символ ASCII.
но используются не все символы ascii а только часть а именно
используются вот такие символы ASCII "A-Z a-z 0-9 + /"
а правило замены такое

0 заменяется на A
1 заменяется на B
...
...
62 заменяется на +
63 заменяется на /

поскольку 6 бит это числа от 0 до 63 то и получается что используется 64 символа ASCII

после замены каждого 6 бит исходного байто потока на некоторый символ ASCII .Что значит 
замена на символ ASCII - это значит что исходные 6 бит заменяются на 1 байт (8бит)
который выбирается исходя из ascii таблицы.

например исходные 6бит 000000 (тоесть 0dec) заменяется на A то есть на 41h (для "A" в ascci
соотвествует байт 41h). тоесть в байт потоке было 000000 стало 41h (8bit)
получается исходный байт поток преобразуется вдругой байт поток по размеру больше на 8\6 
тоесть конечный поток будет больше на 33%. тоесть еще раз вот мы имеем исходный поток байтов

0h 0h 0h => трансформируем его вбиты и группируем по 6 бит => 
=> 0000 0000  0000 0000  0000 0000  => 0000 00|00  0000| 0000  00|00 0000| 
потом по таблице меняем кажду группу из 6бит на байт согласно таблице замены на ascii символ.
тоесть
0 заменяем на A (41h)
значит => 41h 41h 41h 41h
таким образом было 
    0h 0h 0h
стало
    41h 41h 41h 41h

проверим на практике:
    $ echo -ne "\x0\x0\x0" |  od -t x1
    0000000 00 00 00
этим я показал что у нас в пайп передается именно поток байтов вида 0h 0h 0h

далее я байты 0h 0h 0h пускаю на base64 
и мы видим что на выходе мы получили 41h 41h 41h
    $ echo -ne "\x0\x0\x0" | base64 -w0 | od -t x1
    0000000 41 41 41 41
    0000004

а тут я не кодирую поток в base16(hex) а я его просто пускаю на терминал
который интепретирует байты 41h 41h 41h уже в графические символы
и мы видим что мы получаем "AAAA" согласно ASCII кодировке которая ставит соотвествие 
байтов и графических символов. 
    $ echo -ne "\x0\x0\x0" | base64 -w0
    AAAA 
(по факту терминал работает в режиме UTF-8 но первые 127 симоволов что у ASCII что у
utf-8 совпадают. тоесть первые 127 граф символов ascii по своим байтам совпаадает как это 
есть у utf8)

также так как у нас 6бит кодируется в 8бит то конечное число бит должно быть кратно 
им обоим. и минимальное такое число это это 24бита тоесть это 3 байта.то есть  3 байта,
6 байтов, итд.
пример
    $ echo -ne "AAA" | base64 -w0
    QUFB
    $ echo -ne "AAAAAA" | base64 -w0
    QUFBQUFB
видно что размер коненого потока байтов по сравнению с имходным размером птока
увелчивается на 33%. тоесть было 3 байта стало 4 байта. было 6 байтов стало 8 байтов
тот же самый пример но на выходе я смотрю выходной поток не в виде печатных 
символов а в форме байтов
    $ echo -ne "AAA" | base64 -w0 | od -t x1
    0000000 51 55 46 42

    $ echo -ne "AAAAAA" | base64 -w0 | od -t x1
    0000000 51 55 46 42 51 55 46 42

окей. а что если исходный поток неделится нацело на группы по 6 бит.
например берем входной поток 2 байта. например
0000 0000 0000 0000 => 0000 00|00 0000| 0000 ??
как в этом случае работает перекодирование base64. а вот как
первые два полноценных куска по 6бит кодируются как положено  в "A" 41h
последний неполноценный кусок в котором всего 4 бита берется как есть тоесть
0000 
и конвертируется в число. в данном случае в байт "0" то есть 4 бита дополняется нулями до 6бит.
тоесть было 0000 стало 000000 и далее по таблицу эта 6битная группа конвертируется в символ "A"
но на этом история не заканчивается. base64 в конце потока байтов добавляет символ "=" 3dh
причем он добавляет несколько "=" с таким прицелом чтобы число байтов на выходе было кратное 4 байтам.
тоесть было 0000 0000 0000 0000 => 0000 00|00 0000| 0000 ?? => дополняем последнюю группу нулями до 6 бит =>  0000 00|00 0000| 0000 00 => коневертируем в печатные символы получаем => 41h 41h 41h или 
в форме печатных символов => "AAA" . видим что на выходе мы получили 3 байта и это число не кратно 
четырем байтам, тогда добавляем 1 символ "=" => получаем "AAA=" теперь мы получили 4 байта
и это число кратно 4 байтам.
показываю на примере
    $ echo -ne "\x0\x0" | base64 -w0 
    AAA=
    
    $ echo -ne "\x0\x0" | base64 -w0  | od -t x1
    0000000 41 41 41 3d

тут я хочу подчеркнуть что дополнение потока байтов на выходе символами "=" происходит 
только в том случае если исходный поток неделится кратно на 6бит. если же он делится то добавления
символа "=" не происходит. показываю на примере
    $ echo -ne "AAA" | base64 -w0 
    QUFB 
    $ echo -ne "AAAA" | base64 -w0 
    QUFBQQ==
тоесть в первом примере на входе мы имели поток из 3 байтов. 3 байта делятся на целом на группы из 6бит.
поэтому поток на выходе не дополняется кодировкой символом "="
второй пример имеет на входе 4 байта. это 32 бита. 32 бита на цело на 6бит неделится. 
это 5 полноценных групп и одна неполноценная , дополняем неполценнную нулями в битах до полноценной в 6 бит. получим после перекодивки 6 символов ( 6 байтов). так как у нас была неполноценная группа то 
значит смотрим на выходной поток и проверяем делится ли он нацело на 4 байта. 6 байтов неделится на цело на 4. поэтому мы дополняем выходной поток символами "=" столько раз чтобы он начал делится нацело на 4. 
получаем дополняем два раза. получаем 8 символов. 
показываю тоже самое 
    AAAA = 41h 41h 41h 41h 
преобразую 41h в base2 (бинарный) вид
    $ echo "obase=2;ibase=16;41" | bc
    1000001
получаем
    41h 41h 41h 41h = 0100 0001    0100 0001   0100 0001  0100 0001 =>
    => делим на группы по 6бит => 0100 00|01    0100| 0001   01|00 0001|  0100 00|01 ???? =>
    дополняем последнюю неполнценную группу 01 ???? нулями до 6 бит  01 0000 
причем возникает вопрос как неполноценную группу дополняем нулями слева или справа. ответ справа.
тоесть было 01 стало 01 0000
    => тогда полная группы будет выглядеть
    0100 00|01    0100| 0001   01|00 0001|  0100 00|01 0000  =>
    преобразуем в dec числа => 16 | 20 | 5 | 1 | 16 | 16 | 

теперь преобразуем кажду группу в 8битный байт согласно таблице (https://en.wikipedia.org/wiki/Base64#Radix-64_applications_not_compatible_with_Base64)
тут важно понять что мы полученные числа неконвертируем согласно классической ASCII таблицы нет.
мы конвертируем числа согласно таблице Base64 из вики. 
тогда
    16 = Q
    20 = U
    5  = F
    1 =  B
 
тогда получаем на выходе
    QUFBQQ
теперь получив символы мы можем согласно классической таблицы ASCII мы можем каждый символ
конвертиррвать в 8битный байт. тогда
    Q = 51h
    U = 55h
    F = 46h
    B = 42h

тогда выходной поток в форме байтов выглядит как 
    51h 55h 46h 42h 51h 51h
так как у нас была неполноценная группа из 6 бит входного потока то 
теперь мы должны выходной поток байтов проверить дедится ли число его байтов нацело на 4.
имеем 6 байтов. вывод неделится. значит дополняем 6 байтов до 8 байтов чтобы он делится на цело на 4 
через два символа "=" 3Dh
тогда суммарно выходной поток в форме символов выглядит вот так
     QUFBQQ==
или в форме байтов
    51h 55h 46h 42h 51h 51h 3Dh 3Dh
проверяем на практике
    $ echo -ne "AAAA" | base64 -w0 
    QUFBQQ==
    $ echo -ne "AAAA" | base64 -w0 | od -t x1
    0000000 51 55 46 42 51 51 3d 3d
видим что теория совпала с практикой.

итак  я детально разобрался как раобтает процесс работы команды base64
в частности выяснилось что если входной поток в виде битов неделится нацело на 6
то на выходе обязательно будут байт(ы) 3Dh или символ(ы) "="
так вот возврашаемся в /etc/shadow
    $ sudo cat /etc/shadow  | grep temp
    temp:$6$jwAMQACK$YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.:19441:0:99999:7:::
значит видим что 
алгоритм хещирования это sha-512
а хеш записан в виде 
    YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.
полагаем что хеш перекодирован во чтото типа base64
хотя это не может быть именно base64 потому что у него в его алфавите нет символа "."
у base64 словарь это "A-Z a-z 0-9 +/"
а тут в стринге мы видим "."
и видим что на  конце стринга нет символа "="
посчитаем какая длинна в байтах для этого стринга
    $echo -n "YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk." | awk '{print length}'
    86
видим что 86 байт. значит если эта хрень могла бы быть  base64 то в основании был бы поток из 86-и 6 битных групп. тогда 86*6=516 бит
но прикол в том что sha-512 выдает поток байтов длинной 512 бит. но никак не 516 бит. 
поэтому хеш закодирован в чемто другом а не в base64. сука.
если мы будем кодировать 512бит в классический base64 то так как 512 нацело неделится на 6битные группы
то значит обязательно на конце будет символ(ы) "=" а именно 512/6=85 полноценных групп и 1 одна
неполноценная группа. итого 86 групп. так как есть неполноценная группа то значит у нас на конце
будет один или несколько символов "=". проверяем 86 делится ли на 4 на цело. ответ нет. но 
делится 88 на 4. поэтому наши 86 символов будут дополнены двумя "=" до 88 символов.
показываю на примере

$ echo -n "1" | sha512sum | awk '{print $1}' | xxd -r -p | base64 -w0
Tf9Oo0DwqCPxXT9PAati6uDl2lecy4Ufjbnf6ExYsrN7iZA6dA4e4XLaeTpuedVg5ff5vQWKEqKAQz7W+kZRCg==

итак мы видим на конце как и было предсказано  "==" 
и общая длинна стринга 88 байтов
$ echo -n "1" | sha512sum | awk '{print $1}' | xxd -r -p | base64 -w0 | awk '{print length}'
88

таким макаром я доказал что вариант записи хеша в /etc/shadow это не классический base64
а чтото похожее. что конкретно за кодировка я щас буду искать далее


тут я отхожу немного в сторону. есть прога /bin/login из пакета login
эта та прога которая запущена когда мы видим приглашение для логина и пароля. она принимает
наш пароль и анализируе правильный он или нет. 
и у него в man login написано про один из его конф файлов
    /etc/login.defs Shadow password suite configuration.
так вот в этом файле есть строки 

$ cat /etc/login.defs
# If set to MD5 , MD5-based algorithm will be used for encrypting password
# If set to SHA256, SHA256-based algorithm will be used for encrypting password
# If set to SHA512, SHA512-based algorithm will be used for encrypting password
# If set to DES, DES-based algorithm will be used for encrypting password (default)
# Overrides the MD5_CRYPT_ENAB option
ENCRYPT_METHOD SHA512

# Define the number of SHA rounds.
# With a lot of rounds, it is more difficult to brute forcing the password.
# But note also that it more CPU resources will be needed to authenticate
# users.
#
# If not specified, the libc will choose the default number of rounds (5000).
# The values must be inside the 1000-999999999 range.
# If only one of the MIN or MAX values is set, then this value will be used.
# If MIN > MAX, the highest value will be used.
#
# SHA_CRYPT_MIN_ROUNDS 5000
# SHA_CRYPT_MAX_ROUNDS 5000


таким макаром в этом файле указано как ему проверяеть введенный пароль , как его трансфор
мировать в ту хрень с которой он будет сравнивать с тем что в /etc/shadow

тоесть что хешировать введенный пароль нужно в sha-512 и что это надо сделать 5000 раз.

возврашаемся к нащим баранам. man 3 crypt говорит то что 
 The characters in "salt" and "encrypted" are drawn from the set [a-zA-Z0-9./]
итак мы видим что искомая кодировка имеет словарь кодирования другой отличный от base64.
у base64 словарь [a-zA-Z0-9+/]
а искомая в shadow кодировка [a-zA-Z0-9./]
тоесть "+" был заменен на "."
далее я пошел на вики читать про base64.
и оказалось что это не один стандарт кодировки. это целое семейство кодировок.
я попробовал найти в  man base64 какая же версия кодировки поддерживает эта команда. 
но я не нашел. как я понял методом эмпирического тыка что линуксовская утилита base64
она написана на основе rfc4648 (section-4)
а именно. она требует наличия padding "=" если у нас исходный поток неделится нацело на группы по 6 бит
и что алфавит у нее вот такой 

 Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 +
        12 M            29 d            46 u            63 /
        13 N            30 e            47 v
        14 O            31 f            48 w         (pad) =
        15 P            32 g            49 x
        16 Q            33 h            50 y

тоесть [A-Z a-z 0-9 + /]

и далее в этой википедии  я нашел то что искал уже относиельно crypt(3) 
цитирую:
    Unix stores password hashes computed with crypt in the /etc/passwd file using an encoding called B64. crypt's alphabet puts the punctuation . and / before the alphanumeric characters. crypt uses the alphabet "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz". Padding is not used.

таким макаром я прихожу к выводам:
 - я так и не понял B64 это разновидность base64 или это чтото отдельное? но по факту я в интернете
   отдельно описание кодировки B64 ненашел по имени
 - теперь я могу по идее руками попробовать вычислить хеш от пароля руками то как это делает crypt(3)
   делать надо так: берем строчку из /etc/shadow, берем salt. берем пароль. соединяем вместе, 
   потом начинаем вычислять sha-512 пять тысяч раз. получаем 512 бит поток байтов.
   а потом кодируем этот поток в печатные символы с помощью разделения байтов на группы и 6 бит
   и переводим эти группы в символы алфавита 
            ./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz  
   при этом паддинг не используем.

         0 .            17 F            34 W            51 n
         1 /            18 G            35 X            52 o
         2 0            19 H            36 Y            53 p
         3 1            20 I            37 Z            54 q
         4 2            21 J            38 a            55 r
         5 3            22 K            39 b            56 s
         6 4            23 L            40 c            57 t
         7 5            24 M            41 d            58 u
         8 6            25 N            42 e            59 v
         9 7            26 O            43 f            60 w
        10 8            27 P            44 g            61 x
        11 9            28 Q            45 h            62 y
        12 A            29 R            46 i            63 z
        13 B            30 S            47 j
        14 C            31 T            48 k         (pad) нету
        15 D            32 U            49 l
        16 E            33 V            50 m

   
    
поехали берем строчку
юзер temp пароль temp
его строчка в shadow

temp:$6$jwAMQACK$YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.:19441:0:99999:7:::

мы имеем 
$6 = sha512
jwAMQACK = salt
хеш в формате B64 = YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.
YaBh = 36 38 13 45 

тут вылезла проблема в баш в переменной хер ты сохранишь бинарный поток байтов.
точнее в баш нельзя чтобы байты которые содержатся в переменной содержали байт 00h
показываю
    let a=$(echo -ne "\x31")
    $ echo -n $a | xxd -p
    31
итак переменная a хранит в себе байт 31h
тут проблемы нет.
а вот когда будет проблема
    $ let a=$(echo -ne "\x00")
    bash: warning: command substitution: ignored null byte in input
еще пример когда 00h находится где то всередине потока
    $ let a=$(echo -ne "\x31\x00\x41")
    bash: warning: command substitution: ignored null byte in input

это значит что когда мы будем сохранять хеш в форме байтового потока то у нас же там будут 
байты вида 00h и поэтому нас бащ пошлет нахер. поэтому наш хеш нужно хранить в баще 
не в байтовом виде а в виде hex ( base16). поэтому мне пришлось переделать скрипт вычисления
хеша тот который выше. мы вычисляем хеш получаем его в base16. и это хорошо.так мы его 
и сохраняем. а когда нужно вычислить новый хеш то преобразуем base16 --> bin
и от этого bin вычисляем хеш

$ cat 1.bash 
#!/bin/bash
			    # переменные
p="temp"       # password
n=10000        # число хешей
salt="jwAMQACK"


			    # тело скрипта
echo "пароль = $p"
echo "salt = $salt"
sp=$salt$p
echo "salt\пароль = $sp"
echo "макс число хешей = $n"
start=$(date +%s)  		# начало выполнения скрипта
echo "salt\пароль в hex = $(echo $sp | xxd -p)"

h1=$( echo -n "$sp" | xxd -p ) 	# конвертируем пароль в base16 (hex) формат
for i in $(seq 1 1 $n)
do
  h2=$( echo -n "$h1" | xxd -r -p | sha512sum | awk '{print $1}'  )
  h1=$h2
echo -ne "текущий хеш $i-ый  = $h2 \r"

c1=$( echo -n $h1 | cut -b 1-4 )
if [ "$c1" = "9263" ];then echo "gotcha!";break;fi

done
echo ""
end=$(date +%s)
echo "Время выполнения скрипта: $(($end-$start)) секунд"

еще одна проблема которая вылезла когда писался скрипт это то что
непонятно куда прибавляеть salt к паролю. толи до пароля то ли после пароля.
(как пишут в интернете append or prepend).
причем я нашел в инете противоречивые утверждения о том какой метод 
дает более надежный в плане брутфорса результат. одни пишут что если солт 
стоит до пароля то это более надежно. другие пишут что добавление солт в хвост пароля
это более надежно. 
в итоге  я попробовал и так и так. 5000-ый хеш не получается таким
как он есть в /etc/shadow
также я увеличил глубину до 10 000 но ни один хеш не отвечает нужному.
как я это проверял. я взял кусок хеша в формате B64 из /etc/shadow 
    YaBh
и рассчитал по нему как должен выглядеть хеш в формате base16 получил 
    92636d
но ни один расчетный хеш недает ни то что 92636d но даже недает 9263
в итоге я могу вот что сказать как работает схема в теории от ввода пароля с клавы и 
до записи в /etc/shadow
мы запускаем команду 
    $ passwd
вводим пароль с клавы.
далее вызывается сисколл crypt
он создает рандомный salt и присоединяется к паролю то ли сначала то ли к концу.
далее 5000 раз вычисляется sha-512 и далее эти 512 бит перекодируются в B64
которая является некоей разновидностью base64 и уже вся эта хрень записывается в /etc/shadow
в виде
    имя_юзера:$тип_хеша$salt(в UTF-8)$хеш(в виде B64):остальная хрень нам неважная щас

далее я нашел статью в которой все разбирается по частям отлично:
    https://www.vidarholen.net/contents/blog/?p=32
поехали
в ней приводится разбор как раобтает хещирование пароля через md5 при записи в /etc/shadow
значит в стьатье приводистя баш скрипт. который щас начнем разбирать


#########################
#!/bin/bash
# md5-crypt for GNU and Bash
# By Vidar 'koala_man' Holen

b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}

# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

# Turn stdin into a \xd4\x1d style md5 hash
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}

# Turn an integer into a crypt base64 string with n characters
intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")
        number=$(bc <<< "$number / 64")
        echo -n "${b64:digit:1}"
    done
}

base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}

# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}


doHash() { 
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes

    intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )

    for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done

    # Rearrange the bytes and crypt-base64 encode them
    encoded=$(base64EncodeBytes 22 "$intermediate" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

    printf "%s$salt\$%s\n" "$magic" "$encoded" 

}


if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2 
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 

doHash "$password" "$salt" '$1$'
##########################


начнем с куска 
#######
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}
########


здесь наворочано. разбор микрокусочков этого кода я делаю в "bash.txt"
а тут наверно буду чуть сокращенно.
вот эта хрень
    {#1}
вычисляет длинну переменной $1
поэтому цикл 
    for((i=0; i<${#1}; i++))
будет работать от 0 до длинны $1 минус один. 
оффсет у переменной у баша начинается слева с номера ноль и идет направо до длинны переменной
минус один.тоесть скажем
    $1="34"
значит длинна переменной 2. офссет 0 хранит 3 а оффсет 1 хранит 4
    printf '(%s)*256+%d' "$expression" "'${1:$i:1}"
принтф состоит из трех кусков. 
первый кусок '(%s)*256+%d' так назвываемый формат. это то что нужно напечатать
следущий кусок "$expression" это первая переменная которая будет подставлена в формат
следущий кусок "'${1:$i:1}" это вторая переменая которая убдет подсталена в формат

рассмотрим подробнее кусок с форматом '(%s)*256+%d'
вместо %s  будет поставлена первая переменная тоесть "$expression"
вместо %d будет подставлена вторая переменная "'${1:$i:1}"

также %s означает что переменная должны быть сконвертирована в string. тоесть другими словами
переменная будет подставлена так как она и есть. без изменений. 
пример 
    $ expression="(1+3)*5+6"
    $ printf "%s - самая лучшая строка \n" "$expression"
    (1+3)*5+6 - самая лучшая строка 

%d означает что переменная будет трансформирована в целое десятичное число со знаком.
пример
    $ vasya="-5"
    $ printf "%d  = число со знаком \n" "$vasya"
    -5  = число со знаком 

для контраста %u означает целое десятичное без знака
    $ vasya="-5"
    $ printf "%u  = целое без знака \n" "$vasya"
    18446744073709551611  = целое без знака 

откуда у нас взялось такое число читай о том как хранятся числа в баш
итак еще раз
    printf '(%s)*256+%d' "$expression" "'${1:$i:1}"
будет напечатано 
    (%s)*256+%d
где вместо %s будет подставлен "$expression" без изменений
а вместо %d будет подставлен "'${1:$i:1}" преобразованный в десятичное целое со знаком
далее что такое 
    '${1:$i:1}
апостроф в переменной в принтф означает что он берет первый символ стоящий после апострофа
находит для этого символ в таблице ASCII десятичное число и подставляет его в вместо переменной
пример
для символа "A" в таблице ASCII соотвествует десятичное число 65
    $ printf "%d \n" "'A"
    65 
поэтому это эквивалентно
    $ printf "%d \n" "65"
    65 
что интересно 
    $ printf "%d \n" "'AA"
    65 
тоесть берется только первый символ а все остальное посылается нахер
с апострофом разобрались, теперь что значит вот это
    ${1:$i:1}
это значит взять переменную $1, и вырезать из нее только определенные символы. а именно
начиная с символа с оффсетом $i (где i это наши индекс цикла for) в количестве 1 штука.
переменная $1 это первый аргументы указаный при вызове нашей функции 
stringToNumber
    пример
    $ a="123"
    $ echo ${a:0:1}
    1
    $ echo ${a:1:1}
    2
    $ echo ${a:2:1}
    3
    $ echo ${a:1:2}
    23

тоесть опять же сделано ебануто. было бы логично укаывать первый символ который брать и последний 
по их оффсету. скажем распечатай с первого по пятый. но нихуя. указывается оффсет первого символа
и количество символов которое надо суммарно напечатать после оффсета , включая символ в самом оффсете.
итак в нашем примере
оффсет это номер позиции символа
оффсет 0 хранит 1
оффсет 1 хранит 2
оффсет 2 хранит 3
да - оффсеты начинаются с нуля. и нумеруются слева в стринге. то есть самый левый символ имеет 
наименьший оффсет равный ноль
в первом примере мы говорим напечатай 1 символ начиная с офсета 0
в втором примере мы говорим напечатай 1 символ начиная с офсета 1
в втором примере мы говорим напечатай 1 символ начиная с офсета 2
в последнем примере мы говорим напечатай два символа начиная с оффсета 1
таким макаром суммарно вот эта хрень
    '${1:$i:1}
означает возьми переменную $i и вырежь из нее один символ в оффсете $i
а потом найди для этого символа код в таблице ASCII и подставь вместо переменной в виде десятичного
числа. пиздец
итак теперь расссмотрим как работает эта хуйня на примере
#######
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}
########

вызываем эту функцию с параметром "34"
    stringToNumber "34"
получаем
    expression=0
    ${#1} = 2
тогда 
    for((i=0; i<2; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
заходим в цикл
    $1="34"
    i=0
    "'${1:$i:1}" = "'${1:0:1}" = "'3" 
ascii код для "3" десятичный равен 51 значит 
    "'3" = "51" тоесть 
    "'${1:$i:1}" = "51"
        тогда 
    expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}") = 
      = $(printf '(%s)*256+%d' "0" "33") = "(0)*256+51"
тоесть 
    expression="(0)*256+51"

переходим к следущему шагу цикла
    i=1
    "'${1:$i:1}" = "'${1:1:1}" = "'4" = "34"
    expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}") = 
      = $(printf '(%s)*256+%d' "(0)*256+33" "34") = "((0)*256+51)*256+52"
тоесть 
    expression="((0)*256+33)*256+34"

итак на выходе из цикла мы будем иметь 
    expression="((0)*256+51)*256+52"

дальше эта хрень передается в bc
    bc <<< "$expression"
тоесть
    bc <<< "((0)*256+51)*256+52"
в итоге получим число


далее я изменил текст этой функции в stringToNumber1чтобы было наглядно видно
как она выполняется
и также написал другую функцию stringToNumber2 которая делает тоже самое но делает это по другому.
дело в том что видно что чем длиннее у нас аргумент $1 тем у нас на выходе
из цикла будет стринг расти все длинне и длинне. и только в самом конце он будет передан 
для расчета в bc. нахуй так делать. мы не отращиваем хвост. мы его считаем сразу


###################
$ cat md.bash 
#!/bin/bash

    echo -e '\nаргумент $1 =' "$1 \n"


stringToNumber1 () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
        echo  "i=$i"
        echo "expression=$expression"
        q=$(printf "%d" "'${1:$i:1}")
        echo "'"'${1:$i:1} ='  "'""\${1:$i:1} ="  "'${1:$i:1} = $q "
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
        echo "new_expression =" "printf ""'"'(%s)*256+%d'"'" ' "$expression"' '"'"'"'${1:$i:1}" =' "$expression = " "$(bc <<< $expression)"
        echo -e "---\n"
    done
}




stringToNumber2 () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
        echo  "i=$i"
        echo "expression=$expression"
        expression=$( printf '(%d)*256+%d \n' "$expression" "'${1:$i:1}" | bc )
        echo "new expression = $expression"
        echo -e "---\n"
    done
}

stringToNumber1 $1
stringToNumber2 $1
###############

$ ./md.bash 34

аргумент $1 = 34 

i=0
expression=0
'${1:$i:1} = '${1:0:1} = '3 = 51 
new_expression = printf '(%s)*256+%d'  "$expression" "'${1:$i:1}" = (0)*256+51 =  51
---

i=1
expression=(0)*256+51
'${1:$i:1} = '${1:1:1} = '4 = 52 
new_expression = printf '(%s)*256+%d'  "$expression" "'${1:$i:1}" = ((0)*256+51)*256+52 =  13108
---

i=0
expression=0
new expression = 51
---

i=1
expression=51
new expression = 13108
---

сравним то что я получил высчитвая руками выше чему равен expression при выходе
из цикла
    "((0)*256+51)*256+52"
с тем что показала программа на практкике
     ((0)*256+51)*256+52
тоесть все правильно

единственное что мне непонятно каков физический смысл этой хрени 
    ((0)*256+51)*256+52
очень похоже на формулу когда мы одну систему счисления переводим в другую тоесть.
скажем у нас есть бинарный вид
    0101
тоггда как мы пеереводим в десятичный. мы наичинаем справа налево. в таком виде
   (2^3)*0+(2^2)*1+(2^1)*0+(2^0)*1
в нашем случае мы имеем
   34
насколько я понимаю то система знаков берется типа вся таблица ASCII но почему то не 127 символов
а почемуто какието мифические 256 символов. берется что "3" это число 51 а "4" это число 52 тогда 
   (256^1)*51+(256^0)*52 
  в таком случае мы получим число
    $ echo "(256^1)*51+(256^0)*52" | bc
    13108
   что совпадает с ихней диковинной формулой 
    ((0)*256+51)*256+52 =  13108
поэтому физ смысл этой функции это то что беертся стринг $1="34"
и рассматривается что это число записанное в 256-ричной системе счислений ( в которой 256 знаков)
и вычисляется десятичное значение этого числа.
я вот така не понимаю в ASCII таблице из которой берутся десятичные значения для "3" и "4"
всего 127 символов. причем не все из них печатные. поэтому я не понимаю с чего этот чувак взял
что система счисления 256-ричная. 
и вторая претензия что за ебанутая формула расчета. горазо более проще высчитать вот так
кстати вот эта хуйня с апострофом
    'A
который преврашает символ в его ascii код она работает только в составе printf
и больше нигде. в echo такой вариант не прокатит

по поводу моей претензии что типа функция высчитвает в ебанутом стиле.
оказывается вот что. я написал функцию которая высчитвает тоже самое 
в более логичном стиле. тоесть когда унас есть число "34" которое  в кодах ascci
выглядит как 52,51
и мы высчитываем его в виде 
    51*(256^0) + 52*(256^1)
вот как выглядит эта функция
###############
stringToNumber3 () {
    expression=0
    for((i=${#1}-1; i>-1; i--))
    do
        expression=$( printf '%d + (256^%u)*%d \n' "$expression" "$(bc <<< ${#1}-1-$i)" "'${1:$i:1}" | bc )
    done
    echo "expression = $expression"
    echo "#############"

}
##########

вывод на экран
    expression = 13108

однако как можно заметить что выглядит она 
гораздо более уродливо
чем там что выше изложена. тем чуваком.
тоесть моя фуннкция высчитывает все более логичным образом но выглядит при этом
совершенно по уродски

вот чуть более красивая версия функции. 
это когда мы начинаем суммировать не с младщего бита а со старшего
##################
stringToNumber3 () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
       expression=$(printf '%d + (256^%u)*%d \n' "$expression" "$(bc <<< ${#1}-1-$i)" "'${1:$i:1}" | bc)
    done
    echo "expression = $expression"
    echo "#############"

}
##############
    
сравним с оригинальной функцией
#######
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}
########

моя функция с точки зрения визуальной простоты кода выглядит посложнее поуродскее 
погромоздскее но зато она охуенно более логичная по самому алгоритму расчета.

я заменил егоную реализацию функции этой на мою и запустил полный скрипт. 
по времени программа считает одинаково что с той функцией что  с моей

меня порадовала команда как сравнить два хеша
    $ diff <( printf '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/') <( printf '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/')
либо
    $ diff <(md5sum <<< '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/') <(md5sum <<< '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/')
 
что еще хочу добавить - по поводу цикла for у баша
а именно когда мы его хотим запустить в обратный отсчет.
прямой цикл
    $ for((i=0;i<5;i++)); do echo $i; done
    0
    1
    2
    3
    4
    $ for((i=5;i>0;i--)); do echo $i; done
    5
    4
    3
    2
    1
    $ for((i=5;i=0;i--)); do echo $i; done
тоесть когда я поставил i=0 то вообще ничего на выходе. пошел нахуй.
таким макаром я с функцией stringToNumber закончил 
##################
stringToNumber () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
       expression=$(printf '%d + (256^%u)*%d \n' "$expression" "$(bc <<< ${#1}-1-$i)" "'${1:$i:1}" | bc)
    done
    echo "expression = $expression"
    echo "#############"

}
##############
она делает то что берет посланный в нее параметр $1
рассматривает его как число записанное в 256-ричной системе счисления отталкиваясь от 
того что каждый символ закодирован десятиричным кодом из таблицы ASCII
и переводит 256-ричное число в 10-ичное число.

берем следующую функцию из оригинально скрипта
и смотрим что она делает
########
# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}
###########

рассмотрим для начала очередные приколы принтф
во первых прикол в том что есть встроенный в баш принтф
а есть внешняя команда /usr/bin/printf

как узнать что выполняется при запуске команды вот в таком виде
    $ printf "vasya"
внещняя команда или билтин баша?
стрейт показывает что запускается внешняя команда. 
это прикол
    $ strace printf "vasya"
    execve("/usr/bin/printf", ["printf", "vasya"], 0x7ffc0e3bf778 /* 70 vars */) = 0
тоже самое для команды echo. запускается именно внешняя команда
а как заставить баш запускать билтин? 
незнаю но например вот такт
    $ builtin printf "vasya"
я то думал пол дефолту бащ запускает билтины всегда. а если их нет то уже внешнюю
команду

значчит по printf спавку надо смотреть не через man bash
а через man printf

далее
значит фишка в том что внутри поля формат в принтф можно вбивать не только 
символы классические как например
    $ printf "vasya  \n " 
    vasya  
но и байты напрямую.
например можно указать байт в octal виде в форме \xxx
    $ printf "\41  \n " 
    !  
41 octal это 33 dec это 21р и это восклицетельный знак  в интепретации ascii
    $ printf "\41 \n" | od -t x1
    0000000 21 20 0a

ну тоесть вот мы и видим вначале 21h который восклицетальный знак. потом 20h котоый пробел и 0ah
который Enter.

также можно указать байт в виде hex  через \xHH
    $ printf "\x21 \n" 
    ! 
хочу подчеркнуть разницу с вот этим примером
    $ printf "%x \n" "33"
    21 
здесь мы тоже работаем с hex но по другому. во первых %x касается подстановки переменной
а не работа с константой как в прошлом примере.
во вторых в прошлом примере мы в поток суем байт 21h в прямом виде поэтому на экране мы 
видим "!" 
а в этом примере у нас десятичная 33 переводится в 21h и на экране выводится 21 
поэтому это совершенно разные вещи
еще пример про это
    $ printf "\x21 %x \n" "33"
    ! 21 

возвращаемся обратно к 
    $ printf "\x21 \n" 
    ! 
что если мы хотим на экране получить "\x21"
почемуто одинарное экранирование через палку неработает
    $ printf "\\x21 \n"
    ! 
хотя если заменить кавычки то работает !
    $ printf '\\x%x \n' "33"
    \x21 
пиздец
если кавычки двойные то работает только через двойное экранирование пиздец
    $ printf "\\\x21 \n"
    \x21 
а что если мы хотим 21 вставить через переменную?
    $ printf '\\x%u \n' "21"
    \x21 
    $ printf '\\x%x \n' "33"
    \x21 

тоесть вот эта конструкция "\\\x" или эта '\\x' служит для того чтобы обьяснить принтф что мы просто хотим
напечатать "\x" чтобы он нерассматривал эту хрень как признак hex числа.

теперь мы можем возвратться к функции
########
# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}
###########

получается эта хрень
    printf '\\x%x' "'${1:i:1}"

а точнее вот эта '\\x%x' означает то что мы говорим напечатай нам \x а далее за ним напечатай переменную
преобразовав ее в hex формат. 
напоминаю что сама переменная "'${1:i:1}" это хитрая хуйня потому что стоит апостроф. поэтому вначале переменная представляет собой символ который она берет из аргумента, скажем второй слева символ, а потом
для этого символа находится ascii код и значение переменной заменяется из символа на его ascii код 
в десятичном виде например
пусть 
    "${1:i:1}"="a"
ascii код для "a" равен 97 dec тогда
    "'a" = 97
тогда 
    printf '\\x%x' "'${1:i:1}" = printf '\\x%x' "97"
тогда на экране будет напечатано 
       \x 
а далее 97 согласно %x будет преобразован в hex тоесть 61 итого на экране
      \x61
это пиздец

суммарно на выходе эта фукция должна вот что делать. она берет аргумент 
    34
разбивает его на отдельые цифры
    3     4
потом для каждой цифры находит ascii код
и в итоге печатает ascii код на экране в hex виде
    \x3\x4
проверяем
запускаю функцию stringToHex ab
на экране
    \x61\x62
действиельно "a" имеет ascii код 61h
"b" имеет ascii код 62h
таким макаром эта функция вот что делает. она берет аргумент , берет каждый символ,
находит для него код в ascii таблице и печатает на экране в hex формате а именно \x21
таким образом мы видим аргумент не в форме печатных символов а форме ascii кодов в hex записи
еще пример
    $ ./md.bash  *ab!   
    аргумент $1 = *ab! 
    \x2a\x61\x62\x21
    
и действилеьно согласно ascii
    hex     symbol
    2a      *
    61      a
    62      b
    21      !

и действиельно байтовый поток так и выглядит
    $ echo -n '*ab!' |  od -t x1
    0000000 2a 61 62 21


рассмотрим следующую функцию в оригинальном скрипте
###############
# Turn stdin into a \xd4\x1d style md5 hash
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}
##########

во первых на счет "<<<" пока неразбирался откуда нога растет но
походу вот два эквивалента

    $ echo "a" | od -t x1
    0000000 61 0a

    $  od -t x1 <<< "a"
    0000000 61 0a

    
в целом назначение функции мне понятно. берется из stdin строка символов,
для нее вычисляется md5 хеш,
хещ выглядит на экране после команды md5sum выглядит вот так 
    67f66d5f0d8b38970f71afd43f83c623
и на заключительной стадии он заменятеся на 
    \x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23
чтобы было более понятно какой смысла имеют печатные символы
    
теперь более детально как функция работает.
как я понимаю она вызывается внутри скрипта както вот так

    echo "12 13" | md5hex

через пайп данные влетают в stdin функции (как это обеспечивается хер знает)
что значит stdin функции . как я понимаю это влетает в первую команду 
в теле функции

тело функции
###############
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}
##########

тоесть в stdin команды 
    sum=$(md5sum) 
значит команда md5sum по дефолту читает данные из stdin
поэтому по факту это влетает в нее. значит md5sum будет высчитывать хеш от "12 13"
результат будет запомнен в переменную $sum
далее некоторая проблема потому что типичный вывод от md5sum это 
    67f66d5f0d8b38970f71afd43f83c623  -
здесь мы видим полезный для нас хеш и бесполезный сраный минус на конце.
от него надо избавиться. 
делается это через 
    read sum rest <<< "$sum"
билтин read работает так. он берет стринг $sum находит  в нем пробелы. и то что до первого пробела
сует в переменнуую sum а то что между вторым и третьим пробелом сует в переменную rest
таким макаром у нас чистый эксрактированный хеш теперь лежит в переменной sum
на следущем этапе мы берем стринг. берем по два символа в переменной sum скажем это "12" и меняем на \x12
и так для всего стринга. таким макаром наш исходный стринг
    67f66d5f0d8b38970f71afd43f83c623
будет заменен на 
    $ sed 's/../\\x&/g' <<< 67f66d5f0d8b38970f71afd43f83c623
\x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23
и эта хрень  и будет то что даннная функция будет возврашать нам.
так значит как работает эта херня
    sed 's/../\\x&/g' <<< "$sum"
ну понятно что эквалентом этого является
    echo "$sum" | sed 's/../\\x&/g'
поэтому далее разбираемся с 
    sed 's/../\\x&/g'
значит эта хрень работает так
/.. = это паттерн поиска. он означает что берется два любых символа
\\x& = это паттерн замены того что мы нашли на нечто новое. состоит он из двух частей
\\x вот эта хрень означает напечатать "\x" просто так как в sed символ "\" играет роль экранирующего
то есть это служебный символ то нам для того чтобы напечатать его надо его самого на себя заэкранировать.
показюываю на примере правда для этого надо еще тогда пояснить что за символ "&" . это как бы спец переменная в ней содержится ровно все то что попало под шаблон поиска. тоесть
пример
    $ sed 's/./A&/' <<< "123"
    A123
это работает так. сед берет 123
\. - означает что под шаблон попадает первый любой символ один.
первый символ  у нас "1" он автоматом запоминается в спец переменную &
\A& - шаблон замены говорит о том что то что попало в шаблон поиска должно быть заменено на 
A плюс то что содержится в переменной & (тоесть 1) поэтому замена будет такая
        123 -> A123
что мы и видим. 
по дефолту сед находит первое вхождение в строке и делает замену и после этого успокивается
если же добавить ключ g то он будет искать все вхождение я строке поэтому 
    $ sed 's/./A&/g' <<< "123"
    A1A2A3
теперь когда разборались с флагом g и со спец переменной &
можно вернуться к "/".
предположим мы хотим заменить первый символ на символ &. так как это служебный символ у сед
то ему надо обьяснить что мы его в данном случае используем просто как печатный символ а не спец
символ для этого спец символ надо экранироовать тоест
    $ sed 's/./\&/' <<< "123"
    &23
тоесть /. ищет нам первый символ в строке
и он заменяется на символ & $ echo -e "ibase=16;\n 778D1B86BE195DAE8CB01688E81BE779"  | bc
158910803655924292489198456294474508153

знак \& обясняет седу что в данном случае & это не служебны символ.
так вот представим что мы теперь хотим заменить первый символ на символ "/"
так как он служебный то его тоже нужно экранировать. иначе пошлет нахер
    $ sed 's/./\\/' <<< "123"
    \23

теперь станвться понытным этот щаблон замены
\\x& ==> \\ означает что мы экранировали / и хотим его использовать как простой символ.
x это просто символ 
а & это спец символ означающий все то что было найдено  в шаблоне
поэтому суммарно эта херня работает так
        sed 's/../\\x&/g'
ищется два первых символа любых в строке. они запомниаются в сец переменную &
и далее эти два символа заменяются на \x + то что лежит в &
тоесть если у нас в строке
    1234
то в шаблон попадает "12" оно же запоминается в &
и этот "12" заменятся на "\x12"
так как стоит флаг g то после этого сед продолждает дальше поиск в строке и ищет следующие два 
символа и так до конца строки.
в итоге если на входе у нас есть хеш
    67f66d5f0d8b38970f71afd43f83c623
то он будет заменен на
    $ sed 's/../\\x&/g' <<< "67f66d5f0d8b38970f71afd43f83c623"
    \x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23

таким макаром разгадана третья функция исходного скрипта.



следущая функция
###################
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

# Turn an integer into a crypt base64 string with n characters

    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")  # остаток от деления
        number=$(bc <<< "$number / 64") # целое от деления
        echo -n "${b64:digit:1}"
    done
}
###################

функция работает так, ему скармиливется два числа например 123 и 8
тогда
    number=128
    n=8
далее запускается цикл 8 раз ( от 0 по 7)
каждый раз number делится нацело на 64 и переприсваивается сам себе. тоесть
    j=0 number=128/64=2, 
    j=1 number=2/64=0,
    j=2 number=0/64=0,
    j=3 number=0/64=0
итд
при этом также каждый раз находится остаток от деления numer на 64, тоесть
    j=0 остаток=0
    j=1 остаток=2
    j=2 остаток=0
    j=3 остаток=0
далее  в этом же цикле берется стринг 
    b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
и печатается символ с порядковым номером равным остатку.тоесть
    j=0 символ(0)=.
    j=1 символ(2)=0
    j=2 символ(0)=.
итак далее
тоесть в итоге будет
    .0......
возьмем еще один пример
    number=123 n=8
    значит цикл на 8 раз. 
    j=0 number=123/64=1  остаток=59 символ="v"
    j=1 number=1/64=0    остаток=1  символ="/"
    j=2 number=0/64=0    остаток=0  символ="."
    ...
    j=7 number=0/64=0    остаток=0  символ="."
итого на экране
    v/.....
проверка на практике
    $ ./md.bash 
    v/......


работа функции разгадана. что меня смущает в такой перекодировке или как 
пишут они в описании функции что это типа такой вид шифрования. фишка в том что 
в обратную сторону хрен расшифруешь поэтому по мне это скорее похоже на хеширование. но 
точно не шифрование.
поражает как красиво сделано перекодирование в b64
вот реальные аргументы которые передаются в эту функцию  в реальном скрипте
    322279607899402105297866753734997639596 22
тоесть первый аргумент эта хрень которую мы будем превращать в B64
22 это количество символов B64 которые мы получим на выходе
если мы запустим функцию с этим аргументами то мы на выхлопе получим
    g4kuC1.5wVcZ0Y5XnhARm1
что хочу отметить что алгоритм такой перекодировки совершенно отличается от классического
алгоритма base64
что мне еще непонятно. 
    исходное число оно в формате hex это 
    F274CB738C790296887C1C00CEEB01AC
оно имеет в длинну 32 символа. посольку каждый символ это полбайта.
то это значит что длинна этого числа 16 байтов. или 128 бит.
поскольку у нас b64 словарь это 64 символа. тоесть это 6 бит
то делим 128 на 6 получаем 21 полнценная группа из 6-и бит и еще 
в остатке остается 2 бесхозных бита.
итого это число если его перекодировать то оно будет занимать 22 символа.
как мы видим второй аргумент который программа сует в эту функцию это 22. 
и на выхлопе мы получаем дейтсивльно 22 символа. 
но что непонятно это то что если мы будем пользоваться клссчиеским алгоритмом пеереодирования 
в base64 пусть и с други словарем то мы получим первый символ совершенно не g
а нечто другое. показываю.
берем первый байт
    F2
конвертирум его в битовый вид
    $ echo  "obase=2; ibase=16; F2" | bc 
    11110010
берем от него группу из 6-и бит и конвертируем в десятичное число
    $ echo  "obase=10; ibase=2; 111100" | bc 
    60
теперь берем словарик 
    b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
и находим символ с 60-ым оффсетом получаем 
    w
но никак не 
    g
так что конкретно эта кодировка совершенно отличается от base64 алогритма нетолько словарем
но и самим алгоритом перекодирования сука.
единственное что можно скзаать что число 22 выбрано не случайно. что идет разбивка на 6-и битовые 
группы исходного числа. а потом так или иначе это 6битовое исходное число конвертируется в символ
из словаря.




рассмотрим следущую функцию
######################
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}
#######################
походу эта функция вот что делает. мы ей скармливаем в аргументе единичный
символ и она его ищет в переменной $b64
если находит то пишет офсет в $b64 иначе выдает ошибку

следущая функция
##############
# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}
############
как можно заметить тут приствтуует фигная по названием shift
это баш билтин. он делает вот что.
берем скрипт. и запускаем его с аргументами. $1 $2 $3 
если внутри скрипта запустить shift то он сдвинет все эти параметры на один влево.
тоесть $2 станет $1 $3 станет $2 ну а исходный $1 будет уничтожен.
пример
    $ cat 04.bash 
    #!/bin/bash
    echo $@
    shift 
    echo $@
    shift
    echo $@
    $ ./04.bash  1 2 3
    1 2 3
    2 3
    3

билтин shift имеет аргумент число по дефолту 1. поэтому он сдвигаем параметры на 1 влево.
если запутить как 
    shift 2
то он будет сдвигать на 2 параметра влево.

отойду немного в сторону, скажу как работает функция в баше. 
если в теле фенкции написано echo то будет ли это напечатано на экране зависит вот от чего.
пример

    f1() {
    echo "123"
    }

    f1 

если мы вот так вызываем функцию то эхо будет напечатано на экране. 
а если мы вот так вызовем функцию

    f1() {
    echo "123"
    }

    a=$(f1)
то на экране не будет напечатано нихера. весь stdout от работы функции будет 
записан внутрь переменной $a

далее супер хитррая хуйня. а именно строчка
    for i
типа что за хуйня? оказывается это есть такое сокращение от 
    for i in $@
охуеть. потому что иначе эта строчка сука не имеет никакого значения падла
теперь возврашаемся к нашей функции
##############
# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}
############

значит ее можно пеерписать в более понятный вид
##############
# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
}
############

значит теперь понятно как она рабоаеет. в нее послывается некий набор аргументов.
она запоминает первый $1 в переменную $num
далее через билтин баша shift первый аргумент $1 убивается. и все аргументы сдвинаются влево на один. 
тоесть $2 становится $1 , $3 становится $2 итд.
далее церез цикл мы проходим по всем аргументам и мы что делаем.
мы берем переменную $num и в ней вырезаем по 4 символа в заданных оффсетах. а номер оффсета
определяется как раз аргументами через которые идет итерация в цикле. 
и еще одна поразтеьная вещь
    $ i=4
    $ echo $((i*4))
    16
далее
показываю на примере как рабоает эта функция
######################
getBytes() { 
    num=$1
    echo "$@"
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
    echo ""
}


getBytes "\x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d"  1 4 3 2
################

аргумент  при вызове getBytes нужно взять в кавычки иначе там будет хуйня.
щас покажу на примере.
    smallF () {
        echo "$@"
    }

    smallF "\xa" "\xb"
вывод на экран
    \xa \xb
тоесть все коректно
теперь убираем кавычки
    smallF () {
        echo "$@"
    }

    smallF \xa \xb
вывод на экран
    xa xb
тоесть некореткно
теперь делаем двойные слеши
    smallF () {
        echo "$@"
    }

    smallF \\xa \\xb
вывод на экран
    \xa \xb
тоесть все коректно
тоесть суть такая что \ в bash используеся для экранирования спецсимволов обьясняя
башу что символ стоящий за слэшем ненужно рассматривать как спецсимвол
а нужно рассмтривать просто как простой печатный символ. когда мы не употреьляем
кавычки то баш будет искать  в аргментах спецсимволы. а если мы юзаем кавычки 
то тогда все что внутри кавычек рассмативается как простые печатые символы короме знака $
поэтому если мы хотим передать в функцию печатный знак слэша то нужно либо обрамлять аргумтенты
в кавыычки либо экранировать слеш таким же слешем.
вот еще аналогичный пример
    smallF () {
        echo "$@"
    }

    smallF ( (
вот такое вызовет ошибку. потому что вбаше символ ( явлется сппецсимволом.
поэтому его нужно либо взять в кавычки. либо экранировать слешем , в обобих случаях
это обьяснит башу что в данном случае скобка это не специсмвол а просто печатный симивол.
поэтому правиьные вариынтв такие
    smallF () {
        echo "$@"
    }

    smallF "(" "("
либо
    smallF () {
        echo "$@"
    }

    smallF \( \(
гениально
поэтому возвршаясь к нашей исходной функции
    getBytes "\x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d"  1 4 3 2
нам нужно взять перывй аргумент в кавычки так как слэши в аргументе неимеют смысла экранирорующего
символа. мы слэшем ничего не экранируем. мы его юзаем просто как печатный символ. поэтому либо
надо аргмент зключить в кавыячки что я и сделал либо если кавычки не использваоть то использовать
двойной слеш что конечно более уродливо будет выглядеть. но все же приведу для ясности
    getBytes \\x1b\\x16\\xae\\xbe\\x8d\\x86\\xe7\\x88\\x8c\\x19\\x1b\\x77\\x79\\xe8\\xb0\\x5d  1 4 3 2

    итак возврашаеся к нашей функции
######################
getBytes() { 
    num=$1
    echo "$@"
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
    echo ""
}


getBytes "\x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d"  1 4 3 2
################

еще один резонный вопрос с чего я взял что в исходный скрипт вызывает эту функицю с аналоичными 
параметрами. ответ  - я сделал дебаг исходного срприкта. вот с какми параметрами вызывается в
реальнрсти эта функция
    \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d 11 4 10 5 3 9 15 2 8 14 1 7 13 0

итак запускаем функцию 
на экране получим
    \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d 1 4 3 2
    \x16\x8d\xbe\xae
в верхнем ряду у нас изображены аргументы которые прилетели в функцию 
а внижнем ряду результат.
значит \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d  запоминается в $num
дальше берутся оставишиеся аргументы "1 4 3 2" каждый из них умножается на 4
и получившийся оффсет берется в $num и берется 4 символа и печатаются на экране.
дейтсиветельно берем 1 умножаем на 4 получем 4. в $num символ с оффсетом 4 это "\" и 
берем 4 символа включая "\" стоящие за "\" получем "\x16" и печатаем их на экране
    \x16
далее берем следущий аргмеент 4 умножаем на 4 получаем 16, берем символ имеющий 16 оффсет
в $num это "\", и беерем 4 символа идущие за \ включая \ это 
    \x8d
итак далее. в итоге на экране будет напечатано
    \x16\x8d\xbe\xae
итак суть этой функции это взять некий стринг. из него вырезать куски. и напечатать эти куски без 
преобразований.
так как  в функцию передается число в hex (base16) формате то эта функция по факту
выбирает отдельные заданные числа и печатает их.
тоесть еще раз в функцию влетает вот такое
    \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d 1 4 3 2
а вылетает из нее вот такое
    \x16\x8d\xbe\xae



рассмотрм следующую фугкцию
#############

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}
############

отойду в сторону. если у нас есть функции в скрипте. то самый простой способ их дебажить
это делать echo внутри функии и направлять ее вывод в файл на диске. 
я сделал дебаг этой функции в реальном скрипте вот что внее прилетает в реальности как аргументы
    \x77\x8d\x1b\x86\xbe\x19\x5d\xae\x8c\xb0\x16\x88\xe8\x1b\xe7\x79
тоесть стринг в hex формате
значит вот эта хрень она заменяет буквы на их заглавные версии
    $ tr a-f A-F <<< "\x77\x8d\x1b\x86\xbe\x19\x5d\xae\x8c\xb0\x16\x88\xe8\x1b\xe7\x79"
    \x77\x8D\x1B\x86\xBE\x19\x5D\xAE\x8C\xB0\x16\x88\xE8\x1B\xE7\x79
а вот эта хрень она убирает из стринга "\x"
    $ sed -e 's/\\x//g' <<< "\x77\x8D\x1B\x86\xBE\x19\x5D\xAE\x8C\xB0\x16\x88\xE8\x1B\xE7\x79"
    778D1B86BE195DAE8CB01688E81BE779
нахер это надо. а это надо чтобы подсунуть эту херню в bc потому что он формат hex понимает 
только в виде
    778D1B86BE195DAE8CB01688E81BE779
таким образом команда 
    echo 'ibase=16;'
высирает на stdout строку 
    ibase=16;
причем вконце добавляет знак переноса строки
остальные команды высирают 
    778D1B86BE195DAE8CB01688E81BE779
тоесть суммарный высер в stdout выглдяит так
    ibase=16;
    778D1B86BE195DAE8CB01688E81BE779
и далее этот stdout перенаправляется в bc
далее насколько я понимаю в bc по дефолту obase=10 тоесть он по умолчанию 
число преобразует в dec формат поэтому это не указано. в итоге функция в конце делает 
вот такой эквивалент
    $ echo -e "ibase=16;\n 778D1B86BE195DAE8CB01688E81BE779"  | bc
    158910803655924292489198456294474508153
самое смешное это где находится знак переноса строки. и bc это устраивает. это реальный прикол.
итого физ смысл этой функции состоит в том что на входе ей скармиливается стринг в формате hex
мы его преобразуем в формат hex который понимает bc и оне это число траснформирует в dec формат
фнукция называется hexToInt  , я считаю что более правлно было бы ее назвать hexToDecInt
кстати и козлу понятно что число это целое. 

    
рассмотрим соедующую функцию
###################
base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}
##################

в эту функцию в реальном скрипте прилетает строка аргументов вот такая

22 \xeb\x1c\x96\x8c\x74\x73\x01\x00\x88\x79\xcb\xf2\xac\xce\x7c\x02 11 4 10 5 3 9 15 2 8 14 1 7 13 0 6 12

значит разбираем как она работает
вот эта хрень "22" улетает  в переменную $n
далее аргументы сдвигаются и строка аргументов теперь выглядит как

\xeb\x1c\x96\x8c\x74\x73\x01\x00\x88\x79\xcb\xf2\xac\xce\x7c\x02 11 4 10 5 3 9 15 2 8 14 1 7 13 0 6 12
далее берется эта строка аргументов и суется в функция getBytes.
этот getBytes согласно тому что я про нее разобрал выше. всего навсего берет и из первого аргумента
вырезает hex числа те который указаны по счету в остальных аргументах. причем числа немеруются с нуля
а не единицы. тоесть "\xeb" это число номер ноль. а не число номер 1. "\x1c\" это число номер 1.
и так далее.тоесть в данном случае
из первого аргмуента будут вырезаны 11,4,10,5 итд числа. еще раз почеркну что 11 это не номер символа
(офсета) в первом аргументе а номер всего hex числа(причем hex числа нумеруются с нуля а не единицы).
тоесть если указано 11 значит начало этого числа
его оффсет это 11*4. оффсет тоже нумеруется с нуля.
длинна числа это 4 байта. поэтому 11-е число это "\xf2". итого getBytes
возвратит
    \xf2\x74\xcb...
и так далее. 
вот что показывает выполнение реально программы что возвратит getBytes
    \xf2\x74\xcb\x73\x8c\x79\x02\x96\x88\x7c\x1c\x00\xce\xeb\x01\xac
дальше эта хрень кидается на функцию hexToInt. как описано выше 
она превращает аргумент вот в такой вид
    F274CB738C790296887C1C00CEEB01AC
и потом бросает его в bc и в конечном итоге возваращает его в dec виде тоесть
    322279607899402105297866753734997639596
дальеш запускается функция intToBase64 вот в такое виде
    intToBase64 322279607899402105297866753734997639596 22
где 22 это хрень которая у нас хранилась в $n
в описании к intToBase64 я расписал что она делает. она берет исходное десятичное число
и конвертирует его в наборр символов согласно словаря. это некая изврашеннаая форма кодировки base64.
но конечно по какотому совершенно другому алгоритму.
    g4kuC1.5wVcZ0Y5XnhARm1
таким образом суммарно что делает вся эта функция:
    в нее поступает число в hex формате в размере 16 hex чисел. и далее указан порядок на основе
    которого их нужно переставить. эти 16 чисел  переставляются местами. и потом это новое 
    16 байтовое число конвертирется в изврашенной форме в некое подобие кодировки base64
    из которой получается 22 печатных символа
    эти 22 печатных символа и есть резултат на выходе из функции
        g4kuC1.5wVcZ0Y5XnhARm1   <== 22 символа печатных


далее рассмотрим вот такую хрень

#########
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes
################
во первых в чем разница между высчитыванием длинны стринга через 
    wc -c
и
    awk '{print length}'
значит wc -c он суммирует и байт '\n' отвечающий за enter
а awk его не учитывает.
показываю на примере
    $ printf "vasya\n" | wc -c
    6
    $ printf "vasya\n" | awk '{print length}'
    5
как говорится почувствууй разницу

далее разбираем строку 
    [[ -z $magic ]] && magic='$1$'

-z string =   True if the length of string is zero.

поэтому данная хрень возвращает true если переменная не была определена.
тоесть вся строка целиком говорит о том что если перееная была не определена 
то мы ее задаем

глядя на $1 подумал про аргументы скриптов. и узнал вот такую хуйню непоняьную
пример
    $ cat 10.bash 
    #!/bin/bash

    a="$3"
    echo "a=$a"

    b=$10
    echo "b=$b"

    c="$10"
    echo "c=$c"

    d="${10}"
    echo "d=$d"

    $./10.bash 1 2 3 4 5 6 7 8 f aaa
    a=3
    b=10
    c=10
    d=aaa

из примера видно вот что. если мы указваем аргумент вызоыва скрипта состоящий из одной цифры
в данном случае $3 то его значение "3" абсолютно верно засасывается в переменную.
а если у нас имя аргумента вызова скрипта из двух цифр то обе записи
    b=$10
    c="$10"
засасывают значение $10 совершенно неправильно. почему незнаю. пиздец какойто.
единственно раблтающий вариант это 
    d="${10}"
тоесть это совершенно не похоже как это есть с обычными переменными. тоесть у нас же нет проблем
вот с такой переменной
    $ ddd=4
    $ echo $ddd
    4
    $ echo ${ddd}
    4
и так и так работает.
ксатти ответ на вопорс сколько аргуметов можно в баше послать в скрипт. 
вроде вот столько
    $ getconf ARG_MAX
    2097152

еще один прикол покажу. скажем мы хотим задаваь имя переменной не в форме константы а через другую
переменную. например 
    $ b=1
    $ a=b
    $ echo переменную имя которой хранится в переменной a
так вот это делаетяс вот так
    $ a=1
    $ b=a
    $ echo ${!b}
    1
офигеть
возвращаемся обратно к нашему куску кода
#########
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes
################
а именно
    magic="$3"
    [[ -z $magic ]] && magic='$1$'
возникает вопрос если переменная не задана в нашем случае $3 то какое значение
примет magic. ответ это стринг нулевой длинны
    $ echo -n $dfg | od -t x1
    0000000
вот видно что на выходе ноль байт. 
поэтому 
    [[ -z $magic ]] 
выдаст true
тоесть если $3 незадана то
    magic="$3"
анаолгичен
    magic=""
потому что 
    $ magic=""
    $ echo -n $magic | od -t x1
    0000000

разбираем эту хуйню
    salt=${salt#'$1$'}
как я понимаю как эта хрень работает
она работает так. она говорит, возьми $salt и отрежь от начала этого стринга то что указано 
после # по шаблону. шаблон в данном случае '$1$'
возьмем пока более простой однозначный шаблон
    $ b="aBaC"
    $ echo ${b#a}
    BaC
    $ echo ${b#'a'}
    BaC
    $ echo ${b#"a"}
    BaC
отсюда понятно что шаблоны
    a
    'a'
    "a"
это одно и тоже а кавычки это просто служебные символы
двигаем дальше
    $ b='$a45'
    $ echo $b
        $a45

    $ a='123'
хотим вырезать $ из $b. пробуем подставить просто $ после #
хотя по идее $ это служебный символ и баш нас должен послать нахер
однако почеуто баш непосылает и реально у нас успешно вырезается доллар
    $ echo ${b#$}
        a45

теперь хотим вырезать '$a' из переменной $b. просто добавляем a после $
однако тут облом. баш воспринимает наш шаблон не как набор литер $+a а как то что у нас в шаблоне
указано имя переменной $a значение из которой и надо удалить из $b
поскольку переменная a=123 то из $b нихрена не удаляется
    $ echo ${b#$a}
        $a45
заменяем значение переменной a
    $ a='$a4'
еще раз пробуем удалить из b то что сохранено в a
и успех
    $ echo ${b#$a}
        5
вывод. чтобы быть точно уверенным что спецсимволы в шаблоне не будут тракотованы как спецмиволы
лучше предохраниться и указать спецсимволы в ''
тоесть вместо такого
    $ echo ${b#$}
    a45
лучше вот так
здесь четко видно что доллар у нас просто литера в шаблоне
    $  echo ${b#'$'}
    a45
итак еще раз что значит такая запись. она занчит что мы просим баш вырезать из переменной b 
с ее начала смиволы которые указаны в шаблоне. шаблон указывается после символа #
шаблон должен точно совпадать с символами вначале стринга. если шаблон совпадает где то 
только посреедине нихера вырезано неудет. пример
    $ a='a123b'
    $ echo ${a#123}
    a123b
    $ echo ${a#a123}
    b
в шаблоне можно юзать спецсимволы
    * - любой количество символов
    ? - один любой символ
еше пример
    $ echo ${a#*2}
    3b
    $ echo ${a#??}
    23b
есть еще одна штука вот так выглядит ${VAR##pattern}
    $ a='aaaa СЫР bbbbb СЫР сссс'
    $ echo ${a#*СЫР}
    bbbbb СЫР сссс
    $ echo ${a##*СЫР}
    сссс
    
значит в чем прикол у нас шаблон
    *СЫР
который означает "любое количество символов+СЫР"
когда мы ссмотрим на стринг 
    aaaa СЫР bbbbb СЫР сссс
то у нас этому шаблону удовлетворяет два варианта
    aaaa СЫР
    aaaa СЫР bbbbb СЫР
и какой из них брать?
так вот хрень ${VAR#pattern} она вырезает меньший по размеру кусок
а хрень ${VAR##pattern} вырезает максимально большой возможный
поэтому на экране видим то что получили

далее еще прикол. если ${VAR#pattern}\${VAR##pattern} вырезают с начала стринга
то ${VAR%pattern}\${VAR%%pattern} вырезают с конца стринга
    $ a='aaaa СЫР bbbbb СЫР сссс'
    $ echo ${a%СЫР*}
    aaaa СЫР bbbbb
    $ echo ${a%%СЫР*}
    aaaa

возвращаемся к нашему примеру
    salt=${salt#'$1$'}
значит тперь понятно что он делает. из переменной salt мы хотим вырезать 
литеры $1$
покажу на примере
    $ salt='$1$abcd'
    $ echo ${salt#'$1$'}
    abcd

двигаем дальге. теперь вот эту херню рассмотрим
    salt=${salt:0:32} # 8 first bytes
понятно что она вычленяет из переменной первые 32 символа.
возникает только вопрос а что будет если длинна salt меньше чем 32 символа
как видно из эксперимента если длинна переменной меньше чем 32 символа 
то будет напечатано то число символов сколко есть. если есть 10 символов будет 10 символов
    $ a="123456789|123456789|123456789|123456789|"
    $ echo ${a:0:32}
    123456789|123456789|123456789|12
    $ b="123456789|"
    $ echo -n ${b:0:32}
    123456789|
    $ echo -n ${b:0:32} | od -t x1
    0000000 31 32 33 34 35 36 37 38 39 7c
таким макаром весь вот этот кусок
#########
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes
################
разобран

теперь переходим к разбору куска
###################
intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )
##########

рассматриваем рой хуйни
во первых двойные скобки возвращают всего навсего 0 или 1 
тоесть это оператор логический. если внутри скобок 0 то код возврата $?=False тоесть 1.
если внутри скобок неноль то код возврата True тоесть  0
вот такая запутанная хуйня
пример
    $ (( 0 )); echo $?
    1
    $ (( 1 )); echo $?
    0
    $ (( 100 )); echo $?
    0
    $ (( 5>4 )); echo $?
    0
    $ (( 5<4 )); echo $?
    1
но это только начало пиздеца
если мы хотим узнать что внутри скобок то надо делать тгда вот так
    $ echo $(( 5 ))
    5
    $ echo $(( 5+3 ))
    8
и это совсем другая хуйня к логическим операторам неимеющая никакого отношения.
теперь переходим к операциями над числами на битовом уровне.
как нам подвинуть в числе все биты на 1 направо. а вот так
    $ echo $(( 5>>1 ))
    2
действтиельно 5=101, двигаем на один бит вправо получем 010 а это 2
далее положим мы хотим подвинуть биты у переменной а не у константы
команда выглядит также
    $ let a=5
    $ echo $a
    5
    $ echo $(( a >> 1 ))
    2
или есть еще один вид синтаксиса
    $ echo $(( a >>= 1 ))
    2
а далее небольшой пиздец. команда ">>=" работает только для сдвига в переменной.
а вот для сдвига в константе уже пошел нахуй
    $ echo $(( 5 >>= 1 ))
    bash: 5 >>= 1 : attempted assignment to non-variable (error token is ">>= 1 ")
таким образом чтобы незапоминать эту хуйню я предлагаю и для переменных 
и для констант использовать всегда то что работает для них обоих тоесть ">>" и не ебать мозги
    $ echo $(( 4 >> 1 ))
    2
    $ b=4
    $ echo $(( b >> 1 ))
    2

таким образом я перехожу к строчке
    for ((i=$passwordLength; i != 0; i>>=1)) 
по русски это команда значит запустить цикл от $passwordLength до 0 (ноль не включается) с шагом
таким что каждое следующее число получается из предыдущего путем сдвига i на 1 бит вправо. пример 
пример
$ for(( i=64; i !=0; i>>=1 )); do echo $i; done 
64
32
16
8
4
2
1

самое странное что если  я заменю 
    i>>=1
на
    i>>1
то получится какая херня. цикл будет работать бесконечно. тоесть бит почемуто не сдвигается.
ебанизм.

теперь понятно почему двойные скобки (( )) употребялюся в for
потому что для головы for всего навсего надо знать true или false. а (( )) как раз сообщают 
ему именно это. тоесть внутри (( )) производится арифметический расчет. наружу выдается true или false
потому что для for похер что там внутри конкртено получилось. если true то он выполняет то что 
пропсано в do.  а если false то цикл заканчиватеся. 

теперь расматриваю такой код
    $ (( 0 & 1 )); echo $?
    1
    $ (( 1 & 1 )); echo $?
    0
    $ (( 2 & 1 )); echo $?
    1
    $ (( 3 & 1 )); echo $?
    0
    $ (( 4 & 1 )); echo $?
    1
    $ (( 5 & 1 )); echo $?
    0
как эта хрень работает. знак & означает битовый AND. по англицки bitwise AND.
при битовом AND берется два с одинаковым офсетом бита в двух числах и сравниваются. 
если оба равны 1 то в суммарном числе этот бит тоже 1 иначе 0
к чему это приводит. вот у нас второе число всегда 1 . запишу его в двойчном виде
   0000 0001
поскольку у него биты с 7-го по 1-ый равны нулю то какое бы ни было первое число у суммарного
числа эти биты всегда будут тоже 0. поскольку нулевой бит равен 1 то если у первого числа 
этот бит равен 1 то и суммарное число будет тогда иметь этот бит 1. а если у первого числа этот бит 0 
то и у суммарного числа этот бит 0. теперь вот что поймем - если у нас есть произвольное число и у него
нулевой бит равен 1 это о чем нам говорит. о том что это число 100% нечетное. а если оно у него ноль
то это 100% четное число. тогда мы получаем вот такую диаграмму
     первое число нечетеное & 1  = 0000 0001 = 1 dec
     первое число четное    & 1  = 0000 0000 = 0 dec
подставляем эту хрень в двойные скобки
    (( неч & 1 )) = (( 1 ))
    (( чет & 1 )) = (( 0 )) 
во втором случае так как у нас внутри 0 то результат FALSE это значит код возврата $?=1
в  первом случае так как у нас внутри неноль то результат TRUE значит код возврата $?=0
итого суммарная таблица
    $ (( неч & 1 )); echo $?
    1
    $ (( чет & 1 )); echo $?
    0
таким макаром эта хрень может использоваться для определения число у нас
четное или нечетное


теперь рассматриваю такой код
    for(( i=170; i !=0; i>>=1 )) 
    do 
        echo "i=$i" 
        (( i & 1 )) 
        echo $?
    done 

или в однострочном виде
    $ for(( i=170; i !=0; i>>=1 )); do echo "i=$i"; (( i & 1 )); echo $?; done 
    i=170
    1
    i=85
    0
    i=42
    1
    i=21
    0
    i=10
    1
    i=5
    0
    i=2
    1
    i=1
    0
значит сам индекс цикла i это число которое проходит от 170 и до 0 с шагом таким что 
каждое следущее получается из преддыдущего путем битового смещения на 1 вправо.
при этом для каждого i проводится тест четное число или нечетеное.
пиздец.таже рассмотрим число 170 в двоичном виде
    10101010
очевидно что количество сдвигов пока мы достигнем нуля будет равно тому количеству сдвигов
чтобы самый старший бит числа дошел до нулевого оффсета.
показываю
    0(номер сдвига)   10101010 <== исходное число
    1                 01010101 
    2                 00101010
    3                 00010101
    4                 00001010
    5                 00000101
    6                 00000010
    7                 00000001
    8                 00000000
в данном случае мы имеем 7 сдвигов от начального числа до единицы.
самый старший бит у нас имеет оффсет 7.
получается чтобы данное число превратить  в единицу нужно ровно столько сдвигов сколько 
номер оффсета у старшего установленного бита этого числа.

пример 
$ for(( i=224; i !=0; i>>=1 )); do echo -n "i=$i  "; echo "битовый вид = $(echo "obase=2; $i" | bc)"; done 
i=224  битовый вид = 11100000
i=112  битовый вид = 1110000
i=56   битовый вид = 111000
i=28   битовый вид = 11100
i=14   битовый вид = 1110
i=7    битовый вид = 111
i=3    битовый вид = 11
i=1    битовый вид = 1

самый старший бит у 224 имеет оффсет 7
мы видим что чтобы 224 превратить в 1 нужно 7 передвижений.
    
поскольку у нас в исходном условии
    for(( i=224; i !=0; i>>=1 ))
указано что мы идем от нашего исходного числа до нуля но ноль запрещен
то суммарное количество циклов будет 7+1

теперт после всех этих мытарств рассмотрим этот кусок из реального скрипта
##################
        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done
##############
теперь наконец стало понятно то что написано в его описании
        For every 1 bit in the key length, add a 0.
        Otherwise add the first char of the key.
что он делает. он берет переменную равную длинне пароля. это какое число 
скажем 5. длинна пароля 5 символов.
это число присваивается переменной i.
внутри цикла происходит тест на то что если i это нечетное число. 
если число нечетное то это значит что у него установлен бит в оффсет 0.
так вот если оно нечетное то печатается байт '\x00' 
а если число четное тоесть если бит в оффсете 0 равен 0 то печатается первый байт из пароля.
на следующем этапе цикла число i сдвигается на 1 бит вправо. таким образом двигая биты числа i
вправо через цикл мы перебираем все биты исходного числа i и понимаем установлены ли они или нет.
в зависимости от того установлен ли бит или нет мы печатаем на экране либо '\x00' либо первый байт
из пароля. все тело цикла подчинено исходной задаче которая очевидно состоит в том что 
надо взять число равное длинне пароля.  преобразовать его в битовый вид. и на основе этого 
напечатать на экране последовательность байтов. если соответвущий бит установлен то печатаем один байт.
если бит не установлен то другой байт. и так для всего этого числа.
по факту мы этой программой проверяем выставлен ли у числа i его младший бит. 
потом двигаем биты направо и опять проверяем выставлен ли младший бит.
таким макаром мы пробегаем байт от оффсета 0 до макс оффсета.
вот точно такая  программа.
если в оффсете 0 быт равен ноль то я печатаю на экране ноль.
а если не ноль то печатаю единицу.
$ for(( i=1; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
1
$ for(( i=2; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
01
$ for(( i=4; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
001
$ for(( i=128; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
00000001

таким образом мы без программы bc получаем на экране двоичное представление числа.
единственное что оно выглядит непривычно потому что мы пробегаем биты у числа с младшего бита
к старшему. поэтому на экране первыми печатаются младщие биты а последними старшие. 
и экране терминал так устроен что у него символы с младшим оффсетом (те которые были напечатаны по времени
более первыми) находятся слева. а символы которые он печатает более поздно по времени находятся справа.
поэтому результат на экране логичен. просто дело в том что при записи битового вида числа на бумаге
мы используем написание по правилу BigEndian. Мы пишем слева направо но первым пишем самый старший 
бит в байте. а когда у нас работает цикл то он начинает печатать на экране начиная с самого младщего 
бита на экране. поэтому на экране мы получили зеркальное отражение того как это должно 
быть когда мы пишем на бумаге. поэтому надо еще зеркально отразить.
и тогда
$ for(( i=128; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done | rev; echo "" 
10000000
$ for(( i=15; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done | rev; echo "" 
1111
$ for(( i=192; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done | rev; echo "" 
11000000

можно еще вот так подкрасить вид чтобы было более легко и логично смотреть
$ ( for(( i=192; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done ) | rev; echo "" 
11000000

таким образом вот этот кусок теперь понятен
##################
        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done
##############
интересно что в этом  куске обработка битов в i начинается с младшего бита.
и не совсем понятно так и было задано в изначальной задаче? ведь можно было начать обрабатывать
биты со старшего бита. и тогда последовательно символов которые печатаются будет зеркально выглядеть.

теперь надо еще вот такой кусок разобрать
#################
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"
################
переделвыаю цикл в аналогичный и в однострочный вид
    $ while printf "vasya" 2> /dev/null; do true; done | head -c "1"

значит что делает цикл while. он печатает на экране слово 'vasya' причем бесконечно и непрерывно.
тоесть на экране будет
    vasyavasyavaysvaya...
и так до бесконечности
тоесть еще раз цикл печатает слово, потом еще раз его печатает  и так до бесконечности
далее
    head -c "1"
хед берет первый байт этого потока и печатает

и тут мы получаем очень интересное явление. что если запустим только цикл то цикл бесконечно
будет выполняться и будет бесконечно печатать на экране 'vasya'
но как только мы к нему добавим '|head -c "1"' то код целиком выполнится мгновенно. мы увидим на экране
всего один символ 'v' и дальнейшее исполнение кода прекратится.
возникает два вопроса:
    зачем на цикл
    почему при добавлении '|head -c "1"' цикл прерывается а не работает до бесконечности
на счет первого вопроса - почему вместо цикла не вставить вот такое более простое выражение
    $ printf "vasya" 2> /dev/null | head -c "1"
ведь мы получим тоже самое. оказывается как я подумал дело в том что если слово 'vasya' короткое
а в head стоит большое число например 'head -c "20"' то у нас просто тогда нехватит длинны слова 'vasya'
а если у нас цикл то у нас "-c X" может быть каким угодно большим . показываю на примере
    $ printf "|vasya|" 2> /dev/null head -c "30"
    |vasya|[vasya|
    $ while printf "|vasya|" 2> /dev/null; do true; done | head -c "30"
    |vasya||vasya||vasya||vasya||v
вот зачем нужен именно цикл!

второй вопрос тоже очень интересный. еще раз посмотрим на что похож вывод на экран у цикла
    $ while printf "vasya" 2> /dev/null; do true; done | head -c "2000"
    vasyavasyavasyavasyavasyavasya
    vasyavasyavasyavasyavasyavasya
    vasyavasyavasyavasyavasyavasya
    vasyavasyavasyavasyavasyavasya
    ...
он похож на чтение из текстового файла. очень большого текстового файла. пофакту бесконечно 
большого текстового файла.
тогда наш код вобщем то похож на другой код
    $ cat 1.txt | head -c 1
далее можно вспомнить что при чтении очень большого файла и при выполении данного кода
нам не приходится долго ждать. тоесть нам не приходится ждать когда "cat" полностью прочитает
файл чтобы только потом передать его на head. результат получается мгновенно. 
я об этом вопросе незадумывался. интуитивно казалось что должно работать так. вначале cat полностью
читает первый файл. и только потом он его начинает передавать в stdout. и так как обычно читаются
небольшие файлй то поэтому и не приходится долго ждать. очевидно я был неправ. тут надо вспомнить
из C или наверное и питона как организовывается чтение файла. поскольку я это делал через программирование
пару раз то поэтому я и забыл и думал неправильно. а чтение работает так - мы открываем файл на чтение.
и мы задаем чтение определенными кусками мы читаем кусок. чтото с ним делаем. потом читаем следуший кусок.
поэтому очевидно что cat читает из огромгого файла кусочками. прочита первый кусочек  я думаю это максимум
сколько то килобайт он его высирает в stdout. тут же отрабатывает head и поэтому мы видим результат
мгновенно. чтото похожее имеет место и для while+printf+head. тоесть во первых у нас будет три процесса.
один процесс это баш в котором крутится while , второй процесс это printf, третий процесс это head.
значит баш процесс запускает while. который в свою очередь запускает процесс с printf. тот высирает
на stdout "vasya" и вобщем то тут же этот процесс и подыхает. при этом процесс с head тоже уже запущен 
и его через сисколл соотвествующий ждет от ОС сигнала что на его stdin чтото уже поступило. вобщем пускай
даже while отработает какое то количество раз прежде чем сработает шедулер. шедулер точно сработает
очень быстро. он увидит что для head есть входящая информация в буфере на его stdin и поэтому шедулер
останвоит баш и запустит head. head отработает и высрет нам результат и закончит тут же свой процесс.
поэтому нам не придетя ждать бесконечность чтобы отработал head. тут я разобрался с вопросом почему
head отрабатыает быстро если у нас цикл бесконечный. ... прикол... 
остается еще один вопрос если у нас есть скажем две команды в пайпе
    $ comm1 | comm2
и предположим что команда2 отраотала и вышла закончила свой процесс то почему при этом
и команда1 тоже сраза заканчивает свой процесс?
ведь очевидно что 
    $ while ...  ; do ..; done | head ...
как только head процесс исчезает то сразу убивается и процесс с while.
я тоже никогда на эту тему не думал. 
точнее я думал примерно так напримере скажем этой команду
    $ cat 1.txt | grep vasya
я раньше думал что вначале полностью отрабатывает cat и умирает а потом полностью отрабатывает grep
и умирает. поэтому все чик пибабум.однако очеивдно как стало понятно это было неверное рассуждние.
я щас полагаю что дело вот в чем, - pipe "|" это всего навсего грубо говоря директива управления 
для баш. она позволяет человеку обьяснить баш что мы от него хотим. если мы пишем в баш вот так
    $ comm1 | comm2
то это говорит баш вот что. запусти два новых процесса. comm1 и comm2
при запуске сделай так что stdout одного смотрел на stdin второго
также важно понять что оба процесса будут дочерними для нашего головного баша. поэтому в баше
есть обработчик событий происходящий с его дочерними процессами! дело в том что когда процесс comm2
сам себя уничтожит (через сисколл к ядру конечно) то ядро пошлет родительскому процессу то есть 
головному бащу сигнал SIGCHLD(както такой) которыйй сообщает голоновму башу что один из его дочерей сдох
и тогда баш имея в себе обработчик этих событий понимая что один их процессов в пайпе сдох он 
как я понимаю тогда берет и уничтожает все остальные процессы которые были им запущены в рамках этого 
пайпа! вот как оно работает походу. поэтому прекращение работы head вызывает то что баш получает 
об этом сигнал и тут же уничтожает процесс с while. поэтому цикл тоже прекрашает работать мгновенно
офигеть.
да... уж... система нипель
а ведь интутиция гвоорила что цикл будет раобтать бесконечно и до head информация никогда не долетит..
ужас.
с этим куском разобрались.
переходим наконец теперь к следущему куску.
###################################
intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )
##################################
и также помещу здесь что за кусок md5hex
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}
##########################################
так что касается md5hex то как было разобрано выше в нее прилетает стринг
она вычисляет от него md5sum классчиеский 
и на выходе она выдает этот MD5 в таком виде
    \x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23

перерходим к разбору главной функции
значит главным образом intermidiate выглядит так
intermediate=$({...} | md5hex )
тоесть вычисляется некая хрень пуляется на md5hex и результат stdout будет запомнен
в intermediate. понятно
скобочки {} нужно лишь для того чтобы некую портянку кода визуально обьеденить
в один кусок. потому что как сказано в баше мане скобки {} в таком случае не играют никакой
функциональной роли а просто визуальный украшатель. рассмотрим эти скобочки


{
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    }
    
первая команда просто печатает в stdout символы  
    "$password$magic$salt"
вторая команда берет стринг $password$salt$password вычисляет от него md5 преобразует его
в в вид \xab\xbc итд и запоминает в $alternate
следущая команда печатает на экране из этой алтернейт переменной несколько байт. несколько это 
значит столько сколько длинна пароля. итак в stdout у нас уже будет
    "$password$magic$salt""какой то кусок альтернейта"
последний кусок кода я тоже уже разбирал. он берет число являющееся длинной пароля. тоесть если 
длинна пароля 8 то он берет число 8. и анализирует его двоичный вид написания. тоесть еэто
    0000 1000
и он печатает в stdout 8 байтов. для каждого бита выбирается байт. если в бите ноль то байт печатается
00h а если бит равен 1 то байт печатается равный первому байту из пароля, пусть он равен A1h
тогда на stdout печатается
    00h00h00hA1h00h00h00h00h
причем печать символов начинается с бита с нулевым оффсетом (поэтому с точки зрения отображения битов
в символы порядок на экране будет обратный. об этой ебале подробно расписывал выше при разборе этого
куска кода так что ищи там). в итоге у нас суммарно в stdout будет вот такая шняга
    "$password$magic$salt""какой то кусок альтернейта"00h00h00hA1h00h00h00h00h"
ну и как я сказал выше этот стринг пуляется на md5hex который от него считает классический MD5
преобразощывает высер в вид \xab\xbc\x1a.... высирает это в stdout
и оно будет запомнено в intermediate переменную. жесть.

теперь разбрем этот кусок
#########################
for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done
###############################

значит это цикл на 1000 раз . от 0 по 999 вкчлючительно
разберем вот эти хрени
        (( i & 1 )) &&
        (( i % 3 )) &&
        (( i % 7 )) &&

во первых еще раз как работает двойная скобка (( )) она вычисляет арифметику внутри скобки.
и в завимисти какое итоговое число получилось внутри скобки возвращает в коде возврата $? число
0 или 1. если в скобке получилось 0 то код возврата 1( что эквивалентно булевому False)
а если в скобке получислся неноль то код
вовзрата 0(булевый True). вот такая канаебка
итак первая скобка (( i & 1 )) тестирует если i нечетное. тогда скобка возвращает $?=0(True) 
и поэтому выполняется команда за &&
вторая скобка (( i % 3 )) вычисляет остаток от деления на 3 , если остаток нулевой возврашает $?=1
и поэтому то что за && не выполняется. 
пример
    $ (( 6 % 3 )) && echo "число НЕ делится на 3" || echo "число  делится на 3"
    число  делится на 3
    $ (( 7 % 3 )) && echo "число НЕ делится на 3" || echo "число  делится на 3"
    число НЕ делится на 3
таким образом вторая скобка проверяет что число НЕ делится на три и тогда выполняет то что за &&
третья скобка проверяет что число НЕ делится на 7  и если это так то выполняет то что за &&

теперт рассмотрим эту хрень целиком
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
если i нечетное то на экране ( в stdout) печатается "$password" иначе печатается "$intermediate"
если i неделится на 3 то далее печатается "$salt"
если i неделится на 7 то далее печатается "$password"
если i нечетное то далее печатается $intermediate иначе печатается $password
возьмем для примера что i=10 тогда у нас будет напечатано
    "$intermediate""$salt""$password"$password

теперь рассмотрим эту хрент
       intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
 
 значит получили мы портиянку на экране
    "$intermediate""$salt""$password"$password
далее она направляется в функцию md5hex которая от нее вычисляет MD5 и преобразует вид
в 
    \xab\xbc\x1a...
и эта хрень запоминатся в переменную    $intermediate
таким образом каждый цикл меняет содержимое перменной $intermediate
содержимое как видно меняется в завимости от предудещего значения $intermediate 
от salt, password, i. тоесть бы сказал то 
    intermediate(i)=f(intermediate(i-1),i,salt,password)
    
теперь рассмотрим этот кусок
################
    for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done

    # Rearrange the bytes and crypt-base64 encode them
    encoded=$(base64EncodeBytes 22 "$intermediate" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

    printf "%s$salt\$%s\n" "$magic" "$encoded" 
###############

значит у нас мусолится цикл. и на выходе мы будем иметь в $intermidiate некую хрень вида
    \xab\x1a\x12...
далее этот $intermiadite вместе с друими константами посылается в функцию base64EncodeBytes
эта функция на основе того что я о ней разбирал выше делает вот что. она принимает 
в берет стринг 
    \xab\x1a\x12...
который мы в нее послали через $intermidaite перстааляет в нем местами эти hex 
числа. и перекодирует их в некий изврашенный аналог base64 который назовем B64.
однако этот B64 нетолько имеет словарь отличый от base64 но и сам алгоритм трансфорирмирования
чудовищно отличаается от классичекого base64
ну и на посленем этапе
        printf "%s$salt\$%s\n" "$magic" "$encoded"
у нас на жкране печатаеся искомый результат. тоесть печатаектся тип хеша,
salt, и так называемый хеш в кодировке B64
значит в этой команде тоже не обошлось без подьебок.
можно заметить что вунтри поля формата стоит  $salt тоесть переменная 
упоминаетсся в поле формат но в непривычном виде. тоесть мы же как привыкли
мы привыкли что переменная вставляется в поле формат вот в таком виде
    $ a=123
    $ printf "%d %d %d \n" "1" "2" "$a"
    1 2 123 
то есть внутри поля формат мы вставляем хреновины вида %d скажем
а снаружи формата мы указываем переменные через пробел
однако оказывается что можно указать переменную сразу в поле формат прям внутри
ровно так как мы это делаем в echo
    $ a=123
    $ printf "$a \n"
    123 
вовзаррашаемся к нашему примеру
        printf "%s$salt\$%s\n" "$magic" "$encoded"
в нем в поле формат через %s идет обраение к переменной $magic
потом напрямую в поле формат указана переменная $salt ,
потом экранирован символ \$
тоесть
    $ printf "\$ \n"
    $ 
потом идем обращение к переменной $encoded через %s и знак переноса строки \n
так вот возникает вопрос а как бы нам избавить от $salt в поле формат и вынести его наружу
туда же где стоят $magic и $encoded
и тут выянсяется очередная хуета относиительно printf,
значит переменная $salt равна чтото типа того 
    $salt="\x31\x32\x33"
так вот принтф имеет вот такую штуку как он работает
    $ salt="\x31\x32\x33"
    $ printf "$salt \n"
    123 
или вот так
    $ printf "\x31\x32\x33  \n"
    123  
охуеть да?
но возникает вопрос а что писать в поле формат если мы $salt вынесем за поле формат?
показываю на примере
    $ salt="\x31\x32\x33"
    $ printf "%d  \n" $salt
    bash: printf: \x31\x32\x33: invalid number
    0  
    $ printf "%s  \n" $salt
    \x31\x32\x33  
    $ printf "%c  \n" $salt
    \  
тоесть все совершенно не то. и нихуя непонятно. и тольк в одном месте
я нашел как надо сделать
    $ printf "%b  \n" $salt
    123  
охуеть....
вообще в bash.txt  я создал отдельную тему "| printf" про то как он работает и его заебы.
таким образом вот эту хрень 
            printf "%s$salt\$%s\n" "$magic" "$encoded"
можно переписать вот так , чтобы было более единообразно
            printf "%s%b\$%s\n" "$magic" "$salt" "$encoded"
охуеть с этим принтф

таким образом я почти закончил разбор как этот скрипт работает.

итак
последний кусок в скрипте 
##############################
if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 

doHash "$password" "$salt" '$1$'
######################################

if [[ $# < 1 ]]  
это означает "если количество параметров переданных скрипту меньше 1 (тоесть ноль) то ..."
пример
    $ cat 10.bash 
    #!/bin/bash

    echo \$0=$0
    echo \$#=$#

    $ ./10.bash  1 2
    $0=./10.bash
    $#=2

итак $# - означает переменную которая показывает число аргументов переданных в скрипт
     $0 - означает путь к скрипту на ФС

далее строчка
        echo "Usage: $0 password [salt]" >&2
мне непонятно какой смысл
    >&2
потому что оно значит 
    1>&2
тоесть стандартный вывод перенаправляется туда куда вываодятся ошибки. зачем так делать неясно

далее строчка
    password=$(stringToHex "$1")
    salt=$(stringToHex "$2")

в $1 у нас в аргументах скрипта пароль , $2 это в аргументах скрипта это salt
функция stringToHex берет входной стринг, находит для его стрингов ascii коды, преобразует эти коды в hex вид виде \x21
и возвращает исходный стринг в форме ascii кодов в hex формате
итак эти две строчки превращают стринги в ascii коды. коды представляются в hex виде \x21
    стринги --> ascii коды
тоесть для примера
    если $1="parole" 
    то   password=$(stringToHex "$1")="\x70\x61\x72\x6f\x6c\x65"

далее строчки
    salt=$(stringToHex "$2")
    [[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 
вторая строчка означает то что "если длина стринга $salt равно 0 то ... "
итак если длина $salt равно 0 то 
    salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8)
тогда рассмотрим подробно
    tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8
рассмотрим подробно только tr
tr имеет синтакс 
    tr ключи SET1 SET2
SET1 и SET2 это некий набор символов.
значит tr без ключей но с SET1 и SET2 берет исходный стринг ищет в нем те символы которые 
в SET1 и меняет их на те что в SET2. 
пример
    $ echo "1a2b3" | tr   "ab" "cd"
    1c2d3
тоесть tr ищет в "1a2b3" символ "a" и меняет его на "c",
и ищет символ "b" и меняет его на "d"
то есть tr делает вот такую замену в исходном стринге
    a --> c
    b --> d
причем tr ищет символ из SET1 не один раз а многократно по всей строке . пример
    $ echo "mama mila ramu" | tr   "m" "v"
    vava vila ravu

итак окей так или иначе 
    tr SET1  SET2
делает то что она ищет символы из SET1 и меняет их на соотвествующие символы в SET2

далее ключ -d SET1 удалеяет символы из SET1
    $ echo "mama mila ramu" | tr   -d  "m"
    aa ila rau
еще пример
    $ echo "mama mila ramu" | tr   -d  " "
    mamamilaramu
проблема c tr  в том что ты с его помощью хер заменишь слово. для этого нужно видимо юзать sed
tr подходит для замены отдельных символов а не слов.
еще пример
он прикольный. вначале "m" меняется на "v"
а потом "m" меняется на "s"
также "a" меняется на "a" 
а потом "a" меняется на "y"
поэтому
    $ echo "mama2 mila ramu" | tr   "mama" "vasya"
    sysy2 sily rysu
таким образом пробовать менять слова с помощью tr это бесполезное дело. 
он больше подходит для замены символов во всех документе.
    $ echo "mama2 mila ramu" | tr   "a" "A"
    mAmA2 milA rAmu
я бы сравнил tr с функцией в текстовом редакторе "найти символ и заменить во всем тексте"
теперь хочу рассмотреть два примера
    $ echo "mama2 mila ramu" | tr  " " "-"
    mama2-mila-ramu
    $ echo "mama2 mila ramu" | tr  -c " " "-"
    ----- ---- -----
в первом примере " " заменяется на "-" и результат понятен и логичен
во втором примере испольуется ключ -c. я заебался искать как он работает. в man tr нихуя не написано. ман вобще ебнутый у tr.
а в info tr я нашел как раобтает ключ -c.  значит без каких либо ключей SET1  обозначает те символы которые 
он ищет в тексте так вот -c SET1 он дает то что tr инвертирует массив символов из SET1. тоесть если 
    tr SET1
означает ищи все символы указанные в SET1
то 
    tr -c SET1
означает ищи все символы кроме тех что указаны в SET1
скажем у нас стоит 
    tr "a" "b" 
означающий что найди "a" и замени на "b" 
то  tr -c "a" "b" 
означает что найди любые символы кроме "a" и замени их на "b"
поэтому
    $ echo "mama2 mila ramu" | tr  -c " " "-"
    ----- ---- -----
tr ищет все символы кроме " " и заменяет их на "-"
тоесть -c "символы" означает ищи все символы а указнные не трогай.
еще пример
    $ cat 10.bash  | tr -c " \n" "#"
    ###########

    #### ######
    #### ######
    
    ######
    #### ######

    #####
    #### ######
    
    #######
    #### ######
    
    #########
    #### ######
тоесть мы говорим tr ищи символы все кроме пробела и новой строки и заменяй их на "#"
далее вот интересный пример. мы берем  из urandom триста байт и заменяем в нем все символы на "#" кроме пробела a-z A-Z 0-9
    $ head -c 300 < /dev/urandom  | tr -c " a-zA-Z0-9\n" "#" ; echo ""
    #p#iT##w3######br##V#########D######oo4Q########hw#o##u
    ##f##NN##########Qh#########XB#######Z#W#Lg##d####UX#2#G########K####Bs####q###JE#####P#####K######4####sD##Z#d##FF###27###q####f#2#D#1i#####p###########r##4#MD#p2###T##Ov###C##Q##z##A#p##########I########A##JW######i#cc#X##5####3#Q###U##LG##46
прикольно..
еще пример
мы берем триста байт из urandom и удаляем все байты(символы) кроме пробела a-z A-Z 0-9
тоесть ключ -d говорит о том что надо удалить из потока все символы укзанные в SET1
но поскольку у нас -с SET1 то -d -c SET1 означает удали все символы кроме тех что указны в SET1
$ head -c 300 < /dev/urandom  | tr -c -d " a-zA-Z0-9\n"; echo ""
QlbTb DttwacmU2ReWZFM CY
GWOVpfQ0zErkgy448g7JF I4lreQ2BRJ7YBzcrohBr
далее
если у нас указан -d то прописывать SET2 нет смысла. потому что мы ничего не заменяем мы только удаляем.
возврашаемся к прмиеру из скрипта
    salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8)
итак из urandom читаются байты\символы и из потока удаляются все символы кроме a-z A-Z 0-9
и потом из этого измененного потока забираются первые 8 байтов. то есть первые 8 символов.
и эта хрень записывется в $salt
    $ tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8
    gSBy8fT7
итак tr хорош если нам надо во всем тексте заменить один символ на другой или вырезать из всего текста символ.
далее 
у tr есть подьбека нужно чтобы все ключи были до SET1 и SET2 иначе он не поймет тоесть
пример
работает
    $ echo "a1b" | tr -d "1"
    ab
пошел нахуй потому что -d должен стоять до SET1 и SET2
    $ echo "a1b" | tr "1" -d
    a-b
ключ -s дает то что в модифициованном потоке удаляются повторяющиеся рядом стоящие символы из SET2
тоесть
    $ echo "abbc" | tr  "b" "A"
    aAAc
    $ echo "abbc" | tr -s "b" "A"
    aAc
еще пример
$ echo "goooooogle is ..." | tr -s "o" 
gogle is ...
прикольно
    $ echo "goooooogle is google" | tr -s "o" 
    gogle is gogle
итак tr может во всем тексте заменить заданный символ на другой, удалить заданный символ во всем тексте,
во всем тексте заменить все символы кроме заданных, удалить все символы кроме заданных во всем тексте,
убрать в тексте повторяющиеся стоящие рядом символы.
у tr есть предопределенные классы символов для SET1 чтобы нам не мучаться и их не вводить руками.
об этом смотри в man tr а щас просто примеры
причем я приожу примеры не на все классы . поэтому для всех классов смотри man tr
    $ cat  < /dev/urandom  | tr -cd [:digit:] | head -c 10; echo ""
    6219672303
    $ cat  < /dev/urandom  | tr -cd [:graph:] | head -c 10; echo ""
    TKRyRNfW2%
    $ cat  < /dev/urandom  | tr -cd [:lower:] | head -c 10; echo ""
    mqcfcshjsi
    $ cat  < /dev/urandom  | tr -cd [:print:] | head -c 10; echo ""
    ZD0mVOp~~q
    $ cat  < /dev/urandom  | tr -cd [:punct:] | head -c 10; echo ""
    <]/:@}:+,{
    $ cat  < /dev/urandom  | tr -cd [:upper:] | head -c 10; echo ""
    RYIADZIQVO
    $ cat  < /dev/urandom  | tr -cd [:xdigit:] | head -c 10; echo ""
    56d6d5D2C2
 
может возникнуть вопрос а как же до tr или head прилетают данные от cat через пайп если cat читает 
бесконечный urandom. ответ в том что данные начинаются литться через пайп к соседнему процессу сразу же как cat начинает 
читать данные. а не после того как он их бы все прочел. тоесть cat читает сколько то данных из urandom в свой буфер. и как только буфер 
заполнился то он его высирает в свой stdout который закольцован на stdin у tr. для stdin у tr там запущен запрос к ядру что как только
на stdn у tr чеото поступит то разбудить tr. щедулер вытесняет процесс cat и пробуждает процесс tr. 
таким же макаром когда tr обработае сколько данных то высирает в stdout их часть. stdout у tr закольцован на stdin у head.
как только на stdin у head поступают данные то ядро будит head. а другие процессы если скажем это 1 ядернйы процессор шедулер выдавливает 
с цпу. и head уже высирает нам на терминад данные. как только head высрет 10 байтов то он прекращает свою деятелность и шлет в ядро
сисколл чтоб ядро убило егоный процесс. ядро убивает процесс с head. и шлет головному процессу баша который запускал этот head 
сигнал SIGCHLD что его дочерний процесс сдох. тогда как я понимаю баш уже сам автомтом убивает остальные процессы которые входили в 
цепочку пайпов. поэтому смерть одного из процессов в цепочке пайпов вызывает в итоге смерть всех процессов в цепочке.
все это приводит к тому что для того чтобы head получил данные сосвсем ненужно ждать пока cat прочитвает все данные из бесконечного
файла urandon. и то что смерть одного из процессов из цеочки пайпов вызывает смерть всез процессов в цепочке.

таким макаром я разобрал полностью весь конец скрипта
#########
if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 

doHash "$password" "$salt" '$1$'
############

последння строчка ывзает функцию doHash которая начинает искать ответ на поставленню задачу.
таким макаром я разобрал как работает вест скрипт от верха до низа.


теперь  надо взять конкретный i и прогнать по скрипту посмотреть что принимают при этом
        его разные переменные какие значения


запускаю скрипт вот так
$ ./debug.bash abc 12345678
тоесть пароль = abc
salt=12345678

поехали выполнять программу


if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2
    exit 1
fi

этот кусок программа проскочит так как "$#"="2"

password=$(stringToHex "$1")

значит у нас будет 
password=$(stringToHex "abc")


функция stringToHex

stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

значит #1=3
значит

stringToHex() { 
    for((i=0; i<3; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

значит функция берет "abc" начинает у него брать символы начиная с нулевого офссета (самый левый символ) то есть 
это будет 
a
b
c
и печатает его в виде ascii кода в формате hex \xNN
ascii код для a  = 0x61
          для b  = 0x62
          для c  = 0x63
тогда функция вернет 
password="\x61\x62\x53"
проверяю в программе
и дейтсвительно 
    $ cat debug.txt 
    password=\x61\x62\x63


salt=$(stringToHex "$2")
тогда будет 
salt=$(stringToHex "12345678")
тогда будет 
stringToHex() { 
    for((i=0; i<$8; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

ascii для 1= 0x31
      для 2= 0х32
      ...
      для 8=0x38
тогда stringToHex вернет "\x31\x32\x33\x34\x35\x36\x37\x38"
тогда
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
проверяю
и действиельно
    salt=\x31\x32\x33\x34\x35\x36\x37\x38

    
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 
чтобы эта строка выполниась апускаю скрипт по другому
     $ ./debug.txt abc
тогда он возьмет из urandom только символы a-z A-Z 0-9 в количестве 8 штук и присвоит salt
проверяю
и действительно
    salt=5ZhB6Sm3
запускаю обртано скрипт с 
    $ ./debug.txt abc 12345678

    
doHash "$password" "$salt" '$1$'
тогда будет
doHash "\x61\x62\x63" "\x31\x32\x33\x34\x35\x36\x37\x38" '$1$'

переходим в doHash()


doHash() { 
    password="$1"

#
тогда
password="\x61\x62\x63"
проверяю
и дейтисвиельно сходится
doHash() password=\x61\x62\x63
#

    passwordLength=$(printf "$password" | wc -c)

#
значит wc -c считает байты
значит тогда 
passwordLength=$(printf "\x61\x62\x63" | wc -c)
поскольку в поле формат запись \x61 означает прям сам байт записанны в хекм формате 
а не литеры то это значит что принтф высрет 3 байта из себя. и дейтвительно
$ printf "\x61\x62\x63" | od -t x1
61 62 63
тогда wc -c дожлен насчитать 3 байта и тогда 
passwordLength="3"
проверяем
и действиетьно
doHash() passwordLength=3
#
    salt="$2"
# 
salt= "\x31\x32\x33\x34\x35\x36\x37\x38"
проверяю
doHash() salt=\x31\x32\x33\x34\x35\x36\x37\x38
совпало
#
    magic="$3"
#
magic='$1$'
проверяю
doHash() magic=$1$
совпало
#
    [[ -z $magic ]] && magic='$1$'


    salt=${salt#'$1$'}
#
эта хрень значит искать с начала строки стринг $1$ и вырезать его
пример
    $ a='aws$1$'
    $ echo ${a#'$1$'}
    aws$1$
    $ a='$1$aws'
    $ echo ${a#'$1$'}
    aws
    $ a='$1$aws$1$'
    $ echo ${a#'$1$'}
    aws$1$
в нашем конкретном случае salt="\x31\x32\x33\x34\x35\x36\x37\x38"
поэтому
    $echo ${salt#'$1$'}
    \x31\x32\x33\x34\x35\x36\x37\x38
не приведет ни к чему. поэтому salt останется неизменным
    
#
    salt=${salt:0:32} # 8 first bytes
#
эта команда выбирает 32 символа из переменной начиная с оффсета 0 тоесть символы 0-31 
поскольку salt="\x31\x32\x33\x34\x35\x36\x37\x38"
тоесть на 1 байт в hex формате приходится 4 символа то это значит что будет выбрано 8 байт в хекс формате
в нашем случае так как salt изначально был 8 байт то будет выбрано вся переменная
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
проверяю на праткике
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
совпало


    
    intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

#
password='\x61\x62\x63'
magic='$1$'
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
поэтому  
    printf "\x61\x62\x63$1$\x31\x32\x33\x34\x35\x36\x37\x38" = abc$1$12345678
проверяю
    abc$1$12345678
совпало
что тут интересно. интересно то что 
вот в таком примере у нас принф печатает содержимое переменной
    $ cat 10.bash 
    #!/bin/bash
    printf "$1\n"

    $ ./10.bash vasya
    vasya

тоесть 
    printf "$1\n" = printf "vasya\n"
вместо $1 подставляется занчение этой переменной
а вот в этом примере не происходит двойного раскрытия имени переменной
    $ cat 10.bash 
    #!/bin/bash
    a='$1'
    printf "a=$a\n"

    $ ./10.bash vasya
    a=$1
тоесть
    printf "a=$a\n" = printf "a=$1\n" 
и дальнейшей второй подставновки вместо $1 ее значения не происходит. поэтому будет 
напечаатано 
    a=$1
а не 
    vasya
тоесть если переменная раскрылась один раз и там у нас еще одно имя перееменной. то второй раз
переенная не раскрывается
вот еще пример на эту тему
    $ a=1
    $ b='$a'
    $ echo "$b"
    $a
вообще если указать имя переменной вот так
    $ b='$a'
то ты эту переменную $a вобще никак не раскроешь . даже вот так
    $ echo "${!b}"
    bash: $a: bad substitution
единственный вариант как можно раскрыть переенную два раза это вот так
    $ a="1"
    $ b="a"
    $ echo "${!b}"
    1
но у нас не такой случай
наш случай это 
    magic='$1$'
    printf "...$magic..."
поэтому напечается именно '$1$' а не содержимое переменной $1="abc"
охуеть как наворочано
итак в результате команды
       printf "$password$magic$salt" 
будет напечатано
       abc$1$12345678
#
    
    
        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

#
    alternate=$(printf "$password$salt$password" | md5hex) =>
    $(printf "\x61\x62\x63\x31\x32\x33\x34\x35\x36\x37\x38\x61\x62\x63" | md5hex) =>
поскольку printf воспринимает \xNN как ascii код символа в hex формате то это эквивалентно 
    => $(printf "abc12345678abc' | md5hex) =>
действительно
    printf "\x61\x62\x63\x31\x32\x33\x34\x35\x36\x37\x38\x61\x62\x63"
    abc12345678abc
тогда
    $(printf "abc12345678abc' | md5hex) => \x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff
сравниваем
       \x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff
все совпало
#

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

#
здесь 
$passwordLength="3"
printf "$alternate"=printf "\x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff"=]M�!������m8....
тогда
printf "\x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff" | head -c3
высираются байты "\x5d\x4d\x9e" 


#
прежде чем переходить  к следущему куску
надо прояснить что такое {} в баше.
для этого я говорю о том что 
вот этот кусок кода

{
  printf "1"
  printf "2"
  printf "3"
}

и вот этот кусок кода это одно и тоже
 { printf "1"; printf "2"; printf "3"; }
 причем обязательно проставить все ";" иначе будет хуйня

доказать это легко надо лишь проверить что на выходе один и тот же поток 
байтов

$ {
  printf "1"
  printf "2"
  printf "3"
} | od -t x1
0000000 31 32 33

$ {   printf "1";   printf "2";   printf "3"; } | od -t x1
0000000 31 32 33

итак мы видим что это одно итоже
а вот разница если мы уберем скобки
    printf "1";   printf "2";   printf "3"  | od -t x1
    120000000 33
тоесть "1" и "2" улетели не в od а на экран. а в od улетело только "3"




        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )


# 
$passwordLength="3"
также printf "$password" = printf "abc"
значит

        for ((i=3; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "abc" | head -c 1
            fi
        done

    } | md5hex
    )

значит 3 в битовом виде это 11
из кода цикла видно что для каждого установленного бита в байте 11 печатается printf '\x00'
значит в результате выполнения цикла как бы отработает вот такой код
    printf '\x00'
    printf '\x00'

кстати вот интересно что мы получаем на выходе какой байтовй поток
    $ printf "\x00" | od -t x1
    0000000 00
а понятно. реально будут высираться байты вида 00h
что интересно попытка печати этих байтов на экране не приводит ни к чему
    $ printf "\x00\x00\x00\x00"
на выходе просто ничего не происходит
вот еще так можно сделать
    $ head -c 10 < /dev/zero | od -t x1
    0000000 00 00 00 00 00 00 00 00 00 00
убедиться что на экране нихерна ненапечатается ни один символ хотя байты поступают
    $ head -c 10 < /dev/zero | cat
тоесть этот байт 00h он не является печатным. он является для терминала управлющим. (так же как скажем \n)
и говорит терминалу что нихрена делать ненадо

    
далее видим вот такое
    } | md5hex
    )

так вот я не зря про { рассуждал выше. в md5hex полетит не то что вылетело из последнего цикла
а вообще все что стоит по intermediate. давай ка я соберу все то что было непечатано на stdout внутри
intermediate, я соберу это все в формате единого printf
    printf "abc\$1\$12345678\x5d\x4d\x9e\x00\x00"
и все это  перенаправляется на md5hex тоесть
    printf "abc\$1\$12345678\x5d\x4d\x9e\x00\x00" | md5hex
получаем
    \xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3
проверяем
    \xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3
сходится
итак intermidiate="\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"

#
    
    
    for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done

#
берем i=0
intermidiate="\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"
тогда 
            (( 0 & 1 )) && printf "$password" || printf "$intermediate"
            (( 0 % 3 )) && printf "$salt"
            (( 0 % 7 )) && printf "$password"
            (( 0 & 1 )) && printf "$intermediate" || printf "$password"

(( 0 & 1 )) = (( 0 )) ; это false это код возврата 1 значит отработает printf "$intermediate"
(( 0 % 3 )) = (( 0 )) ; это false поэтому далее ничего не отрабтает
(( 0 % 7 )) = (( 0 )) ; это false поэтому далее ничего не отрабтает
(( 0 & 1 )) ; это false значит отработает  printf "$password"
значит в итоге у нас отработает 
    printf "$intermediate"
    printf "$password"
что эквилвалетнтно
    printf "$intermediate$password"
что эквавалетно 
    printf ""\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"abc"

видно что дальше эта хрент напускатся на md5hex
    printf "\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"abc" | md5hex
значит новый intermidiate 
    intermidiate=$(printf "\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"abc" | md5hex)
я посчитал руками это 
    \x5a\xdd\xbb\x70\x9e\xaa\xe3\x53\x74\x6d\x25\x56\x70\xa8\xef\x5f
далее я запустил исходный скрипт при i=0 и получил
    \x5a\xdd\xbb\x70\x9e\xaa\xe3\x53\x74\x6d\x25\x56\x70\xa8\xef\x5f
все совпадает
значии далее этот intermidiate таким макаром внутри цикла колбасится 1000 раз
итоговый intermidiate после 1000 раз будет такой
    intermidiate="\x40\x1d\x63\xc9\xa4\xd1\xf8\x15\x04\xb6\x88\xda\x52\x2f\x03\x05"
#




    # Rearrange the bytes and crypt-base64 encode them
    encoded=$(base64EncodeBytes 22 "$intermediate" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

#
значит это будет запущено вот так
        encoded=$(base64EncodeBytes 22 "\x40\x1d\x63\xc9\xa4\xd1\xf8\x15\x04\xb6\x88\xda\x52\x2f\x03\x05" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

посмотрим еще раз на функцию 

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}

она запускает функцию getBytes котрая из $intermediate выбирает байты \xnn в указанном порядке
тоесть просто переставляет местами

getBytes() { 
    num=$1
    echo "$@"
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
    echo ""
}

тоесть на выходе мы будем по прежнему иметь "\xnn\xnn..."

далее запускается hexToInt
она преобразует из вида \xnn\xnn в  \xNN\xNN\xNN, далее преобразует к виду NNNNNNNNNN типа 40AB45ED21AF
далее эта хрень направляется в bc и он преобразует это шестанадцатиричное число в десятичное вида 168846464562234234

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}

далее запускается функция intToBase64 "168846464562234234" "22"
которая преобразует это десятичное число в B64 вид используя 
глобальную переменную b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
значит работает эта функция так. она берет исходное число "168846464562234234" и делит его на 64
находит остаток от деления и эта цифра является оффсетом символа в переменной $b64
скажем остаток от деления 168846464562234234 на 64 это 58. значит берется 58-ый символ (отсчитывая от нуля) в $b64
это символ "u" это будет первый символ нашего искомого хеша в кодировке B64
далее исходное число делится на 64 нацело. это и есть новое исходное число. и с этим новым исходным числом 
цикл повторяется. тоесть оно делитнся на 64 ищется остаток. по нему находится новый символ. и так 22 раза. 
таким макаром исходное десятичное число превращается в 22 символа из словаря $b64

intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")  # остаток от деления
        number=$(bc <<< "$number / 64") # целое от деления
        echo -n "${b64:digit:1}"
    done
    echo ""
}

        
я запустил вызов  base64EncodeBytes() и получил
    GVDEjIF51EkM3MPmFX6dO1
а вот я запустил в исходном скрипте
    GVDEjIF51EkM3MPmFX6dO1
совпало
#

    
    printf "%s%b\$%s\n" "$magic" "$salt" "$encoded"


}

# 
эта хрень печатает просто напросто $magic  $salt и $encoded

$magic='$1$'
$salt="\x31\x32\x33\x34\x35\x36\x37\x38" без разницы
$encoded='GVDEjIF51EkM3MPmFX6dO1'

запускаю
    $ printf "%s%b\$%s\n" "$magic" "$salt" "$encoded"
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1
сравниваем с тем что из исходного скрипта
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1
совпало

#

кстати не все функции этого скрипта используются алгоритмом например функция 
stringToNumber() не используется никак


таким макаром я вроде как прям пролезнув по шагами скрипта проработал конкретно на цифрах как 
он работает.




теперь я опишу как раобтает алгоритм НА СЛОВАХ:
мы запускаем скрипт. вводим в аргументах password и salt
если солт мы не ввели он будет сформирован рандомно
далее из солт преобразуется так что из него берется только первые 8 символов
далее задается константа magic

далее вычисляется переменная intermidiate следущим образом:
 на stdout посылаются следущие хрени
    - password+magic+salt"
    - вычисляется md5 от password+salt+password
      и потом мы от этого md5 отрезаем ровно столько байтов какова длинна пароля и эти байты тоже посылаем на stdout
    
    тут надо помнить что функция md5sum она выводит не сам хеш ибо это набор байтов часто которые
    не соовествуют по аски кодам печатным символам поэтому коды байтов преобразуются в новые аски коды для которых
    печатные символы соовествуют аски кодам хеша. тоесть вот это не хеш
    $ printf "1" | md5sum | awk '{print $1}' 
    c4ca4238a0b923820dcc509a6f75849b
    вот это реальный хеш
    $ printf "1" | md5sum | awk '{print $1}' | xxd -p -r -
    �P�ou��
    а вот его байтики 
    $ printf "1" | md5sum | awk '{print $1}' | xxd -p -r - | xxd -p
    c4ca4238a0b923820dcc509a6f75849b
    тоесть надо отличать реальные байты которые составляют даннные 
    и в какой символ преобразуется этот байт на экране. так вот символ 1 на экране
    это не тоже самое что байт 0x1 
    тоесть есть байты котоые и составлят данные. а есть графическая интепретация в символы на экране
    которые тоже имеют цифровой смысл
    
    - берем длинну пароля. берем это число. переводим его в двоичный вид. например это 01010010101
    далее начинаем перебирать биты начиная с младщего и начинаем на stdout посылать байты  по следущему правилу
    если текущий бит 1 то посылаем байт \x00 а если бит 0 то берем пароль и посылаем первый байт из пароля
    тоесть пусть первый байт пароля  тогда для длинны пароля в бинарном виде 01010010101
    мы на stdout будем посылать байты  \x61  \x00 \x61  \x00  \x61 \x61  \x00  \x61  \x00  \x61   \x00

    так вот берем эти три хрени и от этой конструкции вычисляем md5 это и есть переменная intermidiate

далее запускается цикл из 1000 шагов.(через переменную i)
на кажом шаге пересчитывается эта переменная intermediate по схеме

            если i нечетный то  на stdout шлем password иначе шлем intermediate
                но это еще не конец, далее в этом же шаге цикла идет следущий шаг
            если i НЕделится на 3 то шлем salt
                далее идет следущий шаг
            если  i НЕделится на 7 то шлем  password
                далее идет следущий шаг
            если i нечетный  то шлем intermediate иначе  шлем password

            для примера пусть i=15 тогда на stdout будет послано
                password+salt+password+intermediate
            далее от этой хрени вычисляется md5 тоесть для i=15 вычислятся md5(password+salt+password+intermediate)
            и это и присваивается переменной intermidiate
            далее цикл повторяется и так до конца цикла

когда цикл отработал то в получившейся переменной intermidiate переставляются байты по схеме
             11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12

далее после перстановки полученный поток байтов в intermidiate перекодируется в так называемый B64
алгоритм перекодировки такой - берется intermidiate перекодируется в десятичное число. 
это число делится на 64 находится остаток и этот остаток используется как оффсет для поиска символа в словаре
словарь этой кодировки 
            "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
тоесть если остаток равне 63 то берется символ "z" к примеру
далее берется это десятичное число и делится на 64 , целое от деления берется как новое значение intermidiate
и цикл повторяется заново. так просиходит 22 раза. таким макаром мы получаем 22 символа из словаря.
это и есть типа искомый хеш.
это пиздец а не алгоритм


теперь покажу что результаты работы скрипта совпдают с утилитами официльными котоыре типа делают тоже самое

    $ ./md5crypt.bash abc 12345678
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1

    $  mkpasswd --method=md5  abc 12345678
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1

    $ openssl passwd -1 -salt  12345678 -stdin <<< abc
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1

как видно получили одно и тоже. значит утилита работает правдоподобна



ДАЛЕЕ я перехожу к тому ради чего все началось с того как вычисляется /etc/SHADOW с использованием SHA-512
вначале я проверю что скрипт 
    https://www.vidarholen.net/contents/junk/files/sha512crypt.bash
выдает верный результат совпадающий с оф утилитами

    $ ./sha512crypt.bash abc 12345678
    $6$12345678$/2kqzTQ48gi0uN7n3YdhWAqTslf4Lt0yEsFxSucHzxAU7FaXCW..I1OVwaoe6mZIAD.3r1wHv4OIZ90Fuvomd0

    $ mkpasswd --method=sha-512 abc 12345678
    $6$12345678$/2kqzTQ48gi0uN7n3YdhWAqTslf4Lt0yEsFxSucHzxAU7FaXCW..I1OVwaoe6mZIAD.3r1wHv4OIZ90Fuvomd0

    $ openssl passwd -6 -salt  12345678 -stdin <<< abc
    $6$12345678$/2kqzTQ48gi0uN7n3YdhWAqTslf4Lt0yEsFxSucHzxAU7FaXCW..I1OVwaoe6mZIAD.3r1wHv4OIZ90Fuvomd0

мы видим что скрипт sha512crypt.bash выдает все тоже самое. значит можно его рассматривать

####################sha512crypt.bash#########################
#!/bin/bash
# sha512-crypt for GNU and Bash
# By Vidar 'koala_man' Holen

b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}

# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

# Turn stdin into a \xd4\x1d style sha512 hash
sha512hex() { 
    sum=$(sha512sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}

# Turn an integer into a crypt base64 string with n characters
intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")
        number=$(bc <<< "$number / 64")
        echo -n "${b64:digit:1}"
    done
}

base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}

# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}

doHash() { 
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    saltLength=$(printf "$salt" | wc -c)
    magic="$3"
    [[ -z $magic ]] && magic='$6$'

    salt=${salt#$magic}
    salt=${salt:0:64} # 16 first bytes

    intermediate=$(
    {
        # Start intermediate result
        printf "$password$salt" 

        # compute a separate sha512 sum
        alternate=$(printf "$password$salt$password" | sha512hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while true; do printf "$alternate"; done | head -c "$passwordLength"

        # For every 1 bit in the key length, add the alternate sum
        # Otherwise add the entire key (unlike MD5-crypt)
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf "$alternate"
            else 
                printf "$password" 
            fi
        done

    } | sha512hex
    )
    firstByte=$(hexToInt $(getBytes "$intermediate" 0))

    p_bytes=$(for((i=0; i<$passwordLength; i++)); do printf "$password"; done | sha512hex | head -c $((passwordLength*4)) )
    s_bytes=$(for((i=0; i<16+${firstByte}; i++)); do printf "$salt"; done  | sha512hex | head -c $((saltLength*4)) )


    for((i=0; i<5000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$p_bytes" || printf "$intermediate"
            (( i % 3 )) && printf "$s_bytes"
            (( i % 7 )) && printf "$p_bytes"
            (( i & 1 )) && printf "$intermediate" || printf "$p_bytes"
        } | sha512hex)
    done

    # Rearrange the bytes and crypt-base64 encode them
    hex=$(base64EncodeBytes 86 "$intermediate" \
        63  62 20 41  40 61 19  18 39 60  59 17 38  37 58 16  15 36 57  56 14 35 \
            34 55 13  12 33 54  53 11 32  31 52 10   9 30 51  50  8 29  28 49  7 \
             6 27 48  47  5 26  25 46  4   3 24 45  44  2 23  22 43  1   0 21 42)

    printf "%s$salt\$%s\n" "$magic" "$hex" 

}


if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2 
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 16) 

doHash "$password" "$salt" '$6$'

####################sha512crypt.bash#########################


разберу его по кускам
############################

#!/bin/bash
# sha512-crypt for GNU and Bash
# By Vidar 'koala_man' Holen

это словарь для кодирования B64
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"


вот эта функция хоть и есть в скрипте но по факту нихрена
не используется в алгоритме вообще
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}



эта штука находит для каждого символа его ascii символ
переводит его в hex и добавляет \x получается \xnn
например "a" на входе имеет 0x61 ascii
и на выходе будет "\x61"
тоесть "abc" --> "\x61\x62\x63"
фишка в том что для printf на выходе выдаст одно итоже
printf "a" = printf "\x61"

# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}


эта штука берет входящий аргумент '2232ffeffv33ewfw'
находит от него sha512 получаем чтото типа "a112b2.."
и далее к этому добавляется \x на выходе будет "\xa1\x12\xb2.."
тоесть '2232ffeffv33ewfw' --> sha512sum(2232ffeffv33ewfw) --> "\xa1\x12\xb2.."

# Turn stdin into a \xd4\x1d style sha512 hash
sha512hex() { 
    sum=$(sha512sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}


берем десятичное число "3445345464564646" и коневертируем его в B64

# Turn an integer into a crypt base64 string with n characters
intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")
        number=$(bc <<< "$number / 64")
        echo -n "${b64:digit:1}"
    done
}

# эта хрень вобоще не испольщуется в реальном алгоритме скрипта
base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}


эта функция  получает аргументы  вида \x12\xa1\xb2\xc2\xf1  5 4 1
и переставляет в \x12\xa1\xb2\xc2\xf1 хрени вида \x.. местами в 
заданном порядке как указано 5 4 1
тоесть было  \x12\xa1\xb2\xc2\xf1  стало  \xf1\xc2\x12
тоесть эта хрень перставляет местами 

# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}


эта функция на входе получает \xa1\xa2\xb1\xc1
конвертирует a1a2b1c1
а его коневертирует в десятичное число

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}


эта функция берет \xa1\xa2\xb1\xc1
и конвертирует его в B64 кодировку

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}



головная функция

doHash() { 
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    saltLength=$(printf "$salt" | wc -c)
    magic="$3"
    [[ -z $magic ]] && magic='$6$'

эта хрень никогда не сработает. потому что salt="\xa1\x12\x31\b1"
то в нем никогда не будет стринга $magic потому что $magic='$6$'
и это никак не похоже на \xnn
    salt=${salt#$magic}

выбирает 16 байтов из солта
указано 64 символа потому что солт имеет формат "\xa1\x12\x31\b1..."
    salt=${salt:0:64} # 16 first bytes




    intermediate=$(
    {
        # Start intermediate result
        printf "$password$salt" 

        # compute a separate sha512 sum
        alternate=$(printf "$password$salt$password" | sha512hex) 

        эта штука берет $alternate и вырезает от из него столько байт сколько длинна пароля
        причем если длинна пароля длинее чем $alternate то набор байтов продолжается 
        заново сначала пароля и высирает это на stdout
        # Add one byte from alternate for each character in the password. Wtf?
        while true; do printf "$alternate"; done | head -c "$passwordLength"


        эта штука берет число которое показывает длину пароля
        потом по факту это число как бы преобразуется в двоичный вид 0101010101
        далее анализируется этот вид начиная с младшего бита к старшему
        и если очередной бит 1 то на stdout высирается "$alternate"
        а если очередной бит 0 то на stdout высирается "$password"
        # For every 1 bit in the key length, add the alternate sum
        # Otherwise add the entire key (unlike MD5-crypt)
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf "$alternate"
            else 
                printf "$password" 
            fi
        done


все что было высрано на stdout оно направляется на sha512hex функцию        
        
    } | sha512hex
    )
    
    эта хрень вырезает первый байт из intermediate 
    результрующий результат это число в dec формате
    firstByte=$(hexToInt $(getBytes "$intermediate" 0))

    
    эта хрень берет password повторяет его столько раз сколько длинна пароля в байтах.
    если длинна пароля 4 символа то будет четыре раза повторен пароль.
    далее этот четверной пароль бросается на sha512hex тоесть из этого вычисляется sha512 
    и получаем число вида \x21\x34\x45... и из него вырезается столько \xnn столько штук сколько длинна пароля.
    тоесть при длинне пароля 4 символа тогда будет вырезано 16 символов тоесть \x21\x34\x45\x67
    p_bytes=$(for((i=0; i<$passwordLength; i++)); do printf "$password"; done | sha512hex | head -c $((passwordLength*4)) )

    эта хрень берет salt и печатает его 16 раз на stdout и еще столько раз сколько составляет число firstByte
    далее эти солты посылаются на sha512hex которая считает от этого sha512 и переводит ее в вид \x12\x13\x14\x15
    и из этой хрени вырезает столько \xnn штук сколькл длинна солта. скажем если солт длинна 3 символа то 
    вырезано будет \x12\x13\x14
    s_bytes=$(for((i=0; i<16+${firstByte}; i++)); do printf "$salt"; done  | sha512hex | head -c $((saltLength*4)) )


    цикл на 5000 шагов    
    for((i=0; i<5000; i++))
    do
    перевычесляется intermidiate путем того что 
    если i нечетное то печатается $p_bytes иначе $intermediate
    далее
    если i неделится на 3 то печатается  s_bytes
    далее
    если i неделится на 7 то печатается  p_bytes
    далее
    если i нечетное то печатается intermediate иначе печатается p_bytes
    и далее вся эта портянка скармилвается функции sha512hex
    это и есть новый intermediate
    и таки циклов перевычисления 5000 штук
        intermediate=$({
            (( i & 1 )) && printf "$p_bytes" || printf "$intermediate"
            (( i % 3 )) && printf "$s_bytes"
            (( i % 7 )) && printf "$p_bytes"
            (( i & 1 )) && printf "$intermediate" || printf "$p_bytes"
        } | sha512hex)
    done


берется intermediate которая имеет вид \x11\xa1\xa2... посылается на base64EncodeBytes которая 
переставляет местами их в соотвествии с тем как указано цифрами 63 62 итд
а далее эту хрень она перекодирует в B64 формат по алгоритму такому что 
обновленный intermediate конвертруется в dec формат. потом это число делится на 64 и вычисляется целое 
от деления и это новый intermidiate и остаток от деления это офффсет на основе которого из словаря
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" выбирается символ который и явялется искомым.
далее обновленный intermidiate заново делится на 64 и так по кругу пока мы не получим 86 символов
    # Rearrange the bytes and crypt-base64 encode them
    hex=$(base64EncodeBytes 86 "$intermediate" \
        63  62 20 41  40 61 19  18 39 60  59 17 38  37 58 16  15 36 57  56 14 35 \
            34 55 13  12 33 54  53 11 32  31 52 10   9 30 51  50  8 29  28 49  7 \
             6 27 48  47  5 26  25 46  4   3 24 45  44  2 23  22 43  1   0 21 42)

эта хрень печатает ту самую штуку которую мы хотим 
получить в конечном итоге
резултат имеет вид magic+salt+хеш
    printf "%s$salt\$%s\n" "$magic" "$hex" 

}


если при запуске скрипта не было указано ни одного аргумента
то скрипт пошлет нахер
if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2 
    exit 1
fi

конвертируем пароль так что каждая литера пароля конвертируется в ее ascii код в hex формате \xnn
скажем пароль был "a" стал "\x61"
формально пароль изменился
но если мы будем печатать пароль через printf то результат на stdout будет одно итоже 
в обоих случаях  printf "a" = printf "\x61"
password=$(stringToHex "$1")

тоже самое для солт
salt=$(stringToHex "$2")

если солт при запуске солта не был указан как аргумент то солт генериуется на основе urandom длинной 16 байт
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 16) 

запуск главной функции которая нам и посчитает то что мы хотим
doHash "$password" "$salt" '$6$'


############################

вот так и получается та самая строчка в /etc/shadow
пиздец

   
##########################################


    
===
| filebeat 


проверить что конфиг верный
#filebeat test config

но это тоьлко провека что гланый конфиг верный flebeat.yml
а то что у тебя в модулях верно все (/etc/filbeat/modules.d) которые тоже конфиги эта сука так
не проверяет. чтобы проверить что и в модулях все окей надо останвоить filebeat 

# systemctl stop filebeat
и

# sudo filebeat -e -c /etc/filebeat/filebeat.yml

если он не напишет что 
Exiting: Failed to start crawler: creating module reloader failed: could not create module registry for filesets: error unpacking module config :error creating config from fileset nginx/access: error unpacking configuration

pзначит чвсе окей. 
иначе у тебя ориибка в конфиге модуля 




проверить что ест связь с эластиком
# filebeat test output
elasticsearch: http://10.113.151.1:5080/api/default/...
  parse url... OK
  connection...
    parse host... OK
    dns lookup... OK
    addresses: 10.113.151.1
    dial up... OK
  TLS... WARN secure connection disabled
  talk to server... OK
  version: 8.9.0


запускаем айлбит

# systemctl start filebeat
и нао чуть подождить. он падает не сразу
проверяем

# jouralctl -f -u filebeat



дефолтовый частоат  с которой он проверяет файлы логов это 10с.
настраивается через scan_frequency



прописать  путь к модуля иначе их не актививровать
# cat filebeat.yml

filebeat.config.modules:
  path: ${path.config}/modules.d/*.yml

  reload.enabled: false


после этго можно активовть модуль

# filebeat modules enable  elasticsearch



как выгддяит как пример конфиг модуля nginx

.d# cat /etc/filebeat/modules.d/nginx.yml 
- module: nginx
  access:
    enabled: true
    var.paths:     
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/access.log"
        - "/home/magento/magento2-sandbox.magestage.net/log/access.log"


  error:
    enabled: true
    var.paths:  
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/error.log"
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/error.log"


  ingress_controller:
    enabled: false
    #var.paths:


 важно отметть      что  как я пути прописал. 
 это очен удобно. только надо кавычки ставить чтобы не было ошибоок!
 





===


| SUID
| SGID

во первых в целом про классические file permisons в линуксе (далее просто пермишнс).
для каждого файла этот пермишнс по длинее составляет 3бита*4=12бит
в каждой тройке быты отвеча за разрешение на чтеиние+запись+исполнение=rwx
одна тройка откчает за пермишнсы для владельца обьекта, вторая зя пермишнсы
для группы владельца обьекта и третья тройка битов оотвечате за преминсы для всех остальных
кто полезет к обьекту. четверткая тройка битов имеет особые значения - один бит
отвечает за SUID признак, второй за SGID признак и третий бит за признак "sticky бит".

начнем с SUID бита. что это такое . за что он отвечает что дает.
соглаасно wiki SUID пеерводится как SetUID. забегая вперед скажу что 
сейчас мы говорим про некие атрибуты файла. а далее мы будем говорить о атрибутах запущеного
процесса и у неготоже есть атрибут SUID но он переводится совершенно по другому тоест
это совершенно другой обьект и переводится он как SavedUID но сокращенно выглядит точно
также SUID. итак возвращаемся к файлу , что такое SetUID флаг.
этот бит он как бы устанавливает UID.
что такое UID куда он его устанавливает  и с чем это все едят. Если у файла установлен
бит x скажем для владеьца файла то такой файл разршено "исполнять" . пускай это ELF файл
по своему типу. так вот мы в командной строке указываем путь к файлу и баш вызовет сисколл
который загрузит тело файла в оперативку и передаст на исполнение код этого файла. так вот
у нас возникнет родится новый процесс в системе.  и для этого процесса ядро создаст 
три атрибута UID(EUID), RUID, SUID.

RUID - это id юзера который запустил этот процесс. 
UID или EUID (что одно и тоже) - это id юзера который показывает что этот процессу 
можно делать какими полномочиями этот процесс обладает. именно UID/EUID используется
ядром для сравнения чего хочет сделать процесс с тем что ему позволено делать.

тут надо сказать то что в самом простом случае когда у нас линукс создал процесс по нашму
запросу из файла то у этого процесса RUID=UID\EUID то есть процесс в баше запустил вася
и процесс обладает прававми васи. все красиво логично и просто. более того внезавимости 
от того кто владелец файла процесс будет иметь тот UID который юзер запустил этот файл.
тоесть скажем файл /bin/ex1 его владелец root.root  и сидит вася в баше и тыкает 
этот файл и процесс будет создан с UID=vasya а не с UID=root . потому что вобще то действительно есть фундаментальный вопрос - если мы создаем процесс из файла то какой
UID должен иметь этот процесс? и логичный ответ UID должен быть того юзера который
этот файл запускает. чтобы непривилигорованный юзер мог создаваь только непривилигированные
процессы. тоесть обратим внимание на очень интересуную вещь у нас есть обьект файл и у нас
есть обьект процесс. в целом это две разные несвязанные сущности. у процесса есть UID 
этот UID обозначает какие действия может делать этот процесс в системе.  UID у процесса как бы выражает владельца этого процесса.
у файла тоже есть  владалец у которого есть UID. и этот UID для файла регулирует кто с этим
файлом может менять его содержимое. а теперь фундаментальный вопрос  вася тыкает на файл
у которого владелец петя - тогда какой UID надо присобачивать для процесса который сделан
на основе этого файла?ну и как я уже сказал при создании процесса на основе файла 
плевать кто владелец файла какой UID у владельца файла - новый процесс будет иметь UID 
ттого юзера который тыкнул на этот файл. поэтому нам обычно плевать кто создал файл
и кто его владелец ибо это влияет только на то кто может редактировать тело файла на диске
и UID процесса обычно зависит совсем от друогого - кто запустил файл. итак есть UID у файла
который регулирует кто может редактировать тело файла.  и есть UID у процесса который
обозначает полномочия этого процесса тоесть что этот процесс может или неможет делать 
в системе.  файл похож на рецепт торта. а процесс похож на повара который готовит этот торт.
так вот рецепт мог написать один и только ему разрешено менять этот рецепт. а готовить 
по рецепту может уже другой еинственное что еще вопрос разрешит ли системе готовить
этому другому этот торт в данном конкретном случае.  итак у нас есть вася который 
имеет UID=123 и он запустил файл и создался процесс и обычно по деолфту ядро создат процесс
с 

UID/EUID=123
RUID=123
SUID=123

RUID - показывает кто создавал процесс. кто тыкнул на файл
UID\EUID- показывает что этому процессу разрешено делать. именно с этим полем ядро всегда
сравнивает что процесс хочет делать с тем что ему разрешено.
SUID- это некое предыдущее значение UID. об этом позже.


спрашивается нахера иметь три сущности UID\RUID\SUID. почему не завсети одну.
ответ такой что когда процесс работает то он с помощью сисколлов может менять эти атрибуты.
например процесс может поменять UID налету. скажем схема такая. сидит root и он 
запустил процесс через файл. процсс запустился он имеет UID=0 и этот процесс имеет
типа неограниченные права. он выполянет какието привилигированные операции а дальше
ему уже ненужно иметь такие мощные права и тогда процесс взывает сисколл и просит у ядра
изменить UID на какйото котоый имеет уже минимальные права скажем UID=100500
и тогда ядро меняет UID у процесса и с точки зранеия безопаснтсти это очень хорошо
потому что и сам процесс если код криовй неможет ничего сломать ни какойнибудь взломщик
который както влез в этот процесс неможет через него чтото поломать в системе. 
так вот перехожу к SUID что если мы в работющем процессе через сисколл сменили UID то
преыдудщее значение UID будет засунуто забэкаплено в SUID. зачем так делают об этом ниже
но кратно затем что в ряде случаев ядро позволит процессу еще раз поменять UID но не на произвольный а только на тот кооторый в SUID. но об этом ниже. возгкает вопрос а какой 
SUID на стадии когда мы только запустили процесс ведь никаокго предыдущего занчение в UID еще не было. ответ такой что на старте прцоессе SUID=UID.
также вопрос а можно ли сменить RUID - ведь по идее он ранит инфо кто запутил процесс.
если мы сменим RUID то как бы теряется смысла этого поля. пока что навскидку я вижу что 
RUID все время остается один и тот же но это не точно это надо проверять. там ниже я покажу
как эти атрибуты менятся на лету.

переходим к SUID биту атрибуту у файла. переводится SetUID. (не путать с SUID атрибутом
процесса. suid файла и suid процесса это разные хрени и относятся они к разным обьектам в том числе). так вот SUID файла он не имеет отношения к разграничению прав кто и что может делать
с телом файла. этот атрибут показывает что если файл запустил петя а владельцем файла
укзаан root то процесс должен быть создан с UID=root. таикм образом если у файла выставлен
SUID атрибут то при создании процесса уже играет роялт не кто этт файл тыкнул а кто его 
владелец. 

@@@@ закончил тут

простой юзери будучи вдаледбецем файла неможет сменить его владельца. но может менять
chmod. и может добавить SUID бит. в баше файлы с SUID битом подсвечиваются красным.
если бы юзер мог менять влаеднца на рут. то он мог бы записать в файл любой вредный код.
потом снметьи воадедьца на root. потом преилеить SUID бит и заустит этот код от рута.
кто может выставлять SUID бит?
на скрипты этот бит нерабтает. кроме bash -p ?
прикол sudo touch > 1.txt создаст файл с владельцем vasya! а не root
и только sudo bash && touch 2.txt создаст файл с владельцем root. это прикол
что еще я воде выяснмил из практики. если на файле стоит  даже 777 то менять 
его атрибуты может толкьо владелец. (может еще ктото из группы - проверял). но не лбой
юзер. даже если стоит 777. тоесть премишнсы к файлу опсывают что можно делать внути
файла с его телом. но не с его атрибутами внешними. также прикольно то что вот у нас
есть на папку влаледец вася. он в папке может делать что хочет. в этой папке root
создает файл с влаледльцем root и 777. вася неможет менять пермишнсы на файле. 
но он может его удалить из этой папки. потому что право удалить файл прописывается не 
в пермишнсах файла а в пермищнсах папки в которйо лежит файл. 
таким оюрахлм на самом деел файл как бы имеет три сферы разнымх перминсов:
- кто может мождицифицировать тело файла
- кто может удалять файла
- кто может модициифровать атрибуты его тела 
это разные пермищнсы они просываются в разных местах. и это тоже прикол.
также перминс о том кто может запускать этот файл (x) пропсиыватся в пермишнсах тела файла.










shared librru suid  = гнихуя не дает
suid н файл - в процессах все равно сказано что запустл вася
SGID на папку дает что фалы будет создваны с группой папки алвдедькца
а SUID на папку нихуя не даст

suid на pipg - нахйуй?
suid на симлинк что дает ?

rwsrw-r-x – SUID bit set and the binary is executable
rwSrw-r-x – SUID bit set and the binary is not executable


When you run a SUID bit enabled file, it is being executed with the user-id current user but with an effective id of the owner of that file.
это реьный прикол. файл будео в прцоессах запущен от васи но по факту он буедт 
работать по рутом. это пздц.

The SUID bit is ignored in most of the Unix/Linux so it will not affect the files you create in the directory. But when you set the SGID bit on the directory and then create a file inside it, the group of the new files will be the same as the group of directories.

$ chmod g+s,o+rwx mydir
$ stat -c "%A %n" mydir
drwxr-srwx mydir

при смене владедьца файла через chown SUID бит автоматом сбратсывается\убирается.
и его надо заново активировать!

rwSrw-r-x = вот это означает что SUID усановлен но x бит не устанволен
а 
rwsrw-r-x = это ознаает что и x и suid биты устаовлены


bash скрипы и вообще все файлы кооыер исполнятся интрепреторрами на них suid бит
недействуеи . почему? вот статяь https://unix.stackexchange.com/questions/364/allow-setuid-on-shell-scripts



lsof показывает параметры заущенных процесоов. он берет это из proc.
поэтому можно идти в proc и там все увидеть либо смоетреть через lsof
lsof это некий фронтед визуализатор для /proc/$PID папки



$  sudo lsof -p  32145   2>/dev/null
COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
ping    32145 vasya  cwd    DIR  259,2     4096 24909215 /home/vasya
ping    32145 vasya  rtd    DIR  259,2     4096        2 /
ping    32145 vasya  txt    REG  259,2    64424 25690241 /bin/ping
ping    32145 vasya  mem    REG  259,2 10281936 23337573 /usr/lib/locale/locale-archive
ping    32145 vasya  mem    REG  259,2   144976 13250066 /lib/x86_64-linux-gnu/libpthread-2.27.so
ping    32145 vasya  mem    REG  259,2    14560 13250054 /lib/x86_64-linux-gnu/libdl-2.27.so
ping    32145 vasya  mem    REG  259,2  2030928 13250051 /lib/x86_64-linux-gnu/libc-2.27.so
ping    32145 vasya  mem    REG  259,2    97072 13250067 /lib/x86_64-linux-gnu/libresolv-2.27.so
ping    32145 vasya  mem    REG  259,2   219304 23339395 /usr/lib/x86_64-linux-gnu/libnettle.so.6.5
ping    32145 vasya  mem    REG  259,2   206872 13243527 /lib/x86_64-linux-gnu/libidn.so.11.6.16
ping    32145 vasya  mem    REG  259,2    22768 13243485 /lib/x86_64-linux-gnu/libcap.so.2.25
ping    32145 vasya  mem    REG  259,2    26616 23343542 /usr/lib/x86_64-linux-gnu/libgtk3-nocsd.so.0
ping    32145 vasya  mem    REG  259,2   179152 13245746 /lib/x86_64-linux-gnu/ld-2.27.so
ping    32145 vasya    0u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    1u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    2u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    3u   raw             0t0  1576046 00000000:0001->00000000:0000 st=07
ping    32145 vasya    4u  raw6             0t0  1576048 00000000000000000000000000000000:003A->00000000000000000000000000000000:0000 st=07



$ sudo ls -1al /proc/32145/fd
total 0
dr-x------ 2 root  root   0 июл 30 18:19 .
dr-xr-xr-x 9 vasya vasya  0 июл 30 18:18 ..
lrwx------ 1 root  root  64 июл 30 18:19 0 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 1 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 2 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 3 -> 'socket:[1576046]'
lrwx------ 1 root  root  64 июл 30 18:19 4 -> 'socket:[1576048]'


видно что пинг процесс имеет открытыми два файла которые сокеты. 

тепрь понятна фраза что пинг открыает два raw сокета. по факту это озрнчает что
он делает сисколлыы которые ему открывают два файла которые на бекенде ведут в ядро в сокеты.
и видимо этот сисколл может делать только процесс от рута.

что странно - без SUID  пинг пошлет нахер
$ stat ./ping
  File: ./ping
  Size: 64424     	Blocks: 128        IO Block: 4096   regular file
Device: 10302h/66306d	Inode: 10095974    Links: 1
Access: (0755/-rwxr-xr-x)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-07-30 17:57:55.329820506 +0600
Modify: 2023-07-30 17:53:59.694022907 +0600
Change: 2023-07-30 17:57:41.981829605 +0600
 Birth: -
[vasya@lenovo #7]$ ./ping -c 3 8.8.8.8
ping: socket: Operation not permitted

если же запускаем ping с SUID
$ stat /bin/ping
  File: /bin/ping
  Size: 64424     	Blocks: 128        IO Block: 4096   regular file
Device: 10302h/66306d	Inode: 25690241    Links: 1
Access: (4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)

то видно что ни uid ни euid абсолютно не равны root !!!!
$ ps -p 12226  -o pid,uid,euid,cmd
  PID   UID  EUID CMD
12226  1000  1000 ping 8.8.8.8

и это я понять не могу.!
может этот пинг он стартует. открыает сокет. потом содает форк непривлигированный а 
потом сам себя киляет ??

я запустил ручную  c программу и она в итоге ее процесс имеет UID=65534 (nobody)
как это происходит на уровне сисколлов непонятно птому что при запуске ее
через strace она запускается под васей. 


systemtap - но под нее надо там мудить чтобы она заработалал



ruid = тот кто запустил
uid=euid= какие права у процесса
suid = хранит предыдущий uid

вот эта стаьья = https://www.osso.nl/blog/setuid-seteuid-uid-euid/

и поэтому наступила разгадка насчет пинга. я четко установил вот что :
если у нас у файла владелец "UID=vasya, GID=pupkin"и у файла установлен бит SUID
то 100% процесс будет запущен так что  ps покажет что UID=vasya (вне зависимости от 
того какой юзер из своей консоли нажал на этот файл) тоест например

сидит у на петя в своей консоли 

(petya) $ ./file

то процесс в ps буде виден как 

UID      COMMAND
vasya    ./file


соотвесвтенно если файло владеет root  и запускает его petya то ps покажет что 

UID    COMMAND
root   ./file


теперь я возвращаюсь к конкретному примеру программа ping
у нее владелец root и  SUID установлен .
это значит что если простой юзер запускает команду ping то она вобще то 
должна в ps быть показано что ее UID=root 
однако этого не происходит. потому что как я полагаю что тут уже другой момент.
когда пинг запустился то он реально работает а UID=root
под ним он открыает сокеты. а потом уже ему ненадо иметь такие права
и он сам запускает сисколл наример setuid и понижает права до простого юзера. 
вот и разгадка. именно поэтому мы видим в ps что пинг работает под простым юзером а не root.
вот она разгадка!!

что еще примечательно из второстепенного что поле UID в ps это не юзер который запустил
программу! нет! это показаны эффективные права процесса. тоесть UID это тоже самое что EUID.
а поле которое показыает кто запустил команду это RUID
а есть еще поле SUID. и в ps это совсем не бит SUID. нет. это показан так называемый
saved uid - предыдущее значение uid в случае если процесс в ходе своей работы через сисколлы
постоянно меняет uid. 

это дает еще доп интересный вывод что вот мы смотрим ps -p $PID
и видим некоторый UID. так вот так как процесс может его менять то соверешенно не факт 
что этот же самый процесс чере 10 минут покажет тот же самый UID в ps


| samba
| smb

отлчная стаять я как быстро настроить samba сервер.
чтобы потом можно быо к нему под виндой зайти

https://linuxize.com/post/how-to-install-and-configure-samba-on-ubuntu-18-04/






| nmap
| scan

как быстро найти все хосты в сети LAN

$ nmap -sn 192.168.0.0/24




| openssl

как зашифровать симметрично пароль

  $ printf 'пароль' | openssl enc  -aes-256-cbc    -e -v -a -pbkdf2 -salt  -md md5 -base64
на счет того как зашифровать файл
  $ cat 1.txt | openssl enc  -aes-256-cbc    -e  -v -a -pbkdf2 -salt  -md md5 -base64 > 1.aes
 
(на счет использования echo вместо printf то тоже конечно можно, причем
я проверил что echo можно использовать но надо помнить что echo добавляем на конце
автоатом символ 0x0a. но я проверил что разницы никакой что заппустить echo "" или
echo -n "" . в обоих случаях расшифровка идет без проблем. но просто применение
printf дает более предасказуемое поведение. если мы в нем неуказали "\n" то принтф
его добавляеть не будет)

но чтобы не палить пароль с клавиатуры в истории баша  то лучше запускать вот так

 $ read  -e -s var1  &&  printf "%s" "$var1" | openssl enc  -aes-256-cbc    -e -v -a -pbkdf2 -salt  -md md5 -base64


также тут хочу заметить про ЕБАНУТОСТЬ printf если в си он имеет формат

	printf ("%s", var1)

то /usr/bin/printf имеет СОВЕРШЕННО ДРУГОЙ ФОРМАТ

	printf "%s"  "$var1"

окей openssl программа отработала. мы получили на экране хеш

	U2FsdGVkX18bnRrj/JWlOAIVtovuEZ/thRmNVh/ta28=

ДАЛЬШЕ ВАЖНЫЙ ПРИКОЛ  вот этот хеш его для расшифровки в openssl нужно передавать
ОБЯЗАТЕЛЬНО с символом "\n"  на конце! иначе тебя openssl пошлет нахер выдав ошибку
	
		error reading input file 

это просто пздц


РАСШИФРОВКА идет ровно также как зашифровака только нужно ключ -e (encrypt)
заменить на -d (decrypt)

 $ var1='U2FsdGVkX18bnRrj/JWlOAIVtovuEZ/thRmNVh/ta28='
 $ printf "%s\n" "$var1" | openssl enc  -aes-256-cbc    -d  -a -pbkdf2 -salt  -md md5 -base64

расшифровать файл
 $ cat 1.aes | openssl enc  -aes-256-cbc    -d  -v -a -pbkdf2 -salt  -md md5 -base64 > 1.txt

еще раз обязательно обращаю внимание чтобы успешно расшифровать то
нужно /usr/bin/printf обязательно использовать с "\n" иначе openssl пошлет нахер

	printf "%s\n" "$var1"
            /\
            ||
            ||
             \\ 
               вот этот символ "\n" обязателен при расшифровке добавлять
               иначе будет openssl пошлет с ошибкой  "error reading input file"





 

| screen

как сделать так чтобы скроллинг экрана по колесу мыши работал
надо создать файл

~/.screenrc

$ cat .screenrc 
termcapinfo xterm* ti@:te@


| 1900
| udp 1900
| upnp
| ssdp

в логах journactl , ufw видно что посылаются пакеты на udp 1900 239.255.255.255 
это ssdp или upnp

как это откчлюить хрен знает.
в интете пишут что надо остановить avahi.
я останвил толку никакого


| systemctl

если netstat -tnlp покываезывает сокеты которые слушаются непонятно кем
то значит его слушает systemd
получить детали можно через

# systemctl list-sockets


| nologin 

man 5  nologin

там написано что если мы хотим временно заприть на комп любых юзеров
ккроме root ( я сам не проверял). непонятно по ssh тоже нельзя будет зайти?
для этого надо создвать файл /etc/nologin


| sudo 

ключ -i дает то что будет запущен шелл который указан в /etc/password также будет выполннны файлы .login
и .profile  , если же еше при этом указать команду то она будет запушена в этом шелле. команда будет 
передана в шеел через  ключ -c. , тоесть sudo -i это как бы эктватлент sudo -i bash
а sudo -i  sleep 130 это как бы экваилваент sudo -i bash -c "sleep 130"
так что меня удивило.  если "sudo -i  sleep 130" запускает баш с ключом -с то тогда должна образоваться цепочка процессов.
тоесть sudo -- bash - sleep
но этого не вижу. я вижу только такую цепочку процессов
    sudo -- sleep
непонянтно

| rpcbind
по моему эта служба нужна когда ставии samba



| dbus

я заметил  в top что висела какая хуйня goa*daemon
короче оказалось что gnome через dbus запускает кучу всякой ненужной хуйни как это еть
для примера  виндовсе. где миллион наху ненйжунжных сервисов. 
я все этонаухйу отклчил. для этого смотрим через 

    # journalctl -f что там запускается 
потом идем в 

    /usr/share/dbus-1/services

и там комментируем все мусорные сервисы

также можно посмотреть что замусор запускается через 
# systemctl status dbus

пиздец 

ксатаи dbus его не перезапустить. потому что как я нашел в интете
это IPC механизм и пэтому пошелу нхуй. тлько перезарузка. 
камнный век.

| top

запустить так чтобы он показывал треды

$ top -H

сделать так чтобы он покзаывал только процессы 
со статуом R

тыкаем Shift+o и вводим S=R

профит!

если тыкнуть 'f' появится окное где можно добавлять поля что показывать



| tmux

как сделать так чтобы у него работала прокрутка буфера 
через мышку


$ cat ~/.tmux.conf 
set -g mouse on


и обязатлно грохнуть его надо 

 exit tmux
$ tmux kill-server
$ tmux


кстати чтобы не ебаться с кнопками экран разделить можно без кнопок. достаточно нажать правую 
кнопку мыши вылезает меню. и там можно выбрать как разрезать экран вертикально или горизонтально.

однако  tmux это ебаный кусок говна там по дефолту нет базового функционала,
там нет возможсности скопироовать хоть чтото в буфер. для этого надо поставить tmux plugin manager 
(его можнайти в apt-cache)  а дальше все что написано в инете неработает. так что нахуй этот супе
инсурмент. долбоебы.



| hyper-threading

одно ядро такое виртуально дает двадцать процентов скрости 
всего лишь тоесть реальное ядро дает 




| lxqt
| keyboard layout
| layout


это какая то ебаная пизда. относительно русского языка. 
у нас есть lxqt хуй знает что это грубо говоря графическая оболочка. так вот в ней охуеть чтобы
настроить руские буквы. это касается всех графических программ. например текстовыый редактор Feather
или терминал qterminal. формально настройки руского языка вот здесь - "prefrences" - "lxqt settings" - "keyboard"
там предлагается целый рой типа руских клавиатур но прикол в том что сука ни одна из них не дает кнопки 
так как надо . а именно при нажатии на  "." ту кнопку которая правее кнопки "ю" мы вместо точки сука получаем
букву "ё" это пиздец. 
значит истоия темная я нихуя не понимаю. казалось бы есть та сама сраная locale. но хуй там. есть еще 
keyboard layout. вот сука только они вместе дают руские буквы. значит через графическую утоиту я так и несмог
настроить. более того она сука меняет конф файлы правильные так что работающая клава становистя опять не работающйе.
в итоге - я даю набор конф  файлов если их сука сменить то будут руские буквы.

вот эта хуета дает руские буквы в консоли линукса tty*
между прочим это совершенно отдельная хуета по сравнению с qterminal и всеми 
приложениями работающими когда заупстили граф оболочку.
онадает руские буквы и переключение ммежду ними через Ctrl+Shift

$ cat /etc/default/keyboard 
# KEYBOARD CONFIGURATION FILE

# Consult the keyboard(5) manual page.

XKBMODEL="pc105"
XKBLAYOUT="us,ru"
XKBVARIANT=","
XKBOPTIONS="grp:ctrl_shift_toggle"
BACKSPACE="guess"


$ cat ~/.config/lxqt/lxqt-config-locale.conf 
[General]
__userfile__=true

[Formats]
LANG=ru_RU.UTF-8


и вот это самый важный файл сука. 
чтобы lxqt его не меняла на него надо постваить владельца root

$ cat ~/.config/lxqt/session.conf 
[General]
__userfile__=true

[Environment]
BROWSER=firefox
GTK_CSD=0
GTK_OVERLAY_SCROLLING=0
LANG=en_US.UTF-8
LANGUAGE=en_US
LC_ADDRESS=ru_RU.UTF-8
LC_COLLATE=en_US.UTF-8
LC_CTYPE=en_US.UTF-8
LC_IDENTIFICATION=ru_RU.UTF-8
LC_MEASUREMENT=ru_RU.UTF-8
LC_MESSAGES=en_US.UTF-8
LC_MONETARY=ru_RU.UTF-8
LC_NAME=ru_RU.UTF-8
LC_NUMERIC=ru_RU.UTF-8
LC_PAPER=ru_RU.UTF-8
LC_TELEPHONE=ru_RU.UTF-8
LC_TIME=ru_RU.UTF-8
SAL_USE_VCLPLUGIN=qt5
SAL_VCL_QT5_USE_CAIRO=true
TERM=qterminal

[Keyboard]
layout="us,ru"
model=pc105
options=grp:ctrl_shift_toggle
variant=","


причем вот эта секция самая важная
[Keyboard]
layout="us,ru"
model=pc105
options=grp:ctrl_shift_toggle
variant=","

а в ней самая важная вот эта сторчка
variant=","

без всего этого руские буквы в lxqt нихуя работать как над не будут.
часть кнопок будет работаьт а часть будет выдавать полную хуету.

вот и все.  почему это так хуй знает. это чисто решение конечное.

вот  еще команда чтобы на лету поменять на одну сессию графическую

$ setxkbmap "-model"  "pc105"  "-layout"  "us,ru"  "-variant"  ","  "-option"  "grp:ctrl_shift_toggle"

если все верно настроно то вот так должно выдавать
$ setxkbmap -query
rules:      evdev
model:      pc105
layout:     us,ru
variant:    ,
options:    grp:ctrl_shift_toggle

суки падля блять. как обычно все понамуттили и понамудили.


===============================
| systemd
| systemctl

сервис я написал 

$ cat acpi-wake.service 
[Unit]
Description=ACPI Wake Service
Before=sleep.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c "for i in $(cat /proc/acpi/wakeup| grep enabled| awk '{print $1}'| xargs); do [ $i != PBTN ] && echo $i| tee /proc/acpi/wakeup; done"


[Install]
WantedBy=sleep.target
[vasya@lenovo system]$ 


он запускается если пере запускаом сеорвиса sleep.target
это значит то что если я загоняю комп в сон через кнопку sleep в интерфейсе или через 
    $ systrmctl sleep (чтото типа того)
то этот сервис отработает

а если загоняю комп в сон через 
    $ sudo  pm-suspend
то мой сервис КОНЕЧНО не отрабатывает. 
=======================================


| w

интерсная команда
столбик FROM  в нем указано с какого IP зашли на комп.

Как прога определяет это я не знаю.



| ufw

ключ --dry-run

    $ ufw  allow in on docker0 proto tcp from 172.17.0.0/24 to  172.17.0.1 port 22 comment SSH
(всегда можно постмреть в man ufw)


| tmux

в чем прикол оказывается этой прги это то что она также как и команда screen призакрытти окна (сигнал HUP)
все равно проодолжает работать в памтяти. 

как можно это легко определить. набиарем команду 
    $ w
    или
    $ who
и там будет в списке куча tmux

как посмтреть список сессия 
    $ tmux ls

как подколчиться к сесссиии

    $ tmux  attach -d -t номер_сессии

    
    
| iphone
| apple

как подключив по usb проводу к компу увидеть фотки с телефона в форме папки на компе ?

    $ sudo apt-get install idevicepair
    $ sudo apt-get install ifuse

    $ sudo idevicepair pair

    $ mkdir ~/iphone && ifuse  ~/iphone

на экране инфона выскочит предлжоние ввести пароль

перед тем как выдернуть ифон из компа нужно оего отмонтировать

    $ sudo umount ~/iphone
    
иначе если повтом воткнуть обратно и подмонтровать то в папку бует не войти

что характеретно монтрование ifuse ~/iphone идет от имени простго юзера
а вот отмонтироовать можн тоько под рутом   sudo umount ~/iphone

=====

| mouse
| pointer
| usb
| touchpad
| synaptics


как программмно отключить тачпад синаптикс в линукс

    $ xinput list

    ⎡ Virtual core pointer                          id=2    [master pointer  (3)]
⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]
⎜   ↳ SynPS/2 Synaptics TouchPad                id=12   [slave  pointer  (2)]
⎣ Virtual core keyboard                         id=3    [master keyboard (2)]
    ↳ Virtual core XTEST keyboard               id=5    [slave  keyboard (3)]
    ↳ Power Button                              id=6    [slave  keyboard (3)]
    ↳ Video Bus                                 id=7    [slave  keyboard (3)]
    
    
    
    $ xinput --disable 12



===
| proc

оказыается в /proc можно для прцоесса увидеть его env переменные окружения
	$ cat /proc/self/environ 
CLUTTER_IM_MODULE=ximLS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st...



===
| grep 
| Binary file (standard input) matches

кстати прикол 

$ cat /proc/self/environ | grep -i bash
Binary file (standard input) matches

греп почемуто думает что ему подсунули бинарник.
окей копирую файл на диск

$ cat /proc/self/environ > /tmp/1.txt
$ grep BASH < /tmp/1.txt
Binary file (standard input) matches
Binary file (standard input) matches

я лезу в файл может там вначале какието непечатные символы. да нет.
 все ок. 

в итоге заставил греп прочитать файл ччерез ключ -a (который как бы говорит неважно 
что по твоему мнению файл бинарный читай ) и сработало














| hyper-threading


так меня задолбало то что вопрос про гипертердинг висит все это время
непонятным. в инете много хуйни бесполезной написано. 

раньше я думал что когда мы включаем гипертрединг это значит что внтри цпу помимо
полноценного ядра включается ядро уродец. которое по тем или иным причинам 
работает медленнее. 

это все оказалась полная хуйня.

на самом деле вот что происходит - ядро цпу имеет разные компоненты. которые
делают свою часть работы. так вот создатели гипертрединга взяли и продублировали
часть этих компонентов. причем не те запчасти которые обрабатывают данные в конце
процесса обработки а те части которые занимаются обработкой данных вначале процесса.
условно говоря есть почта у нее есть конвейерная лента куда валсять письма ,
есть приемные лотки. есть заезд для машины. а на конце лотка стоят люди которые
письма сортируют. так вот людей они оставили сколько и было они число лотков и лент
увеличили. или как в магазине есть три кассы и есть дорожки ведущие к кассе. так вот
число касс осталось прежним увеличилось число дорожек к кассам. как пишут в инете
увеличилась "фронтенд" часть обработки потока в таких цпу. а бекенд остался таким
как и был. такой который может обрабатывать только один поток. давайте скажем 
даже так - касса и кассирша как была одна так и оасталась одна. увеличилось лишь
число дорожек к кней.  поэтому при включении гипер трединга у нас просто напросто
активируется дополнительная дорожка к касссе. кажждое ядро это дорожка. поэтому 
после активации гипертреднига КАЖДОЕ "ядро" АБСОЛЮТНО ИДЕНТИЧНОЕ С ДРУГИМ ЯДРОМ.
тоесть нет никакой разницы в какое ядро попадет код. никаких преимуществ одной
доорожки над другой нет. поэтому мое предположение что одно ядро правильное а второе
каличеное - это все неверно. просто теперь команды из двух дороже делят вместе 
одну кассиршу. вот и все. поэтому код который попал на первое ядро или на второе
обрабатывается аболютно с одной и той же скоростью при условии что на втором ядре
нет команд и касса свободна!!! тоесть если  у нас есть два ядра. цпу с гипертредингом.
однопотончое приложение. если мы поместим его наодно ядро померяем скорость.
потом поместим на другое ядро и померяем сокрость - то время выпоенеия будет АБСОЛЮТНО
ОДНО И ТОЖЕ. !!!!!  единственное на что влияет гипертрединг это если мы засунем
код и на одно ядро(дорожку) и на другое ядро то они будут друг другу мешать 
конкурируя за кассиршу. чтобы она обслуживала именно их  дорожку! 
тоесть положим у нас два ядра. на каждом есть гипертрединг. значит у нас два ядра
превращаюьтся в 4 гипертрединг ядра. пусть у нас прогорамма двух поточная.
если мы зансуем один поток на одно физ ядро а второй поток на другое физ ядро
то код из кажого потока будет иметь свою персональную кассиршу. 
скорост будем максимальная. а если мы засунем оба треда на два ядра которые 
сидят на одном физ цпу то оба этих треда будут друг другу мешать потому что на выходе
их будет обслуживать всего одна кассирша! вот и вся технология гипетрединга!
 
поэтому включении гипертрединга нет "нормалтных" ядер   и "неполноценных гипертрединг" ядер.
они все одинаковые!!!! просто надо понимать что если ядра сидят на одном физ чипе
то код в этих ядрах будет мешать друг другу. тоесть в таком случае оба ядра станут 
"работать" медленнее.  это можно еще так предтсавить. у нас есть рукав который в итоге
выходит на дырку. и естт второй рукав который выходит на туже дырку. если мы будем лить
воду только в один рукав то дырка будет обеспечивать выливание воды толко для этого
рукава. скорость протекания  воды по рукаву будет X, если же мы начнем лить воду 
и во второй рукав то теерь дырка обесепечивает проход воды от двух рукававов. через саму
дырку поток выливания не изменился но в кажодм рукаве скорость истекания воды в обоих 
станет меньше ! пожтому в этом плане каждый рукав такой же как его сосед. они друг
другу мешают.  нет такого что один рукав более скоростной. а второй мнее скоростной.
они пропускают воду одинакоово. но если воду прекратить лиить в один рукав то во второй
сразу вода потеечет быстрее. тоесть при гимртрединге включенном все ядра одинаковые
котоыре сидят на физ чипе. если их оба одновременно нагузить работой они будут 
рабать одинаково с соседом по скорости. но они будут работать медленнее чем они 
работали когда сосед им не мешал! вот суть гипертрединга!

как я примерно понял суть в том что вот эта вся бандура все эти системы внутри цпу 
настолко их много что конечный блок "кассирша" он нагружен далеко не всегда 
потому что от моммент пока данные попадут в цпу и до момоента когда их начнет
выполнять кассирша проходит дохрена времени. вот и решили давайте добавим доп ленту
загрузки данных. чтобы кассирша не простаивала. щас скажу конкретный пример который
я прочитал. у нас когда есть скажем две программы. то вот у нас отработала программа
свой слайс времени. тогда цпу берет все потроха от этой программы и начинает их выгружать
в память , потом он загружает шедулер. потом шедулер загружает из памяти потроха второй
программы. и только потом запускается исполнение второй программы. так вот во время
выгрузки и загрузки потрохов процессов как я понимаю касссирша в это время нихрена
неделает. и если в этот момент у нас есть уже готовые данные на второй ленте
то они в этот момент могут исполняться на кассе. тоесть процесс context switching 
занимает время и наверное немалое. поэтому если у нас есть вторая лента на которой
уже весь контекст (потроха) процесса уже загружены то они могут загружать кассиршу
в это время! гипертрединг это грубо говоря второй набор регистров. а арифметическая
часть осталось по прежнему в одном экземпляре. получатся что скажем загрузит из 
памяти данные в регистры или выгрузить из регистра в память(а это очень долгая
операция ) это можно теперь делать 
в двойном размере. скажем скопировать из одного регистра в другой можно тепер делать
в двойном размере. может с битами в регистре можно тоже делать без участия 
арифметичского модуля. а скажем делать сложение двух регистров можно делать только 
спомощью арифм модуля. в общем получается что есть ряд операций в цпу которые 
составляют часть исполнения кода программы но они нетребуют участия кассиршы. поэтому
их удвоение дает эффект укорения обьема выполняемго кода на компе в целом. я вот говорю
записать из памяти в регистр или выгрузить из регистра в память это нужная операция 
частая операция и она очень медленная делать ее надо ? надо. и в это время кассирша 
(арифм блок) тупо простаивает поэтмоу добвление второго набора общих регистров 
дает возможность загружать кассиршу доп работой. что дает в общем на компе 
где дохрена тредов ждет своего исполнения эффект увеличения выполненной сумарно
работы за секунду времени! например физические интеррапты их хендлеры. они имеют
очень маленктйи обьем исполнения. но они очень часто вызываются. поэтому цпу 
постоянно дергается этими кусками кода. и приходится выгружать контекст потроха 
юзерского процесса в память. заггружать хендлер обработки скажем прилетевшего в сет
карточку пакета. а потом обратно загружать потроха юзерского процесса. 
вот в чем суть и как работает гипертрединг хрень.

а я думал что гипертрединг это когда у нас одно ядро "полноценное" а второе "каличное".
я примерно представлял так что да там есть конкуренция за какието микросхемы внутри
но  я себе представлял так - основое ядро имеет к этой кассе привлигированный доступ
а доп ядро уже допускается  к кассе по остаточному прицнипу. вот так я себе преставлял.
поэтому как конечный результат код который крутитсся на "полноценном" ядре он проска
каивает быстрее а код который попал на "каличное" ядро он проскакаивет медленнее.
это как в магазине есть две очередти вещущие в одну кассу. только первая очередь 
она блатная а вторая  обычная. поэтому люи из блатной очереи обслуживаются в первую
очередь а из простой очереди по остаточному приниципу. 

исходя из этого щас проделаем эксперименты. пробовать будем так. - берем архиватор 7za.
делаем его однопоточным. далее я берут один и тот же файл для сжатия. 
далее я запускаю одну копию сжатия на ядре на одном физ цпу а вторую копию на втором цпу.
у нас два потока две кассы. получу время сжатия файла. обе программы отработают одноврменно.
они друг другу не мешают. но главное я получу время. скажем 1 минута.
далее я засуну обе эти программы на ядра которые сидят на одном физ цпу. тогда
они станут друг другу мешать я доожен получить то что 
1) время сжатия в каждой программе будет одинаковое (тоесть ядра работают с одной скорсотью)
2) время сжатия будет  больше. птому что ядра друг другу мешали. тоесть скорость 
работы ядра когда ему не мешало второе ядро было больше чем скорость работы
ядра когда ему мешало второе ядро стало меньше. 

перед тем как начать эксперимент. хочу сказать про некотоую ебанутость команды 
taskset
у нее есть ключи. и обычно по логике ожидается что ты укаываешь ключ и потом числовое
значение ключа. потом еще ключ и потом еще числовое значение ключа.
но ТУУТ БДЯЛЯДБ НЕТАК!
у тасксет есть ключ -p он указыает с каким тредом (не процессом) мы хооотим иметь дело.
и есть ключ -c указывает на каких цпу мы разрешаем этому процессу чтобы щедулер его
туда пихал.  по логике ты думешь нутодга это надо вот так заускать

	$ taskset -c 1,5 -p 1234
тоесть на процессоарх 1,5 и треде 1234
но это нихуя не срабтает!
он выждаст ошибку
	taskset: failed to execute -p: No such file or directory
доблобеб

окзывается укаыаем ключи .  А УЖЕ ПОТОМ ИДУТ ЗНАЧЕНИЯ. это пздец.
вот синтсксис из мана
	  taskset [options] -p [mask] pid
ну нахуя было так делать дебтлы?

поэтому правильно будет вот так

	$ taskset -c  -p 1,5 1234


как узнать номера тредов у процесса c pid=23591 ?
вот так

$ ps -L -p 23591
  PID   LWP TTY          TIME CMD
23591 23591 pts/49   00:00:00 thread3.exe
23591 23592 pts/49   00:00:00 thread3.exe
23591 23593 pts/49   00:00:00 thread3.exe
23591 23594 pts/49   00:00:00 thread3.exe

LWP это номер треда. 
подробно про треды я буду говорить в "linux-general" ищи по шаблону "| thread"


также перед началом эксеримнтов как узнать конфигурцию ядер на компе. 
какие из них сидят на одном чипе. 
сделать это можно вот так

$ lscpu -p
# The following is the parsable format, which can be fed to other
# programs. Each different item in every column has an unique ID
# starting from zero.
# CPU,Core,Socket,Node,,L1d,L1i,L2,L3
0,0,0,0,,0,0,0,0
1,1,0,0,,1,1,1,0
2,2,0,0,,2,2,2,0
3,3,0,0,,3,3,3,0
4,0,0,0,,0,0,0,0
5,1,0,0,,1,1,1,0
6,2,0,0,,2,2,2,0
7,3,0,0,,3,3,3,0

второй столбик "Core" это значит физ ядро. из этой 
картинки следует что логические ядра "CPU" номер 0,4 сидят внутри одного физ ядра 0.
аналогично CPU 1,5 сидят внутри друого физ ядра 1.
сокет поняно это прям физ дырка на плате. Core я так понимаю обознаачается именно
физ ядро. поэтому все что сидит  внутри одного Core это гипер трединг ядра.
поэтому cpu 0,4 это гипетрединовые ядра. аналогично 1,5 тоже самое.

$ cat /sys/devices/system/cpu/cpu0/topology/core_cpus_list 
0,4



<>) запускаю один процесс(однопоточный) на одном физ ципе
второй процесс(однопоточный) запускаю на втором физ чипе

$ taskset -c 1  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=1 myarchive.7z ./100_9135.MOV
	2:43.22 real (163с)
$ taskset -c 2  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=1 myarchive2.7z ./100_9135.MOV 
    2:47.47 real (167с)

<>) теперь запукаю теже самые два процесса на одном физ чипе
$ taskset -c 1  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=1 myarchive.7z ./100_9135.MOV
	3:25.51 real  (205с)
$ taskset -c 5  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=1 myarchive2.7z ./100_9135.MOV 
    3:25.61 real  (205с)


и вот мы видим важные факту - оба ядра отработали одинаковый обьем работы 
за одно время. тоесть нет никаокго привилигированного ядра и каличного ядра.
они оба одинаковые. оба имеют одно и тоже право на кассу.
и то что они мешали друг другу и поэтому каждый из них отработал медленее
тот же самый обьем работы которые они делали в прошлый эксперимент. 

теперь вот что надо понять. в кажом эксперименте я сжимал два раза один и тот же 
файл. понятно что это могло быть две копии одного файла. так и представим. 
теперь вот что надо понять. положим у меня есть один физ чип. без гипертрединга. 
и мне на нем надо сжать два файла этих. если я запущу две эти программы на одном 
ядре (на ципе не активирован гипертрединг) то половину времени он будет обслуживать 
первую программу второую половину времени он будет осблуживать вторую программу.
и по идее он выполнит полную работу за (2*163 = 326с)
теперь положим я активирую гипертрединг на этом чипе. у нас появялется новая дорожка
к кассе. я запускаю две эти прграммы на этом чипе. и как мы видим этот же обьем
работы такой чип сделает за (205с) тоесть он ее сделает быстрее в 1.6 раза.
тоесть активация гипертрединга нам как бы добавила доп физ чип на скорости 0.6
от основного чипа. в какойто степени получается что активация гипертрединга
она делает нам число ядер больше но они становятся как бы "мельче" у них как 
бы понижается частота. потому что еси мы поделим 1.6 на 2 то мы получим 0.8 
одно ядро на скрости 0.8 и второе ядро на скорсти 0.8 от скорости того ядра
которое было до активации гипертрединга. получается интересная ситуация.
но суммарная мощность на компе поднимается. а ведь дейтсвтельно в целом
получается выбор именно такой - либо ты имеешь как бы на компе одно 
ядро на скорости 1 либо ты имеешь два ядра на скорости 0.8
что лучше? 
положим у нас на компе на старте есть один долгоиграющий процесс (типа архиватора на
2-3 минуты) и пять коротких процессов на 5-10с. если у нас гипертредигнг выключен
то они все будут друг другу мешать и они все отработают медленно. тоесть 
каждая программа покажет замедленный результат по сравеннеию если бы каждый из
этих прцоесов был запущен на пустом компе. если же у нас гипертрединг
активирован то долгий процесс будет работать в своей очеереди. а короткие процессы
мгновенно отсрреляются на второй очереди.  с точки зрения коротких программ они 
покажут время выполнения существенно ниже! щас прикинем.
вот у нас нет гипертрединга и 5 программ по 10с и одна на 3 минуты.
пусть у нас слайс времени это 1с. цпу имеет скорость 100%.
первая отработала 1с(ей осталось 9с). вторая - пятая в это время ждут у них тоже 1с в итоге простоя.(тоесть у них аптайм 1с и 10с еще выполняться).
потом вторая отработала 1с (у нее осталось 9с). при этом остальные стояли 1с . щас покажу 
на таблице. правда сделаю попроше. два процесса по 5с и один процесс на 10с.
иначе очень много расписываь

эта таблица выгдяи так. 1,2, 3  вверху это номер процесса.
слева столбик от 0 до 19 это мы запустили секундомер и он отсчитывает время в 
секундах. внутри таблицы цыфры это указано время сколько этому процессу осталось работать.
это оьем оставшейся не выполененной работы.

      1    2     3

 0    5    5    10
 1    4    5    10
 2    4    4    10
 3    4    4     9

 4    3    4     9
 5    3    3     9
 6    3    3     8

 6    2    3     8
 7    2    2     8
 8    2    2     7

 9    1    2     7
10    1    1     7
11    1    1     6

12    0    1     6
13    0    0     6
14    0    0     5

15    0    0     4
16    0    0     3
17    0    0     2
18    0    0     1
19    0    0     0

в итоге какая статистика , сколько времени заняло исполнение кажого
процесса.

процесс 1: (вместо  5с)  12с
процесс 2: (вместо  5с)  13с
процесс 3: (вместо 10с)  19с

тоесть они друг другу мешали. и вмест скажем 5с - сколько бы заняло выпоение 
процесса если  бы больше никого не было наш процессо отболтался на компе 12с.


теперт активируем гипертрединг. и на одном ядре у нас будет 
сидеть вот этот долгий (10с) процесс. а вторые будут сидеть на втором ядре.
и еще будем учитывать что у нас ядра станут послабее что они добавят 20% к времени
исполнения процессов. тоесть там где было 5с станет 6с. где было 10с станет 12с
это тоже важно помнить.

тогда картинка будет такая.


   первое  ядро             второе ядро

      1    2                    3 

 0    6    6              0    12
 1    5    6              1    11    
 2    5    5              2    10

 3    4    5              3     9
 4    4    4              4     8
 5    3    4              5     7    
 6    3    3              6     6
 7    2    3              7     5
 8    2    2              8     4
 9    1    2              9     3
10    1    1             10     2
11    0    1             11     1
12    0    0             12     0

в итоге 
процесс 1: (вместо  5с)  11с
процесс 2: (вместо  5с)  12с
процесс 3: (вместо 10с)  12с


итак сраниваем
    без гипертрединга
процесс 1: (вместо  5с)  12с
процесс 2: (вместо  5с)  13с
процесс 3: (вместо 10с)  19с

    с гипертредингом
процесс 1: (вместо  5с)  11с
процесс 2: (вместо  5с)  12с
процесс 3: (вместо 10с)  12с

в итоге получаем на сколько процентов быстрее отработал каждый процесс в процентах
на гипертрединге
процесс 1:    -9%
процесс 2:    -8%
процесс 3:   -58%

еще надо помнить что как только ядро с короткими процессами разгрузится
то второе ядра (где долгий процесс крутится) у него подскочит мощность обратно с 0.8 до 1 
тоесть на 20% станет быстрее. 

получается цпу похоже не желоб и пилу на конце
желобов может быть  несколько а пила одна. она молотит  стакойто скоростью.
если желоб один то дрова в нем распилиываюься со скростью пилы на конце. а если
желобов несколько то скорость распила в каждом желобе замедляется. 
прикол тут еще состоит в том что когда мы процесс закидываем в желоб то это 
непросто дровина которую надо пилить и пилить а  это выглядит вот как - процесс 
это дрова которые лежат на заднем дворе. а за двором стоит прилорама. так вот в цпу 
в желоб можно загрузить только столько то дров из тех что за двором. когда дрова 
распилены те что в желобе то надо поехать на задний двор. набрать новую порцию 
дров привезти засунуть в желоб и тооько тогда продолжится пиление. а в это время пила
стоит. и в это время выгодно иметь во втором желобе дрова которые бы тоже можно 
было бы пилить. хотя эксперимент что в самом верху показывает что если возить дрова 
сразу  с двух мест то в итоге они мешают друг другу. тоесть подвозят дрова
гораздо быстрее чем пила успевает распилить. да у нас теперь пила не стоит 
ни секунды но теперь у нас затор в приемнике пилы. тоесть вот тот результат.
если загружать дрова только в одну дырку то время распила 163с кучи дров.
а если грузить с двух дырок то время распила двойной кучи дров 205с. а если бы
мы грузили двойно обьем дров в одну дырку то время распила было бы 320с.
тоесть активация гипертрединга нам как бы дает увеличение буфера куда можно 
насыпать дров. и это в каакойто мере ускоряет суммарный обьем распила в секунду.
а без гипертрединга эти бы дрова просто лежали бы на заднем дворе. тоесть логика такая.
есть пилорама в нее можно засунуть за 1 раз скажем 10кг дров. больше невлезает.
а остальные дрова лежит за 10км. проблема еще в том что для следущей порции дрова
надо возить непонятно откуда это становится ясно при распиле текущей кучи дров. 
высока вероятность что подойдут дрова из этой же кучи. а может так статься что
нужно будет везти хрен знает откуда. когда у нас два лотка то у нас всегда
есть куча дров от второго процесса пока дрова для первого процесса подвозят.
но если процесс таков что он сугубо обрабатывает дрова из одной и той же локации
тогда второй лоток будет мешать. замедлять.
тоесть да логика ттакая - если у нас есть процесс и он наваливает дрова все время из 
одной кучи то тут нужно чтобы пилорама была все время свободная. так как дрова будут 
успевать подвозить следущую порцию. а если процесс постоянно заказывает дрова с разных мест
то пила будет стоять и тут навалить дрво с другой кучи это хорошо. на скорости
первого прцоесса это не будет влять. еще дрова могу быть наверное разной
твердости. одну кучу орабоать надо много время а вторую мало. если успевать подвозить 
слдущюую порцию то нужно чтобы второго лотка не было. а если првый процесс неуспевает
подвозить дрова ибо рандомный код то второй лоток как раз то что надо. 
но все таки вернусь к простой аналогии - активации гипертердинга как бы замедляет 
скорость ядра на 20% но дает +1 ядро 0.8. тоесть было 1 ядро на скорсоти 1 
 а стало два ядра на скорости 0.8
 получается у нас обработка каждого потока уменьшилась на 20% зато мы теерь можем 
 обрабатывать в  2 раза больше процессов! а если на цпу второй лоток свободен 
 то у нас обратно ядро разгоняется до 1 !!! вот какая аналогия. 

 тоесть у нас либо есть одна касса которая обрабатвыае человека побыстрее 
 на скрости 1. либо у нас есть две кассы каждая из которых теперь работает 
 помедленнее. а теперь представим. у нас есть клиенты которых долго обслужтивать
 и которых мало. какая касса за 1 час обработает болше клиентов суммарно. 
 пусть даже у нас все клиенты одинаковые. пусть скорсть кассы 1 это 1 чел в минуту.
 за час одна касса обработает 60 человека. а две кассы на скорости 0.8 
 обработают за час  96 человек. а теперь представим что у нас 96 человек в обоих 
 случаях.  система без гипертреинга через  1 час еще будет иметь необаботатанные
 процессы а вторая сисистема нет. 
 у нас цпу без гипетрдинга за слайс времени обрабаытывает больше кода от процессора.
 но остальные процессы при этом болльше стоят колом. это похоже на то что 
 у на аналогию у человека две руки но быстрые или у него 10 рук но они помедленнее на 20%.
 фишка еще в том что обычно на компе работает число процессов гораздо гораздо
 гораздо больше чем число ядер. просто они все очень коротко живущие. 
 вобщем это вопрос в том что что лучше иметь 1 ядро на скрости 1 или 2 ядра 
 на скорости 0.8
 если у нас на компе числ процессов явно больше чем число ядер то лучше больше таких
 ядер котоыре помеьше.  главное что гипртрединг ядра не проседают до скорости 0.5
 иначе получалось бы что без разница то ли запуситть два 7z на одном ядре со скорсьтью 1
 либо на двух со скоростью 0.5. было бы все равно по времени. 
 мой общий вывод - что гипетрединг это хорошо. тем более что если на второя ядре
 нет нагурзки то оставешшеся ядро сразу "разгоняется" до 1. мнекажется что 
 гипетрединг (увеличение числа ядер хоть они и помедленне) доолжно повышать отзывчивость
 системы. так бы у нас часть процессов вообще бы не отвечала потому что их на цпу
 просто бы не было. а так они будут на цпу крутится. 
 если представмть что процесс это колесо проколотое которое сдувается а цпу это насос
 кооторый его подкачвает . далее колесо имеет тайм слайс в течение коиторго в него 
 вдувают воздух а потом уже это колесо убирают а другое подставляют. так вот
 если у нас одно более быстрое ядро и мы будем смотреть на судьбу дотдельного 
 колеса то за слайс времени колесо внутрь себя получает больше воздуха но из за 
 того что ядро одно то следущая очередь на подкачку подойдет гораздо позже .
 если у нас два гипетрединг ядра то воздуха за слайс времени колесо получит мегьше 
 но очередь дойет а подкачку в 2 раза быстрее. если процесс это мамаша которая ходит к 
 цпу за едой и возвращается к своим детям их кормить. то цпу без гипертрединга
 дает за один раз еды больше. но выдает еду реже. цпу с гипетредингом дает еды меньше
 но чаще. причем дает еды на 20% меньше. зато в  2 раза чаще. получается примерно
 так если мы возьмем 4 ядра без гипетрединга то на нем можно выполнить со свистом
 4 программы одноерменно. а если возьмем 8 гипетреинговых ядер то на нем
 по прежнему можно со свистом выполнить теже самые 4 програмы. или выолпнить на 20%
 медленее 8 программ.  и теже самые 8 программ можно выполгить на 4 ядрах 
 медленее в 2 раза. это похоже на щоссе у нас есть либо 4 полосы со свистом
 либо 8 полос на 20% медленнее. но опять же если всего 4 машины то все работает
 со свистом. еси 8 машина на  4 полосах это будет затор. то 8 машин на 8 полосах
 это будет всего 20% медленее для каждой машины. и все это на одном и том же железе. 
 просто если у тебя всего 2 машины ненужно их совать на соседние полосы вот и все.

 думаю по гипертредингу пока хватит.


ниже эксперимнты еще которые я проделал.


1) первый экспримент.
сжимаю в один поток на  1-ом  ядре

$ taskset -c 0  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=1  myarchive.7z ./100_9135.MOV

	2:34.32 real  <==== сколько времени 7z сжимал в архив (154сек)

$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
27737     -   - 7z    <===== процесс
    - 27737   0 -     <==== это тред процесса , как видно процесс имеет один тред

taskset это прога которая повзволяет задать на каких цпу будет дозволено
шедулеру исполнять процесс. 

-с0 это номер ядра. 

real это настенное время. 

-mmt=1 это парамтер 7z определяет во сколько потоков жать поток

PSR показывает на каком цпу ядре работает тред.
дело в том что шедулер пихает на цпу не процессы а треды. вспоминается случай что в системе
один процесс а load average 20. это потому что load average работает не с процессами 
а с тредами.  а у один процесс может состоять из милллиона тредов. об щас будем ниже 
говорить про треды. это отдельная тема.

у баша есть встроенный билтин time . он гавно поэтому юзаем именно внешний


очевидно что у меня одна програма запускает друную программму а та третью. 
и очевидно что по дефолту аффинити наследуется дочерним процессом от родителя

видно что при одном потоке сжатия 7z имеем процесс состоящий из одного треда



2) второй экспримент.
сжимаю в два поток на  2-ух   ядрах лежащих на разных чипах


$ taskset -c 0,1  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=2  myarchive.7z ./100_9135.MOV 

	1:11.16 real  (71сек)


$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
27849     -   - 7z  <---- процесс
    - 27849   1 -  <==== тред
    - 27850   0 -  <==== тред
    - 27851   0 -  <==== тред


интересно что кода мы сжимаем в два потока то у процесса уже не два треда а три!
видимо один тред это мастер какойто или арбитр


получили время в х2 раза меньше. тоесть процесс сжатия реально ускорился в  2 раза.



3) третий экспримент.
сжимаю в три потока на  3-ех  ядрах  лежащих на разных чипах

$ taskset -c 0,1,2  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=3  myarchive.7z ./100_9135.MOV
		1:10.41 real

$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
27891     -   - 7z
    - 27891   0 -
    - 27892   2 -
    - 27893   1 -


 странно. сжатие в три потока а треда по прежнему три
чисто визуально в top видно что сжатие идет вообщем то в прежние два потока.
это видно и по времени сжатия. видимо 7z неумеет параллелится в нечетное
число потоков





4) четверый экспримент.
сжимаю в четыре потока на  4-ех  ядрах лежащих на разных чипах
 
$ taskset -c 0-3  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=4  myarchive.7z ./100_9135.MOV
	0:43.05 real

$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
27914     -   - 7z
    - 27914   3 -
    - 27915   2 -
    - 27916   1 -
    - 27917   0 -
    - 27918   3 -
    - 27919   3 -
    - 27920   0 -

видно что при сжатии в 4 потока число тредов стало 7 штук
из всего увиденного я делаю вывод что 7z умеет сжимать много поточно но только 
если число заданных потоков сжатия кратно двум. тоесть когда я указал число поток три
он делал в два потока. если я укажу в 5 он будет сжимать в 4 потока



5) пятый экспримент.
сжимаю в шесть потоков на  4-ех  ядрах лежащи на разных чипах
и плюс 2 ядра  лежащих на этих же чипах. 
на одном чипе максимум лежит два ядра небольше.

$ taskset -c 0-3,4,5  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=6  myarchive.7z ./100_9135.MOV
	0:34.00 real

$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
27970     -   - 7z
    - 27970   1 -
    - 27971   1 -
    - 27972   0 -
    - 27973   3 -
    - 27974   5 -
    - 27975   2 -
    - 27976   3 -
    - 27977   2 -
    - 27978   4 -
    - 27979   4 -

число тредов 10 при числе потока сжатия 6
странно


5) шестой экспримент.
сжимаю в восемь потоков на  4-ех   ядрах лежащих на разных чипах
 и 4-ех ядрах лежащих на тех же чипах.
на одном чипе лежит максимум два ядра не больше

$ taskset -c 0-4,5-7  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=8  myarchive.7z ./100_9135.MOV
	0:33.91 real
$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
28004     -   - 7z
    - 28004   5 -
    - 28005   7 -
    - 28006   5 -
    - 28007   2 -
    - 28008   6 -
    - 28009   1 -
    - 28010   0 -
    - 28011   0 -
    - 28012   6 -
    - 28013   3 -

число тредов 10 при числе потоков сжатия 8


7) седьмой экспримент.
сжимаю в два потока на  2-ух ядрах лежащих на одном чипе. 
$ taskset -c 0,4  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=2  myarchive.7z ./100_9135.MOV
	1:31.95 real   (91сек)

$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
28083     -   - 7z
    - 28083   4 -
    - 28084   0 -
    - 28085   0 -


8) восьмой экспримент.
сжимаю в четыре потока на  4-ех ядрах лежащих на одном чипе 
$ taskset -c 0-1,4-5  /usr/bin/time   --f  "\t%E real"   7z a  -mmt=4 myarchive.7z ./100_9135.MOV
	0:52.77 real

$ ps  m o pid,lwp,psr,comm  p $(pidof 7z)
  PID   LWP PSR COMMAND
28158     -   - 7z
    - 28158   5 -
    - 28159   1 -
    - 28160   4 -
    - 28161   5 -
    - 28162   5 -
    - 28163   0 -
    - 28164   0 -




Итого:

1 ядро-------------------------------154 сек

2 ядра(на одном чипе)-----------------91 сек
2 ядра(разных чипах)------------------71 сек

4 ядра(по два на одном чипе)----------53 сек
4 ядра(на разных чипах)---------------43 сек

8 ядер(по два на одном чипе-----------33 сек



число     число      
потоков   тредов     
   1        1        
   2        3        
   3        3   <==== очевидно прога не поддерживает нечетное число потоков
   4        7
   6       10
   8       10   <==== тоже под вопросом 
  




ксатти  я так поискал - вроде бы линукс имеет понтие о гипертрединге.
так что он вроде бы старается не пихать два процесса на один чип если есть
ядро которое свободное и лежит на другом чипе.




Далее следущая важная штука - вот у меня есть процесс. 
а как узнать какие цпу ему разрешены, как узнать цпу affinity 
у этого процесса. сразу думаешь - в /proc это же фс
как раз по детальной информации про процесс. значит надо искать там.
и есть такое место!

	$ cat /proc/$pid/status | grep -i cpu
	Cpus_allowed:	11
	Cpus_allowed_list:	0,4

нижняя хрень показывает номера ядер на которых этому процессу можно 
тусоваться. а верхняя хрень показывает то же самое но в форме HEX (именно hex  а не DEC) числа
в виде битовой маски тоесть

11 hex это 17 dec. распишем это число в битовом виде
    0001 0001
самый младщий бит это ядро номер 0. значит согласно этой маске
у нас разрешено процессу тусоваться (это указание щедулеру) на ядрах 0 и 4
что полностью совпадает со второй строкой!

ксатти как узнать аффинии для треда tid который приналежит процессу pid?
ответ

$ cat /proc/23591/task/23594/status | grep -i cpu
Cpus_allowed:	ff
Cpus_allowed_list:	0-7

23591 - это номеор проецсса
23594 - это номер треда

кстати приходит вопрос а что если у процесса неодин  тред (все время забываю про треды)
а их несколько? как тогда? немогу сказат точно но вот так навскидку если задали 
цпу аффинити для процесса то тредов это автоматом касается. я проверил на праткие.
запустил этот 7z в мультипотомноч режиме. он создал /proc/pid/tasks/ папки.
внутри кооторых инфо по тредам и там есть такой же файл status. и его содерэимое
в плане 
	Cpus_allowed:	11
	Cpus_allowed_list:	0,4
полностьюю совпадает как оно есть для файла процесса
$ cat /proc/$pid/status

если спросмть в интернете то там везде посылают пользоваться программмаой taskset
так как она нетлтко позволяет задвать аффиниити но и показать его. но почму
то никто не знает прото что это можно посмотеть в /proc
так вот через taskset это можно посмореть вот так

$ taskset -c -p 1
pid 1's current affinity list: 0-7

-p задаает у ккакого процсса мы хотим узнать.

так вот я думал что taskset за этой инфо лезет в /proc
оказалось хрен там. она для этого юзает сисколл  sched_getaffinity!!

$ sudo strace  taskset -c -p 1
..
..
sched_getaffinity(0, 256, [0, 1, 2, 3, 4, 5, 6, 7]) = 8
sched_getaffinity(1, 8, [0, 1, 2, 3, 4, 5, 6, 7]) = 8
..

я этим заинтересовался и сам полез чтобы написать на си программу чтобы
тоже посмотреть также. для этого смотри файл "C+assembly.txt"


кстати на счет taskset. положим у нас прроцесс много тредовый. вопрос
тасксет он работает с номерами тредов или номерами процесса тоест может 
ли тасксет задавать афигити для тредов?

вот у меня есть многотредовая программа

$ ./thread3.exe 
Thread ID (main thread): 23591, pid=23591
Thread ID: 23592, pid=23591
Thread ID: 23593, pid=23591
Thread ID: 23594, pid=23591

проверим какое аффинити для треда 23594


$ cat /proc/23591/task/23594/status | grep -i cpu
Cpus_allowed:	ff
Cpus_allowed_list:	0-7

проверим через тасксет
$ taskset -c -p 23594
pid 23594's current affinity list: 0-7

прикольно то что в ключе -p указывается не номер проесса а номер треда!
просто у многотредовых процессов есть так назыаемый мастер процесс который можно
определить так что у него номер треда равен номеру процесса. поэтому мы вроде как
думаем что вбиваем номер процесса в тасксет а на самом деле вбиваем номер треда. 
о процессах и тредах я буду говорить в "linux-general.txt" искать по "| thread".

пробую менять аффинити для треда (не для процесса а для треда!)

$ taskset -c    -p 1,5 23594
pid 23594's current affinity list: 1,5
pid 23594's new affinity list: 1,5

$ taskset -c    -p  23594
pid 23594's current affinity list: 1,5

$ cat /proc/23591/task/23594/status | grep -i cpu
Cpus_allowed:	22
Cpus_allowed_list:	1,5

все верно! все сработало!

это приклоно и очень правильно что можно менять аффинити для треда а не процесса.
ибо у шедулера единица которую он пихает на цпу это тред! а не процесс. процесс
это просто напросто группа тредов!

упомянуто что процессоры ядра в линуксе распреедялются по группам и доменам.
это делатся что бы шедулеры было понятно на каком цпу ему просыпать процесс
когда ему нужно выполнить кусок своего кода. там учитываются и гипертрединг 
цпу и нума ноды.  нужно искать  в инете фразу linux cpu domains
но конкретиики мало.

а вот про нуму (когда цпу сидят на своем локальном куске RAM)

$ numactl --hardware
available: 1 nodes (0)
node 0 cpus: 0 1 2 3 4 5 6 7
node 0 size: 15766 MB
node 0 free: 915 MB
node distances:
node   0 
  0:  10 

тоесть 8 ядер сидят на одной нума ноде























=====
///////////////////////////////////
///////////////////////////////////
///////////////////////////////////
| план

план

эссе
bash
man top
язык C книжка "c how to program" автор deitel




