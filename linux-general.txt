linux
общее

--
ubuntu 20 
сука в два раза жирнее по диску чем ubuntu16
гораздо мнеее отзывчивый тяжелый

стал как и весь другой софт сразу занчительно неповоротливый тяжелый.
нахуй он такой нужен
тяжело натужно грузится
миллион служб. все как с другим софтом чем дальше тем хуевей
убунту 16 просто ракета по сравению

что нужно допилить напильиником в ubuntu 20:

	иодитский netplan 
	как его удалить - https://disnetern.ru/disable-netplan-ubuntu/
	причем netplan я удалидл. ifupdown пакет поставил но при этом
	настройки про dns из /etc/networkj/interfaces нихера не подсатыватся.
	в итоге нужно еще поставить # apt install resolvconf
	тогда настройки dns надо прорисывать в /etc/resolv.conf про dns
	как и когда то одавно!
		# cat resolv.conf
		nameserver 172.16.101.2
		nameserver 172.16.101.7
		domain mk.local
		search mk.local

	нужно пояс часовой сделать москва
	 sudo timedatectl set-timezone Europe/Moscow

	удалит floppy из системы.
	$ sudo rmmod floppy
				$ echo "blacklist floppy" | sudo tee /etc/modprobe.d/blacklist-floppy.conf
				$ sudo dpkg-reconfigure initramfs-tools
				
	
--


делаем чтобы можно было к нектиться к ФС

ceph auth get-or-create client.cephfs mon 'allow r' osd 'allow rwx pool=cephfs_metadata,allow rwx pool=cephfs_data' -o /etc/ceph/client.cephfs.keyring

ceph-authtool -p -n client.cephfs /etc/ceph/client.cephfs.keyring > /etc/ceph/client.cephfs

--

iperf

задача сделать тест скорости сети 
из между офисами.

далем на основе iperf

ставим на обоих компах iperf3
нужен именно он

# sudo apt-get install iperf3

стандартный iprf работает так, один конец запускаем в
виде сервера

(a)# iperf -p 49001 -s

-p 490001 = это порт на который сервер принимает запросы.
надо на файрволле открыть этот порт для входящих

второй конец работает клиентом

(b)# iperf -c 123.12.12.12 -p 49001 -R -i 5

-c 123.12.12.12 = адрес сервера
-i 5 = через сколько секунд выводить статистику на экран

еще можно указать ключ -t 10 = это значит что тест будет идти 10 секунд
если -t вобще неуказывать то тест будет идти бесконечно что удобно

самый главный ключ это -R и он есть только в iperf3
он дает то что клиент будет скачивать данные с сервера.
потому что по дефолту клиент подклчается к серверу и начинает UPLOAD 
данных на сервер. 
поэтому если мы хотим чтобы клиент DOWNLOAD данные с сервера нужен ключ -R

---

LINUX REMAP KEYS

купил мелкую клаву.
а на ней эти уроды убрали insert 
pgup pgdown end

как сделат ьтак чтобы жмешь наодну конопку а унее функция другой кнлопки


редактикрую файл

/usr/share/X11/xkb/keycodes/evdev

а если пром еще хочется узнать какой код у какой кнопки то 
хзапусти прогу xev

=============
ssh

known_hosts

что в этом файле на компе клиента.

когда мы конектимся к серверу 
то он нам присылыает свой публичный ключ.
так вот в known_hosts наш хост сохраняет хэш от этого публичного ключа + IP\hostname от этого сервера.
зачем мы это делаем = чтобы в следущий раз если мы стучим на этот сервер то заранее знать какой нам публичеый 
ключ ожидать. потому что злолдей может заглущить ориганлный сервер поставить себе его ip 
создать свой приватный \пубичный ключ  и совать их нам выдавая себя за оригинаьный сервер.

строчка в этом файле прдставляет собой вначале идет hostname\ip смотря что мы вбивали в команде ssh
причем оно указано не в открытом виде а виде тоже хэша. а потом идет хэш от публичного ключа того сервера

поскульку это хэши то дешифровать никак нельзя.

зато можно провнрить есть и в known_hosts запись о том или ином хосте.

$ ssh-keygen -F mail.ru

еще можно удлаить строчку из known_hosts

$ ssh-keygen -R mail.ru

если удалить весь файл то ничго страшного.
просто при стучании на серверы начнет выскакивать надпись дескать 
удаденный хост имеет такой то хэш пуличного ключа мол вы согласный что удалеенный хост это удаленный хост
вот и все последствия

=============
tty

про эту тему tty можно писать много и долго.
про эту тему уже разбросано несолько кусков по моей документации. 
я позже их соберу. а щас рассмотрим такую тему. вот если нажать ps aux

то в выводе идет список процессов и у каких то процессов указан знак вопроса "?"  в столбце tty а 
у каких то указано tty1 или tty7 или pts/0. pts небудем трогать пока считаем что это некая разновидость tty. так вот что же это значит что процесс имеет некий tty или не имеет его. на что
это вляет как это понять почуствовать. в чем разница и все такое.

если процесс в выводе ps имеет в свойствах tty это значит что у данного процесса в свойствах 
открытых файлов имеется устройство tty. пример

смотрим на ps для процесса 1180

$ ps aux | grep -E "TTY|1180"
USER       PID %CPU %MEM    VSZ   RSS   TTY      STAT   START   TIME   COMMAND
root      1180  0.6  0.5 1227504 89308  tty7     Rsl+   апр18   116:29  /usr/lib/xorg/Xorg

видим что ps показывает для 1180 что tty7

смотрим какие файловые дескрипторы открыты для процесса 1180 на proc
$ sudo ls -1al /proc/1180/fd/ | grep tty
lrwx------ 1 root root 64 мая  1 01:10 12 -> /dev/tty7

и видим что среди файловых дескрипторов есть /dev/tty7

файловый дескриптор это поток обмена информации между процессом и внешним миром. в него 
можно читать и писать. в данном случае у процесса поток номер 12 имеет 
бекендом  устройство /dev/tty7 тоесть у процесса есть канал обмена информацией между процессом
и устройством /dev/tty7 

таким образом если в ps мы видим что процесс имеет в своих свойствах tty устройство 
это значит что у процесса открыт канал связи с tty устройством.

что такое tty устройство - для начала  /dev/ устройства в целом что это такое. есть реальное физическое устройство железка. данные от железки поступают в ядро. а /dev/ устройства это кранчик
который торчит из ядра который позволяет программе из user space получит данные от железного устройства из ядра через этот кранчик /dev/ файла.  какая железка является бекендом для /dev/ttyX 
файла. в одном случае это COM порт. тоесть запись в /dev/ttyX файл пишет в COM порт и чтение из 
/dev/ttyX файла это принятие данных из COM порта.  
таким образом если у процесса есть файловый дескриптор который ведет в /dev/tty устройство это значит данный процесс может писать в COM порт или читать данные из COM порта.
цепочка тогда выглядтит так:

процесс -> файлоый дескриптор -> /dev/tty устройство -> ядро -> COM порт

и наоборот.

тоесть если у процесса есть tty устройство это значит что у процесса открыт канал связи с внешним миром через COM порт в обе стороны. тоесть с точки зрения процесса у него открыт файл на чтение 
и запись. бекендом данного файла явяляется tty файл бекендом которого является COM железка.

далее. чуть сложнее. раньше клавы и мониторы были вынесены за системный блок. то есть схема 
выглядела так. системный блок у него COM порт. в него идет провод от коробки под названием 
терминал. терминал это коробка у которой есть клава и экран вот сигнал от клавы на терминале 
поступал в системный блок через COM порт получается через /dev/tty файл. и также от системного блока
инфо которая была предназначена для вывода на экран она летела в /dev/tty файл от процесса в системном блоке потом в ядро и в COM порт оттуа по проводу в терминал а он(терминал) поступившую инфо  преобразовавл и выводил буквы на экран терминала.  таким образом COM порт это был порт 
через который инфо от клавы и монитора попадала в системный блок в обе стороны.
таким образом COM порт это был порт через который в процесс могл прилетать инфо от клавы и 
и от процесса инфо могла попадать на экран монитора. тоесть COM порт и tty устройство это устройство
через которое через который процесс имеет связь с живым юзером.

далее прикол в том что в ядро линукс встроен виртуальный терминал выглядит это так. процесс 
открывает файл /dev/ttyX устройство и начинает туда писать. данные летят в ядро. ядро направляет поток в драйвер виртуального терминала и он направляет его на экран монитора. и про клаву. поток из клавы летит в ядро. ядро направляет поток в драйвер вирт терминала. он обрабатывает поток и шлет
поток в /dev/tty файл и процесс чеерз этот файл получает поток от клавы внутрь себя. таким образом
если у процесса открыт на чтение запись файл /dev/tty{1..7} то это значит что даные с клавы летят в данный процесс и данные от процесса выводятся на экран.

таким образом отвечаем на изначальный вопрос в чем разница между процессом у которого открыт 
поток чтения записи в tty устройство от процесса у которого такого потока неоткрыто.
разница в том что процесс у которого отркыт поток обмена данным с tty устройством дает 
возможность чтобы инфо с клавы компа летели внутрь процесса и поток вывода от процесса в tty 
приводит к тому что инфо поступает на экран компа. таким образом tty поток дает воможность 
взаимодействовать процессу с живым юзером через экран и клаву.

во времена терминалов за каждый ttyX  портом скрвыался на том конце терминал со своей клавой 
и своим экраном. тоесть если было семь tty1-tty7 портов то это значит что было на том конце
семь терминалов, семь клавиатур и семь мониторов. поэтому если процесс 1 имел открытым tty1 то 
инфо с клавы 1 летело в процесс1 а если процесс2 имел открытым tty2 то инфо с клавы2 летело в процесс2. а какая же ситуация сейчас когда у нас на компе есть tty1-tty7 но при этом клава 
физически у компа одна. как же ядро понимает в какой tty посылать поток идущий с клавы.
я понимаю что дело выгляди так - вот мы тыкнули Ctrl-Alt-F1 значит ядро понимает 
что на данный момент мы "активировали" первый виртуальный терминал в ядре.значит поток букв от клавы
надо посылать в /dev/tty1 и значит тот процесс который читает с этого устройтва и будет получать
поток букв с клавы.  теперь про экран. пусть у нас семь процессов и каждый из них открыл свой tty
тоесть

pid 1 -> tty1
pid 2 -> tty2
...
pid 7 -> tty7

далее каждый из этих процессов постоянно чтото шлет записывает в свой tty. 
возникает вопрос какой из этих потоков выводить на экран. думаю что рабтает также.
что поток сохраняется в некий буфер в памяти ядра. для каждого tty свой буфер. далее
мы жмем Ctrl-Alt-F1 и ядро понимает что мы активировали первый виртальный терминал. 
тода ядро выводит на физический экран вывод из буфера памяти от tty1 устройства.
далее мы тыкаем Ctrl-Alt-F5 и ядро понимает что мы перключились на пятй виртуальный терминал
и ядро выводми на экран вывод из буфера памяти который хранит накопленный поток от tty5.
это была логика когда у нас линукс работает в текстовом init 3 режиме.
когда у нас графический режим то вместо tty используются pts устройства. и вместо Ctral-Alt-Fx
комбинаий исполщуется то что мы мышкой активируем то или иное окно.

таким образом есл вернтся в текстовый режим то полчается что ядро линукса оно биндит
виртальные терминалы(монитор и клава) в физическую клаву и физический монитор.

итак еще о чем нам говорит если у процесса  в списке открытых файлов есть tty устройство.
это нам говорит о том что данный проецесс подразумевает может контактировать с живым юзером
через клаву и монитор. через клаву процесс может получать от юзера нажатие кнопок а через монитор процесс может выводить инфо. если у процесса нет открытых tty файлов то работа данного процесса
не подразумевает контакт с живым юзером. с клавы он инфо принимать неможет и на экран выводиь 
инфо он тоже неможет. назовем это так : есть юзер интерактивные процессы и неинтерактивные.

вопрос а что если несколько процессов одновременно имеют откртытым один и тот же tty файл например tty2.
вот мы жмем кнопки на клаве в какой процесс летит поток от клавы. ответ такой что от того что 
процессом открыт файл еще незначит что он из него постоянно читает. 
если они оба постоянно пытаются из него читать то будет идти конкурентная борьба и часть букв 
будет попадать в один процесс а часть в другой. 

а что если они оба активно пишут в tty2. значит на экране будет идти смесь то одного процесса то 
от другого. тоесть. скажем первый шлет "aaaaaaaaaaaa" а второй шлет "bbbbbbbbbb"
на экране юзер буездет видеть чтото типа того "ababbbaabbabababbaab" тоесть будет тоже идти
конкуретная борьба.

но как я уже скаал от тооо что два процесса имеют открытым один tty2 это незначит что они оба
из него сейчас активно читают или пишут. пример откроем терминал в граф оболочке. и введем команду
$ tty
она покажет к какому устройству вирт терминала прикреплен данный виртуальный терминал.

$ tty
/dev/pts/21

pts это упрошенно говоря тоже некий аналог вирт терминала.

теперь вот что запустим

$ ps aux | grep 'pts/21'
vasya    15543  0.1  0.0  34112  5448 pts/21   Ss   02:53   0:00 bash
vasya    15557  0.0  0.0  48852  3772 pts/21   R+   02:54   0:00 ps aux


тут видно что два процесса имеют открытым один и тот же файл вирт терминала pts/21
но между ними конфликта нет. мы имели запущенный bash и в нем мы запустили команду ps aux
и баш что сделал. он породил новый процесс ps aux и при этом процесс bash 15543 ушел в состояние 
interruptible sleep. конечно статус в ps не является прям точной инфо потому что процесс может 
чтото делать по быстрому и потом уходить в состояние sleep тоесть это незначит что процесс прям
все время в этом состяонии. он был в том состоянии только на момент вывода ps. одномоментно.
но с высокой долей вероятности можно полагачть что 
  хотя bash 15543 и имеет открытым pts устройство но он из него ничего нечитает и в него 
ничего не выводит. поэтому на момент выполнения ps aux вывод на pts\21 был подчинен только 
процессу ps aux. поэтом конфликат никакого нет. поэтому нет никакой чехарды с потоком от клавы
 и потоком на монитор. но в целом его легко устроить если запустить какойто цикл который чтот выводит экран. а потом открыть другой терминал и начать слать мусор в /dev/pts/21 и тогда на экране
 первого терминала будет идти смешение вывода от цикла и от нашего ручного мусорного потока.


а вот интеренсый вопрос что происходит когда в bash мы запускаем команду  в
background режиме ( это такая фишка баша). например

$  (while true; do sleep 10; echo "111"; done)&

при этом будем наблдюдать интересуную картину с одной стороны мы имеем доступ
к консоли но в ней периодически будет появляться "111"

получаеся по факту у нас два процесса у которых один pts/22 и наш первый процесс он периодически
шлет в pts/22 инфо и она выскакивает на окне терминала. в тоже время мы тоже сидя за клавой
может чтото писать на терминале. тоесть мы имеем два процесса которые одновременно вывоводят в 
один терминал. насколько я понимаю что просиходит при запуске в баш команды в бекграунд режиме 
то форкается процесс в нем запускается команда но исходный баш процесс не помещается в режим sleep
а продолжает свою работу. 

 а вот еще пример

 $  ( while true; do     sleep 10; read var1; done )&

 тут получается что процесс должен считать с клавы. так вот у нас получится что есть 
 два процесса с одним pts и оба процесса в какойто момент времени будут читать с клавы
 так вот незнаю как но баш делает так что если бекграундный процесс лезет читать в то время как 
 исходный баш процесс читает ведь с клавы так вот бекграуден процесс тут же будет остановлен 
 башем.  с точки зрения статуса данный процесс будет переведен в статус "T" когда он попытается
 счиатть с клавы наряду с исходным баш процессом.


====
каналы 1 ,2 

по поводу пернаправления вывода

find / 2>/dev/null

что там происходит по капотом в этом случае. что за загадочные цифра 2.
на самом деле все просто. создаетя процесс который обслуживает find
и у него есть файловые дескприоры 

/proc/$$/fd/{0,1,2}

так вот мы башу закаываем чтобы он когда будет создавать процесс под команду find
чтобы он дескпритор 2 перенарпавил (тоесть что у него будет бекендом ) не на экран ( тоесть не на /dev/pts/17) а в /dev/null вот и все

$ sudo ls -1al /proc/20920/fd
lrwx------ 1 root root 64 мая 17 23:42 0 -> /dev/pts/32
l-wx------ 1 root root 64 мая 17 23:42 1 -> 'pipe:[1662807]'
l-wx------ 1 root root 64 мая 17 23:42 2 -> /dev/null


вот четко видно что 

2 -> /dev/null

что файловый дескриптор 2 ( в который процесс кидает поток с инфо о ошибках) совать в /dev/null

вот как работает под капотом вся эта хрень с перенапраавлением ввода вывода!

===
