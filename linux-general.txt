linux
общее

--
ubuntu 20 
сука в два раза жирнее по диску чем ubuntu16
гораздо мнеее отзывчивый тяжелый

стал как и весь другой софт сразу занчительно неповоротливый тяжелый.
нахуй он такой нужен
тяжело натужно грузится
миллион служб. все как с другим софтом чем дальше тем хуевей
убунту 16 просто ракета по сравению

что нужно допилить напильиником в ubuntu 20:

	иодитский netplan 
	как его удалить - https://disnetern.ru/disable-netplan-ubuntu/
	причем netplan я удалидл. ifupdown пакет поставил но при этом
	настройки про dns из /etc/networkj/interfaces нихера не подсатыватся.
	в итоге нужно еще поставить # apt install resolvconf
	тогда настройки dns надо прорисывать в /etc/resolv.conf про dns
	как и когда то одавно!
		# cat resolv.conf
		nameserver 172.16.101.2
		nameserver 172.16.101.7
		domain mk.local
		search mk.local

	нужно пояс часовой сделать москва
	 sudo timedatectl set-timezone Europe/Moscow

	удалит floppy из системы.
	$ sudo rmmod floppy
				$ echo "blacklist floppy" | sudo tee /etc/modprobe.d/blacklist-floppy.conf
				$ sudo dpkg-reconfigure initramfs-tools
				
	
--


делаем чтобы можно было к нектиться к ФС

ceph auth get-or-create client.cephfs mon 'allow r' osd 'allow rwx pool=cephfs_metadata,allow rwx pool=cephfs_data' -o /etc/ceph/client.cephfs.keyring

ceph-authtool -p -n client.cephfs /etc/ceph/client.cephfs.keyring > /etc/ceph/client.cephfs

--

iperf

задача сделать тест скорости сети 
из между офисами.

далем на основе iperf

ставим на обоих компах iperf3
нужен именно он

# sudo apt-get install iperf3

стандартный iprf работает так, один конец запускаем в
виде сервера

(a)# iperf -p 49001 -s

-p 490001 = это порт на который сервер принимает запросы.
надо на файрволле открыть этот порт для входящих

второй конец работает клиентом

(b)# iperf -c 123.12.12.12 -p 49001 -R -i 5

-c 123.12.12.12 = адрес сервера
-i 5 = через сколько секунд выводить статистику на экран

еще можно указать ключ -t 10 = это значит что тест будет идти 10 секунд
если -t вобще неуказывать то тест будет идти бесконечно что удобно

самый главный ключ это -R и он есть только в iperf3
он дает то что клиент будет скачивать данные с сервера.
потому что по дефолту клиент подклчается к серверу и начинает UPLOAD 
данных на сервер. 
поэтому если мы хотим чтобы клиент DOWNLOAD данные с сервера нужен ключ -R

---

LINUX REMAP KEYS

купил мелкую клаву.
а на ней эти уроды убрали insert 
pgup pgdown end

как сделат ьтак чтобы жмешь наодну конопку а унее функция другой кнлопки


редактикрую файл

/usr/share/X11/xkb/keycodes/evdev

а если пром еще хочется узнать какой код у какой кнопки то 
хзапусти прогу xev

=============
ssh

known_hosts

что в этом файле на компе клиента.

когда мы конектимся к серверу 
то он нам присылыает свой публичный ключ.
так вот в known_hosts наш хост сохраняет хэш от этого публичного ключа + IP\hostname от этого сервера.
зачем мы это делаем = чтобы в следущий раз если мы стучим на этот сервер то заранее знать какой нам публичеый 
ключ ожидать. потому что злолдей может заглущить ориганлный сервер поставить себе его ip 
создать свой приватный \пубичный ключ  и совать их нам выдавая себя за оригинаьный сервер.

строчка в этом файле прдставляет собой вначале идет hostname\ip смотря что мы вбивали в команде ssh
причем оно указано не в открытом виде а виде тоже хэша. а потом идет хэш от публичного ключа того сервера

поскульку это хэши то дешифровать никак нельзя.

зато можно провнрить есть и в known_hosts запись о том или ином хосте.

$ ssh-keygen -F mail.ru

еще можно удлаить строчку из known_hosts

$ ssh-keygen -R mail.ru

если удалить весь файл то ничго страшного.
просто при стучании на серверы начнет выскакивать надпись дескать 
удаденный хост имеет такой то хэш пуличного ключа мол вы согласный что удалеенный хост это удаленный хост
вот и все последствия

=============
tty

про эту тему tty можно писать много и долго.
про эту тему уже разбросано несолько кусков по моей документации. 
я позже их соберу. а щас рассмотрим такую тему. вот если нажать ps aux

то в выводе идет список процессов и у каких то процессов указан знак вопроса "?"  в столбце tty а 
у каких то указано tty1 или tty7 или pts/0. pts небудем трогать пока считаем что это некая разновидость tty. так вот что же это значит что процесс имеет некий tty или не имеет его. на что
это вляет как это понять почуствовать. в чем разница и все такое.

если процесс в выводе ps имеет в свойствах tty это значит что у данного процесса в свойствах 
открытых файлов имеется устройство tty. пример

смотрим на ps для процесса 1180

$ ps aux | grep -E "TTY|1180"
USER       PID %CPU %MEM    VSZ   RSS   TTY      STAT   START   TIME   COMMAND
root      1180  0.6  0.5 1227504 89308  tty7     Rsl+   апр18   116:29  /usr/lib/xorg/Xorg

видим что ps показывает для 1180 что tty7

смотрим какие файловые дескрипторы открыты для процесса 1180 на proc
$ sudo ls -1al /proc/1180/fd/ | grep tty
lrwx------ 1 root root 64 мая  1 01:10 12 -> /dev/tty7

и видим что среди файловых дескрипторов есть /dev/tty7

файловый дескриптор это поток обмена информации между процессом и внешним миром. в него 
можно читать и писать. в данном случае у процесса поток номер 12 имеет 
бекендом  устройство /dev/tty7 тоесть у процесса есть канал обмена информацией между процессом
и устройством /dev/tty7 

таким образом если в ps мы видим что процесс имеет в своих свойствах tty устройство 
это значит что у процесса открыт канал связи с tty устройством.

что такое tty устройство - для начала  /dev/ устройства в целом что это такое. есть реальное физическое устройство железка. данные от железки поступают в ядро. а /dev/ устройства это кранчик
который торчит из ядра который позволяет программе из user space получит данные от железного устройства из ядра через этот кранчик /dev/ файла.  какая железка является бекендом для /dev/ttyX 
файла. в одном случае это COM порт. тоесть запись в /dev/ttyX файл пишет в COM порт и чтение из 
/dev/ttyX файла это принятие данных из COM порта.  
таким образом если у процесса есть файловый дескриптор который ведет в /dev/tty устройство это значит данный процесс может писать в COM порт или читать данные из COM порта.
цепочка тогда выглядтит так:

процесс -> файлоый дескриптор -> /dev/tty устройство -> ядро -> COM порт

и наоборот.

тоесть если у процесса есть tty устройство это значит что у процесса открыт канал связи с внешним миром через COM порт в обе стороны. тоесть с точки зрения процесса у него открыт файл на чтение 
и запись. бекендом данного файла явяляется tty файл бекендом которого является COM железка.

далее. чуть сложнее. раньше клавы и мониторы были вынесены за системный блок. то есть схема 
выглядела так. системный блок у него COM порт. в него идет провод от коробки под названием 
терминал. терминал это коробка у которой есть клава и экран вот сигнал от клавы на терминале 
поступал в системный блок через COM порт получается через /dev/tty файл. и также от системного блока
инфо которая была предназначена для вывода на экран она летела в /dev/tty файл от процесса в системном блоке потом в ядро и в COM порт оттуа по проводу в терминал а он(терминал) поступившую инфо  преобразовавл и выводил буквы на экран терминала.  таким образом COM порт это был порт 
через который инфо от клавы и монитора попадала в системный блок в обе стороны.
таким образом COM порт это был порт через который в процесс могл прилетать инфо от клавы и 
и от процесса инфо могла попадать на экран монитора. тоесть COM порт и tty устройство это устройство
через которое через который процесс имеет связь с живым юзером.

далее прикол в том что в ядро линукс встроен виртуальный терминал выглядит это так. процесс 
открывает файл /dev/ttyX устройство и начинает туда писать. данные летят в ядро. ядро направляет поток в драйвер виртуального терминала и он направляет его на экран монитора. и про клаву. поток из клавы летит в ядро. ядро направляет поток в драйвер вирт терминала. он обрабатывает поток и шлет
поток в /dev/tty файл и процесс чеерз этот файл получает поток от клавы внутрь себя. таким образом
если у процесса открыт на чтение запись файл /dev/tty{1..7} то это значит что даные с клавы летят в данный процесс и данные от процесса выводятся на экран.

таким образом отвечаем на изначальный вопрос в чем разница между процессом у которого открыт 
поток чтения записи в tty устройство от процесса у которого такого потока неоткрыто.
разница в том что процесс у которого отркыт поток обмена данным с tty устройством дает 
возможность чтобы инфо с клавы компа летели внутрь процесса и поток вывода от процесса в tty 
приводит к тому что инфо поступает на экран компа. таким образом tty поток дает воможность 
взаимодействовать процессу с живым юзером через экран и клаву.

во времена терминалов за каждый ttyX  портом скрвыался на том конце терминал со своей клавой 
и своим экраном. тоесть если было семь tty1-tty7 портов то это значит что было на том конце
семь терминалов, семь клавиатур и семь мониторов. поэтому если процесс 1 имел открытым tty1 то 
инфо с клавы 1 летело в процесс1 а если процесс2 имел открытым tty2 то инфо с клавы2 летело в процесс2. а какая же ситуация сейчас когда у нас на компе есть tty1-tty7 но при этом клава 
физически у компа одна. как же ядро понимает в какой tty посылать поток идущий с клавы.
я понимаю что дело выгляди так - вот мы тыкнули Ctrl-Alt-F1 значит ядро понимает 
что на данный момент мы "активировали" первый виртуальный терминал в ядре.значит поток букв от клавы
надо посылать в /dev/tty1 и значит тот процесс который читает с этого устройтва и будет получать
поток букв с клавы.  теперь про экран. пусть у нас семь процессов и каждый из них открыл свой tty
тоесть

pid 1 -> tty1
pid 2 -> tty2
...
pid 7 -> tty7

далее каждый из этих процессов постоянно чтото шлет записывает в свой tty. 
возникает вопрос какой из этих потоков выводить на экран. думаю что рабтает также.
что поток сохраняется в некий буфер в памяти ядра. для каждого tty свой буфер. далее
мы жмем Ctrl-Alt-F1 и ядро понимает что мы активировали первый виртальный терминал. 
тода ядро выводит на физический экран вывод из буфера памяти от tty1 устройства.
далее мы тыкаем Ctrl-Alt-F5 и ядро понимает что мы перключились на пятй виртуальный терминал
и ядро выводми на экран вывод из буфера памяти который хранит накопленный поток от tty5.
это была логика когда у нас линукс работает в текстовом init 3 режиме.
когда у нас графический режим то вместо tty используются pts устройства. и вместо Ctral-Alt-Fx
комбинаий исполщуется то что мы мышкой активируем то или иное окно.

таким образом есл вернтся в текстовый режим то полчается что ядро линукса оно биндит
виртальные терминалы(монитор и клава) в физическую клаву и физический монитор.

итак еще о чем нам говорит если у процесса  в списке открытых файлов есть tty устройство.
это нам говорит о том что данный проецесс подразумевает может контактировать с живым юзером
через клаву и монитор. через клаву процесс может получать от юзера нажатие кнопок а через монитор процесс может выводить инфо. если у процесса нет открытых tty файлов то работа данного процесса
не подразумевает контакт с живым юзером. с клавы он инфо принимать неможет и на экран выводиь 
инфо он тоже неможет. назовем это так : есть юзер интерактивные процессы и неинтерактивные.

вопрос а что если несколько процессов одновременно имеют откртытым один и тот же tty файл например tty2.
вот мы жмем кнопки на клаве в какой процесс летит поток от клавы. ответ такой что от того что 
процессом открыт файл еще незначит что он из него постоянно читает. 
если они оба постоянно пытаются из него читать то будет идти конкурентная борьба и часть букв 
будет попадать в один процесс а часть в другой. 

а что если они оба активно пишут в tty2. значит на экране будет идти смесь то одного процесса то 
от другого. тоесть. скажем первый шлет "aaaaaaaaaaaa" а второй шлет "bbbbbbbbbb"
на экране юзер буездет видеть чтото типа того "ababbbaabbabababbaab" тоесть будет тоже идти
конкуретная борьба.

но как я уже скаал от тооо что два процесса имеют открытым один tty2 это незначит что они оба
из него сейчас активно читают или пишут. пример откроем терминал в граф оболочке. и введем команду
$ tty
она покажет к какому устройству вирт терминала прикреплен данный виртуальный терминал.

$ tty
/dev/pts/21

pts это упрошенно говоря тоже некий аналог вирт терминала.

теперь вот что запустим

$ ps aux | grep 'pts/21'
vasya    15543  0.1  0.0  34112  5448 pts/21   Ss   02:53   0:00 bash
vasya    15557  0.0  0.0  48852  3772 pts/21   R+   02:54   0:00 ps aux


тут видно что два процесса имеют открытым один и тот же файл вирт терминала pts/21
но между ними конфликта нет. мы имели запущенный bash и в нем мы запустили команду ps aux
и баш что сделал. он породил новый процесс ps aux и при этом процесс bash 15543 ушел в состояние 
interruptible sleep. конечно статус в ps не является прям точной инфо потому что процесс может 
чтото делать по быстрому и потом уходить в состояние sleep тоесть это незначит что процесс прям
все время в этом состяонии. он был в том состоянии только на момент вывода ps. одномоментно.
но с высокой долей вероятности можно полагачть что 
  хотя bash 15543 и имеет открытым pts устройство но он из него ничего нечитает и в него 
ничего не выводит. поэтому на момент выполнения ps aux вывод на pts\21 был подчинен только 
процессу ps aux. поэтом конфликат никакого нет. поэтому нет никакой чехарды с потоком от клавы
 и потоком на монитор. но в целом его легко устроить если запустить какойто цикл который чтот выводит экран. а потом открыть другой терминал и начать слать мусор в /dev/pts/21 и тогда на экране
 первого терминала будет идти смешение вывода от цикла и от нашего ручного мусорного потока.


а вот интеренсый вопрос что происходит когда в bash мы запускаем команду  в
background режиме ( это такая фишка баша). например

$  (while true; do sleep 10; echo "111"; done)&

при этом будем наблдюдать интересуную картину с одной стороны мы имеем доступ
к консоли но в ней периодически будет появляться "111"

получаеся по факту у нас два процесса у которых один pts/22 и наш первый процесс он периодически
шлет в pts/22 инфо и она выскакивает на окне терминала. в тоже время мы тоже сидя за клавой
может чтото писать на терминале. тоесть мы имеем два процесса которые одновременно вывоводят в 
один терминал. насколько я понимаю что просиходит при запуске в баш команды в бекграунд режиме 
то форкается процесс в нем запускается команда но исходный баш процесс не помещается в режим sleep
а продолжает свою работу. 

 а вот еще пример

 $  ( while true; do     sleep 10; read var1; done )&

 тут получается что процесс должен считать с клавы. так вот у нас получится что есть 
 два процесса с одним pts и оба процесса в какойто момент времени будут читать с клавы
 так вот незнаю как но баш делает так что если бекграундный процесс лезет читать в то время как 
 исходный баш процесс читает ведь с клавы так вот бекграуден процесс тут же будет остановлен 
 башем.  с точки зрения статуса данный процесс будет переведен в статус "T" когда он попытается
 счиатть с клавы наряду с исходным баш процессом.


====
каналы 1 ,2 

по поводу пернаправления вывода

find / 2>/dev/null

что там происходит по капотом в этом случае. что за загадочные цифра 2.
на самом деле все просто. создаетя процесс который обслуживает find
и у него есть файловые дескприоры 

/proc/$$/fd/{0,1,2}

так вот мы башу закаываем чтобы он когда будет создавать процесс под команду find
чтобы он дескпритор 2 перенарпавил (тоесть что у него будет бекендом ) не на экран ( тоесть не на /dev/pts/17) а в /dev/null вот и все

$ sudo ls -1al /proc/20920/fd
lrwx------ 1 root root 64 мая 17 23:42 0 -> /dev/pts/32
l-wx------ 1 root root 64 мая 17 23:42 1 -> 'pipe:[1662807]'
l-wx------ 1 root root 64 мая 17 23:42 2 -> /dev/null


вот четко видно что 

2 -> /dev/null

что файловый дескриптор 2 ( в который процесс кидает поток с инфо о ошибках) совать в /dev/null

вот как работает под капотом вся эта хрень с перенапраавлением ввода вывода!















===
processes 'R' 'D' status
+ kernel mode

It is not 100% beatifull answer but it can give you a flavour. If you have some process that constantly in 'R' state - you can start to monitor two fields from procfs:

$ awk '{print $14, $15}' /proc/$$/stat 
you will see something like: 0 3915

The first number shows 'Amount of time that this process has been scheduled in user mode, measured in clock ticks' , the second one shows 'Amount of time that this process has been scheduled in kernel mode, measured in clock ticks'. (please have a look at man proc for the details).

However the point is if 3915 is growing fast and 0 is not growing it means the process is running under kernel mode right now. The more fast 3915 is growing the more we can be sure that the process is running under kerhel mode.

an example:

$ sudo dd if=/dev/nvme0n1p2 of=/dev/null bs=30M count=1000

    $ top

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                   
16691 root      20   0   45352  32712   2112 R  50,5  0,2   0:06.00 dd

  
$ awk '{print $14, $15}' /proc/16691/stat 
0 467

$ awk '{print $14, $15}' /proc/16691/stat 
0 512

$ awk '{print $14, $15}' /proc/16691/stat 
0 557

$ awk '{print $14, $15}' /proc/16691/stat 
0 594

$ awk '{print $14, $15}' /proc/16691/stat 
0 630

$ awk '{print $14, $15}' /proc/16691/stat 
0 666

$ awk '{print $14, $15}' /proc/16691/stat 
0 699
So we can say - yes, the process is running under kernel mode.

As for 'D' state:

As for 'D' state (correct me if i'm wrong) - it means the process in a "sleep" state. It is 'uninterruptible sleep' state anyway it is a sleep state , it means the code of the process (user space) or invoked kernel code via syscall IS NOT scheduled on cpu until some necessary data\structure is available. So i suppose the processes in 'D' state should be excluded from the review. Why? Because they just not executed on cpu at all. However there is a subtle moment. The process can switch between 'D' and 'R' states quickly so we can think the process is in 'D' state however it goes from time to time to 'R' state.

Let me give explanation in details: Very often people say that if a process in 'D' state it means it waits some I\O. It is not necessarily so.

Simple program in C.

$ cat 30.c
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {

    pid_t pid = vfork();

    if (pid == 0) {
    sleep(180);
    return 0;
    }

      printf("parent: I am exiting\n");

     return(0);
}
Compile.

$ gcc -o 30.exe 30.c
Launch.

$ ./30.exe
It uses vfork that creates a child process. The parent process will be blocked until child exits. Also the state of parent process will be 'D'.

$ ps  aux | grep 30.exe
vasya     6495  0.0  0.0  10700   964 pts/66   D+   03:30   0:00 ./30.exe
vasya     6496  0.0  0.0  10700   964 pts/66   S+   03:30   0:00 ./30.exe
So the parent doesnt do any i\o operations but have 'D' status.

Next - Lets have a look if process with 'D' uses cpu. So lets check if it really sleepls.

$ while true; do cat /proc/6495/stat | awk '{print $3, $14, $15}'; done
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
D 0 0
As we can see it is.

Next. Very often we can see a process is in 'D' state however "top" shows it consumes CPU. How is it possible? The quick answer - the process switches between 'D' and 'R' states. It can happen very quickly. Remember "top" reads all the information from procfs. By default "top" refreshes all the data every 3 seconds so if the process switched very often to 'D' state and not so often to 'R' state it will seem to us as the process lives all the time in 'D' state. However it is false assumption.

The next important point is that the state of the process is a property of instant moment. That is when we are talking about the process has "D" state we mean it is in this state at this particular time. However when we are talking about CPU consumption - it is not about property of instant moment of time. It is average value FOR SOME PERIOD OF TIME. Pls have a look at the picture:

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND
13416 vasya     20   0   24024   5308   2132 D  62,9  0,0   0:05.02    dd  

                                                                                                                  
We see that the state = 'D' %CPU = 62,9

It means that at the moment (right now) the state = 'D' It means right now process does not consume cpu cycles , however some time before the process was NOT in 'D' state and it was consuming cpu cycles. So for the simplicity "top" calculates the average for the last three seconds. It can be like so:

Now - 0%
1 sec ago - 62,9%
2 sec ago - 62,9%
3 sec ago - 62,9%

the average = (62,9%+62,9%+62,9%+0%)/(1+1+1) = 62,9%
So thats why "top" shows 62.9% of cpu usage in spite of the state of the process is 'D'.

To proof that 'dd' switches between 'D' and 'R' states:

$ while true; do cat /proc/13416/stat | awk '{print $3, $14, $15}'; done
R 0 745
R 0 745
D 0 746
D 0 746
D 0 746
D 0 746
D 0 746
D 0 746
R 0 746
R 0 746
R 0 746
R 0 747
R 0 747
R 0 747
R 0 748
D 0 748
D 0 748
D 0 748
D 0 748
R 0 748
R 0 748
R 0 749
D 0 749
R 0 749
R 0 749
D 0 750
D 0 750
D 0 750
D 0 750
D 0 750
D 0 750
R 0 750
R 0 751
R 0 751
R 0 752
R 0 752
R 0 752
D 0 752
D 0 752
D 0 752
D 0 752
D 0 752
R 0 753
R 0 753
D 0 753
D 0 753
D 0 753
D 0 753
R 0 754
R 0 754
R 0 755
R 0 755
D 0 756
D 0 756
About the meaning of $14 and %15 fields: As for "man proc":

$14 = Amount of time that this process has been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
$15 = Amount of time that this process has been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).

As you can see "dd" switches between 'R' and 'D' states. Thats why average cpu consumption is not 0%.

Also you can see that while the process really in 'D' state it does not consume cpu cycles neither for user mode nor for kernel mode.

As the final suggestion: if you have a process and want to know if it is running right now in user or kernel space --> start monitoring

$ cat /proc/13416/stat | awk '{print $3, $14, $15}';
If $14 is changing - it means the process in user space, if %15 is changing - it means the process is in kernel space

Hope it helps

Еще добавок про S и D состояния процесса.
Если у процесса состояние S то это означает две вещи: 
1. код программы (непосредственный код программы) шедулером больше неразмещается на цпу. Он физически больше непопадает на цпу.тоесть код процесса реально больше непопдает и неисполняется на цпу. а если процесс сделал сисколл тоесть вошел в ринг0 и код ядра. то тоже самое. и ядерный код неразмещен шедулером на цпу. таким образом ни юзерский
код процесса ни вызыванный код ядра через сисколл - ничего из этого на данный момент неразмещено на цпу. ( на данный
момент потому что статус это характеристика типа instant тоесть вот оно как прям щас)  

2. Плюс статус S означает что процесс принимает сигналы. таким образом например работу
процесса можно прервать прям щас.
что значит процесс принимает сигналы.значит что ядру разрешено
в таблицу процессов данному процессу записать свойство сигнал. а шедулеру разрешено тут же взять 
и запустить обработчик этого сигнала. тоесть по факту это нето что там код процесса чтото решает принимать ему или нет. это один кусок кода ядра разрешает другому куску кода ядра сделать 
изменнеие в таблице процессов для данного процесса. а шедулер увидев что в свойствах процесса
появилось своства сигнал запустити обрабочик сигнала. сам процеесс ничего нерешает.

Сразу скажу про статус 'D' он такой же самый только нет пункта два. тоесть 
нельзя процессу доставлять сигналы. запрещено. таким образом пока процесс имеет статус 'D' никак неповлиять на него через сигналы. (кроме ребута). Когда процесс выйдет из статуса 'D' то сигналы что ему слали (они сохраняются) будут ему наконец "доставлены".


далее. вверху я уже написал  на английском  но еще раз скажу:
если у процесса статус S или D то согласно пункту один код процесса шедулером неразмещается
на цпу и также если проецесс сисколл вызывал то его код тоже неразмещается на цпу. дело в том 
что да если процесс вызывал сисколл то как это работает в паре с шедулером? отображается ли 
работа ядерного кода в статусе процесса или нет. ответ да. когда вызывано ядро через сисколл 
то условно гооворя запускается функция просто она физически размещается не в коде программы
а в отдельных других файлах в которых код ядра (условно говоря либо в вбиблиотеке libc либо в ядре vmlinuz) так вот что там происходит. а ничего особого. цпу перекчается в ринг0. да там немного 
меняютсяс пара регистров , условно говоря ссылка на стек меняется но в целом ядерный код начинает
работать в окружении регистров и вирт памяти которая осталась от процесса. да ядерный код помимо 
вирт памяти процесса также может лазить в память ядра но в целом как пишут книжки ядерный код
работает в окружении процесса. и вот далее важно. один момент это то что вот на цпу работает ядерный код. далее происходит таймер интеррапт и цпу прерывает работу этого ядерного кода 
без проблем ему похер ядерный код или юзерский. далее появляется шедулер. и он как то понимает 
что этот ядерный код он относится к процессу и он во первых выдавливает этот код с цпу, сохраняет
все что нужно в свойствах процесса гдето в памяти причем ссылка на команду идет именно на 
ядернй код там где была остановка из за интерапта и шедулер обновляет статистику толтко что заюзанного  тайм слайса со стороны ядерного кода в статистику работы именно процесса.
так что мы имеем два момента , один это то что цпу когда ядерный код выполняет то его можно прервать
и второе что шедулер то время которое ядерный код работал по вызыву процесса зачисляет в статистику
самого процесса в procfs так что мы четко можем быть уверены что время работы ядерного кода на цпу
будет отражено именно в статиске процесса а значит мы увидим в top работу ядерного кода для процесса
в статистике процесса в плане cpu usage. иначе получалась дурацкая ситуация ядерный код по запросу
нашего процесса работает но мы невидим эту статистику в свойствах процесса и думали бы что процесс
прохлаждается . неважно в рамках нашего процесса код из нашей программы крутится на цпу и внешняя функция из ядра - по факту это все ресурсы запользованные нашим процессом так что статистика
должны отражаться в свойствах процесса. потмоу что было непонятно вот заустил процесс сисколл 
цпу перешел в режим ядра и где искать сколько cpu usage сейчас жрет этот сисколл. оказывается 
искать ненадо. его cpu usage засунут в свойства процесса как бутто это щас код из процесса 
и крутится на цпу. получается если мы в top видим что у процесса есть какйото cpu usage то 
мы неможем навскидку сказать это время когда цпу работал в юзер моде или в кернел моде 
потому что там указана их сумма. ( конечно надо понимать что в рамках процесса цпу в каждый момент времени работает либо в юзер моде либо в кернел моде но неодновременно).

также еще ращ скажу важно понимать что характеристика статус процесса типа "S"\"R"\"D"
это характиристика в конкретной точке времени. тоесть скажем прям щас. 
втоже время cpu usage в рамках команды top (потому что в procfs там нет этого параметра в чистом виде) это характеристика не про момент времени а за некоторый пропмежуток времени средняя величина.
Поэтому если мы видим что статус процесса S\D но в тоже время его cpu usage неравен нулю тут 
нет никакого противоречия потому что S\D статус относится к тому как это щас у процесса а его
cpu usage относится к промежутку времени между три секунды назад и щас. (три секунды это дефолтовое
время усреднения со стороны top). тоесть это значит что в моменты времени до нашего текущего
у процесса было переключение на статус R (это 100% и процесс жрал цпу. жрал это значт что он занимал кванты времени находясь на цпу своим кодом). вот поэтому и нет противорречия. да если щас статус S то прям щас процесс использует цпу на 0%. но еще раз top непоказывает на сколько % процесс
исполует цпу прям щас . потому что на самом деле нет такой характеристики на сколько % процесс занимает цпу прям щас. потому что прям щас процесс либо выполняется на цпу тоесть он его занял
либо он невыполняется. но процентов никаких нет в этом плане в природе. процент получается исходя
из совершенно другого если унас есть три промеждутка времени. ( это то как это работает со стороны шедулера) и скажем в первый промежуток у нас код находился на цпу на втором он ненаходился и на третьем он анаходидся то это значит что с точки зрения времени сколько процесс находился на цпу это будет 100%*(1+0+1)/3 =67% тоесть показатель cpu usage это показатель сколько времени процесс находился за заданный проемежуток времени на цпу ане то что прям сейчас цпу работат на 67% своей мощности. у цпу нет никакой мощности он либо работает щас на 100% либо нет. просто кажому процессу
дается небольшой квант времени. и cpu usage это отношение сколько таких квантов процесс находился на
цпу к общему числу квантов времени. поэтому никакого парадокса в top нет. вот как в этом примере

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+   COMMAND
 2185 vasya     20   0 3181856 282088  50380 S  25,9  1,7   377:25.95 cinnamon 

статус S это то как щас а 25.9%CPU это в среднем за последние 3 секунды.
почуствуй разницу между "щас" и "за последние три секунды"

еще подчеркну что cpu usage в точке щас такого понятия вобщемто нет. точнее оно есть
но оно неудобное. процессор щас либо занят CPU usage его 100% либо незанят и тогда 0%.
это нам ничего недает.

далее я еще раз  обсуждаю часть то что сказал выше  а часть нового:
также суперванжно добавить что процесс себя сам выдавить из цпу неможет. самс себя убрать из цпу
процесс неможет. нет ассемблерной команды которая бы выдавила процесс из цпу. вообще что значит
выдавить процесс из цпу. это значит что на какое то время код процесса небудет размещаться на цпу. а ведь только в этом случае процесс будет иметь статус S\D.
это может сделать толко шедулер ибо он в очередной квант времени сует код код процесса на цпу
а код других процессов несует.в юзерспейсе нет такой команды асемблера которая бы обратилась
к шедулеру и сказала мол все я закончила давай убирай меня из цпу. (этот факт что программа сама добровольно обратилась  к шедулеру и сказала мол я закончила раньше времени либо я буду ожидать наступление некоего события поэтому можешь пока выдавливать меня называется voluntary_ctxt_switches
тоесть это процесс сообщил добровольно шедулеру что он может выдавливать этот проецсс из цпу на какоето время. так вот я утверждаю что из кода юзерской программы это невозможно сделать, тоесть 
самому себя выдавить из цпу невозможно а даже если бы это было возможно то об этом бы незнал шедулер , шедулер бы считал что процесс отработал на цпу полный квант времени и статистика по процессу в procfs была все равно такая что как бутто он отработал полный квант в любом случае
сам код программы это сделать неможет работая в юзер спейсе он это может сделать только вызвав
ядерный код через сисколл. я несмотрел код сисколлов но я точно уверен что добровольная отдача обратно цпу а другими словами запрос к шедулеру о том чтобы он выдавил процесс из цпу и вставил другой находится в сисколлах. самый простой сисколл который может это сделать это nanosleep(), 
если в баше то это /bin/sleep, если через асемблер запускать то это сискол номер 35, если пишем на
C то там это вызывается через libc обертку sleep(), остальные сисколлы они там сами решают
когда они хотят сделать запрос к шедулеру чтобы он выдавил процесс из цпу.  еще раз напомню 
что добровольная отдача цпу что по факту никакая неотдача а запрос к шедулеру чтобы он выдавил
процесс из цпу назвыается voluntary_ctxt_switches. так вот я еще раз скажу что я считаю что 
это может сделать только сисколл. делает он это неспрашивая нас когда мы его вызываем например
наша програма  ждет нажатия кнопки для этого мы вызываем сисколл который этим занимается, сисколл
выставляет условие в ядро о том когда процесс надо будить и сисколл просит у шедулера выдавить
процесс из цпу и небудить до момента наступления нажатия кнопки. так и только так происходит voluntary_ctxt_switches . из кода программы юзерского мы так сделать неможем никак а может только 
вызывав сисколл. причем сисколл nanosleep() через него мы в явном виде заказываем выдаволение процесса с цпу на заданное время , другие же сисколлы сами определяют когда на какое время или до наступления какого условия выдавить процесс из цпу и делают запрос к шедулеру тоесть вызывася эти
сисколлы мы понятия неимеем как когда зачем и почему данный сисколл закажет выдавливание ( ака добровольный конекст свич) потому что мы вызываем эти сисколлы для других целей например прими нажатие от кнопки. цель этого длинного куска была втом чтобы обьяснить как на практике и откуда
получается добровльный контекст свич. оценить как часто сисколлы нашей программы заказывали
добровольное выдавливание можно через:

	$ cat /proc/$$/status | grep switch
	voluntary_ctxt_switches:	172
	nonvoluntary_ctxt_switches:	5

соответвенно nonvoluntary_ctxt_switches - это недобровольное выдавливание процесса из цпу 
со стороны шедулера. когда это происходит - тогда когда программа работает но ее тайм слайс 
так уж вышло закончился. тогда шедулер принудительно выдавилвает процесс из цпу. я бы еще добавил 
так что если процесс все время нахрится в состоянии 'R' то у него конечно будут только сплощные
nonvoluntary_ctxt_switches потому что его нужно будет постоянно выдавиливать. а если процесс
слабо нагруженный который часто в "S" то у него буду преимушественно voluntary_ctxt_switches.
оно ипонятно процесс сам по себе в состояние S перейти никак неможет, для этого он обязательнро 
должен вызывать сисколл в котоом наверняка будет выдавилвака процесса из цпу , слабонагруженность
это прямое следствие статуса S и выдавиливалки в сисколле том или ином.

посмотрим для примера статистику по процессам:

$ cat /proc/1/status | grep switch
voluntary_ctxt_switches:	  34780
nonvoluntary_ctxt_switches:	 1194

логично.

а тепер вот такую программу возьмем

$ cat 24.c
#include <stdio.h>
#include<unistd.h> 


int main () {

   /* local variable definition */
   pid_t pid;
   pid = getpid();
   printf ("pid = %d\n",pid);

   int a = 10;
   /* while loop execution */
   while( a < 20 ) {
   }

   return 0;
}

тоесть по факту это просто пустой бесконечный цикл.

компирлируем
$ gcc -o 24.exe 24.c

и сразу для интереса дизасемблиуриуем:
$ objdump -b elf64-x86-64 -M intel  -d 24.exe

000000000000068a <main>:
 68a:	55                   	push   rbp
 68b:	48 89 e5             	mov    rbp,rsp
 68e:	48 83 ec 10          	sub    rsp,0x10
 692:	e8 b9 fe ff ff       	call   550 <getpid@plt>
 697:	89 45 f8             	mov    DWORD PTR [rbp-0x8],eax
 69a:	8b 45 f8             	mov    eax,DWORD PTR [rbp-0x8]
 69d:	89 c6                	mov    esi,eax
 69f:	48 8d 3d ae 00 00 00 	lea    rdi,[rip+0xae]        # 754 <_IO_stdin_used+0x4>
 6a6:	b8 00 00 00 00       	mov    eax,0x0
 6ab:	e8 b0 fe ff ff       	call   560 <printf@plt>
 6b0:	c7 45 fc 0a 00 00 00 	mov    DWORD PTR [rbp-0x4],0xa
 6b7:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
 6bb:	7e fa                	jle    6b7 <main+0x2d>
 6bd:	b8 00 00 00 00       	mov    eax,0x0
 6c2:	c9                   	leave  
 6c3:	c3                   	ret    
 6c4:	66 2e 0f 1f 84 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
 6cb:	00 00 00 
 6ce:	66 90                	xchg   ax,ax


на самом деле цикл while 
это вот эти две команды которые будут крутится вечно

 6b7:	83 7d fc 13          	cmp    DWORD PTR [rbp-0x4],0x13
 6bb:	7e fa                	jle    6b7 <main+0x2d>

ну это чисто так для интереса мы дизасмлировали чтобы посмотрть как С програма будет
выглядит на асемблере.

так вот такая программа неимеет в своем цикле никаких сисколлов так что
эта программа хочет крутится на цпу все время (потому что без вызоыва сисколла программа 
претендует вечно занимать цпу ровно за этим и нужен шедулер), соттвенвенно статус у процесса будет R
все время и загрузка по цпу 100% птому что программа будет стремиться занимать все таймслоты что ей даст шедулер а шедулер будет вынужден выдалавить процесс хотя бы порой. вот щас это и проверим

запускаем
$ ./24.exe
pid = 20260


  PID USER      PR  NI    VIRT    RES    SHR     S  %CPU     %MEM     TIME+ COMMAND                
20260 vasya     20   0   10832    968    868     R  100,0     0,0   0:23.64 24.exe  


$ while true ; do cat /proc/20260/status | grep switch; sleep 1; done
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	73
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	73
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	74
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	76
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	77
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	79

видно что у программы нет ниодного добровольного отдачи цпу потому что да его и нет 
в коде програмы потому что у нас в цикле нет ниодного сисколла. так что щедулер 
исключтельно принудительно nonvoluntary выдавливает процесс из цпу.
цикл снятия статистики выдает ее раз в секунду ( а мы помним что щедулер срабаывает примерно
100 раз в секунду) так что из статистики видно что шедулер далеко некаждый раз выдавливает 
нащ процесс из цпу (иначе бы за секунду он это делал 100 раз а мы видим что за две секунды бывает
что и ни разу), так что программа резвится на цпу очень даже хорошо , лишь иногда шедулер
все таки выдавивет ее из цпу. отсюда мы делаем три вывода: 1) шедулер далеко не каждый тайм слайс (10мс) выдавливает процес из цпу, 2) если в коде программы нет сисколла ( у нас конечно есть в программе сисколлы но вне цикла while тоесть до них очередь недошла) то ни о каком добровольной 
отдаче цпу и речи неидет для этого обязательно нужно вызывать сисколл в коде программы. 3) даже если в системе есть свободные ресурсы то все равно время от времени шедулер выкидывает процесс
из цпу это значит что система недаст процессу 100% времени на цпу иногда всеже она будет
его на немного выдавливать. опять же незабываем что интеррапты приходят на цпу и немало и 
их обработка она же тоже жрет время цпу так что даже на многопроцессорной системе часть мощности
цпу будет вседа уходит по крайней мере на обработку интераптов( я так посмотрел в top цифра si и она доходит порой до 4%). так что будем ссчитать что в лучшем случае процесс может сидеть на цпу на уровне 96%.




пример с nanosleep
$ cat 37.c
#include<stdio.h>
#include<time.h>


int main()
{

     const struct timespec kuku = {300, 100};
     struct timespec kuku2 = {3, 100};

     nanosleep(&kuku, &kuku2);

    return 0;
}


через этот сисколл мы просим шедулер выдавить из цпу наш процесс на 300 секунд и еще 100мс
компилируем запускаем:
$ gcc -o 37.exe 37.c
$ ./37.exe

дальше интерсно я подождал скажем минуту а дальше смотрю статистику
$ cat /proc/24455/stat | awk '{print $3, $14, $15}'
S 0 0

про $14 и $15  я уточню интересное это сколько цифры . первая про юзер спейс вторая про кернел спейс. сколько времени процесс работал в юзер спейсе и в кернел спейсе тоесть сколько времени
процесс выполнял юзерский код а сколько времени проецесс выполнял сисколлы. так вот интересно тут
то что в каких единицах времени это меряется. в man proc написано что цифры обозначают clock tics
сразу скажу что это не цпу клоки и все такое. 1 clock tic это время между вызовами шедулера это 
один тайм слот. вот $14 и $15 показывают число тайм слотов в штуках которые процесс провел на цпу.
далее они предлагают число этих штук этих слотов поделить на sysconf(_SC_CLK_TCK) по дефолту
оно равно 100. тоесть 100 раз в сеунду срабывает таймер интеррапт и вызвается шедулер .таким 
образом если мы поделим тайм слоты на 100 то узнаем в секундах ( а в не в штуках слотов) процесс
прокрутился на цпу. 

  на мой взгляд поэтому немного странно получаенные цифры S 0 0. что как бутто процесс
  непровел на цпу ни единого тайм слота. хотя.. может быть %14 и %15 округляет до целых ведь процесс может провести на цпу толко часть тайм слота а потом попросить щедулер его выдавить.
  тайм слот очень большой целых 10мс. за это время туча кода может отработать. а наша программа
  мелкая и вся заточена под скорейшее выдавливание из цпу. так что может 0+0 это и реальная цифра 
  тоесть программа провел на цпу какоето время но существенно меньшее чем даже 1 тайм слот 10мс.


 теперь посмотрим на 

 $ cat /proc/24455/status | grep switch
voluntary_ctxt_switches:	1
nonvoluntary_ctxt_switches:	0

это было снято через минуту уже как программа была запущена.
тут мы видим что процесс ощутил на себе всего одно добровольное выдавливание из цпу.
и больше ни одного выдавливания небыло. это показывает то что цисло эти switch оно обозначает
сколько раз реально из цпу код процессы был выкинут. это значит что такое минимальное количество
раз код точно побывал на цпу и его выкинули. это незначит что ровно такое число процесс был
на цпу. число может быть гораздо больше скажем для постоянно работющего процесса. как я показал
выше шедулер постоянно рабоатающий проецесс при налиичии ресурсов выдавливает далеко некаждый 
цикл. так что сколько секунд или циклов (которые можно пересчитать в циклы умножив на sysconf(_SC_CLK_TCK) который обычно равен 100) процесс провел на цпу можно посчитать заглянув в 
$14 и $15. а в  voluntary_ctxt_switches и nonvoluntary_ctxt_switches указано реально 
сколько раз код был выкинут,выдавлен из цпу.

вот в нашем конкретном примере четко можно увидеть что код залетел на цпу был выкинут 
и больше код на цпу недопускался.

получается возьмум pid=1
$ cat /proc/1/stat  | awk '{print $14, $15}'
999 1390

получается на цпу он отработал всего (999+1390).100~24c при том что аптайм 12 дней. но тут нет 
парадокса потому что $14 и $15 это же то суммарное время когда код процесса реально работал на
цпу а процесс init он же постоянно спит 'S' так что все нормально. указано чистое время
сколько код процесса реально крутился на цпу. аптайм здесь ни при чем.

а вот если мы возьмем процесс который постоянно раотает статус R у него $14+$15 должны очень
точно совпдаать с временем как мы его запустили (при наличии ресурсов у компа то есть процесс
дейсвительно должен потоянго быть R )


запустим такую программу которая просто цикл
#include <stdio.h>
#include<unistd.h> 


int main () {

   /* local variable definition */
   pid_t pid;
   pid = getpid();
   printf ("pid = %d\n",pid);

   int a = 10;
   /* while loop execution */
   while( a < 20 ) {
   }

   return 0;
}


я запустил а далее

$ cat /proc/25506/stat | awk '{print $14, $15}'
1462 0

получаем что программа крутится на цпу ~15c и да это похоже на правду (засекал с секундомером).

а вот еще чуть позже  я посмотрел статистику для этого процесса
$ cat /proc/25506/stat | awk '{print $14, $15}'
10882 2
$ cat /proc/25506/status | grep swi
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	1246

получается что процесс отработал на цпу ~11c
из них он недобровольно (оно и понятно почему ) был выдавлен с цпу 1246 раз.

это значит что он неработал после этого хотя бы один цикл цпу прежде чем быть назначен обратно
это значит 1246\100 = 1.2с 

ну тоесть процесс отработал на цпу (10882+2) циклов а его выдавили из цпу 1246 раз. тут
конено возникает вопрос сколько времени занимает процесс выдавливания процесса из цпу
потом сколько времени процесс ждал пока его обратно засунуть на цпу потом время которое нужно
чтобы его всякие там регистры засунуть в цпу  это все потеря времени. ну если например предпололо
жить что что каждый раз когда его выдавили из цпу то весь процесс обратного его ожидания и сования
на цпу составил всего один цикл (хотя может и быстрее а может и медленее) тогда получается что 
с того момента как процесс запустили он простаивал 10% времени.

так в /proc/$$/stat  в поле $39  показывается номер ядра на котором раобтает процесс.
я запустил процесс и статистику снова. получил такое. 

~$ while true; do cat /proc/25919/stat | awk '{print $14, $15, $39}'; sleep 1; done
3301 0 1
3401 0 1
3502 0 1
3602 0 1
3703 0 1
3803 0 1
...
8730 0 1
8830 0 1

$ cat /proc/25919/status | grep swi
voluntary_ctxt_switches:	0
nonvoluntary_ctxt_switches:	28


тоест процесс выдавливался шедулером 28 раз недобровольно.
но небыло смены цпу все время процесс работал на ядре номер 1.
получется процесс отработал на цпу ~8.8с и был выдавлен 28 раз.
если процесс выдавливания и обратгного размещеия считать занимал 1 цикл (что нефакт что это так по времени может меньше может больше) то получается что (28\8830) ~= 3% процесс простаивал. 
интересно.


далее будет частичное повторение уже сказанного и часть нового. 
про ассемблерную команду nop. которая ничего недалает. влияет ли ее применение на уменьшение  
cpu usage в выводе top. короткий ответ - нет нихрена невлияет вообще.
 если мы в программе разместим цикл с асемблерной
командой NOP которая по факту внутри цпу ничего неделает это нам ничего недаст потому что 
по факту цпу ничего неделает но с точки зрения шедулера код процесса все равно исполняется на цпу
формально команда nop это тоже команда. код неисполняется значит то что на цпу работает код от 
другого процесса а нето что на цпу выполняется NOP от данного процесса. 
как шедулер высчиывает цпу юзэж процесса он считает циклы цпу в течение которого код выполняется
на цпу (можноу ивдеть в procfs) , далее как top высиытает cpu uxsage  - он берет некий интервал. 
смотрит солько это в тиках цпу. а потом делит сколько тиков процесс сидел на цпу на число тиков на 
инетрвале. получем cpu usage %. здесь важно быол понять что из юзерсепейса процесс сам себя в состояние S перевести неможет так как для этого он должен удалить сам себя на какоето время 
из цпу.  насколько я понимаю дажебы если бы процесс мог такое сделать то об этом бы незнало ядро.
тоест скажем процесс некоей конмандй остановил свое выоплолнение на какое то время до момента
насутлпения таймер интеррапт на цпу. но при этом процесс его регистрвы все равно занимают
цпу а сам процесс неможет себя вычистить из цпу. но тем неменее на каком то интервале до настулпния
таймер интеррапт он бы невыполнялся но фишка в том что ядро и щедулер об этом бы незнали 
и  с их точки зрения процесс сидел на цпу все кванты времени поэтому перменые статистики в /pric/pid/ все равно бы были такие что как бутт процесс выполнылся на цпу. поэтмоу такое невозоможно 
через юзер код. а вопзомоно только если попрпоситьоб этом шедулер. тоесть нужно передать управление
шедулеру с прсобой вычистить регистры от этого процесса и загрузить туда другой и обновить
параметры статистикии  в процфс вот только тоггда для ядра процесс рельно неисоплнется на цпу
и его статус будет S. поэтому процесс состоящий из одиеих команд NOP будет выглядеть в 
top как процесс который на 100% жрет цпу. хотя казалось бы он ничего неделаеи. но это он 
неделает по факту. но с точки зреня шедулера на цпу лежат регистры именно нашео процесса,
выполняется порядок команда нашего процесса и другого процесса на цпу нележит в этот квант времени прэтому с тчоки зерения шедулера цпу занят нащим процессом. важно было разсянить этот экспримент.



двигаем дальше перехоим к рассмотрению переменной /proc/21944/syscall.
так как уже было сказано что если статус процесса R тоесть это означает 
что прям щас на цпу выполняется либо код программы (user space) либо код ядра вызыванный
через сисколл (кернел спейс) то нам непонятно нам хочется знать так щас что выполняется
код программы или кернел код. как это узнать. 

узнать это можно если посмотреть что покажет proc/$$/syscall
$ sudo cat /proc/21944/syscall

если там будет слово
running

это значит что на данный момент выполняется юзерский код программы.

strace при этом покажет вот это:
$ sudo strace -p 19356
strace: Process 19356 attached
strace: [ Process PID=19356 runs in x32 mode. ]


а если там будет вот чтото такое
270 0x1 0x7ffce82706c0 0x0 0x0 0x0 0x7ffce82705f0 0x7ffce82705b0 0x7f24978ceec9

тоэто значит что сейчас на цпу выполняется ядерный код вызыванный через сисколл

270 это номер сисколла котоый щас выполняется.
270 это pselect6 (согласно /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h) 

также убедиться в этом же можно если присодиниться к процессу через strace

$ sudo strace -p $PID
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

единственное что мы можем неуспеть то есть пока мы подкючимся процесс будет уже выполнять какото другой код.


а что покажет /proc/21944/syscall если у нас процесс спящий тоесть его статус 'S'\'D'.
отвечаю что он покажет номер сисколл который значит то что до того как процесс впал в спячку
цпу был занят выполнением этого сисколла. более того я утрвеждаю что именно этот сисколл и был
тем кодом который попросил шедулер вогнать процесс в спячку. я там далее ниже показал это 
на примере запущенной команды $ sleep 180

еще хочу добавить про /proc/pid/wchan вроде бы он вцелом показыает тоже самое что и /proc/pid/syscall но я читал  в инете что этот wchan порой показыает хрень так что на него лучше неполагаться.

итак подвеем итоги по /proc/pid/syscall.
если статус процесса "R" и цпу выполняет юзерский код то /proc/pid/syscall покажет "running"
если статус процесса "R" и цпу выполняет кернел код то /proc/pid/syscall покажет номер сискола
который щас исполняется
если статус процесса "S"/"D" то /proc/pid/syscall покажет номер сисколла который выполнялся на цпу
до того как процесс начал спать, более того это имено тот сисколл который попросил шедулер вогнать
процесс в сон, и конечно на данный момент этот сисколл невыполняется на цпу.


далее повтор того что уже сказано и возможно часть нового.
интересенйшая вещь. команда asm nop хотя она по факту ничего неделает на цпу но процес в цикле 
с этой командой будет показывать статуст R 100%. потому что cpu usage в top\proc происходит с той
точки зрения выполнялся ли код на цпу. а такак nop это все равно команда то с точки зрения шедулера
или другими словами ядра - код выполнялся, поэтому небудет нкиких 0% cpu usage. 0% cpu usage возможно толко 
тогда когда код процесса физиечески шедулером неразмещается на цпу. поэтому 
я скажу так что переменстить процсс в состояние S невомозможно без вызовы хоть какого то
сисколла в проетсейшем случае это sleep. нужн какойто ядерный код который соощит шедулеру о том 
что код этого роцеса ненадо пихать на цпу столко то времени либо до настулпнеия такого то события.
опа!!! поэтому можно быть 100% увреным что у всех проецссов в состоянии S в его /proc/$$/syscall 
стоит имя какого нибуль сисколла! именно этот сисколл и сунул процесс в состояние sleep говоря другими словами попросил щедулер исключить процесс из цпу либо на промежуток времени либо до наступления какогто события.

сделаем пример. команда sleep

$ sleep 180
процесс будет в состоянии S в течение 180 секунд.
посмотрим через strace какой сисколл щас она покажет
$ strace ...
...
nanosleep({tv_sec=180, tv_nsec=0}, 

посмотрим какой сисколл указан в /proc/$pid/syscall 
$ sudo cat /proc/29719/syscall
35 0x7fff0baec2f0 0x0 0x0 0x0 0x0 0x0 0x7fff0baec2e8 0x7fba62d9e774

номер 35. 
найдем имя этого сисколла
$ cat /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h | grep 35
#define __NR_nanosleep 35

совпадает с тем что показывает strace.
Получается что имя сисколла который показывает strace и который показывает /proc/$pid/syscall
если статус процесса 'S'\'D' то это не имя сисколла котрый щас выполняется на цпу . нет. это 
имя сисколла который выполнялся последним до того как процесс вошел в состояние 'S'\'D'.
по факту я утверждаю что именно этот сисколл и вогнял процесс в состояние 'S'\'D'.
существенно тут то что сисколл щас невыполняется. нет. он выполнялся до того как процесс вошел в
спящее состояние но щас он невыпоняется. также можно смело утверждать что именно выполнялся сисколл
а не чтото иное до того как процесс вошел в спящее состояние. и еще раз именно указанный сисколл
и вогнал процесс в спящее состояние. естственно не только сисколл 35 умеет вгонять процесс в спящее
состояние. таких сисколлов вагон. важно тут было понять то что значит имя сисколла который мы видим
в /proc/$pid/syscall если статус процесса 'S'\'D'. еще раз смысл найденного сисколла в том что это 
было последнее что выполнял цпу для данного процесса прежде чем процеесс вошел в спящее состояние.
сейчас код процесса ни юзерский ни сисколловый на цпу невыполняется , оно все вытеснено. и то что
именно этот сискоолл и вогнал процесс в спящее состояние.



далее опять повторение того что выше и может быть чуть нового.
nop только на powerconsumption влияет а на статус S и на цпу юзадж
с точки щрения шедулера никак! ведь ядро как определяет cpu usage - по числу таймслайсов в теччение которых код выполнялся\размещался (что одно и тоже) на цпу. пусть даже эта команды nop. nop невозвращает управление шедулеру ядру ОС. это такая же обычная команда как и любая другая. 
просто по факту цпу в это время ничего неделает. но с точки зрения шедулера это абсолютно неважно! вот это я хочу донести. шедулер меряет произвиодительность cpu usage для процессора исходя неиз того какие команды запускает процесс. на это шедулеру насрасть. шедулер меряет количество времени
в течение которого на цпу размещается любой код процесса. вот шедулер поместил код процесса на цпу
на 1 тайм слайс. процесс это время отработал. шедулер вытесняет код процесса (иногда оставляет но это щас неважно для простоты щас считаем что он каждый раз код вытесняет) и ставит себе галочку в 
/proc/pid/stat о том что процесс отработал на цпу +1 тайм слайс. а команда top читает это количество и делит его на три секунды (дефолтовый промежуток обнволения экрана у top). и таким 
макаром в top появляется cpu usage. тоесть в cpu usage играют рояль только тайм слайсы в течение
которых код процесса крутился на цпу. и шедулеру и top абсолютно насрать какой код крутился в те моменты будь это mov или nop или любое другое. поэтому применение циклов с nop никоим образом
неуменьшаем cpu usage для процесса. оно только уменьшает powerconsumption у цпу на которйы нам полностью насрать. единсвенйы вариант уменьшить цпу юзадж это когда наш процесс запустил команду
syscall и начад исполняться ядерный код и этот код сам решает на момент работы в таймслайсе что
уже ему сисколлу ненужен больше цпу либо на какоето время либо до момента наступлениея какогто
события и тогда сисколл обращается к шедулеру и просит его выдавить процесс из остатка таймслайса.
и вот только тогда и только по такой причине процесс на скольо то таймслайсов небудет размещаться 
шедулером на цпу. получется что на какоето время на какоето количество таймслайсов процесс больше
не размещается на цпу. он физически больше неисполняется. и это дает то что в ячейке отображения
статистики в /proc/pid/stat останавливаются поля $14 и $15 и только тогда у нас с точки зрения
top падает cpu usage. потому что если за 3 секунды у нас ненаступило приращение полей 14 и 15
то значит что 
100*[ 0/(100*3) ] = 0%  cpu usage за последние 3 секунды
где 
0 = дельта изменеия $14+$15
100 = число таймслайсов в секунду (сколько раз в секунду вызывается шедулер)
3 = интервал в секундах обновления экрана в top по дефолту

то есть мы делим количество таймслайсов которые процесс отработал за последнеи три секунды
и делим на общее число таймслайсов которые прошли за это время. это и есть как top высчитывает 
колонку %cpu usage. если процесс многотредовый то наверное в /proc/pid/stat поля $14 и $15
отображают суммарную статистику по таймслайсам для всех тредов. отсюда и получает в top цифры такие
как 200% , 400% , 1000% итд.


то как я щас себе это вижу. как процсс может попать на S состтояние.  через юзер спейс команды никак. никак сам себя процесс неможет выдавить из очереди на выполпнение шедулера. чобы это сделать
надо вызывать какойто сисколл который сформирует условие для шедулера\ядра о том что мол пока что 
меня ты с очереди выкинь то наступления некоего события. и только тошгда процесс будет шедудером выкинут из очереди на выполеннеи!

разница S и D тока в том что S разрешает прилет сигнала к процессу. а D нераазрешеает.
а так это оба процесса код которых неразмещен на цпу.

еще раз про voluntary_ctxt_switches, nonvoluntary_ctxt_switches.
оно показывает сколько прям раз код процесса находясь на цпу был выдавлен из цпу , либо добровольно
тоесть когда сисколл сам попросил об шедулер либо принудительно когда у процесса истек таймслайс
сработал таймер интеррапт запустился щедулер на этом цпу и он выдавил этот процесс из цпу.
важно здесь еще раз отметить что это не цисло сколько раз цпу проходясь по очереди runqueue доходил
до этого процесса и проверял мол ставить его на цпу или нет. это совсем нетак. во первых процесс
удаляется из runqueu а во вторых как уже сказал это неколичетсво проверок а реально число случаев
когда код процесса сидел на цпу и он был выгнан выдавлен вычищен из цпу.

на счет шедулера важнйы момент важный вопрос а как он работает в случае когда у нас много цпу в 
системе. вот на одном цпу сработал таймер интеррапт значит на этом цпу будет загружен шедулер 
и запущен. и понятно что на этом цпу шедулер сможет выдавить текущий процесс а что в это время
с другими ядрами? туда тоже шедулер в этот момент загружен или нет или щедулер на этом цпу 
сидя выдавливает процессы с других ядер . нет походу это все нетак. как я щас понимаю
когда сработал таймер интеррапт на текущем ядре и был загружен шедулер на текущее ядро 
то этот шедулер выдавливает процесс с текущего ядра только а другие ядра нетрогаются да и как
он их сможет тронуть если на тех ядрах произошел такойже таймер интеррапт. а это нет!
так что шедулер загружается на данное ядра. выдавливает процесс на данном ядре а на остальных 
ядрах работа в это время идет без изменений. потом на другом ядре происходит таймер 
интеррапт и на том другом ядре происходит индивидуальное выдавливание процесса. и так для каждого
ядра индививидуально согласно его индивидуальному срабатывания таймер интеррапт. других ядер 
это некасается. вот так я думаю работает система шедулинга в случае много ядерной машины.

==

bash, strace, 
fork, clone


поповоду того что баш если запускает команду из файла то он вначале себя 
форкает точнее испольуется сисколл clone() потом запускает execve.
убедимся на примере:

во первых если мы пишем

$ strace ls

то мы неувидим как баш делает fork ( при том что щас как я прочитал линукс неделает форк а
делает вместо него clone) но в любом случае мы это неувидим потому что как я понял strace создает 
из себя грубо говоря клон и в нем запускает уже коману и уже смотрит какие сисколы эта комнда будет
вызывать. а нам же нужно затрейсить наш баш в котором мы сидим  а не сам ls. поэтому нам надо 
отркыть второе окно и в нем запустить strace самого баша тот который  в первом окне через команду

$ sudo strace -f -p 26294   (где 26294 это pid баша из первого окна)
также можно сразу указать какие сисколлы мы хотим отслеживать

$ sudo strace -e clone,fork,execve -f -p 26294

так вот что меня удивляет.
у баш есть встроенные команды тоесть которые у него в его бинарнике /bin/bash зашиты
получается что если мы их будем запускать то башу форкать ничего ненадо. проверяем на while ибо он 
являетс builtin для баша. он встроен в бинарник баша.

(окно1) $ while :;do :; done
(окно2) $ здесь увидим пару ioctl и пару rt_sigaction

окей. все понятно все красиво. все совпадает.

а теперь пробуем команду echo

с одной стороны баш пишет что это его встроеный builtin

$ type echo
echo is a shell builtin

с другой стороны 

$ which echo
/bin/echo

и также через strace видно что запускается некий внешний файл /bin/echo :

$ strace echo $$
clone(..
execve("/bin/echo", ["echo", "26294"], 0x7ffcd2aa8898 /* 70 vars */) = 0

тоесть получается по дефолту баш при команде echo испольщует несвой билтин а внешнюю команду.
потом я приказал башу в явном использовать встроенный echo

(окно1) $ builtin echo $$
и тогда уже все отработало нормльно без clone и execve.

как заставить баш по дфеолту для команды echo исполтзовать свой билтин непонятно.

а вот уже как выглядит запуск ls который уже точно невстроенный

(окно1) $ ls

(окно2) 
$ clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb85ece9490) = 28795
strace: Process 28795 attached
[pid 28795] execve("/bin/ls", ["ls", "--color=auto"], 0x558216669510 /* 71 vars */) = 0
[pid 28795] +++ exited with 0 +++

здесь мы четко видим что при старте внешней команды баш иполтьзует clone+execve

=======

cpu 
power consumption

задача. надо получить сколько ватт жрет цпу.
поможет прога turbostat из пакета linux-common-tools.

$ sudo turbostat --quiet --show PkgWatt
PkgWatt
1.23
1.22

==========
blocked process
наконец нашел что же такое blocked process оказывается = A runnable process is one
that is not blocked; a blocked process is one that is sleeping, waiting for I/O from the
kernel. 
тоесть blocked процесс это процесс в состоянии 'D'

=========
OR и biwise OR (Bitwise inclusive or)

обыкновенный OR (обозначается || ) этот тот у которого на выходые true или false
пример:

2<5 || 5<1 = true

bitwise or (обозначается | ) = это логический OR только для битов, когда мы берем
один байт и второй байт и делаем побитовый OR. резулттатом является набор битов.

9 | 5 =  15

1010
0101
-----
1111
========
processes kill parent child

что было интересно.

вот есть процесс. этот процесс порождает другой процесс.
первый это парент второй это чайлд.

далее что будет если послать kill -15 паренту?  умрет ли автоматом при этом чайлд?

что я высснил на данный момент.
если написать самопимную программу на C которая делает fork() 
то kill -15 парента убивает парент но чайлд спокойно остатется жить дальше.

а вот если в качестве подопытной программы взять bash то тут (видимо в нем прописан
кастомный обработчик сигналов) все идет подругому. посылка kill -15 к паренту неприводит
ни к чему. парент продолжает спокойно жить. я так думаю что в баш прописан кастомный хендлер
для сигнала 15 в котором написано что если у баш есть чилдрены то тогда сигнал 15 парент должен
игнорировать. а вот если паренту послать сигнал -9 то тогда умирает и парен и чайлд.

вот так интересные результаты пока из эксперимнтов
=========
scheduler
run vs runnable

у нас в ps есть статус 'R'
про него написано что это состояние обозначает сразу два типа процессов - run и runnable.
тоесть это значит что либо процесс реально испольняется на цпу либо неисполняется а стоит в
очеред runqueue и ждет когда для него освободится цпу.


вопрос - а можно както узнать так процесс щас реаьно исполняется или он в очереди стоит ?
поиска в инете ответ я увидел что люди такой вопрос задают но ответа нет. так что я пришел к 
выводу что простого решения как это увидеть нет. едиснвенное решение что я видел это наисать ядерный модуль который будет сканировать что-то в ядре и на основе деталей статуса в таблице процессов или еще где то там (тоесть в ядре безусловно есть точная галочка о том что прроцесс щас реально исполняется на цпу или всеже в очереди стоит) получать такую инфо.
итак короткий ответ  - простого способа это узнать нет.

========
ps
FLAGS 1,4

у команды ps есть флаг -l
и в нем есть колонка F

$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000 13908  3866  0  80   0 -  8528 wait   pts/148  00:00:00 bash
4 R  1000 14966 13908  0  80   0 -  9525 -      pts/148  00:00:00 ps

о чем эта колонка? в ней могут быть числа 0,1,4,5.

по факту они описывают два свойства процесса.

флаг 1 =  в мане описывается так "fork but didnt exec". по факту это значит что процесс был получен путем запуска fork() на его родителе (или clone() о чем нет в 
man ps) но потом в этом процессе (который дочка для парента) небыл запущен execve

тоесть еще раз о чем цифра 1 в этой колонке. обычно как в системе получается новый процесс.
есть процесс А он хочет создать новый процесс. как он это делает. он берет и делает fork()
или clone() получаем дочку B. Далее в дочке B запускается execve(). таким образом мы получили новый процесс B в системе.  так вот флаг 1 нам сообщает что процесс B был создан через fork\clone
НО после этого execve небыл использован. когда на практике это может быть. очень просто. когда 
у нас был  к примеру запущен bash и мы в нем запускаем еще один bash. поскольку бинарник у нас
такой же /bin/bash то смысла выполнять execve нет смысла. execve нам нужен если у нового процесса
другой файл бинарника. например парент процесс у нас /bin/bash а из него мы запускаем /bin/ls

флаг 4 = он говорит о том что процесс запущен с правами root. пример

$ sudo bash
$ echo $$
$ ps -Al | grep $$
# ps -Al | grep -E "$$|PID"
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 15102 15101  0  80   0 -  7464 wait   pts/148  00:00:00 bash


флаг 5 = это когда одновременно и флаг 1 и флаг 4.

прикол еще раз скажу в том что ( я проверил на практике)  что флаг 1 у процесса нетолько 
когда был использован fork но и когда clone тоже. тоесть я бы сказал про флаг 1 по другому
неважно форк там или клон или еще что было примеенено у парента. главное что в текущем процессе
небыл применен execve. тоесть это флаг об отсуствии применнеия execve.


флаг 0 = гораздо хитрее что значит 0. 0 значит отсуствие обоих флагов обоих условий но что это значит на практике?
разве это значит что  какойто процесс был получен без применнеия fork\clone ? как такое возмжно? нет!! это значит что процесс был получаем с примененеием fork\clone и далее с помощью execve !!!!!! вот что !!! таким образом можно воббще забыть про эти упоминания форк хуерк он тут неиграет
никакой роли. флаг 0 означает что в текущем процессе был использован execve при его создании
а флаг 1 означает что execve небыл использован . вот и все! это обьяснение гораздо лучше мудацкого
обьяснения из man ps.


что еще интересно: чтобы вызывать clone() (чтобы успешно откомпилирвать файл  на *.c) 
нужно в C программе использовать следующие макросы:

#define _GNU_SOURCE
#include<sched.h> 


где define _GNU_SOURCE совершенно особая штука. (https://stackoverflow.com/questions/5582211/what-does-define-gnu-source-imply)


что еще паралельно интересно. что еси в C программе мы вызываем fork()
то пофакту вызывается сисколл clone() а не форк!!! и strace это показыавет. а дело вот в чем!: дело в том что в C прогармме
кода мы пишем fork() clone() и прочие типа сисколлы на самом деле мы вызываем не сисколлы а функции библиотки
LIBC. а вот уже те функции вызывают чистые сисколлы. так вот  
libc fork() он по факту вызывает  clone() сисколл.
загадка разгадана.  в ядре естественно есть сисколл fork() но чтобы его заюзать 
надо тогда писать программу на асемблере а не на C. еще раз важно понять что в C коде мы вызываем функции библиотек libC
(функции обертки) а не реальные сисколлы ядра. поэтому это еще вопрос какой сисколл ядра юзает 
функция обертка libc.

итак еще раз когда мы в программе на C пишем вызов fork() то fork в данном случае
это не сисколл fork ядра а функция fork LIBC которая в свою очередь обращается к некоторому сисколлу ядра. в случае функции fork LIBC она обращается к сисколлу ядра clone а не к сисколлу fork как это можно было бы ожидать. 

в целом я бы сказал что столбик F имеет мало какого важного значения мало что дает 
интересного полезного. 

=================
zombie

еще раз поговорить про зомби процесс.

как он получается.

вообще это статус процесса. в целом это нормальный статус процесса если он длится недолго.
и ненормально если длится долго.


как он получается. когда в ядро поступает запрос ( неважно откуда от самого процесса, через Ctrl+c, от другого процесса вобщем неважно) на уничтожение этого процесса из системы то 
система вычищает все кишки процесса но остается небольшой хвостик в таблице процессов в ядре
и в частности сохраняется код возврата говорящий о том нормально процесс завершил работу или с ошибкой и ядро далее шлет сигнал парент процессу SIGCHLD который сообщает процессу о том что
состояние дочернего процесса изменилось ( кстати необязательно в сторону что дочерний процесс склеил ласты , также SIGCHLD посылаетя ядром к парент процессу если напримр процесс был останолвен изза сигнала SIGSTP либо продолжил свою работу после сигнала  SIGCONT). Далее ядро вот как подразумевает: в коде программы может быть прописан хендлер обработчик сигнала SIGCHLD если так есть то при старте парент процесса ядро это учтет и зарегистрирует этот обработчик. так вот при в этом случае при поступлении в парент процесс SIGCHLD сигнала шедулер при следующем таймслайсе
запустить этот кастомный обработчик этого сигнала. в целом ос ожидает что в этом обработчике в итоге будет использован libc функция wait (которая в итоге юзает кернел сисколл wait4) и данная функция через сисколл считает код возврата дочернего процесса. как только ядро увидит этот факт 
то ядро считает что вот теперь то дочерний процесс можно полностью уничтожить. значит как только в ядро поступил запрос на удаление процесса и до момента когда парент процесс считает код возврата
дочернего процесса все это время дочерний процесс будет висеть в списке процессов имея статус Z.
так вот когда могут пойти проблемы - кастомный хендлер в парент процессе для сигнала SIGCHLD его нужно написать програмисту тоесть это обязанность создателя программы парент процесса. а если он этого несделает? тогда в строй вступает дефолтовый ядерный обработчик данного сигнала и фишка в том что дефолтовый обработчик по дефолту игнорирует данный сигнал. Поэтому получается что если парент программа неимеет своего кастомного обработчика да еще и правильно написанного ( с использованием libc wait() ) то тогда получается что код возврата от дочернего процесса небудет
прочитан парент процессом никогда. и значит что дочерний процесс будет висеть в статусе Z вечно.
уничтожить его через сигналы невозможно ибо он уже почти уничтожен и болльше его неуничтожить.
итак причина появления Z процессов это остутствие кастом хендлера сигнала SIGCHLD в парент процессе. тоесть нужно парент программу переписывать. правда есть еще такой выход - нужно 
остановить уничтожить парент процесс тогда у дочернего процесса поменяется номер парент процесса 
в лоховской литературе пишут что этим процессом 100% станет сразу процесс с pid=1. но это брехня
как написано в более правльно литература новым парентом станет некий ближайший к дочернему процессу процесс но совсем необязательно что это будет процесс с pid=1
по моей практике парентом станет совсем другой процесс.

пример.

вот у меня есть процесс 22.exe
и вот его дерево от дочернего процесса до его парента а далее парента того парента итп.

~$ pstree  -A  -s  -p 20834
systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(20614)---mc(20742)---bash(20744)---22.exe(20833)---22.exe(20834)

парентом для 20834 является pid=20833

еще раз в этом убедимся

$ ps -o user,pid,ppid,pgrp,sess,stat,cmd -p 20834
USER       PID  PPID  PGRP  SESS STAT CMD
vasya    20834 20833 20833 20744 S+   ./22.exe

уничтожаем парента 20833

$ kill -9 20833

$ ps -o user,pid,ppid,pgrp,sess,stat,cmd -p 20834
USER       PID  PPID  PGRP  SESS STAT CMD
vasya    20834  1718 20833 20744 S    ./22.exe

и мы видим интереснейшую картину что новым парентом стал далеко непроцесс с pid=1 нет.
новым парентом стал pid=1718

об этом редко где пишут.


если мы еще раз посмотрим на исходное дерево родительских отношений для исходного процесса

systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(20614)---mc(20742)---bash(20744)---22.exe(20833)---22.exe(20834)

то мы увидим что новый парент это вверх по цепочке , второй от начала.

вот это очень интересно что новый парент это не pid=1 как пишут во многих книжках.

почему в системе несколько systemd процессов это другой разговор. скажу только что 
systemd(1718) это systemd который запущен в системе вот с таким ключом

/lib/systemd/systemd --user

почему именно на этот процесс из всей цепочки пал выбор для нового парента пока тоже непонятно.

в любом двигаем дальше что это нам теперь дает. дает оно то что если у нового парента есть 
кастомный обработчик сигнала SIGCHLD а у  systemd он однозначно есть то тогда (как я понимаю) 
ядро еще раз направляет сигнал SIGCHLD уже к systemd(1718) и он считывает код возврата дочернего 
процесса и вот вуаля ядро наконец удаляет дочерний процесс (20834) из системы полностью и целиком
и списке процессов исчезает наш Z процесс.

в чем вообще прооблема с этим Z процессом кроме того что непорядок что он виисит в системе.
проблема в общемто только в том что он пока висит в статусе Z то он занимает номер в таблице процессов. на 32-битных ядрах всего был 32768 доступных номеров для процессов так что если 
наразмножится много Z процессов то система исчерпает возможность создавать новые процессы. незнаю
что при этом будет. кернел паник или что.

еще раз скажу что процес в статусе Z он уже непринимает сигналы так что его никаким $ kill -9 невырубить. 

через $ ps такой процесс будет иметь вид как <defunct> например

22.exe <defunct>

насколько я понял самый реальный случай откуда могут вылезат на практике Z процессы
это скажем апач который запускает типа скрипт баша чтоли а в этом скрипте есть скажем строка с grep
типа 

...

cat /....  | grep 

и далее там было написано где я этот пример встречал что апач может по таймауту грохнуть процесс
скрипта а как он его грохает ну конечно же  некоей командой килл и аналогичным сисколлом в итоге
ядро пошлет сигнал -15 процессу со скриптом по хорошему этот процесс со скриптом должен иметь 
хеендлер кастомный для сигнала -15 который убивает все дочерние процессы причем он должен вначале убить все дочерние процессы считать их код возврата и потом только сам закончить свое существование.
на практике наверное этого часто нет. и что в итоге. в итоге процесс со скриптом будет уничтожен
но в системе останется дочерний процесс тот который grep. далее что получается что раньше для 
grep праентом был процесс со скриптом а теперь ( кстати вопрос) парентом станет (наверное) процесс 
с апачем и он ( неужели? ) неиммет обработчика катомного для SIGCHLD сигналов и поэтому процесс с 
grep будет висеть как Z. помне этот пример какойто бред потому что мне кажется что новым парентом будет systemd и он грохнет этот grep без проблем. но даже если новым парентом будет апач то я думаю у него 100% есть свой хендлер для SIGCHLD процессов потому что он же сам порождает чайлдов так что у него просто обязан быть этот хендлер. вобщем вопрос как на живой практике люди ловят
стада Z процессов надо еще выяснить.

================
proc

это файловая система которая позволяет из юзерского пространства получить доступ ( а procfs 
выствпает как шлюз как интерфейс) к kernel data structures.  тоесть можно полазить в ядре
из юзер пространства

===
bash
terminal

(оффтопик что такое командная строка шел. дело в том что есть пробема чтобы запустить программу нужна программа.)

вот такая программа есть

$ cat 31.c
#include<stdlib.h>
#include<stdio.h>
#include<unistd.h>

int main ()
{
 while (1)
 {
 sleep (5);
 };

return 0;
}


она неделает ничего кроме того что просто бесконечно крутится в цикле
никаких сисколлов кроме nanosleep в ней нет.

если мы ее запустим то просто будет пустой экран.
однако на этом экране можно наимать на кнопки и буквы будут отображаться на экране.

вот так:
$ ./31.exe


eqwe
qwe
qwe
	w
	w
	we
	q
ewq
w
r
we
rqw
er
qwer
qwer
w


вопрос - в выводе на экран этих букв какито сисколлы участвуют? как это работает?
выясним это :

в первом окне выясняем pid текущего баща.
(окно1) $ echo $$
30194

во втором окне подключимся через strace к этому башу
(окно2) $ $ sudo strace -f -p 30194
strace: Process 30194 attached


далее в первом окне запускаем нашу программу
(окно1)$ $ ./31.exe

далее возвращаеимся на второе окно и смотрим что там показыает
(окно2): 
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0
[pid 25271] nanosleep({tv_sec=5, tv_nsec=0}, 0x7ffe98297af0) = 0

и больше ничего. и это реально так потому что наща программа ничего кроме nanosleep неделает.


возврашаеися на первое окно и начинаем тыкать кнопки.на экране появляются буквы
(окно1) $ ./31.exe
wer
ewr
ewr
wer
wer
we
rq
q
r
qer
qer
q
qwr

возврашаемся на второе окно и смотрим появились ли какието сисколлы которые наша програма бы начала юзать (что было бы странно ведь у нас в коде программы нет ничего больше) . или signals которые бы начали прилетать в наш процесс и прерывать его. и видим что ничего нет.
как и прежде на окне2 просто мы видим висящие нанослипы.  отсюда я делаю вывод что прием 
нажатия кнопок с клавы и их печать в окне терминала с моей программой это все вина ядра. это код ядра выполняет. как походу это работает. мы тыкаем кнопку на клаве происходит cpu hardware interrupt. он вызывает перрываение работы моей программы (если комп однопроцессорный)  и запускается ISR (interrupt service routine) котторая код ядра. эта рутина принимает нажатие кнопки 
и далее ( что самое интересное) делает вывод этой литеры на стандартный вывод процесса который крутится в текущем активном терминале. тоесть ядро как букву приняло оно смотрит на данный момент
есть ли активный терминал? есть. а терминала неможет быть без запущенного там хотя бы одного процесса. тогда ядро берет стандартный вывод этого процесса и посылает туда литеру и она появляется
на экране.

щас мы это проверим. запустим программу еще раз и начнем читать из стандартного ввода для начала
нашего процесса. тоесть проверим то что когда мы ввели буквы и ядро их приняло через интеррапт 
то посылает ли ядро эти буквы в стандартный ввод нашего процесса.

значит на первом окне я ввожу символы
(окно1) $ ./31.exe
qeqwewqeqeqweqweqwe
9123879283791839137912731

на втором окне я вижу !
(окно2) $ while :; do cat /proc/25418/fd/0; done
qeqwewqeqeqweqweqwe
9123879283791839137912731


рабтает это так. пока я просто ввожу символы в fd/0 ничего неприходит. но как только 
я нажимаю Enter то сразу прилетает строка в fd/0 

тоесть схема работает так: вот у нас открыт терминал на компе и там крутится процесс ( потому что 
открыть терминал и чтоб там ниодин процесс некрутился невозможно). так вот прием символов с клавы 
и печать их на экране терминала работает автоматичеки в линуксе без участия программы которая крутится в терминале вообще!

даже еще интереснее. я заупстил процесс и всего каналы 0 (который кстаи только на примем)
1 и 2 ( которые на вывод) направил на /dev/null

$ ./31.exe 0</dev/null 1>/dev/null 2>/dev/null

проеряем:
$ ls -1al /proc/25816/fd
total 0
lr-x------ 1 vasya vasya 64 мая 30 16:35 0 -> /dev/null
l-wx------ 1 vasya vasya 64 мая 30 16:35 1 -> /dev/null
l-wx------ 1 vasya vasya 64 мая 30 16:35 2 -> /dev/null

далее я тцкаю кнопки на экране
$ ./31.exe 0</dev/null 1>/dev/null 2>/dev/null
wqe
qwe
qwe
qw
e
qwe
qwe
qw
e

и они отображаются.
соответсвенно так как у процесса все каналы /dev/null то прием и отображение кнопок 
на экане никак несвязано нис процессом ни с его каналами. это все чисто автономная система от процеса и раотает исключиеотно через код ядра. и вобще то логично! - терминал это как жесткий диск
это уже как бы реальная железка (просто она виртуальная . это как виртуальный диск) вобщем
окно терминала это для линукса реальная железка а примом инфо от железки и отправкой байтов на реальную желеку делает ТОЛЬКО код ядра. (так же как чтение в файл на диске например делает толкьо код ядра а программа может лишь об этом просит ядро)тоеть в случае диска картина


программа write() --(просьба о записи)-----> код ядра ---(реальная запись на железку)---> файл на диске
программа read()  --(просьба о чтении)-----> код ядра <--(реальное чтение с железки)---- файл на диске

тоже самое для терминала. ксатти вспомниает что терминал железный это нетолько экран это еще и клава. такчто терминал = окно+клава
значит терминал это такая железка которая как бы в своем лице имеет два порта , один порт на прием
информации из мира и второй порт на отсылку информации в мир. как например сетевая карта.
и задача ядра в том чтобы принимать из принимающего порта когда туда чтото приходит и отправлять
в отправляющий порт когда туда юзерская программа хочет чтото записать. вот что такое терминал как железка с точки зрения ядра.  получается что терминал как бы имеет минимум один хардвейр интеррапт
означающий что на принимающий порт поступил пакет ( с клавы пришло нажатие). и ядро должно это 
нажатие обработать тоесть принять этот байт (нажатие) внутрь себя как сетевая карта принимает пакет снаружи и ядро его забирает внутрь.

получается тогда работает так:  у нас активен терминал. ядро это знает. (незнаю как но ядро это знает). мы тыкаем на клаве кнопку. происходит hardware interrupt посколку клава это железка и она точно имеет линию interrupt. срабатывает цпу интеррапт , цпу запускает ISR(который код ядра).
этот isr считывает нажатие в форме байта типа того и этот байт улетает куда то там в ядро в какйото буфер. (заметим что участия кода процесса нет здесь вообще и дальше его небудет).
что делать дальше с этим байтом с клавы ядру? ядро видит что на данный момент окно терминала активно. значит это как бы означает что сигнал с клавы прилетел как бы с клавы этого виртуального терминала (потому что если активного терминала открытого нет на экране а напримр просто есть пустой рабочий стол Cinnamon то ядро также принимает нажатия с кнопок c клавы тоесть ничего неменятеся но при этом ничего непроисходит потому что к виртуальному терминалу к его виртуальной клаве это событие неимеет никаого отошения). Так вот ядро понимает что это нажатие клавы его нужно соотнести с терминалом открытым. так что же делать? нужно делать то что указано в модуле\драйвере терминала. если бы терминал был реаьным физичеким устройством то нажатие клавы железного терминала всегды бы поступало в ядро и обрабатывалось бы драйвером железного терминала вот что там в драйвере было бы написано то бы ядро с нажатием кнопки и делало бы. так как у нас терминал виртуальный то нажатие кнопки в термиале просходит только тогда когда окно терминала открыто на столе и активно. это логично. окей окно терминала открыто на столе . мы нажали кнопку на клаве.
ядро считало байт. и оно отправило этот байт ну вот туда -  в драйвер виртуального терминала.
и драйвер вирт терминала так настроен что он выводит этот байт на экран терминала в форме литеры.
выводит чисто через ядерный код тоесть его работа нам вообще невидна. к коду процесса это неимеет 
никакого значения. если бы можно было бы иметь запущенный терминал без единого процесса то 
все работало бы точно также. мы жали бы кнопки и на экране появлялись бы буквы. я бы сказал что ситема раотает так . сигнал с клавы счиывает ядро по цпу интерапту и посылает в драйвер терминала.
если бы это был реальный железный терминал то я считаю что это работало бы так : нажали кнопку
сработал цпу интеррапт и ядро приняло через ISR байт через порт терминала который принимает 
сигналы с внешнего мира. далее драйвер терминала обрабатывает этот байт и ядро отправляет в порт 
записи терминала литеру и эта литера отображается на термиале на его окне.тоесть между 
вводом буквы с клавы и выводом на экран находится ядро которое принимает байт с одного порта
и послыает байт на другой порт

нажатие клавы запись в порт1--->  ISR(ядро) чтение из порта1 в буфер--> драйвер терминала(ядро) забирает из буфера к себе , обрабатывает и пишет в порт2 терминала --->  терминал читает из порта2 и рисует на экране литеру.

возможно железные термиыл были сделаны так что при нажатии на кнопку происходила запись в порт 
тоесть отсылка байта в удаленную систему и автоматическая (реализованная на уровне железа терминала) печать символа на экране ,таким образом линуксу на той стороне ненужно было писать в порт2 для того чтобы символ напечатался на экране.


итак еще раз открыто у нас окно терминала. мы нажали кнопку. кнопка на клаве. клава это железка.
железка иммеет линию интерапта к цпу. железка запускает интерапт. цпу прерывается и запускает
ISR (котоырй код ядра). ISR считывает байт из железки и передает его драйверу терминала (тоже код ядра)  (если окно терминала неактивно то считанный байт непердается драйверу терминала ибо данное нажатие кнопки неоотносится  к терминалу). драйвер терминала рисует на экране литеру. таким образом мы видим что принятие кнопок с клавы и рисование букв на терминале это процесс сугубо общение железки и ядра. процесс его код вообще здесь ни капли неучаствует. 
а когда же на сцену вылезает процесс ? а вот когда и как. когда мы открывает терминал
то драйвер терминала создает в системе устройство /dev/tty1 или /dev/pts1 неважно. будем для 
простоты считать что это одно и тоже. так вот процесс который запущен в линуксе и который запущен в терминале для этого процесса ядро автоматом создает\открывает три файловых дескриптора.
что нам дает если у процесса есть открытый файловый дескриптор ( причем при его открытии можно указать он для чтения для записи или для и того и другого). это дает то что из кода программы
мы можем через сисколлы read() write() мы можем писать и читать из этих файлов. тоесть для процесса
это каналы общения  с внешним миром на чтение данных и запись данных. бекендом файлового дескриптора может быть любая железка - жесткий диск, флэшка, звуковая карта, мышка, терминал(клава +окно), сетевая карта, модем. процессу вообще невидно и непонятно с каким железым утсройством он связан. для процесса это все неизвестно и прозрачно. для него это просто открытый поток\файл в который можно пиисать байты или читать байты. ( еще раз важно понять что терминал это прежде всего железка с портами на запись и чтение . с линиями интерраптов. такое же как у сетевой карты или звуковой карты. просто так совпало что что природа человеческая нечуствует неосязает интерфейсы жесктого диска или сетевой карты но мы способы взаимодействовать и осязать интефейсы терминала. пальцами мы взаимодейтвуем с кнопками а глазами  с экраном. у звуковой карты мы осязаем звук. звук у звуковой карты это как экран у терминала. с точки же зрения ядра это железки у которых есть порты на чтение и запись. а уже железка нам дает возможрость конвертировать байты от ядра прилетеврие в порт записи в звуки или картинку или нажатие кнопок от человека в байты для ядра котоыре к ядру летят через порт записи на терминале).  итак если есть процесс ядро может сделать автоматом а можно через сисколлы в программе открыть файл на чтение запись (канал связи) у котрого бекендом будет какая то железка. так вот можно открыть файл дескриптор куда процесс может писать и читать бекендом которого файла является /dev/tty1 тоесть железка терминал. так же как в команде 
dd мы юзаем файл /dev/hda для чтени запииси в железку жесткий диск.
что такое /dev/ папка. это такие файлы в юзер спейсе куда юзеркие программы открыв дескриптор
могут начать чиатть и писать. это такой слой виртуализации такой гейт между юзерской программой
 и железкой. тоеть /dev/hda или /dev/tty1 абстраигирует железку от юзерской программы.

 и тогда если программа пишет в дескриптор 1 и ( который она до этого окрыла через сисколл )
а у этого дескриптора бекендом является /dev/tty1 то байты из программы летят в /dev/tty1
и что дальше? то что летят они пока что в ядро  а не в железку. в специальный буфер.
далее в ядре вступает в действие драйвер данной железки он видит поступление данных в буфер
и уже начинает делать реальную подготовку обработку и low-level отсылку этих данных на уже непосредественно железку выполня всякие там хитрые low-level команды и действия которые нужно сделать чтобы этот поток данных реально засунуть на железку. фишка тут в чатности в том что 
для программы все универсально и легко.  ей похеру куда она пишет - в звуковую карту, в сетевую ли карту, в терминал, в жесткий диск ли. для программы это выглядит всегда одинаково исползуется единый универсальный сисколл вызов.
 write (1, .....)

а уже ос, ядро, драйвер ядра делает всю конкретную low-level работу.  это очень круто с точки 
зрения написания юзер программ. этакий слой софт виртуализации.

тоесть схема такая

процесс (юзер код) ----- сисколл write(1,....) ---> ядро драйвер ---- low-level железка dependent код ----> реальная железка 

где 1 --символическая ссылка на --- /dev/tty1

таким образом кстати вот эти /dev/ файлы это не то что прямое окно к железке. нет.  это входной
гейт в буфер на чтение и\или запист потока байтов  за которым прикреплен драйвер. 
а уже драйвер этот поток каким то образом несет или ненесет реально до железки.
юзерская программа как бы это баально незвучала прямого доступа в обход ядра не имеет до реальных
железок. всегда ядро стоит как посредник как от программы до железки так и от железки до программы

программа <---> ядро <---> железка

и так всегда.

получается ядро оно с одной стоороны выполняет роль секьюрити то есть дает доступ недает итп.
и с другой стороны являюется виртуализирующим слоем типа API скрывая всю low-level конкретику 
общение с железкой и предоставляя юзерской программе некие генерализованные функции\точки\команды
по общению с железкой. 
тоесть вот у на 100 видов сетевых карт. записать в сетевую карту байт для программы всегда будет 
выглядеть едино: условно write(1,.......) а уже ос ядро будет выполнять всю ту сложную работу  
с low level командами асемблера скажем по записи байта в сетевую карту.

возвращаемся к процессу и терминалу.
значит открыли мы терминал. ядро драйвер вирт терминала создает в /dev/ устройство /dev/pts/16 или /dev/tty1 предоставляющее гейт для доступа юзерским программам  к этой железку.
внезависимости от процесса  ядро чеерз драйвер принимает нажатие кнопок от клавы когда 
термиал активен и ядро автоматом рисует в окне терминала принятые с клавы кнопки. и при этом происходит еще один очень важный штук. когда мы нажали кнопку и драйвер терминала ее принял
то помимо отрисовки этой литеры на экране драйвер терминала делает еще одну очень важную вещь
он записывает этот байт в /dev/pts/16 в файл который отвечает за терминал в юзерском пространстве.
зачем он это делает. а делает он это затем чтобы нажатие кнопки поступило нетолько в ядро но и было  продублировано и стало доступным юзерской программе. так как юзерская программа может 
читать из файла /dev/pts/16 . тоесть до этого мы видели исключетельно общение ядра и железки в обе стороны а юзерской программе было непрорваться к железке. и вот наконец ядро смилостивилось и 
получив байт с кнопки оно нетольько  свои дела делает (рисует литеру на экране) но и через файл
доступный для юзер спеейса дублирует туда это байт. 

схема
																																						код ядра отрисовка литеры в окне терм
                                                                           /
кнопка клавы при открытом терминале нажали  -----> ядро --> драйвер ядра->/
 																																				  \
 																																				 	 \ядро запись в /dev/pts


и далее

программа <---- read(0,...) --- /dev/pts

таким образом мы видим каким же образом у процесса юзерского появляется
возможность тоже получит доступ к байту с кнопки железной клавы.
только из за того что ядро кладет полученный им непосредственно с железки байт
в доступный для юзера файл.

также видно что отрисовка на экране идет автономно от 
файлов /dev/pts.  

как же программе считывать с /dev/pts ?
а вот как. программа вначале делает сисколл на открытие файла.

fp = fopen ("/dev/pts/4", "w+");

далее в fp ос возврашает дескриптор. (0,1, 2, итп)

и потом имея этот дескриптор можно через сисколл писать туда

fprintf(fp, "%s %s %s %d", "We", "are", "in", 2012);

также через write(0,....)
насколько я даже щас понимаю что скорей всего fprintf это libc wrapper для сисколла write()


таким образом любой процесс если откроет /dev/pts/4 
может туда писать. при этом в /proc/pid/fd  у процесса будет появлсяться файловй дескпритор
с бекендом /dev/pts/4
если у процесса есть файовй дескриптор  у которого на бекенде файл овтечающий за терминал железку
/dev/tty или /dev/pts то говорят что процесс работает в термиале или прикреплен к терминалу.
вот что значат эти загаочные слова работае в терминале прикреплен к терминалу. всео навсего 
то что процесс открыл файл на чтение запись бекендом которого явлется железка терминал.
таким же макаром если процесс пишет щас на жеткий диск то мжоно говорить что процесс прикреплен к
 жесктому диску или проесс работе в диске. но конечно загадрчнее и понтовее гвоорить что процесс
 работает в терминале или прикрелеен к терминалу.
 процесс работает на цпу вот где он работает. а в терминал железку он пишет или читает. вот иввсе
 вот и весь выебон и понты наведенные вокруг этого.  причем сам процесс и незнает куда он пишет
 на жесктйий диск в звуковую карту или в терминал потому что для процесса это все абстрагировано
 через единую форму

 fprintf(fp, "%s %s %s %d", "We", "are", "in", 2012);

 в любой момент процесс может закрыть этот дескриптор и открыть заново.

 причем по факту процесс всего навсего пишет в файл. и только то. а уже драйвер этого спец файла 
 из /dev/каталога реально пишет или читает с устройства.

 так что в терминале реально работает толкьо ядро. но никак не процесс. ха-ха-ха.

 поэтму становистя понятна наша исходная кратинка
о том что мы запустоли программу которая вообще никак неослуиживает ни клаву ни экран.
 а при этом у нас работает печат букв на экране терминала. 

 $ ./31.exe
wer
ewr
ewr
wer
wer
we
rq
q
r
qer
qer
q


процесс к появлению букв на экране и к приему кнопок с клавы неимеет никакого отношения.!
это все делае автономно ядро драйвер терминала.

все что происходит с процессом при команде  $ ./31.exe то что связано с терминалом это всего
навсего вот что:

ядро автоматом открывает три файла для процесса когда оно его создает
/proc/pid/fd/0 --> /dev/pts/4
/proc/pid/fd/1 --> /dev/pts/4
/proc/pid/fd/2 --> /dev/pts/4

вот это все что связывает процесс с терминалом. всего навсего ядро автоматом 
открывает три файла с бекендом на /dev/pts/4.  любой процесс после запуска при своем 
желании может это сделать и сам самостоятельно! ничего тут такого особого нету!
тоесть можно запустить программу и не в окне этого терминала ( например в окне терминала /dev/tty1) и при этом открыть файлы с бекендом на /dev/pts/4
что это даст? это даст то что когда мы будем сидеть в терминале /dev/pts/4 и нажимать кнопки
то процесс запущенный в /dev/tty1 будет принимать эти нажатия кнопок.

пример:

вот у нас открыт терминал /dev/pts/4

(окно 1)$ tty
/dev/pts/4


мы запускаем программу которая никак с чтением с кнопок неработает. просто пустой цикл while
и мы вводим в терминале буквы "wer"
(окно 1)$ ./31.exe
wer

а в другом окне другом терминале мы зарнее запускаем другой процесс который читает /dev/pts/4 
тоесть тот файл в который ядро дублирует нажатие кнопок с клавы и откуда уже может чиатть любая желающая программа

$ cat  /dev/pts/4
wer


и вуаля мы видим что в первом окне мы ввели wer и их отрисовало само ядро. без участия 
юзерской программы 31.exe

а во втором окне мы тоже видим wer который считала наша юзеркая программа которая незапущена в 
окне терминала (окно1) прочитала из /dev/pts/4 куда ядро кладет нажатия кнопок с клавиуатуры
терминала (окно1). 

вопрос а если десят процессов поставить читать из /dev/pts/4 то как оно будет ? какой процесс будет
получать нажатия кнопок? ответ - они все будут конкурировать. и рандомно то один процесс
будет показыват нажатую кнопку то другой процесс то третий. ибо как это будет работьа


команда cat  /dev/pts/4; 

если через strace помсмотеть она исполтзует read() сисколл.
если мы запустим в неколльких онках этот cat то рандомно то в одном окне то вдругом
(они будут конкурирова)  будет повявятся то что я буду печаать в окне1.
я проерил так и есть.

(забавно что можно открыть на чтение файл сразу нескольким процессам. а с другой стороны а почему
бы и нет).

так вот получается еси мы заупстили программу в окне терминала она ничего не лучше
других программ которые небыли запущенв в терминале в плане возможнсотй чиатть с этого терминала
и писат в этот терминал! единвтеное это то что ядро при создании процесса заупденного в окне 
этого терминала автоматом откроет три дескпритора от данного терминала. так что коду проесса этого длеать самому руками ненужно вот и все. но процесс незпуеннй в терминале может это сделать точно также только руками. вот ивсе.  а дальше процесс если хочет то он читает пищет в дескприорторы а если нехочет то и непишет. вот и все.! ну и еще такой момент что еси мы в терминале жмем Ctrl+C
то ядро шлет SIGINT процессу который был открыт в терминале ( вопрос как ядро отличает какой процесс было запущен в этом терминале а какой небыло а простооткрыл руками дескприоры темринала?)

так что теперь мы четко поняли. терминал это штука сама по себе. а процесс эта щтука сама по себе.
 и единсвтенное что меду ними может быть тонкий мостик  через /dev/pts и ядро между ними.
 а так это абсолютно разделенные сущности. а не какието неразделимые сиамские близнецы. нет такого 
 что процесс прям приращен к терминалу. такго нет вообще. 

 темринал живет сам по себе его обеспечивает и с ним напрямую говорит только ядро. 
 а процесс находится совершенно далеко в другой корзине.   и между етрминалом и процессом есть 
 тонкий телефонный мостик это ядро и файлик /dev/pts/4
 по факту с точки зрения программы ее связывает с терминалом только файлик (чтение запись) /dev/pts/4 это тоже само что любого человека свзыввает с магазином в америке только то что в телефоне
 человека есть номер этого магазина по которому можно позвонить. а когда процесс запускается
 в окне терминала это как то что ядро у человека телефоне при покупке телефона автомтом а адреной
 книжке записало номер этого магазина. вот и вся связь между магазином в америке и человеком на в африке.

 еще раз про то как происходит печать на окне терминала.
 если ядро хочет там печатать то оно печатает через свой код драйвер терминала.
 если процесс хочет печатать на окне терминала это это тоже самое если процесс хочет писать на диск
 тоесть сам процесс никапли это неможет делать. он должео поросить ядро  а оно уже может быть
 это сделает. как попросить - процесс должен сделать запись в /dev/pts/4
 тогда ядро его дравер терминала возьмет этот поток байтов из буфера и уже сделает low level 
 работу и дейсвительно пошлет на терминал и напечатает. когда самое ядро по своему желанию 
 печатает на терминале например в случае убианеим пороцесса по SEGFAULT то ядро непишет в /dev/pts/4 для этого. ему это ненадо. /dev/pts/4 это гейт для запроосов от юзерских порграмм.
 само ядро пишет на термиал напрямую. /dev/pts в этом вобще нучаствует когда ядро пишет на терминал.

 далее еще нюанс. команда cat читает из файла терминала через сисколл read()
проверяется легко
$ strace cat


 в чем его нюанс в  том что пока мы ненажали на enter в окне терминала в cat ничего неприлетит.
 так раотае сисколл read походу

 а вот bash читает из файла термиала через ддругой сисколл pselect6()
 это дает то что баш видиит получает в свои недра уже отдельный символ и нажатия на enter 
 уже абсолютно ненадо. 

 к чему это ведет. к  очен иенересуному результату.

 (окно1)$ tty
 /dev/pts/16

значит в окне 1 запущен bash который все время работает в pselect6()

 (окно2) cat /dev/pts/16

 тоесть во втором окне мы как и раньше воруем то что вводится с клавы в окне 1.
 так вот что непонятно.
 я сижу в окне 1 и ввожу на клаве (без enter)
 1234567890

 при этом в окне 1 непоявляется ни одна цифра кроме последней 0
  а все прердыдущие появляюстя в окне2
  тоесть

  (окно 1) $ 0

  (окно 2) $ $ cat /dev/pts/16
123456789

во первых уменя вопрос почему раньше нам нужно было в окне 1 вводить enter чтобы цифры появились в окне 2 а щас этого делать ненадо. а во вторых самое интереное почему  у нас в окне 1 нет цифр 123456789 если за их отображение отвечает ядро а не баш процесс?
( также упомояну по ходу что в ядре есть два селекта select и pselect6)

мне в этой истории непонтно почему кнопка нажимаемая а окне1 неотображается в окне1
то что она воруется на окно2 это окей (хотя и без enter) а вот почему она неотображатеся
в окне1 непойму. есть пока только одно предположение что баш юзает сисколл 

pselect6(1, [0], NULL, NULL, NULL, {[], 8}

который каким то образом влияет на драйвет терминала? по мне это херня вобщето.
хотя сисколл pselect6 это тоже ядерный код  как и драйвер терминала но он же всего навсего
работает с ... файловым дескриптором... кхмм... ну незнаю.. 

еще какой эксмеримент я сделал. 
язапустил баш вместе с strace в окне1 и начал нажимать кнопки.
четко видно вот что 

вот запустил баш. на экране такое окно1:

(окно1)$ 
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

начинаю нажтмать кнопки
если кнопка непрошла. если ее "перехватил" процесс в окне 2 то на окне1 ничего непросходит.
(что меня и непонятка вызывает).

а если кнопка прошла то мы видим в окне1:

(окно1)$
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, 

если еще одна конопка прошла то видим в окне1

(окно1)$
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, "1", 1)                         = 1
select(1, [0], NULL, [0], {tv_sec=0, tv_usec=0}) = 0 (Timeout)
write(2, "1", 11)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {[], 8}

а вот как выглядит стрейс баща коода мы неворумем символы из окна2

(окно1) $
pselect6(1, [0], NULL, NULL, NULL, {[], 8}) = 1 (in [0])
read(0, "1", 1)                         = 1
select(1, [0], NULL, [0], {tv_sec=0, tv_usec=0}) = 0 (Timeout)
write(2, "1", 11)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {[], 8}


вроде вывод тот же самый. просто во втом случае движуха по сисколлам иидет при каждом
нажатии кнопки. а впервом случае жмеш кнопки а на экране ничего неменяте ся в плане 
сисколлов.

еще меня смущает что читается один байт
read(0, "1", 1)

а пишетс очемуто бащем 11 байт
write(2, "1", 11)
зачем 11 почему 11?

причемя я проверил уб баша все три канала 0 1 2 ведут на один бекенд

 0 -> /dev/pts/16
 1 -> /dev/pts/16
 2 -> /dev/pts/16

такое ощущение что когда бащ стартует то он (хотя звучит как бред)то он просит драйвер 
терминала невыводить автоматом нажатые кнопки на окно терминала.  а делает это сам 
при условии что он (баш процесс) считал этот символ из /dev/pts/
тоесть да вот реально. как бутто бащ кода стартует то он просит драйвер терминала
не дублировать принятые символы автоматом на экран. мол бащ будет сам этим заниматься.

кхм...
кстати там же есть драйвер терминала а есть типа тип терминала который исользуется прям щас в
этом окне терминала
$ echo $TERM
xterm-256color

вобще по терминалам нужно читать Digital VT220 Programmer Reference Manual - VT100.net
кстаи я думал что линукс драйвер терминала эмулирует vt200 а окаызется vt100,

так вот там я нашел такую штуку:

4.6.5 Send/Receive Mode (SRM)
Send/receive mode turns local echo on or off. When send/receive mode is reset (local echo on), every character sent from the keyboard automatically appears on the screen. Therefore, the host does not have to send (echo) the character back to the terminal display. When send/receive mode is set (local echo off), the terminal only sends characters to the application. The host must echo the characters back to the screen.

You can set or reset send/receive mode as follows.

Mode	Sequence	Action
Set	
9/11 3/1  3/2 6/8
CSI   1    2   h
Turns off (disables) local echo. When the terminal sends characters to the host, the host must echo characters back to the screen.
Reset	
9/11 3/1  3/2 6/12 
CSI   1    2   l
Turns on (enables) local echo. When the terminal sends characters, the characters are automatically sent to the screen.

тоесть терминал может автоматом рисовать на экране символ который мы послаи с клавы а может и нет.
что значит эти загадочные сиквенсы я незнаю но я нашел как бурать local echo 
другим способом

$ stty -echo

тогда да. все что пеаатаешь  - ничего на экране непоявляется. но по факту баш его видит. 
так вот предположение может баш при старте делает какито особые натройки текущего экрана 
терминала... тоесть

вот я сдеал 
$strace stty -echo
ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon echo ...}) = 0
ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {B38400 opost isig icanon -echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon -echo ...}) = 0
ioctl(0, TCGETS, {B38400 opost isig icanon -echo ...}) = 0

тоесть походу через ioctl можно 
что такое ioctl это такой сисколл через который юзер программа может послать параметры на железку
(через ядро конечно) который специфичны для данной железки и которые нельзя послать другими обычными сисколлами. тоесть этим сиколом можно как бы лазить под капотом в конкретной железке
через юзерскую программу.

итак ioctl позволяет считывать настройки терминала тоесть линукс термина драйвера
и также подкручивать их. возмжоно вэтом и есть секрет.
баш старует . через ioctl подкручивает насйтроки текущего термиала  и поэтому мы видим такое 
повдеение.

через libc ioctl_tty wrapper 
можно указывая наш /dev/tty1 устройство можно у него подкручитваь его найтсройки. тоесть 
как я понимаю ядро кога создаем новый терминал то его свойтсва как железного устрйоства ядро
подкручитвает по дефолту. а мы можем через ioctl указывая /dev/tty1 подкручивать в нашу сторону.

получается через read() write() можно делть общие оперции с устройсвами в виде файлов
а с помощью ioctl() можно делать спеицифичекие для данной железки операции. тоесть ели бы мы работали с принтером. то read() write() это общие сисколлы для всех принтеров для общих оперции
чтени записи а ioctl можно былло бы юзать из юзеркой процеграммы чтобы делать настйроки принтера.
типа того. тоже самое для терминалов. таким макаром через ioctl можно подкручиват драйвер терминала
в ядре для конкретного нашего открытого окна терминала. вот походу баш это активно и делает при старте.

попробуем для начла считать настройки терминала через ioctl_tty

$ cat 42.c
#include <stdio.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <fcntl.h> // for open
#include <unistd.h> // for close
       int
       main(void)
       {
           int fd;
           struct termios tio2;

           fd = open("/dev/pts/16", O_RDONLY);
           ioctl(fd, TCGETS, &tio2);
           close (fd);
       }



 $ strace ./42.exe
 ioctl(3, TCGETS, {B38400 opost isig -icanon -echo ...}) = 0

отработала успешно. 

 что такое struct termios в коде 42.c

 смотрим

 $ cat /usr/include/bits/termios.h | grep struct -A 20
struct termios
  {
    tcflag_t c_iflag;		/* input mode flags */
    tcflag_t c_oflag;		/* output mode flags */
    tcflag_t c_cflag;		/* control mode flags */
    tcflag_t c_lflag;		/* local mode flags */
    cc_t c_line;			/* line discipline */
    cc_t c_cc[NCCS];		/* control characters */
    speed_t c_ispeed;		/* input speed */
    speed_t c_ospeed;		/* output speed */
#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
  };


еще смотрим
$ man termios 


ухты !!!!! получается  я напоролся еще на одну БОЛЬШУЮ тему (помимо signals , interrupts итп) - а именно драйвер терминала!  в книжке по libc это глава 17 - Low-Level Terminal Interface.


A struct termios records all the I/O attributes of a terminal.


вот такую программу частично я взял с сайта IBM

$ cat 43.c
#define _POSIX_SOURCE
#include <termios.h>
#include <stdio.h>
#include <unistd.h>

int main(void) {
  struct termios term;

  if (tcgetattr(STDIN_FILENO, &term) != 0)
    perror("tcgetatt() error");
  else {
    if (term.c_iflag & BRKINT)
      puts("BRKINT is set");
    else
      puts("BRKINT is not set");
    if (term.c_cflag & PARODD)
      puts("Odd parity is used");
    else
      puts("Even parity is used");
    if (term.c_lflag & ECHO)
      puts("ECHO is set");
    else
      puts("ECHO is not set");

    if (term.c_lflag & INPCK)
      puts("INPCK is set");
    else
      puts("INPCK is not set");

    if (term.c_lflag & IGNBRK)
      puts("IGNBRK is set");
    else
      puts("IGNBRK is not set");




    printf("The end-of-file character is x'%02x'\n",
term.c_cc[VEOF]);
  }
}

выволд на экран:
BRKINT is not set
Even parity is used
ECHO is set
INPCK is set
IGNBRK is set
The end-of-file character is x'04'

интересно..

(офф топик)
про puts и printf.  в чем разница. printf понимает символы форматирования а puts типа более простая
программа которая их непонимает. плюс puts в том что если мы незнаем будет ли у нас в переменной
символы форматирования то безопаснее юзать puts. примерно так судя по стековерфлоу.

из man puts:
 int puts(const char *s);
из man 3 printf:
 int printf(const char *format, ...);

еще полезняшка можно используя gcc получать нетолько .exe бинарник но и файл с ассемблером
чтобы недизассмблировать пример

$ gcc -o printf.exe printf.c -save-temps -masm=intel
тогда файл с кодом асемблера будет храниться в 
$ cat ./printf.s

еще момент. 
переменные в теле функции по крайней мере часть из них она размещается в стеке.
когда идет выход из функции то доступ к локальным переменным функции теряется. кактотак.
потому что все что в стеке то живет дышет меняется и движется.

(конец оффтопик)



а вот что делает баш при старте с настройками терминала. 
я использовал в strace флаг -v и смогу увидеть ioctk строки целиком необрезанные

$ strace  -v -e clone,ioctl bash

ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(2, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCGPGRP, [8315])           = 0
ioctl(255, TIOCSPGRP, [8317])           = 0
ioctl(255, TIOCGPGRP, [8317])           = 0
ioctl(255, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f07117c4490) = 8318
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=8318, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f07117c4490) = 8323
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=8323, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
ioctl(1, TCGETS, 0x7ffd59701040)        = -1 ENOTTY (Inappropriate ioctl for device)
ioctl(2, TCGETS, 0x7ffd59700fb0)        = -1 ENOTTY (Inappropriate ioctl for device)
ioctl(255, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(255, TIOCSPGRP, [8317])           = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0
ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0
ioctl(0, TCGETS, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


ксати видно что баш при старте еще создает парочку детей которые потом подыхают.

из man ioctl_tty вижу что

 TCGETS    struct termios *argp
              Equivalent to tcgetattr(fd, argp).
              Get the current serial port settings.


таким образом строки с TCGETS они нас неинеретсуют  ибо нас инерсуют строки которые меняют
дефолтовые настройки терминала.

тогда остаются строки

ioctl(255, TIOCGPGRP, [8463])           = 0
ioctl(255, TIOCSPGRP, [8465])           = 0
ioctl(255, TIOCGPGRP, [8465])           = 0

ioctl(255, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(1, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0

ioctl(255, TIOCSPGRP, [8465])           = 0

ioctl(0, TIOCGWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0
ioctl(0, TIOCSWINSZ, {ws_row=43, ws_col=190, ws_xpixel=0, ws_ypixel=0}) = 0

ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


причем я думаю что реально значение имеет последняя которая с SNDCTL_TMR_STOP or TCSETSW

сравним ее с теми анстройками которе есть изнаально утерминала

ioctl(0, TCGETS, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0

итак было:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

стало:
{c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}

разница реально есть.


сравним что делает xterm+./31-1.exe(самописная програма которая ничего неделает) при старте. видно что xterm  вызов SNDCTL_TMR_STOP or TCSETSW неиспольует (как баш)
и в итоге у терминала настройки выглядят так:

{c_iflags=0x500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

сравним с дефолтовыми

{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

они почти неотличаются. только вот этим флагом - c_iflags

так что я пока вот думаю что тот факт то когда мы запускаем хоть гном-терминал + 31-1.exe хоть xterm+31-1.exe потом мы ее стопим через -19 сигнал и при этом буквы на экране попрежнему можно вводить они работают.
а вот если мы берем баш и запускаем хоть bash хоть в xterm хоть в gnome-terminal то стоит 
нам баш застопить через -19 сигнал и уже нажатие кнопок непечатает на экране. тоесть как бутто получается что гажатие кнопок на экране обслуживает баш процесс что противорчечит тому что мы ране
писали что нажатие нокопок и печать на экарне осуживает ядро. так вот пртирворчения нет дело в том
что баш коода стартует он посылает в терминал (железку ) управяляющие команды которые 
в нем чтото пееркоючюат от дефолтовых настроек и он начинает печатать буквы только если условно 
говоря как я понимаб только при условии что баш их принял. а раз прцесс стоит то и наэаране пусто.

чтобы это доказать надо расшифровать строку


ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4400, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a31, c_line=0, c_cc[VMIN]=1, c_cc[VTIME]=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x00\x00\x00\x00"}) = 0


двигаем дальше на чем бы мы ни закончили.
мы будем говорить о том же самом только может быть немного с другого примера:

команда kill.
я с ней игрался. я запустил ее в том же окне что и баш

$ kill -19 $$

и я ожидал что также как вслучае голого баша что после этого окно терминала перестанет
печатать символы при нажатии на кнопки. однако это на удивление оказалось нетак.
я начал разбираться. я думал что что баш отфоркает себя. запустит килл. килл остановит баш.
закончит свою работу (правда оставшись зомби ибо код возврата стоячий баш прочитать неможет ибо 
шедулер незпускает хендлер у стоячего процесса). но поскольку килл неменяет настройки терминала я полагал что экран терминал "зафризиться". ан нет. окей. я запустил всторенный в баш kill он там
тоже есть оказывается. тоесть при его вызове никакого форка непроисходит команда работает прям из процесса баша

$ builtin kill -19 $$

однако эфект был прежний. экран незафризился.
ответ оказался (забегая вперед) логичным баш при запуске команды даже если она встроенная
он сбрасывает настроки терминаола (через ioctl) в дефолтовые настройки. там что этим все и обьясняется. теперь длинное обьяснение: 

у баша есть встроенный kill тоесть ему ненужно форкаться и юзать /bin/kill
он может сразу сам из себя из своего процесса это сделать. я думал что баш 
единственная проблема в том что
по дефолту баш почемуто юзает не свой builtin kill а внешний /bin/kill
как заставить баш юзать всегда свои билтины я пока незнаю. но можно bash заставить
персонально выполгить именно builtin а не внешний файл.

(окно1)$  builtin kill -19 $$

так вот моя идея была в том чтобы остановить баш причем через встроенную команду kill 
в том же окне где крутится баш. я думал что это приведет к тому что печать кнопок на экране
прекратится как она прекращается если остановить баш из другого окна. однако я был удивлен
что если остановить баш из того же окна с помощью builtin kill (тоесть баш себя нефоркает и минимальные телодвижения делает по сисколлам в этом случае) то при этом печать символов на экране
работает! в чем же прикол. я затрейсил баш из другого окна и увидел что во время даже
запуска builtin команды ( тоесть без форка) баш производит изменнеие настроек терминала!(казалось бы зачем?)

(окно2)$ sudo strace -v -e ioctl -f -p 10396
strace: Process 10396 attached

ioctl(0, SNDCTL_TMR_STOP or TCSETSW, {c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}) = 0

сравним настройки котоыре бащ выставляет перед запуском builtin и дефолтовые настройки
терминала

изменнеые:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

дефолтовые:
{c_iflags=0x4500, c_oflags=0x5, c_cflags=0xbf, c_lflags=0x8a3b, c_line=0, c_cc="\x03\x1c\x7f\x15\x04\x00\x01\x00\x11\x13\x1a\x00\x12\x0f\x17\x16\x00\x00\x00"}

(как получить дефолтовые - достаточно запустить бащ в новом окней через strace и взять первый 
ioctl TGETS)

гоча! совпадает! значит баш когда форкается для запуска внешнего бинарника или когда баш даже 
выполняет свой встроенный builtin ( тоесть другими словами когда мы набрали коману в строке 
приглашения в баш и тыкаем enter на ее исполнение и неважно она встроенная или это внешний файл) то он когда команду запускает что мы набрали он изменяет настройки терминала на дефолтовые.
опишу дефолтовые настройки терминала которые для нас имеют значение:
	а) если мы вводим буквы с клавы то активирована опция local echo и терминал то что мы ввели с клавы сразу дублирует на экране (если local echo выключен то терминал принимает наши кнопки с клавы и сохраняет их в свой внутренний буфер ) 
	б) набранные буквы терминал шлет в линию в /dev/pts только после нажатия Enter. 

Вот на эти настройки баш сбрасывает термиал когда мы в строке баша запускаем команду.
А когда выпонение команды закончено и управление возврашается к процессу баша (когда мы снова можем набирать команду в строке) то баш снова меняет настройки терминала на кастомные. они имеют два важных последствия: 
	а) если мы нажали на кнопку в терминале то нажатие воспринимается но на экране символ непечатается (режим local echo off). 
	b) терминал шлет в /dev/pts (в линию) букву как только она была нажата ( а не когда был нажат Enter. тоесть в дефолтовом режиме мы вводим строку и она лежит целиком в памяти терминала и неотправляется в /dev/pts до тех пор пока мы не введем Enter а в кастомном режиме кторый баш задает как только ударли по букве на клаве терминал мгновенно отправляет байт о букве в /dev/pt поэтому в дефолтовом режиме данные приложению (башу или другому) попадают только в форме строк целиком а в кастомном баш режиме данные летят в /dev/pts к внешнему приложению мгновенно побуквенно.  )

В кастомном режиме терминала (что задает баш когда мы находимся в режиме ввода командв командной строке) чтобы буквы печаатались на экране баш должен их отправлять в /dev/pts только тогда буква
печатается на экране. баш так и делает. как только он получает букву через /dev/pts он тутже вызывает сисколл write(2,) и печататет эту букву на экране. 

для нас конечно оба эти режимы в конечном итоге выглдядят одинаково но в том то и дело что 
под капотом они рабоают совсем по разному. вот это вылезает когда мы стопим баш в терминале
и у нас пропадает печать наших букв в окне терминала или если мы стопим какоето другой процесс
в окне терминала и у нас при этом буквы отлично печатаются на экране. вот она разгадка!!


итак еще раз: у нас есть терминал.  это желещка как жесткий диск или видеокарта и чтобы с ним работать нужен драйвер код в ядре. у нас терминал виртуальный но это особо роли неиграет 
он для ядра остаетая такой же железкой. терминал это клава и экран в одной железке. когда  у нас
окно терминала активно то ядро "маунтит" нашу реальную клаву в виртуальную клаву от терминала другим словами нажатия от кнопок летят в драйвер терминала. и по поводу экрана  - когда мы шлем 
данные в терминал ( об этом щас поговорим) то драйвер терминала шлет буквы в графическое окно
на физическом экрана ноутбука. для юзерского процесса связь с терминалом идет через /dev устройство ( также как есть при связт юзерского процесса с лююбой другой железкой. связь всегда идет через /dev устройство). для принятия нажатия кнопок процесс читает из /dev/pts а для 
печати на экране процесс пишет в /dev/pts. тоесть для программы  процесс  работы с терминалом
это чтение или запись в /dev/pts файл. между файлом /dev/pts и железкой(терминалом) находится ядро. оно принимает данные из терминала и пересылает их в /dev/pts и оно же принимает данные из /dev/pts и шлет их на терминал. в этом роль ядра. железка же (терминал) получив данные от ядра 
делает уже непосредственную печать на экране железки(терминала) тоесть железка трансформруем полученный поток байтов уже в физические символы на физическом экране. и здесь как видно что ядро только передает данные на железку и все а за само отображение на экране отвечает уже неядро а сама железка. и тоже самое про клаву железка принимает и транформирует механическое нажатие клавиш в поток байтов которые железка(терминал) уже шлет в ядро ( а ядро в /dev/pts чтобы приложение в юзер спейсе увидело получило). Таким образом работа с клавой и преоброзвание кнопок в поток байтов это не ядро делает а сама железка. ядро лишь принимает поток байтов. и еще важно что при желании 
можно подкручивать настройки железки. это все приводит к тому что мы можем настроить чтобы железка неслала в ядро нажатые кнопки пока ненажат Enter или наоборот чтобы железка мгновенно слала в ядро каждую нажату кнопку. Это все настройки самой железки. не ядро. ядро здеь неучаствует. также видно что и программа (баш например ) к этому неимеет никакого отношения. это все настройки самой железки. также можно настроить на железке чтобы нажатая кнопка сразу дублировалась на экране а можно настроить наоборот что нажатые кнопки небудут печататься на экране. Поэтому очень важно понимать что в случае "баш работает в черном окне терминала" у нас три компонента участвуют а выглядит все это как нечто единое. 

	bash ---- ядро ---- терминал (железка)   

каждый компонент играет свою роль. 

важно понимать что bash работает в юзерспейсе и непосредственно с терминалом невзаимодействует а делает это через ядро а конкретно через файл /dev/pts/x

	bash(user space) ---/dev/pts/x--- ядро ---- терминал

поэтому между нажатием кнопки на клаве на терминале и тем что это нажатие долетело до баша
должна произойти целая серия событий.
тоже самое между посылом байта из баша и отрисовываеием литеры на экране терминала должна
прозойти целая серия событий.

поээтому происходит целый ряд событий целый оркестр с момента как мы нажали кнопку на клаве
и как она отрисовалась (или неотрисовалась) в черном окне терминала с приглашением от bash

опять же хочу заметить что для терминала нажатие кнопки и отрисовыванием символа на экране
это в целом два независящих события поэтому если мы хотим чтобы они происходили один за другим то 
это еще надо настроить.

поправка такая еще - я там выше написал что ядро неиграет никакой роли в работате терминала кроме
как отправка байтов и получение. это и есть так если бы у нас терминал был реальной настоящей 
железкой (как это было много лет назад когда были реальные железные терминалы). а щас терминал 
виртуальный поэтому да в конечно итоге функцмонал железного терминала тоже обеспечивает ядро. условно говоря есть драйвер терминала в ядре для которого терминал это железка как настоящая с которой есть некий програмнй интерфейс и порты взаимодействия (через виртуальный com порт) и есть
еще кусок кода ядра который уже непосресдтвенно эмулирует живой железный терминал. но на мой взгляд  для более четкого понимания как все работает лучше представлять что мы имеем реальный железный терминал который через com порт соединяется с системным блоком компа. ( да то есть раньше комп выглядел так что был системный блок и несколько терминалов подключенных через COM порты к сстемному блоку. терминал был  ящиком железным в котором была обьедиенная  в одно целое экран и клава). таким образом между ядром и терминалом только летали байты а отрисовку на себя брала уже железка и прием кнопок с клавы и отсылку в систм блок брала на себя железка. соотвесвтенно 
уже на железке на терминале можно было например ввести строку и отредактировать еще не отправив
в системный блок. также на терминале можно было выбирать (наверное) шрифты цвета и всяке другие 
графические настройки внезависимости от системного блока от ядра. условно говоря терминал это был содеинное в одно три компоенента : граф карта , клава, монитор.  современный комп все это разьединил на три разные устройства каждое из которых коммуницируем  с ядром через свой порт.  а раньше они все сидели на одном COM порту который их соединял с сист блоком тоесть с ядром.


так вот bash он может делать настройки терминала через обращение к ядру черещ сисколлы ioctl_tty, ioctl а ядро тогда получив эти сисколлы подручивает настройки на терминале. что баш активно и делает постоянно. при своем старте. при своем окончании работы. при запуске команды. для 
нас это остаетается все невидимо и прозрачно если только нетрейсить работу баша или незастопить 
его процесс. и тогда мы обнаружим что нажатие кнопок в термирале приводит к тому чтобы они печатались на экране. вот тутто оно и вылезает!

опишем еще раз как работает связь взаимодействия между термиалом и юзерским процессом (приложением):

мы жмем кнопку на клаве это событие принимает обрабатывает терминал (железка если у нас железка или эмулятор терминала особый кусок кода в ядре что существенно что юзерский процесс  к этому неимеет никакого отношения и контроля над этим. единственный контроль который юзерскрйи процесс может сделать это заранее через сисколл ioctl попросить ядро покрутить настройки на терминале которые потом дествуют автономное без участия юзерского процесса). так вот мы нажали на кнопку 
терминал это принял и переработал в байт информации и положил в свой внутренний буфер ( если это желещка то в буфер железки если это виртуальный терминал то в буфер в ядре). далее если на терминале выставлены дефолтовые настройки то байт информации о нажатии клавы непередается в драйвер терминала ( непутать эмулятор терминала и драйвер терминала. эмулятор терминала эмулирует поведеие железки для кода ядра. а драйвер терминала принимает байты от эмулятора терминала либо реального терминала и пересылает их в /dev/pts файл чтобы юзерское приложение могло взаимодействоать с терминалом через ядро. дальше будем для простоты изложения счиать что терминал реальный железный а том мудота описания будет зашкаливать). так вот мы нажали кнопку ее считал терминал и положил в форме байта в свой буфер. далее если настройки натерминале дефолтовые то 
ничегоне произойдет  а именно терминал нестанет отправлять этот байт в COM порт в ядро. тоесть ядро неимеет представления на данный момент что была нажата кнопка а приложение тем более.
далее мы виваем еще несколько кнопока и они тоже записываются в буфер терминала. также в дефолтовой настройке терминала при нажатии на кнопку она автомтом отрисываоается на экране.
обо всем об этом ядро и приложение недогаюываются. они об этом незнают. далее мы можем нажимая спец копки на клаве даже редактировать введенную строку в терминал. об этом тоже ни ядро ни приложение незнают. потому что обовсем об этом по дефолту он недоакладывает в ядро а ядро соответвенно неможет доложить приложению. и наконец мы тыкаем на клаве Enter. это историческое событие потому что теперь терминал шлет всю эту строку в ядро через COM порт. ядро принимает 
байты. в свой драйвер терминала.  приложение по прежнему нифига незнает ни очем.  а между тем у
нас на терминале уже во всю светится та строка что мы ввели. но это абсолютно незначит что эта строка уже в памяти приложения. итак драйвер получил байты о кнопках и он отсылает их в /dev/pts/x.
и вот теперь юзер процесс может считать из /dev/pts и узнать о том что была нажат клава и какие кнопки.  опять же от того что драйвер ядра направил байты от кнопок в /dev/pts незначит что
приложение их автоматом получило. нет. приложение должно самостоятельно сделать запрос на чтение из /dev/pts  а если приложение сейчас занимается чемто другим и не делает запрос на чтение так 
оно и опять же без понятия о том что были нажаты кнопки. на практике приложение делает особоый 
сисколл типа select/pselect и засыпает переходит в S состояние. этот сисколл он следит за тем 
что в /dev/pts появились данные. таким макаром приложение может следить за тем что в /dev/pts прилетели кнопки. итак приложение заюзало при своем старте такой сисколл и он сработал , юзер программа будится и делает запрос на чтение.  и вот только теперь наконец нажатые кнопки 
смогли попасть в программу. !  соовтсветвенно когда теримнал с дефолтовым настроками то в программу
прилетает только строка целиком а непобуквенно. причем на экране терминала уже все нарисовано и 
только потом после Enter буквы появляются в приложении(опять же появляются только если в приложении настроен правильный сисколл а так могут еще хрен знает сколько времени непоявляться а на экране есть). соотсвтенно при такой схеме приложению ненужно обратно посылать эти буквы на /dev/pts с целью чтобы они отрисовались на экране терминала потмоу что они там уже есть. если их заново послать то тогда байты пройдя цепочку посредников обратно нарисут на терминале дубликат той же строки. а смысл? поэтому данная схема имеет свои плюсы и и минусы.

как уже сказал что у терминала можно подкручивать настройки. юзерская программа это может сделать
если исползует сискол  ioctl , ioctl_tty  с параметрами. тогда (через ядро) терминал будет подкручен и начнет работать по другому.

такую подкрутку делает баш. что он делает. баш когда стартует он делает ряд ioctl и меняент на 
терминале настройки. что меняется: если мы нажали кнопку то терминал немедленно (недожидаясь Enter) шлет байт с буквой в COM порт тоесть байт сразу улетает в ядро а оттуда в /dev/pts файл 
а  баше также настроен сисколл который ждет прилета инфо в /dev/pts таким образом нажатая кнопка на терминале мгновенно оказывается в недрах баша. минус такой схемы в том что баш должен предоставлять (как я понимаю ) встроенный редактор чтобы можно было редактировать строку символов (ведь раньше это можно было делать средствами самого терминала а теперь нет). вторая настройка касающаяся терминала состоит в том что после нажатия кнопки терминал автоматом ее неотображает на экране. вместо этого теперь баш когда он получил кнопку то он сразу шлет обратно в /dev/pts этот же байт. терминал принимает этот байт и отрисовывает. такая схема дает некую синхронность в том плане что все что мы нажали сразу оказывается в кишках ( в памяти) баша а то что он получил он отправляет обратно и мы это видим на экране. так что получается что то что на экране уже в кишках баша а что в баше то уже на экране.

но еще раз подчеркну что при такой схеме баш(юзер процесс) никак не играет роли в функции принятия кнопок с клавы или в отображении символов на экране.    

описанная схема работы баша обьясняет феномены такие как:
	- если мы в одном окне откроем баш который привязан к /dev/pts/x а во втором окне запустим 		cat  /proc/pts/x  и потом в первом окне начнем нажимать кнопки то часть наших нажатий отобразится на втором экране и только часть в экране баш. тоесть второе окно будет как бы красть часть наших нажатий. тоесть например мы нажали на клаве 123456 а увидим в окне1 и окно2
	вот что
	 (окно1) $  25
	 (окно2) $ cat /dev/pts/23
	 			136
	 как так вышло.
	 мы жмем на клаву в терминале окна1 и символ мгновенно улетает в /dev/pts на выходе из этого файла в юзерспейсе за его содержимое сражаются одноверменно два процесса bash и cat.
	 и только ктото один (по рандомному закону) считает очередную букву. когда то это будет баш когда то это будет cat. поскольку в терминале где баш он отключил автоматическую печать той кнопки которая была нажата то в этом окне будут печататьс только те симоволы которые баш получил из /dev/pts и обратно сам направил. вот символы 2 и 5 они все таки долеетели до баша (cat их несмог своровать) и баш их автоматом отправил обратно в /dev/pts терминал окна 1 их получил и напечатал. вот почему так все отработает. 
	 	Если бы баш включил local echo on настройку на терминале то тогда все наши нажатые в терминале окна1 кнопки 123456 они бы напечатались бы автоматом внезавимисоти от того что 
	 	из этого доолетело то баша. правда бы при этом кнопки 2 и 5 они бы два раза напеатались 
	 	один раз из за опции local echo on и второй раз из за того что баш их прислал обратно 
	 	через /dev/pts тоесть выглядело бы картина общая тогда бы так
	 (окно1) $  12234556
	 (окно2) $ cat /dev/pts/23
	 			136
	 
	 при этом еще раз подчеркну что баш внутри себя бы имел информацию толлько о нажатии на 2 и 5
	 а об остальных кнопках баш бы бы без понятия. тоесть если бы мы вводили вместо цифр буквы скажем  ls -1 то мы бы увидели (дублируем второй и пятый символ)

	 (окно1) $  lss -11
	 (окно2) $ cat /dev/pts/23
	 			l 
	 и мы бы непонимали что за хрен в командной строке баша откуда и почему. 
	 и если бы мы даже отредактировали то что там по факту осталось бы а недрах баша неясно.
	 и было бы непонятно после Enter почему линукс ругается на синтаксис что он неверный команды.
	 поэтому башу очень важно в режиме ввода команды в строке чтобы отображамый текст на экране
	 терминала в точности соотвествовал тому что реально долетело до баша. 
	 тоесть вот в этом случай
	 (окно1) $  25
	 (окно2) $ cat /dev/pts/23
	 			136
	 хотя до баша у нас долетела лишт только часть нажатий но хотя бы мы четко знаем и баш знает что внутри баша только 25 и на экране 25. полное соотвесвтие между оперативной памятью баша
	 и строкой на экране.

	 Поэтому когда баш запустился и мы увидели его приглашение в командную строку к этому моменту
	 баш уже подкрутил терминал на две вещи - выключил local echo и нажатие кнопки на терминале
	 мгновенно летит в /dev/pts. зачем он это сделал еще раз для того чтобы было четкое совпадение
	 того что напечатано на экране и того что сидит в памяти в окне терминала. Думаю теперь однозначно понятно что вообще говоря и особенно при дефолтовых настройках терминала то что мы видим на экране и то что долетело до приложения и сидит в его кишках это совсем необязано совпадать. ( а ведь интуитивно мы думаем что это одно итоже. что окно терминала это как бы окно в кишки баша или другого приложения а это совсем нетак.) баш можно представить как поле боя с танками самолетами. а окно терминала как карту. с одной стороны юзер генерал может двигать войска по окну терминала потом через ядро эти приказы летят к полю боя ( процесс)
	 но совершенно нефакт что либо одно долетело туда либо резултатты обратно. так что может получаться так что в окне терминала одно (карта поля боя) а на поле боя другое (кишки терминала). а интуитивно кажется что это одно и тоже. что это окно терминала это как бинокль или микроскоп напрямую в кишки баша. нет. скорее это карта на стене которая нарисована согласно телеграммам  с поля боя и нашим движениям руки двигающим фигурки на карте. может быть рассогласование. вот в чем подстава.

	 двигаем дальше.  такой режим терминала недефолтовый кастомный удобен и нужен только башу
	 на момент ввода команд но совершенно нефакт что он нужен программам которые он запускает
	 плэтому как только мы ввели команду отредоактировали и нажали Enter то баш перед тем как выполнять команду сбрасывает насторйки терминала(через сисколл ioctl) на дефолтовые. тоесть на терминале обратно включается local echo on и терминал посылает в ядро нажатые кнопки 
	 только после нажатия Enter. это в частности приводит к тому что когда мы запустили программу
	 в баше и он  там работает то мы можем нажимать кнопки в это время в терминале и они 
	 отрисовываются сразу. пример

	 $ ./39.exe
	 13
	 3 1
	 2213
	 1231
	 23214
	 14
	 1
	 4332
	 4


	 баш сбарывает настроки терминала на дфолтовые даже когда запускает свои builtin команды
	 пример такой команды:

	 $ builtin echo "1"

	 мы помним что когда выоплняется запущенная внешняя команда то это делается через создание
	 дочернего процесса clone+execve и на время работы чайлда баш впадает в спячку через wait.
	 когда команда отработала и дочений процесс сдох и произошел возврат в оживший процесс баш то 
	 баш опять меняет настройки терминала с дефолтовых на кастомные и так каждый раз.

	 соовтственно если исползовался builtin команда то дочернего процесса нет. просто когда builtin выполнился то бащ тоже убирает дефолтоые наторройки терминала и выставляет кастомные.

	 что мы имеем в остатке по практическим случаям:
	 	- если у нас в окне есть баш в котором ничего невыполняется  а просто висит
	 		приглашение командной строки и мы возьмем и застопим(из другого окна) процесс этого баша через SIGSTOP то в нашем исходном окне при нажатии на кнопки они перестанут печататься на экране. хотя по факту их нажатие фиксируется терминалом и направляется
	 		в ядро а оттуда в /dev/pts просто такак у нас local echo off то терминал недублирует
	 		их на экране а только пересылает в /dev/pts а так как баш остановлен то он обратно и 
	 		не пересылает буквы лежащие в /dev/pts поэтмоу на экране и пусто. но еще раз скажу нажатия кнопок фиксируются терминалом ( потому что терминал его эмулятор это ядерный код и он работает как прежде. то что баш остановлен терминалу глубоко пофиг. вот это важно еще раз понять. кнопки терминалом принимаются фиксируются и отправляются на /dev/pts через ядро. так что потери нажатий нет. в этом можно легко убедиться разблокировав баш через SIGCONT и мы тут же увидим на экране всю ту абрадакабру которую мы набрали в слепую. итак еще раз нажатия фиксируются нетеряются терминалом потому что его работа 
	 		обеспечивается ядром искючительно ядром. в том что кнопки фиксруются можно убедитьс разблокировав обратно баш. итак нажатия мы непотеряли. а то что они непечатаются когда бащ стоит здесь баш напрямую ни причем. он на это напрямую никак не влияет. просто до этого баш через ioctl настроил терминал чтобы он при нажатии на кнопку автоматом ее нерисовал на экране (потому что нажатие и отображение на экране это вооще то два разных события и мы можем настройками либо установить автопечать на терминале либо октлючить так вот баш заранее отключил) поэтому оно и нерисуется при нажатии. но нераюотающий баш здесь ни причем. когда он работает авторисование также неработало просто когда баш работал он это со своей строны компенсировал присылая обратно в /dev/pts полученные буквы. терминал их получал и печатал возникала иллюзия что нажатие на кнопку и печать на экране это как бы одно событие неразрываное. а так как баш остановлен то он не посылает обратно ничего на терминал)
	 	- если мы в баш запустили какую то долгоиграющую команду(если она недолгоиграющая то мы просто не успеем кнопки понажимать) то в это время при нажати на 
	 		кнопки на экране будут печататься символы. Это то к чему мы привыкли. ни баш ни команда запущенная к обработке и отрисовке этих символов неимеет никакого отношения. это чисто работает терминал. при запуске команды сам баш сбраывает настройки термиала
	 		на дефолтовые и если после этого команда неменяет настройки то просто нажатые символы их терминал только печатает на экране но нешлет в /dev/pts и только если мы нажмем Enter то терминал их пошлет в /dev/pts ну а там уже дело работающей команды читать из /dev/pts или нечитать. если команда небудет читать то эти символы выскочат в строке баша когда команда закончит свое действие и баш вернется обратно из спящего состояния. 	
	 вообще это интересная тема. если ты нажал на кнопки в терминале и ничего невидишь на экране 
	 это еще незначит что кнопки были не восприняты терминалом. а если ты видишь на экране символы в терминале это ще незначит что терминал отослал эти символы в /dev/pts а если и отослал это еще незначит что приложение их прочитало.

	 кстати еще момент. вот мы остановили наш баш через SIGSTOP (из другого окна) и окно его терминала "зафризилось" тоесть мы нажимаем на кнопки а на экране нет символов. можно легко убедиться что символы продолжают летеь от терминал в /dev/pts достаточно открыть второе окно и там ввести

	 $ cat /dev/pts/x

	 потом вернуться в первое окно нажимать там кнопки. потом вернуться во второе окно и мы там увидим все кнопки что мы нажали. тоесть терминал продолжает как прежде принимать кнопки
	 и посылать их в ядро  драйверу терминала а он в /dev/pts . так что терминал продожает рабоать кнопки нетеряются и замороженый баш на это никак невлияет и неможет повлиять. терминал это терминал ( эмулятор обслуживает ядерный код который условно говоря работает всегда и его неостановить неотключить потому что интеррапты неотключить) и он работает всегда вне зависимости
	 от того работают или зависли или остановлены юзер процессы связанные  с этим терминалом. надо четко понимать что терминал это одно а процесс это совсем чтот другое. кажется что терминал и процесс юзерский это чтото единое спаянное неразрываеное. это совсем нетак. связь между терминалом и юзерской программой это как связь между двумя людьми в разных городах которые обмениваются друг с другом телеграммами. все таки когда мы смотрим в черный экран мы смотрим в терминал (его обслживает ядерный код или даже это может быть железка) и все эти буквы на экране
	 это все терминал и только терминал. юзеркий процесс где то там  за дальними далями. просто юзерский процесс присылает телеграммы через ядро о том что бы он хотел чтобы терминал нарисовал 
	 на экране. вот какая связь между буквами на экране терминала и процессом. а нам кажется что мы 
	 видим буквы вот буквально как бутто это кишки баша. это совсем нетак. 

	 ффффууууухххх... вот так описание. вот баш вот так молодец. и терминал тоже тот еще молодец.

====================================
Posix
Single unix specification  (SUS) = X/Open Common Application Environment Specification
"Unix System V Interface Definition" (SVID)
ABI

Posix и SUS сейчас это одно и тоже.

и еще такое

POSIX:2008 = IEEE Std. 1003.1-2008 = SUSv4 = The Open Group Specification Issue 7.

posix включает в себя несколько томов:
	- Base Definitions
	- System Interfaces
	- Shell & Utilities
	-  Rationale

обычно если это pdf файл то там все тома сразу включены.
прикольно что они дают опредеение для файла а для иноды нет. зато в тексте спокойно
пользуются термином инода. недебилы ли?


далее
нашел стстатью computerworld 26 октября 1987 года.

там сказано что тогда было два документа "Unix System V Interface Definition" (SVID) 
который разработала AT&T. 

POSIX документ о томже самом но его разработал институт IEEE.

цель этих документов описаать стандарт взаимодействия между юзерской программой (user space )
и ОС (кернел спейс). тоесть описат те стандарты и инструменты которые предоставляет
ядро ОС для программы которая сидит в user space и видит эти инструменты с которыми можно общаться по определенным стандартам. тоесть для юзерской программы общение с ядром 
выглядит исключительно через инстурменты которые ядро предоставило в user space.
итак идея еще раз какая. есть ядро внутри себя оно может взаимодевтсивовать как хочет, но в сторону userpspace ядро ОС которая совместима с POSIX должно предоставлять определенные
инструменты таким обоазом с точки зрения user space программы любая ОС совместимая с posix
выглядит одинаково.  условно говоря доступ к файлу с точки зрения user space программы
дожлен выгляеть как /fodler/folder/fodler/filename

итак еще раз posix опиывет стандарт интерфейса между user and os. другими словами ядро предоставляет в userspace набор инстурментов с конкртеными характеристиками. таким образом неважно как ос выглядит на уровне кернел моде главное что для юзер программы любая posix совместимая ос выдает один и тот же набор инструментов поэтому выглядит одинаково.

таким образом юзер программа взаимодейтсивет с posix набором инстурментов(в user mode) и похеру что там по капотом у ос ( в кернел моде) . появляется portability программ между posix 
совместимымми ОС.

важно еще и то что если у нас есть несколко наших программ то друг с дружкой они будут 
взаимодейтсивовать (IPC) через опять же интерфейсы инструменты которые предоставляет ОС,
таким образом нетолько одна программа но и связка программ будет успешно взаимодействоввать
друг с другом как в одной posix os так и в другой. потому что еще раз - все межпроцессное
взпимодейтсвие всегда идет все равно через некоторые инстурменты(видные в user space) которые предоставляет ядро. а эти ipc инстрменты тоже оговорены в posix. 

возврашаемся к SVID - в статье сказано что в SVID указано много чего hardware specific 
что уменьшает portabilty насколько я понял уже речь идет о портабилити ОС а не user программы. в плане того что ОС будет  привязана к конкретному железу. В любом случае там
сказано что в SVID слишком много конкретики что делает его менее сильным в плане portability 
насколко я понимаю уже в плане железа на котором может работать ОС соответвующая SVID чем это есть у ОС которая соответсвтует POSIX.

поэтмоу немогу понять почему ABI привязывается к SVID а не к POSIX ?

в википедии abi опреляется как то что у нас есть две программы уже откомпилированные
и они друг с другом через железо могут обмениваться инфой. тоесть одна хочет другой
чтото передать , делает она это через железо определенным образом , вторая программа
хочет принять от первой инфо и она знает как первая использовала железо (условно говоря
первая прога положиме в регистр intel RAX ).  тоесть abi пропсиывает для бинарных программ
протокол обмена данными через железо - как это делать конкретно.

API описывает тот же обмен данными между двумя прогами но ! на уровне source code.
получается программист должен знать API, компилятор должен знать ABI.

как уже написал если мы пишем на C то это забота компилтора все делать как ABI пропсиывает.
(если только мы в C source неиспользуе вставки из головго асемблера)

api - дает возможность программам обмениваться информацияей друг с другом на уровне исходников. вообще это дебильное определение. тут смысл на самом деле такой - вот у нас есть ОС которая как бы одна программа. а есть наше user приложение которое друая программа.
ОС предоставляет некий набор инструментов на уровне source code для юзер программ.
если у нас будет две ОС у которых в кернел моде все работает по разному но в юзер спейс
они предоставляют одни и теже инстурменты , то для юзер приложения эти две ос идентичны,
поэтому мы берем source код нашей user проги несем в любую ос, компилируем там компилятором
от той ОС и она там работает на одном и том же source код. вот что значит блядь что api дает портабилити на уровне source code. когда мы говорим про api это значит что есть одна программа которая придумала api и его предоставляет и есть другая программа которая подчиняется этому api и следует ему. api это набор инстурментов верхнего уровня абстракции,
эти инструменты позволяют программа обмениваться инфо гвоорить на одном языке на верхнем
уровне абстракции на уровне языков программирования типа C. API конкретика описывается 
в source код первой программы и потом также отображается в source код другой программы.
условно говоря в первой программе мы говорим что у нас есть функция A и у нее есть один параметр который имеет тип целого. чеерз эту функцию мы будем обмениваться данными. это началось api.

A C standard library is a wrapper around the system calls of the Linux kernel; the combination of the Linux kernel System Call Interface and a C standard library is what builds the Linux API.

POSIX является api. но и нетолько там есть и еще доп контент.

посдення версия posix (читается ПАЗИКС): POSIX.1, 2013 Edition


api = это когда у нас одна программа порождает высокоуровневые сущности через которые другие программы могут обращаться к первой и они могут обмениваться данными. что это за сущности. 
наверное например это функции. функция это высокоуровнневая абстракция. 
первая программа поставляет функцию которая имеет один параметр и он скажем целого типа.
если вторая программа обратться к этой функции то сможет получить кусок данных от первой
программы или передать свой кусок данных для первой программы. вот эта функция и есть уже сущность составляющая API от первой программы. итак у API есть обяазательно поставщик
программа которая рождает и обеспечивает существование и работу некоторго набора высокоуровненвых сущностей через которые друние прграаммы могут комуницировать с программой
поставщиком. api обьекты создаются на базе высокоуровневых языков программирования.
итак конкретика api обьекта описывается текстовымм кодом на ввысокоуровневом языке 
прогрммирования. захера нужен api. это прослойка между программой один и внешним миром.
эта прослойка во первых дает связь межу программой и другими программами, и во вторыъ
эта прослойка абстрагирует скрыает внутреннюю кухню первой программы от внешнего мира.
тоесть программа один внутри может меняться но для наружных программ все выглядит всегда
одинаково. один пример это база данных (программа один). она наружу выкидывает набор api функций через которые можно к базе сделать запрос. а уже получив запрос база данных хитрым способом копается в кишках собирая ответ. таким образом для внешей программы внутренности
базы данных скрыты поэтому изнутри мы можем менять базу данных хоть сто раз надень как она там копается в своих кишках при поиске данных. второй пример ядро ОС. мы можем менять его сто раз на день его внутренний процессы но для юзер программы функции через которе ядро 
принимает заказы остаются теми же самыми. поэтому замена кишок ядра никак не влияет на source код юзер программы ибо ядро наружу выставляет всегда один и тот же набор функций.
условно говоря запорожец превратился со временем в бмв под капотом но для водителя это по прежнему руль и три педали. таким макаром у нас со временем ОС становится все более современной и звездатой ( поддерживает новые процесоры большие диски новые видеокарты) но при этом юзерскую программу ( редактор текста) переписывать на уровне source код ненадо. надо 
только перекомпилировать. 

когда мы слышим api то сразу надо спросить api для какой программы? потому что api без
программы источника которая предоставляет api небыавет. итак есть программа источник
она предоставляет набор функций и инструментов которые и составляют api множество.
итак api это неверный термин потмо что у api всегда есть два обьекта - первый это источник
api некая программа например ядро линукс. или веб сервер. второй обьект это набор инструментов
которые и составляют множество обьектов api. зачем все это. чтобы другие программы могли 
подключиться к этим инстурментам и через их помощь получить даные от первой программы или 
засунуть внутрь свои данные. поскольку программа это source код  ( как один из вариантов)
то физическим носителем api обьектов является source код высокоуровненовго язык програмирования, получается что более высокоабстрактные сущности api строятся на тех сущностях менее абстрактных который предоставляет язык программирования. 
прикол api  в том что он скрывает абстрагирует конкретику и внутренности как програаммы один 
от внешней программы так и внутренности внешней программы от программы один. 
на практике обычно важно то что мы написали программу юзерскую ( редактор) в форме source код на языке выскоуровневом програмировния и больше нехотим в нее вкладываться менять ее код.
тогда как бы неменяолсь ядро ОС со временем (линукс) нам ненужно менять код редактора 
текста он по прежнему работает хоть на старом линуксе хоть на новом на уровне source код.тоесть его только надо будет перекомпилировать. в этом и есть желаемая фишка.
потому что хоть внутрености программы один (ядраос) меняются но сисколлы которые ядро
предосталвяет остаются темиже. поэтому для юзер программы все api обьекты выглядят без 
изменений.

 
posix описывает api предоставляемое ядром(кодом раотающем в ринге0) UNIX подобной  ОС для user space программ(ринг3). таким образом если мы написали юзер программу которая взаимодейтствует
с posix api инструментами то эта программа должна работать без необходимости имзенения ее
source кода во всех ОС которые отвечают posix api. (единственное что юзер программу
нужно будет на каждой ос компилировать своим родным для ос компилятором, тоесть откомпиирванная на одной ос бинарник уже необязан работать на другой ос. только source код является перееносимым что уже круто.).
но posix описывает нетолько api которое предтвляет ядро ОС но и ряд дополнительных вешей. в целом получается что posix описывает как должна выглядеть вести себя ОС на уровне верхних абстракция на уровне сущностей выского уровня абстракции. вести себя и предоставлять эти 
сущности. например сущность  - командный интерпретатор. или терминал.



abi - описывает как конкретно две откомпилированые программы должны обмениваться данными 
через реальное железо. тоесть условно говоря если одна программа хочет передать 
данные в другую программу то она должна положить число в регистр EAX.тогда вторая программа
уже знает что данные лежат в EAX.
за реализацию ABI отвечают компиляторы на практике.

вообще это очень непросто понять все участников api или abi. какие стороны компоненты 
принимают участие в этих темах.  в случае api это точно две программы и язык программирования
через который две программы представлены в виде source код, в теле этих sourc кодов запрограмимрованы высокоуровненвые api сущности через менее высокоуровненвые сущности языка
программирования.

в случае abi это две программы и цпу. программы представлены на практике в форме  машинного кода который в свою очередь зависит от  типа цпу (intel 32bit, intel 64bit, arm 32bit, motorola). поэтому на каждый тип цпу свой abi документ. сущностями abi которе составляют его обьекты это  с одной стороны абстрактные сущности кода программы (функции нпример) а с другой стороны это сущнсости цпу (регистры) , ячейки памяти в RAM.

в вики написано что linux api предоставляет ядро и группа библиотек GLIBC.
тоесть носителем создавателем api является неодна программа а несколько - ядро и GLIBC.
ядро предоставляет в юзер спейс сисколлы а глибс функции обертки которые уже в свою очередь 
обращаются к сисколлам ядра.
пользовательккая программа может обращаться как напрямую к сисколлам ядра так и к 
glibc функциям.

что интересно прогарммы мы пишем на C. и язык C нам недает возможность обращатся к 
сисколлам. он только дает возможность обращатся к функциям glibc. а если мы хотим
из C обратиться к сисколлу ядра то надо в текст на C вставлять код на асемблере. 
с другой стороны кто сказал что язык программирования у юзер программы обязан быть C высокоуровневый. ассемблер тоже язык программирования. дауж.. намешали..




====

linux
static library vs dynamic library.

во время компиляции проги можно указать чтобы все библитеки которые ей нужны 
были вмонтированы в тело проги. тогда бинарник становится автономным. все куски кода
которые ему нужны будут вмонтированы в тело бинарника.  так вот вмонтирована в тело 
нашей прграммы будет библиотека в статическом виде.

статическая библиотека или динамичекая орпделеятеся на стадии компилировагния этой библиотеки
из исходного кода на стадии компиляции. берем исхоный код бибиотки компилируем с некоторыми
флагами и на выходе получаем либо файл который статическая библиотека либо файл
который на выходе динамическая библиотека.

файл который статическая библиотека будет использован для вмонтирования в тело 
другой программы при ее компиляции если мы укажем флагами при компилияции что мы хотим 
все библиотеки вмонтировать в тело программы. тогда комипилятор найдет все библиотеки 
которые нужны проге в их статическом виде и вмонтирует.

если же наша програ юзает библиотеку и мы при компиляции нашей проги укажем что
мы хотим чтобы наша прога юзала динамические библиотеки то тогда компилятор в теле нашей 
проге ее бинарника только сделает некие пометки а тело библиотеки небудет вклюать в тело 
нашей проги. зато потом когда прога запускется на выполнение динамический линкер 
найдет нужную билиотеку на диске или в памяти компа и "подключит" эту библиотеку как ссылку налету.

таким образом статиеская библиотекаа или динамическая определяется флагами при компилированиия
бибиотеки.  далее. статическая библиотека предназначена чтобы быть вмонтированной в тело 
программы в состав которой ее хотят включить. а динамическая библиотека предназначена для 
того чтобы загрузить ее в память компа а потом другие проги которые ее юзают при запуске динамиеским линкером будут в форме ссылки в памяти на нее слинкованы.

в чем плюс динамической библиотеки. если у нас 100 процессов и каждй юзает некую  библиотеку
то нуна только одна копия ее в памяти. а проги все которые запущены просто на нее ссылаются.

если бы у нас проги имели в своих телах эту библиотеку вмонтрованную то тогда бы в памяти 
сидело 100 копий этой библиотеки.

---------
===========================================
- как опредитедть что сидим на виртуалке 
ответ: cat /proc/cpuinfo | hyper
если есть слово hypervisor значит мы сидит на виртуаке а не реальном железном сервере
еще раз подчеркну что слово hypervisor неозначает что цпу поддверживает виртуализацию за это
ответчаюь другие флаги. этотфлаг именно означает что мы сидим под гипервизором.
====================================================

nestat
lsof
pid 
socket
network

- определить какой процесс открыл данный сетевой сокет
ответ: через netstat
$ sudo netstat -tnlp
Proto  Local Address           Foreign Address         State       PID/Program    
tcp    192.168.122.1:53        0.0.0.0:*               LISTEN      23404/dnsmasq   

видно что сокет 192.168.122.1:53 открыт проецессом с pid=23404
также замече что ключ -tnlp показывает только TCP сокеты(потому что -t = TCP. а если мы 
хотим также видеть UDP сокеты то нужно добавить ключ -u (UDP)
тоесть netstat -tnlpu
также можно это все увидеть через lsof
# lsof -i -a -n -P

- обратный вопрос. берем pid как узнать какие сетевые сокеты он открыл.
ответ через lsof

# lsof -i -a -n -P -p 23404
COMMAND   PID            USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
dnsmasq 23404 libvirt-dnsmasq    3u  IPv4 5278937      0t0  UDP *:67 
dnsmasq 23404 libvirt-dnsmasq    5u  IPv4 5278940      0t0  UDP 192.168.122.1:53 
dnsmasq 23404 libvirt-dnsmasq    6u  IPv4 5278941      0t0  TCP 192.168.122.1:53 (LISTEN)

вот еще удобная команда если знаем порт
# lsof -i:22
COMMAND  PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME
sshd    1109 root    3u  IPv4 19288701      0t0  TCP *:ssh (LISTEN)
sshd    1109 root    4u  IPv6 19288703      0t0  TCP *:ssh (LISTEN)

====

про цифры
про биты
система счисления
битность
bit



скажем у нас есть система счисления то есть колчество цифр (знаков) которые мы можем 
юзать для обозначения цисла.
например у нас есть 10 знаков\цифр =  0 1 2 3 4 5 6 7 8 9

о знаках\цифрах мы договорились.

теперь смотрим сколько чисел мы можем обозначит через эту систему десяти цифр при условии
что можно использовать для обозначения числа только одну цифру. 

 ноль   = 0
 один   = 1
 два    = 2
  ...   = ...
девять  = 9

количество цифр в числе обозначим как n (битность).

получается в десятичной системе ( 0 1 2 3 4 5 6 7 8 9 ) при битности n=1
мы можем закодировать числа от ноля до девяти.

посмотрим сколько мы можем закодировать чисел если битность два n=2 (две цифры в числе)

ноль = 0
один = 1
...  = ...
девять = 9
десять = 10
....
девяносто девять = 99

итак если битность n=2 то макс число это девяность девять (99).

далее ставится важный вопрос если у нас битность n то какое макс число можно получить 
в этой битности. ответ 10^n-1

проверяем:

n=1 , макс число = 10^1-1=9 и это правильно
n=2, макс число = 10^2-1 = 99 и это правильно

это мы узнали макс число в зависимости от биности. а теперь еще хотим узнать 
не макс число а количество чисел которое мы получаем в данной битности.

для n=1 мы заметили что мы можем закодировать числа от 0 ... до 9 
и их количество равно 10

для n=2 числа будут от 0 до 99, и их колчество равно 100

далее утверждается что для битности n количество получаемых чисел = 10^n

для n=1  10^1=10
для n=2  10^2=100

далее утверждатеся что если у нас система счислений не десятичная а некая другая
например двоичная ( 0 1 ) или шестнадцатиричная ( 0 1 2 3 4 5 6 7 8 9 A B C D E F)
то 

макс (max)число для битности n = S^n-1
где S это количество знаков в системе счисления
а количество чисел (summa) закодированных в через битность n = S^n

например

S=10, n =2
max = 10^2-1=99
summa = 10^2 = 100

S=2, n=2
max = 2^2-1 =3
summa = 4

S=16, n=2
max = 16^2-1=255
summa = 256

зачем нам все это надо.
нам нужно уметь легко понимать имея некоторую битность и двоичную либо шестнадцтраричную
систему - сколько при этом будет закодировано суммаоно чисел и какое макс число.

первый практический пример.
если битность n это количество проводов. и каждый провод обозначает свой бит на шине 
адреса в памяти то нам надо знать какой адрес будет иметь ячейка с макс адресом
и сколько всего ячеек можно адресовать через сколько бит.

например

S=2, n=8
max = 2^8-1 = 255 байт (это макс адрес ячейки в памяти)
summa = 2^8 = 256 ( вот столько байт мы можем адресовать для хранения данных)

S=2, n=32
summa = 2^32 = 4294967296 байт. это 4Gb ячеек. поэтому цпу у которого 32проводка на шине
адреса может адресовать максиум 4Gb памяти.

другой пример.
в юникоде каждая буква имеет свой 4 и 5 значный номер в hex формате.

вопрос сколько букв можно закодировать при таком раскладе

S=16, n=4
summa = 16^4 = 65 536 букв

S=16, n=5
summa = 16^5 = 1 048 576 (примерно миллион)


 а если у нас S=2 и битность 7 то

 summa = 2^7 = 128 букв тогда можно закодировать через двоичную систему и 7 бит

====================================
man

цветной вывод манов на экране.
раскрасить

засунуть в ~/.bashrc


export LESS_TERMCAP_mb=$'\e[1;32m'
export LESS_TERMCAP_md=$'\e[1;32m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;31m'


====================================
man
info 
doc

на счет где искать инфо по команде варианты

первый способ
$ man name
$ man 7 name

второй способ
$ info name

третий способ
и еще в /usr/share/doc/name
полазить

=======================================
bash
type

полезная штука чтобы узнать та команда
что мы вводим она встроенная или внешняя

$ type -t gcc
file
$ type  gcc
gcc is /usr/bin/gcc
$ type -t env
file
$ type -t type
builtin
$ type -a type
type is a shell builtin
$ type -a gcc
gcc is /usr/bin/gcc
$ type -a printf
printf is a shell builtin
printf is /usr/bin/printf

чтобы незапоминать ключи лучше всегд посмотреть в man bash

=======
bash
hash
type

оказывается что каждый раз когда мы вводим команду в баше
он ее ищет в $PATH ( и это понятно) но потом самое главное он найденный путь запоминает.
и уже при повторном вызове.

посмотреть можно через hash (bash builtin) 

$ hash -l
hash: hash table empty

$ env

$ hash -l
builtin hash -p /usr/bin/env env

$ gcc

$ hash -l
builtin hash -p /usr/bin/gcc gcc
builtin hash -p /usr/bin/env env



следущая задача. мы хотим понять вот у нас есть команда . мы хотим понять 
где она лежит на диске а точнее откуда ее будет брать basр при запуске.
If you want to see the path to your program i suggest to use "$type -p" :

$ type gcc
gcc is hashed (/usr/bin/gcc)
$ type -p gcc
/usr/bin/gcc
-p key description:

If the -p option is used, type either returns the name of the disk file that would be executed if name were specified as a command name, or nothing if ``type -t name'' would not return file

Sometimes -p key is not enough. -a key will help:

$ type -p printf
$ type -a printf
printf is a shell builtin
printf is /usr/bin/printf


далее вот у нас есть команда мы хотми понять это встроенный в баш builtin 
или это внешнаяя команда используем type -t



$ type -t echo
builtin

ключ -p показывает где на диске баш будет искать команду
но так как echo это встроеный builtin то ключ -p покажет пустое место
$ type -p echo

а вот так как gcc это уже внешняя команда  то ключ -p покажет где ее будет брать bash
$ type -t gcc
file
$ type -p gcc
/usr/bin/gcc

если мы хотим проверить то что программа является и билтином и внешней командой
то ключ -a

$ type -a echo
echo is a shell builtin
echo is /bin/echo


это показывает что echo есть как в форме внешней команды 
так и внутри в баш в форме builtin

кстати. вот видно что у баш есть свой билтин echo. но это незначит что если мы напишем

$ strace echo ...

то будет исползован баш билтин. команда strace походу недогадывается об этом поэтому
она запустить внешний echo. 

============
bash
help
builtin

если у нас есть какойто builtin из баша
и мы хотми по нему прочитаь справку  один вариант это man bash и там листать вниз 
до описания билтина а второй вариант

$ help имя_builtin

пример

$ help type

=============
unset 

что она делает.
это bash builtin. 

она уничтожает обьявленную переменную баша.

тоесть

создали переменную в баше
$ ww=10
$ set | grep ww
ww=10

удаляем эту переменную
$ unset ww
$ set | grep ww

инфо об unset ищи в man bash

===
bash
readonly

в баш можно назначать ридонли переменные
для этого есть всторенный билтин reeadonly.
кстати он может покзаать спмсок ридонли переменных ключ -p

$ readonly -p

declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:progcomp:promptvars:sourcepath"
declare -ir BASHPID
declare -ar BASH_REMATCH=()
declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
declare -ir EUID="1000"
declare -ir PPID="3866"
declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor"
declare -ir UID="1000"


=================
$ echo $BASHPID
15962
$ echo $$
15962
=================

bash
builtin 
fc


встроенная команда fc
позволяет выдать список команд без номера.
типа аналог history

показать последние 10 команд
$ fc -l -10
2008	 ls
2009	 fc -l -10
2010	 fc -l -100
2011	 fc -l -10
2012	 ls -1
2013	 ls 
2014	 ls -1
2015	 ls
2016	 fc -l -10
2017	 ls -1


но еще она умеет выполнять команды из history.
выполнить все команды из history начиная с команды номер 2014
$ fc -s 2014

справка по fc

$ help fc
$ man bash



=====
bash 
subshell

обозначается как
$ ( command1; command2...)

перед тем как отвечать на вопрс что такое субшелл и зачем оно нужен ответиим на другое.
вот у нас есть сеанс баш это процесс. и в мы в нем запускаем внешнюю команду. что при этом
происходит. баш себя клонирует в новый процесс. потом в новом процессе запускается execve с бинарников внешней команды. далее поскольку это новый процесс независящий от парент процесса
то чтобы ни делалла внешняя команда в новом процессе это никак невлияет на наш исходный баш процесс. никак. 

если мы в текущем сеансе\процессе баша запустим невнешнюю команду а builtin то баш себя
форкать небудет а будем выполнять эту команду в текущем процессе. со всеми вытекающими. какими? например мы с помощью builtin меняем некоторую переменную. и она в итоге будет изменена в текущем сеансе баша. 

а теперь вопрос- а если мы хотим запустить bash builtin но чтобы при этом он смоге поменять 
ничего в нашем текущем процессе баша (переменные и все остальное) - вот для этого и исползуется
субшелл.

что такое субшелл. это баш берет и клонирует себя (форкает). но далее execve он невыполняет в дочернем процессе. действительно а зачем если дочерний процесс уже баш. таким образом с одной стороны дочерний бащ (он же субщелл) получит в наличие все переменные котрые были в парент процессе с другой стороны чтобы ни делалось в дочернем процессе оно уже никак не полвияет на парент процесс. так вот далее в дочернем процессе выполняются все команды которые находятся в скобках.

$ ( command1; command2...)

естствеенно что если в скобках у нас одни buitin то они будут выполенны все в субщелл процессе
а если там есть внешние команды то субшелл еще раз форкнется и выполним execve в дочернем от себя процессе. но важно то что если в субшелле только buitin команды то они максимум могут 
поменять переменные в субшелле а в парент процессе они ничего поменят немогут. 
Итак еще раз если у мы запускаем внешнюю команду то она в текущем баше поменять точно ничего
неможет потому что баш выполняет внешнюю команду через fork+execve тоесть в новом дочернем процессе. так что внешнаяя команда никогда ничего в нашем баше поменять неможет. а вот билтин
команда выполняется в текущем процессе баша и она может много чего поменяь в текущем процессе баша например каккуюто переменную. если мы нехотим этого. если  мы хотим себя от этого 100% предохрнаить то надо запустить билтин команду в субшелле. ради этого субшелл и былпридуман.

пример

$ qq=10
$ echo $qq
10

в первой строке вы запустили билтин. и он нам создал\изменилт переменную в нашем 
текущем процессе.


$ echo "текущий процесс pid=$BASHPID. qq=$qq"; ( echo -n "субшелл pid=$BASHPID. "; qq=20; echo -e "qq=$qq"); echo "текущий процесс pid=$BASHPID, qq=$qq"

текущий процесс pid=20328. qq=10
субшелл pid=21200. qq=20
текущий процесс pid=20328, qq=10

мы видим что в парент процессе qq=10
в субшелл процессе мы поменяли и qq=20
однако после этого в парент процессе qq по прежнему равен 10.

вот для этого и был придуман субшелл. тоесть если мы хотим 100% быть уверенными что 
наши buitin команды неизменят наш текущий процесс то тогда их надо засунуть в субшелл.


Также можно заметить что я использовал $BASHPID а не привычный $$. почему?
потому что - согласно практике выянилось что переменная $$ невсегда показыает коректный pid процесса.

пример

$ echo $$
21006
$ (echo $$)
21006

что за херня. ведь мы же знаем что субшелл это новый процесс.почему одинаковый pid покзывает.

пробуем другой способ

$ echo $BASHPID
21006
$ (echo $BASHPID)
21092

вот уже похожде на правду.

вот что man bash нам пишет про $ и BASHPID:

 $      Expands to the process ID of the shell.  In a () subshell, it expands to the process ID of the current shell, not the subshell.

 BASHPID
              Expands to the process ID of the current bash process.  This differs from $$ under certain circumstances, such as subshells that do not require bash to be re-initialized.

таким образом даже в мане написано что $$ в субшелле показывает неверный pid процесса.
а BASHPID всегда показыает верный pid процесса. а мы и работаем в субшелл поэтому я 
использовал BASHPID которы всегда показывает верный pid процесса.

далее про субшеллы - нашел в man bash фразу:
 Builtin commands that are invoked as part of a pipeline are  also  exe‐
       cuted in a subshell environment.  Changes made to the subshell environment cannot affect the shell's execution environment.

тоесть если у нас есть pipe между builtin то они оба выполняются не в текущем процессе
а оба выполняются в отдельных субшеллах. это важно . я проверил через strace и это подтвердиолось.
пример

$ ds=10 | echo $ds

$ echo $ds


как видим везде пусто. а теперь обьяснение.
первая строка. у нас есть два билтина и они разделены пайпом. раз есть пайп то как мы уже прочитали в man то что делает наш баш. он берет клонирует себя два раза из текущего состояния.
тоесть текущий баш имеет pid=12,
создается pid=13 и pid=14 и вывод из pid=13 прписывается в ввод pid=14,
далее в pid=13 запускается ds=10 
и в pid=14 запускается echo $ds

тут важно понять что pid=13 и pid=14 получены из pid=12 на момент когда там небыло никакого
ds=10. дададада! дело в том что ds=10 будем запущен в pid=13 а pid=12 неимеет никакого понятия об ds=10.

итак еще раз. мы имеем пустой pid=12 наш головной баш. в нем нет переменной ds=10.
потому что эта команда она еще небыла запущена мы ее только собираемся запускать.
далее мы ввели две команды через пайап и тыкнули энтер. баш эти команды невыполняет. нет.
он вначале себя клонирует два раза. поэтому и головной баш и его два клона они абсолютно
одинаковы в том плане что в них пока нет никакого ds=10.
далее уже в дочернем процессе pid=13 баш запускает то что слева от пайпа тоесть ds=10. и там он появляется. в pid=14 он запускает echo $ds но pid=14 неимеет никакого ds у себя поэтому выовод первой строчки пустой! также так как вывод ds=10 пустой то совершенно неимеет роли что вывод из pid=13 направлен на ввод pid=14. тем более что echo он ничего нечитает из станадартного ввода. вот из за всего этого вывод первой строчки пустой! таким образом пееременная ds=10 она будет создана только в pid=13 но ее небудет ни в pid=12 ни в pid=14.
и именно из за этого вторая строка тоже пустая! потому что в pid=12 нет никакого ds=10 !

вот как ! и все это именно из за того что если мы имеем пайп то команда слева и справа обе будут запущены в отдельных процессах и неважно это внешние команды или builtin. таким образом builtin невсегда выполняется в текущем процессе! вот это я и хотел показать!

я проверял через strace что билтины справа и слева дейтсвительно запускаются в
 отдельных процессах

=================

bash

{ ..;}

такие кавычки это просто визуальная оформлялка группировка команд.
тоесть что есть эти кавычки что их нет. все равно. команды внутри этих ковычек исполняются
в текущем процессе если это билтины.

$ echo $BASHPID
23616
$ { echo $BASHPID; }
23616

вот. видно что и так и так это один процесс

чем она еще удобна  - тем что можно удобно вводить много строчные команды  неиспользуя знак "\"

$ { echo 1;
> echo 2;}
1
2


==================

bash

(( ... ))

двойные скобки.

это билтин.предназначены для вычисления арифметических операций.
неимеют ничего общего с одинарными скобками которые субшелл.
в мане написано что расчеты идут исходя о том что операнды это fixed-width integers.
это точная копия билтина let "expression" 

сразу скажу про let
let "expression" это полный аналог (( expression )) 
при использовании let обязательно  нужно использовать двойные кавычки иначе будет мудота потому что иначе нужно будет экранировать спецсимволы а это ужасно неудобно
ненужный оверхед которого нет у двойных скобок.

$ let  "5>4"  && echo "5>4   # проходит без проблем
$ let  5>4  && echo "5>4"    # ошибка
bash: let: expression expected
$ let  5\>4  && echo "5>4"   # прошло но нужно экранировать
5>4

что интересно в man bash про let совсем неуказано что нужно юзать двойные кавычки.
там сказано что 
 let arg [arg ...]
а в man bash про двойные кавычки (ищи по слову compound) там указано что  (( expression))
это полная аналогия let "expression". тоесть описание двойных кавычек как бы намекает что в let надо использовать двойные кавычки.
также прикольно то что если у нас двойные кавычки (()) то понятно как напечатать на экран
их резултат
$ echo $(( 3+ 5))
8

а как распечатать на экран если мы спользуем let я непонимаю
$ echo let "3+5"
let 3+5




двигаем дальше
поддерживаются все простые мат операции +-*/^

$ (( 3+5 ))
$ (( 3-5 ))
итп

но вывода никакого нет на экран.так что в таком виде от команды мало толку. единственное что
если внутри сравнние что можно использовать то что команда возвращает резульатат 0 или 1 в зависимости от того true внутри или false

пример
$ (( 5 > 4 ))

результатом будет код возврата либо 0 либо 1

$ (( 5 > 4 )) && echo "5>4"
5>4

теперь переходим к выводу на экран.
$ echo $(( 3+5 ))
8
наконец получили вывод на экран.


также важно отметить что внутри скобок (( )) если мы обращаемся к переменной то 
знак доллара ненужен. это первая особенность (( )) и переменных внутри них.
$ n=10; (( n+1 ))

еще важный момент про (( )) и переменные это то что часть команд неменяет переменные(что логично) а часть команд внутри (()) меняет переменные! это вторая особеность двойных скообок и переменных внутри них.

щас я приведу команды которые меняют переменные внутри скобок
= *= /= %= += -= <<= >>= &= ^= |=
и  id++ id-- ++id --id
я щас ниже обьясную что каждая команда значит. важно главное щас понять что 
если знак равно испольуется то переменная будет изменена. а если знака равно  внутри нет
значит переменная небудет изменена. но есть одно исключение вот эти команды 
id++ id-- ++id --id они хотя и неимеют знака "=" но они меняют переменную.
начинаю расшифрроввывать что эти команды значат


			 id++ id--
              variable post-increment and post-decrement
       ++id --id
              variable pre-increment and pre-decrement


$ n=16; echo $(( n++  )); echo $n
16
17
$ n=16; echo $(( ++n  )); echo $n
17
17

как видно переменная изменилась, причем знака "=" нет и также обращение к переменной 
идет без знака доллара.


разницы между этими командами нет в конечном итоге
на переменную. есть разница в выводе echo (пока незнаю почему)

тоесть видно что пеерменная n=17  вобоих случаях( и это главное). но echo покажет разный результат.(это второстепенное хотя и любопытно)

еще раз подчеркну что переменная меняется при этом к ней обращение идет без знака доллара $
и без знака "="
$ a=2334
$ (( a++ ))
$ echo $a
2335


еще пример на эту тему
$ a=2334
$ (( a=a+1 ))
$ echo $a
2335



расшифровываю операции:
       = *= /= %= += -= <<= >>= &= ^= |=
              assignment


рассмотрим первое =
$ echo $(( a=5 ))
5
$ echo $a
5

тоесть это просто операция присваивания

дальше интереснее *=
фишка этого обозначения в том что это операция умножения и присвоения одновременно.
тоесть

(( a*=5 )) эквивалентно (( a=a*5 ))

пример
$ a=10
$ echo $(( a=a*10 ))
100
$ echo $a
100
$ a=10
$ echo $(( a*=10 ))
100
$ echo $a
100

отсюда видно что я доказал что (( a*=5 )) эквивалентно (( a=a*5 ))

Так вот далее по аналогии все оставшиеся операции /= %= += -= <<= >>= &= ^= |=
это арифметическое действие и присвоение. тоесть 

/= это деление и присвоение
%= нахождение остатка и присвоение
+= суммирование и присвоение
-= отнимание и присвоение
<<= это сдвиг влева на некоторое число бит и присвоение
>>= сдвиг вправо и присвоение
&= битовый AND и присвоение
^= битовый XOR и присвоение
|= битовый OR и присвоение

примеры
деление и присвоение
$ a=10
$ echo $(( a/=5 )); echo $a
2
2

остаток от деления и присвоение
$ a=10
$ echo $(( a%=3 )); echo $a
1
1

сумммирование и присвоение
$ a=10;echo $(( a+=3 )); echo $a
13
13

отнимание и присвоение
$ a=10;echo $(( a-=3 )); echo $a
7
7

сдвиг влево и присвоение
$ a=3;echo $(( a<<=1 )); echo $a
6
6

обращаю внимание что при сдвиге слева новый бит он нулевой 
тоесть 
было   11
стало 110

сдвиг вправо и присвоение
$ a=15;echo $(( a>>=1 )); echo $a
7
7

было 
1111
стало
0111


битовый AND и присвоение
$ a=15;echo $(( a&=6 )); echo $a
6
6

тоесть 
15=1111 AND 
 6=0110 
---------
   0110 


битовый XOR и присвоение
$ a=15;echo $(( a^=6 )); echo $a
9
9

тоесть 
15=1111 XOR 
 6=0110 
 -------
   1001 

битовый OR и присвоение
$ a=15;echo $(( a|=6 )); echo $a
15
15

тоесть 
15=1111 OR 
 6=0110 
 -------
   1111


далее. еще обращаю вимание на важный момент:
 операции id++ id-- они увеличивают\уменьшениют на один значение переменной
и переприсваивает это значение этой переменной
несмотря на то что id++ id-- не имеет никакого знака равно как скажем вот здесь "+="
тоесть помне было бы более правильно если бы вместо "id++" было "id++="
это совпадало бы по синтаксису с *= /= %= += -= <<= >>= &= ^= |=
из этого  я бы  сформулировал правило о том что переменную меняет только 
та команда у которой есть = за исключением id++ id-- они меняют переменную хотя
в себе несодержат =
нам очень важно понимать поменяет ли (( выражение)) переменную внутри или нет.

примеры на эту тему
здесь пример меняет переменую потому что есть знак =
$ a=15;echo $(( a*=6 )); echo $a
90
90

вот пример где значение перменной меняется хотя знака "=" нет
также интересно отметить что echo $(( a++ )) возвращает 15 а не 16
$ a=15;echo $(( a++ )); echo $a
15
16

меняем переменную потому что здесь есть "="
$ a=15;echo $(( a=16 )); echo $a
16
16

еще хороший пример. значение перемменной неменяется потому что нет знака "="
$ a=15;echo $(( a>>1 )); echo $a
7
15

а вот пример когда уже битовый сдвиг плюс переприсвоение переменной происходит потому что 
есть знак "="
$ a=15;echo $(( a>>=1 )); echo $a
7
7

операции которые еще поддерживаются:
       - +    unary minus and plus

что такое унарная мат операция. это операция которая требует только один аргумент 
( в отличие от обычной мат операции которая требует два аргумента).
по факту унарный минус это такая операция которая делает то что если у нас есть
какой то аргумент то унарный минус из него создает число противоположное. тоесть
было 2 стало -2. было  -2 стало -(-2). унарный плюс вобще по мне нихера неделает ибо
он ничего неменяет. унарный минус и плюс это операция высшего порядка выполняется первой.
примеры
$ n=10; echo $(( -n ))
-10

$ n=-10; echo $(( -n ))
10
важно отметить что сама переменная n неменяется.

как баш отличает унарный минус от бинарного(стандартного ) минуса.... хм.. незнаю.
но вот пример
$ n=-10; echo $(( 1 - -n ))
-9

здесь один минус бинарный а второй унарный. по сути мы имеем 1- -(-10)=1-10=-9




следущая операция:
       ! ~    logical and bitwise negation
переходим к булевым операциям и битовым операциям одноврмеенно

по поводу двойных скобок в man bash сказано - If the value of the expression is non-zero, the return status is 0; а 0 это булевский TRUE.
таким образом если у нас неноль то код возврата TRUE
примеры
$ (( 1 )) && echo true || echo "false"
true
$ (( 100 )) && echo true || echo "false"
true
$ (( -100 )) && echo true || echo "false"
true
$ (( 0 )) && echo true || echo "false"
false
$ (( 5>4 )) && echo true || echo "false"
true
$ (( 5<4 )) && echo true || echo "false"
false

так вот ! это булевский NOT

$ (( ! 1 )) && echo true || echo "false"
false

важно то что ! нельзя  ставить вполтную к числу  обязатеьно отдельно.
$ (( !1 )) # здесь получаем ошибку
bash: !1: event not found

еще пример
$ (( ! 5>4 )) && echo true || echo "false"
false

переходим к "~" bitwise negation тоесть эта операция которая унарная кстати и она что делает
она берет число в бинарном виде и нули превращает в единицы а единицы в нули.
скажем было 0000 стало 1111.

закончил вот на этом
$ echo $(( ~ 0 ))
-1
$ echo $(( ~ 1 ))
-2
$ echo $(( ~ 100 ))
-101
типа что за прикол? 
============================
============================
щас будем разбирать. 

начнем с того как на компе кодируются отрицательные числа.
во первых надо понять что в конечном итоге все данные на компе имеют вида байта или нескольких байт тоесть это некоторый кусок битов. 01010101010101010101010101010
поскольку все операции идут  в цпу то будем рассматривать в качестве хранилища этих битов регистр общего назначения в цпу. 32 бита или 64 бита. будь это отрицательное для нас число 
или положительное внутри регистра в любом случае никакого знака минус небудет. там будет сидеть 32 либо 64 бита нулей и единиц 010101010101010101001.

разберемся какой вид имеет отрицательное для нас число внутри регистра.
вопросы: 
"понимает" ли цпу какое число в его регистре положительное или отрицательное?
навскдку действительно непонятно как обьяснять цпу или он сам это понимает отрцательное
число лежит в регистре или положительное?
как цпу работает с отрицательными числами как он арифм операции с ними выполняет?
начнем разбирать.

section .text
global _start

_start:
    mov ax, 0xA1
    sub ax, 0x30


    xor rdi, rdi
    mov rax, 60d
    syscall


тут я вспоминаю что 16 битный регистр AX состоит из двух 8битных регистров AH и AL
        AX
------------------
| AH    |   AL   |
------------------

из программы я увидел что AL это дейтсвиельно младший байт в AX
(gdb) print /x $ax
$3 = 0xa1
(gdb) print /x $ah
$4 = 0x0
(gdb) print /x $al
$5 = 0xa1


тоесть поскольку 0xA1 это 8битное число. то оно должно быть загружено в младший байт
и мы видим что AH=0 а AL=0xa1

после операции substraction
мы имеем

(gdb) print /x $al
$6 = 0x71

(gdb) print /t $al
$9 = 1110001

$ echo "obase=16;ibase=16; A1-30" | bc
71

$ echo "obase=2;ibase=16; 71" | bc
1110001


здесь все понятно все ожидаемо. A1 > 30 поэтому результат точно положительный. 
здесь пока все понятно. бинарный вид ответа полностью понятен. 

теперь отнимем наоборот 0x30-0xA1 тоесть от меньшего числа отнимаем большее число.результат заведомо отрицательный.

кстати вот флаги после SUB операции:
(gdb) info registers eflags
eflags         0x206	[ PF IF ]


итак отнимаем 0x30-0xA1
смотрим состояние регистров после операции SUB
		 0x0000000000400080 <+0>:	mov    ax,0x30
=>	 0x0000000000400084 <+4>:	sub    ax,0xa1


(gdb) print /x $al
$3 = 0x8f

(gdb) info registers eflags
eflags         0x293	[ CF AF SF IF ]

0x30=00110000
0xA1=10100001

отнимаем
	00110000
	10100001
  ---------
 я вычитать бинарно неумею но комп на выдал в качестве ответа
  10001111

поступим от обратного. прибавим ответ к вычитаемому

10001111
10100001
---------
00110000

в итоге да мы получили то число из которого вычитали.
правда происходит активация флага переполнения.
итак стало понятно что делает комп когда вычитает большее число из меньшего.
он срабатывает как одометр на машине.

мы отнимали 0x30-0xA1 это  48-161. комп по идее должен был отработать при отнимании
как одометр. тоесть идея какая мы имеем счетчик на 48км и нам надо проехать 161 км.
и одометр работает в обратную сторону. тоест машина проедет 48км счетчик при этом станет 0.
и потом он начнет откручиваться в обратнку сторону еще 161-48 км = 113км и счетчик будет показывать вначале 0 потом 255(max число для 8бит регистра) потом 254 итд.
значит в итоге счетчик  должен показать 255-113+1=143
сверяем с ответом от цпу . его ответ 
(gdb) print /x $al
$3 = 0x8f

0x8f = 143(dec)
совпало!

теперь стало совершенно понятно как в цпу работает побитовое отнимание. 
оно работает как одометр машины который крутится в обратную сторону когда едет машина.
тут важно отметить что через регистры общего назначения происходят арифметически операции
для целых чисел с точки зрения цпу. ну или давай скажем так цпу незнает ни что такое целые
числа ни что такое с плавающей точкой ни что такое числа положительные ни что такое числа
отрицательные. для него этого ничего нет. у него только есть регистры с битами.
далее мы натарвливаем команду на цпу такую как SUB подсоввывая в качестве источников данных
биты из регистров общегон назначения и цпу далее манипулирует битами в этих регистрах 
согласно некоторых микросхемам транзисторов внутри. для цпу суть операций выглядит в том
что он берет оттуда биты маниплирует ими и обратно помещает некотрый набор битов вот и все.
для цпу нет никаких чисел у цпу нет таких абстракций. у него есть набор битов и он ими должен както сманипулировать согласно команде которую ему указали. на выходе получает набор битов.
а дальше это уже наше дело человека както интерпретировать эти биты.  так вот получается
что если каждый бит в регистре цпу мы уже как человеки будем ставить в соотвествие с цифрой на одометре(просто одометр с бинарными цифрами 0 и 1 а не  с десятичными 0 1 2 3 4 5 6 7 8 9) то мы увидим что данные биты кодируют целые положительные числа. есть прямое соотвествие.
тоесть создатели цпу они так внутри создали микросхемы что биты в регистрах общего назначения
имеют смысл целых чисел  через двоичную запись при условии что мы над ними выполняем
арифметические операции. тоесть при запуске команды 
	sub ax, 0xA1
цпу так запрограммирован изнутри что биты начинают иметь физический смысл целых чисел 
положительных. и над ними производится операция вычитания.
итак еще раз ответ на вопрос есть ли внутри цпу целые числа или положительные числа
или отрицательные числа - внутри цпу есть биты. биты это как лампочки на елке 
это просто биты просто лампочки висящие на грозди. они в целом к числам неимеют отношения.
так же как пять слонов стоящих вряд они к числу 5 неимеют отношения прямого. это мы люди
делаем такое абстрактное соотношение.  но создатели цпу так настроили эти биты что 
в целом есть прямая связь между положительными целыми числами в двоичном формате 
и битами в регистре. пример
mov ax, 0xA1

здесь мы говорим чтобы в регистр AX было записано число. но число это абстрактное понятие в голове людей это не банан не апельсин это обьбект которого нет в природе в физ форме в физ виде. это либо клякса на бумаге либо картинка в голове у человека. у цпу нет мозга так что 
когда мы просим  в цпу записать число по факту мы просим в регистре активировать определенные
биты которые физически представляют собой какито транзисторы с какимто физ характеристиками
которые мы там хотим выставить. но вот если мы представим что внутри цпу есть биты
и если мы соотнесем биты в цпу с битами на бумаге у чисел в двоичной системе то тогда
мы как бы можем сказать что внутрь цпу было записано число. 
теперь надо понять а что за числа мы можем записать в регистр. 
мы видим в команде число 0xA1. это шестнадцатеричное число. но еще раз хочу подчеркнуть
что мы нечисло пихаем в регистр. просто hex число это удобная форма для записи на бумаге
для програмирования того факта что мы просим в регистре активировать биты. тоесть
 в под капотом наша команда 
mov ax, 0xA1
она просит выставить биты
mov ax, 1010 0001

просто в битовой форме было бы неудобно писать команды.
так вот возникает вопрос можно ли как то наладить соотвесвтие между битами 
и числами. если мы будем использовать двоичную систему счисления чисел то она 
волшебным образом совпадает с битовой картинкой.

поговорим про двоичную систему счисления.
система счисления это система обозначения числа.
десятичная система выглядит так

12356 = (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0

таким образом привычная нам форма записи числа это на самом деле коэффициенты
многочлена.прикол.

так вот в двоичной системе число обозначаетс вот так и вот его какой смысл
этого обозначения:

01010 = (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0

отрицательное число в одной и другой системе счисления(дурацкое слово лучше бы слово 
обозначение использовали)

-12356 = - { (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0 }
-01010 = -  { (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0 }

как мы видим в двоичной системе счисления в математике также спокойно есть знак минус.

теперь обозначение чисел с плавающей точкой

12356.23 = [ (1)*10^4+ (2)*10^3 + (3)*10^2 + (5)*10^1 + (6)*10^0 ] +[ (2)*10^-1 + (3)*10^-2 ]
 + 
и точно тоже самое для двоичной системы счисления!

01010.01 = [ (0)*2^4+ (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0 ] + [ (0)*2^-1 + (1)*2^-2 ]

как видим в математике в двоичной системе счисления нет проблем ни с минусом ни с 
дробными числами!

возвращаемся к цпу. создатели цпу что касается регистров общего назначения они ( я утверждаю )
запрограммировали так обработку битов внутри цпу что они представляют собой ровно теже биты теже коэффициенты в многочлене что и биты в двочиной системе обозначения числа за исключением
того что никакой внутри цпу хрени которая бы отвечала за знак минус нет и никакой хрени 
которая бы отвечала за дробную часть числа в двоичном представлении тоже внутри цпу 
нет при условии что мы говорим про регистры общего назначения.
таким образом биты в регистрах общего назначения можно соотнести с числами обозначаемыми 
через двоичную систему счисления\обозначения при условии что у нас нет знака минус и что нет дробной части. тоесть мы получается говорим только про целые положительные числа.
вот это вот и есть физический смысл битов внутри регистров общего назначения!
таким образом регистр общего назначения по своему физ смыслу это всегда целое положительное
число записанное в двоичной форме! и создатели цпу настроили схемы обработки битов внутри 
этих регистров как обработку чисел. поскольку битвая форма регистра нам позволяет 
обозначить только число положительное ибо минуса в цпу нет носителя и также в регистре 
нет носителя дробной части (регистры общего назначения) то поэтому математические\арифеметичекие операции могут иметь место только по своему физическому смыслу
только с целыми положительными числами. тоесть регистр по своей природе через себя может 
показать только целое положительное число в двоичной форме. никакого другого числа регистр общего назначения показать неможет у него нет для этого носителей минуса и дробной части.
теперь мы поняли\доказали что физ смысл битов в регистре это биты числа в двоичной системе обозначения\счисления причем это число получается является только положительным 
и только целым. 
в самом деле вот берем число -01010101.0101010
оно и отрицательное и дробное мы его никак в регистр всунуть неможем ибо у регистра
нет ни носителя "-" ни носителя дробной части. я говорю о регистре общего назначения.
так создатели цпу и сделали! ну а раз нет внутри регистра ни носителя минуса ни носителя
дробной части то внутренние схемы цпу они рассматривают биты регистра как целое положительное
число и никак иначе.
в самом деле как может быть результатом арифмт операций над двумя положительными целыми
числами отрицательное дробное число если этот резулльтат надо записать запихать в этот же регистр а у него нет таких хреней носителей чтобы отобразить минус или дробную часть.
поэтому как работает операция вычитания на общих регистрах. если одно число больше другого
то все биты обнуляются а потом они в обратном порядке отматываются то есть в точности как работает одометр в намашине если его крутить в обратном направлении.тоже самое касется сложения двух чисел кога результта превышает битность регистра. регистр доходит до макс значения потом обнуляется и начинает заново набирать. точно как одометр.
таким образом между цпу и регистром и математичкой двоичных чисел есть соотвествие но неполное. в математике если из меньшего вычесть большее то появляется минус. в цпу
происходит нечто другое. тоже самое касается деления или случая когда результат превышает
битность исходных чисел. во всех этих случаях между математичкой и цпу нет соотвествия.
цпу ведет себя тут кастомно.  в случае сложения и вычитания он ведет себя как одометр.

- более детально прояснить еще раз физ смысл результата сложения 
реультат прервышает битность регистра

что касаетя операции сложения то тут точно схемы цпу настроены так что 
биты регистра обрабатываются ALU цпу в точном соотвесвтии с логикой сложения целых положительных числе в двочином обозначении. только еще есть вот такой момент - 
вот мы складыаем 200 и 255. 200 уже лежит в регистре а 255 мы к нему прибавляем.
регистр максимум может нести на себе число 255. так вот
цпу он докручивает регистр с 200 до 255. потом он его обнуляет и потом еще его докручивает
прибавляет  к нему такое число чтобы суммарная докрутка от 200 до 255 и потом от 0 до числа X 
составила бы число 255 которое мы прибавляем. вот каков физ смысла того числа в регистре которое мы получаем при операции суммирования когда ответ превысил бы битность регистра.
для операции вычитания тоже самое только одометр откручивается в обратную сторону.

итак в случае арифм операций над регистром его биты обраюатываются цпу в точности такойже
как обрабатывались бы биты двоичного положительного целого числа!
тоесть в случае арифм операций биты в регистре это непросто биты а символы в двоичной записи для целого положительного числа. так их обрабатывает ALU цпу и результат арифмт операции 
записыватся в биты регистра в точности как выглядела бы двоичная запись результата (если результата невызывает ситуация переполнения). если переполнение то я описал выше.


теперь оставим случай арифм операций и рассмотрим просто операцию записи в регистр
	mov ax, 0xA1
можно ли в этом случае сказать что биты  в регистре соответвуют символам в двоичном
числе. 0xA1 это целое положтельное число записанное в шестнадцатеричной форме которое затем
комп преобразует в целое положитеьное число завписанрое в двоичной форме и согласно этой форме
цпу выставляет биты. поэтому из этого  я считаю что нетолько в случае арифм операций но и в случае записи числа в регистр обшего назначения его биты можно трактовать как символы двоичной записи числа получается что и в этом случае это положительное целое число записанное в двоичной форме в регистр в форме битов.

таким образом на мой взгляд биты внутри регистра общего назначения это непросто лампочки
это реально всегда целое положительное число. так их можно всегда трактовать. 

отсюда следует вывод что для работы с отрицательными числами или дробными числами регистры обшего назначения непригодны. и чтобы нам както работать например с целыми отрицатеьльными
числами на  базе регистра нам нужно както дополнительно изголяться.  это похоже на то что у нас есть экран телевизора но входной сигнал это азбука морзе поэтому нам нужно както получая азбуку морзе самим руками ее преобразоывать в картрнку на экране и наоборот. имея картинку на экране нам нужно ее както самим трансфорировать в азбуку морзе и уже именно ее пихать в радиоэфир. также и программа если она хочет работать с отрицательными числами то ей както надо
изголиться чтобы это делать на базе исключительно только положительных чисел с которыми работает цпу на базе регистра. его ALU микросхемы.

нутоесть для примера опишу работы с дробными числами. вот наша програма хочет сложить
1.23 и 2.45. как ей это сделать на базе регистров общего назначения и блока ALU цпу который умеет только складывать целые числа. программа должны вначале сунуть в регистр дробную часть
и потом прибавить к ней другую дробную часть

mov ax,23
add ax,45

далее прогармма должна считать эту цифру. далее также сложить целые части

mov ax,1
add ax,2

считать это число. и отобразить на экране 3.78
таким образом на базе целых положительных чисел мы провернули операцию сложения дробных чисел.

похожую мудоту программа должна суметь сделать для отрицательных чисел.


итак еще раз важный вывод микросхемы цпу настроены так что они обарабывают биты регистров
общего назначения (особенно во время арифм операций. кстати говоря арифм операция уже по крайней мере подразумевает что мы работаем с числами а не лампочками) как обрабатываются биты
у целых положительных числе в двоичном исчислении. каждый бит регистра соотстветует биту
в двоичном числе. это очень важный вывод. ( а то я тут встречаю выскзывания что цпу понятия не имеет ни о числах ни очем . мол у него просто идет обработка битов. обработка битов да но логика обработки этих битов вточности следует обработке битов у аналогичного двоичного числа!
поэтому биты внвутри регистра общего назначения это непросто биты это целое положительное 
число в двоичном виде!
)

а как же нам тогда на практие складывать числа результат сложения которых будет больше
чем размер регистра например

100+200.

первый вариант так как мы будем иметь высталвенный на цпу флаг переполнения то мы можем
просто слать нахер тогда в порграмме. мол слишклом большие числа.
точно незнаю но можно вот как. мы словим флаг переполнения и получим число в регистре 44
( потмоу что регистр со 100 докрутит до 255 потом обнулит и еще докрутит до 44).
и тогда можно на экране в простейше случае вывести мол ответ это 255+44+1.
плюс один это потому что был переход с 255 на ноль. он сьел одну единицу.
где 255 это макс число для регистра 8бит мы его знаем заранее из размера регистра
и 44 мы получили лажещим в регистре.да конечно это неконечный красивый ответ но почти ответ
лучше чем ничего.

переходим к отрицательным числам.
10-200

mov al,10d
sub al,200d

 в результате в al будет лежать 66d (вначале окрутится 10 до нуля. потом ноль до 255 и потом еще до 66. всего будет прокручено на -200)

как нам из полученного результата +66 понять что ответ -100 пока непонятно.

пока оставим и передвигаемся  к теме как мы сами для себя ( не цпу а именно мы) могли бы
обозначать отрицательные числа используя для этого положительные числа цпу. тоесть энкодинг 
отрицательных чисел сугубо для нашей пользовательсктй программы используя положительные
числа цпу. 


один вариант это взять старший бит и кодировать  отрицательное число через  выставление старшего бита  в 1. а оставшиеся биты использовать для абсолютного значения.

тогда можно иметь такую кодировку

1001 = -1
1010 = -2

такой тип кодирования назыается "Sign-Magnitude representation".
переводится примерно как "кодирование по схеме знак-величина"

получается что мы при таком кодировании
цпу видит биты 1001 как число 9 наша же программа для себя понимает это как число -1
цпу видит биты 1010 как число 10 наша же программа для себя понимает это как число -2

сразу про минус такого кодирования. 
мы неможем выполнять арифметические операции на цпу для наших чисел потому что с точки 
зрения программы мы складываем -1 + -2  а точки зрения цпу мы будем складывать 9 + 10
ну и вот посмотрим что мы будем получать. 

1001
1010
-----
0011 с флагом переполнения
 
с точки зрения цпу мы получили число +3. с точки зрения нашей программы мы тоже получили 
число +3 потому что старший бит неравен единице. по модулю правильно по знаку неправильно.
но по идее наша программа может учитывать
то что сработал флаг переполнения и это может быть нашей программе сигналом что число получено
отрицательное а не положительное.

а вот еще пример тогда рассмотрим.

1001 = -1
0010 =  2

сложим
1001
0010
----
1011

получили с точки зрения цпу 11 с точки зрения программы получили -3 а должны же были 
получить +1

так ну походу приходим к выводу что получать верные ответы при арифм операциях 
при схеме кодирования "sign-magnitude" неполучается при использовании ALU на цпу который
работает с класическими положительными числами. так что от такой схемы надо отказаться 
либо делать на цпу отдельный ALU блок который бы распознавал и работал бы именно с этой кодировкой.тоесть игнорировал бы старший бит при арифм операциях. по факту такую кодировку
неиспользуют в жизни в итоге. 

ну так уже для добавки скажу что 
есьт еще один минус у этой кодировки
у нас появляется два нуля.

0000 = 0
1000 = -0

что как бы неклево.


еще скажу что описанная выше схема кодирования отрицательных чисел характерна тем что 
старши бит отвечает только за кодирования(наличие или отсуствиие) знака минус. больше этот бит
никакого значения на себе ненесет. фишка в том что предтавленная (ниже) другая система кодирования отрицательных чисел  тоже имеет старший бит выставленный в 1 если число отрицательное но этот старший бит нетолько в себе несет признак о том есть ли минус
у числа или нет но и также участввует в кодировании величины числа. это важно. потому что
у представленной выше схемы если заменить старший бит с 1 на ноль то мы автоматом легко получаем из -5 сразу 5. та схема что ниже у нее если заменить старщий бит с 1 на ноль то 
это повлияет нетолько назнак но  и на величину числа такчто вот так вот просто прервратить -5 в 5 уже неработает.

Далее. рассматриваем следущйю схему кодирования отрциалеььельных чисел через положительные.
она назыавется "первая обратная форма" - "1's Complement Representation".
перевод литературный а недословынй. дословный по мне какойто хреновый.
суть схемы:
		старший бит если он 1 обозначает что число отрицательное (для нашей программы а не для цпу
для цпу по прежнему число положительное).
		если старший бит 0 то оставшиеся биты обозначают величину.
пример
0100 = старщий бит 0 значит число положительное. оставшиеся биты 100 обозначают величину 4
значит для нашей проги это число +4. для цпу это тоже +4
		если старший бит 1 то число для программы считается отрицательным (для цпу оно по
прежнему положительное) а оставшиеся биты показывают величину но их нужно инвертировать и 
только после этого смотреть виличину.
пример
1010 = старщий бит 1 значит это число с минусом для нашей проги. оставшиеся биты 010 мы 
их инвертируем получаем 101 и вот теперь уже смотрим что это за число . это 5 значит 
для нашей проги это число -5. для компа же по прежнему это число 9.
	как на практике программа могла бы работать  с такой кодировкой. вот она из памяти в регистр
считала байт. пусть у нас 4битная память и 4битный регистр. получила 1010. далее программа
видит что цпу выставил sign флаг который сигнализирует что старший бит равен 1. окей.
программа поняла что это отрицательное число. далее программа вычленяет все младшие биты
и делает их инвертирование для этого тоже есть на цпу команда. и далее уже мы получаем наше искомое отрицательное число ибо минус мы вычислили и модуль числа мы получили. 
получается с точки зрения записать в память и прочитать из памяти и распознать какое 
отрицательное число туда записали ранее эта схема работает пригодна.


		нарисуем табличку чисел в такой кодировке

биты |для      | для 
     |программы| цпу
0000 	0 				0
0001 	1 				1
0010 	2 				2
0011 	3 				3
0100  4 				4
0101  5 				5
0110  6 				6
0111  7 				7
1000  -7 				8
1001 	-6 				9
1010 	-5 				10
1011 	-4 				11
1100 	-3 				12
1101 	-2 				13
1110 	-1 				14
1111 	-0 				15


еще раз подчеркну что для цпу по прежнему все биты это сгубо положиельные числа.
это для нашей программы числа стали иметь другое значение. тоесть если программа 
считала их регистра число 14 то она для себя понимает что это для нее число -1
и наоборот если программа хочет записать в регистр число -1 то она его согласно таблице
перекодирует и сует в регистр число 14 . поому что это только для нашей программы -1 это -1
а в цпу нет нкиаких -1. там есть только 14 который имеет вид 1110.
тоесть программа тарктует битовую запись одним образом а цпу другим. 

виден минус такого кодирования в том что у нас два нуля.
биты |для      | для 
     |программы| цпу
0000 	 0 				0
1111 	-0 				15

еще минус в том что (согласно инфо от книжек) что неполучается извратится и 
получать верные ответы при арифм операциях используя ALU цпу для положительных чисел.
поэтому от такой кодировки тоже отказались в программах. потому что наша задача нетолько 
записыать в память регистры наши "отрицательные"  числа но и выполнять над ними арифм 
операции исползуя ALU cpu. а если мы будем получать неверные ответы то смысла нет.

рассмотрим следущую схему кодирования отрицательных чисел через положитеьльные.
схема называется "вторая обратна схема" "2s complement representation"
схема такая же самая как предыдущая но чуть чуть другая.
	старший бит если 0 то число считается положительное если 1 то отрицательное
	если старший бит 0 то оставиишиеся биты кодируют величину
	если старший бит 1 то оставшиеся биты кодируеют величину но чтобы ее узнать надо 
инвертировать биты и прибавить единицу.
пример для отрицательного числа
1010 = старший бит 1 значит знак минус. оставшиеся биты 010 мы их инвертирует полчаем 101
и прибавляем единицу тоесть
101
001
---
110

это число 5. значит итоговое число это -5

распишем таблицу в этой кодировке

биты |для      | для 
     |программы| цпу
0000 	0 				0
0001 	1 				1
0010 	2 				2
0011 	3 				3
0100  4 				4
0101  5 				5
0110  6 				6
0111  7 				7
1000  -8 				8
1001 	-7 				9
1010 	-6 				10
1011 	-5 				11
1100 	-4 				12
1101 	-3 				13
1110 	-2 				14
1111 	-1 				15


сразу здесь замечаем что положительные для нашей программы числа они и для цпу ровно 
такие же самые. то есть 0-7 для нашей проги это 0-7 для цпу. тут все просто.

сразу видна фишка что теперь у нас один ноль в этой кодировке а не два. это хорошо.
втора фишка наконец то мы ее получили мы можем складывать и вычитать числа пользуясь ALU цпу
и получать верные ответы с точки зрения нашей программы. еще раз фишка в том что с точки зрения цпу и его АЛУ мы имеем только положртельные целые числа и выолняем с ними арифм операции. а так счастливо совпадает что полученный результат верно кодирует число уже  с точки
зрения нашей программы. 
пример.
хотим в нашей проги посчитать 4+(-5).
согласно табллице
4(для нашей программы)=0100=(для цпу это тоже 4)
-5(для нашей проги)=1011(для цпу это 11)

суем в один регистр 0100
во второй регистр суем 1011
далее просим цпу сложить эти числа.
еще раз подчеркну что цпу складывает не 4 и -5 а 4 и 11

0100
1011
----
1111

получили 1111
для цпу это 15
но наша программа считывает это число заглядыает в таблицу понимает что получили -1
 а это то что нам надо потому что в математике 4-5=-1

еще пример
хотим в программе почитать -2-6= -2 + (-6)
-2 согласно таблице = 1110 суем его  в первый регистр (для цпу это число 14)
-6 согласно таблице = 1010 суем его во второй регистр ( для цпу это число 10)

скадываем эти числа пользуясь АЛУ цпу. цпу считает по факту что склдаыает 14 и 10
1110
1010
-----
1000 с флагом переполнения

флаг переполнения игнорируем.
получили 1000 . согласно таблице для цпу это число 8 а для программы это -8
и по математика -2-6=-8

получили поразительную вещь. хитро кодирую  отрицательные числа с точки зрения нашей программы
в положительные числа для цпу и используя АЛУ цпу для обработки положительных чисел 
мы получаем верные ответы с точки зрения арифметики над отрицательными числами! круто!
это значит что нам ненужно внутри цпу заводить доп микросхемы для распознавания класса отрицательных чисел  и ненужен блок арифм операций над отрицаттеьными числами.
это очень хорошо. единственное что на данном этапе это верно для целых чисел и для операций
сложения вычитания. как там обстоят дела с дробными числами и с операциями умножения деления
я пока незнаю.  но четко видно что складывать и выичтать целые отрицательные числа мы уже можем на цпу пользуясь его аппаратом обработки положительных чисел. цпу понятия неимеет обрабатывая положительные числа что по факту для нашей прогармы он получает отрицательные числа.

мы можем вычислаять такие примеры как
2-6= 2+ (-6)
6-2= 6+ (-2)
2+6
2-(-6)=2+6
-2-6=(-2) + (-6) 

также совершенно понятно важное дополение что для каждого размера регистра (сколлько в нем бит) у нас есть некоторый диапазон чисел с которым мы можем работать и получаеть коректные ответы. если мы выходим за этот диапазон то мы будем получать некоректные ответы и тогда 
надо сигнализировать что мы этот случай посчитать неможем.
для n=4 бит наш диапазон это [-8;7] это значит что аргументом в примерер могут быть 
только числа из этого диапазона
например
-8+7 = коретный вариант
4-6 = коректный вариант
-9+1 = некоректный вариант потому что через 4 бита мынеможем запрограмировать число -9

ну это понятно. но есть еще условие что резулттат примера неможет тоже выходит за рамки [-8;7]
потому что результатто у нас тоже записывается  в регистр из тех же 4 бит. а если результат превыешает 4 бита то как мы можем его отобразить? никак. пример

-8-4= -8 + (-4)= -12 результат (число) превышает диапазон. значит тут надо писать что ошибка.
посмотрим как это на практике.
-8 = 1000
-4 = 1100


1000
1100
----
0100 и флаг переполнения а флаг sign сброшен
получили сточки зрения цпу 4 и сточки зрения программы тоже 4. а нам надо было -12.
поскольку мы складывали два отрицательных числа то мы точно знаем что должно получиться 
отрицательное число. а поскольку флаг sign сброшен ( так как старший бит 0) то мы в программе
понимаем что мы превысили лимит снизу. значит выдаем ошибку в программе.

еще пример 
7+2=9. 9 число оно тоже выходит за диапазон [-8;7]
смотрим

0111
0010
-----
1001 

флаг переполнения неустановлен
флаг sign установлен

получили 1001 для цпу это 9 для программы это -7. причем флага переполнения нет.
но флаг sign устанолвен. так как мы знаем что сумма положительных чисел должны быть 
положительна то мы в программе понимаем что мы превысили лимит сверху. выдаем ошибку.

итак получается правило флаг переполнения мы игнорируем.
если складываем два положительных числа и получаем устанолвенный sign флаг 
значит мы превысили лимит сверху. выдаем ошибку.
если мы складыаем два отрицательных числа и получили сброшенный флаг sign то мы 
превысили лимит снизу и выдамем ошибку.

круто!
тогда действиельно если наша программа использует "вторую обратная схема" (мне кажется по русски эта схема называетс схема дополнения до двух но это неточно) то мы можем успешно
складыать и вычитать положтельные и отрицательные целые числа. диапазон чисел определяется
размером в битах регистра.
при n=4 это [-8;7]
при n=8 это [-128;127]

при n=k это [-0.5(2^k);{0.5(2^k)}-1]
заметим что 0.5(2^k)=(2^k)/(2^1) = 2^(k-1) значит преобразуем формулу
при n=k это [-2^(k-1);2^(k-1) - 1 ]

визуально удобная формула выглядит так
при n=k , [-z,z-1], где z=2^(k-1)


получается при n=16, z=2^15=32768 ,значит [-32768;32767]

при n=64, z=2^63, значит это [-2^63; 2^63-1] 
или 
[9 223 372 036 854 775 808; 9 223 372 036 854 775 807]



теперь надо понять почему "вторая обратная схема" дает верный результат 
при арифметических операциях.

для этого рассмотрим на первом шаге вспоминаем о чем я говорил гораздо выше - что происходит с регистром когда мы в него слкадываем число которое превышает его размер. регистр 
работает как одометр на машине. тоесть

1111
0001 +
-------
0000

когда на одометре максмимаьная цифра и мы добавляем еще один то одометр откручивается
до начала до нуля а потом идет все сначала.


0000
0001 -
-------
1111

когда на одометер ноль и мы если его скручиваем на 1 назад то на нем вылезаем 
максимальное число.

так работат арифметика на регистре при проходжении за максимум и минимум.


на втором шаге(чтобы понять почему работает арифметика "второй обратной схемы") рассмотрим еще одну кодировку:
называется она "одометрная кодировка" предложена в книге по асемблеру BOB NEVELN.
пусть у нас есть одометр. из пяти цифр и сейчас он показыавает 99 999км и мы проезжаем 2 километра.
одометр прокрутится в 00 000 и далее прокрутится и покажет  00 001 км. а теперь рассмотрим 
уровеннеие из математики (забудем про одометр на время)

x + 2 = 1
в математике x= -1

значит в математике у нас было -1 мы к нему добавляем 2 и получаем 1.

возвращаемся к одометру у нас было 99 999. мы проехали 2 километра и он показал нам 1.

возникает идея о том что если мы будем  считать показание 99 999 на одометре
как -1 для нашей программы то добавояя километры на одометре мы получим на одометре 
ровно тоже число которое мы получим считая уравнение в математике тоесть.

в математике

-1 + 10 = 9

на одометре

99 999 + 10 = 9

таким образом 99 999 на одометре сооответвует -1 для нашей программы в математике.

возьмем на одометре показание 99 998 . добавим на одометре 3 киломтра получим на одометре показание 1 . тоесть

99 998 + 3 = 1


рассмотрим математику уравнение

x + 3 = 1 
получаем x=-2

теперь рассмотрим пример когда к -2 мы прибавляем 10

-2 + 10 = 8

рассмотрим когда мы к одометре 99 998 добавляем 10 километров

99 998 + 10 = 8

таким образом мы видим что добавление к 99 998 любого числа дает тот же ответ как добавление 
в математике к -2 того же числа. 

это нам дает что что вот мы хотим узнаь сколько будет

-2 +100.
мы выставляем на одометре 99 998 и проезжаем на машине 100 километров и сколько он покажет
такой ответ и есть. одометр покажет 98км

значит -2 + 100 = 98

таким образом мы можем составить таблицу соотвесвтия между отрицателным числом из математики
и показанием на одемтре

-1 				99 999
-2 				99 998
-3 				99 997
-99 999 	1
-100 000 	0


таким образом мы получаем через одометр примитивный калькулятор. если нам надо решить пример
-3 + 15. мы лезем в таблицу смотрим какое число соответвует -3

-3 соотвствует 99 997
мы выставляем на одометре 99 997. далее мы проезжаем 10 километров (ну или условно говоря делаем 10 щелчков на одометре) и та цифра что он высветит это ответ.
одометр покажет 12
значит -3 + 15 = 12

таким образом мы имеем некиий суммирующий калькулятор в форме одометра. он по своей природе
умеет суммировать только положительные числа. но мы исхитрились его приспособить для суммирования отрицательных чисел с положительными.

далее мы замечаем что одометр это 5 битное устройство , 5 битное число с десятичной системой счисления.
а в цпу у нас есть такой же одометр это регистр. у него скажем 4 бита и двоичная система счисления. и главное что АЛУ цпу он работат с регистром при операции сложения ровно также
как одометр на машине очем мы выше говорили.

рассмотрим регистр показывает 

1111 = 15
мы добавляем +2 это 0010

1111
0010 +
------
0001

получаем 1 
таким образом если верхний одометр имел диапазон от 0 до 99 999 
то наш регисррвый одометр имеет диапазон от 0 до 15.
при прохождении 15 он обнуляется ровно также как одометр машины при прохождении 99 999 он обнулялся.


так вот из вернего примера мы видим что 
на регистре было 15 потом прибавили 2 и получили 1. 
в математике x+2=1 имеет место когда x=-1

значит по аналогии -1 из математики соотсвтетует 15 на регистре. прибавляя на цпу к 15 число
Y мы будем получать ответ аналогичный как тому как в математике -1 + Y

-1 +y ( в математике)
15 +Y ( на цпу в регистре)

ссотавляем таблицу

-1		15  1111
-2		14  1110
-3		13 	1101
-4		12 	1100
-5		11 	1011
-6		10 	1010
-7		09  1001
-8		08 	1000
-9		07 	0111
-10		06 	0110
-11		05 	0101
-12		04 	0100
-13		03 	0011
-14		02  0010
-15		01 	0001
-16		00 	0000

в левой колонке наше число из математики которое интересует нашу программу
вторая колонка это число в регистре внутри цпу которое соответвует первой колонке
третья колонка это битовая картинка внутри регистра

хотим узнать сколько будет -14 + 10
согласно таблице для числа -14 надо на регистре положить число 02 или в битовом виде 0010

а далее надо прибавить к тому что лежит в регистре то что мы хотим прибавиить в нашем случае
это 10 . 10 = 1010

получается с точки зрения цпу мы прибавляем 14 и 10

0010
1010
-----
1100 нет флага переполнения

1100 это 12 а согласно таблице это также может быть -4

получается в целом хорошая схема и она как работает но возникает непонятка с результатом
как его трактовать. толимы получили 12 то ли -4. 

рассмтоим еще пример когда модуль отрциательного числа меньше положительного

-4 + 10

согласно таблице для -4 в регистр надо засунуть  12 =	1100
10 = 1010

значит надо приавляем на цпу к 12 число 10

1100
1010  +
------
0110  есть флаг переполнения

получили число либо -10 либо 6

тогда из этих двух примеров можно такое правило создать для программы.
если флаг переполенния сраотал то трактуем полученное число как отрицательное
а если флаг переполенния невыставлен то трактует резултат как положительное число.

получается при такой кодировке "кодировка одометра" можно успешно получать ответы
для арифметичских задач складываний отрицательного числа с положительным.

но есть проблема в том что если мы читаем из памяти в регистр байт то нашей программе
непонятно тли это положителное число толи отрицательное.
тоесть когда мы знаем число отрцаительное потом ишем по таблице ему соотсвтеие 
и потмо склдываем и проверяем флаг перпполения то мы точно знаем как трактовать результат. 
а вот если мы из памяти считали байт то тут нет никаких зацепок как его тарктовать то ли как
политеьное число толи как отрциательное. 

поэтому кодировку одометра надо модифицировать. 

еще раз скажу зачем нам этот огород с кодировкой отрцаттельного числа  в положительное. 
огород нужен затем чтобы внутри цпу ненужно было создавать транзисторные схемы специально 
под отрицатлеьные числа. мы хотим обойтись схемой в цпу которая умеет работать только с положительными числами. это упростит нам усттойство цпу.


итак надо модифицировать "кодировку одометра"

тогда идут на следуший шаг. до сих пор мы использовали четыре бита для кодирования числа.
теперь из всего множества чисел которые мы использовали на преддыдущем шаге мы будем
для кодирования отрицательных чисел использовать невсе а только те у которых так вышло
что старший бит равен 1. тогда половина все чисел будет кодироовать отрицаттельные числа
для нас ( для цпу по прежнему все числа положртельные) а половина для нашей программы
будет кодировать положительные числа. да мы лиштимся половины диапазона но исчезнет
неоднозначность мол это положительное число или отрицательное и при этом сохранится
также механизм о том что если мы будем складывать положительные (для цпу) числа которые ( для нас) выглядят как отрицательные с другими числами то результат будет верный.( при этом мы будем исползовать встроенный в цпу механизм сложения положитльных чисел несоздава в цпу отдельный блок по обработке отрицательных чисел).

итак берем нашу прежнюю таблица

1111 = ( для цпу это прежнему 15)
1110 = ( для цпу это прежнему 14)
1101 = ( для цпу это прежнему 13)
1100 = ( для цпу это прежнему 12)
1011 = ( для цпу это прежнему 11)
1010 = ( для цпу это прежнему 10)
1001 = ( для цпу это прежнему 09)
1000 = ( для цпу это прежнему 08)

0111 = ( для цпу это прежнему 07)
0110 = ( для цпу это прежнему 06)
0101 = ( для цпу это прежнему 05)
0100 = ( для цпу это прежнему 04)
0011 = ( для цпу это прежнему 03)
0010 = ( для цпу это прежнему 02)
0001 = ( для цпу это прежнему 01)
0000 = ( для цпу это прежнему 00)

и для каждого числа мы находим его отрицательный эквивалент но не для каждого 
а только для тех числе у которых старший бит 1.
получаем


1111 = ( для цпу это прежнему 15) | для программы это -1
1110 = ( для цпу это прежнему 14) | для программы это -2
1101 = ( для цпу это прежнему 13) | для программы это -3
1100 = ( для цпу это прежнему 12) | для программы это -4
1011 = ( для цпу это прежнему 11) | для программы это -5
1010 = ( для цпу это прежнему 10) | для программы это -6
1001 = ( для цпу это прежнему 09) | для программы это -7
1000 = ( для цпу это прежнему 08) | для программы это -8

0111 = ( для цпу это прежнему 07) | для программы это 7
0110 = ( для цпу это прежнему 06) | для программы это 6
0101 = ( для цпу это прежнему 05) | для программы это 5
0100 = ( для цпу это прежнему 04) | для программы это 4
0011 = ( для цпу это прежнему 03) | для программы это 3
0010 = ( для цпу это прежнему 02) | для программы это 2
0001 = ( для цпу это прежнему 01) | для программы это 1
0000 = ( для цпу это прежнему 00) | для программы это 0

теперь если мы из памяти скачаем байт то мы однозначно можем сказать что это за число
для нашей программы. только появилась небольшая  проблемка что 
если раньше мы могли отрицательное число брать от -1 до -15 то теперь только от -1
до -8 для наших примеров вида -8 + Y


для цпу по прежнему все эти биты это сугубо положительные числа
от 0 до 15. 
мы же в своей программе можем использовать числа от 0 по 07 как положительные трактуя их как 
числа от 0 по 07

а числа от 08 по 15 мы можем в нашей программе трактовать как числа от -8 до -1

при этом мы теперь имеем однозначность теперь понятно какое положительное (для цпу)
число кодирует положительное число для нашей программы а какое положительное (для цпу)
число кодирует отрицательное для нашей программы число.

теперь наша программа может выполнять арифметические действия с отрицательными числами
используя блок сложения на цпу для положительных чисел и полученный результат наша программа
теперь может одноазначно трактовать что это точно либо положительное либо отрицательное число.
пример

мы хотим через нашу программу сложить -7+4.
наша программа смотрит в таблицу и видит что -7 соответствует число 09 (1001)
тогда наша программа кладет в первый регистр цпу число 09 а во второй регистр число 4(0100)
и дальше просит цпу их сложить.

1001
0100 +
------
1101 флаг переполнения невыставлен. флаг sign выставлен

далее наша программа смотрим  в таблицу и видит что
1101 = для нашей программы это -3. 

данное число наша программа должна для себя трактовать как -3.
и она на экран выводить -3. получено отрицательное число потому что его старший бит 1.

и согласно математике -7+4=-3

тоесть все верно.
ну а с точки зрения цпу он сложит 9 и 4 и получил 13. но это 13 для цпу а наша программа
имеет волность трактовать полученное число как мы хотим. 

обозначим диапазон числе который можно получить для регистра размером n бит.
в рамках этих бит мы можем закодировать положительные числа [-(2^(n-1); (2^(n-1))-1] 
об этом и выше говорил.
пример n=4.  [-8; 7]

далее. вот мы научились прибавлять к отрицательному числу положительное.
как мы это делаем. мы берем отрицательное число. находим по таблице соотвутетвюущий
ему положительное число в байтовом виде и суем в регистр. и далее с даем команду
цпу добавиьт к тому что в регистре еще другое положительеное число

mov al, 0x7
add al, 0x5

проблема в том что мы ищем первое число которое нужно положить в регистр по таблице.
нужна какая то аналиическая формула как это сделать.
если это число положительное то число P которо в регистр класть найти очень просто 
это просто наше исходное число в бинарном виде. 

а вот если исходное число отрицательное то на бумаге эта формула выглдит так

P=2^n-N

P = число которое мы ищем которое хоти поолжить  в регистр.
N = положительное число обратно к нашему отрицательному
n = битность регистра. 

Также хочу подчеркнуть что первый бит у P всегда будет 1.(ествесвтенно если исходное число
отрицательное. если положительное то ноль)


для n=4 
P=16-N

окей. для числа -7 обратное ему число N=7
P=16-7=9 = 1001
mov al, 11d

значит на бумаге мы имеем формулу а как нам заставить сам комп высчитывать это P 
вместо нас. модифицируем формулу

P=16-N=(15-N)+1

рассамотрим 15-N
возьмем N=1, N=5, N=7.
обращаю внимание что N у нас положительное потому что оно обратное число к нашему 
отрцаительному.

поскольку N  у нас положительное то мы можем его представить в виде битов в регистре
и выполнить операцию вычитания в двоичном виде на бумаге ( на цпу неможем потому что наш цпу на данный момент неимеет блока вычитания положительных чисел поэтому пока только на бумаге).

Еще раз почему  я невыбрал чтобы N был отрицательный. почему  я выбрал чтобы N был обратный к нашему числу. потому что я хотел чтобы N был положительный. почему. потому что если N отрицательный то в двоичной системе настоящей число отрицательное к положительному найти 
очень легко. тоесть если у нас 0001 то ему отрицательное это -0001 а вот когда мы 
говорим про бинарный вид числа в регистре у нас там нет никаки минусов. там мы работает
только с положртельными числами поэтому я выбрал чтобы N 	был положитеьный.
схема такова. 

у нас ест число -7 в десятичной записи. ему обратное в десятичной это 7. и мы мгновенно также
можем записать как будет выгляеть 7 уже внутри регистра это 0111. тоест положителность
числа N дает возомность его засунунть в регистр. 


итак имеем числа -1 тогда N=1, тогда его вид в регистре 0001
число -5 тогда N=5 , тогда его вид в регисре 0101
число -7 тогда N=7, тогда его вид в регистре 0111

далее рассмтриваем формулу 15-N
в двоичной записи эта операция выглядит как

для N=1
1111
0001 -
-------
1110

для 
N=5
1111
0101 -
--------
1010

для 
N=7
1111
0111 -
--------
1000

на цпу мы ее выполнить неможем потому что по условиям у нас в цпу нет блока вычитания
одного положртельного числа из другого пэтому мы ее делаем пока только 
на бумаге.

но можно заметить одну интересуню вещь. что ответ в бинарном виде 
всегда является инвертасией битов из числа которое мы отнимали. тоесть

N=1 = 0001
ответ = 1110

N=5 = 0101
ответ = 0101

N=7 = 0111
ответ = 1000

так вот утверждается в кнжижке что так буде всгда для любого аргумента.
если мы отнимаем в 4 битном числе от 15 другое полржителное число то 
ответ можно найти мгновенно путем инверсии битов.

и тут чудо. значит мы можем добавить в цпу такой блок в ALU который умеет 
инвертировать биты в регистре. 

тоесть 15-N = NOT N 
где NOT N это bitwise not для N

тоесть если 
N = 0000 
то 
NOT N = 1111

тогда возврашаемся к формуле
если у нас есть отрицательное число(которое мы неможем засунуть в регистр) и мы хотим найти положительное число P (которое 
мы уже можем записать в регистр) то P можно найти по формуле

P=(15-N)+1

где N это положительное число обратное к нашему отрицательному.тоесть если наше число -7 то N=7.

поскольку мы уже выыснили что (15-N) = NOT N
то формула преобразуется в 

P= NOT N + 1

таким образом мы нашли формулу по которой мы не из таблицы руками а на цпу с помощью его ALU 
можем автоматм красиво получать число P для заданного отрицательного числа зная его обратное положительное число N.

пример.
отрицательное число =  -8
для него его обратное число N=8
значит мы берем и грузим в регистр число 8

mov al,8d

далее мы к нему применяем bitwise NOT

not al

далее мы к нему прибавляем 1

add al,1 

и таким макаром у нас щас в al число P которое согласно таблице соответсует числу -8.


рассмотрим на примере
число -7
N=7 = 0111
NOT 0111 = 1000
прибавим единицу 

1000
0001 +
-----
1001

полученное число 1001(9 dec) это искомое число P для -7.
проверяем по таблице
1001 = ( для цпу это прежнему 09) | для программы это -7
все верно.


расмормим обратную задачу. у нас есть число P в двоичном виде из регистра.
как нам понять какое число оно кодирует?

смотрим на формулу

P= NOT N + 1    # она про то чтобы зная N найти P

теперь выведу обратную формулу
N = NOT (P -1)  # она позволяет зная P найти N

проверим на практике.
P= 1001
N = NOT (1001-0001) = NOT 1000 = 0111  = 7
значит искомое число отрицательное равно -7



ВНИМАНИЕ! ВАЖНЫЙ КУСОК. 
примеры на bash
(собственно именно из за него и началось изучение кодирования отрцаеттельных чисел)

тут очень важно сразу сказать что  баш имеет размер переменной 64бита. а не 4бита как я все это время тут рассматриваю. 

далее важные примеры на эту же тему
на примере bash:

у bash есть bitwise NOT обозначается как ~
$ (( ~число  ))

у bash двочиное число вбивается как
$ (( 2#0001))

все вместе NOT 0001
$ echo  $(( ~ 2#0001 ))

наша задача угадать что будет на выхлопе.
прикол в чем баш берет число которое мы ему дали и применяет к нему инверсию битов. полученный байт баш невыводит в бинарном виде. нет. он воспринимает его как P. как 
число в регистре. поэтому для этого P баш находит N. и потом выводит его на экран в
виде -N

наша задача - мы задаем начальное число N1. и нужно предсказать какое число -N2 
баш распечатает на экране.

значит после выполнения команды в регистре будет лежать байт
P=NOT N1

и  у нас есть формула которая зная P позволяет расчитать его N
N2 = NOT (P -1)

подставляем P из первой формулы во вторую получаем
N2 = NOT (NOT N1  -1)

формулу получили. 
приступаем к конкретным случаям N1.

N1=00..0001

тут суперважно вспомнить и понять что баш выеляет по число 8 байтов. а не 4бита
как я это тут делаю в примерах. почему это важно .потому что 
 я вот ввел и получил
 $ (( ~ 2#0001))
-2

далее я подумал что результатом NOT 0001 является 1110 
и да это верно если размер регистра 4 бита (но это совершенно неверно если 
размер регистра 64 бита щас мы это увидим). ну я и подумал а дайка  я башу сразу подсуну
это число 2#1110 и посмотрю что он напечаатаем. должен же -2

я ввел и получил
~$ echo $(( 2#1110  ))
14

и такой типа непонял почему 14 вместо -2 . а все потому что для 64битого регистра операция

NOT 0001 = 1111111......1110 но никак не 1110

поэтому мне нужно было печатать число
$ echo $(( 2#1111111111111111111111111111111111111111111111111111111111111110 ))
-2

а  я задал печатать совем другое число
$ echo $(( 2#1110  ))
14
которое аналогично
$ echo $(( 2#0000000000000000000000000000000000000000000000000000000000001110  ))
14

поэтому и получил 14 вместо -2

почуствуй разницу между числами
1111111111111111111111111111111111111111111111111111111111111110
и
0000000000000000000000000000000000000000000000000000000000001110
 

после примеения к нему NOT в регистре окажется как уже сказал число 1111111111111111111111111111111111111111111111111111111111111110
по таблице можно найти что ему соотвевтвует -2

но расчитаем по формуле а не по таблице
N2=NOT (NOT 0001  -1) =  NOT (11..1110  -0001) = NOT (11..1101) = 0010 = 2
значит на экране баш должен напечатать -2

проверяем
$ echo $(( ~ 2#0001))
-2
все правильно.


следущий пример
N1=00..1010

после примеения к нему NOT в регистре окажется число 
1111111111111111111111111111111111111111111111111111111111110101
по таблице можно найти что ему соотвевтвует -11 

распечатаем напрямую это число. проверим как баш его интерпретирует
$ echo $(( 2#1111111111111111111111111111111111111111111111111111111111110101  ))
-11

все верно!

но теперь расчитаем -11 через формулу
N2=NOT (NOT 1010  -1) =  NOT (11..0101  - 0001) = NOT (11..0100) = 1011 = 11
значит на экране баш должен напечатать -11

проверяем
$ echo $(( ~ 2#1010))
-11
все правильно.

тут еще важно отметить что так как у нас регистр 64бита то конечно -11 входит в
в диапазон! это если бы регистр был 4 бита то -11 там бы и в помине небыло.


вопрос почему я указываю числа в баш в бинарном виде.
это чтобы точно гарантировать какое бинарное число баш кладет в регистр.
ведь если я укажу число в десятичном формате то баш его вначале преобразоывает в бинарный вид по непонятно какому правилу и только потом кладет в регистр. если же указваем число сразу вбинарном виде то баш ровно  в таком виде и кладет число в регистр. это очено важно.если я указал (( 2#0001 )) то баш засунет  в регистр именно этот набор бит.
а если я укажу (( 1 )) то еще нефакт что баш засунет в регистр 0001

щас  я покажу почему это важно. 
поставим число в десятичном виде.
возьмем предыдущий пример N1=1010. преобразуем в десятичны вид N1=10(dec)

$ echo $(( ~ 2#1010 ))
-11

$ echo $(( ~ 10 ))
-11

ну чтож хорошо получили одно и тоже.



рассмотрим следущий пример.
N1= -4

значит как будет дейтсовтаь баш. он небудет пихать в регистр -4 потому
что это невомозжно. он вначале по таблице 
заменит -4 на некоторое бинарное положительное число (вопрос какое).
и именно его засунет в регистр.
посмотрим что будет
$ echo $((  ~ -4 ))
3



расчитаем что тогда он должен показаьть
по моим понятияем баш -4 превршащат по таблице в 11..1100

N1=11..1100

у нас здесь P=NOT N1= 00..0011

далее по формуле мы уже неможем считать потмоу что формула расчитана
на нахождение N при условии что P имеет старший бит устанолвенный в 1
а наш P имеет старший бит сброшенный.

так что наша формула по нахождению N тут неприменима!

конец теме примеров на баш. далее опять возрвщаемся к искуственным регистрам на 4 бита.
ВНИМАНИ! КОНЕЦ ВАЖНОГО КУСКА.

насколько я понимаю расмотренная выше модифицрованная методика кодирования методом одометра
это и есть "вторая обратная схема кодирования"

?????????????????????????????/
закончил тут.
рассмотреть то что я непонял здесь 
https://www3.ntu.edu.sg/home/ehchua/programming/java/datarepresentation.html
у них какаято друная методика второй схемы кодировагия а именно:
for negative integers, the absolute value of the integer is equal to "the magnitude of the complement of the (n-1)-bit binary pattern plus one" (hence called 2's complement).

ихний пример
1000 0001 типа равен -127(Dec)

посчитаем по моей методике
P=1000 0001

N = NOT (P -1) = NOT (1000 0001 - 0000 0001) = NOT (1000 0000) = 0111 1111 = 127(dec)
значит исходное число по моей методике это -127
кхм.. ответ совпал с ихним. 

P=1 111 1111
N= NOT (1111 1111 - 0000 0001) = NOT (1111 1110) = 0000 0001 = 1
значит число равно -1

их ответ 
0000000+1=1 итого -1
кхм совпало.
почемуто формулы разные а ответс совпдаате! надо разобарсят !

????????????????????????????
Далее. я тут сразу еще скажу то что совершенно очевидно что при такой системе кодирования
чисел старший бит который показывает знак это нетолько бит отвечающий за знак это также 
бит который тоже участвует в кодировании величины числа.это совершенно очевидно. тоесть если взять 
1011 = ( для цпу это прежнему 11) | эквивалент -5
это число и заменить его старший бит с 1 на ноль то мы получим 0011 и согласно верхней
таблице мы получили 
0011 = ( для цпу это прежнему 03)
тоесть у нас было -5 а получили 03
тоесть я хотел сказать что если мы заменяем старший бит с 1 на ноль то мы неполучили 5.
типа было -5 а стало 5. и совершенно понятно почему! конечно так и должно быть.

далее книжку по асемблеру от BOB NEVELN пишет что для цпу информация в регистре она всегда
положительная. а число может быть отрицательным только в интерпретации программы.
ну это мы уже поняли.

итак мы научились к отрицательному числу прибавлять положительное.
берем отрцаительное число находим по таблицк какое положительное число надо
засунуть в регистр. и запускаем на цпу операция сложения.
возникает вопрос как нам на уровне программы\компа\цпу научиться находить число 
из таблицы без таблицы.  


16-x = (15-x) +1

15-x = NOT x

-x = NOT x + (-15)

x=7 = 0111
NOT x= 1000
-15 =0001

-7 = 1000 + 0001 = 1001

1000
0001
-----
1001


Дальше в этой книжке описывается просто поразтельная вещь- а как же нам научиться отнимать 
число от другого числа при этом пользуясь все тем же в цпу блоком который производить сложение. ибо нехочется цпу усложнять новыми транзисторными схемами . и они придумали поразителную схему.

хотим отнять 5-3. замечаем что 
5 - 3 = 5+(-3)

значит теперь мы перевели задачу об отнимании в задачу о сложении. только есть загвоздка
нужно научиться 3 переводить в -3. далее книжка пишет что эта операция нетак проста что это непорсто заменить операция заменить старший бит с 1 на ноль. ( и я тоже согласен с этим).
как показала формула выше чтобы получить для цпу эквивалент -3 это надо выполнить операцию

P = 2^n-N.
скажем у нас 4 битный регистр. тогда
P=16-3
и тут мы уперлись в том что на цпу нужно иметь блок отнимания. типа тупик. но дальше кникжа
пишет что во первых восопользуемся формулой

16-3 = (15-3) +1

далее посмотрим как выглядит отнимание 15-3 на бумаге

1111
0011
-----
1100

так вот присмотримся к 3 и результату
3          = 0011
результат  = 1100

так вот книжка утверждает что при отнимании от 1111 любого числа результатом будет число
которое получается из отнимаемого числа просто операцией замены каждого нуля на единицу
и каждой единица на ноль в отнимаемом числе тоесть.

мы отнимали 3 от 15. 3 это 0011 значит ответ будет 1100 (заменили в тройке все нули на единицы а все единицы на тройки). тогда получается что надо в цпу добавить очень простой блок которйы будет в отнимаемом числе менять биты на наоборот.
с помощью этого блока мы научили цпу отнимать 15-3
смотрим наверх чтобы получить 16-3 нам надо получить 15-3 ( это мы уже можем) и потом еще 
к результатут добавит единицу . для добавления единицы тоже в цпу можно пристроить очень простой блок.

таким образом добавив блок инвертирования битов и блок добавления единицы мы научили цпу
отнимать числа . тоесть

мы хотим отнять 12-4 грузим 12 и 4 в регистры. и даем команду на асемблере мол отнимай.
что делает цпу.


он начинает превращать 4 в -4

-4 = (15-4) +1

4 у нас это 0100
инвертруем на нем биты и получаем чему равно 15-4 = 1011
далее добавляем единицу
1011
0001
-----
1100

это мы получили аналог -4 = 1100

теперь выполняем операция сложения

12 + (-4)
12= 1100
-4= 1100

выполняем сложение

1100
1100
-----
1000 

получили переполнение но это неважно


с точки зрения unsigned integer 1000  это 8.
значит 12-4=8

что меня смущает 12 относится к unsigned intger диапазону а -4 относится к signned integer 
дапазону. как же мы можем смешивать две кодиовки?

зато стало понятно откуда взялась эта формула. что 

если a>0 то -a можно получить в битовом виде через :
-a = (~ a) + 1
где ~ это bitwise NOT.

формулу можно немного и преобразовать
(~ a) = -a-1
получаем тогда типа что если a=0 . то 
(~ 0) = -1

а скажем 
(~ 6) = -6-1 = -7

в баше ровно это и видим:
$ echo $(( ~0 ))
-1
$ echo $(( ~6 ))
-7

в книже по асемблеру процесс инвертации битов в регистре и добавление единицы назыается процессом two's complementation ( переводится как я понимаю дополнение до двух).
по факту это получается алгоритм битовой обработки числа в двоичной форме чтобы получить 
из положительного числа его отрицательную форму с точки зрения кодирования signed integer в битовом виде. таком что сложение на блоке сложения на цпу всегда дает верный результат внезависимости от того что подразумевает программа которая засунулу это число в регистр
толи программа имеет ввиду что это signed int или unsigned int.


у меня остался вопрос - меня смущает 12 относится к unsigned intger диапазону а -4 относится к signned integer 
дапазону. как же мы можем смешивать две кодиовки? тут даже два вопроса.
а как нам отнимать не 4 а например 14 потому что -14 в кодировке со старшим битом 
такого числа там нет. вторйо вопрос если мы взяли 12 из одной кодиовки а -4 из другой
то ответ как интерперретировать к какой кодировке его относить. по мне самый просто ответ
это то что и левое число и правое должны быть взяты из одной кодровки. и наверное
эта кодировка это signed int та при которой минусовые числа имеют старший бит равный 1. 
для 4 битов это диапазон чисел от -8 до 7

если же мы берем числа в диапазоне unsigmed int. то тут непонятно.
числа от 0 до 15.
отнимаем 1-15
насколько я понимаю в этом случае исползуется кодировка когда у нас отрицательное число
необьязано иметь 1 в старщем бите.тоесть кода у нас комбинация битов может трактоваятся
программой и как полжительное число и как отрицательное.
и тут проблема как трактовать полученный ответ. я так понимаю что на это влияет бит переполнения.

берем 15 и превращаем его в -15

1111 =15
инвертируем биты и добаляем 1 получаем
0001

складываем 1 и -15

0001
0001
-----
0010

бит переплонения при этом несработал

0010 это эквивалент -14 ( при условии что мы нетребуем старший бит чтобы был равен 1)
но как нашей программе отличить это -14 или 2. я пока только могу сказаьт что бит переполнения
не срабатывает в этом примере. 

попробуем другой пример

12 -4

4 это  0100
-4 это 1011+0001

1011
0001
-----
1100

12 это 1100

скалдываем

1100
1100
-----
1000

приэтом сработал флаг переполнения

1000 это 8 либо -8

из этих двух примеров я делаю вывод что наша программа может опредеить брать положительное
число или отрицательное вот как: если бит сработал переполения то брать положительный вариант числа. а если флаг переполнения несработал то брать отрицательнй вариант числа.


1-15=0010(2 либо -14) и флаг переполнения несработал
флаг переполнения несработал значит берем отрицательнйы вариант -14
итого 1-15=14

12-4=1000(8 либо -8) и флаг преполнения сработал 
флаг преполнения сработал значит берем пооложительнй вариант 8
итого 12-4=8

замечу что когда мы отнимаем числа в диапазоне unisgned integers то для кодирования
отрицательного числа у нас уже нет требования чтобы старший бит был равен 1
фактически мы работам сразу с двумя диапазонами от 0 до 15 и от -15 до 0
когда набор бит может одновременно быть трактован и положительным и отрицательным числом.
и тогда задача программы на основе флага переполенения понимать какой число с плюсом илли минусом в ответе она получено.


попробуем отнять чисала  с диапазона signed untegers от -8 до 7

-8-7

-8-7=(-8) + (-7)

8 =  1000
-8 = 0111+0001

0111
0001
-----
1000 флаг переполнения получен

7 =  0111
-7 = 1000 + 0001

1000
0001
-----
1001 флаг переполнения неполучен

значит -8 = 1000
-7 = 1001

складываем

1000
1001
-----
0001 флаг переполнения получен

0001 это 1 либо -15

вспоминаем правило: если бит сработал переполения то брать положительный вариант числа. а если флаг переполнения несработал то брать отрицательнй вариант числа.

но у нас тут прикол в том что флаг переполнения сработал два раза так что может быть 
это тоже обозначает что надо брат отрицательный вариант. 

тогда 0001 интерпретриуем как -15
тогда
-8-7=-15

ну как то так но не очень понятно.
====================================
====================================

 

       **     exponentiation
       * / %  multiplication, division, remainder
       + -    addition, subtraction
       << >>  left and right bitwise shifts
       <= >= < >
              comparison
       == !=  equality and inequality
       &      bitwise AND
       ^      bitwise exclusive OR
       |      bitwise OR
       &&     logical AND
       ||     logical OR
       expr?expr:expr
              conditional operator
       expr1 , expr2
              comma




послесловие:

если мы хотим присвоить значение в переменную тогда

$ n=$(( 5 + 4 ))
$ echo $n
9

 а впот пример показывает что расчеты идут только как с целыми числами, никакой 
 дробности нет
$ echo $(( 10 / 3 ))
3

обратим внимание на этот синтаксис
expr1 , expr2
              comma

пример на эту тему

$ a=1;b=3
$ (( a=a+10, b=b+a ))
$ echo $a
11
$ echo $b
14




можно использовать в скобках нетлоько дсесятичые числа но и hex и бинари 
делается через 

(( 2#01010101 )) - бинарное число
(( 16#a134f )) - hex число

посмотреть всегда можно в man bash искатьпо слову arithmetic evaluation

$ echo $(( 2#101 ))
5

$ echo $(( 16#F ))
15

в каком виде баш хранит переменные? какие есть типы переменнух у баша?
цитрую из книжки по башу:
Unlike many other programming languages, Bash does not segregate its variables by "type." Essentially, Bash variables are character strings, but, depending on context, Bash permits arithmetic operations and comparisons on variables. The determining factor is whether the value of a variable contains only digits.

итак если у баша перменные эти всегда strings. но с ними можнр делаь операции порой как
с integer то возникает вопрос насчет формата печати переменных.
так вот формат в котором будет распечатана переменная зависит от прогаммы которая
печаатет переменну.

у echo  всегда будет в dec формате.
потому что echo переменые выводит всегда в dec формате

printf может вывести переменную в hex формате

$ q=$(( 16#f ))
$ printf "%x\n"  $q
f

итак надо различать тот вид в котором перменная хранися в памяти 
и тот вид в котором она напечаатана. это разное.


далее рассмотрим такую штуку:
<< >>  left and right bitwise shifts

$ (( n>>4 )) 
эта штука берет число автоматом его переделывает в бинарный вид и далее сдвигает все биты
направо на 4 бита.

рассмотрим на примере n=15 (0000 1111)
при сдвиге вправо на 4 бита получим конечно ноль
$ n=15; echo $(( n>>4 ))
0
$ n=15; echo $(( n>>3 ))
1
$ n=15; echo $(( n>>2 ))
3
при сдвиге на один бит получим 111 тоесть семь
$ n=15; echo $(( n>>1 ))
7

что еще важно. (( n>>4 )) она двигает биты но саму переменую неменяет.
$  n=15; echo $(( n>>1 )); echo $n
7
15



дале рассмотрим такую штуку:
 expr?expr:expr
              conditional operator
 это ternary(тройной в переводе) оператор. 
 его смысл: An expression a ? b : c evaluates to b if the value of a is true, and otherwise to c

 пример
$ (( a=5<4?5:4 ))
$ echo $(( a=5<4?5:4 ))
4
$ echo $a
4

итак смысл если 5<4 то тогда присвоить a=5 иначе присвоить a=4





$ { let n&=9; }
[1] 13696
=9: command not found
[1]+  Done                    let n
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ let n\&=9;
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ echo $n
9
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ n=15
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ let n\&=9;
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ echo $n
9
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~$ 


далее рассмотрим такую штуку:
 - +    unary minus and plus

 

=====
bash
parameter expansion

смотри в man bash по слову "patameter expansion"

один из примеров по этой теме.а именно 
${parameter/pattern/string}


$ a=2334
$ (( a++ ))
$ echo $a
2335

$ echo ${a/23/BB}
BB35

получается что параметром может быть перменная. она указывается без знака
доллара.
что делается - в параметре ищется паттерн и когда он найден то он заменяется на string

в 2335 искался 23 и когда его нашли то его заменили на BB

======
bash
variable

при обьявлении еременой нельзя использовать пробелы. будет ошибка

$ a=1

$ a= 1
1: command not found

$ a = 1
a: command not found

=========
bash
declare

позволяет обьявить переменную точнее ее тип.

обьявить integer переменую
$ declare -i a

проверить какой тип у обьявленной переменной
$ declare -p a
declare -i a

$ a=12
$ echo $a
12


при попытке integer переменной присвоить неinteger значение , ее значение будет сброшено в ноль
$ a=e3
$ echo $a
0


оьявляем переменную у которой все буквы мелкие. если введем большую букву 
то она автоматом будет переделана в мелкую
$ declare -l kk
$ kk="qw12e12"
$ echo $kk
qw12e12
$ kk="QWE123kfjUOIU12"
$ echo $kk
qwe123kfjuoiu12


обьявляем переменну в котоой буквы все заглавные
$ declare -u UU
$ echo $UU
12kewfjewlkjbvvbbbb
$ UU="12kewfjewlkjBVVBBBB"
$ echo $UU
12KEWFJEWLKJBVVBBBB

это очень удобно для применения с bc и hex числами потому что bc понимает только 
когда hex числа ему скармиливаются только через заглавыне буквы

кстати на счет того как это внешняя программа /bin/echo получает переменную и понимает 
ее.например

$ /bin/echo $p

ведь дело в том что /bin/echo понятия не иммет ни о какой переменной $p. у него нет 
этой переменной в памяти. 

а дело в том что баш себя форкает. однако при этом дочерний процесс это все тот же баш
и далее этот дочерний баш он просто берет занчение переменной $p и подстлавяет число в 
execve

exeve("/bin/echo","...", число)

таким образом команде /bin/echo всего навсего нужно распечатать просто число которое к ней поступило в качестве первого параметра. тоесть я хочу сказать что /bin/echo понятия неимеет
ни о какой переменной $p. это баш выхывает execve и подставляет туда значение в форме уже 
готовой цифры. да безусолвно есть еще механизм что баш в execve пихает я массив  envp[]

int execve(const char *filename, char *const argv[],
                  char *const envp[]);

в котором содержатся все глобальные переменные баша но там небудет переменной $p.
итак еще раз.

есть команда

$/bin/echo $p

она неимеет к баш никакого отношения. чисто внешний бинарник.
скорей всего его код имеет вид

int main(int argc, char *argv[]){}

или вид

int main(int argc, char *argv[], char *envp[])

в любом случае наш параметр $p попадет  в argv[]. 
как это произойдет. баш себя форкнет то есть склонирует и создат свою копию.
и эта копия запустит execve ("/bin/echo",["/bin/echo", 20],NULL)
так вот фишка в том что в /bin/echo попадает не $p а уже его числовое значение ибо баш 
в execve подставить уже значение $p поэтому /bin/echo вообще понятия неимеет ни о каком $p
он просто на вход получает готовое число.
таким образом при запуске внешних программ сам баш раскрывает все переменные а во внешние 
программы он передает уже готовые числа\значения. вот откуд ответ на вопрос " а откуда echo 
знает о переменной $p".
ну я конечно молчу если используется не внешний файл /bin/echo а башевский builtin echo.там еще проще.


также замечу что баш передает внешней программе все глобальные переменные через третий парметр в execve ( не все переменные а именно только глобальные)

это  выглядит вот както так

execve("/bin/ls", ["ls", "--color=auto"], ["CLUTTER_IM_MODULE=xim", "LS_COLORS=rs=0:di=01;34:ln=01;36"..., "LC_MEASUREMENT=ru_RU.UTF-8", "MC_SID=29047", "LESSCLOSE=/usr/bin/lesspipe %s %"..., ...", "GTK_IM_MODULE=ibus", "LC_TIME=ru_RU.UTF-8", "OLDPWD=/home/vasya/Asm", "_=/bin/ls"]) = 0

для того что бы внещнаяя программа могла их принять у нее в ее main() должен быть указан третий параметр

int main(int argc, char *argv[], char *envp[])

но этот способ счиатется ненадежным непереносимым. более наежный способ это то что 
у внешней прграммы должны быть указана глобальная перменная

extern char **environ;
int main(int argc, char *argv[]) 

тогда при вызове башем execve ядро когда будет создавать пространство памяти 
для ноового процесса создать там переменную environ и в нее запишет весь массив из третей переменной execve. такой способ считвается переносимым.

это ответ на вопрос как же из баша переменные передаются другим программамам.

========================

zabbix
/etc/passwd

история - в заббиксе можно увидеть часто алерт вида   "/etc/passwd has been changed"

как работает item от этого триггера  : zabbix использует линукс команду cksum. что она делает - она вычиясляет crc от файла.
тоесть этот crc он высчитывается от байтового содержания файла. ( а от имени файла и от его времени изменения crc независит что тоже важно).

$ cksum /etc/passwd
2207685566 3268 /etc/passwd

2207685566 первое число это crc32 число(контрольная сумма).
3268 это разер файла в баайтах

я проверил - изменение имени файла реально не влияет на cksum
также изменение времен ( acccess time, modify time) без изменения контента файла(через touch -a -m /etc/passwd)  тоже невлияет на cksum

таким образом еще раз - cksum вычисляет crc от файла и на это влияет только содержимое файла а имя файла и  время доступа к файлу никак на это невлияет.


итак мы поняли что если триггер сработал значит 100% контент файла /etc/passwd был точно имзенен.

если мы руками там ничего неменяли тоесть еще один вариант -  так кто же  засунул нового юзера либо сменил 
пароль в /etc/passwd. так вот оказыается что это случается когда мы устаналиваем новый пакет.
примером такого пакета явялется пакет ntp. при установке этого пакета он долавбяет в /etc/passwd  нового юзера ntp

ntp:x:129:136::/nonexistent:/usr/sbin/nologin

вот и разгадка алерта!

так вот - когда файл /etc/passwd будет изменен то это время изменения останется в *time файла. тоесть

# stat /etc/passwd
.....
Access: 2022-11-12 01:51:02.857747523 +0600
Modify: 2022-11-12 01:51:02.857747523 +0600
Change: 2022-11-12 01:51:02.872747584 +0600

так вот если алерт вылез. и непонятно почему и откуда. то полезно взять время модификации файла passwd 
и проверить а ровно в это время не был ли установлен в системе НОВЫЙ ПАКЕТ!?!?!?!?!?!?!!?!?

для yum это:
# tail /var/log/yum.log 
Nov 12 01:51:02 Installed: autogen-libopts-5.18-5.el7.x86_64
Nov 12 01:51:03 Installed: ntpdate-4.2.6p5-29.el7.centos.2.x86_64
Nov 12 01:51:04 Installed: ntp-4.2.6p5-29.el7.centos.2.x86_64


и вот мы увидели что ровно втоже время когда был модифицирован passwd файл ставился в системе пакет ntp. вот из
за этого и оттуда файл passwd и был изменен!


для apt это:

# stat /etc/passwd
.....
Access: 2022-11-12 01:48:49.161664596 +0600
Modify: 2022-11-12 01:48:49.145662840 +0600
Change: 2022-11-12 01:48:49.149663279 +0600


# tail -n 40 /var/log/apt/history.log
Start-Date: 2022-11-12  01:48:47
Commandline: apt-get install ntp
End-Date: 2022-11-12  01:48:55

вот! во время модификации passwd устаналвился пакет ntp который его и поменял!

Итого: если заббикс выплюнул алерт то полезно проверить может быть во время модификации passwd в системе был установлен некоторый интересный пакет наример ntp,
который лезет сам в passwd и туда всталяет своего служебного юзера.


что еще хочется сказать. 
алерт забикса он в целом полезен. но он вообще нераскрывает  кто когда как и на что поменял файл /etc/passwd

========================================

если вылезает такая шибка

update-initramfs: Generating /boot/initrd.img-5.4.0-91-generic
W: Possible missing firmware /lib/firmware/rtl_nic/rtl8125a-3.fw for module r8169
W: Possible missing firmware /lib/firmware/rtl_nic/rtl8168fp-3.fw for module r8169
W: Possible missing firmware /lib/firmware/i915/tgl_dmc_ver2_04.bin for module i915
W: Possible missing firmware /lib/firmware/i915/skl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/bxt_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/kbl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/glk_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/kbl_guc_33.0.0.bin for module i915
W: Possible missing firmware /lib/firmware/i915/icl_guc_33.0.0.bin for module i915
update-initramfs: Generating /boot/initrd.img-5.4.0-84-generic

о том что нехватает какойто firmare
что делать

качаем эти firmware с сайта ядра.
mkdir rtl8125b_fw
cd rtl8125b_fw
wget https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/rtl_nic/rtl8125b-2.fw
wget https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/rtl_nic/rtl8168fp-3.fw
sudo cp *.fw /lib/firmware/rtl_nic/
sudo update-initramfs -u

и обноавляем initramfs

аналогично на сайте  в папке i915 лежат недостющие для него firmware

https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/i915/

=====
как узнать какое устройство работает на каком драйвере

$ lspci -vv -nn | grep -E "..:..\..|modules"

пример вывода:
00:02.0 VGA compatible controller [0300]: Intel Corporation Device [8086:3ea0] (rev 02) (prog-if 00 [VGA controller])
	Kernel modules: i915

00:04.0 Signal processing controller [1180]: Intel Corporation Xeon E3-1200 v5/E3-1500 v5/6th Gen Core Processor Thermal Subsystem [8086:1903] (rev 0c)
	Kernel modules: processor_thermal_device

00:12.0 Signal processing controller [1180]: Intel Corporation Device [8086:9df9] (rev 30)
	Kernel modules: intel_pch_thermal

видно название железки и обслуживающий ее драйвер (модулья ядра)

====

apropos

полжим мы хотим найти man по какйото теме в линуксе. 

тогда можно заюзать apropos . пишут что каждый маг содержит ключевые солова и апропос
ищет нам статьи мана по ключевым словами. пример хотим почитать про firmware

$ apropos firmware
bootctl (1)          - Control the firmware and boot manager settings
btcflash (8)         - firmware flash utility for BTC DRW1008 DVD+/-RW recorder.
hex2hcd (1)          - firmware converter
hp-firmware (1)      - Firmware Download Utility
nvme-fw-commit (1)   - Used to verify and commit a firmware image.
nvme-fw-download (1) - Download all or a portion of an nvme firmware image.
nvme-fw-log (1)      - Send NVMe Firmware log page request, returns result and log
rpl8 (8)             - Firmware loader for DVD drives
[vasya@lenovo docs]$ 

-----


initramfs
firmware
driver


когда мы обновляем initramfs то может выскочить на экране что у нас нехватает /lib/firmware/.. файлов
из пакетов искать это мудота. там бывает нет тог что надо. простой выход скачать их отсююда https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/refs/

а потом просто копируемфайлы в папку /lib/firmware

что за хрень firmware. 

вот здесь пишут https://wiki.ubuntu.com/Kernel/Firmware  что  каждый а может и не каждый драйвер состоит из двух частей одна часть это модуль ядра. фишка модуля ядра в том что от него есть исходный код. 
а вторая часть это готовый бинарник без исходного кода который зоветмя фирмвейр. и этот бинарнтик надо 
закачивать внутрь железки. почему его там нет изналачально непонятно. и вот так как это бинарник без исхоных кодов то начтнается мудота где его взять ибо это же линукс. тут у всего должны быть исходные коды.
поэтому их придодися качать отдебно.

как проверить какие firmware по факту были загружены

# dmesg -T | grep -e 'firmware'
[Чт дек 29 17:03:26 2022] [drm] Finished loading DMC firmware i915/kbl_dmc_ver1_04.bin (v1.4)
[Чт дек 29 17:03:30 2022] ath10k_pci 0000:02:00.0: firmware ver WLAN.TF.2.1-00021-QCARMSWP-1 api 6 features wowlan,ignore-otp crc32 42e41877

----
cron

была следдущая тупая залупа

задание cron не отрабатывало только потому что файл крона в /etc/cron.d/file имел 
неправильные permissions  ! тоесть обязательно надо чтобы root.root и никак по другому.

вот такой ебнутый cron по архитектуре.

догадка пришла тогда когда посмотрел journalctl -f -u crond

----

cron

по дефолту все крон джобы исполняются от root
и только если мы укажем в строке крон джоба другого юзера то джоб будет 
исполнятся не от рута.

-----

как нам удалить переменную из баша которую мы обьявили чеерз export
ответ unset

пример
$ export vasya =1
$ set | grep vasya
$ unset vasya
$ set | grep 

-------

ufw настройка файрволла

как настроить файрволл

по большому счету либо ufw на хосте либо докер. но чтото одно.
потому что докер лезет в настройки iptabes и создает правила в обход ufw.
ессли же актииивировать MANAGE_BUILTINS=yes то ufw стирает часть прпавил докера
и он неможет запускать контейнеры. поэтмоу на лицо явный конфликт. 
а если использовать MANAGE_BUILTINS=no то толку от ufw ноль. ибо докер 
открыает порты и пиздец. поэтому либо докер+внешний файрволл. 
либо ufw и никакого докера. единственное что если мы будем на хосте запускать 
докер контейнер который не открыавет порты то тогда ufw можно использовать 
на хосте ибо докер неменяет сет правила при этом. соотсвтенно ufw надо юзать
с опцией MANAGE_BUILTINS=yes 
это кратно. а подробности ниже.




супер важная вещь что  ufw по дефолту контролирует только часть правил iptables.
а чтобы ufw контролировал все правила целиком то надо выставить
# cat /etc/default/ufw
MANAGE_BUILTINS=yes
и перезагрузка сервиса. об этом читай в linux-general.txt
возможно это может мешать докеру. это надо выяснять.


далее  отключить ipv6 на ufw 
# sudo nano /etc/default/ufw
IPV6=no
      

типовой набор команд активации ufw:

   98  ufw default deny incoming
   99  ufw default allow outgoing
  100  ufw allow 22/tcp
  102  ufw show added numbered
  103  ufw enable
  104  ufw allow 80/tcp
  105  ufw allow 443/tcp
  106  ufw reload
  108  ufw status numbered
  111  ufw status verbose
   11  ufw allow in  on <interface> to any  (это правило юзать чтобы разрешить все входящие на 
   интерфейс который будет отвечать за локалку)


Status: active

     To                         Action      From
     --                         ------      ----
[ 1] 22/tcp                     ALLOW IN    Anywhere                  
[ 2] 80/tcp                     ALLOW IN    Anywhere                  
[ 3] 443/tcp                    ALLOW IN    Anywhere        


как настроить через него nat и port forward

https://gist.github.com/kimus/9315140


ДАЛЕЕ: КАК активировать NAT :

/etc/default/ufw
DEFAULT_FORWARD_POLICY="ACCEPT"


в sysctl 
net.ipv4.ip_forward=1


далее сказано что надо разместить вот этот кусок вначале файла /etc/ufw/before.rules до блока *filter
однако в man ufw (который тоже хороший документ) сказано что этот кусок нужно разместить в конце
этого файла после блока *filter




# NAT table rules
*nat
:POSTROUTING ACCEPT [0:0]

# Forward traffic through eth0 - Change to match you out-interface
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE

# don't delete the 'COMMIT' line or these nat table rules won't
# be processed
COMMIT


перегружаем правила готово
# ufw reload


однако тут выясняется прикол. если мы сделаем пару перезагрузок ufw 
то мы заметим что правила каасающиеся NAT они размножаются это мможно увидеть через iptables-save



будет вот чтото типа такого

*nat
:PREROUTING ACCEPT [385:22237]
:INPUT ACCEPT [63:3370]
:OUTPUT ACCEPT [5:368]
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
-A POSTROUTING -s 10.10.10.0/24 -o eth0 -j MASQUERADE
COMMIT



это же жесть!

так вот я нашел разьяснение = https://bugs.launchpad.net/ufw/+bug/364558
цитирую 

Thank you for using ufw and taking the time to report a bug. This is by design to make sure ufw doesn't step on other applications' rules. From /usr/share/doc/ufw/README.gz:

The primary chains are ufw-before-*, ufw-after-* and ufw-reject-*. The
treatment of iptables' built-in chains can be controlled with the
MANAGE_BUILTINS configuration option (in /etc/default/ufw). By default this is
set to 'no', which means that other than adding the primary chains, the
built-in chains will remain untouched. This also means that these primary
chains will stay in the table, even after disabling ufw. This is to make sure
that the primary chains don't move around other non-ufw rules and chains. To
completely flush the built-in chains with this configuration, you can use:

# /usr/share/ufw/ufw-init flush-all

Alternately, ufw may also take full control of the firewall by setting
MANAGE_BUILTINS=yes in /etc/defaults/ufw. This will flush all the built-in
rules and delete the non-built-in rules on start, stop and reload.


поэтому я выбрал решение

MANAGE_BUILTINS=yes in /etc/defaults/ufw

вот при таком раскладе уже перезагрузка ufw недает разможения правил в iptables-save

также при отключенной опции и наличии докера  наш файрволл теряет весь смысл потому что докер
будет вставлять свои цеопчки и контейнеры будут выставлены наружу!!!


еще один важный момент про связь между ufw и docker
если у нас выставлена опция MANAGE_BUILTINS=no
то если мы стартуем контейнер 
# docker run -it --rm -d -p 80:80 --name web2 nginx
то докер добавляет сам правила в таблицу iptables и таким макаром 
открывает на хосте порты наружу! все файрволл пробит изнутри.
а что будет если перезагрузить ufw ?
# ufw reload
будет то что ufw нетрогает правила докера  и порт открытый через докер 
останется открытым!


а если у нас выставлена опция MANAGE_BUILTINS=yes
тогда при запуске ufw он стирает часть правил докера
и при попытке запуска докера  увидим вот что 

# docker run -it --rm -d -p 80:80 --name web2 nginx

f2de59cccf062b2a6cd320d3a0106c657e54ee99ed02a06b80abb4f8a2eec4b1
docker: Error response from daemon: driver failed programming external connectivity on endpoint web2 (27b91c86e25636fbdbda98dedc2e3a59312c1bf5532d62dcd37b14f809d151d8):  (iptables failed: iptables --wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 --dport 80 -j ACCEPT: iptables: No chain/target/match by that name.
 (exit status 1)).

если мы перезапустим сервис докера
# systemctl restart docker

то он создаст свои стертые правила и тогда уже можно успешно запустить контейнер 

# docker run -it --rm -d -p 80:80 --name web2 nginx

и у нас опять порт открыт наружу !
а что будет если перезапустить ufw? он сотрет часть правил докера 
и это приведет вот к чему = с самого хоста доступ в контенер по порту будет работать
но снаружи доступа к порту контейнера нет.

если наша задача закрыть порт контейнера снаружи то тогда надо при каждом новом запуске
или перезапуске контейнера перезапускать ufw!!а это полная фигня а не продакшн.


============




----------

parted, expand, grow, extend


вот если мы увеличили размер диска в гипервизоре

далее мы обнвоили об этом инфо через

# rescan-scsi-tool

далее надо как то через parted изменить раздел 


# lsblk -f  -o name,size
NAME    SIZE
sda      24G
├─sda1  953M
├─sda2    1G
├─sda3    2G
└─sda4 18,4G




расширяем раздел sda4

# parted /dev/sda
(parted) resizepart 4 100%
Warning: Partition /dev/sda4 is being used. Are you sure you want to continue?
Yes/No? Yes                                                               



# lsblk -f  -o name,size               
NAME    SIZE
sda      24G
├─sda1  953M
├─sda2    1G
├─sda3    2G
└─sda4 20,1G


удобство в том что resizepart 4 100% даем то что ненужно руками вбирвать размер хвоста
мы просто говорим расширь на все сколько можешь


и далее после расширения партиции надо еще расширить ФС

# xfs_grows  /mount_pint
или
# resize2fs /device


--------------

netplan

типовая настройка

ip адрес
если мы настраиваем сет карту через netplan вот конфиг типовой

# cat /etc/netplan/00-installer-config.yaml 
network:
  ethernets:
    eth0:
      optional: true
      addresses:
      - 81.81.81.81/28
      nameservers:
        addresses:
        - 8.8.8.8
        search: []
      routes:
      - to: default
        via: 81.81.81.80
    eth1:
      optional: true
      addresses:
      - 10.10.10.1/24
      nameservers:
        addresses:
        - 8.8.8.8
        search: []
  version: 2


и здесь я укажу очень важную опцию 
optional: true
смысл ее в том что при такой настройке линукс небудет ждать пока указанный интерфейс будет полностью сконфигурирован
и готов к работе (согласно man netplan) - что это по факту значит "будет полностью готов к работе"
но по факту если этой настройки нет то  при загруке убунты у нас загрузка останавливается на фразе

"job is running for wait for network to be configured.." 

и так висит 30-60 секунд.
а вот с этой настройкой такой хуйни нет и вртуалка грузится мгновенно.

а вот кстати как проверить скорость интернета из команднйо строки

# apt-get install -y speedtest-cli


---
mysql
mariadb

делаем

# ps aux | grep mariadb


вопрос как узнать на данный момент база запущена из сервиса или руками.
так вот ответ такой  - если база работает  потому что ее запустили из сервиса то в процессах этот процесс будет иметь очень простой вид

ps aux | grep mariadb
mysql     531425 24.1 20.2 7798524 2066700 ?     Ssl  20:33   7:12 /usr/sbin/mariadbd

а вот если прцоесс был запущен руками то вид будет совершенно другой сложный.

# ps aux | grep mariadb
mysql     493096 48.4 85.4 12509856 8709908 ?    Sl   мар23 1592:12 /usr/sbin/mariadbd --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/mysql/plugin --user=mysql --skip-grant-tables --log-error=/var/log/mysql/error.log --open-files-limit=16364 --pid-file=/var/run/mysqld/mysqld.pid --socket=/var/run/mysqld/mysqld.sock --port=3306

ну и конечно эо можно проверить через банальный

# systemctl status mariadb
и он покажет работает ли сервис сейчас на данный момент или он упал.

----------

mariadb
mysql

проверить текущий статус  ведет ли mysql\mariadb бинарный лог


> show variables like 'log_bin';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| log_bin       | ON    |
+---------------+-------+
1 row in set (0,001 sec)



посмотреть список бинарных логов

> SHOW BINARY LOGS;
+--------------------+------------+
| Log_name           | File_size  |
+--------------------+------------+
| mariadb-bin.000071 |          0 |
| mariadb-bin.000072 |          0 |
| mariadb-bin.000073 |          0 |
| mariadb-bin.000074 |          0 |
| mariadb-bin.000075 |          0 |
| mariadb-bin.000076 |          0 |
| mariadb-bin.000077 |          0 |
| mariadb-bin.000078 |          0 |
| mariadb-bin.000079 |          0 |
| mariadb-bin.000080 |          0 |
| mariadb-bin.000081 |          0 |
| mariadb-bin.000082 |          0 |
| mariadb-bin.000083 |          0 |
| mariadb-bin.000084 |          0 |
| mariadb-bin.000085 | 1048585914 |
| mariadb-bin.000086 |  995604484 |
+--------------------+------------+


как отключить
идем в конфиг и 

[mysqld]
skip-log-bin = true 


---------------------

mariadb
mysql

slow query log

как проверить что он щас активирован


> show variables like 'slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | ON    |
+----------------+-------+



как это выключить без перезапуска 

>  SET GLOBAL slow_query_log = 'OFF';

но чтобы проверить сработало или нет то  надо обязательно 
выйти из мускула и обратно зайти. 

> show variables like 'slow_query_log';
+----------------+-------+
| Variable_name  | Value |
+----------------+-------+
| slow_query_log | OFF   |
+----------------+-------+


а если не выйти\зайти то будет показывать 
что якобы по прежнему все работает.


а как через конфиг отключить?
ну вроде вот так - просто закоментить

#slow_query_log          = 1
#slow_query_log_file     = /var/log/mysql/mariadb-slow.log
#log_slow_rate_limit    = 1000
#log_slow_verbosity      = query_plan
#log_slow_admin_statements

----------

mariadb
mysql

> show variables like 'general_log';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| general_log   | OFF   |
+---------------+-------+


----------------

ipv6
ubuntu

как отключить

net.ipv6.conf.all.disable_ipv6=1
net.ipv6.conf.default.disable_ipv6=1
net.ipv6.conf.lo.disable_ipv6 = 1

-------------

logrotate

интерснейший момент.

как заставить лог ротейт ртейтить логи нетолько в указанной папке но и в ее подпапках

/var/log/basedir/*.log /var/log/basedir/*/*.log {
    daily
    rotate 5
}


в этом примере будут обработаны файлы нетолько в папке /var/log/basedir/
но и в во всех папаках вида /var/log/basedir/XXX

это круто!

---------------------
logrotate

 пример 


конфиг логротетйат:


# export d1="/etc/logrotate.d/mysql-backup" && touch $d1 && chown 0.0 $d1 && chmod 644 $d1

# cat mysql-backup 
/var/backups/mysql/*.gz {
    rotate 40
    daily
    dateext
    nocompress
    notifempty
    nocreate
    missingok
}



daily = срабатывает раз в день. ( вобще ежедненво это самый минимальный кусок времени когда логротейт сразбаывает. быстрее он неможет)

dateext = доабвляеть к архивному файлу тайм стамп (день месяц год)

nocompress  = несжимать архив потому что он уже и так сжат

notifempty = неархивирвать пустые файлы

nocreate = когда зааривхировал файл (он же его переимноваые и исходный иссчезает) то несозадвать новый. ибо незачем

missingok = если исходного файла нет то окей. номрально.это значит что логротейт сработал и убрал исходный файл а новый архив через крон
таки не появился. ну и хер сним

rotate 40 = хранить 40 архивных копий. а 41-ю удалять.


как проверить что logrotate будет рабооать, а вот только так:

# logrotate -v /etc/logrotate.d/mysql-backup  -f 

-f = завсталвяет насильно срабаывает ротейт. иначе он нихера делать неубутдет этого.

установка закончена.

===
ubuntu 

если завситли окна как презапусить cinanmon :


от прав простого юзера

$ cinnamon --replace -d :0.0

как отчлюит apport (котоырй краш дампы снимает)

# systenctl stop apport && systemcl diable apport


красота!

====
| snap

отключчить автоматическое оновление снапов

дело в том что по дефолту так там установлено что 4 раза в день система пытается обновить
каждый снап пакет. и это приводит к диким тормозам то бишь открываешь top 
и там висит бинарник snapd и жрет более 100%. и таких бинарников там может быть два например.
нахер это надо.

чтобы отключить обновление снапов надо :

# sudo systemctl stop snapd.service
# sudo systemctl mask snapd.service

чтоб вернуть обоатно

# sudo systemctl unmask snapd.service
# sudo systemctl start  snapd.service
# sudo snap refresh

приэтом сами снапы родолжают работать !

но это вреод как херноввый алгоритм остановки автоообновлений. более нормальный вариант это 
# snap refresh --hold=forever

===
| snap
еще очень полезная вещь про snap это то что если мы юзаем lxd контейнеры.
то нам внутри этих контейнеров то нам там обычно snap ненужен.
поэтому если запустили контейенр то нужно внутри него удалит snap иначе эта падла
будет проверять snap пакеты на новые версии и охиренно грузить процессор.

выглядит это так. смотри в top и видим там 100% загрузку цпу у процесса snapd и\или snapfuse
это точно значит что snap заимается обновланием. а это нам нахер ненадо.
поэтому внутри lxd корнтенера надо выполнить

# apt-get purge -y snapd*
===

| LXDE

есть такая легкая граф оболочка.
она по дефолту стоит в lubuntu
но ее без проблем можно поставит на классический убунту.
	# apt install lxde

и еще надо если нет поставит такую хрень как
	# apt install  lightdm

далее вот что . когда мы загрузили комп. и у нас экран где мы указываем логин пароль.
там сверху справа надо логином юзера есть белый круг. мы на него тыкаем и там есть список
граф оболочек которцю надо загрузить. там выбираем LXDE. и вуаля. мы в нее загрузися.

еше есть такой прикол что кнопка logout когда мы в LXDE зашли в убунту 18 ( в лубунту с этим проблем нет)
неработает. как быть. закрываем все окна у текушего юзера. и перезагружаем службу lightdm

# systemctl restart lightdm

и мы попадем обратно в окно где надо вводить логин пароль. тоесть таким макаром мы как бы 
добьемся функции logout


далее.
как убрать сраный "update notifier"
надо зайти в /etc/xdg/autostart
и удалить файл upd-*
суки


далее. 
как добавить русскуб клаву. 
в лубунту там есть раздел клава в панели управления. если же мы запустили lxde в убунту18
то делать нужно совсем по другому.

права кнопка на панели задач - "add\remove panel items" - add - "keyboard layout hadler" - ...
дальше уже понятно



===
| AC
| power
| battery

утилита для мониторинга уровня заряда мышки, аккумулятора

список устройств с аккумуляторами
$ upower -e
/org/freedesktop/UPower/devices/line_power_ADP0
/org/freedesktop/UPower/devices/battery_BAT0
/org/freedesktop/UPower/devices/mouse_hidpp_battery_3
/org/freedesktop/UPower/devices/DisplayDevice



$ upower -i /org/freedesktop/UPower/devices/battery_BAT0
  native-path:          BAT0
  vendor:               LGC
  model:                L18L3PF1
  serial:               2267
  power supply:         yes
  updated:              Вс 17 сен 2023 19:53:21 (24 seconds ago)
  has history:          yes
  has statistics:       yes
  battery
    present:             yes
    rechargeable:        yes
    state:               fully-charged
    warning-level:       none
    energy:              35,5 Wh
    energy-empty:        0 Wh
    energy-full:         37,07 Wh
    energy-full-design:  36 Wh
    energy-rate:         0,00280338 W
    voltage:             12,381 V
    percentage:          95%
    capacity:            100%
    technology:          lithium-polymer
    icon-name:          'battery-full-charged-symbolic'


$ upower -i /org/freedesktop/UPower/devices/line_power_ADP0
  native-path:          ADP0
  power supply:         yes
  updated:              Вс 17 сен 2023 18:03:20 (6649 seconds ago)
  has history:          no
  has statistics:       no
  line-power
    warning-level:       none
    online:              yes
    icon-name:          'ac-adapter-symbolic'


$ upower -i            /org/freedesktop/UPower/devices/mouse_hidpp_battery_3
  native-path:          hidpp_battery_3
  model:                Wireless Mouse M315/M235
  serial:               4009-b9-50-a6-d3
  power supply:         no
  updated:              Вс 17 сен 2023 19:52:52 (95 seconds ago)
  has history:          yes
  has statistics:       yes
  mouse
    present:             yes
    rechargeable:        yes
    state:               discharging
    warning-level:       none
    battery-level:       normal
    percentage:          55%
    icon-name:          'battery-good-symbolic'





$ upower -i           /org/freedesktop/UPower/devices/DisplayDevice
  power supply:         yes
  updated:              Вс 17 сен 2023 19:51:21 (201 seconds ago)
  has history:          no
  has statistics:       no
  battery
    present:             yes
    state:               fully-charged
    warning-level:       none
    energy:              35,5 Wh
    energy-full:         37,07 Wh
    energy-rate:         0,00280338 W
    percentage:          95%
    icon-name:          'battery-full-charged-symbolic'


| youtube

альтернативный плеер ютуба.

https://freetubeapp.io/#download
там есть бинарник для убунту



===

| cpu
| hyper-threading

статья = https://www.baeldung.com/linux/disable-hyperthreading


можно посмотеть через lscpu что у нас с гипертрейдингом.

а еще можно проверить что HT активировано вот так

# cat /sys/devices/system/cpu/smt/active
1

если 1 то гипертрединг актиирован


далее смотрим вот такое
$ grep -H . /sys/devices/system/cpu/cpu*/topology/thread_siblings_list 
/sys/devices/system/cpu/cpu0/topology/thread_siblings_list:0-1
/sys/devices/system/cpu/cpu1/topology/thread_siblings_list:0-1
/sys/devices/system/cpu/cpu2/topology/thread_siblings_list:2-3
/sys/devices/system/cpu/cpu3/topology/thread_siblings_list:2-3

отсюда мы видим записи вида 0-1 это значит что  cpu0 это реальное ядро. 
а  cpu1 это гипетредингвое ядро.
таким макаром мы понимаем что ядра 1 и 3 это фиктивные гипетрединговые ядра.

так вот щас мы будем их выключать налету.

# echo 0 | sudo tee /sys/devices/system/cpu/cpu1/online
# echo 0 | sudo tee /sys/devices/system/cpu/cpu3/online

после этого в top исчезнут гипертрединовые ядра.
ура


статья пишет что отключать их онлайн неочень желаттельно.
а включать обратно их онлайн типа категорически ненадо.

| 5GHz

обнаружил такой прикол. 
конекчусь к вай фай точке через 5GHz и имею 50% потери пакетов даже в рамках локалки
котрую обеспечивает эта точка.

конекчусь через эту точку по частоте 2GHz и все окей.


==



| opera
ее установка в ubuntu
я изрядно поебался с этим.

если ставить из snap то при запуске вылезает ошибка на экране вида уже не помню какого
а если при этом посмотреть journalctl -f 
то мы увидим ошибку :
	snap Failed to add PIDs to scope's control group Permission denied

я нашел пост что это изза корявого snap
цитирую 
(https://serverfault.com/questions/478946/how-can-i-create-and-use-linux-cgroups-as-a-non-root-user)

If you have recent enough Linux distribution you should be able to run processes in transient (temporary) cgroups, e.g.

$ systemd-run --user --scope /bin/bash
However, systemd is broken in many Linux distributions Ubuntu versions prior 21.10 and that fails with something like

systemd[2601]: run-rbe547d13ad2c41d7857ea9e660e51ab9.scope: Failed to add PIDs to scope's control group: Permission denied

The reason for this failure is that running transient cgroups without root requires support for cgroupv2 but Canonical really wants to push snap and using cgroupv2 would have broken snap until the snap had been patch enough. Ubuntu 21.10 is the first Ubuntu release that has smart enough snap to work with cgroupv2 so any older Ubuntu version is intentionally broken for transient cgroups to allow snap to run at all.

I guess distributions that do not even try to support the misfeature called snap will have much less problems supporting cgroupv2 and this should work with older distribution versions, too.

поэтому опера из snap на ubuntu 18 неработает.

если ее ставить из пакетов то надо найти такую версию которая при установке не будет 
ругаться что ей не хватает установленных зависимостей
для ubuntu 18 это версия https://download3.operacdn.com/ftp/pub/opera/desktop/90.0.4480.80/linux/

когда наконец мы ее поставили из пакета то еще один прикол - ютуб видео работают а 
видео с сайтов где кино нет. это потому что нужно в убунту поставить пакет с кодеками.
ставится оно так :
(https://gist.github.com/mkaraki/684cd27d6e09c19f986de03f63a55b5c)
	# sudo apt-get update
	# sudo apt-get install -y chromium-codecs-ffmpeg-extra
  # Import to opera
	# sudo ln -sf /usr/lib/chromium-browser/libffmpeg.so /usr/lib/x86_64-linux-gnu/opera/libffmpeg.so

это просто пиздец.
потом заходим на сайт = https://html5test.com/
и смотрим указано ли там что наш браузер теперь поддерживает H.264
если да. то сайты с кино должны заработать.

опера это пиздец. установка.


| laptop
| sn
| serial number

как узнать серийный номер ноутбука

# dmidecode



===
| tlp

дока - https://linrunner.de/tlp/usage/index.html

установка в уунту

# apt-get install tlp

проверка что tlp арботает
# tlp-stat -s
...
State          = enabled



===

| ip
| proc

как узнать ip на компе неимея команды ip 
используя только proc


# cat /proc/net/fib_trie

===
| apt-get update

вылвзииит ошибка

E: dpkg was interrupted, you must manually run 'sudo dpkg --configure -a' to correct the problem. 


решение
dpkg --configure -a


===

| terminal
| controlling terminal
| sigHUP

основной вопрос чем отличается sigterm от sighup
для этого надопонять в какой ситуации  у нас возникают эти сигналы.


навскидку sigerm это сигнал который шлет юзерский процесс другому процессу (через сисколл ествесттвенно) для того чтобы завершить тот другой процесс в штатном режиме. также
этот сигнал может послать и кусок ядра.

sighup шлется процессу когда ядро считает что  потеряна связь с его controlling terminal.
вначале я опишу все по простому. у нас в линуксе открыт терминал (черный экран) у него
в /dev есть соотсвстующий ему файл tty или pts.
узнать это можно вот так

$ tty
/dev/pts/68


далее мы в терминале  запускаем команду. эта команда будет в своих своствах 
иметь тот же самый терминал. этот терминал для нее назыается контрольным терминалом.
наскольк я понял в свойствах процесса может быть указан либо контрольный терминал
либо никакого терминала. терминала который бы был неконтрольным и был в своствах 
процесса такого терминала нет. итак в свойствах процесса либо есть терминал либо совсем
нет. если терминал есть то это контрглнеый термианал.

как узнать есть ли у прцоесса терминал контроьный или его нет и его номер

$ ps -p 579207
    PID TTY          TIME CMD
 579207 pts/66   00:00:00 sleep

команда ps когда покаызает свойства процесса то в столце "TTY" укаызает наличие 
контрольного терминала у процесса и его номер.


так вот самое главное - если мы черное окно терминала закроем то ( тут я точно незнаю)
то ли сам терминал пошлет все процессам которые были в его окне запущены сигнал SIGHUP
либо само ядро при уничтожении терминала пошлет все процессам SIGHUP сигнал.
таким оразрм в конечном итоге при закрытии окна терминала всем прцоессам которые были запущегны через окно этого терминала будет послан сигнал sighup. вот когда наступает
это событие. ну а дальше - sighup это сигнал который можно проигнорировать. поэтому 
если в процессе который был запузен в окне терминала стоит обработчик который может 
слать нахер этот сигнал то процесс будет продолжать работать. а если там нет кастомного
обработчика этого сигнала то  будет исползоваться дефолтовый ядерный обраблочткичик этого 
сигнала который будет уничтожать этот процесс. таким обоаом по дефолту  при поступлении
сигнала sighup в процесс этот процесс будет ядром уничтожен.

показают на примере.
открывают окно терминала. и в нем запускаю кучу башей

$ tty
/dev/pts/67

$ bash
$ bash
$ bash
$ bash
$ bash

$ ps aux | grep "pts/67"
vasya     579407  2.0  0.2  70532 45988 pts/67   Ss   05:15   0:00 bash
vasya     579421  1.1  0.2  70536 46040 pts/67   S    05:15   0:00 bash
vasya     579434  1.0  0.2  70536 46120 pts/67   S    05:15   0:00 bash
vasya     579447  1.3  0.2  70536 45852 pts/67   S    05:15   0:00 bash
vasya     579460  1.3  0.2  70536 45988 pts/67   S    05:15   0:00 bash
vasya     579480  1.3  0.2  70540 46032 pts/67   S    05:15   0:00 bash
vasya     579493  1.6  0.2  70540 46168 pts/67   S    05:15   0:00 bash

вот мы видим 7 процессов  укоторых контроный терминал pts/67

теперь  я закрывают окно терминала и по идее все эти бащ процессы будут уничтожены

$ ps aux | grep "pts/67"
пусто

значит все совпало. как только мы закрыли окно терминала pts/67
то все процессы у которых этот терминал был контршьным терминалом были уничтожены системой.
еще раз почему они были уничтжены - птому что к ним всем был направлен сигнал SIGHUP
и либо в баше стоит обрабочик который в ответ на этот сигнал просит ядро уничтожить
этот процесс либо был задействтвван дефолтовый ядерный обрабочик этого сигнала который
уничтожает этот проецесс.


нахуй этот SIGHUP нужен? а нужен он истоически вот для чего - это сейчас у нас терминал
это просто программа  с черным экраном раоботаюшая локально на нашем компе а раньше все было
иначе - раньше терминал это была  реальная железка с клавой и экраном и проводом serial к 
мейнфрейму. терминал не имеел ни памяти ни цпу он имел только клаву экран и  срведство связи 
с мейнфрейом на котором уже были цпу и память. так вот через терминал юзер запускал программы
на мейнфрейме. и если мейнфрейм считал что связь с терминалом потеряна то надо было уничтожить все те программмы которые были запущены  сэтого терминала. таким обоазом 
кажый процесс имел свойства с какого термиала он был запущен. и при падении связи между 
мейнфреймом и терминалом все эти проги дожны быть уничтожены. при падении связи с терминалом
какойто кусок ядра понимал что связт нет. и он слал все процессам принадлежащим этому терминалу сигнал SIGHUP. тогда шедулер когда доходил до таких процессов то он вместо того
чтобы их пихать на цпу их убивал. также как я понимаю когда человек заканчивать сессию
на терминале с мейфнфрейомм либо жал кнопку либо послыла команду на мейнфрейм о том что 
он заканиывает сессию что видим тоже слало сигнал SIGHUP. теперь я думаю все стало понятен 
смысл всей этой шарманки.

если мы запуакмаем из терминала пргармму и нехотим чтобы она была убита после того
как терминал буде закрыть то надо заюзать прогу nohup

пример

$ tty
/dev/pts/67
$ nohup sleep 200

$ ps aux | grep sleep
vasya     580035  0.0  0.0  14588   836 pts/67   S+   05:26   0:00 sleep 200

видим что наш процесс sleep 200 имеет в своих свойствах указанный коонтрьный терминал 
pts/67

закрыаем теперь окно терминала

проверяем была ли убита при этом программа

$ ps aux | grep sleep
vasya     580035  0.0  0.0  14588   836 ?        S    05:26   0:00 sleep 200

видим что небыла. прогармма продорлжает работать. а столбец который показыает 
номер контрщлного терминала для процесса стоит "?"


далее еще интереный момент - я всегда думал что если у процесса есть контрльный терминал
то это значит что в /proc/$PID/fd есть  файловые дескрипторы которые ведут 
в /dev/pts/67

однако оказалос что это не всегда так...
а именно
беерм запускаем процесс

$ sleep 600

$ ps aux | grep "sleep 600"
vasya     580496  0.0  0.0  14588   832 pts/73   S+   05:34   0:00 sleep 600

видим что у него контролный терминал это pts/73

идем в proc для этого процесса

$ ls -1al  /proc/580496/fd
total 0
dr-x------ 2 vasya vasya  0 июл 24 05:35 .
dr-xr-xr-x 9 vasya vasya  0 июл 24 05:35 ..
lrwx------ 1 vasya vasya 64 июл 24 05:36 0 -> /dev/pts/73
lrwx------ 1 vasya vasya 64 июл 24 05:36 1 -> /dev/pts/73
lrwx------ 1 vasya vasya 64 июл 24 05:36 2 -> /dev/pts/73

видим что да у процесса открыто три файла (0,1,2) все они ведут в терминал pts/73


а тепер посмтрим какая ситуация коггда мы запускаем комнду с nohup

$ nohup sleep 700
$ ps aux  |  grep "sleep 700"
vasya     580624  0.0  0.0  14588   832 pts/75   S+   05:37   0:00 sleep 700

видим что для процесса указано что у него в свойствах указан терминал pts/75
идем в proc и что мы там видим


$ ls -1al  /proc/580624/fd
total 0
dr-x------ 2 vasya vasya  0 июл 24 05:38 .
dr-xr-xr-x 9 vasya vasya  0 июл 24 05:38 ..
l-wx------ 1 vasya vasya 64 июл 24 05:38 0 -> /dev/null
l-wx------ 1 vasya vasya 64 июл 24 05:38 1 -> /home/vasya/nohup.out
l-wx------ 1 vasya vasya 64 июл 24 05:38 2 -> /home/vasya/nohup.out


мы видим что у нас открыто три файла (0,1,2) но ни один из них не ведет в терминал!!!

посморим что за файл nohup.out
$ stat /home/vasya/nohup.out 
  File: /home/vasya/nohup.out
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 24918099    Links: 1

видим что это "regular empty file"
тоесть это прям обычный файл физически лежащий на диске. 

таким образом я не очень понимаю связь этого процесса с терминалом.  дело в том 
что всегда утверждалось что если в свойствах прцоесса указано что у него есть
контрльный терминал то это мол всегда значит что процесс может читать с терминала (через его спец файл /dev/pts/75) либо писать на терминал

а тут мы видим что такой процесс не может ни читать с термиала ни писать на него 
потому что у него неоткрто устройство терминала.... да.. вот это непонятно...

===

| bench
| benchmark
| unixbench


из статьи на habr
 вылезла утилита для замера бенчмарка unixbench
есть только в виде снапов

# snap install unixbench

если у нас много ядер то надо запускать в много ядероом реижиме

# unixbench -c 4
где 4 это число ядер на компе об этом написано тут https://github.com/kdlucas/byte-unixbench/blob/master/UnixBench/USAGE

а тут написано что значит каждый тест https://github.com/kdlucas/byte-unixbench

в целом это бенчмарк связки цпу-память-ос

резульатты на лэптопе

------------------------------------------------------------------------
Benchmark Run: Fri Jul 28 2023 13:38:38 - 14:03:46
8 CPUs in system; running 4 parallel copies of tests

Dhrystone 2 using register variables       66298940.7 lps   (10.0 s, 7 samples)
Double-Precision Whetstone                    10849.2 MWIPS (9.8 s, 7 samples)
Execl Throughput                               6776.4 lps   (29.5 s, 2 samples)
File Copy 1024 bufsize 2000 maxblocks        707440.0 KBps  (30.0 s, 2 samples)
File Copy 256 bufsize 500 maxblocks          180685.6 KBps  (30.0 s, 2 samples)
File Copy 4096 bufsize 8000 maxblocks       1606002.7 KBps  (30.0 s, 2 samples)
Pipe Throughput                             2452775.6 lps   (10.0 s, 7 samples)
Pipe-based Context Switching                 212090.1 lps   (10.0 s, 7 samples)
Process Creation                              11992.4 lps   (30.0 s, 2 samples)
Shell Scripts (1 concurrent)                  18533.0 lpm   (60.0 s, 2 samples)
Shell Scripts (8 concurrent)                   2501.5 lpm   (60.0 s, 2 samples)
System Call Overhead                        2347375.8 lps   (10.0 s, 7 samples)

System Benchmarks Index Values               BASELINE       RESULT    INDEX
Dhrystone 2 using register variables         116700.0   66298940.7   5681.1
Double-Precision Whetstone                       55.0      10849.2   1972.6
Execl Throughput                                 43.0       6776.4   1575.9
File Copy 1024 bufsize 2000 maxblocks          3960.0     707440.0   1786.5
File Copy 256 bufsize 500 maxblocks            1655.0     180685.6   1091.8
File Copy 4096 bufsize 8000 maxblocks          5800.0    1606002.7   2769.0
Pipe Throughput                               12440.0    2452775.6   1971.7
Pipe-based Context Switching                   4000.0     212090.1    530.2
Process Creation                                126.0      11992.4    951.8
Shell Scripts (1 concurrent)                     42.4      18533.0   4371.0
Shell Scripts (8 concurrent)                      6.0       2501.5   4169.1
System Call Overhead                          15000.0    2347375.8   1564.9
                                                                   ========
System Benchmarks Index Score                                        1932.1

---------------

| grep 
пидец нахуй блядь.
вот что выяснил

вот у нас есть файл

$ cat 1.txt 
1
2
3


опция -C N покзаывает N строчек сверху и снизу от найденной строки . тоест

$ grep -C1 "2" 1.txt
1
2
3

так вот пиздец в том что можно убрать "C" и оставти толко "-1"
пример

$ grep -1 "2" 1.txt
1
2
3

ниге ни в man нни в info я об этом ненашел. суки блядь ебаные.

дале ключи -r и -R в чем разница. вроде как в том что -r неследует симлинкам а -R следует.

таким оюоразом

# grep -r2 "vasya"  = grep -r -C 2 "vasya"


====

| passwd
| shadow
| пароли

известно что пароль юзера хранится в /etc/shadow
но там не все так просто,
дело в том что оказывается используется целая серия спец техник чтобы сделать задачу 
вычисления пароля хрен какой сложной.
поэтому прежде чем лезть в /etc/shadow отойдем в сторону:
самая простая техника хранитть пароль на компе так чтобы его затруднить взломать это хэширование его.
хэш эта такая функция f(A)=B где A это пароль а B это хэш. фишка в том что природа это функции такова 
что зная A можно относительно быстро вычислить B. тоесть зная пароль мы быстро узнаем для него хэш.
так вот природа функции такова что типа нет возможности составить обратную функцию которая бы нам позволила
зная зная B хэш вычислить пароль A.
таким макаром мы можем на компе хранить пароли в виде хэша. если ктото узнает хэши то он не может 
составить алгориттм чтобы на основе этих хешей узнать пароли. таким образом наличие хэшей 
у  злодея не дает ему возможность вычислить пароли. в тоже время когда юзер с клавы вводит парольь то ядро
вычисляет по нему хэш и сранивает с хешем что хранится в файле. если хеши совпали значит юзер ввел
верный пароль. таким образом хеш позволяет системе быстро понять ввел ли юзер верный пароль и при этом 
сам пароль не хранится на компе. и если злодей завладел хешами это ему не дает ничего. почти ничего.
дело в том что злодей имея хеши с нашего компа может сделать вот что. он выбирает длинну пароля.
потом он берет первый рандомный пароль вычисляет от него хеш и сравнивает с хещем из файла. если хеши
совпали то пароль найден. посокольку хеш вычисляется относительно быстро и поскольку юзеры часто придумывают
короткий и простой пароль то методом перебора можно подобрать пароль очень даже быстро. если юзер использует 
длинный пароль и в котором еще всякие спецсимволы тогда методом перебора злодей хрен подберет пароль.
таким образом сам алгоритм хеша очень надежный и напрямую вычислить по нему исходный пароль невозможно
но если пароль короткий и простой то его можно подобрать методом перебора очень быстро. это похоже 
как бутто мы имеем сейф. на нем три ручки. сам сейф хрен взломаешь. но если мы выбрали что сейф должен быть 
открыт если мы покрутили ручки три раза то подобрать пароль методом тыка будет быстро. а если мы выбрали 
что сейф может быть открыт если покрутть сейф 250 раз то методом тыка хрен подберешь пароль.
значит в итоге становится ясно что сложность "взлома" пароля при хешировании зависит от двух моментов.
во первых от сложности найти обратный алгоритм для функции хеширования и во вторых от того насколько 
длинный и сложный пароль будет использован. с первым моментом все понятно оно очень надежно. 
а вот со вторым моментом все хуже. юзер всегда хочет придумать короткий и просто пароль.
значит надо как то исправить. 

и тут на помощь приходит первая спец техника = key stretching или password stretching.
эта хрень берет пароль юзера и его модифицирует так что он становится значительно длиннее 
и сложнее. работает на практике это например так (https://en.wikipedia.org/wiki/Key_stretching)
мы берем пароль юзера и вычисляем от него хеш . и этот хеш как бы становится новым паролем.
поскольку хеш по своей длинне это длинная хрень. всегда длинная хрень. скажем 256 байт или 512 байт
длинной. тоесть мы берем пароль длинной 3 байта. вычисляем от него хеш. получаем хрень длинной 
256,512 байт. получается новый "пароль" гораздо длиннее и сложнее. теперь имея такой "новый пароль"
мы вычисляем от него хеш и сохраняем его в файле. так написано в вики. правда тут этот механизм
по факту все таки не приводит по мне к удлиннению пароля.  потому что с точки зрения подбора пароля
через механизм перебора все стало лишь слегка труднее а не значительно труднее. злодей теперь
доллжен всего навсего взять предполагаемый пароль и вычислить от него хеш но не один раз а два раза.
поэтому я не согласен что такой механизм как бы нам удлинняет длинуу пароля. это хрень собачья.
единственное что этот механизм зотрудняет подбор пароля через перебор но с другого бока а именно. 
если возьмем пароль юзера и вычислим от него хеш скажем 100 000 раз и потом запишем финалный хеш 
в файл то злодей должен будет когда перебирать пароли то вычислять для каждого кандидата хеш 100 000 раз.
проверим насколлько быстро может современный цпу высчитать хеш 10 000 раз 

    $ i=1; time ( while [ $i -le 10000 ]; do let "i+=1";  echo 1 | sha256sum >/dev/null; done )

оказалось что это занимает 62 секунды.
получается что если мы возьмем пароль из клавы  потом высчитаем от него хеш 10000 раз 
и запишем финальный хеш в /etc/shadow то чтобы система могла проверить правильный ли пароль ввел 
юзер ей придется тоже вычислить хеш 10 000 раз. и проверить вычисленный хеш с тем что  в файле. 
и это займет 1 минуту. тоесть юзер будет ждать входа в систему 1 минуту. это минус.
но зато злодей который захочет подобрать пароль по хешу должен будет при переборе  для каждого
кандидата пароля высчитывать 10 000 хешей и ждать 62с. а это очень долго. получается что скажем
на 1 ядерном процессоре он за сутки сможет перебрать только 1 440  кандидатов под пароль. 
а за пол года можно перебрать 259 200 штук
если мы используем для пароля символы ASCII который 127 штук то таким макаром за пол года нельзя
будет перебрать все варианты для пароля длинной даже 3 символа. тоесть
    $ echo "127^1" | bc
    127
    $ echo "127^2" | bc
    16129
    $ echo "127^3" | bc
    2 048 383

таким макаром если мы согласимся терпеть что при входе юзера система должна будет считать 10 000 хешей чтобы проверить верность пароля и и юзер должен ждать 1 минуту то грубо говоря юзер может иметь пароль всего 4 символа и его нихрена нельзя будет подобрать даже за полгода на одноядерном цпу.
если же юзер будет иметь пароль длинной 8 символов то сложность подбора (время подбора ) его пароля возрастет в 127*127*127 ~ 1 000 000 раз. 
неплохо. 
последнее что хочу сказать про key strengthen (password strengthen) это то что по мне как обычно
выбрано очень хуевая терминология для данной технологии. с паролем ничего не стренгсится. усложняется
по времени алгоритм проверки коректности пароля. тоесть
    вводим пароль ---> алгоритм проверки = время
чем более трудоемкий по времени процесс проверки коректности введенного пароля
тем сложнее его подобрать брут форсом. 
тоест в статье в википедии говорится о том что якобы эта техника "удлинняет" длинну пароля. 
и из за этого его подобрать сложнее. по мне такое обьяснение полнаяхуйня.
пароль не удлинняется. а увеличивается по времени алгоритм проверки коректности введенного пароля.
это и приводит к тому что подобрать пароль путем перебора становится по времени гораздо дольше.
рассмотрю более реальный пример для практики в том смысле что ждать 62 секунды для проверки
коректности это очень долго поэтому рассмотрю вариант когда мы снижаем число хешей  с 10 000 до 1 000
тогда время проверки сокрашается до 2.6с это время юзер уже может подождать при входе в систему.
при таком алгоритме злодей методом перебора может перебрать 
тогда за 1 минуту брутфорсом можно перебрать 23 пароля.
значит за полгода можжно перебрать вариантов паролей
    $ echo "60*24*30*6*23" | bc
    5 961 600

если мы используем для пароля символы ASCII которых 127 штук то пароль длинной 3 символа
имеет вариантов
    $ echo "127^3" | bc
    2 048 383
значит за полгода можно подобрать пароль только если он состоит из 3 символов по длинне.
ну и чуть чуть перебрать варианты паролей длинной 4 символа.
но в целом за полгода можно будет сломать только пароль длинной всего 3 символа длинной.
таким макаром я думаю я закончил над темой "key strengthen"

таким макаром на данный момент с точки зрения как нам сохранять пароль на компе 
мы пока что приходим к схеме условно такого вида. мы берем пароль , вычисляем от него хеш 
скажем на основе sha-256 одну тысячу раз и записываем этот хещ в /etc/shadow
и это нам как бы дает такую штуку что подобрать пароль длинной даже 4 символа нельза на 
компе через перебор даже за пол года.
но тут выходит на сцену другой способ  поиска пароля - через заранее высчитанные хеши. 
то есть мы берем 1 000 компьютеров. и начинаем на каждом брать варианты пароля , высчитывать от него
1 000 хешей и суммарный хеш записывать  в базу данных. таким макаром посчитав один раз все варианты
хещей для паролей скажем 8 символов мы будем иметь таблицу. и тогда посчитав такую таблицу один раз
мы потом просто будем брать хеш из /etc/shadow и искать этот хеш  в нашей таблице.
и тут нам в спасение приходит следущая техника

техника salt
техника состоит в том что мы берем пароль юзера из клавиатуры и добавляем к нему некоторый дополни
тельный хвост. хвост можно брать либо на основе имени юзера либо некий рандомный 
например исходный пароль "12df" мы  к нему добавляем salt "rf45@4ff"
таким образом новый пароль "12dfrf45@4ff"
а далее действуем по ранее описанному алгоритму вычисляем для этого пароля 1000 хешей.
это нам дает то что теперь наша заранее высчитанная таблица хешей для некоторого множества паролей
стала теперь неактуальной. нам надо брать и высчитывать эту таблицу заново. поскольку таблица 
высчитывалась из расчета того что ее можно многократно использовать для поиска не только одного пароля
а для поиска разных паролей тоесть чтобы одну заранее высчитанную таблицу можно было использовать 
много раз неоднократно теперь это не возможно потому что если для двух паролей испольуется два разных
salt то это делает таблицу хешей высчитанную для одного salt бесполезной для поиска пароля 
который юзает другой salt. таким образом злодей в случае использования salt вынужден будет для
подбора пароля вернуться в предыдущему методу - методу перебора.

таким образом я обсудил две техники "key strengthen" и "salt"
теперь для записи пароля в /etc/shadow мы делаем вот что:
мы берем пароль, потом мы к нему добавляем рандомный salt, потом мы от этого высчитываем 1000 хешей
и  записываем этот хеш в /etc/shadow

как вычислить sha-256 хеш:
    $ echo -n password123 | openssl dgst -sha256
    (stdin)= ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f
либо
    $ echo -n password123 | sha256sum 
    ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f  -


дальше перехожу уже к линуксу на практике. как он хранит пароли и как он 
проверяет верность пароля когда юзер его ввел.
пароли хрантся в /etc/shadow
описание поле смотрим в 
    $ man shadow
а именно
запись имеет несколько полей. поля разделяются двоеточиями ":"
пример записи для юзера vasya2
    $ sudo cat /etc/shadow |  grep vasya2:
я разделил поля с двоеточиями доп пробелами

vasya2 : $6$BbSw9Q10$L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh. : 19430 : 0 : 99999 : 7 :::

первое поле это тип хэша,
второе поле это пароль. точнее это достаточно сложная хрень

$6$BbSw9Q10$L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh.

поля внутри этой хрени разделяются через знак доллара "$"
я добавил доп пробелы чтобы показать поля внутри пароля

$ 6 $ BbSw9Q10 $ L7rsn5B3kJunuyX8q0L10T0ms2/8mnTEExhfKJ7DbCWf/RN.FWlgLDUwBKWp6Xp1l0DHh/o6jv38j1jYPHvhh.

первое поле  в данном случае "6" показыает тип хэша 
виды хэшей. виды хэшей можно посмтреть через 
    $ man openssl-passwd

там видим

  -crypt
           Use the crypt algorithm (default).

  -1  Use the MD5 based BSD password algorithm 1.

  -apr1
           Use the apr1 algorithm (Apache variant of the BSD algorithm).

  -aixmd5
           Use the AIX MD5 algorithm (AIX variant of the BSD algorithm).

  -5
  -6  Use the SHA256 / SHA512 based algorithms defined by Ulrich Drepper.  See <https://www.akkadia.org/drepper/SHA-crypt.txt>.



итак -6 это SHA512

как я понял никак нельзя указать линуксу какой иенно хэш алгоритм юзать. 
он всегда юзает -6 при запист пароля в /etc/shadow если мы юзаем 
    $ passwd vasya2
хотя все таки можно заюзать другой хеш если мы сформируем строчку в /etc/shadow
вручную. (об этом гораздо далее смотри ниже)

второе поле это так называемый "salt"
в данном случае он равен "BbSw9Q10"
гениально. возникает вопрос а откуда взялся salt ведь мы при генерации проля в линуксе
никакой salt неуказыаем. ответ - как я понимаю линукс сам автоматом генерирует salt.
вобщем то удобно. 
salt указан в открытом виде.
проверим теорию с практикой. изменим паролоь для vasya2 на "temp"
    # passwd vasya2

получаем

vasya2:$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0:19568:0:99999:7:::

тогда мы имеем 
$ 6 $ CWvpCyfP $ owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0

значит алгоритм хэширование 6 тоесть SHA512
salt = CWvpCyfP
пароль мы знаем "temp"

сгенеририуем "руками" теперь хэш учитывася все эти данные и проверим получим 
ли мы такой же хэш как в shadow

$ openssl passwd -6 -salt CWvpCyfP temp
$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0


сравниваем с тем что в shadow
$6$CWvpCyfP$owv29lni2vdWIawiMlcMxOxemXSz/IrdNd.vIdD0lgT5wz1JusTk4n3o2wLOhwua055qm1lTKSQFySSQEE1iz0

полное совпдание! теория совпала с праткикой!

кстати прикол что команда выглядит как 
$ openssl passwd
а ман у нее выглядит как
$ man openssl-passwd 

вобще меня на тему shadow навеля это супер статья https://tbhaxor.com/linux-file-permissions/

сравним как выглядит хэш для разных алгоритмов хэша

$ openssl  passwd -crypt temp
lEMHJ3vYIIqsE

$ openssl  passwd -crypt  temp
nKMXOc5hv9SPQ

видно что пароль один и тотже  а хэш разный. видимо он в себя включает 
и salt котоырй автоматом генерируется

$ openssl  passwd -1 temp
$1$UktQ/3s9$a/n2XHoslh.6hwApLdvtV0

$ openssl  passwd -apr1  temp
$apr1$yefESuP3$.W8joK2N12pRHrwHQULKN/

$ openssl  passwd -aixmd5  temp
whIbFfIj$Taivy0xyFOh9ps8Z2dKab.

видно что все три алогритма юзают автосгененирровынный salt (второй столбик с раздели
телем $)


$ openssl  passwd -5  temp
$5$doWL/NwAisNd2cwS$Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3

$ openssl  passwd -6  temp
$6$QEe4qtY9ShP6jVnR$RIzSSyJx0VvrAVjK/6fj.co5fFnapX50ZVaJXNr75Ah0GNWO.rmSr5j76xEuAEQHc6OaQPTSuSEgSFOUKlHY31

в последнем сслучае salt=QEe4qtY9ShP6jVnR
сегенерируем хэш тип 6 

$ openssl  passwd -6 -salt QEe4qtY9ShP6jVnR temp
$6$QEe4qtY9ShP6jVnR$RIzSSyJx0VvrAVjK/6fj.co5fFnapX50ZVaJXNr75Ah0GNWO.rmSr5j76xEuAEQHc6OaQPTSuSEgSFOUKlHY31

видно что совпало. мы верно определили salt

итак на первый взгляд вроде бы мы разгадали что значит строка в /etc/shadow
однако это нихуя не так.
дело в том что - вот возьмем строку вида
$ openssl  passwd -5  temp
$5$doWL/NwAisNd2cwS$Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3

пароль = temp
5 - значит sha-256
salt = doWL/NwAisNd2cwS
хэш  = Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3

так вот если мы возьмем пароль "temp" прилепим к нему salt 
и потом вычислим от него sha-256 то мы нихуя не получим то что стоит в поле хеш.
а все потому что команда "openssl password ..." и команда "passwd .." они используют
системную библиотеку crypt(3) так вот она невычисляет хеш однократно. нет.
согласно 
    $ man 3 crypt
цитирую
Since glibc 2.7, the SHA-256 and SHA-512 implementations support a user-supplied number of hashing rounds, defaulting to 5000.

тоесть эта функция вычисляет хеш 5000 раз. 
поэтому если мы хотим проверить хеш руками то нам надо его вычислить 5000 раз.
я этим займусь но чуть ниже потому что 
есть еще один прикол состоит в том что хеш-256 эта хрень должна иметь по определению 256 байт
но если мы помотрим на хеш
    Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3
то мы легко увидим что его длинна всего 43 байта
    $ echo "Igh7f5Z/IIfnPDoNt3.ulvP5AmFA0gpEdTH8Zy6nwI3" | awk '{print length }'
    43

что за хуйня? оказывается дело вот в чем. нам нужно хеш засунуть в файл текстовый. но 
сам алгоритм хеш sha-256 он сформирует последовательность из 256 байт но прикол в том 
что далеко некаждый байт в этой последовательности является печатным\текстовым согласно ASCII
кодировки а это типа хреново потому что /etc/shadow имеет вид текстового файла по своему формату. поэтому после того как получен чистый хещ sha-256 происходит дополнительная хрень --> хеш транформируется в чистый 
текст но и тут подьбека перекодирование в текст идет не через base64 а через такую хуйню как radix64.
итак еще раз когда мы запускаем команду passwd то она вызывает glibc функцию crypt
которая берет пароль, придумывает для него рандомный salt. потом она вычисляет хеш 5000 раз.
обычно это хеш sha-512 и в конце этого она преобразует этот хеш в чистый текст через radix64.
и вот то что получается уже запсывается в /etc/shadow

значит два следущих шага которые надо сделать
1) получить чистый хеш sha-256\512 и руками его трансформировать в radix64
2) руками вычислить хеш 5000 раз
3) полностью руками сформировать строку в /etc/shadow для юзера vasya2 и пароль temp


разбираю "1)".
разбираюсь что такое кодировка radix64.
согласно этой статье 
    https://medium.com/swlh/base64-encoding-algorithm-42abb929087d
утверждается что слово radix означает основание системы счисления. тоеть бинарное счисление
это radix-2. (цифры 0 и 1). а система счисления radix-10 это 0..9
а radix-64 это счисление на основе символов в размере 64 штуки. (0..63).
я правда не понял навскидку символы обязательено цифры или нетолько.
из этой же сттатьи утверждаетс что radix64 и base64 это одно и тоже.
статью я только начал читать но не дочитал.
зато я нашел нечто более короткое по теме. 
    https://superuser.com/questions/1629013/what-kind-of-encoding-is-this-sha256-variant
во первых sha-256 дает не 256 байт на выходе а 256 бит то есть 32 байта.
также sha-512 дает на выходе 64 байта
итак sha-256 выдает  на выходе поток байтов длинной 32 байта.
пример
    $ echo -n "1" | sha256sum  | awk '{print $1}'
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b

значит то что мы получили на выходе команды sha256sum это поток байтов длинной 32 байта
расписанный в текстовом виде в hex формате
важно осознать что я только что описал
на выходе получаем поток байтов в размере 32 штук, но так как эти байты нужно как то 
перевести в печатные символы. дело в том что брать байты и тупо пытаться их отрисовать на экране
через ASCII или UTF кодировку для них не выход. они берут байтовый поток и конвертируют его 
в печатные символы в hex виде. тоесть вот мы видим на экране 
    6b....
мы видим печатные символы которые по факту отображают поток байтов который на основе
кодировки ASCII\UTF (для первых 127 символов ASCII кодировка совпадает с UTF-8 которая по факту
используется в линуксе поэтому мы можем спокойоно работать с ASCII кодировкой вместо UTF) был преобразован 
терминалом в печатные символы. таким макаром выполним обратное преобразование из печатных символов
в байтовый поток.
ASCII:
    6 = 36(hex)
    b = 62(hex)

таким макаром печатные символы на экране 6b соотвествуют потоку байтов 3662
действительно проверим это 
    $ echo -n "6b" | od -t x1
    36 62

так вот я так долго описывал эту шнягу чтобы сказать что на самом деле преобразоывать печатные
символы в поток байтов ненужно! потому что sha256sum уже показывает 
чистый байтовый поток причем да через печатные символы но в hex формате.
тоесть 
вот мы видим
    $ echo -n "1" | sha256sum  | awk '{print $1}'
    6b...
это значит что перый байт в байт потоке 6b(hex) тоесть печатные символы 6b ненужно преобразовывать 
в байты через ascii кодировку. 6b это уже и есть первый байт потока 6b(hex)
итак 
    $ echo -n "1" | sha256sum | awk '{print $1}'
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b
нам уже сразу показывает какой истинный хеш (поток байтов)

тогда я нихуя не понимаю почему статьи до этого писали что sha256sum вычисляет хеш.
получает байтовый поток и потом его перекодирует в текстовые символы через кодировку radix-64
которая по одной статье это ничто иное как base64 кодировка а по другой статье это некая 
другая кодировка. пиздец. кстати hex формат это base16 кодировка. ебаааать.

ладно. теперь надо понять как нам вычислить хеш от хеша.
для начала
    $ echo -n "1" | sha256sum -t
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b  -
    $ echo -n "1" | sha256sum 
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b  -

из чего следует что по дефолту sha256sum  работает в текстовом режиме. так и написано в
man
далее
    $ echo -n "1" | sha256sum -b
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b *-

видно что мы получили тот же хеш хотя мы вычисляем в бинарном режиме.
что за пизец. вчем разница текствго режима и бинарного? оказывается в линуксе разницы нихуя никакой.
(https://stackoverflow.com/questions/17988090/what-are-the-differences-between-md5-binary-mode-and-text-mode)

в итоге мы забываем про эту хуйню текстовый режиме, бинарный режиме. разницы нкиакой.
по факту число "1" это 31(hex) байт который летит в sha256sum
и тот вычисляет хеш от этого байт потока

    $ echo -ne "\x31"
    1
 
    $ echo -ne "\x31" | sha256sum
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b *-
 
как видно хеш тот же самый.
тоесть еще раз хеш вычисляется не от числа "1" нет. это печатный символ который 
на основе ascii представляет собой байт 31(hex) и именно от этого байта вычисляется хеш.

теперь кода мы поняли от чего вычисляется хеш и что мы получаем на выходе то для
того чтобы посчитать новый хеш от первго хеша у нас проблема.
потому что нам нужно полученный base16 хеш
    6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b *-
преобразоывать в bin хеш ( в поток байтов ) и только после этого его можно направлять на sha256sum
если же мы просто напросто направим   6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b 
в sha256sum то получим не то что надо . потому что мы направим не поток байтов нужных нам 
а поток ascii символов у которых байтовый поток их кодирующий совершенно другой.
и я нашел для этого команду

$ echo -n  "6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b" | xxd -r -p | od -t x1
0000000 6b 86 b2 73 ff 34 fc e1 9d 6b 80 4e ff 5a 3f 57
0000020 47 ad a4 ea a2 2f 1d 49 c0 1e 52 dd b7 87 5b 4b
0000040

видно что символы превратились  в нужный поток байтов

в итоге вот команда которая вычисляет хеш от хеша потока байтов 31h (символ "1")

$  echo -n  "$(echo -n "1" | sha256sum| awk '{print $1}' )" | xxd -r -p | sha256sum | awk '{print $1}'
9c2e4d8fe97d881430de4e754b4205b9c27ce96715231cffc4337340cb110280

awk нужен потому что sha256sum выдает падла не только хеш но некую хрень во втором столбце
которая нам нахен ненужна. поэтому ее нужно отрезать.

таким образом radix64 отвалился сам собой ибо sha256sum вообще его нахен неиспользует.
и пункт "1)" я выполнил.

что касается пункта "2)" то хеш от хеша я вычислил. 
теперь остается написать программу которая вычислить хеш от хеша 5000 раз.
этим сейчас и замемсся

итак я написал такой скрипт

$ cat 1.bash 
#!/bin/bash
			    # переменные
p="temp"       # password
n=10000        # число хешей
salt="jwAMQACK"


			    # тело скрипта
echo "пароль = $p"
echo "salt = $salt"
sp=$salt$p
echo "salt\пароль = $sp"
echo "макс число хешей = $n"
start=$(date +%s)  		# начало выполнения скрипта
echo "salt\пароль в hex = $(echo $sp | xxd -p)"

h1=$( echo -n "$sp" | xxd -p ) 	# конвертируем пароль в base16 (hex) формат
for i in $(seq 1 1 $n)
do
  h2=$( echo -n "$h1" | xxd -r -p | sha512sum | awk '{print $1}'  )
  h1=$h2
echo -ne "текущий хеш $i-ый  = $h2 \r"

c1=$( echo -n $h1 | cut -b 1-4 )
if [ "$c1" = "9263" ];then echo "gotcha!";break;fi

done
echo ""
end=$(date +%s)
echo "Время выполнения скрипта: $(($end-$start)) секунд"


его вывод на  экран

$ ./1.bash 
пароль = temp
salt = jwAMQACK
salt\пароль = jwAMQACKtemp
макс число хешей = 10000
salt\пароль в hex = 6a77414d5141434b74656d700a
текущий хеш 271-ый  = 2f752fcba2c5d118016dbdf0214599ffa977ab73227e1dd215b5052689aed9c235e7d8c3c221ccc8e3cd548928a147f9a38f39327d5eb91ca9950ecdef9030cd 
Время выполнения скрипта: 10 секунд


далее я хотел бы перейти к /etc/shadow
по идее остается добавить salt к скрипту и попоробовать воспроизвести работу библиотеки crypt(3)
но перед этим посмотрим на 

    $ openssl passwd -5 -salt CWvpCyfP 1
    $5$CWvpCyfP$vqBpX.PqU0cw/1GbfU0s.brWw7a8kMEk8c/4zPIvRv3

мы видим в нем хеш 
    vqBpX.PqU0cw/1GbfU0s.brWw7a8kMEk8c/4zPIvRv3

и тут очевидно что мы видим что наш хеш показан точно не в формате base-16
это либо base64 или чтото ему подобное.

тут я расскажу что такое base64 кодирование. хорошо описано тут - (https://superuser.com/questions/1629013/what-kind-of-encoding-is-this-sha256-variant)
работает это так. берется поток байтов где байт это 8-бит в виде битов. потом этот поток разбивается на куски 
по 6 бит. а далее каждый каждый такой 6-битный блок заменяется на символ ASCII.
но используются не все символы ascii а только часть а именно
используются вот такие символы ASCII "A-Z a-z 0-9 + /"
а правило замены такое

0 заменяется на A
1 заменяется на B
...
...
62 заменяется на +
63 заменяется на /

поскольку 6 бит это числа от 0 до 63 то и получается что используется 64 символа ASCII

после замены каждого 6 бит исходного байто потока на некоторый символ ASCII .Что значит 
замена на символ ASCII - это значит что исходные 6 бит заменяются на 1 байт (8бит)
который выбирается исходя из ascii таблицы.

например исходные 6бит 000000 (тоесть 0dec) заменяется на A то есть на 41h (для "A" в ascci
соотвествует байт 41h). тоесть в байт потоке было 000000 стало 41h (8bit)
получается исходный байт поток преобразуется вдругой байт поток по размеру больше на 8\6 
тоесть конечный поток будет больше на 33%. тоесть еще раз вот мы имеем исходный поток байтов

0h 0h 0h => трансформируем его вбиты и группируем по 6 бит => 
=> 0000 0000  0000 0000  0000 0000  => 0000 00|00  0000| 0000  00|00 0000| 
потом по таблице меняем кажду группу из 6бит на байт согласно таблице замены на ascii символ.
тоесть
0 заменяем на A (41h)
значит => 41h 41h 41h 41h
таким образом было 
    0h 0h 0h
стало
    41h 41h 41h 41h

проверим на практике:
    $ echo -ne "\x0\x0\x0" |  od -t x1
    0000000 00 00 00
этим я показал что у нас в пайп передается именно поток байтов вида 0h 0h 0h

далее я байты 0h 0h 0h пускаю на base64 
и мы видим что на выходе мы получили 41h 41h 41h
    $ echo -ne "\x0\x0\x0" | base64 -w0 | od -t x1
    0000000 41 41 41 41
    0000004

а тут я не кодирую поток в base16(hex) а я его просто пускаю на терминал
который интепретирует байты 41h 41h 41h уже в графические символы
и мы видим что мы получаем "AAAA" согласно ASCII кодировке которая ставит соотвествие 
байтов и графических символов. 
    $ echo -ne "\x0\x0\x0" | base64 -w0
    AAAA 
(по факту терминал работает в режиме UTF-8 но первые 127 симоволов что у ASCII что у
utf-8 совпадают. тоесть первые 127 граф символов ascii по своим байтам совпаадает как это 
есть у utf8)

также так как у нас 6бит кодируется в 8бит то конечное число бит должно быть кратно 
им обоим. и минимальное такое число это это 24бита тоесть это 3 байта.то есть  3 байта,
6 байтов, итд.
пример
    $ echo -ne "AAA" | base64 -w0
    QUFB
    $ echo -ne "AAAAAA" | base64 -w0
    QUFBQUFB
видно что размер коненого потока байтов по сравнению с имходным размером птока
увелчивается на 33%. тоесть было 3 байта стало 4 байта. было 6 байтов стало 8 байтов
тот же самый пример но на выходе я смотрю выходной поток не в виде печатных 
символов а в форме байтов
    $ echo -ne "AAA" | base64 -w0 | od -t x1
    0000000 51 55 46 42

    $ echo -ne "AAAAAA" | base64 -w0 | od -t x1
    0000000 51 55 46 42 51 55 46 42

окей. а что если исходный поток неделится нацело на группы по 6 бит.
например берем входной поток 2 байта. например
0000 0000 0000 0000 => 0000 00|00 0000| 0000 ??
как в этом случае работает перекодирование base64. а вот как
первые два полноценных куска по 6бит кодируются как положено  в "A" 41h
последний неполноценный кусок в котором всего 4 бита берется как есть тоесть
0000 
и конвертируется в число. в данном случае в байт "0" то есть 4 бита дополняется нулями до 6бит.
тоесть было 0000 стало 000000 и далее по таблицу эта 6битная группа конвертируется в символ "A"
но на этом история не заканчивается. base64 в конце потока байтов добавляет символ "=" 3dh
причем он добавляет несколько "=" с таким прицелом чтобы число байтов на выходе было кратное 4 байтам.
тоесть было 0000 0000 0000 0000 => 0000 00|00 0000| 0000 ?? => дополняем последнюю группу нулями до 6 бит =>  0000 00|00 0000| 0000 00 => коневертируем в печатные символы получаем => 41h 41h 41h или 
в форме печатных символов => "AAA" . видим что на выходе мы получили 3 байта и это число не кратно 
четырем байтам, тогда добавляем 1 символ "=" => получаем "AAA=" теперь мы получили 4 байта
и это число кратно 4 байтам.
показываю на примере
    $ echo -ne "\x0\x0" | base64 -w0 
    AAA=
    
    $ echo -ne "\x0\x0" | base64 -w0  | od -t x1
    0000000 41 41 41 3d

тут я хочу подчеркнуть что дополнение потока байтов на выходе символами "=" происходит 
только в том случае если исходный поток неделится кратно на 6бит. если же он делится то добавления
символа "=" не происходит. показываю на примере
    $ echo -ne "AAA" | base64 -w0 
    QUFB 
    $ echo -ne "AAAA" | base64 -w0 
    QUFBQQ==
тоесть в первом примере на входе мы имели поток из 3 байтов. 3 байта делятся на целом на группы из 6бит.
поэтому поток на выходе не дополняется кодировкой символом "="
второй пример имеет на входе 4 байта. это 32 бита. 32 бита на цело на 6бит неделится. 
это 5 полноценных групп и одна неполноценная , дополняем неполценнную нулями в битах до полноценной в 6 бит. получим после перекодивки 6 символов ( 6 байтов). так как у нас была неполноценная группа то 
значит смотрим на выходной поток и проверяем делится ли он нацело на 4 байта. 6 байтов неделится на цело на 4. поэтому мы дополняем выходной поток символами "=" столько раз чтобы он начал делится нацело на 4. 
получаем дополняем два раза. получаем 8 символов. 
показываю тоже самое 
    AAAA = 41h 41h 41h 41h 
преобразую 41h в base2 (бинарный) вид
    $ echo "obase=2;ibase=16;41" | bc
    1000001
получаем
    41h 41h 41h 41h = 0100 0001    0100 0001   0100 0001  0100 0001 =>
    => делим на группы по 6бит => 0100 00|01    0100| 0001   01|00 0001|  0100 00|01 ???? =>
    дополняем последнюю неполнценную группу 01 ???? нулями до 6 бит  01 0000 
причем возникает вопрос как неполноценную группу дополняем нулями слева или справа. ответ справа.
тоесть было 01 стало 01 0000
    => тогда полная группы будет выглядеть
    0100 00|01    0100| 0001   01|00 0001|  0100 00|01 0000  =>
    преобразуем в dec числа => 16 | 20 | 5 | 1 | 16 | 16 | 

теперь преобразуем кажду группу в 8битный байт согласно таблице (https://en.wikipedia.org/wiki/Base64#Radix-64_applications_not_compatible_with_Base64)
тут важно понять что мы полученные числа неконвертируем согласно классической ASCII таблицы нет.
мы конвертируем числа согласно таблице Base64 из вики. 
тогда
    16 = Q
    20 = U
    5  = F
    1 =  B
 
тогда получаем на выходе
    QUFBQQ
теперь получив символы мы можем согласно классической таблицы ASCII мы можем каждый символ
конвертиррвать в 8битный байт. тогда
    Q = 51h
    U = 55h
    F = 46h
    B = 42h

тогда выходной поток в форме байтов выглядит как 
    51h 55h 46h 42h 51h 51h
так как у нас была неполноценная группа из 6 бит входного потока то 
теперь мы должны выходной поток байтов проверить дедится ли число его байтов нацело на 4.
имеем 6 байтов. вывод неделится. значит дополняем 6 байтов до 8 байтов чтобы он делится на цело на 4 
через два символа "=" 3Dh
тогда суммарно выходной поток в форме символов выглядит вот так
     QUFBQQ==
или в форме байтов
    51h 55h 46h 42h 51h 51h 3Dh 3Dh
проверяем на практике
    $ echo -ne "AAAA" | base64 -w0 
    QUFBQQ==
    $ echo -ne "AAAA" | base64 -w0 | od -t x1
    0000000 51 55 46 42 51 51 3d 3d
видим что теория совпала с практикой.

итак  я детально разобрался как раобтает процесс работы команды base64
в частности выяснилось что если входной поток в виде битов неделится нацело на 6
то на выходе обязательно будут байт(ы) 3Dh или символ(ы) "="
так вот возврашаемся в /etc/shadow
    $ sudo cat /etc/shadow  | grep temp
    temp:$6$jwAMQACK$YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.:19441:0:99999:7:::
значит видим что 
алгоритм хещирования это sha-512
а хеш записан в виде 
    YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.
полагаем что хеш перекодирован во чтото типа base64
хотя это не может быть именно base64 потому что у него в его алфавите нет символа "."
у base64 словарь это "A-Z a-z 0-9 +/"
а тут в стринге мы видим "."
и видим что на  конце стринга нет символа "="
посчитаем какая длинна в байтах для этого стринга
    $echo -n "YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk." | awk '{print length}'
    86
видим что 86 байт. значит если эта хрень могла бы быть  base64 то в основании был бы поток из 86-и 6 битных групп. тогда 86*6=516 бит
но прикол в том что sha-512 выдает поток байтов длинной 512 бит. но никак не 516 бит. 
поэтому хеш закодирован в чемто другом а не в base64. сука.
если мы будем кодировать 512бит в классический base64 то так как 512 нацело неделится на 6битные группы
то значит обязательно на конце будет символ(ы) "=" а именно 512/6=85 полноценных групп и 1 одна
неполноценная группа. итого 86 групп. так как есть неполноценная группа то значит у нас на конце
будет один или несколько символов "=". проверяем 86 делится ли на 4 на цело. ответ нет. но 
делится 88 на 4. поэтому наши 86 символов будут дополнены двумя "=" до 88 символов.
показываю на примере

$ echo -n "1" | sha512sum | awk '{print $1}' | xxd -r -p | base64 -w0
Tf9Oo0DwqCPxXT9PAati6uDl2lecy4Ufjbnf6ExYsrN7iZA6dA4e4XLaeTpuedVg5ff5vQWKEqKAQz7W+kZRCg==

итак мы видим на конце как и было предсказано  "==" 
и общая длинна стринга 88 байтов
$ echo -n "1" | sha512sum | awk '{print $1}' | xxd -r -p | base64 -w0 | awk '{print length}'
88

таким макаром я доказал что вариант записи хеша в /etc/shadow это не классический base64
а чтото похожее. что конкретно за кодировка я щас буду искать далее


тут я отхожу немного в сторону. есть прога /bin/login из пакета login
эта та прога которая запущена когда мы видим приглашение для логина и пароля. она принимает
наш пароль и анализируе правильный он или нет. 
и у него в man login написано про один из его конф файлов
    /etc/login.defs Shadow password suite configuration.
так вот в этом файле есть строки 

$ cat /etc/login.defs
# If set to MD5 , MD5-based algorithm will be used for encrypting password
# If set to SHA256, SHA256-based algorithm will be used for encrypting password
# If set to SHA512, SHA512-based algorithm will be used for encrypting password
# If set to DES, DES-based algorithm will be used for encrypting password (default)
# Overrides the MD5_CRYPT_ENAB option
ENCRYPT_METHOD SHA512

# Define the number of SHA rounds.
# With a lot of rounds, it is more difficult to brute forcing the password.
# But note also that it more CPU resources will be needed to authenticate
# users.
#
# If not specified, the libc will choose the default number of rounds (5000).
# The values must be inside the 1000-999999999 range.
# If only one of the MIN or MAX values is set, then this value will be used.
# If MIN > MAX, the highest value will be used.
#
# SHA_CRYPT_MIN_ROUNDS 5000
# SHA_CRYPT_MAX_ROUNDS 5000


таким макаром в этом файле указано как ему проверяеть введенный пароль , как его трансфор
мировать в ту хрень с которой он будет сравнивать с тем что в /etc/shadow

тоесть что хешировать введенный пароль нужно в sha-512 и что это надо сделать 5000 раз.

возврашаемся к нащим баранам. man 3 crypt говорит то что 
 The characters in "salt" and "encrypted" are drawn from the set [a-zA-Z0-9./]
итак мы видим что искомая кодировка имеет словарь кодирования другой отличный от base64.
у base64 словарь [a-zA-Z0-9+/]
а искомая в shadow кодировка [a-zA-Z0-9./]
тоесть "+" был заменен на "."
далее я пошел на вики читать про base64.
и оказалось что это не один стандарт кодировки. это целое семейство кодировок.
я попробовал найти в  man base64 какая же версия кодировки поддерживает эта команда. 
но я не нашел. как я понял методом эмпирического тыка что линуксовская утилита base64
она написана на основе rfc4648 (section-4)
а именно. она требует наличия padding "=" если у нас исходный поток неделится нацело на группы по 6 бит
и что алфавит у нее вот такой 

 Value Encoding  Value Encoding  Value Encoding  Value Encoding
         0 A            17 R            34 i            51 z
         1 B            18 S            35 j            52 0
         2 C            19 T            36 k            53 1
         3 D            20 U            37 l            54 2
         4 E            21 V            38 m            55 3
         5 F            22 W            39 n            56 4
         6 G            23 X            40 o            57 5
         7 H            24 Y            41 p            58 6
         8 I            25 Z            42 q            59 7
         9 J            26 a            43 r            60 8
        10 K            27 b            44 s            61 9
        11 L            28 c            45 t            62 +
        12 M            29 d            46 u            63 /
        13 N            30 e            47 v
        14 O            31 f            48 w         (pad) =
        15 P            32 g            49 x
        16 Q            33 h            50 y

тоесть [A-Z a-z 0-9 + /]

и далее в этой википедии  я нашел то что искал уже относиельно crypt(3) 
цитирую:
    Unix stores password hashes computed with crypt in the /etc/passwd file using an encoding called B64. crypt's alphabet puts the punctuation . and / before the alphanumeric characters. crypt uses the alphabet "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz". Padding is not used.

таким макаром я прихожу к выводам:
 - я так и не понял B64 это разновидность base64 или это чтото отдельное? но по факту я в интернете
   отдельно описание кодировки B64 ненашел по имени
 - теперь я могу по идее руками попробовать вычислить хеш от пароля руками то как это делает crypt(3)
   делать надо так: берем строчку из /etc/shadow, берем salt. берем пароль. соединяем вместе, 
   потом начинаем вычислять sha-512 пять тысяч раз. получаем 512 бит поток байтов.
   а потом кодируем этот поток в печатные символы с помощью разделения байтов на группы и 6 бит
   и переводим эти группы в символы алфавита 
            ./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz  
   при этом паддинг не используем.

         0 .            17 F            34 W            51 n
         1 /            18 G            35 X            52 o
         2 0            19 H            36 Y            53 p
         3 1            20 I            37 Z            54 q
         4 2            21 J            38 a            55 r
         5 3            22 K            39 b            56 s
         6 4            23 L            40 c            57 t
         7 5            24 M            41 d            58 u
         8 6            25 N            42 e            59 v
         9 7            26 O            43 f            60 w
        10 8            27 P            44 g            61 x
        11 9            28 Q            45 h            62 y
        12 A            29 R            46 i            63 z
        13 B            30 S            47 j
        14 C            31 T            48 k         (pad) нету
        15 D            32 U            49 l
        16 E            33 V            50 m

   
    
поехали берем строчку
юзер temp пароль temp
его строчка в shadow

temp:$6$jwAMQACK$YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.:19441:0:99999:7:::

мы имеем 
$6 = sha512
jwAMQACK = salt
хеш в формате B64 = YaBhSrk3S4W08N7FI5YgQ47uCyAgtt1gD6lKEPUIrtxsd8KWTq0xvh18dqFWPOiAnQanwhS3fnY.dDjqvgbLk.
YaBh = 36 38 13 45 

тут вылезла проблема в баш в переменной хер ты сохранишь бинарный поток байтов.
точнее в баш нельзя чтобы байты которые содержатся в переменной содержали байт 00h
показываю
    let a=$(echo -ne "\x31")
    $ echo -n $a | xxd -p
    31
итак переменная a хранит в себе байт 31h
тут проблемы нет.
а вот когда будет проблема
    $ let a=$(echo -ne "\x00")
    bash: warning: command substitution: ignored null byte in input
еще пример когда 00h находится где то всередине потока
    $ let a=$(echo -ne "\x31\x00\x41")
    bash: warning: command substitution: ignored null byte in input

это значит что когда мы будем сохранять хеш в форме байтового потока то у нас же там будут 
байты вида 00h и поэтому нас бащ пошлет нахер. поэтому наш хеш нужно хранить в баще 
не в байтовом виде а в виде hex ( base16). поэтому мне пришлось переделать скрипт вычисления
хеша тот который выше. мы вычисляем хеш получаем его в base16. и это хорошо.так мы его 
и сохраняем. а когда нужно вычислить новый хеш то преобразуем base16 --> bin
и от этого bin вычисляем хеш

$ cat 1.bash 
#!/bin/bash
			    # переменные
p="temp"       # password
n=10000        # число хешей
salt="jwAMQACK"


			    # тело скрипта
echo "пароль = $p"
echo "salt = $salt"
sp=$salt$p
echo "salt\пароль = $sp"
echo "макс число хешей = $n"
start=$(date +%s)  		# начало выполнения скрипта
echo "salt\пароль в hex = $(echo $sp | xxd -p)"

h1=$( echo -n "$sp" | xxd -p ) 	# конвертируем пароль в base16 (hex) формат
for i in $(seq 1 1 $n)
do
  h2=$( echo -n "$h1" | xxd -r -p | sha512sum | awk '{print $1}'  )
  h1=$h2
echo -ne "текущий хеш $i-ый  = $h2 \r"

c1=$( echo -n $h1 | cut -b 1-4 )
if [ "$c1" = "9263" ];then echo "gotcha!";break;fi

done
echo ""
end=$(date +%s)
echo "Время выполнения скрипта: $(($end-$start)) секунд"

еще одна проблема которая вылезла когда писался скрипт это то что
непонятно куда прибавляеть salt к паролю. толи до пароля то ли после пароля.
(как пишут в интернете append or prepend).
причем я нашел в инете противоречивые утверждения о том какой метод 
дает более надежный в плане брутфорса результат. одни пишут что если солт 
стоит до пароля то это более надежно. другие пишут что добавление солт в хвост пароля
это более надежно. 
в итоге  я попробовал и так и так. 5000-ый хеш не получается таким
как он есть в /etc/shadow
также я увеличил глубину до 10 000 но ни один хеш не отвечает нужному.
как я это проверял. я взял кусок хеша в формате B64 из /etc/shadow 
    YaBh
и рассчитал по нему как должен выглядеть хеш в формате base16 получил 
    92636d
но ни один расчетный хеш недает ни то что 92636d но даже недает 9263
в итоге я могу вот что сказать как работает схема в теории от ввода пароля с клавы и 
до записи в /etc/shadow
мы запускаем команду 
    $ passwd
вводим пароль с клавы.
далее вызывается сисколл crypt
он создает рандомный salt и присоединяется к паролю то ли сначала то ли к концу.
далее 5000 раз вычисляется sha-512 и далее эти 512 бит перекодируются в B64
которая является некоей разновидностью base64 и уже вся эта хрень записывается в /etc/shadow
в виде
    имя_юзера:$тип_хеша$salt(в UTF-8)$хеш(в виде B64):остальная хрень нам неважная щас

далее я нашел статью в которой все разбирается по частям отлично:
    https://www.vidarholen.net/contents/blog/?p=32
поехали
в ней приводится разбор как раобтает хещирование пароля через md5 при записи в /etc/shadow
значит в стьатье приводистя баш скрипт. который щас начнем разбирать


#########################
#!/bin/bash
# md5-crypt for GNU and Bash
# By Vidar 'koala_man' Holen

b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}

# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

# Turn stdin into a \xd4\x1d style md5 hash
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}

# Turn an integer into a crypt base64 string with n characters
intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")
        number=$(bc <<< "$number / 64")
        echo -n "${b64:digit:1}"
    done
}

base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}

# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}


doHash() { 
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes

    intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )

    for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done

    # Rearrange the bytes and crypt-base64 encode them
    encoded=$(base64EncodeBytes 22 "$intermediate" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

    printf "%s$salt\$%s\n" "$magic" "$encoded" 

}


if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2 
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 

doHash "$password" "$salt" '$1$'
##########################


начнем с куска 
#######
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}
########


здесь наворочано. разбор микрокусочков этого кода я делаю в "bash.txt"
а тут наверно буду чуть сокращенно.
вот эта хрень
    {#1}
вычисляет длинну переменной $1
поэтому цикл 
    for((i=0; i<${#1}; i++))
будет работать от 0 до длинны $1 минус один. 
оффсет у переменной у баша начинается слева с номера ноль и идет направо до длинны переменной
минус один.тоесть скажем
    $1="34"
значит длинна переменной 2. офссет 0 хранит 3 а оффсет 1 хранит 4
    printf '(%s)*256+%d' "$expression" "'${1:$i:1}"
принтф состоит из трех кусков. 
первый кусок '(%s)*256+%d' так назвываемый формат. это то что нужно напечатать
следущий кусок "$expression" это первая переменная которая будет подставлена в формат
следущий кусок "'${1:$i:1}" это вторая переменая которая убдет подсталена в формат

рассмотрим подробнее кусок с форматом '(%s)*256+%d'
вместо %s  будет поставлена первая переменная тоесть "$expression"
вместо %d будет подставлена вторая переменная "'${1:$i:1}"

также %s означает что переменная должны быть сконвертирована в string. тоесть другими словами
переменная будет подставлена так как она и есть. без изменений. 
пример 
    $ expression="(1+3)*5+6"
    $ printf "%s - самая лучшая строка \n" "$expression"
    (1+3)*5+6 - самая лучшая строка 

%d означает что переменная будет трансформирована в целое десятичное число со знаком.
пример
    $ vasya="-5"
    $ printf "%d  = число со знаком \n" "$vasya"
    -5  = число со знаком 

для контраста %u означает целое десятичное без знака
    $ vasya="-5"
    $ printf "%u  = целое без знака \n" "$vasya"
    18446744073709551611  = целое без знака 

откуда у нас взялось такое число читай о том как хранятся числа в баш
итак еще раз
    printf '(%s)*256+%d' "$expression" "'${1:$i:1}"
будет напечатано 
    (%s)*256+%d
где вместо %s будет подставлен "$expression" без изменений
а вместо %d будет подставлен "'${1:$i:1}" преобразованный в десятичное целое со знаком
далее что такое 
    '${1:$i:1}
апостроф в переменной в принтф означает что он берет первый символ стоящий после апострофа
находит для этого символ в таблице ASCII десятичное число и подставляет его в вместо переменной
пример
для символа "A" в таблице ASCII соотвествует десятичное число 65
    $ printf "%d \n" "'A"
    65 
поэтому это эквивалентно
    $ printf "%d \n" "65"
    65 
что интересно 
    $ printf "%d \n" "'AA"
    65 
тоесть берется только первый символ а все остальное посылается нахер
с апострофом разобрались, теперь что значит вот это
    ${1:$i:1}
это значит взять переменную $1, и вырезать из нее только определенные символы. а именно
начиная с символа с оффсетом $i (где i это наши индекс цикла for) в количестве 1 штука.
переменная $1 это первый аргументы указаный при вызове нашей функции 
stringToNumber
    пример
    $ a="123"
    $ echo ${a:0:1}
    1
    $ echo ${a:1:1}
    2
    $ echo ${a:2:1}
    3
    $ echo ${a:1:2}
    23

тоесть опять же сделано ебануто. было бы логично укаывать первый символ который брать и последний 
по их оффсету. скажем распечатай с первого по пятый. но нихуя. указывается оффсет первого символа
и количество символов которое надо суммарно напечатать после оффсета , включая символ в самом оффсете.
итак в нашем примере
оффсет это номер позиции символа
оффсет 0 хранит 1
оффсет 1 хранит 2
оффсет 2 хранит 3
да - оффсеты начинаются с нуля. и нумеруются слева в стринге. то есть самый левый символ имеет 
наименьший оффсет равный ноль
в первом примере мы говорим напечатай 1 символ начиная с офсета 0
в втором примере мы говорим напечатай 1 символ начиная с офсета 1
в втором примере мы говорим напечатай 1 символ начиная с офсета 2
в последнем примере мы говорим напечатай два символа начиная с оффсета 1
таким макаром суммарно вот эта хрень
    '${1:$i:1}
означает возьми переменную $i и вырежь из нее один символ в оффсете $i
а потом найди для этого символа код в таблице ASCII и подставь вместо переменной в виде десятичного
числа. пиздец
итак теперь расссмотрим как работает эта хуйня на примере
#######
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}
########

вызываем эту функцию с параметром "34"
    stringToNumber "34"
получаем
    expression=0
    ${#1} = 2
тогда 
    for((i=0; i<2; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
заходим в цикл
    $1="34"
    i=0
    "'${1:$i:1}" = "'${1:0:1}" = "'3" 
ascii код для "3" десятичный равен 51 значит 
    "'3" = "51" тоесть 
    "'${1:$i:1}" = "51"
        тогда 
    expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}") = 
      = $(printf '(%s)*256+%d' "0" "33") = "(0)*256+51"
тоесть 
    expression="(0)*256+51"

переходим к следущему шагу цикла
    i=1
    "'${1:$i:1}" = "'${1:1:1}" = "'4" = "34"
    expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}") = 
      = $(printf '(%s)*256+%d' "(0)*256+33" "34") = "((0)*256+51)*256+52"
тоесть 
    expression="((0)*256+33)*256+34"

итак на выходе из цикла мы будем иметь 
    expression="((0)*256+51)*256+52"

дальше эта хрень передается в bc
    bc <<< "$expression"
тоесть
    bc <<< "((0)*256+51)*256+52"
в итоге получим число


далее я изменил текст этой функции в stringToNumber1чтобы было наглядно видно
как она выполняется
и также написал другую функцию stringToNumber2 которая делает тоже самое но делает это по другому.
дело в том что видно что чем длиннее у нас аргумент $1 тем у нас на выходе
из цикла будет стринг расти все длинне и длинне. и только в самом конце он будет передан 
для расчета в bc. нахуй так делать. мы не отращиваем хвост. мы его считаем сразу


###################
$ cat md.bash 
#!/bin/bash

    echo -e '\nаргумент $1 =' "$1 \n"


stringToNumber1 () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
        echo  "i=$i"
        echo "expression=$expression"
        q=$(printf "%d" "'${1:$i:1}")
        echo "'"'${1:$i:1} ='  "'""\${1:$i:1} ="  "'${1:$i:1} = $q "
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
        echo "new_expression =" "printf ""'"'(%s)*256+%d'"'" ' "$expression"' '"'"'"'${1:$i:1}" =' "$expression = " "$(bc <<< $expression)"
        echo -e "---\n"
    done
}




stringToNumber2 () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
        echo  "i=$i"
        echo "expression=$expression"
        expression=$( printf '(%d)*256+%d \n' "$expression" "'${1:$i:1}" | bc )
        echo "new expression = $expression"
        echo -e "---\n"
    done
}

stringToNumber1 $1
stringToNumber2 $1
###############

$ ./md.bash 34

аргумент $1 = 34 

i=0
expression=0
'${1:$i:1} = '${1:0:1} = '3 = 51 
new_expression = printf '(%s)*256+%d'  "$expression" "'${1:$i:1}" = (0)*256+51 =  51
---

i=1
expression=(0)*256+51
'${1:$i:1} = '${1:1:1} = '4 = 52 
new_expression = printf '(%s)*256+%d'  "$expression" "'${1:$i:1}" = ((0)*256+51)*256+52 =  13108
---

i=0
expression=0
new expression = 51
---

i=1
expression=51
new expression = 13108
---

сравним то что я получил высчитвая руками выше чему равен expression при выходе
из цикла
    "((0)*256+51)*256+52"
с тем что показала программа на практкике
     ((0)*256+51)*256+52
тоесть все правильно

единственное что мне непонятно каков физический смысл этой хрени 
    ((0)*256+51)*256+52
очень похоже на формулу когда мы одну систему счисления переводим в другую тоесть.
скажем у нас есть бинарный вид
    0101
тоггда как мы пеереводим в десятичный. мы наичинаем справа налево. в таком виде
   (2^3)*0+(2^2)*1+(2^1)*0+(2^0)*1
в нашем случае мы имеем
   34
насколько я понимаю то система знаков берется типа вся таблица ASCII но почему то не 127 символов
а почемуто какието мифические 256 символов. берется что "3" это число 51 а "4" это число 52 тогда 
   (256^1)*51+(256^0)*52 
  в таком случае мы получим число
    $ echo "(256^1)*51+(256^0)*52" | bc
    13108
   что совпадает с ихней диковинной формулой 
    ((0)*256+51)*256+52 =  13108
поэтому физ смысл этой функции это то что беертся стринг $1="34"
и рассматривается что это число записанное в 256-ричной системе счислений ( в которой 256 знаков)
и вычисляется десятичное значение этого числа.
я вот така не понимаю в ASCII таблице из которой берутся десятичные значения для "3" и "4"
всего 127 символов. причем не все из них печатные. поэтому я не понимаю с чего этот чувак взял
что система счисления 256-ричная. 
и вторая претензия что за ебанутая формула расчета. горазо более проще высчитать вот так
кстати вот эта хуйня с апострофом
    'A
который преврашает символ в его ascii код она работает только в составе printf
и больше нигде. в echo такой вариант не прокатит

по поводу моей претензии что типа функция высчитвает в ебанутом стиле.
оказывается вот что. я написал функцию которая высчитвает тоже самое 
в более логичном стиле. тоесть когда унас есть число "34" которое  в кодах ascci
выглядит как 52,51
и мы высчитываем его в виде 
    51*(256^0) + 52*(256^1)
вот как выглядит эта функция
###############
stringToNumber3 () {
    expression=0
    for((i=${#1}-1; i>-1; i--))
    do
        expression=$( printf '%d + (256^%u)*%d \n' "$expression" "$(bc <<< ${#1}-1-$i)" "'${1:$i:1}" | bc )
    done
    echo "expression = $expression"
    echo "#############"

}
##########

вывод на экран
    expression = 13108

однако как можно заметить что выглядит она 
гораздо более уродливо
чем там что выше изложена. тем чуваком.
тоесть моя фуннкция высчитывает все более логичным образом но выглядит при этом
совершенно по уродски

вот чуть более красивая версия функции. 
это когда мы начинаем суммировать не с младщего бита а со старшего
##################
stringToNumber3 () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
       expression=$(printf '%d + (256^%u)*%d \n' "$expression" "$(bc <<< ${#1}-1-$i)" "'${1:$i:1}" | bc)
    done
    echo "expression = $expression"
    echo "#############"

}
##############
    
сравним с оригинальной функцией
#######
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}
########

моя функция с точки зрения визуальной простоты кода выглядит посложнее поуродскее 
погромоздскее но зато она охуенно более логичная по самому алгоритму расчета.

я заменил егоную реализацию функции этой на мою и запустил полный скрипт. 
по времени программа считает одинаково что с той функцией что  с моей

меня порадовала команда как сравнить два хеша
    $ diff <( printf '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/') <( printf '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/')
либо
    $ diff <(md5sum <<< '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/') <(md5sum <<< '$1$12345678$oXt2.vO.tiMwAgvJfHgjl/')
 
что еще хочу добавить - по поводу цикла for у баша
а именно когда мы его хотим запустить в обратный отсчет.
прямой цикл
    $ for((i=0;i<5;i++)); do echo $i; done
    0
    1
    2
    3
    4
    $ for((i=5;i>0;i--)); do echo $i; done
    5
    4
    3
    2
    1
    $ for((i=5;i=0;i--)); do echo $i; done
тоесть когда я поставил i=0 то вообще ничего на выходе. пошел нахуй.
таким макаром я с функцией stringToNumber закончил 
##################
stringToNumber () {
    expression=0
    for((i=0; i<${#1}; i++))
    do
       expression=$(printf '%d + (256^%u)*%d \n' "$expression" "$(bc <<< ${#1}-1-$i)" "'${1:$i:1}" | bc)
    done
    echo "expression = $expression"
    echo "#############"

}
##############
она делает то что берет посланный в нее параметр $1
рассматривает его как число записанное в 256-ричной системе счисления отталкиваясь от 
того что каждый символ закодирован десятиричным кодом из таблицы ASCII
и переводит 256-ричное число в 10-ичное число.

берем следующую функцию из оригинально скрипта
и смотрим что она делает
########
# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}
###########

рассмотрим для начала очередные приколы принтф
во первых прикол в том что есть встроенный в баш принтф
а есть внешняя команда /usr/bin/printf

как узнать что выполняется при запуске команды вот в таком виде
    $ printf "vasya"
внещняя команда или билтин баша?
стрейт показывает что запускается внешняя команда. 
это прикол
    $ strace printf "vasya"
    execve("/usr/bin/printf", ["printf", "vasya"], 0x7ffc0e3bf778 /* 70 vars */) = 0
тоже самое для команды echo. запускается именно внешняя команда
а как заставить баш запускать билтин? 
незнаю но например вот такт
    $ builtin printf "vasya"
я то думал пол дефолту бащ запускает билтины всегда. а если их нет то уже внешнюю
команду

значчит по printf спавку надо смотреть не через man bash
а через man printf

далее
значит фишка в том что внутри поля формат в принтф можно вбивать не только 
символы классические как например
    $ printf "vasya  \n " 
    vasya  
но и байты напрямую.
например можно указать байт в octal виде в форме \xxx
    $ printf "\41  \n " 
    !  
41 octal это 33 dec это 21р и это восклицетельный знак  в интепретации ascii
    $ printf "\41 \n" | od -t x1
    0000000 21 20 0a

ну тоесть вот мы и видим вначале 21h который восклицетальный знак. потом 20h котоый пробел и 0ah
который Enter.

также можно указать байт в виде hex  через \xHH
    $ printf "\x21 \n" 
    ! 
хочу подчеркнуть разницу с вот этим примером
    $ printf "%x \n" "33"
    21 
здесь мы тоже работаем с hex но по другому. во первых %x касается подстановки переменной
а не работа с константой как в прошлом примере.
во вторых в прошлом примере мы в поток суем байт 21h в прямом виде поэтому на экране мы 
видим "!" 
а в этом примере у нас десятичная 33 переводится в 21h и на экране выводится 21 
поэтому это совершенно разные вещи
еще пример про это
    $ printf "\x21 %x \n" "33"
    ! 21 

возвращаемся обратно к 
    $ printf "\x21 \n" 
    ! 
что если мы хотим на экране получить "\x21"
почемуто одинарное экранирование через палку неработает
    $ printf "\\x21 \n"
    ! 
хотя если заменить кавычки то работает !
    $ printf '\\x%x \n' "33"
    \x21 
пиздец
если кавычки двойные то работает только через двойное экранирование пиздец
    $ printf "\\\x21 \n"
    \x21 
а что если мы хотим 21 вставить через переменную?
    $ printf '\\x%u \n' "21"
    \x21 
    $ printf '\\x%x \n' "33"
    \x21 

тоесть вот эта конструкция "\\\x" или эта '\\x' служит для того чтобы обьяснить принтф что мы просто хотим
напечатать "\x" чтобы он нерассматривал эту хрень как признак hex числа.

теперь мы можем возвратться к функции
########
# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}
###########

получается эта хрень
    printf '\\x%x' "'${1:i:1}"

а точнее вот эта '\\x%x' означает то что мы говорим напечатай нам \x а далее за ним напечатай переменную
преобразовав ее в hex формат. 
напоминаю что сама переменная "'${1:i:1}" это хитрая хуйня потому что стоит апостроф. поэтому вначале переменная представляет собой символ который она берет из аргумента, скажем второй слева символ, а потом
для этого символа находится ascii код и значение переменной заменяется из символа на его ascii код 
в десятичном виде например
пусть 
    "${1:i:1}"="a"
ascii код для "a" равен 97 dec тогда
    "'a" = 97
тогда 
    printf '\\x%x' "'${1:i:1}" = printf '\\x%x' "97"
тогда на экране будет напечатано 
       \x 
а далее 97 согласно %x будет преобразован в hex тоесть 61 итого на экране
      \x61
это пиздец

суммарно на выходе эта фукция должна вот что делать. она берет аргумент 
    34
разбивает его на отдельые цифры
    3     4
потом для каждой цифры находит ascii код
и в итоге печатает ascii код на экране в hex виде
    \x3\x4
проверяем
запускаю функцию stringToHex ab
на экране
    \x61\x62
действиельно "a" имеет ascii код 61h
"b" имеет ascii код 62h
таким макаром эта функция вот что делает. она берет аргумент , берет каждый символ,
находит для него код в ascii таблице и печатает на экране в hex формате а именно \x21
таким образом мы видим аргумент не в форме печатных символов а форме ascii кодов в hex записи
еще пример
    $ ./md.bash  *ab!   
    аргумент $1 = *ab! 
    \x2a\x61\x62\x21
    
и действилеьно согласно ascii
    hex     symbol
    2a      *
    61      a
    62      b
    21      !

и действиельно байтовый поток так и выглядит
    $ echo -n '*ab!' |  od -t x1
    0000000 2a 61 62 21


рассмотрим следующую функцию в оригинальном скрипте
###############
# Turn stdin into a \xd4\x1d style md5 hash
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}
##########

во первых на счет "<<<" пока неразбирался откуда нога растет но
походу вот два эквивалента

    $ echo "a" | od -t x1
    0000000 61 0a

    $  od -t x1 <<< "a"
    0000000 61 0a

    
в целом назначение функции мне понятно. берется из stdin строка символов,
для нее вычисляется md5 хеш,
хещ выглядит на экране после команды md5sum выглядит вот так 
    67f66d5f0d8b38970f71afd43f83c623
и на заключительной стадии он заменятеся на 
    \x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23
чтобы было более понятно какой смысла имеют печатные символы
    
теперь более детально как функция работает.
как я понимаю она вызывается внутри скрипта както вот так

    echo "12 13" | md5hex

через пайп данные влетают в stdin функции (как это обеспечивается хер знает)
что значит stdin функции . как я понимаю это влетает в первую команду 
в теле функции

тело функции
###############
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}
##########

тоесть в stdin команды 
    sum=$(md5sum) 
значит команда md5sum по дефолту читает данные из stdin
поэтому по факту это влетает в нее. значит md5sum будет высчитывать хеш от "12 13"
результат будет запомнен в переменную $sum
далее некоторая проблема потому что типичный вывод от md5sum это 
    67f66d5f0d8b38970f71afd43f83c623  -
здесь мы видим полезный для нас хеш и бесполезный сраный минус на конце.
от него надо избавиться. 
делается это через 
    read sum rest <<< "$sum"
билтин read работает так. он берет стринг $sum находит  в нем пробелы. и то что до первого пробела
сует в переменнуую sum а то что между вторым и третьим пробелом сует в переменную rest
таким макаром у нас чистый эксрактированный хеш теперь лежит в переменной sum
на следущем этапе мы берем стринг. берем по два символа в переменной sum скажем это "12" и меняем на \x12
и так для всего стринга. таким макаром наш исходный стринг
    67f66d5f0d8b38970f71afd43f83c623
будет заменен на 
    $ sed 's/../\\x&/g' <<< 67f66d5f0d8b38970f71afd43f83c623
\x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23
и эта хрень  и будет то что даннная функция будет возврашать нам.
так значит как работает эта херня
    sed 's/../\\x&/g' <<< "$sum"
ну понятно что эквалентом этого является
    echo "$sum" | sed 's/../\\x&/g'
поэтому далее разбираемся с 
    sed 's/../\\x&/g'
значит эта хрень работает так
/.. = это паттерн поиска. он означает что берется два любых символа
\\x& = это паттерн замены того что мы нашли на нечто новое. состоит он из двух частей
\\x вот эта хрень означает напечатать "\x" просто так как в sed символ "\" играет роль экранирующего
то есть это служебный символ то нам для того чтобы напечатать его надо его самого на себя заэкранировать.
показюываю на примере правда для этого надо еще тогда пояснить что за символ "&" . это как бы спец переменная в ней содержится ровно все то что попало под шаблон поиска. тоесть
пример
    $ sed 's/./A&/' <<< "123"
    A123
это работает так. сед берет 123
\. - означает что под шаблон попадает первый любой символ один.
первый символ  у нас "1" он автоматом запоминается в спец переменную &
\A& - шаблон замены говорит о том что то что попало в шаблон поиска должно быть заменено на 
A плюс то что содержится в переменной & (тоесть 1) поэтому замена будет такая
        123 -> A123
что мы и видим. 
по дефолту сед находит первое вхождение в строке и делает замену и после этого успокивается
если же добавить ключ g то он будет искать все вхождение я строке поэтому 
    $ sed 's/./A&/g' <<< "123"
    A1A2A3
теперь когда разборались с флагом g и со спец переменной &
можно вернуться к "/".
предположим мы хотим заменить первый символ на символ &. так как это служебный символ у сед
то ему надо обьяснить что мы его в данном случае используем просто как печатный символ а не спец
символ для этого спец символ надо экранироовать тоест
    $ sed 's/./\&/' <<< "123"
    &23
тоесть /. ищет нам первый символ в строке
и он заменяется на символ & $ echo -e "ibase=16;\n 778D1B86BE195DAE8CB01688E81BE779"  | bc
158910803655924292489198456294474508153

знак \& обясняет седу что в данном случае & это не служебны символ.
так вот представим что мы теперь хотим заменить первый символ на символ "/"
так как он служебный то его тоже нужно экранировать. иначе пошлет нахер
    $ sed 's/./\\/' <<< "123"
    \23

теперь станвться понытным этот щаблон замены
\\x& ==> \\ означает что мы экранировали / и хотим его использовать как простой символ.
x это просто символ 
а & это спец символ означающий все то что было найдено  в шаблоне
поэтому суммарно эта херня работает так
        sed 's/../\\x&/g'
ищется два первых символа любых в строке. они запомниаются в сец переменную &
и далее эти два символа заменяются на \x + то что лежит в &
тоесть если у нас в строке
    1234
то в шаблон попадает "12" оно же запоминается в &
и этот "12" заменятся на "\x12"
так как стоит флаг g то после этого сед продолждает дальше поиск в строке и ищет следующие два 
символа и так до конца строки.
в итоге если на входе у нас есть хеш
    67f66d5f0d8b38970f71afd43f83c623
то он будет заменен на
    $ sed 's/../\\x&/g' <<< "67f66d5f0d8b38970f71afd43f83c623"
    \x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23

таким макаром разгадана третья функция исходного скрипта.



следущая функция
###################
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

# Turn an integer into a crypt base64 string with n characters

    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")  # остаток от деления
        number=$(bc <<< "$number / 64") # целое от деления
        echo -n "${b64:digit:1}"
    done
}
###################

функция работает так, ему скармиливется два числа например 123 и 8
тогда
    number=128
    n=8
далее запускается цикл 8 раз ( от 0 по 7)
каждый раз number делится нацело на 64 и переприсваивается сам себе. тоесть
    j=0 number=128/64=2, 
    j=1 number=2/64=0,
    j=2 number=0/64=0,
    j=3 number=0/64=0
итд
при этом также каждый раз находится остаток от деления numer на 64, тоесть
    j=0 остаток=0
    j=1 остаток=2
    j=2 остаток=0
    j=3 остаток=0
далее  в этом же цикле берется стринг 
    b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
и печатается символ с порядковым номером равным остатку.тоесть
    j=0 символ(0)=.
    j=1 символ(2)=0
    j=2 символ(0)=.
итак далее
тоесть в итоге будет
    .0......
возьмем еще один пример
    number=123 n=8
    значит цикл на 8 раз. 
    j=0 number=123/64=1  остаток=59 символ="v"
    j=1 number=1/64=0    остаток=1  символ="/"
    j=2 number=0/64=0    остаток=0  символ="."
    ...
    j=7 number=0/64=0    остаток=0  символ="."
итого на экране
    v/.....
проверка на практике
    $ ./md.bash 
    v/......


работа функции разгадана. что меня смущает в такой перекодировке или как 
пишут они в описании функции что это типа такой вид шифрования. фишка в том что 
в обратную сторону хрен расшифруешь поэтому по мне это скорее похоже на хеширование. но 
точно не шифрование.
поражает как красиво сделано перекодирование в b64
вот реальные аргументы которые передаются в эту функцию  в реальном скрипте
    322279607899402105297866753734997639596 22
тоесть первый аргумент эта хрень которую мы будем превращать в B64
22 это количество символов B64 которые мы получим на выходе
если мы запустим функцию с этим аргументами то мы на выхлопе получим
    g4kuC1.5wVcZ0Y5XnhARm1
что хочу отметить что алгоритм такой перекодировки совершенно отличается от классического
алгоритма base64
что мне еще непонятно. 
    исходное число оно в формате hex это 
    F274CB738C790296887C1C00CEEB01AC
оно имеет в длинну 32 символа. посольку каждый символ это полбайта.
то это значит что длинна этого числа 16 байтов. или 128 бит.
поскольку у нас b64 словарь это 64 символа. тоесть это 6 бит
то делим 128 на 6 получаем 21 полнценная группа из 6-и бит и еще 
в остатке остается 2 бесхозных бита.
итого это число если его перекодировать то оно будет занимать 22 символа.
как мы видим второй аргумент который программа сует в эту функцию это 22. 
и на выхлопе мы получаем дейтсивльно 22 символа. 
но что непонятно это то что если мы будем пользоваться клссчиеским алгоритмом пеереодирования 
в base64 пусть и с други словарем то мы получим первый символ совершенно не g
а нечто другое. показываю.
берем первый байт
    F2
конвертирум его в битовый вид
    $ echo  "obase=2; ibase=16; F2" | bc 
    11110010
берем от него группу из 6-и бит и конвертируем в десятичное число
    $ echo  "obase=10; ibase=2; 111100" | bc 
    60
теперь берем словарик 
    b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
и находим символ с 60-ым оффсетом получаем 
    w
но никак не 
    g
так что конкретно эта кодировка совершенно отличается от base64 алогритма нетолько словарем
но и самим алгоритом перекодирования сука.
единственное что можно скзаать что число 22 выбрано не случайно. что идет разбивка на 6-и битовые 
группы исходного числа. а потом так или иначе это 6битовое исходное число конвертируется в символ
из словаря.




рассмотрим следущую функцию
######################
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}
#######################
походу эта функция вот что делает. мы ей скармливаем в аргументе единичный
символ и она его ищет в переменной $b64
если находит то пишет офсет в $b64 иначе выдает ошибку

следущая функция
##############
# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}
############
как можно заметить тут приствтуует фигная по названием shift
это баш билтин. он делает вот что.
берем скрипт. и запускаем его с аргументами. $1 $2 $3 
если внутри скрипта запустить shift то он сдвинет все эти параметры на один влево.
тоесть $2 станет $1 $3 станет $2 ну а исходный $1 будет уничтожен.
пример
    $ cat 04.bash 
    #!/bin/bash
    echo $@
    shift 
    echo $@
    shift
    echo $@
    $ ./04.bash  1 2 3
    1 2 3
    2 3
    3

билтин shift имеет аргумент число по дефолту 1. поэтому он сдвигаем параметры на 1 влево.
если запутить как 
    shift 2
то он будет сдвигать на 2 параметра влево.

отойду немного в сторону, скажу как работает функция в баше. 
если в теле фенкции написано echo то будет ли это напечатано на экране зависит вот от чего.
пример

    f1() {
    echo "123"
    }

    f1 

если мы вот так вызываем функцию то эхо будет напечатано на экране. 
а если мы вот так вызовем функцию

    f1() {
    echo "123"
    }

    a=$(f1)
то на экране не будет напечатано нихера. весь stdout от работы функции будет 
записан внутрь переменной $a

далее супер хитррая хуйня. а именно строчка
    for i
типа что за хуйня? оказывается это есть такое сокращение от 
    for i in $@
охуеть. потому что иначе эта строчка сука не имеет никакого значения падла
теперь возврашаемся к нашей функции
##############
# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}
############

значит ее можно пеерписать в более понятный вид
##############
# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
}
############

значит теперь понятно как она рабоаеет. в нее послывается некий набор аргументов.
она запоминает первый $1 в переменную $num
далее через билтин баша shift первый аргумент $1 убивается. и все аргументы сдвинаются влево на один. 
тоесть $2 становится $1 , $3 становится $2 итд.
далее церез цикл мы проходим по всем аргументам и мы что делаем.
мы берем переменную $num и в ней вырезаем по 4 символа в заданных оффсетах. а номер оффсета
определяется как раз аргументами через которые идет итерация в цикле. 
и еще одна поразтеьная вещь
    $ i=4
    $ echo $((i*4))
    16
далее
показываю на примере как рабоает эта функция
######################
getBytes() { 
    num=$1
    echo "$@"
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
    echo ""
}


getBytes "\x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d"  1 4 3 2
################

аргумент  при вызове getBytes нужно взять в кавычки иначе там будет хуйня.
щас покажу на примере.
    smallF () {
        echo "$@"
    }

    smallF "\xa" "\xb"
вывод на экран
    \xa \xb
тоесть все коректно
теперь убираем кавычки
    smallF () {
        echo "$@"
    }

    smallF \xa \xb
вывод на экран
    xa xb
тоесть некореткно
теперь делаем двойные слеши
    smallF () {
        echo "$@"
    }

    smallF \\xa \\xb
вывод на экран
    \xa \xb
тоесть все коректно
тоесть суть такая что \ в bash используеся для экранирования спецсимволов обьясняя
башу что символ стоящий за слэшем ненужно рассматривать как спецсимвол
а нужно рассмтривать просто как простой печатный символ. когда мы не употреьляем
кавычки то баш будет искать  в аргментах спецсимволы. а если мы юзаем кавычки 
то тогда все что внутри кавычек рассмативается как простые печатые символы короме знака $
поэтому если мы хотим передать в функцию печатный знак слэша то нужно либо обрамлять аргумтенты
в кавыычки либо экранировать слеш таким же слешем.
вот еще аналогичный пример
    smallF () {
        echo "$@"
    }

    smallF ( (
вот такое вызовет ошибку. потому что вбаше символ ( явлется сппецсимволом.
поэтому его нужно либо взять в кавычки. либо экранировать слешем , в обобих случаях
это обьяснит башу что в данном случае скобка это не специсмвол а просто печатный симивол.
поэтому правиьные вариынтв такие
    smallF () {
        echo "$@"
    }

    smallF "(" "("
либо
    smallF () {
        echo "$@"
    }

    smallF \( \(
гениально
поэтому возвршаясь к нашей исходной функции
    getBytes "\x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d"  1 4 3 2
нам нужно взять перывй аргумент в кавычки так как слэши в аргументе неимеют смысла экранирорующего
символа. мы слэшем ничего не экранируем. мы его юзаем просто как печатный символ. поэтому либо
надо аргмент зключить в кавыячки что я и сделал либо если кавычки не использваоть то использовать
двойной слеш что конечно более уродливо будет выглядеть. но все же приведу для ясности
    getBytes \\x1b\\x16\\xae\\xbe\\x8d\\x86\\xe7\\x88\\x8c\\x19\\x1b\\x77\\x79\\xe8\\xb0\\x5d  1 4 3 2

    итак возврашаеся к нашей функции
######################
getBytes() { 
    num=$1
    echo "$@"
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
    echo ""
}


getBytes "\x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d"  1 4 3 2
################

еще один резонный вопрос с чего я взял что в исходный скрипт вызывает эту функицю с аналоичными 
параметрами. ответ  - я сделал дебаг исходного срприкта. вот с какми параметрами вызывается в
реальнрсти эта функция
    \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d 11 4 10 5 3 9 15 2 8 14 1 7 13 0

итак запускаем функцию 
на экране получим
    \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d 1 4 3 2
    \x16\x8d\xbe\xae
в верхнем ряду у нас изображены аргументы которые прилетели в функцию 
а внижнем ряду результат.
значит \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d  запоминается в $num
дальше берутся оставишиеся аргументы "1 4 3 2" каждый из них умножается на 4
и получившийся оффсет берется в $num и берется 4 символа и печатаются на экране.
дейтсиветельно берем 1 умножаем на 4 получем 4. в $num символ с оффсетом 4 это "\" и 
берем 4 символа включая "\" стоящие за "\" получем "\x16" и печатаем их на экране
    \x16
далее берем следущий аргмеент 4 умножаем на 4 получаем 16, берем символ имеющий 16 оффсет
в $num это "\", и беерем 4 символа идущие за \ включая \ это 
    \x8d
итак далее. в итоге на экране будет напечатано
    \x16\x8d\xbe\xae
итак суть этой функции это взять некий стринг. из него вырезать куски. и напечатать эти куски без 
преобразований.
так как  в функцию передается число в hex (base16) формате то эта функция по факту
выбирает отдельные заданные числа и печатает их.
тоесть еще раз в функцию влетает вот такое
    \x1b\x16\xae\xbe\x8d\x86\xe7\x88\x8c\x19\x1b\x77\x79\xe8\xb0\x5d 1 4 3 2
а вылетает из нее вот такое
    \x16\x8d\xbe\xae



рассмотрм следующую фугкцию
#############

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}
############

отойду в сторону. если у нас есть функции в скрипте. то самый простой способ их дебажить
это делать echo внутри функии и направлять ее вывод в файл на диске. 
я сделал дебаг этой функции в реальном скрипте вот что внее прилетает в реальности как аргументы
    \x77\x8d\x1b\x86\xbe\x19\x5d\xae\x8c\xb0\x16\x88\xe8\x1b\xe7\x79
тоесть стринг в hex формате
значит вот эта хрень она заменяет буквы на их заглавные версии
    $ tr a-f A-F <<< "\x77\x8d\x1b\x86\xbe\x19\x5d\xae\x8c\xb0\x16\x88\xe8\x1b\xe7\x79"
    \x77\x8D\x1B\x86\xBE\x19\x5D\xAE\x8C\xB0\x16\x88\xE8\x1B\xE7\x79
а вот эта хрень она убирает из стринга "\x"
    $ sed -e 's/\\x//g' <<< "\x77\x8D\x1B\x86\xBE\x19\x5D\xAE\x8C\xB0\x16\x88\xE8\x1B\xE7\x79"
    778D1B86BE195DAE8CB01688E81BE779
нахер это надо. а это надо чтобы подсунуть эту херню в bc потому что он формат hex понимает 
только в виде
    778D1B86BE195DAE8CB01688E81BE779
таким образом команда 
    echo 'ibase=16;'
высирает на stdout строку 
    ibase=16;
причем вконце добавляет знак переноса строки
остальные команды высирают 
    778D1B86BE195DAE8CB01688E81BE779
тоесть суммарный высер в stdout выглдяит так
    ibase=16;
    778D1B86BE195DAE8CB01688E81BE779
и далее этот stdout перенаправляется в bc
далее насколько я понимаю в bc по дефолту obase=10 тоесть он по умолчанию 
число преобразует в dec формат поэтому это не указано. в итоге функция в конце делает 
вот такой эквивалент
    $ echo -e "ibase=16;\n 778D1B86BE195DAE8CB01688E81BE779"  | bc
    158910803655924292489198456294474508153
самое смешное это где находится знак переноса строки. и bc это устраивает. это реальный прикол.
итого физ смысл этой функции состоит в том что на входе ей скармиливается стринг в формате hex
мы его преобразуем в формат hex который понимает bc и оне это число траснформирует в dec формат
фнукция называется hexToInt  , я считаю что более правлно было бы ее назвать hexToDecInt
кстати и козлу понятно что число это целое. 

    
рассмотрим соедующую функцию
###################
base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}
##################

в эту функцию в реальном скрипте прилетает строка аргументов вот такая

22 \xeb\x1c\x96\x8c\x74\x73\x01\x00\x88\x79\xcb\xf2\xac\xce\x7c\x02 11 4 10 5 3 9 15 2 8 14 1 7 13 0 6 12

значит разбираем как она работает
вот эта хрень "22" улетает  в переменную $n
далее аргументы сдвигаются и строка аргументов теперь выглядит как

\xeb\x1c\x96\x8c\x74\x73\x01\x00\x88\x79\xcb\xf2\xac\xce\x7c\x02 11 4 10 5 3 9 15 2 8 14 1 7 13 0 6 12
далее берется эта строка аргументов и суется в функция getBytes.
этот getBytes согласно тому что я про нее разобрал выше. всего навсего берет и из первого аргумента
вырезает hex числа те который указаны по счету в остальных аргументах. причем числа немеруются с нуля
а не единицы. тоесть "\xeb" это число номер ноль. а не число номер 1. "\x1c\" это число номер 1.
и так далее.тоесть в данном случае
из первого аргмуента будут вырезаны 11,4,10,5 итд числа. еще раз почеркну что 11 это не номер символа
(офсета) в первом аргументе а номер всего hex числа(причем hex числа нумеруются с нуля а не единицы).
тоесть если указано 11 значит начало этого числа
его оффсет это 11*4. оффсет тоже нумеруется с нуля.
длинна числа это 4 байта. поэтому 11-е число это "\xf2". итого getBytes
возвратит
    \xf2\x74\xcb...
и так далее. 
вот что показывает выполнение реально программы что возвратит getBytes
    \xf2\x74\xcb\x73\x8c\x79\x02\x96\x88\x7c\x1c\x00\xce\xeb\x01\xac
дальше эта хрень кидается на функцию hexToInt. как описано выше 
она превращает аргумент вот в такой вид
    F274CB738C790296887C1C00CEEB01AC
и потом бросает его в bc и в конечном итоге возваращает его в dec виде тоесть
    322279607899402105297866753734997639596
дальеш запускается функция intToBase64 вот в такое виде
    intToBase64 322279607899402105297866753734997639596 22
где 22 это хрень которая у нас хранилась в $n
в описании к intToBase64 я расписал что она делает. она берет исходное десятичное число
и конвертирует его в наборр символов согласно словаря. это некая изврашеннаая форма кодировки base64.
но конечно по какотому совершенно другому алгоритму.
    g4kuC1.5wVcZ0Y5XnhARm1
таким образом суммарно что делает вся эта функция:
    в нее поступает число в hex формате в размере 16 hex чисел. и далее указан порядок на основе
    которого их нужно переставить. эти 16 чисел  переставляются местами. и потом это новое 
    16 байтовое число конвертирется в изврашенной форме в некое подобие кодировки base64
    из которой получается 22 печатных символа
    эти 22 печатных символа и есть резултат на выходе из функции
        g4kuC1.5wVcZ0Y5XnhARm1   <== 22 символа печатных


далее рассмотрим вот такую хрень

#########
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes
################
во первых в чем разница между высчитыванием длинны стринга через 
    wc -c
и
    awk '{print length}'
значит wc -c он суммирует и байт '\n' отвечающий за enter
а awk его не учитывает.
показываю на примере
    $ printf "vasya\n" | wc -c
    6
    $ printf "vasya\n" | awk '{print length}'
    5
как говорится почувствууй разницу

далее разбираем строку 
    [[ -z $magic ]] && magic='$1$'

-z string =   True if the length of string is zero.

поэтому данная хрень возвращает true если переменная не была определена.
тоесть вся строка целиком говорит о том что если перееная была не определена 
то мы ее задаем

глядя на $1 подумал про аргументы скриптов. и узнал вот такую хуйню непоняьную
пример
    $ cat 10.bash 
    #!/bin/bash

    a="$3"
    echo "a=$a"

    b=$10
    echo "b=$b"

    c="$10"
    echo "c=$c"

    d="${10}"
    echo "d=$d"

    $./10.bash 1 2 3 4 5 6 7 8 f aaa
    a=3
    b=10
    c=10
    d=aaa

из примера видно вот что. если мы указваем аргумент вызоыва скрипта состоящий из одной цифры
в данном случае $3 то его значение "3" абсолютно верно засасывается в переменную.
а если у нас имя аргумента вызова скрипта из двух цифр то обе записи
    b=$10
    c="$10"
засасывают значение $10 совершенно неправильно. почему незнаю. пиздец какойто.
единственно раблтающий вариант это 
    d="${10}"
тоесть это совершенно не похоже как это есть с обычными переменными. тоесть у нас же нет проблем
вот с такой переменной
    $ ddd=4
    $ echo $ddd
    4
    $ echo ${ddd}
    4
и так и так работает.
ксатти ответ на вопорс сколько аргуметов можно в баше послать в скрипт. 
вроде вот столько
    $ getconf ARG_MAX
    2097152

еще один прикол покажу. скажем мы хотим задаваь имя переменной не в форме константы а через другую
переменную. например 
    $ b=1
    $ a=b
    $ echo переменную имя которой хранится в переменной a
так вот это делаетяс вот так
    $ a=1
    $ b=a
    $ echo ${!b}
    1
офигеть
возвращаемся обратно к нашему куску кода
#########
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes
################
а именно
    magic="$3"
    [[ -z $magic ]] && magic='$1$'
возникает вопрос если переменная не задана в нашем случае $3 то какое значение
примет magic. ответ это стринг нулевой длинны
    $ echo -n $dfg | od -t x1
    0000000
вот видно что на выходе ноль байт. 
поэтому 
    [[ -z $magic ]] 
выдаст true
тоесть если $3 незадана то
    magic="$3"
анаолгичен
    magic=""
потому что 
    $ magic=""
    $ echo -n $magic | od -t x1
    0000000

разбираем эту хуйню
    salt=${salt#'$1$'}
как я понимаю как эта хрень работает
она работает так. она говорит, возьми $salt и отрежь от начала этого стринга то что указано 
после # по шаблону. шаблон в данном случае '$1$'
возьмем пока более простой однозначный шаблон
    $ b="aBaC"
    $ echo ${b#a}
    BaC
    $ echo ${b#'a'}
    BaC
    $ echo ${b#"a"}
    BaC
отсюда понятно что шаблоны
    a
    'a'
    "a"
это одно и тоже а кавычки это просто служебные символы
двигаем дальше
    $ b='$a45'
    $ echo $b
        $a45

    $ a='123'
хотим вырезать $ из $b. пробуем подставить просто $ после #
хотя по идее $ это служебный символ и баш нас должен послать нахер
однако почеуто баш непосылает и реально у нас успешно вырезается доллар
    $ echo ${b#$}
        a45

теперь хотим вырезать '$a' из переменной $b. просто добавляем a после $
однако тут облом. баш воспринимает наш шаблон не как набор литер $+a а как то что у нас в шаблоне
указано имя переменной $a значение из которой и надо удалить из $b
поскольку переменная a=123 то из $b нихрена не удаляется
    $ echo ${b#$a}
        $a45
заменяем значение переменной a
    $ a='$a4'
еще раз пробуем удалить из b то что сохранено в a
и успех
    $ echo ${b#$a}
        5
вывод. чтобы быть точно уверенным что спецсимволы в шаблоне не будут тракотованы как спецмиволы
лучше предохраниться и указать спецсимволы в ''
тоесть вместо такого
    $ echo ${b#$}
    a45
лучше вот так
здесь четко видно что доллар у нас просто литера в шаблоне
    $  echo ${b#'$'}
    a45
итак еще раз что значит такая запись. она занчит что мы просим баш вырезать из переменной b 
с ее начала смиволы которые указаны в шаблоне. шаблон указывается после символа #
шаблон должен точно совпадать с символами вначале стринга. если шаблон совпадает где то 
только посреедине нихера вырезано неудет. пример
    $ a='a123b'
    $ echo ${a#123}
    a123b
    $ echo ${a#a123}
    b
в шаблоне можно юзать спецсимволы
    * - любой количество символов
    ? - один любой символ
еше пример
    $ echo ${a#*2}
    3b
    $ echo ${a#??}
    23b
есть еще одна штука вот так выглядит ${VAR##pattern}
    $ a='aaaa СЫР bbbbb СЫР сссс'
    $ echo ${a#*СЫР}
    bbbbb СЫР сссс
    $ echo ${a##*СЫР}
    сссс
    
значит в чем прикол у нас шаблон
    *СЫР
который означает "любое количество символов+СЫР"
когда мы ссмотрим на стринг 
    aaaa СЫР bbbbb СЫР сссс
то у нас этому шаблону удовлетворяет два варианта
    aaaa СЫР
    aaaa СЫР bbbbb СЫР
и какой из них брать?
так вот хрень ${VAR#pattern} она вырезает меньший по размеру кусок
а хрень ${VAR##pattern} вырезает максимально большой возможный
поэтому на экране видим то что получили

далее еще прикол. если ${VAR#pattern}\${VAR##pattern} вырезают с начала стринга
то ${VAR%pattern}\${VAR%%pattern} вырезают с конца стринга
    $ a='aaaa СЫР bbbbb СЫР сссс'
    $ echo ${a%СЫР*}
    aaaa СЫР bbbbb
    $ echo ${a%%СЫР*}
    aaaa

возвращаемся к нашему примеру
    salt=${salt#'$1$'}
значит тперь понятно что он делает. из переменной salt мы хотим вырезать 
литеры $1$
покажу на примере
    $ salt='$1$abcd'
    $ echo ${salt#'$1$'}
    abcd

двигаем дальге. теперь вот эту херню рассмотрим
    salt=${salt:0:32} # 8 first bytes
понятно что она вычленяет из переменной первые 32 символа.
возникает только вопрос а что будет если длинна salt меньше чем 32 символа
как видно из эксперимента если длинна переменной меньше чем 32 символа 
то будет напечатано то число символов сколко есть. если есть 10 символов будет 10 символов
    $ a="123456789|123456789|123456789|123456789|"
    $ echo ${a:0:32}
    123456789|123456789|123456789|12
    $ b="123456789|"
    $ echo -n ${b:0:32}
    123456789|
    $ echo -n ${b:0:32} | od -t x1
    0000000 31 32 33 34 35 36 37 38 39 7c
таким макаром весь вот этот кусок
#########
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    magic="$3"
    [[ -z $magic ]] && magic='$1$'

    salt=${salt#'$1$'}
    salt=${salt:0:32} # 8 first bytes
################
разобран

теперь переходим к разбору куска
###################
intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )
##########

рассматриваем рой хуйни
во первых двойные скобки возвращают всего навсего 0 или 1 
тоесть это оператор логический. если внутри скобок 0 то код возврата $?=False тоесть 1.
если внутри скобок неноль то код возврата True тоесть  0
вот такая запутанная хуйня
пример
    $ (( 0 )); echo $?
    1
    $ (( 1 )); echo $?
    0
    $ (( 100 )); echo $?
    0
    $ (( 5>4 )); echo $?
    0
    $ (( 5<4 )); echo $?
    1
но это только начало пиздеца
если мы хотим узнать что внутри скобок то надо делать тгда вот так
    $ echo $(( 5 ))
    5
    $ echo $(( 5+3 ))
    8
и это совсем другая хуйня к логическим операторам неимеющая никакого отношения.
теперь переходим к операциями над числами на битовом уровне.
как нам подвинуть в числе все биты на 1 направо. а вот так
    $ echo $(( 5>>1 ))
    2
действтиельно 5=101, двигаем на один бит вправо получем 010 а это 2
далее положим мы хотим подвинуть биты у переменной а не у константы
команда выглядит также
    $ let a=5
    $ echo $a
    5
    $ echo $(( a >> 1 ))
    2
или есть еще один вид синтаксиса
    $ echo $(( a >>= 1 ))
    2
а далее небольшой пиздец. команда ">>=" работает только для сдвига в переменной.
а вот для сдвига в константе уже пошел нахуй
    $ echo $(( 5 >>= 1 ))
    bash: 5 >>= 1 : attempted assignment to non-variable (error token is ">>= 1 ")
таким образом чтобы незапоминать эту хуйню я предлагаю и для переменных 
и для констант использовать всегда то что работает для них обоих тоесть ">>" и не ебать мозги
    $ echo $(( 4 >> 1 ))
    2
    $ b=4
    $ echo $(( b >> 1 ))
    2

таким образом я перехожу к строчке
    for ((i=$passwordLength; i != 0; i>>=1)) 
по русски это команда значит запустить цикл от $passwordLength до 0 (ноль не включается) с шагом
таким что каждое следующее число получается из предыдущего путем сдвига i на 1 бит вправо. пример 
пример
$ for(( i=64; i !=0; i>>=1 )); do echo $i; done 
64
32
16
8
4
2
1

самое странное что если  я заменю 
    i>>=1
на
    i>>1
то получится какая херня. цикл будет работать бесконечно. тоесть бит почемуто не сдвигается.
ебанизм.

теперь понятно почему двойные скобки (( )) употребялюся в for
потому что для головы for всего навсего надо знать true или false. а (( )) как раз сообщают 
ему именно это. тоесть внутри (( )) производится арифметический расчет. наружу выдается true или false
потому что для for похер что там внутри конкртено получилось. если true то он выполняет то что 
пропсано в do.  а если false то цикл заканчиватеся. 

теперь расматриваю такой код
    $ (( 0 & 1 )); echo $?
    1
    $ (( 1 & 1 )); echo $?
    0
    $ (( 2 & 1 )); echo $?
    1
    $ (( 3 & 1 )); echo $?
    0
    $ (( 4 & 1 )); echo $?
    1
    $ (( 5 & 1 )); echo $?
    0
как эта хрень работает. знак & означает битовый AND. по англицки bitwise AND.
при битовом AND берется два с одинаковым офсетом бита в двух числах и сравниваются. 
если оба равны 1 то в суммарном числе этот бит тоже 1 иначе 0
к чему это приводит. вот у нас второе число всегда 1 . запишу его в двойчном виде
   0000 0001
поскольку у него биты с 7-го по 1-ый равны нулю то какое бы ни было первое число у суммарного
числа эти биты всегда будут тоже 0. поскольку нулевой бит равен 1 то если у первого числа 
этот бит равен 1 то и суммарное число будет тогда иметь этот бит 1. а если у первого числа этот бит 0 
то и у суммарного числа этот бит 0. теперь вот что поймем - если у нас есть произвольное число и у него
нулевой бит равен 1 это о чем нам говорит. о том что это число 100% нечетное. а если оно у него ноль
то это 100% четное число. тогда мы получаем вот такую диаграмму
     первое число нечетеное & 1  = 0000 0001 = 1 dec
     первое число четное    & 1  = 0000 0000 = 0 dec
подставляем эту хрень в двойные скобки
    (( неч & 1 )) = (( 1 ))
    (( чет & 1 )) = (( 0 )) 
во втором случае так как у нас внутри 0 то результат FALSE это значит код возврата $?=1
в  первом случае так как у нас внутри неноль то результат TRUE значит код возврата $?=0
итого суммарная таблица
    $ (( неч & 1 )); echo $?
    1
    $ (( чет & 1 )); echo $?
    0
таким макаром эта хрень может использоваться для определения число у нас
четное или нечетное


теперь рассматриваю такой код
    for(( i=170; i !=0; i>>=1 )) 
    do 
        echo "i=$i" 
        (( i & 1 )) 
        echo $?
    done 

или в однострочном виде
    $ for(( i=170; i !=0; i>>=1 )); do echo "i=$i"; (( i & 1 )); echo $?; done 
    i=170
    1
    i=85
    0
    i=42
    1
    i=21
    0
    i=10
    1
    i=5
    0
    i=2
    1
    i=1
    0
значит сам индекс цикла i это число которое проходит от 170 и до 0 с шагом таким что 
каждое следущее получается из преддыдущего путем битового смещения на 1 вправо.
при этом для каждого i проводится тест четное число или нечетеное.
пиздец.таже рассмотрим число 170 в двоичном виде
    10101010
очевидно что количество сдвигов пока мы достигнем нуля будет равно тому количеству сдвигов
чтобы самый старший бит числа дошел до нулевого оффсета.
показываю
    0(номер сдвига)   10101010 <== исходное число
    1                 01010101 
    2                 00101010
    3                 00010101
    4                 00001010
    5                 00000101
    6                 00000010
    7                 00000001
    8                 00000000
в данном случае мы имеем 7 сдвигов от начального числа до единицы.
самый старший бит у нас имеет оффсет 7.
получается чтобы данное число превратить  в единицу нужно ровно столько сдвигов сколько 
номер оффсета у старшего установленного бита этого числа.

пример 
$ for(( i=224; i !=0; i>>=1 )); do echo -n "i=$i  "; echo "битовый вид = $(echo "obase=2; $i" | bc)"; done 
i=224  битовый вид = 11100000
i=112  битовый вид = 1110000
i=56   битовый вид = 111000
i=28   битовый вид = 11100
i=14   битовый вид = 1110
i=7    битовый вид = 111
i=3    битовый вид = 11
i=1    битовый вид = 1

самый старший бит у 224 имеет оффсет 7
мы видим что чтобы 224 превратить в 1 нужно 7 передвижений.
    
поскольку у нас в исходном условии
    for(( i=224; i !=0; i>>=1 ))
указано что мы идем от нашего исходного числа до нуля но ноль запрещен
то суммарное количество циклов будет 7+1

теперт после всех этих мытарств рассмотрим этот кусок из реального скрипта
##################
        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done
##############
теперь наконец стало понятно то что написано в его описании
        For every 1 bit in the key length, add a 0.
        Otherwise add the first char of the key.
что он делает. он берет переменную равную длинне пароля. это какое число 
скажем 5. длинна пароля 5 символов.
это число присваивается переменной i.
внутри цикла происходит тест на то что если i это нечетное число. 
если число нечетное то это значит что у него установлен бит в оффсет 0.
так вот если оно нечетное то печатается байт '\x00' 
а если число четное тоесть если бит в оффсете 0 равен 0 то печатается первый байт из пароля.
на следующем этапе цикла число i сдвигается на 1 бит вправо. таким образом двигая биты числа i
вправо через цикл мы перебираем все биты исходного числа i и понимаем установлены ли они или нет.
в зависимости от того установлен ли бит или нет мы печатаем на экране либо '\x00' либо первый байт
из пароля. все тело цикла подчинено исходной задаче которая очевидно состоит в том что 
надо взять число равное длинне пароля.  преобразовать его в битовый вид. и на основе этого 
напечатать на экране последовательность байтов. если соответвущий бит установлен то печатаем один байт.
если бит не установлен то другой байт. и так для всего этого числа.
по факту мы этой программой проверяем выставлен ли у числа i его младший бит. 
потом двигаем биты направо и опять проверяем выставлен ли младший бит.
таким макаром мы пробегаем байт от оффсета 0 до макс оффсета.
вот точно такая  программа.
если в оффсете 0 быт равен ноль то я печатаю на экране ноль.
а если не ноль то печатаю единицу.
$ for(( i=1; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
1
$ for(( i=2; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
01
$ for(( i=4; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
001
$ for(( i=128; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"   ; done; echo ""
00000001

таким образом мы без программы bc получаем на экране двоичное представление числа.
единственное что оно выглядит непривычно потому что мы пробегаем биты у числа с младшего бита
к старшему. поэтому на экране первыми печатаются младщие биты а последними старшие. 
и экране терминал так устроен что у него символы с младшим оффсетом (те которые были напечатаны по времени
более первыми) находятся слева. а символы которые он печатает более поздно по времени находятся справа.
поэтому результат на экране логичен. просто дело в том что при записи битового вида числа на бумаге
мы используем написание по правилу BigEndian. Мы пишем слева направо но первым пишем самый старший 
бит в байте. а когда у нас работает цикл то он начинает печатать на экране начиная с самого младщего 
бита на экране. поэтому на экране мы получили зеркальное отражение того как это должно 
быть когда мы пишем на бумаге. поэтому надо еще зеркально отразить.
и тогда
$ for(( i=128; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done | rev; echo "" 
10000000
$ for(( i=15; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done | rev; echo "" 
1111
$ for(( i=192; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done | rev; echo "" 
11000000

можно еще вот так подкрасить вид чтобы было более легко и логично смотреть
$ ( for(( i=192; i !=0; i>>=1 )); do  (( i & 1 )) && echo -n "1" || echo -n "0"; done ) | rev; echo "" 
11000000

таким образом вот этот кусок теперь понятен
##################
        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done
##############
интересно что в этом  куске обработка битов в i начинается с младшего бита.
и не совсем понятно так и было задано в изначальной задаче? ведь можно было начать обрабатывать
биты со старшего бита. и тогда последовательно символов которые печатаются будет зеркально выглядеть.

теперь надо еще вот такой кусок разобрать
#################
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"
################
переделвыаю цикл в аналогичный и в однострочный вид
    $ while printf "vasya" 2> /dev/null; do true; done | head -c "1"

значит что делает цикл while. он печатает на экране слово 'vasya' причем бесконечно и непрерывно.
тоесть на экране будет
    vasyavasyavaysvaya...
и так до бесконечности
тоесть еще раз цикл печатает слово, потом еще раз его печатает  и так до бесконечности
далее
    head -c "1"
хед берет первый байт этого потока и печатает

и тут мы получаем очень интересное явление. что если запустим только цикл то цикл бесконечно
будет выполняться и будет бесконечно печатать на экране 'vasya'
но как только мы к нему добавим '|head -c "1"' то код целиком выполнится мгновенно. мы увидим на экране
всего один символ 'v' и дальнейшее исполнение кода прекратится.
возникает два вопроса:
    зачем на цикл
    почему при добавлении '|head -c "1"' цикл прерывается а не работает до бесконечности
на счет первого вопроса - почему вместо цикла не вставить вот такое более простое выражение
    $ printf "vasya" 2> /dev/null | head -c "1"
ведь мы получим тоже самое. оказывается как я подумал дело в том что если слово 'vasya' короткое
а в head стоит большое число например 'head -c "20"' то у нас просто тогда нехватит длинны слова 'vasya'
а если у нас цикл то у нас "-c X" может быть каким угодно большим . показываю на примере
    $ printf "|vasya|" 2> /dev/null head -c "30"
    |vasya|[vasya|
    $ while printf "|vasya|" 2> /dev/null; do true; done | head -c "30"
    |vasya||vasya||vasya||vasya||v
вот зачем нужен именно цикл!

второй вопрос тоже очень интересный. еще раз посмотрим на что похож вывод на экран у цикла
    $ while printf "vasya" 2> /dev/null; do true; done | head -c "2000"
    vasyavasyavasyavasyavasyavasya
    vasyavasyavasyavasyavasyavasya
    vasyavasyavasyavasyavasyavasya
    vasyavasyavasyavasyavasyavasya
    ...
он похож на чтение из текстового файла. очень большого текстового файла. пофакту бесконечно 
большого текстового файла.
тогда наш код вобщем то похож на другой код
    $ cat 1.txt | head -c 1
далее можно вспомнить что при чтении очень большого файла и при выполении данного кода
нам не приходится долго ждать. тоесть нам не приходится ждать когда "cat" полностью прочитает
файл чтобы только потом передать его на head. результат получается мгновенно. 
я об этом вопросе незадумывался. интуитивно казалось что должно работать так. вначале cat полностью
читает первый файл. и только потом он его начинает передавать в stdout. и так как обычно читаются
небольшие файлй то поэтому и не приходится долго ждать. очевидно я был неправ. тут надо вспомнить
из C или наверное и питона как организовывается чтение файла. поскольку я это делал через программирование
пару раз то поэтому я и забыл и думал неправильно. а чтение работает так - мы открываем файл на чтение.
и мы задаем чтение определенными кусками мы читаем кусок. чтото с ним делаем. потом читаем следуший кусок.
поэтому очевидно что cat читает из огромгого файла кусочками. прочита первый кусочек  я думаю это максимум
сколько то килобайт он его высирает в stdout. тут же отрабатывает head и поэтому мы видим результат
мгновенно. чтото похожее имеет место и для while+printf+head. тоесть во первых у нас будет три процесса.
один процесс это баш в котором крутится while , второй процесс это printf, третий процесс это head.
значит баш процесс запускает while. который в свою очередь запускает процесс с printf. тот высирает
на stdout "vasya" и вобщем то тут же этот процесс и подыхает. при этом процесс с head тоже уже запущен 
и его через сисколл соотвествующий ждет от ОС сигнала что на его stdin чтото уже поступило. вобщем пускай
даже while отработает какое то количество раз прежде чем сработает шедулер. шедулер точно сработает
очень быстро. он увидит что для head есть входящая информация в буфере на его stdin и поэтому шедулер
останвоит баш и запустит head. head отработает и высрет нам результат и закончит тут же свой процесс.
поэтому нам не придетя ждать бесконечность чтобы отработал head. тут я разобрался с вопросом почему
head отрабатыает быстро если у нас цикл бесконечный. ... прикол... 
остается еще один вопрос если у нас есть скажем две команды в пайпе
    $ comm1 | comm2
и предположим что команда2 отраотала и вышла закончила свой процесс то почему при этом
и команда1 тоже сраза заканчивает свой процесс?
ведь очевидно что 
    $ while ...  ; do ..; done | head ...
как только head процесс исчезает то сразу убивается и процесс с while.
я тоже никогда на эту тему не думал. 
точнее я думал примерно так напримере скажем этой команду
    $ cat 1.txt | grep vasya
я раньше думал что вначале полностью отрабатывает cat и умирает а потом полностью отрабатывает grep
и умирает. поэтому все чик пибабум.однако очеивдно как стало понятно это было неверное рассуждние.
я щас полагаю что дело вот в чем, - pipe "|" это всего навсего грубо говоря директива управления 
для баш. она позволяет человеку обьяснить баш что мы от него хотим. если мы пишем в баш вот так
    $ comm1 | comm2
то это говорит баш вот что. запусти два новых процесса. comm1 и comm2
при запуске сделай так что stdout одного смотрел на stdin второго
также важно понять что оба процесса будут дочерними для нашего головного баша. поэтому в баше
есть обработчик событий происходящий с его дочерними процессами! дело в том что когда процесс comm2
сам себя уничтожит (через сисколл к ядру конечно) то ядро пошлет родительскому процессу то есть 
головному бащу сигнал SIGCHLD(както такой) которыйй сообщает голоновму башу что один из его дочерей сдох
и тогда баш имея в себе обработчик этих событий понимая что один их процессов в пайпе сдох он 
как я понимаю тогда берет и уничтожает все остальные процессы которые были им запущены в рамках этого 
пайпа! вот как оно работает походу. поэтому прекращение работы head вызывает то что баш получает 
об этом сигнал и тут же уничтожает процесс с while. поэтому цикл тоже прекрашает работать мгновенно
офигеть.
да... уж... система нипель
а ведь интутиция гвоорила что цикл будет раобтать бесконечно и до head информация никогда не долетит..
ужас.
с этим куском разобрались.
переходим наконец теперь к следущему куску.
###################################
intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )
##################################
и также помещу здесь что за кусок md5hex
md5hex() { 
    sum=$(md5sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}
##########################################
так что касается md5hex то как было разобрано выше в нее прилетает стринг
она вычисляет от него md5sum классчиеский 
и на выходе она выдает этот MD5 в таком виде
    \x67\xf6\x6d\x5f\x0d\x8b\x38\x97\x0f\x71\xaf\xd4\x3f\x83\xc6\x23

перерходим к разбору главной функции
значит главным образом intermidiate выглядит так
intermediate=$({...} | md5hex )
тоесть вычисляется некая хрень пуляется на md5hex и результат stdout будет запомнен
в intermediate. понятно
скобочки {} нужно лишь для того чтобы некую портянку кода визуально обьеденить
в один кусок. потому что как сказано в баше мане скобки {} в таком случае не играют никакой
функциональной роли а просто визуальный украшатель. рассмотрим эти скобочки


{
        # Start intermediate result
        printf "$password$magic$salt" 

        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    }
    
первая команда просто печатает в stdout символы  
    "$password$magic$salt"
вторая команда берет стринг $password$salt$password вычисляет от него md5 преобразует его
в в вид \xab\xbc итд и запоминает в $alternate
следущая команда печатает на экране из этой алтернейт переменной несколько байт. несколько это 
значит столько сколько длинна пароля. итак в stdout у нас уже будет
    "$password$magic$salt""какой то кусок альтернейта"
последний кусок кода я тоже уже разбирал. он берет число являющееся длинной пароля. тоесть если 
длинна пароля 8 то он берет число 8. и анализирует его двоичный вид написания. тоесть еэто
    0000 1000
и он печатает в stdout 8 байтов. для каждого бита выбирается байт. если в бите ноль то байт печатается
00h а если бит равен 1 то байт печатается равный первому байту из пароля, пусть он равен A1h
тогда на stdout печатается
    00h00h00hA1h00h00h00h00h
причем печать символов начинается с бита с нулевым оффсетом (поэтому с точки зрения отображения битов
в символы порядок на экране будет обратный. об этой ебале подробно расписывал выше при разборе этого
куска кода так что ищи там). в итоге у нас суммарно в stdout будет вот такая шняга
    "$password$magic$salt""какой то кусок альтернейта"00h00h00hA1h00h00h00h00h"
ну и как я сказал выше этот стринг пуляется на md5hex который от него считает классический MD5
преобразощывает высер в вид \xab\xbc\x1a.... высирает это в stdout
и оно будет запомнено в intermediate переменную. жесть.

теперь разбрем этот кусок
#########################
for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done
###############################

значит это цикл на 1000 раз . от 0 по 999 вкчлючительно
разберем вот эти хрени
        (( i & 1 )) &&
        (( i % 3 )) &&
        (( i % 7 )) &&

во первых еще раз как работает двойная скобка (( )) она вычисляет арифметику внутри скобки.
и в завимисти какое итоговое число получилось внутри скобки возвращает в коде возврата $? число
0 или 1. если в скобке получилось 0 то код возврата 1( что эквивалентно булевому False)
а если в скобке получислся неноль то код
вовзрата 0(булевый True). вот такая канаебка
итак первая скобка (( i & 1 )) тестирует если i нечетное. тогда скобка возвращает $?=0(True) 
и поэтому выполняется команда за &&
вторая скобка (( i % 3 )) вычисляет остаток от деления на 3 , если остаток нулевой возврашает $?=1
и поэтому то что за && не выполняется. 
пример
    $ (( 6 % 3 )) && echo "число НЕ делится на 3" || echo "число  делится на 3"
    число  делится на 3
    $ (( 7 % 3 )) && echo "число НЕ делится на 3" || echo "число  делится на 3"
    число НЕ делится на 3
таким образом вторая скобка проверяет что число НЕ делится на три и тогда выполняет то что за &&
третья скобка проверяет что число НЕ делится на 7  и если это так то выполняет то что за &&

теперт рассмотрим эту хрень целиком
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
если i нечетное то на экране ( в stdout) печатается "$password" иначе печатается "$intermediate"
если i неделится на 3 то далее печатается "$salt"
если i неделится на 7 то далее печатается "$password"
если i нечетное то далее печатается $intermediate иначе печатается $password
возьмем для примера что i=10 тогда у нас будет напечатано
    "$intermediate""$salt""$password"$password

теперь рассмотрим эту хрент
       intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
 
 значит получили мы портиянку на экране
    "$intermediate""$salt""$password"$password
далее она направляется в функцию md5hex которая от нее вычисляет MD5 и преобразует вид
в 
    \xab\xbc\x1a...
и эта хрень запоминатся в переменную    $intermediate
таким образом каждый цикл меняет содержимое перменной $intermediate
содержимое как видно меняется в завимости от предудещего значения $intermediate 
от salt, password, i. тоесть бы сказал то 
    intermediate(i)=f(intermediate(i-1),i,salt,password)
    
теперь рассмотрим этот кусок
################
    for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done

    # Rearrange the bytes and crypt-base64 encode them
    encoded=$(base64EncodeBytes 22 "$intermediate" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

    printf "%s$salt\$%s\n" "$magic" "$encoded" 
###############

значит у нас мусолится цикл. и на выходе мы будем иметь в $intermidiate некую хрень вида
    \xab\x1a\x12...
далее этот $intermiadite вместе с друими константами посылается в функцию base64EncodeBytes
эта функция на основе того что я о ней разбирал выше делает вот что. она принимает 
в берет стринг 
    \xab\x1a\x12...
который мы в нее послали через $intermidaite перстааляет в нем местами эти hex 
числа. и перекодирует их в некий изврашенный аналог base64 который назовем B64.
однако этот B64 нетолько имеет словарь отличый от base64 но и сам алгоритм трансфорирмирования
чудовищно отличаается от классичекого base64
ну и на посленем этапе
        printf "%s$salt\$%s\n" "$magic" "$encoded"
у нас на жкране печатаеся искомый результат. тоесть печатаектся тип хеша,
salt, и так называемый хеш в кодировке B64
значит в этой команде тоже не обошлось без подьебок.
можно заметить что вунтри поля формата стоит  $salt тоесть переменная 
упоминаетсся в поле формат но в непривычном виде. тоесть мы же как привыкли
мы привыкли что переменная вставляется в поле формат вот в таком виде
    $ a=123
    $ printf "%d %d %d \n" "1" "2" "$a"
    1 2 123 
то есть внутри поля формат мы вставляем хреновины вида %d скажем
а снаружи формата мы указываем переменные через пробел
однако оказывается что можно указать переменную сразу в поле формат прям внутри
ровно так как мы это делаем в echo
    $ a=123
    $ printf "$a \n"
    123 
вовзаррашаемся к нашему примеру
        printf "%s$salt\$%s\n" "$magic" "$encoded"
в нем в поле формат через %s идет обраение к переменной $magic
потом напрямую в поле формат указана переменная $salt ,
потом экранирован символ \$
тоесть
    $ printf "\$ \n"
    $ 
потом идем обращение к переменной $encoded через %s и знак переноса строки \n
так вот возникает вопрос а как бы нам избавить от $salt в поле формат и вынести его наружу
туда же где стоят $magic и $encoded
и тут выянсяется очередная хуета относиительно printf,
значит переменная $salt равна чтото типа того 
    $salt="\x31\x32\x33"
так вот принтф имеет вот такую штуку как он работает
    $ salt="\x31\x32\x33"
    $ printf "$salt \n"
    123 
или вот так
    $ printf "\x31\x32\x33  \n"
    123  
охуеть да?
но возникает вопрос а что писать в поле формат если мы $salt вынесем за поле формат?
показываю на примере
    $ salt="\x31\x32\x33"
    $ printf "%d  \n" $salt
    bash: printf: \x31\x32\x33: invalid number
    0  
    $ printf "%s  \n" $salt
    \x31\x32\x33  
    $ printf "%c  \n" $salt
    \  
тоесть все совершенно не то. и нихуя непонятно. и тольк в одном месте
я нашел как надо сделать
    $ printf "%b  \n" $salt
    123  
охуеть....
вообще в bash.txt  я создал отдельную тему "| printf" про то как он работает и его заебы.
таким образом вот эту хрень 
            printf "%s$salt\$%s\n" "$magic" "$encoded"
можно переписать вот так , чтобы было более единообразно
            printf "%s%b\$%s\n" "$magic" "$salt" "$encoded"
охуеть с этим принтф

таким образом я почти закончил разбор как этот скрипт работает.

итак
последний кусок в скрипте 
##############################
if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 

doHash "$password" "$salt" '$1$'
######################################

if [[ $# < 1 ]]  
это означает "если количество параметров переданных скрипту меньше 1 (тоесть ноль) то ..."
пример
    $ cat 10.bash 
    #!/bin/bash

    echo \$0=$0
    echo \$#=$#

    $ ./10.bash  1 2
    $0=./10.bash
    $#=2

итак $# - означает переменную которая показывает число аргументов переданных в скрипт
     $0 - означает путь к скрипту на ФС

далее строчка
        echo "Usage: $0 password [salt]" >&2
мне непонятно какой смысл
    >&2
потому что оно значит 
    1>&2
тоесть стандартный вывод перенаправляется туда куда вываодятся ошибки. зачем так делать неясно

далее строчка
    password=$(stringToHex "$1")
    salt=$(stringToHex "$2")

в $1 у нас в аргументах скрипта пароль , $2 это в аргументах скрипта это salt
функция stringToHex берет входной стринг, находит для его стрингов ascii коды, преобразует эти коды в hex вид виде \x21
и возвращает исходный стринг в форме ascii кодов в hex формате
итак эти две строчки превращают стринги в ascii коды. коды представляются в hex виде \x21
    стринги --> ascii коды
тоесть для примера
    если $1="parole" 
    то   password=$(stringToHex "$1")="\x70\x61\x72\x6f\x6c\x65"

далее строчки
    salt=$(stringToHex "$2")
    [[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 
вторая строчка означает то что "если длина стринга $salt равно 0 то ... "
итак если длина $salt равно 0 то 
    salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8)
тогда рассмотрим подробно
    tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8
рассмотрим подробно только tr
tr имеет синтакс 
    tr ключи SET1 SET2
SET1 и SET2 это некий набор символов.
значит tr без ключей но с SET1 и SET2 берет исходный стринг ищет в нем те символы которые 
в SET1 и меняет их на те что в SET2. 
пример
    $ echo "1a2b3" | tr   "ab" "cd"
    1c2d3
тоесть tr ищет в "1a2b3" символ "a" и меняет его на "c",
и ищет символ "b" и меняет его на "d"
то есть tr делает вот такую замену в исходном стринге
    a --> c
    b --> d
причем tr ищет символ из SET1 не один раз а многократно по всей строке . пример
    $ echo "mama mila ramu" | tr   "m" "v"
    vava vila ravu

итак окей так или иначе 
    tr SET1  SET2
делает то что она ищет символы из SET1 и меняет их на соотвествующие символы в SET2

далее ключ -d SET1 удалеяет символы из SET1
    $ echo "mama mila ramu" | tr   -d  "m"
    aa ila rau
еще пример
    $ echo "mama mila ramu" | tr   -d  " "
    mamamilaramu
проблема c tr  в том что ты с его помощью хер заменишь слово. для этого нужно видимо юзать sed
tr подходит для замены отдельных символов а не слов.
еще пример
он прикольный. вначале "m" меняется на "v"
а потом "m" меняется на "s"
также "a" меняется на "a" 
а потом "a" меняется на "y"
поэтому
    $ echo "mama2 mila ramu" | tr   "mama" "vasya"
    sysy2 sily rysu
таким образом пробовать менять слова с помощью tr это бесполезное дело. 
он больше подходит для замены символов во всех документе.
    $ echo "mama2 mila ramu" | tr   "a" "A"
    mAmA2 milA rAmu
я бы сравнил tr с функцией в текстовом редакторе "найти символ и заменить во всем тексте"
теперь хочу рассмотреть два примера
    $ echo "mama2 mila ramu" | tr  " " "-"
    mama2-mila-ramu
    $ echo "mama2 mila ramu" | tr  -c " " "-"
    ----- ---- -----
в первом примере " " заменяется на "-" и результат понятен и логичен
во втором примере испольуется ключ -c. я заебался искать как он работает. в man tr нихуя не написано. ман вобще ебнутый у tr.
а в info tr я нашел как раобтает ключ -c.  значит без каких либо ключей SET1  обозначает те символы которые 
он ищет в тексте так вот -c SET1 он дает то что tr инвертирует массив символов из SET1. тоесть если 
    tr SET1
означает ищи все символы указанные в SET1
то 
    tr -c SET1
означает ищи все символы кроме тех что указаны в SET1
скажем у нас стоит 
    tr "a" "b" 
означающий что найди "a" и замени на "b" 
то  tr -c "a" "b" 
означает что найди любые символы кроме "a" и замени их на "b"
поэтому
    $ echo "mama2 mila ramu" | tr  -c " " "-"
    ----- ---- -----
tr ищет все символы кроме " " и заменяет их на "-"
тоесть -c "символы" означает ищи все символы а указнные не трогай.
еще пример
    $ cat 10.bash  | tr -c " \n" "#"
    ###########

    #### ######
    #### ######
    
    ######
    #### ######

    #####
    #### ######
    
    #######
    #### ######
    
    #########
    #### ######
тоесть мы говорим tr ищи символы все кроме пробела и новой строки и заменяй их на "#"
далее вот интересный пример. мы берем  из urandom триста байт и заменяем в нем все символы на "#" кроме пробела a-z A-Z 0-9
    $ head -c 300 < /dev/urandom  | tr -c " a-zA-Z0-9\n" "#" ; echo ""
    #p#iT##w3######br##V#########D######oo4Q########hw#o##u
    ##f##NN##########Qh#########XB#######Z#W#Lg##d####UX#2#G########K####Bs####q###JE#####P#####K######4####sD##Z#d##FF###27###q####f#2#D#1i#####p###########r##4#MD#p2###T##Ov###C##Q##z##A#p##########I########A##JW######i#cc#X##5####3#Q###U##LG##46
прикольно..
еще пример
мы берем триста байт из urandom и удаляем все байты(символы) кроме пробела a-z A-Z 0-9
тоесть ключ -d говорит о том что надо удалить из потока все символы укзанные в SET1
но поскольку у нас -с SET1 то -d -c SET1 означает удали все символы кроме тех что указны в SET1
$ head -c 300 < /dev/urandom  | tr -c -d " a-zA-Z0-9\n"; echo ""
QlbTb DttwacmU2ReWZFM CY
GWOVpfQ0zErkgy448g7JF I4lreQ2BRJ7YBzcrohBr
далее
если у нас указан -d то прописывать SET2 нет смысла. потому что мы ничего не заменяем мы только удаляем.
возврашаемся к прмиеру из скрипта
    salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8)
итак из urandom читаются байты\символы и из потока удаляются все символы кроме a-z A-Z 0-9
и потом из этого измененного потока забираются первые 8 байтов. то есть первые 8 символов.
и эта хрень записывется в $salt
    $ tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8
    gSBy8fT7
итак tr хорош если нам надо во всем тексте заменить один символ на другой или вырезать из всего текста символ.
далее 
у tr есть подьбека нужно чтобы все ключи были до SET1 и SET2 иначе он не поймет тоесть
пример
работает
    $ echo "a1b" | tr -d "1"
    ab
пошел нахуй потому что -d должен стоять до SET1 и SET2
    $ echo "a1b" | tr "1" -d
    a-b
ключ -s дает то что в модифициованном потоке удаляются повторяющиеся рядом стоящие символы из SET2
тоесть
    $ echo "abbc" | tr  "b" "A"
    aAAc
    $ echo "abbc" | tr -s "b" "A"
    aAc
еще пример
$ echo "goooooogle is ..." | tr -s "o" 
gogle is ...
прикольно
    $ echo "goooooogle is google" | tr -s "o" 
    gogle is gogle
итак tr может во всем тексте заменить заданный символ на другой, удалить заданный символ во всем тексте,
во всем тексте заменить все символы кроме заданных, удалить все символы кроме заданных во всем тексте,
убрать в тексте повторяющиеся стоящие рядом символы.
у tr есть предопределенные классы символов для SET1 чтобы нам не мучаться и их не вводить руками.
об этом смотри в man tr а щас просто примеры
причем я приожу примеры не на все классы . поэтому для всех классов смотри man tr
    $ cat  < /dev/urandom  | tr -cd [:digit:] | head -c 10; echo ""
    6219672303
    $ cat  < /dev/urandom  | tr -cd [:graph:] | head -c 10; echo ""
    TKRyRNfW2%
    $ cat  < /dev/urandom  | tr -cd [:lower:] | head -c 10; echo ""
    mqcfcshjsi
    $ cat  < /dev/urandom  | tr -cd [:print:] | head -c 10; echo ""
    ZD0mVOp~~q
    $ cat  < /dev/urandom  | tr -cd [:punct:] | head -c 10; echo ""
    <]/:@}:+,{
    $ cat  < /dev/urandom  | tr -cd [:upper:] | head -c 10; echo ""
    RYIADZIQVO
    $ cat  < /dev/urandom  | tr -cd [:xdigit:] | head -c 10; echo ""
    56d6d5D2C2
 
может возникнуть вопрос а как же до tr или head прилетают данные от cat через пайп если cat читает 
бесконечный urandom. ответ в том что данные начинаются литться через пайп к соседнему процессу сразу же как cat начинает 
читать данные. а не после того как он их бы все прочел. тоесть cat читает сколько то данных из urandom в свой буфер. и как только буфер 
заполнился то он его высирает в свой stdout который закольцован на stdin у tr. для stdin у tr там запущен запрос к ядру что как только
на stdn у tr чеото поступит то разбудить tr. щедулер вытесняет процесс cat и пробуждает процесс tr. 
таким же макаром когда tr обработае сколько данных то высирает в stdout их часть. stdout у tr закольцован на stdin у head.
как только на stdin у head поступают данные то ядро будит head. а другие процессы если скажем это 1 ядернйы процессор шедулер выдавливает 
с цпу. и head уже высирает нам на терминад данные. как только head высрет 10 байтов то он прекращает свою деятелность и шлет в ядро
сисколл чтоб ядро убило егоный процесс. ядро убивает процесс с head. и шлет головному процессу баша который запускал этот head 
сигнал SIGCHLD что его дочерний процесс сдох. тогда как я понимаю баш уже сам автомтом убивает остальные процессы которые входили в 
цепочку пайпов. поэтому смерть одного из процессов в цепочке пайпов вызывает в итоге смерть всех процессов в цепочке.
все это приводит к тому что для того чтобы head получил данные сосвсем ненужно ждать пока cat прочитвает все данные из бесконечного
файла urandon. и то что смерть одного из процессов из цеочки пайпов вызывает смерть всез процессов в цепочке.

таким макаром я разобрал полностью весь конец скрипта
#########
if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 

doHash "$password" "$salt" '$1$'
############

последння строчка ывзает функцию doHash которая начинает искать ответ на поставленню задачу.
таким макаром я разобрал как работает вест скрипт от верха до низа.


теперь  надо взять конкретный i и прогнать по скрипту посмотреть что принимают при этом
        его разные переменные какие значения


запускаю скрипт вот так
$ ./debug.bash abc 12345678
тоесть пароль = abc
salt=12345678

поехали выполнять программу


if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2
    exit 1
fi

этот кусок программа проскочит так как "$#"="2"

password=$(stringToHex "$1")

значит у нас будет 
password=$(stringToHex "abc")


функция stringToHex

stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

значит #1=3
значит

stringToHex() { 
    for((i=0; i<3; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

значит функция берет "abc" начинает у него брать символы начиная с нулевого офссета (самый левый символ) то есть 
это будет 
a
b
c
и печатает его в виде ascii кода в формате hex \xNN
ascii код для a  = 0x61
          для b  = 0x62
          для c  = 0x63
тогда функция вернет 
password="\x61\x62\x53"
проверяю в программе
и дейтсвительно 
    $ cat debug.txt 
    password=\x61\x62\x63


salt=$(stringToHex "$2")
тогда будет 
salt=$(stringToHex "12345678")
тогда будет 
stringToHex() { 
    for((i=0; i<$8; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

ascii для 1= 0x31
      для 2= 0х32
      ...
      для 8=0x38
тогда stringToHex вернет "\x31\x32\x33\x34\x35\x36\x37\x38"
тогда
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
проверяю
и действиельно
    salt=\x31\x32\x33\x34\x35\x36\x37\x38

    
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 8) 
чтобы эта строка выполниась апускаю скрипт по другому
     $ ./debug.txt abc
тогда он возьмет из urandom только символы a-z A-Z 0-9 в количестве 8 штук и присвоит salt
проверяю
и действительно
    salt=5ZhB6Sm3
запускаю обртано скрипт с 
    $ ./debug.txt abc 12345678

    
doHash "$password" "$salt" '$1$'
тогда будет
doHash "\x61\x62\x63" "\x31\x32\x33\x34\x35\x36\x37\x38" '$1$'

переходим в doHash()


doHash() { 
    password="$1"

#
тогда
password="\x61\x62\x63"
проверяю
и дейтисвиельно сходится
doHash() password=\x61\x62\x63
#

    passwordLength=$(printf "$password" | wc -c)

#
значит wc -c считает байты
значит тогда 
passwordLength=$(printf "\x61\x62\x63" | wc -c)
поскольку в поле формат запись \x61 означает прям сам байт записанны в хекм формате 
а не литеры то это значит что принтф высрет 3 байта из себя. и дейтвительно
$ printf "\x61\x62\x63" | od -t x1
61 62 63
тогда wc -c дожлен насчитать 3 байта и тогда 
passwordLength="3"
проверяем
и действиетьно
doHash() passwordLength=3
#
    salt="$2"
# 
salt= "\x31\x32\x33\x34\x35\x36\x37\x38"
проверяю
doHash() salt=\x31\x32\x33\x34\x35\x36\x37\x38
совпало
#
    magic="$3"
#
magic='$1$'
проверяю
doHash() magic=$1$
совпало
#
    [[ -z $magic ]] && magic='$1$'


    salt=${salt#'$1$'}
#
эта хрень значит искать с начала строки стринг $1$ и вырезать его
пример
    $ a='aws$1$'
    $ echo ${a#'$1$'}
    aws$1$
    $ a='$1$aws'
    $ echo ${a#'$1$'}
    aws
    $ a='$1$aws$1$'
    $ echo ${a#'$1$'}
    aws$1$
в нашем конкретном случае salt="\x31\x32\x33\x34\x35\x36\x37\x38"
поэтому
    $echo ${salt#'$1$'}
    \x31\x32\x33\x34\x35\x36\x37\x38
не приведет ни к чему. поэтому salt останется неизменным
    
#
    salt=${salt:0:32} # 8 first bytes
#
эта команда выбирает 32 символа из переменной начиная с оффсета 0 тоесть символы 0-31 
поскольку salt="\x31\x32\x33\x34\x35\x36\x37\x38"
тоесть на 1 байт в hex формате приходится 4 символа то это значит что будет выбрано 8 байт в хекс формате
в нашем случае так как salt изначально был 8 байт то будет выбрано вся переменная
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
проверяю на праткике
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
совпало


    
    intermediate=$(
    {
        # Start intermediate result
        printf "$password$magic$salt" 

#
password='\x61\x62\x63'
magic='$1$'
salt="\x31\x32\x33\x34\x35\x36\x37\x38"
поэтому  
    printf "\x61\x62\x63$1$\x31\x32\x33\x34\x35\x36\x37\x38" = abc$1$12345678
проверяю
    abc$1$12345678
совпало
что тут интересно. интересно то что 
вот в таком примере у нас принф печатает содержимое переменной
    $ cat 10.bash 
    #!/bin/bash
    printf "$1\n"

    $ ./10.bash vasya
    vasya

тоесть 
    printf "$1\n" = printf "vasya\n"
вместо $1 подставляется занчение этой переменной
а вот в этом примере не происходит двойного раскрытия имени переменной
    $ cat 10.bash 
    #!/bin/bash
    a='$1'
    printf "a=$a\n"

    $ ./10.bash vasya
    a=$1
тоесть
    printf "a=$a\n" = printf "a=$1\n" 
и дальнейшей второй подставновки вместо $1 ее значения не происходит. поэтому будет 
напечаатано 
    a=$1
а не 
    vasya
тоесть если переменная раскрылась один раз и там у нас еще одно имя перееменной. то второй раз
переенная не раскрывается
вот еще пример на эту тему
    $ a=1
    $ b='$a'
    $ echo "$b"
    $a
вообще если указать имя переменной вот так
    $ b='$a'
то ты эту переменную $a вобще никак не раскроешь . даже вот так
    $ echo "${!b}"
    bash: $a: bad substitution
единственный вариант как можно раскрыть переенную два раза это вот так
    $ a="1"
    $ b="a"
    $ echo "${!b}"
    1
но у нас не такой случай
наш случай это 
    magic='$1$'
    printf "...$magic..."
поэтому напечается именно '$1$' а не содержимое переменной $1="abc"
охуеть как наворочано
итак в результате команды
       printf "$password$magic$salt" 
будет напечатано
       abc$1$12345678
#
    
    
        # compute a separate md5 sum
        alternate=$(printf "$password$salt$password" | md5hex) 

#
    alternate=$(printf "$password$salt$password" | md5hex) =>
    $(printf "\x61\x62\x63\x31\x32\x33\x34\x35\x36\x37\x38\x61\x62\x63" | md5hex) =>
поскольку printf воспринимает \xNN как ascii код символа в hex формате то это эквивалентно 
    => $(printf "abc12345678abc' | md5hex) =>
действительно
    printf "\x61\x62\x63\x31\x32\x33\x34\x35\x36\x37\x38\x61\x62\x63"
    abc12345678abc
тогда
    $(printf "abc12345678abc' | md5hex) => \x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff
сравниваем
       \x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff
все совпало
#

        # Add one byte from alternate for each character in the password. Wtf?
        while printf "$alternate" 2> /dev/null
        do
          true
        done | head -c "$passwordLength"

#
здесь 
$passwordLength="3"
printf "$alternate"=printf "\x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff"=]M�!������m8....
тогда
printf "\x5d\x4d\x9e\x21\xef\x9a\xfa\x84\xe1\x87\x6d\x1a\x38\x0a\xaf\xff" | head -c3
высираются байты "\x5d\x4d\x9e" 


#
прежде чем переходить  к следущему куску
надо прояснить что такое {} в баше.
для этого я говорю о том что 
вот этот кусок кода

{
  printf "1"
  printf "2"
  printf "3"
}

и вот этот кусок кода это одно и тоже
 { printf "1"; printf "2"; printf "3"; }
 причем обязательно проставить все ";" иначе будет хуйня

доказать это легко надо лишь проверить что на выходе один и тот же поток 
байтов

$ {
  printf "1"
  printf "2"
  printf "3"
} | od -t x1
0000000 31 32 33

$ {   printf "1";   printf "2";   printf "3"; } | od -t x1
0000000 31 32 33

итак мы видим что это одно итоже
а вот разница если мы уберем скобки
    printf "1";   printf "2";   printf "3"  | od -t x1
    120000000 33
тоесть "1" и "2" улетели не в od а на экран. а в od улетело только "3"




        # For every 1 bit in the key length, add a 0.
        # Otherwise add the first char of the key. WTFFFFF?!
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "$password" | head -c 1
            fi
        done

    } | md5hex
    )


# 
$passwordLength="3"
также printf "$password" = printf "abc"
значит

        for ((i=3; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf '\x00' 
            else 
                printf "abc" | head -c 1
            fi
        done

    } | md5hex
    )

значит 3 в битовом виде это 11
из кода цикла видно что для каждого установленного бита в байте 11 печатается printf '\x00'
значит в результате выполнения цикла как бы отработает вот такой код
    printf '\x00'
    printf '\x00'

кстати вот интересно что мы получаем на выходе какой байтовй поток
    $ printf "\x00" | od -t x1
    0000000 00
а понятно. реально будут высираться байты вида 00h
что интересно попытка печати этих байтов на экране не приводит ни к чему
    $ printf "\x00\x00\x00\x00"
на выходе просто ничего не происходит
вот еще так можно сделать
    $ head -c 10 < /dev/zero | od -t x1
    0000000 00 00 00 00 00 00 00 00 00 00
убедиться что на экране нихерна ненапечатается ни один символ хотя байты поступают
    $ head -c 10 < /dev/zero | cat
тоесть этот байт 00h он не является печатным. он является для терминала управлющим. (так же как скажем \n)
и говорит терминалу что нихрена делать ненадо

    
далее видим вот такое
    } | md5hex
    )

так вот я не зря про { рассуждал выше. в md5hex полетит не то что вылетело из последнего цикла
а вообще все что стоит по intermediate. давай ка я соберу все то что было непечатано на stdout внутри
intermediate, я соберу это все в формате единого printf
    printf "abc\$1\$12345678\x5d\x4d\x9e\x00\x00"
и все это  перенаправляется на md5hex тоесть
    printf "abc\$1\$12345678\x5d\x4d\x9e\x00\x00" | md5hex
получаем
    \xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3
проверяем
    \xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3
сходится
итак intermidiate="\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"

#
    
    
    for((i=0; i<1000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$password" || printf "$intermediate"
            (( i % 3 )) && printf "$salt"
            (( i % 7 )) && printf "$password"
            (( i & 1 )) && printf "$intermediate" || printf "$password"
        } | md5hex)
    done

#
берем i=0
intermidiate="\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"
тогда 
            (( 0 & 1 )) && printf "$password" || printf "$intermediate"
            (( 0 % 3 )) && printf "$salt"
            (( 0 % 7 )) && printf "$password"
            (( 0 & 1 )) && printf "$intermediate" || printf "$password"

(( 0 & 1 )) = (( 0 )) ; это false это код возврата 1 значит отработает printf "$intermediate"
(( 0 % 3 )) = (( 0 )) ; это false поэтому далее ничего не отрабтает
(( 0 % 7 )) = (( 0 )) ; это false поэтому далее ничего не отрабтает
(( 0 & 1 )) ; это false значит отработает  printf "$password"
значит в итоге у нас отработает 
    printf "$intermediate"
    printf "$password"
что эквилвалетнтно
    printf "$intermediate$password"
что эквавалетно 
    printf ""\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"abc"

видно что дальше эта хрент напускатся на md5hex
    printf "\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"abc" | md5hex
значит новый intermidiate 
    intermidiate=$(printf "\xaa\x8a\x43\x2f\x1d\x8b\x38\x4d\xde\x65\x12\xd8\x43\xf6\xfa\xa3"abc" | md5hex)
я посчитал руками это 
    \x5a\xdd\xbb\x70\x9e\xaa\xe3\x53\x74\x6d\x25\x56\x70\xa8\xef\x5f
далее я запустил исходный скрипт при i=0 и получил
    \x5a\xdd\xbb\x70\x9e\xaa\xe3\x53\x74\x6d\x25\x56\x70\xa8\xef\x5f
все совпадает
значии далее этот intermidiate таким макаром внутри цикла колбасится 1000 раз
итоговый intermidiate после 1000 раз будет такой
    intermidiate="\x40\x1d\x63\xc9\xa4\xd1\xf8\x15\x04\xb6\x88\xda\x52\x2f\x03\x05"
#




    # Rearrange the bytes and crypt-base64 encode them
    encoded=$(base64EncodeBytes 22 "$intermediate" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

#
значит это будет запущено вот так
        encoded=$(base64EncodeBytes 22 "\x40\x1d\x63\xc9\xa4\xd1\xf8\x15\x04\xb6\x88\xda\x52\x2f\x03\x05" 11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12)

посмотрим еще раз на функцию 

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}

она запускает функцию getBytes котрая из $intermediate выбирает байты \xnn в указанном порядке
тоесть просто переставляет местами

getBytes() { 
    num=$1
    echo "$@"
    shift
    for i in $@
    do
        echo -n "${num:$((i*4)):4}"
    done
    echo ""
}

тоесть на выходе мы будем по прежнему иметь "\xnn\xnn..."

далее запускается hexToInt
она преобразует из вида \xnn\xnn в  \xNN\xNN\xNN, далее преобразует к виду NNNNNNNNNN типа 40AB45ED21AF
далее эта хрень направляется в bc и он преобразует это шестанадцатиричное число в десятичное вида 168846464562234234

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}

далее запускается функция intToBase64 "168846464562234234" "22"
которая преобразует это десятичное число в B64 вид используя 
глобальную переменную b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
значит работает эта функция так. она берет исходное число "168846464562234234" и делит его на 64
находит остаток от деления и эта цифра является оффсетом символа в переменной $b64
скажем остаток от деления 168846464562234234 на 64 это 58. значит берется 58-ый символ (отсчитывая от нуля) в $b64
это символ "u" это будет первый символ нашего искомого хеша в кодировке B64
далее исходное число делится на 64 нацело. это и есть новое исходное число. и с этим новым исходным числом 
цикл повторяется. тоесть оно делитнся на 64 ищется остаток. по нему находится новый символ. и так 22 раза. 
таким макаром исходное десятичное число превращается в 22 символа из словаря $b64

intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")  # остаток от деления
        number=$(bc <<< "$number / 64") # целое от деления
        echo -n "${b64:digit:1}"
    done
    echo ""
}

        
я запустил вызов  base64EncodeBytes() и получил
    GVDEjIF51EkM3MPmFX6dO1
а вот я запустил в исходном скрипте
    GVDEjIF51EkM3MPmFX6dO1
совпало
#

    
    printf "%s%b\$%s\n" "$magic" "$salt" "$encoded"


}

# 
эта хрень печатает просто напросто $magic  $salt и $encoded

$magic='$1$'
$salt="\x31\x32\x33\x34\x35\x36\x37\x38" без разницы
$encoded='GVDEjIF51EkM3MPmFX6dO1'

запускаю
    $ printf "%s%b\$%s\n" "$magic" "$salt" "$encoded"
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1
сравниваем с тем что из исходного скрипта
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1
совпало

#

кстати не все функции этого скрипта используются алгоритмом например функция 
stringToNumber() не используется никак


таким макаром я вроде как прям пролезнув по шагами скрипта проработал конкретно на цифрах как 
он работает.




теперь я опишу как раобтает алгоритм НА СЛОВАХ:
мы запускаем скрипт. вводим в аргументах password и salt
если солт мы не ввели он будет сформирован рандомно
далее из солт преобразуется так что из него берется только первые 8 символов
далее задается константа magic

далее вычисляется переменная intermidiate следущим образом:
 на stdout посылаются следущие хрени
    - password+magic+salt"
    - вычисляется md5 от password+salt+password
      и потом мы от этого md5 отрезаем ровно столько байтов какова длинна пароля и эти байты тоже посылаем на stdout
    
    тут надо помнить что функция md5sum она выводит не сам хеш ибо это набор байтов часто которые
    не соовествуют по аски кодам печатным символам поэтому коды байтов преобразуются в новые аски коды для которых
    печатные символы соовествуют аски кодам хеша. тоесть вот это не хеш
    $ printf "1" | md5sum | awk '{print $1}' 
    c4ca4238a0b923820dcc509a6f75849b
    вот это реальный хеш
    $ printf "1" | md5sum | awk '{print $1}' | xxd -p -r -
    �P�ou��
    а вот его байтики 
    $ printf "1" | md5sum | awk '{print $1}' | xxd -p -r - | xxd -p
    c4ca4238a0b923820dcc509a6f75849b
    тоесть надо отличать реальные байты которые составляют даннные 
    и в какой символ преобразуется этот байт на экране. так вот символ 1 на экране
    это не тоже самое что байт 0x1 
    тоесть есть байты котоые и составлят данные. а есть графическая интепретация в символы на экране
    которые тоже имеют цифровой смысл
    
    - берем длинну пароля. берем это число. переводим его в двоичный вид. например это 01010010101
    далее начинаем перебирать биты начиная с младщего и начинаем на stdout посылать байты  по следущему правилу
    если текущий бит 1 то посылаем байт \x00 а если бит 0 то берем пароль и посылаем первый байт из пароля
    тоесть пусть первый байт пароля  тогда для длинны пароля в бинарном виде 01010010101
    мы на stdout будем посылать байты  \x61  \x00 \x61  \x00  \x61 \x61  \x00  \x61  \x00  \x61   \x00

    так вот берем эти три хрени и от этой конструкции вычисляем md5 это и есть переменная intermidiate

далее запускается цикл из 1000 шагов.(через переменную i)
на кажом шаге пересчитывается эта переменная intermediate по схеме

            если i нечетный то  на stdout шлем password иначе шлем intermediate
                но это еще не конец, далее в этом же шаге цикла идет следущий шаг
            если i НЕделится на 3 то шлем salt
                далее идет следущий шаг
            если  i НЕделится на 7 то шлем  password
                далее идет следущий шаг
            если i нечетный  то шлем intermediate иначе  шлем password

            для примера пусть i=15 тогда на stdout будет послано
                password+salt+password+intermediate
            далее от этой хрени вычисляется md5 тоесть для i=15 вычислятся md5(password+salt+password+intermediate)
            и это и присваивается переменной intermidiate
            далее цикл повторяется и так до конца цикла

когда цикл отработал то в получившейся переменной intermidiate переставляются байты по схеме
             11  4 10 5  3 9 15  2 8 14  1 7 13  0 6 12

далее после перстановки полученный поток байтов в intermidiate перекодируется в так называемый B64
алгоритм перекодировки такой - берется intermidiate перекодируется в десятичное число. 
это число делится на 64 находится остаток и этот остаток используется как оффсет для поиска символа в словаре
словарь этой кодировки 
            "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
тоесть если остаток равне 63 то берется символ "z" к примеру
далее берется это десятичное число и делится на 64 , целое от деления берется как новое значение intermidiate
и цикл повторяется заново. так просиходит 22 раза. таким макаром мы получаем 22 символа из словаря.
это и есть типа искомый хеш.
это пиздец а не алгоритм


теперь покажу что результаты работы скрипта совпдают с утилитами официльными котоыре типа делают тоже самое

    $ ./md5crypt.bash abc 12345678
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1

    $  mkpasswd --method=md5  abc 12345678
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1

    $ openssl passwd -1 -salt  12345678 -stdin <<< abc
    $1$12345678$GVDEjIF51EkM3MPmFX6dO1

как видно получили одно и тоже. значит утилита работает правдоподобна



ДАЛЕЕ я перехожу к тому ради чего все началось с того как вычисляется /etc/SHADOW с использованием SHA-512
вначале я проверю что скрипт 
    https://www.vidarholen.net/contents/junk/files/sha512crypt.bash
выдает верный результат совпадающий с оф утилитами

    $ ./sha512crypt.bash abc 12345678
    $6$12345678$/2kqzTQ48gi0uN7n3YdhWAqTslf4Lt0yEsFxSucHzxAU7FaXCW..I1OVwaoe6mZIAD.3r1wHv4OIZ90Fuvomd0

    $ mkpasswd --method=sha-512 abc 12345678
    $6$12345678$/2kqzTQ48gi0uN7n3YdhWAqTslf4Lt0yEsFxSucHzxAU7FaXCW..I1OVwaoe6mZIAD.3r1wHv4OIZ90Fuvomd0

    $ openssl passwd -6 -salt  12345678 -stdin <<< abc
    $6$12345678$/2kqzTQ48gi0uN7n3YdhWAqTslf4Lt0yEsFxSucHzxAU7FaXCW..I1OVwaoe6mZIAD.3r1wHv4OIZ90Fuvomd0

мы видим что скрипт sha512crypt.bash выдает все тоже самое. значит можно его рассматривать

####################sha512crypt.bash#########################
#!/bin/bash
# sha512-crypt for GNU and Bash
# By Vidar 'koala_man' Holen

b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"

stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}

# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}

# Turn stdin into a \xd4\x1d style sha512 hash
sha512hex() { 
    sum=$(sha512sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}

# Turn an integer into a crypt base64 string with n characters
intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")
        number=$(bc <<< "$number / 64")
        echo -n "${b64:digit:1}"
    done
}

base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}

# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}

doHash() { 
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    saltLength=$(printf "$salt" | wc -c)
    magic="$3"
    [[ -z $magic ]] && magic='$6$'

    salt=${salt#$magic}
    salt=${salt:0:64} # 16 first bytes

    intermediate=$(
    {
        # Start intermediate result
        printf "$password$salt" 

        # compute a separate sha512 sum
        alternate=$(printf "$password$salt$password" | sha512hex) 

        # Add one byte from alternate for each character in the password. Wtf?
        while true; do printf "$alternate"; done | head -c "$passwordLength"

        # For every 1 bit in the key length, add the alternate sum
        # Otherwise add the entire key (unlike MD5-crypt)
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf "$alternate"
            else 
                printf "$password" 
            fi
        done

    } | sha512hex
    )
    firstByte=$(hexToInt $(getBytes "$intermediate" 0))

    p_bytes=$(for((i=0; i<$passwordLength; i++)); do printf "$password"; done | sha512hex | head -c $((passwordLength*4)) )
    s_bytes=$(for((i=0; i<16+${firstByte}; i++)); do printf "$salt"; done  | sha512hex | head -c $((saltLength*4)) )


    for((i=0; i<5000; i++))
    do
        intermediate=$({
            (( i & 1 )) && printf "$p_bytes" || printf "$intermediate"
            (( i % 3 )) && printf "$s_bytes"
            (( i % 7 )) && printf "$p_bytes"
            (( i & 1 )) && printf "$intermediate" || printf "$p_bytes"
        } | sha512hex)
    done

    # Rearrange the bytes and crypt-base64 encode them
    hex=$(base64EncodeBytes 86 "$intermediate" \
        63  62 20 41  40 61 19  18 39 60  59 17 38  37 58 16  15 36 57  56 14 35 \
            34 55 13  12 33 54  53 11 32  31 52 10   9 30 51  50  8 29  28 49  7 \
             6 27 48  47  5 26  25 46  4   3 24 45  44  2 23  22 43  1   0 21 42)

    printf "%s$salt\$%s\n" "$magic" "$hex" 

}


if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2 
    exit 1
fi

password=$(stringToHex "$1")
salt=$(stringToHex "$2")
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 16) 

doHash "$password" "$salt" '$6$'

####################sha512crypt.bash#########################


разберу его по кускам
############################

#!/bin/bash
# sha512-crypt for GNU and Bash
# By Vidar 'koala_man' Holen

это словарь для кодирования B64
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"


вот эта функция хоть и есть в скрипте но по факту нихрена
не используется в алгоритме вообще
stringToNumber() { 
    expression=0
    for((i=0; i<${#1}; i++))
    do
        expression=$(printf '(%s)*256+%d' "$expression" "'${1:$i:1}")
    done
    bc <<< "$expression"
}



эта штука находит для каждого символа его ascii символ
переводит его в hex и добавляет \x получается \xnn
например "a" на входе имеет 0x61 ascii
и на выходе будет "\x61"
тоесть "abc" --> "\x61\x62\x63"
фишка в том что для printf на выходе выдаст одно итоже
printf "a" = printf "\x61"

# Turn some string into a \xd4\x1d hex string
stringToHex() { 
    for((i=0; i<${#1}; i++))
    do
        printf '\\x%x' "'${1:i:1}"
    done
}


эта штука берет входящий аргумент '2232ffeffv33ewfw'
находит от него sha512 получаем чтото типа "a112b2.."
и далее к этому добавляется \x на выходе будет "\xa1\x12\xb2.."
тоесть '2232ffeffv33ewfw' --> sha512sum(2232ffeffv33ewfw) --> "\xa1\x12\xb2.."

# Turn stdin into a \xd4\x1d style sha512 hash
sha512hex() { 
    sum=$(sha512sum) 
    read sum rest <<< "$sum" # remove trailing dash
    hex=$(sed 's/../\\x&/g' <<< "$sum")
    echo "$hex"
}


берем десятичное число "3445345464564646" и коневертируем его в B64

# Turn an integer into a crypt base64 string with n characters
intToBase64() { 
    number=$1
    n=$2
    for((j=0; j<n; j++))
    do
        digit=$(bc <<< "$number % 64")
        number=$(bc <<< "$number / 64")
        echo -n "${b64:digit:1}"
    done
}

# эта хрень вобоще не испольщуется в реальном алгоритме скрипта
base64Index() { 
    for((i=0; i<64; i++))
    do
        if [[ ${b64:i:1} == $1 ]]
        then
            echo $i
            exit 0
        fi
    done
    exit 1
}


эта функция  получает аргументы  вида \x12\xa1\xb2\xc2\xf1  5 4 1
и переставляет в \x12\xa1\xb2\xc2\xf1 хрени вида \x.. местами в 
заданном порядке как указано 5 4 1
тоесть было  \x12\xa1\xb2\xc2\xf1  стало  \xf1\xc2\x12
тоесть эта хрень перставляет местами 

# From hex string $1, get the bytes indexed by $2, $3 ..
getBytes() { 
    num=$1
    shift
    for i
    do
        echo -n "${num:$((i*4)):4}"
    done
}


эта функция на входе получает \xa1\xa2\xb1\xc1
конвертирует a1a2b1c1
а его коневертирует в десятичное число

hexToInt() { 
    {
    echo 'ibase=16;'
    tr a-f A-F <<< "$1" | sed -e 's/\\x//g'
    } | bc
}


эта функция берет \xa1\xa2\xb1\xc1
и конвертирует его в B64 кодировку

base64EncodeBytes() {
    n=$1
    shift 
    bytes=$(getBytes "$@")
    int=$(hexToInt "$bytes")
    intToBase64 "$int" "$n"
}



головная функция

doHash() { 
    password="$1"
    passwordLength=$(printf "$password" | wc -c)
    salt="$2"
    saltLength=$(printf "$salt" | wc -c)
    magic="$3"
    [[ -z $magic ]] && magic='$6$'

эта хрень никогда не сработает. потому что salt="\xa1\x12\x31\b1"
то в нем никогда не будет стринга $magic потому что $magic='$6$'
и это никак не похоже на \xnn
    salt=${salt#$magic}

выбирает 16 байтов из солта
указано 64 символа потому что солт имеет формат "\xa1\x12\x31\b1..."
    salt=${salt:0:64} # 16 first bytes




    intermediate=$(
    {
        # Start intermediate result
        printf "$password$salt" 

        # compute a separate sha512 sum
        alternate=$(printf "$password$salt$password" | sha512hex) 

        эта штука берет $alternate и вырезает от из него столько байт сколько длинна пароля
        причем если длинна пароля длинее чем $alternate то набор байтов продолжается 
        заново сначала пароля и высирает это на stdout
        # Add one byte from alternate for each character in the password. Wtf?
        while true; do printf "$alternate"; done | head -c "$passwordLength"


        эта штука берет число которое показывает длину пароля
        потом по факту это число как бы преобразуется в двоичный вид 0101010101
        далее анализируется этот вид начиная с младшего бита к старшему
        и если очередной бит 1 то на stdout высирается "$alternate"
        а если очередной бит 0 то на stdout высирается "$password"
        # For every 1 bit in the key length, add the alternate sum
        # Otherwise add the entire key (unlike MD5-crypt)
        for ((i=$passwordLength; i != 0; i>>=1)) 
        do
            if (( i & 1 ))
            then
                printf "$alternate"
            else 
                printf "$password" 
            fi
        done


все что было высрано на stdout оно направляется на sha512hex функцию        
        
    } | sha512hex
    )
    
    эта хрень вырезает первый байт из intermediate 
    результрующий результат это число в dec формате
    firstByte=$(hexToInt $(getBytes "$intermediate" 0))

    
    эта хрень берет password повторяет его столько раз сколько длинна пароля в байтах.
    если длинна пароля 4 символа то будет четыре раза повторен пароль.
    далее этот четверной пароль бросается на sha512hex тоесть из этого вычисляется sha512 
    и получаем число вида \x21\x34\x45... и из него вырезается столько \xnn столько штук сколько длинна пароля.
    тоесть при длинне пароля 4 символа тогда будет вырезано 16 символов тоесть \x21\x34\x45\x67
    p_bytes=$(for((i=0; i<$passwordLength; i++)); do printf "$password"; done | sha512hex | head -c $((passwordLength*4)) )

    эта хрень берет salt и печатает его 16 раз на stdout и еще столько раз сколько составляет число firstByte
    далее эти солты посылаются на sha512hex которая считает от этого sha512 и переводит ее в вид \x12\x13\x14\x15
    и из этой хрени вырезает столько \xnn штук сколькл длинна солта. скажем если солт длинна 3 символа то 
    вырезано будет \x12\x13\x14
    s_bytes=$(for((i=0; i<16+${firstByte}; i++)); do printf "$salt"; done  | sha512hex | head -c $((saltLength*4)) )


    цикл на 5000 шагов    
    for((i=0; i<5000; i++))
    do
    перевычесляется intermidiate путем того что 
    если i нечетное то печатается $p_bytes иначе $intermediate
    далее
    если i неделится на 3 то печатается  s_bytes
    далее
    если i неделится на 7 то печатается  p_bytes
    далее
    если i нечетное то печатается intermediate иначе печатается p_bytes
    и далее вся эта портянка скармилвается функции sha512hex
    это и есть новый intermediate
    и таки циклов перевычисления 5000 штук
        intermediate=$({
            (( i & 1 )) && printf "$p_bytes" || printf "$intermediate"
            (( i % 3 )) && printf "$s_bytes"
            (( i % 7 )) && printf "$p_bytes"
            (( i & 1 )) && printf "$intermediate" || printf "$p_bytes"
        } | sha512hex)
    done


берется intermediate которая имеет вид \x11\xa1\xa2... посылается на base64EncodeBytes которая 
переставляет местами их в соотвествии с тем как указано цифрами 63 62 итд
а далее эту хрень она перекодирует в B64 формат по алгоритму такому что 
обновленный intermediate конвертруется в dec формат. потом это число делится на 64 и вычисляется целое 
от деления и это новый intermidiate и остаток от деления это офффсет на основе которого из словаря
b64="./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" выбирается символ который и явялется искомым.
далее обновленный intermidiate заново делится на 64 и так по кругу пока мы не получим 86 символов
    # Rearrange the bytes and crypt-base64 encode them
    hex=$(base64EncodeBytes 86 "$intermediate" \
        63  62 20 41  40 61 19  18 39 60  59 17 38  37 58 16  15 36 57  56 14 35 \
            34 55 13  12 33 54  53 11 32  31 52 10   9 30 51  50  8 29  28 49  7 \
             6 27 48  47  5 26  25 46  4   3 24 45  44  2 23  22 43  1   0 21 42)

эта хрень печатает ту самую штуку которую мы хотим 
получить в конечном итоге
резултат имеет вид magic+salt+хеш
    printf "%s$salt\$%s\n" "$magic" "$hex" 

}


если при запуске скрипта не было указано ни одного аргумента
то скрипт пошлет нахер
if [[ $# < 1 ]] 
then
    echo "Usage: $0 password [salt]" >&2 
    exit 1
fi

конвертируем пароль так что каждая литера пароля конвертируется в ее ascii код в hex формате \xnn
скажем пароль был "a" стал "\x61"
формально пароль изменился
но если мы будем печатать пароль через printf то результат на stdout будет одно итоже 
в обоих случаях  printf "a" = printf "\x61"
password=$(stringToHex "$1")

тоже самое для солт
salt=$(stringToHex "$2")

если солт при запуске солта не был указан как аргумент то солт генериуется на основе urandom длинной 16 байт
[[ -z $salt ]] && salt=$(tr -cd 'a-zA-Z0-9' < /dev/urandom | head -c 16) 

запуск главной функции которая нам и посчитает то что мы хотим
doHash "$password" "$salt" '$6$'


############################

вот так и получается та самая строчка в /etc/shadow
пиздец

   
##########################################


    
===
| filebeat 


проверить что конфиг верный
#filebeat test config

но это тоьлко провека что гланый конфиг верный flebeat.yml
а то что у тебя в модулях верно все (/etc/filbeat/modules.d) которые тоже конфиги эта сука так
не проверяет. чтобы проверить что и в модулях все окей надо останвоить filebeat 

# systemctl stop filebeat
и

# sudo filebeat -e -c /etc/filebeat/filebeat.yml

если он не напишет что 
Exiting: Failed to start crawler: creating module reloader failed: could not create module registry for filesets: error unpacking module config :error creating config from fileset nginx/access: error unpacking configuration

pзначит чвсе окей. 
иначе у тебя ориибка в конфиге модуля 




проверить что ест связь с эластиком
# filebeat test output
elasticsearch: http://10.113.151.1:5080/api/default/...
  parse url... OK
  connection...
    parse host... OK
    dns lookup... OK
    addresses: 10.113.151.1
    dial up... OK
  TLS... WARN secure connection disabled
  talk to server... OK
  version: 8.9.0


запускаем айлбит

# systemctl start filebeat
и нао чуть подождить. он падает не сразу
проверяем

# jouralctl -f -u filebeat



дефолтовый частоат  с которой он проверяет файлы логов это 10с.
настраивается через scan_frequency



прописать  путь к модуля иначе их не актививровать
# cat filebeat.yml

filebeat.config.modules:
  path: ${path.config}/modules.d/*.yml

  reload.enabled: false


после этго можно активовть модуль

# filebeat modules enable  elasticsearch



как выгддяит как пример конфиг модуля nginx

.d# cat /etc/filebeat/modules.d/nginx.yml 
- module: nginx
  access:
    enabled: true
    var.paths:     
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/access.log"
        - "/home/magento/magento2-sandbox.magestage.net/log/access.log"


  error:
    enabled: true
    var.paths:  
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/error.log"
        - "/home/magento/pwa-studio.magento2-sandbox.magestage.net/log/error.log"


  ingress_controller:
    enabled: false
    #var.paths:


 важно отметть      что  как я пути прописал. 
 это очен удобно. только надо кавычки ставить чтобы не было ошибоок!
 





===


| SUID
| SGID

во первых в целом про классические file permisons в линуксе (далее просто пермишнс).
для каждого файла этот пермишнс по длинее составляет 3бита*4=12бит
в каждой тройке быты отвеча за разрешение на чтеиние+запись+исполнение=rwx
одна тройка откчает за пермишнсы для владельца обьекта, вторая зя пермишнсы
для группы владельца обьекта и третья тройка битов оотвечате за преминсы для всех остальных
кто полезет к обьекту. четверткая тройка битов имеет особые значения - один бит
отвечает за SUID признак, второй за SGID признак и третий бит за признак "sticky бит".

начнем с SUID бита. что это такое . за что он отвечает что дает.
соглаасно wiki SUID пеерводится как SetUID. забегая вперед скажу что 
сейчас мы говорим про некие атрибуты файла. а далее мы будем говорить о атрибутах запущеного
процесса и у неготоже есть атрибут SUID но он переводится совершенно по другому тоест
это совершенно другой обьект и переводится он как SavedUID но сокращенно выглядит точно
также SUID. итак возвращаемся к файлу , что такое SetUID флаг.
этот бит он как бы устанавливает UID.
что такое UID куда он его устанавливает  и с чем это все едят. Если у файла установлен
бит x скажем для владеьца файла то такой файл разршено "исполнять" . пускай это ELF файл
по своему типу. так вот мы в командной строке указываем путь к файлу и баш вызовет сисколл
который загрузит тело файла в оперативку и передаст на исполнение код этого файла. так вот
у нас возникнет родится новый процесс в системе.  и для этого процесса ядро создаст 
три атрибута UID(EUID), RUID, SUID.

RUID - это id юзера который запустил этот процесс. 
UID или EUID (что одно и тоже) - это id юзера который показывает что этот процессу 
можно делать какими полномочиями этот процесс обладает. именно UID/EUID используется
ядром для сравнения чего хочет сделать процесс с тем что ему позволено делать.

тут надо сказать то что в самом простом случае когда у нас линукс создал процесс по нашму
запросу из файла то у этого процесса RUID=UID\EUID то есть процесс в баше запустил вася
и процесс обладает прававми васи. все красиво логично и просто. более того внезавимости 
от того кто владелец файла процесс будет иметь тот UID который юзер запустил этот файл.
тоесть скажем файл /bin/ex1 его владелец root.root  и сидит вася в баше и тыкает 
этот файл и процесс будет создан с UID=vasya а не с UID=root . потому что вобще то действительно есть фундаментальный вопрос - если мы создаем процесс из файла то какой
UID должен иметь этот процесс? и логичный ответ UID должен быть того юзера который
этот файл запускает. чтобы непривилигорованный юзер мог создаваь только непривилигированные
процессы. тоесть обратим внимание на очень интересуную вещь у нас есть обьект файл и у нас
есть обьект процесс. в целом это две разные несвязанные сущности. у процесса есть UID 
этот UID обозначает какие действия может делать этот процесс в системе.  UID у процесса как бы выражает владельца этого процесса.
у файла тоже есть  владалец у которого есть UID. и этот UID для файла регулирует кто с этим
файлом может менять его содержимое. а теперь фундаментальный вопрос  вася тыкает на файл
у которого владелец петя - тогда какой UID надо присобачивать для процесса который сделан
на основе этого файла?ну и как я уже сказал при создании процесса на основе файла 
плевать кто владелец файла какой UID у владельца файла - новый процесс будет иметь UID 
ттого юзера который тыкнул на этот файл. поэтому нам обычно плевать кто создал файл
и кто его владелец ибо это влияет только на то кто может редактировать тело файла на диске
и UID процесса обычно зависит совсем от друогого - кто запустил файл. итак есть UID у файла
который регулирует кто может редактировать тело файла.  и есть UID у процесса который
обозначает полномочия этого процесса тоесть что этот процесс может или неможет делать 
в системе.  файл похож на рецепт торта. а процесс похож на повара который готовит этот торт.
так вот рецепт мог написать один и только ему разрешено менять этот рецепт. а готовить 
по рецепту может уже другой еинственное что еще вопрос разрешит ли системе готовить
этому другому этот торт в данном конкретном случае.  итак у нас есть вася который 
имеет UID=123 и он запустил файл и создался процесс и обычно по деолфту ядро создат процесс
с 

UID/EUID=123
RUID=123
SUID=123

RUID - показывает кто создавал процесс. кто тыкнул на файл
UID\EUID- показывает что этому процессу разрешено делать. именно с этим полем ядро всегда
сравнивает что процесс хочет делать с тем что ему разрешено.
SUID- это некое предыдущее значение UID. об этом позже.


спрашивается нахера иметь три сущности UID\RUID\SUID. почему не завсети одну.
ответ такой что когда процесс работает то он с помощью сисколлов может менять эти атрибуты.
например процесс может поменять UID налету. скажем схема такая. сидит root и он 
запустил процесс через файл. процсс запустился он имеет UID=0 и этот процесс имеет
типа неограниченные права. он выполянет какието привилигированные операции а дальше
ему уже ненужно иметь такие мощные права и тогда процесс взывает сисколл и просит у ядра
изменить UID на какйото котоый имеет уже минимальные права скажем UID=100500
и тогда ядро меняет UID у процесса и с точки зранеия безопаснтсти это очень хорошо
потому что и сам процесс если код криовй неможет ничего сломать ни какойнибудь взломщик
который както влез в этот процесс неможет через него чтото поломать в системе. 
так вот перехожу к SUID что если мы в работющем процессе через сисколл сменили UID то
преыдудщее значение UID будет засунуто забэкаплено в SUID. зачем так делают об этом ниже
но кратно затем что в ряде случаев ядро позволит процессу еще раз поменять UID но не на произвольный а только на тот кооторый в SUID. но об этом ниже. возгкает вопрос а какой 
SUID на стадии когда мы только запустили процесс ведь никаокго предыдущего занчение в UID еще не было. ответ такой что на старте прцоессе SUID=UID.
также вопрос а можно ли сменить RUID - ведь по идее он ранит инфо кто запутил процесс.
если мы сменим RUID то как бы теряется смысла этого поля. пока что навскидку я вижу что 
RUID все время остается один и тот же но это не точно это надо проверять. там ниже я покажу
как эти атрибуты менятся на лету.

переходим к SUID биту атрибуту у файла. переводится SetUID. (не путать с SUID атрибутом
процесса. suid файла и suid процесса это разные хрени и относятся они к разным обьектам в том числе). так вот SUID файла он не имеет отношения к разграничению прав кто и что может делать
с телом файла. этот атрибут показывает что если файл запустил петя а владельцем файла
укзаан root то процесс должен быть создан с UID=root. таикм образом если у файла выставлен
SUID атрибут то при создании процесса уже играет роялт не кто этт файл тыкнул а кто его 
владелец. 

@@@@ закончил тут

простой юзери будучи вдаледбецем файла неможет сменить его владельца. но может менять
chmod. и может добавить SUID бит. в баше файлы с SUID битом подсвечиваются красным.
если бы юзер мог менять влаеднца на рут. то он мог бы записать в файл любой вредный код.
потом снметьи воадедьца на root. потом преилеить SUID бит и заустит этот код от рута.
кто может выставлять SUID бит?
на скрипты этот бит нерабтает. кроме bash -p ?
прикол sudo touch > 1.txt создаст файл с владельцем vasya! а не root
и только sudo bash && touch 2.txt создаст файл с владельцем root. это прикол
что еще я воде выяснмил из практики. если на файле стоит  даже 777 то менять 
его атрибуты может толкьо владелец. (может еще ктото из группы - проверял). но не лбой
юзер. даже если стоит 777. тоесть премишнсы к файлу опсывают что можно делать внути
файла с его телом. но не с его атрибутами внешними. также прикольно то что вот у нас
есть на папку влаледец вася. он в папке может делать что хочет. в этой папке root
создает файл с влаледльцем root и 777. вася неможет менять пермишнсы на файле. 
но он может его удалить из этой папки. потому что право удалить файл прописывается не 
в пермишнсах файла а в пермищнсах папки в которйо лежит файл. 
таким оюрахлм на самом деел файл как бы имеет три сферы разнымх перминсов:
- кто может мождицифицировать тело файла
- кто может удалять файла
- кто может модициифровать атрибуты его тела 
это разные пермищнсы они просываются в разных местах. и это тоже прикол.
также перминс о том кто может запускать этот файл (x) пропсиыватся в пермишнсах тела файла.










shared librru suid  = гнихуя не дает
suid н файл - в процессах все равно сказано что запустл вася
SGID на папку дает что фалы будет создваны с группой папки алвдедькца
а SUID на папку нихуя не даст

suid на pipg - нахйуй?
suid на симлинк что дает ?

rwsrw-r-x – SUID bit set and the binary is executable
rwSrw-r-x – SUID bit set and the binary is not executable


When you run a SUID bit enabled file, it is being executed with the user-id current user but with an effective id of the owner of that file.
это реьный прикол. файл будео в прцоессах запущен от васи но по факту он буедт 
работать по рутом. это пздц.

The SUID bit is ignored in most of the Unix/Linux so it will not affect the files you create in the directory. But when you set the SGID bit on the directory and then create a file inside it, the group of the new files will be the same as the group of directories.

$ chmod g+s,o+rwx mydir
$ stat -c "%A %n" mydir
drwxr-srwx mydir

при смене владедьца файла через chown SUID бит автоматом сбратсывается\убирается.
и его надо заново активировать!

rwSrw-r-x = вот это означает что SUID усановлен но x бит не устанволен
а 
rwsrw-r-x = это ознаает что и x и suid биты устаовлены


bash скрипы и вообще все файлы кооыер исполнятся интрепреторрами на них suid бит
недействуеи . почему? вот статяь https://unix.stackexchange.com/questions/364/allow-setuid-on-shell-scripts



lsof показывает параметры заущенных процесоов. он берет это из proc.
поэтому можно идти в proc и там все увидеть либо смоетреть через lsof
lsof это некий фронтед визуализатор для /proc/$PID папки



$  sudo lsof -p  32145   2>/dev/null
COMMAND   PID  USER   FD   TYPE DEVICE SIZE/OFF     NODE NAME
ping    32145 vasya  cwd    DIR  259,2     4096 24909215 /home/vasya
ping    32145 vasya  rtd    DIR  259,2     4096        2 /
ping    32145 vasya  txt    REG  259,2    64424 25690241 /bin/ping
ping    32145 vasya  mem    REG  259,2 10281936 23337573 /usr/lib/locale/locale-archive
ping    32145 vasya  mem    REG  259,2   144976 13250066 /lib/x86_64-linux-gnu/libpthread-2.27.so
ping    32145 vasya  mem    REG  259,2    14560 13250054 /lib/x86_64-linux-gnu/libdl-2.27.so
ping    32145 vasya  mem    REG  259,2  2030928 13250051 /lib/x86_64-linux-gnu/libc-2.27.so
ping    32145 vasya  mem    REG  259,2    97072 13250067 /lib/x86_64-linux-gnu/libresolv-2.27.so
ping    32145 vasya  mem    REG  259,2   219304 23339395 /usr/lib/x86_64-linux-gnu/libnettle.so.6.5
ping    32145 vasya  mem    REG  259,2   206872 13243527 /lib/x86_64-linux-gnu/libidn.so.11.6.16
ping    32145 vasya  mem    REG  259,2    22768 13243485 /lib/x86_64-linux-gnu/libcap.so.2.25
ping    32145 vasya  mem    REG  259,2    26616 23343542 /usr/lib/x86_64-linux-gnu/libgtk3-nocsd.so.0
ping    32145 vasya  mem    REG  259,2   179152 13245746 /lib/x86_64-linux-gnu/ld-2.27.so
ping    32145 vasya    0u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    1u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    2u   CHR 136,13      0t0       16 /dev/pts/13
ping    32145 vasya    3u   raw             0t0  1576046 00000000:0001->00000000:0000 st=07
ping    32145 vasya    4u  raw6             0t0  1576048 00000000000000000000000000000000:003A->00000000000000000000000000000000:0000 st=07



$ sudo ls -1al /proc/32145/fd
total 0
dr-x------ 2 root  root   0 июл 30 18:19 .
dr-xr-xr-x 9 vasya vasya  0 июл 30 18:18 ..
lrwx------ 1 root  root  64 июл 30 18:19 0 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 1 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 2 -> /dev/pts/13
lrwx------ 1 root  root  64 июл 30 18:19 3 -> 'socket:[1576046]'
lrwx------ 1 root  root  64 июл 30 18:19 4 -> 'socket:[1576048]'


видно что пинг процесс имеет открытыми два файла которые сокеты. 

тепрь понятна фраза что пинг открыает два raw сокета. по факту это озрнчает что
он делает сисколлыы которые ему открывают два файла которые на бекенде ведут в ядро в сокеты.
и видимо этот сисколл может делать только процесс от рута.

что странно - без SUID  пинг пошлет нахер
$ stat ./ping
  File: ./ping
  Size: 64424     	Blocks: 128        IO Block: 4096   regular file
Device: 10302h/66306d	Inode: 10095974    Links: 1
Access: (0755/-rwxr-xr-x)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-07-30 17:57:55.329820506 +0600
Modify: 2023-07-30 17:53:59.694022907 +0600
Change: 2023-07-30 17:57:41.981829605 +0600
 Birth: -
[vasya@lenovo #7]$ ./ping -c 3 8.8.8.8
ping: socket: Operation not permitted

если же запускаем ping с SUID
$ stat /bin/ping
  File: /bin/ping
  Size: 64424     	Blocks: 128        IO Block: 4096   regular file
Device: 10302h/66306d	Inode: 25690241    Links: 1
Access: (4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)

то видно что ни uid ни euid абсолютно не равны root !!!!
$ ps -p 12226  -o pid,uid,euid,cmd
  PID   UID  EUID CMD
12226  1000  1000 ping 8.8.8.8

и это я понять не могу.!
может этот пинг он стартует. открыает сокет. потом содает форк непривлигированный а 
потом сам себя киляет ??

я запустил ручную  c программу и она в итоге ее процесс имеет UID=65534 (nobody)
как это происходит на уровне сисколлов непонятно птому что при запуске ее
через strace она запускается под васей. 


systemtap - но под нее надо там мудить чтобы она заработалал



ruid = тот кто запустил
uid=euid= какие права у процесса
suid = хранит предыдущий uid

вот эта стаьья = https://www.osso.nl/blog/setuid-seteuid-uid-euid/

и поэтому наступила разгадка насчет пинга. я четко установил вот что :
если у нас у файла владелец "UID=vasya, GID=pupkin"и у файла установлен бит SUID
то 100% процесс будет запущен так что  ps покажет что UID=vasya (вне зависимости от 
того какой юзер из своей консоли нажал на этот файл) тоест например

сидит у на петя в своей консоли 

(petya) $ ./file

то процесс в ps буде виден как 

UID      COMMAND
vasya    ./file


соотвесвтенно если файло владеет root  и запускает его petya то ps покажет что 

UID    COMMAND
root   ./file


теперь я возвращаюсь к конкретному примеру программа ping
у нее владелец root и  SUID установлен .
это значит что если простой юзер запускает команду ping то она вобще то 
должна в ps быть показано что ее UID=root 
однако этого не происходит. потому что как я полагаю что тут уже другой момент.
когда пинг запустился то он реально работает а UID=root
под ним он открыает сокеты. а потом уже ему ненадо иметь такие права
и он сам запускает сисколл наример setuid и понижает права до простого юзера. 
вот и разгадка. именно поэтому мы видим в ps что пинг работает под простым юзером а не root.
вот она разгадка!!

что еще примечательно из второстепенного что поле UID в ps это не юзер который запустил
программу! нет! это показаны эффективные права процесса. тоесть UID это тоже самое что EUID.
а поле которое показыает кто запустил команду это RUID
а есть еще поле SUID. и в ps это совсем не бит SUID. нет. это показан так называемый
saved uid - предыдущее значение uid в случае если процесс в ходе своей работы через сисколлы
постоянно меняет uid. 

это дает еще доп интересный вывод что вот мы смотрим ps -p $PID
и видим некоторый UID. так вот так как процесс может его менять то соверешенно не факт 
что этот же самый процесс чере 10 минут покажет тот же самый UID в ps


| samba
| smb

отлчная стаять я как быстро настроить samba сервер.
чтобы потом можно быо к нему под виндой зайти

https://linuxize.com/post/how-to-install-and-configure-samba-on-ubuntu-18-04/






| nmap
| scan

как быстро найти все хосты в сети LAN

$ nmap -sn 192.168.0.0/24




| openssl

как зашифровать симметрично пароль

    $ echo -n 'пароль' | openssl enc  -aes-256-cbc    -e -v -a -pbkdf2 -salt  -md md5
    




