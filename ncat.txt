ncat

повгорим про эту улититу.


тут с самого начала ряд польебок. оказывается есть nc,ncat,netcat.
по сути это утилита про одно и тоже. оказывается что nc и netcat это одно и тоже. также оказывается 
что есть netcat так нзываемый классический а есть от bsd. есть ncat от компании nmap. 
так что это одна и таже хрень только от разных пронамистов. у них есть у каждоый свои фишки. (каыждый уебок пишет 
обязательно свою релизациию того что уже давно написано)

я щас будут говорить про ncat

есть команда cat она берет файл с диска и читает его. 

netcat тоже открывает файл и читает с него. только это сетевой сокет. 

работает это так - каждый процесс в конечном итоге слепое существо сидящее в темноте.
и у него есть несколко конвейеров которые торчат к нему из темноты - это открытые файлы. 
фишка в том что процесс понятия неимеет куда эти файлы ведут на той стороне. конвейнер 
может вести в файл на диске а может вести через сеть в процесс на другом компе. процессс сидя в темноте 
не знает что является бекендм для открытого доя него файла.

а сетевой сокет это ведь выглядит как - мы  чеерез сисколл просим открыть нам сетевой сокет. 
ядро там чтото шаманит  и процессу с неба спускается конвейнер котой ведет кудато туда хер знает 
куда. и работает это так - процесс кладет байты на конвеер и нажимает кнопку. байты улетают куда то 
наружу хер знае куда процесс об этом уже не забоится. ядро берет эти байты и сует их в сеть срет иими 
через сетевую карту. далее ядро тоже уже ничего не решает.  роутыер пинают эти байты.

байты долетают до компа на той стороне. ядро того компа принимет эти байты. 
далее на том компе есть какойто процесс тоже сидящий в темноте. и у него есть конвеейр торчащий с неба
и ему в этот конвейер прилетают эти байты. это и есть сетевой сокет. 

так вот netcat он что делает. он создает юзер процесс сидящий в темноете. открывает ему несколко файлов.
часть файлов это файлы которые ведут в терминал . один файл по нему процесс полуает байты посланные в терминал.
второй файл это процесс пишет в него и они передаются обратно на терминал. и самый интеересный файл 
это сетевой сокет. тоесть байты котоыре процесс посылает в этот файл они ядром посылаются в сеть на удаленный комп.
и наоброот с удаленного компа байты которые прилетели в ядро оно их пишет в этот файл.  
для юзер проесса это аобсолбтно похер какой бенкенд сиит на том конце файла. он просто либо читает из файла
либо пишет в файл. 
и по факту это работает так - человек в терминале пишет буквы. тыкает энтер. буквы летят в юзер процесс.
он их перенапралвяет в файл котоорый ведет  в сетевой сокет. и наоборот. если что потступило в ффайл сетевой сокет
он это перекидвыает в файл который ведет на терминал.  таки макааром человек через термиал может послыать инфо на удаленный
комп и наоброот если что с удаленного компа прилетело то человек это увидит на терминале. 

вот что делает ncat( и иже с ним nc, netcat).

по сути это программа которая работат  с сетю на уровне L7. 
тоесть она с помощью ядра открывает сеетевой сокет. для нее конечно же он выглдяит просто как некий файл дескриптор.
и она туда пишет и читает. точнее позволяет принимать баыйт с терминала и совать в тот файл. и наобророт - принимать байты
с того файла и перенаправлять их на терминал. вот и весь секрет.

получается позволяет подконектится к сетевому сокету по L7. и через терминал посылать в туда байты и принимать на терминал
оттуда байты.

в той или иной степени это аналог telnet.

окей воспользуемся этим L7 сетевым инстурментом. 
подключимся к SMTP серверу

$ ncat localhost 25
220 lenovo ESMTP Exim 4.90_1 Ubuntu Tue, 12 Sep 2023 03:26:50 +0600
> EHLO localhost
250-lenovo Hello localhost [127.0.0.1]
250-SIZE 52428800
250-8BITMIME
250-PIPELINING
250-CHUNKING
250-PRDR
250 HELP
>MAIL FROM:<smith@usa.com>                                                        
250 OK
>RCPT TO:<vasya@lenovo>   
250 Accepted
>DATA
354 Enter message, ending with "." on a line by itself
>From: smith john <smith@usa.com>       
>To: vasya <vasya@lenovo>        
>Subject: testing 03:29 12 sep 2023
>
>тестовое письмо 12 сент 2023.
>время 03:29
>
>ю
>.
250 OK id=1qfoS3-0004tQ-26

( знаком > я обозначил  строки которые  вводил я . а остальное это ответ SMTP сервера)


письмо можно прочитать в 
$ cat /var/mail/vasya 
From smith@usa.com Tue Sep 12 03:29:40 2023
Return-path: <smith@usa.com>
Envelope-to: vasya@lenovo
Delivery-date: Tue, 12 Sep 2023 03:29:40 +0600
Received: from [127.0.0.1] (helo=localhost)
	by lenovo with esmtp (Exim 4.90_1)
	(envelope-from <smith@usa.com>)
	id 1qfoS3-0004tQ-26
	for vasya@lenovo; Tue, 12 Sep 2023 03:29:40 +0600
From: smith john <smith@usa.com>
To: vasya <vasya@lenovo>
Subject: testing 03:29 12 sep 2023
Message-Id: <E1qfoS3-0004tQ-26@lenovo>
Date: Tue, 12 Sep 2023 03:29:15 +0600

тестовое письмо 12 сент 2023.
время 03:29

ю

то в какую папку и файл будет положено письмо для локального юзера зависит от самой программы SMTP которая висит на 25 порту.
exim кладет в /var/mail/$USER

замечу что /var/spool/mail это симлинк на /var/mail


дальше.
что интересно.
просто так присобачиться приконектится к сокету сетеовму которго нет не получится

пример

$ ncat localhost 56578
Ncat: Connection refused.

а все потому что конект работает на протоколе TCP который подразмуевает что ядро шлет по сети пакет и в обратку должен
прилететь ответрный пакет. а если этоого нет то пошел нахер. 

получается tcp сетевой сокет открывается только в том случае если с той стороны есть ответ. а такого что
мы  "вслепую " создаем сетевой сокет такого нет. должен быть ответ с той стороны.


опция -C дает то что в линуксе в терминале для новой строчки используется LF(Line Feed ) символ "\n"
в то время как типа многие сервера (софт) для новой строки исполбзуют CR (Carriage Return) + LF. 
так вот эта опция она преобразует LF котоырй с терминала летитв  линуксе в CR+LF

вот как дока пишет -  CRLF line endings are required by many protocols, including HTTP, though many servers will accept a plain newline (LF) character.



еще раз как работает ncat.
она открывает сеетевой сокет. и также открвыает файлы на терминал. с терминала принимает поток и сует 
в сокет (который тоже файл). и  наоборот . что   с сокета придетает то сует в терминал обратно.


terminal <---> ncat <---> socket<--- > INET


несколько по другому  раобтает ncat в случае когда оно в режиме сервера работает.
раотает оно так - ncat создает сокет и садится на сет карточку. далее если кто к этому сокету обращается 
то ncat отвечает. тоесть он работает как L7 сервер.  вопрос а что он отвечает? 
тут два варианта. если ему подсунуть файл то он его кидает в ответ. а если ему прорписать команды то 
при обращении на сокет он выполняет эти команды и пихает их вывод в сокет. а если ему в сокет чтото прилетает
то он это выводит в терминал. даааааа. мудота.
рассмотрим на примерах

$ echo 123 | ncat -l localhost 8081 -k 

здесь -l запускает в режиме сервера. тоесть сидит и слушает на сокете.
-k дает то что " Accept multiple connections in listen mode"
по дефолту без ключа -k ncat принимает один конект осблуживает его и заканчитвает свою работу.
с ключом -k он принимает дохера конектов и работу не заканчивает.

значит программа отрабтает вот как - на ее stdin поступил  123. он его сожрала.
далее она открыла сокет и села на интерфейс.
когда мы подключимся к этому сокету то ncat высрет нам в ответ этот 123.
вот так это отработает.

показываю. подключаюсь к сокету

$ ncat -C localhost 8081 
123

и получаем 123 в ответ. все совпало
если мы начнем тыкать кнопки на нашем клиенте. то это будет отослоано обратно в сокет. и на сервере оно вылезет
на терминале показываю

]$ ncat -C localhost 8081 
123  <==== это прислал нам сервер

vasya <===== это я натыкад на клаве

а это я увидел в терминале на сервере
$ echo 123 | ncat -l localhost 8081  -k

vasya  <==== вот это прилетело с клиента

все что прилетело в STDIN на серверер то он выплюнет когда к нему подкоючаться. 
можно влить в stdin через echo . можно через перенаправление вывода тоесть

$ cat<<EOF>1.txt
> мама мыла раму
> EOF

запускаем сервер 
$  ncat -l localhost 8081  -k < ./1.txt 

запускаем клиент
$ ncat -C localhost 8081 
мама мыла раму

все сработало

далее
запускаю сервер 
$ ncat -l localhost 8081 -k


запускаю клиент 
$ ncat -C localhost 8081 
1111  <==== ввожу в терминале

оно улетает на сервер
и вижу на сервере 

$ ncat -l localhost 8081 -k
1111  <=== прилетело на сервер от клиента

также от клиента на сервер можно передать данные и через pipe

$ echo 123 | ncat -C localhost 8081 

на сервере увидим
$ ncat -l localhost 8081 -k
123  <=========


а вот еще пример
$ ncat -l localhost 8081 -k -c "xargs -I % echo 'Вы отослали на сервер == %'"

запускаем этот сервер. как эта шарманка рабоатет
если клиент делает запрос на этот сервер на сокет то сервер исполняет команду указанную в -c
$ xargs -I % echo 'Вы отослали на сервер == %'"
и то что она на выходе рождает отправляется клиенту.

запускаем клиент
]$ ncat -C localhost 8081 
алмаз  <===== вбиваем в терминале
Вы отослали на сервер == алмаз       <==== получаем в ответ от сервера


выяснил еще одну интереснеуйшую вещь вот запускаем сервер
$ echo "123" | ncat -l localhost 8081 -k

запускаем клиент
$ ncat -C localhost 8081
123

пока все норм.
закрываем клиент и запускаем еще раз
$ ncat -C localhost 8081

на экране уже ничего не прилетает от сервера! это говорит о том что сервер только один раз 
посылает клиентам то что у него в STDIN прилетело. он не хранит это в себе. не дублирует. 
прилетело. он запинил и один раз отослал клиенту.

а если мы хотим чтобы сервер много кратно повторял отправку то надо запускать сервер по другому
вот так
$ ncat -l localhost 8081 -k  -c "echo 123" 

это значит что каждый раз когда ктото открывае сокет он будет выполнять эту комнду и ее вывод кидать 
клиенту. поэтому запускаю несколько клиентов. и каждому из них прилетает 123
$ ncat -C localhost 8081
123
$ ncat -C localhost 8081
123


тожесамое касается если мы в stdin суем из файла вот так
$ ncat -l localhost 8081 -k  < index.html
только один раз содержимое файла которое прилетело в STDIN будет отослано первому клиенту.
при повторрном обращении уже сервер ничего не отдаст клиенту

показываю

$ ncat -C localhost 8081
HTTP/1.0 200 OK

<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>

$ ncat -C localhost 8081

тоесть то что было в STDIN сервер один раз отдал первому клиенту. а потом уже все. нечего отдавать.
чтобы отадвать повторно каждый раз страницу надо стелать вот так

$ ncat -l localhost 8081 -k  -c "cat  index.html" 


$ ncat -C localhost 8081
HTTP/1.0 200 OK

<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>


$ ncat -C localhost 8081
HTTP/1.0 200 OK

<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>


это важно для понимания.

теперь пооговорим про веб сервер. что такое веб сервер. это процесс который открывает сетевой сокет и слушает его.
если клиент обращается на этот сокет то он в ответ выдает текст. и не более того. просто отдает в ответ текст.
единственноре что это текст форматированный по некоторму законму. по формату HTTP.
там должен быть заголовок вот такой 
		HTTP/1.0 200 OK
и потом уже тело сообщения 
<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>

если сервер отдает такой текст (подчеркиваю веб сервер это просто програ отдающая по запрому текст. просто он форматирован 
по некоторму проавилу вот и все) в формате HTTP то это и есть веб сервер. вот так все супер просто.

так как у нас сервер отдает текст. плюс в формает HTTP то мы по факту подняли HTTP сервер.
значит можем идтив бразуер и вбивать http://localhost:8081
и наш бразуер нарисует нам странцу.
круто!

я правда непойму на вскидку почему при обращении на такой сервер у нас в его консоли нет вывода о том что ему посылают на сокет.

ладно. запустим просто сервер 
	$ ncat -l localhost 8081 -k

и сделаем запрос к нему через curl
	$ curl localhost:8081
тогда в терминале сервера мы увидим
	$ ncat -l localhost 8081 -k
		GET / HTTP/1.1
		Host: localhost:8081
		User-Agent: curl/7.58.0
		Accept: */*


таким макаром мы узнали что посылает curl по факту на веб сервер при своем запросе
вот это 
		GET / HTTP/1.1
		Host: localhost:8081
		User-Agent: curl/7.58.0
		Accept: */*


единственное что если мы запускаем вот так сервер
		$ ncat -l localhost 8081 -k  -c "cat  index.html" 
то наш сервер пошлет HTTP страницу любому кто обратится и без правльного HTTP зарпроса. 
поэтому наш веб сервер не совсем веб сервер. потому что он выдает HTTP текст даже без правилного запроса.


кстати сделаем через ncat как клиент запрос на настоящий веб сервер nginx
$ docker --rm -d -p 8181:80 nginx

$ ncat -C localhost 8181
GET / HTTP/1.1
Host: localhost:8181        
User-Agent: curl/7.58.0
Accept: */*

HTTP/1.1 200 OK
...


тоесть да. все получилось.

====


--
