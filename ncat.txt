ncat

повгорим про эту улититу.


тут с самого начала ряд польебок. оказывается есть nc,ncat,netcat.
по сути это утилита про одно и тоже. оказывается что nc и netcat это одно и тоже. также оказывается 
что есть netcat так нзываемый классический а есть от bsd. есть ncat от компании nmap. 
так что это одна и таже хрень только от разных пронамистов. у них есть у каждоый свои фишки. (каыждый уебок пишет 
обязательно свою релизациию того что уже давно написано)

я щас будут говорить про ncat

есть команда cat она берет файл с диска и читает его. 

netcat тоже открывает файл и читает с него. только это сетевой сокет. 

работает это так - каждый процесс в конечном итоге слепое существо сидящее в темноте.
и у него есть несколко конвейеров которые торчат к нему из темноты - это открытые файлы. 
фишка в том что процесс понятия неимеет куда эти файлы ведут на той стороне. конвейнер 
может вести в файл на диске а может вести через сеть в процесс на другом компе. процессс сидя в темноте 
не знает что является бекендм для открытого доя него файла.

а сетевой сокет это ведь выглядит как - мы  чеерез сисколл просим открыть нам сетевой сокет. 
ядро там чтото шаманит  и процессу с неба спускается конвейнер котой ведет кудато туда хер знает 
куда. и работает это так - процесс кладет байты на конвеер и нажимает кнопку. байты улетают куда то 
наружу хер знае куда процесс об этом уже не забоится. ядро берет эти байты и сует их в сеть срет иими 
через сетевую карту. далее ядро тоже уже ничего не решает.  роутыер пинают эти байты.

байты долетают до компа на той стороне. ядро того компа принимет эти байты. 
далее на том компе есть какойто процесс тоже сидящий в темноте. и у него есть конвеейр торчащий с неба
и ему в этот конвейер прилетают эти байты. это и есть сетевой сокет. 

так вот netcat он что делает. он создает юзер процесс сидящий в темноете. открывает ему несколко файлов.
часть файлов это файлы которые ведут в терминал . один файл по нему процесс полуает байты посланные в терминал.
второй файл это процесс пишет в него и они передаются обратно на терминал. и самый интеересный файл 
это сетевой сокет. тоесть байты котоыре процесс посылает в этот файл они ядром посылаются в сеть на удаленный комп.
и наоброот с удаленного компа байты которые прилетели в ядро оно их пишет в этот файл.  
для юзер проесса это аобсолбтно похер какой бенкенд сиит на том конце файла. он просто либо читает из файла
либо пишет в файл. 
и по факту это работает так - человек в терминале пишет буквы. тыкает энтер. буквы летят в юзер процесс.
он их перенапралвяет в файл котоорый ведет  в сетевой сокет. и наоборот. если что потступило в ффайл сетевой сокет
он это перекидвыает в файл который ведет на терминал.  таки макааром человек через термиал может послыать инфо на удаленный
комп и наоброот если что с удаленного компа прилетело то человек это увидит на терминале. 

вот что делает ncat( и иже с ним nc, netcat).

по сути это программа которая работат  с сетю на уровне L7. 
тоесть она с помощью ядра открывает сеетевой сокет. для нее конечно же он выглдяит просто как некий файл дескриптор.
и она туда пишет и читает. точнее позволяет принимать баыйт с терминала и совать в тот файл. и наобророт - принимать байты
с того файла и перенаправлять их на терминал. вот и весь секрет.

получается позволяет подконектится к сетевому сокету по L7. и через терминал посылать в туда байты и принимать на терминал
оттуда байты.

в той или иной степени это аналог telnet.

окей воспользуемся этим L7 сетевым инстурментом. 
подключимся к SMTP серверу

$ ncat localhost 25
220 lenovo ESMTP Exim 4.90_1 Ubuntu Tue, 12 Sep 2023 03:26:50 +0600
> EHLO localhost
250-lenovo Hello localhost [127.0.0.1]
250-SIZE 52428800
250-8BITMIME
250-PIPELINING
250-CHUNKING
250-PRDR
250 HELP
>MAIL FROM:<smith@usa.com>                                                        
250 OK
>RCPT TO:<vasya@lenovo>   
250 Accepted
>DATA
354 Enter message, ending with "." on a line by itself
>From: smith john <smith@usa.com>       
>To: vasya <vasya@lenovo>        
>Subject: testing 03:29 12 sep 2023
>
>тестовое письмо 12 сент 2023.
>время 03:29
>
>ю
>.
250 OK id=1qfoS3-0004tQ-26

( знаком > я обозначил  строки которые  вводил я . а остальное это ответ SMTP сервера)


письмо можно прочитать в 
$ cat /var/mail/vasya 
From smith@usa.com Tue Sep 12 03:29:40 2023
Return-path: <smith@usa.com>
Envelope-to: vasya@lenovo
Delivery-date: Tue, 12 Sep 2023 03:29:40 +0600
Received: from [127.0.0.1] (helo=localhost)
	by lenovo with esmtp (Exim 4.90_1)
	(envelope-from <smith@usa.com>)
	id 1qfoS3-0004tQ-26
	for vasya@lenovo; Tue, 12 Sep 2023 03:29:40 +0600
From: smith john <smith@usa.com>
To: vasya <vasya@lenovo>
Subject: testing 03:29 12 sep 2023
Message-Id: <E1qfoS3-0004tQ-26@lenovo>
Date: Tue, 12 Sep 2023 03:29:15 +0600

тестовое письмо 12 сент 2023.
время 03:29

ю

то в какую папку и файл будет положено письмо для локального юзера зависит от самой программы SMTP которая висит на 25 порту.
exim кладет в /var/mail/$USER

замечу что /var/spool/mail это симлинк на /var/mail


дальше.
что интересно.
просто так присобачиться приконектится к сокету сетеовму которго нет не получится

пример

$ ncat localhost 56578
Ncat: Connection refused.

а все потому что конект работает на протоколе TCP который подразмуевает что ядро шлет по сети пакет и в обратку должен
прилететь ответрный пакет. а если этоого нет то пошел нахер. 

получается tcp сетевой сокет открывается только в том случае если с той стороны есть ответ. а такого что
мы  "вслепую " создаем сетевой сокет такого нет. должен быть ответ с той стороны.


опция -C дает то что в линуксе в терминале для новой строчки используется LF(Line Feed ) символ "\n"
в то время как типа многие сервера (софт) для новой строки исполбзуют CR (Carriage Return) + LF. 
так вот эта опция она преобразует LF котоырй с терминала летитв  линуксе в CR+LF

вот как дока пишет -  CRLF line endings are required by many protocols, including HTTP, though many servers will accept a plain newline (LF) character.



еще раз как работает ncat.
она открывает сеетевой сокет. и также открвыает файлы на терминал. с терминала принимает поток и сует 
в сокет (который тоже файл). и  наоборот . что   с сокета придетает то сует в терминал обратно.


terminal <---> ncat <---> socket<--- > INET


несколько по другому  раобтает ncat в случае когда оно в режиме сервера работает.
раотает оно так - ncat создает сокет и садится на сет карточку. далее если кто к этому сокету обращается 
то ncat отвечает. тоесть он работает как L7 сервер.  вопрос а что он отвечает? 
тут два варианта. если ему подсунуть файл то он его кидает в ответ. а если ему прорписать команды то 
при обращении на сокет он выполняет эти команды и пихает их вывод в сокет. а если ему в сокет чтото прилетает
то он это выводит в терминал. даааааа. мудота.
рассмотрим на примерах

$ echo 123 | ncat -l localhost 8081 -k 

здесь -l запускает в режиме сервера. тоесть сидит и слушает на сокете.
-k дает то что " Accept multiple connections in listen mode"
по дефолту без ключа -k ncat принимает один конект осблуживает его и заканчитвает свою работу.
с ключом -k он принимает дохера конектов и работу не заканчивает.

значит программа отрабтает вот как - на ее stdin поступил  123. он его сожрала.
далее она открыла сокет и села на интерфейс.
когда мы подключимся к этому сокету то ncat высрет нам в ответ этот 123.
вот так это отработает.

показываю. подключаюсь к сокету

$ ncat -C localhost 8081 
123

и получаем 123 в ответ. все совпало
если мы начнем тыкать кнопки на нашем клиенте. то это будет отослоано обратно в сокет. и на сервере оно вылезет
на терминале показываю

]$ ncat -C localhost 8081 
123  <==== это прислал нам сервер

vasya <===== это я натыкад на клаве

а это я увидел в терминале на сервере
$ echo 123 | ncat -l localhost 8081  -k

vasya  <==== вот это прилетело с клиента

все что прилетело в STDIN на серверер то он выплюнет когда к нему подкоючаться. 
можно влить в stdin через echo . можно через перенаправление вывода тоесть

$ cat<<EOF>1.txt
> мама мыла раму
> EOF

запускаем сервер 
$  ncat -l localhost 8081  -k < ./1.txt 

запускаем клиент
$ ncat -C localhost 8081 
мама мыла раму

все сработало

далее
запускаю сервер 
$ ncat -l localhost 8081 -k


запускаю клиент 
$ ncat -C localhost 8081 
1111  <==== ввожу в терминале

оно улетает на сервер
и вижу на сервере 

$ ncat -l localhost 8081 -k
1111  <=== прилетело на сервер от клиента

также от клиента на сервер можно передать данные и через pipe

$ echo 123 | ncat -C localhost 8081 

на сервере увидим
$ ncat -l localhost 8081 -k
123  <=========


а вот еще пример
$ ncat -l localhost 8081 -k -c "xargs -I % echo 'Вы отослали на сервер == %'"

запускаем этот сервер. как эта шарманка рабоатет
если клиент делает запрос на этот сервер на сокет то сервер исполняет команду указанную в -c
$ xargs -I % echo 'Вы отослали на сервер == %'"
и то что она на выходе рождает отправляется клиенту.

запускаем клиент
]$ ncat -C localhost 8081 
алмаз  <===== вбиваем в терминале
Вы отослали на сервер == алмаз       <==== получаем в ответ от сервера


выяснил еще одну интереснеуйшую вещь вот запускаем сервер
$ echo "123" | ncat -l localhost 8081 -k

запускаем клиент
$ ncat -C localhost 8081
123

пока все норм.
закрываем клиент и запускаем еще раз
$ ncat -C localhost 8081

на экране уже ничего не прилетает от сервера! это говорит о том что сервер только один раз 
посылает клиентам то что у него в STDIN прилетело. он не хранит это в себе. не дублирует. 
прилетело. он запинил и один раз отослал клиенту.

а если мы хотим чтобы сервер много кратно повторял отправку то надо запускать сервер по другому
вот так
$ ncat -l localhost 8081 -k  -c "echo 123" 

это значит что каждый раз когда ктото открывае сокет он будет выполнять эту комнду и ее вывод кидать 
клиенту. поэтому запускаю несколько клиентов. и каждому из них прилетает 123
$ ncat -C localhost 8081
123
$ ncat -C localhost 8081
123


тожесамое касается если мы в stdin суем из файла вот так
$ ncat -l localhost 8081 -k  < index.html
только один раз содержимое файла которое прилетело в STDIN будет отослано первому клиенту.
при повторрном обращении уже сервер ничего не отдаст клиенту

показываю

$ ncat -C localhost 8081
HTTP/1.0 200 OK

<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>

$ ncat -C localhost 8081

тоесть то что было в STDIN сервер один раз отдал первому клиенту. а потом уже все. нечего отдавать.
чтобы отадвать повторно каждый раз страницу надо стелать вот так

$ ncat -l localhost 8081 -k  -c "cat  index.html" 


$ ncat -C localhost 8081
HTTP/1.0 200 OK

<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>


$ ncat -C localhost 8081
HTTP/1.0 200 OK

<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>


это важно для понимания.

теперь пооговорим про веб сервер. что такое веб сервер. это процесс который открывает сетевой сокет и слушает его.
если клиент обращается на этот сокет то он в ответ выдает текст. и не более того. просто отдает в ответ текст.
единственноре что это текст форматированный по некоторму законму. по формату HTTP.
там должен быть заголовок вот такой 
		HTTP/1.0 200 OK
и потом уже тело сообщения 
<html>
  <body>
    <h1>Hello, world!</h1>
  </body>
</html>

если сервер отдает такой текст (подчеркиваю веб сервер это просто програ отдающая по запрому текст. просто он форматирован 
по некоторму проавилу вот и все) в формате HTTP то это и есть веб сервер. вот так все супер просто.

так как у нас сервер отдает текст. плюс в формает HTTP то мы по факту подняли HTTP сервер.
значит можем идтив бразуер и вбивать http://localhost:8081
и наш бразуер нарисует нам странцу.
круто!

я правда непойму на вскидку почему при обращении на такой сервер у нас в его консоли нет вывода о том что ему посылают на сокет.

ладно. запустим просто сервер 
	$ ncat -l localhost 8081 -k

и сделаем запрос к нему через curl
	$ curl localhost:8081
тогда в терминале сервера мы увидим
	$ ncat -l localhost 8081 -k
		GET / HTTP/1.1
		Host: localhost:8081
		User-Agent: curl/7.58.0
		Accept: */*


таким макаром мы узнали что посылает curl по факту на веб сервер при своем запросе
вот это 
		GET / HTTP/1.1
		Host: localhost:8081
		User-Agent: curl/7.58.0
		Accept: */*


единственное что если мы запускаем вот так сервер
		$ ncat -l localhost 8081 -k  -c "cat  index.html" 
то наш сервер пошлет HTTP страницу любому кто обратится и без правльного HTTP зарпроса. 
поэтому наш веб сервер не совсем веб сервер. потому что он выдает HTTP текст даже без правилного запроса.


кстати сделаем через ncat как клиент запрос на настоящий веб сервер nginx
$ docker --rm -d -p 8181:80 nginx

$ ncat -C localhost 8181
GET / HTTP/1.1
Host: localhost:8181        
User-Agent: curl/7.58.0
Accept: */*

HTTP/1.1 200 OK
...


тоесть да. все получилось.

далее я конекчюсь к nmap.org
и я заметил что при таком заголовке
Host: nmap.org:443
то веб сервер посылает нахер. тоесть надо на самом деле вот так делать
Host: nmap.org

или в полной форме 
$ ncat -C --ssl   nmap.org 443
GET / HTTP/1.1
Host: nmap.org
User-Agent: curl/7.58.0
Accept: */*

HTTP/1.1 200 OK
....


здесь я заюзал еще одну фича ncat а имеено он умеет конектится в качестве клиента по ssl
--ssl позволяет подключаться в качестве ssl клиента к удаленнму серверу. 
но он по факту както поииотски работает . не проверяет валидность сертфиката. как и его наличие вобще.
поэтому более коректная форма ключ --ssl-verify


$ ncat -C --ssl-verify   nmap.org 443
GET / HTTP/1.1
Host: nmap.org
User-Agent: curl/7.58.0
Accept: */*

...
HTTP/1.1 200 OK


Verification is done using the ca-bundle.crt certificate bundle shipped with Ncat, plus whatever trusted certificates the operating system may provide. If you want to verify a connection to a server whose certificate isn't signed by one of the default certification authorities, use the --ssl-trustfile to name a file containing certificates you trust.

 The file must be in PEM format.

ncat -C --ssl-verify --ssl-trustfile <custom-certs.pem> <server> 443


далее
ncat может работать как сервер и отвечать по SSL
ему надо подсунуть сертификат и приватный ключ или создать с нуля.
как создать  с нуля смотри "ssl.txt"

запускамем ncat в режиме сервера плюс ssl
	$ ncat --listen --ssl --ssl-cert test-cert.pem --ssl-key test-key.pem 8282

теперь покдлючаемся в режиме клиента. но чтобы клиент мог прроверить самоподисанный сертификат 
то ему надо укзаать что наш сертификат является доверенным
	$ ncat --ssl-verify --ssl-trustfile test-cert.pem -C  magento.local  8282


далее надо подчеркнуь что ncat не является ни в коем случае веб сервером в режиме -l
он просто может отдавать файлы форматиорванные в HTTP формате и все. а веб сервер он умеет обрабатывать запросы вида PUT/POST итд.
а ncat тупо шлет в сокет то что  у него засунуто в STDIN либо выполянет команду при открытии сокета. 


далее. есть очень важное практичесокое применение для ncat
это пересылка файлов между компами. например внутри локалки или по впн каналу между серверами. 
еслимы не хотим юзать scp\rsync оба из которых  тратят цпу на шифрование и требуют аутантификации.
переслыка файлов через ncat выглядит так 
на отправляющей стороне запускаем: 
		# tar cv --to-stdout /root/downloads/  | pv |  ncat -l 8383  --send-only
на принимающей стороне запускаем:
		# ncat --recv-only 10.113.151.191 8383 | pv |  tar -C .  -xvf -

( "pv" чисто для визуализации скорости копирования)
--send-only = говооит о том что через сокет можно только отправлят. а принимать ничего нельзя. это мы 
выставляем на отправляющей стороне
--recv-only = говрит что через сокет можно только принимаь. а отпрвлять оборатно ничего нельщзя.делаем 
так на принимающей стороне
	( страничка на которой описано это https://nmap.org/ncat/guide/ncat-file-transfer.html)

в доках они предлагают еще такой вариант
	host2$ ncat -l | tar xzv
	host1$ tar czv <files> | ncat --send-only host2

еще они дают вариант когда копироание идет через хост посредник. исползуктся фича --broker
	host3$ ncat -l --broker
	host2$ ncat host3 > outputfile
	host1$ ncat --send-only host3 < inputfile


чат система через ncat
на одном хосте запускаем
	$ ncat  -l -k --broker 8383
на втором хосте запускаем
	$ ncat -C  localhost 8383
на третьем хосте запукаем
	$  ncat -C  localhost 8383

теперь все что пишет хост 2 и видно хосту 3. и наоборот. на хосте 1 ничего не будет дублировано.
но если чото написать на хосте 1 то это видно хосту 2 и 3

если добаит ключ --chat на брокере то тогда каждому конекуту автоматом будет добавлен юзер-нейм. что удобно
для чата


далее. 
на этой странице https://nmap.org/ncat/guide/ncat-tricks.html
они пишут о том что ncat можно юзать как web server 
это брехня. веб сервер это нетолько такая штука котоаря отсылает клиенту HTTP текст. но также веб сервер
должен адекватно реагировать на команды PUT/POST итд.
а ncat внезависимости от запроса отдает страницу. поэтому это пародия на веб сервер.

далее.
вот таки проксируется доступ к локального порта на удаленный хост
$ ncat -l localhost 8383 --sh-exec "ncat IP 22"
как эта команда работает - поднимается tcp сервер на порту 8383. если я обращаюсь к порту 8383 то выполяется команда
	$ ncat IP 22
тоесть создается новый процесс и  то что процесс кидает на stdout пересылается мне, тоесть stdout процесса увязыается
видимо через pipe с файлом который ведет на сокет который содеиняет со мной. поэтому когда ncat IP 22 чтото плюет на свой
stdout это через сокет прилетает мне.


тоесть 
мой процесс клиент                        процесс ncat -l localhost 8383 ...          ncat IP 22
socket <--------------------------------> socket <----------------------------------> stdout 

соотвесвтенно когда на сокет моего клиента чтото прилетает то он это пересылает на терминал.
что еще интерсно это то что - то что я в своем клиенте шлю на 8383 это пересылается на stdin запущенного процесса.
тоесть схема получается такая

мой клиент шлет на ------------> localhost 8383 (ncat) а он это пеересылает на  stdin ( ncat ip 22)
в тоже время то что вылетает из stdout (ncat ip 22) заколоьцовано на сокет 8383 и он это переслылает мне обратно.
таким образом получается что процесс на моем компе (клиент) его stdin условно говоря приконекчен к stdin процесса
на удаленном компе. а stdout процесса на удаленном компе приконекчен к stdout моего локального процесса.
конект идете через ncat.
поэтому в итоге ncat выступает как проксификатор.

вот еще пример на эту же тему.
запускаем сервер
	$ ncat -l localhost 8383 --sh-exec "cat "
запускаем клиент
 	$ ncat localhost 8383

как только наш клиент подключаился к серверу на сервере запускается команда cat
и ее stdout заворачивается на stdout ncat. который в свою очередь заворачивается на ее сокет.
поэтому то что будет высирать cat оно в итоге возвращается ко мне в терминал. потому что мой лкальный ncat все что получает
из сокета переводит на stdout тоесть на терминал.

когда я только подключился то с сервера не прилетит ничего потому что cat на своем stdin не имеет ничего.
но вот я в своем терминале пишу vasya нажимаю ENTER. то что влетело в stdin от моего процесса ncat он направляет в сокет
и это улетает на удаленный ncat. а он то что получил через сокет перенаправляет на stdin прцоесса cat. тогда cat высирает
vasya в свой stout который закольцован на ncat который это пересылает обратно мне по сокету  а мой ncat то что получил из сокета
переанарравляет на stdout тоесть терминал. поэтому я увижу в своем терминале от сервер еще одно vasya
тоесть

$ ncat -C localhost 8383
vasya  <===== это написал я 
vasya  <===== это прилетело в ответ

получается все что влетает в stdin на моем компе  в итоге поступает на stdin на удаленном компе на cat
и то что вылетает на stdout на удаленном компе из cat в итоге попаадает на stdout моего компа.

поэтому есл мы заменим cat на "ncat IP 22" это дает то что  мы на удаленном компе установили конект с удаленным сервером 
по порт 22. и то что ncat ip 22 будет выдавать на stdout мы будем получать на наш экран.
а то что мы будем пихать на нашем компе в stdin оно будет попадать в stdin уже на удаленном компе.
тоесть

(наш лэптоп)$ ncat -C serverA 8383
(serverA) $ ncat -l 8383 --sh-exec "ncat serverB 22"


это даст то что мы с нашего компа подключаемся к серверуB через проксирование серверA

тут важно запомнитьчто если у нас на компе запущено ncat -l 8383 -с "команда"
то когда мы подключимся к этому серверу то все что "комада" выдает на stdout это перехыавыается и преенаравляется к нам.
а то что мы будем пихать в сокет 8383 с нашего компа то будет перенаправлено на stdin этой "команды".
таким оббоаразом мы можем взавимосдетовтвьа на "команда" на удаленном компе как бутто это команда запушена на нашем компе
локаллно. точнее как бутто мы сидим за удаленным компом и наш клиент запущен наудаленном компе и мы там напрямую 
взаимодейтситвуем с той командой.
ее stdout попадает нам на экраен. а наш stdin перенаправляется на ее stdin.

например мы можем получить инфо что с дисками на удаленной системе.
на удаленном компе запускаем
$  ncat -l localhost 8383 --sh-exec "df -h "

а на нашем лэпотпе запускаем
$ ncat -C localhost 8383
и мы получим у себя на экране вывод команда df -h с удаленного компа. ее stdout бдует перенаправлен нам.

еще прмиер
		$ ncat -l localhost 143 --sh-exec "ncat --ssl imap.example.com 993"
эта команда позвоялет нам обративишсь на localhost:143 по факту обраиться на imap.example.com:993
при том что ncat будет как клиент общатбся с удаленным хостом по протоколу SSL
тоесть он занимается шифрованием. а наша клиентская прграмма уже читаем нешифрованный поток.

вот еще пример я проксрую досутп на веб сайт. мой клиент может работать по HTTP
а ncat на себя берет уже SSL проксирование

запускаем сервер
$ ncat -k -l localhost 8383 --sh-exec "ncat --ssl nmap.org 443"

запускаем клиент
$ ncat -C localhost 8383
GET / HTTP/1.1        
Host: nmap.org
User-Agent: curl/7.58.0
Accept: */*

HTTP/1.1 200 OK
....

тоесть я на https сервер обратился чреез http клиент через https посредник ncat

