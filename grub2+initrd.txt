| grub
| initrd


здесь будет новая инфо по граьу - 
как его ставить как он работает. как он загружает ядро.
и о том как рабтает initrd файл до того моомента когда
от него линукс уже избавляется

первый важный момент - когда мы поставили грабо то он сосотит
из нескоьких кусков. каждйы кусок устанволен в ранзном месте
и загружается по цепочеке оодин за другим.

я рассматривю сучай комп с BIOS  + диск на GPT
други еварианты пока нахуй

один его кусок это первый сектор диска размером 512 байт.(stage1 или boot1 стадия)
второй кусок это кусок размеро ~ 50-100KB (stage1.5) он лежит на спец разделе
котоырй нужно созтьа на диске и не формтировать зато этот раздел должер иметь 
спец номер типа раздела (делается через patrted)
и трейти кусок это уже большой раздел на диске форматрованном скажем в ext2/3
где уже лежит его осталная часть в том числе и конфиг grub.cfg
вначале граб должне загрузить самого себя. потом он уже может зарузть ядро линкса
и передать ему управление. дело в том что ядро линкса это не просто ELF
это несмтостяттелная хрень. нужно файл ядра и инитрд положить в определенные
адреса в памяти все там правильно подгтовтить и толко тогда можно на них
натравливать цпу. просто так ядро если на него тыкнуть оно не запустится 


ксати а что такое файл ядра с точки рзрения согмого линкса ?
 ཈  $ sudo file  /boot/vmlinuz-5.4.0-91-generic 
/boot/vmlinuz-5.4.0-91-generic: Linux kernel x86 boot executable bzImage, version 5.4.0-91-generic (buildd@lgw01-amd64-024) #102~18.04.1-Ubuntu SMP Thu Nov 11 14:46:36 UTC 2021, RO-rootFS, swap_dev 0x9, Normal VGA


непонярно. это elf или не elf. ладно хуй с этим

сам граб походу пьесы это маленький сам линукс. например его модули имеют ELF формат


 耠  $ readelf -d /boot/grub/x86_64-efi/acpi.mod 

There is no dynamic section in this file.
 ?   $ file  /boot/grub/acpi.mod 
/boot/grub/acpi.mod: cannot open `/boot/grub/acpi.mod' (No such file or directory)
 : ꆌ  $ file  /boot/grub/x86_64-efi/acpi.mod 
/boot/grub/x86_64-efi/acpi.mod: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
 d 鳠  $ 

он очень сам похож на линукс


вначале граб грузит boot0 с того диска который мы укааали в биосе как загрузчный
потом граб грузит boot1.5 там у него уже вшиты основные модули. ксаи каждый модуль он в шелл граба
дает свои новые команды .так вот кода загузлся boot1.5 граба то у него уже в памяти есть
основные модули а значит и командная строка (шелл) и также в boot1.5 укзано где грабу
искать свою третью часть на каком диске и партиции. там лежат его все остальные модули
и конфиг файл grub.cfg который нужен ему чтобы узнать какие модули и откуда ему нужо
в конечном итоге прочитать и на ккком диске и партиции лежит ядро ос которое 
ему нужно загрузить. так вот с точки зрения граба его третья часть хранится на root
дискея+партиции (у него это в единое укзвыается)  в виде (hd0,gpt1)
это переенная в памяти граба. так вот в boot1.5 эта переменная root уже прописана.
еще раз перенная root укзывает груба на каком диске+ партиации лежит конфиг файл grub.cfg
в котроом что само непонятнотое еще раз занвоо прописывается грабовская root 
перменная о том на каком диске и партации лежит его grubc.cfg и модули которые ему 
будут нужны для загрузки ядра ос. 
полчается ебнутая схема.

boot1.5 в нем укзано где лежит диск+партиция  root где лежат его прдварриельные моудули 
и предвариетдный grub.cfg в которо просиана ановая переменая root которая укзаыает
где лежит основной grub.cfg и модули которые ему бует нужрны для заргурузия ядра ос . это пдец !

поэтому 99% строчек в grub.cfg они отнотся не к настрокам как бы ему загрузить ядро ос 
а о том где дежит его root диск _ +парциия! это пздпец!  и та перемная root неимеет
никакого отншения к записили linux vmlinuz ... root=
это про другое . это уже сообщение яру линукса где ему искать root апртиацию свою.
рабу на это похуй. это пиздец!

в кониге граба к загрузке ядра только 2 строчки
	linux ...
	initrd

кстати эти слова это названия модулей котоые как раз таки занимаются тем что суют 
эти файлы в паять. 


про щзагрузку inird
то что мы ядру передаем в строке kernel ...... 
он это хрниит в /proc/cmdline
а init из inirrd это читает в баш скрипте своем init
прыйпроецесс котоырй лирнукс запускает это не /rooot/init из initrd файла это /bin/sh
из inird файла. который видим через execve зпускает уже init фа1л (проуереть кто ppiD?)
и этот init скрипт читает proc/cmdline и сует себе в паямть это ка переенные баша
посмтреть /sbinlsmod он же /bin/kmod какие модули загружены?
что с консолью ? 

find . -print0 | cpio --null --create --format=newc > ../newinitrd
find . | cpio --create --format=newc | gzip -9   >> ../newinitrd


когда делает insmod нужно писать полный путь к модулю включая .mod на конец тоесть
	$ insmod (hd0,gpt2)/boot/grub/i386-pc/ls.mod


комнда boot она говорит грабу из шелла чтобы он шел по пути указнному перееменной 

tty, и pid инит прцоесса? (как он создет термианла?)
поставить баш, натыкать sh в несолкькиместах. я думаю что run-init 
идет нахуй из за невозможнси открыть темрианал?
надо понять ключ -n это он уже сделаь cjhrot или нет?


он ставит свой  кусок boot1 разамером 512 байт в первый сектор диска. 
потому второй кусок boot1.5 он ставит на как я понял на раздел который надо создать
на диске но не форматиовать ему там надо ~ 100KB но радел обычно создают 1 MB
и все остальное а целая папка в которой размещены его модули. его главный конфиг
	grub.cfg
ставить уже как папка с файлам на раздел скажем ext2\3\4
тоесть оно стсотоит из трех частей.  часть модулей он засоывает свою boot1.5 хрень.

настройка котоые мы делаем в /etc/default/grub они в итоге как я понял все идут 
только в grub.cfg но они не меняеют boot1.5 или boot0


