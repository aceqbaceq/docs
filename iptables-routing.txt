важный момент который  я открыл.



как у нас процесс работает с сетью.
процесс создает сокет. далее процесс пишет в сокет
данные. имеется ввиду пейлоад текст например 
какойто. а ядро берет этот текс из сокета  и начинает
заворачивать его в  tcp+ip+ethernet фрейм и совать
в сеть. рассмотрим случай когда инциатором конкта
яялется наш процесс.

помимое пейлоад наш процесс еще должен сунуть в сокет
такую инфо как dest_ip.  но ядру чтобы изготвоить 
сетевые пакеты нужно еще узнать\определить src_ip
и имя сетевой карты через которую этот пакет нужно
выплюнуть. итак еще раз наш прцесс сует в сокет
такой параметр как dest_ip а  само ядро самостоятеьно
опредяет такие парамтеры как src_ip и имя сетевой 
карты. 

далее процесс начинает совать в сокет просто байты
с данными которые к сети неимеют никаго отношения
и делает это процесс через write() либо sendto()

   write(fd,"мама мыла раму")
   sendto(fd,"ехал грека через реку")


здесь важно понять то что после того как прцосс 
сунул в сокет dest_ip то он больше никакие сетевые
параметры в сокет не сует. процесс просто начинает
совать в сокет тлько пейлоад и больше ничего.
за вест сетевой процсс начианет ответчать только ядро.

оно берет из сокета кусок полезных данных "мама мыла раму", далее ядро сует эти данные в tcp пакет.
этот пакет оно сует в ip пакет в которое ядро
запмывает 

  src_ip , dest_ip

где dest_ip это инфо котороые ядру собщил процесс.
а src_ip это инфо которое ядро само определило (как? щас расскажу)  , далее ядро сует этот пакет в эзернет
фрейм параметры которго ядро тоже само определило (как оно это сделао нам щам неважно)  далее ядро прогоняеь
этот пакет через правила иптейблс в течение которых
у пакета могут поменяться параметры 

  src_ip , dest_ip

дада ! они могут там при прохоеде через иптейбс
поменяться! и также может поменяться сет карта в 
которую пакет будет засунут.  также пакет просто 
может быть дропнут внутри ипейтейблс. ив итоге
если пакет дожил до конца всей обработки через 
ипблейс то у него будут какието 

  src_ip1 , dest_ip1

и какое то имя сетевой карты в которую ядро решило
сунуть это пакет. и наконец ядро сует этот пакет
в сетевую карту!

о том как ядро выбирает началный src_ip и как оно 
выбирает ночальную сетевую карту в которую хочет
сунуть пакет мы ниже поговорим. а щас я хочу
акцентирвать внимание на другом важном. на том что 
ядро ожидает что в обратку удаленная система  пришлет
нам пакет ровно стаиким же  src_ip1 , dest_ip1
только поменянными местами. если у нас  наш изна
чальнй пакет претерпел изменения из 

	src_ip=IP1, dest_ip=IP2

в 

   src_ip1=IP3 , dest_ip1=IP4

знчит в талице иатпблс установлен NAT  и при получении
"обратного" пакета тоесть  такого что 


  src_ip2=IP4,  dest_ip2=IP3

тоесть пакет который вылетел из компа 

   src_ip1=IP3 , dest_ip1=IP4

и пакет который мы получии в ответ 

  src_ip2=IP4,  dest_ip2=IP3

они отличаются тем что у них в точности поменяны
IP адреса то этот NAT он автоматом проведет "обрат
ную " замену и наш пакет первратиться в 

  dst_ip2=IP2,  src_ip2=IP1

и этот орабный пакет будет оиличаться от оригинальног
пакета вылезшего из сокет процесса

	src_ip=IP1, dest_ip=IP2

будет отличаться тем что у него просто будут поменяны
местами ип адреса. ТАК ВОТ! только в этом случае
ядро засунет такой пакет в сокет нашего процесса!


зачем я это распиывал? а за тем что ! если у нас 
есть сокет который принадджеит процессу. то этот 
сокет имеет вписанную в него пару LOCAL_IP DEST_IP
так вот. если мы из этого сокета высрали наружу
исходящий пакет с параметрами 

   LOCAL_IP DEST_IP

и если к нам в ответ прилетел некий пакет то ядро
этот влетевщий пакет засунет в этот же сокет в том
и только том случае если влетевший пакет имеет
точно такой же вид 

   LOCAL_IP DEST_IP

есдт влетевщий пакет имеет вид нетакой то он никогда
в наш процесс непопадет! это означает ! что если 
у нас в комп велетел каойто входяий пакет с 
параметрами 

  IP1  IP2 

то мы в ответ обязаны в нем нихуя не менять эти
парамтеры! мы тлоько можемм их поменять местами.
а если мы изменим эти параметры то наш "ответный"
пакет нихуя не будет получен тем кто его отправил!
тоесть на примрере.

положим нам в комп прилетел пакет

  dest_ip=192.168.10.1  src_ip=1.1.1.1

так вот мы неимеем права в нем менять эти ип адреса.
мы тлько можем их поменять местами

  src_ip=192.168.10.1  dest_ip=1.1.1.1

в нашем отвеном пакете. 
а если мы в этом пакете заменим src_ip ан какойто 
другой то этот пакет наш оветный никогда не будет
доставлен в сокет того удаленого прилоежния которое
нам этт пакет прислало!  ВОТ ЧТО ВАЖНОГО Я ХОТЕЛ 
ДОНЕСТИ!

как это выгядит на уровне сокетов для случая когда
мы принмиае внешние конекты. у нас есть слушаюий
сокет. который опредееляет dest_IP или по другому
гвоорят LOCAL_IP . если в ядрл влетает некий новый
пакет с 
  
 dest_IP=LOCAL_IP и какимто SRC_IP=IP1

то ядро клониурет наш слушающий сокет (при условии
что мы в процессе запустили accept(fd) )
и в этот новый сокет ядро запишет 

 LOCAL_IP  REMOTE_IP=IP1

и теперь у нас паарметр входящего и исходяшего
пакета для этго сокета жестко задан. наше ядро
будет слать в сеть пакет 

 src_IP=LOCAL_IP  drst_ip=REMOTE_IP=IP1

и в ответку будет ждать пакеты вида

 dst_IP=LOCAL_IP  src_ip=REMOTE_IP=IP1


таким мкром эта хрень жестко задана. ее меять
нельзя
тоесть еще раз на прмиере.
если на наш комп приелет входяий пакет вида


  dst_ip=192.168.10.1   src_ip=1.1.1.1

то мы обязаны на нено оветить только пакетом 
вида 

  src_ip=192.168.10.1   dst_ip=1.1.1.1


тоесть мы меняем их местами.
если мы в этом пакете заменим src_ip на некий другой
ип например

  src_ip=2.2.2.2   dst_ip=1.1.1.1


то этот пакет он до удаленного ядра то долетит! 
но в сокет приложени которое нам прислало иходный 
пакет никогда не поадает! потмоу что в сокет попадают
пакеты ответные только такие чтобы у них были те
же самые ип адреса что в нем запмсаны были для 
исходящего пакета толко поменяны местами!


справищвается ну хорошо а в чем проблема?
а прикол вот в чем!!! - нужно вернуться к вопросу
как ядро выбирает SRC_IP и ethN(имя сетевой карты
в которую пихать пакет)

так вот прикол в том что если ядру нужно послать 
в сеть пакет который был инициирован для оптравки
процессом нашего компа (исходящий пакет исодящего от нас соедиенения ) то ядро определяет src_ip и ethN 
для пакета одним спообом а если исходящий пакет
является ответным на входящий который приелетел 
от внешнего приложения то ядро использует СОВЕРШЕННО
ДРУГОЙ АЛГОРИТМ! 


положим для начала что мы инциируем конект с процесса
на нашем компе. и шлем первый исходящий пакет в сеть.
наш процесс пишет в сокет 

  dst_ip=1.1.1.1

и сует в сокет текст "123" (payload) далее процесс
гооврит 

  conect()
  sendto()\write()


так вот ядру надо послеть в сеть пейлоад. для 
того нужно составит в частности ip пакет. 
у ядра есть dst_ip но нужно откудато взять src_ip
что делает ядро. оно берет dst_ip и прогоняет 
его по таблице маршрутизации и ищет правило.
пусть у нас пока для постоты праивло будет 
простецкое вот такое

1.1.1.0/24 dev br1 scope link src 1.1.1.10


тоесть ядро берет dst_ip=1.1.1.1 применяет  к нему маску из этого правила 255.255.255.0 получает 1.1.1.0
и сравгивает с тем что стоит в правиле. получает
совпдаение. значит правило найдено. далее ядро 
берет это правило и из него узнает какой src_ip
ему нужно взять для будущего пакета а миенно
src_ip=1.1.1.10 оба! а еще ядро теперь знает в 
какую сет карту совать пакет это br1 
итак мы получили

  src_ip=1.1.1.10  dest_ip=1.1.1.1 

и сунуть пакет нужно в br1
отлично!

так действует ядро если ему нужно составит пакет
и послать его наружу(исходящий пакет) при условии что 
конект инциировал процес нашего компа. а теперь 
смотриим что будет дальше. 
дальше нам в ответ прилетит ответный пакет 
от удаленного приложения с параметрами 

  dst_ip=1.1.1.10  src_ip=1.1.1.1 

тоест он обязан был их нементь а тлоько поменять
местами. ядро берет это пакет и сует его в сокет.
наше приожение получает эту инфо  и оабрабывает
ее. отличано. мы послали пакет наружу  и получили 
ответ. все классно. 
теперь  наш процесс хочет теперь послать следущий
пакет наружу туда же. (!!) тут важно заметить 
что ядро наше когда первый пакет исходящий посылало
то оно записал в свойство сокета src_ip=1.1.1.10
которое оно вычислило на освное таблицы маршрути
зации поэтому когда наше приложение сунет очердной
пейлоад в сокет
  
   write()


то по идее ядру больше ненужно лезть в таблицу маршру
тизации для вычисления какой src_ip нужно брать 
для пакета! (этонадо проверить ) но ядро как я понимаю
(надо тоже проверить) все равно полезет опять в 
таблицу марршурутизации для того чтобы на всякий
случай уточнит  в какую карту плюнуть этот пакет!
поэтому по идее это значит что если мы изменим 
маршрут то это должно повиять только на карту из 
которой пакет будет выпущен но уже не повлияет на 
src_ip этого пакета ! (это надо все проверить)


в случае когда конект инциируется другим компом
и мы получаем первый пакет и нам надо отправитт
первый ответный пакет ВСЕ ЕЩЕ ВЕСЕЛЕЕ!
вот мы получили пакет

  dst_ip=1.1.1.10  src_ip=1.1.1.1 

ядро склонирвало сокет нашего процесса. и в него
записало эти парамтеры. процесс на той стороне
строго ожидает что овтетный пакет будет иметь 
только параметры

  src_ip=1.1.1.10  dst_ip=1.1.1.1 

и ниакие другие! ПОЭТОМУ! наше ядро когда будет
лазить по таблице маршрутиацзии то оно НЕ БУДЕТ
ИЗ НЕЕ БРАТЬ SRC_IP КОТОРЫЙ ТАМ ЗАПИСАН!  а возьмем
из нее только имя сетевой картчоки через которую 
высрать пакет!
тоесть если у нас на компе правило 

1.1.1.0/24 dev br1 scope link src 1.1.1.29

то ядро проигнорирует src 1.1.1.29 
оно только возьмет из этого правила br1 !
ЭТО ПРОСТО ОХРЕНЕЕТЬ!


вот доказтелсьтво про то когда конект инциируется
снаружи и влетает пакет а нам надо послать в ответ.
и еше в таблице маршуртиацзии не содержит в себе
src_ip это еще усложняет схему

вот у нас есть правило

172.16.10.0/24 dev enp0s3 scope link 

вот у нас есть карта 

2: enp0s3:
    inet 172.16.10.14/24 scope link noprefixroute enp0s3
    inet 172.16.70.14/24 scope global enp0s3


в этот комп влетает пакет
172.16.70.14 < 172.16.10.15 

ядро на нашем компе создает сокет  с 

LOCAL_IP=172.16.70.14  REMOTE_IP=172.16.10.15

когда наша прога в ответ чтото хчео послать удаленн
ому процессу и делает

   write(...)

то ядро формирует ip пакет четко  с 

src_ip=172.16.70.14  dest_IP=172.16.10.15

тоест ядро не смотрит в тмаблицу маршуртиацзии 
какой src_ip нужно пакету выдать! ядро смотрит
в табице мращруатиацзиии только через каукую карту
высрать пакет.  а если бы ядро брало бы срц_ип
на освное таблицы маршутиазции то было бы вот как
так как 
172.16.10.0/24 dev enp0s3 scope link 

и
2: enp0s3:
    inet 172.16.10.14/24 scope link noprefixroute enp0s3
    inet 172.16.70.14/24 scope global enp0s3

то src_ip был бы 172.16.10.14 тоесть пакет был бы


src_ip=172.16.10.14  dest_IP=172.16.10.15

сравнваем с тем какой реально будет отослан

src_ip=172.16.70.14  dest_IP=172.16.10.15

как видим это своршенно другой пакет!

Я ЭТО К ТОМУ ЧТО - ДАЛЕКО НЕ ВСЕ ПАРАМЕТРЫ ИЗ 
ПРАВИЛА ТАБЛИЦЫ МАРШРУТИЗАЦИИ ИСПОЛЬЗУЮТСЯ ПРИ 
ФОРМИРОВАНИИ ПАКЕТА. !!! ОХРНЕНЕТЬ!


Далее. 
что я обнаружил.
1) если удалиьт все роуты с хоста это ему не
мешает получать пакеты из вне.
потому что маршруты влияют на то как ядру остылать
исходящие пакеты но не на то чтобы ядро могло 
получать пакеты. прикольно

2)
вот мы сделали тцп конект. значит у нас есть 
сокет где жестко прописан
  src_ip   dest_ip
так вот для исходящих пакетов для каждого пакета ядро
каждый раз проверяет таблицу маршрутиацзии(ппц)
и если находит более крутой маршрут то ядро исходящий
пакет выплеывает из этой ДРУГОЙ сет карты! ОДНАКО -
при этом ядро игнориует параметр src у маршрута
или scope у марщрута, другими словами ядро не пере
определяет параметр src_ip у исходящего пакета,
ядро из марршрута только берет имя сет карты в котрую
совать пакет. в частности это значит что из сет карты
которая имеет какие то ип адреса выпелывается пакет
внутри которого src_ip такой которого нет на карте
из которой он вылетает. но это неглавное. главное это
то что если src_ip уже задан известен из свойств
сокета то ядро этот параметр не меняет у вылетающго
пакета на основе правила маршрутиацзии. ядро из 
правила маршрутизации берет толко имя сет карты!
еще важно то что если у нас есть поток пакетов 
то для исходящий пакетов таблица маршрутиацзии 
проверется для каждого пакета снова, а не так что
она проверилась для первого исходящего потока а 
потом запоминиалсь, такого нет. кажый раз проверяется
снова. это приводит к тому что если появлеся новый
маршрут для этого dst_ip то ядро выплюнет исходящий
пакет через новую карту. также  в частносити это 
означает что входяий пакет может влететь чрез 
одну карту а ответный пакет может вылететь через 
ДРУУГУЮ КАРТУ!



