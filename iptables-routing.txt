важный момент который  я открыл.



как у нас процесс работает с сетью.
процесс создает сокет. далее процесс пишет в сокет
данные. имеется ввиду пейлоад текст например 
какойто. а ядро берет этот текс из сокета  и начинает
заворачивать его в  tcp+ip+ethernet фрейм и совать
в сеть. рассмотрим случай когда инциатором конкта
яялется наш процесс.

помимое пейлоад наш процесс еще должен сунуть в сокет
такую инфо как dest_ip.  но ядру чтобы изготвоить 
сетевые пакеты нужно еще узнать\определить src_ip
и имя сетевой карты через которую этот пакет нужно
выплюнуть. итак еще раз наш прцесс сует в сокет
такой параметр как dest_ip а  само ядро самостоятеьно
опредяет такие парамтеры как src_ip и имя сетевой 
карты. 

далее процесс начинает совать в сокет просто байты
с данными которые к сети неимеют никаго отношения
и делает это процесс через write() либо sendto()

   write(fd,"мама мыла раму")
   sendto(fd,"ехал грека через реку")


здесь важно понять то что после того как прцосс 
сунул в сокет dest_ip то он больше никакие сетевые
параметры в сокет не сует. процесс просто начинает
совать в сокет тлько пейлоад и больше ничего.
за вест сетевой процсс начианет ответчать только ядро.

оно берет из сокета кусок полезных данных "мама мыла раму", далее ядро сует эти данные в tcp пакет.
этот пакет оно сует в ip пакет в которое ядро
запмывает 

  src_ip , dest_ip

где dest_ip это инфо котороые ядру собщил процесс.
а src_ip это инфо которое ядро само определило (как? щас расскажу)  , далее ядро сует этот пакет в эзернет
фрейм параметры которго ядро тоже само определило (как оно это сделао нам щам неважно)  далее ядро прогоняеь
этот пакет через правила иптейблс в течение которых
у пакета могут поменяться параметры 

  src_ip , dest_ip

дада ! они могут там при прохоеде через иптейбс
поменяться! и также может поменяться сет карта в 
которую пакет будет засунут.  также пакет просто 
может быть дропнут внутри ипейтейблс. ив итоге
если пакет дожил до конца всей обработки через 
ипблейс то у него будут какието 

  src_ip1 , dest_ip1

и какое то имя сетевой карты в которую ядро решило
сунуть это пакет. и наконец ядро сует этот пакет
в сетевую карту!

о том как ядро выбирает началный src_ip и как оно 
выбирает ночальную сетевую карту в которую хочет
сунуть пакет мы ниже поговорим. а щас я хочу
акцентирвать внимание на другом важном. на том что 
ядро ожидает что в обратку удаленная система  пришлет
нам пакет ровно стаиким же  src_ip1 , dest_ip1
только поменянными местами. если у нас  наш изна
чальнй пакет претерпел изменения из 

	src_ip=IP1, dest_ip=IP2

в 

   src_ip1=IP3 , dest_ip1=IP4

знчит в талице иатпблс установлен NAT  и при получении
"обратного" пакета тоесть  такого что 


  src_ip2=IP4,  dest_ip2=IP3

тоесть пакет который вылетел из компа 

   src_ip1=IP3 , dest_ip1=IP4

и пакет который мы получии в ответ 

  src_ip2=IP4,  dest_ip2=IP3

они отличаются тем что у них в точности поменяны
IP адреса то этот NAT он автоматом проведет "обрат
ную " замену и наш пакет первратиться в 

  dst_ip2=IP2,  src_ip2=IP1

и этот орабный пакет будет оиличаться от оригинальног
пакета вылезшего из сокет процесса

	src_ip=IP1, dest_ip=IP2

будет отличаться тем что у него просто будут поменяны
местами ип адреса. ТАК ВОТ! только в этом случае
ядро засунет такой пакет в сокет нашего процесса!


зачем я это распиывал? а за тем что ! если у нас 
есть сокет который принадджеит процессу. то этот 
сокет имеет вписанную в него пару LOCAL_IP DEST_IP
так вот. если мы из этого сокета высрали наружу
исходящий пакет с параметрами 

   LOCAL_IP DEST_IP

и если к нам в ответ прилетел некий пакет то ядро
этот влетевщий пакет засунет в этот же сокет в том
и только том случае если влетевший пакет имеет
точно такой же вид 

   LOCAL_IP DEST_IP

есдт влетевщий пакет имеет вид нетакой то он никогда
в наш процесс непопадет! это означает ! что если 
у нас в комп велетел каойто входяий пакет с 
параметрами 

  IP1  IP2 

то мы в ответ обязаны в нем нихуя не менять эти
парамтеры! мы тлоько можемм их поменять местами.
а если мы изменим эти параметры то наш "ответный"
пакет нихуя не будет получен тем кто его отправил!
тоесть на примрере.

положим нам в комп прилетел пакет

  dest_ip=192.168.10.1  src_ip=1.1.1.1

так вот мы неимеем права в нем менять эти ип адреса.
мы тлько можем их поменять местами

  src_ip=192.168.10.1  dest_ip=1.1.1.1

в нашем отвеном пакете. 
а если мы в этом пакете заменим src_ip ан какойто 
другой то этот пакет наш оветный никогда не будет
доставлен в сокет того удаленого прилоежния которое
нам этт пакет прислало!  ВОТ ЧТО ВАЖНОГО Я ХОТЕЛ 
ДОНЕСТИ!

как это выгядит на уровне сокетов для случая когда
мы принмиае внешние конекты. у нас есть слушаюий
сокет. который опредееляет dest_IP или по другому
гвоорят LOCAL_IP . если в ядрл влетает некий новый
пакет с 
  
 dest_IP=LOCAL_IP и какимто SRC_IP=IP1

то ядро клониурет наш слушающий сокет (при условии
что мы в процессе запустили accept(fd) )
и в этот новый сокет ядро запишет 

 LOCAL_IP  REMOTE_IP=IP1

и теперь у нас паарметр входящего и исходяшего
пакета для этго сокета жестко задан. наше ядро
будет слать в сеть пакет 

 src_IP=LOCAL_IP  drst_ip=REMOTE_IP=IP1

и в ответку будет ждать пакеты вида

 dst_IP=LOCAL_IP  src_ip=REMOTE_IP=IP1


таким мкром эта хрень жестко задана. ее меять
нельзя
тоесть еще раз на прмиере.
если на наш комп приелет входяий пакет вида


  dst_ip=192.168.10.1   src_ip=1.1.1.1

то мы обязаны на нено оветить только пакетом 
вида 

  src_ip=192.168.10.1   dst_ip=1.1.1.1


тоесть мы меняем их местами.
если мы в этом пакете заменим src_ip на некий другой
ип например

  src_ip=2.2.2.2   dst_ip=1.1.1.1


то этот пакет он до удаленного ядра то долетит! 
но в сокет приложени которое нам прислало иходный 
пакет никогда не поадает! потмоу что в сокет попадают
пакеты ответные только такие чтобы у них были те
же самые ип адреса что в нем запмсаны были для 
исходящего пакета толко поменяны местами!


справищвается ну хорошо а в чем проблема?
а прикол вот в чем!!! - нужно вернуться к вопросу
как ядро выбирает SRC_IP и ethN(имя сетевой карты
в которую пихать пакет)

так вот прикол в том что если ядру нужно послать 
в сеть пакет который был инициирован для оптравки
процессом нашего компа (исходящий пакет исодящего от нас соедиенения ) то ядро определяет src_ip и ethN 
для пакета одним спообом а если исходящий пакет
является ответным на входящий который приелетел 
от внешнего приложения то ядро использует СОВЕРШЕННО
ДРУГОЙ АЛГОРИТМ! 


положим для начала что мы инциируем конект с процесса
на нашем компе. и шлем первый исходящий пакет в сеть.
наш процесс пишет в сокет 

  dst_ip=1.1.1.1

и сует в сокет текст "123" (payload) далее процесс
гооврит 

  conect()
  sendto()\write()


так вот ядру надо послеть в сеть пейлоад. для 
того нужно составит в частности ip пакет. 
у ядра есть dst_ip но нужно откудато взять src_ip
что делает ядро. оно берет dst_ip и прогоняет 
его по таблице маршрутизации и ищет правило.
пусть у нас пока для постоты праивло будет 
простецкое вот такое

1.1.1.0/24 dev br1 scope link src 1.1.1.10


тоесть ядро берет dst_ip=1.1.1.1 применяет  к нему маску из этого правила 255.255.255.0 получает 1.1.1.0
и сравгивает с тем что стоит в правиле. получает
совпдаение. значит правило найдено. далее ядро 
берет это правило и из него узнает какой src_ip
ему нужно взять для будущего пакета а миенно
src_ip=1.1.1.10 оба! а еще ядро теперь знает в 
какую сет карту совать пакет это br1 
итак мы получили

  src_ip=1.1.1.10  dest_ip=1.1.1.1 

и сунуть пакет нужно в br1
отлично!

так действует ядро если ему нужно составит пакет
и послать его наружу(исходящий пакет) при условии что 
конект инциировал процес нашего компа. а теперь 
смотриим что будет дальше. 
дальше нам в ответ прилетит ответный пакет 
от удаленного приложения с параметрами 

  dst_ip=1.1.1.10  src_ip=1.1.1.1 

тоест он обязан был их нементь а тлоько поменять
местами. ядро берет это пакет и сует его в сокет.
наше приожение получает эту инфо  и оабрабывает
ее. отличано. мы послали пакет наружу  и получили 
ответ. все классно. 
теперь  наш процесс хочет теперь послать следущий
пакет наружу туда же. (!!) тут важно заметить 
что ядро наше когда первый пакет исходящий посылало
то оно записал в свойство сокета src_ip=1.1.1.10
которое оно вычислило на освное таблицы маршрути
зации поэтому когда наше приложение сунет очердной
пейлоад в сокет
  
   write()


то по идее ядру больше ненужно лезть в таблицу маршру
тизации для вычисления какой src_ip нужно брать 
для пакета! (этонадо проверить ) но ядро как я понимаю
(надо тоже проверить) все равно полезет опять в 
таблицу марршурутизации для того чтобы на всякий
случай уточнит  в какую карту плюнуть этот пакет!
поэтому по идее это значит что если мы изменим 
маршрут то это должно повиять только на карту из 
которой пакет будет выпущен но уже не повлияет на 
src_ip этого пакета ! (это надо все проверить)


в случае когда конект инциируется другим компом
и мы получаем первый пакет и нам надо отправитт
первый ответный пакет ВСЕ ЕЩЕ ВЕСЕЛЕЕ!
вот мы получили пакет

  dst_ip=1.1.1.10  src_ip=1.1.1.1 

ядро склонирвало сокет нашего процесса. и в него
записало эти парамтеры. процесс на той стороне
строго ожидает что овтетный пакет будет иметь 
только параметры

  src_ip=1.1.1.10  dst_ip=1.1.1.1 

и ниакие другие! ПОЭТОМУ! наше ядро когда будет
лазить по таблице маршрутиацзии то оно НЕ БУДЕТ
ИЗ НЕЕ БРАТЬ SRC_IP КОТОРЫЙ ТАМ ЗАПИСАН!  а возьмем
из нее только имя сетевой картчоки через которую 
высрать пакет!
тоесть если у нас на компе правило 

1.1.1.0/24 dev br1 scope link src 1.1.1.29

то ядро проигнорирует src 1.1.1.29 
оно только возьмет из этого правила br1 !
ЭТО ПРОСТО ОХРЕНЕЕТЬ!


вот доказтелсьтво про то когда конект инциируется
снаружи и влетает пакет а нам надо послать в ответ.
и еше в таблице маршуртиацзии не содержит в себе
src_ip это еще усложняет схему

вот у нас есть правило

172.16.10.0/24 dev enp0s3 scope link 

вот у нас есть карта 

2: enp0s3:
    inet 172.16.10.14/24 scope link noprefixroute enp0s3
    inet 172.16.70.14/24 scope global enp0s3


в этот комп влетает пакет
172.16.70.14 < 172.16.10.15 

ядро на нашем компе создает сокет  с 

LOCAL_IP=172.16.70.14  REMOTE_IP=172.16.10.15

когда наша прога в ответ чтото хчео послать удаленн
ому процессу и делает

   write(...)

то ядро формирует ip пакет четко  с 

src_ip=172.16.70.14  dest_IP=172.16.10.15

тоест ядро не смотрит в тмаблицу маршуртиацзии 
какой src_ip нужно пакету выдать! ядро смотрит
в табице мращруатиацзиии только через каукую карту
высрать пакет.  а если бы ядро брало бы срц_ип
на освное таблицы маршутиазции то было бы вот как
так как 
172.16.10.0/24 dev enp0s3 scope link 

и
2: enp0s3:
    inet 172.16.10.14/24 scope link noprefixroute enp0s3
    inet 172.16.70.14/24 scope global enp0s3

то src_ip был бы 172.16.10.14 тоесть пакет был бы


src_ip=172.16.10.14  dest_IP=172.16.10.15

сравнваем с тем какой реально будет отослан

src_ip=172.16.70.14  dest_IP=172.16.10.15

как видим это своршенно другой пакет!

Я ЭТО К ТОМУ ЧТО - ДАЛЕКО НЕ ВСЕ ПАРАМЕТРЫ ИЗ 
ПРАВИЛА ТАБЛИЦЫ МАРШРУТИЗАЦИИ ИСПОЛЬЗУЮТСЯ ПРИ 
ФОРМИРОВАНИИ ПАКЕТА. !!! ОХРНЕНЕТЬ!


Далее. 
что я обнаружил.
1) если удалиьт все роуты с хоста это ему не
мешает получать пакеты из вне.
потому что маршруты влияют на то как ядру остылать
исходящие пакеты но не на то чтобы ядро могло 
получать пакеты. прикольно

2)
вот мы сделали тцп конект. значит у нас есть 
сокет где жестко прописан
  src_ip   dest_ip
так вот для исходящих пакетов для каждого пакета ядро
каждый раз проверяет таблицу маршрутиацзии(ппц)
и если находит более крутой маршрут то ядро исходящий
пакет выплеывает из этой ДРУГОЙ сет карты! ОДНАКО -
при этом ядро игнориует параметр src у маршрута
или scope у марщрута, другими словами ядро не пере
определяет параметр src_ip у исходящего пакета,
ядро из марршрута только берет имя сет карты в котрую
совать пакет. в частности это значит что из сет карты
которая имеет какие то ип адреса выпелывается пакет
внутри которого src_ip такой которого нет на карте
из которой он вылетает. но это неглавное. главное это
то что если src_ip уже задан известен из свойств
сокета то ядро этот параметр не меняет у вылетающго
пакета на основе правила маршрутиацзии. ядро из 
правила маршрутизации берет толко имя сет карты!
еще важно то что если у нас есть поток пакетов 
то для исходящий пакетов таблица маршрутиацзии 
проверется для каждого пакета снова, а не так что
она проверилась для первого исходящего потока а 
потом запоминиалсь, такого нет. кажый раз проверяется
снова. это приводит к тому что если появлеся новый
маршрут для этого dst_ip то ядро выплюнет исходящий
пакет через новую карту. также  в частносити это 
означает что входяий пакет может влететь чрез 
одну карту а ответный пакет может вылететь через 
ДРУУГУЮ КАРТУ!
итак еще раз что я выяснил.
есть две карты

2: enp0s3:
    inet 172.16.70.14/24 brd 172.16.70.255 scope global enp0s3
3: enp0s4:
    inet 172.16.70.16/24 brd 172.16.70.255 scope link noprefixroute enp0s4

есть маршрут в котором кстати в явном виде 
указан src адрес
	172.16.70.0/24 dev enp0s4 scope link src 172.16.70.16 metric 100

я инициирую ip[tcp] конект до 172.16.70.15 ,
срабатывает роут и у меня создается сокет с прописан
ными внутри него параметрами src_ip dest_ip

socket:
  LOCAL_ADDRESS=172.16.70.16  REMOTE_ADDRESS=172.16.70.15

параетры в этом сокете не меняются ни при каких
условиях. межуду хостами начинают ходить пакеты

 172.16.70.16 > 172.16.70.15
 172.16.70.16 < 172.16.70.15
 

также важно то что они ходят на моем компе через
карточку enp0s4

[FILTER-OUTPUT tcp] IN= OUT=enp0s4 SRC=172.16.70.16 DST=172.16.70.15 

[FILTER-INPUT tcp] IN=enp0s4 OUT=  SRC=172.16.70.15 DST=172.16.70.16


теперь я добавляю новый маршрут. возникает вопрос
через какую карту начнут ходит пакеты и изменится
ли src_ip у моих пакетов ведь в новом маршруте 
указан другой src_ip

172.16.70.0/24 dev enp0s3 scope link src 172.16.70.14 metric 10    *** новый маршрут
172.16.70.0/24 dev enp0s4 scope link src 172.16.70.16 metric 100 


и вот что мы видим

[FILTER-OUTPUT tcp] IN= OUT=enp0s3 SRC=172.16.70.16 DST=172.16.70.15 

[FILTER-INPUT tcp] IN=enp0s4 OUT=  SRC=172.16.70.15 DST=172.16.70.16


мы видим что теперь исходящий пакет у нас суется
в сеть через НОВУЮ сет карту enp0s3
при этом src_ip не меняется не смотрят на то что
в новом маршруте указан новый src_ip
это самое главное что я хоотел узнать.


да я знаю что каждый пакет прогоняется через иптейблс
и там указан шаг ROUTING DECISION. но было непонятно
как он работает для пакетов которые входят в состав
конекта. ведь возможен такой вариант что ядро 
для первого пакета из конекта делает честный поиск
по табоие маршутизации запоминает его  и когда 
иптбейлс в следущий раз для второго пакета из потока
и других пакетов делает прогон по ипттейбс и доходит
до шага ROUTING DECISION то другая часть ядра просто
возращала бы некое запоненное значение. НО оказыается
это нетак. получаетя что ядро ТУПО для каждого пакета
конекта при прогоне его через таблицы иптейблс и 
доходит до шага ROUTING DECISION то каждый раз ядро
делает полный поиск по таблице маршутизации и если
находит новый более выгоный маршрут то для этого
пакета применяется этот новый маршрут! это первый
важный момент. хочу напомнить что для правил из 
таблицы NAT ядро делает по другому. оно прогоняет
первый пакет из потока через его таблицы. даллее ЗАПОМИНАЕТ применные правила и для других пакетов
потока ядро уже непрогоняет через таблицы NAT а просто
применяет эти правила поэтому замена правила в NAT 
таблице на этот поток уже не повиляет! Но это я отошел
в сторону. итак что касается проавил роутнинга ядро
для каждого пакета из потока прогоняя его через
иптбейлс правила и доходдя до шага ROUTING DECISION
делает четный поиск по талцице маршрутиацзиии и если
находит новы более выгодный маршрут пускает пакет
по этому новому марштуту говоря по руски высирает
пакет в сеть через НОВУЮ ДРУГУЮ карту. так вот 
есть еще один важный момент - применяя новое правило маршрутизации ядро НЕ примняет при этом новый SRC_IP
который находится в этом правиле!
тоесть когда мы создалавали первый исходящий 
пакет и ядро применяло к нему правило маршрутизации

172.16.70.0/24 dev enp0s4 scope link src 172.16.70.16 metric 100 

то ядро подсиавило в первый исходящий пакет 
SRC_IP из этого правла 172.16.70.16

но далее. когда появился новый болей выгодный
маршрут 

172.16.70.0/24 dev enp0s3 scope link src 172.16.70.14 metric 10 

то ядро применило его к второму исходящему пакету
и стало высирать пакет через карту enp0s3 
но при этом ядро не стало подталять в пакет
новый src 172.16.70.14 нет. и это супер  важно!
тоесть при применнеии правила маршрутизации ядро
далеко не всегда применяет ВСЕ ЕГО части!

ткже понятно что это все будет точно так как в случае
когда маршурут содержит в себе src_ip
так и в случае когда он его в себе не содержит
наприме как в этмо случае

172.16.70.0/24 dev enp0s3 scope link  metric 10 

ИТАК еще раз важный вывод - если у нас есть сетевой
сокет , значит в нем уже прописан некий src_ip
и dest_ip , так вот для кажого исходящего пакета
из этого сокета ядро прогонет пакте по праивлам
итейблс и в том числе прогоянет его через шаг ROUTING DECISION . еще раз ядро для каждого исходяшего 
пакета из этого сокета ищет каждый раз заново 
подходящее правило в таблице маршрутизации. ядро 
каждый раз когда хочет послать исходящий пакет
из сокета спрашивает себя "из какоой сет карты этот 
пакет нужно выкинуть в сеть?" ядро делает поиск
в таблице маршрутизации каждый раз для каждого 
исходящего пакета. ядру плевать что предудыщий
исходящий пакет оно высрало через карту1. ядро 
этот факт не запоминает. ядро каждый раз теряет
память и мучитаельно ищет по таблице маршрутизации
ответ на вопрос из какой карты высрать пакет в сеть.
так вот при этом ядро абсоютно игнорирует какой 
src_ip стоит в правиле маршрутизации! ядро неменяет
src_ip у пакета. ядро оставляет src_ip таким каким
он аписан  в сокете. а там этот параметр неменяется.
таким образом с точки зрения наюлюдения все выглядит
вот как. если у нас есть поток на компе который 
имеет вид

 src_ip=172.16.70.16 <> dst_ip=1.1.1.1  

и высирается в сеть через eth0 
и мы вдруг добаляем на комп новый более дешевый
маршрут то ядро тут же меняет поведение и начинает
высирать пакеты через eth1 карту. НО при этом сам
пакет никак не меняется. у него как был
src_ip=172.16.70.16  так и остается! ну и как 
одно из следвтий визуальных получается что из 
карты у которой один ip высирается пакет у которого
src_ip ему неравен.

покажу на картинке

вот пошел первый пакет

 socket(LOCAL_IP=172.16.70.16 REMOTE_IP=1.1.1.1)
                      
                      \|/

                     ядро
            
                      \|/

            |=======================|
            | eth0 IP=172.16.70.16  |
            =========================

                     \|/

       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              ____________________________
              |пакет|172.16.70.16|1.1.1.1|
              ----------------------------

                   СЕТЬ
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


а вот я доабвлил новый маршрут и пакет пошел чреез
новую карту


 socket(LOCAL_IP=172.16.70.16 REMOTE_IP=1.1.1.1)
                      
                                 \|/

                                 ядро
            
                                  \|/

|=======================| |=======================|
| eth0 IP=172.16.70.16  | | eth1 IP=172.16.70.17  |
=========================  ========================

                                     \|/

       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
              ____________________________
              |пакет|172.16.70.16|1.1.1.1|
              ----------------------------

                   СЕТЬ
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



как видно карта сменилась. у нее другой IP
но это никак не сказалось на src_ip пакета!


пожкатоже самое на другой картинке
было:


____________________________
|пакет|172.16.70.16|1.1.1.1|   >>>>   eth0
----------------------------   

стало

____________________________
|пакет|172.16.70.16|1.1.1.1|   >>>>   eth1
----------------------------   


итак src_ip из маршрута прияеняется к пакету только
для первого исходящего пакета и то в случае 
когда конект инциируется с нашего компа. поому
что если конект инциирова снаружи то наш первый
исходящий пакет уже будет иметь известный src_ip
и в этом случае какой срц_ип указан в маршруте
ядро игнирирует. итак срц_ип в маршруте ядро 
учитвает только и только в одном случае - для первого
исходящего пакета в случае когда конект инцирурется
с нашего компа. для всех других пакетов этого конекта
и для всех других случааев ядро этот параметр в 
маршурте игнирриурет! зато неигнориурется другой
моемент - для каждого исходязего  в рамках этого
конекта пакета ядро заново каждый раз сканирует 
таблице маршрутизации поэтмоу если мы доавляем новое
более выгодное правило или если в таблице исчезает
правило для маршурта вообще то тутже это ощущается
на очерезном новом исходящем пакете в том виде
что меняется карточка через карторую пакет плюуется 
в сеть! либо такаая карточка исчезает вовсе!

исходя из этого ставноися понятно как работает 
следущий случай.


комп1                                  комп2

enp0s3 ip=172.16.70.14        enp0s3 ip=172.16.70.15
enp0s4 ip=172.16.70.16        


на компе1 
у нас таблица
	172.16.70.0/24 dev enp0s4 scope link src 172.16.70.16 metric 100


c комп2 я иницирую ip конект на 172.16.70.14
в итоге в комп1 влетает через enp0s3 пакет вида

	 172.16.70.14 < 172.16.70.15

а вылетает обратно через enp0s4 потому что src_ip 
ядру известен. тут все окей. но для исходщяего
пакета ядру нужно понять через какую карту его
совать в сеть(ядро игнориует через какую карту 
прилетел входяий пакет) и ядро использует правилоа
таблицы маршутизации а там указан enp0s4

получается вот так выглядит входящйи и исходящий
поток на комп1

 комп1

  <--- enp0s3   
       enp034 ---->

теперь я доабавляю новое правило в табл маргшрути
зации которое создает более выгодный маргшрут 
для исходящего потока

172.16.70.0/24 dev enp0s3 scope link src 172.16.70.14 metric 10 
172.16.70.0/24 dev enp0s4 scope link src 172.16.70.16 metric 100 


тепрь для исходящего потока более выгодный маршрут
чрез enp0s3

и пэтому теперь поток выгляди вот так


 комп1

  <--- enp0s3 ---->  
       enp034 



входящий поток не поменял карточку чреез которую 
он входит. поменял карточку выходящий поток.
таблица маршрутизации влияет на карту через которую 
полетит исходящий поток из компа.
меняя маршруты мы можем налету переключать ту
карту чрез которую вылетает исходящая часть потока
у конекта. причем налету. мы можем переключаьт с
одной карты на другую.

чтобы еще и переключить на какую карту прилетает
входящий поток то нужно менять не таблицу маршру
тизации а на какой карте сидит IP адрес который 
указан в dest_ip у входящего пакета


ЕЩЕ раз на что влияет таблица машртизации - на 
карточку для исходящего пакета. на src_ip у исход
ящего пакета в ряде случаев(тоесть не всегда).
тоесть она влияет на то через какую карту выйдет
из компа исходящий поток. на то на какую карту
падает  входящий поток таблица не влияет.
то какое правило в табилце машрутизации выберет
ядро зависит от dest_ip исходящего потока.




