| semaphores


в линуксе семафоры сделано на основе System V IPC facility.
что это по факту хрен знает. 
но  в эту группу входят семфоры, message queue, shared memory.
как  я понимаю когда мы говорим про IPC неймспейс то вот как раз 
это означает что отделяются семафоры, шаред мемори и мессадж кью 
в рамках ipc неймспейса.


значит вот программа
$ cat 184.c
/*

the program tests how a semaphore works

*/


#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

#define SEM_KEY 0x1234
#define num_proc 6



char const f_path[] = "/tmp/5.txt";



int consume(int semid)
{


    struct sembuf sem_op;
    sem_op.sem_num = 0;
    sem_op.sem_op = -1;
    sem_op.sem_flg = 0;
    semop(semid, &sem_op, 1);


    int fd = open(f_path, O_RDWR);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }

    char prev[10]="000000000";
    int ret = read(fd, prev, sizeof(prev));
    off_t ret2 = lseek(fd, 0, SEEK_SET);
    char cur[10]="000000000";
    int pid = getpid();
    sprintf(cur,"%d", pid);
    ret = write(fd, cur, sizeof(cur));
    ret = read(fd, cur, sizeof(cur));
    close(fd);

    sem_op.sem_num = 0;
    sem_op.sem_op = 1;
    semop(semid, &sem_op, 1);

    printf("pid = %i, prev  =  %s, cur  %s \n", pid, prev, cur);
}

int main()
{

    int fd = open(f_path, O_RDWR|O_CREAT|O_TRUNC, 0666);
    char const ini[]="000000000";
    int ret = write(fd, ini,sizeof(ini));
    close(fd);


    int semid = semget(SEM_KEY, 1, IPC_CREAT | 0666);
    if (semid < 0)
    {
        perror("semget");
        return 1;
    }

    if (semctl(semid, 0, SETVAL, 1) < 0)
    {
        perror("semctl");
        return 1;
    }

    for (int j = 1; j<num_proc; j++){
        ret = fork();
        if (ret == -1)
        {
           perror("fork");
           return 1;
        }
        else if (ret == 0)
             break;
        }

    //srand(getpid());
    //int rnd_n = ( rand() % 3 ) + 1;
    //printf ("pid = %i, sleep interval = %i \n", getpid(), rnd_n);
    for (int i = 0; i < 3; i++)
    {
        consume(semid);
        //sleep(rnd_n);
    }



    if (ret !=0)
    {
        printf ("pid = %i. Main process has finished the work. Waiting for children to finish the work \n", getpid());
        while (errno != ECHILD)
        {
            wait(NULL);
        }
        printf ("pid = %i. All children has finished the work. Main process is exiting. \n", getpid());


    }

    return 0;
}




вывод на экран
$ ./184.exe 
pid = 27917, prev  =  000000000, cur  27917 
pid = 27918, prev  =  27917, cur  27918 
pid = 27919, prev  =  27918, cur  27919 
pid = 27916, prev  =  27919, cur  27916 
pid = 27920, prev  =  27916, cur  27920 
pid = 27917, prev  =  27921, cur  27917 
pid = 27918, prev  =  27917, cur  27918 
pid = 27921, prev  =  27920, cur  27921 
pid = 27919, prev  =  27918, cur  27919 
pid = 27916, prev  =  27919, cur  27916 
pid = 27920, prev  =  27916, cur  27920 
pid = 27917, prev  =  27920, cur  27917 
pid = 27918, prev  =  27917, cur  27918 
pid = 27921, prev  =  27918, cur  27921 
pid = 27919, prev  =  27921, cur  27919 
pid = 27916, prev  =  27919, cur  27916 
pid = 27916. Main process has finished the work. Waiting for children to finish the work 
pid = 27920, prev  =  27916, cur  27920 
pid = 27921, prev  =  27920, cur  27921 
pid = 27916. All children has finished the work. Main process is exiting. 




значит что она делает.
она создает файл 5.txt и создает семафор. 
далее я через fork() создаю несколько процессов (число задается вот 
здесь #define num_proc 6)
далее все эти процессы начинают заходить на семафор и
через sempop()
далее фишка в том что если семафор щас "занят" то ядро процесс который
вызывал sempop() засунет в "S" состояние. тоесть как говорят в интернете
процесс будет заблокирован (запломбирован) и дальнейшее исполнение его
кода будет заморожено.
тоесть один из процессов обращается к семафору. "захыватывает" его.
и тогда он открывает файл 5.txt читает что там написано. запоминает.
потом стирает содержимое файла и пишет туда свой pid.(точнее он не стирает 
содержимое файла. он переходит в начало файла и начинает писать фактически
перетирая старый байт новым. поэтому все что было в файле после того как
процесс записал туда свой pid оно тоже остается  в файле. к примеру
если в файле было написано 0000000  а пид=2345 то в файле 
будет 2345000000 тоесть хвост еще остается. еще конечно после 2345 
будет ноль байт 0x00 но речь щас не об этом а о том что содержимое
файле не стирается. а он перетирается с головы. но не доконца. 
)
а в это время все другие процессы котороые "полезли" в семафор через sempop()
их всех ядро заслипило. они все "влипли". потому что семафор пока занят.
и вот этот счастливичик (тот кто первый захватил ссемафор) закончил писать
в файл , закрыает его. и освобождает семафор. делает он это опять же
через semop(). (<==тут вдруг непонятно. а что если левый процесс влезет
и пошлет команду освободиь семафор?) после этого как я понимаю ядро которое
собвстенно и исполняет указание от процесса освободить семафор он тогда
берет список процессов которые спят как я понимаю рандомно  ( а может
по приниципу FIFO) выбирает процесс из списка который спит иждет освобождения
светофора. пробуждает его и уже этот процесс захватил семафор. и уже 
он открывает файл 5.txt делает свои дела. а остальные либо продолжают спать
либо тот кто не спал лезет проверять семафор и "влипает" и тоже засыпает.
так каждый процесс в итоге 3 раза захватит семафор и сделает о себе запись в файл.
на экране процесс который захваитил семафор пишет что он в нем прочитал
от предшественника. потому пишет свой pid. потом его читает и только тогда
выводит обновленное содежимое файла на экран

	pid = 27921, prev  =  27920, cur  27921 

prev это то что было в файле а cur то что стало
000000000 - это начальное значение которое я пишу в файл при его
создании
ну и как результат четко видно что шарманка работает. если процесс А
захватил семафор то его пид-А осатется в файле и потом если процесс Б 
захватил семафор то он находит там пид-А от предшесвтенника
из вывода на экран видно что доступ к файлу процессу имеют в рандомном
порядке. это либо из за того что ядро когда одтает семафор новому процессу
то оно рандомно выбирает номер процесса из списка. либо потому что 
шедулер рандомно пихает процессы на цпу. и они рандомно попадают в список
залипших на семафоре процессов. а ядро отдает семафор по приницпу FIFO (кто
первее на семафор залип тому следущему он и достанеся) не знаю.

что еще интересно. если у нас так полуится что наш первый процесс закончит
работу первым и выйдет (сдохнет) то у нас сразу проснется его парент 
тоесть bash из которого мы прогу запускали. выскочит приглашение командной
строки. а чайлды то продолжат работать. да уних сменится парент им станет 
pid=1 systemd но чайлды все равно ведь продолжат раобтать. из за того что 
парент сдох им плевать. и у нас будет хрень. у нас с одной стороы уже 
будет висеть приглащение баша. а сдругой стороны чайлды еще будут срать
в терминал свои мессаги. поэтому  - я добавил в главный процесс я 
добавил блок

    if (ret !=0)
    {
        printf ("pid = %i. Main process has finished the work. Waiting for children to finish the work \n", getpid());
        while (errno != ECHILD)
        {
            wait(NULL);
        }
        printf ("pid = %i. All children has finished the work. Main process is exiting. \n", getpid());


    }


он приводит к тому что главный исходный процесс он не выходит. 
а он через wait() ждет пока выйдует все его чайлды.
а проверка того что все чайлды сдохди идет через  
	(errno != ECHILD)
потому что как только wait() в errno вернет ECHILD это значит что у нашего
мейн процесса больше не осталось чайлдов! можно наконец выходить!
это очень интересный момент был 


еще вот этот момент интересный вылез
    int ret = read(fd, prev, sizeof(prev));
    off_t ret2 = lseek(fd, 0, SEEK_SET);
    ...
    ret = write(fd, cur, sizeof(cur));


я читаю файл. а потом в него пишу. так вот когда я читаю файл
то его "курсор" сдвигается ровно туда где я закончил читать. поэтому 
если сразу начать писать то запись будет идти не сначала файла
а начиная с того места где я закончил читать!
поэтому  я вставил lseek для того чтобы после чтения передвинуть "курсор"
обратно на начало файла!


еще интересный момент это вот это
мне надо пид процесса записать в файл естесвтенно в виде ASCII байтов,
так как pid это  int число записать тоего надо както 
преобразовать в ASCII CHAR массив перед тем как пихать байты в файл
для этого юзаю sprintf
    int pid = getpid();
    sprintf(cur,"%d", pid);


причем sprintf он непросто превращает int pid в массив char байтов
он его превращает в стринг! тоеть он еще на конце добавляет 0x00 байт!
поэтому в файл будет писатьс не просто ASCII(pid) а ASCII(pid)  + 0x00 !
о том как работает sprintf() и как он отличается от print() 
ищи через "| sprintf"



еще интересный момент. правда я его в итоге проге неиспользовал
это как получить рандомное число в си
    //srand(getpid());
    //int rnd_n = ( rand() % 3 ) + 1;
    //printf ("pid = %i, sleep interval = %i \n", getpid(), rnd_n);

rand() позволяет получать рандомные числа.
а srand() он позволяет изменить первое рандомно число в последоваотельности
иначе если это не сделать и пограму вызывать несколко раз наше рандомное
число все время будет одно и тоже. поэтому я в srand() подставлял getpid() 
чтобы наше рандомное число отсчитывалось от номера процесса.


еще момент, когда создаем файл то обязательно нужно указат какие 
файл пермишнс он получит(0666). 
    int fd = open(f_path, O_RDWR|O_CREAT|O_TRUNC, 0666);
если этого не сделать то файл будет создан с пермишнсами плохими
пример


#include <stdio.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>


char const f_path[] = "/tmp/6.txt";



int main()
{

    int fd = open(f_path, O_RDWR|O_CREAT|O_TRUNC);
    close(fd);

    return 0;
}

(как видно я убрал 0666 из open() )
в итоге будет создан файл вот с таими перминшнсами

$ stat /tmp/6.txt
  File: /tmp/6.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15860320    Links: 1
Access: (5230/--wS-wx--T)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)

тоесть
--wS-wx--T

тоесть это SUID бит, sticky бит, запись для овнера. запись для
группы и исполнение для "остальных"

вобщем фиг знает какие пермишнсы. и главное что запись неразрешена 
никому
тоесть сделать open() даже владелец не может!
$ cat 6.txt 
cat: 6.txt: Permission denied

$ strace -e file cat 6.txt 
openat(AT_FDCWD, "6.txt", O_RDONLY)     = -1 EACCES (Permission denied)

пермишн дейнай. пошел нахрен.
только root может сделать файлу open()
охреенть! поэтому при созании файла обязательно нужно в open() 
прописать файл пермишнсы. 

я уже поздабыл все эти стики биты и прочее. у меня есть статья.
из того что я помню и о чем неадавно ввстречал. 
suid бит значит то что обычно когда создается процесс на основе бинарного
файла то процесс запускается под правами кто этот процесс запустил.
а если у файла стоит suid бит то процесс будет запущен не под правами кто
его запустил а того кто является владельецем файла! 
это пользволяет васе запускать программу которая в памяти работает под 
правами рута! этим пользуется команда ping. ей чтобы создать сеевой сокет
наколько я помню нужны права рута. поэтому ping имеет suid бит.
она создает сокет под правами рута. а потом налету уменьшает свои
права обратно до васи.

вот доказательсво того что ping имеет SUID бит
$ stat $(which ping)
  File: /bin/ping
  Size: 64424     	Blocks: 128        IO Block: 4096   regular file
Device: 10302h/66306d	Inode: 25690241    Links: 1
Access: (4755/-rwsr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)

что значит стики бит я уже непомню. недавно читал что раьньше он значил то 
что если программа уже закралысь то текст код файла все равно держался 
в памяти. но щас такая хрен уже нахрен ненужна. но сейчас стики бит 
дает чтот друое что я непомню. 

так вот что еще приметчеьно. наш процесс который создает файл 
когда я забыл указать 0666 файл перишнс
    int fd = open(f_path, O_RDWR|O_CREAT|O_TRUNC);
так вот ядро создась файл и добавит нашему процесу файл дескриптор
на этот файл и наш процесс будет иметь все права на этот файл внезависиомти
от того какие файл пермишнс ядро по дефолту выдало файлу!
но стоит нам только закрыть файл и открыть мы его уже не сможем - сработает
проверка файл прмищнс! это удивительно!


но это все была общая канва и всякая частная хрень.
теперь я возвращаюсь к основному вопросу темы. это о том как 
работать с семафором.

<============ !!!!!

