книги по устройству ядра(которые у меня есть):
-  operating systems three easy pieces
- здесь два курса и несколько книг по устройству ос (https://www.cse.iitb.ac.in/~mythili/)


xv6:
- скачал книжку = /book-rev11.pdf (https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf)
- unix6.pdf = это коментарий к реальному эникс6 на pdp11 который влохновил написание xv6
	(https://cs3210.cc.gatech.edu/r/unix6.pdf) ("A COMMENTARY ON THE SIXTH EDITION 
	UNIX OPERATING SYSTEM" J. Lions.)
- мнжетсво учебного материала про xv6 = https://pdos.csail.mit.edu/6.828/2011/overview.html
---

закрыл часть вкладдок в браузере от 29 мая.

еще более исходный вопрос - это чем деплоймент оличаетя от реплика сет и всего остального

исходный вопрос - кониейнер. pid1 чилдрены. родич умер. чилдрены остались.
чиолдрен умер. прилетел сигнал к pid1 , сигнал по деолфту игнорится. а в pid-1 нет касмного
хендлера. так это все или не так. и как куб в своих подах с этим борется ?

асинхронны сигнал что это ?
в плане сигналов надо разобрать случай когда приелетает от кучи детей сигнал sigchld
и мы их все ловим нетеряем

как работает вызов syscall на уровне цпу и ос

nasm+ld vs gcc  -> syscall 
_start vs _main
signals in linux (прочесь в файле c+assembler)
как это работает что у нас выполняется сисколл тоесть цпу работаетв привлигированном
режиме и его могут прервать через сигнал на выполнение хэндлера сигнала.или как там 
это работает ? как вобе можно прервыать сисиколл. ведь в это время цпу работае в режиме ядра
тоесть там нет никакого прцоесса. если процсс прерыать то его состояние можно срхранить
а как можно созранить состояние выполпние сисколла в режиме ядра? тамже нет процесса никакого !

====
вопросы на которых остановился:
linux:
 page tables. прочитать упрошенный вариант из book-rev11.pdf и unix6.pdf


дописать ответы на вопросы syscall, multitasking.
===
understanding linux kernel
главы: interrupts, scheduling, signals 
===


раздел multitasking
 щас я более подоробно смотрю на два вопроса nested interrupts 
 какой stack испльзуется
 при обработаке интеррапта? 
 tasklet vs hard irq vs softirq? что у них со стеком? 
вопрос нахрена нужен стек push\pop если есть movl ведь в итоге push\pop работает с той же
памятью
про контекст свичинг. есть понятие cpu context switching а есть linux process context switching
 а есть software context switching а есть cpu hardware context swithing.
 что такое intel tss 
 что такое и зачем stack alignment? и связанный  с ним вопрос - а что такое assmbly function? как это с abi связано? закончил на том что научился компилить и дизасмемблтть проги и в gdb смотреть
 и щас хочу понять как там что происходит при командах push\pop с указателем стека итп 

 



раздел syscall
-вызов через int 80 vs через syscall
- далее надо разобратсья так как же через какие регистры происходит адресация в 64 битном режиме
в протектед моде  в режиме ядра
-непонятно что такое process context. какие регистры входят и что еще.(также непонятно
вот мы сисколлом вызывали фнукция в ядре. цпу пеерключился в ринг0 что значит что код ядра
выполняется в контексте юзерского процесса). насколько я понимаю что когда цпу в режиме ядра
то то код ядра работает в виртуальном пространсте памяти как его видит процесс в юзерском режиме
плюс также ядерный код еще видит память которая ядру принадлежит. в общем здесь еще вопрос
в том что очеивдно что в режиме ядра этот код может быть прерван получается как это согласовать 
с шедулером. как это все шедулится? еще вопрос если процесс вызывал сисколл и цпу начал работать в режиме ядра то какой статус у процесса ?


еще вопрос:
посмотреть какие регистры сохраняются и как там с регистрами стека при входе в int80\syscall
что интересного открылось - мы немжем через gdb долезть до кернел функций. как только мы вызываем 
ядерный код через syscall\int80 то туда глубже провалится нельзя. gdb недает. он возврашется 
сразу с резултатом который дает сискол.. то есть gdb может дебагить только в юзер спейсе.



=====> 

вопрос: как работает tickless ядро , как оно без таймер интеррапт раотает ?

====

вопрос:

как работает clone+ execve?
парент через clone создает новый процесс . вопрос как после этого парент может влезть 
в новый процесси и запутитьв нем execve ?

вроде бы ответ вот какой. форк запускаетя в родиче а exec уже чайлде. поскольку чайлд это точная
копия родича значит в коде проги делается if (если я щас в чилдрене ) то взывать exec.
таким образом я бы сказал так это не родич лезет в чайод и выывает exec это сам чайл форкнутый 
сам вс ебе вызывает execve. вот и весь секрет.

===
а как дела если нескоько ядер?  как тогда срабаывает шедулер?
===

ответ на ворос из интернета:
Is the process scheduler "visible" at user space? 
No. Because scheduler is not a process.

Can I see it with ps? 
No because ps shows the list of processes.

Maybe is it one of the kernel threads?
If yes, how is it called?
No.

How can I "see" it?
Usually we have a habit to work with processes in linux as a smallest entity. As scheduler
is not a process you can not "see" it this way.

It doesn’t exist as a separate thread, or module, it’s implemented as a function

Ok, but how and where and in which way is this function run? Is there a way to track it and see it?
It works this way ( very simplified ):
There is a timer inside PC. From time to time it sends a signal (an interrupt) to cpu (via interrupt controller). An interrupt is the electrical signal that goes to cpu via its pin. 
When cpu gets this interrupt it stops what he is doing, saves some registers  and starts to run ISR(Interrupt service routine). An interrupt is the event inside pc that cpu must handle. It means cpu need some piece of code to make it. ISR is the code. Where does it come from? Operating system puts the code beforehand. CPU jumps to ISR ( to be specific "timer interrapt handler") and it invokes scheduler. Scheduler makes "context switch" that is: it evicts some processes from cpu and launches some other, that is it saves all the registers of cpu to memory  (and some other stuff) of one process and loads from memory saved registers state to registers. When it is done scheduler 
exits and the process starts to work for some time until new timer interrupt happens, new scheduler invocation happens.The current process will be evicted and new one will be launched. This is how multitasking works. Timer Interrupt happens 10ms. That is scheduler is invoked every 10ms.


The schema:

Timer Interrupt  --> ISR --> Scheduler  ---> A process switch

Well overall i cant suggest a method to "see " or "touch" scheduler. 

========================
bash
что получается когда мы в баше делаем

$ ./1.exe & 
как это работает на бекенде ?

======
loadaverage?
это среднее число процессов в runqueue(тоесть со статусом R) шедулера 
либо процессов которые имеют статус 'D' за 1\5\15 минут
==========
про runqueue кто определяет чтобы процесс был помеещен в runqueue.
ответ . по дефолту код всегда будет туда помещен. а вот чтобы его оттуда убрали
надо чтобы сисколл который должен вызывать шедулер должен попросить шедулер убрать его из 
runqueue. поэтому когда говорят что процесс runnable возниакает вопрос а как это линукс лпредедляет
что таск = runnable. как он узнает поотребоности процесса. ответ в том что по дефолту процесс
считватется runnable а вот чтобы он таким перестал быть над просить об этом шедулер через сисколл
а то вот пишут "когда процесс готов к исполнеию". а от чего это зависиит как лиунукс это понимает
обьяснения недают.
тоесть по дефолту любой процесс шедулер постоянно размещает в очереди на исполнение.
и только если специально просить шедулер то он будет оттуда задчу убирать. так что с тчоки зрения
динукса и шедулера программа по дефолту всегда готова к исполнению так что эта формулировака
дебилная. она может быть не готова если только обб этом специально просить шедуделер.
в общем форумилрорвака дебильная.
=======
если есть праень и чайлд и мы шлем килл -15 паренту . вопрос будет ли автоматом убит чайлд
или только парент?
частчно ответил на этот вопрос . но до конца нет уверенности. смотри "processes kill parent child"

======
программа

#define _GNU_SOURCE
#include<stdlib.h>
#include<unistd.h>
#include<stdio.h>
#include<sched.h> 


int variable, fd;

int do_something() {
   variable = 42;
    printf("The child: the variable = %d\n", variable);
   _exit(0);
}

int main(int argc, char *argv[]) {
   void **child_stack;
   char tempch;

   variable = 9;
   child_stack = (void **) malloc(16384);
   printf("The parent: the variable = %d\n", variable);

   clone(do_something, child_stack, CLONE_VM|CLONE_FILES, NULL);
   sleep(1);

   printf("The parent: the variable is =  %d\n", variable);
   return 0;
}



вылетает с segmentation fault 
при попытке в треде
printf("The child: the variable = %d\n", variable);
   _exit(0);

почему?
=======
D статус он вызывает  W статус в top/nmon
или что вызвыает W что это как это увидеть в procfs ?
мне непонятна откуда берется характирстика W !
======
неигнорируемый сигнал типа -9 может ли у него быть кастомный обработчик сигнала
или только ядерный дефолтовый хендлер
в man signal нашел что :
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

=====
Z процесс
гда на живой практике с нимис сталкиваются так чтобы они рождались 
из каких то практичекиз случаев а не лабораторных симуляциях ?

====
getconf\sysconf
о чем это ?
=====
C конструкция struct
как с ней раотать.
разобрать на примере nanosleep
=====
pselect6 
часто исполщуется в bash
о чем он?
=======
разбобрать clone()
 у него там всякие опции интересные есть. например чтобы процесс
 имел свой стек. о чем это ?

 =====

restart_syscall
почитать man
====
man intro
man standards
man signal
man syscalls
man wait
=====
ps -A  -f f

разобрать вывод (иерархический вид процессов)
и смысл ключей

замечу что 
ps -f f и ps -ff 
это совсем разный вывод!
===
man exit
прочитать потмоу что там есть инфо про зомби процессы и про то как
работает связь между парент и чайлды
====
signal

одноверменный прилет сигналов одного и тогоже сигнала (принимает ли ? копит ли? прерывает
ли хендлер? )
wait vs waitpid?
waitpid в цикле?

далее прикол втом что если мы заменим строчку 

sleep(30 * kid);

на 

sleep(1);

это будет значит что все чилдрены одновременно (более менее) закончать свою работу.
тогда получится то что (надо обьяснить почему) часть чайлдов окажется необработанной 
сигнал хендлером и они останутся висеть как Z. 
чтобы этого небыло наизменить хэендлер вот с такого

static void reapChild(int sig) {
  waitpid(-1, NULL, 0);
  NumChildrenExit++;
}

на такой (обьяснить почему это даст эффект)

static void reapChild(int sig) {
    while (1) {
       pid_t pid = waitpid(-1, NULL, 0);
       if (pid < 0) break;
       NumChildrenExit++;
    }
}


(обьяснить почему это даст эффект)


причем походу когда вызывается сигнал хендлер то по любому парент процесс блочится?(статус D видимо?) или просто неисполняется типа как goto\jmp? 

что дает waitpid(-1, NULL, 0) vs waitpid(-1, NULL, WNOHANG ) ?

получается что wait от waitpid оличается тем что в waitpid побольше есть опций и все.
если мы в теле программы ставим wait\waitpid то программа дальге недвинется пока неумрет
хотя бы один чайлд wait]waitpid будет стоять и ждать. и только окгда умрет хотя бы один чайлд
тогда будет возврат из этой функции и тело главой программы сможет двигать дальше.

если поместить wait\waitpid в хендлер то возврат в главнуб прграмму произойдет мгновенно
потому что хендлер то вызывается только тогда когда один из чайлдов точно сдох. поэтому когда
мы помщаем wait\waitpid в хендлер а не втело пгрограммы то тогда блокировка (то есть задержка выполнения гавной программы) минимальня по времени. во время задержки как я понимаб (надо провертиь)
 сттатус парент процесса будет R.  

 поэтому если мы арзмеостоли wait\waitpuid  втеле програмы но нехотим ждать пока чайлд  сдохнет
 то мы тогда вот используется для этого флг WNOHANG

 waitpid(-1,null,WNOHANG)

 этот флаг приводит к тому что waitpif неждет когда сдонет чайлд а просто делает проверку есть ли 
 сдохший прям щас. если не то сразу возврвается в тело главной прогарммы.
 вот зачем может понадобтся флаг WNOHANG!!!!

 тогда зачем он нужен в хенделере ( втеле главной програмы понятно) ? и что будет
 если выоплнятемся хендлер а в процесс прилетает такой же сигнал? хендлер прерывается? или что?

 из man signal я вижу что если прилетел сигнал то принятие такого же сигнала блокируется (вопрос что тогда будет с прилетевшим но заблоченным сигналом)  и происходит вход в хендлер.
 по выходе из хендлера сигнал разблокируется.

при запуске прогиаммы вот  стаким сигнал хенддлером:
 signal(SIGCHLD, reapChild);

rt_sigaction(SIGCHLD, {sa_handler=0x55df72c187aa, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7fbf43736040}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0

видно что были установлены флаги:SA_RESTORER|SA_RESTART и SIG_DFL

согласно man 7 signal : if multiple instances of a standard signal are delivered while that signal is currently blocked, then
           only one instance is queued.
тоесть вот мы полувили 1 сигнал. ядро заблокиовалоп поучение нового такогоже.
вошли в хендлер. выполняем . в это время летят таки еже сигналы. и как японял ядро сохранит в 
статусе пендинг в очереди ровно 1 такойж сигнал которй будет доставлен после того как 
ехендлер закончит и выйдет.


libc signal несипольуеся керенл ссиколл signal  а исползует сисколл sigaction

(прочитать статью от доков glibc о сигналах https://www.gnu.org/software/libc/manual/html_node/Handler-Returns.html)
оттуда читаю:
When the handler for a particular signal is invoked, that signal is automatically blocked
until the handler returns. That means that if two signals of the same kind arrive close
together, the second one will be held until the first has been handled. (The handler can
explicitly unblock the signal using sigprocmask, if you want to allow more signals of this
type to arrive; see Section 24.7.3 [Process Signal Mask], page 751.)

However, your handler can still be interrupted by delivery of another kind of signal. To
avoid this, you can use the sa_mask member of the action structure passed to sigaction
to explicitly specify which signals should be blocked while the signal handler runs. 

Portability Note: Always use sigaction to establish a handler for a signal that you
expect to receive asynchronously, if you want your program to work properly on System
V Unix. On this system, the handling of a signal whose handler was established with
signal automatically sets the signal’s action back to SIG_DFL, and the handler must reestablish itself each time it runs. This practice, while inconvenient, does work when signals
cannot arrive in succession. However, if another signal can arrive right away, it may arrive
before the handler can re-establish itself. Then the second signal would receive the default
handling, which could terminate the process = чего ?

насколько я понял читая доки и по signal и по cpu interrupts и в том и в другом случае 
они когда говорят asyncncronous interrupt они имеют ввиду ( хотя это дебильно по мне) то что 
возниконовение события независит от самого кода программы, от команд программы (процесса)
с точки зрения кода програмного кода событие может возникнуть(прилететь) абсолютно непредсказуемо
в с точки зрения очередной команды в коде процесса. когда же они говоря что synchrounus interrupt
то имеютт ввиду что событие абсолютно предсказуемо возникнет ибо оно завиисит от очередной 
команды в коде процесса. ( в документации к процессаорам интел и цпу excepton\interrupt авторы 
называют синхронные события эксшепсенасами а асинхронные интерраптами  так чисто для српавки. итак еще раз с точки зрения создатеей цпу интел  если жопное событие происходит из за очередной команды в
коде то это эксепшн. и он является синхронным тоесть это ознчает что событие произошло из за команды в коде.  если жопное событие произошло не из за команды в коде а по какйото другой причине
то с точки зрения интеловцев это называется интеррапт. и это событие асинхронное то есть оно произошло не иза за команды в коде программы а из за чегото внешнего как например на сетевую карту прилетел пакет. вот что  вих дебаильном понимании смысл слов синхронное асинхронное. этот же дебилный смысл синхронное асинхронное переносится и сохраняется на signal то есть на сигналы. прилетит сигнал или неприлетит зависит не от кода в процессе а от чегото внешнего. значит это асинхронное событие. какой же дебилизм они вложиили в понятия синхронный асинхронный. обычно слово синхронный означает одновременное происходждение события с чемто с чем синхронизируемся с какито 
другим эталонный событием. здесь походу пьесы они когда говорят синхронное то связывают возникноневения события с командой в коде. тоесть если в коде есть команда скажем int n которая вызывает событие прерывания то это синхронное событие. кстати поэтому команды int n вызывает эксепшен а не интеррапт.  получается с точки зрения кода процесса появление эксепшенса полностью предсказуемо. там где есть определенный кусок кода там будет возникаить предсказумое прерывание 
выполнения кода процесса назыаемое эксепшен. а возникновение прерыавания выполненеия кода типа интеррапт совершенно не связано с телом кода с его командами. поэтому это событие interrupt.    ).


вот такая программа:
$ cat 40.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

int main(void)
{
//Register signal handler through the signal() function
signal(SIGINT, SIG_IGN);

while(1)
{
//simulate a delay -- as if the program is doing some other stuff
sleep(10);
}

return 0;
}

что в ней примечательного - во первых надо знать что signal это libc функци обертка  которая 
по факту использует сисколл rt_sigaction ( man rt_sigaction) а не сисколл signal. так вот
второй параметр в libc signal это необязательно ссылка на тело хендлера это может быть сразу 
некое действие. в данном случае  

signal(SIGINT, SIG_IGN);

поговорим о втором параметре в signal(). согласно man 2 signal
второй парметр это : 
   либо SIG_IGN, 
   либо  SIG_DFL, 
   либо the address of a programmer-defined function (a "signal handler").

SIG_IGN = означает действие проигнорировать сигнал тоесть ничего неделать
SIG_DFL = означает что ядро должно сделать дефолтовое действие в ответ на сигнал. а что 
это за дефолтовое дейтвие? это зависит от того какой конкретно сигнал прилетел, в man 7 signal есть таблица дефолтовых действия ядра для каждого сигнала. для SIGINT дефолтовое дейтсвие это уничтожит процесс. а например для SIGCHLD дефолтовое дейтсвие это проигнорировать.

также там в манах написано что libc signal() она херово переносится с платформы на платформу ( а оно вобще надо? ), они пишут что код будет переносимым только если мы во втором параметре будем использовать SIG_IGN\SIG_DFL а если ссылку на тело хендлера то нет,
 поэтому они советуют вместо libc signal() использовать libc sigaction().



как видно я в программе вторым параметром выставляю действие SIG_IGN - оно говорит что   to ignore this signal (пруф в man 2 sigaction).
таким образом когда в процесс прилетает сигнал SIGINT то мы в ответ неделаем ничего. компилируем запускаем проверяем - начинаем тыкать Ctrl+C - в ответ программа продолжает работать.


а вот это как выглядит сисколл который наша программа вызывает в итоге при запуске (смотрим через strace) 
$ strace ./40.exe

rt_sigaction(SIGINT, {sa_handler=SIG_IGN, sa_mask=[INT], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7fb9c1415040}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0

видно что реальн испльщуется сиколл rt_sigaction с параметрами
sa_handler=SIG_IGN,
sa_flags=SA_RESTORER|SA_RESTART
sa_handler=SIG_DFL == ? вот это пока непонятно почему второй sa_handler есть

поэтому кстати и 

$ kill -15 pid

непоможет. 

далее я еще чуть добавил в программе а именно игноринг сигнала SIGTERM который -15

$ cat 40.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

int main(void)
{
//Register signal handler through the signal() function
signal(SIGINT, SIG_IGN);
signal(SIGTERM, SIG_IGN);

while(1)
{
//simulate a delay -- as if the program is doing some other stuff
sleep(10);
}

return 0;
}

теперь программу и через 

$ kill -15 pid

незавалишь. только kill -9 потому что еще раз напоминаю (согласно man 7 signal) The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. поэтому на kill -9  нельзя кастомный хендлер написать. а по дефолту ядро убивает процесс на SIGKILL.

а вот я подключился к нашему 40.exe 

$ sudo strace -f -p 2590
strace: Process 2590 attached

и смотрю как в него прилетали сигналы

--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---
restart_syscall(<... resuming interrupted nanosleep ...>) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)

--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=27858, si_uid=1000} ---
restart_syscall(<... resuming interrupted nanosleep ...>) = 0

+++ killed by SIGKILL +++

видно что ни SIGINT ни SIGTERM немогли убить процесс.
видно что происходил рестарт сисколла nanosleep мне кажется потому что при установке хендлера
был выставлен флаг sa_flags=SA_RESTORER|SA_RESTART
вопрос а зачем его рестартовать. почему просто непродолжить с того места где закончил 
перед входом в хендлер.

ну вобщем это приколтно что в signal () можно сразу указат действие а не ссылку на 
тело большого хендлера.

а щас у меня вопрос что значит reestablish handler.

пока двигаем далее. походу я понял почему в хендлере
static void reapChild(int sig) {
    while (1) {
       pid_t pid = waitpid(-1, NULL, 0);
       if (pid < 0) break;
       NumChildrenExit++;
    }
}

нужно заменить 

waitpid(-1, NULL, 0)

на

waitpid(-1, NULL, WNOHUNG)

если у процесса нет детей то команда waitpid(-1, NULL, 0) возвращается мгновенно,
а если у проецсса есть дети живые то waitpid(-1, NULL, 0) будет ждать вечно пока наконец чайлд несдохнет. а пока чайлд несдох продвижение по коду нашего процесса остановилось то есть время идет
а команды из нешего кода дальше недвигаются. что будет с состоянием процесса. процесс будет иметь
все это время статус S. тоесть waitpid вызвал сисколл wait4 а тот попросит шедулер выдавить исключить процесс из ранкью до тех пор пока несдохнет чайлд. все тоесть исполнение кода нашего порцесса остановилось по всем фронтам. теперь код нашего процесса вообще даже физически нанаходися
на цпу. в интернете про такой случай пишут что waitpid blocks процесс. вот как я понимаю 
под слоовом blocks они имеют ввиду что с точки зрения продвижения по списку команд на даннй момент
продивжение застыло на одной команде и ожидается ее выполннение. тоесть програмисты под слоловом blocks неимпют ввиду ни статус процесса ни цпу ни шедулер а чисто юридическую вещь что мы берем два момента времени и сраавниваем разные команды выполняются или одна и таже. если одна и таже
значит эта команда blocks исполннеие программы.
так вот ключ WNOHUNG дает что что наш waitpid "превращается " в checkpid. тоесть еще раз по дефолту
без ключа WNOHUNG waitpid будет ждать до бесконечности (остановив дальнейшее продвижение по коду
программы) до того момента пока очередной чайлд несдохнет. а ключ WNOHUNG дает то что waitpid
неждет он проверяет если есть сдохший чайлд то он счиает с него код возврата а если нет то он неждет а просто сразу возврашается обратно и программа продолжает исполгняться дальше.
вторйо параметр NULL это в какую переменую сохранять код возврата. если NULL то никуда нам пофиг
на код возврата.

далее надо проврерить какой код возврата в случае ключа WNOHUNG кода у нас вобще нет
чилдренов и когадда у нас еть чилдрен но он еще жив. и еще случай когда есть два чилдрена
один из них умер а второй жив.

первый кэкспримент.
нет чайлдов

int status;
waitpid(-1,&status,WNOHANG);
printf("waitpid return code=%d\n", status );

резульата:
waitpid return code=32767

где 32767 это pid самого процесса. что за треш.

далее. есть один чайлд но он жив
waitpid return code=1875472032
что за бред?

аааа!!! status это не код возврата самой функции это код завршения работы чайлда. нам это ненадо.
у нас либо нет чайлда либо он еще незавершал. нам нужно аналзизиовать код врвзрата сайомой функции!!



пределелал
pid_t ret_c;
ret_c = waitpid(-1,NULL,WNOHANG);
printf("waitpid return code=%d\n", ret_c );

резултат когда нет чайлдво вобще:
waitpid return code=-1

когда один чайод и он еще жив:
waitpid return code=0


когда один умер а второй еще жив:
waitpid return code=6244
где 6244 pid того который сдох.

тепрь тогда понятен этот код

static void reapChild(int sig) {
    while (1) {
       pid_t pid = waitpid(-1, NULL, WNOHANG);
       if (pid < 0) break;
       NumChildrenExit++;
    }
}

если у нас однорвременно сдохла куча чайлдов то приелтает первый SIGCHLD
мы ызывает хендлер. он ищет есть ли сдохщий процесс. есть. делает он это неижидая. 
вычищает его. далее он еще раз делает проерку есть ли сдохщий. есть и так до поледнего 
сдохшего. как только сдохшие заонкчились мы получим код возарата -1 и тогда тут же выйдем 
из хендлера. если на момент работы хендлера еще ктото сдохнет то мы его тоже вычистим непотеряв.
а что было бы если бы неблыо флага WNOHANG. было бы вот что.. у нас два чайлда. один сдох
синал SIGCHLD прилетел и был вызыван хендлер. он вычистил первого мгновенно потом 
цикл отработал еще и он будетвечно ждать пока отратботает второй. поэтому все компопнеты кода
абсолютно неободимы!

понятно. на данны момент оатетс открыты вопрос о одновременном прлете сигналов в процесс.
теряютсяне ретяются. задерживаются или что. прилет сигнала когда хендлер работает. 
тоже как там и что.
рассмотрим. берем программу

$ cat 41.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

 void vasya(int sig){
      printf("i am inside the handler\n");
      sleep (10);
       };


int main(void)
{
signal(SIGINT, vasya);

printf("parent: parentpid=%d\n", getpid());
pid_t pid_c;



while(1)
{
sleep(10);
}

return 0;
}


очень простая программа. регистрируем кастомный хендлер для SIGINT
далее в теле программы крутится бесконечный цикл.

хендлер очень простой как только мы в него попадаем то он об этом пишет на
экране и далее этот хендлер засыпаает на 10с.
к чему это приводит: мы тыкать на клаве Ctrl+C много много раз сразу например 7 раз.(можно вместо тыканья Ctrl+C много раз послать kill -2 pid). тоесть мы посылаем в наш процесс один за одним сразу много сигналов SIGINT. что происходит дальше - как показала практика как только прилетел первый сигнал 
то срабатывает хендлер. на экране мы видим  

i am inside the handler

далее ничего непроисходит. тоесть второй и третий сигнал ничего недают - действие хендлера непрерывается новыми сигналами. 
он успешно отрабатывает свой код и засыпает на 10с. мы при этом ничего неделаем вот как нажали послали вначале программы 7 сигналов и сидим ждем. итак мы уже увидели что в хендлер прилетает
только первый сигнал. второй третий итд они блокируются в том плане что они уже непрерывают
хеендлер от первого сигнала. итак хендлер если начал работать то он уже непрерывается работает
до конца. окей итак хендлер нерперрывается сигналами которые после. это мы выяснили. 
вопрос следущий - что стало с тем сигналами что были посланы второй третий четвертный итд.
вот мы в хендлере  а что будет когда он закончит свою работу и выйдет - то есть что стало с сигналами которые второй третий четвертый. они пропали или что. практика показала что 
ядро сохраняет ровно один сигнал из тех что прилетели к процессу когда он уже был в хендлере.
таким образом если мы начали тыкать Ctrl+C скажем 7 раз подряд то первый сигнал вызывает хендлер.
второй держится во внутренней очереди пока хендлер незакончит. как толлько хендлер вышел то процессу
доставляется второй сигнал и он обрабатывается хендлером. остальные сигналы из семи (третий четвертый пятый шестой седьмой) они теряются. таким образом я бы суммарно описал так. вот прилетел
у нас сигнал в процесс. срабатывает хендлер. в это время летят еще сигналы - это неприводит ни к чему  втом плане что работабщей хенддер непрерывается. сигналы которые прилеетли в процесс во время
того как работал хендлер  они все теряются кроме одного , тоесть хоть пятьдесят сигналов пошли 
во время работы хендлера сохраняется и удерживается гдето там внутри  только один. и когда хендлер
выйдет закончив работу то процессу будет доставлен один сигнал из тех что были нарпавлены во время 
того как выполнялся хендлер. таким образом в целом есть проблема что из тех сигналов что прилетят к процессу ( имеется ввиду сигналов тех же самыхтоесть sigINT в нашем случае) во время выполнения
хендлера они все потеряются кроме одного. он будет сохранен и доставлен процессу как только хендлер
закончит свою работу. поэтому чем длинее хендлер тем больше вероятность потерять часть сигналов.

тут я щас покажу с каким параметрами устанавливался хендлер для SIGINT как показывает strace
rt_sigaction(SIGINT, {sa_handler=0x5610fbac176a, sa_mask=[INT], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7f2e44c78040}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0

а вот как выглядит работа на практике на экране

$  ./41.exe
parent: parentpid=19649
^Ci am inside the handler
^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^Ci am inside the handler

видно что янажал ^C и тут же сработал хенделер и написал i am inside the handler
я при этом продолжад нажимать ^C вот их куча на экране но больше ничего непроизошло.
далее я сидел и ждал . прошло 10 секунд. и на экране появилась еще одна надпись i am inside the handler и далее уже ничего непроисходило. то есть из той кучи ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C
которую я пронажимал была обработана только один. остальные пропали вникуда.  я специально
вставил в хенлере паузу 10с чтобы он отрабатывал долго чтобы четко отловить поведение системы
относиельно сигналов на момент работы хенлера  в том плне будет ли он прерван новым выполеннием
хендлера и скоьк сигналов сохранит система на момент когда хендлер вернется.



есть еще вопрос а что если во время выполнения хендлера прилетит сигнал но неатакой же адругой.
будет ли прерван этот хендлер ради выполнения нового хенлера от нового сигнала. например у нас прилеел SIGINT заупустился его хендел тут прилете еще один SIGINT это мы уже знаем что этот 
сигнал неперерывает наш хендлер а после этого еще поилеие сигнал SIGTERM так вот в на этот сигнал 
поскольк уон друогого рода будет ли прерван хендлер обаработки SIGINT или нет?

-1 -1 -1 -2 -2 -2 
-1 -1 -2 -2

i am inside the handler SIGHUP       -x -1  -2 -2 
 i am inside the handler SIGINT      -x -1  -x -2 
 i exit from the handler SIGINT      
 i am inside the handler SIGINT      -x -1  -x -x 
 i exit from the handler SIGINT 
i exit from the handler SIGHUP       

i am inside the handler SIGHUP       -x -x  -x -x 
i exit from the handler SIGHUP 


-1 -2 -1 -2 -1 -2

i am inside the handler SIGHUP 
i am inside the handler SIGINT 
i exit from the handler SIGINT 
i am inside the handler SIGINT 
i exit from the handler SIGINT 
i exit from the handler SIGHUP 
i am inside the handler SIGHUP 
i exit from the handler SIGHUP 

-1:| -2 -1 -2 -1 -2

-1: -2:| -1 -2 -1 -2

-1: -2: (-1) -2:| -1 {-2}

-1: -2: -1:| -2: {-1} {-2}

(-1) -1   (-2) -2 


вбиваем
-1 -2 -2 -2 -1 -1 -2 -1 -2 -1 -2 -2 -1 -1 -2 = -1 -1  -2 -2 =>

предсказание
-1 
-2
-2
-1


практика
i am inside the handler SIGHUP 
 i am inside the handler SIGINT 
 i exit from the handler SIGINT 

 i am inside the handler SIGINT 
 i exit from the handler SIGINT 
i exit from the handler SIGHUP 

i am inside the handler SIGHUP 
i exit from the handler SIGHUP


исходный сигнал
-10 -1 -10 -1 -2 -10 -10 -1 -2 -10 -10 -2 -1 -2 -10 -2 -1 -10 -10 -1 -2 -1 -2 -10
= урезаем -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -1  -1  -1  -1 -1  -1 -1 -2 -2 -2 -2 -2 -2 -2 
= еще урезаем = -10 -10 -1  -1  -2 -2 = как в итоге будет -10 -1 -2 -2 -1 -10 

практика
i am inside the handler SIGUSR1   -10
i am inside the handler SIGINT    -2
i exit from the handler SIGINT 
i am inside the handler SIGINT    -2
i exit from the handler SIGINT 
i exit from the handler SIGUSR1    
i am inside the handler SIGUSR1   -10
i exit from the handler SIGUSR1
i am inside the handler SIGHUP    -1
i exit from the handler SIGHUP    
i am inside the handler SIGHUP    -1
i exit from the handler SIGHUP    

вывод такой. берем общую очередь , разделяем на группы - здесь было три группы: -10, -1, -2
далее в кажой группе оставляем максимум два элемента тоесть:

первая группы было : -10 -10 -10 -10 -10 -10 -10 -10 -10 -10
стало: -10 -10
вторая группы было: -1  -1  -1  -1 -1  -1 -1 
стало: -1 -1
треятья группы было: -2 -2 -2 -2 -2 -2 -2
стало: -2 -2 

итоговая группа: -10 -10 -1 -1 -2 -2 
далее ее перемешиваем рандомно кроме первого элемента он остается и вот в таком порядке
ядро собачит сигналы процессу. напрмер:

-10 -1 -10 -2 -1 -2

далее правило такое: запускается хендлер. далее берем следущий сигнал и смотрим он такой же 
по номеру или нет. если нет то текущий хендлер прерывается и запускается следущий. 
и идем дальше по спику если такой хендлер уже запущен то пропускаем а если нет то прерываем 
текущий хендлер изапускаем следущий. итак до конца . получамм:

вошли в -10
прервали -10 и вошли в -1
-10 (пропускаем ибо уже запущен)
прервали -1 и вошли в -2
-1 (пропускаем ибо уже запущен)
-2 (пропускаем ибо уже запущен)
конец списка. тогда ждем чтобы выполнился последний хендлер.
-2 вышли.
далее опять смотрим на оставииеся сигналы. тут вопрос - опять рандомно смотрим оставишхся
или по списку? положим по списку. тогда 
-2 вошли
-2 вышли
-1 вышли
-1 вошли
-1 вышли
-10 вышли
-10 вошли 
-10 вышли

итого:
-10 +
-1 +
-2 +
-2 -
-2+
-2-
-1 -
-1+
-1-
-10-
-10+
-10-



-10 -1 -10 -1 |
-2 -10 -10 -1 |
-2 -10 -10 -2 | 
-1 -2 -10 -2 |
 -1 -10 -10 -1 | 
 -2 -1 -2 -10 |);


 kill -10 $pid
 kill -1 $pid
 kill -10 $pid
 kill -1 $pid

 kill -2 $pid
 kill -10 $pid
 kill -10 $pid
 kill -1 $pid

 kill -2 $pid
 kill -10 $pid
 kill -10 $pid
 kill -2 $pid

 kill -1 $pid
 kill -2 $pid
 kill -10 $pid
 kill -2 $pid

 kill -1 $pid
 kill -10 $pid
 kill -10 $pid
 kill -1 $pid

 kill -2 $pid
 kill -1 $pid
 kill -2 $pid
 kill -10 $pid
 


из эксериментов у меня сложилось пока ткое впечателение:
если сигналы прилетают друг от друга реально рядышком пактом то ядро пытается сгурппировать 
сигналы по группам и совать их в порядке таком: вначале два из одной группы потом два из другой
групы и потом два из третьей грцппы , чтобы видимо неразывать хендлры изнутри.
например мы пустили 10 1 2 10 1 2 2 10 1 2  тогда ядро пусти сигналы 
как так 10 10 2 2 1 1. чтобы небыло разрыва внути хендлера.
а если сигналы прилетают друг т друга с зедержкой то тогда уже ядро ничего неделает
и происходит разрыв. единсвтенное что полюому неболее двух сигналов в группе. остальные 
просто отбарсываются. <=== закогчил тут





тут я прервался и прерквлюичился на тему цпу интерраптс:
книга- Pentium® Processor Family
Developer’s Manual
Volume 3:
Architecture and Programming Manual

стр. 3-32:
The processor has two mechanisms for interrupting program execution:
1. Exceptions are synchronous events which are responses of the processor to certain
conditions detected during the execution of an instruction.
2. Interrupts are asynchronous events typically triggered by external devices needing
attention.
Interrupts and exceptions are alike in that both cause the processor to temporarily suspend the
program being run in order to run a program of higher priority. The major distinction
between these two kinds of interrupts is their origin. An exception is always reproducible by
re-executing the program which caused the exception, while an interrupt can have a complex,
timing-dependent relationship with programs.

сhapter 14:
Exceptions and interrupts are forced transfers of execution to a task or a procedure. The task
or procedure is called a handler.
Interrupts occur at random times during the execution of a
program, in response to signals from hardware. Exceptions occur when instructions are
executed which provoke exceptions. Usually, the servicing of interrupts and exceptions is
performed in a manner transparent to application programs. Interrupts are used to handle
events external to the processor, such as requests to service peripheral devices. Exceptions
handle conditions detected by the processor in the course of executing instructions, such as
division by zero

There are two sources for interrupts and two sources for exceptions:
1. Interrupts
 Maskable interrupts, which are received on the CPU's INTR input pin. Maskable
interrupts do not occur unless the interrupt-enable flag (IF) is set.
 Nonmaskable interrupts, which are received on the NMI (Non-Maskable Interrupt)
input of the processor. The processor does not provide a mechanism to prevent
nonmaskable interrupts.
2. Exceptions
 Processor-detected exceptions. These are further classified as faults, traps, and
aborts.
 Programmed exceptions. The INTO, INT 3, INT n, and BOUND instructions may
trigger exceptions. These instructions often are called "software interrupts," but the
processor handles them as exceptions.
This chapter explains the features of the processor which control and respond to interrupts.

номер интеррапта \ эксепшена назвыается vector.
The vectors for maskable interrupts are determined by hardware. External interrupt
controllers (such as Intel's 8259A Programmable Interrupt Controller) put the vector on the
processor's bus during its interrupt-acknowledge cycle. 

Faults—A fault is an exception which is reported at the instruction boundary prior to the
instruction in which the exception was detected. The fault is reported with the machine
restored to a state which permits the instruction to be restarted. The return address for the
fault handler points to the instruction which generated the fault, rather than the instruction
following the faulting instruction.

Traps—A trap is an exception which is reported at the instruction boundary immediately
after the instruction in which the exception was detected. ('сюда как раз инструцция int n входит)

Aborts—An abort is an exception which does not always report the location of the instruction
causing the exception and does not allow restart of the program which caused the exception.
Aborts are used to report severe errors, such as hardware errors and inconsistent or illegal
values in system tables. тут говорится о том что обработчик аборта невсегда может указать 
на какой команде произошла жопа и не всегда можно продолжить выполнеие далее. ибо аборт случается в случае тяжелых повреждений железа видимо.

тут вопрос заключется в том что непонятен смысл слов синхронный vs асинхронный. 
как я понял в это вкладывется дурацкий смысл - синхронный значит что ошибку можно повторить еси заупстит программу повторно то она на том же месте на тойже команде сгеннерирует предасказуемо
ту же ошрбку а асинхронный означает что грубоговоря время возниконовние ошибки непредтказуеом(ибо 
это происходит на внешнему устройстве).бредятина. также непонятно когда происходит переход на исоплнение  хенддера - до дермьмовой команды или после или когда? ( а начал я это изучать по прчиичине слов синхронный асинхронный signal . оттуда я суюда пришел!)

еще раз начал читать про цпу интеррапты из за темы signals и фразы syncronoous\asyncronous
хочу понять что это значит. а сигналы я начал читать с темы одновременного прихода несоклких
сигналов в процесс. и комндды waitpid (-1,null,WNOHUNG) зачем его сунули в хендлер? !!!
вот откуда я сюда пришел!



так пока оставим тогда цпу интеррапты. нафик а то перегруз головы.
