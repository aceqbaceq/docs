книги по устройству ядра(которые у меня есть):
-  operating systems three easy pieces


xv6:
- скачал книжку = /book-rev11.pdf (https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf)
- unix6.pdf = это коментарий к реальному эникс6 на pdp11 который влохновил написание xv6
	(https://cs3210.cc.gatech.edu/r/unix6.pdf) ("A COMMENTARY ON THE SIXTH EDITION 
	UNIX OPERATING SYSTEM" J. Lions.)
- мнжетсво учебного материала про xv6 = https://pdos.csail.mit.edu/6.828/2011/overview.html
---


еще более исходный вопрос - это чем деплоймент оличаетя от реплика сет и всего остального

исходный вопрос - кониейнер. pid1 чилдрены. родич умер. чилдрены остались.
чиолдрен умер. прилетел сигнал к pid1 , сигнал по деолфту игнорится. а в pid-1 нет касмного
хендлера. так это все или не так. и как куб в своих подах с этим борется ?

асинхронны сигнал что это ?
в плане сигналов надо разобрать случай когда приелетает от кучи детей сигнал sigchld
и мы их все ловим нетеряем

как работает вызов syscall на уровне цпу и ос

nasm+ld vs gcc  -> syscall 
_start vs _main
signals in linux (прочесь в файле c+assembler)
как это работает что у нас выполняется сисколл тоесть цпу работаетв привлигированном
режиме и его могут прервать через сигнал на выполнение хэндлера сигнала.или как там 
это работает ? как вобе можно прервыать сисиколл. ведь в это время цпу работае в режиме ядра
тоесть там нет никакого прцоесса. если процсс прерыать то его состояние можно срхранить
а как можно созранить состояние выполпние сисколла в режиме ядра? тамже нет процесса никакого !

====
вопросы на которых остановился:
linux:
 page tables. прочитать упрошенный вариант из book-rev11.pdf и unix6.pdf

раздел multitasking
 щас я более подоробно смотрю на два вопроса nested interrupts 
 какой stack испльзуется
 при обработаке интеррапта? 
 tasklet vs hard irq vs softirq? что у них со стеком? 
вопрос нахрена нужен стек push\pop если есть movl ведь в итоге push\pop работает с той же
памятью
про контекст свичинг. есть понятие cpu context switching а есть linux process context switching
 а есть software context switching а есть cpu hardware context swithing.
 что такое intel tss 
 ===>что такое и зачем stack alignment? и связанный  с ним вопрос - а что такое assmbly function? как это с abi связано? закончил на том что научился компилить и дизасмемблтть проги и в gdb смотреть
 и щас хочу понять как там что происходит при командах push\pop с указателем стека итп <======

 



раздел syscall
-вызов через int 80 vs через syscall
- далее надо разобратсья так как же через какие регистры происходит адресация в 64 битном режиме
в протектед моде  в режиме ядра
-непонятно что такое process context. какие регистры входят и что еще.(также непонятно
вот мы сисколлом вызывали фнукция в ядре. цпу пеерключился в ринг0 что значит что код ядра
выполняется в контексте юзерского процесса). насколько я понимаю что когда цпу в режиме ядра
то то код ядра работает в виртуальном пространсте памяти как его видит процесс в юзерском режиме
плюс также ядерный код еще видит память которая ядру принадлежит. в общем здесь еще вопрос
в том что очеивдно что в режиме ядра этот код может быть прерван получается как это согласовать 
с шедулером. как это все шедулится? еще вопрос если процесс вызывал сисколл и цпу начал работать в режиме ядра то какой статус у процесса ?


отдельно:
про состояние процессов 'S'и 'D'.
хотелось понять  так юзается ли цпу когда проессы в этом состоянии ли нет. 
выполняется ли на цпу код самой программмы а может волпняется ядерный код? а если ядерный код
то мы увидим процессорную загрузку именно для этого процесса или она невидна?
короткий ответ такой если у процсса состояние 'S'или 'D' то ни его юзерский код непоадает на 
цпу никакой ядерный код тоже непоадает на цпу. а то что top рисует что процесс 'S'\'D' поребляет
цпу например:


  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                                                   
                                                                                                                 
11242 vasya     20   0 16,834g 496240 115508 S   5,3  3,1  18:50.20 chrome                                                                                                                    
11286 vasya     20   0 16,501g  97576  60228 S   5,3  0,6   7:07.85 chrome   


Так это кажущееся расхождение теории с практикой. дело в том что %CPU это не характирикстка
про сейчас. это среднее за предыдудший промеждуток времени. это значит что за поледние 3 секунды (дефолтовое время усредение у программы top) данные процессы перклюачаист в режим 'R' и жрали цпу.



что немогу понять. если процесс в 'D' state тожрет ли процессор юзер код или кернел код.
или нет? как насчет 'w' state в цпу? = ответ нет. ни юзер код процесса ни сисколл если он его вызывал
тоеть кернел код они все непопдают на цпу. процесс нихера нежрет цпу время. вообще. а как же так
получается часто может но видеть в top что процесс в состоянии D однако cpu usage неноль. секрет
в том что процесс пееключается между D и R состоянием простомы этого незамечаем потому что
top показывает состояние процесса на момент "сейчас". у top между периодами обновления
проходит 3 секунды. что там за эти три сенкуды просиходит с состоянием процесса мы незнаем. он может
100 раз пеоключитя на R состоие и начать жрать цпу. а cpu колонка в top это незначение
на сейчас а это среднее за прошедшие 3 секунды. если же процесс 100% все три секунды был только 
в состоянии D то тогда я гарантрую что cpu usage должен быть строго 0%. если не ноль то значит 
что гаратингванно процесс перелкючася на R состояние. я так понимаю.


