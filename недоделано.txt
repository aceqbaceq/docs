книги по устройству ядра(которые у меня есть):
-  operating systems three easy pieces
- здесь два курса и несколько книг по устройству ос (https://www.cse.iitb.ac.in/~mythili/)


xv6:
- скачал книжку = /book-rev11.pdf (https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf)
- unix6.pdf = это коментарий к реальному эникс6 на pdp11 который влохновил написание xv6
	(https://cs3210.cc.gatech.edu/r/unix6.pdf) ("A COMMENTARY ON THE SIXTH EDITION 
	UNIX OPERATING SYSTEM" J. Lions.)
- мнжетсво учебного материала про xv6 = https://pdos.csail.mit.edu/6.828/2011/overview.html
---
man bash 
и еще книжку по bash
----
основа понимания линукса
asm, c, сисколлы, процессы, терминал, procfs
---
закрыл часть вкладдок в браузере от 29 мая.

еще более исходный вопрос - это чем деплоймент оличаетя от реплика сет и всего остального

исходный вопрос - кониейнер. pid1 чилдрены. родич умер. чилдрены остались.
чиолдрен умер. прилетел сигнал к pid1 , сигнал по деолфту игнорится. а в pid-1 нет касмного
хендлера. так это все или не так. и как куб в своих подах с этим борется ?

асинхронны сигнал что это ?
в плане сигналов надо разобрать случай когда приелетает от кучи детей сигнал sigchld
и мы их все ловим нетеряем

как работает вызов syscall на уровне цпу и ос

nasm+ld vs gcc  -> syscall 
_start vs _main
signals in linux (прочесь в файле c+assembler)
как это работает что у нас выполняется сисколл тоесть цпу работаетв привлигированном
режиме и его могут прервать через сигнал на выполнение хэндлера сигнала.или как там 
это работает ? как вобе можно прервыать сисиколл. ведь в это время цпу работае в режиме ядра
тоесть там нет никакого прцоесса. если процсс прерыать то его состояние можно срхранить
а как можно созранить состояние выполпние сисколла в режиме ядра? тамже нет процесса никакого !
====
puts
printf

разница. 
и формат что в себя включает у prinf
====
вопросы на которых остановился:
linux:
 page tables. прочитать упрошенный вариант из book-rev11.pdf и unix6.pdf


дописать ответы на вопросы syscall, multitasking.
===
understanding linux kernel
главы: interrupts, scheduling, signals 
===


раздел multitasking
 щас я более подоробно смотрю на два вопроса nested interrupts 
 какой stack испльзуется
 при обработаке интеррапта? 
 tasklet vs hard irq vs softirq? что у них со стеком? 
вопрос нахрена нужен стек push\pop если есть movl ведь в итоге push\pop работает с той же
памятью
про контекст свичинг. есть понятие cpu context switching а есть linux process context switching
 а есть software context switching а есть cpu hardware context swithing.
 что такое intel tss 
 что такое и зачем stack alignment? и связанный  с ним вопрос - а что такое assmbly function? как это с abi связано? закончил на том что научился компилить и дизасмемблтть проги и в gdb смотреть
 и щас хочу понять как там что происходит при командах push\pop с указателем стека итп 

 



раздел syscall
-вызов через int 80 vs через syscall
- далее надо разобратсья так как же через какие регистры происходит адресация в 64 битном режиме
в протектед моде  в режиме ядра
-непонятно что такое process context. какие регистры входят и что еще.(также непонятно
вот мы сисколлом вызывали фнукция в ядре. цпу пеерключился в ринг0 что значит что код ядра
выполняется в контексте юзерского процесса). насколько я понимаю что когда цпу в режиме ядра
то то код ядра работает в виртуальном пространсте памяти как его видит процесс в юзерском режиме
плюс также ядерный код еще видит память которая ядру принадлежит. в общем здесь еще вопрос
в том что очеивдно что в режиме ядра этот код может быть прерван получается как это согласовать 
с шедулером. как это все шедулится? еще вопрос если процесс вызывал сисколл и цпу начал работать в режиме ядра то какой статус у процесса ?


еще вопрос:
посмотреть какие регистры сохраняются и как там с регистрами стека при входе в int80\syscall
что интересного открылось - мы немжем через gdb долезть до кернел функций. как только мы вызываем 
ядерный код через syscall\int80 то туда глубже провалится нельзя. gdb недает. он возврашется 
сразу с резултатом который дает сискол.. то есть gdb может дебагить только в юзер спейсе.



=====> 

вопрос: как работает tickless ядро , как оно без таймер интеррапт раотает ?

====

вопрос:

как работает clone+ execve?
парент через clone создает новый процесс . вопрос как после этого парент может влезть 
в новый процесси и запутитьв нем execve ?

вроде бы ответ вот какой. форк запускаетя в родиче а exec уже чайлде. поскольку чайлд это точная
копия родича значит в коде проги делается if (если я щас в чилдрене ) то взывать exec.
таким образом я бы сказал так это не родич лезет в чайод и выывает exec это сам чайл форкнутый 
сам вс ебе вызывает execve. вот и весь секрет.

===
а как дела если нескоько ядер?  как тогда срабаывает шедулер?
===

ответ на ворос из интернета:
Is the process scheduler "visible" at user space? 
No. Because scheduler is not a process.

Can I see it with ps? 
No because ps shows the list of processes.

Maybe is it one of the kernel threads?
If yes, how is it called?
No.

How can I "see" it?
Usually we have a habit to work with processes in linux as a smallest entity. As scheduler
is not a process you can not "see" it this way.

It doesn’t exist as a separate thread, or module, it’s implemented as a function

Ok, but how and where and in which way is this function run? Is there a way to track it and see it?
It works this way ( very simplified ):
There is a timer inside PC. From time to time it sends a signal (an interrupt) to cpu (via interrupt controller). An interrupt is the electrical signal that goes to cpu via its pin. 
When cpu gets this interrupt it stops what he is doing, saves some registers  and starts to run ISR(Interrupt service routine). An interrupt is the event inside pc that cpu must handle. It means cpu need some piece of code to make it. ISR is the code. Where does it come from? Operating system puts the code beforehand. CPU jumps to ISR ( to be specific "timer interrapt handler") and it invokes scheduler. Scheduler makes "context switch" that is: it evicts some processes from cpu and launches some other, that is it saves all the registers of cpu to memory  (and some other stuff) of one process and loads from memory saved registers state to registers. When it is done scheduler 
exits and the process starts to work for some time until new timer interrupt happens, new scheduler invocation happens.The current process will be evicted and new one will be launched. This is how multitasking works. Timer Interrupt happens 10ms. That is scheduler is invoked every 10ms.


The schema:

Timer Interrupt  --> ISR --> Scheduler  ---> A process switch

Well overall i cant suggest a method to "see " or "touch" scheduler. 

========================
bash
что получается когда мы в баше делаем

$ ./1.exe & 
как это работает на бекенде ?

======
loadaverage?
это среднее число процессов в runqueue(тоесть со статусом R) шедулера 
либо процессов которые имеют статус 'D' за 1\5\15 минут
==========
про runqueue кто определяет чтобы процесс был помеещен в runqueue.
ответ . по дефолту код всегда будет туда помещен. а вот чтобы его оттуда убрали
надо чтобы сисколл который должен вызывать шедулер должен попросить шедулер убрать его из 
runqueue. поэтому когда говорят что процесс runnable возниакает вопрос а как это линукс лпредедляет
что таск = runnable. как он узнает поотребоности процесса. ответ в том что по дефолту процесс
считватется runnable а вот чтобы он таким перестал быть над просить об этом шедулер через сисколл
а то вот пишут "когда процесс готов к исполнеию". а от чего это зависиит как лиунукс это понимает
обьяснения недают.
тоесть по дефолту любой процесс шедулер постоянно размещает в очереди на исполнение.
и только если специально просить шедулер то он будет оттуда задчу убирать. так что с тчоки зрения
динукса и шедулера программа по дефолту всегда готова к исполнению так что эта формулировака
дебилная. она может быть не готова если только обб этом специально просить шедуделер.
в общем форумилрорвака дебильная.
=======
если есть праень и чайлд и мы шлем килл -15 паренту . вопрос будет ли автоматом убит чайлд
или только парент?
частчно ответил на этот вопрос . но до конца нет уверенности. смотри "processes kill parent child"

======
программа

#define _GNU_SOURCE
#include<stdlib.h>
#include<unistd.h>
#include<stdio.h>
#include<sched.h> 


int variable, fd;

int do_something() {
   variable = 42;
    printf("The child: the variable = %d\n", variable);
   _exit(0);
}

int main(int argc, char *argv[]) {
   void **child_stack;
   char tempch;

   variable = 9;
   child_stack = (void **) malloc(16384);
   printf("The parent: the variable = %d\n", variable);

   clone(do_something, child_stack, CLONE_VM|CLONE_FILES, NULL);
   sleep(1);

   printf("The parent: the variable is =  %d\n", variable);
   return 0;
}



вылетает с segmentation fault 
при попытке в треде
printf("The child: the variable = %d\n", variable);
   _exit(0);

почему?
=======
D статус он вызывает  W статус в top/nmon
или что вызвыает W что это как это увидеть в procfs ?
мне непонятна откуда берется характирстика W !
======
неигнорируемый сигнал типа -9 может ли у него быть кастомный обработчик сигнала
или только ядерный дефолтовый хендлер
в man signal нашел что :
The signals SIGKILL and SIGSTOP cannot be caught or ignored.

=====
Z процесс
гда на живой практике с нимис сталкиваются так чтобы они рождались 
из каких то практичекиз случаев а не лабораторных симуляциях ?

====
getconf\sysconf
о чем это ?
=====
C конструкция struct
как с ней раотать.
разобрать на примере nanosleep
=====
pselect6 
часто исполщуется в bash
о чем он?
=======
разбобрать clone()
 у него там всякие опции интересные есть. например чтобы процесс
 имел свой стек. о чем это ?

 =====

restart_syscall
почитать man
====
man intro
man standards
man signal
man syscalls
man wait
=====
ps -A  -f f

разобрать вывод (иерархический вид процессов)
и смысл ключей

замечу что 
ps -f f и ps -ff 
это совсем разный вывод!
===
man exit
прочитать потмоу что там есть инфо про зомби процессы и про то как
работает связь между парент и чайлды
====
signal

одноверменный прилет сигналов одного и тогоже сигнала (принимает ли ? копит ли? прерывает
ли хендлер? )
wait vs waitpid?
waitpid в цикле?

далее прикол втом что если мы заменим строчку 

sleep(30 * kid);

на 

sleep(1);

это будет значит что все чилдрены одновременно (более менее) закончать свою работу.
тогда получится то что (надо обьяснить почему) часть чайлдов окажется необработанной 
сигнал хендлером и они останутся висеть как Z. 
чтобы этого небыло наизменить хэендлер вот с такого

static void reapChild(int sig) {
  waitpid(-1, NULL, 0);
  NumChildrenExit++;
}

на такой (обьяснить почему это даст эффект)

static void reapChild(int sig) {
    while (1) {
       pid_t pid = waitpid(-1, NULL, 0);
       if (pid < 0) break;
       NumChildrenExit++;
    }
}


(обьяснить почему это даст эффект)


причем походу когда вызывается сигнал хендлер то по любому парент процесс блочится?(статус D видимо?) или просто неисполняется типа как goto\jmp? 

что дает waitpid(-1, NULL, 0) vs waitpid(-1, NULL, WNOHANG ) ?

получается что wait от waitpid оличается тем что в waitpid побольше есть опций и все.
если мы в теле программы ставим wait\waitpid то программа дальге недвинется пока неумрет
хотя бы один чайлд wait]waitpid будет стоять и ждать. и только окгда умрет хотя бы один чайлд
тогда будет возврат из этой функции и тело главой программы сможет двигать дальше.

если поместить wait\waitpid в хендлер то возврат в главнуб прграмму произойдет мгновенно
потому что хендлер то вызывается только тогда когда один из чайлдов точно сдох. поэтому когда
мы помщаем wait\waitpid в хендлер а не втело пгрограммы то тогда блокировка (то есть задержка выполнения гавной программы) минимальня по времени. во время задержки как я понимаб (надо провертиь)
 сттатус парент процесса будет R.  

 поэтому если мы арзмеостоли wait\waitpuid  втеле програмы но нехотим ждать пока чайлд  сдохнет
 то мы тогда вот используется для этого флг WNOHANG

 waitpid(-1,null,WNOHANG)

 этот флаг приводит к тому что waitpif неждет когда сдонет чайлд а просто делает проверку есть ли 
 сдохший прям щас. если не то сразу возврвается в тело главной прогарммы.
 вот зачем может понадобтся флаг WNOHANG!!!!

 тогда зачем он нужен в хенделере ( втеле главной програмы понятно) ? и что будет
 если выоплнятемся хендлер а в процесс прилетает такой же сигнал? хендлер прерывается? или что?

 из man signal я вижу что если прилетел сигнал то принятие такого же сигнала блокируется (вопрос что тогда будет с прилетевшим но заблоченным сигналом)  и происходит вход в хендлер.
 по выходе из хендлера сигнал разблокируется.

при запуске прогиаммы вот  стаким сигнал хенддлером:
 signal(SIGCHLD, reapChild);

rt_sigaction(SIGCHLD, {sa_handler=0x55df72c187aa, sa_mask=[CHLD], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7fbf43736040}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0

видно что были установлены флаги:SA_RESTORER|SA_RESTART и SIG_DFL

согласно man 7 signal : if multiple instances of a standard signal are delivered while that signal is currently blocked, then
           only one instance is queued.
тоесть вот мы полувили 1 сигнал. ядро заблокиовалоп поучение нового такогоже.
вошли в хендлер. выполняем . в это время летят таки еже сигналы. и как японял ядро сохранит в 
статусе пендинг в очереди ровно 1 такойж сигнал которй будет доставлен после того как 
ехендлер закончит и выйдет.


libc signal несипольуеся керенл ссиколл signal  а исползует сисколл sigaction

(прочитать статью от доков glibc о сигналах https://www.gnu.org/software/libc/manual/html_node/Handler-Returns.html)
оттуда читаю:
When the handler for a particular signal is invoked, that signal is automatically blocked
until the handler returns. That means that if two signals of the same kind arrive close
together, the second one will be held until the first has been handled. (The handler can
explicitly unblock the signal using sigprocmask, if you want to allow more signals of this
type to arrive; see Section 24.7.3 [Process Signal Mask], page 751.)

However, your handler can still be interrupted by delivery of another kind of signal. To
avoid this, you can use the sa_mask member of the action structure passed to sigaction
to explicitly specify which signals should be blocked while the signal handler runs. 

Portability Note: Always use sigaction to establish a handler for a signal that you
expect to receive asynchronously, if you want your program to work properly on System
V Unix. On this system, the handling of a signal whose handler was established with
signal automatically sets the signal’s action back to SIG_DFL, and the handler must reestablish itself each time it runs. This practice, while inconvenient, does work when signals
cannot arrive in succession. However, if another signal can arrive right away, it may arrive
before the handler can re-establish itself. Then the second signal would receive the default
handling, which could terminate the process = чего ?

насколько я понял читая доки и по signal и по cpu interrupts и в том и в другом случае 
они когда говорят asyncncronous interrupt они имеют ввиду ( хотя это дебильно по мне) то что 
возниконовение события независит от самого кода программы, от команд программы (процесса)
с точки зрения кода програмного кода событие может возникнуть(прилететь) абсолютно непредсказуемо
в с точки зрения очередной команды в коде процесса. когда же они говоря что synchrounus interrupt
то имеютт ввиду что событие абсолютно предсказуемо возникнет ибо оно завиисит от очередной 
команды в коде процесса. ( в документации к процессаорам интел и цпу excepton\interrupt авторы 
называют синхронные события эксшепсенасами а асинхронные интерраптами  так чисто для српавки. итак еще раз с точки зрения создатеей цпу интел  если жопное событие происходит из за очередной команды в
коде то это эксепшн. и он является синхронным тоесть это ознчает что событие произошло из за команды в коде.  если жопное событие произошло не из за команды в коде а по какйото другой причине
то с точки зрения интеловцев это называется интеррапт. и это событие асинхронное то есть оно произошло не иза за команды в коде программы а из за чегото внешнего как например на сетевую карту прилетел пакет. вот что  вих дебаильном понимании смысл слов синхронное асинхронное. этот же дебилный смысл синхронное асинхронное переносится и сохраняется на signal то есть на сигналы. прилетит сигнал или неприлетит зависит не от кода в процессе а от чегото внешнего. значит это асинхронное событие. какой же дебилизм они вложиили в понятия синхронный асинхронный. обычно слово синхронный означает одновременное происходждение события с чемто с чем синхронизируемся с какито 
другим эталонный событием. здесь походу пьесы они когда говорят синхронное то связывают возникноневения события с командой в коде. тоесть если в коде есть команда скажем int n которая вызывает событие прерывания то это синхронное событие. кстати поэтому команды int n вызывает эксепшен а не интеррапт.  получается с точки зрения кода процесса появление эксепшенса полностью предсказуемо. там где есть определенный кусок кода там будет возникаить предсказумое прерывание 
выполнения кода процесса назыаемое эксепшен. а возникновение прерыавания выполненеия кода типа интеррапт совершенно не связано с телом кода с его командами. поэтому это событие interrupt.    ).


вот такая программа:
$ cat 40.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

int main(void)
{
//Register signal handler through the signal() function
signal(SIGINT, SIG_IGN);

while(1)
{
//simulate a delay -- as if the program is doing some other stuff
sleep(10);
}

return 0;
}

что в ней примечательного - во первых надо знать что signal это libc функци обертка  которая 
по факту использует сисколл rt_sigaction ( man rt_sigaction) а не сисколл signal. так вот
второй параметр в libc signal это необязательно ссылка на тело хендлера это может быть сразу 
некое действие. в данном случае  

signal(SIGINT, SIG_IGN);

поговорим о втором параметре в signal(). согласно man 2 signal
второй парметр это : 
   либо SIG_IGN, 
   либо  SIG_DFL, 
   либо the address of a programmer-defined function (a "signal handler").

SIG_IGN = означает действие проигнорировать сигнал тоесть ничего неделать
SIG_DFL = означает что ядро должно сделать дефолтовое действие в ответ на сигнал. а что 
это за дефолтовое дейтвие? это зависит от того какой конкретно сигнал прилетел, в man 7 signal есть таблица дефолтовых действия ядра для каждого сигнала. для SIGINT дефолтовое дейтсвие это уничтожит процесс. а например для SIGCHLD дефолтовое дейтсвие это проигнорировать.

также там в манах написано что libc signal() она херово переносится с платформы на платформу ( а оно вобще надо? ), они пишут что код будет переносимым только если мы во втором параметре будем использовать SIG_IGN\SIG_DFL а если ссылку на тело хендлера то нет,
 поэтому они советуют вместо libc signal() использовать libc sigaction().



как видно я в программе вторым параметром выставляю действие SIG_IGN - оно говорит что   to ignore this signal (пруф в man 2 sigaction).
таким образом когда в процесс прилетает сигнал SIGINT то мы в ответ неделаем ничего. компилируем запускаем проверяем - начинаем тыкать Ctrl+C - в ответ программа продолжает работать.


а вот это как выглядит сисколл который наша программа вызывает в итоге при запуске (смотрим через strace) 
$ strace ./40.exe

rt_sigaction(SIGINT, {sa_handler=SIG_IGN, sa_mask=[INT], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7fb9c1415040}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0

видно что реальн испльщуется сиколл rt_sigaction с параметрами
sa_handler=SIG_IGN,
sa_flags=SA_RESTORER|SA_RESTART
sa_handler=SIG_DFL == ? вот это пока непонятно почему второй sa_handler есть

поэтому кстати и 

$ kill -15 pid

непоможет. 

далее я еще чуть добавил в программе а именно игноринг сигнала SIGTERM который -15

$ cat 40.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

int main(void)
{
//Register signal handler through the signal() function
signal(SIGINT, SIG_IGN);
signal(SIGTERM, SIG_IGN);

while(1)
{
//simulate a delay -- as if the program is doing some other stuff
sleep(10);
}

return 0;
}

теперь программу и через 

$ kill -15 pid

незавалишь. только kill -9 потому что еще раз напоминаю (согласно man 7 signal) The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. поэтому на kill -9  нельзя кастомный хендлер написать. а по дефолту ядро убивает процесс на SIGKILL.

а вот я подключился к нашему 40.exe 

$ sudo strace -f -p 2590
strace: Process 2590 attached

и смотрю как в него прилетали сигналы

--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---
restart_syscall(<... resuming interrupted nanosleep ...>) = ? ERESTART_RESTARTBLOCK (Interrupted by signal)

--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=27858, si_uid=1000} ---
restart_syscall(<... resuming interrupted nanosleep ...>) = 0

+++ killed by SIGKILL +++

видно что ни SIGINT ни SIGTERM немогли убить процесс.
видно что происходил рестарт сисколла nanosleep мне кажется потому что при установке хендлера
был выставлен флаг sa_flags=SA_RESTORER|SA_RESTART
вопрос а зачем его рестартовать. почему просто непродолжить с того места где закончил 
перед входом в хендлер.

ну вобщем это приколтно что в signal () можно сразу указат действие а не ссылку на 
тело большого хендлера.

а щас у меня вопрос что значит reestablish handler.

пока двигаем далее. походу я понял почему в хендлере
static void reapChild(int sig) {
    while (1) {
       pid_t pid = waitpid(-1, NULL, 0);
       if (pid < 0) break;
       NumChildrenExit++;
    }
}

нужно заменить 

waitpid(-1, NULL, 0)

на

waitpid(-1, NULL, WNOHUNG)

если у процесса нет детей то команда waitpid(-1, NULL, 0) возвращается мгновенно,
а если у проецсса есть дети живые то waitpid(-1, NULL, 0) будет ждать вечно пока наконец чайлд несдохнет. а пока чайлд несдох продвижение по коду нашего процесса остановилось то есть время идет
а команды из нешего кода дальше недвигаются. что будет с состоянием процесса. процесс будет иметь
все это время статус S. тоесть waitpid вызвал сисколл wait4 а тот попросит шедулер выдавить исключить процесс из ранкью до тех пор пока несдохнет чайлд. все тоесть исполнение кода нашего порцесса остановилось по всем фронтам. теперь код нашего процесса вообще даже физически нанаходися
на цпу. в интернете про такой случай пишут что waitpid blocks процесс. вот как я понимаю 
под слоовом blocks они имеют ввиду что с точки зрения продвижения по списку команд на даннй момент
продивжение застыло на одной команде и ожидается ее выполннение. тоесть програмисты под слоловом blocks неимпют ввиду ни статус процесса ни цпу ни шедулер а чисто юридическую вещь что мы берем два момента времени и сраавниваем разные команды выполняются или одна и таже. если одна и таже
значит эта команда blocks исполннеие программы.
так вот ключ WNOHUNG дает что что наш waitpid "превращается " в checkpid. тоесть еще раз по дефолту
без ключа WNOHUNG waitpid будет ждать до бесконечности (остановив дальнейшее продвижение по коду
программы) до того момента пока очередной чайлд несдохнет. а ключ WNOHUNG дает то что waitpid
неждет он проверяет если есть сдохший чайлд то он счиает с него код возврата а если нет то он неждет а просто сразу возврашается обратно и программа продолжает исполгняться дальше.
вторйо параметр NULL это в какую переменую сохранять код возврата. если NULL то никуда нам пофиг
на код возврата.

далее надо проврерить какой код возврата в случае ключа WNOHUNG кода у нас вобще нет
чилдренов и когадда у нас еть чилдрен но он еще жив. и еще случай когда есть два чилдрена
один из них умер а второй жив.

первый кэкспримент.
нет чайлдов

int status;
waitpid(-1,&status,WNOHANG);
printf("waitpid return code=%d\n", status );

резульата:
waitpid return code=32767

где 32767 это pid самого процесса. что за треш.

далее. есть один чайлд но он жив
waitpid return code=1875472032
что за бред?

аааа!!! status это не код возврата самой функции это код завршения работы чайлда. нам это ненадо.
у нас либо нет чайлда либо он еще незавершал. нам нужно аналзизиовать код врвзрата сайомой функции!!



пределелал
pid_t ret_c;
ret_c = waitpid(-1,NULL,WNOHANG);
printf("waitpid return code=%d\n", ret_c );

резултат когда нет чайлдво вобще:
waitpid return code=-1

когда один чайод и он еще жив:
waitpid return code=0


когда один умер а второй еще жив:
waitpid return code=6244
где 6244 pid того который сдох.

тепрь тогда понятен этот код

static void reapChild(int sig) {
    while (1) {
       pid_t pid = waitpid(-1, NULL, WNOHANG);
       if (pid < 0) break;
       NumChildrenExit++;
    }
}

если у нас однорвременно сдохла куча чайлдов то приелтает первый SIGCHLD
мы ызывает хендлер. он ищет есть ли сдохщий процесс. есть. делает он это неижидая. 
вычищает его. далее он еще раз делает проерку есть ли сдохщий. есть и так до поледнего 
сдохшего. как только сдохшие заонкчились мы получим код возарата -1 и тогда тут же выйдем 
из хендлера. если на момент работы хендлера еще ктото сдохнет то мы его тоже вычистим непотеряв.
а что было бы если бы неблыо флага WNOHANG. было бы вот что.. у нас два чайлда. один сдох
синал SIGCHLD прилетел и был вызыван хендлер. он вычистил первого мгновенно потом 
цикл отработал еще и он будетвечно ждать пока отратботает второй. поэтому все компопнеты кода
абсолютно неободимы!

понятно. на данны момент оатетс открыты вопрос о одновременном прлете сигналов в процесс.
теряютсяне ретяются. задерживаются или что. прилет сигнала когда хендлер работает. 
тоже как там и что.
рассмотрим. берем программу

$ cat 41.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

 void vasya(int sig){
      printf("i am inside the handler\n");
      sleep (10);
       };


int main(void)
{
signal(SIGINT, vasya);

printf("parent: parentpid=%d\n", getpid());
pid_t pid_c;



while(1)
{
sleep(10);
}

return 0;
}


очень простая программа. регистрируем кастомный хендлер для SIGINT
далее в теле программы крутится бесконечный цикл.

хендлер очень простой как только мы в него попадаем то он об этом пишет на
экране и далее этот хендлер засыпаает на 10с.
к чему это приводит: мы тыкать на клаве Ctrl+C много много раз сразу например 7 раз.(можно вместо тыканья Ctrl+C много раз послать kill -2 pid). тоесть мы посылаем в наш процесс один за одним сразу много сигналов SIGINT. что происходит дальше - как показала практика как только прилетел первый сигнал 
то срабатывает хендлер. на экране мы видим  

i am inside the handler

далее ничего непроисходит. тоесть второй и третий сигнал ничего недают - действие хендлера непрерывается новыми сигналами. 
он успешно отрабатывает свой код и засыпает на 10с. мы при этом ничего неделаем вот как нажали послали вначале программы 7 сигналов и сидим ждем. итак мы уже увидели что в хендлер прилетает
только первый сигнал. второй третий итд они блокируются в том плане что они уже непрерывают
хеендлер от первого сигнала. итак хендлер если начал работать то он уже непрерывается работает
до конца. окей итак хендлер нерперрывается сигналами которые после. это мы выяснили. 
вопрос следущий - что стало с тем сигналами что были посланы второй третий четвертный итд.
вот мы в хендлере  а что будет когда он закончит свою работу и выйдет - то есть что стало с сигналами которые второй третий четвертый. они пропали или что. практика показала что 
ядро сохраняет ровно один сигнал из тех что прилетели к процессу когда он уже был в хендлере.
таким образом если мы начали тыкать Ctrl+C скажем 7 раз подряд то первый сигнал вызывает хендлер.
второй держится во внутренней очереди пока хендлер незакончит. как толлько хендлер вышел то процессу
доставляется второй сигнал и он обрабатывается хендлером. остальные сигналы из семи (третий четвертый пятый шестой седьмой) они теряются. таким образом я бы суммарно описал так. вот прилетел
у нас сигнал в процесс. срабатывает хендлер. в это время летят еще сигналы - это неприводит ни к чему  втом плане что работабщей хенддер непрерывается. сигналы которые прилеетли в процесс во время
того как работал хендлер  они все теряются кроме одного , тоесть хоть пятьдесят сигналов пошли 
во время работы хендлера сохраняется и удерживается гдето там внутри  только один. и когда хендлер
выйдет закончив работу то процессу будет доставлен один сигнал из тех что были нарпавлены во время 
того как выполнялся хендлер. таким образом в целом есть проблема что из тех сигналов что прилетят к процессу ( имеется ввиду сигналов тех же самыхтоесть sigINT в нашем случае) во время выполнения
хендлера они все потеряются кроме одного. он будет сохранен и доставлен процессу как только хендлер
закончит свою работу. поэтому чем длинее хендлер тем больше вероятность потерять часть сигналов.

тут я щас покажу с каким параметрами устанавливался хендлер для SIGINT как показывает strace
rt_sigaction(SIGINT, {sa_handler=0x5610fbac176a, sa_mask=[INT], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7f2e44c78040}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0

а вот как выглядит работа на практике на экране

$  ./41.exe
parent: parentpid=19649
^Ci am inside the handler
^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^Ci am inside the handler

видно что янажал ^C и тут же сработал хенделер и написал i am inside the handler
я при этом продолжад нажимать ^C вот их куча на экране но больше ничего непроизошло.
далее я сидел и ждал . прошло 10 секунд. и на экране появилась еще одна надпись i am inside the handler и далее уже ничего непроисходило. то есть из той кучи ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C
которую я пронажимал была обработана только один. остальные пропали вникуда.  я специально
вставил в хенлере паузу 10с чтобы он отрабатывал долго чтобы четко отловить поведение системы
относиельно сигналов на момент работы хенлера  в том плне будет ли он прерван новым выполеннием
хендлера и скоьк сигналов сохранит система на момент когда хендлер вернется.



есть еще вопрос а что если во время выполнения хендлера прилетит сигнал но неатакой же адругой.
будет ли прерван этот хендлер ради выполнения нового хенлера от нового сигнала. например у нас прилеел SIGINT заупустился его хендел тут прилете еще один SIGINT это мы уже знаем что этот 
сигнал неперерывает наш хендлер а после этого еще поилеие сигнал SIGTERM так вот в на этот сигнал 
поскольк уон друогого рода будет ли прерван хендлер обаработки SIGINT или нет?

-1 -1 -1 -2 -2 -2 
-1 -1 -2 -2

i am inside the handler SIGHUP       -x -1  -2 -2 
 i am inside the handler SIGINT      -x -1  -x -2 
 i exit from the handler SIGINT      
 i am inside the handler SIGINT      -x -1  -x -x 
 i exit from the handler SIGINT 
i exit from the handler SIGHUP       

i am inside the handler SIGHUP       -x -x  -x -x 
i exit from the handler SIGHUP 


-1 -2 -1 -2 -1 -2

i am inside the handler SIGHUP 
i am inside the handler SIGINT 
i exit from the handler SIGINT 
i am inside the handler SIGINT 
i exit from the handler SIGINT 
i exit from the handler SIGHUP 
i am inside the handler SIGHUP 
i exit from the handler SIGHUP 

-1:| -2 -1 -2 -1 -2

-1: -2:| -1 -2 -1 -2

-1: -2: (-1) -2:| -1 {-2}

-1: -2: -1:| -2: {-1} {-2}

(-1) -1   (-2) -2 


вбиваем
-1 -2 -2 -2 -1 -1 -2 -1 -2 -1 -2 -2 -1 -1 -2 = -1 -1  -2 -2 =>

предсказание
-1 
-2
-2
-1


практика
i am inside the handler SIGHUP 
 i am inside the handler SIGINT 
 i exit from the handler SIGINT 

 i am inside the handler SIGINT 
 i exit from the handler SIGINT 
i exit from the handler SIGHUP 

i am inside the handler SIGHUP 
i exit from the handler SIGHUP


еще один эксперимент. добавляемт третий сигнал.
вот как выглядит програма при этом

$ cat 41.c
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/wait.h>

 void vasya(int sig){
      printf("  i am inside the handler SIGINT(-2+) \n");
       sleep (30);
      printf("  i exit from the handler SIGINT(-2-) \n");

       };


 void petya(int sig){
      printf("i am inside the handler SIGHUP(-1+) \n");
       sleep (30);
      printf("i exit from the handler SIGHUP(-1-) \n");

       };


 void kolya(int sig){
      printf("   i am inside the handler SIGUSR1(-10+) \n");
       sleep (30);
      printf("   i exit from the handler SIGUSR1(-10-) \n");

       };






int main(void)
{
//Register signal handler through the signal() function
signal(SIGINT,  vasya);
signal(SIGHUP,  petya);
signal(SIGUSR1, kolya);

printf("parent: parentpid=%d\n", getpid());

pid_t pid_c;



while(1)
{
//simulate a delay -- as if the program is doing some other stuff
sleep(10);
}

return 0;
}



наш исходный сигнал:
sigs=( -10 -1 -10 -1 -2 -10 -10 -1 -2 -10 -10 -2 -1 -2 -10 -2 -1 -10 -10 -1 -2 -1 -2 -10);
-10 -1 -10 -1 -2 -10 -10 -1 -2 -10 -10 -2 -1 -2 -10 -2 -1 -10 -10 -1 -2 -1 -2 -10
= урезаем -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -1  -1  -1  -1 -1  -1 -1 -2 -2 -2 -2 -2 -2 -2 
= еще урезаем = -10 -10 -1  -1  -2 -2 = как в итоге будет -10 -1 -2 -2 -1 -10 

практика:

запускаем тест
$ sigs=( -10 -1 -10 -1 -2 -10 -10 -1 -2 -10 -10 -2 -1 -2 -10 -2 -1 -10 -10 -1 -2 -1 -2 -10);
$ pid=24562; for i in ${sigs[@]}; do echo "kill $i $pid"; kill $i $pid; sleep 1; done
тут важно что между командами kill выдерживамем паузу 1с.
(поскольку пауза в хендлеах 30с то важно отметить что все сигналы успевают быть отосланными
за время работы первого хенделера это тоже важно тоесть к тому моенту как первй хендлер закончить работать все сигналы уже буут в системе)

результтат:
   i am inside the handler SIGUSR1(-10+) 
i am inside the handler SIGHUP(-1+) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
i exit from the handler SIGHUP(-1-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 
   i exit from the handler SIGUSR1(-10-) 
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 



тоесть 10, 1, 2, 2, 1, 10. полностьб совпало с ресчтеами.

теперт запускаем тот же самый тест но без паузы 1с между команадми. тоесть все килы
они валятся мгновенно друг за другом.

$ sigs=( -10 -1 -10 -1 -2 -10 -10 -1 -2 -10 -10 -2 -1 -2 -10 -2 -1 -10 -10 -1 -2 -1 -2 -10);
$ pid=24562; for i in ${sigs[@]}; do echo "kill $i $pid"; kill $i $pid; done

резултат:
   i am inside the handler SIGUSR1(-10+) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
   i exit from the handler SIGUSR1(-10-) 
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 



тоест 10, 2, 2, 10, 1, 1

запустил еще раз тот же самый тест
pid=24562; for i in ${sigs[@]}; do echo "kill $i $pid"; kill $i $pid; done

рещуалттат уже друной!
i am inside the handler SIGHUP(-1+) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
i exit from the handler SIGHUP(-1-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 


запускаю еще раз тоже саый тест. при этом даже убираею команду echo чтобы
килы летели еще быстрее
pid=24562; for i in ${sigs[@]}; do kill $i $pid; done 


резултата:
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 


еще раз запуска этот же тест 
pid=24562; for i in ${sigs[@]}; do kill $i $pid; done 

   i am inside the handler SIGUSR1(-10+) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
  i exit from the handler SIGINT(-2-) 
) 
   i exit from the handler SIGUSR1(-10-) 
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 


выводы. последние два тесат вобще были одинаковые а рездултата разный. третий с конца
почти такйо же как два последние. и видно что три посоедний резульатат олитчиаются.
мой общий вывод такйо: если мы кидаем огронмую кучу килов сразу быстро за раз то ядро 
подсоывает их процессу я бы сказал да  в рандомном порядке как это укзаано в man но при этом
я бы еще казал что все же ядро старается их так посдоывать чтобы небыло разрыва хенделеров.вот этого нет в ман. если же сигналы прилетают быстро но не мгновенно как это было в случае когда мы
их кидали с разницей в 1с то тогда подсосываются ядром в том порялке в котором их послали. 
наверное бы в общем случае я для пргамирования я бы исходилиз тоого что сигналы  будут доствалены
процессу в рандомном порядлке. 


далее делаю еще один эскеримент
$ pid=24562; for i in ${sigs[@]}; do kill $i $pid; done 
$ pid=24562; for i in ${sigs[@]}; do kill $i $pid; done 
$ pid=24562; for i in ${sigs[@]}; do kill $i $pid; done 

тоесть посылаю сразу  в три раза болльше сигналов.
цель : доказать что макмимальная длина очереди в группе всегда не более 2 сигнала.
тоесть 1 обрабаыватется и 1 в pending состяониив очереди ссои в независииомсоти от того
скольк ттам в куче прпилетело сигналов.

резульат:
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 
   i am inside the handler SIGUSR1(-10+) 
   i exit from the handler SIGUSR1(-10-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
  i am inside the handler SIGINT(-2+) 
  i exit from the handler SIGINT(-2-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 
i am inside the handler SIGHUP(-1+) 
i exit from the handler SIGHUP(-1-) 


доказали. видно что каждойго сигнаа всего два штуки. несмотря на нашу огромную тучу исходных 
посланных сигналов.
?????????????????????????????????????
вывод такой. берем общую очередь , разделяем на группы - здесь было три группы: -10, -1, -2
далее в кажой группе оставляем максимум два элемента тоесть:

первая группы было : -10 -10 -10 -10 -10 -10 -10 -10 -10 -10
стало: -10 -10
вторая группы было: -1  -1  -1  -1 -1  -1 -1 
стало: -1 -1
треятья группы было: -2 -2 -2 -2 -2 -2 -2
стало: -2 -2 

итоговая группа: -10 -10 -1 -1 -2 -2 
далее ее перемешиваем рандомно кроме первого элемента он остается и вот в таком порядке
ядро собачит сигналы процессу. напрмер:

-10 -1 -10 -2 -1 -2

далее правило такое: запускается хендлер. далее берем следущий сигнал и смотрим он такой же 
по номеру или нет. если нет то текущий хендлер прерывается и запускается следущий. 
и идем дальше по спику если такой хендлер уже запущен то пропускаем а если нет то прерываем 
текущий хендлер изапускаем следущий. итак до конца . получамм:




из эксериментов у меня сложилось пока ткое впечателение:
если сигналы прилетают друг от друга реально рядышком пактом то ядро пытается сгурппировать 
сигналы по группам и совать их в порядке таком: вначале два из одной группы потом два из другой
групы и потом два из третьей грцппы , чтобы видимо неразывать хендлры изнутри.
например мы пустили 10 1 2 10 1 2 2 10 1 2  тогда ядро пусти сигналы 
как так 10 10 2 2 1 1. чтобы небыло разрыва внути хендлера.
а если сигналы прилетают друг т друга с зедержкой то тогда уже ядро ничего неделает
и происходит разрыв. единсвтенное что полюому неболее двух сигналов в группе. остальные 
просто отбарсываются. <=== закогчил тут





тут я прервался и прерквлюичился на тему цпу интерраптс:
книга- Pentium® Processor Family
Developer’s Manual
Volume 3:
Architecture and Programming Manual

стр. 3-32:
The processor has two mechanisms for interrupting program execution:
1. Exceptions are synchronous events which are responses of the processor to certain
conditions detected during the execution of an instruction.
2. Interrupts are asynchronous events typically triggered by external devices needing
attention.
Interrupts and exceptions are alike in that both cause the processor to temporarily suspend the
program being run in order to run a program of higher priority. The major distinction
between these two kinds of interrupts is their origin. An exception is always reproducible by
re-executing the program which caused the exception, while an interrupt can have a complex,
timing-dependent relationship with programs.

сhapter 14:
Exceptions and interrupts are forced transfers of execution to a task or a procedure. The task
or procedure is called a handler.
Interrupts occur at random times during the execution of a
program, in response to signals from hardware. Exceptions occur when instructions are
executed which provoke exceptions. Usually, the servicing of interrupts and exceptions is
performed in a manner transparent to application programs. Interrupts are used to handle
events external to the processor, such as requests to service peripheral devices. Exceptions
handle conditions detected by the processor in the course of executing instructions, such as
division by zero

There are two sources for interrupts and two sources for exceptions:
1. Interrupts
 Maskable interrupts, which are received on the CPU's INTR input pin. Maskable
interrupts do not occur unless the interrupt-enable flag (IF) is set.
 Nonmaskable interrupts, which are received on the NMI (Non-Maskable Interrupt)
input of the processor. The processor does not provide a mechanism to prevent
nonmaskable interrupts.
2. Exceptions
 Processor-detected exceptions. These are further classified as faults, traps, and
aborts.
 Programmed exceptions. The INTO, INT 3, INT n, and BOUND instructions may
trigger exceptions. These instructions often are called "software interrupts," but the
processor handles them as exceptions.
This chapter explains the features of the processor which control and respond to interrupts.

номер интеррапта \ эксепшена назвыается vector.
The vectors for maskable interrupts are determined by hardware. External interrupt
controllers (such as Intel's 8259A Programmable Interrupt Controller) put the vector on the
processor's bus during its interrupt-acknowledge cycle. 

Faults—A fault is an exception which is reported at the instruction boundary prior to the
instruction in which the exception was detected. The fault is reported with the machine
restored to a state which permits the instruction to be restarted. The return address for the
fault handler points to the instruction which generated the fault, rather than the instruction
following the faulting instruction.

Traps—A trap is an exception which is reported at the instruction boundary immediately
after the instruction in which the exception was detected. ('сюда как раз инструцция int n входит)

Aborts—An abort is an exception which does not always report the location of the instruction
causing the exception and does not allow restart of the program which caused the exception.
Aborts are used to report severe errors, such as hardware errors and inconsistent or illegal
values in system tables. тут говорится о том что обработчик аборта невсегда может указать 
на какой команде произошла жопа и не всегда можно продолжить выполнеие далее. ибо аборт случается в случае тяжелых повреждений железа видимо.

тут вопрос заключется в том что непонятен смысл слов синхронный vs асинхронный. 
как я понял в это вкладывется дурацкий смысл - синхронный значит что ошибку можно повторить еси заупстит программу повторно то она на том же месте на тойже команде сгеннерирует предасказуемо
ту же ошрбку а асинхронный означает что грубоговоря время возниконовние ошибки непредтказуеом(ибо 
это происходит на внешнему устройстве).бредятина. также непонятно когда происходит переход на исоплнение  хенддера - до дермьмовой команды или после или когда? ( а начал я это изучать по прчиичине слов синхронный асинхронный signal . оттуда я суюда пришел!)

еще раз начал читать про цпу интеррапты из за темы signals и фразы syncronoous\asyncronous
хочу понять что это значит. а сигналы я начал читать с темы одновременного прихода несоклких
сигналов в процесс. и комндды waitpid (-1,null,WNOHUNG) зачем его сунули в хендлер? !!!
вот откуда я сюда пришел!



так пока оставим тогда цпу интеррапты. нафик а то перегруз головы.
====
вопрос по функциям в C
функция имеет параметры которые она принимает когда ее вызывают.
сответсвтенно парамктры которые ей передали надо где то хранить.
скажем 

void vasya( int a){

int b;
b=a;
	
};

вот переменные которые обьявляюися внутри функции они же временные 
на период выполеннеия функции а потом они исчезнут когда она выфдет.
так вот где  в памяти брать место под эти переменые? ответ. компилятор для этого 
созает так код что коогда фгукция вызывается то ссылки в памяти под эти переменные идет в
 стек. я так понимаю .  ну например. берется что b= ссылка на стек+10. а a=сылка на стек+11.
 а когда мы выходим из стека то эти переменные либо pop все либо меняется ссылка не вершину стека.

 поэтому пременные в фнукции они все локальные. видны только ей когадда она выполняется. 
 когда она выходит они все типа сичезают. и память освбодждается.

далее при таком виде обьявлени функции

void vasya( int a){
}

int main (){
	
	int c;
	c =1;
	vasya (c);

}

при такой шарманке кооагда мы ывзаем фугнкуию из тела прогарммы то из переенной c копиртется значение (единица в данномс лучае) в локальную для фнукии переенную a. тоеть передача параметра
поисходит через копировагние. в чем тут жопа. в том что если мы в функцию передаем некую большую 
стрктуру например масив то коироваоть его запорешься. плюс если мы хотим обратно получить 
измненное значение то нужно както его обратно копироват. мутор.

есть другой выход когда в функиую для парамтера передается незначение методом коирования 
а ссылку адрес поинтер на перменую в главном теле программы.
пример

void vasya( int *a){

*a++;

}

int main (){
	
	int c;
	c =1;
	vasya (&c);

}

тогда насколкоо я понимаю  в функциб при запуске уже некопируется занчение и в функции несоздается
локальная перменная а работа идет как раз с переменнйо из главного тела. что очено удобно.
копировать ненадо и сразу есть обратная связь.


вот пример. по поводу что если  в функцию передвать перменую по имени то коируется
ее содержимое в функцию а исходная перменная в main теле неменяется даже если в функции перенная
меняется. и если передаь в функцию ссылку тоесть поинтер то имзеннеие поинтера в функции мпняет
эту же перемену и в main теле


$ cat 45.c
#include <stdio.h>
#include <stdlib.h>

void vasya (int x, int *z){

// increase and print var x
    x++;
    printf("func: x=%d\n", x);

    //increase and print *z
    (*z)++;
    (*z)++;
    printf("func vasya: *z=%d\n", *z);


};

int main(){

// определяем переменные

  int a;
  void *a_Ptr;
  a = 1;
  a_Ptr = &a;
// печааем здест фишка в том что поинтер типа void хрен напечатаешь без преобразования его во чтото. 
// в данном случае в int
  printf("main: a=%d, *a_Ptr=%d\n",  a,  *(int*)a_Ptr  );



  int *b_Ptr;
 *b_Ptr = 2;
// печатаем
  printf("main: b_Ptr=%d\n",  *b_Ptr  );



// вызывем фукнкцию которая меняет переменные. одну переменную передавем через копирование а вторую через поинтер.
  vasya(a, b_Ptr);

// печатаем все переменые еще раз смотрим изменилиь ли они после функции
   puts("main: print variables after function call:");
   printf("main: a=%d, *a_Ptr=%d\n",  a,  *(int*)a_Ptr  );
   printf("main: b_Ptr=%d\n",  *b_Ptr  );


return(0);
};


вывод на экран:
$ ./45.exe
main: a=1, *a_Ptr=1
main: b_Ptr=2
func: x=2
func vasya: *z=4
main: print variables after function call:
main: a=1, *a_Ptr=1
main: b_Ptr=4



=====

pointers in c 

программа

$ cat 45.c
#include <stdio.h>
#include <stdlib.h>

void vasya (int a, int *c){

    puts("I am inside the function");
    printf("a=%d\n", a);

};

int main(){

  int ma;
  void *mb;
  int *mc;

  ma = 1;
  mb = &ma;
  mc = &ma;

  puts ("i am inside the main before calling the function");
  printf("ma=%d, mc=%d, mb=%d\n",  ma,  *mc, *(int*)mb );

  vasya(ma, mc);


return(0);
};


вопрос вызывает вот этот кусок *(int*)mb
как его понимать. 
====
segmentation fault 
что это как? откуда беертся?
====
C
типы данных.

size_t = зависит от архиектуры цпу. у x64 это 64 бита. 
	обычно ее юзают когда юзают индекс в массиве. нужна переменная такого типа которая точно
	в себе вместит все индексы элемента массива. эта переменная получается portable.

====
pointers in c
casting
void pointer
*(int *)var
вообще типы данных особенно те хитрые которые типа позоляют
программу делать переносимой. 

почемуто в C целые числа которые integer они зовут как integral.
вобщем это все целые числа и булевые и char. их там разные подвиды целая куча.
со знаком без знака, длинные короткие. так что если видишь integral types 
то знай что это целые. вобще в C есть три типа данных - целые, с плавающей точкой и void.
так что можно понять методом исключения кто такие integral types.

вообще же стадарт прописан в ISO C99.
=====
как устроена адресация памяти в линуксе
====
переменные посмотреть они выровнены по четным байтам? а выровнены ли они по 64битам?
а как же читаь и писать из нечетных байтов?

Efficient approach: Since Hexadecimal numbers contain digits from 0 to 15, therefore we can simply check if the last digit is either '0', '2', '4', '6', '8', 'A'(=10), 'C'(=12) or 'E'(=14). If it is, then the given HexaDecimal number will be Even, else Odd.Ap

====
вот часто пишут на счет выровненного стека например. но прикол то в том что программа
пишет в виртуальное адресное простанство - мы понятия неимеем в четный или нечетный адрес сконвертирует MMU наш виртуальный адрес. о каком тогда выравнивании может идти речь?
====
POSIX VS API VS C VS LIBC VS GLIBC VS C API?
is website an api?
UNIX VS POSIX?
POSIX pdf читать
posix это subset of unix стандарта, но в каком аспекте это сабсет?

An API is a menu fronting a black box of software services that you (or someone else) has created for others to use. To use an API, you don't need to know what goes on inside the black box. Typically an API will publish information about what it does, what input it needs, and what output it provides.

You can use a programming language to create an API.

An API is a platform that allows different pieces of software, or applications, to communicate with one another
====
проверить как работает доступ к нечетным ячейка ram.
как можно судить что доступ идет к нечетнм ячейкам если програ обращается к вируальным
адресам и при этом хрен знает какие она вызывает физ адреса.
проверить переменные по нечетным адресам бывают? если нет то проверить они по 64бит
выровенны?
===

sockets

непойму разницу между файлом сокетом на диске и файлом сокетом в /proc/pid/fd

пример

есть докер демон.

# ps aux | grep docker
root      2176  0.0  0.0 2018340 14240 ?       Ssl  мая13   6:51 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock


у него в /var/run есть типа файл сокет

# ls -1al /run | grep docker
srw-rw----  1 root  docker       0 мая 13 03:29 docker.sock

# file  /run/docker.sock
/run/docker.sock: socket

тоесть это файл сокет.

а еще в /proc/pid/fd есть типа ссылка на сокеты какието. ну понято что proc это отображение
данных в ядре о процессе тоесть идея такая что мы гдето в юзерспейсе на диске создаем 
файл сокет к которому могту другие процессы  конектится для IPC а потом в proc/pid/fd об этом сокете появится какая то заметка. но хотелоь бы както уметь находтся связь между заметкой в proc про сокет и этим файлом на диске в userpace.
так вот

 в /proc/pid/fd много сокетов. но как понять который из них вдет к /run/docker.sock

 также непонятно как найти все сокеты на диск в юзерспесе для процесса.

хотя есть lsof

# lsof -p 2176

вот что видно для docker.sock

     FD      TYPE             DEVICE      SIZE/OFF       NODE   NAME
     9u      unix    0xffff8b87177fd000   0t0            30618  /var/run/docker.sock type=STREAM


итак тип файла это unix socket

так а вот другие записи у этого процесса с типом unix

TYPE NAME 
unix type=STREAM 
unix type=STREAM 
unix /var/run/docker/metrics.sock type=STREAM
unix @00019 type=DGRAM
unix type=DGRAM 
unix /var/run/docker.sock type=STREAM
unix type=STREAM 
unix type=STREAM 
unix /var/run/docker/libnetwork/1725ca0371d4.sock type=STREAM
unix /var/run/docker.sock type=STREAM
unix /var/run/docker.sock type=STREAM

так вот видно что невсе сокеты имеют на диске приземление. что за прикол? как тогда
имим пользоватся процессам в юзерспейсе ? (разобраться)

===
top

суммарные графики ядрам берет из /proc/stat?
или как то руками высчттывает. сомневаюсь.
думаю из /proc/stat берет

там указана статистка именно для цпу как сущностей.
а в /proc/pid/ указана стаикстикта для процессов как сущностей

===
linux-gemeral 
статья по terminal и process
пока остановился на ioctl. 
хочу понять как баш его подкручивает при старте.
для начала хочу понять как расечатать все termios struct члены.


открылась огромная тема линукс терминал драйвер.
в книжке libc это глава 17. - Low level terminal
также man termios
потмоу что термиал в линукс это непросто черное окно. это целый железный девайс 
который реализоован в ядре в форме кода виртуальаного устройства. а так это целый желеный
девайс со всякими настройками


выдержки из posix.pdf:
при открытии файла есть флаг  O_NONBLOCK 
который дает то что файл могут после этого однровремнно открыать и другие (одновременное чтение)

controlling terminal ?

session -   A collection of process groups established for job control purposes.Поэтому в одной 
			сессии может быть несколько процесс групп.
			Each process group is a member of a session. A process is considered to be a member of the session of which its process group is a member.
			получается схема такая процесс входит в группу а группа входит в сессию
			
			процесс --->  process group -----> session

			A newly created process joins the session of its creator. A process can alter
			its session membership; see setsid( ).


process group? session ? захера все это ?
а есть еще process group leader. wow?

Terminal (or Terminal Device)
A character special file that obeys the specifications of the general terminal interface.
заметим что терминал и терминал деваайс это у посикс одно и тоже.

Controlling Terminal
A terminal that is associated with a session. Each session may have at most one controlling
terminal associated with it, and a controlling terminal is associated with exactly one session.
Certain input sequences from the controlling terminal cause signals to be sent to all processes in
the foreground process group associated with the controlling terminal. == ? непонятно

про сесссии:
When a user logs out of a system, the kernel needs to terminate all the processes the user had running (otherwise, users would leave a slew of old processes sitting around waiting for input that can never arrive). To simplify this task, processes are organized into sets of sessions. 
The session's ID is the same as the pid of the process that created the session through the setsid() system call. 

сессия всегда имеет номер который равен номеру процесса который был первым у котоорого была 
эта сессия.

есть session leader = ?

A process group is a collection of related processes which can all be signalled at once.

A session is a collection of process groups, which are either attached to a single terminal device (known as the controlling terminal) or not attached to any terminal.


STAT   PID TT        SESS  PGRP COMMAND
Ss   28783 pts/37   28783 28783 bash
S    28841 pts/37   28783 28841 bash
R+   28877 pts/37   28783 28877 ps a -o stat,pid,tty,session,pgrp,command
S+   28878 pts/37   28783 28877 grep --color=auto -E PID|pts/37

согласно posix у сессии может быть максимум один терминал. а у терминала максимум одна сессия.
у сессии может и небыть терминала. тоесть либо ноль терминалов либо один. процессов 
без сессий небывает.

послнный сигнал процессу в группе будет послан всем процессам в группе. походу 
это смысл иметь группу. проверим?

(что такое субшелл в баш его смысл?)

а смысл сессии?

bash subshell  = что это на уровне процессов и захера он нужен?
$ ps -A  -o stat,user,pid,tty,session,pgrp,command | (sed -u 1q; grep pts/38)
STAT USER       PID TT        SESS  PGRP COMMAND
Ss   vasya    30060 pts/38   30060 30060 bash
S+   vasya    30118 pts/38   30060 30118 sleep 180
S+   vasya    30119 pts/38   30060 30118 bash
S+   vasya    30120 pts/38   30060 30118 sleep 180
S+   vasya    30121 pts/38   30060 30118 sleep 180


кстати про баш. вот мы запустили в баше программу ./31.exe

(окно1)$ ./31.exe

а потом с другого окна послали этой программе сигнал $ kill -19(SIGSTOP) pid(31.exe)
что тогда у нас произоудет в окне терминала? а произойдет то что  у нас управление вернется
в наш баш со строкой:


(окно1)[1]+  Stopped                 ./31.exe
(окно1)$

как это получается? коггда мы запускаем из под баш 31.exe то процесс баш форкает себя. получается исходный процесс с баш и дочерний.  в дочернем 
процессе запускается 31.exe и он работает. а парент процесс в это время в состоянии sleep до момента когда чайлд выйдет ( делается через вызов wait в парент процессе). далее когда мы в в чайлд 31.exe шлем сигнал -19 то во первых ядро его стопит а во вторых ядро шел паренту ( который баш) сигнал SIGCHLD о том что состояние чайлда изменилось ну а башу даже и слать этот сигнал ненадо потому что он уже сидит в сисколле wait() так что баш выходит из состояния S из сисколла wait и его двигается в цпу дальше ну а с точки зрения пользователя мы возврашаемся в баш.
яхочу этим подчернуть что надпись 

[1]+  Stopped                 ./31.exe

появяется исключительно потому что парент процессом был баш. он  принял сигнал SIGCHLD обраотал 
его и он баш вывел на экран эту надпись а не ядро. значит еще раз подчеркну что 
в этом случае сочетание процесов было такое:

bash(parent) -> 31.exe  (child)

щас рсмотрим случай когда парентом у 31.exe явяелсяте не баш а xterm.
поскольку у xterm нетакой обработчик на сигнал SIGCHLD то в случае остановки 31.exe через сигнал SIGSTOP мы получим от xterm другое поведение.

вот имеем
$ pstree -Asp 1588
systemd(1)---systemd(1718)---xterm(1587)---31-1.exe(1588))

тоесть 
xterm(парент)---31-1.exe(чайлд)

$ kill -19 1588

и в окне xterm никакого сообщения. ничего непроисходит. именно потому что в xterm другой
обработчик сгнала SIGCHLD

я запустил strace я вообще невижу чтобы xterm принимал сигналы SIGCHLD такое оущщенеи
что он их просто поставил флаг игнориить.

вот как принимает баш SIGCHLD
[pid  1851] <... wait4 resumed> [{WIFSTOPPED(s) && WSTOPSIG(s) == SIGSTOP}], WSTOPPED|WCONTINUED, NULL) = 1892

[pid  1851] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_STOPPED, si_pid=1892, si_uid=1000, si_status=SIGSTOP, si_utime=0, si_stime=0} ---

[pid  1851] wait4(-1, 0x7ffc66f4e690, WNOHANG|WSTOPPED|WCONTINUED, NULL) = 0

вот видно что его wait4 он ждал событий WNOHANG|WSTOPPED|WCONTINUED

и как резултат он выводит на экран строку 
[pid  1851] write(2, "\n", 1)           = 1
[pid  1851] write(2, "[1]+  Stopped                 ./"..., 41) = 41

а уже после этого к башу прилетает SIGCHLD
[pid  1851] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_STOPPED, si_pid=1892, si_uid=1000, si_status=SIGSTOP, si_utime=0, si_stime=0} ---

сраабатывает хендлер баша

[pid  1851] wait4(-1, 0x7ffc66f4e690, WNOHANG|WSTOPPED|WCONTINUED, NULL) = 0

но обрабатывать ему нечего. что видно по коду возврата 0.

и код баша начинает продолжать дальше свою обычную работу - выывод на экран приглашения
и ожидание нажатия кнопок:

[pid  1851] write(2, "\33]0;vasya@vasya-Lenovo-IdeaPad-L"..., 116) = 116
[pid  1851] pselect6(1, [0], NULL, NULL, NULL, {[], 8}


я еще раз проверил в xterm вобще сигнал sigchld неприлетает. видимо он ставить 
флаг его игнорировать.
если баш запускает чайлда и далее ждет через wait
то xterm запускает чайлда и далее сидит в сисколле :
poll([{fd=3, events=POLLIN}, {fd=4, events=POLLIN|POLLPRI|POLLRDNORM|POLLRDBAND}], 2, 0) = 0 (Timeout)
select(6, [3 4 5], [], NULL, NULL


вобще как то так выглядит запуск 31.exe через xterm

$ strace -e clone,fork,execve  xterm -e /home/vasya/C/31-1.exe 

execve("/usr/bin/xterm", ["xterm", "-e", "/home/vasya/C/31-1.exe"], 0x7ffdd8f191b0 /* 70 vars */) = 0

clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f340685a390) = 2349

где 2349 это pid процесса 31-1.exe

мы невидим execve потому что он происходит в pid=2349 а strace у нас следит за сисколлами
в процессе xterm. тоесть в процессе xterm просходит вызов clone() поэтому мы его и видим
а далее уже execve происхдоит в дочернем процессе который strace нетрейсит поэтому мы его невидим.

так я понял почему strace нетрейсил чайлд процесс. для этого нужно было добавит ключ -f
итак пробуем:

$ strace -f -e clone,fork,execve  xterm -e /home/vasya/C/31-1.exe
трейс в паренте(в xterm):
execve("/usr/bin/xterm", ["xterm", "-e", "/home/vasya/C/31-1.exe"], 0x7ffee2dbf5a8 /* 74 vars */) = 0
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb24e323390) = 3922
(трейс в чайлде в 31-1.exe)
strace: Process 3922 attached
[pid  3922] execve("/home/vasya/C/31-1.exe", ["/home/vasya/C/31-1.exe"], 0x5631c787bed0 /* 78 vars */) = 0

теперь все как в книжке. в паренте вызываем clone() а в чайлде вызываем execve()


вот как выглядит запуск 31.exe через bash

clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fb8a8c78490) = 2578
[pid  2578] execve("./31-1.exe", ["./31-1.exe"], 0x564c5b653510 /* 71 vars */) = 0


тут чото неравнозначно я протрейсил.

еще такой момент.
увидел что когда мы жмем на кнопку "x" крестика на окне то для процесса который работает внутри 
этого окна это выглядит так что со стороны юзера прилетел сигнал SIGHUP. ну а дефолтовое действие
у ядра на SIGHUP это убить процесс. мы щас еще раз проверим что нажатие на крестик вызывает 
посыл SIGHUP путем того что установим кастомный хендлер для sighup.

имеет терминал и в нем bash с pid=4158

а вот как на практике выглядит нажатие на крестик если внутри рабоатет bash

--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=3866, si_uid=1000} ---
--- SIGCONT {si_signo=SIGCONT, si_code=SI_KERNEL} ---

очень странно. почему то получается так что наше нажатие крестика с одной сторонвы вызывет
посыл к башу SIGHUP у которого четко видно что заказчик сиганал юзер si_uid=1000 под которым мы сидим также виден четко и процесс который послал SIGHUP это 3866. а что это за процесс?

а это:
vasya     3866  0.4  0.5 999488 83152 ?        Ssl  мая13 131:03 /usr/lib/gnome-terminal/gnome-terminal-server

ну окей. но второе непонятно. то что автоматом также уже от ядра летит SIGCONT.

дальше уже сам баш посылает сигнал на свое уничтожение

kill(4158, SIGHUP) 

и тутже его принимает
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=4158, si_uid=1000} ---

видно что заказчик сигнала si_pid=4158 сам наш процесс bash


потом баш еще раз повторяет свою попытку сам себя грохнуть

kill(4158, SIGHUP)                      = 0
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=4158, si_uid=1000} ---

и наконец у него это удается
+++ killed by SIGHUP +++

вот так интересно происходит окончание работы баш еси нажать на крестик в окне gnome-terminal

щас попробуем тоже самое когда баш раобтет в окне xterm:
bash имеет pid=4409

вот деерево процессов

$ pstree -Asp 4409
systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(3665)---xterm(4408)---bash(4409)


итак тыкаем значок крестика на окне xterm
трейсим внутри баш процесса
$ sudo strace -f -p 4409

--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=4408, si_uid=1000} ---
видим что процесс xterm (4409) послал башу SIGHUP сигнал.

далее видно что как я понимаю начинает отрабатвыает кастом хендле баша на SUGHUP

rt_sigaction(SIGHUP, {sa_handler=0x5570f66ced30, sa_mask=[HUP INT ILL TRAP ABRT BUS FPE USR1 SEGV USR2 PIPE ALRM TERM XCPU XFSZ VTALRM SYS], sa_flags=SA_RESTORER, sa_restorer=0x7f0574d45040}, {sa_handler=0x5570f671fe80, sa_mask=[], sa_flags=SA_RESTORER, sa_restorer=0x7f0574d45040}, 8) = 0

и видимо в этом хендлере уже сам баш начинает себя убивать

kill(4409, SIGHUP)                      = 0
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=4409, si_uid=1000} ---

почемуто оно с первого раза оно несрабатыает 
и баш второй раз заказыаем себя убивать сам и наконец срабаывает

kill(4409, SIGHUP)                      = 0
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=4409, si_uid=1000} ---
+++ killed by SIGHUP +++

видно что у баша есть свой кастом хендлер на сигнал SIGHUP.
также стало понято что когда у нас окно терминала обесечивалось через gnome-terminal то нажатие на крестик вызывает както там сигнал в гном-терминал а он уже направляет SIGHUP баш процессу.
а когда у нас окно темринала обеспечивается через xterm то нажатие на краетик идет к xterm (пока незнаю через что через какой сигнал) а он уже посываелт SIGHUP башу. 

итак закончил на том что запускаю bash в gnome-term и в xterm.
жму крестик. смотрю что прилетает при этом в bash и в xterm\gnome-terminal
всняю а как сделать невомзожным чтобы кретик отарабываел. один способу же занаю надо 
остановить процесс внутри терминала. тогда крест наживать бесполезено.
1)возможно. возмонжго если мы запреитим к нам SUGHUP то окно хрен закроешь. щас поробуем.
2)также надо выяснить а что за сигнал прилетает к gnome-terminal и к xterm при нажати крестика 
потому что оименно они первополучатели событие нажатия крестик.

хммм..
почмуто xterm имеет другой pts чем его дети

$ pstree -Asp  5268
systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(3665)---xterm(5229)---bash(5230)---bash(5240)---bash(5248)---bash(5268)

$ ps -A -o pid,ppid,pgrp,sess,tty,stat,time,cmd  | grep  -E "PID|5268|5248|5240|5230|5229" | grep -vE "chrom|grep"
  PID  PPID  PGRP  SESS TT       STAT     TIME CMD
 5229  3665  5229  3665 pts/71   S+   00:00:00 xterm -e bash
 5230  5229  5230  5230 pts/62   Ss   00:00:00 bash
 5240  5230  5240  5230 pts/62   S    00:00:00 bash
 5248  5240  5248  5230 pts/62   S    00:00:00 bash
 5268  5248  5268  5230 pts/62   S+   00:00:00 bash


хотя походу я понял. pts/62 это для окна графическоого который выдает xterm.
а pts/71 это то окно в котором баш из которого был запущен xterm.
я проверил так и есть..
хм.. надо еще об этом подумать и осознать

значит мы щас потрейсим соазу двух зайцев 5229 xterm и 5268 bash во время нажатия крестика
значит смотрим xterm что у него прорисходит

 унего куча таких сисколлов

 recvmsg(3, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base="\t\0037\2\30\0\300\7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", iov_len=4096}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 32

 они значат. xnj это сисколл чтобы получать сообщеия с сокета.детали пока непонятны и небудем пока углубялться. но я это вижу  я так понимаю что через сокет к процессу поступает инфо о том 
 что нажали крестик.
 далее он получает сообщение что один из чайлдов(5230) сдох

 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_KILLED, si_pid=5230, si_uid=1000, si_status=SIGHUP, si_utime=3, si_stime=0} ---

при этом странно что я неуивдел сообщеия от других чайлдов. хотя это логично - когда у нас одновременно сдыхает куча чайлдов то ядро пошлет в процесс только 1 максимум 2 сигнала об этом.
остаьные прропадут.

далее он направляет сигнал грохнуть почемуто не тот баш который прям был его чайлд
а хер знает какой баш там внизу (надо будет еще раз это проверить)

kill(-5230, SIGHUP) 

и вот как xterm заканчивает работу свою. как я понял просто он вызывает сисколл exit_group


exit_group(0)                           = ?
+++ exited with 0 +++

при этом что странно что этот сисколл он для процессов у которых несколько тредов запущено 
и вот мол мы таким макаром заставим выйти все треды. 
так вот это странно потому что вообщето xterm он однотредовый. вот пруф

$ ls -1al /proc/32173/task/
dr-xr-xr-x 7 vasya vasya 0 июн  2 02:01 32173

$ ps -L -p 32173
  PID   LWP TTY          TIME CMD
32173 32173 pts/50   00:00:00 xterm


ну ладно что с texrm примерно понятно.


что с баш присходит
он получает sighup
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=5248, si_uid=1000} ---

pid=5248 это баш который его родитель. 

и почемуто в этот раз баш по другому обрабатывает SIGHUP чем как мы это видел в случае 
когда был только xterm+bash а щас у нас xerm+bash+bash+bash итп

setpgid(0, 7453)                        = 0
exit_group(0)                           = ?
+++ exited with 0 +++

почемуто он выходит через сисколл exit_group.

надо все таки разбоаться для чего этот exit_group что он делает.

ну в любом случае общая канва понятна. щелкаем на крестик - далее  процесс который обслуживает 
графическое окно получает через сокет сообщение. далее он посылает kill ребенку или детям
они вырубаются через хендлер сигнала и далее головной процесс просто делает сисколл exit того
или иного рода.


вылезла полезняшка. в strace флаг -v который позволяет видеть всю строку ioctl целиком 
а не обрезанную.

также я знаю что если у bash ест дети то на него сигнал kill -15 недействует.

как факт есть то что если у нас есть окно xterm и в нем заупщен баш и он застоплен то крестик
недает закрыть окно. как я понимаю дело в том что xterm закроет окно только если убедиться что 
все процессы в его окне вышли. иначе нет.

интеренсвйый вышел фокус.

заупстил я баш в xterm
далее в окне xterm я выянсняю pid баша

$ echo $$

далее в этомже окне я стоплю баш

$ kill -19 $$

что происходит он стопит баш. но при этом нажатие кнопок на экране работает.

далее дургйо эксепримент. гном-терминал. баш. запукаем

$ echo $$
3423
$ sleep 300

в другом окне вначале стопим баш
$ kill -19 3423
потом sleep
$ kill -19 $(pidof sleep)

в итоге у нас буквы все равно работают нажатие на экране. тоесть только когда у нас
вот прям командная строка баша то если его застопить то на экране буквы непечатаются.
это значит что именно прям баш меняет настройки терминала. в первом приближеннии баш отключает
local echo, тогда система работает так что чтобы буква напечаталась это надо чтобы баш принял
через /dev/pts/ символ и баш сам кидает этот символ обратно в fd/1 на стаданртный вывод а тот в 
dev/pts и тогда терминал его рисует. почему еще я так думаю потому что если застопить баш , нажимать кнопки а потом остоить бащ то на экране буде куча кнопок. тоесть кнопки принимались 
и сидели в ядре в буфере. а как баш проснулся то он их считал и вывел.  я проверил. 
потом я еще как сделал - я застопил баш а потом в друом окне запустил считывание с pts файла.
а потом переешел в окно баш и начал жать кнопки и они вылезли на том втором окне. а птом я отжал
баш и их небыло. так что я думаю что баш вот чтоделает когда он стартует:
1) он отключает local echo. это значит что термиал(ядро) принимает нажатие кнопок но на экране непечатает и ядро шлет их в /pts/56 баш их считывет и потом баш их обратно шлет  в pts/56 и они наконец появляются на экране. 
2) баш делает так  в терминале настроку чтобы терминал слал побуквенно . тоесть если буква появилась то терминал сразу ее шлет. а по дефолту в терминале другая натсройка такая что терминал шлет только когда enter нажали.

вот что я думаю по поводу загадок с баш.

// еще вопросы:
0) вызов функции что с стэком? они один для всей юзер программы . читал что для кажой функции 
свой стек. что за бред.
2)поинтеры и воид 
3)баш джобс ctrl+z
4)программа открывает X окно
5)ping сисколлы сетевой сокет
6)dev vs socket
7)syscall\int 80 время на переключение (по идее цикл должен круто поднять si% таймер в top
	если это нетак разобраться за что %si отвечает)
8)wa time для D state vfork
9) 
	-(надоо попробовать запустт программу в терминале.  и в ее коде закрыть
		дескрпиоры 0,1,2 можно ли это сделать?)

 	- надо щас посмотреьт могу ли я писать из кода в /dev/tty1 напрямую или нужно делать открытие
 			файла?обязательно? 

	- вопрос - а можно ли закрыть из кода программы все три файловые дескриптора?  и таким образом
		программу зааущенную из терминала отрезат от термиала.


8) ответ
походу пьесы с точки зрения nmon ест всего 4 состояния цпу = User%  Sys% Wait%  Idle%
 с точки зрения top их больше =   us,  sy,  ni, id,  wa,   hi,  si,   st
надо проитать а что procfs /proc/stat показвыает. ведь все оттуда считыается? так?
вот полезная стаья = https://blog.pregos.info/wp-content/uploads/2010/09/iowait.txt
 
как я понял наступает таймер интеррапт. появляется шедулер на цпу и он смотрит (незнаю как)
цпу только что что делал? - если в юзер спейсе работал он рибавляет us counter если в ring0
то sy counter а если он выполнял idle тред то тут шедулер еще внимательнее пристаривается
и проверяет есть ли в текущий момент i\o операция (где? и как он это проверяет?) если есть то прибавляет wa counter. во время выского wa цпу свободен для вполнпения других программ.
непонятно захера смотреть idle+io. один процесс можетждать io 100% от таймслайса а вторая
на 100% грузить цпу. wa будет маленький а пофакту система дохера тормозит из за диска.
непонял я пока так ли вычитывается wa ? или он может 100% при условии 100% цпу загрузки диска однврерменно? тоже это неясно.

man proc ( раздел /proc/stat)


еще есть hardware interrupt time ( кстати его счетчик может быть выклюен) = https://tanelpoder.com/posts/linux-hiding-interrupt-cpu-usage/

по идее если есть high i\o то должен быть болльшой hi% time. так ?
может ли быть high io без высокого hi тайма? незнаю

/proc/pid/io ?



также выснилось отсюда https://tanelpoder.com/posts/linux-hiding-interrupt-cpu-usage/ 
	что  

продлоллжение следует

2)поинтеры и воид поинтер. (пишем эту главу).
цепочка которая сюда привела.

поинтеры -> printf --> string\literal string -> const char * vs char * const -> разница 
в ассемблерном представлении простой переменной vs pointer --> fs регистр
еще надо рассмотреть в каком порядке многобайтовое число пишется в память


прежде всего зачем нужные поинтеры если у нас есть обычный способ создавать 
переменные.

я решил посмотреть в чем разница в асемблере меджу обьявлением простой переменной
и переменной типа поинтер :


увтвержается что локальная переменная в функции в том числе и в main() сохраняется
в стек. проверим. кстати ответ на вопрос а почему локальные перменные сохраняются в стек
а не например в heap. дело в том что сохранние в heap происходит в миллиард раз дольше.
потому что: сохранение  в стек выполняетя парой ассемблерных команд. условно говоря переменная 
сохраняется одной командой типа

mov    BYTE PTR [ebp-0x1],0x1

и все. это очень быстро.
а вот чтобы в heap сохранить нужно вначале вызват сисколл malloc() который там прогонит типа тонну 
кода чтобы выделить в физ памяти некий кусок нами запрошенный под переменную. тоесть это заведомо
гораздо более долгая процедура (проверить на практике). поэтому компилятор сует переменнные 
в стек. это очень просто и очень быстро. вот почему перменные хранятся в стеке.
пишут что макс размер для одного треда юзер программы 8МБ 

(как проверить?) : 
$ $ ulimit -s
8192

это означает 8МБ.
если программа превысит этот размер то стек начнет налезать на область памяти там где вроде как
код хранится программы с командами. и тогда линукс ядро вызовет SEGFAULT сигнал в процесс (все это надо проверить)

 (как узнать текущий
размер стека у процесса?) :

$ cat /proc/16455/maps | grep stack
7ffe90c08000-7ffe90c29000 rw-p 00000000 00:00 0                          [stack]

$ a=$(echo "7ffe90c08000-7ffe90c29000" | awk '{print toupper($0) }'); echo "obase=10;ibase=16; ($a)/400" | bc
-132

итого 132КБ занимает стек у баша.

malloc() это сисколл который позволяет запросить у ядра память из heap.

The only downside of stack allocation is you MUST release your stack space before you can return from your function.  This means long-lived data structures, like a user info class used for the rest of the program, need to be allocated on the heap with malloc. Это обьясняет почему в функциях может быть malloc. чтобы сохранились данные котороые надо сохранить потому что все что без malloc
будет потеряно при выходе из функции (кроме поинтеров которые были переданы в параметрах функции)

как выглядит программма и ассемблер когда мы обяьвяляем переменную классичекиим
способом:

$ cat 51.c
#include<stdlib.h>
#include<stdio.h>


int main(){


// обьявляем переменные

char d = 1;

return(0);
};


компилируем в 32bit версию машинны кодов(это важно потому что 64битной версии все будет подругому):

$ gcc -m32 -o 51.exe 51.c
дизасмбьируем и смотрим
$ objdump -d ./51.exe -M intel

000004ed <main>:
 4ed:	55                   	push   ebp
 4ee:	89 e5                	mov    ebp,esp
 4f0:	83 ec 10             	sub    esp,0x10
 4f3:	e8 10 00 00 00       	call   508 <__x86.get_pc_thunk.ax>
 4f8:	05 e4 1a 00 00       	add    eax,0x1ae4
 4fd:	c6 45 ff 01          	mov    BYTE PTR [ebp-0x1],0x1
 501:	b8 00 00 00 00       	mov    eax,0x0
 506:	c9                   	leave  
 507:	c3                   	ret 


00000508 <__x86.get_pc_thunk.ax>:
 508:	8b 04 24             	mov    eax,DWORD PTR [esp]
 50b:	c3                   	ret    
 50c:	66 90                	xchg   ax,ax
 50e:	66 90                	xchg   ax,ax


по факту мы сохарняем указатель стека esp в ebp
потому мы сдвигаем стек (esp) на 16 байт наверх (почему на 16?)
ebp у нас прии этом сохранил ссылку на старый указатель стека. и через вот эту команду

mov    BYTE PTR [ebp-0x1],0x1

мы сохарняем переменую в стеке.
все более менее понятно.

а вот эта строка

mov    eax,0x0

это код возврата из функции.

что вызывает шок что для 64битной версии машиных кодов тот же самый 51.c текст 
дает нечто совсем другое:

$ gcc -m64 -o 51.exe 51.c

00000000000005fa <main>:
 5fa:	55                   	push   rbp
 5fb:	48 89 e5             	mov    rbp,rsp
 5fe:	c6 45 ff 01          	mov    BYTE PTR [rbp-0x1],0x1
 602:	b8 00 00 00 00       	mov    eax,0x0
 607:	5d                   	pop    rbp
 608:	c3                   	ret    
 609:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]

что меня шокирует это то что неменяется указатель на esp.
как так? 

оказывется дело в red zone. (рассказать о ней).
если сказать компилятору чтобы он забил хер на эту красную зону ( флаг -mno-red-zone )
$ gcc -g -m64 -mno-red-zone -o 51.exe 51.c

то код уже выглядит как положено:

00000000000005fa <main>:
 5fa:	55                   	push   rbp
 5fb:	48 89 e5             	mov    rbp,rsp
 5fe:	48 83 ec 10          	sub    rsp,0x10
 602:	c6 45 ff 01          	mov    BYTE PTR [rbp-0x1],0x1
 606:	b8 00 00 00 00       	mov    eax,0x0
 60b:	c9                   	leave  
 60c:	c3                   	ret    

а именно наконец появилась команда

sub    rsp,0x10

тоесть мы двигаем верхушку стека вверх на 16 байт.
а потому внутри стека через mov копируем переменную.
====>
что такое red zone:
они пишут что это некое соглашение софтверное из ABI 64bit о том что:
если есть функция и у нее есть RSP ссылка на стек то можно считать что 128 байт
над стеком тоже принадлежат этой функции. поэтому пока функция работает туда 
можно без проблем пихать данные. пэтому компиляото и недвигал rsp.  а зачем?
если и так мол это область данных для функции. но у меня вопрос . а что если наши 
переменые начнут занимать более чем 128 байт(проверить) то что потом будет с RSP?
компилятор его сдвинет на 128 байт сразу? а что если мы в впрограмме использует встроенный
ассемблер и push\pop ? ведь тогда первый же пуш влезет в эту область и потрет что там есть.(проверить). также когда происходит cpu interrupt то то цпу кладет в стек EIP+FLAGS
автоматом и получается что они тоже потрут данные в области 128 байт. 
поэтому я непонимаю как можно пользоваться этой зоной.(все првериить через практику)
вся эта залупа с красной зоной была задумана тлоько для того чтобы сэкономить всего одну команду в коде sub    rsp,0x10 это  звездец.

прикольно как устроена работа с данными в стеке  в случае gcc и переменных. я привык что работа со стэкаом это push pop. а тут по другому.
изменяется руками RSP.  а далее  обращение к данным идеет через

mov[rbp+смщение], значение_переменной.

тоесть стек используется как хранилище. но команды стека функциона неиспользуется. это как
автомобиль использовать как склад.  или как автомобиль двигать лошадями.

остановил процесс (SIGSTOP) 31891.(chrome pdf обработчик)

===> закончил тут на красной зоне. прорабатвыаю эту секцию (смотри стрелку наверху)
The red zone is the 128 bytes just below rsp, i.e. rsp - 128 to rsp - 1.




есть три проблемы
float * a_Ptr - обьявление переменной
*a_Ptr - обращение к переменной на которую ссылается поинтер
b_Ptr = (int*) a_Ptr - переделка поинтера одного типа в поинтер другого типа
a_Ptr = &a - запись адреса в сам поинтер

все эти вопросы конфьюзные. причина конфьюза в знаке * который морочит голову. 


- ПЕРЕДЕЛАТЬ ЭТУ ГЛАВУ!!!!!! 
ха! напоролся на очеердной вопрос.
	 про printf. 
	 написано в man 3 printf что: 
	int printf(const char*  format, ...);

	и тут очень важно понять значение строки 

	const char*  format;

	format - это имя переменной. понятно идем дальше,

	и давайте сразу поговорим в чем разница между

	const char *
	char * const

	WARNING!!! все что ниже почти верно но есть важный момент который  я нашел!

	int i = 1;
	int const * i_Ptr = &i;
	i++;

	pointer на constant int. означает что изменять int на который указывает поинтер нельзя
	через поинтер. но! это незапрщеает это делать через другие способы! это очень важный момент!
	другие обычно пишут что модификация ячейки наа котру ссылкается поитер запрешена. аэто лажа
	она запрешена только через поинтер. но разрешена через всякие другие способы!


	я напоролся на отличную обьяснялку: https://stackoverflow.com/questions/21476869/constant-pointer-vs-pointer-to-constant

		
	const char* - переводится как pointer to constant char. тоесть поинтер указывает
	на ячейку памяти у которой тип char и value которой нельзя менять. тоесть сам поинтер 
	можно менять а вот содержимое ячейку на которую ссылается поинтер менять нельзя. что это значит менять нельзя. это указание для компилятора. он поместит эту char хрень в ту область
	памяти которая защищена от записи. разрешено только чтение.

	пример программы которая выдаст ошибку
	 #include<stdio.h>

int main(void)
{
    int var1 = 0;
    const int* ptr = &var1;
    *ptr = 1;
    printf("%d\n", *ptr);

    return 0;
} 


	char *const -  оно переводится constant pointer to char. тоесть поинтер менять нельзя. и поинтер ссылается на char. содержимое char менять можно. 
	пример

	#include<stdio.h>

int main(void)
{
    int var1 = 0, var2 = 0;
    int *const ptr = &var1;
    ptr = &var2;
    printf("%d\n", *ptr);

    return 0;
} 

	также пишут что
	const char*
	и
	char const* 
	это одно и тоже

	еще есть
	const char * const - переводистя как constant pointer to constant char.тоесть и поинтер 
	менять нельзя и содержимое char на которую он указывает.

	еще нашел класную табличку
	int       *      mutable_pointer_to_mutable_int;
	int const *      mutable_pointer_to_constant_int;
	int       *const constant_pointer_to_mutable_int;
	int const *const constant_pointer_to_constant_int;



	mutable означает изменчивый.
	при такой записи удобно птому что все читается четко справа налево.

	тогда удобно верхний пример

	const char *
	char * const

	переписать как

	char const *      // mutable pointer to constant char
	char * const 	  // constant pointer to mutable char


	тогда спецификацию для printf  ябы переписал:

	int printf(const char*  format, ...); = int printf(char const *  format, ...);

 	читается mutable pointer to constant char.


	в любом тип данных это поинтер.

	окей разобрались. 

	дальше самый прикол. я определяю в программе поинтер который имеет ровно тот тип 
	который указан в спецификации printf тоесть  const char* 

	const char*      ff = "122\n";
	printf (ff);

	и при компиляции получаю 
	warning: format not a string literal and no format arguments [-Wformat-security]
 	printf (ff);
 	^~~~~~

 	тоесть как бутто я сую в printf чтото нетого формата!

 	тогда я делаю парадоксальный ход! я делаю поинтер другого типа нетот который указан в спецификации от printf

	char* const      ss = "hello\n";
	printf (ss);

	и теперь при компиляции нет никаких ошибок!

	но разве const char* одно итоже с   char* const
	на мой взгляд абсолютно нет!

а еще напоролося в книге на такое :
The keyword const doesn't turn a variable into a constant! A symbol with the const
qualifier merely means that the symbol cannot be used for assignment. This makes the value
re ad -onl y through that symbol; it does not prevent the value from being modified through
some other means internal (or even external) to the program. It is pretty much useful only
for qualifying a pointer parameter, to indicate that this function will not change the data that
argument points to, but other functions may. This is perhaps the most common use of
const in C and C++
и еще
As Ken Thompson pointed out, "The const keyword
only confuses library interfaces with the hope of catching some rare errors." In retrospect,
the const keyword would have been better named readonly



 warning: format not a string literal and no format arguments [-Wformat-security]
 printf (ff);

	причем ман пишет что The format string is a character string.
	что такое string в C - это :
	In C programming, a string is a sequence of characters terminated with a null character(null character это байт у котрого все биты нули. если посылать на печать этот символ то он непечаатется. также как у нас есть символ новой строки \n так же этот символ имеет спец обозначение \0 естественно никакой ноль непечаатется это его такое обозначение. ) . на практике string задается через "" двойные кавычки.

	"string"

	что важно - When the compiler encounters a sequence of characters enclosed in the double quotation marks, it appends a null character \0 at the end by default.
	тоесть мы поняли что в итоге в памяти такая строка будет хранится как s+t+r+i+n+g+\0
	это компилятор сделает автоматом.
	итак еще раз важные моменты 
	1) string обозначается чеерез двойные кавычки

	"vasya"

	2)в памяти стринги хранятся с добавленным в их конец символом \0. это байт у которого 
	все биты нули.(ascii 0)

	3) стринги являются константами. тоесть менять их содержимое нельзя.


	далее тонкий вопрос а как в тексте программы определяем эти string.
	мы же не пишем в тексте просто

	"vasya"

	нужно же какую то переменную опреелять или что.


	но если я в программе определеляю const char*  format и передаю его в printf то gcc 
	ругается

	const char *ss = "June 14";
	printf (ss);

	$ gcc ...

	 warning: format not a string literal and no format arguments [-Wformat-security]
	 printf (ss);

	 тоесть я передаю в printf то что он требует по формату но gcc чтото ненравится!



	Literal strings in C are bytes delimited with '\0' and found via their address. So When you pass "abc" to a function ,you are actually passing the address (a char * pointer) to the function as parameter.
	Arrays are internally treated as pointers



еще раз операция обьявление переменных и операция обращения к переменным это две разные 
операции и знак "*" там имеет соверщенно разное значение! (а не одинаковое!)



еще раз а  в случае обьявления перменной знак * неимеет никакого смысла самостоятельного.
он просто литера буква  в слове.

очень жалко что нельзя вот так писать в программе

(int*) a_Ptr;
*(a_Ptr);








//







интересный момент. если у нас процес в сосоянии STOP (T) то он не принимает ниакие сигналы кроме
-9 (kill) и -18(CONT).  тоесть если у процесса есть чайлд. мы застопили проесс  . потом чайлд сдох то парент для него шедулер назапускает хендлер пока процесс небудет SIGCONT. и чайлд будет висеть как зомби. тоесть при T даже хендлеры незапускаются у процесса.

продолэение сдледует

