книги по устройству ядра(которые у меня есть):
-  operating systems three easy pieces
- здесь два курса и несколько книг по устройству ос (https://www.cse.iitb.ac.in/~mythili/)


xv6:
- скачал книжку = /book-rev11.pdf (https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf)
- unix6.pdf = это коментарий к реальному эникс6 на pdp11 который влохновил написание xv6
	(https://cs3210.cc.gatech.edu/r/unix6.pdf) ("A COMMENTARY ON THE SIXTH EDITION 
	UNIX OPERATING SYSTEM" J. Lions.)
- мнжетсво учебного материала про xv6 = https://pdos.csail.mit.edu/6.828/2011/overview.html
---


еще более исходный вопрос - это чем деплоймент оличаетя от реплика сет и всего остального

исходный вопрос - кониейнер. pid1 чилдрены. родич умер. чилдрены остались.
чиолдрен умер. прилетел сигнал к pid1 , сигнал по деолфту игнорится. а в pid-1 нет касмного
хендлера. так это все или не так. и как куб в своих подах с этим борется ?

асинхронны сигнал что это ?
в плане сигналов надо разобрать случай когда приелетает от кучи детей сигнал sigchld
и мы их все ловим нетеряем

как работает вызов syscall на уровне цпу и ос

nasm+ld vs gcc  -> syscall 
_start vs _main
signals in linux (прочесь в файле c+assembler)
как это работает что у нас выполняется сисколл тоесть цпу работаетв привлигированном
режиме и его могут прервать через сигнал на выполнение хэндлера сигнала.или как там 
это работает ? как вобе можно прервыать сисиколл. ведь в это время цпу работае в режиме ядра
тоесть там нет никакого прцоесса. если процсс прерыать то его состояние можно срхранить
а как можно созранить состояние выполпние сисколла в режиме ядра? тамже нет процесса никакого !

====
вопросы на которых остановился:
linux:
 page tables. прочитать упрошенный вариант из book-rev11.pdf и unix6.pdf


дописать ответы на вопросы syscall, multitasking.


раздел multitasking
 щас я более подоробно смотрю на два вопроса nested interrupts 
 какой stack испльзуется
 при обработаке интеррапта? 
 tasklet vs hard irq vs softirq? что у них со стеком? 
вопрос нахрена нужен стек push\pop если есть movl ведь в итоге push\pop работает с той же
памятью
про контекст свичинг. есть понятие cpu context switching а есть linux process context switching
 а есть software context switching а есть cpu hardware context swithing.
 что такое intel tss 
 что такое и зачем stack alignment? и связанный  с ним вопрос - а что такое assmbly function? как это с abi связано? закончил на том что научился компилить и дизасмемблтть проги и в gdb смотреть
 и щас хочу понять как там что происходит при командах push\pop с указателем стека итп 

 



раздел syscall
-вызов через int 80 vs через syscall
- далее надо разобратсья так как же через какие регистры происходит адресация в 64 битном режиме
в протектед моде  в режиме ядра
-непонятно что такое process context. какие регистры входят и что еще.(также непонятно
вот мы сисколлом вызывали фнукция в ядре. цпу пеерключился в ринг0 что значит что код ядра
выполняется в контексте юзерского процесса). насколько я понимаю что когда цпу в режиме ядра
то то код ядра работает в виртуальном пространсте памяти как его видит процесс в юзерском режиме
плюс также ядерный код еще видит память которая ядру принадлежит. в общем здесь еще вопрос
в том что очеивдно что в режиме ядра этот код может быть прерван получается как это согласовать 
с шедулером. как это все шедулится? еще вопрос если процесс вызывал сисколл и цпу начал работать в режиме ядра то какой статус у процесса ?


еще вопрос:
посмотреть какие регистры сохраняются и как там с регистрами стека при входе в int80\syscall
что интересного открылось - мы немжем через gdb долезть до кернел функций. как только мы вызываем 
ядерный код через syscall\int80 то туда глубже провалится нельзя. gdb недает. он возврашется 
сразу с резултатом который дает сискол.. то есть gdb может дебагить только в юзер спейсе.



=====> 

вопрос: как работает tickless ядро , как оно без таймер интеррапт раотает ?

====

вопрос:

как работает clone+ execve?
парент через clone создает новый процесс . вопрос как после этого парент может влезть 
в новый процесси и запутитьв нем execve ?

вроде бы ответ вот какой. форк запускаетя в родиче а exec уже чайлде. поскольку чайлд это точная
копия родича значит в коде проги делается if (если я щас в чилдрене ) то взывать exec.
таким образом я бы сказал так это не родич лезет в чайод и выывает exec это сам чайл форкнутый 
сам вс ебе вызывает execve. вот и весь секрет.

===
а как дела если нескоько ядер?  как тогда срабаывает шедулер?
===

ответ на ворос из интернета:
Is the process scheduler "visible" at user space? 
No. Because scheduler is not a process.

Can I see it with ps? 
No because ps shows the list of processes.

Maybe is it one of the kernel threads?
If yes, how is it called?
No.

How can I "see" it?
Usually we have a habit to work with processes in linux as a smallest entity. As scheduler
is not a process you can not "see" it this way.

It doesn’t exist as a separate thread, or module, it’s implemented as a function

Ok, but how and where and in which way is this function run? Is there a way to track it and see it?
It works this way ( very simplified ):
There is a timer inside PC. From time to time it sends a signal (an interrupt) to cpu (via interrupt controller). An interrupt is the electrical signal that goes to cpu via its pin. 
When cpu gets this interrupt it stops what he is doing, saves some registers  and starts to run ISR(Interrupt service routine). An interrupt is the event inside pc that cpu must handle. It means cpu need some piece of code to make it. ISR is the code. Where does it come from? Operating system puts the code beforehand. CPU jumps to ISR ( to be specific "timer interrapt handler") and it invokes scheduler. Scheduler makes "context switch" that is: it evicts some processes from cpu and launches some other, that is it saves all the registers of cpu to memory  (and some other stuff) of one process and loads from memory saved registers state to registers. When it is done scheduler 
exits and the process starts to work for some time until new timer interrupt happens, new scheduler invocation happens.The current process will be evicted and new one will be launched. This is how multitasking works. Timer Interrupt happens 10ms. That is scheduler is invoked every 10ms.


The schema:

Timer Interrupt  --> ISR --> Scheduler  ---> A process switch

Well overall i cant suggest a method to "see " or "touch" scheduler. 

========================
bash
что получается когда мы в баше делаем

$ ./1.exe & 
как это работает на бекенде ?

======
loadaverage?
это среднее число процессов в runqueue(тоесть со статусом R) шедулера 
либо процессов которые имеют статус 'D' за 1\5\15 минут
==========
про runqueue кто определяет чтобы процесс был помеещен в runqueue.
ответ . по дефолту код всегда будет туда помещен. а вот чтобы его оттуда убрали
надо чтобы сисколл который должен вызывать шедулер должен попросить шедулер убрать его из 
runqueue. поэтому когда говорят что процесс runnable возниакает вопрос а как это линукс лпредедляет
что таск = runnable. как он узнает поотребоности процесса. ответ в том что по дефолту процесс
считватется runnable а вот чтобы он таким перестал быть над просить об этом шедулер через сисколл
а то вот пишут "когда процесс готов к исполнеию". а от чего это зависиит как лиунукс это понимает
обьяснения недают.
тоесть по дефолту любой процесс шедулер постоянно размещает в очереди на исполнение.
и только если специально просить шедулер то он будет оттуда задчу убирать. так что с тчоки зрения
динукса и шедулера программа по дефолту всегда готова к исполнению так что эта формулировака
дебилная. она может быть не готова если только обб этом специально просить шедуделер.
в общем форумилрорвака дебильная.
=======
если есть праень и чайлд и мы шлем килл -15 паренту . вопрос будет ли автоматом убит чайлд
или только парент?
частчно ответил на этот вопрос . но до конца нет уверенности. смотри "processes kill parent child"

======
программа

#define _GNU_SOURCE
#include<stdlib.h>
#include<unistd.h>
#include<stdio.h>
#include<sched.h> 


int variable, fd;

int do_something() {
   variable = 42;
    printf("The child: the variable = %d\n", variable);
   _exit(0);
}

int main(int argc, char *argv[]) {
   void **child_stack;
   char tempch;

   variable = 9;
   child_stack = (void **) malloc(16384);
   printf("The parent: the variable = %d\n", variable);

   clone(do_something, child_stack, CLONE_VM|CLONE_FILES, NULL);
   sleep(1);

   printf("The parent: the variable is =  %d\n", variable);
   return 0;
}



вылетает с segmentation fault 
при попытке в треде
printf("The child: the variable = %d\n", variable);
   _exit(0);

почему?
=======
D статус он вызывает  W статус в top/nmon
или что вызвыает W что это как это увидеть в procfs ?
мне непонятна откуда берется характирстика W !
======
неигнорируемый сигнал типа -9 может ли у него быть кастомный обработчик сигнала
или только ядерный дефолтовый хендлер
=====
Z процесс
гда на живой практике с нимис сталкиваются так чтобы они рождались 
из каких то практичекиз случаев а не лабораторных симуляциях ?

====






