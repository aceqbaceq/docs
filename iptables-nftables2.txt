| iptables
| nftables










                         4
                         +-----------------------
                         +                      +
                         +                      +
                         +                      +
                         +                      +   
                         +                      +
3                        +                       \                                         6
-------------------------+---------------------------------------------------------------------
                         +        \              \
                         +         \__2____________\_______________________________________________8
1                         +                                                                     7
-------------------------+----------------------------------------------------------------------



линия 1-7 это когда влет ядро происходит из свич порта а вылет из ядра 
идет на свич порт этого же свича


линия 3-6  это когда пакет влетел в ядро  из чистого l3 порта и вылетает в чистрый l3 порт

линия 3-2-8 эо когда пакет влетел в ядро чеиез читрый l3 порт а преднаначен он для любого 
портса свича хоть L3 хоить L2

линия 1-2-8 эо когда пакет влетел в ядро чеиез свич  порт а преднаначен он для 
l2 порта другого свича


линия 1-4 это когда влет в ядро идет через   свич порт а пакет предназчен для любого L3 портса
на хосте хоть чистог хоть счичевого   


линия 4-6 это когда пакет порождет локалным процессо а вылетате он на чистый l3 порт

короче это не все линпнии нао дописывать

===
линия 3-4 

есть лок сет карты wlp2s0=192.168.21.1    br0=172.16.10.1
если я их пингую из локлаьного процесса то  роутер десижн ненправит эти пакеты на эти карты
потому что это бы означало что эти пакеты будут выплюнуты  в сеть. вместо этого они будут 
направлены на LO

  $ ping -4 -c1 -I 172.16.10.1  192.168.21.1
PING 192.168.21.1 (192.168.21.1) from 172.16.10.1 : 56(84) bytes of data.
64 bytes from 192.168.21.1: icmp_seq=1 ttl=64 time=0.137 ms

фев 03 20:24:38 lenovo kernel: [NAT-OUTPUT icmp] IN= OUT=lo SRC=172.16.10.1 DST=192.168.21.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=54072 DF PROTO=ICMP TYPE=8 CODE=0 ID=141 SEQ=1 
фев 03 20:24:38 lenovo kernel: [FILTER-OUTPUT icmp] IN= OUT=lo SRC=172.16.10.1 DST=192.168.21.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=54072 DF PROTO=ICMP TYPE=8 CODE=0 ID=141 SEQ=1 
фев 03 20:24:38 lenovo kernel: [NAT-POSTROUTING icmp] IN= OUT=lo SRC=172.16.10.1 DST=192.168.21.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=54072 DF PROTO=ICMP TYPE=8 CODE=0 ID=141 SEQ=1 


$ ping -4 -c1 -I 127.0.0.1 172.16.10.1
PING 172.16.10.1 (172.16.10.1) from 127.0.0.1 : 56(84) bytes of data.
64 bytes from 172.16.10.1: icmp_seq=1 ttl=64 time=0.249 ms

фев 03 20:27:34 lenovo kernel: [NAT-OUTPUT icmp] IN= OUT=lo SRC=127.0.0.1 DST=172.16.10.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=50717 DF PROTO=ICMP TYPE=8 CODE=0 ID=142 SEQ=1 
фев 03 20:27:34 lenovo kernel: [FILTER-OUTPUT icmp] IN= OUT=lo SRC=127.0.0.1 DST=172.16.10.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=50717 DF PROTO=ICMP TYPE=8 CODE=0 ID=142 SEQ=1 
фев 03 20:27:34 lenovo kernel: [NAT-POSTROUTING icmp] IN= OUT=lo SRC=127.0.0.1 DST=172.16.10.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=50717 DF PROTO=ICMP TYPE=8 CODE=0 ID=142 SEQ=1 

если пакет порождлается сокетом тоесть летит из ядра то он будет завернут на LO  ане на 
сетевую карту

если же пакет из сокета(из ядра) предназначен за ту сторону карточки то тогда он будет
нарпавлен на нее 



$ ping -4 -c1 -I 172.16.10.1   192.168.21.138
здесь моя карта на компе wlp2s0 имеет 192.168.21.1 а мы хотим попасть за тем что  за ней сидит

фев 03 20:38:07 lenovo kernel: [NAT-OUTPUT icmp] IN= OUT=wlp2s0 SRC=172.16.10.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60900 DF PROTO=ICMP TYPE=8 CODE=0 ID=148 SEQ=1 
фев 03 20:38:07 lenovo kernel: [FILTER-OUTPUT icmp] IN= OUT=wlp2s0 SRC=172.16.10.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60900 DF PROTO=ICMP TYPE=8 CODE=0 ID=148 SEQ=1 
фев 03 20:38:07 lenovo kernel: [NAT-POSTROUTING icmp] IN= OUT=wlp2s0 SRC=172.16.10.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=60900 DF PROTO=ICMP TYPE=8 CODE=0 ID=148 SEQ=1 

в этмо случае ядро реально сует пакет в сет карту OUT=wlp2s0 . совать пакет в сет карту есть
смысл ели мы хооитим попасть куда то ЗА НЕЙ. а если мы хотим попасть на нее изнутри ядра то 
для этого ядру ненужно совать пакет на нее. 

ключ -I у пинга имеет два дейвстия. если я укажу IP   -I 172.16.10.1  то это дает значение 
SRC_IP

а если я в -I ставлю имя сет карты то это каи то образом влияет на то в какую карту ядро будет
выплелывать пакет

$ ping -4 -c1 -I wlp2s0   192.168.21.138
здест 192.168.21.138 лежит за wlp2s0 пэому все срабоатет


фев 03 20:41:29 lenovo kernel: [NAT-OUTPUT icmp] IN= OUT=wlp2s0 SRC=192.168.21.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=48918 DF PROTO=ICMP TYPE=8 CODE=0 ID=150 SEQ=1 
фев 03 20:41:29 lenovo kernel: [FILTER-OUTPUT icmp] IN= OUT=wlp2s0 SRC=192.168.21.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=48918 DF PROTO=ICMP TYPE=8 CODE=0 ID=150 SEQ=1 
фев 03 20:41:29 lenovo kernel: [NAT-POSTROUTING icmp] IN= OUT=wlp2s0 SRC=192.168.21.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=48918 DF PROTO=ICMP TYPE=8 CODE=0 ID=150 SEQ=1 



$ ping -4 -c1 -I br0   192.168.21.138
PING 192.168.21.138 (192.168.21.138) from 172

фев 03 20:41:41 lenovo kernel: [NAT-OUTPUT icmp] IN= OUT=br0 SRC=172.16.10.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=801 DF PROTO=ICMP TYPE=8 CODE=0 ID=151 SEQ=1 
фев 03 20:41:41 lenovo kernel: [FILTER-OUTPUT icmp] IN= OUT=br0 SRC=172.16.10.1 DST=192.168.21.138 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=801 DF PROTO=ICMP TYPE=8 CODE=0 ID=151 SEQ=1 

а вот здесь видно что пакет был сроутен на  OUT=br0  но за ним никаокго 192.168.21.138 нет
поэтому дальше ничего не произошоло.  

удивиетно другое - каким макаром пинг заставляет ядро принимать решение о маршуотиазации не 
на оснвое таблица маршуотиацзиии а на основе нашей настройки!

оказывается это работает через 

      setsockopt(SO_BINDTODEVICE,)


 SO_BINDTODEVICE
              Bind  this socket to a particular device like “eth0”, as specified in the passed interface name.  If the name is an empty
              string or the option length is zero, the socket device binding is removed.  The passed option is a variable-length  null-
              terminated  interface  name string with the maximum size of IFNAMSIZ.  If a socket is bound to an interface, only packets
              received from that particular interface are processed by the socket.  Note that this works only for  some  socket  types,
              particularly AF_INET sockets.  It is not supported for packet sockets (use normal bind(2) there).

              Before  Linux  3.8,  this socket option could be set, but could not retrieved with getsockopt(2).  Since Linux 3.8, it is
              readable.  The optlen argument should contain the buffer size available to receive the device name and is recommended  to
              be IFNAMSIZ bytes.  The real device name length is reported back in the optlen argument.



$ strace -e socket,connect,bind,setsockopt  ping -4 -c1 -I wlp2s0   192.168.21.1 2>&1 
socket(AF_INET, SOCK_DGRAM, IPPROTO_IP) = 4
setsockopt(4, SOL_SOCKET, SO_BINDTODEVICE, "wlp2s0\0", 7) = 0
connect(4, {sa_family=AF_INET, sin_port=htons(1025), sin_addr=inet_addr("192.168.21.1")}, 16) = 0

чрез этот сокет монжно и отправтлять и принимать icmp
но в реальности  команда пинг созадает два сокета( я просто второй убрал из
лтиснга). ИИ скзаал что два сокета потому что якобы второй сокет который RAW он позволяет 
юзер приложению читая из этого сокета получать от ядра детальную информацию об  ошибках
если они случислись  с ицмп пакетом.

вот полный трейс

$ 
 \ 깅  $ strace -e socket,connect,bind,setsockopt  ping -4 -c1 -I wlp2s0   192.168.21.1 2>&1 
socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP) = 3
socket(AF_INET, SOCK_DGRAM, IPPROTO_IP) = 4
setsockopt(4, SOL_SOCKET, SO_BINDTODEVICE, "wlp2s0\0", 7) = 0
setsockopt(3, SOL_SOCKET, SO_BINDTODEVICE, "wlp2s0\0", 7) = 0
connect(4, {sa_family=AF_INET, sin_port=htons(1025), sin_addr=inet_addr("192.168.21.1")}, 16) = 0
socket(AF_NETLINK, SOCK_RAW|SOCK_CLOEXEC, NETLINK_ROUTE) = 5
bind(5, {sa_family=AF_NETLINK, nl_pid=0, nl_groups=00000000}, 12) = 0
setsockopt(3, SOL_IP, IP_RECVERR, [1], 4) = 0
setsockopt(3, SOL_IP, IP_RECVTTL, [1], 4) = 0
setsockopt(3, SOL_IP, IP_RETOPTS, [1], 4) = 0
setsockopt(3, SOL_SOCKET, SO_SNDBUF, [324], 4) = 0
setsockopt(3, SOL_SOCKET, SO_RCVBUF, [65536], 4) = 0
PING 192.168.21.1 (192.168.21.1) from 192.168.21.1 wlp2s0: 56(84) bytes of data.
setsockopt(3, SOL_SOCKET, SO_TIMESTAMP_OLD, [1], 4) = 0
setsockopt(3, SOL_SOCKET, SO_SNDTIMEO_OLD, "\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) = 0
setsockopt(3, SOL_SOCKET, SO_RCVTIMEO_OLD, "\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16) = 0
64 bytes from 192.168.21.1: icmp_seq=1 ttl=64 time=0.236 ms


важна вот эта опция IP_RECVERR  это опция именно raw сокета и она дает еще раз то что
ядро будет в сокет пихать детальную инфо об ошибках если они случислись. об этом флаге 
читай в man 7 raw и man 7 ip.
вот зачем нужно два сокета. 


возвращаюсь к  SO_BINDTODEVICE он  работает но не всегда.
вот у меня 192.168.21. сидит на wlp2s0 и если я буду пиноовать 192.168.21.1 
то как я уже сказал выше ядро сунет пакет  в lo
если я попруою насильно сунуть пакет в wlp2s0 через  SO_BINDTODEVICE то ядро настройку
эту выставиит но пакет все равно сунет в LO !

$ strace -e socket,connect,bind,setsockopt  ping -4 -c1 -I wlp2s0   192.168.21.1 2>&1 | grep SO_BINDTODEVICE
setsockopt(4, SOL_SOCKET, SO_BINDTODEVICE, "wlp2s0\0", 7) = 0
setsockopt(3, SOL_SOCKET, SO_BINDTODEVICE, "wlp2s0\0", 7) = 0



фев 03 21:33:46 lenovo kernel: [NAT-OUTPUT icmp] IN= OUT=lo SRC=192.168.21.1 DST=192.168.21.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=64701 DF PROTO=ICMP TYPE=8 CODE=0 ID=159 SEQ=1 
фев 03 21:33:46 lenovo kernel: [FILTER-OUTPUT icmp] IN= OUT=lo SRC=192.168.21.1 DST=192.168.21.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=64701 DF PROTO=ICMP TYPE=8 CODE=0 ID=159 SEQ=1 


такто!

тем не менее в основным случаях если  я пишу -I 192.168.10.1 то это делает то что
мы задаем какой ssrc_ip будет у пакета. а если я пишу -I br0 то это задает через  в какой 
интерйфейс этот пакет будет сунут.
в целом эта настройка  -I 192.168.10.1 имеет  полезный смысл. а вторая по мне вобщемто нет
потому что решение в какой интфрейс пихать пакет (это и есть решение о роутинге) должно 
идти на оснве таблицы мрашуттиацзиии!!

забавно то что мы не можем в пинг задать что мы щлем пакет  якобы с какогто 
инетрфейса! мы шлем его с сокета! у нас IN= всегда будет пустой! мы мжем менять толко 
src_ip адрес. забано вто что внутри ядра  пакет может иметь src_ip и для этого соерешнно 
ненужно прилетать с какойто карты! у нас пакет вылетет из сокета! вот его точка рождления. 
а не сетевая карта. 

забавно то что когда мышлем пакет из проиожения в локальое приложение то ядро его не 
шлет по такой схеме


приодение-А сокет ------> сокет приложения-Б


он шлет вот так

приодение-А сокет ------> lo -----> сокет приложения-Б



заано еще и точто прилоение может быть прибиндено к какйто сет карте на компе типа wlp2s0 
но если я с одного лок приложение шлю в другое локальное то путь не выглдяит вот так

приодение-А сокет ------> wlp2s0 -----> сокет приложения-Б

он выглядит вот так

приодение-А сокет ------> lo -----> сокет приложения-Б

тоетс как ббутто у нас приложение- забиндено на IP от lo. но это же нетак!

вот прмиер. wlpp2s0 ip =192.168.21.1

$ ping -4 -c1 -I 172.16.10.1   192.168.21.1

я пинуюу 192.168.21.1 тоесть приложение которое привязано к wlp2s0  в данном сулчае приожения
на той сторне нет. вместо него ядро. тем нем енее

фев 03 21:45:18 lenovo kernel: [NAT-OUTPUT icmp] IN= OUT=lo SRC=172.16.10.1 DST=192.168.21.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=53417 DF PROTO=ICMP TYPE=8 CODE=0 ID=160 SEQ=1 

тем не менее мы видим OUT=lo а не OUT=wlp2s0

а вот если я пингану внешний хост тоесть


   приложение-А сокет ------> 8.8.8.8

то увжу вот такое в обратном трафике

[FILTER-INPUT icmp] IN=wlp2s0 OUT= MAC=80:30:49:b2:85:cf:06:7f:c6:b9:18:cd:08:00 SRC=8.8.8.8 DST=172.16.10.1 LEN=84 TOS=0x10 PREC=0x40 TTL=104 ID=0 PROTO=ICMP TYPE=0 CODE=0 ID=161 SEQ=1 

OUT=  тоесть входной трафик направлен на сокет! а не на lo!
а ведьь могло быть вот так 


обратный трафик --> wlp2s0 ---> lo ---> сокет прижоение-А


вобщем  я у ядра вижу вот такую логику - приоложение (сокет) может получить входящий 
пакет тольлко обяателно так что это пакет дожлен в ядро влететь из сетевой карты. если такой нет
то из карты lo. 
тоесть

     ________
     |  eth0  |
     ========

       ||
       ||
       ||
       \/

      сокет (приложение)


либо
     ________
     |  lo  |
     ========

       ||
       ||
       ||
       \/

      сокет (приложение)



а вот такое невозможно



     сокет 

       ||
       ||
       ||
       \/

      сокет (приложение)



поэтому FILTER INPUT всегда виглядит вот так
      
      IN=NAME OUT= 

что экивалетнтно 


      IN=NAME OUT=сокет-А

и невоможно чтобы было вот так

      IN=сокет-Б OUT=сокет-А


поэтому окгда мы шлем с одного лок сервиса на друой то это всегда вот так


сокет-Б ------> lo  -------> сокет-А


[NAT-OUTPUT icmp] IN= OUT=lo SRC=172.16.10.1 DST=127.0.0.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=55581 DF PROTO=ICMP TYPE=8 CODE=0 ID=162 SEQ=1 

тоесть IN= OUT=lo

и никогда вот так

сокет-Б ------> сокет-А

тоесть вот такого не бывает IN= OUT=


если у нас из процесса трафик исходящий то у него IN= может быть пустой. тоесть трафк который
исодит от процесса может выдетать из него а не из карты.
но трафик который влетает в процесс не может в него влетатть не из карты. это невозможно.
влетащий трафик должен формаьно прилеетть в ядро из какйото сеетвой карты. поэтому
если я шлю из серсивса-Б в сервис-А. то ядро  вначале сует из сокета в сет карту lo
а потом якобы из нее получает обратно в ядро и только потом сует в приложение-А



приожение-Б ----> lo 

lo -------> сокет-А

тоесть

[NAT-OUTPUT icmp] IN= OUT=lo SRC=172.16.10.1 DST=127.0.0.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=55581 DF PROTO=ICMP TYPE=8 CODE=0 ID=162 SEQ=1 
...
[FILTER-INPUT icmp] IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00 SRC=172.16.10.1 DST=127.0.0.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=55581 DF PROTO=ICMP TYPE=8 CODE=0 ID=162 SEQ=1 

тоесть 
ядро вначале как бы еберет и из сокета и пихает в сет карту lo
      IN= OUT=lo
а потом якобы с сетевой карты lo в ядро влетает пакет (надоже!) и оно его пихает в сокет-А
      IN=lo OUT=


тоесть ядро разрешает трафику начать свой путь из сокета а не из карты для исходящего
трафика из процесса. но ядро запрещает в процесс влетать трафик из сокета, а можно только 
чтобы влетал трафик только из сет карты.
замечу что за Lo сетевой картой всегда сидит ядро (его как бы сокет например для тарфика icmp)

я как то забыл что приожение котрорму мы шлем пакет оно же не просто имеет сокет который 
болтается в пмяти. этот сокет должен через bind() быть привязан к IP+port что опосредованно
означает что он должн быть привязан к карточке сетевой. а что знаит привязка к сетвой
карточек. это означает то что если пакет в летел в ядро из этой картоки то пакет ядро сует
в этот сокет. так вот хорошо если у нас сервис получаетль подвязан к lo карточке
тоесть   bind(127.0.0.1 ) тода этта схема выгляди логичной


   сокет-б ------> lo ------> сокет-А (bind(127.0.0.1 ))

у нас даже исходящий сокет все равно мапиится к сет карте. что по идее должно значить то 
что исходящий трафик из сокета должен совавться в эту карту. а входязий трафик в эту карту
доожен соватья в сокет. так вот для входящего трафика это ядро выполянет. а вот для 
исходящего нет. 



$ strace -f -e socket,connect,bind,sendto,recvfrom  ping -4 -c1 -I 172.16.10.1   127.0.0.1  1>/dev/null

socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP) = 3
bind(3, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("172.16.10.1")}, 16) = 0
sendto(3, "\10... 16) = 64



[NAT-OUTPUT icmp] IN= OUT=lo SRC=172.16.10.1 DST=127.0.0.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=28766 DF PROTO=ICMP TYPE=8 CODE=0 ID=174 SEQ=1 


тоесть видно что 
bind(3, {sa_family=AF_INET, sin_port=htons(0), sin_addr=inet_addr("172.16.10.1")}, 16) = 0
я привзыяываю сокет к карте с 172.16.10.1 а это br0
это по идее должно значить что пакет от сокета ядром должен быть зансуть в br0 а уже 
оттуда роуиттся и быть засунуь в lo
однако что мы видим

[NAT-OUTPUT icmp] IN= OUT=lo SRC=172.16.10.1 DST=127.0.0.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=28766 DF PROTO=ICMP TYPE=8 CODE=0 ID=174 SEQ=1 


пакет у  нас из сокета суется в OUT=lo !

из чего я делаю вывод что bind() он привязывает сокет к IP адресу но не к сетвой карте!
сет карта в которую поток от проги нужно совать на исодящем потоке решает ядро исходя
из своих соображений ! тоже самое я думаю касется и входяего тарфика. ядро сует в 
сокет пакет котоорый главное что длжен иметь это dest_ip такой как указан в bind() сокета
а с какой карты он прилетел это вобоще нважно!
поэтому то что я думал что bind(IP) привзяывает сокет к сет карте = ошибка!
сокет привзыется только к IP! ядро получает неважно с какйо карты пакет если   у него
dst ip = bind(ip) то этот пакет суется в сокет и неажно с какйо карты он приелет!
тоже самое для исходящего тарфика. ядро сунет пакет из сокета в ту сет карту в которую посчитает
нужным а не в ту которая у него указана в bind(IP)

поэтому и получается елси у нас прога сидит на bind(192.168.21.1:3838) где  192.168.21.1 
это ип сет карты wlp2s0 , но этот факт не привзяеывает сокет к этой карте. поэтому 
в данную прогу долетит пакет если его пихнуть в ядро через wlp2s0 или его пихнуть в ядро
через lo интерфейс


 ---->  wlp2s0 ---> ядро ----> сокет прога-А
 ---->  lo     ---> ядро ----> сокет прога-А

тоест сокет по больому счету не привязан к сет карте ни к какой.  он за ней
не сидит. он сидит за ядром. сокет привязан к IP.  из какой сет карты прилетит пакет с этим IP
это без разницы

рассмотрим на примрере icmp. принимающая сторона у нас ядро. оно не имеет сокета. но будем 
считать что якобы ядро имеет сокет. и он принимающий значит как бы имеет bind(192.168.21.1)
так вот если у нас влетит icmp пакет с dest_ip=192.168.21.1 в ядро через wlp2s0 или он 
влетит в ядро через lo интфрейс это неважно. срабает в обих случаях потому что слушащму
сокету плевать из каокгой сет карты влетел пакет главное чтобы у этого пакета был  dest_ip=192.168.21.1
поэтому и получается якобы прикол. что мы шлем из приложение пинг на 192.168.21.1
а ядро этот пакет сует в lo интерфейс. так вот за этим итфрейсом сидит ядро (также как оно 
сидит и перед ним хаха) и вот на той стороне lo сидит ядро и оно сует пакет в сокет bind(192.168.21.1) а сокету плеват с какого сет карты приелет пакета потому что в сокет пакет
пихает ядро.

                пакет
 --------------------------------->
  сет карта wlp2s0 ---- ядро --- сокет 


для сокета нет никаки сет карт. для него есть только ядро. оно ему предает пакеты.
карты есть тлько для ядра

     
    внешний мир

      пакеты

       ||
       ||
       \/

================================
 wlp2s0    eth0    eth1    lo

   ||       ||      ||     ||
   \/       \/      \/     \/
 

           ядро 



сокет1    сокет2   сокет3   сокет4


правда lo он хитрый . за ним сидит не внешний мир а наше же ядро



сокет1    сокет2   сокет3   сокет4


                         ядро
                        пакеты

                          ||
                          ||
                          \/

================================
                         lo

                         ||
                         \/
 

           ядро 

сокет1    сокет2   сокет3   сокет4



поэтому когда сокет1 через ядро шлет в lo пакет то на той стороне 
оказвыается тоже саое ядро и теже самые сокеты.
вот они так друг другу и шлю пакеты чреез этот lo интфреейс



сокет-А --->ядро --->lo ----> ядро -->сокет-Б


важно еще и то что если пакет суется в lo он непросто отражается (замена местами src ip dest ip)
а миенно что за ним как бы тоже сидит ядро и сокеты. поэтому там наш пакет поглощается сокетом
приожения или ядра. обратно оттуда к нам уже летит не наш пакет а именно ответный пакет!


я вот так еще могу нарисовать. вот у нас сокет-А шлет пакет 
src_ip=1.2.3.4  dest_ip=127.0.0.1

сокет-А --->ядро --->lo

как тлоько этот пакет "ударяется" в lo то обратно "входит " в ядро так как бутто этот пакет
не мытолко что щас послали из сокет-А а как бутто этот пакет приелетел в наше ядро откуда 
из внешнего мира. и ядро начинает его обаратывать как такой входящий пакет из внешнего мира

сокет-Б <---ядро <---lo

просто разрциа в том что когда пакет летел к lo то он был исходящий и в ядре прходил по 
цеочкаv OUTPUT итп.
а когда он ударился и "отскочил" от lo то у пакета параметры не поменялист они остались 
прежними как и были src_ip=1.2.3.4  dest_ip=127.0.0.1
но ядро стало обрабаывать этот пакет совершенно чреез другие цепочки INPUT итп
вот как работает механизм сования пакета в lo 

это можно пресдатвиь вот как. вот как выглядит сетевой тракт с обычной сет картой

  

сокет   --------пакет_исх--------------->|    |  -----пакет_исх------>
                                         |eth0|
сокет   <-------пакет_вх-----------------|    |-----пакет_вх------>


тоест пакет который исходящий он из сокета через ядро попдае в карту и ултает во
внешнйи мир
аналогично для входящего. огн входит в карту и чреез ядро переносится в сокет.

а для lo интфрейса все смешнее


сокет   --------пакет_исх--------------->|    |
                                         | lo |
сокет   <-------пакет_исх----------------|    |


связи с внешним миром у этой карты нет. поэтому никаких входящий нет.
зато если исходящий пакет через ядро влетает в эту карту то он перекладыается на 
"входящий" конвейер обратно суется в ядро как бутто якобы этот пакет только что 
влетел в карту из внешнего мира
фишка в том что когда пакет летит по верней дорожке его обарабыавют одни цепочки iptables
а когда по нижней то совшеренно другие
тоесть улосвно говоря


              OUTPUT, POSTROUTING
сокет   --------пакет_исх--------------->|    |
                                         | lo |
сокет   <-------пакет_исх----------------|    |
             INPUT, PREROUTING


 
итак я возвращаюсь к картинке



                         4
                         +-----------------------
                         +                      +
                         +                      +
                         +                      +
                         +                      +   
                         +                      +
3                        +                       \                                         6
-------------------------+---------------------------------------------------------------------
                         +        \              \
                         +         \__2____________\_______________________________________________8
1                         +                                                                     7
-------------------------+----------------------------------------------------------------------




важно вот что. если у меня вм в составе l2 порта который в свиче и я с вм пингую комп
и у нас активароован br_netfilter то для компа ядра влет в ядро происходит четко
через tap интерфейс. через l2 интфреейс а не через l3 интфрейейс. 

ebtables встапают в строй если пакет летит через l2 или l3 интфрейс бриджа. 
если пакет летит чрез  чистрый l3 порт то ebdtables вобще нихуя не работают!
итак ebdtables изначально былиприпдуманы вместе и для софт свича


внутри ядра свичи обращены в нутрь ядра своими l3 портами br0 и docker0
поэтому если мы хотим св одного свича l2 порта пихнут данные в другой l2 порт друого
свича то полет будет

  l2 --->br0 ----> docker0--->l2

и мы это увиимдм в тцпдамп что через br0 и docekr0 лтят пакеты.

а если трафик между двумя l2 одного свича то уже br0 (или ocker0) неиспозуеся.

из l2 от dockr0 я шлю принг на l2 от br0

 ping -4 -c1  172.16.10.11


вот этот тракт


фев 04 05:26:22 lenovo kernel: [EBTABLES BROU BROU ICMP]  IN=veth346b018 OUT= MAC source = 02:42:ac:11:09:02 MAC dest = 02:42:a5:6e:95:26 proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES NAT PREROU ICMP]  IN=veth346b018 OUT= MAC source = 02:42:ac:11:09:02 MAC dest = 02:42:a5:6e:95:26 proto = 0x0800
фев 04 05:26:22 lenovo kernel: [NAT-PREROUTING icmp] IN=docker0 OUT= PHYSIN=veth346b018 MAC=02:42:a5:6e:95:26:02:42:ac:11:09:02:08:00 SRC=172.17.9.2 DST=172.16.10.11 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=4005 DF PROTO=ICMP TYPE=8 CODE=0 ID=179 SEQ=0 
фев 04 05:26:22 lenovo kernel: [EBTABLES FILTER INPUT ICMP]  IN=veth346b018 OUT= MAC source = 02:42:ac:11:09:02 MAC dest = 02:42:a5:6e:95:26 proto = 0x0800
фев 04 05:26:22 lenovo kernel:  [FILTER-FORWARD p:icmp] IN=docker0 OUT=br0 PHYSIN=veth346b018 MAC=02:42:a5:6e:95:26:02:42:ac:11:09:02:08:00 SRC=172.17.9.2 DST=172.16.10.11 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=4005 DF PROTO=ICMP TYPE=8 CODE=0 ID=179 SEQ=0 
фев 04 05:26:22 lenovo kernel: [NAT-POSTROUTING icmp] IN=docker0 OUT=br0 PHYSIN=veth346b018 MAC=02:42:a5:6e:95:26:02:42:ac:11:09:02:08:00 SRC=172.17.9.2 DST=172.16.10.11 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=4005 DF PROTO=ICMP TYPE=8 CODE=0 ID=179 SEQ=0 
фев 04 05:26:22 lenovo kernel: [EBTABLES FILTER OUTP ICMP]  IN= OUT=tap1 MAC source = f6:72:b2:f6:dd:ce MAC dest = ba:ec:24:5c:80:3a proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES NAT OUTPUT ICMP]  IN= OUT=tap1 MAC source = f6:72:b2:f6:dd:ce MAC dest = ba:ec:24:5c:80:3a proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES NAT POSTR ICMP]  IN= OUT=tap1 MAC source = f6:72:b2:f6:dd:ce MAC dest = ba:ec:24:5c:80:3a proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES BROU BROU ICMP]  IN=tap1 OUT= MAC source = ba:ec:24:5c:80:3a MAC dest = f6:72:b2:f6:dd:ce proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES NAT PREROU ICMP]  IN=tap1 OUT= MAC source = ba:ec:24:5c:80:3a MAC dest = f6:72:b2:f6:dd:ce proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES FILTER INPUT ICMP]  IN=tap1 OUT= MAC source = ba:ec:24:5c:80:3a MAC dest = f6:72:b2:f6:dd:ce proto = 0x0800
фев 04 05:26:22 lenovo kernel:  [FILTER-FORWARD p:icmp] IN=br0 OUT=docker0 PHYSIN=tap1 MAC=f6:72:b2:f6:dd:ce:ba:ec:24:5c:80:3a:08:00 SRC=172.16.10.11 DST=172.17.9.2 LEN=84 TOS=0x00 PREC=0x00 TTL=63 ID=43690 PROTO=ICMP TYPE=0 CODE=0 ID=179 SEQ=0 
фев 04 05:26:22 lenovo kernel: [EBTABLES FILTER OUTP ICMP]  IN= OUT=veth346b018 MAC source = 02:42:a5:6e:95:26 MAC dest = 02:42:ac:11:09:02 proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES NAT OUTPUT ICMP]  IN= OUT=veth346b018 MAC source = 02:42:a5:6e:95:26 MAC dest = 02:42:ac:11:09:02 proto = 0x0800
фев 04 05:26:22 lenovo kernel: [EBTABLES NAT POSTR ICMP]  IN= OUT=veth346b018 MAC source = 02:42:a5:6e:95:26 MAC dest = 02:42:ac:11:09:02 proto = 0x0800


об этом тракет поговрим потом.
а щас я хочу получить кривую 3-4 но чтобы ее получить это нужо чтбоы в ядро пооступил
пакет через чистый L3 порт. это вомзожно только в 1 случае. либо прям если снаружи из 
реальной сети влелттит пакет на чистый l3 порт. либо  внутри компа воспользоваться lo 
интфрейсом. либо дамми интерфейсом. например  вот у меня вртукла с 

[sudo] password for noroot: 
root@debian12-c1:/home/noroot# ip -c l sh
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether ba:ec:24:5c:80:3a brd ff:ff:ff:ff:ff:ff


и я еее с внешнеоо ъоста пингую

 ping -4 -c1 -I 172.16.10.1  172.16.10.11 


и вот вижу влогах на ввртуклке

входящий
[NAT-PREROUTING icmp] IN=enp0s3 OUT= MAC=ba:ec:24:5c:80:3a:f6:72:b2:f6:dd:ce:08:00 SRC=172.16.10.1 DST=172.16.10.11 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=26336 DF PROTO=ICMP TYPE=8 CODE=0 ID=185 SEQ=1 
[FILTER-INPUT icmp] IN=enp0s3 OUT= MAC=ba:ec:24:5c:80:3a:f6:72:b2:f6:dd:ce:08:00 SRC=172.16.10.1 DST=172.16.10.11 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=26336 DF PROTO=ICMP TYPE=8 CODE=0 ID=185 SEQ=1 
[NAT-INPUT icmp] IN=enp0s3 OUT= MAC=ba:ec:24:5c:80:3a:f6:72:b2:f6:dd:ce:08:00 SRC=172.16.10.1 DST=172.16.10.11 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=26336 DF PROTO=ICMP TYPE=8 CODE=0 ID=185 SEQ=1 

исходящий
[FILTER-OUTPUT icmp] IN= OUT=enp0s3 SRC=172.16.10.11 DST=172.16.10.1 LEN=84 TOS=0x00 PREC=0x00 TTL=64 ID=29598 PROTO=ICMP TYPE=0 CODE=0 ID=185 SEQ=1 

все как положено. 
обратный трафик кодга он провяерется в иптейблс черз коннтрак то там уже есть конкт поэтому
как я понимаю таблциа NAT асболютно в этмо случае игнориуются.

так как еред [NAT-PREROUTING icmp]  естт роутиг десижн то уже на этом этапе виден выходной
l3 инфтрейс в нашем слуачае это 

      OUT= 

это значит что иптбейлс собирается наш пакет после прходждения цеопчек сунуть в сокет
и так как я вnat аблциац ничего не меняю то так оно и просиходит.
так как у нас входяий и истходящий идует внутри вм по чистым L3 инфтерйсам то у нас
нет никаких ebdtabes. только iptables таблциы и цеоппочки
еще раз иптебйлс обслужваиют пакеты котоыре влетли в ядро через чистый l3 интерсф.
и если он через такой и вылетает.
ebdtabes ослужывают пакеты котоыре влетели либо ывлетают через l2 порт свича
если загржуен br_netfiletr то трафик который влетел ии ли вылетает через l2 инфтерйс тоже
начинает сяобрабаываться иптбейлс цепочками котоыре ставляются межуду цеопочками ebdtabels.
при этом в ипбтейблс нужно обязательно подсавит L3 порт якобы с кторого пакет влетлел в ядро.
в ряде случаев ядро вставляет феккоууую инфморацияю про этот порт. а вряде случаев ядро
реально прогоняет этот пакет после l2 пора через l3 порт. 

так как сокет не привязыван к сет карте а только к IP (что не оно и тоже) и так как ядро 
трубет чттоы локалое приложение получало пакет  ттолько если он влетел в ядро из сет порта
и так как посылание пакета на физ порт вызывает его вылет в сеть все это приводит к тому что
при пинге или nc  для IP карты которая ест на компе ядро шлет пакет не на карту на lo
который отражает пакет обратрно в ядро (как бы таким мккакаром делая что пакет влеетел с наружи
из сети) и наше ядро отает пакет сокету. 


НАПИСАТЬ ЗДЕСЬ ПОЛНЫЙ СЕТЕВОЙ ТРАКТ тоесть 3-4 и 4-6


