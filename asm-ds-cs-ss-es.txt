| asm
| cs
| ds
| ss
| es


еберем 32 баитный режим , protected mode

так вот у нас есть регистры cs, ds, ss, es

так вот из юзер спейса тоесть когда у нас цпу работает в непириливигирвованном
режиме к этим регистрам лазить ненадо. они защищены от записи. а точнее как только
мы попроуем их изменить то возникнет эксепшен. и ядро нахуй убтет процесс со словами

  segmentation fault


давай это проверим

$ cat 09.asm
section .rodata
    message db 'Hello, world!', 0x0A  ; Строка для вывода

section .text
    global _start

_start:
    ; Сохраняем текущие значения регистров (для демонстрации)
    pusha

    ; Попытка изменить DS
    mov ax, 0x10            ; AX = 0x10, это типичный дескриптор сегмента данных
    mov ds, ax              ; Попытка изменить DS

    ; Выводим строку (на случай, если изменение DS будет успешным, что маловероятно)
    mov edx, message        ; Адрес строки
    mov ecx, message        ; Вставляем адрес строки в ecx
    mov ebx, 1              ; STDOUT
    mov eax, 4              ; Системный вызов sys_write (номер 4)
    int 0x80                ; Вызов системного вызова

    ; Восстанавливаем регистры перед выходом
    popa

    ; Завершаем программу
    mov eax, 1              ; Системный вызов sys_exit (номер 1)
    xor ebx, ebx            ; Возвращаем 0 в качестве кода завершения
    int 0x80                ; Вызов системного вызова



	$ nasm -f elf32 -o  09.o 09.asm 
	$ ld -m elf_i386 -o  09.exe  09.o

$ ./09.exe
Segmentation fault (core dumped)


посмотрим изнвутри GDB

  $ gdb ./09.exe
(gdb) b _start
Breakpoint 1 at 0x8049000
(gdb) r
Starting program: /home/noroot/git/docs/C/ASM/09.exe 

(gdb) disass
Dump of assembler code for function _start:
=> 0x08049000 <+0>:	pusha
   0x08049001 <+1>:	mov    ax,0x10
   0x08049005 <+5>:	mov    ds,eax
   0x08049007 <+7>:	mov    edx,0x804a000
   0x0804900c <+12>:	mov    ecx,0x804a000
   0x08049011 <+17>:	mov    ebx,0x1
   0x08049016 <+22>:	mov    eax,0x4
   0x0804901b <+27>:	int    0x80
   0x0804901d <+29>:	popa
   0x0804901e <+30>:	mov    eax,0x1
   0x08049023 <+35>:	xor    ebx,ebx
   0x08049025 <+37>:	int    0x80
End of assembler dump.

(gdb) si
0x08049001 in _start ()
(gdb) si
0x08049005 in _start ()

(gdb) disass
Dump of assembler code for function _start:
   0x08049000 <+0>:	pusha
   0x08049001 <+1>:	mov    ax,0x10
=> 0x08049005 <+5>:	mov    ds,eax
   0x08049007 <+7>:	mov    edx,0x804a000
   0x0804900c <+12>:	mov    ecx,0x804a000
   0x08049011 <+17>:	mov    ebx,0x1
   0x08049016 <+22>:	mov    eax,0x4
   0x0804901b <+27>:	int    0x80
   0x0804901d <+29>:	popa
   0x0804901e <+30>:	mov    eax,0x1
   0x08049023 <+35>:	xor    ebx,ebx
   0x08049025 <+37>:	int    0x80
End of assembler dump.
(gdb) si

Program received signal SIGSEGV, Segmentation fault.
0x08049005 in _start ()


разберу окманды
 > b _start

эту штука уатснавливает брейкпоинт на метке _start
что такое метка какнибудт в друой раз. другой вариант это укзаать адрес

  > b *0x08049000

 длаее
 >r 
 это запуск программы

 далее
 (gdb) disass
это просьба показать дизассебл текст проги
при этом

   0x08049000 <+0>:	pusha
   0x08049001 <+1>:	mov    ax,0x10
=> 0x08049005 <+5>:	mov    ds,eax
   0x08049007 <+7>:	mov    edx,0x804a000
   0x0804900c <+12>:	mov    ecx,0x804a000

 строелочка позкывает ту команду которая еще НЕ исполнена. 

далее
 > si
означает выполнить ровно одну следущую команду


ну стобственно теперь по ходу программы
вот у нас следущая команда пытается записать в DS новое знаение
   0x08049000 <+0>:	pusha
   0x08049001 <+1>:	mov    ax,0x10
=> 0x08049005 <+5>:	mov    ds,eax
   0x08049007 <+7>:	mov    edx,0x804a000
End of assembler dump.


запускем эту следущую команду
(gdb) si

Program received signal SIGSEGV, Segmentation fault.
0x08049005 in _start ()


и получсем пошел нахуй от ядра.

таким образом - да. регистры DS,CS,SS,ES в них писать нельщя. они контролирутся ядром.
ядро в них пишет свои нужные ему значения. а нам можно только на эти регсиры ссмотреть.
или читать.  я бы скзала что эти регситры используюятся яром для своих внутренних нужд.

посмотрим чему они равыны


(gdb) info registers
cs             0x23                35
ss             0x2b                43
ds             0x2b                43
es             0x2b                43
fs             0x0                 0
gs             0x0                 0

левый столбик это я так понимаю анчение  в hex а правый тоже самое но в дсятичном виде


значит главная солт какая ----  когда у нас 32 бит protected mode режим дотсупа к памяти.
то вся память у нас плоская. имеется ввиду виртуальная адресация. поэтому у нас  с точки
зрения юзер спейса всякие там JMP   в них можно подсталвять  4 байта который указывает
абсолютный адрес внутрри виртального пространства. тоесть так как 4 байта адресуют 4ГБ
то можно в теории податслвять любой  адрес из этого 4ГБ пространства. тоеть

  JMP 0xAABBCCDD

тоесть нам в юзер спейсе ненужны никкакие сегментные регистры как это было нужно когда
мы работали с 16 битным real mode cpu режиме. вот там насколько я понимаю у нас для
кодирования адреса в памяти использовалось две хрени. одна хрень запиывалась в DS регистр
там был как бы базовый адрес. а вторая хрень указывалась как смещение относииельно этггого 
регистра

   JMP DS:1233

чтото типа того. ктастатаи DS\CS\ES\SS регстриы они 16 бит длинной. тоест в режим 16 бит real mode
адресация памяти шла не плоская не абсолютная а ячейка паяти адресовалалсь через сегмент+смещение.
в том режиме в сегментом регистре укаывался сегмент. насклоко я понимаю в форме полного адреса.
и добавлялсь смееенщение как доп параметр.  как то примерно так. так вот  в режиме 32 бит
protected mode такой модели адресации памяти уже нет.  нам для JMP больше нахуй ненужны
никакие сегментные регистры. мы просто береми ипосталвяет абсолютный адрес остсоящий из 4 байт
и нахуй. вот что яхочтел скзаать. при этом регистрф DS\SS\CS\ES они оказаись бесхозными
но их както и для чегото юзает ядро когда у нас цпу переключаетс в  привлишированный режим.
но нам из нашего юзер спейса на это уже наплевать. как я примерно понял эти регистры хаполняются
ядром и юзаются для того чтобы видимо обозначить возможно некую связь нашего вирт
адр пространства с физическим адресным пространсотвом. но это неточно. гдавный вывод - 
в юзер спейса наешего процесса нам про эти регистры надо забыть. как будто их и нет. 
нам для попадания в точку внутри адермного виртуальногоп простарансва нашего процесса
они нахйй не нужны. мы можем люубубю точку нашего вирт простанвстра попасть просто засунув
в JMP 4 байта. а эти 4 байта отлчно  охватывают все 4 ГБ памяти. 

ссылка на некотороеобьяснеииеие

	http://www.c-jump.com/CIS77/ASM/Memory/lecture.html

при этом некоторые дизасемблеы монут нам писат хуйню.например objdump

 $ objdump -d -j .plt  ./hello.exe  -M intel
Disassembly of section .plt:

08049020 <__libc_start_main@plt-0x10>:
 8049020:	ff 35 f8 bf 04 08    	push   DWORD PTR ds:0x804bff8
 8049026:	ff 25 fc bf 04 08    	jmp    DWORD PTR ds:0x804bffc


вот он берет опкод
  
  ff 35 f8 bf 04 08

и пишет что якобы он равен 

	push   DWORD PTR ds:0x804bff8

который можно перееввести как 

	push   [ds+0x804bff8]


тоесть якобы возьми то что в ds сложи с числом 0x804bff8. потому пойди по адресу который
получил , вытащи оттуда знаение и сунь его в стек.

так вот это полное набелвовово
на саомо деело опкод

  ff 35 f8 bf 04 08

значит 

	push   [0x804bff8]

тоесть регистр DS сука вообще никакой роли неиграет! число 0x804bff8 уже задает адрес!
никаокй ds нахуй не участвует. поэтому надо пойти по указнному дресу. прочиать то что 
там дежит и засунуть в стек!

сосвтенно с этого примера и началас эта тема - что за нахуй с этим DS регситаром?

