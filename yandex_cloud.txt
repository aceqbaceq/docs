yandex cloud

описание как чего в нем устроено



как ставить yandex cli
$ curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash

потом надо получить oauth токен через ссылку
https://oauth.yandex.ru/authorize?response_type=token&client_id=1a6990aa636648e9b2ef855fa7bec2fb

далее тыкаем
$ yc init

там вводим токен

по окончании посмотреть настройки текущего провиля якли
$ yc config list
token: y0_...
cloud-id: b1...
folder-id: b1g...
compute-default-zone: ru-central1-a

вопрос где хранятся эти настройки на файловой системе - а хранятся они вот в этой папке 
$HOME/.config/yandex-cloud/config.yaml



а теперь куча теории:
во первых тимпы юзеров в яблоке.
есть юзеры которые имеют доступ веб морду ( аля manaement console)
в доках яндекса их именно так и зовут USERS.
посмотреть их и добавиь можно вот так : заходим в веб морду - слева находим значок 
в форме три строки из трех столбиков тыкаем на него - resources & operations - cloud organisation - и 
попадаем вот на такую ссылку https://org.cloud.yandex.ru/users
там список наших Users или веб юзеров.


далее когда вошли в веб морду под веб юзером то можно создать некую хрень под названием папка.
внутри этой папки можно создать service account.
также в рамках этой папки можно создавать виртуалки сети и прочие ресурсы.

нахрен сдался сервис акаунт - ему можно назначать роли. это значит что этому акаунту
можно дать очень органиченныые права. далее типа кхм.. хуй знает можно подключться
к яблоку под этим акаунтом например через cli. под веб акаунтом типа нельзя.
а сервис акаунт в свою очередь не может подключатсья в веб морде.
каким то макаром некие приложения внешние не яндексовские могут покдлючаться 
к яблоку от имени эттого сервис акуунта но это неточно.
на данный моент важно то что если мы хотим подключаться через ya cli либо через 
тераформ то это можно делать только через сервис акаунт.

в яндоблаке куча типов юзеров. есть билинг юзер. есть юзер доступа к веб морде и походу
это и есть билинг юзер или хуй знает. есть яндекс акаунт. походу это все одно и тоже
билинг юзер=веб морда юзер=яндекс акаунт юзер.
есть сервис акаунт - это акаунт котоырй не омжет 
иметь доступ к веб морде но зато от его имени можно обращаться к якблоку через yacli или тераформ.

что такое IAM = Yandex Identity and Access Management . это походу ихний серис аутентификации.

в яндесе есть несколько токенов:

(инфо про токены брал отсюда = https://cloud.yandex.com/en/docs/iam/concepts/authorization/iam-token)

IAM токен - это токен котоырй выдается юзеру ( и тут вопрос каким типа юзеров? потому что в яблоке
дохуя типов юзеров) со стороны сервис IAM  после того как юзер 
аутентифицировался через этот сервис.

написано что юзер предьявляет этот токен при доступе к ресурсам яблока.
итак еще раз - мы аутентифицируемя на IAM (через логин парол к примеру в веб морде)
и нам IAM выдает IAM токен. и потом мы его предьявлем при доступе к ресурсам. 
написано что при доступе к ресурсам через веб морду (management console) и через yandex cli
получение IAM токена происходит для юзера незаметно автоматически и прозрачно. поэтому в этом
случае мы об этом даже не подозреваем. 

еще раз остается вопрос - каким юзерам выдается этот токен ибо у яблока дохуй типов юзеров.

далее написано что при досутпе к яблоку через API ( что это значит на практике хуй знает)
этот токен IAM надо вставлять в строчку:

Authorization: Bearer <IAM token>

так вот как я понимаю что вбраузере при доступе к менеджемент консоли должен быть такой HTTP хидер.
но я посмотрел его нихера нет. непонятно.

пример IAM токена 

t1.7euelSbPyceKx87JqpuRl1qZiY-Ryi3rnpWaksrKaZqUppnLncmDnpeajZvl8_dZNAFl-e8ENXMH_t3z9xljfmT57wQ1cwf-.-LErty1vRh4S__VEp-aDnM5huB5MEfm_Iu1u2IzNgyrn0emiWDYA6rSQXDvzjE0O3HBbUlqoDeCmXYYInzZ6Cg


это означает что IAM токен это берер токен или аксесс токен. раз это аксесс токен то это токен авторизации. а не аутентификации.по крайней мере по внешнему виду. хотя у яндекса как я понял аксесс токены порой применются 
как id токены но об этом дальше.

IAM токен валиден 12 часов. если выпросить новый такой токен то старый тоже работает.

как уже сказал выше при работе в веб морде либо через yandex cli процесс получения и предьявления
IAM токена происходит прозрачно и автоматически для юзера.

далее прикол в том что яндекс доки постоянно путаются и говорят о том что 
iam токен это то метод авторизации на яблоко сервисах и ресурсах то это метод аутентификации.
то есть качество документация яблока это полное гавно.

как я понял iam токен как метод авторизации поддреживается почти всеми яблоко сервисами.
еще раз напомню что iam токен нам выдает iam сервис после того как мы аутентифицировались на iam 
сервисе.  почти всеми кроме тех что AWS-compatible. какие это конкртено хрен знает. 


итого 
-iam токен это аксесс токен. он используется как паспорт\пропусе для доступа к яблоко ресурам
-его выдает юзеру (непонятно юзер какого типа) система аутентификации IAM после аутентификации
-в веб морде и yacli процесс получения и предьявления этого токена происходит прозрачно 
для юзера


окей в yacli работа с этим токеном автоматическая и прозрачная. 
а вот как дело в с этим делом в тераформе пока непонятно.



далее следущий вид токена OAUTH. написано что этот токен используется для  аутентификации yandex account (он же веб юзер входа в менеджмент консоль). только непонятно где он аутентифицируется перед кем.
как я понимаю через этот токен веб юзер аутентифицируется  на IAM сервисе аутентификации.
и IAM сервис в ответ выдает IAM токен используя котоырй можно уже лазить по ресурсам яблока.
в чем подвох? насколько я понимаю (а я могу быть и неправ просто ебнутая документация яблока) когда веб
юзер входит в веб менеджменет консоль через логин пароль то аутентификация видимо идет не через 
IAM сервис. а через какойто совершенно другой механизм. так вот если мы хотим получить доступ 
к ресурсам яблока от имени веб юзера но не через веб морду то наш веб юзер должен проуйти
аутентицикацию на IAM сервисе. там как я понял логин пароль непрокатит неипользуется в яндексе.
там они придумаои вот такой костыль - заходишь в веб морду через логин пароль. потом переходиь 
по спец ссылке и эта ссылка выдает тебе OAUTH токен. ты его берешь и предьявляешь IAM сервису в качестве
средства аутентификации как раз таки вместо логина и пароля. IAM понимаеь аутентификацию через OAUTH 
токен. и в ответ выдает IAM токен.
спрашивается если в веб морде все и так работает для веб юзера то где эта хренота с предьявлением
OAUTH токена применятеся? ответ например в yandex cli. если мы хотим поключиться к яблоку 
через яндекс кли от имени веб юзера то в настройках яндек кли указывается токен. насколько я понимаю
укзаыается именно OAUTH токен. и тогда яндекс кли обращаетя уже само к IAM сервису
и отправляет OAUTH токен. ИАМ серивс понимает что к нему постучался веб юзер вася и обратно 
прозрачно для юзера оптравляет IAM токен который яндекс кли использует в дальнейшем для доступа 
к ресурсам яблока.

еще таким образом - для пользования веб мордой от имени веб юзера никакой OAUTH токен нахен ненужен.
а вот для пользования yandex cli от имени веб юзера уже как раз нужно получит OAUTH токен (котоырй как бы замеменя логин паролль метод аутентификации при доступе к яблоку через янедекс кли при аутентициакации 
через IAM сервис) котоый нужно прописать в настроках яндекс кли.

возникает вопрос - а если мы хотим стучаться через яндекс кли на яблоко от имени service account
для него тоже надо получать OAUTH? если да то как его получить?


согласно доке oauth токен выглядит вот так

y0_AgAEA7qkTAklAATuwQAAAADV6.....

тоесть это форменный аксесс токен. тоесть такой токен должен применяться
по хорошему только как токен авторизации. у них же согласно доке
он прмиенятеся как токен аутентификации.

в целом наверное такой колхоз можно понять ( реально можно ? )  в том плане
что токен аутентификации или id токен он должен быть подписан цифорой подписью
это бы заставлялло видимо мудит с сертификатами на стороне нашего yandex cli клиента
что досталяло бы юзерам конечным кучу порблем. поэтму отказались от id токена 
для аутентифиации и заюзали аксесс токен для аутентификации потому что он никаких
цифровых подписей нетребует.


oauth токен выдаттется только веб юзеру (он же yandex акаунт) если пройти по ссылке
https://oauth.yandex.com/authorize?response_type=token&client_id=1a6990...

фишка втом что oauth токен невыдается сервис акаунту а только веб акаунту.


на данный момент остается открыты вопрос как получать токен для сервис акаунта
который можно всунуть в яндекс кли настройки чтобы мы ходили в яблоко не от имени
веб юзера а от имени сервис акаунта. ( а может это излишний напряг? )

еще важно - oauth токен имеет срог годности 1 год. в отличие от iam токена
который имеет срок годности 12 часов.

наскольо я понимаю яндекс кли если что то она сама обновляет iam токен когда
он протухает прозрачно и автоматически для юзера.

еще важнй момент какие яблоко сервисы поддерживают в своих конфигах 
указание OAUTH токена в качестве метода аутентификации веб юзера:

Yandex Cloud CLI
Yandex Container Registry
Terraform
Packer
GitLab CI

( я правда непонял а что тераформ это яндекс сервис ?)

написано что они автоматически запрашивают iam токен.
насколько я понимаю по факту эта фраза значит совершенно другое - эти сервисы так настроены
что они понимаю в конфигах что такое oauth токен и его суют на IAM сервис а он в свою очередь
разрешает этим сервисам в него это совать и он и в ответ отдает iam токен.

как это все работаео на тераформе пока непонятно. а вот в яндекс кли понятно.
мы скачиваем эту прогу. суем в нее oauth токен. и тогда янедкс кли шлет его на iam сервис
тот отдает iam токен и яндекс кли его юзает для доступа к ресурсам на яблоке.

таким образом мы можем на через яндекс кли входит в яблоко от имени веб юзера.
яндекс кли + iam сервис это поддерживают.

самое интеерсное что яндекс кли и тераформ это проги котоыре ставятся на комп
но это не яндекс сервисы. это скорее некие клиентские программы которые позволяют подключаться 
к яндекс сервисам \ яблоку. как mysql клиент например.
поэтому oauth токен это не токен который наша прога сует яблочным сервисам для аунтификации или 
авторизации как это есть с iam токеном. oauth токен это токен это метод который клиент использует 
как метод аутентификации на iam сервисе. тоесть его роль совершенно другая нежели чем у iam токена.
абсолютно другая. iam токен используется нашим клиентом для авторизации на яблочным сервисах
а oauth токен используется нашим клиентом для аутентификации на iam сервисе и неболее того.
использовать oauth токен напрямую для аутентифации\авторизации на яблочных сервисам не предусмотрено
и невозможно.
причем oauth токен может быть испоьзован для аутентификации только веб юзеров и более никаких
типов юзеров

еще раз как рабоате цепочка:
ставим скажем яндекс кли. в него прописываем oauth токен. яндекс кли стучится на iam сервис и 
предьявляет oauth токен. он в ответ выдает iam токен и яндекс кли уже предьявляет яблочным
ресурсам и сервисам этот iam токен как пропусконой документ.

это похоже вот на что. приходишь на завод(яблоко) на проходную(iam сервис) показываешь паспорт (oauth токен)
и на проходной на основе паспорта выдают пропуск(iam токен) заводской. заходиш на завод
и ходишт по кабинетам и цехам и везед суешь этот пропуск.

итого
завод это -> яблоко
прходная это -> iam сервис
паспорт это -> oauth токен
заводской пропуск это -> iam токен

паспорт валиден много лет. таким же макаром и oauth токен валиден 1 год.
заводскйо пропуск валиден скажем на один рабочий день. и iam токен валиден 12 часов.


так разобрались между разницей сфер примеения ouath токена и iam токена.



итак:
- oauth  это токен только для веб юзера другие типы юзеров в пролете.
- валиден 1 год
- получаем его через веб ссылку
- используется как метод аутентификации веб юзера перед IAM сервисом
это позволяет например в яндекс кли аутентифицироваться от имени веб юзера
- в веб морде аутентификация происходит через логин пароль и там OAUTH токен
нахрен не участвует

так. пока отойдем в сторону.
посмотреть список service accout в папке яблока
$ yc iam service-account --folder-id  b1gobq5rv8qm8qi76hig     list
+----------------------+-----------------+
|          ID          |      NAME       |
+----------------------+-----------------+
| ajed54n7p729vk8tscsg | vasya-test      |
+----------------------+-----------------+

(команду взял из доки от yacli = https://cloud.yandex.com/en/docs/cli/operations/authentication/service-account)

теперь когда мы выяснили параметры нашего сервис акаунта мы 
можем создать пару RSA ключей открытый и закрытый
$ yc iam key create --service-account-name   vasya-test    --output key.json --folder-id   b1gobq5rv8qm8qi76hig

id: aje9ru5060bj44...
service_account_id: ajed54n7p729vk8tscsg
created_at: "2023-03-09T19:15:13.886916958Z"
key_algorithm: RSA_2048

в облаке мы можем увидеть в свойтвах сервис акаунта что унего появился RSA ключи.
и на локальном компе также будет создан файл

$ cat $HOME/.config/yandex-cloud/key.json

{
   "id": "aje9r",
   "service_account_id": "ajed54n7",
   "created_at": "2023-03-09T19:15:13.886916958Z",
   "key_algorithm": "RSA_2048",
   "public_key": "-----BEGIN PUBLIC KEY-----\nMIIBIDAQAB\n-----END PUBLIC KEY-----\n",
   "private_key": "-----BEGIN PRIVATE KEY-----\nMII5AowIHtW/D0=\n-----END PRIVATE KEY-----\n"}


id = это порядковый номер присвоенный этой паре RSA ключей. это их identity номер
public_key =
private_key =  это конкретно приватный и публичный ключи
service_account_id = порядковый номер service account для которого создается пара RSA

таким образом key.json это паблик и приват RSA ключи и номер сервис акаунта для которых
эти ключи созданы 



таким образом у нас у нашего сервис акаунта создана пара RSA ключей ровно также 
как это бывает для связи по ssh и аутентификации через пару RSA ключей.

далее создаем новый профиль в якли
профили позволяют переклюаться между друг другом для того чтобы 
заходит на яблоко от разных яблоко юзеров. профиль якли от профиля якли отличается
юзером креды которого прописаны в профиле. и папкой яблока которые тоже указана в профиле.
таким образоом профиль это креды юзеры яблока + папка яблока
$ yc config profile create service_account_profile-vasya-test

смотрим список профилей якли
$ yc config profile list
default
service_account_profile-vasya-test ACTIVE

видно какой профиль является активным сейчас.

выбрать какой профиль мы активиуруем можно через команду
$ yc config profile  activate  имя_профиля

далее подключаем  к текущему активному профилю наш файл с ключами RSA и номером
service account:
$ yc config set service-account-key key.json


далее. важно. 
хотим посмотреть параметры текущего профиля. тоесть хотим посмотреть 
какие креды прописаны в текущем активном профиле
$ yc config list
service-account-key:
  id: aje...
  service_account_id: ajed...
  created_at: "2023-03-09T19:15:13.886916958Z"
  key_algorithm: RSA_2048
  public_key: |
    -----BEGIN PUBLIC KEY-----
    MIIDAQAB
    -----END PUBLIC KEY-----
  private_key: |
    -----BEGIN PRIVATE KEY-----
    MIIE5AowIHtW/D0=
    -----END PRIVATE KEY-----

видим что щас у нас профиль с сервис акуантом ajed... у которого прописан RSA пара ключей



далее смотрим список профиле
$ yc config profile list
default
service_account_profile-test ACTIVE

далее переключаеися на профиль default
$ yc config profile activate  default
Profile 'default' activated


смотрим свойства этого профиля
$ yc config list
token: y0_...
cloud-id: b1...
folder-id: b1gob...
compute-default-zone: ru-central1-a


видим что здесь прописан токен. 
это значит что это профиль для веб юзера который аутентифицирветя через oauth токен.


возрващаеся обратно в профиль в котором прописан сервис акаунт service_account_profile-test
в нем полезно прописать cloud id,
найти его можно вот по такой ссылке https://console.cloud.yandex.ru/cloud/.
папки яблока являются субструктурами  клауда.
$ yc config set cloud-id b1g8sk79560kbvb6nr2j

далее полезно прписать в профиле folder-id .
фолдер является субструктурой клауда.
$ yc config set  folder-id b1gobq5rv8qm8qi76hig

еще раз смотрим параметры нашего профиля
$ yc config list
service-account-key:
  id: aje9ru
  service_account_id: aj
  created_at: "2023-03-09T19:15:13.886916958Z"
  key_algorithm: RSA_2048
  public_key: |
    -----BEGIN PUBLIC KEY-----
    MIIBQAB
    -----END PUBLIC KEY-----
  private_key: |
    -----BEGIN PRIVATE KEY-----
    MIIIHtW/D0=
    -----END PRIVATE KEY-----
cloud-id: b1g8sk79560kbvb6nr2j
folder-id: b1gobq5rv8qm8qi76hig


видно что в профиел прописан номер клауда, номер фолдера,
номер сервис акаунта, и его RSA ключи.
таким из данного якли профиля мы будем работать от имени сервис акаунта который 
как я понимаю будет аутентифицироваться на клауде через RSA ключи и работать в 
заданной папке и заданном клауде.

теперь у нас все готово для того чтобы через якли от имени сервис акаунта в заданной папке
начать создавать виртуалки


$ yc compute instance create \
   --name test-instance-01 \
   --zone ru-central1-a \
   --network-interface subnet-name=dmz-1-a,nat-ip-version=ipv4 \
   --create-boot-disk image-folder-id=standard-images,image-name=ubuntu-22-04-lts-v20230130 \
   --ssh-key ~/.ssh/foxy.pub

(команду взял отсюда https://cloud.yandex.com/en/docs/compute/operations/vm-create/create-linux-vm)

на экране вылезет параметры вновь созданной виртулки. в том числе ее интернет IP.
чтобы к ней подключиться по ssh надо понять в какого линукс юзера яблоко всунуло наш указанный
ssh ключ. в этом нам поможет консоль в веб морде. 
из нее мы увидим что:
ci-info: ++++++++Authorized keys from /home/yc-user/.ssh/authorized_keys for user yc-user++++++

из чего сразу становится понятно что наш ключ был добавлен к линукс юзеру yc-user
таким макаром подключаемся к виртуалке через

$ ssh yc-user@51.250.4.189 -i ~/.ssh/foxy

success.


далее смотрим список виртуалок в нашей папке
$ yc compute instance list
+----------------------+------------------+---------------+---------+--------------+-------------+
|          ID          |       NAME       |    ZONE ID    | STATUS  | EXTERNAL IP  | INTERNAL IP |
+----------------------+------------------+---------------+---------+--------------+-------------+
| fhm8sb8chnt34440vsjm | test-bastion-1-a | ru-central1-a | STOPPED | 62.84.124.65 | 172.16.2.26 |
| fhmdq9689cc2egujpse9 | test-erp-db      | ru-central1-a | STOPPED |              | 172.16.1.18 |
| fhmqf0fnc1dkh6aem0ab | test-instance-01 | ru-central1-a | RUNNING | 51.250.4.189 | 172.16.2.27 |
+----------------------+------------------+---------------+---------+--------------+-------------+

СТОПИМ виртуалку
$ yc compute instance stop test-instance-01


УДАЛИТЬ виртуалку
$ yc compute instance delete  test-instance-01

(напомню что эти команды я смотрю вот здесь https://cloud.yandex.com/en/docs/compute/operations/vm-control/vm-delete)


<<<<<<<<<<<<< неотработанный материал НАЧАЛО >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
далее
следущий пункт из документа (https://cloud.yandex.com/en/docs/iam/concepts/authorization/api-key)
это api key:



далее возникает вопросы - каким образом аутентифицируется этот сервис акаунт.
под каким юзером(веб юзер или сервис юзер) мы входим через cli на яблоко?
ya cli -> сервис акаунт? oauth? jwt? iam-token ? bearer token?-> terfarorm



далее найдо создать сервис акаунт и получить 



OAuth = (Open Authorization)
bearer = предьявитель

bearer token = токен на предьявителя

разница между claim и assert:
assert (verb): to say that something is certainly true and you can defend your statement.
claim (verb): to say that something is true or is a fact, although you cannot prove it.

в  области аутентификации claim это  документ(справка, доказательство, паспорт)  о том что 
некая сущность имеет некоторое свойство. например паспорт это claim потому что в нем доказывается
что сущность  вася имеет возраст 35 лет.
при атутентификации мы понимаем claim как справку которая была выдана через IdentityProvider
об юзере.

пример claim

“Jim is a father,” Alexa says.
“Tom likes baseball,” states Oliver.
“Lisa is the newest member of the accounting team,” Jan asserts.

здесь видно кто выдале эту справку. и то что в справке указан юзер и его некоторое свойство.

claim может быть выдан самому себе а не только сторонним органом поэтому клейм
может сообщать некое свойство не только о стороннем юзере но и об самом себе.

есть еще такая хрень как scope. scope - это группа клеймов.

claim это ключ значение. из клеймов состоят scopes.

вот еще пример клеймов
{
    "family_name": "Silverman",
    "given_name": "Micah",
    "locale": "en-US",
    "name": "Micah Silverman",
    "preferred_username": "micah.silverman@okta.com",
    "sub": "00u9vme99nxudvxZA0h7",
    "updated_at": 1490198843,
    "zoneinfo": "America/Los_Angeles"

каждый ключ значение это claim.
вопрос а где эти клеймы искать ... ну внутри токенов. фигка в том что токены бывают разные.
бывает скажем beaarer token - то есть токен на предьявителя это как ценные бумаги на предьявителя.
когда мы их показыаем то нас не спрашивают ктомы. нам просто сразу дают за них бабки. кстати - деньги
это ценные бумаги на предьявителя. bearer токен выглядит как просто набор цифр и букв 23324iu34i23u4io23u423u4oi23u4
bearer токен применяется для доступа к конкретному ресурсу. так вот bearer токен он не имеет клеймов.
это один тип токена а есть и другие типы токенов. они внутри себя имеют пары ключ значение. об этом
щас поговорим. так вот эти пары это клэймы.

есть три типа токенов
id токен
access токен
refresh токен

id токен это jsown web tokeen aka JWT токен.
фишка этого токена что он состоит из клэмов.
он самодостаточен в том плане что информация которая в нем есть она подписана цифровй подписью 
поэтому достоверноть этого токена можно проверить самостотелтно.

прикол в том что стандарт OAUTH он в себе вводит понятие id токена но не прописывает как конкетно
он выголядит. а вот jwt он кокнретно опиысывает как выглядит id токен.
есть два вида JWT  - одни это подпианные цифровой подписью тоеть мы уверены что его содерживмое
неизмеено. и второй тип это зашифрованные. подписанные удобны для приложений. типа скрывать нам нечего
 авот иметь уверенность в достоверности нам надо. они постоянно пишут что фишка jwt что нам нежуно обращаться к базе чтбы проверить достоверность токена. блядь. а то что проверка достоверности это тоже сжирает мегагерцы
 их почемуто неебет.тоеть  в чем прикол нептнятно. еще фишка токенов в том что в них можно прорисать 
 время его окончания. поэтому это как одноразовый или времнный пароль. 

 далее идут акцесс токены. или еще их имя bearer токен.
 разница между акцесс токеном и id токеном в том что акцесс токен он очень простой. в
 нем просто идет некий стринг из букв и цифра 1231313erwerwer  который если мы покажем
 некотроому приложению то оно нас пустит на какойто ресурс.  аутентифциироваться нам при этом ненадо.
 а id токен он сложый в нем есть логин юзера. 

 как работает ворфлоу я пока непонимаю кто генерирует id токен  и кому потом отдает.
 еще  язнаю что есть три участника. юзер. ссервер аутентификации. и приложение  к которому юзер 
 хочет иметь доступ. точнее ресурс на этом приложении. по всей видимости сервер аутентициации после того
 как юзер аутнетифиуироытется на нем отдает юзеру bearer токен и юзер может его предьявлять уже
 приложению для доступа на ресурс. 

 чем плоха система паоллей пока непонятна. пароли кстати тоже могли быть одноразовыми или истекать.
 зачем было придумывать велосипед непонятно

 access токены обычно имеют маленький срок валидности и потом его надо обновлять получать заново

 рефреш токен испольщутся для того чтобы получить заново новый акцесс токен. рефреш 
 токен имеет обычно более длинный срок валидности

 нашел что обычно схема такая - юзер аутентицифируется и получает акцесс токен и рефреш токен
юзер обращается к ресурсу через акцесс токен. потом он истекает и наш клиент использует 
рефреш токен чтобы получить новйый  акцесс токен. когда истечет рефреш токен нам нужно 
будет снова аутентифицироваться 


как различать различные виды токенов.
id токен он содержит инфо об юзере. в частности его логин.
и еще id токен должен быть в формате JWT
access токен несодежит никакой инфо об юзере. это просто некий набор букво цифр. 
и его предьявляют при досутпе к конкчному ресурсу. 
рефреш токен незнаю как выгляит но его юзают только для обновления акцесс токена

все это я прочел вот тут = https://developer.okta.com/blog/2017/07/25/oidc-primer-part-1

( кстати on-premises = означает локально.  то есть как я понял это коода серверами владеет 
сама компания и она их сама обслуживает. в противополомженость облака - это когда ты арендуешь
у дяди серверы).

клеймы засоываются в токены. как я понял именно в id токены.
далее этот токен шлется приложению. только непонятно кем юзером или сервеом аутентификации.
кто его генерирует -сам юзер или сервер аутентификации. 
id токен как я сказал имеет цифроую подись поэтом приложение 
может самостояетно провеириить подлинность токена. я тока поканемогу понять что шлют друг 
другу и в каком порядке участники процесса: юзер, сервер аутентифиации и прилоежние.

id токен служит только для аутентификации как я понял. тоесть приложение когда получает такой токен
а там написано

имя: вася
плюс цифровая подпись.

а далее это уже работа приложения решать что этмоу васе можно делать а что нельзя
тоесть решать за авторизацию.

проясниласт вот какая фишка - захера нужны токены. 
вот у нас есть пять приложений.  мы хотим раздавать доступ к ним. по старой схеме (типа) надо 
для каждого приложения заводить некую базу куда прописывать логины пароли для юзеров (для того чтобы с их помощью мы значли что вася который стучит на приложение это точно вася тоесть проводить с их помощью 
аутентификацию ) а если васе нужно дать доступ ко всем пяти приложенияем то этого васю надо 
прописывать  в базу логинов во всех пяти местах. так вот можно пойти другим путем. можно создать 
некий централный орган аутентификации. там мы один раз в одном месте прописыаем васю. далее мы даем васе 
логин пароль. далее происходит примерно вот такая хрень - мы решили дать васе доступ к приложению номер
один. тогда в ответ на то что вася зашел на сервер аутентифкациии мы выдаем васе  токен  который подписан 
цифровой подписью нашего сервиса аутентификации и в этом токене есть поле в котором указано что у него
есть доступ к приложению один. например

id токен1:
имя: вася
приложение: 1
цифровая подпись: Х


далее вася идет на приложение 1 ии предьявляет этот токен. 
приложение 1 понятия не имеет ни о каком васе. но приложение 1 настроено так что оно доверяет 
цифровой подписи сервиса аутентификации. и оно доверяет всем кто на него стучит с этой подписью
и если в токене указано что ест поле

приложение: 1

таким образом приожение 1 неимеет никакой базы полтзователей и это удобно. в приложении 1 всего 
лишь настоено что если постучались с тикетов в котором есть клэйм виде 

приложение: 1

и этот токен подписан центром аутентификации то такого юзера впустить внутрть своих сервисов.

это перая удобвнящка.
вторая удобняшка в том что если мы хотим дать васе доступ на все пять приложений то надо 
в одном месте на сервиме аутентицаии всего лишь прорпсиать что у него такой доступ есть
и выдать васе пять токенов.

наверре сточки зрения васи нудобно носится с пятью токенами вместо одного логина пароля
но сточки зрения архитектурного програмирования  приложений и настроки аутентификации на них 
это приколная схема.

наскоь я понима что центр аутентиацикации этт только центр аутентиации но не авторизации.
тоесть в тикете котоырй выдаст центр аутентицкаици васе будет укаано только что его десивттельно
зовут вася и то что у него есть доступ на приложение 1.и цифровая подписаь. а вот уже 
что этому васе можно делать на приложении 1 это должно быть в настроках приложения 1. тоесть
база авторизации хранится уже внутри приложения 1 но не центар аутентификации.
тоесть база пользователей она все же есть внутри приожложения. но вопрос выяснения 
достоверности личности вася ты реально или невася аутсорсится центру аутентиификации.
тоесть паспорт тебе выдает паспортный стол - он проверяет вася ты или не вася.
а придя на дискотеку и показав паспорт на дискотеке уже охрана решает что тебе васе 
можно там делать. в паспорте этого нет.
об этом  я прочитал здесь = https://en.wikipedia.org/wiki/Claims-based_identity


<<<<<<<<<<<<< неотработанный материал  КОНЕЦ>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

service account - он привязывается к папке. привязать сервис акаунт выше папки нельзя  
тоесть привязать сервис акаунт к облаку нельзя. поэтому сервис акаунт дает доступ
к кокнкретной папке и все что ниже.  если у нас несколько папок то для каждой нужен 
свой сервис акаунт. доступ к облаку целиком дает только веб юзер что тоже самое 
yandex user. это надо учитывать при доступе из якли


как посмотреть список кастомны имаджей для данной папки
$ yc compute image list

как узнать под каким логином добавлен ключ ssh на машину
ответ заюзать опцию --full
$ yc compute instance get --name terraform1  --full
...
metadata:
  serial-port-enable: "0"
  ssh-keys: |
    ubuntu:ssh-rsa AAAAB

отсюда видно что ssh ключ прописан для юзера ubuntu



