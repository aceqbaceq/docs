| argv

ест такой момент. 
вот мы заупстили какойото процесс.
если мы посмтрим про него в ps aux | grep ...
то мы увидим название файла который мы запустили и далее список аргументов которые
мы процессу передали.
например 

	$ sleep 160 123 12 12

тогда в ps мы увидим процесс вот так

$ ps aux | grep sleep
noroot    500131  0.0  0.0   5548  1916 pts/4    S+   00:04   0:00 sleep 160 123 12 12


а вот если мы 
запустили nginx то увидим какую то хрень

# ps aux | grep nginx
root         986  0.0  0.2  20848  1292 ?        Ss   15:11   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;
www-data     987  0.0  0.6  22424  4228 ?        S    15:11   0:00 nginx: worker process
www-data     988  0.0  0.6  22424  4228 ?        S    15:11   0:00 nginx: worker process


вопрос - как самому научится такое творить?
значит суть вот в чем - у нас при запуске программы которая функция main() в нее передается
автоматом вторым аргументом поинтер на первый элемент массива. в этом массиве каждый элемент 
то тоже поинтер. поинтер на стринг. если мы заменим стринги на свои байты то в ps будет
нарисовано то что мы захотим. есть только проблема - стринги лежат в стеке. причем они лежат
плотно друг к другу. щас покажу.
если мы введем аргументы abc def 123
то в стеке они будут лежать вот так плюс минус

   abc0def01230

где 0 это ноль байт.
так вот мы можем найти начало этого места в стеке и засунуть туда свою фразу. но мы 
ни в коем случае недолжны своей фразой перелезть через суммарную длину этих аргументов в стеке
иначе мы получим ошибку "сломанный стек" условно. 
я в программе сделал вот так - я требую что суммарная длина всех аргументов была нениже чем
20 байт. тогдда я точно зная что у нас в стеке лежит как минимум 20 байт спокойно пишу
фразу которая недлинее 20 байт.
вот текст прогрммы


 $ cat 356.c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#define TIMEOUT  60

int main(int argc, char **argv){

   // проверка числа аргументов
   if ( argc < 2 ){
       printf ("число аргументов меньше 1. \n");
       return 1;
   };


  // проверка длины  аргументов
  int len=0;
  char *q;
  for (int i=1; i<argc; i++){
      q = *(argv+i);
      while (*q){
        len++;
        q++;
      };
   };
   printf("len = %i \n", len);
   if ( len < 20) {
     printf("error : длина всех аргументов меньше 20 символов. \n");
     return 1;
    };



  // распечатка аргументов
  for (int i=0; i<argc; i++){
    printf("argv[%i] = %s \n", i, *(argv+i) );

  };

  // замена аргументов
   strcpy(*(argv+1), ": master process   ");




    printf("пауза %iс чтобы залезть в ps\n", TIMEOUT);
    sleep(TIMEOUT);

};


вот так я ее запускаю

 $ ./356.exe  11111111111111111111

и вот что я вижу про этот процесс через ps

$ ps aux | grep 356.exe
noroot    504813  0.0  0.0   2796  1444 pts/1    S+   00:41   0:00 ./356.exe : master process   



тоесть плюс минус тоже самое что мы видим у жинкса
# ps aux | grep nginx
root         986  0.0  0.2  20848  1292 ?        Ss   15:11   0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;



тоесть нужно просто после старта процесса отредактивровать массив где лежат аргументы.

поэтому теперь плюс минус понятны вот такие дурацкие названия в списке ps
root        3159  0.0  0.0      0     0 ?        I<    2024   0:00 [kworker/R-kcryptd_io-254:3-4]

при желании мы теперь и сами такую хрень можем наклепать.

может быть жинкс и не меняет ничего в массиве аргументов. а просто условно говоря 
себя запускает ну примерно так 

 # nginx "nginx: master process /usr/sbin/nginx"

ПРИКОЛЬНО - еще такой момент что , у нас вторым аргументом будет пеерменная тип у нее 
поинтер на поинтер тоесть 
   
   char **argv;

так вот я пробовал другой вариант исправения массива аругметов - я пробовал после старта
программы менять значение как самого поинтера argv так и поинтеров на которые он укаызает
тоесть на 

  *(argv+0)
  *(argv+1)
  ..
  *(argv+argc)

но это никак не отражается на том как мы видим процесс в ps. тоесть такое ощущение что 
ядро именно запоминает прям какие адреса хранятся в (argv+0), (argv+1), (argv+2), ..., (argv+i)
поэтому именно необходимо менять конечные стриги а не поинтеры которые на них ссылаются


