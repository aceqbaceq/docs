umask 


как он работает
что дает.

каждый процесс в линуксе имеет свойство называется umask.
эта хрень это число по длиннее ровно такое же как маска пермишнс.
скажем в OCT виде это 0002

я сказал что каждый процесс в линуксе имеет это свойство. 
более точно картина такая - когда создается процесс то он создается
со свойством UID равным UID юзера кторый запустил файл.(либо  с UID которйы
равен UID файла если файл имеет suid бит ).
UID процесса это тоже его совйство. так вот для каждого юзера
в линуксе задается его umask. скажем в убунту эта хрень задана в 
/etc/login.defs как  я понял. а так его можно откоректировать для
юзера в ~/.profile

что дает этот umask. если мы создаем файл напрмиер через команду
    $ true > ./file1.txt
    $ echo "1" > ./file2.txt
    
то возникает вопрос а какой пермишнс ос должна задать этому файлу.
сразу скажу что владельцем файла будет сделан тот кто создает этот файл.
а с пермишнсами посложнее. поскольку мы при создании файла неуказываем
с каким пермишнс его создавать то нужно какоето дефолтовое правило.
так вот оно есть и оно такое. если мы создаем файл то дефолтовый пермишнс
вычислется по формуле
    0666-umask
а если создается папка то 
    0777-umask
в убунту по дефолту umask=0002  узнать это мжоно через комнду
    $ umask
    0002
еще раз скажу что umask это свойство процесса. и это свойство зависит от юзера
под кторым работает процесс. этот юмаск нужно для того чтобы нам после создания
файла непришлось каждый раз руками через chmod регулировать пермишнс нового файла.
по крайней мере чтобы это неделать в массовом порядке. если юмаск=0002
то новый файл будет иметь пермишнс
    0666-0002=0664
проверим на практкие

    $ :>1.txt
    $ stat --format="%n %a" ./1.txt
    ./1.txt 664

далее хочу сказать вот что. 
что функция C которая создает файл имеет вид

    int fd = open("/tmp/106.txt", O_CREAT|O_WRONLY, S_IXUSR|S_IXOTH);

где
O_CREAT  = флаг что если файла нет то создать 
O_WRONLY = открыть файл в режиме write only

S_IXUSR = owner has execute permission 00100
S_IXOTH = execute/search by others     00001

вместо S_IXUSR|S_IXOTH можно указать пермишн в octal виде
собвственно цифрки 00100 и 00001 это указан октал вид. соотвесвтенно
если мы хотим оба этих флага включить то надо просто сложить
    00100 + 0001 = 00101
тоесть можно вот так указать в сисколле

        int fd = open("/tmp/106.txt", O_CREAT|O_WRONLY, 00101);

и это будет одно и тоже
наебка такого вида этого сисколла в том что когда мы видим 00101
то возникает обманное впечателение что это бинарное число. а это октальное число!
по факту 00101 это пермишн указанный в привычном octal виде. 
просто надо откинуть первый ноль слева. так как он просто для C обозначает 
что формат числа октальный . тогда 
    0101
нам привычно что октал вид пермишнса это три цыфры. но это потому что самая левая
цифра в ней отражаются suid,guid,sticky биты. а они редко используются.
тоесть когда мы пишем
    # chmod 666 ./1.txt
то по факту это 
    # chmod 0666 ./1.txt

итак эта команда она создает файл с пермишнсами что 
    --x --- --x

        
а вот программа
эта программа создает этот файл.
и еще эта програма через команду umask (0) задает юмаск=0000
это дает то что у нас финальный пермишн у файла будет 
   0101-0000 = 0101
тоесть я делаю так что юмаск ни коим образом неизменяет 
пермишн прописанный в open (..)

$ cat 106.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>


int main(void)
{

mode_t mask = umask (0);
//umask (mask);
//printf("umask = %o\n",mask);





int flags = O_CREAT|O_WRONLY;
char *pathname = "/tmp/106.txt";
mode_t mode = S_IXUSR|S_IXOTH;

int fd = open(pathname, flags, mode);


if (fd < 0) {
      perror("Creation error");
      exit (1);
}

close (fd);
exit (0);

}



запускаем ее
и смотрим в strace
    $ strace ...
    ...
    openat(AT_FDCWD, "/tmp/106.txt", O_WRONLY|O_CREAT, 0101) = 3

стрейс напомню показывает в своем выводе не функции C а уже сисколлы.
поэтому мы видим openat а не open. тоесть мы в C программе прописываем C функцции
а уже эта функция запускает сисколлы. видим что в сисколее параметры ровно такиеже
как мы заказали в функции. также помним что 0101 это не бинарное число а октальное.
и оно задает пермишн user=x other=x
также напомню что программа через umasl(0) задала юмаск=0000 поэтому он невлияет 
на конечный пермишн. и мы должны получить в файле пермишн = 0101 . проверяем

    $ stat /tmp/106.txt --format="%n %a"
    /tmp/106.txt 101
    $ ls -1al /tmp/106.txt
    ---x-----x 1 vasya vasya 0 дек 24 02:06 /tmp/106.txt

итак видно что файл получил пермишны точно такие как я указал в теории.

а щас я задам пермишн 0777 и юмаск 0666
и на выходе я должен получить пермишн у файла 0777-0666=0111


$ cat 106.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>


int main(void)
{

mode_t mask = umask (0666);





int flags = O_CREAT|O_WRONLY;
char *pathname = "/tmp/106.txt";
mode_t mode = 0777;

int fd = open(pathname, flags, mode);


if (fd < 0) {
      perror("Creation error");
      exit (1);
}

close (fd);
exit (0);

}


запускаю  прогу с strace
    $ strace ... 
openat(AT_FDCWD, "/tmp/106.txt", O_WRONLY|O_CREAT, 0777) = 3
видим что сисколл отработал с 0777 и еще помним что я задал юмаск 0666
порверяем какой пермишн в итоге у файла
    $ stat /tmp/106.txt --format="%n %a"
    /tmp/106.txt 111
    $ ls -1al /tmp/106.txt
    ---x--x--x 1 vasya vasya 0 дек 24 02:24 /tmp/106.txt

в итоге да! все верно отработало!

тут важно понять то что если я даже в программе незадаю юмаск 
то он автоматом подсасывается при создании процесса из конфигов линукса
скажем из /etc/login.devfs, возникает вопрос а какже он подскаывается если 
его в коде  c программы не указать. а дело в том что помимо моего кода в с программе
при компиляции туда присовывается и некий "стандартный" код libc. либо  
сам ядерный код который занимается созданием процесса из нашего файла без нашего
спроса насоввывает в процесс те штуки которые считает нужными. в любом случае
даже если я в программе не задаю umask он все равно будет присуствовать как переменная
в процессе буду прочитан из некоего конфига линукса. я его задаю в программе
чтобы точно явно было понятно чему он равен. так вот важно понять что юмаск у процесса
есть всегда. и то что при запуске open\openat ядерный код который его обслуживает
он берет пермишн из open\openat и отнимает от него то что  в umask и уже именно 
это и сует  в пермишн создаваемого файла! поэтому важно понять что скажем в программе
вообще невидно никакого юмаска. но он точно  в итоге в процессе будет. и он точно будет
отнят от пермишнов указанных в open\openat
таким макаром я думаю теперь понятно откуда берется юмаск. зачем он и куда он присоба
чивается. 
значит если с пермишнсами разобрались нового файла из чего они складвыаются то 
также видно что в open не указыается владелец файла. откуда он берется?
его берет само ядро и назначает к пермишнсу файлу исходя из uid\gid свойств процесса.
там тоже есть тонкость , есть uid у процесса а есть euid. так вот берется эффективный
uid о котором я щас не буду говорить. в простом случае владельцем созданного файла 
будет тот же юзер который запустил процесс. 
таким макаром теперь становится понятно откуда пермишн берется для создаваемого
файла и понятно откуда берется владелец файла. и про юмаск теепреь тоже понятно.
если я хочу чтобы юмаск никак не влиял на пермишн надо его задать ноль
    umask(0)
чтобы о нем забыть. 
также важно сказать что у линукса почемуто нет возможнсти просто прочитать 
значние текущее юмаска. можно только вот сделать. команда юмаск задает новое
значение юмаска а старое возвращает в коде возврата. поэтому если мы хотим
псмотрть текущее занчение то надо делать финт ушами

    mode_t mask = umask (0);   
    umask (mask);
    printf("umask = %o\n",mask);

тоесть мы юмаск меняем на ноль. числь не имеет никакого значения. 
можно любое другое подставить. при этом в переменную mask 
возврашаетя предыдущее значение юмаска.
следущая строчка меняет юмаск на старое значение
последнняя строчка просто печаатет на экране изначальное значение.
причем прикол втом что в мане линукса есть функция c которая якобы позволяет
считать старое значнеие юмаска без его изменнеия man getumask
но пофакту этой функции С нет в линуксе нихуя. 

    

далее. значит в man 2 open написано что если мы указали флаг O_CREAT
то это значит что мы просим создать файл если его нет и в мане напписано 
что в команде нужно обязательно указыввать пермишн. что логично. я щас попрбую
запустить программу в которой я не указал пермишн. посмотрим что будет



$ 
$ cat 106.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>


int main(void)
{

mode_t mask = umask (0);
//umask (mask);
//printf("umask = %o\n",mask);





int flags = O_CREAT|O_WRONLY;
char *pathname = "/tmp/106.txt";

int fd = open(pathname, flags);


if (fd < 0) {
      perror("Creation error");
      exit (1);
}

close (fd);
exit (0);

}


запускаем и смотрии через strace
    $ strace ...
    openat(AT_FDCWD, "/tmp/106.txt", O_WRONLY|O_CREAT, 0101) = 3

и видно что каким то макаром хотя я не указывал пермишн в программе
но в итоге в сисколле появился пермишн 0101 
проверяем какой пермишн в итоге у файла

    $ stat /tmp/106.txt --format="%n %a"
    /tmp/106.txt 101

видим что тоже 0101 
и здесь я хочу обратить внимание на такую вещь которая постоянно 
пишется в интернете к которой я подводил. в интернете пишут что дефолтовый пермишн
который назначается файлам в линуксе это 0666-umask
так вот я на живом примере доказал что при создании файла если ты явно неуказал
пермишн то линукс создает файл по правилу 0101-umask
что кординально отличается от того что пиздят в интернете.
тут вылезает еще тонкий момент. файл создается в конечном итоге через фунцию C open
или openat которую я рассматривать не буду. эти функции вызыают сисколл openat.
так вот при вызове open мы либо не указвыаем какой пермишн назначить файлу и тогда как
мы толко что увидели ядро линукса вызывает сисколл с пермишном 0101 
либо мы явно указваем с каким пермишном мы хотим создать файл. 
с этим разобрались. 
далее до этого момента я создавал файл через программу на С и функции open.
а теперь посмотрим как работает система когда мы будем создавать файл через bash output 
redirect

    $  : > /tmp/107.txt
и тогда стрейс нам показывает 
    openat(AT_FDCWD, "/tmp/107.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3

и из этого можно сделать важный вывод - когда мы создаем новый файл через баш.
через его средства в частности через output redirection то да , баш вызывает
openat с указанием 0666 для пермишнов нового файла. вот откуда взялась эта фраза
что линукс по дефолту создает файла с пермишном 0666-umask
тоесть очень важно понять что это искллючиетельно не линукс а это исключиетьно если
мы создаем файл через баш. только в этом случае. если это будет какойто другой шелл
то какой там будет пермшн будет зависеть от настроек того шелла. как я уже 
показал выше - если мы создаем файл через программу на C через open и не указываем
пермишн то ядро по дефолту подставлят 0101.
этобыло важно обьяснить раскрыть прояснить.

еще раз хочу сказать что юмаск в линуксе указывается в параметрах конфига 
юзера. вопрос в каком файле.
я нашел запись в ~/.profile о том что 
    
# the default umask is set in /etc/profile; for setting the umask
# for ssh logins, install and configure the libpam-umask package.
#umask 022
   
я зашел в /etc/profile но там нихрена ненашел про umask
зато я его нашел в 

    $ cat /etc/login.defs  | grep -i umask | grep -v '#'
    UMASK		022

вот доказтаельство того что в ~ нихрена нету настроек umask

    $ find ~ -maxdepth 1 -type f -size -10M -exec grep -H -i umask  '{}' ';'  2>/dev/null
    /home/vasya/.profile:# the default umask is set in /etc/profile; for setting the umask
    /home/vasya/.profile:# for ssh logins, install and configure the libpam-umask package.
    /home/vasya/.profile:#umask 022

    
а вот в /etc/
$ find  /etc  -maxdepth 1 -type f -size -10M -exec grep -H -i umask  '{}' ';'  2>/dev/null
/etc/ltrace.conf:octal umask(octal);
/etc/ltrace.conf:octal SYS_umask(octal);
/etc/rsyslog.conf:$Umask 0022
/etc/fstab:UUID=B4A0-BF77  /boot/efi       vfat    umask=0077      0       1
/etc/vsftpd.conf:# Default umask for local users is 077. You may wish to change this to 022,
/etc/vsftpd.conf:#local_umask=022
/etc/login.defs:#	UMASK		Default "umask" value.
/etc/login.defs:# UMASK is the default umask value for pam_umask and is used by
/etc/login.defs:# 022 is the "historical" value in Debian for UMASK
/etc/login.defs:# If USERGROUPS_ENAB is set to "yes", that will modify this UMASK default value
/etc/login.defs:UMASK		022
/etc/login.defs:# Enable setting of the umask group bits to be the same as owner bit

так вот вроде как видно что umask = 0022
однако в  убунту если проверить на практике то мы увидим что юмаск = 0002
    $ umask
    0002
ответ находится все в томже файла /etc/login.defs 

    $ cat /etc/login.defs
    ...
    # UMASK is the default umask value for pam_umask and is used by
    # useradd and newusers to set the mode of the new home directories.
    # 022 is the "historical" value in Debian for UMASK
    # 027, or even 077, could be considered better for privacy
    # There is no One True Answer here : each sysadmin must make up his/her
    # mind. 
    #
    # If USERGROUPS_ENAB is set to "yes", that will modify this UMASK default value
    # for private user groups, i. e. the uid is the same as gid, and username is
    # the same as the primary group name: for these, the user permissions will be
    # used as group permissions, e. g. 022 will become 002.
    #
    # Prefix these values with "0" to get octal, "0x" to get hexadecimal.
...
    #
    # Enable setting of the umask group bits to be the same as owner bits
    # (examples: 022 -> 002, 077 -> 007) for non-root users, if the uid is
    # the same as gid, and username is the same as the primary group name.
    #
    # If set to yes, userdel will remove the user's group if it contains no
    # more members, and useradd will create by default a group with the name
    # of the user.
    #
    USERGROUPS_ENAB yes


тоесть написано что если актииивровано  USERGROUPS_ENAB а он 
как видно активирован в этом конфиге то для root umask=0022
а для простых юзеров umask=0002  так оно и есть. кстати подверждается
такая штука что /etc/login.devfs является в убунту тем файлом где для всех
пропиывается umask. а если уже мы потом хотим какотому юзеру индивидиуально его
поменять то надо идти в ~/.profile
проверяем на практике

    $ umask
    0002

    # umask
    0022

все сходится

значит что дает umask=0002 это дает то что по дефолту при создании нового файла
под обычным юзером у этого файла будет убрано  своство что other может "w"
тоесть этот юмаск запрещает other записывать в файл.

что дает юмаск 0022 он дает то что при создани нового файла у файла будет запрещено
для group запись и для other запись.
вот какой физ смысла юмаска для рута и не рута.

еще раз подчеркну что каждый процесс при старте считывает из системы юмаск.
и далее если процесс будет создавать файл а файл в линуксе в коненом итоге можно 
создать только через функцию open\openat то в этой функции мы по идее обязаны указать 
какой пермишн мы хотим чтобы система назначиал ноовому файлу. а если мы это не укажем
то ядро само подставит значение 0101 так вот в любом случае при создании файла
тоже самое ядро оно отнимет от пермишна юмаск. и уже то что останется назначит файлу.
итак если мы задали в open\opnat permission то файл будет создан с пермишном в виде
    permssion - umask
а если мы неуказал в open нужный нам пермишн то ядро использует 0101 и финаьный 
пермишн на файле будет
    0101 - umask
как только что мы выяснили если процесс имеет эфективный uid непривлигиорванного
юзера то umask по дефолту =0002
если же юзер рут то umask=0022
дефолтовый юмаск для юзера можно поменять через файл ~/.profile
также - сам процесс может без проблем через функццию umask(new_value) поменять 
umask налету что собвстнно я и делал в моей программе на C.
также еще раз напомню что если мы создаем файл средствами баша. тоесть через 
его инструмент под названеим output redirect
    $ команда > file
то баш заказывает в open пермишн = 0666. и значит итоговый пермишн который ядро
назначит файлу будет 0666-umask
тоесть если мы используем баш redirect то цепочка такая
    bash --> open (0666) ---> ядро (0666-umask)  --> драйвер фс --> файл
тоесть юмаск онтнимается от 0666 не в программе баша а уже ядром внутри кода 
ядра во время исполнения сисколла openat
    
ВОТ СКОЛЬКО ФАКТОРОВ ВЛИЯЕТ НА ТО КАКОЙ ПЕРМИШН БУДЕТ У ФАЙЛА В КОНЕЧНОМ ИТОГЕ
ПОСЛЕ ЗАПУСКА КОМАНДЫ


далее. я хочу показать как на практике работает bash redirect.
что скрывается под капотом при использовании ">"

значит я запускаю некую внешнюю по отношению к башу команду
причем сразу подчеркну что какая именно команда неважно.
ниже станет понятно почему. но для примера это команда sleep
и делает редирект который нам создаст новый файл

    $ sleep 120 > /tmp/sleep.txt
смотрю трейс
вначале идут сисколлы самого процесса баша 
    geteuid()                               = 1000
    getegid()                               = 1000
    getuid()                                = 1000
    getgid()                                = 1000


таким макаром баш понимает под каким юзером ему надо запустить
новый процесс в котором будет работать sleep

после этого баш себя клонирует
    clone(child_stack=NULL, \
          flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, \
          child_tidptr=0x7f5027cdda10) = 28916

мы получаем дочерний процесс 28916
в дочернем процессе по прежнему работает код баша. и он 
запускает вот такие сисколлы
    openat(AT_FDCWD, "/tmp/sleep.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
    dup2(3, 1)                  = 1
    close(3)                    = 0
    execve("/bin/sleep", ["sleep", "120"], 0x55ad028a1b10 /* 70 vars */) = 0


первый сисколл openat имеет флаг O_CREAT это значит что если файла /tmp/sleep.txt"
нет то надо его создать. а так как его нет то он его создает.
указан пермишн который мы заказываем у ядра 0666
файл будет создан с перимшном 0666-umask
в трейсе я неувидел чтоббы вызывался сисколл  umask значит umask
дефолтовый. так как процессс запускался от простого юзера значит umask=0002
значит файл будет создан как 0666-0002=0664
это я щас ниже проверю.
также видно что для созданного файла процессу прикрепляется файловый дескриптор 3.
через который можно раобтать с этим новым файлом. также виден флаг O_WRONLY
который разрешает в файл только писать. а читать значит нельзя.

итак мы имеем дочерний процесс. это по прежнему баш. мы создали файл 
/tmp/sleep.txt с пермишном 0664. и его дескриптор равен 3 и прикреплен к этому процесу
поскольку баш был запущен под юзером vasya то дочерний процесс тоже работает под юзером
вася и значит владелец /tmp/sleep.txt ядро тоже сделало vasya

следущий сисколл dup2(3,1) он делает то что он копирует дескрипто 3 в дескриптор 1
это значит что если на момент создания процесса его дескриптор 1 смотрел на терминал
то теперь дескриптор 1 указывает на файл /tmp/sleep.txt 

следущий сисколл убивает дескпритор 3. так как он нам больше ненужен . так
как дескриптор 1 уже смотрит на файл

пооследний сисколл execve заменяет для этого процесса бинарник с баша на sleep
и унас начинает в этом процессе работать уже бинарник sleep
таким образом stdout (файл дескриптор 1) процесса sleep у нас смотрит в файл /tmp/sleep.txt
если бы слип чтот высирал на stdout то это бы было записано в /tmp/sleep.txt
а так как слип ничего не выводит то этот файл останется пустым.

проверяем параметры файла /tmp/sleep.txt
    $ ls -1al /tmp/sleep.txt 
    -rw-rw-r-- 1 vasya vasya 0 дек 24 03:43 /tmp/sleep.txt

    $ stat /tmp/sleep.txt  --format="%n %a"
    /tmp/sleep.txt 664

тоесть ровно все так как я описал в теории
и владелец вася и пермишн равен 644
теория совплаа с практикой

так вот что важно понять из описанного выше. если мы в баше запускаем некую внешнюю
команду и также указываем редирект в файл то эта хрень работает так

    $   команда > file1

баш клонирует самого себя в новый процесс.так как команда запущена без судо 
и так как файл который отвечает за команду скорее всего не имеет suid guid бита
то склонированный процесс будет иметь uid,gid такой же как был у головного баша
тоесть в моем случаае если головоной баш работал под vasya
то и дочерний баш будет работать под vasya
как видно из strace после клонирования баш не меняет umask. это значит что 
он остается таким же как был у головного процесса. далее. дочерний процесс баша
создает новый файл file1 и открывает его на запись. при этом баш заказывает у ядра
чтобы пермишн у файла был 0666. но ядро учитывает umask и делает его как 
    0666-umask
если юзер под которым раобтает процесс непривлигированный то umask=0002
и значит пермишн у файла будет 0664 а владелец будет такой же как у дочернего процесса.
тоесть как у головного то есть vasya.
далее. новый файл ядро подключаает к процессу через новый дескриптор например 3.
далее баш в дочернем процессе копирует дескриптор 3 в дескрпитор 1. таким образом
1 начинает смотреть в file1. далее баш удаляет дескритор 3 ибо он нам нахер теперь
ненужен. далее баш через execve себя убивает а на место себя ядро вставляет бинарник
нашей "команды" которая указана в строке. и полуается у нас начинает работать "команда"
а ее stdout ( дескриптор 1) указывае на file1

вот как под капотом выглядит механизм редиректа stdout процесса в файл у баш.

и тут вылезает очень тонкий момент. а именно. 
положим  я сижу в баш под юзером vasya
и я запускаю команду под sudo и делаю редирект в файл

    $ sudo -Hu temp > /tmp/2.txt

возникает вопрос кто будет владельцем файла 2.txt 
будет ли это vasya, или это temp или может это будет root?
правильный ответ овнером файла будет vasya. почему? ведь интуитивно кажется что
владельцем должен быть temp. однако нихуя. щас я разберу почему это нетак.

для начала разберу как работает sudo без редиректа

    $ sudo ./102.exe
наблюдаем через strace
вначале баш себя клонирует

    clone(child_stack=NULL, \
            flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, \
            child_tidptr=0x7f5027cdda10) = 31070
            
потом в дочернем процессе баш заменяет свой бинарник на 
бианарник /usr/bin/sudo

    execve("/usr/bin/sudo", ["sudo", "./102.exe"], 0x55ad028a1b10 /* 70 vars */) = 0

далее видно что sudo проверяет  чему равен umask
    umask(000)                  = 002
    umask(002)                  = 000
также sudo проверяет какая папка является текущей
    getcwd("/home/vasya/C", 4096) = 14

далее уже sudo себя клонирует

    clone(child_stack=NULL, \
          flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, \
          child_tidptr=0x7f2bb6d8af50) = 31071

и в дочернем процессе sudo заменяет себя на бинарник 102.exe

    execve("./102.exe", ["./102.exe"], 0x5619f4eafd30 /* 27 vars */
 
ну а это уже тело 102.exe

    write(1, "/home/vasya/C\n", 14)         = 14
 

тоесть при запуске команды через sudo  у нас происходит два клонирования.
баш клонирует себя и запускает в дочке sudo,  а sudo клонириует себя
и в дочке запускает уже команду.

бинарник /usr/bin/sudo имеет suid бит
    $ ls -1al /usr/bin/sudo
    -rwsr-xr-x 1 root root 149080 янв 19  2021 /usr/bin/sudo

это значит что (как я понимаю) приводит к тому что процесс в котором будет работать 
sudo он запускается не от vasya а от root. причем чтобы так было юзер который запускает
sudo необязан быть  в группе sudo. тоесть процесс с sudo реально стартует от имени root
а дальше прикол в коде самого sudo есть кусок котрый проверяет что за юзер его запустил.
и проверяет есть ли этот юзер в группе sudo. и если нет то он шлет нахер. 
таким образом suid бит он работает. и процесс успешно стартует от рута. но сам код 
suid проверяет является ли юзер участником группы sudo и если нет то сворачиыает 
шарманку.


а теперт расмотрим самый интеересный случай . мы запускаем команду через sudo
и делаем баш редирект

    $ id
    vasya
    $ sudo -H -u temp sleep > /tmp/1.txt
    
возникает вопрос кто будет владельцем файла 1.txt 
будет ли это vasya или будет ли это temp
ответ - владельцем будет vasya!

почему. потому что:
на первом этапе баш себя клонирует. и дочерний процесс  рабтает по прежнему
под vasya как и родителский процесс. далее баш в дочернем процессе создает файл 
/tmp/1.txt и поскольку процесс работает под vasya то владельцем файла будет vasya!
новый файл к процессу будет прикреплен скажем через дескриптор 3. 
далее баш копирует дескриптор  3 в дескриптор 1 через сисколл dup2
и удаляет дескритор 3. 
далее баш запускает sudo через execve
ядро видит что файл имеет suid бит и самостоятельно понимает что у процесса надо
поменяь юзера на root. далее начинает работать бинарник sudo,
он себя клонирует в дочерний процесс. при этом копируются и файл дескрипторы.
поэтому дочерний процесс от проесса sudo тожее имеет дескриптор 1 который смотрит на 
/tmp/1.txt.  далее наконец в этом процессе судо заменяет свой бинакрник через execve
на sleep. и таким макаром если бы sleep чтот высирал на stdout то запиь бы 
шла а файл. также надо сказать что так как процесс sudo имеет рут права то у него
есть права при клонировании запустить процесс sleep от имени temp
таким образом четко видно почему у нас процесс sleep будет выполняться от имени
юзера temp  и писать в файл /tmp/1.txt и при этом владельцем файла будет не temp
а будет vasya!!

и получаетс что если мы хотим чтобы команда под судо работала как temp
и писала в файл которым тоже владее temp то это надо запускать вот так

    $ sudo -H -u temp  bash -c " sleep 140  > /tmp/1.txt "
    
тогда это отработает вот как
баш клониует себя. процесс дочерний работает под васей. потом бащ заменяет свой
бианрник через execve на sudo при этом ядро видит что у судо есть suid и 
нетолько меняет бинракник но и владельца процесса меняет на root.
процесс  с судо себя клонирует и запускает дочерний процесс от имени temp
и меняет в дочернм прцоессе бинарник sudo на bash
баш себя клонирует в дочерний процесс и владелец процесса temp
также в дочернем процессе баш создает файл /tmp/1.txt
так как процессом владее temp то и файлом владеет temp
далее баш меняет бианрник баша на sleep через execve
конец истории.
показываю на примере

 
    $ id
    uid=1000(vasya) gid=1000(vasya) groups=1000(vasya)

    $  sudo -H -u temp  bash -c " sleep 140  > /tmp/123.txt "

смотрим дерево процессов
    $ ps aux | grep "sleep [0-9]"
    root      1701  sudo -H -u temp bash -c  sleep 140  > /tmp/123.txt 
    temp      1702  bash -c  sleep 140  > /tmp/123.txt 
    temp      1703  sleep 140

    $ pstree -Aspl 1703
    ...---bash(12142)---sudo(1701)---bash(1702)---sleep(1703)

тоесть теория совпла с практикой.
bash 12142 это головной процесс в котором я вбил команду. он работает под васей
    $ ps -p  12142  -o pid,uid
    PID   UID
    12142  1000

uid=1000 это vasya

процесс sudo 1701 это sudo работате под рутом
прцоесс bash 1702 это баш работает под temp
пцроесс sleep 1703 это sleep и работает под temp

проверяет кто владелец файла
    $ ls -1al /tmp/123.txt
    -rw-r--r-- 1 temp temp 0 дек 24 06:13 /tmp/123.txt

владелец temp
теория совпала с  спрактикой. 
тоеть  процесс sleep раобтае под юзером temp
и владелец файла /tmp/123.txt тоже temp




    
далее проверим вот что.   я создаю файл скажем 
с минимальными пермишнсами. скажем --x --x --  и я тут же пытаюсь 
стереть файл. можно ли это сделать. ответ конечно да.
потому что право на удалить файл зависит не от пермишнсов
файла а пермишнсов на папку в которой лежит файл.
поэтому если у процесса есть права создать файл. то
неважно какие права мы назначаем на файл мы можем его и удалить.
ну исключение если мы назначим файлу через 
    $ sudo chattr +i  file1
тотогда перед тем как удалить нужно снять этот атрибут

    

далее что тоже логично. 
вот у нас есть файл . уже создан.
и мы открыаем егго на запись.
мы неможем этого сделать если у файла стоять
пермишнсы которые запрещают в него запись

    


    
    
теперь рассмотрим очень важный вопрос
вот у нас есть процесс-1 и он читает из файла.
в это время процесс-2 открыает файл и обнуляет его скажем
через команду 
    $ : > file1
возникает вопрос что будет с чтением у процесса-1

значит во первых посмотрим как работает : > file1
прежде всего это баш процесс. посмотрим что он делает.

в первом терминале запускаем
    $ : > file1
а во втором терминале наблюдаем
    $ sudo strace -f -p 16114  -e openat
    openat(AT_FDCWD, "/tmp/47.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3

openat у нас открыывает файл. и также этот же сисколл создает файлы с нуля.
на счет AT_FDCWD. это означает текущая рабочая папка для процесса.
но если путь к файлу указан абсолютный а не относииельный то  ядро 
игнориует AT_FDCWD. 
флаг O_WRONLY говорит ядру что файл для процесса надо открыть только для записи. 
флаг  O_CREAT говорит ядру о том что если файла нет то его надо создать 
флаг O_TRUNC говорит ядру о том что если файл есть то нужно весь контент файла
удалить занулить стереть. тоесть все дата блоки файла будут переинциализррованы.
теперь переходим к нашей конктетной ситуации, файл у нас уже есть. значит O_CREAT
роли не играет , а вот флаг O_TRUNC играет рояль. именно он и приводит к тому
что контент файла обнуляеется. 
таким образом стало понято что конкретно делает баш по данной компнде
и стало понятно как занулить файл через C программу.
теперь переходим к вопросу как из C программы можно прочитать контент из файла.
делается это например через read

    char buf[1];
    ssize_t rr = read(fd, buf, 1);
    printf ("символ=%s, число считаных байт=%zd \n", buf, rr );
    
здесь я замечу таакую вещь с которой я поебался пока не понял в чем дело.
данные возвращаются не в rr! а они возвращаются в buf!
в rr возвращается количество прочитанных байтов. кстати на основе rr
можно понять что либо мы дошли до конца файла или вообще чтото не так.
если rr вернул значение 0 знаит пиздец. небыло считано ничего.

кстати замечу что ssize_t в принтф можно напечатать через %zd
значит fd - дескриптор файла из котрого читаем.
buf это буфер в который читаем, тоесть мы читаем из диска в память.
последний параметр это число байт которое надо считать.
и тут возникает важнейший вопрос - файл он большой по размеру. как нам указать 
откуда из файла читать? команда read как видно не иметт такого параметра.
и тут оказывается вот что. чтение происходит на основе так называемого оффсета. 
дело в том что когда мы заказываем открытие файла то в ядре есть одна или несколко
таблиц будем считат что одна. в этой таблице (таблица открытых файлов) хранятся
файлоые дескрипторы, номера процессов, имена файлов, и для кжадого дескриптора
хранится оффсет. офссети это как курсор внутри файла. соотвесвтенно когда
из юзер программы поступает запрос выдать  1 байт из файла с дескриптором fd
то ядро идет в файл делает смещение на величине оффсет. читает 1 байт. выдает 
в ответ для read  и в таблице меняет оффсет на +1.
таким образом команда read она никак не управляет офсетом. им управляет ядро. 
команду рид можно перевести так : ядро прочитай мне 1 байт из файла который лежит
за дескриптором fd начиная с оффсета который у тебя там хранится в твоей таблице
открытых файлов.  однако при желании можно управлять оффсетом. через функцию 
lseek

    int position = lseek(fd, A, B);
    
эта команда позволяет сместить оффсет, расчет идет такой берется точка осчета B
внутри файл и относительно B идет смещение на A байт.
для B используются спец константы

       SEEK_SET = обозначает что отсчет ведем от начала файла
              

       SEEK_CUR = обозначает что отсчет ведем от текущего офсета

       SEEK_END = обозначает что отсчет ведем от конца файла
       
       
есть еще  SEEK_DATA и SEEK_HOLE но там как то сложно. щас не буду их 
разбирать.

тогда например можно узнать какой текущий оффсет  у файла в таблице
        int position = lseek(fd, 0, SEEK_CUR);
а вот  так можно задать оффсет от начала файла
тоесть 10-ый символ от начала файла
        int position = lseek(fd, 10, SEEK_SET);
а вот так можно задать оффсет от конца файла
тоесть 10-ый символ от  конца файла
        int position = lseek(fd, -10, SEEK_END);


        

расмотрим пример. я возьму файл с контентом

    $ cat ./1.txt
    123456789abcdefgh
    

    $ stat --format="%n %s"  ~/temp/\!28/1.txt
    /home/vasya/temp/!28/1.txt 17

видно что файл размером 17 байт. 
это значит что у него оффсет лежит в диапазоне [0,16]
    
прочитаем файл посимвольно
    
$ cat 112.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса =%i \n", getpid() );


int flags = O_RDONLY;
char *pathname = "/home/vasya/temp/!28/1.txt";
int fd = open(pathname, flags);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}

printf ("номер дескриптора = %i \n", fd);


int num=0;
char buf[1];

while ( num<=20 ) {

    int offset = lseek(fd,0,SEEK_CUR);
    ssize_t rr = read(fd, buf, 1);
    printf ("читаю из файла: оффсет=%i, символ=%s, число прочитанных байт=%zd\n", offset, buf, rr );
    num++;
    sleep (5);
}


close(fd);
exit (0);

}




$ ./112.exe  
номер процесса =14191 
номер дескриптора = 3 
читаю из файла: оффсет=0, символ=1, число прочитанных байт=1
читаю из файла: оффсет=1, символ=2, число прочитанных байт=1
читаю из файла: оффсет=2, символ=3, число прочитанных байт=1
читаю из файла: оффсет=3, символ=4, число прочитанных байт=1
читаю из файла: оффсет=4, символ=5, число прочитанных байт=1
читаю из файла: оффсет=5, символ=6, число прочитанных байт=1
читаю из файла: оффсет=6, символ=7, число прочитанных байт=1
читаю из файла: оффсет=7, символ=8, число прочитанных байт=1
читаю из файла: оффсет=8, символ=9, число прочитанных байт=1
читаю из файла: оффсет=9, символ=a, число прочитанных байт=1
читаю из файла: оффсет=10, символ=b, число прочитанных байт=1
читаю из файла: оффсет=11, символ=c, число прочитанных байт=1
читаю из файла: оффсет=12, символ=d, число прочитанных байт=1
читаю из файла: оффсет=13, символ=e, число прочитанных байт=1
читаю из файла: оффсет=14, символ=f, число прочитанных байт=1
читаю из файла: оффсет=15, символ=g, число прочитанных байт=1
читаю из файла: оффсет=16, символ=h, число прочитанных байт=1
читаю из файла: оффсет=17, символ=h, число прочитанных байт=0
читаю из файла: оффсет=17, символ=h, число прочитанных байт=0
читаю из файла: оффсет=17, символ=h, число прочитанных байт=0
читаю из файла: оффсет=17, символ=h, число прочитанных байт=0


видно то что при открытти файла ядро автоматом выставялет у себя
офсет =0, тоесть самому это делать ненадо,
далее при чтении через read когда мы не управляем сами 
офсетом то ядро при чтении каждый раз прибавляет автоматом само
офсет на ту величину на которую мы читаем, то есть прочитали мы 1 байт
и ядро автоматом увелиичивает офсет на 1. 

далее  виден очень интересный момент
последний реальный оффсет это 16. мы считываем этот 16-ый офсет
и  ядро прибавляет само оффсет до 17. хотя такого офсета уже нет. 
при этом у нас read возвращает что число прочитаных байт 0. 
и далее ядро уже оффсет не прибавляет.
таким образом когда мы не руководим офсетом то ядро превышает 
на один реальный поседний офсет. но дальше уже его не двигает
при запросе на чтение. а read возвращает число считанный байт как 0 
в этом случае. таикм образом когда мы читаем файл через read то у него
нет никаких проблем с чтением файла до усрачки до бесконечности.
просто когда ядро выставит уже несущетвубйщий офсет то рид будет 
все равно его читать. возвращая нам инфо о том что число считанных байт 0.
итак у read нет никаких проблем с чтением до усрачки до бесконечности.
он просто посылает запрос в ядро прочитать 1 байт. получил чтото вответ хорошо..
не получил ему похер. он может это делать до бескончечности. едтинсвтерннное что 
он нам просигнализиуерует что код возврата 0. и тут уже мы сами должны проверять
о том что это ноль и дальше чиать ненадо. а ядро прибавляет оффсет до конца
и даже больше. интересно оно прибавляет оффсет на +1 дальше конца 
или больше? проверим. будем читать по 5 символов за раз


$ cat 112.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса =%i \n", getpid() );


int flags = O_RDONLY;
char *pathname = "/home/vasya/temp/!28/1.txt";
int fd = open(pathname, flags);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}

printf ("номер дескриптора = %i \n", fd);


int num=0;
int dlina=5;
char buf[dlina];

while ( num<=5 ) {

    int offset = lseek(fd,0,SEEK_CUR);
    ssize_t rr = read(fd, buf, dlina);
    printf ("читаю из файла: оффсет=%i, символ=%s, число прочитанных байт=%zd\n", offset, buf, rr );
    num++;
    sleep (2);
}


close(fd);
exit (0);

}




$ ./112.exe  
номер процесса =17424 
номер дескриптора = 3 
читаю из файла: оффсет=0, символ=12345, число прочитанных байт=5
читаю из файла: оффсет=5, символ=6789a, число прочитанных байт=5
читаю из файла: оффсет=10, символ=bcdef, число прочитанных байт=5
читаю из файла: оффсет=15, символ=ghdef, число прочитанных байт=2
читаю из файла: оффсет=17, символ=ghdef, число прочитанных байт=0
читаю из файла: оффсет=17, символ=ghdef, число прочитанных байт=0

видно что несмотря на то что мы читали по 5 символов. но ядро
конечный оффсет выставило +1 от конечного реального офсета 16.

виден еще интересный момент. вспомним как выглядит файл 

    $ cat 1.txt
    123456789abcdefgh

делаю его на 5символов группы

    12345 | 6789a | bcdef | gh


соотвеавтеннно мы успешно считываем bcdef у нас  buf=bcdef
далее мы заказываем прочитать следущие 5 символов
у нас считывается два и они кладутся в buf  а те оставщиеся три символа 
в buf они не трогаются.  и витоге у нас в buf лежит ghdef
как это и видно  в распечатке и read нам сообщает что он прочитал не 5 а только 2 
символа. таким макаром если бы я это проверял что rr < 5 то я бы понял что 
конец файла достигнут. ядро меняет офсет с 15 до 17 и далее уже read 
сообщает что было прочитано 0. и таким макаром я могу продожлжать чтение до 
бесконечности. нет никаких прблем с этим при этом в buf уже ничего не меняется.
там так и лежит ghdef
тепрь понятно что с офсетом когда достигнут конце файла, он равен 
    (последний реальный офсет  + 1)
и он дальше ядром не меняется
и что read может продолжать читать до бесконечнсти не возвращая ничего
и сообщая что число прочиатнных байт равно 0

теперь через lseek будем управлять сами офсетом и прочитаем
символы с оффсетом 0 2 4 6


$ cat 112.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса =%i \n", getpid() );


int flags = O_RDONLY;
char *pathname = "/home/vasya/temp/!28/1.txt";
int fd = open(pathname, flags);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}

printf ("номер дескриптора = %i \n", fd);


int num=0;          // переменная цикла
int dlina=1;        // сколько символов за раз считываем
int offset_step=2;  // промежуток между офсетами
char buf[dlina];    // куда записываем символы из файла

while ( num<=5 ) {

    int cur_offset = lseek(fd,0,SEEK_CUR);
    ssize_t rr = read(fd, buf, dlina);
    printf ("читаю из файла: оффсет=%i, символ=%s, число прочитанных байт=%zd\n", cur_offset, buf, rr );
    num ++;
    cur_offset += offset_step;
    lseek(fd,cur_offset,SEEK_SET);
    sleep (2);
}


close(fd);
exit (0);

}





$ ./112.exe  
номер процесса =21009 
номер дескриптора = 3 
читаю из файла: оффсет=0, символ=1, число прочитанных байт=1
читаю из файла: оффсет=2, символ=3, число прочитанных байт=1
читаю из файла: оффсет=4, символ=5, число прочитанных байт=1
читаю из файла: оффсет=6, символ=7, число прочитанных байт=1
читаю из файла: оффсет=8, символ=9, число прочитанных байт=1
читаю из файла: оффсет=10, символ=b, число прочитанных байт=1


напомню содержимое файла
    $ cat 1.txt
    123456789abcdefgh


из чего видно что программа отработала как нужно.

значит у нас штука которая меняла оффсет это 
     lseek(fd,cur_offset,SEEK_SET);
    
при этом cur_offset принимало значения = 0, 2, 4, 6, 8
тоесть унас была последовтельност
    lseek(fd, 0, SEEK_SET);
    lseek(fd, 2, SEEK_SET);
    lseek(fd, 4, SEEK_SET);
    lseek(fd, 6, SEEK_SET);
    lseek(fd, 8, SEEK_SET);
    
тоесть установи оффсет на 
    SEEK_SET+0    
    SEEK_SET+2    
    SEEK_SET+4    
    SEEK_SET+6
    SEEK_SET+8
    
так как SEEK_SET это начало файлатоеесть это оффсет 0 то получаем
    0+0 = 0    
    0+2 = 2   
    0+4 = 4   
    0+6 = 6
    0+8 = 8
    
что и вдно из печати программы в плане номера оффсета
тоеость в этой команде
    lseek(fd, N, SEEK_SET);
нужно вставлять N равный тожму оффсету который мы хотим печатать


еще добавлю про оффсет. 
если мы в процессе выполнили open то  в таблицу открытых файлов ядро вносит - имя
файла, дескриптор, номер процесса, текущий оффсет. если мы из этого же файла
еще выполним +1 open то ядро создаст новый дескриптор и для него новую запись
в таблице открытых файлов и там будет свой индивиудуальный оффсет котоырй не завсит
от певрого оффсета. тоесть кажый open для одного и  тогоже файла обуслуживатется 
своим дескрипттором и своим оффсетом.  если же мы для процесса через сисколл dup3
проклонируем один дескриптор в другой дескриптор то оба этих дескриптора будут
обслуживаться одним оффсетом. проверять я это не буду. поверю на слово.

далее про оффсет.
мы знаем как его узнать  изнутри программы.
а как нам узнать текущий офсет для открытого дескриптора в каком то процессе.
можно сделать так
нужно выяснить какой дескриптор отвечает за наш файл
для этого идем в /proc/pid/fd
например я знаю процесс и знаю какой файл открыт им

    $ ls -1al /proc/17947/fd | grep txt
    lr-x------ 1    root root    9 -> /home/vasya/temp/!28/kubernetes.txt

значит мы нашли дескриптор это 9
теперь идем в другую папку /proc/pid/fdinfo/9

    $ cat /proc/17947/fdinfo/9
    pos:	4096
    flags:	0104000
    mnt_id:	32


и вот 
    pos:  4096 
это и есть оффсет текущий для данного файла в данном дескрипторе


также есть   другой вариант. через lsof  -o

    $ sudo lsof -o -p 17947 2>/dev/null| grep -E "OFFSET|\.txt"
    COMMAND   PID USER   FD   TYPE   DEVICE  OFFSET     NODE NAME
    mc      17947 root    9r   REG   259,2   0t4096 15074481 /home/vasya/temp/!28/kubernetes.txt

и в столбике OFFSET указан тотже самый оффсет
а в столбике FD указан дескриптор

итак с теперь мы умеем узнавать оффсет для дескриптора как изунти программы
так и снаружи из комдной строки

теперь можно узнать ответ на вопрос а что будем с чтением в процессе-1
если процесс-2 обнулил файл. 
я считаю будет вот что. пусть первый процесс читает из файла.
пусть для простоты он это делает по одному символу за раз и оффсетом не управляет.
оффсетом управляет ядро.
как толлько мы через второй процесс обнулим файл. то ядро которое это же и делало
тепер знает что длина файла ноль.  и значит макс оффсет ядро сразу выставит как
    ( макс реальный оффсет +1 ) 
то есть оффсет будет выставлен в 1.
и при этом read начнет сразу возвращать пустоту в плане символов и то что
количетство считанных байтов 0. и так будет до бесконечности.


$ cat 112.c 
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса =%i \n", getpid() );


int flags = O_RDONLY;
char *pathname = "/home/vasya/temp/!28/1.txt";
int fd = open(pathname, flags);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}

printf ("номер дескриптора = %i \n", fd);


int num=0;          // переменная цикла
int dlina=1;        // сколько символов за раз считываем
int offset_step=1;  // промежуток между офсетами
char buf[dlina];    // куда записываем символы из файла

while ( num<=5 ) {

    int cur_offset = lseek(fd,0,SEEK_CUR);
    ssize_t rr = read(fd, buf, dlina);
    printf ("читаю из файла: оффсет=%i, символ=%s, число прочитанных байт=%zd\n", cur_offset, buf, rr );
    num ++;
    cur_offset += offset_step;
    lseek(fd,cur_offset,SEEK_SET);
    sleep (3);
}


close(fd);
exit (0);

}





$ echo "исходный файл" $(cat ~/temp/\!28/1.txt); ./112.exe 
исходный файл 123456789abcdefgh
номер процесса =25617 
номер дескриптора = 3 
читаю из файла: оффсет=0, символ=1, число прочитанных байт=1
читаю из файла: оффсет=1, символ=2, число прочитанных байт=1

<-----> здесь была запущена команда в другом терминале $ > ~/temp/\!28/1.txt 

читаю из файла: оффсет=2, символ=2, число прочитанных байт=0
читаю из файла: оффсет=3, символ=2, число прочитанных байт=0
читаю из файла: оффсет=4, символ=2, число прочитанных байт=0
читаю из файла: оффсет=5, символ=2, число прочитанных байт=0

здесь тоже увиден интеересный эффект. так как я сам управляю в
программе оффсетом то ядро без проблем мне пзволяет выставлять
оффсет наскттолько большой насколлько я хочу. причем неважно что в
файле такого оффсета нет. нет проблем. просто при этом read 
будет возвращать ничего. и поэтому buf не меняется. он застыл на "2"
поэтому печатается "2"  и read вовзаращает что было прочитано 0 байт.
таким образом после обнуления файла попытка чтения через read при любои выставленном
оффсете будет возвращать ничего. и будет возврашать что число считатнных байт 0.
если программа процесса  1 этопроверяет то она это заметит. а если не проверяет
то чтение будет работаь до бескнечности но ничего не вовзращать.
посколльку программы типовые утилиты линукса написано умно то уверен что 
они проверяют то что read возврашает 0 байт. так что на практике я думаю что 
утилиты прекратят сразу чтение.и даже наверное высрут на экране какюу то ошибку.
проверим.

я запускаю тейл

    $ tail -f ./1.txt 
    1234567890abcdefgh

и сдругого терминала обнуляю файл и получаю на экране

 
    $ tail -f ./1.txt 
    1234567890abcdefgh
    tail: ./1.txt: file truncated

тоесть тейл просек в чем дело.

опять же повторю что проверить факт что файл вдруг уменьшился легко 
если мы читаем файл через read то надо после каждой транзакции чтения проверяеть
его код возврата. если он стал ноль. значит мы либо достигли конца файла
либо файл был неожиданно обнулен другим процессом.

в целом получается в плане вот что. положим у нас есть куча процессов
которые открыли один и тот же файл одноверменно и на чтение и на запись.
даже в одном процессе может быть открыт файл через раздельные open одноврменно 
и на чтение и на запись. так вот с этой точки зрения все достаточно просто получается.
каждый дескриптор имеет свой индивиудальный оффсет. за ним следит либо ядро
либо мы сами его таскаем туда и сюда. и каждый запрос на чтение выгляди так:
    - эй ядро это я сисколл read. прочти мне из файла который сидит
    за моим дескриптором столько то байт начиная с текущего оффсета. 
и все. процесс больше ничего не волнует. далее ядро берет файл. отступает в нем
на текущий оффсет и если оффсет нереальный то ядро вернет дулю. и значит read 
получит от ядра пустоту. и число байт счтанных 0. а если оффсет реалльный то 
ядро вернет байты котрые хранятся в районе этого оффсета. рид получит от ядра байты
и число считаныхх байт не равное нулю. если рид закаал считать 5 байт от текущего 
офсета а у нас осталось только два байта а потом конец файла то ядро веренут риду
два байта. и число байт считанных выставит равно 2. 
так что вся работа ложится на ядро.  а ядро смотрит по факту  в файл. в заказанный оффсет.
если там чтото есть то оно отдает. если есть частично отдает частично. если 
ничего нет то отдает ничего.  тоесть  файл похож на склад с полками.
заказчик ( read) говорит ядру мне 10 коробок начиная с полки 12. и программу
больше ничего не касается. ядро идет на склад. и смотрит ест ли вообще полка 10.
и далее с нее начинает выгреабать ящщики. если полки нет. то в ответ null.
если есть частично данных то отдаст частино. если есть полный набор отдаст полный набор.
при этом в разных частях файла в этот момент может происходит массировнная движуха.
тоесть другие процессы в этот момент могут менят содержимое файла в разных его 
оффсетах. если частьпорцессов открыла файл через O_DIRECT а часть нет
то это осложняет. если же все открыли файл без O_DIRECT 
это упрощает. так как они все будут рабоать с единым кешем ядра. 

итак с чтением и неожианным обнулением разобрались.


перехожу к следующему вопросу.  положим процесс-1 пишет в файл.
а другой процессс взял его и обнулил. что будет.
и тут есть два случая. один случай это когда у нас файл в процессе-1
открыт без флага O_APPEND ( что кстати соотвветствует в баше ситуации
когда мы заредиректили в файл через > )
а второй случай это когда процесс-1 открыл файл с флагом O_APPEND (что 
кстати  в баше соответсвует ситации когда мы сделали редирект через >> )

баш я привел чисто для справки потому что неважно какой процесс открыл 
файл на чтение, это может бытт баш а может ллюбая программа например 
моя самописная на C которая к бащу никакого отншения не имеет вообще.
бащ приведен просто для расширения кругозора чтобы было понимание
как это воспроизвести с помощью баша.

кстати то что в баще это так очен легко провериь
в первом  терминале запускаем
    $ : > 1.txt
а во втором ловим через strace и мы увидим
    openat(AT_FDCWD, "2.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
тоесть видно что openat  в этом случае запущен без O_APPEND

или 
    $ : >> 1.txt
на втором терминале увидим
    openat(AT_FDCWD, "2.txt", O_WRONLY|O_CREAT|O_APPEND, 0666) = 3
видно что в этом случае openat запущен через O_APPEND
кстати в обоих случая баш проставляет флаг O_CREAT
это значит что оба случая создадут файл если его нет.

я бы словами охарактирозвал обе эти команды вот как
работают
    $ true > 1.txt
во первых так как true это встроенная команда в баш то дальнйшие дейстивя
выполняется в рамках текущего бащ процесса, если бы true была внешняя
команда то баш бы себя склонировал и далее бы работал в клоне.
так или иначе баш запустит сисколл openat 
        openat(AT_FDCWD, "2.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
который говорит ядру - эй ядро  открой файл 1.txt на запись, 
если файла нет то создай его,
а если файл есть то уменьши размер его тела до нуля.
ядро это все делает. создает дескриптор 3 прикреплеяет его к процессу.
создает запись в таблице открытых файлов. и устанвливает оффсет равным 0.
далее баш клонирует дескриптор 3 в дескриптор 1 через dup2
далее баш закрывает дескритптор 3. ибо он уже нахер ненужен.
и у нас процесс с его stdout (дескриптор 1) начинает ссмотреть в файл.
далее если это встроенный билтин типа true то все что он высрет на 
stdout полетит в файл в начиная с оффсета 0. в данном случае true
ничего на stdout не высрает поэтому на этом все это и закончится. 
если же это внешняя команда то баш запускает execve и заменяет 
свой бинарник на бинраник внешней команды. и все что она срет на 1 
упадет в файл начиная с оффсета 1. например эт может быть команда ls
важно то что если файл есть то на какое то мгновение его тело 
станет равно ноль байтов по длинне. 


    $ true >> 1.txt
эта хрень рабтает точно также за исключением того что
тело файла не зануляется. и все что из команды будет высрано на 1 
оно будет добавлено в хвост этого файла. а что если у нас сразу 
два процесса или сто процсов открыли таким макармо один файл и все вместе
срут ему в хвост? как они определяют этот хвост. да очень просто. 
хвост для каждого процесса определяется актульным хвостом файла на моент создания
этого файла. чем позжже очерной процесс открывает этот файл на запсь тем 
для него этот хвост все правее. а потом каждоая программа просто добавлеяет +1
к оффсету и пишет свои байты. покаызаю

в первом терминале я запускаю
    $ while  true; do echo "a" >>4.txt; sleep 3; done
во втором терминале я запуска   
    $ while  true; do echo "b" >>4.txt; sleep 3; done
в третьем терминале я азпускаю      
    $ while  true; do echo "c" >>4.txt; sleep 3; done
в четевртом терминале я слежу за 4.txt
    $ tail -f 4.txt 

a
a
a
===> в этот момент был запущен второй терминал
a
b
a
b
a
b
a
b
a
b
a
b
a
b
a
b
a
b
a
b
a
b
a
b
======> в этот момент был запущен третий терминал
c
a
b
c
a
b
c

таким макаром эти три процесса ">>" будут драться
за запись в хвост файла
хотя это эксперимент такой хреновй потому что это не три процесса
которые висят и пишут. дело ведь в том что echo "a" это процесс который
запишет только одну букву а пото он подыхает и следущий echo "a"
это уже другой процесс который имеет другой дескриптор и прочее.


ладно. перйдем к просмотру того же самого но когда я это делаю
чрез программу на C

$ cat 109.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса = %i \n", getpid());

mode_t mask = umask (0);


int flags = O_CREAT|O_WRONLY|O_TRUNC|O_APPEND;
char *pathname = "/tmp/109.txt";
mode_t mode=0655;

int fd = open(pathname, flags, mode);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}


int num = 1;

while ( num <=30 ) {

    dprintf (fd, "K%i", num);
    int position = lseek (fd, 0, SEEK_CUR);
    printf ("символ=K%i, оффсет=%i \n", num, position);
    num++;
    sleep(10);

}



close(fd);
exit (0);

}


программа открывает\создает файл "/tmp/109.txt" с флагом O_APPEND
и начинает в него пихать данные 
    
    $ cat ./109.txt 
    K1K2K3K4K5K6K7K8K9K10K11K12K13K14K15K16K17K18K19K20K21K22K23K24K25K26K27K28K29K30

причем делает это с паузой.

итак 
запускаю эту программу. 
и в середине обнуляю этот файл
с другого терминала

$ ./109.exe
номер процесса = 24205 
символ=K1, оффсет=2 
символ=K2, оффсет=4 
символ=K3, оффсет=6 
символ=K4, оффсет=8 
символ=K5, оффсет=10 
         <----- здесь я обнулил файл  с другого терминала
символ=K6, оффсет=2 
символ=K7, оффсет=4 
символ=K8, оффсет=6 
символ=K9, оффсет=8 
символ=K10, оффсет=11 

как в итоге выглядит суммарно итоговый файл
    $ cat /tmp/109.txt
    K6K7K8K9K10
    
что мы видим. мы видим что содержимое файла
было полностью обнулено а новые данные стали записываться сначала
файла. и оффсет был ядром обнулен тоже. 
из чего я делаю вывод что если один процесс открыл файл с флагом O_APPEND
и пишет  в него то мы можем легко обнулить этот файл путем того что
с друогого процесса запульнем командой  $  > file
при таких раскладах скажем можно обрезать лог файлы если они разрослись
без остановки\перезагрузки процесса который пишет в лог файл. но это 
верно только если процесс кторый пишет открыл файл с ключом O_APPEND

теперь я возьму туже самую программу на C. но уберу из нее флаг O_APPEND
тоесть  вот  так стало 
    int flags = O_CREAT|O_WRONLY|O_TRUNC;

и проделаю тоже самое

$ ./109.exe
номер процесса = 25936 
символ=K1, оффсет=2 
символ=K2, оффсет=4 
символ=K3, оффсет=6 
символ=K4, оффсет=8 
символ=K5, оффсет=10 
         <----- здесь я обнулил файл  с другого терминала
символ=K6, оффсет=12 
символ=K7, оффсет=14 
символ=K8, оффсет=16 
символ=K9, оффсет=18 
символ=K10, оффсет=21 
символ=K11, оффсет=24 
символ=K12, оффсет=27 


 
смотрю что в файле в итоге
    $ cat 109.txt 
    ..........K6K7K8K9K10K11K12

здесь точками я заменил ноль байты 0x0
значит из текста программы видно что оффсет текущий вычисляется
уже после того как были напечатаны очередны два символа. поэтому
чтобы узнать в каком оффсете они были напечаатны надо отнять два. 
так что 
    символ=K6, оффсет=12 
означает что K6 печаталось начиная с 10-го оффсета.
и видно что в файле так и есть. 
значит также видно что после того как файл обнулии то 
офссет продолжал ядром увеличиватья в отличие от преддыдудушего
примера когда ядро сразу и офсет обнулило. также видно 
что все те байты которые были в файле до обнуления их ядро 
заполнило ноль байтами. 
в этом и есть огромное отличие от предыдущено случая. 
тоесть как толко мы файл обнуии то ядро все те байты которые были у файла 
она заменила на ноль байты. а программа продолжила вбивать даннные 
с того оффсета на котором закончила. поэтому в итоге размер итогоового 
файла он не уменьшился ни на грош. просто те данные котрые были в файле 
до обнуления они были заменены на ноль байты.

таким образом я резюмирую итогово.  утверждать что во всех случаях можно
уменьшить размер файла в который пишет некоторый процесс это брехня. 
в одном случае когда файл открыт пишушщим процессом с опцией O_APPEND
это дейсттветльно уменьшит раазмер файлла до нуля и заппись пойдет с начала
файла. а если файл открыт без флага O_APPEND 
то обнуление файла неприведет к уменьшению его размера ни на грош. единсвтенноре
что произойдет это то что все данные будут заменены на ноль байты. а запись 
продолжится с того офсета на котором был процесс до обнуления.

далее я запустил две программы однвовременно пишут в
файл. один процесс открыл с O_APPEND а второй прцоесс открыл без.
тот процесс который с O_APPEND он пишет "O1"
а тот который без он пишет "N1"

$ ./109-oappend.exe
номер процесса = 30462 
символ=K1, оффсет=2 
символ=K2, оффсет=4 
символ=K3, оффсет=6 
символ=K4, оффсет=4 
<--- вот здесь обнулил файл
символ=K5, оффсет=2 
символ=K6, оффсет=8 
символ=K7, оффсет=10 
символ=K8, оффсет=12 
символ=K9, оффсет=14 
символ=K10, оффсет=16 
символ=K11, оффсет=18 
символ=K12, оффсет=20 
символ=K13, оффсет=22 


$ ./109-noappend.exe
номер процесса = 30544 
символ=K1, оффсет=2 
символ=K2, оффсет=4 
символ=K3, оффсет=6 
символ=K4, оффсет=8 
<--- обнулил файл примерно здесь
символ=K5, оффсет=10 
символ=K6, оффсет=12 
символ=K7, оффсет=14 
символ=K8, оффсет=16 
символ=K9, оффсет=18 
символ=K10, оффсет=20 
символ=K11, оффсет=22 

в итоге имеем
$ cat 109.txt 
O1..N1N1N1N1N1N1N1N1N1

и вот видно что тот процесс который открыл файл с O_APPEND
он начал писать в файл с самого начала с нулевого оффсета.
а процесс который писал в файл без O_APPEND он продолжил
писать с того оффсета который был до обнуения. а всеоффсеты
которые были до они были запполнены ноль байтами 0x0

тоесть мы получили опят же полностю логичный резульат. соовествующий
той теории которую описал выше.

щас я сделаю еще одну штуку.
я удалю файл. 
потом я создаем его без O_APPEND
потом я руками установлю некоторый оффсет и задам туда
запись. я полагаю что именно в этом случае ядро заполнит нулями все 
те оффсеты которых в файле просто нет. 
тоесть файл имеет изначально ноль офсетов заполенных. его размер нулевой
а мы просим программу начать писать сразу с 10-го офффсета.


$ cat 113.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса = %i \n", getpid());

mode_t mask = umask (0);
//umask (mask);
//printf("umask = %o\n",mask);





int flags = O_CREAT|O_WRONLY|O_TRUNC;
char *pathname = "/tmp/113.txt";
mode_t mode=0655;

int fd = open(pathname, flags, mode);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}


int num = 1;
int offset=10;

while ( num <=2 ) {

    int position = lseek (fd,offset, SEEK_SET);
    dprintf (fd, "O1");
    printf ("символ=O1, оффсет=%i \n", position);
    num++;
    offset += 2;
    sleep(10);

}



close(fd);
exit (0);

}




$ gcc -o 113.exe 113.c
$ ./113.exe
номер процесса = 1395 
символ=O1, оффсет=10 
символ=O1, оффсет=12 

смотрим что в файле
    $ sed 's/\x00/./g' /tmp/113.txt
    ..........O1O1
чтобы распечатать я заменил ноль байты на точки.
но суть раскрылась.

суть состоит в том что еслимы открыли файл на запись
без O_APPEND и указали оффсет который по факту нахоодится за реальным концом 
файла то ядро записывает в файл ровно столлько ноль байтов чтобы добиться
того чтобы заказанный нами оффсет стал реальным концом файла.
тоесть вот наш пример. у нас изнаально файла нет. он создается. у этого файла
даже нет нулевого офффсета. а я заказываю делать запись в оффсет 10.
которого физически в файле нет. поэтому ядро берет и пишем само в файл 
девять ноль байтов которые оббразуют девять реальных оффсетов. 
и только потом ядро пишет в оффсет 10 наш заказанный символ "01"
поэтому у нас в файле девять ноль байтов котоыре мы не заказывади ядру
он их сам туда напихал а уже с 10го оффсета уже на символ.

теперь открою файл с O_APPEND тоже пустой. и пороююу сделат тоже самое
записать сразу  в 10-ый оффсет

    $ ./113.exe
    номер процесса = 3548 
    символ=O1, оффсет=10 
    символ=O1, оффсет=12 
    
    $ sed 's/\x00/./g' /tmp/113.txt
    O1O1
    
видно что запись  идет с начала файла независимо от того
что я указал офсет 10.

тут возниукает вопрос . то ли мой заказ не работает. то  ли ядро
игнорирует мой офсет.

меняю программу чтобы это порверить

[vasya@lenovo C]$ cat 113.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса = %i \n", getpid());

mode_t mask = umask (111);
//umask (mask);
//printf("umask = %o\n",mask);





int flags = O_CREAT|O_WRONLY|O_APPEND;
char *pathname = "/tmp/113.txt";
mode_t mode=0655;

int fd = open(pathname, flags, mode);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}


int num = 1;
int offset=10;

while ( num <=2 ) {

    int position = lseek (fd,offset, SEEK_SET);
    int off_cur  = lseek (fd,offset, SEEK_SET);
    dprintf (fd, "O1");
    printf ("символ=O1, заказал оффсет=%i, получил офсет=%i \n", position, off_cur);
    num++;
    offset += 2;
    sleep(10);

}



close(fd);
exit (0);

}



$ ./113.exe
номер процесса = 4098 
символ=O1, заказал оффсет=10, получил офсет=10 
символ=O1, заказал оффсет=12, получил офсет=12 

кхм... получется что просто ядро игнориует мой заказ офсета.
и пихает символы сначала файла.




вернусь случаю когда я открыл без O_APPEND
но закаызваюь писать туда где еще нет реально офффсета. пример
причем я убираю флаг O_TRUNC .
полжоим у меня есть файл 

    A1A2A3

я закаызваю записать B1 в оффсет 8
я считаю что результат будет такой

    A1A2A3..B1

тоесть все те оффсеты которых слева нет ядро добьет ноль байтами.
итак имею подготовленный файл

    $ cat 113.txt
    A1A2A3

имею проргрмму
$ cat 113.c
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <errno.h> // for the definition of errno



int main(void)
{


printf ("номер процесса = %i \n", getpid());

mode_t mask = umask (111);
//umask (mask);
//printf("umask = %o\n",mask);





int flags = O_WRONLY;
char *pathname = "/tmp/113.txt";
mode_t mode=0655;

int fd = open(pathname, flags, mode);


if (fd < 0) {
      perror("Creation error");
      printf("An error occurred. errno set to %d\n", errno);
      exit(1);

}


int num = 1;
int offset=8;

while ( num <=1 ) {

    int position = lseek (fd,offset, SEEK_SET);
    int off_cur  = lseek (fd,offset, SEEK_SET);
    dprintf (fd, "O1");
    printf ("символ=O1, заказал оффсет=%i, получил офсет=%i \n", position, off_cur);
    num++;
    offset += 2;
    sleep(10);

}



запускаю
$ ./113.exe
номер процесса = 5783 
символ=O1, заказал оффсет=8, получил офсет=8 

итговый файл
    $ sed 's/\x00/./g' /tmp/113.txt
    A1A2A3..O1
    
итак да. теория совплаа с практикой.
те оффсеты которых небыло слева их ядро заменило ноль байтами.

получается интресная вещь. вот мы отрли сущесвующий файл.
причем без O_APPEND ключа. так вот хотя даже мы так сделали
это не означает что мы неможем увеличивать файл с хвоста как 
этоможет интуиативно казаться. мы можем увиличивать файл
с хвоста но для этого надо чтобы мы начали писать с офффсета
равного (хвостовой оффсет +1)
тоесть елси у нас есть файл и у него посоедний реальный оффсет 
нахоится по адресу 7. то чтобы к его хвосту присобачить символ
надо указать при печати оффсет 7+1=8.
а если мы укажем сразу оффсет 9. то ядро в офсете 8 поместит ноль байт.
а уже наш байт в офсете 9.

тогда неочень понятно зачем нужен ключ O_APPEND если и без него 
можно файл растить с хвоста.

из описания O_APPEND (man  2 open)
  O_APPEND
      The  file is opened in append mode.  Before each write(2), 
      the file offset is positioned at the end of the file, 
      as if with lseek(2).  The modification of
      the file offset and the write operation are performed 
      as a single atomic step.
      O_APPEND may lead to corrupted files on NFS filesystems 
      if more than one process appends data to a file at once.  
      This is because  NFS  does  not  support
      appending to a file, so the client kernel has to simulate it, 
      which can't be done without a race condition.

я прихожу к выводу что воможно если указан этот флаг то все наши попытки 
руками указывать offset через lseek неимеют никакого значения. 
ядро при каждый операции записи автоматом ищет конец файла и исправляет 
оффсет четко на конец файла. таким образом наши ручные потуги lseek
неимеют никакой силы. тоеть O_APPEND флаг надо использовать тогда 
когда мы собиаремя писать исключительно в хвост файла и больше никуда.

я так понимаю. без флага O_APPEND мы можем писать в любую часть файла в
в том числе и хвост. с флагом - только в хвост. причем наши ручне изменения
lseek игнорируются.

значит чем хорошо O_APPEND
если мы открыли файл с этим флагом то при записи
нам ненужно както вычислять какой оффсет имеет конец файла. мы просто
шарашим write либо printf а ядро само находит оффсет конца файла и туда
присобачыавает кусок данных. если же мы открыли без O_APPEND
то нам надо както руками узанать задавать оффсет конца файла если
мы хотим именнно туда добавить порцию данных. так что если мы
хотим писать только в конец файл то O_APPEND берет на себя
все накладыне расходы и нудобства. нам остатеся толко пихать данные.
тоесть O_APPEND это частный случай записи общей записи в файл.
ну и послоку ядро каждый раз при компнде записи вычисляет где же хвост
у файла то это значит что мы хоть сто раз можем обнулять файл
через другой процесс это никак нам не сломает механизм запист 
именно в хвост файла если мы открыли с флагом O_APPEND.
вот мы обунуили файл. и даем очередную коаманду на запист. ядро
проверяет оффсет который указыавет на хвост. видит что это оффсет 0.
и пишет в этот нулевой оффсет. при наличии O_APPEND  обнуление файла
будет проходить на отлично. и запист будет идти строго 
с начала файла. и еще напомню что если установлен O_APPEND то 
ручные установки lseek игнорирутся ядром абсолютно. если уж
ты открыл файл с O_APPEND то имешь право писать только в хвост файла
и больше никуда. ядро недаст тебе других возможностейй.
в этом разница открыавть файл с O_APPEND или открвать без него!!
гениально.
что интерсно - если я открыл файл без O_APPEND
и при этом не трогаю lseek. 
и идет запист в файл. и само ядро увеличиывает offset
то при обнулении файла как я уже показывал выше
ядро неменяет оффсет хотя размер файла уже ноль.
ядро оставляет оффсет таким каким оно было 
до обнуления.






я думаю что тема раскрыта полностью.

