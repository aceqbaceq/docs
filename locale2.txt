| locale

я начал пытаться разобраться с locale
-  этой искусственно
зашаманенная вещт на пустом месте.
говно статей много но ни все ни о чем.
втоже время локаль эта хрень которая лежит
в основе.

начал я разбираться с локале в файле  locale1.txt но там мало еще было понятно.




и вот наконец стало более поняно что все это
на практкие кокннетно значит!

локлаь  C POSIX  они ниаккак не настрваиются
они уже встроены кудато там в глибц намертво.
даже не посмтреть какие правиал там есть!
поэтому 


locale -a 
покжает вот это 

$ locale -a
C
C.utf8
en_US.utf8
POSIX


а 

$ locale -a   -v
locale: en_US.utf8      archive: /usr/lib/locale/locale-archive
-------------------------------------------------------------------------------
    title | English locale for the USA
   source | Free Software Foundation, Inc.
  address | https://www.gnu.org/software/libc/
    email | bug-glibc-locales@gnu.org
 language | American English
territory | United States
 revision | 1.0
     date | 2000-06-24
  codeset | UTF-8

locale: C.utf8          directory: /usr/lib/locale/C.utf8
-------------------------------------------------------------------------------
    title | C locale
    email | bug-glibc-locales@gnu.org
 revision | 2.1
     date | 2022-01-30
  codeset | UTF-8


тоесть мы не видим ни C ни POSIX 
они видим встроены в libc.so.6

это первй прикол!

локали в бинакрном виде илежат в 

/usr/lib/locale/locale-archive

добавляетс они туда через 

 $ localedef -f ISO-8859-8  -i yi_US  yi_US.iso-8859-8

вот это -f ISO-8859-8  это /usr/share/i18n/charmaps/ISO-8859-8.gz


вот это -i yi_US это /usr/share/i18n/locales/yi_US

а вотэто  yi_US.iso-8859-8 уже интеереснее 
читаю в man localdef 

       The outputpath argument is interpreted as follows:

       •  If outputpath contains a slash character ('/'), it is interpreted as the name of the directory
          where the output definitions are to be stored.  In this case, there is a separate output  file
          for each locale category (LC_TIME, LC_NUMERIC, and so on).

       •  If  the  --no-archive option is used, outputpath is the name of a subdirectory in /usr/lib/lo‐
          cale where per-category compiled files are placed.

       •  Otherwise, outputpath is the name of a locale and the compiled locale data  is  added  to  the
          archive  file  /usr/lib/locale/locale-archive.  A locale archive is a memory-mapped file which
          contains all the system-provided locales; it is used by all localized programs when the  envi‐
          ronment variable LOCPATH is not set.

тоест в данном сулчае yi_US.iso-8859-8 это значит
что выходной биарный кусок будет всунуть в /usr/lib/locale/locale-archive.
и наколкьо я знаю сразу вроде как все пцроессы
онволят у себя этот файл. или ядро както это делает...


далее логкиа такая. мы зпускаем прогу.  и если она
испольщует локаль то она окрывает файл 
/usr/lib/locale/locale-archive
и прям мапит его сбее в память. 
и далее юзер прога использует те насйтоки котоыре
там указаны в том обьеме как программа хочет.
она может вобще инрировать эту локаль а может 
ее полностью соблдюдать.
что каается печати символов. щас утсроено вот как.
мы внутри программы укзываем номер юникод поинта
символ которого мы хотим напечатать. далее
юзер прога шарится в файле локали и на оснвое
него находит какой поток боайтов нужно сунуть
на стдоут для этого код поинта на основе локали.
когда я создаю локаль то я указываю чармап файл.

-f ISO-8859-8

а внутри он выглдяит вот так

<U0000>     /x00         NULL (NUL)
<U0001>     /x01         START OF HEADING (SOH)
<U0002>     /x02         START OF TEXT (STX)
<U0003>     /x03         END OF TEXT (ETX)
<U0004>     /x04         END OF TRANSMISSION (EOT)

тоесть слева указан юник код поинт.
а далее указан тот поток байтов который как раз 
таки ЮП должно сунуть на стдоут.
таиким образом сделано старннно. у нас есть 
юникод система которая каждый символ обоначает
через юникод поинт. а далее у нас есть скжаем
UTF-8, UTF-16, UTF-32 
котоыре укзывают в какой поток байтов 
генерировать для дланного юникод поинта.
а они взяли юнкод поинты а потом для каждом чапмапе
у нас указано как этот юникод поинт коенвертиоовать
в поток байтов в данной кодировке.
таким обармо смешали юникод с неюникодом.


таиким образм если я пишу

 env LC_TYPE=en_US.utf-8  printf '\x041f \n'

то на выоде будем один поток байтов. 
а если 

 env LC_TYPE=С  printf '\x041f \n'

то другой!

кстати
LC_TYPE=С
после равно мы узакаывам имя локали.
как узнать какие у нас есть. 
вот так 

locale -a
$ locale -a
C
C.utf8
en_US.utf8
POSIX

или 


~$ locale -a -v | grep "locale:"
locale: en_US.utf8      archive: /usr/lib/locale/locale-archive
locale: C.utf8          directory: /usr/lib/locale/C.utf8

но тут небудет локали C и POSIX

значит сами  локали биарнарные лежат в 
 usr/lib/locale/locale-archive
либо в папке 
/usr/lib/locale

а в папке 
/usr/share/i18n/locales
лежат конфини котоыре моно поенять и на освное
них уже создать или преоздать биараную локаль.
и вот этот файл нарпимер 
/usr/share/i18n/locales/C

он отвечает за локаль 

  C.utf-8 

но ника кне за локлаь C  - она куда встроена  
в либси шаред либрари!


внунрурри конфа локаои 
есть секция

LC_CTYPE
copy "i18n_ctype"

translit_start
include "translit_neutral";""
default_missing <U003F>
translit_end

translit_start
include "translit_combining";""
translit_end

END LC_CTYPE


вот это файл i18n_ctype" в нем укзаны все 
юникод поинты и в какие локали группы они 
входят. (об  этом пото подрбннее)
и по идее в этйо секции можно написаьт на какой
юникод поинт меняьт тот который мы сунули в пргармму
но его нет в локали. и он его должен заменить на 
другой. ВОТ ЭТО НАДО НА ПРАКТИКЕ И ПРОВЕРИТЬ 
КАК ЭТО СДЕЛАТЬ. <<<<<<<<<<<====!!!!

прикоо еще в том что в итге этов се высирвется на 
стдоут. так вот если этов файл по хер. а есл и 
это на терминал то нужно чтбы теоминал подержвиаел
эту же кодррвку!!! теость мы лимы ывысираем в CP1255
то и термипал дожен ыть в этйо кодиррке настрен!
как это уже другой вопрос!!



с точки зрения пеати получается вот та.к.
мы в прогрмму суем юнико поинты а он их на оснвое
локали и чармапа превращает в байты которые уже 
сует на стдоут. некторце юникод поинты он может
првщаат в руние бникод пинтонинты. например С локальь
все руские буквы налету укнвеонтртит в англ аналоги.

# localedef -f ISO-8859-8  -i C2  C2.iso88598
# localedef -f ISO-8859-8  -i C2  /usr/lib/locale/C2.iso88598


--
 $ iconv -f UTF-8  -t ISO-8859-5  ./437.c > 438.c
 $ gcc -o 438.exe 438.c -finput-charset=ISO-8859-5 -fwide-exec-charset=UTF-32LE
 $ ./438.exe
43 04 00 00 
--

в си 

 ".........." это на самом дело закодрорванный
 массив + 0х00 в конце

".........."  = { , , , , ,, , 0x00    }
элементы можно указать разными путями

"abcdef"  = { 'a', 'b', 'c', 'd','e' ,'f', 0x00    }

"abcdef"  = { 0x21, 0x22, 0x23, 0x24, 0x25 , 0x27, 0x00    }

"abcdef" = "\u21\u22\u23\u24\u25\u26"

"abcdef" = "\x21\x22\x23\x24\x25\x26"
в этмо случае каждый \x это копилятор сичтет что 
это отделный элмент массива. поэтому

"a" = "\x21223232332"
будет ошибка потому что ".." это счиатется char*
тоесть каждый элемент размером 1 байт а это хекс
число \x21223232332 блльше чем 1 байт

аналогичная хрень для 

L"......"  это счатется wchar_t *
и для него 

"a" = "\x00000021"

байты внутри ассуоиирубтся с юникод поинтами
на освное кодироваки по дефолту utf-8
потмоу что  $ man gcc
 -finput-charset=charset
           Set the input character set, used for translation from the character set of the input file to
           the source character set used by GCC.  If the locale does not specify, or GCC cannot get this
           information  from  the  locale,  the  default is UTF-8.  This can be overridden by either the
           locale or this command-line option.  Currently the command-line option  takes  precedence  if
           there's  a  conflict.   charset can be any encoding supported by the system's "iconv" library
           routine.


 gcc -o 438.exe 438.c -finput-charset=ISO-8859-5 -fwide-exec-charset=UTF-32LE




получается широкий символ это не в том смысле что он на экране занимает визуально большой размер а в том смыысле что  его код поинт занимает больше чем один байт.  где код поинт это не байткод который будет отправлен на терминал непосредстенно а это  байтовый код который потом еще нужно будет преобразовать в байтоую последователность которая и будет направлена на терминал тоесть.

код поинт 4f60  превращается в кейсим байт код e4bda0 и уже e4bda0 суется на терминал.

обычный символ имеет код поинт однобайтовый ну и кейсим код тоже короткий но это уже неважно

0x71 (код поинт) 
====
LC_CTYPE
copy "i18n_ctype"

translit_start
include "translit_neutral";""
default_missing <U003F>
translit_end

translit_start
include "translit_combining";""
translit_end

END LC_CTYPE



LC_CTYPE
copy "i18n"

translit_start
include "translit_combining";""
translit_end
END LC_CTYPE

===

ctrl+m = 0d ctrl+q=0d

====

осташвшаяся повестка
 *cga vga  видкоарты - тектсоый режим
   упрвление чрез регистры в си

 * locale CTYPE что за хрень

 * printwchar чтоэото такое и почему с обычными 
    чарами вывод не работате


===

останвлавем баш
и делаем термианал вот стаиким флфагами

 B ၵ  $ sudo kill -SIGSTOP  571927 
 > ᑙ  $ sudo stty --file=/dev/tty2 icanon echo -echoctl erase 0x7F

надо учеть что текст коснль линукс это VT100
а в нем!!!

bacspace гениурет 0x7F          !!!
del      геннуриует ESC [ 3  ~  !!!


но ! сплошные пркоолы!!! если у нас канон режим
то тогда ттай драйвер настйоки 

intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O

имеют силу!!!
но!! толк если эти байты прилеетли в ттай драйвер
со стороны клавы!!!! а если я их пошлю со стороны
баща или друоготемрианала!!! то ттай драйвер 
их игнриует и простотупо их шлет далее на терминал!
и вот 7F слать безсполезно! и поулчается незвисент
что шлет tty dorver на терминал когда поучеет 7F
с клавы. но получается он шлет не 7F а чтото дурге!
ивитоге у нас на кране bacspace вдеет к стиранию
символа слва от кусора! 

кстаи 7F еще генируетс через ctrl+8

олучается что на vt100 кнопка bacsspace она геннрир
овала не 0ч008 asciii bacskcpce!!! нет!!! она 
генирваала 7F asccii DEL !!!!



получается на vt100 кнопки  backspace просто не было!
на том месте где щас стоит беспейс там была кнопка DELETE!

генерировала она 7F ASCII DEL байткод!

кнопки DEL тоже небыло!

а байт код ascii backspapce можно было сгеенироватьч ерез Ctrl+H

вот так там было !

а щас  наклаве там где была dleete теперь 
стоит backspace и он генерит 07F

а кнопка DEL щас генерит esc [ 3 ~


полчается бывшая DELETE а щас зываемавя BACKSPACE
она предназанчена для стирания символа слева!
кстаи в терминале если это делать внутри слова
то у нас стираетс символс слва и приэтом права часть
неприлипает к левой части! это уже фишка баша!
тоесть вот у нас было
  1234567890
тавм кусоро суюда

123456^7890

нажимает жать бкспейс
у нас будет вот так


        7890

стиарние просихоит за счет натйроки татй драйвера
erase 0x08

кнопка DEL она сочткои зрения ттай дарйвера
неимеет ниакой силы. она нчиего не стиарает.
а стиание просихдит символов справа с поттаскиванием
их к нашей позциии за счет баша софта. он извраается
с терминал командами чтобы удалить кусок и заонов
его послать ! сам терминал этого делать неумеет!

ЭТо ПЦЦЦЦ!!!!


символ 0х08 ascci bacpsalce генерилсяися на vt100 
за счет ctrl+H 
AD!!!


поэтму правлно в gnome-terminal поавтить что
bacspace = ascciii del
del = esq sequcnce она же esc [ 3 ~

все сотално это шваьлль а не настрйоки!!!



так.  я тут кратко нишу то что узнал про локале.
в целом это набор правил для отображения текста.
прилжение может следовать этому набору правила
а может нет. это такая неболшая база данных.
физически она в бинарном виде хранится в файле

  /usr/lib/locale/locale-archive

если мы кмопилируем прграмму через gcc 
то он аватомтмо одавляет такой код в нашу 
прогкрмму который открывает этот файл. 
ряд функциий глибц котоыре занимаются отобраением
на экран лазиют в эту базу преед тем как чтото
напчетатать на экран.

новую локаль можно откомпилировать.
конфиги текстоые лежат в папке 

    /usr/share/i18n/locales


берем там любой файл . компруем его в файл
с новым именем. редактиурем его. далее
комплируем

  $ localedef ....

  $ localedef -f UTF-8 -i fi_FI fi_FI.UTF-8


-f UTF-8 = это укызвает чармап файл который
            лежит в папке /usr/share/i18n/charmaps
в данном сулчае мы указали чтобы юзать чармап
файл /usr/share/i18n/charmaps/UTF-8.gz

чармап файл это таблица между юникод поинтом
и байтами которые его кодируют.
логика такая - твоя фнуция в программе должна
брать как аргумент номер юникод поинта потом
смотреть в чармап локали , находить там этот
юникод поинт. превращать его в байты и уже
эти байты срать на стдаут.
ну а так как стдаут обычно завяан на терминал
и терминал имеет у себя понимание какотого
энкодинга(чармап и энкодинг это одно и тоже) то
нам нужно чтобы локаль у процесса сотвесвтоватвтала
енкодингу у терминала в который мы будем срать
байты. иначе будет мусор на экране терминала.
иатк у нас есть прцоесс. которому похуй какие байты
срать на стдаут. но фнуции глибц частенько смотрят
в локаль в ее чармап. и есть терминал который
настроен всопринимать влетающий байты в определенной
кодирвке. и это надо все согласоываывать.

но повтряюсь приожение не обязано соблюбать нстройки
локалке. это чисто рекомендательная вещь.

на счет базы данных готовых локалей
посмтреть инфо

$ locale  -a -v 


locale: en_US.utf8      archive: /usr/lib/locale/locale-archive
-------------------------------------------------------------------------------
    title | English locale for the USA
   source | Free Software Foundation, Inc.
  address | https://www.gnu.org/software/libc/
    email | bug-glibc-locales@gnu.org
 language | American English
territory | United States
 revision | 1.0
     date | 2000-06-24
  codeset | UTF-8


locale: yi_US.iso88598  archive: /usr/lib/locale/locale-archive
-------------------------------------------------------------------------------
    title | Yiddish Language locale for the USA
   source | http://www.uyip.org/
  contact | Pablo Saratxaga
    email | pablo@mandrakesoft.com
 language | Yiddish
territory | United States
 revision | 0.4
     date | 2003-08-16
  codeset | ISO-8859-8


вот скажем у нас две гтоыве локали
вот написано где они физически лежат
  archive: /usr/lib/locale/locale-archive

и вот в инфо о локале написано какой чармап\кодсет
в ней есть

  codeset | ISO-8859-8


именно определяет то что елси мы в фунцию вставили
юникод поинт один и тот же какой поток байтов
в итоге прога высрет на стдаут. при условии что
моя прога юзает локале базу данных а ней хуй на нее
кладет.
к примеру глибц фуцния 

  putc()

ей похуй локале
а  для

  putwchar()

в нее смотрит.
кстати обозначиит какую локаль ты хочегь в своей
проге использовать можно вот так


   char *p_cl = setlocale(LC_CTYPE,"ru_RU.utf-8");

тесть схеа такая. я имею базу данных скопилилированных
локалей. список который омжно посмреть через
   $ locale -a 

далее в сипрогармпе обьясняем какую локаль мы 
хотим чтобы наш процесс юзал через setlcoale()
а далее уже запускаем фунции котоыей этой локалю
пользуются

 putwchar()


далее я хочу показть что две локали 
ru_RU.utf8 и en_US.utf8
они по факту имеют один и тотже чармап\кодесет


$ locale  -a -v  | grep -E "ru_RU.utf8|en_US.utf8" -A 10 | grep -E "locale:|codeset"
locale: en_US.utf8 
  codeset | UTF-8
locale: ru_RU.utf8 
  codeset | UTF-8


тоесть обе локали имеют один и тот же набор 
символов - это полный utf-8  набор. 
так что в этом плане (чтобы мы успешно видели 
руские буквы ) похуй какую из этих двух локалей
выбирать. а вчем разница? а она своевем в другом!
во всяких там правилах отображения даты и времени
чисел с заятой и прочей хуйне. к  отображению
руских букв это все неимеет никаой разницы.


я хочу тажке подчкнуть что локаль  симнеем "C"
она встроена видимо в libc.so.6 шаред модуль.
тоже самое касается локали с иенем "POSIX"котоарая
по факту эта тот же "С"
прчем не путать локаль "С" и "С.utf8" это две
совлеренно разные локали! тектовый конфиг для 
локали С.utf8 можно найти в папке 

/usr/share/i18n/locales

а вот для "С" локали мы нихуя нигде ненайдем
ее тектовый конфиг! локаль "С" исползует чармап
от ASCII. 

локаль это набор разных правил как нужно проге
раобтаь с тектом. напрмиер как надо отображать 
время или дату. или чичла с запятой. 
или например если у нас есть малнькая буква то
какая для нее есть бльшая буква. еще там есть 
правила о порядке символов по старшинуству (условано
алфавит) чтобы всякие там базы данных могли
сортировать строки по старшинству алфавита.
тоесть у немцев один алафивит а у амеркинцев
другой алфит хотя сиволы почти все одинакоые.
эта хрень назыется коллейшн. так вот 
вся эта дебилная грозьь всех этих правила 
разедена на группы. 

$ locale
LANG=en_US.UTF-8
LC_CTYPE="en_US.UTF-8"
LC_NUMERIC=ru_RU.UTF-8
LC_TIME=ru_RU.UTF-8
LC_COLLATE="en_US.UTF-8"
LC_MONETARY=ru_RU.UTF-8
LC_MESSAGES="en_US.UTF-8"
LC_PAPER=ru_RU.UTF-8
LC_NAME=ru_RU.UTF-8
LC_ADDRESS=ru_RU.UTF-8
LC_TELEPHONE=ru_RU.UTF-8
LC_MEASUREMENT=ru_RU.UTF-8
LC_IDENTIFICATION=ru_RU.UTF-8
LC_ALL=

по большоай счету кодировка символов в этих гурппах
низуя не показана. потому что кодирвка идет 
как чармап. а чармап можно посмтреть только вот
так

$ locale  -a -v  | grep -E "ru_RU.utf8" -A 10 | grep -E "locale:|codeset"
locale: ru_RU.utf8      archive: /usr/lib/locale/locale-archive
  codeset | UTF-8


из чегото инетерсного среди групп настроек
локали эта вот эта

LC_CTYPE=


что дает эта группа нсроек можно постерть 
в 

  $ man 5 locale
  $ man 7 locale

хотя про локаль часто пиздят .и это правда.
на практкие можно 
в типричном коинфиге локали про эту хрень
обвыно написано вот так

  $ /usr/share/i18n/locales/en_US

LC_CTYPE

copy "i18n"
translit_start
include "translit_combining";""
translit_end

END LC_CTYPE


как видно в эту секуцию копруется контент
из файла i18n  а если в него посмтреть то 
из файла i18n_ctype

по факту в этой секции из интерсного
это 

translit_start
...
...
translit_end

в ней можно задавть вот что.
у нас есть чармап файл в котоором как я сказал
есть юникод поинты и байты которые им сотсвттевуют.
так вот положим что в программе мы для putwchar()
дали такой юникод поинт котрого нет в чармапе.
так вот можно в локали в LC_TYPE секцт заадать
праивло в какой юникод поинте нужно трнаслировать
наш исходный юникод поинт.


вот напрмиер я вот так сделал

LC_CTYPE
copy "i18n_ctype"

translit_start
<U2016> <U00BE>
default_missing <U003F>
translit_end


тоест елси в проге я укажу <U2016> и если 
она юзает эту локлаь то она его превратит в <U00BE>
а дальеш уже посмтритм в файл чармапа в какие байты
его превртьить.

вот эта хрент
default_missing <U003F>

она говиит о том в какой юникод поинт по дефолту
прервщать тот юникод поинт которого нет
в чрамапе.

вобшем локаль это тема мудацкая коннетно.
потому что толковой инфо проактически нет.

