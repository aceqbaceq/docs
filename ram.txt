про RAM.


как  примерно работает  обмен данными  между цпу и RAM.

между цпу и памятью имеется memory controller. между этим контроллером и памятью имеется сколько то 
каналов. канал это полноценная шина с полноценной шириной между контроллером и памятью. тоесть 
по этой шине можно заказать и получить полноценные 64бита.(потому что регистры в цпу 64битные так что из 
памяти удобно считывать 64бита за раз). когда мы втыкаем планки памяти в сервер то на каждый канал к 
контроллеру памяти втыкается по 2-4 планки. это значит что по каналу можно получить доступ только к этим 
конкретно 2-4 планкам памяти а невообще ко всем планкам. тоесть есьб у нас на мат плате 
разьемы под планки памяти [1A] [1B] [1C]  ведут к контроллеру памяти по 1-му каналу, 
разьемы под планки памяти [2D] [2E] [2F]  ведут к контроллеру памяти по 2-му каналу.
это значит что по первому каналу можно получить доступ только к планкам [1A] [1B] [1C] а не вообще ко всем.
так в чем же прикол каналов тогда. прикол в том что можно одновременно получить один байт из связки
планок [1A] [1B] [1C] и второй байт из связки планок [2D] [2E] [2F]. а это уже кое что.
возникает вопрос а сколько каналов между контроллером памяти и цпу. незнаю как оно было когда контроллер
памяти был напаян вне цпу но сейчас цпу имеют внутри себя этот контроллер поэтому  я думаю что внутри 
корпуса цпу нет проблем с размером шины между ядрами цпу и контроллером памяти.  также как я понял между цпу
и контроллером памяти на самом деле еще сидят кэши цпу. и как я понял цпу читает данные только из кэшей
а если в кэше данных нет то данные качаются из памяти и кладутся в кэш а цпу читает данные исключительно 
из кэша. непонятно как распределяется нумерация байтов по планкам и каналам. ведь если мы запросим два байта
одновременно из планок  [1A] [1B] [1C] то никакого выигрыша небудет ибо по каналу вначале будет считать
один байт и только потом второй. выигры будет только если первый байт будет счтываться из первого канала
а второй из вторго канала из другого набора планок. также неочень понятно как это цпу может делать запрос
на считывание сразу нескольких байт. вот у нас идет команда на цпу в машинных кодах mov rax,[адрес]
ну и как я понимаю пока эта команда невыполнится ничего больше цпу небудет делать а будет ждать. тоесть 
в память улетел ровно 1 запрос. единственное тут у меня предположение что в цпу ядро неодно а несколько 
поэтому один запрос летит к контроллеру паяти от одного ядра а второй запрос от второго ядра. и тогда да
в один момент времени у нас контроллер памяти получил два запроса к памяти. также насколько я помню у 
кэша ширина его так называемой строки не 64бит а больше так что возможно при запросе от цпу в 64 бит кэш запрашиывает не 64бит а больше. тоесть типа кэш на всякий случай заказывает из памяти больше байт чем
запросил цпу. но про кэш это только догадка - нужно уточнять. 




обмен данными между модулями памяти и цпу(его мемори контроллером) идет 
по шине DDR.

если мемори контроллер у цпу имеет несколько каналов.это значит
что у него несколько независимых шин DDR.

по каждой шине данные цпу может получать независимо от другой шины.

на мат плате на один канал распаяно несколько слотов под модули памяти.
обычно паяют 2 слота под планки памяти на 1 канал DDR.
возможно есть случаи когда на 1 канал памяти на плате распаяно больше чем 2 слота под
планки памяти. 
значит шина DDR имеет ширину 64-bit , а если с поддержкой ECC то 72-bit.

получается обмен данными междц цпу и памятью идет 64 бита за раз.


теперь вспоминаем что у нас несколько планок памяти на один канал связи.
значит получается они как два IDE диска на 1 шлейфе условно говоря. то есть 
они сидят и мешают друг другу ибо два девайса на одной шине.

и тут придвется еще подробнее узнать как устроены сами планки памяти.

на планке памяти есть чипы в которых можно непосредстенно хранить данные. 
эти чипы называются BANKS.
но эти чипы имеют ширину 4 или 8 бит. поэтому чтобы образовать 64 бита
то надо скажем 8 таких чипов. они образуют единую структуру. это как диски 
собранные в рейд0. так вот такая структура чипов которая в итоге дает 64 бит
назыается RANK. получается ранк это структура которая позволяет получить из нее
64бита. тоесть ровно то что нужно цпу потмоу что у цпу регистры по 64бита и такая же 
ширина у шины данных. также получается что данные из банков считываются параллельно.
так вот создаетли памяти они что творят. они создают планки 
памяти с 1 ранком на планке , с 2 ранками, с 4 ранками. это дает бОльше обьема
на одну планку. идея понятна. как я понимаю есть какието пределы сколько байт 
можно засунуть в один чип тот который 8 бит. и получается что есть ограничение 
сверху по обьему сколько может поместить на данный момент в 1 ранк , в группу
из 8 чипов. учитыая что обычно 2 планки памяти на 1 канал. то получается что 
ест ьсовершенно четки обьем верхнего предела по макс обьему памяти
которую можно получить на канал через две планки с 1 ранком (из 8 чипов).
и если мы хотим еще больше памяти иметь в наличии то приходится лепить 
несколько ранков на одну планку. либо повышат плотность памяти на чип, либо 
увеличивать число каналов памяти итп. походу самый дешевый способ
это засунуть много много ранков на одну планку. 

поэтому получается в итоге на одной шине ( на одном канале памяти) сидит 
сразу куча ранков разбросанных по двум планкам. 

далее помимо чипов с данными на планке памяти есть буфер. 
этот буфер нужен потому что цпу читает данные не из самих чипов напрямую
а из этого буфера.

в целом как я понял система счтыавания из памяти работает так - контроллер памяти
сообщает планке или планкам памяти к какому ранку конкретно контроллер хочет получить
доступ и к какому адресу. потом наступает пауза.  в течение которой планка памяти
копирует данные из чипов в буфер планки памяти. это занимает какоето время.
и потом цпу уже читает данные из этого буфера. 

таким образом имея много ранков мы можем иметь очень большой обьем памяти 
но теярем в скорости потому что чтение происходит в несколько этапов. 

насколько я понимаю при установке модулей в мат плату главное это то что 
цпу его контроллер памяти скорей всего может поддерживать максимально такое то 
число ранков на один канал памяти. а уж как эти ранки будут распределены по двум планкам
мне кажется это недолжео играть роли. скажем  цпу поддержтивает 5 ранков 
на канал. наверно ему пофиг будет что одна планка на 4 ранка а вторая на один
или одна планка на два ранка а вторая на три. надо уточнять.
также я ненашел в спецификации скажем e5-2620v4 сколько максимальное ранков 
памяти в сумме он поддерживате на канал. далее я нашел что nehalem он имеет
три канала памяти и до трех планок на канал. неочень понимаю почему сказано
именно про планки а не про число ранков на канал макмиальное.
ведь планки могут иметь разное число ранков.



также про вот эту многоканальность то что у нас цпу имеет несколько каналов.
я незнаю почему но цпу как японял неможет использовать 
несколько канало водновременно во всех случаях. а может только в определенных.
если планки в обоих каналах одного размера и одной частоты шины то тогда 
проц может одновременно читать с обоих каналов. а если нет то нет.
тогда он за раз читает либо с одного канала либо с другого.
так что от того что несколько каналов еще не занчит что чтение 
идет однрвременно.

поскольку перед тем как считать данные цпу оьявляет из какого ранка
ему нужны данные и так как на одном канале в мнимальном случае сидит как минимум
два ранка (один на одной планке а второй на второй) то я теперь невижу большйо
проблемц что планка имеет боллше чем один ранк.
и мне кажется теперь что планка где много ранков ничуть немедлнее чем планка
с одним ранком.

опять же ранк неимеет никакой связи с тем что на одной стороне планки накленны
чипы или на обоих.

регистровая память она же буферизованная RDIMM, в противоположность им нерегистровая\небуферизо-
ванная DIMM или еще она же UDIMM.

на счет того память имеет ecc корекцию или нет насколько я понял это совсем 
отдельная характеристика несвязанная напрямую с тем rdimm или udimm память.
потому что бывает udimm и в тоже время она имеет ecc

итак

ECC - коррекция ошибок . отдельная независимая фича от всех остальных фич
RDIMM - планка имеет регистры. еще их назвыают буферами. память зовут регистровая
или буферизованная
UDIMM - память без регистра
DIMM - тоже самое что UDIMM


что это за регистры.что они делают. зачем они.
как я понял у любой памяти что с регистрами что без регистров есть линии по которым
цпу присылает команду что ему надо(шина управления).  а есть линии по которым задается адрес 
с каким ячейками надо это делать(шина адреса). они зовутся линии команд и линии адреса.
так вот вспоминаем что на планке сидит огромная куча 4 или 8 битных чипиков в которых
данные сидят. так вот если регистров нет то каждый из таких чипиков создает
какую то там электрическую нагрузку на эти линии. что это значит напрактике непонятно
но ясно то что чем больше чипиков тем нагрузка больше и это очень плохо.
нашли выход - на линию адреса и на линию команд посадили по регистру. 
теперь нагрузка на всю планку упала до уровня нагрузки от одного чипика. 
насколько я понял вся эта хрень относится к проблеме электротехники микросхем.
тоесть с введением регистров в аспекте электротехники все стало замечательно.
но с точки зрения перфоманса случилось вот что. если раньше команда от цпу 
до чипиков на планке долетала за 1 такт то теперь за 1 такт от цпу команда долетает
до регистров. а уже за второй такт регистры передают команду от себя до кишок внутри 
планки. учитывая что вся эта кухня по передаче данных между цпу и памятью занимает 
дохрена тактов то никакой катастрофы нет. никакой ощуимой потери перфоманса нет.
зато стало возможно насовать на планку памяти дохрена ранков. и схемотехника 
контроллера памяти на цпу упростилась. я так понял. 
еще раз как я понял до того как придумали регистры на памяти ввести очень 
сильно устложнялась реализации электротехники контроллера памяти. 

далее как я понял обычно цпу может юзать на канал памяти три планки памяти 
по 2 ранка в каждой. итого 6 ранков на канал.

планки с quad-rank они обычно прописываются отдельно. поддерживаются ли они
или нет.

планок с three-rank небывает. только single,dual,quad rank планки.

еще я увидел что если на планке используются чипики по 4 бита то в итоге
на такую планку можно напихать больший обьем.

нашел что xeon e5-v1,2,3,4 имеет 4 канала памяти и поддерживает 8 ранков
на канал



LRDIMM- насколько я пока понял с практической точки зрения ее отличие от RDIMM  втом
что для системы она выглядит так как бутто имеет в два раза меньше ранков на своем
борту. таким макаром получается что можно установить в 2 раза больше ранков
на канал памяти чем это можено сделать через rdimm модули. например - система пооддерживает
8 ранков на канал. значит через rdimm модули можно устанвоить 8 ранков памяти,
а с помощью lrdimm можно установить 16 ранков так как для контроллера памяти будет
казаться что на канале всего 8 ранков памяти.

для примера 160 G9
у него 4 канала памяти. по 2 планки на канал.
судя по книжку он неподдерживает quad-rank rdimm планки.
значит остаются только 2 rank rdimm планки. итого 4 ранка ( 2 планки по 2 ранка ) на канал.
при этом он поддерживает 2 планки по quad-rank lrdimm на канал.



HDIMM-?
FBDIMM-?


такж непонятны пока вопросы:
разница в скрости между планками у которых 1 ранк  2 ранка 3 ранка 4 ракна планка

двигаем дальше. из статьи - The DRAM memory controller translates the
physical address into a DRAM address to identify chan-
nel ID, rank ID, bank ID, row, and column. я это непонял потому что банк имеет размер 4 или 8 бит
тоесть из него можно выбрать либо пол байта либо байт а нужно то 64бита. помоему в этой схеме
bank id это лишнее.  

далее:
хочу обсудить код хэминга 
потому что он исольуется в ecc памяти


54321
11010

1 = 0001 = 0
2 = 0010 = 1
3 = 0011 = 0
4 = 0100 = 1
5 = 0101 = 1
6 = 0110
7 = 0111
8 = 1000
9 = 1001

987654321
1x101x0xx

выбираем вариант нечетного числа единиц

p1 = 3,5,7,9 = (1110) = 1
p2 = 3,6,7 = (100) = 1
p4 = 5,6,7 = (101) = 0
p8 = 9 = (1) = 1

p1,p2,p4,p8 - цифра указывает на позицию в передаваемых данных.

987654321
111010011

проверяем на ошибки
имеем коректный вариант

987654321
111010011


вариант где только биты данных

987654321
1x101x0xx

вариант с ошибкой

987654321
011010011

вспоминаем что у нас нечетный вариант. тоесть единица в проверочном бите если число единиц в данных
нечетное

для проверки что данные целостны надо брать каждый проверочный бит и проверять совпдает его значение
с данными или нет. если нет то либо бит испорчен либо данные.

p1 = 3,5,7,9 = (0110) = 0(расчетное число) != 1(принятое число)

итак видим что уже на первом проверочном бите вывилась порча данных.
теперь надо выяснить какой бит является порченным. для этого надо проверит все проверочные биты 
для начала

p2 = 3,6,7 = (100) = 1(расчетное число) = 1(принятое число)
p4 = 5,6,7 = (101) = 0(расчетное число) = 0(принятое число)
p8 = 9 = (0) = 0(расчетное число) != 1(принятое число)

значит мы получили что p1 и p8 ошибочное показывают. значит ошибочный бит находится в позиции p1+p8 = p9 
тоесть в девятой позиции. 

сравниваем эталонный вариант
987654321
111010011

и ошибочный вариант
987654321
011010011


и дейвствиельно ошибочнйы бит это бит номер 9.

ура.




