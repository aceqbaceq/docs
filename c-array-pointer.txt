надо разобраться с переменными в си.

надо рассмоатреть 

простые переменные  int a ;
массивы 	char vasya[14] ;
поинетры    char *p  ;
массивы поинеров  



у си каждая перменная имеет всегда тип. 
зачем нужен тип. потому что комплиятору который сздаем асемблер код нужно знать
какие команды создавать которые будет создавать эту перменнуюв в памяти. нужно знать 
сколько байтов нужно будет аллоцировать под эту переменную в памяти.и потом кода мы будем
считыать ее из памяти то нужно знать какой командой ее читать. дело в том что если перменная
многобайтовая то мы же при чтении указыаем тлоько адрес первого байта. а дальше то колько 
байт будет считано зависит от регистра в котоырй мы читтем. будет ли считан 1 байт
или  2 байта или 3 байта или 4 байта. итак тип перменной задает сколкьо байт она занимает 
в памяти. 

возьмем простой тип как int


   int a = 0x10;

этот тип занимает 4 байта в памяти.
тепер важный момент. у нас переменная имеет тело. то есть тот кусок памяти где хранится ее 
значение. например 0x10 в 4 бйатовоом виде будет в пмяти выглядеть вот так

	 0х10 0х00 0х00 0х00   

если адрес первого байта 1234 то будет вот такое распрееление по адерсам

1234 	0х10
1235 	0х00
1236 	0х00
1237 	0х00


замечу что если у нас многобайттвоое выражение  то в памяти сохраненеие начинается с младщего
байта . тоесть на бумаше мы привыкли пиасахть числа наоброт первый байту нас старший. тоетс
если на бумаге   тоесть в тексте нашей программы на си у нас число вылглядит как 
   0x11223344
то в памяти это число будет сохранено наоброт вот в таком виде
   0x44 0x33 0x22 0x11

поэтому наше число из прогиаммы 0x00000010 то в памяти оно запиывается вот так

1234 	0х10
1235 	0х00
1236 	0х00
1237 	0х00

так вот где тело ллежит нашей перменной мы поняли. возникает вопрос а где в памти нашей 
прогарммы хранится адрес первого байта этого тела. как ее наша программа будет находить?
ответ - нигде он нехранится в памяти. просто напросто
(внимание) компилятор он на стадии созания кода он  хардкодит "мержит" адрес этой перменной
прямов в код ассемблер команд. тоесть самое тело программы и содержит адрес этой переменной.
тоесть если нам в тексте нужно обратиться к этой пременнй и мы пишем

   b = a + 1;

то комплиятором геннерииуется ассмблер код который вытаскивает эту перменную из памяти и 
кладет ее цпу регистр. и тд. например вот так

    mov eax, [1234];

и вот этот 1234 и это и есть то место тот способ которым  вмерживается адрес нашей перменной
в нашу программу. тоесть адрес нашей перменной где она хранится и ее размер вмеривается просто
тупо в код в виде конкнетных чисел в код нашей прогарммы! тоесть как наша прогарма узнает 
адрес этой перменной в памяти. а вот так что ее адрес прям вмонтирован в код нашей программы.
ну а имя перменной это просто указатель для нашего компиятоора в процессе его работы чтобы 
он для себя понимал про какую пременную мы ведем речь. хотя я хочу скаать что в самом эльф 
файле будет тоже присствовать слово "a" которое имеет наша переменная имя. но это отденый 
разговор о прерврашении эльф файла в код раобаотающего процесса. я щас не буду этого 
касаться. 
итак важно понять что когда у нас код на асебплере уже работает то в памяти есть только 
тело файла которое лежит по какому то адресу. а спец места в памяти где отделно запиасано
где искать эту пермнную - аткого нет. инфморация о перееменной вмонтирована в сам асемблерный
код нашей прграамы. он и несет эту инфо. 


непмного пимеры типов перемененых.

long int = 0x0000000000000010 \\ размер 8 байт
int a = 0x00000010 ; \\ раозмер 4 байта
short int = 0x0010 \\ размер 2 байта
char b = 0x10; \\ размер 1 байт

теперь про массивы.
что такое массив. массив это кучка элементов. каждый эелмент имеет один ии тот же тип.
и таких элементов несколько. и они все лежат в памяти кучкой рядом друг с другом.
как его создавааавт
 

  short int vasya[2];

что здесь что значит. 

[2]  - это значит что в массвие два элемента
имя переменной за которрой кроеется этот массив это vasya
то что стоит левее имени массива тоесть   short int это тип элемента в массиве. 
в данном случае значит каждый эелмент занмиает 2 байта. 
значит весь массив занмиает 2*2 = 4 байта в памяти. значит комплиятрор знает что нужно в впамяти
зареервировать 4 байта под тело массива. при этом в памяти опят же не создается доп ячеек 
для указания начала адреса массива в памяти и нет люблой другой инфо о структуре массива.
вместо этого компиялятор держит в своей голове где в памяти лежит этот массив. и он походу кода
нашей прогарммы будет вставлять ассемблер команды  вк отрые уже захардкоден адрес нужного
элемента из этого массива. поэтому инфомрация о структуре массива она задним число полчается
вмонтирована в код прогарммы. обращение кэлементу массива идет в вот так

   vasya[1]= .....;

замечу подставу что при обьлвяении массива символы [2] уазвыают на число эелментов в массиве.
а уже при раотет с массивом символы [1] означают совреено другое а именно порядоковый номер
элемента в массиве. причем номер начинается с числа ноль а не один. поэтому если в массиве 
два эемена то их индексы это 0 и 1.
так вот кода у нас в коде программы на си текстовом идет запись

	vasya[1] = 0x1AB1;

то компилятор создает условно вот такую ассемблерную команду

   lea eax, 1234
   mov bx, 0x1A1B
   mov [eax + 1], bx

соттенно адрес куда мы пишем он захардкоден. просто в форме цифры. и число байтов которое
мы будем писать а миенно два байта определяется размером регистра. ибо bx имеет размер 2 
байта.
где 1234 этоадрес первого элемента массива. а +1 это смещение. тоесть компдиятор налету когда
сотавляет асскмблер код то он в нужных местах в форме числовых констант подставляет нужные 
адреса. тоесть я хочу сказать что в самой памяти процесса не будет никакой ячейки памяти 
где будет спецаильно хрнаится адрес начала массива куда код будет лазит и узанавать - а где
же начало вот такого массива? тоесть я хочу скзать что при создании массива у нас создается
в памяти только тело массива. а в добавок поинтера на начало масива создано не будет. не будет.
копилтятор просто будет по телу програмы хардкодить числоыве адреса элементов этого
массива и все. 

повторюсь vasya это не поинтер внутри нашей прогараммы. никкого поинтера не будет создано
в ассеблер коде.  а vasya это поинтер внутри памяти компиятора пока он генериурет ассемблер
код из нашего текста. поэому да это поинтер но исключаитеьно внутри компилятора. 
а раз это поинтер то тогда может работать вот такая хрень


  short int *p = vasya;

здест p это переенная поинтер. я про них ниже расскажу. а пока просто скажу что в нее запиывается
адрес в памяти. по этому адресу в памяти хранися какая то перменая. таим обраом поинте он не
хранит значение он хранит адрес где хранистя тело перменной. "p" это имя этого поинтера.
опять же  - имя перменной его в асемблер коде нет. в ассемблер коде идет вместо этого 
вставленный захардоженный адрес где хранися эта перменная. тоесть символльное имя это чисто 
укзаатель внутри памяти компилятора. он знает что такое "p". и он встваляет в ассемблер
команду вмето имени "p" уже число адрес где хранися эта переенная. итак p это имя перменной.
значок * означает что это не просто перменная а это поинтер. то что стоит левее от * оно
обознаачает какой тип у той перенной на которую укызвает поинтер. еще раз значок * позволет
на стадии создания перенной отлчить поинтер от обычной перменной. тоесть


  short int p;  \\ означает что это перенная обычная и имеет тип short int
  short int *p; \\ означает что это поинтер который хранит всебе адрес на переменную
                \\ которая имеет тип short int

вот поэтмоу нужен значок *
еще подчеркну то что в памят процеса поинтер хранися толко его тело. тоесть если у нас 
поинтер равен 1234 то в памти будет хранисят только 1234. а инфомрации о том что этот поинтер
указывает на перенную типа short int небудет! это чисто инфомрация для компилятора чтобы
он когда будет гоотвить ассебмлер чтобы он спас програмиста от делания какйото хуйни.
а если еще раз гворю мы запусти процесс. найем этотпоинтер. то мы увидим только адре 1234
но мы не будем понимать какоо размера перменная на какую он указыает. такой ифомрации в памяти
нигде не сохраренро. эта ифомраия только есть в опосреденнованном виде в коде ассебмлерном
программы.

так вот я врвзращаюсь к массивами поинтеру


  short int *p = vasya;

кода такой текст встертит копилятор то он создаст код который создает в памяти компа 
поинтер. и он создава асемблер код просто напросто всунет в форме готово числа адрес
первого элемента массива! то есть он просто подставит в ассеблер код адре масива. 
тоесть такого не будет что  унас гдето в пмяти процесса есть ячейка которая хранит адрес
начала масива . и оттуда это считвыается.  и запывается в поинтер в памяти. нет.
у нас будет создан поинтер. и комплиятор просто вствит в форме готово числа адрес начала 
массива. тоесть унас слева стоит переменная p и она релаьно будет созана в программе.
спава стоит перенменная vasya которая соедрижит адрес наачала масива но это перменная чисто
внутри комплиятора . в проегрммме такой перменной небудет!
код будет примерно такой.

  mov [7689], 1234

тоест унас поинтер будет лежать в памяти по адресу 7689 и в него просто комплиятор подставил
число 1234. и не будет  ниакой другой  ячейки в памяти где лежало бы 1234 отдельно. 

тоесть еще раз вот в чем прикол си. у нас в тексте прогарммы указвыаются переменные.
и какието из них в итоге релаьно создаются в программе. а какието ппернменные это чисто 
перменые компилятора а в программе их не будет создано.
вот мы обьявили массив

 short int vasya[10];

и комлияттор создаст асебмлер команды которые запишут в паять ТЕЛО массива. но не будет
ячейки где было бы заиписан адрес начала массива. эта инфомрация будет толко в голове компилятора.
поэтому когда мы в тексте прогарммы пишем просто vasya котоое прозумевает что мы хотим узнать
адрес начала масива то это намек комплиятору на его внутннерюю переенную vasya которая хранит
начало адреса массива в памяти будущей прогарммы

  short int *p = vasya;

поэтому слева указана перменная которая будет жить внури программы. а справа указана внутненяя
перменная компилятора. вот такой прикол. не все перменные в си тексте будут созданы в коненой
программе. 

итак созадем массив через 

 short int vasya[10];

досутп к эелменту массива выгляидит как
 
  vasya[1]

и адрес первого элемент массива выглдяит как

  vasya


кодга  втексте мы юзаем vasya[1] то это намек компииятору что бы он взял свою внутрнеюю 
перменную vasya котоаря соеджрит адрес начала массива. прибавил к ней необходимое смещение
в байтах и это число захардокодил в асебебрлер команде которая обратится поэтому адресу
и прочитает нам из памяти в цпу значение элемента массива с индксом 1.
наример 

 short int vasya[2] = ...;
 b = vasya[1]

 пуст у нас масив начинает хранисят с адреса 1234 . так как размер эедмета 2 байта.
 то перый эедмент который имеет индекс 0 то он хранисят по адресам

 1234
 1235

 а вторйо элемент котоы имеет инекс  1 хранистя по дерсу

 1236
 1237

 тогда код вторйо строчки будет 

  mov bx, [1234+2]

тоесть комплиятор вставить адрес начала масива и сдвиг на два байта на начало храения второго
элеента

значит что важно поняь про массив это то что в прогармме в памяти в ячейках будет хранится
только тело массива. метданные в пмяти хранистя не будут. метедатнные хрантся в захардкоженном
виде в тексте ассеблерной программы. когда компитляторв встрчает в тексте на си упомианние
о масиве то он просто трансфорвмирует занчение своей внутррней перенной vasya котоаря обозначает
начало адреса массива  в нужные числа для подстановки в ассемблерные команды. 
если мы пишем в текст на си просто vasya то компилятор понимает что мы его просим вставит 
адрес начала массива в памяти и он вставляет это число в код асеблреной комнды. если
мы в тексте на си пишеи vasya[0] то компиятор понимает чтомы хотим отнего чтобы он содал команду
на асбелеере котоаря вытащит из тела массива первый эелмент. сам комлиятор знает и где 
начало тела масива в памяти прогарммы и стркутурур массива исходяиз этого комплиятор вычсляет
нужные числа адреса и на освное них формирует асемблернуюкомнду. поэтому инфо о ксткрутуруре
массива есть только в голове компилятоора. в памяти программы ифнморации о стрктуруте массива
нет. есть толкьо тело маассива. опосредованно инфо о структуре массива есть в коде на ассеблере
прогармы. а я раньше думал что ифорамаиця о о структуремассива комплиятром где тов памяти
прогармы сохраняется и туда потом код прогармы лазиит. а полкчатс что бОльшая част того что 
мы в тексте на си пишем это все только внутрнееннняя инфорация для компилятора. и что эта 
инфо так не выходит из комлилятора в тело прогаммы на ассемблере!

итак когда копиллиятор выидит текст

 int vasya [10];

он понимает что ему надо создать ассебплер текст который займет 40 байт в памяти прогарммы.
и он такой текст на асебелере создаст. при этом копилятор в своей памяти запомнит во внутрней
переенной vasya что начало массива в памяти программы лежит скажеи по адресу 1234. потому чт
именно комплиятор выбиарет по какому адрксу будет создано тело массива в памяти прогарммы.

если комплиятор види текст

 vasya[2] = ....

то понимает что его просят создаст ассмблер код который сует в тело массива некоторое 
значение. тода он вытасивает из своей памяти начало массива 1234 вычисляет на освное сткрутуры
массива начало адреса третьего элемента в нашем случае это будет 1234+4*3= 1246
и уже генериурет ассеблер код который сует по адресу 1246 значение

 mov [1234+4*3], значение


если компитор видит в тексте слово vasya

  .... = vasya

напрмиер 

 int *p = vasya;

то что касается васи он понимает что здес его просят подсунуть адрес начала массива. он лезет
в свою память вытасиувает число 1234 и сует его в ассеблер код.

тепер про массивы составленные из элементов разных типов

int vasya[10] \\ массив из 10-ти жлементрв каждый имеет тип int тоесть 4 байта
char vasya[10] \\ массив из 10-ти жлементрв каждый имеет тип char тоесть 1 байт

long int vasya[10] \\ массив из 10-ти жлементрв каждый имеет тип long int тоесть 8 байт

итак то что справа число в скобках это число элементов.
посредине имя внутрнейней переенной компилятора для данного массива.
слва от имени массива тип каждогоэлмента массива.
ксати про длину массива. этой инфо в памяти прогаммы нет. это знает только компитор.
а в тексте асселера об этмо есть только опосредвеная информация. а в памяти прогаммы об этом
нет ниакой инфо. поэтмоу елси мы знаем что по адресу 1234 анчианется массив то какая у него
длинна хрен знает. не понять.
с масивами разобралсись.


важно понять что комплиятор так создает прогармму на ассеблеере что в итоге в памяти програмы
будет храится только тело пременной какой бы у нее тип ни был. и не будет хранится в памяти
программы адрес где искать эту перееменную. адрес хранится только в памяти комплиятора пока
он компилиурет и захардкожен в коде ассеблерной программы.


теперо про поинтеры.

как я уже сказал поинтер в своем теле хранит адрес. поэтмоу длина поинтера 4 байта
для 32 битного цпу и 64 битного цпу. 
адрес указывает на перенную котоаря ранее уже была создана на компе. 
поинтер ествесвтенно создается в памяти програмы. если адрес массива котоырй тоже поинтер
не создается в памяти программы а тлько есть в памяти комплиятора. то поинтер создается
в памяти прогармы. и при его создании указывается не его тип иотмоу что его тип нам понятен
а укзывается тип той перменной адер которой он хранит

создаим поинтер

	int *p ;

опять же имя p это чисто внутнний идентийикатор для комплитора этой перееной когда он будет комплировать текст.  int означает что адрес коорый хранистя в p указывает на переенную
длинйо 4 байта. тоесть елси в p лежит 1234 то значит данные лежат в адресах 1234 1235 1236 1237
тип поинтера в памяти прогаммы нигде не фисируется. это чисто инфо для комплиятора. он знает
на стадии комплияцци на какой тип данных указывает поинтер. а в живой программе у нас будет
тлоько адрес 1234 а какйо длинны данные за этим адресом хрен знает.
так вот коплиятор следит чтобы мы привяызали поинтеры к перменным у которых такой же тип
как мы указали в поинтере
напрмиер 

  int a = 10;
  int *p;
  p = &a;

 в первой сторке мы создали int переменную.
 во вторйо строке мы создали поинтер которому разрешено указываьи на пермтеную типа int;
в третьей строке мы занесли в p тот адрес по котроу лежит  в памяти переменаня a.
и это можно сделат потому что перменая а имеет тип INT и у поинтера завялено что ему разрещено
укзываьт на перенную с сэтим типом. 
есть еще поинтер типа void

 void *p;

ему если я проавльнопомню разреешено указывать на переменную любго типа. 

про вот эту строчку

  p = &a;

кода ее увидит компиятор он вот что сдлеает. он посмтрим в своей памяти где хранится p
и где хранися a. и он созаст ассемблер код в котором чилами запишет оба адреса. 
примернно вот так

 mov [6789], 1234

где 1234 это адрес в пмяти процесса где по информации оплиятора лежит пемрееная а
а 6789 это где по информаии комплиятора лежит переменная p.
тоесть в коде асеблера все эти адреса будут тупо захардкодены.

по поводу создания поинтера

int *p;

звезда позволяет указать комплиятору что мы хотим создать не просто перменую типа int
а мы хотим сздать поинтер котрому будет разрешено укзывать на перменную типа int
вот зачем нужна звезда. но звезда имеет совшерешнно дргое значение когда мы уже польщуемся
поинтером. если мы испольщуем имя p без звезды то это значит что мы имеем ввиду знание
этой переенной. например 
 

  int a= 10;
  int *p1= &a;
  int *p2;
  p2=p1;  // в  этой строке мы копируем адрес из p1 в p2


если же мы хотим плолучить из переенной p не адрес а знчение которое лежит по тому
адреу то юзаеи звезду

 int b;
 b = *p1;

звезда p1  это диркетива комплиятору (ровно также как ест директивы у баша) чтомы в этом
месте просим его чтобы он прочитал значение переменной которая хранисят по аресу указаному
в поинере. и тут пригождается тот тип поиеера который мы задавали при его обявлении. потому что 
в поинтере лежит адерс. но адрес это 1 байт. и непонятно сколко байт нужно в итоге прорчитаь
1 или 2 и ли 4 или 8 . а кодгамы занем тип поинтер то знаем сколько байто нужно считаь. 
и какую для этого команду асбелера нужно юзать. пример

int a= 0x10;
int *p = &a;
int b = *p;

в первой строке мы создаем int переменную.
во второй строке мы созадем оинтер и говрим что ему можно укзывать на перменную типа int
и также сразу мы запмываем в поинтер адрес переменой a. комплитор проверит совпдает ли тип 
поинтера и тип перменной а. да совдпает . значит можно так делать.
вторая строка на асбемлере мы просим кмопиялтятор вытащить знаение перменной адрес которой
лежит в p. ткомплиятор смотрит какой тип у пинера. ага тип int. значит нужно считать по указаному
адресу 4 байта. а потом нужно эти 4 байта засунуть в  переенную b котоаря тожа имеет тип int.
тогда он вот что делает

  mov eax, 6767         \\суем в eax адрес переменной a
  mov [eax], 0x00000010  \\пищем в пеерменую a  четыре байта
  mov eax, 6789     \\ суем в eax адрес самого поинтера
  mov [eax], 6767 \\ суем  поинтер адрес переенной a
  mov ebx,[eax]  \\читаем 4 байта по адресу из поинтера в ebx
  mov eax, 2424  \\ пишем в eax адрес переменной b
  mov [eax], ebx  \\ пишем в перменную b то что было в переменой на коорую укзвал p

как видно из текста копмилятор так как знает все адреса где что хранися. и он знает
все типы данных то он это все захардокидвает в ассеблер командах. 
тоесть все адреса и все типы тупо захардкодиваются в параметрах ассемблер команд.


поэтому вот ответ на вопрос

int b = *p;

откуда копляитор знает сколк байт нужно считать на запрос *p 
ответ - оттуа что мы задали при обялвении поиинтера на какой тип данных ему можно укзывать.
и комплиятор это проитал и он это запомнил и знает


теперь рассотрим такой момент как связку массивов и поинтеров. 
для начала еще раз пример когда поинтер укзывать на просто перенную

	int a = 10
	int *p = &a;


мы создали поинтер которому можно указывать на переременную типа int.
и мы занесли в поитер адрес по котрому хранися преременная a которя имеет тип int.
если у нас в p лежит адрес 1234 и мы знаем что по адреусу этому хрнаится int значит
мы знаем что нетолько адрес 1234 содержит инфомрацию а 4 байта содержат иформацию 
а именно 1234 1235 1236

окей. 
теперь поинтер и массив


 char vasya[2];
 char *p = vasya;


в первой строке мы создаем маассив. у него два элемента. кажый из них имеет тип char.
это 1 байт. если массив начианется с адреса 1234 то в итоге его тело лежит в 1234 и 1235
первый эелмент лежит в 1234 второй в 1235

во второй строке мы создаем поинтер котоому можно в себе содержать адрес коорый укаызвает 
на переменную типа char. тоесть если у нас в поинтрете лежит адрес 7890 то мы знаем что полная 
длинна данных на которую укзывает поинтер всего 1 байт тоесть 7890. тоесть еси нас попросят
прочитать всю перееменную которая хранистя по адреу на который укаывзает поинтер 
то мы знаем и комплияоор знает что нужно считать всего 1 байт.

рассмотрим внимательно тепер втору стркоку. в правой части стоит внутрнеяя перменная комлиилятора
и она оназнчает что в этом месте комплиятрор должен попокопавись в своей памяти найти свою
внутренюю пременную vasya и вставить ее занчение в этом место. а какой же смысл перееннйо 
vasya - а это адрес первого байта где начнианется массив в памяти программы.
значит у нас как бы втроая строка выгядит вот так

 char *p = 1234;

тоесть у нас соадатся поинтер. ему разршенено в себе хранить адрес переменной котоаря имеет
тип char. у нас справа стоит число 1234. тоеть в пеереную p мы пытаемся записать число 1234.
адрес ли это ? да это адрес. теперь главный вопрос - находится ли по адремсу 1234 переменная
которая имеет тип char? И ТУТ ПРОШУВНМИАНИЯ!!!!!! -  по адресу 1234 у нас лежит не переменная
char а лежит массив из элементов char. так вот как я понял видим с точки зрения комплиятора
массив это как не единая структура а группа отделных переенных кторые просто вместе собрали 
в кучку. поэтому раз у нас начиная с адреса 1234 лежит массив типа char значит там лежит набор
отделных переменых типа char. теперь вопрос по адресу 1234 лежит ли адрес отдельного элемента
char? ответ - да. потому что у нас один элемент char лежит по адресу 1234 
а второй элемент лежит по адресу 1235. поэтому у нас масив это как бы две одльеных перенных
типа char  с тчоки зрения комплиятора просто они лежат в памяти вплотную друг к другу. 
ну и что . это не страшно считает комплиятор. поэтому раз у нас массив это группу отдельных
переменых типа char и раз по адресу 1234 лежит одна из этих премеыных то значит с этой точки
зрения адрес 1234 указывает на переменую типа char и значит что сохранить адрес 1234
в поинтер типа char яввлется с точки зрения комплиятора валидной операцией! вот такой
пиздец. поэтму с этой же точки зрения валины и вот такие оперкации

  char *p1 = &vasya[0];
  char *p2 = &vasya[1];



вот аналогинчный код 320.c (внизу кусок)


   //
   char neptun[2] = { 0x10, 0x12 };
   char *p_p1 = neptun;
   char *p_p2 = &neptun[0];
   char *p_p3 = &neptun[1];
   printf ("p_p1 = %p, p_p2 = %p, p_p3 = %p\n", p_p1, p_p2, p_p3);
   printf ("*p_p1 = %hX, *p_p2 = %hX *p_p3 = %hX \n", *p_p1, *p_p2, *p_p3);
   


на экранее
p_p1 = 0x7ffc425ab943, p_p2 = 0x7ffc425ab943, p_p3 = 0x7ffc425ab944
*p_p1 = 10, *p_p2 = 10 *p_p3 = 12 

тоесть p_p1 и p_p2 имеют одинаквые значения
а p_p3 имеет занчение на +1 больше. 
и во втором принтф мы вытащили то что хранися в перереенных на которые 
укзывает поинтеры. наши исходные 0х10 и 0х12

из этого куска я хочу сказать важные выводы.
один вывод по поводу переменной которой обозанчаетмассив.
если мы юзаем просто vasya то для комплиятора это сигнал что нужно в этом месте вставить
АДРЕС начал масива.
если мы юзаем vasya[0] то это сигнал для комплиятора что вэтом месте нужно вставить
значение первого элеента массива. тоесть это уже не адрес. совсем не адрес.
если мы юзаем vasya[1] то это сигнал для комплиятора что вэтом месте нужно вставить
значение второго  элеента массива

 char vasya[2];
 char *p = vasya;
 char *p1 = &vasya[0];
 char *p2 = &vasya[1];


поэтому когда я сую знаения по поинтеры то во второй строке я просто пишу vasya ибо это 
уже адрес. а в тетей и четветртой строке я использую директиву & которая образначает кмплтору
что нужно взят указанную перменную и найти ее адрес и вставит адрес. 

втрой вывод такой.
что с точки зрения комлиятора массив такого типа это с одной стороны вроде как единая
макромстурктура. а с другой стороны это куча независимых переерменных одного типа собранная
в одном месте. поэому если у меня есть адрес одного из элементов этого массива тот этот элмент
является полноценной незавиисимой перерменной этого типа. тоесть с токчки зрения компдяитора
вот эти две переменных они абсолютно равценоенные

 char  a;
 vasya[1]; // из массива  char vasya[2] 

и то и то с точеи зрени компиятора это незавиисмая переменная типа char.
несморяр на то что вторая хрень входит в состав массива. с точк зрения компиятора 
типа ну и что? все равно размер этих пременных совпадает. именно ппоэтому можно делать 
вот такое приаврравнивание

 char *p2 = &vasya[1];


и получатся что у нас слеав заявлен поинтер которму можно укзывать на перменную с типом char
а справа у нас адрес второго элемента массива где каждый элмент имеет тип char.
если рассатриват каждвый элемент как независиммую пременную (а почему бы и нет) то 
тодгда этот жлемен ялвяется переменой типа char. и поэтому ее адрес можно соавть внутри
поинтера p2.
вот такой прикол.
отсюда приходит ОЧЕНЬ ВАЖНЫЙ И ШОКРИУЮЩИЙ ВЫВОД - о том что если у нас есть поинтер и у него
задан тип. то этот тип нам предпиысывает соклько байт нужно считать по указаному адресу 
чтобы получить значение переменной. например char *p2 нам предпиывает что если мы связались
с этим поинтером то нужно по указаному адресу считывать строго 1 байт. не более. 
например пусть у нас p2=1234, тогда мы обязаны при пользовании поинтером p2 считывать начиная
с адреса 1234 тлько 1 байт небольше. тоесть нам нельзя читать байты 1235 1236 итак далее.
нахождение там каких либо данных негарантировано. рантше я думал что нахожддение данных
там дальше нетлоько не гаранторвано а более того их там строго нет. как я жестоко ошибался.
так вот тип указанный у поинтера совершенно не запрещает чтобы по адресам котоыре находяятся
дальше  тоесть 1235 1236 небыло данных. они там могут быть . их там может не быть. мы этого
незнаем. но возможность нахождоения там данных незапрещена как я думал ранее. все о чем
гворит нам тип поинера это тлько о том что тип поинтера нам гарантирует что по указанному
адресу АБСОЛЮТНО ТОЧНО есть столько то байт данных. и их можно и нужно считать.  а есть
ли там данные дальше или нет. неизвестно. может и есть это не запрещено. 
что собствтенно и видно когда мы присваиваем поинтеру адрес внутри массива из однородных 
элементов. поинтер нам точно гарантиурет что по указному адресу точно есть 1 байт. а есть
ли таам дальше байты может есть а может нет. это не наше собачье дело.
раншея думал что там дальше конечнонет больше байтов данных . я жесктоко ошибался. 
если поинтер укызвает на какйото тип по какому то адресу. то он указывает минимальное число
байт с данным которое там есть. но там запросто может лежать и гораздо боольшее число байтов
даннных. 
посольку поинтер предписвыает читать и писать строго то число байтов по указному адресу 
котрое указано в его типе то получается что совешенно неважно как мы будем раотать с элементом
в массиве - либо чрез поинтер проавильного типа либо через интфрейс работы с массивом. 
тоесть мы не повредим сосдение элеенты масива. и мы элемент массива прочитаем и запишем целоиком
а не частично. пример

  char vasya[2] = { 0x11, 0x12};
  char *p2 = &vasya[1];
  *p2 = {0x13};


во второй строчке мы записали в поинтер адрес второго элемента массива. это корктная операция
потому чтопоинтер иммет тип char и элемент массива имеет тип char.
в третеьй строке мы чрез пинтер меняем значение второго элемета массива. так как у нас 
поинтер имеет тип char то комплиятор сгенериует код котрырй по указаному адрсу пошлет именно
1 байт. поэтмоу мы незаданем другие элемент массива и мы модифицируем второй элемент массива
целокмо а не частично. все пройдет коректно.

   //
   int ii_1[3] = { 0xAABBCCDD, 0xEEEEEEE, 0XFFFFFFFF};
   int *p_ii = &ii_1[1];
   *p_ii = 0xBBBBAAAA;
   printf ("ii_1[1] = %X \n", ii_1[1] );
   printf ("ii_1[0] = %X, ii_1[1] = %X, ii_1[2] = %X,\n", ii_1[0], ii_1[1], ii_1[2] );
   

вот такой код. у нас масив из трех элементов. каждоый имет тип int это 4 байта.
далее я создаю поинтер тип INT. и заношу в него адрес второго элемента из массива.
так как массив имеет тип INT то каждый элмент имеет тип INT. и каэдйэлемент сточи зрения
клмплятора это полноценный нзависисй элемент такоо же типа INT. поэтому колпиятор разершает
занести в поинтер адрес вторго элемента. таким образом когдмы мы получаем такой поинтер
с типом INT то комплиятор гарантирует со стороны данного поинтера что по краней мере 
4 байта данных у нас точно есть если начать читать по адресу храняемуся по этому поинтеру.
и это правда. потому что по ээтому даресу как раз хрнится 4 байта второго элемента массива.
в третьей строке я прошу комплиятор записать по адресу хранящнему в поинтере 4 байта указаных
данных. так как поинтер имеет тип INT то он гарантирует что если мы прчитаем 4 байта
по указаному адресу то там точно лежит 4 байта данных а не мусора. также этот поитер нам 
дает права записать по ээтому адресу 4 байта данных. мы это делаем.
в следущей сторке я проверяю содеживомеое второго элемента масива но уже через инерфейс
самого массива. выражение  ii_1[1] говорит комлиятору чтобы он нашел в своей внутрней памяти
внутренюю переменную комплиятора с именем ii_1 котоаря выражает адрес начала массива в памяти
прогармым и сформирвал такой код на асбелере который вытащит из массива значение второго элемента.
и далее эти 4 байта скрмлваиваются на входу функции принтф. которой через модификатор %X указано
что в аргументе должно быть 4 байта и что приртф должен эти 4 байта на экране нариосвать в 
hex формет. итак что мы видим на экране

ii_1[1] = BBBBAAAA

в следущей строке я хочу убедится что остальные элементы массива не пострадали

ii_1[0] = AABBCCDD, ii_1[1] = BBBBAAAA, ii_1[2] = FFFFFFFF,

и да - они не пострадали.


таким образом суперважная инфо о том что - мы можем совать внутрт поинтера нетолько адрес
какойто простецкой перменной но и адрес элемента массива. при условии что тип поинтера
и тип массива совдадает. потмоу что с точки зрения комплиятора массив из элеметов это не единая
монолитная струутрура а просто кучка независиимых перееных котрые собраны в одну кучу в памяти
и не более того. поэтмо какая разница или это отдельная пермтенная или это перменная находящася
вместе с друими просто рядышком в памяти ну и что. 
поэтому если мы видим поинтер и у него есть какоето значение. тоесть адрес. и у поинтера есть
тип. то ненужнодумать что по указаному адресу есть полезные байты данных толко в размере
типа поинтера. например елси поинтер имеет тип CHAR и в него записан адрес 1234 то неужно
думать что только по адреу 1234 сидят немусорные байты. это необдяатлеьно так. может быть 
немусор сидит тлоько по адресу 1234 но совершено реально также и подругим адресам которые смежные
тоесть 1233 или 1235 могут сидеть не мусорные байты. но! если мы лезем в перерменую через поинтер
то нужно читать и писать только то числ байтов которое предписано в типе поинтера. ненадо 
саммтоятельно лазить ни влеово ни вправо. это ненаше собаьче дело что там харнися в байтах
слева и справа от положенных там в поинтере. мы лезем в какието чужие смежные данные и этого
делать ненадо. кмплиятор нам на стадии  занеесения адреса в поинтер делает проверку и гарантурет
что по указному адресу точно есть ровно столько байтов не мусора как указанов поинтере. 
это он проверяет иначе он недаст скопилирварь программу. а лазить через поинтер в другие смежные
байты ненужно. но так конечно на прмиере массива слева и справа от данных предписанных типом
нашего поинтера могут сидеть немусорные байты с какимито данными.
а я раьше по свой глупостидумал что есл у нас есть поинтер

char *p ; и у него адрес 1234 то это якбоы всегда значит что по адресу 1234 есть немусор
а по адресу 1235 или 1233 оязательно уже мусор пустотам. как жестокого я ошибался. там может
небыть данных . данные там могут быть. но это уже не наше собачье дело туда соваться через 
этот поинтер.










