надо разобраться с переменными в си.

часть статьи вначале воможно брехня. но чем ближе к концу тем 
все больше и больше правды. переделывать всю статью нет сил.
поехали..



простые переменные  int a ;
массивы 	char vasya[14] ;
поинетры    char *p  ;
массивы поинеров  


когда мы говорим про переменную то нужно понять  какие у нее есть атрибуты.
причем нужно также понимать что у нас коанда текстовая и в ней понятие переенменной. есть компилятор. а есть программа на ассемблере.
и нуно пнимать что переменная с точки зрения этих трех штук это разная вещь.
компиляттор это хрень которая знает что такое перменмееная с тчоки зрения теста на си
и что такое пернпеммеенная на ассемблерее. и он одно переводит в другое. 

есть имя переменной. есть ее значение. есть ее тип.
это с точки зрения текста на си. это с точки
зрения компилятора. про тип мы ниже поговорим. но самое главное про тип пееременной
это то сколько байт он будет занимать в оперативной памяти. 
а когда комилятор преоббрзазует текст на си в ассемблер (машинные коды). и потом
мы запускаем эти коды то у нас появляется оперативаня память. у нее есть адреса.
и в них байты как значение.
с этой точки зрения наша переенная она уже не имеет имени. она имеет адрес\адреса в памяти.
и начиная с этого адреса сколко то ячеек в памяти содержит тело переенной. ее значение.
это связано также с длинной в байтах сколлкьо значение перменной занимает в байтах в памяти
ее размер. 

итак еще раз переменная  сточки зрения текста на си:
   имя переменной (вместо адреса)
   значение переменной
   тип
с точки зрения компилятрора:
   имя переменной
   значение в виде текста
   тип
   адреса  в памяти 
   значение в виде байта в памяти
   размер в байтах в памяти
с точки зрения асссеблре кода:
   значение
   адресса в памяти
   размер в байтах в памяти

таким образом имя переенной в тексте она виртуализирует адрес в памяти. тип переменной
вируализирует размер  в байтах в памяти



поговрим про типы.
у си каждая перменная имеет всегда тип. 
зачем нужен тип. потому что комплиятору который сздаем асемблер код нужно знать
какие команды создавать которые будет создавать эту перменнуюв в памяти. нужно знать 
сколько байтов нужно будет аллоцировать под эту переменную в памяти.и потом кода мы будем
считыать ее из памяти то нужно знать какой командой ее читать. дело в том что если перменная
многобайтовая то мы же при чтении указыаем тлоько адрес первого байта. а дальше то колько 
байт будет считано зависит от регистра в котоырй мы читтем. будет ли считан 1 байт
или  2 байта или 3 байта или 4 байта. итак тип перменной задает сколкьо байт она занимает 
в памяти. 

возьмем простой тип как int


   int a = 0x10;

этот тип занимает 4 байта в памяти.
тепер важный момент. у нас переменная имеет тело. то есть тот кусок памяти где хранится ее 
значение. например 0x10 в 4 бйатовоом виде будет в пмяти выглядеть вот так

	 0х10 0х00 0х00 0х00   

если адрес первого байта 1234 то будет вот такое распрееление по адерсам

1234 	0х10
1235 	0х00
1236 	0х00
1237 	0х00


замечу что если у нас многобайттвоое выражение  то в памяти сохраненеие начинается с младщего
байта . тоесть на бумаше мы привыкли пиасахть числа наоброт первый байту нас старший. тоетс
если на бумаге   тоесть в тексте нашей программы на си у нас число вылглядит как 
   0x11223344
то в памяти это число будет сохранено наоброт вот в таком виде
   0x44 0x33 0x22 0x11

поэтому наше число из прогиаммы 0x00000010 то в памяти оно запиывается вот так

1234 	0х10
1235 	0х00
1236 	0х00
1237 	0х00

так вот где тело ллежит нашей перменной мы поняли. возникает вопрос а где в памти нашей 
прогарммы хранится адрес первого байта этого тела. как ее наша программа будет находить?
ответ - нигде он нехранится в памяти. просто напросто
(внимание) компилятор он на стадии созания кода он  хардкодит "мержит" адрес этой перменной
прямов в код ассемблер команд. тоесть самое тело программы и содержит адрес этой переменной.
тоесть если нам в тексте нужно обратиться к этой пременнй и мы пишем

   b = a + 1;

то комплиятором геннерииуется ассмблер код который вытаскивает эту перменную из памяти и 
кладет ее цпу регистр. и тд. например вот так

    mov eax, [1234];

и вот этот 1234 и это и есть то место тот способ которым  вмерживается адрес нашей перменной
в нашу программу. тоесть адрес нашей перменной где она хранится и ее размер вмеривается просто
тупо в код в виде конкнетных чисел в код нашей прогарммы! тоесть как наша прогарма узнает 
адрес этой перменной в памяти. а вот так что ее адрес прям вмонтирован в код нашей программы.
ну а имя перменной это просто указатель для нашего компиятоора в процессе его работы чтобы 
он для себя понимал про какую пременную мы ведем речь. хотя я хочу скаать что в самом эльф 
файле будет тоже присствовать слово "a" которое имеет наша переменная имя. но это отденый 
разговор о прерврашении эльф файла в код раобаотающего процесса. я щас не буду этого 
касаться. 
итак важно понять что когда у нас код на асебплере уже работает то в памяти есть только 
тело файла которое лежит по какому то адресу. а спец места в памяти где отделно запиасано
где искать эту пермнную - аткого нет. инфморация о перееменной вмонтирована в сам асемблерный
код нашей прграамы. он и несет эту инфо. 


непмного пимеры типов перемененых.

long int = 0x0000000000000010 \\ размер 8 байт
int a = 0x00000010 ; \\ раозмер 4 байта
short int = 0x0010 \\ размер 2 байта
char b = 0x10; \\ размер 1 байт



теперь кода мы поговорили про  простые типы. я сразу заведу речь про поинтеры.
поинтеры это такая переменная в которой не хранится конечное значение как у простых 
переменных а хранится адрес памяти где лежит какая то перенная созданная до этого.
поэтому размер поитера либо 4 либо 8 байт. потому что адрес памяти по длине он либо 4 
либо 8 байт. 
теперь надо понять что в самой  программе на асемблере поинтер выглядит всегда одинаково
вне зависимости на какую пееренную он укзывает. в поинтеер просто лежит некий адрес.
но на какой тип переменной он укзывает в программе на асемблере уже хуй узнаеь потомучто
комплиятор так составляет ассмблер код что там нет доп иформации о том на какой тип
переменной укзывает этот поинтер. но! в тексте на си мы при создании поинтера обязаны это 
указать. потому что сам компилятор на стадии компиляции должен четко знать на какой тип
переменной мы собирается ууказывать через эттот поинтер. только на этот тип перменной он 
может укзывать. так вот в тексте на си поинтер содается вот так

  int *p;  \\поинте который укаызвает на int переменную
  long int *p ; \\ поинтер который укаызвает на long int переменную
  short int *p;  \\ поинтер который укаызвает на short int переменную
  char *p;  \\ поинтер который укаызвает на char переменную

еще раз почеркну что когда скопилированая прграмма начнет работать то точка памяти где
сидит поинтер будет в себе содержать только адрес. но на какой тип данные укызвает этот 
адрес у нас никкой инфо не будет. информация о типпе поинтера есть только у компиятора
в памяти компилятора. и болше нигде. только коиамапилиятор знает наш тип  будущего поинтера.
когда компилятор видит тип поинтера то он разрешит нам в этом поинтре хранит адрес
только переменной того типа какой тип у поинтера. правда есть особые поинтеры

  void *p;

но я их трогать пока небуду.

по поводу звезды

  int *p;

ее можно хоть так хоть так

  int *p;
  int* p;

хотя по идее правльнее вот так

  int* p;

потому что если без звезды

  int p;

то тогда у нас будет перенная обычная. обычного int типа.
а здвезда намекает компилятору что это именно поинтер. если бы без типов 
то поинтер бы обозначался как

  * p;

тоесть * означает тип поинтер. я бы делал бы вот так

 pointer p;

но эти скоты вставили вместо pointer значок звзды *

  * p;

и этой звездой они суки нам много крови попортят. еще увидишь
итак звезда это типа как алиас на слово pointer. и это слоово обозначает новый тип

 pointer p;

нокак я уже сказал компилиятор хочет знать какой именно поинер мы создаем.

  int pointer p;

и тода он понимает что это поинтер которму можно указывать тлоько на переменную типа int;
замеяем pointer на звезду и получаем

  int* p;


теперь вопрос как мне засунуть в поинтер адрес переменной. я же незнаю адрес переменной. 
да рукам заснуьт в поинтер числ не пуолчится. компиятор пошлет нах. можно это сделать 
толко через особую комипляторную директиву. через директиву &.
вот так

 int a;
 int *p = &a;

 либоо вот так

  int a;
  int *p;
  p = &a;

директива &a имеет смысл - эй компилятор найди адрес переменной a и подставть внутрь поинтера.
но эта директива сработает только если у нас совпадает тип поинтера и тип переменной
тоесть вот такое будет ошибка

  int a;
  char *p;
  p = &a;  // <=== ошибка

потому что если мы пихнем адрес переенной a в  поинтер р то  у нас поинтер р будет указвать
на перемену char а ведь в типе поинер а указан тип int.
поэтмоу ошибка

я малек еше про поинтеры скажу. до этого я говорил о том как обьявиить поинтер.
а как нам получит доступ к пеермренной на которую укаызвает поинтер? а вот так. берем
имя поинтер переменной и приставляем к нему слева звезду. звезда участвует при 
создании поинтера. это одно

 int * p;

а когда мы хотим через имя переменной p полуить доступ к переменной на которую он 
указывает то нужно делать вот так

  *p = ...

или 

  ... = *p;

тут я ксатти хочу заюзать вот такой вопрос. что происходит когда в тексте на си 
мы юзаем имя переменной. 
например мы обьвяили перменнуюю

  int a = 10;

а потом где то в тексте мы используем имя 

  ...a ... 

так это обычно значит что мы хотим либо прочитать значение из того места где хранится
переменная в регистр в цпу. или наоборот мы хотим записать некоторое значение туда
где хранится тело переменной. тоесть мы в тексте прогармы мы в конечно итоге мы юзаем 
имя переенной либо чтобы прочитать значение перменной и кудато его отдать либо записать
новое значение. примеры

  a = ....
  ... = a;
  либо  func1(a,...)

тоесть в тексте на си нас обычно иинтересует только значение перменной. все остальные 
атрибуты переменной это антуражная обслуга (тип пперменной , ее адрес в памяти итп) кторрая
нужна компилятору. но нужно не нам. 
итак еще раз важно понять - когда мы вилим имя переменной в тексте на си то таким макаром
мы хотим получить значение этой переенной. либо мы читаем откуда то в наш цпу значение
либо мы запиываем из цпу кудато новое значение, тоетть когда мы пишем в тексте имя переменной
то мы хотим получить доступ к ее значению. к ее телу. либо мы хотим его считать либо 
его записать.







теперь про массивы.
переходим к реально ебанутой теме.
массив это такой тип переменной.
тип переменной означает что у нее такой то размер в байтах  в памяти. 
это не то что 
это целое число или целое со знаком или что это цисло с запятой. НИХУЯ. ЕЩЕ РАЗ - НИХУЯ.
в оперативке нет никаких чисело. там есть только байты. так вот тип переменной в си
для компилятора это прежде всего ЧИСЛО БАЙТОВ КОТОРЫЕ ЭТА ПЕРЕМЕННАЯ ЗАНИМАЕТ. вот что
такое тип переменной. это просто сколько кусков байтов нужно аллоцировать в памяти. 
мы уже говорили про типы int, long int, char. эти слова это всего лишь навсего булл шит.
это не какие не целые и прочее. это все области памяти определенного размера которые нужно
у памяти забрать. поэтому int это синоним 4  байта. long int это синином 8 байт.
char это синониим 1 байт. 
так вот массив это новый тип. значит это какойто кусок в памяти которые нужно занять.
так вот массив он не имеет фиксированного значения. 
массив не имеет предопределенного фиксированного размера. вместо этого мы руками задаем
сколко байт нужно у памяти забрать. переменнная с типом массив задается примерно
вот так 

  int vasya[50];

это значит переменная vasya имеет тип массив. какой же размер этой переменной?
размер в памяти у нее такой - 50*size(int) = 50*4=200 байт.
при обьявлении этого типа переменной у нас комплиятор аллоцирет из памяти 200 байт.

а если вот так

  char vasya[50]

то опять же 50*size(char) = 50*1 = 50 байт
значит этот vasya тоже отожрет в памяти 50 байт.

итак тип переменной это прежде всего о чеем? это  о том сколько байт компилятор должен забрать
у памяти. 
в отличии от обычных типов (long,char,int) тип массив не имеет фиксированного
значения. значения задаем мы. задаем диковаинным образом. укаызаем обычный тип и пишем
число.

так поняли о том что массив не имеет предстановленного фиксированного размера в памяти.
теперь к вопросу - вот что будет если я использую имя пеерменной тип массив в тексте на си.
как я уже выше сказал что обычно при использовании имени переменной мы получаем доступ
к телу переменной. к ее значению. например создаем переменную vasya тип массив

  char vasya[50];
  b = vasya;

я щас оставлю за скобками о том как мы создавали переенную b.
зато во второй строке  у нас vasya используется в том смысле что мы говорим компилятору
вытащи  значение из тела vasya и запиши его в тело переменной b.
так вот компилятор такого делать не будет. да. пиздец. оказывается что компилятор далеко не для
всех  типов переменных позволит  прочитать их значение из тела переменной. или записать
в тело значение. 

ЕЩЕ РАЗ - я хочу подчеркнуть эту революционную мысль, о том что мы привыкли  к тому что когда
мы используем имя переменной то компилятор нам либо читает из памяти и выдает нам значение
переменной. либо компилятор пишет в память новое значение в тело переменной. 
вот например в таких прмиерах

 ...   = vasya;
 vasya = ...;

так вот в случае если переменная имеет тип массив то компилятор создает тело для этой переменной
в памяти. тоесть эта переменная реально существует в памяти. в памяти есть блок который содержит
тело нашей переменной. она такая же переменная как и другие переменные. у нее есть тело в памяти.
она рельная. она сущетствует НО! компилятор не позволит ни читать из этого тела ни писать в это 
трудно поверить но это так. спрашивется а нахуй нам нужен такой тип? мы создаем переменную
с таким типом. компилятор аллоцирует(занимает ) память для тела этой переменной. но блин 
мы не можем совать значение в тело этой переменной используя привычную конструкцию

  int vasya[50];
  vasya = ....;   \\ <=== ошибка ! 

тут прикол. компилятор нам дает другой нестандартный способ как засунуть байты в ту область
памяти которая занята телом этой переменной. а именно. после того как мы создали vasya то 
компилятор автоматом создаем целую кучу переменных. в данном конкретном нашем примере 
компилятор создаст 50 переменных с типом int. дадада. без нашего ведома компилятор сделает это.
так вот компилятор создась эти переменные в точности внутри той области памяти где лежит тело
переменной vasya. дада с точки зрения компилятора получается очередная чудная ситуация. у нас
одновременно в одной области памяти лежат с одной стороны 50 int пееременных и в тоже время одна переменная массив vasya. так вот положить байты в эту област используя имя vasya запрещено,
но компилятор разрешает класть байты в эту область используя эти 50 int переменных.
щас я покажу как это делать. чтобы это показать я еще скажу что эти автоматически созданные
переменные имеют особые имена. а именно vasya[0], vasya[1], .... vasya[49]. я считаю что это 
было дебильно сделано что они всунули слова vasya в эти имена. потому что ты не понимаешь что 
за хуйня.  у нас уже есть переенная vasya причем тут эти хрени vasya[i]. так вот использование
компилятором слова vasya в имени переменных vasya[*] это лишь такая ебанутая хуйня которая
используется компилятором при создании отдельных независимых пеерменных чобы указать что тела
этих переменных лежат внутри области памяти переменнной vasya. вот и весь смысл использования
смысла слова vasya в имени vasya[i]. тоесть это смысл такой: 

    vasya[0] = это переменная условно с именем  А. но имей ввиду (так говорит компилятор)
               что тело этой переменной лежит  внутри области памяти переменной vasya.


тогда мы можем менять тело переменной vasya через переменные vasya[i] вот так

    vasya[3] = 0x10111213;

тогда в области памяти где лежит тело vasya начиная с офсета (0+3*size(int)) = 12
у нас будет два байта изменено

  0  1  2  3     4  5  6 7       8  9 10 11     12 13 14 15  ...

 00 00 00 00    00 00 00 00     00 00 00 00     13 12 11 10  ... 
 

тоесть унас будут заменены байты с оффсетами 12,13,14,15


вот таким макаром нам компилятор разрещает менять тело той области памяти котоаря выделается
для тела переменной vasya.
тоже самое касается как прочитать из тела массива.


 int b;
 b = vasya[3];

таким маккаром компиляор прочитает часть байтов из области памяти перменной массив vasya

еще раз подчеркнут что   vasya[3] это совершенно отдельная переменная с точки зрения 
компилятора. просто у нее дурацкое название которое ее смешивает с переенной vasya. это нетак.
это две совершенно разные переменные. переенная vasya[3] условно имеет имя A. но ее дурацкое
имя говрит о том где находится ее ТЕЛО. ее тело находится внутри тела переменной vasya
по офссету 0+3*size(INT) внутри тела переменной vasya. вот что значит ее дурацкое имя.
тоесть ее имя это информация о находждении ее тела внутри тела перменной vasya. да компилятор
разрешает такую хуйню - чтобы тело одной переенной лежало внутри области памяти другой
переменной. в этом необычность. итак попасть в область памяти перенной vasya через имя этой
переменной невозможно. тоесть напрямую менять значение этой перменой нельзя. ни изменить нельзя
ни прчитаь нельзя. только через сторонние пременные. назовем их вспомогателные переменные
которые компилятор создает автоматом. но хоть чтото можно делать полезное с переменной vasya
исплоьзуя имя переменной vasya. ответ - да можно. можно получить адрес где начинается в памяти 
тело этой переменной. но для этого нужно использовать спец тип поинтера - поинтер на массив.
и делаем это вот так


   int (*p)[50] = &vasya;

вот - вот первый пример когда мы можем хоть чтото полезное получить используя имя vasya.
тоесть через имя vasya мы неможем добраться до ее тела. до контента который хранится в памяти 
в теле. но мы можем получить адрес начала где это тело лежит. 

теперь вот что. есть совершенно конченая залупа как ведет себя компилятор при упоминании
имени vasya в текста на си. то что он делает это не нелезает ни на какую голову.
если я использую слоово vasya справа от равно вот в таком примере


  int *p = vasya;


если мы посмотрим на эту формулу. то можно охуеть. потому что она неимеет никакого смысла.
никакого. это полное нарушение всего что можно приудмать.  потому что у нас слева создается
переменная поинтер. а справа стоит переменная которая не поинтер нихуя ниразу. еще раз
повторю переменная p которая слева она имеет тип=поинтер а справа стоит переменнная тип=массив.
это абсолютно точная инфо. слева у нас поинтер. справа у нас не поинтер. но мы их прирваниваем.
это полный пиздец. это должно порождать ошибку. но ошибки не будет. ПОЧЕМУ НАХУЙ? ПОТОМУ ЧТО -
если компилятор увидит справа от равно слово vasya то компилятор (внимание) убирает из текста
слово vasya и меняет его на &(vasya[0]);


  int *p = &(vasya[0]);


и в этом случае это уже имеет смысл. это коректно с точки зрения типа переменной справа
и слева. потому что vasya[0] это переменная которая имеет тип INT. еще раз надо четко понимать
что перееменная vasya и vasya[0] это две совершенные разные переменные. у них совершенно
разные типы.  vasya имеет тип=массив, а vasya[0] имеет тип=int. это двесовершенно разные
переменные с совершенно разными типами. поэтому забывает про переменную vasya и 
обращаем внимание на vasya[0] . она имеет тип=int.  поэтому далее мы смотрим налево
и видим поинтер p котрому разрешено содержать в себе адрес только на переенную с типом int
а справа у нас стоит адрес указывающий на пееменную типа int. бинго. полное совпадение.
теперь типы совпадают. тоесть поинтер p запиывется адрес который укаызает на адрес в котором
лежит тело переменной которая имеет тип int. 
я вот щас перепишу немного то что выше вот так

  int *temp = адрес переменной vasya[0];
  int *p    = temp;

это полная аналогия того что выше. у нас можно представить компилятор создает временный поинтер
которому разрешено в себе содержать адрес переменной vasya[0]
и далее адрес из temp копируется в p. это можно сделать потому что у temp тип=int*
и у p тип=int*
теперь еще раз посмотрим на эту строку


  int *p    = temp;

важно то что слева и справа стоят переменные с одинаковым типом. и более важно то что 
то что стоит справа это переменная типа поинтер. это поинтер.
а теперь посмотрим ту формулу которую можно написать в программе и компилятор не выдаст
никакйо ошибки


  int *p = vasya;


теперь сравним ее с формулой

  int *p    = temp;


смотря на нижнюю формулу и смотря на верхнюю мы обязаны утверждать что переменная vasya 
обязана иметь тип=поинтер. и тут мы открываем пиздец о котором я уже сказал. дело в том что
переменная vasya имеет НЕПОИНТЕР. вася это точно не поинтер. поэтому формула

  int *p = vasya;

нихуя неправильная. некоректная. эта формула это полная хуйня. это полная мозгоебка.
ЕДИНСВТЕННАЯ ПРИЧИНА почему компилятор не выдает ошиьку на эту формулу это только потому
что компилятор когда встречает эту формулу то он сука ее прозрачно на автомате меняет
на соверщенно другую. в этом и пизда. что он делает совершенно другое. он меняет эту 
формулу на совершенно другую 


  int *p = &(vasya[0]);


то что стоит справа это совершенно другая хрень неежели чем в исходной формуле. 
еще раз подчеркну что  vasya и   &(vasya[0]) ЭТО СОВЕРШЕННО РАЗНЫЕ ХУЕВИНЫ. СОВЕРШЕННО.
но компилятор не моргнув глазом меняет одно на другое без всяких проблем.  тоесть еще раз
когда компиятор видит в тексте кусок


  = vasya

меняет ее на совершеннодругой кусок

  = &(vasya[0])


ЭТО ПОЛНЫЙ ПИЗДЕЦ. эти два куска не равны друг другу никапли. но компилятор это делает 
не моргнув глазом.  и тут важно понять что такая конченая замена имеет место ТОЛЬЛКО если 
у нас в тексте идет голое слово vasya. тоесть если мы юзаем vasya вместе с какойто директивой
например &vasya то это ебанутое поведение компилятор тутже прекращается. тоесть если 
компилятор встретит кусок в тексте

  = &vasya

он уже НЕ БУДЕТ делать такие дебильные замены. он уже будет работать как положено. тоесть 
это не приведет к замене на =&(&vasya[0]) - нет такой хуйни не будет. только если у нас в тексте
есть слово vasya в голом виде без всяких директив то тогда происходит эта дебильная замена.
главное про тип=массив я сказал.

теперь некоторые детали.
вот эти два поинтера


  int *p         =  &(vasya[0]);
  int (*p2) [50] =  &vasya;

так вот адреса памяти которые будут лежат в поинтерах p и p2 они будут одинаковые! хотя 
поинтеры имеют РАЗНЫЕ ТИПЫ. и поинтеры по факту указывают на разные переменные. это возможно
только потому что у нас тело одной переменнйо лежит в области памяти второй переменной. поэтому
возможен такой прикол. также важно понять что так как поинтеры имеют разный тип то приравнять
один поинтер к другой нихуя не получится. тоесть неважно что у нас у двух переменных одинаковое
тело в памяти по размеру. реально - любой поинтер его тело имеет  размер 4 байта (32бит цпу)
но есди они имеют разный тип то приравнять один к другому неполучится. будет ошибка.

как говорит ии в си сделано так что если мы ставим имя массива в нашем случае это vasya
справа от равно либо как аргумент при подстановке в функцию то компилятор автоматом меняет
vasya на адрес первого элемента внутри массива vasya то есть на &(vasya[0]).

еще один пример того какую пользу можно получить через имя vasya, а именно
можно используя имя vasya записать в тело этого массива значения но это можно 
сделатьт только используя стороннюю функцию

 char vasya[10];
 strcpy(vasya, "123456789");








далее. я продолжаю рассуждаь про массив и поинтеры. я написал этот материал по времени 
более раньше. поэтому там может быть и какаято хрень.

  int vasya[50];

тогда компилятор считает по формуле 50*size(int) = 50*4=200 и алоцирует в памяти 200 байт.
также как и и обычных переменных в этом куске памяти будет лежать тело переменной. 
дальше начинатеся некоторый ад.
мы привыкли что содержимое(тело) обычной переменной мы иницлизиуем как то вот так

  char a;
  a = 0x10;

  short int = 0x1020;

  int a;
  a = 0x10AABBCC;

  long int a = 0x1020304050607080;

так вот тип массив мы так ннихуя не иницлизируем. тоесть вот так не будет

  int a[2];
  a = 0x10203040; \\ так нихуя мы не сможем сделать

тоесть у нас тело массива не рассматривется как единая хрень как это есть у обычных типов.

что у нас обычно подразумевается под переменной. подразумевается под ней оббласть в памяти
где лежит значение. паять может быть несколко байтов длинной. а в ней лежит значение.
тоесть

  int a = 0x10203040;

так вот под буквой "a" в тексте си программы тоесть с точки компилятора поразумевается 
кусок памяти 4 байта которые нужно у памти отнять. и значение 10203040 которое там лежит.
тоест переменная под собой поразумевает два аспекта - нужно в памяти занять нескоько байтов
начиная с такогото адреса.  и полложиить туда значение. получается переменаая это означает
что нужно знать куда слазить (по какому адресу) и считать нужно знать сколько байт.

таким образом когда мы создаем переменную то компилятор ищет адрес. и начиная с этого адреса 
занимает столоько то байт. в этих байтах тело переменной. ее значение. которое нам 
в программме обычно и нужно. а адрес в памяти где оно лежит и число байтов которые оттуда
нужно считать это второй аспект переменной.  адрес в памяти где перееную нужно искать
и сколько читать или писать в тот адрес компиляттор формирует через конкеный вид ассембелерных
команд. в них хардкодится адрес переменной и число байт которое считать. а как результат
регистр получает в свои недра значение. 

итак мы пишем

  int a = 0x10203040;

а в ассеблере будет типа

  lea eax, 1234
  mov ebx, [eax]

итак мы пишем в тексте

  int a;
  a  = 0x10203040;

а компилятор ищет в памяти стартоый адрес. и аллоцирует там 4 байта. а потом туда пихает
значение. 

итак еще раз - что нужно думать когда мы видим имя переменной в тексте программы.
это значит что она собой с точки зрения компиятора подразумевает три характеристкии
   адрес в памяти
   размер в байтах
   значение
  

с точки зрения памяти то это столько там которые лежат начиная с таого то адреса
с точки зрения текста ассемблерного кода там будет захардкожен адрес памяти 
и размер. 

когда мы пишем

  a  = 0x10203040;

то комплиятр создает текст асемблерный в который хардкодит адрес начала. харкодит размер.
и команда кладет значение в указанный кусок памяти.

по сути переменная предстлавяет собой несколько обьтектов.  это кусок памяти котоырй имеет
адрес начала и размер. значение которое там лежит. и кусок кода в который записан адрес
начала в памяти и размер области в байтах. тоесть память является носиетелем значения
переенной. а код является носителем адреса памяти где искать. и размер в байтах.
таким образом переменная как много факторая  сущность размазана по двум разным субстанциям 
- одна ее часть сохранена в коде, вторая в теле памяти. 
итак когда мы смотрим на код

  int a;

то надо понимать себе что адрес переменной  в памяти будет сохранен в коде ассемблера.
размер в памяти тоже будет сохранен в коде асемблера.
занчение будет тоже сохранено в коде асемблера. 
как итооге значение будет из текста асемблера в памяти.  в итоге некоторый кусок памяти
такого то размера будет занят. аллоцирован.
с точки зрения именно текста си переемнная это некий абстрактный контейнер
который сейчас содержит какето зачение определенной длинны. в контейнере можно менять
его содержимое. с точки зрения текста си есть адрес перменой это ее имя. и есть значение
которое хранисят по этмоу адресу.если мы хотим в переменной изменить значение то мы
берем имя переменной далее ставим равно и значение 

 a = 10;


теперь в контейнере по адресу a хранится значение 10.
это с точки зрения компилятора. это его точка зрения. причем компилятор падла он знает
двае точки зрения. та что есть у ассемблерной программы. и текстовой на си. он знает
обе точки зрения. 


теперь возвращаюсь к типу переменой массив. 
вот в тексте си видим

 int vasya[5];


итак  унас есть имя пеерменной vasya. и у нее тип массив. тип определяет размер тела переменной
в памяти компа. в данном случае компилятор аллоцирет в памяти 4*5=20 байт
начало этого адреса будет вмонтировано в код на асемблере.
еще раз о свойствах которми обладает переменная
   адрес в памяти начальный
   размер в байтах
   значение
   тип

адрес в памяти началныый и размер в байтах вмонтирован будет компиляторов в ассемблер код.
тип определяет размер в памяти а также некоторые другие моменты. щас поговорим
значение хранится в памяти. имя переменной и ее тип существует только в памяти компилятора.
это его термины и для него это описывается. 
переменная vasya  с точки зрения компилятора имеет тип массив. тоест не int а именно
массив. поэтому поинтер на нее должен иметь тоже особый тип  - он называтеся поинтер на 
массив. выглядит он так

 int (*p)[5];

читается как поинтер на переменную типа массив. спрашивается а на какой адрес этот поинтер
указывает? он укаызвает на адрес первой ячейки где лежит тело массива. тоесть вот у нас 
в памяти есть тело массива это блок из 20-ти байтов. так вот поинтер будет укаызать на первый
байт этого тела. 
какойто логики в синтаксиссе обозначения поинтера нихуя нет

 int (*p)[5];

ее нужно просто принять. я имею ввиду конструцию (*p) это просто какая то бессымсысленная хуета.
а то что стоит слева и справа int [5] это просто повторение того что написано в описании
самого массива

int vasya[5];

при том что поинтер заданный через 

 int (*p)[5];

имеет имя p. а не *p. а вот все остлаьное что вокруг этого имени тоесть int (*)[5]
вот эта залупа описывает тип поинтера. при том что мы привыкли что у нас скажем стоит имя
пееренной а левее ее тип. а тут полчается полный пиздец. тут у нас  имя посреедине а слева
и справа от него вся эта хуета это тип этого понтера. охуенная система синтаксиса.
ксатти для массива тоже самое есть имя vasya имеет тип масив и 

  int vasya[5]

так вот тип массив зада опять же слева и справа от имени как int [5] 
мне непонятно захуя было делать такой дебилоидный синтксасис чтобы имя вкорячивалось 
внутрь букв которые отвечают за тип. 
почему нельщя быо сделать вот так

 int[5] vasya;
 int(*)[5] p;

было бы охуенно все понятно и красиво.

итак при обьявлении массива с именем vasya 
нам приходится мириться что имя суется внутрь типа. 

  int vasya[5];

тоесть имя типа это "int[5]" но имя поемуто нужно сунуть внутрь имени типа

  int vasya[5];

при этом в памяти будет выбран кусок начиная с такого то адреса и займет 20 байт.
память будет аллоцирована только для тела массива. под то где адрес где начала этого масива
в памяти никаких ячеек не будет аллоцировано. эта инфа будет зашита захардокожена в 
тексте асмеблерных команд. также сам компилятор знает где это начало. 
так вот поинтер на эту переменую vasya выглядит вот так

 int (*p)[5];

поинтер это значит что мы в явном виде создадим в памяти переменную в которой будет хранится
некий адрес указывающий кудато. в случае если это поинтер на массив то он будет указыать
на адрес начала тела массива. поинтер это не просто поинтер. он имеет тип. тип хранится
только в памяти компиляттора. зато компиятор четко следит чтобы в поинтере хранился адрес 
только такой который укаызает на пеерменную которая имеет строгого тот тип который указан в
типе поинтера. поэтому так как наша перменная vasya имеет тип массив то обычный поинтер тоесть
который имеет вот такие типы
 
  char* p;
  int* p;
  long int ;

в них нельзя записать адрес переменной vasya. потому что их тип не явлется типом массив.
поэтому эти поинтеры не подходят.

теперь еще раз псмотрим на тип который обозначает массив

  int [5]

помимо того что в целом этот тип обознаачает массив. он еще имеет детали об этом 
массиве. тип массив помимо как единая макроструктура которая сидит в памяти в размере блока
20 байт она имеет еще микроструктуру в рамках этой макростркутуры. как бы у массива 
есть поля. кажлое поле это как бы незавиисисмая обычная переменная. все эти перменнные имеют
одинаковый тип. в данном случае int.  добрать до значения каждого поля можно через ситактсикис

  vasya[i]

тоесть 

  vasya[0]
  vasya[1]


тоест кода мы создали массив

  int vasya[5];

то как бутто автоматом комплиятор создает еще кучу доп перменных. 

  vasya[0]
  vasya[1]
  vasya[2]
  vasya[3]
  vasya[4]

каждая имеет тип int.
 ябы даже по другому сказал. когда мы обьявлем массив

  int vasya[5];

то у нас как бутто вначале создается автоматом 5 отдельных переменных

  vasya[0]
  vasya[1]
  vasya[2]
  vasya[3]
  vasya[4]

каждая из которых имеет тип int.  все эти прееменные в памяти хрантся компилятоом
рядышком друг сдругом. непрерывно. 
и на втором шаге комплиятор создает переменную 

  vasya

физ память для нее спцаильно
выделать нунжно. потому что фомрально ееное тело в памяти является собой весь кусок 
который занимают вот эти 5 переменых. 
тип у этой переменной называется массив. int [5] и он как бы намекает что эта переменная
логическим образом обединяет 5 переменных в себе.  
когда мы говорим про обычные переенные

  vasya[0]
  vasya[1]
  vasya[2]
  vasya[3]
  vasya[4]

то ихнее значение можно менять по класичским приемам. тоеть

  vasya[0] = 10;


а вот перемегная vasya которая имеет тип массив  - у нее нет такой операции как изменить 
значение. потому что она скорее такой логический контейнер над реальными переменными.

поинтер на элемент массива содается легко ибо эта переменная (эомент массива) она как бы
обычная и независимая только у нее имя слегка дебильно непривычное. а так она супер обычная
поэтму. так как у нас vasya[0] имеет тип int то поинтер будет вот такой

 int* p = &(vasya[0]);

таким образом поинтер на обычный переменную может указываь нетолко на обычную перменую
но и на элемент массива. потому что элемент массива это обычная перменная просто у нее слегка
небычно дебильное имя. 
итак еще раз так как переменная с именем vasya[0] имеет тип int то поинтер для нее
подходит int*. 
тоест еще раз создаем когда массив


  int vasya[5];

то компилятор создает автоматом пять обычных пременных

  int A1
  int A2
  int A3
  int A4
  int A5

кладет их в памяти рядом. непрерывно.
также создает уже в своей компидяторской памяти переменню vasya 
она отдельного тела в памяти не имеет. для нее в памяти компилятор прописывается что
она имеет тело как раз в том куске где лежат наши 5 обычных переменных. тип этой
пременной укзывается как массив. это все понятия самого компилятора. в ассемблере нет
никаких массивов. фишка в том что си недает механизма изменения тела переменной vasya
потому что она имеет тип массив. и ееное тело меняется через изменение переменных A1,
A2, A3, A4, A5. чтобы както отразить связь меду пермеменной vasya и перермеными A1..A5
то они в тексте фигурируеют под ебанутыми именами 

  vasya[0]
  vasya[1]
  vasya[2]
  vasya[3]
  vasya[4]

фишка в том что это имена по прежнему отдельных переменных. а наличие слова vasya
в их имени это лишь просто намек что эти преременные входят в некую логическую группу.
поскольку каждая переменная собой в памяти являет некий блок. то поинтер на эту пременную
всегда возвоащает адрес первой ячейки где этот блок начинается. так как 

  vasya[0]
  vasya[1]
  vasya[2]
  vasya[3]
  vasya[4]


это все int

то поинтер на любую из них имеет тип int*
напрмиер 

  int* p = &(vasya[0]);
  int* p = &(vasya[3]);
  
диркетива массив нас избавляет нас от ручного труда создания кучи однотипных переменных
руками. тоесть

 int vasya[100];
и  унас автоматом создана куча переменны int. а именно 100 штук.
и к каждой можно обратиться.

а на счет поинтера на переменную vasya то так как она имеет тип массив то обычный поинтер
на нее не подходит нужен поинтер который имеет тип массив

 int (*) [100]  \\ это тип

а вот переменная p

 int (*p) [100]

читается как поинтер на переменную типа массив. где массив имеет более конкнтеный вид

  int [100]

итак я хочу обознаить то что при обявлении массива создается куча обычных перемерменных
и одна спец переменная. обычные переменные они прям реаьно будут иметь свои тела в физ 
памяти процесса. а спец переменная она будет она сущетстует только в пааяти компилиятора. и она
якобы тоже имеет  в памяти некий блок который якобы занимает ее тело. но по факту ее тело
совпадает с суммарным телом которое занимают те обычные перетменные. и также в си нельзя
никак влиять на содрежимое тела переменой типа массив.  по факту данные внутри тела переменной
типа массив меняется за счет изменения тел отдельных обычных переенных.

есть еще один дебильный момент с массивом. если  в тексте на си мы в каком то месте
используем  имя переменной (которая имеет тип массив )  в чистом виде то компилятор дебил 
он интерпертиурет тогда это как указатель на первый элемент массива . тоесть

вот мы обьявилли переменную типа массив

  int vasya[10];

и если мы потом применим в тексте слово vasya то компилятор будет считать что в этом месте
на самом деле стоит имя переменной котрая является поинтером на первый элемент массива. тоесть
вот я напишу в тексте на си слово
  
  vasya

а он считает что я сделал вот так

  int *p = &(vasya[0]);

и тогда якобы вместо 

  vasya

в тексте прогарммы стоит слово

  p

ну или можно другой пример привести. вот я пишу

  int  *p = vasya;

так вот так как мы применили vasya то вместо него там как бы стоит вот такое

  int *p  = &(vasya[0]);

я считаю что то что они творят это полный пиздец. потому что эти суки мешают водну кучу
совершенно разные штуки. 

  vasya[0] это обычная переменная она сама незавизима от переменной vasya. 
у нее в имени стоит слово vasya чтобы только показать что тело переменой vasya[0]
лежит внутри области памяти переменной vasya.
поинтер p1 на переменную vasya котора имеет тип массив

  int (*p1) [10] 

он конечно технически указывает на тот же адрес что и поинтер на переменную vasya[0]
но еще раз скажу что  пеерменная vasya это даже нихуя не поинтер. и тип у этой переменной
ни разу не int. у нас прирванивают две перменные только если у них одинаковый тип.


  int  *p;
  p = vasya;

а какой же нахуй одинаковый тип у поинтера и у массива. это совершенно два разных типа 
переменных. причем прико такой что даже если есть две переменные. котораы имеют тела
одинаковоого размера. как два поинтера

  int a  = 10;
  char b = 12;
  
  int *p1 = &a;
  char *p2 = p1;

но последння комада пошлет нахуй. потому что даже одинаовый размер тела недает право контент
одной перменрй копировать в тело другой перменной. потому что у переменых разные типы.

потэтому когда мы пише вот такое

  int  *p;
  p = vasya;

то это полный пзидец. слева стоит поинтер. у него тело 4 байта. 
а справа стоит прееная типа массив у него даже размер тела другой. скажем 1000 байт.
какже сука можно пернести контент из одного тела в другой? правильно нихуя никак.!
этополное преступление то что они творят.
просто окзывает в си есть такой дебилный момент. если мы создали перменную типа масив
с именем vasya то если мы потом пишем vasya то комплиятор автоматом считает что вэтом
месте стоит не перменная vasya а поинтер на первый элемент этого масива то есть вместо
vasya там стоит &(vasya[0])  

где vasya[0] это такое дурацкое обрзначене обычной перменнйо которую автоматом
создает копилятор которая лежит в тойже области памяти где формально лежит тело переменной
массив. и vasya[0] это перенменная котоаря лежит в самых первых байтах этой области

при этом если мы вот такое учудим &vasya то это кмплиятором уже не считается как применнеи
просто vasya тоесть здесь работа с пременной vasya уже автоматом идет как положено. как
работа с настоящей переменной vasya. 


далее лежит еще отдельный материал.
тогда компилятор берет адрес в памяти. а потом там аллоцирует размер 5*size(int) = 5*4=20 байт

так. двадцвать байт мы застолбили в памяти по такому то адресу.
под именем vasya у нас и подразумевается этот кусок размером 20 байтов.

но значение в эту область памяти мы будем записыват в непривычном путем.

что такое массив. массив это кучка элементов. каждый эелмент имеет один ии тот же тип.
и таких элементов несколько. и они все лежат в памяти кучкой рядом друг с другом.
как его создавааавт
 

  short int vasya[2];

что здесь что значит. 

[2]  - это значит что в массвие два элемента
имя переменной за которрой кроеется этот массив это vasya
то что стоит левее имени массива тоесть   short int это тип элемента в массиве. 
в данном случае значит каждый эелмент занмиает 2 байта. 
значит весь массив занмиает 2*2 = 4 байта в памяти. значит комплиятрор знает что нужно в впамяти
зареервировать 4 байта под тело массива. при этом в памяти опят же не создается доп ячеек 
для указания начала адреса массива в памяти и нет люблой другой инфо о структуре массива.
вместо этого компиялятор держит в своей голове где в памяти лежит этот массив. и он походу кода
нашей прогарммы будет вставлять ассемблер команды  вк отрые уже захардкоден адрес нужного
элемента из этого массива. поэтому инфомрация о структуре массива она задним число полчается
вмонтирована в код прогарммы. обращение кэлементу массива идет в вот так

   vasya[1]= .....;

замечу подставу что при обьлвяении массива символы [2] уазвыают на число эелментов в массиве.
а уже при раотет с массивом символы [1] означают совреено другое а именно порядоковый номер
элемента в массиве. причем номер начинается с числа ноль а не один. поэтому если в массиве 
два эемена то их индексы это 0 и 1.
так вот кода у нас в коде программы на си текстовом идет запись

	vasya[1] = 0x1AB1;

то компилятор создает условно вот такую ассемблерную команду

   lea eax, 1234
   mov bx, 0x1A1B
   mov [eax + 1], bx

соттенно адрес куда мы пишем он захардкоден. просто в форме цифры. и число байтов которое
мы будем писать а миенно два байта определяется размером регистра. ибо bx имеет размер 2 
байта.
где 1234 этоадрес первого элемента массива. а +1 это смещение. тоесть компдиятор налету когда
сотавляет асскмблер код то он в нужных местах в форме числовых констант подставляет нужные 
адреса. тоесть я хочу сказать что в самой памяти процесса не будет никакой ячейки памяти 
где будет спецаильно хрнаится адрес начала массива куда код будет лазит и узанавать - а где
же начало вот такого массива? тоесть я хочу скзать что при создании массива у нас создается
в памяти только тело массива. а в добавок поинтера на начало масива создано не будет. не будет.
копилтятор просто будет по телу програмы хардкодить числоыве адреса элементов этого
массива и все. 

повторюсь vasya это не поинтер внутри нашей прогараммы. никкого поинтера не будет создано
в ассеблер коде.  а vasya это поинтер внутри памяти компиятора пока он генериурет ассемблер
код из нашего текста. поэому да это поинтер но исключаитеьно внутри компилятора. 
а раз это поинтер то тогда может работать вот такая хрень


  short int *p = vasya;

здест p это переенная поинтер. я про них ниже расскажу. а пока просто скажу что в нее запиывается
адрес в памяти. по этому адресу в памяти хранися какая то перменая. таим обраом поинте он не
хранит значение он хранит адрес где хранистя тело перменной. "p" это имя этого поинтера.
опять же  - имя перменной его в асемблер коде нет. в ассемблер коде идет вместо этого 
вставленный захардоженный адрес где хранися эта перменная. тоесть символльное имя это чисто 
укзаатель внутри памяти компилятора. он знает что такое "p". и он встваляет в ассемблер
команду вмето имени "p" уже число адрес где хранися эта переенная. итак p это имя перменной.
значок * означает что это не просто перменная а это поинтер. то что стоит левее от * оно
обознаачает какой тип у той перенной на которую укызвает поинтер. еще раз значок * позволет
на стадии создания перенной отлчить поинтер от обычной перменной. тоесть


  short int p;  \\ означает что это перенная обычная и имеет тип short int
  short int *p; \\ означает что это поинтер который хранит всебе адрес на переменную
                \\ которая имеет тип short int

вот поэтмоу нужен значок *
еще подчеркну то что в памят процеса поинтер хранися толко его тело. тоесть если у нас 
поинтер равен 1234 то в памти будет хранисят только 1234. а инфомрации о том что этот поинтер
указывает на перенную типа short int небудет! это чисто инфомрация для компилятора чтобы
он когда будет гоотвить ассебмлер чтобы он спас програмиста от делания какйото хуйни.
а если еще раз гворю мы запусти процесс. найем этотпоинтер. то мы увидим только адре 1234
но мы не будем понимать какоо размера перменная на какую он указыает. такой ифомрации в памяти
нигде не сохраренро. эта ифомраия только есть в опосреденнованном виде в коде ассебмлерном
программы.

так вот я врвзращаюсь к массивами поинтеру


  short int *p = vasya;

кода такой текст встертит копилятор то он создаст код который создает в памяти компа 
поинтер. и он создава асемблер код просто напросто всунет в форме готово числа адрес
первого элемента массива! то есть он просто подставит в ассеблер код адре масива. 
тоесть такого не будет что  унас гдето в пмяти процесса есть ячейка которая хранит адрес
начала масива . и оттуда это считвыается.  и запывается в поинтер в памяти. нет.
у нас будет создан поинтер. и комплиятор просто вствит в форме готово числа адрес начала 
массива. тоесть унас слева стоит переменная p и она релаьно будет созана в программе.
спава стоит перенменная vasya которая соедрижит адрес наачала масива но это перменная чисто
внутри комплиятора . в проегрммме такой перменной небудет!
код будет примерно такой.

  mov [7689], 1234

тоест унас поинтер будет лежать в памяти по адресу 7689 и в него просто комплиятор подставил
число 1234. и не будет  ниакой другой  ячейки в памяти где лежало бы 1234 отдельно. 

тоесть еще раз вот в чем прикол си. у нас в тексте прогарммы указвыаются переменные.
и какието из них в итоге релаьно создаются в программе. а какието ппернменные это чисто 
перменые компилятора а в программе их не будет создано.
вот мы обьявили массив

 short int vasya[10];

и комлияттор создаст асебмлер команды которые запишут в паять ТЕЛО массива. но не будет
ячейки где было бы заиписан адрес начала массива. эта инфомрация будет толко в голове компилятора.
поэтому когда мы в тексте прогарммы пишем просто vasya котоое прозумевает что мы хотим узнать
адрес начала масива то это намек комплиятору на его внутннерюю переенную vasya которая хранит
начало адреса массива в памяти будущей прогарммы

  short int *p = vasya;

поэтому слева указана перменная которая будет жить внури программы. а справа указана внутненяя
перменная компилятора. вот такой прикол. не все перменные в си тексте будут созданы в коненой
программе. 

итак созадем массив через 

 short int vasya[10];

досутп к эелменту массива выгляидит как
 
  vasya[1]

и адрес первого элемент массива выглдяит как

  vasya


кодга  втексте мы юзаем vasya[1] то это намек компииятору что бы он взял свою внутрнеюю 
перменную vasya котоаря соеджрит адрес начала массива. прибавил к ней необходимое смещение
в байтах и это число захардокодил в асебебрлер команде которая обратится поэтому адресу
и прочитает нам из памяти в цпу значение элемента массива с индксом 1.
наример 

 short int vasya[2] = ...;
 b = vasya[1]

 пуст у нас масив начинает хранисят с адреса 1234 . так как размер эедмета 2 байта.
 то перый эедмент который имеет индекс 0 то он хранисят по адресам

 1234
 1235

 а вторйо элемент котоы имеет инекс  1 хранистя по дерсу

 1236
 1237

 тогда код вторйо строчки будет 

  mov bx, [1234+2]

тоесть комплиятор вставить адрес начала масива и сдвиг на два байта на начало храения второго
элеента

значит что важно поняь про массив это то что в прогармме в памяти в ячейках будет хранится
только тело массива. метданные в пмяти хранистя не будут. метедатнные хрантся в захардкоженном
виде в тексте ассеблерной программы. когда компитляторв встрчает в тексте на си упомианние
о масиве то он просто трансфорвмирует занчение своей внутррней перенной vasya котоаря обозначает
начало адреса массива  в нужные числа для подстановки в ассемблерные команды. 
если мы пишем в текст на си просто vasya то компилятор понимает что мы его просим вставит 
адрес начала массива в памяти и он вставляет это число в код асеблреной комнды. если
мы в тексте на си пишеи vasya[0] то компиятор понимает чтомы хотим отнего чтобы он содал команду
на асбелеере котоаря вытащит из тела массива первый эелмент. сам комлиятор знает и где 
начало тела масива в памяти прогарммы и стркутурур массива исходяиз этого комплиятор вычсляет
нужные числа адреса и на освное них формирует асемблернуюкомнду. поэтому инфо о ксткрутуруре
массива есть только в голове компилятоора. в памяти программы ифнморации о стрктуруте массива
нет. есть толкьо тело маассива. опосредованно инфо о структуре массива есть в коде на ассеблере
прогармы. а я раньше думал что ифорамаиця о о структуремассива комплиятром где тов памяти
прогармы сохраняется и туда потом код прогармы лазиит. а полкчатс что бОльшая част того что 
мы в тексте на си пишем это все только внутрнееннняя инфорация для компилятора. и что эта 
инфо так не выходит из комлилятора в тело прогаммы на ассемблере!

итак когда копиллиятор выидит текст

 int vasya [10];

он понимает что ему надо создать ассебплер текст который займет 40 байт в памяти прогарммы.
и он такой текст на асебелере создаст. при этом копилятор в своей памяти запомнит во внутрней
переенной vasya что начало массива в памяти программы лежит скажеи по адресу 1234. потому чт
именно комплиятор выбиарет по какому адрксу будет создано тело массива в памяти прогарммы.

если комплиятор види текст

 vasya[2] = ....

то понимает что его просят создаст ассмблер код который сует в тело массива некоторое 
значение. тода он вытасивает из своей памяти начало массива 1234 вычисляет на освное сткрутуры
массива начало адреса третьего элемента в нашем случае это будет 1234+4*3= 1246
и уже генериурет ассеблер код который сует по адресу 1246 значение

 mov [1234+4*3], значение


если компитор видит в тексте слово vasya

  .... = vasya

напрмиер 

 int *p = vasya;

то что касается васи он понимает что здес его просят подсунуть адрес начала массива. он лезет
в свою память вытасиувает число 1234 и сует его в ассеблер код.

тепер про массивы составленные из элементов разных типов

int vasya[10] \\ массив из 10-ти жлементрв каждый имеет тип int тоесть 4 байта
char vasya[10] \\ массив из 10-ти жлементрв каждый имеет тип char тоесть 1 байт

long int vasya[10] \\ массив из 10-ти жлементрв каждый имеет тип long int тоесть 8 байт

итак то что справа число в скобках это число элементов.
посредине имя внутрнейней переенной компилятора для данного массива.
слва от имени массива тип каждогоэлмента массива.
ксати про длину массива. этой инфо в памяти прогаммы нет. это знает только компитор.
а в тексте асселера об этмо есть только опосредвеная информация. а в памяти прогаммы об этом
нет ниакой инфо. поэтмоу елси мы знаем что по адресу 1234 анчианется массив то какая у него
длинна хрен знает. не понять.
с масивами разобралсись.


важно понять что комплиятор так создает прогармму на ассеблеере что в итоге в памяти програмы
будет храится только тело пременной какой бы у нее тип ни был. и не будет хранится в памяти
программы адрес где искать эту перееменную. адрес хранится только в памяти комплиятора пока
он компилиурет и захардкожен в коде ассеблерной программы.


теперо про поинтеры.

как я уже сказал поинтер в своем теле хранит адрес. поэтмоу длина поинтера 4 байта
для 32 битного цпу и 64 битного цпу. 
адрес указывает на перенную котоаря ранее уже была создана на компе. 
поинтер ествесвтенно создается в памяти програмы. если адрес массива котоырй тоже поинтер
не создается в памяти программы а тлько есть в памяти комплиятора. то поинтер создается
в памяти прогармы. и при его создании указывается не его тип иотмоу что его тип нам понятен
а укзывается тип той перменной адер которой он хранит

создаим поинтер

	int *p ;

опять же имя p это чисто внутнний идентийикатор для комплитора этой перееной когда он будет комплировать текст.  int означает что адрес коорый хранистя в p указывает на переенную
длинйо 4 байта. тоесть елси в p лежит 1234 то значит данные лежат в адресах 1234 1235 1236 1237
тип поинтера в памяти прогаммы нигде не фисируется. это чисто инфо для комплиятора. он знает
на стадии комплияцци на какой тип данных указывает поинтер. а в живой программе у нас будет
тлоько адрес 1234 а какйо длинны данные за этим адресом хрен знает.
так вот коплиятор следит чтобы мы привяызали поинтеры к перменным у которых такой же тип
как мы указали в поинтере
напрмиер 

  int a = 10;
  int *p;
  p = &a;

 в первой сторке мы создали int переменную.
 во вторйо строке мы создали поинтер которому разрешено указываьи на пермтеную типа int;
в третьей строке мы занесли в p тот адрес по котроу лежит  в памяти переменаня a.
и это можно сделат потому что перменая а имеет тип INT и у поинтера завялено что ему разрещено
укзываьт на перенную с сэтим типом. 
есть еще поинтер типа void

 void *p;

ему если я проавльнопомню разреешено указывать на переменную любго типа. 

про вот эту строчку

  p = &a;

кода ее увидит компиятор он вот что сдлеает. он посмтрим в своей памяти где хранится p
и где хранися a. и он созаст ассемблер код в котором чилами запишет оба адреса. 
примернно вот так

 mov [6789], 1234

где 1234 это адрес в пмяти процесса где по информации оплиятора лежит пемрееная а
а 6789 это где по информаии комплиятора лежит переменная p.
тоесть в коде асеблера все эти адреса будут тупо захардкодены.

по поводу создания поинтера

int *p;

звезда позволяет указать комплиятору что мы хотим создать не просто перменую типа int
а мы хотим сздать поинтер котрому будет разрешено укзывать на перменную типа int
вот зачем нужна звезда. но звезда имеет совшерешнно дргое значение когда мы уже польщуемся
поинтером. если мы испольщуем имя p без звезды то это значит что мы имеем ввиду знание
этой переенной. например 
 

  int a= 10;
  int *p1= &a;
  int *p2;
  p2=p1;  // в  этой строке мы копируем адрес из p1 в p2


если же мы хотим плолучить из переенной p не адрес а знчение которое лежит по тому
адреу то юзаеи звезду

 int b;
 b = *p1;

звезда p1  это диркетива комплиятору (ровно также как ест директивы у баша) чтомы в этом
месте просим его чтобы он прочитал значение переменной которая хранисят по аресу указаному
в поинере. и тут пригождается тот тип поиеера который мы задавали при его обявлении. потому что 
в поинтере лежит адерс. но адрес это 1 байт. и непонятно сколко байт нужно в итоге прорчитаь
1 или 2 и ли 4 или 8 . а кодгамы занем тип поинтер то знаем сколько байто нужно считаь. 
и какую для этого команду асбелера нужно юзать. пример

int a= 0x10;
int *p = &a;
int b = *p;

в первой строке мы создаем int переменную.
во второй строке мы созадем оинтер и говрим что ему можно укзывать на перменную типа int
и также сразу мы запмываем в поинтер адрес переменой a. комплитор проверит совпдает ли тип 
поинтера и тип перменной а. да совдпает . значит можно так делать.
вторая строка на асбемлере мы просим кмопиялтятор вытащить знаение перменной адрес которой
лежит в p. ткомплиятор смотрит какой тип у пинера. ага тип int. значит нужно считать по указаному
адресу 4 байта. а потом нужно эти 4 байта засунуть в  переенную b котоаря тожа имеет тип int.
тогда он вот что делает

  mov eax, 6767         \\суем в eax адрес переменной a
  mov [eax], 0x00000010  \\пищем в пеерменую a  четыре байта
  mov eax, 6789     \\ суем в eax адрес самого поинтера
  mov [eax], 6767 \\ суем  поинтер адрес переенной a
  mov ebx,[eax]  \\читаем 4 байта по адресу из поинтера в ebx
  mov eax, 2424  \\ пишем в eax адрес переменной b
  mov [eax], ebx  \\ пишем в перменную b то что было в переменой на коорую укзвал p

как видно из текста копмилятор так как знает все адреса где что хранися. и он знает
все типы данных то он это все захардокидвает в ассеблер командах. 
тоесть все адреса и все типы тупо захардкодиваются в параметрах ассемблер команд.


поэтому вот ответ на вопрос

int b = *p;

откуда копляитор знает сколк байт нужно считать на запрос *p 
ответ - оттуа что мы задали при обялвении поиинтера на какой тип данных ему можно укзывать.
и комплиятор это проитал и он это запомнил и знает


теперь рассотрим такой момент как связку массивов и поинтеров. 
для начала еще раз пример когда поинтер укзывать на просто перенную

	int a = 10
	int *p = &a;


мы создали поинтер которому можно указывать на переременную типа int.
и мы занесли в поитер адрес по котрому хранися преременная a которя имеет тип int.
если у нас в p лежит адрес 1234 и мы знаем что по адреусу этому хрнаится int значит
мы знаем что нетолько адрес 1234 содержит инфомрацию а 4 байта содержат иформацию 
а именно 1234 1235 1236

окей. 
теперь поинтер и массив


 char vasya[2];
 char *p = vasya;


в первой строке мы создаем маассив. у него два элемента. кажый из них имеет тип char.
это 1 байт. если массив начианется с адреса 1234 то в итоге его тело лежит в 1234 и 1235
первый эелмент лежит в 1234 второй в 1235

во второй строке мы создаем поинтер котоому можно в себе содержать адрес коорый укаызвает 
на переменную типа char. тоесть если у нас в поинтрете лежит адрес 7890 то мы знаем что полная 
длинна данных на которую укзывает поинтер всего 1 байт тоесть 7890. тоесть еси нас попросят
прочитать всю перееменную которая хранистя по адреу на который укаывзает поинтер 
то мы знаем и комплияоор знает что нужно считать всего 1 байт.

рассмотрим внимательно тепер втору стркоку. в правой части стоит внутрнеяя перменная комлиилятора
и она оназнчает что в этом месте комплиятрор должен попокопавись в своей памяти найти свою
внутренюю пременную vasya и вставить ее занчение в этом место. а какой же смысл перееннйо 
vasya - а это адрес первого байта где начнианется массив в памяти программы.
значит у нас как бы втроая строка выгядит вот так

 char *p = 1234;

тоесть у нас соадатся поинтер. ему разршенено в себе хранить адрес переменной котоаря имеет
тип char. у нас справа стоит число 1234. тоеть в пеереную p мы пытаемся записать число 1234.
адрес ли это ? да это адрес. теперь главный вопрос - находится ли по адремсу 1234 переменная
которая имеет тип char? И ТУТ ПРОШУВНМИАНИЯ!!!!!! -  по адресу 1234 у нас лежит не переменная
char а лежит массив из элементов char. так вот как я понял видим с точки зрения комплиятора
массив это как не единая структура а группа отделных переенных кторые просто вместе собрали 
в кучку. поэтому раз у нас начиная с адреса 1234 лежит массив типа char значит там лежит набор
отделных переменых типа char. теперь вопрос по адресу 1234 лежит ли адрес отдельного элемента
char? ответ - да. потому что у нас один элемент char лежит по адресу 1234 
а второй элемент лежит по адресу 1235. поэтому у нас масив это как бы две одльеных перенных
типа char  с тчоки зрения комплиятора просто они лежат в памяти вплотную друг к другу. 
ну и что . это не страшно считает комплиятор. поэтому раз у нас массив это группу отдельных
переменых типа char и раз по адресу 1234 лежит одна из этих премеыных то значит с этой точки
зрения адрес 1234 указывает на переменую типа char и значит что сохранить адрес 1234
в поинтер типа char яввлется с точки зрения комплиятора валидной операцией! вот такой
пиздец. поэтму с этой же точки зрения валины и вот такие оперкации

  char *p1 = &vasya[0];
  char *p2 = &vasya[1];



вот аналогинчный код 320.c (внизу кусок)


   //
   char neptun[2] = { 0x10, 0x12 };
   char *p_p1 = neptun;
   char *p_p2 = &neptun[0];
   char *p_p3 = &neptun[1];
   printf ("p_p1 = %p, p_p2 = %p, p_p3 = %p\n", p_p1, p_p2, p_p3);
   printf ("*p_p1 = %hX, *p_p2 = %hX *p_p3 = %hX \n", *p_p1, *p_p2, *p_p3);
   


на экранее
p_p1 = 0x7ffc425ab943, p_p2 = 0x7ffc425ab943, p_p3 = 0x7ffc425ab944
*p_p1 = 10, *p_p2 = 10 *p_p3 = 12 

тоесть p_p1 и p_p2 имеют одинаквые значения
а p_p3 имеет занчение на +1 больше. 
и во втором принтф мы вытащили то что хранися в перереенных на которые 
укзывает поинтеры. наши исходные 0х10 и 0х12

из этого куска я хочу сказать важные выводы.
один вывод по поводу переменной которой обозанчаетмассив.
если мы юзаем просто vasya то для комплиятора это сигнал что нужно в этом месте вставить
АДРЕС начал масива.
если мы юзаем vasya[0] то это сигнал для комплиятора что вэтом месте нужно вставить
значение первого элеента массива. тоесть это уже не адрес. совсем не адрес.
если мы юзаем vasya[1] то это сигнал для комплиятора что вэтом месте нужно вставить
значение второго  элеента массива

 char vasya[2];
 char *p = vasya;
 char *p1 = &vasya[0];
 char *p2 = &vasya[1];


поэтому когда я сую знаения по поинтеры то во второй строке я просто пишу vasya ибо это 
уже адрес. а в тетей и четветртой строке я использую директиву & которая образначает кмплтору
что нужно взят указанную перменную и найти ее адрес и вставит адрес. 

втрой вывод такой.
что с точки зрения комлиятора массив такого типа это с одной стороны вроде как единая
макромстурктура. а с другой стороны это куча независимых переерменных одного типа собранная
в одном месте. поэому если у меня есть адрес одного из элементов этого массива тот этот элмент
является полноценной незавиисимой перерменной этого типа. тоесть с токчки зрения компдяитора
вот эти две переменных они абсолютно равценоенные

 char  a;
 vasya[1]; // из массива  char vasya[2] 

и то и то с точеи зрени компиятора это незавиисмая переменная типа char.
несморяр на то что вторая хрень входит в состав массива. с точк зрения компиятора 
типа ну и что? все равно размер этих пременных совпадает. именно ппоэтому можно делать 
вот такое приаврравнивание

 char *p2 = &vasya[1];


и получатся что у нас слеав заявлен поинтер которму можно укзывать на перменную с типом char
а справа у нас адрес второго элемента массива где каждый элмент имеет тип char.
если рассатриват каждвый элемент как независиммую пременную (а почему бы и нет) то 
тодгда этот жлемен ялвяется переменой типа char. и поэтому ее адрес можно соавть внутри
поинтера p2.
вот такой прикол.
отсюда приходит ОЧЕНЬ ВАЖНЫЙ И ШОКРИУЮЩИЙ ВЫВОД - о том что если у нас есть поинтер и у него
задан тип. то этот тип нам предпиысывает соклько байт нужно считать по указаному адресу 
чтобы получить значение переменной. например char *p2 нам предпиывает что если мы связались
с этим поинтером то нужно по указаному адресу считывать строго 1 байт. не более. 
например пусть у нас p2=1234, тогда мы обязаны при пользовании поинтером p2 считывать начиная
с адреса 1234 тлько 1 байт небольше. тоесть нам нельзя читать байты 1235 1236 итак далее.
нахождение там каких либо данных негарантировано. рантше я думал что нахожддение данных
там дальше нетлоько не гаранторвано а более того их там строго нет. как я жестоко ошибался.
так вот тип указанный у поинтера совершенно не запрещает чтобы по адресам котоыре находяятся
дальше  тоесть 1235 1236 небыло данных. они там могут быть . их там может не быть. мы этого
незнаем. но возможность нахождоения там данных незапрещена как я думал ранее. все о чем
гворит нам тип поинера это тлько о том что тип поинтера нам гарантирует что по указанному
адресу АБСОЛЮТНО ТОЧНО есть столько то байт данных. и их можно и нужно считать.  а есть
ли там данные дальше или нет. неизвестно. может и есть это не запрещено. 
что собствтенно и видно когда мы присваиваем поинтеру адрес внутри массива из однородных 
элементов. поинтер нам точно гарантиурет что по указному адресу точно есть 1 байт. а есть
ли таам дальше байты может есть а может нет. это не наше собачье дело.
раншея думал что там дальше конечнонет больше байтов данных . я жесктоко ошибался. 
если поинтер укызвает на какйото тип по какому то адресу. то он указывает минимальное число
байт с данным которое там есть. но там запросто может лежать и гораздо боольшее число байтов
даннных. 
посольку поинтер предписвыает читать и писать строго то число байтов по указному адресу 
котрое указано в его типе то получается что совешенно неважно как мы будем раотать с элементом
в массиве - либо чрез поинтер проавильного типа либо через интфрейс работы с массивом. 
тоесть мы не повредим сосдение элеенты масива. и мы элемент массива прочитаем и запишем целоиком
а не частично. пример

  char vasya[2] = { 0x11, 0x12};
  char *p2 = &vasya[1];
  *p2 = {0x13};


во второй строчке мы записали в поинтер адрес второго элемента массива. это корктная операция
потому чтопоинтер иммет тип char и элемент массива имеет тип char.
в третеьй строке мы чрез пинтер меняем значение второго элемета массива. так как у нас 
поинтер имеет тип char то комплиятор сгенериует код котрырй по указаному адрсу пошлет именно
1 байт. поэтмоу мы незаданем другие элемент массива и мы модифицируем второй элемент массива
целокмо а не частично. все пройдет коректно.

   //
   int ii_1[3] = { 0xAABBCCDD, 0xEEEEEEE, 0XFFFFFFFF};
   int *p_ii = &ii_1[1];
   *p_ii = 0xBBBBAAAA;
   printf ("ii_1[1] = %X \n", ii_1[1] );
   printf ("ii_1[0] = %X, ii_1[1] = %X, ii_1[2] = %X,\n", ii_1[0], ii_1[1], ii_1[2] );
   

вот такой код. у нас масив из трех элементов. каждоый имет тип int это 4 байта.
далее я создаю поинтер тип INT. и заношу в него адрес второго элемента из массива.
так как массив имеет тип INT то каждый элмент имеет тип INT. и каэдйэлемент сточи зрения
клмплятора это полноценный нзависисй элемент такоо же типа INT. поэтому колпиятор разершает
занести в поинтер адрес вторго элемента. таким образом когдмы мы получаем такой поинтер
с типом INT то комплиятор гарантирует со стороны данного поинтера что по краней мере 
4 байта данных у нас точно есть если начать читать по адресу храняемуся по этому поинтеру.
и это правда. потому что по ээтому даресу как раз хрнится 4 байта второго элемента массива.
в третьей строке я прошу комплиятор записать по адресу хранящнему в поинтере 4 байта указаных
данных. так как поинтер имеет тип INT то он гарантирует что если мы прчитаем 4 байта
по указаному адресу то там точно лежит 4 байта данных а не мусора. также этот поитер нам 
дает права записать по ээтому адресу 4 байта данных. мы это делаем.
в следущей сторке я проверяю содеживомеое второго элемента масива но уже через инерфейс
самого массива. выражение  ii_1[1] говорит комлиятору чтобы он нашел в своей внутрней памяти
внутренюю переменную комплиятора с именем ii_1 котоаря выражает адрес начала массива в памяти
прогармым и сформирвал такой код на асбелере который вытащит из массива значение второго элемента.
и далее эти 4 байта скрмлваиваются на входу функции принтф. которой через модификатор %X указано
что в аргументе должно быть 4 байта и что приртф должен эти 4 байта на экране нариосвать в 
hex формет. итак что мы видим на экране

ii_1[1] = BBBBAAAA

в следущей строке я хочу убедится что остальные элементы массива не пострадали

ii_1[0] = AABBCCDD, ii_1[1] = BBBBAAAA, ii_1[2] = FFFFFFFF,

и да - они не пострадали.


таким образом суперважная инфо о том что - мы можем совать внутрт поинтера нетолько адрес
какойто простецкой перменной но и адрес элемента массива. при условии что тип поинтера
и тип массива совдадает. потмоу что с точки зрения комплиятора массив из элеметов это не единая
монолитная струутрура а просто кучка независиимых перееных котрые собраны в одну кучу в памяти
и не более того. поэтмо какая разница или это отдельная пермтенная или это перменная находящася
вместе с друими просто рядышком в памяти ну и что. 
поэтому если мы видим поинтер и у него есть какоето значение. тоесть адрес. и у поинтера есть
тип. то ненужнодумать что по указаному адресу есть полезные байты данных толко в размере
типа поинтера. например елси поинтер имеет тип CHAR и в него записан адрес 1234 то неужно
думать что только по адреу 1234 сидят немусорные байты. это необдяатлеьно так. может быть 
немусор сидит тлоько по адресу 1234 но совершено реально также и подругим адресам которые смежные
тоесть 1233 или 1235 могут сидеть не мусорные байты. но! если мы лезем в перерменую через поинтер
то нужно читать и писать только то числ байтов которое предписано в типе поинтера. ненадо 
саммтоятельно лазить ни влеово ни вправо. это ненаше собаьче дело что там харнися в байтах
слева и справа от положенных там в поинтере. мы лезем в какието чужие смежные данные и этого
делать ненадо. кмплиятор нам на стадии  занеесения адреса в поинтер делает проверку и гарантурет
что по указному адресу точно есть ровно столько байтов не мусора как указанов поинтере. 
это он проверяет иначе он недаст скопилирварь программу. а лазить через поинтер в другие смежные
байты ненужно. но так конечно на прмиере массива слева и справа от данных предписанных типом
нашего поинтера могут сидеть немусорные байты с какимито данными.
а я раьше по свой глупостидумал что есл у нас есть поинтер

char *p ; и у него адрес 1234 то это якбоы всегда значит что по адресу 1234 есть немусор
а по адресу 1235 или 1233 оязательно уже мусор пустотам. как жестокого я ошибался. там может
небыть данных . данные там могут быть. но это уже не наше собачье дело туда соваться через 
этот поинтер.

ксатти вот у нас есть такие типы как структы. и там есть поля. так вот наш поинтер 
он может указывать внутрь структа на его отдельное поле. 
если тип поля совдает с типом поинтера то опять же мы сможем сунуть адрес поля внутрь
поинтера. и если потом читать изпоинтера то у нас получается и слева и справа от байтов
относящихся к поинтеру будут байты с данными а не мусор. друое дело что это не наше
собачье дело в эти байты соваться. 



теперь рассмотрим вот такой интересный случай.
когда мы суем адрес в поинтер то он проверяет свпдает ли тип переменной  с типом поинтера.
это делается для того чтобы гаратироват что то число байтов котоое укзано в поинере оно 
точно содрежало данные по указаному адресу.
например 

  char a = 0x10; \\ обявляю ременую длиной 1 байт
  int *p;  \\ создаю пока пустой поинтер на переенную длиной 4 байта
  p = &a \\ здесь колиятор пшлет нахуй. потому что поинтер требует чтобы было 4 байта данных 
         \\ по адрему переенной а у нас по адресу тлоко 1 байт  а дальше мусор


но можно заставить комплиятор игнорировать проверку при занеении адреса в поинтер.
это называется сделать cast или по кастинг. это имеет в теории смысла ткое делать едси 
например у нас перменная имеет большую длнну. а мы хотим залезть  в ее кусочек.
напрмиер 

  int a = 0x1111110A;
  char *p = (char *)&a;

значит что значит вот эта загадочная констуркция (char *)&a то что в скобках
это и есть кастинг, CAST , typecast , как его тольк не называют.
она гвооит комплиятору - узнай адрес премнной а и засунь его в поинтер p и при этом 
считай что якобы перемнная a имеет тип char тоесть игнорируй если пременая a имеет другой
тип. типа я програмист  я лучше знаю. тоесть этой командй програмист заверяет комплиятор что
по адресу где начинается пермнная a у нее есть немусорные байты  в размере какой указан в
типпе поинтера в данном случае char. тоесть мы утверждаем комплиятору что в первом адресе
по адресу где начаинется пермнная a там точно есть немусор. ну или говоря по протостому мы
говрим комлиятору - слуай просто встваит в поинтер адрес начала перенной а и ни о чем не 
заботться. 
теперь если мы будем читать данные из поинтера пэ. то будет прочитан 1 байт. 
на экране мы длжны получит 0x0A
проверяем

   //
   int a43 = 0x1111110A;
   char *p43 = (char *)&a43;
   printf ("*p32 = %hhX \n", *p43 );

на экране
*p32 = A

тоесть все подтвердилось. 
почему у нас 0A в конце а мы его прочитали. потому что напомню что  в памяти числа котоые
мы на бумаге пишем они сохранены в обратно порядке байтов. поэтоум в пмяти наше число
имеет вид
  0A  11 11 11

и адрес где наинается преенная он лежит слева поэтмо мы счиали первйый байт а нем лежит 0A
эта хрень назвыется casting
справшивеается а зачем он нужен в реаной жизни. .. ну потом  с ним столкнемся
в реальной жизни. а пока просто запомним как прикол.



теперь поговорим про char массивы. 
тоесть char массив

  char vasya[10];

это массив из элементов каждый из которых имеет тип char.
тоест это куча независимых char перееных котторые обьедиенны в одну кучу.

как можно в такой массив насовать данные .
например вот так

    char vasya[] = { 0x10, 0x11, 0x13, 0x14};

замечу что в скобках можно размер неукзывать его автоматом вычислить и подссвит комплиятор.

причем естсвтенно что каждый эелмент это байт и этот байт может быть любым. тоест 
в диапазоне 0x00 - 0xFF

нарпрмиер нет нкиаких прблем вот такие напихатьданные

    char vasya[] = { 0xFF, 0xFF, 0xFF, 0xFF };


тепрь следущий способ напихать данные в char массви это вот так


    char vasya[] = { '1', '2', '3', '4' };


обратим вмнаиание на одинарнвые кавычки . это директива для комплиятора чтобы
он взял символ внутри кавычек и прервтил его в байт согласно ascci таблицы и суунул 
этот байт в элемент массива

соттсвтвтсеннно это выбор челоека как ему увобнее пихать даные в char массив через 
hex вид или через печатные сиволы. замеучу лишь то что если совать адныне в массив
через печатные символы то они охватвают далеко не весь спектра байтов. тоесть 
ascii коды они охватыватют диапазон 0x00 - 0x7F и то невесь смпектр.  а еси 
мы пихаем данные через hex формат то нет нкиаких проблем мы можем пихать все байты
от 0x00 по 0xFF
тоесть элемент в char массиве он необзяазан конекртирваться в символ из ascii таблицы.
элемент в char массвие это может быть любой любой любой абсолюьтно любой байт.

так вот есть еще онадиректива котора позоляет заливать данные в char массив.


  char vasya[] = "123456789"

то что стоит в двойных кавяках это директив для комлпитора чтобы он взял то что стоит 
внутри кавыячек и конвертиролва согласно ascii таблицы в байты. И ЕЩЕ ОЧЕН ВАЖНО что также он 
дожен в конце прибавтиь еще один байт это ноль байт 0x00
поэтому то что выше аналогичновот такому

  char vasya[] = {'1',  '2',   '3',  '4',   '5',   '6', '7',  '8'  '9'  0x00};

или что тоже самое

  char vasya[] = {0x31,  0x32,   0x33,  0x34,   0x35,   0x36, 0x37,  0x38,  0x39,  0x00};

акцентриую внимание на ноль байт 0x00 который обязатеьнобудет доавлен поледним элементом
в char массив


тоесть если мы хотим наосвать супер быстро байтов в char массив и эти байты отлчно конертирются
в символы asccii и мы не против того что последний элемент будет 0x00 то метод через 
двойные кавычки он супербыстрый.
например 

  char vasya[] = "ehal greka cherez reku vidit greka v reke rak"

так вот эта директива дя комплитяора двоные кавыки называется string.

теперь посмотрим куда этот стринг удобно примеить.
рассморим вот такой код


  char vasya[] = "123456789";
  char *p = vasya;


значит что мы имеем. у нас справа стоит vasya это указывает комплиятору что мы хотим чтобы
в этом месте компилятор нашел у себя среди своих локальных перменых vasya в кооторой компилятор
хранит адрес начала тела массива и этот адрес вставил в поинтер. коректная ли этаоперация.
у нас массив имеет тип char. значит это группа независимых преенных кждая из которых имеет тип
char. значит директива vasya имеет адрес начла маасссива тоесть технически это адрес первого
элемента этого массива. а этот элемент каки идгругие имеет тип char. поэтому у нас слева указан 
для поинтера тип char тоесть в этот поинтер можно запивыать адрес котоырй укызвает на перенну 
типа char. и спрва у нас адрес который укаызвает на элемент котоырй тип char который экивалнтенет
незавиисимой перременнйо тип char. поэтмоу это будет коретная операция. 
по факту если мы ситаем 1 байт по адреус из p как это предпмывет тип этого поинтера
то мы получим байт который кодирует символ 1. проверим



  char vasya44[] = "123456789";
  char *p44 = vasya44;
  printf("%c \n", *p44);


на экране
1


прокоментирую 
штука *p44 предпсвыает комплиятору что он составл асемблер код который проичтает из 
памяи по адресу p44 то число байтов который тип имеет поинтер p44. тип у него char значит 1 байт.
и этот 1 байт будет передан в фнкцию printf. ее модификатор %c говорит о том что ей должно 
было быть предано в аргументе 1 байт. и что нужно это байт восприрять как ascii код 
и нарисовать этот символ на экране. важно замтить что модификатор %c ожидает именно байт
который отвечает ascii кодрирвке а не поинтер. поэтому так важно справа поставить *p44 а не p44

так вот тепрь  я вставлю еще одну окманду вот таккую 

  printf("%s \n", p44);


коментирую эту коанду. в фнкцию принтф на этот раз мы прередаем именно адрес хранящийся в
поинтере. а модификтор %s он предпиывсет фкцнии принтф чтобы она начала читать по адресу
указаному в поинтере байт за байтом. и читать до тех пор пока не встреиттся байт вида 0x00
и тогда больше читать нельзя.
тоесть если в p44=1234
то принт условно проитает то что лежит по адресу 1234
увидит что это байт 0x31. он равен 0x00 нет. тогда она прибавляет адрес и читает то что 
лежит по адресу 1235 получит байт 0x32 он равен 0х00 нет. 
и таким макаром эта фнкция прочитает вот эти байты по таким адресам

1234   1235   1235    1236    1237    1238     1239   1240     1241      1242
0x31,  0x32,   0x33,  0x34,   0x35,   0x36,    0x37,  0x38,    0x39,     0x00


и вот прочитав адрес 1242 она получит байт 0х00 и она прекратит дальнейшее чтение
и правильно потмоу что в нашем массиве боьше никаких элементво и не содержится.

а далее модификатор %s он предпвыает принтф чтобы он все эт байты всопринял как ascii
коды и нрисовал их на экране в форме сиволов. кроме естствтенно байта 0x00 который не
имеет печатной формы предсталвения на экране


проверяю.
на экране

123456789

тоесть еще раз напомню код полный

  char vasya44[] = "123456789";
  char *p44 = vasya44;
  printf("%s \n", p44);

на экране
123456789


таким образом вот в чем прикол стрингов. они позволяют быстро и легко заснуть 
из текст втого файла на си печатные символы. а потом  эти же печатные смиволы напечатать 
легко и быстро на экране  испоьзуя printf и его модификатор %s.


что тут хочется сказать. то что в коде нашей фнкции main() наш поинтер имеет тип char
и он указвает на первый элемент массива из char элементов. сам наш поинтер он без понятия
на то что он укзывает на элемент внутри массива. сточки зрения поинтера он просто укзывает
на перееную размером 1 байт. а есть ли полезные данные слева от этого байта или справа он 
понятие не имеет. далее мы этот поинтер передаем как аругмент внутрь фнции printf()
на уровне ассеблерного кода когда функция получает себе через аргумент поинтер то в нем нет
ниакой инфорации о том какого он типа. тоесть сколько байтов немусорных есть справа от адреса
который в нем указан. тоесть понятно что ест по крайнйк мерер 1 байт немусора по адрсу 
который указан в поинтере. но сколкьо там еще есть поеных байтов справа (про лево вооще речи неидет) незисетно. так как только комплиятор это знаал.  но если програмист при взыаве
принтф указал %s то програмсит уверчет принфт () о том что правее первого байта от адреса указанного в поинтерер тоже есть поелезные немусорные байты. и модиификатор %s препсиывает 
фнкции принфт() начать пртбавлять этот адрес и читать ссоедний байт. и делатьтак вполоть
домомента когда принфт не встерить байт 0x00 его наличие гарнатруртся со стороныпрограмиста
котоырй запустил printf() если прогармситнапиздел то рано или поздно принтфт выйдет на тайкой
адрес который небыл иницлизирован в ядре для проесса и ядро убьет процесс с ошибкой segfault.
а вот как это можно сделать для примера в коде нашей программы ровно на примере одного
шага. тоесть мы считаем на 1 байт правее чем адрес указанный в поинтере

вставляю эту команду

  printf("%c \n", *(p44+1) );

получаю на экране
2

ну а если я вставлю вот такое
  printf("%c \n", *(p44+100) );

то получис segfault

едисвнтенное что я не понимаю это как работает сама принфт неужели она считывает по 1 байту
и проверяет получила она 0х00 или нет .это же скажем если у нас char массив имеет длинну 100 байт
то это же 100 итераций надо сделать.

что еще интересно - комлиято очень сильно проверяет на стадии когда мы присываем
поинеру какйото адрес. а вот получается он нихерна не провяеряет когдя  я делаю вот так

  int i12 = *(p44+3);


тоесть у меня компиляция прошла без ошибок. а кто сказал что по укзааному адресу есть 
4 немусорных байта? это же не факт. забавно.

тем не мнеее в итоге я расмотрел массивы , поинтеры и частный случчай масссива char
потому что этот тип массивов типа слегка особенный.

замечу что нет никаких прблем присваивать поинтерам элеметы из массиав нетлоько для масивов
char а и других масиввов наример

int vasya[10] = ....;
int *p = &vasya[5];

у нас поинтер буде укзывать на адрес шестого элемента в массиве. 
и данный поинтер нам предпмывает читать и писать ни бьлольше и ни меньше чем 4 байта.
тоесть работа  с эдементом массива чрез поинтер будет ровно такая же самая как елисли бы
я рабтал с этим жлементм чрез интерефейс самого масиава то есть 

  *p = 0x10AABBCC;
и
  vasya[5] = 0x10AABBCC;

будет давать одинаоковый резултат






поговорим про еще один прикол. вот такая штука тоже возможна

  char *t1 = "12345";

тоесть только я привык что вот такое валидно

  char vasya[] = "123456";
  char *p = vasya;
или
  char *p1 = &vasya[0];


и вот новый прикол

  char *t1 = "12345";

и рабоотает эта хрень вот так. справа стоит директива для комплиятора о том что нужно 
взять все то что внутри кавычек, преобазовать это все в байты согласно ascii таблице , 
плюс добавит в конце байт 0x00, но мало этого , эти все байты суются куда то в память,
то есть создается массив, причем этот массив это массив с типом CHAR,
далее потом создаеттся поинтер t1  и в этот поинтер суется адрес первого char элемента
этого массива. адрес можно совать в t1 потому что наш массив имеет тип CHAR а значит 
как я скащзал выше то все окей. 
таким образом мы може создать CHAR массив двум путями

  char vasya[]="12345";
  char *t1 = "12345";

результат один и тот же. создается в памяти char массив. но в первом случае не создается
поинтер который бы указывал на первый элемент массива. а во втором случае создается такой
поинтер. второй способ занимает чуть больше памяти. зато у нас есть в памяти явный указатель
где находится начало массива. правда первый метод дает по мне более доубный сопособ 
рабоать с элементами через 

  vasya[3] = 'a';

а вторйо метод такого недает. нужно делать вот так

 *(t1+2) = 'a';

хотя в целом это почти одно и тоже.





еще раз поговоорим про char [] массивы
в чем фигня с массивами то что если мы создали переменную типа массив
но если при этом мы сразу не задали значение то есть если мы вот так не сделали

  char vasya[]="123";

то далее наступает жопа. 
потому что потом уже задать знаение УДОБНО для массива супер неудобно.
приходится делать вот так

  char vasya3[10];
  // vasya3[] = "123" ; // так уже не прокатит
  vasya3[0] = 'a';
  vasya3[1] = 'b';
  vasya3[2] = 'c';


и вот такой уже подход не прокатит
  char *p48 = vasya3;
  *p48 = "123";   // так не прокатит 

тоесть я пока не понял как можно удобно задать чему равен массив если я обьявил
перенную но сразу не задал чему оно равно.
а вот мне подсказал ии как сделать. - через strcpy() 
тогда


  char vasya3[10];
  strcpy(vasya3, "1234567");





тепрь надо сделтаь еще один шаг и создасть структ. в нем поле котоое есть char массив
и потом создать поинтер char на этот массив. и убедиться что все чик пибабум.


  // задаем новый структ
  struct Person {
  char name[50];
  int citiNo;
  unsigned char badge;
  };


  struct Person person1;   // создаю переменую person1 под этим структом
    person1.citiNo = 0x1234;  // инициализирую поля структа
    person1.badge = 'A';
    strcpy(person1.name, "Gogy");
  printf("person1.name = %s \n");
  char *p57 = person1.name;
  char *p58 = &person1.name[2];
  printf("*p57 = %c, *p58 = %c \n", *p57, *p58 );
  


на экране
person1.name = 12345 
*p57 = G, *p58 = g 




вот эта строчка итересная
    strcpy(person1.name, "Gogy");
через нее можно удобно занести данные в char массив который ест поле в структе
после того как мы уже создали переменную. 

а вот это тема с поинтерами
  char *p57 = person1.name;
  char *p58 = &person1.name[2];


первый поинтер p57 я нацеливаю на первый char символ поля структа person1.name 
который по своей сути char массив.  и мы получаем адрес начала этого массива

второй поинтер p58 указывает на третий символ этого char массива


далее я публикую еще кое какой контент по массивам


еще малек про массивы
вот прмиер массива
он состоит из 10 элементов. каждый элемент это int тоесть он состоит из 4 байт.
значит его размер 40 байтов.

  //
   unsigned int b2[10]={1, 2, 3, 4, 5, 6, 7, 8, 9};
   dprintf (1, "\n"
  "b2[10] SIZE = %hhi \n"
  "адрес первого элемента в памяти = %p \n"
    "b2[0] = %hhX \n"
        , sizeof(b2), b2, b2[0] );


на экране увидим 
b2[10] SIZE = 40 (полный размер массива)  
адрес первого элемента в памяти = 0x7ffd8615a440 
b2[0] = 1  (занчние первггого элемента)


этим  я доказываю  что сам b2 это поинтер. это адрес на первый элемент массива.
и я покаываю то что запись b2[0] это УЖЕ НЕ ПОИНТЕР. а это именно уже значение такогото
элемента в данном случае значение лежащее в первом элементе. а какой размер у этого элемента?
а размер элемента такой как указано в определении массива

   unsigned int b2[10]

тоесть слова  unsigned int  обозначаю размер ОДНОГО эелмента в массиве. поэтому когда мы
просим нам выдать значение одного элемента  b2[0] то си нам выдаст ровно столько байт
сколко указано при обьявлении маасива. то есть в данном случае 4 байта. этоможно 
проверить  вот так

    dprintf (1,"b2[0] SIZE = %hi\n", sizeof(b2[0]) );

на экране
b2[0] SIZE = 4

тоесть я хотел тут подчеркнуть что b2 это поинтер. а элемент b2[i] это уже не понинтер.
это уже значение которое лежит внуритри таогото элемента массива. его размер равен 
размеру элемента массива. размер одног элемента задается на стаадии оббябявления массива
поэтому если 

   unsigned int b2[10]={1, 2, 3, 4, 5, 6, 7, 8, 9};

то b2 это поинтер размером 4\8 байт  взавимисомти 32\64 бит
а b2[i] это unsigned int а не поинтер и размер  4 байта





далее.
еще раз важный момент
для начала пример


  int* p1;

у нас имя переменной равно p1. а не *p1
а звезда она прилепляется не к имени перерменной. а к слову int
почему. потому что оно показывает что тип переменной это не int а это поинтер  на 
переенную с типом int
так как p1 это имя. а звезда относится к типу *int
то тогда выглядит логично

  int* p2 = p1;

это аналогично

  int a = 10;
  int b = a;

если бы звезда относиилась к имени переенной то тогда бы выглядело бы так

  int *p2 = *p1;

поэтому вот так выглдяит логично

  int* p2 = p1;

итак звезда она участвует в обозначении типа переменной.
еще раз замечу что если мы работамем с поинтером как с поинтером то мы юзаем
чисто имя переменной. тоесть

  p2 = .....
  p1 = ......

но звезда также участвует для другого . еслли мы хотим работать с переменной 
на котрорую указывает поинтер то можно использовать имя перееннной. тоесть

 int a = 10;
 a = a+1;

а если у нас есть поинтер на эту перменную 

 int* p = &a; (об символе & поговорим позже)

то вместо 

 a = a+1;

мы можем заюзать поинтер вот так

 *p = *p+1;

тоесть звезда натравленная на имя поинтера нам как бы дает имя переменной "a"
тоест звезда натравленная на имя поинтера нам дает не значение поинтера а значеие
переенной на которую укзывает поинтер.


теперь про директиву &

  int a   = 10;
  int* p  = &a;

как работает дирекктива &.
мы вспоминаем вот эту формулу 

  int* p1 = p2;

значит справа должно стоять имя поинтера. значит справа как бы стоит  имя p2 
поинтера который укыавзает на переменную a. тоесть у нас компиляотор как создает некий
поинтер p2 так что 

 int* p2;

и его значение хранит адрес переменной "a".

тоесть 

  int* p  = &a;

аналогично

  int *p = p2, где p2: int* p2; где p2 хрнаит адрес перменной а


тоесть вот этот пример

  int a   = 10;
  int* p  = &a;

он аналогичен

  int  a   = 10;
  int* p2  = адрес переменной "a"
  int* p   = p2;


это нам дает то что чтобы не было ошибки то нужно чтобы тип поинтера int* он был такой
что он укывзает на такой тип переменной который равен типу переменной a тоесть int.
тоест вот пример

  int   a = 10;
  char* p = &a;

то будеь ошибка. так как char* означает что поинтеру разрешено указывать на переменую
с типом char. а тип переменной a у нас int. поэтому
 
   char <>  int

поэтому будет ошибка





теперь рассмотрим массив
      int vasya50[10];

и поинтер на него

      int*  p = vasya50

чтобы это равенство работало качественно вспомним форулу выше

      int* p1 = p2;

чтобы это раблтало нужно чтобы тип у p2 был такой что 

      int* p2;

поэтому чтобы это работало 

      int*  p = vasya50

нужно чтбоы vasya50 был обьявлен вот так

      int* vasya50;

а у нас вот так

      int vasya50[10];


значит на счет масссива. 
вот когда мы обявили массиав

    int vasya[50];

и потом в коде пограмым испольузем слово

    vasya

то компилятор для себя интерпетирует это вот именно так

   &(vasya[0])

так что можно забыть про vasya и четко помнить что на самом деле это &(vasya[0])
тоесть

  int vasya[50];
  int* p = &(vasya[0]);

  через vasya[0] компилятор обозначает один из элементов массива. а что такое массив.
  это набор отделных элементов типа int
тоесть еасли у нас есть массив

  int vasya[50];
то в системе как бы с другой строны обьялвена куча отдеьынх переменных типа int
  
  int A0 = vasya[0]
  int A1 = vasya[1] 
  int A2 = vasya[2]

компилятор их ообозначает как vasya[0], vasya[1] итп

я хочу сказать особо чтоесть элемент первый эемент массива A. его компилятор 
  int A

его массив обозначает как vasya[0]

втоже время поинтер на первый элмент массива 

  int *p = &A 

наш компилятор обозначаает как vasya
тоесть

  int* vasya = &A

именно поэтому работает формула

  int* p = vasya;

ябы от так еще скзаал про то как компридятор задает в своей голове формулу

  int* vasya = &(vasya[0])


про массивы.
если мы создаем массив

  int vasya[5];

что это значит. у нас в памяти создается  5 отдельных переенных типа int

  int A0;
  int A1;
  int A2;
  int A3;
  int A4;

и мы просто вот так дебилоидно  замудрено их обозначаем как

  int vasya[5];

далее компилятор для себя интпреретирует слово vasya вот так вот такую переменную

  int* vasya = адрес переменной A0
или
  int* vasya = &A;
или
  int* p = &A;
  int* vasya = p;

итак смысл такой что vasya это поинтер типа int который указывает на первый элемент
массива. а раз так то мы можем вот так этого васю использовать

  int* p_2 = vasya;



вот мы создали массив 

      int vasya50[10];

так вот будет создан в памяти только тело массива
а поинтера который бы указывал на начало этого массива создано не будет.
при этом vasya это внутрнеееенняя переменная комплилятора котоаря хрнаит адрес начала
масссива и она воспринимается компилятором КАК ПОИНТЕР НА МАССИВ.

что такое поинтер на массив щас обсудим
вот код

      int vasya50[10];
      int *p50  = &vasya50;

и я полуаю ошитбку
 error: initialization of ‘int *’ from incompatible pointer type ‘int (*)[10]’ [-Wincompatible-pointer-types]
  212 |       int *p50 = &vasya50;

  а если делаю вот так

      int vasya50[10];
    int (*p50)[10] = &vasya50;


то ошибки нет.
в чем дело

во первых я понял более точно что значит директива "&a"
она НЕ значит "найди адрес такой то перменной и подсавить сюда. " нет. полая фигня.
он на самом деле значит  "найди адрес переменной. а еще опредеелли тип переменной. потом
создай в памяти компилятора виртуальный поинтер на эту переменную . тип у поинтера
равен типу переменной. а затем приравняй значение этого поинтера к нашему поинтеру.
но при условии что их типы совпадают"
покзываю
в этмо прмиере 

      int vasya50[10];
      int *p50  = &vasya50;

значит &vasya50 означает что : найди адрес vasya50 - ага 1234, потом нужно узнать 
тип перенной vasya50. ее тип это поинтер на массив. выглядит он так 
   int (*vasya)[10]  тонее даже вот так  int (*)[10]  
тогда создаем новый поинтер такого же типа
теперт срванвием тип слева и тип справа

    int *   и int (*)[10]
не совпдаают




у нас vasya50 это перменная типа поиинтер на массив. а слева
мы создаем поинтер но не на массив а поинтер на первый эдемент. поэтму 
пошел нафиг
во втором прмиерер


      int vasya50[10];
    int (*p50)[10] = &vasya50;

у нас слева как раз поинтер на массив поэтому ошибки нет

поитер на массив - это пиоинтер на массив в коором столько то элментв такогото типа






длаее. тлько я думал что все гавняшки нужные мне разобрал. 
но не тут то было.
вот есть такая штука

    char *p = ...;

это получается поинтер котторы в себе содержжит адрес по которому находится пременная
которая имеет тип CHAR тоесть размер 1 байт. при этом слева и справа от этого байта как
может быть инфрмация так и не быть. это неизвестно. тоесть унас может быть массив где
куча элементов CHAR. и наш поинтер указывать на какйото из этих элеметов в середине этого
массива


  char vasya[10]="123456789";
  char *p = &vasya[5];

при таком раскладе наш пэ будет указыать на элемент который равен '5';
соотсввсввтенно и слева от этого эелмента есть полезные байты информации и спрва от этого
элемента есть поелезные байты. 

но опять же слева и српва могут быть элементы необязателно char типа. там могу быть и другие
типы. нарпимер 


  // задаем новый структ
  struct Person {
  int citiNo;
  char name[50];
  };


  struct Person person1;   // создаю person1 под этим структом


  // инициализирую поля структа
  person1.citiNo = 0x1234; 
  strcpy(person1.name, "Gogy");

  // создаю поинтер
  char *p58 = &person1.name[0];


так вот левее адреса на который укывзает поинтер у нас будет лежть байт который отноисяя
к другому типу переменной



так вот это уже все обсуждалось
и вот вылезает новая хрень. 
до этго я говорил про один поинтер. единичный. а теперь мы начианем 
говорить про массив из поинтеров. тоесть есть куча незавиисимых потинтеров просто 
они все собраны в памяти  в одну кучу. и еще момент они все указывают на переменные одного
типа. тоесть все поинтеры имеют один тип. 
создается массив поинтеров вот так





======
еще материал отдельный.
на счет массивов. и поинтеров. 
с маассивами у си реальная пизда.

вот я создаю переменную vasya которая имеет тип массив

  int vasya[5];

значит во первых что будет после этого кода внутри компилированной программы. 
будет выбран кусок в памяти размером 4 байта * 5 = 20 байтов. скорей всего будет в стек
засунуто 20 байтов 0х00
больше ничего не произойдет. в частности никакой доп ячейки где будет записано начало
массива. размер массива, размер элемента. этого ничего не будет.

зато внутри памяти компилятора возникнет целая череда всяких переменных. щас я 
о них раскажу.
во первых внутри компилятора возникают переменные вида

  vasya[0]
  vasya[1]
  vasya[2]
  vasya[3]
  vasya[4]
  vasya[5]

все они  имеют тип int. но я не могу вот так записать

  int vasya[0]

потому что у этого дебтла так обьявляется новый массив из нуля элементов
поэтому я могу тлоько записать вот так

  vasya[0] (тип int) 
  vasya[1] (тип int)  
  vasya[2] (тип int)    
  vasya[3] (тип int)  
  vasya[4] (тип int)  
  vasya[5] (тип int)  


во вторых возникает вот такая переменная 

  vasya 

которая по своей сути экивалента &(vasya[0])

в третьих если я использую вот так &vasya то это совершенно неприводит к конструкции
&(&(vasya[0])) . нихуя к этому не приводит.
вместо этого &vasya оно транслируется в &(int vasya[5])  что приводит к тому что 
результатом этой операции будет int (*p)[5]

поэтому в итог я бы сказал что в итоге деается по уму

  int vasya[5];
  &vasya =  &(int vasya[5]) = int (*p)[5]
  тоесть если у нас вася это массив а не просто обычная переменная то поинтер
  на массив не может быть обычным поинтером. это должен быть особый вид поинтера - поинтер
  на массив. вот он вот так обозначается

       int (*p)[5]

  тоесть обычный поинтер int *p не может быть поинтром на массив.
  но вот что эта сука компияторская делать не помуму а по уебанству. 
во первых обычный поинтер укзаывает на обычную перменмнеую

  int a;
  int *p = &a;

это хорошо , это праивльно. 
но к сожалению комлиятор разрешает использовать обычный поинтер на элемент массива. 
по мне это конечный ебанизм

  int *p = &(vasya[0])
  int *p = &(vasya[1])
  int *p = &(vasya[2])
  int *p = &(vasya[3])
  int *p = &(vasya[4])

я считаю что поинтер на элемент массива должне был иметь особое обозначение. но нет 
нихуя. 
итак мы только что узнали что обычынй поинтер 

  int *p

он может указывать как на обычную перменную так и на элемент массива. да уж.
так вот компиялторв плане ебанаства идет еще дальше. он говорит о том что если у нас
есть вот такая запись

  int *p = &(vasya[0])
то ее можно сократить. испольховать более короткий алиас. но внмиание заметь какой ебнутый
вариант алиаса он нам предлагает

  int *p = vasya


это просто пиздец. это просто пиздец.

дело в том что фраща   int *p = vasya
подразуемевает что у нас vasya это якобы поинтер. а тэто нихуя не поинер. это массив.
поэтому то что он вствляет vasya это осука ебаная. этим он очень охуенно запутывает все.
пиарас.

---
еще материал по поинтерам.
хочу разные типы поинтеров осветить.
самый простецкий поинтер выглядит вот так

  int* p 
либо 
  int *p
это совершенно одинаковая фигня.

такой поинтер звучит как поинтер который укаывзавает на обычную переенную которая имеет тип=int

также этот тип поинтера может укаызвать на переменную которая имеет тип=int но ее тело лежит
в памяти внутри тела пременной котоаря имеет тип=массив. пример

    int vasya[10];
    int *p = &(vasya[0]);
причем это работает нетолько для vasya[0] а для любого [i] где i=0..9
тоесть
    int *p2 = &(vasya[3]);
или
    int *p3 = &(vasya[9]);


также я могу скзаать что ровно такойже поинтер может указыать на на переменную которая имеет тип=int и ее тело лежит в памяти внутри тела пременной котоаря имеет тип=массив которая в свою
очередь лежит внутри тела переменной которая явлется структом. пример
 
  // задаем новый структ
  struct Person {
  char name[50];
  int citiNo;
  unsigned char badge;
  };


  struct Person person1;   // создаю person1 под этим структом

  strcpy(person1.name, "Gogy");  // заношу данные в массив name 
  char *p58 = &(person1.name[2]); // создаю поинтер на элемент 2 внутри массива name


тоесть у нас есть массив name. он явлется полем внутри переменной Person1 которая 
миеет тип=структ Person. 
когда мы создали массив name. то компилятор автоматом создал переменные с типом char
которые имеют имена вида person1.name[i]. и я создал поинтер на переменную person1.name[2]
которая имеет тип int. 

так что самые простеукие поинтеры которые имеют тип

    char *p
    int  *p

они могут укзыать нетлоько на простецкие переменные висящие в памяти. но и переменные
которые имеют свои тела глубоко сидящие внутри тел массивов, структов и прочей нечисти.


следущий тип поинтера это 

  int (*p)[N]

этот поинтер иммет тип который читает как. поинтер на переменную которая имеет тип массив.
или сокращенно поинтер на массив. 
еще раз. предыдущий тип поинтера он звучит как поинтер на переменую которая имеет 
тип int\char\long int\short int 
текущий же поинтер это совершенно другая хрень. потому что он укывзает на переменную с
соврешенно другим типом. 

опятьже я просню такую хрень что строго говоря запись вида

    char *p

означает создать переменную p которая имеет тип поинтер который уавызает на переменную кторая
имеет тип char.  так вот строго говоря в этой выражении имя ерееменной равно p а  буквы
которые выражают ее тип это 

    char *

тоже самое для этого выражения

  int (*p)[N]

здесь буквы которые выражают именно тип выглядят как

  int (*)[N]

тоесть выражение 

    char *p

оно создает уже переменную такого то типа.
а сам тип имеет выражение 

    char *

но я дальше буду всетакие неосвсем коректно называть выражение

    char *p

как тип. мне так првиыячнее. хотя это не совсем коректно.

тоесть прикол в том что в си дебильно сделано что имя переменной вставляется внутрь
записи которая описывает тип
вот в этой записи имя переменой p вставлено не слева от типа ни справа а прям в середину.

  int (*p)[N]

по мне это полный ебанизм придумыать такую систему обоначений.
это как если бы мы писали

  пере"p"менная

вместо 

  переменная "p"

вот это рвоно тоже самое что эти ебанаты делают при такой форме записи

  int (*p)[N]

потому что имя перенной p. а ее тип это int (*)[N]
тоесть я счиаю что нужно быол делать обозначение либо вот такое

    int (*)[N] p

либо вот такое

    p int (*)[N]

и это было бы логично красиво. а так полная путающая на пустом месте ХУЙНЯ.


итак я рассмотрел простецкий поинтер. поинтер на массив.
следующий тип поинтера это  тип=массив поинтеров


  int* p [5];


это массив из пяти элементов каждый из которых укаызвает на int
чтобы внести занчение в элемент то нужно сделать вот так
 

 int a = 10;
 int* p [5];
 p[3] = &a;


следущий вид поинтера это поинтер на поинтер

    int **p2;  

тоесть

   int *p;
   int **p2;  

тоесть это p2 это поинтер который указает на поинтер типа int  который укаывзает на перменную которая имеет тип int

можно делать большую вложенность

   int ******p;  


теперь пока отложим расспотрение друнгих типов поинтеров. потому что надо поговорить
про те что уже знаем. есть очень интерсная тема.
во первых напомню  о том что делает компилятор если видит вот такое

  int vasya[10];
  int *p = vasya;

компилятор налету заменяет во второй строке имя переменной массив на имя автоматически
созданной им налету переменной которая имеет тип поинтер и сссылается на первый элемент 
этого массива. тоесть

  int vasya[10];
  int *b = &(vasya[0]);
  int *p = b;

таким образом vasya заменяется на b; 
тоесть как говорит ии что компилятор си если видит в тексте на си упоминание имени
массива то компилятор считает что мы его таким макаром просим в этом месте замениь имя
массива на имя поинтера который указвыает на первый элемент этого массива. этот поинтер
кипилиятор создает на лету прзрачно для нас. по мне такое "удобство" только охуенно запутывает
программу и поорграмиста. 
рассморим теперь массив у которого элементы по своему типу являются поинтерами. говоря
коротко рассмотрим массив поинтеров. 

  int *p [5];
если бы мы написали
 int p [5];
то это был бы массив где элементами являются int
а в нашем случае элементами являются поинтеры которые указывают на int 
теперь создаим переменную которая является поинтером на первый элемент этого массива.
так как это массив с именем p то имя нулевого элемента  имеет имя p[0] и этот элемент 
имеет тип int*. теперь подумаем какой тип будет иметь переенная которая будет уаазывать на 
этот тип. ответ - int**. тоесть если элемент на который мы будем указывать имеет тип поинтер
на int то поинтер который укаызвает на такой тип имеет тип поинтер на поинтер на int или int **

  int** q = &p[0];

теперь подумаем о том какое физ значение будет у дереференса переменной q.
ну так как она указывает на поинтер то значением будет адрес.  а че за адрес?
а щас разберемся

  int a = 10; // переменная a лжеит по адресу 1234 и равна 10
  int *p [5]; // тело массива начинается с адреса 7689 
  p[0] = &a;  // в ячейки 7689-7692 будет записан адрес 1234

  int** q = &p[0];
  *q;


элемент p[0] он лежит в ячейках 7689-7692. и в них лежит число 1234. тоесть p[0] 
он хранит адрес где искать a. 
а переенная q она в себе хранит адрес где искать p[0]
поэтому q = 7689
тоесть поинтер который имеет тип поинтер на поинтер он себе хранит число которое показывает
адрес другого поинтера. а если мы делаем дереференс q тоесть *q то таким макаром мы узнаем
что хранится в удаленном поинтере. а хранится в нем адрес где искать переенную a.
тоесть *q=1234
щас я это проверю


  int a = 10; // переменная a ее адрес=1234
  int *p [5]; // тело массива начинается с адреса=7689 
  p[0] = &a;  // в ячейки 7689-7692 будет записан адрес 1234. тоесть p[0]=1234

  int** q = &p[0]; // q=7689

  значит по идее если я сделаю *q и &a я должен получить одно и тоже.
  printf("*q = %p, &a = %p  \n",   *q, &a  );
  
смотрим на экране
*q = 0xfffea84c, &a = 0xfffea84c 

видим что одно и тоже.
таким образом если  у меня есть поинтер который имеет тип ** тоесть который поинтер на 
поинтер. то дерефееренс его через одну звезду показыает адрес конечной переменной.
тоесть  если  у нас есть переменная a которая имеет адрес 1234.
если у нас есть поинтер p который в себе хранит 1234
то *q который является поинтером на p нам даст 1234. тоесть *q дает нам  &a по своей сути.
тоесть елси  у меня есть какието перменные a,b,c,d которые лежат  в памяти. 
если у меня есть массив p[0], p[1], p[2] который в себе содержит адреса этих переменных.
если у меня есть поинтер который указаывает например на p[1] то тогда операация
*q нам выдаст адрес нахождения например переменной c
тоесть если у нас где в памяти валяются переменные. и если у нас где то  в памяти валяется
массив в котором записаны адреса этих переменных. и если у нас есть переменная в которой
хранится адрес начала того массива то тогда используя эту переменную можно в итоге все это 
хозяйство раскрутить на то что можно добраться до конечных переменных.
я щас хочу расссмотреть хрень которая  часто встречается в си програх.
это 


  int main(int argc, char *argv[]) {
  ...
  ...


так вот я хочу хорошенько понять вот эту хрень  char *argv[] которая встречается
в аргументах фукнкций.
но для начала нужно рассмотреть вот такую хрень как

   char **p



вот пример программы

$ cat < 323.c
#include <stdio.h>

int func1(int **p);  \\ прототип фнкции


int main(){
  int a    = 0x10;
  int *p   = &a;
  int **pp = &p;  \\ вот этот поинтер на поитер
  func1( pp  );   \\ вызываю фнукцию
};


\\ тело функции
int func1(int **p){
    printf("привет из функции func1! **p = 0x%X \n", **p );
    return 0;
};


вывод на экране
привет из функции func1! **p = 0x10 


пока ничего особого. теперт создадим несколько переменных a,b,c 
и поинтеры на них засунем в массив


теперь смотрим другой пример программы
$ cat 324.c
#include <stdio.h>


int func1(int **p);  // прототип функции



int main(){


  int a    = 0x10;  // задаю начальные простые переменные
  int b    = 0x20;
  int c    = 0x30;
  int *p[3];        // создаю массив поинтеров
  p[0]   = &a;      // набиваю элементы массива значенияеми
  p[1]   = &b;
  p[2]   = &c;
  int **pp = &(p[0]);  // создаю поинтер на поинтер. поинтер на первый элемент массива

  func1( pp  );      // самое интересное. я вызываю фнкцию три раза
  func1( &(p[0]) );
  func1 ( p );


};



// тело функции
int func1(int **p){

    printf("привет из функции func1! **p = 0x%X \n", **p );
    return 0;
};


вижу на экране
привет из функции func1! **p = 0x10 
привет из функции func1! **p = 0x10 
привет из функции func1! **p = 0x10 



итак я три раза вызываю функцию тремя разными путями 

  func1( pp  );   
  func1( &(p[0]) );
  func1 ( p );

моя функция в своем проттотипе она требует чтобы в нее ставили имя переенной
которая по своему типу является поинтером на поинтер int func1(int **p)
так вот первый раз когда я вызываю эту фнкцию я в аргумент ставлю переменную pp

  func1( pp  );   

и эта pp он акак раз таки по своему типу является поинтером на поинтер

  int **pp = &(p[0]);

все классно. 

второй раз вызываю фнункцию и я прошу сам компилятор налету создать переменную для меня
невидимую и прозоаучную которая будет иметь тип поинтер на поинтер применяя директиву &
на переменную типа поинтер p[0] 

  func1( &(p[0]) );

тоесть констуркция  &(p[0])  она заствляет компилятор создать некую пеерменную temp 
которая яялется поинтером на переменную p[0]. так как p[0] имеет тип поинтер то в итоге
temp будет поинтером на поинтер. тоесть комплиятор налету создаст некую прозрачную для
меня переенную temp  вот такую

  int ** temp = &(p[0]);
и в моя строчка вызова фукнции будет заменена на стороку

  func1( temp );

итак когда я вызывают фнкцию вот так 

  func1( pp  );   

я перед этим создаю переенную int **p явно. тоест пеемррменную с нужным типом. и я ее подсталвяю
в фукнцию. 

когда я вызваю фукнцию вот так

  func1( &(p[0]) );

то я делаю некий небольшой трюк. и прошу компилятор создать его самого переменную типа поинтер
на поинтер чтобы мне ее не создавать. я прошу его сделать это за меня. тоесть я подставляю
переменную которая всего навсего поинтер. а его проошу создать необхоимую для аргумента 
фукнции переенную типа поинтер на поинтер самого. и он это делает. и трюк срабатывает

и трейти путь как  я вызываю фнкцию 

  func1 ( p );

напомню что такое пеерменая p. какой ее тип    int *p[3]; 
тоесть p это массив. а я уже писал ранее что если мы испоьльщуем в тексте на си имя 
переменной у которой тип массив при подстановке в фкнцию в качестве аргумента то компилятор
сразу это замечает и он прозрачно от нас налету прееделывает наш текст на си на совершшенно
другой. а имено компилятор мгвноенно заменяет нашу строку вот на такую

  func1 ( &(p[0]) );

итак еще раз у нас в прогармме стоит строка

  func1 ( p );

но она мгнвоенно превращается в другую строку

  func1 ( &(p[0]) );

а это ровно тоже самое что яделал когда сам делал вызов фукции второй раз. я сделал
тоже самое. поэтому у нас в итоге все прокатывает. и вызов срабатывает.
если незнать о таком трюке компилятора то будет непонятно. потому что проттотип фунции
требет чтобы переенменная которую мы ставим в аргумент фукнции то он должен иметь тип **

    int func1(int **p)

а если мы посмтрим как мы ункцию вызываем

  func1 ( p );

то мы видим что пеерменная p имеет тип массив. а массив это нихуя ни разу неточто поинтер
на поинтер а это даже не поинтер. поинтер это тип переменной. а у нас тип переменной это 
массив. поэтому это выгядит как ошибка и полная хуйня. однако разгадка в том как я уже сказал
что если мы в тексте используем имя переменной в качестве аргумента функции то компилятор
на лету меняет эту строку на другую . он меняет имя переменной p на имя налету созданной
переменной которая является поинтером на первый элемент этого массива. поэтому вместо p
у нас будет подставлена имя некоей автоматически созданной переенной temp вот такой

   int ** temp = &(p[0]);
и далее наша строчка меняется компилятором на 

  func1 ( temp );

и тут нет ниаких проблем в плане типов. потому что наша temp это ** и это ровно тот тип 
который тербует прототип фнкции func1.


далее я смотрю 325.c
она такая же как 324.c но в ней я добавил func2. мы на ней заострим внмиание.
на этом куске


вот я ее вызываю
   func2( p );


вот ее тело
int func2(int **p){

    printf("привет из функции func2! \n" );
    printf("p = %p, читаем первые 4 байта на которые указывает мой поинтер = %p \n", p, *p );
    printf("p+1 = %p, читаем следущие 4 байта от адреса на который указыает мой поинтер  = %p \n", (p+1), *(p+1) );
    printf("p+2 = %p, читаем еще дальше следущие 4 байта от адреса на который указыает мой поинтер  = %p \n", (p+2), *(p+2) );


    return 0;
};



вот мы увидим на экране
 adress a = 0xffdffc60 , address b = 0xffdffc64, address c = 0xffdffc68 
...
...
читаем первые 4 байта на которые указывает мой поинтер = 0xffdffc60 
читаем следущие 4 байта от адреса на который указыает мой поинтер  = 0xffdffc64 
читаем еще дальше следущие 4 байта от адреса на который указыает мой поинтер  = 0xffdffc68 

я хочу заостирть внимние вот на этих формулах
  *p
  *(p+1)
  *(p+2)

и на этих 
 (p+0)
 (p+1)
 (p+2)

если у меня p  это поинтер и если p=1234 и если я делаю (p+1) то какой адрес будет при этом
вычислен? будет ли это 1234+1=1235 или какойто другой? ответ - так как p это поинтер то
арифметика у него нетакая как кажется. так как p это поинтер то он указыает на какйото 
тип данных. если я пишу +1 то это значит что компилятору нужно сделать такой сдвиг чтобы 
ми полностью минули те байты в которых хранится та переменная на которую указвает адрес p.
тоеесть - если унас 

  int *q;

и q=1234 то это значит что у нас лежат данные в адресах 1234 1235 1236 1237 потому что 
q указывает на int а он размером 4 байта. поэтому если я нпишу в программе q+1
то это значит что нужно сделать сдвиг вправо настолко чтобы мы пропустили байты 1234 1235 
1236 1237 где лежат данные которые относисятся к q. поэтому q+1 приведет к тому что
мы получим 1234+4 = 1238

  1234 1235  1236 1237   1248 ...
 | --------------------|
  здесь лежит те данные
  на которые укаазывает
  поинтер q

поэтому q+1 это будет 1248 но не 1235

если я сделаю 

 short int *q

и q=1234 то это значит что q указывает на два байта 1234 1235
тогда если я сделаю q+1 то у нас сдвиг будет на 2 байта

  1234 1235  1236 1237   1248 ...
 | --------|
  здесь лежит 
  те данные
  на которые 
  укаазывает
  поинтер q

тогда q+1 будет равен 1236

если я сделаю 

 int ** q

и q=1234 
и если я делаю q+1 то у нас q указывает на тип данных поинтер. если это 32бит цпу то поинтер
имеет размер 4 байта. значит у нас q=1234 указывает на байты 1234 1235 1236 1237

  1234 1235  1236 1237   1248 ...
 | --------------------|
  здесь лежит те данные
  на которые укаазывает
  поинтер q

и если  я делаю q+1 то это будет равно 1248

поэиму возвращаясь к нашей проге. у нас есть массив поинтеров p. 
цпу 32 бита. значит по 4 байта на 1 элемент.
я передаю указатель на первый элемент в фкцни func2
и в ней этот адрес лежит в ее внутрнейен перменной p которая уже поинтер на поинтер.
и если я делаю дерефренс через *p то мы видим значение первых 4 байт которые хранятся
в массиве p который ... блядь щас я откоретирую программу. и еще раз распишу

значит вот наша прога

$ cat 325.c
#include <stdio.h>


int func1(int **p);
int func2(int **q);


int main(){


  int a    = 0x10;
  int b    = 0x20;
  int c    = 0x30;
  printf (" adress a = %p , address b = %p, address c = %p \n", &a, &b, &c );
  int *p[3];
  p[0]   = &a;
  p[1]   = &b;
  p[2]   = &c;
  int **pp = &(p[0]);

  func1( pp  );
  func1( &(p[0]) );
  func1 ( p );

// перехожу к func2
   func2( p );
   
  
};



int func1(int **p){

    printf("привет из функции func1! **p = 0x%X \n", **p );
    return 0;
};


int func2(int **q){

    printf("привет из функции func2! \n" );
    printf("q = %p, читаем первые 4 байта на которые указывает мой поинтер = %p \n", q, *q );
    printf("q+1 = %p, читаем следущие 4 байта от адреса на который указыает мой поинтер  = %p \n", (q+1), *(q+1) );
    printf("q+2 = %p, читаем еще дальше следущие 4 байта от адреса на который указыает мой поинтер  = %p \n", (q+2), *(q+2) );


    return 0;
};



у нее есть массив p
  int *p[3];


в котороом элементы это пинтеры и они указывают на некотрые переменные

  p[0]   = &a;
  p[1]   = &b;
  p[2]   = &c;


я передаю адрес перого элемента в func2

   func2( p );


вот ее тело

int func2(int **q){

    printf("привет из функции func2! \n" );
    printf("q = %p, читаем первые 4 байта на которые указывает мой поинтер = %p \n", q, *q );
    printf("q+1 = %p, читаем следущие 4 байта от адреса на который указыает мой поинтер  = %p \n", (q+1), *(q+1) );
    printf("q+2 = %p, читаем еще дальше следущие 4 байта от адреса на который указыает мой поинтер  = %p \n", (q+2), *(q+2) );


    return 0;
};


что она делает.
вэтой строчке

    printf("q = %p, читаем первые 4 байта на которые указывает мой поинтер = %p \n", q, *q );

она печает q в котором лежит адрес первого элемента p[0] массива p  
во следущей строке

    printf("q+1 = %p, читаем следущие 4 байта от адреса на который указыает мой поинтер  = %p \n", (q+1), *(q+1) );

я увеличиваю поинтер q на 1 ==> (q+1) и это приводит к тому что компилятор прибавляет к 
адрсу который лежит в q 4 байта. почему так? почему не +1 байт. потому что кгда мы увелиичивает
поинтер на 1 то это сигнал компилятору что нужно значение адреса в поинтере сдвинуть на то
числ байтов которое равно размеру типа пременной на которую он укзывает. так как цпу 32
бита то поинтер на который укывзает наш поинтер имеет размер 4 байта. поэтому сдвиг идет на 4 
байта.  ну а используя констуркцию *(q+1) я смотрю что же лежит по адресу (1238 1239 1240 1241 
при условии что положим что сам q=1234). таким образом конструкция q+1 позволяет нам используя
адрес хранящийся в поинтере сдвинуться на следущий элемент в памяти а не на 1 байт. что 
очень круто. получатеся если у нас наш q который имеет тип ** тоесть это поинтер на поинтер ,
так вот если q у нас укзыавет не на одиночный поинтер а на самом деле на масив поинтеров то
мы можем легко и прикольно двигать по этому массиву. 
вот еще пример. 
пуст у нас будет массив

  short int vasya[10];
  я делаю поинтер на его первый элемет

  short int *q = &(vasya[0]);

  теперь я могу удобно и легко двиаться по элеметам этого массива не заботясь руками о том
  насклоко байтов мне нужно сдвинуть адрес который лежит в поинтере. делаю это вот так

  (q+0) = это будет я увижу адрес первго элементма массива
  (q+1) = это я увижу адрес втроо элемента массива. при этом компилятор прьбавит 2 байта к 
  адресу который хранится в q. а не один байт. 
  (q+2) = я увижу адрес который хранит третий элемент массива. поскольку поинтер укзывает
  на short int и его размер это 2 байта этого типа то сдвиг значения в q будет не 2 
  а будет q+2*(sizeof (short int)) = q+2*2=q+4

  1234 1235   1236 1237  1238 1239
 
  |---------| |--------| |---------|

  если скажем q=1234 то (q+2) будет равен 1238 и мы виим из картнки что реально третий
  элемент массива храится начиная с адреса 1238.

еще раз посмотрим на хрень когда у нас есть масив поинтеров.


  1234 1235 1236 1237  1238 1239 1240 1241
  
  |-----------------| |--------------------|


положим что у нас есть массив p который хранить поинтеры.
положим что массив p начианется с 1234. и создаю поинтер на поинтер q  который укзвыает
на перй элемент массива тоесть на 1234

  char *p[2];
  char **q = &(p[0]);

q у нас = 1234. q это у нас поинтер на поинтер. если я хочу прогуляться по элемнтам 
массива p то я могу это делать вот так

(q+0) = это адрес первого элемет = 1234
(q+1) = это адрес втого элемента = 1234+1*(sizeof (char *)) = 1238 ( на 32бит цпу)
 
это хорошо видно на картнку выше.
если я хочу прочитать контент этих жлементо то я делаю вот так
*(q+0) = контен первого элемета масива (содержимое кторое лежит по адресам 1234-1237)
*(q+1) = контент второго элемента масива  (содержимое кторое лежит по адресам 1238-1241)

а что это за контент? вспоминаем что элемент массива p это поинтер (тоесть адрес) который
указывает на некоторую переенную. пусть первй элемент укзыавт на перменную a а второй на 
переенную b
значит *(q+0) = покажет нам адрес где хранится пермнная a
значит *(q+1) = покажет нам адрес где хранится пермнная b

вспоинмаем тип переенных a и b это char. также всопминаем что у си у него обычный поинтер
коими являются элеенты масива p он моет укзывать на обычную переную а может указыать на 
обычную перееную  в составе массива. поэтому адрес который указыват не пременную a он еще
может вести на  стринг. тоесть вместо переенной a мы также мыогли бы подснут в наш поинтер
стринг. щас покажу




  char a[10]    = "123456789";
  char b    = 0x20;
  char c    = 0x30;
  char *p[3];
  p[0]   = &(a[0]);
  p[1]   = &b;
  p[2]   = &c;
  char **q = &(p[0]);


тоесть видно что элементы p[i] у которых тип char* они могут указывать как на просто
незавиимую переенную так и на элемент внутри массива. ну и тогда используя q можно 
например напечтатать контент массива a

  printf("%s \n", *(q+0));

на экране
123456789 

тоесть через *(q+0) мы смотрим контент первого элемента массива p тоесть контент p[0]
а это получается адрес первого элемнта массива a[10]. тоест по факту
   *q =   p[0] = &(a[0]);

тоесть через *q мы узнаем адрес певрого элемета массива a[10] который стринг. 
а для принфт модфиикатор %s требует ему пеердать как раз адрес певрого элемента массива
кооырый стринг. поэтому программа успешно работает. 
при этом важно омтеть что вот такое сработает

  p[0]   = &(a[0]);

а вот так несработает

  p[0]   = &a;

потому что у нас перемнаня a это массив. и если мы хотим для него найти поинтер 
то у него будет тип   char (*z)[10] а умен слева стоит элемент у которого тип char*
поэтмоу полет нахуй. а когда мы вот так делаем

  p[0]   = &(a[0]);

то мы не ишем поинтер на весь масив a авсего навего поинтер на его первый элемент который
имеет обычный тип char. поэтому то и полуается.

тепер я продолда. эту темк. и расотрю вот такую програму

$ cat 327.c
#include <stdio.h>


int func2(char **qq);


int main(){


  char a[10]   = "123456789" ;
  char b[4]    = "abc";
  char c[3]    = "FF";
  char *p[3];
  p[0]   = &(a[0]);
  p[1]   = &(b[0]);
  p[2]   = &(c[0]);
  char **pp = &(p[0]);

   func2( pp );
   
  
};





int func2(char **qq){

    printf("*(qq+0)  = %s \n", *(qq+0) );
    printf("*(qq+1)  = %s \n", *(qq+1) );
    printf("*(qq+2)  = %s \n", *(qq+2) );


    return 0;
};



знаит у нас тут получается что наши начальные перменные это три массива
которые внутри себя содержат стринги

  char a[10]   = "123456789" ;
  char b[4]    = "abc";
  char c[3]    = "FF";


длаее я создаю массив поинтров в которых элементы указают на ппервый символ в каждом
из стрингов

  char *p[3];
  p[0]   = &(a[0]);
  p[1]   = &(b[0]);
  p[2]   = &(c[0]);


далее я содаю поинтер на перый элмент нашего масива p

  char **pp = &(p[0]);

получается что pp это поинтер на поинтер.

длаее я этот поинтер скармилваию как аргумент при вызове func2

   func2( pp );



переходим в эту фкнуцию

int func2(char **qq){

    printf("*(qq+0)  = %s \n", *(qq+0) );
    printf("*(qq+1)  = %s \n", *(qq+1) );
    printf("*(qq+2)  = %s \n", *(qq+2) );


    return 0;
};



и мы используя этот поинтер  гуляем по массиву на который он указыает и читаем 
значения элементов этого массива *(qq+0),  *(qq+1), *(qq+2)
что удобно что нам неуно забоатится об ручном вычислении адресов элементов массива. за нас
это делает компилятор. это удобно. 
таким маккаром мы получаем адреса первых элементов стринга.  а это нам надает возможность
напеаать весь стрино через printf и его модификатор %s

щас малек передалю программу

$ cat 328.c
#include <stdio.h>


int func2(unsigned short num, char **qq);


int main(){


  char a[10]   = "123456789" ;
  char b[4]    = "abc";
  char c[3]    = "FF";
  char *p[3];
  p[0]   = &(a[0]);
  p[1]   = &(b[0]);
  p[2]   = &(c[0]);
  char **pp = &(p[0]);
  unsigned short num = 3;

   func2( num, pp );


};





int func2( unsigned short num, char **qq ){

   for (unsigned short i = 0; i<num; i++ ) {
      printf("*(qq+%hhi)  = %s \n", i, *(qq+i) );
   }


    return 0;
};




я теперь преедаю в фукнцию нетолько поинтер на перый элемент массива
но и число элементов массива p

int func2(unsigned short num, char **qq);


тогда я могу пройтись по элементам массива используя цикл for
потому что знаю число элементов массиве



int func2( unsigned short num, char **qq ){

   for (unsigned short i = 0; i<num; i++ ) {
      printf("*(qq+%hhi)  = %s \n", i, *(qq+i) );
   }


    return 0;
};


и вот вывод на экране

*(qq+0)  = 123456789 
*(qq+1)  = abc 
*(qq+2)  = FF 



значит в чем прикол вот такой функции

    int func2( unsigned short num, char **qq )

прикол в том что мы можем создать огроманый массив тоесть много элементов в нашей main()
а потом хотим его напечтатать используя для этого фкнкцию func2
так вот наша задача передать в фкнцию  минимальное количество параметров. потому что 
если нам надо взывать эту фкнцю скажем 1000 000 раз в секунду то нам нужно чтобы ее 
запуск требовал минимального числа параметров. ибо код ассеблере он при взываое фкцнии
кладет копии аргументов в стек. сует их туда. потом он их читает. это все накладно.
так вот получается что неважно сколько элементов у нас в масиве. неважно какой длинны у
нас стринги. всегда у нас вызов функции func2() требует полжить в стек всего две 
короткие перенные. число элементов. это максмумум 2 байта. и указатель. это  4 байта
(на 32бит цпу). это отлично. 

итак получается что у нас в памяти сидят массивы вкоторыех сидят стринги.
у нас есть массив который в себе хранит адреса начал этих стрингов.
и у нас есть поинтер который укызвает на начало этого второго массива. вот такая схема.
и она позволяет в итоге получить func2 досутп ко всей это хрени путем всего навсего
двух простенких перееннменых и коротких по размеру . поинтер и числ элементов  в массиве 2
и все. при этом доступ к конечным пееременным идет через конструкцию

 *(qq+i)
либо 
**(qq+i)

в завсимости что мы хотим прочитать


а теперь я хочу рассмотреть другой вариант передачи тех же самых стрингов
но через вот такой тип аргумента у фкцнии 


    int func2( unsigned short num, char *qq[] )


вот вариант этой прграммы

$ cat 329.c
#include <stdio.h>


int func2(unsigned short num, char *q[]);


int main(){


  char a[10]   = "123456789" ;
  char b[4]    = "abc";
  char c[3]    = "FF";
  char *p[3];
  p[0]   = &(a[0]);
  p[1]   = &(b[0]);
  p[2]   = &(c[0]);
  char **pp = &(p[0]);
  unsigned short num = 3;

   func2( num, pp );


};





int func2( unsigned short num, char *q[] ){


    

  for (unsigned short i = 0; i<num; i++ ) {
      printf("*(qq+%hhi)  = %s \n", i, *(q+i) );
      printf("q[%hhi]  = %s \n", i, q[i] );

   }




    return 0;
};




значит теперь я использую другой тип аргумента у функции
вот такой вот char *q[]

    int func2(unsigned short num, char *q[]);



получатеся по факту я сообщаю что у меня q это массив. теперь мы вспоминаем что 
если мы пытаемся вставит в аргумент фкцнии переменную массив то компилятор сразу это делает
меняет и заменет эту переменную поинтер на первый элемент массива. потому что что было бы
если бы компилятор дословно выполнял наш заказ. если бы компилятор реально юзал имя массива при
вызове фкцнии то это бы означало что он должен был бы при вызвое функции в стек заснуть ТЕЛО
массива. а это огромные перформанс издержки. пэтом там где мы пытаемся сунуть значения массива
там компилятор автомаоматом меняет это дело на поинтер на первый элемент этого массива.
потому в нашем примере мы укаазали что якобы  у нас второй аргумент это переменная которая
имеет тип массив. компилятор не позволит совать тело массива в качестве аргумента фкунииции.
поэтому наш прототип будет прозрачно заменен компилятором вот на такой

    int func2(unsigned short num, char **q );

таким образом наша факция будет ожидать что ей вторым аргументом суют переменную котоаря 
имеет тип поинтер на поинтер но никак не массив. этот случай такйой функции я рассмотрел как
раз выше.

поэтому еще ращ если мы в текте нашей прогрммы пишем протоотп ффкнции у котрой мы укывзаем
что якобы ондин из аргументов имеет тип массив то компилятор мгвновенно заменим наш прототипа
на другой. вот так было 


    int func2(unsigned short num, char *q[]);

а вот так станет

    int func2(unsigned short num, char **q );


а теперь посмим на тело нашей фкнкции


int func2( unsigned short num, char *q[] ){

  for (unsigned short i = 0; i<num; i++ ) {
      printf("*(qq+%hhi)  = %s \n", i, *(q+i) );
      printf("q[%hhi]  = %s \n", i, q[i] );

   }
    return 0;
};


поскольку наше q это не char*[] аэто  **q
то поэтому мы с этой перееменной спокойно работаем через  *(q+i) как  я это делал
в программе гораздо выше. но что еще более прикольно что также можно с нашей q работать
в виде q[i] !  спрашиватся что за хуйня. ведь наш q это поинтер но никак не массив.
мне ии сказал что в си выражение q[i] это всегда взаимозаменяемая хрень с *(q+i)
тоесть вот эти две штуки это одно и тоже с точки зрения компилятора

    q[i] == *(q+i)

поэтом кода я пишу q[i] то он это дело меняет на *(q+i) а эта хрень уже имеет абсолютно
валидное занчение в рамках типа пеерменной q


еще важный момент про стремный  синтаксис  char *q[] а аргументе функции. почему
от нас комилиятор не требует указания массива. а потому что какое бы мы там число не 
написали это неважно. потому что как я уже скзаал наша переменная тип=массив будет 
заменена на поинтер на первый эдемент массива пэтому размер массива никакго значения не 
имеет. поэтому у нас в скобке и не ставится ниакое число. ровно по этойже логике
у нас будет верна и вот эта хрент

    int func2( char q[] )

у нас q это массив и поэтому этот портотип будет прозрачно заменен на 

    int func2( char *q )

и поэтому какой размер у массива неимет никакго значения. это никак не влияет на поинтер
на первый элемент этого массива. вот такие приколы.

я хочу вернуться к тому что сказал чуть выше.
если у нас есть переменная q тип поинтер то если мы для нее  напишем вот такую хрень
q[1] которая вооще то имеет место для переменных тип массив то никаого противорчеия окзвыается
нет потому что компиляторр автоматом преоабразует эту лабуду в *(q+1) а это уже коретктный
стадантртный метод работы с поинтерами.
так вот я рассатриваю тперь обратую ситцию . 
у меня есть перменая vasya которая не поинтер а которая массив. а массив это не поинтер.

 char vasya[10]   = "123456789" ;
  printf ("%c \n", vasya[1]);
  printf ("%c \n", *(vasya+1) );

во второй строке  я юзаю стаднный метод рабоыс массивом через vasya[1] а в следущей строке
я юзаю вроде как хрень  *(vasya+1) потому что смотря на эту штуку получается что якобы
vasya это поинтер. а vasya это непоинтер. почему же нет ошибки? а потому что все опятьже
работает так что комилтор кода видит имя vasya то он меняет эту штуку прозрачно на поинтер
на первый элмент массива vasya и у нас вместо 

  printf ("%c \n", *(vasya+1) );

по факту будет замена на такое

  printf ("%c \n", *(&(vasya[0])+1) );

или можно вот так

  char *q = &(vasya[0]);
  printf ("%c \n", *(q+1) );

и тогда это имеет полный смысл. 
по мне это какйото трындец что себе позволяет компилятор. вначале они вводя типы а потом
они на них срут. потстоянно.

но зато теперь стало понятно что 
вот такая строчка

    int  main(int argc, char *argv[])

на самом деле это вот такая строчка

  int  main(int argc, char **argv) 

и что далее с пееременной argv можно работать в любом из двух видов
либо через 

   *(arv+1)

либо через

   argv[1]

и оба способа будут работать
потому что компилятор если видит argv[1] то он его сразу преобразует в *(arv+1)
поэтому ниаккких противоречий и проблем

ну и также стало понятно что имена argc и argv использовать необязательно. что 
точно также можно юзать любые другие например

  int  main(int p, char **q) 

потому что меня имена argc и argv выбешивают.

в чем разница в массива одинакового размера

  char vasya[20];
  int  petya[5];

вот эти два массива имеют одинактвый размер. в чем их разница? 
массив это как блочное устройство. и тип или размер элемента это размер блока.
и получается какой тип массива выбрать зависит от того насколько мелкий элемент нам нужен.
нужен ли нам элемент 1 байт или 4 байт. массив это группа однотипных переменных. 
и тип массива надо выбирать в зависиомсти от того куском какого размера мы будем менять
контент массива. если мы будем менять тело контента кусочкамми по 1 байту то нужно 
брать char. а если мы будем менять тело мссива кусочками по 4 байта то int.
напримре если у нас есть фраза. и мы в ней собираемся в процессе работы менять отдельные 
буквы то надо совать эту фразу в char. а если у нас массив состоит из ip адресов то нужно
создавать массив у котрого размер элемента 6 байт. если у нам данные это возраст людей
в пределах 0-99 то нам нужно масси выбирать с типом char тоесть 1 байт. тоест ест
какойто массив данных BLOB который мы потом будем менять кусочками небольшими. и вопрос
какой размер этого кусочка. например есть дом. в нем 5 этажей. на этаже живут люди их 
число от 0 до 99. и иногда люди приезжают уезжают. и нам нуно будет в массиве редактировать
его кусочек размером 1 байта. тоест масив можно считать неким единым пирогом куском blobom.
и его надо иногда немножко редактировать. редактироват нужно неболшой кусочек. и тип массива
задает размер этого кусочка. такими кусочками можно будет редактивровать этот пирог. 
скажем массив 100 байт.  если мы хотим иногда его редактиовать кусочком размером 1 байт
тогда нужно создавать char массив. а если мы отим его кусочек редактировать кусочком
размером 4 байта то массив на теже 100 байт нужно создавать как int.
поэтому размер массива это просто сумма всех кусочков. а тип масива оотражает природу данных
массива. припроду кусочков из которых он состаовлен. поэтому если  яи
 

>>>> 
здессь я хотел уделить внимание особым массивам. они называются flexible array.
МОЯ ОСНОВНАЯ ЦЕЛЬ ОБЬЯСНИТЬ КАК ДУМАЕТ КОМПИЛЯТОР КОГДА РАБОТАЕТ С ФЛЕКС МАССИВОМ
И ЧТО НАМ НУЖНО ДУМАТЬ ВИДЯ ИМЯ ТАКОГО МАССИВА.также попутно  я обьясню о чем нужно 
думать когда я вижу в тексте что мы обьявляем создаем массив.
итак флекс массивы. 
переменная с таким типом может тоько входить в состав структа. и только быть последим
полем внем. например 


  struct struc5 {
    int a;
    char vasya[];   <=== флекс массив
  } sa6;
  

здесь я задаю сткрутктуру стркуута и одновмерменно обььявляю переменную sa6 с таким ттипом.
так вот вот эта хрень 

      char vasya[];

это и есть flexible array

потврторсю что он может быть толко последним полем струута. без структа он не может быть 
задан сам по себе голый с нуля.
что вообще значит цифра внутри скобок когда мы обьявялем массив. она значит то сколько элементов
внутри массива и в конечно итоге сколько нужно выделить компилятору в памяти под тело массива.
компилятор умножает число элементов на размер одного элемента и получает размер тела под массив
в памяти.
обычо массив создается компилятором (кодом который он порождает) путем статичского
выделения памяти. то есть тело массива суется в стек. а стек это считается статическое
выделение памяти. 
в тексте на си статическое создание массива выглядит  вот так

    int vasya[10];

чисто по шагам это будет выглядть так на момент старта процесса у нас запускается
служебный код порожденный libc это секция  _start и в этой секции будет код который 
зарезервирвует в стеке 40 байт. поэтому когда уже начнет испольняться чисто код нашего
си текста то эти адреса уже будут зарезервированы в стеке. 
если у нас пеерменная а массив это тоже перменная , точнее это тип. и его имееет переменная
vasya. так вот если тело переменной лежит в сткеке это называется статическое выделение 
памяти. так вот надо на примере обычного "статическоого" массива понять что мы должны думаь
когда видим эти строки в тексет на си. надо понимать что цифра укаазанная в скобках это 
указание компилятору сколько в конечно итоге нужно зарезервировать места под тело этой
переменной в памяти. дело в том что массив как тип в отличие от скаем int он неимеет
заранее фиксиованного размера поэтому копилятору непонятен его размер. а когда мы видим
int [10] то размер становится понятен  = 40 байт. компилятору кога мы обьявляем пееренную 
нужно прежде всего знать какого размера будет тело. именно это ему мы сообщаем через int[10].
итак int[10] это сигнал - "выдели в памяти 40 байт". итак я описал первое последствие
котоорое наступает после выполнения указанной строки. второе последсвтие состоит в том что
у нас в программе возникает новое имя переменной vasya. чеерз это имя мы можем выполнять 
разные операции с переменной. это очень важное последствие что у нас появлется имя. 
имея имя мы можем натраваить на него директиву & и узнать адрес начала где хранится тело.

   &vasya;

адреса переменых у нас хранят особый тип переменных - поинтеры. для массивов есть ососбый
тип поинтеров - поинтер на массив

  int (*p) [10] = &a;

к сожалению поинтер на массив неочень подходит для дальнейших операций. поэтому можно
найти другой поинтер - поинтер на элемент массива. делов в том что массив хитрая штука.
с одной стороны массив это целиком все тело которое он занмимает. в нашем случае 40 байт.
40 байт единого куска. единое целое. и за это тело отвечает переменная с именем vasya.
vasya это переменная тип массив и у нее тело занимает 40 байт. целиком. один кусок. глыба.
но в отличие от других типов переменных нельзя получить доступ к телу массиива (прочитать
или записать) используя имя переменной которой отвечает за массив. тоесть. вот у нас 
есть переенная int

  int b;

и мы через ее имя можем легко пполучить доступ к ее телу. мы можем например записать в это
тело число 10 

 b = 10;

для массива такое запрешещено невозможно.

  vasya = 10; // ошибка!

тоесть массив это такая ососбая переменная у которой есть тело но в это телонельзя ни
запимать ни считать используя ее имя. мы привыкли что при создании переменной у нее появлется
имя, тело. и что в тело можно писать\читать используя имя. с массивом нельзя. мы оьбявялем
массив. у него есть тело. у него есть имя. но через имя нельзя ни  писать ни чиать в его тело.
как же начать работать с телом. си предлагает другой способ. если мы напишем имя массива
то компилятор меняет имя массива на виртуальную переменную которая является поинтером
на первый элемент массива
тоесть в тексте стоит 

  vasya

а компилятор меняет это слово вот на такое

  int *temp = адрес первого элемента массива vasya

и тогда там где  в текcте где стоит имя переменной vasya он меняет его на имя переменной temp
поэтому если я хочу в своей программе создать явный поинтер на первый элемент масива я пишу
вот так
 

 int *q = vasya;

и тода компилятор меняет этот текст вот на такой

  int *temp = адрес первого элемента массива vasya
  int *q = temp;

как легко увидеь temp и q имею одинаковый тип. 
прикол тут еще в том что после того как мы создали масива vasya то компилятор автоматом
как бы создает кучу переменных которые лежат внутри тела массива. унас получается пеерменные
сидят внутри одной большой перееменной. так вот теломассива можно менять через замену тела
составляющих его маленкьких переменных. делать это можно вот так, через строчку

  int *q = vasya;

которая экивлаентна строчкам

  int *temp = адрес первого элемента массива vasya
  int *q = temp;


мы узнаем где начало массива. где адрес начала массива. а далее изменить кусок тела массива
можно вот так

  *q = 0x10;

тоесть через поинтер. тоачнее через "дереференсинг" поинтера. 
что это значит.  у нас поинтер q согласно определению узывает на переменную которая имеет тип
int тоесть 4 байта. поэтому когда мы пишем *q то для компилятора это сигнал что нужно 
считать либо записать (в завсимости от контектса) 4 байта начиная с того адреса который 
записан в поинтере. поэтому если у нас q=1234 то тогда после строки

  *q = 0x10;

у нас в памяти будет записано 4 байта вот так

 0х10 0х00 0х00 0х00

когда у нас в тексте встерчается *q это как бутто в этом месте у нас вставлено имя переменной
на которую указывает поинтер. наболее простом примере

  int a;
  int *p = &q;

теперь если мы напишем
  *p = 10;

то по своей сути 
это как бутто в тексте мы вместо *p подставили имя исходной пеерменной

  a=10;

тоесть у обычный переменной мы можем менять ее тело либо через имя это пеерменной
либо через поинтер на тело переменной

  a=10;
  *q=10;

оба способа дают одно и тоже. 
возвращаеяс к массиву и его элеменам , у элементов нет индивидуальных имен. они как 
бы есть в виде vasya[0], vasya[1], но это хуйня я к этому еще вернусь. так вот если
у нас q это поинтер на элемент массива то мы можем поменять тело элемента массива через 
поинтер 

 *q=0x10;

таикм макаром мы поменяли маленкий кусочек тела всего масива. а как поменять его другие
кусочки. мы по прежнему можем юзать наш поинтер q. если мы сделаем вот так

  q+1

то компилятор прибавит к адресу 1234 не 1 а прибавит все 4 байта тоест 

 q+1=1234+4

почему так. потому что компиляор значет что у поинтер тип int* тоесть он указывает на 
тип int который имеет 4 байта размером. тогда если мы попрсим увелчиить поинтер q на 1
то компиляоор перескочит настолько чтобы перескочить тело текущей переменной на котору
он указывает

  q=1234

   1234 1235 1236 1237 1238 ....
  |------------------|  /\
   тело текущей
   переменной

q+1=1238

поэтому если мы будем писать q+1, q+2, q+3 то каждый раз мы будем получать стартовый адрес
очередного элемента внутри массива.


вот это правило сложения для поинтера оно работает нетолько если поинтер укаызает на
элемент внури масива. оно раотает всегда. даже если у нас поинтер укзывает на просто
переенную. вот пример


  int a=10;
  int *p = &a;
  printf("адреса p=%p, p+1=%p, p+2=%p, p+3=%p \n",  p, p+1, p+2, p+3  );
  

на экране
адреса p=0xffb46bdc, p+1=0xffb46be0, p+2=0xffb46be4, p+3=0xffb46be8

четко видно что каждый адрес отличается на 4

так вот учитывая что q+i нам дает адрес очередного элемента массива мы можем
менять через поинтер тело этого элемента

 *q     = 0x10;
 *(q+1) = 0x20;
 *(q+2) = 0x30;
 *(q+3) = 0x40;


что важно в арифметике с поинтерами - если мы просим пртибавит +1 к поинтеру то компилятор
в итоге прибавит ровно столько байт каков размер типа поинтера
если char *p, то p+1 = 1234 + sizeof(char) = 1234 + 1
если int *p,  то p+1 = 1234 + sizeof(int)  = 1234 + 4
если long int *p, то p+1 = 1234 + sizeof(long int) = 1234 + 8

а если например у нас указан поинтер на массив например int (*p)[10] то p+1=1234+размер
массива  = 1234 + 10*4 = 1234 + 40

таким образом тип поинтер влияет на его поинтерную арифметику

теперь я вовзраащаюсь к массиву и поинтерам. итак елси у нас есть переенная которая имеет
тип массив и я хочу поменять тело этого массива


    int vasya[10];

то как я уже скзаал что поменяь тело этой переменной через ее имя нельзя

    vasya = 1231221; \\ ошибка!

теперь 
если я найду для этой пермеменной ее поинтер 

    int (*p)[10] = &vasya;

то поменять тело массива через дерефренесинг этого поитера тоже нельзя

  *p = 121212121221; \\ ошибка!

нельщя ни прочитать ни записать в тело маасссива ни через имя массива ни через поинтер
на массив. 

если мы прибавии +1 к поинтеру p тоесть


 p+1

то мы получим число (при условии что p=1234) 
  
  p+1  = 1234+ sizeof (массив) = 1234 + 10*4= 1234+40 

тоесть мы получим адрес ячейки памяти которая первая сразу за телом массива.  тоесть 
мы массив перескочии целиком в памяти.
так вот едснвтенный механизм который си дает для изменения тела массива это через поинтер
на его первый элемент. как только мы создали переенную типа массив то компиялтор считает 
что автоматом еще создана целая куча переенных тела которых лежат внутри тела массива
они имеют тот тип который указа в специиккации масива в данном сулчае int и вот меняя
тело каждой такой переннменной можно поменять все тело массива. по частям по кускам.
адрес первого элемнта можно найти используя форулу


   int *p  = vasya;

дословноэта формула неимеет нкиакого смысла. но разгака в том что 
как только видит такую строку то он  меняет ее на вот такие 

   int *temp = адрес первого элеентма масива vasya
   int* p = temp;

теперь коагда у нас есть поинтер не на весь массив а на элемент int то мы можем менять
все тело массива через форулы

  *p = 12;
  *(p+1) = 13;
  *(p+2) = 14;
  ...
  *(p+9)= 20;

поскольку у нас поинтер p имеет тип int то при p+1 у нас сдвиг идет на 4 байта. поэтмоу
мы гуляем внутри тела массива. замечу то что руками поменять значение по интере нельзя
насклоько я знаю то есть вот так компилятор недаст

  p = 1235;

и вот такое он тоже недаст
  *(1235) = 20;

поэтому едиснвтнный сопособ лазить в памяти через поинтеры это создать поинтер нужного
типа это нам даст нужный шаг при p+1 и  присвоить поинтеру адрес первго элемента массива
через заветную форулу

   int *p  = имя_переменной_массива;


теперь кодга я рассказал про обычный массив. про поинтеры. про то как менять содержимое 
массива через поинтеры. я вот что скажу - компилятор и программа наси никак не контролирует
залезли ли мы за границу массива или нет. тоесть вот я созадаю массив

    int vasya[2];

полчаю адрес на его первый элемент
    int *p  = vasya;

по хорошему по коректному я доллжен лазить в памяти только вот по такому диапазону

   *(p+0) = ...;
   *(p+1) = ...;

а если я сделаю

   *(p+2) = ...;

то это я уже полез по тому адресу в памяти который лежит вне тела массива. как мы помним
процессу вооще то нельзя лазить по рандомным адресам памяти. потому что для этого вначале
нужно спросить ядро об разрашеении. так вот с тчоки зрения компилятора и си ааасеблемра
они нам это не запрещают. они за этим не следят. тоесть вот такой текст с точки
зрения компилирования не выдаст ошибкуи

  
  int vasya3[2];
  int *p3  = vasya3;
   *(p+0) = 0x10;
   *(p+1) = 0x20;
   *(p+2) = 0x30;

но кода я начну выполнять программу. то как только она выполнить команду
    *(p+2) = 0x30;

я получу убивание процесса со стороны ядра и ошибку на экране

  Segmentation fault (core dumped)


потому что мы мы обратились по такому адерсу в памяти который мы у ядра до этого не попросиои
выделить нам для работты.
таким макаром я хочу подвчеркнуть то что цифра в скобках при обьявлении массива [2]
она всего лишь говрорит компилятору сколько байтов нужно выделить по тело массива. и все.
и после этого компилятор не будет бегать за нами и проверять лазиим ли мы ччерез поинтер
по телу массива или мы вылезли за его пределы. за этим уже будет следить ядро. если мы сунулись
туда куда неследует то оно грохнет нашпроцесс. а компилятор приккоипоилрвании проверяеть 
это в тексте на си небудет. лазий куда хочешь. 

значит к настяшему моменту я показал про массив у котрого заранее известен его размер.
и как его создавать в стеке тоесть статическим способом.  при желании можно зансутьу тело
массива в heap. это назвыается сздать массив динамически.
правда именно сам массив в чистом виде не получится создать в heap но можно создать структ
который в себе содержит массив. а вот уже структ можно засунуть в heap


  struct struc4 {
    int vasya5[10];
  };
  
  struct struc4 *p5 = malloc(sizeof(struct struc4) );


в первом куске я описываюьь спецификацию структа. он состоит только из одного
поля который явялется массивом. 
во втором куске я прошу в heap выделаит кусок памяти размером таким каков размер прототипа
структа . можно это сдеать и вот так

  struct struc4 {
    int vasya5[10];
  };

  int siz = sizeof(struct struc4);
  
  struct struc4 *p5 = malloc(siz );


маллок нам возвратит стартовый адрес этого куска памяти. и мы этот адрес суем в поинтер.
поирнтер у нас имеет тип struct struc4*  тоесть таким макаром мы гвоорим что наш поинер
укзаваем на тело переменой которая имеет тип struct struc4
таким образом наш поинер укзывает на обласьт памяти где лежит тело массива. а тело
массива наше лежит в heap. 

а теерь я хочу еще раз показать что компиялтор не будет следит лазиим ли мы через поинтер
исключительно в той области в котророй полжено лазить или мы лазиим во вне этой области.
во первых если  прибавлю 

  p5+1 

то компилятор прибавит не +1 а прибавит 40 байт. потому что я напонмю что при +1 
компилятор прибавляет к адресу котоырй записан в поинтере размер того типа который
указан в поинтере. у нас указан struct struc4 *, а его разамер 40 байт. 
так вот мы уже точно залезли за область данных в памяти которую запросили у ядра. 
поэтому вот такая строка 

 *(p+1) = 111;

 приведет к segmntation fault
хотя нет. компилятор нам выдаст ошибку

: error: incompatible types when assigning to type ‘struct struc4’ from type ‘int’
   48 |   *(p5+1)=10;

он нам не даст откопиилирвать. он говорит о том что доступ к телу структа через его
поинтер запрешен. ровно тажке как доступ к телу массива через его поинтер тоже запрещен.
показываю

  int k2[10];
  int (*pk2)[10] = &k2;
  *(pk2) = 10;
  
пробуем комплировать получаем ошибку
 error: assignment to expression with array type
   44 |   *(pk2) = 10;

так хорошо. поинтер на структ нам недает получить доступ к телу струкат.
создадим поинтер на первый элемент массива который лежит внутри структа
если бы у нас был просто массив 


    int vasya5[10];
то я бы получил поинтер на его первый элемент вот так
    int *p = vasya5;

так как у нас массив лежит врнутри структа 


  struct struc4 {
    int vasya5[10];
  };

  struct struc4 *p5 = malloc(sizeof(struct struc4) );

то  я получу поинтер на его первый эелмент вот так


    int *p = p5->vasya5;


я щас обьясню. если бы я создал структ статичским путем тоест вот так

  struct struc4 p6;

то имя переменной которая имеет тип массив было бы

    p6.vasya5

и тогда поинтер на первый элмент этого массива вычислялся бы вот так 

    int *p = p6.vasya5;

но так как у нас нет переменной которая отвечает за структ а у нас есть тлоько поинтер p5
который укывазвыает на тело этой переменной 

  struct struc4 *p5 = malloc(sizeof(struct struc4) );

то дереференсинг поля внутри поинтера который уаывазывает на  структуру выглядит как

    p5->vasya5

давай еще раз. если создам переменную у которой тип структ через ее имя 


  struct struc4 {
    int vasya5[10];
  };

  struct struc4 p6;

то переменная которая отвечает за массив внутри этого структа имеет вид
  
  p6.vasya5

эта переменная имеет тип массив.


но я могу создать переменную которая имеет тип структ без обьявления имени этой переменной
а через поинтер. вот так
вначале я выделаю кусок из памяти и получаю его адрес начала

  void *q = malloc(sizeof(struct struc4) );

а потом я говор компилятору о том чтобы он считал что тот кусок памяти и будет 
телом для переменной типа struc4 и что на тело той переменной будет укаызавать поинтер p5

  struct struc4 *p5 = q;

таким образом у нас создано тело для переменой. и созан поинтер который на это тело укзывает.
и мы гвоорим что этот поинтер указывает на тело переменой с типом struc4
а имени этой переменной у нас и нет. хаха. и нам на это пофиг. так вот у нас нет имени
переменной. но у нас есть ее тело. и есть поинтер на это тело. тогда имея поинтер можно
получить доступ к телу поля внутри нашего структа. так как поле у нас называется vasya
то доступ к полю через поинтер на структ выглядит как

   p5->vasya5;

это аналог *p 
тоесть вот эта хрень  p5->vasya имеет тип данных массив
тогда если я напишу вот такое

  int *p = p5->vasya5;

то компилятор заменит налету эту строку вот на такую

  int *temp = адрес первого элемента массива vasya который лежит  внутри структа
  int *p = temp;

в случае же если я бы я создавал структ через имя переменной то адрес первого элеента
внутри струата выглядел бы вот так

  int*p  = p6.vasya5;

итак я вовзрааюсь к нашему конкретнму случаю

  struct struc4 {
    int vasya5[10];
  };

  struct struc4 *p5 = malloc(sizeof(struct struc4) );
  int *p = p5->vasya5;

так вот наш массив имеет размер 40 байт. у него 10 элеметов по 4 байта. я могу обращаться
к этим элементам читать или писать через 

  *(p+9) = 0x10;

но я также могу сопокойно залупнут смещение у поинтера хоть на вот такое

  *(p+199) = 0x10;

компилятор ошибки не выдаст . он не следит вылез ли я за тело массива или нет. ему
похер. это наша задача за этим следить. есть и еще момент. у маллока я заказал 40 байт
но по факту эта libc функция кода будет у ядра просить кусок из heap то она закажет кусок
размером 135КБ чтото типа того. щас покажу

 $ strace -e brk ./336.exe
brk(NULL)                               = 0x61d5b000
brk(0x61d7c000)                         = 0x61d7c000
brk(0x61d7d000)                         = 0x61d7d000

я не очень понимаю зачем малок два раза просит расширить heap. но в итоге у
нас размер под heap выпрошен у ядра в размере 


61d7d000  - 61d5b000 = 139264  байт = 136 КБ

просто маллок сразу запрпшивает у ядра большой кусок. чтобы потом уже к ядру не обращаться.
и если нам понадобваться еще небольшой кусочек он нам выдаст этот кусочек из этого пула. 
но опять же с не будет проверять шаримся ли мы через поинтер только по той области которую
мы заказали у маллока или мы вылезли хер знает как далеко. компиляция прйодует успешно 
если мы напишем к примеру

*(p+399) = 0x10;

просто если мы вылеезем поинтером за предел 136КБ то ядро нас зарубит и скажет

   segmneation fault


таким образом цифра внутри скобок массива [10] это сигнал компилятору только лишь о том
сколько в памяти нужно выделить кусок под тело массива. и все. а далее если мы будем шарится
через поинтер за преелделы этого куска то никто за нами сточки зрения комплиятораи и си
следить не будет . это наша проблема. если мы полезем не туда то чаще всего ядра зарежет 
наш процесс. ни си ни компилятор не следит лазиим ли мы за грагицами массива или нет при
использовании поинтера который укаывзает на один из элементов массива. еще раз - если у нас
есть понтер который укызвает на эелмент массива то компилятор не контролрует лазиим лимы
с помощтью этого поинтера внутри тела массива или мы уже давно вылелзли за пределы тела массива.

также если у нас есть поинтер на массив. тоесли мы прибавим +1 к такому поинтеру то у нас 
адрес пеерскочит через тело всего массива. тоесть рамзер массива указнный в сокобочках массива
также влияет на этот перескок

  int vasya[10];
  int (*p)[10];
если мы напишем p+1 то перескоко будет на +40 байт. 

также  я хочу пояснить на счет записи элементов массива в виде

  vasya[0]
  vasya[1]
  ...

на самом деле это такой алиас для другой записи. 
представим у нас есть поинтер на первый элемент массива 

int *p = vasya;
тогда vasya[0] это алиас для записи *(p+0)
а vasya[1]     это алиас для записи *(p+1)
тоесть что кроется за записью vasya[i] - кроется то что кмопилятор дебил он под словом
vasya подразумевает поинтер на первый элемент массива vasya который он создает на лету 
прозрачно. 

   int *temp = адрес первого элемента массива vasya

а число в скобочках это смещеение доблавяемое к этому поинтеру

  vasya[i] = *(temp+i)

или

  vasya[i] = *(имя поинтера на первый элемент массива vasya + i)

поскольку внутри скобочки у нас стоит адрес i-го элемента внутри массива то 
конструкция

  *(адрес i-го элемента внутри массива)

означает получить доступ к телу той переменной адрес которой стоит внутри скобки.
поэтому vasya[0] или vasya[1] это строго говоря не имя переменной которая отвечает за элемент
внутри массива. это такой дебильный алиас со стороны компилятора на  имя поинтера на первый
элемент массива к которому прибавлено смещение и от этого взят дереференс. вот что это значит.
тоесть еще раз когда в тексте мы пишем

   vasya[1]

для компилятора это сигнал что нужно на лету сделать следующее
создать переменную поинтер на первый элемент массива vasya

   int *temp = адрес первого эдемента массива vasya

потом нужно найти смещение +1

   int *q = (temp +1)

потом нужно получит доступ к телу на который указывает этот новый поинтер

   *q = ......;

или если писать суперкоротко

  *(temp+1)

а если я напомню что "при использовании в тексте имени переменной которая имеет тип массив
то компилятор авмтоматом ее интепретирует как имя виртуальной переменной temp которая укызвает
на первый элемент массива vasya" то можно замнеить на 

  *(vasya+1)

таким образом алиас  vasya[1] компилятор заменяет на *(vasya+1) а его он заменяет на *(temp+1)
где temp это 

  int * temp = адрес первого элемента массива


таикм образом  я хотел показать что нет строго говоря такого имени переменной как

     vasya[1]

это такой дебильный алиас на  дереференс поинтера который компилятор создает сам налету
когда видит этот алиас в тексте. 
тоесть 

vasya[1] это алиас на *(temp+1) где temp это поинтер на первый элемент массива vasya

таким образом тайна дебильный имен вида vasya[i] разгадана. разясненеа.


теперь я еще раз вернусь к случаю когда мы создаем массив в составе структа и память
выделяем под этот структ а занчит имассив через malloc
ксатти замечу что при использовании malloc нужно как только на больше перменнная ненжуна
тонужно сразу возвращать обратно память через 

   free (p5);

получается как только заюзали malloс нжуно тутже в тексте как if..then дописать free
тоесть



  struct struc4 {
    int vasya5[10];
  };


  struct struc4 *p5 = malloc(sizeof(struct struc4) );  <======
   int *p = p5->vasya5;
  *(p+1)=0x10;


  free(p5);  <=======



так вот нам ничего не мешает выделить под наш структ а значит имассив кусок памяти 
гораздо больше чем нужно. например вот так


  struct struc4 *p5 = malloc(sizeof(struct struc4) +100 );  

чтобы было понятнее я вот так разобью

  void *p           = malloc(sizeof(struct struc4) +100 );
  struct struc4 *p5 = p;


мы выделяем в памяти кусок размером 40 байт +100 = 140 байт.  
и кладем адрес начала этой памяти в поинтер p.
пока что это просто кусок без всяких структов и массивов.
а потом мы копируем адрес этого куска из p в p5 и говорим чтобы коипилятор считал что 
p5 указывает не просто на непойми какой кусок а якобы на тело переменной котооаря 
имеет тип struct struc4
собираю вместе



  struct struc4 {
    int vasya5[10];
  };


  void *p           = malloc(sizeof(struct struc4) +100 );
  struct struc4 *p5 = p;

   int *p = p5->vasya5; \\ создаю поинтер на первый элемент массива 
  *(p+1)=0x10; \\ пишу значение в первый элемент массива


  free(p5); 


так вот тут важно еще раз понять то что компилятору плевать что мы выделили памяти по сути
больше чем это нужно структу. и что важно если я начну лазить поинтером гораздо дальше чем
10-ый элемент массива то компилятору тоже плевать. 

  *(p+11)=0x10; 

вот это командой я залез в ту область памяти которая лежит за пределами 10-го элемента
массиваю по сути это уже как бы 11-ый эоемент массива. нет проблем. компилятор не буде мне
кричать! эй! але! у нас массив заявлено из 10-ти элемнтов! ты что творишь? ему плевать. 
при таком размере выдленной памяти у нас по факту массив сможет всебе содержать 10+25=35 элементов. и никаких проблем. если мы создаем массив статическим путем то компилятор сам
следит сколько байт будет выделено под тело массива. если же мы создаем массив динамически
через маллок - то это уже наша вина и задача выделить праивльный кусок памяти под наш массив.



так еще момент про обычные массивы с заданным размером


  struct struc7 {
    char vasya[2];
    int b;
  } ;

  struct struc7 sa6;
  
  printf ("struc7 size = %i    \n", sizeof(sa6) );




итак у нас структ имеет два поля первое 2 байта. и второе 4 бйта. в итоге 6 байтов.
значит sa6 по идее будет 6 байтов.

на экране
struc7 size = 8 


почему 8 а не 6. дело в том что кошда мы юзаем стек для сохранения данных в памяти 
то цпу гораздо круче работает когда он лазиии в память начиная с адреса который кратен 
наприммер цифре 4. поэтому  данные в стек кладутся так чтобы они быликратны цифре 4.
поэтому наши 6 байтов в итоге будет "дополленны" нулями до билижайщего цисоа кратного к 4.
поэтому в стек будет положено не 6 а 8 байт
щас  покажу то что у нас в стеке под нашу пеерменную было выделено 8 байт.


вот программа

  struct struc7 {
    int b;
    char vasya[2];
  } ;

  struct struc7 sa6;
  
  printf ("struc7 size = %i    \n", sizeof(sa6) );

  char *p = sa6.vasya; 
  *(p+3) = 0x10;

  printf("0x%hhX   \n", *(p+3)  );
  


я малек заменил структ. я поставил int b наверх. а массив вниз.
вот этой штукой я наохожу адрес первого элемента массива

    char *p = sa6.vasya; 

а вот этой штукой я пишу 0х10 в четвертый элемент массива

   *(p+3) = 0x10;

тоесть в 8-ой байт который компилятор выделяил под мой структ из за вырваниывания.
и из за этого мой массив из двухэлементного првератился в четыерхыэлеменный.
если бы это было нетак то при попытке туда записать я бы полуичил segmntaion fault 
или типа того. а так все океф будет. и вот на экране  я вижу

  struc7 size = 8    
  0x10 

вторая строчка это я успешно считал из 8-го байта то что в него засунул.




ТЕПЕРЬ когда с обычными масивами у которых размер задан сразу на стадии компиляции
и как с ними ичто устроено и их связь с поинтерами установлена можно перейти к ФЛЕКС массивам
так вот  флекс массив он в отлиичие от обычнгого массива не бывает сам по себе он всегда
идет в составе структа

  struct struc5 {
    int a;
    char vasya[];
  } 


идет в нем последним полем. также обязателно чтобы до флекс массива было хотябы одно
одбычное поле в структе. иначе пошлет компилятор нахер.

так вот что значит для нас и компилятора если я вижу флек массив. како смысл это дебилной
пустой скобочки?
это значит что поле такое у этого структа есть. переменная которая за это поле ответчает тоже
будет. даже адрес у нее формально будет. но все таки при этом считается что данного поля 
у даннгого структа если мы создаим на основе переменную статическим спосообом копилятор не
выделит ни одного байта. потому что мы компилятору не сказали сколько байт выделять. поэтому
в памяти под это поле не будет выделено ни одного байта. хотя поле есть.и переменная отвечающая
за это поле тоже есть. так вот еще раз . раз у нас в скобках стоит ничего то если мы будем
создавать этот структ статическим путем тоесть вот так

  struct struc5 {
    int a;
    char vasya[];
  } 

  struct struc5  sa6;


то при создании sa6 компилятор в стеке выделит место только под первое поле размером  4 байта.
а под второе поле он в стеке не выделит ни одного байта. потому что мы ему компилятору так
указали. унас при этом получится дебильная ситуация такая что имя переменой у нас сущестовать
будет а тела у переменной в памяти нет. если спросить у си какой размер переенной sa6 он скажет
что 4 байта. потому что размер второго поля 0 байт. если спросить у си адрес где начинается
второе поле то он выдаст адрес. это будет адрес сразу за хвостом первого поля но по факту
это будет полная хуйня потому что при попытке записи в этот байт у нас будет segmenttion fault
показываю


  struct struc5 {
    int a;
    char vasya[];
  };

  struct struc5  sa6;

  printf("размер sa6  = %i \n", sizeof(sa6));
  printf("адрес начала  sa6.a  = %p \n", &sa6.a   );
  printf("адрес начала  sa6.vasya  = %p \n", &sa6.vasya   );


на экране
размер sa6  = 4 
адрес начала  sa6.a  = 0xfffd4708 
адрес начала  sa6.vasya  = 0xfffd470c 

тоесть хуйня в том что размер sa6 это 4 байта. первое поле начинается на  0xfffd4708  
и занимает 4 байта тоесть 
 0xfffd4708 
 0xfffd4709
 0xfffd470a
 0xfffd470b 

соотсвтенно дальше начинается второе поле. но оно же сука имеет 0 байт линной поэтому
я считаю что си должен был выдвыать что второе поле начинается с адреса чтото типа NULL
однако он на голубом глазу нам говорит что пременная которая сидит во втором поле ее тело
начианется с адерса

 0xfffd470c 

но это хуйня полная. потому что если попробую туда записать я получу segmentation fault
при попытке команды

  *(sa6.vasya) = 0x10;

я получаю segmntation fault. 
ну или вот такую хуйню

*** stack smashing detected ***: terminated
Aborted (core dumped)

таким ообразом си позвяолет парадоксандбную ситацию. он не выделяет под второе поле
ни одного байта как я и попроисил. при этом переменная второго поля в его голове сущетвует.
без тела. это же парадокс и пиздец. при этом он мне докладывает что у нее даже есть адрес.

отсюда вывод - что стркуткрутра с флекс массивом ее ненадо создавать статическим способом
ничего хорошего из этого не выйдет. она для этоого не предназначена. тело под такую 
структуру надо выделать через malloc



  struct struc5 {
    int a;
    char vasya[];
  };

  struct struc5  *sa5 = malloc(sizeof(struct struc5) + 10);



  printf("размер sa5  = %i \n", sizeof(*sa5));
  printf("адрес начала  sa5->a  = %p \n",     &(sa5->a)   );
  printf("адрес начала  sa5->vasya  = %p \n", &(sa5->vasya)   );

  *(sa5->vasya) = 0x10;



тоесть я чеез маллок выделяю кусок памяти. а потом сую адрес начала этого 
куска в поинтер sa5 а потом говорю - слушай компиолятор считай что в этом куске
и лежит тело пеерменой у которой тип  struc5
таким маккаром  я как бы сам позабоилися насклько много байтов будет выделено под тело
моего массива. вот эта херня sizeof(struct struc5) выдаст число 4. тоесть все то что указано
в поля структа кроме массива. поэтому внутри мааалок будет число 14. 4 под первое поле
и 10 под второе. 
таким образом при обябявлении флекс массива в прототипе структа я обьяняю компилятору
о том что тело под этот структ я буду создавать сам своими руками через маллок. и вот
сколько там места останется в этом куске завычетом полей с фиксированным значением вот то
все место под массив и пойдет. 
на экране я увижу

размер sa5  = 4 
адрес начала  sa5->a  = 0x621d01a0 
адрес начала  sa5->vasya  = 0x621d01a4 

тоесть начало первго поля 0x621d01a0
а через 4 байта начинется второе поле 0x621d01a4


ну и проблная запись в массив
*(sa5->vasya) = 0x10;
проходит теперь без проблем
компилятор интпретиурет запись sa5->vasya как поинтер на перый элемент массива vasya
поэтому запись идет в первый 1 байт массива. потоу что массив имеет элеенты типа char



если честно ябы мог с таким же успехом обьявить массив с фикс значением
  struct struc5 {
    int a;
    char vasya[4];
  };

  struct struc5  *sa5 = malloc(sizeof(struct struc5) + 10);


и это сработало бы абсолютрно точно также.
и запись бы сработала успешно
*(sa5->vasya) = 0x10;

потому что получается если   я обялвяю размер массива или я не оббяявяю размер 
массива по факту потом его тело будет одинаковое. 
ОДНАКО! ии подскзаал что разница есть! когда я обьвяляю размер массива то уменя
sizeof(struct struc5) покажет другое число. компиляттр учтет что массив будет как
минимум 4 элемента длинной поэтому  sizeof(struct struc5) покажет число 4+4=8. 
получаетя если я задаю размер массива в явно виде это полуается некий мимумум 
который у меня точно будет с другой стороны этот же размер байтов тогда то будет бесполезно
болтаться в хвосте + 10

фелекс эррей нам пригодрится кода позже я переду к расмотрени конкнетного структа sockaddr
потому что с ним жопец.


тут же рассатривю момент. вот у нас размер массива изначально незадан. вот у нас есть 
маллок который позводяет нам нарезать из памяти любой кусок. у меня вопрос. а можно ли 
расшририть тело массива уже поле того как я с ним поработал. ответ ну типа да. 
делется это через realloc() 
как он работает. когда мы взываем malloc() то он вызывается brk() у ядра. и запарашиывает
некий пул байтов. так вот через realloc() я запрашиваю новыый пул байтов. если в текущем
пуле у libc менеджера памяти еще есть свободные блоки то есть он смотриит может ли он просто
хвост нарастить у моего блока памяти. тогда он просто помечает у себя что вот такие то байты
уже тоже заняты. а мне возрваращает тот же самый поинтер. а если хвост нарастить до нужной
длинны не удается то он запрашивает у ядра новый кусок brk() далее он сам автоматом копирует
весь мой блок в новый блок. также он сам помечает себе что тот блок который был до этого он 
становится свободен. тоесть мне его освобождать ненужно через free() что суперудобно
а мне realloc() возвращает новый поинтер. все что нужно мне это после вызова realloc
всегда работать только с тем поинтером что он мне вернул.
теперь к примерам.

 $ cat 339.c
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <string.h>
#include <unistd.h>


int main() {


  struct struc5 {
    int a;
    char vasya[];
  };

  struct struc5  *sa5 = malloc(sizeof(struct struc5) + 10);
    if (sa5 == NULL) {
        perror("malloc failed");
        return 1;
    }

    sa5->a = 42;
    memcpy(sa5->vasya, "Hello", 6);  // Заполняем массив данными


    // Расширяем область памяти, увеличиваем массив до 
    struct struc5 *new_sa5 = realloc(sa5, sizeof(struct struc5) + 20);
    if (new_sa5 == NULL) {
        perror("realloc failed");
        return 1;
    }


  printf("адрес начала  sa5  = %p \n",     sa5   );
  printf("адрес начала  new_sa5  = %p \n", new_sa5   );



};


так как по дефолту маллок запрашивает у ядра 134КБ памяти то пэтому расшириить хвост
моей переменной нет никакого труда. поэтому он мне вернет тот же самый поинтер.
на экране я увижу

адрес начала  sa5  = 0x5c9e51a0 
адрес начала  new_sa5  = 0x5c9e51a0 

как видно поинтер остался прежним. 
но все равно вседа после вызова realloc нужно юзать тот поинтер котооый он вернул.


вот второй пример 340.c

 struct struc5 {
    int a;
    char vasya[];
  };

  struct struc5  *sa5 = malloc(sizeof(struct struc5) + 10);
    if (sa5 == NULL) {
        perror("malloc failed");
        return 1;
    }

    sa5->a = 42;
    memcpy(sa5->vasya, "Hello", 6);  // Заполняем массив данными



  struct struc5  *sa6 = malloc(sizeof(struct struc5) + 10);
    if (sa6 == NULL) {
        perror("malloc failed");
        return 1;
    }

    sa6->a = 62;
    memcpy(sa5->vasya, "GoodBye", 8);  // Заполняем массив данными


    
    // Расширяем область памяти, увеличиваем массив до 
    struct struc5 *new_sa5 = realloc(sa5, sizeof(struct struc5) + 500*1024);
    if (new_sa5 == NULL) {
        perror("realloc failed");
        //free(sa5);  // Освобождаем старую память, если realloc не удался
        return 1;
    }
    //sa5 = new_sa5;



  printf("адрес начала  sa5  = %p \n",     sa5   );
  printf("адрес начала  new_sa5  = %p \n", new_sa5   );
  printf("адрес первого поля new_sa5->a  = %i \n", new_sa5->a   );

  free(new_sa5);
  free(sa6);




здесь   я создаю sa5
потом sa6
потом расширяю sa5 так что он конечно же наежает на sa6 , поэтому
realloc в итоге копирует мой блок sa5 в новое место и вдыает мне новый поинтер в new_sa5
при этом что важно тот блок на который указывает sa5 егоненужно освобождать через free(sa5)
это сам автоматом сделаем сам realloc что суперкруто

адрес начала  sa5  = 0x5ff6e1a0 
адрес начала  new_sa5  = 0xf289f010 
адрес первого поля new_sa5->a  = 42 


все что мне осатется сделать это вместо sa5 далее использовать только new_sa5
в послене строке я проверяю что реально данные которые были в sa5 они скопироаны реаллоком
в new_sa5

ну конечно тут задница состоит в том что если завел массив. потом решил его расширить то 
мне придется посиеть и подождать пока реаллок его скопирует в новое место. а это извините
время займет.

конечно по оконачании работы нужно сделать

  free(new_sa5);
  free(sa6);

освобождат sa5 ненужно. его освободил сам realloc()

вся эта байда из за того чтобы потом поздже успешно рассмотреть стркутуру sockaddr.

итак получается что число которое стоит в квадратных скобках в массиве это лишь сигнал
для компилятора сколько места нужно выделить в памяти под тело массива. но потом болше
никто не следит лазиим ли мы внутри тела массива или лазиим вне тела массива. также размер
тела массива на основе цифры в квадратной скобке будет такой только если мы создаем массив
статическим способом. а если мы создаем массив динамическим способом (через маллок) то
размер тела массива будет уже хрен знает какой совсем необязательно такой как указан в квадрат
ных скобкам. итак если мы создаем массив статическим способом то в памяти блок под тело массива
будет выделяться заботами компилятора. и компилятор будет отталкиваться от цифры в скобке.
если же мы создаем массив динамическим способом то это уже наша забота сколько байт выделить
в памяти под тело массива. и тогда цифра в скобке неимеет никакого значения. после того как
массив так или иначе создан то поинтер который указывает на начало тела массива - на основе
него можно лазит нетлко по телу массива а и вообще хуй знает где. никто за этим не следит.
за исключением ядра который даст по шапке если мы вылезли за рамки выделенного адреного
прострастнва. 

вот например у нас массив 

   int vasya[10]; 

в данном случае мы его создаем статическим способом. это значит что мы просим компилятор
позаботится об выделении памяти под тело массива. тогда компилятор видии число [10] и int.
тогда компилятор берет стек. и в нем резервирует 40 байт. и у нас по факту тело массива занимает
ровно столько сколько мы заказали. мы заказали 40 байт под тело массива и компилятор организовал
что в памяти под тело зарезеривровано 40 байт. все четко. однако при этом если я возьму поинтер
на первый элемент массива то я могу с его помощью лазить нетлоько по телу массива а еще и хуй 
знает куда вне тела массива. 

а вот другой пример 

  struct struc1 {
     char vasya[10];
  }

  struct struc1 *s1 = malloc (100);


это тот случай когда мы говорим компиляитору - иди нахер по поводу массива. я сам буду управлять
выделенеим в памяти блока под тело массива. и в этом случае для компилятора цифра [10] незначит
уже нихрена. потому что мы сами будем заниматься телом масива. поэтмоу компилятор уже неебет
проблема с массивом. теперь [10] это информационная цифра для нас для человека. так вот по факту
под наш массив я выделил под его тело 100 байт. это 25 элементов типа int. тоесть цифра 10 
имеет чисто рекомендальтельный характер причем не лдя компилятора а для меня. так вот по факту
я выделил под массив под его тело столько паммяти что это тело мне обазовало массив на 25 элеметов
и моя 10-ка неимеет никакого значения. и опять же почеркну что если я получу поинтер на начало
массива то с его помощью я могу лазить нетлоько в рамках тела массива я могу лазить вообще хуй
знает где и вне массива. 

таким образом цифра [10] в скобках массива имеет очень интересное значение. в одном случае
это прямо повлияет на тело массива. в другом случае не повлияет нихуя. 

теперь еще раз по поводу массивов в которых в скобках не написано нихуя ни одного числа []

  struct struc1 {
     int a;
     char vasya[];
  }


это указывает что если мы будем содавать переменную статическим спсообом 

   struct struc1 s2;

тоесть с пооомощью компилятора. статический способ создания перменменной означает то что 
мы просим компилятор чтобы он позаботился о выделении байтов в памяти под тело переменнной.
мы его просим об этом.  
так вот тогда компилятор смотрит на спецификацию типа и видит  [] и для него это аналог [0] поэтому под переменную vasya он не выделить ни одного 
байта. нихкя не выделит. и мы полуичим чудовуишуню ситуацию. имя переменной у нас будет но
тела у нее не будет. если мы статическим создадим эту перенную то толку от этого никакого.
потому что после созадания таким обраозом переенной изменить ситуацию с ее телом не получится.
у нас компилятор под переменную "a" выделит в стеке 4 байта. 
 
a =   1234  1235  1236 1237

а вот под переменную vasya он не выделит нихуя байтов. ноль. 

vasya =  0 байтов

чудовщгая ситация. у нас ест имя переменной. она существует с точки зрения компилятора. 
но тела у нее нет. что за пиздец? тело переменной это нетьемлимая часть пеерменной. 
так вот при статчиеском создании переменной мы получим фактически вот такой тип

  struct struc1 {
     int a;
  }

и когда мы создали стат образом такую переенную то изменить тело этой переменной нельзя. 
поэтому просто напросто ненадо создавать такой тип пеерменной статическим способом.
еще раз - если мы статическим споособом создаем такой тип данных

  struct struc1 {
     int a;
     char vasya[];
  }

то значит мы просим компилятор создать в памяти место под такой тип. и компилятор
смотрит на такой тип. видит [] и для компилятора это сигнал что как бутто написано [0]
и это для него сигнал что под переменную vasya надо выделить 0 байт в памяти. что он и делает.
тоесть не выделяет нихуя. и после этого с массивом vasya становится работать НЕВОЗМОЖНО.
да вот так дебильно сделано. у нас переменная vasya с типом массив будет сущестовать. но тела
у нее нет. поэтому при таком типе нужно создавать такую пеемременную только динамическим
способом. тоесть вот так

  struct struc1 *p = malloc (100);

при таком подходе мы не перекладывам на компилятор задачу под формирование тела в памяти.
мы это делаем сами. своими силами. своей головой. и мы выделаем в памяти блок 100 байт. 
и потомы мы говорим компилятору о том что вот эти 100 байт и буудут телом для перменной 
с типом struc1. при этом подходе компиляотор не проверяет а хватает ли размера тела в памяти
под специификацю типа? комилятору похеру. раз мы сами взялись выделять тело под переменную 
то эта наша задача наша проблема - много мы выделили под переменную байтов или мало. ему все
равно он не проверяет. эта наша отвественность от и до. он говорит - ты сказал что 100 байт
это тело под структ struc1 ? - хорошо. раз ты так сказал значит так и принимаем.  а хватает
ли там байт под тело или нет он не проверяет. мы могли выделить и 1 байт. и по факту его
даже не хватает под пеерменную "a" но компилятор не будет проверять. революиционный подход? да
итак при таком подходе

  struct struc1 {
     int a;
     char vasya[];
  }

  struct struc1 *p = malloc (100);


у нас будет выделено 100 байт под нашу переенную. получается первые 4 байта буудут тогда 
в итоге под перемнную "a", а остальные 96 байтов будут под пеермнную vasya. и получается массив
будет иметь по факту такое тело которое дает нам массив из 24 элементов. 

итак еще раз что значит пустая скообочка в массиве. если мы создаем этот тип статчиеским споосбом
тоесть просим создать тело для этой пееренной в памяти силамми самого компилятора - типа эй 
копилятор ты сам найди адрес в памяти старотовый. и сам вычисли сколько байт нужно выделить
под тело этой переменнной. так вот для копмилятора пустая скобочка означает что в ней стоит 0. 
и компилятор под тело массивы выделит ноль байт. и стаким массивом буедет работать невозможно.
если же мы создаем пееременннуб даинмическим способом - то есть именно програмист решает 
где в памяти и сколько байтв в штуках выделить под тело пеерменной. то тогда скобочка пустая []
имеет такой смысл что --  вот сколько байт ты выделишь под тело структа, потом мы вычтем из этого
тела тот кусок который относится к другим полям структа , в нашем конкретном случае это 4 байта.
и вот все что остаенется у этого тела оно все и пойдет на тело нашего массива. гоововрря еще 
более упорошенно и грубо в этом случае пустая скобочка для нас ознает то что  - вот сколько байтов
выделишь под тело массива столько элементов в нем и получишь. 

один из частных выводов который можно скзаать по число в скобочках в массивах [10] это то что
совсем необязатеьльно по факту тело массива будет содержат в себе то число элементов которое указано в специификации массива. да. такой прикол. 

еще пооговорим про вот такой интересный тип массива. правда статическим способом
его не задать. его можно создать только динамиесчекским способом


   int (*p)[] = malloc (12);

если мы посмрим на синтксаис поинтера то он как бы укаызвает на некую перемененную  temp
которая имеет тип массив и у котороой не указано число эелментов в массиве. едиснвтеннное
что мы знаем это то что кадый элемент этого массива это int

  int temp[];

тоест поинтер по своему синтасису как бутто указывает на массив temp размер которого 
незадан но каэждый элмент имеет тип int.
еще раз повторю что такую перменную temp создать не получится. потому что компилятор
напишет что неуказан размер массива. поэтму эта переенная она мифическая толко в нашей
голове. хотя поинтер на нее мы успешно создаддим.
в общем вот такой тип поинтера 

   int (*p)[] 

он чтаетя как поинтер на тело переменной у которой тип массив без определенного размера.
тоесть этот размер компилятору не известен. ну и в этом нет ничего такого страшного. ну 
неизвестен он компиялятору ну и что. главное что он нам известен. из того что мы видим выше
тело массива это 12 байт. значит это массив int из 4-ех элементов. тоесть нам все известено.
а почему комплятор неможет связать два плюс два хрен знает. 
на что по факту такой тип у поинтера влияет. он влияет только на то что если мы начнем
на него применяеть поинтенрную арифметику в виде

   p+1 

то компилятрор выдаст ошибку. так как он незнает размер массива а поинтер у нас фомально
укзывает на весь массив целиком то комплиятор незнает склко же байт нужно прибавит к поинтеру.
вот пример


 int (*p) [] = malloc(100);
 printf ("p+1 = %p \n", p+1);
  
мы увидим ошибку

 error: invalid use of array with unspecified bounds
   14 |  printf ("p+1 = %p \n", p+1);

но нам сосвбтвенно поинтер на весь массив и нахер то и ненужен из практики. мы из него
всего авсего сваргаим поинтер на первый элемент массива и будем спокойно с его элементами
рабоать. 

как мы превратим поинтер на весь массив на поинтер на его первый элемет? 
а вот так

 int *b = *p;

слева у нас стоит обычный поинтер на тип int. это то что надо для поинтера на первый элемент
потому что все элементы у массива int значит и первый элемент имеет тип int. значит поинтер
на него будет иметь тип int* что мы и и видим слева. 
а что мы видим справа - значит если у нас есть поинтер любого типа то если мы пишем *p 
то это означает что как бутто в этом месте мы вставляем имя той переменной на тело которой
указаывает поинтер. неважно что по факту у нашего массива нет переменной которая бы отвечала
за этот массив. это неважно. была ли такая перменная создана в явнов виде или нет. если
мы юзаем *p то в этом месте автоатом и прозрачно как бутто мы втсавиили имя этой переменной. 
поэтому справа у нас как бы стоит имя переменной тип массив. а теперь мы вспоминаем золотое
правило компилятора - если  унас гдето стоит имя переенной тип массив то компилятор это трактует
как бутто там стоит нечто другое. как бутто там стоит имя опять же виртуальной переенной которая
явялется поинтером который укывазет на первый элемент этого массива. тоесть наша стока
она вируально как бутто замеяется вот таким кодом

 int temp[];
 int *b = temp;

котрая опять же вирткльно распадется на код

 int temp[];
 int *q = адрес первого элемента в массиве temp
 int *b = q;


итак я напоминаю наш код

 int (*p) [] = malloc(100);
 int *b = *p;

и мы в поинтере b получаем адрес первого элемента массива. и тперь мы используя
поинтер b можем спокойно лазить по телу этоо массива и менять значение его элементов

 *(b+2) = 0x10;

если я хочу более компактный код то я могу отказаться от b и юзать тольк поинтер p

 *(*p+2) = 0x10;

полуичим одно и тоже.

замечу что еси в случае p+2 кмопиялтор незнает что делать и выдает ошибку. потому что чтобы
приабвит к поитеру p плюс два это компилятор должен знать сколько элементов в массиве на 
который он укывазет а это узнать невозможно то вслучае *p+2 такой проблемы нет. потомучто
это совсем другой коленкор. потомучто для компилятора формула *p означает на саоммо деле
поинтер на первый элемент массива. и так как этот поинетер на первйы элемент массива имеет
тип int то +2 в этом случае означает +2*(sizeof(int)) = +2*4= +8 байт

также я замечу то что вот такой поинтер 

 int (*p) [] =

это не поинтер на флекс массив. компоиялтор утвежает что это именноп оинтер на массив с 
незизвестной незаданной длинной. а не поинтер на флекс массив. хотя визуально мы видим
пустую скообочку. но флекс массив по определению обязатеьно должен быть частью структа.
хотя по сути я считаю что это поинтер на флекс массив. потому что унас здесь операция
 p+2 выдаст ошибку и в случае флекс массива операция p+2 тоже выдаст ошибку. там тоже
компилятор незнает какой размер умассива а значит при арифмеитике с таким поинтером он незнает
сколько байт нужно прибавлять. правда прикол в том что если я попрощу sizeof(*p) то компилятор
пошлет на фиг .скажет я не могу определить размер массива. но если я создам структ с флекс
массивом 

 struct st {
  int a;
  char vasya[];
 }

тот тут  у sizeof не будет проблем. он просто счиает что размер массива vasya равен ноль.
 я считаю что это дебилизм. что в обоих случаях надо подходит одинаково. но хуй с ним
 это маловажная особенность.


тут я еще хочу указат случай про пустую скобочку который имеет совсем другое занчение

 char cc[] = "123";
 printf ("%i   \n", sizeof(cc));

хотя слева у нас формально стоит массив с именем cc который имеет неизвестный а точнее 
незаданный с точки зрения компилятора размер но так как справа стоит значение то компиляттор
вычитывает длинну массива самостоятельно. и наша строка 

 char cc[] = "123";

на саоммом деле заменется на строку

 char cc[4] = "123";

и таким макамром мы не имеет теперь массив с незаданной длиной. а мы имеем обычный массив
с известеной заданнной изачанально длиной. так что в этом случае пустая скобочка это фикция.
путающая наебка. нет там по факту пустой скобочки.

так вот запустив такой код

 char cc[] = "123";
 printf ("%i   \n", sizeof(cc));

на экране мы увидим
 4
тоесть длина массива cc она для компилятора прекрасно задана и известна. 
что как раз таки и идоказывает что строчка с пустой скобочкой 

 char cc[] = "123";

на самомо деле заменяется на лету компилятором на строчку 

 char cc[4] = "123";




теперь поговорим про еще вот такой тип массива как массив с ноликом [0]

  int vasya[0];

опять же как ни странно си позволяет содавать такие дебильные констурции.
в данном случае массив создается статическим способом - тоесть адрес начала в памяти и 
число байтов под тело массива ищет сам компилятор. он этим всем занимается оазадачивается. 
и когда он такое видит то он считает что мы его просим чтобы тело массива занимало в памяти
ноль байтов. при таком статическом способе создания мссива оно неимеет потом никкого проаактиче
ского смысла. у нас есть имя переменной но тела у нее нет. тем не мнее компилятор нам ошибки
на такой дебилимзм не выдаст. и поменять размер тела этого масива уже после созадния невозожмно.

но такой массив имеет больше смысла при динмическом выделении тела. тоесть когда не компилятор
а человек ищет в памяти стартоввйый адрес и человек рещает сколко байт будет выдано этой переменн
ой. 

  int (*p) [0] =  malloc (12);

или можно внаале создать поинтер 
а адрес в него всунуть пожже

 int (*pp) [0];
 void *qq = malloc (12);
 pp = qq;

так вот посмтрим чему равен размер такого массива 
 printf ("%i   \n", sizeof(*pp));

на экране увидим 
 0 

по факту у нас тело массива занмиает 12 байт. но компилятор это не ебет. потому что
он опирается на спецификация типа который укаазан при обьявлении поиентера. а там мы 
указали что поинтер указыает на массив  у кторого 0 элементов. значит и тело массива
если мы его будем создавать приавльно должно иметь 0 байт. 
однако как я уже говорил кода мы тело для массива создаем сами а не силами компилятора
то эта наша забота позаботится чтобы спеицикация массива слева совдпадала с телом его справа.
в данном случае мы об этом плохо позбаотлись . пэтому у нас по факту получился массив
у котороого 3 элемета. и мы можем по этому массиву спокойно передивгваться. и менять 
его контент. 
напрмиер помеяем его третий элемент 

   *(*pp + 2) = 0x10;

можно эут запись записать чуть более красивее хотя она делает тоже самое 
это просто алиас того что написано выше

   (*pp)[2] = 0x10;

но по мне запись  *(*pp + 2) = 0x10; она более класная потому что она более точно показыает
что происходит под капотом. хотя и менее читабельная.

вобщем вот такя фигня с массивом в котором якобы ноль [0] элементов


также я хочу сказать что вот эти два пинтера это две большие разнцы

  int (*p) [10]  \\ это поинтер на массив
  int *p[10]     \\ это массив в котором элементы являются поинтерами



также еесть еще целая куча других типов поинтеров, 
например поинтер  на функцию.
Указатели на функции позволяют динамически выбирать функцию для вызова в программе.

  int (*p)(int, int);  // указатель на функцию, принимающую два int и возвращающую int

В этом случае p — указатель на функцию, которая принимает два аргумента типа int и возвращает значение типа int.

но это все уже я пока не буду рассматривать.


полезная ссылка на счет flex array
https://lwn.net/Articles/908817/



далее на счет поинтеров.

вот у нас такая штука

    char a = 0x10;
    char *p = &a;
    char **b = &p;

у нас есть просто перемнная , поинтер и поинтер на поинтер

что будет если к перменной "a" добавить 1 ? ну унас просто дбавиться единичка
тоесть
 если a=0x10 то  a+1=0x11


а что будет если p+1? p у нас указыает на тело перменной размером 1 байт. поэтому при 
увеличении поинтера


$ cat 391.c
#include <stdio.h>


int main() {

    char a = 0x10;
    char *p = &a;
    char **b = &p;
    printf("a = 0x%hhX,  a+1 = 0x%hhX  \n",      a, a+1     );
    printf("p = %p,  p+1 = %p  \n",      p, p+1     );
    printf("*p = 0x%hhX,  *p+1 = 0x%hhX  \n",      *p, *p+1     );
    printf("b = %p,  b+1 = %p  \n",      b, b+1     );
    printf("*b = %p,  *b+1 = %p  \n",      *b, *b+1     );
    printf("**b = 0x%hhX,  **b+1 = 0x%hhX  \n",      **b, **b+1     );
    



return 0;
}


вывод на экране
a = 0x10,  a+1 = 0x11  
p = 0xff984992,  p+1 = 0xff984993       // инкремент 1
*p = 0x10,  *p+1 = 0x11                 // инкремент 1
b = 0xff984994,  b+1 = 0xff984998       // инкремент 4
*b = 0xff984992,  *b+1 = 0xff984993     // инкремент 1
**b = 0x10,  **b+1 = 0x11               // инкремент 1


значит видно что p+1  имеет инкремент +1 по сравнению с p
потому что p указывает на char поэтому p+1 это адрес на следущий элемент данных 
на которые он указывает. поэтому прибавка +1

так как *p это аналог что мы вместо этой фразы вставим имя перменной на которую он укзывает
тоесть a поэтому *p+1 = a+1 поэтому прибавка +1

так как b это поинтер на поинтер то b+1 это инкретемент +4 (32 бит цпу)

так как *b это аналог p. поэтому *b+1 = p+1 а мы уже нашли что это инкремент +1

**b это аналог a поэтмоу **b+1=a+1 поэтому инкремент +1

это я к тому что я обьясняю если у нас есть хитрый поинтер и мы его прибавляем +1 то 
сколько байт  витоге будет прибавлено в реальности.

в итоге вот что важно понять
если имеем

   char **b

то

  b+1 =   инкремент 4
  *b+1 =  инкремент 1
  **b+1 = инкремент 1


тоесть b в себе содержит адрес который указыает на поинтер. размер тела переменной на которую он укаывает это 4 байта.
поэтому b+1 это адрес в памяти следюущего элемента такого же типа. тоесть если 
b=1234 то он указавает на блок адресов  1234  1235  126 1237
значит b+1=1248 тоесть начало следюущего блока такогоже типа

*b  это уже занчение той перменной на которую укзывает исходный b. тоесть это поинтер p

   char *p;
   p = *b;

поэтому *b+1 это p+1 
p в себе несет адрес который укзывает на char. значит p+1 должен в себе содержать адрес
на следубщй char тоесть тоесть тогда p+1 это +1байт

**b это само тело конечной перменной
тоесть 

   b ----> p -----> a

тоесть

  char a;
  a = **b;

поэтому **b+1 его аналог a+1  . a это у нас просто перменная поэтому a+1 это +1 байт



потсмрим на другом прмиере
  
  int **a;

  **a это тип int тоесть это просто число, значит **a + 1 это икремент +1 байта

  *a это тип поинтера на INT,  значит *a+1  это икремент +4 байт
почему +4 байта. потому что в *a содержитс адрес начала блока данных. размер блока 4 байта.
значит поинтер *a+1 должен всебе содерать адрес следующего блока int

  a это поинтер на поинтер размером 8 байт, значит a+1  это инкремент +8 байт



давай еще раз
ВОРОПРОС:
давай еще раз 
цпу 64бита

int **a;

пусть **a=0x00000010 
тогда **a+1 это 0x00000011

пусть *a=7000 тогда *a+1 это 7004

пусть a=8000 тогда a+1 это 8008

так или нетак

ОТВЕТ:
Давай разберем всё ещё раз внимательно. Вот как это работает с твоими числами.

---

### 1. **`**a`**  
- Пусть **`**a = 0x00000010`**.  
- `**a` — это значение типа `int`. Если ты делаешь `**a + 1`, то это просто добавление 1 к значению `int`.  
- Значение станет `0x00000011`.  

✅ Это правильно.  

---

### 2. **`*a`**  
- Пусть **`*a = 7000`**.  
- `*a` — это указатель на `int`.  
- Если ты делаешь `*a + 1`, то добавляется **размер одного элемента типа `int`**.  
- На 64-битной системе размер `int` обычно 4 байта. Значит, новое значение указателя будет:  
  **`7000 + 4 = 7004`.**

✅ Это правильно.  

---

### 3. **`a`**  
- Пусть **`a = 8000`**.  
- `a` — это указатель на указатель (`int **`).  
- Если ты делаешь `a + 1`, то добавляется **размер одного элемента типа `int *`**.  
- На 64-битной системе размер указателя (`int *`) равен 8 байтам. Значит, новое значение указателя будет:  
  **`8000 + 8 = 8008`.**

✅ Это тоже правильно.

---

### Итог:  
- **`**a + 1` → `0x00000011`** (добавили 1 к значению `int`).  
- **`*a + 1` → `7004`** (добавили 4 байта, так как это указатель на `int`).  
- **`a + 1` → `8008`** (добавили 8 байт, так как это указатель на указатель).

Ты всё рассчитал правильно! 😊





<<<<>>>>



