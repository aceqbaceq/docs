| terminal
| pty
| line discipline

 

 я щас хочу описать очень тонкую вещь.  я оней прочитал 
 на стек оверфлоу.


 вот у нас типичная ситцауия с терминалом



черное граф окно --- ядро X11 драйвер --- (socket)xterm(ptmx) ---- ядро line discipline------(pts/10)bash


тоесть xterm он породил граф окно в X11 системе. а граф окном 
управляет ядро. и xterm получает от черного окна инфораацию 
через сокет который он открыл. если в черном окне мы тыкаем клавишу
то она летит в ядро вдрайвер X11 и ядро ее шлет через сокет в xterm

а через ptmx xterm держит связь с башем . между ptmx xterm 
и pts/10 bash сидит ядро с своим кодом "discipline line" который собс
твенно всю логику работы терминала и выполняет. так вот 
что здесь важно понять и увидеть.

человек выдяеляет мышкой черное граф окно и тыкает кнопку на клаве.
кнопка из окна попадает в ядро  в x11 драйвер. ядро эту кнопку
шлет в сокет xterm таким макамро кнопка оказалась внутри xterm
процесса . (байт кнопки). круто. xterm получив эту кпнопку через сокет
он ВНИМАНИЕ ее мгновенно пересылает в ptmx . МГНОВЕННО! это важно.
эта кнопка влетает в ядро в код "line discipline"
а дальше происходит ОЧЕНЬ ВАЖНАЯ ВЕЩЬ - в зависимости от того как
настроили настройки этой "line discipline" как xterm 
так и процесс на той стороне в данном случае bash то код в ядре
"line discipline" он может поступить ТРЕМЯ разными способами!
     1) он может байт кнопки НИХРЕНА дальше не пропустить! вау!
     зато вместо этого "line discipline код" мгновенно ОБРАТНО в
     через ptmx в xterm шлет такой же байт!
     и получается для xterm все выглядит так что он послал 
     байт в приложение которое сидит за ptmx и он якобы сразу
     прислало ответ! хотя ответ по факту прислал не баш!!!
     а прислало ядро!! охренеть! и xterm то что он получил мгнвоенно
     переселыает в сокет чтобы это нам X11 нарисовало на экране!!
     поэтому мы нажав на кнопку с буквой на клаве видим тут же 
     эту букву на экране! это назвыается в терминах терминала как 
     "echo" эффект. но согласист как же хитро! как мерзко !
     как по гнидски устроена эта схема!!!! 
     а баш как я скзаал при всем при этом нихрена еще ничего не 
     получил!!!! line discipline может быть настроен так 
     что он будет копить все символы которые ему xterm шлет 
     до тех пор пока из черного экрана не прилетит к примеру
     с клавы символ кнопки Enter.  ИВОТ ТОГДА НАКОНЕЦ line discipline
     отошлет уже весь массив всех кнопок в баш!!!!
     это все можно легко проверить если в xterm запусить команду 
     	$ cat -
     и как это будет выглядеть. мы будем наимать на кнопки и они 
     будут сразу появлятся на экране при кажом нашем нажатии. 
     а потом мы нажмем Enter и на экране появится дубликат той
     строки которую мы набрали по буквам. дубликат появится только 
     после тго как мы нажали Enter, не ранее! так вот пиздец это как
     работает как  я описал выше. когда мы тыкаем буквы то они 
     с черного экрана ядром через сокет посылаются в xterm  и он
     их мнгнвоенно пеерслывает в ptmx и они попадают в ядро
     в line discpline код ядра. и он в cat нихрена ничего не шлет!
     зато он сразу каждую полченную бувкву шлет обратно в ptmx
     к xterm процесу и он монвоенно это перелывает в сокет оттдуа
     оно подает в ядро в X11 драйвер и драйвер рисует в черном
     окне наэкране букву. а cat при этом нихрена не получает! он
     на голодоом пайвке! и тоько окгда мы тыкнем Enter и егополучит
     line discpline ТОЛЬЛКО ТОГДА наконец line discilie
     перешлет весь набор набитых до этого символов в cat через
     pts/10 файл! и тогда cat получив наконец то что ему прислали
     он мгвновенно высирает это в stdout который тоже смотрит  в 
     pts/10 оно обратно влетает в ядро в line discipline и тут
     конечно line disline настроен так что та инфо что влетает 
     в line discpine со стороны pts/10 он мгновенно шлет в ptmx
     (ксати я не знаю всегда ли это так. может там тоже можно
     настроить line discpl что оно то что прилетает со стороны pts/10
     тоже собирает в кучку и ждет enter. не проверял не знаю.).
     из ptmx он поступутат  в xterm . оно это имеетя ввиду то что
     послал cat то есть срочка целиком. и он то что получил опять
     же не лукавя шлет в сокет. это летит в яро. ядро через x11
     рисует на экране. вот такая очень хитрая схема. получается
     и в ту стороу все хитро работает и вобратру стоорону тоже. 
     то что мы ыткаем в черном окне на клаве оно не факт что должает
     то процесса конечного. а то что рисуется на экране оно 
     не факт чтоприетело от того процесса коенчного. оно могло
     прилететь и от кода ядра line discipline.  и это пиздец!
     поленейший!

    получается также что эта вся схема так устроена что из за 
    того что мы нажали кнопку и логично ожидаем что она тут же 
    отрисуется на экране (как буто кнопки и экран это одно и тоже
    неразрываное существо) а это нихуя нетак. то что мы тыкаем
    кнопки для этой системы нипель это одно. а рисование
    на экране терминала это совсем другое.  и чтобы нажатая кнопка
    рсиовалась на экране это вот надо еще постараться!

 я бы сказал что классический железный терминал в этой схеме
 эмулирует черное граф окно + ядро с его x11 драйвером + xterm
 процесс. вот это все работает в точности как железный терминал.
 line discipine она как была раньше при подключенном реальном
 желеном терминале так она и осталоась в этой цепоечке.
 тоесть раньше схема была такая

желез терминал ---------- (com) ядро, line discipine ------ (/dev/tty2)bash  процесс

так было раньше.

хотя я вот думал что то что на жел терминале рисуется сразу символ
после нажатия клавы это настройка самого терминала. а вроде как 
оказалось что нет.
также я думал что редактирование символов это хрень была реальзована
внутри термиала в некотором его внутреннем буфере. а это якобы согласно
стекофверфлоу тоже окаазалось неправда. символы сидят в linediscipine
и он служит буфером для редактирования. скажем мы щлем с клавы
терминала символ "backspace" и linediscpine в своем буфере удаляет
последний символ справа который там сидит. и паралельно шлет 
обратно на терминал такойже байт. а терминал уже у себя на 
экране тоже стирает этот символ. вот такая пиздец схема!

2) вторая схема работы состоит в том что line displine так настороен 
что если в нее с черного экрана с xterm процесса c ptmx 
прилетает символ то line discpine мгнвоенно его передает дальше
незадерживая его в своих кишках! так работает лайн дисциплин 
когда у нас конечнм прцессом запущен баш! он когда старутет он 
шлет кучу ioctl сисколлов через pts/10 в line discpline. он ее
программирует. и он ей задает такой режим! поэтму когда мы 
нажали кнопку в черном окне она мгвноенно доолетает до баша!
также я подохрвеваю что баш отклчает на лайн дисциплин режим echo.
тоесть когда символ пролеаеет через лайн дисциплин от ptmx 
в сторону pts/10 то лайн дисицплин автоатом обратно этот символ
я думаю не шлет. зато баш когдп получает символ он сам шлет
обратно этот символ. вот кто причина букв на экране после
нажатия клавиши. не лайн дисциплин а сам баш! 

3) третий режим работы такой что мы настрвиаем лайн дисциплин 
и он накаливает буквы летящие в него от ptmx и не отслывает
их в конечное приложение пока не получит символ Enter но
он также и не послывает обратно эти символы! и поэтму нажимая
кнопки на клаве мы небудем видеть ничего на экране! такйой
режим лайн дисцлпин тоже возможен!
например такая хрент может быть полезна при вводе пароля. 
мы вводим пароль но на экране чисто. скажем условно баш может 
перед вводом пароля через ioctl программировать лайн дисцлиплин
на такое поведение. или любой процесс вметсо баша который запущен 
натой стороне.  если запусить баш с strace то можно увидеть 
сколкьо много постоянно ioctl делает баш ососбенно если он 
собирается запустиь левый бинарник через execve. он для него
подготваливает лайн дисицплин. и потом обратно когда левый бинарник
вышел и баш обратно попдает в foreground группу и собатеся продолжать
раобтать с терминалом то баш обратно восстанвлвиет через ioctl 
насторойки лайн дисцплин "под себя" как башу это удобно!

в целом это полная жесть как элементарная хрень реализована
так сложно!! и я бы скаазал дебильно!! всего то навсего надо 
чтобы кнопки летали с клавы на удаленное приожение и чтобы
на экране рисовались эти кнопки. как же сложно они все это
сдеали! мир динозавров деревынных игрушек и запорожцев







