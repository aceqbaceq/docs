новое описание про так называемый терминал
в линуксе.

значит как процесс в линуксе работает  с файлом с диска. процесс его открывает


  open ("/tmp/1.txt")

получает от ядра номер деспритора  15

и потом из него читает и пишет

     read(15,...)
     write(15,...)


но ровно по такой же схеме процесс может писать не  файл на диске а внутрь какойто 
железки. например внуьрь приентера

  open( "/dev/lp0")

  write(15,....)



была раньше такая железка - терминал. это была хрень как ноутбук тоесть склеенный экран 
и клава, только внутри этой железки не было ни проца ни памяти. это тупо был склеенный 
в одно цело блок из клавы и экрана. и у него был провод через который эта железка опдключа
лась к компу.  вот на современном системном блоке есть отдельная дырка под клаву и отдельная 
дырка под монитор. а тогда эти две железки были склеены и к компу они подкючались через единую
дырку. в ноутбуке щас клава и монитор и вовсе приклеены к корпусу. далее такой момент
современная клава имеет драйвер  в ядре а вот драйвера монитора в ядре я так понимаю нет. 
есть драйвер видеокарты а монитор вроде как получается уже част видеокарты. есть драйрвер
видеокарты. но драйер это хрень которая нужна ядру чтобы взаимодестовать с железкой. а как
получить доступ к клаве или монитору из юзерспейса. ядро  создает виртальные файлы 
например /dev/input/event12  у меня это тачпад


          $ sudo libinput list-devices


Device:           Elan Touchpad
Kernel:           /dev/input/event12
Group:            9
Seat:             seat0, default
Size:             104x68mm
Capabilities:     pointer gesture
Tap-to-click:     disabled
Tap-and-drag:     enabled
Tap drag lock:    disabled
Left-handed:      disabled
Nat.scrolling:    disabled
Middle emulation: disabled
Calibration:      n/a
Scroll methods:   *two-finger edge 
Click methods:    *button-areas clickfinger 
Disable-w-typing: enabled
Disable-w-trackpointing: enabled
Accel profiles:   flat *adaptive custom
Rotation:         n/a


и мы можем обратиться к железке из юзерспейса. точнее юзер процесс поросит ядро считать
байты якобы из просто файла /dev/input/12 а на самом деле ядро читает байты из ядра железки
и кладет эти байты в память процесса. 

насколько я знаю такого вот спец файла по доступу на монитор нет

самому ядру эти спец файлы ненужны. эти спец файлы ядро предоставляет в юзер спейс чтобы
юзер программа могла якобы просто читая "обыкновенные файлы" по факту через ядро могла 
полазить внутри железки. 


итак этот терминал (монитор плюс клава склеенные в  один ящик в котором больше ничего не
было ни проца ни памяти нихуя)  присоединялся к корпусу мейнфрейма через провод. современная
аналогия это сист блок в который втыкается просто клава и просто монитор только не через две 
отельные дырки а через одну. 

ядро детектило это железо. и  ядре начинал работать драйвер этого железа - "драйвер терминала".
далее человек тыкает на клаве кнопку. терминал шлет эту инфо сразу в сист блок. драйвер
терминала перехватывает этот байт и он этот байт там залипает. и лежит в ядре. тоесть 
мы на кнопку нажали и тту же эта инфо удетела внутрь сист блока. но дальше ядра этот байт не
улетел. человек еще тыкнул кнопку , эту инфо терминал сразу переал внутрь сист блока. там
драйвер терминала это  поймал и держит в своих кишках. при этом важно то что клавиуатура 
и монитор в железке терминал это как бы две незавимые железки и это дает то что  если мы 
нажали кнопку на клаве то ее задача передать эту инфо внутрь сстемного блока НО! - это совсем
не значит что на второй железке монитор должна тут же нариосваться буква! нет! если мы нажали
кнопку то это всего навсего приводит к тому что это нажатие улетает в сист блок! задача чтото
там нарписовать на моиторе это совершенно отдельная независимая задача! ни терминал в целом
ни клава не занимается задачей наросвывания буквы на экране если мы нажали кнопку! когда
драйер терминала ловил прилетевший байт то драйвер терминала посылает обратно на терминал
особую команду на монитор и на мониторе повялется буква! это в драйвере терминала назвыается
"функция эхо".  если драйвер терминала в ядре не пошлет сам обратно смец команду то на мониторе
терминала нихрена не будет гореть ничего! сколько бы мы кнопок на клаве термина ни нажали!
итак мы нажали кнопку на теоминале. клава на терминале тутже отрпавила эту кнопку в сист
блок. там ее поймал драйвер терминала в ядре и поймал и держит. и если на драйвере терминала 
включено функция "эхо" то драйвер терминала обратно по пвроду щлет спец команду на моитоор
и на мониторе загорается буква! мы продолжает тыкать кнопки на клаве термианла. она это пердает
в сист блок. дарйвер терминала ловит эти буквы и складывает в своей памяти в кучку. и посылает
обратно на монитоо терминала команды и на мониторе загораются новые буквы. если мы на клаве
наимаем "backspace" то кнопка прилетает в ядро в дарвер терминала и он тогда сттирает в памяти 
в своем буфере последний символ и также драйвер терминала шлет спец команду обратно на терминал
и на мониторе стирается последний символ. таким образом "редактиврование" текста идет не силами
терминала а силами драйвера терминала в ядре в сист блоке. текст набранный хранится и лежит
в буфере памяти в ядре в драйвере терминала а не в желещке терминал. ровно также как это ест
в слуачае компа с сист блоком - набранный текст не хранится ни в клаве ни в нутри монитора
он хранится в ядре! и вот мы уже натыкали цедлую гору букв , они  светятся у нас на экране 
пусть это будет целых 10 букв

     ехал грека через реку

но при этом данные буквы еще так и не поаали внутрь памяти никакого процесса! пока это все 
в ядре! 
если в драйвере термиала выключена функция эха то мы набили текст на клаве. он лежит в ядре
но на мониторе ни хрена не будет светится ничего! 

потом мы наконце тыкаем Enter! и только тогда ядро из внутреннего буфера драйвера терминала
записывает все эти буквы в файл /dev/tty2 !  для простыт понимания можно считать что этот 
файл как бутто прям файл на диске. хотя его нет ни на каком диске это тоже хрень внутри ядра.
но! разница в том что буфер драйврера терминала который в ядре он вообще не доступен для 
юзер процесса а  файл /dev/tty2 он хоть физически лежит в ядре но эта структура уже доступна
для доступа для юзер процесса! и вот когда ядро записало буквы в файл /dev/tty2 то их можно
наконец считать внутрь юзер процесса. проецсс для этого должен заюзать команды

   open("/dev/tty2")
   read(15,&buf,100)

и ядро возьмем байты из файла /dev/tty2 и запшет их в память процесса по адресу &buf
дело в том что хотя файл /dev/tty2 виртуальный но у юзер процессов нет прямрго доступа
внутрь никких файлов ни физ ни вируальных. туда может лазить непосдрественно только ядро.
а юзер  прцоесс может лишь получать отттуда байты только через посредничество ядра.

таким образом нам открывется поразтельная вещь мы тыкаем кнопки на клаве терминала на экране
тут же вспыхивают буквы ( при условии что функция эхо в драйвере терминала актививрована)
и у нас возникает чуство о том что клавиатура посылает байты на экран с одной стороны а 
с другой стороы что посланные буквы как тоько они появились на экране то они уже лежат внутри
юзер процесса. оба этих ощущения абсолютно неверны! это наебка интуиции. 
по факту все что делает клава она шлет буквы в ядро сист блока. буквы на монитре рисует ядро.
и ни одна буква еще не попала внутрь юзер процесса! у нас на экране уже гора тексат но 
внутри юзер проецсса нет еще нихрена. юзер процесс еще даже не подозревает что мы набрали
кучу текса и что он лежит внутри ядра! вот такая вот наебка интуииции. мы нажимаем backspace
у нас на экране стирается последний символ. нам кажется что backspace долетел до юзер процесса
и он стер у себя в памяти последний символ а потом отрисовал эту стацию у нас на мониторе.
это тоже наебка интуиции. на саоммо делео бекспейс прилетел в драйрвер терминала. он поймал
эту кнопку. стер послдений символ в своем буфере памяти. потом послал нужный сигнал на монитор
и там тоже это стерлось. а внутри юзер процесса как небыло нихрена так и нет!!!!
а вот наконец когда мы нажали Enter  - то драйвер терминала поймал эту кнопку и наконец то 
он запиыввает все буквы что у него лежат в его буфере в файл /dev/tty2 !  и если юзер 
процесс сейчас попросит ядро  записать то что лежиь в файле /dev/tty2 внутрь памяти процесса
то наши буквы наконец то попадут внутрь юзер процесса!!! охренеть.  важно понимать что 
буфер драйвера терминала недоступен для юзер процесса никак. и именно туда прилетают кнопки
посланные с клавы терминала. там они лежат и хранятся. а вот файл /dev/tty2 он  вообще то 
говорят тоже недотупен для юзер процесса (потому что прямой доступ к любому файлу для юзер 
процессов запрещен) но процессс может попросит ядро залезть в этот файл прочитать что там лежит
и положить что там лежит в обласьт памяти процесса. когда мы на клаве нажимаем enter 
и эта конопка прилетает в драйвер терминала то это служит ему сигналом что нужно все что в буфере
наконец то переписать  в файл /dev/tty2 и  посланные кнопки наконецто станвится доступными
для юзер приложения. поэтому может быть очень большой перерыв между тем временем когда мы натыкали
кнопок и то время когда они реально попали внутрь юзер процесса! а нам будет кааться что все
что мы натыкали уже давно крутится внутри юзер приложения. и оно их обрабатвыает. это охуенное
наебалоов в архитектура терминала. также прикол файла /dev/tty2 состоит в том что вот положиим
ядро туда записало сколько то байтов. потом юзер процесс читает эти байты из этого файла. 
что было бы если бы /dev/tty2 был бы "обычным" файлом диска если бы мы повтрорно запросили
чтение из него? было бы то что мы бы эти байты прочитали бы успено снова. но /dev/tty2 необычный
файл. если мы из него чтото прочитали то эти данные оттуда сразу стиарются его размер уменьшается.
если мы из него прочитали все байты то его размер становится равен ноль! и если повторно с него
пытаться читаь то  в ответ мы полчим фигу! в этом его разлиичие с обычным файлом!
теперь вопрос а как юзер процессу узнать когда в /dev/tty2 прибудут байты? вот он пустой.
мы в юзер процессе открываем файл /dev/tty2

  open ("/dev/tty2")

получаем имя дескпртора 0 или 15 неаважно

далее мы просим ядро прочитать что там лежит и записть это в память нашего процеса 
по адресу &buff1

  read(0, &buf,...) 

ядро лезет туда читать а там пусто. что тогда будет . будет два варианта - если мы открыли
/dev/tty2 файл без укаания спец флагов  а потом запустили read()
то у нас же по факту любой сисколл выполняет ядро а не юзер спейс код. тоесть мы запускаем

  read(0, &buf,12) 

ксатти мы указыаем чтобы прочитаь из файла 12 байт. роовно 12 байт и немеьше

по факту проц перекобчатся из юзер режиме в ядро режим. запусется код ядра котоырй обслужиает
этот read() и ядро смотрит в файл /dev/tty2 видит что там нетолько 12 байт нет а там вобще
нихрена нет. тогда ядро как говорят "блокирует" процесс. тоесть исполение кода процесса останав
ливатся. код процесса исключается из очереди на выполенение шедулера. тоест наша програамма
застывает на команде 

  read(0, &buf,12) 

и дальше ничего не происходит до тех пор пока в файле /dev/tty2 не появится 12 заказанным байтов.
вот толко когда там повяится 12 байтов то ядро их оттуда читает. потому оно копирет эти байты
в юзер процесс в его память по адрему &buf1, также ядро стирает эти 12 байтов из файла /dev/tty2
и только тогда просходит "вовзрат" из read() и начинает исполняться следующая команда в юзер
процессе по списку. если же мы про  открытии файла укзаазали флаг 

     open("/dev/tty2",O_NONBLOCK)

а начали читаь из файла. то ядро увидит что  в файле нихрена нет но не станет блокировать 
процесс а просто сразу верентся из команды read() и сообщит через errno = EAGAIN
это будет для прцоесса значить что в файле нихрена нет. и код процесса начнет исполнятсяся
со следующей команды. и процессу нужно будет самомму подождать какоето время и повторно
запусти команду

  read(0, &buf,12) 


и первый и второй подход  гавно. в первом слуучае наша программа засытвыает а мола бы делать
чтото поледное. во втором случае мы вслеую должны тыукаться и делать повторный read() надеясь
что в файл наконец то чтото прилетело. 

поэтому есть третий путь использовать select() 
мы отркыаем файл

  open("dev/tty2")

пполучаем дескприптор 0

далее запускаем 

 select (...) в котором указыаем этот десрпитор 0 

при этом у нас процесс блокируется или засыпает. это на самом деле аналогично первому подходу
тоесть код программы больше не выполняется. далее ядро следит кода же на файл на котоырй укзыает
дескпритор 0 получит какието данные  и кога это прооисходит то ядро возвращает жизнь процессу
возвращается из select() и сообщает что в файл с дескприрром  0 чтот прилетело. 
в сущносити использование select() аналогично первому методу. плюс его в том что мы можем 
через select() монииторить сразу кучу файлов . причем мы еще можем и указат какие файлы нужно
мониторить на факт того что  в них чтот прилетело. а какие файлы можно мониторить на факт
того что в них можно наконец чтото записать.  сразу скажу что slect() имеет смысл монитоорть 
только спец файлы. такие которые  сдуваются до нуля если из них считать из контент, или 
такие в которые нельзя писать одноврменно из нескльких процессов. если натрвливать sleect()
на обычные файлы на диске то с точки рения селект такие фалы всегда готовы и на чтение и на 
запись и он будет возвращаеться мгвноевнно.  описаие как работатет селескт смотрит  в тексте
select.txt !

так вот возвращается к нашему /dev/tty2
если мы сделали вот так

  open("dev/tty2")
  select ( ... )

то наш процесс будет спать. но как только драйвер термиала сбросит буквы из своего внутреннего
буфера в /dev/tty2 то ядро мгнвоенно разбудить наш юзер прцоесс и сообщит ему об этом! и процесс
сразу сможет прочитаьт из файла контент!

если мы сидя за терминалом хотим "общаться"  скакойто юзер программой вглубине кишок 
систмного блока то  юзер программа должна быт так настроена что она должна открыть со своей
стороны файл /dev/tty2

потому что вот мы вкючили в пиитание наш термиал. он зажгся. ядро задетектило что появлось
новое устроустов. ядро активирует дарйвер терминала в своей памяти.  мы начинаем тыкать кнопки
на клаве. они летят внутрь ядра драйврера терминала. он в ответ шлте комадыы на монитор
мы видим как загорются на мониторе буквы. все классно. 
потомы ммы тыкаем enter - драйер терминала переслыает данные из своего внутреннего буфера
в файл /dev/tt2 .классно. но что дальше? если ни один юзер процесс на системном блоке 
не прочитает из /dev/tty2 то  никакого толка от набаранных нами букв нет! ну переслали мы их в
ядро. ну ядро отрислваоло их на мониоре. ну  перелетели они в файл /dev/tty2 ну что? все
финита.  поэтому раньше да и сейчас было так. вот мы вклчили терминал. ядро его задетеклтило.
и ядро автоматом создает процесс. хотя скорей всего не ядро за этим следит а init процесс. 
не столь важно. скорей всего вообще вот как - после загрузки ядра процесс init заранее
сам запускает  процесс , окрывает  файл /dev/tty2 и в рамках этого процесса запускает 
через execve() бинарник программы agetty
вот как это выглядит

 $ ꉙ  $ pstree -Aspt 2838009
systemd(1)---agetty(2838009)


$ sudo lsof -Pn -p 2838009  2>/dev/null | tail -n 5
agetty  2838009 root   0u      CHR    4,2      0t0        21 /dev/tty2
agetty  2838009 root   1u      CHR    4,2      0t0        21 /dev/tty2
agetty  2838009 root   2u      CHR    4,2      0t0        21 /dev/tty2
agetty  2838009 root   3r      DIR   0,87       40         1 /run/credentials/getty@tty2.service
agetty  2838009 root   5r  a_inode   0,16        0      3117 inotify

здесь нам важно что что agetty открыл /dev/tty2
и вот чем занят agetty

$ sudo strace -p 2838009
strace: Process 2838009 attached
pselect6(6, [0 5], NULL, NULL, NULL, NULL

видно что он спит и попросил ядро чтобы оно его разбудило когда на файл на который
указем десерпитор с именем 0 придут данные. тоесть когда на файл /dev/tty2 чтото при
летит из ядра!

к систем блоку моет подключено неколько терминалов. ядро их както различает. видимо по номеру
дырки в которуб воткнуть дата кабель от терминала. и если чтото прилетаит оттерминала2 в ядро
и будет нажат enter то ядро драйер терминала это будет всегда скидывать в файл /dev/tty2
а все что прилетиит от термиала3 ядро будет скиывать в /dev/tty3
таким образом если мы хотим поймать что будет послано из терминала2 то нам нужно вегда ловить
это в файле /dev/tty2
неважно что щас терминал2 выключен.
мы можем запусти юзер процесс. открыть файл /dev/tty2 и заснуть. а ядро попросить что если
чтото наконец прилетит на /dev/tty2 чтобы оно нас разбулило! во как

важный момент. мы сидя в нашей юзер программе можем через ядро менять настройки на железке 
терминал. мы можем ею управлять! делается это через ioctl()
если у нас файл декпритор который ведет на tty2 это 0 то вот пример

ioctl(0, TIOCGWINSZ, {ws_row=39, ws_col=158, ws_xpixel=0, ws_ypixel=0}) = 0

тоесть мы указвыаем 0 для адра обьясняя какой терминал ему нужно подкрутить. тоесть 
мы используем 0 только для того чтобы обяснить ядру "имя" того ттерминала который ядру нужно
подкрутить. сам файл /dev/tty2 никакого прямого отошения к процессу подкручивания неимеет.
тоесть ядро фиически подкручивает терминал через друигие файлы и каналы. 0 тоесть  /dev/tty2
используется в сисколле только чтобы  оьбяснить ядру с каким терминалом мы хотим чтобы он 
пошаманли. посколку у нас "настоящего" имени терминала у нашего процесса нет мы в качетсве
имени терминала подсталяем единственнй "идентицкатор" трминала который мы имеем в простарнсте
юзер процесса. сам же файл /dev/tty2 физичски используется только для одного чтобы процесс
мог из него забрать те данные которые прилеетли из терминала в ядро и которые ядро из своего
внутреннего буфера сбросило в этот файл для нас.

также через ioctl() юзер процесс может изменит настройки нетлоько самого терминала железки
(исользуя ядро) но изменить настройки драйвера терминала в ядре! напрмер я говорил что по дефолту
дравер терминала  перееносит байты прилеетвших кнопоок из внутренненго буфера в ядра в 
файл /dev/tty2 только когда с клавы терминала прилетит наконец кнопка Enter
так вот если у нас юзер процесс bash то он чрез ioctl() меняет эту натройку и он говорит - эй
драйвер термиинала 2 значит если к тебеприлетела кнпка то ты ее незажимай а шли мне сразу
и немедленно! также баш говорит драйрвер терминала чтобы он сам от себя эхо обратно на монитор
терминала не слал. поэтому когда мы нажимаем кнопку на клаве терминала он сразу долетает до
ядра а оттуа сразу передается на /dev/tty2 где ее уже ждет бащ. при этом ядро нешлет обратно
на монитор терминала эхо. вместо этого сам баш получив букву пишет в dev/tty2 полученную 
букву

  write(1,"Y",1)

и драйвер терминала вида что в /dev/tty2 чтото прилтело уже от приложения шлет эту букву на
мониттор термиала и она там зажигтается

поэтму юзер процесс работая с терминалом может нетолько принимать и отправлят на него буквы
но и менять нстройки работы железки терминала и менять настройки работы драйвера терминала

когда у нас пресональный компьтер с сист блоком клавой и мышкой  и линуксом то у нас 
как бы уже есть терминал подключенный к систмному блоку. и пусть линукс загружен  в тектовом
режиме. так вот линукс берет и из нашего реальнгого одного терминала создает сразу 
скажем 5 или 9 виртальных терминалов из нашего одного реального. переключаться между ними
можно через Alt+FN

итак псоел загрзуки у нас уже есть запуенный процсс который "привязан" к нашему терминалу
это agetty
мы вводим в терминале логин и пароль. это все улетает в ядро а оттуда на /dev/tty2
а оттуда это все читает agetty. если логин пароль ок. то вместо agetty запускается login 
а он запускает bash

$ pstree -Aspt 2839919
systemd(1)---login(2838009)---bash(2839919)

нехочу разбратся зачем нужен login процесс. похер. ясно что он засыпает. а на сцену выходит
процесс bash который он запустил. этот bash уже привязан к tty2 ему самому это делать ненужно.

 ] ⋘  $ lsof -Pn -p 2839919 2>/dev/null | tail -n5
bash    2839919 noroot mem    REG  254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
bash    2839919 noroot   0u   CHR    4,2      0t0        21 /dev/tty2
bash    2839919 noroot   1u   CHR    4,2      0t0        21 /dev/tty2
bash    2839919 noroot   2u   CHR    4,2      0t0        21 /dev/tty2
bash    2839919 noroot 255u   CHR    4,2      0t0        21 /dev/tty2

чем же он занят

  $ sudo strace -p 2839919
strace: Process 2839919 attached
pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}^Cstrace: Process 2839919 detached

а он получается спит. и ждет кода его ядро разбудит в том случае когда в файл на который
ведет деспритоо с именем 0 чтото прилетит что можно будет прочитаьт. тоесть он спит до тех
пор пока в /dev/tty2 ядро не сбросит буквы с терминала

вот я переключился на черный экран тектовго терминала и нажал кнопку 1
что при этом произошло

   $ sudo strace -p 2839919
strace: Process 2839919 attached
pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}) = 1 (in [0])
read(0, "1", 1)                         = 1
pselect6(1, [0], NULL, [0], {tv_sec=0, tv_nsec=0}, {sigmask=NULL, sigsetsize=8}) = 0 (Timeout)
write(2, "1", 1)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}^Cstrace: Process 2839919 detached

тоест мы нажали кнопку. клава (часть железкт терминал) послал сразу ее в ядро. 
ядро это сунуло в дравер терминала2. так как баш заранее попросил драйвер этого терминала
незадерживаь буквы в своих недрах то драйер термиала сразу эту букву из своего внуреннго
буфера переслал в /dev/tty2
а так как баш просил ядро разбудить его когда чтото прилетит то яро его будит. и баш 
пронснувишись читает что там прилетело в файл /dev/tty2
есвтеенно читает не сам а с помощью ядра
     read(0, "1", 1)                         = 1

успешно засавыает в себя цифру 1.
идале баш уже сам пишет эту цифру 1 в /dev/tty2

     write(2, "1", 1)                        = 1

почему баш читает файл /dev/tty2 через 0 а пишет в /dev/tty2 чере 2 хуй знает. 
и 0 и 1 и 2 все ведут на один итотже файл /dev/tty2 и без разницы через какой номер 
деспритора обращаться на один и тот же файл. ровно был бы такой же эффект если сделать

     write(2, "1", 1)                        = 1

потмоу что резузььтатт завсиит не от номера деспритора а от того на какой файл этот деспритор
укзывает!

итак баш сует 1 в /dev/tty2 . это видит драйрвер терминал2. он беерт этот 1 и посылает на тер
минал на монитор. чтобы тот нарисоват этот 1 на экране.

после этого баш обратно засыпает

таким образом сам файл /dev/tty2 используется ядром чтобы пихать в него байты которые приелетли
в ядро из клавы терминала чтобы процессс мог читая файл /dev/ttt2 мог забрать эти кнопки.
и чтобы пороцесс мог писать байты которые он хочет нарисовать на экране монитора терминала.
и ядро забирает эти байты из этого файла и уже каким то там макаром их щлет на монитор и 
просит его отрисовать эти байты как картинки. таким образом сам файл /dev/ttt2 используется
для обмена через него байтами которые процесс хочет нарисовать на экране и для обмена
кнопками которые были нажаты на клаве терминала чтобы передать их внутрь процесса.
процесс обмена идет через read() write()
а ioctl() опосредованно исползует имя /dev/tty2 а не его самого чтобы прцесс мог обьяснить 
ядру какой именно терминал (1 2 или 22) баш просит подкрутить его настройки. или подкобчить
настроки драйвера терминала от этого терминала

user space  |                 ядро                        |               железка

процесс 0 ----- /dev/tty2    ядро   драйевер  терминала буфер --------  клава, монитор (терминал)


важно увидет что и /dev/tty2 и буфер драйвера темринала лежат в ядре. но проецесс не может
никак дотянться до буфера. он может дотняться только до /dev/tty2

файл /dev/tty2 это способ дотянуться у юзер процесса до драйвера терминала в ядре.
это его такой канал связи с драйвером термианала.  какой канал связи самого ядра и драйвера
термнинала с терминалом хрен знает. он какото есть. но процессу онневедом. и ненужен
каналы связи я показал черточками.

может интутивно неверно казаться что /dev/tty2 это средство связи процесса с терминалом.
это не так. это канал связи процесса с драйвером терминала.  канала связи пошарится и пошупать
у процесса к самому терминалу железке нет. он есть только у ядра. у драйвера терминала. 
но процесс к этому не имеет нкиакого доступа. процесс общается дотягивется через /dev/tty2
только до драйвера терминала! и то опосредованно. тоесть процесс кладет чтото в /dev/tty2
оптятть с поомощтю ядра. а уже потом драйвер термиала заглядывает в /dev/tty2 вытаскивает 
это оттуда морщится нюхает вертит между пальцев и гадливо это передает на монитор терминала.

итак что такое файл /dev/tty2 это такое место куда ядро драйвер темрианал при определенных 
условиях скаывает те байты которые прислало клавиуара терминала. если какому то процессу 
интересно что там прилетело с кнопопок терминала2 то такой процесс может заглунуть в 
файл /dev/tty2 и прочитать. если же какйто процесс захочет чтото нарисовать на экране терминала2
символы то он может открыть файл /dev/tty2 сунуть туда байты. и эти байты заберет ядро и пошлет
комаду на мониттор терминала чтобы он нарисовал там какието симоволы.

что из себя прдстлвяет железка терминал по сути. это клава и монитор.  и бльше ничего.
зачем оно нужно. это средство общения между человеком и процессом. между челоком и компом.
человек с помощью клавы шлет в процесс внутри компа  байты. пытаясь таким макаром начать чтото 
делать полезное этот процесс. процесс в ответ шлет байты ответа которые в итоге рисуются в форме
графических смиволов на монитторе чтобы чеолвек мог понять что там прилетело в  в ответе от
процесса.  потому что ток или байты человек не умеет чуствовать . он может зато картинки 
распознавать.

для процесса файл /dev/tty2 это просто файл из котрого прилетают байты и в который можно 
запиывать байты. но если процесс понимает что это непросто обычный файл а  файл связанный 
с драйвером терминала то процесс может  нетлоько принмать и посылать байты через read() write()
но еще может и делать настроки как на драйвере терминаоа в ядре так и на самой железке терминал
(прося об этом ядро естесвтенно через ioctl())
какието моментики что можно на практике подкручивать я уже выше показал. а так мало знаю
что полезного можно там накрутить.

что будет если терминал включен. человек тыкает кнопки. но процесса внутри компа который бы
читал из /dev/tty2 нет. а будет то что кнопки будут прилетать внутрь драйвера терминала в ядре.
там будут копиться. драйвер терминала будет на теримианале на мониторе их рисовать. потом
драйвер терминала сбросиит эти кнопки в файл  /dev/tty2 и на этом все. больше ничего 
и\или ничего полезного не произойдет.

кто дожен внутри линукса запустить процесс котоырй бы читал писал в /dev/tty2 который бы 
интерсовался этим файлом. ответ - процесс init. он должен заранее запустить процесс 
в частности agetty который бы ждал что наконец чтото прилетело в /dev/tty2

вот эти вот виртальные терминалы в которые превращает линукс клаву и монитор и потом
сбрасывет байты от них в файлы /dev/ttyN они сущетсвуют если мы линукс загрузили в текстовом
режиме. без запуска Xorg.  схема выглядит тогда так


что касается монитора
 черный экран -- монитор -- видеокарта --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 

что касается клавы
клава --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 


в целом клава + монитор составляют железо терминала

здесь я хочу подчеркнуть что если мы видим в системе файл /dev/tty2 и мы беерм процесс.  
и из процесса мы открываем этот файл. и пихаем в него байты и хотим посмортеть эти байты
в форме графических символов на монитторе то как нам "попасть" на этот терминал? попасть
на него вот как - если линукс запущен в текстом режиме то попасть на мониттор этого второго
терминала можно нажав Alt+F2 тогда линукс превратит наш монитор в монитор вот того виртуального
терминала2 !!! и клава в этот момент прерватится в клаву того виртуального термианала2 !
а если мы сидим графическом режиме. то переключиь нашу клаву и мониттор в клаву и монитор
виртуального терминала 2 можно нажав Ctrl+Alt+F2 .
тоесть мониттор виртуального терминала линукс держит виртуально в своей голове тоесть  в памяти
ядра. а когда мы тыкаем Alt+F2 то линукс рисует на нашем физ мониторе то что "нарисовано " 
в данный момент на виртаьном мониторе виртального терминала2.
тоесть эти виртуаьные терминалы они включены в линуксе всегда. просто их ний экран 
и клава виртуальные. а когда мы жмем Alt+F2 то линукс "совмещает" экран виртального терминала2
с реалным физическим экраном компа.

поэтому еще раз. вот мы видим в системе есть файл /dev/tty2 . мы берем его открываем
и в него пихаем байты. мы уже знаем что если есть такой файл значит где то там должен быть 
терминал тоесть железка с клавой и монитором. и что если мы записали в этот файл байты то 
на какомто монитре они должны нарисоваться. где этот мониттор как на него посмотреть?
этот мониттор виртуальный и находится он в памяти ядра. но на какое то время можно совместтить
тот виртльный монитор и наш физический монитор нашего компа. для этого надо нажать Alt+F2
или Ctrl+Alt+F2 и ядро на время превратит наш физ мониттор в мониттор того терминала2. тоесть
ядро нарисует на нашем физ монитрре то что было бы нарисовано на экране терминала2 который
живет в его памяти.

важный момент файл  /dev/tty2 создает само ядро. нам из юзер процесса ничего для этого делать
ненадо. "подключение" к терминалу идет просто через то что мы открываем этот файл

  open("/dev/tty2",)

а далее читаем и пишем из него

  read()
  write()

для изменеие настроке драйвера терминала или самого терминала используем

iocttl()

так как самого терминала физичеки несуществует то измеения будут касаться тлько дравера
терминала. хотя учитыая что на время наш физ монитор перрвашаетя в мониттор терминала
взомжно что через ioctl() можно чтото менять из настроек монитора терминала. 
тоесть условно может вирт термиал обладает шрифтами. и получается что чез iotl() можно 
менять шрифты на экране. ведь драйвер терминала толко посылает что надо пеаать а как это печать
какими глифами это здавалось на самом железном терминале. тоесть кажем ты ему из драурвера
терминала шлешь команду  - используй шрифт "times". и после этого он пеатает все байты 
только этим шрифтом. итп

итак как "искать" экран этого терминала2 в линуксе. как его найти и посмтреть что там
на нем нарисовано разобрались.


возвращаюсь к схеме терминала

что касается монитора
 черный экран -- монитор -- видеокарта --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 

что касается клавы
клава --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 


теперь рассмотрим очень токний и важный момент. дело в том что файл /dev/tty2 он не обычный
как файл на диске. осоеность его в том что если мы берем файл на диске. открываем его и пишем
в него байты то эти байты они застревают и так и остаются внутри этого файла. и после того
как мы запиисали "123" в файл на диске то потом мы читаем из этого файла и в ответ мы 
обратно получим эти "123". все прекарасно. но важно не это а то что когда мы их оттуда прочитаем
то они там так и останутся лежать. и при повторном чтении мы опять в ответ полуим "123"
это супераважно. это своство обычных файлов на диске.
так вот файл /dev/tty2 он совершенно не такой. если я в него чтото записал. а потом я это 
прочитаю. то после этого все те байты которые я из него прочитал они оттуда исчезнут!
и при повторном чтении я получу дулю! тоесть когда я пишу в этот файл он "надувается"
а когда я из него читаю он "сдувается". это супр важно понимать. 

теперь рассмотрим схему

 черный экран -- монитор -- видеокарта --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 

вот я беру из процесса открываю /dev/tty2 и пишу в него "123" , далее драйвер терминала 
это мгновенно замечает и он оттуда это считывает и файл мнвоенно сдувается. далее драйвер 
терминала отправяет эти 123 на экран монитора. а я  в своем процессе если запущу команду 
чтения то получу дулю! потому что то что язаписал прочитал уже "котото " другой. файл сдулся.
и в нем ничего нет. а если я читаю из /dev/tty2  то то что я оттуда прочитаю это не то что
я в этот файл до этого засунул а это только то что приттело из клавый терминала!
это поимание теперь дожно помочь и прояснить следущий случай.
вот у меня есть процесс который спит и ждет уведомления от ядра о том что на /dev/tty2
чтото поступило в плане чтобы это проснуться и прочитать.

L ᯯ  $ 
 c Ȭ  $ sudo lsof -Pn -p 2843623 2>/dev/null | tail -n 5
agetty  2843623 root   0u      CHR    4,2      0t0        21 /dev/tty2
agetty  2843623 root   1u      CHR    4,2      0t0        21 /dev/tty2
agetty  2843623 root   2u      CHR    4,2      0t0        21 /dev/tty2
agetty  2843623 root   3r      DIR   0,87       40         1 /run/credentials/getty@tty2.service
agetty  2843623 root   5r  a_inode   0,16        0      3117 inotify
 b   $ 


b   $ sudo strace -p 2843623
strace: Process 2843623 attached
pselect6(6, [0 5], NULL, NULL, NULL, NULL^Cstrace: Process 2843623 detached
 <detached ..


потом мы открываем этот же /dev/tty2 файл уже в другом процессе
для начала открою через cat

   # cat /dev/tty2

# lsof -Pn -p 2849700 2>/dev/null | tail -n 4
cat     2849700 root   0u   CHR 136,122      0t0       125 /dev/pts/122
cat     2849700 root   1u   CHR 136,122      0t0       125 /dev/pts/122
cat     2849700 root   2u   CHR 136,122      0t0       125 /dev/pts/122
cat     2849700 root   3r   CHR     4,2      0t0        21 /dev/tty2

# strace  -p 2849700
strace: Process 2849700 attached
read(3, 

таким образом cat реально успешно открыл /dev/tty2 в дескпритор 3

я такой экспримент провожу потому что если файл обычный типа с диска то его открыть хоть
миллион раз можно хоть из того же самого процесса хоть из разнхы процессов а вот что
касается особых файлов типа сокетов, пайпов итп то их можно открыть толльк один раз 
и только из того же процеса. так что это был тест. 

так вот если я с другого процесса открою этот файл /dev/tty2 и чегото туда запишу

   # echo "124" > /dev/tty2

то ! внутрь процесса agetty это не попадет! потому что ! все что юзер процесс запихиывает 
в /dev/tty2 то это все мгновенно забирает драйвер терминала и уносит на экран терминала.
поэтому если один процесс сидит и читает из /dev/tty2 а второй пишет в /dev/tty2 то 
тот который читает он никогда не прочитает то что записал другой процесс. при чтении 
из /dev/tty2 в процесс может поступить только байты которые были посланы с клавиатуры
терминала , которые затем попали в ядро, которые затем попали в драйвер темринала и коооорые
затем драйрвер терминала зсунул в /dev/tty2, а так как байты которые мы засунули в /dev/tty2
попали в этот файл путем записи из процесса2 то эти байты никогда не будут доступны для 
чтения из другого процесса !
тоесть то что рабоатае с обычными файлами 

   process1 "123" <-- read  /file1
   process2 "123" --> write /file1


такое с файлом /dev/tty2 никога не сработает! если какйто процессс чтот записал в /dev/tty2 
то другой процесс если будет читать /dev/ttt2 он никогда это не получит. то что процесс 
запиывает в /dev/tty2 мгнвоенно оттуда забиарет дарйвер терминала и посылает на монитор 
терминала! единсвтенные байты коорые можно прочитать из /dev/tty2 это те которые были посланы
в ядро с клавиатуры терминала! поэтому можно хоть до усрачки пихать в /dev/tty2 баайты 
через echo


   # echo "124" > /dev/tty2

при этом эти байты никогда не будут считать через agetty который читает из /dev/tty2 !!!

поэтому если есть процесс1 ктырй читает из /dev/tty2 то в этот процесс просунуть байты 
както слева неполуится путем запиывания байтов в /dev/tty2
единсвтенный способ просунуть байты в процесс1 это напечатать их на клавитуре терминала2 !

но при применении echo все же будет интересный эффект. если мы пошлем данные через echo
и потом отркороем монитор терминала2 то симолвы "124" будут на экране этого монитоора 
этого терминала. тоесть это убдет выглядть так как бутто на экране терминала послала 
эти байты программа agetty хотя она неимеет к этому никкого отншения! поэтому получается что 
если программа "читает из терминала" то у нее наежная защита от того чтобы данные не прилелели
откуда то  сбоку сприпеку. все что к ней прилеиитит точо было сгененировано на клавитуре 
термианла. а вот то что мы увидим на экране терминала  эта информация никак не защищена.
в оконо терминала могут "срать" записываь абсолютно левые разные процессы. и окно термила 
от этого ниак не защищено! я могу открыть /dev/tty2 через пятдесят программ. все они могут
одноврменно писать в /dev/tty2 и на экране будет у меня суммараня каша от всех 50 программ.
и понять от какйо прогарммы что прилетло будет невзомжно. ! мы как бы привыкли что если у нас
есть устройство терминал то к этому терминалу якобы поключено на даный момент один процесс.
и поэтому мы думаем что ели на терминале появилс какието буквы то это ровно то что та программа
послала .  а это полуается не так. то что мы увиим на монитооре это может послать как там прогармма так и еще куча программм любых левых. файл /dev/tty2 может одноврмнно откртьы 
куча процессов. и все они могут одноврменно в него писать. ядро это не запршеает. оно просто
будет брать все эти байты и печаатть на мониторре. аналогия такая как буто 50 прогармм открыли
один обычный файл. аэто незарпшеено. и начали туда все пихать. в итоге конетнт файла будет
мешагина из байтов от всех программ сразу!
ну некая логика понятна. вот у нас есть терминал. его открыл bash

# lsof -Pn -p $$ 2>/dev/null | tail -n 5
bash    2849729 root mem    REG   254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
bash    2849729 root   0u   CHR 136,124      0t0       127 /dev/pts/124
bash    2849729 root   1u   CHR 136,124      0t0       127 /dev/pts/124
bash    2849729 root   2u   CHR 136,124      0t0       127 /dev/pts/124
bash    2849729 root 255u   CHR 136,124      0t0       127 /dev/pts/124

потом мы вбаше заупускаем скажем комнду ls 
тогда баш себя клониурует. и родительский процесс засыпает . при этом у него файл 
/dev/pts/124 по прежнму открыт. 
а в клон пороцессе у нас будет тоже этот файл /dev/pts/124 тоже открыт. и баш 
запуускает execve(ls) и у на новый пцроесс выполянет код ls
тот выполняется и срет данные на fd/1 тоесть на /dev/pts/124 , это дело подхыватывает
драйвер терминала и мы видим на терминале вывод от ls. при этом унас bash тоже имеет
октртым /dev/pts/124 но просто баш спит и поэтоу он не срет на терминал. поэтому  у нас 
вывод на экране термиала идет тлоько от ls.  если бы было тердание что файл /dev/ttyN 
либо файл /dev/pts/N можно открывать только одному процессу то башу нужно было бы зактывьат
этот файл при каждом запуске комады внешней а потом заново открывать.  ну воможно да это 
был бы мудеж. а так логиука у  програмистов ядра такая.  - файл /dev/tty2 может открыть 
любое число процессов. а дальше это уже освтвтвеннность этих процессов чтобы не писать 
одновмренно в этот файл потому что иначе у нас то что будет на кэкране напечатано неп онятно
от какого процесса эта информация приелетела!

знаичит  к настощем моменту я расмотрел  классчиеские терминылы которые можно обозвать 
так что они все харакетризуются файлами вида /dev/ttyN
так по своему назначению эти терминалы предназанчены чтобы наладить контакт обмен информацией
между ЧЕЛОВЕКОМ и ПРОЦЕССОМ. человек общается разговаривет с прцоессом , обенивается байтами
используя клаву как метод отсылки инфомрации. экране служит как перводчик информации от процесса
при приема ответа от процесса. 

кстати баш котоая написана чтобы работать именно с терминалом. но также она может работать
хотя бы в какото степени и без терминала через pipe ! тоесть она может прнимать иноформацию
не от терминала и посылать инфомрацию не натерминал. используяю pipe !
тоесть в какойто степени использования баш можетрабтать и без терминала. 
миеется ввиду что дескприторы 0,1,2 баша необязательно дожны смотреть на файл терминала /dev/ttyN
или /dev/pts/N

также такйо ммоент получается что если программа юзер процесс требует для своей работы
терминал это значит что по своей сути эта программа требует ввода данных со стороны
человека и выводит свои даные для того чтобы их человек посмотрел и проанализировал
глазами. она интерактивная.  подразумевает ввод данных со стороны человека и результат
работы этой программы предназначен имено для человека. типа баш. для сраврения программа
логгер она не требует ввода данных от человека например она может их считать из файла
и выводит данные в файл. ей ненужно чтобы человек их анализировал. ей ненужно интеравтивно
с человеком обмениваться данными. а баш подарзумевает постоянный обмена между ней и человеком.
он ей кусок. она в ответ .он ей куоск новых данных она в ответ. она интерактивная. 
для сравнения cat или echo у них только раз задается паарметр и они его ввыодят и конец
работы  - они нетинтеративные. поэтому эттм командам терминал ненужен. они спокойоно 
и через pipe отработают что на входе что на выходе. баш же постоянно требует ввода 
каких то новых данных от челоека. и баш постоянно подкручивает терминал ее свойства 
через ioctl(). тоесть что дает железка терминал  - она дает овзможность человеку через клаву
постоянно чтото корректировать в работе процесса внутри компа. через клавыу как посредника
послыать внутрь процесса новые данные и команды. общаться с этим процессом. монитор дает 
волзможность получать от процесса обаратну связь в человекопонятной форме.  поэтому если 
программа требует для своей работы термиал это зн8ачит что она требует интерактивного 
учатстия при ее работе. ее нужно постоянно контроилировать коррективровать со стороны
чловека. терминал дает споосою как человек может общаться с процессом. термина это средство 
а цель  это наладить диалог между двумя супер разными сущностями - процесс внутри компа 
жлектрическая хрень и человек. cat или echo нетребует терминал потому что их ненужно 
постоянно корректирвоват. их зарядил и впреед. сервисам ненужен термиал потому что их работа
не подрзауметвает общение с человеком. терминал вслпывает там где прцоессу нужно общаться с 
человеком а человеку нужно пообщаться с этим процессом. процессы разные. кому то нужно 
общение с человеком а кому то нет. если у запущенного проецссов в свойствах еть открыйтый 
файл терминала /dev/ttyN то это значит что это приложение интерактивное. оно позволяет коректирова
ть свою работу в онлайн режиме со стороны человека. также это означает что приложение умеет
ввыводить данные в человекоудобной формет тоесть на экран. тоесть приложение понимает что 
то что оно выисрает через fd/1 оно будет выводитсят на экран. и приложеие должно так 
форматирвовать свои данные чтобы это было удобно читать именно на экране. и это значит что
можно будет на компе открыть окно\монитор того термиала к которму это приложение подключено
и там с этим приложением пообщаться. посмотреть что оно уже высрало на экран. и что оно 
готоово от тебя приять на входе. через клаву.

что касаета современного компа то  классичекие терминалы практиески не исползуются. 
их время золтое было тогд кгда не было графичееского режима. вот когда их было время. 
а так как щас время графческого режима на современном компе выглядит список 
проецсов которые заюзали эти классические терминалы


# ps aux | grep " tty" | grep -v grep
root  tty7   /usr/lib/Xorg :0 -seat seat0 -auth /run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch
root  tty3   /sbin/agetty -o -p -- \u --noclear - linux
root  tty2   /sbin/agetty -o -p -- \u --noclear - linux
 

причем не очен понятно .ну два агетти которрые работают и они покдлючены к терминлам 2
и 3  это понятно. это получается в если перключусь на  терминал 2 или 3 то эти программы
ждут что я веду с клавы логин пароль они его проверят и если все окей то запустят процесс
bash котрый они привяжу к этому терминалу. тость это такие прогарммы прверяеряльщики пароля.
вот а на счет терминала 7 непонятно. 

# lsof -Pn -p 1162 2>/dev/null | sort | grep CHR
Xorg    1162 root   0r      CHR                1,3       0t0          4 /dev/null
Xorg    1162 root 120u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 132u      CHR              13,66       0t0        156 /dev/input/event2
Xorg    1162 root 134u      CHR              13,65       0t0        155 /dev/input/event1
Xorg    1162 root 135u      CHR              13,73       0t0        481 /dev/input/event9
Xorg    1162 root 136u      CHR              13,67       0t0        400 /dev/input/event3
Xorg    1162 root 138u      CHR              13,74       0t0        715 /dev/input/event10
Xorg    1162 root  14u      CHR                4,7       0t0         26 /dev/tty7
Xorg    1162 root  15u      CHR             10,127       0t0          2 /dev/vga_arbiter
Xorg    1162 root  16u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 175u      CHR              13,76       0t0        827 /dev/input/event12
Xorg    1162 root  17u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 184u      CHR              13,69       0t0       7260 /dev/input/event5
Xorg    1162 root 186u      CHR              13,71       0t0       7267 /dev/input/event7
Xorg    1162 root  18u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root  19u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 207u      CHR              13,72       0t0       7270 /dev/input/event8
Xorg    1162 root 220u      CHR              13,68       0t0       7256 /dev/input/event4
Xorg    1162 root 228u      CHR              13,70       0t0       7263 /dev/input/event6

видим что Xorg имеет кучу открытых устроусйтво ввода. потом открую видеокрарту.
и /dev/tty7

непонятно то что в окно терминала 7 невозможно пререкоючиься. потому что Alt+F7 дает то 
что открывается уже графиеская система. поэтому получаетя что врдоде как Xorg подключен 
к терминалу 7 но как на него переключится в линксе непоянтно. вместо окна терминала 7 
вылезает графичскя система. 
а так по идее что должно было быть - я каким то макаром перлючаюсь в терминал 7. моя клава
прерващается в клаву терминал. и мой монитор прервщается   в монитор терминала. далее то что 
я начинаю вводить с клавы оно улаеае в ядро в  драйвер терминала. и он это записвыает в
/dev/tty7 и Xorg это мог прочиать. тоесть то что я выткаивал бы с клавы оно  бы прилетало
в /dev/tty7 а Xorg если бы хотел мог бы  с этим познакомться прочитав. и если бы он захотел
ответь то он бы мог написать мне ответ в /ev/tty7 а драйрвер бы терминала это бы прочитал 
и мне на экране бы отрисовал.  одна проблема - непонятно как преключится в терминал 7. 
поэтмоу получетс вроде как Xorg приложени интеративное. но непонятно как попасть на терминал 7.

c приходом графической системы надобность в классических терминалах типа отпала. 
у нас теперь создается окошко на экране. за этим окошком следит Xorg. если событие в окошке
наступает , тоесть если мышка пролетает мимо окошка. или если окошко выделено и на клаве 
кнопка нажата то это все посылается ядром в процесс Xorg. а он это все отсылает в тот 
процесс который его попросил создать это окно. например файрфокс или gnome-terminal 
или xterm. тоесть Xorg это как бы рисовалка окон. а  такие программы как xterm или gnome-terminal
или firefox у них это окно рисуется в их голове вириуально. тоесть Xorg сообщает мол эй файрфокс
там мышка клинкнула в окне твоем в точке 23,17 - че то надо делать или нет. файрфокс анализирует
и пишет в xorg - нужно вот такой то кусок вот такто прериоросвать. тоесть Xorg грубо говоря
"видит " как все нарисовано на экране. и сам рисует. а  програмы которые обращаются к нему
у них этот рисунок в голове только. и получается со старых времен остались интерактивные 
программы которые работали в связке с классическим терминалом. их что на помойку выбрасыавать?
оказывается нет. придумали ПСЕВДОТЕРМИНАЛЫ. они служать для того чтобы общаться одному ПРОЦЕССУ
со вторым ПРОЦЕССОМ. тоесть это опять же средство IPC - интрпроцесс комуникейшен. но! 
новые терминалы применятся там где один из процессов со старых времен тоесть требует в своей
работе подключения к терминалу. 
если раньше было вот так


     ЧЕЛОВЕК -> терминад ---- ядро,  /dev/tty7 --- BASH


слева у нас был человек а справа  bash и они с помощью теримнала общались


то теперь возникла новая схема


   ПРОЦЕСС1 ------ /dev/ptmx, ядро, /dev/pts/15 ---- ПРОЦЕСС2

 
причем процесс2 такой по своей природе что он требует его подключить к терминалу. 
чаще всего тогда эта схема выглядит вот так


   ПРОЦЕСС1 ------ /dev/ptmx, ядро, /dev/pts/15 ---- BASH


так как самая часто используемая терминалая программа это bash


башу предоствляется такой файл и такой получается драйвер  в ядре что баш может 
делать все ему привычные терминальные штучки в том числе и юзать все ioctl() которые
он привык массов юзать.  но при этом уже никакого экрана термианала нет в природе кроме
как в памяти ядра. а вместо этого то что бащ посылает обрабатавется и шлется в файл /dev/ptmx
вместо посылки на экран. ну я так примерно насколько знаю через сам файл /dev/pts/15 баш 
шлет типа чистый текст который бы был на экране напечаатан. все хитрые штучки он юзает 
через ioctl() так что как я понимаю ему дают порвезвиться с ioctl() но по факту это нина что
не влияет. а сами данные текстовые прям  в чистом виде он шлет на /dev/pts/15 и оно в чистом
виде переслыается на /dev/ptmx  вместо экрана монитора.  а там уже есть процесс1 который 
сидит и ждет когда же даныне прилтетят на /dev/ptmx и они читает.  повторюсь почему бы
не содеинить поцес1 и баш через пайпы. и типа нет проблем. но проблема в том что баш в своей
работе помимо отсылки данных через STDIN и STDOUT он еще постянно юзает ioctl() вызовы
так что если ему не дать термианал то его ioctl() будут вызывать ошибки как миниуумум потому что
какйо нахрен ioctl() на файле который укзвает не на терминал  а на пайп.
и полуыатся терминалы этого нового поколения позволяют успешно запускать bash. давать ему резвится
с терминалом , потом всю эту терминальную чушь вырезать. и чисто данные уже пускать на процесс.
ну а процесс1 он понимает что такое графическая система. понимае протокол общение с Xorg
и он получив от бащ "чистые данные" тоесть просто текст то процесс1 тогда трансфоривмирует 
ээтот просто текст уже графический формат и дает команду Xorg как это текст уже отрисовать 
именнов графическом окне.  тоесть мы башу подсывавем такую типа затычку эмулирующую терминал.
баш при этом может использовать все сисколыл котоыре он привык исползовать успешно
а именно ioctl(). тоесть с ioctl() вызоывми у баша проблем нет. то есть я как понимаю
через ioctl() баш формтирует текст на экране. а уже через write(/dev/pts/15) он шлет сам
текст который хотел чтобы драйвер терминала на  экране нарисовал.  этот чистый текст поступает
в /dev/ptmx и оттуда его считыает xterm или gnome-termnal который этои чистый текст 
преобрзаует в язык графического протокола и послыает на Xorg который уже рисует чисто точки 
на экране. таким образом мы старую программу присоабачили к графческой системе
кстати фишка в том что прогарма которая слева  


   ПРОЦЕСС1 ------ /dev/ptmx, ядро, /dev/pts/15 ---- BASH


она не обязана быть графической. это любая программа. весь смысл вот этоих терминалов
новоого поколеииния лишь в том чтобы дать возмжность общаться двум порцессоам один просто
любой процесс а второй процесс который обязательно требует подключить его к терминалу

поэтому ровно по такой схеме работает ssh + bash


     $ pstree -Aspt $$
systemd(1)---sshd(459)---sshd(1743)---sshd(1749)---bash(1750)



     $ sudo lsof -Pn -p 1749  | tail -n 12
...
...
sshd    1749 noroot    9u   CHR                5,2      0t0     86 /dev/ptmx



     $ sudo lsof -Pn -p 1750  | tail -n 4
bash    1750 noroot    0u   CHR  136,3      0t0      6 /dev/pts/3
bash    1750 noroot    1u   CHR  136,3      0t0      6 /dev/pts/3
bash    1750 noroot    2u   CHR  136,3      0t0      6 /dev/pts/3
bash    1750 noroot  255u   CHR  136,3      0t0      6 /dev/pts/3



тоесть у нас схема такая

                         ТЕРМИНАЛ
     SSHD  ---- /dev/ptmx, ядро , /dev/pts/3 ---- BASH


получатся у нас термиал нового поколения "проксирует" связь между sshd и баш.
межу двумя процессами.


на счет SIGHUP. 
как было раньше. сидит человек за жедлезным терминалом и он его взял и выклюил из розетки.
и ядро замечает что провоод через которй берминал был подкючен перестал давать ток. и ядро
понимает то терминал вырубился. и тогда смысла существоать для процесса котоорый был "покдючен"
к терминалу нет. и тогда ядро шлет процессу скажем башу сигнал SIGHUP который означал что
"эй баш! терминал выключился!" и тогда если баш не создал кастомный хендлер то ядро в итоге
этот баш процесс уничтожало. тоесть этот сигнал шлет ядро тому процссу который был полюкчен
к тому терминалу который по мнению ядра больше не отвечает (как ядро этот определяло хрен знает)
и ядро сигнализировало процессу что железка с которой был связан баш выключилась. или сломалась
а значит башу по всей видимости дальше существовать нет смысла. и если баш не создал кастомный 
хендлер то ядро использовало своей дефолтовый и ядро убивало процесс баша.
кстати я думаю что еще можно было с клавы на терминале тыкнуть комбинацию и эта комбианация
собщала ядру что юзер собирается вырубиьт терминал. и тода ядро тоже послыло башу такой
сигнал. 

что касается терминалов нового поколения. там ситуация я думаю такая - мы тыкаем на крестик в
графичеком окне. ядро это шлет к Xorg. тот находит тот процсс который просил создат это окно.
находит что это xterm. тогда Xorg шлет через сокет к xterm эту инфо. xterm понимает что юзер
хочет пррекратить работу и он тогда шлет сигнал SIGHUP башу. таким образом башу ссобщается что
пора заканчивать ибо человек наверху уже нехочет работать. ну и когда все хвосты зачищены то 
я дуаю что xterm посылает команду к xorg что можно унчтожать окно. а потом и сам xterm
заканивает свое существоание. я так думаю. тажкже я полагаю что если xterm пошлет


           close(/dev/ptmx)

 то само ядро увидев такое безаоние пошлет к башу сигнал SIGHUP потому что это уже 
 буквлно ситация что термиал на котоырй смотрел баш "выключился"

вот я имею дервое провецссов

[lenovo dev]# pstree -Aspt $(pidof xterm)
systemd(1)---systemd(1294)---gnome-terminal-(1774)---bash(2859122)---xterm(2894486)---bash(2894488)
[lenovo dev]# 




я навожу крестик на граф окно и вот что получаю


     # strace -f -p  $(pidof xterm)
recvmsg(3, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base="\241 \324\1\f\0 \2b\1\0\0`\1\0\0\311\336\236r\214\300\274\305\300\2071\236p\242\262\213", iov_len=4096}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 32

kill(-2894488, SIGHUP)                  = 0
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_KILLED, si_pid=2894488, si_uid=1000, si_status=SIGHUP, si_utime=7 /* 0.07 s */, si_stime=0} ---
wait4(-1, NULL, 0, NULL)                = 2894488
wait4(-1, NULL, WNOHANG, NULL)          = -1 ECHILD (No child processes)
kill(-2894488, SIGHUP)                  = -1 ESRCH (No such process)

clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLDstrace: Process 2894552 attached
, child_tidptr=0x713fabc13a50) = 2894552
[pid 2894486] wait4(2894552,  <unfinished ...>
[pid 2894552] execve("/usr/lib/utempter/utempter", ["/usr/lib/utempter/utempter", "del"], 0x63abc20032f0 /* 67 vars */) = 0
--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=2894552, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
ioctl(5, TCFLSH, TCOFLUSH)              = 0
close(5)                                = 0
exit_group(0)                           = ?
+++ exited with 0 +++


что видно из этого. я нажал крестик на экране на окне гарфическом. Xorg шлет в xterm через 
локальный сокет сигнал что был нажат крестик

     recvmsg(3, {msg_name=NULL, msg_namelen=0, msg_iov=[{iov_base="\241 \324\1\f\0 \2b\1\0\0`\1\0\0\311\336\236r\214\300\274\305\300\2071\236p\242\262\213", iov_len=4096}], msg_iovlen=1, msg_controllen=0, msg_flags=0}, 0) = 32

xterm шлет к башу(-2894488) через ядро сигнал SIGHUP
причем нетолько к башу а ко всем процессом которые входят с баш в одну групппу процессов

     kill(-2894488, SIGHUP)                  = 0

далее от ядра xterm получает сигнал что чайлд процесс баш сдох
потму что ядро послало сигнал о котором попросили. баш принял сигнал и себя грохнул

--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_KILLED, si_pid=2894488, si_uid=1000, si_status=SIGHUP, si_utime=7 /* 0.07 s */, si_stime=0} ---

xterm читает код возврата из чайлд процесса иначе он вечно будет виесть в состоянии зомби(еба
нутое название)
причем делает это два раза чтобы точно убедиться что чайлда ядро уничтожило вноль после того как xterm про
читал кодввразта 

     wait4(-1, NULL, 0, NULL)                = 2894488
     wait4(-1, NULL, WNOHANG, NULL)          = -1 ECHILD (No child processes)


зачем то потом xterm еще раз шлет килл к башу которого уже точно нет

     kill(-2894488, SIGHUP)                  = -1 ESRCH (No such process)


а дальше происходит то чего я незнал. xterm клонирует себя и запускает utempter
эта программа нужна чтобы имзенть записи в файлах utmp\wtmp(об этом читай отдельно
в utmp.txt) . что это за файлы? это такие 
файлы   в которых рекомендовано не обязательно записывать информацию о том какой юзер и когда
делал логин в вситему и делал логоут. с технической точки зрения что значит юзер 
сделал логин это значит что если какйото
процесс создает ФАЙЛЫ терминала (/dev/pts/N /dev/ptmx) и потом запускает процеесс1 который 
подключает к /dev/pts/N товедь понятно что с эттим процессом1  будет непосредственно снаружи
обменитвася инфомацией какйото юзер. тоесть у нас в системе полявелся процесс с которым из 
внешнего мира обменивается инфомрацией какотой юзер. ну а если котот получил доступ к процессу
то это же надо зафиксировать. значит ктото "подключился" к системе. тоесть в нашем случае. 
запускается xterm процесс. он открывает /dev/ptmx ядро создает при этом /dev/pts/10
далее xterm себя клонирует и запускает там bash. ну и вот где то в этим моментах xterm
делает запись в wtmp utmp о том что новый юзер "подключился" к системе. по факту о том что 
появился новый процесс привязанный к терминалу. в данном случае мы наюлюдаем оратный процесс
что когда баш который был приявязан к терминлу был грохнут то xterm делает запись что юзер
закончил работу с процессом. так вот xterm меняет utmp\wtmp записи через программу utempter


clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLDstrace: Process 2894552 attached
, child_tidptr=0x713fabc13a50) = 2894552
[pid 2894552] execve("/usr/lib/utempter/utempter", ["/usr/lib/utempter/utempter", "del"], 0x63abc20032f0 /* 67 vars */) = 0

далее xterm ждет когда дочерний процесс utempere закончит свою работу
     [pid 2894486] wait4(2894552,  <unfinished ...>


далее utempet заканчивает свою работу. от ядра прилеает сигнал что дочка сдохла.
xterm читает код возврата. делает какеито манипуляции с драйвером терминала через ioctl()
и сам подыхает

--- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=2894552, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
ioctl(5, TCFLSH, TCOFLUSH)              = 0
close(5)                                = 0
exit_group(0)                           = ?

таким образом я открыл что окзаваетс xterm юзает utemper (ну это побочное знание) и самое
гавное я узнал когда и как и кем используется сигнал SIGHUP!! вот радичего я делал этот strace


итак я расмотреть прояснил тот момент кто когда как юзает SIGHUP
тут надо кое что поясинить. как у нас взникает терминал новогго поколения. у нас 
есть процесс-А который открывает файл /dev/ptmx  при этом ядро создает автомтаом файл
/dev/pts/N намриер /dev/pts/10
тепер если какойто процесс-Б открывает /dev/pts/10 то он "подключится к тмериналу" тоесть
процесс-Б через /dev/pts/10 имеет связь с драйвером терминала. он может делать ioctl 
к этому драйеру терминала. а все что процесс-Б пошлет в /dev/pts/10 все это влетает в ядро
потом в драйверо терминала а потом он летит в /dev/ptmx файл который у нас открыл процесс-А
и наброт то что процесс-А пошлет в /dev/ptmx то влетит в ядро потом в рдрайвер терминала 
и потом райвер это пошлет в /dev/pts/10 
вот код как "создается" терминал нового поколения 168.c


int main()
{

  int md = -1;
  md = open("/dev/ptmx", O_RDWR | O_NOCTTY);

  int sl1 = -1;
  sl1 = grantpt(md);
  sl1 = unlockpt(md);


  char * ptr_sln = NULL;
  ptr_sln = ptsname(md);

      pid_t pid = -1;
      pid = fork();
 ...
 ...


тоесть процесс должен открыть /dev/ptmx
этим действием мы заказываем у ядра чтобы оно создало новый /dev/pts/N и оно его
создает. процесс-А как бы становится человеком который включил теримнал железный.
человек это процес-А , клава и монитор железного терминала это файл /dev/ptmx котоырй
он открыл. а для процесса-Б с которым процесс-А хочет пообщаться создается свой конец
в терминал это /dev/pts/N
вот эити команды хуй хнает что делают но они нужны при активации терминала
  sl1 = grantpt(md);
  sl1 = unlockpt(md);

а вот эта комнада
       ptr_sln = ptsname(md);

это мы в процессе-А узнаем номер сзданного ядром файла /dev/pts/N потому что мы его нмоер
незнаем

так вот я возвращаюсь к синалу SIGHUP.
когда у нас железный ерминал а процесс имеет открытм файл /dev/tty2 то кто когда и как 
послыает SIGHUP. один вариант это делает ядро. оно это делает тогда когда ядро считает 
что связь с терминалом железным отвалилась. потому что у на схема какая. прцесс имеет
связь с драйвером терминала через файл /dev/tty2  а ядро имеет уже реалную связь с релным
железным терминалом черз некоторйы провод


  прцесс fd/0 -----> /dev/tty2 ядро, дравер терминала ----провод-----> желеный терминал

так вот когда даравер термнала видит через провод что похоже железный терминал 
выключился связь с ним пррпала (как тэто узанет ядро на практкикие хуй занет наверное кода 
в провде волтты проппадают) то логика дальше такая ядро "видит" что связь с терминалом
пропала (типа по аналогии что диск от систмы отвалилися) и получаетя что проецссуу который
общался с терминалом жить дальше незачем. по крайней мере нужно этотпрцесс об этом событии
уведомить. потому что терминал можт никогда больше не вкдлюиться а процесс сидит и чтото 
считает для вывода на терминал и жрет цпу. и ядро тогда шлет проессу сигнал SIGHUP! котоырй
означает - эй процесс! терминал с которым ты разговрилва сдох! имей это ввиду!
если проецсс создал свой кастнй хендлер сигнала SIGHUP то запустится шедуоером этот хендлер.
а если процесс токого не сделла то зауспустится дефолтоый хендлер этго сигнала в ядре. 
а этот хендлер он просто напросто грожает это процесс!

также я думаю что юзер на хэжелезом терминале может начать неукю комбиацнацию и в янвом виде
собощаить ядру что термиал щас будет скоро выключен. и тода ядро тоже пшлет в процесс
сигнал SIGHUP!! вот кто кода зачем и поеум шлет этот сигнал

когда же мы иемеем дело с /dev/ptmx и /dev/pts/10 
то у нас весто челоека выступает процесс-А вместо желеднго терминал вытступает /dev/ptmx файл
и мы имеем схему

пцроесс-А fd/5 ----> /dev/ptmx, ядро, райер терминала, /dev/pts/10 ----> fd/0 процесс-Б

так вот если процесс-А собирается закрыать файл /dev/ptmx то это значит что ядро "уничтожит"
текущий терминал. это значит что дальнейшая работа процеса-Б потеряет смысл и возмжность. 
потому что если прцесс-А закроет файл /dev/ptmx то ядро автоматом уничтожит файл /dev/pts/10
поэтому если процесс-А собиарется закрыть /dev/ptmx/ то процесс-А шлет проесу-Б сигнал
SIGHUP. он какбы говорит эй! процесс-Б терминал на который ты звонишь он будет уничтожен!
имей ввиду! ну а дальше еси процес-Б несодал коасмтный хендлер для SIGHUP то сработает деофлтрйы
ядерный хенлере который грохнет процес-Б
тосьт инициатором посылки SIGHUP в этом сулчаетя явтяеся процесс-А а не ядро как это 
было в случае /dev/tty2.  и далет это процес-А если собирается "уничтожить" терминал. а ткак
проце-С покдлчюен к этому терминалу то процес-А предуружпдает проецес-Б об этом через SIGHUP

но возможнен и второй вариан. если мы возьмем и грохнем процесс-А через SIGKILL то он ничего
не успеет послать к проесу-Б, тогда само ядро инциирует посылку сигнала SIGHUP к порцесу-Б

вот тако ответ на вопрос - кто когда зачем и как шлет SIGHUP и кому. 
также я затронул вопрос - как создать на практике этот новй тип теримнала в СИ программе.

я провел экмеримент. я заутил xterm
потом нашел его pid и нашел pid баша котооый он запутил.
потом я запутсил strace обоих этих прцоессов.
далее я запустил SIGKILL для прцоесса xterm. и что же я увидел
для процесса xterm я увидел то что он просто был уничтожен
     
          +++ killed by SIGKILL +++

и он сам ничего не успел седлать
при этом олуается у нас баш еще остался. смотрим что с ним происхдит

  $ sudo strace -p 2905170
pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}) = 1 (in [0])
--- SIGHUP {si_signo=SIGHUP, si_code=SI_KERNEL} ---
--- SIGCONT {si_signo=SIGCONT, si_code=SI_KERNEL} ---
getpid()                                = 2905170
kill(2905170, SIGHUP)                   = 0
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=2905170, si_uid=1000} ---
kill(2905170, SIGHUP)                   = 0
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=2905170, si_uid=1000} ---
+++ killed by SIGHUP +++


видно что приетает SIGHUP причем инцииатором явлется именно ядро
          si_code=SI_KERNEL
а не какойто процесс. это важно понимать
также видно что ядро присылвает SIGCONT сигнал видимо это делается потому что процесс баш
в даннмо случае может находится в зафризенном состоянии T (которое можно получить послав SIGSTOP)
пример

$ kill -SIGSTOP 2906019
$ ps aux | grep 2906019
noroot   2906019  0.6  0.0   9352  6080 pts/122  Ts+  15:27   0:00 bash

значит зачем ядро после SIGHUP шлет также и сигнал SICONT? а вот почему. я проверил. если
запусить процесс. потом его зафризить через SIGSTOP , потому к этому процессу послать SIGHUP
то шедулер ничего с прцоессом делать небудет! тоесть процесс нетлько не раобтает но и шедулер
необрабатывает сигналу прилетающие к нему! а если я после этого пошлю SIGCONT то тутже 
пойдет обработка SIGHUP потому что он нкуда неделася  он так и лежал записанын в свойства 
процесса!

ну дальше в том стрейс что я привел происходит вот что - очевидно что баш имеет свйой кастомный
хенделер для обработки SIGHUP. поэтмоу он там делает разные дела я просто опустил это в лрстинге
и в итоге когда баш сделает все свои дела то баш уже сам себе шлет SIGHUP
причем даже неоднократно

--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=2905170, si_uid=1000} ---
kill(2905170, SIGHUP)                   = 0
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=2905170, si_uid=1000} ---
+++ killed by SIGHUP +++

то что именно баш шлет сам себе сигнал можно определить по этому

          si_code=SI_USER, si_pid=2905170,

тоесть ичтосник сигнала указан. кто послал.
а дальше вот что - если проецесс при запуске устанвоил свой кастоный хендлер по дефолту
этот кастомный хендлер отарбоатет тольк один раз когда этот сигнал приелтит првый раз. 
после этого автоматом процессу названчаается дефтоввый яденый хендлер. (можно ли кастонмный
както переневесить незнаю). поэтому когда SIGHP приает в баш повторно то уже встрой втсупает 
яедерный хендер который и наконец то грохает этот процесс!

таким оразм  я ровпроверил свою теорию о том что - если процесс-А мы грохнули через SIGKILL
то он уже SIGHUP послать неуспевает. и его шлет само ядро!! более того не простошлет а еще 
и SIGCONT в дполениенние шлет!!!

еще раз замеучу что когда у нас граф режим и мы юзаем скажем xterm или gnome-terminal
тоесть прогарммы которые создают окно в граф системе а потом через это окно "проксируют"
и также создают терминал нового поколения и через это граф окно и терминал нового поколения
"проксируют" связь между человеком который смтиритв граф окно и  каимто процессом напимер bash.
так вот в этом случае событие SIGHUP  со стороны внешенго наблюдатется слеучается тогда когда
человек тыкает на "крестик" на графическом окне. вот тогда gnoe-terminal или xterm шлет
SIGHUP на bash


таким оразом я очень даже хроошо разобрать всю хрень про SIGHUP!
ксати согласно ответу от ИИ этот сигнал случается в сстеме нетлолько когда имеет место 
суета с процесами свызанным с терминалаами. есть еще случаи. может разберу их потом.


програма bash нумеет раотать  с граф системой . она незнает язык проктола X11 она только 
умеет буковкий послытьа. поэтому нужно прогиама посредник которая будет забтрать от 
баша буковки превращать их в язык X11 протокола и слать на Xorg чтобы это прервратилось 
в граф картинку. это умеет деать xterm\gnome-terminal


  ГРАФ СИСТЕМА (Xorg) <---x11 поток-----  xterm  <----текст---- bash

аналогично

  ГРАФ СИСТЕМА (Xorg) <---x11 поток-----  gnome-terminal  <----текст---- bash


далее отдельные заметки мысли  ==>
 
--
первая заметка
/dev/pts/15 это не просто труба по передаче байтов как напрмиер пайп
это труба в драйвер терминала. тоесть это канал связи процесса с драйврером
терминала. безусловно что в этот канал можно слать и просто текст. но взможно в
него можно слать какието управляющие байты чтобы подкрутить както настойки
на дрйвере термианла. хотя насклоько я знаю настройки драйврер терминал подручитвабся
не через
  
  write(/dev/pts/15)

а через отдельный сисколл

     ioctl(/dev/pts/15)

при этом файл /dev/pts/15 испольщутся чтобы обьянить ядру какой экзмепляр драйрвера терминала
нужно подкрутить. формать этого сисколаа нарпример выглядит вот так

ioctl(0, TCSETSW, {c_iflag=ICRNL|IXON|IUTF8, c_oflag=NL0|CR0|TAB0|BS0|VT0|FF0|OPOST|ONLCR, c_cflag=B38400|CS8|CREAD, c_lflag=ISIG|ICANON|ECHO|ECHOE|ECHOK|IEXTEN|ECHOCTL|ECHOKE, ...}) = 0

насколко я понимаю при вызове этого сисколла в сам файл /dev/pts/15 юзер прога ничего 
не пишет. а она исползует имя файла тлько ля того чобы обяьснить ядру какую копию драйвера
терминала мы просим подкрутить
тоесть насклоько я понимаю запист в /dev/pts/15 используетя только для передачи самих 
данных. а для подкрутки параметров драйрвера темринала ничего в этот файл не запиывается!



---
следущая заметка
как было раньше. 

1) человек сидит перед коробкой. корбка наыается терминал. по факту внутри коробки
находится склеенные вместе монитор  с клавой. в нем нет ни цпу ни памяти.


2) коробка по проводу идет в сист блок тоесть в ядро. там сидит драйвер этого терминала


     коробка ----- провод ----->штекер, ядро, драйвер терминала 


3) в ядре есть вирт файл /dev/tty2 который ведет в драйвер терминала со стороны процесса

     коробка ----- провод ----->штекер, ядро, драйвер терминала, dev/tty2 ----- fd/0,процесс


3) в глубине памяти мейнфрейрма сидит баш процесс c именами дескпрторов 0 1 2.
внуири памяти процесса есь только имена десприторов тоесть банально тлоько числа 0,1,2
а уже в самамам ядре сидят сущности "файл дескрпитторы"
в кажом дескприторе написаны параметры файла с которым он связан


процесс,fd/0 ------> ядро, файл десриптор 0

тело файл дескриптора 0
(имя файл дескприотора = 0)
(имя файла  = /dev/tty2)
(инода файла = 21)

значит еси у нас еть процесс как узнать какие имена дескприторов у него внутри есть. 
и на какие файлы эти деспртторы нацелены? ответ - есть папка в ктторой он размещает
файлы так вот есть файл в котором имя файла равно имени файл дескпритора. этот файл 
это симлинк. так вот в теле симлинка ядро кодирует имя файла на который дескприттор в ядре
указывает
пример

        $ stat /proc/$$/fd/0
  File: /proc/2911185/fd/0 -> /dev/pts/126
  Size: 64          Blocks: 0          IO Block: 1024   symbolic link

тоесть здесь мы имеем файл с именем 0. поэтому 0 кодирует имя файл дескриптора 0.
а типа этгго файла это сикмлинк.  и в теле симлинка зашифрвано на какое имя файла
укзаыем дескпритор в ядре  в нашем случае указыват на файл

          /dev/pts/126

и все это верно для процесса с номерм $$

с таким же успехом ядро могло бы это все предтавлять не в форме симлинка потому что
он только мозги выебывает а форме "обычного" файла. который если октрыть то там было
бы записано /dev/pts/126 . и было бы прсто и понятно. а так симлик он реаьно сбивает 
столку сука



важно поять что сам проецсс он в /proc папку не лазиит когда работает с файлом /dev/pts/126
сам процесс просто беерт и подствляет 0! напрмиер

  write(0,....)

а proc это просто ядро нам показывает внутренности процесса в такой форме. 

так вот обычно но не всегда если процесс раотает с термиалом то у него файл терминала /dev/tty2
открыт три раза и дескрпиторы с именем 0,1,2 все смотрят на этот файл 


 0 ---> /dev/tty2
 1 ---> /dev/tty2
 2 ---> /dev/tty2
 


вот человек нажал кнопку на клаве этого ящимка и кнопка улетела в ядро удаленного 
мейнфрейма. и застряла в ядре в драйвере терминала. но драйвер не обязан эту кнопку сразу
пересылать бащу! у него мжет настроено чтобы переслать кнопку только если нажали Enter
поэтмоу мы можем на клаве нажать несколько кнопок они все тут же улетели в ядро и там лежат.
но в баш еще ничего не прилетело. и вот мы нажали Enter и олько тгда ядро передал все
эти кнопки в файл /dev/tty2 но опятьже это еще не значит что данные попали в бащ!!!
на картнке  я показал где сейчас лежит байт который с клавы нажал человек но еще не нажал enter

                                                               байт
                                                                \/
человек -- клава -----провод----штекер,ядро, драйвер теримнала буфер, /dev/tty2 ---- fd/0 bash

он лежит в буфере я ядре. туда доступ процессу невозмжоен.

тоесть содной тороны байт давно уже улетел с клавы и лежит внутри мнейнферейма.
но в баш еще не попал


далее челоек с клвы нажал enter. это байт улетел в ядро и дал сигнал дрверу терминала 
переслать байт из буфера драйрвера терминала в файл /dev/tty2

                                                             
                                                                       байт
                                                                        \/
человек -- клава -----провод----штекер,ядро, драйвер теримнала буфер, /dev/tty2 ---- fd/0 bash


но и опять по прежнему этого байта нет внутри баша!!!
и только если баш со своей стороны изволит попробовать прочитать из файла /dev/tty2 

     read(0,....)

то кнопка из клавы наконце то попдает в нутрь баща!!
и толкьо тогда баш получил эти кнопки! тоесть по времени это будет
совем не то время когда они были нажаты!

еще момент. мы нажали кнопку она улетела в ядро. но нажатие кнопки невлечет автоматически
что мониттор этго ящика будет эту кнопку рисовать! нажатие кнопки это одно а отрисовка ее 
на экане это совершеннодругое! и в райвере ядра может быть настройка "эхо" такая что если 
в ядро прилеетела кнопка то ядро автоматом без участия баша  обратно на кообробку отслыает
сигнал нарисовать букву!  и у нас на экране загорается буква! но не потому что баш ее 
получил и нам обратно отослал! нет!  буква загорелась потому что удаленное ядро дало такую 
команду! а бащ эту букву еще вообще не получал! она лежит в ядре! 

процесс который открыл файл терминала /dev/tty2 он может нетлько слать данные тоесть
буквы. но также процесс может подркучиваьт настойки драйвера терминаала в ядре через
ioctl()

баш через ioctl() насраивает так драйвер темрианала в ядре что ядро при получении буквы тут
же ее шлет в баш. также баш отключает эхо у ядра. тоесть ядро при получнии буквы само
обратно нешлет сигнал на ее отрисовку. вместо этого сам баш при получении буквы ее сразу
шлет обратно ! тоесть бащ на себя берет часть функций драйвера терминала. баш отключает эхо
, трбует  у драйвера чтобы он неждал ентер а сразу пихал полученную букву из ядра в баш.
и баш сам шлет братно полученную бвкву! кога баш азпускает внешнюю коману то он все возвращает
в терминале - он влкювает эхо! и он вкюачает что драрйвер терминала непереслыает буквы процессу
пока неполучит ентер
тоесть монжно запустиь программу в черном окне. и тыкать кнопки на клаве и на экране они будут
рисоваться но стрейс покажет что процесс ничего не получает. а всепотому что кнопки 
прилетаютв ядро в дравер терминала и там застревают. и ядро обратно шлет символы на экране
и унас впечатление буквы уже внуири процесса и он нам в ответ их отрисовал. а ниуйя этовсе 
ядро и его драйвер терминала. и толко когдмы тыкнем ентер нам стрейс покажет что буквы
наконец поступили внутрт процесса!

я это проверил. 251.c

122             
PARENT PROCESS. READ DATA FROM /dev/ptmx : 122
 w ᴱ  $ cat 251.c
#include <stdio.h>
#include <unistd.h>

int main() {

     int pid = getpid();
     printf ("pid = %d\n",pid);

               char buffer[256];
                 int len = read(1, buffer, sizeof(buffer) - 1);
                 if (len > 0) {
                    buffer[len] = '\0';  // Null-terminate the string
                    printf("PARENT PROCESS. READ DATA FROM /dev/ptmx : %s", buffer);
                 }



    return 0;
}
 r 鮖  $ 


 запускаем эту прогу в одном окне

 а вдругом окне запускает strace этгоо процесса

потом идем в первое окно и начинаем тыкать кнопки. и нажимать бекспейс.
и все эти букы рисуются на экране
но! во втором окне видно что в процеесс ничего не прилктает! 
получается что буквы прилетают в ядро. они прилипают там внутри к драфуреру ядра.
и ядро делает эхо и шлет на экран символы! это делает не прцоесс.  и потом мы жмем ентер
и они наконец то попают в процесс!хотя мы ввели их давно и накэарне они давно! и редактирование
их наэкране делается  за счет драйвера ядра  а не пцроесса! 

но я подчркну что так имеет место только когда мы запустили простекцкий процесс и приязали
его к теримналу. а если мы запустил такйо процсс как баш и привжем к терминалу то он сразу 
начинеает через ioctl() менять натройки на драйере терминала. и как следствие драйвер терминала
наичинает рабоать сосем не как по деолту. например ели у нас бащ то редактирование строки
идет уже не в буфере драйвера терминала а уже именно силами баша внутри баща.

еще важно пнять


процесс fd/1 ---> /dev/tty2  ядро -- драйвер терм -- --- провод ---- монитор терминала -- человек


важно понимать что с коробкой железкой терминал имеет связь только ядро, драйвер терминала
и как и через что она там раотбоате хрен знает. 
а файл /dev/tty2 это связующее звено между драйвером терминала и процессом
поэтому ошибочно думать что если процесс пишет в этот файл то за этим файлом лежит 
железка. нихуя. за этим файлом лежит драйвер терминала , тоесть кусок кода ядра.
также ошибочно думать что драйвер темрианал ядра связывается с коробкой железкой терминал
исаользуя файл /dev/tty2. это тоже полная хуйня.
вот еще раз как эыто вынлядит на саомо деле


 процсс  --- /dev/tty2 --- драйер терминала ---- провод ----железка терминал

как выглядит проарммый интерфейс между драером терминала и железкой (то что обозначено как
провод ) нам даже незивестно.

когда драйвер терминалаа  делает эхо на экране терминала тоесть посылает управляющие
сигналы по проводу чтобы на мониторе терминала загорелись картинки то это ниак не связана
с прокачкой байтов через /dev/tty2 !!! потому что четко на кратинке видно что между
дарером терминала и терминалом лежит "провод", а /dev/tt2 он лежит между процессом 
и даррайвером терианал.тоесть совсем с другой стлроны


в текстомов ржеиме  линукса у нас нет реальной железкт терминал. 
точнее у нас вобщем то есть физ терминал это монитор и клава. но линукс
научился в своей голове создавать виртаьные терминалы а потом  перкочать эти вирт 
терминалы с едиснвтенным физ термиалом. тоесть лиункс умеет совместить  на время
монитор вирт терминала с реальным монитором компа. тода схема во т тааая


процесс fd/1 ---> /dev/tty2,ядро,драйвер терм---- видеокарта----экран монитора--человек


еще раз когдая ядро делает эхо то для процесса это невидимое событие и никак не завфиикировать 
потому что это ядро шлет данные сразу на видеокарту. а оттуда на экран. а не то что ядро шлет 
на tt2 нет. 
тоесть /dev/tty2 это не файл связти между железкой терминал и ядром мейнфрейма! нет. 
/dev/tty2 это файл связи между двумя кусками софта процессом и драйвером терминала в ядре!



граф режим

                 |                 ЯДРО                  |
процесс fd/1 ---> /dev/pts/10,ядро,драйвер терм,/dev/ptmx----> xterm - Xorg -экран терминала -- человек


ВОПРОС - почему если я шлю байты с процесса2 на /dev/pts/10 то они в процес1 не влетают?
а еcли я шлю байты на /dev/pts/10 через /dev/ptmx из xterm то байты до процесса1 долетают?
ОТВВЕТ - на этот вопрос я уже ответил там наверху. но здесь еще раз обсудю
этот момент


     процесс fd/1 ---> /dev/pts/10 -  ядро -- драйвер терм ----- /dev/ptmx
                         /|\ =========================================>
                          |

                       проецесс 2



файл /dev/pts/10 он таков что если его ты открыл и ты в него 
пишешь то ядро всегда те байты которые ты в него снуул оно их мгновенно
из этого файла вытаскивает, удаляет их из этого файла и шлет эти байты  на драйвер терминала,
а тот уже их сразу шлет на монитор если мы имеем дело с класческим терминалом либо в 
файл /dev/ptms когдамы имеем делос терминалом нвого поколения. я это показал стрелой. 
ты можешь конечно и читать с этого файла - но! там уже будет пусто!
поэтому еси один файл читает из /dev/pts/10 а второй файл туда пишет то никогда 
эти байты не попадут в процесс который читает!


процесс которй читает из /dev/pts/10 в него попадут только те байты которые были 
отправлены исключительно через /dev/ptmx либо байты которы были введены с клавы
вот!
видимо в чем разгадка!  пэтому когда мы из процесс2 пишем в pts/10 то пытаться это прочитать
из процесс1 fd/0 бесполезно!тоесть то что ты туда записал оно сразу оттуда улетает  как 
через запись в сокет или пайп. тоесть получается как бутто файл /dev/pts/10 это точка
фхода одна но там внутри две пары пайпов котрые не переекаются. то что влетело сразу улетает туда. 
а если я чтото читаю то это читается то что было всунуто не на этой стороне а всунуто с той 
стороны. 
этовсе обянсяет - почму пихая в pts/10 из процесса2 я будт это видеть на экране (потому что
оно сразу улетело на втророй конец ptmx) но попытка это считать из prcocess1 нчиего недаст.
зато если чтото шлется к нам через ptmx  и мы читаем из процесса1 и процесса2 один 
и тоже pts/10 то мы оба будем конкурировать за это. и чась прчитает процесс1 а чатсть 
перехватит процесс2!


далее
что значит что у процесса есть терминал или нет терминала?
ну во первых признаком этого будет то что у процесс будет дескприторп  который 
ведет на файл терминала /dev/tty2 или /dev/pts/10. это признак того что подкюлчен 
ли процесс к тмериналу или нет. теперь по поводу физ смысыла этого.
изначально термиал это было устройство для общения процесса внутри компа и живого человека
тоесть это не связь меджу процссом и процессом (это было не средство IPC интепрпроцесс
коммуникейшен. это было серство комункиации прцесса и челоекка)
вот схема
 
  ПРОЦЕСС  - /dev/tty2 драйвер терминала --- терминал - ЧЕЛОВЕК

для процесса признком того что на той стороне от дескриптора сидит человек за терминалом явялеось 
то что десприптор   смотрит на спец файл /dev/tty2
а если на той стороне терминал то процесс делал натсройки терминла через дайрвер 
терминала через сисколл ioctl()

вслучае текст режима лиукнса считай так и есть
схема

     проецсс fd/0 - /dev/tty2  дравер терминала    - экран+клава


в случае когда у проецесса открыт псевдотерминал /dev/pts/10 то это значит что 
для процесса все выгдядиттак что с торой стороны по прежнму терминал с челоевекком
а нсаомом деле с той стороны другой процесс!!!
схема

     прцоесс fd/0 --- pts/10  драрвер терминала /dev/ptms-- процесс 2


еслипроцессу которому нжуен терминал типа баша посунуть внместо термианал пайп или сокет
то скрей всего баш вылетит с ошиькой потому то тчто он начнет делать ioctl() пытась 
этот терминал настройкит . а ядро верент шибку и баш видимо вылетит с ошибкой. 
тоесть процессы  для которых напсиано тербованияе дать им терминал они порзумеваеют что 
с той стороны от открытых файлов на процессе будет не процесс сидеть а будет сидеть 
железка терминал и на ней человек. 
формально ролучется что есть процессы которые заточены не для общения с друими процессами
или общеиня с обычными файлами а для общения с железкой! железкой терминалом! и в конечном
итоге с человеком .если им желеку это не предотваить то они выполняя сисколлы
специифические для настройки терминала получат отлуп от ядра и просто вылетят!
правда я это не проверял.
вот что значит что процесс требует терминал. 


а если процесс нетребует терминал то значит этому процессу связь с желзкой термиаом
ненужна, значит ему оббщение с челоеком ненужно. значит ему нужно достаточно либо 
просто в физ обычный файл писать. либо достатчо будет пайпа, сокета для связи с другим
процессом. тоесть если процесс нетребует представления ему терминала то это означает что 
такйо процесс непредназначен для обение с челоквеком а он предназначен только для
записи в файл или лдя общеи с другим процессами.



такеж важно - вот обычныйй файл похож на трубу с одной дыркой и заткнутойдыркой на той тороне. 
дыркой явялется название файла.
потому если мы открыли файл и туда чтот записали то оно там в трубе и осталобсь. 
пэтому елси мы записали
и тутже начинаетм читать то мы конечно и обратно получим то что заисали! 
причем получается что имя файла через который можно и чтать и писать оно одно и тоже.
если мы повторно
второй раз начнем читать то мы опяжть же получим то что ранее записали. так устроены
обычные файлы! 

а пайпы и сокеты устроены по другому.  это труба с двумя дырками.
тоесть есть имя файла через который можно записать и есть дрвгое имя файла откуда можно
то что втрубе есть считать. более того
они особенны тем что если я чтото записал в один файл на этой стороне дырки 
то ядро это удаляет из этого файла и записывает это вдругой файл.
если я с этой стороны дырки чтото туда записал то чиатть с этой стороны нет смысла
в этом файл уже ничего нет. надо читать другой файл тот который служит второй дыркой трубы.
поэтому если я читаю чтото из файла то это было засунуто в эту трубу с той стороны дырки.
это важно понимать потому что прикол еще в том что ряд таким спецффайлов наример файл тер
минала позволяет нескльким процессам подключаться с одной стороны дырки. причем один процесс
читает из нее а второй пишет.

если я будут читаь с этой стороны дырки то байты которые я прочитаю они будут только те
которые  были всунуты с той строны дырки не смотрят на то что даже есть процес который в это
время пихает байты с нашей стороны трубы!


если я чтот вснул в pts/10 и начну читать из pts/10 то я нчего не проитаю потмоу ч
то вс уже уделетло на тот конец трубы в dev/ptmx 
а если я читаю и чтот получаю то это тлоько то что быо всунуто  в трубу со стороыны /dev/ptmx!
поэтому ессли два процесса открытли pts/10 и один туда пишет а второй сразу чиатет то тот кто 
читает он ничего не получит из того что туда записал процесс2! потмоу что все что было 
запиано процессом2 улетело в /dev/ptmx!
а вот если оба проецесса читают один конец дырки то они будут конкуиовать за одни 
и теже байты котоыре суются со сторны дырки /dev/ptmx!
поэтому если у мня есть окно терминала и есть баш который связан с этим терминалом и я хочу  
всунуть в баш данные внутрь его памяти  то нужно либо тыкать кнпоки на клаве термнала. 
либо нужно совать данные в /dev/ptmx. кстати говоря несколько процессов могут успешно 
откыть одновременно файл /dev/tty2 либо /dev/pts/10 но откыть файл /dev/ptmx сразу одновременно
нескольким процессам неполучится нельзя!  поэтому насовать в /dev/ptmx байтов от имени 
друого процесса не полуится! только оригинаный процесс который первым открыл /dev/ptmx толкьо
он сможет насовать данные в него.

тут я уточню что чисто фрмально два процесса могут открыть одвноменно файл /dev/ptmx
но это супер хитрый файл. это так называемый мультиплкс файл. тость ябы сказал так что
если два процесса ткрывают этот файл то они как бы открывают оба кадый свою копию этого 
файла. поэтому невзможно так сделать чтобы два процесса открыли одну и туже копию этого файла.
поэтом и неполучтся чтобы два процесса окрыли этот файл. пихали туда данные и они летели
водно и тоже место!
поэтому можно найти кучу прцоссов кждый из которых имеет открытым якобы один и тот же 
файл /dev/ptmx но это очереодное наеоаблово от ядра. на сама деле они имею открытыми 
каждый свою отдельную независимую копию этого файла. тоесть по факту все они работают
с разными файлами. вот такой  дебилизм.   это похоже на то как куча клиенто стучится 
на порт 80 на нашем компе. и под кждый порт создается в итоге свой индиидиуальный сокет.
хотя каждый сокет обслуживает пакет на порту 80.



кстати если я вижу у процесса есть открытый файл  /dev/ptmx то 
как найти тот процесс который открыл  слейв файл /dev/pts/N 
насколько я знаю  в целом с помщью утилит из юзерспейса никак не определить.
из си кода для этого используется спецаильная фнкция


       ptr_sln = ptsname(md);


единсвтеннео что чаще всего процесс который открыл /dev/pts/N от этого /dev/ptmx он 
явялется дочерним для этого процесса. чаще всего это так но необязательно!
но даже если этот процесс явялется дочерним то может так слуится что наш процесс открыл
неслкько /dev/ptmx файлов. тоесть создал несколько терминалов. поэтому у него будет
куча дочерних процесов  с /dev/pts/N файлоами. и какой дочений процесс именно связан с 
конкнетно этим /dev/ptmx опять хрен знает как опредеить. шас покадзываю на прмире. 
берем gnome-termnal-server процесс


  $ lsof -Pn -p $(pidof gnome-terminal-server) 2>/dev/null | tail -n 15 | grep ptmx
gnome-ter 1774 noroot 213u      CHR                5,2      0t0       115 /dev/ptmx
gnome-ter 1774 noroot 215u      CHR                5,2      0t0       115 /dev/ptmx
gnome-ter 1774 noroot 217u      CHR                5,2      0t0       115 /dev/ptmx
gnome-ter 1774 noroot 222u      CHR                5,2      0t0       115 /dev/ptmx

вот видно что  у него аж 4 таких файла.  значит у него 4 дочерних процесса bash
сотввтенно какой из дочерник башев связан с каким конкретно /dev/ptmx файлом хрен 
знает как определить на основе утилит из юзер спйеса.
UPDATE: я нашел как это определить. надо открыть файл описание к этому /dev/ptmx
файлу. пример берем дескприптор 213 и читаем его свойства

     $ cat /proc/1774/fdinfo/213
pos: 0
flags:    02104002
mnt_id:   27
ino: 115
tty-index:     121


насолкьо я понимаю данный /dev/ptmx связан с /dev/pts/121
тперь читаю 215,217,222

  $ cat /proc/1774/fdinfo/215  | grep tty
tty-index:     123
  $ cat /proc/1774/fdinfo/217  | grep tty
tty-index:     125
흂  $ cat /proc/1774/fdinfo/222  | grep tty
tty-index:     126


так что ПОХОЖЕ РЕШЕНИЕ НАЙДЕНО!


получается что в /proc  файл /proc/pid/fd/N  он показывает имя номера десприптора.
так как N это символический файл то то куда он указывает это имя файла на фс на который 
укзаывает тело файл дескприттора 

  $ stat   /proc/1774/fd/213
  File: /proc/1774/fd/213 -> /dev/ptmx

а содержимое файла

 /proc/pid/fdinfo/213

оно показывает другие подробности тела файл дескпритора! 
по мне опять же сделано дебильно.  получается что информация о файл дескприорре разбросана
по двум папкам и двум файла

     /proc/pid/fd/N
     /proc/pid/fdinfo/N



следущий момент
вот как выглядит на языке си создание нового терминала нового поколения

  md = open("/dev/ptmx", O_RDWR | O_NOCTTY);
  int sl1 = -1;
  sl1 = grantpt(md);
  sl1 = unlockpt(md);

это означает что просто открыть /dev/ptmx это еще не дает вомзжность работать 
с этим терминалом. поэтому напрмиер cat нам непозволит работаьт с терминалом . щас покажу.
вот берем cat

     $ cat /dev/ptmx

по своей сути cat сделать только open() и больше ничего.
приметчально то что как только юзер процесс делает open(/dev/ptmx) то ядро мгнвоенно 
создает новый /dev/pts/N и мы щас его найдем
находим pid нашего процесса cat

  $ ps aux | grep cat | grep ptmx
noroot   2921286  0.0  0.0   5820  1776 pts/130  S+   17:59   0:00 cat /dev/ptmx

теперь ищем номер дескприора который ответчает за откртый ptmx файл

$ lsof -Pn -p 2921286 2>/dev/null | tail -n4
cat     2921286 noroot   0u   CHR 136,130      0t0       133 /dev/pts/130
cat     2921286 noroot   1u   CHR 136,130      0t0       133 /dev/pts/130
cat     2921286 noroot   2u   CHR 136,130      0t0       133 /dev/pts/130
cat     2921286 noroot   3r   CHR     5,2      0t0       115 /dev/ptmx

это номер 3
теперь читаем свойства этого  дескрпиоора

  $ cat /proc/2921286/fdinfo/3
pos: 0
flags:    0100000
mnt_id:   27
ino: 115
tty-index:     131

значит видно что второй файл это /dev/pts/131
проверяем что такйо файл есть

  $ ls -1al /dev/pts/131
crw--w---- 1 noroot tty 136, 131 дек  1 17:59 /dev/pts/131

да он есть.
теперь я пробую записать "123" в этот файл чтобы ядро пребросило это в /dev/ptmx
и cat нам это нарисовал 

$ echo "12345" > /dev/pts/131
bash: /dev/pts/131: Input/output error

и от мы получаем ошибку. все верно. потому что cat он не сделлал все операции которые нужны
чтобы вся эта шармнка заработала
из нужных команд

  md = open("/dev/ptmx", O_RDWR | O_NOCTTY);
  int sl1 = -1;
  sl1 = grantpt(md);
  sl1 = unlockpt(md);


наш cat сделал тлько open() , поэтому со стороны /dev/pts/131 запись ровно как и чтение
будет зарпщено. тоесть термиал как бы создан. но он "невключен". поэтому ядро шлет нахрен
со стороны /dev/pts/131

а теперь я возьму уже прогрмму на си которая сделает все что надо это 253.с
 K 戴  $ cat 253.c
#define _XOPEN_SOURCE 600
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/wait.h>


int main()
{

  pid_t pid_p = getpid();
  printf("parent PID = %d\n", pid_p);


// открывваю и активирую терминал
  int md = -1;
  md = open("/dev/ptmx", O_RDWR | O_NOCTTY);

  int sl1 = -1;
  sl1 = grantpt(md);
  sl1 = unlockpt(md);


// узнаю номер pts/N
  char * ptr_sln = NULL;
  ptr_sln = ptsname(md);
  printf ("pts name = %s\n", ptr_sln);



// читаю из ptmx
  char buffer[256];
  int len = read(md, buffer, sizeof(buffer) - 1);
     if (len > 0) {
            buffer[len] = '\0';  // Null-terminate the string
            printf("READ DATA FROM /dev/ptmx : %s", buffer);
     }



  close (md);



exit (0);


}


запуска прогрмму смотрю на экран

  $ ./253.exe
parent PID = 2923152
pts name = /dev/pts/132


ищу чему равен pts/N используя инфомрацию из дескпритоора в процессе 253.exe

  $ lsof -Pn -p $(pidof 253.exe) 2>/dev/null | tail -n6
253.exe 2923152 noroot   0u   CHR 136,131      0t0       134 /dev/pts/131
253.exe 2923152 noroot   1u   CHR 136,131      0t0       134 /dev/pts/131
253.exe 2923152 noroot   2u   CHR 136,131      0t0       134 /dev/pts/131
253.exe 2923152 noroot   3u   CHR     5,2      0t0       115 /dev/ptmx


посморим свойства дескрпитора 3. найеем там номер pts/N
 M   $ cat /proc/$(pidof 253.exe)/fdinfo/3  
pos: 0
flags:    0100002
mnt_id:   27
ino: 115
tty-index:     132

как видим  pts/132 совпал и там и там. 

теперь подключмся к терминалу со стороны /dev/pts/132 и пихнем туда "1234"
я ожиадаю что процесс запси будет на этот раз успешным. что ядро драйвер теминала
возьмем то что лежит в /dev/pts/132 и пееренест в /dev/ptmx нашей проги 253.exe 
и она нам это вывдет на экран потому что она сидит и читает то что лежит в /dev/ptmx
открываю другой черное окно и там запускаю

$ echo "12345" > /dev/pts/132

а в окне где запущен 253.exe  я вижу

  $ ./253.exe
parent PID = 2923152
pts name = /dev/pts/132
READ DATA FROM /dev/ptmx : 12345    <==== !!!!

тоесть все сработало
офигенно

ну кстати в случае команды echo ели мы хотим передать ее вывод другому процессу то
конечно термиал ненужен. и прдойдет простой pipe

  $ echo "1234" | программа1

тоесть исолтзоване термианла чтобы прееать данные из команды echo в какую то друную программу
это overkill.  зато позвояет все хороо понять.  а вот если мы хотим из процсса bash передать
чтото в  другой процесс1. вот тогда то между процессом1 и bash и нужно поднимать терминал.
потому что bash  в отичие от echo при своей работы помешан на работе с темриналом.


далее. 
теперь понятно что есть есть два любых процесса например путь это даже два cat
и они оба открывают /dev/ptmx то каждый из эьтих ptmx будет смотреть на свой индифиуадьный pts/N
а вот вопрос а если я одним cat открою /dev/ptmx а вторым cat открою дескпритор который
на него указывает, что тогда ?
смотрим
запумкаю первый cat , выянсяю его pid, и выясяю номер pts/N

     $ cat /dev/ptmx

     $ pidof cat
     2924435

     $ lsof -Pn -p $(pidof cat) 2>/dev/null | tail -n4
cat     2924435 noroot   0u   CHR 136,122      0t0       125 /dev/pts/122
cat     2924435 noroot   1u   CHR 136,122      0t0       125 /dev/pts/122
cat     2924435 noroot   2u   CHR 136,122      0t0       125 /dev/pts/122
cat     2924435 noroot   3r   CHR     5,2      0t0       115 /dev/ptmx

     $ cat /proc/$(pidof cat)/fdinfo/3
pos: 0
flags:    0100000
mnt_id:   27
ino: 115
tty-index:     125


итак перый cat  его ptmx укзвыает на pts/125

теперь берем второй cat и открываем десприпттор 3 у этого ката

     $ cat /proc/$(pidof cat)/fd/3

смоитрим на этот второй cat

  $ lsof -Pn -p 2924684 2>/dev/null | tail -n5
cat     2924684 noroot mem    REG   254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
cat     2924684 noroot   0u   CHR 136,126      0t0       129 /dev/pts/126
cat     2924684 noroot   1u   CHR 136,126      0t0       129 /dev/pts/126
cat     2924684 noroot   2u   CHR 136,126      0t0       129 /dev/pts/126
cat     2924684 noroot   3r   CHR     5,2      0t0       115 /dev/ptmx

видим что кат открыл  в итоге не файл /proc/$(pidof cat)/fd/3 а файл /dev/ptmx
посмтрим теперь на какой pts/N укзвыаемт наш второй кат

 ⹦  $ cat /proc/2924684/fdinfo/3
pos: 0
flags:    0100000
mnt_id:   27
ino: 115
tty-index:     127

итак он узкывает на /dev/pts/127

поэтому без разница что откывтаь /dev/ptmx что откывать на /proc файл коорый на него 
укзывате. в итоге одно и тоже. 
таким образом если у нас есть поцесс у него октрыть /dev/ptmx файл и мы хотим ккакто 
перхватить то что в этот процесс из этого файла приелает путем того что мы сделаем

  $ cat /proc/pid/fd/N

у нас нихена не получится таким путем чтото перехватить!
ксатти  я подумал вот о чем у нас файл 

     /proc/pid/fd/N
это симлинк

соовтетенно у меня вопрос а какой файл открыватся кода мы открываем симлинк? сам файл
симлинка или файл на который укзывает симлинк?
написал прогу 254.c


  $ cat 254.c
#define _XOPEN_SOURCE 600
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/wait.h>

int main()
{

  pid_t pid_p = getpid();
  printf("parent PID = %d\n", pid_p);


  int md = -1;
  md = open("/home/noroot/temp/nc", O_RDONLY);

  sleep(120);
  close (md);


exit (0);


}



а вот рузальтатт

뙁  $ lsof -Pn -p 2925891 2>/dev/null | tail -n5
254.exe 2925891 noroot   1u   CHR 136,118      0t0       121 /dev/pts/118
254.exe 2925891 noroot   2u   CHR 136,118      0t0       121 /dev/pts/118
254.exe 2925891 noroot   3r   DIR   254,0     4096 549482395 /home/noroot/temp/nc

как видим в итоге открыватся файл НА которйы указывает симлинк. поэтому понятно
что если у нас есть процесс у котрого 0--->/dev/ptmx то если мы октрываем файл через
путь "/proc/pid/fd/0" то по факту в итоге ядро открывает файл /dev/ptmx !


далее  я сделал что один сиклинк указываем на дрйго симлинк а уже тот на обычный файл

  $ ls -1al vasya*
lrwxrwxrwx 1 noroot noroot  6 дек  1 18:45 vasya -> vasya2
lrwxrwxrwx 1 noroot noroot 12 дек  1 18:45 vasya2 -> ./index.html

тоесть

 vasya --> vasya2 --> index.html


запускаю прогрму повторно

 * 뇃  $ lsof -Pn -p 2926685 2>/dev/null | tail -n5
254.exe 2926685 noroot   1u   CHR 136,118      0t0       121 /dev/pts/118
254.exe 2926685 noroot   2u   CHR 136,118      0t0       121 /dev/pts/118
254.exe 2926685 noroot   3r   DIR   254,0     4096 549482395 /home/noroot/temp/nc

сотвтственно в итоге ядро "раскрывает" всю цеопчку симлинков  и открывает конечный файл.
вроде я читал что макмисуму длинна цеопопчки симлинков может быть 127 штук. небольше

  sym1-->sum2-->,,,,,->sym127-->file1

----

следущий момент
а вот локальный юникс сокет(он называется named unix socket) на основе  файл на диске 
хотя якобы два проецесса подключены к одному файлу

во первых вопрос а как создать на диске named unix socket по аналогии с командой mkfifo?
крактик ответ - такой команды нет
ответ нашел здесь

     https://serverfault.com/questions/358866/create-unix-named-socket-from-the-command-line


There is no exact equivalent of mkfifo for socket, i.e. there is no command 
that just creates a "hanging" socket. This is for historical reason: 
server's function bind(), the one that creates a socket name/inode in the filesystem, 
fails if the name is already used. In other words, server cannot operate on
 a pre-existing socket.
So if you'd created socket earlier, it would need to be removed by the server
 anyway first. No benefit. As you see with Gregory's answer, 
 you can create a socket IF you keep a server for it, such as netcat. Once a 
 server is gone, the old socket is gone. A new server has a new socket, 
 and all clients need to re-connect, despite the socket's name being identical.

кастати я думаю это отчатси уже неерно потому что если мы заюзем флаги REUSADDR и REUSEPORT
то можно создавать несклько сокетов которые имеют одинаковый bind() я это рассматриваю
в другом месте щас на это не буду фиксировтаься.


  $ ps aux | grep nc | grep un2
noroot   2819780  0.0  0.0   3160  1540 pts/106  S+   05:44   0:00 nc -l -U ./un2
noroot   2819783  0.0  0.0   3160  1496 pts/108  S+   05:44   0:00 nc -U ./un2

посмтрим ксатти как созадатеся сокет этот 
     socket(AF_UNIX, SOCK_STREAM, 0)         = 3
     unlink("./un4")                         = 0
     bind(3, {sa_family=AF_UNIX, sun_path="./un4"}, 8) = 0
     listen(3, 5)                            = 0
     accept4(3, ...)

что приколно при остатнвоке процесса файл сокета все равно осатется на диске.
но поклчаться к нему бесполезно если сервеный процесс умер
       $ nc -U ./un4
     nc: ./un4: Connection refused

а вот как выглядит успешный конект
     socket(AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0) = 3
     connect(3, {sa_family=AF_UNIX, sun_path="./un4"}, 8) = 0



так ладно мы щас о другом размышляем

берем два процесса один из создал неймед сокет вторй подключился

noroot   2928531  0.0  0.0   3160  1316 pts/116  S+   19:02   0:00 nc -l -U ./un4
noroot   2928558  0.0  0.0   3160  1536 pts/121  S+   19:02   0:00 nc -U ./un4

посмтрим параметр самого un4 файла 
$ stat ./un4
  File: ./un4
  Size: 0           Blocks: 0          IO Block: 4096   socket
Device: 254,0  Inode: 549482403   Links: 1


заглядываем в первый процессс

$ lsof -Pn -p 2928531 2>/dev/null | grep STREAM
nc      2928531 noroot   3u  unix 0x000000008549db68      0t0  33095905 ./un4 type=STREAM (LISTEN)
nc      2928531 noroot   4u  unix 0x0000000000194c5a      0t0  33095906 ./un4 type=STREAM (CONNECTED)

меня итересует только тот дескпритптор который CONNECTED тоесть 4

   $ ls -1al /proc/2928531/fd
lrwx------ 1 noroot noroot 64 дек  1 19:04 4 -> 'socket:[33095906]'


    $ stat /proc/2928531/fd/4
  File: /proc/2928531/fd/4 -> socket:[33095906]
  Size: 64          Blocks: 0          IO Block: 1024   symbolic link
Device: 0,23   Inode: 33098987    Links: 1


смотим какую еще инфо можно вытащить про дескпритор 4
  $ cat /proc/2928531/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 33095906
scm_fds: 0

значит еще раз посмотрим на сам файл un4
$ stat ./un4
  File: ./un4
  Size: 0           Blocks: 0          IO Block: 4096   socket
Device: 254,0  Inode: 549482403   Links: 1

как видно его размер на диске это 0 блоков. то есть у него нет тела. а вся его инфо
находится в иноде.  номер этой иноды на диске это 549482403 
тоесть у нас прям на жесктом диске берется инода с номерм 549482403 и в ней записаывается
все данные нового файла. там записывается что это непросто обычный файл который будет иметь
тело на этом жестком диске. это будет файл но без тела. и что типа сокет файл. 
насклько я понимаю на диске этот файл создается командой bind()

     bind(3, {sa_family=AF_UNIX, sun_path="./un4"}, 8) = 0

именно ее применение вдеет к тому что ядро создает этот файл на ФС. 
я полагаю но не могу проверить то что при этом именно в саму иноду записывается номер
сокета. но как это прочитать из ФС непонятно. видимо только через debugfs. потому что 
если я попробую сделать cat ./un4 то ядро пошлет меня нахер.
тогда вторая программа когда стартует и делает connect()

     connect(3, {sa_family=AF_UNIX, sun_path="./un4"}, 8) = 0

то тогда ядро реально читает сдиска файл un4. 
насколько я понимаю исходя из вот этого листинга


   $ ls -1al /proc/2928531/fd/4
lrwx------ 1 noroot noroot 64 дек  1 19:04 4 -> 'socket:[33095906]'


    $ stat /proc/2928531/fd/4
  File: /proc/2928531/fd/4 -> socket:[33095906]
  Size: 64          Blocks: 0          IO Block: 1024   symbolic link


и особенно вот этого

 $ cat /proc/2928531/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 33095906
scm_fds: 0

где мы видим  ino: 33095906, что  число 33095906 это номер иноды на файловой системе 
где то там внутри ядра. 
тоесть дескрпитор 4 процесса это симлинк, в симлинке всегда пишется ИМЯ файла на файловой
системе. НО! получается что тело дескпритоора 4 указывает не файл у которого нет имени!
а есть только инода. поэтому когда нам ls  или stat (  а по факту они юзают одинаковый
сисколл) пытается нарисовать имя файла на который симлинк указывает то ненаходит никаого имени
и вместо него рисует номер иноды. и еще помечает нам какой тип файла имеет файл сохраенный 
в этой иноде. потому что у нас бывают разные типы файлов  - обычные сокет итп.

     /proc/2928531/fd/4 -> socket:[33095906]


тоесть я щас себе вижу этот все вот так:
процесс1  запускает фнукцию bind()

     bind(3, {sa_family=AF_UNIX, sun_path="./un4"}, 8) = 0

тогда ядро создает на жесктом диске на реальном жесктом диске реальный файл  который занимает
на жесктом диске иноду, который имеет имя которрое прописывается в папку. едиснвтенное что 
это файл без тела. поэтому он имеет имя. он занимает иноду. и внутри этой иноды там всегда
укзыается какйотип файла. и там указывается что это файл-сокет. подчеркну то что файл-сокет
это абсолютно реаьльный файл на жеском диске, он имеет имя которое пропиано в папке. он занимает
иноду на жесктом диске. единсвтеное что у него нет тела. он пусто в плане тела. но в иноде
записано что это файл-сокет , я считаю что в иноде а ее номер 549482403 на жестком диске 
ядро записвыает ДРУГОЙ НОМЕР ДРУГОЙ ИНОДЫ. дело в том что параерльно с созданием этого файла
на реалном жектом диске bind() также создает внутри ядра на какойто там внутрней ФС еще
один файл который там не имеет имени но тоже там занимает иноду и тоже там тот файл имеет 
тип. тот файл тоже имеет тип сокет и в том файле указаны какето параметры неймд сокета.
что за параметры там указаны мы незнаем. файл на жектом диске используется тлько как я понимаю
для того чтобы клиент который хочет подключться к этому неймед сокету узнал номер иноды в котрой
хранится сокет файл вот там внутри ФС. тоесть у нас bind() он с одной стороны сздает файл на 
жестком диске а сдругой создает файл где то в потрохах ядра.  и в файле на жесктом диске ядро
сохраняет адрес файла на фс внутри ядра.   и также bind() приводит к тому что он создает
файл дескприптор 4  для этоогоо процесса и в этом десприптторе указвыает файл именно на фс
ядра

     /proc/2928531/fd/4 -> socket:[33095906]


 $ cat /proc/2928531/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 33095906
scm_fds: 0


тоесть сам файл un4 для него bind()  несоздает файл дескпритор который бы вел именно на un4
нет. бинд создает файл дескприттор котоырй ведет именно на файл внутри ФС ядра. этот файл неимеет
имени.он имеет тлько иноду 33095906
тоесть вот эти две хрени

     /proc/2928531/fd/4 -> socket:[33095906]


 $ cat /proc/2928531/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 33095906
scm_fds: 0


они и показвают то что у нас для этого процесса создан в ядре дескрпитор. он имеет имя 4.
и он укзаывает на файл с инодой номер 33095906, данный файл не имеет имени поэтому
в симлинке в котоом ядро обычно указыает имя файла вместо имени стоит толко номер иноды.
я вот думаю если взять обычный файл на жеском диске. потом создать для него симлинк.
а потом взять и у этого файла удалить имя из иноды которая за папку отвечает - что тогда
будет показвыать симлинк? будет ли он она тоже покзавать только номер иноды? но мне кажетя что 
на обычнофс если удалить имя файла то фс автоматом удалить и саму иноду от этого файла. поэтому
на обычной фс такой номер не проакакти мне кажется.
поэтому там где у нас симлинк у нас вместо имени которооого нет показывает номер иноды файла
и его тип. тип сокет показывается не того файла котоыйр на диске! а того файла которыйлежит
гдето внутри фс ядра! 

получается интерсная ситация мы указали bind() реальыйн файл на жекстокм диске
а он в итоге для процесса открыл файл совершенно другой тот который на фс внутри ядра.
а файл на жеском диске как бутто не сущетвует. по крайней мере проецесс с ним никак не связан
потому что он неоткрыт

  $ lsof -Pn -p 2928531
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
nc      2928531 noroot   4u  unix 0x0000000000194c5a      0t0  33095906 ./un4 type=STREAM (CONNECTED)

вот нам lsof риусет что якобы 4 дескпритор указыет на файл котоырй имеет имя un4
я считаю что это полная брехня. 
потому что если мы посмрим на свойства этого деспритора 4

 $ cat /proc/2928531/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 33095906
scm_fds: 0

то мы видим что дескприттор укзывает на файл с инодой 33095906 
а если бы дескпритор укзаывал на файл un4 то номер этой иноды был бы  549482403 !
что легко видно отсюда
  $ stat un4
  File: un4
  Size: 0           Blocks: 0          IO Block: 4096   socket
Device: 254,0  Inode: 549482403   Links: 1


насолько я понимаю что ядро создало файл но не на диске арелаьно гдето внутри своих кишок
- файл в памяти. и так как фс внутри ядра тоже имеет иноды то тот файл занимает иноду 
с номером 33095906


более того у нас же у сервеного процесса у него пока клиент не подклчться будет 
также слушающий сокет

  $ lsof -Pn -p 2928531
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
nc      2928531 noroot   3u  unix 0x000000008549db68      0t0  33095905 ./un4 type=STREAM (LISTEN)
nc      2928531 noroot   4u  unix 0x0000000000194c5a      0t0  33095906 ./un4 type=STREAM (CONNECTED)

так вот для этого сокет тоже будет создан внутри ядра файл и вот даже видим номер 
его иноды в которой он лежит 33095905
щас проверим
  찮  $ cat /proc/2928531/fdinfo/3
pos: 0
flags:    02
mnt_id:   10
ino: 33095905
scm_fds: 0

видим так и есть. 


я думаю на диске в файле un4 записано именно вот это число 33095905
посмтреть это наряую нельзя только если через debugfs както скачивать содержимое иноды 549482403
и там внутри нее искать число  33095905

так еще раз посмотрим на эту штуку

  $ lsof -Pn -p 2928531
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
nc      2928531 noroot   3u  unix 0x000000008549db68      0t0  33095905 ./un4 type=STREAM (LISTEN)
nc      2928531 noroot   4u  unix 0x0000000000194c5a      0t0  33095906 ./un4 type=STREAM (CONNECTED)

тоесть мыимеем
  4---> 33095906

насколкьо я понимаю когда мы потом в процессе заюзаем комнду
 
 write(4,&buf1...)

то ядро возьмем данные из памяти нашего прцесса по адрему &buf1 и запищет их в файл 
внутри ядра на фс в файл который лежит в иноде  33095906 
тоесть при команде запис данные из паяти процесса переноссятся в некоторый файл внутри ядра
и там сохраняются. 

посмотрим на процесс клиент

  $ lsof -Pn -p 2928558 
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
...
nc      2928558 noroot   3u  unix 0x000000005ad0b0e9      0t0  33094964 type=STREAM (CONNECTED)

  $ 
 _ 捺  $ cat /proc/2928558/fdinfo/3
pos: 0
flags:    02000002
mnt_id:   10
ino: 33094964
scm_fds: 0


полуается что команда connect() она в итоге создала на фс внутри ядра файл  сномером
иноды  33094964, потом создала десппттор с номером 4 котоый смотрит на этот файл.

в итоге получетс вот такая схема


                          
                          |      ЯДРО              |
процесс-сервер fd/4 ------ 33095906, ядро, 33094964 ------ fd/3 клиент-процесс



получается что когда процес-сервер пишет в файл на который указвыает деспритор 4

   write(4, &buf1,15)

то ядро берет байты из памти процесса и пишет их в файл котоый не имеет имени и лежит 
на фс внутри ядра. видимо файлы на фс нутри ядра неимеют имен ибо ядерный код он же к файлам
в реалности доступ делает по инодам поэтому ядерному коду имена к файлам ненужны поэтому внутри
фс внутри ядра имен у файлов нет. и ядро запиывает байты из памяти процесса в файл который
хранится в иноде 33095906 внутри ядра.  далее само ядро берет из этого файла 33095906 байты
и кпирует их в другой файл внутри фс ядра с номером  33094964  а в файле 33095906 их стирает.
далее клиент-процесс когда говорит

     read(3,&buf2,)

то ядро берет байты из файола котоырый хранится в иноде  33094964 внутри ядра и копирет
их в память поцесса начиная с адреса &buf2

вот походу как это устроено и что значать эти загоднчные цифры    33095906  33094964
в свойтсвах файл дескрпитора. ксати само навзание файл дескприор опять же доказывает что 
дескпрттор 4  и дескпитр 3 указыают именно на файлы! а не на чттото другое. просто эти файлы
лежат на на диске а внутри фс внутри памяти ядра! но это теже самые файлы!!
поэтому получается что unix named socket это сука ни что иное как просто напросто два файла
которые созданы внутри памяти ядра. и больше ничего такого особенного и загадочного!
а на диске по всей видимосои в файле un4 запмывается номер иноды файлу слушающего сокета 33095905
чтобы кога процесс клиент обращается к файлу un4 через connect то ядро бы которое исполняет
код connect() почитало бы из un4 номер файла 33095905 и на основе этого поняло бы к КАКОМУ 
ПРОЦЕССУ нужно подключать наш процесс клиент. 

потому что как походу вся эта шарамканка рабоает.
вот nc-сервер запускает 
  
     bind (un4)

тогда ядро создает внури ядра файл усолвно в иноду 11. это слушающий сокет.
и ядро создает на диске файл un4 и туда запиывает число 11.
далее  nc-клиент хочет подклчаться к этому процессу и он делает

  connect(un4)

тогда ядро читает un4 видит там число 11. понимает что файл 11 принадлежить прцоессу nc-сервер.
тогда ядро создает внутри ядра файл 12 и 13.  далее ядро создает файл дескпртттор 4 у
nc-сервер котоырй укаывзает на файл 11 и создает файл деспритор 3 в nc-клиент который указвакет
на файл 12.


nc-сервер fd\4----- дескприпттор 4----> 11,  ядро, 12<-----дескпритор 3-------fd\3nc-клиент

деспитторы 3 и 4 , файлы 11 и 12 все эта хрени которые лежат внутри ядра.
в процессах леажт только цифры 3 и 4 ккоторые кодируют навзания дескпритров лежащих в ядре.
таким образом ядро ссмогло понять какие два процеса надо связать. создало внутри ядра
два файла 11 и 12.  и также настроило такую хрень что если чтото влетает  в файл 11 то 
это надо скпиватть в файл 12 а то что было в 11 стееть и наоброт. 

вот мы и полуили связь через юникс неймд локльный сокет!!!!

далее. socketpair() на выхлопе работает точно также. только нахен ненужен файл на диске!
потоому что мы как бы связываем процесс сам с собой. и слушающий сокет тоже ненужен поэтому.
прото на выходе ядро даст файлы 11 и 12 и десприторы 4 и  5 которые будут привязаны к одному
и тому же процессу!!

cдругой стороны именнлваный сокет  дает воможность иметь много конектов одному процессу
за счет слушающего сокета! а socketpair() дает один конкретный конект!

получсется socketpair() блоьше подходит для процесса который хочет настогать детей  и с ними
уствновить с каждым конект.  
а именованный сокет подходит для процесса который хочет чтобы левые процессы с ним не связанные
могли бы с ним связываться. 

рассмотрим пайп коооый  я думаю работает точно также. я даже больше скажу он рабатет 
ттчно также как socketpair() только позволет делать односторонннюю связь.

     $ sleep 120 | sleep 160


       $ lsof -Pn -p 2935540
...
sleep   2935540 noroot   1w  FIFO    0,15      0t0  33129079 pipe



  $ stat /proc/2935540/fd/1
  File: /proc/2935540/fd/1 -> pipe:[33129079]


  $ cat  /proc/2935540/fdinfo/1
pos: 0
flags:    01
mnt_id:   16
ino: 33129079


вот мы и видим все тоже самое.   у нас процесс имеет дескприттор 1  он лежит в ядре.
и он там указывает на файл который не имеет имени а имееттолько иноду номер   33129079

поэтому когда stat либо ls будет пытаться найти имя файла которые содержисят в симлинке fd/1
то имени то нет поэтому будет нарисвано номер иноды того файла и тип файла

          pipe:[33129079]

ровно также как мы имели с сокетом

          socket:[33095906]


едивнненое что отличается это вывод lsof права часть для пайпа он пишет слово пайп

       $ lsof -Pn -p 2935540
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
...
sleep   2935540 noroot   1w  FIFO    0,15      0t0             33129079 pipe



а для сокета он пишет 

  $ lsof -Pn -p 2928558 
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
...
nc      2928558 noroot   3u  unix 0x000000005ad0b0e9      0t0  33094964 type=STREAM (CONNECTED)


тоесть еще раз для пайпа он пишет в колонке NAME

NAME
pipe

а для сокета в этой колоке он пишет

NAME
type=STREAM (CONNECTED)

что по мне уебанство . потому что в поле NAME надо писать имя файла. а такак его нет
нахуй там чтото писать тогда?

по поводу фразы 

     type=STREAM (CONNECTED)

в ней указано получается что деспртор укзывает на файл который в итоге как  я понимаю 
связан с сокетом. тоесть тут непонятно то ли файл лежащий внутри фс ядро это уже и есть 
та самая структура в памяти сокет. то ли за этим файлом где то там лежит сокет а файл
это просто некий фронтент от этого сокета. но в итоге в этой строке указан тип сокета 
что у него тип STREAM а не датаграм.  потому что всопним что при создании неймд сокета
прежде всего используется команда 

     socket()

а при создании пайпа такого неиего нет. исопзуется вызов

     pipe()

тоесть сокет невзывается при этом.

ксати аналог неймд сокета у пайпа это неймд пайп. потому что он тоже тода на диске создает
файл тип пайп.  ровно также как для сокета мы создаваили файл un4

интесно то что в сулчае именнового пайпа у нас как я понимаю в пмяти ядра создатся на фс
некий файл но он не свзяан ни с каким процессом. и этот номер файла видимо завпиывается на 
пайп файл на диске. и тога будет такая схема:

     $ strace mkfifo fifo2
          mknodat(AT_FDCWD, "fifo2", S_IFIFO|0666)

при этой команде ядро гдето внутри себя на фс создал файл. но мы его иноду пока незнаем
и записало ее в файл fifo2. прочиать ее неареаьно только если через debugfs.
что делает команда mknodat - она позволяет создавать пустые файлы! тоесть  я то думал что 
пустые файлы можно создвать через open() но опен он нетлько создает файл но и его открывает.
а mknodat он позволяет файл только создать но его не открывать приколно я незнал!(man mknodat)


далее мыделаем

      $ echo 123 > ./fifo2


а дальше я открыл прикол. если запусить эту команду то в списке процессов ты ненайдешь 
процсс echo. почему? потому  что как раотает баш? если мы задаем перенарпавление ввода вывода
то баш в рамках ТЕКУЩЕГО процесса вначале открывает тот файл который ты указал. только потом
он себя клонирует. там перестаавлят десприторы чтобы скажем у нас не дескпрттторп 4 указывал
на fifo2 а дескпрттор 1 и потом делает execve()
ТАК ВОТ! при попытке открыть fifo2 операция open() она блокируется! тоесть баш висит и ждет
пока файл откроется а он не открыается. он откроется толко кога я в другом термиале вторым
процессом тоже открою этот файл

  $ cat ./fifo2

вот только тогда вся эта шарманка начнет шевелится!

тогда мне чтобы все остлеить нужна саписная програма котораы откраывает файл. пишет туда
незакрывать и спит. и вторая которая открывает читает. незакрывает и спит. тогда мы 
все посмотрим. две прогарммы 255.c и 256.c


 흦  $ cat 255.c
#define _XOPEN_SOURCE 600
#define _POSIX_C_SOURCE 200809L
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/wait.h>



int main()
{

  pid_t pid_p = getpid();
  printf("parent PID = %d\n", pid_p);


  int md = -1;
  md = open("/home/noroot/temp/nc/fifo2", O_WRONLY);

  dprintf (md, "hello vasya\n");
  sleep(120);
  close (md);



exit (0);


}




 栟  $ cat 256.c
#define _XOPEN_SOURCE 600
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/wait.h>




int main()
{

  pid_t pid_p = getpid();
  printf("parent PID = %d\n", pid_p);


  int md = -1;
  md = open("/home/noroot/temp/nc/fifo2", O_RDONLY);

// читаю 
  char buffer[256];
  int len = read(md, buffer, sizeof(buffer) - 1);
     if (len > 0) {
            buffer[len] = '\0';  // Null-terminate the string
            printf("READ DATA FROM md : %s", buffer);
     }



  sleep(120);
  close (md);



exit (0);


}


запускаем обе. естетенно что надо чтобы файл fifo2 был создан заранее
через 

     $ mkfifo fifo2



смоиитрим чтотам  с фалйами у обоих прцесов

  $ lsof -Pn -p 2939045
COMMAND     PID   USER  FD   TYPE  DEVICE SIZE/OFF      NODE NAME
255.exe 2939045 noroot   3w  FIFO   254,0      0t0 549482381 /home/noroot/temp/nc/fifo2

  $ lsof -Pn -p 2939049
COMMAND     PID   USER  FD   TYPE  DEVICE SIZE/OFF      NODE NAME
256.exe 2939049 noroot   3r  FIFO   254,0      0t0 549482381 /home/noroot/temp/nc/fifo2


забавно. что в этом случае  дескпрторы процессов якобы указывают не на файл внутри
ядра а  типа прям якобы на файл на самом диске. что якобы если мы пишем в дескпрттоор
то байты записыватся не в ядро в кактото там файл нвутри ядра а прям на диск!

но давай посмотрим какую иноду имеет файл fifo2

  $ stat fifo2
  File: fifo2
  Size: 0           Blocks: 0          IO Block: 4096   fifo
Device: 254,0  Inode: 549482381   Links: 1

как видно это точно файл типа fifo тоесть пайп. а не обынчный файл.
хм... номер его иноды на жсктом диске 549482381 странно но сопдаатет с номером иноды
которыая написана в выводе lsof!

посмотрим еще внимательнее инфо о дескрипторах
  $ cat /proc/2940025/fdinfo/3
pos: 0
flags:    0100001
mnt_id:   30
ino: 549482381

получается стрнанаая вещь что дескпритторы реально ведут имнно на файл на диске а не на
файл гдето там в памяти внутри ядра!

я проверил еще по другому

     $ cat /dev/zero 1>./fifo2
     $ cat ./fifo2

  $ lsof -Pn -p 2941005
COMMAND     PID   USER  FD   TYPE  DEVICE SIZE/OFF      NODE NAME
cat     2941005 noroot   3r  FIFO   254,0      0t0 549482381 /home/noroot/temp/nc/fifo2

   $ lsof -Pn -p 2940984
COMMAND     PID   USER  FD   TYPE  DEVICE SIZE/OFF      NODE NAME
cat     2940984 noroot   1w  FIFO   254,0      0t0 549482381 /home/noroot/temp/nc/fifo2

  $ stat fifo2
  File: fifo2
  Size: 0           Blocks: 0          IO Block: 4096   fifo
Device: 254,0  Inode: 549482381   Links: 1

тоесть якобы cat реально именно читает и пишет из файла на жеском диске!
но если я смотрю активность жесткого диска через nmon то там видно что диск на
холостом ходу
тоесть можно предположть что ядро могло бы писать в этот файл чуть чуть после этоо блокироать
запись а потом второй процесс это считаывал. но тогда бы была видна активность на диске
а ее нет. тоесть несмотря на то что дескпритооры показывают что они смотрят на файл
на диске на самом деле походу пьемы они смотрят куда то на файл внутри ядра. и на самом диске
ничего не пищется и не читается. вобщем неожиданый прикол! при том что если мы возьмем два 
процесса с обычным пайпом неименновым то там все будет как положено напсиано красиво. 
как я показал выще
тоесть нарпимер вот

       $ lsof -Pn -p 2935540
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
...
sleep   2935540 noroot   1w  FIFO    0,15      0t0             33129079 pipe


что еще интеерсно , что lsof он же нам оказывает файлвые дескпритторы и он нам показывает
ТИП файла на который указывает дескприттор. так вот случае когда мы работем с пайпом неважно
это именнваый или анонимный у нас TYPE=FIFO

       $ lsof -Pn -p 2935540
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
...
sleep   2935540 noroot   1w  FIFO    0,15      0t0             33129079 pipe


   $ lsof -Pn -p 2940984
COMMAND     PID   USER  FD   TYPE  DEVICE SIZE/OFF      NODE NAME
cat     2940984 noroot   1w  FIFO   254,0      0t0 549482381 /home/noroot/temp/nc/fifo2


а когда мы работаем с сокетом то тип открытоо файла это unix !

  $ lsof -Pn -p 2928558 
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
...
nc      2928558 noroot   3u  unix 0x000000005ad0b0e9      0t0  33094964 type=STREAM (CONNECTED)


интересно а что это за тип файлов такой "unix" тоесть внутри ядра есть диковинный вид
типа файлов как unix

напомню какие типы файлов есть на обычной фс
regular, directory, symbolic link, FIFO special, block special, character special, and socket

никакого типа unix здесь нет,
насколько  я понял от ИИ что  на самом деле тип файла = SOCKET! просто именно команда lsof
берет падла и заменяет слово socket на слово unix. вот и все! так что никакого нового
типа файлов нет!

что еще интересно в ввыоде lsof есть сторока DEVICE в ней указано на каком "диске"
лежит файл.
например если файл реальный физически и лежит на физ диске то будет вот так

  $ lsof -Pn -p 2942863
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
nc      2942863 noroot txt    REG              254,0    39352 805576410 /usr/bin/nc

DEVICE=254,0 
осатется узнать что это за диск

$ lsblk | grep 254:0 -B1
├─nvme0n1p3                                   259:3    0   400G  0 part  
│ └─luks-ca8.........88552dc7d85 254:0    0   400G  0 crypt /

получается что файл лежит на nvme0n1p3 типа того.

еще можно тут посмотрет

$ cat /proc/devices   | grep 254
254 device-mapper


254  это так называемое MAJOr число оно определяет дравер , а 0 это минор число
это чтобы драйвер различало одно устройство от дурргого которое он обсдуживает

так вот если мы работмем чрез  аононимный пайп то будет напсано вот такое


$ lsof -Pn -p 2945162
COMMAND     PID   USER  FD   TYPE  DEVICE SIZE/OFF      NODE NAME
sleep   2945162 noroot   0r  FIFO    0,15      0t0  33178971 pipe

тоесть DEVICE=0,15 
15 полуается это порядоковйы номер  а что такое нмоер драйвера 0 . ну хрен знает 
в /proc/deices такого нет. что уже навевает мысли что это какоето виртуальное устройство.

а если мы раотаем с сокетом то будет вот такое


COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
nc      2942883 noroot   3u  unix 0x0000000007375cfb      0t0  33166900 type=STREAM (CONNECTED)

тоесть DEVICE=0x0000000007375cfb что вообще хрен пойми что такое!
что тоже навевает мыслт что файл на который покзывает дескпритор точно лежит не на физ диске

---
еще момент. 
я там выще терминал xterm раасматривал и сигналы как там ходят. а именно когда
мы на крестик нажали на граф окне.
так вот мне пришел еще вопрос - если я сижу в оконе xterm и тыкаю Ctrl+с 
то вопрос - кто пошлет сигнал к башу процесс какой или само ядро?
я включил стрейс и xterm процесса и bash. по факту я вижу что в баш прилетает сигнал
инициированный ЯДРОМ! неонятно. по идее я вижу что в xterm от xorg прилетает некая обычная
инфо. тогда непонятно почему инициатором сигнала не явялется xterm а является ядро. 
---
еще момент.
я открыл xterm .
потом  я нажал крестик на его окне. 
в итоге я четко увидел что именно процесс xterm шлет сигнал SIGHUP процессу bash


далее я открыл xterm через черное окно gnome-terminal-server потом я нажал крестик на окне
именно gnome-terminal-server  и вот прикол ---> окно gnome-terminal  закрылось но ни окно
xterm ни баш - ничего не исчезло. 

вот как выглдело окно процессов до 

  $ pstree -Aspt $(pidof xterm)
systemd(1)---systemd(1294)---gnome-terminal-(1774)---bash(2981307)---xterm(2981330)---bash(2981332)
 

и как после 
  $ pstree -Aspt $(pidof xterm)
systemd(1)---systemd(1294)---xterm(2981330)---bash(2981332)

значит что происходит коогда я нажимаю на крест окна gnome-terminal. это ловит ядро 
шлет Xorg он шлет это к gnome-terminal. тот понимает что юзер хочет закрыть окно а это 
значит что юзер хочет завершить работу с той программой с которой юзер работал через это 
окно а именно bash 2981307 с которым gnome-terminal позволял работать через это окно.
тогда gnome-terminal собирается закрыть /dev/ptmx файл-устройство которое имеет в паре 
файл /dev/pts/123 к которому присоединен этот баш. поэтому gnome-terminal он шлет SIGHUP 
в bash 2981307 сообщая ему что он собиаретс закрыть терминал к которому покдлючен баш.

тоесть gnome-terminal имеет откртый файл /dev/ptmx
а процесс  bash  имеет открытым файл /dev/pts/123
эти два файла связаны связью в ядре через драйвер терминала
    /dev/ptmx --драйвер терминала -> /dev/pts/123

но у нас и проецсс xterm тоже имеет открытым /dev/pts/123 но gnome-terminal об этом 
незнает поэтому он ему нешлет SIGHUP. но зато bash зная о своем дочернем процессе
ему шлет SIGHUP


вот трейс от процесса баша который крутится в окне гном терминала
четко видно что SIGHUP прилтел от процесса 1774 а это и есть гном-терминал процесс

--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=1774, si_uid=1000} ---
--- SIGHUP {si_signo=SIGHUP, si_code=SI_KERNEL} ---
--- SIGCONT {si_signo=SIGCONT, si_code=SI_KERNEL} ---



а это трейс у xterm
видно что сигнал приелетел от процесса 2981307 это как раз pid от баш  
--- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=2981307, si_uid=1000} ---
--- SIGHUP {si_signo=SIGHUP, si_code=SI_KERNEL} ---
--- SIGCONT {si_signo=SIGCONT, si_code=SI_KERNEL} ---


просто тут пролема в том что xterm клал хуй на SIGHUP сигнал. поэтому он и не закрывается.
также видно что в  баш  и  в xterm потом еще прилетатет сигнал от ядра. это происходит 
потому что как я понммаю gnome-terminal закрывает /dev/ptmx возможно не дожидаясь ответа
от баш что он сдох. при этом /dev/pts/123 ядро удаляется и у нас полуается два процесса
которые имеют дескпритоторы нацеленные на /dev/pts/123 а его уже нет. вот ядро им и шлет
сигнал уже само что терминал к которому они покдлючены умерло. 

получется еще раз как все срабатывает. мы тыкаем на крестик окна гном-терминал.
ядро шлет  инфо к xorg то шлет инфо в процесс гном-терминал (инфо это просто байты 
через сокет но не сигнал).  гном теримнал шлет SIGHUP к бащ , баш шлет SIGHUP к xterm.
баш заканчивает свою работу. а xterm кладет хер на этот сигнал. далее гном-терминал
зарывает файл /dev/ptmx и при этом ядро удаляет /dev/pts/122  и у нас баш и xterm
имеют дескрпиторы которые смотрят в итоге на файл которог нет. и ядро это видит  и шлет
само SIGHUP к обоим процессам и к бащ и к xterm.  в итоге баш реагирует на SIGHUP  и 
умирает. а xterm кладет хер на это.и остаетя жить. поэтому то  закрытие окна в гном-терминал
не приводит к автоматичесому умиранию xterm

в итоге у нас xterm будет иметь вот таккую картину

$ lsof -Pn -p 2982863 | tail -n 6
xterm   2982863 noroot   0u   CHR            136,144      0t0       147 /dev/pts/144 (deleted)
xterm   2982863 noroot   1u   CHR            136,144      0t0       147 /dev/pts/144 (deleted)
xterm   2982863 noroot   2u   CHR            136,144      0t0       147 /dev/pts/144 (deleted)
xterm   2982863 noroot   3u  unix 0x0000000022f8f36d      0t0  33418962 type=STREAM (CONNECTED)
xterm   2982863 noroot   4u  unix 0x00000000d230bb02      0t0  33418964 type=STREAM (CONNECTED)
xterm   2982863 noroot   5u   CHR                5,2      0t0       115 /dev/ptmx

то есть я акцентирую внимание на 
     /dev/pts/144 (deleted) 

на практике конкретно эти недоступные терминалы не повлияют ни на что. они всего навсего служили
для того чтобы xterm мог выводить текст на  окно того терминала который закрыт. но это не 
полвяет на работу  баш который был запущен из под xterm

вобщем мудота огромная 


---
cледущий момент
вот я запуситил xterm. он нарисовал окно графическое. 
далее я ставлю на паузу xterm

  $ kill -SIGSTOP $pid

и тогда я тыкаю в окно графическое и нихрена не происходит. а все потому что 
xorg шлет в xterm события а xterm неотвечает. поэтому с окном ничего не происходит!

-----
еще момент.
вот у нас есть программа с которой я как
человек взаимодейтсивую. она интерактивная.
я смотрю в свойства прцоесса и вижу что 
у нее нет открыттого файла терминала.
вопрос- что за хрень? ответ - значит вы
сидите в графческой среде. и ващ процесс
он ИСКЛЮЧИТЕЛЬНО опирается на графческую
подсистему. он не сможет работать в текто
вом режиме. а если у вас есть процесс
интеравтиный и у него в восйтвах открыт
файл терминала. то это значит что это 
процесс интерактивный и он МОЖЕТ рабаоть
БЕЗ графичекого режима! он может работать
в текстовром режиме лиункса через эмулятор
терминала tty2! в частности вот мы сомтрим
на список процссов. и мы видим что у нас
все прцоессы без терминалов. это незачит
что все процессы неинтакртивные. нет.
нужно более внимательно смотреть как у них
налажено общение с графичекском подсистемой
процесс может быть интеративным через
юзание графической подсистемы
------
еще момент
посмотрим локальный юникс сокет
ксатти замечу что в рамках ss это фиьлтруется чреез -f unix

   $ ss -f unix -n -p  | grep -E "Recv-Q|\"nc\""  | grep -E "Recv-Q|26928819"
Netid State Recv-Q Send-Q   Local Address:Port     Peer Address:Port    Process          
u_str ESTAB 0      0        ./un1 26928819            * 26939480        users:(("nc",pid=2371538
u_str ESTAB 0      0        * 26939480                * 26928819        users:(("nc",pid=2371579

посмотрим на файлы процессов

  $ lsof -Pnp 2371538 2>/dev/null | grep -E "FD|unix"
COMMAND     PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
nc      2371538 noroot   3u  unix 0x00000000fe66055e      0t0  26937014 ./un1 type=STREAM (LISTEN)
nc      2371538 noroot   4u  unix 0x000000006eec9b5e      0t0  26928819 ./un1 type=STREAM (CONNECTED)

посмотрим на дескпритор 4

⃱  $ /bin/cat  /proc/2371538/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 26928819
scm_fds: 0


итак в выводе ss для сокета мы видим колонки "Local Address:Port"  и  "Peer Address:Port"
что они показывают для обычно tcp сокета
   $ ss -4np
Netid  State  Recv-Q  Send-Q     Local Address:Port     Peer Address:Port    Process                                      
tcp    ESTAB  0       0           172.16.10.1:47950     172.16.10.11:22      users:(("ssh"))            

тоесть в этих колонках показны параметры пакета который пролетает через данный сокет.
а именно указано откуда пакет прилетел и куда он был направлен

теперь возварщается к выводу ss в случае юникс сокета

   $ ss -f unix -n -p  | grep -E "Recv-Q|\"nc\""  | grep -E "Recv-Q|26928819"
Netid State Recv-Q Send-Q   Local Address:Port     Peer Address:Port    Process          
u_str ESTAB 0      0        ./un1 26928819            * 26939480        users:(("nc",pid=2371538


так вот тут в этих колнках тоже показано откуда прилеетел пакет и куда он был нправлен.
вместо адреса и порта указваются числа. а что это  за числа? из листингов выше следует
что число 26928819 в колонке 


     Local Address:Port
         ./un1 26928819



это инода файла внутри ядра фс  на которую укзыывает деспритор 4   процесса

⃱  $ /bin/cat  /proc/2371538/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 26928819
scm_fds: 0

еще раз вот на что посмотрим. у нас есть процесс. у процесса есть  дескриптор который 
укзываем на файл через который в процесс поступает поток из сокета


процесс fd/4 ---> десприптор ----> файл ------> сокет  <---- байты из потока 

вот пример
 ᆂ  $ ss -4np
Netid  State   Recv-Q   Send-Q     Local Address:Port   Peer Address:Port    Process                                      
tcp    ESTAB        0        0      172.16.10.1:48624   172.16.10.11:2080    users:(("firefox",pid=2128228,fd=391))

    $ cat /proc/2128228/fdinfo/391
pos: 0
flags:    04002
mnt_id:   10
ino: 33530258


тоесть есть процесс  2128228 у него есть в ядре деспритор номер 391 который укаызвает на
файл внутри фс с  инодой  33530258  и  через этот файл байты посутапают в процесс из сокета 
в который поступают из ядра байты из сети

процесс(pid 2128228)  fd/391 ----> дескпритор 391 -----> файл  33530258 ----> сокет

и вот получается что в случае tcp сокета ss показывает в  колонках "Local Address\Peer Address"
не файл 33530258 внутри ядра через который процесс получает данные из сокета

а в случае юник сокета ss в этих колнках показыает  именно иноду внутри фс через которую
процесс получает из сокета байты

   $ ss -f unix -n -p  | grep -E "Recv-Q|\"nc\""  | grep -E "Recv-Q|26928819"
Netid State Recv-Q Send-Q   Local Address:Port     Peer Address:Port    Process          
u_str ESTAB 0      0        ./un1 26928819            * 26939480        users:(("nc",pid=2371538


⃱  $ /bin/cat  /proc/2371538/fdinfo/4
pos: 0
flags:    04002
mnt_id:   10
ino: 26928819
scm_fds: 0

так как данные курсируют исключтетльно внутри хоста то  наверное номера инод файлов
внутри ядра через которые идет по факту обмен байтами можно использовать в качестве "адресов"
пакетов

процесс1 fd/1 <---- десприттор <---- файл 26928819 <---- сокет ----> файл 26939480 ---> деспр
иптор ---> fd/3 процесс2 


выделяю вот эту часть

          файл 26928819 <---- сокет ----> файл 26939480 

тоесть то что вкладвыается в один файл  пролетает через сокет 
тоесть через сокет пролетает пакет в которого указано что он прилетел из файла  26928819
в файл 26939480 и наоборот.   имена этих файлов выступают как адреса.

хочу заметить что pipe он не использует сокеты.  поэтому  в ss бесполезно искать 
следы от пайпов. вот мы открыаем пайп

     $ sleep 120 | sleep 160

смотрим открытые файлы  у процессов

   $  lsof -Pnp 3006197 2>/dev/null | grep -E "FD|pipe"
COMMAND     PID   USER  FD   TYPE DEVICE SIZE/OFF      NODE NAME
sleep   3006197 noroot   1w  FIFO   0,15      0t0  33587355 pipe

  $  lsof -Pnp 3006198 2>/dev/null | grep -E "FD|pipe"
COMMAND     PID   USER  FD   TYPE DEVICE SIZE/OFF      NODE NAME
sleep   3006198 noroot   0r  FIFO   0,15      0t0  33587355 pipe

и  в обоих процессах мы видим 

     33587355


смотрим свойства дескприторов
       $ cat /proc/3006197/fdinfo/1
pos: 0
flags:    01
mnt_id:   16
ino: 33587355


     $ cat /proc/3006198/fdinfo/0
pos: 0
flags:    00
mnt_id:   16
ino: 33587355

итак для пайпа у нас в ss нет ничего. есть чтото тлько в  деспрторах процесса.
а что там? а там номер иноды на которую указывает десприптор. и оба процесса у них 
деспритор который указвыает в пайп и этот   дескприптор укзывает в обоих процессах 
на один и тот же файл внутри фс

          33587355


и он указан в графе

     NODE
     33587355


и полуачается вот что. если у меня есть процесс.и него в дескприторах указан pipe

   ꮅ  $ lsof -Pnp 3004907 2>/dev/null| grep -E "PID|pipe"
COMMAND       PID   USER  FD      TYPE             DEVICE  SIZE/OFF      NODE NAME
Web\x20Co 3004907 noroot  13r     FIFO               0,15       0t0  33570898 pipe
Web\x20Co 3004907 noroot  14w     FIFO               0,15       0t0  33570898 pipe
Web\x20Co 3004907 noroot  16r     FIFO               0,15       0t0  33569968 pipe
Web\x20Co 3004907 noroot  17w     FIFO               0,15       0t0  33569968 pipe
Web\x20Co 3004907 noroot  18r     FIFO               0,15       0t0  33569969 pipe
Web\x20Co 3004907 noroot  19w     FIFO               0,15       0t0  33569969 pipe
Web\x20Co 3004907 noroot  40r     FIFO               0,15       0t0  33569970 pipe
Web\x20Co 3004907 noroot  41w     FIFO               0,15       0t0  33569970 pipe
Web\x20Co 3004907 noroot  44r     FIFO               0,15       0t0  33562117 pipe
Web\x20Co 3004907 noroot  45w     FIFO               0,15       0t0  33562117 pipe


и  я хочу найти "второй конец" этого пайпа 

например вот этого 

COMMAND       PID   USER  FD      TYPE             DEVICE  SIZE/OFF      NODE NAME
Web\x20Co 3004907 noroot  13r     FIFO               0,15       0t0  33570898 pipe

а именно
     NODE
     33570898

то найдо найти другой процесс у которого был дескпритор который смотрим на файл с 
такой же инодой

вот видно что у одного процесса есть два десприптора котоыре смотрят на один и тот же
инод

   ꮅ  $ lsof -Pnp 3004907 2>/dev/null| grep -E "PID|pipe"
COMMAND       PID   USER  FD      TYPE             DEVICE  SIZE/OFF      NODE NAME
Web\x20Co 3004907 noroot  13r     FIFO               0,15       0t0  33570898 pipe
Web\x20Co 3004907 noroot  14w     FIFO               0,15       0t0  33570898 pipe

получается что? у процесса два конца одного пайпа? да.  мы же как его получем. мы 
в пцроессе запускам 
  pipe()
получаем два когнца.
потом себя клонируем . в одом проецссе закываем один конец а во второй закрываем втоой
конец.  но закрывать не обязателно. главное не пользоваться в одном процессе обоими концами.
так вот это прсто значит что вторйо конец лежит в поцессе который деочерний либо парент 
у этого процесса . там надо искать второй конец пайпа.
вообще  конец пайпа легко найти вот как - это всегда будет какйото парент либо дочерний
процесс от данного !

---
еще момент
имеем вывод ss

    $ sudo ss -xp  | grep -E "31357566"
u_str ESTAB 0   0     @/tmp/.X11-unix/X0 31359153    * 31357566 users:(("Xorg",pid=1162,fd=201))
u_str ESTAB 0   0     * 31357566                     * 31359153 users:(("xterm",pid=2716573,fd=3))                                                                                                                                                                                             

это показывает то что между xterm процессом и Xorg процессом есть связь через локаьый юникс 
сокет. также показан файл на фс @/tmp/.X11-unix/X0  через который можно пдключиться 
к Xorg процессу через юникс сокет новому процессу


     $ sudo fuser /tmp/.X11-unix/X0
/tmp/.X11-unix/X0:    1162

 
     $ ps aux | grep 1162
root        1162  1.9  2.0 1448452 325072 tty7   Ssl+ окт12 1457:05 /usr/lib/Xorg :0 -seat seat0 -auth /run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch

-----
следущий момент

тезис:
собствеенно разная вещь  - послать в файл дескриптор у процесса типа STDIN 
и на терминал на который этот стдин смотрит

в целом наверное - ДА.

пусть у нас есть процесс  и  у него fd/0 десприптор смотрит на файл терминала /dev/pts/15


   0 ---->  /dev/pts/15


тоесть

  процесс fd/0 ------>  дсескриптор(0) ----> /dev/pts/15  <---   /dev/ptmx


а далее мы имеем вот то что  я описывал выше а именно
файл /dev/pts/15 он особенный.  если я в него пошлю байты то эти байты они незадерживаются
в этом файле. драйвер терминала мгнвоенно забирает байты из этого файла и переправляет
их в /dev/ptmx файл.  поэтому если процесс будут прообовать читать из /dev/pts15 через 
дескприптор 0 то наш процесс эти байты никогда не увидит.   поэтому думать что если я посылаю
из процесса2 в файл /dev/pts/15 то эти байты попадут в процесс из за того что он читает из 
/dev/pts/15 это ОШИБОЧНО.  в  процесс файлы прилетят только те которые будут всунуты в 
файл /dev/ptmx который открыт в какйомто другом процессе3.  если я будут пытаться "подключиться"
к /dev/ptmx чтобы через него отправить в процесс  то я тоже потерплю поражение. причины 
этого я описал тоже там выше.  щас я не будут их повторять. 
поэтому получается что да -   совершенно разная вещь это  просунуть в процесс на его stdin 
байты и  записать байты в /dev/pts/15 на который смотрит десприптор 0 у процесса!
---
еще момент

я описал путь от нажатия кнопки на экране до баша
но описал его не совсем точно ибо устал                                         

тыкаю кнопку '9' на экран черный (граф хрень) -->(процесс Xorg) ----сокет /tmp/.X11-unix/X0<-- ядро----->/fd/сокет юникс   xetrm  /dev/ptms --ядро--->  /dev/pts/81 -----fd/0 bash 

баш засоало и должно выстрать эту же  9 через fd/1

bash fd/1 --->/dev/pts/81 ---> /dev/ptmx xterm ---> fd/N --->/tmp/.X11-unix/X0 --- Xorg --> граф
окно черный экран

замечу что процесс Xorg он имеет слушающий юникс сокет в файле /tmp/.X11-unix/X0

---








=====================================

НИЖЕ УКАЗАН БОЛЕЕ СТАРЫЙ МАТЕРИАЛ,
ВНЕМ МОУТ БЫТЬ ОШИБКИ

| terminal
| pty
| line discipline

 

 я щас хочу описать очень тонкую вещь.  я оней прочитал 
 на стек оверфлоу.


 вот у нас типичная ситцауия с терминалом



черное граф окно --- ядро X11 драйвер --- (socket)xterm(ptmx) ---- ядро line discipline------(pts/10)bash


тоесть xterm он породил граф окно в X11 системе. а граф окном 
управляет ядро. и xterm получает от черного окна инфораацию 
через сокет который он открыл. если в черном окне мы тыкаем клавишу
то она летит в ядро вдрайвер X11 и ядро ее шлет через сокет в xterm

а через ptmx xterm держит связь с башем . между ptmx xterm 
и pts/10 bash сидит ядро с своим кодом "discipline line" который собс
твенно всю логику работы терминала и выполняет. так вот 
что здесь важно понять и увидеть.

человек выдяеляет мышкой черное граф окно и тыкает кнопку на клаве.
кнопка из окна попадает в ядро  в x11 драйвер. ядро эту кнопку
шлет в сокет xterm таким макамро кнопка оказалась внутри xterm
процесса . (байт кнопки). круто. xterm получив эту кпнопку через сокет
он ВНИМАНИЕ ее мгновенно пересылает в ptmx . МГНОВЕННО! это важно.
эта кнопка влетает в ядро в код "line discipline"
а дальше происходит ОЧЕНЬ ВАЖНАЯ ВЕЩЬ - в зависимости от того как
настроили настройки этой "line discipline" как xterm 
так и процесс на той стороне в данном случае bash то код в ядре
"line discipline" он может поступить ТРЕМЯ разными способами!
     1) он может байт кнопки НИХРЕНА дальше не пропустить! вау!
     зато вместо этого "line discipline код" мгновенно ОБРАТНО в
     через ptmx в xterm шлет такой же байт!
     и получается для xterm все выглядит так что он послал 
     байт в приложение которое сидит за ptmx и он якобы сразу
     прислало ответ! хотя ответ по факту прислал не баш!!!
     а прислало ядро!! охренеть! и xterm то что он получил мгнвоенно
     переселыает в сокет чтобы это нам X11 нарисовало на экране!!
     поэтому мы нажав на кнопку с буквой на клаве видим тут же 
     эту букву на экране! это назвыается в терминах терминала как 
     "echo" эффект. но согласист как же хитро! как мерзко !
     как по гнидски устроена эта схема!!!! 
     а баш как я скзаал при всем при этом нихрена еще ничего не 
     получил!!!! line discipline может быть настроен так 
     что он будет копить все символы которые ему xterm шлет 
     до тех пор пока из черного экрана не прилетит к примеру
     с клавы символ кнопки Enter.  ИВОТ ТОГДА НАКОНЕЦ line discipline
     отошлет уже весь массив всех кнопок в баш!!!!
     это все можно легко проверить если в xterm запусить команду 
     	$ cat -
     и как это будет выглядеть. мы будем наимать на кнопки и они 
     будут сразу появлятся на экране при кажом нашем нажатии. 
     а потом мы нажмем Enter и на экране появится дубликат той
     строки которую мы набрали по буквам. дубликат появится только 
     после тго как мы нажали Enter, не ранее! так вот пиздец это как
     работает как  я описал выше. когда мы тыкаем буквы то они 
     с черного экрана ядром через сокет посылаются в xterm  и он
     их мнгнвоенно пеерслывает в ptmx и они попадают в ядро
     в line discpline код ядра. и он в cat нихрена ничего не шлет!
     зато он сразу каждую полченную бувкву шлет обратно в ptmx
     к xterm процесу и он монвоенно это перелывает в сокет оттдуа
     оно подает в ядро в X11 драйвер и драйвер рисует в черном
     окне наэкране букву. а cat при этом нихрена не получает! он
     на голодоом пайвке! и тоько окгда мы тыкнем Enter и егополучит
     line discpline ТОЛЬЛКО ТОГДА наконец line discilie
     перешлет весь набор набитых до этого символов в cat через
     pts/10 файл! и тогда cat получив наконец то что ему прислали
     он мгвновенно высирает это в stdout который тоже смотрит  в 
     pts/10 оно обратно влетает в ядро в line discipline и тут
     конечно line disline настроен так что та инфо что влетает 
     в line discpine со стороны pts/10 он мгновенно шлет в ptmx
     (ксати я не знаю всегда ли это так. может там тоже можно
     настроить line discpl что оно то что прилетает со стороны pts/10
     тоже собирает в кучку и ждет enter. не проверял не знаю.).
     из ptmx он поступутат  в xterm . оно это имеетя ввиду то что
     послал cat то есть срочка целиком. и он то что получил опять
     же не лукавя шлет в сокет. это летит в яро. ядро через x11
     рисует на экране. вот такая очень хитрая схема. получается
     и в ту стороу все хитро работает и вобратру стоорону тоже. 
     то что мы ыткаем в черном окне на клаве оно не факт что должает
     то процесса конечного. а то что рисуется на экране оно 
     не факт чтоприетело от того процесса коенчного. оно могло
     прилететь и от кода ядра line discipline.  и это пиздец!
     поленейший!

    получается также что эта вся схема так устроена что из за 
    того что мы нажали кнопку и логично ожидаем что она тут же 
    отрисуется на экране (как буто кнопки и экран это одно и тоже
    неразрываное существо) а это нихуя нетак. то что мы тыкаем
    кнопки для этой системы нипель это одно. а рисование
    на экране терминала это совсем другое.  и чтобы нажатая кнопка
    рсиовалась на экране это вот надо еще постараться!

 я бы сказал что классический железный терминал в этой схеме
 эмулирует черное граф окно + ядро с его x11 драйвером + xterm
 процесс. вот это все работает в точности как железный терминал.
 line discipine она как была раньше при подключенном реальном
 желеном терминале так она и осталоась в этой цепоечке.
 тоесть раньше схема была такая

желез терминал ---------- (com) ядро, line discipine ------ (/dev/tty2)bash  процесс

так было раньше.

хотя я вот думал что то что на жел терминале рисуется сразу символ
после нажатия клавы это настройка самого терминала. а вроде как 
оказалось что нет.
также я думал что редактирование символов это хрень была реальзована
внутри термиала в некотором его внутреннем буфере. а это якобы согласно
стекофверфлоу тоже окаазалось неправда. символы сидят в linediscipine
и он служит буфером для редактирования. скажем мы щлем с клавы
терминала символ "backspace" и linediscpine в своем буфере удаляет
последний символ справа который там сидит. и паралельно шлет 
обратно на терминал такойже байт. а терминал уже у себя на 
экране тоже стирает этот символ. вот такая пиздец схема!

2) вторая схема работы состоит в том что line displine так настороен 
что если в нее с черного экрана с xterm процесса c ptmx 
прилетает символ то line discpine мгнвоенно его передает дальше
незадерживая его в своих кишках! так работает лайн дисциплин 
когда у нас конечнм прцессом запущен баш! он когда старутет он 
шлет кучу ioctl сисколлов через pts/10 в line discpline. он ее
программирует. и он ей задает такой режим! поэтму когда мы 
нажали кнопку в черном окне она мгвноенно доолетает до баша!
также я подохрвеваю что баш отклчает на лайн дисциплин режим echo.
тоесть когда символ пролеаеет через лайн дисциплин от ptmx 
в сторону pts/10 то лайн дисицплин автоатом обратно этот символ
я думаю не шлет. зато баш когдп получает символ он сам шлет
обратно этот символ. вот кто причина букв на экране после
нажатия клавиши. не лайн дисциплин а сам баш! 

3) третий режим работы такой что мы настрвиаем лайн дисциплин 
и он накаливает буквы летящие в него от ptmx и не отслывает
их в конечное приложение пока не получит символ Enter но
он также и не послывает обратно эти символы! и поэтму нажимая
кнопки на клаве мы небудем видеть ничего на экране! такйой
режим лайн дисцлпин тоже возможен!
например такая хрент может быть полезна при вводе пароля. 
мы вводим пароль но на экране чисто. скажем условно баш может 
перед вводом пароля через ioctl программировать лайн дисцлиплин
на такое поведение. или любой процесс вметсо баша который запущен 
натой стороне.  если запусить баш с strace то можно увидеть 
сколкьо много постоянно ioctl делает баш ососбенно если он 
собирается запустиь левый бинарник через execve. он для него
подготваливает лайн дисицплин. и потом обратно когда левый бинарник
вышел и баш обратно попдает в foreground группу и собатеся продолжать
раобтать с терминалом то баш обратно восстанвлвиет через ioctl 
насторойки лайн дисцплин "под себя" как башу это удобно!

в целом это полная жесть как элементарная хрень реализована
так сложно!! и я бы скаазал дебильно!! всего то навсего надо 
чтобы кнопки летали с клавы на удаленное приожение и чтобы
на экране рисовались эти кнопки. как же сложно они все это
сдеали! мир динозавров деревынных игрушек и запорожцев







