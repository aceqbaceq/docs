новое описание про так называемый терминал
в линуксе.

значит как процесс в линуксе работает  с файлом с диска. процесс его открывает


  open ("/tmp/1.txt")

получает от ядра номер деспритора  15

и потом из него читает и пишет

     read(15,...)
     write(15,...)


но ровно по такой же схеме процесс может писать не  файл на диске а внутрь какойто 
железки. например внуьрь приентера

  open( "/dev/lp0")

  write(15,....)



была раньше такая железка - терминал. это была хрень как ноутбук тоесть склеенный экран 
и клава, только внутри этой железки не было ни проца ни памяти. это тупо был склеенный 
в одно цело блок из клавы и экрана. и у него был провод через который эта железка опдключа
лась к компу.  вот на современном системном блоке есть отдельная дырка под клаву и отдельная 
дырка под монитор. а тогда эти две железки были склеены и к компу они подкючались через единую
дырку. в ноутбуке щас клава и монитор и вовсе приклеены к корпусу. далее такой момент
современная клава имеет драйвер  в ядре а вот драйвера монитора в ядре я так понимаю нет. 
есть драйвер видеокарты а монитор вроде как получается уже част видеокарты. есть драйрвер
видеокарты. но драйер это хрень которая нужна ядру чтобы взаимодестовать с железкой. а как
получить доступ к клаве или монитору из юзерспейса. ядро  создает виртальные файлы 
например /dev/input/event12  у меня это тачпад


          $ sudo libinput list-devices


Device:           Elan Touchpad
Kernel:           /dev/input/event12
Group:            9
Seat:             seat0, default
Size:             104x68mm
Capabilities:     pointer gesture
Tap-to-click:     disabled
Tap-and-drag:     enabled
Tap drag lock:    disabled
Left-handed:      disabled
Nat.scrolling:    disabled
Middle emulation: disabled
Calibration:      n/a
Scroll methods:   *two-finger edge 
Click methods:    *button-areas clickfinger 
Disable-w-typing: enabled
Disable-w-trackpointing: enabled
Accel profiles:   flat *adaptive custom
Rotation:         n/a


и мы можем обратиться к железке из юзерспейса. точнее юзер процесс поросит ядро считать
байты якобы из просто файла /dev/input/12 а на самом деле ядро читает байты из ядра железки
и кладет эти байты в память процесса. 

насколько я знаю такого вот спец файла по доступу на монитор нет

самому ядру эти спец файлы ненужны. эти спец файлы ядро предоставляет в юзер спейс чтобы
юзер программа могла якобы просто читая "обыкновенные файлы" по факту через ядро могла 
полазить внутри железки. 


итак этот терминал (монитор плюс клава склеенные в  один ящик в котором больше ничего не
было ни проца ни памяти нихуя)  присоединялся к корпусу мейнфрейма через провод. современная
аналогия это сист блок в который втыкается просто клава и просто монитор только не через две 
отельные дырки а через одну. 

ядро детектило это железо. и  ядре начинал работать драйвер этого железа - "драйвер терминала".
далее человек тыкает на клаве кнопку. терминал шлет эту инфо сразу в сист блок. драйвер
терминала перехватывает этот байт и он этот байт там залипает. и лежит в ядре. тоесть 
мы на кнопку нажали и тту же эта инфо удетела внутрь сист блока. но дальше ядра этот байт не
улетел. человек еще тыкнул кнопку , эту инфо терминал сразу переал внутрь сист блока. там
драйвер терминала это  поймал и держит в своих кишках. при этом важно то что клавиуатура 
и монитор в железке терминал это как бы две незавимые железки и это дает то что  если мы 
нажали кнопку на клаве то ее задача передать эту инфо внутрь сстемного блока НО! - это совсем
не значит что на второй железке монитор должна тут же нариосваться буква! нет! если мы нажали
кнопку то это всего навсего приводит к тому что это нажатие улетает в сист блок! задача чтото
там нарписовать на моиторе это совершенно отдельная независимая задача! ни терминал в целом
ни клава не занимается задачей наросвывания буквы на экране если мы нажали кнопку! когда
драйер терминала ловил прилетевший байт то драйвер терминала посылает обратно на терминал
особую команду на монитор и на мониторе повялется буква! это в драйвере терминала назвыается
"функция эхо".  если драйвер терминала в ядре не пошлет сам обратно смец команду то на мониторе
терминала нихрена не будет гореть ничего! сколько бы мы кнопок на клаве термина ни нажали!
итак мы нажали кнопку на теоминале. клава на терминале тутже отрпавила эту кнопку в сист
блок. там ее поймал драйвер терминала в ядре и поймал и держит. и если на драйвере терминала 
включено функция "эхо" то драйвер терминала обратно по пвроду щлет спец команду на моитоор
и на мониторе загорается буква! мы продолжает тыкать кнопки на клаве термианла. она это пердает
в сист блок. дарйвер терминала ловит эти буквы и складывает в своей памяти в кучку. и посылает
обратно на монитоо терминала команды и на мониторе загораются новые буквы. если мы на клаве
наимаем "backspace" то кнопка прилетает в ядро в дарвер терминала и он тогда сттирает в памяти 
в своем буфере последний символ и также драйвер терминала шлет спец команду обратно на терминал
и на мониторе стирается последний символ. таким образом "редактиврование" текста идет не силами
терминала а силами драйвера терминала в ядре в сист блоке. текст набранный хранится и лежит
в буфере памяти в ядре в драйвере терминала а не в желещке терминал. ровно также как это ест
в слуачае компа с сист блоком - набранный текст не хранится ни в клаве ни в нутри монитора
он хранится в ядре! и вот мы уже натыкали цедлую гору букв , они  светятся у нас на экране 
пусть это будет целых 10 букв

     ехал грека через реку

но при этом данные буквы еще так и не поаали внутрь памяти никакого процесса! пока это все 
в ядре! 
если в драйвере термиала выключена функция эха то мы набили текст на клаве. он лежит в ядре
но на мониторе ни хрена не будет светится ничего! 

потом мы наконце тыкаем Enter! и только тогда ядро из внутреннего буфера драйвера терминала
записывает все эти буквы в файл /dev/tty2 !  для простыт понимания можно считать что этот 
файл как бутто прям файл на диске. хотя его нет ни на каком диске это тоже хрень внутри ядра.
но! разница в том что буфер драйврера терминала который в ядре он вообще не доступен для 
юзер процесса а  файл /dev/tty2 он хоть физически лежит в ядре но эта структура уже доступна
для доступа для юзер процесса! и вот когда ядро записало буквы в файл /dev/tty2 то их можно
наконец считать внутрь юзер процесса. проецсс для этого должен заюзать команды

   open("/dev/tty2")
   read(15,&buf,100)

и ядро возьмем байты из файла /dev/tty2 и запшет их в память процесса по адресу &buf
дело в том что хотя файл /dev/tty2 виртуальный но у юзер процессов нет прямрго доступа
внутрь никких файлов ни физ ни вируальных. туда может лазить непосдрественно только ядро.
а юзер  прцоесс может лишь получать отттуда байты только через посредничество ядра.

таким образом нам открывется поразтельная вещь мы тыкаем кнопки на клаве терминала на экране
тут же вспыхивают буквы ( при условии что функция эхо в драйвере терминала актививрована)
и у нас возникает чуство о том что клавиатура посылает байты на экран с одной стороны а 
с другой стороы что посланные буквы как тоько они появились на экране то они уже лежат внутри
юзер процесса. оба этих ощущения абсолютно неверны! это наебка интуиции. 
по факту все что делает клава она шлет буквы в ядро сист блока. буквы на монитре рисует ядро.
и ни одна буква еще не попала внутрь юзер процесса! у нас на экране уже гора тексат но 
внутри юзер проецсса нет еще нихрена. юзер процесс еще даже не подозревает что мы набрали
кучу текса и что он лежит внутри ядра! вот такая вот наебка интуииции. мы нажимаем backspace
у нас на экране стирается последний символ. нам кажется что backspace долетел до юзер процесса
и он стер у себя в памяти последний символ а потом отрисовал эту стацию у нас на мониторе.
это тоже наебка интуиции. на саоммо делео бекспейс прилетел в драйрвер терминала. он поймал
эту кнопку. стер послдений символ в своем буфере памяти. потом послал нужный сигнал на монитор
и там тоже это стерлось. а внутри юзер процесса как небыло нихрена так и нет!!!!
а вот наконец когда мы нажали Enter  - то драйвер терминала поймал эту кнопку и наконец то 
он запиыввает все буквы что у него лежат в его буфере в файл /dev/tty2 !  и если юзер 
процесс сейчас попросит ядро  записать то что лежиь в файле /dev/tty2 внутрь памяти процесса
то наши буквы наконец то попадут внутрь юзер процесса!!! охренеть.  важно понимать что 
буфер драйвера терминала недоступен для юзер процесса никак. и именно туда прилетают кнопки
посланные с клавы терминала. там они лежат и хранятся. а вот файл /dev/tty2 он  вообще то 
говорят тоже недотупен для юзер процесса (потому что прямой доступ к любому файлу для юзер 
процессов запрещен) но процессс может попросит ядро залезть в этот файл прочитать что там лежит
и положить что там лежит в обласьт памяти процесса. когда мы на клаве нажимаем enter 
и эта конопка прилетает в драйвер терминала то это служит ему сигналом что нужно все что в буфере
наконец то переписать  в файл /dev/tty2 и  посланные кнопки наконецто станвится доступными
для юзер приложения. поэтому может быть очень большой перерыв между тем временем когда мы натыкали
кнопок и то время когда они реально попали внутрь юзер процесса! а нам будет кааться что все
что мы натыкали уже давно крутится внутри юзер приложения. и оно их обрабатвыает. это охуенное
наебалоов в архитектура терминала. также прикол файла /dev/tty2 состоит в том что вот положиим
ядро туда записало сколько то байтов. потом юзер процесс читает эти байты из этого файла. 
что было бы если бы /dev/tty2 был бы "обычным" файлом диска если бы мы повтрорно запросили
чтение из него? было бы то что мы бы эти байты прочитали бы успено снова. но /dev/tty2 необычный
файл. если мы из него чтото прочитали то эти данные оттуда сразу стиарются его размер уменьшается.
если мы из него прочитали все байты то его размер становится равен ноль! и если повторно с него
пытаться читаь то  в ответ мы полчим фигу! в этом его разлиичие с обычным файлом!
теперь вопрос а как юзер процессу узнать когда в /dev/tty2 прибудут байты? вот он пустой.
мы в юзер процессе открываем файл /dev/tty2

  open ("/dev/tty2")

получаем имя дескпртора 0 или 15 неаважно

далее мы просим ядро прочитать что там лежит и записть это в память нашего процеса 
по адресу &buff1

  read(0, &buf,...) 

ядро лезет туда читать а там пусто. что тогда будет . будет два варианта - если мы открыли
/dev/tty2 файл без укаания спец флагов  а потом запустили read()
то у нас же по факту любой сисколл выполняет ядро а не юзер спейс код. тоесть мы запускаем

  read(0, &buf,12) 

ксатти мы указыаем чтобы прочитаь из файла 12 байт. роовно 12 байт и немеьше

по факту проц перекобчатся из юзер режиме в ядро режим. запусется код ядра котоырй обслужиает
этот read() и ядро смотрит в файл /dev/tty2 видит что там нетолько 12 байт нет а там вобще
нихрена нет. тогда ядро как говорят "блокирует" процесс. тоесть исполение кода процесса останав
ливатся. код процесса исключается из очереди на выполенение шедулера. тоест наша програамма
застывает на команде 

  read(0, &buf,12) 

и дальше ничего не происходит до тех пор пока в файле /dev/tty2 не появится 12 заказанным байтов.
вот толко когда там повяится 12 байтов то ядро их оттуда читает. потому оно копирет эти байты
в юзер процесс в его память по адрему &buf1, также ядро стирает эти 12 байтов из файла /dev/tty2
и только тогда просходит "вовзрат" из read() и начинает исполняться следующая команда в юзер
процессе по списку. если же мы про  открытии файла укзаазали флаг 

     open("/dev/tty2",O_NONBLOCK)

а начали читаь из файла. то ядро увидит что  в файле нихрена нет но не станет блокировать 
процесс а просто сразу верентся из команды read() и сообщит через errno = EAGAIN
это будет для прцоесса значить что в файле нихрена нет. и код процесса начнет исполнятсяся
со следующей команды. и процессу нужно будет самомму подождать какоето время и повторно
запусти команду

  read(0, &buf,12) 


и первый и второй подход  гавно. в первом слуучае наша программа засытвыает а мола бы делать
чтото поледное. во втором случае мы вслеую должны тыукаться и делать повторный read() надеясь
что в файл наконец то чтото прилетело. 

поэтому есть третий путь использовать select() 
мы отркыаем файл

  open("dev/tty2")

пполучаем дескприптор 0

далее запускаем 

 select (...) в котором указыаем этот десрпитор 0 

при этом у нас процесс блокируется или засыпает. это на самом деле аналогично первому подходу
тоесть код программы больше не выполняется. далее ядро следит кода же на файл на котоырй укзыает
дескпритор 0 получит какието данные  и кога это прооисходит то ядро возвращает жизнь процессу
возвращается из select() и сообщает что в файл с дескприрром  0 чтот прилетело. 
в сущносити использование select() аналогично первому методу. плюс его в том что мы можем 
через select() монииторить сразу кучу файлов . причем мы еще можем и указат какие файлы нужно
мониторить на факт того что  в них чтот прилетело. а какие файлы можно мониторить на факт
того что в них можно наконец чтото записать.  сразу скажу что slect() имеет смысл монитоорть 
только спец файлы. такие которые  сдуваются до нуля если из них считать из контент, или 
такие в которые нельзя писать одноврменно из нескльких процессов. если натрвливать sleect()
на обычные файлы на диске то с точки рения селект такие фалы всегда готовы и на чтение и на 
запись и он будет возвращаеться мгвноевнно.  описаие как работатет селескт смотрит  в тексте
select.txt !

так вот возвращается к нашему /dev/tty2
если мы сделали вот так

  open("dev/tty2")
  select ( ... )

то наш процесс будет спать. но как только драйвер термиала сбросит буквы из своего внутреннего
буфера в /dev/tty2 то ядро мгнвоенно разбудить наш юзер прцоесс и сообщит ему об этом! и процесс
сразу сможет прочитаьт из файла контент!

если мы сидя за терминалом хотим "общаться"  скакойто юзер программой вглубине кишок 
систмного блока то  юзер программа должна быт так настроена что она должна открыть со своей
стороны файл /dev/tty2

потому что вот мы вкючили в пиитание наш термиал. он зажгся. ядро задетектило что появлось
новое устроустов. ядро активирует дарйвер терминала в своей памяти.  мы начинаем тыкать кнопки
на клаве. они летят внутрь ядра драйврера терминала. он в ответ шлте комадыы на монитор
мы видим как загорются на мониторе буквы. все классно. 
потомы ммы тыкаем enter - драйер терминала переслыает данные из своего внутреннего буфера
в файл /dev/tt2 .классно. но что дальше? если ни один юзер процесс на системном блоке 
не прочитает из /dev/tty2 то  никакого толка от набаранных нами букв нет! ну переслали мы их в
ядро. ну ядро отрислваоло их на мониоре. ну  перелетели они в файл /dev/tty2 ну что? все
финита.  поэтому раньше да и сейчас было так. вот мы вклчили терминал. ядро его задетеклтило.
и ядро автоматом создает процесс. хотя скорей всего не ядро за этим следит а init процесс. 
не столь важно. скорей всего вообще вот как - после загрузки ядра процесс init заранее
сам запускает  процесс , окрывает  файл /dev/tty2 и в рамках этого процесса запускает 
через execve() бинарник программы agetty
вот как это выглядит

 $ ꉙ  $ pstree -Aspt 2838009
systemd(1)---agetty(2838009)


$ sudo lsof -Pn -p 2838009  2>/dev/null | tail -n 5
agetty  2838009 root   0u      CHR    4,2      0t0        21 /dev/tty2
agetty  2838009 root   1u      CHR    4,2      0t0        21 /dev/tty2
agetty  2838009 root   2u      CHR    4,2      0t0        21 /dev/tty2
agetty  2838009 root   3r      DIR   0,87       40         1 /run/credentials/getty@tty2.service
agetty  2838009 root   5r  a_inode   0,16        0      3117 inotify

здесь нам важно что что agetty открыл /dev/tty2
и вот чем занят agetty

$ sudo strace -p 2838009
strace: Process 2838009 attached
pselect6(6, [0 5], NULL, NULL, NULL, NULL

видно что он спит и попросил ядро чтобы оно его разбудило когда на файл на который
указем десерпитор с именем 0 придут данные. тоесть когда на файл /dev/tty2 чтото при
летит из ядра!

к систем блоку моет подключено неколько терминалов. ядро их както различает. видимо по номеру
дырки в которуб воткнуть дата кабель от терминала. и если чтото прилетаит оттерминала2 в ядро
и будет нажат enter то ядро драйер терминала это будет всегда скидывать в файл /dev/tty2
а все что прилетиит от термиала3 ядро будет скиывать в /dev/tty3
таким образом если мы хотим поймать что будет послано из терминала2 то нам нужно вегда ловить
это в файле /dev/tty2
неважно что щас терминал2 выключен.
мы можем запусти юзер процесс. открыть файл /dev/tty2 и заснуть. а ядро попросить что если
чтото наконец прилетит на /dev/tty2 чтобы оно нас разбулило! во как

важный момент. мы сидя в нашей юзер программе можем через ядро менять настройки на железке 
терминал. мы можем ею управлять! делается это через ioctl()
если у нас файл декпритор который ведет на tty2 это 0 то вот пример

ioctl(0, TIOCGWINSZ, {ws_row=39, ws_col=158, ws_xpixel=0, ws_ypixel=0}) = 0

тоесть мы указвыаем 0 для адра обьясняя какой терминал ему нужно подкрутить. тоесть 
мы используем 0 только для того чтобы обяснить ядру "имя" того ттерминала который ядру нужно
подкрутить. сам файл /dev/tty2 никакого прямого отошения к процессу подкручивания неимеет.
тоесть ядро фиически подкручивает терминал через друигие файлы и каналы. 0 тоесть  /dev/tty2
используется в сисколле только чтобы  оьбяснить ядру с каким терминалом мы хотим чтобы он 
пошаманли. посколку у нас "настоящего" имени терминала у нашего процесса нет мы в качетсве
имени терминала подсталяем единственнй "идентицкатор" трминала который мы имеем в простарнсте
юзер процесса. сам же файл /dev/tty2 физичски используется только для одного чтобы процесс
мог из него забрать те данные которые прилеетли из терминала в ядро и которые ядро из своего
внутреннего буфера сбросило в этот файл для нас.

также через ioctl() юзер процесс может изменит настройки нетлоько самого терминала железки
(исользуя ядро) но изменить настройки драйвера терминала в ядре! напрмер я говорил что по дефолту
дравер терминала  перееносит байты прилеетвших кнопоок из внутренненго буфера в ядра в 
файл /dev/tty2 только когда с клавы терминала прилетит наконец кнопка Enter
так вот если у нас юзер процесс bash то он чрез ioctl() меняет эту натройку и он говорит - эй
драйвер термиинала 2 значит если к тебеприлетела кнпка то ты ее незажимай а шли мне сразу
и немедленно! также баш говорит драйрвер терминала чтобы он сам от себя эхо обратно на монитор
терминала не слал. поэтому когда мы нажимаем кнопку на клаве терминала он сразу долетает до
ядра а оттуа сразу передается на /dev/tty2 где ее уже ждет бащ. при этом ядро нешлет обратно
на монитор терминала эхо. вместо этого сам баш получив букву пишет в dev/tty2 полученную 
букву

  write(1,"Y",1)

и драйвер терминала вида что в /dev/tty2 чтото прилтело уже от приложения шлет эту букву на
мониттор термиала и она там зажигтается

поэтму юзер процесс работая с терминалом может нетолько принимать и отправлят на него буквы
но и менять нстройки работы железки терминала и менять настройки работы драйвера терминала

когда у нас пресональный компьтер с сист блоком клавой и мышкой  и линуксом то у нас 
как бы уже есть терминал подключенный к систмному блоку. и пусть линукс загружен  в тектовом
режиме. так вот линукс берет и из нашего реальнгого одного терминала создает сразу 
скажем 5 или 9 виртальных терминалов из нашего одного реального. переключаться между ними
можно через Alt+FN

итак псоел загрзуки у нас уже есть запуенный процсс который "привязан" к нашему терминалу
это agetty
мы вводим в терминале логин и пароль. это все улетает в ядро а оттуда на /dev/tty2
а оттуда это все читает agetty. если логин пароль ок. то вместо agetty запускается login 
а он запускает bash

$ pstree -Aspt 2839919
systemd(1)---login(2838009)---bash(2839919)

нехочу разбратся зачем нужен login процесс. похер. ясно что он засыпает. а на сцену выходит
процесс bash который он запустил. этот bash уже привязан к tty2 ему самому это делать ненужно.

 ] ⋘  $ lsof -Pn -p 2839919 2>/dev/null | tail -n5
bash    2839919 noroot mem    REG  254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
bash    2839919 noroot   0u   CHR    4,2      0t0        21 /dev/tty2
bash    2839919 noroot   1u   CHR    4,2      0t0        21 /dev/tty2
bash    2839919 noroot   2u   CHR    4,2      0t0        21 /dev/tty2
bash    2839919 noroot 255u   CHR    4,2      0t0        21 /dev/tty2

чем же он занят

  $ sudo strace -p 2839919
strace: Process 2839919 attached
pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}^Cstrace: Process 2839919 detached

а он получается спит. и ждет кода его ядро разбудит в том случае когда в файл на который
ведет деспритоо с именем 0 чтото прилетит что можно будет прочитаьт. тоесть он спит до тех
пор пока в /dev/tty2 ядро не сбросит буквы с терминала

вот я переключился на черный экран тектовго терминала и нажал кнопку 1
что при этом произошло

   $ sudo strace -p 2839919
strace: Process 2839919 attached
pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}) = 1 (in [0])
read(0, "1", 1)                         = 1
pselect6(1, [0], NULL, [0], {tv_sec=0, tv_nsec=0}, {sigmask=NULL, sigsetsize=8}) = 0 (Timeout)
write(2, "1", 1)                        = 1
pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}^Cstrace: Process 2839919 detached

тоест мы нажали кнопку. клава (часть железкт терминал) послал сразу ее в ядро. 
ядро это сунуло в дравер терминала2. так как баш заранее попросил драйвер этого терминала
незадерживаь буквы в своих недрах то драйер термиала сразу эту букву из своего внуреннго
буфера переслал в /dev/tty2
а так как баш просил ядро разбудить его когда чтото прилетит то яро его будит. и баш 
пронснувишись читает что там прилетело в файл /dev/tty2
есвтеенно читает не сам а с помощью ядра
     read(0, "1", 1)                         = 1

успешно засавыает в себя цифру 1.
идале баш уже сам пишет эту цифру 1 в /dev/tty2

     write(2, "1", 1)                        = 1

почему баш читает файл /dev/tty2 через 0 а пишет в /dev/tty2 чере 2 хуй знает. 
и 0 и 1 и 2 все ведут на один итотже файл /dev/tty2 и без разницы через какой номер 
деспритора обращаться на один и тот же файл. ровно был бы такой же эффект если сделать

     write(2, "1", 1)                        = 1

потмоу что резузььтатт завсиит не от номера деспритора а от того на какой файл этот деспритор
укзывает!

итак баш сует 1 в /dev/tty2 . это видит драйрвер терминал2. он беерт этот 1 и посылает на тер
минал на монитор. чтобы тот нарисоват этот 1 на экране.

после этого баш обратно засыпает

таким образом сам файл /dev/tty2 используется ядром чтобы пихать в него байты которые приелетли
в ядро из клавы терминала чтобы процессс мог читая файл /dev/ttt2 мог забрать эти кнопки.
и чтобы пороцесс мог писать байты которые он хочет нарисовать на экране монитора терминала.
и ядро забирает эти байты из этого файла и уже каким то там макаром их щлет на монитор и 
просит его отрисовать эти байты как картинки. таким образом сам файл /dev/ttt2 используется
для обмена через него байтами которые процесс хочет нарисовать на экране и для обмена
кнопками которые были нажаты на клаве терминала чтобы передать их внутрь процесса.
процесс обмена идет через read() write()
а ioctl() опосредованно исползует имя /dev/tty2 а не его самого чтобы прцесс мог обьяснить 
ядру какой именно терминал (1 2 или 22) баш просит подкрутить его настройки. или подкобчить
настроки драйвера терминала от этого терминала

user space  |                 ядро                        |               железка

процесс 0 ----- /dev/tty2    ядро   драйевер  терминала буфер --------  клава, монитор (терминал)


важно увидет что и /dev/tty2 и буфер драйвера темринала лежат в ядре. но проецесс не может
никак дотянться до буфера. он может дотняться только до /dev/tty2

файл /dev/tty2 это способ дотянуться у юзер процесса до драйвера терминала в ядре.
это его такой канал связи с драйвером термианала.  какой канал связи самого ядра и драйвера
термнинала с терминалом хрен знает. он какото есть. но процессу онневедом. и ненужен
каналы связи я показал черточками.

может интутивно неверно казаться что /dev/tty2 это средство связи процесса с терминалом.
это не так. это канал связи процесса с драйвером терминала.  канала связи пошарится и пошупать
у процесса к самому терминалу железке нет. он есть только у ядра. у драйвера терминала. 
но процесс к этому не имеет нкиакого доступа. процесс общается дотягивется через /dev/tty2
только до драйвера терминала! и то опосредованно. тоесть процесс кладет чтото в /dev/tty2
оптятть с поомощтю ядра. а уже потом драйвер термиала заглядывает в /dev/tty2 вытаскивает 
это оттуда морщится нюхает вертит между пальцев и гадливо это передает на монитор терминала.

итак что такое файл /dev/tty2 это такое место куда ядро драйвер темрианал при определенных 
условиях скаывает те байты которые прислало клавиуара терминала. если какому то процессу 
интересно что там прилетело с кнопопок терминала2 то такой процесс может заглунуть в 
файл /dev/tty2 и прочитать. если же какйто процесс захочет чтото нарисовать на экране терминала2
символы то он может открыть файл /dev/tty2 сунуть туда байты. и эти байты заберет ядро и пошлет
комаду на мониттор терминала чтобы он нарисовал там какието симоволы.

что из себя прдстлвяет железка терминал по сути. это клава и монитор.  и бльше ничего.
зачем оно нужно. это средство общения между человеком и процессом. между челоком и компом.
человек с помощью клавы шлет в процесс внутри компа  байты. пытаясь таким макаром начать чтото 
делать полезное этот процесс. процесс в ответ шлет байты ответа которые в итоге рисуются в форме
графических смиволов на монитторе чтобы чеолвек мог понять что там прилетело в  в ответе от
процесса.  потому что ток или байты человек не умеет чуствовать . он может зато картинки 
распознавать.

для процесса файл /dev/tty2 это просто файл из котрого прилетают байты и в который можно 
запиывать байты. но если процесс понимает что это непросто обычный файл а  файл связанный 
с драйвером терминала то процесс может  нетлоько принмать и посылать байты через read() write()
но еще может и делать настроки как на драйвере терминаоа в ядре так и на самой железке терминал
(прося об этом ядро естесвтенно через ioctl())
какието моментики что можно на практике подкручивать я уже выше показал. а так мало знаю
что полезного можно там накрутить.

что будет если терминал включен. человек тыкает кнопки. но процесса внутри компа который бы
читал из /dev/tty2 нет. а будет то что кнопки будут прилетать внутрь драйвера терминала в ядре.
там будут копиться. драйвер терминала будет на теримианале на мониторе их рисовать. потом
драйвер терминала сбросиит эти кнопки в файл  /dev/tty2 и на этом все. больше ничего 
и\или ничего полезного не произойдет.

кто дожен внутри линукса запустить процесс котоырй бы читал писал в /dev/tty2 который бы 
интерсовался этим файлом. ответ - процесс init. он должен заранее запустить процесс 
в частности agetty который бы ждал что наконец чтото прилетело в /dev/tty2

вот эти вот виртальные терминалы в которые превращает линукс клаву и монитор и потом
сбрасывет байты от них в файлы /dev/ttyN они сущетсвуют если мы линукс загрузили в текстовом
режиме. без запуска Xorg.  схема выглядит тогда так


что касается монитора
 черный экран -- монитор -- видеокарта --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 

что касается клавы
клава --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 


в целом клава + монитор составляют железо терминала

здесь я хочу подчеркнуть что если мы видим в системе файл /dev/tty2 и мы беерм процесс.  
и из процесса мы открываем этот файл. и пихаем в него байты и хотим посмортеть эти байты
в форме графических символов на монитторе то как нам "попасть" на этот терминал? попасть
на него вот как - если линукс запущен в текстом режиме то попасть на мониттор этого второго
терминала можно нажав Alt+F2 тогда линукс превратит наш монитор в монитор вот того виртуального
терминала2 !!! и клава в этот момент прерватится в клаву того виртуального термианала2 !
а если мы сидим графическом режиме. то переключиь нашу клаву и мониттор в клаву и монитор
виртуального терминала 2 можно нажав Ctrl+Alt+F2 .
тоесть мониттор виртуального терминала линукс держит виртуально в своей голове тоесть  в памяти
ядра. а когда мы тыкаем Alt+F2 то линукс рисует на нашем физ мониторе то что "нарисовано " 
в данный момент на виртаьном мониторе виртального терминала2.
тоесть эти виртуаьные терминалы они включены в линуксе всегда. просто их ний экран 
и клава виртуальные. а когда мы жмем Alt+F2 то линукс "совмещает" экран виртального терминала2
с реалным физическим экраном компа.

поэтому еще раз. вот мы видим в системе есть файл /dev/tty2 . мы берем его открываем
и в него пихаем байты. мы уже знаем что если есть такой файл значит где то там должен быть 
терминал тоесть железка с клавой и монитором. и что если мы записали в этот файл байты то 
на какомто монитре они должны нарисоваться. где этот мониттор как на него посмотреть?
этот мониттор виртуальный и находится он в памяти ядра. но на какое то время можно совместтить
тот виртльный монитор и наш физический монитор нашего компа. для этого надо нажать Alt+F2
или Ctrl+Alt+F2 и ядро на время превратит наш физ мониттор в мониттор того терминала2. тоесть
ядро нарисует на нашем физ монитрре то что было бы нарисовано на экране терминала2 который
живет в его памяти.

важный момент файл  /dev/tty2 создает само ядро. нам из юзер процесса ничего для этого делать
ненадо. "подключение" к терминалу идет просто через то что мы открываем этот файл

  open("/dev/tty2",)

а далее читаем и пишем из него

  read()
  write()

для изменеие настроке драйвера терминала или самого терминала используем

iocttl()

так как самого терминала физичеки несуществует то измеения будут касаться тлько дравера
терминала. хотя учитыая что на время наш физ монитор перрвашаетя в мониттор терминала
взомжно что через ioctl() можно чтото менять из настроек монитора терминала. 
тоесть условно может вирт термиал обладает шрифтами. и получается что чез iotl() можно 
менять шрифты на экране. ведь драйвер терминала толко посылает что надо пеаать а как это печать
какими глифами это здавалось на самом железном терминале. тоесть кажем ты ему из драурвера
терминала шлешь команду  - используй шрифт "times". и после этого он пеатает все байты 
только этим шрифтом. итп

итак как "искать" экран этого терминала2 в линуксе. как его найти и посмтреть что там
на нем нарисовано разобрались.


возвращаюсь к схеме терминала

что касается монитора
 черный экран -- монитор -- видеокарта --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 

что касается клавы
клава --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 


теперь рассмотрим очень токний и важный момент. дело в том что файл /dev/tty2 он не обычный
как файл на диске. осоеность его в том что если мы берем файл на диске. открываем его и пишем
в него байты то эти байты они застревают и так и остаются внутри этого файла. и после того
как мы запиисали "123" в файл на диске то потом мы читаем из этого файла и в ответ мы 
обратно получим эти "123". все прекарасно. но важно не это а то что когда мы их оттуда прочитаем
то они там так и останутся лежать. и при повторном чтении мы опять в ответ полуим "123"
это супераважно. это своство обычных файлов на диске.
так вот файл /dev/tty2 он совершенно не такой. если я в него чтото записал. а потом я это 
прочитаю. то после этого все те байты которые я из него прочитал они оттуда исчезнут!
и при повторном чтении я получу дулю! тоесть когда я пишу в этот файл он "надувается"
а когда я из него читаю он "сдувается". это супр важно понимать. 

теперь рассмотрим схему

 черный экран -- монитор -- видеокарта --- ядро , буфер, драйвер терминала , /dev/tty2 -- fd/1, процесс 

вот я беру из процесса открываю /dev/tty2 и пишу в него "123" , далее драйвер терминала 
это мгновенно замечает и он оттуда это считывает и файл мнвоенно сдувается. далее драйвер 
терминала отправяет эти 123 на экран монитора. а я  в своем процессе если запущу команду 
чтения то получу дулю! потому что то что язаписал прочитал уже "котото " другой. файл сдулся.
и в нем ничего нет. а если я читаю из /dev/tty2  то то что я оттуда прочитаю это не то что
я в этот файл до этого засунул а это только то что приттело из клавый терминала!
это поимание теперь дожно помочь и прояснить следущий случай.
вот у меня есть процесс который спит и ждет уведомления от ядра о том что на /dev/tty2
чтото поступило в плане чтобы это проснуться и прочитать.

L ᯯ  $ 
 c Ȭ  $ sudo lsof -Pn -p 2843623 2>/dev/null | tail -n 5
agetty  2843623 root   0u      CHR    4,2      0t0        21 /dev/tty2
agetty  2843623 root   1u      CHR    4,2      0t0        21 /dev/tty2
agetty  2843623 root   2u      CHR    4,2      0t0        21 /dev/tty2
agetty  2843623 root   3r      DIR   0,87       40         1 /run/credentials/getty@tty2.service
agetty  2843623 root   5r  a_inode   0,16        0      3117 inotify
 b   $ 


b   $ sudo strace -p 2843623
strace: Process 2843623 attached
pselect6(6, [0 5], NULL, NULL, NULL, NULL^Cstrace: Process 2843623 detached
 <detached ..


потом мы открываем этот же /dev/tty2 файл уже в другом процессе
для начала открою через cat

   # cat /dev/tty2

# lsof -Pn -p 2849700 2>/dev/null | tail -n 4
cat     2849700 root   0u   CHR 136,122      0t0       125 /dev/pts/122
cat     2849700 root   1u   CHR 136,122      0t0       125 /dev/pts/122
cat     2849700 root   2u   CHR 136,122      0t0       125 /dev/pts/122
cat     2849700 root   3r   CHR     4,2      0t0        21 /dev/tty2

# strace  -p 2849700
strace: Process 2849700 attached
read(3, 

таким образом cat реально успешно открыл /dev/tty2 в дескпритор 3

я такой экспримент провожу потому что если файл обычный типа с диска то его открыть хоть
миллион раз можно хоть из того же самого процесса хоть из разнхы процессов а вот что
касается особых файлов типа сокетов, пайпов итп то их можно открыть толльк один раз 
и только из того же процеса. так что это был тест. 

так вот если я с другого процесса открою этот файл /dev/tty2 и чегото туда запишу

   # echo "124" > /dev/tty2

то ! внутрь процесса agetty это не попадет! потому что ! все что юзер процесс запихиывает 
в /dev/tty2 то это все мгновенно забирает драйвер терминала и уносит на экран терминала.
поэтому если один процесс сидит и читает из /dev/tty2 а второй пишет в /dev/tty2 то 
тот который читает он никогда не прочитает то что записал другой процесс. при чтении 
из /dev/tty2 в процесс может поступить только байты которые были посланы с клавиатуры
терминала , которые затем попали в ядро, которые затем попали в драйвер темринала и коооорые
затем драйрвер терминала зсунул в /dev/tty2, а так как байты которые мы засунули в /dev/tty2
попали в этот файл путем записи из процесса2 то эти байты никогда не будут доступны для 
чтения из другого процесса !
тоесть то что рабоатае с обычными файлами 

   process1 "123" <-- read  /file1
   process2 "123" --> write /file1


такое с файлом /dev/tty2 никога не сработает! если какйто процессс чтот записал в /dev/tty2 
то другой процесс если будет читать /dev/ttt2 он никогда это не получит. то что процесс 
запиывает в /dev/tty2 мгнвоенно оттуда забиарет дарйвер терминала и посылает на монитор 
терминала! единсвтенные байты коорые можно прочитать из /dev/tty2 это те которые были посланы
в ядро с клавиатуры терминала! поэтому можно хоть до усрачки пихать в /dev/tty2 баайты 
через echo


   # echo "124" > /dev/tty2

при этом эти байты никогда не будут считать через agetty который читает из /dev/tty2 !!!

поэтому если есть процесс1 ктырй читает из /dev/tty2 то в этот процесс просунуть байты 
както слева неполуится путем запиывания байтов в /dev/tty2
единсвтенный способ просунуть байты в процесс1 это напечатать их на клавитуре терминала2 !

но при применении echo все же будет интересный эффект. если мы пошлем данные через echo
и потом отркороем монитор терминала2 то симолвы "124" будут на экране этого монитоора 
этого терминала. тоесть это убдет выглядть так как бутто на экране терминала послала 
эти байты программа agetty хотя она неимеет к этому никкого отншения! поэтому получается что 
если программа "читает из терминала" то у нее наежная защита от того чтобы данные не прилелели
откуда то  сбоку сприпеку. все что к ней прилеиитит точо было сгененировано на клавитуре 
термианла. а вот то что мы увидим на экране терминала  эта информация никак не защищена.
в оконо терминала могут "срать" записываь абсолютно левые разные процессы. и окно термила 
от этого ниак не защищено! я могу открыть /dev/tty2 через пятдесят программ. все они могут
одноврменно писать в /dev/tty2 и на экране будет у меня суммараня каша от всех 50 программ.
и понять от какйо прогарммы что прилетло будет невзомжно. ! мы как бы привыкли что если у нас
есть устройство терминал то к этому терминалу якобы поключено на даный момент один процесс.
и поэтому мы думаем что ели на терминале появилс какието буквы то это ровно то что та программа
послала .  а это полуается не так. то что мы увиим на монитооре это может послать как там прогармма так и еще куча программм любых левых. файл /dev/tty2 может одноврмнно откртьы 
куча процессов. и все они могут одноврменно в него писать. ядро это не запршеает. оно просто
будет брать все эти байты и печаатть на мониторре. аналогия такая как буто 50 прогармм открыли
один обычный файл. аэто незарпшеено. и начали туда все пихать. в итоге конетнт файла будет
мешагина из байтов от всех программ сразу!
ну некая логика понятна. вот у нас есть терминал. его открыл bash

# lsof -Pn -p $$ 2>/dev/null | tail -n 5
bash    2849729 root mem    REG   254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
bash    2849729 root   0u   CHR 136,124      0t0       127 /dev/pts/124
bash    2849729 root   1u   CHR 136,124      0t0       127 /dev/pts/124
bash    2849729 root   2u   CHR 136,124      0t0       127 /dev/pts/124
bash    2849729 root 255u   CHR 136,124      0t0       127 /dev/pts/124

потом мы вбаше заупускаем скажем комнду ls 
тогда баш себя клониурует. и родительский процесс засыпает . при этом у него файл 
/dev/pts/124 по прежнму открыт. 
а в клон пороцессе у нас будет тоже этот файл /dev/pts/124 тоже открыт. и баш 
запуускает execve(ls) и у на новый пцроесс выполянет код ls
тот выполняется и срет данные на fd/1 тоесть на /dev/pts/124 , это дело подхыватывает
драйвер терминала и мы видим на терминале вывод от ls. при этом унас bash тоже имеет
октртым /dev/pts/124 но просто баш спит и поэтоу он не срет на терминал. поэтому  у нас 
вывод на экране термиала идет тлоько от ls.  если бы было тердание что файл /dev/ttyN 
либо файл /dev/pts/N можно открывать только одному процессу то башу нужно было бы зактывьат
этот файл при каждом запуске комады внешней а потом заново открывать.  ну воможно да это 
был бы мудеж. а так логиука у  програмистов ядра такая.  - файл /dev/tty2 может открыть 
любое число процессов. а дальше это уже освтвтвеннность этих процессов чтобы не писать 
одновмренно в этот файл потому что иначе у нас то что будет на кэкране напечатано неп онятно
от какого процесса эта информация приелетела!

знаичит  к настощем моменту я расмотрел  классчиеские терминылы которые можно обозвать 
так что они все харакетризуются файлами вида /dev/ttyN
так по своему назначению эти терминалы предназанчены чтобы наладить контакт обмен информацией
между ЧЕЛОВЕКОМ и ПРОЦЕССОМ. человек общается разговаривет с прцоессом , обенивается байтами
используя клаву как метод отсылки инфомрации. экране служит как перводчик информации от процесса
при приема ответа от процесса. 

кстати баш котоая написана чтобы работать именно с терминалом. но также она может работать
хотя бы в какото степени и без терминала через pipe ! тоесть она может прнимать иноформацию
не от терминала и посылать инфомрацию не натерминал. используяю pipe !
тоесть в какойто степени использования баш можетрабтать и без терминала. 
миеется ввиду что дескприторы 0,1,2 баша необязательно дожны смотреть на файл терминала /dev/ttyN
или /dev/pts/N

также такйо ммоент получается что если программа юзер процесс требует для своей работы
терминал это значит что по своей сути эта программа требует ввода данных со стороны
человека и выводит свои даные для того чтобы их человек посмотрел и проанализировал
глазами. она интерактивная.  подразумевает ввод данных со стороны человека и результат
работы этой программы предназначен имено для человека. типа баш. для сраврения программа
логгер она не требует ввода данных от человека например она может их считать из файла
и выводит данные в файл. ей ненужно чтобы человек их анализировал. ей ненужно интеравтивно
с человеком обмениваться данными. а баш подарзумевает постоянный обмена между ней и человеком.
он ей кусок. она в ответ .он ей куоск новых данных она в ответ. она интерактивная. 
для сравнения cat или echo у них только раз задается паарметр и они его ввыодят и конец
работы  - они нетинтеративные. поэтому эттм командам терминал ненужен. они спокойоно 
и через pipe отработают что на входе что на выходе. баш же постоянно требует ввода 
каких то новых данных от челоека. и баш постоянно подкручивает терминал ее свойства 
через ioctl(). тоесть что дает железка терминал  - она дает овзможность человеку через клаву
постоянно чтото корректировать в работе процесса внутри компа. через клавыу как посредника
послыать внутрь процесса новые данные и команды. общаться с этим процессом. монитор дает 
волзможность получать от процесса обаратну связь в человекопонятной форме.  поэтому если 
программа требует для своей работы термиал это зн8ачит что она требует интерактивного 
учатстия при ее работе. ее нужно постоянно контроилировать коррективровать со стороны
чловека. терминал дает споосою как человек может общаться с процессом. термина это средство 
а цель  это наладить диалог между двумя супер разными сущностями - процесс внутри компа 
жлектрическая хрень и человек. cat или echo нетребует терминал потому что их ненужно 
постоянно корректирвоват. их зарядил и впреед. сервисам ненужен термиал потому что их работа
не подрзауметвает общение с человеком. терминал вслпывает там где прцоессу нужно общаться с 
человеком а человеку нужно пообщаться с этим процессом. процессы разные. кому то нужно 
общение с человеком а кому то нет. если у запущенного проецссов в свойствах еть открыйтый 
файл терминала /dev/ttyN то это значит что это приложение интерактивное. оно позволяет коректирова
ть свою работу в онлайн режиме со стороны человека. также это означает что приложение умеет
ввыводить данные в человекоудобной формет тоесть на экран. тоесть приложение понимает что 
то что оно выисрает через fd/1 оно будет выводитсят на экран. и приложеие должно так 
форматирвовать свои данные чтобы это было удобно читать именно на экране. и это значит что
можно будет на компе открыть окно\монитор того термиала к которму это приложение подключено
и там с этим приложением пообщаться. посмотреть что оно уже высрало на экран. и что оно 
готоово от тебя приять на входе. через клаву.

что касаета современного компа то  классичекие терминалы практиески не исползуются. 
их время золтое было тогд кгда не было графичееского режима. вот когда их было время. 
а так как щас время графческого режима на современном компе выглядит список 
проецсов которые заюзали эти классические терминалы


# ps aux | grep " tty" | grep -v grep
root  tty7   /usr/lib/Xorg :0 -seat seat0 -auth /run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch
root  tty3   /sbin/agetty -o -p -- \u --noclear - linux
root  tty2   /sbin/agetty -o -p -- \u --noclear - linux
 

причем не очен понятно .ну два агетти которрые работают и они покдлючены к терминлам 2
и 3  это понятно. это получается в если перключусь на  терминал 2 или 3 то эти программы
ждут что я веду с клавы логин пароль они его проверят и если все окей то запустят процесс
bash котрый они привяжу к этому терминалу. тость это такие прогарммы прверяеряльщики пароля.
вот а на счет терминала 7 непонятно. 

# lsof -Pn -p 1162 2>/dev/null | sort | grep CHR
Xorg    1162 root   0r      CHR                1,3       0t0          4 /dev/null
Xorg    1162 root 120u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 132u      CHR              13,66       0t0        156 /dev/input/event2
Xorg    1162 root 134u      CHR              13,65       0t0        155 /dev/input/event1
Xorg    1162 root 135u      CHR              13,73       0t0        481 /dev/input/event9
Xorg    1162 root 136u      CHR              13,67       0t0        400 /dev/input/event3
Xorg    1162 root 138u      CHR              13,74       0t0        715 /dev/input/event10
Xorg    1162 root  14u      CHR                4,7       0t0         26 /dev/tty7
Xorg    1162 root  15u      CHR             10,127       0t0          2 /dev/vga_arbiter
Xorg    1162 root  16u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 175u      CHR              13,76       0t0        827 /dev/input/event12
Xorg    1162 root  17u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 184u      CHR              13,69       0t0       7260 /dev/input/event5
Xorg    1162 root 186u      CHR              13,71       0t0       7267 /dev/input/event7
Xorg    1162 root  18u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root  19u      CHR              226,1       0t0        479 /dev/dri/card1
Xorg    1162 root 207u      CHR              13,72       0t0       7270 /dev/input/event8
Xorg    1162 root 220u      CHR              13,68       0t0       7256 /dev/input/event4
Xorg    1162 root 228u      CHR              13,70       0t0       7263 /dev/input/event6

видим что Xorg имеет кучу открытых устроусйтво ввода. потом открую видеокрарту.
и /dev/tty7

непонятно то что в окно терминала 7 невозможно пререкоючиься. потому что Alt+F7 дает то 
что открывается уже графиеская система. поэтому получаетя что врдоде как Xorg подключен 
к терминалу 7 но как на него переключится в линксе непоянтно. вместо окна терминала 7 
вылезает графичскя система. 
а так по идее что должно было быть - я каким то макаром перлючаюсь в терминал 7. моя клава
прерващается в клаву терминал. и мой монитор прервщается   в монитор терминала. далее то что 
я начинаю вводить с клавы оно улаеае в ядро в  драйвер терминала. и он это записвыает в
/dev/tty7 и Xorg это мог прочиать. тоесть то что я выткаивал бы с клавы оно  бы прилетало
в /dev/tty7 а Xorg если бы хотел мог бы  с этим познакомться прочитав. и если бы он захотел
ответь то он бы мог написать мне ответ в /ev/tty7 а драйрвер бы терминала это бы прочитал 
и мне на экране бы отрисовал.  одна проблема - непонятно как преключится в терминал 7. 
поэтмоу получетс вроде как Xorg приложени интеративное. но непонятно как попасть на терминал 7.

c приходом графической системы надобность в классических терминалах типа отпала. 
у нас теперь создается окошко на экране. за этим окошком следит Xorg. если событие в окошке
наступает , тоесть если мышка пролетает мимо окошка. или если окошко выделено и на клаве 
кнопка нажата то это все посылается ядром в процесс Xorg. а он это все отсылает в тот 
процесс который его попросил создать это окно. например файрфокс или gnome-terminal 
или xterm. тоесть Xorg это как бы рисовалка окон. а  такие программы как xterm или gnome-terminal
или firefox у них это окно рисуется в их голове вириуально. тоесть Xorg сообщает мол эй файрфокс
там мышка клинкнула в окне твоем в точке 23,17 - че то надо делать или нет. файрфокс анализирует
и пишет в xorg - нужно вот такой то кусок вот такто прериоросвать. тоесть Xorg грубо говоря
"видит " как все нарисовано на экране. и сам рисует. а  програмы которые обращаются к нему
у них этот рисунок в голове только. и получается со старых времен остались интерактивные 
программы которые работали в связке с классическим терминалом. их что на помойку выбрасыавать?
оказывается нет. придумали ПСЕВДОТЕРМИНАЛЫ. они служать для того чтобы общаться одному ПРОЦЕССУ
со вторым ПРОЦЕССОМ. тоесть это опять же средство IPC - интрпроцесс комуникейшен. но! 
новые терминалы применятся там где один из процессов со старых времен тоесть требует в своей
работе подключения к терминалу. 
если раньше было вот так


     ЧЕЛОВЕК -> терминад ---- ядро,  /dev/tty7 --- BASH


слева у нас был человек а справа  bash и они с помощью теримнала общались


то теперь возникла новая схема


   ПРОЦЕСС1 ------ /dev/ptmx, ядро, /dev/pts/15 ---- ПРОЦЕСС2

 
причем процесс2 такой по своей природе что он требует его подключить к терминалу. 
чаще всего тогда эта схема выглядит вот так


   ПРОЦЕСС1 ------ /dev/ptmx, ядро, /dev/pts/15 ---- BASH


так как самая часто используемая терминалая программа это bash


башу предоствляется такой файл и такой получается драйвер  в ядре что баш может 
делать все ему привычные терминальные штучки в том числе и юзать все ioctl() которые
он привык массов юзать.  но при этом уже никакого экрана термианала нет в природе кроме
как в памяти ядра. а вместо этого то что бащ посылает обрабатавется и шлется в файл /dev/ptmx
вместо посылки на экран. ну я так примерно насколько знаю через сам файл /dev/pts/15 баш 
шлет типа чистый текст который бы был на экране напечаатан. все хитрые штучки он юзает 
через ioctl() так что как я понимаю ему дают порвезвиться с ioctl() но по факту это нина что
не влияет. а сами данные текстовые прям  в чистом виде он шлет на /dev/pts/15 и оно в чистом
виде переслыается на /dev/ptmx  вместо экрана монитора.  а там уже есть процесс1 который 
сидит и ждет когда же даныне прилтетят на /dev/ptmx и они читает.  повторюсь почему бы
не содеинить поцес1 и баш через пайпы. и типа нет проблем. но проблема в том что баш в своей
работе помимо отсылки данных через STDIN и STDOUT он еще постянно юзает ioctl() вызовы
так что если ему не дать термианал то его ioctl() будут вызывать ошибки как миниуумум потому что
какйо нахрен ioctl() на файле который укзвает не на терминал  а на пайп.
и полуыатся терминалы этого нового поколения позволяют успешно запускать bash. давать ему резвится
с терминалом , потом всю эту терминальную чушь вырезать. и чисто данные уже пускать на процесс.
ну а процесс1 он понимает что такое графическая система. понимае протокол общение с Xorg
и он получив от бащ "чистые данные" тоесть просто текст то процесс1 тогда трансфоривмирует 
ээтот просто текст уже графический формат и дает команду Xorg как это текст уже отрисовать 
именнов графическом окне.  тоесть мы башу подсывавем такую типа затычку эмулирующую терминал.
баш при этом может использовать все сисколыл котоыре он привык исползовать успешно
а именно ioctl(). тоесть с ioctl() вызоывми у баша проблем нет. то есть я как понимаю
через ioctl() баш формтирует текст на экране. а уже через write(/dev/pts/15) он шлет сам
текст который хотел чтобы драйвер терминала на  экране нарисовал.  этот чистый текст поступает
в /dev/ptmx и оттуда его считыает xterm или gnome-termnal который этои чистый текст 
преобрзаует в язык графического протокола и послыает на Xorg который уже рисует чисто точки 
на экране. таким образом мы старую программу присоабачили к графческой системе
кстати фишка в том что прогарма которая слева  


   ПРОЦЕСС1 ------ /dev/ptmx, ядро, /dev/pts/15 ---- BASH


она не обязана быть графической. это любая программа. весь смысл вот этоих терминалов
новоого поколеииния лишь в том чтобы дать возмжность общаться двум порцессоам один просто
любой процесс а второй процесс который обязательно требует подключить его к терминалу

поэтому ровно по такой схеме работает ssh + bash


     $ pstree -Aspt $$
systemd(1)---sshd(459)---sshd(1743)---sshd(1749)---bash(1750)



     $ sudo lsof -Pn -p 1749  | tail -n 12
...
...
sshd    1749 noroot    9u   CHR                5,2      0t0     86 /dev/ptmx



     $ sudo lsof -Pn -p 1750  | tail -n 4
bash    1750 noroot    0u   CHR  136,3      0t0      6 /dev/pts/3
bash    1750 noroot    1u   CHR  136,3      0t0      6 /dev/pts/3
bash    1750 noroot    2u   CHR  136,3      0t0      6 /dev/pts/3
bash    1750 noroot  255u   CHR  136,3      0t0      6 /dev/pts/3



тоесть у нас схема такая

                         ТЕРМИНАЛ
     SSHD  ---- /dev/ptmx, ядро , /dev/pts/3 ---- BASH


получатся у нас термиал нового поколения "проксирует" связь между sshd и баш.
межу двумя процессами.


>>>>>> закончтл тут











  






/dev/pts/15 это не просто труба по передаче байтов как пайп 
а это вход в устроство в железку! в терминал. который как принтер. э
---
как было раньше. 

1) человек сидит перед коробкой. экран с клавой - терминал. в нем нет ни цпу ни памяти.
типа это почти что мониттор и клава.

2) это проводу идет в ядро. там сидит драйвер этого терминала

3) в ядре есть вирт файл /dev/tty2 который ведет в драйвер терминала

3) в глубине памяти мейнфрейрма сидит баш процесс c именами дескпрторов 0 1 2.
эти деспритторы кодируют имя файла /dev/tty2

 0 ---> /dev/tty2
 1 ---> /dev/tty2
 2 ---> /dev/tty2
 

вот человек нажал кнопку на клаве этого ящимка и кнопка улетела в ядро удаленного 
мейнфрейма. и застряла в ядре в драйвере терминала. но драйвер не обязан эту кнопку сразу
пересылать бащу! у него мжет настроено чтобы переслать кнопку только если нажали Enter
поэтмоу мы можем на клаве нажать несколько кнопок они все тут же улетели в ядро и там лежат.
но в баш еще ничего не прилетело. и вот мы нажали Enter и олько тгда ядро передал все
эти кнопки в файл /dev/tty2 и толкьо тогда баш получил эти кнопки! тоесть по времени это будет
совем не то время когда они были нажаты!
еще момент. мы нажали кнопку она улетела в ядро. но нажатие кнопки невлечет автоматически
что мониттор этго ящика будет эту кнопку рисовать! нажатие кнопки это одно а отрисовка ее 
на экане это совершеннодругое! и в райвере ядра может быть настройка "эхо" такая что если 
в ядро прилеетела кнопка то ядро автоматом без участия баша  обратно на кообробку отслыает
сигнал нарисовать букву!  и у нас на экране загорается буква! но не потому что баш ее 
получил и нам обратно отослал! нет!  буква загорелась потому что удаленное ядро дало такую 
команду! а бащ эту букву еще вообще не получал! она лежит в ядре! 
баш через ioxtl() насраивает так драйвер темрианала в ядре что ядро при получении буквы тут
же ее шлет в баш. также баш отключает эхо у ядра. тоесть ядро при получнии буквы само
обратно нешлет сигнал на ее отрисовку. вместо этого сам баш при получении буквы ее сразу
шлет обратно ! тоесть бащ на себя берет часть функций драйвера терминала. баш отключает эхо
, трбует  у драйвера чтобы он неждал ентер а сразу пихал полученную букву из ядра в баш.
и баш сам шлет братно полученную бвкву! кога баш азпускает внешнюю коману то он все возвращает
в терминале - он влкювает эхо! и он вкюачает что драрйвер терминала непереслыает буквы процессу
пока неполучит ентер
тоесть монжно запустиь программу в черном окне. и тыкать кнопки на клаве и на экране они будут
рисоваться но стрейс покажет что процесс ничего не получает. а всепотому что кнопки 
прилетаютв ядро в дравер терминала и там застревают. и ядро обратно шлет символы на экране
и унас впечатление буквы уже внуири процесса и он нам в ответ их отрисовал. а ниуйя этовсе 
ядро и его драйвер терминала. и толко когдмы тыкнем ентер нам стрейс покажет что буквы
наконец поступили внутрт процесса!

я это проверил. 251.c

122             
PARENT PROCESS. READ DATA FROM /dev/ptmx : 122
 w ᴱ  $ cat 251.c
#include <stdio.h>
#include <unistd.h>

int main() {

     int pid = getpid();
     printf ("pid = %d\n",pid);

               char buffer[256];
                 int len = read(1, buffer, sizeof(buffer) - 1);
                 if (len > 0) {
                    buffer[len] = '\0';  // Null-terminate the string
                    printf("PARENT PROCESS. READ DATA FROM /dev/ptmx : %s", buffer);
                 }



    return 0;
}
 r 鮖  $ 


 запускаем эту прогу в одном окне

 а вдругом окне запускает strace этгоо процесса

потом идем в первое окно и начинаем тыкать кнопки. и нажимать бекспейс.
и все эти букы рисуются на экране
и во втором окне видно что в процеесс ничего не прилктает! 
получается что буквы прилетают в ядро. они прилипают там внутри к драфуреру ядра.
и ядро делает эхо и шлет на экран символы! это делает не прцоесс.  и потом мы еэмем ентер
и они наконец то попают в процесс!хотя мы ввели их давно и накэарне они адвно! и редактирование
их наэкране это за счет ядра ане пцроесса! но этот режим не касается раоботы в баш

еще важно пнять


процесс fd/1 ---> /dev/tty2  ядро -- драйвер терм -- --- провод ---- экран терминала -- человек

важно понимать что между терминалом и ядром мейнфейрейма связь чисто электическая
тоесть цировая связь идет тлоько между процсосом и ядром  а между ядром и терминалом
идета аналоговая связь поэтому кода ядро делает эхо на экране терминала это ниак не связана
с прокачкой байтов через какой либо псевдовайл файл

аналогично для тексвого режима линуса


процесс fd/1 ---> /dev/tty2  ядро -- драйвер терм -- --- видеокарта ---- экран терминала -- человек

еще раз когдая ядро делает эхо то для нас это прозрачн никак не завфиикировать потому что 
это ядро шлет данные сразу на видеокарту. а оттуда на экран. а не то что ядро шлет на tt2
нет. 
тоесть /dev/tty2 это не файл связт между коробкой терминала и ядром мейнфрейа! нет там
все было аналоговое. /dev/tty2 это файл связи между процессом и ядром!


граф режим
процесс fd/1 ---> /dev/pts/10 -  ядро -- драйвер терм ----- /dev/ptmx ---- xterm - Xorg -экран терминала -- человек


ВОПРОС - почему если я шлю байты с другого процесса на /dev/pts/10 то они в процес1 не влетают?
а ели я шлю байты на /dev/pts/10 через /dev/ptmx из xterm то байты до процесса1 долетают?
ОТВВЕТ - уменя вот какое впечателние
     процесс fd/1 ---> /dev/pts/10 -  ядро -- драйвер терм ----- /dev/ptmx
                         /|\ =========================================>
                          |

                       проецесс 2

у меня впечателние что файл /dev/pts/10 он таков что если его ты открыл и ты в него 
пишешь то ядро всегда те батй которые ты в него снуул оно их шлет на драйвер экрана!
я это показал стрелой. ты можешь конечно и читать с этого файла - но! ты будешь читать 
из него только те байты которые были отправлены исключительно через /dev/ptmx!!! вот
видимо в чем разгадка!  пэтому когда мы из процесс2 пишем в pts/10 то пытаться это прочитать
из процесс1 fd/0 бесполезно!тоесть то что ты туда записал оно сразу оттуда улетает  как 
через запись в сокет , тоесть аналогично сокету (правда двапроцесса не смогут пключится к 
одному файлу соакета) если я чтото сунул в сокет то это сразу исчезает и вылетает на том
конце сокета.  а если я из него читаю то я буду чиать оттоько то что мы всунулто в сокет 
с той стороны второго сокета! тоесть получается как уббутто файл эт точка фхода одна но
там внутри две пары пайпов котрые не переекаются. то что влетело сразу улетает туда. 
а если я чтото читаю то это читается то что было всунуто не на этой стороне а толко на той!
этовсе обянсяет! почму пихая в pts/10 из процесса2 я будт это видеть на экране (потому что
оно сразу улетело на втророй конец ptmx) и попытка это считать из prcocess1 нчиего недаст.
зато если чтото шлется к нам через ptmx  и мы читаем из процесса1 и процесса2 один 
и тоже pts/10 то мы оба будем конкурировать за это. и чась прчитает процесс1 а чатсть 
перехватит процесс2!


что значит что у процесса есть терминал или нет терминала?
изначально термиал это было устройство для общения процесса внутри компа и живого человека
тоесть это не связь меджу процссом и процессом (это было не средство IPC интепрпроцесс
коммуникейшен. это было серство комункиации прцесса и челоекка)
участники
 
  процесс  - /dev/tty2 драйвер терминала --- терминал - человек

для процесса признком того что на той стороне сидит человек за терминалом явялеось 
то что fd/0/1/2 смотрит на спец файл /dev/tty2
а если на той стороне терминал то процесс делал натсройки терминла через дайрвер 
терминала в ядре через спец ссиколлы

вслучае текст режима лиукнса считай так и есть

проецсс fd/0 - /dev/tty2  дравер терминала    - экран+клава

в случае когда у проецесса открыт псевдотерминал /dev/pts/10 то это значит что 
для процесса все выгдядиттак что с торой стороны по прежнму терминал с челоевекком
а нсаомом деле с той стороны другой процесс!!!


прцоесс fd/0 --- pts/10  драрвер терминала /dev/ptms-- процесс 2

еслипроцессу которому нжуен терминал типа баша посунуть внместо термианал пайп или сокет
то скрей всего баш вылетит с ошиькой потому то тчто он начнет делать ioctl() пытась 
этот терминал настройкит . а ядро верент шибку и баш видимо вылетит с ошибкой. 
тоесть прримым котрые напсианы с тербованияем дать им терминал они порзумеваеют что 
с той стороны будет не процесс сидеть а будет сидеть железка терминал и на ней человек. 
формально ролучется что есть процессы которые заточены не для общени с друими процессами
или общеия с обычными файлами а для общения с железкой! железкой терминалом! еси
им желеку это не предотваить то они выплоять ряд спциифических сисколоов получат отлуп
и просто вылетят!

вот что значит что процесс требует терминал. 

аесли он нетрует терминал но ему его предоставить то он пхож на  локальный сокет 
двухсторонний. и значит есть другой процесс клторый сязана с этми процессом. хочет от него
получать отвартлять данные через этот канал. тольло ели прогарамма не требует терминал
то лучше их обьядениять через сокет локлаьный!

такеж важно - вот обвынй файл похож на трубу с зтанутойдыркой на той тороне. потому ели
мы открыли файл и туда чтот записали то оно там в туреб и осталобсь. пэтому елси мы записали
и тутже начинаетм читать то мы конечно и обратно получим то что заисали! так устроены
обычные файлы! а пайпы и сокеты устроены по другому1 это труба сыдыркой на том конец.
если я с этой сторон ыдырки чтото туда записал то чиатть с этой стороны не сымсла потом что 
все что язапиаса уже улетело на ту стороны дырки!  а если я будут читаь то я сомгу прочитаь
тлько то что был всунуто с той строны дырки! ровно также раотают и пара файлов у псевдом
терминала! если я чтот вснул в pts/10 и начну читать из pts/10 то я нчего не проитаю потмоу ч
то вс уже уделетло на тот конец в dev/ptmx 
а если я читаю и чтот получаю то это тлоько то что быо всунуто  в трубу через дырку /dev/ptmx!
пэтому ялси два айла открытли pts/10 и один туда пишет а второй сразу чиатет то тот кто 
читает он ничего не получит! потмоу что все что было апиано улетело в /dev/ptmx!
а вот елси оба читают то они будут конкуиовать за теб айты котоыре суются со сторны дырки /dev/ptmx!
поэтому если у мня есть окно терминал и ест бащ который связа с этим терминалом и я зочу  
всунуть в баш данные то нужно либ тыкать кнпоки на окне термнала. либо нужно совать данные
в /dev/ptmx но с чужого процеса пдлкючтиься к /dev/ptmx неполучится. кроме ориигианлього
процесса котоырй его открыл!

кстаи если я вижу в пцроессе /dev/ptmx то понять в каком процессе сидит его слейв pts/N 
в целом роде как хрен найдешь. в си дя этого есть спец функция. а как это искаь рукаи 
чере баш хрен знает. 

попытка открыть /dev/ptmx из друго процесса хоть для чтения хоть для записи 
недает нихрена
так что к нму хрен подлезешь
возможно потому этот файл мало открыть с ним потом еше нужн мудить

  md = open("/dev/ptmx", O_RDWR | O_NOCTTY);
  int sl1 = -1;
  sl1 = grantpt(md);
  sl1 = unlockpt(md);


поэтому просто cat или echo не прокатит!



еще раз . кода пише ь в файл pts/10 и потом думаешь я чео я читаю и ничего нет вответ.
потмоу что нужно понимать приоду файлов. есть обычноые файлы. куда ты навалил и оно
там осталс. пэтому туту же читая ты получишь то что записал ранее. а друие файлы как 
дыряое ведро. то чты  ты зваисал то уже там этого нету. оно улетело в дурго файл который
типа другой конец трубы. тоеть

один файл /dev/pts/10 он как ведро  с дыркой
если бы он был обчнй фйл я в него налил данные и они там остались. а так то что 
я туда налил оно тутже выиывется и перливается в дуройфайл  /dev/ptmx! ровно также 
как у двух файлов пайпа. только пайп файл неоволет читаь и писать из одного фалйа. но
зато в точности как у окального сокета. ты зливаешь данные в одн файл. а тм уже данны
и нет. они переиты ыли ядром во второй файл. это касется socketpair()

а вот сокет на сонвое файл ана диске 
хотя якобы два проесса подключены к однму файлу
 d ⱔ  $ ps aux | grep nc | grep un2
noroot   2819780  0.0  0.0   3160  1540 pts/106  S+   05:44   0:00 nc -l -U ./un2
noroot   2819783  0.0  0.0   3160  1496 pts/108  S+   05:44   0:00 nc -U ./un2
 % 鿩  $ 
 R   $ lsof -Pn -p 2819780 | tail -n 10
lsof: WARNING: can't stat() tracefs file system /sys/kernel/debug/tracing
      Output information may be incomplete.
nc      2819780 noroot mem    REG              254,0    63736   1594801 /usr/lib/libresolv.so.2
nc      2819780 noroot mem    REG              254,0    76664   1745618 /usr/lib/libbsd.so.0.12.2
nc      2819780 noroot mem    REG              254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
nc      2819780 noroot   0u   CHR            136,106      0t0       109 /dev/pts/106
nc      2819780 noroot   1u   CHR            136,106      0t0       109 /dev/pts/106
nc      2819780 noroot   2u   CHR            136,106      0t0       109 /dev/pts/106
nc      2819780 noroot   3u  unix 0x000000001f6c02d6      0t0  32247184 ./un2 type=STREAM (LISTEN)
nc      2819780 noroot   4u  unix 0x00000000a452b7e5      0t0  32247185 ./un2 type=STREAM (CONNECTED)
nc      2819780 noroot  10w  FIFO               0,15      0t0  32231023 pipe
nc      2819780 noroot  12w  FIFO               0,15      0t0  32231024 pipe
 $ 쉴  $ 
 8   $ lsof -Pn -p 2819783 | tail -n 10
lsof: WARNING: can't stat() tracefs file system /sys/kernel/debug/tracing
      Output information may be incomplete.
nc      2819783 noroot mem    REG              254,0  2014520     55931 /usr/lib/libc.so.6
nc      2819783 noroot mem    REG              254,0    63736   1594801 /usr/lib/libresolv.so.2
nc      2819783 noroot mem    REG              254,0    76664   1745618 /usr/lib/libbsd.so.0.12.2
nc      2819783 noroot mem    REG              254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
nc      2819783 noroot   0u   CHR            136,108      0t0       111 /dev/pts/108
nc      2819783 noroot   1u   CHR            136,108      0t0       111 /dev/pts/108
nc      2819783 noroot   2u   CHR            136,108      0t0       111 /dev/pts/108
nc      2819783 noroot   3u  unix 0x0000000019deda0e      0t0  32250909 type=STREAM (CONNECTED)
nc      2819783 noroot  10w  FIFO               0,15      0t0  32247926 pipe
nc      2819783 noroot  12w  FIFO               0,15      0t0  32247927 pipe
 L 蘵  $ 

но если смотреть через /proc

 v ႅ  $ ls -1al /proc/pid/2819780 
ls: cannot access '/proc/pid/2819780': No such file or directory
 s 츭  $ ls -1al /proc/2819780/fd
total 0
dr-x------ 2 noroot noroot  7 ноя 29 05:44 .
dr-xr-xr-x 9 noroot noroot  0 ноя 29 05:44 ..
lrwx------ 1 noroot noroot 64 ноя 29 05:44 0 -> /dev/pts/106
lrwx------ 1 noroot noroot 64 ноя 29 05:44 1 -> /dev/pts/106
l-wx------ 1 noroot noroot 64 ноя 29 05:44 10 -> 'pipe:[32231023]'
l-wx------ 1 noroot noroot 64 ноя 29 05:44 12 -> 'pipe:[32231024]'
lrwx------ 1 noroot noroot 64 ноя 29 05:44 2 -> /dev/pts/106
lrwx------ 1 noroot noroot 64 ноя 29 05:44 3 -> 'socket:[32247184]'
lrwx------ 1 noroot noroot 64 ноя 29 05:44 4 -> 'socket:[32247185]'
 o 屢  $ 
 3 |  $ ls -1al /proc/2819783/fd
total 0
dr-x------ 2 noroot noroot  6 ноя 29 05:44 .
dr-xr-xr-x 9 noroot noroot  0 ноя 29 05:44 ..
lrwx------ 1 noroot noroot 64 ноя 29 05:44 0 -> /dev/pts/108
lrwx------ 1 noroot noroot 64 ноя 29 05:44 1 -> /dev/pts/108
l-wx------ 1 noroot noroot 64 ноя 29 05:44 10 -> 'pipe:[32247926]'
l-wx------ 1 noroot noroot 64 ноя 29 05:44 12 -> 'pipe:[32247927]'
lrwx------ 1 noroot noroot 64 ноя 29 05:44 2 -> /dev/pts/108
lrwx------ 1 noroot noroot 64 ноя 29 05:44 3 -> 'socket:[32250909]'
 v べ  $ 

 то получаптс один пцроцесс смотрит на   'socket:[32247185]'
 а второй прцоесс смотрит на файл 'socket:[32250909]'
 поэтому это опять же ситема из двух разных файлов. то что в один вливаем тутже 
 из него исчезает  и появляется во втором.

                    -----------------------------
                     >>>>>>>>>>>>>>>>>>>>>>>>>>
'socket:[32247185]' -----------------------------  'socket:[32250909]'
                     <<<<<<<<<<<<<<<<<<<<<<<<<<<
                    ------------------------------

причем мне видится это так.  
причем пцроесс переливаяни байтов с оного файл в вдругой независим по двум направлениияем.
тоесть можно одоновмренно заливать в каждый из двух файлов и это никак не помешает.
тоесть процесс 1может записывть  "111111" в 'socket:[32247185]'
а процесс2 может в тоже время запиывать "222222" в  'socket:[32250909]'
и после этого у нас млжно успешно прочиать из  "222222" из 'socket:[32247185]'
и успешно прочиать  "111111" из 'socket:[32250909]'
тоесть виимо в ядре для каждого файла ест два буфера. в один буфер зливаются байты котоыре
потому будут перелиты во второй файл. а второй буфер использутся для тогочто как раз из него
и читае прцоесс если он обащвется к файлу на чтение. и пэтмоу нет конфлика и перечсеняиеи!




ВОПРОС попробоваь открыть обычны файл. поставить на паузу. потом открыть с другого процесса
измнить его конеткнт.  а потом прчитать из первого процесса. он же увидит все что наизменял
второй процесс?



---


что такое эхо в терминале?
---
процесс-1 имеет /dev/ptmx
процесс-2 имеет /dev/pts/15
я проверил процесс-1 пишет в /dev/ptmx и это успешно прилетает в process2 в /dev/pts/15
и наоброт process-2 пишет в /dev/pts/15 и это прилетает в prcoces1 в /dev/ptmx
---

еще вопрос у мен заущен баш котоырй смотрит в терминал /dev/pts/15
и в баш стоит селект(0,1)
я с чужого процесса открываю /dev/pts/15 и шлю байты на экарне они рисуются но 
селект в баш остается мертвым. почему?




НИЖЕ УКАЗАН БОЛЕЕ СТАРЫЙ МАТЕРИАЛ,
ВНЕМ МОУТ БЫТЬ ОШИБКИ

| terminal
| pty
| line discipline

 

 я щас хочу описать очень тонкую вещь.  я оней прочитал 
 на стек оверфлоу.


 вот у нас типичная ситцауия с терминалом



черное граф окно --- ядро X11 драйвер --- (socket)xterm(ptmx) ---- ядро line discipline------(pts/10)bash


тоесть xterm он породил граф окно в X11 системе. а граф окном 
управляет ядро. и xterm получает от черного окна инфораацию 
через сокет который он открыл. если в черном окне мы тыкаем клавишу
то она летит в ядро вдрайвер X11 и ядро ее шлет через сокет в xterm

а через ptmx xterm держит связь с башем . между ptmx xterm 
и pts/10 bash сидит ядро с своим кодом "discipline line" который собс
твенно всю логику работы терминала и выполняет. так вот 
что здесь важно понять и увидеть.

человек выдяеляет мышкой черное граф окно и тыкает кнопку на клаве.
кнопка из окна попадает в ядро  в x11 драйвер. ядро эту кнопку
шлет в сокет xterm таким макамро кнопка оказалась внутри xterm
процесса . (байт кнопки). круто. xterm получив эту кпнопку через сокет
он ВНИМАНИЕ ее мгновенно пересылает в ptmx . МГНОВЕННО! это важно.
эта кнопка влетает в ядро в код "line discipline"
а дальше происходит ОЧЕНЬ ВАЖНАЯ ВЕЩЬ - в зависимости от того как
настроили настройки этой "line discipline" как xterm 
так и процесс на той стороне в данном случае bash то код в ядре
"line discipline" он может поступить ТРЕМЯ разными способами!
     1) он может байт кнопки НИХРЕНА дальше не пропустить! вау!
     зато вместо этого "line discipline код" мгновенно ОБРАТНО в
     через ptmx в xterm шлет такой же байт!
     и получается для xterm все выглядит так что он послал 
     байт в приложение которое сидит за ptmx и он якобы сразу
     прислало ответ! хотя ответ по факту прислал не баш!!!
     а прислало ядро!! охренеть! и xterm то что он получил мгнвоенно
     переселыает в сокет чтобы это нам X11 нарисовало на экране!!
     поэтому мы нажав на кнопку с буквой на клаве видим тут же 
     эту букву на экране! это назвыается в терминах терминала как 
     "echo" эффект. но согласист как же хитро! как мерзко !
     как по гнидски устроена эта схема!!!! 
     а баш как я скзаал при всем при этом нихрена еще ничего не 
     получил!!!! line discipline может быть настроен так 
     что он будет копить все символы которые ему xterm шлет 
     до тех пор пока из черного экрана не прилетит к примеру
     с клавы символ кнопки Enter.  ИВОТ ТОГДА НАКОНЕЦ line discipline
     отошлет уже весь массив всех кнопок в баш!!!!
     это все можно легко проверить если в xterm запусить команду 
     	$ cat -
     и как это будет выглядеть. мы будем наимать на кнопки и они 
     будут сразу появлятся на экране при кажом нашем нажатии. 
     а потом мы нажмем Enter и на экране появится дубликат той
     строки которую мы набрали по буквам. дубликат появится только 
     после тго как мы нажали Enter, не ранее! так вот пиздец это как
     работает как  я описал выше. когда мы тыкаем буквы то они 
     с черного экрана ядром через сокет посылаются в xterm  и он
     их мнгнвоенно пеерслывает в ptmx и они попадают в ядро
     в line discpline код ядра. и он в cat нихрена ничего не шлет!
     зато он сразу каждую полченную бувкву шлет обратно в ptmx
     к xterm процесу и он монвоенно это перелывает в сокет оттдуа
     оно подает в ядро в X11 драйвер и драйвер рисует в черном
     окне наэкране букву. а cat при этом нихрена не получает! он
     на голодоом пайвке! и тоько окгда мы тыкнем Enter и егополучит
     line discpline ТОЛЬЛКО ТОГДА наконец line discilie
     перешлет весь набор набитых до этого символов в cat через
     pts/10 файл! и тогда cat получив наконец то что ему прислали
     он мгвновенно высирает это в stdout который тоже смотрит  в 
     pts/10 оно обратно влетает в ядро в line discipline и тут
     конечно line disline настроен так что та инфо что влетает 
     в line discpine со стороны pts/10 он мгновенно шлет в ptmx
     (ксати я не знаю всегда ли это так. может там тоже можно
     настроить line discpl что оно то что прилетает со стороны pts/10
     тоже собирает в кучку и ждет enter. не проверял не знаю.).
     из ptmx он поступутат  в xterm . оно это имеетя ввиду то что
     послал cat то есть срочка целиком. и он то что получил опять
     же не лукавя шлет в сокет. это летит в яро. ядро через x11
     рисует на экране. вот такая очень хитрая схема. получается
     и в ту стороу все хитро работает и вобратру стоорону тоже. 
     то что мы ыткаем в черном окне на клаве оно не факт что должает
     то процесса конечного. а то что рисуется на экране оно 
     не факт чтоприетело от того процесса коенчного. оно могло
     прилететь и от кода ядра line discipline.  и это пиздец!
     поленейший!

    получается также что эта вся схема так устроена что из за 
    того что мы нажали кнопку и логично ожидаем что она тут же 
    отрисуется на экране (как буто кнопки и экран это одно и тоже
    неразрываное существо) а это нихуя нетак. то что мы тыкаем
    кнопки для этой системы нипель это одно. а рисование
    на экране терминала это совсем другое.  и чтобы нажатая кнопка
    рсиовалась на экране это вот надо еще постараться!

 я бы сказал что классический железный терминал в этой схеме
 эмулирует черное граф окно + ядро с его x11 драйвером + xterm
 процесс. вот это все работает в точности как железный терминал.
 line discipine она как была раньше при подключенном реальном
 желеном терминале так она и осталоась в этой цепоечке.
 тоесть раньше схема была такая

желез терминал ---------- (com) ядро, line discipine ------ (/dev/tty2)bash  процесс

так было раньше.

хотя я вот думал что то что на жел терминале рисуется сразу символ
после нажатия клавы это настройка самого терминала. а вроде как 
оказалось что нет.
также я думал что редактирование символов это хрень была реальзована
внутри термиала в некотором его внутреннем буфере. а это якобы согласно
стекофверфлоу тоже окаазалось неправда. символы сидят в linediscipine
и он служит буфером для редактирования. скажем мы щлем с клавы
терминала символ "backspace" и linediscpine в своем буфере удаляет
последний символ справа который там сидит. и паралельно шлет 
обратно на терминал такойже байт. а терминал уже у себя на 
экране тоже стирает этот символ. вот такая пиздец схема!

2) вторая схема работы состоит в том что line displine так настороен 
что если в нее с черного экрана с xterm процесса c ptmx 
прилетает символ то line discpine мгнвоенно его передает дальше
незадерживая его в своих кишках! так работает лайн дисциплин 
когда у нас конечнм прцессом запущен баш! он когда старутет он 
шлет кучу ioctl сисколлов через pts/10 в line discpline. он ее
программирует. и он ей задает такой режим! поэтму когда мы 
нажали кнопку в черном окне она мгвноенно доолетает до баша!
также я подохрвеваю что баш отклчает на лайн дисциплин режим echo.
тоесть когда символ пролеаеет через лайн дисциплин от ptmx 
в сторону pts/10 то лайн дисицплин автоатом обратно этот символ
я думаю не шлет. зато баш когдп получает символ он сам шлет
обратно этот символ. вот кто причина букв на экране после
нажатия клавиши. не лайн дисциплин а сам баш! 

3) третий режим работы такой что мы настрвиаем лайн дисциплин 
и он накаливает буквы летящие в него от ptmx и не отслывает
их в конечное приложение пока не получит символ Enter но
он также и не послывает обратно эти символы! и поэтму нажимая
кнопки на клаве мы небудем видеть ничего на экране! такйой
режим лайн дисцлпин тоже возможен!
например такая хрент может быть полезна при вводе пароля. 
мы вводим пароль но на экране чисто. скажем условно баш может 
перед вводом пароля через ioctl программировать лайн дисцлиплин
на такое поведение. или любой процесс вметсо баша который запущен 
натой стороне.  если запусить баш с strace то можно увидеть 
сколкьо много постоянно ioctl делает баш ососбенно если он 
собирается запустиь левый бинарник через execve. он для него
подготваливает лайн дисицплин. и потом обратно когда левый бинарник
вышел и баш обратно попдает в foreground группу и собатеся продолжать
раобтать с терминалом то баш обратно восстанвлвиет через ioctl 
насторойки лайн дисцплин "под себя" как башу это удобно!

в целом это полная жесть как элементарная хрень реализована
так сложно!! и я бы скаазал дебильно!! всего то навсего надо 
чтобы кнопки летали с клавы на удаленное приожение и чтобы
на экране рисовались эти кнопки. как же сложно они все это
сдеали! мир динозавров деревынных игрушек и запорожцев







