bash

| приколы

приколы баша
$ echo !4
echo ps aux | grep sleep
$ echo !0
bash: !0: event not found
эта хрень показывает команды из истории команд


| tr

эта комнда ищет паттерн и меняет его на другой

$ echo " output=10; input=16; A0" | tr [:lower:] [:upper:] 
 OUTPUT=10; INPUT=16; A0


$ echo "aaa bbb " | tr "a" "D"                             
DDD bbb 



эта команда он подлая. об этом можно прочитать в info tr
вот пример

$ echo "b" | tr  bbbbb  12345
5

вчем подлость команды tr : у нас в паттерне есть несколько b возникает вопрос
когда мы находим b в нашем слове то какой b использовать? тот который b в 1 превращает
или b который в 2 превшращает? или b который в 5 превращает?
ответ такой что берется самый последний b. поэтому все b пропускаются в шаблоне
и берется последний b кторый превращает b в 5.

еще пример

$ echo "a"  |  tr    aaaaaaaaaa 1234567890
0


тоесть у нас есть шаблон aaaaaaaaaa у нас естт исходное ссобщение 'a'
возникает вопрос какой a нужно брать из шаблона. овтет последний.
потом смотрим на какой символ мапится последний a  в шаблонке ответ а ноль.


прмиер

$ echo ooops not good | tr oops nice
iiice nit giid

как это рабооает. 
у нас есть шаблон "oops" у нас есть слово "ooops"
в шаблоне берем последний "o" он мапитсят в "i" получается

[ooo]ps -> [iii]ps

остатеся вопрос с ps он мапиисят напрямую поэтому 

[ooo][ps] -> [iii][ps] = iiips

далее берем слово "not"
берем шаблон "ooops" 
в шаблоне "n" нет. есть "o" но в шаблоне "o" несколько. мы берем последнее "o"
второе "o" мапится в "i"

потмоу что o[o]ps n[i]ce

значит n[o][t] --> n[i][t]
бквы t нет в шаблоне значит t остается без изменений значит

not -> nit

берем слово "good"
ни g ни d нет в шаблоне они без изменений. 
буква o есть  в шаблоне. их несколько в щаблоне мы беерм послнее o в щаблрне оно маится в
i значит

g[oo]d  --> giid

значит в итоге 

iiips nit giid

в целом намой взгляд достоачно неинтуитивная и ебанутая команда этот tr


| special variables $0 $1 $@  $# $* $? $$ $!

`$0` – The name of the script being executed.
`$1-$9` – The first nine command-line arguments.
`$#` – The number of command-line arguments.
`$*` – All command-line arguments as a single string.
`$@` – All command-line arguments as an array.
`$?` – The exit status of the last executed command.
`$$` – The process ID of the current shell.
`$!` – The process ID of the last background command.


рассмотрим $0
я не согласен то о чем везде пишут что $0 это имя скрипта.
посмотрим

$ echo $0
bash

$ /bin/bash
$ echo $0
/bin/bash


$ ln -s /bin/bash ./b-lnk
$ ./b-lnk
$ echo $0
./b-lnk


$ ln -s ./b-lnk ./c-lnk
$ ./c-lnk
$ echo $0
./c-lnk

отсюда видно что $0 эта переменная показывает каким образом был запущен процесс.
а именно его такой параметр как /proc/$$/cmdline

/proc/self vs /proc/$$/ (self это не перменная. это симлинк в /proc/)

запускаем чтото в баше . тогда он себя форкает через сисколл(просит об этом ядро тоесть)то создает дочерний процесс
а вот если в баше прога зпускатся через exec то баш взывает сисколл exec тоесть управлениеп
передаетая ядру. и ядро замещает усовно говорят код баша в процессе в котором крутится баш 
на код вызываемой программы.  

мы импользуем exec когда не хотим создавать новый процесс. а хотим запустиьт прогу
в рамкаж уже этого процесса. 



--
вот так верно

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c", "sleep 120"]

а так полет нахер

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c sleep 120"]

--
вот так верно

docker run --rm --name t1 -it    --entrypoint  "/bin/bash"   ubuntu  -c "sleep 120"

а так полет рахер

docker run --rm --name t1 -it    --entrypoint  '/bin/bash -c "sleep 120"'   ubuntu  
отому что в доках дкоера написано что --entrypont должно сдежать татолько
путь к бинарнику\скриту. но не к параметрам. параметры пишктая в самом справава



==

| -
| ~-

в баше любили повыебвыаться.

если мы в качестве пути укажем "-" то баш подставит вместо этого $OLDPWD
где OLDPWD это сохранненный есть предыдущая папка в которой ты был.
но эта хрень раротботет только с встроенным билтином cd и только в единствнной форме

$ cd -
эквивалентно
$ cd $OLDPWD

при этом вот такое уже нераобтеает

]$ cd -/tmp
bash: cd: -/: invalid option
cd: usage: cd [-L|[-P [-e]] [-@]] [dir]

в эхо это тоже неработает

$ echo -
-


втора хрень "~-" она более универсальная. она раобтотает уже нетолько с cd
но и скажем с echo 

$ echo $OLDPWD
/
[vasya@lenovo //]$ cd ~-
[vasya@lenovo /]$ echo ~-
//


пиздец доблеблы в этом баш. выбеонщики

нашел этот все зесь = https://unix.stackexchange.com/questions/330876/difference-between-cd-and-cd
===
| bash
| redirect
| exec

bash
io redirect

(для начала ознакомился с этим https://tldp.org/LDP/abs/html/io-redirection.html)

разбереся как работает эта команда
       # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3

для начала
немного отойдем в сторону что будет если ввести команду
$ cat > 56.txt
а будет вот что. команда будет ждать ввода текста со стандартного ввода.
тоесть можно сидеть и набирать текст. когда хотим закончить набор то жмем Ctrl+D.
и этот текст набранный в терминале на экране будет записан в файл.

получается форма вида

# echo "asd" > /tmp/1.txt 
это укороченная форма команды
# echo "asd" 1 > /tmp/1.txt

и команда вида
# cat < 1.txt
это укороченный аналог
# cat 0 < 1.txt
(взял отсюда https://tldp.org/LDP/abs/html/io-redirection.html)

еще важная хуйня про io redirect
надо обязательно дескриптор файла ставить рядом без пробелов со знаками ">","<" итп.
тоесть

$ dfrtr 2>4.txt
$ cat 4.txt
dfrtr: command not found

тоесть видно что редирект сработал. мы ввели несуществующую команду.
при этом канал ошибок был заредиректен на файл 4.txt
видно что мы ввели "2>..." тоест между 2 и ">" нет пробела. 
такой редиректо сработает.

$ dfrtr 2 >4.txt
dfrtr: command not found

а этот редирект неработает. потому что у нас между 2 и ">" стоит пробел.

далее . разберем поподробнее пример
    $ dfrtr 2>4.txt

что в нем интересно это как оно выполняется.
у нас есть баш процесс и мы его просим запустить команду "dfrtr"
баш процесс выполняет сисколл и просит ядро создать новый процесс самого себя. когда клон исходного процесса
будет создан в форме нового процесса то баш в новом процессе ищет среди $PATH бинарник с именем "dfrtr"
ненаходит его и посылает на sterr ошибку. если бы бинарник был бы найден то баш склонированного процесса
выполнил бы еще один сисколл который просит ядро заменить в текущем процессе бинарник баша на бинарник dfrtr.
соотсвтвенно вопрос - кто кидает в stderr ошибку что файл ненайден - баш в склонированном процессе или ядро?
как я понимаю имеено баш запускает ряд сисколлов stat в разных папках которые у него прописаны в $PATH
и все сисколлы сообщают бинарнику баша что там такого файла нет. тогда бинарник баша пишет в sterr 
сообщение о том что файл ненайден. таким образом именно бинарник баша кидает на stderr сообщение об ошибке
я не ядро. потому что важно было понять кто занимается отправкой сообщений на stderr юзерская программа
или само ядро. 
вот доказательство

$ strace  bash -c "kuku"
...
stat(".", {st_mode=S_IFDIR|0775, st_size=1011712, ...}) = 0
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/sbin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/sbin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/bin/kuku", 0x7ffcfd0c62a0)   = -1 ENOENT (No such file or directory)
stat("/sbin/kuku", 0x7ffcfd0c62a0)      = -1 ENOENT (No such file or directory)
stat("/bin/kuku", 0x7ffcfd0c62a0)       = -1 ENOENT (No such file or directory)
stat("/usr/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/snap/bin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)

тоесть видно что бинарник баша ищет бинарник kuku во всех папках которые есть у него в $PATH
и ничего ненаходит.
...
write(2, "bash: kuku: command not found\n", 30bash: kuku: command not found
) = 30

и тогда бинарник баша сам лично через сисколл write пишет в дескриптор "2" об ошибке
я совершенно не утверждаю что в 2 неможет писать само ядро. но в данном случае ошибку генерирует
сам юзерский процесс.

так вот вовзращаемся к примеру
        $ dfrtr 2>4.txt
рассмотрим более простой пример для начала
        $ dfrtr
        dfrtr: command not found

кто гененриует ошибку? ответ склонированный бинарник баша генерирует.
у нас наш текущий процесс баша сам себя клонирует. дальше в дело вступает клонированный баш.
он начинает искать бинарник dfrtr по всем папкам прописанным в $PATH
ненаходит. и тогда он склонированный бинарник баша пишет в 2 о том что файл ненайден.
таким образом отвечаю на вопрос - если команда не найден то кто генерирует ошибку?
возвращаемся к примеру
         $ dfrtr 2>4.txt
наш текущий баш склонирует самого себя в новый процесс через сисколл к ядру.
плюс наш исходный баш попросит ядро чтобы при создании нового процесса его дескриптор 2 указывал 
не на pty файл ( не на терминал как это обычно бывает)  а на файл ./4.txt
таким образом привязку 2 к 4.txt для нового процесса делает ядро по просьбе родительского баша.
дочерний баш к этому не имеет никакого отношения. дочерний единственное что сделает это напишет в 2 
что файл не найден. гениально. мудота та еще...
важно еще то что такого рода редирект файловых дескрипторов происходит не для исходного процесса баша 
а исключительно для новых порождаемых процессов. это тоже важно отметить. 

теперь фундаментальный вопрос а как нам изменить привязку файловых дескрипторов не для новых 
порождаемых процессов а для текущего процесса в котором крутится bash
в этом нам поможет баш билитн exec


баш builtin exec
что он делает.
по дефолту если мы запускаем команду в баше то баш это процесс как любой другой.
когда мы запускаем команду то баш создает новый процесс и в нем уже запускает нашу команду.
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
тоесть видно что номер баш процесса 31410
когда мы в нем запустили команду pstree то баш создал новый процесс 31426
так вот exec заставляет бащ не создавать новый процесс а запустить эту команду в текущем процессе
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
$ exec sleep 120
$ pstree -Asp 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---sleep(31410)
видно что процесс 31410 остался но там уже не баш а наша команда. а нового процесса нет.

тут я добавлю полезняшку про pstree. 
если цепочка очень длинная то pstree порежет цепочку. поэтому нужно добавить флаг -l
чтобы цепочка былабы показана по всей длинне чтобы он не обрезад

обрезанный вид
$ pstree -Asp 9174
systemd(1)---lightdm(4560)---lightdm(4814)---lightdm(4930)---lightdm(4931)---lxsession(4932)---pcmanfm(5071)---lxterminal(6046)---b+

необрезанный вид
$ pstree -Aspl 9174
systemd(1)---lightdm(4560)---lightdm(4814)---lightdm(4930)---lightdm(4931)---lxsession(4932)---pcmanfm(5071)---lxterminal(6046)---
---bash(3676)---mc(3687)---bash(3689)---find(9174)---sleep(9176)


как видно не создавание нового процесса было выполненно через баш билтин exec . в виде

$ exec команда

итак "exec команда" не порождает новый процесс а в текущем процессе заменяет бинарник.
есть надежда что подключение io redirect вкупе с exec позволит нам изменить привязки файловых
дескрипторов для текущего процесса.

$ echo $$
32624
$ exec sleep 130 2>3-err.txt

итак у нас был баш процесс 32624 со стададартной привязкой его дескрипоров 1,2,3 к терминалу
далее мы говорим что в текущем процессе заменить баш на sleep и для этого процесса (для того же самого)
задать что файловый дескриптор 2 должен смотреть на файл 3-err.txt

проверяем
$ ls -1al /proc/32624/fd
total 0
dr-x------ 2 vasya vasya  0 окт  4 09:00 .
dr-xr-xr-x 9 vasya vasya  0 окт  4 09:00 ..
lrwx------ 1 vasya vasya 64 окт  4 09:00 0 -> /dev/pts/21
lrwx------ 1 vasya vasya 64 окт  4 09:00 1 -> /dev/pts/21
l-wx------ 1 vasya vasya 64 окт  4 09:00 2 -> /home/vasya/temp/3-err.txt

и это действительно сработало!
процесс по номеру не поменялся. зато его привязка для дескриптора 2 поменялась.

попробуем на этом фоне более интересный пример
запустить баш из баша при этом перенаправить его 2 в 5.txt
для начала я хотел показать одну важную вещь. вот  у нас есть баш процесс.
я думал что prompts приглашение этот процесс пишет в 1 тоесть в stdout
а оказалось что он его пишет на stderr! показываю

$ echo $$
31668
$ bash 1>7.txt
таким макаром я запустил новый процесс баша и его stdout я завернул на файл 7.txt
$ 
при этом как видно у меня на экране по прежнему присуствует prompt тоесть 
этот prompt он пишется процессом как я уже сказал не на stdout а на stderr

открываю другой терминал и проверяю что новый баш имеет то  редирект в файл который я сказал
(другой терминал)$ $ cat 7.txt 
2661
(другой терминал)$ pstree -Asp 2661
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31668)---bash(2661)
видно что новый баш это чайлд от головного баша
(другой терминал)$ ls -1al /proc/2661/fd
lrwx------ 1 vasya vasya 64 окт  4 10:27 0 -> /dev/pts/22
l-wx------ 1 vasya vasya 64 окт  4 10:27 1 -> /home/vasya/temp/7.txt
lrwx------ 1 vasya vasya 64 окт  4 10:27 2 -> /dev/pts/22
lrwx------ 1 vasya vasya 64 окт  4 10:27 255 -> /dev/pts/22
четко видно что наш дочерний баш имеет stdout завернутый в файл

так вот аналогично легко убедться что если мы запустим баш у которого stderr будет завернут
в файл то  у нас приглашение баша исчезнет с экрана потому что оно теперь будет писаться не в терминал а в файл
$ bash 2>8.txt

и все у нас на экране больше нет prompt

так вот до этого моменты мы создавали дочерний процесс баша у которого был настроен редирект одного из 
файл дескрипторов в файл. 
теперь сделаем тоже самое без создавания дочернего процесса.
в первом терминале запускаем
    $ echo $$
    2963
    $ exec bash 1>10.txt
    $ 

во втором терминале проверяем
$ pstree -Asp 2963
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(2963)
$ ls -1al  /proc/2963/fd 
lrwx------ 1 vasya vasya 64 окт  4 10:31 0 -> /dev/pts/23
l-wx------ 1 vasya vasya 64 окт  4 10:31 1 -> /home/vasya/10.txt
lrwx------ 1 vasya vasya 64 окт  4 10:31 2 -> /dev/pts/23
lrwx------ 1 vasya vasya 64 окт  4 10:32 255 -> /dev/pts/23

видно что исходный процесс 2963 не имеет чайлдов и что его 1 перенаправлен в 10.txt
таким макаром мы научились текущий баш процесс менять таким образом чтобы у него менялась 
привязка его файл дескрипторов. вот эта волшебная команда
        $ exec bash 1>10.txt
так вот в описании билитина exec написано что это можно сделать еще короче.
цитирую
$ exec --help
exec: exec ... [command] ... [redirection ...]
...
 If COMMAND is not specified,
    any redirections take effect in the current shell.

тоесть тут написано что если не указать никакой команды то получается что он автоматом меняет дескрипторы
указанные в [redirection] для данного процесса. 
проверяем
    $ echo $$
    3208
    $ exec 1>11.txt
    $ 

проверяем в другом терминале
$ pstree -Asp 3208
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(3208)
$ ls -1al  /proc/3208/fd
lrwx------ 1 vasya vasya 64 окт  4 10:39 0 -> /dev/pts/26
l-wx------ 1 vasya vasya 64 окт  4 10:39 1 -> /home/vasya/11.txt
lrwx------ 1 vasya vasya 64 окт  4 10:39 2 -> /dev/pts/26
lrwx------ 1 vasya vasya 64 окт  4 10:39 255 -> /dev/pts/26

и действительно да. процесс 3208 не имеет никаких чайлдов. и его 1 имеет редирект на файл!
гоча!

я бы еще как сказал хотя это не совсем верно. что если мы никакую команду не подставляем в exec
то баш сам автоматом как бы подставляем bash тоесть  как бы 
    exec 1>11.txt = exec bash 1>11.txt
хотя это не совсем так. потому что в первом случае он не меняет бинарник в памяти а во втором случае
он удаляет старый бинарник и сует в процесс новый бинарник. (ксатти сказать процесс получается это как бы коробка (типа фреймворк) плюс начинка в виде бинарника)


двигаем дальше. вот еще интересный пример который нам пригодится
$ echo $$
3554
$ exec bash 12<>12.txt
$ echo $$
3554
[vasya@lenovo ~]$ ls -1al /proc/$$/fd
lrwx------ 1 vasya vasya 64 окт  4 10:49 0 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 1 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 12 -> /home/vasya/12.txt
lrwx------ 1 vasya vasya 64 окт  4 10:49 2 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 255 -> /dev/pts/29

мы говорим чтобы в нашем текущем процессе был заменен бинарник на баш
и чтобы  в нашем процессе был открыт новый файловый дескриптор с номер 12 и чтобы этот файловый дескриптор
был связан с файлом 12.txt который будет открыт с флагами и на чтение и на запись.
что примечательно в этой команде. примечательно то что мы можем изменить для данного процесса
число его файловых дескрипторов. было 0,1,2,255 (правда какого хрена тут делает 255 непонятно. вернее понятно.
я же запускаю bash из некоего другого процесса скажем это gnome-terminal или xterm или из под граф оболочки 
и открытые файловые дескрипторы в родительском процессе автоматом наследуются и дочерним процессом вобщем щас нам этот 255 неважен) а стало 0,1,2,255,12.
таким макаром мы можем "прикрепить" к процессу дохрена файловых дескрипторов и дохрена открытых файлов.
при том что самому бинарнику процесса на этот абсолютно плевать. вот эти открытые файлы , прикрепленные файловые
дескрипторы они бинарник ни к чему не обязывают. это как в квартире понаделать больше окон. 
если процесс нехочет ни читать с данного файлового дескриптора ни писать в него то его никто к этому не обязывает. это как у машины добавить запасных колес. или в ящике понаделать новых дырок. тот кто сидит в яшике (бинарник)  может пользоваться этими дырками а может и нет. опять же что интересно у нас обычно один процесс родительский порождает некий дочерний процесс и родитель может заказать для дочернего процесса понаоткрывать 
для него кучу файлов. но дочернему процессу это может быть глубоко фиолетово. он может пользоваться открытыми 
для него файлами а может и нет. это никак не влияет на него. 
что еще важно это вот значок  "<>" он на самом деле никакого мистического значения не имеет. он на самом деле 
только значит то что в сисколле будет прописано что открываемый файл открывается с флагами "R+W" тоесть 
и на чтение и на запись. сразу в догонку скажу что значок ">" говорит через сисколл ядру что нужно открыть файл 
с флагом "W" а значок "<" говорит ядру что файл нужно открыть с флагом "R"
тоесть то что изначально называется редиректом. это корявое определение. это не редирект это команда ядру 
на то  с каким флагом нужно открыть файл. тоесть 
        $  echo 1 1>4.txt
комбинация "1>4.txt" говорит башу как ему выстроить сисколл который он будет пулять в ядро. 
сисколл должен быть такой что - надо открыть файл 4.txt причем с флагом "W" и привязать этот файл к дескриптору 1. ну да.. на последнем этапе можно скзаать что мы имеем дело с редиректом. но важно подчеркнуть что значки
"<" и ">" и "<>" их смысл не только редирект но и с каким флагом открыт файл на который они ведут. 
">" =  W
"<" =  R
"<>" = RW

еще пример 
        $ echo "abc" 12<>5.txt
здесь ксати тоже интересно. дело в том что echo это билтин баша. поэтому ему ненужно себя клонировать.
а он выполняет команду ровно в текущем процессе. так вот для текущего процесса будет открыть файл 5.txt
в режиме "RW" и будет создан файловый дескриптор 12 который будет прикреплен к текущему процессу 
сам же echo ясен банан выплюнет свой "abc"  в дескриптор 1. тоесть ему этот открытый дескриптор 12 
в целом нахрен не сдался. просто мы делая одно одновременно сделали и другое
причем насколько я понимаю баш он умный и он откроет этот файл и создаст дескриптор но как 
только билтин закончит работу то баш автоматом закроет файл и уничтожит дескриптор. вот 
доказательство
    $ echo "abc" 13<>13.txt
    abc
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:12 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 2 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:25 255 -> /dev/pts/31
тоесть еще раз так как echo это билтин то никого нового процесса создано не будет. все
будет делать в рамках текущего баша. поэтому я и смотрю список открытых файлов для текущего процесса.
и видно что никакого дескриптора 13 нет и в помине. он был создан и тут же обратно удален.
я так это понимаю.

совершенно другой коленкор когда мы через баш запускаем некую внешнюю программу и просим баш прилепить к ней
открытый файл. баш составит нужный сисколл для ядра. и мы все будем иметь.
    $ sleep 130 14<>14.txt

с другого терминала смотрим
    $ ps aux | grep sleep
    vasya     4806  0.0  0.0  14580   892 pts/31   S+   11:28   0:00 sleep 130
    $ ls -1al /proc/4806/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:29 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 14 -> /home/vasya/14.txt
    lrwx------ 1 vasya vasya 64 окт  4 11:29 2 -> /dev/pts/31

тоесть у нас баш себя клонировал тоесть попросил ядро создать новый процесс. причем при клонировании попросил 
ядро чтобы дочерний процесс имел открый файл 14.txt через дескриптор 14.
далее баш в дочернем процессе попросил ядро через  сисколл заменить свой
бинарник на sleep.
поэтому все так выглядит
еще раз подчеркну что значок "<>" в конечном итоге означае то что файл 14.txt открывается с флагами и на чтение
и на запись. флаг "<" открывает файл на чтение только, флаг ">" открывает файл на запись только
причем имеется ввиду для данного процесса. ничто мне не мешает из другого процесса попросить ядро открыть этот файл с другими флагами. тоесть скажем наш процесс открывает файл только на запись. а с другого процесса я прошу
ядро открыть файл на чтение. и таким макаром я спокойно читаю то что пишет туда первый процесс.

также попутно я покажу докажу что когда баш запускаем внешний бинарник то он создает новый процесс 
клонирует себя а если мы запускаем баш билтин то новый процесс не создается.
я запутил баш с номером процесса 4309
в соседнем окне я запустил strace
$ sudo strace -p 4309 -e clone,fork,execve
strace: Process 4309 attached

и в первом окне я запустил ls -1
и мне strace нарисовал
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fe0cc338a10) = 4589

а потом я в первом окне запустил echo 1
и мне strace ничего не нарисовал
это все доказывает

теперь переходим к интересному.
зная все что мы узнали выше я открою файл /dev/cpu_dma_latency
в текущем баше так чтобы он оставался открытым
    # exec bash 16> /dev/cpu_dma_latency;
    # ls -1al /proc/$$/fd
    lrwx------ 1 root root 64 окт  4 11:37 0 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:37 1 -> /dev/pts/32
    l-wx------ 1 root root 64 окт  4 11:38 16 -> /dev/cpu_dma_latency
    lrwx------ 1 root root 64 окт  4 11:37 2 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:38 255 -> /dev/pts/32

ну или можно было короче написать
    # exec 16> /dev/cpu_dma_latency;
мы открыли /dev/cpu_dma_latency на запись и прикрепили его к процессу через дескриптор 16
показываю чему он равен прям щас 
    # cat /dev/cpu_dma_latency  | od -t x1
    0000000 00 94 35 77
    0000004

теперь можно его изменить вот так
    # echo -en "0x00000258" 1>&16
здесь так как echo у нас шлет свои данные на stdout тоесть в 1 то я перенаправил в 16.
на low level уровне это работает так что по дефолту баш юзает сискол
write (1,"текст")
а когда мы ему дали подсказку то он делает
write(16,текст)

проверяем что сработало
# cat /dev/cpu_dma_latency  | od -t x1
0000000 58 02 00 00
0000004
да сработало получается.
такой вывод наоборотный потому что в оперативку много байтовой число пишется в little endian формате.
об little endian  читай в ext4.txt

также отмечу вот это "1>&16" знак амперсанда говорит бащу что мы делает перенаправление не в файл  с именем 16 на файловой системе а в файловый дескриптор 16. это две большие разницы.
ксати я щас попробую сделать запись в несуществующий дескриптор
    # echo -en "0x00000258" 1>&28
    bash: 28: Bad file descriptor
все верно. пошел нахер


итак еще раз
что было сделано
     # exec 16> /dev/cpu_dma_latency;
     # echo -en "0x00000258" 1>&16
для текущего процесса баща был открыт файл /dev/cpu_dma_latency на запись. и прикреплен к процессу через
дескриптор 16. фишка в том что он будет висеть открытым пока я его сам руками не закрою.
далее я делаю запись в этот файл через подскажу башу что писать надо не в дескриптор 1 как он это обычно
делает по дефолту а в дескриптор 16. после записи файл который скрывается за дескриптором 16 продолжает висеть открытым.
тут еще раз также подчеркну что когда мы работаем с io redirect то между номером дескриптора и значком
редиректа категорически нельзя чтобы были пробелы. тоесть 
         # exec 16> /dev/cpu_dma_latency;   # правильная команда

         # exec 16 > /dev/cpu_dma_latency;  # НЕправильная команда
         сразу вылезет ошибка. потому что баш будет интепретировать эту команду вот так
         # exec 16 1> /dev/cpu_dma_latency;
тоесть он будет пытаться найти бинарник с именем "16", заменить в текущем процессе баш этим бинарником
и заменит файловый дескриптор 1 чтобы он вел не на терминал а на файл /dev/cpu_dma_latency
тоесть это совершенно не то что нам надо. поэтому 
        "16> /dev/cpu_dma_latency" = правильная хрень. обозначает что мы открываем файл /dev/cpu_dma_latency
        на запись и в для процесса прокидываем этот файл как дескриптор номер 16

        "16   > /dev/cpu_dma_latency" = неправильная хрень, если быть более точным она тоже правильная но она делает совершенно другое. она обозначает вот это 
        "16   1> /dev/cpu_dma_latency" 
то есть мы открываем файл /dev/cpu_dma_latency на запись и привязываем его к процессу через дескриптор 1.
и плюс к этому у нас бинарник имеет имя 16. 
поэтому смысл этих двух команд совершенно разный

а вот после значка ">" уже неважно есть пробелы или нет. оно все будет трактоваться одинаково тоесть
    "16> /dev/cpu_dma_latency"
    "16>/dev/cpu_dma_latency"
    "16>        /dev/cpu_dma_latency"
это все одно и тоже.
в целом конечно это дебилизм потому что сегодня я это помню. а завтра уже совершенно нет.


возвращаемся НАКОНЕЦ к нашей исходной задаче
нужно понять как это работает
        # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
кстати сразу замечу что 3 это не stderr (как я иногда глючу так думая), stderr это 2
а 3 это вобще ничего. потому что stdin это 0. stdout это 1 и stderr это 2
немного преобразуем это выражение
        # exec bash 3<> /dev/cpu_dma_latency; echo -en "0x00000258" 1>&3
строго говоря оно немного отличается от оригинала но по конечному результату это одно и тоже
зато все указано в явном виде и поэтому более понятно 
далее эту команду можно эквивалентно переписать как 
        # exec bash 3<> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
во первых я считаю что символ "<>" он излишен потому что мы собираемся писать туда а читать нет.
но в целом не особо важно конечно. но я считаю что вот это более грамотно.
поэтому преобразуем 
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
теперь все понятно. разберем его.
мы открываем файл на чтение /dev/cpu_dma_latency и прикрепляем этот  файл через дескриптор номер 3 у текущего баша. фишка в том что  файл будет висеть постоянно открытым все время. пока мы не закроем его 
специально сами руками. теперь если мы из баща будем писать в дескриптор 3 то оно будет лететь в файл
далее мы через echo посылаем число но не в канал 1 как это баш делает по дефолту а в канал 3.
таким макаром мы записали  число в /dev/cpu_dma_latency
казалось бы мы могли бы сделать проще вот так 
        # echo -en "0x00000258"  /dev/cpu_dma_latency
но это не привело бы нас к тому что нам надо потому что 
этот файл /dev/cpu_dma_latency он хитрый.нам надо чтобы файл оставался все время открытым после 
записи. если мы это делаем сразу через эхо. то как только эхо закончит то файл закроется и ОС перезапишет
значение на дефолтовое. так устроен этот файл. а вот верхний мудежный способ как раз дает то что после записи в эхо файл будет продолжать оставаться открытым и наше новое значение будет сохраняться. 
получается одна маленькая строчка из интернета но чтобы ее понять нужно диссертацию написать.
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
при этом получается пока наш процесс баша будет на компе сущестовать файл будет открыт
и наше записанное значение будет жить.
как только мы текущий баш процесс закроем. файл тоже закроется и значние будет со стороны ос перезаписано
на дефолтовое.
в принципе можно было сделать и вот так
        # bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
без выебонов с exec
у нас просто напросто создасться в системе +1 процесс с баш и только и всего. 
так что если расхлобучить все эти выебоны которые накручены в исходном выражении то вся фишка лишь в том
что для того чтобы открыть файл на постоянной основе надо заюзать вот это выражение
            # bash N> file
и только и всего.
тогда у нас  в системе будет баш процесс  у которого будет постоянно открытый файл "file" на запись
через дескриптор N. вот и все.

далее
теперь моя задача в том чтобы найти все процессы в которых открыты файл дескрипторы
ведущие на файл /dev/cpu_dma_latency
и закрыть все эти файл дескрипторы

# lsof -u root | grep cpu_dma_latency
bash       5106 root   16w      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6454 root    3u      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6828 root    3w      CHR              10,59      0t0        162 /dev/cpu_dma_latency

здесь видно какой процесс имеет этот файл открытым, через какой дескриптор, и  в каком режиме
открыт файл (r,w,rw)

и тут выясняется прикол (из того что я вижу навскидку из интернета) что нет такого красивого 
способа чтобы под рутом запустить команду и заставить позакрываться эти файловые дескрипторы. 
хаха.
тоесть вижу что есть только три неудобных способа
один это подключаемся к процессу через gdb и там запускаем команду на закрытие файла.
второй способ разыскать в граф оболочке наши конкретные терминалы с этими прям башами 
и уже из под них запускать команды на закрытие файлов
а ну и третий самый лоховской способ это поубивать эти процессы и автоматом и файлы закроются

я пойду вторым способом.
он состоит вот в чем.
причем в методичке там запаривают мозг что в завимости в каком режиме был открыть файл 
чтени, запись его нужно гасить по разному на самом деле нихрена. нам совершенно неважно как был открыт файл
    # exec 3> file
    # exec 3< file
    # exec 3<> file
нам на это наплевать 
во всех случаях гасим дескриптор совершенно одинаково
    # exec 3>&-
либо
    # exec 3<&-
а вот вариант 
    # exec 3<>&-
абсолютно нерабочий.
ПРИЧЕМ в данном случае абсолютно нельзя чтобы был пробел между ">" и "&-"
либо между "<" и "&-"
тоесть пробел запрещен не толко слева от знака редиректа но и справа
сразу выдаст ошибку!

поэтому в случае редиректов я бы советовал ни слева от знака редиректа ни справа не оставлять пробелов
чтобы не получать проблем на ровном месте


я в итоге предпочитаю гасить через 
    # exec 3> &-


метод закрытия файла через gdb
# gdb -p $PID
# p close($FD)

далее
интересный пример
    # $ cat /etc/passwd >&-
эквивалент этой команды
    # $ cat /etc/passwd 1>&-
так вот эта команда как работает,
баш создаст новый процесс , со своим бинарником,
и также мы ему указали что в новом процессе нужно уничтожить файл дескриптор 1
далее запустится бинарник cat  а далее прикол в том что по дефолту он пишет в 1  через
write (1, ...)
а 1  у нас нету поэтому на экране вылезет ошибка
    # $ cat /etc/passwd 1>&-
      cat: standard output: Bad file descriptor

можно сделать по другому
    #  tty
     /dev/pts/12
    # cat /etc/passwd 1>&- 1>/dev/pts/12
как ни странно это сработает. 
с новым процессом будет проделано все то что я описал в предыдушем примере
тоесть будет удален дефолтовый дексриптор 1 и будет создан новый который ведет в /dev/pts/12
и все окей. тоесть если указано несколько редиректов в строке то баш и выполняет последовательно 
слева направо хоть миллион таких редиректов 


далее
    $ exec 2>&1
это понятно дескриптор 2 будет иметь тот же бекенд что и дескриптор 1
амперсанд обязателен иначе 2 будет перенаправлен не в дескриптор а обычный файл с именем 1

далее
    $ exec  &>kuku.txt
это перенаправляет 1 и 2  в файл. причем только файл на диске.
перенаправление в файл дескриптор не работает
аналогичная команда
    $ exec 1>kuku.txt 2>kuku.txt
при этом вот это неработает
    $ exec 4<>kuku.txt
    $ exec &>&4
тоесть &> можно перенаправлять только на файлы на диске а не на дескрипторы. тоесть 
вот так только работает
    $ exec &>12.txt

далее. все это время я рассматривал только ">" "<" "<>"
что означало
    > = открыть файл на запист
    < = открыть файл на чтение
    <> = открыть файл на чтение и запись
и  я совсем забыл про ">>" и "<<"
что означает
    >> = открыть файл на запись и плюс флаг APPEND
    << = это совершенно отдельный флаг. я только знаю его вот такое применение
    $ cat <<EOF >1.txt
    12
    12
    EOF
кстати я точно проверил вот так уже неработает
    $ cat <EOF >1.txt
     bash: EOF: No such file or directory

далее
    $ <<vasya
> eee
> bbb
> vasya

тоесть команда просит нас ввести текс. как только мы заканчиваем на контрольном слове vasya
то ввод заканчивается. и никакой файл не создается.
как я понимаю что это аналог команды
    $ :<<vasya
    > eee
    > bbb
    > vasya

тоесть наш текст идет на stdin команды true и в итоге все это просто команды пустышка

далее
    $ >>kuku
эта команда просто напросто создат пустой файл kuku на диске
тоесть аналог этой команды вот такой
    $:>>kuku
или аналог
    $: 1>>kuku

далее
    $ ls >>filename 2>&1
аналог
    $ ls 1>>filename 2>&1
тоесть эта команда она создает процесс с бинарником ls
уничтожает стандартный 1 и создает новый 1 который ведет в файл с именем "filename"
уничтожает стандартный 2 и создает новый который смотрит туда же куда и 1 тоесть в файл "filename"


далее
    $ 2>&1
аналог
    $ :2>&1
все понятно


далее. 
в bash 4 добавили вот такую хрень
|& was added to Bash 4 as an abbreviation for 2>&1
тоесть
    $ vasya |& cat
это аналог
    $ vasya 2>&1 | cat
пример
    $ vasya 2>&1 | xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
    $ vasya  |& xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
 
тоесть хрень рабтает как. баш создает свой клон в новом процессе.
далее этот чайлд баш ищет бинарник вася, ненаходит его, выводит в 2 сообщение об 
ошибке. а у нас при этом когда процесс создавался то 1 была перенаправлена на 0 процесса xargs
и 2 была направлена тудаже куда 1. получается чайлд баш срет в 2 сообщение об ошибке
и оно автоматом прилетает на 0 xargs. и он то что получил высирает

далее выяснился конкретный пиздец с башем.
мы привыкли что в самоей левой позиции в строке обязательно идет команда 
а все аргументы пайпы итд обязательно идут справа. 
это настолько фундаментальная хрень что о том что это не так даже в голову не приходит
однако это не так. оказывается что можно вот так
    $ cat filename 
    filename
    kuku
    vasya
    $ 2>file2 0<filename cat | xargs echo   
    filename kuku vasya

тоесть левее команды можно абсолютно спокойно насовать редиректы! это пиздец
об этом я нашел случайно в сноске в bash advanced guide
то есть аналогичная в более привычном виде команда выглядит так
    $ cat 0<filename 2>file2 | xargs echo 

можно конечно еще более загадочно и с выебоном написать
    $ < filename cat > out
аналог тоесть более привычный вид
    $ cat 0<filename 1>out

вот еще пример с выебоном
    $ rpm2cpio < filename > $TEMPFILE
аналог
    $ rpm2cpio 0<filename 1>$TEMPFILE

а вот еще приме с приколом
как создать новый дескриптор который ссылается на уже существующий дескриптор
    $ exec 4>&1
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 02:44 0 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 1 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 2 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 4 -> /dev/pts/15

переводится команда так. в существующем процессе баш нужно открыть создать файловый дескриптор 4
и направить его на файл на который ссылается дескриптор 1. причем этот файл нужно открыть на чтение

еще один пиздец
    $ ls -l  1>/dev/null  16>&-
здесь я вывод от ls просто заткнул тем что перевел в null
и это не главное. главное это "16>&-" 
тоесть оказывается что можно давать команду уничтожить файловый дескриптор который 
и в помине у процесса нихуя нет. и ошибки при этом никакой не выдает. 

вот еще ебанутый пример
    $  <&2  ls  >/dev/null
его аналог
    $ ls  1>/dev/null   0<&2


вот еще ебанутый пример
    $ exec 3<&2
    $ exec 2>&1 >&3 3>&-
первая строка она в текущем процессе баша создает дескриптор 3 который ведет на тот же файл на который
указвыает дескриптор 2. причем этот файл для через дескриптор 3 будет открыт на чтение
тоесть в итоге 3 будет указывать на /dev/pts/19
вторая строка работает так. для текущего процесса баша дескриптор 2 будет уничтожен и создана заново
при этом он будет указыват на тот же файл на который указывает дескриптор 1. так как  1 указывает на /dev/pts/19
то и 2 будет на него указывать. причем в режиме на запись. 
следущим шагом будет уничтожен дескриптор 1 и создан заново при этом он будет указывать на файл на который
указывает дескриптор 3. а 3 указывает на /dev/pts/19 ( на основе информации из команды из первой строки)
поэтому 1 будет указывать на /dev/pts/19 причем в режиме на запись он откроет этот файл
на последнем шаге будет уничтожен дескриптор 3
здесь важно понять что работа с дескрипторами их создание и уничтожение идет слева направо. последовательно 
по шагам. также важно понять что если у нас написано что дескриптор 2 указывает на дескриптор 1 
как вот здесь "2>&1" то это нетак. не дескриптор ссылается на дескриптор а дескриптор ссылает на файл 
на который ссылает другой дескриптор. тоесть как только мы выяснили на какой файл ссылается дескриптор 1
то нам на него насрать. дескриптор 2 будет ссылаться не на дескриптор а на файл который является бекендом 
для дескритора 1. поэтому если потом позже мы удалим дескриптор 1 то проблемы у дескриптора 2 не будет 
никакой так как оне никогда не ссылался на дескритор 1. это тоже важно понять.
а вот на эту тему пример
        $ exec 4<filename 0<&4 1>&0 4>&-
        
        $ ls -1al /proc/16039/fd
        lr-x------ 1 vasya vasya 64 окт  5 03:08 0 -> /home/vasya/filename
        lr-x------ 1 vasya vasya 64 окт  5 03:08 1 -> /home/vasya/filename
        lrwx------ 1 vasya vasya 64 окт  5 03:08 2 -> /dev/pts/20


тоесть как это работает. для текущего процесса у нас открывается файл "filename" на чтение 
и привыязывается к процессу через дескриптор 4
на втором шаге у нас уничтожается прежний 0 и создается новый и он открывает на чтение тот файл на который ссы
лается 4 тоесть filename
на третьем шаге у нас уничожается 1  и создается заново и он открывает на запись файл на который ссылается 0
тоесть filename 
на последнем этапе у нас уничтожается дескриптор 4
от того что мы уничтожили дескриптор 4 это не означает что это как то повлияет на 0. потому что 0 указывает
не на 4 а на файл на который указывал 4 тоесть на filename
пиздец

далее. шок
внещняя по отношению к башу команда cat
она почемуто читает данные не из 0 а из 3 !!!
показываю:
    $ cat /dev/urandom > /dev/null

    $ ls -1al /proc/21031/fd
    lrwx------ 1 vasya vasya 64 окт  5 10:15 0 -> /dev/pts/16
    l-wx------ 1 vasya vasya 64 окт  5 10:15 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 10:15 2 -> /dev/pts/16
    lr-x------ 1 vasya vasya 64 окт  5 10:15 3 -> /dev/urandom

хотя в приниципе нормально. для cat штука "/dev/urandom" является параметром и бинарник cat когда он запустился
анализирует с каким параметрами командной строки он был запущен и волен открывать файл под любым дескриптором.
в том числе и под дескриптором 3.
скорее я капитально ошибся думая что параметр командной строки почемуто должен быть открыть катом через 
дескриптор 0. это же чушь. через 0 cat принимает данные из терминала. а через 3 он принимает данные из файла.
все конечно же должно быть так.

далее еще прикол про cat
    $ cat 1.txt 2.txt
если так запустить то cat вначале откроет 1.txt полностью его прочитает и выдаст в 1, закроет его,
потом только откроет 2.txt 
а не так как я думал что он одноврменно откроет два файла. нет так он не делает.

далее еще прикол
    $ <<EOF
    > aa
    > bb
    > EOF
насколько я понимаю эквивалент команды это 
    $ :<<EOF
либо
    $ true<<EOF
тоесть невидимая команда это ":" или "true" что одно и тоже.
и  в нее скармливается текст из терминала
как работает "<<EOF" насколько я понимаю когда мы тыкаем enter то текущий баш он видит эту хрень 
и делает вывод что мы хотим написать в терминале какойто текст, он дает нам написать в терминале наш текст,
засасывает внутрь себя И ТОЛЬКО ПОТОМ он клонирует себя в новый процесс и как я понимаю он где то сохраняет
засосанный текст из терминала и после того как склонировал себя то он наверное из родительского процесса
видимо через пайп скармливает засосанный текст в stdin чайлд процесса.
тоесть если у нас есть вот такая команда
    $ команда <<EOF 
то ее эквивалент
    $ echo -en "aaasdas\n asdasdsdasd\n" | команда 
или еше пример
    $ cat<<EOF > 1.txt
ее аналог в более понятной форме
    $ echo -en "aaaa\n bbb\n" | cat > 1.txt 
этим описанием я хочу подчеркнуть что "<<" не имеет никакого отношения к cat! это фича либо самого терминала
либо баша скорей всего баша. поэтому "<<" можно прихуяривать с любой программой. самое главное что программа должна ожидать получить какието данные из stdin. пример
    $ xargs echo <<EOF
    > "aaa"
    > "bbb"
    > EOF
    aaa bbb
тоесть эта команда эквивалентна
    $ echo "aaa bbb" | xargs echo
    aaa bbb

работает это так. мы тыкаем Enter. баш начинает анализировать строку  "xargs echo <<EOF"
видит конструкцию "<<EOF" и понимает что пока что делать ничего нельзя. прежде всего нужно считать 
некий текст из терминала. поэтому баш останавливается и ждет чтобы мы набили в терминале текст.
мы его набивает. баш его где то запомиает в своих кишках. потом он клонирует себя. запускает в чайлде
xargs и видимо через пайп передает из родительского процесса из своих кишок запомненный текст 
на stdin дочернего процесса.

далее я возвращаюсь к cat
у него есть такой прикол
    $ cat 1.txt - 2.txt
эта хуйня должна работать так вначале кат открывает файл 1.txt полностью его читает и выводит  на терминал.
потом кат ждет наших данных прям с терминала. он их считывает и выводит на экран. потом мы както должны обьяснить кату что мы больше не хотим вводит из терминала. и он тогда должен открыть 2.txt и его прочитать
и вывести на экран. на данный момент прблема в том что я не понимаю как этому кату обьяснить тот момент
когда я хочу закончить ввод из терминала
значит я не знаю как из терминала обьяснить кату что мы закончили ввод тоесть
    $ cat -
я не понимаю как закончить ввод с терминала
зато вот можно сделать такой прикол
вот есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777

тогда можно сделать вот такой фокус
   $ echo "111" | cat 6.txt - 7.txt
    666
    111
    777
круто??!?!?!?!?

во! я узнал как в терминале что надо нажать чтобы обьяснит терминалу и cat что я закончил
вводить текст и мы достигли "конец файла EOF" . оказывается это комбинация Ctrl+D
показываю имеем два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
тогда пуляем такую команду
    $ cat 6.txt - 7.txt 
    666  <=== это кат вывел содержимое 6.txt
    aa   <=== это мы ввели руками в терминале
    aa   <=== это кат вывел то что мы ввели
    bb   <=== это мы ввели руками в терминале 
    bb   <=== это кат вывел то что мы ввели руками, и тут я нажал Ctrl+D
    777  <=== это кат вывел содержимое файла 7.txt
круто!!!!!

далее. итак я выяснил что 
    $ cat 1.txt
приводит  к тому что кат откроет файл 1.txt через файловый дескриптор номер 3 
еще раз показываю на примере
    $ cat /dev/urandom 1>/dev/null
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
четко видно что файл открыт через дескриптор номер 3
а если мы хотим чтобы cat начал читать файл через дескриптор 0 то это запускается
совсем по другому
    $ cat /dev/urandom | cat 1>/dev/null
вот как выглядит открытые файлы у второго кат
    $ ls -1al /proc/22921/fd
    lr-x------ 1 vasya vasya 64 окт  5 11:18 0 -> 'pipe:[2312995]'
    l-wx------ 1 vasya vasya 64 окт  5 11:18 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:18 2 -> /dev/pts/18
в этом случае поток засасывается из 0 который ведет в пайп. но дело не в пайпе. а то что
в таком случае поток забирается из 0
возвращаюсь к случаю когда кат читает из файла который мы указали в командной строке
    $ cat /dev/urandom
мы имеем вот такой список открытых дескрипторов
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
так вот понятно что у нас на экране будут лететь символы
можно даже вот такой пример сделать чтобы на экране были только буквы 
    $  cat /dev/urandom | od -t x1
так вот возникает вопрос а что если мы вэто время будем конпки на терминале тыкать будет ли
их параллельно пихать на экран cat или нет. отвечаю конечно нет! 
как я уже сказал раз мы указали cat файл в командной строке как аргумент то он читает данные
только из дескриптора 3. а планов читать в это время  у него из stdin из 0  у него нет! поэтому
тыкать в терминале кнопки в это время нет никакого эффекта!

далее еще полезный момент
    $ echo 113 | cat
    113
    $ echo 113 | cat -
    113
результат один и тот же. однако во втором случае мы в более явной 
форме обьясняем кату что мы хотим чтобы он данные принимал из 0






далее я перехожу к мудежной но знаковой важной теме 
называется она 
>>> bash process substitution <<<
выглядит это так
    $ команда1 >(команда2)
например 
    $  cat - >(sleep  160)
и работает это так
создается  pipe.
и тут важно скзаать что книжка "bash advanced scripting" на которую я опираюсь нередко пишет 
полную хуйню. так и в этот раз. книжка пишет что создается named pipe. на самом деле нихуя. 
создается anonymous pipe. тут я делаю отсылку на pipe.txt чтобы прочитать про то что такое пайпы.
итак создается неименованный пайп а именно анонимный! выглядит он так
        'pipe:[2498298]'
где что и как щас станет понятно
    $ ls -1al /proc/5013/fd
        lrwx------ 1 vasya vasya 64 окт  6 10:41 0 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22
        l-wx------ 1 vasya vasya 64 окт  6 10:41 63 -> 'pipe:[2498298]'  <====
    $ ls -1al /proc/5014/fd
        lr-x------ 1 vasya vasya 64 окт  6 10:41 0 -> 'pipe:[2498298]'   <====
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22

так вот ядро создало анонимный пайп где то там в своих кишках памяти 'pipe:[2498298]'
далее запускается команда2 и ее stdin конец присоединяется к анонимному пайпу 'pipe:[2498298]'

далее запускается команда1 и ей в качестве аргумента командной строки передается адрес файла /dev/fd/63
то бишь /proc/pid1/fd/63
показываю:
    $ ps aux | grep cat
     vasya     5013  0.0  0.0  14720   744 pts/22   S+   10:40   0:00 cat - /dev/fd/63

где /dev/fd/63 это симлинк на /proc/self/fd/63 тоесть то бишь /proc/pid1/fd/63
нихуя себе! да?
тоесть команда 1 была по факту запущена в виде
    $ cat - /dev/fd/63
и соотвественно программа cat обрабатвыает этот аргумент строки 
и открывает этот файл под каким то дескриптором ну точнее как видно из практики под дескриптором 63
и таким макаром у первой программы мы имеем
        63 -> 'pipe:[2498298]'
у второй программы мы имеем
        0 -> 'pipe:[2498298]'
если первая программа захочет и будет писать в дескриптор 63 то это летит в пайп 
и если вторая программа будет читать если захочет из дескриптора 0 то она будет читать из пайпа.
таким макаром пайп обеспечивает связь между двумя процессами.
во втором процессе пайп присоединяется к 0
а в первом процессе имя файла пайпа (/proc/pid1/fd/63) передается программе как аргумент в строке.
соотвесвтенно если первая программа такова что она не собирается писать данные в файл который указан  в ее 
строке то второй програме нихрена и не прилетит.  тоесть bash process substituition это более специфический
процесс связи между программами.  классический анонимный пайп вида $ echo | cat более бронебойный способ 
потому что он вставляет пайп на stdout первого процесса и сует на stdin второго процесса.
если первый процесс чтото высирает на stdout а второй процесс чтото желает читать из своего stdin (что вобще то говоря не факт) то связь между процессами обеспечена.
в случае же bash process subsitution связь заработает только если первый процесс умеет писать в файл имя которого ему передали как аргумент в строке. вот что надо подметить.! но еще раз подчеркну что в bash process
substition используется анонимный пайп. а не именнованный как это суки эти пищут в bash advanced guide книжке


еще пример
    $ echo >(true)
    /dev/fd/63
почему так. потому что в конечно итоге будет запущена команда
    $ echo /dev/fd/63
обьясню почему. мы вбили команду в баш. баш анализирует строку и видит в ней кусок ">(true)"
для баша это означает что нужно этот кусок заменить на имя файла. что за файл?  файл в папке 
/dev/fd/63. по факту это симлинк на файл /proc/self/fd/63 то бищь /proc/pid1/fd/63
почему именно 63? я так думаю это какойто хардкод число в ядре с которого он создает эту хрень.
и между прочим это тоже симлинк и ведет он на анонимный пайп 
        /proc/pid1/fd/63 --> 'pipe:[2498298]'
когда пайп создан и когда ссылка на него создана то баш подставляет в оригинальную команду и запускает 
ее 
     $ echo /dev/fd/63
поэтму мы на экране видим 
    /dev/fd/63
помимо этого баш создает новый процесс и запукает там вторую команду "true"
и к ее stdin присоединяет этот же анонимный пайп тоесть
          /proc/pid2/fd/0 --> 'pipe:[2498298]'
конкретно в даннном случае вся команда целиком неимеет никакого практического смысла
потому что echo абсолютно не собирается писать в файл /dev/fd/63 по своей природе
а команда true не собирается ничего читать со своего stdin 
поэтому это пример чисто работающий но бесполезный     потому что данные через пайп
от первой команды ко второй не передаются


а вот пример где данные уже передаются
    $ cp /dev/urandom >(pv 1>/dev/null)
     147MiB 0:00:06 [21,0MiB/s] [                   <=>                           <=>    

работает это так что данные из /dev/urandom пихаются в пайп
а из него их читает pv и рисует картинку

более подробно  как это работает 
работает также как в прошлом примере
вот мы вбили команду
    $ cp /dev/urandom >(pv 1>/dev/null)
нажали Enter
бащ анализирует эту строку.  и видит комбинацию ">(pv 1>/dev/null)"
тогда баш понимает что все не так просто и создает аононимный  пайп где то там  в памяти вот 
такую хрень 'pipe:[2498298]'
далее бащ создает новый процесс и в нем запускает "pv". когда  баш создает этот процесс через сисколл
то просит у ядра чтобы оно присоединило к stdin дочернего процесса наш пайп
и выглядит это так
        /proc/pid2/fd/0 --->  'pipe:[2498298]'
далее баш берет оригинальную команду и меняет ее из вот такой
        $ cp /dev/urandom >(pv 1>/dev/null)
в такую
        $ cp /dev/urandom /dev/fd/63
где /dev/fd/63 в конечном итоге ведет в тот же самый пайп 'pipe:[2498298]' тоесть
        /dev/fd/63 --> /proc/self/fd/63 ---> 'pipe:[2498298]'

соотвевственно команде cp похеру что там на том конце у /dev/fd/63
она просто копирует данные из /dev/urandom в /dev/fd/63
таким макаром данные улетают в пайп.
и таким же макаром вторая команда читает свой stdin и получает данные из пайпа.

можно привести пример когда работает наоборот
    $ cp <(cat /dev/urandom) /dev/null
работает это так что () кидает их в свой stdout который направлен в пайп
а команда cp будет запущена в виде
    $ cp /dev/fd/62 /dev/null
где /dev/fd/63 тоже смотрит в пайп
таким макаром данные из stdout () поступают в пайп оттуда в /dev/fd/62 а оттуда в cp 

да уж..


а вот еще пример
    $  cp /dev/urandom >(echo "печать из субшелла"; pv 1>/dev/null)
    печать из субшелла
    66,2MiB 0:00:01 [37,1MiB/s] [     <=>           ]
получается вот что. вначале то что вылетает из cp пристыковывается через пайп к stdin команды echo.
но ей посрать на то что поступает к ней из stdin поэтому она просто печатает текст на экране и заканчивает
свою работу. данные при этом в пайпе как лежали так и лежат ( деньги в копилке так и лежат)
тогда далее запускается pv и уже к ней пристыковывается  пайп на ее stdin 
и так как pv как раз таки и и ждет поступления данных из stdin то pv начинает выкачивать данные из пайпа

тоесть фишка в том что у нас наш пайп был подключен и к одной команде и другой. а с классическим анонимным пайпом так хрен сделаешь наверно...


а вот еще очень важный пример
    $ echo "11" 1>(echo "первый привет из субшелл"; cat)
    11 1/dev/fd/63

что я хотел в этом примере добиться. я хотел чтобы вывод эха был перенаправлен в ()
но это не получилось хотя я якобы настроил редирект для 1. ошибка в том что баш заменил
конструкцию ">(echo "первый привет из субшелл"; cat)" на "/dev/fd/63" в итоге echo был запущен
буквально вот так
    $ echo "11" 1/dev/fd/63
поэтому то мы на экране и увидели вот эту хрен незапланированную 
    11 1/dev/fd/63
а чтобы все заработало как надо - надо вот так
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat)
    первый привет из субшелл
    11

значит в нем редирект настроен как "1>" а файл в который мы редиректим указан как ">(echo "первый привет из субшелл"; cat)"
в итоге и получается вот такая удивительная конструкция! c двумя галками через пробел "> >"
тоесть пример у нас расшифрорвывается так:
напечатай 11 но при этом stdout мы перенаправляем в именованный пайп который ведет в субшелл
далее. вначале именнованный пайп с 11 внутри прилепляется к stdin команды 
    echo "первый привет из субшелл";
но ей похеру то что у нее сидит на ее stdin
поэтому она просто на экране печатает приветствие и заканчиывает работу
тогда запускается команда cat у которой именованный пайп подключен к ее stdin
и вот тут наконец 11 из верхней эхо поступает на stdin команды кат. и она его печатает. 
в итоге мы получаем на экране
    первый привет из субшелл
    11


возникает вопрос а что будет у такой команды?
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
возникает вопрос чтото из верхнего эхо доберется до второго cat?
ответ конечно нет. потому что пайп уже весь опустошен на первом cat
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    11
    второй  привет из субшелл



а вот еще очень интересный пример
вот у нас есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
запускаем такую команду 
    $ cat 6.txt 7.txt  1> >(echo "первый привет из субшелл"; cat -; echo "второй  привет из субшелл"; cat -;)
    первый привет из субшелл
    666
    777
    второй  привет из субшелл


вопрос был вот в чем. когда у нас верхний cat закончит передавать первый файл и первый cat в субщелле закончит 
его печать то закончит ли cat в субшелле свою работу и передаст ли второй echo в субщелле управление
или нет. практика нам показала что первый cat в субшелле посрал на то что первый файл закончился 
и работал до упора напечатал оба файла и только потом закончил работу и передал управление дальше.
поэтому второй cat оказался полностью пустой. к нему по пайпу ничего не прилетело.



вот еще пример на эту тему
вот у нас есть файл 
    $ cat 6.txt 
    666
запускаю такую команду
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
в ней я говорю что  я буду пихать в головной cat вначале данные сам руками из терминала.
а потом как закончу данные в cat еще поступят из файла 6.txt
мой вопрос до второго cat в субшелл чтото долетит или нет?
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    вася  <=== это  я ввел руками в терминале
    вася
    петя  <=== это  я ввел руками в терминале
    петя
          <== тут я нажал Ctrl+D (EOF) и cat прекратил читать из терминала и начать читать файл 6.txt
    666   <== содержимое файла 6.txt
    второй  привет из субшелл


так вот видно то что первый cat в субшелле сидел и ждал данные до упора. она 
вначале дождался данных из того что я втермиале печатал. а потом он еще напечатал то что в 6.txt
и только после этого он закончил свою работу. и поэтом до второго cat в субшелле уже ничего не долетело
сверху. вот это и я хотел исследовать



еще малек пример про редирекшн.
пример
    $ echo -e 1>15.txt
я хотел изначально записать "1" в 15.txt
а как очевидно понятно я ошибся. и по факту обозначение "1>15.txt"
привело к тому что файловый дескриптор 1 стал указывать на 15.txt 
а не то что символ 1 был напечатан на экран. 
надо было вот так делать чтобы 1 на экране напечатался
    $ echo -e "1"   1>15.txt
вот как было правильно




теперь НАКОНЕЦ я возвращаюсь к тому примеру с которого начал изучение редиректов 
        $ exec &> >(tee -a ./1.txt)
теперь наконец  эта тарабарщина понятна!
"&>" дает то что stdin и stderr оба будут перенаправлены в некий файл. а что за файл?
а это как раз указано дальше , файл такой что он указывает на анонимный пайп из "bash process substitution" 
обычно это файл 
        /dev/fd/63 ---> /proc/self/fd/63 ---> 'pipe:[2498298]'

баш начнет анализировать всю эту команду после нажатия enter  и попросит ядро создать пайп 'pipe:[2498298]' 
где то в памяти ядра, далее баш 
произведет в исходной строке замену 
было
    $ exec &> >(tee -a ./1.txt)
стало
    $ exec &> /dev/fd/63

в доказательство этого я выполнил strace чтобы это поймать
    # strace -p 7859 -f  -s80  -e openat
    [pid  7859] openat(AT_FDCWD, "/dev/fd/63", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
причем этот файл присутствует именно в openat а не в execve
удивительно

далее баш выполнит команду exec и тогда у текущего баша поменяется два дескриптора. 1 и 2 (stdout и stderr)
раньше скорей всего они смотрели на файлы терминало /dev/pts/22
а станут смотреть на пайп
        /proc/bash_pid/fd/1 ---> 'pipe:[2498298]'
        /proc/bash_pid/fd/2 ---> 'pipe:[2498298]'

далее баш запустит еще один процесс и там запустит tee
к stdin дескриптору этого процесса он прилепит тот же пайп 
        /proc/tee_pid/fd/0 ---> 'pipe:[2498298]'

в итоге все что баш будет бросать на stdout\stderr будет направлено в пайп
и будет считано из пайпа командой tee и отрисовано на окне терминала и продублировано  в физ файл на физ диске.

хотелось  почеркнуть что отрисовка вывода в терминале будет идти не засчет головного баша
а за счет tee в субшелл.
посмотрим теперь на практике
    $ exec &> >(tee -a 1.txt)
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 13:11 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 1 -> pipe:[2331898]   <====
    l-wx------ 1 vasya vasya 64 окт  5 13:11 2 -> pipe:[2331898]   <====

    $ ps aux  | grep tee
    vasya    26155  0.0  0.0  14588   792 pts/17   S    13:10   0:00 tee 1.txt
    $ ls -1al /proc/26155/fd
    lr-x------ 1 vasya vasya 64 окт  5 13:11 0 -> pipe:[2331898]   <====
    lrwx------ 1 vasya vasya 64 окт  5 13:11 1 -> /dev/pts/17
    lrwx------ 1 vasya vasya 64 окт  5 13:11 2 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 4 -> /home/vasya/temp/1.txt

из чего действительно видно что в головноv баше stdin и stdout указывают на пайп [2331898]
а в процессе "tee" ее stdin смотрит в тотже самый пайп [2331898]
тоесть теория совпала с практикой


далее я покажу что будет напечатано в 1.txt
если в исходной терминале будет выглядеть вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

то в 1.txt будет вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

что интересно новые буквы будут появляться в файле не тогда когда мы воригинальном терминале 
нажали enter а уже тогда когда мы в терминале нажали просто букву!
что еще более поразительно. если мы сотрем букву на оригинальном терминале то эта буква также сотрется 
и в файлле ! amazing!
вот это тема.... охренеть


возникает удивительный вопрос а нахуй этот механизм нужен на практике? покажите
пример практический когда это может пригодится?

еще пример
еще:
    $ echo 1 >(cat)
        1 /dev/fd/63
ну понятно. строка 
    $ echo 1 >(cat)
будет заменена на
    $ echo 1 /dev/fd/63
отсюда результат


далее
    >&, &>
есть ли разница.
обычно нет. но лучше юзать &>
по смыслу эта команда перенаправляет sterr и stdin в один файл
который обязательно нужно укзаать после тоесть
    $ echo "aaa" &> /tmp/1.txt
эквиваелент
    $ echo "aaa" 1>/tmp/1.txt 2>&1
либо
    $ echo "aaa" 1>/tmp/1.txt 2>/tmp/1.txt


далее
    >|
тут интересно. баш имеет ряд крутилок настроек.
настроки подкручитваются через баш билтин set
    $ set --help
в частности вот так крутятся настройки
    $ set +o pipefail -o noclobber
посмотреть текущие настройки вот так
    $ echo $-
хотя там не информативно. а более информативно вот так

$ set -o
set -o
+ set -o
allexport       off
braceexpand     on
emacs           on
errexit         off
errtrace        off
functrace       off
hashall         on
histexpand      on
history         on
ignoreeof       off
interactive-comments    on
keyword         off
monitor         on
noclobber       off
noexec          off
noglob          off
nolog           off
notify          off
nounset         off
onecmd          off
physical        off
pipefail        off
posix           off
privileged      off
verbose         on
vi              off
xtrace          on

видно опять же как я сказал что noclobber выключена.
если она включена то ">" не даст перезаписать существующий файл. выдаст ошибку.
у нас опция выключена поэтому ">" перезатирает файл без всяких ошибок.
так вот если все таки noclobber активирована то ">|" позволяет игнорировать эту настройку.  
в общем в итоге ">|" малополезная хрень.
я еще ни разу не встречал чтобы noclobber был хоть где то активирован.

далее пример. 
я нашел более менее пример который уже как то типа может быть полезен на практике.
есть два файла
    # cat 7.txt 
        a
        b
        c
    # cat 6.txt 
        1
        2
        3

есть интересная команда "paste" она читает из нескольких файлов по одной строке
и печатает это на экране через TAB
    # paste 6.txt 7.txt 
        1   a
        2   b
        3   c
так вот как это же можно сделать через bash process substitution 
    # paste <(cat 6.txt) <(cat  7.txt)
        1   a
        2   b
        3   c
ну когда мы читаем из готовых файлов то пример мало полезен. а вот когда 
нам надо прочитать из stdout нескольких процессов и все это построчно соединить в таблицу
на экране то bash process substitution уже становить реально полезен
    # paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp)
        INT3400 Thermal 20000
        pch_cannonlake  40000
        B0D4    0
        x86_pkg_temp    42000


как написано в мануле утилита "paste" позволяет соединить строки нескольких файлов вместе.
тоесть еще пример
    $ cat 1.txt 
        aaa
        bbb
        ccc 
$ cat 2.txt 
        5
        6
        7 
$ paste 1.txt  2.txt 
        aaa 5
        bbb 6
        ccc 7 

разделение идет через TAB


далее я опишу утилиту colrm
это частично идиотская утилита потому что ее man нагло врет
    $ colrm start stop
утилита удаляет из текста колонки с номерами  
    start << колонка << stop
причем разделителя колонки никакого нет. это ни пробел  ни TAB
это всегда банально номер символ в строке. показываю
в этом примере будет удалены символы 3 и 4
их позиция в строке и является так называемой "колонкой"
    $ echo -e "123456789" | colrm 3 4
    1256789
если указать только стартовую колоноку то он удаляет вот такие колонки
    start << колонка << EOL
пример
    $ echo -e "123456789" | colrm 3
    12
в целом убогая утилита



далее я опишу утилиту column
она позволяет назначить разделитель и потом отформатировать текст по колонкам.
но по мне утилита корявая. она порой работает хер знает как.
итак имеем файл
    $ echo -e "1+2+3+4+5\n6+7+8+9+10"
    1+2+3+4+5
    6+7+8+9+10
воспользуемся недавно узнанной штукой "bash process substitution"
    $ column -t -s "+" <(echo -e "1+2+3+4+5\n6+7+8+9+10")
    1  2  3  4  5
    6  7  8  9  10
так вот утилита column 
ее ключ -е без него вобще ничего не работает. считай что он значит что надо отформатировать текст
ключ -s "+" означает что разделитель между колонками "+"

далее важно дополнение. выравнивание в колонке идет всегда по левому краю.
пример про это
    $ echo -e "111111111+2+3+4+5\n6+7+8+9+10"
    111111111+2+3+4+5
    6+7+8+9+10

    $ column -t -s "+" <(echo -e "111111111+2+3+4+5\n6+7+8+9+10")
    111111111  2  3  4  5
    6          7  8  9  10

порой эта прога как уже сказал работает непонятно как . но если ее применить несколько раз
то вроде можно получить вменяемый результат
практический пример 
имеем вот такой вывод.
почему то cpupower хреновато форматирует свой текст
можно заметить что "Freq" и "POLL" поплыли
    $ sudo cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6   || C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,02|  1,37| 59,17|  0,00||  0,88| 99,12|   632||  0,00|  0,00|  0,00|  0,02|  0,47|  0,00|  3,36|  0,16| 95,13
   4|  0,02|  1,37| 59,17|  0,00||  2,33| 97,67|   577||  0,00|  0,00|  0,03|  0,01|  1,36|  0,00| 14,02|  0,08| 82,29
   1|  0,13|  0,42| 59,17|  0,00||  1,66| 98,34|   598||  0,00|  0,74|  0,18|  0,09|  0,23|  0,00|  7,52|  0,03| 89,59
   5|  0,13|  0,42| 59,17|  0,00||  1,06| 98,94|   600||  0,00|  1,82|  0,00|  0,06|  0,26|  0,00| 10,37|  1,03| 85,34
   2|  0,00|  0,27| 59,17|  0,00||  1,70| 98,30|   657||  0,00|  0,00|  0,01|  0,02|  0,02|  0,00|  4,72|  0,00| 93,46
   6|  0,00|  0,27| 59,17|  0,00||  0,32| 99,68|   623||  0,00|  0,00|  0,02|  0,00|  0,20|  0,00|  4,52|  0,00| 94,87
   3|  0,09|  0,98| 59,17|  0,00||  0,87| 99,13|   609||  0,00|  0,94|  0,73|  0,03|  0,48|  0,00|  7,93|  0,00| 89,05
   7|  0,09|  0,98| 59,17|  0,00||  1,62| 98,38|   568||  0,01|  0,66|  0,04|  0,10|  0,76|  0,00| 14,12|  0,00| 82,69


отформатируем этот текст
    $ sudo cpupower monitor | column -t -s "|" | column -t -s " " | grep -v Nehalem
CPU      C3     C6          PC3    PC6   C0    Cx     Freq  POLL  C1    C1E   C3    C6    C7s   C8     C9    C10
0        0,02   1,22        52,58  0,00  1,20  98,80  645   0,00  1,92  0,17  0,02  0,23  0,00  9,80   1,11  85,57
4        0,02   1,22        52,58  0,00  1,84  98,16  623   0,00  0,00  0,24  0,04  1,83  0,54  11,55  0,38  83,64
1        0,08   0,40        52,58  0,00  1,76  98,24  631   0,01  0,00  0,02  0,09  0,48  0,00  8,84   0,00  88,81
5        0,08   0,40        52,58  0,00  3,34  96,66  674   0,00  1,05  1,26  0,00  0,16  0,40  6,78   0,07  86,95
2        0,06   2,54        52,58  0,00  2,61  97,39  666   0,00  0,11  0,85  0,01  0,72  0,00  8,97   0,07  86,65
6        0,06   2,54        52,58  0,00  2,02  97,98  646   0,00  0,00  0,03  0,10  3,00  0,00  10,23  0,06  84,53
3        0,03   0,71        52,58  0,00  5,44  94,56  654   0,00  0,00  0,00  0,05  0,68  0,00  15,06  0,09  78,67
7        0,03   0,71        52,58  0,00  0,75  99,25  635   0,00  0,00  0,01  0,01  0,09  0,00  6,79   0,00  92,28

в плане ключа -s который указывает разделитель колонок
так вот возникает вопрос как указать в качестве разделителя например знак табуляции
в мануале об этом нет ни слова. так вот ответ вот как
    -s $'\t'
а вот пример
    $ echo -e "1\t2\t3\t"
    1   2   3   

    $ echo -e "1\t2\t3\t" | column -t -s $'\t'
    1  2  3

утилита column работает так что она удаляет из строк сам знак разделителя
и заменяет его на пробел. или пробелы. по своему усмотрению. поэтому в примере выше она убрала
табы и вставила пробел как разделитель заместо

а теперь более менее практический пример где эта утилита может пригодится реально
исходный текст
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с"
    'температура датчика'   'скорость'  'высота'
    30°C    12 м\с

прикол в том что между колонками TAB а внутри колонки у нас пробелы могут быть.
а мы хотим выровнять.
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с" |  column -t -s $'\t'
    'температура датчика'  'скорость'  'высота'
    30°C                   12 м\с



а вот пример ради которого я долбался писал выше описание для 
утилит paste, bash process substitution, sed 
( кстати о том как работает sed смотри в sed-awk-cut-tr.txt )
итак встретился в инете такой пример.
в нем column он заменяет разделитель TAB на пробел,
а sed берет три последние символа, запоминает третий слева символ в группу 1,
и вместо трех последних символов вставляет точку плюс символ который сохранен в группе 1 и 
далее градус с цельсием. например в конце было 20000, значит три берем три последних символа это "000"
запоминаем третий слева в группу 1 это "0" и заменяем в итоге на ".0°C"
    $ paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp) | column -s $'\t' -t  | sed 's/\(.\)..$/.\1°C/'

    INT3400 Thermal  20.0°C
    pch_cannonlake   37.0°C
    x86_pkg_temp     39.0°C


далее еще пример про редирект
    $ echo "456" | ssh thinkpad cat - 1>~/7.txt
прикол в том что редирект будет идти не в файл на удаленном компе. нееееееет.
файл будет записан на этом компе!
чтобы записать файл на удаленный комп нужно
    $ echo "456" | ssh thinkpad cp /dev/stdin ~/7.txt


| {!var}
как нам напечатать переменную имя которой хранится в дургой
переменной.
    $ a="1"
    $ b="a"
эта хрень нам даст просто то что лежит в $b
    $ echo "$b"
    a
а вот уже эта хрень нам сделает двойное раскрытие имени переменной и напечатает то что лежит в $a
    $ echo "${!b}"
    1
причем важно заметить что надо именно вот так сохранять имя переменной
    $ b="a"
если сделать вот так
    $ b='$a'
то раскрыть такое не полуxится и баi пошлет нахер
    $ echo "${!b}"
    bash: $a: bad substitution
а если сделать вот так
    $ b="$a"
то тоже ничего хорошего не полуxится
    $ b="$a"
    $ echo "$b"
    1
    $ echo "${b}"
    1
итак только такой вариант работает
    b="a"

    
    
    
| <<<
пока что детално неразбирался но 

    $ bc <<< 2*3
    6
тоесть это некий аналог 
    $ echo -n "2*3" | bc

    

    
    
| ${#parameter}
| ${#var}

вычисляет длинну переменной
    $ a="123"
    $ echo ${#a}
    3

если у нас скрипт то 
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"
    $ ./03.bash 1
    первый параметр = 1, длинна первого параметра = 1
    $ ./03.bash 12
    первый параметр = 12, длинна первого параметра = 2
    $ ./03.bash 
    первый параметр = , длинна первого параметра = 0

в данном случае #1 это первый аргумент передаваемый в скрипт


еще один пример
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"

    for ((i=0; i<${#1}; i++))
    do
        echo "i = $i"
    done


    $ ./03.bash 5
    первый параметр = 5, длинна первого параметра = 1
    i = 0

поскольку длинна первого аргумента скрипта "5" равна единице то цикл for имеет параметры
i=0, i<1, i++
поэтому он отрабатывает один раз
еще интересно то что {#1} означает посчитать длинну переменной $1






| ${parameter:offset:length}
| ${:::}

позволяет печатать не всю переменную а ее часть.
причем важно offset указывает начало откуда печатать
а length указывает сколько символов после оффсета напечатать
следущий пример печатает начиная с оффсет и до конца переменной
    $ a="123"
    $ echo ${#a}   # напоминаю что ${#a} считает длинну переменной 
    3
    $ echo ${a:0:${#a}}
    123
    $ echo ${a:1:${#a}}
    23
    $ echo ${a:2:${#a}}
    3
    $ echo ${a:3:${#a}}
очевидно что нумерация символов в переменной начинается с "0"

следущий пример печатает начиная с оффсет всего один символ
    $ a="123"
    $ echo "${a:0:1}"
    1
    $ echo "${a:1:1}"
    2
    $ echo "${a:2:1}"
    3



    
    
    
| ${#}
| ${:::}

вот еще интерснейший пример

    $ cat md.bash 
    #!/bin/bash

    for((i=0; i<${#1}; i++))
    do
        echo "i=$i"
        echo "${1:$i:1}"
        echo "---"
    done

    $ ./md.bash 34
    i=0
    3
    ---
    i=1
    4
    ---

значит вот эта хует ${#1} означает посчитай длинну переменной $1
где $1 это первый аргумент командной строки который был передан скрипту при запуске

вот эта хуета "${1:$i:1}" означает возмьми переменную $1 и вырежь из нее символы начиная с позиции $i
в количестве 1 штука

получается мы передаем в скрипт 34 который будет являться $1
тогда ${#1} = 2
и цикл будет работать для i=0,1

для i=0
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 0 в количестве 1 штука. тоесть это будет 3

для i=1
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 1 в количестве 1 штука. тоесть это будет 3
4

что мы и видим на экране

охуеть




| printf
это bash builtin.

при этом эти суки в man bash нихуя про него нормально не написали ублюдки.

формат этой хуеты такой

printf "format" arg1 arg2 arg3 ...

тоесть вначале задается формат печати. а потом указываются аргументы(переменные) для печати


простейщий пример
    $ printf "asd\n"
    asd

в этом примере у нас указан только формат. аргументов нихуя нет.
asd это просто литеры. а "\n" это спецсимвол переноса строки. 
все супер просто.

теперь о некоторых других спецсимволах внутри формата

Format Specifier	Description
%c	Treat the arguments as a single character.
%d	Treat the input as a decimal (integer) number (base 10).
%e	Treats the input as an exponential floating-point number.
%f	Treat the input as a floating-point number.
%i	Treat the input as an integer number (base 10).
%o	Treats the input as an octal number (base 8).
%s	Treat the input as a string of characters.
%u	Treat the input as an unsigned decimal (integer) number.
%x	Treats the input as a hexadecimal number (base 16).
%%	Print a percent sign.
%Wd	Print the W integer X digits wide.
%(format)T	Outputs a date-time string resulting from using format as a format string for strftime. The corresponding argument can be the number of seconds since Epoch (January 1, 1970, 00:00), -1 (the current time), or -2 (shell startup time). Not specifying an argument uses the current time as the default value.
\%	Print a percent sign.
\n	Prints a newline character.
\t	Print a tab character.


важно. насколко я понял формат аргумента изначально воспринимается как string
а уже потом в строке формат он конвертируется согласно приказу.
обьясняю на примерах:
    $ printf "число=%d\n" 10
    число=10
    $ printf "число=%c\n" 10
    число=1

в первом примере мы берем аргумент стринг 10 и конвертируем  его в  десятичное число
во втором примере мы берем аргумент стринг 10 и конвертируем его как символ единичный поэтому он от 10 отрезал 1 символ
с начала. начало (офссет) у аргумента начинается слева. получили 1

следущие примеры
    $ printf "%x\n"  10
    a
    $ printf "%x\n"  11
    b

мы берем аргумент в формате стринг и конвертируем его в hex формат
и вот очень важный пример, 
    $ printf "%x\n"  "A"
    bash: printf: A: invalid number
    0
    $ printf "%x\n"  "a"
    bash: printf: a: invalid number
    0
    $ printf "%x\n"  "0xa"
    a
    $ printf "%x\n"  "0xA"
    a
тоесть на сколько я понял если мы хотим конвертировать аргумент в hex формат то на входе
по дефолту ожидается что аргумент имеет dec формат. а если мы хотим уже в аргументе выразить число в hex формате
то его нужно в аргументе писать в виде "0xhex"
охуеть




следущий прмиер
    $ printf "число=%x\n" q
    bash: printf: q: invalid number
    число=0
здесь он нас законно щлет нахер потому что как я уже сказал если мы хотим сконвертиоровать
аргумент в hex формат то аргументе по дефолту принтф ожидает видеть аргумент в формате десятичном 
поэтому аргумент вида "q" приводит к посыланию нахер


двигаем дальше. есть особая залупа о которой не сказано в манах. а оно только обнаруживется в примерах.
залупа касется аргиумента

    $ printf "%d\n" "'A"
    65
    $ printf "%x\n" "'A"
    41

если указываем в аргументе вот так 'аргумент
то это сообщает принтф что прежде чем аргумент подставлять в формат его нужно из ASCII символа преобразовать 
в число причем подставить это число в аргумент именно в десяиичном виде . 
тоесть в ASCII таблице символ "A" имеет код 65(dec)

итак 65  подставляется в аргумент. 
таким макаром первый пример превращается в 
    $ printf "%d\n" 65
    65
а второй пример превращается в  
    $ printf "%x\n" 65
    41

поскольку как я уже писал если мы хотим преобраовать число в hex то принтф ожидает по дефолту что 
в аргументе число представлено в формате dec. поэтому 65 dec преврашается в 41h
если же мы хотим чтобы принтф рассмматривал уже в аргументе 65 как hex число то надо делать вот так
    $ printf "%x\n"  "0x65"
    65

ну а вот такая хрень приводит к ошике
    $ printf "%x\n"  "0x'A"
    bash: printf: 0x'A: invalid hex number
    0

вообще этот принтф это полный пиздец. выдумка шизофреника. 

следущий момент а если у нас несколько аргументов. тогда они выбираются слева направо по порядку. тоесть
    $ printf "ширина=%d, длинна=%d \n" "10" "2"
    ширина=10, длинна=2
тоесть первый %d берется как 10
второй %d берется как 2
все просто. идем слева направо.


далее. 
значит таким макаром если мы хотим по быстрому узнать какой ASCII код у символа
то можно набрать 
    $ man ascii
а можно вот так
    $ printf "%d\n" "'3"
    51
    $ printf "%d\n" "'4"
    52


далее. 
что еще интересно что вот эта хуйня $1 она возможно только при вызове скрипта
тоесть просто для команды в строке этой хуйни не сущетсует
    $ echo $1 <<< "a"
    $ echo "1" | echo $1 
    $ printf "%s \n" "$1" <<< "a"
    $ echo "a" | printf "%s \n" "$1" 
видим что везде пусто на выхлопе





| bc
с ним есть такая хуйня. если мы в него передаем строчку то обязательно 
она должна заканчиваться символом Enter иначе пошлет нахуй. 
пример
    $ echo "2*3" | bc   
    6
    $ echo -n "2*3" | bc
    (standard_in) 1: syntax error
тоесть во втором примере ошибка потому что echo -n недобавляем автоматом символ Enter
к потоку байтов. поэтому bc шлет нахуй.

тоже самое когда юзаем printf 
    $ printf "2*3" | bc
    (standard_in) 1: syntax error
    $ printf "2*3 \n" | bc
    6

    

    
    

| for

есть вот такая хуйня в баш

   for i
    do
        echo -n "vasya"
    done

мы видим   
    for i
типа что за хуйня? оказывается это есть такое сокращение для
    for i in $@
охуеть. потому что иначе эта строчка сука не имеет никакого значения падла
таким образом это эквивалент
   for i in $@
    do
        echo -n "vasya"
    done


    
    
| wc

оказалась приколная программа
что она умеет делать
  wc - print newline, word, and byte counts for each file

тоесть она умеет считать:
    число строк
    число слов
    число байтов


этот пример берет папку с *.txt файлами и считает сколько в них суммарно слов
    $ ls -1 *.txt | xargs -L1 -I% wc -w ./"%" | awk '{print $1}' | xargs echo | sed 's/ /+/g' | bc
    727721

еще можно через wc считать число букв или байтов в стринге
хотя есть подьебка
пример
    $ echo "1" | wc -m
    2
возникает вопрос почему длинна два символа.
а потому что эхо вставил символ Enter вконце. а для wc это тоже символ
    $ echo "1" | od -t x1
    0000000 31 0a

убираем enter в конце и получим уже верный результат
    $ echo -n "1" | wc -m
    1

    $ echo -n "1" | od -t x1
    0000000 31

поэтому удобнее считать число букв в стринге через awk потому что он enter не считает
пример
    $ echo  "1" | awk '{print length}'
    1

а теперь самый что ни на есть практический пример.
нужно узнаиь число букв в хеше
    $ echo "1" | sha512sum | awk '{print $1}'   | awk '{print length}'
    128
    $ echo "1" | sha512sum | awk '{print $1}'   | wc -m
    129
    $ echo "1" | sha512sum | awk '{print $1}'   | od -t x1
0000000 33 61 62 62 36 36 37 37 61 66 33 34 61 63 35 37
0000020 63 30 63 61 35 38 32 38 66 64 39 34 66 39 64 38
0000040 38 36 63 32 36 63 65 35 39 61 38 63 65 36 30 65
0000060 63 66 36 37 37 38 30 37 39 34 32 33 64 63 63 66
0000100 66 31 64 36 66 31 39 63 62 36 35 35 38 30 35 64
0000120 35 36 30 39 38 65 36 64 33 38 61 31 61 37 31 30
0000140 64 65 65 35 39 35 32 33 65 65 64 37 35 31 31 65
0000160 35 61 39 65 34 62 38 63 63 62 33 61 34 36 38 36
0000200 0a
0000201


видно что awk дает верный ответ а wc нет. потому что у нас в стринге на конце есть 0x0a тобишь Enter и wc его считает. 
а он нам нахуй ненужен.
-----


| printf

эта команда настолкло ебанутая что ее надо описать отдельно суку
во первых есть встроенный в баш билтин printf
а есть отдеьная программа которая от баша никак не зависит.
баш почмуто по дефолту запускает не свой билтин а внешнюю.
проверить это легко через strace

    $ strace printf "поле формата \n"
    execve("/usr/bin/printf"...

запустить именно билтин принудительно можно через 
    $ builtin printf "a"
справочная по билтину охуенно убогая. смотрим либо 
    $ builtin printf  --help
либо man bash

далее рассматриваем только внешнюю команду /usr/bin/printf
справка по ней тоже охуенно убогая
    $ man printf
    $ man 3 printf


    
a1
'a
$salt


значит у принтф ест  минимум одно поле. поле формата
    $ printf "поле формата"
    поле формата

в целом туда вставляется все то что мы хотим напечатать. ровно также как это есть у 
команды echo "печать"

в отличие от echo принтф не вставляет автоматом на конце символ новой строки. поэтому 
его надо вставлять руками. через "\n"
    printf "поле формата \n"
    поле формата 

слэш как и у баша в целом это спец символ. тоесть когда его встречает принтф то он его рассматривает 
не как просто печатную литеру а как то что за ней идет символ который тоже является спецсимволом и чтобы его
можно было напечатать его экранирует слэш.
помимо экранируеющего действия комбинция слэш + некоторый символ за слэшем сообщает принтф что \X это тоже 
некий спецсимвол.тоесть с одной стороны слэш может отключать функцию спецсимвола для спецсимвола котоырй стоит за слешем
с другой стороны комбинация слэша и некоторого простого символа стоящего за ним формирует в итоге спецсимвол.
чтобы это все показать на примерах я еще добавлю одну хрень. переменные можно печатать также как и у echo 
тоесть
    $ a=123
    $ printf "$a"
    123
так вот очевидно что $ это спецсимвол который обьясняет принтфу что за ним идет не просто печатный символ "a" 
что за $ идет имя переменной. 
так вот если мы хотим просто распечатать '$a' тогда надо обьянсить принтф что доллар  в данном случае это не спец
символ а просто литера. тут вступает в дело слэш. 
пример
    $ printf "\$a"
        $a
    $ printf "\$a\$a\$a"
        $a$a$a
    $ printf "$a$a$a"
    123123123
с этим понятно.
    $ printf """
    > ^C
тоесть символ " является спецсимволом и он нам его недает напечатать. 
отключаем спецсимвольность и полный порядок
    $ printf "\""
    " 
печатаем слэш
    $ printf "\\"
    \
итак мы рассморели примеры когда слэш забирает силу у спецсимвола преврашая его в просто литеру
теперь рассматриваем случай когда слэш дает спецсилу простму символу.
самый известные пример это символ кнопки Enter. тоесть символ новой строки и перенос каретки налево.
    $ printf "1 \n"
    1
тоесть будет наечатан 1 и пробел. а затем экран будет прокручен на 1 строку вверх и печатная головка
возвратится на начало строки. тоесть \n это управляющий символ терминала
далее. печатаем спецсимвол backspace (прикольно!)
    $ printf "abc"
    abc
    $ printf "abc\b"
    ab
    $ printf "abc\b\b"
    a
тоесть он затирает символ слева как кнопка backspace.
кстати backspace походу переводится как "пробел в обратно направлении"
однако тут я нашел некую необьяснимую хуйню.
вот я печатаю три символ и затираю последние два
    $ printf "abc\b\b"
    a
но если я добавляю в конце символ новой строки тобишь нажатие кнопки enter то
почемуто при этом все символы будут напечатаны. хуйня какаято
    $ printf "abc\b\b\n"
    abc
почему такая хуйня непонятно
однако далее стало понятно что "\b" это ссукат не backspace как
об этом написноа в man ascii это на самом деле аналог стрелки влево. тоест 
он передвигает каретку на один символ влево и сам символ не удаляет.
вот пример
    $ echo -ne "123\b"; sleep 5
или 
    $ printf "123\b"; sleep 5
если мы доблавяем \n то у нас прокручивыается строка наверх и поэтому 123
сохраняется. если мы \n недобавлем то баш начинает печатать с текущего положения
каретки и просто затирает 3. вот как это работает

следущий спецсимвол который образуется в паре со слещем это "form feed"
он означает прокрутить экран или бумагу на одну строку вверх при этом положение
печатающей головки остается на том же месте
    $ printf "abc\f 1  \n"
    abc
        1  
тоесть мы напечатали abc и пробел. потом прокрутили бумагу на 1 строку вверх и в той же
горизонтальной позиции продолжаем печатать.
по факте терминал (черный экран) это полны аналог матрчного принтера. у него есть 
строка в которой он печатает и он может бумагу прокручивать на одун строку вверх и есть
печатная головка которая печатате символ в текущем положении.
единственное что нет такого спецмивола чтобы строку прокрутит не на 1 строку вверху 
а обратно на 1 строку вниз. жалко.
    $ printf "abc\f1\f2\f3  \n"
    abc
        1
          2
            3  
следущий спецсимвол это вовзрат печ головки вначало строки 
    $ printf "abc\rdef  \n"
    def  
тоесть это работат так 
вначале печаается abc потом печатающая головка (курсор) возврашается вначало этой же строки
и начинает печататаь новые символы убивая старые. поэтому abc исчзаеае а def появлыется
    $ printf "vasya\rB\n"
    Basya
мы напечатали vasya потом вернули голову внвало стоки и напечатали символ B
поэтому vasya стал Basya
что интересно что если мы будем писать эту хрень в файл то в нем будут все эти символы. 
щам покажу
    $ printf "vasya\rB\n" | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
или прям запишем в файл на диске и прочитаем
    $ printf "vasya\rB\n" > 11.txt
    $ cat 11.txt | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
             v  a  s  y  a \r  B  \n    <==  я показываю какой символ ASCII\UTF-8 соотвествет какому байту

считываем этот файл с диска и видим на экране
    $ cat 11.txt 
    Basya
    
так в чем прикол  что я хотел этим показать. я хотел паоказать что 
по факту файл на диске содержить гораздо больше чем просто Basya как это мы видим на экране.
файл по факту содержит слово "vasya" которое мы на эаркне не видим. несколко упраляющих симвлов и символ "B"
когда терминал читает с диска поток байтов. то из за наличия нетолько байтов отвечающих за просто символы но и из 
за наличия управляющих терминалом байтов у нас на экране текст получается совсем не такой как он есть в файле.
таким макаром можно в тексте прятать информацию. вот еще пример
    $ printf "notebook Lenovo\rcarpet table wood\n" > 11.txt
    $ cat 11.txt 
    carpet table wood
тоесть по факту в файле есть символы "notebook Lenovo" но они при печати на терминале перетираются
из за управляющего символ '\r'
и мы видим только "carpet table wood"
хотя по факту в файле есть и то и то
    $ cat 11.txt | hexdump -C
    00000000  6e 6f 74 65 62 6f 6f 6b  20 4c 65 6e 6f 76 6f 0d  |notebook Lenovo.|
    00000010  63 61 72 70 65 74 20 74  61 62 6c 65 20 77 6f 6f  |carpet table woo|
    00000020  64 0a                                             |d.|
охуеть

следудуший спецсимвол образюущийся из за налияичия слеша это горизотальная табуляция \t
    $ printf "1\t2\t3\n"
    1	2	3
тоесть работате так. 
терминал печатает 1 потом он видит \t и делает своей печатающей головкой или курсором скачок направо на определенное
число пробелов. потом печатает 2 итак далее. вконце видит \n и тогда он прокручивает строку на 1 вверх
и возвращает печатную головку в начало строки.

следущий спецсимвол это верикальная табуляция. он чтото я не понял разницу между form feed и vertical tab
$ printf "1\v2\v3\n"
1
 2
  3
[vasya@lenovo !9]$ printf "1\f2\f3\n"
1
 2
  3

на выхлопе одно и тоже.

ксатти вовзращаясь назад. когда слэш экранирует спецсимвл лишая его силы. 
есть спец символ у принтф это %
    $ printf "%"
    bash: printf: `%': missing format character
тоеть поше нахууй
пробуем его экранировать
получаем почемуто опять пошел нахуй
незнаю почему
    $ printf "\%"
    bash: printf: `%': missing format character
и только прочитав man printf узнаем что % экранруется индивиудуаальным особым образом
    $ printf "%%"
    %
охуеть.

далее легко заметить и понять что когда мы в термиале виваем символ
то по факту в stdout или в файл улетает никако не символ а байт
    $ printf "a" | od -t x1
    0000000 61
тоесть скажем за символ "a" отвечает байт 0x61
свызь между символом на экране и байтом котоырй за ним стоит это либо ASCII таблица (man ascii)
либо это UTF-8 таблица. причем байты из ascii совпдают с UTF-8 байтами. 
так я это к чему говорю. можно указать принтф что мы вбиваем не печатный символ а сразу байт
скажем байт в hex виде в принтф прописывается как 
    \xHH
тоесть 
    $ printf "\x61"
    a
тоесть \x в поле формата сообщает принтф что это непросто литеры '\' и 'x' а что это спецсимвол который обозначает
байт в hex виде. показываю
    $ printf "a" | od -t x1
    0000000 61
    $ printf "\x61" | od -t x1
    0000000 61
соотвественно чтобы напечатать '\x61' просто как набор литер надо это экранировать
    $ printf "\\\x61" 
    \x61
тоесть мы обьяснили принтф что и \x это просто литеры. хотя непонятно почему вот такой варинт не прокатывает
    $ printf "\\x61" 
    a
ведь по идее мы сделаи \\ что обьяснило принтф что мы печатаем просто \ ну а дальше у нас просто x61
ксатти одиночные кавычки в этом плане все делают более предсказуемым
    $ printf '\x61' 
    a
тоесть видим что \x по прежнему интерпретируется как спецсимвол
но чтобы его обезвредить уже достаточно один раз применить слеш перед слеш
    $ printf '\\x61' 
    \x61

есть еще возможность указать принтф что мы печатаем не символы а байты в формате OCTAL
       \NNN   byte with octal value NNN (1 to 3 digits)

номер символа в формате UNICODE
       \uHHHH Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)
       \UHHHHHHHH
              Unicode character with hex value HHHHHHHH (8 digits)
но я не буду для этих случаев разбирать примеры.

теперь переходим к переменным принтф. хотя они у него называются аргументами.
окей буду называть их аргументами. 
значит помимо поля формат 
    $ printf "поле формата" 
у принф еще можно указать аргументы
    $ printf "поле формата" арг1 арг2 арг3
и тогда при печати эти аргументы будут вставлены в поле формата.
внутри поля формат мы обозначаем что мол сюда надо вставить аргумент через конструцию %T
где T это несколько возможных хреней. например
    %d означает что нужно взять аргумент , преобраозовать его в dec число и уже вставить 
пример
    $ printf "%d \n" "1"
    1 
тоесть он берет 1 преобразует его в 1 (то по факту в данном сулчае нихуя преобразоывать ненадо) и вставляет
в принтф. тоесть 
    printf "%d \n" "1"
превращается после подставновки в 
    printf "1 \n"
и мы получаем на экране
    1
возникает резонный вопрос а нахуя такой огород если можно сразу вставить 1 в поле формат. 
ответа я не знаю. тоесть например вот у нас есть переменная и вот у нас два совершенно равнозачных 
примера
    $ printf "$a \n"
    123 
    $ printf "%d \n" "$a"
    123 
единственный смысл такого усложнения горждения огорода я вижу в том что при таком раскладе само поле формат
может быть коротким и легко воспринимаем а сложные аргументы вынесены отдельно. например
    $ printf "%d \n" "$( echo "2*3" | bc)"
    6 
тоесть у нас поле формат маленькое компактное легко воспринимамое. а громоздкий аргумент вынесен во вне.
возможно в этом смысл такого огрода
раньше я думал что просто переменные нельзя вставлять напрму в поле формата. но как теперь понятно это не так.
причина не в этом.

так вот возврашаемся обратно к %d
как я уже сказал его смысл в том что мы берем аргумент и преобразуем его в dec вид 
и уже как литеру подставляем в поле формат. щас я покажу что значит преобразуем
    $ printf "%d \n"  "0xa"
    10 
значит у нас аргумент записан в hex виде (об этом щас поговорим). так вот %d его преобразует в dec тоесть 
0xa преобразует в 10 и постславяет уже как литера в поле формата
    $ printf "%d \n"  "0xa" ---> printf "10 \n"
    10
и получаем 10 на экране
таким образом видно что формат аргумента совершенно не обязан совпадать с форматом внутри поля формат. 
будет происходить преобразование.
и пиздец конкетной этой ситации в том что если мы находится в поле аргумент то hex формат в нем выглядит как "0xNN"
в то время как в поле формат hex формат выглядит совершенно по другому
    $ printf "\x21 \n"  
    ! 
правда и разница при этом колоссальная. hex число напряму в поле формата вставляется в байтовый поток 
как есть в виде этого hex числа без преобраования в литеру!
а hex число в аргументе как мы видим приводит к тому что оно будет преобразовано в литеру а какой у него будет 
байт уже зависит от ascii таблицы. еще раз показваю разницу
    $ printf "\x22"  
    "
    $ printf "\x22"  | od -t x1
    0000000 22

    $ printf "%d"  "0x22"
    34
    $ printf "%d"  "0x22" | od -t x1
    0000000 33 34

тоесть еще раз. hex формат в поле "формат" у нас в виде '\xNN'
а hex формат в поле "аргумент" совершенно другой в виде '0xNN'
почему так хуй знает.
но и последствия разные. в первом случае у нас 22h будет прям засунут в байтовый поток
а во втором случае hex число будет преобразовано в dec число. и будут найдены соотвствующие литеры в ascii
таблице чтобы это число в итоге нарисовать в терминале. тоесть "34" это 33h и 34h коды в таблице ascii
и тут приходит фундаментальный вопрос в голову а что еси у нас аргумент выглядит как '\x33\x34'
тоесть как мы видим это hex формат но он несоотвествует hex формату разрешенному при использовании для аргумента
    $ printf "%d"  "\x33" 
    bash: printf: \x33: invalid number
как говорится пошел нахер.
так вот как заставит принтф понимать что в аргументе используетсяя hex число просто в другом способе написания хекса.
так вот как это сделать для %d непонятно.
зато известен ключ %b
и вот что он делает
он берет то что находится в аргументе и считает что там прописаны голые байты. тоесть
    $ printf "%b" "\x21"
это полный эквивалент
    $ printf "\x21"
и в итоге получаем
    $ printf "\x21"
    !  
    $ printf "%b" "\x21"
    !  
тоесть %b берет аргумент и вставлят его в поле формата но не  в формет печатных литер а именно в виде голых 
байтов. при этом формат голых байтов должен соотвестовать правилу как эти голые байты могут выглядеть в поле формат.
пиздец
соотвстенно с этим волшенбным ключом %b мы можем использовать либо так либо так
    $ printf "%b" "\x21\x21\x21\x21"
    !!!!
    $ printf "\x21\x21\x21\x21"
    !!!!
тоесть ключ %b позволяет нам вынести из поля формата голые байты в аргумент.

приведу следущий ключ %s
он берет аргумент и вставляет как есть в форме символов как стринг.
    $ printf "%s \n" "\\\\%\\\\"
    \\%\\ 
    $ printf "%s \n" "\x21\x21\x21\x21"
    \x21\x21\x21\x21 

тоесть очень тупо и просто. ровно как мы видим символы в аргументе так они и будут напечатаны на экране

следущий ключ %c делает тоже самое что %s но печатает только первый символ
    $ printf "%c \n" "\x21\x21\x21\x21"
    \ 
    $ printf "%c \n" "\\\\%\\\\"
    \
    
    
 еще один полезный ключ это %x он или %X берет число из аргумента
и преобраует его в hex число и печатаем с помощью литер.
X отличается от  x тем что печатает результат в заглавном формате (большими буквами) 
    $ printf "%x \n" "10"
    a 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%X \n" "0xA"
    A 
    $ printf "%X \n" "0xa"
    A 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%x \n" "0xA"
    a 

ксатти вот еще интересно
    $ printf "%x" "0x21 0x33 0x34 0x56"
    bash: printf: 0x21 0x33 0x34 0x56: invalid hex number
    $ printf "%x" "0x21"
    21
    $ printf "%x" "0x2133"
    2133
    $ printf "%x" "0x21333456"
    21333456
    
по идее все самые важные и частые ключи  я описал.
соовественно если у нас есть переменная которая содержит ascii коды символов то чтобы их напечатать
именнов форме символов надо чтобы формат был вида \x21 тогда
    $ a="\x21\x33\x34\x56"
    $ printf "$a \n"
    !34V 
либо 
    $ printf "%b \n" "$a"
    !34V 

если же у нас a="21333456" либо a="0x210x330x340x56" либо a="21h33h34h56h"
то такие hex ascii коды  мы хрен распечатаем  в форме символов на раз два.
надо преобразоываать.
щас покажу. 
пусть у нас есть переменная которая хранить ascii коды в hex формате но вот в таком виде
    $ a="21333456"
и мы хотим их напечатать на экране в виде символов 
    $ sed 's/../\\x&/g' <<< $a
    \x21\x33\x34\x56
тоесть мы заменяем 
    21333456 -->  \x21\x33\x34\x56
тогда
    $ printf "%b \n" "$(sed 's/../\\x&/g' <<< $a)"
    !34V 
хотя самый простой способ превратить ascii коды "21333456" в символы это пойти по другому пути
    $ echo "21333456" | xxd -r -p | cat
    !34V

далее. вот еше прикол
понятчно и логично что если у нас  в поле формата (кстати идиотский термин) указано два аргумента
и по факту у нас два аргумента то в первый подставляется первый а во второй подставляеься второй
    $ printf "%d %d \n"  "10" "11"
    10 11 
но мне даже в голову не приходило пока не напоролся на пример в интете что 
число аргументов в поле формата может не совпадать с числом аргументов
и тогда походу они применяются по кольцу
    $ printf "%d \n" 1 2 3 4 5
    1 
    2 
    3 
    4 
    5 

пока все про printf
это не команда это какойто идиот ее писал. пиздец.






| $''

$'' эта конструкция имеет особый смысл
эта хрень позволяет определять стринг в баше аналогичный ""
причем подчеркну что $'' это единая конструкция.
так вот она дает то что эта хрень она понимает спецсимволы типа \n \t итп
это удобно если мы хотим задать например переменную у кооторой есть 
cпецсимволы.
пример
первый
    $ echo "\t1"
    \t1
как я понимаю в этом примере содержимое стринга "\t1" в памяти в байтовом виде представляет собой
    5Ch 31h, где 5Ch в ascii это символ "\" , 74h в ascii это "t",  31h в ascii кодах это "1"
соотвественно echo пытается печатать байтовый поток 0x5C7431

а вот второй пример
    $ echo $'\t1'
        1
как я понимаю в этом случае байтовое содержимое стринга в памяти совершенно другое,
а именно 0х09 "\t"  и 0x31 "1" тоесть суммарно байтовый поток содержимого стринга в памяти выглядит как 0x0931
поэтому эхо выводит другую картинку 
да можно конечно и вот так сделать
    $ echo -e "\t"1
        1
и мы получаем ровно тоже самое на выходе что и в предыдущем примере
однако механизм получения совершенно другой потому что эхо получает на входе поток 0x5C7431
но печатает не его а печатает модифицированный поток 0x0931
тоесть прикол в том что echo  с помощью спец ключа -e модифицирует входной поток. а  в предыдущем примере
поток байтов не модифицируется он тупо печатаются. 


хочу еще кое что показать
вот этот пример который отрабатывает кореектно
    $ a=$'\t \t \n \n 23'
    $ echo "$a"
	 	 
 
            23

так вот если мы обращаемся к переменной вот так "$a"
то у нас все коректно отрабатывает
    $ strace -e execve echo "$a"
    execve("/bin/echo", ["echo", "\t \t \n \n 23"], 0x7ffea8490db8 /* 66 vars */) = 0
        
а если мы убираем двойные кавычки
и обращаемся к переменной без кавычек вот так $a
то баш подставляет в execve уже некорректно
тоесть это именно баш по особому обрабатывает аргументы и подставляет в вызов execve
тоесть это не внешняя команда /bin/echo отрабатывает некоректно это именно бащ его вина
$ strace -e execve echo $a
execve("/bin/echo", ["echo", "23"], 0x7ffc356993e8 /* 66 vars */) = 0

тоесть echo "$a" и echo $a отрабатывает соверщенно по другому.  и это вина не эхо. 
это вина баша который анализирует командную строку и уже запускает эхо с совершенно разным аргументом.
этот момент я буду анализировать отдельно.

я хочу подчеркнуть что хрень $'' нужно использовать именно в таком виде. 
если это заюзать в виде "$''" то это уже неработает
    $ echo "$'\t1'"
    $'\t1'
    $ echo $'\t1'
        1



        

        

| ""
| string
| echo

хочу рассмотреть тонкий момент
и нихуя неописанный

рассмотрю на примере команды /bin/echo , тоесть эта команда не баш билтин
а внешняя по отношению к башу команда

и тут важно во первых вот что сказать вот мы в строке пуляем команду
    $ echo "123" "124"
и это все поступает в баш. он это все обрабатывает. при необходимости модифицирует и потом уже
запускает сисколл execve с параметрами. показываю на примере
в этом примере у нас в командной строке мы ввели \n а баш в execve сует нечто другое n
    $ strace -e execve echo -e \n
    execve("/bin/echo", ["echo", "-e", "n"] ...) = 0
а в этом примере у нас в командной строке мы ввели "\n" и баш в execve сует почти тоже самое "\\n"
    $ strace -e execve echo -e "\n"
    execve("/bin/echo", ["echo", "-e", "\\n"] ...) = 0
поэтому конечный результат другой не из за команды echo а из за того что баш подменяет то что
мы ему в комадной строке записали а он  в echo сует изменную хрень

тоесть важно понять что между тем что мы вбили на клаве и тем как реально будет запущена
внешняя команда с какими параметрами это разные вещи. получается вот такая схема
    мы  вбили в клаве команду  с параметрами ----> bash процесс ---> запуск внешней команды
поэтому то что мы вбили на клаве и как это будет в конечном итоге запущено это не всегда совпдает
из за того что посередине сидит баш который берет то что мы вбили и модифицириует и только потом
запускает внещнюю команду

поэтому чтобы реаьно понять как именно с каким аргументами была запущена таже самая echo 
нужно смотреть через strace

нуладно. двигаем дальше.
берем 
    $ man echo 
там сказано
вот какой у нее формат
    $ echo [SHORT-OPTION]... [STRING]...

я пытался найти как в баше задается стринг. 
но я не могу найти. что такое string? это просто любой набор символов с клавы?
или это набор символов заключенный в кавычки? я не могу найти ответ на этот вопрос
зато в man echo  я читаю вот такое

    If -e is in effect, the following sequences are recognized:
    \n     new line

тогда по идее 
    $ echo -e \n1
должно приводить к тому что \n должно дать перенос строки и потом напечатать символ "1"
однако на практике этого не происходит. а происходит полная хуйня
    $ echo -e \n1
    n1
хотя в man echo как я сказал написано совсем другое. и только если записать вот так
то работает как записано в man echo
    $ echo -e "\n1"

    1

из чего я делаю вывод что понятие STRING в баше это обязательно хрень заключенная в двойные кавычки.
иначе я не могу обьяснить результаты.
а что такое набор символов без кавычек тогда? я не могу найти.

тоже самое касается printf. в его man printf указано что \n должен приводить к новой строке.однако
этого не происходит.
    $ printf \n
    n
и только если мы заключаем эту хрень в кавычки то тогда оно отрабатывает как надо
    $ printf "\n"



тут попутно озвучу что в баш есть так называемые спецсимволы
# 
; 
" 
'
,
\
/
`
:
!
*
?
$
()
{}
[]
[[]]
(())
> &> >& >> < <>
|
>|
-
+
%
~
^
суть их  в том что бащ их по дефолут считает не просто символами печатными а спецсимволами, метасимволами.
(https://tldp.org/LDP/abs/html/escapingsection.html)

так вот я щас пытаюсь связать спецсимволы и кавычки ""
что дают кавычки. во первых я уже показал что только заключение в кавычки дает правильное поведение как 
пропсиано в манах для спецсимволов вида \n \t и тому подобных слеш спецсимволов.
так вот во вторых кавыки экранируют спецсимволы. заставляя баш (именн баш а не внешние команды типа echo) 
воспринимать спецсимволы как просто печатны символы. пример
    $ echo #

    $ echo "#"
    #

    $ strace -e execve echo #
    execve("/bin/echo", ["echo"] ...) = 0

    $ strace -e execve echo "#"
    execve("/bin/echo", ["echo", "#"] ...) = 0
    #

тоесть видно что между клавой и запуском echo сидит баш процесс который анализирует то чтомы вбили 
и в завсимости от того в кавычках или без он совсем разное вставляет в execve в поле аргументов.
тоесть
    вбили echo # --->  бащ процесс принимает и анализирует и видит что # указан без кавычек значит 
    он его рассматривает как спецсимвол и
    поэтому echo запускается вообще без аргументов ---> (execve "/bin/echo", ["echo"]) 

в bash advanced guide (https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html)
написано что все такие не все спецсимволы экранируются через "" 
а именно
    Enclosing characters in double quotes (‘"’) preserves the literal value of all characters 
    within the quotes, with the exception of ‘$’, ‘`’, ‘\’, and, when history expansion 
    is enabled, ‘!’. When the shell is in POSIX mode (see Bash POSIX Mode), the ‘!’ has no special 
    meaning within double quotes, even when history expansion is enabled. The characters ‘$’ 
    and ‘`’ retain their special meaning within double quotes (see Shell Expansions). 
    The backslash retains its special meaning only when followed by one of the 
    following characters: ‘$’, ‘`’, ‘"’, ‘\’, or newline. Within double quotes, backslashes 
    that are followed by one of these characters are removed. Backslashes preceding characters 
    without a special meaning are left unmodified. A double quote may be quoted within 
    double quotes by preceding it with a backslash. If enabled, history expansion will 
    be performed unless an ‘!’ appearing in double quotes is escaped using a backslash. 
    The backslash preceding the ‘!’ is not removed.
    The special parameters ‘*’ and ‘@’ have special meaning when in 
    double quotes (see Shell Parameter Expansion).

тоесть скажем знак $ он в "" не экранируется
поэтому мы можем "раскрывать" переменную внутри ""
пример
    $ let a="1"
    $ echo "$a"
    1


а теперь я покажу еще прикол. о том что я рекомендую не только STRING всегда заключать в кавычки
чтобы не получать приколы непонятные. но я также рекоедую всегда и имя переменной всегда заключать в 
кавычки чтобы не получать необьяснимые приколы. 
пример берем и делаем переменную со спецсимволами
    $ a=$'\t1'
    $ echo $a
    1
    $ echo "$a"
        1
и видно что когда имя переменной указано без кавычек  то получаем хуйню.
а когда в "" то получаем то что надо.

поэтому я бы постулировал что STRING в баше это только хрень заключенная в "" иначе мы будем получать
всякую непонятную хуйню.
и более того в "" нужно заключать и переменные иначе тоже будем получать хуйню.
хотя вот чисто экспериментальным путем я нашел вопреки манам как же заставить скажем echo 
раобтать со спецсимволами вида \n без использования кавычек. ответ такой что нужно вместо \n 
использовать \\n
пример
    $ echo -e \\n1

    1

    
    
| IFS
есть такая спец переменная у баша
она в себе содержит три символа. 
    - символ пробела
    - символ табуляции
    - символ новой строки
тоесть
    $ od -t x1 <<< "$IFS"
    0000000 20 09 0a 0a
где 
    20h  это пробел
    09h  это таббуляция
    0ф   это новая строка

так вот какой физ смысл этой встроенной в баш переменной?
значит баш использует символы в этой переменной для определения какие 
символы являются признаком разделителя так называемых слов.
бащ использует эту переменную только в некоторых специфических случаях.
первый случай это команда 
    $ read -a ARRAY <<< "1 2 3 4"
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
в данном случае символ пробела который есть в "$IFS" был найден в "1 2 3 4" и на основе
пробела этот стринг был разрезан на слова.
следущий пример это когда баш находит в $'1\t2\t3\t4' символ табуляции поэтому он разрезает эту переменную
на отдельные слова
    $ read -a ARRAY <<< $'1\t2\t3\t4'
    $ echo "${ARRAY[1]}"
    2
вот пример когда у нас бащ ненаходит в стринге ни пробела ни табуляции ни новой строки
поэтому стринг не разрезается на слова
    $ read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[1]}"

    $ echo "${ARRAY[0]}"
    1-2-3-4

а вот мы меняем "$IFS" и тогда баш уже находит в стринге символ который указан в IFS
и разрезает стринг на слова
    $ IFS="-";read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
хочу подчеркнуть что IFS срабатывает только в ряде небольшого числа случаев про коорые
надо прям конерктно читать. этих случаев мало. второй случай когда это работает это вот такой случай
далее я показываю ряд случаев причем я не понимаю почему в ряде случаев оно работает 
а в других нет
но разбирать почему я уже не буду
    $ a="1:2:3:4"
    $ for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ for i in "$(echo $a)"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$(echo $a)"; do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo $a); do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo "$a"); do echo "i=$i"; done
    i=1
    i=2
    i=3
    i=4

    
    

| <>
| << >>
| <<< >>>
| < <  > >
| |
| <(command)
| >(command)

<
начнем с "<"
эта штука читает из файла
тоесть справа в конечном итоге должно стоять имя файла
тоесть 
    < имя файла
справа только имя файла. болше там ничего поставить нельзя.
не получится. 
более точно формат выражени выглядит вот так
    $ command < имя файла
тогда ОС начинает сама читать из указанного файла и подавать байты на stdin процесса команды
более расширенный вариант это 
    $ command n< имя файла
где n это файловый дескриптор процесса command 
тоесть ОС сама читает файл и подает его на файловый дескриптор процесса с номер n
получается когда n мы не указваем то это по дефолту дескриптор 0
тоесть
    command < имя файла = command 0< имя файла
итак пример
    $ tr -d -c "1" < /dev/urandom | head -c1; echo ""
    1
значит что он делает ОС читает из файла /dev/urandom и подает эти байты
на stdin команды tr , и это главное. ну а далее детали. tr вырезает из потока все символы кроме
символ "1" и далее и потом из этого потока команда head выбирает один байт. 
последння команда нужна просто чтобы добавить перенос строки.
главное что нужно понять что  < можно употреблять только если у нас есть какойто файл. 
тогда мы его ставим справа то <. если файла нету то < употреблять нельзя невозможно.

    command < file_name

при этом совершенно понятно что сама команда она совершенно необязана читать байты которые 
подсовывает ей ОС. 
пример
    $ sleep 100 < /dev/urandom
тоесть команда sleep абсолютно не будет читать данные из urandom. 
хотя ОС ей на stdin подключает /dev/urandom
    $ ls -a1l /proc/24234/fd
        0 -> /dev/urandom

так тут я поправлюсь < не приводит к тому что сама ОС начинает читать файл. 
ОС лишь подключает /dev/urandom к stdin
а читает либо не читает из stdin уже код самой команды. если в команде  в ее коде нет
сисколлов на чтение то чтения не будет никакого.

аналогично команда 
    > file_name
она только подключает stdout команды процесса к  file_name
а будет писать на stdout команда процесса или не будет это уже зависит от кода команды. 
вот пример
    $ sleep 100 > /dev/urandom
    $ ls -a1l /proc/24395/fd
        1 -> /dev/urandom

и тут я перехожу к команда <<<
в чем ее ОГРОМНАЯ разница с <
а разница в том что справа от <<< должен стоять STRING
а справа от < должен стоять имя файла
и поэтому они применяются в совершенно разных ситациях
пример
    $ bc <<< "2*3"     <---- STRING
    6          
    
    $ head -c 1 < /dev/urandom   <---- файл
    k

как говорится заметь разницу
тоесть 
    command < file
делает то что на stdin процесса команды привязывается файл
а
    command <<< "STRING"
делает то что на stdin процесса команды подается то что находится в STRING
значит как я понял на подкорке это работает так что ОС создает сама файл в /tmp 
пишет туда сама "STRING" а потом когда этот файл прочитывает команда то ОС 
этот файл удаляет
    $ sleep 120 <<< "TEST"
    $ ls -1al /proc/24710/fd
    0 -> '/tmp/sh-thd.MNxZor (deleted)'
единсвтенное я не понял почему ОС удалила файл для команды sleep ведь она не читает 
свой stdin
вот еще способ проверки
    $ ls -l /proc/self/fd/ <<< "TEST"
    1 vasya vasya 64 дек  2 07:39 0 -> '/tmp/sh-thd.Olh22p (deleted)'
таким образом я сам для себя выяснил в каком случае есть смысл
использовать < а в каком случае использовать <<<
теперт это понятно. и понятно что использовать их можно только в совершенно
разных случаях.

получается что 
        command <<< "STRING"
это полный аналог команды
        echo "STRING" | command
ну типа получается что вариант с <<< он якобы более наглядный
ПРИЧЕМ важно еще заметить что <<< добавляет к исходному стрингу знак новой строки.
тоесть
    $ od -t x1 <<< "1"
    0000000 31 0a
тоесть в команду od влетает не просто байт 0x31 а еще и доблавляется символ новой строки 0x0a
таким образом полный аналог команды
            command <<< "STRING"
это именно команда
        echo "STRING" | command
но НЕ команда
        echo -n "STRING" | command
таким образом если нам важно не добавляеть к стрингу символ новой строки то нам 
нельзя пользоваться <<< а если мы нам похеру то можно.
вот еще раз я показыают какой байтовый поток вылезает из разных команд
    $ od -t x1 <<< "1"
0000000 31 0a
    $ echo "1" | od -t x1
0000000 31 0a
    $ echo -n "1" | od -t x1
0000000 31

вот еще на этих приерах видно когда одно и тоже получаем
а когда нет
    $ md5sum <<< "1"
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo "1" | md5sum
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo -n "1" | md5sum
    c4ca4238a0b923820dcc509a6f75849b  -



далее насколько я понимаю что >>> такой команды нет. 
потому что писать из stdout в "STRING" это бред
    $ echo "123" >>> "qwe"
    bash: syntax error near unexpected token `>'

далее >>
    command >> file
это аналог 
    command > file
с той разницей что в верхнем случае к концу файла добавляются данные
а во втором случае содержимое файла полностью удаляется и данные начинают
писаться в начало файла

далее <<
    command << file
как я понимаю такой команды нет


далее |
    command1 | command2
возникает вопрос в чем разница между > и |
можно ли как то через > заменить |
значит пайп приводит к тому что stdout первой команды
и stdin второй команды смотрят на один и тот же буфер в ядре. 
    stdout1 > буфер ядра > stdin2
тоесть никакой файл на диске не создается а используется буфер в ядре
так вот если command2 уже запущена то можно найти ее stdin на диске например  /proc/4444/stdin
и далее можно вот так извратиться
    command1 > /proc/4444/stdin
но повторюсь что для этого команда 2 уже должны быть запущена. а если она не запущена
то хрен ты так сделаешь. 
пайп позволяет отдать процесс увязки stdout1 stdin2 башу. 
в целом я бы сказал что > и < оно в целом предназначено чтобы читать и писать на реальные физ файлы
на диске либо спец файлы на /dev тоесть это более менее статичекие файлы причем никак не связанные 
с файлами процессов на /proc
пайп же предназначен для увязки между файлами на /proc которые там создает ядро для процессов.


далее <(command)
    command1 <(command2)
эта хрень называется bash process substitution
и она  не имеет отношения к 
    command < file
хотя вроде как немного на нее похоже
визуально можно заметить быстро разницу всегда из того что если это bash process substitution
то рядом с ним всегда стоит скобка
    <(...
а если это обычный файл редирекшн то между < и file всегда стоит пробел
    < file
у меня есть отдельная статья в этом же файле про bash process substitution.
здесь же краткое описание что как это работает
    command1 <(command2)
баш запускает command2 потом делает симлинк его stdout в файл /dev/fd/X
и подставляет в исходную команду имя этого файла
    command1 /dev/fd/X
еще раз имя файла подставляется как аргумент команды  command1
пример
    $ echo <(echo "1")
    /dev/fd/63

таким макаром конструкция 
    command1 <(command2)
имеет смысл если команда1 умеет читать из файла если ей указать имя файла как аргумент.
например тако умеет делать команда cat
    $ cat <(echo "123")
    123
и если мы хотим чтобы у нас stdout от одной команды был прочитан другой командой при условии что первая 
команда умеет читать из файла если он указан у нее как аргумент
обратная команда
    command1 >(command2)
пример
    $ cp /dev/urandom >(tr -cd "[:digit:]" | head -c10 | cat -)
    2054370200
как работает. запускается tr и его stdin через симлинк протаскивается в некий файл /dev/fd/X
и этот файл подставляется вот так 
    $ cp /dev/urandom /dev/fd/X
и cp копируется байты из urandom на stdin команды tr 
ну а дальше tr выбирает из потока только цифры. потом head берет первыех 10 цифр ну а cat их печатает.
теперь когда мы знаем что вместо 
    <(command)
    >(command)
подставляется как аргумент строки имя файла вида /dev/fd/X
будет понятен смысл вот такой конструкции
    $ wc -w < <(echo "a b c d")
    4
значит что это за загадочные < <
значит <(echo "a b c d") это bash process substitutution
а wc -w < это файл редиреккшн
если мы вспомним что в результатие bash pricess sustitution в исходную команду подставлется вот 
такая хрень /dev/fd/X то мы получаем 
    $ wc -w < /dev/fd/X
и теперь совершенно легко видно что оставшийся < это классический файл редирекшн.
справа стоит некое имя файла. а слева команда
конечно в данном примере можно было и не городить огород а сделать проще
    $ echo "a b c d" | wc -w
    4
но так возможно потому что wc такая команда она может работать как с stdin так и с файлами 
указанными ей в командной строке в качестве аргумента. другие команды не такие универсальные


напоследок разберу еше вот эти примеры

       $ cat <<< 1.bash
          1.bash
здесь понятно 1.bash воспринимается как стринг вида "1.bash"
тоесть просто набор литер

        $ cat < 1.bash
          #!/bin/bash
          ...
здесь получается что на stdin от cat привязан к файлу 1.bash
и cat читает из stdin тоесть в коненом итоге из файла 1.bash

        
        $ a="123"
        $ cat < "$a"
          bash: 123: No such file or directory
здесь понятно что  на фс нет файла с именем "123"

        $ cat <<< "$a"
          123
здесь тоже понятно что на stdin от cat привязан временный файл который содержит в себе "123"
котоырй ос создает сама в /tmp папке и поэтому cat читает из stdin по факту читает из /tmp/X
и рисует его содержимое 122


        $ cat < $(echo 123)
        bash: $(echo 123): No such file or directory
эта команда читает из файл с именем справа от >
результатом $(echo 123) будет 123 тоесть полный аналог команды это 
        $ cat < 123
но файла 123 на фс нет. поэтому пошел нахер


        $ cat <<< $(echo 123)
            123
аналог этой команды это 
        $ cat <<< "123"
эта команда позволяет засунуть стринг стоящий справа на stdin команды слева поэтому
такой резултат

        $ cat <$(echo 123)
комбинация <$(echo 123) это не bash process substituition потому что <$
результатом $(echo 123) будет 123 поэтому аналог это 
        $ cat <123
ее аналог это 
        $ cat < 123
но файл 123 на фс нет
а когда такой файл есть то все сработает
    $ echo "aa" > 123
    $ cat <$(echo "123")
    aa
тоесть в этом примере ловушка в том что вроде спервого взгляда кажетс что команда
    $ cat <$(echo 123)
это команда
    $ cat <(echo 123)
которая является bash process substitutuiion
но это не так потому что есть еще $

кстати я вверху писал что при файл редиреккшн между < и именем файла обязателно стоит пробел . вобще
то это не обязательно. 
и так и так верно
    command < file
    commadn <file
просто если это bash proces substittiuition то после < обязателно стоит (
    command <(command2)
и это его отлличает от файл редирекшн




| ascii

    $ man ascii

схема такая в устройство "терминал" поступает поток байтов. каждый байт
терминалом транслируется либо в печатный символ. либо это непечатный символа а управляющий
для терминала.

скажем 0x61 байт терминалом транслируется в печатный символ "a"
а байт 0x0a приводит к тому что терминал прокручивает картинку на 1 строку вверх и переводит печатную
головку в начало строки тоесть в самое лево и при этом конечно ничего не печатает. 
поэтому 0x61 это байт которые отвечает за печатный символ а 0x0a это байт который отвечает за
управление терминалом.

так вот среди них есть два таких байта
0x0E  (shift out) SO
0x0F  (shift in)  SI

что это за хрень. как пишект виикипедия из того что я понял был такой телетайп Model 38
это типа принтера матричного. и  у него было несколко лент разных цветом так вот эти байты
они переключали с черной ленты на красную ленту. 

дальше как я понял когда появились видимо более продвинутые матрчиные принтеры в котоорые как я понял
можно было загружаьт в память как бы доп символы например символы руского языка. то 
посылка байта SO приводила к тому что принтер начинал печатать рускими символами а SI печать латинскиими.

потом с появлением терминала VT100 это приводило к переключению символов на символы псевдографики.
тоесть скажем SO переключал на симолы псевдографиики а SI возвраащал обратно символы ascii.

в текущем окне терминала линукса посылание на терминал этих символов нихрена ни к чему не приводит.
наверное потому что по факту щас терминал работает на UTF-8 а не на ascii и тому подобное









## bash advanced scripting guide
    (https://tldp.org/LDP/abs/html/special-chars.html)


    
|как преобразовать число из двоичного или 16ричного вида в 10ый
    $ echo $(( 2#101011 ))
    43
    $ echo $(( 16#A ))
    10


    
    
    
|разделитель команд 
    ;
они пишут что после него надо обязательно ставить пробел





|шелл билтин .
что тоже самое source
эта хрень приводит к тому что скрипт выполняется в данном процессе. а не в новом.
обычно эта хрень делается чтобы в текущем процессе баша изменить или добавить переменные



|переенная "$PWD" содержит в себе текущую папку


|:
|встроенный билтин :
по факту он не делает нихрена
код возврата 0

: > file
уменьшает размер файла до нуля
даже если файл открыт 

: >> file
неделает нихрена если файл уже есть


: может использоваться как имя фукции но это нерекомендвано


|?
интересный пример использования ?
если $var1<98 то var0=9
иначе var0=21
охренеть
    $ (( var0 = var1<98?9:21 ))
правда непонятно зачем эта галиматься с (()) если все можно сделать без них

кстати
    $ echo $((var0=1))
    1

более простой пример. но для начала вот что
    (( 0 )) && echo "True \$?=$?" || echo "False \$?=$?"
    False $?=1

    $ (( 21 )) && echo "True \$?=$?" || echo "False \$?=$?"
    True $?=0

Итак если   (( 0 )) то False , 1
если        (( 21 )) то True , 0



так вот пример попроще
если 100 меньше 98 то тогда 0 иначе 21
в итоге получаем внутри скобки 21 
поскольку внутри скобки неноль то код возврата true тоесть 0
    $ (( 100<98?0:21 )); echo $?
    0

внутри скобки 0 значит код вовзрата false тоесть 1
    $ (( 1<98?0:21 )); echo $?
    1

далее
    $ echo $(( 1<98?0:21 )); echo $?
    0
    0
    $ echo $(( 100<98?0:21 )); echo $?
    21
    0
видно что можно распечатать содержимое скобки
код возврата всегда ноль потому что мы используем echo
а не просто голые скобки

еще раз наопмню что просто скобки они на stdout ничего не возвращают
но они возвращают код возврата в $?
а чтобы возвратить то что внутри скобок тогда надо 
    $ echo $(( 21 ))
    21

|$*
|$@

эти переменные почти одно и тоже.
показывает все аргументы скормленные скрипту

переменная $* берет все аргументы собирает их в одну переменную. тоесть
если

    $ ./03.bash 1 2 3 
то 
    $*="1 2 3"
то есть еще раз все отдельные аргументы будут собраны в одну переменную

а переменная $@ она собирает все аргументы в массив поэтому их можно 
потом выцепить по отдельности.
пример
    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done

запускаю
    $ ./03.bash  1 2 3
    $*=1 2 3
    $@=1 2 3

    $@[1]=1
    $@[2]=2
    $@[3]=3

    $*[1 2 3]=1 2 3

из чего видно что $@ это массив а $* это просто переменная в которой все аргументы собраны в одну кучу


| **
возведение в степень
    $ echo "$(( 2**3 ))"
    8




|$$

эта переменная показывает pid процесса скрипта

|()
эта хрень называется субшелл
пока мало ясно что это. 
как я понял все команды которые стоят внутри скобок запускаются в отдельном процессе

$ a="123"; echo "$a"; ( a="321"; echo $a); echo $a
123
321
123

как я понял основной смысл в скриптах использовать субшелл
это то что все переменные субшеллла никак не влияют на переменные основного шелла.
тоесть субшелл это чтото типа функции наверно.хотя возможо функция может 
влиять на глобальные переменные скрипта.

еще с помощью () обявляют массив
    $ a=( 1 2 3 )
    $ echo $a
    1
    $ echo ${a[*]}
    1 2 3


|{x,y,z}
фигурные скобки внутри которых 
элементы через запятые.
как я понял эта хрень работать так
если поставить символ скажем a до {
и поставить символ скажем b после }
то все хрени перечисленные внутри {}
будут обрамлены в ab.
пример
    $ echo \"{1,2,3}\"
    "1" "2" "3"
    $ echo a{1,2,3}b
    a1b a2b a3b

тоесть 1 2 3 перечислены внутри {}
а снаружи скобок стоят a и b
поэтому 1 2 3 обрамлены ими

также сказано что элемент внутри {}
перечиаляются через запятую и нельзя
между ними ставить пробел

    $ echo file.{txt,log}
    file.txt file.log

далее
не знаю что за правило но можно делать "вложенные" скобки
    $ echo {"a:","b:"}{"1","2"}
    a:1 a:2 b:1 b:2


    $ echo {"a:","b:"}{"1","2"}{"+","-"}
    a:1+ a:1- a:2+ a:2- b:1+ b:1- b:2+ b:2-

|{a..z}

    $ echo {a..z}
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    $ echo {1..10}
    1 2 3 4 5 6 7 8 9 10

| {; ; ; }
эта хрень на мой взгляд в основном нужна только для того чтобы 
для красивости обьединить команды в один красиво выглядищий кусок.
при этом никаких реальных дейтсвий эта команда не делает.
    $ { printf "1"; printf "2"; printf "3\n"; } 
    123
    $  printf "1"; printf "2"; printf "3\n"; 
    123
не вижу никакой разницы
важно после последней команды в скобках поставить тоже ; иначе пошлет нахер

без скобок я даже не знаю как вот такое сделать
    $ { printf "1+"; printf "2+"; printf "3\n"; } | bc
    6
максимум могу вот так
    $ printf "1+"; printf "2+"; printf "3\n" | tr "3" "c"
    1+2+c
в книжке написано что {} создает безымянную функцию. в отличие 
от обычной функции если мы внутри функкции определяем переменную
такую же как и в главном теле то то будет переопределена функция в главном теле.
тоесть безымянная функция может переопределять глобалные переменные
    $ a="1"; { a="2"; }; echo $a
    2

вот еще интересный пример
    $ { tr -cd [:digit:] | head -c 1 ; echo ""; tr -cd [:digit:] | head -c 1; echo ""; } < /dev/urandom 
    4
    8
    
эта штука работает так - запускается первая команда из скобки, пусть это внешняя команда, тоесть создается новый процесс.
и к его файл дескриптор 0 ядро подключает /dev/urandom. далее это уже забота самой команды либо читать из stdin 
или нет. как только первая команда отработала , то запускается вторая команда из скобки и ядро снова подключает к  stdin 
уже этого процесса файл /dev/urandom и так пока все команды из скобок не закончат свою работу

я бы сказал что эти скобки работают ровно как скобки из математики. тоесть берем математику
    ( 2+3 ) *5
раскрываем скобки
    2*5 + 3*5

тоесть ос когда работает с предыдущим примером она делает ровно вот так
    $ tr -cd [:digit:] < /dev/urandom | head -c 1 
    $ echo ""< /dev/urandom
    $ tr -cd [:digit:] < /dev/urandom| head -c 1 
    $ echo "" < /dev/urandom  

тоесть еще раз говорю что каждой команде внутри скобок подсовывается то что находится вне скобки.
что касается данного конкретного случая то далеко некаждая команда по своей сути читает из stdin
поэтому на какие то команды влияет это подключение а на другие нет

правда как этот пример переработать в эквивалент хрен знает
    $ { printf "1+"; printf "2+"; printf "3\n"; }  | bc
    6

мне кажется что проще всего понимать работу скобок так что скобка 
имеет некую единую stdin и stdout 
поэтому скажем вначале полностью отрабатывают все команды из скобки. они скажем
все срут на stdout и только потом все что было высрано командами внутри скобки
единым куском выплевывается во вне.
поэтому на bc поступает сразу единый кусок от всех трех printf

я даже в книжке нашел такое же описание

{



}  > 1.test # Redirects output of everything in block to file


также книжка дает еще один пример когда юзается {}
а именно {} используется  в команде xargs. {} в ней используется для подстановки
аргументов 
    $ ls -1 | xargs -I{}  echo "файл = {}"
    файл = 03.bash
    файл = 04.bash

    
также {} используется чтобы обозначать тело функции


| &>
эта хрень редиректит 1 и 2 в filename
    $ command &>filename 

эта хрень редиректит 1 в 2
    $ command >&2 


| >

примеры на счет использования >
    $ [[ "ab" > "cd" ]]; echo $?
    1
насколько я понимаю сравннеие идет следущим образом
берется байтовый поток обоих операндов и сравнивается как hex число
скажем ab=0x6162  cd=0x6364
вот эти два числа и сравниваются. какое больше то и победило

| pipe
берем такой код
    variable="initial_value"
    echo "new_value" | read variable
    echo "variable = $variable"     # variable = initial_value

первая команда в текущем процессе-1 задает variable="initial vaue"
вторая команда запускает дочений процесс-2 от процесса-1 для команды read variable. тоесть
    процесс-1 ===> процесс-2
вдочерний процесс-2 конечно клонируются
перменные из родительского процесса. поэтому картина такая 
    процесс-1 variable=initial_value
    процесс-2 variable=initial_value

так будет на моммент создания процесса-2
но далее эти перменные незавиисимы.

вторая строчка приведет к тому что в процесс-2 прилетит на stdin значение new_value в переменную variable
значит имеем
    процесс-1 variable=initial_value
    процесс-2 variable=new_value


третья строчка создает процесс-3 дочерний от процесс-1. клонируя при этом переенные. поэтому третья строчка напечатает что 
    variable=initial_value

насколько я понял если мы пишем в пайп и при этом есть проблема то в процесс которы пишет будет вернут
сигнал SIGPIPE (https://www.gnu.org/software/libc/manual/html_node/Operation-Error-Signals.html)

| >|

это force redirection.
через настрйоки баша можно задать что редирект неработает если файл уже сушествует.
так вот эта настройка преодолевает ту настройку
по умолчанию редирект в файл который уже существует разрешен . так что эта хрень
никогда не пригождается

| &

эта хрень позволяет раотать с джобами. по факту это баш создает дочерний процесс 
но не ждет пока тот выполнится сам ожидая в тени а после создания дочереннго процесса
обратно возврашает контроль на теоминалом себе. детали я не помню. конкретно данная хрень &
говорит о том что нужно поменстить прооцесс в бекграуд режим
пример
он создает два цикла. один выполняется в бекграуденде а второй в фореграунде
тоесть мы получаем в скрипте два параллельно работающих куска
что забавно
$ for i in {1..10}; do echo $i;sleep 3; done & for i in {11..20}; do echo $i; sleep 3; done
[1] 16570
11
1
12
2
3
13
14
4
5
15
16
6
17
7
18
8
19
9
20
10



| &&
это логический AND

правада иногда логический AND задется по другому
    if [ "$c" -eq 24 -a "$d" -eq 47 ]
    then #    ^              ^
    echo "$c equals 24 and $d equals 47."
    fi


| --
в командах опции задаются либо через - либо через --
зависит от самой команды

написано что в бащ билтинах эта хрень ообозначает конец области где задаются опции
не  в билтинах так не сработает

вобщем лучше набрать 
    $ man команда
    $ type команда
    
и посмотеть что там написано про --

| -

 
прикол с echo и -
    $ a="-n"
    $ echo "$a"
не выводит ничего. 

| ~+

это аналог $pwd

| ~-
это штука показывает предудущий рабочий каталог


| Ctrl
кнопки управления терминалом

Ctrl+A   перейти вначало строки
Ctrl+E   перейти в конец строки
Ctrl+B   стрелка влево
Ctrl+H   backspace
Ctrl+J   Enter
Ctrl+M   Enter
Ctrl+P   стрелка вверх
Ctrl+R   вылезает меню поиска предыдудущих команд по первой букве
Ctrl+S   продолжает принимать кнопки  с клавы но в термтинал их не передает
         то есть нажатия не теряюься но на терминал ничего не прилетает
Ctrl+Q   отменяет предыдущее. при этом мы увидим на экране все кнопки которые мы нажали 
         во время блока. 
Ctrl+T   меняет местами последние два введенных символа
Ctrl+U   если у нас курсор стоит посреди строки то удаляет все что левее курсора
Ctrl+W   тоже самое что предыдущее
Ctrl+Z   как я понял текущий процесс суется в бекграунд и там ставится на паузу


в мануале сказано что 
    a="^H" 
это аналог Ctrl+H 
но это полная хуйня. 
    $ echo "^H"
    ^H

| { }

я нашел замечательное примерение {}
если у меня есть какойто скрипт то чтобы его легко вбить надо всего навсего 

$ {

далее Ctrl-V скрипт 
и потом

}

и вуаля


| read
интеерсный билтин

    $ read -n10  -p '$$\>'
    $$\>
    
ключ -n дает то что символ поступают в read мгновенно а не как это есть по дефолту когда 
ожиается ввод Enter. -n 10 говорит о том что надо считать 10 символов и комарда закончит свою работу

ключ -p говорит о том что нужно на экране рисовать PROMPT тот который указан после -p в данном случае это "$$\>'
есть еще ключ -s который делает то что когда мы жмем кнопки на клаве то символы на экране не отображаются. да они улетают
в read но на экране не отображаются.

| col
как работает эта хуйня. ее ман это писаи ебанаты. в инете примеров норм нет. итак

$ echo $'\n\n\n\n  111 \v 222 \v 333 \v 444'   | col

		 444
	    333
       222
  111


значит по факту \n = \f+\r
тоесть прокркутка листа на строку вверх и вовзарат пеатной головки в самое левое положение.
\v это по идее верт и табуляция но по факту в линукс терминале это \f то есть прокрутка листа на 1 строку вверх
тоесть текс уехзжает вниз

так вот команда col она интерптиурет \v как прокрутка на 1 строку вверх а не вниз.
тоесть печатная головка поднимается наверх.
поэтому верхняя команда имеет расшифроку: опустись на 4 строки вниз и держи пеачатну гловку слева. напечаатай 111
потом подними головку на 1 строкувверх и напечаатй 222 потом подними печ головку вверх и напечаатй 333 потом поднимм
печ головку вверх и напечатай 444
тоесть таким макаром мы можем печатать текс не сверху вниз а снизу вверх.

единтвенная хуйня состоит  втом что перед тем как подниматься наверх надо обязательно опуститься вниз иначе выдаст segmentation fault
    $ echo $'\v 111'   | col
    Segmentation fault
тоесть мы еще не прокуртили лист вниз а уже пробуем поднимать головку на верх. так нихуя не работает. 
мы вначале должны опустить лист через \n (прикол что \f не подходит) и толко потом поднимать головку вверх
    $ echo $'\n \v 111'   | col
    111

тгда можно вот такое сделать

$ echo $'\n\n\n  111 \v 222 \v 333 \v 444 \n\t\t\t 555 \n\t\t\t\t 666 \n\t\t\t\t\t  777 \v 888'   | col
		 444
	    333 	 555
       222			 666	       888
  111					  777


прикол еще в том что col не понимает "\f" а жаль


| variable

оказывается что $a это сокращенная от ${a}

когда ициализируем переменную то нельзя иметь пробел слева от =
    $ a ="1"
иначе баш пытается выполнить команду a с параметром ="1"

оказется что запись
    $ a=
означает что a приварнивается значение NULL
я пока непонял эквивалетно ли это с
    $ a=""

по крайней мере
    $ a=
    $ echo -n ${a} | od -t x1
    
    $ a=""
    $ echo -n ${a} | od -t x1

на выходе байтовый поток один и тот же

оказывается можно инциализиоовать несколько переменных в одной строке через пробел

    $ a=1 b=2
    
если мы инициализируем переменную не испольуя кавычки то например "пробел"
надо экранировать

    $ a=1\ 2\ 3
    $ echo ${a}
    1 2 3

попытка напечатаать необьявленную  переменную выдаст null на выходе то есть пусто

обявление переменной это когда вот так
    $ a=
инициализациия переменной это когда мы обявляем переменную и задаем переменной значение
    $ a="1"

в любом случае резуллтат один и тот же в этих ообоих случаях
    $ echo "$b"
    $ a=
    $ echo "$a"
на выходе будет ничего
первый случай это когда переменная необьявлена
второй случай когда переменная обьявлена но неинициализирована

также оказвается что можно инициализированную переменную сделать обратно неинициализиованной
тоесть

    $ a="1"
    $ unset a
    $ echo "$a"

    
неиницализировнная перменная неимеет никаого значения а не ноль.

далее
в арифметических операциях если мы ссылаемся на необьявленную переменную то в таком случае
ее значение принимется равным нулю. это едиснчтенный случай когда необявленная переменная 
автоматом принимает значение прчием нулевое.

    $ unset a
    $ echo $a

    $ b=5
    $ echo $(( $a + $b ))
    5

далее.
опять же получается что когда мы иницализиуем переменную то нельзя чтобы ни слева ни српава от = стоял пробел.
иначе баш думает что мы ему дали команду с двумя аргуменатми

    $ a = 1
    a: command not found


переменную можно задать черещ то что ввести ее с клавы

    $ read  -p '> введите переменную и нажмите Enter > ' a; echo "a=$a"
    > введите переменную и нажмите Enter > 1
    a=1

еще переменную можно иницализиоовать вот так
    $$ a=`ls `
либо
    $ a=$(ls)

по сути они делают одно итоже. вторая команда это более новый синтаксис.
отличаются ли они внутри по реализации хрен знает


далее
наприсано что переменные у баша не имеют типов. а точнее они имеют один тип "character type"
но все равно можно желать например арифметические операции но для этого надо чтобы переменная содеражала только цифры
как я понял обработка переменных идет в завиисимости от контектса. то есть мы как бы обьясняем бащу как ему трактовать
переменную.

далее 
вот эта констурукция ${a/find/replace} ищет в переменной "$a" в любом ее места паттерн и меняет его на заданный
как толко находится паттерн то дальнйший поиск прекрашается
    $ a="#23#23"
    $ b=${a/23/45}
    $ echo "$b"
    #45#23

отличие ${a/find/replace} от ${a#find}  в том что второй всего навсего стирает заданный паттерн. причем только если 
паттерн стоит в самом начале переенной. также ${a%find} эта хрень удаляет строго с конца переенной кусок
    $ b="45#23"
    $ echo ${b#4}
    5#23
    $ echo ${b%3}
    45#2

тут параллельно вылезает такая хрень как билтин declare
например она позволяет задать свойство переменной такой что при ее дальнейше инициализации ее буквы.
я бы сказал что declare нам позволяет обьясниить башу какие значения может принимать переенная.
и тогда если мы будем давать этой переменной неправильные значения то баш будет нас посылать нахер
и преобразовывать наши неверные значения в некоторое более менее подходящее которое мы заказали
через decalre
пример declare -l огранчиывает значения только   lower case. если вводим upper case то они будут
автомтом сконвертрровны в lower case.
    $ a="AAAA"
    $ declare -l a
    $ echo "$a"
    AAAA
    $ a="BBBB"
    $ echo "$a"
    bbbb

видно что если переменная уже иницализиована и мы запускаем decalre то это никак не влияет на уже сущевтующее
значение AAAA.
а вот последующая инициализация уже проходит как надо и BBBB автоконвертиится в bbbb

а вот еще пример
declare -i огранииввает переменную только числами.
    $ declare -i b
    $ b="1"
    $ echo "$b"
    1
    $ b="a23"
    $ echo "$b"
    0

видно что когда мы задали значение переменной в форме запрещенной хрени "a23" то 
баш послал нас нахер и сконвертировал значение в 0. видимо дефолтовое значение если вводят хрень.
таким макаром ябы сказал что decalare это некий аналог типа переменных плюс автоконвертер.

кстати 
    $ declare ..
и
    $ typeset ..
это одно и тоже.

далее
declare -p позволяет посмотреть свойства переменной.

    $ declare -p  ab
    bash: declare: ab: not found

    $ ab=
    $ declare -p  ab
    declare -- ab=""

    $ ab=""
    $ declare -p  ab
    declare -- ab=""

насколко я поня из эксперимента что -- означает что на переменную не наложено никаких 
ограничений на значения. это значит что переменная была определена и иницаилизирована 
без использования declare

а вот другой пример на эту тему. 
мы определяем переменную через declare

    $ declare -i ab
    $ ab="123"
    $ declare -p ab
    declare -i ab="123"


можно посмотреть свойства встроенных системных в баш переменных

    $ declare -p IFS
    declare -- IFS=" 	
    "

    $ declare -p HOME
    declare -x HOME="/home/vasya"

едиснвтенрное я непонял смысл ключа -x = to make NAMEs export


все  полезные ключи declare
      -p	display the attributes and value of each NAME
      -i	to make NAMEs have the `integer' attribute
      -l	to convert NAMEs to lower case on assignment
      -r	to make NAMEs readonly
      -u	to convert NAMEs to upper case on assignment
      -x	to make NAMEs export


получается ключ -r позволяет задать константу
    $ unset a
    $ a="1"
    $ declare -r a
    $ echo "$a"
    1
    $ a="3"
    bash: a: readonly variable


в книжке я нашел стремный пример (https://tldp.org/LDP/abs/html/untyped.html)

    a=2334                   # Integer.
    let "a += 1"
    echo "a = $a "           # a = 2335
    echo                     # Integer, still.

    b=${a/23/BB}             # Substitute "BB" for "23".
                             # This transforms $b into a string.
    echo "b = $b"            # b = BB35
    declare -i b             # Declaring it an integer doesn't help.
    echo "b = $b"            # b = BB35


значит что этот пример делает. он беерет 2234 и сует их в $a
потом увеличиывает $a на 1 получаем 2235
потом мы берем 2235 и меняем на BB35 и присваиваем это b
итак b="BB35"
далее заупскается команда "declare -i b" и они печатают после этого $b и видят
что b=BB35 и пишут в коментацриях что мол декларе не помог превратить стринговую переменную в интеджер.
сука блядь. ну конечно же не помог. но декларе в этом не виноват. потому что как я писал выше декларе
АБСОЛЮТНО НЕ ВЛИЯЕТ на значение переменной которое уже есть. декларе влияет только на значение переменной
которое задается после применения декларе тоесть

показываю
    ...
    $ unset b
    $ b="BB35"
    $ echo $b
    BB35
    $ declare -i b
    $ echo $b
    BB35
    $ b="234"
    $ echo $b
    234
    $ b="BB234"
    $ echo $b
    0


далее. выше я писал что если переменная заобявлена или ее значение на иницализировано
и мы делаем арифемтечичекую оперцию с этой перепменной то баш ее значение в этом единственном
случае автоматом считает равным 0.
так вот эта же хрень имеет место если у нас переменная содержит символы.

    $ unset b
    $ b="BB35"
    $ echo $(( $b + 5 ))
    5

далее
если мы делим на переменную которое не обьявлена то 

    $ echo $((  5 / $abc ))
    bash: 5 /  : syntax error: operand expected (error token is "/  ")

а если мы делаим на переменную которая имеет символы в значении то по факту мы делим на 0

    $ echo $((  5 / $b ))
    bash: 5 / BB35 : division by 0 (error token is "BB35 ")
 
суммарно в плане declare я хочу сказать что польза от нее в том что если 
мы точно знаем что переменная должна принимать только числовые значения то можно 
это задать через declare хотя поведение при этом мне мало нравится. если бы
после этого при попытке присвоить пеерменной символы бащ выдавал ошибку
это было бы круто. а то что он втихаря корнвертирует стринг в 0 
неуверен что это поможет дебажить скрипт.
что касается автоковнертации стрингов в ловер кейс или аппер кейс помоему 
это вообще слабая хрень ненужная никогда или очень редко

кстати
    $ seq 10
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

кстати 
  eval это билтин баша который вот что делает "Execute arguments as a shell command."
тоесть если вставим аргумент в eval то этот аргумент будет выполнен как команда баша.
пример

    $ eval "ls -1"
    -
    03.bash
    04.bash
    05.bash
    10.bash
    11.txt


теперь беру такой пример
    $ seq 10 | sed -e 's/.*/export var&=1/'
    export var1=1
    export var2=1
    export var3=1
    export var4=1
    export var5=1
    export var6=1
    export var7=1
    export var8=1
    export var9=1
    export var10=1


тоесть seq создает числа от 1 по 10. и эта цифра подставляется вместо & в export var&=1
далее если мы это заключим в eval как аргумент тот этот код будет выполен в баше
пример

    $ seq 10 | sed -e 's/.*/echo "number = &";/' 
    echo "number = 1";
    echo "number = 2";
    echo "number = 3";
    echo "number = 4";
    echo "number = 5";
    echo "number = 6";
    echo "number = 7";
    echo "number = 8";
    echo "number = 9";
    echo "number = 10";

    $ eval $( seq 10 | sed -e 's/.*/echo "number = &";/' )
    number = 1
    number = 2
    number = 3
    number = 4
    number = 5
    number = 6
    number = 7
    number = 8
    number = 9
    number = 10


далее 
 переменные окружения передаются от родительского процесса его дочерним.
в обратную сторону связи нет. от дочери родителю ничего из переменных не передается.


далее
команда basename. она берет полный путь к файлу как аргумент. и возвращает только конечный файл
    $ basename '/home/vasya/temp/\!9/debug.bash'
    debug.bash
кстати надо заметить что хотя я использовал '' для указания пути но знак ! все равно нужно 
экранировать , так как иначе вместо !9 баш подставляет туда команду из баш хистори.

кстати 
можно сделать переменную как readonly нетолько через decalre но и через 
другой билтин readonly
во первых этот билтин может показать за один раз все переменные которые 
имеют свойства readonly

    $ readonly -p 
    declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote"
    declare -ir BASHPID
    declare -ar BASH_REMATCH=()
    declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
    declare -ir EUID="1000"
    declare -ir PPID="26695"
    declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor"
    declare -ir UID="1000"
    declare -r a="1"
    declare -r abc


как сделать переменную read only
    $ readonly abc
для сравнения через decalre это делается так
    $ declare -r abc

так вот далее я нашел такую шокирующую инфо о том что если мы переменную обьявили как константу (рид онли)
то обратно ее превратить в обычную переменную = нельзя никак. все что можно это убить этот процесс баша.
ничего сделать нельзя другого.но есть вот какой выход. мы можем запустить в данном баше
еще один баш. дочерний баш унаследует все переменые из родителя. но при этом переменная наша уже не будет
иметь статуса рид онли. пример

    $ readonly abc
    $ unset abc
    пошел нахер
    $ bash
    $ unset abc
    сукксесс
    

далее 
 -n $var  проверяет что длинна переменной НЕноль. если длина НЕноль то код возврата $?=0 (success)
пример
    $ a="123"; [ -n "$a" ] && echo "переменная \$a непустая"
    переменная $a непустая


далее
рассмотрим такой скрипт
    $ cat 06.bash 
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 

смотрим результаты работы
    $ ./06.bash 
    Parameter #1 отсуствует
    $ ./06.bash 1
    Parameter #1 is 1
    $ ./06.bash "1"
    Parameter #1 is 1
    $ ./06.bash ""1""
    Parameter #1 is 1
    $ ./06.bash "\"1\""
    Parameter #1 is "1"

что примечательно. если мы вызываем скрипт с аргументом который выглядит как 1 либо "1" либо ""1"" то он 
прилетает внутрь скрипта как 1.  
а если мы хотим чтобы внутри скрипта прилетел именно "1" то аргумент нужно в командной строке задавать как "\"1\""
удивительно.

далее. прикол
для того чтобы работать с аргументом 10,11 итд то нужно к ним обращаться внутри скрипта не как $10 или $11
а ${10) , ${11}
об этом написано в книжке

    $ cat 06.bash   
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 


    if [ -n "${10}" ]              
    then
        echo "Parameter #10 is ${10}"  
    else 
        echo "Parameter #10 отсуствует"
    fi 

работа скрипта
    $ ./06.bash 1 2 3 4 5 6 7 8 9 a
    Parameter #1 is 1
    Parameter #10 is a


далее
скрипт
скрипт берет путь к скрипту. удаляет из него весь путь кроме названия файла.
и потом к нему добавляет ./

    #!/bin/bash
    echo "путь к скрипту ./$(basename "$0")"

запускаем скрипт
    $ ./06.bash 
    путь к скрипту ./06.bash

далеее
еще раз напомню про $@ и $*
первая сохраняет все аргументы скрипта в массив.
а вторая собирает все аргументы в единую переменную

    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done


запускаю скрипт
    $ ./03.bash 1 2 3 4 5 6 7 8 9 a
    $*=1 2 3 4 5 6 7 8 9 a
    $@=1 2 3 4 5 6 7 8 9 a

    $@[1]=1
    $@[2]=2
    $@[3]=3
    $@[4]=4
    $@[5]=5
    $@[6]=6
    $@[7]=7
    $@[8]=8
    $@[9]=9
    $@[a]=a

    $*[1 2 3 4 5 6 7 8 9 a]=1 2 3 4 5 6 7 8 9 a

что интеерсно. что индексы в массиве начинаются с единицы походу. а не с нуля.

далее
 -lt 
означает less than. арифм сравнение
    $ a="12"; [ "$a"  -lt 100 ] && echo "\$a меньше чем 100"
    >>$a меньше чем 100

далее
на счет []
согласно man bash это одно и тоже
    $ test expr
    $ [ expr ]
    
также в баше есть билтин '['
но также есть и внешняя команда /usr/bin/[
так вот баш запускает именно внешнюю команду

$ strace [ 10 -lt  1 ]
execve("/usr/bin/[", ["[", "10", "-lt", "1", "]"], 0x7ffdd5429b60 /* 66 vars */) = 0

тоесть запускается файл  "/usr/bin/[" а дальше к этой команде присобачиваются аргументы. причем обязательно последним
аргументом нужно указать "]" иначе программа пошлет нахер/

получается первая скобка это название файла. далее идут аргументы. и последняя скобка это тоже аргумент.

что странно если я набираю 
    $ man [
он мне выдает man от команды /usr/bin/test
хотя /usr/bin/[ и /usr/bin/test это два разных файла

    $ stat /usr/bin/[
        File: /usr/bin/[
        Size: 51384     	Blocks: 104        IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23330837    Links: 1

    $ stat /usr/bin/test
        File: /usr/bin/test
        Size: 47288     	Blocks: 96         IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23332131    Links: 1

видно что иноды разные

хотя еще как я уже сказал и есть башевский билтин [

    $   builtin [ 10 -lt  1 ]


кстти выискивать что значат все эти -lt -n -d и прочие штуки для сравнения проще не в man bash а в 
    $ man test

| !

возвращаюсь к вопрому который уже освещал.
как в переменной укзать имя другой переменной и потом докопаться до этой второй переменной из первой переменной
а вот как
    $ a="1"
    $ b=a
    $ echo ${!b}
    1

замечу что именно ${!b} а вот так не работает ${!$b}

теперь если вернкемся к спец перееменным которые ест при вызове скрипта. то там есть спецпеременая $#
соовествнно ее имя # 
эта переменная укзаывает на число аргументов с которыми запущен скрипт. напоминаю что $0 это имя скрипта $1 первый аргумент
соовесвтенно $n это n-ый аргумент. получается если аргуметов 10 то $#=10 и значит эта же переменная показыает на две хрени 
сразу и на число переенных и на номер последней переменной. еще раp $# указывает на порядковый номер последней переменной 
но естевственно не содержит значение этой последней переменной. и чтобы посмотреть ее содержимое надо вот так 
    $ echo ${!#}
теперь имеем скрипт
он работает так
мы проверяем что число аргументов скрипта больше чем 0
если это так то мы печатаем содержимое переменной имя которой хранится в переменной с именем # тоесть ${!#}
потому что если аргументов 10 то $#=10 а нам нужно добраться до ${10}
    $ cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo "число аргументов 0"

запускаем его
    $ ./07.bash 
    число аргументов 0

    $ ./07.bash a b c 
    последний аргумент =  c

    $ ./07.bash 1 2 3 4 5  a b c d e f
    последний аргумент =  f


хочу заметить что если скрипт запущен без аргументов  то у него все равно всегда есть один аргумент $0 который
содержит имя скрипта. точнее путь к скрипту.

я модицфиуировал скрипт

    $  cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo -e "число аргументов 0,\nоднако \$0=\"$0\""

теперь запускаю скрипт без аргументов
    $ ./07.bash
    число аргументов 0,
    однако $0="./07.bash"

далее рассматривается интересная вещь.
вот у нас есть переменная
    $ a="123"
мы хотим создать новую перемнную которая будет в себе содержать "$a" + "_"
как это сделать. первая попытка
    $ b="$a_"
    $ echo $b

однако на выходе пусто. почему. потмоу что баш ищет переменную с именем a_ которой конечно нет.
а как нам тогда обьяснить то что мы хотим. а вот как
    $ b="$a"_
    $ echo $b
    123_

вот еще похожий пример
    $ read -p '>>' var1; echo "var1=$var1"; var2="$var1"_; echo "var2=$var2"; var3="${var2%_}"; echo "var3=$var3"
    >>890
    var1=890
    var2=890_
    var3=890

мы считываем переменную из клавы. потом добавляем "_" потом его отрезаем обратно.

до этого обсуждалась проверка вида -n $a которая проверяет что длинна стринга ненулевая.
есть обратная проверка которая проверяет что длинна стринга нулевая -z $a

    $ a="" && [ -z "$a" ] && echo "переменная пустая"
    переменная пустая
    

еще пример на созвучную тему

    $ cat 08.bash 
    #!/bin/bash

    if [  -z "$1" ] 
    then
        echo -e "ERROR: аргумент отсутствует \nUsage: $0 arg1 "
        exit 1
    else
        echo "аргумент = $1"
    fi

запускаю скрипт
    $ ./08.bash 
    ERROR: аргумент отсутствует 
    Usage: ./08.bash arg1 

    $ ./08.bash  "1a"
    аргумент = 1a

    
| ${var:-default}

эта хрень позволяет задать дефолтовое значение если значение переменной $var незадано или равно пусто
что вобщем то одно и тоже

    $ a="1"; b="${a:-33}"; echo "$b"
    1
    $ a=""; b="${a:-33}"; echo "$b" 
    33

эта хрень поможет в скрипте. если мы не хотим проверять был ли введен аргумент $1 или нет.
тогда нам поможет эта констркция.

    $ cat 09.bash 
    #!/bin/bash

    disk="${1:-sda}"
    echo "диск = $disk"

запускаю скрипт
если мы не указываем при запуске аргумент 
то баш подставляет в переменную дефолтовое предопределенное значение
    $ ./09.bash  sdb
    диск = sdb

    $ ./09.bash 
    диск = sda


| case


    case EXPRESSION in

    PATTERN_1)
        STATEMENTS
        ;;

    PATTERN_2)
        STATEMENTS
        ;;

    PATTERN_N)
        STATEMENTS
        ;;

    *)
        STATEMENTS
        ;;
    esac

кстати последння хрень это если не будет найдено ни одно значение.
а вот пример case когда он в одну строчку

    $ { case "b" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    b
    $ { case "z" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    не найдено


далее
пример
скрипт проверяет наличие аргумента при вызове скрипта.
и печатает этот аргумент
далее проверяется под каким именем файла был запущен скрипт.
если имя файла 10.bash или 11.bash то печатается имя скрипта

сам скрипт имеет имя 10.bash
также надо создать симлинк 11.bash 

    $ ln -s ./10.bash ./11.bash

    $ cat 10.bash 
    #!/bin/bash

    E_NOARGS=75

    if [ -z "$1" ]
    then
        echo  "Error: NO_ARGS"
        echo  "Usage: $(basename $0) [ARG]"
        exit $E_NOARGS
    else
        echo "аргумент = $1"
    fi



    case "$(basename "$0")" in

        "10.bash")
            echo "скрипт запущен как  10.bash"
            ;;

        "11.bash")
            echo "скрипт запущен как 11.bash"
            ;;

        *)
            echo "неопознанная ошибка"
        exit 1
            ;;
        esac



запускаю скрипт
    $ ./10.bash    
    Error: NO_ARGS
    Usage: 10.bash [ARG]

    $ ./11.bash    
    Error: NO_ARGS
    Usage: 11.bash [ARG]

    $ ./10.bash    123
    аргумент = 123
    скрипт запущен как  10.bash

    $ ./11.bash  234  
    аргумент = 234
    скрипт запущен как 11.bash



| shift

как уже было сказано выше он сдвигает аргументы которые были указаны при вызове скрипта
тоесть второй аргумент присваивается первому 
    $2 ---> $1
третий аргумент присвивается второму
    $3 ---> $2
единственное что $0 остатеся неизменным. это логично


напомню что shift может сдвигать нетолько на 1 аргумент влево но и на другое число
    $ shift N
по факту эта команда делает вот что. она берет и сжирает первые N аргументов. 
щас покажу

    $ cat 12.bash 
    #!/bin/bash

    until [ -z "$1" ]
    do
        echo "\$@=$@"
        shift 8 || break
    done

запускаю скрипт
    $ ./12.bash  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
        $@=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
        $@=9 10 11 12 13 14 15 16 17 18 19 20
        $@=17 18 19 20

тоесть мы имеем N=8 значит на первом этапе сжираются аргументы 1-8
было 
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
стало
                    9 10 11 12 13 14 15 16 17 18 19 20

далее на следущем шаге опять сжираются 8 первых арументов
было 
    9 10 11 12 13 14 15 16 17 18 19 20
стало
                            17 18 19 20


далее что происходит если shift хочет сожрать 8 аргументов а нужного числа арунментов нету
как в случае 

    17 18 19 20

так вот происходит то что шифт останавливается. нихрена неделает. и выдает $?=1

я бы сказал что более удобно рассматривать что shift не сдвигает аргументы. а сжирает аргументы.
тоогда все понятно.
единственно что помним что аргумент $0 этой командной не трогается.

| $0
если  мы запустили скрипт то в $0 содержится путь к файлу скрипта.
а если мы запустили echo $0 из командной строки то оно показвыает bash

    $ echo $0
    bash


| []
следущий пример выбирает файлы
которые начинаются либо с "0" либо с "1"

    $ ls -1 [01]*
    03.bash
    04.bash
    05.bash
    06.bash
    07.bash
    08.bash
    09.bash
    10.bash
    11.bash
    11.txt
    '12 13'
    123
    12.bash
    1.bash


    
    
    
    
| ""
| ''


тема quoting в баще

квоутинг делает то что ряд спецсимволов перестает быть спецсимволом и становится
только печатным символом. но бывают команды которые все равно плюют на квоутинг
и продолжают воспринимать спецсимволы
пример

    $ grep '[Vv]' t*.txt
    t1.txt:vasya
    t2.txt:Vasya

    
    
| command

это билтин
делает он то что запускает команду. спрашивется нахуй тогда он нужен.
а нужен он затем что если у нас в скрипте есть функция с именем таким же как команда 
то command позволяет запустить не функцию а именно команду.
работает хрень вот так
    $ $ command ls -1
    03.bash
    04.bash
в целом вобщем то бесполезный билтин


| \


знак \ позволяет экранировать спецсимволы внутри ""
в итоге если мы будем экранировать не спецсимвол то напечаатется и слэш и простой символ
пример
    $ echo "\a"
    \a

если мы экранируем спецсимвол то сам слэш исчезает . будет напечатан только спецсимвол как
просто символ
прмиеры
    $ echo "\\"
    \

    $ echo "\$"
    $

    $ var2="\\\\\""
    $ echo "$var2"
    \\"

чтобы избежать непонятных непоняток я рекомендую всегда все переменные заклчать в ""
иначе результаты будут часто непредсказуемые.


вот это подьебочный пример

    $ echo "$(echo '"')"           # "
    "

хрень  состоит из двух частей
    "$(echo '"')"   +      # "   
которое можно схематично представить как 
    "..."  +    #"
    
что можно представит схематично как
    $ echo "..."     +   # "
из чего наконец можно понять что мы получим на выходе то что у нас есть команда echo и справа от нее просто
напросто стоит комментарий (который начинается с символа #).
поэтому комментарий можно свободно выкинуть ибо он ни на что не влияет тогда получаем
    $ echo "..." = $ echo "$(echo '"')" = $ echo """ => на выходе будет "
проверяем
    $ echo "$(echo '"')"           # "
    "
совпало.
пример было пиздец
еще пример пиздец
    $ var1="Two bits"
    $ echo "\$var1 = "$var1""
    $var1 = Two bits
насколко я понимаю эта хрень работает так. он берет кавычку и ищет ближайшую кавычку справа.тогда
    echo "\$var1 = "$var1"" = echo "\$var1 = "    +  $var1  +  ""
тоесть у echo стоит три аргумента
    "\$var1 = "
    $var1
    ""
первый и третий аргумент заключены в кавыки а второй нет. 
печать первого аргумента даст
    $var1 = 
печать второго даст
    Two bits
печать третьего даст пусто . в итоге на экране будет
    $var1 = Two bits
что мы и имеем на практике

вот несколько изменный тот же пример где 
я подсветил каждый из трех аргументов
    $ echo ">\$var1 = <"       $var1        "><"
    >$var1 = < Two bits ><


| "

внутри двойных кавычек можно без проблем печатать одинарные кавычки
пример
    $ echo " '   "
    '   
    $ echo " ' '  "
    ' '  
никаких проблем
как и в этом прмиере
    $ echo "Why can't I breath 's between single quotes"
    Why can't I breath 's between single quotes


    
    
    
| '
одиночная кавычка якобы блокирует все спецсимволы. кроме символа '
если мы хотим напечатать ' внутри '' то  не получится
пример
    $ echo '''
    > 
тоесть этот пример это аналог 
    $ echo ''   '
тоесть у нас есть одна пара закрытых кавычек и есть одна пара незакрытых кавычек
поэтому пошел нахер говорит баш

| \

приколнно что это будет напечатано в две строки
    $ echo "This will print
        as two lines."

потому что когда мы тыкаем Enter мы "печатаем" символ Enter

    $ echo "a
    > b"
    a
    b

    $ echo "a
    b" | od -t x1
    61 0a 62 0a

и так как \ стоящипод кавычками оотключает значение спецсисмволов то он отключает и значение спецсимвола 0x0a 
    $ echo "a\
    > b"
    ab

    $ echo "a\
    b" | od -t x1
    61 62 0a

    
опять же повторюсь что если слеш стоит не перед спец символом то он не исчезнет а будет напечатан
    $ echo "\a"
    \a
а если он стоит перед спецсимволом то он не будет напечатан
    $ echo "\$"
    $


еще момент. если эхо запущен без -e то слэш только экранирует спецсимволы
    $ echo "\t1"
    \t1
а если эхо с клюючом  -e то комбинация слэша с некоторыми обычными символами
рассматривается как спецсимвол. например \t это горизональная табуляция
пизздец ебанизм и заморочка
    $ echo -e "\t1"
            1
            
            
тоесть зацени разницу
одна и таже команадна с одним и итем же аргументом но 
без ключае -e и с ключом -e
    $ echo  "\t\t\t\t1"
    \t\t\t\t1
    
    $ echo  -e "\t\t\t\t1"
                    1

            
кстати если юзать $'....' то ключ -e и ненужен
    $ echo   $'\t\t\t\t1'
                    1

замечу что одинарные кавычки ' внутри "" абсолютно леагальны. и их ненужно эакраинировать
    $ echo "Introducing the \$\' ... \' string-expansion construct . . . "
    Introducing the $\' ... \' string-expansion construct . . . 

    $ echo "Introducing the \$' ... ' string-expansion construct . . . "
    Introducing the $' ... ' string-expansion construct . . . 

еще интереный пример
    $ echo "1   $'\n\n' 2"
    1   $'\n\n' 2

тоесть $'' неработает внутри ""
тоесть нужно $'' вынести за ""
пример
    $ echo "1   " $'\n\n'"  2"
    1    

        2
            
здесь у нас три аргумента под эхо
    "1   "
    $'\n\n'
    "  2"

вот еще пример о том что $'' неработает если находится внутри ""
    $ echo  $'\n\n1'


    1
    
    $ echo  "$'\n\n1'"
    $'\n\n1'


| clear
внешняя команда.
очищает окно терминала

| read

если мы не указали в какую переменную или переменные считывать данные то по дефолту 
данные считываются в переменную $REPLY

с помощью read можно узнать какой байт или байты влетают в комп
при нажатии той или иной кнопки. в том числе и спец кнопки типа ESC, DEL, BACKSPACE, ENTER

    $ clear; read -s  -p '>>нажмите кнопку и нажмите Enter>>'; \
      echo ""; echo -n "код кнопки "; od -t x1 <<< "$REPLY" |  head -n1 | cut -c 8- | rev | cut -c 3- | rev

      >>нажмите кнопку и нажмите Enter>>
     код кнопки  1b 5b 32 7e
 
 
оказывается что простецкие кнопки типа "a" "b" посылают всего один байт.
например если тыкнуть кнопку "a" то получим

    >>нажмите кнопку и нажмите Enter>>
    код кнопки  61 

еще ксатати кнопка ESC посылает тоже только 1 байт

    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 
    
а вот если мы жмем спецкнопки типа DEL,  ENTER, Pg_Up
то эти кнопки посылают за нажатие сразу несколько байтов

DEL:
    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 5b 33 7e
    
    
Pg_UP:
    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 5b 35 7e

чтобы кнопку Enter отсканировать то надо сменить скрипт
    $ clear; read -n4 -s  -p '>>нажмите кнопку>>';       echo ""; echo -n "код кнопки "; od -t x1 <<< "$REPLY" | cut -c 8-
    >>нажмите кнопку>>
    код кнопки  0a


    
как отсканировать кнопку BAckspace непонятно. ладно двинем дальше.

далее мы хотим считывать с клавы кнопки которые высирают от одного байта 
по четыре байта. тоесть число байтов разное. потому что нажатие на одну кнопку 
приводит к тому что клава высирает в ос один байт. а нажатие на другую кнопку
привод к тому что ос высирает в ос четыре байта. или три байта.
и чтобы это можно сделать без нажатия на Enter после нажатия на кнопку.
положим мы нажимаем на кнопку которая высирает 4 байта за раз. типа кнопка Insert
    $ read -s -n1 a; read -s -n2 b; read -s -n1 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 32 7e
вот мы получили код этой кнопки
тоесть клава срет 4 байта, первая команда read считывает первый байт,
вторая команда считывает следущий два байта,
третья команда считывает последний четвертый байт

кстати я тут нашел одну хрень нужно заменить -n на -N 
потому что если юзать -n то read в этом случае игнорирует влетающие 
байты которые совпадают с тем что указано в IFS.
в IFS у нас в частности есть байт пробела . поэтому если мы 
будем нажимать пробел то read его будет игнорировать и ждать
дальше прилета друогого байта а если юзать -N то если в read
влетает байт соотвествующий пробелму то он его радостно
всасывает
поэтому

    $ read -s -N1 a; read -s -N2 b; read -s -N1 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-


но тут проблема получается если у нас пуляется c клавы один байт
тогда у нас срабаыватет первый read. управление передается второму read. но так как
байт всего один с клавы то вторая команда будет висеть вечно! поэтому нам надо 
для второй и третьей команды установить тайм аут. чтобы они отваливались если тайм аут достингнут.
кстати поправка- как я понял кнопка на клаве порождает либо один байт либо три либо четыре. 
вроде как два байта породить кнопка не может. поэтому второй read это два байта читает. тогда делаю
поправку  я во второй и третий read вставляю таймаут после которого команда заканчвает свою работу

    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-


тогда нажимаю "SPACE":
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    20

нажимаю INSERT:
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 32 7e

нажимаю "стрелка направо":
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 41






далее скрипт из интернета:
работает он так
инициализируется переменная 
    key="кнопка не нажата"
на экране печатается баннер
потом печатается на экране содержимое переменной $key  
    You pressed: \'"$key"\'
далее система ожидает поступления одного байта
причем ждет она этого бесконечно
    read -s -N1 -p "Press a key: "
если мы нажали кнопку то там еще тогда отрабатывает два read
причем там уже нет бесконечного ожидания поступления байтов.
наоборот там есть таймаут для ввода
    read -s -N2 -t 0.001
    read -s -N1 -t 0.001

справшивается нахуя такая сложная схема
почему нельзя заменить эти три рида одним. 
это сделано из за того что после нажатия кнопки
в ос прилетает разное количество байтов. 
от 1-го байта до 4-ех байтов
поэтому если мы заменим все одной командой которая 
читает 4 байта
    read -s -N4 -p "Press a key: "
то при нажатии кнопки которая выдает один байт
то эта команда будет ждать поступления оставшихся трех байтов.
а их то не будет. или надо будет нажать кнопку четыре раза.
а это нам не подходит.
можно конечно сделать по другому. можно убрать из read описание 
сколько байт нужно считать и заменить это тем что надо нажать кнопку
а потом нажать кнопку Enter 
но в том то и прикол что мы нехотим после нажатия кнопки нажимать еще и Enter
мы хотим обойтись без Enter
тогда работает такая схема
    read -s -N1 -p "Press a key: "
    K1="$REPLY"
    read -s -N2 -t 0.001
    K2="$REPLY"
    read -s -N1 -t 0.001
    K3="$REPLY"

первая команда ждет поступления одного байта с клавы
пока байт непоступит команда ждет. ждет бесконечно.
далее следущая команда уже неждет бесконечно. она ждет всего навсего t=0.001c
и ждет с клавы два байта. и последняя команда ждет t=0.001с ждет поступления 
один байт.
это дает то что если мы нажали кнопку и клава на это высирает в ос всего один байт то 
K1="байт"
а K2=""
K3=""
если же после нажатия кнопки с клавы летит 4 байта. то 
тогда будет
    K1="байт"
    K2="два байта"
    K3="байт"
таким макаром эта схема позволяет ловить с клавы от один,
три, четыре байта. и при этом ненадо нажимать Enter после
нажатия кнопки. после этого переопределяется 
переменная $key
    key="$K1$K2$K3"
далее перезапускется цикл while,
очищается экран через clear
печатается баннер.
анализируется $key и он печатается тоже.
далее появляется первая команда read 
который ждет первый байт. причем ждет бесконечно
    read -s -N1 -p "Press a key: "
и пока кнопка не нажата этот read будет 
ждат бесконечно  и экран не будет стираться через clear 
поэтому. тоесть clear срабатывает только после 
того как нажата кнопка. 
как только кнопка нажата то цикл идет на новый цикл


>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<
$ cat 13.bash 
#!/bin/bash


key="кнопка не нажата"

while true; do
  clear
  echo "Bash Extra Keys Demo. Keys to try:"
  echo
  echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
  echo "* The four arrow keys"
  echo "* Tab, enter, escape, and space key"
  echo "* The letter and number keys, etc."
  echo
  echo "    d = show date/time"
  echo "    q = quit"
  echo "================================"
  echo





 case "$key" in
  $'\x1b\x5b\x32\x7e')  # Insert
   echo You pressed: \'Insert Key\'
  ;;
  $'\x1b\x5b\x33\x7e')  # Delete
   echo You pressed: \'Delete Key\'

  ;;
  $'\x1b\x5b\x48')  # Home_key_num_7
   echo You pressed: \'Home Key\'

  ;;
  $'\x1b\x5b\x46')  # End_key_num_1
   echo You pressed: \'End Key\'

  ;;
  $'\x1b\x5b\x35\x7e')  # Page_Up
   echo You pressed: \'Page_Up Key\'

  ;;
  $'\x1b\x5b\x36\x7e')  # Page_Down
   echo You pressed: \'Page_Down Key\'

  ;;
  $'\x1b\x5b\x41')  # Up_arrow
   echo You pressed: \'Up Key\'

  ;;
  $'\x1b\x5b\x42')  # Down_arrow
   echo You pressed: \'Down Key\'

  ;;
  $'\x1b\x5b\x43')  # Right_arrow
   echo You pressed: \'Right Key\'

  ;;
  $'\x1b\x5b\x44')  # Left_arrow
   echo You pressed: \'Left Key\'

  ;;
  $'\x09')  # Tab
   echo You pressed: \'Tab Key\'

  ;;
  $'\x0a')  # Enter
   echo You pressed: \'Enter Key\'

  ;;
  $'\x1b')  # Escape
   echo You pressed: \'Escape Key\'

  ;;
  $'\x20')  # Space
   echo You pressed: \'Space Key\'

  ;;
  d)
   date

  ;;
  q)
  echo Time to quit...
  echo
  exit 0

  ;;
  *)
   echo You pressed: \'"$key"\'

  ;;
 esac

 echo
 echo "================================"

 unset K1 K2 K3
 read -s -N1 -p "Press a key: "
 K1="$REPLY"
 read -s -N2 -t 0.001
 K2="$REPLY"
 read -s -N1 -t 0.001
 K3="$REPLY"
 key="$K1$K2$K3"

done

exit $?

>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<


запуск скрипта
    $ ./13.bash

Bash Extra Keys Demo. Keys to try:

* Insert, Delete, Home, End, Page_Up and Page_Down
* The four arrow keys
* Tab, enter, escape, and space key
* The letter and number keys, etc.

    d = show date/time
    q = quit
================================

You pressed: 'Escape Key'

================================
Press a key: 




| echo
| \

далее еще раз коснусь темы
в этом примере работает такая логика.
если слэш под двойными кавычками и за ним стоит обычный символ
то баш печатает слэщ
    $ echo "\a"
    \a

если под двойными кавычками за слэшем стоит спец символ ( а слэш внутри двойных кавычек это есть спецсимвол)
то слэш не печатается а спецсимвол теряет свою спецсимвольность и печатеся как простой символ
поэтому один слэш исчезает а второй печатается
    $ echo "\\a"
    \a

еще момент. 

    $ a="\\"
    $ echo "$a"
    \

    
далее
я теперь малек понял почему если мы в командной строке баща ввоим команду потом вводим \ 
потом тыкаем Enter и у нас ввод команды продолжается. потому что слэш экранировал последующее нажатие Enter.

| |
| pipe

если мы в командной строке стоит пайп "|" и жмем Enter
то слэш вводить ненадо. автоматом баш ждет от нас продолжения ввода.

    $ echo "1" | 
    > 
    
| exit code

код возврата из дочернего процесса поступает в родительский процесс.

если в скрипте  в явном виде в конце не указана команда exit $код_возврата
либо указана команда exit но без кода возврата 
то код возврата берется из статуса выполнения последней команды в скрипте

и еще в одном случае 
 exit $?
в этом случае тоже код возврата будет браться из кода из предыдудщей команды
потому что понятно почму. потому что $? это всегда код возврата предыдудущей
отработавшей команды

код возврата может быть в диапазоне 0-255

| !
если мы перед командой поставим "!" 
то код возврата $? будет инвертирован.
нахрен это надо незнаю.

    $ echo "1" 1>/dev/null; echo $?
    0
    $ ! echo "1" 1>/dev/null; echo $?
    1


| test constructs

конструкции которые могут проверять условия чего нибудь

1) if then

2) [ (левая скобка /usr/bin/[) 
у баша есть одноименный билтин
также есть аналогичная внешняя команда /usr/bin/test 
при этом это аналог а не хардлинк\симлинк не [

3) [[...]]]
это типа более продвинутая версия [..]

4) ((...)) , let 
вроде как это одно и тоже

насколько я понял из книжки if then это не команда баша это его keyword.
keyword это составная часть команды.
[[...]] книжка тоже утвржлает что это тоже keyword
так я не могу понять как if then или [[...]] могут быть кейвордами
если они могут самостоятельно применяться. это же команды получается!


примеры
    $ (( 1 + 2 )); echo $?
    0
    $ let "n=1+2"; echo $?
    0
    $ (( 0 + 0 )); echo $?
    1
    $ let "n=0+0"; echo $?
    1

отсюда книжка пишет что код возврата у ((...)) и let "..." один и тот же

кстати 
    $ i=0;
    $ (( i+=2 ))
    $ echo "$i"
    2

кстати 
внешняя команда cmp сравнивает два файла
    $ cmp file1 file2

далее if она принимает любую команду в качестве условия потому что 
if анализирует только код возврата
пример

    $ if { echo "123" | head -c 1 &>/dev/null; }; then echo "success"; else echo "fail"; fi
    success
тоесть как видно мы в качестве условия вставили портянку { echo "123" | head -c 1 &>/dev/null; }
ифу все равно какая длинна портянки. if смотрит только код возврата. если $?=0 то выполняется then
а если $?=1 то выполняется else. вот и все

еще пример
    $ if { grep -q "bash" 03.bash; }; then echo "success"; else echo "fail"; fi
    success

еще пример
    $ if { echo "123" | grep -q "2";  }; then echo "цифра 2 найдена"; else echo " цифра 2 ненайдена"; fi
    цифра 2 найдена


кстати
    $ [ 0 ]; echo $?
    0
    $ [ 100 ]; echo $?
    0
    $ [ 1 ]; echo $?
    0
    $ [ -1 ]; echo $?
    0
    $ [  ]; echo $?
    1

из чего видно что [ число ] скобка подходит только если мы хотим 
протетисровать что число под скобкой НЕ NULL
    
тоже самое со стрингами
    $ [ "abc" ]; echo $?
    0
    $ [ "123" ]; echo $?
    0   
    $ [ "$drt" ]; echo $?
    1
только если стринг NULL  мы получаем false

можно это все проверять в более явной мере
    $ [ -z "$abc" ]  #  true если длина стринга 0
    $ [ -n "$abc" ]  #  true если длина стринга неноль


вот такая форма if then это хуйня
потому что в ней в качестве команду указана команда [
фишка  в том как  я уже сказал что в if может стоять любой клубок команд
ифу похуй на это. он анализирует лишь код возврата $? от этого клубка команд
    if [ condition-true ]
    then
        command 1
        command 2
        ...
    else  # Or else ...
      # Adds default code block executing if original condition tests false.
        command 3
        command 4
        ...
fi


более верная форма 
    if { command1; command2; command2}
    then
        ...
    else
        ...
    fi

кстати помимов else есть еще elif
пример
    $ if [ 1 -gt 2 ]; then echo "1>2"; elif [ 3 -gt 4 ]; then echo "3>4"; else echo "все не так"; fi
    все не так

в книжке написано что /usr/bin/[ вызывает по факту /usr/bin/test

по поводу [[...]] книжка пишет => No filename expansion or word splitting takes place between [[ and ]], 
but there is parameter expansion and command substitution.
Using the [[ ... ]] test construct, rather than [ ... ] can prevent many logic errors in scripts.
For example, the &&, ||, <, and > operators work within a [[ ]] test, despite giving an error within a [ ] construct

тоесть как я понял предпочитительнее использовать [[...]] а не [...]

кстати что интетесно в команде echo ( man echo ) напиано что можно в аргумент прописать сразу байт а не символ.
только дискриминация в том что байт можно прописать либо в OCT виде либо в HEX виде. а в десятичном нельзя.
почему непонятно. пример
    # ascii 141oct 97dec 61dec
    $ echo $'\141'
    a
    $ echo $'\x61'
    a
а 97dec никак не прописать в качестве аргумента


кстати нашел в man bash
 Quoting  is used to remove the special meaning of certain characters or words to the shell.  Quoting can be used to disable special treatment for special charac‐
       ters, to prevent reserved words from being recognized as such, and to prevent parameter expansion.

       Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell and must be quoted if it is to represent itself.

       When the command history expansion facilities are being used (see HISTORY EXPANSION below), the history expansion character, usually !, must be quoted to prevent
       history expansion.

       There are three quoting mechanisms: the escape character, single quotes, and double quotes.

       A  non-quoted  backslash  (\) is the escape character.  It preserves the literal value of the next character that follows, with the exception of <newline>.  If a
       \<newline> pair appears, and the backslash is not itself quoted, the \<newline> is treated as a line continuation (that is, it is removed from the  input  stream
       and effectively ignored).

       Enclosing  characters in single quotes preserves the literal value of each character within the quotes.  A single quote may not occur between single quotes, even
       when preceded by a backslash.

       Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of $, `, \, and, when history expansion
       is enabled, !.  When the shell is in posix mode, the ! has no special meaning within double quotes, even when history expansion is enabled.  The characters $ and
       ` retain their special meaning within double quotes.  The backslash retains its special meaning only when followed by one of the following characters: $,  `,  ",
       \,  or <newline>.  A double quote may be quoted within double quotes by preceding it with a backslash.  If enabled, history expansion will be performed unless an
       !  appearing in double quotes is escaped using a backslash.  The backslash preceding the !  is not removed.

       The special parameters * and @ have special meaning when in double quotes (see PARAMETERS below).

    
там же нашел
 A  double-quoted string preceded by a dollar sign ($"string") will cause the string to be translated according to the current locale.  If the current locale is C
or POSIX, the dollar sign is ignored.  If the string is translated and replaced, the replacement is double-quoted
пример
    $ a="1"
    $ echo $"a"
    a
что лишний раз подтверждает что надо весь стринг всегда заклюать в кавычки либо будешь 
получать непредсткадуемый результат
скажем в этом примере все понятно
    $ echo "$"a""
    $a
мы имеем три аргумента
    "$"
    a
    ""
поэтому в итоге будет напечатан $+a+пусто = $a
что мы и видим

кстати еще раз хочу вернуться к $'...'
 Words of the form $'string' are treated specially.  The word expands to string, with backslash-escaped characters replaced as specified by the ANSI  C  standard.
       Backslash escape sequences, if present, are decoded as follows:
              \a     alert (bell)
              \b     backspace
              \e
              \E     an escape character
              \f     form feed
              \n     new line
              \r     carriage return
              \t     horizontal tab
              \v     vertical tab
              \\     backslash
              \'     single quote
              \"     double quote
              \?     question mark
              \nnn   the eight-bit character whose value is the octal value nnn (one to three digits)
              \xHH   the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
              \uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
              \UHHHHHHHH
                     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)
              \cx    a control-x character

       The expanded result is single-quoted, as if the dollar sign had not been present.

особенно меня прикололо  "\cx    a control-x character" это чтото новенькое
я проверил. внатуре так и работает

Ctrl+R:
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    12
    $ echo -n $'\cr'| od -t x1
    0000000 12

ладно так вот $'..'
в итоге эта хрень работает так - знак $ отбрасывается. оставляются '' а то что внутри транслируется в 
соотвствие с приведенной таблицей учитывая спецсимволы.

так вот я перехожу  к главному меня интересующему вопросу - какой формат в баше
чтобы задать данные не в виде печатных симоволов которые баш потом по факту конвертирует
в байты а чтобы сразу указать в форме байтов. например в hex формате.
и тут получается тонкий момент. во первых в баше нельзя в общем то задать стринг 
сам по себе. он обычно входит в состав команды. а команда транслирует стринг в своем
индивидуальном порядке. а нам надо чтобы без трансляции. чтоб как есть. переменную
же задать можно. безотносительно команды которая будет ее обрабатывать. с переменной проще в этом плане.
но еще отсается задача как потом посмотреть содержимое переменной так чтобы команда 
не транслировала ее контент во чтото другое.
в итоге я пришел вот к чему
вот как я смотрю истинное содержимое голого стринга в байтовом виде
    $ od -t x1 <<< "a"
    0000000 61 0a
единственное что это добавялет лишний 0a на конце. поэтому его надо мысленно отбросить
итак видно что стриг "a" по факту в байтовом виде это 0x61  ( очевидно что этот байт ссоветсвет таблице ascii )
еще пример
    $ od -t x1 <<< "\x61"
    0000000 5c 78 36 31 0a
отбрасываем 0a и у нас остается 5c 78 36 31 это и есть байтовое содержимое нашего стринга,
смотрим в таблицу ascii и узнаем что 0x5с="\"  0x78="x"  0x36="6" 0x31="1"
итак совершенно очевидно что стринг  в формате "\x61" непредставляет собой ничего кроме прямого набора литер которые
его составляют
еще один пример
    $ od -t x1 <<< "0x61"
    0000000 30 78 36 31 0a
тут тоже видно что байтовое содержимое стринга это просто набор литер входящих в его состав
теперь применяем вот такое
    $ od -t x1 <<< $'\x61'
    0000000 61 0a
и тут мы видим принициапильно дуругую ситуацию. байтовое содержимое стринга это не набор литер а это ровно такое же байтовое 
содержание как указано в теле стринга. 

таким образом я постулирую что если мы хотим задать в стринге под двойными кавычками "...." стринг прям в форме байта 
то это нихрена не сделать. стринг можно задать в форме байта только через $'\xNN'

тоже самое касается задать переменную ( а все переменные у баща это стринги только имеющие имя ) то если мы хотим
задать переменную в форме байта то это можно сделать только одним способом 
    a=$'\xNN'
через 
    a="..." это никак не сделать.
пример
    $ a=$'\x31'
    $ od -t x1 <<< "$a"
    0000000 31 0a
видно что я записал в теле 31 и получил 31 уже в форме байтового потока
а вот показано то что байтовый поток переменной отличается от ее формального описания
    $ a="1"
    $ od -t x1 <<< "$a"
    0000000 31 0a


далее еще тонкий момент. вот мы разобрались как нам в перменую или в стринг засунуть нужный нам байтовый поток.
но когда команда получает через аргумент стринг или переенную то она по своему может обрабатывать этот байтовый поток.
но тут я думаю вот что. баш прежде чем запустить команду считывает переменную из памяти  в форме байтового потока
и подставляет этот байтовый поток из памяти в  аргумент. тоесть программа к переменнной доступа не имеет. перед 
тем как зпустить команду баш считывает переменную и посдтавляет ее в байтовом виде в команду и потом толко вызыает команду
примеир
    $ a=$'\x31'
    $ strace -e execve printf "$a\n"
    execve("/usr/bin/printf", ["printf", "1\\n"], 0x7ffe76b5c318 /* 70 vars */) = 0

тоесть баш запомнил где то в своих кишках 0x31
перед запуском printf баш сам считывает 0x31 и подставляет этот байт в сисколл execve в качестве аргумента
таким образом если бащ засунул в переменную какойто байт поток то он при вызове команды 
считает этот же байт поток и подсунет этот же байт поток как аргумент в команду

возможен конечно другой вариант. когда мы суем некотоыйр байт поток в команду а она уже сама
на основе своего интеллекта преобразует его в другое значение
    $ strace -e execve printf "\x31"
    execve("/usr/bin/printf", ["printf", "\\x31"], ...
    1
или 
    $ a="\x31"
    $ strace -e execve printf "$a"
    execve("/usr/bin/printf", ["printf", "\\x31"] ...
    1
что я хотел этими двумя примерами показать что в printf улетел стринг "\x31" тоесть байтовый поток  5c 78 33 31    
    $ od -t x1 <<< "$a"
    0000000 5c 78 33 31 0a
но сама команда printf такая умная что она его преобразовала в "1" тоесть в байт поток 0x31
тоесть вот это две соверенно разные ситауации в плане байт потока аргумента в printf 
хотя резулттат один и тот же

    $ strace -e execve printf "\x31"
    execve("/usr/bin/printf", ["printf", "\\x31"]
    1

    $ strace -e execve printf $'\x31'
    execve("/usr/bin/printf", ["printf", "1"]
    1

результат мы получили один и тот же. но баш подставил при вызовер printf совершенно разные байт потоки
в первом случае это "\x31" = 5c 78 33 31
во втором случае это $'\x31'= 31
это очень важно понять

теперь когда этот важный вопрос прояснился 
посмотрим вот на что.
возьмем команду [ либо test они же одинаково работают.
и посмотрим как они могут работать с входными форматами данных
я хочу сравнить стринги
    "10"
    "0x0A"
    "0x0a"
    $'\x0a'
совершенно понятно что байтовый поток у них совершенно разный
то входные аргументы совершенно не совпдаают. 
но возможно сама программа [ умеет 
распознавать форматы
проверим

    $ [ "10" -eq "0x0A" ]; echo $?
    bash: [: 0x0A: integer expression expected
    2

    $ [ "10" -eq "0x0a" ]; echo $?
    bash: [: 0x0a: integer expression expected
    2

    $ [ "10" -eq $'\x0a' ]; echo $?
    bash: [: 
    : integer expression expected
    2

как видим [ совершенно неумеет сама распознавать форматы.
она работает с числами которые должны быть выражены буквально в форме литер "1" "2"
проверим еще вот как  посмотрим какой байтвый поток у "10"
    $ od -t x1 <<< "10"
    0000000 31 30 0a
тогда
    $ [ "10" -eq $'\x31\x30' ]; echo $?
    0
ха. сработало.
    $ test "10" -eq $'\x31\x30'; echo $?
    0
но оно сработало не потому что программа [ какая то умная а потому то баш перед запуском команды
транслировал $'\x31\x30' в "10" в форме байт потока

    $ strace -e execve [ "10" -eq $'\x31\x30' ]; echo $?
    execve("/usr/bin/[", ["[", "10", "-eq", "10", "]"], 

тоесть с точки зрения [ в нее влетело абсолютно два одинаковых аргумента!

а теперь рассмотрим так называемый якобы keyword [[...]] может он более интеллектуальный 
и умеет распознавать форматы чисел в разных байт потоках. например может он понимает что "0x0A" это надо 
понимать как $'\x0a'

    $ [[ "10" -eq "0x0A" ]]; echo $?
    0

    $ [[ "10" -eq "0x0a" ]]; echo $?
    0

окей перепишу эти два примера по другому в равнозначной форме
я опишу левый аргумент в форме байт потока

    $ [[ $'\x31\x30' -eq "0x0A" ]]; echo $?
    0

    $ [[ $'\x31\x30' -eq "0x0a" ]]; echo $?
    0

    
совершенно понятно что справа у нас аргумент имеет совершенно другой байт поток
    $ od -t x1 <<< "0x0A"   
    0000000 30 78 30 41 0a
    $ od -t x1 <<< "0x0a"
    0000000 30 78 30 61 0a
    
отсюда следует что [[...]] умеет сама в себе  понимать и трансформировать "0x0A" который в виде байт
потока выглядит как 30 78 30 41 в совершенно другой байт поток $'\x31\x30'
тоже самое касается "0x0a". если же отойти от байт потоков и перейти к литерам то я говорю о том что сама программа
внутри себя умеет трансформировать литеры "0x0A" в литеры "10"
для сравнения программа [...] этого делать не умеет. 
еще пример
здесь понятно. оба аргумента имеют одинаковый байт поток. 
илидругими словами одинаковый литерный вид
    $ [[ "10" -eq $'\x31\x30' ]]; echo $?
    0


еще пример
понятно почему неработает 
потому что разный байт поток, тоже самое у нас разный литерный поток
а сама программа не умеет внутри себя трансформировать $'\x0a' в "10"
    $ [[ "10" -eq $'\x0a' ]]; echo $?
    1
    
    
таким макаром [[..]] умеет понимать hex формат в литерном виде если он записан как "0xNN" либо "0xnn"
для сравнения [..] этого не умеет
таким образом мы можем в [[...]] задать аргумент 
либо    в виде 
    литер '10' 
либо в виде 
    байтового потока этих литер $'\x31\x30'
либо в виде литер. преобразовав число 10 в вид
    '0x0A'
    '0x0a'
    
таким образом можно заменить исходные литеры на другие литеры по некоторому закону и програмаа [[...]]
это поймет. но поймет только эта программа потому что она индивидуально под это заточено. 
как там у других программ надо смотреть индивидуально.
пиздец
возьмем для примера другую программу printf
здесь все понятно просто печатаем литеры "10"
    $ printf "10 \n"
    10 
или печатаем их в форме байтового потока
    $ printf $'\x31\x30\x0a'
    10
тут все понятно в принтф прилетает один и тот же аргумент. 
преобрзаованием занимтся сам баш. а принтф вобще ни при чем
доказываю
    $ strace -e execve printf "10 \n"
    execve("/usr/bin/printf", ["printf", "10 \\n"]
    10 

    $ strace -e execve printf $'\x31\x30\x0a'
    execve("/usr/bin/printf", ["printf", "10\n"]
    10

сточки зрения принтф в него были подставлены абсолбтно одни и теже аргументы.
это заслуга самого бащ.
далее как видно вот такой формат принтф уже не понимает
    $ printf "0x310x30 \n"
    0x310x30 

зато принтф понимает вот такой формат и это заслуга именно
самого принта а не баша
    $ printf "\x31\x30 \n"
    10 

    $ strace -e execve printf "\x31\x30 \n"
    execve("/usr/bin/printf", ["printf", "\\x31\\x30 \\n"]
    10 

еще вот такая хрень в которой в принтф влетают литеры "\x31" \x30"
а уже именно он сам их преобразует в литеры "1" "0"
это заслуга не баша а самого принтф
    $ printf "%b%b \n" "\x31" "\x30"
    10 

    $ strace -e execve printf "%b%b \n" "\x31" "\x30"
    execve("/usr/bin/printf", ["printf", "%b%b \\n", "\\x31", "\\x30"]
    10 

а вот еще пример где в принтф влетают литеры "10"
он именно он их преобразует в другие литеры
    $ printf "%x \n" "10"
    a 
тоесть берутся литеры "10". они внутри преобразуются в число 10
это число считается что записано в десятичном формате
оно преобразуется в hex число a и это число преобразуется в литеру "a"
и это все заслуга принтф.
    "10" -> 10 -> a -> "a"

а вот еще пример интересный
    $ printf "%x \n" "0xa"
    a 
на входе в принтф  у нас литеры "0xa" он преобразует их в число a в формате hex
а потом это число преобразует в литеру "a"
    "0xa" -> a -> "a"
и это все заслуга исключтельно принтф

таким образом вот так все сложно с форматами литер\байтов в самом баше в его
стрингах и переменных и во внешних по отношению к башу командах и в кейвордах
баша.

чтобы в этм ориентироваться надо все это четко понимать - какие форматы понимает баш.
разница между литерами и байт потоком, числами, в каком байт виде перменная или стринг
есть в баше и как она подставляется в команду или кейворд и какие форматы понимает 
для автоматического преорбразвания этот кейворд или команда

опять же надо понимать что есть реальные числа котрые хранятся в формет байтов
а есть литеры которые имеют совершенно другое байтовое представление. 
надо понимать с чем рабтает программа с числами в формет байтов
или с числами в форме литер

вот так все сложно.

теперь когда мы это все знаем мы можем предстазывать резултат работы прогармм
например программа [
она анализирует числа-литеры. тоесть мы скажем ей суем литеру "1" она ее внутри себя преобразует
уже в число 1(десятичное). и с ним работает. таким образом если мы хотим сравнить число 1 и число 2 то 
их нужно подсунуть этой прграмме в форме литер "1" и "2"
    $ [ "1" -lt "2" ]; echo "$?"
    0
программа работает так. берет литеру "1" и внутри себя преобразует в число 1
потом берет литеру "2" преобразует ее в число 2 и потом сравнивает 
    1 < 2 ?
ответ да. тоесть true .
поэтому код возврата 0

следущий пример
    { decimal=15; octal=017; hex=0x0f; [ "$decimal" -eq "$octal" ]; echo $?; }
    1
у нас по факту это раотает так 
    [ "15" -eq "017" ]
у нас литеры "15" преобразуюься в число 15  и литеры "017" преобразуются вчисло 17
  15 неравно 17 
поэтому на выходе код возрата 1

следущий пример
    $ { decimal=15;  hex=0x0f; [ "$decimal" -eq "$hex" ]; echo $?; }
    bash: [: 0x0f: integer expression expected
    2
тут теперь тоже все понятно. у нас это раоатет так
    [ "15" -eq "0x0f" ]
литеры "15" программа преобразует в десятичное число 15
литеры "0x0f" программа ни в какое число не преобразует. потому что она не понимает что 
это ей за хрень подсунули. она ожидает увидеть среди литер только литеры из словаря "0 1 2 3 4 5 6 7 8 9:
поэтмоу она нас шлет нахер.

рассмомирим следущюу программу [[..]]
пример
    $ { decimal=15; octal=017;  [[ "$decimal" -eq "$octal" ]]; echo $?; }
    0
эта программа более умная чем предудыдущая. она раотает так
подставляются переменные
    [[ "15" -eq "017" ]]
далее программа преобразует литеры "15" в десятичное число 15
и преобразует литеры "017" в OCT число 017
и далее программа сранивает 15 dec и 017 OCT . ( по факту я думаю прогармма в конечно итоге оба числа
преобрзаует в двоичный вид).
видит что это два одинаковых числа поэтмоу возварщает $?=0
таким образом это заслуга самой программы что она умеет в литерном виде понимать нетолько десятичный формат
но и восьемеричный.

еще пример
    $ { decimal=15;  hex=0x0f; [[ "$decimal" -eq "$hex" ]]; echo $?; }
    0
суть такая же как в прошлом примере.
изюминка лишь в том что программа [[...]] умеет преобразоывать литерный вид "0x0f" в число 
в hex формате 0x0f поэтому она не выдвает ошибку а сравнивает 15 dec и 0x0f видит что 
это одно и тоже число и выдает $?=0
офигеть...

из этого я делаю в частосноти вывод что лучше всегда использовать [[...]] вместо [..] потому что она 
более интеллектуальная.

насколько я понял разница между [[...]] и ((...)) в том что 
((...)) вычисялет арифеметичесие операции 
а 
[[...]] делает сравнения в виде больше, меньше, равно

тоесть это несколько разные виды операций. 
и код вовзрата формируется также у них по разному. внутри [[...]] формируется булевый результат true или fasle
в зависимосоти от этого в $? идет 0 или 1
у ((..))) внутри формируется число. если оно равно 0 то в $? летит 1 а если оно неравно -0 
то  в $? летит 0

охренеть

    $ (( 0 )); echo $?
    1
    $ (( 1 )); echo $?
    0
    $ (( 5>4 )); echo $?
    0
    $ (( 5>9 )); echo $?
    1

ксати видно что ((..)) тоже может делать операции сравнению больше меньше как и [[...]]
только для этого прмиенятся другие символы.
еще пример для сраврнеия

    $ [[ "5" -gt "4" ]]; echo $?
    0
    $  (( 5>4 )); echo $?
    0
как видно код вовзрата одинаковый кстати
получается что (( 5>4 )) приводит к (( 1 )) что в свою очередь приводит к $?=0
получается (( 0 )) это свое рода (( False )) поэтому $?=1
а (( 1 )) или  (( 100 )) это своего рода (( True )) поэтому $?=0

еще примеры
внутри получаем True  поэтому $?=0
    $ (( 5==5 ));echo $?
    0
внутри получаем  0 это аналог false значит $?=1
    $ (( 5-5 ));echo $?
    1   
целое  от деления  1 это аналог True згначит $?=0
    $ (( 5/4 ));echo $?
    0
целое от деления это 0 это аналог false значит $?=1
    $ (( 5/10 ));echo $?
    1
пздец


кстати 
    /proc/self/fd смотрит в ---> /dev/fd/
удобно


| проверка файлов

есть такая подьебка с самого начала.
есть множество флагов проверяющих существование файла или его тип
например

проверить что файл существует
    $ [ -e "./03.bash" ]; echo "$?"
    0

проверить что файел есть и его тип обычный
    $ [[ -f "./03.bash" ]]; echo "$?"
    0

и здесь вот надо особо указать на то что флаг -f
он проверяет две вещи сразу 1) существует ли файл вообще и 2) что тип файла обычный 
поэтому команда будет возвращать false если хотя бы одно условие не выполняется. 
тоесть если команда вернула $?=1 это значит что либо тип файла необычный либо 
файла вообще нет. поэтому, если мы хотим точно узнать то ли файла вобще нет. то ли он 
есть но у него нетот тип тогда надо делать две проверки.
    $ if [[ -e "./03.bash" ]]
      then
         if [[ -f "./03.bash" ]]
         then
            echo "тип файлы обычный"
         else
            echo "тип файл необычный"
        fi
      else
        echo "файл несуществует"
      fi

а вот проверка тогоже самого в одну строчку
    $ [[ -e "./03.bash" ]] &&  { [[ -f "./03.bash" ]] && echo "файл обычный" || echo "файл необычный"; }   || echo "файл несуществует"

примеры
    $ stat "./03.bash" | head -n2
        File: ./03.bash
        Size: 151       	Blocks: 8          IO Block: 4096   regular file

    $ file="./03.bash"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл обычный

    $ stat "./123.bash" | head -n2
    stat: cannot stat './123.bash': No such file or directory

    $ file="./123.bash"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл несуществует

    $ stat "/dev/zfs" | head -n2
        File: /dev/zfs
        Size: 0         	Blocks: 0          IO Block: 4096   character special file

    $ file="/dev/zfs"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл необычный

таким образом скрипт работает на 100%

далее
проверить что файл существует и размер файла не нулевой
    $ [[ -s "./03.bash" ]]; echo "$?"
    0
    
    $ [[ -s "/proc/self/fd/0" ]]; echo "$?"
    1

проверка что файл существует и это папка
    $ [[ -d "/" ]]; echo "$?"
    0

проверка что файл существует и  файл это блочное устройство
    $ [[ -b "/dev/loop0" ]]; echo "$?"
    0
    
провекра что файл существует и  файл это character устройство
    $ [[ -c "/dev/zfs" ]]; echo "$?"
    0

далее поговорим про файл типа пайп.
для начала создадим именованный пайп
    $ mkfifo /tmp/1.pipe
посмотрим как выглядит его описание

    $ ls -1al /tmp/1.pipe
    prw-rw-r-- 1 vasya vasya 0 дек 10 20:02 /tmp/1.pipe

тоесть у него буква "p" вначале (prw-rw-r--)

    $ stat  /tmp/1.pipe
        Size: 0         	Blocks: 0          IO Block: 4096   fifo


проверим что файл существует и его тип это пайп (FIFO)
    $ [[ -p "/tmp/1.pipe" ]]; echo "$?"
    0

а теперь создадим два процесса связаных пайпом
и посмотрим как там у них выглядят файлы дескрипторы

    $ sleep 120 | sleep 130
    $ ps aux | grep sleep
    vasya    22746  ... sleep 120
    vasya    22747  ... sleep 130

    $ ls -1al /proc/22746/fd/1
    l-wx------ 1  ...  /proc/22746/fd/1 -> 'pipe:[3692096]'
    $ ls -1al /proc/22747/fd/0
    lr-x------ 1  ...  /proc/22747/fd/0 -> 'pipe:[3692096]'

и соотвесвтенно тут важно заметить что файлы 0 и 1 они не имеют тип пайп. нихуя.
они симлинки. указыывающие хрен знает на что.
таким образом если мы будем проверять 0 и 1 на то что они пайп то получим пошел нахер.
они только успешно проверяться на то что они симлинки

проверка на то что файл симлинк идет через два флага -h -L
чем они отличаются хуй знает

    $ [[ -h "/proc/22746/fd/0" ]]; echo "$?"
    0

    $ [[ -L "/proc/22746/fd/0" ]]; echo "$?"
    0

    $ [[ -p "/proc/22746/fd/0" ]]; echo "$?"
    1
    

тоесть я хочу сказать что кога мы создаем два процесса соединеных пайпом то интуиция 
говорит что ихние файлы отвечающие за STDOUT и STDIN должны быть типа пайп. 
но нихуя. это будут симлинки. указывающие на типа пайп. который не пайп а некая ядерная структура.

таким образом я бы сказал что проверка через флаг -p 
она позволяет является ли файл не просто пайпом а является ли он ИМЕНОВАННЫМ ПАЙПОМ.
вот что важно понять.

кстати  с именованным пайпом тоже хуйня интересная. если мы запустим команды
    $ echo "123" > /tmp/1.pipe; cat < /tmp/1.pipe;
то вторая команда не будет выполнена никогда. 
потому что первая команда сунула 123 в пайп и ждет как я понимаю ответа 
от ос о том что данные были забраны. а они не забраны потому что программа cat 
начнет выполняться только после того как закончит работы программа echo
поэтому единственый вариант это использовать два терминала. 
на первом термианале мы пишем
    $ echo "123" > /tmp/1.pipe; 
и эта команда после ввода будет висеть
потом заходим на второй терминал и там пишем
    cat < /tmp/1.pipe;
и вот только тогда все сработает.
пиздец

я себе представлял это некольпо по другому. что при записии в /tmp/1.pipe
данные записываются в ядро в буфер некоторого размера и поэтому наличие второго процесса
считываютщего необязательно. а хуйтам.

далее. сокет файл.
найдем сокет файл

    $ stat $(find "/tmp" -type s 2>/dev/null | head -n1) | grep -E "File|Size|Uid"
        File: /tmp/ssh-Ffb3Jn4D9wqx/agent.4932
        Size: 0         	Blocks: 0          IO Block: 4096   socket
        Access: (0600/srw-------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    
значит файл найден. видно что его тип это socket.
и видно что в описании файла буковка "s" (0600/srw-------)

еще раз убедимся в наличии буквы "s" в описании файла
    $ ls -1al /tmp/ssh-Ffb3Jn4D9wqx/agent.4932
    srw------- 1  ....  /tmp/ssh-Ffb3Jn4D9wqx/agent.4932

    
проверим что файл действиельно есть и что у него тип "сокет"
        $ [[ -S "/tmp/ssh-Ffb3Jn4D9wqx/agent.4932" ]]; echo $?
        0


следующий флаг -t очень интересный
    -t   file (descriptor) is associated with a terminal device
хуета в том что аргумент сюда ставится не путь к файлу. нет нихуя.
аргумент здесь это номер файл дескриптора процесса в котором сейчас работает
скрипт. это то как я понял из эксперимента. потому что описание этого флага
мегауебищное. поэтому эта хрень ее примененеие может выгляеть только так
    $ [[ -t 0 ]]
    $ [[ -t 1 ]]
    $ [[ -t 2 ]]
    
так вот я как понял эта хрень проверяет то что если дескриптор  ( а дескриптор это
 всегда симлинк ) как симлинк указывает на спец файл (/dev/...) который обрабатывается
 драйвером терминала. пример такого файла
 причем подходит нетолько tty драйвер но и pts драйвер
    $ ls -1al /proc/self/fd/0
    ... /proc/self/fd/0 -> /dev/pts/21

в общем этот странный флаг на практкие может быть использован чтобы
типа скрипт мог опрееделить что какойто его дескриптор обслуживатеся 
драйвером терминала.

далее проверить есть ли файл и может ли наш процесс читать этот файл. есть ли пермишнс

    $ [[ -r "./private-dhcp" ]]; echo "$?"
    0
    $ [[ -r "/etc/shadow" ]]; echo "$?"
    1


проверка что файл есть и у процесса есть право записывать в файл у этого проццеса

    $ [[ -w "/etc/shadow" ]]; echo "$?"
    1

прверка есть ли файл и есть ли у нашего текущего юзера права на execution для этого файла

    $ [[ -x "/etc/shadow" ]]; echo "$?"
    1

    $ [[ -x "./03.bash" ]]; echo "$?"
    0   

    
    
| find 

на время отвлечемся  на  find ( а позже обратно вернемся к преддыдудщей теме)
итак
программа ищет в /etc файла "*host*" и печатает имя файла на экране (что круто кстати)
    $ find /etc -name "*host*" -type f -print 2>/dev/null
    /etc/ansible/hosts
    /etc/avahi/hosts
    /etc/hosts


вот это пример интересный
    $find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files named core in or below the directory /tmp and delete them, 
processing filenames in such a way that file or directory names containing single or 
double  quotes, spaces or newlines are correctly handled.  
The -name test comes before the -type test in order to avoid having to call stat(2) on every file.

тут я покажу то что можно создавать файлы в имени которых есть диковинные символы. 
тоесть в имени файла насколько я щас помню можно использовать любые байты 
за исключением по моему байта 0x00 а все остальное можно. поэтому
в имени байта наример можноисользовать байт 0x0a который отвечает за Enter
ну и вообще лббые символы UTF-8.
показываю

    $ : > "$( printf "12\x0a1")"
    $ ls
    '12'$'\n''1'

тоесть у нас имя файла это "12" + символ Enter + "1"

ну и вот еще пример. когда мы вставляем символ UTF-8  "∑"

    $ : > "$( printf "12\x0a\xe2\x88\x91")"
    $ ls -1
    '12'$'\n''∑'
    '12'$'\n''1'

тоесть второй файл это "12" + Enter + "∑"
    
из за того что у нас в имени файла теперь есть символ "Enter" это приводит к проблеме.
вот какой. вот мы щас начнем искать эти файлы. и передаем этот список в команду xargs
а она же должна понять как ей отделить "слова" друг между другом. для этого она 
использует переменную $IFS в которой указано какие символы являются признаком 
разделителя между словами. по дефолту это символ "пробел", символ "Enter" и 
символ табуляции вертикальной "\t"
    $ od -t x1 <<< "$IFS"
    0000000 20 09 0a 0a

поэтому когда в xargs прилетит поток с именами нащих файлов в которых знак "enter" присуствует 
внтри имени файла то xargs будет считать что это знак разделения между словами. и мы получим 
скажем вместо имени файла '12'$'\n''∑' мы получим типа два отдельных слова '12' и '∑'
и это приведет нас к ошибкам. у нас же нет таких файлов. показываю

    $ ls -1
    '12'$'\n''∑'
    '12'$'\n''1'


    $ find . | xargs -I% echo "аргумент = %"
    аргумент = .
    аргумент = ./12
    аргумент = ∑
    аргумент = ./12
    аргумент = 1

поэтому это проблема
вот к чему это ведет    
    $ find . | xargs stat
    File: .
    Size: 4096      	Blocks: 8          IO Block: 4096   directory
    Device: 10302h/66306d	Inode: 15073820    Links: 2
    Access: (0775/drwxrwxr-x)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    Access: 2023-12-10 23:37:31.572393014 +0600
    Modify: 2023-12-10 23:37:28.716395145 +0600
    Change: 2023-12-10 23:37:28.716395145 +0600
    Birth: -

    stat: cannot stat './12': No such file or directory
    stat: cannot stat '∑': No such file or directory
    stat: cannot stat './12': No such file or directory
    stat: cannot stat '1': No such file or directory

но это можно преодолеть. можно указать команде find чтобы она когда формирует выходной список файлов 
чтобы она между именами файлов ставила не Enter как по дефолту а нулевой байт 0x00
это опция -print0

    $ find . -print0

и далее надо обьяснить xargs чтобы он тоже для определения как ему различать "слова" использовал
не то что указано в $IFS а байт 0x00 это опция -0

    $ find . -print0 | xargs -0 -I% echo -e "аргумент =%\n"
    аргумент =.
    
    аргумент =./12
    ∑

    аргумент =./12
    1

соовесвтенно теперь имена файлов различает xargs коректно. ну а то что ∑ стоит на следущей строке то это же понятно
как еще в терминале отображать сивмол 0x0a Enter

вот проверка что теперь все верно работает
    $ find . -print0 | xargs -0  stat
  File: .
  Size: 4096      	Blocks: 8          IO Block: 4096   directory

  File: ./12
∑
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file

  File: ./12
1
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file


теперь поймем какой формат аргументов у find

    $ find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]

тут много всякой хрени но нас оно интересует с момента  [starting-point...] [expression]

[starting-point...] это папка с которой начинать искать и тут все понятно

[expression] = вот это самое интересное. дело в том что эта хрень сама состоит из нескольких частей
а именно 
     [expression] = Tests + Actions + Global options + Positional options + Operators

для примера берем папку
    $ ls -1al
    total 8
    drwxrwxr-x 2 vasya vasya 4096 дек 11 00:21 .
    drwxrwxr-x 7 vasya vasya 4096 дек 10 23:57 ..
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 1.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 2.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 3.txt
    prw-rw-r-- 1 vasya vasya    0 дек 11 00:21 4.pipe

    
так вот если у нас аргументы идет просто через пробел то между ними как бы невидимо идет AND
то есть надо чтобы все аргументы выполнились
в данном случае я ищу файл с именем "1.txt" и чтобы тип файлы был обычный
    $ find .   -name "1.txt" -type "f"
    ./1.txt

полный аналог (-a это AND)
    $ find .   -name "1.txt" -a -type "f"
    ./1.txt

если мы хотим чтобы аргументы воспринимались как OR то 
в данном примере мы ищем файлы у которых либо имя "1.txt" либо тип файла обычный
    $ find .   -name "1.txt" -o -type "f"
    ./1.txt
    ./3.txt
    ./2.txt

также я как понял вместо "-o" можно использовать ","
    $ find .   -name "1.txt" , -type "f"
    ./1.txt
    ./3.txt
    ./2.txt

также как я понял условия можно группировать используя скобки. 
единственное что так как скобки это спецсимвол самого баша то надо обьяснить бащу чтобы он воспринял их как просто 
литеры и передал без изменений внешней команде в данном случае find
так вот пример когда скобки дают смысл

    $ find / \(  условие1 -a условие2 -a условие3 \) -o \(  условие4 -a условие5 -a условие6 \)  

смысл этой хрени такой найти в / файлы которые отвечают условиям: условие1+условие2+условие3    либо условие4+условие5+условие6
приведу конкретный пример
этот пример ищет либо файл с именем 1.txt и тип файла обычный либо файл с именем 4.pipe и тип файла pipe
также можно заметить что я экранировал скобки двумя способами это либо \( либо "("

    $ find .  \( -name "1.txt" -a -type "f"    \)  -o   "(" -name "4.pipe"  -a  -type "p"  ")"
    ./1.txt
    ./4.pipe

можно также сократить запись сделав ее более короткой но менее читаемой

    $ find .  \( -name "1.txt" -type f    \)  ,   "(" -name "4.pipe"    -type p  ")"
    ./1.txt
    ./4.pipe
    
теперь зная все это можно прокоментиоовать пример из самого man find
    
     $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -printf /root/big.txt '%-10s %p\n' \)

значит этот пример ищет файл который либо удовлетворяет требованиям
       
       -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n'
    
либо удовлетворяет требованияем

       -size +100M -printf /root/big.txt '%-10s %p\n'
       
тоесть либо файл имеет SUID бит установленный и тогда список этих файлов пишется в /root/suid.txt в формате %#m %u %p\n
либо файл по размеру больше 100МB и список этих файлов пишется в /root/big.txt в формате %-10s %p\n

тоесть этот исходный пример можно схематически вот таки изобразить

     $ find / \( услови1 AND  условие2  \) OR ( условие3 AND  условие4 \)

правда не совсем так потому что часть условий это actiiond дейтствия то есть что надо сделать с найденным файлом

     $ find / \( услови1 AND  действие1  \) OR ( условие3 AND  действие2 \)

кстати что еще парамлельно я узнал\вспомнил
как добавить SUID бит
    # chmod u+s file
что это дает. если владелец файла root а запускает на исполненеие файл простой юзер 
то фактически процесс будет запущен не от юзера а от владельца файла то есть рута.

также при смене владельца файла SUID бит автоматом сбрасывается

далее. интересный момент на счет аргумента "-perm -4000"
значит как задаются пермишнсы  файла который ищется
он задается в виде трех вариантов

    -perm маска    # в этом режиме нужно чтобы маска пермишнсов у файла точно совпала с маска у find
                   # сокращенно я бы этот режиме назвал exact match
    
    -perm -маска   # в этом режиме нужно чтобы установленные биты (равные 1)  из маски find были установлены в 
                   # маске файла. что касается битов которые не установленных битов (равных 0) в маске find
                   # то эти биты в маске файла могут быть любыми
                   # сокращенно я называюь этот режим all match
    
    -perm /маска   # в этом режиме нужно чтобы хотя бы один любой устанолвенный бит в маске find
                   # был установлен в маске файла
                   
сама маска может задавать либо через OCT число либо через вид "u=r,g=w,o=x"
пример

    $ ls -1al
    -r-------- 1 vasya vasya    0 дек 10 23:57 1.txt
    -r--r----- 1 vasya vasya    0 дек 10 23:57 2.txt
    -r--r--r-- 1 vasya vasya    0 дек 10 23:57 3.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 11 01:03 4.txt

вначале ищем файлы у которых пермишнс точно совпдадает с 444
    $ find .  -perm 444
    ./3.txt
кстати можно дополнительным образом подчеркнуть для find что 
маску мы вводим в OCT формате хотя это необязательно
    $ find .  -perm 0444
    ./3.txt

    
в этом примере мы ищем файлы у которых установлены биты 
user = read, group=read, other=read
что касается остальных битов то нам на них насрать
как видно в выборку попал файл 4.txt хоть 
у него есть биты установленные на запись но нам на это
насрать
    $ find .  -perm -444
    ./3.txt
    ./4.txt
    
теперь мы ищем файлы у которых установлен хотя бы
один любой бит из списка
user = read либо  group=read либо other=read
как видно под это подошли все файлы
    $ find .  -perm /444
    ./1.txt
    ./3.txt
    ./2.txt
    ./4.txt

далее я повторяю ровно теже 
самые запросы но маску задаю в символьном виде
    $ find .  -perm u=r,g=r,o=r
    ./3.txt

    
    $ find .  -perm -u=r,g=r,o=r
    ./3.txt
    ./4.txt

    $ find .  -perm /u=r,g=r,o=r
    ./1.txt
    ./3.txt
    ./2.txt
    ./4.txt


    
таким макааром я вовзращаюсь к исходному примеру где было указано
    $ find / \( -perm -4000 .....
откуда становится понятен смысл аргумента
    -perm -4000
мы  ищем файлы у которых установлен SUID бит. что до остальных 
битов в маске нам все равно

теперь еще раз посмотрим на исходную команду

    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -printf /root/big.txt '%-10s %p\n' \)
    
так вот вопрос чем отличается -fprintf от -printf 
а тем что -fprintf она берет результат форматирует его и пишет его на диск
а -printf берет результат форматирует его и пишет на stdout 
поэтому вот этот кусок в команде неправильный ( а между прочим это пример из man find )
    -printf /root/big.txt '%-10s %p\n'
    
так как у нас указан файл то нужно изменить этот кусок на 
    -fprintf /root/big.txt '%-10s %p\n'
    
либо на такой кусок
    -printf '%-10s %p\n'


так я еще раз пересмотрел пример из man find
    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
       \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

и оказыается это  я его переписал с ошибкой. в ориигинальном примере ошибок нет

теперь я хочу разобрать что значит эти загадочные символы описывающие формат
    '%#m %u %p\n' 

    '%-10s %p\n'

окаызвается %m укаызвает что find должен напечатать маску пермишснов в oct формате.
если мы хотим получить дополнительный ноль то нужно юзать %#m
символ \n нужен чтобы был перенос строк
пример
    $ find . -printf '%m\n'
    775
    400
    
    $ find . -printf '%#m\n'
    0775
    0400

%u означает напечатай мне имя владельца файла. если у него нет 
символьного имени то напечатай ID

    $ find . -printf '%u\n' | head -n2
    vasya
    vasya

%p это напечатай мне имя файла
    $ find . -printf '%p\n' | head -n2
    .
    ./1.txt

%f печатает имя файл и убираем из его имени хрень вида "./"
что очень удобно
    $ find . -printf '%f\n'
    .
    1.txt

%s печатает размер файла в байтах
кстати  прикол в том что у самого find нет никаких ключей чтобы показывать размер файла в мегабайтах
или гигабайтах. только можно в байтах. это конечно проеб
    $ find . -printf ' %s  \n'
    4096  
    0  

кстати можно в вывод вставлять всякие элементы декора
что тоже очень круто
    $ find . -printf '%f -> %s  \n'
    . -> 4096  
    1.txt -> 0  


    $ find . -printf 'имя файла = %f -> размер = %s  \n'
    имя файла = . -> размер = 4096  
    имя файла = 1.txt -> размер = 0  



    
откатываемся чуть назад
получается вот эта хрень
    '%#m %u %p\n' 
означает напечатай маску в oct формате и доп нулем, потом владельца файла и имя файла

    $ find . -printf '%#m %u %p\n'  | head -n2
    0775 vasya .
    0400 vasya ./1.txt


теперь я хочу понять что это за хрень

    '%-10s %p\n'

главынм образом непонятно что это значит этот кусок
    %-10s

а значит это вот что:
для начала отойдем от реализации printf у find и перейдем в к реализации
просто printf с которым я до этого работал. эта штука пришла из языка C
и в нем есть вот что. я привык что внутри поля формат идут вот такие хрени
    %x
    %d
    %s
    %c

так вот эта хрень на самом деле она длинее. гораздо длиннее
а я видел до этого просто сокращеный формат. 
полный формат этого выглядит как 
    
    %[Flags][Minimum field width][Period Precision. Maximum field width]Argument type

даю расшифровку.  этой формулы

    Argument type

это x либо d , s, c
на самом деле их гораздо больше (https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html)

    %d %i     Decimal signed integer.
    %o	      Octal integer.
    %x %X     Hex integer.
    %u	      Unsigned integer.
    %c	      Character.
    %s	      String. See below.
    %f	      double
    %e %E     double.
    %g %G     double.
    %p        pointer.
    %n	      Number of characters written by this printf.
              No argument expected.
    %%	      %. No argument expected.

щас мы их все отработаем чуть ниже. а пока расшфифровываем
поля дальше

[Period Precision. Maximum field width] = это число которое в одних случая обозначает сколько цифр 
                   сохранить после запятой в дробном числе,
                   в другом случае задает макс распечатываему длину аргумента,
                   я это щас тоже покаж на примере
                
    
[[Minimum field width]] = это число которое покаывает минимальную ширину аргумента в ряде случаев


[flag(s)] = это флаги. 
они бывают:

    -      Left justify.
   0  	  Field is padded with 0's instead of blanks.
   +	  Sign of number always O/P.
   blank  Positive values begin with a blank.

   # 	  особый флаг имеет разные назначения:
	  %#o (Octal) 0 prefix inserted.
	  %#x (Hex)   0x prefix added to non-zero values.
	  %#X (Hex)   0X prefix added to non-zero values.
	  %#e         Always show the decimal point.
	  %#E         Always show the decimal point.
	  %#f         Always show the decimal point.
	  %#g         Always show the decimal point trailing 
	  	      zeros not removed.
	  %#G         Always show the decimal point trailing
		      zeros not removed.

		      

так вот вовзращаемся к нашему примеру

    %-10s
	
значит когда у нас аргумент это %s тоесть простой стринг то число перед s
это ширина столбика внутри которого будет печататься наш аргумент
наш стринг. и дело в том что по дефолту выравнивание происходит
по правой стороне столбика поэтому если у нас столбик 
шириной 10 символов а аргумент шириной 5 символов тогда 
у нас при печати перед символами будет куча пробелов.
это из за выравнивания по правому борту по дефолту.
    $ printf "%10s \n" "12345"
         12345 
если мы хотим выравниваться по левому борту то надо поставить
флаг "-" тогда
    $ printf "%-10s \n" "12345"
    12345      

таким образом разгадаа загадка что значит 
    %-10s

вот эти параметры при печати очень удобны кодга мы заранее незнаем длину
нашего аргумента

насвкику нахрен все это формтрование надо ?
а надо оно походу тогда когда мы печатаем несолько строк. 
в кажой строке по несколко столбцов. и у нас скажем аргумент в кажом столбце прыгает 
принимая разное количсво символов. так вот чтобы столбдцы были красивые то
помогает это форматирование. показываю
вот так выглядит печать без форматирования
    $ for i in $(echo "1 100 2 1000 33" ); do printf "%s 44\n" "$i"; done 
    1 44
    100 44
    2 44
    1000 44
    33 44

вот так с форматированием
разница как говориттся колоссальная
    $ for i in $(echo "1 100 2 1000 33" ); do printf "%-10s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44

возникает вопрос а что если у нас задана ширина первого столбца как 10 симвлов а аргумент будет 20
симвлов?
ответ - будет то что ширина первого столбца тогда будет автоматом увеличена
чтобы у нас нащ исходный стринг поместился и не был затерт. 
поэтому ширину столбца есть смысл выбирать длинной такой какова максимальная
длинна аргумента в столбце может быть
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-10s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44
    1000000000000 44


а вот я увеличил шириину столбца
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-20s 44\n" "$i"; done 
    1                    44
    100                  44
    2                    44
    1000                 44
    33                   44
    1000000000000        44

    
можно пойти и по другому пути. можно обрезать сам стринг вот так 
    $ printf "%-4.2s --\n" "123456"
    12   --
тоесть я гооворю что ширина столбца 4 символа а при этом макс ширина стринга вырезается равной 2 символа

возвращаюсь к примеру что был чуть выше
я оставляю ширину столбца 10 символов но ограничиыаю макс ширину печатаемого стринга как 9 
символов. поэтому  у меня мой длинный стринг будет обрезан. 
первый столбик будет выглядеть красиво но конечно же потеряется часть информации.
жалко что у printf нет такого флага чтобы как то сигнализировать что при печчати 
аргумент был порезан
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-10.9s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44
    100000000  44

таким образом вот эта хрень
    %-10.9s
означает что возьми стринг. обрежь из него 9 символов и напечатай их в столбике шириной 10 символов
с выравниваеием по левой стороне.

далее. 
если мы возьмем число с плавающей точкой
    $ printf "%20.2f \n" "1234,5678"
             1234,57 

то смысл 
    %20.2f
вот какой.
мы говорим вот что 
f = означает что тот стринг который стоит в аргументе надо рассматривать как число с плавающей точкой
окей. он переводит внутри себя этот стринг как число с плавающей точкой 1234,5678
    "1234,5678" --> 1234,5678

далее 20 означает ширину столбика в котором будем печаат аргумент. по умолчанию выравнивение по правому краю
.2 означает что после запятой нужно сохранить два знака
поэтому 
    1234,5678 --> 1234,56
далее он конвертирует число обратно в стринг "1234,56"
и печатает его в столбике шририной 20 симвлов с выравнивем справа
еще пример
    $ printf "%20.2f ----\n" "1234,5678"
             1234,57 ----
соотвесвтенно ширина столбика играет роль для следущего печатуемого аргумента.
еще пример
    $ printf "%-20.2f ----\n" "1234,5678"
    1234,57              ----
тоесть первый аргумент печатается как дробное число с сохраненеим двух знаков
после запятой в столбике шириной 20 симвоолов с выравниванием слева.
значит следущий аргумент "----" уже начинает печататься с 21 позиции в строке.

вот еще один пример. из которого видна как важна ширина столбца
и по какому краю выравнивание

    $ printf "%s \n" "---------- ----------"
    $ printf "%-10s %10.2f \n" "123" "12,123456"
    $ printf "%10s %-10.2f \n" "123" "12,123456"
    ---------- ---------- 
    123             12,12 
            23 12,12      


теперь я вовзращась к тому что printf у меня еще есть в find.
и прикол в том что согласно man find у егоного принтф значения 
для %s другое чем у классического printf. у файндовского принтф
%s    означает  File's size in bytes.


так вот насколько я понимаю в случае файндовского printf 
формат %-10s означает что возьми длиннну в байтах 
и напечатай ее в столбике шириной 10 символов с выравниванием слева.
проверяю.

    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10s %f \n' | sort | head -n7
    1011712    temp 
    102        .python_history 
    102        .zshrc 
    1070       33.txt 
    11026432   atomicwallet-2.75.3.dmg.1 
    11853498   fastrans-2022-11-29-gt_erp.sql.gz.7z 
    118        kuku.txt 


значит как работает эта команда. я говорю чтобы find нашел в папке "." с глубиной поиска 1 файлы такие что 
 0b < размер файлы < 4096b  OR  размер файла > 4096b
кстати прикол в том что по дефолту аргумент -size это блоки. так что если я хочу заказывать размер  в байтах 
то надо добавлят "c" тоесть -size +4096c 
плюс означает больше, минус означает меньше.

так вот найденные файлы печатаются по формату
    -printf '%-10s %f \n'
где s это размер файла в байтах
а f это имя файла

насколко я понимаю если у классического printf %s %f ознаает тип данных то у файндовского принтф это 
означает какие поля и свойств файла надо печатать. а тип данных у него всегда один это стринг. вот такая ужасная
путаница между классическим принтф и файндовским
то есть виртуально можно файндовский формат сконвертировать в классический вот так
    printf '%-10s %s \n'  "размер файла" "имя файла"
так вот я печатаю размер файла в столбике размером 10 симвлов. выравнивание слева
имя файла просто печатается без всяких стобиков и без всяких вырваниваий просто 
с позиции 11 от начала строки.

а вот потверждение моей теории
    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10.2s %.2f \n' | sort | head -n7
    10         33 
    10         .p 
    10         te 
    10         .z 
    11         at 
    11         fa 
    11         ku 

поскольку файндовский принтф все аргументы воспринимает как стринг то запись вида 
    %-10.2s
говорит о том что напечатай аргумент в столбике шириной 10 символов а сам аргумент обрежь до двух символов
тоже самое здесь
    %.2f
возьми аргумент и обрежь его до двух символов

пздец.

еще пример
    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10s %8.8f \n' | sort | head -n10
    1011712        temp 
    102        .python_ 
    102          .zshrc 
    1070         33.txt 
    11026432   atomicwa 
    11853498   fastrans 
    118        kuku.txt 
    122          13.txt 
    127        .Xauthor 
    131        .xinputr 

я печатаю размер файла в столбике длинной 10 симвлов вырванию его по левому краю.
а имя файла печатаю в столбике 8 символов выравниваю по левому краю и обрезаю аргумент до длины 8 символов

дауж... наворотили
это зведец. сам по себе принтф это звездец. а принтф у программы файнд это дполнительный звездец.

разберу примеры из man find
он ищет в папке /tmp файл 
        с именем core
        тип файлы обычный
        и печатает на экране название файлов
        далее это пеернаправляется через пайп на xargs и там этот файл стирается

    $ find /tmp -name core -type f -print | xargs /bin/rm -f

еще пример
ищет в папке "."
тип файла обычный
и найденное имя файла подставляется в команду file в качестве аргумента
    $ find . -type f -exec file '{}' \;

насколко я понял  хрень -exec file '{}' \; работает так. берется команда file в нее вместо аргумента '{}' подставляется
имя файла наденного (если файлов много то по одному на одну команду ) и \; сообщает файнду что строка аргументов закончилась.

я сразу приведу команду которая такая же самая но выглядит более по человечески

    $ find . -type f -exec file '{}' ';'
итак каждый найденный файл будет вставлен в команду
    $ file имя_файла;
и она будет выполнена.
и так с каждый найденным файлом
еще раз повторюсь что '{}' говорит файнду что именно в это место нужно вставлять имя найденного файла.
';' это говорит файнду что строка с аргументами для подстановки закончена и можно запускать команду.
и {} и ; надо сэкранировать, чтобы бащ передал эти аргументы внутрь find без изменений.
экранировать можно либо через '' либо через слеши / мне гораздо больге нравтся экранировать через ''
вместо слешей
может возникнут желание сэкранировать за один присест и {} и ;
но это нельзя делать. потому что надо чтобы баш передало в find это как два отдельных  аргумента
    $ strace -e execve find . -type f -exec file '{}' ';' 
    execve("/usr/bin/find", ["find", ".", "-type", "f", "-exec", "file", "{}", ";"]


показываю теперь как оно отработает на чуть другом примере

    $ ls -1
    1.txt
    2.txt
    3.txt
    4.txt


    $ find . -type f -exec echo \"название файла = '{}' \" ';' 
    "название файла = ./1.txt "
    "название файла = ./3.txt "
    "название файла = ./2.txt "
    "название файла = ./4.txt "


получается что через -exec можно можно выполнять команды над найденными файлами без использования pipe
и xargs.  единственное требование к команде  это чтобы она понимала работу с файлами через аргумент.
показываю пример через xargs аналоичный предыдущей команде

    $ find . -type f | xargs -L1 -I% echo "название файла = %;" 
    название файла = ./1.txt;
    название файла = ./3.txt;
    название файла = ./2.txt;
    название файла = ./4.txt;

в целом лучше не использовать pipe+xargs потому что это лишняя команда и перекачка через пайп
показываю пример
скрипт с xargs
    $ ls -1 /etc/ssh/*.pub | xargs -L 1 -I %  ssh-keygen   -l -E sha256 -f  %
    256 SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10 root@vasya-Lenovo-IdeaPad-L340-15IWL (ECDSA)

пример c find+exec
    $ find /etc/ssh/*.pub  -exec ssh-keygen   -l -E sha256 -f  '{}' ';' 
    256 SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10 root@vasya-Lenovo-IdeaPad-L340-15IWL (ECDSA)

итак возвращаюсь к исходному примеру    
будут взяты файлы из текущей папки и ее подпапок
тип файла обычный, и на них натравливается команда file
    $ find . -type f -exec file '{}' ';'

а вот я модифицировал команду 
и получаю ошибку
и это  дает ошибку о том что указаны неправильные аргументы 
команды file
тоесть попытка всунуть внутрь -exec  пайп приводит к ошибке
о том что find пыается запустить file у котрого в аргументах вставляется  pipe и head -n5
    $ find . -maxdepth 1 -type f -exec  file '{}'  "|"  head -n5 ';'

    file: invalid option -- '5'
    Usage: file [-bcEhikLlNnprsvzZ0] [--apple] [--extension] [--mime-encoding] [--mime-type]
            [-e testname] [-F separator] [-f namefile] [-m magicfiles] file ...
        file -C [-m magicfiles]
        file [--help]

тоесть видно что file запускается с неверными аргументами.

окей идем другим путем выносим pipe из под -exec наружу

    $ find . -maxdepth 1 -type f -exec  file '{}' ';'  | head -n5
    ./09.bash: Bourne-Again shell script, UTF-8 Unicode text executable
    ./08.bash: Bourne-Again shell script, UTF-8 Unicode text executable
    ./03.bash: Bourne-Again shell script, ASCII text executable
    ./args: POSIX shell script, ASCII text executable
    ./sha512crypt.bash: Bourne-Again shell script, ASCII text executable
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13

сигнал 13 это broken pipe.
она возникает тогда когда процесс пишет в пайп
а никто его не читает. 
оно и понятно head после 5 строк себя убивает. 
почему при этом find не помирает непонятно. 
и find продолжает запускать file и направлять его вывод в pipe
а читать из пайпа уже некому.
обычно при убиении процесса в цепочке пайпов баш убивает всех участников.
а тут почему то нет. .. непонятно. 

я запустил
     $ find . -maxdepth 1 -type f -exec  sleep 160  ';'  | head -n5
и попытался найти куда и как подключется пайп. и получил
find имеет номер процесса 9174
sleep имеет номер процесса /9284
head имеет номер процесса 9175

также видно что 
вот такое дерево процессов

    bash(3689)|---find(9174)---sleep(9929)
              |---head(9175)

тоесть и find и head имеют одного родителя

и вот что я увидел в плане пайпа

    $ ls -1al /proc/9174/fd    # find 
    0 -> /dev/pts/25
    1 -> 'pipe:[3796881]'  <--
    2 -> /dev/pts/25

    $ ls -1al /proc/9284/fd   # sleep
    0 -> /dev/pts/25
    1 -> 'pipe:[3796881]'  <--
    2 -> /dev/pts/25

    $ ls -1al /proc/9175/fd  # head
    0 -> 'pipe:[3796881]'  <--
    1 -> /dev/pts/25
    2 -> /dev/pts/25

отсюда видно что 
    в find подключается pipe на запись
    в sleep пайп подключется на запись 
    в head пайп открывается на чтение

и вот я не очень понимаю. пайп изначально открывается для find и head.
в процессе работы pid процессов find и head неменяется. пайп тоже неменяется вообще.
sleep запускется и убивется каджый раз новый для каждого файла.
так вот когда head закочит свою работу то сигнал об этом будет послан в его родителя
в bash(3689) и поскольку изначально баш устанавливает пайп между find и head
и оба из них дети родителя bash(3689) то как я понимаю в ответ на гибель head
баш должен послать сигнал и закончить работу процесса find. 
почему он продолжает раобтать мне непонятно. кто виноват. баш не шлет сигнал
или find отказывается закончить работу? непонятно... в итоге получаем сигнал 13 "broken pipe"
потому find продолжает работать, держать открытм пайп, продолджает породждать процесссы -exec
и этот -exec file создается так что у него stdout открыт на запись в пайп. он пытается писать
в этот пайп но читать то этот пайп некому поэтому возникает ошибка.
тоесть проблема в том что когда head -n5 заканчиввает свлю работу то find ее почемуто не заканичивает.
еще раз покажу пример

    $ find . -maxdepth 1 -type f -exec  file '{}'  ';' |  head -n2
    ./1.txt: empty
    ./3.txt: empty
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13
когда же мы убираем -exec 
то все окей с прерыванием работы find когда head закончил свою работу
    $ find . -maxdepth 1 -type f  |  head -n2
    ./1.txt
    ./3.txt

кстати совать пайп под -exec не имеет смысла. потому что под -exec обрабатывается только один файл.
тоесть
в этом нет смысла
    $ find . -maxdepth 1 -type f -exec  bash -c 'file {} | head -n2'  ';' 

у нас под башем комагда file "1.txt"  | head -n2 
в ней нет смысла котоырй мне нужен. а смысл такой что я хочу чтобы как только 5 строчек файнд выплюнет
то его работа закончилась.

пайп конечно можно вставить. только надоо погимать зачем. чтоон делает

тоесть вот пример
$ find . -maxdepth 1 -type f -exec  bash -c 'stat  {}'  ';' 
  File: ./1.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15073824    Links: 1
Access: (0400/-r--------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-12-10 23:57:18.335641448 +0600
Modify: 2023-12-10 23:57:18.335641448 +0600
Change: 2023-12-11 01:02:11.447191099 +0600
 Birth: -
  File: ./3.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15073826    Links: 1
Access: (0444/-r--r--r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-12-10 23:57:21.627646002 +0600
Modify: 2023-12-10 23:57:21.627646002 +0600
Change: 2023-12-11 01:02:32.155191286 +0600
 Birth: -

 я хочу обрезать статстику по каждому файлу. тогда можно пайп засунуть под -exec
 вот пример
    $ find . -maxdepth 1 -type f -exec  bash -c 'stat  {} | grep -E "File|Uid"'  ';' 
    File: ./1.txt
    Access: (0400/-r--------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    File: ./3.txt
    Access: (0444/-r--r--r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
в этом случае пайп делает то что нам надо безусловно но это другой пример. 
учитывая проблемы с пайпом из под -exec тогда проще xarg заюзать


тоесть вместо 
     $ find . -maxdepth 1 -type f -exec  file '{}' ';'| head -n2  

    $ find . -maxdepth 1 -type f | xargs -L1  file | head -n2
    ./1.txt: empty
    ./3.txt: empty
    xargs: file: terminated by signal 13

блин все равно ошибка 13 что за хрень.
я считаю что xargs неумеет коректно сам себя гасить кода к нему прилетает от родича сигнал 
прекратить работу. потому что вот аналогичный код
    $ for i in 1 2 3 4 5; do echo $i; done | head -n5  | head -n1
    1
нет никаких проблем у команд в цепочке погасит себя
а вот простейщий код с xargs который не гасит себя 

    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 echo  | head -n2
    1
    2
    xargs: echo: terminated by signal 13


и вот я нашел в инете как убрать ошибку
нужно вставить доп команду в цепочку "tail -n+1" (https://superuser.com/questions/554855/how-can-i-fix-a-broken-pipe-error)
тогда
    $ find . -maxdepth 1 -type f -exec  file '{}' ';' | tail -n+1 | head -n2 
    ./1.txt: empty
    ./3.txt: empty

или другое решение можно использовать awk

    $ find . -maxdepth 1 -type f -exec  file '{}' ';' | awk -v N=2 'NR<=N'
    ./1.txt: empty
    ./3.txt: empty



задания: <<<--=====---- остановился здесь
0) разобраться почему xargs+head 
выызывает error 13
во первых разобраться как работает tail -n +1
во вторых как работает awk -v N=2 'NR<=N'
    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 echo  | head -n2
    хотя вот такое не вызвыает
    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 echo  | tail -n +1 | head -n2
    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 echo  | awk -v N=2 'NR<=N'

с перфомансом тоже очень интересно. 
$ cat /home/vasya/~UNITPAY/krivosheeva/17830.txt | pv | head -n2 1>/dev/null
64,0KiB 0:00:00                                                                                                                                           ]
[vasya@lenovo docs]$ cat /home/vasya/~UNITPAY/krivosheeva/17830.txt | pv | tail -n +1 | head -n2 1>/dev/null
96,0KiB 0:00:00                                                                                                                                           ]
[vasya@lenovo docs]$ cat /home/vasya/~UNITPAY/krivosheeva/17830.txt | pv |  awk -v N=2 'NR<=N' 1>/dev/null
1,59GiB 0:00:05         
    
меньше всего прокачиать данных нужно естесвтенно через голый head
чуть больше через tail+head
и пиздец как много через awk

две ссылки  с ответом
    https://stackoverflow.com/questions/27800726/ls-terminated-by-signal-13-when-using-xargs/77637318#77637318
    https://superuser.com/questions/554855/how-can-i-fix-a-broken-pipe-error


1) разобрать примеры из man find (смотри на соседнем листе)
2) разобрать три ссылки
    https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html
    https://stackoverflow.com/questions/71284062/how-to-printf-fixed-number-or-digits-in-floating-in-bash
    https://unix.stackexchange.com/questions/589475/how-can-i-exclude-and-when-listing-only-hidden-items

3) продолжить разбор
    https://tldp.org/LDP/abs/html/fto.html







##  



=== остановился тут

$$$$$$$$$$$$$
$$$$$$$$$$$$$
$$$$$$$$$$$$$

вопросы:
- вернуть обратно модуля ядра чтобы coretemp опять заработал
- thermal zones
- yaml формат  в thinkfan
- <<<



- а как происходит запись в файл сразу двух процессов?
как при этом работает
$ : > file



-  изучить bash advanced guide
