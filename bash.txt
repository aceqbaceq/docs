bash


| $$
| $BASHPID


bash


вот мы  в баше написали команду и нажали Enter.
как же баш ее начнет "выполнять".
тут кстати два вариант либо эта команда это некий внешний 
левый бинарркник либо это башевский builtin.
поехали.

совершенно известно  как баш выполняет команду которая является 
внешним бинарником.
баш с помощью ядра  клонирует себя. тоесть создается +1 процесс.
внутри такой же самый как и исходный процесс. у нас получается два идентичных
баш процесса. просто они находятся в разных изолированных хренях - процессах.
при этом в новом процессе есть все переменные баща исходного. вообще в новом процессе
у нас ровно такой же баш. поэтому у нас есть вся полнота всей информации. переменные
и прочая хрень у нас все есть. далее в новом процессе бащ делает сисколл execve
который приводит к тому что ядро вырезает из этого процесса код баша и вместо 
него вставляет код бинарника команды которую мы хотим выполнить. я вскользь 
почитал про execve, как я понял ядро когда вырезает бинарник баща и вставляет 
бинарник скажем /bin/ls то оно как я понял вырезает нахуй буквально почти все
что было от баша. остается там от прошлого процесса хууй да нихуя - открытые файлы,
кастомные хендлеры сигналов вобщем мало что остается. я вот непонял насколько много
сил тратит ядро по времени на вырезание всей этой требухи от баша. я искал 
в инете а можно создать новый процесс снужным бинарником без предвариельной
создания копии от предыдщего процесса. вответ идут огромные портянки с таким
хуй пойми пиздежом что пиздец. они (интернетчиики) напирают на то что операция
клонирования это супер быстроая и простая операция по имплементации. у меня
возникает встречный вопрос - и что ? вы мне ответье что будет быстрее вырезать
после этого всю требуху от предыдущего процесса или создать процесс с нуля.
об этом эти ебаные специалисты молчат. они все пиздят как один тлько отом что 
создание клона это супер прсто и быстро.  а дальше этого они отказвыаются смотреть в
будущее.пиздец.  еще они упирают на вот что - когда мы запускаем новую команду
то ей нужно передать аргументы и ей нужно передать еще переменные окружения.
вот как выглядит execve вызов

   int execve(const char *filename, char *const argv[], char *const envp[]);

тут я малек впал в ступор - а вчем разница между аргументами и переменными окружения?
как я понимаю для себя аргумент это необязательно переменная. это просто кусок 
каких то данных например 

       ls -1 -f -t /mnt 

как видно аргументы это -1 ,  -f  ,   -t ,  /mnt
а переменные окружения это ПЕРЕМЕННЫЕ. они имеют вид a=1, arch=x86.
также как я понимаю аргументы это 100% нужная хрень чтобы команда успешно отработала
а переменные окружения это хрень которая может понадобиться команде а может и нет.
может так?
так вот они (интернетчики) пишут что обычно для запуска команды нужно дохрена
данных ввести. то есть например дохрена переменных окружения передать. или например
можно аргументы указать в форме переменной из баша и тогда башу при вызове execve
нужно будет только вставить указание на адрес переменной а ядро само найдет значение.
поэтому они говорят супер круто когда у нас execve запускается изнутри баша. типа дохуя
нужных данных уже "закачано" в память процесса. а еси создавать процесс с нуля то 
дохуя данных нужно было бы передавать как ссылку или даже копировать из одного процесса
в другой. короче - вопрос очень мутный почему же так?  факт только в том что оно 
точно так - в линуксе нельзя создать процесс с нуля. первый процесс pid-1 создает ядро.
а все остальные процессы создаются через клонирования+execve. я более чем уверен что
когда ядро выполняет execve оно вычищает просто дохуя требухи от баш процесса потому что
иначе получается что новый бинарник получит доступ к данных от другого процесса который
к этому бинарнику нихуя не имеют отношения и доступа. это была бы супер дырка
безопасности. итак почему неясно но как факт в линуксе нельзя создать проецсс с нуля.
можно толко сделать копию какого то процесса и запустить execve.
тогда вопрос - а нахуя баш запускает внешний бинарник (/bin/ls например ) путем
запуска его в другом процессе? почему баш не может прочиать /bin/ls в свою память
и передать ему управление. возможно это невозможно сделать из за строения линукса.
или потому что запускать чужой код внутри своего кода это наверное пиздец.
точно я не знаю. тоест наверное новвый код начнет лазить в память которая относится
к бащу и все в итоге сломается? наверное из за этого.
итак подвожу итог когда мы в баше пишем

    $ /bin/ls -1 /mnt

то баш запускает сисколл fork() тогда ядро создает новый процесс и он 
является клоном этого баша. далее код баша в этом новом процессе запускается с той
точки которая находится ровно за командой fork(). далее этот баш новый запускает
сисиколл execve со всеми параметрами. на это ядро вычишает всю требуху от баша
из процесса и сует туда /bin/ls со всеми теми параметрами которые бащ передал 
новому бинарнику через параметры execve. в народе это все называется fork()+execve()
вот по факту как баш запускает execve для ls -1 /mnt

# strace -e execve -a "$COLUMNS" -v   -s 2000  ls -1 /mnt
ключ -a дает то что вывод форматруется на укаазанное число колонок.
число колонок в окне терминала это $COLUMNS, я проверил реаально если менять размер
окна то эта переменная сразу меняется. 
ключ -v означает чтобы strace показал те переменные
которые передаются в сисколлах (иначе он просто пищет что было передано 15 переменных
а каких? а хуй знает)
ключ -s говорит какую длинну для значения каждой переменной показывать. если 
значение переменной длиннее то он дальше покаывает просто три точки. например 
переменная "LS_COLORS" она хуя знает какой длинны. если я укажу -s 4 то он 
покажет вот так "LS_COLORS=rs=0..." поэтому если я хочу видеть полное значение
длинных переменных то это число надо ставит большим.
ты такой типа - я чтото непонял в чем разница между -v и -s. разница в том что 
без -v стрейс вообще нахуй не покажет ни одной переменной которая была передана
ссисколлу. просто напишет что было передано 32 переменные. и все.
а -s позволяет настраивать какую длинну значения каждой переенной я хочу видеть на 
экране. 

итак вывод на экран будет такой

execve(
       "/bin/ls", 

       ["ls", "-1", "/mnt"], 

       [
        "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:", 

        "LC_MEASUREMENT=ru_RU.UTF-8", 

        "LESSCLOSE=/usr/bin/lesspipe %s %s", 

        "LC_PAPER=ru_RU.UTF-8", 


        "LC_MONETARY=ru_RU.UTF-8", 

        "LANG=en_US.UTF-8", 

        "SUDO_GID=1000", 

        "DISPLAY=:0", 


        "COLORTERM=truecolor", 

        "USERNAME=root", 

        "SUDO_COMMAND=/bin/bash", 

        "SSH_AUTH_SOCK=/home/vasya/.ssh/ssh-agent.lenovo.sock", 

        "LC_NAME=ru_RU.UTF-8", 

        "USER=root", 

        "PWD=/home/vasya/temp", 


        "HOME=/home/vasya", 

        "SUDO_USER=vasya", 

        "LC_ADDRESS=ru_RU.UTF-8", 

        "LC_NUMERIC=ru_RU.UTF-8", 

        "SUDO_UID=1000", 

        "MAIL=/var/mail/root", 

        "SHELL=/bin/bash", 

        "TERM=xterm-256color", 


        "SHLVL=1", 

        "LANGUAGE=en_US", 

        "LC_TELEPHONE=ru_RU.UTF-8", 

        "LOGNAME=root", 

        "XAUTHORITY=/home/vasya/.Xauthority", 

        "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin", 

        "LC_IDENTIFICATION=ru_RU.UTF-8", 

        "LESSOPEN=| /usr/bin/lesspipe %s", 

        "LC_TIME=ru_RU.UTF-8", 

        "_=/usr/bin/strace"
                             ])


итак как я уже скзазал execve имеет три части при запуске.
первая часть это путь к бинарнику
           "/bin/ls", 
втоая часть это так назыаемые аргументы команды. эта та хрень без которой
команда незнает чо ей вообще делать
               ["ls", "-1", "/mnt"], 
(ха. напоминает формат entrypoint в Dockerfile. как вспомню так вздрогну)
забавно то что имя файла тоже почемуто должно быть вкючено в строку аргументов.
третья част самая огромная это переменные которые тоже передаются. 
       [
        "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:
        ....]

еще раз скажу мое мненеие  в чем разница между аргументами и переменными.
переменная это всегда 
    имя=значение
а аргумент не вседа имеет такой формат. также аргумент эта первостпенной важности
информация без нее команда 100% неотработает ибо не будет знать что от нее хотят.
переменные окружения или просто переменные это информация второстепенной
важности. может какието пеерменные нужны будут команде а может и никакие.
я так это понимаю.
тоесть вот тако пофакту у нас баш запускает ls



Далее важный момент,
если мы в строке баша вбили не внешний бинарник а так назаемый билтин баша
то ни fork() ни execve() на запускается. вместо этого в рамках текущего процесса
баш просто напросто начинает выполнять одну из своих внутренних функций.
билтин это кусок кода самого баща который умеет чегото делать сам. тоесть 
с одной стороны баш позволяет запускат другие программы а с другой стороны
он чтото умеет делать и сам. когда он умеет чтото делать сам то нахера
ему делать форк() и тем более execve()


а вот я добавил доп переменную которую баш передал в ls при запуске
# vasya="446" strace -e execve -a "$COLUMNS" -v   -s 20  ls -1 /mnt

execve("/bin/ls", ["ls", "-1", "/mnt"], ["vasya=446", "LS_COLORS=rs=0:di=01"...,

четко видно что переменная vasya=446 была передана  в строке переменных 
при запуске ls !
также видно подйстввал ключ -s 20 у нас вместо огромного значени LS_COLORS
strace напечатал лишь его маленткий кусок

если посмотреть внимательно наверх. там где я показал 
какие переменные баш передало в ls то можно вдруг заметить что во первых 
там переменные указаны без знака "$" хотя наверное это  и логично ибо коода
переменная задается то у нее нет в имени доллара. тоесть скажем когда 
мы пишем echo $vasya то имя переменной vasya а не $vasya. но тогда замечается
вторая удивительная вещь это то что среди  тех переменных нет двух важных
часто встречающихся переменных  с именами "$" и "BASHPID"
их там абсолютно нет! во как!!! а нет их там потому что баш не передает эти переменные
в execve когда он запускает внешний бинарник! тоесть он не передает эти переменные
через третью секцию execve (как я думал). он их передает через секцию аргументов!
используется так назаываемый globbing в баше. щас покажу.
значит мы дали команду

    $ /bin/echo $BASHPID

баш форкнулся. далее ему надо по плану запускать execve. ему чтобы его запустить 
нужно составить секцию вторую "секцию аргументов". баш начинает анализировать строчку
которую мы ему послали. и баш понимает что в строке что мы ему задали стоит $BASHPID 
и баш погнимает что это егоная переменная. точнее эта запись означает что нужно вставить
ЗНАЧЕНИЕ это переменной. тогда он достает из памяти ее значение и при запуске execve
он сует  в секцию аргументов ЗНАЧЕНИЕ этой переменной а не стринг $BASHPID
поэтому execve выглядит в итоге вот так

# strace -e execve -a "$COLUMNS"    -s 20  /bin/echo $BASHPID

execve("/bin/echo", ["/bin/echo", "506761"], 0x7fffa63f0ef8 /* 33 vars ) = 0

тоесть при запуске execve баш сует 506761. таким образом баш не сует в execve 
саму переменную в виде BASHPID=506761 в третью секцию! он сует уже готовое значение
во вторую секцию аргументов!

показываю на примере самописной c программы. чтобы показать что дело не в
волшебном бинарнике /bin/echo. что $BASHPID может напечатать любая программа


#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <locale.h>
#include <string.h>

int main(int argc, char *argv[], char *envp[])
{



int i=0;
while(argv[i]) {
  printf("%s\n", argv[i]);
  //do something
  i++;
};




exit (0);

}




$ gcc -o 155.exe 155.c

программа работает так. когда она запускается то то что ей execve передает во второй
секции она копирует в массив argv. а потом я просто печатаю что же там в этом массиве
нам напередаавали.

запускаю на выполнение

$ ./155.exe  $BASHPID
./155.exe
492977

а теперь покажу через strace

$ strace -e execve -a "$COLUMNS"    -s 20  ./155.exe  $BASHPID

execve("./155.exe", ["./155.exe", "492977"], 0x7ffd144e5238 /* 72 vars */) = 0
./155.exe
492977

тоесть execve передает массив аргументов ["./155.exe", "492977"]
моя программа его принимает и записывает в переменную. и потом печатает что 
же там лежит

соотвевтенно как работает программа /bin/echo она ровно также и рабтает просто 
она из этого массива непечатает первый член. потому что он у нее будет "echo"
и он нам нахер ненужен.

если я в программе выше поменяю
    int i=0;
на 
    int i=1;
то она зараотат в точности как программа /bin/echo



а вот программа которая принимает и запоминает в переменную третью секцию execve
и печаатает ее

#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <locale.h>
#include <string.h>

int main(int argc, char *argv[], char *envp[])
{

int i=0;
while(envp[i]) {
  printf("%s\n", envp[i]);
  //do something
  i++;
};


exit (0);



}



$ gcc -o 156.exe 156.c
$ ./156.exe

соотвевтенно мы увидим ровно тоже самое что показал выше strace

CLUTTER_IM_MODULE=xim
LS_COLORS=rs=0:di...
LC_MEASUREMENT=ru_RU.UTF-8
_LXSESSION_PID=4753
XDG_CONFIG_HOME=/home/vasya/.config
...
...


соотвственно стало понятно что если мы в баше вбивает команду. а потом
после нее пишем какито башевские переменные то он при вызове execve вставляет их ЗНАЧЕНИЯ
в секцию аргументов (во вторую секцию) execve.
и если бинарник который запускается так написан что он печатает массив аргументов
который ему передается то мы на экране увидим значение переменной баша. тут важно я хочу
подчеркнуть что эта переменная не передается в третьей секции execve и также 
эта переменная когда запуститься этот новый бинарник не лежит  в его памяти в виде BASHPID=123123
это ничего нихрена нет. в бинарник просто поступает число которое баш вставляет при вызове
execve. 

зачем я так про все это распинался???????
потому что щас переходим к самому главному. у баша есть переменная $BASHPID
в ней хранится номер текущего процесса баша. 
я запускаю команду 

$ builtin echo $BASHPID
492977

то что я пишу builtin это говорит башу чтобы он использовал не внешний бинарник /bin/echo
а его внутреннюю функцию. это нам дает то что баш выполняет код без форкания в текущем
процессе. и показывает нам номер именно текущего процесса.

если мы несколько раз запустим то увидим одно и тоже

$ builtin echo $BASHPID
492977
$ builtin echo $BASHPID
492977
$ builtin echo $BASHPID
492977


все правьно потому что мы код выполняем в одном и том же процессе. мы из 
него никуда не вылезаем

далее запускам внешнюю программму 155.exe

$ ./155.exe $BASHPID
./155.exe
492977
$ ./155.exe $BASHPID
./155.exe
492977
$ ./155.exe $BASHPID
./155.exe
492977

или внешнюю программу /bin/echo

$ /bin/echo $BASHPID
492977
$ /bin/echo $BASHPID
492977
$ /bin/echo $BASHPID
492977

мы видим что у нас цифра на выходе не меняется. а как же это так получается?
ведь уже понятно что при запуске внешней программы баш себя клонирует. получается НОВЫЙ
процесс с ДРУГИМ pid. но это все еще баш процесс. и потому этот новый баш процесс в новом
процессе запускает execve и он должен подставить значение переменой $BASHPID.
но баш почему то эту переменную не обновляет до актуального значения! и подставляет 
ее значение которое было у его родителя. получается мы видим брехню. мы видим pid не текущего
процесса а того - родительского баша! ты скажешь ну ведь в текущем процессе уже нет баша.
нахер ему было обновлять. да его уже нет но он же был в этом процессе! или баш 
рассужает так что - ага я буду запускать execve я щас сдохну поэтому зачем мне
обнволять BASHPID до актуаьного значения. типа эта ж переменная сообщает pid проецесса в 
котором по прежнему крутится баш, а в этом процессе я щас исчезну. поэтому сообщу как 
я пид моего родителя! походу так !

получается через конструкцию
$ /bin/echo $BASHPID
мы не узнаем какой pid был у echo процесса! мы только узнаем какой pid у баша
из которого этот echo был запущен!

$ builtin echo $BASHPID
ну а здесь понятно. здесь эхо это билтин. поэтому он покажет именно пид текущего 
процесса.

для сравнения с помощью pstree можно увидеть именно pid текущего процесса тоесть
самого pstree

$ pstree -AspT $BASHPID
...---bash(492977)---pstree(516119)
соотвтвенно видно что сам pstree крутится в процессе с пид=516119
а был он запущен из баща с пид=429977


я модифицировал 155.c
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <locale.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

int main(int argc, char *argv[], char *envp[])
{



unsigned int i=1;
while(argv[i]) {
  printf("$%u=%s\n", i, argv[i]);
  //do something
  i++;
};


pid_t p;
p=getpid();
printf ("pid=%u\n", p);


exit (0);



}



она показывает что ей передал баш через execve в секции аргументов (какое значение
бащ передал в качестве переменной $BASHPID)
и также программа делает запрос про свой текущий pid

$ ./155.exe $BASHPID
$1=492977
pid=516347

и вот мы видим что фактически программа исполняется  в процессе с пид=516347
и в нем же какоето время жил баш процесс. но он незахотел обновлять переменную $BASHPID
и подставил значение прежнее , тот пид который был у баша до клонирования.
а между прочим баш прекрасно понимает что он был клонирован. так что он мог спокойно 
актуализировать свою переменную. но он этого не делает.


а вот смотри интересно

$ builtin echo $BASHPID
492977
$ ( builtin echo $BASHPID )
516418

я запустил субшелл. это всего навсего когда баш себя клонирует и в новом процессе
выполняет те команды которые указаны внутри скобок.  получается он себя склонировал 
и в том же процессе он выполнил кусок своего же кода и получается что баш увидел 
что в том баше ему запускать execve ему ненадо. что ему сдыхать ненадо. и тогда он 
очевидно обновил свою переменную и показал уже номер процесса того склонированного баща 
а не до того как он склонировался!

вот обьединенеи двух команд в одну
$ builtin echo $BASHPID  $( builtin echo $BASHPID )
492977 516467

субшелл нужен тгда когда мы хотим выполнить серию команд и то что в итоге
получится на выходе из stdout получит в наш исходный шелл в качестве аргумента 
или аргументов в строке.

ну вот типа такого

$ echo $( echo "2+3" | bc ) "+" $(echo "4+5" | bc ) | bc
14


двигаем дальше
$ builtin echo $BASHPID  $( builtin echo $BASHPID; ./155.exe $BASHPID )
492977 516581 $1=516581 pid=516582


у нас первый echo так как это билтин и башу форкаться ненадо показал 
номер процесса баша 492977 который был изначально в терминале.
второй билтин эхо работал уже в субшелле тоесть уже в новом процессе баша
тоесть пид поменялся и так как баш увидел что execve ему не грозит в течение
этой команды то он обновил BASHPID и поэтому 516581 это номер пида субшелла.
далее баш этого субшелла увидел команду 155.exe , поэтому он себя склонировал
и далее он увидел что ему грозит execve и смерть и он обновлят BASHPID нестал! и поэтому
третье число 516581 это не номер процесса в котором потом начал исполняться 155.exe 
это номер родительского баща (Субшелла). и последнее число 516582 это уже сам
код 155.exe сделал запрос и спросил эй ядро в каком процессе я щас кручусь?  и конечно
это не 516581 а 516582

поэтому в итоге если мы в терминале написали команду
$ echo $BASHPID
456789
то она покажет пид процесса БАША из которого мы запустили команду echo.
(неважно встроенная она или внешняя). но надо ЧЕТКО понимать что если исполнялся
внешний бинаркник /bin/echo то пид 456789 это не тот пид в котором выполнялся /bin/echo !

ДАлее. есть еще одна коварная переменная баша с именем "$" соотвевстенно 
ее значение смотрится через "$$"

$ builtin echo  $BASHPID  $$
492977 492977

пока все нормально

$ builtin echo  $BASHPID  $$   $( builtin echo  $BASHPID $$  )
492977 492977 516781 492977

а вот тут уже интереснее !

есть еще одна инересная переменная которая нам щас тоже пригдится $BASH_SUBSHELL

$ builtin echo  $BASHPID  $$ $BASH_SUBSHELL   $( builtin echo  $BASHPID $$ $BASH_SUBSHELL )
492977 492977 0 516939 492977 1


так вот переменная $$ она показывает какой пид у того баша в котором мы команды
вводили ручками. потому что в субшелле мы уже ничего руками не вводим. там уже команды
все заранее прописаны. поэтому там где BASH_SUBSHELL = 0 то это значит тот баш интератктивный
там где мы вводим команды руками и там $$ = $BASHPID
а когда прваливаемся в субщеллы там $$ уже показывает не текущий номер бащ процесса
а того далекого родителя с которого все началось

$ builtin echo  $BASHPID  $$ $BASH_SUBSHELL   $( builtin echo  $BASHPID $$ $BASH_SUBSHELL; ./155.exe $BASHPID $$ $BASH_SUBSHELL )
492977 492977 0 
517031 492977 1 
$1=517031 $2=492977 $3=1 pid=517032


итак первые три переменные печатались билтином баша  в своем собсвтенном процессе.
причем это был интерактивный процесс. поэтому $$=$BASH_PID = 492977 это тот номер 
процесса с которого мы начали. $BASH_SUBSHELL=0 потому что это был интерактивный процесс.
другими словами $$ и $BASHPID показали реально тот процесс в котором код реально
исполнялся. 
дальше у нас субшеел прэтому $BASH_SUBSHELL=1 поэтому $$ уже не субшелла а родителського
прцоесса который был интерактивным поэтому $$=492977
и так как echo был билтин и форкаться ненужно было то $BASHPID=517031 показал
в каком процессе код выполялся. 
далее этот субшелл увидел 155.exe поэтому он форкнулся в новый процесс. далее баш увидел 
что ему предстоить смерть через execve поэтму он уже BASHPID не обновлял поэтому он 
равен уже пид предыдушего баш процесса 517031. $$ он тоже не менял потому что данный 
процесс нето что не интерактивный баш он вообше щас башем перестанет быть. 
и BASH_SUBSHELL он тоже не менял потому что это уже щас будет не баш и не субшелл. 
теперь нарисую это в таблице

   интерактивный баш    реальный pid   $BASHPID   $$        $BASH_SUBSHELL   субшелл   builtin    
        да                 429977       492977   492977          0             нет        да
        да                 517235       492977   492977          0             нет        нет
        нет                517031       517031   429977          1             да         да
        нет                517032       517031   429977          1             нет        нет


из чего вылезает вывод $BASHPID нам показывает pid того баша который максимально 
к нам близок если двигаться наверх. неважно интеравтивный он или нет.
$$ нам показвыает ближайший наверх баш интерактивный в котором мы руками набивали команды

ппц

я запустил такую команду

$ builtin echo $( sleep 90 ) $(sleep 180 )

и я думаю слушай а как так баш получит данные стрго вначале от одной команды 
а потом от другой. а потом запустил ps aux и pstree и увидел
баш запускает эти субшеллы последовательно. первый отработал потом только второй!


$ ps aux | grep sleep
vasya     517374  0.0  0.0   7400   796 pts/3    S+   06:44   0:00 sleep 90


$ pstree -AspT 492977
---bash(492977)---sleep(517385)


   

кстати те переменные которые баш сует в третю секцию execve можно осмотреть в
баше через 
    $ env
не знаю все ли он оттуда их сует . но часть точно!





разбор примеров
# /bin/echo $BASHPID
31078
# builtin echo $BASHPID
31078

тут все понятно. показывает одно и тоже потому что показывает пид процесса 
ближайшего наверх у которого внутри сидит бинарник баща! во как!
в первом случае это родитель процесса под который внешнее эхо работает.
во втором случае это и есть сам процесс


вот еще пример
$ builtin echo $$
513079
$ ( exec /bin/echo $BASHPID )
517633

он интересный. итак мы сидели в баше у которго был пид 513079.
потом мы запустили субшелл. в итоге баш клонировался и мы оказались 
в новом процессе. в нем тоже заработал баш. далее он увидел что надо выполнить
внешнюю команду но без форкания а прям в этом процессе тогда он 
в этом процессе выполнил execve но почему то он в execve передал не прошлый пид
а обновленный хотя он же видел что ему щас кранты и что он щас будет погибать.
непонятно чем этот execve лучше чем вот такой
$ builtin echo $BASHPID
513079
$ /bin/echo $BASHPID
513079

тоесть здесь мы сидели в 513079 потом баш увиел что нужно выоплнить бинарник
он форкнулся. далеее он уивдел что нужно execve но ему он передал старый пид.


еще пример 
$ ( builtin echo $BASHPID; /bin/echo $BASHPID) 
517782
517782

ну тут уже все ожидаемо. первая комнда написала текущий процесс в котором
она и выполнялась. вторая команда вызвыала форк и execve но баш увидел что 
щас сдонет поэтмоу не стал обновлять пид и передал старый поэтому он тот же самый 
хотя процесс уже был другой в котоором все выполнялось)


==
ебаьб еще одна наебка
смотрю на два файла

# stat /bin/echo
  File: /bin/echo
  Size: 35120       Blocks: 72         IO Block: 4096   regular file
Device: 801h/2049d  Inode: 1555        Links: 1

# stat /usr/bin/echo
  File: /usr/bin/echo
  Size: 35120       Blocks: 72         IO Block: 4096   regular file
Device: 801h/2049d  Inode: 1555        Links: 1

не могу понять. оба файала регуляр файлы. тоесть не симлинки. при этом 
одна и таже инода. и Links 1. да что за хуйня. а потом оказывается
что ПАПКА /bin/ это симлинк на папку /usr/bin
ДА Е МАЕ!!!!!!

в заключении скажу вот что , посмотрим на execve

   int execve(const char *filename, char *const argv[], char *const envp[]);

он передает данные в новый процесс через два массива argv[] и envp[]
так вот у баша его две переменные $$ и $BASHPID
их нет в переменных окружения. тоесть их нет в 
    $ env
а это значит что эти переменные точно не передаются башем при запуске execve 
через массив envp[]!
это важно понять. а передается только  значение той переменной
или переменных которые мы указали в командной строке через массив argv. 
тостть если например мы написали
    $ /bin/ls -1 $BASHPID
то значеение $BASHPID будет передано в execve через массив argv[]  в виде 
подставленного значения этой переменной например 6556




===












| array

инеересная вещь это как указать напечатать только часть индексов

    $ a=(1 2 3 4 5 )


    $ echo "${a[@]:1}"
    2 3 4 5


а вот еще
как напечатать часть индексов
    $ a=(1 2 3)
   $ echo "${a[@]:0:1}"
    1

    


| compare
| float



в баше работа идет только со стрингами.
частны случаем является его работа с целыми числами. он может 
только с ними работа.
задача - как сравнить два float цисла
ответ
    $ (( $( bc <<< " 4.3 > 5.4") )); echo $?
    1


    
| base
| conversion

в баше все пеерменные имеют один тип это string.
тоесть набор литер. но если все литеры являются числами
то баш понимает что это числа. 
так вот числа можно присвивать нетлько в десятично виде но и 
любом другой системе счисления 
чтобы это срабтало надо это делать через let

hex задаетя в виде 0x
октал задается в виде 0...

    $ let a=0x34
    $ echo $a
    52

    $ let a=034
    $ echo $a
    28

    
а если мы говорим про произвольну систему то через N#...


    $ let a=16#a
    $ echo $a
    10


    $ a=(1 2 3 4 5 6 7 8 9 10 11)
    $ echo ${a[16#a]}
    11


а вот еще актуальные приммер 

 
    $ a=( 00 01 02 03  04 05 )
    $ echo ${a[*]}
    00 01 02 03 04 05

я хочу напечатать элемент 05
я делаю 

    $ echo ${a[5]}
    05

    
если я вот так попробую

    $ echo ${a[05]}
    05

то 05 внутри [05] бдует проинтрпетирован башем как то что я подставил внутрт [] число
в ОCT виде. потому что если перед числом стоит 0 значт это число ввели в OCT виде.
нам повезло что 05 в OCT это 05  в десяичном виде.

а вот так будет ошибка

    $ a=( 00 01 02 03  04 05 06 07 08 09 )
    $ echo ${a[09]}
    bash: 09: value too great for base (error token is "09")

потому что 09 неможет бытт в OCT виде. так как там можгут быть только цифры 0 1 2 3 4 5 6 7

можно и без массива эту ошибку спрвоцировать

    $ let b=09
    bash: let: b=09: value too great for base (error token is "09")

    
но можно ее и вот так обойти

    ]$ let b=10#09
    $ echo $b
    9

очень интерсно!
тоесть мы через 10#...  говоорим бащу что все следущие значки 
это число в dec формате поэтому вот такое тоже прокатит

    $ let b=10#0000000000009
    $ echo $b
    9

WOW!!



| array

как быстро его набить инциализовать цифрами

    $ a=( $(seq 10) )
    $ echo $a
    1
    
    $ echo ${a[*]}
    1 2 3 4 5 6 7 8 9 10

классно!

сть еще вариан но он менее гбкий
    a=( {1..10} )
  
самое смешное что я ненашел как быстро создать массив нужной длины составленный
из единиц например тоесть из одинаковых эелментов. как это сделать без for непонятно
 
    
| var

первая констукрция дает то что если перменная пустая то вместе ее пустого
значения будет вернуто то что указано после -  тоесть default 
в данном случае. при этом значние перменной неизменяется
    $ echo $a
    $ echo "${a:-default}"
    default
    $ echo $a
    пусто
    
    
а этот делает другое. если перемеая неопределена. то ее значение 
ихменяется на то что после = тоесть default

    $ echo "${a:=default}"
    default
    $ echo $a
    default

| var

пеерменую можно обьвляь на лету
    $ [[  "a=$(ls -1 | wc -l)" -gt  2 ]]; echo $a
    114

    
    
| array
приколная щтука. как нам в массиве найти послдений эелемент
есть хак

    a=(1 2 3)
    echo "${a[-1}"
    
тоесть  индеккс -1 дает нам хвоаст. круто!


    
| приколы

приколы баша
$ echo !4
echo ps aux | grep sleep
$ echo !0
bash: !0: event not found
эта хрень показывает команды из истории команд


| tr

эта комнда ищет паттерн и меняет его на другой

$ echo " output=10; input=16; A0" | tr [:lower:] [:upper:] 
 OUTPUT=10; INPUT=16; A0


$ echo "aaa bbb " | tr "a" "D"                             
DDD bbb 



эта команда он подлая. об этом можно прочитать в info tr
вот пример

$ echo "b" | tr  bbbbb  12345
5

вчем подлость команды tr : у нас в паттерне есть несколько b возникает вопрос
когда мы находим b в нашем слове то какой b использовать? тот который b в 1 превращает
или b который в 2 превшращает? или b который в 5 превращает?
ответ такой что берется самый последний b. поэтому все b пропускаются в шаблоне
и берется последний b кторый превращает b в 5.

еще пример

$ echo "a"  |  tr    aaaaaaaaaa 1234567890
0


тоесть у нас есть шаблон aaaaaaaaaa у нас естт исходное ссобщение 'a'
возникает вопрос какой a нужно брать из шаблона. овтет последний.
потом смотрим на какой символ мапится последний a  в шаблонке ответ а ноль.


прмиер

$ echo ooops not good | tr oops nice
iiice nit giid

как это рабооает. 
у нас есть шаблон "oops" у нас есть слово "ooops"
в шаблоне берем последний "o" он мапитсят в "i" получается

[ooo]ps -> [iii]ps

остатеся вопрос с ps он мапиисят напрямую поэтому 

[ooo][ps] -> [iii][ps] = iiips

далее берем слово "not"
берем шаблон "ooops" 
в шаблоне "n" нет. есть "o" но в шаблоне "o" несколько. мы берем последнее "o"
второе "o" мапится в "i"

потмоу что o[o]ps n[i]ce

значит n[o][t] --> n[i][t]
бквы t нет в шаблоне значит t остается без изменений значит

not -> nit

берем слово "good"
ни g ни d нет в шаблоне они без изменений. 
буква o есть  в шаблоне. их несколько в щаблоне мы беерм послнее o в щаблрне оно маится в
i значит

g[oo]d  --> giid

значит в итоге 

iiips nit giid

в целом намой взгляд достоачно неинтуитивная и ебанутая команда этот tr


| special variables $0 $1 $@  $# $* $? $$ $!

`$0` – The name of the script being executed.
`$1-$9` – The first nine command-line arguments.
`$#` – The number of command-line arguments.
`$*` – All command-line arguments as a single string.
`$@` – All command-line arguments as an array.
`$?` – The exit status of the last executed command.
`$$` – The process ID of the current shell.
`$!` – The process ID of the last background command.


рассмотрим $0
я не согласен то о чем везде пишут что $0 это имя скрипта.
посмотрим

$ echo $0
bash

$ /bin/bash
$ echo $0
/bin/bash


$ ln -s /bin/bash ./b-lnk
$ ./b-lnk
$ echo $0
./b-lnk


$ ln -s ./b-lnk ./c-lnk
$ ./c-lnk
$ echo $0
./c-lnk

отсюда видно что $0 эта переменная показывает каким образом был запущен процесс.
а именно его такой параметр как /proc/$$/cmdline

/proc/self vs /proc/$$/ (self это не перменная. это симлинк в /proc/)

запускаем чтото в баше . тогда он себя форкает через сисколл(просит об этом ядро тоесть)то создает дочерний процесс
а вот если в баше прога зпускатся через exec то баш взывает сисколл exec тоесть управлениеп
передаетая ядру. и ядро замещает усовно говорят код баша в процессе в котором крутится баш 
на код вызываемой программы.  

мы импользуем exec когда не хотим создавать новый процесс. а хотим запустиьт прогу
в рамкаж уже этого процесса. 



--
вот так верно

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c", "sleep 120"]

а так полет нахер

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c sleep 120"]

--
вот так верно

docker run --rm --name t1 -it    --entrypoint  "/bin/bash"   ubuntu  -c "sleep 120"

а так полет рахер

docker run --rm --name t1 -it    --entrypoint  '/bin/bash -c "sleep 120"'   ubuntu  
отому что в доках дкоера написано что --entrypont должно сдежать татолько
путь к бинарнику\скриту. но не к параметрам. параметры пишктая в самом справава



==

| -
| ~-

в баше любили повыебвыаться.

если мы в качестве пути укажем "-" то баш подставит вместо этого $OLDPWD
где OLDPWD это сохранненный есть предыдущая папка в которой ты был.
но эта хрень раротботет только с встроенным билтином cd и только в единствнной форме

$ cd -
эквивалентно
$ cd $OLDPWD

при этом вот такое уже нераобтеает

]$ cd -/tmp
bash: cd: -/: invalid option
cd: usage: cd [-L|[-P [-e]] [-@]] [dir]

в эхо это тоже неработает

$ echo -
-


втора хрень "~-" она более универсальная. она раобтотает уже нетолько с cd
но и скажем с echo 

$ echo $OLDPWD
/
[vasya@lenovo //]$ cd ~-
[vasya@lenovo /]$ echo ~-
//


пиздец доблеблы в этом баш. выбеонщики

нашел этот все зесь = https://unix.stackexchange.com/questions/330876/difference-between-cd-and-cd
===
| bash
| redirect
| exec

bash
io redirect

(для начала ознакомился с этим https://tldp.org/LDP/abs/html/io-redirection.html)

разбереся как работает эта команда
       # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3

для начала
немного отойдем в сторону что будет если ввести команду
$ cat > 56.txt
а будет вот что. команда будет ждать ввода текста со стандартного ввода.
тоесть можно сидеть и набирать текст. когда хотим закончить набор то жмем Ctrl+D.
и этот текст набранный в терминале на экране будет записан в файл.

получается форма вида

# echo "asd" > /tmp/1.txt 
это укороченная форма команды
# echo "asd" 1 > /tmp/1.txt

и команда вида
# cat < 1.txt
это укороченный аналог
# cat 0 < 1.txt
(взял отсюда https://tldp.org/LDP/abs/html/io-redirection.html)

еще важная хуйня про io redirect
надо обязательно дескриптор файла ставить рядом без пробелов со знаками ">","<" итп.
тоесть

$ dfrtr 2>4.txt
$ cat 4.txt
dfrtr: command not found

тоесть видно что редирект сработал. мы ввели несуществующую команду.
при этом канал ошибок был заредиректен на файл 4.txt
видно что мы ввели "2>..." тоест между 2 и ">" нет пробела. 
такой редиректо сработает.

$ dfrtr 2 >4.txt
dfrtr: command not found

а этот редирект неработает. потому что у нас между 2 и ">" стоит пробел.

далее . разберем поподробнее пример
    $ dfrtr 2>4.txt

что в нем интересно это как оно выполняется.
у нас есть баш процесс и мы его просим запустить команду "dfrtr"
баш процесс выполняет сисколл и просит ядро создать новый процесс самого себя. когда клон исходного процесса
будет создан в форме нового процесса то баш в новом процессе ищет среди $PATH бинарник с именем "dfrtr"
ненаходит его и посылает на sterr ошибку. если бы бинарник был бы найден то баш склонированного процесса
выполнил бы еще один сисколл который просит ядро заменить в текущем процессе бинарник баша на бинарник dfrtr.
соотсвтвенно вопрос - кто кидает в stderr ошибку что файл ненайден - баш в склонированном процессе или ядро?
как я понимаю имеено баш запускает ряд сисколлов stat в разных папках которые у него прописаны в $PATH
и все сисколлы сообщают бинарнику баша что там такого файла нет. тогда бинарник баша пишет в sterr 
сообщение о том что файл ненайден. таким образом именно бинарник баша кидает на stderr сообщение об ошибке
я не ядро. потому что важно было понять кто занимается отправкой сообщений на stderr юзерская программа
или само ядро. 
вот доказательство

$ strace  bash -c "kuku"
...
stat(".", {st_mode=S_IFDIR|0775, st_size=1011712, ...}) = 0
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/sbin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/sbin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/bin/kuku", 0x7ffcfd0c62a0)   = -1 ENOENT (No such file or directory)
stat("/sbin/kuku", 0x7ffcfd0c62a0)      = -1 ENOENT (No such file or directory)
stat("/bin/kuku", 0x7ffcfd0c62a0)       = -1 ENOENT (No such file or directory)
stat("/usr/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/snap/bin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)

тоесть видно что бинарник баша ищет бинарник kuku во всех папках которые есть у него в $PATH
и ничего ненаходит.
...
write(2, "bash: kuku: command not found\n", 30bash: kuku: command not found
) = 30

и тогда бинарник баша сам лично через сисколл write пишет в дескриптор "2" об ошибке
я совершенно не утверждаю что в 2 неможет писать само ядро. но в данном случае ошибку генерирует
сам юзерский процесс.

так вот вовзращаемся к примеру
        $ dfrtr 2>4.txt
рассмотрим более простой пример для начала
        $ dfrtr
        dfrtr: command not found

кто гененриует ошибку? ответ склонированный бинарник баша генерирует.
у нас наш текущий процесс баша сам себя клонирует. дальше в дело вступает клонированный баш.
он начинает искать бинарник dfrtr по всем папкам прописанным в $PATH
ненаходит. и тогда он склонированный бинарник баша пишет в 2 о том что файл ненайден.
таким образом отвечаю на вопрос - если команда не найден то кто генерирует ошибку?
возвращаемся к примеру
         $ dfrtr 2>4.txt
наш текущий баш склонирует самого себя в новый процесс через сисколл к ядру.
плюс наш исходный баш попросит ядро чтобы при создании нового процесса его дескриптор 2 указывал 
не на pty файл ( не на терминал как это обычно бывает)  а на файл ./4.txt
таким образом привязку 2 к 4.txt для нового процесса делает ядро по просьбе родительского баша.
дочерний баш к этому не имеет никакого отношения. дочерний единственное что сделает это напишет в 2 
что файл не найден. гениально. мудота та еще...
важно еще то что такого рода редирект файловых дескрипторов происходит не для исходного процесса баша 
а исключительно для новых порождаемых процессов. это тоже важно отметить. 

теперь фундаментальный вопрос а как нам изменить привязку файловых дескрипторов не для новых 
порождаемых процессов а для текущего процесса в котором крутится bash
в этом нам поможет баш билитн exec


баш builtin exec
что он делает.
по дефолту если мы запускаем команду в баше то баш это процесс как любой другой.
когда мы запускаем команду то баш создает новый процесс и в нем уже запускает нашу команду.
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
тоесть видно что номер баш процесса 31410
когда мы в нем запустили команду pstree то баш создал новый процесс 31426
так вот exec заставляет бащ не создавать новый процесс а запустить эту команду в текущем процессе
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
$ exec sleep 120
$ pstree -Asp 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---sleep(31410)
видно что процесс 31410 остался но там уже не баш а наша команда. а нового процесса нет.

тут я добавлю полезняшку про pstree. 
если цепочка очень длинная то pstree порежет цепочку. поэтому нужно добавить флаг -l
чтобы цепочка былабы показана по всей длинне чтобы он не обрезад

обрезанный вид
$ pstree -Asp 9174
systemd(1)---lightdm(4560)---lightdm(4814)---lightdm(4930)---lightdm(4931)---lxsession(4932)---pcmanfm(5071)---lxterminal(6046)---b+

необрезанный вид
$ pstree -Aspl 9174
systemd(1)---lightdm(4560)---lightdm(4814)---lightdm(4930)---lightdm(4931)---lxsession(4932)---pcmanfm(5071)---lxterminal(6046)---
---bash(3676)---mc(3687)---bash(3689)---find(9174)---sleep(9176)


как видно не создавание нового процесса было выполненно через баш билтин exec . в виде

$ exec команда

итак "exec команда" не порождает новый процесс а в текущем процессе заменяет бинарник.
есть надежда что подключение io redirect вкупе с exec позволит нам изменить привязки файловых
дескрипторов для текущего процесса.

$ echo $$
32624
$ exec sleep 130 2>3-err.txt

итак у нас был баш процесс 32624 со стададартной привязкой его дескрипоров 1,2,3 к терминалу
далее мы говорим что в текущем процессе заменить баш на sleep и для этого процесса (для того же самого)
задать что файловый дескриптор 2 должен смотреть на файл 3-err.txt

проверяем
$ ls -1al /proc/32624/fd
total 0
dr-x------ 2 vasya vasya  0 окт  4 09:00 .
dr-xr-xr-x 9 vasya vasya  0 окт  4 09:00 ..
lrwx------ 1 vasya vasya 64 окт  4 09:00 0 -> /dev/pts/21
lrwx------ 1 vasya vasya 64 окт  4 09:00 1 -> /dev/pts/21
l-wx------ 1 vasya vasya 64 окт  4 09:00 2 -> /home/vasya/temp/3-err.txt

и это действительно сработало!
процесс по номеру не поменялся. зато его привязка для дескриптора 2 поменялась.

попробуем на этом фоне более интересный пример
запустить баш из баша при этом перенаправить его 2 в 5.txt
для начала я хотел показать одну важную вещь. вот  у нас есть баш процесс.
я думал что prompts приглашение этот процесс пишет в 1 тоесть в stdout
а оказалось что он его пишет на stderr! показываю

$ echo $$
31668
$ bash 1>7.txt
таким макаром я запустил новый процесс баша и его stdout я завернул на файл 7.txt
$ 
при этом как видно у меня на экране по прежнему присуствует prompt тоесть 
этот prompt он пишется процессом как я уже сказал не на stdout а на stderr

открываю другой терминал и проверяю что новый баш имеет то  редирект в файл который я сказал
(другой терминал)$ $ cat 7.txt 
2661
(другой терминал)$ pstree -Asp 2661
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31668)---bash(2661)
видно что новый баш это чайлд от головного баша
(другой терминал)$ ls -1al /proc/2661/fd
lrwx------ 1 vasya vasya 64 окт  4 10:27 0 -> /dev/pts/22
l-wx------ 1 vasya vasya 64 окт  4 10:27 1 -> /home/vasya/temp/7.txt
lrwx------ 1 vasya vasya 64 окт  4 10:27 2 -> /dev/pts/22
lrwx------ 1 vasya vasya 64 окт  4 10:27 255 -> /dev/pts/22
четко видно что наш дочерний баш имеет stdout завернутый в файл

так вот аналогично легко убедться что если мы запустим баш у которого stderr будет завернут
в файл то  у нас приглашение баша исчезнет с экрана потому что оно теперь будет писаться не в терминал а в файл
$ bash 2>8.txt

и все у нас на экране больше нет prompt

так вот до этого моменты мы создавали дочерний процесс баша у которого был настроен редирект одного из 
файл дескрипторов в файл. 
теперь сделаем тоже самое без создавания дочернего процесса.
в первом терминале запускаем
    $ echo $$
    2963
    $ exec bash 1>10.txt
    $ 

во втором терминале проверяем
$ pstree -Asp 2963
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(2963)
$ ls -1al  /proc/2963/fd 
lrwx------ 1 vasya vasya 64 окт  4 10:31 0 -> /dev/pts/23
l-wx------ 1 vasya vasya 64 окт  4 10:31 1 -> /home/vasya/10.txt
lrwx------ 1 vasya vasya 64 окт  4 10:31 2 -> /dev/pts/23
lrwx------ 1 vasya vasya 64 окт  4 10:32 255 -> /dev/pts/23

видно что исходный процесс 2963 не имеет чайлдов и что его 1 перенаправлен в 10.txt
таким макаром мы научились текущий баш процесс менять таким образом чтобы у него менялась 
привязка его файл дескрипторов. вот эта волшебная команда
        $ exec bash 1>10.txt
так вот в описании билитина exec написано что это можно сделать еще короче.
цитирую
$ exec --help
exec: exec ... [command] ... [redirection ...]
...
 If COMMAND is not specified,
    any redirections take effect in the current shell.

тоесть тут написано что если не указать никакой команды то получается что он автоматом меняет дескрипторы
указанные в [redirection] для данного процесса. 
проверяем
    $ echo $$
    3208
    $ exec 1>11.txt
    $ 

проверяем в другом терминале
$ pstree -Asp 3208
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(3208)
$ ls -1al  /proc/3208/fd
lrwx------ 1 vasya vasya 64 окт  4 10:39 0 -> /dev/pts/26
l-wx------ 1 vasya vasya 64 окт  4 10:39 1 -> /home/vasya/11.txt
lrwx------ 1 vasya vasya 64 окт  4 10:39 2 -> /dev/pts/26
lrwx------ 1 vasya vasya 64 окт  4 10:39 255 -> /dev/pts/26

и действительно да. процесс 3208 не имеет никаких чайлдов. и его 1 имеет редирект на файл!
гоча!

я бы еще как сказал хотя это не совсем верно. что если мы никакую команду не подставляем в exec
то баш сам автоматом как бы подставляем bash тоесть  как бы 
    exec 1>11.txt = exec bash 1>11.txt
хотя это не совсем так. потому что в первом случае он не меняет бинарник в памяти а во втором случае
он удаляет старый бинарник и сует в процесс новый бинарник. (ксатти сказать процесс получается это как бы коробка (типа фреймворк) плюс начинка в виде бинарника)


двигаем дальше. вот еще интересный пример который нам пригодится
$ echo $$
3554
$ exec bash 12<>12.txt
$ echo $$
3554
[vasya@lenovo ~]$ ls -1al /proc/$$/fd
lrwx------ 1 vasya vasya 64 окт  4 10:49 0 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 1 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 12 -> /home/vasya/12.txt
lrwx------ 1 vasya vasya 64 окт  4 10:49 2 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 255 -> /dev/pts/29

мы говорим чтобы в нашем текущем процессе был заменен бинарник на баш
и чтобы  в нашем процессе был открыт новый файловый дескриптор с номер 12 и чтобы этот файловый дескриптор
был связан с файлом 12.txt который будет открыт с флагами и на чтение и на запись.
что примечательно в этой команде. примечательно то что мы можем изменить для данного процесса
число его файловых дескрипторов. было 0,1,2,255 (правда какого хрена тут делает 255 непонятно. вернее понятно.
я же запускаю bash из некоего другого процесса скажем это gnome-terminal или xterm или из под граф оболочки 
и открытые файловые дескрипторы в родительском процессе автоматом наследуются и дочерним процессом вобщем щас нам этот 255 неважен) а стало 0,1,2,255,12.
таким макаром мы можем "прикрепить" к процессу дохрена файловых дескрипторов и дохрена открытых файлов.
при том что самому бинарнику процесса на этот абсолютно плевать. вот эти открытые файлы , прикрепленные файловые
дескрипторы они бинарник ни к чему не обязывают. это как в квартире понаделать больше окон. 
если процесс нехочет ни читать с данного файлового дескриптора ни писать в него то его никто к этому не обязывает. это как у машины добавить запасных колес. или в ящике понаделать новых дырок. тот кто сидит в яшике (бинарник)  может пользоваться этими дырками а может и нет. опять же что интересно у нас обычно один процесс родительский порождает некий дочерний процесс и родитель может заказать для дочернего процесса понаоткрывать 
для него кучу файлов. но дочернему процессу это может быть глубоко фиолетово. он может пользоваться открытыми 
для него файлами а может и нет. это никак не влияет на него. 
что еще важно это вот значок  "<>" он на самом деле никакого мистического значения не имеет. он на самом деле 
только значит то что в сисколле будет прописано что открываемый файл открывается с флагами "R+W" тоесть 
и на чтение и на запись. сразу в догонку скажу что значок ">" говорит через сисколл ядру что нужно открыть файл 
с флагом "W" а значок "<" говорит ядру что файл нужно открыть с флагом "R"
тоесть то что изначально называется редиректом. это корявое определение. это не редирект это команда ядру 
на то  с каким флагом нужно открыть файл. тоесть 
        $  echo 1 1>4.txt
комбинация "1>4.txt" говорит башу как ему выстроить сисколл который он будет пулять в ядро. 
сисколл должен быть такой что - надо открыть файл 4.txt причем с флагом "W" и привязать этот файл к дескриптору 1. ну да.. на последнем этапе можно скзаать что мы имеем дело с редиректом. но важно подчеркнуть что значки
"<" и ">" и "<>" их смысл не только редирект но и с каким флагом открыт файл на который они ведут. 
">" =  W
"<" =  R
"<>" = RW

еще пример 
        $ echo "abc" 12<>5.txt
здесь ксати тоже интересно. дело в том что echo это билтин баша. поэтому ему ненужно себя клонировать.
а он выполняет команду ровно в текущем процессе. так вот для текущего процесса будет открыть файл 5.txt
в режиме "RW" и будет создан файловый дескриптор 12 который будет прикреплен к текущему процессу 
сам же echo ясен банан выплюнет свой "abc"  в дескриптор 1. тоесть ему этот открытый дескриптор 12 
в целом нахрен не сдался. просто мы делая одно одновременно сделали и другое
причем насколько я понимаю баш он умный и он откроет этот файл и создаст дескриптор но как 
только билтин закончит работу то баш автоматом закроет файл и уничтожит дескриптор. вот 
доказательство
    $ echo "abc" 13<>13.txt
    abc
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:12 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 2 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:25 255 -> /dev/pts/31
тоесть еще раз так как echo это билтин то никого нового процесса создано не будет. все
будет делать в рамках текущего баша. поэтому я и смотрю список открытых файлов для текущего процесса.
и видно что никакого дескриптора 13 нет и в помине. он был создан и тут же обратно удален.
я так это понимаю.

совершенно другой коленкор когда мы через баш запускаем некую внешнюю программу и просим баш прилепить к ней
открытый файл. баш составит нужный сисколл для ядра. и мы все будем иметь.
    $ sleep 130 14<>14.txt

с другого терминала смотрим
    $ ps aux | grep sleep
    vasya     4806  0.0  0.0  14580   892 pts/31   S+   11:28   0:00 sleep 130
    $ ls -1al /proc/4806/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:29 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 14 -> /home/vasya/14.txt
    lrwx------ 1 vasya vasya 64 окт  4 11:29 2 -> /dev/pts/31

тоесть у нас баш себя клонировал тоесть попросил ядро создать новый процесс. причем при клонировании попросил 
ядро чтобы дочерний процесс имел открый файл 14.txt через дескриптор 14.
далее баш в дочернем процессе попросил ядро через  сисколл заменить свой
бинарник на sleep.
поэтому все так выглядит
еще раз подчеркну что значок "<>" в конечном итоге означае то что файл 14.txt открывается с флагами и на чтение
и на запись. флаг "<" открывает файл на чтение только, флаг ">" открывает файл на запись только
причем имеется ввиду для данного процесса. ничто мне не мешает из другого процесса попросить ядро открыть этот файл с другими флагами. тоесть скажем наш процесс открывает файл только на запись. а с другого процесса я прошу
ядро открыть файл на чтение. и таким макаром я спокойно читаю то что пишет туда первый процесс.

также попутно я покажу докажу что когда баш запускаем внешний бинарник то он создает новый процесс 
клонирует себя а если мы запускаем баш билтин то новый процесс не создается.
я запутил баш с номером процесса 4309
в соседнем окне я запустил strace
$ sudo strace -p 4309 -e clone,fork,execve
strace: Process 4309 attached

и в первом окне я запустил ls -1
и мне strace нарисовал
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fe0cc338a10) = 4589

а потом я в первом окне запустил echo 1
и мне strace ничего не нарисовал
это все доказывает

теперь переходим к интересному.
зная все что мы узнали выше я открою файл /dev/cpu_dma_latency
в текущем баше так чтобы он оставался открытым
    # exec bash 16> /dev/cpu_dma_latency;
    # ls -1al /proc/$$/fd
    lrwx------ 1 root root 64 окт  4 11:37 0 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:37 1 -> /dev/pts/32
    l-wx------ 1 root root 64 окт  4 11:38 16 -> /dev/cpu_dma_latency
    lrwx------ 1 root root 64 окт  4 11:37 2 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:38 255 -> /dev/pts/32

ну или можно было короче написать
    # exec 16> /dev/cpu_dma_latency;
мы открыли /dev/cpu_dma_latency на запись и прикрепили его к процессу через дескриптор 16
показываю чему он равен прям щас 
    # cat /dev/cpu_dma_latency  | od -t x1
    0000000 00 94 35 77
    0000004

теперь можно его изменить вот так
    # echo -en "0x00000258" 1>&16
здесь так как echo у нас шлет свои данные на stdout тоесть в 1 то я перенаправил в 16.
на low level уровне это работает так что по дефолту баш юзает сискол
write (1,"текст")
а когда мы ему дали подсказку то он делает
write(16,текст)

проверяем что сработало
# cat /dev/cpu_dma_latency  | od -t x1
0000000 58 02 00 00
0000004
да сработало получается.
такой вывод наоборотный потому что в оперативку много байтовой число пишется в little endian формате.
об little endian  читай в ext4.txt

также отмечу вот это "1>&16" знак амперсанда говорит бащу что мы делает перенаправление не в файл  с именем 16 на файловой системе а в файловый дескриптор 16. это две большие разницы.
ксати я щас попробую сделать запись в несуществующий дескриптор
    # echo -en "0x00000258" 1>&28
    bash: 28: Bad file descriptor
все верно. пошел нахер


итак еще раз
что было сделано
     # exec 16> /dev/cpu_dma_latency;
     # echo -en "0x00000258" 1>&16
для текущего процесса баща был открыт файл /dev/cpu_dma_latency на запись. и прикреплен к процессу через
дескриптор 16. фишка в том что он будет висеть открытым пока я его сам руками не закрою.
далее я делаю запись в этот файл через подскажу башу что писать надо не в дескриптор 1 как он это обычно
делает по дефолту а в дескриптор 16. после записи файл который скрывается за дескриптором 16 продолжает висеть открытым.
тут еще раз также подчеркну что когда мы работаем с io redirect то между номером дескриптора и значком
редиректа категорически нельзя чтобы были пробелы. тоесть 
         # exec 16> /dev/cpu_dma_latency;   # правильная команда

         # exec 16 > /dev/cpu_dma_latency;  # НЕправильная команда
         сразу вылезет ошибка. потому что баш будет интепретировать эту команду вот так
         # exec 16 1> /dev/cpu_dma_latency;
тоесть он будет пытаться найти бинарник с именем "16", заменить в текущем процессе баш этим бинарником
и заменит файловый дескриптор 1 чтобы он вел не на терминал а на файл /dev/cpu_dma_latency
тоесть это совершенно не то что нам надо. поэтому 
        "16> /dev/cpu_dma_latency" = правильная хрень. обозначает что мы открываем файл /dev/cpu_dma_latency
        на запись и в для процесса прокидываем этот файл как дескриптор номер 16

        "16   > /dev/cpu_dma_latency" = неправильная хрень, если быть более точным она тоже правильная но она делает совершенно другое. она обозначает вот это 
        "16   1> /dev/cpu_dma_latency" 
то есть мы открываем файл /dev/cpu_dma_latency на запись и привязываем его к процессу через дескриптор 1.
и плюс к этому у нас бинарник имеет имя 16. 
поэтому смысл этих двух команд совершенно разный

а вот после значка ">" уже неважно есть пробелы или нет. оно все будет трактоваться одинаково тоесть
    "16> /dev/cpu_dma_latency"
    "16>/dev/cpu_dma_latency"
    "16>        /dev/cpu_dma_latency"
это все одно и тоже.
в целом конечно это дебилизм потому что сегодня я это помню. а завтра уже совершенно нет.


возвращаемся НАКОНЕЦ к нашей исходной задаче
нужно понять как это работает
        # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
кстати сразу замечу что 3 это не stderr (как я иногда глючу так думая), stderr это 2
а 3 это вобще ничего. потому что stdin это 0. stdout это 1 и stderr это 2
немного преобразуем это выражение
        # exec bash 3<> /dev/cpu_dma_latency; echo -en "0x00000258" 1>&3
строго говоря оно немного отличается от оригинала но по конечному результату это одно и тоже
зато все указано в явном виде и поэтому более понятно 
далее эту команду можно эквивалентно переписать как 
        # exec bash 3<> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
во первых я считаю что символ "<>" он излишен потому что мы собираемся писать туда а читать нет.
но в целом не особо важно конечно. но я считаю что вот это более грамотно.
поэтому преобразуем 
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
теперь все понятно. разберем его.
мы открываем файл на чтение /dev/cpu_dma_latency и прикрепляем этот  файл через дескриптор номер 3 у текущего баша. фишка в том что  файл будет висеть постоянно открытым все время. пока мы не закроем его 
специально сами руками. теперь если мы из баща будем писать в дескриптор 3 то оно будет лететь в файл
далее мы через echo посылаем число но не в канал 1 как это баш делает по дефолту а в канал 3.
таким макаром мы записали  число в /dev/cpu_dma_latency
казалось бы мы могли бы сделать проще вот так 
        # echo -en "0x00000258"  /dev/cpu_dma_latency
но это не привело бы нас к тому что нам надо потому что 
этот файл /dev/cpu_dma_latency он хитрый.нам надо чтобы файл оставался все время открытым после 
записи. если мы это делаем сразу через эхо. то как только эхо закончит то файл закроется и ОС перезапишет
значение на дефолтовое. так устроен этот файл. а вот верхний мудежный способ как раз дает то что после записи в эхо файл будет продолжать оставаться открытым и наше новое значение будет сохраняться. 
получается одна маленькая строчка из интернета но чтобы ее понять нужно диссертацию написать.
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
при этом получается пока наш процесс баша будет на компе сущестовать файл будет открыт
и наше записанное значение будет жить.
как только мы текущий баш процесс закроем. файл тоже закроется и значние будет со стороны ос перезаписано
на дефолтовое.
в принципе можно было сделать и вот так
        # bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
без выебонов с exec
у нас просто напросто создасться в системе +1 процесс с баш и только и всего. 
так что если расхлобучить все эти выебоны которые накручены в исходном выражении то вся фишка лишь в том
что для того чтобы открыть файл на постоянной основе надо заюзать вот это выражение
            # bash N> file
и только и всего.
тогда у нас  в системе будет баш процесс  у которого будет постоянно открытый файл "file" на запись
через дескриптор N. вот и все.

далее
теперь моя задача в том чтобы найти все процессы в которых открыты файл дескрипторы
ведущие на файл /dev/cpu_dma_latency
и закрыть все эти файл дескрипторы

# lsof -u root | grep cpu_dma_latency
bash       5106 root   16w      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6454 root    3u      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6828 root    3w      CHR              10,59      0t0        162 /dev/cpu_dma_latency

здесь видно какой процесс имеет этот файл открытым, через какой дескриптор, и  в каком режиме
открыт файл (r,w,rw)

и тут выясняется прикол (из того что я вижу навскидку из интернета) что нет такого красивого 
способа чтобы под рутом запустить команду и заставить позакрываться эти файловые дескрипторы. 
хаха.
тоесть вижу что есть только три неудобных способа
один это подключаемся к процессу через gdb и там запускаем команду на закрытие файла.
второй способ разыскать в граф оболочке наши конкретные терминалы с этими прям башами 
и уже из под них запускать команды на закрытие файлов
а ну и третий самый лоховской способ это поубивать эти процессы и автоматом и файлы закроются

я пойду вторым способом.
он состоит вот в чем.
причем в методичке там запаривают мозг что в завимости в каком режиме был открыть файл 
чтени, запись его нужно гасить по разному на самом деле нихрена. нам совершенно неважно как был открыт файл
    # exec 3> file
    # exec 3< file
    # exec 3<> file
нам на это наплевать 
во всех случаях гасим дескриптор совершенно одинаково
    # exec 3>&-
либо
    # exec 3<&-
а вот вариант 
    # exec 3<>&-
абсолютно нерабочий.
ПРИЧЕМ в данном случае абсолютно нельзя чтобы был пробел между ">" и "&-"
либо между "<" и "&-"
тоесть пробел запрещен не толко слева от знака редиректа но и справа
сразу выдаст ошибку!

поэтому в случае редиректов я бы советовал ни слева от знака редиректа ни справа не оставлять пробелов
чтобы не получать проблем на ровном месте


я в итоге предпочитаю гасить через 
    # exec 3> &-


метод закрытия файла через gdb
# gdb -p $PID
# p close($FD)

далее
интересный пример
    # $ cat /etc/passwd >&-
эквивалент этой команды
    # $ cat /etc/passwd 1>&-
так вот эта команда как работает,
баш создаст новый процесс , со своим бинарником,
и также мы ему указали что в новом процессе нужно уничтожить файл дескриптор 1
далее запустится бинарник cat  а далее прикол в том что по дефолту он пишет в 1  через
write (1, ...)
а 1  у нас нету поэтому на экране вылезет ошибка
    # $ cat /etc/passwd 1>&-
      cat: standard output: Bad file descriptor

можно сделать по другому
    #  tty
     /dev/pts/12
    # cat /etc/passwd 1>&- 1>/dev/pts/12
как ни странно это сработает. 
с новым процессом будет проделано все то что я описал в предыдушем примере
тоесть будет удален дефолтовый дексриптор 1 и будет создан новый который ведет в /dev/pts/12
и все окей. тоесть если указано несколько редиректов в строке то баш и выполняет последовательно 
слева направо хоть миллион таких редиректов 


далее
    $ exec 2>&1
это понятно дескриптор 2 будет иметь тот же бекенд что и дескриптор 1
амперсанд обязателен иначе 2 будет перенаправлен не в дескриптор а обычный файл с именем 1

далее
    $ exec  &>kuku.txt
это перенаправляет 1 и 2  в файл. причем только файл на диске.
перенаправление в файл дескриптор не работает
аналогичная команда
    $ exec 1>kuku.txt 2>kuku.txt
при этом вот это неработает
    $ exec 4<>kuku.txt
    $ exec &>&4
тоесть &> можно перенаправлять только на файлы на диске а не на дескрипторы. тоесть 
вот так только работает
    $ exec &>12.txt

далее. все это время я рассматривал только ">" "<" "<>"
что означало
    > = открыть файл на запист
    < = открыть файл на чтение
    <> = открыть файл на чтение и запись
и  я совсем забыл про ">>" и "<<"
что означает
    >> = открыть файл на запись и плюс флаг APPEND
    << = это совершенно отдельный флаг. я только знаю его вот такое применение
    $ cat <<EOF >1.txt
    12
    12
    EOF
кстати я точно проверил вот так уже неработает
    $ cat <EOF >1.txt
     bash: EOF: No such file or directory

далее
    $ <<vasya
> eee
> bbb
> vasya

тоесть команда просит нас ввести текс. как только мы заканчиваем на контрольном слове vasya
то ввод заканчивается. и никакой файл не создается.
как я понимаю что это аналог команды
    $ :<<vasya
    > eee
    > bbb
    > vasya

тоесть наш текст идет на stdin команды true и в итоге все это просто команды пустышка

далее
    $ >>kuku
эта команда просто напросто создат пустой файл kuku на диске
тоесть аналог этой команды вот такой
    $:>>kuku
или аналог
    $: 1>>kuku

далее
    $ ls >>filename 2>&1
аналог
    $ ls 1>>filename 2>&1
тоесть эта команда она создает процесс с бинарником ls
уничтожает стандартный 1 и создает новый 1 который ведет в файл с именем "filename"
уничтожает стандартный 2 и создает новый который смотрит туда же куда и 1 тоесть в файл "filename"


далее
    $ 2>&1
аналог
    $ :2>&1
все понятно


далее. 
в bash 4 добавили вот такую хрень
|& was added to Bash 4 as an abbreviation for 2>&1
тоесть
    $ vasya |& cat
это аналог
    $ vasya 2>&1 | cat
пример
    $ vasya 2>&1 | xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
    $ vasya  |& xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
 
тоесть хрень рабтает как. баш создает свой клон в новом процессе.
далее этот чайлд баш ищет бинарник вася, ненаходит его, выводит в 2 сообщение об 
ошибке. а у нас при этом когда процесс создавался то 1 была перенаправлена на 0 процесса xargs
и 2 была направлена тудаже куда 1. получается чайлд баш срет в 2 сообщение об ошибке
и оно автоматом прилетает на 0 xargs. и он то что получил высирает

далее выяснился конкретный пиздец с башем.
мы привыкли что в самоей левой позиции в строке обязательно идет команда 
а все аргументы пайпы итд обязательно идут справа. 
это настолько фундаментальная хрень что о том что это не так даже в голову не приходит
однако это не так. оказывается что можно вот так
    $ cat filename 
    filename
    kuku
    vasya
    $ 2>file2 0<filename cat | xargs echo   
    filename kuku vasya

тоесть левее команды можно абсолютно спокойно насовать редиректы! это пиздец
об этом я нашел случайно в сноске в bash advanced guide
то есть аналогичная в более привычном виде команда выглядит так
    $ cat 0<filename 2>file2 | xargs echo 

можно конечно еще более загадочно и с выебоном написать
    $ < filename cat > out
аналог тоесть более привычный вид
    $ cat 0<filename 1>out

вот еще пример с выебоном
    $ rpm2cpio < filename > $TEMPFILE
аналог
    $ rpm2cpio 0<filename 1>$TEMPFILE

а вот еще приме с приколом
как создать новый дескриптор который ссылается на уже существующий дескриптор
    $ exec 4>&1
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 02:44 0 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 1 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 2 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 4 -> /dev/pts/15

переводится команда так. в существующем процессе баш нужно открыть создать файловый дескриптор 4
и направить его на файл на который ссылается дескриптор 1. причем этот файл нужно открыть на чтение

еще один пиздец
    $ ls -l  1>/dev/null  16>&-
здесь я вывод от ls просто заткнул тем что перевел в null
и это не главное. главное это "16>&-" 
тоесть оказывается что можно давать команду уничтожить файловый дескриптор который 
и в помине у процесса нихуя нет. и ошибки при этом никакой не выдает. 

вот еще ебанутый пример
    $  <&2  ls  >/dev/null
его аналог
    $ ls  1>/dev/null   0<&2


вот еще ебанутый пример
    $ exec 3<&2
    $ exec 2>&1 >&3 3>&-
первая строка она в текущем процессе баша создает дескриптор 3 который ведет на тот же файл на который
указвыает дескриптор 2. причем этот файл для через дескриптор 3 будет открыт на чтение
тоесть в итоге 3 будет указывать на /dev/pts/19
вторая строка работает так. для текущего процесса баша дескриптор 2 будет уничтожен и создана заново
при этом он будет указыват на тот же файл на который указывает дескриптор 1. так как  1 указывает на /dev/pts/19
то и 2 будет на него указывать. причем в режиме на запись. 
следущим шагом будет уничтожен дескриптор 1 и создан заново при этом он будет указывать на файл на который
указывает дескриптор 3. а 3 указывает на /dev/pts/19 ( на основе информации из команды из первой строки)
поэтому 1 будет указывать на /dev/pts/19 причем в режиме на запись он откроет этот файл
на последнем шаге будет уничтожен дескриптор 3
здесь важно понять что работа с дескрипторами их создание и уничтожение идет слева направо. последовательно 
по шагам. также важно понять что если у нас написано что дескриптор 2 указывает на дескриптор 1 
как вот здесь "2>&1" то это нетак. не дескриптор ссылается на дескриптор а дескриптор ссылает на файл 
на который ссылает другой дескриптор. тоесть как только мы выяснили на какой файл ссылается дескриптор 1
то нам на него насрать. дескриптор 2 будет ссылаться не на дескриптор а на файл который является бекендом 
для дескритора 1. поэтому если потом позже мы удалим дескриптор 1 то проблемы у дескриптора 2 не будет 
никакой так как оне никогда не ссылался на дескритор 1. это тоже важно понять.
а вот на эту тему пример
        $ exec 4<filename 0<&4 1>&0 4>&-
        
        $ ls -1al /proc/16039/fd
        lr-x------ 1 vasya vasya 64 окт  5 03:08 0 -> /home/vasya/filename
        lr-x------ 1 vasya vasya 64 окт  5 03:08 1 -> /home/vasya/filename
        lrwx------ 1 vasya vasya 64 окт  5 03:08 2 -> /dev/pts/20


тоесть как это работает. для текущего процесса у нас открывается файл "filename" на чтение 
и привыязывается к процессу через дескриптор 4
на втором шаге у нас уничтожается прежний 0 и создается новый и он открывает на чтение тот файл на который ссы
лается 4 тоесть filename
на третьем шаге у нас уничожается 1  и создается заново и он открывает на запись файл на который ссылается 0
тоесть filename 
на последнем этапе у нас уничтожается дескриптор 4
от того что мы уничтожили дескриптор 4 это не означает что это как то повлияет на 0. потому что 0 указывает
не на 4 а на файл на который указывал 4 тоесть на filename
пиздец

далее. шок
внещняя по отношению к башу команда cat
она почемуто читает данные не из 0 а из 3 !!!
показываю:
    $ cat /dev/urandom > /dev/null

    $ ls -1al /proc/21031/fd
    lrwx------ 1 vasya vasya 64 окт  5 10:15 0 -> /dev/pts/16
    l-wx------ 1 vasya vasya 64 окт  5 10:15 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 10:15 2 -> /dev/pts/16
    lr-x------ 1 vasya vasya 64 окт  5 10:15 3 -> /dev/urandom

хотя в приниципе нормально. для cat штука "/dev/urandom" является параметром и бинарник cat когда он запустился
анализирует с каким параметрами командной строки он был запущен и волен открывать файл под любым дескриптором.
в том числе и под дескриптором 3.
скорее я капитально ошибся думая что параметр командной строки почемуто должен быть открыть катом через 
дескриптор 0. это же чушь. через 0 cat принимает данные из терминала. а через 3 он принимает данные из файла.
все конечно же должно быть так.

далее еще прикол про cat
    $ cat 1.txt 2.txt
если так запустить то cat вначале откроет 1.txt полностью его прочитает и выдаст в 1, закроет его,
потом только откроет 2.txt 
а не так как я думал что он одноврменно откроет два файла. нет так он не делает.

далее еще прикол
    $ <<EOF
    > aa
    > bb
    > EOF
насколько я понимаю эквивалент команды это 
    $ :<<EOF
либо
    $ true<<EOF
тоесть невидимая команда это ":" или "true" что одно и тоже.
и  в нее скармливается текст из терминала
как работает "<<EOF" насколько я понимаю когда мы тыкаем enter то текущий баш он видит эту хрень 
и делает вывод что мы хотим написать в терминале какойто текст, он дает нам написать в терминале наш текст,
засасывает внутрь себя И ТОЛЬКО ПОТОМ он клонирует себя в новый процесс и как я понимаю он где то сохраняет
засосанный текст из терминала и после того как склонировал себя то он наверное из родительского процесса
видимо через пайп скармливает засосанный текст в stdin чайлд процесса.
тоесть если у нас есть вот такая команда
    $ команда <<EOF 
то ее эквивалент
    $ echo -en "aaasdas\n asdasdsdasd\n" | команда 
или еше пример
    $ cat<<EOF > 1.txt
ее аналог в более понятной форме
    $ echo -en "aaaa\n bbb\n" | cat > 1.txt 
этим описанием я хочу подчеркнуть что "<<" не имеет никакого отношения к cat! это фича либо самого терминала
либо баша скорей всего баша. поэтому "<<" можно прихуяривать с любой программой. самое главное что программа должна ожидать получить какието данные из stdin. пример
    $ xargs echo <<EOF
    > "aaa"
    > "bbb"
    > EOF
    aaa bbb
тоесть эта команда эквивалентна
    $ echo "aaa bbb" | xargs echo
    aaa bbb

работает это так. мы тыкаем Enter. баш начинает анализировать строку  "xargs echo <<EOF"
видит конструкцию "<<EOF" и понимает что пока что делать ничего нельзя. прежде всего нужно считать 
некий текст из терминала. поэтому баш останавливается и ждет чтобы мы набили в терминале текст.
мы его набивает. баш его где то запомиает в своих кишках. потом он клонирует себя. запускает в чайлде
xargs и видимо через пайп передает из родительского процесса из своих кишок запомненный текст 
на stdin дочернего процесса.

далее я возвращаюсь к cat
у него есть такой прикол
    $ cat 1.txt - 2.txt
эта хуйня должна работать так вначале кат открывает файл 1.txt полностью его читает и выводит  на терминал.
потом кат ждет наших данных прям с терминала. он их считывает и выводит на экран. потом мы както должны обьяснить кату что мы больше не хотим вводит из терминала. и он тогда должен открыть 2.txt и его прочитать
и вывести на экран. на данный момент прблема в том что я не понимаю как этому кату обьяснить тот момент
когда я хочу закончить ввод из терминала
значит я не знаю как из терминала обьяснить кату что мы закончили ввод тоесть
    $ cat -
я не понимаю как закончить ввод с терминала
зато вот можно сделать такой прикол
вот есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777

тогда можно сделать вот такой фокус
   $ echo "111" | cat 6.txt - 7.txt
    666
    111
    777
круто??!?!?!?!?

во! я узнал как в терминале что надо нажать чтобы обьяснит терминалу и cat что я закончил
вводить текст и мы достигли "конец файла EOF" . оказывается это комбинация Ctrl+D
показываю имеем два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
тогда пуляем такую команду
    $ cat 6.txt - 7.txt 
    666  <=== это кат вывел содержимое 6.txt
    aa   <=== это мы ввели руками в терминале
    aa   <=== это кат вывел то что мы ввели
    bb   <=== это мы ввели руками в терминале 
    bb   <=== это кат вывел то что мы ввели руками, и тут я нажал Ctrl+D
    777  <=== это кат вывел содержимое файла 7.txt
круто!!!!!

далее. итак я выяснил что 
    $ cat 1.txt
приводит  к тому что кат откроет файл 1.txt через файловый дескриптор номер 3 
еще раз показываю на примере
    $ cat /dev/urandom 1>/dev/null
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
четко видно что файл открыт через дескриптор номер 3
а если мы хотим чтобы cat начал читать файл через дескриптор 0 то это запускается
совсем по другому
    $ cat /dev/urandom | cat 1>/dev/null
вот как выглядит открытые файлы у второго кат
    $ ls -1al /proc/22921/fd
    lr-x------ 1 vasya vasya 64 окт  5 11:18 0 -> 'pipe:[2312995]'
    l-wx------ 1 vasya vasya 64 окт  5 11:18 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:18 2 -> /dev/pts/18
в этом случае поток засасывается из 0 который ведет в пайп. но дело не в пайпе. а то что
в таком случае поток забирается из 0
возвращаюсь к случаю когда кат читает из файла который мы указали в командной строке
    $ cat /dev/urandom
мы имеем вот такой список открытых дескрипторов
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
так вот понятно что у нас на экране будут лететь символы
можно даже вот такой пример сделать чтобы на экране были только буквы 
    $  cat /dev/urandom | od -t x1
так вот возникает вопрос а что если мы вэто время будем конпки на терминале тыкать будет ли
их параллельно пихать на экран cat или нет. отвечаю конечно нет! 
как я уже сказал раз мы указали cat файл в командной строке как аргумент то он читает данные
только из дескриптора 3. а планов читать в это время  у него из stdin из 0  у него нет! поэтому
тыкать в терминале кнопки в это время нет никакого эффекта!

далее еще полезный момент
    $ echo 113 | cat
    113
    $ echo 113 | cat -
    113
результат один и тот же. однако во втором случае мы в более явной 
форме обьясняем кату что мы хотим чтобы он данные принимал из 0






далее я перехожу к мудежной но знаковой важной теме 
называется она 
>>> bash process substitution <<<
выглядит это так
    $ команда1 >(команда2)
например 
    $  cat - >(sleep  160)
и работает это так
создается  pipe.
и тут важно скзаать что книжка "bash advanced scripting" на которую я опираюсь нередко пишет 
полную хуйню. так и в этот раз. книжка пишет что создается named pipe. на самом деле нихуя. 
создается anonymous pipe. тут я делаю отсылку на pipe.txt чтобы прочитать про то что такое пайпы.
итак создается неименованный пайп а именно анонимный! выглядит он так
        'pipe:[2498298]'
где что и как щас станет понятно
    $ ls -1al /proc/5013/fd
        lrwx------ 1 vasya vasya 64 окт  6 10:41 0 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22
        l-wx------ 1 vasya vasya 64 окт  6 10:41 63 -> 'pipe:[2498298]'  <====
    $ ls -1al /proc/5014/fd
        lr-x------ 1 vasya vasya 64 окт  6 10:41 0 -> 'pipe:[2498298]'   <====
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22

так вот ядро создало анонимный пайп где то там в своих кишках памяти 'pipe:[2498298]'
далее запускается команда2 и ее stdin конец присоединяется к анонимному пайпу 'pipe:[2498298]'

далее запускается команда1 и ей в качестве аргумента командной строки передается адрес файла /dev/fd/63
то бишь /proc/pid1/fd/63
показываю:
    $ ps aux | grep cat
     vasya     5013  0.0  0.0  14720   744 pts/22   S+   10:40   0:00 cat - /dev/fd/63

где /dev/fd/63 это симлинк на /proc/self/fd/63 тоесть то бишь /proc/pid1/fd/63
нихуя себе! да?
тоесть команда 1 была по факту запущена в виде
    $ cat - /dev/fd/63
и соотвественно программа cat обрабатвыает этот аргумент строки 
и открывает этот файл под каким то дескриптором ну точнее как видно из практики под дескриптором 63
и таким макаром у первой программы мы имеем
        63 -> 'pipe:[2498298]'
у второй программы мы имеем
        0 -> 'pipe:[2498298]'
если первая программа захочет и будет писать в дескриптор 63 то это летит в пайп 
и если вторая программа будет читать если захочет из дескриптора 0 то она будет читать из пайпа.
таким макаром пайп обеспечивает связь между двумя процессами.
во втором процессе пайп присоединяется к 0
а в первом процессе имя файла пайпа (/proc/pid1/fd/63) передается программе как аргумент в строке.
соотвесвтенно если первая программа такова что она не собирается писать данные в файл который указан  в ее 
строке то второй програме нихрена и не прилетит.  тоесть bash process substituition это более специфический
процесс связи между программами.  классический анонимный пайп вида $ echo | cat более бронебойный способ 
потому что он вставляет пайп на stdout первого процесса и сует на stdin второго процесса.
если первый процесс чтото высирает на stdout а второй процесс чтото желает читать из своего stdin (что вобще то говоря не факт) то связь между процессами обеспечена.
в случае же bash process subsitution связь заработает только если первый процесс умеет писать в файл имя которого ему передали как аргумент в строке. вот что надо подметить.! но еще раз подчеркну что в bash process
substition используется анонимный пайп. а не именнованный как это суки эти пищут в bash advanced guide книжке


еще пример
    $ echo >(true)
    /dev/fd/63
почему так. потому что в конечно итоге будет запущена команда
    $ echo /dev/fd/63
обьясню почему. мы вбили команду в баш. баш анализирует строку и видит в ней кусок ">(true)"
для баша это означает что нужно этот кусок заменить на имя файла. что за файл?  файл в папке 
/dev/fd/63. по факту это симлинк на файл /proc/self/fd/63 то бищь /proc/pid1/fd/63
почему именно 63? я так думаю это какойто хардкод число в ядре с которого он создает эту хрень.
и между прочим это тоже симлинк и ведет он на анонимный пайп 
        /proc/pid1/fd/63 --> 'pipe:[2498298]'
когда пайп создан и когда ссылка на него создана то баш подставляет в оригинальную команду и запускает 
ее 
     $ echo /dev/fd/63
поэтму мы на экране видим 
    /dev/fd/63
помимо этого баш создает новый процесс и запукает там вторую команду "true"
и к ее stdin присоединяет этот же анонимный пайп тоесть
          /proc/pid2/fd/0 --> 'pipe:[2498298]'
конкретно в даннном случае вся команда целиком неимеет никакого практического смысла
потому что echo абсолютно не собирается писать в файл /dev/fd/63 по своей природе
а команда true не собирается ничего читать со своего stdin 
поэтому это пример чисто работающий но бесполезный     потому что данные через пайп
от первой команды ко второй не передаются


а вот пример где данные уже передаются
    $ cp /dev/urandom >(pv 1>/dev/null)
     147MiB 0:00:06 [21,0MiB/s] [                   <=>                           <=>    

работает это так что данные из /dev/urandom пихаются в пайп
а из него их читает pv и рисует картинку

более подробно  как это работает 
работает также как в прошлом примере
вот мы вбили команду
    $ cp /dev/urandom >(pv 1>/dev/null)
нажали Enter
бащ анализирует эту строку.  и видит комбинацию ">(pv 1>/dev/null)"
тогда баш понимает что все не так просто и создает аононимный  пайп где то там  в памяти вот 
такую хрень 'pipe:[2498298]'
далее бащ создает новый процесс и в нем запускает "pv". когда  баш создает этот процесс через сисколл
то просит у ядра чтобы оно присоединило к stdin дочернего процесса наш пайп
и выглядит это так
        /proc/pid2/fd/0 --->  'pipe:[2498298]'
далее баш берет оригинальную команду и меняет ее из вот такой
        $ cp /dev/urandom >(pv 1>/dev/null)
в такую
        $ cp /dev/urandom /dev/fd/63
где /dev/fd/63 в конечном итоге ведет в тот же самый пайп 'pipe:[2498298]' тоесть
        /dev/fd/63 --> /proc/self/fd/63 ---> 'pipe:[2498298]'

соотвевственно команде cp похеру что там на том конце у /dev/fd/63
она просто копирует данные из /dev/urandom в /dev/fd/63
таким макаром данные улетают в пайп.
и таким же макаром вторая команда читает свой stdin и получает данные из пайпа.

можно привести пример когда работает наоборот
    $ cp <(cat /dev/urandom) /dev/null
работает это так что () кидает их в свой stdout который направлен в пайп
а команда cp будет запущена в виде
    $ cp /dev/fd/62 /dev/null
где /dev/fd/63 тоже смотрит в пайп
таким макаром данные из stdout () поступают в пайп оттуда в /dev/fd/62 а оттуда в cp 

да уж..


а вот еще пример
    $  cp /dev/urandom >(echo "печать из субшелла"; pv 1>/dev/null)
    печать из субшелла
    66,2MiB 0:00:01 [37,1MiB/s] [     <=>           ]
получается вот что. вначале то что вылетает из cp пристыковывается через пайп к stdin команды echo.
но ей посрать на то что поступает к ней из stdin поэтому она просто печатает текст на экране и заканчивает
свою работу. данные при этом в пайпе как лежали так и лежат ( деньги в копилке так и лежат)
тогда далее запускается pv и уже к ней пристыковывается  пайп на ее stdin 
и так как pv как раз таки и и ждет поступления данных из stdin то pv начинает выкачивать данные из пайпа

тоесть фишка в том что у нас наш пайп был подключен и к одной команде и другой. а с классическим анонимным пайпом так хрен сделаешь наверно...


а вот еще очень важный пример
    $ echo "11" 1>(echo "первый привет из субшелл"; cat)
    11 1/dev/fd/63

что я хотел в этом примере добиться. я хотел чтобы вывод эха был перенаправлен в ()
но это не получилось хотя я якобы настроил редирект для 1. ошибка в том что баш заменил
конструкцию ">(echo "первый привет из субшелл"; cat)" на "/dev/fd/63" в итоге echo был запущен
буквально вот так
    $ echo "11" 1/dev/fd/63
поэтому то мы на экране и увидели вот эту хрен незапланированную 
    11 1/dev/fd/63
а чтобы все заработало как надо - надо вот так
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat)
    первый привет из субшелл
    11

значит в нем редирект настроен как "1>" а файл в который мы редиректим указан как ">(echo "первый привет из субшелл"; cat)"
в итоге и получается вот такая удивительная конструкция! c двумя галками через пробел "> >"
тоесть пример у нас расшифрорвывается так:
напечатай 11 но при этом stdout мы перенаправляем в именованный пайп который ведет в субшелл
далее. вначале именнованный пайп с 11 внутри прилепляется к stdin команды 
    echo "первый привет из субшелл";
но ей похеру то что у нее сидит на ее stdin
поэтому она просто на экране печатает приветствие и заканчиывает работу
тогда запускается команда cat у которой именованный пайп подключен к ее stdin
и вот тут наконец 11 из верхней эхо поступает на stdin команды кат. и она его печатает. 
в итоге мы получаем на экране
    первый привет из субшелл
    11


возникает вопрос а что будет у такой команды?
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
возникает вопрос чтото из верхнего эхо доберется до второго cat?
ответ конечно нет. потому что пайп уже весь опустошен на первом cat
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    11
    второй  привет из субшелл



а вот еще очень интересный пример
вот у нас есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
запускаем такую команду 
    $ cat 6.txt 7.txt  1> >(echo "первый привет из субшелл"; cat -; echo "второй  привет из субшелл"; cat -;)
    первый привет из субшелл
    666
    777
    второй  привет из субшелл


вопрос был вот в чем. когда у нас верхний cat закончит передавать первый файл и первый cat в субщелле закончит 
его печать то закончит ли cat в субшелле свою работу и передаст ли второй echo в субщелле управление
или нет. практика нам показала что первый cat в субшелле посрал на то что первый файл закончился 
и работал до упора напечатал оба файла и только потом закончил работу и передал управление дальше.
поэтому второй cat оказался полностью пустой. к нему по пайпу ничего не прилетело.



вот еще пример на эту тему
вот у нас есть файл 
    $ cat 6.txt 
    666
запускаю такую команду
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
в ней я говорю что  я буду пихать в головной cat вначале данные сам руками из терминала.
а потом как закончу данные в cat еще поступят из файла 6.txt
мой вопрос до второго cat в субшелл чтото долетит или нет?
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    вася  <=== это  я ввел руками в терминале
    вася
    петя  <=== это  я ввел руками в терминале
    петя
          <== тут я нажал Ctrl+D (EOF) и cat прекратил читать из терминала и начать читать файл 6.txt
    666   <== содержимое файла 6.txt
    второй  привет из субшелл


так вот видно то что первый cat в субшелле сидел и ждал данные до упора. она 
вначале дождался данных из того что я втермиале печатал. а потом он еще напечатал то что в 6.txt
и только после этого он закончил свою работу. и поэтом до второго cat в субшелле уже ничего не долетело
сверху. вот это и я хотел исследовать



еще малек пример про редирекшн.
пример
    $ echo -e 1>15.txt
я хотел изначально записать "1" в 15.txt
а как очевидно понятно я ошибся. и по факту обозначение "1>15.txt"
привело к тому что файловый дескриптор 1 стал указывать на 15.txt 
а не то что символ 1 был напечатан на экран. 
надо было вот так делать чтобы 1 на экране напечатался
    $ echo -e "1"   1>15.txt
вот как было правильно




теперь НАКОНЕЦ я возвращаюсь к тому примеру с которого начал изучение редиректов 
        $ exec &> >(tee -a ./1.txt)
теперь наконец  эта тарабарщина понятна!
"&>" дает то что stdin и stderr оба будут перенаправлены в некий файл. а что за файл?
а это как раз указано дальше , файл такой что он указывает на анонимный пайп из "bash process substitution" 
обычно это файл 
        /dev/fd/63 ---> /proc/self/fd/63 ---> 'pipe:[2498298]'

баш начнет анализировать всю эту команду после нажатия enter  и попросит ядро создать пайп 'pipe:[2498298]' 
где то в памяти ядра, далее баш 
произведет в исходной строке замену 
было
    $ exec &> >(tee -a ./1.txt)
стало
    $ exec &> /dev/fd/63

в доказательство этого я выполнил strace чтобы это поймать
    # strace -p 7859 -f  -s80  -e openat
    [pid  7859] openat(AT_FDCWD, "/dev/fd/63", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
причем этот файл присутствует именно в openat а не в execve
удивительно

далее баш выполнит команду exec и тогда у текущего баша поменяется два дескриптора. 1 и 2 (stdout и stderr)
раньше скорей всего они смотрели на файлы терминало /dev/pts/22
а станут смотреть на пайп
        /proc/bash_pid/fd/1 ---> 'pipe:[2498298]'
        /proc/bash_pid/fd/2 ---> 'pipe:[2498298]'

далее баш запустит еще один процесс и там запустит tee
к stdin дескриптору этого процесса он прилепит тот же пайп 
        /proc/tee_pid/fd/0 ---> 'pipe:[2498298]'

в итоге все что баш будет бросать на stdout\stderr будет направлено в пайп
и будет считано из пайпа командой tee и отрисовано на окне терминала и продублировано  в физ файл на физ диске.

хотелось  почеркнуть что отрисовка вывода в терминале будет идти не засчет головного баша
а за счет tee в субшелл.
посмотрим теперь на практике
    $ exec &> >(tee -a 1.txt)
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 13:11 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 1 -> pipe:[2331898]   <====
    l-wx------ 1 vasya vasya 64 окт  5 13:11 2 -> pipe:[2331898]   <====

    $ ps aux  | grep tee
    vasya    26155  0.0  0.0  14588   792 pts/17   S    13:10   0:00 tee 1.txt
    $ ls -1al /proc/26155/fd
    lr-x------ 1 vasya vasya 64 окт  5 13:11 0 -> pipe:[2331898]   <====
    lrwx------ 1 vasya vasya 64 окт  5 13:11 1 -> /dev/pts/17
    lrwx------ 1 vasya vasya 64 окт  5 13:11 2 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 4 -> /home/vasya/temp/1.txt

из чего действительно видно что в головноv баше stdin и stdout указывают на пайп [2331898]
а в процессе "tee" ее stdin смотрит в тотже самый пайп [2331898]
тоесть теория совпала с практикой


далее я покажу что будет напечатано в 1.txt
если в исходной терминале будет выглядеть вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

то в 1.txt будет вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

что интересно новые буквы будут появляться в файле не тогда когда мы воригинальном терминале 
нажали enter а уже тогда когда мы в терминале нажали просто букву!
что еще более поразительно. если мы сотрем букву на оригинальном терминале то эта буква также сотрется 
и в файлле ! amazing!
вот это тема.... охренеть


возникает удивительный вопрос а нахуй этот механизм нужен на практике? покажите
пример практический когда это может пригодится?

еще пример
еще:
    $ echo 1 >(cat)
        1 /dev/fd/63
ну понятно. строка 
    $ echo 1 >(cat)
будет заменена на
    $ echo 1 /dev/fd/63
отсюда результат


далее
    >&, &>
есть ли разница.
обычно нет. но лучше юзать &>
по смыслу эта команда перенаправляет sterr и stdin в один файл
который обязательно нужно укзаать после тоесть
    $ echo "aaa" &> /tmp/1.txt
эквиваелент
    $ echo "aaa" 1>/tmp/1.txt 2>&1
либо
    $ echo "aaa" 1>/tmp/1.txt 2>/tmp/1.txt


далее
    >|
тут интересно. баш имеет ряд крутилок настроек.
настроки подкручитваются через баш билтин set
    $ set --help
в частности вот так крутятся настройки
    $ set +o pipefail -o noclobber
посмотреть текущие настройки вот так
    $ echo $-
хотя там не информативно. а более информативно вот так

$ set -o
set -o
+ set -o
allexport       off
braceexpand     on
emacs           on
errexit         off
errtrace        off
functrace       off
hashall         on
histexpand      on
history         on
ignoreeof       off
interactive-comments    on
keyword         off
monitor         on
noclobber       off
noexec          off
noglob          off
nolog           off
notify          off
nounset         off
onecmd          off
physical        off
pipefail        off
posix           off
privileged      off
verbose         on
vi              off
xtrace          on

видно опять же как я сказал что noclobber выключена.
если она включена то ">" не даст перезаписать существующий файл. выдаст ошибку.
у нас опция выключена поэтому ">" перезатирает файл без всяких ошибок.
так вот если все таки noclobber активирована то ">|" позволяет игнорировать эту настройку.  
в общем в итоге ">|" малополезная хрень.
я еще ни разу не встречал чтобы noclobber был хоть где то активирован.

далее пример. 
я нашел более менее пример который уже как то типа может быть полезен на практике.
есть два файла
    # cat 7.txt 
        a
        b
        c
    # cat 6.txt 
        1
        2
        3

есть интересная команда "paste" она читает из нескольких файлов по одной строке
и печатает это на экране через TAB
    # paste 6.txt 7.txt 
        1   a
        2   b
        3   c
так вот как это же можно сделать через bash process substitution 
    # paste <(cat 6.txt) <(cat  7.txt)
        1   a
        2   b
        3   c
ну когда мы читаем из готовых файлов то пример мало полезен. а вот когда 
нам надо прочитать из stdout нескольких процессов и все это построчно соединить в таблицу
на экране то bash process substitution уже становить реально полезен
    # paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp)
        INT3400 Thermal 20000
        pch_cannonlake  40000
        B0D4    0
        x86_pkg_temp    42000


как написано в мануле утилита "paste" позволяет соединить строки нескольких файлов вместе.
тоесть еще пример
    $ cat 1.txt 
        aaa
        bbb
        ccc 
$ cat 2.txt 
        5
        6
        7 
$ paste 1.txt  2.txt 
        aaa 5
        bbb 6
        ccc 7 

разделение идет через TAB


далее я опишу утилиту colrm
это частично идиотская утилита потому что ее man нагло врет
    $ colrm start stop
утилита удаляет из текста колонки с номерами  
    start << колонка << stop
причем разделителя колонки никакого нет. это ни пробел  ни TAB
это всегда банально номер символ в строке. показываю
в этом примере будет удалены символы 3 и 4
их позиция в строке и является так называемой "колонкой"
    $ echo -e "123456789" | colrm 3 4
    1256789
если указать только стартовую колоноку то он удаляет вот такие колонки
    start << колонка << EOL
пример
    $ echo -e "123456789" | colrm 3
    12
в целом убогая утилита



далее я опишу утилиту column
она позволяет назначить разделитель и потом отформатировать текст по колонкам.
но по мне утилита корявая. она порой работает хер знает как.
итак имеем файл
    $ echo -e "1+2+3+4+5\n6+7+8+9+10"
    1+2+3+4+5
    6+7+8+9+10
воспользуемся недавно узнанной штукой "bash process substitution"
    $ column -t -s "+" <(echo -e "1+2+3+4+5\n6+7+8+9+10")
    1  2  3  4  5
    6  7  8  9  10
так вот утилита column 
ее ключ -е без него вобще ничего не работает. считай что он значит что надо отформатировать текст
ключ -s "+" означает что разделитель между колонками "+"

далее важно дополнение. выравнивание в колонке идет всегда по левому краю.
пример про это
    $ echo -e "111111111+2+3+4+5\n6+7+8+9+10"
    111111111+2+3+4+5
    6+7+8+9+10

    $ column -t -s "+" <(echo -e "111111111+2+3+4+5\n6+7+8+9+10")
    111111111  2  3  4  5
    6          7  8  9  10

порой эта прога как уже сказал работает непонятно как . но если ее применить несколько раз
то вроде можно получить вменяемый результат
практический пример 
имеем вот такой вывод.
почему то cpupower хреновато форматирует свой текст
можно заметить что "Freq" и "POLL" поплыли
    $ sudo cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6   || C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,02|  1,37| 59,17|  0,00||  0,88| 99,12|   632||  0,00|  0,00|  0,00|  0,02|  0,47|  0,00|  3,36|  0,16| 95,13
   4|  0,02|  1,37| 59,17|  0,00||  2,33| 97,67|   577||  0,00|  0,00|  0,03|  0,01|  1,36|  0,00| 14,02|  0,08| 82,29
   1|  0,13|  0,42| 59,17|  0,00||  1,66| 98,34|   598||  0,00|  0,74|  0,18|  0,09|  0,23|  0,00|  7,52|  0,03| 89,59
   5|  0,13|  0,42| 59,17|  0,00||  1,06| 98,94|   600||  0,00|  1,82|  0,00|  0,06|  0,26|  0,00| 10,37|  1,03| 85,34
   2|  0,00|  0,27| 59,17|  0,00||  1,70| 98,30|   657||  0,00|  0,00|  0,01|  0,02|  0,02|  0,00|  4,72|  0,00| 93,46
   6|  0,00|  0,27| 59,17|  0,00||  0,32| 99,68|   623||  0,00|  0,00|  0,02|  0,00|  0,20|  0,00|  4,52|  0,00| 94,87
   3|  0,09|  0,98| 59,17|  0,00||  0,87| 99,13|   609||  0,00|  0,94|  0,73|  0,03|  0,48|  0,00|  7,93|  0,00| 89,05
   7|  0,09|  0,98| 59,17|  0,00||  1,62| 98,38|   568||  0,01|  0,66|  0,04|  0,10|  0,76|  0,00| 14,12|  0,00| 82,69


отформатируем этот текст
    $ sudo cpupower monitor | column -t -s "|" | column -t -s " " | grep -v Nehalem
CPU      C3     C6          PC3    PC6   C0    Cx     Freq  POLL  C1    C1E   C3    C6    C7s   C8     C9    C10
0        0,02   1,22        52,58  0,00  1,20  98,80  645   0,00  1,92  0,17  0,02  0,23  0,00  9,80   1,11  85,57
4        0,02   1,22        52,58  0,00  1,84  98,16  623   0,00  0,00  0,24  0,04  1,83  0,54  11,55  0,38  83,64
1        0,08   0,40        52,58  0,00  1,76  98,24  631   0,01  0,00  0,02  0,09  0,48  0,00  8,84   0,00  88,81
5        0,08   0,40        52,58  0,00  3,34  96,66  674   0,00  1,05  1,26  0,00  0,16  0,40  6,78   0,07  86,95
2        0,06   2,54        52,58  0,00  2,61  97,39  666   0,00  0,11  0,85  0,01  0,72  0,00  8,97   0,07  86,65
6        0,06   2,54        52,58  0,00  2,02  97,98  646   0,00  0,00  0,03  0,10  3,00  0,00  10,23  0,06  84,53
3        0,03   0,71        52,58  0,00  5,44  94,56  654   0,00  0,00  0,00  0,05  0,68  0,00  15,06  0,09  78,67
7        0,03   0,71        52,58  0,00  0,75  99,25  635   0,00  0,00  0,01  0,01  0,09  0,00  6,79   0,00  92,28

в плане ключа -s который указывает разделитель колонок
так вот возникает вопрос как указать в качестве разделителя например знак табуляции
в мануале об этом нет ни слова. так вот ответ вот как
    -s $'\t'
а вот пример
    $ echo -e "1\t2\t3\t"
    1   2   3   

    $ echo -e "1\t2\t3\t" | column -t -s $'\t'
    1  2  3

утилита column работает так что она удаляет из строк сам знак разделителя
и заменяет его на пробел. или пробелы. по своему усмотрению. поэтому в примере выше она убрала
табы и вставила пробел как разделитель заместо

а теперь более менее практический пример где эта утилита может пригодится реально
исходный текст
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с"
    'температура датчика'   'скорость'  'высота'
    30°C    12 м\с

прикол в том что между колонками TAB а внутри колонки у нас пробелы могут быть.
а мы хотим выровнять.
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с" |  column -t -s $'\t'
    'температура датчика'  'скорость'  'высота'
    30°C                   12 м\с



а вот пример ради которого я долбался писал выше описание для 
утилит paste, bash process substitution, sed 
( кстати о том как работает sed смотри в sed-awk-cut-tr.txt )
итак встретился в инете такой пример.
в нем column он заменяет разделитель TAB на пробел,
а sed берет три последние символа, запоминает третий слева символ в группу 1,
и вместо трех последних символов вставляет точку плюс символ который сохранен в группе 1 и 
далее градус с цельсием. например в конце было 20000, значит три берем три последних символа это "000"
запоминаем третий слева в группу 1 это "0" и заменяем в итоге на ".0°C"
    $ paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp) | column -s $'\t' -t  | sed 's/\(.\)..$/.\1°C/'

    INT3400 Thermal  20.0°C
    pch_cannonlake   37.0°C
    x86_pkg_temp     39.0°C


далее еще пример про редирект
    $ echo "456" | ssh thinkpad cat - 1>~/7.txt
прикол в том что редирект будет идти не в файл на удаленном компе. нееееееет.
файл будет записан на этом компе!
чтобы записать файл на удаленный комп нужно
    $ echo "456" | ssh thinkpad cp /dev/stdin ~/7.txt


| {!var}
как нам напечатать переменную имя которой хранится в дургой
переменной.
    $ a="1"
    $ b="a"
эта хрень нам даст просто то что лежит в $b
    $ echo "$b"
    a
а вот уже эта хрень нам сделает двойное раскрытие имени переменной и напечатает то что лежит в $a
    $ echo "${!b}"
    1
причем важно заметить что надо именно вот так сохранять имя переменной
    $ b="a"
если сделать вот так
    $ b='$a'
то раскрыть такое не полуxится и баi пошлет нахер
    $ echo "${!b}"
    bash: $a: bad substitution
а если сделать вот так
    $ b="$a"
то тоже ничего хорошего не полуxится
    $ b="$a"
    $ echo "$b"
    1
    $ echo "${b}"
    1
итак только такой вариант работает
    b="a"

    
    
    
| <<<
пока что детално неразбирался но 

    $ bc <<< 2*3
    6
тоесть это некий аналог 
    $ echo -n "2*3" | bc

    

    
    
| ${#parameter}
| ${#var}

вычисляет длинну переменной
    $ a="123"
    $ echo ${#a}
    3

если у нас скрипт то 
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"
    $ ./03.bash 1
    первый параметр = 1, длинна первого параметра = 1
    $ ./03.bash 12
    первый параметр = 12, длинна первого параметра = 2
    $ ./03.bash 
    первый параметр = , длинна первого параметра = 0

в данном случае #1 это первый аргумент передаваемый в скрипт


еще один пример
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"

    for ((i=0; i<${#1}; i++))
    do
        echo "i = $i"
    done


    $ ./03.bash 5
    первый параметр = 5, длинна первого параметра = 1
    i = 0

поскольку длинна первого аргумента скрипта "5" равна единице то цикл for имеет параметры
i=0, i<1, i++
поэтому он отрабатывает один раз
еще интересно то что {#1} означает посчитать длинну переменной $1






| ${parameter:offset:length}
| ${:::}

позволяет печатать не всю переменную а ее часть.
причем важно offset указывает начало откуда печатать
а length указывает сколько символов после оффсета напечатать
следущий пример печатает начиная с оффсет и до конца переменной
    $ a="123"
    $ echo ${#a}   # напоминаю что ${#a} считает длинну переменной 
    3
    $ echo ${a:0:${#a}}
    123
    $ echo ${a:1:${#a}}
    23
    $ echo ${a:2:${#a}}
    3
    $ echo ${a:3:${#a}}
очевидно что нумерация символов в переменной начинается с "0"

следущий пример печатает начиная с оффсет всего один символ
    $ a="123"
    $ echo "${a:0:1}"
    1
    $ echo "${a:1:1}"
    2
    $ echo "${a:2:1}"
    3



    
    
    
| ${#}
| ${:::}

вот еще интерснейший пример

    $ cat md.bash 
    #!/bin/bash

    for((i=0; i<${#1}; i++))
    do
        echo "i=$i"
        echo "${1:$i:1}"
        echo "---"
    done

    $ ./md.bash 34
    i=0
    3
    ---
    i=1
    4
    ---

значит вот эта хует ${#1} означает посчитай длинну переменной $1
где $1 это первый аргумент командной строки который был передан скрипту при запуске

вот эта хуета "${1:$i:1}" означает возмьми переменную $1 и вырежь из нее символы начиная с позиции $i
в количестве 1 штука

получается мы передаем в скрипт 34 который будет являться $1
тогда ${#1} = 2
и цикл будет работать для i=0,1

для i=0
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 0 в количестве 1 штука. тоесть это будет 3

для i=1
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 1 в количестве 1 штука. тоесть это будет 3
4

что мы и видим на экране

охуеть




| printf
это bash builtin.

при этом эти суки в man bash нихуя про него нормально не написали ублюдки.

формат этой хуеты такой

printf "format" arg1 arg2 arg3 ...

тоесть вначале задается формат печати. а потом указываются аргументы(переменные) для печати


простейщий пример
    $ printf "asd\n"
    asd

в этом примере у нас указан только формат. аргументов нихуя нет.
asd это просто литеры. а "\n" это спецсимвол переноса строки. 
все супер просто.

теперь о некоторых других спецсимволах внутри формата

Format Specifier	Description
%c	Treat the arguments as a single character.
%d	Treat the input as a decimal (integer) number (base 10).
%e	Treats the input as an exponential floating-point number.
%f	Treat the input as a floating-point number.
%i	Treat the input as an integer number (base 10).
%o	Treats the input as an octal number (base 8).
%s	Treat the input as a string of characters.
%u	Treat the input as an unsigned decimal (integer) number.
%x	Treats the input as a hexadecimal number (base 16).
%%	Print a percent sign.
%Wd	Print the W integer X digits wide.
%(format)T	Outputs a date-time string resulting from using format as a format string for strftime. The corresponding argument can be the number of seconds since Epoch (January 1, 1970, 00:00), -1 (the current time), or -2 (shell startup time). Not specifying an argument uses the current time as the default value.
\%	Print a percent sign.
\n	Prints a newline character.
\t	Print a tab character.


важно. насколко я понял формат аргумента изначально воспринимается как string
а уже потом в строке формат он конвертируется согласно приказу.
обьясняю на примерах:
    $ printf "число=%d\n" 10
    число=10
    $ printf "число=%c\n" 10
    число=1

в первом примере мы берем аргумент стринг 10 и конвертируем  его в  десятичное число
во втором примере мы берем аргумент стринг 10 и конвертируем его как символ единичный поэтому он от 10 отрезал 1 символ
с начала. начало (офссет) у аргумента начинается слева. получили 1

следущие примеры
    $ printf "%x\n"  10
    a
    $ printf "%x\n"  11
    b

мы берем аргумент в формате стринг и конвертируем его в hex формат
и вот очень важный пример, 
    $ printf "%x\n"  "A"
    bash: printf: A: invalid number
    0
    $ printf "%x\n"  "a"
    bash: printf: a: invalid number
    0
    $ printf "%x\n"  "0xa"
    a
    $ printf "%x\n"  "0xA"
    a
тоесть на сколько я понял если мы хотим конвертировать аргумент в hex формат то на входе
по дефолту ожидается что аргумент имеет dec формат. а если мы хотим уже в аргументе выразить число в hex формате
то его нужно в аргументе писать в виде "0xhex"
охуеть




следущий прмиер
    $ printf "число=%x\n" q
    bash: printf: q: invalid number
    число=0
здесь он нас законно щлет нахер потому что как я уже сказал если мы хотим сконвертиоровать
аргумент в hex формат то аргументе по дефолту принтф ожидает видеть аргумент в формате десятичном 
поэтому аргумент вида "q" приводит к посыланию нахер


двигаем дальше. есть особая залупа о которой не сказано в манах. а оно только обнаруживется в примерах.
залупа касется аргиумента

    $ printf "%d\n" "'A"
    65
    $ printf "%x\n" "'A"
    41

если указываем в аргументе вот так 'аргумент
то это сообщает принтф что прежде чем аргумент подставлять в формат его нужно из ASCII символа преобразовать 
в число причем подставить это число в аргумент именно в десяиичном виде . 
тоесть в ASCII таблице символ "A" имеет код 65(dec)

итак 65  подставляется в аргумент. 
таким макаром первый пример превращается в 
    $ printf "%d\n" 65
    65
а второй пример превращается в  
    $ printf "%x\n" 65
    41

поскольку как я уже писал если мы хотим преобраовать число в hex то принтф ожидает по дефолту что 
в аргументе число представлено в формате dec. поэтому 65 dec преврашается в 41h
если же мы хотим чтобы принтф рассмматривал уже в аргументе 65 как hex число то надо делать вот так
    $ printf "%x\n"  "0x65"
    65

ну а вот такая хрень приводит к ошике
    $ printf "%x\n"  "0x'A"
    bash: printf: 0x'A: invalid hex number
    0

вообще этот принтф это полный пиздец. выдумка шизофреника. 

следущий момент а если у нас несколько аргументов. тогда они выбираются слева направо по порядку. тоесть
    $ printf "ширина=%d, длинна=%d \n" "10" "2"
    ширина=10, длинна=2
тоесть первый %d берется как 10
второй %d берется как 2
все просто. идем слева направо.


далее. 
значит таким макаром если мы хотим по быстрому узнать какой ASCII код у символа
то можно набрать 
    $ man ascii
а можно вот так
    $ printf "%d\n" "'3"
    51
    $ printf "%d\n" "'4"
    52


далее. 
что еще интересно что вот эта хуйня $1 она возможно только при вызове скрипта
тоесть просто для команды в строке этой хуйни не сущетсует
    $ echo $1 <<< "a"
    $ echo "1" | echo $1 
    $ printf "%s \n" "$1" <<< "a"
    $ echo "a" | printf "%s \n" "$1" 
видим что везде пусто на выхлопе





| bc
с ним есть такая хуйня. если мы в него передаем строчку то обязательно 
она должна заканчиваться символом Enter иначе пошлет нахуй. 
пример
    $ echo "2*3" | bc   
    6
    $ echo -n "2*3" | bc
    (standard_in) 1: syntax error
тоесть во втором примере ошибка потому что echo -n недобавляем автоматом символ Enter
к потоку байтов. поэтому bc шлет нахуй.

тоже самое когда юзаем printf 
    $ printf "2*3" | bc
    (standard_in) 1: syntax error
    $ printf "2*3 \n" | bc
    6

    

    
    

| for

есть вот такая хуйня в баш

   for i
    do
        echo -n "vasya"
    done

мы видим   
    for i
типа что за хуйня? оказывается это есть такое сокращение для
    for i in $@
охуеть. потому что иначе эта строчка сука не имеет никакого значения падла
таким образом это эквивалент
   for i in $@
    do
        echo -n "vasya"
    done


    
    
| wc

оказалась приколная программа
что она умеет делать
  wc - print newline, word, and byte counts for each file

тоесть она умеет считать:
    число строк
    число слов
    число байтов


этот пример берет папку с *.txt файлами и считает сколько в них суммарно слов
    $ ls -1 *.txt | xargs -L1 -I% wc -w ./"%" | awk '{print $1}' | xargs echo | sed 's/ /+/g' | bc
    727721

еще можно через wc считать число букв или байтов в стринге
хотя есть подьебка
пример
    $ echo "1" | wc -m
    2
возникает вопрос почему длинна два символа.
а потому что эхо вставил символ Enter вконце. а для wc это тоже символ
    $ echo "1" | od -t x1
    0000000 31 0a

убираем enter в конце и получим уже верный результат
    $ echo -n "1" | wc -m
    1

    $ echo -n "1" | od -t x1
    0000000 31

поэтому удобнее считать число букв в стринге через awk потому что он enter не считает
пример
    $ echo  "1" | awk '{print length}'
    1

а теперь самый что ни на есть практический пример.
нужно узнаиь число букв в хеше
    $ echo "1" | sha512sum | awk '{print $1}'   | awk '{print length}'
    128
    $ echo "1" | sha512sum | awk '{print $1}'   | wc -m
    129
    $ echo "1" | sha512sum | awk '{print $1}'   | od -t x1
0000000 33 61 62 62 36 36 37 37 61 66 33 34 61 63 35 37
0000020 63 30 63 61 35 38 32 38 66 64 39 34 66 39 64 38
0000040 38 36 63 32 36 63 65 35 39 61 38 63 65 36 30 65
0000060 63 66 36 37 37 38 30 37 39 34 32 33 64 63 63 66
0000100 66 31 64 36 66 31 39 63 62 36 35 35 38 30 35 64
0000120 35 36 30 39 38 65 36 64 33 38 61 31 61 37 31 30
0000140 64 65 65 35 39 35 32 33 65 65 64 37 35 31 31 65
0000160 35 61 39 65 34 62 38 63 63 62 33 61 34 36 38 36
0000200 0a
0000201


видно что awk дает верный ответ а wc нет. потому что у нас в стринге на конце есть 0x0a тобишь Enter и wc его считает. 
а он нам нахуй ненужен.
-----


| printf

эта команда настолкло ебанутая что ее надо описать отдельно суку
во первых есть встроенный в баш билтин printf
а есть отдеьная программа которая от баша никак не зависит.
баш почмуто по дефолту запускает не свой билтин а внешнюю.
проверить это легко через strace

    $ strace printf "поле формата \n"
    execve("/usr/bin/printf"...

запустить именно билтин принудительно можно через 
    $ builtin printf "a"
справочная по билтину охуенно убогая. смотрим либо 
    $ builtin printf  --help
либо man bash

далее рассматриваем только внешнюю команду /usr/bin/printf
справка по ней тоже охуенно убогая
    $ man printf
    $ man 3 printf


    
a1
'a
$salt


значит у принтф ест  минимум одно поле. поле формата
    $ printf "поле формата"
    поле формата

в целом туда вставляется все то что мы хотим напечатать. ровно также как это есть у 
команды echo "печать"

в отличие от echo принтф не вставляет автоматом на конце символ новой строки. поэтому 
его надо вставлять руками. через "\n"
    printf "поле формата \n"
    поле формата 

слэш как и у баша в целом это спец символ. тоесть когда его встречает принтф то он его рассматривает 
не как просто печатную литеру а как то что за ней идет символ который тоже является спецсимволом и чтобы его
можно было напечатать его экранирует слэш.
помимо экранируеющего действия комбинция слэш + некоторый символ за слэшем сообщает принтф что \X это тоже 
некий спецсимвол.тоесть с одной стороны слэш может отключать функцию спецсимвола для спецсимвола котоырй стоит за слешем
с другой стороны комбинация слэша и некоторого простого символа стоящего за ним формирует в итоге спецсимвол.
чтобы это все показать на примерах я еще добавлю одну хрень. переменные можно печатать также как и у echo 
тоесть
    $ a=123
    $ printf "$a"
    123
так вот очевидно что $ это спецсимвол который обьясняет принтфу что за ним идет не просто печатный символ "a" 
что за $ идет имя переменной. 
так вот если мы хотим просто распечатать '$a' тогда надо обьянсить принтф что доллар  в данном случае это не спец
символ а просто литера. тут вступает в дело слэш. 
пример
    $ printf "\$a"
        $a
    $ printf "\$a\$a\$a"
        $a$a$a
    $ printf "$a$a$a"
    123123123
с этим понятно.
    $ printf """
    > ^C
тоесть символ " является спецсимволом и он нам его недает напечатать. 
отключаем спецсимвольность и полный порядок
    $ printf "\""
    " 
печатаем слэш
    $ printf "\\"
    \
итак мы рассморели примеры когда слэш забирает силу у спецсимвола преврашая его в просто литеру
теперь рассматриваем случай когда слэш дает спецсилу простму символу.
самый известные пример это символ кнопки Enter. тоесть символ новой строки и перенос каретки налево.
    $ printf "1 \n"
    1
тоесть будет наечатан 1 и пробел. а затем экран будет прокручен на 1 строку вверх и печатная головка
возвратится на начало строки. тоесть \n это управляющий символ терминала
далее. печатаем спецсимвол backspace (прикольно!)
    $ printf "abc"
    abc
    $ printf "abc\b"
    ab
    $ printf "abc\b\b"
    a
тоесть он затирает символ слева как кнопка backspace.
кстати backspace походу переводится как "пробел в обратно направлении"
однако тут я нашел некую необьяснимую хуйню.
вот я печатаю три символ и затираю последние два
    $ printf "abc\b\b"
    a
но если я добавляю в конце символ новой строки тобишь нажатие кнопки enter то
почемуто при этом все символы будут напечатаны. хуйня какаято
    $ printf "abc\b\b\n"
    abc
почему такая хуйня непонятно
однако далее стало понятно что "\b" это ссукат не backspace как
об этом написноа в man ascii это на самом деле аналог стрелки влево. тоест 
он передвигает каретку на один символ влево и сам символ не удаляет.
вот пример
    $ echo -ne "123\b"; sleep 5
или 
    $ printf "123\b"; sleep 5
если мы доблавяем \n то у нас прокручивыается строка наверх и поэтому 123
сохраняется. если мы \n недобавлем то баш начинает печатать с текущего положения
каретки и просто затирает 3. вот как это работает

следущий спецсимвол который образуется в паре со слещем это "form feed"
он означает прокрутить экран или бумагу на одну строку вверх при этом положение
печатающей головки остается на том же месте
    $ printf "abc\f 1  \n"
    abc
        1  
тоесть мы напечатали abc и пробел. потом прокрутили бумагу на 1 строку вверх и в той же
горизонтальной позиции продолжаем печатать.
по факте терминал (черный экран) это полны аналог матрчного принтера. у него есть 
строка в которой он печатает и он может бумагу прокручивать на одун строку вверх и есть
печатная головка которая печатате символ в текущем положении.
единственное что нет такого спецмивола чтобы строку прокрутит не на 1 строку вверху 
а обратно на 1 строку вниз. жалко.
    $ printf "abc\f1\f2\f3  \n"
    abc
        1
          2
            3  
следущий спецсимвол это вовзрат печ головки вначало строки 
    $ printf "abc\rdef  \n"
    def  
тоесть это работат так 
вначале печаается abc потом печатающая головка (курсор) возврашается вначало этой же строки
и начинает печататаь новые символы убивая старые. поэтому abc исчзаеае а def появлыется
    $ printf "vasya\rB\n"
    Basya
мы напечатали vasya потом вернули голову внвало стоки и напечатали символ B
поэтому vasya стал Basya
что интересно что если мы будем писать эту хрень в файл то в нем будут все эти символы. 
щам покажу
    $ printf "vasya\rB\n" | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
или прям запишем в файл на диске и прочитаем
    $ printf "vasya\rB\n" > 11.txt
    $ cat 11.txt | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
             v  a  s  y  a \r  B  \n    <==  я показываю какой символ ASCII\UTF-8 соотвествет какому байту

считываем этот файл с диска и видим на экране
    $ cat 11.txt 
    Basya
    
так в чем прикол  что я хотел этим показать. я хотел паоказать что 
по факту файл на диске содержить гораздо больше чем просто Basya как это мы видим на экране.
файл по факту содержит слово "vasya" которое мы на эаркне не видим. несколко упраляющих симвлов и символ "B"
когда терминал читает с диска поток байтов. то из за наличия нетолько байтов отвечающих за просто символы но и из 
за наличия управляющих терминалом байтов у нас на экране текст получается совсем не такой как он есть в файле.
таким макаром можно в тексте прятать информацию. вот еще пример
    $ printf "notebook Lenovo\rcarpet table wood\n" > 11.txt
    $ cat 11.txt 
    carpet table wood
тоесть по факту в файле есть символы "notebook Lenovo" но они при печати на терминале перетираются
из за управляющего символ '\r'
и мы видим только "carpet table wood"
хотя по факту в файле есть и то и то
    $ cat 11.txt | hexdump -C
    00000000  6e 6f 74 65 62 6f 6f 6b  20 4c 65 6e 6f 76 6f 0d  |notebook Lenovo.|
    00000010  63 61 72 70 65 74 20 74  61 62 6c 65 20 77 6f 6f  |carpet table woo|
    00000020  64 0a                                             |d.|
охуеть

следудуший спецсимвол образюущийся из за налияичия слеша это горизотальная табуляция \t
    $ printf "1\t2\t3\n"
    1	2	3
тоесть работате так. 
терминал печатает 1 потом он видит \t и делает своей печатающей головкой или курсором скачок направо на определенное
число пробелов. потом печатает 2 итак далее. вконце видит \n и тогда он прокручивает строку на 1 вверх
и возвращает печатную головку в начало строки.

следущий спецсимвол это верикальная табуляция. он чтото я не понял разницу между form feed и vertical tab
$ printf "1\v2\v3\n"
1
 2
  3
[vasya@lenovo !9]$ printf "1\f2\f3\n"
1
 2
  3

на выхлопе одно и тоже.

ксатти вовзращаясь назад. когда слэш экранирует спецсимвл лишая его силы. 
есть спец символ у принтф это %
    $ printf "%"
    bash: printf: `%': missing format character
тоеть поше нахууй
пробуем его экранировать
получаем почемуто опять пошел нахуй
незнаю почему
    $ printf "\%"
    bash: printf: `%': missing format character
и только прочитав man printf узнаем что % экранруется индивиудуаальным особым образом
    $ printf "%%"
    %
охуеть.

далее легко заметить и понять что когда мы в термиале виваем символ
то по факту в stdout или в файл улетает никако не символ а байт
    $ printf "a" | od -t x1
    0000000 61
тоесть скажем за символ "a" отвечает байт 0x61
свызь между символом на экране и байтом котоырй за ним стоит это либо ASCII таблица (man ascii)
либо это UTF-8 таблица. причем байты из ascii совпдают с UTF-8 байтами. 
так я это к чему говорю. можно указать принтф что мы вбиваем не печатный символ а сразу байт
скажем байт в hex виде в принтф прописывается как 
    \xHH
тоесть 
    $ printf "\x61"
    a
тоесть \x в поле формата сообщает принтф что это непросто литеры '\' и 'x' а что это спецсимвол который обозначает
байт в hex виде. показываю
    $ printf "a" | od -t x1
    0000000 61
    $ printf "\x61" | od -t x1
    0000000 61
соотвественно чтобы напечатать '\x61' просто как набор литер надо это экранировать
    $ printf "\\\x61" 
    \x61
тоесть мы обьяснили принтф что и \x это просто литеры. хотя непонятно почему вот такой варинт не прокатывает
    $ printf "\\x61" 
    a
ведь по идее мы сделаи \\ что обьяснило принтф что мы печатаем просто \ ну а дальше у нас просто x61
ксатти одиночные кавычки в этом плане все делают более предсказуемым
    $ printf '\x61' 
    a
тоесть видим что \x по прежнему интерпретируется как спецсимвол
но чтобы его обезвредить уже достаточно один раз применить слеш перед слеш
    $ printf '\\x61' 
    \x61

есть еще возможность указать принтф что мы печатаем не символы а байты в формате OCTAL
       \NNN   byte with octal value NNN (1 to 3 digits)

номер символа в формате UNICODE
       \uHHHH Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)
       \UHHHHHHHH
              Unicode character with hex value HHHHHHHH (8 digits)
но я не буду для этих случаев разбирать примеры.

теперь переходим к переменным принтф. хотя они у него называются аргументами.
окей буду называть их аргументами. 
значит помимо поля формат 
    $ printf "поле формата" 
у принф еще можно указать аргументы
    $ printf "поле формата" арг1 арг2 арг3
и тогда при печати эти аргументы будут вставлены в поле формата.
внутри поля формат мы обозначаем что мол сюда надо вставить аргумент через конструцию %T
где T это несколько возможных хреней. например
    %d означает что нужно взять аргумент , преобраозовать его в dec число и уже вставить 
пример
    $ printf "%d \n" "1"
    1 
тоесть он берет 1 преобразует его в 1 (то по факту в данном сулчае нихуя преобразоывать ненадо) и вставляет
в принтф. тоесть 
    printf "%d \n" "1"
превращается после подставновки в 
    printf "1 \n"
и мы получаем на экране
    1
возникает резонный вопрос а нахуя такой огород если можно сразу вставить 1 в поле формат. 
ответа я не знаю. тоесть например вот у нас есть переменная и вот у нас два совершенно равнозачных 
примера
    $ printf "$a \n"
    123 
    $ printf "%d \n" "$a"
    123 
единственный смысл такого усложнения горждения огорода я вижу в том что при таком раскладе само поле формат
может быть коротким и легко воспринимаем а сложные аргументы вынесены отдельно. например
    $ printf "%d \n" "$( echo "2*3" | bc)"
    6 
тоесть у нас поле формат маленькое компактное легко воспринимамое. а громоздкий аргумент вынесен во вне.
возможно в этом смысл такого огрода
раньше я думал что просто переменные нельзя вставлять напрму в поле формата. но как теперь понятно это не так.
причина не в этом.

так вот возврашаемся обратно к %d
как я уже сказал его смысл в том что мы берем аргумент и преобразуем его в dec вид 
и уже как литеру подставляем в поле формат. щас я покажу что значит преобразуем
    $ printf "%d \n"  "0xa"
    10 
значит у нас аргумент записан в hex виде (об этом щас поговорим). так вот %d его преобразует в dec тоесть 
0xa преобразует в 10 и постславяет уже как литера в поле формата
    $ printf "%d \n"  "0xa" ---> printf "10 \n"
    10
и получаем 10 на экране
таким образом видно что формат аргумента совершенно не обязан совпадать с форматом внутри поля формат. 
будет происходить преобразование.
и пиздец конкетной этой ситации в том что если мы находится в поле аргумент то hex формат в нем выглядит как "0xNN"
в то время как в поле формат hex формат выглядит совершенно по другому
    $ printf "\x21 \n"  
    ! 
правда и разница при этом колоссальная. hex число напряму в поле формата вставляется в байтовый поток 
как есть в виде этого hex числа без преобраования в литеру!
а hex число в аргументе как мы видим приводит к тому что оно будет преобразовано в литеру а какой у него будет 
байт уже зависит от ascii таблицы. еще раз показваю разницу
    $ printf "\x22"  
    "
    $ printf "\x22"  | od -t x1
    0000000 22

    $ printf "%d"  "0x22"
    34
    $ printf "%d"  "0x22" | od -t x1
    0000000 33 34

тоесть еще раз. hex формат в поле "формат" у нас в виде '\xNN'
а hex формат в поле "аргумент" совершенно другой в виде '0xNN'
почему так хуй знает.
но и последствия разные. в первом случае у нас 22h будет прям засунут в байтовый поток
а во втором случае hex число будет преобразовано в dec число. и будут найдены соотвствующие литеры в ascii
таблице чтобы это число в итоге нарисовать в терминале. тоесть "34" это 33h и 34h коды в таблице ascii
и тут приходит фундаментальный вопрос в голову а что еси у нас аргумент выглядит как '\x33\x34'
тоесть как мы видим это hex формат но он несоотвествует hex формату разрешенному при использовании для аргумента
    $ printf "%d"  "\x33" 
    bash: printf: \x33: invalid number
как говорится пошел нахер.
так вот как заставит принтф понимать что в аргументе используетсяя hex число просто в другом способе написания хекса.
так вот как это сделать для %d непонятно.
зато известен ключ %b
и вот что он делает
он берет то что находится в аргументе и считает что там прописаны голые байты. тоесть
    $ printf "%b" "\x21"
это полный эквивалент
    $ printf "\x21"
и в итоге получаем
    $ printf "\x21"
    !  
    $ printf "%b" "\x21"
    !  
тоесть %b берет аргумент и вставлят его в поле формата но не  в формет печатных литер а именно в виде голых 
байтов. при этом формат голых байтов должен соотвестовать правилу как эти голые байты могут выглядеть в поле формат.
пиздец
соотвстенно с этим волшенбным ключом %b мы можем использовать либо так либо так
    $ printf "%b" "\x21\x21\x21\x21"
    !!!!
    $ printf "\x21\x21\x21\x21"
    !!!!
тоесть ключ %b позволяет нам вынести из поля формата голые байты в аргумент.

приведу следущий ключ %s
он берет аргумент и вставляет как есть в форме символов как стринг.
    $ printf "%s \n" "\\\\%\\\\"
    \\%\\ 
    $ printf "%s \n" "\x21\x21\x21\x21"
    \x21\x21\x21\x21 

тоесть очень тупо и просто. ровно как мы видим символы в аргументе так они и будут напечатаны на экране

следущий ключ %c делает тоже самое что %s но печатает только первый символ
    $ printf "%c \n" "\x21\x21\x21\x21"
    \ 
    $ printf "%c \n" "\\\\%\\\\"
    \
    
    
 еще один полезный ключ это %x он или %X берет число из аргумента
и преобраует его в hex число и печатаем с помощью литер.
X отличается от  x тем что печатает результат в заглавном формате (большими буквами) 
    $ printf "%x \n" "10"
    a 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%X \n" "0xA"
    A 
    $ printf "%X \n" "0xa"
    A 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%x \n" "0xA"
    a 

ксатти вот еще интересно
    $ printf "%x" "0x21 0x33 0x34 0x56"
    bash: printf: 0x21 0x33 0x34 0x56: invalid hex number
    $ printf "%x" "0x21"
    21
    $ printf "%x" "0x2133"
    2133
    $ printf "%x" "0x21333456"
    21333456
    
по идее все самые важные и частые ключи  я описал.
соовественно если у нас есть переменная которая содержит ascii коды символов то чтобы их напечатать
именнов форме символов надо чтобы формат был вида \x21 тогда
    $ a="\x21\x33\x34\x56"
    $ printf "$a \n"
    !34V 
либо 
    $ printf "%b \n" "$a"
    !34V 

если же у нас a="21333456" либо a="0x210x330x340x56" либо a="21h33h34h56h"
то такие hex ascii коды  мы хрен распечатаем  в форме символов на раз два.
надо преобразоываать.
щас покажу. 
пусть у нас есть переменная которая хранить ascii коды в hex формате но вот в таком виде
    $ a="21333456"
и мы хотим их напечатать на экране в виде символов 
    $ sed 's/../\\x&/g' <<< $a
    \x21\x33\x34\x56
тоесть мы заменяем 
    21333456 -->  \x21\x33\x34\x56
тогда
    $ printf "%b \n" "$(sed 's/../\\x&/g' <<< $a)"
    !34V 
хотя самый простой способ превратить ascii коды "21333456" в символы это пойти по другому пути
    $ echo "21333456" | xxd -r -p | cat
    !34V

далее. вот еше прикол
понятчно и логично что если у нас  в поле формата (кстати идиотский термин) указано два аргумента
и по факту у нас два аргумента то в первый подставляется первый а во второй подставляеься второй
    $ printf "%d %d \n"  "10" "11"
    10 11 
но мне даже в голову не приходило пока не напоролся на пример в интете что 
число аргументов в поле формата может не совпадать с числом аргументов
и тогда походу они применяются по кольцу
    $ printf "%d \n" 1 2 3 4 5
    1 
    2 
    3 
    4 
    5 

пока все про printf
это не команда это какойто идиот ее писал. пиздец.






| $''

$'' эта конструкция имеет особый смысл
эта хрень позволяет определять стринг в баше аналогичный ""
причем подчеркну что $'' это единая конструкция.
так вот она дает то что эта хрень она понимает спецсимволы типа \n \t итп
это удобно если мы хотим задать например переменную у кооторой есть 
cпецсимволы.
пример
первый
    $ echo "\t1"
    \t1
как я понимаю в этом примере содержимое стринга "\t1" в памяти в байтовом виде представляет собой
    5Ch 31h, где 5Ch в ascii это символ "\" , 74h в ascii это "t",  31h в ascii кодах это "1"
соотвественно echo пытается печатать байтовый поток 0x5C7431

а вот второй пример
    $ echo $'\t1'
        1
как я понимаю в этом случае байтовое содержимое стринга в памяти совершенно другое,
а именно 0х09 "\t"  и 0x31 "1" тоесть суммарно байтовый поток содержимого стринга в памяти выглядит как 0x0931
поэтому эхо выводит другую картинку 
да можно конечно и вот так сделать
    $ echo -e "\t"1
        1
и мы получаем ровно тоже самое на выходе что и в предыдущем примере
однако механизм получения совершенно другой потому что эхо получает на входе поток 0x5C7431
но печатает не его а печатает модифицированный поток 0x0931
тоесть прикол в том что echo  с помощью спец ключа -e модифицирует входной поток. а  в предыдущем примере
поток байтов не модифицируется он тупо печатаются. 


хочу еще кое что показать
вот этот пример который отрабатывает кореектно
    $ a=$'\t \t \n \n 23'
    $ echo "$a"
	 	 
 
            23

так вот если мы обращаемся к переменной вот так "$a"
то у нас все коректно отрабатывает
    $ strace -e execve echo "$a"
    execve("/bin/echo", ["echo", "\t \t \n \n 23"], 0x7ffea8490db8 /* 66 vars */) = 0
        
а если мы убираем двойные кавычки
и обращаемся к переменной без кавычек вот так $a
то баш подставляет в execve уже некорректно
тоесть это именно баш по особому обрабатывает аргументы и подставляет в вызов execve
тоесть это не внешняя команда /bin/echo отрабатывает некоректно это именно бащ его вина
$ strace -e execve echo $a
execve("/bin/echo", ["echo", "23"], 0x7ffc356993e8 /* 66 vars */) = 0

тоесть echo "$a" и echo $a отрабатывает соверщенно по другому.  и это вина не эхо. 
это вина баша который анализирует командную строку и уже запускает эхо с совершенно разным аргументом.
этот момент я буду анализировать отдельно.

я хочу подчеркнуть что хрень $'' нужно использовать именно в таком виде. 
если это заюзать в виде "$''" то это уже неработает
    $ echo "$'\t1'"
    $'\t1'
    $ echo $'\t1'
        1



        

        

| ""
| string
| echo

хочу рассмотреть тонкий момент
и нихуя неописанный

рассмотрю на примере команды /bin/echo , тоесть эта команда не баш билтин
а внешняя по отношению к башу команда

и тут важно во первых вот что сказать вот мы в строке пуляем команду
    $ echo "123" "124"
и это все поступает в баш. он это все обрабатывает. при необходимости модифицирует и потом уже
запускает сисколл execve с параметрами. показываю на примере
в этом примере у нас в командной строке мы ввели \n а баш в execve сует нечто другое n
    $ strace -e execve echo -e \n
    execve("/bin/echo", ["echo", "-e", "n"] ...) = 0
а в этом примере у нас в командной строке мы ввели "\n" и баш в execve сует почти тоже самое "\\n"
    $ strace -e execve echo -e "\n"
    execve("/bin/echo", ["echo", "-e", "\\n"] ...) = 0
поэтому конечный результат другой не из за команды echo а из за того что баш подменяет то что
мы ему в комадной строке записали а он  в echo сует изменную хрень

тоесть важно понять что между тем что мы вбили на клаве и тем как реально будет запущена
внешняя команда с какими параметрами это разные вещи. получается вот такая схема
    мы  вбили в клаве команду  с параметрами ----> bash процесс ---> запуск внешней команды
поэтому то что мы вбили на клаве и как это будет в конечном итоге запущено это не всегда совпдает
из за того что посередине сидит баш который берет то что мы вбили и модифицириует и только потом
запускает внещнюю команду

поэтому чтобы реаьно понять как именно с каким аргументами была запущена таже самая echo 
нужно смотреть через strace

нуладно. двигаем дальше.
берем 
    $ man echo 
там сказано
вот какой у нее формат
    $ echo [SHORT-OPTION]... [STRING]...

я пытался найти как в баше задается стринг. 
но я не могу найти. что такое string? это просто любой набор символов с клавы?
или это набор символов заключенный в кавычки? я не могу найти ответ на этот вопрос
зато в man echo  я читаю вот такое

    If -e is in effect, the following sequences are recognized:
    \n     new line

тогда по идее 
    $ echo -e \n1
должно приводить к тому что \n должно дать перенос строки и потом напечатать символ "1"
однако на практике этого не происходит. а происходит полная хуйня
    $ echo -e \n1
    n1
хотя в man echo как я сказал написано совсем другое. и только если записать вот так
то работает как записано в man echo
    $ echo -e "\n1"

    1

из чего я делаю вывод что понятие STRING в баше это обязательно хрень заключенная в двойные кавычки.
иначе я не могу обьяснить результаты.
а что такое набор символов без кавычек тогда? я не могу найти.

тоже самое касается printf. в его man printf указано что \n должен приводить к новой строке.однако
этого не происходит.
    $ printf \n
    n
и только если мы заключаем эту хрень в кавычки то тогда оно отрабатывает как надо
    $ printf "\n"



тут попутно озвучу что в баш есть так называемые спецсимволы
# 
; 
" 
'
,
\
/
`
:
!
*
?
$
()
{}
[]
[[]]
(())
> &> >& >> < <>
|
>|
-
+
%
~
^
суть их  в том что бащ их по дефолут считает не просто символами печатными а спецсимволами, метасимволами.
(https://tldp.org/LDP/abs/html/escapingsection.html)

так вот я щас пытаюсь связать спецсимволы и кавычки ""
что дают кавычки. во первых я уже показал что только заключение в кавычки дает правильное поведение как 
пропсиано в манах для спецсимволов вида \n \t и тому подобных слеш спецсимволов.
так вот во вторых кавыки экранируют спецсимволы. заставляя баш (именн баш а не внешние команды типа echo) 
воспринимать спецсимволы как просто печатны символы. пример
    $ echo #

    $ echo "#"
    #

    $ strace -e execve echo #
    execve("/bin/echo", ["echo"] ...) = 0

    $ strace -e execve echo "#"
    execve("/bin/echo", ["echo", "#"] ...) = 0
    #

тоесть видно что между клавой и запуском echo сидит баш процесс который анализирует то чтомы вбили 
и в завсимости от того в кавычках или без он совсем разное вставляет в execve в поле аргументов.
тоесть
    вбили echo # --->  бащ процесс принимает и анализирует и видит что # указан без кавычек значит 
    он его рассматривает как спецсимвол и
    поэтому echo запускается вообще без аргументов ---> (execve "/bin/echo", ["echo"]) 

в bash advanced guide (https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html)
написано что все такие не все спецсимволы экранируются через "" 
а именно
    Enclosing characters in double quotes (‘"’) preserves the literal value of all characters 
    within the quotes, with the exception of ‘$’, ‘`’, ‘\’, and, when history expansion 
    is enabled, ‘!’. When the shell is in POSIX mode (see Bash POSIX Mode), the ‘!’ has no special 
    meaning within double quotes, even when history expansion is enabled. The characters ‘$’ 
    and ‘`’ retain their special meaning within double quotes (see Shell Expansions). 
    The backslash retains its special meaning only when followed by one of the 
    following characters: ‘$’, ‘`’, ‘"’, ‘\’, or newline. Within double quotes, backslashes 
    that are followed by one of these characters are removed. Backslashes preceding characters 
    without a special meaning are left unmodified. A double quote may be quoted within 
    double quotes by preceding it with a backslash. If enabled, history expansion will 
    be performed unless an ‘!’ appearing in double quotes is escaped using a backslash. 
    The backslash preceding the ‘!’ is not removed.
    The special parameters ‘*’ and ‘@’ have special meaning when in 
    double quotes (see Shell Parameter Expansion).

тоесть скажем знак $ он в "" не экранируется
поэтому мы можем "раскрывать" переменную внутри ""
пример
    $ let a="1"
    $ echo "$a"
    1


а теперь я покажу еще прикол. о том что я рекомендую не только STRING всегда заключать в кавычки
чтобы не получать приколы непонятные. но я также рекоедую всегда и имя переменной всегда заключать в 
кавычки чтобы не получать необьяснимые приколы. 
пример берем и делаем переменную со спецсимволами
    $ a=$'\t1'
    $ echo $a
    1
    $ echo "$a"
        1
и видно что когда имя переменной указано без кавычек  то получаем хуйню.
а когда в "" то получаем то что надо.

поэтому я бы постулировал что STRING в баше это только хрень заключенная в "" иначе мы будем получать
всякую непонятную хуйню.
и более того в "" нужно заключать и переменные иначе тоже будем получать хуйню.
хотя вот чисто экспериментальным путем я нашел вопреки манам как же заставить скажем echo 
раобтать со спецсимволами вида \n без использования кавычек. ответ такой что нужно вместо \n 
использовать \\n
пример
    $ echo -e \\n1

    1

    
    
| IFS
есть такая спец переменная у баша
она в себе содержит три символа. 
    - символ пробела
    - символ табуляции
    - символ новой строки
тоесть
    $ od -t x1 <<< "$IFS"
    0000000 20 09 0a 0a
где 
    20h  это пробел
    09h  это таббуляция
    0ф   это новая строка

так вот какой физ смысл этой встроенной в баш переменной?
значит баш использует символы в этой переменной для определения какие 
символы являются признаком разделителя так называемых слов.
бащ использует эту переменную только в некоторых специфических случаях.
первый случай это команда 
    $ read -a ARRAY <<< "1 2 3 4"
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
в данном случае символ пробела который есть в "$IFS" был найден в "1 2 3 4" и на основе
пробела этот стринг был разрезан на слова.
следущий пример это когда баш находит в $'1\t2\t3\t4' символ табуляции поэтому он разрезает эту переменную
на отдельные слова
    $ read -a ARRAY <<< $'1\t2\t3\t4'
    $ echo "${ARRAY[1]}"
    2
вот пример когда у нас бащ ненаходит в стринге ни пробела ни табуляции ни новой строки
поэтому стринг не разрезается на слова
    $ read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[1]}"

    $ echo "${ARRAY[0]}"
    1-2-3-4

а вот мы меняем "$IFS" и тогда баш уже находит в стринге символ который указан в IFS
и разрезает стринг на слова
    $ IFS="-";read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
хочу подчеркнуть что IFS срабатывает только в ряде небольшого числа случаев про коорые
надо прям конерктно читать. этих случаев мало. второй случай когда это работает это вот такой случай
далее я показываю ряд случаев причем я не понимаю почему в ряде случаев оно работает 
а в других нет
но разбирать почему я уже не буду
    $ a="1:2:3:4"
    $ for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ for i in "$(echo $a)"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$(echo $a)"; do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo $a); do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo "$a"); do echo "i=$i"; done
    i=1
    i=2
    i=3
    i=4

    
    

| <>
| << >>
| <<< >>>
| < <  > >
| |
| <(command)
| >(command)

<
начнем с "<"
эта штука читает из файла
тоесть справа в конечном итоге должно стоять имя файла
тоесть 
    < имя файла
справа только имя файла. болше там ничего поставить нельзя.
не получится. 
более точно формат выражени выглядит вот так
    $ command < имя файла
тогда ОС начинает сама читать из указанного файла и подавать байты на stdin процесса команды
более расширенный вариант это 
    $ command n< имя файла
где n это файловый дескриптор процесса command 
тоесть ОС сама читает файл и подает его на файловый дескриптор процесса с номер n
получается когда n мы не указваем то это по дефолту дескриптор 0
тоесть
    command < имя файла = command 0< имя файла
итак пример
    $ tr -d -c "1" < /dev/urandom | head -c1; echo ""
    1
значит что он делает ОС читает из файла /dev/urandom и подает эти байты
на stdin команды tr , и это главное. ну а далее детали. tr вырезает из потока все символы кроме
символ "1" и далее и потом из этого потока команда head выбирает один байт. 
последння команда нужна просто чтобы добавить перенос строки.
главное что нужно понять что  < можно употреблять только если у нас есть какойто файл. 
тогда мы его ставим справа то <. если файла нету то < употреблять нельзя невозможно.

    command < file_name

при этом совершенно понятно что сама команда она совершенно необязана читать байты которые 
подсовывает ей ОС. 
пример
    $ sleep 100 < /dev/urandom
тоесть команда sleep абсолютно не будет читать данные из urandom. 
хотя ОС ей на stdin подключает /dev/urandom
    $ ls -a1l /proc/24234/fd
        0 -> /dev/urandom

так тут я поправлюсь < не приводит к тому что сама ОС начинает читать файл. 
ОС лишь подключает /dev/urandom к stdin
а читает либо не читает из stdin уже код самой команды. если в команде  в ее коде нет
сисколлов на чтение то чтения не будет никакого.

аналогично команда 
    > file_name
она только подключает stdout команды процесса к  file_name
а будет писать на stdout команда процесса или не будет это уже зависит от кода команды. 
вот пример
    $ sleep 100 > /dev/urandom
    $ ls -a1l /proc/24395/fd
        1 -> /dev/urandom

и тут я перехожу к команда <<<
в чем ее ОГРОМНАЯ разница с <
а разница в том что справа от <<< должен стоять STRING
а справа от < должен стоять имя файла
и поэтому они применяются в совершенно разных ситациях
пример
    $ bc <<< "2*3"     <---- STRING
    6          
    
    $ head -c 1 < /dev/urandom   <---- файл
    k

как говорится заметь разницу
тоесть 
    command < file
делает то что на stdin процесса команды привязывается файл
а
    command <<< "STRING"
делает то что на stdin процесса команды подается то что находится в STRING
значит как я понял на подкорке это работает так что ОС создает сама файл в /tmp 
пишет туда сама "STRING" а потом когда этот файл прочитывает команда то ОС 
этот файл удаляет
    $ sleep 120 <<< "TEST"
    $ ls -1al /proc/24710/fd
    0 -> '/tmp/sh-thd.MNxZor (deleted)'
единсвтенное я не понял почему ОС удалила файл для команды sleep ведь она не читает 
свой stdin
вот еще способ проверки
    $ ls -l /proc/self/fd/ <<< "TEST"
    1 vasya vasya 64 дек  2 07:39 0 -> '/tmp/sh-thd.Olh22p (deleted)'
таким образом я сам для себя выяснил в каком случае есть смысл
использовать < а в каком случае использовать <<<
теперт это понятно. и понятно что использовать их можно только в совершенно
разных случаях.

получается что 
        command <<< "STRING"
это полный аналог команды
        echo "STRING" | command
ну типа получается что вариант с <<< он якобы более наглядный
ПРИЧЕМ важно еще заметить что <<< добавляет к исходному стрингу знак новой строки.
тоесть
    $ od -t x1 <<< "1"
    0000000 31 0a
тоесть в команду od влетает не просто байт 0x31 а еще и доблавляется символ новой строки 0x0a
таким образом полный аналог команды
            command <<< "STRING"
это именно команда
        echo "STRING" | command
но НЕ команда
        echo -n "STRING" | command
таким образом если нам важно не добавляеть к стрингу символ новой строки то нам 
нельзя пользоваться <<< а если мы нам похеру то можно.
вот еще раз я показыают какой байтовый поток вылезает из разных команд
    $ od -t x1 <<< "1"
0000000 31 0a
    $ echo "1" | od -t x1
0000000 31 0a
    $ echo -n "1" | od -t x1
0000000 31

вот еще на этих приерах видно когда одно и тоже получаем
а когда нет
    $ md5sum <<< "1"
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo "1" | md5sum
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo -n "1" | md5sum
    c4ca4238a0b923820dcc509a6f75849b  -



далее насколько я понимаю что >>> такой команды нет. 
потому что писать из stdout в "STRING" это бред
    $ echo "123" >>> "qwe"
    bash: syntax error near unexpected token `>'

далее >>
    command >> file
это аналог 
    command > file
с той разницей что в верхнем случае к концу файла добавляются данные
а во втором случае содержимое файла полностью удаляется и данные начинают
писаться в начало файла

далее <<
    command << file
как я понимаю такой команды нет


далее |
    command1 | command2
возникает вопрос в чем разница между > и |
можно ли как то через > заменить |
значит пайп приводит к тому что stdout первой команды
и stdin второй команды смотрят на один и тот же буфер в ядре. 
    stdout1 > буфер ядра > stdin2
тоесть никакой файл на диске не создается а используется буфер в ядре
так вот если command2 уже запущена то можно найти ее stdin на диске например  /proc/4444/stdin
и далее можно вот так извратиться
    command1 > /proc/4444/stdin
но повторюсь что для этого команда 2 уже должны быть запущена. а если она не запущена
то хрен ты так сделаешь. 
пайп позволяет отдать процесс увязки stdout1 stdin2 башу. 
в целом я бы сказал что > и < оно в целом предназначено чтобы читать и писать на реальные физ файлы
на диске либо спец файлы на /dev тоесть это более менее статичекие файлы причем никак не связанные 
с файлами процессов на /proc
пайп же предназначен для увязки между файлами на /proc которые там создает ядро для процессов.


далее <(command)
    command1 <(command2)
эта хрень называется bash process substitution
и она  не имеет отношения к 
    command < file
хотя вроде как немного на нее похоже
визуально можно заметить быстро разницу всегда из того что если это bash process substitution
то рядом с ним всегда стоит скобка
    <(...
а если это обычный файл редирекшн то между < и file всегда стоит пробел
    < file
у меня есть отдельная статья в этом же файле про bash process substitution.
здесь же краткое описание что как это работает
    command1 <(command2)
баш запускает command2 потом делает симлинк его stdout в файл /dev/fd/X
и подставляет в исходную команду имя этого файла
    command1 /dev/fd/X
еще раз имя файла подставляется как аргумент команды  command1
пример
    $ echo <(echo "1")
    /dev/fd/63

таким макаром конструкция 
    command1 <(command2)
имеет смысл если команда1 умеет читать из файла если ей указать имя файла как аргумент.
например тако умеет делать команда cat
    $ cat <(echo "123")
    123
и если мы хотим чтобы у нас stdout от одной команды был прочитан другой командой при условии что первая 
команда умеет читать из файла если он указан у нее как аргумент
обратная команда
    command1 >(command2)
пример
    $ cp /dev/urandom >(tr -cd "[:digit:]" | head -c10 | cat -)
    2054370200
как работает. запускается tr и его stdin через симлинк протаскивается в некий файл /dev/fd/X
и этот файл подставляется вот так 
    $ cp /dev/urandom /dev/fd/X
и cp копируется байты из urandom на stdin команды tr 
ну а дальше tr выбирает из потока только цифры. потом head берет первыех 10 цифр ну а cat их печатает.
теперь когда мы знаем что вместо 
    <(command)
    >(command)
подставляется как аргумент строки имя файла вида /dev/fd/X
будет понятен смысл вот такой конструкции
    $ wc -w < <(echo "a b c d")
    4
значит что это за загадочные < <
значит <(echo "a b c d") это bash process substitutution
а wc -w < это файл редиреккшн
если мы вспомним что в результатие bash pricess sustitution в исходную команду подставлется вот 
такая хрень /dev/fd/X то мы получаем 
    $ wc -w < /dev/fd/X
и теперь совершенно легко видно что оставшийся < это классический файл редирекшн.
справа стоит некое имя файла. а слева команда
конечно в данном примере можно было и не городить огород а сделать проще
    $ echo "a b c d" | wc -w
    4
но так возможно потому что wc такая команда она может работать как с stdin так и с файлами 
указанными ей в командной строке в качестве аргумента. другие команды не такие универсальные


напоследок разберу еше вот эти примеры

       $ cat <<< 1.bash
          1.bash
здесь понятно 1.bash воспринимается как стринг вида "1.bash"
тоесть просто набор литер

        $ cat < 1.bash
          #!/bin/bash
          ...
здесь получается что на stdin от cat привязан к файлу 1.bash
и cat читает из stdin тоесть в коненом итоге из файла 1.bash

        
        $ a="123"
        $ cat < "$a"
          bash: 123: No such file or directory
здесь понятно что  на фс нет файла с именем "123"

        $ cat <<< "$a"
          123
здесь тоже понятно что на stdin от cat привязан временный файл который содержит в себе "123"
котоырй ос создает сама в /tmp папке и поэтому cat читает из stdin по факту читает из /tmp/X
и рисует его содержимое 122


        $ cat < $(echo 123)
        bash: $(echo 123): No such file or directory
эта команда читает из файл с именем справа от >
результатом $(echo 123) будет 123 тоесть полный аналог команды это 
        $ cat < 123
но файла 123 на фс нет. поэтому пошел нахер


        $ cat <<< $(echo 123)
            123
аналог этой команды это 
        $ cat <<< "123"
эта команда позволяет засунуть стринг стоящий справа на stdin команды слева поэтому
такой резултат

        $ cat <$(echo 123)
комбинация <$(echo 123) это не bash process substituition потому что <$
результатом $(echo 123) будет 123 поэтому аналог это 
        $ cat <123
ее аналог это 
        $ cat < 123
но файл 123 на фс нет
а когда такой файл есть то все сработает
    $ echo "aa" > 123
    $ cat <$(echo "123")
    aa
тоесть в этом примере ловушка в том что вроде спервого взгляда кажетс что команда
    $ cat <$(echo 123)
это команда
    $ cat <(echo 123)
которая является bash process substitutuiion
но это не так потому что есть еще $

кстати я вверху писал что при файл редиреккшн между < и именем файла обязателно стоит пробел . вобще
то это не обязательно. 
и так и так верно
    command < file
    commadn <file
просто если это bash proces substittiuition то после < обязателно стоит (
    command <(command2)
и это его отлличает от файл редирекшн




| ascii

    $ man ascii

схема такая в устройство "терминал" поступает поток байтов. каждый байт
терминалом транслируется либо в печатный символ. либо это непечатный символа а управляющий
для терминала.

скажем 0x61 байт терминалом транслируется в печатный символ "a"
а байт 0x0a приводит к тому что терминал прокручивает картинку на 1 строку вверх и переводит печатную
головку в начало строки тоесть в самое лево и при этом конечно ничего не печатает. 
поэтому 0x61 это байт которые отвечает за печатный символ а 0x0a это байт который отвечает за
управление терминалом.

так вот среди них есть два таких байта
0x0E  (shift out) SO
0x0F  (shift in)  SI

что это за хрень. как пишект виикипедия из того что я понял был такой телетайп Model 38
это типа принтера матричного. и  у него было несколко лент разных цветом так вот эти байты
они переключали с черной ленты на красную ленту. 

дальше как я понял когда появились видимо более продвинутые матрчиные принтеры в котоорые как я понял
можно было загружаьт в память как бы доп символы например символы руского языка. то 
посылка байта SO приводила к тому что принтер начинал печатать рускими символами а SI печать латинскиими.

потом с появлением терминала VT100 это приводило к переключению символов на символы псевдографики.
тоесть скажем SO переключал на симолы псевдографиики а SI возвраащал обратно символы ascii.

в текущем окне терминала линукса посылание на терминал этих символов нихрена ни к чему не приводит.
наверное потому что по факту щас терминал работает на UTF-8 а не на ascii и тому подобное









## bash advanced scripting guide
    (https://tldp.org/LDP/abs/html/special-chars.html)


    
|как преобразовать число из двоичного или 16ричного вида в 10ый
    $ echo $(( 2#101011 ))
    43
    $ echo $(( 16#A ))
    10


    
    
    
|разделитель команд 
    ;
они пишут что после него надо обязательно ставить пробел





|шелл билтин .
что тоже самое source
эта хрень приводит к тому что скрипт выполняется в данном процессе. а не в новом.
обычно эта хрень делается чтобы в текущем процессе баша изменить или добавить переменные



|переенная "$PWD" содержит в себе текущую папку


|:
|встроенный билтин :
по факту он не делает нихрена
код возврата 0

: > file
уменьшает размер файла до нуля
даже если файл открыт 

: >> file
неделает нихрена если файл уже есть


: может использоваться как имя фукции но это нерекомендвано


|?
интересный пример использования ?
если $var1<98 то var0=9
иначе var0=21
охренеть
    $ (( var0 = var1<98?9:21 ))
правда непонятно зачем эта галиматься с (()) если все можно сделать без них

кстати
    $ echo $((var0=1))
    1

более простой пример. но для начала вот что
    (( 0 )) && echo "True \$?=$?" || echo "False \$?=$?"
    False $?=1

    $ (( 21 )) && echo "True \$?=$?" || echo "False \$?=$?"
    True $?=0

Итак если   (( 0 )) то False , 1
если        (( 21 )) то True , 0



так вот пример попроще
если 100 меньше 98 то тогда 0 иначе 21
в итоге получаем внутри скобки 21 
поскольку внутри скобки неноль то код возврата true тоесть 0
    $ (( 100<98?0:21 )); echo $?
    0

внутри скобки 0 значит код вовзрата false тоесть 1
    $ (( 1<98?0:21 )); echo $?
    1

далее
    $ echo $(( 1<98?0:21 )); echo $?
    0
    0
    $ echo $(( 100<98?0:21 )); echo $?
    21
    0
видно что можно распечатать содержимое скобки
код возврата всегда ноль потому что мы используем echo
а не просто голые скобки

еще раз наопмню что просто скобки они на stdout ничего не возвращают
но они возвращают код возврата в $?
а чтобы возвратить то что внутри скобок тогда надо 
    $ echo $(( 21 ))
    21

|$*
|$@

эти переменные почти одно и тоже.
показывает все аргументы скормленные скрипту

переменная $* берет все аргументы собирает их в одну переменную. тоесть
если

    $ ./03.bash 1 2 3 
то 
    $*="1 2 3"
то есть еще раз все отдельные аргументы будут собраны в одну переменную

а переменная $@ она собирает все аргументы в массив поэтому их можно 
потом выцепить по отдельности.
пример
    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done

запускаю
    $ ./03.bash  1 2 3
    $*=1 2 3
    $@=1 2 3

    $@[1]=1
    $@[2]=2
    $@[3]=3

    $*[1 2 3]=1 2 3

из чего видно что $@ это массив а $* это просто переменная в которой все аргументы собраны в одну кучу


| **
возведение в степень
    $ echo "$(( 2**3 ))"
    8




|$$

эта переменная показывает pid процесса скрипта

|()
эта хрень называется субшелл
пока мало ясно что это. 
как я понял все команды которые стоят внутри скобок запускаются в отдельном процессе

$ a="123"; echo "$a"; ( a="321"; echo $a); echo $a
123
321
123

как я понял основной смысл в скриптах использовать субшелл
это то что все переменные субшеллла никак не влияют на переменные основного шелла.
тоесть субшелл это чтото типа функции наверно.хотя возможо функция может 
влиять на глобальные переменные скрипта.

еще с помощью () обявляют массив
    $ a=( 1 2 3 )
    $ echo $a
    1
    $ echo ${a[*]}
    1 2 3


|{x,y,z}
фигурные скобки внутри которых 
элементы через запятые.
как я понял эта хрень работать так
если поставить символ скажем a до {
и поставить символ скажем b после }
то все хрени перечисленные внутри {}
будут обрамлены в ab.
пример
    $ echo \"{1,2,3}\"
    "1" "2" "3"
    $ echo a{1,2,3}b
    a1b a2b a3b

тоесть 1 2 3 перечислены внутри {}
а снаружи скобок стоят a и b
поэтому 1 2 3 обрамлены ими

также сказано что элемент внутри {}
перечиаляются через запятую и нельзя
между ними ставить пробел

    $ echo file.{txt,log}
    file.txt file.log

далее
не знаю что за правило но можно делать "вложенные" скобки
    $ echo {"a:","b:"}{"1","2"}
    a:1 a:2 b:1 b:2


    $ echo {"a:","b:"}{"1","2"}{"+","-"}
    a:1+ a:1- a:2+ a:2- b:1+ b:1- b:2+ b:2-

|{a..z}

    $ echo {a..z}
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    $ echo {1..10}
    1 2 3 4 5 6 7 8 9 10

| {; ; ; }
эта хрень на мой взгляд в основном нужна только для того чтобы 
для красивости обьединить команды в один красиво выглядищий кусок.
при этом никаких реальных дейтсвий эта команда не делает.
    $ { printf "1"; printf "2"; printf "3\n"; } 
    123
    $  printf "1"; printf "2"; printf "3\n"; 
    123
не вижу никакой разницы
важно после последней команды в скобках поставить тоже ; иначе пошлет нахер

без скобок я даже не знаю как вот такое сделать
    $ { printf "1+"; printf "2+"; printf "3\n"; } | bc
    6
максимум могу вот так
    $ printf "1+"; printf "2+"; printf "3\n" | tr "3" "c"
    1+2+c
в книжке написано что {} создает безымянную функцию. в отличие 
от обычной функции если мы внутри функкции определяем переменную
такую же как и в главном теле то то будет переопределена функция в главном теле.
тоесть безымянная функция может переопределять глобалные переменные
    $ a="1"; { a="2"; }; echo $a
    2

вот еще интересный пример
    $ { tr -cd [:digit:] | head -c 1 ; echo ""; tr -cd [:digit:] | head -c 1; echo ""; } < /dev/urandom 
    4
    8
    
эта штука работает так - запускается первая команда из скобки, пусть это внешняя команда, тоесть создается новый процесс.
и к его файл дескриптор 0 ядро подключает /dev/urandom. далее это уже забота самой команды либо читать из stdin 
или нет. как только первая команда отработала , то запускается вторая команда из скобки и ядро снова подключает к  stdin 
уже этого процесса файл /dev/urandom и так пока все команды из скобок не закончат свою работу

я бы сказал что эти скобки работают ровно как скобки из математики. тоесть берем математику
    ( 2+3 ) *5
раскрываем скобки
    2*5 + 3*5

тоесть ос когда работает с предыдущим примером она делает ровно вот так
    $ tr -cd [:digit:] < /dev/urandom | head -c 1 
    $ echo ""< /dev/urandom
    $ tr -cd [:digit:] < /dev/urandom| head -c 1 
    $ echo "" < /dev/urandom  

тоесть еще раз говорю что каждой команде внутри скобок подсовывается то что находится вне скобки.
что касается данного конкретного случая то далеко некаждая команда по своей сути читает из stdin
поэтому на какие то команды влияет это подключение а на другие нет

правда как этот пример переработать в эквивалент хрен знает
    $ { printf "1+"; printf "2+"; printf "3\n"; }  | bc
    6

мне кажется что проще всего понимать работу скобок так что скобка 
имеет некую единую stdin и stdout 
поэтому скажем вначале полностью отрабатывают все команды из скобки. они скажем
все срут на stdout и только потом все что было высрано командами внутри скобки
единым куском выплевывается во вне.
поэтому на bc поступает сразу единый кусок от всех трех printf

я даже в книжке нашел такое же описание

{



}  > 1.test # Redirects output of everything in block to file


также книжка дает еще один пример когда юзается {}
а именно {} используется  в команде xargs. {} в ней используется для подстановки
аргументов 
    $ ls -1 | xargs -I{}  echo "файл = {}"
    файл = 03.bash
    файл = 04.bash

    
также {} используется чтобы обозначать тело функции


| &>
эта хрень редиректит 1 и 2 в filename
    $ command &>filename 

эта хрень редиректит 1 в 2
    $ command >&2 


| >

примеры на счет использования >
    $ [[ "ab" > "cd" ]]; echo $?
    1
насколько я понимаю сравннеие идет следущим образом
берется байтовый поток обоих операндов и сравнивается как hex число
скажем ab=0x6162  cd=0x6364
вот эти два числа и сравниваются. какое больше то и победило

| pipe
берем такой код
    variable="initial_value"
    echo "new_value" | read variable
    echo "variable = $variable"     # variable = initial_value

первая команда в текущем процессе-1 задает variable="initial vaue"
вторая команда запускает дочений процесс-2 от процесса-1 для команды read variable. тоесть
    процесс-1 ===> процесс-2
вдочерний процесс-2 конечно клонируются
перменные из родительского процесса. поэтому картина такая 
    процесс-1 variable=initial_value
    процесс-2 variable=initial_value

так будет на моммент создания процесса-2
но далее эти перменные незавиисимы.

вторая строчка приведет к тому что в процесс-2 прилетит на stdin значение new_value в переменную variable
значит имеем
    процесс-1 variable=initial_value
    процесс-2 variable=new_value


третья строчка создает процесс-3 дочерний от процесс-1. клонируя при этом переенные. поэтому третья строчка напечатает что 
    variable=initial_value

насколько я понял если мы пишем в пайп и при этом есть проблема то в процесс которы пишет будет вернут
сигнал SIGPIPE (https://www.gnu.org/software/libc/manual/html_node/Operation-Error-Signals.html)

| >|

это force redirection.
через настрйоки баша можно задать что редирект неработает если файл уже сушествует.
так вот эта настройка преодолевает ту настройку
по умолчанию редирект в файл который уже существует разрешен . так что эта хрень
никогда не пригождается

| &

эта хрень позволяет раотать с джобами. по факту это баш создает дочерний процесс 
но не ждет пока тот выполнится сам ожидая в тени а после создания дочереннго процесса
обратно возврашает контроль на теоминалом себе. детали я не помню. конкретно данная хрень &
говорит о том что нужно поменстить прооцесс в бекграуд режим
пример
он создает два цикла. один выполняется в бекграуденде а второй в фореграунде
тоесть мы получаем в скрипте два параллельно работающих куска
что забавно
$ for i in {1..10}; do echo $i;sleep 3; done & for i in {11..20}; do echo $i; sleep 3; done
[1] 16570
11
1
12
2
3
13
14
4
5
15
16
6
17
7
18
8
19
9
20
10



| &&
это логический AND

правада иногда логический AND задется по другому
    if [ "$c" -eq 24 -a "$d" -eq 47 ]
    then #    ^              ^
    echo "$c equals 24 and $d equals 47."
    fi


| --
в командах опции задаются либо через - либо через --
зависит от самой команды

написано что в бащ билтинах эта хрень ообозначает конец области где задаются опции
не  в билтинах так не сработает

вобщем лучше набрать 
    $ man команда
    $ type команда
    
и посмотеть что там написано про --

| -

 
прикол с echo и -
    $ a="-n"
    $ echo "$a"
не выводит ничего. 

| ~+

это аналог $pwd

| ~-
это штука показывает предудущий рабочий каталог


| Ctrl
кнопки управления терминалом

Ctrl+A   перейти вначало строки
Ctrl+E   перейти в конец строки
Ctrl+B   стрелка влево
Ctrl+H   backspace
Ctrl+J   Enter
Ctrl+M   Enter
Ctrl+P   стрелка вверх
Ctrl+R   вылезает меню поиска предыдудущих команд по первой букве
Ctrl+S   продолжает принимать кнопки  с клавы но в термтинал их не передает
         то есть нажатия не теряюься но на терминал ничего не прилетает
Ctrl+Q   отменяет предыдущее. при этом мы увидим на экране все кнопки которые мы нажали 
         во время блока. 
Ctrl+T   меняет местами последние два введенных символа
Ctrl+U   если у нас курсор стоит посреди строки то удаляет все что левее курсора
Ctrl+W   тоже самое что предыдущее
Ctrl+Z   как я понял текущий процесс суется в бекграунд и там ставится на паузу


в мануале сказано что 
    a="^H" 
это аналог Ctrl+H 
но это полная хуйня. 
    $ echo "^H"
    ^H

| { }

я нашел замечательное примерение {}
если у меня есть какойто скрипт то чтобы его легко вбить надо всего навсего 

$ {

далее Ctrl-V скрипт 
и потом

}

и вуаля


| read
интеерсный билтин

    $ read -n10  -p '$$\>'
    $$\>
    
ключ -n дает то что символ поступают в read мгновенно а не как это есть по дефолту когда 
ожиается ввод Enter. -n 10 говорит о том что надо считать 10 символов и комарда закончит свою работу

ключ -p говорит о том что нужно на экране рисовать PROMPT тот который указан после -p в данном случае это "$$\>'
есть еще ключ -s который делает то что когда мы жмем кнопки на клаве то символы на экране не отображаются. да они улетают
в read но на экране не отображаются.

| col
как работает эта хуйня. ее ман это писаи ебанаты. в инете примеров норм нет. итак

$ echo $'\n\n\n\n  111 \v 222 \v 333 \v 444'   | col

		 444
	    333
       222
  111


значит по факту \n = \f+\r
тоесть прокркутка листа на строку вверх и вовзарат пеатной головки в самое левое положение.
\v это по идее верт и табуляция но по факту в линукс терминале это \f то есть прокрутка листа на 1 строку вверх
тоесть текс уехзжает вниз

так вот команда col она интерптиурет \v как прокрутка на 1 строку вверх а не вниз.
тоесть печатная головка поднимается наверх.
поэтому верхняя команда имеет расшифроку: опустись на 4 строки вниз и держи пеачатну гловку слева. напечаатай 111
потом подними головку на 1 строкувверх и напечаатй 222 потом подними печ головку вверх и напечаатй 333 потом поднимм
печ головку вверх и напечатай 444
тоесть таким макаром мы можем печатать текс не сверху вниз а снизу вверх.

единтвенная хуйня состоит  втом что перед тем как подниматься наверх надо обязательно опуститься вниз иначе выдаст segmentation fault
    $ echo $'\v 111'   | col
    Segmentation fault
тоесть мы еще не прокуртили лист вниз а уже пробуем поднимать головку на верх. так нихуя не работает. 
мы вначале должны опустить лист через \n (прикол что \f не подходит) и толко потом поднимать головку вверх
    $ echo $'\n \v 111'   | col
    111

тгда можно вот такое сделать

$ echo $'\n\n\n  111 \v 222 \v 333 \v 444 \n\t\t\t 555 \n\t\t\t\t 666 \n\t\t\t\t\t  777 \v 888'   | col
		 444
	    333 	 555
       222			 666	       888
  111					  777


прикол еще в том что col не понимает "\f" а жаль


| variable

оказывается что $a это сокращенная от ${a}

когда ициализируем переменную то нельзя иметь пробел слева от =
    $ a ="1"
иначе баш пытается выполнить команду a с параметром ="1"

оказется что запись
    $ a=
означает что a приварнивается значение NULL
я пока непонял эквивалетно ли это с
    $ a=""

по крайней мере
    $ a=
    $ echo -n ${a} | od -t x1
    
    $ a=""
    $ echo -n ${a} | od -t x1

на выходе байтовый поток один и тот же

оказывается можно инциализиоовать несколько переменных в одной строке через пробел

    $ a=1 b=2
    
если мы инициализируем переменную не испольуя кавычки то например "пробел"
надо экранировать

    $ a=1\ 2\ 3
    $ echo ${a}
    1 2 3

попытка напечатаать необьявленную  переменную выдаст null на выходе то есть пусто

обявление переменной это когда вот так
    $ a=
инициализациия переменной это когда мы обявляем переменную и задаем переменной значение
    $ a="1"

в любом случае резуллтат один и тот же в этих ообоих случаях
    $ echo "$b"
    $ a=
    $ echo "$a"
на выходе будет ничего
первый случай это когда переменная необьявлена
второй случай когда переменная обьявлена но неинициализирована

также оказвается что можно инициализированную переменную сделать обратно неинициализиованной
тоесть

    $ a="1"
    $ unset a
    $ echo "$a"

    
неиницализировнная перменная неимеет никаого значения а не ноль.

далее
в арифметических операциях если мы ссылаемся на необьявленную переменную то в таком случае
ее значение принимется равным нулю. это едиснчтенный случай когда необявленная переменная 
автоматом принимает значение прчием нулевое.

    $ unset a
    $ echo $a

    $ b=5
    $ echo $(( $a + $b ))
    5

далее.
опять же получается что когда мы иницализиуем переменную то нельзя чтобы ни слева ни српава от = стоял пробел.
иначе баш думает что мы ему дали команду с двумя аргуменатми

    $ a = 1
    a: command not found


переменную можно задать черещ то что ввести ее с клавы

    $ read  -p '> введите переменную и нажмите Enter > ' a; echo "a=$a"
    > введите переменную и нажмите Enter > 1
    a=1

еще переменную можно иницализиоовать вот так
    $$ a=`ls `
либо
    $ a=$(ls)

по сути они делают одно итоже. вторая команда это более новый синтаксис.
отличаются ли они внутри по реализации хрен знает


далее
наприсано что переменные у баша не имеют типов. а точнее они имеют один тип "character type"
но все равно можно желать например арифметические операции но для этого надо чтобы переменная содеражала только цифры
как я понял обработка переменных идет в завиисимости от контектса. то есть мы как бы обьясняем бащу как ему трактовать
переменную.

далее 
вот эта констурукция ${a/find/replace} ищет в переменной "$a" в любом ее места паттерн и меняет его на заданный
как толко находится паттерн то дальнйший поиск прекрашается
    $ a="#23#23"
    $ b=${a/23/45}
    $ echo "$b"
    #45#23

отличие ${a/find/replace} от ${a#find}  в том что второй всего навсего стирает заданный паттерн. причем только если 
паттерн стоит в самом начале переенной. также ${a%find} эта хрень удаляет строго с конца переенной кусок
    $ b="45#23"
    $ echo ${b#4}
    5#23
    $ echo ${b%3}
    45#2

тут параллельно вылезает такая хрень как билтин declare
например она позволяет задать свойство переменной такой что при ее дальнейше инициализации ее буквы.
я бы сказал что declare нам позволяет обьясниить башу какие значения может принимать переенная.
и тогда если мы будем давать этой переменной неправильные значения то баш будет нас посылать нахер
и преобразовывать наши неверные значения в некоторое более менее подходящее которое мы заказали
через decalre
пример declare -l огранчиывает значения только   lower case. если вводим upper case то они будут
автомтом сконвертрровны в lower case.
    $ a="AAAA"
    $ declare -l a
    $ echo "$a"
    AAAA
    $ a="BBBB"
    $ echo "$a"
    bbbb

видно что если переменная уже иницализиована и мы запускаем decalre то это никак не влияет на уже сущевтующее
значение AAAA.
а вот последующая инициализация уже проходит как надо и BBBB автоконвертиится в bbbb

а вот еще пример
declare -i огранииввает переменную только числами.
    $ declare -i b
    $ b="1"
    $ echo "$b"
    1
    $ b="a23"
    $ echo "$b"
    0

видно что когда мы задали значение переменной в форме запрещенной хрени "a23" то 
баш послал нас нахер и сконвертировал значение в 0. видимо дефолтовое значение если вводят хрень.
таким макаром ябы сказал что decalare это некий аналог типа переменных плюс автоконвертер.

кстати 
    $ declare ..
и
    $ typeset ..
это одно и тоже.

далее
declare -p позволяет посмотреть свойства переменной.

    $ declare -p  ab
    bash: declare: ab: not found

    $ ab=
    $ declare -p  ab
    declare -- ab=""

    $ ab=""
    $ declare -p  ab
    declare -- ab=""

насколко я поня из эксперимента что -- означает что на переменную не наложено никаких 
ограничений на значения. это значит что переменная была определена и иницаилизирована 
без использования declare

а вот другой пример на эту тему. 
мы определяем переменную через declare

    $ declare -i ab
    $ ab="123"
    $ declare -p ab
    declare -i ab="123"


можно посмотреть свойства встроенных системных в баш переменных

    $ declare -p IFS
    declare -- IFS=" 	
    "

    $ declare -p HOME
    declare -x HOME="/home/vasya"

едиснвтенрное я непонял смысл ключа -x = to make NAMEs export


все  полезные ключи declare
      -p	display the attributes and value of each NAME
      -i	to make NAMEs have the `integer' attribute
      -l	to convert NAMEs to lower case on assignment
      -r	to make NAMEs readonly
      -u	to convert NAMEs to upper case on assignment
      -x	to make NAMEs export


получается ключ -r позволяет задать константу
    $ unset a
    $ a="1"
    $ declare -r a
    $ echo "$a"
    1
    $ a="3"
    bash: a: readonly variable


в книжке я нашел стремный пример (https://tldp.org/LDP/abs/html/untyped.html)

    a=2334                   # Integer.
    let "a += 1"
    echo "a = $a "           # a = 2335
    echo                     # Integer, still.

    b=${a/23/BB}             # Substitute "BB" for "23".
                             # This transforms $b into a string.
    echo "b = $b"            # b = BB35
    declare -i b             # Declaring it an integer doesn't help.
    echo "b = $b"            # b = BB35


значит что этот пример делает. он беерет 2234 и сует их в $a
потом увеличиывает $a на 1 получаем 2235
потом мы берем 2235 и меняем на BB35 и присваиваем это b
итак b="BB35"
далее заупскается команда "declare -i b" и они печатают после этого $b и видят
что b=BB35 и пишут в коментацриях что мол декларе не помог превратить стринговую переменную в интеджер.
сука блядь. ну конечно же не помог. но декларе в этом не виноват. потому что как я писал выше декларе
АБСОЛЮТНО НЕ ВЛИЯЕТ на значение переменной которое уже есть. декларе влияет только на значение переменной
которое задается после применения декларе тоесть

показываю
    ...
    $ unset b
    $ b="BB35"
    $ echo $b
    BB35
    $ declare -i b
    $ echo $b
    BB35
    $ b="234"
    $ echo $b
    234
    $ b="BB234"
    $ echo $b
    0


далее. выше я писал что если переменная заобявлена или ее значение на иницализировано
и мы делаем арифемтечичекую оперцию с этой перепменной то баш ее значение в этом единственном
случае автоматом считает равным 0.
так вот эта же хрень имеет место если у нас переменная содержит символы.

    $ unset b
    $ b="BB35"
    $ echo $(( $b + 5 ))
    5

далее
если мы делим на переменную которое не обьявлена то 

    $ echo $((  5 / $abc ))
    bash: 5 /  : syntax error: operand expected (error token is "/  ")

а если мы делаим на переменную которая имеет символы в значении то по факту мы делим на 0

    $ echo $((  5 / $b ))
    bash: 5 / BB35 : division by 0 (error token is "BB35 ")
 
суммарно в плане declare я хочу сказать что польза от нее в том что если 
мы точно знаем что переменная должна принимать только числовые значения то можно 
это задать через declare хотя поведение при этом мне мало нравится. если бы
после этого при попытке присвоить пеерменной символы бащ выдавал ошибку
это было бы круто. а то что он втихаря корнвертирует стринг в 0 
неуверен что это поможет дебажить скрипт.
что касается автоковнертации стрингов в ловер кейс или аппер кейс помоему 
это вообще слабая хрень ненужная никогда или очень редко

кстати
    $ seq 10
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

кстати 
  eval это билтин баша который вот что делает "Execute arguments as a shell command."
тоесть если вставим аргумент в eval то этот аргумент будет выполнен как команда баша.
пример

    $ eval "ls -1"
    -
    03.bash
    04.bash
    05.bash
    10.bash
    11.txt


теперь беру такой пример
    $ seq 10 | sed -e 's/.*/export var&=1/'
    export var1=1
    export var2=1
    export var3=1
    export var4=1
    export var5=1
    export var6=1
    export var7=1
    export var8=1
    export var9=1
    export var10=1


тоесть seq создает числа от 1 по 10. и эта цифра подставляется вместо & в export var&=1
далее если мы это заключим в eval как аргумент тот этот код будет выполен в баше
пример

    $ seq 10 | sed -e 's/.*/echo "number = &";/' 
    echo "number = 1";
    echo "number = 2";
    echo "number = 3";
    echo "number = 4";
    echo "number = 5";
    echo "number = 6";
    echo "number = 7";
    echo "number = 8";
    echo "number = 9";
    echo "number = 10";

    $ eval $( seq 10 | sed -e 's/.*/echo "number = &";/' )
    number = 1
    number = 2
    number = 3
    number = 4
    number = 5
    number = 6
    number = 7
    number = 8
    number = 9
    number = 10


далее 
 переменные окружения передаются от родительского процесса его дочерним.
в обратную сторону связи нет. от дочери родителю ничего из переменных не передается.


далее
команда basename. она берет полный путь к файлу как аргумент. и возвращает только конечный файл
    $ basename '/home/vasya/temp/\!9/debug.bash'
    debug.bash
кстати надо заметить что хотя я использовал '' для указания пути но знак ! все равно нужно 
экранировать , так как иначе вместо !9 баш подставляет туда команду из баш хистори.

кстати 
можно сделать переменную как readonly нетолько через decalre но и через 
другой билтин readonly
во первых этот билтин может показать за один раз все переменные которые 
имеют свойства readonly

    $ readonly -p 
    declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote"
    declare -ir BASHPID
    declare -ar BASH_REMATCH=()
    declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
    declare -ir EUID="1000"
    declare -ir PPID="26695"
    declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor"
    declare -ir UID="1000"
    declare -r a="1"
    declare -r abc


как сделать переменную read only
    $ readonly abc
для сравнения через decalre это делается так
    $ declare -r abc

так вот далее я нашел такую шокирующую инфо о том что если мы переменную обьявили как константу (рид онли)
то обратно ее превратить в обычную переменную = нельзя никак. все что можно это убить этот процесс баша.
ничего сделать нельзя другого.но есть вот какой выход. мы можем запустить в данном баше
еще один баш. дочерний баш унаследует все переменые из родителя. но при этом переменная наша уже не будет
иметь статуса рид онли. пример

    $ readonly abc
    $ unset abc
    пошел нахер
    $ bash
    $ unset abc
    сукксесс
    

далее 
 -n $var  проверяет что длинна переменной НЕноль. если длина НЕноль то код возврата $?=0 (success)
пример
    $ a="123"; [ -n "$a" ] && echo "переменная \$a непустая"
    переменная $a непустая


далее
рассмотрим такой скрипт
    $ cat 06.bash 
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 

смотрим результаты работы
    $ ./06.bash 
    Parameter #1 отсуствует
    $ ./06.bash 1
    Parameter #1 is 1
    $ ./06.bash "1"
    Parameter #1 is 1
    $ ./06.bash ""1""
    Parameter #1 is 1
    $ ./06.bash "\"1\""
    Parameter #1 is "1"

что примечательно. если мы вызываем скрипт с аргументом который выглядит как 1 либо "1" либо ""1"" то он 
прилетает внутрь скрипта как 1.  
а если мы хотим чтобы внутри скрипта прилетел именно "1" то аргумент нужно в командной строке задавать как "\"1\""
удивительно.

далее. прикол
для того чтобы работать с аргументом 10,11 итд то нужно к ним обращаться внутри скрипта не как $10 или $11
а ${10) , ${11}
об этом написано в книжке

    $ cat 06.bash   
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 


    if [ -n "${10}" ]              
    then
        echo "Parameter #10 is ${10}"  
    else 
        echo "Parameter #10 отсуствует"
    fi 

работа скрипта
    $ ./06.bash 1 2 3 4 5 6 7 8 9 a
    Parameter #1 is 1
    Parameter #10 is a


далее
скрипт
скрипт берет путь к скрипту. удаляет из него весь путь кроме названия файла.
и потом к нему добавляет ./

    #!/bin/bash
    echo "путь к скрипту ./$(basename "$0")"

запускаем скрипт
    $ ./06.bash 
    путь к скрипту ./06.bash

далеее
еще раз напомню про $@ и $*
первая сохраняет все аргументы скрипта в массив.
а вторая собирает все аргументы в единую переменную

    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done


запускаю скрипт
    $ ./03.bash 1 2 3 4 5 6 7 8 9 a
    $*=1 2 3 4 5 6 7 8 9 a
    $@=1 2 3 4 5 6 7 8 9 a

    $@[1]=1
    $@[2]=2
    $@[3]=3
    $@[4]=4
    $@[5]=5
    $@[6]=6
    $@[7]=7
    $@[8]=8
    $@[9]=9
    $@[a]=a

    $*[1 2 3 4 5 6 7 8 9 a]=1 2 3 4 5 6 7 8 9 a

что интеерсно. что индексы в массиве начинаются с единицы походу. а не с нуля.

далее
 -lt 
означает less than. арифм сравнение
    $ a="12"; [ "$a"  -lt 100 ] && echo "\$a меньше чем 100"
    >>$a меньше чем 100

далее
на счет []
согласно man bash это одно и тоже
    $ test expr
    $ [ expr ]
    
также в баше есть билтин '['
но также есть и внешняя команда /usr/bin/[
так вот баш запускает именно внешнюю команду

$ strace [ 10 -lt  1 ]
execve("/usr/bin/[", ["[", "10", "-lt", "1", "]"], 0x7ffdd5429b60 /* 66 vars */) = 0

тоесть запускается файл  "/usr/bin/[" а дальше к этой команде присобачиваются аргументы. причем обязательно последним
аргументом нужно указать "]" иначе программа пошлет нахер/

получается первая скобка это название файла. далее идут аргументы. и последняя скобка это тоже аргумент.

что странно если я набираю 
    $ man [
он мне выдает man от команды /usr/bin/test
хотя /usr/bin/[ и /usr/bin/test это два разных файла

    $ stat /usr/bin/[
        File: /usr/bin/[
        Size: 51384     	Blocks: 104        IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23330837    Links: 1

    $ stat /usr/bin/test
        File: /usr/bin/test
        Size: 47288     	Blocks: 96         IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23332131    Links: 1

видно что иноды разные

хотя еще как я уже сказал и есть башевский билтин [

    $   builtin [ 10 -lt  1 ]


кстти выискивать что значат все эти -lt -n -d и прочие штуки для сравнения проще не в man bash а в 
    $ man test

| !

возвращаюсь к вопрому который уже освещал.
как в переменной укзать имя другой переменной и потом докопаться до этой второй переменной из первой переменной
а вот как
    $ a="1"
    $ b=a
    $ echo ${!b}
    1

замечу что именно ${!b} а вот так не работает ${!$b}

теперь если вернкемся к спец перееменным которые ест при вызове скрипта. то там есть спецпеременая $#
соовествнно ее имя # 
эта переменная укзаывает на число аргументов с которыми запущен скрипт. напоминаю что $0 это имя скрипта $1 первый аргумент
соовесвтенно $n это n-ый аргумент. получается если аргуметов 10 то $#=10 и значит эта же переменная показыает на две хрени 
сразу и на число переенных и на номер последней переменной. еще раp $# указывает на порядковый номер последней переменной 
но естевственно не содержит значение этой последней переменной. и чтобы посмотреть ее содержимое надо вот так 
    $ echo ${!#}
теперь имеем скрипт
он работает так
мы проверяем что число аргументов скрипта больше чем 0
если это так то мы печатаем содержимое переменной имя которой хранится в переменной с именем # тоесть ${!#}
потому что если аргументов 10 то $#=10 а нам нужно добраться до ${10}
    $ cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo "число аргументов 0"

запускаем его
    $ ./07.bash 
    число аргументов 0

    $ ./07.bash a b c 
    последний аргумент =  c

    $ ./07.bash 1 2 3 4 5  a b c d e f
    последний аргумент =  f


хочу заметить что если скрипт запущен без аргументов  то у него все равно всегда есть один аргумент $0 который
содержит имя скрипта. точнее путь к скрипту.

я модицфиуировал скрипт

    $  cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo -e "число аргументов 0,\nоднако \$0=\"$0\""

теперь запускаю скрипт без аргументов
    $ ./07.bash
    число аргументов 0,
    однако $0="./07.bash"

далее рассматривается интересная вещь.
вот у нас есть переменная
    $ a="123"
мы хотим создать новую перемнную которая будет в себе содержать "$a" + "_"
как это сделать. первая попытка
    $ b="$a_"
    $ echo $b

однако на выходе пусто. почему. потмоу что баш ищет переменную с именем a_ которой конечно нет.
а как нам тогда обьяснить то что мы хотим. а вот как
    $ b="$a"_
    $ echo $b
    123_

вот еще похожий пример
    $ read -p '>>' var1; echo "var1=$var1"; var2="$var1"_; echo "var2=$var2"; var3="${var2%_}"; echo "var3=$var3"
    >>890
    var1=890
    var2=890_
    var3=890

мы считываем переменную из клавы. потом добавляем "_" потом его отрезаем обратно.

до этого обсуждалась проверка вида -n $a которая проверяет что длинна стринга ненулевая.
есть обратная проверка которая проверяет что длинна стринга нулевая -z $a

    $ a="" && [ -z "$a" ] && echo "переменная пустая"
    переменная пустая
    

еще пример на созвучную тему

    $ cat 08.bash 
    #!/bin/bash

    if [  -z "$1" ] 
    then
        echo -e "ERROR: аргумент отсутствует \nUsage: $0 arg1 "
        exit 1
    else
        echo "аргумент = $1"
    fi

запускаю скрипт
    $ ./08.bash 
    ERROR: аргумент отсутствует 
    Usage: ./08.bash arg1 

    $ ./08.bash  "1a"
    аргумент = 1a

    
| ${var:-default}

эта хрень позволяет задать дефолтовое значение если значение переменной $var незадано или равно пусто
что вобщем то одно и тоже

    $ a="1"; b="${a:-33}"; echo "$b"
    1
    $ a=""; b="${a:-33}"; echo "$b" 
    33

эта хрень поможет в скрипте. если мы не хотим проверять был ли введен аргумент $1 или нет.
тогда нам поможет эта констркция.

    $ cat 09.bash 
    #!/bin/bash

    disk="${1:-sda}"
    echo "диск = $disk"

запускаю скрипт
если мы не указываем при запуске аргумент 
то баш подставляет в переменную дефолтовое предопределенное значение
    $ ./09.bash  sdb
    диск = sdb

    $ ./09.bash 
    диск = sda


| case


    case EXPRESSION in

    PATTERN_1)
        STATEMENTS
        ;;

    PATTERN_2)
        STATEMENTS
        ;;

    PATTERN_N)
        STATEMENTS
        ;;

    *)
        STATEMENTS
        ;;
    esac

кстати последння хрень это если не будет найдено ни одно значение.
а вот пример case когда он в одну строчку

    $ { case "b" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    b
    $ { case "z" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    не найдено


далее
пример
скрипт проверяет наличие аргумента при вызове скрипта.
и печатает этот аргумент
далее проверяется под каким именем файла был запущен скрипт.
если имя файла 10.bash или 11.bash то печатается имя скрипта

сам скрипт имеет имя 10.bash
также надо создать симлинк 11.bash 

    $ ln -s ./10.bash ./11.bash

    $ cat 10.bash 
    #!/bin/bash

    E_NOARGS=75

    if [ -z "$1" ]
    then
        echo  "Error: NO_ARGS"
        echo  "Usage: $(basename $0) [ARG]"
        exit $E_NOARGS
    else
        echo "аргумент = $1"
    fi



    case "$(basename "$0")" in

        "10.bash")
            echo "скрипт запущен как  10.bash"
            ;;

        "11.bash")
            echo "скрипт запущен как 11.bash"
            ;;

        *)
            echo "неопознанная ошибка"
        exit 1
            ;;
        esac



запускаю скрипт
    $ ./10.bash    
    Error: NO_ARGS
    Usage: 10.bash [ARG]

    $ ./11.bash    
    Error: NO_ARGS
    Usage: 11.bash [ARG]

    $ ./10.bash    123
    аргумент = 123
    скрипт запущен как  10.bash

    $ ./11.bash  234  
    аргумент = 234
    скрипт запущен как 11.bash



| shift

как уже было сказано выше он сдвигает аргументы которые были указаны при вызове скрипта
тоесть второй аргумент присваивается первому 
    $2 ---> $1
третий аргумент присвивается второму
    $3 ---> $2
единственное что $0 остатеся неизменным. это логично


напомню что shift может сдвигать нетолько на 1 аргумент влево но и на другое число
    $ shift N
по факту эта команда делает вот что. она берет и сжирает первые N аргументов. 
щас покажу

    $ cat 12.bash 
    #!/bin/bash

    until [ -z "$1" ]
    do
        echo "\$@=$@"
        shift 8 || break
    done

запускаю скрипт
    $ ./12.bash  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
        $@=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
        $@=9 10 11 12 13 14 15 16 17 18 19 20
        $@=17 18 19 20

тоесть мы имеем N=8 значит на первом этапе сжираются аргументы 1-8
было 
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
стало
                    9 10 11 12 13 14 15 16 17 18 19 20

далее на следущем шаге опять сжираются 8 первых арументов
было 
    9 10 11 12 13 14 15 16 17 18 19 20
стало
                            17 18 19 20


далее что происходит если shift хочет сожрать 8 аргументов а нужного числа арунментов нету
как в случае 

    17 18 19 20

так вот происходит то что шифт останавливается. нихрена неделает. и выдает $?=1

я бы сказал что более удобно рассматривать что shift не сдвигает аргументы. а сжирает аргументы.
тоогда все понятно.
единственно что помним что аргумент $0 этой командной не трогается.

| $0
если  мы запустили скрипт то в $0 содержится путь к файлу скрипта.
а если мы запустили echo $0 из командной строки то оно показвыает bash

    $ echo $0
    bash


| []
следущий пример выбирает файлы
которые начинаются либо с "0" либо с "1"

    $ ls -1 [01]*
    03.bash
    04.bash
    05.bash
    06.bash
    07.bash
    08.bash
    09.bash
    10.bash
    11.bash
    11.txt
    '12 13'
    123
    12.bash
    1.bash


    
    
    
    
| ""
| ''


тема quoting в баще

квоутинг делает то что ряд спецсимволов перестает быть спецсимволом и становится
только печатным символом. но бывают команды которые все равно плюют на квоутинг
и продолжают воспринимать спецсимволы
пример

    $ grep '[Vv]' t*.txt
    t1.txt:vasya
    t2.txt:Vasya

    
    
| command

это билтин
делает он то что запускает команду. спрашивется нахуй тогда он нужен.
а нужен он затем что если у нас в скрипте есть функция с именем таким же как команда 
то command позволяет запустить не функцию а именно команду.
работает хрень вот так
    $ $ command ls -1
    03.bash
    04.bash
в целом вобщем то бесполезный билтин


| \


знак \ позволяет экранировать спецсимволы внутри ""
в итоге если мы будем экранировать не спецсимвол то напечаатется и слэш и простой символ
пример
    $ echo "\a"
    \a

если мы экранируем спецсимвол то сам слэш исчезает . будет напечатан только спецсимвол как
просто символ
прмиеры
    $ echo "\\"
    \

    $ echo "\$"
    $

    $ var2="\\\\\""
    $ echo "$var2"
    \\"

чтобы избежать непонятных непоняток я рекомендую всегда все переменные заклчать в ""
иначе результаты будут часто непредсказуемые.


вот это подьебочный пример

    $ echo "$(echo '"')"           # "
    "

хрень  состоит из двух частей
    "$(echo '"')"   +      # "   
которое можно схематично представить как 
    "..."  +    #"
    
что можно представит схематично как
    $ echo "..."     +   # "
из чего наконец можно понять что мы получим на выходе то что у нас есть команда echo и справа от нее просто
напросто стоит комментарий (который начинается с символа #).
поэтому комментарий можно свободно выкинуть ибо он ни на что не влияет тогда получаем
    $ echo "..." = $ echo "$(echo '"')" = $ echo """ => на выходе будет "
проверяем
    $ echo "$(echo '"')"           # "
    "
совпало.
пример было пиздец
еще пример пиздец
    $ var1="Two bits"
    $ echo "\$var1 = "$var1""
    $var1 = Two bits
насколко я понимаю эта хрень работает так. он берет кавычку и ищет ближайшую кавычку справа.тогда
    echo "\$var1 = "$var1"" = echo "\$var1 = "    +  $var1  +  ""
тоесть у echo стоит три аргумента
    "\$var1 = "
    $var1
    ""
первый и третий аргумент заключены в кавыки а второй нет. 
печать первого аргумента даст
    $var1 = 
печать второго даст
    Two bits
печать третьего даст пусто . в итоге на экране будет
    $var1 = Two bits
что мы и имеем на практике

вот несколько изменный тот же пример где 
я подсветил каждый из трех аргументов
    $ echo ">\$var1 = <"       $var1        "><"
    >$var1 = < Two bits ><


| "

внутри двойных кавычек можно без проблем печатать одинарные кавычки
пример
    $ echo " '   "
    '   
    $ echo " ' '  "
    ' '  
никаких проблем
как и в этом прмиере
    $ echo "Why can't I breath 's between single quotes"
    Why can't I breath 's between single quotes


    
    
    
| '
одиночная кавычка якобы блокирует все спецсимволы. кроме символа '
если мы хотим напечатать ' внутри '' то  не получится
пример
    $ echo '''
    > 
тоесть этот пример это аналог 
    $ echo ''   '
тоесть у нас есть одна пара закрытых кавычек и есть одна пара незакрытых кавычек
поэтому пошел нахер говорит баш

| \

приколнно что это будет напечатано в две строки
    $ echo "This will print
        as two lines."

потому что когда мы тыкаем Enter мы "печатаем" символ Enter

    $ echo "a
    > b"
    a
    b

    $ echo "a
    b" | od -t x1
    61 0a 62 0a

и так как \ стоящипод кавычками оотключает значение спецсисмволов то он отключает и значение спецсимвола 0x0a 
    $ echo "a\
    > b"
    ab

    $ echo "a\
    b" | od -t x1
    61 62 0a

    
опять же повторюсь что если слеш стоит не перед спец символом то он не исчезнет а будет напечатан
    $ echo "\a"
    \a
а если он стоит перед спецсимволом то он не будет напечатан
    $ echo "\$"
    $


еще момент. если эхо запущен без -e то слэш только экранирует спецсимволы
    $ echo "\t1"
    \t1
а если эхо с клюючом  -e то комбинация слэша с некоторыми обычными символами
рассматривается как спецсимвол. например \t это горизональная табуляция
пизздец ебанизм и заморочка
    $ echo -e "\t1"
            1
            
            
тоесть зацени разницу
одна и таже команадна с одним и итем же аргументом но 
без ключае -e и с ключом -e
    $ echo  "\t\t\t\t1"
    \t\t\t\t1
    
    $ echo  -e "\t\t\t\t1"
                    1

            
кстати если юзать $'....' то ключ -e и ненужен
    $ echo   $'\t\t\t\t1'
                    1

замечу что одинарные кавычки ' внутри "" абсолютно леагальны. и их ненужно эакраинировать
    $ echo "Introducing the \$\' ... \' string-expansion construct . . . "
    Introducing the $\' ... \' string-expansion construct . . . 

    $ echo "Introducing the \$' ... ' string-expansion construct . . . "
    Introducing the $' ... ' string-expansion construct . . . 

еще интереный пример
    $ echo "1   $'\n\n' 2"
    1   $'\n\n' 2

тоесть $'' неработает внутри ""
тоесть нужно $'' вынести за ""
пример
    $ echo "1   " $'\n\n'"  2"
    1    

        2
            
здесь у нас три аргумента под эхо
    "1   "
    $'\n\n'
    "  2"

вот еще пример о том что $'' неработает если находится внутри ""
    $ echo  $'\n\n1'


    1
    
    $ echo  "$'\n\n1'"
    $'\n\n1'


| tac
| cat
| rev

есть такой прикол команды 
    cat
    tac
    rev
в чем их разница?
вот у нас есть файл
    $ printf  "123\n456\n789\n"
    123
    456
    789

cat его читает с нулевого оффсета и до конца файла
    $ printf  "123\n456\n789\n" | cat 
    123
    456
    789
    
tac его читает с конца построчно
тоесть у нас в тексте будут переставлены строки
скажем если нумеровать строки то у нормально документа
они идует как 1,2,3....100
а после чтения его чеерез tac строки будут идти 100,99...1
символы в строках порядок сохраняют оригинальный
    $ printf  "123\n456\n789\n" | tac
    789
    456
    123

вот более понятный пример 
про разницу cat и tac
    $ printf  "1. mama\n2. mila\n3. ramu\n" | cat
    1. mama
    2. mila
    3. ramu

    $ printf  "1. mama\n2. mila\n3. ramu\n" | tac
    3. ramu
    2. mila
    1. mama

тоесть еще раз переставляются строки но не символы в строке
для работы tac ему нужно читать файл сконца к началу искать очередной
символ 0x0a а потом его в памяти переставлять, тоесть ему читая
символы в обратном порядке нужно найти конец предудущей строки. 
а потом переставить символы в строке из обратного порядка к нормальному.
поэтому tac работает в несколько раз медлнее чем cat

вот я взял файл размером 1,59GB 

    $ cat "./17830.txt" | pv 1>/dev/null  
    1,59GiB 0:00:01 [1,07GiB/s]
    
    $ tac  "./17830.txt" | pv 1>/dev/null  
    1,59GiB 0:00:05 [ 316MiB/s]
    
как говорится почуствуй разницу

и последняя команда rev.
она работает вот как. она читает файл
с начала файла. прочитвыает строку 
(тоесть ищет 0x0a)
а далее она в этой строке перетавляет
символы зеркально наоборот.
поэтому строки не будут переставлены
будут переставлены символы в каждой строке.
примеры

оригинальный файл
    $ printf  "1. mama\n2. mila\n3. ramu\n" 
    1. mama
    2. mila
    3. ramu

обработка через rev
    $ printf  "1. mama\n2. mila\n3. ramu\n" | rev
    amam .1
    alim .2
    umar .3

оригинальный файл
    $ printf  "123\n456\n789\n"
    123
    456
    789

обработка через rev
    $ printf  "123\n456\n789\n" | rev
    321
    654
    987

получается tac переставляет строчки а rev переставляет символы.
значит если мы хотим получить файл у которого полностью переставлены все символы.
тоесть чтобы он стал записано полнтстью с зада на перед то надо вот как сделать

оригинальный файл
    $ printf  "1. mama\n2. mila\n3. ramu\n" 
    1. mama
    2. mila
    3. ramu

задом наперед
    $ printf  "1. mama\n2. mila\n3. ramu\n"  | tac | rev
    umar .3
    alim .2
    amam .1

получается что tac читает файл с конца  а rev читает с начала. 

    

    
| clear
внешняя команда.
очищает окно терминала

| read

если мы не указали в какую переменную или переменные считывать данные то по дефолту 
данные считываются в переменную $REPLY

с помощью read можно узнать какой байт или байты влетают в комп
при нажатии той или иной кнопки. в том числе и спец кнопки типа ESC, DEL, BACKSPACE, ENTER

    $ clear; read -s  -p '>>нажмите кнопку и нажмите Enter>>'; \
      echo ""; echo -n "код кнопки "; od -t x1 <<< "$REPLY" |  head -n1 | cut -c 8- | rev | cut -c 3- | rev

      >>нажмите кнопку и нажмите Enter>>
     код кнопки  1b 5b 32 7e
 
 
оказывается что простецкие кнопки типа "a" "b" посылают всего один байт.
например если тыкнуть кнопку "a" то получим

    >>нажмите кнопку и нажмите Enter>>
    код кнопки  61 

еще ксатати кнопка ESC посылает тоже только 1 байт

    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 
    
а вот если мы жмем спецкнопки типа DEL,  ENTER, Pg_Up
то эти кнопки посылают за нажатие сразу несколько байтов

DEL:
    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 5b 33 7e
    
    
Pg_UP:
    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 5b 35 7e

чтобы кнопку Enter отсканировать то надо сменить скрипт
    $ clear; read -n4 -s  -p '>>нажмите кнопку>>';       echo ""; echo -n "код кнопки "; od -t x1 <<< "$REPLY" | cut -c 8-
    >>нажмите кнопку>>
    код кнопки  0a


    
как отсканировать кнопку BAckspace непонятно. ладно двинем дальше.

далее мы хотим считывать с клавы кнопки которые высирают от одного байта 
по четыре байта. тоесть число байтов разное. потому что нажатие на одну кнопку 
приводит к тому что клава высирает в ос один байт. а нажатие на другую кнопку
привод к тому что ос высирает в ос четыре байта. или три байта.
и чтобы это можно сделать без нажатия на Enter после нажатия на кнопку.
положим мы нажимаем на кнопку которая высирает 4 байта за раз. типа кнопка Insert
    $ read -s -n1 a; read -s -n2 b; read -s -n1 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 32 7e
вот мы получили код этой кнопки
тоесть клава срет 4 байта, первая команда read считывает первый байт,
вторая команда считывает следущий два байта,
третья команда считывает последний четвертый байт

кстати я тут нашел одну хрень нужно заменить -n на -N 
потому что если юзать -n то read в этом случае игнорирует влетающие 
байты которые совпадают с тем что указано в IFS.
в IFS у нас в частности есть байт пробела . поэтому если мы 
будем нажимать пробел то read его будет игнорировать и ждать
дальше прилета друогого байта а если юзать -N то если в read
влетает байт соотвествующий пробелму то он его радостно
всасывает
поэтому

    $ read -s -N1 a; read -s -N2 b; read -s -N1 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-


но тут проблема получается если у нас пуляется c клавы один байт
тогда у нас срабаыватет первый read. управление передается второму read. но так как
байт всего один с клавы то вторая команда будет висеть вечно! поэтому нам надо 
для второй и третьей команды установить тайм аут. чтобы они отваливались если тайм аут достингнут.
кстати поправка- как я понял кнопка на клаве порождает либо один байт либо три либо четыре. 
вроде как два байта породить кнопка не может. поэтому второй read это два байта читает. тогда делаю
поправку  я во второй и третий read вставляю таймаут после которого команда заканчвает свою работу

    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-


тогда нажимаю "SPACE":
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    20

нажимаю INSERT:
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 32 7e

нажимаю "стрелка направо":
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 41






далее скрипт из интернета:
работает он так
инициализируется переменная 
    key="кнопка не нажата"
на экране печатается баннер
потом печатается на экране содержимое переменной $key  
    You pressed: \'"$key"\'
далее система ожидает поступления одного байта
причем ждет она этого бесконечно
    read -s -N1 -p "Press a key: "
если мы нажали кнопку то там еще тогда отрабатывает два read
причем там уже нет бесконечного ожидания поступления байтов.
наоборот там есть таймаут для ввода
    read -s -N2 -t 0.001
    read -s -N1 -t 0.001

справшивается нахуя такая сложная схема
почему нельзя заменить эти три рида одним. 
это сделано из за того что после нажатия кнопки
в ос прилетает разное количество байтов. 
от 1-го байта до 4-ех байтов
поэтому если мы заменим все одной командой которая 
читает 4 байта
    read -s -N4 -p "Press a key: "
то при нажатии кнопки которая выдает один байт
то эта команда будет ждать поступления оставшихся трех байтов.
а их то не будет. или надо будет нажать кнопку четыре раза.
а это нам не подходит.
можно конечно сделать по другому. можно убрать из read описание 
сколько байт нужно считать и заменить это тем что надо нажать кнопку
а потом нажать кнопку Enter 
но в том то и прикол что мы нехотим после нажатия кнопки нажимать еще и Enter
мы хотим обойтись без Enter
тогда работает такая схема
    read -s -N1 -p "Press a key: "
    K1="$REPLY"
    read -s -N2 -t 0.001
    K2="$REPLY"
    read -s -N1 -t 0.001
    K3="$REPLY"

первая команда ждет поступления одного байта с клавы
пока байт непоступит команда ждет. ждет бесконечно.
далее следущая команда уже неждет бесконечно. она ждет всего навсего t=0.001c
и ждет с клавы два байта. и последняя команда ждет t=0.001с ждет поступления 
один байт.
это дает то что если мы нажали кнопку и клава на это высирает в ос всего один байт то 
K1="байт"
а K2=""
K3=""
если же после нажатия кнопки с клавы летит 4 байта. то 
тогда будет
    K1="байт"
    K2="два байта"
    K3="байт"
таким макаром эта схема позволяет ловить с клавы от один,
три, четыре байта. и при этом ненадо нажимать Enter после
нажатия кнопки. после этого переопределяется 
переменная $key
    key="$K1$K2$K3"
далее перезапускется цикл while,
очищается экран через clear
печатается баннер.
анализируется $key и он печатается тоже.
далее появляется первая команда read 
который ждет первый байт. причем ждет бесконечно
    read -s -N1 -p "Press a key: "
и пока кнопка не нажата этот read будет 
ждат бесконечно  и экран не будет стираться через clear 
поэтому. тоесть clear срабатывает только после 
того как нажата кнопка. 
как только кнопка нажата то цикл идет на новый цикл


>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<
$ cat 13.bash 
#!/bin/bash


key="кнопка не нажата"

while true; do
  clear
  echo "Bash Extra Keys Demo. Keys to try:"
  echo
  echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
  echo "* The four arrow keys"
  echo "* Tab, enter, escape, and space key"
  echo "* The letter and number keys, etc."
  echo
  echo "    d = show date/time"
  echo "    q = quit"
  echo "================================"
  echo





 case "$key" in
  $'\x1b\x5b\x32\x7e')  # Insert
   echo You pressed: \'Insert Key\'
  ;;
  $'\x1b\x5b\x33\x7e')  # Delete
   echo You pressed: \'Delete Key\'

  ;;
  $'\x1b\x5b\x48')  # Home_key_num_7
   echo You pressed: \'Home Key\'

  ;;
  $'\x1b\x5b\x46')  # End_key_num_1
   echo You pressed: \'End Key\'

  ;;
  $'\x1b\x5b\x35\x7e')  # Page_Up
   echo You pressed: \'Page_Up Key\'

  ;;
  $'\x1b\x5b\x36\x7e')  # Page_Down
   echo You pressed: \'Page_Down Key\'

  ;;
  $'\x1b\x5b\x41')  # Up_arrow
   echo You pressed: \'Up Key\'

  ;;
  $'\x1b\x5b\x42')  # Down_arrow
   echo You pressed: \'Down Key\'

  ;;
  $'\x1b\x5b\x43')  # Right_arrow
   echo You pressed: \'Right Key\'

  ;;
  $'\x1b\x5b\x44')  # Left_arrow
   echo You pressed: \'Left Key\'

  ;;
  $'\x09')  # Tab
   echo You pressed: \'Tab Key\'

  ;;
  $'\x0a')  # Enter
   echo You pressed: \'Enter Key\'

  ;;
  $'\x1b')  # Escape
   echo You pressed: \'Escape Key\'

  ;;
  $'\x20')  # Space
   echo You pressed: \'Space Key\'

  ;;
  d)
   date

  ;;
  q)
  echo Time to quit...
  echo
  exit 0

  ;;
  *)
   echo You pressed: \'"$key"\'

  ;;
 esac

 echo
 echo "================================"

 unset K1 K2 K3
 read -s -N1 -p "Press a key: "
 K1="$REPLY"
 read -s -N2 -t 0.001
 K2="$REPLY"
 read -s -N1 -t 0.001
 K3="$REPLY"
 key="$K1$K2$K3"

done

exit $?

>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<


запуск скрипта
    $ ./13.bash

Bash Extra Keys Demo. Keys to try:

* Insert, Delete, Home, End, Page_Up and Page_Down
* The four arrow keys
* Tab, enter, escape, and space key
* The letter and number keys, etc.

    d = show date/time
    q = quit
================================

You pressed: 'Escape Key'

================================
Press a key: 




| echo
| \

далее еще раз коснусь темы
в этом примере работает такая логика.
если слэш под двойными кавычками и за ним стоит обычный символ
то баш печатает слэщ
    $ echo "\a"
    \a

если под двойными кавычками за слэшем стоит спец символ ( а слэш внутри двойных кавычек это есть спецсимвол)
то слэш не печатается а спецсимвол теряет свою спецсимвольность и печатеся как простой символ
поэтому один слэш исчезает а второй печатается
    $ echo "\\a"
    \a

еще момент. 

    $ a="\\"
    $ echo "$a"
    \

    
далее
я теперь малек понял почему если мы в командной строке баща ввоим команду потом вводим \ 
потом тыкаем Enter и у нас ввод команды продолжается. потому что слэш экранировал последующее нажатие Enter.

| |
| pipe

если мы в командной строке стоит пайп "|" и жмем Enter
то слэш вводить ненадо. автоматом баш ждет от нас продолжения ввода.

    $ echo "1" | 
    > 
    
| exit code

код возврата из дочернего процесса поступает в родительский процесс.

если в скрипте  в явном виде в конце не указана команда exit $код_возврата
либо указана команда exit но без кода возврата 
то код возврата берется из статуса выполнения последней команды в скрипте

и еще в одном случае 
 exit $?
в этом случае тоже код возврата будет браться из кода из предыдудщей команды
потому что понятно почму. потому что $? это всегда код возврата предыдудущей
отработавшей команды

код возврата может быть в диапазоне 0-255

| !
если мы перед командой поставим "!" 
то код возврата $? будет инвертирован.
нахрен это надо незнаю.

    $ echo "1" 1>/dev/null; echo $?
    0
    $ ! echo "1" 1>/dev/null; echo $?
    1


| test constructs

конструкции которые могут проверять условия чего нибудь

1) if then

2) [ (левая скобка /usr/bin/[) 
у баша есть одноименный билтин
также есть аналогичная внешняя команда /usr/bin/test 
при этом это аналог а не хардлинк\симлинк не [

3) [[...]]]
это типа более продвинутая версия [..]

4) ((...)) , let 
вроде как это одно и тоже

насколько я понял из книжки if then это не команда баша это его keyword.
keyword это составная часть команды.
[[...]] книжка тоже утвржлает что это тоже keyword
так я не могу понять как if then или [[...]] могут быть кейвордами
если они могут самостоятельно применяться. это же команды получается!


примеры
    $ (( 1 + 2 )); echo $?
    0
    $ let "n=1+2"; echo $?
    0
    $ (( 0 + 0 )); echo $?
    1
    $ let "n=0+0"; echo $?
    1

отсюда книжка пишет что код возврата у ((...)) и let "..." один и тот же

кстати 
    $ i=0;
    $ (( i+=2 ))
    $ echo "$i"
    2

кстати 
внешняя команда cmp сравнивает два файла
    $ cmp file1 file2

далее if она принимает любую команду в качестве условия потому что 
if анализирует только код возврата
пример

    $ if { echo "123" | head -c 1 &>/dev/null; }; then echo "success"; else echo "fail"; fi
    success
тоесть как видно мы в качестве условия вставили портянку { echo "123" | head -c 1 &>/dev/null; }
ифу все равно какая длинна портянки. if смотрит только код возврата. если $?=0 то выполняется then
а если $?=1 то выполняется else. вот и все

еще пример
    $ if { grep -q "bash" 03.bash; }; then echo "success"; else echo "fail"; fi
    success

еще пример
    $ if { echo "123" | grep -q "2";  }; then echo "цифра 2 найдена"; else echo " цифра 2 ненайдена"; fi
    цифра 2 найдена


кстати
    $ [ 0 ]; echo $?
    0
    $ [ 100 ]; echo $?
    0
    $ [ 1 ]; echo $?
    0
    $ [ -1 ]; echo $?
    0
    $ [  ]; echo $?
    1

из чего видно что [ число ] скобка подходит только если мы хотим 
протетисровать что число под скобкой НЕ NULL
    
тоже самое со стрингами
    $ [ "abc" ]; echo $?
    0
    $ [ "123" ]; echo $?
    0   
    $ [ "$drt" ]; echo $?
    1
только если стринг NULL  мы получаем false

можно это все проверять в более явной мере
    $ [ -z "$abc" ]  #  true если длина стринга 0
    $ [ -n "$abc" ]  #  true если длина стринга неноль


вот такая форма if then это хуйня
потому что в ней в качестве команду указана команда [
фишка  в том как  я уже сказал что в if может стоять любой клубок команд
ифу похуй на это. он анализирует лишь код возврата $? от этого клубка команд
    if [ condition-true ]
    then
        command 1
        command 2
        ...
    else  # Or else ...
      # Adds default code block executing if original condition tests false.
        command 3
        command 4
        ...
fi


более верная форма 
    if { command1; command2; command2}
    then
        ...
    else
        ...
    fi

кстати помимов else есть еще elif
пример
    $ if [ 1 -gt 2 ]; then echo "1>2"; elif [ 3 -gt 4 ]; then echo "3>4"; else echo "все не так"; fi
    все не так

в книжке написано что /usr/bin/[ вызывает по факту /usr/bin/test

по поводу [[...]] книжка пишет => No filename expansion or word splitting takes place between [[ and ]], 
but there is parameter expansion and command substitution.
Using the [[ ... ]] test construct, rather than [ ... ] can prevent many logic errors in scripts.
For example, the &&, ||, <, and > operators work within a [[ ]] test, despite giving an error within a [ ] construct

тоесть как я понял предпочитительнее использовать [[...]] а не [...]

кстати что интетесно в команде echo ( man echo ) напиано что можно в аргумент прописать сразу байт а не символ.
только дискриминация в том что байт можно прописать либо в OCT виде либо в HEX виде. а в десятичном нельзя.
почему непонятно. пример
    # ascii 141oct 97dec 61dec
    $ echo $'\141'
    a
    $ echo $'\x61'
    a
а 97dec никак не прописать в качестве аргумента


кстати нашел в man bash
 Quoting  is used to remove the special meaning of certain characters or words to the shell.  Quoting can be used to disable special treatment for special charac‐
       ters, to prevent reserved words from being recognized as such, and to prevent parameter expansion.

       Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell and must be quoted if it is to represent itself.

       When the command history expansion facilities are being used (see HISTORY EXPANSION below), the history expansion character, usually !, must be quoted to prevent
       history expansion.

       There are three quoting mechanisms: the escape character, single quotes, and double quotes.

       A  non-quoted  backslash  (\) is the escape character.  It preserves the literal value of the next character that follows, with the exception of <newline>.  If a
       \<newline> pair appears, and the backslash is not itself quoted, the \<newline> is treated as a line continuation (that is, it is removed from the  input  stream
       and effectively ignored).

       Enclosing  characters in single quotes preserves the literal value of each character within the quotes.  A single quote may not occur between single quotes, even
       when preceded by a backslash.

       Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of $, `, \, and, when history expansion
       is enabled, !.  When the shell is in posix mode, the ! has no special meaning within double quotes, even when history expansion is enabled.  The characters $ and
       ` retain their special meaning within double quotes.  The backslash retains its special meaning only when followed by one of the following characters: $,  `,  ",
       \,  or <newline>.  A double quote may be quoted within double quotes by preceding it with a backslash.  If enabled, history expansion will be performed unless an
       !  appearing in double quotes is escaped using a backslash.  The backslash preceding the !  is not removed.

       The special parameters * and @ have special meaning when in double quotes (see PARAMETERS below).

    
там же нашел
 A  double-quoted string preceded by a dollar sign ($"string") will cause the string to be translated according to the current locale.  If the current locale is C
or POSIX, the dollar sign is ignored.  If the string is translated and replaced, the replacement is double-quoted
пример
    $ a="1"
    $ echo $"a"
    a
что лишний раз подтверждает что надо весь стринг всегда заклюать в кавычки либо будешь 
получать непредсткадуемый результат
скажем в этом примере все понятно
    $ echo "$"a""
    $a
мы имеем три аргумента
    "$"
    a
    ""
поэтому в итоге будет напечатан $+a+пусто = $a
что мы и видим

кстати еще раз хочу вернуться к $'...'
 Words of the form $'string' are treated specially.  The word expands to string, with backslash-escaped characters replaced as specified by the ANSI  C  standard.
       Backslash escape sequences, if present, are decoded as follows:
              \a     alert (bell)
              \b     backspace
              \e
              \E     an escape character
              \f     form feed
              \n     new line
              \r     carriage return
              \t     horizontal tab
              \v     vertical tab
              \\     backslash
              \'     single quote
              \"     double quote
              \?     question mark
              \nnn   the eight-bit character whose value is the octal value nnn (one to three digits)
              \xHH   the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
              \uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
              \UHHHHHHHH
                     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)
              \cx    a control-x character

       The expanded result is single-quoted, as if the dollar sign had not been present.

особенно меня прикололо  "\cx    a control-x character" это чтото новенькое
я проверил. внатуре так и работает

Ctrl+R:
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    12
    $ echo -n $'\cr'| od -t x1
    0000000 12

ладно так вот $'..'
в итоге эта хрень работает так - знак $ отбрасывается. оставляются '' а то что внутри транслируется в 
соотвствие с приведенной таблицей учитывая спецсимволы.

так вот я перехожу  к главному меня интересующему вопросу - какой формат в баше
чтобы задать данные не в виде печатных симоволов которые баш потом по факту конвертирует
в байты а чтобы сразу указать в форме байтов. например в hex формате.
и тут получается тонкий момент. во первых в баше нельзя в общем то задать стринг 
сам по себе. он обычно входит в состав команды. а команда транслирует стринг в своем
индивидуальном порядке. а нам надо чтобы без трансляции. чтоб как есть. переменную
же задать можно. безотносительно команды которая будет ее обрабатывать. с переменной проще в этом плане.
но еще отсается задача как потом посмотреть содержимое переменной так чтобы команда 
не транслировала ее контент во чтото другое.
в итоге я пришел вот к чему
вот как я смотрю истинное содержимое голого стринга в байтовом виде
    $ od -t x1 <<< "a"
    0000000 61 0a
единственное что это добавялет лишний 0a на конце. поэтому его надо мысленно отбросить
итак видно что стриг "a" по факту в байтовом виде это 0x61  ( очевидно что этот байт ссоветсвет таблице ascii )
еще пример
    $ od -t x1 <<< "\x61"
    0000000 5c 78 36 31 0a
отбрасываем 0a и у нас остается 5c 78 36 31 это и есть байтовое содержимое нашего стринга,
смотрим в таблицу ascii и узнаем что 0x5с="\"  0x78="x"  0x36="6" 0x31="1"
итак совершенно очевидно что стринг  в формате "\x61" непредставляет собой ничего кроме прямого набора литер которые
его составляют
еще один пример
    $ od -t x1 <<< "0x61"
    0000000 30 78 36 31 0a
тут тоже видно что байтовое содержимое стринга это просто набор литер входящих в его состав
теперь применяем вот такое
    $ od -t x1 <<< $'\x61'
    0000000 61 0a
и тут мы видим принициапильно дуругую ситуацию. байтовое содержимое стринга это не набор литер а это ровно такое же байтовое 
содержание как указано в теле стринга. 

таким образом я постулирую что если мы хотим задать в стринге под двойными кавычками "...." стринг прям в форме байта 
то это нихрена не сделать. стринг можно задать в форме байта только через $'\xNN'

тоже самое касается задать переменную ( а все переменные у баща это стринги только имеющие имя ) то если мы хотим
задать переменную в форме байта то это можно сделать только одним способом 
    a=$'\xNN'
через 
    a="..." это никак не сделать.
пример
    $ a=$'\x31'
    $ od -t x1 <<< "$a"
    0000000 31 0a
видно что я записал в теле 31 и получил 31 уже в форме байтового потока
а вот показано то что байтовый поток переменной отличается от ее формального описания
    $ a="1"
    $ od -t x1 <<< "$a"
    0000000 31 0a


далее еще тонкий момент. вот мы разобрались как нам в перменую или в стринг засунуть нужный нам байтовый поток.
но когда команда получает через аргумент стринг или переенную то она по своему может обрабатывать этот байтовый поток.
но тут я думаю вот что. баш прежде чем запустить команду считывает переменную из памяти  в форме байтового потока
и подставляет этот байтовый поток из памяти в  аргумент. тоесть программа к переменнной доступа не имеет. перед 
тем как зпустить команду баш считывает переменную и посдтавляет ее в байтовом виде в команду и потом толко вызыает команду
примеир
    $ a=$'\x31'
    $ strace -e execve printf "$a\n"
    execve("/usr/bin/printf", ["printf", "1\\n"], 0x7ffe76b5c318 /* 70 vars */) = 0

тоесть баш запомнил где то в своих кишках 0x31
перед запуском printf баш сам считывает 0x31 и подставляет этот байт в сисколл execve в качестве аргумента
таким образом если бащ засунул в переменную какойто байт поток то он при вызове команды 
считает этот же байт поток и подсунет этот же байт поток как аргумент в команду

возможен конечно другой вариант. когда мы суем некотоыйр байт поток в команду а она уже сама
на основе своего интеллекта преобразует его в другое значение
    $ strace -e execve printf "\x31"
    execve("/usr/bin/printf", ["printf", "\\x31"], ...
    1
или 
    $ a="\x31"
    $ strace -e execve printf "$a"
    execve("/usr/bin/printf", ["printf", "\\x31"] ...
    1
что я хотел этими двумя примерами показать что в printf улетел стринг "\x31" тоесть байтовый поток  5c 78 33 31    
    $ od -t x1 <<< "$a"
    0000000 5c 78 33 31 0a
но сама команда printf такая умная что она его преобразовала в "1" тоесть в байт поток 0x31
тоесть вот это две соверенно разные ситауации в плане байт потока аргумента в printf 
хотя резулттат один и тот же

    $ strace -e execve printf "\x31"
    execve("/usr/bin/printf", ["printf", "\\x31"]
    1

    $ strace -e execve printf $'\x31'
    execve("/usr/bin/printf", ["printf", "1"]
    1

результат мы получили один и тот же. но баш подставил при вызовер printf совершенно разные байт потоки
в первом случае это "\x31" = 5c 78 33 31
во втором случае это $'\x31'= 31
это очень важно понять

теперь когда этот важный вопрос прояснился 
посмотрим вот на что.
возьмем команду [ либо test они же одинаково работают.
и посмотрим как они могут работать с входными форматами данных
я хочу сравнить стринги
    "10"
    "0x0A"
    "0x0a"
    $'\x0a'
совершенно понятно что байтовый поток у них совершенно разный
то входные аргументы совершенно не совпдаают. 
но возможно сама программа [ умеет 
распознавать форматы
проверим

    $ [ "10" -eq "0x0A" ]; echo $?
    bash: [: 0x0A: integer expression expected
    2

    $ [ "10" -eq "0x0a" ]; echo $?
    bash: [: 0x0a: integer expression expected
    2

    $ [ "10" -eq $'\x0a' ]; echo $?
    bash: [: 
    : integer expression expected
    2

как видим [ совершенно неумеет сама распознавать форматы.
она работает с числами которые должны быть выражены буквально в форме литер "1" "2"
проверим еще вот как  посмотрим какой байтвый поток у "10"
    $ od -t x1 <<< "10"
    0000000 31 30 0a
тогда
    $ [ "10" -eq $'\x31\x30' ]; echo $?
    0
ха. сработало.
    $ test "10" -eq $'\x31\x30'; echo $?
    0
но оно сработало не потому что программа [ какая то умная а потому то баш перед запуском команды
транслировал $'\x31\x30' в "10" в форме байт потока

    $ strace -e execve [ "10" -eq $'\x31\x30' ]; echo $?
    execve("/usr/bin/[", ["[", "10", "-eq", "10", "]"], 

тоесть с точки зрения [ в нее влетело абсолютно два одинаковых аргумента!

а теперь рассмотрим так называемый якобы keyword [[...]] может он более интеллектуальный 
и умеет распознавать форматы чисел в разных байт потоках. например может он понимает что "0x0A" это надо 
понимать как $'\x0a'

    $ [[ "10" -eq "0x0A" ]]; echo $?
    0

    $ [[ "10" -eq "0x0a" ]]; echo $?
    0

окей перепишу эти два примера по другому в равнозначной форме
я опишу левый аргумент в форме байт потока

    $ [[ $'\x31\x30' -eq "0x0A" ]]; echo $?
    0

    $ [[ $'\x31\x30' -eq "0x0a" ]]; echo $?
    0

    
совершенно понятно что справа у нас аргумент имеет совершенно другой байт поток
    $ od -t x1 <<< "0x0A"   
    0000000 30 78 30 41 0a
    $ od -t x1 <<< "0x0a"
    0000000 30 78 30 61 0a
    
отсюда следует что [[...]] умеет сама в себе  понимать и трансформировать "0x0A" который в виде байт
потока выглядит как 30 78 30 41 в совершенно другой байт поток $'\x31\x30'
тоже самое касается "0x0a". если же отойти от байт потоков и перейти к литерам то я говорю о том что сама программа
внутри себя умеет трансформировать литеры "0x0A" в литеры "10"
для сравнения программа [...] этого делать не умеет. 
еще пример
здесь понятно. оба аргумента имеют одинаковый байт поток. 
илидругими словами одинаковый литерный вид
    $ [[ "10" -eq $'\x31\x30' ]]; echo $?
    0


еще пример
понятно почему неработает 
потому что разный байт поток, тоже самое у нас разный литерный поток
а сама программа не умеет внутри себя трансформировать $'\x0a' в "10"
    $ [[ "10" -eq $'\x0a' ]]; echo $?
    1
    
    
таким макаром [[..]] умеет понимать hex формат в литерном виде если он записан как "0xNN" либо "0xnn"
для сравнения [..] этого не умеет
таким образом мы можем в [[...]] задать аргумент 
либо    в виде 
    литер '10' 
либо в виде 
    байтового потока этих литер $'\x31\x30'
либо в виде литер. преобразовав число 10 в вид
    '0x0A'
    '0x0a'
    
таким образом можно заменить исходные литеры на другие литеры по некоторому закону и програмаа [[...]]
это поймет. но поймет только эта программа потому что она индивидуально под это заточено. 
как там у других программ надо смотреть индивидуально.
пиздец
возьмем для примера другую программу printf
здесь все понятно просто печатаем литеры "10"
    $ printf "10 \n"
    10 
или печатаем их в форме байтового потока
    $ printf $'\x31\x30\x0a'
    10
тут все понятно в принтф прилетает один и тот же аргумент. 
преобрзаованием занимтся сам баш. а принтф вобще ни при чем
доказываю
    $ strace -e execve printf "10 \n"
    execve("/usr/bin/printf", ["printf", "10 \\n"]
    10 

    $ strace -e execve printf $'\x31\x30\x0a'
    execve("/usr/bin/printf", ["printf", "10\n"]
    10

сточки зрения принтф в него были подставлены абсолбтно одни и теже аргументы.
это заслуга самого бащ.
далее как видно вот такой формат принтф уже не понимает
    $ printf "0x310x30 \n"
    0x310x30 

зато принтф понимает вот такой формат и это заслуга именно
самого принта а не баша
    $ printf "\x31\x30 \n"
    10 

    $ strace -e execve printf "\x31\x30 \n"
    execve("/usr/bin/printf", ["printf", "\\x31\\x30 \\n"]
    10 

еще вот такая хрень в которой в принтф влетают литеры "\x31" \x30"
а уже именно он сам их преобразует в литеры "1" "0"
это заслуга не баша а самого принтф
    $ printf "%b%b \n" "\x31" "\x30"
    10 

    $ strace -e execve printf "%b%b \n" "\x31" "\x30"
    execve("/usr/bin/printf", ["printf", "%b%b \\n", "\\x31", "\\x30"]
    10 

а вот еще пример где в принтф влетают литеры "10"
он именно он их преобразует в другие литеры
    $ printf "%x \n" "10"
    a 
тоесть берутся литеры "10". они внутри преобразуются в число 10
это число считается что записано в десятичном формате
оно преобразуется в hex число a и это число преобразуется в литеру "a"
и это все заслуга принтф.
    "10" -> 10 -> a -> "a"

а вот еще пример интересный
    $ printf "%x \n" "0xa"
    a 
на входе в принтф  у нас литеры "0xa" он преобразует их в число a в формате hex
а потом это число преобразует в литеру "a"
    "0xa" -> a -> "a"
и это все заслуга исключтельно принтф

таким образом вот так все сложно с форматами литер\байтов в самом баше в его
стрингах и переменных и во внешних по отношению к башу командах и в кейвордах
баша.

чтобы в этм ориентироваться надо все это четко понимать - какие форматы понимает баш.
разница между литерами и байт потоком, числами, в каком байт виде перменная или стринг
есть в баше и как она подставляется в команду или кейворд и какие форматы понимает 
для автоматического преорбразвания этот кейворд или команда

опять же надо понимать что есть реальные числа котрые хранятся в формет байтов
а есть литеры которые имеют совершенно другое байтовое представление. 
надо понимать с чем рабтает программа с числами в формет байтов
или с числами в форме литер

вот так все сложно.

теперь когда мы это все знаем мы можем предстазывать резултат работы прогармм
например программа [
она анализирует числа-литеры. тоесть мы скажем ей суем литеру "1" она ее внутри себя преобразует
уже в число 1(десятичное). и с ним работает. таким образом если мы хотим сравнить число 1 и число 2 то 
их нужно подсунуть этой прграмме в форме литер "1" и "2"
    $ [ "1" -lt "2" ]; echo "$?"
    0
программа работает так. берет литеру "1" и внутри себя преобразует в число 1
потом берет литеру "2" преобразует ее в число 2 и потом сравнивает 
    1 < 2 ?
ответ да. тоесть true .
поэтому код возврата 0

следущий пример
    { decimal=15; octal=017; hex=0x0f; [ "$decimal" -eq "$octal" ]; echo $?; }
    1
у нас по факту это раотает так 
    [ "15" -eq "017" ]
у нас литеры "15" преобразуюься в число 15  и литеры "017" преобразуются вчисло 17
  15 неравно 17 
поэтому на выходе код возрата 1

следущий пример
    $ { decimal=15;  hex=0x0f; [ "$decimal" -eq "$hex" ]; echo $?; }
    bash: [: 0x0f: integer expression expected
    2
тут теперь тоже все понятно. у нас это раоатет так
    [ "15" -eq "0x0f" ]
литеры "15" программа преобразует в десятичное число 15
литеры "0x0f" программа ни в какое число не преобразует. потому что она не понимает что 
это ей за хрень подсунули. она ожидает увидеть среди литер только литеры из словаря "0 1 2 3 4 5 6 7 8 9:
поэтмоу она нас шлет нахер.

рассмомирим следущюу программу [[..]]
пример
    $ { decimal=15; octal=017;  [[ "$decimal" -eq "$octal" ]]; echo $?; }
    0
эта программа более умная чем предудыдущая. она раотает так
подставляются переменные
    [[ "15" -eq "017" ]]
далее программа преобразует литеры "15" в десятичное число 15
и преобразует литеры "017" в OCT число 017
и далее программа сранивает 15 dec и 017 OCT . ( по факту я думаю прогармма в конечно итоге оба числа
преобрзаует в двоичный вид).
видит что это два одинаковых числа поэтмоу возварщает $?=0
таким образом это заслуга самой программы что она умеет в литерном виде понимать нетолько десятичный формат
но и восьемеричный.

еще пример
    $ { decimal=15;  hex=0x0f; [[ "$decimal" -eq "$hex" ]]; echo $?; }
    0
суть такая же как в прошлом примере.
изюминка лишь в том что программа [[...]] умеет преобразоывать литерный вид "0x0f" в число 
в hex формате 0x0f поэтому она не выдвает ошибку а сравнивает 15 dec и 0x0f видит что 
это одно и тоже число и выдает $?=0
офигеть...

из этого я делаю в частосноти вывод что лучше всегда использовать [[...]] вместо [..] потому что она 
более интеллектуальная.

насколько я понял разница между [[...]] и ((...)) в том что 
((...)) вычисялет арифеметичесие операции 
а 
[[...]] делает сравнения в виде больше, меньше, равно

тоесть это несколько разные виды операций. 
и код вовзрата формируется также у них по разному. внутри [[...]] формируется булевый результат true или fasle
в зависимосоти от этого в $? идет 0 или 1
у ((..))) внутри формируется число. если оно равно 0 то в $? летит 1 а если оно неравно -0 
то  в $? летит 0

охренеть

    $ (( 0 )); echo $?
    1
    $ (( 1 )); echo $?
    0
    $ (( 5>4 )); echo $?
    0
    $ (( 5>9 )); echo $?
    1

ксати видно что ((..)) тоже может делать операции сравнению больше меньше как и [[...]]
только для этого прмиенятся другие символы.
еще пример для сраврнеия

    $ [[ "5" -gt "4" ]]; echo $?
    0
    $  (( 5>4 )); echo $?
    0
как видно код вовзрата одинаковый кстати
получается что (( 5>4 )) приводит к (( 1 )) что в свою очередь приводит к $?=0
получается (( 0 )) это свое рода (( False )) поэтому $?=1
а (( 1 )) или  (( 100 )) это своего рода (( True )) поэтому $?=0

еще примеры
внутри получаем True  поэтому $?=0
    $ (( 5==5 ));echo $?
    0
внутри получаем  0 это аналог false значит $?=1
    $ (( 5-5 ));echo $?
    1   
целое  от деления  1 это аналог True згначит $?=0
    $ (( 5/4 ));echo $?
    0
целое от деления это 0 это аналог false значит $?=1
    $ (( 5/10 ));echo $?
    1
пздец


кстати 
    /proc/self/fd смотрит в ---> /dev/fd/
удобно


| проверка файлов

есть такая подьебка с самого начала.
есть множество флагов проверяющих существование файла или его тип
например

проверить что файл существует
    $ [ -e "./03.bash" ]; echo "$?"
    0

проверить что файел есть и его тип обычный
    $ [[ -f "./03.bash" ]]; echo "$?"
    0

и здесь вот надо особо указать на то что флаг -f
он проверяет две вещи сразу 1) существует ли файл вообще и 2) что тип файла обычный 
поэтому команда будет возвращать false если хотя бы одно условие не выполняется. 
тоесть если команда вернула $?=1 это значит что либо тип файла необычный либо 
файла вообще нет. поэтому, если мы хотим точно узнать то ли файла вобще нет. то ли он 
есть но у него нетот тип тогда надо делать две проверки.
    $ if [[ -e "./03.bash" ]]
      then
         if [[ -f "./03.bash" ]]
         then
            echo "тип файлы обычный"
         else
            echo "тип файл необычный"
        fi
      else
        echo "файл несуществует"
      fi

а вот проверка тогоже самого в одну строчку
    $ [[ -e "./03.bash" ]] &&  { [[ -f "./03.bash" ]] && echo "файл обычный" || echo "файл необычный"; }   || echo "файл несуществует"

примеры
    $ stat "./03.bash" | head -n2
        File: ./03.bash
        Size: 151       	Blocks: 8          IO Block: 4096   regular file

    $ file="./03.bash"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл обычный

    $ stat "./123.bash" | head -n2
    stat: cannot stat './123.bash': No such file or directory

    $ file="./123.bash"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл несуществует

    $ stat "/dev/zfs" | head -n2
        File: /dev/zfs
        Size: 0         	Blocks: 0          IO Block: 4096   character special file

    $ file="/dev/zfs"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл необычный

таким образом скрипт работает на 100%

далее
проверить что файл существует и размер файла не нулевой
    $ [[ -s "./03.bash" ]]; echo "$?"
    0
    
    $ [[ -s "/proc/self/fd/0" ]]; echo "$?"
    1

проверка что файл существует и это папка
    $ [[ -d "/" ]]; echo "$?"
    0

проверка что файл существует и  файл это блочное устройство
    $ [[ -b "/dev/loop0" ]]; echo "$?"
    0
    
провекра что файл существует и  файл это character устройство
    $ [[ -c "/dev/zfs" ]]; echo "$?"
    0

далее поговорим про файл типа пайп.
для начала создадим именованный пайп
    $ mkfifo /tmp/1.pipe
посмотрим как выглядит его описание

    $ ls -1al /tmp/1.pipe
    prw-rw-r-- 1 vasya vasya 0 дек 10 20:02 /tmp/1.pipe

тоесть у него буква "p" вначале (prw-rw-r--)

    $ stat  /tmp/1.pipe
        Size: 0         	Blocks: 0          IO Block: 4096   fifo


проверим что файл существует и его тип это пайп (FIFO)
    $ [[ -p "/tmp/1.pipe" ]]; echo "$?"
    0

а теперь создадим два процесса связаных пайпом
и посмотрим как там у них выглядят файлы дескрипторы

    $ sleep 120 | sleep 130
    $ ps aux | grep sleep
    vasya    22746  ... sleep 120
    vasya    22747  ... sleep 130

    $ ls -1al /proc/22746/fd/1
    l-wx------ 1  ...  /proc/22746/fd/1 -> 'pipe:[3692096]'
    $ ls -1al /proc/22747/fd/0
    lr-x------ 1  ...  /proc/22747/fd/0 -> 'pipe:[3692096]'

и соотвесвтенно тут важно заметить что файлы 0 и 1 они не имеют тип пайп. нихуя.
они симлинки. указыывающие хрен знает на что.
таким образом если мы будем проверять 0 и 1 на то что они пайп то получим пошел нахер.
они только успешно проверяться на то что они симлинки

проверка на то что файл симлинк идет через два флага -h -L
чем они отличаются хуй знает

    $ [[ -h "/proc/22746/fd/0" ]]; echo "$?"
    0

    $ [[ -L "/proc/22746/fd/0" ]]; echo "$?"
    0

    $ [[ -p "/proc/22746/fd/0" ]]; echo "$?"
    1
    

тоесть я хочу сказать что кога мы создаем два процесса соединеных пайпом то интуиция 
говорит что ихние файлы отвечающие за STDOUT и STDIN должны быть типа пайп. 
но нихуя. это будут симлинки. указывающие на типа пайп. который не пайп а некая ядерная структура.

таким образом я бы сказал что проверка через флаг -p 
она позволяет является ли файл не просто пайпом а является ли он ИМЕНОВАННЫМ ПАЙПОМ.
вот что важно понять.

кстати  с именованным пайпом тоже хуйня интересная. если мы запустим команды
    $ echo "123" > /tmp/1.pipe; cat < /tmp/1.pipe;
то вторая команда не будет выполнена никогда. 
потому что первая команда сунула 123 в пайп и ждет как я понимаю ответа 
от ос о том что данные были забраны. а они не забраны потому что программа cat 
начнет выполняться только после того как закончит работы программа echo
поэтому единственый вариант это использовать два терминала. 
на первом термианале мы пишем
    $ echo "123" > /tmp/1.pipe; 
и эта команда после ввода будет висеть
потом заходим на второй терминал и там пишем
    cat < /tmp/1.pipe;
и вот только тогда все сработает.
пиздец

я себе представлял это некольпо по другому. что при записии в /tmp/1.pipe
данные записываются в ядро в буфер некоторого размера и поэтому наличие второго процесса
считываютщего необязательно. а хуйтам.

далее. сокет файл.
найдем сокет файл

    $ stat $(find "/tmp" -type s 2>/dev/null | head -n1) | grep -E "File|Size|Uid"
        File: /tmp/ssh-Ffb3Jn4D9wqx/agent.4932
        Size: 0         	Blocks: 0          IO Block: 4096   socket
        Access: (0600/srw-------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    
значит файл найден. видно что его тип это socket.
и видно что в описании файла буковка "s" (0600/srw-------)

еще раз убедимся в наличии буквы "s" в описании файла
    $ ls -1al /tmp/ssh-Ffb3Jn4D9wqx/agent.4932
    srw------- 1  ....  /tmp/ssh-Ffb3Jn4D9wqx/agent.4932

    
проверим что файл действиельно есть и что у него тип "сокет"
        $ [[ -S "/tmp/ssh-Ffb3Jn4D9wqx/agent.4932" ]]; echo $?
        0


следующий флаг -t очень интересный
    -t   file (descriptor) is associated with a terminal device
хуета в том что аргумент сюда ставится не путь к файлу. нет нихуя.
аргумент здесь это номер файл дескриптора процесса в котором сейчас работает
скрипт. это то как я понял из эксперимента. потому что описание этого флага
мегауебищное. поэтому эта хрень ее примененеие может выгляеть только так
    $ [[ -t 0 ]]
    $ [[ -t 1 ]]
    $ [[ -t 2 ]]
    
так вот я как понял эта хрень проверяет то что если дескриптор  ( а дескриптор это
 всегда симлинк ) как симлинк указывает на спец файл (/dev/...) который обрабатывается
 драйвером терминала. пример такого файла
 причем подходит нетолько tty драйвер но и pts драйвер
    $ ls -1al /proc/self/fd/0
    ... /proc/self/fd/0 -> /dev/pts/21

в общем этот странный флаг на практкие может быть использован чтобы
типа скрипт мог опрееделить что какойто его дескриптор обслуживатеся 
драйвером терминала.

далее проверить есть ли файл и может ли наш процесс читать этот файл. есть ли пермишнс

    $ [[ -r "./private-dhcp" ]]; echo "$?"
    0
    $ [[ -r "/etc/shadow" ]]; echo "$?"
    1


проверка что файл есть и у процесса есть право записывать в файл у этого проццеса

    $ [[ -w "/etc/shadow" ]]; echo "$?"
    1

прверка есть ли файл и есть ли у нашего текущего юзера права на execution для этого файла

    $ [[ -x "/etc/shadow" ]]; echo "$?"
    1

    $ [[ -x "./03.bash" ]]; echo "$?"
    0   

    
    
| find 

на время отвлечемся  на  find ( а позже обратно вернемся к преддыдудщей теме)
итак
программа ищет в /etc файла "*host*" и печатает имя файла на экране (что круто кстати)
    $ find /etc -name "*host*" -type f -print 2>/dev/null
    /etc/ansible/hosts
    /etc/avahi/hosts
    /etc/hosts


вот это пример интересный
    $find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files named core in or below the directory /tmp and delete them, 
processing filenames in such a way that file or directory names containing single or 
double  quotes, spaces or newlines are correctly handled.  
The -name test comes before the -type test in order to avoid having to call stat(2) on every file.

тут я покажу то что можно создавать файлы в имени которых есть диковинные символы. 
тоесть в имени файла насколько я щас помню можно использовать любые байты 
за исключением по моему байта 0x00 а все остальное можно. поэтому
в имени байта наример можноисользовать байт 0x0a который отвечает за Enter
ну и вообще лббые символы UTF-8.
показываю

    $ : > "$( printf "12\x0a1")"
    $ ls
    '12'$'\n''1'

тоесть у нас имя файла это "12" + символ Enter + "1"

ну и вот еще пример. когда мы вставляем символ UTF-8  "∑"

    $ : > "$( printf "12\x0a\xe2\x88\x91")"
    $ ls -1
    '12'$'\n''∑'
    '12'$'\n''1'

тоесть второй файл это "12" + Enter + "∑"
    
из за того что у нас в имени файла теперь есть символ "Enter" это приводит к проблеме.
вот какой. вот мы щас начнем искать эти файлы. и передаем этот список в команду xargs
а она же должна понять как ей отделить "слова" друг между другом. для этого она 
использует переменную $IFS в которой указано какие символы являются признаком 
разделителя между словами. по дефолту это символ "пробел", символ "Enter" и 
символ табуляции вертикальной "\t"
    $ od -t x1 <<< "$IFS"
    0000000 20 09 0a 0a

поэтому когда в xargs прилетит поток с именами нащих файлов в которых знак "enter" присуствует 
внтри имени файла то xargs будет считать что это знак разделения между словами. и мы получим 
скажем вместо имени файла '12'$'\n''∑' мы получим типа два отдельных слова '12' и '∑'
и это приведет нас к ошибкам. у нас же нет таких файлов. показываю

    $ ls -1
    '12'$'\n''∑'
    '12'$'\n''1'


    $ find . | xargs -I% echo "аргумент = %"
    аргумент = .
    аргумент = ./12
    аргумент = ∑
    аргумент = ./12
    аргумент = 1

поэтому это проблема
вот к чему это ведет    
    $ find . | xargs stat
    File: .
    Size: 4096      	Blocks: 8          IO Block: 4096   directory
    Device: 10302h/66306d	Inode: 15073820    Links: 2
    Access: (0775/drwxrwxr-x)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    Access: 2023-12-10 23:37:31.572393014 +0600
    Modify: 2023-12-10 23:37:28.716395145 +0600
    Change: 2023-12-10 23:37:28.716395145 +0600
    Birth: -

    stat: cannot stat './12': No such file or directory
    stat: cannot stat '∑': No such file or directory
    stat: cannot stat './12': No such file or directory
    stat: cannot stat '1': No such file or directory

но это можно преодолеть. можно указать команде find чтобы она когда формирует выходной список файлов 
чтобы она между именами файлов ставила не Enter как по дефолту а нулевой байт 0x00
это опция -print0

    $ find . -print0

и далее надо обьяснить xargs чтобы он тоже для определения как ему различать "слова" использовал
не то что указано в $IFS а байт 0x00 это опция -0

    $ find . -print0 | xargs -0 -I% echo -e "аргумент =%\n"
    аргумент =.
    
    аргумент =./12
    ∑

    аргумент =./12
    1

соовесвтенно теперь имена файлов различает xargs коректно. ну а то что ∑ стоит на следущей строке то это же понятно
как еще в терминале отображать сивмол 0x0a Enter

вот проверка что теперь все верно работает
    $ find . -print0 | xargs -0  stat
  File: .
  Size: 4096      	Blocks: 8          IO Block: 4096   directory

  File: ./12
∑
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file

  File: ./12
1
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file


теперь поймем какой формат аргументов у find

    $ find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]

тут много всякой хрени но нас оно интересует с момента  [starting-point...] [expression]

[starting-point...] это папка с которой начинать искать и тут все понятно

[expression] = вот это самое интересное. дело в том что эта хрень сама состоит из нескольких частей
а именно 
     [expression] = Tests + Actions + Global options + Positional options + Operators

для примера берем папку
    $ ls -1al
    total 8
    drwxrwxr-x 2 vasya vasya 4096 дек 11 00:21 .
    drwxrwxr-x 7 vasya vasya 4096 дек 10 23:57 ..
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 1.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 2.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 3.txt
    prw-rw-r-- 1 vasya vasya    0 дек 11 00:21 4.pipe

    
так вот если у нас аргументы идет просто через пробел то между ними как бы невидимо идет AND
то есть надо чтобы все аргументы выполнились
в данном случае я ищу файл с именем "1.txt" и чтобы тип файлы был обычный
    $ find .   -name "1.txt" -type "f"
    ./1.txt

полный аналог (-a это AND)
    $ find .   -name "1.txt" -a -type "f"
    ./1.txt

если мы хотим чтобы аргументы воспринимались как OR то 
в данном примере мы ищем файлы у которых либо имя "1.txt" либо тип файла обычный
    $ find .   -name "1.txt" -o -type "f"
    ./1.txt
    ./3.txt
    ./2.txt

также я как понял вместо "-o" можно использовать ","
    $ find .   -name "1.txt" , -type "f"
    ./1.txt
    ./3.txt
    ./2.txt

также как я понял условия можно группировать используя скобки. 
единственное что так как скобки это спецсимвол самого баша то надо обьяснить бащу чтобы он воспринял их как просто 
литеры и передал без изменений внешней команде в данном случае find
так вот пример когда скобки дают смысл

    $ find / \(  условие1 -a условие2 -a условие3 \) -o \(  условие4 -a условие5 -a условие6 \)  

смысл этой хрени такой найти в / файлы которые отвечают условиям: условие1+условие2+условие3    либо условие4+условие5+условие6
приведу конкретный пример
этот пример ищет либо файл с именем 1.txt и тип файла обычный либо файл с именем 4.pipe и тип файла pipe
также можно заметить что я экранировал скобки двумя способами это либо \( либо "("

    $ find .  \( -name "1.txt" -a -type "f"    \)  -o   "(" -name "4.pipe"  -a  -type "p"  ")"
    ./1.txt
    ./4.pipe

можно также сократить запись сделав ее более короткой но менее читаемой

    $ find .  \( -name "1.txt" -type f    \)  ,   "(" -name "4.pipe"    -type p  ")"
    ./1.txt
    ./4.pipe
    
теперь зная все это можно прокоментиоовать пример из самого man find
    
     $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -printf /root/big.txt '%-10s %p\n' \)

значит этот пример ищет файл который либо удовлетворяет требованиям
       
       -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n'
    
либо удовлетворяет требованияем

       -size +100M -printf /root/big.txt '%-10s %p\n'
       
тоесть либо файл имеет SUID бит установленный и тогда список этих файлов пишется в /root/suid.txt в формате %#m %u %p\n
либо файл по размеру больше 100МB и список этих файлов пишется в /root/big.txt в формате %-10s %p\n

тоесть этот исходный пример можно схематически вот таки изобразить

     $ find / \( услови1 AND  условие2  \) OR ( условие3 AND  условие4 \)

правда не совсем так потому что часть условий это actiiond дейтствия то есть что надо сделать с найденным файлом

     $ find / \( услови1 AND  действие1  \) OR ( условие3 AND  действие2 \)

кстати что еще парамлельно я узнал\вспомнил
как добавить SUID бит
    # chmod u+s file
что это дает. если владелец файла root а запускает на исполненеие файл простой юзер 
то фактически процесс будет запущен не от юзера а от владельца файла то есть рута.

также при смене владельца файла SUID бит автоматом сбрасывается

далее. интересный момент на счет аргумента "-perm -4000"
значит как задаются пермишнсы  файла который ищется
он задается в виде трех вариантов

    -perm маска    # в этом режиме нужно чтобы маска пермишнсов у файла точно совпала с маска у find
                   # сокращенно я бы этот режиме назвал exact match
    
    -perm -маска   # в этом режиме нужно чтобы установленные биты (равные 1)  из маски find были установлены в 
                   # маске файла. что касается битов которые не установленных битов (равных 0) в маске find
                   # то эти биты в маске файла могут быть любыми
                   # сокращенно я называюь этот режим all match
    
    -perm /маска   # в этом режиме нужно чтобы хотя бы один любой устанолвенный бит в маске find
                   # был установлен в маске файла
                   
сама маска может задавать либо через OCT число либо через вид "u=r,g=w,o=x"
пример

    $ ls -1al
    -r-------- 1 vasya vasya    0 дек 10 23:57 1.txt
    -r--r----- 1 vasya vasya    0 дек 10 23:57 2.txt
    -r--r--r-- 1 vasya vasya    0 дек 10 23:57 3.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 11 01:03 4.txt

вначале ищем файлы у которых пермишнс точно совпдадает с 444
    $ find .  -perm 444
    ./3.txt
кстати можно дополнительным образом подчеркнуть для find что 
маску мы вводим в OCT формате хотя это необязательно
    $ find .  -perm 0444
    ./3.txt

    
в этом примере мы ищем файлы у которых установлены биты 
user = read, group=read, other=read
что касается остальных битов то нам на них насрать
как видно в выборку попал файл 4.txt хоть 
у него есть биты установленные на запись но нам на это
насрать
    $ find .  -perm -444
    ./3.txt
    ./4.txt
    
теперь мы ищем файлы у которых установлен хотя бы
один любой бит из списка
user = read либо  group=read либо other=read
как видно под это подошли все файлы
    $ find .  -perm /444
    ./1.txt
    ./3.txt
    ./2.txt
    ./4.txt

далее я повторяю ровно теже 
самые запросы но маску задаю в символьном виде
    $ find .  -perm u=r,g=r,o=r
    ./3.txt

    
    $ find .  -perm -u=r,g=r,o=r
    ./3.txt
    ./4.txt

    $ find .  -perm /u=r,g=r,o=r
    ./1.txt
    ./3.txt
    ./2.txt
    ./4.txt


    
таким макааром я вовзращаюсь к исходному примеру где было указано
    $ find / \( -perm -4000 .....
откуда становится понятен смысл аргумента
    -perm -4000
мы  ищем файлы у которых установлен SUID бит. что до остальных 
битов в маске нам все равно

теперь еще раз посмотрим на исходную команду

    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -printf /root/big.txt '%-10s %p\n' \)
    
так вот вопрос чем отличается -fprintf от -printf 
а тем что -fprintf она берет результат форматирует его и пишет его на диск
а -printf берет результат форматирует его и пишет на stdout 
поэтому вот этот кусок в команде неправильный ( а между прочим это пример из man find )
    -printf /root/big.txt '%-10s %p\n'
    
так как у нас указан файл то нужно изменить этот кусок на 
    -fprintf /root/big.txt '%-10s %p\n'
    
либо на такой кусок
    -printf '%-10s %p\n'


так я еще раз пересмотрел пример из man find
    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
       \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

и оказыается это  я его переписал с ошибкой. в ориигинальном примере ошибок нет

теперь я хочу разобрать что значит эти загадочные символы описывающие формат
    '%#m %u %p\n' 

    '%-10s %p\n'

окаызвается %m укаызвает что find должен напечатать маску пермишснов в oct формате.
если мы хотим получить дополнительный ноль то нужно юзать %#m
символ \n нужен чтобы был перенос строк
пример
    $ find . -printf '%m\n'
    775
    400
    
    $ find . -printf '%#m\n'
    0775
    0400

%u означает напечатай мне имя владельца файла. если у него нет 
символьного имени то напечатай ID

    $ find . -printf '%u\n' | head -n2
    vasya
    vasya

%p это напечатай мне имя файла
    $ find . -printf '%p\n' | head -n2
    .
    ./1.txt

%f печатает имя файл и убираем из его имени хрень вида "./"
что очень удобно
    $ find . -printf '%f\n'
    .
    1.txt

%s печатает размер файла в байтах
кстати  прикол в том что у самого find нет никаких ключей чтобы показывать размер файла в мегабайтах
или гигабайтах. только можно в байтах. это конечно проеб
    $ find . -printf ' %s  \n'
    4096  
    0  

кстати можно в вывод вставлять всякие элементы декора
что тоже очень круто
    $ find . -printf '%f -> %s  \n'
    . -> 4096  
    1.txt -> 0  


    $ find . -printf 'имя файла = %f -> размер = %s  \n'
    имя файла = . -> размер = 4096  
    имя файла = 1.txt -> размер = 0  



    
откатываемся чуть назад
получается вот эта хрень
    '%#m %u %p\n' 
означает напечатай маску в oct формате и доп нулем, потом владельца файла и имя файла

    $ find . -printf '%#m %u %p\n'  | head -n2
    0775 vasya .
    0400 vasya ./1.txt


теперь я хочу понять что это за хрень

    '%-10s %p\n'

главынм образом непонятно что это значит этот кусок
    %-10s

а значит это вот что:
для начала отойдем от реализации printf у find и перейдем в к реализации
просто printf с которым я до этого работал. эта штука пришла из языка C
и в нем есть вот что. я привык что внутри поля формат идут вот такие хрени
    %x
    %d
    %s
    %c

так вот эта хрень на самом деле она длинее. гораздо длиннее
а я видел до этого просто сокращеный формат. 
полный формат этого выглядит как 
    
    %[Flags][Minimum field width][Period Precision. Maximum field width]Argument type

даю расшифровку.  этой формулы

    Argument type

это x либо d , s, c
на самом деле их гораздо больше (https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html)

    %d %i     Decimal signed integer.
    %o	      Octal integer.
    %x %X     Hex integer.
    %u	      Unsigned integer.
    %c	      Character.
    %s	      String. See below.
    %f	      double
    %e %E     double.
    %g %G     double.
    %p        pointer.
    %n	      Number of characters written by this printf.
              No argument expected.
    %%	      %. No argument expected.

щас мы их все отработаем чуть ниже. а пока расшфифровываем
поля дальше

[Period Precision. Maximum field width] = это число которое в одних случая обозначает сколько цифр 
                   сохранить после запятой в дробном числе,
                   в другом случае задает макс распечатываему длину аргумента,
                   я это щас тоже покаж на примере
                
    
[[Minimum field width]] = это число которое покаывает минимальную ширину аргумента в ряде случаев


[flag(s)] = это флаги. 
они бывают:

    -      Left justify.
   0  	  Field is padded with 0's instead of blanks.
   +	  Sign of number always O/P.
   blank  Positive values begin with a blank.

   # 	  особый флаг имеет разные назначения:
	  %#o (Octal) 0 prefix inserted.
	  %#x (Hex)   0x prefix added to non-zero values.
	  %#X (Hex)   0X prefix added to non-zero values.
	  %#e         Always show the decimal point.
	  %#E         Always show the decimal point.
	  %#f         Always show the decimal point.
	  %#g         Always show the decimal point trailing 
	  	      zeros not removed.
	  %#G         Always show the decimal point trailing
		      zeros not removed.

		      

так вот вовзращаемся к нашему примеру

    %-10s
	
значит когда у нас аргумент это %s тоесть простой стринг то число перед s
это ширина столбика внутри которого будет печататься наш аргумент
наш стринг. и дело в том что по дефолту выравнивание происходит
по правой стороне столбика поэтому если у нас столбик 
шириной 10 символов а аргумент шириной 5 символов тогда 
у нас при печати перед символами будет куча пробелов.
это из за выравнивания по правому борту по дефолту.
    $ printf "%10s \n" "12345"
         12345 
если мы хотим выравниваться по левому борту то надо поставить
флаг "-" тогда
    $ printf "%-10s \n" "12345"
    12345      

таким образом разгадаа загадка что значит 
    %-10s

вот эти параметры при печати очень удобны кодга мы заранее незнаем длину
нашего аргумента

насвкику нахрен все это формтрование надо ?
а надо оно походу тогда когда мы печатаем несолько строк. 
в кажой строке по несколко столбцов. и у нас скажем аргумент в кажом столбце прыгает 
принимая разное количсво символов. так вот чтобы столбдцы были красивые то
помогает это форматирование. показываю
вот так выглядит печать без форматирования
    $ for i in $(echo "1 100 2 1000 33" ); do printf "%s 44\n" "$i"; done 
    1 44
    100 44
    2 44
    1000 44
    33 44

вот так с форматированием
разница как говориттся колоссальная
    $ for i in $(echo "1 100 2 1000 33" ); do printf "%-10s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44

возникает вопрос а что если у нас задана ширина первого столбца как 10 симвлов а аргумент будет 20
симвлов?
ответ - будет то что ширина первого столбца тогда будет автоматом увеличена
чтобы у нас нащ исходный стринг поместился и не был затерт. 
поэтому ширину столбца есть смысл выбирать длинной такой какова максимальная
длинна аргумента в столбце может быть
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-10s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44
    1000000000000 44


а вот я увеличил шириину столбца
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-20s 44\n" "$i"; done 
    1                    44
    100                  44
    2                    44
    1000                 44
    33                   44
    1000000000000        44

    
можно пойти и по другому пути. можно обрезать сам стринг вот так 
    $ printf "%-4.2s --\n" "123456"
    12   --
тоесть я гооворю что ширина столбца 4 символа а при этом макс ширина стринга вырезается равной 2 символа

возвращаюсь к примеру что был чуть выше
я оставляю ширину столбца 10 символов но ограничиыаю макс ширину печатаемого стринга как 9 
символов. поэтому  у меня мой длинный стринг будет обрезан. 
первый столбик будет выглядеть красиво но конечно же потеряется часть информации.
жалко что у printf нет такого флага чтобы как то сигнализировать что при печчати 
аргумент был порезан
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-10.9s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44
    100000000  44

таким образом вот эта хрень
    %-10.9s
означает что возьми стринг. обрежь из него 9 символов и напечатай их в столбике шириной 10 символов
с выравниваеием по левой стороне.

далее. 
если мы возьмем число с плавающей точкой
    $ printf "%20.2f \n" "1234,5678"
             1234,57 

то смысл 
    %20.2f
вот какой.
мы говорим вот что 
f = означает что тот стринг который стоит в аргументе надо рассматривать как число с плавающей точкой
окей. он переводит внутри себя этот стринг как число с плавающей точкой 1234,5678
    "1234,5678" --> 1234,5678

далее 20 означает ширину столбика в котором будем печаат аргумент. по умолчанию выравнивение по правому краю
.2 означает что после запятой нужно сохранить два знака
поэтому 
    1234,5678 --> 1234,56
далее он конвертирует число обратно в стринг "1234,56"
и печатает его в столбике шририной 20 симвлов с выравнивем справа
еще пример
    $ printf "%20.2f ----\n" "1234,5678"
             1234,57 ----
соотвесвтенно ширина столбика играет роль для следущего печатуемого аргумента.
еще пример
    $ printf "%-20.2f ----\n" "1234,5678"
    1234,57              ----
тоесть первый аргумент печатается как дробное число с сохраненеим двух знаков
после запятой в столбике шириной 20 симвоолов с выравниванием слева.
значит следущий аргумент "----" уже начинает печататься с 21 позиции в строке.

вот еще один пример. из которого видна как важна ширина столбца
и по какому краю выравнивание

    $ printf "%s \n" "---------- ----------"
    $ printf "%-10s %10.2f \n" "123" "12,123456"
    $ printf "%10s %-10.2f \n" "123" "12,123456"
    ---------- ---------- 
    123             12,12 
            23 12,12      


теперь я вовзращась к тому что printf у меня еще есть в find.
и прикол в том что согласно man find у егоного принтф значения 
для %s другое чем у классического printf. у файндовского принтф
%s    означает  File's size in bytes.


так вот насколько я понимаю в случае файндовского printf 
формат %-10s означает что возьми длиннну в байтах 
и напечатай ее в столбике шириной 10 символов с выравниванием слева.
проверяю.

    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10s %f \n' | sort | head -n7
    1011712    temp 
    102        .python_history 
    102        .zshrc 
    1070       33.txt 
    11026432   atomicwallet-2.75.3.dmg.1 
    11853498   fastrans-2022-11-29-gt_erp.sql.gz.7z 
    118        kuku.txt 


значит как работает эта команда. я говорю чтобы find нашел в папке "." с глубиной поиска 1 файлы такие что 
 0b < размер файлы < 4096b  OR  размер файла > 4096b
кстати прикол в том что по дефолту аргумент -size это блоки. так что если я хочу заказывать размер  в байтах 
то надо добавлят "c" тоесть -size +4096c 
плюс означает больше, минус означает меньше.

так вот найденные файлы печатаются по формату
    -printf '%-10s %f \n'
где s это размер файла в байтах
а f это имя файла

насколко я понимаю если у классического printf %s %f ознаает тип данных то у файндовского принтф это 
означает какие поля и свойств файла надо печатать. а тип данных у него всегда один это стринг. вот такая ужасная
путаница между классическим принтф и файндовским
то есть виртуально можно файндовский формат сконвертировать в классический вот так
    printf '%-10s %s \n'  "размер файла" "имя файла"
так вот я печатаю размер файла в столбике размером 10 симвлов. выравнивание слева
имя файла просто печатается без всяких стобиков и без всяких вырваниваий просто 
с позиции 11 от начала строки.

а вот потверждение моей теории
    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10.2s %.2f \n' | sort | head -n7
    10         33 
    10         .p 
    10         te 
    10         .z 
    11         at 
    11         fa 
    11         ku 

поскольку файндовский принтф все аргументы воспринимает как стринг то запись вида 
    %-10.2s
говорит о том что напечатай аргумент в столбике шириной 10 символов а сам аргумент обрежь до двух символов
тоже самое здесь
    %.2f
возьми аргумент и обрежь его до двух символов

пздец.

еще пример
    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10s %8.8f \n' | sort | head -n10
    1011712        temp 
    102        .python_ 
    102          .zshrc 
    1070         33.txt 
    11026432   atomicwa 
    11853498   fastrans 
    118        kuku.txt 
    122          13.txt 
    127        .Xauthor 
    131        .xinputr 

я печатаю размер файла в столбике длинной 10 симвлов вырванию его по левому краю.
а имя файла печатаю в столбике 8 символов выравниваю по левому краю и обрезаю аргумент до длины 8 символов

дауж... наворотили
это зведец. сам по себе принтф это звездец. а принтф у программы файнд это дполнительный звездец.

разберу примеры из man find
он ищет в папке /tmp файл 
        с именем core
        тип файлы обычный
        и печатает на экране название файлов
        далее это пеернаправляется через пайп на xargs и там этот файл стирается

    $ find /tmp -name core -type f -print | xargs /bin/rm -f

еще пример
ищет в папке "."
тип файла обычный
и найденное имя файла подставляется в команду file в качестве аргумента
    $ find . -type f -exec file '{}' \;

насколко я понял  хрень -exec file '{}' \; работает так. берется команда file в нее вместо аргумента '{}' подставляется
имя файла наденного (если файлов много то по одному на одну команду ) и \; сообщает файнду что строка аргументов закончилась.

я сразу приведу команду которая такая же самая но выглядит более по человечески

    $ find . -type f -exec file '{}' ';'
итак каждый найденный файл будет вставлен в команду
    $ file имя_файла;
и она будет выполнена.
и так с каждый найденным файлом
еще раз повторюсь что '{}' говорит файнду что именно в это место нужно вставлять имя найденного файла.
';' это говорит файнду что строка с аргументами для подстановки закончена и можно запускать команду.
и {} и ; надо сэкранировать, чтобы бащ передал эти аргументы внутрь find без изменений.
экранировать можно либо через '' либо через слеши / мне гораздо больге нравтся экранировать через ''
вместо слешей
может возникнут желание сэкранировать за один присест и {} и ;
но это нельзя делать. потому что надо чтобы баш передало в find это как два отдельных  аргумента
    $ strace -e execve find . -type f -exec file '{}' ';' 
    execve("/usr/bin/find", ["find", ".", "-type", "f", "-exec", "file", "{}", ";"]


показываю теперь как оно отработает на чуть другом примере

    $ ls -1
    1.txt
    2.txt
    3.txt
    4.txt


    $ find . -type f -exec echo \"название файла = '{}' \" ';' 
    "название файла = ./1.txt "
    "название файла = ./3.txt "
    "название файла = ./2.txt "
    "название файла = ./4.txt "


получается что через -exec можно можно выполнять команды над найденными файлами без использования pipe
и xargs.  единственное требование к команде  это чтобы она понимала работу с файлами через аргумент.
показываю пример через xargs аналоичный предыдущей команде

    $ find . -type f | xargs -L1 -I% echo "название файла = %;" 
    название файла = ./1.txt;
    название файла = ./3.txt;
    название файла = ./2.txt;
    название файла = ./4.txt;

в целом лучше не использовать pipe+xargs потому что это лишняя команда и перекачка через пайп
показываю пример
скрипт с xargs
    $ ls -1 /etc/ssh/*.pub | xargs -L 1 -I %  ssh-keygen   -l -E sha256 -f  %
    256 SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10 root@vasya-Lenovo-IdeaPad-L340-15IWL (ECDSA)

пример c find+exec
    $ find /etc/ssh/*.pub  -exec ssh-keygen   -l -E sha256 -f  '{}' ';' 
    256 SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10 root@vasya-Lenovo-IdeaPad-L340-15IWL (ECDSA)

итак возвращаюсь к исходному примеру    
будут взяты файлы из текущей папки и ее подпапок
тип файла обычный, и на них натравливается команда file
    $ find . -type f -exec file '{}' ';'

а вот я модифицировал команду 
и получаю ошибку
и это  дает ошибку о том что указаны неправильные аргументы 
команды file
тоесть попытка всунуть внутрь -exec  пайп приводит к ошибке
о том что find пыается запустить file у котрого в аргументах вставляется  pipe и head -n5
    $ find . -maxdepth 1 -type f -exec  file '{}'  "|"  head -n5 ';'

    file: invalid option -- '5'
    Usage: file [-bcEhikLlNnprsvzZ0] [--apple] [--extension] [--mime-encoding] [--mime-type]
            [-e testname] [-F separator] [-f namefile] [-m magicfiles] file ...
        file -C [-m magicfiles]
        file [--help]

тоесть видно что file запускается с неверными аргументами.

окей идем другим путем выносим pipe из под -exec наружу

    $ find . -maxdepth 1 -type f -exec  file '{}' ';'  | head -n5
    ./09.bash: Bourne-Again shell script, UTF-8 Unicode text executable
    ./08.bash: Bourne-Again shell script, UTF-8 Unicode text executable
    ./03.bash: Bourne-Again shell script, ASCII text executable
    ./args: POSIX shell script, ASCII text executable
    ./sha512crypt.bash: Bourne-Again shell script, ASCII text executable
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13

сигнал 13 это signal 13 это SIGPIPE
он возникает вот когда - у нас есть два процесса которые запущены через пайп
например 
    $ comm1 | comm2

так вот как обычно обстоит дело. напримере
    $ echo "1" | grep "2"
вторая команда никогда не закончит свою работу раньше чем 
закончит работу первая команда.
тоесть как эта связка работтает. echo сует 
на stdout байты эти байты летят в пайп в буфер в ядре
и echo при этом заканчивает работу и ос убивает этот процесс.
после этого grep получает на stdin из пайпа из ядра, 
отрабатывает поток байтов и тоже заканчиывает свою работу.
такого никогда не будет что grep закончит свою жизнь
раньше чем echo , это просто не возможно.
рассмотрим другой вараинт.

    $ cat file1 | head -n 5

тут все по другому работает. 
cat засасывает из файла некоторую кучу байтов. 
потом cat сует то ли часть этих байтов толи все засосанные
байты в stdout , по факту они летят в пайп , в буфер ядра,
далее из ядра из буфера этот поток прилетает в head  в его 
stdin. и он начинает его обрабатывать. итак и далее 
cat засасывает данные и то ли она паралельно часть данных сует 
в stdout то ли она работает в полудуплексном режиме тоесть 
либо чтение из файла либо сует поток в stdout но в любом случае
cat сует данные в stdout это летит в ядро из ядра оно летит
на stdin команды head. так вот положим файл file1 он огромный.
а команда head ей нужно всего первые 5 строк и все. так вот 
наступает момент когда head видит что он обработал 5 строк. 
и он посылает ядру запрос о том чтобы ядро убило head.
и ядро убивает head. а в этот момент cat продолжает читать файл
и пихать его в stdout в pipe. и вот получается что процесса head
его уже нет в природе. а cat продолжает работать и пихает данные в 
stdout в пайп в конечном итоге. и когда такой момент настанет (процесса
head уже нет а cat пихает данные  в pipe) то ядро вдруг видит что 
один процесс пытается писать в пайп но при этом нет ни одного 
процесса который бы имел открытый этот же пайп на чтение! и тогда
внимание ядро вместо того чтобы принять от процесса cat его запрос
на запись в пайп оно посылает процессу cat сигнал SIGPIPE (13)
и дальше понятно. когда щедулер доходит до запуска на цпу
процесса cat то видит что к нему пришел сигнал и ядро запускает
хендлер обработчик этого сигнала (некий код) и в итоге ввсего на
всего от хендлера летит к ядру запрос чтобы ядро убило процесс в нашем
случае cat.
таким обраозом еще раз как и когда получается что в процесс прилетает
SIGPIPE - если у нас в пайпе завязано два процессе. первый пишет в пайп
а второй читает из пайп. то сигнал 13 прилетает от ядра только к процессу
который пишет в пайп и никогда не прилетает к процессу который читает из 
пайпа. так вот если у нас по каким то причинам исчезает процесс который
читает из пайпа и у нас оказывается что нет ни одного процесса который 
бы имел открытым пайп на чтение. то при попытке процесса записать в пайп
ядро в ответ пришлет этому процессу сигнал 13. который как бы ознчает "эй
процесс ты просишь меня принять от тебя данные в пайп но я тебе сообщаю
что нет никакого процесса который потом будет читать твои данные
из пайпа. имей ввиду". и после этого хендлер этого сигнала убивает 
процесс пытающийся записать в пайп. вот как это работает.
поэтому если процесс справа от пайпа исчез сдох закончил свою работу
то процессу стоящему слева от пайпа прилетит сигнал 13 и этот процесс
слева будет убит.  значит когда хендлер убивает процесс то это зависит
от хендлера этого процесса будет он чтото писать на терминал или нет.
захочет пишет. захочет не пишет. например хендлер у cat нихрена 
не пишет. а хендлер у xargs пишет. я щас это покажу на примере.
вначале берем просто команду sleep

    $ sleep 130

убиваю его
    $ kill -15 $pid

получаю
    $ sleep 160
    Terminated

вот это terminated это хендлер этой команды отреагирова на сигнал 15

запускаю команду cat

    $ cat /dev/zero >/dev/null
    
и убиваю его

    $ cat /dev/zero >/dev/null
    Terminated

получаю terminated. это хендлер уже этой команды

теперь запускаю их в пайпе

    $ cat /dev/zero  | sleep 160
    

убиваю sleep
правда убью его не сигналом 15(SIGTERM) а более мягким сигналом 2(SIGINT)
    $ kill -2 $pid_sleep
    
и что мы увидим
    $ cat /dev/zero  | sleep 160

тоесть ничего. хендлеры мягко убили все эти процессы.

а теперь возвращаемся к нашему xargs

    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null

убиваем cat

    $ kill -2 $cat_pid
    
и получаем "xargs: echo: terminated by signal 13"

    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null
    xargs: echo: terminated by signal 13



тоесть я убил cat который читал из пайпа. и xargs при попытке 
записи в пайп получил от ядра пинок signal 13
и хендлер сигнала 13 процесса xargs вывел на экран мессагу.

а теперь я вот к чему перейду. как нам узнать о проблеме
с пайпом если хендлеры молчат. и тут нам на помощь приходит 
спеец переменная bash ${PIPESTATUS[*]}  это массив.
в этой переменной находятся все коды возврата "$?" всех процессов
которые стояли в пайпах. показываю на примере

    $ echo "1" | cat  | cat  | cat | xargs echo >/dev/null; echo "${PIPESTATUS[*]}"
    0 0 0 0 0

эти нули показывают коды возврата каждой команды которая стояла в 
цепочке пайпов
из этого вывода мы видим что все команды закончили свою работу успешно.

а теперь посмотрим какие коды возврата когда у нас команда стоящая
справа от пайпа заканчивает свою работу раньше чем команда слева от пайпа.
я запускаю цепочку пайпов

    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null; echo "${PIPESTATUS[*]}"
    
далее я убиваю cat через SIGINT
    $ kill -2 $cat_pid
    
и я получаю
    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null; echo "${PIPESTATUS[*]}"
    xargs: echo: terminated by signal 13
    141 125 130

    
получается cat закончил свою работу с кодом $?=130
тут я скажу о том что если код возврата больше 128 то обычно такой 
код возврата напрямую показывает что процесс был убит сигналом и номер
этого сигнала можно вычислить по формуле $?=128+N
тоест у нас код возврата 130=128+N , N=2 значит процесс подох
от сигнала signal 2 (SIGINT) 
таким макаром 

$?(cat) = 130 , сдох от SIGINT
$?(xargs) = 125 
$?(yes) = 141 , сдох от signal 13 (SIGPIPE)

на счет сигнала 125 . все что касается расшифровки смысла сигналов кода 
возврата процесса. код 0 всегда означает успех. все остальные коды 
означают какую то ошибку. но какую хрень знает. 
какой код возврата выдаст процесс на какую то ошибку неизвестно. 
потому что это зависит от кастомного хенлера этого конкретного процессса.
поэтому что значит 125 код возврата у xargs хуй знает. но как я 
как раз понимаю у xargs это ошибка означает что процесс xargs был 
закончен из за прилета SIGPIPE. итак

$?(cat) = 130 , сдох от SIGINT
$?(xargs) = 125, сдох от SIGPIPE
$?(yes) = 141 , сдох от signal 13 (SIGPIPE)

получаем 

    $ yes | xargs | cat 
    
получаем мы убили cat, и вслед за этим xargs не смог записать в пайп ибо 
его убило ядро через SIGPIPE, и вслед за этим yes не смог записать в свой 
пайп и был убит ядром через SIGPIPE

таким образом я еще раз говорю о том что нам чтобы узнать были ли проблемы
с цепочкой пайпов через массив "$PIPESTATUS[*}"
причем нужно снимать данные из "$PIPESTATUS[*}" сразу как закончила работать
цепочка пайпов потому что эта переменная (как написано) скоропортящаяся.



далее я  запустил
     $ find . -maxdepth 1 -type f -exec  sleep 160  ';'  | head -n5
и попытался найти куда и как подключется пайп. и получил
find имеет номер процесса 9174
sleep имеет номер процесса /9284
head имеет номер процесса 9175

также видно что 
вот такое дерево процессов

    bash(3689)|---find(9174)---sleep(9929)
              |---head(9175)

тоесть и find и head имеют одного родителя

и вот что я увидел в плане пайпа

    $ ls -1al /proc/9174/fd    # find 
    0 -> /dev/pts/25
    1 -> 'pipe:[3796881]'  <--
    2 -> /dev/pts/25

    $ ls -1al /proc/9284/fd   # sleep
    0 -> /dev/pts/25
    1 -> 'pipe:[3796881]'  <--
    2 -> /dev/pts/25

    $ ls -1al /proc/9175/fd  # head
    0 -> 'pipe:[3796881]'  <--
    1 -> /dev/pts/25
    2 -> /dev/pts/25

отсюда видно что 
    в find подключается pipe на запись
    в sleep пайп подключется на запись 
    в head пайп открывается на чтение


    $ find . -maxdepth 1 -type f -exec  file '{}'  ';' |  head -n2
    ./1.txt: empty
    ./3.txt: empty
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13
когда же мы убираем -exec 
то все окей с прерыванием работы find когда head закончил свою работу
    $ find . -maxdepth 1 -type f  |  head -n2
    ./1.txt
    ./3.txt

однако все ли на самом деле хорошо?
проверим через PIPESTATUS

    $ find . -maxdepth 1 -type f  |  head -n2; echo "${PIPESTATUS[*]}"
    ./1.txt
    ./3.txt
    0 0

вау! оба процесса закончили без ошибок. 
из этого примера я делаю вывод что не всегда ситуация когда процесс
справа заканчивает работу раньше чем слева это приводит к ошибке SIGPIPE.
будет ошибка или нет зависит от того буфферизует данные в себе команда 
слева от пайпа. очевидно что cat или xargs они буфферизуют в себе данные.
а find без -exec походу получается нет. интересно!

    
кстати совать пайп под -exec не имеет смысла. потому что под -exec обрабатывается только один файл.
тоесть
в этом нет смысла
    $ find . -maxdepth 1 -type f -exec  bash -c 'file {} | head -n2'  ';' 

у нас под башем комагда file "1.txt"  | head -n2 
в ней нет смысла котоырй мне нужен. а смысл такой что я хочу чтобы как только 5 строчек файнд выплюнет
то его работа закончилась.

пайп конечно можно вставить. только надоо погимать зачем. чтоон делает

тоесть вот пример
$ find . -maxdepth 1 -type f -exec  bash -c 'stat  {}'  ';' 
  File: ./1.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15073824    Links: 1
Access: (0400/-r--------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-12-10 23:57:18.335641448 +0600
Modify: 2023-12-10 23:57:18.335641448 +0600
Change: 2023-12-11 01:02:11.447191099 +0600
 Birth: -
  File: ./3.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15073826    Links: 1
Access: (0444/-r--r--r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-12-10 23:57:21.627646002 +0600
Modify: 2023-12-10 23:57:21.627646002 +0600
Change: 2023-12-11 01:02:32.155191286 +0600
 Birth: -

 я хочу обрезать статстику по каждому файлу. тогда можно пайп засунуть под -exec
 вот пример
    $ find . -maxdepth 1 -type f -exec  bash -c 'stat  {} | grep -E "File|Uid"'  ';' 
    File: ./1.txt
    Access: (0400/-r--------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    File: ./3.txt
    Access: (0444/-r--r--r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
в этом случае пайп делает то что нам надо безусловно но это другой пример. 
учитывая проблемы с пайпом из под -exec тогда проще xarg заюзать


тоесть вместо 
     $ find . -maxdepth 1 -type f -exec  file '{}' ';'| head -n2  

    $ find . -maxdepth 1 -type f | xargs -L1  file | head -n2
    ./1.txt: empty
    ./3.txt: empty
    xargs: file: terminated by signal 13

далее вот такой пример    
    $ for i in 1 2 3 4 5; do echo $i; done | head -n5  | head -n1; echo "${PIPESTATUS[*]}"
    0 0 0
    
видно что никаких проблем

еще пример

    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 echo  | head -n2
    1
    2
    xargs: echo: terminated by signal 13


и вот я нашел в инете пример с tail
нужно вставить доп команду в цепочку "tail -n+1" (https://superuser.com/questions/554855/how-can-i-fix-a-broken-pipe-error)
тогда
вначале без tail

    $ find . -maxdepth 1 -type f -exec  file '{}' ';'  | head -n2; echo "${PIPESTATUS[*]}"
    ./1.txt: empty
    ./3.txt: empty
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13
    0 0


видно что коды возврата к удивлению нули. и при этом нет кода возврата
всех тех file которые тоже запускаются но о них ни слова

теперь с tail
    $ find . -maxdepth 1 -type f -exec  file '{}' ';' | tail -n+1 | head -n2; echo "${PIPESTATUS[*]}"
    ./1.txt: empty
    ./3.txt: empty
    0 0 0

я не очень понимаю почему исчезновение процесса head не привело к ошибкам у
tail.
проанализируем
я беру цепочку и вставляю в разные места pv чтобы посмотреть
с какой скоростью каждый участник цепочки срет на stdout


    $ yes | pv | xargs -n1 -L1 -I% echo "%"  |  tail -n +1  1>/dev/null
    72,0KiB 0:00:03 [21,5KiB/s]                                                                                                                                          ]


    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  


    $ yes | xargs -n1 -L1 -I% echo "%"  |    tail -n +1 | pv 1>/dev/null
    16,0KiB 0:00:16 [0,00 B/s] 

и тут я еще один пример посмотрю

    $ yes | pv  | cat - 1>/dev/null
    2,47GiB 0:00:02 [1,24GiB/s] 

так вот что я вижу из первого примера то что между yes и xargs 
идет скорость обмена с 21,5 KB/s
а с последнего примера я вижу что между yes и cat идет скорость обмена
со скоростю 1,24 GiB/s
из чего я делаю важный вывод что скорость обмена между процессами через пайп
скорее зависит от мощности принимающего процесса с какой сокростью он может читать
перерабатывать информацию а не от скорости записи информации отправляющего процесса.
тоесть когда  у нас стоит cat читающий из пайпа то yes может шарашить в пайп 
с огромной скоростью. а когда у нас за yes стоит xargs то такая маленькая скорость
обмена 21 KB\s зависит не от того что yes так меленно может срать в пайп а то что 
xargs может перерабатвыать данные так медленно поступающие
как я вижу когда процесс слева хочет записать в stdut он делает сисколл
в котором есть аргумент с куском данных. сисколл вызывает ядро. ядро смотрит 
есть ли место в буфере который под пайп задейтсовован. если место есть то данные 
записываются а если места нет то этот сисколл как я понимаю висит в состоянии s или d 
типа того. как только процесс справа прочитает данные из пайпа то место  в буфере пайпа
в ядре освободится и сисколл на запись сможет записать. 

я  это к чему. посмотрим еще раз на эту статистику

    $ yes | pv | xargs -n1 -L1 -I% echo "%"  |  tail -n +1  1>/dev/null
    72,0KiB 0:00:03 [21,5KiB/s]                                                                                                                                          ]


    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  


    $ yes | xargs -n1 -L1 -I% echo "%"  |    tail -n +1 | pv 1>/dev/null
    16,0KiB 0:00:16 [0,00 B/s] 


получается xargs читает из cat на скорости 21,5 KB\s
далее мы видим что между  tail и xargs  скорость в 20 раз меньше 1,21 KB\s
вопрос это xargs отдает существенно медленнее чем он читает данные 
т yes или tail такой тормоз? проверим

    $ yes | xargs -n1 -L1 echo | pv   1>/dev/null
    2,33KiB 0:00:02 [1,19KiB/s] 

видно что xargs крайне медленно умеет отдавать данные

    $ yes | pv | tail -n +1  1>/dev/null
    1,24GiB 0:00:01 [1,24GiB/s] [ 

для сравнения tail умеет читать данные очень быстро

значит 

    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  

медленный обмен между xargs и  tail основан на том что xargs 
очень медленно умеет отдавать тоесть tail просто сидит и ждет
когда же от xargs будет хоть какаято новая порция.

посмотрим на вот это 

    $ yes | pv | tail -n +1  1>/dev/null
    1,30GiB 0:00:01 [1,30GiB/s] 

    $ yes | tail -n +1 | pv  1>/dev/null
    1002MiB 0:00:02 [ 500MiB/s] 
    
отсюда видно что tail умеет быстро принимать 
и быстро отдавать. единственное что отдает он в 3 
раза медленнее чем принимает

тогда на основе этого
я анализируею вот этот кусок

    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  


    $ yes | xargs -n1 -L1 -I% echo "%"  |    tail -n +1 | pv 1>/dev/null
    4,00KiB 0:00:04 [4,00KiB/s]
    4,00KiB 0:00:06 [0,00 B/s] 
    8,00KiB 0:00:07 [3,91KiB/s] 
    8,00KiB 0:00:08 [0,00 B/s] 
    8,00KiB 0:00:09 [0,00 B/s] 
    8,00KiB 0:00:10 [0,00 B/s]
    12,0KiB 0:00:11 [3,89KiB/s]
    
получается в tail влетают данные на скорсти 1.21 KB\s и как 
видно tail их мнговенне не высирает на stdout а он насасывает данные 
какоето время а потом выбрасывает одним большим пакетов. 

понимаю теперь как рабтает каждая программа в цеопочке мы знаем 
и смотрим на целую цепочку

когда входной поток всего две строки
и на выходе head -n2 неумирает пока не увидит
две строки
то конечно все окей
    $ echo -e "1\n2\n" | xargs -n1 -L1 -I% echo "%"  | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    0 0 0

тут когда три строки слева а справа две строки
то уже жопа
head умирает а xargs после этого еше живой
и хочет писать в пайп и пролучает от ядра signal 2 SIGPIPE
и умирает с ошибкой
    $ echo -e "1\n2\n3\n" | xargs -n1 -L1 -I% echo "%"  | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    xargs: echo: terminated by signal 13
    0 125 0

вставляем cat между xargs и head
    $ echo -e "1\n2\n3\n" | xargs -n1 -L1 -I% echo "%"  | cat | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    0 0 141 0

видно что cat умирает от SIGPIPE просто хендлер для SIGPIPE  у cat
молчаливо убивает процесс а у xargs хендлер SIGPIPE убивает 
процесс с руганью  в терминал
тоесть ситцация такая же как в прошлом примере , процесс умирает 
аварийно только он об этом не ругается

мне правда мне малек непонятен еще момент. вот head умер. насколько мгновенно
сигнал об его смерти накидывается все процессам из цепочки. а если какойто 
процесс из цепочки висит уже на каком то ядре? потому что ведь баш должен убить все 
процессы в цепочке если умер хотя бы один процесс из цепочки. как я понимаю 
из этой практики что когда умер head то сигнал  о том что надо сдохнуть всем 
процессам в цепочке когда то прилетит другим процессам цепочки но непоняно когда
зато до этого момента один из процессов цепочки попадет на цпу и будет продолжать
исполняться и в частности попробует записать в пайп. если бы ядро после убиения
head мгнвенно прибило другие процессы то SIGPIPE бы не было. а так head уже нет.
процессы в цепочке неприбиыт еще неуспело ядро накидать на все процессы SIGTERM
а может при этом процесс пишущий в файл имеет статус D.  и в итоге оставишийся
процесс из цепочки попадает на цпу и пытвается писать в пайп. ядро видит что 
процесса которы бы читал из пайпа уже нет. и кидает SIGPIPE.


    
вместо cat всталвяем tail между head и xargs
и вдруг у нас все команды отрабатывают с кодом возврата ноль
несмотря на то что head умирает раньше всех
    $ echo -e "1\n2\n3\n" | xargs -n1 -L1 -I% echo "%"  | tail -n +1 | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    0 0 0 0

оп уже все коды 0.
тоесть head сдох. 
а tail при этом не собирался писать в pipe.
и к нему успел прилететь сигнал SIGTERM что пора сдыхать
тоесть head сдох. какоето время tail болтается в космосе и сигнал SIGTERM 
еще не прилетел. и tail успевает залезть на цпу но отправлять в pipe он при этом
ничего несобирался и SGPIPE он не генериурует. и он дождавшись SIGTERM
он споокойно умирает в мире.

тоесть как я понимаю сиитуацию. умирает один из процессов в цепочке.
потом идет какойто временной лаг когда ядро разошлет всем процессам в цепочке
и получается что какоето время процессы из цепочки шедулером 
будут соваться на цпу.  и они буудут пыататься еще какоето время рабоать.
и в частности такой процесс будет пытаться писать в пайп. и именно тут ядро
ему пошлет SIGPIPE. а если процесс во время этого лага небудет пытаться в ядро
то он не словит SIGPIPE и дождется SIGTERM и умрет уже мягко.
получается из примера выше становится ясно что по какойто причине tail
не срет все время на stdout а срет он порциями. импульсами. то есть он то срет
на пайп то не срет. есть окна когда он не срет. и поэтому когда head умер
и tail какое то время несрет. хотя у него в кишках есть данные. но он 
все равно молчит. и tail успевает дожить до SIGTERM не высирая ничего не пайп 
и не провоцируя SIGPIPE
для сравнения cat неимеет буфера внутри а значит он срет на пайп постоянно.
я так погимаю почему cat ловит SIGPIPE а tail не ловит. при прочих равных.

    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 -L1 -I% echo "%"  | tail -n +1 | head -n2; echo "${PIPESTATUS[*]}"  
    1
    2
    0 0 0 0

но процесс который стоит слева от tail накидывает ему данные 
яростно и сильно то тогда tail срет на пайп уже очевидно чаще.
и уже неуспевает дождаться до прилета ему SIGTERM
тоесть head сдох а программы стоящие слева продолжает наваливать данные
и в tail проодолжают наливаться данные. поэтому за то окно пока head сдох
но SIGTERM еще не прилетел то у tail переполняется его буфер и он срет 
на пайп и ловит SIGPIPE
    $ yes  | xargs -n1 -L1 -I% echo "%"  | tail -n +1 | head -n2; echo "${PIPESTATUS[*]}"
    y
    y
    xargs: echo: terminated by signal 13
    141 125 141 0

значит чтобы этого всего избежать надо чтобы вместо tail стояла такая команда 
которая очень может много в себя засосать много данных и при этом редко импульсно
срет на пайп.
тоесть cat срет на пайп постоянно при поступлении данных ибо у него буфера нет или
почти нет. tail уже срет на  stdout импульсно. 
нужна программа которая еще более импульсно срет. с большим буфером.

и тут я напоролся еще на один кусок инфо. оказвыается 
    Most standard Unix commands buffer their output when used non-interactively.
    This means that they don't write each character (or even each line) immediately, 
    but instead collect a larger number of characters (often 4 kilobytes) 
    before printing anything at all. In the case above, 
    the grep command buffers its output, and therefore awk only gets 
    its input in large chunks. ( https://mywiki.wooledge.org/BashFAQ/009 )

тоесть если процесс имеет свой stdout не на терминал (tty, pts)
а скажем в файл или в пайп тогда приложение не посылает каждый байт
сразу на stdout а копит их пакетами обычно по 4КБ. и посылает это
импульсами.


    
или другое решение можно использовать awk
я не знаю что значат его ключи но я знаю как эта хрень работает.
она печатает первые две строки по аналогии как head -n2
а далее она продолжает принимать весь поток от find пока 
он не закончится. поэтому такое решение вобщем то полное гавно
    $ find . -maxdepth 1 -type f -exec  file '{}' ';' | awk -v N=2 'NR<=N'
    ./1.txt: empty
    ./3.txt: empty

    
вот еще пример
я имею файл 17830.txt размером 1,59 GB
и вот четко видно что awk витоге прочитает весь файл полностью.
это полный дебилизм
    $ cat ./17830.txt | pv |  awk -v N=2 'NR<=N' 1>/dev/null
    1,59GiB 0:00:05 [ 283MiB/s]
    
в итоге я бы пока что сказал так на собщение от xargs о том 
что в него прилетел signal 13 можно полностью игнорировать.
в этом нет ничего ни странного ни нетяснимого ни вредного.
тоже самое касается если мы запускаем find + -exec
и он нам пишет про signal 13. 
это все окей. это просто значит что команда справа от пайпа 
закончила свою работу раньше чем команда слева от пайпа.
если смерть команды справа это закономерная вещь то все окей.

| tail

этот пример печатает последние 2 строки снизу
тоесть вначале полностью засасывается файл
либо поток байтов из stdin
и потом уже отсчитываются снизу 2 строки
    $ tail -n 2

    $ echo -e "1\n2\n"
    1
    2

    $ echo -en "1\n2\n" | tail -n 1
    2

единственное что мне непонятно это каким 
образом tail понимает что при приеме байтов
из stdin как tail понимает что передача байтов
наконец закончена.

еще вот я такое нашел о том как баш убивает процессы
в цепочке пайпов:
    If the pipeline is not executed asynchronously (see Lists of Commands), 
    the shell waits for all commands in the pipeline to complete.
    (https://www.gnu.org/software/bash/manual/html_node/Pipelines.html)

тоесть из этих слов следует что когда мы запускаем команды через пайп
то все что делает бащ это запускает процессы и увязывает их stdin stdout
вместе. и все. далее баш процессы не трогает. она тупо ждет пока
все процессы САМОСТОЯТЕЛЬНО закончат свою работу. тоесть если процесс
в цепочке закончил свою работу то баш не трогает другие процеесы
а ждет когда они сами закончат свою работу.

еще пример
имеем текстовый файл размером 1,59 GB
    $ cat 17830.txt | pv | tail -n 1
    1,59GiB 0:00:01 [ 904MiB/s] 

вот получатеся что cat читает файл целиком.
tail это целиком засасывает. и потом отсчитывает снизу 
одну строку.

окей когда cat закончил свою работу. но так как баш
не трогает остальные процессы после умирания одного из процесса
в цепочке пайпов поэтому когда cat закончил читать файл
и сдох то баш ничего не делает. для него оставшийся
tail просто процесс. и он просто ждет когда он САМ
закончит свою работу. поэтому tail не убивается а спокойной
анализирует засосанный файл столько сколько ему нужно.

единственное что мне непонятно как tail узнает что 
ему на вход на stdin больше ничего не придет.
что поток закончился.

ксттаи если баш сам не убивает процессы а процессы
сами себя убивают то вопрос а как они это делают?
пример

    $ yes | head -n5
    
возникает вопрос. когда head закончился
то как yes заканчивает работу? ответ 
очень ясный. когда yes попробует записать
в пайп то ос пришлет процессу SIGPIPE
и процесс будет убит хендлером.

    $ yes | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    141 0

так и есть. 141 это процесс был убит через SIGPIPE

далее вот что я нашел. наш процесс пытается писать в пайп
а как это делается ? а вот как пайп это файл. запись в файл
идет через сисколл write. так вот мы через сисколл write
посылаем в пайп(файл) кусок данных. сисколл это значит
что у нас запускается уже ядерный код ядра. так вот 
если пайп не открыт ни одним процессом на чтение то  в ответ
ядро пришлео процессу сигнал SIGPIPE. далее когда 
процесс нужно будет засунуть на цпу то шедулер увидит сигнал
и вместо кода процесса засунет на цпу хендлер сигнала 
SIGPIPE. и вот если хендлер так написан что он не убььет процесс
то тогда сисколл write вернется с ошибкой EPIPE.
правда что будет дальше я не понимаю. тоесть если мы юзаем
сисколл любой. и он вовзращает ошибку (ибо у каждого сисколла
есть варианты что он вернет ошибку при возврате из сисколла
в код процесса ) 

и тут я узнал как это работает
вот программа которая пробует открывать файл 


$ cat 97.c


#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

int main()
{
// Declaration of a file descriptor
int fd;

// Opening a file
fd = open("/root/sasikala/testing",O_CREAT|O_EXCL);
// If Open is failed
if ( fd < 0 ) {
        printf("Opening file : Failed\n");
        printf ("Error no is : %d\n", errno);
        printf("Error description is : %s\n",strerror(errno));
}
// If Open is success
else
        printf("Opening file : Success\n");


// print hello world
printf("Hello, World!\n");
}

значит при открытии файла в fd возвращается номер файл дескриптора
через который можно работать с открытым файлом.
если при открытии файла произошла проблема то fd будет равен -1 или NULL
поэтому мы делаем проверку что fd < 0
при этом в C есть спец переменная "errno" которую можно подключить через 
    #include <errno.h>
так вот если при открытии файла возникла проблема то в переменной "errno"
будет номер который показывает какая именно ошибка возникла при отрытии файла.
можно узнать ее символическкую расшифроку через strerror(errno)
возникает вопрос а что происходит дальше с нашей программой если 
открытие файла не произошло из за ошибки? ответ - да также как в баше
когда мы команды через точку с запятой ввели - просто напросто начнет
исполнятся следующая команда! показываю - я компиирую программу
и запускаю ее.

    $ gcc -o 97.exe 97.c
    $ ./97.exe 
    Opening file : Failed
    Error no is : 13
    Error description is : Permission denied
    Hello, World!
    

тоесть мы не смогли открыть файл, 
далее идет расшифровка ошибки.
и далее выполнилась следующая команда по списку которая 
напечатала hello world.
поэтому ответ на вопрос - а что если у нас в коде выполняется команда
которая вызывает ошибку? ответ - если ошибка не критическая и мы неотлавливаем
сами своим кодом эту ошибку и сами не останавливаем программу то просто напросто
программа продолжит выполнять следующие команды ниже по тексту команды.

тут я хочу еще важную полезняшку сказать. мы получили код ошибки в виде цифры 13.
мы получили расшифроку ошибки через словесное обьяснение "Permission denied"
но фишка в том что в "$ man syscall" нет ни того ни другого. там ошибки которые
возвращает сисколл обозначаются одним словом корттким. например EPIP
как нам узнать это имея цифру ошибки например 13.
оказывается в /usr/src/... есть файлы *errno* в которых есть связь с 
цифрой ошибки и EPIP который указан в "$ man syscall"

например у нас сисколл open читаю его man
    $ man 2 open
так много ошибок укажу только две возможные
       EACCES The requested access to the file is not allowed,
       or search permission is denied for one of the directories 
       in the path prefix of pathname, or the file did
       not exist yet and write access to the parent directory is not allowed.
       (See also path_resolution(7).)

       EDQUOT Where O_CREAT is specified, the file does not exist, and the user's 
       quota of disk blocks or inodes on the filesystem has been exhausted.


начинаем искать число 13 в /usr/src/*errno*.h

    $ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(13\)+\($'(\t)'\)   '{}' ';'
    ./include/uapi/asm-generic/errno-base.h:#define	EACCES		13	/* Permission denied */

итак мы выяснили что 13 это EACCES
знаая это мы теперь можем детально почитать про нее в $ man 2 open 
и видим подрообное описание
    EACCES The requested access to the file is not allowed,
       or search permission is denied for one of the directories 
       in the path prefix of pathname, or the file did
       not exist yet and write access to the parent directory is not allowed.
       (See also path_resolution(7).)

синтаксис grep я разберу чуть ниже.


спрашивается а причем здесь пайп. нахрен я все это разбирал. а затем
что теперь стало все совершенно понятно прото что будет если у нас есть 
процесс который пытается писать в пайп но при этом нет процесса который 
бы имел открытым пайп на чтение. а происходит вот что. при попытке записать 
ос пришлет процессу SIGPIPE. далее отработает хендлер этого процесса
по обработке этого сигнала. если у процесса нет свеоего хендлера то 
дефолтовый хендлер ОС убьет процесс. а если у процесса есть 
свой хендлер который неубивает процесс а например просто на экране
рисует сообщение то тогда в системной переменной errno будет 
содержаться цифровой код ошибки почему запись в пайп была неудачная.
так как паай это файл то пишем мы в пайп также как в файл тоесть
через сисколл write. если запись в пайп была неудачная то в errno
будет записано такой код ошибки который соовествует ошибке EPIPE.
далее если мы в нашем коде программы после вызова write анализирует
успех этой операции и анализируем содержимое errno то мы увидим
что произошла ошибка и тут все зависит от нас. какой код мы написали
если мы при этом завершим процесс то окей. а если нет то дальше
все будет очень просто - наша программа продолжит выполнение 
дальнейшего кода !!!! вот как это будет раотат на практике.

$ cat 96.c


#include <stdio.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>


static void handler(int sig) {
    struct sigaction act = {
	.sa_handler = SIG_DFL,
	.sa_flags = 0,
    };
    sigaction(sig, &act, NULL);
    printf("Got signal %d\n", sig);
    //kill(getpid(), sig);
}



int main(int argc, char **argv) {
    int pipefd[2];
    bool ignore = argc > 1 && argv[1][0] != '0';

    struct sigaction oldact, act = {
	.sa_handler = ignore ? SIG_IGN : handler,
	.sa_flags = 0,
    };

    sigaction(SIGPIPE, &act, &oldact);

    pipe(pipefd);
    close(pipefd[0]); // reader
    if (write(pipefd[1], "Hello", 6) < 0){
	perror("write()");
	printf ("Error no is : %d\n", errno);
        printf("Error description is : %s\n",strerror(errno));
   }

    sigaction(SIGPIPE, &oldact, NULL);
    return 0;
}





$ ./96.exe 
Got signal 13
write(): Broken pipe
Error no is : 32
Error description is : Broken pipe


значит мы видим что мы получили ошибку 32. тоесть errno=32
ищем для него слово которое обозначает эту ошибку в *errno*.h

$ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(32\)+\($'(\t)'\)   '{}' ';'
./errno-base.h:#define	EPIPE		32	/* Broken pipe */

видим что errno=32 это EPIPE

ошибка возникла при сисколл write (хотя поправка это не сисколл это gnu libc функция
которая в своих кишках уже сама запускает нужные сисколлы)
значиит идем в man write и ищем описание EPIPE

  EPIPE  fd is connected to a pipe or socket whose reading end is closed.  
  When this happens the writing process will also receive a SIGPIPE  signal.   
  (Thus,  the write return value is seen only if the program catches, 
  blocks or ignores this signal.)

ксатии прогрмма 96.exe работает так - она пробует писать в пайп. 
при этом ос присылает ей SIGPIPE. вызывается ее хендлер. он печатает 
на экране "Got signal 13" и больлше ничего не делает.
тогда код програмы продолжает дальше выполнять дальнейшие команды. 
и мы анализируем код возврата из функции write через анализ
переменной errno. и печатаем на экране

    write(): Broken pipe    
    Error no is : 32
    Error description is : Broken pipe

  
теперь мне все стало понятно как это работает. и как и почему получаеся SIGPIPE
и как и что это значит EPIPE. 


теперь понясню про grep  
$ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(13\|32\)+\($'(\t)'\)   '{}' ';'
./include/uapi/asm-generic/errno-base.h:#define	EACCES		13	/* Permission denied */
./include/uapi/asm-generic/errno-base.h:#define	EPIPE		32	/* Broken pipe */

а именно 
    $ grep -H  -E \($'(\t)'\)+\(13\|32\)+\($'(\t)'\)  file1

ключ -H дает то что греп будет печатать на экране не только строчку
в которой найдено совпаедение но и имя файла где он 
нашел входждение. это круто

ключ -E нам дает то что можно через "|" указывать паттерны в режиме OR
тоесть паттерн1 OR паттерн2 OR паттерн2 выглядит так
    $ grep pat1 | pat2 | pat3
    
также я использую () для того чтобы указывать отдельные группы.
cскобки работают только вместе с ключом -E.
также скобки друг  с другом соединяются через +
тоесть 
    $ echo -e "ab1\n a2" | grep -E "(a)+(b)"
    ab1
либо
    $ echo -e "ab1\n a2" | grep -E \(a\)+\(b\)
    ab1

нужно экранировать скобки так как в бащ скобка это спецсимвол. а нам
надо передать скобку как аргумент внутрь внешней прогарммы grep

переходим к основному примеру

    $ grep -H  -E \($'(\t)'\)+\(13\|32\)+\($'(\t)'\)  file1

мы в нем ищем патттер "TAB"+"13 или 32"+"TAB"
значит отдельные части уравнения мы обозначаем через ()+
применив экранирование
а OR мы обозначаем через "|" тоже его нужно экранировать

сделаем чуть красивее

    $ grep -H  -E   \($'(\t)'\)+"(13|32)"+\($'(\t)'\) errno-base.h 
    errno-base.h:#define	EACCES		13	/* Permission denied */
    errno-base.h:#define	EPIPE		32	/* Broken pipe */

чтобы грепу подсунут TAB мы юзаем $'(\t)' потому что с ключом -E он не понимает \n
он понимает \n тлоько с ключом -P который взаимоисключащий с -E а  -P не понимает пайп 
 в качестве OR так что мы юзаем -E ради пайпа в качестве OR а TAB подсовывыаем
 через $'(\t)' тоесть через то что сам баш дешфирует это в нужный байт перед тем
 как вызыват греп и подставить его сам в качестве аргумента.
 
мы неможем использовать "($'(\t)')" потому что двойные кавычки убивают $'(\t)'
поэтому мы юзаем слэши \($'(\t)'\)
вот такой пиздец

кстати вот все ошибки котоыре указаны как код возврата во всех сисколлах
это все в итоге ошибки прописанные в *errno*.h и падают они в errno. тоест 
все сисколлы они обращаются к функциоаналу *errno*.h а не свой функционал пилят
для этого.

итак как в итоге работает ситуция с записью в пайп.
мы открыли в программе пайп. получиил дескриптор файла. теперь  используя 
этот дескриптор можем туда писать. писать туда можно как в обычный файл
используя сисколл\glibc функцию write.
мы пишем используя write и дескриптор пайпа.

при вызовее write ос переключается из юзер режима в режим ядра.
в режиме ядра ос перед тем как приянять байты и засунуть их в буфер в памяти
отвечающий за пайп ядро проверяет есть ли процесс у которго пайп открыт на чтение.
если такого нет то принимать данные нет смысла и ядро шлет процессу этому который 
пишет сигнал SIGPIPE. шедулер перед тем как засунуть код процесса на цпу увидит 
что у процсса есть сигнал. он вызывет хендлер этого сигнала. если процесс не имеет 
своего хендлера то ос подсунет дефолтовый свой и он просто убьет процесс.
а если у прцесса есть свой хенлер то запустит его. если хендлер не убьет процесс
то прсто напросто продолжится выполнения дальнейших по тексту команд программы.
у программы есть два вараинта. если программа после вызова write анализирует 
код вовзрата errno то в errno будет код ошибки что пошло нетак при вызове write
там будет какая то цифра. и подчекрну что код ошибки вовзрвата функции это не SIGPIPE
SIGPIPE это сигнал который прилетает. он не имеет ничегообщего с кодов возврата 
сисколла. так вот в errno будет лежат число 32. если код программы анализирует errno
и запргарммирован убит процесс если errno неравено нулю то окей.  а если он не анализирует
или не убивает при условии что errno <>0 то программа просто напросто продолжит работать
дальше. и это зависит чисто от нас от програмиста этой программы. так что при желании
ни SIGPIPE ни errno=32 не остановят программ от дальнейшего исполенния. ну типа 
произошли ошибки и ладно.
по поводу дешировации ошибки errno=32 как это делать. внутри кода программы
можно вот такое вызывать

    perror("write()");
	printf ("Error no is : %d\n", errno);
    printf("Error description is : %s\n",strerror(errno));

что на экарне даст

    write(): Broken pipe    
    Error no is : 32
    Error description is : Broken pipe
    
а если мы хотим подробное описание
нам найдо найти для 32 его описание в формет спец слова.

это описание хранися в /usr/src/*errno*

ищем вот так

    $ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(32\)+\($'(\t)'\)   '{}' ';'
    ./errno-base.h:#define	EPIPE		32	/* Broken pipe */

находим EPIPE.
теперь мы смотрим а какой сисколл был использован котоыйрый вызывал этот errno
в нашем случае это write.
тогда идем в man
    $ man 2 write 
и там ищем EPIPE
и читаем

    EPIPE  fd is connected to a pipe or socket whose reading end is closed.  
    When this happens the writing process will also receive a SIGPIPE  signal.   
    (Thus, the write return value is seen only if the program catches, 
    blocks or ignores this signal.)

таким макаром мы детально понимаем что значит полученная ошибка 32.

ура товарищи...

еще раз возвращаюсь к тому как работает tail -n +1 вкупе с пайпом

    $ echo "1" | tail -n +1
    
во первых как работает пайп в купе с башем. все что делает баш 
если видит пайп это запускает две команды. у которых увязывает вместе их
stdin stdout
    stdout (proc1) ----> stdin (proc2)
далее баш вобщем то забывает про эти процессы напрочь.
каждый из процессов должен закончить свою жизнь самостоятельно.
если какйото из процессов сдох то баш аобсолбтно ничего неделает
с дурими процессами в цепочке. 
поэтому кджый процесс должен закочить свою жизнь соамтоятельно.
либо его должна убить сама ОС. но не баш.
это дает то что если слева скажем идет чтение огромного файл 

    $ cat big_file | tail -n +1

то это работает так. cat прочитает весь файл целиком а tail его засосет целиком,
после этого cat сдохнет. но и башу и ос и tail на это насрать. tail будет 
работать столько сколько захочем и ему неважно что какйото друой процесс сдох.
ну и сам тейл с данной опцией что делает. он печатает на stdout 
весь файл что получил начиная с 1-ой строки сверху. 
если я вот так дам команду

    $ cat big_file | tail -n +10
    
то тейл напечатает весь файл начиная с 10-ой строки сверху

тоесть если классчиеский tail -n2 он печатает файл с конца последние две строки.
то tail -n +10 печатает файл сначала файла начиная с такой то строки.

соовтесвтенно в обоих случая и когда мы печатаем сверху и когда мы печатаем
нижние строки чтобы тейл мог отраотать ему нужно в себя употребить весь файл 
целиком
доказываю, берем файл размером 1,59GiB

    $ cat 17830.txt | pv | tail -n2 1>/dev/null
    1,59GiB 0:00:01 [ 932MiB/s] 

    $ cat 17830.txt | pv | tail -n +2>/dev/null
    1,59GiB 0:00:01 [1,04GiB/s]
    

    
так. ну если процессы в пайпе неубиваются башем а работают 
настколько долго насколько они этого хотят
то возникает вопрос а как тогда заканчываиет свою работу вот эта цепочка

    $ yes | head -n5
    
тоесть head читает 5 линий и убивает себя. а yes то должен работать бесконечно
однако это нетак. так вот yes убивает принудительно сама ос. вот как yes 
заканвивает свою работу.
когда head исчезает то при попытке записать порцию данных в stdout/pipe 
со стоороны yes ос видит что больше нет процессов котыре имеют этот пайп
откртым на чтение. и тогда ос ппосылвет в yes сигнал SIGPIPE.
далее либо хендлер yes а если его нет то хендлер дефолтовый ОС видя 
это сионал убивает процесс yes. 
а если мы вот такую возьмем цепочку

    $ echo -e "1\n 2\n 3\n" | xargs -n1 -L1 echo | cat -; echo "${PIPESTATUS[*]}"
    1
    2
    3
    0 0 0


понятно что echo закончит свою жизнь само.
непонятно на каком основании xargs и cat понимаю что больше данных 
им на stdin никогда не поступит. 

можно легко проверть что при смерти процесса сслева от пайп или спрва
от пайп баш и ос нихрена неделает

    $ sleep 120 | sleep 130

если  я рукамт убтю правый процесс то легко проверить 
что процесс слева прдолжает жить.
и наоброт если убью первым процесс справ то процесс продождает жить.

вопрос 
как в этих примерах
программа xargs или cat
узнает что больше данных из stdin не прилетит?

    $ echo "1" | xargs ....
либо
    $ echo "1" | cat 

тут я обнаружил очередной фундаментальный огромный кусок под названием EOF и EOT.
End Of File, End Of Transfer.

на основе этих хреней программы которые читают из stdin определяют что больше 
ничего не прилетит. и убивают себя сами.

значит программа которая читает из файла пусть это будет stdin 
например можно читать из stdin через getchar

$ cat 99.c
#include <stdio.h>
#include <errno.h> // for the definition of errno
#include <stdlib.h> // for exit()
int main(void)
{
    int c;
    c = getchar();
    putchar(c);
    printf ("\n");
    printf("feof =  %d\n",feof(stdin));
    printf("ferror=  %d\n",ferror(stdin));

    exit (0);

}


как это работает на практике. мы запускаем прогу.
она ждет от нас ввода кнопок в терминале.
мы вводим символы

    $ 123

но пока мы их вводим в программу ничего не улетает. 
только после того как мы нажмем Enter символ реально улетают в программу.
поток 123 улетает в stdin программы но по факту из потока будет прочитан 
только один байт один символ. тоест "1" все остальное исчезнет вникуда.
тоесть 

    int c;
    c = getchar();
    
позводяет нам считать только один символ.

    $ echo -n "123" | ./99.exe
    1
    feof =  0
    ferror=  0

пока все окей.
но что если мы хотим считать много символов например 2.
модифицирую программу

$ cat 99.c
#include <stdio.h>
#include <errno.h> // for the definition of errno
#include <stdlib.h> // for exit()
int main(void)
{

    int i;

 for (i = 1; i < 3; ++i)
 {
    int c;
    c = getchar();
    putchar(c);
    printf ("\n");
    printf("feof =  %d\n",feof(stdin));
    printf("ferror=  %d\n",ferror(stdin));
 }
    exit (0);

}


натравливаю на нее файл из 2-ух символов

$ echo -n "12" | ./99.exe
1
feof =  0
ferror=  0
2
feof =  0
ferror=  0

тоже все окей.

а теперь натравливаю файл из 1-го символа

$ echo -n "1" | ./99.exe
1
feof =  0
ferror=  0

�
feof =  1
ferror=  0

и мы получаем интересный момент.
первый шаг цикла считал символ "1"
и на выходе напечатало

1
feof =  0
ferror=  0

на втором шаге цикла читать уже было нечего
потому что файл закончился.
и тут происходит магия. тут участвует в процессе чтения
целая матрешка - сисколл ядра, libc, наша команда.

ОС код ядра при попытке 
считать следущий символ в файле понимает както нам неважно как 
что файл достигнул конца и сообщает вышестоящей функции libc 
о том что файл достиг конца. libc делает так что функция getchar 
выдает как результат специальный байт называется EOF. 
как он конкретно выглядит в виде байта завиисит от разного
но как я понял в линуксе этот байт выглядит как -1 
поскольку байтов отрицателных небывает то это некая форма представления
отрицательных чисел на компе в форме байта. 

в коде проверить что getchar нам вернул EOF можно через 
спец конструкцию

int c;
c = getchar;
if ( c == EOF) {
        printf("end-of-file reached\n");
        exit(0);
    }

тоесть нам даже ненадо знать как конктено выглядит этот EOF
просто подставляет EOF а C сам уже знает о чем речь.


более того помимо возврата в getchar EOF
у нас функция feof принимает значение 1
как доп фактор доказать что мы достигли конца файла
что собсвтенно видно из вывода на экран

    feof =  1

в программе можно проверять этот факт вот так

if (feof(stdin)) {
        printf("end-of-file reached\n");
        exit(0);
    }


из вывода в hex портянки

$ echo -n "1" | ./99.exe  | od -t x1
0000000 31 0a 66 65 6f 66 20 3d 20 20 30 0a 66 65 72 72
0000020 6f 72 3d 20 20 30 0a ff 0a 66 65 6f 66 20 3d 20
0000040 20 31 0a 66 65 72 72 6f 72 3d 20 20 30 0a
0000056


я делаю вывод что этот байт имеет вид 0xff но это неточно.


таким образом еще раз. для того чтобы прочиатаь из файл
мы испольуем C программу. она опирается на libc. 
а та опирается на системны вызовы ядра.

когда мы в программе просит прочитать из файла например через
getchar() то эта хрень обращается к libc а та к сисколлу.
сисколл это ядерный код и он видит как то там нам неавжно как
что файл закончился. и он наверх об этом сигнализирует. 
в итоге  в getchar возвращается некий спецбайт EOF
как он выглядит нам неважно потому что в программе мы проверяем
его наличие через EOF

c = getchar;
if ( c == EOF) {
        printf("end-of-file reached\n");
        exit(0);
    }

в дополнеие к этому также функция feof(stdin) принимает значение 1
что нам тоже докаызвает что мы достигли конца файла.

тогда покываю программу которая это все ловит

$ cat 100.c
#include <stdio.h>
#include <errno.h> // for the definition of errno
#include <stdlib.h> // for exit()
int main(void)
{
    int c;
    while ((c = getchar()) != EOF)
       putchar(c);

   printf ("мы словили EOF!\n");

    if (feof(stdin)) {
        printf("feof = %d\n", feof(stdin));
        exit(0);
    }
    else if (ferror(stdin)) {
        printf("An error occurred. errno set to %d\n", errno);
        perror("Human readable explanation");
        exit(1);
    }
    else {
        printf("This should never happen...\n");
        exit('?');
    }
}

    $ gcc -o 100.exe 100.c
    $ echo "123" | ./100.exe
    123
    мы словили EOF!
    feof = 1

если программа ждет ввода с stdin с терминала.
то чтобы сообщить ядру что мы достигли конца файла нужно тыкнуть Ctrl+D
тогда драйвер терминала сообщит ядру что ввод с терминала достиг конца файла.

если у нас stdin смотрит в пайп то насколько я понимаю ядро понимает что 
достигнут конец файла если в нет ни одного процесса который бы писал в пайп 
и что буфер пайпа пуст. тогда ядро сообщает в libc что файл закончился.
тоесть

    $ echo "123" | cat
    
у нас echo высрало в пайп "123" и сдохло. пайп как  я понимаю 
это буфер в памяти ядра какогоо то размера.
и теперь 123 лежит в этом буфере. 
cat читает из пайпа кусками. выбирает оттуда 123. 
и шлет новый запрос на чтение данных. 
ядро которые обрабатывает это запрос непосредственно видит что 
буфер пуст. это значит что либо программа которая записывает в пайп на даннйы
момент пока что ничего новоого не высрала в пайп. но тогда нужно наличие такой программы
висящей в памяти и имеющей отрытым на запис этот пайп. если это так то запрос cat 
просто откладывается в S-state до поступления данных в буфер пайпа.
а если в памяти нет ни одной программы которая имеет открытым пайп на запись и буфер 
пайпа повторю пуст то ядро понимает что в пайп уже никогда данные не поступят.и что 
это конец файла. и оно сигнализирует к libc что конец файла.

я так понимаю этот ад.

таким образом более менее разгадаа загадка как программы соедиенные  пайп
понимают что им никто уже данные не нальет и надо заканчиывать свой процесс.






про awk
пример печаатает
последние 2 строки из файла
    $ awk -v N=2 'NR<=N'
    


    
    
еще раз расскажу про  ${PIPESTATUS[*]} 
${PIPESTATUS[*]}
содержит коды возврата всех процессов в цепочке пайпов.
если код возврата команды ненулеовй это еще незначит что у нее сломался пайп.

$ sleep 130 | sleep 140 | sleep 150; echo "${PIPESTATUS[@]}"
Hangup
129 129 129

$ kill -1  9088
$ kill -1  9089
$ kill -1  9090

поскольку баш нетрогает процессы в цепочке если у нас один из процессов
упал то нужно убить все три поцесса прежде чем пайп развалится

код возврата 129-128=1 ровно сигнал 1  я им слал.
ошибка 129 совершенно не значит что была проблема с пайпом она значит что в процесс
прилетел сигнал 1


далее
$ yes | head -n 100 | xargs -n1 echo | tail -n +1 | head -n2; echo "${PIPESTATUS[@]}"
y
y
141 0 0 0 0
не все хендлеры 13 сигнала чтото пишут на терминал.
часто ничего не пишут


$ yes | head -n 100 | xargs -n1 echo  | head -n2; echo "${PIPESTATUS[@]}"
y
y
xargs: echo: terminated by signal 13
141 0 125 0
а здесь более правый пайп завершил с ошибкой


прикол в том что если код 0 это успешный выход.
все остальное неуспешный. и что значит конкретно каджый код выше 1 по 125 
опредлелется программстом программы. закралывая его в фукцию обработки.
поэтому что значит код 128 для xargs это надо искать в описании xargs
а вот если код >128 то обычно это значит что в прцесс прилетел сигнал N
высиляется по формуле код возврата = 128+N.


и вот что про ext satus написано на сайте gnu
The exit status of an executed command is the value returned by the waitpid
system call or equivalent function. Exit statuses fall between 0 and 255, 
though, as explained below, the shell may use values above 125 specially. 
Exit statuses from shell builtins and compound commands are also limited 
to this range. Under certain circumstances, the shell will use special 
values to indicate specific failure modes.
For the shell’s purposes, a command which exits with a zero exit status has succeeded
. A non-zero exit status indicates failure. This seemingly 
counter-intuitive scheme is used so there is one well-defined way
to indicate success and a variety of ways to indicate various failure
modes. When a command terminates on a fatal signal whose number is N, Bash
uses the value 128+N as the exit status.
If a command is not found, the child process created to execute it returns a
status of 127. If a command is found but is not executable, the return status is 126.
If a command fails because of an error during expansion or redirection, 
the exit status is greater than zero.
The exit status is used by the Bash conditional commands
(see Conditional Constructs) and some of the list
constructs (see Lists of Commands).
All of the Bash builtins return an exit status of zero if they succeed
and a non-zero status on failure, so they may be used by the conditional
and list constructs. All builtins return an exit status of 2 to
indicate incorrect usage, generally invalid options or missing arguments.
The exit status of the last command is available in the special 
parameter $? (see Special Parameters).

так что 141 это 128+13 значит сигнал 13 а 13 это  SIGPIPE ( kill -L )
это значит этот процесс хотел записат в пайп но не было процесса который бы открыл 
этот пайп на чтение. ядро это заметило и послало процессу сигнал 13. и дефолтовый хендлоер убил процесс
который хотел пиать в пайп

вот я запуисил процесс
    $ yes | cat - 1>/dev/null; echo "${PIPESTATUS[*]}"
и с терминала дургого убил cat
    $ kill -1 $pid_cat

и получил на первом терминале
Hangup
141 129
причем hangup это мне напиал cat когда поулчил этот синал

вот еще пример
$ cat 0< /dev/zero 1>/dev/null; echo $?
Hangup
129

$ yes | xargs -n1 echo | cat - 1>/dev/null; echo "${PIPESTATUS[*]}"
xargs: echo: terminated by signal 13
Hangup
141 125 129

я послал kill -1 в cat
в итоге cat его обработчки сигналов мне написал на экране Hangup
xargs его обработчик сигналов мне написал xargs: echo: terminated by signal 13
yes мне ничего не написал

а это их коды возврата
141 125 129

yes получаетс получил сигнал 13
xargs сигнал 13 судя по его сообщению но код возврата выдал 125
cat полувил сишгнал 1

таикм иобарзом я убил cat. после этог xargs не смог писать в пайп и ядро его убило.
вслед за этим не смог писать yes и его тоже убило ядро


я походу понял почему я раньше эту ошибку не встречал
$ cat 17830.txt | grep a 1>/dev/null; echo "${PIPESTATUS[@]}"
0 0
потому что раньше у меня были такие команды что комада которая 
справа от пайпа она всегда ждет бесконечно
данные от команды слева. и в цепочке первой заканчивала работу всегда
команда слева. и только потом комнда 
справа от пайпа. и поэтому немогло быть ситуации при которой 
возникает сигнал 13. тоесть процесс 
пишет в пайп но его никто не читает. 





далее 
    set -o pipefail 
    set +o pipefail
    это о чем?
вообще этот билтин баша
это вещь в себе.
например если мы используем -o .... то это АКТИВИРУЕТ опцию
       а если мы используем +o .... то это ОТКЛЮЧАЕТ  опцию
то все наоборот , антиинтуитивно.

по дефолту эта хрень отключена. 
значит если мы ее активируем  
    $ set -o pipefail 
то даст вот что 

pipefail
            If  set,  the  return value of a pipeline is the value of
            the last (rightmost) command to exit with a non-zero status, 
            or zero if all commands in the pipeline exit successfully.  
            This option is disabled by default.

значит по дефолту когда эта опция выключена то если у нас есть цепочка команда
с пайпами то если мы после этого захотим посмотреть код возврата то он будет 
содержать код возврата последней команды в цепочке.
а если мы активируем эту опцию то код возврата будет содержать последний код 
возврата комады в цеопчке который был неравен нулю. таким образом активация 
этой оции позволяет вскрыть вытащить наружу проблемы с в пайп цепочке.
сразу скажу что эта опция никоим образом не влияет на переменную "${PEIPSTATUS[*]}"
эта переменная содержит  в себе все коды возврата всех команда из цепочки
вне зависимости от усноавлена или нет опция pipefail.
кстати как узнать установлена ли опция pipefail или нет. вот как
    $ set -o | grep pipefail
итак показываю.

    $ set -o | grep pipefail
    pipefail       	off

    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    xargs: echo: terminated by signal 13
    141 125 0

    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "$?"
    xargs: echo: terminated by signal 13
    0

таким образом видно что при отключенной опции у нас $?=0 тоесть равен
коду возврата последней команды в цепочке

активируем опцию

    $ set -o pipefail
    $ set -o | grep pipefail
    pipefail       	on


    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    xargs: echo: terminated by signal 13
    141 125 0

    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "$?"
    xargs: echo: terminated by signal 13
    125

видно что при активиированной опции код возврата $?=125 равен первому справа
ненулевому коду возврата из цепочки

еще интересный шокирующий момент. если мы хотим посмтреть echo "${PIPESTATUS[*]}"
то это надо делать прям сразу после цепочки команд. если прошляпить хотя бы
на одну команду. то она протухает. показываю.

тоесть вот я смотрю ее сразу
    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    141 125 0

а вот я смотрю эту переменную но чуть позже
    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo $?; echo "${PIPESTATUS[*]}"
    125
    0

как говорится почуствуй разницу между 
    141 125 0
и
    0
    
в этом тоже конечно засада.

если у нас скрипт. то надо еще подумать активировать ли pipefail
или нет. потому что не всегда плохой код возврата это плохо
пример
    $ yes  | xargs -n1 -L1 echo | head -n 5 1>/dev/null; echo "${PIPESTATUS[*]}"
    141 125 0

если мы активируем pipefail то $? после этой цепочки будет 125.
но на самом деле проблемы в этом пайпе нет. просто head сделал свое дело
и умер раньше чем команды слева. это норм. как уже разбирал выше.

еще раз о set
если мы хотим посмотреть чему равны все опции то надо set -o

    $ set -o
    allexport      	off
    braceexpand    	on
    emacs          	on
    errexit        	off
    errtrace       	off
    functrace      	off
    hashall        	on
    histexpand     	on
    history        	on
    ignoreeof      	off
    interactive-comments	on
    keyword        	off
    ...
    
а set +o нам выдаст список команд которые можно вбить 
в шелл чтобы привести эти опции к этому виду

    $ set +o
    set +o allexport
    set -o braceexpand
    set -o emacs
    set +o errexit
    set +o errtrace
    set +o functrace
    set -o hashall
    set -o histexpand
    set -o history
    set +o ignoreeof
    set -o interactive-comments
    set +o keyword
    ...
    

    
    
еще раз вовзращаюс к разбору примеров из man find
этот пример ищет в папке /tmp файл с именем "core"
тип файла обычный
и печатает на экране имя файла с добавлением Enter в конце файла каждого
едиснтвенное что я не понял это смысл -print 
ибо имя файла оно и без этой опции печаается 
    $ find /tmp -name core -type f -print
ее аналог
    $ find /tmp -name core -type f


    
еще пример
ищет в папке /tmp
имя файла core
тип файла обычный
печатает имя файла и добавляет в конец байт 0x00
это делается если в имени файла есть символ Enter
тогда можно передать через pipe на xargs и там тоже обьяснить что символ
разделения названий файло тоже 0x00
    $ find /tmp -name core -type f -print0
если дбавить xargs
    $ find /tmp -name core -type f -print0 | xargs -o echo 

    
    
еще пример
ищем в папке "."
тип файла обычный 
и  с каждым таким файлом печатаать его тип 
    $ find . -type f -exec file '{}' \;

    
еще пример
найти файл у которого есть suid бит и заппсать имя этого файла
в файл /root/suid.txt в формате "permissions  user  имя_файла"
либо найти файл размером 100M+ в файл /root/big.txt  в формате
"размер файла  имя_файла",
причем размер файла печатается в колонке 10 символов
с выравниванием по левому краю а печать имя_файла 
идет с 11 символа
    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
       \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)



еще пример
ищет в папке $HOME
файлы которые были изменены за последние 24 часа
    $ find $HOME -mtime 0
       
на счет -mtime, -atime, -ctime, -mmin
m означает modification
c означает creation
a означает acccess
тоесть проверяется то или иное время в свойствах файла

*time означает время в единицах сутки. тоесть -ctime 1 это время 1 сутки
*min означает минуты. -mmin 10 означает 10 минут.

если число стоит без значков +- то это означает точное совпадение
если стоит -10 то это означает промежуток [сейчас-10; сейчас]
а если стоит +10 это промежуток [-бесконечность; сейчас-10]

тоесть -mmin -10 означает файл был модифицирован в течение последних 10 минут. в этом промеж
утке
-mmin +10 означает что файл был модифицирован более раньше чем 10 минут назад. и еще
более раньше. 

-mmin 10 означает что файл был модифицирован точно 10 минут назад

аргумент 0 имеет особое значение

-mmin +0 означает что файл был раньше чем 0 минут назад или более раньше.
тоесть по факту это любой файл. 


    $ ls -l -t
    15:18 4.txt
    13:40 1.txt
    
    $ find . -mmin -4
    ./4.txt
тоесть мы ищем файл который был измнеен в течение между щас и 4 минуты назад.
    время 15:21
получается это время  (15:17, 15:21) внутри этого интервала лежит 4.txt (15:18)


возвращаюсь к исходному пример
ищется файлы которые были модифицированы ровно за последние сутки    
    $ find $HOME -mtime 0

-amin
-atime
-cmin
-ctime
-mmin
-mtime


a - время доступа к файлу
m - время изменения содержимого  файла
c - время  изменения метаданных файла. тоесть 
инода. тоесть пермишнсы у файла. владелец итп

что я не понимаю. это то что если я захожу и меняю содержимое 
файла причем просто символ один меняю на другой. тоесть метаданные
не меняются то все равно меняется и mtime и ctime. что за хуйня
я не понимаю почему.



команда 
    $ touch file
она меняет acccess time и modify time 
и еще и  change time 
вобщем она по дефолту все меняет


будем работать на примере ctime. это время изменнеия метаданных у файла.

    $ ls -ltc --time-style="+%d %b %H:%M" | awk '{print $6 "  "$7"  " $8"  " $9}'
    13  дек  17:45  01.bash
    25  июн  04:09  temp
    20  июн  23:38  04.bash
    16  июн  19:41  LC_CTYPE=ru_RU.utf8
    16  июн  18:43  06.txt
    16  июн  17:32  03.bash
    16  июн  15:58  04.txt
    16  июн  15:56  05.txt
    16  июн  15:09  03.txt
    16  июн  14:38  root
    16  июн  14:02  02.bash

    $ date "+%d %b %H:%M"
    13 дек 18:16

    $ find . -type f -cmin 32 -printf "%-10f %Cd %Cb %CH:%CM \n"
    01.bash    13 дек 17:45 

-cmin 32 означает что мы ищем файл у которого 
ctime равен (текущее время - ctime файла) выраженное в минутах должно быть 32 целых
минуты и еще может быть сколько то секунд миллисекунд итд это мы уже отбрасываем.
главное что промежуток должен составлять полноценных 32 минуты.
тоесть грубо говоря -cmin 32 означает найди файл который был модифицирован относиельно
ctime 32 минуты назад. но это должны быть полные минуты. тоесть с учетом секунд.
поскольку время записывается в свойствах файла с точностью до условно говоря миллисекунд
или микросекунд но нам самое главное что с точностью до секунд точно и то что
отсчет идет от текущего момента времени это означает что нам придется подбирать cmin
в пределах +-1 минута. например у нас файл создан в 17ч:01м:56с  а сейчас время 17ч:02м:20с
отнимаем одно от другого это будет 24секунды. это значит что  у нас в промежутке нет 
ни одной полноценной минуты. другой случай файл создан в 17ч:01м:01с 
значит промежуто равен 1м 15с или одна полноценная минута. как мы видим на листинге ls
время показано с точностью до минуты. поэтому оба наших файла буду показаны как
17ч01м но только один из них попадет в поиск find по критерию найди файл модифицированный 
за последнюю минуту. поэтому я гооврю о том что параметр -cmin он будет гулять туда 
сюда в пределах 1 минуты.
примеры

итак имеем вот такой файл
    13  дек  17:45  01.bash
сейчас время
    $ date "+%d %b %H:%M"
    13 дек 18:28
я ожидаю его найти как -cmin 43
    $ find . -type f -cmin 43 -printf "%-10f %Cd %Cb %CH:%CM \n"
    01.bash    13 дек 17:45 
сработало

еще ест вот такой файл
    13  дек  17:48  1.txt
текущее время 13 дек 18:30
я ожидаю  его найти как -cmin 42

    $ find . -type f -cmin 42 -printf "%-10f %Cd %Cb %CH:%CM \n"
    1.txt      13 дек 17:48 

сработало

если мы модифицируем 
    -cmin 42 
как 
    -cmin -42 
это будет значить что мы ищем файлы у которых ctime лежит в интервале
    (текущее время-42;текущее время)
а если заменить на 
    -cmin +42 
это будет значить что мы ищем файлы у которых ctime лежит в интервале
    (-бесконечность ;текущее время-42)

отдьено скажу про 
    -cmin 0
это значит что у файл ctime такой что промежуток времени между его ctime
и текущим мометом такой что он меньше чем одна полная минута. тоесть если мы возьмем
этот промежтоу времени выразим его в секундах и поделим на 60 то в целой части от деления
будет 0. и будет какйото остаток но мы его всегда отбрасываем.
тоесть -cmin 0 это такой файл который был модифицирован меньше чем минуту назад
-cmin 1 означает что файл был модифицирован одну полную минуту назад.
-cmin -1 означает что файл был модифицирован в интервале одну полную минуту назад или меньше
-cmin +1 означае что файл был модифицироован позже чем одну полную минуту назад

-сtime такойже смысл как cmin но он меряется промежутком в 24часа. тоесть это одни 
полные сутки. 
-ctime 0 это такой файл который был модифицирован меньше чем одни полные сутки назад
-ctime 1 означает что файл был модифицирован одни полные сутки назад.
-ctime -1 означает что файл был модифицирован в интервале одни полные сутки назад или меньше
-ctime +1 означае что файл был модифицироован позже чем одни полные сутки назад
    
соотвественно через -ctime +10 ищется какоето супер старье
через -cmin -10 ищется наоборот чтот очень молодое

имеем вот такие файлы

$ ls -ltc --time-style="+%d %b %H:%M" | awk '{print $6 "  "$7"  " $8"  " $9}'
      
13  дек  17:48  1.txt
10  дек  23:20  3.txt
10  дек  23:20  2.txt

я хочу найти все файлы в течеие последних 3-ех суток
    $ date "+%d %b %H:%M"
    13 дек 18:27

    $ find . -type f -ctime  -3 -printf "%-10f %Cd %Cb %CH:%CM \n"
    1.txt      13 дек 17:48 
    3.txt      10 дек 23:20 
    2.txt      10 дек 23:20 

хочу найти файлы котрые
          файлы  старее чем  -1 сутки
но при этом 
          файл моложе чем -3 сутки
        
тогда
    $ find . -type f -ctime +1 \! -ctime +3 -printf "%-10f %Cd %Cb %CH:%CM \n"
    3.txt      10 дек 23:20 
    2.txt      10 дек 23:20
    

конструкция 
    \! -ctime +3
означает промежуток времени который мы исключаем из рассмотрения
по умолчанию между  всеми аргументами в find незримо стоит логический AND
тоест должны выопнтяся одновмренно все условия поиска
причем надо экранировать ! чтобы баш не расстривал ! как спесимвол

найти файлы с ctime моложе чем 1 сутки (-ctime 0)

    $ date "+%d %b %H:%M"
    13 дек 18:27

    $ find ~ -type f -ctime 0 -printf "%-10.5f %Cd %Cb %CH:%CM \n" 2>/dev/null | head -n4
    4bae8      13 дек 03:49 
    471f2      13 дек 13:06 
    84b66      13 дек 06:27 


найти файлы с ctime моложе чем 1 минута (-cmin 0)
    $ echo "текущее время  = $(date '+%d %b %H:%M')"; find ~ -type f -cmin 0 -printf "%h/%-8.8f %Cd %Cb %CH:%CM \n" 2>/dev/null  | head -n3
    текущее время  = 13 дек 18:57
    /home/vasya/.cache/lxsession/LXDE/run.log  13 дек 18:57 
    /home/vasya/.psensor/log      13 дек 18:57 
    /home/vasya/.config/google-chrome/Default/Preferen 13 дек 18:57 

еще раз про разницу
    -cmin 0  найти все файлы у которых ctime  моложе чем одна полная минута
    -cmin 1  найти все файлы у которых ctime одна полная минута или меньше
    если текущее время t, а ctime это знание у файла то 
    -cmin 0 такой что    (t-ctime) < 1min
    -cmin 1 такой что    (t-ctime) <= 1min
    где 1min это полная минута то есть 60 секунд

возвращаюсь  к примеру
найти все файлы которые были модифицированы (mtime) меньше чем 24 часа от текущего
момента
    $ find $HOME -mtime 0

далее найти файл который executable (для текущего юзера)
    $ find . -executable -type f
    ./1.txt

проверяем 
    $ find . -type f -printf "%f   "  -exec  stat --format="%A" '{}'   ';'
    1.txt   -rwxrwxr-x
    3.txt   -rw-rw-r--
    2.txt   -rw-rw-r--

проверка что файл readable (для текущего юзера)
    $ find . -readable -type f
    ./1.txt
    ./3.txt
    ./2.txt


далее
найти файлы и папки  которые "x" но не "r" для текущего юзера
что это значит на практике не помню. особенно для папок    
    $ find /sbin /usr/sbin -executable \! -readable -print

тоже самое но только для файлов обычных
    $ find ~ -executable \! -readable  -type f -printf "%f   "   -exec stat --format="%A" '{}' ';' 2>/dev/null
либо
    $ find ~ -executable ! -readable  -type f -printf "%f   "   -exec stat --format="%A" '{}' ';' 2>/dev/null
    sudo   ---s--x--x
    sudoreplay   ---x--x--x
    sudo   ---s--x--x
    sudoreplay   ---x--x--x
    sudo   ---s--x--x
тоесть работает и  с экранированием "!" и без его экранирования.

дальше
ищет файлы которых пермишнс в точности 644
    $ find . -perm 664
    
ищет файлы у которых пермишнс такие что установленные биты в маске 664 = 110110100
также установлены и в пермишнс файлов. 
что касается неустанолвенных битов в маске если они установлены  в файле 
то нам похеру
    $ find . -perm -664
    
маска пермишнс 664 = 110110100
нам надо чтобы в файле в пермишнс был устанолвен хотя бы один бит из тех что
есть  в маске тогда нам такой файл уже подходит
    $ find . -perm /664
    
    
    
далее
       $ find . -perm /220
       $ find . -perm /u+w,g+w
       $ find . -perm /u=w,g=w
все три команды одинаковые. только в разной форме записаны.
файлы подходят если либо юзер может писать либо other может писать. 


следущий пример
    $ find . -perm -220
    $ find . -perm -g+w,u+w

так на счет пермишнсов.
перимишнсы описывают право на  чтение (r) на запись (w) на исполнение (x)
для трех групп клиентов - user, group, other в итоге это можно 
схематично обозначить как 9 символов

    u   g   o
   --- --- ---

полуается каждый символ можно закодировать через 1 бит. получается
вся эта хрень кодируется через 9 бит. 
пример

    u   g    o
   -wx rwx r--

что обоначает что user может (r,x) 
группа может (r,w,x)
other может (r)

в битах это выглядит как
011-111-100

а теперь вот что сделаем.
помотрим как этот байт выглядит в восьмеричной системе
счисления.
в левом столбике бинарный вид
в правом столбике oct вид
 u   g   o     ugo      u   g   o
000 000 001 |  001  |  --- --- --x
000 001 001 |  011  |  --- --x --x
001 001 001 |  111  |  --x --x --x

 u   g   o     ugo     u   g   o
000 000 010 |  002  | --- --- -w-
000 010 010 |  022  | --- -w- -w- 
010 010 010 |  222  | -w- -w- -w-

 u   g   o     ugo     u   g   o
000 000 100 |  004  | --- --- r--
000 100 100 |  044  | --- r-- r-- 
100 100 100 |  444  | r-- r-- r--


отсюда виден очень удобный закон. чтобы нам легко 
понимать как нам быстро преобразовать в голове пермишнсы из битового
вида в oct. это можно сделтаь очень бысро. а линукс понимает если 
ему мы подсовыаем маску в oct виде.
для этого  мы вначале понимаем куда надо изменит пермишн - юзеру, группе , или other.
пишем на бумаге три цифры они будутотвечать за число в oct виде

    000

левая цифра это цифра котрая отвечает за левые три бита бинарного виде и ответчает
за пермишнсы для юзера.
средняя цифра это цифра котоая отвечает за средне три бита бинарного вида и 
ответчает за пермишнсы для группы
правая цифра отвечает за правые три бита и отвечает за пермишнсы для other
если мы хотим дать праов на выполнение то надо туда прибавить единицу
если хотми дать право на запись то прибавить двойку. если хотим дать право 
на чтение то добавить четверку. пример

хотим  
     u   g   o
    rw- rw- rw-
            
береем
   000
   
и делаем вот так
   000 => (4+2)(4+2)(4+2) => 666
   
доказательство 

    $ a="110110110"; echo -n "$a   ";  echo " obase=8; ibase=2; $a" | bc
    110110110   666

все совпало


возвращаюсь к примеру

    $ find . -perm -220
    $ find . -perm -g+w,u+w

       u   g   o
220 = -w- -w- --- 

тоесть u=w, g=w
сравниваем  с

    $ find . -perm -g+w,u+w

видим что это одно и тоже.
потому что у find
    g+w это одно и тоже g=w
    u+w это одно и тоже u=w

итак эти две команды в плане маски это одно итоже.

-220 означает то что мы ищем файлы у которых вот эти биты установлены

       u   g   o
      -w- -w- --- 

а те быты которые в нашей маске не установлены они в маске файлы могут
быть какие угодно. тоесть есть нас волнует толко то чтобы юзер мог писать и группа
могла писать. а остальные биты нам все равно какие.


следущий прмиер

       $ find . -perm -444 -perm /222 \! -perm /111
       $ find . -perm -a+r -perm /a+w \! -perm /a+x

      
444 это r-- r-- r--

тут еще надо понястьи что такое "a" это означает all users. тоесть
    $ chmod a+x
оно устанвиит и для юзера и для группы и для other бит x
будет 
    ??x-??x-??x
биты которые обозначены как ? затронуты не будут

тогда сраавниваем -444  r-- r-- r--
значит -444 значит то что мы требует чтобы вот эти биты r-- r-- r--
были устанолвены. что касается других нам похер.

сравниваем с этим -a+r
оно делает тоже самое. то есть для всех юзеров устанавлиывается бит r
а знак минус означает что другие биты мы не трогаем. доказываю показываю

    $ ls -1al
    -rwxrwxr-x  1.txt
    -rw-rw-r--  2.txt
    -rw-rw-r--  3.txt
    -r--r--r--  5.txt

    $ find . -perm -a+r 
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

тоесть он показал все файлы где устанолвнены биты r для всех юзеров

    $ find . -perm -444
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

кстати что -a+r что -a=r это одно и тоже

    $ find . -perm -a=r 
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

по русккт этот пермишн значит то что нам нужны файлы у которых для всех 
разрешено чтение

тоесть -444 и -a+r это одно тоже

теперь сравним 
    -perm /222
    -perm /a+w
      
222 и a+w это одно тоже. 
/222 означае что мы ищем файлы где хотя бы один устаглвенный бит
будет установлен в маске файла. тоесть говоря по руски мы ищем файлы где
либо для юзера либо для группы либо для other будет разрешен запись

далее сравним
    \! -perm /111
    \! -perm /a+x
      
111 этоодно  тоже с a+x
/111 означает что нам нужно чтобы хотя бы один бит был устанолвен в маске
файла тоесть в фале должно быть рарзерешено исполенние либо для юзера 
либо для группы либо для other.  знак ! означае что мы такие файлы исключаем из 
поиска.

таким образом эти два примера они о б одном и том.же
в итоге мы ищем файлы такие что : 
    в маске файла и для всех должно быть разрещено чтение r-- r-- r--
    AND хотя бы для когото разрешена запись               -w- or -w- or -w-
    AND запрещено чтобы хотя бы доя когото был установлен x тоеть ! --x --x --x
    

проверяю. имеем файлы
    $ ls -1 | xargs "-I^"  stat -c "%A  %n"   "^"  
    -rwxrwxr-x  1.txt
    -rw-rw-r--  2.txt
    -rw-rw-r--  3.txt
    -r--r--r--  5.txt


    $ find . -type f  -perm -a+r -perm /a+w \! -perm /a+x 
    ./3.txt
    ./2.txt

все верно. 5.txt  не подхлодит потому что у него нет w 
хотя бы у когото, 1.txt не подходит потому что у него есть x а он 
запрещен вообще



следущий пример

    $ cd /source-dir
    $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 /dest-dir
      
    
здесь нужно обьяснить что за настройка -prune
во первых какой формат у команды find

    $ find "папка где искать" "условие поиска1" "действие1" OR\AND 
        "условие поиска2" "действие2" ...
        
если мы не указываем дейтсвие сами то find автоматом подстаялет действие -print
даю простой пример
    $ find / -name "vasya" -print
/ = папка где искать
-name "vasya" = шаблон что искать
-print = что делать с найднным

второй просто пример
        $ find / -name "vasya" -print  -o   -size 100M+ -print
этот пример ищет в / файлы с именем vasya и печатае их на экране ИЛИ
ищет файлы размером 100M+ и печаатает их на экране.

так вот -prune относится к действию. что он делает.
перед -prune надо обязательно чтобы стояило какое то условие поиска.
так вот если резулттаом поиска является папка то он в нее не спускается.
пример
имеем папку

    $ find . -maxdepth 1  \! -name "." -printf "%y %f \n" | sort
    d 12 
    f 1.txt 
    f 2.txt 
    f 3.txt 
    f 5.txt 

мы не хотим чтобы find искал в папке 12. нам надо ее исключить.
мы не хотми чтобы find в нее спускался

    $ find . -name 12 -prune -o -type f -name "*" -print
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

    
пример расшифровавывается так ищи в папке "."
если имя "12" и это имя папки то не спускайся в нее.
ИЛИ
если это обычный файл  и у него имя "*" то печатай его на терминале

но скажем так нахер это prune если можно сделать аналогиченое через maxdepth

    $ find . -maxdepth 1  -type f -name "*" -print
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

но -prune пригодится например в другом случае например такой случай что
у нас то там то здесь появляется папка с именем ".git" на разных глубинах
и мы не хотим чтобы мы в нее входили. 
для примера имеем такую структуру папок

    $ find .  \! -name "." -printf "%y %h/%f \n" | sort
    d ./folder-A 
    d ./folder-A/.git 
    d ./folder-B 
    d ./folder-B/er-f 
    d ./folder-B/er-f/.git 
    f ./1.txt 
    f ./2.txt 
    f ./3.txt 
    f ./5.txt 
    f ./folder-A/a.txt 
    f ./folder-A/.git/12.txt 
    f ./folder-B/er-f/er.txt 
    f ./folder-B/er-f/.git/14.txt 

исключаем вход в папку .git где бы она не была внутри в кишках
через -prune
    $ find . -name ".git"  -prune -o -type f -name "*" -print
    ./1.txt
    ./3.txt
    ./folder-A/a.txt
    ./5.txt
    ./2.txt
    ./folder-B/er-f/er.txt

(с prune помогло разобраться вот это https://stackoverflow.com/questions/1489277/how-to-use-prune-option-of-find-in-sh)

есть еще опция -path
какая же у нее связь с базовой папкой откуда мы начинаем поиск.
а прикол в том что связи никакой. в том плане что 
в -path мы прописываем абсолютный путь
например у меня есть папка /home/vasya/temp/!9/2
кстати замечу что ее нужно взять в одинарные кавычки
иначе быш при вызове find вместо ! подставить чтот там из 
истории команд.
итак есть папка
    /home/vasya/temp/!9/2
у нее есть подпапка 
    .git
я хочу ее исключить
тогда в -path надо указать полный путь

    $ find '/home/vasya/temp/!9/2' -path '/home/vasya/temp/!9/2/.git' -prune  -o -name "*.txt" -print | grep .git

вот видим что вывод пустой
если бы мы указали в -path относитльный путь  относиельно базовой папки
то ничего бы не сработало.

хотя я несколько лукавлю когда говорю что в -path нужно указывать
полный путь. не совсем так. надо понимать как будет выглядеть имя файла
если мы указали нашу базовую папку
показываю

    $ find '/home/vasya/temp/!9/2' 
    /home/vasya/temp/!9/2
    /home/vasya/temp/!9/2/1.txt
    /home/vasya/temp/!9/2/3.txt
    /home/vasya/temp/!9/2/.git
    /home/vasya/temp/!9/2/.git/5.txt

он будет всегда выглядеть как  '/home/vasya/temp/!9/2' + '.....'
поэтому мы берем в этом списке ту папку которую хотим исключить и всталвяем 
в -path  в данном случае это '/home/vasya/temp/!9/2/.git'
так вот теперь я запущу тот же поиск в той же папке но задам по другому
название базовой папки
    $ find . 
    .
    ./1.txt
    ./3.txt
    ./.git

и мы видим что наша искомая папка тепер имеет имя './.git' так вот именно его 
теперь надо подствлять в -path './.git'
тоесть

    $ find '.' -path './.git' -prune  -o -name "*.txt" -print | grep .git

тоесть то как будет выглядеть -path все таки зависит от $basedir
я бы сказал что -path нужно указывать в виде 
    -path '$basedir+$dir'
    
тоесть -path это полный путь к папке но с учетом в какой форме задан basedir
самой простой спооб понять что вставить в -path это запустить просто поиск с 
basedir и потом прогрепать и найти название папки нужной нам и вставить в -path

причем -path допускает вставляьь в себя шаблоны. пример

    $ find '.'
    ./1.txt
    ./a01
    ./123
    ./b01

    $ find '.' -path "./?01" -prune  -o -name "*" -print 
    ./1.txt
    ./123

тоесть в данном случае он исключил папки 
    ./a01
    ./123
    ./b01
на основе шаблона "./?01"
причем этот шаблон обработал именно find а не баш перед тем как запустить find

или вот я хочу исключить a01 и b01 
делаю это на основе шаблона "./[ab]01"
опять же хочу подчеркнуть что этот щаблон обарабывает 
именно find  а не баш до того как запустить find

    $ find '.' -path "./[ab]01" -prune  -o -name "*" -print 
    ./1.txt
    ./123



возвращаюсь к исходному примеру

       $ cd /source-dir
       $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 /dest-dir

вторая строчка эквивалентна
       $ find . -name .snapshot -prune -o "("  \! -name '*~'  -print0 ")" | cpio -pmd0 /dest-dir
    
    
сразу замечу что скобками огораживается хрень вида  условие + действие
тоесть find можно вот так расписать его синткаскис

    $ find DIR  (условие1 действие1 AND/OR условие2 действие2 ...) AND/OR 
        (условие5 действие5 AND/OR условие6 действие6) 

в условиях мы указываем что ишем а в действии что мы делаем с найденным именем файла
DIR - базовая папка откуда начинаем поиск всегда остается вне скобок

-o  это OR для find

если у нас внутри скобок тольк одно условие+действие то его можно в скобки и не 
заключать. тоесть 

    find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) =
  = find . -name .snapshot -prune -o  \! -name '*~' -print0 =
  = find . "(" -name .snapshot -prune ")" -o "("  \! -name '*~' -print0  ")"

это все одно и тоже.
скобки являются парамтрами файнд а в баш они являются спецсмволвами. поэтому надо 
чтобы баш их передал  в файнд как еть. поэтому мы их экранируем. тожесамое касается !.
экранировать скобки можно либо через слэш \( либо через кавычки "("
! можно экранировать либо черещ \! либо '!' наколько я помню двойные кавычки "!" 
нихрена не экранируют !

итак возвращаюсь к этой строчке

    $ find . -name .snapshot -prune -o "("  \! -name '*~'  -print0 ")"

в папке "." и ее подпапках ищется папка с именем ".snapshot" на люыбых
глубинах и  в нее вход запрещен. помимо этого ищутся все файлы и папки кроме 
тех у которых на конец имени стоит "~" 
кстати проверка что насчет тильды я прав

    $ ls -1 
    123
    123~
    1.txt
    a01
    b01

    $ find . '!' -name "*~"
    ./1.txt
    ./a01
    ./123
    ./b01

да все верно

итак возвращаясь к исходному примеру

    $ cd /source-dir
    $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 /dest-dir

переходим в папку '/source-dir'
ищем в ней все файл и папки кроме тех что имеют в имени на конце "~"
и кроме папок у которых имя ".snapshot"  и эти имена посылаются через пайп
в cpio. расшифровааю ключи от cpio. где cpio это такой архиватор. и копировалщик между 
папками. нахер он нужен надо почитать. итак его ключи
 -p, --pass-through
              Pass-through.  Read a list of file names from the standard input 
              and copy them to the specified directory.
итак как раз ключ -p говорит о том что имена файлов которые копировать брать из stdin
что ему и делает find
        -d, --make-directories
            Create leading directories where needed.

       -m, --preserve-modification-time
              Retain previous file modification times when creating files.

        -0, --null
              Filenames in the list are delimited by null characters instead of newlines

значит -d создает папки в dest-dir, -m нетрогает mtime, а -0 говорит о том что
имена файлов которые прилетают из stdin разделены байтом 0x00
и действельно у find мы юзаем -print0 
который на конце имени файла прилепляет 0x00 байт вместо дефолтового 0x0a
это на случай если есть ебанутые файлы у которых в имени есть символ "\n"

по факту вся эта констуркция find | cpio копирует файлы и папки и  /source-dir 
в /dest-dir,

непонятно только нахер это делать через cpio.

вот к этому примеру в man find есть подпись. 
This  command  copies  the  contents of /source-dir to /dest-dir, 
but omits files and directories named .snapshot (and anything in them).
It also omits files or        directories whose name ends in ~, but not their contents.  
The construct -prune -o \( ... -print0 \) is quite common. 
The  idea  here  is  that  the  expression
before  -prune  matches  things  which are to be pruned. 
However, the -prune action itself returns true, 
so the following -o ensures that the right hand side is
evaluated only for those directories which didn't get
pruned (the contents of the pruned directories are not even visited, so  their 
contents  are  irrelevant).
The  expression  on  the  right  hand  side of the -o is
in parentheses only for clarity.  
It emphasises that the -print0 
action takes place only for things that
didn't have -prune applied to them. 
Because the default `and' condition between tests 
binds more tightly than -o, this is the default anyway, but the  parenthe‐
ses help to show what is going on.

из нее следует какая то хрень что типа файнд игнориует как я уже сказал 
файли  и папкт котоыре имеют на конце "~" и папки ".snapshot" но 
при этом они пишут что ихний контент не игнориуется. это что за хуйня?
не игнориуется кем? если файндом - то конечно игнорируется потому что 
их имен не будет в списке который он высирает на stdout.  а игнориует 
ли их cpio ну не знаю...  проведу эксперимент.

у меня есть структура папок

    $ find . -printf "%y  %h/%f \n" 
    f  ./10.txt 
    f  ./9~ 
    d  ./.snapshot 
    f  ./.snapshot/snapshot.txt 


тоесть в корне два файла 
    10.txt
    9~
и папка
    .snapshot
и внутри нее файл 
    snapshot.txt

соовтестенно файнд выдаст на stdout только 10.txt и все.
    $ find . -name .snapshot -prune -o \( \! -name "*~" -print \)
    .
    ./10.txt

так оно и есть . а теперь запускаю полную команду

    $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 '../!11'
    1 block

в итоге я захожу в папку '../!11' и в ней ровно так и есть что скопировался
только файл 10.txt и больше ничего. поэтому я считаю вот этот кусок фразы
    but not their contents
полная хуйня. в итоге будет скопирован ровно тот набор файлов который 
ему укажет find
тоесть если скажем у нас есть папка папка и в ней есть файл 10.txt
и 9~ то файл 10.txt будет скопирован а файл 9~ не будет хотя само название
папки будет передано в cpio. но он из нее 9~ исключит.
я еще раз проерил ровно так и работает
я завел подпапку ./12 и в ней два файла 12.txt и 13~
при этом у меня файнд передал название папки и файл 12.txt
    /12
    ./12/12.txt
так вот cpio он такой умный он видит название папки но копиреует оттуда 
только те файлы которые есть в списке что ему передали а не всю папку.
прикол.


но это еще невсе. в описании написано что все actions которые есть в find
например -prune они делают некий код вовзрата например -prune всегда делает
код возврата true. спрашивается а какая нам разница. а это имеет значение
для наших AND/OR
например

     $ find . -name .snapshot -prune -o  "("    \! -name '*~'   -print0   ")"

у нас стоит 
     find .  (-name .snapshot -prune)   OR   (\! -name '*~' -print0 )
как работает OR а именно
     cond1 OR cond2
если слева операция дает TRUE то правая операция уже не запускается.
правая операция запускается только если левая вернула FALSE
условие начинает проверятся прежде всего левое.
получается до правого может и недойти.
получаетс у нас prune стоит слева поэтому каждый новый файл проверяется прежде 
всего на prune. таким образом если файл удовлетворяет прун. то он отбрасывается
этим пруном из списка файлов высираемых файндом и кодом возврата является TRUE
поэтому данный файл далее не проверяется на условия которые стоят в правой скобке.
то что кодом возврата прун является всегда true означает то что если за ним стоит OR
то то что стоит за OR не будет выполнено. тоесть если у нас файнд берет очередного
кандидата и натравливает его на первую скобку. и этот кандидат удовлетвтоярет условию
этой первой скобки то действие прун в этой скобке исключает этот файл из того чтобы
высрать его имя на stdout плюс так как прун код возврата возращает TRUE а затем 
стоит OR это приводит к тому что дальнейшая обработка этого кандидата прекращается.
если же кадидат не удовлветоряет услвию в первой скобке то первая скобка вовзращает 
false и тогда вдействие вступает вторая скообка стоящая за OR
там тоже может быть либо фолс либо тру. но фишка состоит в том что так как прун стоит
в первой скобке то никакой хреновый кадидат не прорвется через эту первую скобку.
если собкки поменять местами 

    (\! -name '*~' -print0 ) OR (-name .snapshot -prune)     

то у нас папки с именем .snashot будут успешно удовлетворять первой скобке
и прорываться наружу из файнд в stdout
тоесть поток выглядит так

очередной кандидат /dir1/file1 -->find -->(первая скобка )если $?=true то -->stdout
                                                         |если $?=false то -->(вторая скобка)

из второй скобки путь:
(вторая скобка)если $?=true то -->stdout
              |если $?=false то -->имя кандидата в /dev/null
                                       

таким образом скобку с прун надо всегда ставить в самом начале слева.
чтобы она обрабатыватлась первой. и далее ставить OR
тогда если мы нашли гавняную папку то дальнейшая обработка этой строки 
прекратится а кадидат отправится в топку

теперь такой момент. как я уже сказал что нужно условие на основе 
которого искать файлы а потом надо указать действие. так вот оказывается что
можно указат НЕСКОЛЬКО действий.
вот пример
в нем я для кажого найденного файла применяю аж три actions
печатаю на экране имя файла, печатаю имя файла в в файл на диск,
и запускаю команду echo

    $ find . -print   -fprintf "/tmp/1.txt" "%f \n"  -exec  echo === ';'
    .
    ===
    ./10.txt
    ===
    ./9~
    ===
    ./.snapshot
    ===



                                    
кстати щас малек в сторону пример вначале.
у меня есть папки вида  !1 !2  !3 я их хочу пеернименовать в !01 !02
как это сделать

    $ find . -maxdepth 1 -name '!?'  | cut -c 4- | xargs -L1 -n1  -I%  mv  './!'% './!0'%


    
    
следующий пример

    $ find . "(" -exec test -d '{}'/.svn ";"  \
      -or -exec test -d '{}'/.git ';'  \
      -or -exec test -d '{}'/CVS ';' ")" \
      -print -prune


схематично комана выгляди так

    $ find DIR ( action1 OR action2 OR action3 ) AND action4 AND action4

и это опять новое слово потому что оказывается что можно ставить AND\OR не тольк между
    ( условие1 action1 ) AND\OR (условие2 action2 )
но и в случае 
    ( action1 ) AND/OR ( action2 )
без указания условий
причем получается что выставление скобок повышает приоритет . тоесть

   A OR B OR C AND D AND E

это совсем другое по сравнению с 

   ( A OR B OR C)  AND D AND E


возвращаюсь к примеру

  $ find . "(" -exec test -d '{}'/.svn ";"  \
      -or -exec test -d '{}'/.git ';'  \
      -or -exec test -d '{}'/CVS ';' ")" \
      -print -prune
      
схематично выгляит комнад так

    $ find . ( exec test OR exec test OR exec test ) AND print AND prune
    

так вот пример по теме
    $ find . -type f      -a \
             -name "*12*" -a \
             -exec bash -c 'if echo {} | grep -q  "txt"; then exit 0; else exit 1; fi' ';' -a \
             -print 

    ./123.txt
    ./12.txt

я ранее писал неверно.  я писал что (условие + action) записываюьтся 
вместе и только эта связка разделяется логическими операторами AND/OR
на самом деле нет. на самом деле find его синтксим выглядит так

    $ find DIR условие/action  AND/OR условие/action AND/OR условие/action

тоесть указывается DIR а потом идут в линнеечке либо условие либо action
они абсолютно равнозначны между ними по дефолту незримо стоит AND
хотя можно его поставить в явном виде -a , а можно поставить OR как -o
результатом проверки условия либо выпоонения action явялется код возврата.
соовесвтенно если на какомто шаге код возврата FALSE а дальше стоит AND
то обработка текущего файла прекращается а если OR то наобоорот переходит 
к следущему шагу в цепочке. если мы хотим несаолко шагов обьединить в один 
то применяем скобки.

    $ find DIR (условие/action  AND/OR условие/action) AND/OR (условие/action)

а я раньше думал что action происходит только если выполнился слева от него условие.
а это оказалось совсм не так. 
например 
я думал что если стоит

   -type f -print 
   
то это значит что если -type f то выполнить -print
а оказалось что 
  
    -type f -print  =  (-type f) -a (-print) = (-type f) AND (-print)
    
читается так что если код возврата от -type f равен TRUE то происходит переход
к выполению\проверке следующего шага в цепочке
так вот теперь живой пример

    $ ls -1
    12
    123
    123.txt
    12.txt
    13
    13.txt

    $ find . -type f      -a \
             -name "*12*" -a \
             -exec bash -c 'if echo {} | grep -q  "txt"; then exit 0; else exit 1; fi' ';' -a \
             -print 

    ./123.txt
    ./12.txt

    
работает эта шарманка так. find начинает сканировать папку "." берет из нее первый
файл или папку и нправляет это на первых шаг цепочки  
    -type f -a \
если это непрстой файл то код возврата FALSE и поскольку дальше стоит -a (AND)
то обработка текущего файла прекращается. и файнд переходит к сладущему файлу 
начинает опять сначала. если тип файлы обычный то кодд вовзарата TRUE
и посколку дальше стоит -a то файнд переходит  к следущему шагу
    -name "*12*" -a \
и идет проверка имя файла совпдает по паттерну "*12*"
если нет то поскольку далше стоит -a (AND) то тогда оббработка этого файла прекращается.
если же имя соотвесвтует паттерну то код возварат true и так как дальше 
стоит -a то происхдодит переход к следушему шагу
    -exec bash -c 'if echo {} | grep -q  "txt"; then exit 0; else exit 1; fi' ';' -a \
здесь выполняется некая внешняя команда в которую через {} файнд подставляет
имя файла текущего если код возврата FALSE то посколлку дальше стоит -a 
то обработка текущего файла прекращается. если же TRUE а в данном случае 
я тестирую что имя файла по шаблогу пересекается с "txt" то тогда происходит 
переход к следушему шагу. по сути exec позволяет нам расширить функционал
команды find за счет любых внешних команд
    - print
это последний шаг и он по своей сути что делает. он печатает имя файла на экране.
поэтому этот шаг этот action его имеет смысл вставлят самым последним самым правым
в цепочке. тоесть после того как прошли все проверки. все команды. 
вот так это рабоает
тогда в итоге команда эта работает так
она проверяет что файл по типу простой   AND 
что имя его вкладывается в шаблон "*12*" AND
далее проверяется что имя соотвествует шаблону "*txt*" AND
печатется на экране имя файла

так вот возврашаюсь к примеру

        $ find repo/ "(" -exec test -d '{}'/.svn ';' -or   \
                         -exec test -d '{}'/.git ';' -or   \
                         -exec test -d '{}'/CVS  ';'  ")"  \
                         -print -a \
                         -prune
                         


значит эта команда работает так (...) AND -print AND -prune
значит команда идет в папку  repo/ 
и последовательно берет оттуда название каждого файла каждой
папки как аргумент например пусть repo/dir1 
вначале отрабатывает скобка , в скобке идет проверка на то что 
repo/dir1 имеет подпапку .svn либо подпапку .git либо подпапку CVS
если хотя бы одно выполняется то файнд переходит к следущему шагу в цепочке
а именно печатает имя repo/dir1 на терминал, команда -print 
всегда имеет код возврата TRUE поэтому далее файнд перходит к 
следушему шагу в цепочке и делает prune.
самый главный вопрос что тут делает prune
значит я малек переписал команду

 $ find repo/ -exec [  -d "{}/CVS" -o -d "{}/.git" -o -d "{}/.svn" ] ';' -print -prune
 
значит я убираю /repo меняю на . 
чтобы это меня не отвлекало от главного 

 $ find .  -exec [  -d "{}/CVS" -o -d "{}/.git" -o -d "{}/.svn" ] ';' -print -prune

значит что делает prune. во первых prune работает только если файнд сейчас 
обрабатывает имя папки пусть это папка ./project1 так вот если файнд 
доходит в цепочке до команды prune то после этого файнд прекращает обработку
всех файлов в этой папке, и всех подпапок этой папки. тоесть 
если у нас файнд обрабывает сейчас ./project1 и файнд дошел до -prune 
в цепочке то после этого файнд сразу отбрасывает для дальнейшей обработки все 
файл и папки с путями ./project1/*
таким макаром логика этой команды такая. мы берем папку "." начинаем сканировать 
все файл и подпапки этой "." , файлы мы сразу обрасываем потому что в логике этой программы
файлы вообще не участвуют. но можно улучшить эту команду чтобы это было еще более
явно ясно

 $ find .  -type d -exec [  -d "{}/CVS" -o -d "{}/.git" -o -d "{}/.svn" ] ';' -print -prune

 
так вот фанд берет первую подпапку в "." скажем ./vasya
и выполняет exec который тестирует через баш а есть ли у ./vasya подпапки ./vasya/CVS
либо ./vasya/.git либо ./vasya/.svn подчеркну важную вещь что сам файнд 
на данном этапе оперирует в качестве аргумента папкой ./vasya
а проверка на существоввание   ./vasya/CVS | ./vasya/.git | ./vasya/.svn
идет средствами внешними через внешнюю баш команду []
если это так то печатается аргумент файнда на экране ./vasya
тоесть аргумент уже напечатался а далее выполняется следущая команда из цепочки
это prune и она приводит к тому что все подпапки этого аргумента выбрасываются
из дальнейшей обработки. тоесть ./vasya/*
это обусловаленно логикой программы. а именно мы хотим найти начиная от корня все 
папки как можно выше в которых есть подпапки .git .svn CVS
если у какойто папки любая из этих подпапок найдена то копать глубже нет смысла. 
поэтому мы применяем prune чтобы find не занимался переборкой ненужных уже нам
подпапок этой папки. мы уже узнали что хотели и дальше в этой папке копать абсолютно
 ненужно.
 
если мы имеем вот такую структуру папок
       repo/project1/CVS
       repo/gnu/project2/.svn
       repo/gnu/project3/.svn
       repo/gnu/project3/src/.svn
       repo/project4/.git

файнд берет repo/project1/ и проверяет есть ли у нее подпапки из {.git, .svn, CVS }
и да она есть. мы печатаем на экране аргумент файнда 
        repo/project1/
а делее к repo/project1/ примяеняется prune поэтому файнд запрещает
сам себе дальнейшую обработку путей вида repo/project1/*

потом файнд берет следущую папку repo/gnu/project2/
провяеряет и находит что есть подпапка .svn печатает на экране
    repo/gnu/project2/
и на будущее запрещает себе обработку папок вида  repo/gnu/project2/*

далее интересно. файнд беерет как аргумент  repo/gnu/project3/
проверяет что есть .svn как подпапка. печатает аргумент 
        repo/gnu/project3/
и запрещает сам себе обработку всех путей вида repo/gnu/project3/*
тоесть запрещает себе обрабатыать файлы этой папки и спускаться ниже в подпапки
поэтому вот эта папка  repo/gnu/project3/src
она хотя и имеет подпапку .svn но она никогда не попадет как аргумент 
в файнд. потому что на предыдущем шаге find запретил себе обрабатывать все что ниже 
repo/gnu/project3/*

напишу аналогичную программу. она ищет в каждой папке README.txt 
если находит то прекращает искать ее в подпапках этой папки
показываю структуру папок

    $ find . "(" -type f  -exec echo "FILE    {}" ';' ")"   -o \
             "(" -type d  -exec echo "DIR     {}" ';' ")" 

    DIR    .
    DIR    ./proj1
    DIR    ./proj1/01
    FILE   ./proj1/01/README.txt
    FILE   ./proj1/README.txt
    DIR    ./proj2
    DIR    ./proj2/super1
    DIR    ./proj2/super1/01
    FILE   ./proj2/super1/01/README.txt
    FILE   ./proj2/super1/README.txt
    DIR    ./proj2/super2


    $ find   .   -type d    -exec [ -f "{}/README.txt" ] ';' -print -prune 
    ./proj1
    ./proj2/super1

поскольку я вставил -prune и поскольку в папке ./proj1 есть файл README.txt
то подпапки  ./proj1/* исключаются из дальнейшей обработки поэтому 
папка ./proj1/01/ ее нет в распечатке не смотря на то что у нее есть README.txt
тоже самое поскольку файл README.txt есть в папке ./proj2/super1/
то подпапки ./proj2/super1/* исключаются из обработки файндом. поэтому
папка ./proj2/super1/01/ отсуствует в распечатке несмотря на то что в ней
есть README.txt
это хороший пример на понимание что дает -prune 

следщий пример

    $ find /tmp \( -type f -o -type d -o -type l \)
    
видно что вэтой команде есть только условия но нет ни одного action. так вот
если так есть то по дефолту файнд допиывает невидимо action -print
тоесть полная аналогия команды это 

    $ find /tmp \( -type f -o -type d -o -type l \) -print
    
    
в папке /tmp  ищутся файлы типов: обыный файл, папка, симлинк.
если файл удовлетворяет какому то из этих типов то имя файла\папки 
выводится на терминал 
    
далее в man find вижу такое
The command 

    $ find . -name afile -o -name bfile -print 

will never print afile because this is actually equivalent to 

    $ find . -name afile -o "(" -name bfile -a -print  ")"  

Remember that the precedence of -a is higher than that of -o and 
when there is no operator specified between tests, -a is assumed.

и дейсивтельно. так как перед -print нестоит ничего значит там незримо 
стоит -a значит у нас  A  OR  B  AND C
а это сооветсвенно A  OR  ( B  AND C )
    
тоесть 

    $ find . "(" -name afile ")"   -o   "(" -name bfile -a -print  ")"  

теперьт посмотрим что будет. 
когда аргумнтом будет bfile то первая скобка возварщает FALSE но так как 
у нас между скобками OR то запускается вторая скобка в которой мы выполняем -print
и печатаем bfile на терминале.
а вот когда аргументом будет afile то да условие -name afile успешно выполняется
но не написано какой экшн надо сделать поэтом скобка отрабатывает. но нихрена не 
печатает . возрвращвает TRUE . а так как справа стоит OR между скобками
то правая скобка уже не выполняется. так что имя файла afile дейстиеьно
никгда не будет наечаттано на экране. а чтобы он было напечатано надо переделать команду

    $ find . "(" -name afile    -o   -name bfile ")" -a -print 
    
теперь у нас A AND B
где A = (C OR D )
и в итоге если у нас  внутри скобки хотя бы одно из условий выполняется тоесть 
имя файла либо afile либо bile то скобка возвращает TRUE 
и так как далее AND то печаатет аргумент на экране. 
если у нас аргумент ни afile ни bfile то  скобка вовзращает FALSE и так как
далее указано AND то обработка такого аргумента прекращается.

далее приводится в man find пример

    $ find . -name *.c -print
    find: paths must precede expression
    Usage: find [-H] [-L] [-P] [-Olevel] [-D ... [path...] [expression]

они пишут что ошибка вылезла потому что знак * является спецсимволом
в баше поэтому перед тем как баш запустил find (внешнюю команду)
то баш обработал спецсимвол  и подставил вместо * а аргумент 
нечто другое наподобие вот такого

    $ find . -name frcode.c locate.c word_io.c -print
    
а эта команда по синтаксису уже неверная так как у find нет таких элеметов
в цепочке как locate.c word_io.c
поэтому они пишут что нужно от баша экранировать спецсимвол *
    
    $ find . -name '*.c' -print
    $ find . -name \*.c  -print
    $ find . -name "*.c" -print

и я с этим абсолютно согласен

далее.
есть  экшен -exec command arg1 arg2 '{}' arg3  ';' у find
который для каждого аргумента запускает внешнюю команду 
в которую можно подставить аргумент через '{}' а символ ';'
исползуется чтобы обьяснить файнду что мы закончили описыывать внешнюю команду
пример

    $ find . -exec echo '{}' ';'
    .
    ./13.txt
    ./123.txt
    ./123
    ./12
    ./12.txt
    ./13

а есть похожая команда -exec command arg1 arg2 '{}' arg3  '+'
которая визуально отличается от предыдудщей тем что стоит '+'
эта команда отличается тем что она запускает внешнюю команду не для каждого
аргумента а ( и тут два варианта ) либо она собирает все аргументы и подстлавяет
их во внешнюю команду за один раз через пробел, либо разбивает все 
аргументы на какието кучи и запускает их несколько раз
пример

   $ find . -exec echo '{}' '+'
    . ./13.txt ./123.txt ./123 ./12 ./12.txt ./13

как говорится почувствуй разницу

прододжаю читать man find
там написано что если папка в которой начинать искать не указана
то автоматом подразумевается что это папка "."

-P означает не следовать смивлоическим ссылкам
это озеачает что если файл это симлинк на папку то внее не входим.
еслли симлинк это файл то на запрос свойства этого симлинка
будутпоказаны свойства именнно симлинка

-L означает следовать симлинкам. 

-H означает что не следовать симлинкам но если смотрим свойства 
файла то будет показывать свойства файла на который покаызвает симлинк

по по деолфту работает -P . если мы укажем вс троке несколько 
этих опций то каждая следующая отменяет предыдущее


пример
есть такая структура файло папок
тоесть у нас есть симлинк на файл и симлинк на папку
    $ ls -1al
    lrwxrwxrwx   20 дек 15  10.dir -> '/home/vasya/temp/!10'
    lrwxrwxrwx   27 дек 15  10.lnk -> '/home/vasya/temp/!10/10.txt'


запускаем -P который неследует симлинкам
видно что да. покащывает размер 
именно симлинков
    $ find -P .  -printf "%y %h/%f   %s \n"
    l ./10.lnk   27 
    l ./10.dir   20 

    
запускаем -L который следует симлинкам
    $ find -L .  -printf "%y %h/%f   %s \n"
    f ./10.lnk   2 
    d ./10.dir   4096 
    f ./10.dir/10.txt   2 
    d ./10.dir/repo   4096 
    d ./10.dir/repo/project4   4096 
    d ./10.dir/repo/project4/.git   4096 
    ...
    ...
    
смотрим с ключом -P у нас была вот такая инфо про файл 10.lnk
тоесть имя  10.lnk
тип файла симлинк
размер 27 байт
    l ./10.lnk   27 
а вот как с ключом -L у нас информация про 10.lnk
имя 10.lnk
тип файла обычный файл
размер 2 байта
    f ./10.lnk   2 

надо заметить что с ключом -L у нас тип файла и размер файла указан
тот на который укаывает симлинк. но имя показывается по прежнему самого симлинка

что касается симлинка который указывет на папку
c ключом -P
        l ./10.dir   20 
с ключом -L
        d ./10.dir   4096 

опять же с ключом -L показан тип файла это d и размер 4096 байт. 
тоесть то как это есть у папки на которую показывает симлинк
только название показывает как у симлинка
плюс find провалился в симлинк папку и показывает еще контент этой папки.

тут всплывает еще интересный момент что значит размер папки 4096 байт?
я щас покажу это не для симлинка а для реальной папки
беру реальную папку с именем "1"
    $ stat 1
        File: 1
        Size: 4096      	Blocks: 8          IO Block: 4096   directory

и мы видим что размер папки 4096 байт. что это за хрень.
а это вот то и есть. это не суммарный размер всего того что лежит внутри 
папки. это размер файла на ФС который хранит в себе список файлов и список папок
лежащих в этой папке. тоесть папка это файл на фс который внутри себя содержит
всего навсего список файлов и список папок. просто сраный список. 
вот эта хрень иммет размер 4096 байт.

на счет -H я нихуя не понял. показывает ровно тоже самое что -P

    $ find -P .  -printf "%y %h/%f   %s \n"
    d ./.   4096 
    l ./10.lnk   27 
    l ./10.dir   20 

    $ find -H .  -printf "%y %h/%f   %s \n"
    d ./.   4096 
    l ./10.lnk   27 
    l ./10.dir   20 


опция -D позволяет смотреть дебаг инфо. только там хер что поймешь
    $ find -D help  . -exec ech
    $ find -D stat  . -exec ech
    

-O позволяет как то там оптимизировать процесс поиска файлов
тоже нихера непонятно что там по факту и как

есть экшен 
    -ok command '{}' ';'
это тоже самое как exec только при запуске команды он каждый 
раз будет справшивать у нас разрешения на клаве

есть хрень о фильровании имени -name  но как я понял 
есть более мощная хрень по фильтрации имени файла -regex
и можно даже выставить какой именно regex мы используем. для этого юзаем
-regextype 

    $ find . -regextype help
    find: Unknown regular expression type ‘help’; 
    valid types are ‘findutils-default’, ‘awk’, 
    ‘egrep’, ‘ed’, ‘emacs’, ‘gnu-awk’, ‘grep’, 
    ‘posix-awk’, ‘posix-basic’, ‘posix-egrep’, 
    ‘posix-extended’, ‘posix-minimal-basic’, ‘sed’.

у меня заработало только с -regextype sed

    $ find . -regextype sed -regex  ".*12.*"
    ./12
    ./12/13~
    ./12/12.txt

о том как задать шаблон через регекс у sed можно посмотеь 
здесь https://regex101.com/
также надо понимать что в поле -regex мы ищем имя файла сучетом его полной
строчки пути как ее будет печатать find. то есть скажем мы ищем в строке
вида
    ./12/12.txt
а не вида
    12.txt
    
следущий момент. в find можно сразу задать критерии поиска через запятую ","
это аналог "command 2; comand2" в баш. тоесть  файнд будет 
обрабатьывать всегда и то что слева от ; и то что справа. введена 
эта хрень для того если мы хотим за один прогон по диску посмотреть сразу
несколько разных запросов. хотя чем это лучше () -o () мне непонятно
цитирую что написано про это в man find

expr1 , expr2
  List; both expr1 and expr2 are always evaluated.  The value of expr1 
  is discarded; the value of the list is the value of expr2.  
  The comma operator can be   useful for searching for several different
  types of thing, but traversing the filesystem hierarchy only once.  
  The -fprintf action can be used to list the
  various matched items into several different output files


пример
    $ find .  -type f -name "*10*"   -print , \
              -type f -name "*9*"    -print , \ 
              -type f -name "*.svn*" -print

    ./10.txt
    ./repo/gnu/project3/.svn
    ./repo/gnu/project3/src/.svn
    ./repo/gnu/project2/.svn
    ./9~


походу про find НАКОНЕЦ ВСЕ




| printf
далее
на счет floating чисел и printf

надо четко помнить что у принтф числа с запятой
они обязательно обозначаются через запятую а не точку.
пример
когда получаем ошибку
потому что я юзаю "1.2345"
    $ printf "\$%.7f \n"  "1.2345"
    bash: printf: 1.2345: invalid number

пример когда все работает
потому что юзаю "1,2345"
    $ printf "\$%.7f \n"  "1,2345"
    $1,2345000 


| ls
| dir
| vdir
| glob
| globbing

если посмотреть их ключи то это как бутто одинаовые команды.
однако они не имеют одинаковые бинарники. хотя на выходе показыают
вобщем то одно и тоже.

нашел в иенет в чем прикол.
да это разные команды. какая то из этих команд ее не было 
раньше в unix а какая то была. так вот как я понял dir написали позже.

короче про разницу этих команд. если мы запускаем ls без ключей
    $ ls
и ее stdout смотрит на терминал то она высирает список файлов
в горризонтальную строчку.  а если ее stdout смотрит в пайп то 
она высирает список файлов в столбик сука. щас покажу

    $ ls
    10.txt  12  23.bash  9~  repo

    $ ls | cat
    10.txt
    12
    23.bash
    9~
    repo

команда же dir она высирает список одинаково
что на терминал что в пайп

    $ dir
    10.txt	12  23.bash  9~  repo

    $ dir | cat
    10.txt	12  23.bash  9~  repo

как я понял команда dir была придумана исходя из доктрины что команда
должна выдавать одинаковый результа в независимости куда она срет 
в терминал или в пайп или файл на диске.

хочу сказать что у команды ls описание ее ключей в man ls
хуевое. лучше его смотреть  в info ls

есть такой ключ --author 
‘--author’
     List each file’s author when producing long format directory
     listings.  In GNU/Hurd, file authors can differ from their owners,
     but in other operating systems the two are the same.

прикол. в linux он неимеет смысла.

значит я всегда думал что ls показывает список файлов и подпапок у указанной
папки. это оказалось лишь часть правды. на самом делел формат ls таков:

    $ ls file1 DIR1 DIR2 file2

и ls покажет информацию об указанных в аргументах файлах
и папках. если в аргументе папка то он покажет ее файлы и подпапки.
тоесть сущенственно то что ls умеет показывать инфо и про файлы. 
и то что он умеет показывать содержимое нескольких папок одновременно. 
пример
вот пример где ls имеет в аругменте только файл

    $ ls -1al  ./10.txt
    -rw-rw-r-- 1 vasya vasya 2 дек 14 11:40 ./10.txt
     
а вот пример где ls имеет в аргументе 
сразу несколько папок
в данном примере мы ссмотрим содержимое папки 3 и папки 6
название папок ls обозначает через : тоесть 3: или 6:
    $ ls -1  ./3 ./6
    ./3:   <--- название папки
    afile
    bfile

    ./6:   <--- название папки
    sleep2

    
если указать ключ -d то ls не будет показыват содержимое папки которая
у него указан в качестве аргумента. а будет показывать всего навсего 
только имя папки.
повторяю предудыщую команду но добавляю ключ -d
как говортся заметьи разницу
в выводе
    $ ls -1d  ./3 ./6
    ./3
    ./6


если в ls мы не указываем имя файлы или папки 
которую хотим просмотреть то по дефолту подставляется папка "."
тоесть $ ls это   $ ls .

есть ключ 
    --indicator-style=file-type 
он дает то что к именам папок добавляется "/" таким макаром 
можно визуально понять где имя файла а где имя папки
пример

    $ ls -1 --indicator-style=file-type   .
    1.txt
    2.txt
    dir1/
    dir2/


вот пример когда я в ls подсунул нвазание двух папок dir1
и dir2 и он покаызает их содержимое за один раз

    $ ls -1 --indicator-style=file-type    dir1 dir2
    dir1:
    1.txt

    dir2:
    2.txt

а вот я подснул ему еще и имя файла 

    $ ls -1 --indicator-style=file-type    dir1 dir2   1.txt
    1.txt

    dir1:
    1.txt

    dir2:
    2.txt

а теперь подсовывыаем ключ -d и он приводит   к  тому что ls 
небудет показывать содержимое папок которые я ему указал в качестве 
аргумента. только я не очень поимаю как практический смысл
этого ключа на практкие нахер он всрался. типа проверить есть ли 
папка с указанным именем что ли ?

    $ ls -1 --indicator-style=file-type  -d   dir1 dir2   1.txt
    1.txt
    dir1/
    dir2/

вот пример когда я подсунул имя папки которой нет.
    $ ls -1 -d dir3
    ls: cannot access 'dir3': No such file or directory

кстти когда указываем папку в виде dir3 то автоматом он ищет папку
вот по такому пути ./dir3

далее интересный момент. если мы подставим вместо имени файла\папки спецсимволы
баша то баш прежде чем вызывать ls просканирует папку согласно шаблону спецсимволов
и подставит их как аргументы в ls . показываю

вот есть такое содержимое папки

    $ ls -1 --indicator-style=file-type .
    1.txt
    2.txt
    dir1/
    dir2/

я делаю вот так

    $ ls -1 --indicator-style=file-type   ./d*
    ./dir1:
    1.txt

    ./dir2:
    2.txt

а теперь я покажу как баш вызывает ls в этом случае

    $ strace -e execve ls -1 --indicator-style=file-type   ./d*
    execve("/bin/ls", ["ls", "-1", "--indicator-style=file-type", "./dir1", "./dir2"]
    
тоесть сам баш берет "./d*" сканирует папку вытаскивает оттуда dir1 и dir2
и подставляет при вызове ls. сам ls к этому отношения никакого не имеет.
сам ls  с шаблонами имен работать не умеет.
получаетяс что мы в командной строке пищем вот так 
        $ ls -1 --indicator-style=file-type   ./d*
а баш перехерачивает этот запрос
и запускает ls вот так по факту 
        $ ls -1 --indicator-style=file-type  ./dir1  ./dir2
    
    
еще пример. я хочу посмотреть в папке /etc только файлы начинающиеся с 
буквы a.  сам ls так делать не умеет. значит надо чтобы ктото в ls подставил
список файлов из /etc начинающихся с буквы a* это сможет сделать сам баш.
показываю

    $ ls -1d  /etc/a*
    /etc/acpi
    /etc/adduser.conf
    /etc/aliases
    ...
    
значит в ls список файлов подставил сам баш. вот доказатество

    $ strace -e execve ls -1d  /etc/a*
    execve("/bin/ls", ["ls", "-1d", "/etc/acpi", 
                                    "/etc/adduser.conf", 
                                     "/etc/aliases", 
                                     "/etc/aliases.db", 
                                     "/etc/alternatives", 
                                     "/etc/anacrontab", 
                                     "/etc/ansible", 
                                     "/etc/apache2", 
                                     "/etc/apg.conf", ..."]
    


получается это свойство самого бащ. если мы в комадной строке пишем 
спецсимволы то баш ищет в папке файлы с таким именем и подставляет 
как аргументы при запуске внешней команды
доказательство. запущу тот же щаблон /etc/a* но с командой echo
как видно были посталвелены теже самые аргумтенты

    $ strace -e execve echo   /etc/a*
    execve("/bin/echo", ["echo", "/etc/acpi", "/etc/adduser.conf", 
                         "/etc/aliases", "/etc/aliases.db", 
                          "/etc/alternatives", ....]

                          
    $ echo   /etc/a*
    /etc/acpi /etc/adduser.conf /etc/aliases ....
    

кстати прикол в том что если в папке есть файлы\папки начинающиеся с точки
то баш их по дефолту их ненайдет и не подставит в аргументы.
пример
вот содержимое папки

    $ ls -1a --indicator-style=file-type .
    ./
    ../
    1.txt
    .234/
    .23.txt
    2.txt
    dir1/
    dir2/


и вот я использую спецсимвол * чтобы баш нашел сам файлы 
и подставил в ls как аргументы
и мы видим что нет в списке файлов с точками

    $ ls -1ad --indicator-style=file-type ./*
    ./1.txt
    ./2.txt
    ./dir1/
    ./dir2/

 
доказательство
    $ strace -e execve ls -1ad --indicator-style=file-type ./*
    execve("/bin/ls", ["ls", "-1ad", "--indicator-style=file-type", "./1.txt", 
                       "./2.txt", "./dir1", "./dir2"]
                       
видно что файлы с точками баш невидит!

в любом случае такой способ плох тем что количество аргументов которые баш может подставит 
ограничен. так что на каком то обьеме файлов нас пошдют нахуй.

странно что точка не вопсриимается башем как спецсимвол
    $ strace -e execve ls -1d  .
    execve("/bin/ls", ["ls", "-1d", "."]

а вот так баш уже вопсрпинимает как спецсимволв
    $ strace -e execve ls -1d  .*
    execve("/bin/ls", ["ls", "-1d", ".", "..", ".234", ".23.txt"],
    
и тут кстати видно что в случае шаблона .* баш уже видит 
файлы с точками

    $ ls -1d  .*
    .
    ..
    .234
    .23.txt


дальше вобще пиздец. оказываетя вот эта фича баша когда он спецсимволы
трансформирует в имена файлов по шаблону называется GLOBBING.
шаблоны эттго globbing подчинаются не regex а своим законам.это 
я щас буду изучать. но есть и еще одна пизда. в баше есть доп опции
от которых этот глоббинг зависит. задаются они через shopt

$ shopt
autocd         	off
cdable_vars    	off
cdspell        	off
checkhash      	off
checkjobs      	off
checkwinsize   	on
cmdhist        	on
compat31       	off
compat32       	off
compat40       	off
compat41       	off
compat42       	off
compat43       	off
complete_fullquote	on
direxpand      	off
dirspell       	off
dotglob        	off
execfail       	off
expand_aliases 	on
extdebug       	off
extglob        	on
extquote       	on
failglob       	off
force_fignore  	on
globasciiranges	off
globstar       	off
gnu_errfmt     	off
histappend     	on
histreedit     	off
histverify     	off
hostcomplete   	off
huponexit      	off
inherit_errexit	off
interactive_comments	on
lastpipe       	off
lithist        	off
login_shell    	off
mailwarn       	off
no_empty_cmd_completion	off
nocaseglob     	off
nocasematch    	off
nullglob       	off
progcomp       	on
promptvars     	on
restricted_shell	off
shift_verbose  	off
sourcepath     	on
xpg_echo       	off


напоминаю что до этого я выяснил что опции баща задаются через 
    $ set -o
но то была  только часть опций баща. 
а тут еще shopt вылез.
это пиздец.

кстати что значат все опции shopt можно прочесть в man bash

так вот есть такая тема в баше называется по народному globbing.
про нее читаю здесь:
    1) man 7 glob
также она называется в "advanced bash scripting guuide" 
    2) (https://tldp.org/LDP/abs/html/globbingref.html#FTN.AEN17592)
также 
    3) $ man bash она назвыается "Pattern Matching"
еще вот хорошая статья по теме 
    4) (https://mywiki.wooledge.org/glob)
    
а суть следущая. вот мы записали строку в баш. тыкаем Enter
баш начинает анализировать нашу строку. и если он видит  в строке
символы 
    ?
    *
    [
то он предполагает что мы хотим чтобы он на основе шаблона  заменил
эти символы на имена файлов и папок которые лежат как я понял в текущей 
папке. и толко после такой замены он запускает ту команды которую мы указали.
причем что интересно символы ?*[ они расшифроваются не по закону regex
а по особому glob правилу
    ? - это один символ любой кроме символа "."
    * - это ноль или сколь угодно много символов за исключением случая когда
         первый символ это ".". если "." любой символ кроме первого то это
         подходит
    [:множество:] - означает один символ из указанного множества но кроме "."

прикол в том что  символ "." особый его нужно указывать в явном виде.
об этом ниже.

а пока более подробно про  [множество]
множество бывает либо заданное руками
либо множество на основе предустановленных
множеств.
ручное множество обозначается как [символ1,символ2,символ3]
либо [символ1-символN]
примеры
первый пример
найти файлы у которых первый символ это "a" либо "b" либо "c" 
а второй символ это символы "1" либо "2" либо "3"
    $ echo [abc][1-3]
    a1 b2

предустановленное множество обозначается как [[:множество::]]
(заметим что скобка используется вэтом случае двойная)
предустановленные множества быывают
    alnum 
    alpha 
    ascii 
    blank 
    cntrl 
    digit 
    graph 
    lower 
    print 
    punct 
    space 
    upper 
    word 
    xdigi

таблицу этих множсетв нашел здеcь 
    (https://www.gnu.org/software/grep/manual/html_node/Character-Classes-and-Bracket-Expressions.html)
где
    alnum = alpha +  digit = [0-9A-Za-z]
    alpha  = lower + upper = [A-Za-z]
    ascii = ??
    blank это "space" и "tab"
    cntrl =  In ASCII, these characters have octal codes 000 through 037, and 177 (DEL)
            я посмотрел это все непечатные символы
    digit = [0-9]
    graph = alnum + punct
    punct = ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ _ ` { | } ~
    lower = [a-z]
    print = alnum + punct +  "пробел"
    space = tab, newline, vertical tab, form feed, carriage return, and 'пробел'
    upper = [A-Z]
    word = letters, digits, и  "_"
    xdigit = 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f

итак поехали на примерах   
для глоббинга можно юзать любую команду. я буду юзать echo  
примеры
содержимое папки
    $ ls -a
    .  ..  12  123  124  13  1.txt  .234  .23.txt  2.txt  5  a1  ab  ac  dir1  dir2
напечатать файлы имя которых состоит из двух символов
    $ echo ??
    12 13 a1 ab ac
при этом я подчеркиваю что сам баш перед тем как запустить echo
заменяет ?? на кучу файлов имя которых состоит из двух любых символов
кроме случая когда файл начинается с "." (это будет отдельный случай)
    $ strace -e execve echo ??
    execve("/bin/echo", ["echo", "12", "13", "a1", "ab", "ac"]
напечатать файлы имя которых начинается с "."
    $ echo .*
    . .. .234 .23.txt
паттерн .* перводится для глобинга так : найди все файлы ( и папки) имя
которых начинается с символа "." а далее либо нет символов  либо любое 
количество любых символов. замечу что под паттер .* попала папка ..
тоесть звездочка словила "." только из за того что это второй символ в файле
еще пример на файлы с точкой
    $ >.123.456
    $ ls -a
    .  ..  12  123  .123.456  124  13  1.txt  .234  .23.txt  2.txt  5  a1  ab  ac  dir1  dir2
    $ echo .*
    . .. .123.456 .234 .23.txt

далее
перехожу на примеры с множествами 
напоминаю множество опредеяет один символ 
кастомное множество обознаяается как [acbbc]
а предустановленное множество как [[:множество:]]
пример
    $ ls
    '(1'   12   123   124   13   1a   1.txt  ')2'   
    2b   2.txt   5  '#a'   a1   a.123   ab   
    abab123.txt   ac   a-c.txt   a.txt   b2   N1

ищем все файлы у которых первый символ это либо буква(большая маленткая)
либо цифра
    $ echo [[:alnum:]]*
    12 123 124 13 1a 1.txt 2b 2.txt 5 a1 a.123 ab abab123.txt ac a-c.txt a.txt b2 N1

ищем файлы у которых первый символ это буква (болььшая или маленькая)
    $ echo [[:alpha:]]*
    a1 a.123 ab abab123.txt ac a-c.txt a.txt b2 N1

что такое класс :ascii: я так и не нашел
воможно это любой символ таблицы ascii
    $ echo [[:ascii:]]*
    (1 12 123 124 13 1a 1.txt )2 2b 2.txt 5 #a a1 a.123 ab abab123.txt ac a-c.txt a.txt b2 N1

ищем файлы где первый символ это цифра
    $ echo [[:digit:]]*
    12 123 124 13 1a 1.txt 2b 2.txt 5

    $ echo [[:graph:]]*
    (1 12 123 124 13 1a 1.txt )2 2b 2.txt 5 #a a1 a.123 ab abab123.txt ac a-c.txt a.txt b2 N1    $ echo [:lower:]*

    $ echo [[:lower:]]*
    a1 a.123 ab abab123.txt ac a-c.txt a.txt b2    [:print:]*

    $ echo [[:word:]]*
    12 123 124 13 1a 1.txt 2b 2.txt 5 a1 a.123 ab abab123.txt ac a-c.txt a.txt b2 N1

    $ echo [[:xdigit:]]*
    12 123 124 13 1a 1.txt 2b 2.txt 5 a1 a.123 ab abab123.txt ac a-c.txt a.txt b2


теперь про примеры на основе
множеств заданные вручную
пример
напечатай файлы первый символ у которого это символ из множества abc123 
а остальные символы их либо нет либо они любые
еще раз замечу что ручные множества задаются
через одиночные скобкт а не двойные
    $ echo [abc123]*
    12 123 124 13 1.txt 2.txt a1 ab ac
пример
напечатай файл у которого первый символ любой кроме "."
а второй символ это символ из множества 123
    $ echo ?[123]
12 13 a1
напечатай файлы у которых первый символ это "." а остальные их нет
или они любые
    $ echo .*
    . .. .123.456 .234 .23.txt
итак еще раз как работают шаблоны у глобинга.
    ? - означает любой один символ. но если мы используем ?
    в качестве указателя на первый символ в имени файла то он не 
    может быть ".". если ? указывает на второй и другие символы в имени
    файла то ? включает в себя и "."
пример
    $ >.1
    $ echo ?1
    a1

    $ >a.123
    $ echo a?123
    a.123

тоесть ? обозначает любой один символ при условии что ? обозначает вторую
или третью и далее букву в имени файла. если ? обозначает первую букву в имени
файла то это любой сивол кроме "."
если нам надо найти файл который начинается с "." нам нужно будет указать "."
в явном виде

    * - означает ноль или любое количество символов.любых.
        но если мы ставим * вначале шаблона то он в себя не включит файл 
        у котрого первый символ "."
пример
    $ echo *
    12 123 124 13 1.txt 2.txt 5 a1 a.123 ab ac dir1 dir2
видно что мы поймали все файлы кроме тех у которых "."
стоит первым символом. а там где "." стоит не первым символом мы поймали

    $ echo ?*
    12 123 124 13 1.txt 2.txt 5 a1 a.123 ab ac dir1 dir2
тоже самое. мы поймали все файлы где первый символ любой кроме точки.

ловим файлы с "." вначале для этого нужнопервым симолом указать точку.
    $ echo .*
    . .. .1 .123.456 .234 .23.txt

    [:предустановленное множество:] или [множество] - эта хрень
означает один символ из указанного множества. как я показал выше почемуто
предустановленные множества работют хреново. поэтому юзаем просто множества
которые мы задаем сами. опять же если через [] мы хотим словить первый символ
то символ "." мы не поймаем
    $ echo [.]*
    [.]*
а если это непервый символ то уже точку мы ловим
    $ echo a[.]*
    a.123 a.txt
если мы возьмем в кавычки то ясен банан что globbing тутже перестает работать
    $ echo "a[.]*"
    a[.]*
если мы хотим исключить символ то надо вставить [!символ]
например я хочу запретить чтобы второй символ в имени файла был
    $ echo ?[!2]*
    13 1.txt 2.txt a1 a.123 ab ac a.txt dir1 dir2

а теперь я хочу напечатать все файлы начинающиейся с точки
но хочу исключить системные папки "." и ".."
для этого нужно использовать два шаблона ибо в одном это хрень сделаешь
    $ echo .[!.]* ..?*
    .1 .123.456 .234 .23.txt ..17.txt

.[!.]* = означает что мы разрешаем файлы\папки  у которых первый символ
это "." далее любой символ кроме точки а далее либо нет вобще символов либо они любые
таким образом это шаблон точка(любой символ кроме точки)(любые символы или NULL)
этот шаблон нам отсеет "." и ".." но он нам также отсеет файлы вида ..(любые символы)
например ..17.txt поэтому мы добавляем второй шаблон

..?* = он означает файл\папку где первые два символа это ".." но потом обязательно
есть еще один любой символ а далее либо ничего либо любые символы.
этот шаблон нам захватит ..17.txt но не включить ".."

если же я хочу для этой же задачи заюзать find то это делается вот так
    $ find . -maxdepth 1   -name ".*"  "!" "(" -name .   -o  -name .. ")"  -print
    ./..17.txt
    ./.234
    ./.123.456
    ./.1
    ./.23.txt
переводится как "найди мне все имена фалов\папок в текущей папке, в подпапки
спускаться ненадо, причем имя файла должно начинаться с точки, но при этом
имя файла не может быть ни "." ни ".."
в более явной форме команда выглядит вот так
    $ find .  -maxdepth 1  -a  \
              -name ".*"   -a   \
               "!" "(" -name .    -o   -name .. ")" \
               -print

а вот замена -print на -printf чтобы убрать './' чтобы было 
более красиво
    $ find . -maxdepth 1   -name ".*"  "!" "(" -name .   -o  -name .. ")"  -printf "%f \n"
    ..17.txt 
    .234 
    .123.456 
    .1 
    .23.txt 
сверялся вот с этим местом (https://unix.stackexchange.com/questions/589475/how-can-i-exclude-and-when-listing-only-hidden-items)


вообще это полуается полный прикол. для того чтобы посмотреть 
содержимое папки нам ls можно вобще не использовать.
мы можем заюзать echo 

    $ echo .* *
    . .. .1 .123.456 ..17.txt .234 .23.txt 12 123 124 13 1.txt 2.txt 5 a1 a.123 ab ac a.txt dir1 dir2

единственная проблема в том что если файлов в папке много
то как я понимаю у баш есть ограничение на количество 
аргументов которые он может использовать при запуске внешней прогарммы.
и будет ошибка переполнения.
потому что globbing работает вот так еще раз подчеркну
    $ strace -e execve echo .* *
    execve("/bin/echo", ["echo", ".", "..", ".1", ".123.456", "..17.txt", ".234", 
    ".23.txt", "12", "123", "124", "13", "1.txt", "2.txt", "5", "a1", 
    "a.123", "ab", "ac", "a.txt", "dir1", "dir2"]
тоесть в данном случае в папке было не так много файлов и нам хватилло
их вставить как аргументы. а если бы файлов было 100 000 то был бы пиздец с ошибкой
"Argument list too long"



| 0x00
| \0
| null byte


кстати на счет 0x00 его спецсимвол это \0
    $ echo -en "\0" | od -t x1
    0000000 00 

    $ printf "\0" | od -t x1
    0000000 00

причем нетолько xargs может работат с 0x00 как разделитель слов
но и sort
    $ xargs -0
    $ sort -z
прикольно


| glob
| globbing

прдолжаю про глоббинг
и говорю о том что обычно пишут что баш
подставлеяет файлы\папки из текущией папки. 
но это не совсем так.
если подсвить путь к папке то баш покажет файл\ппаки из указанной папки
пример
    $ pwd
    /home/vasya/temp/!14
    $ echo *
    !15 proj1 proj2
    $ echo ../\!13/*
    ../!13/1 ../!13/12 ../!13/123 ../!13/123.txt ../!13/12.txt ../!13/13 ../!13/13.txt
    $ ls ../\!13
    1  12  123  123.txt  12.txt  13  13.txt


далее если закончить имя файла слешем "/"
то баш (через глоббинг) подставит только папки. а файлы неподставит

    $ ls
    '!15'  'ab cd'   proj1   proj2

    $ echo */
    !15/ proj1/ proj2/


кстати я узнал как использовать глоббинг через printf

    $ printf "%s \n"  *
    !15 
    ab cd 
    proj1 
    proj2 


также глобинг работает в [[ ]]
это кстати хороший пример как находить субстринг в стринге
    $ a="some Error is found"
    $ [[ "$a" = *[Ee]rror* ]]; echo $?
    0
а в [] уже нет
    $ [ "$a" = *[Ee]rror* ]; echo $?
    1

еще глоббинг работает в обрезке переменных
этот пример удаляет из переменной  
кусок от самого начала до последнего слэша
и все символы за ним
в итоге будет вырезано все
    $ echo $a
    /home/vasya/temp/!14
    $ echo ${a##/*}

вырезаю первые два символа
    $ echo ${a#??}
    ome/vasya/temp/!14

следущий пример находит 
с конца первый слеш и удаляет 
этот слеш и все что после него
    $ echo ${a%/*}
    /home/vasya/temp

далее. есть у баша опция которая позволяет
активировать расширенный глоббинг.
проверяем активирована она вот так

    $ shopt | grep extglob
    extglob        	on

если что актиивируем эту фичу вот так

    $ shopt -s extglob

тогда начинает работать вот такая хрень

    ?(pattern-list)
    Matches zero or one occurrence of the given patterns.

    *(pattern-list)
    Matches zero or more occurrences of the given patterns.

    +(pattern-list)
    Matches one or more occurrences of the given patterns.

    @(pattern-list)
    Matches one of the given patterns.

    !(pattern-list)
    Matches anything except one of the given patterns.

на счет паттерн лист который внутри () надо сказать 
что если мы туда вставим буквы то они так буквально 
будут и воспринматься. ни о каком множестве речи не идет
тоесть

    $ echo +(ab)123.txt
    abab123.txt

слдущий пример это подчеркивает тоесть
(a-c) означает именно "a-c" а не множество [a-c]
    $ echo +(a-c).txt
    a-c.txt

 
пример

    $ echo +(abc)123.txt
    abcabc123.txt

еще пример
    $ echo +(abc)?*+(abc)*
    abc123abc.txt
    
еще пример
    $ echo !(*.txt)
    !15 ab cd proj1 proj2

если отключить extglob то эти паттерны реально нихрнеа
не работают

    $ shopt -u extglob
    $ echo !(*.txt)
    bash: !: event not found


теперь переходим на множества
для начала множества которые
мы сами определяем руками [a-z]
    $ echo +([a-z])?([0-9])
    a1 ab ac dir1 dir2

    $ echo +([a-z])?([0-9])*(.txt)
    a1 ab ac a.txt dir1 dir2


теперь пеерейдем к множествам
которые предопределены

    $ echo +([[:lower:]])
    ab ac

далее пример с обрезкой переменной
    $ echo ${a##+([a-c])}
    123

    $ echo ${a##+([[:lower:]])}
    123

ксати вот эти продвинутые глобы они позволяют нам
OR вставлять в паттерны через знак пайпа
пример
найти файл  у котрого первые две 
буквы это либо "ab" либо "12"
$ echo +(ab|12)*
    12 123 124 ab abab123.txt
ну а можно ли вставлять OR на простых глобах
я не знаю. у меня не получается

    $ echo ([ab]|[12])*
    bash: syntax error near unexpected token `[ab]'
    $ echo [ab]|[12]*
    12: command not found


exteded глоббиинг внутри [[]]
    $ a="banana"
    $ [[ "$a" = @(ba+(na)|a+(p)le) ]]; echo $?
    0
    
    $ a="apple"
    $ [[ "$a" = @(ba+(na)|a+(p)le) ]]; echo $?
    0


и тут я хочу скзаать одну очень важную вещь
вот у нас есть форму extended глоббинга

  ?(pattern-list)
    Matches zero or one occurrence of the given patterns.

    *(pattern-list)
    Matches zero or more occurrences of the given patterns.

    +(pattern-list)
    Matches one or more occurrences of the given patterns.

    @(pattern-list)
    Matches one of the given patterns.

    !(pattern-list)
    Matches anything except one of the given patterns.

    
тоесть это выгляит на пратике вот так

    $ команда ?(.....)
    $ команда *(.....)
    $ команда +(.....)
    $ команда @(.....)
    $ команда !(.....)
   
или с конкретной командой echo

    $ echo ?(.....)
    $ echo *(.....)
    $ echo +(.....)
    $ echo @(.....)
    $ echo !(.....)
   
   
и тут я хочу обратить нвимние на очень важгную вещь.
с которй оможно спутать ext глоббинг.
первая вещь это субщелл (.....)
так вот перед субшеллом обязатено должен стоять только пробел
и больше ничего. ну или еще знак $ то есть
    $ ( echo 1 )
    $ echo $( echo 1)
тоесть если мы видим скобки (....) и нам понять это субшелл
или ext глоббинг нужно внимательно посмотеть на первый символ перед скобкой.
если это 
    ?(   
    *(
    +(
    @(
    !(
то это external глоббинг а не субшелл

также хочу обратить внимание на ! по дефолту это символ обозначающий
bash history, но он является баш хистори толко если за ним идет цифра

    $ echo !1
    echo git add .
    git add .

если же за ! идет ( то это ext глоббинг.!
поэтому чтобы не спутать надо это все понимать различать.

еще один случай когда применяются скобки это обьявление переменной
а точнее массива!

    $ w=(1 2 3)
    $ echo ${w[*]}
    1 2 3

тоесть в этом случае (....) это ни субшелл ни ext глоббинг
а обьявление массива.
это пиздец.

кстати если мы хотим заранее сообщить башу что наша переменная будет 
массивом то это можно сделать вот так
    $ declare -a w
    $ w=(1 2 3)
    $ echo ${w[*]}

ксати можно совместить обьявление типа переенной и ее инициалиацию

    $ declare -a w=(2 3 4)
    $ echo ${w[*]}
    2 3 4

также при обявлении массива можно скобки обрамить кавычками

    $ declare -a w='(5 6 7)'
    $ echo ${w[*]}
    5 6 7

при этом еси внутри массива мы навставляем переменных то  
одинакрные кавычки не помешают башу успешно эти переменные подставить

    $ a="1"
    $ b="2"
    $ c='3'
    $ declare -a d='( $a $b $c $d)'
    $ echo ${d[*]}
    1 2 3

а теперь вишня на торте - внутрь массива при его определнеии 
вместо переменных можно подставить глоббинг!! и ext глоббинг тоже !!

    $ ls
    01.txt  02.txt  03.txt  04.txt  05.txt  06.txt  07.txt  a1

    $ echo [[:alnum:]]*.txt
    01.txt 02.txt 03.txt 04.txt 05.txt 06.txt 07.txt

подставляем в массив имена файлов через глобинг
    $ declare -a d='( [[:alnum:]]*.txt   )'

    $ echo ${d[*]}
    01.txt 02.txt 03.txt 04.txt 05.txt 06.txt 07.txt

    
    $ echo +([[:alnum:]]).txt
    01.txt 02.txt 03.txt 04.txt 05.txt 06.txt 07.txt

подсталяем в массив через ext глоббинг
внешняя ( ) это обьявление массива
внутренняя +() это ext глоббинг
    $ declare -a d='( +([[:alnum:]]).txt   )'

    $ echo ${d[*]}
    01.txt 02.txt 03.txt 04.txt 05.txt 06.txt 07.txt

еще пример
    $ echo !(x)
    01.txt 02.txt 03.txt 04.txt 05.txt 06.txt 07.txt a1

подставляем внутр массива имена файлов через ext глоббинг
внешняя () это обявление массива
внутрненняя () это ext глоббиинг
    $ declare -a d='(  !(x)   )'

    $ echo ${d[*]}
    01.txt 02.txt 03.txt 04.txt 05.txt 06.txt 07.txt a1

когда смотришь d='(  !(x)   )'  думаешь что это за хуйня?????!?
а размышлять нужно так скобка это либо обьявление массива, либо ext глоблиинг,
либо субшелл. это неможет быть субшеллом потому что слева нет $ или знака пробел.
ext глоббингом тоже не может быть потому что слева нет ? ! * + @
зато есть = значит это обьявление массива. и точно. остается хрень внутри !(x)
если бы это был bash history то после ! должна стоять цифра. значит не подходит.
и так как это !( то это значит что это ext глоббинг. пиздец.
итого получается 
у нас обьявляется массив d внутри которого стоят элементы названия файлов которые
ищутся по маске "файлы с любыми символами в имени кроме файлов с точкой вначале
и кроме файла с именем 'x' ". это пиздец

кстати bash history в качестве элементов массива не подставляется
    $ declare -a d='(  !1   )'
    $ echo ${d[*]}
    !1

точнее подставляется но тогда нужно '' убрать на скобках
    $ declare -a d=(  !1   )
    declare -a d=(  git add .   )
    $ echo ${d[*]}
    git add .

это пиздец с этимбашем

с двойными " тоже рабтает
    $ declare -a d="(  !1   )"
    declare -a d="(  git add .   )"
    $ echo ${d[*]}
    git add .

    
кстати массив можно обьявить еще вот так
    $ e=()
а элементы в него запихнуть потом вот так
    $ e[0]='vasya'
    $ e[1]='petya'
    $ echo ${e[*]}
    vasya petya

если мы просто запустиим echo он нам напечатает нулеовй
элмент массива
    $ echo $e
    vasya

как присоединиить к концу массива +1 элемент
    $ e+=("kuku")
    $ echo ${e[*]}
    vasya petya kuku

напечатать массив индексов элементов
    $ echo ${!e[*]}
    0 1 2

я уже знаю как посчитать длинну стринга
    $ t='446'
    $ echo ${#t}
    3
а вот так можно посчитать длинну масива
    $ echo ${e[*]}
    vasya petya kuku
    $ echo ${#e[*]}
    3

    
кстати в простую перменную глоббинг не подставляется
    $ a=!(x)
    $ echo "$a"
    !(x)
    $ a=*
    $ echo "$a"
    *

в массив можно засунуть вывод от команды
    $ declare -a a
    $ a=( $(ls) )

    $ echo "${a[*]}"
    2.txt 3.base64 dec.txt

или вместо declare
    $ b=()
    $ b=( $(ls) )
    
    $ echo "${b[*]}"
    2.txt 3.base64 dec.txt

если просто ls то это всего лишь будет как литера
    $ b=( ls )
    $ echo "${b[*]}"
    ls

если $ls это будет как значение необьявленной переменной

    $ b=( $ls )
    $ echo "${b[*]}"

далее про nullglob
если эта опция выключена и у нас идет глоб
и у нас не находятся файлы удовлетворяющие глоб
то баш подставляет во внешнюю команду
тупо сам шаблон. пример у меня в текущей
папке нет *.c файлов  и вот что присходит
баш тупо подставляет напрую *.c при вызоыве
ls
    $ strace -e execve ls *.c
    execve("/bin/ls", ["ls", "*.c"], 0x7fff3a4aac38 /* 70 vars */) =

обалдеть
именно поэтому ls выдает ошибку что файла с таким именем 
он не может найти

    $ ls *.c
    ls: cannot access '*.c': No such file or directory


так вот если активировать nullglob то если баш ненеаходит
через глоб нихуя то он просто напросто уничтожает этот аргумент
как бутто его и небыло

    $ shopt -s nullglob
    $ strace -e execve ls *.c
    execve("/bin/ls", ["ls"], 0x7ffe7de4b000 /* 
    
    
прикольно. по дефолту nullglob дезактивирован

еще пример globbing
я запоминаю в переменную er массив,
элемнетами массива является подставленное башем 
список файлов из текущей папки по маске *
    $ er=( * )

тогда можно вот таким макаром посчитать 
количество файлов в текущей папке

    $ echo "${er[*]}"
    2.txt 3.base64 3.bash 6 dec.txt
    $ echo "${#er[*]}"
    5


кстати а что будет если посчиать длинну пустого массива
    $ rt=()
    $ echo "${#rt[*]}"
    0


напоминаю такую штуку то что если башу неполучается
раскрыть glob то он вызывает внешнюю команду 
и подставляет туда наш glob шаблон без раскрытия 
так как он есть
это же касается и случая когда мы подставляем  glob
в массив. пример

    $ ls *.c
    ls: cannot access '*.c': No such file or directory

    $ tt=( *.c )
    $ echo ${tt[*]}
    *.c

тоесть если файлов *.c нет то 
    $ ls *.c
превращается самим башем в 
    $ ls "*.c"

тоже самое касается когда мы испольщуем glob
внутри массива. если файлов нет то вместо кучи файлов в массив
вместо элементов вставляется буквально сама маска как если бы она была
в кавычках

еще раз повторю пример
    $ tt=( *.c )
так как таких файлов нет то баш 
переделает команду в 
    $ tt=( "*.c" )
поэтому массив будет состоять 
из одного элемента "*.c"
    $ echo ${tt[*]}
    *.c
и поэтому длинна этого массива будет 1

итак еще раз если шаблон glob невыпоняется тоесть таких файлов 
нет то баш вместо файлов которых нет подставляет просто 
буквально сам шаблон как элемент
так вот если установлен nullglob то в случае отсуствия файлов по шаблону
то баш не подставляет сам шаблон.он неподставляет тогда нихрена
тоесть 

    $ shopt -s nullglob
    $ tu=( * )
    $ echo ${tu[*]}

    $ echo ${#tu[*]}
    0

итак еще раз если nullglob неустановлен то 
в случае осуствия файлов баш  подставит сам шаблон

    $ shopt -u nullglob
    $ tu=( * )
    $ echo ${tu[*]}
    *
    $ echo ${#tu[*]}
    1

а если nullglob устанолвен то 

    $ shopt -s nullglob
    $ tu=( * )
    $ echo ${tu[*]}

    $ echo ${#tu[*]}
    0

в целом последний пример
можно использовать для того чтобы
посчитать сколько файлов в папке
но будет коректно работать если 
папка непустая, а если папка пустая 
то чтобы коректно считало что 
число файлов ноль должен быть установлен 
nullglob 

а вот пример с for
вначале вообще несвязанный  с nullglob
если мы возьмем массив непустой то for 
конечно отработает со всеми элементами

    $ a=( 1 2 3 )
    $ for i in ${a[@]}; do echo "$i"; done
    1
    2
    3

а если мы возьмем массив пустой 
то for ниразу неотработает

    $ a=()
    $ for i in ${a[@]}; do echo "$i"; done

теперь мы будем в $a пихать файлы через glob
и наша задача чтобы если шаблон глоба невыполнился 
тоесть нет ни одного файла соотвествующего шаблона
то чтобы и цикл ниразу не выполнился. 
вначале запускаем с nullgobe неустановленным

    $ shopt -u nullglob
    $ a=( *.c  )
    $ for i in ${a[@]}; do echo "$i"; done
    *.c

а теперь актиивируем nullglobe

    $ shopt -s nullglob
    $ a=( *.c  )
    $ for i in ${a[@]}; do echo "$i"; done

логика понятно. в первом случае a=( "*.c" )
а во втором случае a=()

а вот еще пример глоббинга

    $ for i in *; do echo "$i"; done
    2.txt
    3.base64
    3.bash


далее скрипт
он вызывает функцию в которую 
в качестве аргументов баш через глоббинг 
подставляет файлы из текущей папки
а функция проверяет что существует 
файл с именем которое содержится
в $1. где в $1 будет содержаться
файл первый из списка если
запустить команду ls

    $ cat 4.bash 
    #!/bin/bash

    f () {

        [ -e "$1" ] || return 1

    }


    f * || echo "file not found"


следующая опция dotglob
что она дает.
если она отключена то чтобы мы словили 
файлы с точками вначале имени файла
то нужно использовать паттерн .*
потому что любой другой паттерн наприер *
он файлы с точками не словит

    $ shopt -u dotglob
обычный паттерн * неловит
    $ echo *
    a.txt b.txt dir1
только спец паттерн .* ловит
    $ echo .*
    . .. .w.txt

    
    $ shopt -s dotglob
теперь обычный паттерн * ловит файлы с точками
однако заметим что при  этом файлы "."
и ".." автоматом не включаются в этот список
    $ echo *
    a.txt b.txt dir1 .w.txt
тоесть видно что шаблон * словил файл .w.txt
но при этом не словил ".", ".."
    
этот паттерн по прежнему ловит 
все файлы  с точками в том числе и "." и ".."
    $ echo .*
    . .. .w.txt
спец паттерн тоже ловит
    $ echo *.txt
    a.txt b.txt .w.txt






следующая опция globstar
если ее активировать она
дает вот что. если мы юзаем при этом шаблон **
то тогда баш выбирает нетолько файлы в текущей
папке но и во всех подпаках текущей папки

содержимое папки
где a.txt и b.txt это файл
а dir1 это папка
    $ ls -a
    .  ..  a.txt  b.txt  dir1

при отключенной опции globstar
шаблон ** аналогичен шаблону *
    $ shopt | grep globs
    globstar       	off

    $ echo **
    a.txt b.txt dir1

при активироанной опции globstar
шаблон ** выбирает также
все подпаки и все подфайлы текущей папки
    $ shopt -s globstar
    $ echo **
    a.txt b.txt dir1 dir1/1.txt dir1/2.txt dir1/dir2 dir1/dir2/dir1.txt dir1/dir2/dir3 dir1/dir2/dir3/4.txt

    
как найти все файлы *.txt в текущей папке и во всех ее подпапках
    $ echo **/*.txt
    a.txt b.txt dir1/1.txt dir1/2.txt dir1/dir2/dir1.txt dir1/dir2/dir3/4.txt


далее по умполчанию если баш на glob запрос ненаходит
ни одного файла\папки то он как я уже сказал выше 
подставляет во внешнюю команду вместо глоба его string аналог
тоесть

    $ ls *.c
превращается в 
    $ ls "*.c"
и тогда это уже  забота внешней программы
как она интепретиурет этот аргумент.
прмиеры

    $ ls *.c  ==> ls "*.c"
ls: cannot access '*.c': No such file or directory

    $ echo *.c  ==> echo "*.c"
    *.c

а если мы активируем опцию failglob
то если баш ненаходит ни одного файла\папки
соотвествующей паатерну то сам баш прекращает работу
и генерирует 
ошибку

    $ ls *.c
    bash: no match: *.c

    $ echo *.c
    bash: no match: *.c

    $ a=( *.c )
    bash: no match: *.c

    
по моему это самая правильная натройка для обработки глобов.
потому что мы тогда четко должны понимать что и как мы подставляем
в команду. если мы хотим чтобы баш передал внешней 
команде некий  стринг то мы будем обязаны
его заключить в кавычки чтобы этот стринг не рассматривался как глоб
а рассматривался просто как стринг "*.c" 
а если мы хотим чтобы баш перед выполненеим внешней команды
подставил в качестве аргумента имена каких то файлов и папок 
то мы используем globbing но если при этом баш не найдет ни одного
файла\папким соотвествующей этому глобингу то он прекращает свою 
работу даже не пытаясь запустить внешнюю команду. и генерирует
понятную ошибку об этом на экране
по моему это очень логичное поведение. 
без этой настройки  у нас глобинг работат очень диковинно.
мы говорим башу : свари борщ но перед этим сходи на рынок
и купи продукты по списку. баш идет на рынок. продуктов 
не находит но все равно пытается сварить борщ.

далее.
можно задать в переменной $GLOBIGNORE паттерн glob
файлы и папки которые соотвествуют это шаблону
они автоматом будут исключаться из финального списка
котоырй баш подставляет уже в строку аргументов
при вызоыве внешней команды.
тоесть мы пишем в баше
    $ echo *.txt
баш сканирует текущую папку на имена файлов\папок
с таким шаблном имени. далее баш смотрит какой шаблон
указан в GLOBIGNORE и исключает этот щаблон из найденного
списока файлов. также как толькло мы вбиваем какото шаблон
в GLOBIGNORE то автоматом активиуется опция dotglobe!
которая дает то что обычный шаблон также ловит и файлы 
начинающие на точку но при этом исключает файлы
"." и ".."
замечу еще раз что внезаивисимости от того какие 
шаблоны указаны в $GLOBIGNORE автоматом 
активируется исключение двух файлов "." и ".."
и автоматом актиивируется забор файлов с точками 
при условии что это подпадает под шаблон указанный 
в команде баша
показываю на примерах
тоесть есть файлы с точками
    $ ls -a
    .  ..  .3.c  a.txt  b.txt  dir1  .w.txt

исключаем из выборки файлы *.txt
    $ echo $GLOBIGNORE
    *.txt

задаем выборку всех файлов что есть в папке
через *
при активация globignore активирует захват файлов 
с точками и исключает захват двух конкретных файлов
".", ".."

    $ echo *
    .3.c dir1


проверяем что установление GLOBIGNORE
автоматом активиуерует опцию dotglobe

    $ shopt | grep dotglob
    dotglob        	on


также интерсно то что баш все еще развиватеся. 
скажем в убунту 18 это версия 4.* а убунту 22 это уже версия 5.*


немного отойду в стороны.
хочу понять если внутри функции идет обращение к 
перееной которая указана в главном теле. 
то это обращение поменяет переенную в главном теле или нет?

    $ cat f.bash 
    #!/bin/bash

    # тело функции
    f () {

        a=10
        local b
        b=10
    }

    # главное тело
    a=1
    b=1

    f

    echo "a=$a"
    echo "b=$b"

запускаем скрипт
    $ ./f.bash 
    a=10
    b=1

получается по дефолту обращение к переенной
которая есть в главном теле из функции ее меняет.
а если мы хотим завести локальну перменную в функции
то надо юзать local


далее напомню такую штуку.
если у нас есть скрипт. 
это обяазтеально. вне скрипта это нерабоатет
так вот цикл for в виде

    for i;do ...;done
это эквивалент
    for i in @; do ... ; done
    
пример

    $ cat sc.bash 
    #!/bin/bash

    for f
    do
        echo "файл=$f"
    done

    $ ./sc.bash 1.txt 2.txt
    файл=1.txt
    файл=2.txt


кстати эта же  хрень с for  работает 
и для for внутри функции. но функция опять же 
в основном задеся в скриптах нежели чем в командной тсроке

далее кстати что на счет 
разницы между "=" и "==" внутри квадратных скобок
оказвается это одно и тоже внутри квадратный скобок
неважно одинакрные двойные. и эта штука исползуется
для того чтобы сравниваь стринги между собой.
как пишет интернет "==" это чисто башовская тема
а "=" это более общий синтаксис соотвствующий POSIX

    $ [ "a" == "a" ]; echo $?
    0
    $ [[ "a" = "a" ]]; echo $?
    0

для сравнения чисел использовать нужно 
например -eq (equal) тогда он сравнивает
то что слева и справа как числа.
    ( https://stackoverflow.com/questions/20449543/shell-equality-operators-eq )

    
еще один важный момент
скобки и глоббинг
начнем с одинакрной квадратнйо скобки

    $ ls
    ab.c  AB.c  a.txt  bc.c  b.txt  dir1  f.bash  f.c  r.d  sc.bash

когда у нас резулттатом выборки явялется один файл то все 
заедись работает
    $ [ "r.d" == *.d ]; echo $?
    0

а когда у нас в выборке уже два и более файлов то 
уже нихрена неработает. не просто нерабоате
а вылезает ошриька
    $ [ "1.bash" == *.bash ]; echo $?
    bash: [: too many arguments
    2

а вот с двойной скобкой все раобтает даже
если глоббинг выдает более чем один файл

    $ echo *.c
    ab.c AB.c bc.c f.c

    $ [[ "ab.c" == *.c ]]; echo $?
    0
    $ [[ "AB.c" == *.c ]]; echo $?
    0
    $ [[ "bc.c" == *.c ]]; echo $?
    0
    $ [[ "f.c" == *.c ]]; echo $?
    0

тоесть по идее *.c  выдает  массив.
получаетя слева у нас стоит стринг 
а справа у нас стоит массив. 
и получаается что [[ "переменная" = "массив" ]]
и получается что [[  ]] умеет искать то слева как элемента
в массиве справа.

при том что такая хрень работает тоолько с глобингом. если справа
подставить массив то [[ ]] в нем поиск не ведет

    $ a=( "1.txt" "2.txt" "3.txt" )
вот эта строка срабатывает потому что 
в если у нас переменная это массив то $a подразумевает ${a[0]}
    $ [[ "1.txt" == "$a" ]]; echo $?
    0

а дальше уже ничего несрабатыает
    $ [[ "2.txt" == "$a" ]]; echo $?
    1

    $ [[ "2.txt" == "${a[*]}" ]]; echo $?
    1

    $ [[ "2.txt" == "${a[@]}" ]]; echo $?
    1

    
а в случае когда справа глоббинг то все сработает
    $ ls
    1.txt  2.txt  3.txt

    $ [[ "1.txt" == *.txt ]];echo $?
    0

    $ [[ "2.txt" == *.txt ]];echo $?
    0

    $ [[ "3.txt" == *.txt ]];echo $?
    0


получается конструкция 
    [[ "..." = glob ]]
аналогична поиску в массиве
а не просто сравнению стринга слева и справа где
стринг подставлявется из имен файлов
    $ ls
    1.txt  2.txt  3.txt

    $ a="неуспех"; for  i in *; \
                   do if [ "2.txt" == "$i" ]; \
                   then a="успех"; break; fi; done; echo "$a"
    успех


кстати break позволяет выйти из for , после break можно поставить
число и оно покажет сколько вложенных циклов ты хочешь разорвать.
если цикл один то break 1, если циклов 2 то break 2
вот пример когда break 2 останаливает два вложенных цикла

    $ for i in $(seq 10); do for j in $(seq 10); \
        do  if [ "$i" -eq 5  -a "$j" -eq 5 ]; \
        then echo "i=$i, j=$j"; break 2;else echo "i=$i, j=$j";\
        fi; \
        done; \
        done
  
i=1, j=1
i=1, j=2
i=1, j=3
i=1, j=4
i=1, j=5
i=1, j=6
i=1, j=7
i=1, j=8
i=1, j=9
i=1, j=10
i=2, j=1
i=2, j=2
i=2, j=3
i=2, j=4
i=2, j=5
i=2, j=6
i=2, j=7
i=2, j=8
i=2, j=9
i=2, j=10
i=3, j=1
i=3, j=2
i=3, j=3
i=3, j=4
i=3, j=5
i=3, j=6
i=3, j=7
i=3, j=8
i=3, j=9
i=3, j=10
i=4, j=1
i=4, j=2
i=4, j=3
i=4, j=4
i=4, j=5
i=4, j=6
i=4, j=7
i=4, j=8
i=4, j=9
i=4, j=10
i=5, j=1
i=5, j=2
i=5, j=3
i=5, j=4
i=5, j=5

    

    


далее . хочу показать что простой глоббинг
и extended глоббиннг моожно сочетать в одном месте
пример
    $ ls
    1.txt  2.txt  3.txt

    $ echo [1-3].@(txt)
    1.txt 2.txt 3.txt

тоесть [1-3]. это обычный глобинг 
а @(txt) это ext глобинг
кстати в чем фишка ext глобинг это то
что там можно юзать OR через |

    $ echo [1-3].@(txt|c)
    1.c 1.txt 2.c 2.txt 3.c 3.txt


    
    

    
далее опция nocasematch
она дает то что внутри case или внутри [[ ... ]] 
срававнении мелкие 
и большие буквы счиаются одинакоаыми

    $ shopt -u nocasematch
    $ [[ "ab" = "AB" ]]; echo $?
    1

    $ shopt -s nocasematch
    $ [[ "ab" = "AB" ]]; echo $?
    0

также эта хрень работает для глоббинга но опять же
внутри [[ ]] или case

    $ ls
    ab.c  AB.c  a.txt  bc.c  b.txt  dir1  f.bash  f.c  r.d  sc.bash

при отключенном nocasematch
    $ shopt -u nocasematch
    $ [[ 'f.BASH' ==  *.bash ]]; echo $?
    1

при включенном nocasematch
    $ shopt -s nocasematch
    $ [[ 'f.BASH' ==  *.bash ]]; echo $?
    0

значит тут я поясню что я понял из практики что если в [[ ]]
стоит глобинг то резултат то глобинга это дохрена имен файлов
а слева то у нас стоит одно имя файла. так вот внутри [[ ]]
баш делает проверку стринга слева со всеми файлами который выдает глобинг
и если находит равенство с одним из файлов то скобка возвращает успех
тоесть *.bash возвращает f.bash sc.bash
и баш ищет в этой строке  есть ли в ней вхождение 'f.BASH
считай что он ее как бы грепает.тоесть не идет тут сравнение 
стринга слева 'f.bash' и стринга справа 'f.bash sc.bash'
а именно баш грепает точто справа на наличие того что указано слева.
так вот опция nocasematch дает то что игнорриууется большие буквы или маленькие
буквы.

тоест я бы сказал что аналогом команды
    $ [[ 'f.BASH' ==  *.bash ]]; echo $?
является команда 
    $ echo "f.bash sc.bash" | grep -i "f.BASH" 1>/dev/null; echo $?
    0

а вот пример похожей хрени на примере скрипта и функции

$ cat 23.bash 
#!/bin/bash


f() {

local ncs

shopt -q nocasematch && ncs=1 || ncs=0

(( ncs )) || shopt -s nocasematch


for i
do 
    [[ "$i" == * ]] && echo "такой файл есть!"
done

(( ncs )) || shopt -u nocasematch

}


echo "список файлов в папке  => "  *
a="1.BASH"
echo "искомый файл = $a"

f "$a"


$ ./23.bash 
список файлов в папке  =>  1.c 1.txt 23.bash 2.c 2.txt 3.c 3.txt
искомый файл = 1.BASH
такой файл есть!


единственное что  я не пойму почему вот такой пример
приводит к коду возврата TRUE

    $ ls
    1.c  1.txt  23.bash  2.c  2.txt  3.c  3.txt

    $ [[ 'f.BASH' ==  *  ]]; echo $?
    0

тоесть какого хрена. и файла f.BASH ни файла f.bash нет 
в папке. 

непонимаю
почему [[ ]] показывает показывает что
в папке есть файл 2.txt или 3.txt
это ж полная хуйня
    $ shopt | grep match
    nocasematch    	off

    $ ls
    1.txt  2.TXT

    $ echo *.@(txt)
    1.txt

    $ [[ "2.txt"  == *.@(txt) ]]; echo $?
    0

    $ [[ "3.txt"  == *.@(txt) ]]; echo $?
    0

при этом
    $ [[ "2.txt"  == "1.txt" ]]; echo $?
    1
    $ [[ "3.txt"  == "1.txt" ]]; echo $?
    1


двигаю дальше
примерчик
    $ [[ $f = *.[Tt][Xx][Tt] ]] || [[ $f = *.[Jj][Pp][Gg] ]]
    

далее про continue
эта хрень перескакивает и запускает следущий цикл в for

    $ for i in $(seq 10); do (( "$i" & 1 )) && continue; echo "i=$i,чет"; done
    i=2,чет
    i=4,чет
    i=6,чет
    i=8,чет
    i=10,чет


еще приколный пример. оказыается внутри ext глобинг
можжно указывать шаблоны на основе обычного глобинга

    $ ls
    1.txt  2.TXT  3.tZt

    $ echo  ?.@(t?t)
    1.txt 3.tZt

    
еще пример
очень интересный
в нем видно что внутри ext globing
можно юзать вложенный ext globing
    $ ls
    1.txt  2.TXT  3.tZt  4.jpg  5.jpeg  6.jpg  7.jpG

    $ echo [0-9].@(jp?([eE])g)
    4.jpg 5.jpeg 6.jpg


следущая оция nocaseglob
она дает то что при глобинге
у нас неучиыавается маленькая или большая
буква. типа это одно и тоже.

    $ shopt | grep nocaseglob
    nocaseglob     	off
    $ echo *.jpg
    4.jpg 6.jpg

    $ shopt -s nocaseglob
    $ echo *.jpg
    4.jpg 6.jpg 7.JPG

для сравнения nocasemath рабоатает только
внутри [[]] и case
( до хрена того что я выше обсуждал я взял отсюда https://mywiki.wooledge.org/BashFAQ )






далее.
проверка разного рода типов файлов
файлы бывают по типу: (нашелл в man find)

              b      block (buffered) special

              c      character (unbuffered) special

              d      directory

              p      named pipe (FIFO)

              f      regular file

              l      symbolic  link;  

              s      socket

блочное устройство - это диски
символьное устройство - это tty к примеру
сокет - это файл через который идет связь по сети с другиими процессами
на других компах

в оббщем вылезает важный вопрос чем отличается блочный файл от символьного?
во первых это файлы. поэтому как и открытие обычного файла они поддерживают 
операции чтения записи итп.  тоесть для процесса в любом случае чтение запись 
идет в файловый дескриптор который появляется у процесса после открытия файла.

значит и символьный файл и блочный файл они ведут к определенному драйверу
в ядре которй обслуживает запросы на чтение и запись в эти файлы. 
разница и нюансы этих двух типов файлов состоят вот в чем. 
если мы открыли файл блочный то читать из него и писать в него можно только кусками 
байтов определенного минимального размера. тоесть с диска скаже можно считать
только кусок размером 4КБ. но никак не меньше. тоже самое минимальный размер 
куска записи 4КБ. если же мы открыли символниый файл то в него можно читать и писать
в минимальном размере по 1 байту. блочные файлы обычно обслуживают разного
рода накопители. обычно если мы работаем с блочным файлом то после его
открытия  у него рабтает такаая функция как seek то есть можно по файлу можно 
путешествовать задавая оффсет внутри файла. и оттуда читать. тоесть можно 
читать блочки байтов с произвольных мест внутри такого файла. символьные
файлы обычно не позволяют рандомный доступ внутри такого файла. но 
есть и те которые позволяют. зависит от устройства которое прячется за 
символным файлом и его драйвером. еще часто пишут что при записи и вроде
и при чтении в блочный файл это хрень работает только через промежуточный буфер.
тоесть мы пишем в блочный файл но запись идет не нустройство при этом а в буфер.
а уже после буфера когда то там идет уже на устройство. якобы когда мы
пишем в символный файл то якобы запись идет сразу на устройство без всяких там
промежуточных буферов в памяти. запис в буфер приводит к тому что если мы
сделали две записи по вермени мы незнаем какая из них попадет на устройство 
в итоге первымм по времеи а какая вторым. 

ввобще же в интернете есть ряд статей в которых несколько по разному 
обьясняется в чем же разница между символным файлом и блочным. нет единого
мненеия.

пытаюсь подвести итог про их разницу. из блочного файла можно читать\писать 
только блоками байтов. предопреедленного размера.  чтение\запись из
символьного файла позволяет это делать отдельнымы байтами. тоесть названия 
ебанутые на саамом деле. я бы назвал что это не символьные и блочные файлы а 
однобайтовые и многобайтовые файлы. 
втторое отличие в том что запись в блочный файл проходит через посредник
через буфер в памяти. на счет чтения не уверен. возможно тоже через этот посредник.
у смивольного файла нет такого посреденика. запись идет сразу на железку.
буфер приводит к тому что если мы с точки зрения программы сдеали сисколл на запись 
то он возвращается уже к нащей программе тогда когда данные упалр в буфер. и наша 
программа уже думает что данные на диске. а они еще в буфере. а из буфера они 
попадут на диск хрен знает когда. когда это захочет ос. хотя можнно открыать
файл на запис с флагом O_DIRECT который это дело улучшает хотя бы отчасти.
также это приводит  к тому что если было два запроса на запись по времени.
то не факт что первая запись действительно упадет на диск первой.

бывают приводят еще одно свойство мол только блочноый файл предоставляет 
возможность задвать оффсет внутри файлаи таким образом хотя бы и блоками 
но чиать и писать в любое место в таком файле. но как  я нашел бывваают инггда
и символные файлы кооторые такое позволяют. но это скорее исключение. 

у символьных и блочных файлов есть два числа мажор минор которые вот что обозначают.
мажор число обозначает драйвер ядра который будет обслуживать запросы на чтение
запись в этот файл. минор означает порядоквый номер внутри одного драйвера
чтобы отличать запросы от разных файлов в рамках одного драйвера.

при загрузке эти файлы создает udev
их также можно создать руками через mknod

еединственное что мне непонятно это то как при создании руками 
скажем блочного файла как ядро понимает к какой физ железке его нужно 
прикрепить. докучи говоря  если мы создадим +1 блочное устройство
это же не привдете к тому что в ноутбуке вырастет +1 жесткий диск если
его там просто нет. пример 

вот у меня есть nvme диск на компе реально
    # ls -l /dev/nvme*
    crw------- 1 root root 240, 0 окт 11 22:09 /dev/nvme0

видно что его обслуживает драйвер с номером 240.
порядковый номер конкретно моего диска внутри этого драйвера это 0.
я создаю +1 устройство с таким же драйвером и порядковым номером 1
кстати можно заметить что тип файла символьный

    # mknod ./nvme1 c 240 1

    # ls -l ./nvme1
    crw-r--r-- 1 root root 240, 1 дек 21 00:01 ./nvme1

окей файл я создал. но диск то у меня физически на компе
не может появится из воздуха. 

а вот еще прикол что почеемуто часть файлов отвечающих 
за реальный диск символные а часть блочные. тоже непонятно

    # ls -l /dev/nvme*
    crw------- 1 root root 240, 0 окт 11 22:09 /dev/nvme0
    brw-rw---- 1 root disk 259, 0 окт 11 22:09 /dev/nvme0n1
    brw-rw---- 1 root disk 259, 1 окт 11 22:09 /dev/nvme0n1p1
    brw-rw---- 1 root disk 259, 2 окт 11 22:09 /dev/nvme0n1p2


далее
файл пайп это понятно. это буфер в памяти. запись в файл ведет
 в запист в буфер в ядре. и через этот файл процессы могут
 делать IPC
 
тип симлинк это понятно.

сокет это тоже буфер в памяти который в итоге ведет в сеть и в итоге
на другой комп в другой процесс. тоесть это типа такой пайп только 
не между процессами на одном компе а пайп между процессами на 
компах на разных компах

в итоге мы подошли  к так называемому regular file.
если файлы до этого имели смысл некоего гейтвея между юзер программой
и железкой или юзер программой на компе и другой юзер прогарммой на этом жее компе
или другом компе по сети то регуляр файл отвечает за другое - он является 
хранилищем байтов которые будет читать юзер программа чтобы либо музыку на основе
этих байтов играть, либо текст на экране рисовать, либо картинку на экране рисовать.
тоесть реегуляр файл это прямое храниилище байтов. сторадж. бекенд сторедж для 
юзерской программы. доступ  к файлу идет через драйвер ФС. и как я понимаю 
наверное драйвер ФС потом обращается к драйверу уже железки. 
тоесть этот файл неявляется ни эдеметом IPC , ни гейтвеем к железке, а чисто
являтся храниищем кучи байтов. чобы их процесс на компе прочитал чтобы потом
его както нам предоставить. в той или иной понятной для человека форме.

а в завершении скажу то что вобщем то конечный юзер с его юзер программой
нихрена не связываются с блочными или символьными файлами 
вобщем то никогда. эти файлы используют сами юзер программы как то 
там внутри сами их вызывая. юзер нигде эти файлы сам руками программам
не подсоывает в строке аргументов только за исключением случая 
коогда мы диск руками форматируем.

теперь когда подразобрались  с типами файлов 
    

теперь начинаем башем 
проверять что разные типы файлов существуют

для начала проверяем что файл вообще существует
, файл любого типа

    $  ls
    1.txt  2.TXT  3.tZt  4.jpg  5.jpeg  6.jpg  7.jpG
    $ [[  -e "1.txt" ]]; echo $? 
    0
    $ [[  -e "vasya.txt" ]]; echo $? 
    1


далее
проверяем что регуляр файл 
существует

    $ [[ -f "f.pipe" ]]; echo $?
    1
    $ [[ -f "6.jpg" ]]; echo $?
    0

а вот дальше какая то непоняная хуйня.
почему то -f показывает true
не только для простых файлов 
но и для симлинков. 
это пиздец . почему -f покаызвает
на симлинках true ?

    # ls -l
    -rw-r--r-- 1 root root 0 дек 21 01:08 1.txt
    lrwxrwxrwx 1 root root 7 дек 21 01:08 2.lnk -> ./1.txt

    # [ -f "./1.txt" ]; echo "$?"
    0
    # [ -f "./2.lnk" ]; echo "$?"
    0

    
еще раз повтор непонтный звездец.
проверка -f которая проверяет что файл обычный и он есть
выдает true для симлинка. что за бред

как линукс определяет тип файла - тип  файла записан в иноде от файла.
в зависимости от типа файла он по разному хранится на ФС.
и по  разному оббрабатывается ядром.


далее про проверку -s
которая проверяет размер файла > 0

    # echo -e "perm           размер \t имя"; \
      ls -l | 
      awk '{print $1 "\t"  $5 "\t"  $9}' | 
      tail -n +2
      
    perm           размер 	   имя
    lrwxrwxrwx	     7	      1.lnk
    -rw-rw-r--	     3	      1.txt
    -rw-rw-r--	     0	      2.TXT
    -rw-rw-r--	     0	      3.tZt
    -rw-rw-r--	     0	      4.jpg
    lrwxrwxrwx	     7	      4.lnk
    -rw-rw-r--	     0	      5.jpeg
    -rw-rw-r--	     0	      6.jpg
    -rw-rw-r--	     0	      7.jpG
    prw-rw-r--	     0	      f2.pipe
    prw-rw-r--	     0	      f.pipe



отсюда видно что файлы с ненулевым размером
это 
    1.lnk
    1.txt
    4.lnk
    
    
а теперь посмотрим что покажет -s

    # for i in *; \
    do [ -s "$i" ] && \
    printf "%-15.15s %-20.20s \n" "файл $i " "| размер > 0";\
    done

    файл 1.lnk  | размер > 0   
    файл 1.txt  | размер > 0   

или давай руками

    # [ -s "./1.lnk" ]; echo $?
    0
    
    # [ -s "./1.txt" ]; echo $?
    0
    
    # [ -s "./4.lnk" ]; echo $?
    1

    
так вот что меня и тут шокирует. есть файл 4.lnk 
размер которого не ноль. но -s показывает что его размер ноль.
и как я понимаю -s при обращении к симлинку смотрит 
не размер самого файла симлинка а смотрит размер 
того файла НА который указывает симлинк
это пиздец
вот я это проверю еще раз.
создаю пустой текстовый файл и делаю на него симлинк.
далее создаю непустой текстовый файл и создаю на него
симлинк. в обоих случаях сам файл симлинк имеет ненулевой размер
и проверяем что покажет -s про эти симлинки
создаю файлы

    # > 5.txt
    # ln -s ./5.txt ./5.lnk

    # echo "123" > 6.txt
    # ln -s ./6.txt ./6.lnk

проверяю их размер    
    # ls -l [5-6].@(txt|lnk)
    lrwxrwxrwx 1 root root 7 дек 21 11:14 5.lnk -> ./5.txt
    -rw-r--r-- 1 root root 0 дек 21 11:14 5.txt
    lrwxrwxrwx 1 root root 7 дек 21 11:15 6.lnk -> ./6.txt
    -rw-r--r-- 1 root root 4 дек 21 11:15 6.txt

проверяю как работает -s
    # [ -s "./5.lnk" ]; echo "$?"
    1
    # [ -s "./6.lnk" ]; echo "$?"
    0

тоесть соврещенно видно что размер симлинка 5.lnk ненулевой
но -s показыает что нулевой. потому что как я еще раз скажу
-s походу смотрит не размер самого файла симлинка 
а размер файла на который этот симлинк указыает.
это пиздец. птомту что эти суки об этом не пишут 
в доках.


далее ключ -d 
проверяет что файл это папка

$ ls -1  --file-type
1.lnk@
1.txt
2.TXT
3.tZt
4.jpg
4.lnk@
5.jpeg
5.lnk@
5.txt
6.jpg
6.lnk@
6.txt
7.jpG
dir1/
f2.pipe|
f.pipe|
nvme1

$ for i  in *; do  [[ -d "$i" ]] && echo "$i"; done
dir1






кстати как создать named pipe 

    $ mknod f3.pipe p

также можно через mknod можно создавать
блочные и символьные файлы

    $ sudo mknod ./a1.block b 12 12
    $ sudo mknod ./b1.char c 13 12
    $ ls -1 --file-type  ./a1.block ./b1.char
    ./a1.block
    ./b1.char



    
далее -b провеерыяет что файл блочный и его наличие
    $ ls -l  | sort
    brw-r--r-- 1 root  root   12, 12 дек 21 18:35 a1.block
    crw-r--r-- 1 root  root   13, 12 дек 21 18:35 b1.char
    crw-r--r-- 1 root  root  240,  1 дек 21 00:01 nvme1
    drwxrwxr-x 2 vasya vasya    4096 дек 21 17:59 dir1
    lrwxrwxrwx 1 root  root        7 дек 21 10:43 1.lnk -> ./1.txt

    $ for i  in *; do  [[ -b "$i" ]] && echo "$i"; done
    a1.block

ключ -c проверяет что файл символьный
    $ for i  in *; do  [[ -c "$i" ]] && echo "$i"; done
    b1.char
    nvme1

ключ -p прорверяет что файл это pipe и что он есть
    $ for i  in *; do  [[ -p "$i" ]] && echo "$i"; done
    f2.pipe
    f3.pipe
    f.pipe


вот прикольная штука
    $ echo "1" | [ -p "/dev/fd/0" ] && echo "PIPE"
    PIPE
но все становистя понятнее когда мы вспомним что [ это /usr/bin/[
тоемсть
    $ echo "1" | /usr/bin/[ "-p" "/dev/fd/0" "]" && echo "PIPE"
    PIPE
тоесть слева от пайпа запускается процесс echo
а справа от пайпа запускается процесс /usr/bin/[
а /dev/fd/0 это симлинк на /proc/self/fd/0

а вот это неочень понятно
    $ echo "1" | [[ -p "/dev/fd/0" ]] && echo "PIPE"
    PIPE
потому что слева от пайпа заупускается внешняя команда процесс echo
а справ от пайпа стоит баш keyword [[...]] поэтом вопрос что за процесс
запускается справ от пайпа, типа новый баш процесс а в нем уже [[ ]]?

так я разобрался как эта строчка работает.
я заупстил трейс 
     $ sudo strace  -e execve,clone,pipe  -p 29393 -f
и увидел что баш делает.
баш создает два новых процесса - два своих клона.
причем после клонирования он незаменяет бинарник. 
так что это получаетя два процесса баша. именнно баша.
в первом клоне баша запускается echo в форме билтина
во втором клоне баша запускается кейворд [[...]]
вот как это работает.
тоесть если у нас есть пайп и слева и справа стоят билтины баша
то баш клонирует себя два раза. клоны это тоже башы. и вэтих клонах
он запускает эти билтины. и оба этих процесса обьединены через пайп. (stdout
первого смотрит на stdin второго)

далее  я нашел интересный пример о том что в скрипте
можно справ от пайпа ставить функцию

function func1()
{
   ...
}


echo "1" | show_input_type   

и это работает точно также как я описал. когда баш доходит
до пайпа то он клонирует себя два раза. в первом клоне
запускается echo во втором клоне запускается функция. а оба 
этих процесса обтединены через пайп (stdout
первого смотрит на stdin второго)
таким макаром без проблем можно в пайпе исползовать функцию.

    $ cat script1.bash 
    #!/bin/bash

    function func1 () {

        echo -n " в STDIN функции поступило вот что =" 
        cat

    }


    echo "111" | func1

    $ ./script1.bash 
    в STDIN функции поступило вот что =111



ксатати хочу показать
про работу head и tail
head печатает голову
а tail  печатает хвост.
но есть интересные нюансы

    $ echo -e "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

печатаем 2 строки сверху
    $ echo -e "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"  | head -n2
    1
    2

    
печатаем последние 2 строки
    $ echo -e "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"  | tail -n2
    9
    10

    
печатаем ВСЕ кроме 2 строки снизу
-2 как бы подсказывает что мы печатаем ( ALL - 2 )
    $ echo -e "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"  | head -n -2
    1
    2
    3
    4
    5
    6
    7
    8


печатаем ВСЁ начиная сверху со строки с номером 3
+3 подсказывает что мы печатаем ( +3 : END )
    $ echo -e "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"  | tail -n +3
    3
    4
    5
    6
    7
    8
    9
    10

последние два примера это вообще бомба.
в любом случае head получается печатает какойто кусок сверху
чтото обрезая снизу. а tail чтото обрезает сверху 
и печатает остальное до конца вниз.


двигаем дальше
ключ -h тестирут что файл симлинк
и что он есть

$ ls --file-type -1
1.lnk@
1.txt
2.TXT
3.tZt
4.jpg
4.lnk@
5.jpeg
5.lnk@
5.txt
6.jpg
6.lnk@
6.txt
7.jpG
a1.block
b1.char
dir1/
f2.pipe|
f3.pipe|
f.pipe|
nvme1
script1.bash

$ for i in *; do [[ -h "$i" ]] && echo "$i"; done
1.lnk
4.lnk
5.lnk
6.lnk


что я при этом НЕ понимаю это то что ключ -f который
тестирует что файл регуляр и что он существует что он 
захватывает тоже симлинки

$ for i in *; do [[ -f "$i" ]] && echo "$i"; done | grep "lnk"
1.lnk
4.lnk
5.lnk
6.lnk

ключ -L это тоже самое что ключ -h

ключ -S проверяет что файл это сокет. и что он есть

    $ for i in /tmp/*; do [[ -S "$i" ]] && echo "$i"; done
    /tmp/OSL_PIPE_1000_SingleOfficeIPC_32bf37703a6a371df545a35a7094f39

проверяю
    $ stat /tmp/OSL_PIPE_1000_SingleOfficeIPC_32bf37703a6a371df545a35a7094f39 |  grep socket
    Size: 0         	Blocks: 0          IO Block: 4096   socket

    
ключ -t очень необычный. у него аргумент это не имя файла
а номер файл дескриптора текущего процесса. (0,1,2...)
и баш проверяет что бекендом для этого файл дескриптора является 
терминал что файл десприктор ведет на терминал

    $ ls -1al /proc/self/fd/0
    lrwx------ 1 vasya vasya 64 дек 21 19:50 /proc/self/fd/0 -> /dev/pts/11

    $ [ -t 0 ] && echo "TERMINAL"
    TERMINAL


проверяем что юзер который запустил команду
имеет право на чтение\запись\исполнение файла
    $ ls -l ./1.txt
    -rw-rw-r-- 1 vasya vasya 3 дек 21 10:43 ./1.txt

    $ id
    uid=1000(vasya) gid=1000(vasya) groups=1000(vasya)

    $ [  -r "./1.txt" ]; echo $?
    0
    
    $ [  -w "./1.txt" ]; echo $?
    0
    
    $ [  -x "./1.txt" ]; echo $?
    1


| sgid
| suid
| sticky
| chattr

    
SGID бит. set-group-id.
рассмотрим его. как он работает 
нахер он нужен
его можно установить для папки  и для файла
рассмотрим вначале для папки.
если мы его установим для папки. то при создании файла в 
этой папке от имени любого юзера
владельцем файла будет не группа к который юзер принадлежит а группа 
к которой принадлежит папка.
признаком того что установлен этот бит является обозначение
    --- --s ---
либо 
    --- --S ---

можно заметить что буква s\S стоит на месте 
там где должен стоять x для группы.
поэтому становится понятно что s\S нам сигнализирует
нетолко о том что установлен sgid но и о том
установлен x для группы или нет. если S то это обозначает что 
g+x неустановлен. а если s то g+x установлен.
тоесть 
    --s = sgid и (g+x)
    --S = sgid и (g-x)

если пермишн обозначается через октальный вид то sgid
обозначается как 
    2---

рассмотрим на примере
у нас есть папка владелец которой принадлежит к группе "nogroup"
и на папке установлен sgid
    $ ls -1ald ./\!21
    drwx--sr-x 2 vasya nogroup 4096 дек 22 00:31 './!21'
а вот так в октальном виде 
    $ stat --format="%n %a" ./\!21
    ./!21 2715

и вот мы видим 2--- в октальном виде пермишнс. это sgid
и я вижу "s"  маленькую  потому что мы видим в октальном виде 1 для группы.
тоесть "x" для группы установлен. поэтому s маленкая
    
я работаю под юзером vasya
    $ id
    uid=1000(vasya) gid=1000(vasya) groups=1000(vasya)

я создаю файл. но его группа будет не vasya
а nogroup из за наличия sgid у папки в которой
я создаю файл

    $ >3.txt 
    $ ls -1al ./3.txt 
    -rw-rw-r-- 1 vasya nogroup 0 дек 21 20:05 ./3.txt

ключ -g позволяет проверить что на файле\папке
установлен sgid бит

    $ ls -1ald ../\!21
    drwxrwsr-x 2 vasya nogroup '../!21'

    $ [ -g '../!21' ]; echo "$?"
    0

теперь вопрос -а зачем нам это надо на практике?
это дает то что это нам позволяет иметь механизм
чтобы непривлигированный юзер мог запустить программу
с повышенными правами. кстати программа будучи работающей 
с повышенми правами может выполнить кусок который требует 
повышенных прав и программа может вывзвать сисколл
и сменить владельца самой себя (процесса) на 
непривилигированного. и нет проблем с безопаностью
сферический пример в вакуусе - мы запускаем программу под васей
но нужно чтобы эта программа могла писать в файл
в который разрешено писать группе петя а васе нельзя.
тогда можно сделать что у файла группа петя и 
добавить sgid. и эта программа сможет пписать в этот файл.


  
теперь разбер следущий случай
если установить sgid НА ФАЙЛ это даст то 
будет вот что. положим у нас есть юзер
который имеет UID=vasya
и этот юзер входит в группу GID=vasya
далее у файла есть теже свойства
UID,GID которые задают владельца файла.
для примера UID(файла)= root GID(файла)=root
далее когда создается процесс в памяти 
то у него есть такие же свойства UID,GID
так вот когда юзер тыкает на файл и ядро
создает процесс в памяти то ядро абсолютно
срет на UID,GID файла и смотрит только 
на UID,GID юзера. и присваивает UID юзера
в UID процесса. тоже самое с GID.
НО! ситуация полностью меняется когда 
файл имеет sgid флаг установленный. тогда 
при создании процесса ядро для процесса
выставляет GID(процесса)=GID(файла)
а на GID(юзера) срет с колокольни.

пример
UID(юзера)=vasya
GID(юзера)=vasya
UID(файла)=root
GID(файла)=root
запускаю файл и получаю процесс с 
параметрами
    # ps -o pid,uid,gid,egroup,command  $(pidof sleep)
    PID   UID   GID EGROUP   COMMAND
    6767  1000  1000 vasya    sleep 130

GID=1000 это обозначение группы через цифру. 
а EGROUP это обозначение группы через слова
UID=1000 это обозначение владельца процесса через цифру.
а поля которое бы автоматом конвертировало бы его в слова нет. поэтому
это надо конвертировать в слово руками. щас я сконвертирую.
UID=1000 конвертируется в UID=vasya
   
тоесть в итоге мы получили 
UID(процесса)=vasya
GID(процесса)=vasya

тоесть у процесса эта хрень берется из параметров юзера.
а то что прописано в файле это игнориуется.

так вот если вдруг у файла появляется sgid флаг. то ситуация
меняется. GID(процесса) устанавливется равным GID(файла).
пример на этот случай
юзер:
UID(юзера)=vasya
GID(юзера)=vasya

имеем файл с sgid:
    $ sudo chmod g+s ./sleep
    $ ls -l  ./sleep 
    -rwxr-sr-x 1 root nogroup 35000 дек 22 01:11 ./sleep
кстати при смене владельца файла (а может также и при смене группы
у файла )у него сбрасываются эти спец флаги suid,sgid,sticky и они исчезают
и если они нам нужны их нужно заново устанавливать
тоесть мы видим что у файла
UID(файла)=root
GID(файла)=nogroup

теперь я этим васей запускаю этот файл. 
и смотрю свойства полученного процесса

    # ps -o pid,uid,gid,egroup,command  $(pidof sleep)
    PID   UID   GID EGROUP   COMMAND
    7403  1000 65534 nogroup  ./sleep 130

и вижу что 
UID(процесса)=1000=vasya
GID(процесса)=65534=nogroup

тоесть GID(процесса) был взять равным из GID(файла) а не GID(юзера)

и тут я поясню еще такой момент. нахуй процессу нужно 
иметь в своих свойствах UID, GID
а оно нужно вот для чего. когда процесс обращается 
к файлу какомуто надиске скажем чтобы записать в тот файл
то это происходит через посредничество с ядром.
и ядро сравнивает UID,GID процесса с permissions этого файла.
а ведь в пермишнс файла как раз все прописано на основе UID,GID 
который предьявляется ему снаружи. тоесть скажем  в файле
указано что владелец файла это vasya и ему разрешена запись.
и вот ядро смотрит что у процесса UID=vasya. и что у файла владелец
vasya и этому владельцу можно делать запись. и тогда ядро на основе
этого разрешает процессу писать в файл. вот зачем нужно процессу
иметь такие свойства как UID, GID 

теперь вопрос - зачем на практие нам нужен такой механизм?
положим у нас есть папка в которой файлы создают разные
юзеры. при создании файла по дефолту у него вот такие пермишнсы
    -rw-rw-r--
тоесть разрешено по дефолту писать владельцу файла и 
группе файла. ну а владелец файла это юзер который создал 
этот файл. и положим есть сервис который запущен от имени 
совершенно другого юзера. и также он не входит в группу 
этого юзера. это значит что этому сервису писат в этот файл
по деолфту запрешено. тогда чтобы не мудить вручную с пермигншгасами
для кажодго такого файла мы идем в папку. там устанвливаем sgid
и делаем группу у папки group4. где group4 это группа в которую 
входит наш сервис. тогда при созании файла юзером 
сервис автоматом будет иметь право писать в этот файл.
этот пример опять же сферический  в вакуууме. на практике
я не встречал в продакшене нигде мудеж с использованием
sgid ни для файлов ни для папок.
на практике как можно обеспечить чтобы неклько юзеров могли создвать 
файлы в одной и той же папке. все юзеры не могут быть владецльем папки
так что это отпадает. но можно создать группу. назначить ее папке. разрешить
группе писать в папку. и юзеров всех добавить в эту группу. в том числе и сервис.
далее при остуствии sgid на папку юзеры будет создавтаь файлы но писать в него
сможет либо создатель либо члены его группы. а это нам неудбно. потому что у
кажодго юзера своя индициаульная primary группа. а вот установка sgid 
даст то что группой для файла будет группа у папки. и этой группе 
по дефолту при создании файла юзером будет разерешена запись. 
а у нас уже задано что все юзеры входят в группу которой принадлжеить папка.
гоча.
пример
вначчале как это есть для папки без sgid
свойства папки

    $ ls -ld ../\!23
    drwxrwxr-x 2 root josh 4096 дек 22 03:27 '../!23

берем юзера vasya
и создаем файл

    $ >vasya.txt
    $ ls -l
    -rw-rw-r-- 1 vasya vasya 0 дек 22 03:27 vasya.txt

видно что в файл может писать либо вася либо член группы вася.
это пиздец

теперь добавляем sgid на папку
    $ sudo chmod g+s ../\!23
    $ ls -ld ../\!23
    drwxrwsr-x 2 root josh 4096 дек 22 03:27 '../!23'

и создаем файл тем же васей
    $ >vasya2.txt
    $ ls -l vasya2.txt 
    -rw-rw-r-- 1 vasya josh 0 дек 22 03:30 vasya2.txt

видно что теперь файл имеет группу josh.
эта группа не имеет отношения к группе юзера. эта группа взята
из свойства папки. какой бы юзер ни создал файл в этой папке 
он всегда будет иметь в свойствах группу josh
и по дефолту для группы этой в файл разрешена запись.
поэтоу все юзеры которые входят в группу josh могут писать во все файлы
в этой папке неважно какой юзер этот файл создал.
вот так можно юзать эту хрень на практкие

щас  я попробую найти не сильно углубляясь на фс 
файлы\папки с sgid установленым

# find / -maxdepth 2 -perm /g+s -printf "%h/%-24.24f | %y\n"
/sbin/pam_extrausers_chkpwd    | f
/sbin/unix_chkpwd              | f
/var/metrics                  | d
/var/mail                     | d
/var/local                    | d
/var/crash                    | d
/etc/chatscripts              | d

проаналириуем эти файл и папки
при запске этой команды ее процесс будет иметь группу shadow
    # ls -1ald /sbin/pam_extrausers_chkpwd 
    -rwxr-sr-x 1 root shadow 34816 апр  8  2021 /sbin/pam_extrausers_chkpwd

аналогичный пример
    # ls -1ald /sbin/unix_chkpwd 
    -rwxr-sr-x 1 root shadow 34816 апр  8  2021 /sbin/unix_chkpwd

если юзер принадлежит группе mail 
то если этот юзер создает файл в этой папке 
то у файла будет группа не primary юзера а mail
    # ls -1ald /var/mail 
    drwxrwsr-x 2 root mail 4096 окт 11 21:26 /var/mail

тут надо проянсить важный момент. юзер может быть членом кучки групп. но 
у юзера есть primary группа и при создании файлов\папок по дефолту им назначается
именно эта примари группа. поэтому если vasya член группы mail но у него
примари группа vasya то при созданиии файла  в папке где разрешена 
запись для членов группы мейл такому файлу будет назначена группа vasya
а по дефолту запись в файл разерешена только владельцу васе или его группе вася.
так что другие юзеры которые тоже входтя в группу mail не смогут писать в 
этот файл. а вот установленный sgid на папку дает то что файл созданный васей
будет иметь группу не вася а mail  и члены группы mail могут 
сразу писать в этот файл.
ладно с этим примером все понятно

следующая папка
файлы созданные в этой папке будут имет групппу staff
и члены этой группы могут  писать в эти файлы
    # ls -1ald /var/local
    drwxrwsr-x 2 root staff 4096 апр 24  2018 /var/local

    
тоже самое что в предыдущем примере
толко группа whoopsie
    # ls -1ald /var/crash
    drwxrwsrwt 2 root whoopsie 4096 сен 26 01:50 /var/crash

файлы созданные  в этой папке буду иметь группу dip
участники группы dip как видно могут входить в папку
но не могут создавать файлы в папке.
вопрос
как же тогда куча юзеров сможет создавать файлы в этой папке. 
ответ никак. файлы в этой папке будет создавать рут.
но после того как рут создал файл его смогут редактировать 
все члены группы dip. потому что по дефолту после создания
файла для группы устанвливаются права rw- тоесть запист 
в файл разрешена. а для файла группа будет установлена dip

    # ls -1ald /etc/chatscripts/
    drwxr-s--- 2 root dip 4096 сен 16  2021 /etc/chatscripts/


Итак я разобрал что дает установка бита sgid
и на файл и на папку..





немного отоду в сторону
кстати как установить на папке sgid бит
    $ chmod g+s file1
    
    
    
кстати в команде chmod + означает добавить
пермишн, - означает отнять пермишн. если мы неуказываем 
для кого то незримо подставляетя что для всех. тоеть 
    $ chmod a+x file1
это аналог
    $ chmod +x file1
    
а вот можно указать для кого
    $ chmod o+x file1
означает добавить +x для other
а знак = означает  что нужно сбросить все пермишны
и выставить в точности как мы указали пермишн для всех

выставляем что нужно сбросить все пермишны
и для всех выставит rwx
но почему то при этом для other бит w
не выставляется
    $ chmod  =rwx 3.txt
    $ ls -1al 3.txt
    -rwxrwxr-x 1 vasya nogroup 0 дек 21 20:05 3.txt

выставляем что все биты нужно сбросить и для всех
установить бит x
    $ chmod  =x 3.txt
    $ ls -1al 3.txt
    ---x--x--x 1 vasya nogroup 0 дек 21 20:05 3.txt

выставляем что все биты нужно сбсрсить и для всех
выставить биты wx
видно что опять для other бит w не выставился
    $ chmod  =wx 3.txt
    $ ls -1al 3.txt
    --wx-wx--x 1 vasya nogroup 0 дек 21 20:05 3.txt

говорим что для other нужно добавить бит w
    $ chmod  o+w 3.txt
    $ ls -1al 3.txt
    --wx-wx-wx 1 vasya nogroup 0 дек 21 20:05 3.txt




    

suid  , set-user-id флаг.
это следущий интеересный флаг который
можно установить на файл или на папку.

смысл этого флага точно такой же как у предыдущего флага.
тоесть если мы ставим suid на файл то при запуске этого файла
его процесс будет uid такой же как  uid у файла

а если поставить suid поставить на папку то при создании
файла любым юзером (в том числе и рутом) то владельцем
нового файла будет uid которйы стоит на папку

установка suid на файл дает то что мы можем таким макаром
обеспечить механизм что при запуске программы неприлигированным
васей процесс будет иметь повышенные привилегии. 

установка suid на папку дает то что если группа юзеров   
создает файлы в папке то файл сразу получает
такие пермишнсы что его может редактировать куча юзеров
которые принадлежат некоей группе. и для этого ненужно 
руками менять пермишнсы для этого файла. 

найдем файлы и папки с suid

    $ find /bin  -maxdepth 1   -type f  -perm -u+s -print
    /bin/mount
    /bin/umount
    /bin/ping
    /bin/su
    /bin/fusermount


    $ find /bin  -maxdepth 1   -type f  -perm -u+s    -exec ls -1al '{}' ';'
    -rwsr-xr-x 1 root root 43088 сен 17  2020 /bin/mount
    -rwsr-xr-x 1 root root 26696 сен 17  2020 /bin/umount
    -rwsr-xr-x 1 root root 64424 июн 28  2019 /bin/ping
    -rwsr-xr-x 1 root root 44664 мар 23  2019 /bin/su
    -rwsr-xr-x 1 root root 30800 авг 11  2016 /bin/fusermount

    
также как с guid -> suid обозначается как S либо s
если юзер имеет x то это s
а если юзер не имеет x то это S
    
также нам нужно octal представление пермишнов. чтобы точно знать.
ls это не умеет зато stat или find умеет. я нахожу что find 
более просто использовать для этого. щас покажу

    $ find /bin  -maxdepth 1   -type f  -perm -u+s    -printf "%f %m \n"
    mount 4755 
    umount 4755 
    ping 4755 
    su 4755 
    fusermount 4755 

suid обозначается через 4  (а guid обозначается как  2 )   
    

для примера более подоробно смотрим ping

    $ ls -1al /bin/ping
    -rwsr-xr-x 1 root root 64424 июн 28  2019 /bin/ping
    $ find /bin -name "ping" -type f -printf "%f %m \n"
    ping 4755 

так как s маленькая это значит что x для юзера выставлен.
это дказывает и цифра 7  в find
прикольно

кстати есть очень важный прикол
когда юзер vasya запускает комаду ping то она
как процесс запускается от root. но если мы запустим пинг и посмотрим
в списке процессов от имени кого он запущен то мы не увидим владельца root
мы увидим владельца vasya. что же за хуйня. ответ состоит в том что 
пинг когда стартует он реаьно стартует по рутом. делает небольшую работу 
ту которую имеет право сделать только рут. а потом запускатся сисколл который
меняет владелца процесса на непривилигированного пользователя! вот такая
хитрая щарманка. а что же делает пинг под рутом? он создает сетевой сокет.
эта операция требует права рута. вот так хитро.

если файл имеет suid то ls его отображает розовым цветом
если файл имеет guid то он печатается на экране оранжевым

так вот ключ -u проверяет устаговлен ли suid на файл и есть ли файл вообше
    $ [ -u "/bin/ping" ]; echo $?
    0

кстати suid, guid для файла работает только если это бинарь файл
но для файла скрипта это не рабтает!
 если это скрипт то ос шлет этот бит нахер. логика простая. 
есть скрипт владельцем котрого является root и у 
юзера вася так случилось есть  права на запись в этот файл. вася вставмть в скрипт 
команду rm -f зпустит этот скрипт . скрипт запустился бы от имени рута
и потер нахер всю систему.

кстати логично что если мы сменили владельца у файла то 
ос автоматом сбрасыввает биты suid и guid
потому что только root или владелец файла должен иметь права 
устанавливать право на то чтобы при запуске этого файла процесс получал права
этого юзера. 


теперь рассмотрим примеры.
вначале мы установим suid на файл. запустим этот файл
и проверим что процесс имеет uid файла
имеем такой файл

    $ ls -l ./sleep
    -rwsr-xr-x 1 temp josh 35000 дек 22 12:01 ./sleep

запускаем его под юзером vasya
    (vasya)$ ./sleep 160
смотрим параметры проецесса
    # ps -o pid,uid,gid,command 12418
    PID     UID   GID   COMMAND
    12418  1002  1000   ./sleep 160

выясняем кто такой uid=1002
    # id 1002
    uid=1002(temp) gid=1002(temp) groups=1002(temp),1004(gr4)
    
итак  это юзер temp
тоесть мы увидели что файл я запускпл под vasya а пофакту он как
процесс крутится под temp. где temp это uid файла

теперь рассмотрим пример когда suid установлен на папку.

    # ls -ald '../!24'
    drwsrwsrwx 2 root josh 4096 дек 22 12:01 '../!24'

создаем в этой папке файл под юзером vasya

    $ >3.txt
    $ ls -1ald ./3.txt 
    -rw-rw-r-- 1 vasya josh 0 дек 22 12:40 ./3.txt

    
видим что suid несработал. что владельцем файла является не root
а vasya. но это как я полагаю потому что владельцем папки является root
а это особый случай. 
щас я поменяю владельца папкой temp

    $ ls -ald  '../!24'
    drwsrwsrwx 2 temp josh 4096 дек 22 12:43 '../!24'


    $ >6.txt
    $ ls -1al ./6.txt 
    -rw-rw-r-- 1 vasya josh 0 дек 22 12:45 ./6.txt

как видно все тоже самое. так что я констатирую => suid  на папку НЕРАБОТАЕТ
далее очень важно подчеркнуть что чтобы suid бит сработал надо чтобы выполнялись
условия:
    1) один раз  я вместо suid бита добавил на файл стики бит. нужно не спутать
        #  chmod +x file1
    2) нужно чтобы  у файла был верный владелей. если мы хотим чтобы
    процесс стартовал от рута значит владельцем файла должен быть root
    3) очень важный момент что для того чтобы suid бит работал юзер
    под которым мы стартуем этот файл необязан быть в группе sudo.
    достаточно выполнения двух предыдущих условий, еше раз подчеркну
    что юзер который тыкает на файл ему ненужно быть членом группы sudo
    4) есть еще один момент положим мы выполнили два первых пунтка
    но потом смотрим в процессах и видим что процесс висит не от рута.
    в чем дело? а дело в том что когда код программы стартанет в процессе
    от рута то этот код если в нем есть такой кусок то он может по своему желанию
    сменить юзера процесса (тоесть самого себя) на другого юзера.
    раассмотрим на прмиере ping
        $ id
        uid=1000(vasya) gid=1000(vasya) groups=1000(vasya)
        $ ls -1al $(which ping)
        -rwsr-xr-x 1 root root 64424 июн 28  2019 /bin/ping
        $ ping 8.8.8.8

    и на другом терминале я смотрю от чьего имени работает процесс
        # ps aux | grep "ping [0-9]" 
        vasya      821  0.0  0.0  23500  1096 pts/3    S+   05:49   0:00 ping 8.8.8.8

    как видим не от root
    это именно потому что внутри кода ping есть кусок 
    который переводит владельца процесса из root обратно в непривлигиорванного
    5) также известный момент что скрипты ядро не запускает в привлигированном режиме
    тоесть бесполезно на файл со скриптом (баш перл неважно) навешивать suid бит

        
таким макаром что я имею суммарно:

    suid на папку НЕработает

    suid на файл дает то что когда юзер вася запускает файл у которого
владелец петя процесс будет создан как бутто его запустил петя тоесть uid процесса
будет петя

    guid на папку дает то что кто бы ни создал файл в этой папке ее владельцем
в плане группы будет не тот кто создал файл а та группа которая прописана в свойствах
папки. тоеть если папка имеет в свойствах gid=petya и заходит vasya
в папку создает в ней файл то в свойствах файла будет gid=petya а не vasya

    guid на файл дает то что если у файла gid=петя  а файл запускает vasya
    то в свойствах процесса gid=petya а не vasya
    


    


далее
кстати интернсо что find может искат сразу в нескльких папкахх

    $ find /dir1 /dir2 -type f -print

   


кстати как временно изменить вид PROMPT в баше
    $ echo $PS1
    \[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}[\u@\h \W]\$
    $ PS1='\$'
    $

    
далее посмотрим как выглядять пермишнсы когда 
и suid и guid установлеены одноврееменно.
рассмотрю случай когда мы это делаем на примере папки

    $ ls -1ald ../\!24
    drwxrwxr-x 2 vasya vasya 4096 дек 22 11:54 '../!24'
    $ chmod u+s,g+s ../\!24
    $ ls -1ald ../\!24
    drwsrwsr-x 2 vasya vasya 4096 дек 22 11:54 '../!24'

    $ stat  --format="%n %a"   ../\!24
    ../!24 6775

видим что октал это 6=2+4 
логично


далее
    $ chmod + file1
несделает нихрена






далее изучаем sticky bit.
цитирую из "bash advanced guide" - Commonly known as the sticky bit, the save-text-mode flag is a special type
of file permission. If a file has this flag set, that file will be kept in cache memory, 
for quicker access.

тоесть стики бит прилеить к файлу то например когда последний процесс
использующий этот файл умрет то ядро все равно будет держать этот файл в памяти
чтобы потом его не подгружать не траить наа это время. и то что если будет
запущено несклоько процессов с этим файлом то все они будут обращаться к одному куску
памяти где этот файл. в целом сейчас эта хрень вообще нахер ненужна. поэтому
гланвым образом можно сказать что назначать стики бит файлу нахер ничего недает.

если стики бит назначаем на папку оно работает сука совершенно другим образом.
пока забудем про стики бит. если у вас есть права на запись в папке то вы можете
создавать и удалять файлы в папке. так вот если мы назначаем sticky бит
на папку то удалить в папке файл может только владелец файла и ли root
и больше никто другой

итак имеем папку
в ней для other разрешено write
поэтому каждый может создавать файлы и удалять файлы
    $ ls  -al .
    drwxrwxrwx   2 temp  temp     4096 дек 22 14:15 .

создаем файл от имени юзера temp

    $ sudo -Hu   temp   bash -c ': > ./1.txt'
    $ ls -al ./1.txt 
    -rw-r--r-- 1 temp temp 0 дек 22 14:22 ./1.txt

удаляем файл от имени юзера vasya.
причем на то можно удалить файл или нет не влияют права на самом файле
влияет только пермишнсы на папку!

    $ id
    uid=1000(vasya) gid=1000(vasya) groups=1000(vasya)
    $ rm 1.txt 

теперь ставим sticky бит на папку
    $ sudo chmod +t .

    $ ls -ald  .
    drwxrwxrwt 2 temp temp 4096 дек 22 14:21 .
видно как появился t в пермишнсах
    
в oct виде  в пермишнсах появляется 1
    $ stat --format="%n %a" .
    . 1777

итак 1 = sticky bit
     2 = suid bit
     4 = sgid bit
    

я сразу скажу что  чтобы назначить стики бит файлу через chmod
это можно сделать в двух формах либо в символьной (+t) либо в oct (+1000)

    # chmod +t ./file1
    # chmod +1000 file1

а вот у find нет символной формы. а есть толко oct  форма
    $ find /tmp -type f -perm -1000 -print 2>/dev/null
    

причем обращая внимание еще на один ммоент. вовзращаемся кк тому
когда у нас пермишн показан в форме
    --- --- ---
у нас признак стики бита стоит в конце
    --- --- --t
    --- --- --T

буква T большая когда x для other неустановлен
а t маленькая когда у нас x для other установлен 
показываю  на примере
первый случай когда для other x не устанолвен
    $ stat /tmp/3.txt --format="%n %A"
    /tmp/3.txt -rw-rw-r-T
    $ stat /tmp/3.txt --format="%n %a"
    /tmp/3.txt 1664
второй случай кода x для other устанолвен
    $ chmod o+x /tmp/3.txt
    $ stat /tmp/3.txt --format="%n %A"
    /tmp/3.txt -rw-rw-r-t
    $ stat /tmp/3.txt --format="%n %a"
    /tmp/3.txt 1665


теперь опять создаем файл с владельцем temp
и пробуем его удалить от юзера vasya


    $ sudo -Hu   temp   bash -c ': > ./1.txt'
    $ ls -al ./1.txt 
    -rw-r--r-- 1 temp temp 0 дек 22 14:22 ./1.txt

    $ id
    uid=1000(vasya) gid=1000(vasya) groups=1000(vasya)


    $ rm 1.txt 
    rm: remove write-protected regular empty file '1.txt'? y
    rm: cannot remove '1.txt': Operation not permitted


но файл может удалить либо рут либо владелец
    $ sudo rm ./1.txt

а как сделать так чтобы файл не мог удалить никто. даже рут
на помощь приходит chattr
    $ sudo chattr +i ./1.txt
ls при этом ничего не покажет
    $ ls -1al ./1.txt
    -rw-rw-r-- 1 vasya vasya 0 дек 22 14:35 ./1.txt
новое покажет другая команда
    $ lsattr   ./1.txt
    ----i---------e--- ./1.txt

    
    $ sudo rm ./1.txt
    rm: cannot remove './1.txt': Operation not permitted

ксати атрибут "e" означает что файл использует не блоки а экстенты.

кстати если файлу назначить s атрибут то при его удалении все его дата 
блоки буду затерты нулями.

также man chattr пишет что далеко не все ФС поддерживают все флаги chattr
и что надо читать в манах ФС какие флаги они поддерживают.

баш позволяет проверить имеет ли файл стики бит чеерез -k ключ

    $ ls -1ald .
    drwxrwxrwt 2 temp temp 4096 дек 22 14:35 .

    $ stat --format="%n %a" .
    . 1777

    $ [[ -k "." ]]; echo "$?" 
    0

    

как нам найти через find папки с sticky bit

    $ find /  -maxdepth 2 -type d -perm -1000  -print 2>/dev/null
    /run/screen
    /run/lock
    /var/metrics
    /var/tmp
    /var/crash
    /tmp
    /tmp/.font-unix
    /tmp/.XIM-unix
    /tmp/.ICE-unix
    /tmp/.X11-unix
    /tmp/.Test-unix
    /dev/mqueue
    /dev/shm

    $ stat --format="%n %a" /dev/mqueue
    /dev/mqueue 1777

    
видно что /tmp  имеет стики бит.
значит в этой папке удалить файл может только владелец. или рут.

    $ ls -1ald /tmp
    drwxrwxrwt 102 root root 32768 дек 22 14:48 /tmp
    
    
значит видно что для other разрешена запись в папку.
значит как бы каждый типа может удалять файлы в этой папке.
но стики бит не даст удалять файлы которые мы не явяялемся владельцем
либо мы должны быть рут

проверяем. берем файл которым владеет вася. и пытаемя его удалить 
от имени юзера пети

    $ ls -1al /tmp/big.txt 
    -rw-rw-r-- 1 vasya vasya 4096 дек 11 01:21 /tmp/big.txt

    $ sudo -Hu temp bash -c "rm /tmp/big.txt"
    rm: remove write-protected regular file '/tmp/big.txt'? y
    rm: cannot remove '/tmp/big.txt': Operation not permitted

далее я прочитал и открыл что если мы поставим стики бит на папку.
тот файл в этой папке может удалить 
    1) root
    2) владелец файла
и оказывается есть еще  один человек который может удалить файл из папки
    3) владелец папки!

показываю
владелец папки vasya
и папка имеет sticky bit
    $ ls -1ald "."
    drwxrwxrwt 2 vasya vasya 4096 дек 22 16:54 .

создаем файл у котрого владалец temp
    $ sudo -Hu temp bash -c " : > 1.txt"
    $ ls -1ald  ./1.txt
    -rw-r--r-- 1 temp temp 0 дек 22 16:56 ./1.txt
пробуем удалить файл от имени владельца папки тоесть vasya
    $ rm ./1.txt 
    rm: remove write-protected regular empty file './1.txt'? y
успех . охуеть



итак подвожу итоги что дают sgid, suid, sticky bit.
sgid - если назначили на файл то при запуске бинарника 
процесс буде иметь gid не юзера который запустил файл как 
это всегда бывает а gid который указан в файле
sgid - если назначил на папку то при созании файла
его gid будет такой же как gid у папки а не gid юзера 
кторй его создал как это обычно быает

suid - на папку неработает. не дает ничего
suid - на файл. при заупске бинарника процес будет
иметь uid файла а не uid юзера который его заупстил

sticky bit на файл - недает ничего
sticky bit на папку  - если создать файл 
в такой папке то его удалить может толко владелец или root или тот кто владелец
этой папки!



далее я открыл для себя реальный прикол непонятный.
я уже знаю что если я создаб файл от имени вася то файл 
будет иметь владельца васю. но почемуто вот эта команда
так не делает.
для начала подготовительная штука.
я показываю что sudo запускает процесс от имени temp
    $ sudo -Hu temp sleep 130
    # ps aux | grep sleep
    root     19546  sudo -Hu temp sleep 130
    temp     19547  sleep 130

тут видна тоже интереная вещь. команда sudo работает от root
но не она выполняет sleep! она просто висит и нихера неделает. роль процесса
sudo чтобы всего навсего себя склонировать и запустить заданный процесс
от имени заданного пользователя. как то раньше я думал что уже сам sudo внутри
себя запускает нужный процесс. оказыается совершенно нет. 
получается как работает sudo.
мы его запускаем от имени простого юзера
бинарник sudo имеет suid бит

    # ls -1ald $(which sudo)
    -rwsr-xr-x 1 root root 149080 янв 19  2021 /usr/bin/sudo
    
поэтому хотя у нас sudo запукает вася но процесс sudo за счет suid
запускается от рута. и может делат чо хочет. этот процесс смотрит входит ли
юзер который запустил процесс в группу судо. видит что да. значит можно 
этому юзеру позволить запустить некую команду от имени рута. и судо далее себя
клонирует и запускает от имени заказанного юзера например рута запускает 
заказанный бинарник. 
пример
    $ sudo -Hu temp sleep 130
    # ps aux | grep sleep
    root     19546  sudo -Hu temp sleep 130
    temp     19547  sleep 130

я запускаю под юзером вася команду судо. и прошу ее запустить команду sleep
от имени юзера темп. в итоге судо запускается от имени рута потому что на бинарнике
sudo стоит suid бит. и судо видит что вася входи в групу судо. и поэтому судо дает 
зеленый свет и клонррует себя и запускает команду sleep от имени temp
поэтому сам процесс судо он внутри себя команду sleep невыполняет как я раньше думал
а просто создает дочерний процесс и там уже запускает sleep. а сам процесс судо
после этого тупо висит в памяти и ждет кода возврата от дочернего процесса.

вот еще пример
# 
    # pstree 3389
    sudo───iptraf-ng
    # ps aux | grep -E "3389|3390" | grep -v grep
    root      3389  sudo iptraf-ng
    root      3390  iptraf-ng

таикм образом процесс sudo iptraf-ng  он нихрена неделает. он не выполняет 
код iptraf-ng он просто висит. так как он ранее себя склониррвал в новом процессе
запустил уже iptraf-ng
такимобразом внутри процесса с sudo код iptraf-ng ни в коем случае не выполняется!

ладео это я отвлекся о том как радоттае судо.
возвращаеся  к примеру
я сижу под юзером вася
и запускаю код
    $ sudo -Hu temp sleep 130
    # ps aux | grep sleep
    root     19546  sudo -Hu temp sleep 130
    temp     19547  sleep 130

значит четко видно что наша строка с судо в итоге запустила sleep 
от имени юзера temp.
и тогда далее я не очень понимаю почему вот эта строка создает 
файл с владельцем вася а не юзер temp

    $ sudo -Hu temp  true > 3.txt
    $ ls -1al
    -rw-rw-r--   1 vasya vasya       0 дек 22 17:30 3.txt
     
у нас ведь теперь мы точно знаем что запускатся процесс с командой true
от имени юзера temp но почему то файл 3.txt создается с владельцем vasya.
что за хрень.

и я разобрался и узнаал как и почему так все получается.
и я понял почему вот такая команда уже делает то что надо
    $ sudo -Hu temp bash -c 'true > 3.txt'
    
начну разбирать эту штуку поэтапно.
начну разбирать с вспомогательных моментов чтобы понять.
во первых как линукс создает файл.
он его создает через сискол open или openat (man 2 openat)
точнее по другому. есть систем коллы а есть C функции.
C функции это обычно обертка которая вызывает систем колл
в C программе строчки кода вызывают функции C.
в man  насколько я понимаю описываются функции C 
а не систем коллы. а вот strace нам показывает систем коллы
а не функции C. часто функции C и системколлы имеют одинаковые
имена. вроде бы так хотя тут можно ноги сломать легко.
далее я употребляю термин систем колл хотя это функция C.
итак open и openat эти сисколлы позволяют открывать файл для последующей 
чтения записи  а также что более важно
для меня эти сисколлы умеют создавать новые файлы

    int open(const char *pathname, int flags, mode_t mode);

    int openat(int dirfd, const char *pathname, int flags, mode_t mode);

вначале разберем более простой

    int open(const char *pathname, int flags, mode_t mode);

где pathname  это "путь к файлу"
mode  это пермишнс при создании файла типа 0666 которые будут ему присвоены
flags  это опции открытия файла. во флагах обязательно нужно указать
хотя бы один из трех флагов  O_RDONLY, O_WRONLY, or O_RDWR
тоесть файл открывается на чтение, запись , или и то и другое
также если мы создаем файл то нужно указать флаг O_CREAT
пример прогарммы которая использует эту функцию и создает файл

$ cat 104.c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>


int main(void)
{

int flags = O_CREAT|O_WRONLY;
mode_t mode = 0666;
char *pathname = "/tmp/1.txt";


int fd = open(pathname, flags, mode);


if (fd < 0) {
      perror("Creation error");
      exit (1);
}

close (fd);
exit (0);

}


итак сама фукция имеет вид 
    open(pathname, flags, mode);

а ее паарметры это 
    pathname = "/tmp/1.txt";
    flags = O_CREAT|O_WRONLY;
    mode = 0666;


итак мы указыаем путь, флаги, пермишнсы и файл создается
    $ gcc -o 104.exe 104c

    $ strace -e 'trace=execve,close,open,openat' ./104.exe
    execve("./104.exe", ["./104.exe"], 0x7ffd61a9f9f0 /* 70 vars */) = 0
    openat(AT_FDCWD, "/tmp/1.txt", O_WRONLY|O_CREAT, 0666) = 3
    close(3)                                = 0

посолльку я уже сказал что в программе на C мы испольщуем функции
а strace показыает сисколлы. поэтому в выводе от strace
мы видим не фнукцию open а сисколл openat который она вызвыает.
поэтому openat отличается от open но немного.  в нем мы видим и path "/tmp/1.txt", 
и флаги O_WRONLY|O_CREAT, и mode 0666 из нашей функции

проверим что получили
 
    $ stat --format="%n %a" /tmp/1.txt
    /tmp/1.txt 664
    $ stat --format="%n %A" /tmp/1.txt
    /tmp/1.txt -rw-rw-r--
    $ 

кхм мы получили файл с 0664 а мы заказывали с 0666
секрет ответа в том что из того что я прочитал в 
    $ man 2 umask 
и в 
    $ man 2 openat 
при отсуствии дефолтного ACL (что такое ACL это отдельная тема) у папки в которой мы
создаем файл то при создании файла ядро задаст конечный пермишнс
для файла как (mode - umask). про umask можно почитать в umask.txt 
там же находится окончание этой темы.


также владельцем файла явялестятся тот  uid который равен uid юзера
который запустил процесс. 





    

    
кстати про find
так как каждая его опция вовзвращает код возврата
это дает то что можно печатат на экране имена файлов только тех 
которые удовлетворяют условиям
скажем в этом примере
будут напечатаны только те имена файлов для которых греп
нашел вхожждение. потому что для файвло для которых греп
ничего ненайдет его код вовзарат будет false и значит
последующее условие -print оно не будет выполнено

    $ find . -maxdepth 1 -type f  -size -10M -exec grep "launchpad.net" '{}' ';' -print
    
потому что эта команда эквивалентна команде

    $ find . -maxdepth 1 AND -type f  AND -size -10M AND \ 
      -exec grep "launchpad.net" '{}' ';' AND  -print

поэтому файнд переходит к выполнению следущего условия в строке
только если предыдудшее вернуло TRUE

другое дело что можно печатать название файла сресдвтами самого грепа
и убрать из файнд -print тоеть

    $ find . -maxdepth 1 -type f  -size -10M -exec grep -H "launchpad.net" '{}' ';'


кстати вот еще проблема. как сделать так чтобы ls  
показывал толко папки. для этого нужно заюзать глоббинг.
тоесть хрень баша неимеющая к ls никакого отношения.
есть несколько вариантов

    # ls -1d ./*/
    ./kdm.d/
    # ls -1d   */
    kdm.d/


или 
    # echo ./*/
    # echo */
    
пример
    $ ls -1d /proc/12673/*/
    /proc/12673/attr/
    /proc/12673/cwd/
    /proc/12673/fd/
    /proc/12673/fdinfo/
    /proc/12673/map_files/
    /proc/12673/net/
    /proc/12673/ns/
    /proc/12673/root/
    /proc/12673/task/


    
    
далее readlink
эта штука дает то что ты ей скармилваешь имя файла и если 
он симлинк то эта прога покаызывает на какой файл симлинк показывает
пример

    $ ls -1al
    -rw-r--r--   1 root  root        0 дек 21 01:08 1.txt
    lrwxrwxrwx   1 root  root        7 дек 21 01:08 2.lnk -> ./1.txt

    
    $ readlink 2.lnk 
    ./1.txt

    
видно что readlink он к счатью или к грусти не показывает имя самого 
симлинка.
тогда надо как то к нему это прилепить


    $ find . -type l  -exec bash -c "printf '%s --> %s\n'  '{}'  \$(readlink '{}')"   ';'
    ./2.lnk --> ./1.txt

хочу это подрбнее пояснить  у нас find имеет вид

    $ find . -type l  -exec bash -c   "... {}   "   ';'

exec внутрь вместо {} подставит имя файла
теперь посмотрим что внутри bash -c ""

    printf '%s --> %s\n'      '{}'     \$(readlink '{}')  
    
    
пример сделать тоже самое но не через readlink а через stat

    $ find . -type l  -exec  stat --format="%N"  '{}'  ';'
    './2.lnk' -> './1.txt


| proc
| fd
| file


вопрос вот у нас есть процесс. он пишет в файл. 
при том что ктото этот файл из папки удалил. вопрос - как
нам прочитать этот файл и как нам его восстановить.

очень интересная тема. щас я смоделирую эту ситуацию.
для этого используем билтин баша  exec 
он позволяет запустить команду в окне текущего терминала
вместо баща. но нам это ненадо. еще этот билтин позволяет 
для текущего процесса баша создать новый файловый дескриптор
и чтобы он смотрел на какйото файл на диске. пример

    $ echo -e "1234\n 3456\n 7890\n" > 26.txt
    $ cat 26.txt
    1234
    3456
    7890

    $ exec 9<./26.txt     # (1)      
    $ ls -1al /proc/self/fd
    9 -> '/home/vasya/temp/!003/26.txt'

чтобы команда (1) сработала нужно чтобы между 9 и < небыло 
пробела. 
теперь у нас для текущего процесса в данном случае баша
создан файл дескриптор 9 который ведет в файл 26.txt

теперь из текущего процесса или друного процесса можно удалить
файл 26.txt из папки. но так как есть открыйтый файл дескриптор
для этого файла то связь с файлом останется. 
при этом в /proc статус этого файла станет (deleted) 

$ ls -1al /proc/self/fd
9 -> '/home/vasya/temp/!003/26.txt (deleted)'


так вот самое крутое это то что используя путь 
    /proc/pid/fd/9 
можно по прежнему из этого файла читать. а если он был открыт
на запись то и писать. причем не только из процессы для которого
открыт десериптор 9 а из любого другого процесса запущенного
под root или этим же юзером

    $ echo $$
    26885


    $ cat /proc/26885/fd/9
    1234
    3456
    7890


также можно без прблем этот файо обратно скоировать 
 в папку на диск
 
    $ cp  /proc/26885/fd/9 ~/temp/\!003/28.txt
    $ cat ~/temp/\!003/28.txt
    1234
    3456
    7890

это поразительно!
необычно то что в программу cat подсовыается не путь к файлу 
на диске а путь к файлу через fd в /proc
    
    cat /proc/26885/fd/9
    
но логика в принципе есть. посмотрим что это за файл /proc/26885/fd/9

$ stat /proc/26885/fd/9
  File: /proc/26885/fd/9 -> /home/vasya/temp/!003/26.txt (deleted)
  Size: 64        	Blocks: 0          IO Block: 1024   symbolic link
Device: 5h/5d	Inode: 73058650    Links: 1
Access: (0500/lr-x------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)


это типа файла симлинка. получается что 9 это файл чтото типа обычного
симлинка. а что у нас происходит если мы cat натравливаем читать
из симлинка - у нас ос тогда "перенарпавляет" на сам файл и читает
его. поэтому нас типа cat и срабатывает. 

удивительно.!!!

а вот еще интереный момент.
если у нас у процесса есть открытый файл дескриптор. как его 
можно закрыть

    $ exec 15<&-
    $ exec 15>&-

обе команды равнозначны. они закроют файл и уничтожат файл 
дескриптор. чтобы команда сработала нужно чтобы между 15 и < 
небыло пробела.




| compgen

это какой то странный builtin. в целом в общем говоря 
эта хрень показывает всевозможные билтины и команды доступные 
для запуска из баша. самое сказочное что в интенете куча статей
где этот и так нихера не понятный билтин уебаны также хуево
описывается. вобщем мне стало влом разбираться. с одним ключом
он показывает все билтины баща.  с другим ключом он показывает
еще чтото там баща... херота какая то мало понятная.
нарпимер с другим ключом она покажет все встроенные в баш функции.
фнукция она же ведь нетлоько в скрипте может быть прописана. 
можно задать фнукциб прям в командной строке. а потом ее юзать.
так вот компген покажет какие функции прям щас уже опередедены
для использвания в комндной строке

| --
| double dash

охиреть какая вещь. вот есть команда после нее мы вводим аргумены
в стркое

$ command1 -v -t -b -s  er4   tg4   yu6

все что после command1 это ее аргументы. считывая которые 
команда понимает че мы от нее хотим более конкретно. но! оказывается
аргументы раздаеляются как минимум на два вида , я всю эту полную
муть не стал разбирать так как она как обычно супер хево описана
а читать 200 статей в поисках вычленения поравды нахуй надо. так
вот предположим у нас есть команда у которой есть options (хотя 
как точно оно называется я не знаю ) которые начинаются со знака
минус "-" например -v -t итд.  а есть аргументы которые не являются
опциями они например являются паттернами поиска в файле но! они 
могут выглядеть точно также! и вот чтобы их как то друг от друга
отличать обычно в самих командах (это тоже очень важное дополнение 
об это чуть дальше) добавляется спецопция "--" она обьясняет команде
что все что дальше это не опции с минусом это нечто другое. 
щас покажу на примере

$ grep -v -- "-v" 1.txt

все что идет до -- считается что это опции с минусами, поэтому
первый -v восприниматеся командой grep как опция -v которая говорит
что нужно инвертировать паттерн поиска. все что после -- это уже
все что угодно но не опции с минусом. поэтому второй -v это уже 
сам паттерн поиска, ну а 1.txt это файл в котором надо искать.

самое ссешное что яотработал всю жизнь но на практике я не сталки
вался чтобы мне нужен был -- чтобы разрулить ситуация когда возник
нет такая проблема. все как то и так работало. 

а прикол в том что дейтсивельно без -- нихуя не получается от 
grep добиться того чтобы он -v считал как паттерн а не как опцию 
инвертирования -v. 

тоесть еще раз -- это опция самой команды grep это не globbing баша,
это тоже надо четко понимать. и эта оция она указыает грепу что
все что слева если оно имееть минус то это надо рассматривать 
как опцию. а все что правее -- если оно имеет в себе минус то 
это ни в коем случае не опация , это все что угодно только не это.

подчеркну что если мы хотим в файле найти паттерн "-v" то у нас
никак нихуя не получится это обььяснить grep пока мы не заюзаем --
тоесть
 $  grep -v 1.txt
 $ grep "-v" 1.txt
 $ grep '-v' 1.txt
 $ grep 1.txt '-v'
все это будет работать одинаково гркп будет считать что мы 
вбили опцию -v и просим его инвертировать паттерн поиска. все ! финиш!
и сработает только вот так
$ grep -- "-v" 1.txt
$ grep -- -v 1.txt
только так греп поймет что -v это не опция -v это нечто другое.
а именно паттерн поиска -v. суууууууууууууууууууууукааа!!!

итак если мы юзаем -- то мы сообщаем что все что справа от него
и оно имеет минус это ни в коем случае не опции! а чтото другое!


еще раз подчеркну и еще одну важную вещь. опция -- это не башовская
фича глоббинг . нет! это опция которую должна поддверживать 
сама команад которую мы вызываем. если сама команад не понимает
если у нее нет такой опции значит ее нет. значит у этой команды
небывает таких проблем чтобы у нее были неопции которые имеют 
минус и он совпадает с опцией с минусом.

у самого баша тоже есть опция --. он ее позволяет юзать башовских
билтинов. но врдое бы не для всех. важно понять что от того что 
сам баш для своих билтинов поддерживает -- это не значит что это 
как то поможет если мы присунем эту опцию к комаде которая этой опции
не имеет. понянтно?

что смешное это то что в манах многих команд соверенно не упоми
нается что они поддерживаеют опцию -- но они сука ее поддверживают.
пример я хочу сокпироавть файл в файл с именем "-e"

$ cp 1.txt -e

оно выдаст ошимбку потому что у cp есть оация "-e" поэтому cp 
не понимает хер ли я опцию "-e" использую и где имя файла в который
нужно копировать файл 1.txt
а вот если вот так сделать

$ cp -- 1.txt -e

то все сработает. cp понимает что все что правее -- это не опции
это нечто другое потому cp понимает что "-e" это имя файла.
пиздц

я нихрена с подобной хренью не сталкивался.

об этом вот здесь более менее я прочитал https://unix.stackexchange.com/questions/11376/what-does-double-dash-mean

тоже самое если я поробую удалить файл "-e"

$ rm -e
rm: invalid option -- 'e'

и сработате только после вот кода мы вставим --

$ rm -- -e


так вот у kubectl тоже есть ключ --

$ kubectl exec --stdin --tty shell-demo -- /bin/bash

и он обозначает для кубцтл что левее -- идут аргументы запуска 
самого кубцтл а все что правее -- это идет команда и ее параметры
которые будут запущены внутри контейнера!!!
тоесть еще раз -- оьясняет кубцтлю что левее -- идут опции запуска
самого кубцтл а правее -- идут параметры того что нужно запустить
внутри контйенера. чтобы было понятно чтобы было однозначно и четко.
жалко только то что описано это все кратко что чтобы понять все это 
нужно поебаться внаале с поиском и осознанеием.

в целом в -- никаго чуда нет. просто как обычно горе описываетели
забеали все мозги на пусто месте. суки






    
$$$$$$$$$$$$$$$$$$$
<---- остановился тут

вопрросы:

| chapter 3. special characters


# обозначает комментарий
если вначале файла (первые два байта) вставить #! то 
это совсем не комент это ша банг хрень.
и тут я попал на проблему - как работает шабанг.
это привело меня на следущую проблему что у ОС есть loader
далее я напоролся на то что loader это call back handler у
сисколла execve.
теперь мне надо понять что такое колл бек. пиздец
это ведет на functions pointer а это ведет на просто поинтеры 
в C. пиздец





    
d)  Using degraded feature set (TCP) for DNS server 192.168.0.1
на обоих буках
https://superuser.com/questions/1676584/using-degraded-feature-set-tcp-instead-of-udp-for-dns-server/1791986#1791986

dd) https://superuser.com/questions/753163/wheres-the-man-page-for-the-sizeof-c-function


    
0) разобрать С файлы


0000000)

stat --printf="%A\t%a\t%h\t%U\t%G\t%s\t%.19y\t%n\n" * | numfmt --to=iec-i --field=6 --delimiter='     ' --suffix=B
    
00000)

find /var/crash/. ! -name . \ 
                    -prune  \ 
                    -type f \( \( -size 0 -a \! -name '*.upload*' -a \! -name '*.drkonqi*' \) \
                    -o -mtime +7 \) \
                    -exec rm -f -- '{}' \;
                    

find /var/crash/. ! -name . \
                    -prune  \
                    -type d \
                    -regextype posix-extended \
                    -regex '.*/[0-9]{12}$' \( -mtime +7 \) \
                    -exec rm -Rf -- '{}' \;



                    
                    
000) chmod go=  /etc/file1  ???

 
0) порверить ovh подключили они или нет vps
удалить ovh.odt с  обоих компов
занести его параметры на обоих компвх а data3
в gmail удалить открытые пароли и вставить aes-cbc или aes-gcm


2) на счет глобинга дочитаать 
    https://mywiki.wooledge.org/glob
    https://tldp.org/LDP/abs/html/globbingref.html#FTN.AEN17592

2.1) проработваь массивы
    https://ostechnix.com/bash-indexed-array/
    
3) продолжить разбор
    https://tldp.org/LDP/abs/html/fto.html

3.1)
    unset array[1]
    unset -v "array[1]"
    array=([1]=*)

1.5) непонятно только нахер это делать через cpio.

1.6) man install ?
походу это аналог cp но можно указать маску пермишнс
которую нужно установить на dest файл
    
1.5) две ссылки  с ответом
    https://stackoverflow.com/questions/27800726/ls-terminated-by-signal-13-when-using-xargs/77637318#77637318
    https://superuser.com/questions/554855/how-can-i-fix-a-broken-pipe-error


2) разобрать три ссылки
    https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html
    https://stackoverflow.com/questions/71284062/how-to-printf-fixed-number-or-digits-in-floating-in-bash
    https://unix.stackexchange.com/questions/589475/how-can-i-exclude-and-when-listing-only-hidden-items


    
3.1) man bash читать

set [+abefhkmnptuvxBCEHPT] [+o option-name] [arg ...]


3.a) man login 

3.2) sihup vs sigterm
    
3.5) /usr/bin/nohup 
    
4) проработать info coreutils 
посмотреть какие там есть утилиты

5) c beginnerr guide pdf книжка





##  



=== недоделано

$$$$$$$$$$$$$
$$$$$$$$$$$$$
$$$$$$$$$$$$$

вопросы:
- вернуть обратно модуля ядра чтобы coretemp опять заработал
- thermal zones
- yaml формат  в thinkfan
- <<<



- а как происходит запись в файл сразу двух процессов?
как при этом работает
$ : > file



-  изучить bash advanced guide
