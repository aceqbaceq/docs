bash

| приколы

приколы баша
$ echo !4
echo ps aux | grep sleep
$ echo !0
bash: !0: event not found
эта хрень показывает команды из истории команд


| tr

эта комнда ищет паттерн и меняет его на другой

$ echo " output=10; input=16; A0" | tr [:lower:] [:upper:] 
 OUTPUT=10; INPUT=16; A0


$ echo "aaa bbb " | tr "a" "D"                             
DDD bbb 



эта команда он подлая. об этом можно прочитать в info tr
вот пример

$ echo "b" | tr  bbbbb  12345
5

вчем подлость команды tr : у нас в паттерне есть несколько b возникает вопрос
когда мы находим b в нашем слове то какой b использовать? тот который b в 1 превращает
или b который в 2 превшращает? или b который в 5 превращает?
ответ такой что берется самый последний b. поэтому все b пропускаются в шаблоне
и берется последний b кторый превращает b в 5.

еще пример

$ echo "a"  |  tr    aaaaaaaaaa 1234567890
0


тоесть у нас есть шаблон aaaaaaaaaa у нас естт исходное ссобщение 'a'
возникает вопрос какой a нужно брать из шаблона. овтет последний.
потом смотрим на какой символ мапится последний a  в шаблонке ответ а ноль.


прмиер

$ echo ooops not good | tr oops nice
iiice nit giid

как это рабооает. 
у нас есть шаблон "oops" у нас есть слово "ooops"
в шаблоне берем последний "o" он мапитсят в "i" получается

[ooo]ps -> [iii]ps

остатеся вопрос с ps он мапиисят напрямую поэтому 

[ooo][ps] -> [iii][ps] = iiips

далее берем слово "not"
берем шаблон "ooops" 
в шаблоне "n" нет. есть "o" но в шаблоне "o" несколько. мы берем последнее "o"
второе "o" мапится в "i"

потмоу что o[o]ps n[i]ce

значит n[o][t] --> n[i][t]
бквы t нет в шаблоне значит t остается без изменений значит

not -> nit

берем слово "good"
ни g ни d нет в шаблоне они без изменений. 
буква o есть  в шаблоне. их несколько в щаблоне мы беерм послнее o в щаблрне оно маится в
i значит

g[oo]d  --> giid

значит в итоге 

iiips nit giid

в целом намой взгляд достоачно неинтуитивная и ебанутая команда этот tr


| special variables $0 $1 $@  $# $* $? $$ $!

`$0` – The name of the script being executed.
`$1-$9` – The first nine command-line arguments.
`$#` – The number of command-line arguments.
`$*` – All command-line arguments as a single string.
`$@` – All command-line arguments as an array.
`$?` – The exit status of the last executed command.
`$$` – The process ID of the current shell.
`$!` – The process ID of the last background command.


рассмотрим $0
я не согласен то о чем везде пишут что $0 это имя скрипта.
посмотрим

$ echo $0
bash

$ /bin/bash
$ echo $0
/bin/bash


$ ln -s /bin/bash ./b-lnk
$ ./b-lnk
$ echo $0
./b-lnk


$ ln -s ./b-lnk ./c-lnk
$ ./c-lnk
$ echo $0
./c-lnk

отсюда видно что $0 эта переменная показывает каким образом был запущен процесс.
а именно его такой параметр как /proc/$$/cmdline

/proc/self vs /proc/$$/ (self это не перменная. это симлинк в /proc/)

запускаем чтото в баше . тогда он себя форкает через сисколл(просит об этом ядро тоесть)то создает дочерний процесс
а вот если в баше прога зпускатся через exec то баш взывает сисколл exec тоесть управлениеп
передаетая ядру. и ядро замещает усовно говорят код баша в процессе в котором крутится баш 
на код вызываемой программы.  

мы импользуем exec когда не хотим создавать новый процесс. а хотим запустиьт прогу
в рамкаж уже этого процесса. 



--
вот так верно

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c", "sleep 120"]

а так полет нахер

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c sleep 120"]

--
вот так верно

docker run --rm --name t1 -it    --entrypoint  "/bin/bash"   ubuntu  -c "sleep 120"

а так полет рахер

docker run --rm --name t1 -it    --entrypoint  '/bin/bash -c "sleep 120"'   ubuntu  
отому что в доках дкоера написано что --entrypont должно сдежать татолько
путь к бинарнику\скриту. но не к параметрам. параметры пишктая в самом справава



==

| -
| ~-

в баше любили повыебвыаться.

если мы в качестве пути укажем "-" то баш подставит вместо этого $OLDPWD
где OLDPWD это сохранненный есть предыдущая папка в которой ты был.
но эта хрень раротботет только с встроенным билтином cd и только в единствнной форме

$ cd -
эквивалентно
$ cd $OLDPWD

при этом вот такое уже нераобтеает

]$ cd -/tmp
bash: cd: -/: invalid option
cd: usage: cd [-L|[-P [-e]] [-@]] [dir]

в эхо это тоже неработает

$ echo -
-


втора хрень "~-" она более универсальная. она раобтотает уже нетолько с cd
но и скажем с echo 

$ echo $OLDPWD
/
[vasya@lenovo //]$ cd ~-
[vasya@lenovo /]$ echo ~-
//


пиздец доблеблы в этом баш. выбеонщики

нашел этот все зесь = https://unix.stackexchange.com/questions/330876/difference-between-cd-and-cd
===
| bash
| redirect
| exec

bash
io redirect

(для начала ознакомился с этим https://tldp.org/LDP/abs/html/io-redirection.html)

разбереся как работает эта команда
       # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3

для начала
немного отойдем в сторону что будет если ввести команду
$ cat > 56.txt
а будет вот что. команда будет ждать ввода текста со стандартного ввода.
тоесть можно сидеть и набирать текст. когда хотим закончить набор то жмем Ctrl+D.
и этот текст набранный в терминале на экране будет записан в файл.

получается форма вида

# echo "asd" > /tmp/1.txt 
это укороченная форма команды
# echo "asd" 1 > /tmp/1.txt

и команда вида
# cat < 1.txt
это укороченный аналог
# cat 0 < 1.txt
(взял отсюда https://tldp.org/LDP/abs/html/io-redirection.html)

еще важная хуйня про io redirect
надо обязательно дескриптор файла ставить рядом без пробелов со знаками ">","<" итп.
тоесть

$ dfrtr 2>4.txt
$ cat 4.txt
dfrtr: command not found

тоесть видно что редирект сработал. мы ввели несуществующую команду.
при этом канал ошибок был заредиректен на файл 4.txt
видно что мы ввели "2>..." тоест между 2 и ">" нет пробела. 
такой редиректо сработает.

$ dfrtr 2 >4.txt
dfrtr: command not found

а этот редирект неработает. потому что у нас между 2 и ">" стоит пробел.

далее . разберем поподробнее пример
    $ dfrtr 2>4.txt

что в нем интересно это как оно выполняется.
у нас есть баш процесс и мы его просим запустить команду "dfrtr"
баш процесс выполняет сисколл и просит ядро создать новый процесс самого себя. когда клон исходного процесса
будет создан в форме нового процесса то баш в новом процессе ищет среди $PATH бинарник с именем "dfrtr"
ненаходит его и посылает на sterr ошибку. если бы бинарник был бы найден то баш склонированного процесса
выполнил бы еще один сисколл который просит ядро заменить в текущем процессе бинарник баша на бинарник dfrtr.
соотсвтвенно вопрос - кто кидает в stderr ошибку что файл ненайден - баш в склонированном процессе или ядро?
как я понимаю имеено баш запускает ряд сисколлов stat в разных папках которые у него прописаны в $PATH
и все сисколлы сообщают бинарнику баша что там такого файла нет. тогда бинарник баша пишет в sterr 
сообщение о том что файл ненайден. таким образом именно бинарник баша кидает на stderr сообщение об ошибке
я не ядро. потому что важно было понять кто занимается отправкой сообщений на stderr юзерская программа
или само ядро. 
вот доказательство

$ strace  bash -c "kuku"
...
stat(".", {st_mode=S_IFDIR|0775, st_size=1011712, ...}) = 0
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/sbin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/sbin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/bin/kuku", 0x7ffcfd0c62a0)   = -1 ENOENT (No such file or directory)
stat("/sbin/kuku", 0x7ffcfd0c62a0)      = -1 ENOENT (No such file or directory)
stat("/bin/kuku", 0x7ffcfd0c62a0)       = -1 ENOENT (No such file or directory)
stat("/usr/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/snap/bin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)

тоесть видно что бинарник баша ищет бинарник kuku во всех папках которые есть у него в $PATH
и ничего ненаходит.
...
write(2, "bash: kuku: command not found\n", 30bash: kuku: command not found
) = 30

и тогда бинарник баша сам лично через сисколл write пишет в дескриптор "2" об ошибке
я совершенно не утверждаю что в 2 неможет писать само ядро. но в данном случае ошибку генерирует
сам юзерский процесс.

так вот вовзращаемся к примеру
        $ dfrtr 2>4.txt
рассмотрим более простой пример для начала
        $ dfrtr
        dfrtr: command not found

кто гененриует ошибку? ответ склонированный бинарник баша генерирует.
у нас наш текущий процесс баша сам себя клонирует. дальше в дело вступает клонированный баш.
он начинает искать бинарник dfrtr по всем папкам прописанным в $PATH
ненаходит. и тогда он склонированный бинарник баша пишет в 2 о том что файл ненайден.
таким образом отвечаю на вопрос - если команда не найден то кто генерирует ошибку?
возвращаемся к примеру
         $ dfrtr 2>4.txt
наш текущий баш склонирует самого себя в новый процесс через сисколл к ядру.
плюс наш исходный баш попросит ядро чтобы при создании нового процесса его дескриптор 2 указывал 
не на pty файл ( не на терминал как это обычно бывает)  а на файл ./4.txt
таким образом привязку 2 к 4.txt для нового процесса делает ядро по просьбе родительского баша.
дочерний баш к этому не имеет никакого отношения. дочерний единственное что сделает это напишет в 2 
что файл не найден. гениально. мудота та еще...
важно еще то что такого рода редирект файловых дескрипторов происходит не для исходного процесса баша 
а исключительно для новых порождаемых процессов. это тоже важно отметить. 

теперь фундаментальный вопрос а как нам изменить привязку файловых дескрипторов не для новых 
порождаемых процессов а для текущего процесса в котором крутится bash
в этом нам поможет баш билитн exec


баш builtin exec
что он делает.
по дефолту если мы запускаем команду в баше то баш это процесс как любой другой.
когда мы запускаем команду то баш создает новый процесс и в нем уже запускает нашу команду.
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
тоесть видно что номер баш процесса 31410
когда мы в нем запустили команду pstree то баш создал новый процесс 31426
так вот exec заставляет бащ не создавать новый процесс а запустить эту команду в текущем процессе
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
$ exec sleep 120
$ pstree -Asp 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---sleep(31410)
видно что процесс 31410 остался но там уже не баш а наша команда. а нового процесса нет.

тут я добавлю полезняшку про pstree. 
если цепочка очень длинная то pstree порежет цепочку. поэтому нужно добавить флаг -l
чтобы цепочка былабы показана по всей длинне чтобы он не обрезад

обрезанный вид
$ pstree -Asp 9174
systemd(1)---lightdm(4560)---lightdm(4814)---lightdm(4930)---lightdm(4931)---lxsession(4932)---pcmanfm(5071)---lxterminal(6046)---b+

необрезанный вид
$ pstree -Aspl 9174
systemd(1)---lightdm(4560)---lightdm(4814)---lightdm(4930)---lightdm(4931)---lxsession(4932)---pcmanfm(5071)---lxterminal(6046)---
---bash(3676)---mc(3687)---bash(3689)---find(9174)---sleep(9176)


как видно не создавание нового процесса было выполненно через баш билтин exec . в виде

$ exec команда

итак "exec команда" не порождает новый процесс а в текущем процессе заменяет бинарник.
есть надежда что подключение io redirect вкупе с exec позволит нам изменить привязки файловых
дескрипторов для текущего процесса.

$ echo $$
32624
$ exec sleep 130 2>3-err.txt

итак у нас был баш процесс 32624 со стададартной привязкой его дескрипоров 1,2,3 к терминалу
далее мы говорим что в текущем процессе заменить баш на sleep и для этого процесса (для того же самого)
задать что файловый дескриптор 2 должен смотреть на файл 3-err.txt

проверяем
$ ls -1al /proc/32624/fd
total 0
dr-x------ 2 vasya vasya  0 окт  4 09:00 .
dr-xr-xr-x 9 vasya vasya  0 окт  4 09:00 ..
lrwx------ 1 vasya vasya 64 окт  4 09:00 0 -> /dev/pts/21
lrwx------ 1 vasya vasya 64 окт  4 09:00 1 -> /dev/pts/21
l-wx------ 1 vasya vasya 64 окт  4 09:00 2 -> /home/vasya/temp/3-err.txt

и это действительно сработало!
процесс по номеру не поменялся. зато его привязка для дескриптора 2 поменялась.

попробуем на этом фоне более интересный пример
запустить баш из баша при этом перенаправить его 2 в 5.txt
для начала я хотел показать одну важную вещь. вот  у нас есть баш процесс.
я думал что prompts приглашение этот процесс пишет в 1 тоесть в stdout
а оказалось что он его пишет на stderr! показываю

$ echo $$
31668
$ bash 1>7.txt
таким макаром я запустил новый процесс баша и его stdout я завернул на файл 7.txt
$ 
при этом как видно у меня на экране по прежнему присуствует prompt тоесть 
этот prompt он пишется процессом как я уже сказал не на stdout а на stderr

открываю другой терминал и проверяю что новый баш имеет то  редирект в файл который я сказал
(другой терминал)$ $ cat 7.txt 
2661
(другой терминал)$ pstree -Asp 2661
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31668)---bash(2661)
видно что новый баш это чайлд от головного баша
(другой терминал)$ ls -1al /proc/2661/fd
lrwx------ 1 vasya vasya 64 окт  4 10:27 0 -> /dev/pts/22
l-wx------ 1 vasya vasya 64 окт  4 10:27 1 -> /home/vasya/temp/7.txt
lrwx------ 1 vasya vasya 64 окт  4 10:27 2 -> /dev/pts/22
lrwx------ 1 vasya vasya 64 окт  4 10:27 255 -> /dev/pts/22
четко видно что наш дочерний баш имеет stdout завернутый в файл

так вот аналогично легко убедться что если мы запустим баш у которого stderr будет завернут
в файл то  у нас приглашение баша исчезнет с экрана потому что оно теперь будет писаться не в терминал а в файл
$ bash 2>8.txt

и все у нас на экране больше нет prompt

так вот до этого моменты мы создавали дочерний процесс баша у которого был настроен редирект одного из 
файл дескрипторов в файл. 
теперь сделаем тоже самое без создавания дочернего процесса.
в первом терминале запускаем
    $ echo $$
    2963
    $ exec bash 1>10.txt
    $ 

во втором терминале проверяем
$ pstree -Asp 2963
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(2963)
$ ls -1al  /proc/2963/fd 
lrwx------ 1 vasya vasya 64 окт  4 10:31 0 -> /dev/pts/23
l-wx------ 1 vasya vasya 64 окт  4 10:31 1 -> /home/vasya/10.txt
lrwx------ 1 vasya vasya 64 окт  4 10:31 2 -> /dev/pts/23
lrwx------ 1 vasya vasya 64 окт  4 10:32 255 -> /dev/pts/23

видно что исходный процесс 2963 не имеет чайлдов и что его 1 перенаправлен в 10.txt
таким макаром мы научились текущий баш процесс менять таким образом чтобы у него менялась 
привязка его файл дескрипторов. вот эта волшебная команда
        $ exec bash 1>10.txt
так вот в описании билитина exec написано что это можно сделать еще короче.
цитирую
$ exec --help
exec: exec ... [command] ... [redirection ...]
...
 If COMMAND is not specified,
    any redirections take effect in the current shell.

тоесть тут написано что если не указать никакой команды то получается что он автоматом меняет дескрипторы
указанные в [redirection] для данного процесса. 
проверяем
    $ echo $$
    3208
    $ exec 1>11.txt
    $ 

проверяем в другом терминале
$ pstree -Asp 3208
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(3208)
$ ls -1al  /proc/3208/fd
lrwx------ 1 vasya vasya 64 окт  4 10:39 0 -> /dev/pts/26
l-wx------ 1 vasya vasya 64 окт  4 10:39 1 -> /home/vasya/11.txt
lrwx------ 1 vasya vasya 64 окт  4 10:39 2 -> /dev/pts/26
lrwx------ 1 vasya vasya 64 окт  4 10:39 255 -> /dev/pts/26

и действительно да. процесс 3208 не имеет никаких чайлдов. и его 1 имеет редирект на файл!
гоча!

я бы еще как сказал хотя это не совсем верно. что если мы никакую команду не подставляем в exec
то баш сам автоматом как бы подставляем bash тоесть  как бы 
    exec 1>11.txt = exec bash 1>11.txt
хотя это не совсем так. потому что в первом случае он не меняет бинарник в памяти а во втором случае
он удаляет старый бинарник и сует в процесс новый бинарник. (ксатти сказать процесс получается это как бы коробка (типа фреймворк) плюс начинка в виде бинарника)


двигаем дальше. вот еще интересный пример который нам пригодится
$ echo $$
3554
$ exec bash 12<>12.txt
$ echo $$
3554
[vasya@lenovo ~]$ ls -1al /proc/$$/fd
lrwx------ 1 vasya vasya 64 окт  4 10:49 0 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 1 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 12 -> /home/vasya/12.txt
lrwx------ 1 vasya vasya 64 окт  4 10:49 2 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 255 -> /dev/pts/29

мы говорим чтобы в нашем текущем процессе был заменен бинарник на баш
и чтобы  в нашем процессе был открыт новый файловый дескриптор с номер 12 и чтобы этот файловый дескриптор
был связан с файлом 12.txt который будет открыт с флагами и на чтение и на запись.
что примечательно в этой команде. примечательно то что мы можем изменить для данного процесса
число его файловых дескрипторов. было 0,1,2,255 (правда какого хрена тут делает 255 непонятно. вернее понятно.
я же запускаю bash из некоего другого процесса скажем это gnome-terminal или xterm или из под граф оболочки 
и открытые файловые дескрипторы в родительском процессе автоматом наследуются и дочерним процессом вобщем щас нам этот 255 неважен) а стало 0,1,2,255,12.
таким макаром мы можем "прикрепить" к процессу дохрена файловых дескрипторов и дохрена открытых файлов.
при том что самому бинарнику процесса на этот абсолютно плевать. вот эти открытые файлы , прикрепленные файловые
дескрипторы они бинарник ни к чему не обязывают. это как в квартире понаделать больше окон. 
если процесс нехочет ни читать с данного файлового дескриптора ни писать в него то его никто к этому не обязывает. это как у машины добавить запасных колес. или в ящике понаделать новых дырок. тот кто сидит в яшике (бинарник)  может пользоваться этими дырками а может и нет. опять же что интересно у нас обычно один процесс родительский порождает некий дочерний процесс и родитель может заказать для дочернего процесса понаоткрывать 
для него кучу файлов. но дочернему процессу это может быть глубоко фиолетово. он может пользоваться открытыми 
для него файлами а может и нет. это никак не влияет на него. 
что еще важно это вот значок  "<>" он на самом деле никакого мистического значения не имеет. он на самом деле 
только значит то что в сисколле будет прописано что открываемый файл открывается с флагами "R+W" тоесть 
и на чтение и на запись. сразу в догонку скажу что значок ">" говорит через сисколл ядру что нужно открыть файл 
с флагом "W" а значок "<" говорит ядру что файл нужно открыть с флагом "R"
тоесть то что изначально называется редиректом. это корявое определение. это не редирект это команда ядру 
на то  с каким флагом нужно открыть файл. тоесть 
        $  echo 1 1>4.txt
комбинация "1>4.txt" говорит башу как ему выстроить сисколл который он будет пулять в ядро. 
сисколл должен быть такой что - надо открыть файл 4.txt причем с флагом "W" и привязать этот файл к дескриптору 1. ну да.. на последнем этапе можно скзаать что мы имеем дело с редиректом. но важно подчеркнуть что значки
"<" и ">" и "<>" их смысл не только редирект но и с каким флагом открыт файл на который они ведут. 
">" =  W
"<" =  R
"<>" = RW

еще пример 
        $ echo "abc" 12<>5.txt
здесь ксати тоже интересно. дело в том что echo это билтин баша. поэтому ему ненужно себя клонировать.
а он выполняет команду ровно в текущем процессе. так вот для текущего процесса будет открыть файл 5.txt
в режиме "RW" и будет создан файловый дескриптор 12 который будет прикреплен к текущему процессу 
сам же echo ясен банан выплюнет свой "abc"  в дескриптор 1. тоесть ему этот открытый дескриптор 12 
в целом нахрен не сдался. просто мы делая одно одновременно сделали и другое
причем насколько я понимаю баш он умный и он откроет этот файл и создаст дескриптор но как 
только билтин закончит работу то баш автоматом закроет файл и уничтожит дескриптор. вот 
доказательство
    $ echo "abc" 13<>13.txt
    abc
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:12 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 2 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:25 255 -> /dev/pts/31
тоесть еще раз так как echo это билтин то никого нового процесса создано не будет. все
будет делать в рамках текущего баша. поэтому я и смотрю список открытых файлов для текущего процесса.
и видно что никакого дескриптора 13 нет и в помине. он был создан и тут же обратно удален.
я так это понимаю.

совершенно другой коленкор когда мы через баш запускаем некую внешнюю программу и просим баш прилепить к ней
открытый файл. баш составит нужный сисколл для ядра. и мы все будем иметь.
    $ sleep 130 14<>14.txt

с другого терминала смотрим
    $ ps aux | grep sleep
    vasya     4806  0.0  0.0  14580   892 pts/31   S+   11:28   0:00 sleep 130
    $ ls -1al /proc/4806/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:29 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 14 -> /home/vasya/14.txt
    lrwx------ 1 vasya vasya 64 окт  4 11:29 2 -> /dev/pts/31

тоесть у нас баш себя клонировал тоесть попросил ядро создать новый процесс. причем при клонировании попросил 
ядро чтобы дочерний процесс имел открый файл 14.txt через дескриптор 14.
далее баш в дочернем процессе попросил ядро через  сисколл заменить свой
бинарник на sleep.
поэтому все так выглядит
еще раз подчеркну что значок "<>" в конечном итоге означае то что файл 14.txt открывается с флагами и на чтение
и на запись. флаг "<" открывает файл на чтение только, флаг ">" открывает файл на запись только
причем имеется ввиду для данного процесса. ничто мне не мешает из другого процесса попросить ядро открыть этот файл с другими флагами. тоесть скажем наш процесс открывает файл только на запись. а с другого процесса я прошу
ядро открыть файл на чтение. и таким макаром я спокойно читаю то что пишет туда первый процесс.

также попутно я покажу докажу что когда баш запускаем внешний бинарник то он создает новый процесс 
клонирует себя а если мы запускаем баш билтин то новый процесс не создается.
я запутил баш с номером процесса 4309
в соседнем окне я запустил strace
$ sudo strace -p 4309 -e clone,fork,execve
strace: Process 4309 attached

и в первом окне я запустил ls -1
и мне strace нарисовал
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fe0cc338a10) = 4589

а потом я в первом окне запустил echo 1
и мне strace ничего не нарисовал
это все доказывает

теперь переходим к интересному.
зная все что мы узнали выше я открою файл /dev/cpu_dma_latency
в текущем баше так чтобы он оставался открытым
    # exec bash 16> /dev/cpu_dma_latency;
    # ls -1al /proc/$$/fd
    lrwx------ 1 root root 64 окт  4 11:37 0 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:37 1 -> /dev/pts/32
    l-wx------ 1 root root 64 окт  4 11:38 16 -> /dev/cpu_dma_latency
    lrwx------ 1 root root 64 окт  4 11:37 2 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:38 255 -> /dev/pts/32

ну или можно было короче написать
    # exec 16> /dev/cpu_dma_latency;
мы открыли /dev/cpu_dma_latency на запись и прикрепили его к процессу через дескриптор 16
показываю чему он равен прям щас 
    # cat /dev/cpu_dma_latency  | od -t x1
    0000000 00 94 35 77
    0000004

теперь можно его изменить вот так
    # echo -en "0x00000258" 1>&16
здесь так как echo у нас шлет свои данные на stdout тоесть в 1 то я перенаправил в 16.
на low level уровне это работает так что по дефолту баш юзает сискол
write (1,"текст")
а когда мы ему дали подсказку то он делает
write(16,текст)

проверяем что сработало
# cat /dev/cpu_dma_latency  | od -t x1
0000000 58 02 00 00
0000004
да сработало получается.
такой вывод наоборотный потому что в оперативку много байтовой число пишется в little endian формате.
об little endian  читай в ext4.txt

также отмечу вот это "1>&16" знак амперсанда говорит бащу что мы делает перенаправление не в файл  с именем 16 на файловой системе а в файловый дескриптор 16. это две большие разницы.
ксати я щас попробую сделать запись в несуществующий дескриптор
    # echo -en "0x00000258" 1>&28
    bash: 28: Bad file descriptor
все верно. пошел нахер


итак еще раз
что было сделано
     # exec 16> /dev/cpu_dma_latency;
     # echo -en "0x00000258" 1>&16
для текущего процесса баща был открыт файл /dev/cpu_dma_latency на запись. и прикреплен к процессу через
дескриптор 16. фишка в том что он будет висеть открытым пока я его сам руками не закрою.
далее я делаю запись в этот файл через подскажу башу что писать надо не в дескриптор 1 как он это обычно
делает по дефолту а в дескриптор 16. после записи файл который скрывается за дескриптором 16 продолжает висеть открытым.
тут еще раз также подчеркну что когда мы работаем с io redirect то между номером дескриптора и значком
редиректа категорически нельзя чтобы были пробелы. тоесть 
         # exec 16> /dev/cpu_dma_latency;   # правильная команда

         # exec 16 > /dev/cpu_dma_latency;  # НЕправильная команда
         сразу вылезет ошибка. потому что баш будет интепретировать эту команду вот так
         # exec 16 1> /dev/cpu_dma_latency;
тоесть он будет пытаться найти бинарник с именем "16", заменить в текущем процессе баш этим бинарником
и заменит файловый дескриптор 1 чтобы он вел не на терминал а на файл /dev/cpu_dma_latency
тоесть это совершенно не то что нам надо. поэтому 
        "16> /dev/cpu_dma_latency" = правильная хрень. обозначает что мы открываем файл /dev/cpu_dma_latency
        на запись и в для процесса прокидываем этот файл как дескриптор номер 16

        "16   > /dev/cpu_dma_latency" = неправильная хрень, если быть более точным она тоже правильная но она делает совершенно другое. она обозначает вот это 
        "16   1> /dev/cpu_dma_latency" 
то есть мы открываем файл /dev/cpu_dma_latency на запись и привязываем его к процессу через дескриптор 1.
и плюс к этому у нас бинарник имеет имя 16. 
поэтому смысл этих двух команд совершенно разный

а вот после значка ">" уже неважно есть пробелы или нет. оно все будет трактоваться одинаково тоесть
    "16> /dev/cpu_dma_latency"
    "16>/dev/cpu_dma_latency"
    "16>        /dev/cpu_dma_latency"
это все одно и тоже.
в целом конечно это дебилизм потому что сегодня я это помню. а завтра уже совершенно нет.


возвращаемся НАКОНЕЦ к нашей исходной задаче
нужно понять как это работает
        # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
кстати сразу замечу что 3 это не stderr (как я иногда глючу так думая), stderr это 2
а 3 это вобще ничего. потому что stdin это 0. stdout это 1 и stderr это 2
немного преобразуем это выражение
        # exec bash 3<> /dev/cpu_dma_latency; echo -en "0x00000258" 1>&3
строго говоря оно немного отличается от оригинала но по конечному результату это одно и тоже
зато все указано в явном виде и поэтому более понятно 
далее эту команду можно эквивалентно переписать как 
        # exec bash 3<> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
во первых я считаю что символ "<>" он излишен потому что мы собираемся писать туда а читать нет.
но в целом не особо важно конечно. но я считаю что вот это более грамотно.
поэтому преобразуем 
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
теперь все понятно. разберем его.
мы открываем файл на чтение /dev/cpu_dma_latency и прикрепляем этот  файл через дескриптор номер 3 у текущего баша. фишка в том что  файл будет висеть постоянно открытым все время. пока мы не закроем его 
специально сами руками. теперь если мы из баща будем писать в дескриптор 3 то оно будет лететь в файл
далее мы через echo посылаем число но не в канал 1 как это баш делает по дефолту а в канал 3.
таким макаром мы записали  число в /dev/cpu_dma_latency
казалось бы мы могли бы сделать проще вот так 
        # echo -en "0x00000258"  /dev/cpu_dma_latency
но это не привело бы нас к тому что нам надо потому что 
этот файл /dev/cpu_dma_latency он хитрый.нам надо чтобы файл оставался все время открытым после 
записи. если мы это делаем сразу через эхо. то как только эхо закончит то файл закроется и ОС перезапишет
значение на дефолтовое. так устроен этот файл. а вот верхний мудежный способ как раз дает то что после записи в эхо файл будет продолжать оставаться открытым и наше новое значение будет сохраняться. 
получается одна маленькая строчка из интернета но чтобы ее понять нужно диссертацию написать.
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
при этом получается пока наш процесс баша будет на компе сущестовать файл будет открыт
и наше записанное значение будет жить.
как только мы текущий баш процесс закроем. файл тоже закроется и значние будет со стороны ос перезаписано
на дефолтовое.
в принципе можно было сделать и вот так
        # bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
без выебонов с exec
у нас просто напросто создасться в системе +1 процесс с баш и только и всего. 
так что если расхлобучить все эти выебоны которые накручены в исходном выражении то вся фишка лишь в том
что для того чтобы открыть файл на постоянной основе надо заюзать вот это выражение
            # bash N> file
и только и всего.
тогда у нас  в системе будет баш процесс  у которого будет постоянно открытый файл "file" на запись
через дескриптор N. вот и все.

далее
теперь моя задача в том чтобы найти все процессы в которых открыты файл дескрипторы
ведущие на файл /dev/cpu_dma_latency
и закрыть все эти файл дескрипторы

# lsof -u root | grep cpu_dma_latency
bash       5106 root   16w      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6454 root    3u      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6828 root    3w      CHR              10,59      0t0        162 /dev/cpu_dma_latency

здесь видно какой процесс имеет этот файл открытым, через какой дескриптор, и  в каком режиме
открыт файл (r,w,rw)

и тут выясняется прикол (из того что я вижу навскидку из интернета) что нет такого красивого 
способа чтобы под рутом запустить команду и заставить позакрываться эти файловые дескрипторы. 
хаха.
тоесть вижу что есть только три неудобных способа
один это подключаемся к процессу через gdb и там запускаем команду на закрытие файла.
второй способ разыскать в граф оболочке наши конкретные терминалы с этими прям башами 
и уже из под них запускать команды на закрытие файлов
а ну и третий самый лоховской способ это поубивать эти процессы и автоматом и файлы закроются

я пойду вторым способом.
он состоит вот в чем.
причем в методичке там запаривают мозг что в завимости в каком режиме был открыть файл 
чтени, запись его нужно гасить по разному на самом деле нихрена. нам совершенно неважно как был открыт файл
    # exec 3> file
    # exec 3< file
    # exec 3<> file
нам на это наплевать 
во всех случаях гасим дескриптор совершенно одинаково
    # exec 3>&-
либо
    # exec 3<&-
а вот вариант 
    # exec 3<>&-
абсолютно нерабочий.
ПРИЧЕМ в данном случае абсолютно нельзя чтобы был пробел между ">" и "&-"
либо между "<" и "&-"
тоесть пробел запрещен не толко слева от знака редиректа но и справа
сразу выдаст ошибку!

поэтому в случае редиректов я бы советовал ни слева от знака редиректа ни справа не оставлять пробелов
чтобы не получать проблем на ровном месте


я в итоге предпочитаю гасить через 
    # exec 3> &-


метод закрытия файла через gdb
# gdb -p $PID
# p close($FD)

далее
интересный пример
    # $ cat /etc/passwd >&-
эквивалент этой команды
    # $ cat /etc/passwd 1>&-
так вот эта команда как работает,
баш создаст новый процесс , со своим бинарником,
и также мы ему указали что в новом процессе нужно уничтожить файл дескриптор 1
далее запустится бинарник cat  а далее прикол в том что по дефолту он пишет в 1  через
write (1, ...)
а 1  у нас нету поэтому на экране вылезет ошибка
    # $ cat /etc/passwd 1>&-
      cat: standard output: Bad file descriptor

можно сделать по другому
    #  tty
     /dev/pts/12
    # cat /etc/passwd 1>&- 1>/dev/pts/12
как ни странно это сработает. 
с новым процессом будет проделано все то что я описал в предыдушем примере
тоесть будет удален дефолтовый дексриптор 1 и будет создан новый который ведет в /dev/pts/12
и все окей. тоесть если указано несколько редиректов в строке то баш и выполняет последовательно 
слева направо хоть миллион таких редиректов 


далее
    $ exec 2>&1
это понятно дескриптор 2 будет иметь тот же бекенд что и дескриптор 1
амперсанд обязателен иначе 2 будет перенаправлен не в дескриптор а обычный файл с именем 1

далее
    $ exec  &>kuku.txt
это перенаправляет 1 и 2  в файл. причем только файл на диске.
перенаправление в файл дескриптор не работает
аналогичная команда
    $ exec 1>kuku.txt 2>kuku.txt
при этом вот это неработает
    $ exec 4<>kuku.txt
    $ exec &>&4
тоесть &> можно перенаправлять только на файлы на диске а не на дескрипторы. тоесть 
вот так только работает
    $ exec &>12.txt

далее. все это время я рассматривал только ">" "<" "<>"
что означало
    > = открыть файл на запист
    < = открыть файл на чтение
    <> = открыть файл на чтение и запись
и  я совсем забыл про ">>" и "<<"
что означает
    >> = открыть файл на запись и плюс флаг APPEND
    << = это совершенно отдельный флаг. я только знаю его вот такое применение
    $ cat <<EOF >1.txt
    12
    12
    EOF
кстати я точно проверил вот так уже неработает
    $ cat <EOF >1.txt
     bash: EOF: No such file or directory

далее
    $ <<vasya
> eee
> bbb
> vasya

тоесть команда просит нас ввести текс. как только мы заканчиваем на контрольном слове vasya
то ввод заканчивается. и никакой файл не создается.
как я понимаю что это аналог команды
    $ :<<vasya
    > eee
    > bbb
    > vasya

тоесть наш текст идет на stdin команды true и в итоге все это просто команды пустышка

далее
    $ >>kuku
эта команда просто напросто создат пустой файл kuku на диске
тоесть аналог этой команды вот такой
    $:>>kuku
или аналог
    $: 1>>kuku

далее
    $ ls >>filename 2>&1
аналог
    $ ls 1>>filename 2>&1
тоесть эта команда она создает процесс с бинарником ls
уничтожает стандартный 1 и создает новый 1 который ведет в файл с именем "filename"
уничтожает стандартный 2 и создает новый который смотрит туда же куда и 1 тоесть в файл "filename"


далее
    $ 2>&1
аналог
    $ :2>&1
все понятно


далее. 
в bash 4 добавили вот такую хрень
|& was added to Bash 4 as an abbreviation for 2>&1
тоесть
    $ vasya |& cat
это аналог
    $ vasya 2>&1 | cat
пример
    $ vasya 2>&1 | xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
    $ vasya  |& xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
 
тоесть хрень рабтает как. баш создает свой клон в новом процессе.
далее этот чайлд баш ищет бинарник вася, ненаходит его, выводит в 2 сообщение об 
ошибке. а у нас при этом когда процесс создавался то 1 была перенаправлена на 0 процесса xargs
и 2 была направлена тудаже куда 1. получается чайлд баш срет в 2 сообщение об ошибке
и оно автоматом прилетает на 0 xargs. и он то что получил высирает

далее выяснился конкретный пиздец с башем.
мы привыкли что в самоей левой позиции в строке обязательно идет команда 
а все аргументы пайпы итд обязательно идут справа. 
это настолько фундаментальная хрень что о том что это не так даже в голову не приходит
однако это не так. оказывается что можно вот так
    $ cat filename 
    filename
    kuku
    vasya
    $ 2>file2 0<filename cat | xargs echo   
    filename kuku vasya

тоесть левее команды можно абсолютно спокойно насовать редиректы! это пиздец
об этом я нашел случайно в сноске в bash advanced guide
то есть аналогичная в более привычном виде команда выглядит так
    $ cat 0<filename 2>file2 | xargs echo 

можно конечно еще более загадочно и с выебоном написать
    $ < filename cat > out
аналог тоесть более привычный вид
    $ cat 0<filename 1>out

вот еще пример с выебоном
    $ rpm2cpio < filename > $TEMPFILE
аналог
    $ rpm2cpio 0<filename 1>$TEMPFILE

а вот еще приме с приколом
как создать новый дескриптор который ссылается на уже существующий дескриптор
    $ exec 4>&1
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 02:44 0 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 1 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 2 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 4 -> /dev/pts/15

переводится команда так. в существующем процессе баш нужно открыть создать файловый дескриптор 4
и направить его на файл на который ссылается дескриптор 1. причем этот файл нужно открыть на чтение

еще один пиздец
    $ ls -l  1>/dev/null  16>&-
здесь я вывод от ls просто заткнул тем что перевел в null
и это не главное. главное это "16>&-" 
тоесть оказывается что можно давать команду уничтожить файловый дескриптор который 
и в помине у процесса нихуя нет. и ошибки при этом никакой не выдает. 

вот еще ебанутый пример
    $  <&2  ls  >/dev/null
его аналог
    $ ls  1>/dev/null   0<&2


вот еще ебанутый пример
    $ exec 3<&2
    $ exec 2>&1 >&3 3>&-
первая строка она в текущем процессе баша создает дескриптор 3 который ведет на тот же файл на который
указвыает дескриптор 2. причем этот файл для через дескриптор 3 будет открыт на чтение
тоесть в итоге 3 будет указывать на /dev/pts/19
вторая строка работает так. для текущего процесса баша дескриптор 2 будет уничтожен и создана заново
при этом он будет указыват на тот же файл на который указывает дескриптор 1. так как  1 указывает на /dev/pts/19
то и 2 будет на него указывать. причем в режиме на запись. 
следущим шагом будет уничтожен дескриптор 1 и создан заново при этом он будет указывать на файл на который
указывает дескриптор 3. а 3 указывает на /dev/pts/19 ( на основе информации из команды из первой строки)
поэтому 1 будет указывать на /dev/pts/19 причем в режиме на запись он откроет этот файл
на последнем шаге будет уничтожен дескриптор 3
здесь важно понять что работа с дескрипторами их создание и уничтожение идет слева направо. последовательно 
по шагам. также важно понять что если у нас написано что дескриптор 2 указывает на дескриптор 1 
как вот здесь "2>&1" то это нетак. не дескриптор ссылается на дескриптор а дескриптор ссылает на файл 
на который ссылает другой дескриптор. тоесть как только мы выяснили на какой файл ссылается дескриптор 1
то нам на него насрать. дескриптор 2 будет ссылаться не на дескриптор а на файл который является бекендом 
для дескритора 1. поэтому если потом позже мы удалим дескриптор 1 то проблемы у дескриптора 2 не будет 
никакой так как оне никогда не ссылался на дескритор 1. это тоже важно понять.
а вот на эту тему пример
        $ exec 4<filename 0<&4 1>&0 4>&-
        
        $ ls -1al /proc/16039/fd
        lr-x------ 1 vasya vasya 64 окт  5 03:08 0 -> /home/vasya/filename
        lr-x------ 1 vasya vasya 64 окт  5 03:08 1 -> /home/vasya/filename
        lrwx------ 1 vasya vasya 64 окт  5 03:08 2 -> /dev/pts/20


тоесть как это работает. для текущего процесса у нас открывается файл "filename" на чтение 
и привыязывается к процессу через дескриптор 4
на втором шаге у нас уничтожается прежний 0 и создается новый и он открывает на чтение тот файл на который ссы
лается 4 тоесть filename
на третьем шаге у нас уничожается 1  и создается заново и он открывает на запись файл на который ссылается 0
тоесть filename 
на последнем этапе у нас уничтожается дескриптор 4
от того что мы уничтожили дескриптор 4 это не означает что это как то повлияет на 0. потому что 0 указывает
не на 4 а на файл на который указывал 4 тоесть на filename
пиздец

далее. шок
внещняя по отношению к башу команда cat
она почемуто читает данные не из 0 а из 3 !!!
показываю:
    $ cat /dev/urandom > /dev/null

    $ ls -1al /proc/21031/fd
    lrwx------ 1 vasya vasya 64 окт  5 10:15 0 -> /dev/pts/16
    l-wx------ 1 vasya vasya 64 окт  5 10:15 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 10:15 2 -> /dev/pts/16
    lr-x------ 1 vasya vasya 64 окт  5 10:15 3 -> /dev/urandom

хотя в приниципе нормально. для cat штука "/dev/urandom" является параметром и бинарник cat когда он запустился
анализирует с каким параметрами командной строки он был запущен и волен открывать файл под любым дескриптором.
в том числе и под дескриптором 3.
скорее я капитально ошибся думая что параметр командной строки почемуто должен быть открыть катом через 
дескриптор 0. это же чушь. через 0 cat принимает данные из терминала. а через 3 он принимает данные из файла.
все конечно же должно быть так.

далее еще прикол про cat
    $ cat 1.txt 2.txt
если так запустить то cat вначале откроет 1.txt полностью его прочитает и выдаст в 1, закроет его,
потом только откроет 2.txt 
а не так как я думал что он одноврменно откроет два файла. нет так он не делает.

далее еще прикол
    $ <<EOF
    > aa
    > bb
    > EOF
насколько я понимаю эквивалент команды это 
    $ :<<EOF
либо
    $ true<<EOF
тоесть невидимая команда это ":" или "true" что одно и тоже.
и  в нее скармливается текст из терминала
как работает "<<EOF" насколько я понимаю когда мы тыкаем enter то текущий баш он видит эту хрень 
и делает вывод что мы хотим написать в терминале какойто текст, он дает нам написать в терминале наш текст,
засасывает внутрь себя И ТОЛЬКО ПОТОМ он клонирует себя в новый процесс и как я понимаю он где то сохраняет
засосанный текст из терминала и после того как склонировал себя то он наверное из родительского процесса
видимо через пайп скармливает засосанный текст в stdin чайлд процесса.
тоесть если у нас есть вот такая команда
    $ команда <<EOF 
то ее эквивалент
    $ echo -en "aaasdas\n asdasdsdasd\n" | команда 
или еше пример
    $ cat<<EOF > 1.txt
ее аналог в более понятной форме
    $ echo -en "aaaa\n bbb\n" | cat > 1.txt 
этим описанием я хочу подчеркнуть что "<<" не имеет никакого отношения к cat! это фича либо самого терминала
либо баша скорей всего баша. поэтому "<<" можно прихуяривать с любой программой. самое главное что программа должна ожидать получить какието данные из stdin. пример
    $ xargs echo <<EOF
    > "aaa"
    > "bbb"
    > EOF
    aaa bbb
тоесть эта команда эквивалентна
    $ echo "aaa bbb" | xargs echo
    aaa bbb

работает это так. мы тыкаем Enter. баш начинает анализировать строку  "xargs echo <<EOF"
видит конструкцию "<<EOF" и понимает что пока что делать ничего нельзя. прежде всего нужно считать 
некий текст из терминала. поэтому баш останавливается и ждет чтобы мы набили в терминале текст.
мы его набивает. баш его где то запомиает в своих кишках. потом он клонирует себя. запускает в чайлде
xargs и видимо через пайп передает из родительского процесса из своих кишок запомненный текст 
на stdin дочернего процесса.

далее я возвращаюсь к cat
у него есть такой прикол
    $ cat 1.txt - 2.txt
эта хуйня должна работать так вначале кат открывает файл 1.txt полностью его читает и выводит  на терминал.
потом кат ждет наших данных прям с терминала. он их считывает и выводит на экран. потом мы както должны обьяснить кату что мы больше не хотим вводит из терминала. и он тогда должен открыть 2.txt и его прочитать
и вывести на экран. на данный момент прблема в том что я не понимаю как этому кату обьяснить тот момент
когда я хочу закончить ввод из терминала
значит я не знаю как из терминала обьяснить кату что мы закончили ввод тоесть
    $ cat -
я не понимаю как закончить ввод с терминала
зато вот можно сделать такой прикол
вот есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777

тогда можно сделать вот такой фокус
   $ echo "111" | cat 6.txt - 7.txt
    666
    111
    777
круто??!?!?!?!?

во! я узнал как в терминале что надо нажать чтобы обьяснит терминалу и cat что я закончил
вводить текст и мы достигли "конец файла EOF" . оказывается это комбинация Ctrl+D
показываю имеем два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
тогда пуляем такую команду
    $ cat 6.txt - 7.txt 
    666  <=== это кат вывел содержимое 6.txt
    aa   <=== это мы ввели руками в терминале
    aa   <=== это кат вывел то что мы ввели
    bb   <=== это мы ввели руками в терминале 
    bb   <=== это кат вывел то что мы ввели руками, и тут я нажал Ctrl+D
    777  <=== это кат вывел содержимое файла 7.txt
круто!!!!!

далее. итак я выяснил что 
    $ cat 1.txt
приводит  к тому что кат откроет файл 1.txt через файловый дескриптор номер 3 
еще раз показываю на примере
    $ cat /dev/urandom 1>/dev/null
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
четко видно что файл открыт через дескриптор номер 3
а если мы хотим чтобы cat начал читать файл через дескриптор 0 то это запускается
совсем по другому
    $ cat /dev/urandom | cat 1>/dev/null
вот как выглядит открытые файлы у второго кат
    $ ls -1al /proc/22921/fd
    lr-x------ 1 vasya vasya 64 окт  5 11:18 0 -> 'pipe:[2312995]'
    l-wx------ 1 vasya vasya 64 окт  5 11:18 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:18 2 -> /dev/pts/18
в этом случае поток засасывается из 0 который ведет в пайп. но дело не в пайпе. а то что
в таком случае поток забирается из 0
возвращаюсь к случаю когда кат читает из файла который мы указали в командной строке
    $ cat /dev/urandom
мы имеем вот такой список открытых дескрипторов
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
так вот понятно что у нас на экране будут лететь символы
можно даже вот такой пример сделать чтобы на экране были только буквы 
    $  cat /dev/urandom | od -t x1
так вот возникает вопрос а что если мы вэто время будем конпки на терминале тыкать будет ли
их параллельно пихать на экран cat или нет. отвечаю конечно нет! 
как я уже сказал раз мы указали cat файл в командной строке как аргумент то он читает данные
только из дескриптора 3. а планов читать в это время  у него из stdin из 0  у него нет! поэтому
тыкать в терминале кнопки в это время нет никакого эффекта!

далее еще полезный момент
    $ echo 113 | cat
    113
    $ echo 113 | cat -
    113
результат один и тот же. однако во втором случае мы в более явной 
форме обьясняем кату что мы хотим чтобы он данные принимал из 0






далее я перехожу к мудежной но знаковой важной теме 
называется она 
>>> bash process substitution <<<
выглядит это так
    $ команда1 >(команда2)
например 
    $  cat - >(sleep  160)
и работает это так
создается  pipe.
и тут важно скзаать что книжка "bash advanced scripting" на которую я опираюсь нередко пишет 
полную хуйню. так и в этот раз. книжка пишет что создается named pipe. на самом деле нихуя. 
создается anonymous pipe. тут я делаю отсылку на pipe.txt чтобы прочитать про то что такое пайпы.
итак создается неименованный пайп а именно анонимный! выглядит он так
        'pipe:[2498298]'
где что и как щас станет понятно
    $ ls -1al /proc/5013/fd
        lrwx------ 1 vasya vasya 64 окт  6 10:41 0 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22
        l-wx------ 1 vasya vasya 64 окт  6 10:41 63 -> 'pipe:[2498298]'  <====
    $ ls -1al /proc/5014/fd
        lr-x------ 1 vasya vasya 64 окт  6 10:41 0 -> 'pipe:[2498298]'   <====
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22

так вот ядро создало анонимный пайп где то там в своих кишках памяти 'pipe:[2498298]'
далее запускается команда2 и ее stdin конец присоединяется к анонимному пайпу 'pipe:[2498298]'

далее запускается команда1 и ей в качестве аргумента командной строки передается адрес файла /dev/fd/63
то бишь /proc/pid1/fd/63
показываю:
    $ ps aux | grep cat
     vasya     5013  0.0  0.0  14720   744 pts/22   S+   10:40   0:00 cat - /dev/fd/63

где /dev/fd/63 это симлинк на /proc/self/fd/63 тоесть то бишь /proc/pid1/fd/63
нихуя себе! да?
тоесть команда 1 была по факту запущена в виде
    $ cat - /dev/fd/63
и соотвественно программа cat обрабатвыает этот аргумент строки 
и открывает этот файл под каким то дескриптором ну точнее как видно из практики под дескриптором 63
и таким макаром у первой программы мы имеем
        63 -> 'pipe:[2498298]'
у второй программы мы имеем
        0 -> 'pipe:[2498298]'
если первая программа захочет и будет писать в дескриптор 63 то это летит в пайп 
и если вторая программа будет читать если захочет из дескриптора 0 то она будет читать из пайпа.
таким макаром пайп обеспечивает связь между двумя процессами.
во втором процессе пайп присоединяется к 0
а в первом процессе имя файла пайпа (/proc/pid1/fd/63) передается программе как аргумент в строке.
соотвесвтенно если первая программа такова что она не собирается писать данные в файл который указан  в ее 
строке то второй програме нихрена и не прилетит.  тоесть bash process substituition это более специфический
процесс связи между программами.  классический анонимный пайп вида $ echo | cat более бронебойный способ 
потому что он вставляет пайп на stdout первого процесса и сует на stdin второго процесса.
если первый процесс чтото высирает на stdout а второй процесс чтото желает читать из своего stdin (что вобще то говоря не факт) то связь между процессами обеспечена.
в случае же bash process subsitution связь заработает только если первый процесс умеет писать в файл имя которого ему передали как аргумент в строке. вот что надо подметить.! но еще раз подчеркну что в bash process
substition используется анонимный пайп. а не именнованный как это суки эти пищут в bash advanced guide книжке


еще пример
    $ echo >(true)
    /dev/fd/63
почему так. потому что в конечно итоге будет запущена команда
    $ echo /dev/fd/63
обьясню почему. мы вбили команду в баш. баш анализирует строку и видит в ней кусок ">(true)"
для баша это означает что нужно этот кусок заменить на имя файла. что за файл?  файл в папке 
/dev/fd/63. по факту это симлинк на файл /proc/self/fd/63 то бищь /proc/pid1/fd/63
почему именно 63? я так думаю это какойто хардкод число в ядре с которого он создает эту хрень.
и между прочим это тоже симлинк и ведет он на анонимный пайп 
        /proc/pid1/fd/63 --> 'pipe:[2498298]'
когда пайп создан и когда ссылка на него создана то баш подставляет в оригинальную команду и запускает 
ее 
     $ echo /dev/fd/63
поэтму мы на экране видим 
    /dev/fd/63
помимо этого баш создает новый процесс и запукает там вторую команду "true"
и к ее stdin присоединяет этот же анонимный пайп тоесть
          /proc/pid2/fd/0 --> 'pipe:[2498298]'
конкретно в даннном случае вся команда целиком неимеет никакого практического смысла
потому что echo абсолютно не собирается писать в файл /dev/fd/63 по своей природе
а команда true не собирается ничего читать со своего stdin 
поэтому это пример чисто работающий но бесполезный     потому что данные через пайп
от первой команды ко второй не передаются


а вот пример где данные уже передаются
    $ cp /dev/urandom >(pv 1>/dev/null)
     147MiB 0:00:06 [21,0MiB/s] [                   <=>                           <=>    

работает это так что данные из /dev/urandom пихаются в пайп
а из него их читает pv и рисует картинку

более подробно  как это работает 
работает также как в прошлом примере
вот мы вбили команду
    $ cp /dev/urandom >(pv 1>/dev/null)
нажали Enter
бащ анализирует эту строку.  и видит комбинацию ">(pv 1>/dev/null)"
тогда баш понимает что все не так просто и создает аононимный  пайп где то там  в памяти вот 
такую хрень 'pipe:[2498298]'
далее бащ создает новый процесс и в нем запускает "pv". когда  баш создает этот процесс через сисколл
то просит у ядра чтобы оно присоединило к stdin дочернего процесса наш пайп
и выглядит это так
        /proc/pid2/fd/0 --->  'pipe:[2498298]'
далее баш берет оригинальную команду и меняет ее из вот такой
        $ cp /dev/urandom >(pv 1>/dev/null)
в такую
        $ cp /dev/urandom /dev/fd/63
где /dev/fd/63 в конечном итоге ведет в тот же самый пайп 'pipe:[2498298]' тоесть
        /dev/fd/63 --> /proc/self/fd/63 ---> 'pipe:[2498298]'

соотвевственно команде cp похеру что там на том конце у /dev/fd/63
она просто копирует данные из /dev/urandom в /dev/fd/63
таким макаром данные улетают в пайп.
и таким же макаром вторая команда читает свой stdin и получает данные из пайпа.

можно привести пример когда работает наоборот
    $ cp <(cat /dev/urandom) /dev/null
работает это так что () кидает их в свой stdout который направлен в пайп
а команда cp будет запущена в виде
    $ cp /dev/fd/62 /dev/null
где /dev/fd/63 тоже смотрит в пайп
таким макаром данные из stdout () поступают в пайп оттуда в /dev/fd/62 а оттуда в cp 

да уж..


а вот еще пример
    $  cp /dev/urandom >(echo "печать из субшелла"; pv 1>/dev/null)
    печать из субшелла
    66,2MiB 0:00:01 [37,1MiB/s] [     <=>           ]
получается вот что. вначале то что вылетает из cp пристыковывается через пайп к stdin команды echo.
но ей посрать на то что поступает к ней из stdin поэтому она просто печатает текст на экране и заканчивает
свою работу. данные при этом в пайпе как лежали так и лежат ( деньги в копилке так и лежат)
тогда далее запускается pv и уже к ней пристыковывается  пайп на ее stdin 
и так как pv как раз таки и и ждет поступления данных из stdin то pv начинает выкачивать данные из пайпа

тоесть фишка в том что у нас наш пайп был подключен и к одной команде и другой. а с классическим анонимным пайпом так хрен сделаешь наверно...


а вот еще очень важный пример
    $ echo "11" 1>(echo "первый привет из субшелл"; cat)
    11 1/dev/fd/63

что я хотел в этом примере добиться. я хотел чтобы вывод эха был перенаправлен в ()
но это не получилось хотя я якобы настроил редирект для 1. ошибка в том что баш заменил
конструкцию ">(echo "первый привет из субшелл"; cat)" на "/dev/fd/63" в итоге echo был запущен
буквально вот так
    $ echo "11" 1/dev/fd/63
поэтому то мы на экране и увидели вот эту хрен незапланированную 
    11 1/dev/fd/63
а чтобы все заработало как надо - надо вот так
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat)
    первый привет из субшелл
    11

значит в нем редирект настроен как "1>" а файл в который мы редиректим указан как ">(echo "первый привет из субшелл"; cat)"
в итоге и получается вот такая удивительная конструкция! c двумя галками через пробел "> >"
тоесть пример у нас расшифрорвывается так:
напечатай 11 но при этом stdout мы перенаправляем в именованный пайп который ведет в субшелл
далее. вначале именнованный пайп с 11 внутри прилепляется к stdin команды 
    echo "первый привет из субшелл";
но ей похеру то что у нее сидит на ее stdin
поэтому она просто на экране печатает приветствие и заканчиывает работу
тогда запускается команда cat у которой именованный пайп подключен к ее stdin
и вот тут наконец 11 из верхней эхо поступает на stdin команды кат. и она его печатает. 
в итоге мы получаем на экране
    первый привет из субшелл
    11


возникает вопрос а что будет у такой команды?
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
возникает вопрос чтото из верхнего эхо доберется до второго cat?
ответ конечно нет. потому что пайп уже весь опустошен на первом cat
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    11
    второй  привет из субшелл



а вот еще очень интересный пример
вот у нас есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
запускаем такую команду 
    $ cat 6.txt 7.txt  1> >(echo "первый привет из субшелл"; cat -; echo "второй  привет из субшелл"; cat -;)
    первый привет из субшелл
    666
    777
    второй  привет из субшелл


вопрос был вот в чем. когда у нас верхний cat закончит передавать первый файл и первый cat в субщелле закончит 
его печать то закончит ли cat в субшелле свою работу и передаст ли второй echo в субщелле управление
или нет. практика нам показала что первый cat в субшелле посрал на то что первый файл закончился 
и работал до упора напечатал оба файла и только потом закончил работу и передал управление дальше.
поэтому второй cat оказался полностью пустой. к нему по пайпу ничего не прилетело.



вот еще пример на эту тему
вот у нас есть файл 
    $ cat 6.txt 
    666
запускаю такую команду
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
в ней я говорю что  я буду пихать в головной cat вначале данные сам руками из терминала.
а потом как закончу данные в cat еще поступят из файла 6.txt
мой вопрос до второго cat в субшелл чтото долетит или нет?
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    вася  <=== это  я ввел руками в терминале
    вася
    петя  <=== это  я ввел руками в терминале
    петя
          <== тут я нажал Ctrl+D (EOF) и cat прекратил читать из терминала и начать читать файл 6.txt
    666   <== содержимое файла 6.txt
    второй  привет из субшелл


так вот видно то что первый cat в субшелле сидел и ждал данные до упора. она 
вначале дождался данных из того что я втермиале печатал. а потом он еще напечатал то что в 6.txt
и только после этого он закончил свою работу. и поэтом до второго cat в субшелле уже ничего не долетело
сверху. вот это и я хотел исследовать



еще малек пример про редирекшн.
пример
    $ echo -e 1>15.txt
я хотел изначально записать "1" в 15.txt
а как очевидно понятно я ошибся. и по факту обозначение "1>15.txt"
привело к тому что файловый дескриптор 1 стал указывать на 15.txt 
а не то что символ 1 был напечатан на экран. 
надо было вот так делать чтобы 1 на экране напечатался
    $ echo -e "1"   1>15.txt
вот как было правильно




теперь НАКОНЕЦ я возвращаюсь к тому примеру с которого начал изучение редиректов 
        $ exec &> >(tee -a ./1.txt)
теперь наконец  эта тарабарщина понятна!
"&>" дает то что stdin и stderr оба будут перенаправлены в некий файл. а что за файл?
а это как раз указано дальше , файл такой что он указывает на анонимный пайп из "bash process substitution" 
обычно это файл 
        /dev/fd/63 ---> /proc/self/fd/63 ---> 'pipe:[2498298]'

баш начнет анализировать всю эту команду после нажатия enter  и попросит ядро создать пайп 'pipe:[2498298]' 
где то в памяти ядра, далее баш 
произведет в исходной строке замену 
было
    $ exec &> >(tee -a ./1.txt)
стало
    $ exec &> /dev/fd/63

в доказательство этого я выполнил strace чтобы это поймать
    # strace -p 7859 -f  -s80  -e openat
    [pid  7859] openat(AT_FDCWD, "/dev/fd/63", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
причем этот файл присутствует именно в openat а не в execve
удивительно

далее баш выполнит команду exec и тогда у текущего баша поменяется два дескриптора. 1 и 2 (stdout и stderr)
раньше скорей всего они смотрели на файлы терминало /dev/pts/22
а станут смотреть на пайп
        /proc/bash_pid/fd/1 ---> 'pipe:[2498298]'
        /proc/bash_pid/fd/2 ---> 'pipe:[2498298]'

далее баш запустит еще один процесс и там запустит tee
к stdin дескриптору этого процесса он прилепит тот же пайп 
        /proc/tee_pid/fd/0 ---> 'pipe:[2498298]'

в итоге все что баш будет бросать на stdout\stderr будет направлено в пайп
и будет считано из пайпа командой tee и отрисовано на окне терминала и продублировано  в физ файл на физ диске.

хотелось  почеркнуть что отрисовка вывода в терминале будет идти не засчет головного баша
а за счет tee в субшелл.
посмотрим теперь на практике
    $ exec &> >(tee -a 1.txt)
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 13:11 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 1 -> pipe:[2331898]   <====
    l-wx------ 1 vasya vasya 64 окт  5 13:11 2 -> pipe:[2331898]   <====

    $ ps aux  | grep tee
    vasya    26155  0.0  0.0  14588   792 pts/17   S    13:10   0:00 tee 1.txt
    $ ls -1al /proc/26155/fd
    lr-x------ 1 vasya vasya 64 окт  5 13:11 0 -> pipe:[2331898]   <====
    lrwx------ 1 vasya vasya 64 окт  5 13:11 1 -> /dev/pts/17
    lrwx------ 1 vasya vasya 64 окт  5 13:11 2 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 4 -> /home/vasya/temp/1.txt

из чего действительно видно что в головноv баше stdin и stdout указывают на пайп [2331898]
а в процессе "tee" ее stdin смотрит в тотже самый пайп [2331898]
тоесть теория совпала с практикой


далее я покажу что будет напечатано в 1.txt
если в исходной терминале будет выглядеть вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

то в 1.txt будет вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

что интересно новые буквы будут появляться в файле не тогда когда мы воригинальном терминале 
нажали enter а уже тогда когда мы в терминале нажали просто букву!
что еще более поразительно. если мы сотрем букву на оригинальном терминале то эта буква также сотрется 
и в файлле ! amazing!
вот это тема.... охренеть


возникает удивительный вопрос а нахуй этот механизм нужен на практике? покажите
пример практический когда это может пригодится?

еще пример
еще:
    $ echo 1 >(cat)
        1 /dev/fd/63
ну понятно. строка 
    $ echo 1 >(cat)
будет заменена на
    $ echo 1 /dev/fd/63
отсюда результат


далее
    >&, &>
есть ли разница.
обычно нет. но лучше юзать &>
по смыслу эта команда перенаправляет sterr и stdin в один файл
который обязательно нужно укзаать после тоесть
    $ echo "aaa" &> /tmp/1.txt
эквиваелент
    $ echo "aaa" 1>/tmp/1.txt 2>&1
либо
    $ echo "aaa" 1>/tmp/1.txt 2>/tmp/1.txt


далее
    >|
тут интересно. баш имеет ряд крутилок настроек.
настроки подкручитваются через баш билтин set
    $ set --help
в частности вот так крутятся настройки
    $ set +o pipefail -o noclobber
посмотреть текущие настройки вот так
    $ echo $-
хотя там не информативно. а более информативно вот так

$ set -o
set -o
+ set -o
allexport       off
braceexpand     on
emacs           on
errexit         off
errtrace        off
functrace       off
hashall         on
histexpand      on
history         on
ignoreeof       off
interactive-comments    on
keyword         off
monitor         on
noclobber       off
noexec          off
noglob          off
nolog           off
notify          off
nounset         off
onecmd          off
physical        off
pipefail        off
posix           off
privileged      off
verbose         on
vi              off
xtrace          on

видно опять же как я сказал что noclobber выключена.
если она включена то ">" не даст перезаписать существующий файл. выдаст ошибку.
у нас опция выключена поэтому ">" перезатирает файл без всяких ошибок.
так вот если все таки noclobber активирована то ">|" позволяет игнорировать эту настройку.  
в общем в итоге ">|" малополезная хрень.
я еще ни разу не встречал чтобы noclobber был хоть где то активирован.

далее пример. 
я нашел более менее пример который уже как то типа может быть полезен на практике.
есть два файла
    # cat 7.txt 
        a
        b
        c
    # cat 6.txt 
        1
        2
        3

есть интересная команда "paste" она читает из нескольких файлов по одной строке
и печатает это на экране через TAB
    # paste 6.txt 7.txt 
        1   a
        2   b
        3   c
так вот как это же можно сделать через bash process substitution 
    # paste <(cat 6.txt) <(cat  7.txt)
        1   a
        2   b
        3   c
ну когда мы читаем из готовых файлов то пример мало полезен. а вот когда 
нам надо прочитать из stdout нескольких процессов и все это построчно соединить в таблицу
на экране то bash process substitution уже становить реально полезен
    # paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp)
        INT3400 Thermal 20000
        pch_cannonlake  40000
        B0D4    0
        x86_pkg_temp    42000


как написано в мануле утилита "paste" позволяет соединить строки нескольких файлов вместе.
тоесть еще пример
    $ cat 1.txt 
        aaa
        bbb
        ccc 
$ cat 2.txt 
        5
        6
        7 
$ paste 1.txt  2.txt 
        aaa 5
        bbb 6
        ccc 7 

разделение идет через TAB


далее я опишу утилиту colrm
это частично идиотская утилита потому что ее man нагло врет
    $ colrm start stop
утилита удаляет из текста колонки с номерами  
    start << колонка << stop
причем разделителя колонки никакого нет. это ни пробел  ни TAB
это всегда банально номер символ в строке. показываю
в этом примере будет удалены символы 3 и 4
их позиция в строке и является так называемой "колонкой"
    $ echo -e "123456789" | colrm 3 4
    1256789
если указать только стартовую колоноку то он удаляет вот такие колонки
    start << колонка << EOL
пример
    $ echo -e "123456789" | colrm 3
    12
в целом убогая утилита



далее я опишу утилиту column
она позволяет назначить разделитель и потом отформатировать текст по колонкам.
но по мне утилита корявая. она порой работает хер знает как.
итак имеем файл
    $ echo -e "1+2+3+4+5\n6+7+8+9+10"
    1+2+3+4+5
    6+7+8+9+10
воспользуемся недавно узнанной штукой "bash process substitution"
    $ column -t -s "+" <(echo -e "1+2+3+4+5\n6+7+8+9+10")
    1  2  3  4  5
    6  7  8  9  10
так вот утилита column 
ее ключ -е без него вобще ничего не работает. считай что он значит что надо отформатировать текст
ключ -s "+" означает что разделитель между колонками "+"

далее важно дополнение. выравнивание в колонке идет всегда по левому краю.
пример про это
    $ echo -e "111111111+2+3+4+5\n6+7+8+9+10"
    111111111+2+3+4+5
    6+7+8+9+10

    $ column -t -s "+" <(echo -e "111111111+2+3+4+5\n6+7+8+9+10")
    111111111  2  3  4  5
    6          7  8  9  10

порой эта прога как уже сказал работает непонятно как . но если ее применить несколько раз
то вроде можно получить вменяемый результат
практический пример 
имеем вот такой вывод.
почему то cpupower хреновато форматирует свой текст
можно заметить что "Freq" и "POLL" поплыли
    $ sudo cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6   || C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,02|  1,37| 59,17|  0,00||  0,88| 99,12|   632||  0,00|  0,00|  0,00|  0,02|  0,47|  0,00|  3,36|  0,16| 95,13
   4|  0,02|  1,37| 59,17|  0,00||  2,33| 97,67|   577||  0,00|  0,00|  0,03|  0,01|  1,36|  0,00| 14,02|  0,08| 82,29
   1|  0,13|  0,42| 59,17|  0,00||  1,66| 98,34|   598||  0,00|  0,74|  0,18|  0,09|  0,23|  0,00|  7,52|  0,03| 89,59
   5|  0,13|  0,42| 59,17|  0,00||  1,06| 98,94|   600||  0,00|  1,82|  0,00|  0,06|  0,26|  0,00| 10,37|  1,03| 85,34
   2|  0,00|  0,27| 59,17|  0,00||  1,70| 98,30|   657||  0,00|  0,00|  0,01|  0,02|  0,02|  0,00|  4,72|  0,00| 93,46
   6|  0,00|  0,27| 59,17|  0,00||  0,32| 99,68|   623||  0,00|  0,00|  0,02|  0,00|  0,20|  0,00|  4,52|  0,00| 94,87
   3|  0,09|  0,98| 59,17|  0,00||  0,87| 99,13|   609||  0,00|  0,94|  0,73|  0,03|  0,48|  0,00|  7,93|  0,00| 89,05
   7|  0,09|  0,98| 59,17|  0,00||  1,62| 98,38|   568||  0,01|  0,66|  0,04|  0,10|  0,76|  0,00| 14,12|  0,00| 82,69


отформатируем этот текст
    $ sudo cpupower monitor | column -t -s "|" | column -t -s " " | grep -v Nehalem
CPU      C3     C6          PC3    PC6   C0    Cx     Freq  POLL  C1    C1E   C3    C6    C7s   C8     C9    C10
0        0,02   1,22        52,58  0,00  1,20  98,80  645   0,00  1,92  0,17  0,02  0,23  0,00  9,80   1,11  85,57
4        0,02   1,22        52,58  0,00  1,84  98,16  623   0,00  0,00  0,24  0,04  1,83  0,54  11,55  0,38  83,64
1        0,08   0,40        52,58  0,00  1,76  98,24  631   0,01  0,00  0,02  0,09  0,48  0,00  8,84   0,00  88,81
5        0,08   0,40        52,58  0,00  3,34  96,66  674   0,00  1,05  1,26  0,00  0,16  0,40  6,78   0,07  86,95
2        0,06   2,54        52,58  0,00  2,61  97,39  666   0,00  0,11  0,85  0,01  0,72  0,00  8,97   0,07  86,65
6        0,06   2,54        52,58  0,00  2,02  97,98  646   0,00  0,00  0,03  0,10  3,00  0,00  10,23  0,06  84,53
3        0,03   0,71        52,58  0,00  5,44  94,56  654   0,00  0,00  0,00  0,05  0,68  0,00  15,06  0,09  78,67
7        0,03   0,71        52,58  0,00  0,75  99,25  635   0,00  0,00  0,01  0,01  0,09  0,00  6,79   0,00  92,28

в плане ключа -s который указывает разделитель колонок
так вот возникает вопрос как указать в качестве разделителя например знак табуляции
в мануале об этом нет ни слова. так вот ответ вот как
    -s $'\t'
а вот пример
    $ echo -e "1\t2\t3\t"
    1   2   3   

    $ echo -e "1\t2\t3\t" | column -t -s $'\t'
    1  2  3

утилита column работает так что она удаляет из строк сам знак разделителя
и заменяет его на пробел. или пробелы. по своему усмотрению. поэтому в примере выше она убрала
табы и вставила пробел как разделитель заместо

а теперь более менее практический пример где эта утилита может пригодится реально
исходный текст
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с"
    'температура датчика'   'скорость'  'высота'
    30°C    12 м\с

прикол в том что между колонками TAB а внутри колонки у нас пробелы могут быть.
а мы хотим выровнять.
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с" |  column -t -s $'\t'
    'температура датчика'  'скорость'  'высота'
    30°C                   12 м\с



а вот пример ради которого я долбался писал выше описание для 
утилит paste, bash process substitution, sed 
( кстати о том как работает sed смотри в sed-awk-cut-tr.txt )
итак встретился в инете такой пример.
в нем column он заменяет разделитель TAB на пробел,
а sed берет три последние символа, запоминает третий слева символ в группу 1,
и вместо трех последних символов вставляет точку плюс символ который сохранен в группе 1 и 
далее градус с цельсием. например в конце было 20000, значит три берем три последних символа это "000"
запоминаем третий слева в группу 1 это "0" и заменяем в итоге на ".0°C"
    $ paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp) | column -s $'\t' -t  | sed 's/\(.\)..$/.\1°C/'

    INT3400 Thermal  20.0°C
    pch_cannonlake   37.0°C
    x86_pkg_temp     39.0°C


далее еще пример про редирект
    $ echo "456" | ssh thinkpad cat - 1>~/7.txt
прикол в том что редирект будет идти не в файл на удаленном компе. нееееееет.
файл будет записан на этом компе!
чтобы записать файл на удаленный комп нужно
    $ echo "456" | ssh thinkpad cp /dev/stdin ~/7.txt


| {!var}
как нам напечатать переменную имя которой хранится в дургой
переменной.
    $ a="1"
    $ b="a"
эта хрень нам даст просто то что лежит в $b
    $ echo "$b"
    a
а вот уже эта хрень нам сделает двойное раскрытие имени переменной и напечатает то что лежит в $a
    $ echo "${!b}"
    1
причем важно заметить что надо именно вот так сохранять имя переменной
    $ b="a"
если сделать вот так
    $ b='$a'
то раскрыть такое не полуxится и баi пошлет нахер
    $ echo "${!b}"
    bash: $a: bad substitution
а если сделать вот так
    $ b="$a"
то тоже ничего хорошего не полуxится
    $ b="$a"
    $ echo "$b"
    1
    $ echo "${b}"
    1
итак только такой вариант работает
    b="a"

    
    
    
| <<<
пока что детално неразбирался но 

    $ bc <<< 2*3
    6
тоесть это некий аналог 
    $ echo -n "2*3" | bc

    

    
    
| ${#parameter}
| ${#var}

вычисляет длинну переменной
    $ a="123"
    $ echo ${#a}
    3

если у нас скрипт то 
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"
    $ ./03.bash 1
    первый параметр = 1, длинна первого параметра = 1
    $ ./03.bash 12
    первый параметр = 12, длинна первого параметра = 2
    $ ./03.bash 
    первый параметр = , длинна первого параметра = 0

в данном случае #1 это первый аргумент передаваемый в скрипт


еще один пример
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"

    for ((i=0; i<${#1}; i++))
    do
        echo "i = $i"
    done


    $ ./03.bash 5
    первый параметр = 5, длинна первого параметра = 1
    i = 0

поскольку длинна первого аргумента скрипта "5" равна единице то цикл for имеет параметры
i=0, i<1, i++
поэтому он отрабатывает один раз
еще интересно то что {#1} означает посчитать длинну переменной $1






| ${parameter:offset:length}
| ${:::}

позволяет печатать не всю переменную а ее часть.
причем важно offset указывает начало откуда печатать
а length указывает сколько символов после оффсета напечатать
следущий пример печатает начиная с оффсет и до конца переменной
    $ a="123"
    $ echo ${#a}   # напоминаю что ${#a} считает длинну переменной 
    3
    $ echo ${a:0:${#a}}
    123
    $ echo ${a:1:${#a}}
    23
    $ echo ${a:2:${#a}}
    3
    $ echo ${a:3:${#a}}
очевидно что нумерация символов в переменной начинается с "0"

следущий пример печатает начиная с оффсет всего один символ
    $ a="123"
    $ echo "${a:0:1}"
    1
    $ echo "${a:1:1}"
    2
    $ echo "${a:2:1}"
    3



    
    
    
| ${#}
| ${:::}

вот еще интерснейший пример

    $ cat md.bash 
    #!/bin/bash

    for((i=0; i<${#1}; i++))
    do
        echo "i=$i"
        echo "${1:$i:1}"
        echo "---"
    done

    $ ./md.bash 34
    i=0
    3
    ---
    i=1
    4
    ---

значит вот эта хует ${#1} означает посчитай длинну переменной $1
где $1 это первый аргумент командной строки который был передан скрипту при запуске

вот эта хуета "${1:$i:1}" означает возмьми переменную $1 и вырежь из нее символы начиная с позиции $i
в количестве 1 штука

получается мы передаем в скрипт 34 который будет являться $1
тогда ${#1} = 2
и цикл будет работать для i=0,1

для i=0
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 0 в количестве 1 штука. тоесть это будет 3

для i=1
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 1 в количестве 1 штука. тоесть это будет 3
4

что мы и видим на экране

охуеть




| printf
это bash builtin.

при этом эти суки в man bash нихуя про него нормально не написали ублюдки.

формат этой хуеты такой

printf "format" arg1 arg2 arg3 ...

тоесть вначале задается формат печати. а потом указываются аргументы(переменные) для печати


простейщий пример
    $ printf "asd\n"
    asd

в этом примере у нас указан только формат. аргументов нихуя нет.
asd это просто литеры. а "\n" это спецсимвол переноса строки. 
все супер просто.

теперь о некоторых других спецсимволах внутри формата

Format Specifier	Description
%c	Treat the arguments as a single character.
%d	Treat the input as a decimal (integer) number (base 10).
%e	Treats the input as an exponential floating-point number.
%f	Treat the input as a floating-point number.
%i	Treat the input as an integer number (base 10).
%o	Treats the input as an octal number (base 8).
%s	Treat the input as a string of characters.
%u	Treat the input as an unsigned decimal (integer) number.
%x	Treats the input as a hexadecimal number (base 16).
%%	Print a percent sign.
%Wd	Print the W integer X digits wide.
%(format)T	Outputs a date-time string resulting from using format as a format string for strftime. The corresponding argument can be the number of seconds since Epoch (January 1, 1970, 00:00), -1 (the current time), or -2 (shell startup time). Not specifying an argument uses the current time as the default value.
\%	Print a percent sign.
\n	Prints a newline character.
\t	Print a tab character.


важно. насколко я понял формат аргумента изначально воспринимается как string
а уже потом в строке формат он конвертируется согласно приказу.
обьясняю на примерах:
    $ printf "число=%d\n" 10
    число=10
    $ printf "число=%c\n" 10
    число=1

в первом примере мы берем аргумент стринг 10 и конвертируем  его в  десятичное число
во втором примере мы берем аргумент стринг 10 и конвертируем его как символ единичный поэтому он от 10 отрезал 1 символ
с начала. начало (офссет) у аргумента начинается слева. получили 1

следущие примеры
    $ printf "%x\n"  10
    a
    $ printf "%x\n"  11
    b

мы берем аргумент в формате стринг и конвертируем его в hex формат
и вот очень важный пример, 
    $ printf "%x\n"  "A"
    bash: printf: A: invalid number
    0
    $ printf "%x\n"  "a"
    bash: printf: a: invalid number
    0
    $ printf "%x\n"  "0xa"
    a
    $ printf "%x\n"  "0xA"
    a
тоесть на сколько я понял если мы хотим конвертировать аргумент в hex формат то на входе
по дефолту ожидается что аргумент имеет dec формат. а если мы хотим уже в аргументе выразить число в hex формате
то его нужно в аргументе писать в виде "0xhex"
охуеть




следущий прмиер
    $ printf "число=%x\n" q
    bash: printf: q: invalid number
    число=0
здесь он нас законно щлет нахер потому что как я уже сказал если мы хотим сконвертиоровать
аргумент в hex формат то аргументе по дефолту принтф ожидает видеть аргумент в формате десятичном 
поэтому аргумент вида "q" приводит к посыланию нахер


двигаем дальше. есть особая залупа о которой не сказано в манах. а оно только обнаруживется в примерах.
залупа касется аргиумента

    $ printf "%d\n" "'A"
    65
    $ printf "%x\n" "'A"
    41

если указываем в аргументе вот так 'аргумент
то это сообщает принтф что прежде чем аргумент подставлять в формат его нужно из ASCII символа преобразовать 
в число причем подставить это число в аргумент именно в десяиичном виде . 
тоесть в ASCII таблице символ "A" имеет код 65(dec)

итак 65  подставляется в аргумент. 
таким макаром первый пример превращается в 
    $ printf "%d\n" 65
    65
а второй пример превращается в  
    $ printf "%x\n" 65
    41

поскольку как я уже писал если мы хотим преобраовать число в hex то принтф ожидает по дефолту что 
в аргументе число представлено в формате dec. поэтому 65 dec преврашается в 41h
если же мы хотим чтобы принтф рассмматривал уже в аргументе 65 как hex число то надо делать вот так
    $ printf "%x\n"  "0x65"
    65

ну а вот такая хрень приводит к ошике
    $ printf "%x\n"  "0x'A"
    bash: printf: 0x'A: invalid hex number
    0

вообще этот принтф это полный пиздец. выдумка шизофреника. 

следущий момент а если у нас несколько аргументов. тогда они выбираются слева направо по порядку. тоесть
    $ printf "ширина=%d, длинна=%d \n" "10" "2"
    ширина=10, длинна=2
тоесть первый %d берется как 10
второй %d берется как 2
все просто. идем слева направо.


далее. 
значит таким макаром если мы хотим по быстрому узнать какой ASCII код у символа
то можно набрать 
    $ man ascii
а можно вот так
    $ printf "%d\n" "'3"
    51
    $ printf "%d\n" "'4"
    52


далее. 
что еще интересно что вот эта хуйня $1 она возможно только при вызове скрипта
тоесть просто для команды в строке этой хуйни не сущетсует
    $ echo $1 <<< "a"
    $ echo "1" | echo $1 
    $ printf "%s \n" "$1" <<< "a"
    $ echo "a" | printf "%s \n" "$1" 
видим что везде пусто на выхлопе





| bc
с ним есть такая хуйня. если мы в него передаем строчку то обязательно 
она должна заканчиваться символом Enter иначе пошлет нахуй. 
пример
    $ echo "2*3" | bc   
    6
    $ echo -n "2*3" | bc
    (standard_in) 1: syntax error
тоесть во втором примере ошибка потому что echo -n недобавляем автоматом символ Enter
к потоку байтов. поэтому bc шлет нахуй.

тоже самое когда юзаем printf 
    $ printf "2*3" | bc
    (standard_in) 1: syntax error
    $ printf "2*3 \n" | bc
    6

    

    
    

| for

есть вот такая хуйня в баш

   for i
    do
        echo -n "vasya"
    done

мы видим   
    for i
типа что за хуйня? оказывается это есть такое сокращение для
    for i in $@
охуеть. потому что иначе эта строчка сука не имеет никакого значения падла
таким образом это эквивалент
   for i in $@
    do
        echo -n "vasya"
    done


    
    
| wc

оказалась приколная программа
что она умеет делать
  wc - print newline, word, and byte counts for each file

тоесть она умеет считать:
    число строк
    число слов
    число байтов


этот пример берет папку с *.txt файлами и считает сколько в них суммарно слов
    $ ls -1 *.txt | xargs -L1 -I% wc -w ./"%" | awk '{print $1}' | xargs echo | sed 's/ /+/g' | bc
    727721

еще можно через wc считать число букв или байтов в стринге
хотя есть подьебка
пример
    $ echo "1" | wc -m
    2
возникает вопрос почему длинна два символа.
а потому что эхо вставил символ Enter вконце. а для wc это тоже символ
    $ echo "1" | od -t x1
    0000000 31 0a

убираем enter в конце и получим уже верный результат
    $ echo -n "1" | wc -m
    1

    $ echo -n "1" | od -t x1
    0000000 31

поэтому удобнее считать число букв в стринге через awk потому что он enter не считает
пример
    $ echo  "1" | awk '{print length}'
    1

а теперь самый что ни на есть практический пример.
нужно узнаиь число букв в хеше
    $ echo "1" | sha512sum | awk '{print $1}'   | awk '{print length}'
    128
    $ echo "1" | sha512sum | awk '{print $1}'   | wc -m
    129
    $ echo "1" | sha512sum | awk '{print $1}'   | od -t x1
0000000 33 61 62 62 36 36 37 37 61 66 33 34 61 63 35 37
0000020 63 30 63 61 35 38 32 38 66 64 39 34 66 39 64 38
0000040 38 36 63 32 36 63 65 35 39 61 38 63 65 36 30 65
0000060 63 66 36 37 37 38 30 37 39 34 32 33 64 63 63 66
0000100 66 31 64 36 66 31 39 63 62 36 35 35 38 30 35 64
0000120 35 36 30 39 38 65 36 64 33 38 61 31 61 37 31 30
0000140 64 65 65 35 39 35 32 33 65 65 64 37 35 31 31 65
0000160 35 61 39 65 34 62 38 63 63 62 33 61 34 36 38 36
0000200 0a
0000201


видно что awk дает верный ответ а wc нет. потому что у нас в стринге на конце есть 0x0a тобишь Enter и wc его считает. 
а он нам нахуй ненужен.
-----


| printf

эта команда настолкло ебанутая что ее надо описать отдельно суку
во первых есть встроенный в баш билтин printf
а есть отдеьная программа которая от баша никак не зависит.
баш почмуто по дефолту запускает не свой билтин а внешнюю.
проверить это легко через strace

    $ strace printf "поле формата \n"
    execve("/usr/bin/printf"...

запустить именно билтин принудительно можно через 
    $ builtin printf "a"
справочная по билтину охуенно убогая. смотрим либо 
    $ builtin printf  --help
либо man bash

далее рассматриваем только внешнюю команду /usr/bin/printf
справка по ней тоже охуенно убогая
    $ man printf
    $ man 3 printf


    
a1
'a
$salt


значит у принтф ест  минимум одно поле. поле формата
    $ printf "поле формата"
    поле формата

в целом туда вставляется все то что мы хотим напечатать. ровно также как это есть у 
команды echo "печать"

в отличие от echo принтф не вставляет автоматом на конце символ новой строки. поэтому 
его надо вставлять руками. через "\n"
    printf "поле формата \n"
    поле формата 

слэш как и у баша в целом это спец символ. тоесть когда его встречает принтф то он его рассматривает 
не как просто печатную литеру а как то что за ней идет символ который тоже является спецсимволом и чтобы его
можно было напечатать его экранирует слэш.
помимо экранируеющего действия комбинция слэш + некоторый символ за слэшем сообщает принтф что \X это тоже 
некий спецсимвол.тоесть с одной стороны слэш может отключать функцию спецсимвола для спецсимвола котоырй стоит за слешем
с другой стороны комбинация слэша и некоторого простого символа стоящего за ним формирует в итоге спецсимвол.
чтобы это все показать на примерах я еще добавлю одну хрень. переменные можно печатать также как и у echo 
тоесть
    $ a=123
    $ printf "$a"
    123
так вот очевидно что $ это спецсимвол который обьясняет принтфу что за ним идет не просто печатный символ "a" 
что за $ идет имя переменной. 
так вот если мы хотим просто распечатать '$a' тогда надо обьянсить принтф что доллар  в данном случае это не спец
символ а просто литера. тут вступает в дело слэш. 
пример
    $ printf "\$a"
        $a
    $ printf "\$a\$a\$a"
        $a$a$a
    $ printf "$a$a$a"
    123123123
с этим понятно.
    $ printf """
    > ^C
тоесть символ " является спецсимволом и он нам его недает напечатать. 
отключаем спецсимвольность и полный порядок
    $ printf "\""
    " 
печатаем слэш
    $ printf "\\"
    \
итак мы рассморели примеры когда слэш забирает силу у спецсимвола преврашая его в просто литеру
теперь рассматриваем случай когда слэш дает спецсилу простму символу.
самый известные пример это символ кнопки Enter. тоесть символ новой строки и перенос каретки налево.
    $ printf "1 \n"
    1
тоесть будет наечатан 1 и пробел. а затем экран будет прокручен на 1 строку вверх и печатная головка
возвратится на начало строки. тоесть \n это управляющий символ терминала
далее. печатаем спецсимвол backspace (прикольно!)
    $ printf "abc"
    abc
    $ printf "abc\b"
    ab
    $ printf "abc\b\b"
    a
тоесть он затирает символ слева как кнопка backspace.
кстати backspace походу переводится как "пробел в обратно направлении"
однако тут я нашел некую необьяснимую хуйню.
вот я печатаю три символ и затираю последние два
    $ printf "abc\b\b"
    a
но если я добавляю в конце символ новой строки тобишь нажатие кнопки enter то
почемуто при этом все символы будут напечатаны. хуйня какаято
    $ printf "abc\b\b\n"
    abc
почему такая хуйня непонятно
однако далее стало понятно что "\b" это ссукат не backspace как
об этом написноа в man ascii это на самом деле аналог стрелки влево. тоест 
он передвигает каретку на один символ влево и сам символ не удаляет.
вот пример
    $ echo -ne "123\b"; sleep 5
или 
    $ printf "123\b"; sleep 5
если мы доблавяем \n то у нас прокручивыается строка наверх и поэтому 123
сохраняется. если мы \n недобавлем то баш начинает печатать с текущего положения
каретки и просто затирает 3. вот как это работает

следущий спецсимвол который образуется в паре со слещем это "form feed"
он означает прокрутить экран или бумагу на одну строку вверх при этом положение
печатающей головки остается на том же месте
    $ printf "abc\f 1  \n"
    abc
        1  
тоесть мы напечатали abc и пробел. потом прокрутили бумагу на 1 строку вверх и в той же
горизонтальной позиции продолжаем печатать.
по факте терминал (черный экран) это полны аналог матрчного принтера. у него есть 
строка в которой он печатает и он может бумагу прокручивать на одун строку вверх и есть
печатная головка которая печатате символ в текущем положении.
единственное что нет такого спецмивола чтобы строку прокрутит не на 1 строку вверху 
а обратно на 1 строку вниз. жалко.
    $ printf "abc\f1\f2\f3  \n"
    abc
        1
          2
            3  
следущий спецсимвол это вовзрат печ головки вначало строки 
    $ printf "abc\rdef  \n"
    def  
тоесть это работат так 
вначале печаается abc потом печатающая головка (курсор) возврашается вначало этой же строки
и начинает печататаь новые символы убивая старые. поэтому abc исчзаеае а def появлыется
    $ printf "vasya\rB\n"
    Basya
мы напечатали vasya потом вернули голову внвало стоки и напечатали символ B
поэтому vasya стал Basya
что интересно что если мы будем писать эту хрень в файл то в нем будут все эти символы. 
щам покажу
    $ printf "vasya\rB\n" | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
или прям запишем в файл на диске и прочитаем
    $ printf "vasya\rB\n" > 11.txt
    $ cat 11.txt | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
             v  a  s  y  a \r  B  \n    <==  я показываю какой символ ASCII\UTF-8 соотвествет какому байту

считываем этот файл с диска и видим на экране
    $ cat 11.txt 
    Basya
    
так в чем прикол  что я хотел этим показать. я хотел паоказать что 
по факту файл на диске содержить гораздо больше чем просто Basya как это мы видим на экране.
файл по факту содержит слово "vasya" которое мы на эаркне не видим. несколко упраляющих симвлов и символ "B"
когда терминал читает с диска поток байтов. то из за наличия нетолько байтов отвечающих за просто символы но и из 
за наличия управляющих терминалом байтов у нас на экране текст получается совсем не такой как он есть в файле.
таким макаром можно в тексте прятать информацию. вот еще пример
    $ printf "notebook Lenovo\rcarpet table wood\n" > 11.txt
    $ cat 11.txt 
    carpet table wood
тоесть по факту в файле есть символы "notebook Lenovo" но они при печати на терминале перетираются
из за управляющего символ '\r'
и мы видим только "carpet table wood"
хотя по факту в файле есть и то и то
    $ cat 11.txt | hexdump -C
    00000000  6e 6f 74 65 62 6f 6f 6b  20 4c 65 6e 6f 76 6f 0d  |notebook Lenovo.|
    00000010  63 61 72 70 65 74 20 74  61 62 6c 65 20 77 6f 6f  |carpet table woo|
    00000020  64 0a                                             |d.|
охуеть

следудуший спецсимвол образюущийся из за налияичия слеша это горизотальная табуляция \t
    $ printf "1\t2\t3\n"
    1	2	3
тоесть работате так. 
терминал печатает 1 потом он видит \t и делает своей печатающей головкой или курсором скачок направо на определенное
число пробелов. потом печатает 2 итак далее. вконце видит \n и тогда он прокручивает строку на 1 вверх
и возвращает печатную головку в начало строки.

следущий спецсимвол это верикальная табуляция. он чтото я не понял разницу между form feed и vertical tab
$ printf "1\v2\v3\n"
1
 2
  3
[vasya@lenovo !9]$ printf "1\f2\f3\n"
1
 2
  3

на выхлопе одно и тоже.

ксатти вовзращаясь назад. когда слэш экранирует спецсимвл лишая его силы. 
есть спец символ у принтф это %
    $ printf "%"
    bash: printf: `%': missing format character
тоеть поше нахууй
пробуем его экранировать
получаем почемуто опять пошел нахуй
незнаю почему
    $ printf "\%"
    bash: printf: `%': missing format character
и только прочитав man printf узнаем что % экранруется индивиудуаальным особым образом
    $ printf "%%"
    %
охуеть.

далее легко заметить и понять что когда мы в термиале виваем символ
то по факту в stdout или в файл улетает никако не символ а байт
    $ printf "a" | od -t x1
    0000000 61
тоесть скажем за символ "a" отвечает байт 0x61
свызь между символом на экране и байтом котоырй за ним стоит это либо ASCII таблица (man ascii)
либо это UTF-8 таблица. причем байты из ascii совпдают с UTF-8 байтами. 
так я это к чему говорю. можно указать принтф что мы вбиваем не печатный символ а сразу байт
скажем байт в hex виде в принтф прописывается как 
    \xHH
тоесть 
    $ printf "\x61"
    a
тоесть \x в поле формата сообщает принтф что это непросто литеры '\' и 'x' а что это спецсимвол который обозначает
байт в hex виде. показываю
    $ printf "a" | od -t x1
    0000000 61
    $ printf "\x61" | od -t x1
    0000000 61
соотвественно чтобы напечатать '\x61' просто как набор литер надо это экранировать
    $ printf "\\\x61" 
    \x61
тоесть мы обьяснили принтф что и \x это просто литеры. хотя непонятно почему вот такой варинт не прокатывает
    $ printf "\\x61" 
    a
ведь по идее мы сделаи \\ что обьяснило принтф что мы печатаем просто \ ну а дальше у нас просто x61
ксатти одиночные кавычки в этом плане все делают более предсказуемым
    $ printf '\x61' 
    a
тоесть видим что \x по прежнему интерпретируется как спецсимвол
но чтобы его обезвредить уже достаточно один раз применить слеш перед слеш
    $ printf '\\x61' 
    \x61

есть еще возможность указать принтф что мы печатаем не символы а байты в формате OCTAL
       \NNN   byte with octal value NNN (1 to 3 digits)

номер символа в формате UNICODE
       \uHHHH Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)
       \UHHHHHHHH
              Unicode character with hex value HHHHHHHH (8 digits)
но я не буду для этих случаев разбирать примеры.

теперь переходим к переменным принтф. хотя они у него называются аргументами.
окей буду называть их аргументами. 
значит помимо поля формат 
    $ printf "поле формата" 
у принф еще можно указать аргументы
    $ printf "поле формата" арг1 арг2 арг3
и тогда при печати эти аргументы будут вставлены в поле формата.
внутри поля формат мы обозначаем что мол сюда надо вставить аргумент через конструцию %T
где T это несколько возможных хреней. например
    %d означает что нужно взять аргумент , преобраозовать его в dec число и уже вставить 
пример
    $ printf "%d \n" "1"
    1 
тоесть он берет 1 преобразует его в 1 (то по факту в данном сулчае нихуя преобразоывать ненадо) и вставляет
в принтф. тоесть 
    printf "%d \n" "1"
превращается после подставновки в 
    printf "1 \n"
и мы получаем на экране
    1
возникает резонный вопрос а нахуя такой огород если можно сразу вставить 1 в поле формат. 
ответа я не знаю. тоесть например вот у нас есть переменная и вот у нас два совершенно равнозачных 
примера
    $ printf "$a \n"
    123 
    $ printf "%d \n" "$a"
    123 
единственный смысл такого усложнения горждения огорода я вижу в том что при таком раскладе само поле формат
может быть коротким и легко воспринимаем а сложные аргументы вынесены отдельно. например
    $ printf "%d \n" "$( echo "2*3" | bc)"
    6 
тоесть у нас поле формат маленькое компактное легко воспринимамое. а громоздкий аргумент вынесен во вне.
возможно в этом смысл такого огрода
раньше я думал что просто переменные нельзя вставлять напрму в поле формата. но как теперь понятно это не так.
причина не в этом.

так вот возврашаемся обратно к %d
как я уже сказал его смысл в том что мы берем аргумент и преобразуем его в dec вид 
и уже как литеру подставляем в поле формат. щас я покажу что значит преобразуем
    $ printf "%d \n"  "0xa"
    10 
значит у нас аргумент записан в hex виде (об этом щас поговорим). так вот %d его преобразует в dec тоесть 
0xa преобразует в 10 и постславяет уже как литера в поле формата
    $ printf "%d \n"  "0xa" ---> printf "10 \n"
    10
и получаем 10 на экране
таким образом видно что формат аргумента совершенно не обязан совпадать с форматом внутри поля формат. 
будет происходить преобразование.
и пиздец конкетной этой ситации в том что если мы находится в поле аргумент то hex формат в нем выглядит как "0xNN"
в то время как в поле формат hex формат выглядит совершенно по другому
    $ printf "\x21 \n"  
    ! 
правда и разница при этом колоссальная. hex число напряму в поле формата вставляется в байтовый поток 
как есть в виде этого hex числа без преобраования в литеру!
а hex число в аргументе как мы видим приводит к тому что оно будет преобразовано в литеру а какой у него будет 
байт уже зависит от ascii таблицы. еще раз показваю разницу
    $ printf "\x22"  
    "
    $ printf "\x22"  | od -t x1
    0000000 22

    $ printf "%d"  "0x22"
    34
    $ printf "%d"  "0x22" | od -t x1
    0000000 33 34

тоесть еще раз. hex формат в поле "формат" у нас в виде '\xNN'
а hex формат в поле "аргумент" совершенно другой в виде '0xNN'
почему так хуй знает.
но и последствия разные. в первом случае у нас 22h будет прям засунут в байтовый поток
а во втором случае hex число будет преобразовано в dec число. и будут найдены соотвствующие литеры в ascii
таблице чтобы это число в итоге нарисовать в терминале. тоесть "34" это 33h и 34h коды в таблице ascii
и тут приходит фундаментальный вопрос в голову а что еси у нас аргумент выглядит как '\x33\x34'
тоесть как мы видим это hex формат но он несоотвествует hex формату разрешенному при использовании для аргумента
    $ printf "%d"  "\x33" 
    bash: printf: \x33: invalid number
как говорится пошел нахер.
так вот как заставит принтф понимать что в аргументе используетсяя hex число просто в другом способе написания хекса.
так вот как это сделать для %d непонятно.
зато известен ключ %b
и вот что он делает
он берет то что находится в аргументе и считает что там прописаны голые байты. тоесть
    $ printf "%b" "\x21"
это полный эквивалент
    $ printf "\x21"
и в итоге получаем
    $ printf "\x21"
    !  
    $ printf "%b" "\x21"
    !  
тоесть %b берет аргумент и вставлят его в поле формата но не  в формет печатных литер а именно в виде голых 
байтов. при этом формат голых байтов должен соотвестовать правилу как эти голые байты могут выглядеть в поле формат.
пиздец
соотвстенно с этим волшенбным ключом %b мы можем использовать либо так либо так
    $ printf "%b" "\x21\x21\x21\x21"
    !!!!
    $ printf "\x21\x21\x21\x21"
    !!!!
тоесть ключ %b позволяет нам вынести из поля формата голые байты в аргумент.

приведу следущий ключ %s
он берет аргумент и вставляет как есть в форме символов как стринг.
    $ printf "%s \n" "\\\\%\\\\"
    \\%\\ 
    $ printf "%s \n" "\x21\x21\x21\x21"
    \x21\x21\x21\x21 

тоесть очень тупо и просто. ровно как мы видим символы в аргументе так они и будут напечатаны на экране

следущий ключ %c делает тоже самое что %s но печатает только первый символ
    $ printf "%c \n" "\x21\x21\x21\x21"
    \ 
    $ printf "%c \n" "\\\\%\\\\"
    \
    
    
 еще один полезный ключ это %x он или %X берет число из аргумента
и преобраует его в hex число и печатаем с помощью литер.
X отличается от  x тем что печатает результат в заглавном формате (большими буквами) 
    $ printf "%x \n" "10"
    a 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%X \n" "0xA"
    A 
    $ printf "%X \n" "0xa"
    A 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%x \n" "0xA"
    a 

ксатти вот еще интересно
    $ printf "%x" "0x21 0x33 0x34 0x56"
    bash: printf: 0x21 0x33 0x34 0x56: invalid hex number
    $ printf "%x" "0x21"
    21
    $ printf "%x" "0x2133"
    2133
    $ printf "%x" "0x21333456"
    21333456
    
по идее все самые важные и частые ключи  я описал.
соовественно если у нас есть переменная которая содержит ascii коды символов то чтобы их напечатать
именнов форме символов надо чтобы формат был вида \x21 тогда
    $ a="\x21\x33\x34\x56"
    $ printf "$a \n"
    !34V 
либо 
    $ printf "%b \n" "$a"
    !34V 

если же у нас a="21333456" либо a="0x210x330x340x56" либо a="21h33h34h56h"
то такие hex ascii коды  мы хрен распечатаем  в форме символов на раз два.
надо преобразоываать.
щас покажу. 
пусть у нас есть переменная которая хранить ascii коды в hex формате но вот в таком виде
    $ a="21333456"
и мы хотим их напечатать на экране в виде символов 
    $ sed 's/../\\x&/g' <<< $a
    \x21\x33\x34\x56
тоесть мы заменяем 
    21333456 -->  \x21\x33\x34\x56
тогда
    $ printf "%b \n" "$(sed 's/../\\x&/g' <<< $a)"
    !34V 
хотя самый простой способ превратить ascii коды "21333456" в символы это пойти по другому пути
    $ echo "21333456" | xxd -r -p | cat
    !34V

далее. вот еше прикол
понятчно и логично что если у нас  в поле формата (кстати идиотский термин) указано два аргумента
и по факту у нас два аргумента то в первый подставляется первый а во второй подставляеься второй
    $ printf "%d %d \n"  "10" "11"
    10 11 
но мне даже в голову не приходило пока не напоролся на пример в интете что 
число аргументов в поле формата может не совпадать с числом аргументов
и тогда походу они применяются по кольцу
    $ printf "%d \n" 1 2 3 4 5
    1 
    2 
    3 
    4 
    5 

пока все про printf
это не команда это какойто идиот ее писал. пиздец.






| $''

$'' эта конструкция имеет особый смысл
эта хрень позволяет определять стринг в баше аналогичный ""
причем подчеркну что $'' это единая конструкция.
так вот она дает то что эта хрень она понимает спецсимволы типа \n \t итп
это удобно если мы хотим задать например переменную у кооторой есть 
cпецсимволы.
пример
первый
    $ echo "\t1"
    \t1
как я понимаю в этом примере содержимое стринга "\t1" в памяти в байтовом виде представляет собой
    5Ch 31h, где 5Ch в ascii это символ "\" , 74h в ascii это "t",  31h в ascii кодах это "1"
соотвественно echo пытается печатать байтовый поток 0x5C7431

а вот второй пример
    $ echo $'\t1'
        1
как я понимаю в этом случае байтовое содержимое стринга в памяти совершенно другое,
а именно 0х09 "\t"  и 0x31 "1" тоесть суммарно байтовый поток содержимого стринга в памяти выглядит как 0x0931
поэтому эхо выводит другую картинку 
да можно конечно и вот так сделать
    $ echo -e "\t"1
        1
и мы получаем ровно тоже самое на выходе что и в предыдущем примере
однако механизм получения совершенно другой потому что эхо получает на входе поток 0x5C7431
но печатает не его а печатает модифицированный поток 0x0931
тоесть прикол в том что echo  с помощью спец ключа -e модифицирует входной поток. а  в предыдущем примере
поток байтов не модифицируется он тупо печатаются. 


хочу еще кое что показать
вот этот пример который отрабатывает кореектно
    $ a=$'\t \t \n \n 23'
    $ echo "$a"
	 	 
 
            23

так вот если мы обращаемся к переменной вот так "$a"
то у нас все коректно отрабатывает
    $ strace -e execve echo "$a"
    execve("/bin/echo", ["echo", "\t \t \n \n 23"], 0x7ffea8490db8 /* 66 vars */) = 0
        
а если мы убираем двойные кавычки
и обращаемся к переменной без кавычек вот так $a
то баш подставляет в execve уже некорректно
тоесть это именно баш по особому обрабатывает аргументы и подставляет в вызов execve
тоесть это не внешняя команда /bin/echo отрабатывает некоректно это именно бащ его вина
$ strace -e execve echo $a
execve("/bin/echo", ["echo", "23"], 0x7ffc356993e8 /* 66 vars */) = 0

тоесть echo "$a" и echo $a отрабатывает соверщенно по другому.  и это вина не эхо. 
это вина баша который анализирует командную строку и уже запускает эхо с совершенно разным аргументом.
этот момент я буду анализировать отдельно.

я хочу подчеркнуть что хрень $'' нужно использовать именно в таком виде. 
если это заюзать в виде "$''" то это уже неработает
    $ echo "$'\t1'"
    $'\t1'
    $ echo $'\t1'
        1



        

        

| ""
| string
| echo

хочу рассмотреть тонкий момент
и нихуя неописанный

рассмотрю на примере команды /bin/echo , тоесть эта команда не баш билтин
а внешняя по отношению к башу команда

и тут важно во первых вот что сказать вот мы в строке пуляем команду
    $ echo "123" "124"
и это все поступает в баш. он это все обрабатывает. при необходимости модифицирует и потом уже
запускает сисколл execve с параметрами. показываю на примере
в этом примере у нас в командной строке мы ввели \n а баш в execve сует нечто другое n
    $ strace -e execve echo -e \n
    execve("/bin/echo", ["echo", "-e", "n"] ...) = 0
а в этом примере у нас в командной строке мы ввели "\n" и баш в execve сует почти тоже самое "\\n"
    $ strace -e execve echo -e "\n"
    execve("/bin/echo", ["echo", "-e", "\\n"] ...) = 0
поэтому конечный результат другой не из за команды echo а из за того что баш подменяет то что
мы ему в комадной строке записали а он  в echo сует изменную хрень

тоесть важно понять что между тем что мы вбили на клаве и тем как реально будет запущена
внешняя команда с какими параметрами это разные вещи. получается вот такая схема
    мы  вбили в клаве команду  с параметрами ----> bash процесс ---> запуск внешней команды
поэтому то что мы вбили на клаве и как это будет в конечном итоге запущено это не всегда совпдает
из за того что посередине сидит баш который берет то что мы вбили и модифицириует и только потом
запускает внещнюю команду

поэтому чтобы реаьно понять как именно с каким аргументами была запущена таже самая echo 
нужно смотреть через strace

нуладно. двигаем дальше.
берем 
    $ man echo 
там сказано
вот какой у нее формат
    $ echo [SHORT-OPTION]... [STRING]...

я пытался найти как в баше задается стринг. 
но я не могу найти. что такое string? это просто любой набор символов с клавы?
или это набор символов заключенный в кавычки? я не могу найти ответ на этот вопрос
зато в man echo  я читаю вот такое

    If -e is in effect, the following sequences are recognized:
    \n     new line

тогда по идее 
    $ echo -e \n1
должно приводить к тому что \n должно дать перенос строки и потом напечатать символ "1"
однако на практике этого не происходит. а происходит полная хуйня
    $ echo -e \n1
    n1
хотя в man echo как я сказал написано совсем другое. и только если записать вот так
то работает как записано в man echo
    $ echo -e "\n1"

    1

из чего я делаю вывод что понятие STRING в баше это обязательно хрень заключенная в двойные кавычки.
иначе я не могу обьяснить результаты.
а что такое набор символов без кавычек тогда? я не могу найти.

тоже самое касается printf. в его man printf указано что \n должен приводить к новой строке.однако
этого не происходит.
    $ printf \n
    n
и только если мы заключаем эту хрень в кавычки то тогда оно отрабатывает как надо
    $ printf "\n"



тут попутно озвучу что в баш есть так называемые спецсимволы
# 
; 
" 
'
,
\
/
`
:
!
*
?
$
()
{}
[]
[[]]
(())
> &> >& >> < <>
|
>|
-
+
%
~
^
суть их  в том что бащ их по дефолут считает не просто символами печатными а спецсимволами, метасимволами.
(https://tldp.org/LDP/abs/html/escapingsection.html)

так вот я щас пытаюсь связать спецсимволы и кавычки ""
что дают кавычки. во первых я уже показал что только заключение в кавычки дает правильное поведение как 
пропсиано в манах для спецсимволов вида \n \t и тому подобных слеш спецсимволов.
так вот во вторых кавыки экранируют спецсимволы. заставляя баш (именн баш а не внешние команды типа echo) 
воспринимать спецсимволы как просто печатны символы. пример
    $ echo #

    $ echo "#"
    #

    $ strace -e execve echo #
    execve("/bin/echo", ["echo"] ...) = 0

    $ strace -e execve echo "#"
    execve("/bin/echo", ["echo", "#"] ...) = 0
    #

тоесть видно что между клавой и запуском echo сидит баш процесс который анализирует то чтомы вбили 
и в завсимости от того в кавычках или без он совсем разное вставляет в execve в поле аргументов.
тоесть
    вбили echo # --->  бащ процесс принимает и анализирует и видит что # указан без кавычек значит 
    он его рассматривает как спецсимвол и
    поэтому echo запускается вообще без аргументов ---> (execve "/bin/echo", ["echo"]) 

в bash advanced guide (https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html)
написано что все такие не все спецсимволы экранируются через "" 
а именно
    Enclosing characters in double quotes (‘"’) preserves the literal value of all characters 
    within the quotes, with the exception of ‘$’, ‘`’, ‘\’, and, when history expansion 
    is enabled, ‘!’. When the shell is in POSIX mode (see Bash POSIX Mode), the ‘!’ has no special 
    meaning within double quotes, even when history expansion is enabled. The characters ‘$’ 
    and ‘`’ retain their special meaning within double quotes (see Shell Expansions). 
    The backslash retains its special meaning only when followed by one of the 
    following characters: ‘$’, ‘`’, ‘"’, ‘\’, or newline. Within double quotes, backslashes 
    that are followed by one of these characters are removed. Backslashes preceding characters 
    without a special meaning are left unmodified. A double quote may be quoted within 
    double quotes by preceding it with a backslash. If enabled, history expansion will 
    be performed unless an ‘!’ appearing in double quotes is escaped using a backslash. 
    The backslash preceding the ‘!’ is not removed.
    The special parameters ‘*’ and ‘@’ have special meaning when in 
    double quotes (see Shell Parameter Expansion).

тоесть скажем знак $ он в "" не экранируется
поэтому мы можем "раскрывать" переменную внутри ""
пример
    $ let a="1"
    $ echo "$a"
    1


а теперь я покажу еще прикол. о том что я рекомендую не только STRING всегда заключать в кавычки
чтобы не получать приколы непонятные. но я также рекоедую всегда и имя переменной всегда заключать в 
кавычки чтобы не получать необьяснимые приколы. 
пример берем и делаем переменную со спецсимволами
    $ a=$'\t1'
    $ echo $a
    1
    $ echo "$a"
        1
и видно что когда имя переменной указано без кавычек  то получаем хуйню.
а когда в "" то получаем то что надо.

поэтому я бы постулировал что STRING в баше это только хрень заключенная в "" иначе мы будем получать
всякую непонятную хуйню.
и более того в "" нужно заключать и переменные иначе тоже будем получать хуйню.
хотя вот чисто экспериментальным путем я нашел вопреки манам как же заставить скажем echo 
раобтать со спецсимволами вида \n без использования кавычек. ответ такой что нужно вместо \n 
использовать \\n
пример
    $ echo -e \\n1

    1

    
    
| IFS
есть такая спец переменная у баша
она в себе содержит три символа. 
    - символ пробела
    - символ табуляции
    - символ новой строки
тоесть
    $ od -t x1 <<< "$IFS"
    0000000 20 09 0a 0a
где 
    20h  это пробел
    09h  это таббуляция
    0ф   это новая строка

так вот какой физ смысл этой встроенной в баш переменной?
значит баш использует символы в этой переменной для определения какие 
символы являются признаком разделителя так называемых слов.
бащ использует эту переменную только в некоторых специфических случаях.
первый случай это команда 
    $ read -a ARRAY <<< "1 2 3 4"
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
в данном случае символ пробела который есть в "$IFS" был найден в "1 2 3 4" и на основе
пробела этот стринг был разрезан на слова.
следущий пример это когда баш находит в $'1\t2\t3\t4' символ табуляции поэтому он разрезает эту переменную
на отдельные слова
    $ read -a ARRAY <<< $'1\t2\t3\t4'
    $ echo "${ARRAY[1]}"
    2
вот пример когда у нас бащ ненаходит в стринге ни пробела ни табуляции ни новой строки
поэтому стринг не разрезается на слова
    $ read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[1]}"

    $ echo "${ARRAY[0]}"
    1-2-3-4

а вот мы меняем "$IFS" и тогда баш уже находит в стринге символ который указан в IFS
и разрезает стринг на слова
    $ IFS="-";read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
хочу подчеркнуть что IFS срабатывает только в ряде небольшого числа случаев про коорые
надо прям конерктно читать. этих случаев мало. второй случай когда это работает это вот такой случай
далее я показываю ряд случаев причем я не понимаю почему в ряде случаев оно работает 
а в других нет
но разбирать почему я уже не буду
    $ a="1:2:3:4"
    $ for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ for i in "$(echo $a)"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$(echo $a)"; do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo $a); do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo "$a"); do echo "i=$i"; done
    i=1
    i=2
    i=3
    i=4

    
    

| <>
| << >>
| <<< >>>
| < <  > >
| |
| <(command)
| >(command)

<
начнем с "<"
эта штука читает из файла
тоесть справа в конечном итоге должно стоять имя файла
тоесть 
    < имя файла
справа только имя файла. болше там ничего поставить нельзя.
не получится. 
более точно формат выражени выглядит вот так
    $ command < имя файла
тогда ОС начинает сама читать из указанного файла и подавать байты на stdin процесса команды
более расширенный вариант это 
    $ command n< имя файла
где n это файловый дескриптор процесса command 
тоесть ОС сама читает файл и подает его на файловый дескриптор процесса с номер n
получается когда n мы не указваем то это по дефолту дескриптор 0
тоесть
    command < имя файла = command 0< имя файла
итак пример
    $ tr -d -c "1" < /dev/urandom | head -c1; echo ""
    1
значит что он делает ОС читает из файла /dev/urandom и подает эти байты
на stdin команды tr , и это главное. ну а далее детали. tr вырезает из потока все символы кроме
символ "1" и далее и потом из этого потока команда head выбирает один байт. 
последння команда нужна просто чтобы добавить перенос строки.
главное что нужно понять что  < можно употреблять только если у нас есть какойто файл. 
тогда мы его ставим справа то <. если файла нету то < употреблять нельзя невозможно.

    command < file_name

при этом совершенно понятно что сама команда она совершенно необязана читать байты которые 
подсовывает ей ОС. 
пример
    $ sleep 100 < /dev/urandom
тоесть команда sleep абсолютно не будет читать данные из urandom. 
хотя ОС ей на stdin подключает /dev/urandom
    $ ls -a1l /proc/24234/fd
        0 -> /dev/urandom

так тут я поправлюсь < не приводит к тому что сама ОС начинает читать файл. 
ОС лишь подключает /dev/urandom к stdin
а читает либо не читает из stdin уже код самой команды. если в команде  в ее коде нет
сисколлов на чтение то чтения не будет никакого.

аналогично команда 
    > file_name
она только подключает stdout команды процесса к  file_name
а будет писать на stdout команда процесса или не будет это уже зависит от кода команды. 
вот пример
    $ sleep 100 > /dev/urandom
    $ ls -a1l /proc/24395/fd
        1 -> /dev/urandom

и тут я перехожу к команда <<<
в чем ее ОГРОМНАЯ разница с <
а разница в том что справа от <<< должен стоять STRING
а справа от < должен стоять имя файла
и поэтому они применяются в совершенно разных ситациях
пример
    $ bc <<< "2*3"     <---- STRING
    6          
    
    $ head -c 1 < /dev/urandom   <---- файл
    k

как говорится заметь разницу
тоесть 
    command < file
делает то что на stdin процесса команды привязывается файл
а
    command <<< "STRING"
делает то что на stdin процесса команды подается то что находится в STRING
значит как я понял на подкорке это работает так что ОС создает сама файл в /tmp 
пишет туда сама "STRING" а потом когда этот файл прочитывает команда то ОС 
этот файл удаляет
    $ sleep 120 <<< "TEST"
    $ ls -1al /proc/24710/fd
    0 -> '/tmp/sh-thd.MNxZor (deleted)'
единсвтенное я не понял почему ОС удалила файл для команды sleep ведь она не читает 
свой stdin
вот еще способ проверки
    $ ls -l /proc/self/fd/ <<< "TEST"
    1 vasya vasya 64 дек  2 07:39 0 -> '/tmp/sh-thd.Olh22p (deleted)'
таким образом я сам для себя выяснил в каком случае есть смысл
использовать < а в каком случае использовать <<<
теперт это понятно. и понятно что использовать их можно только в совершенно
разных случаях.

получается что 
        command <<< "STRING"
это полный аналог команды
        echo "STRING" | command
ну типа получается что вариант с <<< он якобы более наглядный
ПРИЧЕМ важно еще заметить что <<< добавляет к исходному стрингу знак новой строки.
тоесть
    $ od -t x1 <<< "1"
    0000000 31 0a
тоесть в команду od влетает не просто байт 0x31 а еще и доблавляется символ новой строки 0x0a
таким образом полный аналог команды
            command <<< "STRING"
это именно команда
        echo "STRING" | command
но НЕ команда
        echo -n "STRING" | command
таким образом если нам важно не добавляеть к стрингу символ новой строки то нам 
нельзя пользоваться <<< а если мы нам похеру то можно.
вот еще раз я показыают какой байтовый поток вылезает из разных команд
    $ od -t x1 <<< "1"
0000000 31 0a
    $ echo "1" | od -t x1
0000000 31 0a
    $ echo -n "1" | od -t x1
0000000 31

вот еще на этих приерах видно когда одно и тоже получаем
а когда нет
    $ md5sum <<< "1"
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo "1" | md5sum
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo -n "1" | md5sum
    c4ca4238a0b923820dcc509a6f75849b  -



далее насколько я понимаю что >>> такой команды нет. 
потому что писать из stdout в "STRING" это бред
    $ echo "123" >>> "qwe"
    bash: syntax error near unexpected token `>'

далее >>
    command >> file
это аналог 
    command > file
с той разницей что в верхнем случае к концу файла добавляются данные
а во втором случае содержимое файла полностью удаляется и данные начинают
писаться в начало файла

далее <<
    command << file
как я понимаю такой команды нет


далее |
    command1 | command2
возникает вопрос в чем разница между > и |
можно ли как то через > заменить |
значит пайп приводит к тому что stdout первой команды
и stdin второй команды смотрят на один и тот же буфер в ядре. 
    stdout1 > буфер ядра > stdin2
тоесть никакой файл на диске не создается а используется буфер в ядре
так вот если command2 уже запущена то можно найти ее stdin на диске например  /proc/4444/stdin
и далее можно вот так извратиться
    command1 > /proc/4444/stdin
но повторюсь что для этого команда 2 уже должны быть запущена. а если она не запущена
то хрен ты так сделаешь. 
пайп позволяет отдать процесс увязки stdout1 stdin2 башу. 
в целом я бы сказал что > и < оно в целом предназначено чтобы читать и писать на реальные физ файлы
на диске либо спец файлы на /dev тоесть это более менее статичекие файлы причем никак не связанные 
с файлами процессов на /proc
пайп же предназначен для увязки между файлами на /proc которые там создает ядро для процессов.


далее <(command)
    command1 <(command2)
эта хрень называется bash process substitution
и она  не имеет отношения к 
    command < file
хотя вроде как немного на нее похоже
визуально можно заметить быстро разницу всегда из того что если это bash process substitution
то рядом с ним всегда стоит скобка
    <(...
а если это обычный файл редирекшн то между < и file всегда стоит пробел
    < file
у меня есть отдельная статья в этом же файле про bash process substitution.
здесь же краткое описание что как это работает
    command1 <(command2)
баш запускает command2 потом делает симлинк его stdout в файл /dev/fd/X
и подставляет в исходную команду имя этого файла
    command1 /dev/fd/X
еще раз имя файла подставляется как аргумент команды  command1
пример
    $ echo <(echo "1")
    /dev/fd/63

таким макаром конструкция 
    command1 <(command2)
имеет смысл если команда1 умеет читать из файла если ей указать имя файла как аргумент.
например тако умеет делать команда cat
    $ cat <(echo "123")
    123
и если мы хотим чтобы у нас stdout от одной команды был прочитан другой командой при условии что первая 
команда умеет читать из файла если он указан у нее как аргумент
обратная команда
    command1 >(command2)
пример
    $ cp /dev/urandom >(tr -cd "[:digit:]" | head -c10 | cat -)
    2054370200
как работает. запускается tr и его stdin через симлинк протаскивается в некий файл /dev/fd/X
и этот файл подставляется вот так 
    $ cp /dev/urandom /dev/fd/X
и cp копируется байты из urandom на stdin команды tr 
ну а дальше tr выбирает из потока только цифры. потом head берет первыех 10 цифр ну а cat их печатает.
теперь когда мы знаем что вместо 
    <(command)
    >(command)
подставляется как аргумент строки имя файла вида /dev/fd/X
будет понятен смысл вот такой конструкции
    $ wc -w < <(echo "a b c d")
    4
значит что это за загадочные < <
значит <(echo "a b c d") это bash process substitutution
а wc -w < это файл редиреккшн
если мы вспомним что в результатие bash pricess sustitution в исходную команду подставлется вот 
такая хрень /dev/fd/X то мы получаем 
    $ wc -w < /dev/fd/X
и теперь совершенно легко видно что оставшийся < это классический файл редирекшн.
справа стоит некое имя файла. а слева команда
конечно в данном примере можно было и не городить огород а сделать проще
    $ echo "a b c d" | wc -w
    4
но так возможно потому что wc такая команда она может работать как с stdin так и с файлами 
указанными ей в командной строке в качестве аргумента. другие команды не такие универсальные


напоследок разберу еше вот эти примеры

       $ cat <<< 1.bash
          1.bash
здесь понятно 1.bash воспринимается как стринг вида "1.bash"
тоесть просто набор литер

        $ cat < 1.bash
          #!/bin/bash
          ...
здесь получается что на stdin от cat привязан к файлу 1.bash
и cat читает из stdin тоесть в коненом итоге из файла 1.bash

        
        $ a="123"
        $ cat < "$a"
          bash: 123: No such file or directory
здесь понятно что  на фс нет файла с именем "123"

        $ cat <<< "$a"
          123
здесь тоже понятно что на stdin от cat привязан временный файл который содержит в себе "123"
котоырй ос создает сама в /tmp папке и поэтому cat читает из stdin по факту читает из /tmp/X
и рисует его содержимое 122


        $ cat < $(echo 123)
        bash: $(echo 123): No such file or directory
эта команда читает из файл с именем справа от >
результатом $(echo 123) будет 123 тоесть полный аналог команды это 
        $ cat < 123
но файла 123 на фс нет. поэтому пошел нахер


        $ cat <<< $(echo 123)
            123
аналог этой команды это 
        $ cat <<< "123"
эта команда позволяет засунуть стринг стоящий справа на stdin команды слева поэтому
такой резултат

        $ cat <$(echo 123)
комбинация <$(echo 123) это не bash process substituition потому что <$
результатом $(echo 123) будет 123 поэтому аналог это 
        $ cat <123
ее аналог это 
        $ cat < 123
но файл 123 на фс нет
а когда такой файл есть то все сработает
    $ echo "aa" > 123
    $ cat <$(echo "123")
    aa
тоесть в этом примере ловушка в том что вроде спервого взгляда кажетс что команда
    $ cat <$(echo 123)
это команда
    $ cat <(echo 123)
которая является bash process substitutuiion
но это не так потому что есть еще $

кстати я вверху писал что при файл редиреккшн между < и именем файла обязателно стоит пробел . вобще
то это не обязательно. 
и так и так верно
    command < file
    commadn <file
просто если это bash proces substittiuition то после < обязателно стоит (
    command <(command2)
и это его отлличает от файл редирекшн




| ascii

    $ man ascii

схема такая в устройство "терминал" поступает поток байтов. каждый байт
терминалом транслируется либо в печатный символ. либо это непечатный символа а управляющий
для терминала.

скажем 0x61 байт терминалом транслируется в печатный символ "a"
а байт 0x0a приводит к тому что терминал прокручивает картинку на 1 строку вверх и переводит печатную
головку в начало строки тоесть в самое лево и при этом конечно ничего не печатает. 
поэтому 0x61 это байт которые отвечает за печатный символ а 0x0a это байт который отвечает за
управление терминалом.

так вот среди них есть два таких байта
0x0E  (shift out) SO
0x0F  (shift in)  SI

что это за хрень. как пишект виикипедия из того что я понял был такой телетайп Model 38
это типа принтера матричного. и  у него было несколко лент разных цветом так вот эти байты
они переключали с черной ленты на красную ленту. 

дальше как я понял когда появились видимо более продвинутые матрчиные принтеры в котоорые как я понял
можно было загружаьт в память как бы доп символы например символы руского языка. то 
посылка байта SO приводила к тому что принтер начинал печатать рускими символами а SI печать латинскиими.

потом с появлением терминала VT100 это приводило к переключению символов на символы псевдографики.
тоесть скажем SO переключал на симолы псевдографиики а SI возвраащал обратно символы ascii.

в текущем окне терминала линукса посылание на терминал этих символов нихрена ни к чему не приводит.
наверное потому что по факту щас терминал работает на UTF-8 а не на ascii и тому подобное









## bash advanced scripting guide
    (https://tldp.org/LDP/abs/html/special-chars.html)


    
|как преобразовать число из двоичного или 16ричного вида в 10ый
    $ echo $(( 2#101011 ))
    43
    $ echo $(( 16#A ))
    10


    
    
    
|разделитель команд 
    ;
они пишут что после него надо обязательно ставить пробел





|шелл билтин .
что тоже самое source
эта хрень приводит к тому что скрипт выполняется в данном процессе. а не в новом.
обычно эта хрень делается чтобы в текущем процессе баша изменить или добавить переменные



|переенная "$PWD" содержит в себе текущую папку


|:
|встроенный билтин :
по факту он не делает нихрена
код возврата 0

: > file
уменьшает размер файла до нуля
даже если файл открыт 

: >> file
неделает нихрена если файл уже есть


: может использоваться как имя фукции но это нерекомендвано


|?
интересный пример использования ?
если $var1<98 то var0=9
иначе var0=21
охренеть
    $ (( var0 = var1<98?9:21 ))
правда непонятно зачем эта галиматься с (()) если все можно сделать без них

кстати
    $ echo $((var0=1))
    1

более простой пример. но для начала вот что
    (( 0 )) && echo "True \$?=$?" || echo "False \$?=$?"
    False $?=1

    $ (( 21 )) && echo "True \$?=$?" || echo "False \$?=$?"
    True $?=0

Итак если   (( 0 )) то False , 1
если        (( 21 )) то True , 0



так вот пример попроще
если 100 меньше 98 то тогда 0 иначе 21
в итоге получаем внутри скобки 21 
поскольку внутри скобки неноль то код возврата true тоесть 0
    $ (( 100<98?0:21 )); echo $?
    0

внутри скобки 0 значит код вовзрата false тоесть 1
    $ (( 1<98?0:21 )); echo $?
    1

далее
    $ echo $(( 1<98?0:21 )); echo $?
    0
    0
    $ echo $(( 100<98?0:21 )); echo $?
    21
    0
видно что можно распечатать содержимое скобки
код возврата всегда ноль потому что мы используем echo
а не просто голые скобки

еще раз наопмню что просто скобки они на stdout ничего не возвращают
но они возвращают код возврата в $?
а чтобы возвратить то что внутри скобок тогда надо 
    $ echo $(( 21 ))
    21

|$*
|$@

эти переменные почти одно и тоже.
показывает все аргументы скормленные скрипту

переменная $* берет все аргументы собирает их в одну переменную. тоесть
если

    $ ./03.bash 1 2 3 
то 
    $*="1 2 3"
то есть еще раз все отдельные аргументы будут собраны в одну переменную

а переменная $@ она собирает все аргументы в массив поэтому их можно 
потом выцепить по отдельности.
пример
    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done

запускаю
    $ ./03.bash  1 2 3
    $*=1 2 3
    $@=1 2 3

    $@[1]=1
    $@[2]=2
    $@[3]=3

    $*[1 2 3]=1 2 3

из чего видно что $@ это массив а $* это просто переменная в которой все аргументы собраны в одну кучу


| **
возведение в степень
    $ echo "$(( 2**3 ))"
    8




|$$

эта переменная показывает pid процесса скрипта

|()
эта хрень называется субшелл
пока мало ясно что это. 
как я понял все команды которые стоят внутри скобок запускаются в отдельном процессе

$ a="123"; echo "$a"; ( a="321"; echo $a); echo $a
123
321
123

как я понял основной смысл в скриптах использовать субшелл
это то что все переменные субшеллла никак не влияют на переменные основного шелла.
тоесть субшелл это чтото типа функции наверно.хотя возможо функция может 
влиять на глобальные переменные скрипта.

еще с помощью () обявляют массив
    $ a=( 1 2 3 )
    $ echo $a
    1
    $ echo ${a[*]}
    1 2 3


|{x,y,z}
фигурные скобки внутри которых 
элементы через запятые.
как я понял эта хрень работать так
если поставить символ скажем a до {
и поставить символ скажем b после }
то все хрени перечисленные внутри {}
будут обрамлены в ab.
пример
    $ echo \"{1,2,3}\"
    "1" "2" "3"
    $ echo a{1,2,3}b
    a1b a2b a3b

тоесть 1 2 3 перечислены внутри {}
а снаружи скобок стоят a и b
поэтому 1 2 3 обрамлены ими

также сказано что элемент внутри {}
перечиаляются через запятую и нельзя
между ними ставить пробел

    $ echo file.{txt,log}
    file.txt file.log

далее
не знаю что за правило но можно делать "вложенные" скобки
    $ echo {"a:","b:"}{"1","2"}
    a:1 a:2 b:1 b:2


    $ echo {"a:","b:"}{"1","2"}{"+","-"}
    a:1+ a:1- a:2+ a:2- b:1+ b:1- b:2+ b:2-

|{a..z}

    $ echo {a..z}
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    $ echo {1..10}
    1 2 3 4 5 6 7 8 9 10

| {; ; ; }
эта хрень на мой взгляд в основном нужна только для того чтобы 
для красивости обьединить команды в один красиво выглядищий кусок.
при этом никаких реальных дейтсвий эта команда не делает.
    $ { printf "1"; printf "2"; printf "3\n"; } 
    123
    $  printf "1"; printf "2"; printf "3\n"; 
    123
не вижу никакой разницы
важно после последней команды в скобках поставить тоже ; иначе пошлет нахер

без скобок я даже не знаю как вот такое сделать
    $ { printf "1+"; printf "2+"; printf "3\n"; } | bc
    6
максимум могу вот так
    $ printf "1+"; printf "2+"; printf "3\n" | tr "3" "c"
    1+2+c
в книжке написано что {} создает безымянную функцию. в отличие 
от обычной функции если мы внутри функкции определяем переменную
такую же как и в главном теле то то будет переопределена функция в главном теле.
тоесть безымянная функция может переопределять глобалные переменные
    $ a="1"; { a="2"; }; echo $a
    2

вот еще интересный пример
    $ { tr -cd [:digit:] | head -c 1 ; echo ""; tr -cd [:digit:] | head -c 1; echo ""; } < /dev/urandom 
    4
    8
    
эта штука работает так - запускается первая команда из скобки, пусть это внешняя команда, тоесть создается новый процесс.
и к его файл дескриптор 0 ядро подключает /dev/urandom. далее это уже забота самой команды либо читать из stdin 
или нет. как только первая команда отработала , то запускается вторая команда из скобки и ядро снова подключает к  stdin 
уже этого процесса файл /dev/urandom и так пока все команды из скобок не закончат свою работу

я бы сказал что эти скобки работают ровно как скобки из математики. тоесть берем математику
    ( 2+3 ) *5
раскрываем скобки
    2*5 + 3*5

тоесть ос когда работает с предыдущим примером она делает ровно вот так
    $ tr -cd [:digit:] < /dev/urandom | head -c 1 
    $ echo ""< /dev/urandom
    $ tr -cd [:digit:] < /dev/urandom| head -c 1 
    $ echo "" < /dev/urandom  

тоесть еще раз говорю что каждой команде внутри скобок подсовывается то что находится вне скобки.
что касается данного конкретного случая то далеко некаждая команда по своей сути читает из stdin
поэтому на какие то команды влияет это подключение а на другие нет

правда как этот пример переработать в эквивалент хрен знает
    $ { printf "1+"; printf "2+"; printf "3\n"; }  | bc
    6

мне кажется что проще всего понимать работу скобок так что скобка 
имеет некую единую stdin и stdout 
поэтому скажем вначале полностью отрабатывают все команды из скобки. они скажем
все срут на stdout и только потом все что было высрано командами внутри скобки
единым куском выплевывается во вне.
поэтому на bc поступает сразу единый кусок от всех трех printf

я даже в книжке нашел такое же описание

{



}  > 1.test # Redirects output of everything in block to file


также книжка дает еще один пример когда юзается {}
а именно {} используется  в команде xargs. {} в ней используется для подстановки
аргументов 
    $ ls -1 | xargs -I{}  echo "файл = {}"
    файл = 03.bash
    файл = 04.bash

    
также {} используется чтобы обозначать тело функции


| &>
эта хрень редиректит 1 и 2 в filename
    $ command &>filename 

эта хрень редиректит 1 в 2
    $ command >&2 


| >

примеры на счет использования >
    $ [[ "ab" > "cd" ]]; echo $?
    1
насколько я понимаю сравннеие идет следущим образом
берется байтовый поток обоих операндов и сравнивается как hex число
скажем ab=0x6162  cd=0x6364
вот эти два числа и сравниваются. какое больше то и победило

| pipe
берем такой код
    variable="initial_value"
    echo "new_value" | read variable
    echo "variable = $variable"     # variable = initial_value

первая команда в текущем процессе-1 задает variable="initial vaue"
вторая команда запускает дочений процесс-2 от процесса-1 для команды read variable. тоесть
    процесс-1 ===> процесс-2
вдочерний процесс-2 конечно клонируются
перменные из родительского процесса. поэтому картина такая 
    процесс-1 variable=initial_value
    процесс-2 variable=initial_value

так будет на моммент создания процесса-2
но далее эти перменные незавиисимы.

вторая строчка приведет к тому что в процесс-2 прилетит на stdin значение new_value в переменную variable
значит имеем
    процесс-1 variable=initial_value
    процесс-2 variable=new_value


третья строчка создает процесс-3 дочерний от процесс-1. клонируя при этом переенные. поэтому третья строчка напечатает что 
    variable=initial_value

насколько я понял если мы пишем в пайп и при этом есть проблема то в процесс которы пишет будет вернут
сигнал SIGPIPE (https://www.gnu.org/software/libc/manual/html_node/Operation-Error-Signals.html)

| >|

это force redirection.
через настрйоки баша можно задать что редирект неработает если файл уже сушествует.
так вот эта настройка преодолевает ту настройку
по умолчанию редирект в файл который уже существует разрешен . так что эта хрень
никогда не пригождается

| &

эта хрень позволяет раотать с джобами. по факту это баш создает дочерний процесс 
но не ждет пока тот выполнится сам ожидая в тени а после создания дочереннго процесса
обратно возврашает контроль на теоминалом себе. детали я не помню. конкретно данная хрень &
говорит о том что нужно поменстить прооцесс в бекграуд режим
пример
он создает два цикла. один выполняется в бекграуденде а второй в фореграунде
тоесть мы получаем в скрипте два параллельно работающих куска
что забавно
$ for i in {1..10}; do echo $i;sleep 3; done & for i in {11..20}; do echo $i; sleep 3; done
[1] 16570
11
1
12
2
3
13
14
4
5
15
16
6
17
7
18
8
19
9
20
10



| &&
это логический AND

правада иногда логический AND задется по другому
    if [ "$c" -eq 24 -a "$d" -eq 47 ]
    then #    ^              ^
    echo "$c equals 24 and $d equals 47."
    fi


| --
в командах опции задаются либо через - либо через --
зависит от самой команды

написано что в бащ билтинах эта хрень ообозначает конец области где задаются опции
не  в билтинах так не сработает

вобщем лучше набрать 
    $ man команда
    $ type команда
    
и посмотеть что там написано про --

| -

 
прикол с echo и -
    $ a="-n"
    $ echo "$a"
не выводит ничего. 

| ~+

это аналог $pwd

| ~-
это штука показывает предудущий рабочий каталог


| Ctrl
кнопки управления терминалом

Ctrl+A   перейти вначало строки
Ctrl+E   перейти в конец строки
Ctrl+B   стрелка влево
Ctrl+H   backspace
Ctrl+J   Enter
Ctrl+M   Enter
Ctrl+P   стрелка вверх
Ctrl+R   вылезает меню поиска предыдудущих команд по первой букве
Ctrl+S   продолжает принимать кнопки  с клавы но в термтинал их не передает
         то есть нажатия не теряюься но на терминал ничего не прилетает
Ctrl+Q   отменяет предыдущее. при этом мы увидим на экране все кнопки которые мы нажали 
         во время блока. 
Ctrl+T   меняет местами последние два введенных символа
Ctrl+U   если у нас курсор стоит посреди строки то удаляет все что левее курсора
Ctrl+W   тоже самое что предыдущее
Ctrl+Z   как я понял текущий процесс суется в бекграунд и там ставится на паузу


в мануале сказано что 
    a="^H" 
это аналог Ctrl+H 
но это полная хуйня. 
    $ echo "^H"
    ^H

| { }

я нашел замечательное примерение {}
если у меня есть какойто скрипт то чтобы его легко вбить надо всего навсего 

$ {

далее Ctrl-V скрипт 
и потом

}

и вуаля


| read
интеерсный билтин

    $ read -n10  -p '$$\>'
    $$\>
    
ключ -n дает то что символ поступают в read мгновенно а не как это есть по дефолту когда 
ожиается ввод Enter. -n 10 говорит о том что надо считать 10 символов и комарда закончит свою работу

ключ -p говорит о том что нужно на экране рисовать PROMPT тот который указан после -p в данном случае это "$$\>'
есть еще ключ -s который делает то что когда мы жмем кнопки на клаве то символы на экране не отображаются. да они улетают
в read но на экране не отображаются.

| col
как работает эта хуйня. ее ман это писаи ебанаты. в инете примеров норм нет. итак

$ echo $'\n\n\n\n  111 \v 222 \v 333 \v 444'   | col

		 444
	    333
       222
  111


значит по факту \n = \f+\r
тоесть прокркутка листа на строку вверх и вовзарат пеатной головки в самое левое положение.
\v это по идее верт и табуляция но по факту в линукс терминале это \f то есть прокрутка листа на 1 строку вверх
тоесть текс уехзжает вниз

так вот команда col она интерптиурет \v как прокрутка на 1 строку вверх а не вниз.
тоесть печатная головка поднимается наверх.
поэтому верхняя команда имеет расшифроку: опустись на 4 строки вниз и держи пеачатну гловку слева. напечаатай 111
потом подними головку на 1 строкувверх и напечаатй 222 потом подними печ головку вверх и напечаатй 333 потом поднимм
печ головку вверх и напечатай 444
тоесть таким макаром мы можем печатать текс не сверху вниз а снизу вверх.

единтвенная хуйня состоит  втом что перед тем как подниматься наверх надо обязательно опуститься вниз иначе выдаст segmentation fault
    $ echo $'\v 111'   | col
    Segmentation fault
тоесть мы еще не прокуртили лист вниз а уже пробуем поднимать головку на верх. так нихуя не работает. 
мы вначале должны опустить лист через \n (прикол что \f не подходит) и толко потом поднимать головку вверх
    $ echo $'\n \v 111'   | col
    111

тгда можно вот такое сделать

$ echo $'\n\n\n  111 \v 222 \v 333 \v 444 \n\t\t\t 555 \n\t\t\t\t 666 \n\t\t\t\t\t  777 \v 888'   | col
		 444
	    333 	 555
       222			 666	       888
  111					  777


прикол еще в том что col не понимает "\f" а жаль


| variable

оказывается что $a это сокращенная от ${a}

когда ициализируем переменную то нельзя иметь пробел слева от =
    $ a ="1"
иначе баш пытается выполнить команду a с параметром ="1"

оказется что запись
    $ a=
означает что a приварнивается значение NULL
я пока непонял эквивалетно ли это с
    $ a=""

по крайней мере
    $ a=
    $ echo -n ${a} | od -t x1
    
    $ a=""
    $ echo -n ${a} | od -t x1

на выходе байтовый поток один и тот же

оказывается можно инциализиоовать несколько переменных в одной строке через пробел

    $ a=1 b=2
    
если мы инициализируем переменную не испольуя кавычки то например "пробел"
надо экранировать

    $ a=1\ 2\ 3
    $ echo ${a}
    1 2 3

попытка напечатаать необьявленную  переменную выдаст null на выходе то есть пусто

обявление переменной это когда вот так
    $ a=
инициализациия переменной это когда мы обявляем переменную и задаем переменной значение
    $ a="1"

в любом случае резуллтат один и тот же в этих ообоих случаях
    $ echo "$b"
    $ a=
    $ echo "$a"
на выходе будет ничего
первый случай это когда переменная необьявлена
второй случай когда переменная обьявлена но неинициализирована

также оказвается что можно инициализированную переменную сделать обратно неинициализиованной
тоесть

    $ a="1"
    $ unset a
    $ echo "$a"

    
неиницализировнная перменная неимеет никаого значения а не ноль.

далее
в арифметических операциях если мы ссылаемся на необьявленную переменную то в таком случае
ее значение принимется равным нулю. это едиснчтенный случай когда необявленная переменная 
автоматом принимает значение прчием нулевое.

    $ unset a
    $ echo $a

    $ b=5
    $ echo $(( $a + $b ))
    5

далее.
опять же получается что когда мы иницализиуем переменную то нельзя чтобы ни слева ни српава от = стоял пробел.
иначе баш думает что мы ему дали команду с двумя аргуменатми

    $ a = 1
    a: command not found


переменную можно задать черещ то что ввести ее с клавы

    $ read  -p '> введите переменную и нажмите Enter > ' a; echo "a=$a"
    > введите переменную и нажмите Enter > 1
    a=1

еще переменную можно иницализиоовать вот так
    $$ a=`ls `
либо
    $ a=$(ls)

по сути они делают одно итоже. вторая команда это более новый синтаксис.
отличаются ли они внутри по реализации хрен знает


далее
наприсано что переменные у баша не имеют типов. а точнее они имеют один тип "character type"
но все равно можно желать например арифметические операции но для этого надо чтобы переменная содеражала только цифры
как я понял обработка переменных идет в завиисимости от контектса. то есть мы как бы обьясняем бащу как ему трактовать
переменную.

далее 
вот эта констурукция ${a/find/replace} ищет в переменной "$a" в любом ее места паттерн и меняет его на заданный
как толко находится паттерн то дальнйший поиск прекрашается
    $ a="#23#23"
    $ b=${a/23/45}
    $ echo "$b"
    #45#23

отличие ${a/find/replace} от ${a#find}  в том что второй всего навсего стирает заданный паттерн. причем только если 
паттерн стоит в самом начале переенной. также ${a%find} эта хрень удаляет строго с конца переенной кусок
    $ b="45#23"
    $ echo ${b#4}
    5#23
    $ echo ${b%3}
    45#2

тут параллельно вылезает такая хрень как билтин declare
например она позволяет задать свойство переменной такой что при ее дальнейше инициализации ее буквы.
я бы сказал что declare нам позволяет обьясниить башу какие значения может принимать переенная.
и тогда если мы будем давать этой переменной неправильные значения то баш будет нас посылать нахер
и преобразовывать наши неверные значения в некоторое более менее подходящее которое мы заказали
через decalre
пример declare -l огранчиывает значения только   lower case. если вводим upper case то они будут
автомтом сконвертрровны в lower case.
    $ a="AAAA"
    $ declare -l a
    $ echo "$a"
    AAAA
    $ a="BBBB"
    $ echo "$a"
    bbbb

видно что если переменная уже иницализиована и мы запускаем decalre то это никак не влияет на уже сущевтующее
значение AAAA.
а вот последующая инициализация уже проходит как надо и BBBB автоконвертиится в bbbb

а вот еще пример
declare -i огранииввает переменную только числами.
    $ declare -i b
    $ b="1"
    $ echo "$b"
    1
    $ b="a23"
    $ echo "$b"
    0

видно что когда мы задали значение переменной в форме запрещенной хрени "a23" то 
баш послал нас нахер и сконвертировал значение в 0. видимо дефолтовое значение если вводят хрень.
таким макаром ябы сказал что decalare это некий аналог типа переменных плюс автоконвертер.

кстати 
    $ declare ..
и
    $ typeset ..
это одно и тоже.

далее
declare -p позволяет посмотреть свойства переменной.

    $ declare -p  ab
    bash: declare: ab: not found

    $ ab=
    $ declare -p  ab
    declare -- ab=""

    $ ab=""
    $ declare -p  ab
    declare -- ab=""

насколко я поня из эксперимента что -- означает что на переменную не наложено никаких 
ограничений на значения. это значит что переменная была определена и иницаилизирована 
без использования declare

а вот другой пример на эту тему. 
мы определяем переменную через declare

    $ declare -i ab
    $ ab="123"
    $ declare -p ab
    declare -i ab="123"


можно посмотреть свойства встроенных системных в баш переменных

    $ declare -p IFS
    declare -- IFS=" 	
    "

    $ declare -p HOME
    declare -x HOME="/home/vasya"

едиснвтенрное я непонял смысл ключа -x = to make NAMEs export


все  полезные ключи declare
      -p	display the attributes and value of each NAME
      -i	to make NAMEs have the `integer' attribute
      -l	to convert NAMEs to lower case on assignment
      -r	to make NAMEs readonly
      -u	to convert NAMEs to upper case on assignment
      -x	to make NAMEs export


получается ключ -r позволяет задать константу
    $ unset a
    $ a="1"
    $ declare -r a
    $ echo "$a"
    1
    $ a="3"
    bash: a: readonly variable


в книжке я нашел стремный пример (https://tldp.org/LDP/abs/html/untyped.html)

    a=2334                   # Integer.
    let "a += 1"
    echo "a = $a "           # a = 2335
    echo                     # Integer, still.

    b=${a/23/BB}             # Substitute "BB" for "23".
                             # This transforms $b into a string.
    echo "b = $b"            # b = BB35
    declare -i b             # Declaring it an integer doesn't help.
    echo "b = $b"            # b = BB35


значит что этот пример делает. он беерет 2234 и сует их в $a
потом увеличиывает $a на 1 получаем 2235
потом мы берем 2235 и меняем на BB35 и присваиваем это b
итак b="BB35"
далее заупскается команда "declare -i b" и они печатают после этого $b и видят
что b=BB35 и пишут в коментацриях что мол декларе не помог превратить стринговую переменную в интеджер.
сука блядь. ну конечно же не помог. но декларе в этом не виноват. потому что как я писал выше декларе
АБСОЛЮТНО НЕ ВЛИЯЕТ на значение переменной которое уже есть. декларе влияет только на значение переменной
которое задается после применения декларе тоесть

показываю
    ...
    $ unset b
    $ b="BB35"
    $ echo $b
    BB35
    $ declare -i b
    $ echo $b
    BB35
    $ b="234"
    $ echo $b
    234
    $ b="BB234"
    $ echo $b
    0


далее. выше я писал что если переменная заобявлена или ее значение на иницализировано
и мы делаем арифемтечичекую оперцию с этой перепменной то баш ее значение в этом единственном
случае автоматом считает равным 0.
так вот эта же хрень имеет место если у нас переменная содержит символы.

    $ unset b
    $ b="BB35"
    $ echo $(( $b + 5 ))
    5

далее
если мы делим на переменную которое не обьявлена то 

    $ echo $((  5 / $abc ))
    bash: 5 /  : syntax error: operand expected (error token is "/  ")

а если мы делаим на переменную которая имеет символы в значении то по факту мы делим на 0

    $ echo $((  5 / $b ))
    bash: 5 / BB35 : division by 0 (error token is "BB35 ")
 
суммарно в плане declare я хочу сказать что польза от нее в том что если 
мы точно знаем что переменная должна принимать только числовые значения то можно 
это задать через declare хотя поведение при этом мне мало нравится. если бы
после этого при попытке присвоить пеерменной символы бащ выдавал ошибку
это было бы круто. а то что он втихаря корнвертирует стринг в 0 
неуверен что это поможет дебажить скрипт.
что касается автоковнертации стрингов в ловер кейс или аппер кейс помоему 
это вообще слабая хрень ненужная никогда или очень редко

кстати
    $ seq 10
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

кстати 
  eval это билтин баша который вот что делает "Execute arguments as a shell command."
тоесть если вставим аргумент в eval то этот аргумент будет выполнен как команда баша.
пример

    $ eval "ls -1"
    -
    03.bash
    04.bash
    05.bash
    10.bash
    11.txt


теперь беру такой пример
    $ seq 10 | sed -e 's/.*/export var&=1/'
    export var1=1
    export var2=1
    export var3=1
    export var4=1
    export var5=1
    export var6=1
    export var7=1
    export var8=1
    export var9=1
    export var10=1


тоесть seq создает числа от 1 по 10. и эта цифра подставляется вместо & в export var&=1
далее если мы это заключим в eval как аргумент тот этот код будет выполен в баше
пример

    $ seq 10 | sed -e 's/.*/echo "number = &";/' 
    echo "number = 1";
    echo "number = 2";
    echo "number = 3";
    echo "number = 4";
    echo "number = 5";
    echo "number = 6";
    echo "number = 7";
    echo "number = 8";
    echo "number = 9";
    echo "number = 10";

    $ eval $( seq 10 | sed -e 's/.*/echo "number = &";/' )
    number = 1
    number = 2
    number = 3
    number = 4
    number = 5
    number = 6
    number = 7
    number = 8
    number = 9
    number = 10


далее 
 переменные окружения передаются от родительского процесса его дочерним.
в обратную сторону связи нет. от дочери родителю ничего из переменных не передается.


далее
команда basename. она берет полный путь к файлу как аргумент. и возвращает только конечный файл
    $ basename '/home/vasya/temp/\!9/debug.bash'
    debug.bash
кстати надо заметить что хотя я использовал '' для указания пути но знак ! все равно нужно 
экранировать , так как иначе вместо !9 баш подставляет туда команду из баш хистори.

кстати 
можно сделать переменную как readonly нетолько через decalre но и через 
другой билтин readonly
во первых этот билтин может показать за один раз все переменные которые 
имеют свойства readonly

    $ readonly -p 
    declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote"
    declare -ir BASHPID
    declare -ar BASH_REMATCH=()
    declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
    declare -ir EUID="1000"
    declare -ir PPID="26695"
    declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor"
    declare -ir UID="1000"
    declare -r a="1"
    declare -r abc


как сделать переменную read only
    $ readonly abc
для сравнения через decalre это делается так
    $ declare -r abc

так вот далее я нашел такую шокирующую инфо о том что если мы переменную обьявили как константу (рид онли)
то обратно ее превратить в обычную переменную = нельзя никак. все что можно это убить этот процесс баша.
ничего сделать нельзя другого.но есть вот какой выход. мы можем запустить в данном баше
еще один баш. дочерний баш унаследует все переменые из родителя. но при этом переменная наша уже не будет
иметь статуса рид онли. пример

    $ readonly abc
    $ unset abc
    пошел нахер
    $ bash
    $ unset abc
    сукксесс
    

далее 
 -n $var  проверяет что длинна переменной НЕноль. если длина НЕноль то код возврата $?=0 (success)
пример
    $ a="123"; [ -n "$a" ] && echo "переменная \$a непустая"
    переменная $a непустая


далее
рассмотрим такой скрипт
    $ cat 06.bash 
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 

смотрим результаты работы
    $ ./06.bash 
    Parameter #1 отсуствует
    $ ./06.bash 1
    Parameter #1 is 1
    $ ./06.bash "1"
    Parameter #1 is 1
    $ ./06.bash ""1""
    Parameter #1 is 1
    $ ./06.bash "\"1\""
    Parameter #1 is "1"

что примечательно. если мы вызываем скрипт с аргументом который выглядит как 1 либо "1" либо ""1"" то он 
прилетает внутрь скрипта как 1.  
а если мы хотим чтобы внутри скрипта прилетел именно "1" то аргумент нужно в командной строке задавать как "\"1\""
удивительно.

далее. прикол
для того чтобы работать с аргументом 10,11 итд то нужно к ним обращаться внутри скрипта не как $10 или $11
а ${10) , ${11}
об этом написано в книжке

    $ cat 06.bash   
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 


    if [ -n "${10}" ]              
    then
        echo "Parameter #10 is ${10}"  
    else 
        echo "Parameter #10 отсуствует"
    fi 

работа скрипта
    $ ./06.bash 1 2 3 4 5 6 7 8 9 a
    Parameter #1 is 1
    Parameter #10 is a


далее
скрипт
скрипт берет путь к скрипту. удаляет из него весь путь кроме названия файла.
и потом к нему добавляет ./

    #!/bin/bash
    echo "путь к скрипту ./$(basename "$0")"

запускаем скрипт
    $ ./06.bash 
    путь к скрипту ./06.bash

далеее
еще раз напомню про $@ и $*
первая сохраняет все аргументы скрипта в массив.
а вторая собирает все аргументы в единую переменную

    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done


запускаю скрипт
    $ ./03.bash 1 2 3 4 5 6 7 8 9 a
    $*=1 2 3 4 5 6 7 8 9 a
    $@=1 2 3 4 5 6 7 8 9 a

    $@[1]=1
    $@[2]=2
    $@[3]=3
    $@[4]=4
    $@[5]=5
    $@[6]=6
    $@[7]=7
    $@[8]=8
    $@[9]=9
    $@[a]=a

    $*[1 2 3 4 5 6 7 8 9 a]=1 2 3 4 5 6 7 8 9 a

что интеерсно. что индексы в массиве начинаются с единицы походу. а не с нуля.

далее
 -lt 
означает less than. арифм сравнение
    $ a="12"; [ "$a"  -lt 100 ] && echo "\$a меньше чем 100"
    >>$a меньше чем 100

далее
на счет []
согласно man bash это одно и тоже
    $ test expr
    $ [ expr ]
    
также в баше есть билтин '['
но также есть и внешняя команда /usr/bin/[
так вот баш запускает именно внешнюю команду

$ strace [ 10 -lt  1 ]
execve("/usr/bin/[", ["[", "10", "-lt", "1", "]"], 0x7ffdd5429b60 /* 66 vars */) = 0

тоесть запускается файл  "/usr/bin/[" а дальше к этой команде присобачиваются аргументы. причем обязательно последним
аргументом нужно указать "]" иначе программа пошлет нахер/

получается первая скобка это название файла. далее идут аргументы. и последняя скобка это тоже аргумент.

что странно если я набираю 
    $ man [
он мне выдает man от команды /usr/bin/test
хотя /usr/bin/[ и /usr/bin/test это два разных файла

    $ stat /usr/bin/[
        File: /usr/bin/[
        Size: 51384     	Blocks: 104        IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23330837    Links: 1

    $ stat /usr/bin/test
        File: /usr/bin/test
        Size: 47288     	Blocks: 96         IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23332131    Links: 1

видно что иноды разные

хотя еще как я уже сказал и есть башевский билтин [

    $   builtin [ 10 -lt  1 ]


кстти выискивать что значат все эти -lt -n -d и прочие штуки для сравнения проще не в man bash а в 
    $ man test

| !

возвращаюсь к вопрому который уже освещал.
как в переменной укзать имя другой переменной и потом докопаться до этой второй переменной из первой переменной
а вот как
    $ a="1"
    $ b=a
    $ echo ${!b}
    1

замечу что именно ${!b} а вот так не работает ${!$b}

теперь если вернкемся к спец перееменным которые ест при вызове скрипта. то там есть спецпеременая $#
соовествнно ее имя # 
эта переменная укзаывает на число аргументов с которыми запущен скрипт. напоминаю что $0 это имя скрипта $1 первый аргумент
соовесвтенно $n это n-ый аргумент. получается если аргуметов 10 то $#=10 и значит эта же переменная показыает на две хрени 
сразу и на число переенных и на номер последней переменной. еще раp $# указывает на порядковый номер последней переменной 
но естевственно не содержит значение этой последней переменной. и чтобы посмотреть ее содержимое надо вот так 
    $ echo ${!#}
теперь имеем скрипт
он работает так
мы проверяем что число аргументов скрипта больше чем 0
если это так то мы печатаем содержимое переменной имя которой хранится в переменной с именем # тоесть ${!#}
потому что если аргументов 10 то $#=10 а нам нужно добраться до ${10}
    $ cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo "число аргументов 0"

запускаем его
    $ ./07.bash 
    число аргументов 0

    $ ./07.bash a b c 
    последний аргумент =  c

    $ ./07.bash 1 2 3 4 5  a b c d e f
    последний аргумент =  f


хочу заметить что если скрипт запущен без аргументов  то у него все равно всегда есть один аргумент $0 который
содержит имя скрипта. точнее путь к скрипту.

я модицфиуировал скрипт

    $  cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo -e "число аргументов 0,\nоднако \$0=\"$0\""

теперь запускаю скрипт без аргументов
    $ ./07.bash
    число аргументов 0,
    однако $0="./07.bash"

далее рассматривается интересная вещь.
вот у нас есть переменная
    $ a="123"
мы хотим создать новую перемнную которая будет в себе содержать "$a" + "_"
как это сделать. первая попытка
    $ b="$a_"
    $ echo $b

однако на выходе пусто. почему. потмоу что баш ищет переменную с именем a_ которой конечно нет.
а как нам тогда обьяснить то что мы хотим. а вот как
    $ b="$a"_
    $ echo $b
    123_

вот еще похожий пример
    $ read -p '>>' var1; echo "var1=$var1"; var2="$var1"_; echo "var2=$var2"; var3="${var2%_}"; echo "var3=$var3"
    >>890
    var1=890
    var2=890_
    var3=890

мы считываем переменную из клавы. потом добавляем "_" потом его отрезаем обратно.

до этого обсуждалась проверка вида -n $a которая проверяет что длинна стринга ненулевая.
есть обратная проверка которая проверяет что длинна стринга нулевая -z $a

    $ a="" && [ -z "$a" ] && echo "переменная пустая"
    переменная пустая
    

еще пример на созвучную тему

    $ cat 08.bash 
    #!/bin/bash

    if [  -z "$1" ] 
    then
        echo -e "ERROR: аргумент отсутствует \nUsage: $0 arg1 "
        exit 1
    else
        echo "аргумент = $1"
    fi

запускаю скрипт
    $ ./08.bash 
    ERROR: аргумент отсутствует 
    Usage: ./08.bash arg1 

    $ ./08.bash  "1a"
    аргумент = 1a

    
| ${var:-default}

эта хрень позволяет задать дефолтовое значение если значение переменной $var незадано или равно пусто
что вобщем то одно и тоже

    $ a="1"; b="${a:-33}"; echo "$b"
    1
    $ a=""; b="${a:-33}"; echo "$b" 
    33

эта хрень поможет в скрипте. если мы не хотим проверять был ли введен аргумент $1 или нет.
тогда нам поможет эта констркция.

    $ cat 09.bash 
    #!/bin/bash

    disk="${1:-sda}"
    echo "диск = $disk"

запускаю скрипт
если мы не указываем при запуске аргумент 
то баш подставляет в переменную дефолтовое предопределенное значение
    $ ./09.bash  sdb
    диск = sdb

    $ ./09.bash 
    диск = sda


| case


    case EXPRESSION in

    PATTERN_1)
        STATEMENTS
        ;;

    PATTERN_2)
        STATEMENTS
        ;;

    PATTERN_N)
        STATEMENTS
        ;;

    *)
        STATEMENTS
        ;;
    esac

кстати последння хрень это если не будет найдено ни одно значение.
а вот пример case когда он в одну строчку

    $ { case "b" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    b
    $ { case "z" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    не найдено


далее
пример
скрипт проверяет наличие аргумента при вызове скрипта.
и печатает этот аргумент
далее проверяется под каким именем файла был запущен скрипт.
если имя файла 10.bash или 11.bash то печатается имя скрипта

сам скрипт имеет имя 10.bash
также надо создать симлинк 11.bash 

    $ ln -s ./10.bash ./11.bash

    $ cat 10.bash 
    #!/bin/bash

    E_NOARGS=75

    if [ -z "$1" ]
    then
        echo  "Error: NO_ARGS"
        echo  "Usage: $(basename $0) [ARG]"
        exit $E_NOARGS
    else
        echo "аргумент = $1"
    fi



    case "$(basename "$0")" in

        "10.bash")
            echo "скрипт запущен как  10.bash"
            ;;

        "11.bash")
            echo "скрипт запущен как 11.bash"
            ;;

        *)
            echo "неопознанная ошибка"
        exit 1
            ;;
        esac



запускаю скрипт
    $ ./10.bash    
    Error: NO_ARGS
    Usage: 10.bash [ARG]

    $ ./11.bash    
    Error: NO_ARGS
    Usage: 11.bash [ARG]

    $ ./10.bash    123
    аргумент = 123
    скрипт запущен как  10.bash

    $ ./11.bash  234  
    аргумент = 234
    скрипт запущен как 11.bash



| shift

как уже было сказано выше он сдвигает аргументы которые были указаны при вызове скрипта
тоесть второй аргумент присваивается первому 
    $2 ---> $1
третий аргумент присвивается второму
    $3 ---> $2
единственное что $0 остатеся неизменным. это логично


напомню что shift может сдвигать нетолько на 1 аргумент влево но и на другое число
    $ shift N
по факту эта команда делает вот что. она берет и сжирает первые N аргументов. 
щас покажу

    $ cat 12.bash 
    #!/bin/bash

    until [ -z "$1" ]
    do
        echo "\$@=$@"
        shift 8 || break
    done

запускаю скрипт
    $ ./12.bash  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
        $@=1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
        $@=9 10 11 12 13 14 15 16 17 18 19 20
        $@=17 18 19 20

тоесть мы имеем N=8 значит на первом этапе сжираются аргументы 1-8
было 
    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
стало
                    9 10 11 12 13 14 15 16 17 18 19 20

далее на следущем шаге опять сжираются 8 первых арументов
было 
    9 10 11 12 13 14 15 16 17 18 19 20
стало
                            17 18 19 20


далее что происходит если shift хочет сожрать 8 аргументов а нужного числа арунментов нету
как в случае 

    17 18 19 20

так вот происходит то что шифт останавливается. нихрена неделает. и выдает $?=1

я бы сказал что более удобно рассматривать что shift не сдвигает аргументы. а сжирает аргументы.
тоогда все понятно.
единственно что помним что аргумент $0 этой командной не трогается.

| $0
если  мы запустили скрипт то в $0 содержится путь к файлу скрипта.
а если мы запустили echo $0 из командной строки то оно показвыает bash

    $ echo $0
    bash


| []
следущий пример выбирает файлы
которые начинаются либо с "0" либо с "1"

    $ ls -1 [01]*
    03.bash
    04.bash
    05.bash
    06.bash
    07.bash
    08.bash
    09.bash
    10.bash
    11.bash
    11.txt
    '12 13'
    123
    12.bash
    1.bash


    
    
    
    
| ""
| ''


тема quoting в баще

квоутинг делает то что ряд спецсимволов перестает быть спецсимволом и становится
только печатным символом. но бывают команды которые все равно плюют на квоутинг
и продолжают воспринимать спецсимволы
пример

    $ grep '[Vv]' t*.txt
    t1.txt:vasya
    t2.txt:Vasya

    
    
| command

это билтин
делает он то что запускает команду. спрашивется нахуй тогда он нужен.
а нужен он затем что если у нас в скрипте есть функция с именем таким же как команда 
то command позволяет запустить не функцию а именно команду.
работает хрень вот так
    $ $ command ls -1
    03.bash
    04.bash
в целом вобщем то бесполезный билтин


| \


знак \ позволяет экранировать спецсимволы внутри ""
в итоге если мы будем экранировать не спецсимвол то напечаатется и слэш и простой символ
пример
    $ echo "\a"
    \a

если мы экранируем спецсимвол то сам слэш исчезает . будет напечатан только спецсимвол как
просто символ
прмиеры
    $ echo "\\"
    \

    $ echo "\$"
    $

    $ var2="\\\\\""
    $ echo "$var2"
    \\"

чтобы избежать непонятных непоняток я рекомендую всегда все переменные заклчать в ""
иначе результаты будут часто непредсказуемые.


вот это подьебочный пример

    $ echo "$(echo '"')"           # "
    "

хрень  состоит из двух частей
    "$(echo '"')"   +      # "   
которое можно схематично представить как 
    "..."  +    #"
    
что можно представит схематично как
    $ echo "..."     +   # "
из чего наконец можно понять что мы получим на выходе то что у нас есть команда echo и справа от нее просто
напросто стоит комментарий (который начинается с символа #).
поэтому комментарий можно свободно выкинуть ибо он ни на что не влияет тогда получаем
    $ echo "..." = $ echo "$(echo '"')" = $ echo """ => на выходе будет "
проверяем
    $ echo "$(echo '"')"           # "
    "
совпало.
пример было пиздец
еще пример пиздец
    $ var1="Two bits"
    $ echo "\$var1 = "$var1""
    $var1 = Two bits
насколко я понимаю эта хрень работает так. он берет кавычку и ищет ближайшую кавычку справа.тогда
    echo "\$var1 = "$var1"" = echo "\$var1 = "    +  $var1  +  ""
тоесть у echo стоит три аргумента
    "\$var1 = "
    $var1
    ""
первый и третий аргумент заключены в кавыки а второй нет. 
печать первого аргумента даст
    $var1 = 
печать второго даст
    Two bits
печать третьего даст пусто . в итоге на экране будет
    $var1 = Two bits
что мы и имеем на практике

вот несколько изменный тот же пример где 
я подсветил каждый из трех аргументов
    $ echo ">\$var1 = <"       $var1        "><"
    >$var1 = < Two bits ><


| "

внутри двойных кавычек можно без проблем печатать одинарные кавычки
пример
    $ echo " '   "
    '   
    $ echo " ' '  "
    ' '  
никаких проблем
как и в этом прмиере
    $ echo "Why can't I breath 's between single quotes"
    Why can't I breath 's between single quotes


    
    
    
| '
одиночная кавычка якобы блокирует все спецсимволы. кроме символа '
если мы хотим напечатать ' внутри '' то  не получится
пример
    $ echo '''
    > 
тоесть этот пример это аналог 
    $ echo ''   '
тоесть у нас есть одна пара закрытых кавычек и есть одна пара незакрытых кавычек
поэтому пошел нахер говорит баш

| \

приколнно что это будет напечатано в две строки
    $ echo "This will print
        as two lines."

потому что когда мы тыкаем Enter мы "печатаем" символ Enter

    $ echo "a
    > b"
    a
    b

    $ echo "a
    b" | od -t x1
    61 0a 62 0a

и так как \ стоящипод кавычками оотключает значение спецсисмволов то он отключает и значение спецсимвола 0x0a 
    $ echo "a\
    > b"
    ab

    $ echo "a\
    b" | od -t x1
    61 62 0a

    
опять же повторюсь что если слеш стоит не перед спец символом то он не исчезнет а будет напечатан
    $ echo "\a"
    \a
а если он стоит перед спецсимволом то он не будет напечатан
    $ echo "\$"
    $


еще момент. если эхо запущен без -e то слэш только экранирует спецсимволы
    $ echo "\t1"
    \t1
а если эхо с клюючом  -e то комбинация слэша с некоторыми обычными символами
рассматривается как спецсимвол. например \t это горизональная табуляция
пизздец ебанизм и заморочка
    $ echo -e "\t1"
            1
            
            
тоесть зацени разницу
одна и таже команадна с одним и итем же аргументом но 
без ключае -e и с ключом -e
    $ echo  "\t\t\t\t1"
    \t\t\t\t1
    
    $ echo  -e "\t\t\t\t1"
                    1

            
кстати если юзать $'....' то ключ -e и ненужен
    $ echo   $'\t\t\t\t1'
                    1

замечу что одинарные кавычки ' внутри "" абсолютно леагальны. и их ненужно эакраинировать
    $ echo "Introducing the \$\' ... \' string-expansion construct . . . "
    Introducing the $\' ... \' string-expansion construct . . . 

    $ echo "Introducing the \$' ... ' string-expansion construct . . . "
    Introducing the $' ... ' string-expansion construct . . . 

еще интереный пример
    $ echo "1   $'\n\n' 2"
    1   $'\n\n' 2

тоесть $'' неработает внутри ""
тоесть нужно $'' вынести за ""
пример
    $ echo "1   " $'\n\n'"  2"
    1    

        2
            
здесь у нас три аргумента под эхо
    "1   "
    $'\n\n'
    "  2"

вот еще пример о том что $'' неработает если находится внутри ""
    $ echo  $'\n\n1'


    1
    
    $ echo  "$'\n\n1'"
    $'\n\n1'


| tac
| cat
| rev

есть такой прикол команды 
    cat
    tac
    rev
в чем их разница?
вот у нас есть файл
    $ printf  "123\n456\n789\n"
    123
    456
    789

cat его читает с нулевого оффсета и до конца файла
    $ printf  "123\n456\n789\n" | cat 
    123
    456
    789
    
tac его читает с конца построчно
тоесть у нас в тексте будут переставлены строки
скажем если нумеровать строки то у нормально документа
они идует как 1,2,3....100
а после чтения его чеерез tac строки будут идти 100,99...1
символы в строках порядок сохраняют оригинальный
    $ printf  "123\n456\n789\n" | tac
    789
    456
    123

вот более понятный пример 
про разницу cat и tac
    $ printf  "1. mama\n2. mila\n3. ramu\n" | cat
    1. mama
    2. mila
    3. ramu

    $ printf  "1. mama\n2. mila\n3. ramu\n" | tac
    3. ramu
    2. mila
    1. mama

тоесть еще раз переставляются строки но не символы в строке
для работы tac ему нужно читать файл сконца к началу искать очередной
символ 0x0a а потом его в памяти переставлять, тоесть ему читая
символы в обратном порядке нужно найти конец предудущей строки. 
а потом переставить символы в строке из обратного порядка к нормальному.
поэтому tac работает в несколько раз медлнее чем cat

вот я взял файл размером 1,59GB 

    $ cat "./17830.txt" | pv 1>/dev/null  
    1,59GiB 0:00:01 [1,07GiB/s]
    
    $ tac  "./17830.txt" | pv 1>/dev/null  
    1,59GiB 0:00:05 [ 316MiB/s]
    
как говорится почуствуй разницу

и последняя команда rev.
она работает вот как. она читает файл
с начала файла. прочитвыает строку 
(тоесть ищет 0x0a)
а далее она в этой строке перетавляет
символы зеркально наоборот.
поэтому строки не будут переставлены
будут переставлены символы в каждой строке.
примеры

оригинальный файл
    $ printf  "1. mama\n2. mila\n3. ramu\n" 
    1. mama
    2. mila
    3. ramu

обработка через rev
    $ printf  "1. mama\n2. mila\n3. ramu\n" | rev
    amam .1
    alim .2
    umar .3

оригинальный файл
    $ printf  "123\n456\n789\n"
    123
    456
    789

обработка через rev
    $ printf  "123\n456\n789\n" | rev
    321
    654
    987

получается tac переставляет строчки а rev переставляет символы.
значит если мы хотим получить файл у которого полностью переставлены все символы.
тоесть чтобы он стал записано полнтстью с зада на перед то надо вот как сделать

оригинальный файл
    $ printf  "1. mama\n2. mila\n3. ramu\n" 
    1. mama
    2. mila
    3. ramu

задом наперед
    $ printf  "1. mama\n2. mila\n3. ramu\n"  | tac | rev
    umar .3
    alim .2
    amam .1

получается что tac читает файл с конца  а rev читает с начала. 

    

    
| clear
внешняя команда.
очищает окно терминала

| read

если мы не указали в какую переменную или переменные считывать данные то по дефолту 
данные считываются в переменную $REPLY

с помощью read можно узнать какой байт или байты влетают в комп
при нажатии той или иной кнопки. в том числе и спец кнопки типа ESC, DEL, BACKSPACE, ENTER

    $ clear; read -s  -p '>>нажмите кнопку и нажмите Enter>>'; \
      echo ""; echo -n "код кнопки "; od -t x1 <<< "$REPLY" |  head -n1 | cut -c 8- | rev | cut -c 3- | rev

      >>нажмите кнопку и нажмите Enter>>
     код кнопки  1b 5b 32 7e
 
 
оказывается что простецкие кнопки типа "a" "b" посылают всего один байт.
например если тыкнуть кнопку "a" то получим

    >>нажмите кнопку и нажмите Enter>>
    код кнопки  61 

еще ксатати кнопка ESC посылает тоже только 1 байт

    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 
    
а вот если мы жмем спецкнопки типа DEL,  ENTER, Pg_Up
то эти кнопки посылают за нажатие сразу несколько байтов

DEL:
    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 5b 33 7e
    
    
Pg_UP:
    >>нажмите кнопку и нажмите Enter>>
    код кнопки  1b 5b 35 7e

чтобы кнопку Enter отсканировать то надо сменить скрипт
    $ clear; read -n4 -s  -p '>>нажмите кнопку>>';       echo ""; echo -n "код кнопки "; od -t x1 <<< "$REPLY" | cut -c 8-
    >>нажмите кнопку>>
    код кнопки  0a


    
как отсканировать кнопку BAckspace непонятно. ладно двинем дальше.

далее мы хотим считывать с клавы кнопки которые высирают от одного байта 
по четыре байта. тоесть число байтов разное. потому что нажатие на одну кнопку 
приводит к тому что клава высирает в ос один байт. а нажатие на другую кнопку
привод к тому что ос высирает в ос четыре байта. или три байта.
и чтобы это можно сделать без нажатия на Enter после нажатия на кнопку.
положим мы нажимаем на кнопку которая высирает 4 байта за раз. типа кнопка Insert
    $ read -s -n1 a; read -s -n2 b; read -s -n1 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 32 7e
вот мы получили код этой кнопки
тоесть клава срет 4 байта, первая команда read считывает первый байт,
вторая команда считывает следущий два байта,
третья команда считывает последний четвертый байт

кстати я тут нашел одну хрень нужно заменить -n на -N 
потому что если юзать -n то read в этом случае игнорирует влетающие 
байты которые совпадают с тем что указано в IFS.
в IFS у нас в частности есть байт пробела . поэтому если мы 
будем нажимать пробел то read его будет игнорировать и ждать
дальше прилета друогого байта а если юзать -N то если в read
влетает байт соотвествующий пробелму то он его радостно
всасывает
поэтому

    $ read -s -N1 a; read -s -N2 b; read -s -N1 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-


но тут проблема получается если у нас пуляется c клавы один байт
тогда у нас срабаыватет первый read. управление передается второму read. но так как
байт всего один с клавы то вторая команда будет висеть вечно! поэтому нам надо 
для второй и третьей команды установить тайм аут. чтобы они отваливались если тайм аут достингнут.
кстати поправка- как я понял кнопка на клаве порождает либо один байт либо три либо четыре. 
вроде как два байта породить кнопка не может. поэтому второй read это два байта читает. тогда делаю
поправку  я во второй и третий read вставляю таймаут после которого команда заканчвает свою работу

    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-


тогда нажимаю "SPACE":
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    20

нажимаю INSERT:
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 32 7e

нажимаю "стрелка направо":
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    1b 5b 41






далее скрипт из интернета:
работает он так
инициализируется переменная 
    key="кнопка не нажата"
на экране печатается баннер
потом печатается на экране содержимое переменной $key  
    You pressed: \'"$key"\'
далее система ожидает поступления одного байта
причем ждет она этого бесконечно
    read -s -N1 -p "Press a key: "
если мы нажали кнопку то там еще тогда отрабатывает два read
причем там уже нет бесконечного ожидания поступления байтов.
наоборот там есть таймаут для ввода
    read -s -N2 -t 0.001
    read -s -N1 -t 0.001

справшивается нахуя такая сложная схема
почему нельзя заменить эти три рида одним. 
это сделано из за того что после нажатия кнопки
в ос прилетает разное количество байтов. 
от 1-го байта до 4-ех байтов
поэтому если мы заменим все одной командой которая 
читает 4 байта
    read -s -N4 -p "Press a key: "
то при нажатии кнопки которая выдает один байт
то эта команда будет ждать поступления оставшихся трех байтов.
а их то не будет. или надо будет нажать кнопку четыре раза.
а это нам не подходит.
можно конечно сделать по другому. можно убрать из read описание 
сколько байт нужно считать и заменить это тем что надо нажать кнопку
а потом нажать кнопку Enter 
но в том то и прикол что мы нехотим после нажатия кнопки нажимать еще и Enter
мы хотим обойтись без Enter
тогда работает такая схема
    read -s -N1 -p "Press a key: "
    K1="$REPLY"
    read -s -N2 -t 0.001
    K2="$REPLY"
    read -s -N1 -t 0.001
    K3="$REPLY"

первая команда ждет поступления одного байта с клавы
пока байт непоступит команда ждет. ждет бесконечно.
далее следущая команда уже неждет бесконечно. она ждет всего навсего t=0.001c
и ждет с клавы два байта. и последняя команда ждет t=0.001с ждет поступления 
один байт.
это дает то что если мы нажали кнопку и клава на это высирает в ос всего один байт то 
K1="байт"
а K2=""
K3=""
если же после нажатия кнопки с клавы летит 4 байта. то 
тогда будет
    K1="байт"
    K2="два байта"
    K3="байт"
таким макаром эта схема позволяет ловить с клавы от один,
три, четыре байта. и при этом ненадо нажимать Enter после
нажатия кнопки. после этого переопределяется 
переменная $key
    key="$K1$K2$K3"
далее перезапускется цикл while,
очищается экран через clear
печатается баннер.
анализируется $key и он печатается тоже.
далее появляется первая команда read 
который ждет первый байт. причем ждет бесконечно
    read -s -N1 -p "Press a key: "
и пока кнопка не нажата этот read будет 
ждат бесконечно  и экран не будет стираться через clear 
поэтому. тоесть clear срабатывает только после 
того как нажата кнопка. 
как только кнопка нажата то цикл идет на новый цикл


>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<
$ cat 13.bash 
#!/bin/bash


key="кнопка не нажата"

while true; do
  clear
  echo "Bash Extra Keys Demo. Keys to try:"
  echo
  echo "* Insert, Delete, Home, End, Page_Up and Page_Down"
  echo "* The four arrow keys"
  echo "* Tab, enter, escape, and space key"
  echo "* The letter and number keys, etc."
  echo
  echo "    d = show date/time"
  echo "    q = quit"
  echo "================================"
  echo





 case "$key" in
  $'\x1b\x5b\x32\x7e')  # Insert
   echo You pressed: \'Insert Key\'
  ;;
  $'\x1b\x5b\x33\x7e')  # Delete
   echo You pressed: \'Delete Key\'

  ;;
  $'\x1b\x5b\x48')  # Home_key_num_7
   echo You pressed: \'Home Key\'

  ;;
  $'\x1b\x5b\x46')  # End_key_num_1
   echo You pressed: \'End Key\'

  ;;
  $'\x1b\x5b\x35\x7e')  # Page_Up
   echo You pressed: \'Page_Up Key\'

  ;;
  $'\x1b\x5b\x36\x7e')  # Page_Down
   echo You pressed: \'Page_Down Key\'

  ;;
  $'\x1b\x5b\x41')  # Up_arrow
   echo You pressed: \'Up Key\'

  ;;
  $'\x1b\x5b\x42')  # Down_arrow
   echo You pressed: \'Down Key\'

  ;;
  $'\x1b\x5b\x43')  # Right_arrow
   echo You pressed: \'Right Key\'

  ;;
  $'\x1b\x5b\x44')  # Left_arrow
   echo You pressed: \'Left Key\'

  ;;
  $'\x09')  # Tab
   echo You pressed: \'Tab Key\'

  ;;
  $'\x0a')  # Enter
   echo You pressed: \'Enter Key\'

  ;;
  $'\x1b')  # Escape
   echo You pressed: \'Escape Key\'

  ;;
  $'\x20')  # Space
   echo You pressed: \'Space Key\'

  ;;
  d)
   date

  ;;
  q)
  echo Time to quit...
  echo
  exit 0

  ;;
  *)
   echo You pressed: \'"$key"\'

  ;;
 esac

 echo
 echo "================================"

 unset K1 K2 K3
 read -s -N1 -p "Press a key: "
 K1="$REPLY"
 read -s -N2 -t 0.001
 K2="$REPLY"
 read -s -N1 -t 0.001
 K3="$REPLY"
 key="$K1$K2$K3"

done

exit $?

>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<


запуск скрипта
    $ ./13.bash

Bash Extra Keys Demo. Keys to try:

* Insert, Delete, Home, End, Page_Up and Page_Down
* The four arrow keys
* Tab, enter, escape, and space key
* The letter and number keys, etc.

    d = show date/time
    q = quit
================================

You pressed: 'Escape Key'

================================
Press a key: 




| echo
| \

далее еще раз коснусь темы
в этом примере работает такая логика.
если слэш под двойными кавычками и за ним стоит обычный символ
то баш печатает слэщ
    $ echo "\a"
    \a

если под двойными кавычками за слэшем стоит спец символ ( а слэш внутри двойных кавычек это есть спецсимвол)
то слэш не печатается а спецсимвол теряет свою спецсимвольность и печатеся как простой символ
поэтому один слэш исчезает а второй печатается
    $ echo "\\a"
    \a

еще момент. 

    $ a="\\"
    $ echo "$a"
    \

    
далее
я теперь малек понял почему если мы в командной строке баща ввоим команду потом вводим \ 
потом тыкаем Enter и у нас ввод команды продолжается. потому что слэш экранировал последующее нажатие Enter.

| |
| pipe

если мы в командной строке стоит пайп "|" и жмем Enter
то слэш вводить ненадо. автоматом баш ждет от нас продолжения ввода.

    $ echo "1" | 
    > 
    
| exit code

код возврата из дочернего процесса поступает в родительский процесс.

если в скрипте  в явном виде в конце не указана команда exit $код_возврата
либо указана команда exit но без кода возврата 
то код возврата берется из статуса выполнения последней команды в скрипте

и еще в одном случае 
 exit $?
в этом случае тоже код возврата будет браться из кода из предыдудщей команды
потому что понятно почму. потому что $? это всегда код возврата предыдудущей
отработавшей команды

код возврата может быть в диапазоне 0-255

| !
если мы перед командой поставим "!" 
то код возврата $? будет инвертирован.
нахрен это надо незнаю.

    $ echo "1" 1>/dev/null; echo $?
    0
    $ ! echo "1" 1>/dev/null; echo $?
    1


| test constructs

конструкции которые могут проверять условия чего нибудь

1) if then

2) [ (левая скобка /usr/bin/[) 
у баша есть одноименный билтин
также есть аналогичная внешняя команда /usr/bin/test 
при этом это аналог а не хардлинк\симлинк не [

3) [[...]]]
это типа более продвинутая версия [..]

4) ((...)) , let 
вроде как это одно и тоже

насколько я понял из книжки if then это не команда баша это его keyword.
keyword это составная часть команды.
[[...]] книжка тоже утвржлает что это тоже keyword
так я не могу понять как if then или [[...]] могут быть кейвордами
если они могут самостоятельно применяться. это же команды получается!


примеры
    $ (( 1 + 2 )); echo $?
    0
    $ let "n=1+2"; echo $?
    0
    $ (( 0 + 0 )); echo $?
    1
    $ let "n=0+0"; echo $?
    1

отсюда книжка пишет что код возврата у ((...)) и let "..." один и тот же

кстати 
    $ i=0;
    $ (( i+=2 ))
    $ echo "$i"
    2

кстати 
внешняя команда cmp сравнивает два файла
    $ cmp file1 file2

далее if она принимает любую команду в качестве условия потому что 
if анализирует только код возврата
пример

    $ if { echo "123" | head -c 1 &>/dev/null; }; then echo "success"; else echo "fail"; fi
    success
тоесть как видно мы в качестве условия вставили портянку { echo "123" | head -c 1 &>/dev/null; }
ифу все равно какая длинна портянки. if смотрит только код возврата. если $?=0 то выполняется then
а если $?=1 то выполняется else. вот и все

еще пример
    $ if { grep -q "bash" 03.bash; }; then echo "success"; else echo "fail"; fi
    success

еще пример
    $ if { echo "123" | grep -q "2";  }; then echo "цифра 2 найдена"; else echo " цифра 2 ненайдена"; fi
    цифра 2 найдена


кстати
    $ [ 0 ]; echo $?
    0
    $ [ 100 ]; echo $?
    0
    $ [ 1 ]; echo $?
    0
    $ [ -1 ]; echo $?
    0
    $ [  ]; echo $?
    1

из чего видно что [ число ] скобка подходит только если мы хотим 
протетисровать что число под скобкой НЕ NULL
    
тоже самое со стрингами
    $ [ "abc" ]; echo $?
    0
    $ [ "123" ]; echo $?
    0   
    $ [ "$drt" ]; echo $?
    1
только если стринг NULL  мы получаем false

можно это все проверять в более явной мере
    $ [ -z "$abc" ]  #  true если длина стринга 0
    $ [ -n "$abc" ]  #  true если длина стринга неноль


вот такая форма if then это хуйня
потому что в ней в качестве команду указана команда [
фишка  в том как  я уже сказал что в if может стоять любой клубок команд
ифу похуй на это. он анализирует лишь код возврата $? от этого клубка команд
    if [ condition-true ]
    then
        command 1
        command 2
        ...
    else  # Or else ...
      # Adds default code block executing if original condition tests false.
        command 3
        command 4
        ...
fi


более верная форма 
    if { command1; command2; command2}
    then
        ...
    else
        ...
    fi

кстати помимов else есть еще elif
пример
    $ if [ 1 -gt 2 ]; then echo "1>2"; elif [ 3 -gt 4 ]; then echo "3>4"; else echo "все не так"; fi
    все не так

в книжке написано что /usr/bin/[ вызывает по факту /usr/bin/test

по поводу [[...]] книжка пишет => No filename expansion or word splitting takes place between [[ and ]], 
but there is parameter expansion and command substitution.
Using the [[ ... ]] test construct, rather than [ ... ] can prevent many logic errors in scripts.
For example, the &&, ||, <, and > operators work within a [[ ]] test, despite giving an error within a [ ] construct

тоесть как я понял предпочитительнее использовать [[...]] а не [...]

кстати что интетесно в команде echo ( man echo ) напиано что можно в аргумент прописать сразу байт а не символ.
только дискриминация в том что байт можно прописать либо в OCT виде либо в HEX виде. а в десятичном нельзя.
почему непонятно. пример
    # ascii 141oct 97dec 61dec
    $ echo $'\141'
    a
    $ echo $'\x61'
    a
а 97dec никак не прописать в качестве аргумента


кстати нашел в man bash
 Quoting  is used to remove the special meaning of certain characters or words to the shell.  Quoting can be used to disable special treatment for special charac‐
       ters, to prevent reserved words from being recognized as such, and to prevent parameter expansion.

       Each of the metacharacters listed above under DEFINITIONS has special meaning to the shell and must be quoted if it is to represent itself.

       When the command history expansion facilities are being used (see HISTORY EXPANSION below), the history expansion character, usually !, must be quoted to prevent
       history expansion.

       There are three quoting mechanisms: the escape character, single quotes, and double quotes.

       A  non-quoted  backslash  (\) is the escape character.  It preserves the literal value of the next character that follows, with the exception of <newline>.  If a
       \<newline> pair appears, and the backslash is not itself quoted, the \<newline> is treated as a line continuation (that is, it is removed from the  input  stream
       and effectively ignored).

       Enclosing  characters in single quotes preserves the literal value of each character within the quotes.  A single quote may not occur between single quotes, even
       when preceded by a backslash.

       Enclosing characters in double quotes preserves the literal value of all characters within the quotes, with the exception of $, `, \, and, when history expansion
       is enabled, !.  When the shell is in posix mode, the ! has no special meaning within double quotes, even when history expansion is enabled.  The characters $ and
       ` retain their special meaning within double quotes.  The backslash retains its special meaning only when followed by one of the following characters: $,  `,  ",
       \,  or <newline>.  A double quote may be quoted within double quotes by preceding it with a backslash.  If enabled, history expansion will be performed unless an
       !  appearing in double quotes is escaped using a backslash.  The backslash preceding the !  is not removed.

       The special parameters * and @ have special meaning when in double quotes (see PARAMETERS below).

    
там же нашел
 A  double-quoted string preceded by a dollar sign ($"string") will cause the string to be translated according to the current locale.  If the current locale is C
or POSIX, the dollar sign is ignored.  If the string is translated and replaced, the replacement is double-quoted
пример
    $ a="1"
    $ echo $"a"
    a
что лишний раз подтверждает что надо весь стринг всегда заклюать в кавычки либо будешь 
получать непредсткадуемый результат
скажем в этом примере все понятно
    $ echo "$"a""
    $a
мы имеем три аргумента
    "$"
    a
    ""
поэтому в итоге будет напечатан $+a+пусто = $a
что мы и видим

кстати еще раз хочу вернуться к $'...'
 Words of the form $'string' are treated specially.  The word expands to string, with backslash-escaped characters replaced as specified by the ANSI  C  standard.
       Backslash escape sequences, if present, are decoded as follows:
              \a     alert (bell)
              \b     backspace
              \e
              \E     an escape character
              \f     form feed
              \n     new line
              \r     carriage return
              \t     horizontal tab
              \v     vertical tab
              \\     backslash
              \'     single quote
              \"     double quote
              \?     question mark
              \nnn   the eight-bit character whose value is the octal value nnn (one to three digits)
              \xHH   the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
              \uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
              \UHHHHHHHH
                     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)
              \cx    a control-x character

       The expanded result is single-quoted, as if the dollar sign had not been present.

особенно меня прикололо  "\cx    a control-x character" это чтото новенькое
я проверил. внатуре так и работает

Ctrl+R:
    $ read -s -N1 a; read -s -N2 -t 0.001 b; read -s -N1 -t 0.001 c;  printf "$a$b$c" | od -t x1 | head -n1 | cut -c 8-
    12
    $ echo -n $'\cr'| od -t x1
    0000000 12

ладно так вот $'..'
в итоге эта хрень работает так - знак $ отбрасывается. оставляются '' а то что внутри транслируется в 
соотвствие с приведенной таблицей учитывая спецсимволы.

так вот я перехожу  к главному меня интересующему вопросу - какой формат в баше
чтобы задать данные не в виде печатных симоволов которые баш потом по факту конвертирует
в байты а чтобы сразу указать в форме байтов. например в hex формате.
и тут получается тонкий момент. во первых в баше нельзя в общем то задать стринг 
сам по себе. он обычно входит в состав команды. а команда транслирует стринг в своем
индивидуальном порядке. а нам надо чтобы без трансляции. чтоб как есть. переменную
же задать можно. безотносительно команды которая будет ее обрабатывать. с переменной проще в этом плане.
но еще отсается задача как потом посмотреть содержимое переменной так чтобы команда 
не транслировала ее контент во чтото другое.
в итоге я пришел вот к чему
вот как я смотрю истинное содержимое голого стринга в байтовом виде
    $ od -t x1 <<< "a"
    0000000 61 0a
единственное что это добавялет лишний 0a на конце. поэтому его надо мысленно отбросить
итак видно что стриг "a" по факту в байтовом виде это 0x61  ( очевидно что этот байт ссоветсвет таблице ascii )
еще пример
    $ od -t x1 <<< "\x61"
    0000000 5c 78 36 31 0a
отбрасываем 0a и у нас остается 5c 78 36 31 это и есть байтовое содержимое нашего стринга,
смотрим в таблицу ascii и узнаем что 0x5с="\"  0x78="x"  0x36="6" 0x31="1"
итак совершенно очевидно что стринг  в формате "\x61" непредставляет собой ничего кроме прямого набора литер которые
его составляют
еще один пример
    $ od -t x1 <<< "0x61"
    0000000 30 78 36 31 0a
тут тоже видно что байтовое содержимое стринга это просто набор литер входящих в его состав
теперь применяем вот такое
    $ od -t x1 <<< $'\x61'
    0000000 61 0a
и тут мы видим принициапильно дуругую ситуацию. байтовое содержимое стринга это не набор литер а это ровно такое же байтовое 
содержание как указано в теле стринга. 

таким образом я постулирую что если мы хотим задать в стринге под двойными кавычками "...." стринг прям в форме байта 
то это нихрена не сделать. стринг можно задать в форме байта только через $'\xNN'

тоже самое касается задать переменную ( а все переменные у баща это стринги только имеющие имя ) то если мы хотим
задать переменную в форме байта то это можно сделать только одним способом 
    a=$'\xNN'
через 
    a="..." это никак не сделать.
пример
    $ a=$'\x31'
    $ od -t x1 <<< "$a"
    0000000 31 0a
видно что я записал в теле 31 и получил 31 уже в форме байтового потока
а вот показано то что байтовый поток переменной отличается от ее формального описания
    $ a="1"
    $ od -t x1 <<< "$a"
    0000000 31 0a


далее еще тонкий момент. вот мы разобрались как нам в перменую или в стринг засунуть нужный нам байтовый поток.
но когда команда получает через аргумент стринг или переенную то она по своему может обрабатывать этот байтовый поток.
но тут я думаю вот что. баш прежде чем запустить команду считывает переменную из памяти  в форме байтового потока
и подставляет этот байтовый поток из памяти в  аргумент. тоесть программа к переменнной доступа не имеет. перед 
тем как зпустить команду баш считывает переменную и посдтавляет ее в байтовом виде в команду и потом толко вызыает команду
примеир
    $ a=$'\x31'
    $ strace -e execve printf "$a\n"
    execve("/usr/bin/printf", ["printf", "1\\n"], 0x7ffe76b5c318 /* 70 vars */) = 0

тоесть баш запомнил где то в своих кишках 0x31
перед запуском printf баш сам считывает 0x31 и подставляет этот байт в сисколл execve в качестве аргумента
таким образом если бащ засунул в переменную какойто байт поток то он при вызове команды 
считает этот же байт поток и подсунет этот же байт поток как аргумент в команду

возможен конечно другой вариант. когда мы суем некотоыйр байт поток в команду а она уже сама
на основе своего интеллекта преобразует его в другое значение
    $ strace -e execve printf "\x31"
    execve("/usr/bin/printf", ["printf", "\\x31"], ...
    1
или 
    $ a="\x31"
    $ strace -e execve printf "$a"
    execve("/usr/bin/printf", ["printf", "\\x31"] ...
    1
что я хотел этими двумя примерами показать что в printf улетел стринг "\x31" тоесть байтовый поток  5c 78 33 31    
    $ od -t x1 <<< "$a"
    0000000 5c 78 33 31 0a
но сама команда printf такая умная что она его преобразовала в "1" тоесть в байт поток 0x31
тоесть вот это две соверенно разные ситауации в плане байт потока аргумента в printf 
хотя резулттат один и тот же

    $ strace -e execve printf "\x31"
    execve("/usr/bin/printf", ["printf", "\\x31"]
    1

    $ strace -e execve printf $'\x31'
    execve("/usr/bin/printf", ["printf", "1"]
    1

результат мы получили один и тот же. но баш подставил при вызовер printf совершенно разные байт потоки
в первом случае это "\x31" = 5c 78 33 31
во втором случае это $'\x31'= 31
это очень важно понять

теперь когда этот важный вопрос прояснился 
посмотрим вот на что.
возьмем команду [ либо test они же одинаково работают.
и посмотрим как они могут работать с входными форматами данных
я хочу сравнить стринги
    "10"
    "0x0A"
    "0x0a"
    $'\x0a'
совершенно понятно что байтовый поток у них совершенно разный
то входные аргументы совершенно не совпдаают. 
но возможно сама программа [ умеет 
распознавать форматы
проверим

    $ [ "10" -eq "0x0A" ]; echo $?
    bash: [: 0x0A: integer expression expected
    2

    $ [ "10" -eq "0x0a" ]; echo $?
    bash: [: 0x0a: integer expression expected
    2

    $ [ "10" -eq $'\x0a' ]; echo $?
    bash: [: 
    : integer expression expected
    2

как видим [ совершенно неумеет сама распознавать форматы.
она работает с числами которые должны быть выражены буквально в форме литер "1" "2"
проверим еще вот как  посмотрим какой байтвый поток у "10"
    $ od -t x1 <<< "10"
    0000000 31 30 0a
тогда
    $ [ "10" -eq $'\x31\x30' ]; echo $?
    0
ха. сработало.
    $ test "10" -eq $'\x31\x30'; echo $?
    0
но оно сработало не потому что программа [ какая то умная а потому то баш перед запуском команды
транслировал $'\x31\x30' в "10" в форме байт потока

    $ strace -e execve [ "10" -eq $'\x31\x30' ]; echo $?
    execve("/usr/bin/[", ["[", "10", "-eq", "10", "]"], 

тоесть с точки зрения [ в нее влетело абсолютно два одинаковых аргумента!

а теперь рассмотрим так называемый якобы keyword [[...]] может он более интеллектуальный 
и умеет распознавать форматы чисел в разных байт потоках. например может он понимает что "0x0A" это надо 
понимать как $'\x0a'

    $ [[ "10" -eq "0x0A" ]]; echo $?
    0

    $ [[ "10" -eq "0x0a" ]]; echo $?
    0

окей перепишу эти два примера по другому в равнозначной форме
я опишу левый аргумент в форме байт потока

    $ [[ $'\x31\x30' -eq "0x0A" ]]; echo $?
    0

    $ [[ $'\x31\x30' -eq "0x0a" ]]; echo $?
    0

    
совершенно понятно что справа у нас аргумент имеет совершенно другой байт поток
    $ od -t x1 <<< "0x0A"   
    0000000 30 78 30 41 0a
    $ od -t x1 <<< "0x0a"
    0000000 30 78 30 61 0a
    
отсюда следует что [[...]] умеет сама в себе  понимать и трансформировать "0x0A" который в виде байт
потока выглядит как 30 78 30 41 в совершенно другой байт поток $'\x31\x30'
тоже самое касается "0x0a". если же отойти от байт потоков и перейти к литерам то я говорю о том что сама программа
внутри себя умеет трансформировать литеры "0x0A" в литеры "10"
для сравнения программа [...] этого делать не умеет. 
еще пример
здесь понятно. оба аргумента имеют одинаковый байт поток. 
илидругими словами одинаковый литерный вид
    $ [[ "10" -eq $'\x31\x30' ]]; echo $?
    0


еще пример
понятно почему неработает 
потому что разный байт поток, тоже самое у нас разный литерный поток
а сама программа не умеет внутри себя трансформировать $'\x0a' в "10"
    $ [[ "10" -eq $'\x0a' ]]; echo $?
    1
    
    
таким макаром [[..]] умеет понимать hex формат в литерном виде если он записан как "0xNN" либо "0xnn"
для сравнения [..] этого не умеет
таким образом мы можем в [[...]] задать аргумент 
либо    в виде 
    литер '10' 
либо в виде 
    байтового потока этих литер $'\x31\x30'
либо в виде литер. преобразовав число 10 в вид
    '0x0A'
    '0x0a'
    
таким образом можно заменить исходные литеры на другие литеры по некоторому закону и програмаа [[...]]
это поймет. но поймет только эта программа потому что она индивидуально под это заточено. 
как там у других программ надо смотреть индивидуально.
пиздец
возьмем для примера другую программу printf
здесь все понятно просто печатаем литеры "10"
    $ printf "10 \n"
    10 
или печатаем их в форме байтового потока
    $ printf $'\x31\x30\x0a'
    10
тут все понятно в принтф прилетает один и тот же аргумент. 
преобрзаованием занимтся сам баш. а принтф вобще ни при чем
доказываю
    $ strace -e execve printf "10 \n"
    execve("/usr/bin/printf", ["printf", "10 \\n"]
    10 

    $ strace -e execve printf $'\x31\x30\x0a'
    execve("/usr/bin/printf", ["printf", "10\n"]
    10

сточки зрения принтф в него были подставлены абсолбтно одни и теже аргументы.
это заслуга самого бащ.
далее как видно вот такой формат принтф уже не понимает
    $ printf "0x310x30 \n"
    0x310x30 

зато принтф понимает вот такой формат и это заслуга именно
самого принта а не баша
    $ printf "\x31\x30 \n"
    10 

    $ strace -e execve printf "\x31\x30 \n"
    execve("/usr/bin/printf", ["printf", "\\x31\\x30 \\n"]
    10 

еще вот такая хрень в которой в принтф влетают литеры "\x31" \x30"
а уже именно он сам их преобразует в литеры "1" "0"
это заслуга не баша а самого принтф
    $ printf "%b%b \n" "\x31" "\x30"
    10 

    $ strace -e execve printf "%b%b \n" "\x31" "\x30"
    execve("/usr/bin/printf", ["printf", "%b%b \\n", "\\x31", "\\x30"]
    10 

а вот еще пример где в принтф влетают литеры "10"
он именно он их преобразует в другие литеры
    $ printf "%x \n" "10"
    a 
тоесть берутся литеры "10". они внутри преобразуются в число 10
это число считается что записано в десятичном формате
оно преобразуется в hex число a и это число преобразуется в литеру "a"
и это все заслуга принтф.
    "10" -> 10 -> a -> "a"

а вот еще пример интересный
    $ printf "%x \n" "0xa"
    a 
на входе в принтф  у нас литеры "0xa" он преобразует их в число a в формате hex
а потом это число преобразует в литеру "a"
    "0xa" -> a -> "a"
и это все заслуга исключтельно принтф

таким образом вот так все сложно с форматами литер\байтов в самом баше в его
стрингах и переменных и во внешних по отношению к башу командах и в кейвордах
баша.

чтобы в этм ориентироваться надо все это четко понимать - какие форматы понимает баш.
разница между литерами и байт потоком, числами, в каком байт виде перменная или стринг
есть в баше и как она подставляется в команду или кейворд и какие форматы понимает 
для автоматического преорбразвания этот кейворд или команда

опять же надо понимать что есть реальные числа котрые хранятся в формет байтов
а есть литеры которые имеют совершенно другое байтовое представление. 
надо понимать с чем рабтает программа с числами в формет байтов
или с числами в форме литер

вот так все сложно.

теперь когда мы это все знаем мы можем предстазывать резултат работы прогармм
например программа [
она анализирует числа-литеры. тоесть мы скажем ей суем литеру "1" она ее внутри себя преобразует
уже в число 1(десятичное). и с ним работает. таким образом если мы хотим сравнить число 1 и число 2 то 
их нужно подсунуть этой прграмме в форме литер "1" и "2"
    $ [ "1" -lt "2" ]; echo "$?"
    0
программа работает так. берет литеру "1" и внутри себя преобразует в число 1
потом берет литеру "2" преобразует ее в число 2 и потом сравнивает 
    1 < 2 ?
ответ да. тоесть true .
поэтому код возврата 0

следущий пример
    { decimal=15; octal=017; hex=0x0f; [ "$decimal" -eq "$octal" ]; echo $?; }
    1
у нас по факту это раотает так 
    [ "15" -eq "017" ]
у нас литеры "15" преобразуюься в число 15  и литеры "017" преобразуются вчисло 17
  15 неравно 17 
поэтому на выходе код возрата 1

следущий пример
    $ { decimal=15;  hex=0x0f; [ "$decimal" -eq "$hex" ]; echo $?; }
    bash: [: 0x0f: integer expression expected
    2
тут теперь тоже все понятно. у нас это раоатет так
    [ "15" -eq "0x0f" ]
литеры "15" программа преобразует в десятичное число 15
литеры "0x0f" программа ни в какое число не преобразует. потому что она не понимает что 
это ей за хрень подсунули. она ожидает увидеть среди литер только литеры из словаря "0 1 2 3 4 5 6 7 8 9:
поэтмоу она нас шлет нахер.

рассмомирим следущюу программу [[..]]
пример
    $ { decimal=15; octal=017;  [[ "$decimal" -eq "$octal" ]]; echo $?; }
    0
эта программа более умная чем предудыдущая. она раотает так
подставляются переменные
    [[ "15" -eq "017" ]]
далее программа преобразует литеры "15" в десятичное число 15
и преобразует литеры "017" в OCT число 017
и далее программа сранивает 15 dec и 017 OCT . ( по факту я думаю прогармма в конечно итоге оба числа
преобрзаует в двоичный вид).
видит что это два одинаковых числа поэтмоу возварщает $?=0
таким образом это заслуга самой программы что она умеет в литерном виде понимать нетолько десятичный формат
но и восьемеричный.

еще пример
    $ { decimal=15;  hex=0x0f; [[ "$decimal" -eq "$hex" ]]; echo $?; }
    0
суть такая же как в прошлом примере.
изюминка лишь в том что программа [[...]] умеет преобразоывать литерный вид "0x0f" в число 
в hex формате 0x0f поэтому она не выдвает ошибку а сравнивает 15 dec и 0x0f видит что 
это одно и тоже число и выдает $?=0
офигеть...

из этого я делаю в частосноти вывод что лучше всегда использовать [[...]] вместо [..] потому что она 
более интеллектуальная.

насколько я понял разница между [[...]] и ((...)) в том что 
((...)) вычисялет арифеметичесие операции 
а 
[[...]] делает сравнения в виде больше, меньше, равно

тоесть это несколько разные виды операций. 
и код вовзрата формируется также у них по разному. внутри [[...]] формируется булевый результат true или fasle
в зависимосоти от этого в $? идет 0 или 1
у ((..))) внутри формируется число. если оно равно 0 то в $? летит 1 а если оно неравно -0 
то  в $? летит 0

охренеть

    $ (( 0 )); echo $?
    1
    $ (( 1 )); echo $?
    0
    $ (( 5>4 )); echo $?
    0
    $ (( 5>9 )); echo $?
    1

ксати видно что ((..)) тоже может делать операции сравнению больше меньше как и [[...]]
только для этого прмиенятся другие символы.
еще пример для сраврнеия

    $ [[ "5" -gt "4" ]]; echo $?
    0
    $  (( 5>4 )); echo $?
    0
как видно код вовзрата одинаковый кстати
получается что (( 5>4 )) приводит к (( 1 )) что в свою очередь приводит к $?=0
получается (( 0 )) это свое рода (( False )) поэтому $?=1
а (( 1 )) или  (( 100 )) это своего рода (( True )) поэтому $?=0

еще примеры
внутри получаем True  поэтому $?=0
    $ (( 5==5 ));echo $?
    0
внутри получаем  0 это аналог false значит $?=1
    $ (( 5-5 ));echo $?
    1   
целое  от деления  1 это аналог True згначит $?=0
    $ (( 5/4 ));echo $?
    0
целое от деления это 0 это аналог false значит $?=1
    $ (( 5/10 ));echo $?
    1
пздец


кстати 
    /proc/self/fd смотрит в ---> /dev/fd/
удобно


| проверка файлов

есть такая подьебка с самого начала.
есть множество флагов проверяющих существование файла или его тип
например

проверить что файл существует
    $ [ -e "./03.bash" ]; echo "$?"
    0

проверить что файел есть и его тип обычный
    $ [[ -f "./03.bash" ]]; echo "$?"
    0

и здесь вот надо особо указать на то что флаг -f
он проверяет две вещи сразу 1) существует ли файл вообще и 2) что тип файла обычный 
поэтому команда будет возвращать false если хотя бы одно условие не выполняется. 
тоесть если команда вернула $?=1 это значит что либо тип файла необычный либо 
файла вообще нет. поэтому, если мы хотим точно узнать то ли файла вобще нет. то ли он 
есть но у него нетот тип тогда надо делать две проверки.
    $ if [[ -e "./03.bash" ]]
      then
         if [[ -f "./03.bash" ]]
         then
            echo "тип файлы обычный"
         else
            echo "тип файл необычный"
        fi
      else
        echo "файл несуществует"
      fi

а вот проверка тогоже самого в одну строчку
    $ [[ -e "./03.bash" ]] &&  { [[ -f "./03.bash" ]] && echo "файл обычный" || echo "файл необычный"; }   || echo "файл несуществует"

примеры
    $ stat "./03.bash" | head -n2
        File: ./03.bash
        Size: 151       	Blocks: 8          IO Block: 4096   regular file

    $ file="./03.bash"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл обычный

    $ stat "./123.bash" | head -n2
    stat: cannot stat './123.bash': No such file or directory

    $ file="./123.bash"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл несуществует

    $ stat "/dev/zfs" | head -n2
        File: /dev/zfs
        Size: 0         	Blocks: 0          IO Block: 4096   character special file

    $ file="/dev/zfs"; [[ -e "$file" ]] &&  { [[ -f "$file" ]] && echo "файл обычный" || echo "файл необычный"; }  || echo "файл несуществует"
    файл необычный

таким образом скрипт работает на 100%

далее
проверить что файл существует и размер файла не нулевой
    $ [[ -s "./03.bash" ]]; echo "$?"
    0
    
    $ [[ -s "/proc/self/fd/0" ]]; echo "$?"
    1

проверка что файл существует и это папка
    $ [[ -d "/" ]]; echo "$?"
    0

проверка что файл существует и  файл это блочное устройство
    $ [[ -b "/dev/loop0" ]]; echo "$?"
    0
    
провекра что файл существует и  файл это character устройство
    $ [[ -c "/dev/zfs" ]]; echo "$?"
    0

далее поговорим про файл типа пайп.
для начала создадим именованный пайп
    $ mkfifo /tmp/1.pipe
посмотрим как выглядит его описание

    $ ls -1al /tmp/1.pipe
    prw-rw-r-- 1 vasya vasya 0 дек 10 20:02 /tmp/1.pipe

тоесть у него буква "p" вначале (prw-rw-r--)

    $ stat  /tmp/1.pipe
        Size: 0         	Blocks: 0          IO Block: 4096   fifo


проверим что файл существует и его тип это пайп (FIFO)
    $ [[ -p "/tmp/1.pipe" ]]; echo "$?"
    0

а теперь создадим два процесса связаных пайпом
и посмотрим как там у них выглядят файлы дескрипторы

    $ sleep 120 | sleep 130
    $ ps aux | grep sleep
    vasya    22746  ... sleep 120
    vasya    22747  ... sleep 130

    $ ls -1al /proc/22746/fd/1
    l-wx------ 1  ...  /proc/22746/fd/1 -> 'pipe:[3692096]'
    $ ls -1al /proc/22747/fd/0
    lr-x------ 1  ...  /proc/22747/fd/0 -> 'pipe:[3692096]'

и соотвесвтенно тут важно заметить что файлы 0 и 1 они не имеют тип пайп. нихуя.
они симлинки. указыывающие хрен знает на что.
таким образом если мы будем проверять 0 и 1 на то что они пайп то получим пошел нахер.
они только успешно проверяться на то что они симлинки

проверка на то что файл симлинк идет через два флага -h -L
чем они отличаются хуй знает

    $ [[ -h "/proc/22746/fd/0" ]]; echo "$?"
    0

    $ [[ -L "/proc/22746/fd/0" ]]; echo "$?"
    0

    $ [[ -p "/proc/22746/fd/0" ]]; echo "$?"
    1
    

тоесть я хочу сказать что кога мы создаем два процесса соединеных пайпом то интуиция 
говорит что ихние файлы отвечающие за STDOUT и STDIN должны быть типа пайп. 
но нихуя. это будут симлинки. указывающие на типа пайп. который не пайп а некая ядерная структура.

таким образом я бы сказал что проверка через флаг -p 
она позволяет является ли файл не просто пайпом а является ли он ИМЕНОВАННЫМ ПАЙПОМ.
вот что важно понять.

кстати  с именованным пайпом тоже хуйня интересная. если мы запустим команды
    $ echo "123" > /tmp/1.pipe; cat < /tmp/1.pipe;
то вторая команда не будет выполнена никогда. 
потому что первая команда сунула 123 в пайп и ждет как я понимаю ответа 
от ос о том что данные были забраны. а они не забраны потому что программа cat 
начнет выполняться только после того как закончит работы программа echo
поэтому единственый вариант это использовать два терминала. 
на первом термианале мы пишем
    $ echo "123" > /tmp/1.pipe; 
и эта команда после ввода будет висеть
потом заходим на второй терминал и там пишем
    cat < /tmp/1.pipe;
и вот только тогда все сработает.
пиздец

я себе представлял это некольпо по другому. что при записии в /tmp/1.pipe
данные записываются в ядро в буфер некоторого размера и поэтому наличие второго процесса
считываютщего необязательно. а хуйтам.

далее. сокет файл.
найдем сокет файл

    $ stat $(find "/tmp" -type s 2>/dev/null | head -n1) | grep -E "File|Size|Uid"
        File: /tmp/ssh-Ffb3Jn4D9wqx/agent.4932
        Size: 0         	Blocks: 0          IO Block: 4096   socket
        Access: (0600/srw-------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    
значит файл найден. видно что его тип это socket.
и видно что в описании файла буковка "s" (0600/srw-------)

еще раз убедимся в наличии буквы "s" в описании файла
    $ ls -1al /tmp/ssh-Ffb3Jn4D9wqx/agent.4932
    srw------- 1  ....  /tmp/ssh-Ffb3Jn4D9wqx/agent.4932

    
проверим что файл действиельно есть и что у него тип "сокет"
        $ [[ -S "/tmp/ssh-Ffb3Jn4D9wqx/agent.4932" ]]; echo $?
        0


следующий флаг -t очень интересный
    -t   file (descriptor) is associated with a terminal device
хуета в том что аргумент сюда ставится не путь к файлу. нет нихуя.
аргумент здесь это номер файл дескриптора процесса в котором сейчас работает
скрипт. это то как я понял из эксперимента. потому что описание этого флага
мегауебищное. поэтому эта хрень ее примененеие может выгляеть только так
    $ [[ -t 0 ]]
    $ [[ -t 1 ]]
    $ [[ -t 2 ]]
    
так вот я как понял эта хрень проверяет то что если дескриптор  ( а дескриптор это
 всегда симлинк ) как симлинк указывает на спец файл (/dev/...) который обрабатывается
 драйвером терминала. пример такого файла
 причем подходит нетолько tty драйвер но и pts драйвер
    $ ls -1al /proc/self/fd/0
    ... /proc/self/fd/0 -> /dev/pts/21

в общем этот странный флаг на практкие может быть использован чтобы
типа скрипт мог опрееделить что какойто его дескриптор обслуживатеся 
драйвером терминала.

далее проверить есть ли файл и может ли наш процесс читать этот файл. есть ли пермишнс

    $ [[ -r "./private-dhcp" ]]; echo "$?"
    0
    $ [[ -r "/etc/shadow" ]]; echo "$?"
    1


проверка что файл есть и у процесса есть право записывать в файл у этого проццеса

    $ [[ -w "/etc/shadow" ]]; echo "$?"
    1

прверка есть ли файл и есть ли у нашего текущего юзера права на execution для этого файла

    $ [[ -x "/etc/shadow" ]]; echo "$?"
    1

    $ [[ -x "./03.bash" ]]; echo "$?"
    0   

    
    
| find 

на время отвлечемся  на  find ( а позже обратно вернемся к преддыдудщей теме)
итак
программа ищет в /etc файла "*host*" и печатает имя файла на экране (что круто кстати)
    $ find /etc -name "*host*" -type f -print 2>/dev/null
    /etc/ansible/hosts
    /etc/avahi/hosts
    /etc/hosts


вот это пример интересный
    $find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

Find files named core in or below the directory /tmp and delete them, 
processing filenames in such a way that file or directory names containing single or 
double  quotes, spaces or newlines are correctly handled.  
The -name test comes before the -type test in order to avoid having to call stat(2) on every file.

тут я покажу то что можно создавать файлы в имени которых есть диковинные символы. 
тоесть в имени файла насколько я щас помню можно использовать любые байты 
за исключением по моему байта 0x00 а все остальное можно. поэтому
в имени байта наример можноисользовать байт 0x0a который отвечает за Enter
ну и вообще лббые символы UTF-8.
показываю

    $ : > "$( printf "12\x0a1")"
    $ ls
    '12'$'\n''1'

тоесть у нас имя файла это "12" + символ Enter + "1"

ну и вот еще пример. когда мы вставляем символ UTF-8  "∑"

    $ : > "$( printf "12\x0a\xe2\x88\x91")"
    $ ls -1
    '12'$'\n''∑'
    '12'$'\n''1'

тоесть второй файл это "12" + Enter + "∑"
    
из за того что у нас в имени файла теперь есть символ "Enter" это приводит к проблеме.
вот какой. вот мы щас начнем искать эти файлы. и передаем этот список в команду xargs
а она же должна понять как ей отделить "слова" друг между другом. для этого она 
использует переменную $IFS в которой указано какие символы являются признаком 
разделителя между словами. по дефолту это символ "пробел", символ "Enter" и 
символ табуляции вертикальной "\t"
    $ od -t x1 <<< "$IFS"
    0000000 20 09 0a 0a

поэтому когда в xargs прилетит поток с именами нащих файлов в которых знак "enter" присуствует 
внтри имени файла то xargs будет считать что это знак разделения между словами. и мы получим 
скажем вместо имени файла '12'$'\n''∑' мы получим типа два отдельных слова '12' и '∑'
и это приведет нас к ошибкам. у нас же нет таких файлов. показываю

    $ ls -1
    '12'$'\n''∑'
    '12'$'\n''1'


    $ find . | xargs -I% echo "аргумент = %"
    аргумент = .
    аргумент = ./12
    аргумент = ∑
    аргумент = ./12
    аргумент = 1

поэтому это проблема
вот к чему это ведет    
    $ find . | xargs stat
    File: .
    Size: 4096      	Blocks: 8          IO Block: 4096   directory
    Device: 10302h/66306d	Inode: 15073820    Links: 2
    Access: (0775/drwxrwxr-x)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    Access: 2023-12-10 23:37:31.572393014 +0600
    Modify: 2023-12-10 23:37:28.716395145 +0600
    Change: 2023-12-10 23:37:28.716395145 +0600
    Birth: -

    stat: cannot stat './12': No such file or directory
    stat: cannot stat '∑': No such file or directory
    stat: cannot stat './12': No such file or directory
    stat: cannot stat '1': No such file or directory

но это можно преодолеть. можно указать команде find чтобы она когда формирует выходной список файлов 
чтобы она между именами файлов ставила не Enter как по дефолту а нулевой байт 0x00
это опция -print0

    $ find . -print0

и далее надо обьяснить xargs чтобы он тоже для определения как ему различать "слова" использовал
не то что указано в $IFS а байт 0x00 это опция -0

    $ find . -print0 | xargs -0 -I% echo -e "аргумент =%\n"
    аргумент =.
    
    аргумент =./12
    ∑

    аргумент =./12
    1

соовесвтенно теперь имена файлов различает xargs коректно. ну а то что ∑ стоит на следущей строке то это же понятно
как еще в терминале отображать сивмол 0x0a Enter

вот проверка что теперь все верно работает
    $ find . -print0 | xargs -0  stat
  File: .
  Size: 4096      	Blocks: 8          IO Block: 4096   directory

  File: ./12
∑
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file

  File: ./12
1
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file


теперь поймем какой формат аргументов у find

    $ find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]

тут много всякой хрени но нас оно интересует с момента  [starting-point...] [expression]

[starting-point...] это папка с которой начинать искать и тут все понятно

[expression] = вот это самое интересное. дело в том что эта хрень сама состоит из нескольких частей
а именно 
     [expression] = Tests + Actions + Global options + Positional options + Operators

для примера берем папку
    $ ls -1al
    total 8
    drwxrwxr-x 2 vasya vasya 4096 дек 11 00:21 .
    drwxrwxr-x 7 vasya vasya 4096 дек 10 23:57 ..
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 1.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 2.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 10 23:57 3.txt
    prw-rw-r-- 1 vasya vasya    0 дек 11 00:21 4.pipe

    
так вот если у нас аргументы идет просто через пробел то между ними как бы невидимо идет AND
то есть надо чтобы все аргументы выполнились
в данном случае я ищу файл с именем "1.txt" и чтобы тип файлы был обычный
    $ find .   -name "1.txt" -type "f"
    ./1.txt

полный аналог (-a это AND)
    $ find .   -name "1.txt" -a -type "f"
    ./1.txt

если мы хотим чтобы аргументы воспринимались как OR то 
в данном примере мы ищем файлы у которых либо имя "1.txt" либо тип файла обычный
    $ find .   -name "1.txt" -o -type "f"
    ./1.txt
    ./3.txt
    ./2.txt

также я как понял вместо "-o" можно использовать ","
    $ find .   -name "1.txt" , -type "f"
    ./1.txt
    ./3.txt
    ./2.txt

также как я понял условия можно группировать используя скобки. 
единственное что так как скобки это спецсимвол самого баша то надо обьяснить бащу чтобы он воспринял их как просто 
литеры и передал без изменений внешней команде в данном случае find
так вот пример когда скобки дают смысл

    $ find / \(  условие1 -a условие2 -a условие3 \) -o \(  условие4 -a условие5 -a условие6 \)  

смысл этой хрени такой найти в / файлы которые отвечают условиям: условие1+условие2+условие3    либо условие4+условие5+условие6
приведу конкретный пример
этот пример ищет либо файл с именем 1.txt и тип файла обычный либо файл с именем 4.pipe и тип файла pipe
также можно заметить что я экранировал скобки двумя способами это либо \( либо "("

    $ find .  \( -name "1.txt" -a -type "f"    \)  -o   "(" -name "4.pipe"  -a  -type "p"  ")"
    ./1.txt
    ./4.pipe

можно также сократить запись сделав ее более короткой но менее читаемой

    $ find .  \( -name "1.txt" -type f    \)  ,   "(" -name "4.pipe"    -type p  ")"
    ./1.txt
    ./4.pipe
    
теперь зная все это можно прокоментиоовать пример из самого man find
    
     $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -printf /root/big.txt '%-10s %p\n' \)

значит этот пример ищет файл который либо удовлетворяет требованиям
       
       -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n'
    
либо удовлетворяет требованияем

       -size +100M -printf /root/big.txt '%-10s %p\n'
       
тоесть либо файл имеет SUID бит установленный и тогда список этих файлов пишется в /root/suid.txt в формате %#m %u %p\n
либо файл по размеру больше 100МB и список этих файлов пишется в /root/big.txt в формате %-10s %p\n

тоесть этот исходный пример можно схематически вот таки изобразить

     $ find / \( услови1 AND  условие2  \) OR ( условие3 AND  условие4 \)

правда не совсем так потому что часть условий это actiiond дейтствия то есть что надо сделать с найденным файлом

     $ find / \( услови1 AND  действие1  \) OR ( условие3 AND  действие2 \)

кстати что еще парамлельно я узнал\вспомнил
как добавить SUID бит
    # chmod u+s file
что это дает. если владелец файла root а запускает на исполненеие файл простой юзер 
то фактически процесс будет запущен не от юзера а от владельца файла то есть рута.

также при смене владельца файла SUID бит автоматом сбрасывается

далее. интересный момент на счет аргумента "-perm -4000"
значит как задаются пермишнсы  файла который ищется
он задается в виде трех вариантов

    -perm маска    # в этом режиме нужно чтобы маска пермишнсов у файла точно совпала с маска у find
                   # сокращенно я бы этот режиме назвал exact match
    
    -perm -маска   # в этом режиме нужно чтобы установленные биты (равные 1)  из маски find были установлены в 
                   # маске файла. что касается битов которые не установленных битов (равных 0) в маске find
                   # то эти биты в маске файла могут быть любыми
                   # сокращенно я называюь этот режим all match
    
    -perm /маска   # в этом режиме нужно чтобы хотя бы один любой устанолвенный бит в маске find
                   # был установлен в маске файла
                   
сама маска может задавать либо через OCT число либо через вид "u=r,g=w,o=x"
пример

    $ ls -1al
    -r-------- 1 vasya vasya    0 дек 10 23:57 1.txt
    -r--r----- 1 vasya vasya    0 дек 10 23:57 2.txt
    -r--r--r-- 1 vasya vasya    0 дек 10 23:57 3.txt
    -rw-rw-r-- 1 vasya vasya    0 дек 11 01:03 4.txt

вначале ищем файлы у которых пермишнс точно совпдадает с 444
    $ find .  -perm 444
    ./3.txt
кстати можно дополнительным образом подчеркнуть для find что 
маску мы вводим в OCT формате хотя это необязательно
    $ find .  -perm 0444
    ./3.txt

    
в этом примере мы ищем файлы у которых установлены биты 
user = read, group=read, other=read
что касается остальных битов то нам на них насрать
как видно в выборку попал файл 4.txt хоть 
у него есть биты установленные на запись но нам на это
насрать
    $ find .  -perm -444
    ./3.txt
    ./4.txt
    
теперь мы ищем файлы у которых установлен хотя бы
один любой бит из списка
user = read либо  group=read либо other=read
как видно под это подошли все файлы
    $ find .  -perm /444
    ./1.txt
    ./3.txt
    ./2.txt
    ./4.txt

далее я повторяю ровно теже 
самые запросы но маску задаю в символьном виде
    $ find .  -perm u=r,g=r,o=r
    ./3.txt

    
    $ find .  -perm -u=r,g=r,o=r
    ./3.txt
    ./4.txt

    $ find .  -perm /u=r,g=r,o=r
    ./1.txt
    ./3.txt
    ./2.txt
    ./4.txt


    
таким макааром я вовзращаюсь к исходному примеру где было указано
    $ find / \( -perm -4000 .....
откуда становится понятен смысл аргумента
    -perm -4000
мы  ищем файлы у которых установлен SUID бит. что до остальных 
битов в маске нам все равно

теперь еще раз посмотрим на исходную команду

    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -printf /root/big.txt '%-10s %p\n' \)
    
так вот вопрос чем отличается -fprintf от -printf 
а тем что -fprintf она берет результат форматирует его и пишет его на диск
а -printf берет результат форматирует его и пишет на stdout 
поэтому вот этот кусок в команде неправильный ( а между прочим это пример из man find )
    -printf /root/big.txt '%-10s %p\n'
    
так как у нас указан файл то нужно изменить этот кусок на 
    -fprintf /root/big.txt '%-10s %p\n'
    
либо на такой кусок
    -printf '%-10s %p\n'


так я еще раз пересмотрел пример из man find
    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
       \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

и оказыается это  я его переписал с ошибкой. в ориигинальном примере ошибок нет

теперь я хочу разобрать что значит эти загадочные символы описывающие формат
    '%#m %u %p\n' 

    '%-10s %p\n'

окаызвается %m укаызвает что find должен напечатать маску пермишснов в oct формате.
если мы хотим получить дополнительный ноль то нужно юзать %#m
символ \n нужен чтобы был перенос строк
пример
    $ find . -printf '%m\n'
    775
    400
    
    $ find . -printf '%#m\n'
    0775
    0400

%u означает напечатай мне имя владельца файла. если у него нет 
символьного имени то напечатай ID

    $ find . -printf '%u\n' | head -n2
    vasya
    vasya

%p это напечатай мне имя файла
    $ find . -printf '%p\n' | head -n2
    .
    ./1.txt

%f печатает имя файл и убираем из его имени хрень вида "./"
что очень удобно
    $ find . -printf '%f\n'
    .
    1.txt

%s печатает размер файла в байтах
кстати  прикол в том что у самого find нет никаких ключей чтобы показывать размер файла в мегабайтах
или гигабайтах. только можно в байтах. это конечно проеб
    $ find . -printf ' %s  \n'
    4096  
    0  

кстати можно в вывод вставлять всякие элементы декора
что тоже очень круто
    $ find . -printf '%f -> %s  \n'
    . -> 4096  
    1.txt -> 0  


    $ find . -printf 'имя файла = %f -> размер = %s  \n'
    имя файла = . -> размер = 4096  
    имя файла = 1.txt -> размер = 0  



    
откатываемся чуть назад
получается вот эта хрень
    '%#m %u %p\n' 
означает напечатай маску в oct формате и доп нулем, потом владельца файла и имя файла

    $ find . -printf '%#m %u %p\n'  | head -n2
    0775 vasya .
    0400 vasya ./1.txt


теперь я хочу понять что это за хрень

    '%-10s %p\n'

главынм образом непонятно что это значит этот кусок
    %-10s

а значит это вот что:
для начала отойдем от реализации printf у find и перейдем в к реализации
просто printf с которым я до этого работал. эта штука пришла из языка C
и в нем есть вот что. я привык что внутри поля формат идут вот такие хрени
    %x
    %d
    %s
    %c

так вот эта хрень на самом деле она длинее. гораздо длиннее
а я видел до этого просто сокращеный формат. 
полный формат этого выглядит как 
    
    %[Flags][Minimum field width][Period Precision. Maximum field width]Argument type

даю расшифровку.  этой формулы

    Argument type

это x либо d , s, c
на самом деле их гораздо больше (https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html)

    %d %i     Decimal signed integer.
    %o	      Octal integer.
    %x %X     Hex integer.
    %u	      Unsigned integer.
    %c	      Character.
    %s	      String. See below.
    %f	      double
    %e %E     double.
    %g %G     double.
    %p        pointer.
    %n	      Number of characters written by this printf.
              No argument expected.
    %%	      %. No argument expected.

щас мы их все отработаем чуть ниже. а пока расшфифровываем
поля дальше

[Period Precision. Maximum field width] = это число которое в одних случая обозначает сколько цифр 
                   сохранить после запятой в дробном числе,
                   в другом случае задает макс распечатываему длину аргумента,
                   я это щас тоже покаж на примере
                
    
[[Minimum field width]] = это число которое покаывает минимальную ширину аргумента в ряде случаев


[flag(s)] = это флаги. 
они бывают:

    -      Left justify.
   0  	  Field is padded with 0's instead of blanks.
   +	  Sign of number always O/P.
   blank  Positive values begin with a blank.

   # 	  особый флаг имеет разные назначения:
	  %#o (Octal) 0 prefix inserted.
	  %#x (Hex)   0x prefix added to non-zero values.
	  %#X (Hex)   0X prefix added to non-zero values.
	  %#e         Always show the decimal point.
	  %#E         Always show the decimal point.
	  %#f         Always show the decimal point.
	  %#g         Always show the decimal point trailing 
	  	      zeros not removed.
	  %#G         Always show the decimal point trailing
		      zeros not removed.

		      

так вот вовзращаемся к нашему примеру

    %-10s
	
значит когда у нас аргумент это %s тоесть простой стринг то число перед s
это ширина столбика внутри которого будет печататься наш аргумент
наш стринг. и дело в том что по дефолту выравнивание происходит
по правой стороне столбика поэтому если у нас столбик 
шириной 10 символов а аргумент шириной 5 символов тогда 
у нас при печати перед символами будет куча пробелов.
это из за выравнивания по правому борту по дефолту.
    $ printf "%10s \n" "12345"
         12345 
если мы хотим выравниваться по левому борту то надо поставить
флаг "-" тогда
    $ printf "%-10s \n" "12345"
    12345      

таким образом разгадаа загадка что значит 
    %-10s

вот эти параметры при печати очень удобны кодга мы заранее незнаем длину
нашего аргумента

насвкику нахрен все это формтрование надо ?
а надо оно походу тогда когда мы печатаем несолько строк. 
в кажой строке по несколко столбцов. и у нас скажем аргумент в кажом столбце прыгает 
принимая разное количсво символов. так вот чтобы столбдцы были красивые то
помогает это форматирование. показываю
вот так выглядит печать без форматирования
    $ for i in $(echo "1 100 2 1000 33" ); do printf "%s 44\n" "$i"; done 
    1 44
    100 44
    2 44
    1000 44
    33 44

вот так с форматированием
разница как говориттся колоссальная
    $ for i in $(echo "1 100 2 1000 33" ); do printf "%-10s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44

возникает вопрос а что если у нас задана ширина первого столбца как 10 симвлов а аргумент будет 20
симвлов?
ответ - будет то что ширина первого столбца тогда будет автоматом увеличена
чтобы у нас нащ исходный стринг поместился и не был затерт. 
поэтому ширину столбца есть смысл выбирать длинной такой какова максимальная
длинна аргумента в столбце может быть
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-10s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44
    1000000000000 44


а вот я увеличил шириину столбца
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-20s 44\n" "$i"; done 
    1                    44
    100                  44
    2                    44
    1000                 44
    33                   44
    1000000000000        44

    
можно пойти и по другому пути. можно обрезать сам стринг вот так 
    $ printf "%-4.2s --\n" "123456"
    12   --
тоесть я гооворю что ширина столбца 4 символа а при этом макс ширина стринга вырезается равной 2 символа

возвращаюсь к примеру что был чуть выше
я оставляю ширину столбца 10 символов но ограничиыаю макс ширину печатаемого стринга как 9 
символов. поэтому  у меня мой длинный стринг будет обрезан. 
первый столбик будет выглядеть красиво но конечно же потеряется часть информации.
жалко что у printf нет такого флага чтобы как то сигнализировать что при печчати 
аргумент был порезан
    $ for i in $(echo "1 100 2 1000 33" 1000000000000); do printf "%-10.9s 44\n" "$i"; done 
    1          44
    100        44
    2          44
    1000       44
    33         44
    100000000  44

таким образом вот эта хрень
    %-10.9s
означает что возьми стринг. обрежь из него 9 символов и напечатай их в столбике шириной 10 символов
с выравниваеием по левой стороне.

далее. 
если мы возьмем число с плавающей точкой
    $ printf "%20.2f \n" "1234,5678"
             1234,57 

то смысл 
    %20.2f
вот какой.
мы говорим вот что 
f = означает что тот стринг который стоит в аргументе надо рассматривать как число с плавающей точкой
окей. он переводит внутри себя этот стринг как число с плавающей точкой 1234,5678
    "1234,5678" --> 1234,5678

далее 20 означает ширину столбика в котором будем печаат аргумент. по умолчанию выравнивение по правому краю
.2 означает что после запятой нужно сохранить два знака
поэтому 
    1234,5678 --> 1234,56
далее он конвертирует число обратно в стринг "1234,56"
и печатает его в столбике шририной 20 симвлов с выравнивем справа
еще пример
    $ printf "%20.2f ----\n" "1234,5678"
             1234,57 ----
соотвесвтенно ширина столбика играет роль для следущего печатуемого аргумента.
еще пример
    $ printf "%-20.2f ----\n" "1234,5678"
    1234,57              ----
тоесть первый аргумент печатается как дробное число с сохраненеим двух знаков
после запятой в столбике шириной 20 симвоолов с выравниванием слева.
значит следущий аргумент "----" уже начинает печататься с 21 позиции в строке.

вот еще один пример. из которого видна как важна ширина столбца
и по какому краю выравнивание

    $ printf "%s \n" "---------- ----------"
    $ printf "%-10s %10.2f \n" "123" "12,123456"
    $ printf "%10s %-10.2f \n" "123" "12,123456"
    ---------- ---------- 
    123             12,12 
            23 12,12      


теперь я вовзращась к тому что printf у меня еще есть в find.
и прикол в том что согласно man find у егоного принтф значения 
для %s другое чем у классического printf. у файндовского принтф
%s    означает  File's size in bytes.


так вот насколько я понимаю в случае файндовского printf 
формат %-10s означает что возьми длиннну в байтах 
и напечатай ее в столбике шириной 10 символов с выравниванием слева.
проверяю.

    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10s %f \n' | sort | head -n7
    1011712    temp 
    102        .python_history 
    102        .zshrc 
    1070       33.txt 
    11026432   atomicwallet-2.75.3.dmg.1 
    11853498   fastrans-2022-11-29-gt_erp.sql.gz.7z 
    118        kuku.txt 


значит как работает эта команда. я говорю чтобы find нашел в папке "." с глубиной поиска 1 файлы такие что 
 0b < размер файлы < 4096b  OR  размер файла > 4096b
кстати прикол в том что по дефолту аргумент -size это блоки. так что если я хочу заказывать размер  в байтах 
то надо добавлят "c" тоесть -size +4096c 
плюс означает больше, минус означает меньше.

так вот найденные файлы печатаются по формату
    -printf '%-10s %f \n'
где s это размер файла в байтах
а f это имя файла

насколко я понимаю если у классического printf %s %f ознаает тип данных то у файндовского принтф это 
означает какие поля и свойств файла надо печатать. а тип данных у него всегда один это стринг. вот такая ужасная
путаница между классическим принтф и файндовским
то есть виртуально можно файндовский формат сконвертировать в классический вот так
    printf '%-10s %s \n'  "размер файла" "имя файла"
так вот я печатаю размер файла в столбике размером 10 симвлов. выравнивание слева
имя файла просто печатается без всяких стобиков и без всяких вырваниваий просто 
с позиции 11 от начала строки.

а вот потверждение моей теории
    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10.2s %.2f \n' | sort | head -n7
    10         33 
    10         .p 
    10         te 
    10         .z 
    11         at 
    11         fa 
    11         ku 

поскольку файндовский принтф все аргументы воспринимает как стринг то запись вида 
    %-10.2s
говорит о том что напечатай аргумент в столбике шириной 10 символов а сам аргумент обрежь до двух символов
тоже самое здесь
    %.2f
возьми аргумент и обрежь его до двух символов

пздец.

еще пример
    $ find . -maxdepth 1 "(" -size +0c -a -size -4096c -o  -size +4096c ")"  -printf '%-10s %8.8f \n' | sort | head -n10
    1011712        temp 
    102        .python_ 
    102          .zshrc 
    1070         33.txt 
    11026432   atomicwa 
    11853498   fastrans 
    118        kuku.txt 
    122          13.txt 
    127        .Xauthor 
    131        .xinputr 

я печатаю размер файла в столбике длинной 10 симвлов вырванию его по левому краю.
а имя файла печатаю в столбике 8 символов выравниваю по левому краю и обрезаю аргумент до длины 8 символов

дауж... наворотили
это зведец. сам по себе принтф это звездец. а принтф у программы файнд это дполнительный звездец.

разберу примеры из man find
он ищет в папке /tmp файл 
        с именем core
        тип файлы обычный
        и печатает на экране название файлов
        далее это пеернаправляется через пайп на xargs и там этот файл стирается

    $ find /tmp -name core -type f -print | xargs /bin/rm -f

еще пример
ищет в папке "."
тип файла обычный
и найденное имя файла подставляется в команду file в качестве аргумента
    $ find . -type f -exec file '{}' \;

насколко я понял  хрень -exec file '{}' \; работает так. берется команда file в нее вместо аргумента '{}' подставляется
имя файла наденного (если файлов много то по одному на одну команду ) и \; сообщает файнду что строка аргументов закончилась.

я сразу приведу команду которая такая же самая но выглядит более по человечески

    $ find . -type f -exec file '{}' ';'
итак каждый найденный файл будет вставлен в команду
    $ file имя_файла;
и она будет выполнена.
и так с каждый найденным файлом
еще раз повторюсь что '{}' говорит файнду что именно в это место нужно вставлять имя найденного файла.
';' это говорит файнду что строка с аргументами для подстановки закончена и можно запускать команду.
и {} и ; надо сэкранировать, чтобы бащ передал эти аргументы внутрь find без изменений.
экранировать можно либо через '' либо через слеши / мне гораздо больге нравтся экранировать через ''
вместо слешей
может возникнут желание сэкранировать за один присест и {} и ;
но это нельзя делать. потому что надо чтобы баш передало в find это как два отдельных  аргумента
    $ strace -e execve find . -type f -exec file '{}' ';' 
    execve("/usr/bin/find", ["find", ".", "-type", "f", "-exec", "file", "{}", ";"]


показываю теперь как оно отработает на чуть другом примере

    $ ls -1
    1.txt
    2.txt
    3.txt
    4.txt


    $ find . -type f -exec echo \"название файла = '{}' \" ';' 
    "название файла = ./1.txt "
    "название файла = ./3.txt "
    "название файла = ./2.txt "
    "название файла = ./4.txt "


получается что через -exec можно можно выполнять команды над найденными файлами без использования pipe
и xargs.  единственное требование к команде  это чтобы она понимала работу с файлами через аргумент.
показываю пример через xargs аналоичный предыдущей команде

    $ find . -type f | xargs -L1 -I% echo "название файла = %;" 
    название файла = ./1.txt;
    название файла = ./3.txt;
    название файла = ./2.txt;
    название файла = ./4.txt;

в целом лучше не использовать pipe+xargs потому что это лишняя команда и перекачка через пайп
показываю пример
скрипт с xargs
    $ ls -1 /etc/ssh/*.pub | xargs -L 1 -I %  ssh-keygen   -l -E sha256 -f  %
    256 SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10 root@vasya-Lenovo-IdeaPad-L340-15IWL (ECDSA)

пример c find+exec
    $ find /etc/ssh/*.pub  -exec ssh-keygen   -l -E sha256 -f  '{}' ';' 
    256 SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10 root@vasya-Lenovo-IdeaPad-L340-15IWL (ECDSA)

итак возвращаюсь к исходному примеру    
будут взяты файлы из текущей папки и ее подпапок
тип файла обычный, и на них натравливается команда file
    $ find . -type f -exec file '{}' ';'

а вот я модифицировал команду 
и получаю ошибку
и это  дает ошибку о том что указаны неправильные аргументы 
команды file
тоесть попытка всунуть внутрь -exec  пайп приводит к ошибке
о том что find пыается запустить file у котрого в аргументах вставляется  pipe и head -n5
    $ find . -maxdepth 1 -type f -exec  file '{}'  "|"  head -n5 ';'

    file: invalid option -- '5'
    Usage: file [-bcEhikLlNnprsvzZ0] [--apple] [--extension] [--mime-encoding] [--mime-type]
            [-e testname] [-F separator] [-f namefile] [-m magicfiles] file ...
        file -C [-m magicfiles]
        file [--help]

тоесть видно что file запускается с неверными аргументами.

окей идем другим путем выносим pipe из под -exec наружу

    $ find . -maxdepth 1 -type f -exec  file '{}' ';'  | head -n5
    ./09.bash: Bourne-Again shell script, UTF-8 Unicode text executable
    ./08.bash: Bourne-Again shell script, UTF-8 Unicode text executable
    ./03.bash: Bourne-Again shell script, ASCII text executable
    ./args: POSIX shell script, ASCII text executable
    ./sha512crypt.bash: Bourne-Again shell script, ASCII text executable
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13

сигнал 13 это signal 13 это SIGPIPE
он возникает вот когда - у нас есть два процесса которые запущены через пайп
например 
    $ comm1 | comm2

так вот как обычно обстоит дело. напримере
    $ echo "1" | grep "2"
вторая команда никогда не закончит свою работу раньше чем 
закончит работу первая команда.
тоесть как эта связка работтает. echo сует 
на stdout байты эти байты летят в пайп в буфер в ядре
и echo при этом заканчивает работу и ос убивает этот процесс.
после этого grep получает на stdin из пайпа из ядра, 
отрабатывает поток байтов и тоже заканчиывает свою работу.
такого никогда не будет что grep закончит свою жизнь
раньше чем echo , это просто не возможно.
рассмотрим другой вараинт.

    $ cat file1 | head -n 5

тут все по другому работает. 
cat засасывает из файла некоторую кучу байтов. 
потом cat сует то ли часть этих байтов толи все засосанные
байты в stdout , по факту они летят в пайп , в буфер ядра,
далее из ядра из буфера этот поток прилетает в head  в его 
stdin. и он начинает его обрабатывать. итак и далее 
cat засасывает данные и то ли она паралельно часть данных сует 
в stdout то ли она работает в полудуплексном режиме тоесть 
либо чтение из файла либо сует поток в stdout но в любом случае
cat сует данные в stdout это летит в ядро из ядра оно летит
на stdin команды head. так вот положим файл file1 он огромный.
а команда head ей нужно всего первые 5 строк и все. так вот 
наступает момент когда head видит что он обработал 5 строк. 
и он посылает ядру запрос о том чтобы ядро убило head.
и ядро убивает head. а в этот момент cat продолжает читать файл
и пихать его в stdout в pipe. и вот получается что процесса head
его уже нет в природе. а cat продолжает работать и пихает данные в 
stdout в пайп в конечном итоге. и когда такой момент настанет (процесса
head уже нет а cat пихает данные  в pipe) то ядро вдруг видит что 
один процесс пытается писать в пайп но при этом нет ни одного 
процесса который бы имел открытый этот же пайп на чтение! и тогда
внимание ядро вместо того чтобы принять от процесса cat его запрос
на запись в пайп оно посылает процессу cat сигнал SIGPIPE (13)
и дальше понятно. когда щедулер доходит до запуска на цпу
процесса cat то видит что к нему пришел сигнал и ядро запускает
хендлер обработчик этого сигнала (некий код) и в итоге ввсего на
всего от хендлера летит к ядру запрос чтобы ядро убило процесс в нашем
случае cat.
таким обраозом еще раз как и когда получается что в процесс прилетает
SIGPIPE - если у нас в пайпе завязано два процессе. первый пишет в пайп
а второй читает из пайп. то сигнал 13 прилетает от ядра только к процессу
который пишет в пайп и никогда не прилетает к процессу который читает из 
пайпа. так вот если у нас по каким то причинам исчезает процесс который
читает из пайпа и у нас оказывается что нет ни одного процесса который 
бы имел открытым пайп на чтение. то при попытке процесса записать в пайп
ядро в ответ пришлет этому процессу сигнал 13. который как бы ознчает "эй
процесс ты просишь меня принять от тебя данные в пайп но я тебе сообщаю
что нет никакого процесса который потом будет читать твои данные
из пайпа. имей ввиду". и после этого хендлер этого сигнала убивает 
процесс пытающийся записать в пайп. вот как это работает.
поэтому если процесс справа от пайпа исчез сдох закончил свою работу
то процессу стоящему слева от пайпа прилетит сигнал 13 и этот процесс
слева будет убит.  значит когда хендлер убивает процесс то это зависит
от хендлера этого процесса будет он чтото писать на терминал или нет.
захочет пишет. захочет не пишет. например хендлер у cat нихрена 
не пишет. а хендлер у xargs пишет. я щас это покажу на примере.
вначале берем просто команду sleep

    $ sleep 130

убиваю его
    $ kill -15 $pid

получаю
    $ sleep 160
    Terminated

вот это terminated это хендлер этой команды отреагирова на сигнал 15

запускаю команду cat

    $ cat /dev/zero >/dev/null
    
и убиваю его

    $ cat /dev/zero >/dev/null
    Terminated

получаю terminated. это хендлер уже этой команды

теперь запускаю их в пайпе

    $ cat /dev/zero  | sleep 160
    

убиваю sleep
правда убью его не сигналом 15(SIGTERM) а более мягким сигналом 2(SIGINT)
    $ kill -2 $pid_sleep
    
и что мы увидим
    $ cat /dev/zero  | sleep 160

тоесть ничего. хендлеры мягко убили все эти процессы.

а теперь возвращаемся к нашему xargs

    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null

убиваем cat

    $ kill -2 $cat_pid
    
и получаем "xargs: echo: terminated by signal 13"

    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null
    xargs: echo: terminated by signal 13



тоесть я убил cat который читал из пайпа. и xargs при попытке 
записи в пайп получил от ядра пинок signal 13
и хендлер сигнала 13 процесса xargs вывел на экран мессагу.

а теперь я вот к чему перейду. как нам узнать о проблеме
с пайпом если хендлеры молчат. и тут нам на помощь приходит 
спеец переменная bash ${PIPESTATUS[*]}  это массив.
в этой переменной находятся все коды возврата "$?" всех процессов
которые стояли в пайпах. показываю на примере

    $ echo "1" | cat  | cat  | cat | xargs echo >/dev/null; echo "${PIPESTATUS[*]}"
    0 0 0 0 0

эти нули показывают коды возврата каждой команды которая стояла в 
цепочке пайпов
из этого вывода мы видим что все команды закончили свою работу успешно.

а теперь посмотрим какие коды возврата когда у нас команда стоящая
справа от пайпа заканчивает свою работу раньше чем команда слева от пайпа.
я запускаю цепочку пайпов

    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null; echo "${PIPESTATUS[*]}"
    
далее я убиваю cat через SIGINT
    $ kill -2 $cat_pid
    
и я получаю
    $ yes | xargs -L1 -n1 echo | cat 1>/dev/null; echo "${PIPESTATUS[*]}"
    xargs: echo: terminated by signal 13
    141 125 130

    
получается cat закончил свою работу с кодом $?=130
тут я скажу о том что если код возврата больше 128 то обычно такой 
код возврата напрямую показывает что процесс был убит сигналом и номер
этого сигнала можно вычислить по формуле $?=128+N
тоест у нас код возврата 130=128+N , N=2 значит процесс подох
от сигнала signal 2 (SIGINT) 
таким макаром 

$?(cat) = 130 , сдох от SIGINT
$?(xargs) = 125 
$?(yes) = 141 , сдох от signal 13 (SIGPIPE)

на счет сигнала 125 . все что касается расшифровки смысла сигналов кода 
возврата процесса. код 0 всегда означает успех. все остальные коды 
означают какую то ошибку. но какую хрень знает. 
какой код возврата выдаст процесс на какую то ошибку неизвестно. 
потому что это зависит от кастомного хенлера этого конкретного процессса.
поэтому что значит 125 код возврата у xargs хуй знает. но как я 
как раз понимаю у xargs это ошибка означает что процесс xargs был 
закончен из за прилета SIGPIPE. итак

$?(cat) = 130 , сдох от SIGINT
$?(xargs) = 125, сдох от SIGPIPE
$?(yes) = 141 , сдох от signal 13 (SIGPIPE)

получаем 

    $ yes | xargs | cat 
    
получаем мы убили cat, и вслед за этим xargs не смог записать в пайп ибо 
его убило ядро через SIGPIPE, и вслед за этим yes не смог записать в свой 
пайп и был убит ядром через SIGPIPE

таким образом я еще раз говорю о том что нам чтобы узнать были ли проблемы
с цепочкой пайпов через массив "$PIPESTATUS[*}"
причем нужно снимать данные из "$PIPESTATUS[*}" сразу как закончила работать
цепочка пайпов потому что эта переменная (как написано) скоропортящаяся.



далее я  запустил
     $ find . -maxdepth 1 -type f -exec  sleep 160  ';'  | head -n5
и попытался найти куда и как подключется пайп. и получил
find имеет номер процесса 9174
sleep имеет номер процесса /9284
head имеет номер процесса 9175

также видно что 
вот такое дерево процессов

    bash(3689)|---find(9174)---sleep(9929)
              |---head(9175)

тоесть и find и head имеют одного родителя

и вот что я увидел в плане пайпа

    $ ls -1al /proc/9174/fd    # find 
    0 -> /dev/pts/25
    1 -> 'pipe:[3796881]'  <--
    2 -> /dev/pts/25

    $ ls -1al /proc/9284/fd   # sleep
    0 -> /dev/pts/25
    1 -> 'pipe:[3796881]'  <--
    2 -> /dev/pts/25

    $ ls -1al /proc/9175/fd  # head
    0 -> 'pipe:[3796881]'  <--
    1 -> /dev/pts/25
    2 -> /dev/pts/25

отсюда видно что 
    в find подключается pipe на запись
    в sleep пайп подключется на запись 
    в head пайп открывается на чтение


    $ find . -maxdepth 1 -type f -exec  file '{}'  ';' |  head -n2
    ./1.txt: empty
    ./3.txt: empty
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13
когда же мы убираем -exec 
то все окей с прерыванием работы find когда head закончил свою работу
    $ find . -maxdepth 1 -type f  |  head -n2
    ./1.txt
    ./3.txt

однако все ли на самом деле хорошо?
проверим через PIPESTATUS

    $ find . -maxdepth 1 -type f  |  head -n2; echo "${PIPESTATUS[*]}"
    ./1.txt
    ./3.txt
    0 0

вау! оба процесса закончили без ошибок. 
из этого примера я делаю вывод что не всегда ситуация когда процесс
справа заканчивает работу раньше чем слева это приводит к ошибке SIGPIPE.
будет ошибка или нет зависит от того буфферизует данные в себе команда 
слева от пайпа. очевидно что cat или xargs они буфферизуют в себе данные.
а find без -exec походу получается нет. интересно!

    
кстати совать пайп под -exec не имеет смысла. потому что под -exec обрабатывается только один файл.
тоесть
в этом нет смысла
    $ find . -maxdepth 1 -type f -exec  bash -c 'file {} | head -n2'  ';' 

у нас под башем комагда file "1.txt"  | head -n2 
в ней нет смысла котоырй мне нужен. а смысл такой что я хочу чтобы как только 5 строчек файнд выплюнет
то его работа закончилась.

пайп конечно можно вставить. только надоо погимать зачем. чтоон делает

тоесть вот пример
$ find . -maxdepth 1 -type f -exec  bash -c 'stat  {}'  ';' 
  File: ./1.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15073824    Links: 1
Access: (0400/-r--------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-12-10 23:57:18.335641448 +0600
Modify: 2023-12-10 23:57:18.335641448 +0600
Change: 2023-12-11 01:02:11.447191099 +0600
 Birth: -
  File: ./3.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15073826    Links: 1
Access: (0444/-r--r--r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
Access: 2023-12-10 23:57:21.627646002 +0600
Modify: 2023-12-10 23:57:21.627646002 +0600
Change: 2023-12-11 01:02:32.155191286 +0600
 Birth: -

 я хочу обрезать статстику по каждому файлу. тогда можно пайп засунуть под -exec
 вот пример
    $ find . -maxdepth 1 -type f -exec  bash -c 'stat  {} | grep -E "File|Uid"'  ';' 
    File: ./1.txt
    Access: (0400/-r--------)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
    File: ./3.txt
    Access: (0444/-r--r--r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)
в этом случае пайп делает то что нам надо безусловно но это другой пример. 
учитывая проблемы с пайпом из под -exec тогда проще xarg заюзать


тоесть вместо 
     $ find . -maxdepth 1 -type f -exec  file '{}' ';'| head -n2  

    $ find . -maxdepth 1 -type f | xargs -L1  file | head -n2
    ./1.txt: empty
    ./3.txt: empty
    xargs: file: terminated by signal 13

далее вот такой пример    
    $ for i in 1 2 3 4 5; do echo $i; done | head -n5  | head -n1; echo "${PIPESTATUS[*]}"
    0 0 0
    
видно что никаких проблем

еще пример

    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 echo  | head -n2
    1
    2
    xargs: echo: terminated by signal 13


и вот я нашел в инете пример с tail
нужно вставить доп команду в цепочку "tail -n+1" (https://superuser.com/questions/554855/how-can-i-fix-a-broken-pipe-error)
тогда
вначале без tail

    $ find . -maxdepth 1 -type f -exec  file '{}' ';'  | head -n2; echo "${PIPESTATUS[*]}"
    ./1.txt: empty
    ./3.txt: empty
    find: ‘file’ terminated by signal 13
    find: ‘file’ terminated by signal 13
    0 0


видно что коды возврата к удивлению нули. и при этом нет кода возврата
всех тех file которые тоже запускаются но о них ни слова

теперь с tail
    $ find . -maxdepth 1 -type f -exec  file '{}' ';' | tail -n+1 | head -n2; echo "${PIPESTATUS[*]}"
    ./1.txt: empty
    ./3.txt: empty
    0 0 0

я не очень понимаю почему исчезновение процесса head не привело к ошибкам у
tail.
проанализируем
я беру цепочку и вставляю в разные места pv чтобы посмотреть
с какой скоростью каждый участник цепочки срет на stdout


    $ yes | pv | xargs -n1 -L1 -I% echo "%"  |  tail -n +1  1>/dev/null
    72,0KiB 0:00:03 [21,5KiB/s]                                                                                                                                          ]


    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  


    $ yes | xargs -n1 -L1 -I% echo "%"  |    tail -n +1 | pv 1>/dev/null
    16,0KiB 0:00:16 [0,00 B/s] 

и тут я еще один пример посмотрю

    $ yes | pv  | cat - 1>/dev/null
    2,47GiB 0:00:02 [1,24GiB/s] 

так вот что я вижу из первого примера то что между yes и xargs 
идет скорость обмена с 21,5 KB/s
а с последнего примера я вижу что между yes и cat идет скорость обмена
со скоростю 1,24 GiB/s
из чего я делаю важный вывод что скорость обмена между процессами через пайп
скорее зависит от мощности принимающего процесса с какой сокростью он может читать
перерабатывать информацию а не от скорости записи информации отправляющего процесса.
тоесть когда  у нас стоит cat читающий из пайпа то yes может шарашить в пайп 
с огромной скоростью. а когда у нас за yes стоит xargs то такая маленькая скорость
обмена 21 KB\s зависит не от того что yes так меленно может срать в пайп а то что 
xargs может перерабатвыать данные так медленно поступающие
как я вижу когда процесс слева хочет записать в stdut он делает сисколл
в котором есть аргумент с куском данных. сисколл вызывает ядро. ядро смотрит 
есть ли место в буфере который под пайп задейтсовован. если место есть то данные 
записываются а если места нет то этот сисколл как я понимаю висит в состоянии s или d 
типа того. как только процесс справа прочитает данные из пайпа то место  в буфере пайпа
в ядре освободится и сисколл на запись сможет записать. 

я  это к чему. посмотрим еще раз на эту статистику

    $ yes | pv | xargs -n1 -L1 -I% echo "%"  |  tail -n +1  1>/dev/null
    72,0KiB 0:00:03 [21,5KiB/s]                                                                                                                                          ]


    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  


    $ yes | xargs -n1 -L1 -I% echo "%"  |    tail -n +1 | pv 1>/dev/null
    16,0KiB 0:00:16 [0,00 B/s] 


получается xargs читает из cat на скорости 21,5 KB\s
далее мы видим что между  tail и xargs  скорость в 20 раз меньше 1,21 KB\s
вопрос это xargs отдает существенно медленнее чем он читает данные 
т yes или tail такой тормоз? проверим

    $ yes | xargs -n1 -L1 echo | pv   1>/dev/null
    2,33KiB 0:00:02 [1,19KiB/s] 

видно что xargs крайне медленно умеет отдавать данные

    $ yes | pv | tail -n +1  1>/dev/null
    1,24GiB 0:00:01 [1,24GiB/s] [ 

для сравнения tail умеет читать данные очень быстро

значит 

    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  

медленный обмен между xargs и  tail основан на том что xargs 
очень медленно умеет отдавать тоесть tail просто сидит и ждет
когда же от xargs будет хоть какаято новая порция.

посмотрим на вот это 

    $ yes | pv | tail -n +1  1>/dev/null
    1,30GiB 0:00:01 [1,30GiB/s] 

    $ yes | tail -n +1 | pv  1>/dev/null
    1002MiB 0:00:02 [ 500MiB/s] 
    
отсюда видно что tail умеет быстро принимать 
и быстро отдавать. единственное что отдает он в 3 
раза медленнее чем принимает

тогда на основе этого
я анализируею вот этот кусок

    $ yes | xargs -n1 -L1 -I% echo "%"  | pv |   tail -n +1  1>/dev/null
    4,64KiB 0:00:04 [1,21KiB/s]  


    $ yes | xargs -n1 -L1 -I% echo "%"  |    tail -n +1 | pv 1>/dev/null
    4,00KiB 0:00:04 [4,00KiB/s]
    4,00KiB 0:00:06 [0,00 B/s] 
    8,00KiB 0:00:07 [3,91KiB/s] 
    8,00KiB 0:00:08 [0,00 B/s] 
    8,00KiB 0:00:09 [0,00 B/s] 
    8,00KiB 0:00:10 [0,00 B/s]
    12,0KiB 0:00:11 [3,89KiB/s]
    
получается в tail влетают данные на скорсти 1.21 KB\s и как 
видно tail их мнговенне не высирает на stdout а он насасывает данные 
какоето время а потом выбрасывает одним большим пакетов. 

понимаю теперь как рабтает каждая программа в цеопочке мы знаем 
и смотрим на целую цепочку

когда входной поток всего две строки
и на выходе head -n2 неумирает пока не увидит
две строки
то конечно все окей
    $ echo -e "1\n2\n" | xargs -n1 -L1 -I% echo "%"  | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    0 0 0

тут когда три строки слева а справа две строки
то уже жопа
head умирает а xargs после этого еше живой
и хочет писать в пайп и пролучает от ядра signal 2 SIGPIPE
и умирает с ошибкой
    $ echo -e "1\n2\n3\n" | xargs -n1 -L1 -I% echo "%"  | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    xargs: echo: terminated by signal 13
    0 125 0

вставляем cat между xargs и head
    $ echo -e "1\n2\n3\n" | xargs -n1 -L1 -I% echo "%"  | cat | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    0 0 141 0

видно что cat умирает от SIGPIPE просто хендлер для SIGPIPE  у cat
молчаливо убивает процесс а у xargs хендлер SIGPIPE убивает 
процесс с руганью  в терминал
тоесть ситцация такая же как в прошлом примере , процесс умирает 
аварийно только он об этом не ругается

мне правда мне малек непонятен еще момент. вот head умер. насколько мгновенно
сигнал об его смерти накидывается все процессам из цепочки. а если какойто 
процесс из цепочки висит уже на каком то ядре? потому что ведь баш должен убить все 
процессы в цепочке если умер хотя бы один процесс из цепочки. как я понимаю 
из этой практики что когда умер head то сигнал  о том что надо сдохнуть всем 
процессам в цепочке когда то прилетит другим процессам цепочки но непоняно когда
зато до этого момента один из процессов цепочки попадет на цпу и будет продолжать
исполняться и в частности попробует записать в пайп. если бы ядро после убиения
head мгнвенно прибило другие процессы то SIGPIPE бы не было. а так head уже нет.
процессы в цепочке неприбиыт еще неуспело ядро накидать на все процессы SIGTERM
а может при этом процесс пишущий в файл имеет статус D.  и в итоге оставишийся
процесс из цепочки попадает на цпу и пытвается писать в пайп. ядро видит что 
процесса которы бы читал из пайпа уже нет. и кидает SIGPIPE.


    
вместо cat всталвяем tail между head и xargs
и вдруг у нас все команды отрабатывают с кодом возврата ноль
несмотря на то что head умирает раньше всех
    $ echo -e "1\n2\n3\n" | xargs -n1 -L1 -I% echo "%"  | tail -n +1 | head -n2; echo "${PIPESTATUS[*]}"
    1
    2
    0 0 0 0

оп уже все коды 0.
тоесть head сдох. 
а tail при этом не собирался писать в pipe.
и к нему успел прилететь сигнал SIGTERM что пора сдыхать
тоесть head сдох. какоето время tail болтается в космосе и сигнал SIGTERM 
еще не прилетел. и tail успевает залезть на цпу но отправлять в pipe он при этом
ничего несобирался и SGPIPE он не генериурует. и он дождавшись SIGTERM
он споокойно умирает в мире.

тоесть как я понимаю сиитуацию. умирает один из процессов в цепочке.
потом идет какойто временной лаг когда ядро разошлет всем процессам в цепочке
и получается что какоето время процессы из цепочки шедулером 
будут соваться на цпу.  и они буудут пыататься еще какоето время рабоать.
и в частности такой процесс будет пытаться писать в пайп. и именно тут ядро
ему пошлет SIGPIPE. а если процесс во время этого лага небудет пытаться в ядро
то он не словит SIGPIPE и дождется SIGTERM и умрет уже мягко.
получается из примера выше становится ясно что по какойто причине tail
не срет все время на stdout а срет он порциями. импульсами. то есть он то срет
на пайп то не срет. есть окна когда он не срет. и поэтому когда head умер
и tail какое то время несрет. хотя у него в кишках есть данные. но он 
все равно молчит. и tail успевает дожить до SIGTERM не высирая ничего не пайп 
и не провоцируя SIGPIPE
для сравнения cat неимеет буфера внутри а значит он срет на пайп постоянно.
я так погимаю почему cat ловит SIGPIPE а tail не ловит. при прочих равных.

    $ echo -e "1\n2\n3\n4\n5\n" | xargs -n1 -L1 -I% echo "%"  | tail -n +1 | head -n2; echo "${PIPESTATUS[*]}"  
    1
    2
    0 0 0 0

но процесс который стоит слева от tail накидывает ему данные 
яростно и сильно то тогда tail срет на пайп уже очевидно чаще.
и уже неуспевает дождаться до прилета ему SIGTERM
тоесть head сдох а программы стоящие слева продолжает наваливать данные
и в tail проодолжают наливаться данные. поэтому за то окно пока head сдох
но SIGTERM еще не прилетел то у tail переполняется его буфер и он срет 
на пайп и ловит SIGPIPE
    $ yes  | xargs -n1 -L1 -I% echo "%"  | tail -n +1 | head -n2; echo "${PIPESTATUS[*]}"
    y
    y
    xargs: echo: terminated by signal 13
    141 125 141 0

значит чтобы этого всего избежать надо чтобы вместо tail стояла такая команда 
которая очень может много в себя засосать много данных и при этом редко импульсно
срет на пайп.
тоесть cat срет на пайп постоянно при поступлении данных ибо у него буфера нет или
почти нет. tail уже срет на  stdout импульсно. 
нужна программа которая еще более импульсно срет. с большим буфером.

и тут я напоролся еще на один кусок инфо. оказвыается 
    Most standard Unix commands buffer their output when used non-interactively.
    This means that they don't write each character (or even each line) immediately, 
    but instead collect a larger number of characters (often 4 kilobytes) 
    before printing anything at all. In the case above, 
    the grep command buffers its output, and therefore awk only gets 
    its input in large chunks. ( https://mywiki.wooledge.org/BashFAQ/009 )

тоесть если процесс имеет свой stdout не на терминал (tty, pts)
а скажем в файл или в пайп тогда приложение не посылает каждый байт
сразу на stdout а копит их пакетами обычно по 4КБ. и посылает это
импульсами.


    
или другое решение можно использовать awk
я не знаю что значат его ключи но я знаю как эта хрень работает.
она печатает первые две строки по аналогии как head -n2
а далее она продолжает принимать весь поток от find пока 
он не закончится. поэтому такое решение вобщем то полное гавно
    $ find . -maxdepth 1 -type f -exec  file '{}' ';' | awk -v N=2 'NR<=N'
    ./1.txt: empty
    ./3.txt: empty

    
вот еще пример
я имею файл 17830.txt размером 1,59 GB
и вот четко видно что awk витоге прочитает весь файл полностью.
это полный дебилизм
    $ cat ./17830.txt | pv |  awk -v N=2 'NR<=N' 1>/dev/null
    1,59GiB 0:00:05 [ 283MiB/s]
    
в итоге я бы пока что сказал так на собщение от xargs о том 
что в него прилетел signal 13 можно полностью игнорировать.
в этом нет ничего ни странного ни нетяснимого ни вредного.
тоже самое касается если мы запускаем find + -exec
и он нам пишет про signal 13. 
это все окей. это просто значит что команда справа от пайпа 
закончила свою работу раньше чем команда слева от пайпа.
если смерть команды справа это закономерная вещь то все окей.

| tail

этот пример печатает последние 2 строки снизу
тоесть вначале полностью засасывается файл
либо поток байтов из stdin
и потом уже отсчитываются снизу 2 строки
    $ tail -n 2

    $ echo -e "1\n2\n"
    1
    2

    $ echo -en "1\n2\n" | tail -n 1
    2

единственное что мне непонятно это каким 
образом tail понимает что при приеме байтов
из stdin как tail понимает что передача байтов
наконец закончена.

еще вот я такое нашел о том как баш убивает процессы
в цепочке пайпов:
    If the pipeline is not executed asynchronously (see Lists of Commands), 
    the shell waits for all commands in the pipeline to complete.
    (https://www.gnu.org/software/bash/manual/html_node/Pipelines.html)

тоесть из этих слов следует что когда мы запускаем команды через пайп
то все что делает бащ это запускает процессы и увязывает их stdin stdout
вместе. и все. далее баш процессы не трогает. она тупо ждет пока
все процессы САМОСТОЯТЕЛЬНО закончат свою работу. тоесть если процесс
в цепочке закончил свою работу то баш не трогает другие процеесы
а ждет когда они сами закончат свою работу.

еще пример
имеем текстовый файл размером 1,59 GB
    $ cat 17830.txt | pv | tail -n 1
    1,59GiB 0:00:01 [ 904MiB/s] 

вот получатеся что cat читает файл целиком.
tail это целиком засасывает. и потом отсчитывает снизу 
одну строку.

окей когда cat закончил свою работу. но так как баш
не трогает остальные процессы после умирания одного из процесса
в цепочке пайпов поэтому когда cat закончил читать файл
и сдох то баш ничего не делает. для него оставшийся
tail просто процесс. и он просто ждет когда он САМ
закончит свою работу. поэтому tail не убивается а спокойной
анализирует засосанный файл столько сколько ему нужно.

единственное что мне непонятно как tail узнает что 
ему на вход на stdin больше ничего не придет.
что поток закончился.

ксттаи если баш сам не убивает процессы а процессы
сами себя убивают то вопрос а как они это делают?
пример

    $ yes | head -n5
    
возникает вопрос. когда head закончился
то как yes заканчивает работу? ответ 
очень ясный. когда yes попробует записать
в пайп то ос пришлет процессу SIGPIPE
и процесс будет убит хендлером.

    $ yes | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    141 0

так и есть. 141 это процесс был убит через SIGPIPE

далее вот что я нашел. наш процесс пытается писать в пайп
а как это делается ? а вот как пайп это файл. запись в файл
идет через сисколл write. так вот мы через сисколл write
посылаем в пайп(файл) кусок данных. сисколл это значит
что у нас запускается уже ядерный код ядра. так вот 
если пайп не открыт ни одним процессом на чтение то  в ответ
ядро пришлео процессу сигнал SIGPIPE. далее когда 
процесс нужно будет засунуть на цпу то шедулер увидит сигнал
и вместо кода процесса засунет на цпу хендлер сигнала 
SIGPIPE. и вот если хендлер так написан что он не убььет процесс
то тогда сисколл write вернется с ошибкой EPIPE.
правда что будет дальше я не понимаю. тоесть если мы юзаем
сисколл любой. и он вовзращает ошибку (ибо у каждого сисколла
есть варианты что он вернет ошибку при возврате из сисколла
в код процесса ) 

и тут я узнал как это работает
вот программа которая пробует открывать файл 


$ cat 97.c


#include <stdio.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>

int main()
{
// Declaration of a file descriptor
int fd;

// Opening a file
fd = open("/root/sasikala/testing",O_CREAT|O_EXCL);
// If Open is failed
if ( fd < 0 ) {
        printf("Opening file : Failed\n");
        printf ("Error no is : %d\n", errno);
        printf("Error description is : %s\n",strerror(errno));
}
// If Open is success
else
        printf("Opening file : Success\n");


// print hello world
printf("Hello, World!\n");
}

значит при открытии файла в fd возвращается номер файл дескриптора
через который можно работать с открытым файлом.
если при открытии файла произошла проблема то fd будет равен -1 или NULL
поэтому мы делаем проверку что fd < 0
при этом в C есть спец переменная "errno" которую можно подключить через 
    #include <errno.h>
так вот если при открытии файла возникла проблема то в переменной "errno"
будет номер который показывает какая именно ошибка возникла при отрытии файла.
можно узнать ее символическкую расшифроку через strerror(errno)
возникает вопрос а что происходит дальше с нашей программой если 
открытие файла не произошло из за ошибки? ответ - да также как в баше
когда мы команды через точку с запятой ввели - просто напросто начнет
исполнятся следующая команда! показываю - я компиирую программу
и запускаю ее.

    $ gcc -o 97.exe 97.c
    $ ./97.exe 
    Opening file : Failed
    Error no is : 13
    Error description is : Permission denied
    Hello, World!
    

тоесть мы не смогли открыть файл, 
далее идет расшифровка ошибки.
и далее выполнилась следующая команда по списку которая 
напечатала hello world.
поэтому ответ на вопрос - а что если у нас в коде выполняется команда
которая вызывает ошибку? ответ - если ошибка не критическая и мы неотлавливаем
сами своим кодом эту ошибку и сами не останавливаем программу то просто напросто
программа продолжит выполнять следующие команды ниже по тексту команды.

тут я хочу еще важную полезняшку сказать. мы получили код ошибки в виде цифры 13.
мы получили расшифроку ошибки через словесное обьяснение "Permission denied"
но фишка в том что в "$ man syscall" нет ни того ни другого. там ошибки которые
возвращает сисколл обозначаются одним словом корттким. например EPIP
как нам узнать это имея цифру ошибки например 13.
оказывается в /usr/src/... есть файлы *errno* в которых есть связь с 
цифрой ошибки и EPIP который указан в "$ man syscall"

например у нас сисколл open читаю его man
    $ man 2 open
так много ошибок укажу только две возможные
       EACCES The requested access to the file is not allowed,
       or search permission is denied for one of the directories 
       in the path prefix of pathname, or the file did
       not exist yet and write access to the parent directory is not allowed.
       (See also path_resolution(7).)

       EDQUOT Where O_CREAT is specified, the file does not exist, and the user's 
       quota of disk blocks or inodes on the filesystem has been exhausted.


начинаем искать число 13 в /usr/src/*errno*.h

    $ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(13\)+\($'(\t)'\)   '{}' ';'
    ./include/uapi/asm-generic/errno-base.h:#define	EACCES		13	/* Permission denied */

итак мы выяснили что 13 это EACCES
знаая это мы теперь можем детально почитать про нее в $ man 2 open 
и видим подрообное описание
    EACCES The requested access to the file is not allowed,
       or search permission is denied for one of the directories 
       in the path prefix of pathname, or the file did
       not exist yet and write access to the parent directory is not allowed.
       (See also path_resolution(7).)

синтаксис grep я разберу чуть ниже.


спрашивается а причем здесь пайп. нахрен я все это разбирал. а затем
что теперь стало все совершенно понятно прото что будет если у нас есть 
процесс который пытается писать в пайп но при этом нет процесса который 
бы имел открытым пайп на чтение. а происходит вот что. при попытке записать 
ос пришлет процессу SIGPIPE. далее отработает хендлер этого процесса
по обработке этого сигнала. если у процесса нет свеоего хендлера то 
дефолтовый хендлер ОС убьет процесс. а если у процесса есть 
свой хендлер который неубивает процесс а например просто на экране
рисует сообщение то тогда в системной переменной errno будет 
содержаться цифровой код ошибки почему запись в пайп была неудачная.
так как паай это файл то пишем мы в пайп также как в файл тоесть
через сисколл write. если запись в пайп была неудачная то в errno
будет записано такой код ошибки который соовествует ошибке EPIPE.
далее если мы в нашем коде программы после вызова write анализирует
успех этой операции и анализируем содержимое errno то мы увидим
что произошла ошибка и тут все зависит от нас. какой код мы написали
если мы при этом завершим процесс то окей. а если нет то дальше
все будет очень просто - наша программа продолжит выполнение 
дальнейшего кода !!!! вот как это будет раотат на практике.

$ cat 96.c


#include <stdio.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>


static void handler(int sig) {
    struct sigaction act = {
	.sa_handler = SIG_DFL,
	.sa_flags = 0,
    };
    sigaction(sig, &act, NULL);
    printf("Got signal %d\n", sig);
    //kill(getpid(), sig);
}



int main(int argc, char **argv) {
    int pipefd[2];
    bool ignore = argc > 1 && argv[1][0] != '0';

    struct sigaction oldact, act = {
	.sa_handler = ignore ? SIG_IGN : handler,
	.sa_flags = 0,
    };

    sigaction(SIGPIPE, &act, &oldact);

    pipe(pipefd);
    close(pipefd[0]); // reader
    if (write(pipefd[1], "Hello", 6) < 0){
	perror("write()");
	printf ("Error no is : %d\n", errno);
        printf("Error description is : %s\n",strerror(errno));
   }

    sigaction(SIGPIPE, &oldact, NULL);
    return 0;
}





$ ./96.exe 
Got signal 13
write(): Broken pipe
Error no is : 32
Error description is : Broken pipe


значит мы видим что мы получили ошибку 32. тоесть errno=32
ищем для него слово которое обозначает эту ошибку в *errno*.h

$ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(32\)+\($'(\t)'\)   '{}' ';'
./errno-base.h:#define	EPIPE		32	/* Broken pipe */

видим что errno=32 это EPIPE

ошибка возникла при сисколл write (хотя поправка это не сисколл это gnu libc функция
которая в своих кишках уже сама запускает нужные сисколлы)
значиит идем в man write и ищем описание EPIPE

  EPIPE  fd is connected to a pipe or socket whose reading end is closed.  
  When this happens the writing process will also receive a SIGPIPE  signal.   
  (Thus,  the write return value is seen only if the program catches, 
  blocks or ignores this signal.)

ксатии прогрмма 96.exe работает так - она пробует писать в пайп. 
при этом ос присылает ей SIGPIPE. вызывается ее хендлер. он печатает 
на экране "Got signal 13" и больлше ничего не делает.
тогда код програмы продолжает дальше выполнять дальнейшие команды. 
и мы анализируем код возврата из функции write через анализ
переменной errno. и печатаем на экране

    write(): Broken pipe    
    Error no is : 32
    Error description is : Broken pipe

  
теперь мне все стало понятно как это работает. и как и почему получаеся SIGPIPE
и как и что это значит EPIPE. 


теперь понясню про grep  
$ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(13\|32\)+\($'(\t)'\)   '{}' ';'
./include/uapi/asm-generic/errno-base.h:#define	EACCES		13	/* Permission denied */
./include/uapi/asm-generic/errno-base.h:#define	EPIPE		32	/* Broken pipe */

а именно 
    $ grep -H  -E \($'(\t)'\)+\(13\|32\)+\($'(\t)'\)  file1

ключ -H дает то что греп будет печатать на экране не только строчку
в которой найдено совпаедение но и имя файла где он 
нашел входждение. это круто

ключ -E нам дает то что можно через "|" указывать паттерны в режиме OR
тоесть паттерн1 OR паттерн2 OR паттерн2 выглядит так
    $ grep pat1 | pat2 | pat3
    
также я использую () для того чтобы указывать отдельные группы.
cскобки работают только вместе с ключом -E.
также скобки друг  с другом соединяются через +
тоесть 
    $ echo -e "ab1\n a2" | grep -E "(a)+(b)"
    ab1
либо
    $ echo -e "ab1\n a2" | grep -E \(a\)+\(b\)
    ab1

нужно экранировать скобки так как в бащ скобка это спецсимвол. а нам
надо передать скобку как аргумент внутрь внешней прогарммы grep

переходим к основному примеру

    $ grep -H  -E \($'(\t)'\)+\(13\|32\)+\($'(\t)'\)  file1

мы в нем ищем патттер "TAB"+"13 или 32"+"TAB"
значит отдельные части уравнения мы обозначаем через ()+
применив экранирование
а OR мы обозначаем через "|" тоже его нужно экранировать

сделаем чуть красивее

    $ grep -H  -E   \($'(\t)'\)+"(13|32)"+\($'(\t)'\) errno-base.h 
    errno-base.h:#define	EACCES		13	/* Permission denied */
    errno-base.h:#define	EPIPE		32	/* Broken pipe */

чтобы грепу подсунут TAB мы юзаем $'(\t)' потому что с ключом -E он не понимает \n
он понимает \n тлоько с ключом -P который взаимоисключащий с -E а  -P не понимает пайп 
 в качестве OR так что мы юзаем -E ради пайпа в качестве OR а TAB подсовывыаем
 через $'(\t)' тоесть через то что сам баш дешфирует это в нужный байт перед тем
 как вызыват греп и подставить его сам в качестве аргумента.
 
мы неможем использовать "($'(\t)')" потому что двойные кавычки убивают $'(\t)'
поэтому мы юзаем слэши \($'(\t)'\)
вот такой пиздец

кстати вот все ошибки котоыре указаны как код возврата во всех сисколлах
это все в итоге ошибки прописанные в *errno*.h и падают они в errno. тоест 
все сисколлы они обращаются к функциоаналу *errno*.h а не свой функционал пилят
для этого.

итак как в итоге работает ситуция с записью в пайп.
мы открыли в программе пайп. получиил дескриптор файла. теперь  используя 
этот дескриптор можем туда писать. писать туда можно как в обычный файл
используя сисколл\glibc функцию write.
мы пишем используя write и дескриптор пайпа.

при вызовее write ос переключается из юзер режима в режим ядра.
в режиме ядра ос перед тем как приянять байты и засунуть их в буфер в памяти
отвечающий за пайп ядро проверяет есть ли процесс у которго пайп открыт на чтение.
если такого нет то принимать данные нет смысла и ядро шлет процессу этому который 
пишет сигнал SIGPIPE. шедулер перед тем как засунуть код процесса на цпу увидит 
что у процсса есть сигнал. он вызывет хендлер этого сигнала. если процесс не имеет 
своего хендлера то ос подсунет дефолтовый свой и он просто убьет процесс.
а если у прцесса есть свой хенлер то запустит его. если хендлер не убьет процесс
то прсто напросто продолжится выполнения дальнейших по тексту команд программы.
у программы есть два вараинта. если программа после вызова write анализирует 
код вовзрата errno то в errno будет код ошибки что пошло нетак при вызове write
там будет какая то цифра. и подчекрну что код ошибки вовзрвата функции это не SIGPIPE
SIGPIPE это сигнал который прилетает. он не имеет ничегообщего с кодов возврата 
сисколла. так вот в errno будет лежат число 32. если код программы анализирует errno
и запргарммирован убит процесс если errno неравено нулю то окей.  а если он не анализирует
или не убивает при условии что errno <>0 то программа просто напросто продолжит работать
дальше. и это зависит чисто от нас от програмиста этой программы. так что при желании
ни SIGPIPE ни errno=32 не остановят программ от дальнейшего исполенния. ну типа 
произошли ошибки и ладно.
по поводу дешировации ошибки errno=32 как это делать. внутри кода программы
можно вот такое вызывать

    perror("write()");
	printf ("Error no is : %d\n", errno);
    printf("Error description is : %s\n",strerror(errno));

что на экарне даст

    write(): Broken pipe    
    Error no is : 32
    Error description is : Broken pipe
    
а если мы хотим подробное описание
нам найдо найти для 32 его описание в формет спец слова.

это описание хранися в /usr/src/*errno*

ищем вот так

    $ find . -name "*errno*.h" -exec  grep -H  -E \($'(\t)'\)+\(32\)+\($'(\t)'\)   '{}' ';'
    ./errno-base.h:#define	EPIPE		32	/* Broken pipe */

находим EPIPE.
теперь мы смотрим а какой сисколл был использован котоыйрый вызывал этот errno
в нашем случае это write.
тогда идем в man
    $ man 2 write 
и там ищем EPIPE
и читаем

    EPIPE  fd is connected to a pipe or socket whose reading end is closed.  
    When this happens the writing process will also receive a SIGPIPE  signal.   
    (Thus, the write return value is seen only if the program catches, 
    blocks or ignores this signal.)

таким макаром мы детально понимаем что значит полученная ошибка 32.

ура товарищи...

еще раз возвращаюсь к тому как работает tail -n +1 вкупе с пайпом

    $ echo "1" | tail -n +1
    
во первых как работает пайп в купе с башем. все что делает баш 
если видит пайп это запускает две команды. у которых увязывает вместе их
stdin stdout
    stdout (proc1) ----> stdin (proc2)
далее баш вобщем то забывает про эти процессы напрочь.
каждый из процессов должен закончить свою жизнь самостоятельно.
если какйото из процессов сдох то баш аобсолбтно ничего неделает
с дурими процессами в цепочке. 
поэтому кджый процесс должен закочить свою жизнь соамтоятельно.
либо его должна убить сама ОС. но не баш.
это дает то что если слева скажем идет чтение огромного файл 

    $ cat big_file | tail -n +1

то это работает так. cat прочитает весь файл целиком а tail его засосет целиком,
после этого cat сдохнет. но и башу и ос и tail на это насрать. tail будет 
работать столько сколько захочем и ему неважно что какйото друой процесс сдох.
ну и сам тейл с данной опцией что делает. он печатает на stdout 
весь файл что получил начиная с 1-ой строки сверху. 
если я вот так дам команду

    $ cat big_file | tail -n +10
    
то тейл напечатает весь файл начиная с 10-ой строки сверху

тоесть если классчиеский tail -n2 он печатает файл с конца последние две строки.
то tail -n +10 печатает файл сначала файла начиная с такой то строки.

соовтесвтенно в обоих случая и когда мы печатаем сверху и когда мы печатаем
нижние строки чтобы тейл мог отраотать ему нужно в себя употребить весь файл 
целиком
доказываю, берем файл размером 1,59GiB

    $ cat 17830.txt | pv | tail -n2 1>/dev/null
    1,59GiB 0:00:01 [ 932MiB/s] 

    $ cat 17830.txt | pv | tail -n +2>/dev/null
    1,59GiB 0:00:01 [1,04GiB/s]
    

    
так. ну если процессы в пайпе неубиваются башем а работают 
настколько долго насколько они этого хотят
то возникает вопрос а как тогда заканчываиет свою работу вот эта цепочка

    $ yes | head -n5
    
тоесть head читает 5 линий и убивает себя. а yes то должен работать бесконечно
однако это нетак. так вот yes убивает принудительно сама ос. вот как yes 
заканвивает свою работу.
когда head исчезает то при попытке записать порцию данных в stdout/pipe 
со стоороны yes ос видит что больше нет процессов котыре имеют этот пайп
откртым на чтение. и тогда ос ппосылвет в yes сигнал SIGPIPE.
далее либо хендлер yes а если его нет то хендлер дефолтовый ОС видя 
это сионал убивает процесс yes. 
а если мы вот такую возьмем цепочку

    $ echo -e "1\n 2\n 3\n" | xargs -n1 -L1 echo | cat -; echo "${PIPESTATUS[*]}"
    1
    2
    3
    0 0 0


понятно что echo закончит свою жизнь само.
непонятно на каком основании xargs и cat понимаю что больше данных 
им на stdin никогда не поступит. 

можно легко проверть что при смерти процесса сслева от пайп или спрва
от пайп баш и ос нихрена неделает

    $ sleep 120 | sleep 130

если  я рукамт убтю правый процесс то легко проверить 
что процесс слева прдолжает жить.
и наоброт если убью первым процесс справ то процесс продождает жить.

вопрос 
как в этих примерах
программа xargs или cat
узнает что больше данных из stdin не прилетит?

    $ echo "1" | xargs ....
либо
    $ echo "1" | cat 

тут я обнаружил очередной фундаментальный огромный кусок под названием EOF и EOT.
End Of File, End Of Transfer.

на основе этих хреней программы которые читают из stdin определяют что больше 
ничего не прилетит. и убивают себя сами.

значит программа которая читает из файла пусть это будет stdin 
например можно читать из stdin через getchar

$ cat 99.c
#include <stdio.h>
#include <errno.h> // for the definition of errno
#include <stdlib.h> // for exit()
int main(void)
{
    int c;
    c = getchar();
    putchar(c);
    printf ("\n");
    printf("feof =  %d\n",feof(stdin));
    printf("ferror=  %d\n",ferror(stdin));

    exit (0);

}


как это работает на практике. мы запускаем прогу.
она ждет от нас ввода кнопок в терминале.
мы вводим символы

    $ 123

но пока мы их вводим в программу ничего не улетает. 
только после того как мы нажмем Enter символ реально улетают в программу.
поток 123 улетает в stdin программы но по факту из потока будет прочитан 
только один байт один символ. тоест "1" все остальное исчезнет вникуда.
тоесть 

    int c;
    c = getchar();
    
позводяет нам считать только один символ.

    $ echo -n "123" | ./99.exe
    1
    feof =  0
    ferror=  0

пока все окей.
но что если мы хотим считать много символов например 2.
модифицирую программу

$ cat 99.c
#include <stdio.h>
#include <errno.h> // for the definition of errno
#include <stdlib.h> // for exit()
int main(void)
{

    int i;

 for (i = 1; i < 3; ++i)
 {
    int c;
    c = getchar();
    putchar(c);
    printf ("\n");
    printf("feof =  %d\n",feof(stdin));
    printf("ferror=  %d\n",ferror(stdin));
 }
    exit (0);

}


натравливаю на нее файл из 2-ух символов

$ echo -n "12" | ./99.exe
1
feof =  0
ferror=  0
2
feof =  0
ferror=  0

тоже все окей.

а теперь натравливаю файл из 1-го символа

$ echo -n "1" | ./99.exe
1
feof =  0
ferror=  0

�
feof =  1
ferror=  0

и мы получаем интересный момент.
первый шаг цикла считал символ "1"
и на выходе напечатало

1
feof =  0
ferror=  0

на втором шаге цикла читать уже было нечего
потому что файл закончился.
и тут происходит магия. тут участвует в процессе чтения
целая матрешка - сисколл ядра, libc, наша команда.

ОС код ядра при попытке 
считать следущий символ в файле понимает както нам неважно как 
что файл достигнул конца и сообщает вышестоящей функции libc 
о том что файл достиг конца. libc делает так что функция getchar 
выдает как результат специальный байт называется EOF. 
как он конкретно выглядит в виде байта завиисит от разного
но как я понял в линуксе этот байт выглядит как -1 
поскольку байтов отрицателных небывает то это некая форма представления
отрицательных чисел на компе в форме байта. 

в коде проверить что getchar нам вернул EOF можно через 
спец конструкцию

int c;
c = getchar;
if ( c == EOF) {
        printf("end-of-file reached\n");
        exit(0);
    }

тоесть нам даже ненадо знать как конктено выглядит этот EOF
просто подставляет EOF а C сам уже знает о чем речь.


более того помимо возврата в getchar EOF
у нас функция feof принимает значение 1
как доп фактор доказать что мы достигли конца файла
что собсвтенно видно из вывода на экран

    feof =  1

в программе можно проверять этот факт вот так

if (feof(stdin)) {
        printf("end-of-file reached\n");
        exit(0);
    }


из вывода в hex портянки

$ echo -n "1" | ./99.exe  | od -t x1
0000000 31 0a 66 65 6f 66 20 3d 20 20 30 0a 66 65 72 72
0000020 6f 72 3d 20 20 30 0a ff 0a 66 65 6f 66 20 3d 20
0000040 20 31 0a 66 65 72 72 6f 72 3d 20 20 30 0a
0000056


я делаю вывод что этот байт имеет вид 0xff но это неточно.


таким образом еще раз. для того чтобы прочиатаь из файл
мы испольуем C программу. она опирается на libc. 
а та опирается на системны вызовы ядра.

когда мы в программе просит прочитать из файла например через
getchar() то эта хрень обращается к libc а та к сисколлу.
сисколл это ядерный код и он видит как то там нам неавжно как
что файл закончился. и он наверх об этом сигнализирует. 
в итоге  в getchar возвращается некий спецбайт EOF
как он выглядит нам неважно потому что в программе мы проверяем
его наличие через EOF

c = getchar;
if ( c == EOF) {
        printf("end-of-file reached\n");
        exit(0);
    }

в дополнеие к этому также функция feof(stdin) принимает значение 1
что нам тоже докаызвает что мы достигли конца файла.

тогда покываю программу которая это все ловит

$ cat 100.c
#include <stdio.h>
#include <errno.h> // for the definition of errno
#include <stdlib.h> // for exit()
int main(void)
{
    int c;
    while ((c = getchar()) != EOF)
       putchar(c);

   printf ("мы словили EOF!\n");

    if (feof(stdin)) {
        printf("feof = %d\n", feof(stdin));
        exit(0);
    }
    else if (ferror(stdin)) {
        printf("An error occurred. errno set to %d\n", errno);
        perror("Human readable explanation");
        exit(1);
    }
    else {
        printf("This should never happen...\n");
        exit('?');
    }
}

    $ gcc -o 100.exe 100.c
    $ echo "123" | ./100.exe
    123
    мы словили EOF!
    feof = 1

если программа ждет ввода с stdin с терминала.
то чтобы сообщить ядру что мы достигли конца файла нужно тыкнуть Ctrl+D
тогда драйвер терминала сообщит ядру что ввод с терминала достиг конца файла.

если у нас stdin смотрит в пайп то насколько я понимаю ядро понимает что 
достигнут конец файла если в нет ни одного процесса который бы писал в пайп 
и что буфер пайпа пуст. тогда ядро сообщает в libc что файл закончился.
тоесть

    $ echo "123" | cat
    
у нас echo высрало в пайп "123" и сдохло. пайп как  я понимаю 
это буфер в памяти ядра какогоо то размера.
и теперь 123 лежит в этом буфере. 
cat читает из пайпа кусками. выбирает оттуда 123. 
и шлет новый запрос на чтение данных. 
ядро которые обрабатывает это запрос непосредственно видит что 
буфер пуст. это значит что либо программа которая записывает в пайп на даннйы
момент пока что ничего новоого не высрала в пайп. но тогда нужно наличие такой программы
висящей в памяти и имеющей отрытым на запис этот пайп. если это так то запрос cat 
просто откладывается в S-state до поступления данных в буфер пайпа.
а если в памяти нет ни одной программы которая имеет открытым пайп на запись и буфер 
пайпа повторю пуст то ядро понимает что в пайп уже никогда данные не поступят.и что 
это конец файла. и оно сигнализирует к libc что конец файла.

я так понимаю этот ад.

таким образом более менее разгадаа загадка как программы соедиенные  пайп
понимают что им никто уже данные не нальет и надо заканчиывать свой процесс.






про awk
пример печаатает
последние 2 строки из файла
    $ awk -v N=2 'NR<=N'
    


    
    
еще раз расскажу про  ${PIPESTATUS[*]} 
${PIPESTATUS[*]}
содержит коды возврата всех процессов в цепочке пайпов.
если код возврата команды ненулеовй это еще незначит что у нее сломался пайп.

$ sleep 130 | sleep 140 | sleep 150; echo "${PIPESTATUS[@]}"
Hangup
129 129 129

$ kill -1  9088
$ kill -1  9089
$ kill -1  9090

поскольку баш нетрогает процессы в цепочке если у нас один из процессов
упал то нужно убить все три поцесса прежде чем пайп развалится

код возврата 129-128=1 ровно сигнал 1  я им слал.
ошибка 129 совершенно не значит что была проблема с пайпом она значит что в процесс
прилетел сигнал 1


далее
$ yes | head -n 100 | xargs -n1 echo | tail -n +1 | head -n2; echo "${PIPESTATUS[@]}"
y
y
141 0 0 0 0
не все хендлеры 13 сигнала чтото пишут на терминал.
часто ничего не пишут


$ yes | head -n 100 | xargs -n1 echo  | head -n2; echo "${PIPESTATUS[@]}"
y
y
xargs: echo: terminated by signal 13
141 0 125 0
а здесь более правый пайп завершил с ошибкой


прикол в том что если код 0 это успешный выход.
все остальное неуспешный. и что значит конкретно каджый код выше 1 по 125 
опредлелется программстом программы. закралывая его в фукцию обработки.
поэтому что значит код 128 для xargs это надо искать в описании xargs
а вот если код >128 то обычно это значит что в прцесс прилетел сигнал N
высиляется по формуле код возврата = 128+N.


и вот что про ext satus написано на сайте gnu
The exit status of an executed command is the value returned by the waitpid
system call or equivalent function. Exit statuses fall between 0 and 255, 
though, as explained below, the shell may use values above 125 specially. 
Exit statuses from shell builtins and compound commands are also limited 
to this range. Under certain circumstances, the shell will use special 
values to indicate specific failure modes.
For the shell’s purposes, a command which exits with a zero exit status has succeeded
. A non-zero exit status indicates failure. This seemingly 
counter-intuitive scheme is used so there is one well-defined way
to indicate success and a variety of ways to indicate various failure
modes. When a command terminates on a fatal signal whose number is N, Bash
uses the value 128+N as the exit status.
If a command is not found, the child process created to execute it returns a
status of 127. If a command is found but is not executable, the return status is 126.
If a command fails because of an error during expansion or redirection, 
the exit status is greater than zero.
The exit status is used by the Bash conditional commands
(see Conditional Constructs) and some of the list
constructs (see Lists of Commands).
All of the Bash builtins return an exit status of zero if they succeed
and a non-zero status on failure, so they may be used by the conditional
and list constructs. All builtins return an exit status of 2 to
indicate incorrect usage, generally invalid options or missing arguments.
The exit status of the last command is available in the special 
parameter $? (see Special Parameters).

так что 141 это 128+13 значит сигнал 13 а 13 это  SIGPIPE ( kill -L )
это значит этот процесс хотел записат в пайп но не было процесса который бы открыл 
этот пайп на чтение. ядро это заметило и послало процессу сигнал 13. и дефолтовый хендлоер убил процесс
который хотел пиать в пайп

вот я запуисил процесс
    $ yes | cat - 1>/dev/null; echo "${PIPESTATUS[*]}"
и с терминала дургого убил cat
    $ kill -1 $pid_cat

и получил на первом терминале
Hangup
141 129
причем hangup это мне напиал cat когда поулчил этот синал

вот еще пример
$ cat 0< /dev/zero 1>/dev/null; echo $?
Hangup
129

$ yes | xargs -n1 echo | cat - 1>/dev/null; echo "${PIPESTATUS[*]}"
xargs: echo: terminated by signal 13
Hangup
141 125 129

я послал kill -1 в cat
в итоге cat его обработчки сигналов мне написал на экране Hangup
xargs его обработчик сигналов мне написал xargs: echo: terminated by signal 13
yes мне ничего не написал

а это их коды возврата
141 125 129

yes получаетс получил сигнал 13
xargs сигнал 13 судя по его сообщению но код возврата выдал 125
cat полувил сишгнал 1

таикм иобарзом я убил cat. после этог xargs не смог писать в пайп и ядро его убило.
вслед за этим не смог писать yes и его тоже убило ядро


я походу понял почему я раньше эту ошибку не встречал
$ cat 17830.txt | grep a 1>/dev/null; echo "${PIPESTATUS[@]}"
0 0
потому что раньше у меня были такие команды что комада которая 
справа от пайпа она всегда ждет бесконечно
данные от команды слева. и в цепочке первой заканчивала работу всегда
команда слева. и только потом комнда 
справа от пайпа. и поэтому немогло быть ситуации при которой 
возникает сигнал 13. тоесть процесс 
пишет в пайп но его никто не читает. 





далее 
    set -o pipefail 
    set +o pipefail
    это о чем?
вообще этот билтин баша
это вещь в себе.
например если мы используем -o .... то это АКТИВИРУЕТ опцию
       а если мы используем +o .... то это ОТКЛЮЧАЕТ  опцию
то все наоборот , антиинтуитивно.

по дефолту эта хрень отключена. 
значит если мы ее активируем  
    $ set -o pipefail 
то даст вот что 

pipefail
            If  set,  the  return value of a pipeline is the value of
            the last (rightmost) command to exit with a non-zero status, 
            or zero if all commands in the pipeline exit successfully.  
            This option is disabled by default.

значит по дефолту когда эта опция выключена то если у нас есть цепочка команда
с пайпами то если мы после этого захотим посмотреть код возврата то он будет 
содержать код возврата последней команды в цепочке.
а если мы активируем эту опцию то код возврата будет содержать последний код 
возврата комады в цеопчке который был неравен нулю. таким образом активация 
этой оции позволяет вскрыть вытащить наружу проблемы с в пайп цепочке.
сразу скажу что эта опция никоим образом не влияет на переменную "${PEIPSTATUS[*]}"
эта переменная содержит  в себе все коды возврата всех команда из цепочки
вне зависимости от усноавлена или нет опция pipefail.
кстати как узнать установлена ли опция pipefail или нет. вот как
    $ set -o | grep pipefail
итак показываю.

    $ set -o | grep pipefail
    pipefail       	off

    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    xargs: echo: terminated by signal 13
    141 125 0

    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "$?"
    xargs: echo: terminated by signal 13
    0

таким образом видно что при отключенной опции у нас $?=0 тоесть равен
коду возврата последней команды в цепочке

активируем опцию

    $ set -o pipefail
    $ set -o | grep pipefail
    pipefail       	on


    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    xargs: echo: terminated by signal 13
    141 125 0

    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "$?"
    xargs: echo: terminated by signal 13
    125

видно что при активиированной опции код возврата $?=125 равен первому справа
ненулевому коду возврата из цепочки

еще интересный шокирующий момент. если мы хотим посмтреть echo "${PIPESTATUS[*]}"
то это надо делать прям сразу после цепочки команд. если прошляпить хотя бы
на одну команду. то она протухает. показываю.

тоесть вот я смотрю ее сразу
    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo "${PIPESTATUS[*]}"
    141 125 0

а вот я смотрю эту переменную но чуть позже
    $ yes | xargs -n1 -L1 echo  | head -n5 1>/dev/null; echo $?; echo "${PIPESTATUS[*]}"
    125
    0

как говорится почуствуй разницу между 
    141 125 0
и
    0
    
в этом тоже конечно засада.

если у нас скрипт. то надо еще подумать активировать ли pipefail
или нет. потому что не всегда плохой код возврата это плохо
пример
    $ yes  | xargs -n1 -L1 echo | head -n 5 1>/dev/null; echo "${PIPESTATUS[*]}"
    141 125 0

если мы активируем pipefail то $? после этой цепочки будет 125.
но на самом деле проблемы в этом пайпе нет. просто head сделал свое дело
и умер раньше чем команды слева. это норм. как уже разбирал выше.

еще раз о set
если мы хотим посмотреть чему равны все опции то надо set -o

    $ set -o
    allexport      	off
    braceexpand    	on
    emacs          	on
    errexit        	off
    errtrace       	off
    functrace      	off
    hashall        	on
    histexpand     	on
    history        	on
    ignoreeof      	off
    interactive-comments	on
    keyword        	off
    ...
    
а set +o нам выдаст список команд которые можно вбить 
в шелл чтобы привести эти опции к этому виду

    $ set +o
    set +o allexport
    set -o braceexpand
    set -o emacs
    set +o errexit
    set +o errtrace
    set +o functrace
    set -o hashall
    set -o histexpand
    set -o history
    set +o ignoreeof
    set -o interactive-comments
    set +o keyword
    ...
    

    
    
еще раз вовзращаюс к разбору примеров из man find
этот пример ищет в папке /tmp файл с именем "core"
тип файла обычный
и печатает на экране имя файла с добавлением Enter в конце файла каждого
едиснтвенное что я не понял это смысл -print 
ибо имя файла оно и без этой опции печаается 
    $ find /tmp -name core -type f -print
ее аналог
    $ find /tmp -name core -type f


    
еще пример
ищет в папке /tmp
имя файла core
тип файла обычный
печатает имя файла и добавляет в конец байт 0x00
это делается если в имени файла есть символ Enter
тогда можно передать через pipe на xargs и там тоже обьяснить что символ
разделения названий файло тоже 0x00
    $ find /tmp -name core -type f -print0
если дбавить xargs
    $ find /tmp -name core -type f -print0 | xargs -o echo 

    
    
еще пример
ищем в папке "."
тип файла обычный 
и  с каждым таким файлом печатаать его тип 
    $ find . -type f -exec file '{}' \;

    
еще пример
найти файл у которого есть suid бит и заппсать имя этого файла
в файл /root/suid.txt в формате "permissions  user  имя_файла"
либо найти файл размером 100M+ в файл /root/big.txt  в формате
"размер файла  имя_файла",
причем размер файла печатается в колонке 10 символов
с выравниванием по левому краю а печать имя_файла 
идет с 11 символа
    $ find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
       \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)



еще пример
ищет в папке $HOME
файлы которые были изменены за последние 24 часа
    $ find $HOME -mtime 0
       
на счет -mtime, -atime, -ctime, -mmin
m означает modification
c означает creation
a означает acccess
тоесть проверяется то или иное время в свойствах файла

*time означает время в единицах сутки. тоесть -ctime 1 это время 1 сутки
*min означает минуты. -mmin 10 означает 10 минут.

если число стоит без значков +- то это означает точное совпадение
если стоит -10 то это означает промежуток [сейчас-10; сейчас]
а если стоит +10 это промежуток [-бесконечность; сейчас-10]

тоесть -mmin -10 означает файл был модифицирован в течение последних 10 минут. в этом промеж
утке
-mmin +10 означает что файл был модифицирован более раньше чем 10 минут назад. и еще
более раньше. 

-mmin 10 означает что файл был модифицирован точно 10 минут назад

аргумент 0 имеет особое значение

-mmin +0 означает что файл был раньше чем 0 минут назад или более раньше.
тоесть по факту это любой файл. 


    $ ls -l -t
    15:18 4.txt
    13:40 1.txt
    
    $ find . -mmin -4
    ./4.txt
тоесть мы ищем файл который был измнеен в течение между щас и 4 минуты назад.
    время 15:21
получается это время  (15:17, 15:21) внутри этого интервала лежит 4.txt (15:18)


возвращаюсь к исходному пример
ищется файлы которые были модифицированы ровно за последние сутки    
    $ find $HOME -mtime 0

-amin
-atime
-cmin
-ctime
-mmin
-mtime


a - время доступа к файлу
m - время изменения содержимого  файла
c - время  изменения метаданных файла. тоесть 
инода. тоесть пермишнсы у файла. владелец итп

что я не понимаю. это то что если я захожу и меняю содержимое 
файла причем просто символ один меняю на другой. тоесть метаданные
не меняются то все равно меняется и mtime и ctime. что за хуйня
я не понимаю почему.



команда 
    $ touch file
она меняет acccess time и modify time 
и еще и  change time 
вобщем она по дефолту все меняет


будем работать на примере ctime. это время изменнеия метаданных у файла.

    $ ls -ltc --time-style="+%d %b %H:%M" | awk '{print $6 "  "$7"  " $8"  " $9}'
    13  дек  17:45  01.bash
    25  июн  04:09  temp
    20  июн  23:38  04.bash
    16  июн  19:41  LC_CTYPE=ru_RU.utf8
    16  июн  18:43  06.txt
    16  июн  17:32  03.bash
    16  июн  15:58  04.txt
    16  июн  15:56  05.txt
    16  июн  15:09  03.txt
    16  июн  14:38  root
    16  июн  14:02  02.bash

    $ date "+%d %b %H:%M"
    13 дек 18:16

    $ find . -type f -cmin 32 -printf "%-10f %Cd %Cb %CH:%CM \n"
    01.bash    13 дек 17:45 

-cmin 32 означает что мы ищем файл у которого 
ctime равен (текущее время - ctime файла) выраженное в минутах должно быть 32 целых
минуты и еще может быть сколько то секунд миллисекунд итд это мы уже отбрасываем.
главное что промежуток должен составлять полноценных 32 минуты.
тоесть грубо говоря -cmin 32 означает найди файл который был модифицирован относиельно
ctime 32 минуты назад. но это должны быть полные минуты. тоесть с учетом секунд.
поскольку время записывается в свойствах файла с точностью до условно говоря миллисекунд
или микросекунд но нам самое главное что с точностью до секунд точно и то что
отсчет идет от текущего момента времени это означает что нам придется подбирать cmin
в пределах +-1 минута. например у нас файл создан в 17ч:01м:56с  а сейчас время 17ч:02м:20с
отнимаем одно от другого это будет 24секунды. это значит что  у нас в промежутке нет 
ни одной полноценной минуты. другой случай файл создан в 17ч:01м:01с 
значит промежуто равен 1м 15с или одна полноценная минута. как мы видим на листинге ls
время показано с точностью до минуты. поэтому оба наших файла буду показаны как
17ч01м но только один из них попадет в поиск find по критерию найди файл модифицированный 
за последнюю минуту. поэтому я гооврю о том что параметр -cmin он будет гулять туда 
сюда в пределах 1 минуты.
примеры

итак имеем вот такой файл
    13  дек  17:45  01.bash
сейчас время
    $ date "+%d %b %H:%M"
    13 дек 18:28
я ожидаю его найти как -cmin 43
    $ find . -type f -cmin 43 -printf "%-10f %Cd %Cb %CH:%CM \n"
    01.bash    13 дек 17:45 
сработало

еще ест вот такой файл
    13  дек  17:48  1.txt
текущее время 13 дек 18:30
я ожидаю  его найти как -cmin 42

    $ find . -type f -cmin 42 -printf "%-10f %Cd %Cb %CH:%CM \n"
    1.txt      13 дек 17:48 

сработало

если мы модифицируем 
    -cmin 42 
как 
    -cmin -42 
это будет значить что мы ищем файлы у которых ctime лежит в интервале
    (текущее время-42;текущее время)
а если заменить на 
    -cmin +42 
это будет значить что мы ищем файлы у которых ctime лежит в интервале
    (-бесконечность ;текущее время-42)

отдьено скажу про 
    -cmin 0
это значит что у файл ctime такой что промежуток времени между его ctime
и текущим мометом такой что он меньше чем одна полная минута. тоесть если мы возьмем
этот промежтоу времени выразим его в секундах и поделим на 60 то в целой части от деления
будет 0. и будет какйото остаток но мы его всегда отбрасываем.
тоесть -cmin 0 это такой файл который был модифицирован меньше чем минуту назад
-cmin 1 означает что файл был модифицирован одну полную минуту назад.
-cmin -1 означает что файл был модифицирован в интервале одну полную минуту назад или меньше
-cmin +1 означае что файл был модифицироован позже чем одну полную минуту назад

-сtime такойже смысл как cmin но он меряется промежутком в 24часа. тоесть это одни 
полные сутки. 
-ctime 0 это такой файл который был модифицирован меньше чем одни полные сутки назад
-ctime 1 означает что файл был модифицирован одни полные сутки назад.
-ctime -1 означает что файл был модифицирован в интервале одни полные сутки назад или меньше
-ctime +1 означае что файл был модифицироован позже чем одни полные сутки назад
    
соотвественно через -ctime +10 ищется какоето супер старье
через -cmin -10 ищется наоборот чтот очень молодое

имеем вот такие файлы

$ ls -ltc --time-style="+%d %b %H:%M" | awk '{print $6 "  "$7"  " $8"  " $9}'
      
13  дек  17:48  1.txt
10  дек  23:20  3.txt
10  дек  23:20  2.txt

я хочу найти все файлы в течеие последних 3-ех суток
    $ date "+%d %b %H:%M"
    13 дек 18:27

    $ find . -type f -ctime  -3 -printf "%-10f %Cd %Cb %CH:%CM \n"
    1.txt      13 дек 17:48 
    3.txt      10 дек 23:20 
    2.txt      10 дек 23:20 

хочу найти файлы котрые
          файлы  старее чем  -1 сутки
но при этом 
          файл моложе чем -3 сутки
        
тогда
    $ find . -type f -ctime +1 \! -ctime +3 -printf "%-10f %Cd %Cb %CH:%CM \n"
    3.txt      10 дек 23:20 
    2.txt      10 дек 23:20
    

конструкция 
    \! -ctime +3
означает промежуток времени который мы исключаем из рассмотрения
по умолчанию между  всеми аргументами в find незримо стоит логический AND
тоест должны выопнтяся одновмренно все условия поиска
причем надо экранировать ! чтобы баш не расстривал ! как спесимвол

найти файлы с ctime моложе чем 1 сутки (-ctime 0)

    $ date "+%d %b %H:%M"
    13 дек 18:27

    $ find ~ -type f -ctime 0 -printf "%-10.5f %Cd %Cb %CH:%CM \n" 2>/dev/null | head -n4
    4bae8      13 дек 03:49 
    471f2      13 дек 13:06 
    84b66      13 дек 06:27 


найти файлы с ctime моложе чем 1 минута (-cmin 0)
    $ echo "текущее время  = $(date '+%d %b %H:%M')"; find ~ -type f -cmin 0 -printf "%h/%-8.8f %Cd %Cb %CH:%CM \n" 2>/dev/null  | head -n3
    текущее время  = 13 дек 18:57
    /home/vasya/.cache/lxsession/LXDE/run.log  13 дек 18:57 
    /home/vasya/.psensor/log      13 дек 18:57 
    /home/vasya/.config/google-chrome/Default/Preferen 13 дек 18:57 

еще раз про разницу
    -cmin 0  найти все файлы у которых ctime  моложе чем одна полная минута
    -cmin 1  найти все файлы у которых ctime одна полная минута или меньше
    если текущее время t, а ctime это знание у файла то 
    -cmin 0 такой что    (t-ctime) < 1min
    -cmin 1 такой что    (t-ctime) <= 1min
    где 1min это полная минута то есть 60 секунд

возвращаюсь  к примеру
найти все файлы которые были модифицированы (mtime) меньше чем 24 часа от текущего
момента
    $ find $HOME -mtime 0

далее найти файл который executable (для текущего юзера)
    $ find . -executable -type f
    ./1.txt

проверяем 
    $ find . -type f -printf "%f   "  -exec  stat --format="%A" '{}'   ';'
    1.txt   -rwxrwxr-x
    3.txt   -rw-rw-r--
    2.txt   -rw-rw-r--

проверка что файл readable (для текущего юзера)
    $ find . -readable -type f
    ./1.txt
    ./3.txt
    ./2.txt


далее
найти файлы и папки  которые "x" но не "r" для текущего юзера
что это значит на практике не помню. особенно для папок    
    $ find /sbin /usr/sbin -executable \! -readable -print

тоже самое но только для файлов обычных
    $ find ~ -executable \! -readable  -type f -printf "%f   "   -exec stat --format="%A" '{}' ';' 2>/dev/null
либо
    $ find ~ -executable ! -readable  -type f -printf "%f   "   -exec stat --format="%A" '{}' ';' 2>/dev/null
    sudo   ---s--x--x
    sudoreplay   ---x--x--x
    sudo   ---s--x--x
    sudoreplay   ---x--x--x
    sudo   ---s--x--x
тоесть работает и  с экранированием "!" и без его экранирования.

дальше
ищет файлы которых пермишнс в точности 644
    $ find . -perm 664
    
ищет файлы у которых пермишнс такие что установленные биты в маске 664 = 110110100
также установлены и в пермишнс файлов. 
что касается неустанолвенных битов в маске если они установлены  в файле 
то нам похеру
    $ find . -perm -664
    
маска пермишнс 664 = 110110100
нам надо чтобы в файле в пермишнс был устанолвен хотя бы один бит из тех что
есть  в маске тогда нам такой файл уже подходит
    $ find . -perm /664
    
    
    
далее
       $ find . -perm /220
       $ find . -perm /u+w,g+w
       $ find . -perm /u=w,g=w
все три команды одинаковые. только в разной форме записаны.
файлы подходят если либо юзер может писать либо other может писать. 


следущий пример
    $ find . -perm -220
    $ find . -perm -g+w,u+w

так на счет пермишнсов.
перимишнсы описывают право на  чтение (r) на запись (w) на исполнение (x)
для трех групп клиентов - user, group, other в итоге это можно 
схематично обозначить как 9 символов

    u   g   o
   --- --- ---

полуается каждый символ можно закодировать через 1 бит. получается
вся эта хрень кодируется через 9 бит. 
пример

    u   g    o
   -wx rwx r--

что обоначает что user может (r,x) 
группа может (r,w,x)
other может (r)

в битах это выглядит как
011-111-100

а теперь вот что сделаем.
помотрим как этот байт выглядит в восьмеричной системе
счисления.
в левом столбике бинарный вид
в правом столбике oct вид
 u   g   o     ugo      u   g   o
000 000 001 |  001  |  --- --- --x
000 001 001 |  011  |  --- --x --x
001 001 001 |  111  |  --x --x --x

 u   g   o     ugo     u   g   o
000 000 010 |  002  | --- --- -w-
000 010 010 |  022  | --- -w- -w- 
010 010 010 |  222  | -w- -w- -w-

 u   g   o     ugo     u   g   o
000 000 100 |  004  | --- --- r--
000 100 100 |  044  | --- r-- r-- 
100 100 100 |  444  | r-- r-- r--


отсюда виден очень удобный закон. чтобы нам легко 
понимать как нам быстро преобразовать в голове пермишнсы из битового
вида в oct. это можно сделтаь очень бысро. а линукс понимает если 
ему мы подсовыаем маску в oct виде.
для этого  мы вначале понимаем куда надо изменит пермишн - юзеру, группе , или other.
пишем на бумаге три цифры они будутотвечать за число в oct виде

    000

левая цифра это цифра котрая отвечает за левые три бита бинарного виде и ответчает
за пермишнсы для юзера.
средняя цифра это цифра котоая отвечает за средне три бита бинарного вида и 
ответчает за пермишнсы для группы
правая цифра отвечает за правые три бита и отвечает за пермишнсы для other
если мы хотим дать праов на выполнение то надо туда прибавить единицу
если хотми дать право на запись то прибавить двойку. если хотим дать право 
на чтение то добавить четверку. пример

хотим  
     u   g   o
    rw- rw- rw-
            
береем
   000
   
и делаем вот так
   000 => (4+2)(4+2)(4+2) => 666
   
доказательство 

    $ a="110110110"; echo -n "$a   ";  echo " obase=8; ibase=2; $a" | bc
    110110110   666

все совпало


возвращаюсь к примеру

    $ find . -perm -220
    $ find . -perm -g+w,u+w

       u   g   o
220 = -w- -w- --- 

тоесть u=w, g=w
сравниваем  с

    $ find . -perm -g+w,u+w

видим что это одно и тоже.
потому что у find
    g+w это одно и тоже g=w
    u+w это одно и тоже u=w

итак эти две команды в плане маски это одно итоже.

-220 означает то что мы ищем файлы у которых вот эти биты установлены

       u   g   o
      -w- -w- --- 

а те быты которые в нашей маске не установлены они в маске файлы могут
быть какие угодно. тоесть есть нас волнует толко то чтобы юзер мог писать и группа
могла писать. а остальные биты нам все равно какие.


следущий прмиер

       $ find . -perm -444 -perm /222 \! -perm /111
       $ find . -perm -a+r -perm /a+w \! -perm /a+x

      
444 это r-- r-- r--

тут еще надо понястьи что такое "a" это означает all users. тоесть
    $ chmod a+x
оно устанвиит и для юзера и для группы и для other бит x
будет 
    ??x-??x-??x
биты которые обозначены как ? затронуты не будут

тогда сраавниваем -444  r-- r-- r--
значит -444 значит то что мы требует чтобы вот эти биты r-- r-- r--
были устанолвены. что касается других нам похер.

сравниваем с этим -a+r
оно делает тоже самое. то есть для всех юзеров устанавлиывается бит r
а знак минус означает что другие биты мы не трогаем. доказываю показываю

    $ ls -1al
    -rwxrwxr-x  1.txt
    -rw-rw-r--  2.txt
    -rw-rw-r--  3.txt
    -r--r--r--  5.txt

    $ find . -perm -a+r 
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

тоесть он показал все файлы где устанолвнены биты r для всех юзеров

    $ find . -perm -444
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

кстати что -a+r что -a=r это одно и тоже

    $ find . -perm -a=r 
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

по русккт этот пермишн значит то что нам нужны файлы у которых для всех 
разрешено чтение

тоесть -444 и -a+r это одно тоже

теперь сравним 
    -perm /222
    -perm /a+w
      
222 и a+w это одно тоже. 
/222 означае что мы ищем файлы где хотя бы один устаглвенный бит
будет установлен в маске файла. тоесть говоря по руски мы ищем файлы где
либо для юзера либо для группы либо для other будет разрешен запись

далее сравним
    \! -perm /111
    \! -perm /a+x
      
111 этоодно  тоже с a+x
/111 означает что нам нужно чтобы хотя бы один бит был устанолвен в маске
файла тоесть в фале должно быть рарзерешено исполенние либо для юзера 
либо для группы либо для other.  знак ! означае что мы такие файлы исключаем из 
поиска.

таким образом эти два примера они о б одном и том.же
в итоге мы ищем файлы такие что : 
    в маске файла и для всех должно быть разрещено чтение r-- r-- r--
    AND хотя бы для когото разрешена запись               -w- or -w- or -w-
    AND запрещено чтобы хотя бы доя когото был установлен x тоеть ! --x --x --x
    

проверяю. имеем файлы
    $ ls -1 | xargs "-I^"  stat -c "%A  %n"   "^"  
    -rwxrwxr-x  1.txt
    -rw-rw-r--  2.txt
    -rw-rw-r--  3.txt
    -r--r--r--  5.txt


    $ find . -type f  -perm -a+r -perm /a+w \! -perm /a+x 
    ./3.txt
    ./2.txt

все верно. 5.txt  не подхлодит потому что у него нет w 
хотя бы у когото, 1.txt не подходит потому что у него есть x а он 
запрещен вообще



следущий пример

    $ cd /source-dir
    $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 /dest-dir
      
    
здесь нужно обьяснить что за настройка -prune
во первых какой формат у команды find

    $ find "папка где искать" "условие поиска1" "действие1" OR\AND 
        "условие поиска2" "действие2" ...
        
если мы не указываем дейтсвие сами то find автоматом подстаялет действие -print
даю простой пример
    $ find / -name "vasya" -print
/ = папка где искать
-name "vasya" = шаблон что искать
-print = что делать с найднным

второй просто пример
        $ find / -name "vasya" -print  -o   -size 100M+ -print
этот пример ищет в / файлы с именем vasya и печатае их на экране ИЛИ
ищет файлы размером 100M+ и печаатает их на экране.

так вот -prune относится к действию. что он делает.
перед -prune надо обязательно чтобы стояило какое то условие поиска.
так вот если резулттаом поиска является папка то он в нее не спускается.
пример
имеем папку

    $ find . -maxdepth 1  \! -name "." -printf "%y %f \n" | sort
    d 12 
    f 1.txt 
    f 2.txt 
    f 3.txt 
    f 5.txt 

мы не хотим чтобы find искал в папке 12. нам надо ее исключить.
мы не хотми чтобы find в нее спускался

    $ find . -name 12 -prune -o -type f -name "*" -print
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

    
пример расшифровавывается так ищи в папке "."
если имя "12" и это имя папки то не спускайся в нее.
ИЛИ
если это обычный файл  и у него имя "*" то печатай его на терминале

но скажем так нахер это prune если можно сделать аналогиченое через maxdepth

    $ find . -maxdepth 1  -type f -name "*" -print
    ./1.txt
    ./3.txt
    ./5.txt
    ./2.txt

но -prune пригодится например в другом случае например такой случай что
у нас то там то здесь появляется папка с именем ".git" на разных глубинах
и мы не хотим чтобы мы в нее входили. 
для примера имеем такую структуру папок

    $ find .  \! -name "." -printf "%y %h/%f \n" | sort
    d ./folder-A 
    d ./folder-A/.git 
    d ./folder-B 
    d ./folder-B/er-f 
    d ./folder-B/er-f/.git 
    f ./1.txt 
    f ./2.txt 
    f ./3.txt 
    f ./5.txt 
    f ./folder-A/a.txt 
    f ./folder-A/.git/12.txt 
    f ./folder-B/er-f/er.txt 
    f ./folder-B/er-f/.git/14.txt 

исключаем вход в папку .git где бы она не была внутри в кишках
через -prune
    $ find . -name ".git"  -prune -o -type f -name "*" -print
    ./1.txt
    ./3.txt
    ./folder-A/a.txt
    ./5.txt
    ./2.txt
    ./folder-B/er-f/er.txt

(с prune помогло разобраться вот это https://stackoverflow.com/questions/1489277/how-to-use-prune-option-of-find-in-sh)

есть еще опция -path
какая же у нее связь с базовой папкой откуда мы начинаем поиск.
а прикол в том что связи никакой. в том плане что 
в -path мы прописываем абсолютный путь
например у меня есть папка /home/vasya/temp/!9/2
кстати замечу что ее нужно взять в одинарные кавычки
иначе быш при вызове find вместо ! подставить чтот там из 
истории команд.
итак есть папка
    /home/vasya/temp/!9/2
у нее есть подпапка 
    .git
я хочу ее исключить
тогда в -path надо указать полный путь

    $ find '/home/vasya/temp/!9/2' -path '/home/vasya/temp/!9/2/.git' -prune  -o -name "*.txt" -print | grep .git

вот видим что вывод пустой
если бы мы указали в -path относитльный путь  относиельно базовой папки
то ничего бы не сработало.

хотя я несколько лукавлю когда говорю что в -path нужно указывать
полный путь. не совсем так. надо понимать как будет выглядеть имя файла
если мы указали нашу базовую папку
показываю

    $ find '/home/vasya/temp/!9/2' 
    /home/vasya/temp/!9/2
    /home/vasya/temp/!9/2/1.txt
    /home/vasya/temp/!9/2/3.txt
    /home/vasya/temp/!9/2/.git
    /home/vasya/temp/!9/2/.git/5.txt

он будет всегда выглядеть как  '/home/vasya/temp/!9/2' + '.....'
поэтому мы берем в этом списке ту папку которую хотим исключить и всталвяем 
в -path  в данном случае это '/home/vasya/temp/!9/2/.git'
так вот теперь я запущу тот же поиск в той же папке но задам по другому
название базовой папки
    $ find . 
    .
    ./1.txt
    ./3.txt
    ./.git

и мы видим что наша искомая папка тепер имеет имя './.git' так вот именно его 
теперь надо подствлять в -path './.git'
тоесть

    $ find '.' -path './.git' -prune  -o -name "*.txt" -print | grep .git

тоесть то как будет выглядеть -path все таки зависит от $basedir
я бы сказал что -path нужно указывать в виде 
    -path '$basedir+$dir'
    
тоесть -path это полный путь к папке но с учетом в какой форме задан basedir
самой простой спооб понять что вставить в -path это запустить просто поиск с 
basedir и потом прогрепать и найти название папки нужной нам и вставить в -path

причем -path допускает вставляьь в себя шаблоны. пример

    $ find '.'
    ./1.txt
    ./a01
    ./123
    ./b01

    $ find '.' -path "./?01" -prune  -o -name "*" -print 
    ./1.txt
    ./123

тоесть в данном случае он исключил папки 
    ./a01
    ./123
    ./b01
на основе шаблона "./?01"
причем этот шаблон обработал именно find а не баш перед тем как запустить find

или вот я хочу исключить a01 и b01 
делаю это на основе шаблона "./[ab]01"
опять же хочу подчеркнуть что этот щаблон обарабывает 
именно find  а не баш до того как запустить find

    $ find '.' -path "./[ab]01" -prune  -o -name "*" -print 
    ./1.txt
    ./123



возвращаюсь к исходному примеру

       $ cd /source-dir
       $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 /dest-dir

вторая строчка эквивалентна
       $ find . -name .snapshot -prune -o "("  \! -name '*~'  -print0 ")" | cpio -pmd0 /dest-dir
    
    
сразу замечу что скобками огораживается хрень вида  условие + действие
тоесть find можно вот так расписать его синткаскис

    $ find DIR  (условие1 действие1 AND/OR условие2 действие2 ...) AND/OR 
        (условие5 действие5 AND/OR условие6 действие6) 

в условиях мы указываем что ишем а в действии что мы делаем с найденным именем файла
DIR - базовая папка откуда начинаем поиск всегда остается вне скобок

-o  это OR для find

если у нас внутри скобок тольк одно условие+действие то его можно в скобки и не 
заключать. тоесть 

    find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) =
  = find . -name .snapshot -prune -o  \! -name '*~' -print0 =
  = find . "(" -name .snapshot -prune ")" -o "("  \! -name '*~' -print0  ")"

это все одно и тоже.
скобки являются парамтрами файнд а в баш они являются спецсмволвами. поэтому надо 
чтобы баш их передал  в файнд как еть. поэтому мы их экранируем. тожесамое касается !.
экранировать скобки можно либо через слэш \( либо через кавычки "("
! можно экранировать либо черещ \! либо '!' наколько я помню двойные кавычки "!" 
нихрена не экранируют !

итак возвращаюсь к этой строчке

    $ find . -name .snapshot -prune -o "("  \! -name '*~'  -print0 ")"

в папке "." и ее подпапках ищется папка с именем ".snapshot" на люыбых
глубинах и  в нее вход запрещен. помимо этого ищутся все файлы и папки кроме 
тех у которых на конец имени стоит "~" 
кстати проверка что насчет тильды я прав

    $ ls -1 
    123
    123~
    1.txt
    a01
    b01

    $ find . '!' -name "*~"
    ./1.txt
    ./a01
    ./123
    ./b01

да все верно

итак возвращаясь к исходному примеру

    $ cd /source-dir
    $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 /dest-dir

переходим в папку '/source-dir'
ищем в ней все файл и папки кроме тех что имеют в имени на конце "~"
и кроме папок у которых имя ".snapshot"  и эти имена посылаются через пайп
в cpio. расшифровааю ключи от cpio. где cpio это такой архиватор. и копировалщик между 
папками. нахер он нужен надо почитать. итак его ключи
 -p, --pass-through
              Pass-through.  Read a list of file names from the standard input 
              and copy them to the specified directory.
итак как раз ключ -p говорит о том что имена файлов которые копировать брать из stdin
что ему и делает find
        -d, --make-directories
            Create leading directories where needed.

       -m, --preserve-modification-time
              Retain previous file modification times when creating files.

        -0, --null
              Filenames in the list are delimited by null characters instead of newlines

значит -d создает папки в dest-dir, -m нетрогает mtime, а -0 говорит о том что
имена файлов которые прилетают из stdin разделены байтом 0x00
и действельно у find мы юзаем -print0 
который на конце имени файла прилепляет 0x00 байт вместо дефолтового 0x0a
это на случай если есть ебанутые файлы у которых в имени есть символ "\n"

по факту вся эта констуркция find | cpio копирует файлы и папки и  /source-dir 
в /dest-dir,

непонятно только нахер это делать через cpio.

вот к этому примеру в man find есть подпись. 
This  command  copies  the  contents of /source-dir to /dest-dir, 
but omits files and directories named .snapshot (and anything in them).
It also omits files or        directories whose name ends in ~, but not their contents.  
The construct -prune -o \( ... -print0 \) is quite common. 
The  idea  here  is  that  the  expression
before  -prune  matches  things  which are to be pruned. 
However, the -prune action itself returns true, 
so the following -o ensures that the right hand side is
evaluated only for those directories which didn't get
pruned (the contents of the pruned directories are not even visited, so  their 
contents  are  irrelevant).
The  expression  on  the  right  hand  side of the -o is
in parentheses only for clarity.  
It emphasises that the -print0 
action takes place only for things that
didn't have -prune applied to them. 
Because the default `and' condition between tests 
binds more tightly than -o, this is the default anyway, but the  parenthe‐
ses help to show what is going on.

из нее следует какая то хрень что типа файнд игнориует как я уже сказал 
файли  и папкт котоыре имеют на конце "~" и папки ".snapshot" но 
при этом они пишут что ихний контент не игнориуется. это что за хуйня?
не игнориуется кем? если файндом - то конечно игнорируется потому что 
их имен не будет в списке который он высирает на stdout.  а игнориует 
ли их cpio ну не знаю...  проведу эксперимент.

у меня есть структура папок

    $ find . -printf "%y  %h/%f \n" 
    f  ./10.txt 
    f  ./9~ 
    d  ./.snapshot 
    f  ./.snapshot/snapshot.txt 


тоесть в корне два файла 
    10.txt
    9~
и папка
    .snapshot
и внутри нее файл 
    snapshot.txt

соовтестенно файнд выдаст на stdout только 10.txt и все.
    $ find . -name .snapshot -prune -o \( \! -name "*~" -print \)
    .
    ./10.txt

так оно и есть . а теперь запускаю полную команду

    $ find . -name .snapshot -prune -o \( \! -name '*~' -print0 \) | cpio -pmd0 '../!11'
    1 block

в итоге я захожу в папку '../!11' и в ней ровно так и есть что скопировался
только файл 10.txt и больше ничего. поэтому я считаю вот этот кусок фразы
    but not their contents
полная хуйня. в итоге будет скопирован ровно тот набор файлов который 
ему укажет find
тоесть если скажем у нас есть папка папка и в ней есть файл 10.txt
и 9~ то файл 10.txt будет скопирован а файл 9~ не будет хотя само название
папки будет передано в cpio. но он из нее 9~ исключит.
я еще раз проерил ровно так и работает
я завел подпапку ./12 и в ней два файла 12.txt и 13~
при этом у меня файнд передал название папки и файл 12.txt
    /12
    ./12/12.txt
так вот cpio он такой умный он видит название папки но копиреует оттуда 
только те файлы которые есть в списке что ему передали а не всю папку.
прикол.


но это еще невсе. в описании написано что все actions которые есть в find
например -prune они делают некий код вовзрата например -prune всегда делает
код возврата true. спрашивается а какая нам разница. а это имеет значение
для наших AND/OR
например

     $ find . -name .snapshot -prune -o  "("    \! -name '*~'   -print0   ")"

у нас стоит 
     find .  (-name .snapshot -prune)   OR   (\! -name '*~' -print0 )
как работает OR а именно
     cond1 OR cond2
если слева операция дает TRUE то правая операция уже не запускается.
правая операция запускается только если левая вернула FALSE
условие начинает проверятся прежде всего левое.
получается до правого может и недойти.
получаетс у нас prune стоит слева поэтому каждый новый файл проверяется прежде 
всего на prune. таким образом если файл удовлетворяет прун. то он отбрасывается
этим пруном из списка файлов высираемых файндом и кодом возврата является TRUE
поэтому данный файл далее не проверяется на условия которые стоят в правой скобке.
то что кодом возврата прун является всегда true означает то что если за ним стоит OR
то то что стоит за OR не будет выполнено. тоесть если у нас файнд берет очередного
кандидата и натравливает его на первую скобку. и этот кандидат удовлетвтоярет условию
этой первой скобки то действие прун в этой скобке исключает этот файл из того чтобы
высрать его имя на stdout плюс так как прун код возврата возращает TRUE а затем 
стоит OR это приводит к тому что дальнейшая обработка этого кандидата прекращается.
если же кадидат не удовлветоряет услвию в первой скобке то первая скобка вовзращает 
false и тогда вдействие вступает вторая скообка стоящая за OR
там тоже может быть либо фолс либо тру. но фишка состоит в том что так как прун стоит
в первой скобке то никакой хреновый кадидат не прорвется через эту первую скобку.
если собкки поменять местами 

    (\! -name '*~' -print0 ) OR (-name .snapshot -prune)     

то у нас папки с именем .snashot будут успешно удовлетворять первой скобке
и прорываться наружу из файнд в stdout
тоесть поток выглядит так

очередной кандидат /dir1/file1 -->find -->(первая скобка )если $?=true то -->stdout
                                                         |если $?=false то -->(вторая скобка)

из второй скобки путь:
(вторая скобка)если $?=true то -->stdout
              |если $?=false то -->имя кандидата в /dev/null
                                       

таким образом скобку с прун надо всегда ставить в самом начале слева.
чтобы она обрабатыватлась первой. и далее ставить OR
тогда если мы нашли гавняную папку то дальнейшая обработка этой строки 
прекратится а кадидат отправится в топку

теперь такой момент. как я уже сказал что нужно условие на основе 
которого искать файлы а потом надо указать действие. так вот оказывается что
можно указат НЕСКОЛЬКО действий.
вот пример
в нем я для кажого найденного файла применяю аж три actions
печатаю на экране имя файла, печатаю имя файла в в файл на диск,
и запускаю команду echo

    $ find . -print   -fprintf "/tmp/1.txt" "%f \n"  -exec  echo === ';'
    .
    ===
    ./10.txt
    ===
    ./9~
    ===
    ./.snapshot
    ===



                                    
кстати щас малек в сторону пример вначале.
у меня есть папки вида  !1 !2  !3 я их хочу пеернименовать в !01 !02
как это сделать

    $ find . -maxdepth 1 -name '!?'  | cut -c 4- | xargs -L1 -n1  -I%  mv  './!'% './!0'%


    
    
следующий пример

    $ find . "(" -exec test -d '{}'/.svn ";"  \
      -or -exec test -d '{}'/.git ';'  \
      -or -exec test -d '{}'/CVS ';' ")" \
      -print -prune


схематично комана выгляди так

    $ find DIR ( action1 OR action2 OR action3 ) AND action4 AND action4

и это опять новое слово потому что оказывается что можно ставить AND\OR не тольк между
    ( условие1 action1 ) AND\OR (условие2 action2 )
но и в случае 
    ( action1 ) AND/OR ( action2 )
без указания условий
причем получается что выставление скобок повышает приоритет . тоесть

   A OR B OR C AND D AND E

это совсем другое по сравнению с 

   ( A OR B OR C)  AND D AND E


возвращаюсь к примеру

  $ find . "(" -exec test -d '{}'/.svn ";"  \
      -or -exec test -d '{}'/.git ';'  \
      -or -exec test -d '{}'/CVS ';' ")" \
      -print -prune
      
схематично выгляит комнад так

    $ find . ( exec test OR exec test OR exec test ) AND print AND prune
    

так вот пример по теме
    $ find . -type f      -a \
             -name "*12*" -a \
             -exec bash -c 'if echo {} | grep -q  "txt"; then exit 0; else exit 1; fi' ';' -a \
             -print 

    ./123.txt
    ./12.txt

я ранее писал неверно.  я писал что (условие + action) записываюьтся 
вместе и только эта связка разделяется логическими операторами AND/OR
на самом деле нет. на самом деле find его синтксим выглядит так

    $ find DIR условие/action  AND/OR условие/action AND/OR условие/action

тоесть указывается DIR а потом идут в линнеечке либо условие либо action
они абсолютно равнозначны между ними по дефолту незримо стоит AND
хотя можно его поставить в явном виде -a , а можно поставить OR как -o
результатом проверки условия либо выпоонения action явялется код возврата.
соовесвтенно если на какомто шаге код возврата FALSE а дальше стоит AND
то обработка текущего файла прекращается а если OR то наобоорот переходит 
к следущему шагу в цепочке. если мы хотим несаолко шагов обьединить в один 
то применяем скобки.

    $ find DIR (условие/action  AND/OR условие/action) AND/OR (условие/action)

а я раньше думал что action происходит только если выполнился слева от него условие.
а это оказалось совсм не так. 
например 
я думал что если стоит

   -type f -print 
   
то это значит что если -type f то выполнить -print
а оказалось что 
  
    -type f -print  =  (-type f) -a (-print) = (-type f) AND (-print)
    
читается так что если код возврата от -type f равен TRUE то происходит переход
к выполению\проверке следующего шага в цепочке
так вот теперь живой пример

    $ ls -1
    12
    123
    123.txt
    12.txt
    13
    13.txt

    $ find . -type f      -a \
             -name "*12*" -a \
             -exec bash -c 'if echo {} | grep -q  "txt"; then exit 0; else exit 1; fi' ';' -a \
             -print 

    ./123.txt
    ./12.txt

    
работает эта шарманка так. find начинает сканировать папку "." берет из нее первый
файл или папку и нправляет это на первых шаг цепочки  
    -type f -a \
если это непрстой файл то код возврата FALSE и поскольку дальше стоит -a (AND)
то обработка текущего файла прекращается. и файнд переходит к сладущему файлу 
начинает опять сначала. если тип файлы обычный то кодд вовзарата TRUE
и посколку дальше стоит -a то файнд переходит  к следущему шагу
    -name "*12*" -a \
и идет проверка имя файла совпдает по паттерну "*12*"
если нет то поскольку далше стоит -a (AND) то тогда оббработка этого файла прекращается.
если же имя соотвесвтует паттерну то код возварат true и так как дальше 
стоит -a то происхдодит переход к следушему шагу
    -exec bash -c 'if echo {} | grep -q  "txt"; then exit 0; else exit 1; fi' ';' -a \
здесь выполняется некая внешняя команда в которую через {} файнд подставляет
имя файла текущего если код возврата FALSE то посколлку дальше стоит -a 
то обработка текущего файла прекращается. если же TRUE а в данном случае 
я тестирую что имя файла по шаблогу пересекается с "txt" то тогда происходит 
переход к следушему шагу. по сути exec позволяет нам расширить функционал
команды find за счет любых внешних команд
    - print
это последний шаг и он по своей сути что делает. он печатает имя файла на экране.
поэтому этот шаг этот action его имеет смысл вставлят самым последним самым правым
в цепочке. тоесть после того как прошли все проверки. все команды. 
вот так это рабоает
тогда в итоге команда эта работает так
она проверяет что файл по типу простой   AND 
что имя его вкладывается в шаблон "*12*" AND
далее проверяется что имя соотвествует шаблону "*txt*" AND
печатется на экране имя файла

так вот возврашаюсь к примеру

        $ find repo/ "(" -exec test -d '{}'/.svn ';' -or   \
                         -exec test -d '{}'/.git ';' -or   \
                         -exec test -d '{}'/CVS  ';'  ")"  \
                         -print -a \
                         -prune
                         


значит эта команда работает так (...) AND -print AND -prune
значит команда идет в папку  repo/ 
и последовательно берет оттуда название каждого файла каждой
папки как аргумент например пусть repo/dir1 
вначале отрабатывает скобка , в скобке идет проверка на то что 
repo/dir1 имеет подпапку .svn либо подпапку .git либо подпапку CVS
если хотя бы одно выполняется то файнд переходит к следущему шагу в цепочке
а именно печатает имя repo/dir1 на терминал, команда -print 
всегда имеет код возврата TRUE поэтому далее файнд перходит к 
следушему шагу в цепочке и делает prune.
самый главный вопрос что тут делает prune
значит я малек переписал команду

 $ find repo/ -exec [  -d "{}/CVS" -o -d "{}/.git" -o -d "{}/.svn" ] ';' -print -prune
 
значит я убираю /repo меняю на . 
чтобы это меня не отвлекало от главного 

 $ find .  -exec [  -d "{}/CVS" -o -d "{}/.git" -o -d "{}/.svn" ] ';' -print -prune

значит что делает prune. во первых prune работает только если файнд сейчас 
обрабатывает имя папки пусть это папка ./project1 так вот если файнд 
доходит в цепочке до команды prune то после этого файнд прекращает обработку
всех файлов в этой папке, и всех подпапок этой папки. тоесть 
если у нас файнд обрабывает сейчас ./project1 и файнд дошел до -prune 
в цепочке то после этого файнд сразу отбрасывает для дальнейшей обработки все 
файл и папки с путями ./project1/*
таким макаром логика этой команды такая. мы берем папку "." начинаем сканировать 
все файл и подпапки этой "." , файлы мы сразу обрасываем потому что в логике этой программы
файлы вообще не участвуют. но можно улучшить эту команду чтобы это было еще более
явно ясно

 $ find .  -type d -exec [  -d "{}/CVS" -o -d "{}/.git" -o -d "{}/.svn" ] ';' -print -prune

 
так вот фанд берет первую подпапку в "." скажем ./vasya
и выполняет exec который тестирует через баш а есть ли у ./vasya подпапки ./vasya/CVS
либо ./vasya/.git либо ./vasya/.svn подчеркну важную вещь что сам файнд 
на данном этапе оперирует в качестве аргумента папкой ./vasya
а проверка на существоввание   ./vasya/CVS | ./vasya/.git | ./vasya/.svn
идет средствами внешними через внешнюю баш команду []
если это так то печатается аргумент файнда на экране ./vasya
тоесть аргумент уже напечатался а далее выполняется следущая команда из цепочки
это prune и она приводит к тому что все подпапки этого аргумента выбрасываются
из дальнейшей обработки. тоесть ./vasya/*
это обусловаленно логикой программы. а именно мы хотим найти начиная от корня все 
папки как можно выше в которых есть подпапки .git .svn CVS
если у какойто папки любая из этих подпапок найдена то копать глубже нет смысла. 
поэтому мы применяем prune чтобы find не занимался переборкой ненужных уже нам
подпапок этой папки. мы уже узнали что хотели и дальше в этой папке копать абсолютно
 ненужно.
 
если мы имеем вот такую структуру папок
       repo/project1/CVS
       repo/gnu/project2/.svn
       repo/gnu/project3/.svn
       repo/gnu/project3/src/.svn
       repo/project4/.git

файнд берет repo/project1/ и проверяет есть ли у нее подпапки из {.git, .svn, CVS }
и да она есть. мы печатаем на экране аргумент файнда 
        repo/project1/
а делее к repo/project1/ примяеняется prune поэтому файнд запрещает
сам себе дальнейшую обработку путей вида repo/project1/*

потом файнд берет следущую папку repo/gnu/project2/
провяеряет и находит что есть подпапка .svn печатает на экране
    repo/gnu/project2/
и на будущее запрещает себе обработку папок вида  repo/gnu/project2/*

далее интересно. файнд беерет как аргумент  repo/gnu/project3/
проверяет что есть .svn как подпапка. печатает аргумент 
        repo/gnu/project3/
и запрещает сам себе обработку всех путей вида repo/gnu/project3/*
тоесть запрещает себе обрабатыать файлы этой папки и спускаться ниже в подпапки
поэтому вот эта папка  repo/gnu/project3/src
она хотя и имеет подпапку .svn но она никогда не попадет как аргумент 
в файнд. потому что на предыдущем шаге find запретил себе обрабатывать все что ниже 
repo/gnu/project3/*

напишу аналогичную программу. она ищет в каждой папке README.txt 
если находит то прекращает искать ее в подпапках этой папки
показываю структуру папок

    $ find . "(" -type f  -exec echo "FILE    {}" ';' ")"   -o \
             "(" -type d  -exec echo "DIR     {}" ';' ")" 

    DIR    .
    DIR    ./proj1
    DIR    ./proj1/01
    FILE   ./proj1/01/README.txt
    FILE   ./proj1/README.txt
    DIR    ./proj2
    DIR    ./proj2/super1
    DIR    ./proj2/super1/01
    FILE   ./proj2/super1/01/README.txt
    FILE   ./proj2/super1/README.txt
    DIR    ./proj2/super2


    $ find   .   -type d    -exec [ -f "{}/README.txt" ] ';' -print -prune 
    ./proj1
    ./proj2/super1

поскольку я вставил -prune и поскольку в папке ./proj1 есть файл README.txt
то подпапки  ./proj1/* исключаются из дальнейшей обработки поэтому 
папка ./proj1/01/ ее нет в распечатке не смотря на то что у нее есть README.txt
тоже самое поскольку файл README.txt есть в папке ./proj2/super1/
то подпапки ./proj2/super1/* исключаются из обработки файндом. поэтому
папка ./proj2/super1/01/ отсуствует в распечатке несмотря на то что в ней
есть README.txt
это хороший пример на понимание что дает -prune 

следщий пример

    $ find /tmp \( -type f -o -type d -o -type l \)
    
видно что вэтой команде есть только условия но нет ни одного action. так вот
если так есть то по дефолту файнд допиывает невидимо action -print
тоесть полная аналогия команды это 

    $ find /tmp \( -type f -o -type d -o -type l \) -print
    
    
в папке /tmp  ищутся файлы типов: обыный файл, папка, симлинк.
если файл удовлетворяет какому то из этих типов то имя файла\папки 
выводится на терминал 
    
далее в man find вижу такое
The command 

    $ find . -name afile -o -name bfile -print 

will never print afile because this is actually equivalent to 

    $ find . -name afile -o "(" -name bfile -a -print  ")"  

Remember that the precedence of -a is higher than that of -o and 
when there is no operator specified between tests, -a is assumed.

и дейсивтельно. так как перед -print нестоит ничего значит там незримо 
стоит -a значит у нас  A  OR  B  AND C
а это сооветсвенно A  OR  ( B  AND C )
    
тоесть 

    $ find . "(" -name afile ")"   -o   "(" -name bfile -a -print  ")"  

теперьт посмотрим что будет. 
когда аргумнтом будет bfile то первая скобка возварщает FALSE но так как 
у нас между скобками OR то запускается вторая скобка в которой мы выполняем -print
и печатаем bfile на терминале.
а вот когда аргументом будет afile то да условие -name afile успешно выполняется
но не написано какой экшн надо сделать поэтом скобка отрабатывает. но нихрена не 
печатает . возрвращвает TRUE . а так как справа стоит OR между скобками
то правая скобка уже не выполняется. так что имя файла afile дейстиеьно
никгда не будет наечаттано на экране. а чтобы он было напечатано надо переделать команду

    $ find . "(" -name afile    -o   -name bfile ")" -a -print 
    
теперь у нас A AND B
где A = (C OR D )
и в итоге если у нас  внутри скобки хотя бы одно из условий выполняется тоесть 
имя файла либо afile либо bile то скобка возвращает TRUE 
и так как далее AND то печаатет аргумент на экране. 
если у нас аргумент ни afile ни bfile то  скобка вовзращает FALSE и так как
далее указано AND то обработка такого аргумента прекращается.

далее приводится в man find пример

    $ find . -name *.c -print
    find: paths must precede expression
    Usage: find [-H] [-L] [-P] [-Olevel] [-D ... [path...] [expression]

они пишут что ошибка вылезла потому что знак * является спецсимволом
в баше поэтому перед тем как баш запустил find (внешнюю команду)
то баш обработал спецсимвол  и подставил вместо * а аргумент 
нечто другое наподобие вот такого

    $ find . -name frcode.c locate.c word_io.c -print
    
а эта команда по синтаксису уже неверная так как у find нет таких элеметов
в цепочке как locate.c word_io.c
поэтому они пишут что нужно от баша экранировать спецсимвол *
    
    $ find . -name '*.c' -print
    $ find . -name \*.c  -print
    $ find . -name "*.c" -print

и я с этим абсолютно согласен

далее.
есть  экшен -exec command arg1 arg2 '{}' arg3  ';' у find
который для каждого аргумента запускает внешнюю команду 
в которую можно подставить аргумент через '{}' а символ ';'
исползуется чтобы обьяснить файнду что мы закончили описыывать внешнюю команду
пример

    $ find . -exec echo '{}' ';'
    .
    ./13.txt
    ./123.txt
    ./123
    ./12
    ./12.txt
    ./13

а есть похожая команда -exec command arg1 arg2 '{}' arg3  '+'
которая визуально отличается от предыдудщей тем что стоит '+'
эта команда отличается тем что она запускает внешнюю команду не для каждого
аргумента а ( и тут два варианта ) либо она собирает все аргументы и подстлавяет
их во внешнюю команду за один раз через пробел, либо разбивает все 
аргументы на какието кучи и запускает их несколько раз
пример

   $ find . -exec echo '{}' '+'
    . ./13.txt ./123.txt ./123 ./12 ./12.txt ./13

как говорится почувствуй разницу


    
    
<--- закончил тут 
1) проработать все ключи в find

1.5) непонятно только нахер это делать через cpio.

    
1.5) две ссылки  с ответом
    https://stackoverflow.com/questions/27800726/ls-terminated-by-signal-13-when-using-xargs/77637318#77637318
    https://superuser.com/questions/554855/how-can-i-fix-a-broken-pipe-error


2) разобрать три ссылки
    https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html
    https://stackoverflow.com/questions/71284062/how-to-printf-fixed-number-or-digits-in-floating-in-bash
    https://unix.stackexchange.com/questions/589475/how-can-i-exclude-and-when-listing-only-hidden-items


3) продолжить разбор
    https://tldp.org/LDP/abs/html/fto.html
    
3.1) man bash читать
     set [+abefhkmnptuvxBCEHPT] [+o option-name] [arg ...]
    
3.5) /usr/bin/nohup 
    
4) проработать info coreutils 
посмотреть какие там есть утилиты






##  



=== недоделано

$$$$$$$$$$$$$
$$$$$$$$$$$$$
$$$$$$$$$$$$$

вопросы:
- вернуть обратно модуля ядра чтобы coretemp опять заработал
- thermal zones
- yaml формат  в thinkfan
- <<<



- а как происходит запись в файл сразу двух процессов?
как при этом работает
$ : > file



-  изучить bash advanced guide
