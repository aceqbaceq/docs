bash

| приколы

приколы баша
$ echo !4
echo ps aux | grep sleep
$ echo !0
bash: !0: event not found
эта хрень показывает команды из истории команд


| tr

эта комнда ищет паттерн и меняет его на другой

$ echo " output=10; input=16; A0" | tr [:lower:] [:upper:] 
 OUTPUT=10; INPUT=16; A0


$ echo "aaa bbb " | tr "a" "D"                             
DDD bbb 



эта команда он подлая. об этом можно прочитать в info tr
вот пример

$ echo "b" | tr  bbbbb  12345
5

вчем подлость команды tr : у нас в паттерне есть несколько b возникает вопрос
когда мы находим b в нашем слове то какой b использовать? тот который b в 1 превращает
или b который в 2 превшращает? или b который в 5 превращает?
ответ такой что берется самый последний b. поэтому все b пропускаются в шаблоне
и берется последний b кторый превращает b в 5.

еще пример

$ echo "a"  |  tr    aaaaaaaaaa 1234567890
0


тоесть у нас есть шаблон aaaaaaaaaa у нас естт исходное ссобщение 'a'
возникает вопрос какой a нужно брать из шаблона. овтет последний.
потом смотрим на какой символ мапится последний a  в шаблонке ответ а ноль.


прмиер

$ echo ooops not good | tr oops nice
iiice nit giid

как это рабооает. 
у нас есть шаблон "oops" у нас есть слово "ooops"
в шаблоне берем последний "o" он мапитсят в "i" получается

[ooo]ps -> [iii]ps

остатеся вопрос с ps он мапиисят напрямую поэтому 

[ooo][ps] -> [iii][ps] = iiips

далее берем слово "not"
берем шаблон "ooops" 
в шаблоне "n" нет. есть "o" но в шаблоне "o" несколько. мы берем последнее "o"
второе "o" мапится в "i"

потмоу что o[o]ps n[i]ce

значит n[o][t] --> n[i][t]
бквы t нет в шаблоне значит t остается без изменений значит

not -> nit

берем слово "good"
ни g ни d нет в шаблоне они без изменений. 
буква o есть  в шаблоне. их несколько в щаблоне мы беерм послнее o в щаблрне оно маится в
i значит

g[oo]d  --> giid

значит в итоге 

iiips nit giid

в целом намой взгляд достоачно неинтуитивная и ебанутая команда этот tr


| special variables $0 $1 $@  $# $* $? $$ $!

`$0` – The name of the script being executed.
`$1-$9` – The first nine command-line arguments.
`$#` – The number of command-line arguments.
`$*` – All command-line arguments as a single string.
`$@` – All command-line arguments as an array.
`$?` – The exit status of the last executed command.
`$$` – The process ID of the current shell.
`$!` – The process ID of the last background command.


рассмотрим $0
я не согласен то о чем везде пишут что $0 это имя скрипта.
посмотрим

$ echo $0
bash

$ /bin/bash
$ echo $0
/bin/bash


$ ln -s /bin/bash ./b-lnk
$ ./b-lnk
$ echo $0
./b-lnk


$ ln -s ./b-lnk ./c-lnk
$ ./c-lnk
$ echo $0
./c-lnk

отсюда видно что $0 эта переменная показывает каким образом был запущен процесс.
а именно его такой параметр как /proc/$$/cmdline

/proc/self vs /proc/$$/ (self это не перменная. это симлинк в /proc/)

запускаем чтото в баше . тогда он себя форкает через сисколл(просит об этом ядро тоесть)то создает дочерний процесс
а вот если в баше прога зпускатся через exec то баш взывает сисколл exec тоесть управлениеп
передаетая ядру. и ядро замещает усовно говорят код баша в процессе в котором крутится баш 
на код вызываемой программы.  

мы импользуем exec когда не хотим создавать новый процесс. а хотим запустиьт прогу
в рамкаж уже этого процесса. 



--
вот так верно

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c", "sleep 120"]

а так полет нахер

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c sleep 120"]

--
вот так верно

docker run --rm --name t1 -it    --entrypoint  "/bin/bash"   ubuntu  -c "sleep 120"

а так полет рахер

docker run --rm --name t1 -it    --entrypoint  '/bin/bash -c "sleep 120"'   ubuntu  
отому что в доках дкоера написано что --entrypont должно сдежать татолько
путь к бинарнику\скриту. но не к параметрам. параметры пишктая в самом справава



==

| -
| ~-

в баше любили повыебвыаться.

если мы в качестве пути укажем "-" то баш подставит вместо этого $OLDPWD
где OLDPWD это сохранненный есть предыдущая папка в которой ты был.
но эта хрень раротботет только с встроенным билтином cd и только в единствнной форме

$ cd -
эквивалентно
$ cd $OLDPWD

при этом вот такое уже нераобтеает

]$ cd -/tmp
bash: cd: -/: invalid option
cd: usage: cd [-L|[-P [-e]] [-@]] [dir]

в эхо это тоже неработает

$ echo -
-


втора хрень "~-" она более универсальная. она раобтотает уже нетолько с cd
но и скажем с echo 

$ echo $OLDPWD
/
[vasya@lenovo //]$ cd ~-
[vasya@lenovo /]$ echo ~-
//


пиздец доблеблы в этом баш. выбеонщики

нашел этот все зесь = https://unix.stackexchange.com/questions/330876/difference-between-cd-and-cd
===
| bash
| redirect
| exec

bash
io redirect

(для начала ознакомился с этим https://tldp.org/LDP/abs/html/io-redirection.html)

разбереся как работает эта команда
       # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3

для начала
немного отойдем в сторону что будет если ввести команду
$ cat > 56.txt
а будет вот что. команда будет ждать ввода текста со стандартного ввода.
тоесть можно сидеть и набирать текст. когда хотим закончить набор то жмем Ctrl+D.
и этот текст набранный в терминале на экране будет записан в файл.

получается форма вида

# echo "asd" > /tmp/1.txt 
это укороченная форма команды
# echo "asd" 1 > /tmp/1.txt

и команда вида
# cat < 1.txt
это укороченный аналог
# cat 0 < 1.txt
(взял отсюда https://tldp.org/LDP/abs/html/io-redirection.html)

еще важная хуйня про io redirect
надо обязательно дескриптор файла ставить рядом без пробелов со знаками ">","<" итп.
тоесть

$ dfrtr 2>4.txt
$ cat 4.txt
dfrtr: command not found

тоесть видно что редирект сработал. мы ввели несуществующую команду.
при этом канал ошибок был заредиректен на файл 4.txt
видно что мы ввели "2>..." тоест между 2 и ">" нет пробела. 
такой редиректо сработает.

$ dfrtr 2 >4.txt
dfrtr: command not found

а этот редирект неработает. потому что у нас между 2 и ">" стоит пробел.

далее . разберем поподробнее пример
    $ dfrtr 2>4.txt

что в нем интересно это как оно выполняется.
у нас есть баш процесс и мы его просим запустить команду "dfrtr"
баш процесс выполняет сисколл и просит ядро создать новый процесс самого себя. когда клон исходного процесса
будет создан в форме нового процесса то баш в новом процессе ищет среди $PATH бинарник с именем "dfrtr"
ненаходит его и посылает на sterr ошибку. если бы бинарник был бы найден то баш склонированного процесса
выполнил бы еще один сисколл который просит ядро заменить в текущем процессе бинарник баша на бинарник dfrtr.
соотсвтвенно вопрос - кто кидает в stderr ошибку что файл ненайден - баш в склонированном процессе или ядро?
как я понимаю имеено баш запускает ряд сисколлов stat в разных папках которые у него прописаны в $PATH
и все сисколлы сообщают бинарнику баша что там такого файла нет. тогда бинарник баша пишет в sterr 
сообщение о том что файл ненайден. таким образом именно бинарник баша кидает на stderr сообщение об ошибке
я не ядро. потому что важно было понять кто занимается отправкой сообщений на stderr юзерская программа
или само ядро. 
вот доказательство

$ strace  bash -c "kuku"
...
stat(".", {st_mode=S_IFDIR|0775, st_size=1011712, ...}) = 0
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/sbin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/sbin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/bin/kuku", 0x7ffcfd0c62a0)   = -1 ENOENT (No such file or directory)
stat("/sbin/kuku", 0x7ffcfd0c62a0)      = -1 ENOENT (No such file or directory)
stat("/bin/kuku", 0x7ffcfd0c62a0)       = -1 ENOENT (No such file or directory)
stat("/usr/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/snap/bin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)

тоесть видно что бинарник баша ищет бинарник kuku во всех папках которые есть у него в $PATH
и ничего ненаходит.
...
write(2, "bash: kuku: command not found\n", 30bash: kuku: command not found
) = 30

и тогда бинарник баша сам лично через сисколл write пишет в дескриптор "2" об ошибке
я совершенно не утверждаю что в 2 неможет писать само ядро. но в данном случае ошибку генерирует
сам юзерский процесс.

так вот вовзращаемся к примеру
        $ dfrtr 2>4.txt
рассмотрим более простой пример для начала
        $ dfrtr
        dfrtr: command not found

кто гененриует ошибку? ответ склонированный бинарник баша генерирует.
у нас наш текущий процесс баша сам себя клонирует. дальше в дело вступает клонированный баш.
он начинает искать бинарник dfrtr по всем папкам прописанным в $PATH
ненаходит. и тогда он склонированный бинарник баша пишет в 2 о том что файл ненайден.
таким образом отвечаю на вопрос - если команда не найден то кто генерирует ошибку?
возвращаемся к примеру
         $ dfrtr 2>4.txt
наш текущий баш склонирует самого себя в новый процесс через сисколл к ядру.
плюс наш исходный баш попросит ядро чтобы при создании нового процесса его дескриптор 2 указывал 
не на pty файл ( не на терминал как это обычно бывает)  а на файл ./4.txt
таким образом привязку 2 к 4.txt для нового процесса делает ядро по просьбе родительского баша.
дочерний баш к этому не имеет никакого отношения. дочерний единственное что сделает это напишет в 2 
что файл не найден. гениально. мудота та еще...
важно еще то что такого рода редирект файловых дескрипторов происходит не для исходного процесса баша 
а исключительно для новых порождаемых процессов. это тоже важно отметить. 

теперь фундаментальный вопрос а как нам изменить привязку файловых дескрипторов не для новых 
порождаемых процессов а для текущего процесса в котором крутится bash
в этом нам поможет баш билитн exec


баш builtin exec
что он делает.
по дефолту если мы запускаем команду в баше то баш это процесс как любой другой.
когда мы запускаем команду то баш создает новый процесс и в нем уже запускает нашу команду.
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
тоесть видно что номер баш процесса 31410
когда мы в нем запустили команду pstree то баш создал новый процесс 31426
так вот exec заставляет бащ не создавать новый процесс а запустить эту команду в текущем процессе
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
$ exec sleep 120
$ pstree -Asp 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---sleep(31410)
видно что процесс 31410 остался но там уже не баш а наша команда. а нового процесса нет.

как видно не создавание нового процесса было выполненно через баш билтин exec . в виде

$ exec команда

итак "exec команда" не порождает новый процесс а в текущем процессе заменяет бинарник.
есть надежда что подключение io redirect вкупе с exec позволит нам изменить привязки файловых
дескрипторов для текущего процесса.

$ echo $$
32624
$ exec sleep 130 2>3-err.txt

итак у нас был баш процесс 32624 со стададартной привязкой его дескрипоров 1,2,3 к терминалу
далее мы говорим что в текущем процессе заменить баш на sleep и для этого процесса (для того же самого)
задать что файловый дескриптор 2 должен смотреть на файл 3-err.txt

проверяем
$ ls -1al /proc/32624/fd
total 0
dr-x------ 2 vasya vasya  0 окт  4 09:00 .
dr-xr-xr-x 9 vasya vasya  0 окт  4 09:00 ..
lrwx------ 1 vasya vasya 64 окт  4 09:00 0 -> /dev/pts/21
lrwx------ 1 vasya vasya 64 окт  4 09:00 1 -> /dev/pts/21
l-wx------ 1 vasya vasya 64 окт  4 09:00 2 -> /home/vasya/temp/3-err.txt

и это действительно сработало!
процесс по номеру не поменялся. зато его привязка для дескриптора 2 поменялась.

попробуем на этом фоне более интересный пример
запустить баш из баша при этом перенаправить его 2 в 5.txt
для начала я хотел показать одну важную вещь. вот  у нас есть баш процесс.
я думал что prompts приглашение этот процесс пишет в 1 тоесть в stdout
а оказалось что он его пишет на stderr! показываю

$ echo $$
31668
$ bash 1>7.txt
таким макаром я запустил новый процесс баша и его stdout я завернул на файл 7.txt
$ 
при этом как видно у меня на экране по прежнему присуствует prompt тоесть 
этот prompt он пишется процессом как я уже сказал не на stdout а на stderr

открываю другой терминал и проверяю что новый баш имеет то  редирект в файл который я сказал
(другой терминал)$ $ cat 7.txt 
2661
(другой терминал)$ pstree -Asp 2661
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31668)---bash(2661)
видно что новый баш это чайлд от головного баша
(другой терминал)$ ls -1al /proc/2661/fd
lrwx------ 1 vasya vasya 64 окт  4 10:27 0 -> /dev/pts/22
l-wx------ 1 vasya vasya 64 окт  4 10:27 1 -> /home/vasya/temp/7.txt
lrwx------ 1 vasya vasya 64 окт  4 10:27 2 -> /dev/pts/22
lrwx------ 1 vasya vasya 64 окт  4 10:27 255 -> /dev/pts/22
четко видно что наш дочерний баш имеет stdout завернутый в файл

так вот аналогично легко убедться что если мы запустим баш у которого stderr будет завернут
в файл то  у нас приглашение баша исчезнет с экрана потому что оно теперь будет писаться не в терминал а в файл
$ bash 2>8.txt

и все у нас на экране больше нет prompt

так вот до этого моменты мы создавали дочерний процесс баша у которого был настроен редирект одного из 
файл дескрипторов в файл. 
теперь сделаем тоже самое без создавания дочернего процесса.
в первом терминале запускаем
    $ echo $$
    2963
    $ exec bash 1>10.txt
    $ 

во втором терминале проверяем
$ pstree -Asp 2963
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(2963)
$ ls -1al  /proc/2963/fd 
lrwx------ 1 vasya vasya 64 окт  4 10:31 0 -> /dev/pts/23
l-wx------ 1 vasya vasya 64 окт  4 10:31 1 -> /home/vasya/10.txt
lrwx------ 1 vasya vasya 64 окт  4 10:31 2 -> /dev/pts/23
lrwx------ 1 vasya vasya 64 окт  4 10:32 255 -> /dev/pts/23

видно что исходный процесс 2963 не имеет чайлдов и что его 1 перенаправлен в 10.txt
таким макаром мы научились текущий баш процесс менять таким образом чтобы у него менялась 
привязка его файл дескрипторов. вот эта волшебная команда
        $ exec bash 1>10.txt
так вот в описании билитина exec написано что это можно сделать еще короче.
цитирую
$ exec --help
exec: exec ... [command] ... [redirection ...]
...
 If COMMAND is not specified,
    any redirections take effect in the current shell.

тоесть тут написано что если не указать никакой команды то получается что он автоматом меняет дескрипторы
указанные в [redirection] для данного процесса. 
проверяем
    $ echo $$
    3208
    $ exec 1>11.txt
    $ 

проверяем в другом терминале
$ pstree -Asp 3208
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(3208)
$ ls -1al  /proc/3208/fd
lrwx------ 1 vasya vasya 64 окт  4 10:39 0 -> /dev/pts/26
l-wx------ 1 vasya vasya 64 окт  4 10:39 1 -> /home/vasya/11.txt
lrwx------ 1 vasya vasya 64 окт  4 10:39 2 -> /dev/pts/26
lrwx------ 1 vasya vasya 64 окт  4 10:39 255 -> /dev/pts/26

и действительно да. процесс 3208 не имеет никаких чайлдов. и его 1 имеет редирект на файл!
гоча!

я бы еще как сказал хотя это не совсем верно. что если мы никакую команду не подставляем в exec
то баш сам автоматом как бы подставляем bash тоесть  как бы 
    exec 1>11.txt = exec bash 1>11.txt
хотя это не совсем так. потому что в первом случае он не меняет бинарник в памяти а во втором случае
он удаляет старый бинарник и сует в процесс новый бинарник. (ксатти сказать процесс получается это как бы коробка (типа фреймворк) плюс начинка в виде бинарника)


двигаем дальше. вот еще интересный пример который нам пригодится
$ echo $$
3554
$ exec bash 12<>12.txt
$ echo $$
3554
[vasya@lenovo ~]$ ls -1al /proc/$$/fd
lrwx------ 1 vasya vasya 64 окт  4 10:49 0 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 1 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 12 -> /home/vasya/12.txt
lrwx------ 1 vasya vasya 64 окт  4 10:49 2 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 255 -> /dev/pts/29

мы говорим чтобы в нашем текущем процессе был заменен бинарник на баш
и чтобы  в нашем процессе был открыт новый файловый дескриптор с номер 12 и чтобы этот файловый дескриптор
был связан с файлом 12.txt который будет открыт с флагами и на чтение и на запись.
что примечательно в этой команде. примечательно то что мы можем изменить для данного процесса
число его файловых дескрипторов. было 0,1,2,255 (правда какого хрена тут делает 255 непонятно. вернее понятно.
я же запускаю bash из некоего другого процесса скажем это gnome-terminal или xterm или из под граф оболочки 
и открытые файловые дескрипторы в родительском процессе автоматом наследуются и дочерним процессом вобщем щас нам этот 255 неважен) а стало 0,1,2,255,12.
таким макаром мы можем "прикрепить" к процессу дохрена файловых дескрипторов и дохрена открытых файлов.
при том что самому бинарнику процесса на этот абсолютно плевать. вот эти открытые файлы , прикрепленные файловые
дескрипторы они бинарник ни к чему не обязывают. это как в квартире понаделать больше окон. 
если процесс нехочет ни читать с данного файлового дескриптора ни писать в него то его никто к этому не обязывает. это как у машины добавить запасных колес. или в ящике понаделать новых дырок. тот кто сидит в яшике (бинарник)  может пользоваться этими дырками а может и нет. опять же что интересно у нас обычно один процесс родительский порождает некий дочерний процесс и родитель может заказать для дочернего процесса понаоткрывать 
для него кучу файлов. но дочернему процессу это может быть глубоко фиолетово. он может пользоваться открытыми 
для него файлами а может и нет. это никак не влияет на него. 
что еще важно это вот значок  "<>" он на самом деле никакого мистического значения не имеет. он на самом деле 
только значит то что в сисколле будет прописано что открываемый файл открывается с флагами "R+W" тоесть 
и на чтение и на запись. сразу в догонку скажу что значок ">" говорит через сисколл ядру что нужно открыть файл 
с флагом "W" а значок "<" говорит ядру что файл нужно открыть с флагом "R"
тоесть то что изначально называется редиректом. это корявое определение. это не редирект это команда ядру 
на то  с каким флагом нужно открыть файл. тоесть 
        $  echo 1 1>4.txt
комбинация "1>4.txt" говорит башу как ему выстроить сисколл который он будет пулять в ядро. 
сисколл должен быть такой что - надо открыть файл 4.txt причем с флагом "W" и привязать этот файл к дескриптору 1. ну да.. на последнем этапе можно скзаать что мы имеем дело с редиректом. но важно подчеркнуть что значки
"<" и ">" и "<>" их смысл не только редирект но и с каким флагом открыт файл на который они ведут. 
">" =  W
"<" =  R
"<>" = RW

еще пример 
        $ echo "abc" 12<>5.txt
здесь ксати тоже интересно. дело в том что echo это билтин баша. поэтому ему ненужно себя клонировать.
а он выполняет команду ровно в текущем процессе. так вот для текущего процесса будет открыть файл 5.txt
в режиме "RW" и будет создан файловый дескриптор 12 который будет прикреплен к текущему процессу 
сам же echo ясен банан выплюнет свой "abc"  в дескриптор 1. тоесть ему этот открытый дескриптор 12 
в целом нахрен не сдался. просто мы делая одно одновременно сделали и другое
причем насколько я понимаю баш он умный и он откроет этот файл и создаст дескриптор но как 
только билтин закончит работу то баш автоматом закроет файл и уничтожит дескриптор. вот 
доказательство
    $ echo "abc" 13<>13.txt
    abc
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:12 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 2 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:25 255 -> /dev/pts/31
тоесть еще раз так как echo это билтин то никого нового процесса создано не будет. все
будет делать в рамках текущего баша. поэтому я и смотрю список открытых файлов для текущего процесса.
и видно что никакого дескриптора 13 нет и в помине. он был создан и тут же обратно удален.
я так это понимаю.

совершенно другой коленкор когда мы через баш запускаем некую внешнюю программу и просим баш прилепить к ней
открытый файл. баш составит нужный сисколл для ядра. и мы все будем иметь.
    $ sleep 130 14<>14.txt

с другого терминала смотрим
    $ ps aux | grep sleep
    vasya     4806  0.0  0.0  14580   892 pts/31   S+   11:28   0:00 sleep 130
    $ ls -1al /proc/4806/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:29 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 14 -> /home/vasya/14.txt
    lrwx------ 1 vasya vasya 64 окт  4 11:29 2 -> /dev/pts/31

тоесть у нас баш себя клонировал тоесть попросил ядро создать новый процесс. причем при клонировании попросил 
ядро чтобы дочерний процесс имел открый файл 14.txt через дескриптор 14.
далее баш в дочернем процессе попросил ядро через  сисколл заменить свой
бинарник на sleep.
поэтому все так выглядит
еще раз подчеркну что значок "<>" в конечном итоге означае то что файл 14.txt открывается с флагами и на чтение
и на запись. флаг "<" открывает файл на чтение только, флаг ">" открывает файл на запись только
причем имеется ввиду для данного процесса. ничто мне не мешает из другого процесса попросить ядро открыть этот файл с другими флагами. тоесть скажем наш процесс открывает файл только на запись. а с другого процесса я прошу
ядро открыть файл на чтение. и таким макаром я спокойно читаю то что пишет туда первый процесс.

также попутно я покажу докажу что когда баш запускаем внешний бинарник то он создает новый процесс 
клонирует себя а если мы запускаем баш билтин то новый процесс не создается.
я запутил баш с номером процесса 4309
в соседнем окне я запустил strace
$ sudo strace -p 4309 -e clone,fork,execve
strace: Process 4309 attached

и в первом окне я запустил ls -1
и мне strace нарисовал
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fe0cc338a10) = 4589

а потом я в первом окне запустил echo 1
и мне strace ничего не нарисовал
это все доказывает

теперь переходим к интересному.
зная все что мы узнали выше я открою файл /dev/cpu_dma_latency
в текущем баше так чтобы он оставался открытым
    # exec bash 16> /dev/cpu_dma_latency;
    # ls -1al /proc/$$/fd
    lrwx------ 1 root root 64 окт  4 11:37 0 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:37 1 -> /dev/pts/32
    l-wx------ 1 root root 64 окт  4 11:38 16 -> /dev/cpu_dma_latency
    lrwx------ 1 root root 64 окт  4 11:37 2 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:38 255 -> /dev/pts/32

ну или можно было короче написать
    # exec 16> /dev/cpu_dma_latency;
мы открыли /dev/cpu_dma_latency на запись и прикрепили его к процессу через дескриптор 16
показываю чему он равен прям щас 
    # cat /dev/cpu_dma_latency  | od -t x1
    0000000 00 94 35 77
    0000004

теперь можно его изменить вот так
    # echo -en "0x00000258" 1>&16
здесь так как echo у нас шлет свои данные на stdout тоесть в 1 то я перенаправил в 16.
на low level уровне это работает так что по дефолту баш юзает сискол
write (1,"текст")
а когда мы ему дали подсказку то он делает
write(16,текст)

проверяем что сработало
# cat /dev/cpu_dma_latency  | od -t x1
0000000 58 02 00 00
0000004
да сработало получается.
такой вывод наоборотный потому что в оперативку много байтовой число пишется в little endian формате.
об little endian  читай в ext4.txt

также отмечу вот это "1>&16" знак амперсанда говорит бащу что мы делает перенаправление не в файл  с именем 16 на файловой системе а в файловый дескриптор 16. это две большие разницы.
ксати я щас попробую сделать запись в несуществующий дескриптор
    # echo -en "0x00000258" 1>&28
    bash: 28: Bad file descriptor
все верно. пошел нахер


итак еще раз
что было сделано
     # exec 16> /dev/cpu_dma_latency;
     # echo -en "0x00000258" 1>&16
для текущего процесса баща был открыт файл /dev/cpu_dma_latency на запись. и прикреплен к процессу через
дескриптор 16. фишка в том что он будет висеть открытым пока я его сам руками не закрою.
далее я делаю запись в этот файл через подскажу башу что писать надо не в дескриптор 1 как он это обычно
делает по дефолту а в дескриптор 16. после записи файл который скрывается за дескриптором 16 продолжает висеть открытым.
тут еще раз также подчеркну что когда мы работаем с io redirect то между номером дескриптора и значком
редиректа категорически нельзя чтобы были пробелы. тоесть 
         # exec 16> /dev/cpu_dma_latency;   # правильная команда

         # exec 16 > /dev/cpu_dma_latency;  # НЕправильная команда
         сразу вылезет ошибка. потому что баш будет интепретировать эту команду вот так
         # exec 16 1> /dev/cpu_dma_latency;
тоесть он будет пытаться найти бинарник с именем "16", заменить в текущем процессе баш этим бинарником
и заменит файловый дескриптор 1 чтобы он вел не на терминал а на файл /dev/cpu_dma_latency
тоесть это совершенно не то что нам надо. поэтому 
        "16> /dev/cpu_dma_latency" = правильная хрень. обозначает что мы открываем файл /dev/cpu_dma_latency
        на запись и в для процесса прокидываем этот файл как дескриптор номер 16

        "16   > /dev/cpu_dma_latency" = неправильная хрень, если быть более точным она тоже правильная но она делает совершенно другое. она обозначает вот это 
        "16   1> /dev/cpu_dma_latency" 
то есть мы открываем файл /dev/cpu_dma_latency на запись и привязываем его к процессу через дескриптор 1.
и плюс к этому у нас бинарник имеет имя 16. 
поэтому смысл этих двух команд совершенно разный

а вот после значка ">" уже неважно есть пробелы или нет. оно все будет трактоваться одинаково тоесть
    "16> /dev/cpu_dma_latency"
    "16>/dev/cpu_dma_latency"
    "16>        /dev/cpu_dma_latency"
это все одно и тоже.
в целом конечно это дебилизм потому что сегодня я это помню. а завтра уже совершенно нет.


возвращаемся НАКОНЕЦ к нашей исходной задаче
нужно понять как это работает
        # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
кстати сразу замечу что 3 это не stderr (как я иногда глючу так думая), stderr это 2
а 3 это вобще ничего. потому что stdin это 0. stdout это 1 и stderr это 2
немного преобразуем это выражение
        # exec bash 3<> /dev/cpu_dma_latency; echo -en "0x00000258" 1>&3
строго говоря оно немного отличается от оригинала но по конечному результату это одно и тоже
зато все указано в явном виде и поэтому более понятно 
далее эту команду можно эквивалентно переписать как 
        # exec bash 3<> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
во первых я считаю что символ "<>" он излишен потому что мы собираемся писать туда а читать нет.
но в целом не особо важно конечно. но я считаю что вот это более грамотно.
поэтому преобразуем 
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
теперь все понятно. разберем его.
мы открываем файл на чтение /dev/cpu_dma_latency и прикрепляем этот  файл через дескриптор номер 3 у текущего баша. фишка в том что  файл будет висеть постоянно открытым все время. пока мы не закроем его 
специально сами руками. теперь если мы из баща будем писать в дескриптор 3 то оно будет лететь в файл
далее мы через echo посылаем число но не в канал 1 как это баш делает по дефолту а в канал 3.
таким макаром мы записали  число в /dev/cpu_dma_latency
казалось бы мы могли бы сделать проще вот так 
        # echo -en "0x00000258"  /dev/cpu_dma_latency
но это не привело бы нас к тому что нам надо потому что 
этот файл /dev/cpu_dma_latency он хитрый.нам надо чтобы файл оставался все время открытым после 
записи. если мы это делаем сразу через эхо. то как только эхо закончит то файл закроется и ОС перезапишет
значение на дефолтовое. так устроен этот файл. а вот верхний мудежный способ как раз дает то что после записи в эхо файл будет продолжать оставаться открытым и наше новое значение будет сохраняться. 
получается одна маленькая строчка из интернета но чтобы ее понять нужно диссертацию написать.
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
при этом получается пока наш процесс баша будет на компе сущестовать файл будет открыт
и наше записанное значение будет жить.
как только мы текущий баш процесс закроем. файл тоже закроется и значние будет со стороны ос перезаписано
на дефолтовое.
в принципе можно было сделать и вот так
        # bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
без выебонов с exec
у нас просто напросто создасться в системе +1 процесс с баш и только и всего. 
так что если расхлобучить все эти выебоны которые накручены в исходном выражении то вся фишка лишь в том
что для того чтобы открыть файл на постоянной основе надо заюзать вот это выражение
            # bash N> file
и только и всего.
тогда у нас  в системе будет баш процесс  у которого будет постоянно открытый файл "file" на запись
через дескриптор N. вот и все.

далее
теперь моя задача в том чтобы найти все процессы в которых открыты файл дескрипторы
ведущие на файл /dev/cpu_dma_latency
и закрыть все эти файл дескрипторы

# lsof -u root | grep cpu_dma_latency
bash       5106 root   16w      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6454 root    3u      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6828 root    3w      CHR              10,59      0t0        162 /dev/cpu_dma_latency

здесь видно какой процесс имеет этот файл открытым, через какой дескриптор, и  в каком режиме
открыт файл (r,w,rw)

и тут выясняется прикол (из того что я вижу навскидку из интернета) что нет такого красивого 
способа чтобы под рутом запустить команду и заставить позакрываться эти файловые дескрипторы. 
хаха.
тоесть вижу что есть только три неудобных способа
один это подключаемся к процессу через gdb и там запускаем команду на закрытие файла.
второй способ разыскать в граф оболочке наши конкретные терминалы с этими прям башами 
и уже из под них запускать команды на закрытие файлов
а ну и третий самый лоховской способ это поубивать эти процессы и автоматом и файлы закроются

я пойду вторым способом.
он состоит вот в чем.
причем в методичке там запаривают мозг что в завимости в каком режиме был открыть файл 
чтени, запись его нужно гасить по разному на самом деле нихрена. нам совершенно неважно как был открыт файл
    # exec 3> file
    # exec 3< file
    # exec 3<> file
нам на это наплевать 
во всех случаях гасим дескриптор совершенно одинаково
    # exec 3>&-
либо
    # exec 3<&-
а вот вариант 
    # exec 3<>&-
абсолютно нерабочий.
ПРИЧЕМ в данном случае абсолютно нельзя чтобы был пробел между ">" и "&-"
либо между "<" и "&-"
тоесть пробел запрещен не толко слева от знака редиректа но и справа
сразу выдаст ошибку!

поэтому в случае редиректов я бы советовал ни слева от знака редиректа ни справа не оставлять пробелов
чтобы не получать проблем на ровном месте


я в итоге предпочитаю гасить через 
    # exec 3> &-


метод закрытия файла через gdb
# gdb -p $PID
# p close($FD)

далее
интересный пример
    # $ cat /etc/passwd >&-
эквивалент этой команды
    # $ cat /etc/passwd 1>&-
так вот эта команда как работает,
баш создаст новый процесс , со своим бинарником,
и также мы ему указали что в новом процессе нужно уничтожить файл дескриптор 1
далее запустится бинарник cat  а далее прикол в том что по дефолту он пишет в 1  через
write (1, ...)
а 1  у нас нету поэтому на экране вылезет ошибка
    # $ cat /etc/passwd 1>&-
      cat: standard output: Bad file descriptor

можно сделать по другому
    #  tty
     /dev/pts/12
    # cat /etc/passwd 1>&- 1>/dev/pts/12
как ни странно это сработает. 
с новым процессом будет проделано все то что я описал в предыдушем примере
тоесть будет удален дефолтовый дексриптор 1 и будет создан новый который ведет в /dev/pts/12
и все окей. тоесть если указано несколько редиректов в строке то баш и выполняет последовательно 
слева направо хоть миллион таких редиректов 


далее
    $ exec 2>&1
это понятно дескриптор 2 будет иметь тот же бекенд что и дескриптор 1
амперсанд обязателен иначе 2 будет перенаправлен не в дескриптор а обычный файл с именем 1

далее
    $ exec  &>kuku.txt
это перенаправляет 1 и 2  в файл. причем только файл на диске.
перенаправление в файл дескриптор не работает
аналогичная команда
    $ exec 1>kuku.txt 2>kuku.txt
при этом вот это неработает
    $ exec 4<>kuku.txt
    $ exec &>&4
тоесть &> можно перенаправлять только на файлы на диске а не на дескрипторы. тоесть 
вот так только работает
    $ exec &>12.txt

далее. все это время я рассматривал только ">" "<" "<>"
что означало
    > = открыть файл на запист
    < = открыть файл на чтение
    <> = открыть файл на чтение и запись
и  я совсем забыл про ">>" и "<<"
что означает
    >> = открыть файл на запись и плюс флаг APPEND
    << = это совершенно отдельный флаг. я только знаю его вот такое применение
    $ cat <<EOF >1.txt
    12
    12
    EOF
кстати я точно проверил вот так уже неработает
    $ cat <EOF >1.txt
     bash: EOF: No such file or directory

далее
    $ <<vasya
> eee
> bbb
> vasya

тоесть команда просит нас ввести текс. как только мы заканчиваем на контрольном слове vasya
то ввод заканчивается. и никакой файл не создается.
как я понимаю что это аналог команды
    $ :<<vasya
    > eee
    > bbb
    > vasya

тоесть наш текст идет на stdin команды true и в итоге все это просто команды пустышка

далее
    $ >>kuku
эта команда просто напросто создат пустой файл kuku на диске
тоесть аналог этой команды вот такой
    $:>>kuku
или аналог
    $: 1>>kuku

далее
    $ ls >>filename 2>&1
аналог
    $ ls 1>>filename 2>&1
тоесть эта команда она создает процесс с бинарником ls
уничтожает стандартный 1 и создает новый 1 который ведет в файл с именем "filename"
уничтожает стандартный 2 и создает новый который смотрит туда же куда и 1 тоесть в файл "filename"


далее
    $ 2>&1
аналог
    $ :2>&1
все понятно


далее. 
в bash 4 добавили вот такую хрень
|& was added to Bash 4 as an abbreviation for 2>&1
тоесть
    $ vasya |& cat
это аналог
    $ vasya 2>&1 | cat
пример
    $ vasya 2>&1 | xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
    $ vasya  |& xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
 
тоесть хрень рабтает как. баш создает свой клон в новом процессе.
далее этот чайлд баш ищет бинарник вася, ненаходит его, выводит в 2 сообщение об 
ошибке. а у нас при этом когда процесс создавался то 1 была перенаправлена на 0 процесса xargs
и 2 была направлена тудаже куда 1. получается чайлд баш срет в 2 сообщение об ошибке
и оно автоматом прилетает на 0 xargs. и он то что получил высирает

далее выяснился конкретный пиздец с башем.
мы привыкли что в самоей левой позиции в строке обязательно идет команда 
а все аргументы пайпы итд обязательно идут справа. 
это настолько фундаментальная хрень что о том что это не так даже в голову не приходит
однако это не так. оказывается что можно вот так
    $ cat filename 
    filename
    kuku
    vasya
    $ 2>file2 0<filename cat | xargs echo   
    filename kuku vasya

тоесть левее команды можно абсолютно спокойно насовать редиректы! это пиздец
об этом я нашел случайно в сноске в bash advanced guide
то есть аналогичная в более привычном виде команда выглядит так
    $ cat 0<filename 2>file2 | xargs echo 

можно конечно еще более загадочно и с выебоном написать
    $ < filename cat > out
аналог тоесть более привычный вид
    $ cat 0<filename 1>out

вот еще пример с выебоном
    $ rpm2cpio < filename > $TEMPFILE
аналог
    $ rpm2cpio 0<filename 1>$TEMPFILE

а вот еще приме с приколом
как создать новый дескриптор который ссылается на уже существующий дескриптор
    $ exec 4>&1
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 02:44 0 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 1 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 2 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 4 -> /dev/pts/15

переводится команда так. в существующем процессе баш нужно открыть создать файловый дескриптор 4
и направить его на файл на который ссылается дескриптор 1. причем этот файл нужно открыть на чтение

еще один пиздец
    $ ls -l  1>/dev/null  16>&-
здесь я вывод от ls просто заткнул тем что перевел в null
и это не главное. главное это "16>&-" 
тоесть оказывается что можно давать команду уничтожить файловый дескриптор который 
и в помине у процесса нихуя нет. и ошибки при этом никакой не выдает. 

вот еще ебанутый пример
    $  <&2  ls  >/dev/null
его аналог
    $ ls  1>/dev/null   0<&2


вот еще ебанутый пример
    $ exec 3<&2
    $ exec 2>&1 >&3 3>&-
первая строка она в текущем процессе баша создает дескриптор 3 который ведет на тот же файл на который
указвыает дескриптор 2. причем этот файл для через дескриптор 3 будет открыт на чтение
тоесть в итоге 3 будет указывать на /dev/pts/19
вторая строка работает так. для текущего процесса баша дескриптор 2 будет уничтожен и создана заново
при этом он будет указыват на тот же файл на который указывает дескриптор 1. так как  1 указывает на /dev/pts/19
то и 2 будет на него указывать. причем в режиме на запись. 
следущим шагом будет уничтожен дескриптор 1 и создан заново при этом он будет указывать на файл на который
указывает дескриптор 3. а 3 указывает на /dev/pts/19 ( на основе информации из команды из первой строки)
поэтому 1 будет указывать на /dev/pts/19 причем в режиме на запись он откроет этот файл
на последнем шаге будет уничтожен дескриптор 3
здесь важно понять что работа с дескрипторами их создание и уничтожение идет слева направо. последовательно 
по шагам. также важно понять что если у нас написано что дескриптор 2 указывает на дескриптор 1 
как вот здесь "2>&1" то это нетак. не дескриптор ссылается на дескриптор а дескриптор ссылает на файл 
на который ссылает другой дескриптор. тоесть как только мы выяснили на какой файл ссылается дескриптор 1
то нам на него насрать. дескриптор 2 будет ссылаться не на дескриптор а на файл который является бекендом 
для дескритора 1. поэтому если потом позже мы удалим дескриптор 1 то проблемы у дескриптора 2 не будет 
никакой так как оне никогда не ссылался на дескритор 1. это тоже важно понять.
а вот на эту тему пример
        $ exec 4<filename 0<&4 1>&0 4>&-
        
        $ ls -1al /proc/16039/fd
        lr-x------ 1 vasya vasya 64 окт  5 03:08 0 -> /home/vasya/filename
        lr-x------ 1 vasya vasya 64 окт  5 03:08 1 -> /home/vasya/filename
        lrwx------ 1 vasya vasya 64 окт  5 03:08 2 -> /dev/pts/20


тоесть как это работает. для текущего процесса у нас открывается файл "filename" на чтение 
и привыязывается к процессу через дескриптор 4
на втором шаге у нас уничтожается прежний 0 и создается новый и он открывает на чтение тот файл на который ссы
лается 4 тоесть filename
на третьем шаге у нас уничожается 1  и создается заново и он открывает на запись файл на который ссылается 0
тоесть filename 
на последнем этапе у нас уничтожается дескриптор 4
от того что мы уничтожили дескриптор 4 это не означает что это как то повлияет на 0. потому что 0 указывает
не на 4 а на файл на который указывал 4 тоесть на filename
пиздец

далее. шок
внещняя по отношению к башу команда cat
она почемуто читает данные не из 0 а из 3 !!!
показываю:
    $ cat /dev/urandom > /dev/null

    $ ls -1al /proc/21031/fd
    lrwx------ 1 vasya vasya 64 окт  5 10:15 0 -> /dev/pts/16
    l-wx------ 1 vasya vasya 64 окт  5 10:15 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 10:15 2 -> /dev/pts/16
    lr-x------ 1 vasya vasya 64 окт  5 10:15 3 -> /dev/urandom

хотя в приниципе нормально. для cat штука "/dev/urandom" является параметром и бинарник cat когда он запустился
анализирует с каким параметрами командной строки он был запущен и волен открывать файл под любым дескриптором.
в том числе и под дескриптором 3.
скорее я капитально ошибся думая что параметр командной строки почемуто должен быть открыть катом через 
дескриптор 0. это же чушь. через 0 cat принимает данные из терминала. а через 3 он принимает данные из файла.
все конечно же должно быть так.

далее еще прикол про cat
    $ cat 1.txt 2.txt
если так запустить то cat вначале откроет 1.txt полностью его прочитает и выдаст в 1, закроет его,
потом только откроет 2.txt 
а не так как я думал что он одноврменно откроет два файла. нет так он не делает.

далее еще прикол
    $ <<EOF
    > aa
    > bb
    > EOF
насколько я понимаю эквивалент команды это 
    $ :<<EOF
либо
    $ true<<EOF
тоесть невидимая команда это ":" или "true" что одно и тоже.
и  в нее скармливается текст из терминала
как работает "<<EOF" насколько я понимаю когда мы тыкаем enter то текущий баш он видит эту хрень 
и делает вывод что мы хотим написать в терминале какойто текст, он дает нам написать в терминале наш текст,
засасывает внутрь себя И ТОЛЬКО ПОТОМ он клонирует себя в новый процесс и как я понимаю он где то сохраняет
засосанный текст из терминала и после того как склонировал себя то он наверное из родительского процесса
видимо через пайп скармливает засосанный текст в stdin чайлд процесса.
тоесть если у нас есть вот такая команда
    $ команда <<EOF 
то ее эквивалент
    $ echo -en "aaasdas\n asdasdsdasd\n" | команда 
или еше пример
    $ cat<<EOF > 1.txt
ее аналог в более понятной форме
    $ echo -en "aaaa\n bbb\n" | cat > 1.txt 
этим описанием я хочу подчеркнуть что "<<" не имеет никакого отношения к cat! это фича либо самого терминала
либо баша скорей всего баша. поэтому "<<" можно прихуяривать с любой программой. самое главное что программа должна ожидать получить какието данные из stdin. пример
    $ xargs echo <<EOF
    > "aaa"
    > "bbb"
    > EOF
    aaa bbb
тоесть эта команда эквивалентна
    $ echo "aaa bbb" | xargs echo
    aaa bbb

работает это так. мы тыкаем Enter. баш начинает анализировать строку  "xargs echo <<EOF"
видит конструкцию "<<EOF" и понимает что пока что делать ничего нельзя. прежде всего нужно считать 
некий текст из терминала. поэтому баш останавливается и ждет чтобы мы набили в терминале текст.
мы его набивает. баш его где то запомиает в своих кишках. потом он клонирует себя. запускает в чайлде
xargs и видимо через пайп передает из родительского процесса из своих кишок запомненный текст 
на stdin дочернего процесса.

далее я возвращаюсь к cat
у него есть такой прикол
    $ cat 1.txt - 2.txt
эта хуйня должна работать так вначале кат открывает файл 1.txt полностью его читает и выводит  на терминал.
потом кат ждет наших данных прям с терминала. он их считывает и выводит на экран. потом мы както должны обьяснить кату что мы больше не хотим вводит из терминала. и он тогда должен открыть 2.txt и его прочитать
и вывести на экран. на данный момент прблема в том что я не понимаю как этому кату обьяснить тот момент
когда я хочу закончить ввод из терминала
значит я не знаю как из терминала обьяснить кату что мы закончили ввод тоесть
    $ cat -
я не понимаю как закончить ввод с терминала
зато вот можно сделать такой прикол
вот есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777

тогда можно сделать вот такой фокус
   $ echo "111" | cat 6.txt - 7.txt
    666
    111
    777
круто??!?!?!?!?

во! я узнал как в терминале что надо нажать чтобы обьяснит терминалу и cat что я закончил
вводить текст и мы достигли "конец файла EOF" . оказывается это комбинация Ctrl+D
показываю имеем два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
тогда пуляем такую команду
    $ cat 6.txt - 7.txt 
    666  <=== это кат вывел содержимое 6.txt
    aa   <=== это мы ввели руками в терминале
    aa   <=== это кат вывел то что мы ввели
    bb   <=== это мы ввели руками в терминале 
    bb   <=== это кат вывел то что мы ввели руками, и тут я нажал Ctrl+D
    777  <=== это кат вывел содержимое файла 7.txt
круто!!!!!

далее. итак я выяснил что 
    $ cat 1.txt
приводит  к тому что кат откроет файл 1.txt через файловый дескриптор номер 3 
еще раз показываю на примере
    $ cat /dev/urandom 1>/dev/null
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
четко видно что файл открыт через дескриптор номер 3
а если мы хотим чтобы cat начал читать файл через дескриптор 0 то это запускается
совсем по другому
    $ cat /dev/urandom | cat 1>/dev/null
вот как выглядит открытые файлы у второго кат
    $ ls -1al /proc/22921/fd
    lr-x------ 1 vasya vasya 64 окт  5 11:18 0 -> 'pipe:[2312995]'
    l-wx------ 1 vasya vasya 64 окт  5 11:18 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:18 2 -> /dev/pts/18
в этом случае поток засасывается из 0 который ведет в пайп. но дело не в пайпе. а то что
в таком случае поток забирается из 0
возвращаюсь к случаю когда кат читает из файла который мы указали в командной строке
    $ cat /dev/urandom
мы имеем вот такой список открытых дескрипторов
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
так вот понятно что у нас на экране будут лететь символы
можно даже вот такой пример сделать чтобы на экране были только буквы 
    $  cat /dev/urandom | od -t x1
так вот возникает вопрос а что если мы вэто время будем конпки на терминале тыкать будет ли
их параллельно пихать на экран cat или нет. отвечаю конечно нет! 
как я уже сказал раз мы указали cat файл в командной строке как аргумент то он читает данные
только из дескриптора 3. а планов читать в это время  у него из stdin из 0  у него нет! поэтому
тыкать в терминале кнопки в это время нет никакого эффекта!

далее еще полезный момент
    $ echo 113 | cat
    113
    $ echo 113 | cat -
    113
результат один и тот же. однако во втором случае мы в более явной 
форме обьясняем кату что мы хотим чтобы он данные принимал из 0






далее я перехожу к мудежной но знаковой важной теме 
называется она 
>>> bash process substitution <<<
выглядит это так
    $ команда1 >(команда2)
например 
    $  cat - >(sleep  160)
и работает это так
создается  pipe.
и тут важно скзаать что книжка "bash advanced scripting" на которую я опираюсь нередко пишет 
полную хуйню. так и в этот раз. книжка пишет что создается named pipe. на самом деле нихуя. 
создается anonymous pipe. тут я делаю отсылку на pipe.txt чтобы прочитать про то что такое пайпы.
итак создается неименованный пайп а именно анонимный! выглядит он так
        'pipe:[2498298]'
где что и как щас станет понятно
    $ ls -1al /proc/5013/fd
        lrwx------ 1 vasya vasya 64 окт  6 10:41 0 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22
        l-wx------ 1 vasya vasya 64 окт  6 10:41 63 -> 'pipe:[2498298]'  <====
    $ ls -1al /proc/5014/fd
        lr-x------ 1 vasya vasya 64 окт  6 10:41 0 -> 'pipe:[2498298]'   <====
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22

так вот ядро создало анонимный пайп где то там в своих кишках памяти 'pipe:[2498298]'
далее запускается команда2 и ее stdin конец присоединяется к анонимному пайпу 'pipe:[2498298]'

далее запускается команда1 и ей в качестве аргумента командной строки передается адрес файла /dev/fd/63
то бишь /proc/pid1/fd/63
показываю:
    $ ps aux | grep cat
     vasya     5013  0.0  0.0  14720   744 pts/22   S+   10:40   0:00 cat - /dev/fd/63

где /dev/fd/63 это симлинк на /proc/self/fd/63 тоесть то бишь /proc/pid1/fd/63
нихуя себе! да?
тоесть команда 1 была по факту запущена в виде
    $ cat - /dev/fd/63
и соотвественно программа cat обрабатвыает этот аргумент строки 
и открывает этот файл под каким то дескриптором ну точнее как видно из практики под дескриптором 63
и таким макаром у первой программы мы имеем
        63 -> 'pipe:[2498298]'
у второй программы мы имеем
        0 -> 'pipe:[2498298]'
если первая программа захочет и будет писать в дескриптор 63 то это летит в пайп 
и если вторая программа будет читать если захочет из дескриптора 0 то она будет читать из пайпа.
таким макаром пайп обеспечивает связь между двумя процессами.
во втором процессе пайп присоединяется к 0
а в первом процессе имя файла пайпа (/proc/pid1/fd/63) передается программе как аргумент в строке.
соотвесвтенно если первая программа такова что она не собирается писать данные в файл который указан  в ее 
строке то второй програме нихрена и не прилетит.  тоесть bash process substituition это более специфический
процесс связи между программами.  классический анонимный пайп вида $ echo | cat более бронебойный способ 
потому что он вставляет пайп на stdout первого процесса и сует на stdin второго процесса.
если первый процесс чтото высирает на stdout а второй процесс чтото желает читать из своего stdin (что вобще то говоря не факт) то связь между процессами обеспечена.
в случае же bash process subsitution связь заработает только если первый процесс умеет писать в файл имя которого ему передали как аргумент в строке. вот что надо подметить.! но еще раз подчеркну что в bash process
substition используется анонимный пайп. а не именнованный как это суки эти пищут в bash advanced guide книжке


еще пример
    $ echo >(true)
    /dev/fd/63
почему так. потому что в конечно итоге будет запущена команда
    $ echo /dev/fd/63
обьясню почему. мы вбили команду в баш. баш анализирует строку и видит в ней кусок ">(true)"
для баша это означает что нужно этот кусок заменить на имя файла. что за файл?  файл в папке 
/dev/fd/63. по факту это симлинк на файл /proc/self/fd/63 то бищь /proc/pid1/fd/63
почему именно 63? я так думаю это какойто хардкод число в ядре с которого он создает эту хрень.
и между прочим это тоже симлинк и ведет он на анонимный пайп 
        /proc/pid1/fd/63 --> 'pipe:[2498298]'
когда пайп создан и когда ссылка на него создана то баш подставляет в оригинальную команду и запускает 
ее 
     $ echo /dev/fd/63
поэтму мы на экране видим 
    /dev/fd/63
помимо этого баш создает новый процесс и запукает там вторую команду "true"
и к ее stdin присоединяет этот же анонимный пайп тоесть
          /proc/pid2/fd/0 --> 'pipe:[2498298]'
конкретно в даннном случае вся команда целиком неимеет никакого практического смысла
потому что echo абсолютно не собирается писать в файл /dev/fd/63 по своей природе
а команда true не собирается ничего читать со своего stdin 
поэтому это пример чисто работающий но бесполезный     потому что данные через пайп
от первой команды ко второй не передаются


а вот пример где данные уже передаются
    $ cp /dev/urandom >(pv 1>/dev/null)
     147MiB 0:00:06 [21,0MiB/s] [                   <=>                           <=>    

работает это так что данные из /dev/urandom пихаются в пайп
а из него их читает pv и рисует картинку

более подробно  как это работает 
работает также как в прошлом примере
вот мы вбили команду
    $ cp /dev/urandom >(pv 1>/dev/null)
нажали Enter
бащ анализирует эту строку.  и видит комбинацию ">(pv 1>/dev/null)"
тогда баш понимает что все не так просто и создает аононимный  пайп где то там  в памяти вот 
такую хрень 'pipe:[2498298]'
далее бащ создает новый процесс и в нем запускает "pv". когда  баш создает этот процесс через сисколл
то просит у ядра чтобы оно присоединило к stdin дочернего процесса наш пайп
и выглядит это так
        /proc/pid2/fd/0 --->  'pipe:[2498298]'
далее баш берет оригинальную команду и меняет ее из вот такой
        $ cp /dev/urandom >(pv 1>/dev/null)
в такую
        $ cp /dev/urandom /dev/fd/63
где /dev/fd/63 в конечном итоге ведет в тот же самый пайп 'pipe:[2498298]' тоесть
        /dev/fd/63 --> /proc/self/fd/63 ---> 'pipe:[2498298]'

соотвевственно команде cp похеру что там на том конце у /dev/fd/63
она просто копирует данные из /dev/urandom в /dev/fd/63
таким макаром данные улетают в пайп.
и таким же макаром вторая команда читает свой stdin и получает данные из пайпа.

можно привести пример когда работает наоборот
    $ cp <(cat /dev/urandom) /dev/null
работает это так что () кидает их в свой stdout который направлен в пайп
а команда cp будет запущена в виде
    $ cp /dev/fd/62 /dev/null
где /dev/fd/63 тоже смотрит в пайп
таким макаром данные из stdout () поступают в пайп оттуда в /dev/fd/62 а оттуда в cp 

да уж..


а вот еще пример
    $  cp /dev/urandom >(echo "печать из субшелла"; pv 1>/dev/null)
    печать из субшелла
    66,2MiB 0:00:01 [37,1MiB/s] [     <=>           ]
получается вот что. вначале то что вылетает из cp пристыковывается через пайп к stdin команды echo.
но ей посрать на то что поступает к ней из stdin поэтому она просто печатает текст на экране и заканчивает
свою работу. данные при этом в пайпе как лежали так и лежат ( деньги в копилке так и лежат)
тогда далее запускается pv и уже к ней пристыковывается  пайп на ее stdin 
и так как pv как раз таки и и ждет поступления данных из stdin то pv начинает выкачивать данные из пайпа

тоесть фишка в том что у нас наш пайп был подключен и к одной команде и другой. а с классическим анонимным пайпом так хрен сделаешь наверно...


а вот еще очень важный пример
    $ echo "11" 1>(echo "первый привет из субшелл"; cat)
    11 1/dev/fd/63

что я хотел в этом примере добиться. я хотел чтобы вывод эха был перенаправлен в ()
но это не получилось хотя я якобы настроил редирект для 1. ошибка в том что баш заменил
конструкцию ">(echo "первый привет из субшелл"; cat)" на "/dev/fd/63" в итоге echo был запущен
буквально вот так
    $ echo "11" 1/dev/fd/63
поэтому то мы на экране и увидели вот эту хрен незапланированную 
    11 1/dev/fd/63
а чтобы все заработало как надо - надо вот так
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat)
    первый привет из субшелл
    11

значит в нем редирект настроен как "1>" а файл в который мы редиректим указан как ">(echo "первый привет из субшелл"; cat)"
в итоге и получается вот такая удивительная конструкция! c двумя галками через пробел "> >"
тоесть пример у нас расшифрорвывается так:
напечатай 11 но при этом stdout мы перенаправляем в именованный пайп который ведет в субшелл
далее. вначале именнованный пайп с 11 внутри прилепляется к stdin команды 
    echo "первый привет из субшелл";
но ей похеру то что у нее сидит на ее stdin
поэтому она просто на экране печатает приветствие и заканчиывает работу
тогда запускается команда cat у которой именованный пайп подключен к ее stdin
и вот тут наконец 11 из верхней эхо поступает на stdin команды кат. и она его печатает. 
в итоге мы получаем на экране
    первый привет из субшелл
    11


возникает вопрос а что будет у такой команды?
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
возникает вопрос чтото из верхнего эхо доберется до второго cat?
ответ конечно нет. потому что пайп уже весь опустошен на первом cat
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    11
    второй  привет из субшелл



а вот еще очень интересный пример
вот у нас есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
запускаем такую команду 
    $ cat 6.txt 7.txt  1> >(echo "первый привет из субшелл"; cat -; echo "второй  привет из субшелл"; cat -;)
    первый привет из субшелл
    666
    777
    второй  привет из субшелл


вопрос был вот в чем. когда у нас верхний cat закончит передавать первый файл и первый cat в субщелле закончит 
его печать то закончит ли cat в субшелле свою работу и передаст ли второй echo в субщелле управление
или нет. практика нам показала что первый cat в субшелле посрал на то что первый файл закончился 
и работал до упора напечатал оба файла и только потом закончил работу и передал управление дальше.
поэтому второй cat оказался полностью пустой. к нему по пайпу ничего не прилетело.



вот еще пример на эту тему
вот у нас есть файл 
    $ cat 6.txt 
    666
запускаю такую команду
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
в ней я говорю что  я буду пихать в головной cat вначале данные сам руками из терминала.
а потом как закончу данные в cat еще поступят из файла 6.txt
мой вопрос до второго cat в субшелл чтото долетит или нет?
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    вася  <=== это  я ввел руками в терминале
    вася
    петя  <=== это  я ввел руками в терминале
    петя
          <== тут я нажал Ctrl+D (EOF) и cat прекратил читать из терминала и начать читать файл 6.txt
    666   <== содержимое файла 6.txt
    второй  привет из субшелл


так вот видно то что первый cat в субшелле сидел и ждал данные до упора. она 
вначале дождался данных из того что я втермиале печатал. а потом он еще напечатал то что в 6.txt
и только после этого он закончил свою работу. и поэтом до второго cat в субшелле уже ничего не долетело
сверху. вот это и я хотел исследовать



еще малек пример про редирекшн.
пример
    $ echo -e 1>15.txt
я хотел изначально записать "1" в 15.txt
а как очевидно понятно я ошибся. и по факту обозначение "1>15.txt"
привело к тому что файловый дескриптор 1 стал указывать на 15.txt 
а не то что символ 1 был напечатан на экран. 
надо было вот так делать чтобы 1 на экране напечатался
    $ echo -e "1"   1>15.txt
вот как было правильно




теперь НАКОНЕЦ я возвращаюсь к тому примеру с которого начал изучение редиректов 
        $ exec &> >(tee -a ./1.txt)
теперь наконец  эта тарабарщина понятна!
"&>" дает то что stdin и stderr оба будут перенаправлены в некий файл. а что за файл?
а это как раз указано дальше , файл такой что он указывает на анонимный пайп из "bash process substitution" 
обычно это файл 
        /dev/fd/63 ---> /proc/self/fd/63 ---> 'pipe:[2498298]'

баш начнет анализировать всю эту команду после нажатия enter  и попросит ядро создать пайп 'pipe:[2498298]' 
где то в памяти ядра, далее баш 
произведет в исходной строке замену 
было
    $ exec &> >(tee -a ./1.txt)
стало
    $ exec &> /dev/fd/63

в доказательство этого я выполнил strace чтобы это поймать
    # strace -p 7859 -f  -s80  -e openat
    [pid  7859] openat(AT_FDCWD, "/dev/fd/63", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
причем этот файл присутствует именно в openat а не в execve
удивительно

далее баш выполнит команду exec и тогда у текущего баша поменяется два дескриптора. 1 и 2 (stdout и stderr)
раньше скорей всего они смотрели на файлы терминало /dev/pts/22
а станут смотреть на пайп
        /proc/bash_pid/fd/1 ---> 'pipe:[2498298]'
        /proc/bash_pid/fd/2 ---> 'pipe:[2498298]'

далее баш запустит еще один процесс и там запустит tee
к stdin дескриптору этого процесса он прилепит тот же пайп 
        /proc/tee_pid/fd/0 ---> 'pipe:[2498298]'

в итоге все что баш будет бросать на stdout\stderr будет направлено в пайп
и будет считано из пайпа командой tee и отрисовано на окне терминала и продублировано  в физ файл на физ диске.

хотелось  почеркнуть что отрисовка вывода в терминале будет идти не засчет головного баша
а за счет tee в субшелл.
посмотрим теперь на практике
    $ exec &> >(tee -a 1.txt)
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 13:11 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 1 -> pipe:[2331898]   <====
    l-wx------ 1 vasya vasya 64 окт  5 13:11 2 -> pipe:[2331898]   <====

    $ ps aux  | grep tee
    vasya    26155  0.0  0.0  14588   792 pts/17   S    13:10   0:00 tee 1.txt
    $ ls -1al /proc/26155/fd
    lr-x------ 1 vasya vasya 64 окт  5 13:11 0 -> pipe:[2331898]   <====
    lrwx------ 1 vasya vasya 64 окт  5 13:11 1 -> /dev/pts/17
    lrwx------ 1 vasya vasya 64 окт  5 13:11 2 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 4 -> /home/vasya/temp/1.txt

из чего действительно видно что в головноv баше stdin и stdout указывают на пайп [2331898]
а в процессе "tee" ее stdin смотрит в тотже самый пайп [2331898]
тоесть теория совпала с практикой


далее я покажу что будет напечатано в 1.txt
если в исходной терминале будет выглядеть вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

то в 1.txt будет вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

что интересно новые буквы будут появляться в файле не тогда когда мы воригинальном терминале 
нажали enter а уже тогда когда мы в терминале нажали просто букву!
что еще более поразительно. если мы сотрем букву на оригинальном терминале то эта буква также сотрется 
и в файлле ! amazing!
вот это тема.... охренеть


возникает удивительный вопрос а нахуй этот механизм нужен на практике? покажите
пример практический когда это может пригодится?

еще пример
еще:
    $ echo 1 >(cat)
        1 /dev/fd/63
ну понятно. строка 
    $ echo 1 >(cat)
будет заменена на
    $ echo 1 /dev/fd/63
отсюда результат


далее
    >&, &>
есть ли разница.
обычно нет. но лучше юзать &>
по смыслу эта команда перенаправляет sterr и stdin в один файл
который обязательно нужно укзаать после тоесть
    $ echo "aaa" &> /tmp/1.txt
эквиваелент
    $ echo "aaa" 1>/tmp/1.txt 2>&1
либо
    $ echo "aaa" 1>/tmp/1.txt 2>/tmp/1.txt


далее
    >|
тут интересно. баш имеет ряд крутилок настроек.
настроки подкручитваются через баш билтин set
    $ set --help
в частности вот так крутятся настройки
    $ set +o pipefail -o noclobber
посмотреть текущие настройки вот так
    $ echo $-
хотя там не информативно. а более информативно вот так

$ set -o
set -o
+ set -o
allexport       off
braceexpand     on
emacs           on
errexit         off
errtrace        off
functrace       off
hashall         on
histexpand      on
history         on
ignoreeof       off
interactive-comments    on
keyword         off
monitor         on
noclobber       off
noexec          off
noglob          off
nolog           off
notify          off
nounset         off
onecmd          off
physical        off
pipefail        off
posix           off
privileged      off
verbose         on
vi              off
xtrace          on

видно опять же как я сказал что noclobber выключена.
если она включена то ">" не даст перезаписать существующий файл. выдаст ошибку.
у нас опция выключена поэтому ">" перезатирает файл без всяких ошибок.
так вот если все таки noclobber активирована то ">|" позволяет игнорировать эту настройку.  
в общем в итоге ">|" малополезная хрень.
я еще ни разу не встречал чтобы noclobber был хоть где то активирован.

далее пример. 
я нашел более менее пример который уже как то типа может быть полезен на практике.
есть два файла
    # cat 7.txt 
        a
        b
        c
    # cat 6.txt 
        1
        2
        3

есть интересная команда "paste" она читает из нескольких файлов по одной строке
и печатает это на экране через TAB
    # paste 6.txt 7.txt 
        1   a
        2   b
        3   c
так вот как это же можно сделать через bash process substitution 
    # paste <(cat 6.txt) <(cat  7.txt)
        1   a
        2   b
        3   c
ну когда мы читаем из готовых файлов то пример мало полезен. а вот когда 
нам надо прочитать из stdout нескольких процессов и все это построчно соединить в таблицу
на экране то bash process substitution уже становить реально полезен
    # paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp)
        INT3400 Thermal 20000
        pch_cannonlake  40000
        B0D4    0
        x86_pkg_temp    42000


как написано в мануле утилита "paste" позволяет соединить строки нескольких файлов вместе.
тоесть еще пример
    $ cat 1.txt 
        aaa
        bbb
        ccc 
$ cat 2.txt 
        5
        6
        7 
$ paste 1.txt  2.txt 
        aaa 5
        bbb 6
        ccc 7 

разделение идет через TAB


далее я опишу утилиту colrm
это частично идиотская утилита потому что ее man нагло врет
    $ colrm start stop
утилита удаляет из текста колонки с номерами  
    start << колонка << stop
причем разделителя колонки никакого нет. это ни пробел  ни TAB
это всегда банально номер символ в строке. показываю
в этом примере будет удалены символы 3 и 4
их позиция в строке и является так называемой "колонкой"
    $ echo -e "123456789" | colrm 3 4
    1256789
если указать только стартовую колоноку то он удаляет вот такие колонки
    start << колонка << EOL
пример
    $ echo -e "123456789" | colrm 3
    12
в целом убогая утилита



далее я опишу утилиту column
она позволяет назначить разделитель и потом отформатировать текст по колонкам.
но по мне утилита корявая. она порой работает хер знает как.
итак имеем файл
    $ echo -e "1+2+3+4+5\n6+7+8+9+10"
    1+2+3+4+5
    6+7+8+9+10
воспользуемся недавно узнанной штукой "bash process substitution"
    $ column -t -s "+" <(echo -e "1+2+3+4+5\n6+7+8+9+10")
    1  2  3  4  5
    6  7  8  9  10
так вот утилита column 
ее ключ -е без него вобще ничего не работает. считай что он значит что надо отформатировать текст
ключ -s "+" означает что разделитель между колонками "+"

далее важно дополнение. выравнивание в колонке идет всегда по левому краю.
пример про это
    $ echo -e "111111111+2+3+4+5\n6+7+8+9+10"
    111111111+2+3+4+5
    6+7+8+9+10

    $ column -t -s "+" <(echo -e "111111111+2+3+4+5\n6+7+8+9+10")
    111111111  2  3  4  5
    6          7  8  9  10

порой эта прога как уже сказал работает непонятно как . но если ее применить несколько раз
то вроде можно получить вменяемый результат
практический пример 
имеем вот такой вывод.
почему то cpupower хреновато форматирует свой текст
можно заметить что "Freq" и "POLL" поплыли
    $ sudo cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6   || C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,02|  1,37| 59,17|  0,00||  0,88| 99,12|   632||  0,00|  0,00|  0,00|  0,02|  0,47|  0,00|  3,36|  0,16| 95,13
   4|  0,02|  1,37| 59,17|  0,00||  2,33| 97,67|   577||  0,00|  0,00|  0,03|  0,01|  1,36|  0,00| 14,02|  0,08| 82,29
   1|  0,13|  0,42| 59,17|  0,00||  1,66| 98,34|   598||  0,00|  0,74|  0,18|  0,09|  0,23|  0,00|  7,52|  0,03| 89,59
   5|  0,13|  0,42| 59,17|  0,00||  1,06| 98,94|   600||  0,00|  1,82|  0,00|  0,06|  0,26|  0,00| 10,37|  1,03| 85,34
   2|  0,00|  0,27| 59,17|  0,00||  1,70| 98,30|   657||  0,00|  0,00|  0,01|  0,02|  0,02|  0,00|  4,72|  0,00| 93,46
   6|  0,00|  0,27| 59,17|  0,00||  0,32| 99,68|   623||  0,00|  0,00|  0,02|  0,00|  0,20|  0,00|  4,52|  0,00| 94,87
   3|  0,09|  0,98| 59,17|  0,00||  0,87| 99,13|   609||  0,00|  0,94|  0,73|  0,03|  0,48|  0,00|  7,93|  0,00| 89,05
   7|  0,09|  0,98| 59,17|  0,00||  1,62| 98,38|   568||  0,01|  0,66|  0,04|  0,10|  0,76|  0,00| 14,12|  0,00| 82,69


отформатируем этот текст
    $ sudo cpupower monitor | column -t -s "|" | column -t -s " " | grep -v Nehalem
CPU      C3     C6          PC3    PC6   C0    Cx     Freq  POLL  C1    C1E   C3    C6    C7s   C8     C9    C10
0        0,02   1,22        52,58  0,00  1,20  98,80  645   0,00  1,92  0,17  0,02  0,23  0,00  9,80   1,11  85,57
4        0,02   1,22        52,58  0,00  1,84  98,16  623   0,00  0,00  0,24  0,04  1,83  0,54  11,55  0,38  83,64
1        0,08   0,40        52,58  0,00  1,76  98,24  631   0,01  0,00  0,02  0,09  0,48  0,00  8,84   0,00  88,81
5        0,08   0,40        52,58  0,00  3,34  96,66  674   0,00  1,05  1,26  0,00  0,16  0,40  6,78   0,07  86,95
2        0,06   2,54        52,58  0,00  2,61  97,39  666   0,00  0,11  0,85  0,01  0,72  0,00  8,97   0,07  86,65
6        0,06   2,54        52,58  0,00  2,02  97,98  646   0,00  0,00  0,03  0,10  3,00  0,00  10,23  0,06  84,53
3        0,03   0,71        52,58  0,00  5,44  94,56  654   0,00  0,00  0,00  0,05  0,68  0,00  15,06  0,09  78,67
7        0,03   0,71        52,58  0,00  0,75  99,25  635   0,00  0,00  0,01  0,01  0,09  0,00  6,79   0,00  92,28

в плане ключа -s который указывает разделитель колонок
так вот возникает вопрос как указать в качестве разделителя например знак табуляции
в мануале об этом нет ни слова. так вот ответ вот как
    -s $'\t'
а вот пример
    $ echo -e "1\t2\t3\t"
    1   2   3   

    $ echo -e "1\t2\t3\t" | column -t -s $'\t'
    1  2  3

утилита column работает так что она удаляет из строк сам знак разделителя
и заменяет его на пробел. или пробелы. по своему усмотрению. поэтому в примере выше она убрала
табы и вставила пробел как разделитель заместо

а теперь более менее практический пример где эта утилита может пригодится реально
исходный текст
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с"
    'температура датчика'   'скорость'  'высота'
    30°C    12 м\с

прикол в том что между колонками TAB а внутри колонки у нас пробелы могут быть.
а мы хотим выровнять.
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с" |  column -t -s $'\t'
    'температура датчика'  'скорость'  'высота'
    30°C                   12 м\с



а вот пример ради которого я долбался писал выше описание для 
утилит paste, bash process substitution, sed 
( кстати о том как работает sed смотри в sed-awk-cut-tr.txt )
итак встретился в инете такой пример.
в нем column он заменяет разделитель TAB на пробел,
а sed берет три последние символа, запоминает третий слева символ в группу 1,
и вместо трех последних символов вставляет точку плюс символ который сохранен в группе 1 и 
далее градус с цельсием. например в конце было 20000, значит три берем три последних символа это "000"
запоминаем третий слева в группу 1 это "0" и заменяем в итоге на ".0°C"
    $ paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp) | column -s $'\t' -t  | sed 's/\(.\)..$/.\1°C/'

    INT3400 Thermal  20.0°C
    pch_cannonlake   37.0°C
    x86_pkg_temp     39.0°C


далее еще пример про редирект
    $ echo "456" | ssh thinkpad cat - 1>~/7.txt
прикол в том что редирект будет идти не в файл на удаленном компе. нееееееет.
файл будет записан на этом компе!
чтобы записать файл на удаленный комп нужно
    $ echo "456" | ssh thinkpad cp /dev/stdin ~/7.txt


| {!var}
как нам напечатать переменную имя которой хранится в дургой
переменной.
    $ a="1"
    $ b="a"
эта хрень нам даст просто то что лежит в $b
    $ echo "$b"
    a
а вот уже эта хрень нам сделает двойное раскрытие имени переменной и напечатает то что лежит в $a
    $ echo "${!b}"
    1
причем важно заметить что надо именно вот так сохранять имя переменной
    $ b="a"
если сделать вот так
    $ b='$a'
то раскрыть такое не полуxится и баi пошлет нахер
    $ echo "${!b}"
    bash: $a: bad substitution
а если сделать вот так
    $ b="$a"
то тоже ничего хорошего не полуxится
    $ b="$a"
    $ echo "$b"
    1
    $ echo "${b}"
    1
итак только такой вариант работает
    b="a"

    
    
    
| <<<
пока что детално неразбирался но 

    $ bc <<< 2*3
    6
тоесть это некий аналог 
    $ echo -n "2*3" | bc

    

    
    
| ${#parameter}
| ${#var}

вычисляет длинну переменной
    $ a="123"
    $ echo ${#a}
    3

если у нас скрипт то 
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"
    $ ./03.bash 1
    первый параметр = 1, длинна первого параметра = 1
    $ ./03.bash 12
    первый параметр = 12, длинна первого параметра = 2
    $ ./03.bash 
    первый параметр = , длинна первого параметра = 0

в данном случае #1 это первый аргумент передаваемый в скрипт


еще один пример
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"

    for ((i=0; i<${#1}; i++))
    do
        echo "i = $i"
    done


    $ ./03.bash 5
    первый параметр = 5, длинна первого параметра = 1
    i = 0

поскольку длинна первого аргумента скрипта "5" равна единице то цикл for имеет параметры
i=0, i<1, i++
поэтому он отрабатывает один раз
еще интересно то что {#1} означает посчитать длинну переменной $1






| ${parameter:offset:length}
| ${:::}

позволяет печатать не всю переменную а ее часть.
причем важно offset указывает начало откуда печатать
а length указывает сколько символов после оффсета напечатать
следущий пример печатает начиная с оффсет и до конца переменной
    $ a="123"
    $ echo ${#a}   # напоминаю что ${#a} считает длинну переменной 
    3
    $ echo ${a:0:${#a}}
    123
    $ echo ${a:1:${#a}}
    23
    $ echo ${a:2:${#a}}
    3
    $ echo ${a:3:${#a}}
очевидно что нумерация символов в переменной начинается с "0"

следущий пример печатает начиная с оффсет всего один символ
    $ a="123"
    $ echo "${a:0:1}"
    1
    $ echo "${a:1:1}"
    2
    $ echo "${a:2:1}"
    3



    
    
    
| ${#}
| ${:::}

вот еще интерснейший пример

    $ cat md.bash 
    #!/bin/bash

    for((i=0; i<${#1}; i++))
    do
        echo "i=$i"
        echo "${1:$i:1}"
        echo "---"
    done

    $ ./md.bash 34
    i=0
    3
    ---
    i=1
    4
    ---

значит вот эта хует ${#1} означает посчитай длинну переменной $1
где $1 это первый аргумент командной строки который был передан скрипту при запуске

вот эта хуета "${1:$i:1}" означает возмьми переменную $1 и вырежь из нее символы начиная с позиции $i
в количестве 1 штука

получается мы передаем в скрипт 34 который будет являться $1
тогда ${#1} = 2
и цикл будет работать для i=0,1

для i=0
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 0 в количестве 1 штука. тоесть это будет 3

для i=1
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 1 в количестве 1 штука. тоесть это будет 3
4

что мы и видим на экране

охуеть




| printf
это bash builtin.

при этом эти суки в man bash нихуя про него нормально не написали ублюдки.

формат этой хуеты такой

printf "format" arg1 arg2 arg3 ...

тоесть вначале задается формат печати. а потом указываются аргументы(переменные) для печати


простейщий пример
    $ printf "asd\n"
    asd

в этом примере у нас указан только формат. аргументов нихуя нет.
asd это просто литеры. а "\n" это спецсимвол переноса строки. 
все супер просто.

теперь о некоторых других спецсимволах внутри формата

Format Specifier	Description
%c	Treat the arguments as a single character.
%d	Treat the input as a decimal (integer) number (base 10).
%e	Treats the input as an exponential floating-point number.
%f	Treat the input as a floating-point number.
%i	Treat the input as an integer number (base 10).
%o	Treats the input as an octal number (base 8).
%s	Treat the input as a string of characters.
%u	Treat the input as an unsigned decimal (integer) number.
%x	Treats the input as a hexadecimal number (base 16).
%%	Print a percent sign.
%Wd	Print the W integer X digits wide.
%(format)T	Outputs a date-time string resulting from using format as a format string for strftime. The corresponding argument can be the number of seconds since Epoch (January 1, 1970, 00:00), -1 (the current time), or -2 (shell startup time). Not specifying an argument uses the current time as the default value.
\%	Print a percent sign.
\n	Prints a newline character.
\t	Print a tab character.


важно. насколко я понял формат аргумента изначально воспринимается как string
а уже потом в строке формат он конвертируется согласно приказу.
обьясняю на примерах:
    $ printf "число=%d\n" 10
    число=10
    $ printf "число=%c\n" 10
    число=1

в первом примере мы берем аргумент стринг 10 и конвертируем  его в  десятичное число
во втором примере мы берем аргумент стринг 10 и конвертируем его как символ единичный поэтому он от 10 отрезал 1 символ
с начала. начало (офссет) у аргумента начинается слева. получили 1

следущие примеры
    $ printf "%x\n"  10
    a
    $ printf "%x\n"  11
    b

мы берем аргумент в формате стринг и конвертируем его в hex формат
и вот очень важный пример, 
    $ printf "%x\n"  "A"
    bash: printf: A: invalid number
    0
    $ printf "%x\n"  "a"
    bash: printf: a: invalid number
    0
    $ printf "%x\n"  "0xa"
    a
    $ printf "%x\n"  "0xA"
    a
тоесть на сколько я понял если мы хотим конвертировать аргумент в hex формат то на входе
по дефолту ожидается что аргумент имеет dec формат. а если мы хотим уже в аргументе выразить число в hex формате
то его нужно в аргументе писать в виде "0xhex"
охуеть




следущий прмиер
    $ printf "число=%x\n" q
    bash: printf: q: invalid number
    число=0
здесь он нас законно щлет нахер потому что как я уже сказал если мы хотим сконвертиоровать
аргумент в hex формат то аргументе по дефолту принтф ожидает видеть аргумент в формате десятичном 
поэтому аргумент вида "q" приводит к посыланию нахер


двигаем дальше. есть особая залупа о которой не сказано в манах. а оно только обнаруживется в примерах.
залупа касется аргиумента

    $ printf "%d\n" "'A"
    65
    $ printf "%x\n" "'A"
    41

если указываем в аргументе вот так 'аргумент
то это сообщает принтф что прежде чем аргумент подставлять в формат его нужно из ASCII символа преобразовать 
в число причем подставить это число в аргумент именно в десяиичном виде . 
тоесть в ASCII таблице символ "A" имеет код 65(dec)

итак 65  подставляется в аргумент. 
таким макаром первый пример превращается в 
    $ printf "%d\n" 65
    65
а второй пример превращается в  
    $ printf "%x\n" 65
    41

поскольку как я уже писал если мы хотим преобраовать число в hex то принтф ожидает по дефолту что 
в аргументе число представлено в формате dec. поэтому 65 dec преврашается в 41h
если же мы хотим чтобы принтф рассмматривал уже в аргументе 65 как hex число то надо делать вот так
    $ printf "%x\n"  "0x65"
    65

ну а вот такая хрень приводит к ошике
    $ printf "%x\n"  "0x'A"
    bash: printf: 0x'A: invalid hex number
    0

вообще этот принтф это полный пиздец. выдумка шизофреника. 

следущий момент а если у нас несколько аргументов. тогда они выбираются слева направо по порядку. тоесть
    $ printf "ширина=%d, длинна=%d \n" "10" "2"
    ширина=10, длинна=2
тоесть первый %d берется как 10
второй %d берется как 2
все просто. идем слева направо.


далее. 
значит таким макаром если мы хотим по быстрому узнать какой ASCII код у символа
то можно набрать 
    $ man ascii
а можно вот так
    $ printf "%d\n" "'3"
    51
    $ printf "%d\n" "'4"
    52


далее. 
что еще интересно что вот эта хуйня $1 она возможно только при вызове скрипта
тоесть просто для команды в строке этой хуйни не сущетсует
    $ echo $1 <<< "a"
    $ echo "1" | echo $1 
    $ printf "%s \n" "$1" <<< "a"
    $ echo "a" | printf "%s \n" "$1" 
видим что везде пусто на выхлопе





| bc
с ним есть такая хуйня. если мы в него передаем строчку то обязательно 
она должна заканчиваться символом Enter иначе пошлет нахуй. 
пример
    $ echo "2*3" | bc   
    6
    $ echo -n "2*3" | bc
    (standard_in) 1: syntax error
тоесть во втором примере ошибка потому что echo -n недобавляем автоматом символ Enter
к потоку байтов. поэтому bc шлет нахуй.

тоже самое когда юзаем printf 
    $ printf "2*3" | bc
    (standard_in) 1: syntax error
    $ printf "2*3 \n" | bc
    6

    

    
    

| for

есть вот такая хуйня в баш

   for i
    do
        echo -n "vasya"
    done

мы видим   
    for i
типа что за хуйня? оказывается это есть такое сокращение для
    for i in $@
охуеть. потому что иначе эта строчка сука не имеет никакого значения падла
таким образом это эквивалент
   for i in $@
    do
        echo -n "vasya"
    done


    
    
| wc

оказалась приколная программа
что она умеет делать
  wc - print newline, word, and byte counts for each file

тоесть она умеет считать:
    число строк
    число слов
    число байтов


этот пример берет папку с *.txt файлами и считает сколько в них суммарно слов
    $ ls -1 *.txt | xargs -L1 -I% wc -w ./"%" | awk '{print $1}' | xargs echo | sed 's/ /+/g' | bc
    727721

еще можно через wc считать число букв или байтов в стринге
хотя есть подьебка
пример
    $ echo "1" | wc -m
    2
возникает вопрос почему длинна два символа.
а потому что эхо вставил символ Enter вконце. а для wc это тоже символ
    $ echo "1" | od -t x1
    0000000 31 0a

убираем enter в конце и получим уже верный результат
    $ echo -n "1" | wc -m
    1

    $ echo -n "1" | od -t x1
    0000000 31

поэтому удобнее считать число букв в стринге через awk потому что он enter не считает
пример
    $ echo  "1" | awk '{print length}'
    1

а теперь самый что ни на есть практический пример.
нужно узнаиь число букв в хеше
    $ echo "1" | sha512sum | awk '{print $1}'   | awk '{print length}'
    128
    $ echo "1" | sha512sum | awk '{print $1}'   | wc -m
    129
    $ echo "1" | sha512sum | awk '{print $1}'   | od -t x1
0000000 33 61 62 62 36 36 37 37 61 66 33 34 61 63 35 37
0000020 63 30 63 61 35 38 32 38 66 64 39 34 66 39 64 38
0000040 38 36 63 32 36 63 65 35 39 61 38 63 65 36 30 65
0000060 63 66 36 37 37 38 30 37 39 34 32 33 64 63 63 66
0000100 66 31 64 36 66 31 39 63 62 36 35 35 38 30 35 64
0000120 35 36 30 39 38 65 36 64 33 38 61 31 61 37 31 30
0000140 64 65 65 35 39 35 32 33 65 65 64 37 35 31 31 65
0000160 35 61 39 65 34 62 38 63 63 62 33 61 34 36 38 36
0000200 0a
0000201


видно что awk дает верный ответ а wc нет. потому что у нас в стринге на конце есть 0x0a тобишь Enter и wc его считает. 
а он нам нахуй ненужен.
-----


| printf

эта команда настолкло ебанутая что ее надо описать отдельно суку
во первых есть встроенный в баш билтин printf
а есть отдеьная программа которая от баша никак не зависит.
баш почмуто по дефолту запускает не свой билтин а внешнюю.
проверить это легко через strace

    $ strace printf "поле формата \n"
    execve("/usr/bin/printf"...

запустить именно билтин принудительно можно через 
    $ builtin printf "a"
справочная по билтину охуенно убогая. смотрим либо 
    $ builtin printf  --help
либо man bash

далее рассматриваем только внешнюю команду /usr/bin/printf
справка по ней тоже охуенно убогая
    $ man printf
    $ man 3 printf


    
a1
'a
$salt


значит у принтф ест  минимум одно поле. поле формата
    $ printf "поле формата"
    поле формата

в целом туда вставляется все то что мы хотим напечатать. ровно также как это есть у 
команды echo "печать"

в отличие от echo принтф не вставляет автоматом на конце символ новой строки. поэтому 
его надо вставлять руками. через "\n"
    printf "поле формата \n"
    поле формата 

слэш как и у баша в целом это спец символ. тоесть когда его встречает принтф то он его рассматривает 
не как просто печатную литеру а как то что за ней идет символ который тоже является спецсимволом и чтобы его
можно было напечатать его экранирует слэш.
помимо экранируеющего действия комбинция слэш + некоторый символ за слэшем сообщает принтф что \X это тоже 
некий спецсимвол.тоесть с одной стороны слэш может отключать функцию спецсимвола для спецсимвола котоырй стоит за слешем
с другой стороны комбинация слэша и некоторого простого символа стоящего за ним формирует в итоге спецсимвол.
чтобы это все показать на примерах я еще добавлю одну хрень. переменные можно печатать также как и у echo 
тоесть
    $ a=123
    $ printf "$a"
    123
так вот очевидно что $ это спецсимвол который обьясняет принтфу что за ним идет не просто печатный символ "a" 
что за $ идет имя переменной. 
так вот если мы хотим просто распечатать '$a' тогда надо обьянсить принтф что доллар  в данном случае это не спец
символ а просто литера. тут вступает в дело слэш. 
пример
    $ printf "\$a"
        $a
    $ printf "\$a\$a\$a"
        $a$a$a
    $ printf "$a$a$a"
    123123123
с этим понятно.
    $ printf """
    > ^C
тоесть символ " является спецсимволом и он нам его недает напечатать. 
отключаем спецсимвольность и полный порядок
    $ printf "\""
    " 
печатаем слэш
    $ printf "\\"
    \
итак мы рассморели примеры когда слэш забирает силу у спецсимвола преврашая его в просто литеру
теперь рассматриваем случай когда слэш дает спецсилу простму символу.
самый известные пример это символ кнопки Enter. тоесть символ новой строки и перенос каретки налево.
    $ printf "1 \n"
    1
тоесть будет наечатан 1 и пробел. а затем экран будет прокручен на 1 строку вверх и печатная головка
возвратится на начало строки. тоесть \n это управляющий символ терминала
далее. печатаем спецсимвол backspace (прикольно!)
    $ printf "abc"
    abc
    $ printf "abc\b"
    ab
    $ printf "abc\b\b"
    a
тоесть он затирает символ слева как кнопка backspace.
кстати backspace походу переводится как "пробел в обратно направлении"
однако тут я нашел некую необьяснимую хуйню.
вот я печатаю три символ и затираю последние два
    $ printf "abc\b\b"
    a
но если я добавляю в конце символ новой строки тобишь нажатие кнопки enter то
почемуто при этом все символы будут напечатаны. хуйня какаято
    $ printf "abc\b\b\n"
    abc
почему такая хуйня непонятно
однако далее стало понятно что "\b" это ссукат не backspace как
об этом написноа в man ascii это на самом деле аналог стрелки влево. тоест 
он передвигает каретку на один символ влево и сам символ не удаляет.
вот пример
    $ echo -ne "123\b"; sleep 5
или 
    $ printf "123\b"; sleep 5
если мы доблавяем \n то у нас прокручивыается строка наверх и поэтому 123
сохраняется. если мы \n недобавлем то баш начинает печатать с текущего положения
каретки и просто затирает 3. вот как это работает

следущий спецсимвол который образуется в паре со слещем это "form feed"
он означает прокрутить экран или бумагу на одну строку вверх при этом положение
печатающей головки остается на том же месте
    $ printf "abc\f 1  \n"
    abc
        1  
тоесть мы напечатали abc и пробел. потом прокрутили бумагу на 1 строку вверх и в той же
горизонтальной позиции продолжаем печатать.
по факте терминал (черный экран) это полны аналог матрчного принтера. у него есть 
строка в которой он печатает и он может бумагу прокручивать на одун строку вверх и есть
печатная головка которая печатате символ в текущем положении.
единственное что нет такого спецмивола чтобы строку прокрутит не на 1 строку вверху 
а обратно на 1 строку вниз. жалко.
    $ printf "abc\f1\f2\f3  \n"
    abc
        1
          2
            3  
следущий спецсимвол это вовзрат печ головки вначало строки 
    $ printf "abc\rdef  \n"
    def  
тоесть это работат так 
вначале печаается abc потом печатающая головка (курсор) возврашается вначало этой же строки
и начинает печататаь новые символы убивая старые. поэтому abc исчзаеае а def появлыется
    $ printf "vasya\rB\n"
    Basya
мы напечатали vasya потом вернули голову внвало стоки и напечатали символ B
поэтому vasya стал Basya
что интересно что если мы будем писать эту хрень в файл то в нем будут все эти символы. 
щам покажу
    $ printf "vasya\rB\n" | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
или прям запишем в файл на диске и прочитаем
    $ printf "vasya\rB\n" > 11.txt
    $ cat 11.txt | od -t x1
    0000000 76 61 73 79 61 0d 42 0a
             v  a  s  y  a \r  B  \n    <==  я показываю какой символ ASCII\UTF-8 соотвествет какому байту

считываем этот файл с диска и видим на экране
    $ cat 11.txt 
    Basya
    
так в чем прикол  что я хотел этим показать. я хотел паоказать что 
по факту файл на диске содержить гораздо больше чем просто Basya как это мы видим на экране.
файл по факту содержит слово "vasya" которое мы на эаркне не видим. несколко упраляющих симвлов и символ "B"
когда терминал читает с диска поток байтов. то из за наличия нетолько байтов отвечающих за просто символы но и из 
за наличия управляющих терминалом байтов у нас на экране текст получается совсем не такой как он есть в файле.
таким макаром можно в тексте прятать информацию. вот еще пример
    $ printf "notebook Lenovo\rcarpet table wood\n" > 11.txt
    $ cat 11.txt 
    carpet table wood
тоесть по факту в файле есть символы "notebook Lenovo" но они при печати на терминале перетираются
из за управляющего символ '\r'
и мы видим только "carpet table wood"
хотя по факту в файле есть и то и то
    $ cat 11.txt | hexdump -C
    00000000  6e 6f 74 65 62 6f 6f 6b  20 4c 65 6e 6f 76 6f 0d  |notebook Lenovo.|
    00000010  63 61 72 70 65 74 20 74  61 62 6c 65 20 77 6f 6f  |carpet table woo|
    00000020  64 0a                                             |d.|
охуеть

следудуший спецсимвол образюущийся из за налияичия слеша это горизотальная табуляция \t
    $ printf "1\t2\t3\n"
    1	2	3
тоесть работате так. 
терминал печатает 1 потом он видит \t и делает своей печатающей головкой или курсором скачок направо на определенное
число пробелов. потом печатает 2 итак далее. вконце видит \n и тогда он прокручивает строку на 1 вверх
и возвращает печатную головку в начало строки.

следущий спецсимвол это верикальная табуляция. он чтото я не понял разницу между form feed и vertical tab
$ printf "1\v2\v3\n"
1
 2
  3
[vasya@lenovo !9]$ printf "1\f2\f3\n"
1
 2
  3

на выхлопе одно и тоже.

ксатти вовзращаясь назад. когда слэш экранирует спецсимвл лишая его силы. 
есть спец символ у принтф это %
    $ printf "%"
    bash: printf: `%': missing format character
тоеть поше нахууй
пробуем его экранировать
получаем почемуто опять пошел нахуй
незнаю почему
    $ printf "\%"
    bash: printf: `%': missing format character
и только прочитав man printf узнаем что % экранруется индивиудуаальным особым образом
    $ printf "%%"
    %
охуеть.

далее легко заметить и понять что когда мы в термиале виваем символ
то по факту в stdout или в файл улетает никако не символ а байт
    $ printf "a" | od -t x1
    0000000 61
тоесть скажем за символ "a" отвечает байт 0x61
свызь между символом на экране и байтом котоырй за ним стоит это либо ASCII таблица (man ascii)
либо это UTF-8 таблица. причем байты из ascii совпдают с UTF-8 байтами. 
так я это к чему говорю. можно указать принтф что мы вбиваем не печатный символ а сразу байт
скажем байт в hex виде в принтф прописывается как 
    \xHH
тоесть 
    $ printf "\x61"
    a
тоесть \x в поле формата сообщает принтф что это непросто литеры '\' и 'x' а что это спецсимвол который обозначает
байт в hex виде. показываю
    $ printf "a" | od -t x1
    0000000 61
    $ printf "\x61" | od -t x1
    0000000 61
соотвественно чтобы напечатать '\x61' просто как набор литер надо это экранировать
    $ printf "\\\x61" 
    \x61
тоесть мы обьяснили принтф что и \x это просто литеры. хотя непонятно почему вот такой варинт не прокатывает
    $ printf "\\x61" 
    a
ведь по идее мы сделаи \\ что обьяснило принтф что мы печатаем просто \ ну а дальше у нас просто x61
ксатти одиночные кавычки в этом плане все делают более предсказуемым
    $ printf '\x61' 
    a
тоесть видим что \x по прежнему интерпретируется как спецсимвол
но чтобы его обезвредить уже достаточно один раз применить слеш перед слеш
    $ printf '\\x61' 
    \x61

есть еще возможность указать принтф что мы печатаем не символы а байты в формате OCTAL
       \NNN   byte with octal value NNN (1 to 3 digits)

номер символа в формате UNICODE
       \uHHHH Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)
       \UHHHHHHHH
              Unicode character with hex value HHHHHHHH (8 digits)
но я не буду для этих случаев разбирать примеры.

теперь переходим к переменным принтф. хотя они у него называются аргументами.
окей буду называть их аргументами. 
значит помимо поля формат 
    $ printf "поле формата" 
у принф еще можно указать аргументы
    $ printf "поле формата" арг1 арг2 арг3
и тогда при печати эти аргументы будут вставлены в поле формата.
внутри поля формат мы обозначаем что мол сюда надо вставить аргумент через конструцию %T
где T это несколько возможных хреней. например
    %d означает что нужно взять аргумент , преобраозовать его в dec число и уже вставить 
пример
    $ printf "%d \n" "1"
    1 
тоесть он берет 1 преобразует его в 1 (то по факту в данном сулчае нихуя преобразоывать ненадо) и вставляет
в принтф. тоесть 
    printf "%d \n" "1"
превращается после подставновки в 
    printf "1 \n"
и мы получаем на экране
    1
возникает резонный вопрос а нахуя такой огород если можно сразу вставить 1 в поле формат. 
ответа я не знаю. тоесть например вот у нас есть переменная и вот у нас два совершенно равнозачных 
примера
    $ printf "$a \n"
    123 
    $ printf "%d \n" "$a"
    123 
единственный смысл такого усложнения горждения огорода я вижу в том что при таком раскладе само поле формат
может быть коротким и легко воспринимаем а сложные аргументы вынесены отдельно. например
    $ printf "%d \n" "$( echo "2*3" | bc)"
    6 
тоесть у нас поле формат маленькое компактное легко воспринимамое. а громоздкий аргумент вынесен во вне.
возможно в этом смысл такого огрода
раньше я думал что просто переменные нельзя вставлять напрму в поле формата. но как теперь понятно это не так.
причина не в этом.

так вот возврашаемся обратно к %d
как я уже сказал его смысл в том что мы берем аргумент и преобразуем его в dec вид 
и уже как литеру подставляем в поле формат. щас я покажу что значит преобразуем
    $ printf "%d \n"  "0xa"
    10 
значит у нас аргумент записан в hex виде (об этом щас поговорим). так вот %d его преобразует в dec тоесть 
0xa преобразует в 10 и постславяет уже как литера в поле формата
    $ printf "%d \n"  "0xa" ---> printf "10 \n"
    10
и получаем 10 на экране
таким образом видно что формат аргумента совершенно не обязан совпадать с форматом внутри поля формат. 
будет происходить преобразование.
и пиздец конкетной этой ситации в том что если мы находится в поле аргумент то hex формат в нем выглядит как "0xNN"
в то время как в поле формат hex формат выглядит совершенно по другому
    $ printf "\x21 \n"  
    ! 
правда и разница при этом колоссальная. hex число напряму в поле формата вставляется в байтовый поток 
как есть в виде этого hex числа без преобраования в литеру!
а hex число в аргументе как мы видим приводит к тому что оно будет преобразовано в литеру а какой у него будет 
байт уже зависит от ascii таблицы. еще раз показваю разницу
    $ printf "\x22"  
    "
    $ printf "\x22"  | od -t x1
    0000000 22

    $ printf "%d"  "0x22"
    34
    $ printf "%d"  "0x22" | od -t x1
    0000000 33 34

тоесть еще раз. hex формат в поле "формат" у нас в виде '\xNN'
а hex формат в поле "аргумент" совершенно другой в виде '0xNN'
почему так хуй знает.
но и последствия разные. в первом случае у нас 22h будет прям засунут в байтовый поток
а во втором случае hex число будет преобразовано в dec число. и будут найдены соотвствующие литеры в ascii
таблице чтобы это число в итоге нарисовать в терминале. тоесть "34" это 33h и 34h коды в таблице ascii
и тут приходит фундаментальный вопрос в голову а что еси у нас аргумент выглядит как '\x33\x34'
тоесть как мы видим это hex формат но он несоотвествует hex формату разрешенному при использовании для аргумента
    $ printf "%d"  "\x33" 
    bash: printf: \x33: invalid number
как говорится пошел нахер.
так вот как заставит принтф понимать что в аргументе используетсяя hex число просто в другом способе написания хекса.
так вот как это сделать для %d непонятно.
зато известен ключ %b
и вот что он делает
он берет то что находится в аргументе и считает что там прописаны голые байты. тоесть
    $ printf "%b" "\x21"
это полный эквивалент
    $ printf "\x21"
и в итоге получаем
    $ printf "\x21"
    !  
    $ printf "%b" "\x21"
    !  
тоесть %b берет аргумент и вставлят его в поле формата но не  в формет печатных литер а именно в виде голых 
байтов. при этом формат голых байтов должен соотвестовать правилу как эти голые байты могут выглядеть в поле формат.
пиздец
соотвстенно с этим волшенбным ключом %b мы можем использовать либо так либо так
    $ printf "%b" "\x21\x21\x21\x21"
    !!!!
    $ printf "\x21\x21\x21\x21"
    !!!!
тоесть ключ %b позволяет нам вынести из поля формата голые байты в аргумент.

приведу следущий ключ %s
он берет аргумент и вставляет как есть в форме символов как стринг.
    $ printf "%s \n" "\\\\%\\\\"
    \\%\\ 
    $ printf "%s \n" "\x21\x21\x21\x21"
    \x21\x21\x21\x21 

тоесть очень тупо и просто. ровно как мы видим символы в аргументе так они и будут напечатаны на экране

следущий ключ %c делает тоже самое что %s но печатает только первый символ
    $ printf "%c \n" "\x21\x21\x21\x21"
    \ 
    $ printf "%c \n" "\\\\%\\\\"
    \
    
    
 еще один полезный ключ это %x он или %X берет число из аргумента
и преобраует его в hex число и печатаем с помощью литер.
X отличается от  x тем что печатает результат в заглавном формате (большими буквами) 
    $ printf "%x \n" "10"
    a 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%X \n" "0xA"
    A 
    $ printf "%X \n" "0xa"
    A 
    $ printf "%x \n" "0xa"
    a 
    $ printf "%x \n" "0xA"
    a 

ксатти вот еще интересно
    $ printf "%x" "0x21 0x33 0x34 0x56"
    bash: printf: 0x21 0x33 0x34 0x56: invalid hex number
    $ printf "%x" "0x21"
    21
    $ printf "%x" "0x2133"
    2133
    $ printf "%x" "0x21333456"
    21333456
    
по идее все самые важные и частые ключи  я описал.
соовественно если у нас есть переменная которая содержит ascii коды символов то чтобы их напечатать
именнов форме символов надо чтобы формат был вида \x21 тогда
    $ a="\x21\x33\x34\x56"
    $ printf "$a \n"
    !34V 
либо 
    $ printf "%b \n" "$a"
    !34V 

если же у нас a="21333456" либо a="0x210x330x340x56" либо a="21h33h34h56h"
то такие hex ascii коды  мы хрен распечатаем  в форме символов на раз два.
надо преобразоываать.
щас покажу. 
пусть у нас есть переменная которая хранить ascii коды в hex формате но вот в таком виде
    $ a="21333456"
и мы хотим их напечатать на экране в виде символов 
    $ sed 's/../\\x&/g' <<< $a
    \x21\x33\x34\x56
тоесть мы заменяем 
    21333456 -->  \x21\x33\x34\x56
тогда
    $ printf "%b \n" "$(sed 's/../\\x&/g' <<< $a)"
    !34V 
хотя самый простой способ превратить ascii коды "21333456" в символы это пойти по другому пути
    $ echo "21333456" | xxd -r -p | cat
    !34V

далее. вот еше прикол
понятчно и логично что если у нас  в поле формата (кстати идиотский термин) указано два аргумента
и по факту у нас два аргумента то в первый подставляется первый а во второй подставляеься второй
    $ printf "%d %d \n"  "10" "11"
    10 11 
но мне даже в голову не приходило пока не напоролся на пример в интете что 
число аргументов в поле формата может не совпадать с числом аргументов
и тогда походу они применяются по кольцу
    $ printf "%d \n" 1 2 3 4 5
    1 
    2 
    3 
    4 
    5 

пока все про printf
это не команда это какойто идиот ее писал. пиздец.






| $''

$'' эта конструкция имеет особый смысл
эта хрень позволяет определять стринг в баше аналогичный ""
причем подчеркну что $'' это единая конструкция.
так вот она дает то что эта хрень она понимает спецсимволы типа \n \t итп
это удобно если мы хотим задать например переменную у кооторой есть 
cпецсимволы.
пример
первый
    $ echo "\t1"
    \t1
как я понимаю в этом примере содержимое стринга "\t1" в памяти в байтовом виде представляет собой
    5Ch 31h, где 5Ch в ascii это символ "\" , 74h в ascii это "t",  31h в ascii кодах это "1"
соотвественно echo пытается печатать байтовый поток 0x5C7431

а вот второй пример
    $ echo $'\t1'
        1
как я понимаю в этом случае байтовое содержимое стринга в памяти совершенно другое,
а именно 0х09 "\t"  и 0x31 "1" тоесть суммарно байтовый поток содержимого стринга в памяти выглядит как 0x0931
поэтому эхо выводит другую картинку 
да можно конечно и вот так сделать
    $ echo -e "\t"1
        1
и мы получаем ровно тоже самое на выходе что и в предыдущем примере
однако механизм получения совершенно другой потому что эхо получает на входе поток 0x5C7431
но печатает не его а печатает модифицированный поток 0x0931
тоесть прикол в том что echo  с помощью спец ключа -e модифицирует входной поток. а  в предыдущем примере
поток байтов не модифицируется он тупо печатаются. 


хочу еще кое что показать
вот этот пример который отрабатывает кореектно
    $ a=$'\t \t \n \n 23'
    $ echo "$a"
	 	 
 
            23

так вот если мы обращаемся к переменной вот так "$a"
то у нас все коректно отрабатывает
    $ strace -e execve echo "$a"
    execve("/bin/echo", ["echo", "\t \t \n \n 23"], 0x7ffea8490db8 /* 66 vars */) = 0
        
а если мы убираем двойные кавычки
и обращаемся к переменной без кавычек вот так $a
то баш подставляет в execve уже некорректно
тоесть это именно баш по особому обрабатывает аргументы и подставляет в вызов execve
тоесть это не внешняя команда /bin/echo отрабатывает некоректно это именно бащ его вина
$ strace -e execve echo $a
execve("/bin/echo", ["echo", "23"], 0x7ffc356993e8 /* 66 vars */) = 0

тоесть echo "$a" и echo $a отрабатывает соверщенно по другому.  и это вина не эхо. 
это вина баша который анализирует командную строку и уже запускает эхо с совершенно разным аргументом.
этот момент я буду анализировать отдельно.

я хочу подчеркнуть что хрень $'' нужно использовать именно в таком виде. 
если это заюзать в виде "$''" то это уже неработает
    $ echo "$'\t1'"
    $'\t1'
    $ echo $'\t1'
        1



        

        

| ""
| string
| echo

хочу рассмотреть тонкий момент
и нихуя неописанный

рассмотрю на примере команды /bin/echo , тоесть эта команда не баш билтин
а внешняя по отношению к башу команда

и тут важно во первых вот что сказать вот мы в строке пуляем команду
    $ echo "123" "124"
и это все поступает в баш. он это все обрабатывает. при необходимости модифицирует и потом уже
запускает сисколл execve с параметрами. показываю на примере
в этом примере у нас в командной строке мы ввели \n а баш в execve сует нечто другое n
    $ strace -e execve echo -e \n
    execve("/bin/echo", ["echo", "-e", "n"] ...) = 0
а в этом примере у нас в командной строке мы ввели "\n" и баш в execve сует почти тоже самое "\\n"
    $ strace -e execve echo -e "\n"
    execve("/bin/echo", ["echo", "-e", "\\n"] ...) = 0
поэтому конечный результат другой не из за команды echo а из за того что баш подменяет то что
мы ему в комадной строке записали а он  в echo сует изменную хрень

тоесть важно понять что между тем что мы вбили на клаве и тем как реально будет запущена
внешняя команда с какими параметрами это разные вещи. получается вот такая схема
    мы  вбили в клаве команду  с параметрами ----> bash процесс ---> запуск внешней команды
поэтому то что мы вбили на клаве и как это будет в конечном итоге запущено это не всегда совпдает
из за того что посередине сидит баш который берет то что мы вбили и модифицириует и только потом
запускает внещнюю команду

поэтому чтобы реаьно понять как именно с каким аргументами была запущена таже самая echo 
нужно смотреть через strace

нуладно. двигаем дальше.
берем 
    $ man echo 
там сказано
вот какой у нее формат
    $ echo [SHORT-OPTION]... [STRING]...

я пытался найти как в баше задается стринг. 
но я не могу найти. что такое string? это просто любой набор символов с клавы?
или это набор символов заключенный в кавычки? я не могу найти ответ на этот вопрос
зато в man echo  я читаю вот такое

    If -e is in effect, the following sequences are recognized:
    \n     new line

тогда по идее 
    $ echo -e \n1
должно приводить к тому что \n должно дать перенос строки и потом напечатать символ "1"
однако на практике этого не происходит. а происходит полная хуйня
    $ echo -e \n1
    n1
хотя в man echo как я сказал написано совсем другое. и только если записать вот так
то работает как записано в man echo
    $ echo -e "\n1"

    1

из чего я делаю вывод что понятие STRING в баше это обязательно хрень заключенная в двойные кавычки.
иначе я не могу обьяснить результаты.
а что такое набор символов без кавычек тогда? я не могу найти.

тоже самое касается printf. в его man printf указано что \n должен приводить к новой строке.однако
этого не происходит.
    $ printf \n
    n
и только если мы заключаем эту хрень в кавычки то тогда оно отрабатывает как надо
    $ printf "\n"



тут попутно озвучу что в баш есть так называемые спецсимволы
# 
; 
" 
'
,
\
/
`
:
!
*
?
$
()
{}
[]
[[]]
(())
> &> >& >> < <>
|
>|
-
+
%
~
^
суть их  в том что бащ их по дефолут считает не просто символами печатными а спецсимволами, метасимволами.
(https://tldp.org/LDP/abs/html/escapingsection.html)

так вот я щас пытаюсь связать спецсимволы и кавычки ""
что дают кавычки. во первых я уже показал что только заключение в кавычки дает правильное поведение как 
пропсиано в манах для спецсимволов вида \n \t и тому подобных слеш спецсимволов.
так вот во вторых кавыки экранируют спецсимволы. заставляя баш (именн баш а не внешние команды типа echo) 
воспринимать спецсимволы как просто печатны символы. пример
    $ echo #

    $ echo "#"
    #

    $ strace -e execve echo #
    execve("/bin/echo", ["echo"] ...) = 0

    $ strace -e execve echo "#"
    execve("/bin/echo", ["echo", "#"] ...) = 0
    #

тоесть видно что между клавой и запуском echo сидит баш процесс который анализирует то чтомы вбили 
и в завсимости от того в кавычках или без он совсем разное вставляет в execve в поле аргументов.
тоесть
    вбили echo # --->  бащ процесс принимает и анализирует и видит что # указан без кавычек значит 
    он его рассматривает как спецсимвол и
    поэтому echo запускается вообще без аргументов ---> (execve "/bin/echo", ["echo"]) 

в bash advanced guide (https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html)
написано что все такие не все спецсимволы экранируются через "" 
а именно
    Enclosing characters in double quotes (‘"’) preserves the literal value of all characters 
    within the quotes, with the exception of ‘$’, ‘`’, ‘\’, and, when history expansion 
    is enabled, ‘!’. When the shell is in POSIX mode (see Bash POSIX Mode), the ‘!’ has no special 
    meaning within double quotes, even when history expansion is enabled. The characters ‘$’ 
    and ‘`’ retain their special meaning within double quotes (see Shell Expansions). 
    The backslash retains its special meaning only when followed by one of the 
    following characters: ‘$’, ‘`’, ‘"’, ‘\’, or newline. Within double quotes, backslashes 
    that are followed by one of these characters are removed. Backslashes preceding characters 
    without a special meaning are left unmodified. A double quote may be quoted within 
    double quotes by preceding it with a backslash. If enabled, history expansion will 
    be performed unless an ‘!’ appearing in double quotes is escaped using a backslash. 
    The backslash preceding the ‘!’ is not removed.
    The special parameters ‘*’ and ‘@’ have special meaning when in 
    double quotes (see Shell Parameter Expansion).

тоесть скажем знак $ он в "" не экранируется
поэтому мы можем "раскрывать" переменную внутри ""
пример
    $ let a="1"
    $ echo "$a"
    1


а теперь я покажу еще прикол. о том что я рекомендую не только STRING всегда заключать в кавычки
чтобы не получать приколы непонятные. но я также рекоедую всегда и имя переменной всегда заключать в 
кавычки чтобы не получать необьяснимые приколы. 
пример берем и делаем переменную со спецсимволами
    $ a=$'\t1'
    $ echo $a
    1
    $ echo "$a"
        1
и видно что когда имя переменной указано без кавычек  то получаем хуйню.
а когда в "" то получаем то что надо.

поэтому я бы постулировал что STRING в баше это только хрень заключенная в "" иначе мы будем получать
всякую непонятную хуйню.
и более того в "" нужно заключать и переменные иначе тоже будем получать хуйню.
хотя вот чисто экспериментальным путем я нашел вопреки манам как же заставить скажем echo 
раобтать со спецсимволами вида \n без использования кавычек. ответ такой что нужно вместо \n 
использовать \\n
пример
    $ echo -e \\n1

    1

    
    
| IFS
есть такая спец переменная у баша
она в себе содержит три символа. 
    - символ пробела
    - символ табуляции
    - символ новой строки
тоесть
    $ od -t x1 <<< "$IFS"
    0000000 20 09 0a 0a
где 
    20h  это пробел
    09h  это таббуляция
    0ф   это новая строка

так вот какой физ смысл этой встроенной в баш переменной?
значит баш использует символы в этой переменной для определения какие 
символы являются признаком разделителя так называемых слов.
бащ использует эту переменную только в некоторых специфических случаях.
первый случай это команда 
    $ read -a ARRAY <<< "1 2 3 4"
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
в данном случае символ пробела который есть в "$IFS" был найден в "1 2 3 4" и на основе
пробела этот стринг был разрезан на слова.
следущий пример это когда баш находит в $'1\t2\t3\t4' символ табуляции поэтому он разрезает эту переменную
на отдельные слова
    $ read -a ARRAY <<< $'1\t2\t3\t4'
    $ echo "${ARRAY[1]}"
    2
вот пример когда у нас бащ ненаходит в стринге ни пробела ни табуляции ни новой строки
поэтому стринг не разрезается на слова
    $ read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[1]}"

    $ echo "${ARRAY[0]}"
    1-2-3-4

а вот мы меняем "$IFS" и тогда баш уже находит в стринге символ который указан в IFS
и разрезает стринг на слова
    $ IFS="-";read -a ARRAY <<< $'1-2-3-4'
    $ echo "${ARRAY[0]}"
    1
    $ echo "${ARRAY[1]}"
    2
    $ echo "${ARRAY[2]}"
    3
    $ echo "${ARRAY[3]}"
    4
хочу подчеркнуть что IFS срабатывает только в ряде небольшого числа случаев про коорые
надо прям конерктно читать. этих случаев мало. второй случай когда это работает это вот такой случай
далее я показываю ряд случаев причем я не понимаю почему в ряде случаев оно работает 
а в других нет
но разбирать почему я уже не буду
    $ a="1:2:3:4"
    $ for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ for i in "$(echo $a)"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$a"; do echo "i=$i"; done
    i=1:2:3:4
    $ IFS=":";for i in "$(echo $a)"; do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo $a); do echo "i=$i"; done
    i=1 2 3 4
    $ IFS=":";for i in $(echo "$a"); do echo "i=$i"; done
    i=1
    i=2
    i=3
    i=4

    
    

| <>
| << >>
| <<< >>>
| < <  > >
| |
| <(command)
| >(command)

<
начнем с "<"
эта штука читает из файла
тоесть справа в конечном итоге должно стоять имя файла
тоесть 
    < имя файла
справа только имя файла. болше там ничего поставить нельзя.
не получится. 
более точно формат выражени выглядит вот так
    $ command < имя файла
тогда ОС начинает сама читать из указанного файла и подавать байты на stdin процесса команды
более расширенный вариант это 
    $ command n< имя файла
где n это файловый дескриптор процесса command 
тоесть ОС сама читает файл и подает его на файловый дескриптор процесса с номер n
получается когда n мы не указваем то это по дефолту дескриптор 0
тоесть
    command < имя файла = command 0< имя файла
итак пример
    $ tr -d -c "1" < /dev/urandom | head -c1; echo ""
    1
значит что он делает ОС читает из файла /dev/urandom и подает эти байты
на stdin команды tr , и это главное. ну а далее детали. tr вырезает из потока все символы кроме
символ "1" и далее и потом из этого потока команда head выбирает один байт. 
последння команда нужна просто чтобы добавить перенос строки.
главное что нужно понять что  < можно употреблять только если у нас есть какойто файл. 
тогда мы его ставим справа то <. если файла нету то < употреблять нельзя невозможно.

    command < file_name

при этом совершенно понятно что сама команда она совершенно необязана читать байты которые 
подсовывает ей ОС. 
пример
    $ sleep 100 < /dev/urandom
тоесть команда sleep абсолютно не будет читать данные из urandom. 
хотя ОС ей на stdin подключает /dev/urandom
    $ ls -a1l /proc/24234/fd
        0 -> /dev/urandom

так тут я поправлюсь < не приводит к тому что сама ОС начинает читать файл. 
ОС лишь подключает /dev/urandom к stdin
а читает либо не читает из stdin уже код самой команды. если в команде  в ее коде нет
сисколлов на чтение то чтения не будет никакого.

аналогично команда 
    > file_name
она только подключает stdout команды процесса к  file_name
а будет писать на stdout команда процесса или не будет это уже зависит от кода команды. 
вот пример
    $ sleep 100 > /dev/urandom
    $ ls -a1l /proc/24395/fd
        1 -> /dev/urandom

и тут я перехожу к команда <<<
в чем ее ОГРОМНАЯ разница с <
а разница в том что справа от <<< должен стоять STRING
а справа от < должен стоять имя файла
и поэтому они применяются в совершенно разных ситациях
пример
    $ bc <<< "2*3"     <---- STRING
    6          
    
    $ head -c 1 < /dev/urandom   <---- файл
    k

как говорится заметь разницу
тоесть 
    command < file
делает то что на stdin процесса команды привязывается файл
а
    command <<< "STRING"
делает то что на stdin процесса команды подается то что находится в STRING
значит как я понял на подкорке это работает так что ОС создает сама файл в /tmp 
пишет туда сама "STRING" а потом когда этот файл прочитывает команда то ОС 
этот файл удаляет
    $ sleep 120 <<< "TEST"
    $ ls -1al /proc/24710/fd
    0 -> '/tmp/sh-thd.MNxZor (deleted)'
единсвтенное я не понял почему ОС удалила файл для команды sleep ведь она не читает 
свой stdin
вот еще способ проверки
    $ ls -l /proc/self/fd/ <<< "TEST"
    1 vasya vasya 64 дек  2 07:39 0 -> '/tmp/sh-thd.Olh22p (deleted)'
таким образом я сам для себя выяснил в каком случае есть смысл
использовать < а в каком случае использовать <<<
теперт это понятно. и понятно что использовать их можно только в совершенно
разных случаях.

получается что 
        command <<< "STRING"
это полный аналог команды
        echo "STRING" | command
ну типа получается что вариант с <<< он якобы более наглядный
ПРИЧЕМ важно еще заметить что <<< добавляет к исходному стрингу знак новой строки.
тоесть
    $ od -t x1 <<< "1"
    0000000 31 0a
тоесть в команду od влетает не просто байт 0x31 а еще и доблавляется символ новой строки 0x0a
таким образом полный аналог команды
            command <<< "STRING"
это именно команда
        echo "STRING" | command
но НЕ команда
        echo -n "STRING" | command
таким образом если нам важно не добавляеть к стрингу символ новой строки то нам 
нельзя пользоваться <<< а если мы нам похеру то можно.
вот еще раз я показыают какой байтовый поток вылезает из разных команд
    $ od -t x1 <<< "1"
0000000 31 0a
    $ echo "1" | od -t x1
0000000 31 0a
    $ echo -n "1" | od -t x1
0000000 31

вот еще на этих приерах видно когда одно и тоже получаем
а когда нет
    $ md5sum <<< "1"
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo "1" | md5sum
    b026324c6904b2a9cb4b88d6d61c81d1  -
    $ echo -n "1" | md5sum
    c4ca4238a0b923820dcc509a6f75849b  -



далее насколько я понимаю что >>> такой команды нет. 
потому что писать из stdout в "STRING" это бред
    $ echo "123" >>> "qwe"
    bash: syntax error near unexpected token `>'

далее >>
    command >> file
это аналог 
    command > file
с той разницей что в верхнем случае к концу файла добавляются данные
а во втором случае содержимое файла полностью удаляется и данные начинают
писаться в начало файла

далее <<
    command << file
как я понимаю такой команды нет


далее |
    command1 | command2
возникает вопрос в чем разница между > и |
можно ли как то через > заменить |
значит пайп приводит к тому что stdout первой команды
и stdin второй команды смотрят на один и тот же буфер в ядре. 
    stdout1 > буфер ядра > stdin2
тоесть никакой файл на диске не создается а используется буфер в ядре
так вот если command2 уже запущена то можно найти ее stdin на диске например  /proc/4444/stdin
и далее можно вот так извратиться
    command1 > /proc/4444/stdin
но повторюсь что для этого команда 2 уже должны быть запущена. а если она не запущена
то хрен ты так сделаешь. 
пайп позволяет отдать процесс увязки stdout1 stdin2 башу. 
в целом я бы сказал что > и < оно в целом предназначено чтобы читать и писать на реальные физ файлы
на диске либо спец файлы на /dev тоесть это более менее статичекие файлы причем никак не связанные 
с файлами процессов на /proc
пайп же предназначен для увязки между файлами на /proc которые там создает ядро для процессов.


далее <(command)
    command1 <(command2)
эта хрень называется bash process substitution
и она  не имеет отношения к 
    command < file
хотя вроде как немного на нее похоже
визуально можно заметить быстро разницу всегда из того что если это bash process substitution
то рядом с ним всегда стоит скобка
    <(...
а если это обычный файл редирекшн то между < и file всегда стоит пробел
    < file
у меня есть отдельная статья в этом же файле про bash process substitution.
здесь же краткое описание что как это работает
    command1 <(command2)
баш запускает command2 потом делает симлинк его stdout в файл /dev/fd/X
и подставляет в исходную команду имя этого файла
    command1 /dev/fd/X
еще раз имя файла подставляется как аргумент команды  command1
пример
    $ echo <(echo "1")
    /dev/fd/63

таким макаром конструкция 
    command1 <(command2)
имеет смысл если команда1 умеет читать из файла если ей указать имя файла как аргумент.
например тако умеет делать команда cat
    $ cat <(echo "123")
    123
и если мы хотим чтобы у нас stdout от одной команды был прочитан другой командой при условии что первая 
команда умеет читать из файла если он указан у нее как аргумент
обратная команда
    command1 >(command2)
пример
    $ cp /dev/urandom >(tr -cd "[:digit:]" | head -c10 | cat -)
    2054370200
как работает. запускается tr и его stdin через симлинк протаскивается в некий файл /dev/fd/X
и этот файл подставляется вот так 
    $ cp /dev/urandom /dev/fd/X
и cp копируется байты из urandom на stdin команды tr 
ну а дальше tr выбирает из потока только цифры. потом head берет первыех 10 цифр ну а cat их печатает.
теперь когда мы знаем что вместо 
    <(command)
    >(command)
подставляется как аргумент строки имя файла вида /dev/fd/X
будет понятен смысл вот такой конструкции
    $ wc -w < <(echo "a b c d")
    4
значит что это за загадочные < <
значит <(echo "a b c d") это bash process substitutution
а wc -w < это файл редиреккшн
если мы вспомним что в результатие bash pricess sustitution в исходную команду подставлется вот 
такая хрень /dev/fd/X то мы получаем 
    $ wc -w < /dev/fd/X
и теперь совершенно легко видно что оставшийся < это классический файл редирекшн.
справа стоит некое имя файла. а слева команда
конечно в данном примере можно было и не городить огород а сделать проще
    $ echo "a b c d" | wc -w
    4
но так возможно потому что wc такая команда она может работать как с stdin так и с файлами 
указанными ей в командной строке в качестве аргумента. другие команды не такие универсальные


напоследок разберу еше вот эти примеры

       $ cat <<< 1.bash
          1.bash
здесь понятно 1.bash воспринимается как стринг вида "1.bash"
тоесть просто набор литер

        $ cat < 1.bash
          #!/bin/bash
          ...
здесь получается что на stdin от cat привязан к файлу 1.bash
и cat читает из stdin тоесть в коненом итоге из файла 1.bash

        
        $ a="123"
        $ cat < "$a"
          bash: 123: No such file or directory
здесь понятно что  на фс нет файла с именем "123"

        $ cat <<< "$a"
          123
здесь тоже понятно что на stdin от cat привязан временный файл который содержит в себе "123"
котоырй ос создает сама в /tmp папке и поэтому cat читает из stdin по факту читает из /tmp/X
и рисует его содержимое 122


        $ cat < $(echo 123)
        bash: $(echo 123): No such file or directory
эта команда читает из файл с именем справа от >
результатом $(echo 123) будет 123 тоесть полный аналог команды это 
        $ cat < 123
но файла 123 на фс нет. поэтому пошел нахер


        $ cat <<< $(echo 123)
            123
аналог этой команды это 
        $ cat <<< "123"
эта команда позволяет засунуть стринг стоящий справа на stdin команды слева поэтому
такой резултат

        $ cat <$(echo 123)
комбинация <$(echo 123) это не bash process substituition потому что <$
результатом $(echo 123) будет 123 поэтому аналог это 
        $ cat <123
ее аналог это 
        $ cat < 123
но файл 123 на фс нет
а когда такой файл есть то все сработает
    $ echo "aa" > 123
    $ cat <$(echo "123")
    aa
тоесть в этом примере ловушка в том что вроде спервого взгляда кажетс что команда
    $ cat <$(echo 123)
это команда
    $ cat <(echo 123)
которая является bash process substitutuiion
но это не так потому что есть еще $

кстати я вверху писал что при файл редиреккшн между < и именем файла обязателно стоит пробел . вобще
то это не обязательно. 
и так и так верно
    command < file
    commadn <file
просто если это bash proces substittiuition то после < обязателно стоит (
    command <(command2)
и это его отлличает от файл редирекшн




| ascii

    $ man ascii

схема такая в устройство "терминал" поступает поток байтов. каждый байт
терминалом транслируется либо в печатный символ. либо это непечатный символа а управляющий
для терминала.

скажем 0x61 байт терминалом транслируется в печатный символ "a"
а байт 0x0a приводит к тому что терминал прокручивает картинку на 1 строку вверх и переводит печатную
головку в начало строки тоесть в самое лево и при этом конечно ничего не печатает. 
поэтому 0x61 это байт которые отвечает за печатный символ а 0x0a это байт который отвечает за
управление терминалом.

так вот среди них есть два таких байта
0x0E  (shift out) SO
0x0F  (shift in)  SI

что это за хрень. как пишект виикипедия из того что я понял был такой телетайп Model 38
это типа принтера матричного. и  у него было несколко лент разных цветом так вот эти байты
они переключали с черной ленты на красную ленту. 

дальше как я понял когда появились видимо более продвинутые матрчиные принтеры в котоорые как я понял
можно было загружаьт в память как бы доп символы например символы руского языка. то 
посылка байта SO приводила к тому что принтер начинал печатать рускими символами а SI печать латинскиими.

потом с появлением терминала VT100 это приводило к переключению символов на символы псевдографики.
тоесть скажем SO переключал на симолы псевдографиики а SI возвраащал обратно символы ascii.

в текущем окне терминала линукса посылание на терминал этих символов нихрена ни к чему не приводит.
наверное потому что по факту щас терминал работает на UTF-8 а не на ascii и тому подобное









## bash advanced scripting guide
    (https://tldp.org/LDP/abs/html/special-chars.html)


    
|как преобразовать число из двоичного или 16ричного вида в 10ый
    $ echo $(( 2#101011 ))
    43
    $ echo $(( 16#A ))
    10


    
    
    
|разделитель команд 
    ;
они пишут что после него надо обязательно ставить пробел





|шелл билтин .
что тоже самое source
эта хрень приводит к тому что скрипт выполняется в данном процессе. а не в новом.
обычно эта хрень делается чтобы в текущем процессе баша изменить или добавить переменные



|переенная "$PWD" содержит в себе текущую папку


|:
|встроенный билтин :
по факту он не делает нихрена
код возврата 0

: > file
уменьшает размер файла до нуля
даже если файл открыт 

: >> file
неделает нихрена если файл уже есть


: может использоваться как имя фукции но это нерекомендвано


|?
интересный пример использования ?
если $var1<98 то var0=9
иначе var0=21
охренеть
    $ (( var0 = var1<98?9:21 ))
правда непонятно зачем эта галиматься с (()) если все можно сделать без них

кстати
    $ echo $((var0=1))
    1

более простой пример. но для начала вот что
    (( 0 )) && echo "True \$?=$?" || echo "False \$?=$?"
    False $?=1

    $ (( 21 )) && echo "True \$?=$?" || echo "False \$?=$?"
    True $?=0

Итак если   (( 0 )) то False , 1
если        (( 21 )) то True , 0



так вот пример попроще
если 100 меньше 98 то тогда 0 иначе 21
в итоге получаем внутри скобки 21 
поскольку внутри скобки неноль то код возврата true тоесть 0
    $ (( 100<98?0:21 )); echo $?
    0

внутри скобки 0 значит код вовзрата false тоесть 1
    $ (( 1<98?0:21 )); echo $?
    1

далее
    $ echo $(( 1<98?0:21 )); echo $?
    0
    0
    $ echo $(( 100<98?0:21 )); echo $?
    21
    0
видно что можно распечатать содержимое скобки
код возврата всегда ноль потому что мы используем echo
а не просто голые скобки

еще раз наопмню что просто скобки они на stdout ничего не возвращают
но они возвращают код возврата в $?
а чтобы возвратить то что внутри скобок тогда надо 
    $ echo $(( 21 ))
    21

|$*
|$@

эти переменные почти одно и тоже.
показывает все аргументы скормленные скрипту

переменная $* берет все аргументы собирает их в одну переменную. тоесть
если

    $ ./03.bash 1 2 3 
то 
    $*="1 2 3"
то есть еще раз все отдельные аргументы будут собраны в одну переменную

а переменная $@ она собирает все аргументы в массив поэтому их можно 
потом выцепить по отдельности.
пример
    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done

запускаю
    $ ./03.bash  1 2 3
    $*=1 2 3
    $@=1 2 3

    $@[1]=1
    $@[2]=2
    $@[3]=3

    $*[1 2 3]=1 2 3

из чего видно что $@ это массив а $* это просто переменная в которой все аргументы собраны в одну кучу


| **
возведение в степень
    $ echo "$(( 2**3 ))"
    8




|$$

эта переменная показывает pid процесса скрипта

|()
эта хрень называется субшелл
пока мало ясно что это. 
как я понял все команды которые стоят внутри скобок запускаются в отдельном процессе

$ a="123"; echo "$a"; ( a="321"; echo $a); echo $a
123
321
123

как я понял основной смысл в скриптах использовать субшелл
это то что все переменные субшеллла никак не влияют на переменные основного шелла.
тоесть субшелл это чтото типа функции наверно.хотя возможо функция может 
влиять на глобальные переменные скрипта.

еще с помощью () обявляют массив
    $ a=( 1 2 3 )
    $ echo $a
    1
    $ echo ${a[*]}
    1 2 3


|{x,y,z}
фигурные скобки внутри которых 
элементы через запятые.
как я понял эта хрень работать так
если поставить символ скажем a до {
и поставить символ скажем b после }
то все хрени перечисленные внутри {}
будут обрамлены в ab.
пример
    $ echo \"{1,2,3}\"
    "1" "2" "3"
    $ echo a{1,2,3}b
    a1b a2b a3b

тоесть 1 2 3 перечислены внутри {}
а снаружи скобок стоят a и b
поэтому 1 2 3 обрамлены ими

также сказано что элемент внутри {}
перечиаляются через запятую и нельзя
между ними ставить пробел

    $ echo file.{txt,log}
    file.txt file.log

далее
не знаю что за правило но можно делать "вложенные" скобки
    $ echo {"a:","b:"}{"1","2"}
    a:1 a:2 b:1 b:2


    $ echo {"a:","b:"}{"1","2"}{"+","-"}
    a:1+ a:1- a:2+ a:2- b:1+ b:1- b:2+ b:2-

|{a..z}

    $ echo {a..z}
    a b c d e f g h i j k l m n o p q r s t u v w x y z
    $ echo {1..10}
    1 2 3 4 5 6 7 8 9 10

| {; ; ; }
эта хрень на мой взгляд в основном нужна только для того чтобы 
для красивости обьединить команды в один красиво выглядищий кусок.
при этом никаких реальных дейтсвий эта команда не делает.
    $ { printf "1"; printf "2"; printf "3\n"; } 
    123
    $  printf "1"; printf "2"; printf "3\n"; 
    123
не вижу никакой разницы
важно после последней команды в скобках поставить тоже ; иначе пошлет нахер

без скобок я даже не знаю как вот такое сделать
    $ { printf "1+"; printf "2+"; printf "3\n"; } | bc
    6
максимум могу вот так
    $ printf "1+"; printf "2+"; printf "3\n" | tr "3" "c"
    1+2+c
в книжке написано что {} создает безымянную функцию. в отличие 
от обычной функции если мы внутри функкции определяем переменную
такую же как и в главном теле то то будет переопределена функция в главном теле.
тоесть безымянная функция может переопределять глобалные переменные
    $ a="1"; { a="2"; }; echo $a
    2

вот еще интересный пример
    $ { tr -cd [:digit:] | head -c 1 ; echo ""; tr -cd [:digit:] | head -c 1; echo ""; } < /dev/urandom 
    4
    8
    
эта штука работает так - запускается первая команда из скобки, пусть это внешняя команда, тоесть создается новый процесс.
и к его файл дескриптор 0 ядро подключает /dev/urandom. далее это уже забота самой команды либо читать из stdin 
или нет. как только первая команда отработала , то запускается вторая команда из скобки и ядро снова подключает к  stdin 
уже этого процесса файл /dev/urandom и так пока все команды из скобок не закончат свою работу

я бы сказал что эти скобки работают ровно как скобки из математики. тоесть берем математику
    ( 2+3 ) *5
раскрываем скобки
    2*5 + 3*5

тоесть ос когда работает с предыдущим примером она делает ровно вот так
    $ tr -cd [:digit:] < /dev/urandom | head -c 1 
    $ echo ""< /dev/urandom
    $ tr -cd [:digit:] < /dev/urandom| head -c 1 
    $ echo "" < /dev/urandom  

тоесть еще раз говорю что каждой команде внутри скобок подсовывается то что находится вне скобки.
что касается данного конкретного случая то далеко некаждая команда по своей сути читает из stdin
поэтому на какие то команды влияет это подключение а на другие нет

правда как этот пример переработать в эквивалент хрен знает
    $ { printf "1+"; printf "2+"; printf "3\n"; }  | bc
    6

мне кажется что проще всего понимать работу скобок так что скобка 
имеет некую единую stdin и stdout 
поэтому скажем вначале полностью отрабатывают все команды из скобки. они скажем
все срут на stdout и только потом все что было высрано командами внутри скобки
единым куском выплевывается во вне.
поэтому на bc поступает сразу единый кусок от всех трех printf

я даже в книжке нашел такое же описание

{



}  > 1.test # Redirects output of everything in block to file


также книжка дает еще один пример когда юзается {}
а именно {} используется  в команде xargs. {} в ней используется для подстановки
аргументов 
    $ ls -1 | xargs -I{}  echo "файл = {}"
    файл = 03.bash
    файл = 04.bash

    
также {} используется чтобы обозначать тело функции


| &>
эта хрень редиректит 1 и 2 в filename
    $ command &>filename 

эта хрень редиректит 1 в 2
    $ command >&2 


| >

примеры на счет использования >
    $ [[ "ab" > "cd" ]]; echo $?
    1
насколько я понимаю сравннеие идет следущим образом
берется байтовый поток обоих операндов и сравнивается как hex число
скажем ab=0x6162  cd=0x6364
вот эти два числа и сравниваются. какое больше то и победило

| pipe
берем такой код
    variable="initial_value"
    echo "new_value" | read variable
    echo "variable = $variable"     # variable = initial_value

первая команда в текущем процессе-1 задает variable="initial vaue"
вторая команда запускает дочений процесс-2 от процесса-1 для команды read variable. тоесть
    процесс-1 ===> процесс-2
вдочерний процесс-2 конечно клонируются
перменные из родительского процесса. поэтому картина такая 
    процесс-1 variable=initial_value
    процесс-2 variable=initial_value

так будет на моммент создания процесса-2
но далее эти перменные незавиисимы.

вторая строчка приведет к тому что в процесс-2 прилетит на stdin значение new_value в переменную variable
значит имеем
    процесс-1 variable=initial_value
    процесс-2 variable=new_value


третья строчка создает процесс-3 дочерний от процесс-1. клонируя при этом переенные. поэтому третья строчка напечатает что 
    variable=initial_value

насколько я понял если мы пишем в пайп и при этом есть проблема то в процесс которы пишет будет вернут
сигнал SIGPIPE (https://www.gnu.org/software/libc/manual/html_node/Operation-Error-Signals.html)

| >|

это force redirection.
через настрйоки баша можно задать что редирект неработает если файл уже сушествует.
так вот эта настройка преодолевает ту настройку
по умолчанию редирект в файл который уже существует разрешен . так что эта хрень
никогда не пригождается

| &

эта хрень позволяет раотать с джобами. по факту это баш создает дочерний процесс 
но не ждет пока тот выполнится сам ожидая в тени а после создания дочереннго процесса
обратно возврашает контроль на теоминалом себе. детали я не помню. конкретно данная хрень &
говорит о том что нужно поменстить прооцесс в бекграуд режим
пример
он создает два цикла. один выполняется в бекграуденде а второй в фореграунде
тоесть мы получаем в скрипте два параллельно работающих куска
что забавно
$ for i in {1..10}; do echo $i;sleep 3; done & for i in {11..20}; do echo $i; sleep 3; done
[1] 16570
11
1
12
2
3
13
14
4
5
15
16
6
17
7
18
8
19
9
20
10



| &&
это логический AND

правада иногда логический AND задется по другому
    if [ "$c" -eq 24 -a "$d" -eq 47 ]
    then #    ^              ^
    echo "$c equals 24 and $d equals 47."
    fi


| --
в командах опции задаются либо через - либо через --
зависит от самой команды

написано что в бащ билтинах эта хрень ообозначает конец области где задаются опции
не  в билтинах так не сработает

вобщем лучше набрать 
    $ man команда
    $ type команда
    
и посмотеть что там написано про --

| -

 
прикол с echo и -
    $ a="-n"
    $ echo "$a"
не выводит ничего. 

| ~+

это аналог $pwd

| ~-
это штука показывает предудущий рабочий каталог


| Ctrl
кнопки управления терминалом

Ctrl+A   перейти вначало строки
Ctrl+E   перейти в конец строки
Ctrl+B   стрелка влево
Ctrl+H   backspace
Ctrl+J   Enter
Ctrl+M   Enter
Ctrl+P   стрелка вверх
Ctrl+R   вылезает меню поиска предыдудущих команд по первой букве
Ctrl+S   продолжает принимать кнопки  с клавы но в термтинал их не передает
         то есть нажатия не теряюься но на терминал ничего не прилетает
Ctrl+Q   отменяет предыдущее. при этом мы увидим на экране все кнопки которые мы нажали 
         во время блока. 
Ctrl+T   меняет местами последние два введенных символа
Ctrl+U   если у нас курсор стоит посреди строки то удаляет все что левее курсора
Ctrl+W   тоже самое что предыдущее
Ctrl+Z   как я понял текущий процесс суется в бекграунд и там ставится на паузу


в мануале сказано что 
    a="^H" 
это аналог Ctrl+H 
но это полная хуйня. 
    $ echo "^H"
    ^H

| { }

я нашел замечательное примерение {}
если у меня есть какойто скрипт то чтобы его легко вбить надо всего навсего 

$ {

далее Ctrl-V скрипт 
и потом

}

и вуаля


| read
интеерсный билтин

    $ read -n10  -p '$$\>'
    $$\>
    
ключ -n дает то что символ поступают в read мгновенно а не как это есть по дефолту когда 
ожиается ввод Enter. -n 10 говорит о том что надо считать 10 символов и комарда закончит свою работу

ключ -p говорит о том что нужно на экране рисовать PROMPT тот который указан после -p в данном случае это "$$\>'
есть еще ключ -s который делает то что когда мы жмем кнопки на клаве то символы на экране не отображаются. да они улетают
в read но на экране не отображаются.

| col
как работает эта хуйня. ее ман это писаи ебанаты. в инете примеров норм нет. итак

$ echo $'\n\n\n\n  111 \v 222 \v 333 \v 444'   | col

		 444
	    333
       222
  111


значит по факту \n = \f+\r
тоесть прокркутка листа на строку вверх и вовзарат пеатной головки в самое левое положение.
\v это по идее верт и табуляция но по факту в линукс терминале это \f то есть прокрутка листа на 1 строку вверх
тоесть текс уехзжает вниз

так вот команда col она интерптиурет \v как прокрутка на 1 строку вверх а не вниз.
тоесть печатная головка поднимается наверх.
поэтому верхняя команда имеет расшифроку: опустись на 4 строки вниз и держи пеачатну гловку слева. напечаатай 111
потом подними головку на 1 строкувверх и напечаатй 222 потом подними печ головку вверх и напечаатй 333 потом поднимм
печ головку вверх и напечатай 444
тоесть таким макаром мы можем печатать текс не сверху вниз а снизу вверх.

единтвенная хуйня состоит  втом что перед тем как подниматься наверх надо обязательно опуститься вниз иначе выдаст segmentation fault
    $ echo $'\v 111'   | col
    Segmentation fault
тоесть мы еще не прокуртили лист вниз а уже пробуем поднимать головку на верх. так нихуя не работает. 
мы вначале должны опустить лист через \n (прикол что \f не подходит) и толко потом поднимать головку вверх
    $ echo $'\n \v 111'   | col
    111

тгда можно вот такое сделать

$ echo $'\n\n\n  111 \v 222 \v 333 \v 444 \n\t\t\t 555 \n\t\t\t\t 666 \n\t\t\t\t\t  777 \v 888'   | col
		 444
	    333 	 555
       222			 666	       888
  111					  777


прикол еще в том что col не понимает "\f" а жаль


| variable

оказывается что $a это сокращенная от ${a}

когда ициализируем переменную то нельзя иметь пробел слева от =
    $ a ="1"
иначе баш пытается выполнить команду a с параметром ="1"

оказется что запись
    $ a=
означает что a приварнивается значение NULL
я пока непонял эквивалетно ли это с
    $ a=""

по крайней мере
    $ a=
    $ echo -n ${a} | od -t x1
    
    $ a=""
    $ echo -n ${a} | od -t x1

на выходе байтовый поток один и тот же

оказывается можно инциализиоовать несколько переменных в одной строке через пробел

    $ a=1 b=2
    
если мы инициализируем переменную не испольуя кавычки то например "пробел"
надо экранировать

    $ a=1\ 2\ 3
    $ echo ${a}
    1 2 3

попытка напечатаать необьявленную  переменную выдаст null на выходе то есть пусто

обявление переменной это когда вот так
    $ a=
инициализациия переменной это когда мы обявляем переменную и задаем переменной значение
    $ a="1"

в любом случае резуллтат один и тот же в этих ообоих случаях
    $ echo "$b"
    $ a=
    $ echo "$a"
на выходе будет ничего
первый случай это когда переменная необьявлена
второй случай когда переменная обьявлена но неинициализирована

также оказвается что можно инициализированную переменную сделать обратно неинициализиованной
тоесть

    $ a="1"
    $ unset a
    $ echo "$a"

    
неиницализировнная перменная неимеет никаого значения а не ноль.

далее
в арифметических операциях если мы ссылаемся на необьявленную переменную то в таком случае
ее значение принимется равным нулю. это едиснчтенный случай когда необявленная переменная 
автоматом принимает значение прчием нулевое.

    $ unset a
    $ echo $a

    $ b=5
    $ echo $(( $a + $b ))
    5

далее.
опять же получается что когда мы иницализиуем переменную то нельзя чтобы ни слева ни српава от = стоял пробел.
иначе баш думает что мы ему дали команду с двумя аргуменатми

    $ a = 1
    a: command not found


переменную можно задать черещ то что ввести ее с клавы

    $ read  -p '> введите переменную и нажмите Enter > ' a; echo "a=$a"
    > введите переменную и нажмите Enter > 1
    a=1

еще переменную можно иницализиоовать вот так
    $$ a=`ls `
либо
    $ a=$(ls)

по сути они делают одно итоже. вторая команда это более новый синтаксис.
отличаются ли они внутри по реализации хрен знает


далее
наприсано что переменные у баша не имеют типов. а точнее они имеют один тип "character type"
но все равно можно желать например арифметические операции но для этого надо чтобы переменная содеражала только цифры
как я понял обработка переменных идет в завиисимости от контектса. то есть мы как бы обьясняем бащу как ему трактовать
переменную.

далее 
вот эта констурукция ${a/find/replace} ищет в переменной "$a" в любом ее места паттерн и меняет его на заданный
как толко находится паттерн то дальнйший поиск прекрашается
    $ a="#23#23"
    $ b=${a/23/45}
    $ echo "$b"
    #45#23

отличие ${a/find/replace} от ${a#find}  в том что второй всего навсего стирает заданный паттерн. причем только если 
паттерн стоит в самом начале переенной. также ${a%find} эта хрень удаляет строго с конца переенной кусок
    $ b="45#23"
    $ echo ${b#4}
    5#23
    $ echo ${b%3}
    45#2

тут параллельно вылезает такая хрень как билтин declare
например она позволяет задать свойство переменной такой что при ее дальнейше инициализации ее буквы.
я бы сказал что declare нам позволяет обьясниить башу какие значения может принимать переенная.
и тогда если мы будем давать этой переменной неправильные значения то баш будет нас посылать нахер
и преобразовывать наши неверные значения в некоторое более менее подходящее которое мы заказали
через decalre
пример declare -l огранчиывает значения только   lower case. если вводим upper case то они будут
автомтом сконвертрровны в lower case.
    $ a="AAAA"
    $ declare -l a
    $ echo "$a"
    AAAA
    $ a="BBBB"
    $ echo "$a"
    bbbb

видно что если переменная уже иницализиована и мы запускаем decalre то это никак не влияет на уже сущевтующее
значение AAAA.
а вот последующая инициализация уже проходит как надо и BBBB автоконвертиится в bbbb

а вот еще пример
declare -i огранииввает переменную только числами.
    $ declare -i b
    $ b="1"
    $ echo "$b"
    1
    $ b="a23"
    $ echo "$b"
    0

видно что когда мы задали значение переменной в форме запрещенной хрени "a23" то 
баш послал нас нахер и сконвертировал значение в 0. видимо дефолтовое значение если вводят хрень.
таким макаром ябы сказал что decalare это некий аналог типа переменных плюс автоконвертер.

кстати 
    $ declare ..
и
    $ typeset ..
это одно и тоже.

далее
declare -p позволяет посмотреть свойства переменной.

    $ declare -p  ab
    bash: declare: ab: not found

    $ ab=
    $ declare -p  ab
    declare -- ab=""

    $ ab=""
    $ declare -p  ab
    declare -- ab=""

насколко я поня из эксперимента что -- означает что на переменную не наложено никаких 
ограничений на значения. это значит что переменная была определена и иницаилизирована 
без использования declare

а вот другой пример на эту тему. 
мы определяем переменную через declare

    $ declare -i ab
    $ ab="123"
    $ declare -p ab
    declare -i ab="123"


можно посмотреть свойства встроенных системных в баш переменных

    $ declare -p IFS
    declare -- IFS=" 	
    "

    $ declare -p HOME
    declare -x HOME="/home/vasya"

едиснвтенрное я непонял смысл ключа -x = to make NAMEs export


все  полезные ключи declare
      -p	display the attributes and value of each NAME
      -i	to make NAMEs have the `integer' attribute
      -l	to convert NAMEs to lower case on assignment
      -r	to make NAMEs readonly
      -u	to convert NAMEs to upper case on assignment
      -x	to make NAMEs export


получается ключ -r позволяет задать константу
    $ unset a
    $ a="1"
    $ declare -r a
    $ echo "$a"
    1
    $ a="3"
    bash: a: readonly variable


в книжке я нашел стремный пример (https://tldp.org/LDP/abs/html/untyped.html)

    a=2334                   # Integer.
    let "a += 1"
    echo "a = $a "           # a = 2335
    echo                     # Integer, still.

    b=${a/23/BB}             # Substitute "BB" for "23".
                             # This transforms $b into a string.
    echo "b = $b"            # b = BB35
    declare -i b             # Declaring it an integer doesn't help.
    echo "b = $b"            # b = BB35


значит что этот пример делает. он беерет 2234 и сует их в $a
потом увеличиывает $a на 1 получаем 2235
потом мы берем 2235 и меняем на BB35 и присваиваем это b
итак b="BB35"
далее заупскается команда "declare -i b" и они печатают после этого $b и видят
что b=BB35 и пишут в коментацриях что мол декларе не помог превратить стринговую переменную в интеджер.
сука блядь. ну конечно же не помог. но декларе в этом не виноват. потому что как я писал выше декларе
АБСОЛЮТНО НЕ ВЛИЯЕТ на значение переменной которое уже есть. декларе влияет только на значение переменной
которое задается после применения декларе тоесть

показываю
    ...
    $ unset b
    $ b="BB35"
    $ echo $b
    BB35
    $ declare -i b
    $ echo $b
    BB35
    $ b="234"
    $ echo $b
    234
    $ b="BB234"
    $ echo $b
    0


далее. выше я писал что если переменная заобявлена или ее значение на иницализировано
и мы делаем арифемтечичекую оперцию с этой перепменной то баш ее значение в этом единственном
случае автоматом считает равным 0.
так вот эта же хрень имеет место если у нас переменная содержит символы.

    $ unset b
    $ b="BB35"
    $ echo $(( $b + 5 ))
    5

далее
если мы делим на переменную которое не обьявлена то 

    $ echo $((  5 / $abc ))
    bash: 5 /  : syntax error: operand expected (error token is "/  ")

а если мы делаим на переменную которая имеет символы в значении то по факту мы делим на 0

    $ echo $((  5 / $b ))
    bash: 5 / BB35 : division by 0 (error token is "BB35 ")
 
суммарно в плане declare я хочу сказать что польза от нее в том что если 
мы точно знаем что переменная должна принимать только числовые значения то можно 
это задать через declare хотя поведение при этом мне мало нравится. если бы
после этого при попытке присвоить пеерменной символы бащ выдавал ошибку
это было бы круто. а то что он втихаря корнвертирует стринг в 0 
неуверен что это поможет дебажить скрипт.
что касается автоковнертации стрингов в ловер кейс или аппер кейс помоему 
это вообще слабая хрень ненужная никогда или очень редко

кстати
    $ seq 10
    1
    2
    3
    4
    5
    6
    7
    8
    9
    10

кстати 
  eval это билтин баша который вот что делает "Execute arguments as a shell command."
тоесть если вставим аргумент в eval то этот аргумент будет выполнен как команда баша.
пример

    $ eval "ls -1"
    -
    03.bash
    04.bash
    05.bash
    10.bash
    11.txt


теперь беру такой пример
    $ seq 10 | sed -e 's/.*/export var&=1/'
    export var1=1
    export var2=1
    export var3=1
    export var4=1
    export var5=1
    export var6=1
    export var7=1
    export var8=1
    export var9=1
    export var10=1


тоесть seq создает числа от 1 по 10. и эта цифра подставляется вместо & в export var&=1
далее если мы это заключим в eval как аргумент тот этот код будет выполен в баше
пример

    $ seq 10 | sed -e 's/.*/echo "number = &";/' 
    echo "number = 1";
    echo "number = 2";
    echo "number = 3";
    echo "number = 4";
    echo "number = 5";
    echo "number = 6";
    echo "number = 7";
    echo "number = 8";
    echo "number = 9";
    echo "number = 10";

    $ eval $( seq 10 | sed -e 's/.*/echo "number = &";/' )
    number = 1
    number = 2
    number = 3
    number = 4
    number = 5
    number = 6
    number = 7
    number = 8
    number = 9
    number = 10


далее 
 переменные окружения передаются от родительского процесса его дочерним.
в обратную сторону связи нет. от дочери родителю ничего из переменных не передается.


далее
команда basename. она берет полный путь к файлу как аргумент. и возвращает только конечный файл
    $ basename '/home/vasya/temp/\!9/debug.bash'
    debug.bash
кстати надо заметить что хотя я использовал '' для указания пути но знак ! все равно нужно 
экранировать , так как иначе вместо !9 баш подставляет туда команду из баш хистори.

кстати 
можно сделать переменную как readonly нетолько через decalre но и через 
другой билтин readonly
во первых этот билтин может показать за один раз все переменные которые 
имеют свойства readonly

    $ readonly -p 
    declare -r BASHOPTS="checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote"
    declare -ir BASHPID
    declare -ar BASH_REMATCH=()
    declare -ar BASH_VERSINFO=([0]="4" [1]="4" [2]="20" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
    declare -ir EUID="1000"
    declare -ir PPID="26695"
    declare -r SHELLOPTS="braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor"
    declare -ir UID="1000"
    declare -r a="1"
    declare -r abc


как сделать переменную read only
    $ readonly abc
для сравнения через decalre это делается так
    $ declare -r abc

так вот далее я нашел такую шокирующую инфо о том что если мы переменную обьявили как константу (рид онли)
то обратно ее превратить в обычную переменную = нельзя никак. все что можно это убить этот процесс баша.
ничего сделать нельзя другого.но есть вот какой выход. мы можем запустить в данном баше
еще один баш. дочерний баш унаследует все переменые из родителя. но при этом переменная наша уже не будет
иметь статуса рид онли. пример

    $ readonly abc
    $ unset abc
    пошел нахер
    $ bash
    $ unset abc
    сукксесс
    

далее 
 -n $var  проверяет что длинна переменной НЕноль. если длина НЕноль то код возврата $?=0 (success)
пример
    $ a="123"; [ -n "$a" ] && echo "переменная \$a непустая"
    переменная $a непустая


далее
рассмотрим такой скрипт
    $ cat 06.bash 
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 

смотрим результаты работы
    $ ./06.bash 
    Parameter #1 отсуствует
    $ ./06.bash 1
    Parameter #1 is 1
    $ ./06.bash "1"
    Parameter #1 is 1
    $ ./06.bash ""1""
    Parameter #1 is 1
    $ ./06.bash "\"1\""
    Parameter #1 is "1"

что примечательно. если мы вызываем скрипт с аргументом который выглядит как 1 либо "1" либо ""1"" то он 
прилетает внутрь скрипта как 1.  
а если мы хотим чтобы внутри скрипта прилетел именно "1" то аргумент нужно в командной строке задавать как "\"1\""
удивительно.

далее. прикол
для того чтобы работать с аргументом 10,11 итд то нужно к ним обращаться внутри скрипта не как $10 или $11
а ${10) , ${11}
об этом написано в книжке

    $ cat 06.bash   
    #!/bin/bash

    if [ -n "$1" ]              
    then
        echo "Parameter #1 is $1"  
    else 
        echo "Parameter #1 отсуствует"
    fi 


    if [ -n "${10}" ]              
    then
        echo "Parameter #10 is ${10}"  
    else 
        echo "Parameter #10 отсуствует"
    fi 

работа скрипта
    $ ./06.bash 1 2 3 4 5 6 7 8 9 a
    Parameter #1 is 1
    Parameter #10 is a


далее
скрипт
скрипт берет путь к скрипту. удаляет из него весь путь кроме названия файла.
и потом к нему добавляет ./

    #!/bin/bash
    echo "путь к скрипту ./$(basename "$0")"

запускаем скрипт
    $ ./06.bash 
    путь к скрипту ./06.bash

далеее
еще раз напомню про $@ и $*
первая сохраняет все аргументы скрипта в массив.
а вторая собирает все аргументы в единую переменную

    $ cat 03.bash 
    #!/bin/bash

    echo '$*='"$*"
    echo '$@='"$@"
    echo ""

    for i in "$@"
    do
        echo "\$@[$i]=$i"
    done

    echo ""

    for i in "$*"
    do
        echo "\$*[$i]=$i"
    done


запускаю скрипт
    $ ./03.bash 1 2 3 4 5 6 7 8 9 a
    $*=1 2 3 4 5 6 7 8 9 a
    $@=1 2 3 4 5 6 7 8 9 a

    $@[1]=1
    $@[2]=2
    $@[3]=3
    $@[4]=4
    $@[5]=5
    $@[6]=6
    $@[7]=7
    $@[8]=8
    $@[9]=9
    $@[a]=a

    $*[1 2 3 4 5 6 7 8 9 a]=1 2 3 4 5 6 7 8 9 a

что интеерсно. что индексы в массиве начинаются с единицы походу. а не с нуля.

далее
 -lt 
означает less than. арифм сравнение
    $ a="12"; [ "$a"  -lt 100 ] && echo "\$a меньше чем 100"
    >>$a меньше чем 100

далее
на счет []
согласно man bash это одно и тоже
    $ test expr
    $ [ expr ]
    
также в баше есть билтин '['
но также есть и внешняя команда /usr/bin/[
так вот баш запускает именно внешнюю команду

$ strace [ 10 -lt  1 ]
execve("/usr/bin/[", ["[", "10", "-lt", "1", "]"], 0x7ffdd5429b60 /* 66 vars */) = 0

тоесть запускается файл  "/usr/bin/[" а дальше к этой команде присобачиваются аргументы. причем обязательно последним
аргументом нужно указать "]" иначе программа пошлет нахер/

получается первая скобка это название файла. далее идут аргументы. и последняя скобка это тоже аргумент.

что странно если я набираю 
    $ man [
он мне выдает man от команды /usr/bin/test
хотя /usr/bin/[ и /usr/bin/test это два разных файла

    $ stat /usr/bin/[
        File: /usr/bin/[
        Size: 51384     	Blocks: 104        IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23330837    Links: 1

    $ stat /usr/bin/test
        File: /usr/bin/test
        Size: 47288     	Blocks: 96         IO Block: 4096   regular file
    Device: 10302h/66306d	Inode: 23332131    Links: 1

видно что иноды разные

хотя еще как я уже сказал и есть башевский билтин [

    $   builtin [ 10 -lt  1 ]


кстти выискивать что значат все эти -lt -n -d и прочие штуки для сравнения проще не в man bash а в 
    $ man test

| !

возвращаюсь к вопрому который уже освещал.
как в переменной укзать имя другой переменной и потом докопаться до этой второй переменной из первой переменной
а вот как
    $ a="1"
    $ b=a
    $ echo ${!b}
    1

замечу что именно ${!b} а вот так не работает ${!$b}

теперь если вернкемся к спец перееменным которые ест при вызове скрипта. то там есть спецпеременая $#
соовествнно ее имя # 
эта переменная укзаывает на число аргументов с которыми запущен скрипт. напоминаю что $0 это имя скрипта $1 первый аргумент
соовесвтенно $n это n-ый аргумент. получается если аргуметов 10 то $#=10 и значит эта же переменная показыает на две хрени 
сразу и на число переенных и на номер последней переменной. еще раp $# указывает на порядковый номер последней переменной 
но естевственно не содержит значение этой последней переменной. и чтобы посмотреть ее содержимое надо вот так 
    $ echo ${!#}
теперь имеем скрипт
он работает так
мы проверяем что число аргументов скрипта больше чем 0
если это так то мы печатаем содержимое переменной имя которой хранится в переменной с именем # тоесть ${!#}
потому что если аргументов 10 то $#=10 а нам нужно добраться до ${10}
    $ cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo "число аргументов 0"

запускаем его
    $ ./07.bash 
    число аргументов 0

    $ ./07.bash a b c 
    последний аргумент =  c

    $ ./07.bash 1 2 3 4 5  a b c d e f
    последний аргумент =  f


хочу заметить что если скрипт запущен без аргументов  то у него все равно всегда есть один аргумент $0 который
содержит имя скрипта. точнее путь к скрипту.

я модицфиуировал скрипт

    $  cat 07.bash 
    #!/bin/bash

    [ "$#" -gt 0 ] && echo "последний аргумент =  ${!#}" || echo -e "число аргументов 0,\nоднако \$0=\"$0\""

теперь запускаю скрипт без аргументов
    $ ./07.bash
    число аргументов 0,
    однако $0="./07.bash"

далее рассматривается интересная вещь.
вот у нас есть переменная
    $ a="123"
мы хотим создать новую перемнную которая будет в себе содержать "$a" + "_"
как это сделать. первая попытка
    $ b="$a_"
    $ echo $b

однако на выходе пусто. почему. потмоу что баш ищет переменную с именем a_ которой конечно нет.
а как нам тогда обьяснить то что мы хотим. а вот как
    $ b="$a"_
    $ echo $b
    123_

вот еще похожий пример
    $ read -p '>>' var1; echo "var1=$var1"; var2="$var1"_; echo "var2=$var2"; var3="${var2%_}"; echo "var3=$var3"
    >>890
    var1=890
    var2=890_
    var3=890

мы считываем переменную из клавы. потом добавляем "_" потом его отрезаем обратно.

до этого обсуждалась проверка вида -n $a которая проверяет что длинна стринга ненулевая.
есть обратная проверка которая проверяет что длинна стринга нулевая -z $a

    $ a="" && [ -z "$a" ] && echo "переменная пустая"
    переменная пустая
    

еще пример на созвучную тему

    $ cat 08.bash 
    #!/bin/bash

    if [  -z "$1" ] 
    then
        echo -e "ERROR: аргумент отсутствует \nUsage: $0 arg1 "
        exit 1
    else
        echo "аргумент = $1"
    fi

запускаю скрипт
    $ ./08.bash 
    ERROR: аргумент отсутствует 
    Usage: ./08.bash arg1 

    $ ./08.bash  "1a"
    аргумент = 1a

    
| ${var:-default}

эта хрень позволяет задать дефолтовое значение если значение переменной $var незадано или равно пусто
что вобщем то одно и тоже

    $ a="1"; b="${a:-33}"; echo "$b"
    1
    $ a=""; b="${a:-33}"; echo "$b" 
    33

эта хрень поможет в скрипте. если мы не хотим проверять был ли введен аргумент $1 или нет.
тогда нам поможет эта констркция.

    $ cat 09.bash 
    #!/bin/bash

    disk="${1:-sda}"
    echo "диск = $disk"

запускаю скрипт
если мы не указываем при запуске аргумент 
то баш подставляет в переменную дефолтовое предопределенное значение
    $ ./09.bash  sdb
    диск = sdb

    $ ./09.bash 
    диск = sda


| case


    case EXPRESSION in

    PATTERN_1)
        STATEMENTS
        ;;

    PATTERN_2)
        STATEMENTS
        ;;

    PATTERN_N)
        STATEMENTS
        ;;

    *)
        STATEMENTS
        ;;
    esac

кстати последння хрень это если не будет найдено ни одно значение.
а вот пример case когда он в одну строчку

    $ { case "b" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    b
    $ { case "z" in   "a") echo "$a";;   "b") echo "b";;   "c") echo "c";;   *)  echo "не найдено";; esac;  }
    не найдено


далее
пример
скрипт проверяет наличие аргумента при вызове скрипта.
и печатает этот аргумент
далее проверяется под каким именем файла был запущен скрипт.
если имя файла 10.bash или 11.bash то печатается имя скрипта

сам скрипт имеет имя 10.bash
также надо создать симлинк 11.bash 

    $ ln -s ./10.bash ./11.bash

    $ cat 10.bash 
    #!/bin/bash

    E_NOARGS=75

    if [ -z "$1" ]
    then
        echo  "Error: NO_ARGS"
        echo  "Usage: $(basename $0) [ARG]"
        exit $E_NOARGS
    else
        echo "аргумент = $1"
    fi



    case "$(basename "$0")" in

        "10.bash")
            echo "скрипт запущен как  10.bash"
            ;;

        "11.bash")
            echo "скрипт запущен как 11.bash"
            ;;

        *)
            echo "неопознанная ошибка"
        exit 1
            ;;
        esac



запускаю скрипт
    $ ./10.bash    
    Error: NO_ARGS
    Usage: 10.bash [ARG]

    $ ./11.bash    
    Error: NO_ARGS
    Usage: 11.bash [ARG]

    $ ./10.bash    123
    аргумент = 123
    скрипт запущен как  10.bash

    $ ./11.bash  234  
    аргумент = 234
    скрипт запущен как 11.bash



| shift

как уже было сказано выше он сдвигает аргументы которые были указаны при вызове скрипта
тоесть второй аргумент присваивается первому 
    $2 ---> $1
третий аргумент присвивается второму
    $3 ---> $2
единственное что $0 остатеся неизменным. это логично


##


=== остановился тут

$$$$$$$$$$$$$
$$$$$$$$$$$$$
$$$$$$$$$$$$$

вопросы:
- вернуть обратно модуля ядра чтобы coretemp опять заработал
- thermal zones
- yaml формат  в thinkfan
- <<<



- а как происходит запись в файл сразу двух процессов?
как при этом работает
$ : > file



-  изучить bash advanced guide
