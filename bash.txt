bash

| приколы

приколы баша
$ echo !4
echo ps aux | grep sleep
$ echo !0
bash: !0: event not found
эта хрень показывает команды из истории команд


| tr

эта комнда ищет паттерн и меняет его на другой

$ echo " output=10; input=16; A0" | tr [:lower:] [:upper:] 
 OUTPUT=10; INPUT=16; A0


$ echo "aaa bbb " | tr "a" "D"                             
DDD bbb 



эта команда он подлая. об этом можно прочитать в info tr
вот пример

$ echo "b" | tr  bbbbb  12345
5

вчем подлость команды tr : у нас в паттерне есть несколько b возникает вопрос
когда мы находим b в нашем слове то какой b использовать? тот который b в 1 превращает
или b который в 2 превшращает? или b который в 5 превращает?
ответ такой что берется самый последний b. поэтому все b пропускаются в шаблоне
и берется последний b кторый превращает b в 5.

еще пример

$ echo "a"  |  tr    aaaaaaaaaa 1234567890
0


тоесть у нас есть шаблон aaaaaaaaaa у нас естт исходное ссобщение 'a'
возникает вопрос какой a нужно брать из шаблона. овтет последний.
потом смотрим на какой символ мапится последний a  в шаблонке ответ а ноль.


прмиер

$ echo ooops not good | tr oops nice
iiice nit giid

как это рабооает. 
у нас есть шаблон "oops" у нас есть слово "ooops"
в шаблоне берем последний "o" он мапитсят в "i" получается

[ooo]ps -> [iii]ps

остатеся вопрос с ps он мапиисят напрямую поэтому 

[ooo][ps] -> [iii][ps] = iiips

далее берем слово "not"
берем шаблон "ooops" 
в шаблоне "n" нет. есть "o" но в шаблоне "o" несколько. мы берем последнее "o"
второе "o" мапится в "i"

потмоу что o[o]ps n[i]ce

значит n[o][t] --> n[i][t]
бквы t нет в шаблоне значит t остается без изменений значит

not -> nit

берем слово "good"
ни g ни d нет в шаблоне они без изменений. 
буква o есть  в шаблоне. их несколько в щаблоне мы беерм послнее o в щаблрне оно маится в
i значит

g[oo]d  --> giid

значит в итоге 

iiips nit giid

в целом намой взгляд достоачно неинтуитивная и ебанутая команда этот tr


| special variables $0 $1 $@  $# $* $? $$ $!

`$0` – The name of the script being executed.
`$1-$9` – The first nine command-line arguments.
`$#` – The number of command-line arguments.
`$*` – All command-line arguments as a single string.
`$@` – All command-line arguments as an array.
`$?` – The exit status of the last executed command.
`$$` – The process ID of the current shell.
`$!` – The process ID of the last background command.


рассмотрим $0
я не согласен то о чем везде пишут что $0 это имя скрипта.
посмотрим

$ echo $0
bash

$ /bin/bash
$ echo $0
/bin/bash


$ ln -s /bin/bash ./b-lnk
$ ./b-lnk
$ echo $0
./b-lnk


$ ln -s ./b-lnk ./c-lnk
$ ./c-lnk
$ echo $0
./c-lnk

отсюда видно что $0 эта переменная показывает каким образом был запущен процесс.
а именно его такой параметр как /proc/$$/cmdline

/proc/self vs /proc/$$/ (self это не перменная. это симлинк в /proc/)

запускаем чтото в баше . тогда он себя форкает через сисколл(просит об этом ядро тоесть)то создает дочерний процесс
а вот если в баше прога зпускатся через exec то баш взывает сисколл exec тоесть управлениеп
передаетая ядру. и ядро замещает усовно говорят код баша в процессе в котором крутится баш 
на код вызываемой программы.  

мы импользуем exec когда не хотим создавать новый процесс. а хотим запустиьт прогу
в рамкаж уже этого процесса. 



--
вот так верно

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c", "sleep 120"]

а так полет нахер

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c sleep 120"]

--
вот так верно

docker run --rm --name t1 -it    --entrypoint  "/bin/bash"   ubuntu  -c "sleep 120"

а так полет рахер

docker run --rm --name t1 -it    --entrypoint  '/bin/bash -c "sleep 120"'   ubuntu  
отому что в доках дкоера написано что --entrypont должно сдежать татолько
путь к бинарнику\скриту. но не к параметрам. параметры пишктая в самом справава



==

| -
| ~-

в баше любили повыебвыаться.

если мы в качестве пути укажем "-" то баш подставит вместо этого $OLDPWD
где OLDPWD это сохранненный есть предыдущая папка в которой ты был.
но эта хрень раротботет только с встроенным билтином cd и только в единствнной форме

$ cd -
эквивалентно
$ cd $OLDPWD

при этом вот такое уже нераобтеает

]$ cd -/tmp
bash: cd: -/: invalid option
cd: usage: cd [-L|[-P [-e]] [-@]] [dir]

в эхо это тоже неработает

$ echo -
-


втора хрень "~-" она более универсальная. она раобтотает уже нетолько с cd
но и скажем с echo 

$ echo $OLDPWD
/
[vasya@lenovo //]$ cd ~-
[vasya@lenovo /]$ echo ~-
//


пиздец доблеблы в этом баш. выбеонщики

нашел этот все зесь = https://unix.stackexchange.com/questions/330876/difference-between-cd-and-cd
===
| bash
| redirect
| exec

bash
io redirect

(для начала ознакомился с этим https://tldp.org/LDP/abs/html/io-redirection.html)

разбереся как работает эта команда
       # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3

для начала
немного отойдем в сторону что будет если ввести команду
$ cat > 56.txt
а будет вот что. команда будет ждать ввода текста со стандартного ввода.
тоесть можно сидеть и набирать текст. когда хотим закончить набор то жмем Ctrl+D.
и этот текст набранный в терминале на экране будет записан в файл.

получается форма вида

# echo "asd" > /tmp/1.txt 
это укороченная форма команды
# echo "asd" 1 > /tmp/1.txt

и команда вида
# cat < 1.txt
это укороченный аналог
# cat 0 < 1.txt
(взял отсюда https://tldp.org/LDP/abs/html/io-redirection.html)

еще важная хуйня про io redirect
надо обязательно дескриптор файла ставить рядом без пробелов со знаками ">","<" итп.
тоесть

$ dfrtr 2>4.txt
$ cat 4.txt
dfrtr: command not found

тоесть видно что редирект сработал. мы ввели несуществующую команду.
при этом канал ошибок был заредиректен на файл 4.txt
видно что мы ввели "2>..." тоест между 2 и ">" нет пробела. 
такой редиректо сработает.

$ dfrtr 2 >4.txt
dfrtr: command not found

а этот редирект неработает. потому что у нас между 2 и ">" стоит пробел.

далее . разберем поподробнее пример
    $ dfrtr 2>4.txt

что в нем интересно это как оно выполняется.
у нас есть баш процесс и мы его просим запустить команду "dfrtr"
баш процесс выполняет сисколл и просит ядро создать новый процесс самого себя. когда клон исходного процесса
будет создан в форме нового процесса то баш в новом процессе ищет среди $PATH бинарник с именем "dfrtr"
ненаходит его и посылает на sterr ошибку. если бы бинарник был бы найден то баш склонированного процесса
выполнил бы еще один сисколл который просит ядро заменить в текущем процессе бинарник баша на бинарник dfrtr.
соотсвтвенно вопрос - кто кидает в stderr ошибку что файл ненайден - баш в склонированном процессе или ядро?
как я понимаю имеено баш запускает ряд сисколлов stat в разных папках которые у него прописаны в $PATH
и все сисколлы сообщают бинарнику баша что там такого файла нет. тогда бинарник баша пишет в sterr 
сообщение о том что файл ненайден. таким образом именно бинарник баша кидает на stderr сообщение об ошибке
я не ядро. потому что важно было понять кто занимается отправкой сообщений на stderr юзерская программа
или само ядро. 
вот доказательство

$ strace  bash -c "kuku"
...
stat(".", {st_mode=S_IFDIR|0775, st_size=1011712, ...}) = 0
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/sbin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/sbin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/bin/kuku", 0x7ffcfd0c62a0)   = -1 ENOENT (No such file or directory)
stat("/sbin/kuku", 0x7ffcfd0c62a0)      = -1 ENOENT (No such file or directory)
stat("/bin/kuku", 0x7ffcfd0c62a0)       = -1 ENOENT (No such file or directory)
stat("/usr/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/snap/bin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)

тоесть видно что бинарник баша ищет бинарник kuku во всех папках которые есть у него в $PATH
и ничего ненаходит.
...
write(2, "bash: kuku: command not found\n", 30bash: kuku: command not found
) = 30

и тогда бинарник баша сам лично через сисколл write пишет в дескриптор "2" об ошибке
я совершенно не утверждаю что в 2 неможет писать само ядро. но в данном случае ошибку генерирует
сам юзерский процесс.

так вот вовзращаемся к примеру
        $ dfrtr 2>4.txt
рассмотрим более простой пример для начала
        $ dfrtr
        dfrtr: command not found

кто гененриует ошибку? ответ склонированный бинарник баша генерирует.
у нас наш текущий процесс баша сам себя клонирует. дальше в дело вступает клонированный баш.
он начинает искать бинарник dfrtr по всем папкам прописанным в $PATH
ненаходит. и тогда он склонированный бинарник баша пишет в 2 о том что файл ненайден.
таким образом отвечаю на вопрос - если команда не найден то кто генерирует ошибку?
возвращаемся к примеру
         $ dfrtr 2>4.txt
наш текущий баш склонирует самого себя в новый процесс через сисколл к ядру.
плюс наш исходный баш попросит ядро чтобы при создании нового процесса его дескриптор 2 указывал 
не на pty файл ( не на терминал как это обычно бывает)  а на файл ./4.txt
таким образом привязку 2 к 4.txt для нового процесса делает ядро по просьбе родительского баша.
дочерний баш к этому не имеет никакого отношения. дочерний единственное что сделает это напишет в 2 
что файл не найден. гениально. мудота та еще...
важно еще то что такого рода редирект файловых дескрипторов происходит не для исходного процесса баша 
а исключительно для новых порождаемых процессов. это тоже важно отметить. 

теперь фундаментальный вопрос а как нам изменить привязку файловых дескрипторов не для новых 
порождаемых процессов а для текущего процесса в котором крутится bash
в этом нам поможет баш билитн exec


баш builtin exec
что он делает.
по дефолту если мы запускаем команду в баше то баш это процесс как любой другой.
когда мы запускаем команду то баш создает новый процесс и в нем уже запускает нашу команду.
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
тоесть видно что номер баш процесса 31410
когда мы в нем запустили команду pstree то баш создал новый процесс 31426
так вот exec заставляет бащ не создавать новый процесс а запустить эту команду в текущем процессе
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
$ exec sleep 120
$ pstree -Asp 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---sleep(31410)
видно что процесс 31410 остался но там уже не баш а наша команда. а нового процесса нет.

как видно не создавание нового процесса было выполненно через баш билтин exec . в виде

$ exec команда

итак "exec команда" не порождает новый процесс а в текущем процессе заменяет бинарник.
есть надежда что подключение io redirect вкупе с exec позволит нам изменить привязки файловых
дескрипторов для текущего процесса.

$ echo $$
32624
$ exec sleep 130 2>3-err.txt

итак у нас был баш процесс 32624 со стададартной привязкой его дескрипоров 1,2,3 к терминалу
далее мы говорим что в текущем процессе заменить баш на sleep и для этого процесса (для того же самого)
задать что файловый дескриптор 2 должен смотреть на файл 3-err.txt

проверяем
$ ls -1al /proc/32624/fd
total 0
dr-x------ 2 vasya vasya  0 окт  4 09:00 .
dr-xr-xr-x 9 vasya vasya  0 окт  4 09:00 ..
lrwx------ 1 vasya vasya 64 окт  4 09:00 0 -> /dev/pts/21
lrwx------ 1 vasya vasya 64 окт  4 09:00 1 -> /dev/pts/21
l-wx------ 1 vasya vasya 64 окт  4 09:00 2 -> /home/vasya/temp/3-err.txt

и это действительно сработало!
процесс по номеру не поменялся. зато его привязка для дескриптора 2 поменялась.

попробуем на этом фоне более интересный пример
запустить баш из баша при этом перенаправить его 2 в 5.txt
для начала я хотел показать одну важную вещь. вот  у нас есть баш процесс.
я думал что prompts приглашение этот процесс пишет в 1 тоесть в stdout
а оказалось что он его пишет на stderr! показываю

$ echo $$
31668
$ bash 1>7.txt
таким макаром я запустил новый процесс баша и его stdout я завернул на файл 7.txt
$ 
при этом как видно у меня на экране по прежнему присуствует prompt тоесть 
этот prompt он пишется процессом как я уже сказал не на stdout а на stderr

открываю другой терминал и проверяю что новый баш имеет то  редирект в файл который я сказал
(другой терминал)$ $ cat 7.txt 
2661
(другой терминал)$ pstree -Asp 2661
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31668)---bash(2661)
видно что новый баш это чайлд от головного баша
(другой терминал)$ ls -1al /proc/2661/fd
lrwx------ 1 vasya vasya 64 окт  4 10:27 0 -> /dev/pts/22
l-wx------ 1 vasya vasya 64 окт  4 10:27 1 -> /home/vasya/temp/7.txt
lrwx------ 1 vasya vasya 64 окт  4 10:27 2 -> /dev/pts/22
lrwx------ 1 vasya vasya 64 окт  4 10:27 255 -> /dev/pts/22
четко видно что наш дочерний баш имеет stdout завернутый в файл

так вот аналогично легко убедться что если мы запустим баш у которого stderr будет завернут
в файл то  у нас приглашение баша исчезнет с экрана потому что оно теперь будет писаться не в терминал а в файл
$ bash 2>8.txt

и все у нас на экране больше нет prompt

так вот до этого моменты мы создавали дочерний процесс баша у которого был настроен редирект одного из 
файл дескрипторов в файл. 
теперь сделаем тоже самое без создавания дочернего процесса.
в первом терминале запускаем
    $ echo $$
    2963
    $ exec bash 1>10.txt
    $ 

во втором терминале проверяем
$ pstree -Asp 2963
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(2963)
$ ls -1al  /proc/2963/fd 
lrwx------ 1 vasya vasya 64 окт  4 10:31 0 -> /dev/pts/23
l-wx------ 1 vasya vasya 64 окт  4 10:31 1 -> /home/vasya/10.txt
lrwx------ 1 vasya vasya 64 окт  4 10:31 2 -> /dev/pts/23
lrwx------ 1 vasya vasya 64 окт  4 10:32 255 -> /dev/pts/23

видно что исходный процесс 2963 не имеет чайлдов и что его 1 перенаправлен в 10.txt
таким макаром мы научились текущий баш процесс менять таким образом чтобы у него менялась 
привязка его файл дескрипторов. вот эта волшебная команда
        $ exec bash 1>10.txt
так вот в описании билитина exec написано что это можно сделать еще короче.
цитирую
$ exec --help
exec: exec ... [command] ... [redirection ...]
...
 If COMMAND is not specified,
    any redirections take effect in the current shell.

тоесть тут написано что если не указать никакой команды то получается что он автоматом меняет дескрипторы
указанные в [redirection] для данного процесса. 
проверяем
    $ echo $$
    3208
    $ exec 1>11.txt
    $ 

проверяем в другом терминале
$ pstree -Asp 3208
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(3208)
$ ls -1al  /proc/3208/fd
lrwx------ 1 vasya vasya 64 окт  4 10:39 0 -> /dev/pts/26
l-wx------ 1 vasya vasya 64 окт  4 10:39 1 -> /home/vasya/11.txt
lrwx------ 1 vasya vasya 64 окт  4 10:39 2 -> /dev/pts/26
lrwx------ 1 vasya vasya 64 окт  4 10:39 255 -> /dev/pts/26

и действительно да. процесс 3208 не имеет никаких чайлдов. и его 1 имеет редирект на файл!
гоча!

я бы еще как сказал хотя это не совсем верно. что если мы никакую команду не подставляем в exec
то баш сам автоматом как бы подставляем bash тоесть  как бы 
    exec 1>11.txt = exec bash 1>11.txt
хотя это не совсем так. потому что в первом случае он не меняет бинарник в памяти а во втором случае
он удаляет старый бинарник и сует в процесс новый бинарник. (ксатти сказать процесс получается это как бы коробка (типа фреймворк) плюс начинка в виде бинарника)


двигаем дальше. вот еще интересный пример который нам пригодится
$ echo $$
3554
$ exec bash 12<>12.txt
$ echo $$
3554
[vasya@lenovo ~]$ ls -1al /proc/$$/fd
lrwx------ 1 vasya vasya 64 окт  4 10:49 0 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 1 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 12 -> /home/vasya/12.txt
lrwx------ 1 vasya vasya 64 окт  4 10:49 2 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 255 -> /dev/pts/29

мы говорим чтобы в нашем текущем процессе был заменен бинарник на баш
и чтобы  в нашем процессе был открыт новый файловый дескриптор с номер 12 и чтобы этот файловый дескриптор
был связан с файлом 12.txt который будет открыт с флагами и на чтение и на запись.
что примечательно в этой команде. примечательно то что мы можем изменить для данного процесса
число его файловых дескрипторов. было 0,1,2,255 (правда какого хрена тут делает 255 непонятно. вернее понятно.
я же запускаю bash из некоего другого процесса скажем это gnome-terminal или xterm или из под граф оболочки 
и открытые файловые дескрипторы в родительском процессе автоматом наследуются и дочерним процессом вобщем щас нам этот 255 неважен) а стало 0,1,2,255,12.
таким макаром мы можем "прикрепить" к процессу дохрена файловых дескрипторов и дохрена открытых файлов.
при том что самому бинарнику процесса на этот абсолютно плевать. вот эти открытые файлы , прикрепленные файловые
дескрипторы они бинарник ни к чему не обязывают. это как в квартире понаделать больше окон. 
если процесс нехочет ни читать с данного файлового дескриптора ни писать в него то его никто к этому не обязывает. это как у машины добавить запасных колес. или в ящике понаделать новых дырок. тот кто сидит в яшике (бинарник)  может пользоваться этими дырками а может и нет. опять же что интересно у нас обычно один процесс родительский порождает некий дочерний процесс и родитель может заказать для дочернего процесса понаоткрывать 
для него кучу файлов. но дочернему процессу это может быть глубоко фиолетово. он может пользоваться открытыми 
для него файлами а может и нет. это никак не влияет на него. 
что еще важно это вот значок  "<>" он на самом деле никакого мистического значения не имеет. он на самом деле 
только значит то что в сисколле будет прописано что открываемый файл открывается с флагами "R+W" тоесть 
и на чтение и на запись. сразу в догонку скажу что значок ">" говорит через сисколл ядру что нужно открыть файл 
с флагом "W" а значок "<" говорит ядру что файл нужно открыть с флагом "R"
тоесть то что изначально называется редиректом. это корявое определение. это не редирект это команда ядру 
на то  с каким флагом нужно открыть файл. тоесть 
        $  echo 1 1>4.txt
комбинация "1>4.txt" говорит башу как ему выстроить сисколл который он будет пулять в ядро. 
сисколл должен быть такой что - надо открыть файл 4.txt причем с флагом "W" и привязать этот файл к дескриптору 1. ну да.. на последнем этапе можно скзаать что мы имеем дело с редиректом. но важно подчеркнуть что значки
"<" и ">" и "<>" их смысл не только редирект но и с каким флагом открыт файл на который они ведут. 
">" =  W
"<" =  R
"<>" = RW

еще пример 
        $ echo "abc" 12<>5.txt
здесь ксати тоже интересно. дело в том что echo это билтин баша. поэтому ему ненужно себя клонировать.
а он выполняет команду ровно в текущем процессе. так вот для текущего процесса будет открыть файл 5.txt
в режиме "RW" и будет создан файловый дескриптор 12 который будет прикреплен к текущему процессу 
сам же echo ясен банан выплюнет свой "abc"  в дескриптор 1. тоесть ему этот открытый дескриптор 12 
в целом нахрен не сдался. просто мы делая одно одновременно сделали и другое
причем насколько я понимаю баш он умный и он откроет этот файл и создаст дескриптор но как 
только билтин закончит работу то баш автоматом закроет файл и уничтожит дескриптор. вот 
доказательство
    $ echo "abc" 13<>13.txt
    abc
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:12 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 2 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:25 255 -> /dev/pts/31
тоесть еще раз так как echo это билтин то никого нового процесса создано не будет. все
будет делать в рамках текущего баша. поэтому я и смотрю список открытых файлов для текущего процесса.
и видно что никакого дескриптора 13 нет и в помине. он был создан и тут же обратно удален.
я так это понимаю.

совершенно другой коленкор когда мы через баш запускаем некую внешнюю программу и просим баш прилепить к ней
открытый файл. баш составит нужный сисколл для ядра. и мы все будем иметь.
    $ sleep 130 14<>14.txt

с другого терминала смотрим
    $ ps aux | grep sleep
    vasya     4806  0.0  0.0  14580   892 pts/31   S+   11:28   0:00 sleep 130
    $ ls -1al /proc/4806/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:29 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 14 -> /home/vasya/14.txt
    lrwx------ 1 vasya vasya 64 окт  4 11:29 2 -> /dev/pts/31

тоесть у нас баш себя клонировал тоесть попросил ядро создать новый процесс. причем при клонировании попросил 
ядро чтобы дочерний процесс имел открый файл 14.txt через дескриптор 14.
далее баш в дочернем процессе попросил ядро через  сисколл заменить свой
бинарник на sleep.
поэтому все так выглядит
еще раз подчеркну что значок "<>" в конечном итоге означае то что файл 14.txt открывается с флагами и на чтение
и на запись. флаг "<" открывает файл на чтение только, флаг ">" открывает файл на запись только
причем имеется ввиду для данного процесса. ничто мне не мешает из другого процесса попросить ядро открыть этот файл с другими флагами. тоесть скажем наш процесс открывает файл только на запись. а с другого процесса я прошу
ядро открыть файл на чтение. и таким макаром я спокойно читаю то что пишет туда первый процесс.

также попутно я покажу докажу что когда баш запускаем внешний бинарник то он создает новый процесс 
клонирует себя а если мы запускаем баш билтин то новый процесс не создается.
я запутил баш с номером процесса 4309
в соседнем окне я запустил strace
$ sudo strace -p 4309 -e clone,fork,execve
strace: Process 4309 attached

и в первом окне я запустил ls -1
и мне strace нарисовал
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fe0cc338a10) = 4589

а потом я в первом окне запустил echo 1
и мне strace ничего не нарисовал
это все доказывает

теперь переходим к интересному.
зная все что мы узнали выше я открою файл /dev/cpu_dma_latency
в текущем баше так чтобы он оставался открытым
    # exec bash 16> /dev/cpu_dma_latency;
    # ls -1al /proc/$$/fd
    lrwx------ 1 root root 64 окт  4 11:37 0 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:37 1 -> /dev/pts/32
    l-wx------ 1 root root 64 окт  4 11:38 16 -> /dev/cpu_dma_latency
    lrwx------ 1 root root 64 окт  4 11:37 2 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:38 255 -> /dev/pts/32

ну или можно было короче написать
    # exec 16> /dev/cpu_dma_latency;
мы открыли /dev/cpu_dma_latency на запись и прикрепили его к процессу через дескриптор 16
показываю чему он равен прям щас 
    # cat /dev/cpu_dma_latency  | od -t x1
    0000000 00 94 35 77
    0000004

теперь можно его изменить вот так
    # echo -en "0x00000258" 1>&16
здесь так как echo у нас шлет свои данные на stdout тоесть в 1 то я перенаправил в 16.
на low level уровне это работает так что по дефолту баш юзает сискол
write (1,"текст")
а когда мы ему дали подсказку то он делает
write(16,текст)

проверяем что сработало
# cat /dev/cpu_dma_latency  | od -t x1
0000000 58 02 00 00
0000004
да сработало получается.
такой вывод наоборотный потому что в оперативку много байтовой число пишется в little endian формате.
об little endian  читай в ext4.txt

также отмечу вот это "1>&16" знак амперсанда говорит бащу что мы делает перенаправление не в файл  с именем 16 на файловой системе а в файловый дескриптор 16. это две большие разницы.
ксати я щас попробую сделать запись в несуществующий дескриптор
    # echo -en "0x00000258" 1>&28
    bash: 28: Bad file descriptor
все верно. пошел нахер


итак еще раз
что было сделано
     # exec 16> /dev/cpu_dma_latency;
     # echo -en "0x00000258" 1>&16
для текущего процесса баща был открыт файл /dev/cpu_dma_latency на запись. и прикреплен к процессу через
дескриптор 16. фишка в том что он будет висеть открытым пока я его сам руками не закрою.
далее я делаю запись в этот файл через подскажу башу что писать надо не в дескриптор 1 как он это обычно
делает по дефолту а в дескриптор 16. после записи файл который скрывается за дескриптором 16 продолжает висеть открытым.
тут еще раз также подчеркну что когда мы работаем с io redirect то между номером дескриптора и значком
редиректа категорически нельзя чтобы были пробелы. тоесть 
         # exec 16> /dev/cpu_dma_latency;   # правильная команда

         # exec 16 > /dev/cpu_dma_latency;  # НЕправильная команда
         сразу вылезет ошибка. потому что баш будет интепретировать эту команду вот так
         # exec 16 1> /dev/cpu_dma_latency;
тоесть он будет пытаться найти бинарник с именем "16", заменить в текущем процессе баш этим бинарником
и заменит файловый дескриптор 1 чтобы он вел не на терминал а на файл /dev/cpu_dma_latency
тоесть это совершенно не то что нам надо. поэтому 
        "16> /dev/cpu_dma_latency" = правильная хрень. обозначает что мы открываем файл /dev/cpu_dma_latency
        на запись и в для процесса прокидываем этот файл как дескриптор номер 16

        "16   > /dev/cpu_dma_latency" = неправильная хрень, если быть более точным она тоже правильная но она делает совершенно другое. она обозначает вот это 
        "16   1> /dev/cpu_dma_latency" 
то есть мы открываем файл /dev/cpu_dma_latency на запись и привязываем его к процессу через дескриптор 1.
и плюс к этому у нас бинарник имеет имя 16. 
поэтому смысл этих двух команд совершенно разный

а вот после значка ">" уже неважно есть пробелы или нет. оно все будет трактоваться одинаково тоесть
    "16> /dev/cpu_dma_latency"
    "16>/dev/cpu_dma_latency"
    "16>        /dev/cpu_dma_latency"
это все одно и тоже.
в целом конечно это дебилизм потому что сегодня я это помню. а завтра уже совершенно нет.


возвращаемся НАКОНЕЦ к нашей исходной задаче
нужно понять как это работает
        # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
кстати сразу замечу что 3 это не stderr (как я иногда глючу так думая), stderr это 2
а 3 это вобще ничего. потому что stdin это 0. stdout это 1 и stderr это 2
немного преобразуем это выражение
        # exec bash 3<> /dev/cpu_dma_latency; echo -en "0x00000258" 1>&3
строго говоря оно немного отличается от оригинала но по конечному результату это одно и тоже
зато все указано в явном виде и поэтому более понятно 
далее эту команду можно эквивалентно переписать как 
        # exec bash 3<> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
во первых я считаю что символ "<>" он излишен потому что мы собираемся писать туда а читать нет.
но в целом не особо важно конечно. но я считаю что вот это более грамотно.
поэтому преобразуем 
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
теперь все понятно. разберем его.
мы открываем файл на чтение /dev/cpu_dma_latency и прикрепляем этот  файл через дескриптор номер 3 у текущего баша. фишка в том что  файл будет висеть постоянно открытым все время. пока мы не закроем его 
специально сами руками. теперь если мы из баща будем писать в дескриптор 3 то оно будет лететь в файл
далее мы через echo посылаем число но не в канал 1 как это баш делает по дефолту а в канал 3.
таким макаром мы записали  число в /dev/cpu_dma_latency
казалось бы мы могли бы сделать проще вот так 
        # echo -en "0x00000258"  /dev/cpu_dma_latency
но это не привело бы нас к тому что нам надо потому что 
этот файл /dev/cpu_dma_latency он хитрый.нам надо чтобы файл оставался все время открытым после 
записи. если мы это делаем сразу через эхо. то как только эхо закончит то файл закроется и ОС перезапишет
значение на дефолтовое. так устроен этот файл. а вот верхний мудежный способ как раз дает то что после записи в эхо файл будет продолжать оставаться открытым и наше новое значение будет сохраняться. 
получается одна маленькая строчка из интернета но чтобы ее понять нужно диссертацию написать.
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
при этом получается пока наш процесс баша будет на компе сущестовать файл будет открыт
и наше записанное значение будет жить.
как только мы текущий баш процесс закроем. файл тоже закроется и значние будет со стороны ос перезаписано
на дефолтовое.
в принципе можно было сделать и вот так
        # bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
без выебонов с exec
у нас просто напросто создасться в системе +1 процесс с баш и только и всего. 
так что если расхлобучить все эти выебоны которые накручены в исходном выражении то вся фишка лишь в том
что для того чтобы открыть файл на постоянной основе надо заюзать вот это выражение
            # bash N> file
и только и всего.
тогда у нас  в системе будет баш процесс  у которого будет постоянно открытый файл "file" на запись
через дескриптор N. вот и все.

далее
теперь моя задача в том чтобы найти все процессы в которых открыты файл дескрипторы
ведущие на файл /dev/cpu_dma_latency
и закрыть все эти файл дескрипторы

# lsof -u root | grep cpu_dma_latency
bash       5106 root   16w      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6454 root    3u      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6828 root    3w      CHR              10,59      0t0        162 /dev/cpu_dma_latency

здесь видно какой процесс имеет этот файл открытым, через какой дескриптор, и  в каком режиме
открыт файл (r,w,rw)

и тут выясняется прикол (из того что я вижу навскидку из интернета) что нет такого красивого 
способа чтобы под рутом запустить команду и заставить позакрываться эти файловые дескрипторы. 
хаха.
тоесть вижу что есть только три неудобных способа
один это подключаемся к процессу через gdb и там запускаем команду на закрытие файла.
второй способ разыскать в граф оболочке наши конкретные терминалы с этими прям башами 
и уже из под них запускать команды на закрытие файлов
а ну и третий самый лоховской способ это поубивать эти процессы и автоматом и файлы закроются

я пойду вторым способом.
он состоит вот в чем.
причем в методичке там запаривают мозг что в завимости в каком режиме был открыть файл 
чтени, запись его нужно гасить по разному на самом деле нихрена. нам совершенно неважно как был открыт файл
    # exec 3> file
    # exec 3< file
    # exec 3<> file
нам на это наплевать 
во всех случаях гасим дескриптор совершенно одинаково
    # exec 3>&-
либо
    # exec 3<&-
а вот вариант 
    # exec 3<>&-
абсолютно нерабочий.
ПРИЧЕМ в данном случае абсолютно нельзя чтобы был пробел между ">" и "&-"
либо между "<" и "&-"
тоесть пробел запрещен не толко слева от знака редиректа но и справа
сразу выдаст ошибку!

поэтому в случае редиректов я бы советовал ни слева от знака редиректа ни справа не оставлять пробелов
чтобы не получать проблем на ровном месте


я в итоге предпочитаю гасить через 
    # exec 3> &-


метод закрытия файла через gdb
# gdb -p $PID
# p close($FD)

далее
интересный пример
    # $ cat /etc/passwd >&-
эквивалент этой команды
    # $ cat /etc/passwd 1>&-
так вот эта команда как работает,
баш создаст новый процесс , со своим бинарником,
и также мы ему указали что в новом процессе нужно уничтожить файл дескриптор 1
далее запустится бинарник cat  а далее прикол в том что по дефолту он пишет в 1  через
write (1, ...)
а 1  у нас нету поэтому на экране вылезет ошибка
    # $ cat /etc/passwd 1>&-
      cat: standard output: Bad file descriptor

можно сделать по другому
    #  tty
     /dev/pts/12
    # cat /etc/passwd 1>&- 1>/dev/pts/12
как ни странно это сработает. 
с новым процессом будет проделано все то что я описал в предыдушем примере
тоесть будет удален дефолтовый дексриптор 1 и будет создан новый который ведет в /dev/pts/12
и все окей. тоесть если указано несколько редиректов в строке то баш и выполняет последовательно 
слева направо хоть миллион таких редиректов 


далее
    $ exec 2>&1
это понятно дескриптор 2 будет иметь тот же бекенд что и дескриптор 1
амперсанд обязателен иначе 2 будет перенаправлен не в дескриптор а обычный файл с именем 1

далее
    $ exec  &>kuku.txt
это перенаправляет 1 и 2  в файл. причем только файл на диске.
перенаправление в файл дескриптор не работает
аналогичная команда
    $ exec 1>kuku.txt 2>kuku.txt
при этом вот это неработает
    $ exec 4<>kuku.txt
    $ exec &>&4
тоесть &> можно перенаправлять только на файлы на диске а не на дескрипторы. тоесть 
вот так только работает
    $ exec &>12.txt

далее. все это время я рассматривал только ">" "<" "<>"
что означало
    > = открыть файл на запист
    < = открыть файл на чтение
    <> = открыть файл на чтение и запись
и  я совсем забыл про ">>" и "<<"
что означает
    >> = открыть файл на запись и плюс флаг APPEND
    << = это совершенно отдельный флаг. я только знаю его вот такое применение
    $ cat <<EOF >1.txt
    12
    12
    EOF
кстати я точно проверил вот так уже неработает
    $ cat <EOF >1.txt
     bash: EOF: No such file or directory

далее
    $ <<vasya
> eee
> bbb
> vasya

тоесть команда просит нас ввести текс. как только мы заканчиваем на контрольном слове vasya
то ввод заканчивается. и никакой файл не создается.
как я понимаю что это аналог команды
    $ :<<vasya
    > eee
    > bbb
    > vasya

тоесть наш текст идет на stdin команды true и в итоге все это просто команды пустышка

далее
    $ >>kuku
эта команда просто напросто создат пустой файл kuku на диске
тоесть аналог этой команды вот такой
    $:>>kuku
или аналог
    $: 1>>kuku

далее
    $ ls >>filename 2>&1
аналог
    $ ls 1>>filename 2>&1
тоесть эта команда она создает процесс с бинарником ls
уничтожает стандартный 1 и создает новый 1 который ведет в файл с именем "filename"
уничтожает стандартный 2 и создает новый который смотрит туда же куда и 1 тоесть в файл "filename"


далее
    $ 2>&1
аналог
    $ :2>&1
все понятно


далее. 
в bash 4 добавили вот такую хрень
|& was added to Bash 4 as an abbreviation for 2>&1
тоесть
    $ vasya |& cat
это аналог
    $ vasya 2>&1 | cat
пример
    $ vasya 2>&1 | xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
    $ vasya  |& xargs -I % echo " ощибка = %"
    ощибка = Command vasya not found, did you mean:
 
тоесть хрень рабтает как. баш создает свой клон в новом процессе.
далее этот чайлд баш ищет бинарник вася, ненаходит его, выводит в 2 сообщение об 
ошибке. а у нас при этом когда процесс создавался то 1 была перенаправлена на 0 процесса xargs
и 2 была направлена тудаже куда 1. получается чайлд баш срет в 2 сообщение об ошибке
и оно автоматом прилетает на 0 xargs. и он то что получил высирает

далее выяснился конкретный пиздец с башем.
мы привыкли что в самоей левой позиции в строке обязательно идет команда 
а все аргументы пайпы итд обязательно идут справа. 
это настолько фундаментальная хрень что о том что это не так даже в голову не приходит
однако это не так. оказывается что можно вот так
    $ cat filename 
    filename
    kuku
    vasya
    $ 2>file2 0<filename cat | xargs echo   
    filename kuku vasya

тоесть левее команды можно абсолютно спокойно насовать редиректы! это пиздец
об этом я нашел случайно в сноске в bash advanced guide
то есть аналогичная в более привычном виде команда выглядит так
    $ cat 0<filename 2>file2 | xargs echo 

можно конечно еще более загадочно и с выебоном написать
    $ < filename cat > out
аналог тоесть более привычный вид
    $ cat 0<filename 1>out

вот еще пример с выебоном
    $ rpm2cpio < filename > $TEMPFILE
аналог
    $ rpm2cpio 0<filename 1>$TEMPFILE

а вот еще приме с приколом
как создать новый дескриптор который ссылается на уже существующий дескриптор
    $ exec 4>&1
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 02:44 0 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 1 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 2 -> /dev/pts/15
    lrwx------ 1 vasya vasya 64 окт  5 02:44 4 -> /dev/pts/15

переводится команда так. в существующем процессе баш нужно открыть создать файловый дескриптор 4
и направить его на файл на который ссылается дескриптор 1. причем этот файл нужно открыть на чтение

еще один пиздец
    $ ls -l  1>/dev/null  16>&-
здесь я вывод от ls просто заткнул тем что перевел в null
и это не главное. главное это "16>&-" 
тоесть оказывается что можно давать команду уничтожить файловый дескриптор который 
и в помине у процесса нихуя нет. и ошибки при этом никакой не выдает. 

вот еще ебанутый пример
    $  <&2  ls  >/dev/null
его аналог
    $ ls  1>/dev/null   0<&2


вот еще ебанутый пример
    $ exec 3<&2
    $ exec 2>&1 >&3 3>&-
первая строка она в текущем процессе баша создает дескриптор 3 который ведет на тот же файл на который
указвыает дескриптор 2. причем этот файл для через дескриптор 3 будет открыт на чтение
тоесть в итоге 3 будет указывать на /dev/pts/19
вторая строка работает так. для текущего процесса баша дескриптор 2 будет уничтожен и создана заново
при этом он будет указыват на тот же файл на который указывает дескриптор 1. так как  1 указывает на /dev/pts/19
то и 2 будет на него указывать. причем в режиме на запись. 
следущим шагом будет уничтожен дескриптор 1 и создан заново при этом он будет указывать на файл на который
указывает дескриптор 3. а 3 указывает на /dev/pts/19 ( на основе информации из команды из первой строки)
поэтому 1 будет указывать на /dev/pts/19 причем в режиме на запись он откроет этот файл
на последнем шаге будет уничтожен дескриптор 3
здесь важно понять что работа с дескрипторами их создание и уничтожение идет слева направо. последовательно 
по шагам. также важно понять что если у нас написано что дескриптор 2 указывает на дескриптор 1 
как вот здесь "2>&1" то это нетак. не дескриптор ссылается на дескриптор а дескриптор ссылает на файл 
на который ссылает другой дескриптор. тоесть как только мы выяснили на какой файл ссылается дескриптор 1
то нам на него насрать. дескриптор 2 будет ссылаться не на дескриптор а на файл который является бекендом 
для дескритора 1. поэтому если потом позже мы удалим дескриптор 1 то проблемы у дескриптора 2 не будет 
никакой так как оне никогда не ссылался на дескритор 1. это тоже важно понять.
а вот на эту тему пример
        $ exec 4<filename 0<&4 1>&0 4>&-
        
        $ ls -1al /proc/16039/fd
        lr-x------ 1 vasya vasya 64 окт  5 03:08 0 -> /home/vasya/filename
        lr-x------ 1 vasya vasya 64 окт  5 03:08 1 -> /home/vasya/filename
        lrwx------ 1 vasya vasya 64 окт  5 03:08 2 -> /dev/pts/20


тоесть как это работает. для текущего процесса у нас открывается файл "filename" на чтение 
и привыязывается к процессу через дескриптор 4
на втором шаге у нас уничтожается прежний 0 и создается новый и он открывает на чтение тот файл на который ссы
лается 4 тоесть filename
на третьем шаге у нас уничожается 1  и создается заново и он открывает на запись файл на который ссылается 0
тоесть filename 
на последнем этапе у нас уничтожается дескриптор 4
от того что мы уничтожили дескриптор 4 это не означает что это как то повлияет на 0. потому что 0 указывает
не на 4 а на файл на который указывал 4 тоесть на filename
пиздец

далее. шок
внещняя по отношению к башу команда cat
она почемуто читает данные не из 0 а из 3 !!!
показываю:
    $ cat /dev/urandom > /dev/null

    $ ls -1al /proc/21031/fd
    lrwx------ 1 vasya vasya 64 окт  5 10:15 0 -> /dev/pts/16
    l-wx------ 1 vasya vasya 64 окт  5 10:15 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 10:15 2 -> /dev/pts/16
    lr-x------ 1 vasya vasya 64 окт  5 10:15 3 -> /dev/urandom

хотя в приниципе нормально. для cat штука "/dev/urandom" является параметром и бинарник cat когда он запустился
анализирует с каким параметрами командной строки он был запущен и волен открывать файл под любым дескриптором.
в том числе и под дескриптором 3.
скорее я капитально ошибся думая что параметр командной строки почемуто должен быть открыть катом через 
дескриптор 0. это же чушь. через 0 cat принимает данные из терминала. а через 3 он принимает данные из файла.
все конечно же должно быть так.

далее еще прикол про cat
    $ cat 1.txt 2.txt
если так запустить то cat вначале откроет 1.txt полностью его прочитает и выдаст в 1, закроет его,
потом только откроет 2.txt 
а не так как я думал что он одноврменно откроет два файла. нет так он не делает.

далее еще прикол
    $ <<EOF
    > aa
    > bb
    > EOF
насколько я понимаю эквивалент команды это 
    $ :<<EOF
либо
    $ true<<EOF
тоесть невидимая команда это ":" или "true" что одно и тоже.
и  в нее скармливается текст из терминала
как работает "<<EOF" насколько я понимаю когда мы тыкаем enter то текущий баш он видит эту хрень 
и делает вывод что мы хотим написать в терминале какойто текст, он дает нам написать в терминале наш текст,
засасывает внутрь себя И ТОЛЬКО ПОТОМ он клонирует себя в новый процесс и как я понимаю он где то сохраняет
засосанный текст из терминала и после того как склонировал себя то он наверное из родительского процесса
видимо через пайп скармливает засосанный текст в stdin чайлд процесса.
тоесть если у нас есть вот такая команда
    $ команда <<EOF 
то ее эквивалент
    $ echo -en "aaasdas\n asdasdsdasd\n" | команда 
или еше пример
    $ cat<<EOF > 1.txt
ее аналог в более понятной форме
    $ echo -en "aaaa\n bbb\n" | cat > 1.txt 
этим описанием я хочу подчеркнуть что "<<" не имеет никакого отношения к cat! это фича либо самого терминала
либо баша скорей всего баша. поэтому "<<" можно прихуяривать с любой программой. самое главное что программа должна ожидать получить какието данные из stdin. пример
    $ xargs echo <<EOF
    > "aaa"
    > "bbb"
    > EOF
    aaa bbb
тоесть эта команда эквивалентна
    $ echo "aaa bbb" | xargs echo
    aaa bbb

работает это так. мы тыкаем Enter. баш начинает анализировать строку  "xargs echo <<EOF"
видит конструкцию "<<EOF" и понимает что пока что делать ничего нельзя. прежде всего нужно считать 
некий текст из терминала. поэтому баш останавливается и ждет чтобы мы набили в терминале текст.
мы его набивает. баш его где то запомиает в своих кишках. потом он клонирует себя. запускает в чайлде
xargs и видимо через пайп передает из родительского процесса из своих кишок запомненный текст 
на stdin дочернего процесса.

далее я возвращаюсь к cat
у него есть такой прикол
    $ cat 1.txt - 2.txt
эта хуйня должна работать так вначале кат открывает файл 1.txt полностью его читает и выводит  на терминал.
потом кат ждет наших данных прям с терминала. он их считывает и выводит на экран. потом мы както должны обьяснить кату что мы больше не хотим вводит из терминала. и он тогда должен открыть 2.txt и его прочитать
и вывести на экран. на данный момент прблема в том что я не понимаю как этому кату обьяснить тот момент
когда я хочу закончить ввод из терминала
значит я не знаю как из терминала обьяснить кату что мы закончили ввод тоесть
    $ cat -
я не понимаю как закончить ввод с терминала
зато вот можно сделать такой прикол
вот есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777

тогда можно сделать вот такой фокус
   $ echo "111" | cat 6.txt - 7.txt
    666
    111
    777
круто??!?!?!?!?

во! я узнал как в терминале что надо нажать чтобы обьяснит терминалу и cat что я закончил
вводить текст и мы достигли "конец файла EOF" . оказывается это комбинация Ctrl+D
показываю имеем два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
тогда пуляем такую команду
    $ cat 6.txt - 7.txt 
    666  <=== это кат вывел содержимое 6.txt
    aa   <=== это мы ввели руками в терминале
    aa   <=== это кат вывел то что мы ввели
    bb   <=== это мы ввели руками в терминале 
    bb   <=== это кат вывел то что мы ввели руками, и тут я нажал Ctrl+D
    777  <=== это кат вывел содержимое файла 7.txt
круто!!!!!

далее. итак я выяснил что 
    $ cat 1.txt
приводит  к тому что кат откроет файл 1.txt через файловый дескриптор номер 3 
еще раз показываю на примере
    $ cat /dev/urandom 1>/dev/null
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
четко видно что файл открыт через дескриптор номер 3
а если мы хотим чтобы cat начал читать файл через дескриптор 0 то это запускается
совсем по другому
    $ cat /dev/urandom | cat 1>/dev/null
вот как выглядит открытые файлы у второго кат
    $ ls -1al /proc/22921/fd
    lr-x------ 1 vasya vasya 64 окт  5 11:18 0 -> 'pipe:[2312995]'
    l-wx------ 1 vasya vasya 64 окт  5 11:18 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:18 2 -> /dev/pts/18
в этом случае поток засасывается из 0 который ведет в пайп. но дело не в пайпе. а то что
в таком случае поток забирается из 0
возвращаюсь к случаю когда кат читает из файла который мы указали в командной строке
    $ cat /dev/urandom
мы имеем вот такой список открытых дескрипторов
    $ ls -1al /proc/22836/fd
    lrwx------ 1 vasya vasya 64 окт  5 11:16 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 11:16 1 -> /dev/null
    lrwx------ 1 vasya vasya 64 окт  5 11:16 2 -> /dev/pts/17
    lr-x------ 1 vasya vasya 64 окт  5 11:16 3 -> /dev/urandom
так вот понятно что у нас на экране будут лететь символы
можно даже вот такой пример сделать чтобы на экране были только буквы 
    $  cat /dev/urandom | od -t x1
так вот возникает вопрос а что если мы вэто время будем конпки на терминале тыкать будет ли
их параллельно пихать на экран cat или нет. отвечаю конечно нет! 
как я уже сказал раз мы указали cat файл в командной строке как аргумент то он читает данные
только из дескриптора 3. а планов читать в это время  у него из stdin из 0  у него нет! поэтому
тыкать в терминале кнопки в это время нет никакого эффекта!

далее еще полезный момент
    $ echo 113 | cat
    113
    $ echo 113 | cat -
    113
результат один и тот же. однако во втором случае мы в более явной 
форме обьясняем кату что мы хотим чтобы он данные принимал из 0






далее я перехожу к мудежной но знаковой важной теме 
называется она 
>>> bash process substitution <<<
выглядит это так
    $ команда1 >(команда2)
например 
    $  cat - >(sleep  160)
и работает это так
создается  pipe.
и тут важно скзаать что книжка "bash advanced scripting" на которую я опираюсь нередко пишет 
полную хуйню. так и в этот раз. книжка пишет что создается named pipe. на самом деле нихуя. 
создается anonymous pipe. тут я делаю отсылку на pipe.txt чтобы прочитать про то что такое пайпы.
итак создается неименованный пайп а именно анонимный! выглядит он так
        'pipe:[2498298]'
где что и как щас станет понятно
    $ ls -1al /proc/5013/fd
        lrwx------ 1 vasya vasya 64 окт  6 10:41 0 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22
        l-wx------ 1 vasya vasya 64 окт  6 10:41 63 -> 'pipe:[2498298]'  <====
    $ ls -1al /proc/5014/fd
        lr-x------ 1 vasya vasya 64 окт  6 10:41 0 -> 'pipe:[2498298]'   <====
        lrwx------ 1 vasya vasya 64 окт  6 10:41 1 -> /dev/pts/22
        lrwx------ 1 vasya vasya 64 окт  6 10:41 2 -> /dev/pts/22

так вот ядро создало анонимный пайп где то там в своих кишках памяти 'pipe:[2498298]'
далее запускается команда2 и ее stdin конец присоединяется к анонимному пайпу 'pipe:[2498298]'

далее запускается команда1 и ей в качестве аргумента командной строки передается адрес файла /dev/fd/63
то бишь /proc/pid1/fd/63
показываю:
    $ ps aux | grep cat
     vasya     5013  0.0  0.0  14720   744 pts/22   S+   10:40   0:00 cat - /dev/fd/63

где /dev/fd/63 это симлинк на /proc/self/fd/63 тоесть то бишь /proc/pid1/fd/63
нихуя себе! да?
тоесть команда 1 была по факту запущена в виде
    $ cat - /dev/fd/63
и соотвественно программа cat обрабатвыает этот аргумент строки 
и открывает этот файл под каким то дескриптором ну точнее как видно из практики под дескриптором 63
и таким макаром у первой программы мы имеем
        63 -> 'pipe:[2498298]'
у второй программы мы имеем
        0 -> 'pipe:[2498298]'
если первая программа захочет и будет писать в дескриптор 63 то это летит в пайп 
и если вторая программа будет читать если захочет из дескриптора 0 то она будет читать из пайпа.
таким макаром пайп обеспечивает связь между двумя процессами.
во втором процессе пайп присоединяется к 0
а в первом процессе имя файла пайпа (/proc/pid1/fd/63) передается программе как аргумент в строке.
соотвесвтенно если первая программа такова что она не собирается писать данные в файл который указан  в ее 
строке то второй програме нихрена и не прилетит.  тоесть bash process substituition это более специфический
процесс связи между программами.  классический анонимный пайп вида $ echo | cat более бронебойный способ 
потому что он вставляет пайп на stdout первого процесса и сует на stdin второго процесса.
если первый процесс чтото высирает на stdout а второй процесс чтото желает читать из своего stdin (что вобще то говоря не факт) то связь между процессами обеспечена.
в случае же bash process subsitution связь заработает только если первый процесс умеет писать в файл имя которого ему передали как аргумент в строке. вот что надо подметить.! но еще раз подчеркну что в bash process
substition используется анонимный пайп. а не именнованный как это суки эти пищут в bash advanced guide книжке


еще пример
    $ echo >(true)
    /dev/fd/63
почему так. потому что в конечно итоге будет запущена команда
    $ echo /dev/fd/63
обьясню почему. мы вбили команду в баш. баш анализирует строку и видит в ней кусок ">(true)"
для баша это означает что нужно этот кусок заменить на имя файла. что за файл?  файл в папке 
/dev/fd/63. по факту это симлинк на файл /proc/self/fd/63 то бищь /proc/pid1/fd/63
почему именно 63? я так думаю это какойто хардкод число в ядре с которого он создает эту хрень.
и между прочим это тоже симлинк и ведет он на анонимный пайп 
        /proc/pid1/fd/63 --> 'pipe:[2498298]'
когда пайп создан и когда ссылка на него создана то баш подставляет в оригинальную команду и запускает 
ее 
     $ echo /dev/fd/63
поэтму мы на экране видим 
    /dev/fd/63
помимо этого баш создает новый процесс и запукает там вторую команду "true"
и к ее stdin присоединяет этот же анонимный пайп тоесть
          /proc/pid2/fd/0 --> 'pipe:[2498298]'
конкретно в даннном случае вся команда целиком неимеет никакого практического смысла
потому что echo абсолютно не собирается писать в файл /dev/fd/63 по своей природе
а команда true не собирается ничего читать со своего stdin 
поэтому это пример чисто работающий но бесполезный     потому что данные через пайп
от первой команды ко второй не передаются


а вот пример где данные уже передаются
    $ cp /dev/urandom >(pv 1>/dev/null)
     147MiB 0:00:06 [21,0MiB/s] [                   <=>                           <=>    

работает это так что данные из /dev/urandom пихаются в пайп
а из него их читает pv и рисует картинку

более подробно  как это работает 
работает также как в прошлом примере
вот мы вбили команду
    $ cp /dev/urandom >(pv 1>/dev/null)
нажали Enter
бащ анализирует эту строку.  и видит комбинацию ">(pv 1>/dev/null)"
тогда баш понимает что все не так просто и создает аононимный  пайп где то там  в памяти вот 
такую хрень 'pipe:[2498298]'
далее бащ создает новый процесс и в нем запускает "pv". когда  баш создает этот процесс через сисколл
то просит у ядра чтобы оно присоединило к stdin дочернего процесса наш пайп
и выглядит это так
        /proc/pid2/fd/0 --->  'pipe:[2498298]'
далее баш берет оригинальную команду и меняет ее из вот такой
        $ cp /dev/urandom >(pv 1>/dev/null)
в такую
        $ cp /dev/urandom /dev/fd/63
где /dev/fd/63 в конечном итоге ведет в тот же самый пайп 'pipe:[2498298]' тоесть
        /dev/fd/63 --> /proc/self/fd/63 ---> 'pipe:[2498298]'

соотвевственно команде cp похеру что там на том конце у /dev/fd/63
она просто копирует данные из /dev/urandom в /dev/fd/63
таким макаром данные улетают в пайп.
и таким же макаром вторая команда читает свой stdin и получает данные из пайпа.

можно привести пример когда работает наоборот
    $ cp <(cat /dev/urandom) /dev/null
работает это так что () кидает их в свой stdout который направлен в пайп
а команда cp будет запущена в виде
    $ cp /dev/fd/62 /dev/null
где /dev/fd/63 тоже смотрит в пайп
таким макаром данные из stdout () поступают в пайп оттуда в /dev/fd/62 а оттуда в cp 

да уж..


а вот еще пример
    $  cp /dev/urandom >(echo "печать из субшелла"; pv 1>/dev/null)
    печать из субшелла
    66,2MiB 0:00:01 [37,1MiB/s] [     <=>           ]
получается вот что. вначале то что вылетает из cp пристыковывается через пайп к stdin команды echo.
но ей посрать на то что поступает к ней из stdin поэтому она просто печатает текст на экране и заканчивает
свою работу. данные при этом в пайпе как лежали так и лежат ( деньги в копилке так и лежат)
тогда далее запускается pv и уже к ней пристыковывается  пайп на ее stdin 
и так как pv как раз таки и и ждет поступления данных из stdin то pv начинает выкачивать данные из пайпа

тоесть фишка в том что у нас наш пайп был подключен и к одной команде и другой. а с классическим анонимным пайпом так хрен сделаешь наверно...


а вот еще очень важный пример
    $ echo "11" 1>(echo "первый привет из субшелл"; cat)
    11 1/dev/fd/63

что я хотел в этом примере добиться. я хотел чтобы вывод эха был перенаправлен в ()
но это не получилось хотя я якобы настроил редирект для 1. ошибка в том что баш заменил
конструкцию ">(echo "первый привет из субшелл"; cat)" на "/dev/fd/63" в итоге echo был запущен
буквально вот так
    $ echo "11" 1/dev/fd/63
поэтому то мы на экране и увидели вот эту хрен незапланированную 
    11 1/dev/fd/63
а чтобы все заработало как надо - надо вот так
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat)
    первый привет из субшелл
    11

значит в нем редирект настроен как "1>" а файл в который мы редиректим указан как ">(echo "первый привет из субшелл"; cat)"
в итоге и получается вот такая удивительная конструкция! c двумя галками через пробел "> >"
тоесть пример у нас расшифрорвывается так:
напечатай 11 но при этом stdout мы перенаправляем в именованный пайп который ведет в субшелл
далее. вначале именнованный пайп с 11 внутри прилепляется к stdin команды 
    echo "первый привет из субшелл";
но ей похеру то что у нее сидит на ее stdin
поэтому она просто на экране печатает приветствие и заканчиывает работу
тогда запускается команда cat у которой именованный пайп подключен к ее stdin
и вот тут наконец 11 из верхней эхо поступает на stdin команды кат. и она его печатает. 
в итоге мы получаем на экране
    первый привет из субшелл
    11


возникает вопрос а что будет у такой команды?
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
возникает вопрос чтото из верхнего эхо доберется до второго cat?
ответ конечно нет. потому что пайп уже весь опустошен на первом cat
    $ echo "11" 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    11
    второй  привет из субшелл



а вот еще очень интересный пример
вот у нас есть два файла
    $ cat 6.txt 
    666
    $ cat 7.txt 
    777
запускаем такую команду 
    $ cat 6.txt 7.txt  1> >(echo "первый привет из субшелл"; cat -; echo "второй  привет из субшелл"; cat -;)
    первый привет из субшелл
    666
    777
    второй  привет из субшелл


вопрос был вот в чем. когда у нас верхний cat закончит передавать первый файл и первый cat в субщелле закончит 
его печать то закончит ли cat в субшелле свою работу и передаст ли второй echo в субщелле управление
или нет. практика нам показала что первый cat в субшелле посрал на то что первый файл закончился 
и работал до упора напечатал оба файла и только потом закончил работу и передал управление дальше.
поэтому второй cat оказался полностью пустой. к нему по пайпу ничего не прилетело.



вот еще пример на эту тему
вот у нас есть файл 
    $ cat 6.txt 
    666
запускаю такую команду
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
в ней я говорю что  я буду пихать в головной cat вначале данные сам руками из терминала.
а потом как закончу данные в cat еще поступят из файла 6.txt
мой вопрос до второго cat в субшелл чтото долетит или нет?
    $ cat - 6.txt 1> >(echo "первый привет из субшелл"; cat; echo "второй  привет из субшелл"; cat;)
    первый привет из субшелл
    вася  <=== это  я ввел руками в терминале
    вася
    петя  <=== это  я ввел руками в терминале
    петя
          <== тут я нажал Ctrl+D (EOF) и cat прекратил читать из терминала и начать читать файл 6.txt
    666   <== содержимое файла 6.txt
    второй  привет из субшелл


так вот видно то что первый cat в субшелле сидел и ждал данные до упора. она 
вначале дождался данных из того что я втермиале печатал. а потом он еще напечатал то что в 6.txt
и только после этого он закончил свою работу. и поэтом до второго cat в субшелле уже ничего не долетело
сверху. вот это и я хотел исследовать



еще малек пример про редирекшн.
пример
    $ echo -e 1>15.txt
я хотел изначально записать "1" в 15.txt
а как очевидно понятно я ошибся. и по факту обозначение "1>15.txt"
привело к тому что файловый дескриптор 1 стал указывать на 15.txt 
а не то что символ 1 был напечатан на экран. 
надо было вот так делать чтобы 1 на экране напечатался
    $ echo -e "1"   1>15.txt
вот как было правильно




теперь НАКОНЕЦ я возвращаюсь к тому примеру с которого начал изучение редиректов 
        $ exec &> >(tee -a ./1.txt)
теперь наконец  эта тарабарщина понятна!
"&>" дает то что stdin и stderr оба будут перенаправлены в некий файл. а что за файл?
а это как раз указано дальше , файл такой что он указывает на анонимный пайп из "bash process substitution" 
обычно это файл 
        /dev/fd/63 ---> /proc/self/fd/63 ---> 'pipe:[2498298]'

баш начнет анализировать всю эту команду после нажатия enter  и попросит ядро создать пайп 'pipe:[2498298]' 
где то в памяти ядра, далее баш 
произведет в исходной строке замену 
было
    $ exec &> >(tee -a ./1.txt)
стало
    $ exec &> /dev/fd/63

в доказательство этого я выполнил strace чтобы это поймать
    # strace -p 7859 -f  -s80  -e openat
    [pid  7859] openat(AT_FDCWD, "/dev/fd/63", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
причем этот файл присутствует именно в openat а не в execve
удивительно

далее баш выполнит команду exec и тогда у текущего баша поменяется два дескриптора. 1 и 2 (stdout и stderr)
раньше скорей всего они смотрели на файлы терминало /dev/pts/22
а станут смотреть на пайп
        /proc/bash_pid/fd/1 ---> 'pipe:[2498298]'
        /proc/bash_pid/fd/2 ---> 'pipe:[2498298]'

далее баш запустит еще один процесс и там запустит tee
к stdin дескриптору этого процесса он прилепит тот же пайп 
        /proc/tee_pid/fd/0 ---> 'pipe:[2498298]'

в итоге все что баш будет бросать на stdout\stderr будет направлено в пайп
и будет считано из пайпа командой tee и отрисовано на окне терминала и продублировано  в физ файл на физ диске.

хотелось  почеркнуть что отрисовка вывода в терминале будет идти не засчет головного баша
а за счет tee в субшелл.
посмотрим теперь на практике
    $ exec &> >(tee -a 1.txt)
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  5 13:11 0 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 1 -> pipe:[2331898]   <====
    l-wx------ 1 vasya vasya 64 окт  5 13:11 2 -> pipe:[2331898]   <====

    $ ps aux  | grep tee
    vasya    26155  0.0  0.0  14588   792 pts/17   S    13:10   0:00 tee 1.txt
    $ ls -1al /proc/26155/fd
    lr-x------ 1 vasya vasya 64 окт  5 13:11 0 -> pipe:[2331898]   <====
    lrwx------ 1 vasya vasya 64 окт  5 13:11 1 -> /dev/pts/17
    lrwx------ 1 vasya vasya 64 окт  5 13:11 2 -> /dev/pts/17
    l-wx------ 1 vasya vasya 64 окт  5 13:11 4 -> /home/vasya/temp/1.txt

из чего действительно видно что в головноv баше stdin и stdout указывают на пайп [2331898]
а в процессе "tee" ее stdin смотрит в тотже самый пайп [2331898]
тоесть теория совпала с практикой


далее я покажу что будет напечатано в 1.txt
если в исходной терминале будет выглядеть вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

то в 1.txt будет вот так
[vasya@lenovo temp]$ # васяяяяяяяяя
[vasya@lenovo temp]$ # петя
[vasya@lenovo temp]$ 

что интересно новые буквы будут появляться в файле не тогда когда мы воригинальном терминале 
нажали enter а уже тогда когда мы в терминале нажали просто букву!
что еще более поразительно. если мы сотрем букву на оригинальном терминале то эта буква также сотрется 
и в файлле ! amazing!
вот это тема.... охренеть


возникает удивительный вопрос а нахуй этот механизм нужен на практике? покажите
пример практический когда это может пригодится?

еще пример
еще:
    $ echo 1 >(cat)
        1 /dev/fd/63
ну понятно. строка 
    $ echo 1 >(cat)
будет заменена на
    $ echo 1 /dev/fd/63
отсюда результат


далее
    >&, &>
есть ли разница.
обычно нет. но лучше юзать &>
по смыслу эта команда перенаправляет sterr и stdin в один файл
который обязательно нужно укзаать после тоесть
    $ echo "aaa" &> /tmp/1.txt
эквиваелент
    $ echo "aaa" 1>/tmp/1.txt 2>&1
либо
    $ echo "aaa" 1>/tmp/1.txt 2>/tmp/1.txt


далее
    >|
тут интересно. баш имеет ряд крутилок настроек.
настроки подкручитваются через баш билтин set
    $ set --help
в частности вот так крутятся настройки
    $ set +o pipefail -o noclobber
посмотреть текущие настройки вот так
    $ echo $-
хотя там не информативно. а более информативно вот так

$ set -o
set -o
+ set -o
allexport       off
braceexpand     on
emacs           on
errexit         off
errtrace        off
functrace       off
hashall         on
histexpand      on
history         on
ignoreeof       off
interactive-comments    on
keyword         off
monitor         on
noclobber       off
noexec          off
noglob          off
nolog           off
notify          off
nounset         off
onecmd          off
physical        off
pipefail        off
posix           off
privileged      off
verbose         on
vi              off
xtrace          on

видно опять же как я сказал что noclobber выключена.
если она включена то ">" не даст перезаписать существующий файл. выдаст ошибку.
у нас опция выключена поэтому ">" перезатирает файл без всяких ошибок.
так вот если все таки noclobber активирована то ">|" позволяет игнорировать эту настройку.  
в общем в итоге ">|" малополезная хрень.
я еще ни разу не встречал чтобы noclobber был хоть где то активирован.

далее пример. 
я нашел более менее пример который уже как то типа может быть полезен на практике.
есть два файла
    # cat 7.txt 
        a
        b
        c
    # cat 6.txt 
        1
        2
        3

есть интересная команда "paste" она читает из нескольких файлов по одной строке
и печатает это на экране через TAB
    # paste 6.txt 7.txt 
        1   a
        2   b
        3   c
так вот как это же можно сделать через bash process substitution 
    # paste <(cat 6.txt) <(cat  7.txt)
        1   a
        2   b
        3   c
ну когда мы читаем из готовых файлов то пример мало полезен. а вот когда 
нам надо прочитать из stdout нескольких процессов и все это построчно соединить в таблицу
на экране то bash process substitution уже становить реально полезен
    # paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp)
        INT3400 Thermal 20000
        pch_cannonlake  40000
        B0D4    0
        x86_pkg_temp    42000


как написано в мануле утилита "paste" позволяет соединить строки нескольких файлов вместе.
тоесть еще пример
    $ cat 1.txt 
        aaa
        bbb
        ccc 
$ cat 2.txt 
        5
        6
        7 
$ paste 1.txt  2.txt 
        aaa 5
        bbb 6
        ccc 7 

разделение идет через TAB


далее я опишу утилиту colrm
это частично идиотская утилита потому что ее man нагло врет
    $ colrm start stop
утилита удаляет из текста колонки с номерами  
    start << колонка << stop
причем разделителя колонки никакого нет. это ни пробел  ни TAB
это всегда банально номер символ в строке. показываю
в этом примере будет удалены символы 3 и 4
их позиция в строке и является так называемой "колонкой"
    $ echo -e "123456789" | colrm 3 4
    1256789
если указать только стартовую колоноку то он удаляет вот такие колонки
    start << колонка << EOL
пример
    $ echo -e "123456789" | colrm 3
    12
в целом убогая утилита



далее я опишу утилиту column
она позволяет назначить разделитель и потом отформатировать текст по колонкам.
но по мне утилита корявая. она порой работает хер знает как.
итак имеем файл
    $ echo -e "1+2+3+4+5\n6+7+8+9+10"
    1+2+3+4+5
    6+7+8+9+10
воспользуемся недавно узнанной штукой "bash process substitution"
    $ column -t -s "+" <(echo -e "1+2+3+4+5\n6+7+8+9+10")
    1  2  3  4  5
    6  7  8  9  10
так вот утилита column 
ее ключ -е без него вобще ничего не работает. считай что он значит что надо отформатировать текст
ключ -s "+" означает что разделитель между колонками "+"

далее важно дополнение. выравнивание в колонке идет всегда по левому краю.
пример про это
    $ echo -e "111111111+2+3+4+5\n6+7+8+9+10"
    111111111+2+3+4+5
    6+7+8+9+10

    $ column -t -s "+" <(echo -e "111111111+2+3+4+5\n6+7+8+9+10")
    111111111  2  3  4  5
    6          7  8  9  10

порой эта прога как уже сказал работает непонятно как . но если ее применить несколько раз
то вроде можно получить вменяемый результат
практический пример 
имеем вот такой вывод.
почему то cpupower хреновато форматирует свой текст
можно заметить что "Freq" и "POLL" поплыли
    $ sudo cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6   || C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,02|  1,37| 59,17|  0,00||  0,88| 99,12|   632||  0,00|  0,00|  0,00|  0,02|  0,47|  0,00|  3,36|  0,16| 95,13
   4|  0,02|  1,37| 59,17|  0,00||  2,33| 97,67|   577||  0,00|  0,00|  0,03|  0,01|  1,36|  0,00| 14,02|  0,08| 82,29
   1|  0,13|  0,42| 59,17|  0,00||  1,66| 98,34|   598||  0,00|  0,74|  0,18|  0,09|  0,23|  0,00|  7,52|  0,03| 89,59
   5|  0,13|  0,42| 59,17|  0,00||  1,06| 98,94|   600||  0,00|  1,82|  0,00|  0,06|  0,26|  0,00| 10,37|  1,03| 85,34
   2|  0,00|  0,27| 59,17|  0,00||  1,70| 98,30|   657||  0,00|  0,00|  0,01|  0,02|  0,02|  0,00|  4,72|  0,00| 93,46
   6|  0,00|  0,27| 59,17|  0,00||  0,32| 99,68|   623||  0,00|  0,00|  0,02|  0,00|  0,20|  0,00|  4,52|  0,00| 94,87
   3|  0,09|  0,98| 59,17|  0,00||  0,87| 99,13|   609||  0,00|  0,94|  0,73|  0,03|  0,48|  0,00|  7,93|  0,00| 89,05
   7|  0,09|  0,98| 59,17|  0,00||  1,62| 98,38|   568||  0,01|  0,66|  0,04|  0,10|  0,76|  0,00| 14,12|  0,00| 82,69


отформатируем этот текст
    $ sudo cpupower monitor | column -t -s "|" | column -t -s " " | grep -v Nehalem
CPU      C3     C6          PC3    PC6   C0    Cx     Freq  POLL  C1    C1E   C3    C6    C7s   C8     C9    C10
0        0,02   1,22        52,58  0,00  1,20  98,80  645   0,00  1,92  0,17  0,02  0,23  0,00  9,80   1,11  85,57
4        0,02   1,22        52,58  0,00  1,84  98,16  623   0,00  0,00  0,24  0,04  1,83  0,54  11,55  0,38  83,64
1        0,08   0,40        52,58  0,00  1,76  98,24  631   0,01  0,00  0,02  0,09  0,48  0,00  8,84   0,00  88,81
5        0,08   0,40        52,58  0,00  3,34  96,66  674   0,00  1,05  1,26  0,00  0,16  0,40  6,78   0,07  86,95
2        0,06   2,54        52,58  0,00  2,61  97,39  666   0,00  0,11  0,85  0,01  0,72  0,00  8,97   0,07  86,65
6        0,06   2,54        52,58  0,00  2,02  97,98  646   0,00  0,00  0,03  0,10  3,00  0,00  10,23  0,06  84,53
3        0,03   0,71        52,58  0,00  5,44  94,56  654   0,00  0,00  0,00  0,05  0,68  0,00  15,06  0,09  78,67
7        0,03   0,71        52,58  0,00  0,75  99,25  635   0,00  0,00  0,01  0,01  0,09  0,00  6,79   0,00  92,28

в плане ключа -s который указывает разделитель колонок
так вот возникает вопрос как указать в качестве разделителя например знак табуляции
в мануале об этом нет ни слова. так вот ответ вот как
    -s $'\t'
а вот пример
    $ echo -e "1\t2\t3\t"
    1   2   3   

    $ echo -e "1\t2\t3\t" | column -t -s $'\t'
    1  2  3

утилита column работает так что она удаляет из строк сам знак разделителя
и заменяет его на пробел. или пробелы. по своему усмотрению. поэтому в примере выше она убрала
табы и вставила пробел как разделитель заместо

а теперь более менее практический пример где эта утилита может пригодится реально
исходный текст
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с"
    'температура датчика'   'скорость'  'высота'
    30°C    12 м\с

прикол в том что между колонками TAB а внутри колонки у нас пробелы могут быть.
а мы хотим выровнять.
    $ echo -e "'температура датчика'\t'скорость'\t'высота'\n30°C\t12 м\с" |  column -t -s $'\t'
    'температура датчика'  'скорость'  'высота'
    30°C                   12 м\с



а вот пример ради которого я долбался писал выше описание для 
утилит paste, bash process substitution, sed 
( кстати о том как работает sed смотри в sed-awk-cut-tr.txt )
итак встретился в инете такой пример.
в нем column он заменяет разделитель TAB на пробел,
а sed берет три последние символа, запоминает третий слева символ в группу 1,
и вместо трех последних символов вставляет точку плюс символ который сохранен в группе 1 и 
далее градус с цельсием. например в конце было 20000, значит три берем три последних символа это "000"
запоминаем третий слева в группу 1 это "0" и заменяем в итоге на ".0°C"
    $ paste <(cat /sys/class/thermal/thermal_zone*/type) <(cat /sys/class/thermal/thermal_zone*/temp) | column -s $'\t' -t  | sed 's/\(.\)..$/.\1°C/'

    INT3400 Thermal  20.0°C
    pch_cannonlake   37.0°C
    x86_pkg_temp     39.0°C


далее еще пример про редирект
    $ echo "456" | ssh thinkpad cat - 1>~/7.txt
прикол в том что редирект будет идти не в файл на удаленном компе. нееееееет.
файл будет записан на этом компе!
чтобы записать файл на удаленный комп нужно
    $ echo "456" | ssh thinkpad cp /dev/stdin ~/7.txt


| <<<
пока что детално неразбирался но 

    $ bc <<< 2*3
    6
тоесть это некий аналог 
    $ echo -n "2*3" | bc

    
    
| ${#parameter}
| ${#var}

вычисляет длинну переменной
    $ a="123"
    $ echo ${#a}
    3

если у нас скрипт то 
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"
    $ ./03.bash 1
    первый параметр = 1, длинна первого параметра = 1
    $ ./03.bash 12
    первый параметр = 12, длинна первого параметра = 2
    $ ./03.bash 
    первый параметр = , длинна первого параметра = 0

в данном случае #1 это первый аргумент передаваемый в скрипт


еще один пример
    $ cat 03.bash 
    #!/bin/bash
    echo "первый параметр = $1, длинна первого параметра = ${#1}"

    for ((i=0; i<${#1}; i++))
    do
        echo "i = $i"
    done


    $ ./03.bash 5
    первый параметр = 5, длинна первого параметра = 1
    i = 0

поскольку длинна первого аргумента скрипта "5" равна единице то цикл for имеет параметры
i=0, i<1, i++
поэтому он отрабатывает один раз
еще интересно то что {#1} означает посчитать длинну переменной $1





| ${parameter:offset:length}
| ${:::}

позволяет печатать не всю переменную а ее часть.
причем важно offset указывает начало откуда печатать
а length указывает сколько символов после оффсета напечатать
следущий пример печатает начиная с оффсет и до конца переменной
    $ a="123"
    $ echo ${#a}   # напоминаю что ${#a} считает длинну переменной 
    3
    $ echo ${a:0:${#a}}
    123
    $ echo ${a:1:${#a}}
    23
    $ echo ${a:2:${#a}}
    3
    $ echo ${a:3:${#a}}
очевидно что нумерация символов в переменной начинается с "0"

следущий пример печатает начиная с оффсет всего один символ
    $ a="123"
    $ echo "${a:0:1}"
    1
    $ echo "${a:1:1}"
    2
    $ echo "${a:2:1}"
    3



    
| ${#}
| ${:::}

вот еще интерснейший пример

    $ cat md.bash 
    #!/bin/bash

    for((i=0; i<${#1}; i++))
    do
        echo "i=$i"
        echo "${1:$i:1}"
        echo "---"
    done

    $ ./md.bash 34
    i=0
    3
    ---
    i=1
    4
    ---

значит вот эта хует ${#1} означает посчитай длинну переменной $1
где $1 это первый аргумент командной строки который был передан скрипту при запуске

вот эта хуета "${1:$i:1}" означает возмьми переменную $1 и вырежь из нее символы начиная с позиции $i
в количестве 1 штука

получается мы передаем в скрипт 34 который будет являться $1
тогда ${#1} = 2
и цикл будет работать для i=0,1

для i=0
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 0 в количестве 1 штука. тоесть это будет 3

для i=1
${1:$i:1} => $1=34 вырежь из него символы начиная с офсета 1 в количестве 1 штука. тоесть это будет 3
4

что мы и видим на экране

охуеть


| printf
это bash builtin.

при этом эти суки в man bash нихуя про него нормально не написали ублюдки.

формат этой хуеты такой

printf "format" arg1 arg2 arg3 ...

тоесть вначале задается формат печати. а потом указываются аргументы(переменные) для печати


простейщий пример
    $ printf "asd\n"
    asd

в этом примере у нас указан только формат. аргументов нихуя нет.
asd это просто литеры. а "\n" это спецсимвол переноса строки. 
все супер просто.

теперь о некоторых других спецсимволах внутри формата

Format Specifier	Description
%c	Treat the arguments as a single character.
%d	Treat the input as a decimal (integer) number (base 10).
%e	Treats the input as an exponential floating-point number.
%f	Treat the input as a floating-point number.
%i	Treat the input as an integer number (base 10).
%o	Treats the input as an octal number (base 8).
%s	Treat the input as a string of characters.
%u	Treat the input as an unsigned decimal (integer) number.
%x	Treats the input as a hexadecimal number (base 16).
%%	Print a percent sign.
%Wd	Print the W integer X digits wide.
%(format)T	Outputs a date-time string resulting from using format as a format string for strftime. The corresponding argument can be the number of seconds since Epoch (January 1, 1970, 00:00), -1 (the current time), or -2 (shell startup time). Not specifying an argument uses the current time as the default value.
\%	Print a percent sign.
\n	Prints a newline character.
\t	Print a tab character.


важно. насколко я понял формат аргумента изначально воспринимается как string
а уже потом в строке формат он конвертируется согласно приказу.
обьясняю на примерах:
    $ printf "число=%d\n" 10
    число=10
    $ printf "число=%c\n" 10
    число=1

в первом примере мы берем аргумент стринг 10 и конвертируем  его в  десятичное число
во втором примере мы берем аргумент стринг 10 и конвертируем его как символ единичный поэтому он от 10 отрезал 1 символ
с начала. начало (офссет) у аргумента начинается слева. получили 1

следущие примеры
    $ printf "%x\n"  10
    a
    $ printf "%x\n"  11
    b

мы берем аргумент в формате стринг и конвертируем его в hex формат
и вот очень важный пример, 
    $ printf "%x\n"  "A"
    bash: printf: A: invalid number
    0
    $ printf "%x\n"  "a"
    bash: printf: a: invalid number
    0
    $ printf "%x\n"  "0xa"
    a
    $ printf "%x\n"  "0xA"
    a
тоесть на сколько я понял если мы хотим конвертировать аргумент в hex формат то на входе
по дефолту ожидается что аргумент имеет dec формат. а если мы хотим уже в аргументе выразить число в hex формате
то его нужно в аргументе писать в виде "0xhex"
охуеть




следущий прмиер
    $ printf "число=%x\n" q
    bash: printf: q: invalid number
    число=0
здесь он нас законно щлет нахер потому что как я уже сказал если мы хотим сконвертиоровать
аргумент в hex формат то аргументе по дефолту принтф ожидает видеть аргумент в формате десятичном 
поэтому аргумент вида "q" приводит к посыланию нахер


двигаем дальше. есть особая залупа о которой не сказано в манах. а оно только обнаруживется в примерах.
залупа касется аргиумента

    $ printf "%d\n" "'A"
    65
    $ printf "%x\n" "'A"
    41

если указываем в аргументе вот так 'аргумент
то это сообщает принтф что прежде чем аргумент подставлять в формат его нужно из ASCII символа преобразовать 
в число причем подставить это число в аргумент именно в десяиичном виде . 
тоесть в ASCII таблице символ "A" имеет код 65(dec)

итак 65  подставляется в аргумент. 
таким макаром первый пример превращается в 
    $ printf "%d\n" 65
    65
а второй пример превращается в  
    $ printf "%x\n" 65
    41

поскольку как я уже писал если мы хотим преобраовать число в hex то принтф ожидает по дефолту что 
в аргументе число представлено в формате dec. поэтому 65 dec преврашается в 41h
если же мы хотим чтобы принтф рассмматривал уже в аргументе 65 как hex число то надо делать вот так
    $ printf "%x\n"  "0x65"
    65

ну а вот такая хрень приводит к ошике
    $ printf "%x\n"  "0x'A"
    bash: printf: 0x'A: invalid hex number
    0

вообще этот принтф это полный пиздец. выдумка шизофреника. 

следущий момент а если у нас несколько аргументов. тогда они выбираются слева направо по порядку. тоесть
    $ printf "ширина=%d, длинна=%d \n" "10" "2"
    ширина=10, длинна=2
тоесть первый %d берется как 10
второй %d берется как 2
все просто. идем слева направо.


далее. 
значит таким макаром если мы хотим по быстрому узнать какой ASCII код у символа
то можно набрать 
    $ man ascii
а можно вот так
    $ printf "%d\n" "'3"
    51
    $ printf "%d\n" "'4"
    52


далее. 
что еще интересно что вот эта хуйня $1 она возможно только при вызове скрипта
тоесть просто для команды в строке этой хуйни не сущетсует
    $ echo $1 <<< "a"
    $ echo "1" | echo $1 
    $ printf "%s \n" "$1" <<< "a"
    $ echo "a" | printf "%s \n" "$1" 
видим что везде пусто на выхлопе



| bc
с ним есть такая хуйня. если мы в него передаем строчку то обязательно 
она должна заканчиваться символом Enter иначе пошлет нахуй. 
пример
    $ echo "2*3" | bc   
    6
    $ echo -n "2*3" | bc
    (standard_in) 1: syntax error
тоесть во втором примере ошибка потому что echo -n недобавляем автоматом символ Enter
к потоку байтов. поэтому bc шлет нахуй.

тоже самое когда юзаем printf 
    $ printf "2*3" | bc
    (standard_in) 1: syntax error
    $ printf "2*3 \n" | bc
    6

    


| for

есть вот такая хуйня в баш

   for i
    do
        echo -n "vasya"
    done

мы видим   
    for i
типа что за хуйня? оказывается это есть такое сокращение для
    for i in $@
охуеть. потому что иначе эта строчка сука не имеет никакого значения падла
таким образом это эквивалент
   for i in $@
    do
        echo -n "vasya"
    done


| wc

оказалась приколная программа
что она умеет делать
  wc - print newline, word, and byte counts for each file

тоесть она умеет считать:
    число строк
    число слов
    число байтов


этот пример берет папку с *.txt файлами и считает сколько в них суммарно слов
    $ ls -1 *.txt | xargs -L1 -I% wc -w ./"%" | awk '{print $1}' | xargs echo | sed 's/ /+/g' | bc
    727721

еще можно через wc считать число букв или байтов в стринге
хотя есть подьебка
пример
    $ echo "1" | wc -m
    2
возникает вопрос почему длинна два символа.
а потому что эхо вставил символ Enter вконце. а для wc это тоже символ
    $ echo "1" | od -t x1
    0000000 31 0a

убираем enter в конце и получим уже верный результат
    $ echo -n "1" | wc -m
    1

    $ echo -n "1" | od -t x1
    0000000 31

поэтому удобнее считать число букв в стринге через awk потому что он enter не считает
пример
    $ echo  "1" | awk '{print length}'
    1

а теперь самый что ни на есть практический пример.
нужно узнаиь число букв в хеше
    $ echo "1" | sha512sum | awk '{print $1}'   | awk '{print length}'
    128
    $ echo "1" | sha512sum | awk '{print $1}'   | wc -m
    129
    $ echo "1" | sha512sum | awk '{print $1}'   | od -t x1
0000000 33 61 62 62 36 36 37 37 61 66 33 34 61 63 35 37
0000020 63 30 63 61 35 38 32 38 66 64 39 34 66 39 64 38
0000040 38 36 63 32 36 63 65 35 39 61 38 63 65 36 30 65
0000060 63 66 36 37 37 38 30 37 39 34 32 33 64 63 63 66
0000100 66 31 64 36 66 31 39 63 62 36 35 35 38 30 35 64
0000120 35 36 30 39 38 65 36 64 33 38 61 31 61 37 31 30
0000140 64 65 65 35 39 35 32 33 65 65 64 37 35 31 31 65
0000160 35 61 39 65 34 62 38 63 63 62 33 61 34 36 38 36
0000200 0a
0000201


видно что awk дает верный ответ а wc нет. потому что у нас в стринге на конце есть 0x0a тобишь Enter и wc его считает. 
а он нам нахуй ненужен.
-----


    
=== остановился тут

$$$$$$$$$$$$$
$$$$$$$$$$$$$
$$$$$$$$$$$$$

вопросы:
- вернуть обратно модуля ядра чтобы coretemp опять заработал
- thermal zones
- yaml формат  в thinkfan
- <<<



- а как происходит запись в файл сразу двух процессов?
как при этом работает
$ : > file



-  изучить bash advanced guide
