bash


| tr

эта комнда ищет паттерн и меняет его на другой

$ echo " output=10; input=16; A0" | tr [:lower:] [:upper:] 
 OUTPUT=10; INPUT=16; A0


$ echo "aaa bbb " | tr "a" "D"                             
DDD bbb 



эта команда он подлая. об этом можно прочитать в info tr
вот пример

$ echo "b" | tr  bbbbb  12345
5

вчем подлость команды tr : у нас в паттерне есть несколько b возникает вопрос
когда мы находим b в нашем слове то какой b использовать? тот который b в 1 превращает
или b который в 2 превшращает? или b который в 5 превращает?
ответ такой что берется самый последний b. поэтому все b пропускаются в шаблоне
и берется последний b кторый превращает b в 5.

еще пример

$ echo "a"  |  tr    aaaaaaaaaa 1234567890
0


тоесть у нас есть шаблон aaaaaaaaaa у нас естт исходное ссобщение 'a'
возникает вопрос какой a нужно брать из шаблона. овтет последний.
потом смотрим на какой символ мапится последний a  в шаблонке ответ а ноль.


прмиер

$ echo ooops not good | tr oops nice
iiice nit giid

как это рабооает. 
у нас есть шаблон "oops" у нас есть слово "ooops"
в шаблоне берем последний "o" он мапитсят в "i" получается

[ooo]ps -> [iii]ps

остатеся вопрос с ps он мапиисят напрямую поэтому 

[ooo][ps] -> [iii][ps] = iiips

далее берем слово "not"
берем шаблон "ooops" 
в шаблоне "n" нет. есть "o" но в шаблоне "o" несколько. мы берем последнее "o"
второе "o" мапится в "i"

потмоу что o[o]ps n[i]ce

значит n[o][t] --> n[i][t]
бквы t нет в шаблоне значит t остается без изменений значит

not -> nit

берем слово "good"
ни g ни d нет в шаблоне они без изменений. 
буква o есть  в шаблоне. их несколько в щаблоне мы беерм послнее o в щаблрне оно маится в
i значит

g[oo]d  --> giid

значит в итоге 

iiips nit giid

в целом намой взгляд достоачно неинтуитивная и ебанутая команда этот tr


| special variables $0 $1 $@  $# $* $? $$ $!

`$0` – The name of the script being executed.
`$1-$9` – The first nine command-line arguments.
`$#` – The number of command-line arguments.
`$*` – All command-line arguments as a single string.
`$@` – All command-line arguments as an array.
`$?` – The exit status of the last executed command.
`$$` – The process ID of the current shell.
`$!` – The process ID of the last background command.


рассмотрим $0
я не согласен то о чем везде пишут что $0 это имя скрипта.
посмотрим

$ echo $0
bash

$ /bin/bash
$ echo $0
/bin/bash


$ ln -s /bin/bash ./b-lnk
$ ./b-lnk
$ echo $0
./b-lnk


$ ln -s ./b-lnk ./c-lnk
$ ./c-lnk
$ echo $0
./c-lnk

отсюда видно что $0 эта переменная показывает каким образом был запущен процесс.
а именно его такой параметр как /proc/$$/cmdline

/proc/self vs /proc/$$/ (self это не перменная. это симлинк в /proc/)

запускаем чтото в баше . тогда он себя форкает через сисколл(просит об этом ядро тоесть)то создает дочерний процесс
а вот если в баше прога зпускатся через exec то баш взывает сисколл exec тоесть управлениеп
передаетая ядру. и ядро замещает усовно говорят код баша в процессе в котором крутится баш 
на код вызываемой программы.  

мы импользуем exec когда не хотим создавать новый процесс. а хотим запустиьт прогу
в рамкаж уже этого процесса. 



--
вот так верно

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c", "sleep 120"]

а так полет нахер

$ cat Dockerfile 
FROM ubuntu

CMD ["/bin/bash", "-c sleep 120"]

--
вот так верно

docker run --rm --name t1 -it    --entrypoint  "/bin/bash"   ubuntu  -c "sleep 120"

а так полет рахер

docker run --rm --name t1 -it    --entrypoint  '/bin/bash -c "sleep 120"'   ubuntu  
отому что в доках дкоера написано что --entrypont должно сдежать татолько
путь к бинарнику\скриту. но не к параметрам. параметры пишктая в самом справава



==

| -
| ~-

в баше любили повыебвыаться.

если мы в качестве пути укажем "-" то баш подставит вместо этого $OLDPWD
где OLDPWD это сохранненный есть предыдущая папка в которой ты был.
но эта хрень раротботет только с встроенным билтином cd и только в единствнной форме

$ cd -
эквивалентно
$ cd $OLDPWD

при этом вот такое уже нераобтеает

]$ cd -/tmp
bash: cd: -/: invalid option
cd: usage: cd [-L|[-P [-e]] [-@]] [dir]

в эхо это тоже неработает

$ echo -
-


втора хрень "~-" она более универсальная. она раобтотает уже нетолько с cd
но и скажем с echo 

$ echo $OLDPWD
/
[vasya@lenovo //]$ cd ~-
[vasya@lenovo /]$ echo ~-
//


пиздец доблеблы в этом баш. выбеонщики

нашел этот все зесь = https://unix.stackexchange.com/questions/330876/difference-between-cd-and-cd
===
| bash
| redirect
| exec

bash
io redirect

(для начала ознакомился с этим https://tldp.org/LDP/abs/html/io-redirection.html)

разбереся как работает эта команда
       # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3

для начала
немного отойдем в сторону что будет если ввести команду
$ cat > 56.txt
а будет вот что. команда будет ждать ввода текста со стандартного ввода.
тоесть можно сидеть и набирать текст. когда хотим закончить набор то жмем Ctrl+D.
и этот текст набранный в терминале на экране будет записан в файл.

получается форма вида

# echo "asd" > /tmp/1.txt 
это укороченная форма команды
# echo "asd" 1 > /tmp/1.txt

и команда вида
# cat < 1.txt
это укороченный аналог
# cat 0 < 1.txt
(взял отсюда https://tldp.org/LDP/abs/html/io-redirection.html)

еще важная хуйня про io redirect
надо обязательно дескриптор файла ставить рядом без пробелов со знаками ">","<" итп.
тоесть

$ dfrtr 2>4.txt
$ cat 4.txt
dfrtr: command not found

тоесть видно что редирект сработал. мы ввели несуществующую команду.
при этом канал ошибок был заредиректен на файл 4.txt
видно что мы ввели "2>..." тоест между 2 и ">" нет пробела. 
такой редиректо сработает.

$ dfrtr 2 >4.txt
dfrtr: command not found

а этот редирект неработает. потому что у нас между 2 и ">" стоит пробел.

далее . разберем поподробнее пример
    $ dfrtr 2>4.txt

что в нем интересно это как оно выполняется.
у нас есть баш процесс и мы его просим запустить команду "dfrtr"
баш процесс выполняет сисколл и просит ядро создать новый процесс самого себя. когда клон исходного процесса
будет создан в форме нового процесса то баш в новом процессе ищет среди $PATH бинарник с именем "dfrtr"
ненаходит его и посылает на sterr ошибку. если бы бинарник был бы найден то баш склонированного процесса
выполнил бы еще один сисколл который просит ядро заменить в текущем процессе бинарник баша на бинарник dfrtr.
соотсвтвенно вопрос - кто кидает в stderr ошибку что файл ненайден - баш в склонированном процессе или ядро?
как я понимаю имеено баш запускает ряд сисколлов stat в разных папках которые у него прописаны в $PATH
и все сисколлы сообщают бинарнику баша что там такого файла нет. тогда бинарник баша пишет в sterr 
сообщение о том что файл ненайден. таким образом именно бинарник баша кидает на stderr сообщение об ошибке
я не ядро. потому что важно было понять кто занимается отправкой сообщений на stderr юзерская программа
или само ядро. 
вот доказательство

$ strace  bash -c "kuku"
...
stat(".", {st_mode=S_IFDIR|0775, st_size=1011712, ...}) = 0
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/.local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/sbin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/sbin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/bin/kuku", 0x7ffcfd0c62a0)   = -1 ENOENT (No such file or directory)
stat("/sbin/kuku", 0x7ffcfd0c62a0)      = -1 ENOENT (No such file or directory)
stat("/bin/kuku", 0x7ffcfd0c62a0)       = -1 ENOENT (No such file or directory)
stat("/usr/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/games/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/snap/bin/kuku", 0x7ffcfd0c62a0)  = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/home/vasya/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)
stat("/usr/local/go/bin/kuku", 0x7ffcfd0c62a0) = -1 ENOENT (No such file or directory)

тоесть видно что бинарник баша ищет бинарник kuku во всех папках которые есть у него в $PATH
и ничего ненаходит.
...
write(2, "bash: kuku: command not found\n", 30bash: kuku: command not found
) = 30

и тогда бинарник баша сам лично через сисколл write пишет в дескриптор "2" об ошибке
я совершенно не утверждаю что в 2 неможет писать само ядро. но в данном случае ошибку генерирует
сам юзерский процесс.

так вот вовзращаемся к примеру
        $ dfrtr 2>4.txt
рассмотрим более простой пример для начала
        $ dfrtr
        dfrtr: command not found

кто гененриует ошибку? ответ склонированный бинарник баша генерирует.
у нас наш текущий процесс баша сам себя клонирует. дальше в дело вступает клонированный баш.
он начинает искать бинарник dfrtr по всем папкам прописанным в $PATH
ненаходит. и тогда он склонированный бинарник баша пишет в 2 о том что файл ненайден.
таким образом отвечаю на вопрос - если команда не найден то кто генерирует ошибку?
возвращаемся к примеру
         $ dfrtr 2>4.txt
наш текущий баш склонирует самого себя в новый процесс через сисколл к ядру.
плюс наш исходный баш попросит ядро чтобы при создании нового процесса его дескриптор 2 указывал 
не на pty файл ( не на терминал как это обычно бывает)  а на файл ./4.txt
таким образом привязку 2 к 4.txt для нового процесса делает ядро по просьбе родительского баша.
дочерний баш к этому не имеет никакого отношения. дочерний единственное что сделает это напишет в 2 
что файл не найден. гениально. мудота та еще...
важно еще то что такого рода редирект файловых дескрипторов происходит не для исходного процесса баша 
а исключительно для новых порождаемых процессов. это тоже важно отметить. 

теперь фундаментальный вопрос а как нам изменить привязку файловых дескрипторов не для новых 
порождаемых процессов а для текущего процесса в котором крутится bash
в этом нам поможет баш билитн exec


баш builtin exec
что он делает.
по дефолту если мы запускаем команду в баше то баш это процесс как любой другой.
когда мы запускаем команду то баш создает новый процесс и в нем уже запускает нашу команду.
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
тоесть видно что номер баш процесса 31410
когда мы в нем запустили команду pstree то баш создал новый процесс 31426
так вот exec заставляет бащ не создавать новый процесс а запустить эту команду в текущем процессе
пример
$ echo $$
31410
$ pstree -A -s -p 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31410)---pstree(31426)
$ exec sleep 120
$ pstree -Asp 31410
systemd(1)---systemd(4739)---gnome-terminal-(31314)---sleep(31410)
видно что процесс 31410 остался но там уже не баш а наша команда. а нового процесса нет.

как видно не создавание нового процесса было выполненно через баш билтин exec . в виде

$ exec команда

итак "exec команда" не порождает новый процесс а в текущем процессе заменяет бинарник.
есть надежда что подключение io redirect вкупе с exec позволит нам изменить привязки файловых
дескрипторов для текущего процесса.

$ echo $$
32624
$ exec sleep 130 2>3-err.txt

итак у нас был баш процесс 32624 со стададартной привязкой его дескрипоров 1,2,3 к терминалу
далее мы говорим что в текущем процессе заменить баш на sleep и для этого процесса (для того же самого)
задать что файловый дескриптор 2 должен смотреть на файл 3-err.txt

проверяем
$ ls -1al /proc/32624/fd
total 0
dr-x------ 2 vasya vasya  0 окт  4 09:00 .
dr-xr-xr-x 9 vasya vasya  0 окт  4 09:00 ..
lrwx------ 1 vasya vasya 64 окт  4 09:00 0 -> /dev/pts/21
lrwx------ 1 vasya vasya 64 окт  4 09:00 1 -> /dev/pts/21
l-wx------ 1 vasya vasya 64 окт  4 09:00 2 -> /home/vasya/temp/3-err.txt

и это действительно сработало!
процесс по номеру не поменялся. зато его привязка для дескриптора 2 поменялась.

попробуем на этом фоне более интересный пример
запустить баш из баша при этом перенаправить его 2 в 5.txt
для начала я хотел показать одну важную вещь. вот  у нас есть баш процесс.
я думал что prompts приглашение этот процесс пишет в 1 тоесть в stdout
а оказалось что он его пишет на stderr! показываю

$ echo $$
31668
$ bash 1>7.txt
таким макаром я запустил новый процесс баша и его stdout я завернул на файл 7.txt
$ 
при этом как видно у меня на экране по прежнему присуствует prompt тоесть 
этот prompt он пишется процессом как я уже сказал не на stdout а на stderr

открываю другой терминал и проверяю что новый баш имеет то  редирект в файл который я сказал
(другой терминал)$ $ cat 7.txt 
2661
(другой терминал)$ pstree -Asp 2661
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(31668)---bash(2661)
видно что новый баш это чайлд от головного баша
(другой терминал)$ ls -1al /proc/2661/fd
lrwx------ 1 vasya vasya 64 окт  4 10:27 0 -> /dev/pts/22
l-wx------ 1 vasya vasya 64 окт  4 10:27 1 -> /home/vasya/temp/7.txt
lrwx------ 1 vasya vasya 64 окт  4 10:27 2 -> /dev/pts/22
lrwx------ 1 vasya vasya 64 окт  4 10:27 255 -> /dev/pts/22
четко видно что наш дочерний баш имеет stdout завернутый в файл

так вот аналогично легко убедться что если мы запустим баш у которого stderr будет завернут
в файл то  у нас приглашение баша исчезнет с экрана потому что оно теперь будет писаться не в терминал а в файл
$ bash 2>8.txt

и все у нас на экране больше нет prompt

так вот до этого моменты мы создавали дочерний процесс баша у которого был настроен редирект одного из 
файл дескрипторов в файл. 
теперь сделаем тоже самое без создавания дочернего процесса.
в первом терминале запускаем
    $ echo $$
    2963
    $ exec bash 1>10.txt
    $ 

во втором терминале проверяем
$ pstree -Asp 2963
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(2963)
$ ls -1al  /proc/2963/fd 
lrwx------ 1 vasya vasya 64 окт  4 10:31 0 -> /dev/pts/23
l-wx------ 1 vasya vasya 64 окт  4 10:31 1 -> /home/vasya/10.txt
lrwx------ 1 vasya vasya 64 окт  4 10:31 2 -> /dev/pts/23
lrwx------ 1 vasya vasya 64 окт  4 10:32 255 -> /dev/pts/23

видно что исходный процесс 2963 не имеет чайлдов и что его 1 перенаправлен в 10.txt
таким макаром мы научились текущий баш процесс менять таким образом чтобы у него менялась 
привязка его файл дескрипторов. вот эта волшебная команда
        $ exec bash 1>10.txt
так вот в описании билитина exec написано что это можно сделать еще короче.
цитирую
$ exec --help
exec: exec ... [command] ... [redirection ...]
...
 If COMMAND is not specified,
    any redirections take effect in the current shell.

тоесть тут написано что если не указать никакой команды то получается что он автоматом меняет дескрипторы
указанные в [redirection] для данного процесса. 
проверяем
    $ echo $$
    3208
    $ exec 1>11.txt
    $ 

проверяем в другом терминале
$ pstree -Asp 3208
systemd(1)---systemd(4739)---gnome-terminal-(31314)---bash(3208)
$ ls -1al  /proc/3208/fd
lrwx------ 1 vasya vasya 64 окт  4 10:39 0 -> /dev/pts/26
l-wx------ 1 vasya vasya 64 окт  4 10:39 1 -> /home/vasya/11.txt
lrwx------ 1 vasya vasya 64 окт  4 10:39 2 -> /dev/pts/26
lrwx------ 1 vasya vasya 64 окт  4 10:39 255 -> /dev/pts/26

и действительно да. процесс 3208 не имеет никаких чайлдов. и его 1 имеет редирект на файл!
гоча!

я бы еще как сказал хотя это не совсем верно. что если мы никакую команду не подставляем в exec
то баш сам автоматом как бы подставляем bash тоесть  как бы 
    exec 1>11.txt = exec bash 1>11.txt
хотя это не совсем так. потому что в первом случае он не меняет бинарник в памяти а во втором случае
он удаляет старый бинарник и сует в процесс новый бинарник. (ксатти сказать процесс получается это как бы коробка (типа фреймворк) плюс начинка в виде бинарника)


двигаем дальше. вот еще интересный пример который нам пригодится
$ echo $$
3554
$ exec bash 12<>12.txt
$ echo $$
3554
[vasya@lenovo ~]$ ls -1al /proc/$$/fd
lrwx------ 1 vasya vasya 64 окт  4 10:49 0 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 1 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 12 -> /home/vasya/12.txt
lrwx------ 1 vasya vasya 64 окт  4 10:49 2 -> /dev/pts/29
lrwx------ 1 vasya vasya 64 окт  4 10:49 255 -> /dev/pts/29

мы говорим чтобы в нашем текущем процессе был заменен бинарник на баш
и чтобы  в нашем процессе был открыт новый файловый дескриптор с номер 12 и чтобы этот файловый дескриптор
был связан с файлом 12.txt который будет открыт с флагами и на чтение и на запись.
что примечательно в этой команде. примечательно то что мы можем изменить для данного процесса
число его файловых дескрипторов. было 0,1,2,255 (правда какого хрена тут делает 255 непонятно. вернее понятно.
я же запускаю bash из некоего другого процесса скажем это gnome-terminal или xterm или из под граф оболочки 
и открытые файловые дескрипторы в родительском процессе автоматом наследуются и дочерним процессом вобщем щас нам этот 255 неважен) а стало 0,1,2,255,12.
таким макаром мы можем "прикрепить" к процессу дохрена файловых дескрипторов и дохрена открытых файлов.
при том что самому бинарнику процесса на этот абсолютно плевать. вот эти открытые файлы , прикрепленные файловые
дескрипторы они бинарник ни к чему не обязывают. это как в квартире понаделать больше окон. 
если процесс нехочет ни читать с данного файлового дескриптора ни писать в него то его никто к этому не обязывает. это как у машины добавить запасных колес. или в ящике понаделать новых дырок. тот кто сидит в яшике (бинарник)  может пользоваться этими дырками а может и нет. опять же что интересно у нас обычно один процесс родительский порождает некий дочерний процесс и родитель может заказать для дочернего процесса понаоткрывать 
для него кучу файлов. но дочернему процессу это может быть глубоко фиолетово. он может пользоваться открытыми 
для него файлами а может и нет. это никак не влияет на него. 
что еще важно это вот значок  "<>" он на самом деле никакого мистического значения не имеет. он на самом деле 
только значит то что в сисколле будет прописано что открываемый файл открывается с флагами "R+W" тоесть 
и на чтение и на запись. сразу в догонку скажу что значок ">" говорит через сисколл ядру что нужно открыть файл 
с флагом "W" а значок "<" говорит ядру что файл нужно открыть с флагом "R"
тоесть то что изначально называется редиректом. это корявое определение. это не редирект это команда ядру 
на то  с каким флагом нужно открыть файл. тоесть 
        $  echo 1 1>4.txt
комбинация "1>4.txt" говорит башу как ему выстроить сисколл который он будет пулять в ядро. 
сисколл должен быть такой что - надо открыть файл 4.txt причем с флагом "W" и привязать этот файл к дескриптору 1. ну да.. на последнем этапе можно скзаать что мы имеем дело с редиректом. но важно подчеркнуть что значки
"<" и ">" и "<>" их смысл не только редирект но и с каким флагом открыт файл на который они ведут. 
">" =  W
"<" =  R
"<>" = RW

еще пример 
        $ echo "abc" 12<>5.txt
здесь ксати тоже интересно. дело в том что echo это билтин баша. поэтому ему ненужно себя клонировать.
а он выполняет команду ровно в текущем процессе. так вот для текущего процесса будет открыть файл 5.txt
в режиме "RW" и будет создан файловый дескриптор 12 который будет прикреплен к текущему процессу 
сам же echo ясен банан выплюнет свой "abc"  в дескриптор 1. тоесть ему этот открытый дескриптор 12 
в целом нахрен не сдался. просто мы делая одно одновременно сделали и другое
причем насколько я понимаю баш он умный и он откроет этот файл и создаст дескриптор но как 
только билтин закончит работу то баш автоматом закроет файл и уничтожит дескриптор. вот 
доказательство
    $ echo "abc" 13<>13.txt
    abc
    $ ls -1al /proc/$$/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:12 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:12 2 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:25 255 -> /dev/pts/31
тоесть еще раз так как echo это билтин то никого нового процесса создано не будет. все
будет делать в рамках текущего баша. поэтому я и смотрю список открытых файлов для текущего процесса.
и видно что никакого дескриптора 13 нет и в помине. он был создан и тут же обратно удален.
я так это понимаю.

совершенно другой коленкор когда мы через баш запускаем некую внешнюю программу и просим баш прилепить к ней
открытый файл. баш составит нужный сисколл для ядра. и мы все будем иметь.
    $ sleep 130 14<>14.txt

с другого терминала смотрим
    $ ps aux | grep sleep
    vasya     4806  0.0  0.0  14580   892 pts/31   S+   11:28   0:00 sleep 130
    $ ls -1al /proc/4806/fd
    lrwx------ 1 vasya vasya 64 окт  4 11:29 0 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 1 -> /dev/pts/31
    lrwx------ 1 vasya vasya 64 окт  4 11:29 14 -> /home/vasya/14.txt
    lrwx------ 1 vasya vasya 64 окт  4 11:29 2 -> /dev/pts/31

тоесть у нас баш себя клонировал тоесть попросил ядро создать новый процесс. причем при клонировании попросил 
ядро чтобы дочерний процесс имел открый файл 14.txt через дескриптор 14.
далее баш в дочернем процессе попросил ядро через  сисколл заменить свой
бинарник на sleep.
поэтому все так выглядит
еще раз подчеркну что значок "<>" в конечном итоге означае то что файл 14.txt открывается с флагами и на чтение
и на запись. флаг "<" открывает файл на чтение только, флаг ">" открывает файл на запись только
причем имеется ввиду для данного процесса. ничто мне не мешает из другого процесса попросить ядро открыть этот файл с другими флагами. тоесть скажем наш процесс открывает файл только на запись. а с другого процесса я прошу
ядро открыть файл на чтение. и таким макаром я спокойно читаю то что пишет туда первый процесс.

также попутно я покажу докажу что когда баш запускаем внешний бинарник то он создает новый процесс 
клонирует себя а если мы запускаем баш билтин то новый процесс не создается.
я запутил баш с номером процесса 4309
в соседнем окне я запустил strace
$ sudo strace -p 4309 -e clone,fork,execve
strace: Process 4309 attached

и в первом окне я запустил ls -1
и мне strace нарисовал
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7fe0cc338a10) = 4589

а потом я в первом окне запустил echo 1
и мне strace ничего не нарисовал
это все доказывает

теперь переходим к интересному.
зная все что мы узнали выше я открою файл /dev/cpu_dma_latency
в текущем баше так чтобы он оставался открытым
    # exec bash 16> /dev/cpu_dma_latency;
    # ls -1al /proc/$$/fd
    lrwx------ 1 root root 64 окт  4 11:37 0 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:37 1 -> /dev/pts/32
    l-wx------ 1 root root 64 окт  4 11:38 16 -> /dev/cpu_dma_latency
    lrwx------ 1 root root 64 окт  4 11:37 2 -> /dev/pts/32
    lrwx------ 1 root root 64 окт  4 11:38 255 -> /dev/pts/32

ну или можно было короче написать
    # exec 16> /dev/cpu_dma_latency;
мы открыли /dev/cpu_dma_latency на запись и прикрепили его к процессу через дескриптор 16
показываю чему он равен прям щас 
    # cat /dev/cpu_dma_latency  | od -t x1
    0000000 00 94 35 77
    0000004

теперь можно его изменить вот так
    # echo -en "0x00000258" 1>&16
здесь так как echo у нас шлет свои данные на stdout тоесть в 1 то я перенаправил в 16.
на low level уровне это работает так что по дефолту баш юзает сискол
write (1,"текст")
а когда мы ему дали подсказку то он делает
write(16,текст)

проверяем что сработало
# cat /dev/cpu_dma_latency  | od -t x1
0000000 58 02 00 00
0000004
да сработало получается.
такой вывод наоборотный потому что в оперативку много байтовой число пишется в little endian формате.
об little endian  читай в ext4.txt

также отмечу вот это "1>&16" знак амперсанда говорит бащу что мы делает перенаправление не в файл  с именем 16 на файловой системе а в файловый дескриптор 16. это две большие разницы.
ксати я щас попробую сделать запись в несуществующий дескриптор
    # echo -en "0x00000258" 1>&28
    bash: 28: Bad file descriptor
все верно. пошел нахер


итак еще раз
что было сделано
     # exec 16> /dev/cpu_dma_latency;
     # echo -en "0x00000258" 1>&16
для текущего процесса баща был открыт файл /dev/cpu_dma_latency на запись. и прикреплен к процессу через
дескриптор 16. фишка в том что он будет висеть открытым пока я его сам руками не закрою.
далее я делаю запись в этот файл через подскажу башу что писать надо не в дескриптор 1 как он это обычно
делает по дефолту а в дескриптор 16. после записи файл который скрывается за дескриптором 16 продолжает висеть открытым.
тут еще раз также подчеркну что когда мы работаем с io redirect то между номером дескриптора и значком
редиректа категорически нельзя чтобы были пробелы. тоесть 
         # exec 16> /dev/cpu_dma_latency;   # правильная команда

         # exec 16 > /dev/cpu_dma_latency;  # НЕправильная команда
         сразу вылезет ошибка. потому что баш будет интепретировать эту команду вот так
         # exec 16 1> /dev/cpu_dma_latency;
тоесть он будет пытаться найти бинарник с именем "16", заменить в текущем процессе баш этим бинарником
и заменит файловый дескриптор 1 чтобы он вел не на терминал а на файл /dev/cpu_dma_latency
тоесть это совершенно не то что нам надо. поэтому 
        "16> /dev/cpu_dma_latency" = правильная хрень. обозначает что мы открываем файл /dev/cpu_dma_latency
        на запись и в для процесса прокидываем этот файл как дескриптор номер 16

        "16   > /dev/cpu_dma_latency" = неправильная хрень, если быть более точным она тоже правильная но она делает совершенно другое. она обозначает вот это 
        "16   1> /dev/cpu_dma_latency" 
то есть мы открываем файл /dev/cpu_dma_latency на запись и привязываем его к процессу через дескриптор 1.
и плюс к этому у нас бинарник имеет имя 16. 
поэтому смысл этих двух команд совершенно разный

а вот после значка ">" уже неважно есть пробелы или нет. оно все будет трактоваться одинаково тоесть
    "16> /dev/cpu_dma_latency"
    "16>/dev/cpu_dma_latency"
    "16>        /dev/cpu_dma_latency"
это все одно и тоже.
в целом конечно это дебилизм потому что сегодня я это помню. а завтра уже совершенно нет.


возвращаемся НАКОНЕЦ к нашей исходной задаче
нужно понять как это работает
        # exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
кстати сразу замечу что 3 это не stderr (как я иногда глючу так думая), stderr это 2
а 3 это вобще ничего. потому что stdin это 0. stdout это 1 и stderr это 2
немного преобразуем это выражение
        # exec bash 3<> /dev/cpu_dma_latency; echo -en "0x00000258" 1>&3
строго говоря оно немного отличается от оригинала но по конечному результату это одно и тоже
зато все указано в явном виде и поэтому более понятно 
далее эту команду можно эквивалентно переписать как 
        # exec bash 3<> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
во первых я считаю что символ "<>" он излишен потому что мы собираемся писать туда а читать нет.
но в целом не особо важно конечно. но я считаю что вот это более грамотно.
поэтому преобразуем 
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
теперь все понятно. разберем его.
мы открываем файл на чтение /dev/cpu_dma_latency и прикрепляем этот  файл через дескриптор номер 3 у текущего баша. фишка в том что  файл будет висеть постоянно открытым все время. пока мы не закроем его 
специально сами руками. теперь если мы из баща будем писать в дескриптор 3 то оно будет лететь в файл
далее мы через echo посылаем число но не в канал 1 как это баш делает по дефолту а в канал 3.
таким макаром мы записали  число в /dev/cpu_dma_latency
казалось бы мы могли бы сделать проще вот так 
        # echo -en "0x00000258"  /dev/cpu_dma_latency
но это не привело бы нас к тому что нам надо потому что 
этот файл /dev/cpu_dma_latency он хитрый.нам надо чтобы файл оставался все время открытым после 
записи. если мы это делаем сразу через эхо. то как только эхо закончит то файл закроется и ОС перезапишет
значение на дефолтовое. так устроен этот файл. а вот верхний мудежный способ как раз дает то что после записи в эхо файл будет продолжать оставаться открытым и наше новое значение будет сохраняться. 
получается одна маленькая строчка из интернета но чтобы ее понять нужно диссертацию написать.
        # exec bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
при этом получается пока наш процесс баша будет на компе сущестовать файл будет открыт
и наше записанное значение будет жить.
как только мы текущий баш процесс закроем. файл тоже закроется и значние будет со стороны ос перезаписано
на дефолтовое.
в принципе можно было сделать и вот так
        # bash 3> /dev/cpu_dma_latency
        # echo -en "0x00000258" 1>&3
без выебонов с exec
у нас просто напросто создасться в системе +1 процесс с баш и только и всего. 
так что если расхлобучить все эти выебоны которые накручены в исходном выражении то вся фишка лишь в том
что для того чтобы открыть файл на постоянной основе надо заюзать вот это выражение
            # bash N> file
и только и всего.
тогда у нас  в системе будет баш процесс  у которого будет постоянно открытый файл "file" на запись
через дескриптор N. вот и все.

далее
теперь моя задача в том чтобы найти все процессы в которых открыты файл дескрипторы
ведущие на файл /dev/cpu_dma_latency
и закрыть все эти файл дескрипторы

# lsof -u root | grep cpu_dma_latency
bash       5106 root   16w      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6454 root    3u      CHR              10,59      0t0        162 /dev/cpu_dma_latency
bash       6828 root    3w      CHR              10,59      0t0        162 /dev/cpu_dma_latency

здесь видно какой процесс имеет этот файл открытым, через какой дескриптор, и  в каком режиме
открыт файл (r,w,rw)

и тут выясняется прикол (из того что я вижу навскидку из интернета) что нет такого красивого 
способа чтобы под рутом запустить команду и заставить позакрываться эти файловые дескрипторы. 
хаха.
тоесть вижу что есть только три неудобных способа
один это подключаемся к процессу через gdb и там запускаем команду на закрытие файла.
второй способ разыскать в граф оболочке наши конкретные терминалы с этими прям башами 
и уже из под них запускать команды на закрытие файлов
а ну и третий самый лоховской способ это поубивать эти процессы и автоматом и файлы закроются

я пойду вторым способом.
он состоит вот в чем.
причем в методичке там запаривают мозг что в завимости в каком режиме был открыть файл 
чтени, запись его нужно гасить по разному на самом деле нихрена. нам совершенно неважно как был открыт файл
    # exec 3> file
    # exec 3< file
    # exec 3<> file
нам на это наплевать 
во всех случаях гасим дескриптор совершенно одинаково
    # exec 3>&-
либо
    # exec 3<&-
а вот вариант 
    # exec 3<>&-
абсолютно нерабочий.
ПРИЧЕМ в данном случае абсолютно нельзя чтобы был пробел между ">" и "&-"
либо между "<" и "&-"
тоесть пробел запрещен не толко слева от знака редиректа но и справа
сразу выдаст ошибку!

поэтому в случае редиректов я бы советовал ни слева от знака редиректа ни справа не оставлять пробелов
чтобы не получать проблем на ровном месте


я в итоге предпочитаю гасить через 
    # exec 3> &-


^
||
=== остановился тут


$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$
вопросы:
  #  exec &> >(tee -a ./1.txt)
  wtf?
насколько я понимаю это эквивалентно
  #  exec 1,2>&1 | $(tee -a ./1.txt)
или как ?

далее.
а как происходит запись в файл сразу двух процессов?
как при этом работает
$ : > file
