параллельная штука.

как я понял системный вызов fork() создает дочерний процесс.
это полноценный новый процесс со своим новым pid.
он полностью независим от родительского процесса.
он имеет например свое незавиимсое виртуальное адресное пространстов в памяти.
поэтому процессы в памяти дочернего процесса никак не влияют на память в родительсокм
процессе.просто на момент когда процесс только что отклонирован его содержимое памяти 
ровно такое же как у родителя. потому что в режиме на чтение идет отсылка к памяти родителя.
но все изменения идут уже в отдельнуд область памяти.

другой системный вызов clone() как я понял он используется для создания трэдов.
это значит что тред имеет общую вирт память с процессом.
тред неиммет своего нового pid.

далее.


через --bind можно смонтировать любой каталог параллельно в другой катало

# mount --bind /tmp/1 /tmp/2

далее про файловую структуру файловую иерархию выяснилась интереснейшая вещь.

вот это вот дерево папок


# ls -1 /
bin
boot
dev
esdata
es_snapshots
etc
home
initrd.img
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
snap
srv
sys
tmp
usr
var
vmlinuz

это сугубо виртуальная структура.
эта штука нигде напрямую на диске незаписана.

наш процесс обращается к линуксе - мол скажи мне а каков листинг папок.

линукс там у себя в требухе шуршит и выдает некий результат. 
он его нечитает напрямую с диска. это чисто плод  виртуального размышления ядра.

то есть линуксу ничего немешает одлному процессу выдать один список папок 
а другому другой.

список папок на диске незаписан в жетском виде так чтобы линукс его считал с диска 
и отдал напрямую.

например.

раздел /dev/sda2 может быть подмонтирован к /mnt а можно подмонтировать к /tmp/1

то есть это все результат манипулирования.

одному процессу линукс при желании может отдать один список папок 
а другому процессу другой список.

а значит мы можем играться с тем какая структура папок их иерархия должны быть 
отдана одному процессу а какая структура другому. это все виртуальная штука.
разные процессы могут получать разные списки списка папок.

нет ну кончено на конечных дисках есть файловая система на которой жестко 
прописана структура папок. но это типа исходный материал.
но нам ничего немешает налету показать вместо одной папки другую.

ведь алгоритм выглядит так  - мы запрашиваем листинг папок.

линукс смотрит на диск. получает списко папок а потом может в этом списке чтото
динамически поменять (не насамом диске и его ФС)а в уже полученном списке.

и уже этототредактированный список отдать процессу.

подмена понятий налету.

получатеся что структура папок , обьекты монтирования структура папочной системы
это сугубо виртуалная щтука с которой можно играться.

*далее. в линуксе есть точки монтирования.
и эти точки монтирования могут иметь свойства. - shared private
unbindable slave.
* важно понять что вот эти свойства прайвэт шаред итп для точек
монтирования они неимеют отношения к маунт неймспейсам. это изначально
свойства тупо точек монтирования. маунт спейсы вылезают и появляются
уже потом и отдельным манером. 


насколько я понял та папка которую можно использовать 
совместно с несклькими процессами зовут shared mount

можно настроить чтобы изменения в структуре папок предоставленной процессу 1
отображались в структуре папок предоставленной другому процессу 2. и при этом 
чтобы изменеия в структуре папок показанной процессу 2 неотображались 
в структуре папок показанной процессу 1.

структура папок для процесса 1 называется shared mount
а структура папок для процесса 2 называется slave mount

типа процесс 1 один создает папку /tmp/1
и это видит процесс 2.

а если процесс 2 создает папку /tmp/2
и это невидит процесс 1

получается что для процесса 2 структура папок процесса 1 доступна на чтение.
а вот все изменения папок в процессе 2 сохраняется в другом месте.

точки монтирования которые мастер без слейвов называются privat mount.

есть еще unbindable mount - точки монтроавния которые нельзя  забиндить
через mount --bind

по умолчанию все обькты монтроания изначально private.
что логично.

вот так обьект монтирования делается из private в shared
# mount --make-shared <mount-object>

# mount --make-shared /

вот так делается slave обьект монтирования
# mount --make-slave /mount_point


две еще логичные команды
# mount --make-private <mount-object>

# mount --make-unbindable <mount-object>

во первых что такое неймспейс. это некая структура (таблица или чтото типа того ) в оперативке
линукса. она больше нигде кроме как в оперативке нехранится. как только мы перезагружаемся
поскольку никаких записей на диске неостается то все неймспейсы исчезают. как и любая другая часть
лежащая только в оперативке.

далее.
оказыается есть просто неймспейсы
а есть persistent namespaces.

в чем их отличие.

персистент неймспейс  - к ним не приаттачен ни один процесс.
как это работает.
в оперативке создается неймспейс. но нам нужно получить идентификатор на него чтобы 
с ним можно было начать чтото делать.

обычно по классике неймспейс создается при создаии процесса и тогда ссылка на неймспейс
кладется в /proc/$PID/ns

если процесса нет. то как бы дефолтового места куда можно было бы положить ссылку на неймспейс нет.

то есть на самом деле дело всего лишь куда положит ссылку.
некоторые утилиты в них можно указать какой файл будет хранить ссылку на неймспейс в оперативке.
наверно точнее в файле будет ссылка на некий файл в /proc а проц это хитрожопая файловая система 
которая хитрожопо связана с оперативкой ядра.

таким образом например утилита unshare умеет создавать неймспейсы без создания процессов.
если ей указать в какой файл положить ссылку на созданный неймспейс . пример

# touch /root/ns-uts         
# unshare --uts=/root/ns-uts

файл ns-uts он пустой. 
и если ввести ls -1al тоо будет показано ничего. как бутто этот файл никуда неведет.
но должен же он как то кудато указыывать на чтото в памяти линукса чтобы через него 
можно было связаться с неймспейсом.

если мы сравним на то как выглядит ссылка на имя неймспейса для процесса

# ls -1al /proc/1/ns/
lrwxrwxrwx 1 root root 0 Jun 18 00:41 uts -> uts:[4026531838]

мы увидим что uts както там хитрожопо указывает на инод в proc фс.

но еще раз скажу в случае с /root/ns-uts такого мы не увидим

t# ls -1al /root
-r--r--r--  1 root root    0 Jun 18 00:34 uts-temp

как бутто просто пустой файл никуда неведущий.

это потому что наш файл нележит на proc фс. и  он нас связыаем с неймспейсом 
другим хитрожопым способом. он нас связывает с именем неймспейса через хитрожопую файловую
систему nsfs (NameSpaceFileSystem)

как это проерить

# mount | grep nsfs
nsfs on /root/uts-temp type nsfs (rw)

еще как проверить

# findmnt | grep nsfs
TARGET									SOURCE				 FSTYPE     OPTIONS
├─/root/uts-temp                      nsfs[uts:[4026532440]] nsfs       rw

nsfs это чисто програмистская линукс хрень.
с ней както там работают утилиты. а юзерам с ней напрямую неработать.
можно просто понимать что когда мы создаем неймспейс и сразу к нему привязываем процесс
то ссылка на неймспейс кладется в /proc/$PID/ns
и тут nsfs ненужен. как я понял .
когда мы создаем неймспейс без процесса то создается имя неймспейса сохранятеся в некоей
вирт фс nsfs и ссылка на nsfs файл (или что за хрень за хрень незнаю ) через опцию bind 
пробрасывается на обычный файл на диске.

увидеть эту связь этот проброс ( а есть ли у нас файлы на диске к которым сделан проброс
на nsfs ? ) можно через findmnt или mount

получается 
nsfs[uts:[4026532440]] 
это имя файла или инода или чего то там на nsfs где хранится имя неймспейса или ссылка на него вобщем
по этой херне линукс может его найти идентифицировать. но мы как юзеры с этой хренью работать неможем
поэтому линукс через mount и опцию bind сам автоматом создает связь между обычным файлом
/root/uts-temp и  nsfs[uts:[4026532440]]

таким образом если мы будем обращаться к /root/uts-temp в утилитах которые умеют работаь с неймспейсами
(типа nsenter) то эти утилиты смогут добратьсядо nsfs.

сам по себе файл /root/uts-temp на диске в форме байтов ( если мы вытащим диск вставим в другой комп
и посмотрим что же хранится там в этом файле). там ничего нехранится.

это система налету когда мы обращаемся к файлу фищическому она пробрасывает прозрачно 
туда в кишки nsfs.

вся эта хрень сделана чтобы поддерживать линукс концепцию что все структуры в линуксе это типа файлы.
просто мы привыкли что файл это кусок на диске.  а это более общее понятие.
это типа путь . по которому мы можем обратиться и попасть хрен знает куда. можем на диск
а можем и в памят ядра.

таким образом мы узнал что такое persistent неймспейс.
конешно после перезагрузки наш файл /root/uts-temp больше небудет 
никуда вести. потому что и неймспейс исчезнет при отключении компа. и связь уже небудет никуда вести.
потому что связь она незаписана на диске. это чисто линукс в памяти у себя держал такой хук.
мол если будут обращаться к такому то файлу то пробрасывать внутрь ядра.

то ест вот это слово persistent оно относится не к потере электричества и у нас все выжило.
оно относится к тому что процесса нет приаттаченного к неймспейсу а неймспейс при этом живет 
неуничтожается. вот смысл слова персистент.

мельком взглянем на findmount

root@test-kub-03:/root# findmnt
TARGET                                SOURCE     FSTYPE     OPTIONS
/                                     /dev/sda1  ext4       rw,relatime,errors=remount-ro,data=ordered
├─/sys                                sysfs      sysfs      rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/security              securityfs securityfs rw,nosuid,nodev,noexec,relatime
│ ├─/sys/fs/cgroup                    tmpfs      tmpfs      ro,nosuid,nodev,noexec,mode=755
│ │ ├─/sys/fs/cgroup/systemd          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/lib/systemd/systemd-cgroups-agent,name=syste
│ │ ├─/sys/fs/cgroup/cpu,cpuacct      cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,cpu,cpuacct
│ │ ├─/sys/fs/cgroup/freezer          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,freezer
│ │ ├─/sys/fs/cgroup/net_cls,net_prio cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,net_cls,net_prio
│ │ ├─/sys/fs/cgroup/pids             cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,pids
│ │ ├─/sys/fs/cgroup/devices          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,devices
│ │ ├─/sys/fs/cgroup/hugetlb          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,hugetlb
│ │ ├─/sys/fs/cgroup/memory           cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,memory
│ │ ├─/sys/fs/cgroup/blkio            cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,blkio
│ │ ├─/sys/fs/cgroup/cpuset           cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,cpuset
│ │ └─/sys/fs/cgroup/perf_event       cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,perf_event
│ ├─/sys/fs/pstore                    pstore     pstore     rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/debug                 debugfs    debugfs    rw,relatime
│ └─/sys/fs/fuse/connections          fusectl    fusectl    rw,relatime
├─/proc                               proc       proc       rw,nosuid,nodev,noexec,relatime
│ └─/proc/sys/fs/binfmt_misc          systemd-1  autofs     rw,relatime,fd=36,pgrp=1,timeout=0,minproto=5,maxproto=5,direct
├─/dev                                udev       devtmpfs   rw,nosuid,relatime,size=1004076k,nr_inodes=251019,mode=755
│ ├─/dev/pts                          devpts     devpts     rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000
│ ├─/dev/shm                          tmpfs      tmpfs      rw,nosuid,nodev
│ ├─/dev/mqueue                       mqueue     mqueue     rw,relatime
│ └─/dev/hugepages                    hugetlbfs  hugetlbfs  rw,relatime
├─/run                                tmpfs      tmpfs      rw,nosuid,noexec,relatime,size=204828k,mode=755
│ ├─/run/lock                         tmpfs      tmpfs      rw,nosuid,nodev,noexec,relatime,size=5120k
│ └─/run/user/1000                    tmpfs      tmpfs      rw,nosuid,nodev,relatime,size=204828k,mode=700,uid=1000,gid=1000
├─/root/uts-temp                      nsfs[uts:[4026532440]]
│                                                nsfs       rw
├─/root/vasya                         /dev/sda1[/tmp]
│                                                ext4       rw,relatime,errors=remount-ro,data=ordered
└─/var/lib/lxcfs                      lxcfs      fuse.lxcfs rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other

если df -h покащзывает только классические точки монтирования

t# df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            981M     0  981M   0% /dev
tmpfs           201M   21M  180M  11% /run
/dev/sda1        20G   14G  5.1G  73% /
tmpfs          1001M     0 1001M   0% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs          1001M     0 1001M   0% /sys/fs/cgroup
tmpfs           201M     0  201M   0% /run/user/1000

то findmnt показывает их все.

например findmnt опзкаывает все бинды

например

├─/root/vasya                         /dev/sda1[/tmp]

то есть это значит что папка /tmp на /dev/sda1 она прибиндена в /root/vasya

поэтому я бы скзаал что findmnt это более расиренная и современная версия старого df -h

кратно скажу про sysfs и procfs. 
procfs более старая. 
sysfs более новая.

старая procfs неимеет четких правил че и как там держать.
новая sysfs имеет.

sysfs это как бы апргреженная и цивилизиированная версия procfs

однако невсе структуры програмитсы линукса будут переносить из procfs в sysfs.

изначально полтьзотвательсуие утилиты типа ps они лезли в /dev/mem и читали сырую память
типа того и оттуда находили инфо о процессах запущенных на компе.

вот чтобы эту фигню прекратить придумали procfs в которой информаци о процессах размещена
в виде папок и файлов.

тоесть изначально proc была придумана чтобы юзерские утилиты могли получать иформацию 
о процессах запущенных в удобной форме. то есть изначально это справочная по процессам.
потом ее функционал подрасширили.

ладно. возвращаемся к неймспейсам.

 
насколько я понял . когда мы создаем неймспес и тут же к нему аттачим процесс.
то вот этот вот файл  /proc/[pid]/ns/[type] на proc он ведет конечно тоже на nsfs
то есть

t# ls -1al  /proc/1/ns
lrwxrwxrwx 1 root root 0 Jun 18 00:41 uts -> uts:[4026531838]

файл /proc/1/ns/uts он через биндинг ведет на nsfs к хрени по имени nsfs[4026531838]

а когда мы с помощью unshare 

# unshare --uts=/root/ns-uts

создаем неймспейс то с помощью биндинга nsfs [23423423] имя неймспейса пробрасывается на обычный файл на фс 
а не на proc файл. 

вот и весь механизм.
и когда у нас ссылка на неймспейс хранится в proc то в findmnt об этом нет никакого упоминания.
а когда у насс ссылка ведет на обычный файл на диске то тогда ссылка в findmnt появляется про nsfs

вот и вся разница между персистент и неперсистент неймсейсов.

если персистент - значит ссылка на его имя в nsfs  привязана (прибиндена) к файлу на диске
если неперсистент значит ссылка на имя неймспейса в nsfs привязана к файла на proc.

ну и мол зачем нам перситсент неймспейсы. затем что мы хотим чтобы у нас были неймспейсы которые
неприязаны к конкретному процессу. ну и например был неймспейск нему был привязан процесс.
ссылка на имя неймспйса хранилась по пути /proc/$PID/ns/имя
когда процесс умер то папка /proc/$PID исчезает и мы теряем ссылку на неймспейс.
а может нам он еще нужен.
тогда если мы заранее сделаем биндинг на файл  в nsfs привяжем его к какому нибудь файлу на диске
то при уничтожении процесса мы ссылку на неймспейс непотеряем.

это как хардлинки на классической фс на файл. если  у нас есть 5 хардлинков то если мы удалим
все 5 то файл то на диске остался но связь с ним зацепка ниточка путь потерян. 
поэтому нужен хотя бы один хардлинк. тоже самое с именами неймспейсов.

возвращаемся к mount неймспейсам

команда unshare.

по умолчанию когда мы в bash запускаем команду то она запускается ровно в тех же неймспейсах
что и сам bash сидит.

так вот unshare позволяет запустить программу у которой все или какие мы захотим неймспейсы
будут другими новыми отличными от тех которыми обладает bash

пример

смотрим какой PID имеет текущий сеанс bash

root@test-kub-03:/root# echo $$
4935

запускаем новый баш у котрого хотим чтобы mount неймспейс был другой

root@test-kub-03:/root# unshare -m bash

ключ -m означает что мы хотим mount неймспейс другой чем у родительского баша.

узнаем PID дочернего баша

root@test-kub-03:/root# echo $$
23369

смотрим какой "номер" mount неймспейса имеет родительский баш

root@test-kub-03:/root# ls -l /proc/23369/ns/ | grep mnt
lrwxrwxrwx 1 root root 0 Jun 18 01:30 mnt -> mnt:[4026532441]


смотрим какой "номер" mount неймспейса имеет дочерний баш 

root@test-kub-03:/root# ls -l /proc/4935/ns/ | grep mnt
lrwxrwxrwx 1 root root 0 Jun 18 01:30 mnt -> mnt:[4026531840]

видим что разные.

если мы напишем не так

# unshare -m bash

а вот так

# unshare -m 

то это равнозначно. 
как я понимаю.
типа unshare он если ему неуказать какую прогу запускать то он клонирует тот процесс из котрого 
его запускают. а мы запускаем его из баша.

то есть 

# unshare -m bash  == # unshare -m 

итак unshare нам позволяет запустить программу и у нее получить неймспейсы отличные от сеанса
баша из которого мы запускаем unshare.
новыми могут быть все неймспейсы или часть. как нам хочется.

далее. двигаем еще ближе уже к mount неймспейсам.

если у нас есть два маунт неймспейса, и мы создадим в одном из них приватную точку монтирования
то в другом неймспейсе эта точка монтирования и все что вней будет невидно 
в другом mount спейсе.

здесь вылезли вот эти вот приватные точки монтирования. это отличается от того к чему
мы привыкли в сетевых неймспейсах.
в сетевых неймспейсах там по дефолту все сетевые карты одного неймспейса 
невидят все сетевые карты другого неймспейса.

в маунт неймспейсах несколько по другому.
мы изначально невсегда хотим полностью изолировать структуру список папок
и точек монтироавния которые видны одному процессу и другому процессу.

часто мы хоотим чтобы часть папок была видна в обоих неймспейсах
а часть чтоб была невидна. вобщем вся эта куралесица взаимосвязи видомости части папок
между разными неймспейсами делает маунт неймспейс несколько отличным от сетевого неймспейса
. там мы четко хотим чтобы карты одного полностью невидели карты другого.
так вот возвращаясь к маунт неймспейсам. поэтому появляются приватные точки монтирования,
расшаренные точки, мастер , слев.

будет шас это все смотреть.

берем две консоли баш. консоль-А и консоль-Б

вот что точно работает 

в консоли-Б делаем:

консоль-Б # unshare -m bash
консоль-Б # mkdir /mnt/02
консоль-Б # mount -n -o size=1m -t tmpfs tmpfs /mnt/02
консоль-Б # touch /mnt/02/petya.txt

в консоли-А пробуем увидеть папку /mnt/02 и файл /mnt/02/petya.txt

консоль-А # ls -1 /mnt
01
02

папка видна

консоль-А # ls -1 /mnt/02

а файл petya.txt невиден


строка mount -n -o size=1m -t tmpfs tmpfs /mnt/02
позволяет нам подмонтировать к папке не реальный физ диск а виртуальных RAM диск.

получается что в новом маунт неймспейсе мы создали папку.
в нее примонтировали типа диск.
таким образом папка стала точкой монтирования.
на этой точке монтиования мы создали файл. и он уже невиден в консоли-А.

важно подчеркнуть что вот эта вот невидимость работает только 
для точек монтирования. если мы в консоли-Б  создадим файл в простой
папке то консоль-А этот файл будет виден 

теперь надо разобраться 
что будет если в консоли А создать теперь точку монттирования. будут ли файлы 
в новой точке монтиоавния видны в консоли Б

разобрался - вот что я сделал в консоли-А

консоль-А # mkdir /mnt/A-01
консоль-А # mount -n -o size=1m -t tmpfs tmpfs /mnt/A-01
консоль-А # touch /mnt/A-01/A-01.txt

после этого в консоли-Б файла A-01.txt невидно.

~# ls -1 /mnt/A-01

получается что неважно кто кому там родитель.
имеем такое - что имеем два маунт неймспейса.

если в одном из них (любом) создаем точку монтирования , монтируем туда диск, создаем 
там файл то в другом маунт неймспейсе точка монтирования видна, но файлы на ней 
уже невидны.

откроем третью консоль-С. узнаем PID-ы консоли А и консоли Б.
с помощью nsenter войдем в mount спейсы этих консолей.
и проверим видимость папок. она должны быть в точности как только было выше.
таким образом мы проверим что мы умеем входит в маунт неймспейсы. 
что нам и нужно при работе с конейнерами а именно нам нужно видеть как изнвутри
контейнера выглядит его файловая система. а для этого надо научиться определять 
маунт неймспейс контейнера и входит в него.

консоль-А PID = 2706
консоль-Б PID = 4474


консоль-С # nsenter --mount=/proc/2706/ns/mnt ls -1 /mnt/02

консоль-С # nsenter --mount=/proc/2706/ns/mnt ls -1 /mnt/A-01
A-01.txt

(мы вошли в маунт спейс консоли А и увидели ровно то что должны были увидеть)



консоль-С # nsenter --mount=/proc/4474/ns/mnt ls -1 /mnt/02
petya.txt

консоль-С # nsenter --mount=/proc/4474/ns/mnt ls -1 /mnt/A-01

(мы вошли в маунт спейс консоли Б и увидели ровно то что должны были увидеть)


вывод - мы научились находит маунтспейсы процессов.
и научились видеть файловую систему так как ее видят процессы а ля в будущем контейнеры.

|||||||||||>>>>>>>далее:

*надо узнать как увидеть все точки монтирования. и все файлы на компе.
получается findmnt она покащывает только те точки монтирования которые лежат в нашем
маунт неймспейсе. например для консоли-А

# findmnt
└─/mnt/A-01                           tmpfs      tmpfs      rw,relatime,size=1024k

для консоли-Б
# findmnt
└─/mnt/02                             tmpfs      tmpfs      rw,relatime,size=1024k

то есть что логично - что разные маунт неймспейсы они невидят чужие точки монтирования.

а нам как root надо знать обо всех файлах и папках на системе.

ответ на этот вопрос: 
по первых для процесса $pid все точки монтирования что он видит
можно посмотреть в /proc/$pid/mounts

*также я тут сразу еще затрону родительские-дочерние маунт неймспейсы.
что чего как.
как я понял когда мы создаем новый маунт неймспейс то новый 
маунт неймспейс создается не из воздуха. новый неймспейс всегда как я понял
создается только на основе уже какогото существующего.
единственное что первый неймспейс создается с нуля.
так вот каждый маунт неймспейс он содержит список маунт поинтов.
так вот когда создается новый неймспейс как я уже сказал он создается
обязательно на основе уже другого существующего. так вот новый неймспейс получает от старого копию точек монтирования.
как я пока понял посмотреть какой неймспейс  у какого родитель 
нельзя. 
насколько я понял утилиты которая бы показывала список маунт неймспейсов
ее нет. есть lsns но она гавно. чтот показывает чтото нет.
самый прямой способ это просканировать /proc/**/ns/mnt
сравнить с дефолтным. и все что отличаются вывести списком.
далее зная "номер" маунт неймспейса можно через nsenter в него зайти 
и посмотреть что там есть в плане файловой системы. также если мы хотим  посмотреть только на список майнт поинтов то можно посмотреть в /proc/$pid/mounts. из этого  я делаю такой страншный вывод: утилиты 
которая бы показывала все маунт  неймспеймы на компе нет, увидеть какой 
маунт неймспейс родитель а какой ребенок нельзя, утилиты которая бы позволяла увидеть все файлы спрятанные на компе на всех маунт поинт неймспейсах нет. поэтому сделать поиск по всем маунт неймспейсам нельзя.
нужно брать писать скрипт который будет брат каждый процесс в /proc
брать его маунт неймспейс и сканировать файлы в нем. это жопа.
возникает вопрос. а если мы сидим в неймспейсе в котором часть /proc 
отрезана заблокирована. тогда мы понятия небудем иметь о том другом
майнт неймспейсе потому что иформацию о существовании другого неймспейса
мы черпаем из файловой системы /proc получилась рекурсия.
вот такой ответ на вопросы - как увидеть все файлы на компе во всех маунтнеймспейсах и как узнат кто родитель кто child между маунт неймспейсами. ответы на эти вопросы - никак. 

*shared private и прочие маунт неймспейсы. что за хрень.
точки монтирования в данном маунт неймспейсе могут быть - 
шаред
прайвет
слейв
анбиндабл

как нам узнать какое из этих свойств имеет некоторая 
точка монтирования

во первых надо узнать список всех точек монтирования 
для нашего маунт неймспейса

# cat /proc/$$/mounts

но тут непоказано какое свойство (шаред прайвэт слейв ) имеет точка
монтирования. это мжоно посмореть в другом месте

# cat /proc/$$/mountinfo

783 22 0:40 / /run/user/1000 rw,nosuid,nodev,relatime shared:142 - tmpfs tmpfs rw,size=204828k,mode=700,uid=1000,gid=1000

вот видно что /run/user/1000 точка монтирования 
имеет свойство shared

монтируем рамдиск в /mnt/01
# mount -t tmpfs -o size=1M tmpfs /mnt/01

смотрим какое свойство получила точка монтирования

~# cat /proc/$$/mountinfo | grep '/mnt/01'
849 24 0:189 / /mnt/01 rw,relatime shared:150 - tmpfs tmpfs rw,size=1024k

видим что shared

теперь очень важное дполенение - вот эти вот свойства точки 
монтирования - шаред прайвет слейв андиндабл они уже работают 
в рамках одного маунт неймспейса. то есть мы уже все это можем прочуствовать
посмотреть проверить в рамках того же самого одного маунт неймспейса.
необязательно задействовать еще один маунт неймспейс.

анбиндабл точка монтирования - это такая что ее нельзя
перемонтировать в другую папку с помощью mount --bind

# mkdir /mnt/02
# mount -t tmpfs -o size=2M tmpfs /mnt/02
# mount --make-unbindable /mnt/02
# cat /proc/self/mountinfo | grep '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime unbindable - tmpfs tmpfs rw,size=2048k

имеем аннбиндабл точку монтирования.

пробуем ее смонтировать в другую папку через --bind

# mkdir /mnt/03
# mount --bind /mnt/02 /mnt/03
mount: wrong fs type, bad option, bad superblock on /mnt/02,
       missing codepage or helper program, or other error

       In some cases useful info is found in syslog - try
       dmesg | tail or so.

неможем.
вот это и есть смысл свойства андиндабл
для точки монтирования

рассмотрим точку монтриования со свйоством прайвэт

# mount --make-private /mnt/02
root@test-kub-01:~# cat /proc/self/mountinfo | grep '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k

видим что вместо свойства прайвэт оно рисует '-'

пробуем биндануть такую точку монтироавния

~# mount --bind /mnt/02 /mnt/03
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/03'
1020 24 0:190 / /mnt/03 rw,relatime shared:152 - tmpfs tmpfs rw,size=2048k

успешно.

делаем что /mnt/03 оно тоже прайвэт

~# mount --make-private /mnt/03
root@test-kub-01:~#
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k
root@test-kub-01:~#
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/03'
1020 24 0:190 / /mnt/03 rw,relatime - tmpfs tmpfs rw,size=2048k

итак у нас /mnt/02 забинден на /mnt/03
и оба они прайвэт.

если я скопирую файл в любую из этих папок 
то файл будет виден в обоих папках.
так что покачто ничего нового и интересного.

создадим точку монтирования в кишках /mnt/02

# mkdir /mnt/02/A
root@test-kub-01:~#
root@test-kub-01:~# mount -t tmpfs -o size=2M tmpfs /mnt/02/A

копируем файл в /mnt/02/A

и он невиден в /mnt/03/...

создадим точку монтирования в кишках /mnt/03

~#  mkdir /mnt/03/B
# mount -t tmpfs -o size=2M tmpfs /mnt/03/B

копируем файл в /mnt/03/B

и он невиден в /mnt/02/...

таким образом. если у нас есть точка монтирования /mnt/02
она имеет свойство прайвэт, 
далее эту точку монтирования смонтировалив еще одну папку /mnt/03 через --bind

 то все  субточки монтирования в /mnt/02 например /mnt/02/A будут невидны
в другой папке /mnt/03

тоесть какбы флажок прайвеэт означает что изменнеия в точке монтирования
/mnt/02 небудут распостраняться на ее бинд клоны. клоны ничего об 
измненеия в /mnt/02 знать небудут. 

также важно понять (я прверил) что неважно когда была создана 
субточка монтирования внутри /mnt/02 дотого как на /mnt/02 натравили
--bind или после.  в обоих случаях в /mnt/03 субточки монтирования /mnt/02
будут невидны.

при этом в /mnt/03 будут видны все файлы самой папки /mnt/02
и если мы будем удалят добавлять файлыи папки в /mnt/02 то это все 
будет также обнволяться в /mnt/03
то есть вся эта котовасия с флажком прайвэт имеет силу не для самой точки 
монтирования /mnt/02 а для ее субточек монтирования.
это конечно дебилизм усложняет путаницу и добавляет сложности понимания
на пусто м месте.

витоге я бы сказал так - если точка монтиоавния имеет свойство 
прайвэт это значит что ее субточки монтиорвания будут видны только в самой
этой папке. и небудут видны в зеркалах которые созданы через --bind

таким образом флажок прайвэт делает субточки монтиорвания невидимыми
на зеркалах --bind

еще раз важно понять что сила свойство прайвэт отнсоится к субточкам
монтиоррования. содержимое же самое папки /mnt/02 будет отлично
видно на всех зеркалах --bind. 

окей.

итак у нас есть папка /mnt/02 
это точка монтиования.

она имеет флажой прайвэт.

и внутри этой папки есть куча подпапок которые являются субточками
монтирования.

так вот если мы сделаем зеркало /mnt/02 но с флагом --rbind 

# mount --rbind /mnt/02 /mnt/06

то в папке /mnt/06 будут видны все субточки монтирования.
то есть rbind полностью игнорирует свойство private

но! если мы после этого в /mnt/02 создадим +1 новую точку субмонтирования
то в /mnt/06 она уже небует видна.

жесть...

далее

свойство shared.
она обратное от прайвет
и оназнчает что все субточки монтирования в /mnt/02 также будут видны
будут появляться во всех зеркалах --bind
то есть изменененеия с субточками монтирования в /mnt/02 прилетают
во все зеркала --bind

получается анбиндэбл рассмотрели
прайвэт расмотрели
шаред рассмотрели

остался слейв.

если точка мониования имеет свойство слейв это значит что 
эта точка приимает информацию об изменения но не отправляет.
то есть принимать принимает. а отправляь неотправляет.

пример.

/mnt/02 = shared

/mnt/03 это --bind от /mnt/02 и 
/mnt/03 это слейв.

тогда если мы создадим субточку монтирования 

# mount -t tmpfs -o size=1M tmpfs /mnt/02/AA

то поскольку /mnt/02 = shared то /mnt/02 отправи информацию об этом 
во все зеркала
поскольку /mnt/03 = слейв то он примет эту информацию и будет видна 
субточка монтиорания /mnt/03/AA

а если мы создадим  

# mount -t tmpfs -o size=1M tmpfs /mnt/03/BB

то поскольку /mnt/03 это слейв он информцию о своей субточке 
монтиования /mnt/03/BB отсылать никуда небудет. поэтому в 
/mnt/02 небудет видна субточка /mnt/02/BB

опять же важно понять что вся эта фигня имеет отношение только  к субточками
монтирования а не к просто папкам. 
про просто папки можно забыть.

то есть если мы сосздаим просто папку /mnt/03/rrrr
то конечно она будет видна в /mnt/02/rrrr

потому что это прсто папки а не субточки монтирования.


далее прочитаем оф доку.
для этого прежде всего читаю - https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
прежде всего мы работает не с папками. мы работает с точками монтирования.
точка монтирования это базовая исходная основная единица с которой
мы и будем работать дальше.
также важно сказать что мы пока что вообще нетрогаем маунт неймспейсы.
это нас сейчас вообще неколышет.

прикольно что дока говорит о mounts и о mount points. в чем разница ???
дока постулирует что точку монтирования можно реплицировать (забиндить)
хоть на миллион других точек монтирования если исходная точка монтирования
имеет свойство shared. типа как хардлинки 
на жестких дисках

#  mkdir /01
   mount -n -o size=10M -t tmpfs tmpfs /01
   mount --make-shared /01
   mkdir /02
   mount --bind /01 /02
   

~# cat /proc/self/mountinfo | grep -E '/01|/02'

1101 24 0:194 / /01 rw,relatime shared:175 - tmpfs tmpfs rw,size=10240k
1103 24 0:194 / /02 rw,relatime shared:175 - tmpfs tmpfs rw,size=10240k

видно что и /01 и /02 = shared

делаем /02 = private

# mount --make-private  /02
1103 24 0:194 / /02 rw,relatime - tmpfs tmpfs rw,size=10240k

видно что если никакого слова нет. значит точка монтирования = private   
   
сделаем /02 обратно = шаред

# mount --make-shared /02

если в /01 положим файл /01/vasya.txt

то в /02 видим этот файл /02/vasya.txt

создадим субточку монтиования /01/A
положим в нее файл. 
сделаем /01/A прайвэт и посмотрим будет ли файл виден в /02

ответ  - да будет виден. 
в итоге я получил непонятнй результат. я создал кучу вложенных приватных
субточек монтирования в /01 и они все видны в /02. любая глубина вложенных
приватных субточек монтиования в /01 видна в /02
как бутто это значит что если /02 это миррор от /01 и если /01 = shared
то в /02 будет всегда при всех условиях видна полная структура /01







* родиелей для данной точки монтирования мржнро найти в
/proc/self/mountinfo
вообще надо научиться расшифровываааать все поля в /proc/self/mountinfo


* теперь надо понять   а какая же связт между 
свойством точки монтирования (шаред прайвэт слейв) и другим
маунт неймспейсом. это же как связь между красным и кислым.
нужно найти связь между совершенно разными вещами.

в исходном неймсейсе создаем точку монтирования

# mkdir /mnt/EE
# mount --bind /mnt/EE /mnt/EE
# cat /proc/self/mountinfo | grep '/mnt/EE'
1199 24 8:1 /mnt/EE /mnt/EE rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered



видно что точка монтирования создалась. и что ее тип шаред

создаем новый маунт неймспейс

~# unshare -m bash

проверяем. есть ли  в новом маунт неймспейсе эта же
точка монтирования

# cat /proc/self/mountinfo | grep '/mnt/EE'
1201 1099 8:1 /mnt/EE /mnt/EE rw,relatime - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered


видим что есть. 


~# findmnt -o +PROPAGATION | grep '/mnt/EE'
└─/mnt/EE                                                                                                        /dev/sda1[/mnt/EE]       ext4       rw,relatime,errors=remount-ro,data=ordered  private

причем тип этой точки монтирования в новом неймспейсе = private

интересно.

в исходном неймспейсе создадим +1 точку монтирования.

# mkdir /mnt/FF
# mount --bind /mnt/FF /mnt/FF
# cat /proc/self/mountinfo | grep '/mnt/FF'
1202 24 8:1 /mnt/FF /mnt/FF rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

в старом неймспейсе эта точка есть А ВОТ В НОВОМ НЕЙМСПЕЙСЕ
ЭТО ТОЧКИ МОНТИРОВАНИЯ НЕТ !!!

наверно потому что в исходном маунтспейсе для '/' установлено
свойство private

~# findmnt
TARGET                                SOURCE             FSTYPE     OPTIONS
/                                     /dev/sda1          ext4       rw,relatime,errors=remount-ro,data=ordered

(realtime означает что private)




щас мы это проверим.

\\\\вопросы - как влияет прайвеэт шаред у родительской точеки монтироавния
на видимость дочерней точки монтирования. то есть что побеждает
дочерняя настройка или родителтская.
как влияет что в разных неймспейсах на одну точку монтииования разные
выставолены свойства.\\\\\\\ <----------




в исходном неймспейсе поменяем для /mnt/DD тип с прайвэт 
на шаред.

# mount --make-shared /mnt/DD

# cat /proc/self/mountinfo | grep '/mnt/DD'
1096 24 8:1 /mnt/DD /mnt/DD rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

видим что /mnt/DD имеет тип shared


 








* непонятно как с помощью unshare создать новый процесс у которого
файловая система будет иметь корень в определенной папке.


* появляется вопрос. как определит кто у данного маунт неймспейса папа а 
кто у  него дети

* походу вот так - если мы имеем $PID контейнера.
то в /proc/$PID/mountinfo указано где он хранит свою файловую систему.




* про утилиту nsenter. из того что я уже понял про нее.
параметр -t у нее неработает. надо каждый неймспейс процесса смотреть отдельно, 
указывая путь к каждому типу неймспейса. то есть

хотим посмотреть что в сетевом неймспейсе тогда

# nsenter --net=/proc/$PID/ns/net команда

хотм посмтреть чтото в маунт неймспейсе тогда 

# nsenter --mount=/proc/$PID/ns/mnt команда

а вот такая штука нерботате и выводим полную галиматью

# nsenter -t $PID команда

а очень жаль. потому что хотелось бы сразу что nsenter всосал все неймспейсы процесса 
и чтоб команда отрабатыавала исходя сразу из всех неймспейсов процесса.


и вот наконец то получилось то что я хотел.

запускаем контейнер с ubuntu+bash

# docker run -ti ubuntu /bin/bash&
[1] 2805

root@test-kub-02:~# docker ps
CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES
1706b53a231c        ubuntu                 "/bin/bash"              3 seconds ago       Up 2 seconds                             musing_clarke

надо немногожко его доработать.
установим внутри этого котейнера iproute2 утилиты. иначе ip -c address show внутри контейнера
небудет работать.

# docker exec -it 1706b53a231c bash
(внутри контейнера)# apt-get update
(внутри контейнера)# apt-get install iproute2

готово. контейнер доработан. выходим из него.

далее. узнаем  PID контейнера

# docker inspect 1706b53a231c | grep -i pid
            "Pid": 2881,
            "PidMode": "",
            "PidsLimit": null,


теперь я хочу незаходя внутрь контейнера а используя неймспейсы и утилиту nsenter 
посмотреть как выглядит  сеетвые карточки внутри контейнера и его файловая система внутри
контейнера

# nsenter --net=/proc/2881/ns/net --mount=/proc/2881/ns/mnt ip -c address show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    inet 127.0.0.1/8 scope host lo
29: eth0@if30: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0

совершенно понятно что это сетевые карточки контейнра а не хоста.

далее. создаем на компе папку

root@test-kub-02:~# mkdir /mnt/host

root@test-kub-02:~# nsenter --net=/proc/2881/ns/net --mount=/proc/2881/ns/mnt ls -1 /mnt

изнутри контейнера она невидна. что логично. ибо фаловая система контейнера
отделена от фс хоста.

видно что nsenter корректно работает когда мы все неймспейсы указываем отдельно друг за другом.
тогда nsnenter их все учитывает.

а если я введу 

# nsenter -t 2881 команда

то утилита выведем фигню  а не инфо изнутри контейнера. к сожалению. баг какойто.
а было бы удобне указать только pid вместо вот этой вот длиннющей портянки со всеми неймспейсами.

по идеет ключ -t судя по ману должен как бы учитывать все неймспейсы процесса сразу

   -t, --target pid
              Specify a target process to get contexts from.  The paths to the contexts specified by pid are:

              /proc/pid/ns/mnt    the mount namespace
              /proc/pid/ns/uts    the UTS namespace
              /proc/pid/ns/ipc    the IPC namespace
              /proc/pid/ns/net    the network namespace
              /proc/pid/ns/pid    the PID namespace
              /proc/pid/ns/user   the user namespace
              /proc/pid/root      the root directory
              /proc/pid/cwd       the working directory respectively

но по факту этот ключ неработает.  достаточно провести такой эксперимент

# nsenter -t 2881  ip -c address show

и вместо сетевых карт внутри контейнера на экран вылезет списко сетевых карт хоста.
это ужасный баг nsenter.

далее.
прикольно то что мы "невлезаем" внутрь контейнера когда юзаем 

# nsenter .... bash

или 

# docker exec -it ... bash

мы на самом деле ( и это только сейчас теперь стало понятно )  запускаем 
в линуксе еще один 
процесс ( bash в данном случае ) который просто напросто входит в теже
 неймспейсы что и процесс
который типа контейнер.

то есть в линуксе нет никаких "контейнеров". есть процессы которые принадлежать тем или иным 
неймспейсам. если мы хотим "влезть" в тот или иной контейнер это значит что мы должны создать 
еще один процесс который входит в теже самые неймспейсы что и процесс на котором крутится 
контейнер. это как в папку положить к файлу соседний файл.

таким образом мы когда "залазиим " в контейнер мы в нем ничего ненарушаем. 
просто для определнного набора неймспейсов добялвется еще один процесс приаттаченый к ним.



* по идее имея PID процесса на котором крутится контейнер применяя знания про 
неймспейсы и утилиту nsenter можно "входить" внутрь контейнера и выполнять на нем
команды неиспользуя docker exec -it  загадочную команду.


надо теперь понять. как зная PID контейнера и используя  знания про неймспейсы
нам узнат куда примонтирована фс контейнера.


* надо разобраться связано ли это с понятими родиетелский маунт неймспейс. дочерний
майнт нейсмпейс.

* надо  разобраться как это свзяано с private shared состоянием точки монтирования.

* надо разобраться как одни итеже точки монтирования видны с разные неймспейсов.
с точки зрения командыfindmnt  findmnt -o TARGET,PROPAGATION 




\\\\\\[  этот кусок весь проработаь и осознать все моменты 

вот наконец пример как сделать свой mount неймспейс






mktemp - создтает файл или папку название которой автоматом рандомное и имеет 600 пермишн.
так что если мы создаем файл или папку заведомо временную то нам ненужно париться
насчет имени. и ненужно париться на счет chmod пермишенов.
то есть никакой загадки в работе этой команды нет. что она делает - 
она придумывает случайно имя. создает с ним файл или папку и дает ей перимшн 600
то есть только кокнретный юзер имеет к ней доступ. типа такая удобняшка и неболее того.




https://unix.stackexchange.com/questions/153665/per-process-private-file-system-mount-points

а вот еще проимер.

во первых - моунт неймспейсы работают с точками монтирования.
а не просто с папками.
но есть следущая фишка она позводяет простую папку превратить в точку монтиования

вначале удостоверимся что наша папка неявляется точкой монттрования

~ findmnt -o TARGET,PROPAGATION /tmp 

если эта папка неявляется точкой монтирования то в выводе будет пусто.

создадим из папки точку монтирования

# mount --bind /tmp /tmp

посмотрим что теперь стало

~# findmnt -o TARGET,PROPAGATION /tmp
TARGET PROPAGATION
/tmp   shared

во первых папка стала точкой монтироавния
во вторых тип точки монтирования видим что shared

если мы хотим создать новый моунт неймспейс нужно чтобы точка монтирования
была private

~# mount --make-private /tmp
root@test-kub-01:~# findmnt -o TARGET,PROPAGATION /tmp
TARGET PROPAGATION
/tmp   private

с этим порядок. точка монтиоавния стала приватной

# touch /tmp/20-00

также возникает вопрос  о том как узнать все mount namespaces.
потому что иначе у нас будут файлы которые невидно под рутом.


конец  зоны осознания]\\\\\\\\

nsenter - понять почему этот кусок говна покаывает соверщенно сетевые карты
когда мы суем ему -t pid
и коогда ему суем -net=file


