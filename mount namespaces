параллельная штука.

как я понял системный вызов fork() создает дочерний процесс.
это полноценный новый процесс со своим новым pid.
он полностью независим от родительского процесса.
он имеет например свое незавиимсое виртуальное адресное пространстов в памяти.
поэтому процессы в памяти дочернего процесса никак не влияют на память в родительсокм
процессе.просто на момент когда процесс только что отклонирован его содержимое памяти 
ровно такое же как у родителя. потому что в режиме на чтение идет отсылка к памяти родителя.
но все изменения идут уже в отдельнуд область памяти.

другой системный вызов clone() как я понял он используется для создания трэдов.
это значит что тред имеет общую вирт память с процессом.
тред неиммет своего нового pid.

далее.


через --bind можно смонтировать любой каталог параллельно в другой катало

# mount --bind /tmp/1 /tmp/2

далее про файловую структуру файловую иерархию выяснилась интереснейшая вещь.

вот это вот дерево папок


# ls -1 /
bin
boot
dev
esdata
es_snapshots
etc
home
initrd.img
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
snap
srv
sys
tmp
usr
var
vmlinuz

это сугубо виртуальная структура.
эта штука нигде напрямую на диске незаписана.

наш процесс обращается к линуксе - мол скажи мне а каков листинг папок.

линукс там у себя в требухе шуршит и выдает некий результат. 
он его нечитает напрямую с диска. это чисто плод  виртуального размышления ядра.

то есть линуксу ничего немешает одлному процессу выдать один список папок 
а другому другой.

список папок на диске незаписан в жетском виде так чтобы линукс его считал с диска 
и отдал напрямую.

например.

раздел /dev/sda2 может быть подмонтирован к /mnt а можно подмонтировать к /tmp/1

то есть это все результат манипулирования.

одному процессу линукс при желании может отдать один список папок 
а другому процессу другой список.

а значит мы можем играться с тем какая структура папок их иерархия должны быть 
отдана одному процессу а какая структура другому. это все виртуальная штука.
разные процессы могут получать разные списки списка папок.

нет ну кончено на конечных дисках есть файловая система на которой жестко 
прописана структура папок. но это типа исходный материал.
но нам ничего немешает налету показать вместо одной папки другую.

ведь алгоритм выглядит так  - мы запрашиваем листинг папок.

линукс смотрит на диск. получает списко папок а потом может в этом списке чтото
динамически поменять (не насамом диске и его ФС)а в уже полученном списке.

и уже этототредактированный список отдать процессу.

подмена понятий налету.

получатеся что структура папок , обьекты монтирования структура папочной системы
это сугубо виртуалная щтука с которой можно играться.

>>>>>>>

*далее. в линуксе есть точки монтирования.
и эти точки монтирования могут иметь свойства. - shared private
unbindable slave.
* важно понять что вот эти свойства прайвэт шаред итп для точек
монтирования они неимеют отношения к маунт неймспейсам. это изначально
свойства тупо точек монтирования. маунт спейсы вылезают и появляются
уже потом и отдельным манером. (хм.. разве? пока неуверен)

>>>>
что такое shared mount. это значит что данная точка монтироавния входит
в состав peer group с другими точками монтирования. 
что это дает. если создадим субточку монтирования у точки монтирования
то вновь созданная субточка монтирования будет видна во всех других
точках монтирования из пир группы.

скажем /mnt/vasya и /mnt/petya входят в пир группу.
если мы создадим /mnt/vasya/new то она будет видна также в /mnt/petya/new

замечу что сейчас я описываю видимые точки монтирования с точки зрения 
некоторого процесса. тоесть пока мы работаем в одном маунт неймспейсе.
про видимость в разных неймспейсах поговорим потом.

>>>>>
если маунт поинт имеет свойство слейв. значит она тоже входит в peer group
и новые субточки монтирования у участников пир группы видна и в нашей точки
монтирования. как это в случае выще.но если мы создадим субточку монтирования
в нашей слейв точке то эту субточку неувидят другие участники пир группы.
пример

/mnt/vasya - master
/mnt/petya - slave

создаем /mnt/vasya/01 субточку монтирования.
она будет видна в /mnt/petya/01

создаем субточку монтирования
/mnt/petya/02
она будет невидна в /mnt/vasya

и тут я хочу уточнить супер важную вещь.  чтобы создать субточку
монтирования /mnt/petya/02 нужно вначале создать банально
пустую папку /mnt/petya/02 и только когда мы имеем пустую папку
мы можем ее преобразовать в точку монтирования. так вот пустая
папка /mnt/petya/02 она будет видна в /mnt/vasya/02    а вот 
когда мы в нее смонтируем точку монтирования то содержимое папки 02
небудет видно в /mnt/vasya. папка /mnt/vasya/02 будет но пустая.
важно понять что у всех участьников пир группы неважно слейвы они 
или шаред или мастера  - у всех участников группы содержимое 
коренвого каталога будет совершенно одинаковое. любой файл или пустая
папка созданная у любого участника пир группы будет видно 
у всех других участников группы , но вот если мы в какотой то пустой
папке создаем субточку монтироавния то ее создержимое будет либо
небудет видно у других участников пир группы в зависимости 
от свойств (шаред слейв) точки монтироавния.
опять же повторю мы все рассматриваем сточки зрения ФС отдельного
процесса. в одном маунт неймспейсе.


точки монтирования которые не состоят ни в какой пир группе не принимают
от других точек монтирования инфо о новых субточках монтирования ни сами 
другим точкам не посылают инфо о своих новых субточках монтироавния называются
private ммаунт поинт. наверно это как бы классические точки монтирования
привычные со старых времен

есть еще unbindable mount - точки монтроавния которые нельзя  забиндить
через mount --bind

>>>>>>>>>>>>>

по умолчанию все обькты монтроания изначально private.
что логично.

вообще то несовсем так. 
обычно точка монтирования это же папка и она имеет некую вышестоящую папку
и наверное еще более важно что она имеет некую вышестоящую точку монтироавния.
и та выщестоящая точка монтироавния имеет свойство.
линукс так настроен что если головная точка монтирования имеет совйство
шаред то обычно и ее субточки монтироавния по умолчанию получают автоматом
свойство шаред.
правда я говорю о непостредственных точках субмонтироавния.
например / = shared
/mnt  - тоже получит шаред
а /mnt/vasya это уже не непосредственная субточка монтирования а более 
глубокого уровня и она не получит свойство шаред от корня. 

>>>>>>>>

вот так обьект монтирования делается из private в shared
# mount --make-shared <mount-object>

# mount --make-shared /

вот так делается slave обьект монтирования
# mount --make-slave /mount_point


две еще логичные команды
# mount --make-private <mount-object>

# mount --make-unbindable <mount-object>
>>>>>>>>>>>>>>>>>>>>>>>

что такое неймспейс. это некая структура (таблица или чтото типа того ) в оперативке
линукса. она больше нигде кроме как в оперативке нехранится. как только мы перезагружаемся
поскольку никаких записей на диске неостается то все неймспейсы исчезают. как и любая другая часть
лежащая только в оперативке.

далее.
оказыается есть просто неймспейсы
а есть persistent namespaces.

в чем их отличие.

персистент неймспейс  - к ним не приаттачен ни один процесс.
как это работает.
в оперативке создается неймспейс. но нам нужно получить идентификатор на него чтобы 
с ним можно было начать чтото делать.

обычно по классике неймспейс создается при создаии процесса и тогда ссылка на неймспейс
кладется в /proc/$PID/ns

если процесса нет. то как бы дефолтового места куда можно было бы положить ссылку на неймспейс нет.

то есть на самом деле дело всего лишь куда положит ссылку.
некоторые утилиты в них можно указать какой файл будет хранить ссылку на неймспейс в оперативке.
наверно точнее в файле будет ссылка на некий файл в /proc а проц это хитрожопая файловая система 
которая хитрожопо связана с оперативкой ядра.

таким образом например утилита unshare умеет создавать неймспейсы без создания процессов.
если ей указать в какой файл положить ссылку на созданный неймспейс . пример

# touch /root/ns-uts         
# unshare --uts=/root/ns-uts

файл ns-uts он пустой. 
и если ввести ls -1al тоо будет показано ничего. как бутто этот файл никуда неведет.
но должен же он как то кудато указыывать на чтото в памяти линукса чтобы через него 
можно было связаться с неймспейсом.

если мы сравним на то как выглядит ссылка на имя неймспейса для процесса

# ls -1al /proc/1/ns/
lrwxrwxrwx 1 root root 0 Jun 18 00:41 uts -> uts:[4026531838]

мы увидим что uts както там хитрожопо указывает на инод в proc фс.

но еще раз скажу в случае с /root/ns-uts такого мы не увидим

t# ls -1al /root
-r--r--r--  1 root root    0 Jun 18 00:34 uts-temp

как бутто просто пустой файл никуда неведущий.

это потому что наш файл нележит на proc фс. и  он нас связыаем с неймспейсом 
другим хитрожопым способом. он нас связывает с именем неймспейса через хитрожопую файловую
систему nsfs (NameSpaceFileSystem)

как это проерить

# mount | grep nsfs
nsfs on /root/uts-temp type nsfs (rw)

еще как проверить

# findmnt | grep nsfs
TARGET									SOURCE				 FSTYPE     OPTIONS
├─/root/uts-temp                      nsfs[uts:[4026532440]] nsfs       rw

nsfs это чисто програмистская линукс хрень.
с ней както там работают утилиты. а юзерам с ней напрямую неработать.
можно просто понимать что когда мы создаем неймспейс и сразу к нему привязываем процесс
то ссылка на неймспейс кладется в /proc/$PID/ns
и тут nsfs ненужен. как я понял .
когда мы создаем неймспейс без процесса то создается имя неймспейса сохранятеся в некоей
вирт фс nsfs и ссылка на nsfs файл (или что за хрень за хрень незнаю ) через опцию bind 
пробрасывается на обычный файл на диске.

увидеть эту связь этот проброс ( а есть ли у нас файлы на диске к которым сделан проброс
на nsfs ? ) можно через findmnt или mount

получается 
nsfs[uts:[4026532440]] 
это имя файла или инода или чего то там на nsfs где хранится имя неймспейса или ссылка на него вобщем
по этой херне линукс может его найти идентифицировать. но мы как юзеры с этой хренью работать неможем
поэтому линукс через mount и опцию bind сам автоматом создает связь между обычным файлом
/root/uts-temp и  nsfs[uts:[4026532440]]

таким образом если мы будем обращаться к /root/uts-temp в утилитах которые умеют работаь с неймспейсами
(типа nsenter) то эти утилиты смогут добратьсядо nsfs.

сам по себе файл /root/uts-temp на диске в форме байтов ( если мы вытащим диск вставим в другой комп
и посмотрим что же хранится там в этом файле). там ничего нехранится.

это система налету когда мы обращаемся к файлу фищическому она пробрасывает прозрачно 
туда в кишки nsfs.

вся эта хрень сделана чтобы поддерживать линукс концепцию что все структуры в линуксе это типа файлы.
просто мы привыкли что файл это кусок на диске.  а это более общее понятие.
это типа путь . по которому мы можем обратиться и попасть хрен знает куда. можем на диск
а можем и в памят ядра.

таким образом мы узнал что такое persistent неймспейс.
конешно после перезагрузки наш файл /root/uts-temp больше небудет 
никуда вести. потому что и неймспейс исчезнет при отключении компа. и связь уже небудет никуда вести.
потому что связь она незаписана на диске. это чисто линукс в памяти у себя держал такой хук.
мол если будут обращаться к такому то файлу то пробрасывать внутрь ядра.

то ест вот это слово persistent оно относится не к потере электричества и у нас все выжило.
оно относится к тому что процесса нет приаттаченного к неймспейсу а неймспейс при этом живет 
неуничтожается. вот смысл слова персистент.

>>>>>>>>>>>>>>>>>>>>>>>>
мельком взглянем на findmount

root@test-kub-03:/root# findmnt
TARGET                                SOURCE     FSTYPE     OPTIONS
/                                     /dev/sda1  ext4       rw,relatime,errors=remount-ro,data=ordered
├─/sys                                sysfs      sysfs      rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/security              securityfs securityfs rw,nosuid,nodev,noexec,relatime
│ ├─/sys/fs/cgroup                    tmpfs      tmpfs      ro,nosuid,nodev,noexec,mode=755
│ │ ├─/sys/fs/cgroup/systemd          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/lib/systemd/systemd-cgroups-agent,name=syste
│ │ ├─/sys/fs/cgroup/cpu,cpuacct      cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,cpu,cpuacct
│ │ ├─/sys/fs/cgroup/freezer          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,freezer
│ │ ├─/sys/fs/cgroup/net_cls,net_prio cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,net_cls,net_prio
│ │ ├─/sys/fs/cgroup/pids             cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,pids
│ │ ├─/sys/fs/cgroup/devices          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,devices
│ │ ├─/sys/fs/cgroup/hugetlb          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,hugetlb
│ │ ├─/sys/fs/cgroup/memory           cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,memory
│ │ ├─/sys/fs/cgroup/blkio            cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,blkio
│ │ ├─/sys/fs/cgroup/cpuset           cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,cpuset
│ │ └─/sys/fs/cgroup/perf_event       cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,perf_event
│ ├─/sys/fs/pstore                    pstore     pstore     rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/debug                 debugfs    debugfs    rw,relatime
│ └─/sys/fs/fuse/connections          fusectl    fusectl    rw,relatime
├─/proc                               proc       proc       rw,nosuid,nodev,noexec,relatime
│ └─/proc/sys/fs/binfmt_misc          systemd-1  autofs     rw,relatime,fd=36,pgrp=1,timeout=0,minproto=5,maxproto=5,direct
├─/dev                                udev       devtmpfs   rw,nosuid,relatime,size=1004076k,nr_inodes=251019,mode=755
│ ├─/dev/pts                          devpts     devpts     rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000
│ ├─/dev/shm                          tmpfs      tmpfs      rw,nosuid,nodev
│ ├─/dev/mqueue                       mqueue     mqueue     rw,relatime
│ └─/dev/hugepages                    hugetlbfs  hugetlbfs  rw,relatime
├─/run                                tmpfs      tmpfs      rw,nosuid,noexec,relatime,size=204828k,mode=755
│ ├─/run/lock                         tmpfs      tmpfs      rw,nosuid,nodev,noexec,relatime,size=5120k
│ └─/run/user/1000                    tmpfs      tmpfs      rw,nosuid,nodev,relatime,size=204828k,mode=700,uid=1000,gid=1000
├─/root/uts-temp                      nsfs[uts:[4026532440]]
│                                                nsfs       rw
├─/root/vasya                         /dev/sda1[/tmp]
│                                                ext4       rw,relatime,errors=remount-ro,data=ordered
└─/var/lib/lxcfs                      lxcfs      fuse.lxcfs rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other

если df -h покащзывает только классические точки монтирования

t# df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            981M     0  981M   0% /dev
tmpfs           201M   21M  180M  11% /run
/dev/sda1        20G   14G  5.1G  73% /
tmpfs          1001M     0 1001M   0% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs          1001M     0 1001M   0% /sys/fs/cgroup
tmpfs           201M     0  201M   0% /run/user/1000

то findmnt показывает их все.

например findmnt опзкаывает все бинды

например

├─/root/vasya                         /dev/sda1[/tmp]

то есть это значит что папка /tmp на /dev/sda1 она прибиндена в /root/vasya

поэтому я бы скзаал что findmnt это более расиренная и современная версия старого df -h

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
кратно скажу про sysfs и procfs. 
procfs более старая. 
sysfs более новая.

старая procfs неимеет четких правил че и как там держать.
новая sysfs имеет.

sysfs это как бы апргреженная и цивилизиированная версия procfs

однако невсе структуры програмитсы линукса будут переносить из procfs в sysfs.

изначально полтьзотвательсуие утилиты типа ps они лезли в /dev/mem и читали сырую память
типа того и оттуда находили инфо о процессах запущенных на компе.

вот чтобы эту фигню прекратить придумали procfs в которой информаци о процессах размещена
в виде папок и файлов.

тоесть изначально proc была придумана чтобы юзерские утилиты могли получать иформацию 
о процессах запущенных в удобной форме. то есть изначально это справочная по процессам.
потом ее функционал подрасширили.

>>>>>>>>>>>>>>>>>>>>>>
ладно. возвращаемся к неймспейсам.

 
насколько я понял . когда мы создаем неймспес и тут же к нему аттачим процесс.
то вот этот вот файл  /proc/[pid]/ns/[type] на proc он ведет конечно тоже на nsfs
то есть

t# ls -1al  /proc/1/ns
lrwxrwxrwx 1 root root 0 Jun 18 00:41 uts -> uts:[4026531838]

файл /proc/1/ns/uts он через биндинг ведет на nsfs к хрени по имени nsfs[4026531838]

а когда мы с помощью unshare 

# unshare --uts=/root/ns-uts

создаем неймспейс то с помощью биндинга nsfs [23423423] имя неймспейса пробрасывается на обычный файл на фс 
а не на proc файл. 

вот и весь механизм.
и когда у нас ссылка на неймспейс хранится в proc то в findmnt об этом нет никакого упоминания.
а когда у насс ссылка ведет на обычный файл на диске то тогда ссылка в findmnt появляется про nsfs

вот и вся разница между персистент и неперсистент неймсейсов.

если персистент - значит ссылка на его имя в nsfs  привязана (прибиндена) к файлу на диске
если неперсистент значит ссылка на имя неймспейса в nsfs привязана к файла на proc.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
ну и мол зачем нам перситсент неймспейсы. затем что мы хотим чтобы у нас были неймспейсы которые
неприязаны к конкретному процессу. ну и например был неймспейск нему был привязан процесс.
ссылка на имя неймспйса хранилась по пути /proc/$PID/ns/имя
когда процесс умер то папка /proc/$PID исчезает и мы теряем ссылку на неймспейс.
а может нам он еще нужен.
тогда если мы заранее сделаем биндинг на файл  в nsfs привяжем его к какому нибудь файлу на диске
то при уничтожении процесса мы ссылку на неймспейс непотеряем.

это как хардлинки на классической фс на файл. если  у нас есть 5 хардлинков то если мы удалим
все 5 то файл то на диске остался но связь с ним зацепка ниточка путь потерян. 
поэтому нужен хотя бы один хардлинк. тоже самое с именами неймспейсов.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
возвращаемся к mount неймспейсам

команда unshare.

по умолчанию когда мы в bash запускаем команду то она запускается ровно в тех же неймспейсах
что и сам bash сидит.

так вот unshare позволяет запустить программу у которой все или какие мы захотим неймспейсы
будут другими новыми отличными от тех которыми обладает исходный процесс bash

пример

смотрим какой PID имеет текущий сеанс bash

root@test-kub-03:/root# echo $$
4935

запускаем новый баш у котрого хотим чтобы mount неймспейс был другой

root@test-kub-03:/root# unshare -m bash

ключ -m означает что мы хотим mount неймспейс другой чем у родительского баша.

узнаем PID дочернего баша

root@test-kub-03:/root# echo $$
23369

смотрим какой "номер" mount неймспейса имеет родительский баш

root@test-kub-03:/root# ls -l /proc/23369/ns/ | grep mnt
lrwxrwxrwx 1 root root 0 Jun 18 01:30 mnt -> mnt:[4026532441]


смотрим какой "номер" mount неймспейса имеет дочерний баш 

root@test-kub-03:/root# ls -l /proc/4935/ns/ | grep mnt
lrwxrwxrwx 1 root root 0 Jun 18 01:30 mnt -> mnt:[4026531840]

видим что разные.

если мы напишем не так

# unshare -m bash

а вот так

# unshare -m 

то это равнозначно. 
как я понимаю.
типа unshare он если ему неуказать какую прогу запускать то он клонирует тот процесс из котрого 
его запускают. а мы запускаем его из баша.

то есть 

# unshare -m bash  == # unshare -m 

итак unshare нам позволяет запустить программу и у нее получить неймспейсы отличные от сеанса
баша из которого мы запускаем unshare.
новыми могут быть все неймспейсы или часть. как нам хочется.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
далее. двигаем еще ближе уже к mount неймспейсам.

маунт неймспейс это на самом деле список точек монтирования. и этот набор точек монтирования эта ФС она невидна другим точкам монтирования 
которые лежат в других маунт неймспейсам. (при желании могут быть частично
видны об этом далее). и получается мы можем делать чтобы какойто процесс
имел доступ к тому или этому маунт неймспейсу. опять же как я понял
процесс имеет единоразово доступ только к одному маунт неймспейсу.


мы привыкли в сетевых неймспейсах.
в сетевых неймспейсах там по дефолту все сетевые карты одного неймспейса 
невидят все сетевые карты другого неймспейса.

в маунт неймспейсах несколько по другому.
мы изначально невсегда хотим полностью изолировать 
точки монтироавния одного неймспейса от другого неймспейса таким образом
процесс который имеет доступ к одному маунт неймспейсу чтобы видел 
точку монтирования прнадлежащую другому маунт неймспейсу.
на самом деле как я понимаю точки монтирования они реально все 
разные индивиудальные в двух маунт неймспейсах. но мы можем установить
связь между точкой монтироавния одного маунт неймспейса и точкой монтирования
другого маунт неймспейса. таким образом изменнеия в точке монтирования 
одного неймспейса прилетит также к другой точке монтирования другого маунт
неймспейса. таким образом процессы разных маунт неймспейсов увидят 
одно и тоже но непотому что они имеют доступ к одной точке монтирования 
а потому что изменнеия одной точки монтирования прилетели к другой 
точке монтирования. 

часто мы хоотим /mnt  была видна в обоих неймспейсах. но этот /mnt
это будут разные точки монтирования в разных неймсейсах. просто между /mnt
одного неймспейса и /mnt другого неймспейса установлена связь.
но сами /mnt не одно и тоже а разные.

вобщем вся эта куралесица взаимосвязи видимости точек монтирования
между разными неймспейсами делает маунт неймспейс несколько отличным от сетевого неймспейса там мы четко хотим чтобы карты одного полностью невидели карты другого.

>>>>>>>>>>>>>>>>>>>>>>>>>>>
теперь переходим к важному моменту. про взаимосвязь свойств точек монтирования
shared slave private и маунт неймспейсами. ибо эта связь она замолчена перемешана запутана плохо очерчена и описана создавая кашу в голове.

маунт неймспейс это список точек монтирования. 
как я понимаю точка монтирования она всегда принадлежмт только одному
неймспейсу. точка монтироавния неможет принадлежать нескольким маунт
неймспейсам.

как создается маунт неймспейс. первый маунт неймспейс как то так создается
ядром линукса. (первый список первых точек монтирования).
но вот далее обычно происходит вот так - очередной новый маунт неймспейс создается как полная копия некоего исходного маунт неймспейса.
пример. исходный неймспейс содержит точки монтирования
/   (mnt Id =1) 
/dev (mnt Id =2)
/mnt (mnt Id =3)

каждая точка монтирования для ядра имеет номер.
мы создаем новый маунт неймспейс. и он будет содержать ровно тот же список
точек монтиорвания

/   (mnt Id =4)
/dev (mnt Id =5)
/mnt (mnt Id =6)

что это дает процессам , первый процесс подключен к первому неймспейсу.
второй процесс подкючен к втором неймспейсу. если мы в первом спейсе 
создаим новый файл в / то этот файл будет виден во втором неймспейсе в /.
если мы удалим файл во втором неймспейсе в / то он будет удален и во 
первом нейммспейсе в /.
тоесть работа с файлами и папками в точке монтирования в одном неймспейсе
абсолютно делает тоже самое в другом неймспейсе. список файлов и папок
в точке монтиования в обоих неймспейсах всегда одно и тоже.
получается и в чем прикол? где тут изоляция между неймспейсами.
действительно этот момент описан дебильно. во первых как я уже
сказал / в одном неймспейсе это совсем другая точка монтирования 
чем / в другом неймспейсе. и как видно с картинки номера у них разные.
(номер можно посмотреть в # mountinfo )
но! изоляция работает недля файлов и папок! с точки зрения файлов 
и папок ядро передает измененения между неймспейсами для одноименных
точек монтирования без проблем. тут никакой изоляции нет!
точки монтирования для ядра разные просто он передает между ними
изменения. так вот изоляция работает (ВНИМАНИЕ!) для новых субточек 
монтирования.

в первом неймспейсе в точке монтирования  / создаем папку

/vasya

так как это папка\файл то она будет видна и во втором неймспеейсе в /

/vasya

а теперь (внимание) в первом неймспейсе мы монтируем в /vasya диск
теперь /vasya это непросто папка это субточка монтироавния от /
так вот во втором неймспейсе внутри /vasya будет пусто. во втором неймспейсе
/vasya останется просто папкой. просто пустой папкой.
вот это и есть та самая сраная изоляция для точек монтирования
между разными маунт неймспейсами.! изоляция касается только субточек монтирования у точек монтирования но не файлов и просто папок.

еще раз заблуждения про маунт неймспейсы. заблужение что одноименные
точки монтироавния это одна и таже точка монтирования. это ложь. 
так кажется потому что изменнеия файлов и папок в одной точке видны 
в другой точке другого неймспейса. ну и типа раз "нет изоляции" то кажется что
это одна и таже точка монтирования. это не так.  у них разный mountt ID
. просто ядро переносит изменения в одной точке в другую.
также нет четкого понимания что изоляция касается только и только 
субточек монтирования.

и тут я иду дальше. вспоминимаем что мы создали новый неймспейс
на основе исходного неймспейса. 
так вот есть еще момент.
на момент копирования списка точек монтирования и присвоения 
им новых mount ID случается еще одна важная штука!
если точка монтирования в исходном неймспейсе имеет свойств SHARED
то откопировання новая точка монтирования в новом неймспейсе тоже 
полуается свойство shared и обе эти точки (исхоная из первого спейса 
и новая из второго спейса) добавляют в одну peer группу. что это дает.
peer группа структура в ядре. ей насрать на неймспейсы. для нее их нет.
и если создать субточку монтироавния у точки монтирования входящей в пир
группу то эта субточка монтироавния будет видна во всех других
точках монтирования членах пир группы. получим что субточка монтирования vasya в точке монтрования /mnt одного спейса будет видна в другой точке
монтирования /mnt другого неймспейса

/mnt/vasya (один неймспейс)  
/mnt/vasya (второй неймсейс)

таким макаром была налажена связь для субточек монтироавния между неймспейсами.  отметим еще раз что пир группа она вообще ничего незнает
про маунт неймспейсы. пир группы содержит как и маунт неймспейс 
список точек монтирования. такая между ними аналогия. но по сути
пир группа ничего незнает и не имеет никакой связи привязки к маунт
неймспейсам. она от этого полностью независима. 
пир группа работает очень просто. если у одного члена завелась субточка
то ее надо распостранить всем членам группы . ( и при этом насрать абсолютно
к каким маунт неймспейсам они относятся . )

так вот связь между маунт неймспейсами и shared свойством точки появляется 
только иза за того что при создании маунт неймспейса ядро линукса по своей
воле ( на основе шаред свойства другой точки монтирования ) заносит
новую точку монтирования в пир группу исходной точки. 
если бы ядро этого неделало тогда никакой связи между свойство shared
и маунт неймспейсами бы небыло вообще.

тоесть механизм довольно дурацкий а описан он вообще очень дебильно.

есть исходный неймспейс.
есть точка монтироавния / с mountid=1

мы создлаем нровый маунт неймспейс.
ядро создаем новую абсолютно независимуб точку монтирования / с новым
mount id  =2 

они типа независимы. совершенно разные сущности. но изменения с файлами
и папками в одной тут же видны в другой. (вот тебе и независимость).
и если исходлный / имел свойство shared ( а shared значит что / входит 
в некую пир группу) то новая точка / ядром также заносится в туже пир группу.
теперь оба / входят в одну пир группу. таким макаром две разные точки монти
рования из двух как получается разных неймспейсов оказыаются в одной пир группе. ну и как я сказал . новые субточки монтирования созданные у одного
участника пир группы тут же видны у всех участников пир группы.

вот такая дебилистика.

если исходная точка имела свойство private то новая одноименная точка в новом
неймспейсе будет тоже прайвэт. соотсветенно в плане субточек новых
между ними связи небудет.

очень важно понимать что неймспейсы работают не с папками а сточками 
монтироавния. что точки монтирования хотьи  имеют одни имена но являются
не одним и тем же а разным штуками. но между ними есть связь в плане
файло и впапок все прозрачно как бутто это одна и таже точка монтирования. а
вот изоляция работает на уровне субточек монттиорвания новых которые появляются уже после создания неймспейса

также ! есть важная подлянка. когда мы используем команду unshare
для создания нового маунт неймспейса то нужно также использовать СПЕЦ КЛЮЧ!
опцию в ней чтобы все работало как я описал. это тоже дебилистика.
без этой спец опции (смотри в man ) новый неймспейс будет создан
вообще нетак!. без опции unshare посрет на shared свойства исходных точек
и в новом неймспейсе новые точки ВСЕ АБСОЛЮТНО будут иметь свойства private
. с этим ятоже очень сильно прокололся промучался вначале непонимая
что же нетак

>>>>>>>>>>>>>>>>>
еще раз.
маунт нейимсппйсы это хуйня. потому что они делают то что ты ожидаешь.
их архитектура антилогична.

мы изначально хотим чтобы один процесс невидел файловую системы
другого процесса. чтоб изменения файлов и папок у одного процесса
никак не влияли на файлы и папки у другого процесса.

маунт неймспейсы это суки неделают.

во первых мы неможем создать маунт неймспейс с нуля.
мы неможем примонтировать диск и сказать процессу что теперь 
вот этот диск твоя корневая файловая система.  мы можем создать 
новый маунт неймсейс только из другого неймспейса. его копию.
значит у нас всегда будет копия /

когда мы создадим новый неймспейс то никакой изоляции между старыми
точками монтирования и новыми тоже небудет. все измененения  с файлами
и папками в первом неймспейсе будут видны во втором и наобоорот.
так что никакой изоляции не будет. толку от создания второго неймспейса ноль!

изоляция будет касаться только НОВЫХ СУБТОЧЕК МОНТИРОВАНИЯ.
вот  у нас есть в исходном спейсе /
мы создали новый неймспейс. тоже имеем /
изменеия в / любого неймспейса видны в другом неймспейсе.
и только если мы создадим новую субточку  /vasya то ее содержимое небудет
видлно  в другом неймспейсе.

очень странная архитектура.

вот сколько антилогичных и неудобных свойств имеют маунт неймспейс.
какото урод и инвалид.

итак еще раз новый неймспейс недает изоляцию на уровне текущих точек монтиования на уровне текущих файлов и папок. этого он ничего недаст.
с нуля неймсейс также несоздать. все что ондает это изоляция на уровне
новых субточек монтирования уже после создания неймспейса.

если мы хотим чтобы наш текущий / был индивидуальен и независит для двух
процессов то маунт неймспейс новый эту задачу вобще нерешит.

индивидувальными будут новые субточки монтирования с путями /NAME

итак что дает и как работает новый маунт неймспейс поняли. теперь хотим
чтобы некоторые субточки монтирования все таки тоже были видны в обоих
немспйсах. это работает вот как.
при создании неймспейса ядро берет каждую исходную точку монтиоравния 
и создает в новом неймспейсе такую же точку но с новым ID и если исходная точка  имеет свойство ШАРЕД то новая одноименная точка тоже получит свойство
ШАРЕД в той же peer group. 
что это дает - пир группы неимеют никакого отношения к маунт неймспейсам.
пир группам вообще насрать на неймспейсы. пир группы это тоже список 
точек монтирования также как неймспейс это срписок точек монтиоавания.
так вот если мы создаем субточку монтирования у одного члена пир группы
то эта точка будет видна во всех других членах. вот и все.

а как вообще в целом как засунуть точку монтирования в пир группу?
ответ - нормального способа нет. да в этом тоже жопа архитектуры.
просто так ты это несделаешь.точнее это легко сделать в рамках одного
маунт неймспейса.  сделать это можно через mount --bind.
а вот если у нас есть две точки монтирования в разных неймспейсах
то их никак вместе в одну группу незасунуть. нет. только при создании
неймспейса это автоматом делает ядро. и все. 
более того. положим у нас есть во втором спейсе точка входящая в пир 
группу . если мы эту точку сделаем приватной то после этого обратно 
ее вставимть в группу никак неполучится. вот такая дебильная необратимость.
опять же. если в этом спейсе есть другой член входящий в группу то можно 
вытянутую точку засунутть в mount --bind . но если в текущем спейсе 
больше нет члена той группы а все члены лежат в другом спейсе - все
сделать уже больше ничего нельзя.

оптья же это полный архитектурынй дебилизм.

опть же шаред правэт слейв эти свойства точки монтирования неимеюи
никакого отношения к маунт неймспейсам. абсолютно от них независят.
это просто включение точек монтирования в отделную некую группу.
когда мы включили точку монтрования в группу то все члены видят новые 
субточки монтирования соседей.

слейв точка монтироавния видит новые точки монтирования сосейдей но 
свои новые субточки она непоказывает соседям.

точка может быть одновременно шаред членом в одной пир группе и 
одноврременно быт слейв членом группы в другой пир группе.


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

перейдем к практике
проверим вот что.
создадим еще один маунт неймспейс.
причем при создании сделаем так чтобы ядро игнорировало
свойства исходных точек монтироавния (шаред слейв итп) и в новом нейм
спейсе чтобы все новые точк монтирования были только прайвеэт.
это даст то что новые субточки монтирования не будут состоять в пир группах
со старыми точкаи монтирования. и это даст то что новые субточки монтироавния
будут взаимно невидны между между немспейсами.

значит чтобы новый неймспейс посрал на шаред свойство точек монтирования
исходного неймспейса достаточно заюзать команду unshare -m bash
по дефолту она как раз так и делает.

раз точки монтирования в новом неймспейсе невходят в пир группы с точкмми 
монтироавния старого неймсейса то нам абсолютно насрать какие свойства
имели исхдные точки монтирования. нам было бы это важно и мы должны 
были бы это учитыать если бы мы заюзали unashare --propagation unchanged
тогда бы при создании нового неймспейса и новых точек монтироавния
ядро смотрело а какой флаг имела исходная точка монтироавния и если исходная 
имеет шаред то ее копия новая тоже полуала бы флаг шаред и они бы входили
в одну пир группу. и тогда бы новые субточки монтирования были бы видны
в обоих неймспейсах для данной пары точек монтироавния. 
поэтому так важно при созбании нового неймспейса четко понимать - 
мы будем игнорировать флаги в исходном неймспейсе или нет.
если будем игнорировать  то на флаги в ихсодном посрать. а если 
будем учитывать тогда перед тем как создавать новый неймспейс нужно
получить список точек монтироавния даннного неймспейса и посмотреть 
какие свойства они имеют cat /proc/self/mountinfo

берем две консоли баш. консоль-А и консоль-Б



в консоли-Б делаем:

консоль-Б # unshare -m bash

то есть мы создаем новый неймспейс и мы при этом срем на флаги 
исходных точек монтирования.

unshare -m bash аналогично команде unashare --propagation private

консоль-Б # mkdir /mnt/02
консоль-Б # mount -n -o size=1m -t tmpfs tmpfs /mnt/02
консоль-Б # touch /mnt/02/petya.txt



в консоли-А пробуем увидеть папку /mnt/02 и файл /mnt/02/petya.txt

консоль-А # ls -1 /mnt
01
02

папка видна

консоль-А # ls -1 /mnt/02

а файл petya.txt невиден

здесь мы видим что в другом неймспейсе новая папка видна 
а вот содержимое субточки невидно. все по теории.



теперь надо посмотреть 
что будет если в консоли А создать теперь точку монттирования. будут ли файлы 
в новой точке монтиоавния видны в консоли Б

разобрался - вот что я сделал в консоли-А

консоль-А # mkdir /mnt/A-01
консоль-А # mount -n -o size=1m -t tmpfs tmpfs /mnt/A-01
консоль-А # touch /mnt/A-01/A-01.txt

после этого в консоли-Б файла A-01.txt невидно.

~# ls -1 /mnt/A-01

итого новые субточки монтироавния взавимно невидны между 
маунт неймспейсами

при этом новые просто файлы и просто папки взаимно видны в обоих
немспейсах


это совпадает с теорией.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

откроем третью консоль-С. узнаем PID-ы консоли А и консоли Б.
с помощью nsenter войдем в mount спейсы этих консолей.
и проверим видимость папок. она должны быть в точности как только было выше.
таким образом мы проверим что мы умеем входит в маунт неймспейсы. 
что нам и нужно при работе с конейнерами а именно нам нужно видеть как изнвутри
контейнера выглядит его файловая система. а для этого надо научиться определять 
маунт неймспейс контейнера и входит в него.

консоль-А PID = 2706
консоль-Б PID = 4474


консоль-С # nsenter --mount=/proc/2706/ns/mnt ls -1 /mnt/02

консоль-С # nsenter --mount=/proc/2706/ns/mnt ls -1 /mnt/A-01
A-01.txt

(мы вошли в маунт спейс консоли А и увидели ровно то что должны были увидеть)



консоль-С # nsenter --mount=/proc/4474/ns/mnt ls -1 /mnt/02
petya.txt

консоль-С # nsenter --mount=/proc/4474/ns/mnt ls -1 /mnt/A-01

(мы вошли в маунт спейс консоли Б и увидели ровно то что должны были увидеть)


вывод - мы научились находит маунтспейсы процессов.
и научились видеть файловую систему так как ее видят процессы а ля в будущем контейнеры.

|||||||||||>>>>>>>далее:

*надо узнать как увидеть все точки монтирования. и все файлы на компе.
получается findmnt она покащывает только те точки монтирования которые лежат в нашем
маунт неймспейсе. например для консоли-А

# findmnt
└─/mnt/A-01                           tmpfs      tmpfs      rw,relatime,size=1024k

для консоли-Б
# findmnt
└─/mnt/02                             tmpfs      tmpfs      rw,relatime,size=1024k

то есть что логично - что разные маунт неймспейсы они невидят чужие точки монтирования.

а нам как root надо знать обо всех файлах и папках на системе.

ответ на этот вопрос: 
во первых для процесса $pid все точки монтирования что он видит
можно посмотреть в /proc/$pid/mounts


>>>>>>>>>>>>>>>>>>>>>
(это отработать позже)
*также я тут сразу еще затрону родительские-дочерние маунт неймспейсы.
что чего как.
как я понял когда мы создаем новый маунт неймспейс то новый 
маунт неймспейс создается не из воздуха. новый неймспейс всегда как я понял
создается только на основе уже какогото существующего.
единственное что первый неймспейс создается с нуля.
так вот каждый маунт неймспейс он содержит список маунт поинтов.
так вот когда создается новый неймспейс как я уже сказал он создается
обязательно на основе уже другого существующего. так вот новый неймспейс получает от старого копию точек монтирования.
как я пока понял посмотреть какой неймспейс  у какого родитель 
нельзя. 
насколько я понял утилиты которая бы показывала список маунт неймспейсов
ее нет. есть lsns но она гавно. чтот показывает чтото нет.
самый прямой способ это просканировать /proc/**/ns/mnt
сравнить с дефолтным. и все что отличаются вывести списком.
далее зная "номер" маунт неймспейса можно через nsenter в него зайти 
и посмотреть что там есть в плане файловой системы. также если мы хотим  посмотреть только на список майнт поинтов то можно посмотреть в /proc/$pid/mounts. из этого  я делаю такой страншный вывод: утилиты 
которая бы показывала все маунт  неймспеймы на компе нет, увидеть какой 
маунт неймспейс родитель а какой ребенок нельзя, утилиты которая бы позволяла увидеть все файлы спрятанные на компе на всех маунт поинт неймспейсах нет. поэтому сделать поиск по всем маунт неймспейсам нельзя.
нужно брать писать скрипт который будет брат каждый процесс в /proc
брать его маунт неймспейс и сканировать файлы в нем. это жопа.
возникает вопрос. а если мы сидим в неймспейсе в котором часть /proc 
отрезана заблокирована. тогда мы понятия небудем иметь о том другом
майнт неймспейсе потому что иформацию о существовании другого неймспейса
мы черпаем из файловой системы /proc получилась рекурсия.
вот такой ответ на вопросы - как увидеть все файлы на компе во всех маунтнеймспейсах и как узнат кто родитель кто child между маунт неймспейсами. ответы на эти вопросы - никак. 
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

*shared private и свойства точек монтирования.
точки монтирования в данном маунт неймспейсе могут быть - 
шаред
прайвет
слейв
анбиндабл

как нам узнать какое из этих свойств имеет некоторая 
точка монтирования

во первых надо узнать список всех точек монтирования 
для нашего маунт неймспейса

# cat /proc/$$/mounts

но тут непоказано какое свойство (шаред прайвэт слейв ) имеет точка
монтирования. это мжоно посмореть в другом месте

# cat /proc/$$/mountinfo

783 22 0:40 / /run/user/1000 rw,nosuid,nodev,relatime shared:142 - tmpfs tmpfs rw,size=204828k,mode=700,uid=1000,gid=1000

вот видно что /run/user/1000 точка монтирования 
имеет свойство shared

монтируем рамдиск в /mnt/01
# mount -t tmpfs -o size=1M tmpfs /mnt/01

смотрим какое свойство получила точка монтирования

~# cat /proc/$$/mountinfo | grep '/mnt/01'
849 24 0:189 / /mnt/01 rw,relatime shared:150 - tmpfs tmpfs rw,size=1024k

видим что shared

теперь очень важное дполенение - вот эти вот свойства точки 
монтирования - шаред прайвет слейв андиндабл они уже работают 
в рамках одного маунт неймспейса. то есть мы уже все это можем прочуствовать
посмотреть проверить в рамках того же самого одного маунт неймспейса.
необязательно задействовать еще один маунт неймспейс.
естественно! потому что шарел слейв итп неимеет отношения к неймспесам вообще

анбиндабл точка монтирования - это такая что ее нельзя
перемонтировать в другую папку с помощью mount --bind

# mkdir /mnt/02
# mount -t tmpfs -o size=2M tmpfs /mnt/02
# mount --make-unbindable /mnt/02
# cat /proc/self/mountinfo | grep '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime unbindable - tmpfs tmpfs rw,size=2048k


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
имеем аннбиндабл точку монтирования.

пробуем ее смонтировать в другую папку через --bind

# mkdir /mnt/03
# mount --bind /mnt/02 /mnt/03
mount: wrong fs type, bad option, bad superblock on /mnt/02,
       missing codepage or helper program, or other error

       In some cases useful info is found in syslog - try
       dmesg | tail or so.

неможем.
вот это и есть смысл свойства андиндабл
для точки монтирования


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

рассмотрим точку монтриования со свйоством прайвэт
изаодно рассмотрим как работает --bind

# mount --make-private /mnt/02
root@test-kub-01:~# cat /proc/self/mountinfo | grep '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k

видим что вместо свойства прайвэт оно рисует '-'

пробуем биндануть такую точку монтироавния

~# mount --bind /mnt/02 /mnt/03
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/03'
1020 24 0:190 / /mnt/03 rw,relatime shared:152 - tmpfs tmpfs rw,size=2048k

успешно.

сразу возникает куча вопросов по поводу того как работает --bind
во первых: как найти все бинды. оказывается найти просто.
если два маунт поинта являются биндами то у них обязательно один и 
тот же бекенд устройство.
в нашем случае бекенд устройство = 0:190
таким образом если мы имеем какую то точку монтирования например корень.
смотрим какой у него бекенд на уровне major:minor

# cat /proc/self/mountinfo | grep -E 'sda'
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

видим что у корня major:minor бекенда = 8:1
значит если корень еще кудато забинден то он обязан иметь тот же бекенд 8:1

~# cat /proc/self/mountinfo | grep -E '8:1 '
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered
374 24 8:1 / /mnt/14 rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

таким образом мы нашли забинденый маунт поинт в /mnt/14

прикольно то что маунтится не корень. ибо корень это куда мы маунтим а
маунтится некий бекенд. в данном случае это /dev/sda1

итак искать все бинды какогото конкретного маунт поинта мы научились.

возврашаемся к исходной теме. и возникает вопрос почему /mnt/03
который получился путем биндинга из /mnt/02 является shared:152 в то время
как исходный /mnt/02 = private. также непонятно с чем он шаред. какие 
еще точки монтирования входят в пир группу 152.
я поискал больше никаких маунтов в группу 152 невходит

# cat /proc/self/mountinfo | grep -E 'shared:152'
372 24 0:96 / /mnt/11 rw,relatime shared:152 - tmpfs tmpfs rw,size=2048k


походу я нащупал откуда берется shared:152.

я создал точку монтирования 

~# mkdir /mnt/1-A-0
# mount -n -o size=10M -t tmpfs tmpfs /mnt/1-A-0/

# cat /proc/self/mountinfo | grep "1-A-0 "
376 24 0:99 / /mnt/1-A-0 rw,relatime shared:112 - tmpfs tmpfs rw,size=10240k

как видим по умолчанию она получилась shared:112

вобще я читал что когда мы создаем точку монтрования то линуксу также
надо знать какоой ее делать шаред приват слейв итп.
и как я понял если вышестоящая точка монтироавния имеет некоторое свойство
то ровно такое же получает и наша точка.
странно то что вышестоящая точка монтирования это / и она шаред 
но в пир группа у нее другая

24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

тем не менее мы имеем что имеем. 
также я ненашел больше никаких точек монтирования shared:112

ладно. далее мы делаем из /mnt/1-A-0 приватную точку

# mount --make-private /mnt/1-A-0/

# cat /proc/self/mountinfo | grep "1-A-0 "
376 24 0:99 / /mnt/1-A-0 rw,relatime - tmpfs tmpfs rw,size=10240k

далее мы биндим 1-A-0 

# mount --bind /mnt/1-A-0  /mnt/1-A-0-binded/

# cat /proc/self/mountinfo | grep "1-A-0 "
376 24 0:99 / /mnt/1-A-0 rw,relatime - tmpfs tmpfs rw,size=10240k
377 374 0:99 / /mnt/14/mnt/1-A-0 rw,relatime shared:112 - tmpfs tmpfs rw,size=10240k

и мы видим что несмотря на то что исходная точка монтирования 
праивэт ее забинденная точка монтироавния = shared:112

из чего я делаю повтор вывода о том что бинд это просто некий автоматизатор
ручной работы а именно бинд он просто напросто определеяет бекенд
который стоит за точкой монтирования а потом ядро исходная точка 
монтироавния абсолютно неволнует. далее ядро создает из бекенда
абсолютно незавиисимую точку монтииования в том числе ядро несмотрит
какое свойство имела исходная точка. на это ядру плевать. 
ядро смотрит куда то туда куда оно смотрело при создании изначальной
1-A-0 когдда оно у нас стало shared:112

поэтому глубоко ощшибокчно считать что забнденные точки монтироавния 
они связаны. это так только в форме файлов и папок. 
а с точки зрения субточек монттироавния свойств шаред прайвэт
это абсолютно другая независимая точка монтирования . их обьединяет
только один обший бекенд. но как мы уже знаем в плане субточек монтиоавния
нам глубоко посрать на бекенд и его физическую структуру папок файлов.




как вобще работает бинд. с ним нет никакой магии.
мы могли бы найти из mountinfo какой бекенд в форме /dev/... скрвыается 
за точкой монтирования по пути /. обнаружить что это /dev/sda1

# cat /proc/self/mountinfo | grep -E 'sda'
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

и потом руками этот /dev/sda1 примаунтить в по еще одному пути типа
# mount -t ext4 /dev/sda1 /mnt/new

и мы получили бы ручной аналог команды bind. вот и все. а mount --bind 
просто нам позволяет избежать ручной работы и сделать ее более автомати
ческой. исходя из этого обе точки монтироавния / и /mnt/new
они абсолютно незавиисимы. просто имеюти один бекенд /dev/sda1.

но для точек монтирования это абсолютно похер что у них один бекенд
или он разный. все точки монтиования абсолютино независимы
друг от дурга и никому ничего недолжны. 
конечно если мы внесем изменения в файловую систему на самом бекенде
через один путь монтирования то это изменение будет видно по всем 
другим путям монтирования которые имеют этот же бекенд.
создали файл /1.txt он также будлет виден через путь /mnt/new/1.txt
точки монтиироавния незавиисимы просто они читают из одного бекенда.
поэтому изменения видны через все пути.
но! что касается создания новых точек субмонтирования  - а это самая центральная тема с точки зрения точки монтирования. тут мы имеем совсем
друнгую ситуацию.  если мы создаем субточку монтироавния в некоторрой
точке монтрования то эта субточка монтирования будет видна в другой 
точке монтирования ТОЛЬКО если эти обе точки монттироавния входят в одну 
пир группу и АБСОЛЮТНО при этом насрать что у них один бекенд.
пример как раз на основе того что мы только что сделали

root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/03'
1020 24 0:190 / /mnt/03 rw,relatime shared:152 - tmpfs tmpfs rw,size=2048k

вот у нас есть /mnt/02
и /mnt/03
две точки монтирования с одним бекендом. вторую мы получили из первой путем
биндинга.
так вот как видно из свойств этих точек первая = прайвэт
вторая = шаред. сотвествнно они обе НЕВХОДЯТ в одну пир группу.
это значит что если мы создадим субточку монтирования в /mnt/02/A
она небудет видна через /mnt/03/A
и если мы создалим субточку монтииорвания в /mnt/03/B она небует видна в
/mnt/02/B и абсолютно похеру что вторая являтеся биндом первой что у них
один бекенд. это все неважно. важно только то что они невходят в одну
пир группу. 
опять же важно понимать что субточки монтирования это сугубо виртуальная 
штука которая изменнеий на файловую структуру бекенда никакой не несет
поэтому это все работает ничего неломает ненарушает. есть реальный бекенд
файло и папок которые физический записаны на диски. а есть просто 
виртуальная хрень путь к этому бекенду назыаваемый точка монтирования
которые нигде кроме памяти невисит.
вот такая вот важная тонкая вещь про точки монтироавния, про то как рабтает
бинд, про видимость субточек монтирванния, про то как бинд создает 
новую точку монтиоавния, какое свойство он ей устанавливает.  

>>>>>>>>>>>>>>>>>>>>>>>>

также в man mount написано что если 
мы создаем новую точку монтрования через --bind
то новая точка монтирования небудет содержать субточки монтиррования
исходной точки монтирования.
если мы хотим через bind получить вообще всю подноготноую со всеми
суюточками монтирования в новый путь нужно использовать 

# mount --rbind

пример у нас есть папка /mnt/02 
это точка монтиования.

и внутри этой папки есть куча подпапок которые являются субточками
монтирования.

так вот если мы сделаем зеркало /mnt/02 но с флагом --rbind 

# mount --rbind /mnt/02 /mnt/06

то в папке /mnt/06 будут видны все субточки монтирования.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>>>>>>>> остановился здесь !

свойство shared.
она обратное от прайвет

если приват точка никому непосылает инфо о своих новых субточках
и не принимает ни от кого то шаред точка она и принимает и посылает эту инфо
всем членам своей пир группы.

>>>>>>>>>>>>>>>>>>>>>>
получается анбиндэбл рассмотрели
прайвэт расмотрели
шаред рассмотрели

остался слейв.

если точка мониования имеет свойство слейв это значит что 
эта точка приимает информацию об изменения но не отправляет в своей пир группе.
то есть принимать принимает. а отправляь неотправляет.

пример.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
>>>>>>>>>>>>> остановился здесь!
далее прочитаем оф доку.
для этого прежде всего читаю - https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
прежде всего мы работает не с папками. мы работает с точками монтирования.
точка монтирования это базовая исходная основная единица с которой
мы и будем работать дальше.

прикольно что дока говорит о mounts и о mount points. в чем разница ???


#  mkdir /01
   mount -n -o size=10M -t tmpfs tmpfs /01
  
  1101 24 0:194 / /01 rw,relatime shared:175 - tmpfs tmpfs rw,size=10240k
  
  насколько я теперь понял зачастую при создании моунт поинта
линукс автомтом его делает шаред. 
а раз он шаред то должен входить в какуюто пир группу.
а так как это новый шаред то линукс СОЗДАЕТ НОВУЮ ПИР ГРУППУ! в данном 
случае 175. вот и обьяснение почему больше нет членов пир группы 175
  пртичем возможно даже он делает пир группу для бекенда 0:194
  а не для пути /01 потому что если мы сделаем /01 приватным
  но забиндим его в /02 то /02 будет shared:175 он же это берет 
  не от /01 а от именно походу свойств БЕКЕНДА 0:99!
  
   mkdir /02
   mount --bind /01 /02
   

~# cat /proc/self/mountinfo | grep -E '/01|/02'

1101 24 0:194 / /01 rw,relatime shared:175 - tmpfs tmpfs rw,size=10240k
1103 24 0:194 / /02 rw,relatime shared:175 - tmpfs tmpfs rw,size=10240k

вот этот shared:175 он создался когда мы маунтили /01 так
как он был первым его членом!

кстати удобно смотреть какой major:minor бекенда принадлежит 
какому физ диску через lsblk

root@test-kub-02:/# lsblk --all --fs
NAME   FSTYPE LABEL UUID                                 MOUNTPOINT
sda
└─sda1 ext4         9b206c59-f120-41e8-ad2a-d4ef7ea1e064 /mnt/14
sdb
└─sdb1 ext4         e5bcc257-d55e-451e-9c0c-51c7d5ab9523 /mnt/disks/vdb1
sdc
loop0
loop1
loop2
loop3
loop4
loop5
loop6
loop7


жалко что он не все бекенды показывает например наш 0:99 непоказывает

есть еще полезная штука

/# blkid
/dev/sda1: UUID="9b206c59-f120-41e8-ad2a-d4ef7ea1e064" TYPE="ext4" PARTUUID="559a02c9-01"
/dev/sdb1: UUID="e5bcc257-d55e-451e-9c0c-51c7d5ab9523" TYPE="ext4" PARTUUID="47e317e9-8750-4e19-b95f-1afebd10f80c"

я посмотрел. к сожалению mount не умеет монтироватть на основке major:minor
максимум она может на основе UUID

# mount --uuid 9b206c59-f120-41e8-ad2a-d4ef7ea1e064 /mnt/01
root@test-kub-02:/#

uudi назначется автоматом партишену ядром.

а еще часто ФС позволяет руками прописать партишену LABEL
(uudi это то что система назначает партишену а label это
то что мы можем сами назначить\изменить)

метода нанесения лейбела зависит от ФС. 
и делается утилитами от ФС.
непример для ext3\ext4

# tune2fs -L ROOT_PARTITION /dev/sda1

посмотреть его можно через 

# lsblk -f

так вот mount умеет монтировать партишены через этот LABEL

# mount --label ROOT_PARTITION /mnt/02

возвращшаемся к основному вопросу

видно что и /01 и /02 = shared

делаем /02 = private

# mount --make-private  /02
1103 24 0:194 / /02 rw,relatime - tmpfs tmpfs rw,size=10240k

видно что если никакого слова нет. значит точка монтирования = private   
   
сделаем /02 обратно = шаред

как только мы делаем обратно шаред у /02 уже будет не так 
шаред группа что у /01 нет-нет-нет. у него будет своя. 
и теперь /01 и /02 в разных шаред группах 
и друг с другом несвязаны. а значит субточки монтирования новые
друг дружки они видет не будут !

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

есть процесс.

# echo $$

можно посмотреть какой маунт неймспейс подключен
к этому процессу

root@test-kub-02:~# ls -1al  /proc/$$/ns
lrwxrwxrwx 1 root root 0 Jul 24 16:45 mnt -> mnt:[4026531840]

врзникают вопросы:
1)а что к процессу может быть подключен только один маунт неймспейс?

ответ - я думаю да.

2) а какая связь между точками монтирования и маунт неймспейсом

а связь такая. маунт спейс это всего навсего список точек 
монтирования.и этот список можно лепить к процессу.

берем строку из /proc/$$/mountinfo
>>>>>>>>> остановися здесь
18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw

18 =  номер маунта.  mount ID этой точки монтирования.
 
я вообще нифига ненашел что это и как это использовать.
в man proc сказано 
mount ID: unique identifier of the mount (may be reused after umount(2)).
я вообще ненашел ничего ни в man mount ни в man umount
про это

24 = ID родительского mount 

эти цифры пока что остаются загадкой.
родительсктй маунт это пока неясно и оставим

0:17 = это обозначение бекенда в виде major:minor чисел.
мажор относится к "номеру" драйвера который обслуживает бекенд.
минор нумерует однотипные усройства которые висят на драйвере с
номером major. то есть минор число используется чтобы драйвер 
различал устройства которые он обслуживает

/ =  root of the mount within the filesystem. что это такое тоже непонятно
я посмотрел на живой системе этот столбик всегда = /

shared:7 = это озгначает что данная точка монтирования входит
в  peer группу с номером 7.


маунт неймспейс это множество маунтпоинтов

получается что то что мы видим в /proc/pid/mountinfo - это список маунтпоинтов
которые составляют вот этот маунт неймспейс /proc/pid/ns/mnt


новый неймспейс создается путем копирования исходных маунтпоинтов но
им назначаются новые mount-id 

написано что каждый маунт неймспейс принадлежит некоторому юзер неймспейсу

пишут что маунт неймспейс и пир группа неодноитоже
и это понятно. оба являются списком точек монтирования 
но их цель разная.

значит в маунт неймспейсе событьия которые могут происходить с
маунт поинтами это всего навсего - либо новый маунт поинт создался
либо маунт поинт был уничтожен. вот ивсе.

значит если маунт поинт имеет свойство SHARED то как я понял 
если внутри этого маунт поинта создается или уничтожается суб-моунт-поинт
то точно такое действие происходит во всех других маунт поинтах
которые входят в одну пир группу с нашим маунт поинтом.


получается конечно тупая замудреная система. есть маунт спейс. в нем
список точек монтирования.
берем несколько точек монтирования. обьединяем их в пир группу.
при этом пир группа на самом деле вообще независит ни от какого
маунт неймспейса
далее берем одну из точек монтирования в пир группе.   далее создаем субточку монтирования в этой точке 
монтирования и наступает наконец самое главное - информация о том что была
создана субточка монтирования распостраняется на все точки монтирования в пир
группе при этом абсолютно неважно в каком маунт неймспейсе сидит тот 
или иной член пир группы действие проникает на все члены в любой маунт
неймспейсе. точка монтирования может входить в пир группу либо на роли
shared либьо на роли slave.
если точка имеет шаред то она отсылает ифо о своих субточках новых
и принимает инфо от других об их новых субточках.
если точка SLAVE то она принимает но не отсылает.

следущее свойство маунт точки = PRIVATE. если точка монтирования
имеет это свойство то точка монтиования невходит нив какую пир группу
и события внутри этой точки монтирования невылетают наружу другим точкам
монтирования. и события о новых субточках монтирования в других
точкам монтирования в эту точку монтирования неприлетают.
такая классическая автономная точка монтирования.

точка-А (входит в пир группу-А как полноценный член shared).
точка-Б (входит в  пир группу-А как слейв)
точка-Б (также вхдодит в пир группу-Б как shared)
точка-С (вхдоит в пир группу-Б как shared).

тогда событие в точке-А прилетит в точку-Б
а вот событие в точке-Б неприлетит в точку-А
событие в точке-Б прилетит в точку-С

точка может иметь свойтсво UNBINDABLE. это тоже самое что и PRIVATE
но плюс  к этому ее нельзя смонтировать через mount --bind

остается вопрос. первое как создавать пир группы.

как только мы создаем новую шаред точку ядро создает новую пир 
группу и вклчает нашу точку в эту пир группу.
чтобы добавить другую точку в эту пир группу надо использовать --bind
это пожалуй единственный прямой явный способ добавить точку в пир группу в рамках одного маунт неймспейса. если мы хотим добавит в пир группу точку
которая лежит в другом маунт неймспейсе то сделать это невозможно. 
единственное что возможно вот что - когда создается новый неймспейс Б на 
основе неймспейса А и при этом скажем в команде unshare мы еще и ключ
должны использовать дополнттельный --propagate unchanged тогда ядро 
при создании новой точки монтирования из исходной проверяет имеет 
ли исходная точка свойство ШАРЕД и если да то новая точка тоже будет 
ШАРЕД и входить в ту же пир группу.
вот и все способы добавление точки в существующую пир группу. 


еще вопрос
и как летают события между точками которые сидят в разных
маунт неймспейсах но в одной пир группе.
ответ - летают отлично. им насрать на то в каком неймспейсе 
сидит точка. главное чтобы точки сидели в одной пир группе

>>>>>>>>>>>>>>>>>>>>>>>>
далее написано что вот эта вся байда с событиями верна только для субточек монтирования которые лежат ровно на один уровень ниже нашей точки монтирования.


пример

точка монтиоврания = /mnt/01
ее субточки монтиования первого уровня = /mnt/01/A, /mnt/01/B
только информация о них (создания и уничтожение) будет передваваться 
пир членам. события о точках монтиирования более глубокого залегания (удаление и создание) небудет передаваться членам пир группы.


это еще раз подтверждает дебилизм архитектруры системы маунт поинтов.
>>>>>>>>>>>>>>>>>>>>

напимсано что если точка монтирования шаред и в ней создать субточку
монттирования то вторая  автоматом получает свойство шаред. и как я понял
субточка монтирования создаст новую пир группу. и это логично
информация о субточках монтирования для /mnt/01 недолжна прилетать
в точку монтироавния /mnt/01/vasya

написано что узнать какое свойство (шаред приват итп) имеет точка
морнтирования можно из /proc/pid/mountinfo

ну это мы уже знаем

пример

18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw

shared:7  данная точка монтирования /sys
имеет свойство shared и что и принадлежит к пир группе номер 7 !

насколько я понял каждая точка монтирования от ядра получает 
уникальный номер. 18 это номер точки монтирования для /sys от ядра.

практический смысл точки монтирования непронятен.в мане нарписано что
им можн ополтьзоваться  когда сделлаи umount. непонятно.

24 это номер другой точки монтирвания. какой же ?
это номер точки монтирования  к которой наша точки монтирования прикреплена.

пример есть две точки  / и /mnt так вот / является роидительской
точки монтирования для /mnt

еще пример

/sys/fs/cgroup и /sys/fs/cgroup/systemd
так вот /sys/fs/cgroup является родителтской точкой монтирования для 
/sys/fs/cgroup/systemd

тоесть родительская точка монтииования это путь к папке в которой наша 
точка монтирования и находится

еще пример точка монтирования /home является родительской для 
точек монтирования /home/vasya ,   /home/petya

а /home/vasya уже является родительской для /home/vasya/tmp

  
итак еще раз мы раскрыли тайну строки из /proc/pid/mountinfo

18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw

точка монтирования /sys имеет свойство shared и лежит в пир группе 7.
для /sys номер ее маунта для ядра = 18
точка /sys лежит в точке монтирования /.  для /sys родительтской точкой
монтииования я вляется /.  точка монтирования / имеет для ядра номер 24

18 и 24 это не номера пир групп. это номера точек монтирования для ядра.
номер пир группы 7.

еще раз mount ID и peer group ID это разные вещи.

18 и 24 это mount ID
7 это peer group ID

пир груп ID начинаются с 1
маунт ID начинаются с 0

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
если маунт точка имеет свойство шаред то в /proc/pid/mountinfo будет
указано

shared: X

где X - это номер пир группы.

если точка анбиндабл то будет указано 

unbindable

дальше тупизм. если ничего неуказано то это private точка.
реальный дебилизм

если для точки указано 

master: X

то (внимание еще дебилизм) это значит что точка slave! в пир группе X

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

далее. для маунт поинта может быть свойство propagate_from:X
оно идет всегда в купе с master:X
зачем тогда propagate_from:X нужно. 
оно используется тогда когда процесс (/proc/pid) неможет непосредственно
"увидеть" в своем списке каталогов путь монтирования точки монтирования 
которые принадлежат к пир группе X.

и щас мы разберем как так на практике может получится:
значит я пока неразобрался с этой штукой.
отложим.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
разберемся детально что значит каждя штучка в mountinfo

304 46 8:33 / /mnt/disks/vdb1/vdb2 rw,relatime shared:106 - ext4 /dev/sdc1 rw,data=ordered

304 = идентификатор маунт поинта для ядра. mount-ID
/mnt/disks/vdb1/vdb2 = этот тот путь куда примаунчено, это destination
в команде mount. это куда мы монтируем
/dev/sdc1 - это source в команде mount. это что мы монтируем.

то есть данная срочка может быть расшифрована как

mount /dev/sdc1 /mnt/disks/vdb1/vdb2

ext4 = понятно. это тип ФС

rw,relatime + rw,data=ordered = это параметры монтирования

shared:106 = понятно. точка монтирования является членом пир группы с номером 106

теперь обсудим более сложные параметры в строке оставшиеся

8:33 = major:minor. это у нас source тот который /dev/sdc1 но 
прописанный другими словами. по любому это указан бекенд источник который мы
примаунтили. потому что мы прикрепляем некий бекенд (диск) к некоторому
пути типа /vasya/home/folder. так вот диск = /dev/sdc1 = 8:33.  8 это
номер драйвера обслуживающего бекенд. 33 это порядковый номер идентичных
устройств для драйвера номер 8. соотсветвие между дисками с разделами  и их major:minor можно увидеть через lsblk

~# lsblk
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sda      8:0    0  20G  0 disk
└─sda1   8:1    0  20G  0 part /
sdb      8:16   0  30G  0 disk
└─sdb1   8:17   0  30G  0 part /mnt/03
sdc      8:32   0   2G  0 disk
└─sdc1   8:33   0   2G  0 part /mnt/disks/vdb1/vdb2
sdd      8:48   0   2G  0 disk

/ = это супер тупой параметр который я считаю неимеет никакого нормального
смысла. в man proc про  него пишут что это типа root: root of the mount within the filesystem. но это полная херня и брехня. этот параметр я настаиваю
ничего кроме дурить мозг неимеет смысла. он всегда равен / кроме пары случаев.
один случай если мы делаем маунт через --bind то он равен источнику
например мы делаем mount /etc /vasya тогда он будет = /etc . второй случай
это когда у нас nsfs тогда он равен net:[4026531957]. в  остальных случаях
чтобы ты неделал он всегда равен /. поэтому я настаиваю что этт параметр
можно всегда игнорировать он показывает чушь.
 
46 = это номер другой маунт точки. а какой.
берем наш маунт путь /mnt/disks/vdb1/vdb2 и начинаем по нему подниматься по 
каталогу наверх. ближайший каталог наверх это /mnt/disks/vdb1/ проверяем
это просто каталог или маунт точка. если это просто каталог то идем выше.
следущая папка наверх это /mnt/disks/. она уже точка монтирования а не 
просто папка. смотрим какой у нее mount-id и записываем его. это 46.
вот какой смысл 46. он назыается parent-id. главное что надо понять
что между нашей точкой монтирования и parent-id НИКАКОЙ СВЯЗИ НЕТ ВОООБЩЕ 
имеется ввиду по поводу взаимосвязи содержимого каталогов нашей точки и точки
parent-id. parent-id это просто ближайшая папка наверх по каталожному пути
которая непросто папка а вдобавок точка монтирования. то есть это просто 
ближайшая точка монтироавния к нашей точке монтиования. ближайщшая в смысле
каталожного пути. а так между ними связи никакой. 

на мой взглял в mountinfo куча ненужной информации я бы сделал вот так

304 ext4 /dev/sdc1 /mnt/disks/vdb1/vdb2  rw,relatime,data=ordered shared:106

все остальная инфо это просто забивающая мозги шлак!

есть конечно несколко кстати. кстати бекенд невсегда указан
в mountinfo в виде /dev/sda1 итп. то есть его невсегда можно определить
из mountinfo в явном виде. а жаль. едиснтвенное что бекенд всегда
представлен в виде major:minor

с точки зрения mountinfo нет никакой иерархической
файловой структуры папок. есть просто набор записей о точках монтирования.
каждая запись независимая. 

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
про чеверты столбик в строке mountinfo
как я говорил там в 95% стоит знак /

сейчас я так понимаю значение этого столбика.
если там стоит знак / то это значит что на бекенде примонтирован 
полный раздел от самого корня. то есть это означает классическое
монтиование.

если же на бекенде примонтирован нераздел целиком а отдельная папка
то будет показана папка ( как это быавет через mount --bind)
например если указан /etc/ то это значит что на бекенде примонтирован
не целиком раздел а только отдельная папка /etc

в упрощенном обьяснении этот солбик позволяет быстро определить
маунт был классический или через --bind

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
прокомментирую как нужно расшифроварвыть записи в mountinfo


239 61 8:2 / /mnt ... shared:102
248 239 0:4 / /mnt/proc ... shared:5
267 40 8:2 /etc /tmp/etc ... shared:105 master:102
273 239 8:2 /etc /mnt/tmp/etc ... master:105

первая точка - путь монтирования /mnt
бекенд 8:2
mount-id 239
ближайшая наверх по структуре папок точка монтиования имеет mount-id 61
монтирование идет классическое целого раздела а не отдельного каталога
точка монтирования является членом в пир группе 102

что относительно хорошо в строке mountinfo по сравнению с классической строкой
mount source dest это то что в mountinfo ядро берет source определяет 
какой за ним стоит бекенд и его указывает в mountinfo.
если же рассматривать строку mount source dest то может быть очень 
трудно найти какой же бекенд скрыается за source потому что 
source может быть целой цепочкой забинденных моунтов.
строка в mountinfo лишает нас необходимости определять и искать скрывающийся
истинный бекенд.

вторая точка - путь монтирования /mnt/proc
бекенд 0:4. так как major=0 то это означает что на бекенде стоит 
не реальный физ диск а вирт диск типа бекендом является сама память
mount-id 248
ближайшая наверх по структуре папок точка монтиования имеет mount-id 239
монтирование идет классическое целого раздела а не отдельного каталога
точка монтирования является членом в пир группе 5

ну думаю хватит.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
точка монтирования это два компонента в союзе - это путь монтироавния
и это бекенд источник

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

я смонтировал корень в /mnt
# mount --bind / /mnt

смотрим что получилось

# cat /proc/self/mountinfo | grep -E 'sda1|/mnt/A1'

24 0 8:1 / /  shared:1  ext4 /dev/sda1 
378 24 8:1 / /mnt/A1 shared:1 ext4 /dev/sda1 


видно что у / указано что есть более высокая якобы папка 
в плане иерархии фс хотя ее же нет. так вот для / указано
что есть более высокая папка которая является точкой монтироавния
с mount-id = 0 но папки то нет выше корня. в общем удивительно что 
указано 24 0 вместо 24 24.
также забавно что точка с минимальным mount-id  доступная это mount-id=18

18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw
19 24 0:4 / /proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw
20 24 0:6 / /dev rw,nosuid,relatime shared:2 - devtmpfs udev rw,size=5099828k,nr_inodes=1274957,mode=755
21 20 0:14 / /dev/pts rw,nosuid,noexec,relatime shared:3 - devpts devpts rw,gid=5,mode=620,ptmxmode=000
22 24 0:18 / /run rw,nosuid,noexec,relatime shared:5 - tmpfs tmpfs rw,size=1023972k,mode=755
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered


если корень был смонтирован 24-ым по счету
то забавно что /sys /proc /dev /dev/pts /run были смонтированы раньше 
чем /.
походу разгадка в том что изанчально бекендом для ФС при загрузке
является RAM. и потом на каком то этапе ядро как то хитро отмонтирует 
точку монтироавния / у которой бекенд в RAM и вместо этого монтирует
раельный жесткий диск в путь /. при этом /sys и прочие ядру перемонтировать
ненужно поэтому получается такая забавна нумерация.

видимо 0 это бекенд вирт RAM диска который изначально монтируется
и которого уже нет в живых.

также видно что и 24 и 378 входят в одну пир группу.
причем это самая первая пир группа

получается у нас был shared:1 корень. когда мы через бинд
его смонтировали в еще одно место то новая точка монтирования 
заимела такие же свойства. стала shared:1

что собственно совпадает с теорией - для того чтобы добавить точку
монтирования в пир  группу нужно заюзать --bind. естественно
исходная точка должны быть shared

>>>>>>>>>>>>>>>>>>>>>>>>>
полезная утилита.
узнать какие файлы (дин библиотеки) бинарник юзает

 ldd /bin/bash
        linux-vdso.so.1 =>  (0x00007fff857d2000)
        libtinfo.so.5 => /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f2c9b245000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f2c9b041000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f2c9ac77000)
        /lib64/ld-linux-x86-64.so.2 (0x00005597d5641000)


это пригодится если мы хотим запустить команду из под chroot папки
то нужно будет в нее скопировать нетолько /bin/bash 
но и все вот это

вот прикольный списочек для mc

# ldd `which mc`
        linux-vdso.so.1 =>  (0x00007ffed4d10000)
        libslang.so.2 => /lib/x86_64-linux-gnu/libslang.so.2 (0x00007f84a84fd000)
        libgpm.so.2 => /usr/lib/x86_64-linux-gnu/libgpm.so.2 
		...
		...
        /lib64/ld-linux-x86-64.so.2 (0x000056192f6de000)
        libgpg-error.so.0 => /lib/x86_64-linux-gnu/libgpg-error.so.0 (0x00007f84a62fb000)


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
выяснилась очеердная непонятная хуйня.
непонятно как работает команда chroot.

# mount --bind / /mnt/A3

после этой команды и / и /mnt должны сидеть в одной пир группе.
при условии что / = shared

# mount --bind /proc /mnt/A3/proc

тоже самое и тут.

# echo $$
9023
# ls -1al /proc/$$/ns

 mnt -> mnt:[4026531840]

# cat /proc/$$/mountinfo

# cat /proc/self/mountinfo 
19 24 0:4 / /proc shared:12 - proc proc rw
24 0 8:1 / / shared:1 - ext4 /dev/sda1 
392 24 8:1 / /mnt/A3 rw,relatime shared:1 - ext4 /dev/sda1 
400 392 0:4 / /mnt/A3/proc  shared:12 - proc proc rw
И ЕЩЕ ОЧЕНЬ МНОГО СТРОЧЕК. (это важно)




#chroot /mnt
# echo $$
12905
он поменялся

так я понял. если chroot меняет корневой каталог это да, но также 
chroot нужно указать какую программу запустить в этом новом корневом
каталоге. если имя программы неуказать то будет запущен дефолтовый 
шелл. поэтому теперь понятно почему когда я запустил chroot /mnt
то изменился processs-id

прикол в том что в интернете часто пишут фигню они пишут что черут 
меняет корневой каталог для ТЕКУЩЕГО процесса. это брехня полная.

# ls -1al /proc/$$/ns

 mnt -> mnt:[4026531840]

маунт неймспейс НЕПОМЕНЯЛСЯ.
но при этом потерялась целая куча точек монтирования

# cat /proc/$$/mountinfo
392 24 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered
400 392 0:4 / /proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw

куча точек монтирования исчезла.
эти две строчки единственные точки монтирования что остались

что за хуйня. ведь изначально утверждалось что 
маунт неймспейс это список точек монтирования.
получается есть два процесса. они сидят в одном маунт неймспейсе.
но при этом ссука видят разные список маунт поинтов.

да это непонятно.

получается что если у двух процессов один и тот же мааунт 
немспейс то нефакт что список точек монтирования один и тот же.
это жесть
также как видно даже точки монтирования с одинаковым mount-id
для этих двух процессов имет разные пути монтирования.

отсюда мудрость - если ты из под процесса имеешь mountinfo 
то есть информацию о маунт неймспейсе то 
1) нефакт что это полный список точек монтирования данного маунт
неймспейса
2) нефакт что пути монтирования истинные

это полная жопа.

как узнать полный и истинный список точек монтиования для конкретного
маунт неймспейса непонятно.


>>>>>>>>>>>>>>>>>>>>

полезная инфо

# cat /proc/self/mountinfo  | grep -E 'shared:1 '
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1
451 24 8:1 / /vasya rw,relatime shared:1 - ext4 /dev/sda1

отсюда правило. если есть точки монтирования у которых одна и таже 
запиьс вида 

shared:1

значит обе точки монтирования ведут к одному и томуже бекенду.

поэтому вопрос . вот у меня есть точка монтитвания на ней есть свойство
шаред  я его меняю на прайвет что произойдет. ответ нихуя непроизойдет.
нихуя. все что видно будет видно попрежнему.
все изменения будут касаться новых субточек монтирования.
а именно став приватной эта точка монтирования ни другим не даст
инфо о своих новых субточках ни от других небудет принимать этой
инфо
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

опять важн опонять что две точки монтироавния дожлны быть непросто обе
шаред а должны еще принадлежать к одной пир группе.
только тогда они будут видеть новые субточки друг у друга

>>>>>>>>>>>>>>>>
однако остается вопрос какой же командой делается 
для процесса котоый является "контейнером" некоторая папка 
как корневая папка

>>>>>>>>>>>>>>>>>>>>>>>>

еще важно. как я понял . если у нас две точки монтирвоания входят в одну
пир группу.и мы сделали одну из точек приватной. то обратно вставить
эту точку в пир группу уже нихуя никак неполучится.

>>>>>>>>>>>>>>>>>>>>>>>>
смена свойств в шаред на приват итп влияет не натекущую картину что 
видно в папке. а на последующую картину. на картину что будет твориться
потом после когда когда начнут создавать новые субточки монтиварония после.
на новые субточки монтиварния. все старое остается без имзенений.

>>>>>>>>>>>>>>>

!!! наконец посмотреть в /proc/pid/mountinfo для контейнера чтобы 
наконец узнгать где же контейнер хранит свою файловую систему

имеем контейнер c nginx

# docker inspect 6ff6fea5d68c

находим там pid

 "Pid": 21265
 
 зная pid мы можем узнать mountinfo. 
 то есть все точки монтирования которые видит процесс

# cat /proc/21265/mountinfo

и в самой верхней строчке мы видим

466 388 0:96 / / rw,relatime master:109 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work

466 - mount-id
388 нас неинтересует.
0:96 = бекенд маунтинга. поскольку 0. то значит что бекенд не физ диск
а оперативка.
/ = озачает что смонтирован бекенд полностью а не его отдельная папка.
/ = означает что путь монтирования. понятно что если мы делаем 
скажем chroot то как  я показал выше путь вида /path/path становится
в mountinfo как /

rw,relatime = параметры монтирования 
master:109 означает что точка монтрования является слейв членом пир группы 109. то есть их новые субточки будут в ней видны. а наши новые субточки
не будут там видны.
overlay = файловая система бекенда

lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work = 
это параметры маунтинга оверлей фс

я хотел проверить что так как оверлей фс необычная ФС 
то что у нее всегда major=0 который в свою очередь как бы вообще то
означает что бекенд не физ диск а мемори.

mountinfo так устроен что когда у нас меняется через chroot путь монтирования
то в первых столбиках у нас меняется путь монтирования но при этом 
параметр монтирования отображаются каонечно как они есть.
поэтому понятно что корень указанный в параметрах
и корень указанный в пути монтирования это разные корни.



# cd /tmp
# mkdir lower upper workdir overlay
# sudo mount -t overlay -o \
lowerdir=/tmp/lower,\
upperdir=/tmp/upper,\
workdir=/tmp/workdir \
none /tmp/overlay

# cat /proc/self/mountinfo  | grep '/tmp/overlay'
442 24 0:96 / /tmp/overlay rw,relatime shared:130 - overlay none rw,lowerdir=/tmp/lower,upperdir=/tmp/upper,workdir=/tmp/workdir

подтвердилось. бекенд устройство 0:96


далее когда монтируем оверлейФС то мы указыаем несколько
каталогов: lowerdir (их тоже может быть несколько штук сразу) - это каталог только на чтение, upperdir, workdir. хрен знает что из них каждый
делает но финальный результат показывается в каталоге mergedir или другими
словами в точке монтироавния.

то есть в mount мы указываем mount -t overlayfs  lowerdir,upperdir,workdir /точка_монтирования

из верхней строки мы видим что 

lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7

upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff

workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work

и то что точка монтирования  = /

но стоп. прикол в том что мы и хотим найти этот / но уже на нашей файловой
системе хоста.

мое предположение еще раз что если брать "абсолютную" структур папок ФС
то там наша точка монтирования 442 имеет некий path  который мне и надо
знать но если мы запускаем процесс через chroot то для 
процесса этот паф преобразуется черутом и он выглядит в mountinfo процесса
как /.
мы знаем зато точно что mount-id он уникален и неменяется. поэтому
походу если мы возьмем mountinfo для процесса init и в нем
поищем mount-id=442 то там мы увидим истинный путь к папке.
 япроверил. прикол в том что в mountinfo от init нет вообще такого
 mount-id.
 походу дело вот в чем. есть неймспейс контейнерного процесса.
 в нем он создает новый маунт поинт. и этот маунт поинт получает
 уникальный на весь комп mount-id и это хорошо так как он неменяется
 и все такое его легко идентифицировать но данный маунт поинт 
 будет виден только в маунт неймспейсе контейнера. а в этом 
 маунт поинте сидит только один процесс.контейнерыный процесс.
 когда я делал chroot то новый процесс сидел в том же маунт неймспейсе
 что и исходный процесс. если в процессе который работает под chroot
 пути монтирвания являются измененными то в исходном процессе
 пути неизмененные. и посмотрев mount-id в черут процессе
 мы можем в исходном процессе в mountinfo есть тот же mount-id
 только с неизменнеыми путями монтирования.  проблема в том что 
 когда мы имеем дело с маунт поинтом контейнера то во первых
 у нас нет двух процессов работающих в его неймспейсе процесс
 только один. поэтому мы можем видеть только путь с 
 измененннымм путем монтирования. 
 
 окей. вспоминаем то что маунт неймспейс контейнера он же должен 
 создаваться путем копирования из некоего другого маунт неймспейса.
 возникает вопрос что это за исходный маунт неймспейс 
 если в неймспейсе контейнера мы видим в mountinfo только пару 
 точек монтироавния. 
 
 >>>
 пока непонятно.
 остановился здесь !!!!!!!!!!!!
 нет команды которая бы показала какой mount name space
 является исходным для данного неймспейса. а если бы и была 
 то надо еще узнать какой процесс крутится в исходном нпеймпейсек


есть контейнер
есть его конкретная маунт поинт

:/# cat /proc/5750/mountinfo | grep '/ /'
685 549 0:109 / / rw,relatime master:168 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/C44UK7KTLN5352B6SM5ISOX2PU:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/6bcca7abc92f2131c05b07354d86bb7367631f1b5d01780e0300b1c4e33e0edb/diff,workdir=/var/lib/docker/overlay2/6bcca7abc92f2131c05b07354d86bb7367631f1b5d01780e0300b1c4e33e0edb/work

задача - перекопировать файлы с этого маунт поинта 
в другой маунт неймспейс.

проблема  в том что pivot_root и chroot обезобарживают mountinfi
до неузнаваемости.

в частном случа докера. все просто потому что повезло.
докер берет папки в /var/lib/docker.
варганит из них оверлей в папку /var/lib/docker/.../megerged 
и туда делает pivot_root походу.
поэтому найти концы тут просто.
но что делать в общем случае. как переместить файлы между
маунт неймсейсами.


значит что я понял к настоящему моменту.

вот есть у нас маунт поинт в некотором неймспейсе

685 549 0:109 / / rw,relatime master:168 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/C44UK7KTLN5352B6SM5ISOX2PU:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/6bcca7abc92f2131c05b07354d86bb7367631f1b5d01780e0300b1c4e33e0edb/diff,workdir=/var/lib/docker/overlay2/6bcca7abc92f2131c05b07354d86bb7367631f1b5d01780e0300b1c4e33e0edb/work

и информации в нем недостаточно в общем случае 
чтобы определить а где на бекенде и в какой папке лежит эта папка.
во первых если бекенд физический то еще можно методом поиска
поискать папку похожу на ту что указан в пути монтирования.
но если бекенд нефизический вида 0:x то бекенд может лежать в озу
и доступ к нему будет возможен только из маунт спейса 
того процесса а не нашего процесса.
оверлей фс хоть и базируется на физ бекенде но тоже имеет
0:х это как исключение.
если бекенд физический то мы можем его найти через lsblk.
если мы до  бекенда добраться неомжем то остается искать
пути копирования из одного маунт неймспейса в другой.
в общем случае это невозможно.

также рассмотрим еще раз саму mountinfo

685 549 = вот это в общем случае нам ничего недает.
единственное что оно неменяется такими командами как chroot и pivot_root

0:109  = бекенд. если он вида 0:х то это нам тоже особоничего недает.
едиснтвенное что его чирут и пивот_рут неменяют

/ / = второй значок это путь монтирования. так вот он нам к сожалению
тоже ничего недает. так как его меняет чирут и пивот_рут.

еще раз подчеркну очень важный момент  есть команды chroot и pivot_root
которые меняют путь монтирования в mountinfo с истинного на новый
таким образом запись в mountinfo про путь монтирования не является
истинной. это подмененнная реальность для процесса. то есть 
с точки зрения процесса в этом неймспейсе путь валиден
то сточки зрения бекенда это легко может быть брехня.

lowerdir=/var/lib/docker/overlay2/l/C44UK7KTLN5352B6SM5ISOX2PU:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/6bcca7abc92f2131c05b07354d86bb7367631f1b5d01780e0300b1c4e33e0edb/diff,workdir=/var/lib/docker/overlay2/6bcca7abc92f2131c05b07354d86bb7367631f1b5d01780e0300b1c4e33e0edb/work = вот 
эта штука это параметры монтирования в строке mount. слава богу что ее 
ни чирут ни пивот_рут неменяют а оставляют как оно и было изначально.
таким образом можно по нему искать на бекендах для оверлейФС его 
исходные папки  и надеяться что где то там и папка merged лежит
рядышком которая нам собсвтенно и нужна. то есть по эттм паратметрам
монтирования можно пробовать искать и финальную нужную папку монтирования.

таким образом в маунтинфо не вся информация является неизменной
абсолютной. часть информации является относительной. относительна она
в том смысле что так оно и есть для процесса который крутится в этом 
маунт неймспейсе. но абсолютно не факт что так есть с точки зрения
процесса из нашего неймспейса. 
поэтому поиск папки прописанной в mountinfo это нетривиальная задача.
и говоря упрощенно часть информации в маунтинфо это брехня.
а части информации нехватает. поэтому имея маунтинфо далеко невсегда
можно найти эту папку в своем неймспейсе на бекенде.

таким образом конкретно что касается докер контейнеров
мы приходим к тому что мы используем внешнюю инфо о том что 
докер хранит свои папки в /var/lib/docker




>>>>



посмотрим что докер пишет на счет где он хранит бекенд 
для контейнера

# docker inspecr $PID

и видим

  "LowerDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c-init/diff:/var/lib/docker/overlay2/c361f573d628d9f5b9d064373de4d7753436ff86663fba20cb211b8ede62c5e5/diff:/var/lib/docker/overlay2/723190a9632b1a1f4040286c9840261a35aa8cc2e943a7271517d8f8acb06833/diff:/var/lib/docker/overlay2/0933c48b3bdf8a9a3efa7efc3968fe6425b3878b041add6e961590f88f8896e8/diff:/var/lib/docker/overlay2/bdd6630675e988b2ec399b6de6f2da22817d302013bbf4b818edfb9cc1d35e0a/diff:/var/lib/docker/overlay2/ebd8f8ddbcfca6a98334252558badc1d1eb162e5feaf3d5cd072472b3a736b0b/diff",

  "MergedDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged",
  
  "UpperDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff",
  
  "WorkDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work"


таким образом корневая сиситема контейнера лежит в 
mergedir =  "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged"

так ну по крайней мере хоть както научились искать где же на диске
лежит файловая система контейнера. так что 
теперь без проблем можно там редактировать файлы без уебанской мудоты.

итак - мы научились находить папку где лежит ФС контейнера
чтобы ее можно было редактировать напрямую из нашего неймспейса.

по поводу родительской точки монтирования - как я уже писал.
единственный смысл этой хрени это то что якобы если мы пойдем вверх 
по папкам по ФС то это будет первая папка ближайшая которая еще к тому
же непросто папка а точка монтирования. ну и что. эта херня нам 
бесполезна . они ничего недает. и она на нашу точку никак 
не влияет ни начто.

>>>>>>>>>>>>>>>>>
еще раз коснусь о чем уже говорил.
западлянской команды unashare
очень важно понимать с каким флагом мы ее запускаем
а если флаг неуказываем то какой у нее дефолтовый
иначе небудешь понимать почему 
в новом маунт неймспейсе точки имеют нете флаги(щаред приват слейв) 
чем ожидаешь по теории

# unshare -m  --propagation unchanged  bash

если мы используем флаг  --propagation unchanged
именно благодаря ему в новый неймспейс список точек монтирования будет
скопирован по всем правилам что описаны выше. а именно что в новом немспейсе
точки монтирования будут членами пир групп(то что описано выше). если этот флаг непоставить то все что описано выше окажется полной херней. 
ниодна точка монтирования в новом неймспейсе небудет членом ни одной пир группы ни при каких условиях при создании нового неймспейса. наоборот.
unshare сотрет все флаги шаред итп со всех точек монтрования в новом неймспейсе. поэтому этот флаг суперважен при запуске команды unshare

>>>>>>>>>>>>>>>>>>>>>>>>>>>

чтобы узнаь является ли одна точка монтирования биндом от другой
точки монтирования надо посмотреть в mountinfo сидят ли они в одной
пир группе

# cat /proc/self/mountinfo | grep '/mnt/X'
334 24 0:100 / /mnt/X rw,relatime shared:116 - tmpfs tmpfs rw,size=10240k

# cat /proc/self/mountinfo | grep '/mnt/Y'
335 24 0:100 / /mnt/Y rw,relatime shared:116 - tmpfs tmpfs rw,size=10240k
 
как видно сидят. 
так как и /mnt/X и /mnt/Y сидят еще и в одном маунт неймспейсе
значит одна из них была получена из другой через --bind

>>>>>>>>>>>>>>>>>>>>>>>>>



еще раз подчеркну такую вещь. а именно ответ на вопрос - вот у нас есть 
точка монтирования /mnt/vasya и она шаред.
что будет если создать у нее субточку монтирования например /mnt/vasya/sub она тоже будет шаред
или приватной. аесли шаред то в какой пир группе в той же что и головная точка /mnt/vasya? во первых надо заметить что это независит от 
свойств головной точки /mnt/vasya это зависит от дефолтовых установок
самого линукса. как я писал выше если на компе крутится systemd то 
тогда если /mnt/vasya = shared то и субточки монтирования /mnt/vasya/xxx тоже
будут шаред.
так оно и есть я проверил я создал /mnt/23 сделал ее = shared
потом создал субточку монтирования /mnt/23/A 
и сам недобавлял к ней никаких флагов. 
и система показала что она уже щаред.

# cat /proc/self/mountinfo | grep '/mnt/23'
335 24 0:101 / /mnt/23 rw,relatime shared:117 - tmpfs tmpfs rw,size=10240k
336 335 0:103 / /mnt/23/A rw,relatime shared:118 - tmpfs tmpfs rw,size=10240k

едиснтвенное что надо добавить что конечно же /mnt/23/A будет шаред в своей
собственной пир группе. потому что точки монтирования попадают в одну 
пир группу либо если они образованы через --bind друг от друга
либо если одна точка лежит в одном неймспейсе а другая лежит в другом неймспейсе и второй неймспейс получен из первого. ну и конечно во всех случаях исходная точка монтирования доложна быть шаред. в даннои случае для /mnt/23/A этого ничего нет. поэтому она сидит в другой пир группе чем /mnt/23

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

далее. еще раз дебильный момент
если точка монтирования имеет приписку master:2
то она не мастер. нет. она slave. вот такой дебилизм


далее. если точка одновременно является слейвом одной пир группе и полноценным
членом вдругой группе то в mountinfo про нее будет сразу две опции указано
master:M tag and a shared:N

если  точка монтироавния slave то обычно линукс субточку монтирования создаст
приватной. это независит от архитектуры самих точек. это больше от самого 
линукса зависит как у него дефолты установлены.
просто теперь получается что при создании точки монтирования нужно для
линукса прояснять это какая точка монтирования - шаред приватная слейв анбинда
бл. и если ты этого неделаешь в явном виде сам. то линуксу надо самому
решать какое свойство точке присвоить

>>>>>>>>>>>>>>>>>>>>>>>>>>
важно опять же помнить что если 
у нас есть пир группу и неважно что в ней один член = шаред
а другой слейв. это похеру. если мы в любом члене пир группы создаем
файл или папку то это будет видно всем членам пир группы

>>>>>

что если мы по одному пути подрял сделаем 20 маунтов.
да так можно. 
виден будет последний. но остальные тоже будут висеть 
просто невидимо.

чтобы провериить какой маунт побеждает при много кратном маунте
и какой маунт отмаунчивается при юмаунт я сделал вот что


# mkdir /mnt/Z
# mount -t tmpfs -o size=10m tmpfs /mnt/Z

# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

# mount -t tmpfs -o size=10m tmpfs /mnt/Z

# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
338 337 0:107 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

# mount -t tmpfs -o size=10m tmpfs /mnt/Z

# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
338 337 0:107 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
339 338 0:108 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

то есть видно что каждый новый маунт в туже точку 
дает точк монтирования с более большим mount-id

теперь начнем делат юмаунт

# umount /mnt/Z


~# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
338 337 0:107 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

видно что отмаунтился последний. хм... странно 
так как в случае слейв точки монтирования первым отмаунтился тот маунт 
который имел самый маленький номер.
>>>>>>>>>>>>>>>>>>>>

 113 24 0:45 / /var/lib/docker/containers/368670921d299f8aa18be2eb3bf35cca9c55b3c029ab4cb53629bb5a7d66b134/mounts/shm rw,nosuid,nodev,noexec,relatime shared:88 - tmpfs shm rw,size=65536k

виртуальный диск tmpfs для контейнера примаунчен как корень .зачем почему
пока непонятно

>>>>>>>>>>>>>>>>>>>>>>>
chroot и pivot_root
они неменяют маунт неймспейс.

но они делают две вещи.

1 они меняют пути в путях монтирования . так что 
некая точка монтирования становится / хотя наример она изначально 
имеет путь /mnt

2 они убирают из mountinfo для процесса ВСЕ АБСОЛЮТНО ВСЕ ЗАПИСИ про другие
точки монтирования которые существуют в данном маунт неймспейсе которые лежат
выше корневой точки монтирования.

пример

были точки монтиования 

/

/A

/mnt

если мы сделаем #chroot /mnt bash

то в mountinfo этого процесса будет только одна точка монтирования
хотя маунт неймспейс неизменился. будет запись только о точке монтирования

/mnt  

о двух других небудет ни слова. 
это пиздец. потому что маунт неймспейс неизменился.

и также в mountinfo для этого процесса чирут изменит путь и вместо /mnt
будует указано /

пример было 

/mnt  /dev/sda1

станет

/ /dev/sda1

вот такая *зда.


>>>>>>>>>>>>>>>>>>>>>>>>>
увидели путь в docker inspect
или в cat /proc/pid/mouintinfo

с докером возможно нам везет. что маунт 
нейсмпейс контенера создается из исходного нашего
неймспейса

отлично. возникает вопрос. почему мы видим папки контейнера в нашем
неймспейсе (под другим путем единственно что)
которые лежат в другом маунтнеймспейсе

ответ такой - потому что хотя оверлейфс и пишет что якобы у нее бекенд
в RAM лежит 0:107 это брехня бекенд лежит на реальном физ диске.
а к физ диску мы имеем доступ из любого неймспейса в том 
числе и из дефолтового. также насколько контейнер создается вот как.
берется делается копия из дефолтового неймспейса нашего.


mountinfo процесса контейнера

453 361 0:107 / / rw,relatime master:112 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/OEIXU3INGSPT7GSM7WGFB2U74K:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/456aa739a64c6e9792ecdeddb8dda4a77906fa11de1b82ee98f1f6d8cd021c85/diff,workdir=/var/lib/docker/overlay2/456aa739a64c6e9792ecdeddb8dda4a77906fa11de1b82ee98f1f6d8cd021c85/work

видно что точка монтирования корня состоит к счастью в пир группе 
с номером 102
попробуем найти в неймспейсе init есть ли там случайно
члены 102 пир группы.

оказывается есть. нам очень повезло
mountinfo процесса обычного

# cat /proc/self/mountinfo | grep shared:112
251 24 0:107 / /var/lib/docker/overlay2/456aa739a64c6e9792ecdeddb8dda4a77906fa11de1b82ee98f1f6d8cd021c85/merged rw,relatime shared:112 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/OEIXU3INGSPT7GSM7WGFB2U74K:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/456aa739a64c6e9792ecdeddb8dda4a77906fa11de1b82ee98f1f6d8cd021c85/diff,workdir=/var/lib/docker/overlay2/456aa739a64c6e9792ecdeddb8dda4a77906fa11de1b82ee98f1f6d8cd021c85/work

отсюда я делаю вывод что нам очень повезло.  я делаю вывод что докер при 
создании контейнера создает папку 

/var/lib/docker/overlay2/456aa739a64c6e9792ecdeddb8dda4a77906fa11de1b82ee98f1f6d8cd021c85/merged

и монтирует туда оверлейФС. это все происходит  в неймспейсе init.

А ДАЛЕЕ докер создает на основе init неймспейса новый маунт 
спейс. и делает pivot_root в эту папку. таким образом она становится 
корнем для контейнера.

благодаря этим счастливым совпадениям мы можем видеть ФС контейнера
которая лежит в другом маунт неймспейсе в нашем неймспейсе (неймспейсе init
процесса).

это очень круто и удобно.

также посмотрим какую папку как корень показывает docker inspect

# docker inspect ID

"MergedDir": "/var/lib/docker/overlay2/456aa739a64c6e9792ecdeddb8dda4a77906fa11de1b82ee98f1f6d8cd021c85/merged",

ответ да. я все правильно понял.

поскольку mount 251 в нашем неймспейсе и mount 453 в неймспейсе контейнера
сидят в одной пир группе причем 251 = шаред а 453  = slave
то это значит что новые субточки монтирования в 251 будут видны в 453.
но нам пока важнее другое - раз точки монтироавния сидят в одной пир 
группе то внезависимости от их свойств (шаред слейв) измненеие файлов
и просто-папок в одной точке монтирования сразу видны в другой точке 
монтирования. таким образом изменяя файлы водной точке монтирования 251
мы меняем файлы и папки в другой точке монтироавния 453.
а это нам и нужно изначально. 

если бы они не сидели в одной пир группе то мы бы немогли 
быть уверены что 453 была получена из 251 при создании нового 
неймспейса.

вопрос а чтобы  мы делали если бы 453 была бы не слейв а приватная.
как нам тогда искать в нашем неймспейсе ее пир группу.
ответ - во первых неймспейс контейнера необязан быть склонирован с нашего
неймспейса. нам просто везет что докер так сделан.
а так есть такой вариант - как я заметил - если мы забиндим приватную точку
то новая точка монтирования будет шаред и будет состоять втой пир группе
в которой состоит бекенд точки монтирования первой.
и тогда когда бы мы узнали пир группу таким способом то можно было бы 
искать наличие этой пир группы в нашем неймспейсе.

еще раз подчеркну мы смогли найти  исходную точку монтирования в нашем
неймспейсе для корневой точки монтирования контейнера только благодаря
тому что у нее есть свойство master:102
и мы искали в нашем неймспейсе пир группу 102 которая к счастью 
там оказалась.

а раз две точки состоят в одной пир группе это значит что измненеие 
файлов и просто-папок в одном любом члене делает это же во всех членах.
ура.

ну и доп свойство. так как один шаред а второй слейв. то 
новые субточки в шаред видны в слейв. а новые субточки в слейв
невидны в шаред.
это кстати значит что если мы внутри контейнера создалим новые субточки 
монтиоавния то в нашем неймспейсе в 251 мы их неувидим. таким оборазом
получается что просто так полную ФС контейнера в общем случае мы несможем
увидеть и скачать пользуясь 251.


>>>>>>>>>>>>>>>>>>>>>>>

* перечитить man mount и man на неймспейсы

>>>>>>>>>>>>>>>>>>>>>>>>>>>>

получается что каждая папка на ФС вида

/var/lib/docker/overlay2/имя../mereged

это "корневая точка монтирования" для живого и может быть остановленного
тоже контейнера 

причем это же не просто папки это точки монтирования.
и их отлично показывает df 

~# df -h | grep overlay
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/b84a02e1d117a0a4766f6c4c3eb7dc/merged
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/d3e1b9b510c6d1cd32eef6e33129cc/merged
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/2a3f6e3810742e448b66ab37c7562/merged
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/fe191ec7fc50908fd4807d65454697/merged
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/8bfd01eb9d651ce655cdfd3726eac/merged
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/ec871870902b46c5f42b93ec76796/merged
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/67117590340c341c0975e8ade8523/merged
overlay          20G  7.9G   11G  43% /var/lib/docker/overlay2/456aa739a64c6e9792ecdcd021c85/merged

к сожалению путь к точке монтиоравния несодержит в себе container-id
а то вообще было бы супер удобно одно через другое
идентифицировать.



>>>>>>>>>>>>>>>>>>>>>>


как влияет что в разных неймспейсах на одну точку монтииования разные
выставолены свойства.
ответ - во первых в разных неймспесах все точки монтирования разные.
единственное что если один неймспейс был получен из другого 
то есть точки исходные и точки порожденные.
и да в одном неймспейсе сидит точка с путем монтирования /mnt
и в другом будет точка с таким же путем. 
одна была порождена из другой.
измненеия файлов и папок в одной будет отображаться в другой.
это да. причем в независиомсти от свойств на этих точках(щаред слейв
приват). а вот взаимная видимость новых субточек монтироавния как раз
зависит от свойств.

>>>>>>>>>>>>>>>>>>>>>>>>

* непонятно как с помощью unshare создать новый процесс у которого
файловая система будет иметь корень в определенной папке.

ответ - никак. это делается с помощью chroot иди pivot_root
>>>>>>>>>>>>>>>>>>>>>>


* появляется вопрос. как определит кто у данного маунт неймспейса папа а 
кто у  него дети

ответ - походу никак. пока невстретил такого способа
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

* походу вот так - если мы имеем $PID контейнера.
то в /proc/$PID/mountinfo указаны все точки монтирования которые видит
данный процесс. причем жопа в том что в маунт неймспейсе могут быть еще 
точки но процесс их может невидеть и их небудет в mountinfo
такой прикол устраивает применнеие chroor или pivot_root

>>>>>>>>>>>>>>>>>>>>>>>


* про утилиту nsenter. из того что я уже понял про нее.
параметр -t у нее неработает. надо каждый неймспейс процесса смотреть отдельно, 
указывая путь к каждому типу неймспейса. то есть

хотим посмотреть что в сетевом неймспейсе тогда

# nsenter --net=/proc/$PID/ns/net команда

хотм посмтреть чтото в маунт неймспейсе тогда 

# nsenter --mount=/proc/$PID/ns/mnt команда

а вот такая штука нерботате и выводим полную галиматью

# nsenter -t $PID команда

а очень жаль. потому что хотелось бы сразу что nsenter всосал все неймспейсы процесса 
и чтоб команда отрабатыавала исходя сразу из всех неймспейсов процесса.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
и вот наконец то получилось то что я хотел.

запускаем контейнер с ubuntu+bash

# docker run -ti ubuntu /bin/bash&
[1] 2805

root@test-kub-02:~# docker ps
CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES
1706b53a231c        ubuntu                 "/bin/bash"              3 seconds ago       Up 2 seconds                             musing_clarke

надо немногожко его доработать.
установим внутри этого котейнера iproute2 утилиты. иначе ip -c address show внутри контейнера
небудет работать.

# docker exec -it 1706b53a231c bash
(внутри контейнера)# apt-get update
(внутри контейнера)# apt-get install iproute2

готово. контейнер доработан. выходим из него.

далее. узнаем  PID контейнера

# docker inspect 1706b53a231c | grep -i pid
            "Pid": 2881,
            "PidMode": "",
            "PidsLimit": null,


теперь я хочу незаходя внутрь контейнера а используя неймспейсы и утилиту nsenter 
посмотреть как выглядит  сеетвые карточки внутри контейнера и его файловая система внутри
контейнера

# nsenter --net=/proc/2881/ns/net --mount=/proc/2881/ns/mnt ip -c address show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    inet 127.0.0.1/8 scope host lo
29: eth0@if30: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0

совершенно понятно что это сетевые карточки контейнра а не хоста.

далее. создаем на компе папку

root@test-kub-02:~# mkdir /mnt/host

root@test-kub-02:~# nsenter --net=/proc/2881/ns/net --mount=/proc/2881/ns/mnt ls -1 /mnt

изнутри контейнера она невидна. что логично. ибо фаловая система контейнера
отделена от фс хоста.

видно что nsenter корректно работает когда мы все неймспейсы указываем отдельно друг за другом.
тогда nsnenter их все учитывает.

а если я введу 

# nsenter -t 2881 команда

то утилита выведем фигню  а не инфо изнутри контейнера. к сожалению. баг какойто.
а было бы удобне указать только pid вместо вот этой вот длиннющей портянки со всеми неймспейсами.

по идеет ключ -t судя по ману должен как бы учитывать все неймспейсы процесса сразу

   -t, --target pid
              Specify a target process to get contexts from.  The paths to the contexts specified by pid are:

              /proc/pid/ns/mnt    the mount namespace
              /proc/pid/ns/uts    the UTS namespace
              /proc/pid/ns/ipc    the IPC namespace
              /proc/pid/ns/net    the network namespace
              /proc/pid/ns/pid    the PID namespace
              /proc/pid/ns/user   the user namespace
              /proc/pid/root      the root directory
              /proc/pid/cwd       the working directory respectively

но по факту этот ключ неработает.  достаточно провести такой эксперимент

# nsenter -t 2881  ip -c address show

и вместо сетевых карт внутри контейнера на экран вылезет списко сетевых карт хоста.
это ужасный баг nsenter.

далее.
прикольно то что мы "невлезаем" внутрь контейнера когда юзаем 

# nsenter .... bash

или 

# docker exec -it ... bash

мы на самом деле ( и это только сейчас теперь стало понятно )  запускаем 
в линуксе еще один 
процесс ( bash в данном случае ) который просто напросто входит в теже
 неймспейсы что и процесс
который типа контейнер.

то есть в линуксе нет никаких "контейнеров". есть процессы которые принадлежать тем или иным 
неймспейсам. если мы хотим "влезть" в тот или иной контейнер это значит что мы должны создать 
еще один процесс который входит в теже самые неймспейсы что и процесс на котором крутится 
контейнер. это как в папку положить к файлу соседний файл.

таким образом мы когда "залазиим " в контейнер мы в нем ничего ненарушаем. 
просто для определнного набора неймспейсов добялвется еще один процесс приаттаченый к ним.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

* по идее имея PID процесса на котором крутится контейнер применяя знания про 
неймспейсы и утилиту nsenter можно "входить" внутрь контейнера и выполнять на нем
команды неиспользуя docker exec -it  загадочную команду.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


mktemp - создтает файл или папку название которой автоматом рандомное и имеет 600 пермишн.
так что если мы создаем файл или папку заведомо временную то нам ненужно париться
насчет имени. и ненужно париться на счет chmod пермишенов.
то есть никакой загадки в работе этой команды нет. что она делает - 
она придумывает случайно имя. создает с ним файл или папку и дает ей перимшн 600
то есть только кокнретный юзер имеет к ней доступ. типа такая удобняшка и неболее того.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

