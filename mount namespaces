параллельная штука.

как я понял системный вызов fork() создает дочерний процесс.
это полноценный новый процесс со своим новым pid.
он полностью независим от родительского процесса.
он имеет например свое незавиимсое виртуальное адресное пространстов в памяти.
поэтому процессы в памяти дочернего процесса никак не влияют на память в родительсокм
процессе.просто на момент когда процесс только что отклонирован его содержимое памяти 
ровно такое же как у родителя. потому что в режиме на чтение идет отсылка к памяти родителя.
но все изменения идут уже в отдельнуд область памяти.

другой системный вызов clone() как я понял он используется для создания трэдов.
это значит что тред имеет общую вирт память с процессом.
тред неиммет своего нового pid.

далее.


через --bind можно смонтировать любой каталог параллельно в другой катало

# mount --bind /tmp/1 /tmp/2

далее про файловую структуру файловую иерархию выяснилась интереснейшая вещь.

вот это вот дерево папок


# ls -1 /
bin
boot
dev
esdata
es_snapshots
etc
home
initrd.img
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
snap
srv
sys
tmp
usr
var
vmlinuz

это сугубо виртуальная структура.
эта штука нигде напрямую на диске незаписана.

наш процесс обращается к линуксе - мол скажи мне а каков листинг папок.

линукс там у себя в требухе шуршит и выдает некий результат. 
он его нечитает напрямую с диска. это чисто плод  виртуального размышления ядра.

то есть линуксу ничего немешает одлному процессу выдать один список папок 
а другому другой.

список папок на диске незаписан в жетском виде так чтобы линукс его считал с диска 
и отдал напрямую.

например.

раздел /dev/sda2 может быть подмонтирован к /mnt а можно подмонтировать к /tmp/1

то есть это все результат манипулирования.

одному процессу линукс при желании может отдать один список папок 
а другому процессу другой список.

а значит мы можем играться с тем какая структура папок их иерархия должны быть 
отдана одному процессу а какая структура другому. это все виртуальная штука.
разные процессы могут получать разные списки списка папок.

нет ну кончено на конечных дисках есть файловая система на которой жестко 
прописана структура папок. но это типа исходный материал.
но нам ничего немешает налету показать вместо одной папки другую.

ведь алгоритм выглядит так  - мы запрашиваем листинг папок.

линукс смотрит на диск. получает списко папок а потом может в этом списке чтото
динамически поменять (не насамом диске и его ФС)а в уже полученном списке.

и уже этототредактированный список отдать процессу.

подмена понятий налету.

получатеся что структура папок , обьекты монтирования структура папочной системы
это сугубо виртуалная щтука с которой можно играться.

*далее. в линуксе есть точки монтирования.
и эти точки монтирования могут иметь свойства. - shared private
unbindable slave.
* важно понять что вот эти свойства прайвэт шаред итп для точек
монтирования они неимеют отношения к маунт неймспейсам. это изначально
свойства тупо точек монтирования. маунт спейсы вылезают и появляются
уже потом и отдельным манером. 


насколько я понял та папка которую можно использовать 
совместно с несклькими процессами зовут shared mount

можно настроить чтобы изменения в структуре папок предоставленной процессу 1
отображались в структуре папок предоставленной другому процессу 2. и при этом 
чтобы изменеия в структуре папок показанной процессу 2 неотображались 
в структуре папок показанной процессу 1.

структура папок для процесса 1 называется shared mount
а структура папок для процесса 2 называется slave mount

типа процесс 1 один создает папку /tmp/1
и это видит процесс 2.

а если процесс 2 создает папку /tmp/2
и это невидит процесс 1

получается что для процесса 2 структура папок процесса 1 доступна на чтение.
а вот все изменения папок в процессе 2 сохраняется в другом месте.

точки монтирования которые мастер без слейвов называются privat mount.

есть еще unbindable mount - точки монтроавния которые нельзя  забиндить
через mount --bind

по умолчанию все обькты монтроания изначально private.
что логично.

вот так обьект монтирования делается из private в shared
# mount --make-shared <mount-object>

# mount --make-shared /

вот так делается slave обьект монтирования
# mount --make-slave /mount_point


две еще логичные команды
# mount --make-private <mount-object>

# mount --make-unbindable <mount-object>

во первых что такое неймспейс. это некая структура (таблица или чтото типа того ) в оперативке
линукса. она больше нигде кроме как в оперативке нехранится. как только мы перезагружаемся
поскольку никаких записей на диске неостается то все неймспейсы исчезают. как и любая другая часть
лежащая только в оперативке.

далее.
оказыается есть просто неймспейсы
а есть persistent namespaces.

в чем их отличие.

персистент неймспейс  - к ним не приаттачен ни один процесс.
как это работает.
в оперативке создается неймспейс. но нам нужно получить идентификатор на него чтобы 
с ним можно было начать чтото делать.

обычно по классике неймспейс создается при создаии процесса и тогда ссылка на неймспейс
кладется в /proc/$PID/ns

если процесса нет. то как бы дефолтового места куда можно было бы положить ссылку на неймспейс нет.

то есть на самом деле дело всего лишь куда положит ссылку.
некоторые утилиты в них можно указать какой файл будет хранить ссылку на неймспейс в оперативке.
наверно точнее в файле будет ссылка на некий файл в /proc а проц это хитрожопая файловая система 
которая хитрожопо связана с оперативкой ядра.

таким образом например утилита unshare умеет создавать неймспейсы без создания процессов.
если ей указать в какой файл положить ссылку на созданный неймспейс . пример

# touch /root/ns-uts         
# unshare --uts=/root/ns-uts

файл ns-uts он пустой. 
и если ввести ls -1al тоо будет показано ничего. как бутто этот файл никуда неведет.
но должен же он как то кудато указыывать на чтото в памяти линукса чтобы через него 
можно было связаться с неймспейсом.

если мы сравним на то как выглядит ссылка на имя неймспейса для процесса

# ls -1al /proc/1/ns/
lrwxrwxrwx 1 root root 0 Jun 18 00:41 uts -> uts:[4026531838]

мы увидим что uts както там хитрожопо указывает на инод в proc фс.

но еще раз скажу в случае с /root/ns-uts такого мы не увидим

t# ls -1al /root
-r--r--r--  1 root root    0 Jun 18 00:34 uts-temp

как бутто просто пустой файл никуда неведущий.

это потому что наш файл нележит на proc фс. и  он нас связыаем с неймспейсом 
другим хитрожопым способом. он нас связывает с именем неймспейса через хитрожопую файловую
систему nsfs (NameSpaceFileSystem)

как это проерить

# mount | grep nsfs
nsfs on /root/uts-temp type nsfs (rw)

еще как проверить

# findmnt | grep nsfs
TARGET									SOURCE				 FSTYPE     OPTIONS
├─/root/uts-temp                      nsfs[uts:[4026532440]] nsfs       rw

nsfs это чисто програмистская линукс хрень.
с ней както там работают утилиты. а юзерам с ней напрямую неработать.
можно просто понимать что когда мы создаем неймспейс и сразу к нему привязываем процесс
то ссылка на неймспейс кладется в /proc/$PID/ns
и тут nsfs ненужен. как я понял .
когда мы создаем неймспейс без процесса то создается имя неймспейса сохранятеся в некоей
вирт фс nsfs и ссылка на nsfs файл (или что за хрень за хрень незнаю ) через опцию bind 
пробрасывается на обычный файл на диске.

увидеть эту связь этот проброс ( а есть ли у нас файлы на диске к которым сделан проброс
на nsfs ? ) можно через findmnt или mount

получается 
nsfs[uts:[4026532440]] 
это имя файла или инода или чего то там на nsfs где хранится имя неймспейса или ссылка на него вобщем
по этой херне линукс может его найти идентифицировать. но мы как юзеры с этой хренью работать неможем
поэтому линукс через mount и опцию bind сам автоматом создает связь между обычным файлом
/root/uts-temp и  nsfs[uts:[4026532440]]

таким образом если мы будем обращаться к /root/uts-temp в утилитах которые умеют работаь с неймспейсами
(типа nsenter) то эти утилиты смогут добратьсядо nsfs.

сам по себе файл /root/uts-temp на диске в форме байтов ( если мы вытащим диск вставим в другой комп
и посмотрим что же хранится там в этом файле). там ничего нехранится.

это система налету когда мы обращаемся к файлу фищическому она пробрасывает прозрачно 
туда в кишки nsfs.

вся эта хрень сделана чтобы поддерживать линукс концепцию что все структуры в линуксе это типа файлы.
просто мы привыкли что файл это кусок на диске.  а это более общее понятие.
это типа путь . по которому мы можем обратиться и попасть хрен знает куда. можем на диск
а можем и в памят ядра.

таким образом мы узнал что такое persistent неймспейс.
конешно после перезагрузки наш файл /root/uts-temp больше небудет 
никуда вести. потому что и неймспейс исчезнет при отключении компа. и связь уже небудет никуда вести.
потому что связь она незаписана на диске. это чисто линукс в памяти у себя держал такой хук.
мол если будут обращаться к такому то файлу то пробрасывать внутрь ядра.

то ест вот это слово persistent оно относится не к потере электричества и у нас все выжило.
оно относится к тому что процесса нет приаттаченного к неймспейсу а неймспейс при этом живет 
неуничтожается. вот смысл слова персистент.

мельком взглянем на findmount

root@test-kub-03:/root# findmnt
TARGET                                SOURCE     FSTYPE     OPTIONS
/                                     /dev/sda1  ext4       rw,relatime,errors=remount-ro,data=ordered
├─/sys                                sysfs      sysfs      rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/security              securityfs securityfs rw,nosuid,nodev,noexec,relatime
│ ├─/sys/fs/cgroup                    tmpfs      tmpfs      ro,nosuid,nodev,noexec,mode=755
│ │ ├─/sys/fs/cgroup/systemd          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/lib/systemd/systemd-cgroups-agent,name=syste
│ │ ├─/sys/fs/cgroup/cpu,cpuacct      cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,cpu,cpuacct
│ │ ├─/sys/fs/cgroup/freezer          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,freezer
│ │ ├─/sys/fs/cgroup/net_cls,net_prio cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,net_cls,net_prio
│ │ ├─/sys/fs/cgroup/pids             cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,pids
│ │ ├─/sys/fs/cgroup/devices          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,devices
│ │ ├─/sys/fs/cgroup/hugetlb          cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,hugetlb
│ │ ├─/sys/fs/cgroup/memory           cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,memory
│ │ ├─/sys/fs/cgroup/blkio            cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,blkio
│ │ ├─/sys/fs/cgroup/cpuset           cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,cpuset
│ │ └─/sys/fs/cgroup/perf_event       cgroup     cgroup     rw,nosuid,nodev,noexec,relatime,perf_event
│ ├─/sys/fs/pstore                    pstore     pstore     rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/debug                 debugfs    debugfs    rw,relatime
│ └─/sys/fs/fuse/connections          fusectl    fusectl    rw,relatime
├─/proc                               proc       proc       rw,nosuid,nodev,noexec,relatime
│ └─/proc/sys/fs/binfmt_misc          systemd-1  autofs     rw,relatime,fd=36,pgrp=1,timeout=0,minproto=5,maxproto=5,direct
├─/dev                                udev       devtmpfs   rw,nosuid,relatime,size=1004076k,nr_inodes=251019,mode=755
│ ├─/dev/pts                          devpts     devpts     rw,nosuid,noexec,relatime,gid=5,mode=620,ptmxmode=000
│ ├─/dev/shm                          tmpfs      tmpfs      rw,nosuid,nodev
│ ├─/dev/mqueue                       mqueue     mqueue     rw,relatime
│ └─/dev/hugepages                    hugetlbfs  hugetlbfs  rw,relatime
├─/run                                tmpfs      tmpfs      rw,nosuid,noexec,relatime,size=204828k,mode=755
│ ├─/run/lock                         tmpfs      tmpfs      rw,nosuid,nodev,noexec,relatime,size=5120k
│ └─/run/user/1000                    tmpfs      tmpfs      rw,nosuid,nodev,relatime,size=204828k,mode=700,uid=1000,gid=1000
├─/root/uts-temp                      nsfs[uts:[4026532440]]
│                                                nsfs       rw
├─/root/vasya                         /dev/sda1[/tmp]
│                                                ext4       rw,relatime,errors=remount-ro,data=ordered
└─/var/lib/lxcfs                      lxcfs      fuse.lxcfs rw,nosuid,nodev,relatime,user_id=0,group_id=0,allow_other

если df -h покащзывает только классические точки монтирования

t# df -h
Filesystem      Size  Used Avail Use% Mounted on
udev            981M     0  981M   0% /dev
tmpfs           201M   21M  180M  11% /run
/dev/sda1        20G   14G  5.1G  73% /
tmpfs          1001M     0 1001M   0% /dev/shm
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs          1001M     0 1001M   0% /sys/fs/cgroup
tmpfs           201M     0  201M   0% /run/user/1000

то findmnt показывает их все.

например findmnt опзкаывает все бинды

например

├─/root/vasya                         /dev/sda1[/tmp]

то есть это значит что папка /tmp на /dev/sda1 она прибиндена в /root/vasya

поэтому я бы скзаал что findmnt это более расиренная и современная версия старого df -h

кратно скажу про sysfs и procfs. 
procfs более старая. 
sysfs более новая.

старая procfs неимеет четких правил че и как там держать.
новая sysfs имеет.

sysfs это как бы апргреженная и цивилизиированная версия procfs

однако невсе структуры програмитсы линукса будут переносить из procfs в sysfs.

изначально полтьзотвательсуие утилиты типа ps они лезли в /dev/mem и читали сырую память
типа того и оттуда находили инфо о процессах запущенных на компе.

вот чтобы эту фигню прекратить придумали procfs в которой информаци о процессах размещена
в виде папок и файлов.

тоесть изначально proc была придумана чтобы юзерские утилиты могли получать иформацию 
о процессах запущенных в удобной форме. то есть изначально это справочная по процессам.
потом ее функционал подрасширили.

ладно. возвращаемся к неймспейсам.

 
насколько я понял . когда мы создаем неймспес и тут же к нему аттачим процесс.
то вот этот вот файл  /proc/[pid]/ns/[type] на proc он ведет конечно тоже на nsfs
то есть

t# ls -1al  /proc/1/ns
lrwxrwxrwx 1 root root 0 Jun 18 00:41 uts -> uts:[4026531838]

файл /proc/1/ns/uts он через биндинг ведет на nsfs к хрени по имени nsfs[4026531838]

а когда мы с помощью unshare 

# unshare --uts=/root/ns-uts

создаем неймспейс то с помощью биндинга nsfs [23423423] имя неймспейса пробрасывается на обычный файл на фс 
а не на proc файл. 

вот и весь механизм.
и когда у нас ссылка на неймспейс хранится в proc то в findmnt об этом нет никакого упоминания.
а когда у насс ссылка ведет на обычный файл на диске то тогда ссылка в findmnt появляется про nsfs

вот и вся разница между персистент и неперсистент неймсейсов.

если персистент - значит ссылка на его имя в nsfs  привязана (прибиндена) к файлу на диске
если неперсистент значит ссылка на имя неймспейса в nsfs привязана к файла на proc.

ну и мол зачем нам перситсент неймспейсы. затем что мы хотим чтобы у нас были неймспейсы которые
неприязаны к конкретному процессу. ну и например был неймспейск нему был привязан процесс.
ссылка на имя неймспйса хранилась по пути /proc/$PID/ns/имя
когда процесс умер то папка /proc/$PID исчезает и мы теряем ссылку на неймспейс.
а может нам он еще нужен.
тогда если мы заранее сделаем биндинг на файл  в nsfs привяжем его к какому нибудь файлу на диске
то при уничтожении процесса мы ссылку на неймспейс непотеряем.

это как хардлинки на классической фс на файл. если  у нас есть 5 хардлинков то если мы удалим
все 5 то файл то на диске остался но связь с ним зацепка ниточка путь потерян. 
поэтому нужен хотя бы один хардлинк. тоже самое с именами неймспейсов.

возвращаемся к mount неймспейсам

команда unshare.

по умолчанию когда мы в bash запускаем команду то она запускается ровно в тех же неймспейсах
что и сам bash сидит.

так вот unshare позволяет запустить программу у которой все или какие мы захотим неймспейсы
будут другими новыми отличными от тех которыми обладает bash

пример

смотрим какой PID имеет текущий сеанс bash

root@test-kub-03:/root# echo $$
4935

запускаем новый баш у котрого хотим чтобы mount неймспейс был другой

root@test-kub-03:/root# unshare -m bash

ключ -m означает что мы хотим mount неймспейс другой чем у родительского баша.

узнаем PID дочернего баша

root@test-kub-03:/root# echo $$
23369

смотрим какой "номер" mount неймспейса имеет родительский баш

root@test-kub-03:/root# ls -l /proc/23369/ns/ | grep mnt
lrwxrwxrwx 1 root root 0 Jun 18 01:30 mnt -> mnt:[4026532441]


смотрим какой "номер" mount неймспейса имеет дочерний баш 

root@test-kub-03:/root# ls -l /proc/4935/ns/ | grep mnt
lrwxrwxrwx 1 root root 0 Jun 18 01:30 mnt -> mnt:[4026531840]

видим что разные.

если мы напишем не так

# unshare -m bash

а вот так

# unshare -m 

то это равнозначно. 
как я понимаю.
типа unshare он если ему неуказать какую прогу запускать то он клонирует тот процесс из котрого 
его запускают. а мы запускаем его из баша.

то есть 

# unshare -m bash  == # unshare -m 

итак unshare нам позволяет запустить программу и у нее получить неймспейсы отличные от сеанса
баша из которого мы запускаем unshare.
новыми могут быть все неймспейсы или часть. как нам хочется.

далее. двигаем еще ближе уже к mount неймспейсам.

если у нас есть два маунт неймспейса, и мы создадим в одном из них приватную точку монтирования
то в другом неймспейсе эта точка монтирования и все что вней будет невидно 
в другом mount спейсе.

здесь вылезли вот эти вот приватные точки монтирования. это отличается от того к чему
мы привыкли в сетевых неймспейсах.
в сетевых неймспейсах там по дефолту все сетевые карты одного неймспейса 
невидят все сетевые карты другого неймспейса.

в маунт неймспейсах несколько по другому.
мы изначально невсегда хотим полностью изолировать структуру список папок
и точек монтироавния которые видны одному процессу и другому процессу.

часто мы хоотим чтобы часть папок была видна в обоих неймспейсах
а часть чтоб была невидна. вобщем вся эта куралесица взаимосвязи видомости части папок
между разными неймспейсами делает маунт неймспейс несколько отличным от сетевого неймспейса
. там мы четко хотим чтобы карты одного полностью невидели карты другого.
так вот возвращаясь к маунт неймспейсам. поэтому появляются приватные точки монтирования,
расшаренные точки, мастер , слев.

будет шас это все смотреть.

берем две консоли баш. консоль-А и консоль-Б

вот что точно работает 

в консоли-Б делаем:

консоль-Б # unshare -m bash
консоль-Б # mkdir /mnt/02
консоль-Б # mount -n -o size=1m -t tmpfs tmpfs /mnt/02
консоль-Б # touch /mnt/02/petya.txt

в консоли-А пробуем увидеть папку /mnt/02 и файл /mnt/02/petya.txt

консоль-А # ls -1 /mnt
01
02

папка видна

консоль-А # ls -1 /mnt/02

а файл petya.txt невиден


строка mount -n -o size=1m -t tmpfs tmpfs /mnt/02
позволяет нам подмонтировать к папке не реальный физ диск а виртуальных RAM диск.

получается что в новом маунт неймспейсе мы создали папку.
в нее примонтировали типа диск.
таким образом папка стала точкой монтирования.
на этой точке монтиования мы создали файл. и он уже невиден в консоли-А.

важно подчеркнуть что вот эта вот невидимость работает только 
для точек монтирования. если мы в консоли-Б  создадим файл в простой
папке то консоль-А этот файл будет виден 

теперь надо разобраться 
что будет если в консоли А создать теперь точку монттирования. будут ли файлы 
в новой точке монтиоавния видны в консоли Б

разобрался - вот что я сделал в консоли-А

консоль-А # mkdir /mnt/A-01
консоль-А # mount -n -o size=1m -t tmpfs tmpfs /mnt/A-01
консоль-А # touch /mnt/A-01/A-01.txt

после этого в консоли-Б файла A-01.txt невидно.

~# ls -1 /mnt/A-01

получается что неважно кто кому там родитель.
имеем такое - что имеем два маунт неймспейса.

если в одном из них (любом) создаем точку монтирования , монтируем туда диск, создаем 
там файл то в другом маунт неймспейсе точка монтирования видна, но файлы на ней 
уже невидны.

откроем третью консоль-С. узнаем PID-ы консоли А и консоли Б.
с помощью nsenter войдем в mount спейсы этих консолей.
и проверим видимость папок. она должны быть в точности как только было выше.
таким образом мы проверим что мы умеем входит в маунт неймспейсы. 
что нам и нужно при работе с конейнерами а именно нам нужно видеть как изнвутри
контейнера выглядит его файловая система. а для этого надо научиться определять 
маунт неймспейс контейнера и входит в него.

консоль-А PID = 2706
консоль-Б PID = 4474


консоль-С # nsenter --mount=/proc/2706/ns/mnt ls -1 /mnt/02

консоль-С # nsenter --mount=/proc/2706/ns/mnt ls -1 /mnt/A-01
A-01.txt

(мы вошли в маунт спейс консоли А и увидели ровно то что должны были увидеть)



консоль-С # nsenter --mount=/proc/4474/ns/mnt ls -1 /mnt/02
petya.txt

консоль-С # nsenter --mount=/proc/4474/ns/mnt ls -1 /mnt/A-01

(мы вошли в маунт спейс консоли Б и увидели ровно то что должны были увидеть)


вывод - мы научились находит маунтспейсы процессов.
и научились видеть файловую систему так как ее видят процессы а ля в будущем контейнеры.

|||||||||||>>>>>>>далее:

*надо узнать как увидеть все точки монтирования. и все файлы на компе.
получается findmnt она покащывает только те точки монтирования которые лежат в нашем
маунт неймспейсе. например для консоли-А

# findmnt
└─/mnt/A-01                           tmpfs      tmpfs      rw,relatime,size=1024k

для консоли-Б
# findmnt
└─/mnt/02                             tmpfs      tmpfs      rw,relatime,size=1024k

то есть что логично - что разные маунт неймспейсы они невидят чужие точки монтирования.

а нам как root надо знать обо всех файлах и папках на системе.

ответ на этот вопрос: 
по первых для процесса $pid все точки монтирования что он видит
можно посмотреть в /proc/$pid/mounts

*также я тут сразу еще затрону родительские-дочерние маунт неймспейсы.
что чего как.
как я понял когда мы создаем новый маунт неймспейс то новый 
маунт неймспейс создается не из воздуха. новый неймспейс всегда как я понял
создается только на основе уже какогото существующего.
единственное что первый неймспейс создается с нуля.
так вот каждый маунт неймспейс он содержит список маунт поинтов.
так вот когда создается новый неймспейс как я уже сказал он создается
обязательно на основе уже другого существующего. так вот новый неймспейс получает от старого копию точек монтирования.
как я пока понял посмотреть какой неймспейс  у какого родитель 
нельзя. 
насколько я понял утилиты которая бы показывала список маунт неймспейсов
ее нет. есть lsns но она гавно. чтот показывает чтото нет.
самый прямой способ это просканировать /proc/**/ns/mnt
сравнить с дефолтным. и все что отличаются вывести списком.
далее зная "номер" маунт неймспейса можно через nsenter в него зайти 
и посмотреть что там есть в плане файловой системы. также если мы хотим  посмотреть только на список майнт поинтов то можно посмотреть в /proc/$pid/mounts. из этого  я делаю такой страншный вывод: утилиты 
которая бы показывала все маунт  неймспеймы на компе нет, увидеть какой 
маунт неймспейс родитель а какой ребенок нельзя, утилиты которая бы позволяла увидеть все файлы спрятанные на компе на всех маунт поинт неймспейсах нет. поэтому сделать поиск по всем маунт неймспейсам нельзя.
нужно брать писать скрипт который будет брат каждый процесс в /proc
брать его маунт неймспейс и сканировать файлы в нем. это жопа.
возникает вопрос. а если мы сидим в неймспейсе в котором часть /proc 
отрезана заблокирована. тогда мы понятия небудем иметь о том другом
майнт неймспейсе потому что иформацию о существовании другого неймспейса
мы черпаем из файловой системы /proc получилась рекурсия.
вот такой ответ на вопросы - как увидеть все файлы на компе во всех маунтнеймспейсах и как узнат кто родитель кто child между маунт неймспейсами. ответы на эти вопросы - никак. 

*shared private и прочие маунт неймспейсы. что за хрень.
точки монтирования в данном маунт неймспейсе могут быть - 
шаред
прайвет
слейв
анбиндабл

как нам узнать какое из этих свойств имеет некоторая 
точка монтирования

во первых надо узнать список всех точек монтирования 
для нашего маунт неймспейса

# cat /proc/$$/mounts

но тут непоказано какое свойство (шаред прайвэт слейв ) имеет точка
монтирования. это мжоно посмореть в другом месте

# cat /proc/$$/mountinfo

783 22 0:40 / /run/user/1000 rw,nosuid,nodev,relatime shared:142 - tmpfs tmpfs rw,size=204828k,mode=700,uid=1000,gid=1000

вот видно что /run/user/1000 точка монтирования 
имеет свойство shared

монтируем рамдиск в /mnt/01
# mount -t tmpfs -o size=1M tmpfs /mnt/01

смотрим какое свойство получила точка монтирования

~# cat /proc/$$/mountinfo | grep '/mnt/01'
849 24 0:189 / /mnt/01 rw,relatime shared:150 - tmpfs tmpfs rw,size=1024k

видим что shared

теперь очень важное дполенение - вот эти вот свойства точки 
монтирования - шаред прайвет слейв андиндабл они уже работают 
в рамках одного маунт неймспейса. то есть мы уже все это можем прочуствовать
посмотреть проверить в рамках того же самого одного маунт неймспейса.
необязательно задействовать еще один маунт неймспейс.

анбиндабл точка монтирования - это такая что ее нельзя
перемонтировать в другую папку с помощью mount --bind

# mkdir /mnt/02
# mount -t tmpfs -o size=2M tmpfs /mnt/02
# mount --make-unbindable /mnt/02
# cat /proc/self/mountinfo | grep '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime unbindable - tmpfs tmpfs rw,size=2048k

имеем аннбиндабл точку монтирования.

пробуем ее смонтировать в другую папку через --bind

# mkdir /mnt/03
# mount --bind /mnt/02 /mnt/03
mount: wrong fs type, bad option, bad superblock on /mnt/02,
       missing codepage or helper program, or other error

       In some cases useful info is found in syslog - try
       dmesg | tail or so.

неможем.
вот это и есть смысл свойства андиндабл
для точки монтирования

рассмотрим точку монтриования со свйоством прайвэт

# mount --make-private /mnt/02
root@test-kub-01:~# cat /proc/self/mountinfo | grep '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k

видим что вместо свойства прайвэт оно рисует '-'

пробуем биндануть такую точку монтироавния

~# mount --bind /mnt/02 /mnt/03
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/03'
1020 24 0:190 / /mnt/03 rw,relatime shared:152 - tmpfs tmpfs rw,size=2048k

успешно.

делаем что /mnt/03 оно тоже прайвэт

~# mount --make-private /mnt/03
root@test-kub-01:~#
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/02'
947 24 0:190 / /mnt/02 rw,relatime - tmpfs tmpfs rw,size=2048k
root@test-kub-01:~#
root@test-kub-01:~# cat /proc/self/mountinfo | grep -E '/mnt/03'
1020 24 0:190 / /mnt/03 rw,relatime - tmpfs tmpfs rw,size=2048k

итак у нас /mnt/02 забинден на /mnt/03
и оба они прайвэт.

если я скопирую файл в любую из этих папок 
то файл будет виден в обоих папках.
так что покачто ничего нового и интересного.

создадим точку монтирования в кишках /mnt/02

# mkdir /mnt/02/A
root@test-kub-01:~#
root@test-kub-01:~# mount -t tmpfs -o size=2M tmpfs /mnt/02/A

копируем файл в /mnt/02/A

и он невиден в /mnt/03/...

создадим точку монтирования в кишках /mnt/03

~#  mkdir /mnt/03/B
# mount -t tmpfs -o size=2M tmpfs /mnt/03/B

копируем файл в /mnt/03/B

и он невиден в /mnt/02/...

таким образом. если у нас есть точка монтирования /mnt/02
она имеет свойство прайвэт, 
далее эту точку монтирования смонтировалив еще одну папку /mnt/03 через --bind

 то все  субточки монтирования в /mnt/02 например /mnt/02/A будут невидны
в другой папке /mnt/03

тоесть какбы флажок прайвеэт означает что изменнеия в точке монтирования
/mnt/02 небудут распостраняться на ее бинд клоны. клоны ничего об 
измненеия в /mnt/02 знать небудут. 

также важно понять (я прверил) что неважно когда была создана 
субточка монтирования внутри /mnt/02 дотого как на /mnt/02 натравили
--bind или после.  в обоих случаях в /mnt/03 субточки монтирования /mnt/02
будут невидны.

при этом в /mnt/03 будут видны все файлы самой папки /mnt/02
и если мы будем удалят добавлять файлыи папки в /mnt/02 то это все 
будет также обнволяться в /mnt/03
то есть вся эта котовасия с флажком прайвэт имеет силу не для самой точки 
монтирования /mnt/02 а для ее субточек монтирования.
это конечно дебилизм усложняет путаницу и добавляет сложности понимания
на пусто м месте.

витоге я бы сказал так - если точка монтиоавния имеет свойство 
прайвэт это значит что ее субточки монтиорвания будут видны только в самой
этой папке. и небудут видны в зеркалах которые созданы через --bind

таким образом флажок прайвэт делает субточки монтиорвания невидимыми
на зеркалах --bind

еще раз важно понять что сила свойство прайвэт отнсоится к субточкам
монтиоррования. содержимое же самое папки /mnt/02 будет отлично
видно на всех зеркалах --bind. 

окей.

итак у нас есть папка /mnt/02 
это точка монтиования.

она имеет флажой прайвэт.

и внутри этой папки есть куча подпапок которые являются субточками
монтирования.

так вот если мы сделаем зеркало /mnt/02 но с флагом --rbind 

# mount --rbind /mnt/02 /mnt/06

то в папке /mnt/06 будут видны все субточки монтирования.
то есть rbind полностью игнорирует свойство private

но! если мы после этого в /mnt/02 создадим +1 новую точку субмонтирования
то в /mnt/06 она уже небует видна.

жесть...

далее

свойство shared.
она обратное от прайвет
и оназнчает что все субточки монтирования в /mnt/02 также будут видны
будут появляться во всех зеркалах --bind
то есть изменененеия с субточками монтирования в /mnt/02 прилетают
во все зеркала --bind

получается анбиндэбл рассмотрели
прайвэт расмотрели
шаред рассмотрели

остался слейв.

если точка мониования имеет свойство слейв это значит что 
эта точка приимает информацию об изменения но не отправляет.
то есть принимать принимает. а отправляь неотправляет.

пример.

/mnt/02 = shared

/mnt/03 это --bind от /mnt/02 и 
/mnt/03 это слейв.

тогда если мы создадим субточку монтирования 

# mount -t tmpfs -o size=1M tmpfs /mnt/02/AA

то поскольку /mnt/02 = shared то /mnt/02 отправи информацию об этом 
во все зеркала
поскольку /mnt/03 = слейв то он примет эту информацию и будет видна 
субточка монтиорания /mnt/03/AA

а если мы создадим  

# mount -t tmpfs -o size=1M tmpfs /mnt/03/BB

то поскольку /mnt/03 это слейв он информцию о своей субточке 
монтиования /mnt/03/BB отсылать никуда небудет. поэтому в 
/mnt/02 небудет видна субточка /mnt/02/BB

опять же важно понять что вся эта фигня имеет отношение только  к субточками
монтирования а не к просто папкам. 
про просто папки можно забыть.

то есть если мы сосздаим просто папку /mnt/03/rrrr
то конечно она будет видна в /mnt/02/rrrr

потому что это прсто папки а не субточки монтирования.


далее прочитаем оф доку.
для этого прежде всего читаю - https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
прежде всего мы работает не с папками. мы работает с точками монтирования.
точка монтирования это базовая исходная основная единица с которой
мы и будем работать дальше.
также важно сказать что мы пока что вообще нетрогаем маунт неймспейсы.
это нас сейчас вообще неколышет.

прикольно что дока говорит о mounts и о mount points. в чем разница ???
дока постулирует что точку монтирования можно реплицировать (забиндить)
хоть на миллион других точек монтирования если исходная точка монтирования
имеет свойство shared. типа как хардлинки 
на жестких дисках

#  mkdir /01
   mount -n -o size=10M -t tmpfs tmpfs /01
   mount --make-shared /01
   mkdir /02
   mount --bind /01 /02
   

~# cat /proc/self/mountinfo | grep -E '/01|/02'

1101 24 0:194 / /01 rw,relatime shared:175 - tmpfs tmpfs rw,size=10240k
1103 24 0:194 / /02 rw,relatime shared:175 - tmpfs tmpfs rw,size=10240k

видно что и /01 и /02 = shared

делаем /02 = private

# mount --make-private  /02
1103 24 0:194 / /02 rw,relatime - tmpfs tmpfs rw,size=10240k

видно что если никакого слова нет. значит точка монтирования = private   
   
сделаем /02 обратно = шаред

# mount --make-shared /02

если в /01 положим файл /01/vasya.txt

то в /02 видим этот файл /02/vasya.txt

создадим субточку монтиования /01/A
положим в нее файл. 
сделаем /01/A прайвэт и посмотрим будет ли файл виден в /02

ответ  - да будет виден. 
в итоге я получил непонятнй результат. я создал кучу вложенных приватных
субточек монтирования в /01 и они все видны в /02. любая глубина вложенных
приватных субточек монтиования в /01 видна в /02
как бутто это значит что если /02 это миррор от /01 и если /01 = shared
то в /02 будет всегда при всех условиях видна полная структура /01

изначально моунт спейсез приудлумывались чтобы 
они были независимыми друг от друга.
но насколько я щас понимаю ... мысль прервыается.

есть процесс.

# echo $$

можно посмотреть какой маунт неймспейс подключен
к этому процессу

root@test-kub-02:~# ls -1al  /proc/$$/ns
lrwxrwxrwx 1 root root 0 Jul 24 16:45 mnt -> mnt:[4026531840]

врзникают вопросы:
1)а что к процессу может быть подключен только один маунт неймспейс?
2) а какая связь между точками монтирования и маунт неймспейсом

навскидку непонятна связь между маунт неймспейсом и точками 
монтирования. как найти связь как посмротреть

берем строку из /proc/$$/mountinfo

18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw

18 =  номер маунта.  mount ID этой точки монтирования.
 
я вообще нифига ненашел что это и как это использовать.
в man proc сказано 
mount ID: unique identifier of the mount (may be reused after umount(2)).
я вообще ненашел ничего ни в man mount ни в man umount
про это

24 = ID родительского mount 

эти цифры пока что остаются загадкой.

0:17 = это типа диск (sda итп) так зашифровано название

/ =  root of the mount within the filesystem. что это такое тоже непонятно
я посмотрел на живой системе этот столбик всегда = /

shared:7 = это озгначает что данная точка монтирования расшарена
то есть общая с peer группой 7.

что такое пир группа - 

маунт неймспейс это множество маунтпоинтов

получается что то что мы видим в /proc/pid/mountinfo - это список маунтпоинтов
которые составляют вот этот маунт неймспейс /proc/pid/ns/mnt

еще раз 

здесь указан маунт неймспейс /proc/pid/ns/mnt
а здеь указан список маунтпоинтов которые составляют тот неймспейс - /proc/pid/mountinfo

итак маунт неймспейс это список точек монтирования.

как я понял новый неймспейс создается обязательно  на основе
уже какогто существующего неймспейса.

и новый неймспейс создается путем копирования всех точек монтирования
из исходлного неймспейса

сказано что по дефолту дальнейшие изменнеия со списком точек монтирования
невидны между неймспейсами.
замечу!что когда мы работаем с маунт неймспейсами то модификация касается
только точек монтирования! маунт неймспейсам аюсолютно похеру на файлы и 
папки. абсолютно похеру! работа с маунт неймспейсами касается
только модификации списка точек монтирования!

написано что каждый маунт неймспейс принадлежит некоторому юзер неймспейсу

пишут что маунт неймспейс и пир группа неодноитоже

далее важно отметить что свойства - шаред слейв анбиндабл итп это все
свойства относящиеся к маунт поинту (а не маунт неймспейсу).
таким образом эти свойства мы назначаем в рамках одного неймспейса
к маунт поинтам. таким образом мы можем насладиться и увидеть все 
фишки применения этих свойств (шаред слейв итп) в рамках одного
неймспейса.  а другой неймспейс даже и ненужен.

значит в маунт неймспейсе событьия которые могут происходить с
маунт поинтами это всего навсего - либо новый маунт поинт создался
либо маунт поинт был уничтожен. вот ивсе.

значит если маунт поинт имеет свойство SHARED то как я понял 
если внутри этого маунт поинта создается или уничтожается суб-моунт-поинт
то точно такое действие происходит во всех других маунт поинтах
которые входят в одну пир группу с нашим маунт поинтом.
вот такая чушь.

получается конечно тупая замудреная система. есть маунт спейс. в нем
список точек монтирования.
берем несколько точек монтирования. обьединяем их в пир группу.
далее берем одну из точек монтирования в пир группе. назначаем ей
свойтсво SHARED.  далее создаем субточку монтирования в этой точке 
монтирования и наступает наконец самое главное - информация о том что была
создана субточка монтирования распостраняется на все точки монтирования в пир
группе 

возникает вопрос что такое пир группа. и какой смысл по группе распотсранять
инфо о появлении новой субточки монтирования у одного из члена группы.

следущее свойство маунт точки = PRIVATE. если точка монтирования
имеет это свойство то точка монтиования невходит нив какую пир группу
и события внутри этой точки монтирования невылетают наружу другим точкам
монтирования. и события о новых субточках монтирования в других
точкам монтирования в эту точку монтирования неприлетают.
такая классическая автономная точка монтирования.

точка монтиования может иметь свойство SLAVE.
это значит что данная точка входит в пир группу (типа мастер группа)
из которой в нашу точку придлетают события.
то есть оттуда сюда. а вот наоборот неработает. то есть соьытия в нашей
точке туда неулетают.
но. есть еще момент. наша исходная точка монтирования может входить
еще в одну пир группу там где она является полноценным членом.
и получается события между членами этой пир группы будут передававться
полноценно. еще раз.

точка-А (входит в мастер пир группу-А как полноценный член).
точка-Б (входит в мастер пир группу-А как слейв)
точка-Б (также вхдодит в пир группу-Б как полценоценный член)
точка-С (вхдоит в пир группу-Б как полноценный член).

тогда событие в точке-А прилетит в точку-Б
а вот событие в точке-Б неприлетит в точку-А
но событие в точке-Б прилетит в точку-С

точка может иметь свойтсво UNBINDABLE. это тоже самое что и PRIVATE
но плюс  к этому ее нельзя смонтировать через mount --bind

остается два вопроса. первое как создавать пир группы.
и как летают события между точками которые сидят в разных
маунт неймспейсах.

далее написано что вот эта вся байда с событиями верна только для субточек монтирования которые лежат ровно на один уровень ниже нашей точки монтирования.

пример

точка монтиоврания = /mnt/01
ее субточки монтиования первого уровня = /mnt/01/A, /mnt/01/B
только информация о них (создания и уничтожение) будет передваваться 
пир членам. события о точках монтиирования более глубокого залегания (удаление и создание) небудет передаваться членам пир группы.


это еще раз подтверждает дебилизм архитектруры системы маунт поинтов.

как добавить точку монтирования в пир группу.
во первых точке монтирования нужно присвоить свойство SHARED.

во вторых если есть скажем два маунт неймспейса. один из них 
соотвесвтенно получим путем копирования из другого. 
то скажем /mnt в одной маунт неймспейсе и /mnt в другом неймспейсе
будут засунуты в одну пир группу. (при условии как я сказал в первом 
условии что /mnt имеет свойство SHARED ).

ха! вот она связь между точками монтированимя в разных маунт неймспейсах.

был /mnt в первом маунт неймспейсе. и /mnt имел свойство SHARED,
потом этот маунт неймспейс скопировали и создлали +1 маунт неймспейс.
при этом /mnt во втором неймспейсе будет включен в пир группу с /mnt
из первого маунт неймспейса.

есть еще вариант как добавить точку монтирования в пир группу.
во первых надо чтобы выполнялось первое условния (точка должна иметь свойство
SHARED) и второе данную точку монтиирования надо забиндить

# mount --make-shared /mnt/01
# mount --bind /mnt/01 /mnt/02

так вот /mnt/01 и /mnt/02 будут входить в одну пир группу.

таким оборазом мы наконец узнали ответ на два главных вопроса.
как точки монтирования попадают в пир группы. и как настроена связь
между маунт поинтами ккоторые сидят в разным маунт неймспейсах.

потому что здесь это все намешали в кучу. кучу говна.

напимсано что если точка монтирования шаред и в ней создать субточку
монттирования то она автоматом получает свойство шаред. и как я понял
субточка монтирования создаст новую пир группу.

написано что узнать какое свойство (шаред приват итп) имеет точка
морнтирования можно из /proc/pid/mountinfo

пример


18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw

shared:7 насколько я понял это значит что данная точка монтирования /sys
имеет свойство shared и что и принадлежит к пир группе номер 7 !

18 и 24 это не номера пир групп. нееееет!

насколько я понял каждая точка монтирования от ядра получает 
уникальный номер. 18 это номер точки монтирования для /sys от ядра.

практический смысл точки монтирования непронятен.в мане нарписано что
им можн ополтьзоваться  когда сделлаи umount. непонятно.

24 это номер другой точки монтирвания. какой же ?
это номер точки монтирования  к которой наша точки монтирования прикреплена.

пример есть две точки  / и /mnt так вот / является роидительской
точки монтирования для /mnt

еще пример

/sys/fs/cgroup и /sys/fs/cgroup/systemd
так вот /sys/fs/cgroup является родителтской точкой монтирования для 
/sys/fs/cgroup/systemd

тоесть родительская точка монтииования это путь к папке в которой наша 
точка монтирования и находится

еще пример точка монтирования /home является родительской для 
точек монтирования /home/vasya ,   /home/petya

а /home/vasya уже является родительской для /home/vasya/tmp

  
итак еще раз мы раскрыли тайну строки из /proc/pid/mountinfo

18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw

точка монтирования /sys имеет свойство shared и лежит в пир группе 7.
для /sys номер ее маунта для ядра = 18
точка /sys лежит в точке монтирования /.  для /sys родительтской точкой
монтииования я вляется /.  точка монтирования / имеет для ядра номер 24

18 и 24 это не номера пир групп. это номера точек монтирования для ядра.
номер пир группы 7.

еще раз mount ID и peer group ID это разные вещи.

18 и 24 это mount ID
7 это peer group ID

пир груп ID начинаются с 1
маунт ID начинаются с 0

если маунт точка имеет свойство шаред то в /proc/pid/mountinfo будет
указано

shared: X

где X - это номер пир группы.

если точка анбиндабл то будет указано 

unbindable

дальше тупизм. если ничего неуказано то это private точка.
реальный дебилизм

если для точки указано 

master: X

то (внимание еще дебилизм) это значит что точка slave! в пир группе X

далее. для маунт поинта может быть свойство propagate_from:X
оно идет всегда в купе с master:X
зачем тогда propagate_from:X нужно. 
оно используется тогда когда процесс (/proc/pid) неможет непосредственно
"увидеть" в своем списке каталогов точку монтирования точки монтирования 
которые принадлежат к пир группе X.

и щас мы разберем как так на практике может получится:


получается --bind это как +1 хардлинк к файлу.

выяснилась очеердная непонятная хуйня.
непонятно как работает команда chroot.

# mount --bind / /mnt
# mount --bind /proc /mnt/proc
# echo $$
4122
# ls -1al /proc/$$/ns
# cat /proc/$$/mountinfo


#chroot /mnt
# echo $$
8114
он поменялся

# ls -1al /proc/$$/ns

маунт неймспейс НЕПОМЕНЯЛСЯ.
но при этом

# cat /proc/$$/mountinfo
куча точек монтирования исчезла.

что за хуйня. ведь изначально утверждалось что 
маунт неймспейс это список точек монтирования.
получается есть два процесса. они сидят в одном маунт неймспейсе.
но при этом ссука видят разные список маунт поинтов.

пиздец нахуй блядь.

получается что майнт неймспейс это список точек монтирования
при условии что на процесс неприменили chroot

полезная инфо

# cat /proc/self/mountinfo  | grep -E 'shared:1 '
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1
451 24 8:1 / /vasya rw,relatime shared:1 - ext4 /dev/sda1

отсюда правило. если есть точки монтирования у которых одна и таже 
запиьс вида 

shared:1

значит обе точки монтирования ведут к одному и томуже.

прикольно что вот есть свойство shared на точке монтирования 
и оно будет распостранять ивенты не об списке папок внутри себя нет нихуя.
оно будет распстранять информацию о точках монтирования внутри себя. ебаные точки монтирования. а папки похуй. забыть про папки когда мы говорим про 
shred private итп.

вся эта тема конченая и ебанутая. именно архитектурно. 
наверно индусы придумывали.

например.

если мы возьмем точку монтирования и забиндим ее в другую папку
то мы получим новую точку монтирования в этой папке

# cat /proc/self/mountinfo  | grep '/ / '
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1

# mkdir /petya
# mount --bind / /petya

# cat /proc/self/mountinfo  | grep -E '/ / |/petya '
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1
486 24 8:1 / /petya rw,relatime shared:1 - ext4 /dev/sda1

видно что /petya стал тоже shared и что и / и /petya 
входят в одну пир группу 1.

тоесть что инфо о новых точках субмонтирвания в / будут показаны в 
/petya
и что новые точки субмонтрования в /petya будут показаны в /

делаем /petya приавтным

# mount --make-private /petya


~# cat /proc/self/mountinfo  | grep -E '/ / |/petya '
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1
486 24 8:1 / /petya rw,relatime - ext4 /dev/sda1 

видим что /petya больше нешаред.
внутри /petya попрежнему такой же список папок как и в /
но если мы создадим новую точку субмонтирования в / то она небудет
показана в /petya

и новая точка субмонтирования в /petya небудет показана в /

# mkdir /01
# mount -n -o size=1m -t tmpfs tmpfs /01

самое причем ебанутое. что точка субмонтирования все таки сука
будет показана. небудет видно содержимое этой папки.
тоесть здесь тоже суки все замудрили на пустом месте.

так вот содержимое /01 будет видно только из под /
а в /petya 01 будет виден но содержимое папки небудет видно.

итак субточка монтирования в / не видна в /petya 
это мы проверили.

# mkdir /petya/02
# mount -n -o size=1m -t tmpfs tmpfs /petya/02

я проверил.
в /petya/02 видно содержимое папки.
а в
/02 видна только папка. а содержимое пустое.

итак подтвердилось что приватная точка монтирования /petya
ни сама непринимает снаружи новые субточки монтирования 
ни из нее наружу эта инфо невылетает.

при этом замечу что фишка --bind никак несвязана с shared, private
от того что мы на точке монтирования будет менять шаред на прайвет
итд от этого bind никак неменяется и неотваливается.

что у нас такое точка монтирования. это папка и одновременно это файловый путь к которому можно прикрутить файловую иерархию.
это папка к которому можно прикрутить другую папку.
а что такое папка. во первых она имеет адрес путь в файловой структуре.
во вторых она содержит список подпапок и подфайлов. которые в свою 
очередь могут иметь подпапки и подфайлы.

если у нас есть папка /mnt которая содержит список подпапок 01 и 02
то бинд позволяет  этот список из 01 и 02 перенести в другую папку

# mount --bind /mnt /kolya

теперь 01 и 02 видны и в /kolya

если 01 и 02 были бы файлами то как бы /mnt и /kolya это два хардлинка
к 01 и 02. один дом у которого две двери с разных сторон в одни и теже 
комнаты.

тоесть бинд позволяет получить доступ к некоторму списку подпапок и файлов
не по исходному пути а по альтернативному.

типа симлинка.

так вот прикол в чем состоит.
когда у нас в /mnt появляются новые файлы и папки например /mnt/03 
/mnt/tt.txt то новые файлы и папки они без проблемы видны и через /mnt
и через /kolya .тут все отлично. новые подпапки и новые подфайлы видны 
по обоим путям и через /mnt и через /kolya

но совершенно другая хуйня происходит когда у нас в /mnt или в /kolya
появляются непросто новые подпапки а новые блядь субточки монтирования.
тут начинается совершенно другая хуйня.

если /mnt и /kolya оба шаред и оба сидят в одной пир группе.
то появление новых субточек монтирования в одной папке будут видны в
другой. и наоборот. но если /mnt и /kolya имеют свойство private
то появление по одному пути новой субточки монтироавния нихуянебудет 
видно подругому пути. если в /mnt появится новая субточка монтивтания /mnt/03 то в /kolya  /kolya/03 будет видет но содержимое папки будет
невидно. тоесть измеения в забинденных папках видны в обоих местах
только если появляются новые файлы и папки. если же появляются новые 
субточки монтиврования тут совершенно другой коленкор.
будет ли в одной папке видно измеение в другой зависит от свойств
шаред приват слейв которые навешены на /mnt и /kolya 

опять же как я понимаю. изменние свойства на точке монтирования с шаред 
на приват влияет только на НОВЫЕ ИЗМЕНЕИЯ. все старые "видимые" хуевины 
будут продолжаться быть видны. изменения будут касаться только новых изменений в плане субточек монтирования после. тоесть видимые точки
монтирования после смены свойства шаред на прайвэт на точке монтирования
на текущую видимую структуру папок неприведет. ничего неотвалится.
ебнутая тема. пиздец.

поэтому вопрос . вот у меня есть точка монтитвания на ней есть свойство
шаред  я его меняю на прайвет что произойдет. ответ нихуя непроизойдет.
нихуя. все что видно будет видно попрежнему.
все изменения будут касаться новых субточек монтирования.

если /mnt и /petya были шаред. а потом мы сменили на /petya свойство на
приват. то только субточки монтитвания которые будет созданы в /mnt после 
того как мы дали /petya private небудут видны в /petya

мудота связана с тем что точка монтиирования это непросто папка 
хотя она так и выглядит. точка монтирования это нечто большее.
как алмаз это непросто булыжник хотя и камень. тоже самое про просто 
папки и точки монтировангия

опять важн опонять что две точки монтироавния дожлны быть непросто обе
шаред а должны еще принадлежать к одной пир группе.

еще важно. как я понял . если у нас две точки монтирвоания входят в одну
пир группу.и мы сделали одну из точек приватной. то обратно вставить
эту точку в пир группу уже нихуя никак неполучится.
если мы ее сделаем шаред то у нее будет своя собственная новая
пир группа. наверное едиснстенные путь это заново папку биндить
из старой папки.

пример


# mkdir /04
# mount --bind /04 /04
# mount --make-shared /04

# mkdir /06
# mount --bind /04 /06

# cat /proc/self/mountinfo | grep -E '/04|/06'
501 24 8:1 /04 /04 rw,relatime shared:1 - ext4 /dev/sda1
545 24 8:1 /04 /06 rw,relatime shared:1 - ext4 /dev/sda1 

видим что /04 и /06 принадлежать к одной пир группе 1

делаем /06 приватной точкой

# mount --make-private /06
root@test-kub-02:~# cat /proc/self/mountinfo | grep -E '/04|/06'
501 24 8:1 /04 /04 rw,relatime shared:1 - ext4 /dev/sda1
545 24 8:1 /04 /06 rw,relatime - ext4 /dev/sda1

даелаем /06 шаред

# mount --make-shared /06
# cat /proc/self/mountinfo | grep -E '/04|/06'
501 24 8:1 /04 /04 rw,relatime shared:1 - ext4 /dev/sda1
545 24 8:1 /04 /06 rw,relatime shared:164 - ext4 /dev/sda1


видим что /06 стала шаред но в абсолютно новой другой пир группе.


если я создам файл \ папку в /04 оно будет безпроблем видно в /06
тоже самое если я создам файл\папку в /06 оно буде проблем
тутже будет видно и в /04
но АБСОЛЮТНО ДРУГАЯ ХУЙНЯ если я начну создавать субточки 
монтирования в /06 или  в /04
если я создам новую субточку монтирования в /04 она нихуя небдует 
видна в /06 . потому что /06 невходит в одну пир группу с /04

это пиздец. гдлавное новые файлы и папки видны и там и там без проблем
но абсолютно другой коленкор с субточками монтивроания.
тоже саоме для /06, если я в ней создам новую субточку монтиврания
то она НИХУЯ небудет видна в /04

это как бутто ты заходишь в квартиру с разных входных дверей и 
новые стулы и стулья видны с какой бы ты двери низашел.
а вот новый видик виден только если зашел из двери номер 1. пиздец.
ссуки на этих важных моментах в своих ебучих доках вообще 
внимание не акцентируют. уебки .
точнее еще раз скажу сами субточки будут видны и в /04 и в /06
но содержимое папко будет пусто.простоя заебался поправлсяться про это.

смена свойств в шаред на приват итп влияет на натекущую картину что 
видно в папке. а на последующую картину. на картину что будет твориться
потом после когда когда начнут создавать новые субточки монтиварония после.
на новые субточки монтиварния. все старое остается без имзенений.

итак имеем две папки.
одна является биндом другой.
но они сидят в разных пир группах.

# cat /proc/self/mountinfo | grep -E '/04|/06'
501 24 8:1 /04 /04 rw,relatime shared:1 - ext4 /dev/sda1
545 24 8:1 /04 /06 rw,relatime shared:164 - ext4 /dev/sda1


создаю в /06 новую субточку монтиварония
дальше какая хуйня енпонятная пошла.


заново.

# mkdir /10
# mkdir /11
# mount -n -o size=1m -t tmpfs tmpfs /10
# mount --bind /10 /11


# cat /proc/self/mountinfo | grep -E '/10 |/11 '
556 24 0:120 / /10 rw,relatime shared:165 - tmpfs tmpfs rw,size=1024k
565 24 0:120 / /11 rw,relatime shared:165 - tmpfs tmpfs rw,size=1024k


видно что /10 и /11 входят в одну пир группу.

делаем /11 приватным. далее делаем ее шаред

# mount --make-private /11
# mount --make-shared /11

# cat /proc/self/mountinfo | grep -E '/10 |/11 '
556 24 0:120 / /10 rw,relatime shared:165 - tmpfs tmpfs rw,size=1024k
565 24 0:120 / /11 rw,relatime shared:182 - tmpfs tmpfs rw,size=1024k

видно что /11 входит в другую пир группу.

теперь по идее в теории если мы в /11 создадим новую субточку
монтирования /11/А то в /10/А содержимое будет невидно.

# mount -n -o size=1m -t tmpfs tmpfs /11/A

я проверил .так и есть.
в /11/A файл лежит 
а в /10/A его нет.

сука. почемуто ровно такая же хуйня но превращение папки в маунт точку
нечерез mount -n -o size=1m -t tmpfs tmpfs /11/A а через mount --bind
приводит совершенно к другим результамттм. то есть с --bind дополнеттельная
ебала. но ее  я пока оставлю.

а теперь внгимание важный эксперимент.
у нас есть субточка монтиваония /11/A 

и тут я запущу вот такую команду

# mount --bind /10 /11

смешно то что она прокатила.
и /11/А   стало пусто. ровно как это есть в /10/А

тоесть субточка /11/А исчезла с лица земли.
похуй линуксуна то что в /11/А была субточка монтирования.

но можно отменить --bind

# umount /11

вуаля! и субточка /11/A опять видна. ее содержимое.

далее надо разобрать вариант с 

propagate_from:X 

он появляется на слейв точке монтирования когда 
точка монтирования к которой он привязан недоступна в рамках
текущей файлово системы.

условно говоря мы /proc засунем в /mnt/proc 
далее сделаем /mnt/proc слейвом.
потом сделаем chroot в /mnt и уже /proc нам недоступен.

пример
# mount --bind / /mnt
# mount --bind /proc /mnt/proc
# mount --make-slave /mnt/proc
# chroot /mnt
# cat /proc/self/mountinfo
303 24 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 
344 303 0:4 / /proc rw,nosuid,nodev,noexec,relatime master:12 - proc 

прикол в том что propagate_from:X  непоявился для /proc
хотя точка монтирования для которой пир группа = 12 теперь невидна 
и недоступна для данной файловой структуры.
ну и хуй с ним.
поясню зачем мы биндили / в /mnt и еще /proc в /mnt/proc
дело в том что для того чтобы сделать chroot в той папке должны 
быть файлы и папки чтобы мог автомтом стартовать bash. поэтому
мы в /mnt биндим /,  а для того чтобы посмотреть mountinfo нам
в /mnt нужен еще и проц. поэтому нам приходится биндить
эти обе точки монтирования.
если мы просто зачирутимся в произвольную папку то мы этого просто несможем
сдеать. во первых линукс напишет что неможет запустить /bin/bash
а если мы сделаем так что баш запуститься то без наличия proc
мы не сможем посмотреть mountinfo.
вот проэтому все так.






!!! наконец посмотреть в /proc/pid/mountinfo для контейнера чтобы 
наконец узнгать где же контейнер хранит свою файловую систему

имеем контейнер c nginx

# docker inspect 6ff6fea5d68c

находим там pid

 "Pid": 21265
 
 зная pid мы можем узнать mountinfo. 
 то есть все точки монтирования которые видит процесс

# cat /proc/21265/mountinfo

и в самой верхней строчке мы видим

466 388 0:96 / / rw,relatime master:109 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work


неочень понимаю эту запись.
вот как выглядит запись для обычного корня на линуксе

24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro

видно что корень монтируется из устройства /dev/sda1
все понятно

а в верхней строчке для контейнерного процесса корень монтируется
из /var/lib/docker/... но позвольте / еще нет . тогда как можно монтироваться
/ на основе его субпути. хуйня какаято.
хотя наверное нехуйня.

а обьяснение такое. все что идет после слов master:109 это опции монтирования
данной точки монтирования которые были применены не к данно точке монтирования
а к ее родительской точки монтирования которую потом забиндили.
тоесть есть родительская точка монтииования 

/vasya , которую монтиролвали с параметрами 

overlay rw,lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work


потом эту точки монтирования забиндили.и ее отдали контейнерному процессу.
и mountinfo так устроен что он показыается для всех и родительских и дочерних
точек монтирования параметры монтиирования родительской точки монтирования.
поэтому теперь понятно что дочернаяя точка конечно никакой каталог
/var/lib/docker/overlay2 невидит.
его видит только самая верхняя невидимая для нам точка монтирования.

проверим.
сразу добавлю что когда монтируем оверлейФС то мы указыаем несколько
каталогов: lowerdir (их тоже может быть несколько штук сразу) - это каталог только на чтение, upperdir, workdir. хрен знает что из них каждый
делает но финальный результат показывается в каталоге mergedir или другими
словами в точке монтироавния.

то есть в mount мы указываем mount -t overlayfs  lowerdir,upperdir,workdir /точка_монтирования

из верхней строки мы видим что 

lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7

upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff

workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work

и то что точка монтирования  = /

но стоп. прикол в том что мы и хотим найти этот / но уже на нашей файловой
системе хоста.

наверно прикол в том что процесс конейтнера лежит в другом маунт спейсе.


ладно. пока что мы зайдем к вопросу с другой стороны.
получим инфо из докера

# docker inspecr $PID

и видим

  "LowerDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c-init/diff:/var/lib/docker/overlay2/c361f573d628d9f5b9d064373de4d7753436ff86663fba20cb211b8ede62c5e5/diff:/var/lib/docker/overlay2/723190a9632b1a1f4040286c9840261a35aa8cc2e943a7271517d8f8acb06833/diff:/var/lib/docker/overlay2/0933c48b3bdf8a9a3efa7efc3968fe6425b3878b041add6e961590f88f8896e8/diff:/var/lib/docker/overlay2/bdd6630675e988b2ec399b6de6f2da22817d302013bbf4b818edfb9cc1d35e0a/diff:/var/lib/docker/overlay2/ebd8f8ddbcfca6a98334252558badc1d1eb162e5feaf3d5cd072472b3a736b0b/diff",

  "MergedDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged",
  
  "UpperDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff",
  
  "WorkDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work"


таким образом корневая сиситема контейнера лежит в 
mergedir =  "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged"

так ну по крайней мере хоть както научились искать где же на диске
лежит файловая система контейнера. так что 
теперь без проблем можно там редактировать файлы без уебанской мудоты.

осталось только понять как эту ФС находить штатными методами 
линукса.

чтоб все это понять надо понять как меняется парметры монтирования ФС при недоступности 
корневой мастер пир точки в том же маунт неймспейсе и в другом
неймспейсе 

посмотрим на сразу на примере оверлейфс так как она именно и юзается
в контейнерах.

я смонтировал в папку оверлейФС

# mount -t overlay -o lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir overlay /dev/shm/merged

тогда в mountinfo видим строку

# cat /proc/self/mountinfo | grep -E '/dev/shm'
387 26 0:107 / /dev/shm/merged rw,relatime shared:114 - overlay overlay rw,lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

оверлейФс нам позволяет из нескольких папок в итоге слепить одну.
lowerdir=/dev/shm/lowerdir в этой папке лежат файлы только на чтение доступные
upperdir=/dev/shm/upperdir - в этой папке вроде бы будут лежать все измененные
данные
workdir=/dev/shm/workdir это какая то служеюбная папка нужная для внетренней
кухни оверлейФс вроде так.

а итоговая папка смонтирована в /dev/shm/merged

как мы видим точка монтирования с оверлейфс в mountinfo содержит всю 
строку параметров lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir
которую мы использовали в команде mount и также видна точка монтирования
/dev/shm/merged

сейчас никаких проблем нет. так как для данного процесса доступна как 
финальная папка /dev/shm/merged так и папки с lowerdir upperdir и workdir

так. сейчас немного переделаем монтаж оверлейФС так чтобы у нас lowerdir был равен / , чтобы мы могли потом забиндить /dev/shm/merged в другую папку,
сделать ее слейвом, сделать туда chroot и в итоге посмотреть как 
из под той новой папки будет выглядеть mountinfo.
потому что у нас исходная папка будет недоступна.

итак . монтируем оверлейфс еще раз.

кстати оказвыается все merged папки от контейнеров показывает df -h
поэтому путь к ним даже типа и искать неприходится

# df -h

m# df -h
Filesystem      Size  Used Avail Use% Mounted on
/var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/merged
overlay          20G  8.7G  9.9G  47% /var/lib/docker/overlay2/65dbe972eaeed8ce7f93a6071887e7ca33531be8ade816d212be4a8fcc377afe/merged
shm              64M     0   64M   0% 


другое дело что непонятно какой контейнер к какой папке относится.


также получается что буквально вся файловая система контейнеров
она чисто физически живет в /var/lib/docker/overlay2/

так что этот раздел надо выносить на отдельную точку монтирования на 
отделный сторадж.
чтобы в случае чего его можно было расширить итп.
именно там и лежат все контейнеры. вся их файловая структура

ладно. возврашаемся  к нашей оверлейфс

# mount -t overlay -o lowerdir=/,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir overlay /dev/shm/merged

# mount --bind /proc /dev/shm/merged/proc

# cat /proc/self/mountinfo | grep -E '/dev/shm'
387 26 0:107 / /dev/shm/merged rw,relatime shared:114 - overlay overlay rw,lowerdir=/,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

432 387 0:4 / /dev/shm/merged/proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw

прикольно что из mountinfo можно узнать параметры переданные в mount
точку монтирования переданную в mount но непонятна точка монтирования источника указанная в mount

тоесть берем строку

387 26 0:107 / /dev/shm/merged rw,relatime shared:114 - overlay overlay rw,lowerdir=/,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir


из нее мы узнаем что

/dev/shm/merged = точка монтирования
lowerdir=/,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir = параметры
переданные в mount а исходной точки монтирования нет . ну окей при 
монтировании оверлейфс ее и нет. но возьмем другую строку

432 387 0:4 / /dev/shm/merged/proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw


/dev/shm/merged/proc = точка монтирования
ну параметров типа нет
и самое главное что непонятна исходная точка монтирования.

тоесть глядя в сроку из mountinfo трудно восстановить оригинальную строку
команды mount которая была источником.

вот самая классическая строка 

24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

/ = точка монтиррования
errors=remount-ro,data=ordered = параметры указанные в команде mount
/dev/sda1 = а это исходная точка монтирования , источник при монтировании

смотрим на этот кусок в строку маунтинфо

- ext4 /dev/sda1

и делаем такой вывод. что 
идет '-' минус, потом тип файловой системы ext4 а потом типа источник.

посмотрим по аналогии что мы имеем в  этом случае для оверлейфс строки
в маунт

- overlay overlay = получается минус, потом название файловой системы = оверлей,
а потом источник монтирования типа это оверлей.

посмотрим для proc

- proc proc = служебный  минус. потом тип фс = proc, и потом 
типа источник монтирования = proc, ну и типа надо догадаться что это 
значит что /proc

итак после монтирования оверлея мы имеем

# cat /proc/self/mountinfo | grep -E '/dev/shm'

387 26 0:107 / /dev/shm/merged rw,relatime shared:114 - overlay overlay rw,lowerdir=/,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

432 387 0:4 / /dev/shm/merged/proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw

эта информация имеет отношение к нашему процессу.
и важно заметить что наш процесс имеет доступ ко всем папкам (путям)
указанным в mountinfo

теперь мы сделаем chroot в /dev/shm/merged
при этом наш новый процесс уже небудет иметь доступ к следущим путям:
lowerdir=/,
upperdir=/dev/shm/upperdir,
workdir=/dev/shm/workdir

при этом мы посмотрим что будет для черутного процесса указано в
mountinfo

# cat /proc/self/mountinfo
387 26 0:107 / / rw,relatime shared:114 - overlay overlay rw,lowerdir=/,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir
432 387 0:4 / /proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw

хотя прикол вот в чем ! - хотя наш черутнутый процесс неимеет
доступа к "исходным" путям 
lowerdir=/,
upperdir=/dev/shm/upperdir,
workdir=/dev/shm/workdir
но они же забиндены! и по факту действительно доступны для процесса!

просто с точки зрения исходной файловой системы исходного процесса мы бы имели путь
/dev/shm/upperdir/dev/shm/upeerdir
к папке которая для нового процесса имеет путь = /dev/shm/upperdir
но по факту папка то одна и таже!

получается что по факту все круто.
у исходного процесса в маунт инфо была указана папка для примера
upperdir=/dev/shm/upperdir

и она ему доступна

для новго процесса в маунт инфо указана папка 
upperdir=/dev/shm/upperdir

и она по этому пути и лежит !

ну а то что для старого процесса папка /dev/shm/upperdir имеет путь 
/dev/shm/upperdir/dev/shm/upperdir так ничего страшного.

поэтому я был неправ когда написал для контейнера и его записи в 
маунтинфо 

# cat /proc/21265/mountinfo

466 388 0:96 / / rw,relatime master:109 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work

что якобы c точки зрения контейнера невидны пути lowerdir,upperdir,workdir
хмм... вобще то несовсем понятно.
так! тут я забыл что я то оверлейфс тестировал с биндингом все 
корневой файловой системы. это гавно.


сейчас все переделаем будем смотреть другой вариант.
нам надо избавиться от биндинга корневой файловой системы.

копируем из /bin в /dev/shm/merged
создаем /dev/shm/merged/proc и биндим туда /proc

в итоге имеем две папки

/dev/shm/merged/bin
/dev/shm/merged/proc

на самом деле чтобы chroot сработал надо еще скопирвать две папки

/lib --> /dev/shm/merged
/lib64 --> /dev/shm/merged

только тогда баш сможет запуститься в черут.

я сделал черут но тут понял что я же никакой оверлейфс незамаунтил.

так что создаем папку /dev/shm/merged/01

и в нее маунтим оверлейфс

(понимаю что неочень хорошо вышло с названиями папок ибо оверлейфс 
будет смонтирван не в merged а в ./merged/01 но переделывать небудем)

# mount -t overlay -o lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir overlay /dev/shm/merged/01

смотрим запись в маунтинфо для этого маунта

# cat /proc/self/mountinfo | grep -E '/dev/shm/merged/01'

430 26 0:107 / /dev/shm/merged/01 rw,relatime shared:116 - overlay overlay rw,lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

на данный момент наш процесс имеет доступ на файловой системе
к папкам lowerdir, upperdir, workdir

делаем chroot

# chroot /dev/shm/merged

и вот наконец таки мы получили

# cat /proc/self/mountinfo
430 26 0:107 / /01 rw,relatime shared:116 - overlay overlay rw,lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

мы получили интереснейший результат.
для нашего нового черутного процесса в маунтинфо указаны папки lowerdir
upperdir workdir к которым он не имеет абсолютно никакого доступа

проверим

bash-4.3# pwd
/
bash-4.3# ls -1 /
01
bin
lib
lib64
proc
bash-4.3# cd /dev/shm
bash: cd: /dev/shm: No such file or directory

как видно никаких /dev/shm папок на доступной файловой системе
нет и в помине.

отсюда главнй и шокирующий вывод - если в mountinfo указаны
какието папки. это абсолютно незначит что данному процессу они доступны !!!!
ВАУ !!!
конечно для правды надо скзаать что речь идет о недоступности папок 
некоторые являются точами монтирования а папками которые содержаться в 
параметрах которые были указаны в при вводе команды mount.
теперь мы понимаем что данный mount может быть сделан не из данного процесса.
тоесть вот эта строка которую видит наш процесс

430 26 0:107 / /01 rw,relatime shared:116 - overlay overlay rw,lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

означает что точку монтирования = / к которой наш процесс
имеет доступ кто то где то когда то замаунтил для нас через
команду mount с параметрами
lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir
и это абсолютно нефакт что это было сделано в рамках нашего процесса.
ну и я говорю что самое главное - что абсолютно нефакт что данному процессу
доступны те папки которые указаны как параметры команды mount.
ВАУ! Это удвительно нелогично!

поэтому ! возвращваеся к живому контейнеру и его записи в mountinfo

# cat /proc/21265/mountinfo

466 388 0:96 / / rw,relatime master:109 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work


теперь то мы знаем! что процесс контейнера имеет запись в маунт инфо 
о корневой точке монтирования. что данная точка монтирования
имеет mount параметры 
lowerdir=/var/lib/docker/...
upeerdir=/var/lib/docker/...
workdir=/var/lib/docker/...
и что это абсолютно неозначает что данные папки должны быть 
доступны в рамках ФС нашему процессу контейнерному. ВАУ!
как нелогично но это так! ВАУ!

теперь то мы знаем что запись в маунтинфо означает что процессу доступна
корневая точка монтрования = '/' которую ктото для него смонтировал
с теми параметрами что указаны. и что абсолютно нефакт что папки указанные
в параметрах доступны конкретно нашему процессу. они ему недоступны и это 
нормально. но они чисто для общего развитися все равно указаны в mountinfo.

помне это очень дебильно. по мне маунтифно должен показывать инфо 
о точках монтироавния сточки зрения самого процесса. и если чтото ему недоступно то это тогда ненадо указыавть в mountinfo. 

нО! тут мы вспоминмаем что mountinfo это файл на файловой системе proc
а файловая система proc типа наверно она выдает информацию несточки зрения
того пользователя\процесса или этого пользователя\процесса. она ее выдает
с точки зрения ядра. которому доступно все. во как!
поэтому когда мы вводим cat /proc/pid/mountinfo 
то мы получаем информацию не с точки зрения процесса $PID и не для него.
мы получаем информацию с точки зрения стороннего наблюдателя - ядра. ну и 
типа для него. а яядру как я уже сказал доступны вообще все папки.
так что все нормально....
ВАУ!как все странно.
но опять же. точка монтирования в mountinfo втоже время указывается не 
с точки зрения ядра а сточки зрения процесса. то есть = '/'
так что все таки ВАУ!

теперь все равно остается вопрос о том что из mountinfo
мы видим что точка монтирования = '/'
а нам же надо узнат где эта папка сточки зрения фс иерархии хоста. сточки зрения процесса init.

вообще с этими биндами теперь путь к папке он неабсолютный а непойми какой.
тоесть если у нас есть какая фаловая иерархия то по факту совсем неясно
каая же она есть на физическом уровне.

например по физике путь к файлу = /dev/sda1/1/A
а на файловой системе он виде как /mnt/1/A

ну это ладно. нам надо научиться зная $PID узнавать где на иерархии фс
с точки зрения хоста находися фс контейнера.

контейнер видит как корень . о чем и написано в его mountinfo.
было бы удобнее если бы все записи в mountinfo были бы с точки зрения
файловой иерерархии именно хоста. но увы.

итак еще раз сточки зрения контейнера мы имеем

# cat /proc/self/mountinfo

430 26 0:107 / /01 rw,relatime shared:116 - overlay overlay rw,lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

мы имеем что для '/'  = shared:116

выйдем из черута и поищем в маунинфо хостовго процесса кто еще
имеет shared:116 кто еще входит в 116 пир группу

# cat /proc/self/mountinfo | grep -E 'shared:116'

430 26 0:107 / /dev/shm/merged/01 rw,relatime shared:116 - overlay overlay rw,lowerdir=/dev/shm/lowerdir,upperdir=/dev/shm/upperdir,workdir=/dev/shm/workdir

и мы видим что это /dev/shm/merged/01
ура! мы нашли то что искали.

теперь проделаем тоже самое для контейнера.

# cat /proc/21265/mountinfo

466 388 0:96 / / rw,relatime master:109 - overlay overlay 

мы имеем что для '/' = master:109

поищем кто с точки зрения init имеет shared:109

# cat /proc/1/mountinfo | grep 'shared:109'
376 24 0:96 / /var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged rw,relatime shared:109 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work

384 303 0:96 / 
/mnt/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged rw,relatime shared:109 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/EXY3YZV2YOMAU7ZBBNNH2W6ZGE:/var/lib/docker/overlay2/l/234PMVLXIUBOQPJHCKAMD2WQUM:/var/lib/docker/overlay2/l/ZRS2BBPN5COYAD5KSNDX32QGFM:/var/lib/docker/overlay2/l/76ETXT6LANYET2QEPMJJXPKPMM:/var/lib/docker/overlay2/l/SQK5UK3D5I6GJSNPISQ5GDRNIB:/var/lib/docker/overlay2/l/TVXC74YOTUGEOWHC7TF342XWH7,upperdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/diff,workdir=/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/work


получили два участника пир группы 109.
но можно заметить что верхняя точка монтирования /var/lib/docker
а нижняя точка монтирования /mnt/var/lib/docker
в общем по факту обе эти точки монтироваия ведут к одной папке.
то есть все участники пир группы они ведут в одно место. так что 
можно брать любого. а в целом обьясненение такое что мы же 
до этого забиндили / в /mnt поэтому две ссылки. в общем берем любую
например первую

"/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged"

это и есть тот сетевой путь где лежит фс контейнера. 
ура!!

сравниваем с тем путем что указан в docker inspect $Id

"MergedDir": "/var/lib/docker/overlay2/3fec7498aa64fd374a43aba5b222b546c46509e66f2dc3752dddf8025bc46e0c/merged"

как видим один в один !!

ура!! мы научились находить где же хранится ФС контейнера!
теперь мы можем ее легко редактировать. копировать туда файлы итд итп.!!!
без всяких мучительных "вхождений" в контейнер.
УРРРРРАААА!!!!


* сделаем разминку.
возьмем cat /proc/1/mountinfo
и проанализируем строки в нем. научимся их расшифровоаывать.

mountinfo напомню это список маунтпоинтов для процесса с $pid в его
маунт неймспейсе

18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw

18 - порядковый номер маунт поинта
24 - номер маунт поинта в списке каталогов которого находится этот маунт поинт
0:17 - major и minor номер устройства на котором расположена файловая система
данной точки монтирования
первое число (major) - это типа номер драйвера который обслуживает 
данный класс устройств
второе число (minor) - это уникальное число для данного устройства которое
позволяет отличить конкретно это устройство среди аналогичных этого же класса

но опять же есть тонкости особенности. у нас мажор номер = 0 . это означает что источником точки 
монтирования бекенд устройством является неустройство.

 и действительно мы видим что файловая система sysfs она виртуальная висит
 в оперативке. поэтому бекндом является не диск не устройство а некая
 виртуальная хрень. поэтому мажор номер = 0.
 
/ = к какму  пути примонтирована "родительская" точка монтирования
/sys = к какому пути примонтирована наша точка монтирования
rw,nosuid,nodev,noexec,relatime = опции монтирования переданные команде mount
shared:7 = наша точка монтирования имеет свойство shared. и принадлежит
пир группе номер 7
- sysfs sysfs = означает что файловая система sysfs и что исходным
устройством бекендом является ничего.
 

19 24 0:4 / /proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw

19 - номер точки монтироавния
24 - номер родительской точки монтирования.
точка монтирования это ко всему прочему еще и папка всегда.
так вот родительская точка монтирования это папка в спике которой
указана и папка текущей точки монтиования.
0:4 - типа обозначает номер устройства на котором как бы расположена
файловая система. тоесть бекенд устройство. 0 - номер драйвера устройства,
4 это номер устройства среди аналогичных от драйвера номер 0.
номер драйвера 0 означает что бекендом служит неустройство а хрень
из памяти. оно и логично. ибо файловая система proc она незаписана 
ни на каком устройстве. она лежит в оперативке
/ - путь в файловой иерархии  к которому прикреплена родительская
точка монтирования 24
/proc - путь к папке к которому прикреплена наша текущая точка монтирования
rw,nosuid,nodev,noexec,relatime - папаметры монтироавния которые были 
переданы команде mount 
shared:12 - точка монтирования имеет свйоство шаред и входит в пир группу
номер 12
- proc proc rw = файловая система proc исходное устройство оперативка



24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw, errors=remount-ro,  data=ordered

а вот мы дошли как смонтирована кореневая точка монтирования.

24 - номер точки монтирования
0 - номер родительской точки монтирования.
8:1 = номер бекенд устройства на котором физически расположена
файловая система текущей точки монтиварония.
8 обычно означает что устройство начинается /dev/sd*
1 это порядоквый номер устройство среди агалогичных sd* чтобы драйвер
их для себя друг от друга отличал
забегая вперед становится понятчто но 8:1 = /dev/sda
/ - куда смонтирована родителтская точка монтирования
/ - куда примонтрована текущая точка монтирования
rw,relatime = параметры монтироавния переданные mount
shared:1 = текущая точка монтирования имеет свойство shared и входит 
в пир группу номер 1
- ext4 /dev/sda1 = файловая система ext4, фс физически находится на 
устройстве /dev/sda1
errors=remount-ro,  data=ordered = опять же параметры монтирования переданные
команде mount



44 20 0:36 / /dev/hugepages rw,relatime shared:26 - hugetlbfs hugetlbfs rw

видна диковинная точка монтироавния.
попробвал в нее записать. недает.
создает файлы с нулевым размером.
пока оставим

46 24 8:17 / /mnt/disks/vdb1 rw,relatime shared:28 - ext4 /dev/sdb1 rw,data=ordered

еще одна обычная классическая точка монтирования.
ext4 на /dev/sdb1 смонтировано в папаку /mnt/disks/vdb1



97 24 0:41 / /var/lib/kubelet/pods/6908c56e-5b6a-40d4-9cb4-ed0cf5d1eb1e/volumes/kubernetes.io~secret/flannel-token-khbdr rw,relatime shared:78 - tmpfs tmpfs rw

какая то хрень сидящая в оперативке.

101 24 0:43 / /var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/merged rw,relatime shared:82 - overlay overlay rw,lowerdir=/var/lib/docker/overlay2/l/L57FD26VWNCVNNBJMY6IC5GVO2:/var/lib/docker/overlay2/l/6NCQUZK6XBBJMDAMKB4COYILVK,upperdir=/var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/diff,workdir=/var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/work

101 = номер точки монтирования
24 =- номер родительской точки монтирования
0:43 - типа бекенд устройство на котором физически лежит ФС.та как первое 
число 0 то означает что бекенд устройство нефизическое. а оперативка.
но так как это оверлейфс то надо щас проверить верно ли то.
надо провреить два случая : когда исходные каталоги лежат в оперативке
и когда merge каталог лежит в оперативке мол какой при этом 
major:minor будет рисовать линукс.

/= каталог куда примонтирована родителькая точка монтирования
/var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/merged = куда примонтирован финальный каталог оверлейфс

rw,relatime = парамтры переданные mount

shared:82 = точка монтироания имеет свойство шаред и входит в пир группу
номер 82

- overlay overlay rw = файловая система оверлейфс. исходное устройство
походу для нее нифига неуказыается ядром. а жаль. возможно 
потому что несколько исходных каталогов задается и они могут лежать
на разных устройствах. ну указал бы тогда их все через запятую но нет. пусто

lowerdir=/var/lib/docker/overlay2/l/L57FD26VWNCVNNBJMY6IC5GVO2:/var/lib/docker/overlay2/l/6NCQUZK6XBBJMDAMKB4COYILVK,upperdir=/var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/diff,workdir=/var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/work  = исходные каталоги переданные команде mount


106 22 0:3 net:[4026531957] /run/docker/netns/default rw shared:84 - nsfs nsfs rw

net:[4026531957] - типа куда примонтирована родительская точка монтиварония
/run/docker/netns/default = куда примонтирована текущая точка монтирования
nsfs = файлоая система
хрень та еще

113 24 0:45 / /var/lib/docker/containers/368670921d299f8aa18be2eb3bf35cca9c55b3c029ab4cb53629bb5a7d66b134/mounts/shm rw,nosuid,nodev,noexec,relatime shared:88 - tmpfs shm rw,size=65536k

какойто виртуальный диск tmpfs для контейнера зачемто нужный.
пока непонятно


95 22 0:40 / /run/user/1000 rw,nosuid,nodev,relatime shared:76 - tmpfs tmpfs rw,size=1023972k,mode=700,uid=1000,gid=1000
тоже непонятно зачем какойто вирт диск.


* оверлейФС
строка из mountinfo
101 24 0:43 / /var/lib/docker/overlay2/cb92cdc6a533c50e7c53bfdbe8d42594083eae3d26308802a4915b5c8b683408/merged rw,relatime shared:82 - overlay overlay ...

0:43 - типа бекенд устройство на котором физически лежит ФС.та как первое 
число 0 то означает что бекенд устройство нефизическое. а оперативка.
но так как это оверлейфс то надо щас проверить верно ли то.
надо провреить два случая : когда исходные каталоги лежат в оперативке
и когда merge каталог лежит в оперативке мол какой при этом 
major:minor будет рисовать линукс.




*возникают вопросы как это у корневой точки монтирования может быть 
родительская точка монтирования. что за бред.
непонятно как у корневой точки монтиварония может быть какойто 
родитель.

в доке к man написано что каждая точка монтирования имеет родиетльскую
точку монтирвания. хм..
также там написано 
In the case where a new mount is stacked on
       top of an existing mount, the parent of the new mount is the previous
       mount that was stacked at that location
	   
	  этого я непонял. мудота какаято.
	  
	  



* надо помотреть что будет с mountinfo для точки монтирования 
если ее родителтская точка монтирования становится недоступна

у нас есть процесс. он имеет доступ к древовидной структуре папок.
некоторые папки являются помимо папочности еще и точками монтирования.

чем папка отличается от папки-точки монтиования.

в целом структура папок которую видит процесс необязана иметь жесткий
диск как бекенд.

любая файловая структура которая видна процессу она имеет чтото своим бекендом. это может быть cd-rom, это может быть жетский диск, это 
может быть даже просто оперативка. бекенд это типа то место где файловая 
структура физически записана и хранится. , это может быть лента.

если мы берем папку то она гдето физически хранится. 
например берем папку /home/vasya
пусть это просто папка. 
у этой просто папки есть родительская папка /home
так вот там где это все физически хранится прям так и записано что ест папка home и у нее есть подпапка vasya. эта взаимосвязь между home и vasya физически
записана на том устройстве. это важно подчеркнуть что если мы говорим про обычные папки то на том устройстве где они хранятся четко физически
записано какая папка является подпапкой такойто папки.
например есть диск sda и на нем физически записано что есть папка home 
и у нее есть подпапки vasya petya kolya 
далее. если мы возьмем папку. на файловой системе видной для процесса.
и будем подыматься все выше и выше по файловому пути и каждый раз
спрашивать себя это просто папка или точка монтирования то рано или поздно
мы наткнемы на папку которая уже непросто папка а точка монтирования.
пример

берем папку /home/vasya , это просто папка
идем выше /home  , это тоже просто папка
идем выше / , и это уже непросто папка а точка монтирования.
это значит что на неком физической бекенд устройстве эта папка является 
самой корневой самой верхней. из нее все другие папки отходят.
то есть начиная из этой папки мы можем спуститься вниз и получить полный 
охват всех папок на данном физ устройстве.

итак если у нас просто папка то значит что на данном бекенд устройстве
это не самая верхняя папка. есть папка гораздо более выше из которой происходят все другие подпапки. эта самая верхняя папка обязательно 
будет являться точкой монтирования. 
эта самая верхняя корневая папка на данном физ устройстве она прикрепляется
к файловой системе процесса в некоторую папку. через которую все что там 
будет доступно.

пример.


/ - точка монтирования . бекенд устройство оперативная память.
в подпапках этой папки можно получить доступ ко всем папкам которые хранятся
в оперативке. к прмиеру /home , /mnt, /home/vasya

/mnt/01 - точка монтирования. бекенд устройство диск sdb
если мы задйем глубже /mnt/01/... то получим доступ ко всем
подпапкам которые хранятся на sdb
так как /mnt/01 это точка монтирования то все подпапки что глубже
они хранятся на устройстве sdb, а папка /mnt является просто папкой
ее точка монтирования это / и оно хранится в оперативке.
поэтому точка монтирования это всегда признак что соседние папки 
хранятся на одном бекенд устройстве а то что внутри точки монтирования хранится на другом бекенд устройстве.

аналогия еще такая. есть многквартирый дом. одни квартиры обычные.
а если зайти в дверь некоторых квартир то через портал попадаешь 
в квартиру которая физически находится в другом доме но войти можно через 
дверь исходного дома. это разница между обычной папкой и папкой точкой 
монтирования.


c одной стороны точка монтирования это путь к папке в файловой системе.
это файловый адрес. это как говорится где ее искать.
с другой стороны точка монтирования говорит о том что на каком то бекенд
устройстве записаны файлы и папки и через некоторый файловый путь  они 
доступны для процесса.
и точка монтирования дает доступ к самой корневой верхней папке на устройстве.
от которой идя вниз можно пуолчить доступ ко всем папкам ее файловой системы.

у каждой папки если это просто папка есть некая родительская папка
которая является точкой монтирования.


итак есть файловая иерархия доступная для процесса.
в этой иерархии есть просто папки а есть папки-точки монтирования.

возвращаемся к исходной вопросу. есть точка монтирования. и есть родительская точка монтирования. 

пример

/ = бекенд в оперативке. точка монтирования
/home  = просто папка (принадлежит  точке монтирования /)
/mnt = просто папка
/mnt/01 = бекенд на диске sda. точка монтирования
/mnt/01/vasya = просто папка.(принадлежит точке монтирования /mnt/01)
/mnt/01/petya = бекенд на cd-rom. точка монтирования.
для этой папки родительская точка монтирвания = /mnt/01

итак если есть две точки монтирования например /mnt/01 и /mnt/01/petya
то так как /mnt/01/petya является подпапкой /mnt/01 то /mnt/01 являетмся
родительской точкой монтирвания для /mnt/01/petya

что тут существенно. что мы имеем две точки монтирования.
и что одна из них лежит в подпапке другой точки монтирвания.


еще пример

первая точка монтирования = /
вторая точка монтирования = /mnt/01

тогда для второй точки монтирования первая является родительской.


еще пример

первая точка монтирования /mnt/01
вторая точка монтивоания /mnt/02
третья точка монтирования /

третья точка монтирования является родительской для первой и второй.
вторая и первая друг к другу неявляются никем.

итак если точка монтирования А является родительско для точки монтирования B
это занчит что B лежит  в подпапке A.

пример из mountinfo

161 24 0:65 / /var/lib/docker/overlay2/...

/ = первая точка монтирования
/var/lib/docker/overlay2/... = вторая точка монтирования.

поскольку вторая является подпапкой первой то для второй точки первая 
является родительской.

другим словами если есть родитель и есть ребенок. то это значт что в одной
из подпапок родителя мы найдем ребенка.
вот это суть связи между родительскй и ребнковской точками 
монтирования.

теперь надо подумать можнли ккак то сделать ттак чтобы
из папки ребенковской точки монтирования нельзя было попаст в папку
родительской точки монтирования.


/mnt - первая точка монтирования бекенд sda
/mnt/01 - вторая точка монтирования бекенд sdb

получаетс что /mnt является родиетской точкой монтирования для  /mnt/01

потом делаем chroot в /mnt/01 тогда /mnt/01 для процесса будет виден как /
ну и для / его родительской точкой монтирования являестся он сам.
по идее. то есть если папка = / то чьей подпапой он является с точки зрения
файловго пути. ну ничьей. только если своей собственной.
хотя по мне корень неявляется ничьей подпапкой. так как по определению 
папки с путем / это наивысшый файловый путь выше которого нет.

рассотрим живые примеры у каких точек монтирования какие родительские
точки монтииования. 

# cat /proc/1/mountinfo

18 24 0:17 / /sys 

точка монтирования /sys является подпапкой для /

19 24 0:4 / /proc 
20 24 0:6 / /dev 

аналогично

21 20 0:14 / /dev/pts

аналогично

22 24 0:18 / /run 
24 0 8:1 / / 

вот тут тот самый прикол. что типа корень является подпапкой корня. 
хотя  у корня неможет быть надпапок

25 18 0:12 / /sys/kernel/security 
26 20 0:20 / /dev/shm 
27 22 0:21 / /run/lock 
28 18 0:22 / /sys/fs/cgroup 
29 28 0:23 / /sys/fs/cgroup/systemd 
30 18 0:24 / /sys/fs/pstore 
31 28 0:25 / /sys/fs/cgroup/memory 
32 28 0:26 / /sys/fs/cgroup/cpuset 
33 28 0:27 / /sys/fs/cgroup/net_cls
34 28 0:28 / /sys/fs/cgroup/cpu
35 28 0:29 / /sys/fs/cgroup/freezer 
36 28 0:30 / /sys/fs/cgroup/perf_event 
37 28 0:31 / /sys/fs/cgroup/blkio 
38 28 0:32 / /sys/fs/cgroup/devices 
39 28 0:33 / /sys/fs/cgroup/pids 
40 28 0:34 / /sys/fs/cgroup/hugetlb
41 19 0:35 / /proc/sys/fs/binfmt_misc
42 18 0:7 / /sys/kernel/debug 
43 20 0:36 / /dev/hugepages 
44 20 0:16 / /dev/mqueue 
45 18 0:37 / /sys/fs/fuse/connections 
46 24 8:17 / /mnt/disks/vdb1 
93 24 0:39 / /var/lib/lxcfs 
95 22 0:40 / /run/user/1000 
97 24 0:41 / /var/lib/kubelet/pods/773ec87b-1b40-45c5-899b-2ea5e9bd6ece/volumes/kubernetes.io~secret/kube-proxy-token-jcn74
108 22 0:3 net:[4026531957] /run/docker/netns/default 

вот тут непонятно. по мне / является родительской точкой монтирования для
/run/docker/netns/default  потому что из корня можно попасть в папку /run/docker/netns/default  без проблем. поэтому причем здесь net:[4026531957] 
вобще непонятно. херня.

110 24 0:45 / /var/lib/docker/containers/6a5264dc0556b00dad6221674157df5af19cae81d38f6e917334b3a3fbfa20c1/mounts/shm 
112 24 0:46 / /var/lib/docker/overlay2/cf5b0fe57449d0d3336147ccad7c6c8e3f7de4596273a4228f3d4d90f0b67375/merged 

в целом понятн что из / можно попасть в любую подпапку. но 
если у нас есть точка монтирования которая прикреплена к какой то папке.
то для этой папки мы ищем ближайшую верхнюю папку которая при этом является точкой монтирования. она и будет родительской.

пример.

/ - точка монтиования

/mnt/01 - точка монтиоиания
/mnt/01/vasya - точка монтирования.

для /mnt/01/vasya родительская точка монтиования это /mnt/01 потому что на ближайщая на пути наверх. а не /. так как / является неближайшей наверх точкой монтирования.

вот пример.


421 378 8:1 /var/lib/kubelet/pods/63c02f92-bc65-4fb8-9d92-d31f68cb5cc0/containers/elasticsearch/ea76a706 /dev/termination-log

здесь якобы для точки монтиирования в папке /dev/termination-log родительской
точкой монтирования является  точка в папке /var/lib/kubelet/pods/63c02f92-bc65-4fb8-9d92-d31f68cb5cc0/containers/elasticsearch/ea76a706

и вроде бы бред написан. потому что поднимаясь наверх по файловому пути из 
/dev/termination-log мы никак неможем попасть в путь /var/lib/kubelet/...

но тут непонятно.

я взял и замаунтил tmpfs в /mnt/01

274 24 0:96 / /mnt/01 

ну понятно что для /mnt/01 родительской точкой монтирования = /

далее я в /mnt/01/B замаунтил tmpfs

324 274 0:97 / /mnt/01/B

но на удивление почему то для /mnt/01/B родительской точкой 
монтирования показана не /mnt/01 а /

что за бред

на мой взгляд сейчас могу сделать только такой вывод - что 
указанный в mountinfo родительская точка монтирования это
ненадежная неправидивая информация. на которую надо забить





* теперь надо понять как работает свойство шаринг когда участники 
пир группы сидят в разных маунт спейсах

что я обнаружил из опыта. если я создаю новый маунт-неймспейс через 
# unshare -m bash

то в новом маунт неймспейсе все точки монтирования ПОТЕРЯЮТ СВОЕ СВОЙСТВО SHARED !

пример. в исходном неймспейсе

18 24 0:17 / /sys shared:7 
19 24 0:4 / /proc shared:12
20 24 0:6 / /dev  shared:2

в новом неймспейсе

478 467 0:17 / /sys rw,nosuid,nodev,noexec,relatime
495 467 0:4 / /proc rw,nosuid,nodev,noexec,relatime
468 467 0:6 / /dev rw,nosuid,relatime

возникает вопрос есть ли между ними связь.

что происходит при создании нового маунт спейса - берется список
всех точек монтирования и копируется в новый маунт спейс.
но как я понял удаляются флаги шаред итп.
раз точка монтирования есть в списке в mountinfo то процесс
имеет доступ к фс что внутри точки монтирования.
если мы в исходном маунт спейсе создадим после этого новую субточку
монтированиято на небудет видна в новом маунт спейсе. 
и еслив новом маунт спейсе сооздать ночую субточку монтирования
то она будет невидна в исходном маунтспейсе.
а если мы хотим чтобы была такая точка монтирования чтобы новые
субточки монтирования созданные в ней в одном маунтспейсе были видна
в другом маунт спейсе как это сделать. например их любимый тупой пример
это то что  у нас есть точка монтирования /mnt и мы в исходном маунт
спейсе монтируес новую субточку монтирования /mnt/cdrom и хотим
чтобы она была видна в новом маунтспейсе. как это сделать.
тоесть исходная их мысль понятна - при создании маунт неймспейса  список точек
монтирования копируется и это хорошо. все что было видно встаром видно в новом. но дальше жопа. новая субточка монтирования в одном неймспейсе
невидна в другом. получается если я монтирую новый диск в одном неймспейсе
и хочу чтобы он был виднен во всех других неймспейсах его 
нужно монтировать индивидуально в каждом из неймспейсов отдельно персонально
индивидуально. мне кажнтся нуипохуй но они решили что нет и придумали жопу.
что еще важно подчеркнуть. маунт неймспейс работает не с файлами ни с папками
для него их несуществует. их он некасается. он работает со списком точек
монтирования. все. маунт спейсы были придуманы чтобы у процессов были 
свои индивидуальные только им досутпные субточки монтиорования. но втоже
время чтоб еще были общие для всех точки монтирования. команды mount и umount
создают и удаляют точки монтирования в списке точек монтирования в маунт неймспейсе.
прикольно что шаред и прочие свойства были придуманы изначлаьно для случая когда у нас несколько маунт нейспейсов.нескоько. и нам надо между ними создать
такую точку монтирования чтобы ее субточки монтирования новые которые будут
создавать уже после создания всех неймспейсов чтобы они были видны во всех
неймспейсах.итак изначально шаред придумана именно для случая несколько неймспейсов. несколко а неодин. то есть изначально пир группа придумывалась
чтобы увязать несколько неймспейсов единой хуйней. понятно что при создании
неймспейса он получает полуный список исходных точек монтироавния поэтому
все неймспейсы они видят все точки монтирования которые были на момент создания неймспейсов. тут проблем с видимостью нет. херня начинает я после.
когда мы в неймсейсах начинаем создавать новые субточки монтирования. и они
невидны между нееймспейсамми. вот тут на помощь и приходит шаред. для этого 
она придумывалась. и пир группы.
что дает согласно доке шаред херня. вот у нас есть точка монтирования.
ей можно присвоить свойство шаред. тогда субточки монтирования внутри 
этой точки монтирования будут видны ( и тут внимание какую хуйню они пишут ) - видны другим точкам монтирования. как бы что ? каким другим? и в каких 
маунт неймспейсах? ебанаты.
дальше они уточняют. что видны в других точках монтирования которые сидят с 
этой точкой монтирования в одной пир группе. ооо.. это уже чтото новое.
но все равно пока что недостаточно обьяснили.
дальше они подчеркивают что вот это свойства шаред и прочее они применяется 
работает ТОЛЬКО на субточки первого уровня монтирования. а на более глубокие 
субточки монтирования это свойство НЕРАБОТАЕТ. пример

точки монтироавния /mnt у не свойство шаред.
оно будет применяться только на субточки первого уровня
/mnt/01
/mnt/03
/mnt/vasya

а на более глубокие субточки монтирования
/mnt/01/A
/mnt/03/B
/mnt/vasya/01/06
свойство шаред НЕРАБОТЕТ.

работает \неработает якобы значит что такието субточки монтирования будут видны в пир группе или небудут.
тоесть якобы /mnt/01 будет видна в других неймспейсах в точках монтирования
которые члены пир группы. а /mnt/01/ddddd небудет видна.
это надо проверять. но так они пишут.
пир группы это ряд точек монтирования таких что если мы создадим новую
субточку монтирования в одной точке монтирования то ее увидят все другие
члены пир группы.
дальше они пишут. как точке монтирования попасть в пир группу.
если у нас есть исходный маунт неймспейс. в нем есть точка монтирования /mnt.
она имеет свойство шаред. дальше мы создаем новый неймспейс на основе этого
неймспейса. при этом в новый неймспейс копируется список всех точек монтирования исходного неймспейса. и вот в новом нейсейсе этаже точка
монтирования /mnt будет ходить в пир группу с /mnt из исходного неймспейса.
еще важно подчекрунуть что /mnt в исходном неймспейсе обязательно должен
иметь свойство шаред. также важно подчеркнуть что если у нас есть два неймспейса то всунуть точку монтировния в пир группу какую то  невозможно.
это происходит только на стадии создания неймспейса. когда он создан то все
жопа ничего непоменять. 
второй случай как точку монтирования добавить в пир группу. это если есть точка монтирования. и мы создаем новую точку монтирования с помощью  mount --bind ( причем как я понимаю
причем речь идет о работе в одном неймспейсе и исходная точка монтирования
опять же должна иметь свойство шаред).
вот такая вот хуйня была придумана. вызыавет тучу вопросов.
Типа в обоих случаях новая точка монтирования будет добавлена в пир группу
исходной точки монтирования.

пример.
  918  mount --make-private / 
  919  mkdir /mnt/X
  920  mkdir /mnt/Y
  924  mount --make-shared /mnt/X
  925  mount --make-shared /mnt/Y
 
проверяем что обе точки = шаред
# cat /proc/self/mountinfo | grep -E '/mnt/X|/mnt/Y'
334 24 0:100 / /mnt/X rw,relatime shared:116 - tmpfs tmpfs rw,size=10240k
335 24 0:101 / /mnt/Y rw,relatime shared:117 - tmpfs tmpfs rw,size=10240k

создаем новый маунт неймспейс

# unshare -m  --propagation unchanged  bash

И ТУТ ОЧЕНЬ ВАЖНО ПОДЧЕРКНУТЬ что мы используем флаг  --propagation unchanged
именно благодаря ему в новый неймспейс список точек монтирования будет
скопирован по всем правилам что описаны выше. а именно что в новом немспейсе
точки монтирования будут членами пир групп(то что описано выше). если этот флаг непоставить то все что описано выше окажется полной херней. 
ниодна точка монтирования в новом неймспейсе небудет членом ни одной пир группы ни при каких условиях при создании нового неймспейса. наоборот.
unshare сотрет все флаги шаред итп со всех точек монтрования в новом неймспейсе. поэтому этот флаг суперважен при запуске команды unshare

итак проверим что в новом неймспейсе наши точки монтирования 
сохранили флаг шаред и состоят в тойже пир группе что и исходные
точки монтирования

#  cat /proc/self/mountinfo | grep -E '/mnt/X|/mnt/Y'
471 337 0:100 / /mnt/X rw,relatime shared:116 - tmpfs tmpfs rw,size=10240k
472 337 0:101 / /mnt/Y rw,relatime shared:117 - tmpfs tmpfs rw,size=10240k

все так !

я изначально незнал про опцию --propagation unchanged и никак немог понять
почему в новом неймспейсе точки монтирования теряют флаг шаред.
 а как я уже также сказал что после того как неймспейс создан чтото поменять 
 внутри него невозможно. невозможно точки монтирования включить в какую то
 пир группу после создания неймспейса.
 
 что в итоге нам это дало.
 мы имеем два неймспейса.
 и если мы в исходном неймспейсе создадим субточку монтирования /mnt/X/01
 то она будет видна во втором неймспейсе. в той же папке.
 
 важно также подчеркнуть что хотя пути к точкам монтирования выглядят одинаково
 например /mnt/X в обоих неймспейсах но для ядра это совершенно разные точки 
 монтирования. 
 
 
 поскольку / в исходном неймспейсе приватный. то его субточки монтирования
 небудут видны  в новом неймспейсе. вот мы имеем уже второй неймспейс.
 создаем теперь новую субточку монтирования под / в исходном неймспейсе

# mkdir /kolya
#  mount -t tmpfs -o size=10m tmpfs /kolya
 
 /kolya это субточка монтиования для /
 
 эта точка монтирования невилна в новом неймспейсе
 
 ну опять же повторюсь. сама папка будет видна. но ее содержимое будет
 недоступно. оно будет пустое в новом неймспейсе.
 
 тоже дебильно сделано. зачем она вобще видна. тоже дебильно придумано.
 
 создадим еще одну субточку монтирования / в исходном неймспейсе но более
 диковинную через --bind
 
  935  mkdir /A
  936  mount --bind /mnt/X /A

/A это субточка монтирования /

эта субточка тоже будет невидна в новом неймспейсе

еще подчеркну что такое точка монтирования. это способ получить доступ
к файловой структуре некоторого устройства.
ну и еще это способ чтобы какая то папка ( к устройству вообще отношения неимеет) была доступна по другому файловому пути.


итак. есть маунт неймспейс. он содержит список точек монтирования.
мы создаем новый немспейс. при этом список точек монтироваия копируется.
получается те точки монтирования которые были доступны ранее они доступны и сейчас. в чем тогда прикол созддания нового неймспейса. прикол втом что при создании новых субточек монтирования в обоих неймспейсах они неувидят новые
субточки монтирования друг друга. видны только старые точки монтирования.
и. если при создании нового неймспейса были точки монтирования с пометкой = shared то в новом неймспейсе они тоже будут шаред и они будут входит в одну
пир группу с одноименными точками в старом неймспейсе. что это дает. это 
дает то что при создании субточки монтирования у такой точки монтирования 
в одном неймспейсе она будет видна в другом неймспейсе тоже.  например
в исходном неймспейсе была шаред точка монтиования /mnt/X мы создали новый неймспейс. там тоже будет конечно эта точка. в исходном неймспейсе уже после
созданнного нового неймспейса мы создаем новую субточку монтирования /mnt/X/1
и она будет видна в новом неймспейсе. таким образом созданная новая субточка
монтирования в одном неймспейсе видна в другом неймспейсе. появляется возможность создавать точки монтиварония которые видны между неймспейсами.
надо подчеркнуть что если мы для создания нового неймспейса используем 
команду # unshare то обязательно нужно добавлять ключ --propagation unchanged
если его недобавить то при создании нового неймспейса он удалить все ключи
shared со всех точек монтироавния и вся описанная логика выше обрушится.
небудет возможности создавать общие субточки монтиварония.
также стоит скачать что если у нас есть два неймспейса. они уже созданы.
то нет ниакакой команды никакой возможности связать эти два неймспейса. нет
возможности связать произволную точку монтирования в  одном с призволльной
точкой монтирования в другом сделать их членами одной пир группы.
точка монтирования добавляется в пир группу если она получена через команду
mount --bind. тогда новая точка монтирования попадает в пир группу с исходной
точкой монтироавния. при этом исходная точка должна быть шаред обяазательно.
второй способ чтобы точка монтирования попала в пир группу это мы создаем
новый неймспейс. тогда в новом неймспейсе каждая точка монтирования условно
говоря /mnt/X будет добавлена в пир группу в которой состоит точка монтирования
/mnt/X в исходном неймспейсе. обязательно  в исходном неймспейсе /mnt/X должна  быть шаред. после того как неймспейс создан изменить в нем чтото 
уже невозможно. в плане того чтобы увязать точки монтрования одного неймспейса
с точками монтирования в другом неймспейсе. уже их в пир группу невключишь.

вот это свойствоа shared оно работает только для суботочек монтирования 
первого уровня. то есть если /mnt = shared то видимыми в другом неймспейсе
будут только субточки 
/mnt/X 
/mnt/Y
/mnt/vasya

все новые суботчки монтирования которые глубже
/mnt/X/1
/mnt/X/1/2
/mnt/Y/1
/mnt/vasya/1/100
они в другом неймспейсе будут невидны.
новые субточки имеется вввиду что они будут созданы уже после создания
второго неймспейса.

также для того чтобы крыша непоехала с точками монтирования 
надо всегда считать что каждая точка монтирования она своя собственная
независимая от других и неперенимает свойство от других точек монтиования.

например есть /mnt/X и есть /mnt/Y которые был получени через --bind /mnt/X
так вот надо считать что /mnt/Y это абсолютьно независимая от /mnt/X точка
монтирования. почему это полезно так думать. чтобы неломать голову что
если /mnt/X имеет или получил какието новые свойства то какже это отразится
на его --bind соседях.
пример

один неймспейс
/ - точка монтирования , приватная
/mnt/X - точка монтирования , shared

создаем второй неймспейс
там тоже будет /mnt/X и тоже shared

после этого создаем в первом неймспейсе

mount --bind /mnt/X /mnt/Y


возникает вопрос будет ли /mnt/Y виден во втором неймспейсе.
основываясь на том что я написал что каждую точку надо считать 
независимой от ее bind предка мы имеем что в первом неймспейсе / = private
значит его субточки невидны во втором неймспейсе.
/mnt/Y является субточкой от / . значит ответ = она невидна во втором
неймспейсе. и нам глубочайше похер что она является bind клоном от 
/mnt/X который виден во втором неймспейсе.то есть нам плевать на присхождение
точки от кого она отбиндена и какие свойства имеет ее бинд предок.
и это хорошо. потому что порой отследить все запутанные бинд  корни 
очень трудно. а тут все просто. можно насрать на бинд происхождение и свойства
бинд предков. каждая точка независима от своих корней происхождения.
важно лишь какое свойство имеет более высокая более корневая точка монтироавния. тоесть для /mnt/Y нам насрать на свойства /mnt/X для /mnt/Y
важно лишь какое свойство имеет /.

/proc/pid/mountinfo это более обновленная версия более старой хрени /proc/pid/mounts

если в одном файле /proc/pid/mountinfo для точки монтироавния указанро что
shared:7 и в другом файле /proc/pid_1/mountinfo для другой точки монтироавния
указано что она shared:7 то это однозначно говорит что  обе эти точки 
сидят в одной пир группе. и похеру в одном маунт неймспейсе сидят эти точки 
монтироавния или в разных. то есть это однозначный признак нахождения точек
в одной пир группе. 
пир группы как понятно уже находится выше маунтспейсов. она над ними.

пример
81 61 8:3 / /X rw,relatime shared:7

то что точки монтирования которые имеют один путь например /X в 
разных неймспейсах являются для ядра разными точками монтирования 
доказыается через то что в mountinfo первая цифра это mount ID
и вот для /X в первом неймспейсе mount id = 81

81 61 8:3 / /X rw,relatime shared:1

а во втором неймспейсе для /X mount id = 221

221 147 8:3 / /X rw,relatime shared:1

вторая цифра это mount id родиетельской точки монтирования.
но я уже писал что порой там указана какая то хуйня. поэтому
на родительскую точку монтирования я пока забиваю.

далее они пишут что типа трудный момент в том что 
если мы создаем новую точку монтирования тонепонятно какой ее делать по 
дефолту приватной или шаред.

вроде как рещили такое правило сделать - если родительская точка монтирования
шаред то ее новосоздаваемые субточки монтирования тоже помечать как шаред.
а если родительская точка монтирования приватная то новосоздваваемые
субточки монтирования тоже делать приватными.
далее вмешалась systemd которая вроде как насрала на это правило
создат новые субточки монтирования всегда как шаред.

далее один чувак написал что если через -bind монтировать /dev/pts а потом 
его отмонтировать то якобы линукс отмонтирует и исходный /dev/pts а это п..дец. непроверял. в моем понимании по логике отмонтирование забинденной
точки монтироавния недолжно отмонтировать исходную точку.
я проверил. у меня неподтвердилось. 
я взял точку монтрования /mnt/X
потом я ее забиндил на /mnt/Y

# mount --bind /mnt/X /mnt/Y

потом я сделал

# umount /mnt/Y

и при этом у меня незаанмаунтился /mnt/X
так что в этом плане все окей. если отмаунтить одну из забинденных точек
монтирования то другая при этом остается примонтированной что вобще то 
логично. это как удаление ярлыка на столе. это неудаляет все остальные ярлыки на эту папку на столе.


походу в mountinfo для каждой точки монтирования например /mnt/X указывается ее родительская
точка монтирования например / видимо для того чтобы можно было посмотреть имеет ли родительская точка монтирования свойтсво шаред чтобы понять при создании нового маунт неймспейса будут ли в нем видны субточки монтирования для /mnt/X. потому что иначе непонятно захера в mountinfo указыать родительсктие точки монтироавния. для текущей точки монтирования родительская
нужна только для одного случая - чтоб понять будут ли видны субточки монтирования между немспейсами для данной точки монтирования. а это завиисит
от свойств родительсокй точки монтирования.

чтобы узнаь является ли одна точка монтирования биндом от другой
точки монтирования надо посмотреть в mountinfo сидят ли они в одной
пир группе

# cat /proc/self/mountinfo | grep '/mnt/X'
334 24 0:100 / /mnt/X rw,relatime shared:116 - tmpfs tmpfs rw,size=10240k

# cat /proc/self/mountinfo | grep '/mnt/Y'
335 24 0:100 / /mnt/Y rw,relatime shared:116 - tmpfs tmpfs rw,size=10240k
 
как видно сидят. 
так как и /mnt/X и /mnt/Y сидят еще и в одном маунт неймспейсе
значит одна из них была получена из другой через --bind


что важно. вот мы создали новый неймспейс.
после этого мы в исходном неймспейсе начинаем чтото менять
какието точки монтироавния делаем приавтными. какието расшаррыенными.
но это уже нихера невлияет на ситауцию во втором неймспейсе.
во первых потому что все точки монтирования во втором неймспейсе 
они совершенно независимы от точек монтирования в первом неймспейсе.
хотя они и имеют теже пути : что в первом точка имеет путь /mnt/X что
во втором имеет /mnt/X но их mount ID совершенно разные. поэтому
манипуляции с точкмми монтирования в первом неймспейсе аболюбтно похер 
точкам монтирования во втором неймспейсе.
единственное что если в первом нейспейсе были шаред точки монтироания
то во втором тоже будут шаред и они будут состоять в одной пир группе.
например /mnt/X = shared:7 в первом маунт неймспесе
и /mnt/X = shared:7 будет во втором неймспейсе.
и если мы уже когда второй неймспейс создан мы в первом сделаем /mnt/X приватным то понятное дело что /mnt/X из первого неймспейса будет удален
из пир группы 7. но во втором нейспейсе /mnt/X так и будет состоять в 
пир группе 7. опят же потому что точками монтироавния во втором неймспейсе
насрать на изменния с точками монтирования в первом неймспейсе.
и это приведет к тому что если мы во втором неймспейсе создадим субточку монтирования /mnt/X/1 уже после того как в первом неймспейсе мы сделали
приватным /mnt/X то в первом неймспйсе /mnt/X/1 будет невиден.

пример.
первый неймспейс
/mnt/X - shared:7

создаем второй неймспейс 
получаем в нем
/mnt/X - shared:7

создаем во втором неймспейсе субточку монтирования /mnt/X/2
она будет видна в первом неймспейсе.

далее в первом неймспейсе делаем /mnt/X = private
при этом в нем по прежнему будет виден /mnt/X/2 ( дадада ! )

далее во втором неймспейсе создаем еще одну субточку монтирования /mnt/X/1
и вот она уже будет невидна в первом неймспейсе.

далее. если мы после этого в первом неймспейсе сделаем /mnt/X опят = shared то ХАХА конечно это непривдеет к тому чтобы /mnt/X попал в туже группу
7. нет нихуя. /mnt/X будет включен в некую новую хер знает какую пир группу.
но точно не в группу с номером 7 . все поезд ушел. и нет никакой команды которая бы позволила включить /mnt/X в группу 7.
тут так это непрботает. 
так что как только ты сделал точку монтирования из шаред в приватную то все.
она навсегда потеряет связь со своей исходной пир группой. бай бай пока!

по мне архитектурно это все дебильно сделано. замудрено. 
это все очень трудно помнить. и если забыть то все это нахер хер вспомнишь.
тоест архитектура дебильная.

получается что когда мы тискаем команду
# unshare -m --propagation unchanged sh

то создается новый маунт неймспейс в который копируется список 
точек монтирования то есть ровно такой же как и в исходном маунт неймспейсе.
ну это не ново. опция --propagation unchanged дает то что нетолько список
точек монтирования такой же но и опции у каждой точки монтирования сохраняюся,если точка была шаред то она останется шаред в той же пир группе.
единственное что меняется это у каждой точки монтирования заменяется mount id на абсолютно новый.

еще раз подчеркну такую вещь. а именно ответ на вопрос - вот у нас есть 
точка монтирования /mnt/vasya и она шаред.
что будет если создать у нее субточку монтирования например /mnt/vasya/sub она тоже будет шаред
или приватной. аесли шаред то в какой пир группе в той же что и головная точка /mnt/vasya? во первых надо заметить что это независит от 
свойств головной точки /mnt/vasya это зависит от дефолтовых установок
самого линукса. как я писал выше если на компе крутится systemd то 
тогда если /mnt/vasya = shared то и субточки монтирования /mnt/vasya/xxx тоже
будут шаред.
так оно и есть я проверил я создал /mnt/23 сделал ее = shared
потом создал субточку монтирования /mnt/23/A 
и сам недобавлял к ней никаких флагов. 
и система показала что она уже щаред.

# cat /proc/self/mountinfo | grep '/mnt/23'
335 24 0:101 / /mnt/23 rw,relatime shared:117 - tmpfs tmpfs rw,size=10240k
336 335 0:103 / /mnt/23/A rw,relatime shared:118 - tmpfs tmpfs rw,size=10240k

едиснтвенное что надо добавить что конечно же /mnt/23/A будет шаред в своей
собственной пир группе. потому что точки монтирования попадают в одну 
пир группу либо если они образованы через --bind друг от друга
либо если одна точка лежит в одном неймспейсе а другая лежит в другом неймспейсе и второй неймспейс получен из первого. ну и конечно во всех случаях исходная точка монтирования доложна быть шаред. в даннои случае для /mnt/23/A этого ничего нет. поэтому она сидит в другой пир группе чем /mnt/23

далее. еще раз дебильный момент
если точка монтирования имеет приписку master:2
то она не мастер. нет. она slave. вот такой дебилизм

далее. если точка одновременно является слейвом одной пир группе и полноценным
членом вдругой группе то в mountinfo про нее будет сразу две опции указано
master:M tag and a shared:N

если  точка монтироавния slave то обычно линукс субточку монтирования создаст
приватной. это независит от архитектуры самих точек. это больше от самого 
линукса зависит как у него дефолты установлены.
просто теперь получается что при создании точки монтирования нужно для
линукса прояснять это какая точка монтирования - шаред приватная слейв анбинда
бл. и если ты этого неделаешь в явном виде сам. то линуксу надо самому
решать какое свойство точке присвоить

на счет slave точек монтирования . возникает интересный вопрос.
слейв точка это такая точка что если внутри нее завести субточки монтирования
то членам пир группы эта информация небудет передана. то есть у них эта 
субточка монтирования небудет видна. ладно. а вот если у членов пир группы
появится новая субточка то эта субточка появится и у slave точкми монтирования. возникает вопрос. если  у нас у слейв точки есть суботочка монти
рования vasya и такая же будет создана у члена пир группы. то что же будет 
у slave точки монтирования. ведь у нее уже есть такая точка своя. 
пример

первый неймспейс

/mnt/X = shared 

второй неймспейс
/mnt/X = slave

во второй неймспейсе создаем субточку монтирования
/mnt/X/vasya

теперь идем в первый неймспейс и там тоже создаем субточку vasya
/mnt/X/vasya
эта субточка монтирования теперь должна полететь во второй неймспейс
в слейв точку монтирования и появится там.
но как она там появится если там уже точка монтирования с таким путем есть?
еще раз.

первый неймспейс

точка монтирования /mnt/X = shared
# cat /proc/self/mountinfo | grep -E '/mnt/X'
334 24 0:104 / /mnt/X rw,relatime shared:119 - tmpfs tmpfs rw,size=10240k

создаем второй неймспейс

# unshare -m --propagation unchanged bash
# cat /proc/self/mountinfo | grep -E '/mnt/X'
478 338 0:104 / /mnt/X rw,relatime shared:119 - tmpfs tmpfs rw,size=10240k

делаем эту точку слейвом

# mount --make-slave /mnt/X
# cat /proc/self/mountinfo | grep -E '/mnt/X'
478 338 0:104 / /mnt/X rw,relatime master:119 - tmpfs tmpfs rw,size=10240k

создаем во втором неймспейсе субточку /mnt/X/vasya

# mkdir /mnt/X/vasya
# mount -t tmpfs -o size=10m tmpfs /mnt/X/vasya
# cat /proc/self/mountinfo | grep -E '/mnt/X'
478 338 0:104 / /mnt/X rw,relatime master:119 - tmpfs tmpfs rw,size=10240k
479 478 0:105 / /mnt/X/vasya rw,relatime - tmpfs tmpfs rw,size=10240k

проверяем что в первом неймспейсе ее нет
проерил -ее там нет.

теперь в первом неймспейсе тоже создаем субточку /mnt/X/vasya
ага ! я выяснил как и что происходит.

я попробовал создать просто каталог в первом неймспейсе
# mkdir /mnt/X/vasya
mkdir: cannot create directory ‘/mnt/X/vasya’: File exists

и он мне недал. пишет что каталог уже есть. опа.. интересно.
значит что я понял далее сделав эксперименты : 
во первых. вот есть у нас две точки монтирования которые входят в одну
пир группу. одна из них обычная полноценная шаред. вторая типа слейв.
так вот во первых надо понять что если я в одной точке будут создавать
файлы или папки то эти файлы будут видны во всех других точках.
и неважно где я их создал в слейв точке или в мастер точке. 
если я создам папке то само название папки тоже будет видно у всех.
и неважно где я ее создал на мастер мембере или на слейв мембере.
место порождения папки абсолютно похер. если мы создадим папку 
на слейв мембере пир группы она все равно будет видна на всех 
членах этой группы.!если мы чтото создали в каталоге одного члена неважно
мастера или слейва это видно у всех членов! поэтому когда я на слейве 
создаю папку 
2# mkdir /mnt/X/vasya 
она видна и на мастере.
содержимое самого каталога  /mnt/X этой точки оно будет абсолютно
одинаковое на всех мемберах. поэтому само по себе имя папки vasya будет 
видно и на мастере! /mnt/X/vasya это еще даже субточка монтирования!  это 
просто мы создали пустую папку. далее мы эту папку на втором неймспейсе
делаем точкой монтирования.
2# mount -t tmpfs -o size=10m tmpfs /mnt/X/vasya
так вот вот эта хрень мастер-слейв только сейчас начинает работать.
и она приведет к тому что на первом неймспейсе 1# НЕБУДЕТ ВИДНО СОДЕРЖИМОЕ 
ПАПКИ /mnt/X/vasya ! но самое название папки будет видно !
вот такой мудеж. и это раскрыывает как сделана защита чтобы неполучилось что 
у нас в слейв мембере есть субточка монтирования и мы на мастер мембере 
чтобы не смогли создат такую же. мы это несможет сделтаь. потому что прежде
чем создать точку монтирования нужно создать пустую папку. а когда мы создаем
на слейв мембере эту пустую папку она будет видна на мастере. поэтому на мастере мы уже даже пустую папку создать такую несможем. вот такая защита.
но вообще это прикольно что если у нас есть мастер мемберы пир группы и есть
слейв мемберы пир группы то содержимое каталога этих точек монтироания будет 
всегда абсолютно одинаковое на всех мемберах. и можно создавать файл или 
папку на любом мембере и эта будет видно на всех. вся эта хрень со слейвом 
будет работать только если мы одну из папок сделали точкой монтирования.
тогда на мастере содержимое этой папки будет пусто. но сама папка пустая
будет видна на мастер мембере.  будет присутствовать!
еще напомню что если у нас есть два неймспейса. один получился из другого.
то нам вообще насрать какие точки щаред прайвэт итп. содержимое всех точек
монтирования будет одинаковое в обоих маунтспейсах. если мы создадим файл в одном неймспейсе в точке монтирования /petya то он будет виден в другом
неймспейсе в /petya. и неважно в каком из двух мы создали этот файл. 
и неважно шаред прайвет анбиндабл имеет свойство эта точка.неважно!
вся эта херня с изоляцией,  с щаред, прайвет, слейв будет работать только 
для СУБТОЧЕК НОВЫХ которые будут создавать уже потом после. для исходных же 
точек это все похеру. 

пример.
первыый неймспейс.
/petya  - неважно какое у нее свойство

мы создаем новый неймспейс из первого. получаем такую же точку
/petya - неважно какое тут у нее свойство.

далее мы можем что из первого что из второго неймспейса создать файл в
/petya/1.txt  и этот файл будет виден в обоих неймспейсах.

тоже самое из любого неймспейса создаем пустой каталог
/petya/dir-1
и этот каталог будет виден в обоих неймспейсах !

вся эта херня с изоляцией или пир группами начнет действовать только 
для НОВЫХ СУБТОЧЕК монтирования которые если мы хотим создать
уже после созданив второго неймспейса.

 я считаю что они очень намудили на пустом месте с архитерктурой по этой 
 теме.
 
 поэтому. если у нас в #1 /petya и он мастер
 а во #2 у нас /petya и он slave и мы в 2# создаем папку /petya/vasya
 то эту папку будет отлично видно в #1. если мы потом в #2 папку /petya/vasya
 превраить в субточку монтироания то далее в #1 мы несможем создать такую же
 субточку потому что папка /petya/vasya уже есть.
 
 ха! но получается в #1 нам ненадо создавать папку /petya/vasya она же 
 уже есть. тогда попробуем в ней создат точку монтирования
 
 очень интересно. 
 у меня и  в слейв создался субточка монтирования /mnt/X/vasya
 и в мастере создался субточка монтирования /mnt/X/vasya
 
 первый неймспейс
# cat /proc/self/mountinfo | grep -E '/mnt/X'
334 24 0:104 / /mnt/X rw,relatime shared:119 - tmpfs tmpfs rw,size=10240k
480 334 0:106 / /mnt/X/vasya rw,relatime shared:120 - tmpfs tmpfs rw,size=10240k
 

второй неймспейс
~# cat /proc/self/mountinfo | grep -E '/mnt/X'
478 338 0:104 / /mnt/X rw,relatime master:119 - tmpfs tmpfs rw,size=10240k
479 478 0:105 / /mnt/X/vasya rw,relatime - tmpfs tmpfs rw,size=10240k
481 478 0:106 / /mnt/X/vasya rw,relatime master:120 - tmpfs tmpfs rw,size=10240k

как видно из первого неймспейса инфо о субточке из первого прилетело
и во второй.
и мы видим что во втором неймспейсе у нас для файлового пути /mnt/X/vasya
есть два варианта монтироавния. так какой же победит?
я записал разные файлы в /mnt/X/vasya в первом неймспейсе 
и во втором. и оглашаю результат. во 2# победил маунт второго неймспейса
то есть маунт с mount-id=479
тоесть маунт из первого хотя и прилетел то он по какойто причине
незнаю какой он "неперебил" местный маунт.

я сделал в 2# 

# umount /mnt/X/vasya

и получил

~# cat /proc/self/mountinfo | grep -E '/mnt/X'
478 338 0:104 / /mnt/X rw,relatime master:119 - tmpfs tmpfs rw,size=10240k
481 478 0:106 / /mnt/X/vasya rw,relatime master:120 - tmpfs tmpfs rw,size=10240k


то есть отмаунтился тот маунт у которого mount-id меньше.
и после этого уже в /mnt/X/vasya виден тот файл который я записал из первого 
маунт неймспейса.

чтобы провериить какой маунт побеждает при много кратном маунте
и какой маунт отмаунчивается при юмаунт я сделал вот что


# mkdir /mnt/Z
# mount -t tmpfs -o size=10m tmpfs /mnt/Z

# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

# mount -t tmpfs -o size=10m tmpfs /mnt/Z

# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
338 337 0:107 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

# mount -t tmpfs -o size=10m tmpfs /mnt/Z

# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
338 337 0:107 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
339 338 0:108 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

то есть видно что каждый новый маунт в туже точку 
дает точк монтирования с более большим mount-id

теперь начнем делат юмаунт

# umount /mnt/Z


~# cat /proc/self/mountinfo | grep -E '/mnt/Z'
337 24 0:105 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k
338 337 0:107 / /mnt/Z rw,relatime - tmpfs tmpfs rw,size=10240k

видно что отмаунтился последний. хм... странно 
так как в случае слейв точки монтирования первым отмаунтился тот маунт 
который имел самый маленький номер.

в любом случае - видно что в случае мастер  слейв точек монтироваия 
мы можем успешно создать одноименную точку монтирования однрвременно 
и на стороне мастер мембера и на стороне слейв мембера. далее просто они обе в
итоге будут сущестовать на слейве в mountinfo. просто линукс по своим 
какимто пока непонятным законам выберет один из них и будет использовать.
если потом сделать юмаунт то он один уберет какой тоже надо перепроверять
и будет использовать оставшийся.
да уж.. таким образом в линуксе без проблем можно хоть сто раз подряд
маунтитися в один и тот же файловый путь. ошибки это невызовет.



<<--- закончил здесь--->>













<<--  перечитать это -->>

 



* 113 24 0:45 / /var/lib/docker/containers/368670921d299f8aa18be2eb3bf35cca9c55b3c029ab4cb53629bb5a7d66b134/mounts/shm rw,nosuid,nodev,noexec,relatime shared:88 - tmpfs shm rw,size=65536k

какойто виртуальный диск tmpfs для контейнера зачемто нужный.
пока непонятно

* 95 22 0:40 / /run/user/1000 rw,nosuid,nodev,relatime shared:76 - tmpfs tmpfs rw,size=1023972k,mode=700,uid=1000,gid=1000
тоже непонятно зачем какойто вирт диск.



* поразбираем на примере с живой системы.
будем угадывать как выглядела команда mount

# cat /proc/self/mountinfo
18 24 0:17 / /sys rw,nosuid,nodev,noexec,relatime shared:7 - sysfs sysfs rw
19 24 0:4 / /proc rw,nosuid,nodev,noexec,relatime shared:12 - proc proc rw
20 24 0:6 / /dev rw,nosuid,relatime shared:2 - devtmpfs udev rw,size=5099828k,nr_inodes=1274957,mode=755
22 24 0:18 / /run rw,nosuid,noexec,relatime shared:5 - tmpfs tmpfs rw,size=1023972k,mode=755
24 0 8:1 / / rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered
25 18 0:12 / /sys/kernel/security rw,nosuid,nodev,noexec,relatime shared:8 - securityfs securityfs rw
26 20 0:20 / /dev/shm rw,nosuid,nodev shared:4 - tmpfs tmpfs rw
27 22 0:21 / /run/lock rw,nosuid,nodev,noexec,relatime shared:6 - tmpfs tmpfs rw,size=5120k
28 18 0:22 / /sys/fs/cgroup ro,nosuid,nodev,noexec shared:9 - tmpfs tmpfs ro,mode=755
41 19 0:35 / /proc/sys/fs/binfmt_misc rw,relatime shared:23 - autofs systemd-1 rw,fd=37,pgrp=1,timeout=0,minproto=5,maxproto=5,direct
42 18 0:7 / /sys/kernel/debug rw,relatime shared:24 - debugfs debugfs rw
43 20 0:16 / /dev/mqueue rw,relatime shared:25 - mqueue mqueue rw
44 20 0:36 / /dev/hugepages rw,relatime shared:26 - hugetlbfs hugetlbfs rw
45 18 0:37 / /sys/fs/fuse/connections rw,relatime shared:27 - fusectl fusectl rw
46 24 8:17 / /mnt/disks/vdb1 rw,relatime shared:28 - ext4 /dev/sdb1 rw,data=ordered
93 24 0:39 / /var/lib/lxcfs rw,nosuid,nodev,relatime shared:74 - fuse.lxcfs lxcfs rw,user_id=0,group_id=0,allow_other
95 22 0:40 / /run/user/1000 rw,nosuid,nodev,relatime shared:76 - tmpfs tmpfs rw,size=1023972k,mode=700,uid=1000,gid=1000





* увидели путь в docker inspect
в cat proc pid mouintinfo

отлично. возникает вопрос. почему мы видим папки контейнера
которые лежат в другом маунтнеймспейсе

* перечитить man mount и man на неймспейсы

(такое ощущение что --bind это это непросто создание точки монтирования
как например mount /dev/sda1 /vasya а это типа реальный хардллинк
и что видно по одному пути будет видно по другому пути)



--



далее

491 24 0:118 / /01 rw,relatime shared:131 - tmpfs tmpfs rw,size=1024k

что значит цифра 24. она значит что если мы хотим эту точку монтирования
увидеть то нам надо видеть для начала точку монтирвания с номером 24.
ибо данная точка монтирования сидит в каталоге точки монтирования 24









* родиелей для данной точки монтирования мржнро найти в
/proc/self/mountinfo
вообще надо научиться расшифровываааать все поля в /proc/self/mountinfo


* теперь надо понять   а какая же связт между 
свойством точки монтирования (шаред прайвэт слейв) и другим
маунт неймспейсом. это же как связь между красным и кислым.
нужно найти связь между совершенно разными вещами.

в исходном неймсейсе создаем точку монтирования

# mkdir /mnt/EE
# mount --bind /mnt/EE /mnt/EE
# cat /proc/self/mountinfo | grep '/mnt/EE'
1199 24 8:1 /mnt/EE /mnt/EE rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered



видно что точка монтирования создалась. и что ее тип шаред

создаем новый маунт неймспейс

~# unshare -m bash

проверяем. есть ли  в новом маунт неймспейсе эта же
точка монтирования

# cat /proc/self/mountinfo | grep '/mnt/EE'
1201 1099 8:1 /mnt/EE /mnt/EE rw,relatime - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered


видим что есть. 


~# findmnt -o +PROPAGATION | grep '/mnt/EE'
└─/mnt/EE                                                                                                        /dev/sda1[/mnt/EE]       ext4       rw,relatime,errors=remount-ro,data=ordered  private

причем тип этой точки монтирования в новом неймспейсе = private

интересно.

в исходном неймспейсе создадим +1 точку монтирования.

# mkdir /mnt/FF
# mount --bind /mnt/FF /mnt/FF
# cat /proc/self/mountinfo | grep '/mnt/FF'
1202 24 8:1 /mnt/FF /mnt/FF rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

в старом неймспейсе эта точка есть А ВОТ В НОВОМ НЕЙМСПЕЙСЕ
ЭТО ТОЧКИ МОНТИРОВАНИЯ НЕТ !!!

наверно потому что в исходном маунтспейсе для '/' установлено
свойство private

~# findmnt
TARGET                                SOURCE             FSTYPE     OPTIONS
/                                     /dev/sda1          ext4       rw,relatime,errors=remount-ro,data=ordered

(realtime означает что private)




щас мы это проверим.

\\\\вопросы - как влияет прайвеэт шаред у родительской точеки монтироавния
на видимость дочерней точки монтирования. то есть что побеждает
дочерняя настройка или родителтская.
как влияет что в разных неймспейсах на одну точку монтииования разные
выставолены свойства.\\\\\\\ <----------




в исходном неймспейсе поменяем для /mnt/DD тип с прайвэт 
на шаред.

# mount --make-shared /mnt/DD

# cat /proc/self/mountinfo | grep '/mnt/DD'
1096 24 8:1 /mnt/DD /mnt/DD rw,relatime shared:1 - ext4 /dev/sda1 rw,errors=remount-ro,data=ordered

видим что /mnt/DD имеет тип shared


 








* непонятно как с помощью unshare создать новый процесс у которого
файловая система будет иметь корень в определенной папке.


* появляется вопрос. как определит кто у данного маунт неймспейса папа а 
кто у  него дети

* походу вот так - если мы имеем $PID контейнера.
то в /proc/$PID/mountinfo указано где он хранит свою файловую систему.




* про утилиту nsenter. из того что я уже понял про нее.
параметр -t у нее неработает. надо каждый неймспейс процесса смотреть отдельно, 
указывая путь к каждому типу неймспейса. то есть

хотим посмотреть что в сетевом неймспейсе тогда

# nsenter --net=/proc/$PID/ns/net команда

хотм посмтреть чтото в маунт неймспейсе тогда 

# nsenter --mount=/proc/$PID/ns/mnt команда

а вот такая штука нерботате и выводим полную галиматью

# nsenter -t $PID команда

а очень жаль. потому что хотелось бы сразу что nsenter всосал все неймспейсы процесса 
и чтоб команда отрабатыавала исходя сразу из всех неймспейсов процесса.


и вот наконец то получилось то что я хотел.

запускаем контейнер с ubuntu+bash

# docker run -ti ubuntu /bin/bash&
[1] 2805

root@test-kub-02:~# docker ps
CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                NAMES
1706b53a231c        ubuntu                 "/bin/bash"              3 seconds ago       Up 2 seconds                             musing_clarke

надо немногожко его доработать.
установим внутри этого котейнера iproute2 утилиты. иначе ip -c address show внутри контейнера
небудет работать.

# docker exec -it 1706b53a231c bash
(внутри контейнера)# apt-get update
(внутри контейнера)# apt-get install iproute2

готово. контейнер доработан. выходим из него.

далее. узнаем  PID контейнера

# docker inspect 1706b53a231c | grep -i pid
            "Pid": 2881,
            "PidMode": "",
            "PidsLimit": null,


теперь я хочу незаходя внутрь контейнера а используя неймспейсы и утилиту nsenter 
посмотреть как выглядит  сеетвые карточки внутри контейнера и его файловая система внутри
контейнера

# nsenter --net=/proc/2881/ns/net --mount=/proc/2881/ns/mnt ip -c address show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    inet 127.0.0.1/8 scope host lo
29: eth0@if30: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0

совершенно понятно что это сетевые карточки контейнра а не хоста.

далее. создаем на компе папку

root@test-kub-02:~# mkdir /mnt/host

root@test-kub-02:~# nsenter --net=/proc/2881/ns/net --mount=/proc/2881/ns/mnt ls -1 /mnt

изнутри контейнера она невидна. что логично. ибо фаловая система контейнера
отделена от фс хоста.

видно что nsenter корректно работает когда мы все неймспейсы указываем отдельно друг за другом.
тогда nsnenter их все учитывает.

а если я введу 

# nsenter -t 2881 команда

то утилита выведем фигню  а не инфо изнутри контейнера. к сожалению. баг какойто.
а было бы удобне указать только pid вместо вот этой вот длиннющей портянки со всеми неймспейсами.

по идеет ключ -t судя по ману должен как бы учитывать все неймспейсы процесса сразу

   -t, --target pid
              Specify a target process to get contexts from.  The paths to the contexts specified by pid are:

              /proc/pid/ns/mnt    the mount namespace
              /proc/pid/ns/uts    the UTS namespace
              /proc/pid/ns/ipc    the IPC namespace
              /proc/pid/ns/net    the network namespace
              /proc/pid/ns/pid    the PID namespace
              /proc/pid/ns/user   the user namespace
              /proc/pid/root      the root directory
              /proc/pid/cwd       the working directory respectively

но по факту этот ключ неработает.  достаточно провести такой эксперимент

# nsenter -t 2881  ip -c address show

и вместо сетевых карт внутри контейнера на экран вылезет списко сетевых карт хоста.
это ужасный баг nsenter.

далее.
прикольно то что мы "невлезаем" внутрь контейнера когда юзаем 

# nsenter .... bash

или 

# docker exec -it ... bash

мы на самом деле ( и это только сейчас теперь стало понятно )  запускаем 
в линуксе еще один 
процесс ( bash в данном случае ) который просто напросто входит в теже
 неймспейсы что и процесс
который типа контейнер.

то есть в линуксе нет никаких "контейнеров". есть процессы которые принадлежать тем или иным 
неймспейсам. если мы хотим "влезть" в тот или иной контейнер это значит что мы должны создать 
еще один процесс который входит в теже самые неймспейсы что и процесс на котором крутится 
контейнер. это как в папку положить к файлу соседний файл.

таким образом мы когда "залазиим " в контейнер мы в нем ничего ненарушаем. 
просто для определнного набора неймспейсов добялвется еще один процесс приаттаченый к ним.



* по идее имея PID процесса на котором крутится контейнер применяя знания про 
неймспейсы и утилиту nsenter можно "входить" внутрь контейнера и выполнять на нем
команды неиспользуя docker exec -it  загадочную команду.


надо теперь понять. как зная PID контейнера и используя  знания про неймспейсы
нам узнат куда примонтирована фс контейнера.


* надо разобраться связано ли это с понятими родиетелский маунт неймспейс. дочерний
майнт нейсмпейс.

* надо  разобраться как это свзяано с private shared состоянием точки монтирования.

* надо разобраться как одни итеже точки монтирования видны с разные неймспейсов.
с точки зрения командыfindmnt  findmnt -o TARGET,PROPAGATION 




\\\\\\[  этот кусок весь проработаь и осознать все моменты 

вот наконец пример как сделать свой mount неймспейс






mktemp - создтает файл или папку название которой автоматом рандомное и имеет 600 пермишн.
так что если мы создаем файл или папку заведомо временную то нам ненужно париться
насчет имени. и ненужно париться на счет chmod пермишенов.
то есть никакой загадки в работе этой команды нет. что она делает - 
она придумывает случайно имя. создает с ним файл или папку и дает ей перимшн 600
то есть только кокнретный юзер имеет к ней доступ. типа такая удобняшка и неболее того.




https://unix.stackexchange.com/questions/153665/per-process-private-file-system-mount-points

а вот еще проимер.

во первых - моунт неймспейсы работают с точками монтирования.
а не просто с папками.
но есть следущая фишка она позводяет простую папку превратить в точку монтиования

вначале удостоверимся что наша папка неявляется точкой монттрования

~ findmnt -o TARGET,PROPAGATION /tmp 

если эта папка неявляется точкой монтирования то в выводе будет пусто.

создадим из папки точку монтирования

# mount --bind /tmp /tmp

посмотрим что теперь стало

~# findmnt -o TARGET,PROPAGATION /tmp
TARGET PROPAGATION
/tmp   shared

во первых папка стала точкой монтироавния
во вторых тип точки монтирования видим что shared

если мы хотим создать новый моунт неймспейс нужно чтобы точка монтирования
была private

~# mount --make-private /tmp
root@test-kub-01:~# findmnt -o TARGET,PROPAGATION /tmp
TARGET PROPAGATION
/tmp   private

с этим порядок. точка монтиоавния стала приватной

# touch /tmp/20-00

также возникает вопрос  о том как узнать все mount namespaces.
потому что иначе у нас будут файлы которые невидно под рутом.


конец  зоны осознания]\\\\\\\\

nsenter - понять почему этот кусок говна покаывает соверщенно сетевые карты
когда мы суем ему -t pid
и коогда ему суем -net=file


