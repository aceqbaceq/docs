| bond

     bond + balance-tlb
в чем прикол этого вида бонда

bond0 9e:4a:75:ef:12:36 
veth5 6a:74:95:1a:a4:df
veth7 9e:4a:75:ef:12:36

  veth5 ~~~~~~~ veth6
  veth7 ~~~~~~~ veth8



         |
       bond0
   veth5   veth7
      |      |
      |      |
      |      |
   veth6   veth8


 я делаю конект на bond0
вопорос как расрпеляется поток между veth5\7

в рамках  пинга к одному
 хосту выбирается один veth5 либо veth7 и далее
 постояно по времени на нем поток
 зато странно что при этом судя по nmon
 поток нефакт что передасться к veth6 он может
 быть предан на veth8

а если  я делаю второй поток пинг на хост2 то 
второй поток будет нарпавлен уже на оставщися veth7

таким оразом в рамках потока к однму хосту прыжков
между veth5\7 нет по времени.

а баланс нагрузки на карточки идет на уровне хостов-
новый хост пускается по менее занятой карте.



---------------------------------------------
    _______>__________              сеть
----|----------------|-----------------------
   /|\              \|/
   |||              |||
 |veth5| |veth7|  |veth6|_____|veth8|_  
   _              |                  |
  /|\             |   свич           |
   |              |__________|veth11||
                               \||/
                           ------------
                           | сеть     |
                           | другой   |
                           | неймспейс| 
                           ------------

              ядро

=================================================
          /\ 
         /||\
       приложение 


туда

ядро --> veth5 ---> сеть ---> veth6 -->ядро --> veth11--> сеть

когда ядро --> NIC --> сеть  то это исходящий трафик для карты тоесть TX

когда сеть --> NIC --> ядро то это входящий трафик для карты тоесть RX


тоесть 
veth5 TX
veth6 RX
veth11 TX



обратно

---------------------------------------------
            _______<_____________    сеть
------------|--------------------|-----------
           \|/                  /|\
           |||                  |||
 |veth5| |veth7|  |veth6|_____|veth8|_  
            _     |                  |
            |     |   свич           |
           \|/    |__________|veth11||
                               /||\
                           ------------
                           | сеть     |
                           | другой   |
                           | неймспейс| 
                           ------------

              ядро

=================================================
         \||/   
          \/ 
       приложение 


обратно

ядро <-- veth7 <-- сеть <-- veth8 <-- ядро <-- veth11 <-- сеть


тоесть 
veth11 RX
veth8 TX
veth7 RX


ИТОГО

veth5 TX
veth6 RX
veth7 RX
veth8 TX
veth11 RX TX


когда ядро пихает в veth5 то пакет вот такой
6a:74:95:1a:a4:df > e2:95:d8:7a:70:04

когда пакет влетает внутрь другого сет неймспейса
из veth11 
6a:74:95:1a:a4:df > e2:95:d8:7a:70:04

тоесть пакет когда летит туда он неменяется

обратный пакет
e2:95:d8:7a:70:04 > 9e:4a:75:ef:12:36

как так получается? а сеервет вот в чем 
дело в том что хост при формировании обратного 
ответа ОН НЕИСПОЛЬЗУЕТ SRC_MAC от влетевшего пакета
!!!!!!  как это обычно есть в случае ip адресации.
а вместо этого хост делает ARP запрос ! и ждет 
какой мак прилетит  в этом запросе из сети! 
прчием там важно то что он смотоит не на тот мак
который стоит в ethernet кадре  а на тот мак который
укзаан внутри в arp  пакете который лежит внутри
эзернет пакета! поэтому хост делает запрос 
а ядро в ответ шлет MAC от bond0 инфтрейса!

	bond0 9e:4a:75:ef:12:36 

поэтому обратный пакет имеет вид
обратный пакет
e2:95:d8:7a:70:04 > 9e:4a:75:ef:12:36

поэтому обрный пакет летит на совершенно другой
DST_MAC

именно поэтму орбратный пакет прилетит в бонд
интфрейс уже на veth7 

bond0 9e:4a:75:ef:12:36 
veth5 6a:74:95:1a:a4:df
veth7 9e:4a:75:ef:12:36


                туда
        veth5 ---->
  bond0         обратно
        veth7 <----



mode 5 (balance-tlb)
    Adaptive transmit load balancing. Establishes channel bonding that does not require any special switch support. The outgoing traffic is distributed according to the current load (computed relative to the speed) on each slave. Incoming traffic is received by the current slave. If the receiving slave fails, another slave takes over the MAC address of the failed receiving slave. 

фейловер при поломке карты у него раооает. 
но с задержкой.


в чем стремотат этого режима:
положим у нас есть сервер на нем куча физ карт

 ---------------------------
              сеть 
 ---------------------------
    |em1|   |em2|  |em3| 

            |bond0 IP=... | 
 
              ядро 

==================================
             приложение


так вот если приложение обращается через ядро
на bond0 и генериурет исходящий конект то 
ядро выбирае одну из физ карт и чреез нее
пуляет исхояящий пакет. но оратный пакет прилетит
всегда на em1 

если исходящих конектов много. и если главный 
поток это исходящий а не входящий то рабоатет 
отлично.


а вот если конкт ицниировать снаружи 
то ядро на ARP запрос овтетит как MAC адрес одной
карты вседа. поэтому для такго конекта и входящий
на срверр пакет и исходящий идует по одной карте
для всех конектов! поэтому такой бонд вобще не
подходит для веб сервера. 

тоесть очень спеиифичский трафик можкт облужвать
этот бонд. когда мы с сервера хотим делать кучу
конектов типа как клиенты. и трафик мы будем 
выталкивать с сервера.  в других случая этот бонд
полная херня


mode 5 (balance-tlb)
    Adaptive transmit load balancing. Establishes channel bonding that does not require any special switch support. The outgoing traffic is distributed according to the current load (computed relative to the speed) on each slave. Incoming traffic is received by the current slave. If the receiving slave fails, another slave takes over the MAC address of the failed receiving slave. 


тут прям напсиано четко что параелллиттся только 
ИСХОЯДЯЩИЙ трафик. только не скзано что это верно
только если конект был иниицрован на хосте. это тоже
важное условие. 


tlb  - transmit load balancing

написано что обратный поток идет через слейв карту.
я так понимаю что слейв имеется ввиду карту которая
имеет друой май чем bond инфтрейс


bond0 9e:4a:75:ef:12:36 
veth5 6a:74:95:1a:a4:df
veth7 9e:4a:75:ef:12:36

здесь как я понимаю слев это veth5
нарпавиктке все наоббрроот. обаратный поток будеи
итти на veth7


# cat /sys/class/net/bond0/bonding/slaves 
veth5 veth7

# cat /sys/class/net/bond0/bonding/mode
balance-tlb 5


# cat /proc/net/bonding/bond0
Ethernet Channel Bonding Driver: v6.11.11-1-MANJARO

Bonding Mode: transmit load balancing
Primary Slave: None
Currently Active Slave: veth7
MII Status: up
MII Polling Interval (ms): 100
Up Delay (ms): 0
Down Delay (ms): 0
Peer Notification Delay (ms): 0

Slave Interface: veth5
MII Status: up
Speed: 10000 Mbps
Duplex: full
Link Failure Count: 3
Permanent HW addr: 9e:4a:75:ef:12:36
Slave queue ID: 0

Slave Interface: veth7
MII Status: up
Speed: 10000 Mbps
Duplex: full
Link Failure Count: 2
Permanent HW addr: 6a:74:95:1a:a4:df
Slave queue ID: 0


значит далее через nmon  я выяснил вот что - 
НЕВАЖНО кто инциировал конект  - сделал ли это 
сам сам наш хост или это сделал комп который снаружи.
неважно кто сделал инцииацию конекта. это неважно. 
в любом случае при такой балансировке ядро для
исходящего потока будет делать балансировку через
несколько карточек. тоесть исходящий из серврера
поток будет распалралеливаться. а вот входящий
поток будет идти через одну карту. так что этот 
способ абаанксиоровки подоходит для веб сервера.



      направление потока
    =====================>
  
           /-- nic1 ---->     клиент1
сервер ---/--- nic2 ---->     клтент2
          \--- nic3 ---->     клиент3




      направление потока
    <=====================

           /nic1 <--\----  клиент1
сервер ---/ nic2     \---  клиент2
          \ nic3      \--  клтент3



итак ИСХОДЯЩИЙ поток ядро распараллеливает выплывает
в сеть через разные карты

ВХОДЯЩИЙ поток сервер будет принимать только на 
однй карту от всех клиентов

причем неважно кто инцииоровал конект либо ядро
нашего сервера либо клиент снаружи

если клиенте снаужи инциирвал конект то ему будет 
выдан МАК адрес nic1  карты. и так для всех клиентов.
но обратный поток ядро как я сказал будет высирать
из себя с разных карт

