| console
| font
| vconsole.conf
| keyboard
| terminal


здесь я еще раз коснусь разных аспектоа таких
вещей как ТЕРМИНАЛ   КОНСОЛЬ   и  шрифт в консоли
в том числе руские буквы. поехали




тут я еще раз опишу проблему шрифта в консоли
линукса.

я рекомендую использовать вот этот шрифт

	FullCyrSlav-Terminus24x12.psf.gz

он крупный и имеет руские буквы внутри себя
его нет в arch но он есть в дебиан. оттуда я его
взял и скопировал в arch. отличный шрифт.


значит моя задача была вот какая -по дефолту шрифт
в консоли линукса мелки и руские буквы не поддерживает.
значит надо чтоб был руские буквы и шрифт чтобы был 
большого размера.

на старых системах типа дебиана там за шрифт в консоли
отвечают пакеты

   console-setup-linux
   console-setup
   keyboard-configuration
   kbd


пакет console-setup-linux
он делает вот что. 
  в нем есть файлы со шрифтами psf.gz (напрмиер 
    /usr/share/consolefonts/Vietnamese-TerminusBold14.psf.gz) 
  во вторых в нем есть системд юниты которые суются
    в автозагрузку. именно эти скрипты запускают бинарник setupcon и именно этот бинарник читает конфиги
	   /etc/default/keyboard
	   /etc/default/console-setup
    и потом на основе них устанавливает шрифт в консоли.
    при том что бинакрник setupcon он не входит в этот пакет он входит в состав другого пакета (об нем ниже)
  также в этом пакете есть udev правила которые слушают
   ядро на случай создания нового консольного терминала
   чтобы в нем установить динамиески заданный шрифт

пакет console-setup
он состоит из 
  бинарника setupcon. именно если запустить этот 
    бинарник то он устанавливает шрифт в консоли
    и также он устанавливает настройки клавиатуры.
    а что же за настроки клавы. дело в том что мы 
    там указаваем парамететры какому языку соовтествует
    наша клава. поэтому мы тыкаем на кнопку и он ее
    трансформирует в нужный кейкод на основе языка
    что мы указали. и потом на экране рисутеся символ
    из шрифта что мы указали. дело в том что если 
    мы посмотрим на клаву то мы увидим нарисованные
    на кнопках символы которые там нарсиованы как раз
    исходя к какому языку эта клава относится. вот 
    это мы и задаем. и именно это setupcon оьбьясняет
    это ядру. как я уже писал выше что этот бинарник
    читает настройки из двух файлов

	   /etc/default/keyboard
	   /etc/default/console-setup

    в одном указаны настроки клавы. во втором настро
    йки шрифта. файл /etc/default/console-setup гене
    риует этот же пакет.
  также в этом пакете есть man console-setup который
  как раз таки опмсывает какой контент нужно засунуть
  в файл /etc/default/console-setup . по мне навзание
  этого файла дебилное. егонужно было назвать console-font и было бы все понятно. файл /etc/default/keyboard создается другим пакетом    keyboard-configuration




пакет keyboard-configuration  
  он создает файл /etc/default/keyboard
  он создает $ man keyboard в котором написано какой
    контент надо засунуть в /etc/default/keyboard


пакет kbd
 содержит кучу утилит работы с консолью. я знаю
    только их часть. 
 утилита setfont. 
   она позволяет установить консоль
   ный шрифт для консоли налету. дело в том что 
   шрифт для консоли можно поменять налету двумя 
   путями. можно поменять файл /etc/default/console-setup и потом запустить 
      $ setupcon -f
   но этот способ он скорее уже как дополнитльный 
   проверочный. а основной способ когда мы тестируем
   только настройки консоли то менять файлы в /etc/default ненадо потому что если мы чтото сломааем
   то после перезагрузки поломка останется. так вот
   более надежно эксперимнтировать этот как раз через
   setfont потому что он меняет шрифт налету и никакие
   файлы не меняет. шрифты подходят не абы какие а 
   ккоторые  psf.gz . делаем это так
      $ setfont  /usr/share/consolefonts/CyrSlav-Terminus22x11.psf.gz
   этот шрифт имеет латинсикиеи русские символы.
   это нам дает то что если мы скажем напечатаем
   файл в коттором есть руские буквы
     $ cat vasya.txt
   то на экране будут руские буквы. а если шрифт не
   содержит руские буквы то мы увидим каракули.
   а вот как нам заставить при нажатии с клавы кнопок
   мы могли бы на экране печаатать руские буквы
   то для этого нужно правильно настроить /etc/default/keyboard именно там насртраивается кнопка пере
   ключения с руских на англ буквы на клаве. важно
   еще то что если даже мы переклачалку настроим но 
   в шрифте не будет руских букв то при нажатии на 
   кнопку мы на экране будем видит каракули.
 утилита showconsolefont. 
   она выведет в консоли на
   экран все символы которые содержит установленный
   для консоли шрифт. 
      # showconsolefont
   к сожалению это буквально едиснытенный способ
   чтобы посмотреть как выглядят символы в файле
   шрифта. тоесть мы загружаем этот шрифт в коносль
   и смотрим как он выглдяит. что достаточно дебильно
   	  # setfont /..../..psf.gz
   	  # showconsolefont
  утилита screendump. 
    она делает то что можно скажем
    зайти на комп по ссш. а потом "подсмотреть" что
    там напечатано на экране такого то терминала
    такой то консоли ttyN
        $ sudo screendump 0
    что приколнои удобно. потому что из консоли 
    ты хер что скопируешь в буфер. а если мы зашли
    по ссш то мы увидим на экране что там ест на 
    эакране термианала и можно это скопировать в буфер
    можно "посмотреть, прочитать" что находится щас
    на экране любой консоли через 
       $ cat /dev/vcs1
    но есть проблемка в том что число столбцов в окне
    терминала будет отличаться от числа столбцов в
    окне ссш терминала. поэтому лучше юзать screendump потому что как я понимаю он читает
    из того же файла но потом пытается подогнать 
    отформатировать текст под параметры нашего окна.
  утилита vcstime.
    если ее запустить то справа вверху будут напе
    чатаны часы! можно запустить команду в фореграунд
    режиме и они там будут всегда! что приколно
вот в принципе и все утилиты которые входя в состав
пакета kdb. зачем нужны остальные незнаю.


в итоге если мы установили все эти пакеты. то далее
нам нужно только правильно заполнить два файла.
вот я их даю 


	$ cat /etc/default/console-setup
ACTIVE_CONSOLES="/dev/tty[1-6]"
CHARMAP="UTF-8"
CODESET="FullCyrSlav"
FONTFACE="Terminus"
FONTSIZE="12x24"
VIDEOMODE=

	$ cat /etc/default/keyboard
XKBMODEL="pc105"
XKBLAYOUT="us,ru"
XKBVARIANT=","
XKBOPTIONS="grp:ctrl_shift_toggle"
BACKSPACE="guess"


далее запускаем 

  # setupcon 

и вуаля. у нас в консоли будет крупный по размеру
шрифт. также при нажатии на ctrl+shift можно будет
менять какие буквы будут печаатться на экране -руски
ие или латинские. также если мы будем печаатать на
экране контент файлов тектовых с рускими буквами
то мы увидим их ане каракули. Я БОЛЕЕ ПОДРОБНО но
со стороны практики заполнения этих файлов записал
в qemu2.txt поэтому читай там.

тут еще я хочу показать один прикол.
  берем файл
	 # which setupcon
	 /usr/bin/setupcon
  я хочу узнать в какой пакет он входит.
     # dpkg -S $(which setupcon)
     dpkg-query: no path found matching pattern /usr/bin/setupcon
  как же так? а прикол вот в чем. папка /usr она
  "настоящая" 
     # file /usr
     /usr: directory
  а вот папка /bin это симлинк
     # file /bin 
     /bin: symbolic link to usr/bin
  и мы получаем вот что. в пакете console-setup
  прописано что файл setupcon ставится в папку /bin
  тоесть в пакете прописано вот так
    /bin/setupcon
  и получается что по факту он будет установлен в
  папку 
    /usr/bin/setupcon 
  о чем и пишет which поэтому dpkg -S и покзывает 
  нам дулю. а вот доказтельство того что setupcon
  входит в состав console-setup
      # dpkg -L console-setup | head -n3
        ...
        /bin/setupcon
  поэтому если не можешь найти в состав какого 
  пакета входит файл то попробовать понять а не
  замешан ли здесь вопрос с хитрым симлинком.
  либо надо взять каждый пакет установленный , распе
  чатать его состав файлов и прогрепить.
  а есть еще такой прикол. у нас есть файл на фс
  и он формально не входит в состав ни одного пакета
  потому что этот файл создается неким стартовым
  скриптом который заапускается в системе при устано
  вке этого пакета. вот эти два файла
  	   /etc/default/keyboard
	   /etc/default/console-setup
  как раз пример об этом. потому что они не входят
  в статический сосатав пакета. они создаются при
  установке пакетов.


тут я еще напишу очень важные моменты про то как
рабтает терминал в линуксе. рассмотрим так называемую
консоль. работает это так. мы видим на экране монитора
черный экран. и там скажем баш процесс. так вот
баш процесс имеет свои дескоипторы направленные на
/dev/tty1


 bash
   fd/0 -> /dev/tty1
   fd/1 -> /dev/tty1
   fd/2 -> /dev/tty1

а этот /dev/tty1 ведет в драйвер TTY в ядре


bash --> /dev/tty1 ---> драйвер ядра TTY

так вот этот драйвер он под собой эмулирует железку
VT102 , эмуляция железки идет именно в драйвере TTY
реальный терминал, терминал железка не только тупо принимает байты которые тупо можно напечатать  на 
экране но тераминал можно еще программирвать меняя
на нем всякие настройки. настройки на терминале
можно менять двумя путями можно через ioctl()
а можно через тупо посылку байтов на /dev/tty1
пример через ioctl()

 v 惜  $ cat 423.c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <termios.h>
#include <sys/ioctl.h>

int main() {
    int fd;
    struct termios term;

    // Открываем терминал (например, /dev/tty1 или /dev/pts/0)
    fd = open("/dev/tty4", O_RDWR);
    if (fd == -1) {
        perror("Error opening terminal");
        return 1;
    }

    // Получаем текущие параметры терминала
    if (tcgetattr(fd, &term) == -1) {
        perror("Error getting terminal attributes");
        close(fd);
        return 1;
    }

    // Включаем канонический режим (если он был выключен)
    term.c_lflag |= ICANON;

    // Отключаем режим передачи EOF (например, ^D) из команды ctrl-D
    term.c_lflag &= ~ECHO;

    // Применяем изменения к терминалу
    if (tcsetattr(fd, TCSANOW, &term) == -1) {
        perror("Error setting terminal attributes");
        close(fd);
        return 1;
    }

    printf("Terminal settings changed successfully.\n");

    // Закрываем терминал
    close(fd);

    return 0;
}



запускаю прогу

openat(AT_FDCWD, "/dev/tty4", O_RDWR)   = 3

ioctl(3, TCGETS, {c_iflag=ICRNL|IXON|IUTF8, c_oflag=NL0|CR0|TAB0|BS0|VT0|FF0|OPOST|ONLCR, c_cflag=B38400|CS8|CREAD|HUPCL, c_lflag=ISIG|ICANON|ECHO|ECHOE|ECHOK|IEXTEN|ECHOCTL|ECHOKE, ...}) = 0

ioctl(3, TCSETS, {c_iflag=ICRNL|IXON|IUTF8, c_oflag=NL0|CR0|TAB0|BS0|VT0|FF0|OPOST|ONLCR, c_cflag=B38400|CS8|CREAD|HUPCL, c_lflag=ISIG|ICANON|ECHOE|ECHOK|IEXTEN|ECHOCTL|ECHOKE, ...}) = 0


тоесть в ioctl() я через дескриптор обьясняю ядру
на какую железку я хочу повлиять (как бутто я диск
указываю). и далее через параметры ioctl() я обьясняю
ядру что я хочу чтобы оно подкрутило на этой железке.

суть в том что использую ioctl моя программа сама
непосдретввенно в /dev/tty4 ничего непишет. я лишь
использую /dev/tty4 как укаазатель железки. а 
как там ядро конкнтено работает с этой железкой
это остается для меня невидимо.

но есть и другой способ поменять режим работы жлезки
путем того что я из юзер проги тупо шлю байты на 
/dev/tty4 и это тоже меняет какието режимы на этой
железке. такие упоавляющие байты называются ESC секвенс.

	$ printf '\033%%G' > /dev/tty4

это аналог того что я бы слал чтото в диск

  $ echo "123" > /dev/sda

и это бы не приводило к записи байтов на сам диск
а както бы меняло какую то его настройку

в любом случае эта хрень тоже влетает   в драйвер TTY в ядре. и это он занматется интерпетацией этих 
управляющих байтов

итак если я из проги шлю байты в /dev/tty4 то эти
байты  вчасти случаев будут напечатна на экране
а в другом случае не будут наечаатаны а поменяют
настройки на терминале. это досаточно необычно.

так вот далее очередной прикол. вот у нас байты
из влетели в TTY драйвер. и пусть это просто байты
которые надо напечатать на экране. так вот печаткой
байтов TTY драйвер НЕЗАНИМАЕТСЯ! а он передает эти
байты другому драйверу  - драйверу vtconsole
а уже он занимается отрисовкой символов на мониторе.
причем vtconsole это видим не имя дарйвера а класс
драйвера. сами драйверы бывают разные. пока что 
я встртл два драйвера этого класса это dummy драйвер
и frambuffer драйвер. прикол в том что для всех 
консолей (ttN) может использоваться толко один 
кокннетный vtconsole драйвер. например только 
framebuffer драйвер. или олько dummy драйвер. а так
чтобы часть юзала dummy а часть frambuffer - так
нельзя. как это выбрать. 
делатеся это досточно дебильно неинтутивно.
надо послать "отключить" сигнал на тот драйвер
котоырй активен щас. тогда ядро автоматом "включит"
оставшийся драйвер.
вот для примера у меня активен dummy драйвер

	# cat /sys/class/vtconsole/vtcon0/name 
	(M) frame buffer device
	0
	# cat /sys/class/vtconsole/vtcon1/name 
	(M) dummy device
	# cat /sys/class/vtconsole/vtcon1/bind 
	1

и вот я вырубаю этот dummy драйвер
# echo 0 > /sys/class/vtconsole/vtcon1/bind 

и тогда ядро автоматом активиуре оставищийся драйвер

# cat /sys/class/vtconsole/vtcon1/name 
(M) dummy device
# cat /sys/class/vtconsole/vtcon1/bind 
0

# cat /sys/class/vtconsole/vtcon0/name 
(M) frame buffer device
# cat /sys/class/vtconsole/vtcon0/bind 
1

когла активиуртесят дамми драйвер это приводит к тому
что во всех когсолях прекращается всякий вывод. 
тоесть если какото проеццес чтото шлет на /dev/ttyN
то по факту на экране ничего не печаатется. 
если же я обратно активирую фрейбуфер дайрвер то
печать на экране возюоновится.

тем не меее я хотел выразить ту мысль что драйвер TTY
он лишь занимаетс примеом данных от юзер процессса
и их интерпетицией. но выводом на экран он незанимается (да уж) а передает то что нужно отрисовать другому драйверу. драйверу класса vtconsole. 

        [           ЯДРО                     ]
bash ---[ драйвер TTY --- драйвер vtconsole ]-- экран


есть и еще прикол. есть еще одна группа дайрверов
это vc драйвер.  

   /sys/class/vc

и он созает на компе кучу устройств

   /dev/vcsN

что они дают. дело в том что когда драйвер vtconsole
рисует чтото на экране он еще это все тоже самое
сохраняет внутри ядра в буфере. как гвоится внутри
ядра всегда есть копия всего экрана консоли. спра
шивается зачем? ну затем что если  я бууду переклю
чаться между консолями Ctrl+Alt-N то нужно же откуда
то брать контент этой консоли чтобы заново нарисовать
на экране. а /dev/vcsN это метод доступа к этим
буферам для юзер спейс программ. зачем? а затем что
сижу я например на компе по ссш. и я чисто физически
не могу "войти" в консоль того компа. зато я могу
сделать 

   # cat /dev/vcs1

и поулчить контен экрана! это же круто! например 
если мы подключены к удаленнной машине по ссш.

таким макамром у нас терминал выявил что в ядре
при его обслуживании используется ТРИ группы драйверов
   
   tty драйвер
   vtconsole драйвер
   vc драйвер

причем я указал не имена драйверов а класс драйвера.


теперь такой момент. вот при запуске лиукса в 
параметрах ядра я указываю вот такие штуки

$ cat  /proc/cmdline 
BOOT_IMAGE=/boot/vmlinuz-6.1.0-23-amd64 root=UUID=e5f6d32b-b291-4e52-a679-40cb07d9d50d ro console=ttyS0,115200n8 console=tty1 quiet

а именно 
 console=ttyS0,115200n8 console=tty1

(ксатти задать этот параметр мы можем в конфиге
граба в /etc/default/grub и /etc/default/grub.d/...
потому что именно граб же сует в память ядро и потом
его стартует. поэтмоу эти парамтры нужно предать 
грабу. а уже он с этими парамтрами запустит ядро
тоесть эти параметры нужно совать тому кто запускает
ядро ведь ядро не само себя запускает. )

это дает то что ядро при загрузке плюет свои 
мессаги информационные на все устройства указанные
под грифом console= в данном случае на ttyS0 тоесть
сериал порт и на tty1 (экран монитора)

тоесть с точки зрения ядра слово консоль если я
ее указал в параметрах загрузки ядра ознаачает те
устройства на которые он срет своими ядерными 
мессагами.  но мы то привыкли что слово консоль 
означает не только то устройство на котором можно
посмтреть как там дела у ядра , псмотреть мессаги
с ошибками и событиями с точки зрения ядра но и то
место где мы можем ввести логин пароль и вводить
команды. А ЭТО УЖЕ НЕСКОЛКО ДРУГОЙ КОЛЕНКОР. для 
того чтобы на консоль выводить мессаги ядру нужно
всего навсего связаться с драйвером устройтва 
который связан с консолью и преедать ему байты. а он
уже их нарисует сам или еще кому преедаст кто их 
нарисует. влюбом случае это получается все происходит
внутри ядра.  нприме мы указали что консоль это /dev/ttyS0 тогда ядро свет свои мессаги на TTY драйвер 
а тот их сует на драйвер сериал порта. или мы указали
что косоль это /dev/tty1 тогда ядро передает свои
мессаги на ttu драйвер а тот их пердает на vtconsole
драйвер а тот на экран. но чтобы мы могли в консоли
ввесии логин пароль и попасть в бащ и начать водить
команды нужно сделать кое что попбольше. нужно 
создать юзер процесс например agetty котоый будет
прикрелпен к /dev/tty1

    agetty
      fd/0 -> /dev/tty1
      fd/1 -> /dev/tty1      
      fd/2 -> /dev/tty1

тогда агетти пошлет на stdout строку со словами 

  login:

далее мы начем нажимать кнопки на клаве. сидя в 
терминале и ядро передаст эти кнопки в драйрвер tty 
терминала а тот их передаст в agetty. если же у нас
агетти не запущен или запущен но не приклеплен к /dev/tty1 то мы будем нажимать кнопки они буут попдать в 
буфер tty драйвера но преедавать дальше их будет НЕКУДА. поэтмоу наши кнопки просто будут застервать 
в ядре. так вот мы жмем кнопки они попадают в агетти.
он провряет наш логин пароль. и потом запускает баш
который тоже приклплен к /dev/tty1


    bash
      fd/0 -> /dev/tty1
      fd/1 -> /dev/tty1      
      fd/2 -> /dev/tty1


таким макааром мы попдаем в баш сидя за терминалом.
таким образом посл загрузки компа важно что процесс
INIT сам автомтом запустил agetty и привязал его
к /dev/tty1  если он это несделат то мы никогда 
в баш не попадем. хотя терминал как бы включен.
и фнкционирует. и ядро будет на этот терминал 
нам посылать мессаги о событиях. напрмиер еси мы
нажмем ctrl+alt+del то он на терминале нам напишет
что собиарется презапустить комп. без правильно запуенного агетти наш терминал работает но он почти
бесполезен потмоу что он неинтерктивный.

раньше у нас init после загагрузки автоматом 
запускал 6 агетти каждый из которых был приязвзан 
к /dev/tty1 ... /dev/tty6

сейчас системд делет немного по другому
он запускает agetty для тех устройств (как я понял)
котоыре указаны в параметрах console= в ядре.
как он это узнает. он читает /proc

$ cat  /proc/cmdline 
BOOT_IMAGE=/boot/vmlinuz-6.1.0-23-amd64 root=UUID=e5f6d32b-b291-4e52-a679-40cb07d9d50d ro console=ttyS0,115200n8 console=tty1 quiet

видит там
console=ttyS0,115200n8 console=tty1

тогда системд понимает что  ему нужно запустить
два агентти . один с привязкой к tty1 а второй
спривязкой к ttyS0 ,так написано вот тут 

https://0pointer.de/blog/projects/serial-console.html


поэтому когада лиункс загрузится и если мы водем
по ссш то мы увидим вот такое

$ ps aux  | grep -E "PID|agetty"
PID  TTY     COMMAND
452  tty1    /sbin/agetty -o -p -- \u --noclear - linux
453  ttyS0   /sbin/agetty -o -p -- \u --keep-baud 115200,57600,38400,9600 - vt220


два автоматически запущенных агетти один из которых
привзян к tty1 а второй к ttyS0
их запустил системд

причем он их запускает непросто абы как а через 
юниты

  $ systemctl status getty@tty1
● getty@tty1.service - Getty on tty1


$ systemctl status serial-getty@ttyS0
● serial-getty@ttyS0.service - Serial Getty on ttyS0

и эти юниты уже помещены в автозагрузку.
вот содержимое этих юнитов

$ systemctl cat getty@tty1 | grep -v '#'
...
ConditionPathExists=/dev/tty0
...
[Service]
ExecStart=-/sbin/agetty -o '-p -- \\u' --noclear - $TERM
StandardInput=tty
StandardOutput=tty
TTYPath=/dev/%I
...

в этих условиях происано что нужно непосто стартунть
процесс а что нужно еще его дескрипторы забиндить
на /dev/ttyN устройство.

в принципе тоже самое и для второгого юнита

$ systemctl cat serial-getty@ttyS0 | grep -v '#'
...
[Service]
ExecStart=-/sbin/agetty -o '-p -- \\u' --keep-baud 115200,57600,38400,9600 - $TERM
StandardInput=tty
StandardOutput=tty
TTYPath=/dev/%I

таикмим макаом системд(pid=1) через /proc/cmdline
узнает какие устрйоства обьявлены как console=
и для них создает юниты. через которые стартует 
агетти привзнные к этим устройствам. и тогда
мы можем через эти устойства (/dev/tty1  /dev/ttyS0)
посылать байты (нажатия кнопок) и их принимает
агетти. если мы ввели логин пароль то он запустит
баш. и тогда мы можем через эти устрйоства взаимо
дйстввать с линуком.  таким макамро мы пиходим к тому
есть понятие консоль. есть устройства. есть драйвер
консоли. есть агетти , есть баш , есть ядро. и вот
оно как все хитро переплетено.  итак консоль это  
с точки зрения ядра некий КЛАСС устройств которые
подразумевают двухнаправленый обмен данными. ну 
по крайней мере однонапарвленный. хотя вот опять же
прикол. есть консоль а есть терминал.  изначально
консоль для адра это такое устройство в которое
ядро может записывать свои мессаги. это устройство
вывода. считай как файл в который ядру разрешено
или предписано записывать свои мессаги. 
насколько я понял (от слов ИИ)  ядро всегда отдает мессаги TTY драйверу  а уже тот их конвертирет и 
передает на ttyN либо ttySN либо USBN идругие 
устройтва.  не хочу дальше забивать мозг. 
важно теперь то что если я хочу запретить чтобы 
ктото  мог залогииться на комп через ttyN (через 
монитор и клаву подклченную к компу) либо через 
COM порты на компе то мне нужно запретить системд  запуск агетти  через юниты.  ведь если у меня есть
устройство но к нему не прикрелен агетти то если
я буду вэто  устойтва совать поток байтов(логин пароль) то это все будет всегонавего попадать в ядро
но обработаь это будет некому. не бует процесса прик
репленного к этому устрйству. и войти на комп будет
нельзя. 

   # systemctl mask getty@tty0.service
   ...
   # systemctl mask getty@tty12.service
   # systemctl mask getty@.service


   # systemctl mask serial-getty@.service
   # systemctl mask serial-getty@ttyS0.service
   ..
   # systemctl mask serial-getty@ttyS12.service

и все. порядок.  теперь на этих устйростваъ не 
будет апущен агетти и значит чтото послать внутрт
будет нельзя. но еще остается такая штука что 
можно читать из этих утсройтв что же там ядро
послало из своих мессаг(логи загрзуки). чтобы это 
предоарвраить нужно в граб конфиге /etc/default/grub
убрать все слова вида console= ну кроме может быть
console=tty0
дело в том что ядру нужна хотя бы одна консле 
если мы ее неукажем то он в случае обаружения внутри
компа видеокарты исползует tty0 а если видеокарты нет
то использует ttyS0

получается такая хрень - консоль это с точки зрения
ядра терминал в который он выводит свои мессаги через printk(). а терминал который не консоль это устройство
подвязанное к tty драйверу которое поддерживает некотыйый набор ioctl() и других спциифиеских сисколлов.

чем консоль отличается от терминала.
консоль это терминал в котрый ядро выводит свои логи при загрузке. терминал который не консоль это теминал в которые ядро не выводит свои логи при загрузке. 

например устрово диск /dev/hda это как и терминал
двунапавленное устройства ввода ввывода но диск
не поддержвает те ioctl() котоыре поддеживатют
терминалы. таким ioctl как
		TCGETS
		TCSETS
		TIOCGWINSZ
		TIOCSTI
		TIOCSCTTY

в частности теринал имеет такой параметр как число
строк и столбцов. это достатночно стрмный парметр.
помеять его можно чрез 

  # stty cols 100
  # stty rows 25

и что это дает. если я поставлю 

  # stty cols 5

и я начну на клаве тыкать кнопку 1
то у меня как только в строке окажется пять единиц
11111
то слеудующую еиницу ядро на монитторе напечаатет автоматом на новой строке

если же я сделаю
  # stty rows 5

то если зажму 1 то у меня на экране будет макимум
пять строк. а как только должна повяится шестая
то у меня ядро прокрутит весь экран на одну строку
вверх.

по идее есть размер "экрана" в голове драйвера tty
а есть размер экрана в буфере видеокрты. по идее
если я сделаю что число стоблцов их очень много 


  # stty cols 50000

то по идее оно должнораттьаттак. я печатаю кучу сим
волов и как только я доходжу до конца строки на
экане уменя либо печатьдолжно невидим продооджаться 
в воздухе не приводя к переносу строки либо у меня
печаь должно нчинаться опть с начала этой же строки.
наделе же это не так. вобщем ебала.


а теперь еще вот такое рассмотрим. рассмотрим
udev правило 


$ cat /lib/udev/rules.d/90-console-setup.rules 
ACTION=="add", SUBSYSTEM=="vtconsole", KERNEL=="vtcon*", RUN+="/etc/console-setup/cached_setup_font.sh"

ACTION=="add", SUBSYSTEM=="vc", KERNEL=="vcs[1-9]|vcs[1-9][0-9]", TEST=="/run/console-setup/font-loaded", RUN+="/etc/console-setup/cached_setup_terminal.sh %k"


это правило из пакета console-setup-linux


рассмотрим первое правило

ACTION=="add", SUBSYSTEM=="vtconsole", KERNEL=="vtcon*", RUN+="/etc/console-setup/cached_setup_font.sh"


и расмотрим указанный скрипт

$ cat /etc/console-setup/cached_setup_font.sh
#!/bin/sh

setfont '/usr/share/consolefonts/FullCyrSlav-Terminus24x12.psf.gz' 

if ls /dev/fb* >/dev/null 2>/dev/null; then
    for i in /dev/vcs[0-9]*; do
        { :
            setfont '/usr/share/consolefonts/FullCyrSlav-Terminus24x12.psf.gz' 
        } < /dev/tty${i#/dev/vcs} > /dev/tty${i#/dev/vcs}
    done
fi

mkdir -p /run/console-setup
> /run/console-setup/font-loaded
for i in /dev/vcs[0-9]*; do
    { :
printf '\033%%G' 
    } < /dev/tty${i#/dev/vcs} > /dev/tty${i#/dev/vcs}
done


значит как рабтает это правило. если у нас возникает
обьект /sys/class/vtconsole/vt* (где каждый обьект
это драйвер который умеет выводит графику на экран 
терминала) то запускается скрипт. его первая строка

setfont '/usr/share/consolefonts/FullCyrSlav-Terminus24x12.psf.gz' 


она ничего сделать не сможет потому что эта прога
она проверяет прикрплен ли процесс к терминалу. 
если нет то пошел нахер.
слудущий кусок

if ls /dev/fb* >/dev/null 2>/dev/null; then
    for i in /dev/vcs[0-9]*; do
        { :
            setfont '/usr/share/consolefonts/FullCyrSlav-Terminus24x12.psf.gz' 
        } < /dev/tty${i#/dev/vcs} > /dev/tty${i#/dev/vcs}
    done
fi

он проверяет непустая ли папка /dev/fb
и если да то он для всех терминалов /dev/ttyN
создает процесс котоырй к этому терминалу прикрелпен
и внутри этого процесса выполняет setfont 
таким обраом в каждой консоли будет установен 
заданный шрифт. название шрифта FullCyrSlav-Terminus24x12.psf.gz попадет в этот скрипт
скорее всего когда мы один раз запустим команду setupcon она читает название шрифта из /etc/defaut/setup-con и впиывает его в этот скрипт.
как только мы устанволи шрифт в каждой консоли
тоесть вкажом терминале каждой консоли то 
мы создаем файл который об этом сигнализирует

mkdir -p /run/console-setup
> /run/console-setup/font-loaded

следущий этап
for i in /dev/vcs[0-9]*; do
    { :
printf '\033%%G' 
    } < /dev/tty${i#/dev/vcs} > /dev/tty${i#/dev/vcs}
done

это мы для каждого терминала каждой консоли
преключаем драйвер tty для этго терминала в режим UTF-8 через управлябщие ESC  символы

    $ printf '\033%%G' 

дело в том что терминал или его драввер хер знает
можно менять подкручивать его режимы через ioctl()
а можно напрямую послав в /dev/ttyN управляющую
последоватлеьность байтов.  вот эта последовательно

\033%%G это \x1B%%G  она заставллет драйвер терминала
прелкючтится в режим UTF-8 . а что это такое. это
то что драйвер терминала ожидает и расмаривает поток
байтов который в него влетает что это UTF-8 символы.
вот что это значит! обо всех управлющий ESC сивполмах
можно прочиать тут


   $ man console_codes


там ксати вот что написано
If the console is in UTF-8 mode, then the incoming bytes are first assembled into 16-bit  Unicode
codes.   Otherwise, each byte is transformed according to the current mapping table (which trans‐
lates it to a Unicode value).  See the Character Sets section below for discussion
In the normal case, the Unicode value is converted to a font index, and this is stored  in  video
memory, so that the corresponding glyph (as found in video ROM) appears on the screen.  Note that
the  use of Unicode (and the design of the PC hardware) allows us to use 512 different glyphs si‐
multaneously.
If the current Unicode value is a control character, or we are currently processing an escape se‐
quence, the value will treated specially.  Instead of being turned into a font index and rendered
as a glyph, it may trigger cursor movement or other control functions.   See  the  Linux  Console
Controls section below for discussion.

вот ряд управляющих символов (man console_codes)

  ESC E = newline

ESC это код ASCII 0x1B
тогда
  # printf '\x1BE' > /dev/tty1'

следущая хрень
 ESC ( B  = Select default (ISO/IEC 8859-1 mapping).
или
  # printf '\x1B(B' > /dev/tty1'



тоесть драйвер терминала начинает воспримниать
байтовыы поток как символы в кодировке ISO/IEC 8859-1

 ESC % G  = UTF-8 encdoding 
  # printf '\x1B%%G' > /dev/tty1'

два раза % потому что это такой способ показать 
терминалу что % это управляющий символ


есть управляющий символ CSI=ESC[ это \x1B\x5B

 СSA A = курсор вверх на 1 позицию
  # printf '\x1B\x5BA' > /dev/tty1'


в документе также написано что вообще то прописывать
в программе нарямую эти коды не очень хорошо.
типа они меняются от терминала к терминалу. есть
база этих кодов от всех терминалов . база назвыается
terminfo вхоит в состав пакета ncurses.
база лежит  в папке 
	/usr/share/terminfo/

прставлет собой бинарнивые файлы.
чтобы из не  прочитать в текстовом виде то 
$ infocmp vt102
#	Reconstructed via infocmp from file: /usr/share/terminfo/v/vt102
vt102|DEC VT102,
	am, mc5i, msgr, xenl, xon,
	cols#80, it#8, lines#24, vt#3,
	acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,
	bel=^G, blink=\E[5m$<2>, bold=\E[1m$<2>,
	clear=\E[H\E[J$<50>, cr=\r, csr=\E[%i%p1%d;%p2%dr,

вот эти загадочные хрени
am, mc5i, msgr, xenl, xon, bold ...
это разные умения термиала. например  bold это значит
что мы ему преедаем приказ печатать в жирном виде
текст. а то что после равно

bold=\E[1m$<2>,

это уже тот самый ESC управляющий поток который 
нужно направит в /dev/tty1 чтобы он понял
\E - это кодове обознчние ESC символа \x5B
правда я не уверен за хвост $<2> по моему это просто
мусор

тоест чтобы начать печатать жирным нужно

  # printf '\x1B[1m' > /dev/tty1'


и далее весь текст будет только жирным идти
а вот так текст будет красным

  # printf '\x1B[31m' > /dev/tty1'

а как узнать что все остлаьные штуки типа
cr  csr означают. об этом написано в 

   # man terminfo

например csr значит
change_scroll_region       csr       cs  change region to line #1 to line #2 (P)

ксати вот прям по VT102 его таблица его ESC секвенс
https://vt100.net/docs/vt102-ug/appendixc.html

но они пишут что руками вставлять эти коды это 
лошизм. есть утилита 

   $ tput

мы в нее вставляем что мы хотим получить. а она
уже сама лазии в базу terminfo оттуда вытасивает
нужный байты и сует в терминал. например мы 
хтим сделать текси жирным тодга

  $ tput bold

  $ tput smacs  это использвать алтретрантивнвый 
                набор символв или пвседоаграфика (G1)

  $ tput smso  меняется цвет фона воуркуг буквы 
               и цвет саомй буквы


  $ tput sgr0   сбрсоить все атрибуты до дефлта

длаее такой момент. tput когда мы его заускаем 
он считвает чему равен TERM, в неей мы подскаыажем
программам в каком терминале они работают. тогда
tput делает зпрос к базе terminfo на оснвое этого 
азвания. и уже потом сует в /dev/tty1 нужныебайты.
так вот если TERM=vt102 то команда

   $ tput setaf 10  

котоаря устанвлиывает цвет ткста нихрена нерабтате.
из ччего я делаю преопджение что VT102 был не цветной.
а если  я выставляю TERM=konsole-256color тогда 
соазу 

   $ tput setaf 10  

у нас будет цветной шрифт.

поэтмоу непоянтно. если ядро эмуливрует VT102
а он не цветной то почему если  я в него шлю 
уравляющие коды от друого терминала tput setaf 10   то
ядро их принимает и начинает рисовать все в цвете.
бред.




Итак я очень много дополнил как работает консоль
и терминал. 

А ТЕПЕРЬ - я хочу продолжить на счет консоли в современных дистрибубивах типа arch\manjaro где
шрифт и настройки клавы  контролируются не через
пакеты 


   console-setup-linux
   console-setup
   keyboard-configuration
   kbd


их тут просто нет. и все работает несколкьо по другому.



