| atop
| vmcom
| vmlim

значит у нас у atop есть вот такие параметры такие колонки

		vmcom  28.0G  | vmlim  23.7G


что они значат. о чем они?


vmcom.
что это такое. это так называемый обьем COMMITTED памяти. 
atop берет это число вот отсюда 


 	$ cat /proc/meminfo  | grep Commit
	Committed_AS:   29653396 kB

значит что это за число. о чем оно? значит когда у нас процесс работает. то формально 
у него в доступе есть право для обращения ко всем адресам виртуальной памяти. но не сразу
а только после того как ядро ему это разрешит по просьбе процесса. при старте процесса к
каким то адресам процессу ядро разрешает обращатся сразу. это например кусок стека где уже 
чтото лежит. или тот кусок адресов где лежит тело прграммы машинный код - туда можно лазить.
если же процесс хочет еще куда то слазить он делает к ядру запрос например через 

  malloc()
  brk()
  sbrk()


эти запросы они просят у ядра выделить кусок памяти такогото размера в виртуальном адресном
пространстве. и ядро возвращает стартоый адрес этого куска куда можно теперь лазит и чиать
писать в этом куске. при этом адреса которые стали доступны процессу они неимеют никакого 
отошения к реальным адресам физ памяти. это идет такой прозрачный для процесса маппинг.
при этом также важно что когда ядро выпляет этот заказ то оно неаллоцирует запрошенные куски
памяти в физ памяти. это будет делаться потом отложенно кода и если проецесс реаьно начнет
писать в запрошеннй кусок. ядро просто делает себе в голове пометку о том что процесс
собирается писать в кусок такого размера но аллокации в физ памяти не происходит. ядро
просто себе делает заметку в голове что теперь процессу разрешено обращаться к вирт памяти
в диапазоне там 10 000 - 20 000 байт условно.  тоесть ядро контролирует к каким вирт адресам
можно процессу обращаться. но реальная аллокция физ кусков памяти будет заниматься ядром
когда процесс неосредсвтенно начнет писать в этот кусок памяти. так вот что такое COMMIT 
память с теримнах ядра. это кусок памяти которую процесс формаьно у ядра запросил для
доступа и ядро в ответ формально пообещало что процессу оно выделило в физ памяти такой 
кусок. ключевое слово ядро пообещало. это обещанная ядром размер памяти для процесса. тоесть
процес гвоорит ядру через malloc() выдели мне в физ памяти 100 МБ. ядро возврщаает 
обратно адрес стартовый. и говорит - да я тебе обещаю клянусь что этот размер памяти я теебе 
выделила. ядро ПООБЕЩАЛО. это обещанный размер памяти который ядро якобы выделило процессу
для пользования. процесс считает что этот размер памяти уже у него в кармане. но на самом деле
ядро физически нихрена это не аллоцировало в физ паяти. оно только пообещало. тоесть еще
раз что такие COMMITTED память. это обьем памяти суммарный для всех процессов которые они
попросили выделит им у ядра. тоесть перывй важный момент - процессы попросили. 
второй важный момент - ядро ответило что оно им этот размер памяет выдает и выделяет. пользуйтесь.
и вот размер этой запрошенной и якобы выделенной памяти ядром нам в этом столбике и показан.
в данном случае 

	Committed_AS:   29653396 kB

мы имеем 27ГБ памяти которую процессы запросили у ядра чтобы оно им ее выделило. 
такой обьем процессы попросили в своих просьбах. 
а ядро покрутив усами сказало окей. я вам ее даю. 
но важно понимать что в реальности при запросе ядро не аллоцирует в физ памяти нихуя ни одного
байта. оно лишь делает пометку в свойствах процесса что процесс заказал столько то памяти.
а реальная аллокация (занимание) памяти ядром делается уже потом. когда процесс начинает
реально писать в память данные. поэтому Commit память это не сколько процессы реально занимают
в физ памяти , это не то сколко они сожрали памяти. это отдельный другой вопрос.  это лишь 
заказанный и обещаный ядром обьем памяти в целом в приниципе. сколко из этой памяти реально щас
занято физ памяти хрен знает. это отдельный вопрос. итак это обещанная память. но отнюдь не 
занятая память. это как создавать спарс файл. мы указыаем сколько он может занять в будущем
но сколько он щас занимает блоков на диске это хуй знает. 

итак мы из этих цифр понимаем что в будущем нашим процссам может понадобиться 27ГБ оперативной
памяти. а може и не понадобиться. потому что процесс может запросит тучу байтов а потом вобщем
то ими и не вопсользоваться. а может и воспользоваться. то есть это цифра сколько процесы
запросили памяти и может быть она им понадобится и нам реально нужно будет иметь 27ГБ физ памяти
а но может и не понадобится. да процессы заказазали такой обьем. они бьют себя пяткой
в грудь что память им в таком обьеме понадобится. но заполняют то они ее потом гораздо позже.
и заполняют они ее по частям. и в итоге реально ли они в итоге заюзают этот заказнный обьем 
или нет неизвестно. может да. а может и нет. вот какой физ смысл

	Committed_AS:   29653396 kB

в этой цифре.


можно легко проверить правильность моих слов.
вот программа

  $ cat 392.c
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>


int main(){


     void *p = malloc( 1024 * 1024 * 1024 );
     if(p == NULL){
         printf("malloc error\n");
         return 1; };
         
     void *p2 = malloc( 1024 * 1024 * 1024 );
     if(p2 == NULL){
         printf("malloc error\n");
         return 1; };

      sleep(10);
      free(p);
      free(p2);
      
      
      
      return 0;
}



все что она делает это она запрашивает у ядра через malloc два куска по 1ГБ памяти.
при этом она потом туда ничего непишет. и после этго 10с прога ничего недает и заканчивает
свою работу. 
так вот можно параельно запустить atop и увидеть что параметр vcom после запуска программы
вырастает на +2ГБ.
а коода програма заканчивает свою жизнь то vmcom обратно падает на -2ГБ.

итак смысл этой цифры стал понятен. мы его потрогали.

теперь такой момент  - каждый раз когда к ядру обращется процессс с новым запросом нового
куска commited памяти то ядру надо понять выполнять этот запрос или послать нахер.
и тут на сцену выходит другое число

	$ cat /proc/meminfo  | grep Commit
	CommitLimit:    24837020 kB

это число задает лимит до каких пор процессы могут заказывать заказывать и заказывать новые
порции commited памяти. это число это лимит на обьем commited памяти. 
он равен 23ГБ.

тут можно заметить хуйню потому что лимит 23ГБ < 27ГБ
спрашиватся это что блядт такой за лимит если этот лимит уже пройден?
и тут на сцену выходит третье число

	$ cat /proc/sys/vm/overcommit_memory 
	0

его можно и по другому посмреть

	$ sysctl vm.overcommit_memory
	vm.overcommit_memory = 0

у этой настройки есть три возможных занчения  0,  1,   2
вот описание этой настройки

	https://www.kernel.org/doc/Documentation/vm/overcommit-accounting.rst

хотя оно хуевое.

значит опишу своими словами:

 1  --- при этой натсройке ядро срет на лимит и позволяет бесконечно процессам запрашивает
 	    новые куски commited памяти. с этим все понятно. тут все просто.

 2 --- это наоборот. ядро не позволит чтобы размер commited памяти превысил лимит коммитед
       памяти. тут тоже все просто.

 0 --- это самая деабильно описаная настройка. мы ее как раз имеем. при этой настройке ядро
       позволяет превышать коммит памяти указанный лимит. но до какого предела это можно
       делать это решает само ядро на основе каких то там непонятных мне соображений.

именно поэтому в нашем случае размер commit памяти превышает заданынй лимит.

тперь вопрос - откуда берется занчения для лимита? на основе чего?
а оно высчитывается по формуле . берется размер все свап файлов и скалдывется некоторой
частью оперативки.

в плане оперативки берется вот это число

$ cat /proc/sys/vm/overcommit_ratio 
50


это значит 50% . тоесть берется 50% от размера доступной RAM и прибавляется к размеру всех
свап файлов. и вот этот обьем и записывается в лимит commit памяти тоесть вот в это число

	$ cat /proc/meminfo  | grep Commit
	CommitLimit:    24837020 kB


проверим. 
мой обьем свап файлов равен

$ swapon
NAME      TYPE      SIZE USED PRIO
/dev/dm-1 partition  16G 6,8G   -2

как видно 16ГБ

мой обьем оперативки 16ГБ. 


тогда лимит на коммит память будет равен 16Г + 50%*16ГБ = 16+8 = 24ГБ

сравниваем с лимитом в графе CommitLimit

$ bc <<< "scale=3; 24837020 /1024 /1024 "
23.686 ГБ


все в целом совпало!

забавно что линукс по дефолту только половину оперативки готов выделить под нужды процессов
а остальную половину он получается оставляет под разные там кеши и тому подобное. 

тут еще надо добавить что 50% выситывается не от размер физ памяти 16ГБ а от число которое
меньше. а именно  - когда комп загрузился то в его памяти лежит физически ядро и оно занимает
память и эту память ну никак нельзя использовать ни под что кроме самого ядра. поэтмоу она 
вычитается. так вот обем опративки за вычетом обьема который занимает само ядро. имеется ввиду
не  перменные ядра а именно сами машинные коды ядра хотя я не исключаю что возможно также
и какойто кусок памяти также исключеается из использования из за куска памяти где ядро хранит
какито важные для себя пемреенные. так вот доступный обьем в теории для выдачи под нужды 
процессов можно увидеть вот так 

$ cat /proc/meminfo  | head -n2
MemTotal:       16123712 kB

$ bc <<< "scale=3; 16123712 /1024 /1024 "
15.376


это 15.376 GB.  тоест это не размер физ памяти. а именно это размер физ память минус
код самого ядра также взоможно минус какойто кусочек памяти под какието свер важные перменные
тоесть наше ядро отрезаело под свои нужды 0.624GB  это 479МБ


тогда с учетом этого перечитыаем вот эту формулу

	16Г + 50%*15.376ГБ =  = 23.685 ГБ

теперь сравним с этой цифрой


	$ cat /proc/meminfo  | grep Commit
	CommitLimit:    24837020 kB

$ bc <<< "scale=3; 24837020 /1024 /1024 "
23.686 ГБ

видим отличное совпаление!

тоесть ядро по дефолту собирается только половину памяти использовать под нужны процессов
а потом это все пихать в свап. а вторую половину юзать по всякие там кэши и тому подобное.
либо это всего лишь некаий способ свофмировать цифру лимита. и не более того. а как и что 
он потом пихае и куда это отдельный вопрос.

ну можно оценить сколько же реально при этом памяти щас занято и сколко свапа занято.
и так  я напоимнаю
процессы попрсили а ядро обещало им 

 	$ cat /proc/meminfo  | grep Commit
	Committed_AS:   29653396 kB = 28.279 ГБ

лимит у нас щас 

	$ cat /proc/meminfo  | grep Commit
	CommitLimit:    24837020 kB = 23.686 ГБ


так вот на счет свапа согласно atop
   SWP |  tot    16.0G |  free    9.2G

у нас занято 7ГБ свапа

на счет физ памяти 
