| atop
| vmcom
| vmlim

значит у нас у atop есть вот такие параметры такие колонки

		vmcom  28.0G  | vmlim  23.7G


что они значат. о чем они?


vmcom.
что это такое. это так называемый обьем COMMITTED памяти. 
atop берет это число вот отсюда 


 	$ cat /proc/meminfo  | grep Commit
	Committed_AS:   29653396 kB

значит что это за число. о чем оно? значит когда у нас процесс работает. то формально 
у него в доступе есть право для обращения ко всем адресам виртуальной памяти. но не сразу
а только после того как ядро ему это разрешит по просьбе процесса. при старте процесса к
каким то адресам процессу ядро разрешает обращатся сразу. это например кусок стека где уже 
чтото лежит. или тот кусок адресов где лежит тело прграммы машинный код - туда можно лазить.
если же процесс хочет еще куда то слазить он делает к ядру запрос например через 

  malloc()
  brk()
  sbrk()


эти запросы они просят у ядра выделить кусок памяти такогото размера в виртуальном адресном
пространстве. и ядро возвращает стартоый адрес этого куска куда можно теперь лазит и чиать
писать в этом куске. при этом адреса которые стали доступны процессу они неимеют никакого 
отошения к реальным адресам физ памяти. это идет такой прозрачный для процесса маппинг.
при этом также важно что когда ядро выпляет этот заказ то оно неаллоцирует запрошенные куски
памяти в физ памяти. это будет делаться потом отложенно кода и если проецесс реаьно начнет
писать в запрошеннй кусок. ядро просто делает себе в голове пометку о том что процесс
собирается писать в кусок такого размера но аллокации в физ памяти не происходит. ядро
просто себе делает заметку в голове что теперь процессу разрешено обращаться к вирт памяти
в диапазоне там 10 000 - 20 000 байт условно.  тоесть ядро контролирует к каким вирт адресам
можно процессу обращаться. но реальная аллокция физ кусков памяти будет заниматься ядром
когда процесс неосредсвтенно начнет писать в этот кусок памяти. так вот что такое COMMIT 
память с теримнах ядра. это кусок памяти которую процесс формаьно у ядра запросил для
доступа и ядро в ответ формально пообещало что процессу оно выделило в физ памяти такой 
кусок. ключевое слово ядро пообещало. это обещанная ядром размер памяти для процесса. тоесть
процес гвоорит ядру через malloc() выдели мне в физ памяти 100 МБ. ядро возврщаает 
обратно адрес стартовый. и говорит - да я тебе обещаю клянусь что этот размер памяти я теебе 
выделила. ядро ПООБЕЩАЛО. это обещанный размер памяти который ядро якобы выделило процессу
для пользования. процесс считает что этот размер памяти уже у него в кармане. но на самом деле
ядро физически нихрена это не аллоцировало в физ паяти. оно только пообещало. тоесть еще
раз что такие COMMITTED память. это обьем памяти суммарный для всех процессов которые они
попросили выделит им у ядра. тоесть перывй важный момент - процессы попросили. 
второй важный момент - ядро ответило что оно им этот размер памяет выдает и выделяет. пользуйтесь.
и вот размер этой запрошенной и якобы выделенной памяти ядром нам в этом столбике и показан.
в данном случае 

	Committed_AS:   29653396 kB

мы имеем 27ГБ памяти которую процессы запросили у ядра чтобы оно им ее выделило. 
такой обьем процессы попросили в своих просьбах. 
а ядро покрутив усами сказало окей. я вам ее даю. 
но важно понимать что в реальности при запросе ядро не аллоцирует в физ памяти нихуя ни одного
байта. оно лишь делает пометку в свойствах процесса что процесс заказал столько то памяти.
а реальная аллокация (занимание) памяти ядром делается уже потом. когда процесс начинает
реально писать в память данные. поэтому Commit память это не сколько процессы реально занимают
в физ памяти , это не то сколко они сожрали памяти. это отдельный другой вопрос.  это лишь 
заказанный и обещаный ядром обьем памяти в целом в приниципе. сколко из этой памяти реально щас
занято физ памяти хрен знает. это отдельный вопрос. итак это обещанная память. но отнюдь не 
занятая память. это как создавать спарс файл. мы указыаем сколько он может занять в будущем
но сколько он щас занимает блоков на диске это хуй знает. 

итак мы из этих цифр понимаем что в будущем нашим процссам может понадобиться 27ГБ оперативной
памяти. а може и не понадобиться. потому что процесс может запросит тучу байтов а потом вобщем
то ими и не вопсользоваться. а может и воспользоваться. то есть это цифра сколько процесы
запросили памяти и может быть она им понадобится и нам реально нужно будет иметь 27ГБ физ памяти
а но может и не понадобится. да процессы заказазали такой обьем. они бьют себя пяткой
в грудь что память им в таком обьеме понадобится. но заполняют то они ее потом гораздо позже.
и заполняют они ее по частям. и в итоге реально ли они в итоге заюзают этот заказнный обьем 
или нет неизвестно. может да. а может и нет. вот какой физ смысл

	Committed_AS:   29653396 kB

в этой цифре.


можно легко проверить правильность моих слов.
вот программа

  $ cat 392.c
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>


int main(){


     void *p = malloc( 1024 * 1024 * 1024 );
     if(p == NULL){
         printf("malloc error\n");
         return 1; };
         
     void *p2 = malloc( 1024 * 1024 * 1024 );
     if(p2 == NULL){
         printf("malloc error\n");
         return 1; };

      sleep(10);
      free(p);
      free(p2);
      
      
      
      return 0;
}



все что она делает это она запрашивает у ядра через malloc два куска по 1ГБ памяти.
при этом она потом туда ничего непишет. и после этго 10с прога ничего недает и заканчивает
свою работу. 
так вот можно параельно запустить atop и увидеть что параметр vcom после запуска программы
вырастает на +2ГБ.
а коода програма заканчивает свою жизнь то vmcom обратно падает на -2ГБ.

итак смысл этой цифры стал понятен. мы его потрогали.

теперь такой момент  - каждый раз когда к ядру обращется процессс с новым запросом нового
куска commited памяти то ядру надо понять выполнять этот запрос или послать нахер.
и тут на сцену выходит другое число

	$ cat /proc/meminfo  | grep Commit
	CommitLimit:    24837020 kB

это число задает лимит до каких пор процессы могут заказывать заказывать и заказывать новые
порции commited памяти. это число это лимит на обьем commited памяти. 
он равен 23ГБ.

тут можно заметить хуйню потому что лимит 23ГБ < 27ГБ
спрашиватся это что блядт такой за лимит если этот лимит уже пройден?
и тут на сцену выходит третье число

	$ cat /proc/sys/vm/overcommit_memory 
	0

его можно и по другому посмреть

	$ sysctl vm.overcommit_memory
	vm.overcommit_memory = 0

у этой настройки есть три возможных занчения  0,  1,   2
вот описание этой настройки

	https://www.kernel.org/doc/Documentation/vm/overcommit-accounting.rst

хотя оно хуевое.

значит опишу своими словами:

 1  --- при этой натсройке ядро срет на лимит и позволяет бесконечно процессам запрашивает
 	    новые куски commited памяти. с этим все понятно. тут все просто.

 2 --- это наоборот. ядро не позволит чтобы размер commited памяти превысил лимит коммитед
       памяти. тут тоже все просто.

 0 --- это самая деабильно описаная настройка. мы ее как раз имеем. при этой настройке ядро
       позволяет превышать коммит памяти указанный лимит. но до какого предела это можно
       делать это решает само ядро на основе каких то там непонятных мне соображений.

именно поэтому в нашем случае размер commit памяти превышает заданынй лимит.

тперь вопрос - откуда берется занчения для лимита? на основе чего?

 


