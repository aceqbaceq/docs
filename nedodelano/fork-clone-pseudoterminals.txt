на счет разгицы между fork() и clone()

когда мы запускаем fork () то у него и параметров то нет. и после этого 
дочерний процесс поодолждает исполнение на том месте что идет после форка. все 
легко и клеов. а clone он имеет кучу флагов и что еще более важно что clone требует
чтобы то что убдет выпоолнсяься у чайлда было описано в функции! и то что 
как только выполненеие кода в функции заканчииваетя то чайлд автоматом помирает.
поэтому если у нас есть код с fork() то просто взять его и заменить на clone() с соответ
всутюим флагами хрен получится!
прмиер проиги с клон это "pid-ns.c"
===

я почитал на счет псевдотерминалов. 
я наконец то стал про них догонять! как это работает:
парент процесс обращается к /dev/ptmx.  этот ptmx это типа входная точка. после этого 
ядро создает у парент процесса новый +1 файл дескриптор. например 3 тоесть 
/proc/parent_pid/fd/3
этот файл дескриптор ведет в /dev/ptmx тоесть выглядит это вот так
/proc/parent_pid/fd/3 --> /dev/ptmx

также ядро создает в папке /dev/pts еще один новый файл напрмиер 10. тоесть
/dev/pts/10

дальше вот что - любой процесс на компе может послать в /dev/pts/10 и это прилетит в ядро
а оттуда в /proc/parent_pid/fd/3 тоесть в наш родительский процесс. верно и обратное
если родительский процесс напишет в fd/3 то это летит в ядро а отуда в pts/10

самое большое непонятное наебалово которое я никак не мог понять состоит в том что 
если в pts/10 может писать и читать любой процесс с компа и это работает. то писать и 
читать из fd/3 МОЖЕТ ТОЛЬКО СУКА ТОТ ПРОЦЕСС КОТОРЫЙ ОБРАЩАЛСЯ К PTMX ТО ЕСТЬ
ТОЛЬКО ПАРЕНТ ПРОЦЕСС. как  я полагаю когда процесс с компа делает read() сисколл то ядро
видит какой процесс делает запрос  и ответ нихрена нешлет при чтении. и нихрена 
не отправляет то что при записи! а я нихрена не мог понять. и об этом буквально
нихрнеа нигде н обяснятесят! тоесть ядро четко проверяет какой процесс делает
запрос на чтение запись к этому дескриптору! 

полчучается если какйото юзеркий процсс его STDIN, STDOUT подклчит к pts/10 
например вот так 

/proc/некий процесс/fd/0 -->  /dev/pts/10
/proc/некий процесс/fd/1 -->  /dev/pts/10

то этот процесс будет писать и читать и это все будет лететь паренту.
так вот если я с темринала начну параельно писать в pts/10 то это срабатывает 
отлично. паренту моя писанина тоже будет прилетать.
также можно ворровать то что от парента прилетает этом процессу.
надо просто поставить 
	cat /dev/pts/10 
и мы будем вдвоем с процессом воевать за ту инфо что прилетает. то он букву
получит то я. 

но тоже самое нихрена не получится сделать для /proc/parent_pid/fd/3
как бы я ни старался. ни прочитать оттуда ни записть нихрена не полися.!

pts/10 назвыается slave конец терминала. а fd/3  называется мастер конец
терминала. так вот в слейв конец могут читать писать все кто ни попадя. вобще похер.
это никак не контрлируется, развет только файл пермишнсами. но если скажем 
файл перминс разрешает васе читать и писать то любой процесс зауещенный васей
может читаь и писать в слейв конец терминала. так вот как я понимаю 
в мастер конец терминала может читать писать только процесс относящийся к 
этому fd. и болше никто. как я понимаю ядро просто нахрен проверяет от кого
прилетел запрос. от какого процесса. и если это левый процесс то нихрнеана 
не просходит!

пайп дает одностороннюю связь по одному каналу.  
причем в пайпы может писаь и читать (воровать ) любой процесс.
проблемы нет. ядро не проверяет.

например запсутили мы вот так

$ sleep 120 | sleep 130

скажем у первого pid=10 у второго pid=11
тогда их fd выглядит так
/proc/10/1 -> [pipe]
/proc/11/0 -> [pipe]

мы можем спокойно открыть еще два окна терминала 
в первом окне мы можем с левого процессса совать данные в пайп процесса 10
# echo 111 > /proc/10/1
во втором тмеримнмале мы можем из пайпа процсс 11 данные забиаьть
# cat /proc/11/0

но повтторю пайп однонаправлленный. чтобы процесса два могли друг другу
писать чиать надо открывать два пайпа.

темринал позволяет чиать и писать чрез один термиал файл /dev/pts/17

юникс сокет домен. двунаправленая хрень. толькьо я незнаю можно ли в него
писать чиать прям через echo 111 ? (ппробтать написать прогу котоаря открывает сокет слу
шает его. а я в него пишу через echo )

===

# echo -e "123\n456\n789\n" | docker run -it --rm --name=150  150 
the input device is not a TTY

из этого следует вот что.  как я понимаю докер клиент или сервер как делает.
он берет процесс который ответчеает за echo . берет у него fd=1 и пытается его скопировать
в когтейнер контенеронмуо процессу при этом он как то проверят тип fd. у меня 
fd на беенде бует коненчо пайп.  и конечно это не tty.

вобщем походу так это рабает.
во перых я щас буду расматривать вот такие команды
$ docker run 
значит как все начинает рабоать. мы запускаем docker run. docker это клиент
он делает запрос на сервер докера dockerd через сокет.
сервер вначале создаем shim процесс. а уже потом то ли сервер докера
то ли сам shim процесс уже создает контенер.
в итоге у нас начинают висеть три процесса
 это докер клиен, shin, контенер


bash(он спит)--docker(клиент)----shim----контейнер(процесс)



если мы не юзаем ни -i ни -t то при содании процесса в конйенере
докер заворачивает STDOUT и STDERR (fd/1 и fd/2) контйеенрого процесса
на shim процесс через ПАЙПЫ. если мы юзаем ключ -i то из контейнера и stddin
контейнерного процесса заворачивается на shim. эта хрень делается один раз при
создании контейнера и потом больше не меняетя. 
когда мы потом позже подключается к конейтенру через docker attach
то наш клиент docker уже соедняется с shim процессом и то ли через пайпы то ли 
через сокет связывается с ним. таким образом shim идет как прокси. 
если мы делаем docker run через -t это значит что STDOUT и STDERR контейнера
заворачиватся на его стадии создания на shim через pts/x файлы тоесть через терминал
на shim при этом возникет характерный /dev/ptmx файл. если к этому добавляетяс 
ключ -i то еще и STDIN пробрасыатся на shim через pts/X
когда мы конектися к контйенеру через attach то там всегда связт идет 
через пайпы либо сокет.
если сделать в оабавок docker exec -t то на shim возникнет еще одно устройствао /dev/ptmx
вобщм абсолбтно то что с контйенера его fd всегда заворавичаются на shim.
это 100%. вопрос только каким спосбом. елимы не указали ключ -t то через пайпы.
а если указали то чрез /dev/pts/X
дальше конечно вопрос о том когда мы конестися к контейнеру через docekr attach
иидет ли он на шим или он идет на докер сервер а тот на shim а потом уже контйенер.
тоесть вопрос идет ли проксиование чрез shim или двйоное проксиорвание 
через дор сервер и shim. я все таки доумаю что через shim.
ключ -i вдиякт тлоько на то будет ли stdin с конейнера авернутна shim или нет.
теперт выжные проктичские свойства. если у нас контенер ище на Shim чрез пайпы
тоест при сддании мы ключ -t не сипользвали то вывод того что контйерер срет на stdut
приздойдет только тогда когда контйеенр остаовновится. тоесть когда закроется 
пайпы. тоесьт вначале через пайп в шим пердается полносью вся ифомрация.
а только потом шим нам ее пкажкет. если же конейнер завернут на шим
чреезе -t чрезе .dev/pts/X то вывод в клиент будет идти уже как полжено- как толко
строчка высрралась в коненере так сразу у нас на клиенте и прилеретететелеа.
что касается ввода то он всегда работает хорошо что с -t что без -t. 
едиснвтенное непонятно жнкс зпапущенный с -d и без -t усмпено видны его логи
на экран без всякого окочнаания его раобты. это поа непоняино. 
ии еще если мы заускаем докер ктнейоенера с ключом -t а сами шлем данные в контйенер 
чреез пайп
  echo "13" | docekr -it --rm --name "asbvsa" busybox cat -
то доаеркер пошлет столшибккой что мол stdout нащего процесса не являтеся TTY 
устройством. и десвтиетльно у echo уго stdout имеет тип пайп.
еще клч -t нужен ряду программ в контейнере. таким как bash. потому что они делают 
вяские ioctl через stdout. и если там не темрианал то у них код возврата с оштбкой
и процес спросто закрываетая.  тоест без -t некотоы процессы просто не зпустсятя. 
итак по дфеолту stdour\\stderr конейрера пробрвтсся на shim. а при аличи ключа -i 
и он тоже. ключ -t влияет каким методом идет заворот. ели ключа нет то чрез пайпы
а ели есть то черех /pts/X. при это мна шим овзникает файл /dev/ptmx.
при подклчении к конейтенерчеерз attah идет связт клиента докер с шим. он выствает 
в роли прокси. атк вот еси сввязь конейенра с шиим идет по пайам то в stdout мы 
неу видим ничео пока контейнер не останоисят и пайп не закроется. еси же 
связь дет по pts/X то stdout бдует на клиенте заоплнсят в режиме рлаьного времени.
права да жинкс запущенный с -d и без -t умудряется срать в stdout 
врежиме рально врмени.
хотя нет все неатк. stdout что у жинкса что у редиса пустой! а вот логи полные!
но все равно это непоянтн. у меня если экран заполнсял хреново то и логи
тоже зааолянлись только после выключения конейтенра.

флаг -i называетая по уебски как "interactive" и лы бдумаетшь интутиивно что мол воо 
 я щас поставолю флаг -i и значит смогу посылать кнопки внутр контенера 
 и смогу видеть что ввнути контейнера в едь в этом сымсл нтерактив. а это полная хуйня.
 -i дает только то то stin контйенерного процесса заворачивается на shim! наормально?
 тоесчть человвек думает так если мне надо запустить прогамму вгутри когтейгера 
 и чтобы можно было на ней кнопки нажимать и видеть то что на экране то видимо это 
 надо использовать флаг -i а на хрен флаг -t вобще на хрен непонятно. вот 
 дуаает человек. тоесть ага - я заупкска баш в конйетнере значит нжен -i
 а если жинкс то -d . а нахрен флаг -t вобщне понянтно. втт как думает человек.!
 а все горрааааааааздо сложнеее!  связь с конйерепррм идет через прокси через shim.
 и выгяит так что  std* из контйенера проброшен в shim. когда ты конектится к контейнеру
 на самом деле ты конектилшься к shim. по учалонию связт между контейреом и шимом 
 идет через папйы. а в чем прикол этого? а в том что (проверить) что пока
 в контйенере процесс не оставноистя шим в наш клиент нихрена не пришлет!
 так ест если при слздании контйерера мы не указали клч -t.а если указать то связт
 между шим и конйером будет иадти через термрианал. а во это уже дает то что то что 
 срет контйерер будет появлятся на нашем клиенте уже строка за сторкой. без задержки!
 вот что дает флаг -t. а что дает флаг -i - он дает то ч то по дефолту только stdotut и dtderr
 пробрасывабтся с конетйреа в шим. а еслио -i то и stdin!
 -i поводяелет чтобы мы пдолкючившишт с клиента могли с клвы послыать в когейнер на 
 его стдин данные с клавы. летят они сразу и без прллем. но как ты поймешьчто они долетели
 если у тебя ключ -t не стоит и не показыуает тебе оббратку?!  также без ключа =t 
 ряд процессов не хоят стартоваоььь. а коода клююч -t ненужен? когда мы с роцессом
 в контейерере не удешо с кннопоаок взаимодействовать . типа жинкс. 
 обычно рабочик ероцесс запускает просто как -d а вот уже заход в контйеер чотоо
 починить через бащ иет как -it.
 так вот если мыхоитим чтотов контейнер послать не ечерез кнопки а через пайп то туту
 кюч -t нельзя . дбокер напишет что stdout нащего клиета имее не типtty и это правда.
 он иже имеет типа пайпйа!!!

в docker run --help ==>  -i, --interactive                    Keep STDIN open even if not attached
идиостое обяснение!

свойства контейрер рабуюащего на наличеи ttu 
 "Tty": false

если контейнер стартаунут в с только ключом -d то если к нему приатачиться
docekr attach 
то ты хуй из него выйдет наатием ctrl-p Ctrl-q 
если ажать ctrl+C то шим проксирует этот сигнал и пшлет его в контейе. и контенер
остаитантся! едиснвтенное что арботает это воттак
docker attach --sig-proxy=false  ng3
и тогда мы жмем ctrl+C и споокйно отпочковыаваесяся от контейета без его остановкиЙ
если же у нас уже есть запущенный клиент docker attach без опции --sig-proxy=false 
то его тоже можно безопасно грохнуть. открывам друго термиинал. наодижим pid докер клиента
и грохаем его чрез SIGKILL. дело в том что как ратает отпочковаыеие от конетйнера.
мы клиентом подключаемся к shim. мы посыаем синал клиенту. он его ловит своим хендлером
и шлет шиму а тот посылает его конейеру. так вот если я шлю клиенту sigkill то его 
нельзя поймать поэтому как бы ни хоел клиент поймать это сигнал и соощаить об неи шиму
у него нихенра не поуистя! итоооо суммарный рецемт. как правильно приаттачииться к коейнеру
docker attach --sig-proxy=false и жмем Ctrl+C все сальнео хуйя.
а если у нас уже есть запущеный docker attach без --sig-proxy=false то находим пид
этог кллиента и грожхаем через SIGKILL!!!!! полуается кога мы одключаемся клиентом к контейреру
а тчонее к шим который прексиурет уже нас в конейтенер то эти рпидулки также проксируют
все сигналы котоыре прилелтают в наш клиент. клиент их перехватывает и перенраялвет в шим
а шим в контйенет . НАХУЯ????

далее когадя я делаю attach то это всего навсего я чрез прокси щас подклчаютс к STDIN STDOIT
прцоеса контейнера. это значит то что Я НЕ УВИЖУ ТОГО ЧТОБ ЫЛО ДО ТОГО КАК Я ПОДКЛЮЧИСЛЯ! нет
никкого буфера ! все что было до подклчния надо смотреть в docekr logs а через attach 
можно уивдеть только то что высирает конетйреер прямо щас!!! понятно?!?!?!?
а я интуивино оиждаю что коода я делаю аттач то я увжиужу н етлоко т о что щас контейнер 
высирает но и то что было ! это хуйня! так не есть!

хочу сказать о том что нужно различать две разные штуки - одна шука это старт контейнера
и вторая щтука это подкючение к контенеру. так вот. когда мы подключаемся это мы 
подкючаемся клиентом к шим прокси. а когда мы стартуем контенер это создается конйенен
запускется процесс и у него stdout+stderr и иногоа stdin завораичивается на шим.
так вот кода мы делаем docker run то мы просим нетолько докер создать контйенер но также 
и покдлюяистя к нему! тоесть docker run = docker create + docker attach!
когда мы добавляем ключ -d то по факту это мы проис чтобы docker run сделал только 
docker run и не делал docker attach! вот каков истинный смысл этой загадочной фразы 
"запустить контейнер в detached режиме"! думаешь да что эт за хуйня. что значит создать
контейре в отключенном реиме сука! итак еще раз docker run нетлоко создает конейнер
но по дефолту и докер клиент "подключает\attach" нас к коенйенру! 
так вот ключ -d он запрещает после созданяи контенера подключатся к нему! таким образом
ключ -d он не о том что наш контенер запускается в каком то особом режиме! нет!это 
совсем не пропараметры запуска контейнера! это про докер клинет! мы просим докер клиент
не подключаться к контейнеру после его созданяи!!! это пиздц!  потому то когда видишь
ключ -d то думаешь что это процесс контйенера запускается в какомто "особом"реэме! 
а это хуян!  процесс в контйенер азпукается одинаково что с ключаом -d что без него!!сука!!!
ттак с ключом -d разобралсиь. ключ -d означает "эй докер клиент! псоле запуска контейенрера
не надо сука подключаться к окнтейнеру! покдлючаться значит atach"

тепер ключ -i = по дефолту когда конейнер создается то его stdout  и stderr заворачиватеся
на шим. а stdin заворачивается на /dev/null и это после этого никк не поменять!
так вот ключ -i дает то что /dev/stdin тоже заворачивается на шим!! вот и весь смысл

attach означает что мы докер клиентом подключаеся к шим. не к конейтенеру! а к шим!
но так как шим покдлчен к контейнеру то мы в итоге испольщуя шим как прокси как бы 
подкчаеся к конейтенеру! но по факту мы подкчаемся к шим! stdout\stderr и иногда 
srdin конейрера наарвален в шим. а он получая эьи данные перенапарвляет их нашему 
клиенту во врея того времени пока мы подключены к шим! а что происходит с даннными
которые летят от контйерера к шим кодга мы к шим не покдлчены? ответ - шим эти данные
сохраняет на диске. это называется логи контенера.

посколку attach - это подклбчение к шим а не к конейтенур то поключившис к шим мы 
можем получить только те данные с контейнера которые были запрограммиорвны на момент старта
контеейнра! а именно! если мы при старте контейнер не указали ключ -i это значит stdin
контейнера направлен в /dev/null а не в шим. это значит что кода мы подкчичлись к шим
то он никак нас не может перенаравить в stdin контйенера! нкиак!

ключ -t дает то что мы содании контйенера его stdout\stderr будут перенавлены в шиим
не через пайпы а через /pts/X устройства. шим будет выступать в роли терминала.
тоеть -t влияет на параметры старт процеса контейнера. формально процесс будет иметь
так называемый tty. КСТАТИ! получатся интерсная очень штука о которйо я изначально
нихера не замечал! как было арньше с компами. был мейнфрейм. условно говоря ситемный блок.
внутри него был цпу паять. и там сидели процессы. в систмном блоке было ядро. и были
устройства /dev/pts/X (на самом деел /dev/ttyX неважно). процеесс сидя в сист блоке
обращсялся к /dev/pts/X далее инфо попададла в ядро внутри сист блока. далее
по проводам инфо летела в физ железку - терминал. внутри терминала на цпу ни памяти
ни процессов нихуя не было. там только было экран и клава. информация прилетев  в терминал
сразу попадала на экран. едиснветннеое что можно было из процесса послать спец символы
и поменять цвет на экране или размер шрифта. и внутри терминала все таки была какая то
мелкая микросхема поэтому можно было из процесса моплсать некотоырй текст и  в ответ
эта микросхема могла послать какойто кусочек текса что бы сообщить проецссу о режиме
настроек на терминале. но важно именно то что внутри термигла ни каких процессов не было!
там было пусто!  пцерссы и ядро сидели внутри мейнврфейса! и /dev/pts/X тоже был внутри
мейврейма! терминал это был как удаленный жесткий диск подключеный по COM порту. к чему
это я. к тому что щас восприимаетяс что есть программа терминал (xterm gnome terminal) 
и внутри этой программы крутится процесс например баша! и это полная хуйня! никаких 
"внутри " терминала программ не крутистя!  некоректная фраз- программа запущена
внутри терминала! сука! внути терминала никаких прогармм процесссов не было! физчски не было!
они все сидели физичес внутри удаленного системного блока! прогарммы можно запустить тоьлько
С терминала ! не ВНУТРИ терминала ! а С терминала! а всегда они запускалсиь ВНУТРИ
удаленного мейнфрейма!  терминад это удаленный пуль управления от телевизора! телевизи
онная преедача запукется внутри теелвизора а не внутри пульа управления ска!
когда говорят что процесс имеет TTY это значит что этот процесс был запущен С темрианала.
а не внутри терминала! и это также озанчает то что процесс имеет открытый файл 
в который он может писать (как на диск) текст который будет отослан ядром на терминал.
а термина его нарисует на экране. если проесс имеет tty это значит что у процесса
есь открыйтый ядром "файл на диске" куда процесс может писать данные. 
и также процесс может читать данные с этого диска! только это недиск а чуть более диковинный
диск под названием терминал! и процесс может нетлко писать в файл и чиатть из файла
но и изменять настройки терминала. тоесть делать запросы и получать ответы о режиме 
работы терминала и посылаь запросы на изменение режима работы этой железки. тоесть через
файл можно нетлоько текст туда сюда гонять но и менять параметры работы железки.
пэтому когда говорят что процесс имеет tty это значит почти тоже самое что ядро 
поключило к процеассу доступ к файлу на диске! и больше ничегоособо! а процесс может
читаь из файла может пиать  в файл. и может через файл посылая спецтекст менять
параметры работы железки. тоесть если проецсс запущен с TTY это значит что у процесса
есть открытый файл. в котоыйр ог может писать может читать. и может через этот файл 
менять режим работы железки.   в отличие от обычного файла на жестком диске когда 
процесс не может через файл менять парметры работы диска.  кстаи tty файл можно 
сравнить с файлом /dev/sda . через него можно и данные писат чиать на диск но и менять 
паарметры раоты диска ! тоже самое ! толкьо вместо диска чуть более дисквинный диск
под названием терминал. если заыбтыть шас про контеры то на простом компе запущенный процесс
у которого есть tty означает то что STDIN, STDOUT,STDERR процесса перенаправлены на спец
программу. которая управляет графическим окном на экране ноутбука. полчается процесс
пишет в  файл который ведет в терминал. тоесть в ту другую программу. она принимает 
данные и рисует и пеерводит эти данные в симоволы в графиеском окне экрана ноутбука. 
если процесс на компе неимеет tty это значит что такой процесс может вообще неиметь
открыйтых файлов и в итоге не выдавать наруу себя никаких выходных данных. либо
у процесса может быт открыть файл но не tty и выходыне данные процесс пишет на диск!
или у процесса может быть открыт файл ведущий в примнтер. и процесс может писать
выходыне данные на примнтер!  тоесть еслли  упроцесса на компе есть tty значит у процесса
внутри компа есть открый файл в который он пишет данные и этот файл ведет в программу эму
лятор тмерминала и эта программа полученны данные рисует графически в какомто
окне на экране компа. тоесть если процесс имеет tty значит где то среди окон на компе
можно найти такое окно где будут нарисованы данные из этого процессса! вот что значит 
на ппактике наличие tty у процесса на компе! значит на компе где то есть посредник
котоый от этого процесса получает данные и рисует их на экране компа в каотом 
выделенном окне. типа хей! я процесс у меня есть tty ! это доожно пеерводистя в голове
как "у этого процесса на компе есть посредник который принимает от этого процесса данные
и рисует их в каком то выдленом окне на компе!"  это как бы похожн на то что - у процесса
есть жена. ага! значит у этоо процесса естт дети!  типа - у этого процесса есть tty  - значит
где то на компе есть окно с выходными данными вылетевшими из этого процесса! вотчто это згачит!
если  упроцесса нет tty это значит что на комме нет такого окна где были бы выходные
данные вылетевшие из этого процессса!  ятут коснулся аспекте "выходные даннные процесса". так
вот наличие tty также занчит что на компе есть окно нажав на которое и потом нажимая
на клавиатуру мы можем посредством этого окна послать данные внутрь этого процессса!
вот что еще значит наичие tty! ели у процесса нет tty это значит что на компе нет 
такого окна нажав на коорое и нажимая на клаву мы могли бы послать в процесс данные!
это не значит что в процесс никак нельзя данные послать. но их нельзя послать 
с помощью окна ! нет такого окна ччерез которое можно было бы постучать внутрь 
процесса ! наличие tty у процесса подразумевает то что данный процесс подразумевает
взаимодейсвтие  с человеком. процесс значит из себя высирает какито данные которые 
мы должны видеть визаьно глазами. и  процессу нужны от человека данные которые человек
должен совать в этт процесс. еще раз - наличие tty подразумевает что процесс таков
что должно быть какое то "общение" взаимодйствие между человеком и процессом. подразумевается
что процесс будет "говорить " с человеком а человек будет " говориить " с процессом.
процесс будет говрить с человеком через симоволы в окне. а челоек будет отвечать
процессу через нажатие на клаву в окне. если у процесса нет tty значит работа процесса 
такова что она не подразумевает общение этооо процесса человеком. тоеть скажем 
проецсс с tty который опозволяет читать книги. процесс - покзывает человеку в окне
содерзжиме книниги. а человек через клаву обьчяняет процессу какую книгу ему показать. 
процесс который  следит чтобы если переполнилас память то начать убивать процессы - работа
этого процесса не подразумевает общение с члоевеком. ни человеку ни процессу этго не нужно.
процесс автономно ищет такие программы и убивает их. такому процессу tty ненужен. 
вот что дает наличие ии отсутвиве tty у процесса!
тепрь взрвщващаеся к контенерам. если процесс в контейнере запущен без -t
этр значит что процесс внутри контйнере запущен без tty. это значит что работа данного 
процесса не подразумевает чтобы процесс посылал какую то информацию на экран. не подра
зумевает чтобы у процесса было чтото чтобы он печаатл на экране а мы бы ее читали.
также это подразумевает что процессу ненужна никакая инфомрация от человека введенная в
клавиатуры. тоесь работа данного процесса не пдразумевает ни вывод тексат на экран
ни ввода внутрь этого процесса никакой информации от человека.  работу процесса 
не прдразумевает никго  интеравтикного взаимодействия мжду челоеком и процессом. 
процес будетт работат автномно. не соприксасвясь с челоком. напрмиер солнце светит 
на неебе. и никакого взмиодетсвия между солнцем и челокком нет. так и этот процесс.
отсвтуисвие tty означает что для работы процесса не нужны от челокка никакие данные 
которй бы человек мог передать процессу чрез клаву. процессу от человека для работы
нихрена ненужно. и у процесса в процесе работы невозникает никаких данны котоыре бы
нужны были человеку прочитать. ели прцоесс запущен с -t тост с tty 
это занчит что у процесса в процессе рабтты будет появлсят полезая для человека
инфомрация которую можно будет прочиать  в фомрет текста. также  это озгчает что 
процссу для работы нужна будет от члеоовкека инфомрация которую человек долже будет
сообщать процессу. через печаь на клаве в какомто окне. 
напрмиер жинкс. ему с клавы от человека в процесс его рабты нихрена никакой инфомрации
ненужно. что касается продукта труда процесса то этот продукт процесс предоставляет
не в форме "текста" а в форме HTTML хрени. а терминал TTY он требует чтобы продукт
труда процесса выдывался со стороны терминала в формет голого тектс.а поэтому
запускать жинкс с tty нет смысла.  втоже время bash. чтобы баш мог раобтаьт ему потоянно
нужно чтобы члоеквек потавлял бащу данны с клавы. также результат труда баш предсталвяет
собой голвый текст , который еловек хочет ичтать. поэтому башу нужен tty.
может ли человек чтото собщить процессу без исопльзвагия теоминала. да может!
но нужен посредник! другой процесс. тогда это выгдяит так - человек через терминал
сует инфорцию . терминал (железка) шлет инфо в процесс который имеет tty файл.
процесс принимае инфо а далее этот процесс через пайп шлет эту инфо конечному процесуу.
и наоброт. процес может через пайп сообщить инфо другом упроцессу. а тот процесс
через файл tty может послать эту инфо на экраен терминала которй покажет эту инфо в форме
текста. в нашем случае цепочка выгдяит так

   терминал - баш - клиент докера - шим - контейнер

   мы в терминале вбиваем текст. темринал шлет ее в баш который имеет tty. 
   баш запускает клиент докера котрому он тоже подклчает tty  для того чтобы киент докера 
   мог посылать текстовую инфо в терминал чтобы мы видели что делает клиент и принимать до че
   ловека нужную инфо через кнопки
(после    этоо баш засыпает отклбчается от терминала). клиент докера 
свзывается уже без терминала с процессом шим и передает от нас то что мы заказали
у киента докера. посылает он это ллибо через пайп либо через сокет. 
шим имеет связь с контееноом через пайп. дрвух сторонюю. таким образом образуетс
связ между человеком и процессов внутри конерера. 
едст мы встлавяем ключ -t то создатеся файл терминала /prs/X и процесс контенера
покдлчается к этому файлу. получается этот процесс становистя связан как бы с неким
окном терминала. дальше полуается хитро. терминал с его окном и клавой начинает
эмулировать шим процесс. получается что шим процесс принимает данные от контенейнера
но ни на каком экране он их не рисует. также шим процесс посылает коненеру текст
но с клавы никто его не вводил. контенеру думает что он посылает данные на терминал 
и что данные рилетатт с термиала. но это брехня и наебка. это шим проецсс так наебывает
процесс контейнера. на самом деле шим получив данные преобразует их и отправляет их 
то ли через сокет то ли через пайп докер клиенту. то через пайп\сокет
потавряелят их башу. а баш их преобарзовав отравляет нам на терминал. 
спрашивается нахуй нам через шиим наебывать процесс в конйенере чтобы тот думал 
что подкючен к терминалу? например некоторый проеграмы так изанчально написаны
что они могут раотать только если к ним подкчен терминал. например это прогарма баш.
если мы ее запустим без подключенного терминала она попробует его инцииализировать.
получит ошику и умрет.   я говорю - процесс может приимать данные и отслыать их 
не через термиал а через пайп или сокет. но это подразумевает что  этот процесс 
общается не с человеком а с другим процессом. если программа которую мы запукаем 
внутри терминал подразумевает ощбщение  с человеком то ее надо запускать с tty.
шим не может так сделать чтобы подключить терминал наего компа внутрь контйенера,
но шим может сам запустить внутри себя терминал. и разговаривать с процессом 
на языке терминала. и посылать ее грубо говоря уже в "нащ терминал"
есть еще такой класс программ - они  из себя высирают текст котоый полезен человеку
и при этом они с насторйками терминала не завязываются. тоесть такая программа
она может отослать текст хоть в файл термиала хоть в пайп. в целом ей похеру. 
например мы можем вот сделтьа

   $ exec cat ~/1.txt

по факту бинник баща будет заменен на бинарник cat , cat будет читать файл и срать 
тексом на stdout. текст может вылетать как в другой процес через пайп так и в файл
которй вдет не терминал. в данном лучае cat высрет тект  в файл терминала. и мы 
увидим текст на кране термианла. при этом cat никаикх настрок термиала неделает.
или 

 $ read $1

это программа принимат данные с stdin. она может их приять как от дргог процесса
через пайп так и с файла терминала то есть из терминала. ей пофиг. 

програмы которе жесткр требуею темрина типа баша - они сособенны тем что эти программы
делают через сискол и указав как один и парамтеров файл терминала насройки на терминале.
и если ядро возрватит ошибку (потому что файл указанный не терминала) то такая програма
просто закончит свою работу и все. такие тчно надо засткать с -t ключом.

так вот про прогарммы котоыре вобщем то с человком не взаимодейтсвуют тоесть 
им терминал ненужен но ингда он чтото в форме текста из себя высирают. их можно 
запускать без -t. через пайп их stdout будет завернут на процесс шима.

рассмттрим примеры конкетыне. 
прогрмма редис. ей в целом ненужно взаимдоействоват с чловеком. но иногда она 
высирает из себя простой текс с полезной инфо. 
запускаю ее вот так
# docker run  --rm --name "redis2" redis
1:C 27 Apr 2024 21:55:33.453 # WARNING Memory overcommit must be enabled! Without it, a background 

тоесть я говорю докеру: создай контейнер. запусти в нем процесс редиса. 
так как нет ключа -i то не заворачивай stdin проецсса на шим. заверни его на dev/null
не создавай на шим эмулятор терминала и не вставляй файл терминала на процесс редиса.
заверни stdout\stderr на шиим через пайпы. редис автономный процесс ему от нас с клавый
ничего ненадо. иногда он просто текст высирает из себя поэтому ни -i ни -t мы не выставляем.
тоест ввод к нопоко ему от человека ненужен . пэтому ключ -i  я не выставляю.
терминал редису не нужен.  я его ему и недаю поэтому. да он чтот из себя высирает
иногда. ну нам чтобы это прочитаь хватит шима который примет через пайп то что хотел нам 
сказать редис.  как видно редис высрал из себя немного текста. его шим чреез пайп принял.
и переслал через пайп\сокет нашему докер клиенту. а тот высрал это уже нам на экране
нащего терминала. то есть все сработало. также так как я не указал -d это значит что
полсе тго как контенер был создан то докер клиент поключися к шим и через него 
покдлючился к stdout\stderr конйенера. ну ли скажем подругому  - клент подключтися к шим
и спрсил. нет ли там чего от контенера по каналам stderr\stdout? и шим сказал что есть.
и выдал клиенту докера. а он нам на терминал.

кстати если мы через докер run сразу подключаеся к конйеру то чтобы иметь 
взможность от него откобчиься и мы погасить при этмо окнейтенр то полезно в 
docekr run указыват --sig-proxy=false вот так

docker run  --sig-proxy=false --name "ng4" ngnx
по мне это саамая оптимаяльная форма запуакка конейнера. в отичие от -d потмоу что
с одной стороны мы сразу видим успешно контйеенр тсратунсл или нет. а сдругой стороны
мы ожем соааойно оключти от него без гаения процесса.  запупск конейтеера через -d
хуже тем что нам нужно вводит еще одну комнуд чтобы приа тачиться к конйтеноу
чтобы процеть все ли успено у него подкнялосьь.

команда docker start вот чем плоха. у нее есть опция --attach
чтобы сразу проверть что конетнуер успешно стартунул но при этом у нее нет 
опции --sig-proxy=false
поэтому аттачиться нельзя при docker start
надо стартануть а потом уже одеьной командйо атачитьсятоест
тоесть правильно вот так
$ docker start ng1
$ docker attach --sig-proxy=false ng1

и тут я выяснил еще одну подьебку. вот я уже думал что самый идельный 
способ подклчения к окнтенренур это 

$ docker attach --sig-proxy=false ng1

потому что из контейнера можно отключиться через Ctrl-C и мы и отключиимся
и процесс в конейнере не останвоим. но оказалось что это еще не конец мучений!
окзывается что это все верно если мы запустили контейнер без -t ключа!
а если с ним то докер клиент нихуя сука от конейнера не отключаеся!
а чтобы он отключился надо запускать вот так!

$ docker attach --sig-proxy="false"  --detach-keys="ctrl-c"  bash1

ВОТ ЭТО ИДЕАЛЬНЫЙ ВАРИАНТ ATTACH к контенейнеру! мы можем отключться через Ctrl-C
и при этом не застопим процесс контейнера!


если у проуесса нет кастмного хедлра для SIGTERM и скажем это тестоывый контйрер
то чтобы ускорить проецсс остановки окнтйенер и неждать 10с можно укзаат 
при старте чтобы докер его останвливает через SIGKILL вот так
$ docker run  --stop-signal=SIGKILL ...

напрмиер 
# docker run --name 134 --sig-proxy=false --stop-signal=SIGKILL 134

у команы start есть стремная оация -i указано что она покдлючет stdin конйенера.
у меня была вресия что start это же запуск прцоесаа. что если мы при созании конейтенера
не указали -i то почму бы это не поменять при старте. нет же ниаких проблем. так как
прцоесс создается заново . но нет это не про то. это про то что при старте 
еще и приатачиться к контенеру. и пробрость stdin с докер клиента на шим. но при этом понятр
что если при содании конйтенера мы неукзали -i то толку пробрсывать с докер клиента stdin
на штим нет. на шим то мы прбростили а с шиима в контейнер проброса то нет! 
так вот в чем еще прикол у start еть ключ -a (attach) он подклчаем  с киента на шим
stdout и stderr и сигналы! и ключ -i который тоже делает attach и сигналы и stdout и stderr
покзываю
# docker start --help
  -a, --attach               Attach STDOUT/STDERR and forward signals
  -i, --interactive          Attach container's STDIN

раве это не дебилизм. тоесть -i это вточности -a толкьо еще с докер клиента
в шим подключается stdin с докер клиента. тоесть -i = -a только еще и stdin докер 
клента подкчатся к шим. но при этом при старте процесса его stdin завернется на штим
только если при СОЗДАНИИ этого контенера там было указано так сделать! дебилизм


так вот что еще я обнаружил важного. если я стартую контйнер без -t
а он высирает из себя просто текст и мы аттачимся к конйтенйеру то 
для каких процессов докер печаатет на экране то что высирает процесс
например для жинкса и редиса он сразу печатает.
а для каикхто процесов например сампоисна на c программа - докер 
нихрена при аттаче ничего не экране не печатает. если у программы
естт хендлер для sigterm то тогда докер напечтает то что она срала на экран
при остановке контейнера. тоже самое касается логов.
таким образом я бы рекомендоал при старте демонов вначале заумккаем его
с ключом -t. смотрим что он на экране срет. 
потом заупскаем без ключа -t и смотим будет ли на кране чото или нет.
если нет то уже оконачкльно запускает демона с ключом -t
почему такая херна = незнаю.

# docker run -t --name 134 --sig-proxy=false --stop-signal=SIGKILL\SIGTERM  134

кстаи еще одна уообяняшка. мы хотим застопть контейнер. а у него нет экндела SIGTERM
и нам невжно что даные потреются. то гда чтобы не ждат 10 с стопим его 
чрез SIGKILL вот так

$ docker stop --signal=SIGKILL $id

вот тоже удобно. ключ --no-stream чтобы выести таблицу 1 раз без обновления 
# docker stats --no-stream
CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O         BLOCK I/O         PIDS
38a2987103f0   busybox   0.00%     516KiB / 437.5MiB     0.12%     2.2kB / 796B    1.36MB / 0B       1
79d9b0e44809   alpine    0.00%     696KiB / 437.5MiB     0.16%     3.41kB / 796B   1.7MB / 0B        1
b7d1bf6c45eb   nginx     0.00%     2.387MiB / 437.5MiB   0.55%     4.14kB / 866B   11.4MB / 12.3kB   2
136fe38413f1   22        0.00%     660KiB / 437.5MiB     0.15%     4.93kB / 866B   1.9MB / 0B        1
e9ab745aa9cb   131       0.00%     612KiB / 437.5MiB     0.14%     5.45kB / 866B   455kB / 0B        2
888fafb44b4c   133       0.01%     340KiB / 437.5MiB     0.08%     7.08kB / 866B   16.4kB / 0B       1
516b13a7ba9e   134       0.00%     588KiB / 437.5MiB     0.13%     7.81kB / 866B   291kB / 0B        2


как по быстрому останвоить все контенеры
# docker stop --signal=SIGKILL $(docker ps -q)





 ==
 неьль зя сделтаь clone (clONE_NEWNS, CLONE_MOUNT) в докер конейнере. потому нельзя 
 внутри нейсмейса создавать ноаые нейсппейы.
 докер написал что cloen тnot permioted. так вот дело не в клон. дело во флагах!


 
 который создается 
перед созданием контенера. shim будет выполнять роль прокси. 

$ docker exec 
$docker attach 




==

