| mmap
| malloc
| brk

начну с mmap
обычно это команда нужна чтобы можно было файл спроецировать в память. чтобы
ездия туда сюда по памяти мы ездили внутри файла. в чем фишка
вместо read() write() незнаю. 
в мане привоится пример 

...
  fd = open(argv[1], O_RDONLY);
...
addr = mmap(NULL, length + offset - pa_offset, PROT_READ,
                       MAP_PRIVATE, fd, pa_offset);
...
 s = write(STDOUT_FILENO, addr + offset - pa_offset, length);


тоесть отрывается файл. получаем fd для него.
потом этот fd подсовываем в mmap. теперь обращаясь по адресу addr
и так далее мы ездиим не по памяти а внутри файла.
далее мы печатаем на stdout то что лежит по адресу addr длинной length.
все же не очень понимаю как особый прок от mmap по сравнению с read()
или write()
инутититивно есть тольк оощущение что когда у нас файл замаплен в память
и мы уже можем раобтать с файлом на диске просто как с куском памяти.
то наверное скажем искать в таком куске памяти удобнее чем если чтото
искать в файле читая его по кускам анализируя и потом опять читая
какойто кусок. 
ладно. пока нпонятно. двигаем дальше

так вот при запуске

$ cat /tmp/1.txt

в ее трейсе я увидел такую команду


mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9c2c9b4000

я заинтереосвалася нахрен cat нужен mmap. 

и вылез  интересный флаг 
MAP_ANONYMOUS

он говорит о том что на самом деле кусок памяти 139264 байта который
запрашивается он не будет вести ни на какой файл! о чем также
дальге свидествутуает число -1 это типа номер файл дескриптора
который игнориуется если мы такой флаг юзаем. 


 MAP_ANONYMOUS
              The  mapping  is  not  backed  by any file; its contents are initialized to zero.  The fd argument is ignored; however, some implementations
              require fd to be -1 if MAP_ANONYMOUS (or MAP_ANON) is specified, and portable applications should ensure this.  The offset  argument  should
              be zero.  The use of MAP_ANONYMOUS in conjunction with MAP_SHARED is supported on Linux only since kernel 2.4.

получается такое испльзование mmap приводит к тому что ядро
берет кусок вирт памяти процесса. весь его зануляет. (тоесть у нас не будет
ошиьбки segmentaion fault при обращении внутрт этого куска)
и возврашает нам адрес начала этого куска. фишка также в том что этот 
кусок от иницаилизируется не в области стека и не в области статической
памяти процесса а в области heap. тоест если нашему процессу нужен кусок
инициализированой непрерывной памяти где то в heap то можно заюзать
mmap например чобы потом туда какйото массив начать писать. вобщем неочень
понятно нахрен это нужно команде cat но  вцелом прикольно было об этом узнать


работа команды cat выгоялдит так

openat(AT_FDCWD, "./kubernetes.txt", O_RDONLY) = 3
fstat(3, , ...}) = 0
fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0
mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f3161e1a000
read(3, "...."..., 131072) = 131072
write(1, ..."..., 131072) = 131072
...
...
read(3,)
write(1,)
read(3,)
write(1,)
munmap(0x7f3161e1a000, 139264)          = 0

тоесть открыается файл который нужно читаать.
счтываеются его параетры свойства.
делается указание ядру что мы будем щас читат секвенциально
в памяти heap у ядра закаызается кусок памяти инициализованной размер 139264 байта
потом идет куча read() write() когда cat читает из файла на диске
и пишет в stdout то что он прочитал.
и когда файл считан то запускется unmap чтобы вернуть память ядру
нахрен был нужен этот mmap munmap хрен знает


далее malloc 
это не системный вызов это си функция. поэтому в strace мы никакого
malloc не увидим. также это можно поняь если вызвать 
	$ man malloc
и будеь написано
MALLOC(3) 
вот эта тройка (так называемая третья секция) означает что это не сист вызов.
практика поазывает что malloc использует при своем запуске brk() и mmap()
их мы увидим в strace


распределение памяти в процессе можно увидеть в /proc
$ cat /proc/self/maps
55609bc98000-55609bca0000 r-xp 00000000 103:02 25690137                  /bin/cat
55609be9f000-55609bea0000 r--p 00007000 103:02 25690137                  /bin/cat
55609bea0000-55609bea1000 rw-p 00008000 103:02 25690137                  /bin/cat
55609d67a000-55609d69b000 rw-p 00000000 00:00 0                          [heap]
7fd685d9c000-7fd686068000 r--p 00000000 103:02 23330897                  /usr/lib/locale/locale-archive
7fd686068000-7fd68624f000 r-xp 00000000 103:02 13250051                  /lib/x86_64-linux-gnu/libc-2.27.so
7fd68624f000-7fd68644f000 ---p 001e7000 103:02 13250051                  /lib/x86_64-linux-gnu/libc-2.27.so
7fd68644f000-7fd686453000 r--p 001e7000 103:02 13250051                  /lib/x86_64-linux-gnu/libc-2.27.so
7fd686453000-7fd686455000 rw-p 001eb000 103:02 13250051                  /lib/x86_64-linux-gnu/libc-2.27.so
7fd686455000-7fd686459000 rw-p 00000000 00:00 0 
7fd686459000-7fd686482000 r-xp 00000000 103:02 13245746                  /lib/x86_64-linux-gnu/ld-2.27.so
7fd68664f000-7fd686651000 rw-p 00000000 00:00 0 
7fd686660000-7fd686682000 rw-p 00000000 00:00 0 
7fd686682000-7fd686683000 r--p 00029000 103:02 13245746                  /lib/x86_64-linux-gnu/ld-2.27.so
7fd686683000-7fd686684000 rw-p 0002a000 103:02 13245746                  /lib/x86_64-linux-gnu/ld-2.27.so
7fd686684000-7fd686685000 rw-p 00000000 00:00 0 
7ffdfd654000-7ffdfd675000 rw-p 00000000 00:00 0                          [stack]
7ffdfd6bf000-7ffdfd6c2000 r--p 00000000 00:00 0                          [vvar]
7ffdfd6c2000-7ffdfd6c3000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]
 

щас подробно об этом погоорим.
первая строчка
55609bc98000-55609bca0000 r-xp 00000000 103:02 25690137                  /bin/cat



static переменная<===
global переменная <===

каждая сеция имеет флаг "r-xp"
55eb7f979000-55eb7fa7d000 r-xp 00000000 103:02 25690119   /bin/bash
он покзыат что с этой сецией можно делать. 
эту скцию можно чиать и выполнят ее код. тоесть это тот кусок 
фала баша где лежит код. "p" означет я думаю protected?

прикол в том что то где алллоцирует память mmap это нихрена не heap!!!
оба-на!



char *p=(char*)malloc(sizeof(char));

посчитаь размер стека  <==================
посмратитать размер каждого сегмента 183.exe <==================
подмапить файл посмотеть что он повиятся тоже в списке  <==================
после тго как я выделил памят через malloc (тоесть brk или mmap) <==================
   попроать там поприсваивать значения ячейкам произволльным.  <==================
   даст ли ядро или будет segmnation fault ? <==================
vvar ? <==================
vdso ? <==================
vsysvall ? <==================


