если у процеса есть /dev/pts/X
то гоорят это процес открыл терминал!!! как буто этот процесс как челоек
сидит перед терминалом. ХУЙНЯ!!!!
как ра таки сидит перед терминалом удаленный процесс владеле ц терминала.
он эмулирует члеовеа сеибящего пеиед ерминалмло.м
а этот процесс этот тот процес К КОТОРОМУ ПОДКЛЮЧЕН тот самый удаленнй терминал


процесс1 < -/dev/pts/X -> --------ядро-------/dev/ptmx---(удаленный терминал) --владаеллец
уделенного терминала(ака вирт человека) процесс2

у процесса2 открыт терминал
а процесс1 это тот к кому пдкодчен удаленнй терминал.

сигнал SIGHUP прилетает именно процессу1 сигнализируя что удаленный терминал
больше не доступен чтобы процесс1 принял рещение стоит ли дальше работать
или нет. плсыдает его либо процесс2 либо ядро.
на практике щсс обычно это обозначает что либо процесс2 сдох. либо процесс2 
закрывает "терминальную линию связи" /dev/pts/X от него к процессу1

что значит в практиеческом плане если мы видим что вот есть процесс у котрого tty2

$ w
 22:03:15 up 7 min,  1 user,  load average: 3,05, 1,82, 0,83
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
vasya    tty2     -                22:03    3.00s  0.13s  0.10s -bash

это значит что  К ЭТОМУ ПРОЦЕССУ подключен где то там хрен 
знает где расположенный  терминал! тоеть наличиу у процесса tty здесь значит 
что терминал есть где то там ! есть где то там располженный темринал который стучит
на этот процесс. посыдает в этот процесс данные. получает с этого процесса данные.
процесс с tty выступает как фтп сервер а где то там расопложенный терминал выступает 
как фтп клиент. и что ? а то что если указано что у процесса здесь есть tty* 
то это значит что клиент(теримнал) расположен в одном из окон Ctrl-Alt-[123456789]
тоеть это значит что если мы пееркчлючимся в одно из этих оконо мы обнаружим 
что в одном из окон ввели пароль. и там висит баш. и в нем можно вводить команды.
про tty вобще интерсно. у нас процес получает файлы /dev/tty1 это как ыб клентсака
я часть . а серверной нет. тоеть нет процесса который бы является держателем терминала.
тоесть держателем ялвляется само ядро. поэтому если какойто процесс получил себе
открытые файлы /dev/tty1 то тогда все что он посывлает туда летит в ядро и сразу на 
экран который пояяелсят при Ctrl-Alt-1. и наоброт. все что нажимается с кнопок в
режиме экрана Ctrl-Alt-1 оно автомато летит в ядро а оотуа к процессу у котрого 
открты /dev/tty1. 
если кайото пцроесс имеет /dev/pts/N откртый это значит что это где то к  этому поцессу
подкючен терминал. и трминалом явялется ДРУГОЙ ПРОЦЕСС! тот процесс явялется держеталем
терминала. саму фнукцию терминаал обеспечиват ядро. так вот тот удаленй процесс он 
может иметь окно (для челоека) так ег и неиметь. 
поэтому 
если мы видим что прцоесс иемм откртый /dev/tty1 это значит надо беатжать в 
окно CTrl-Alt-1 и там смотреть чтотам туда этот процесс срет. и копки в том окне 
будут лететь прям в ттот прцоесс. это значит то в окне ctrl-alt-1 вели пароль. и открыйли
там баш. вот что это занчит
если мы видим /dev/pts/N то это значит надо на компе скрочно искать второй процесс 
с которрых эттот прцесс через "термнанлые" файлы /dev/pts/N общается. повторю при этом 
вторая прогрммма аовсоюнтго необязана иметь окно гарфическое чтобы сообщать члеокек
о чем они там говяоврият.

надо эту тему еще подумать додумать.
как бы впрос тко - если мы вилим что роцес имееть tty ил pts а что эо на апрктиуке 
значит?






==

а до этого я занимался вопросом как вставить процесс в cgroup.
окащалост что docker top покзывает не процессы которые имеют оди еймсейс! нет!
а процессы которые сидят в одной цгруппе. 
докер топ считает что преыесы сидят в одном онтейнерере если они сидят в одной цгруппе!
а на неймспейсы ему похуй!!!

 !! итакже тоогда я непонял а что же тогда означает неймсаеймкйс
cgroup. в чем разгица между proc/cgroup где написано в кааокй цгруп входит процесс
и неймспейсом cgroup ? у менч такое ощущение что неймспейс cgroup это как маунт нейсмекпейс.
тоесть новй неймспейс цгрупп это копия /sys/fs/cgroup но в ней можно деоа измнееия
котоыре потом в родтелет не отметться?????
тоесть почему цгруппа и цгрупп неймспейс это разное ??!?!?!?!?!!?!?!


чтоо еще меня пораило в shim процессе. мы делаем docker exec bash
это по факту это выгдяит так. shim себя клонирует. и потом делает execve bash
и получается очень интерено. новый баш заворачивает свои fd/* в shim
а докер клиент сутчится в shim


вопросы:
shim
  1) у него родииель systemd а не conatinered 
  но это незначит что его породил systemd
  надо проверить по неймсмейсам кто его порродил. просто тот кто его породил 
  вышел и новыым парентмо был назненен systdm
  а sytemd нго родитьео чтобы еси шим сдохнет то чтобы sytsmed занималя
  его wait()
  2) у него сокет с containerd. чтобы контейнерд мог делать заросы общаться 
  с shim о состоянии злоровтя контйенеров за которым смориит shim
  3) я думаю что containerd созщает шим. и дает более ошую команду 
  сосзать контейнер. а shum уже умеет облатся с runc/crun и дает более кокнерую 
  команду runc\crun . shim это руки от conerrdd. агент соаватель. connerd прораб
  а шим это рабочий

что дает дочке что он дочка такого парента
 дает то что  у нее обычно общие с парентом нейспейсы и файлы
что дает родиеою что процесс его дочка. тоже что и предудщий пункт
иеще родител нужно будет делать wait()
в чем фишка если процесс1 доелает дочку процесс2  а процссесс2 делет дочеу процесс3
а потом прое2 выходит и процесс3 теряет родииеоя и его рдителя systemd ?


докер и pod что осттется поле перзапуска в плане остаюбтся ли 
темжи самыми неймсйссы. цгруппы. ip?
тоесть если коненеры сидели в гурппе что они теряют. настолько ли эфемерны поды 
как об этом пздит дока к8 ?

==


на счет создания руками в докере аналога пода.
у пода под деолу  у его кнтйенеров обшиме нееймсейсы .
на счет общие ли у них цгруппы это вопрос!
но разные pid , mnt нейспейсы 
поэтому в бытовом плане у пода конейтеов общая только сеть! это дает только то что
онм мргу друн сдругом на lo интефрсе через бинды обшаться

докер повяие обтедениь кониейнеры как раз наоброт. чтобы у них были максиму 
это ьбшая сеть, pid, mnt нейспейсы! тоесть докер конетрнкы их група
может стать пхожда на под макмсмумс толко изза того что у них сеть обащая.

напомню виды неймспсов
$ ls -1 /proc/self/ns
cgroup
ipc  <===
mnt  <===
net  <===
pid  <===
user 
uts

кстаи! кога я хочу помтреть нейсейсы проецсса то 
$ ls -1 /proc/self/ns
покжает ns для процесса ls!
а 
$ ls -1 /proc/$$/ns
покжает нейспсейсы для посденего интераткивного баша!
$ ls -1 /proc/$$BASHPID/ns
покажт для посдеднего ближашего баша неважно инерактивнй он или нет

как посдить два докре коентейнер а одну пид неймсейс 
docker run --name c1 --pid=container:c2 -d ubuntu sh -c 'sleep 1d'



===

