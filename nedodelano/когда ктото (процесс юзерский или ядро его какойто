когда ктото (процесс юзерский или ядро его какойто кусок) шлют сигнал процессу
это значит что другой кусок ядра в свойствах процесса вносит пометку о так
назыаемом сигнале. это приводит к тому что третий кусок ядра шедулер когда доходит
до этого процесса вместо того чтобы на цпу совать код этого процесса сует на цпу 
обработчик этого сигнала




---

как докер стоит контйенер. он шлет процессу запущенному в контейнере сигнал SIGTERM.
потом ждет 10с. если процесс все еще не сдох то он шлет сигнал SIGKILL
так вот вопрос - если у нас контенер сидит в своем pid неймспейсе то понятно что 
легко понять какому процессу нужно слать сигнал ==> pid=1
а если процесс (контейнер) сидит в pid namepsace друогого контейнера. то наш
процесс который крутится в контейнере уже имеет хрен знает как pid. как тогда 
докер выкрчитвается?

--
если в контейнере есть несклоько процессов. мы нажали docker stop ID
то головной 

--
процесс с pid=1 имеет такие дефолтовые хендлеры что они игнорирует все сигналы. 
даже SIGKILL. и только если код этого процесса имеет свои кастомные хендлеры
тогда посылка сигнала таому процессу приведет к успеху. кстати прикол еще в том
что для sigterm\sigint итп можно напсать кастомные хндлер а для sigkill по прежнему
нет. 
также если запустить
bash в качесвте pid=1 то он среагиурет на сигнал. а если systemd то вивдимо пошлет нахер.

--
