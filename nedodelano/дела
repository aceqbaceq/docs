дела
-
разберемся какой вид имеет отрицательное для нас число внутри регистра. 
"понимает" цпу какое число в его регистре положительное или отрицательное?

- разобраться что происходит в цпу при операции умножения когда результат вызывает переполненеие по размеру регистра. физ смысл результата?

- что интересно. есть математический вид числа например в бинарном виде
скажем 
8 = 1000
и математический вид -8 в бинарном виде
-8 = -1000 (незнаю есть ли смысла вэтом с точки математики?)

а есть то как программа изголяется пытаясь сохранить число в реальных битах
реальных байтов в реальной памяти. дело в том что там нет никаких минусов. поэтому
в памяти нет вот такого -1000
в памяти программа сохраняет -8  в виде 1000
ипоэтому вот это интересно


 $ echo "obase=10;ibase=2; 1111111111111111111111111111111111111111111111111111111111111110" | bc
18446744073709551614
 $ echo "obase=10;ibase=10; 2^63 " | bc
9223372036854775808
 $ echo "obase=10;ibase=10; 2^63-1 " | bc
9223372036854775807
 $ echo "obase=10;ibase=10; 2^64 " | bc
18446744073709551616
 $ echo "obase=2;ibase=10; -2^64 " | bc
10000000000000000000000000000000000000000000000000000000000000000
 $ echo "obase=2;ibase=10; -15 " | bc
-1111
 $ echo "obase=2;ibase=10; -255 " | bc
-11111111
 $ echo "obase=2;ibase=10; -0.5*2^64 " | bc
-1000000000000000000000000000000000000000000000000000000000000000.00\
00
 $ echo "obase=2;ibase=10; -0.5*(2^64-1) " | bc
-111111111111111111111111111111111111111111111111111111111111111.100\
0
 $ echo "obase=2;ibase=10; -0.5*(2^63-1) " | bc
-11111111111111111111111111111111111111111111111111111111111111.1000
 $ echo "obase=2;ibase=10; -0.5*(2^62-1) " | bc
-1111111111111111111111111111111111111111111111111111111111111.1000
 $ echo "obase=2;ibase=10; -0.5*(2^62) " | bc
-10000000000000000000000000000000000000000000000000000000000000.0000
 $ echo "obase=2;ibase=10; (2^62)/2 " | bc
10000000000000000000000000000000000000000000000000000000000000
 $ echo "obase=2;ibase=10; -(2^62)/2 " | bc
-10000000000000000000000000000000000000000000000000000000000000
 $ echo $(( 2#101  ))
5
 $ echo $(( -2#101  ))
-5
 $ 

и втоже время
$ echo $(( ~ 0 ))
-1

удивительно поразительно!


- разобраться  с кодировкой отрицательных чисел
- глобальный вопрос как внутри компа харнстя отрицательные числа.
или это чисто на усмотрение программы ведь для цпу все числа положительные(или для цпу нетак?)
- как тгда насчет этого вропроса когда просили показать число в бинарном виде
toBinary () 
{ 
    local n bits sign='';
    (($1<0)) && sign=-;
    for ((n=$sign$1 ; n>0 ; n >>= 1 ))
    do
        bits=$((n&1))$bits;
    done;
    printf "%s\n" "$sign${bits-0}"
}

ведь отрицательные числа так нехранятся. никакого минуса
внутри компа нет в памяти

- 
$ echo $(( 2**62 ))
4611686018427387904

$ echo $(( 2**63-1))
9223372036854775807

$ echo $(( 2**63 ))
-9223372036854775808

$ echo $(( 2**64 ))
0

$ echo $(( 2**65 ))
0

непонял почему?

-
$ echo $(( 0.1 * 0.1 ))
bash: 0.1 * 0.1 : syntax error: invalid arithmetic operator (error token is ".1 * 0.1 ")
$ echo $(( 0,1 * 0,1 ))
1
$ echo $(( 0,2 * 0,2 ))
2




- перечитать и дописать тему ARITHMETIC EVALUATION


- $ a=15;echo $(( a++ )); echo $a
	15
	16
	почему 15 ?

$ n=16; echo $(( n++  ))
16
$ n=16; echo $(( ++n  ))
17

почему разное показывает ?

- bash ((n=5 ; n>0 ; n >>= 1 ))
- bash как напечатать число в bin виде ?
- bash parameter expnasion $p vs ${p...} vs ${#x}
- c lvalue vs rvalue
- dc -e "3k2 3/p"
- /proc/stat
