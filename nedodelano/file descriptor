| file descriptor
| fd


физ смысл файл дескриптора. 

когда мы юзаем open() то как результтат он нашей 
проге возвращает число. называемое файл дескритор. что 
это за хуйня такая?

оказывается. ядро для процесса держит кусок в памяти в котором
она описывает все причинадалы процесса. в том числе там
есть таблица FD таблица. или File descritptor таблица!
в этой таблице есть столбик с номером. условно говоря этот столбик
описывает номер строчки в этой таблице. так вот этот номер 
строки в этом столбике это и есть file descritptor число который
ядро возвращает нащему проуесссу сука!
коггда мы в рамках нашего прцоесса просим ядро через open()
"открыть" файл. то ядро в своей памяти в в той части где ядро
держит всю инфо относящуются к процесссу она делает необходимые 
свои внутренние пригтоовления которые нужны ядру для работы с файлом,
ядро "отрывает" файл для дальнейшей работы. делает нужные запсии 
всякой хрени которые потом понадобятся ядру чтобы оно могло работать с 
файлом. это называется открыть файл. не мы открыаем файл. его открывает
ядро для себя по нашей просьтбе. так вот ядро делает нужные ему
записи в разных таблицах про файл с которым мы хотим рабтать. 
таких табица как миниумум три. одна это FD таблица. получается при 
открытии кажого нового файла по закаузу процесса в этой таблице прибавляется
строчка. каждая строчка сообщает нам о том что процесс захотел открыть 
еще один файл. поэтому каждый открытый ядром для процесса файл получает
согдасно этой талице свою строчку и свой порядоквый номер. потом позже
когда наш процесс хочет чтото сделать имнно с этим файлом то мы в 
функции read() write() указываем этот порядковый номер - номер строчки
в памяти ядра в таблице FD для этого процесса - и тогда ядро понимает 
с каким конкнетно файлом мы хотим чтобы ядро сделало запис или чтение!
сука! вот какой физ смысла этого сраного дескриптора! соотвсвтнно
в /proc мы можем увидеть сколко строчек создано в таллице FD нашим файлом
на данный момент (сколько отырытых файлов процесс имеет )

$ ls -1al /proc/self/fd/
lrwx------ 1 vasya vasya 64 мая  8 22:00 0 -> /dev/pts/150
lrwx------ 1 vasya vasya 64 мая  8 22:00 1 -> /dev/pts/150
lrwx------ 1 vasya vasya 64 мая  8 22:00 2 -> /dev/pts/150
lr-x------ 1 vasya vasya 64 мая  8 22:00 3 -> /proc/10641/fd

папа fd в proc это есть ничто иное как отражение таблицы FD!!!!
нам показывается количество строчек в этой таблице  и даже
кое какая инфорация по кажой строчке!

таким образом fd число файл дескриптор это не какая то абстрактная херня.
это номер строки в конкретной таблице в памяти ядра в той части
где хранисят информаия о проецссе. 

когда мы пишем read(2,...)
мы гговорим ядру - загляини в свою FD таблицу. найдти там строку с номером 2
и из этого файла прочитай нам тото и тото !



таблица FD имеет вроде как простой вид. одна колонка это FD номер строки.
и вторая флаги файл дескриптора. я пока не понял но возможно как раз 
таки те флаги что указываются при открытии файла чрез open()
типа O_APPEND или O_CREAT они там и прописаны?

далее там еще есть стоблец он указывает на строку в таблице "File Table"
как я понял это таблица уже одна на весь хост ( в противоположность что  FD таблица идицидуальная
для кажого процесса). и там спмсок всех открытых фалов на хосте. 
а строка из той таблицы указывает на таблицу открытых инодов . тоесть 
по иноде уже точно понятно про какой файл идет речь.
я не очень понимаю как может быть одна таблица на весь хост по открытым
файлам ведь один процесс омжет открыть файл на запис и второй этот
же файл на запись. и у одного файла будет один "курсор" в этом файле на даный
момент а второго в другом месте "курсор". ладно.
главное что файл десприктор . его номер и его физ смысл
теперь имеет кокнетное осязаемое значнеие!

совстенно когда мы пишем

int i = open ("/wew/we/1.txt",......)
и в ответ получаем что i=4
то мы теперь четко понимаем какой нахрен смысл имеет эта дебильная цифра?
эта цифра это номер записи или строки  в таблице FD открытых файлов в 
памяти ядра в той части где ядро хранит инфо о всей информации о этом 
процессе. открывая файл ядро заносит всякие унжные ему ядру данные
по этому файлу для того чтобы оно могло потом для нас с этим файлом раобтать.
и когда потом мы пишем
	read (4, .....)
то ядро понимает что мы просим его начать читать файл информация
о котором нужно ему ядру искать в FD таблице в строке 4 !!!!!! сука!!

это похоже вот на что.
банк   и у нас есть ячейка. мы сдали деньги. но в банк нас не пустили.
нам просто сказали что у нас теперь ячейка 148.
потом когда мы просим чтото сделать с нашим деньгами то мы гооворим 
банкиру пойди в ячейку 148 и вытащи 50р.
нам номер 148 нихуя не дает. это внутренняяя архитктура банка. 
но банкик ядро знает о чем речь. он идет и все делает. 

получается fd файл дескриптор это кусок информации о внутрнейей архитектуре
ядра. ядро нам сообщает свое внутреннее число. чтобы мы могли потом
ему это число сообщить. 



кстаи вот инфо из man 2 open
 A call to open() creates a new open file description, an entry in the system-wide table of open files.  The open file description records the  file
       offset  and the file status flags (see below).  A file descriptor is a reference to an open file description; this reference is unaffected if path‐
       name is subsequently removed or modified to refer to a different file.  For further details on open file descriptions, see NOTES.



раота с файлом через файл дескриптор


#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>


int main(void) {

  printf ("pid = %i\n", getpid() );
  char const * ptr_path = "/tmp/1.txt";
  int i = open(ptr_path, O_CREAT, O_RDONLY);
  printf ("i = %i\n", i );
  sleep(30);
  close(i);

 exit(0);

}


на экране:
$ ./174.exe 
pid = 12087
i = 3




$ ls -1al /proc/12087/fd/
...
lr-x------ 1 vasya vasya 64 мая  8 23:02 3 -> /tmp/1.txt


на этом про файл дескрипторы все!
казалось бы а почему я так заморочился. ну я знал что fd это 
какйото номер 0,1,2,3,4 казалось бы да хрен бы  с ним,
но оказалось что работать с файлами можно не только через файл 
дескприорторы! вот в чем звездец!


оказалось что разработчики языка си
они написали некую надстройку. свой юзерский код. и незнаю зачем
предложили работаь с файлами не через файл дескрипторы. а через свою хрень.
через так называемые streams!
и я вдруг непонял. подождите. надо вначале понять а что такое файл 
дескриптор как он работает чего он значит. иначе я нихрена не пойму
про streams. 
про стримс я написал отдельрый кусок "|streams"

кстати 
stdout это хрень имеет тип * FILE тоесть это стрим, а
STDOUT_FILENO это уже int и в нем закодирован номер файл дескриптора
который отвечает за стандартный вывод тоесть 1

таким образом stdout нужно использовать в функциях которые
работают со стримами такими как fputs() итп 

а

STDOUT_FILENO нужно использовать в фунциях где файл дескрипторы
юзатся такие как open() read() write()  и обозначает он fd/0

