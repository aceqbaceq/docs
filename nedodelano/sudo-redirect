| sudo
| redirect

есть такой известный случай
	$ sudo echo "123" > /etc/hosts
и мы видим на экране ошибку
	bash: /etc/hosts: Permission denied

в чем же прикол?

приходит вопрос - ведь echo запускается под рутом. как это ему 
нехватает прав?
НО секрет в том что echo тут ни причем. до него недоходит даже!
все дело в баше. и щас я все обясню!

возьмем даже для примера не echo а даже
самописную программу чтобы мы точно знали как оно работает

$ cat 181.c

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <stdlib.h>




int main(void) {


     printf( "123"     );
     sleep(90);

    return 0;
}



она просто печатает "123" на экране и потом процесс впадает в сон.
и вот я эту прогу вот так запускаю

$ ./181.exe  > /tmp/2.txt
bash: /tmp/2.txt: Permission denied

пока как видно запускаю без sudo. (потом и sudo добавим)

как отрабатывает команда что выше. есть баш процесс. он создает своего
чайлд баша. далее этот чайлд процесс прежде всего пытается открыть
файл 2.txt ! потому что чтобы с файлом работать его вначале нужно открыть!
причем с нужными флагами! и чтобы это свершилось нужно чтобы процессу
хватило файл пермишнс! так вот баш процесс пытается открыть файл с нуж
ными флагами. и нужно заметить что чайлд баш являясь клоном парента
имеет теже права чтоб и его родитель. тоесть права у процесса обычные!
поэтому вот он ключ к проблеме! если файл котоырй баш пытается открыть 
разрешает его редактировать только root то баш обломиться открыть файл!
ну вот , если 2.txt имеет обычные пермишнсы что обычный юзер
может его редактировать то стрейс чайлд баш процесса выглядит вот так

трейс в чайлд процессе баша:
[pid 19771] openat(AT_FDCWD, "/tmp/2.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 4
[pid 19771] dup2(4, 1)                  = 1
[pid 19771] close(4)                    = 0
[pid 19771] execve("./181.exe", ["./181.exe"], 0x55fdf2f06ce0 /* 72 vars */) = 0

тоесть чайлд баш УСПЕШНо открывает 2.txt и получает от ядра инфо что
fd этого проецесса равен 4
далее баш клонирует fd=4 в fd=1 ну понятно чтобы у  STDOUT смотрел в 2.txt
далее баш закрывает fd=4 он нам больше нахрне ненужен
и далее баш запускает через execve уже бинарник 181.exe 
(ксати получаеся интересный прикол который мы щас увидим в следущем 
прмере он сочтоит в том что если у процесса нет прав на чтение\запись в файл
то у процесса не получится даже "открыть" его поэтому ни о каком read()
write() и речи уже быть не может! до них просто не дойдет очередь!)

а вот трейс чайлда баша когда файл пермишнс на файл 2.txt таковы что его
редактировать (писать) может только root
[pid 19756] openat(AT_FDCWD, "/tmp/2.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666) = -1 EACCES (Permission denied)
[pid 19756] write(2, "bash: /tmp/2.txt: Permission den"..., 36) = 36
[pid 19756] exit_group(1)               = ?

тоесть баш себя клонировал в чайлда. чайлд работает под правами как упарента
тоесть под обычным юзером. 
баш пытается открыть файл 2.txt но у него не хватает прав. потому что 2.txt
в него может писать только рут. поэтому ядро шлет нахрен запрос openat()
с ошибкой EACCES (Permission denied)
баш эту ошибку ловит. и выводит в STDERR (fd=2) надпись 
	bash: /tmp/2.txt: Permission denied
которую мы и видим на экране!
что суественно тут понять что до запуска 181.exe при этом абсолютно не доходит!
это важно понять! так как до запуска 181.exe баш должен для этого бинарника 
подготовить почву. бащ должен открыть файл 2.txt потом его приконектить к 
STDOUT то если на этом этапе возникают проблемы то до запуска 181.exe просто
недоходит! а так как баш чайлд имеет теже права что и парент. а парент имеет
права простого юзера то если файл 2.txt непозволяет простому юзеру его
редактировать то баш обламывается его "открыть" через openat()! 
вот и весь секрет !

теперь мы вспоминаем что оригинальная команда содержала sudo.
может он чудо сделает ? ответ - не сделает!
если я запущу команду
	$ sudo 	./181.exe  > /tmp/2.txt
то как она сработает?

баш клонирует себя в чайлда. чайлд баш работает под обычным юзером.
чайлд баш пытается открыть 2.txt 
если у чайлд баша под обычным юзером нехватает прав откыть 2.txt 
то до запуска sudo (а это ведь обычный бинарник просто он стартует уже с правами
root) ПРОСТО НЕ ДОХОДИТ! поэтому нам абсолютно похрену что sudo при старте
имеет права root! до его запуска ПРОСТО НЕ ДОЙТЕТ! ХА-ХА-ХА! вот и весь 
секрет!

вот и все!

докучи напомню как работает sudo.
он стартует. под правами root.
далее он себя клонирует. и уже в клоне запускает через execve 181.exe
если же мы запускаем sudo с редиректом то вся цепочка (если она успешная)
работает так.
у нас есть баш с обычными правами процесс. он себя клонирует в чайлд баш.
чайлд баш открывает файл 2.txt потом он клонирует десприптор этого файла в fd/1
потом он закрывает дескприптор под которым изначально ядро открыло 2.txt
потом баш через execve запускает sudo. sudo стартует и меняет права прцоесса
на root. при этом этот процесс уже через stdout смотит на 2.txt
далее sudo клониурет себя. и его чайлд sudo тоже наследует fd/N 
далее этот чайлд sudo через execve запускает 181.exe 
вот такая схема. 
и ящас  я ее покажу картинкой

$ pstree -AspT  22872
...---bash(19263)---sudo(22872)---181.exe(22873)
        /\             
        ||             
     обычный юзер      

$ sudo ls -1al /proc/22872/fd
lrwx------ 1 root root 64 мая 11 05:50 0 -> /dev/pts/159
l-wx------ 1 root root 64 мая 11 05:51 1 -> /tmp/3.txt
lrwx------ 1 root root 64 мая 11 05:51 2 -> /dev/pts/159

$ sudo ls -1al /proc/22873/fd
lrwx------ 1 root root 64 мая 11 05:50 0 -> /dev/pts/159
l-wx------ 1 root root 64 мая 11 05:50 1 -> /tmp/3.txt
lrwx------ 1 root root 64 мая 11 05:50 2 -> /dev/pts/159



получается чтобы redirect ">" или ">>" отработал успешно на файл
который может редактировать только root то надо чтобы bash
в котором мы этот редирект запускаем был запущен под рутом. так 
как дело в том что значок редиректа это же функционал баша. это 
он его транслирует в "открыть файл , и приконектиить его fd на STDOUT".
например

$ sudo bash -c "./181.exe > /tmp/1.txt"

тоесть унас текущий баш себя клонирует. в чайлде
баш запускает execve sudo. тот  повышает права чайлд процесса до рута.
далее судо запускает своего чайлда тот чайлд запускает  execve bash который
уже работает под рутом. тот бащ создает своего чайлд баша который
тоже рабтает под рутом. тот чайлд баш успешно открывает файл 1.txt потому
что у него есть права рута. и потом он запускает execve 181.exe
показываю на картинке

$ pstree -AspT $(pidof 181.exe)
...---bash(22876)---sudo(23001)---bash(23002)---181.exe(23003)
                                     | 
                                     |
                                     |
                                 вот эта
                                 команда 
                                 bash
                                 она под root

так как bash(23002) стартанут под рутом это дает то что
баш(23002) стартует тоже под рутом поэтому этот баш успешно может
открыть файл 2.txt и присобачить его к STDOUT ( ну и потом успешно сдохнуть
через execve)
а на верхней картинке я щас ее повторю


$ pstree -AspT  22872
...---bash(19263)---sudo(22872)---181.exe(22873)
        /\             
        ||             
     обычный юзер      


процесс 19263 баша работает под обычным юзером потому его чайлд баш (22872)
не сможет открыть 2.txt ибо не хватит мощности и поэтому до запуска execve sudo
просто недойдет. на картинке показан успешный случай когда 2.txt 
имел файл пермишнс которые позволяли простому юзеру редактировать файл

еще хочу обратить внимание на этот случай
	$ sudo 	./181.exe  > /tmp/2.txt
дело в том что для баша в кооторомы вбиваем эту команду
она не выглядит как казалось бы
	$ sudo 	"./181.exe  > /tmp/2.txt"
кавычки поставил для наглядности
а она выглядит вот так
	$ "sudo  ./181.exe"  > /tmp/2.txt
то есть для баш это выглядит как
	$ sudo arg1     > /tmp/2.txt
тоесть для баш это выглядит так что нужно вначале открыть 2.txt 
присобачить его к STDOUT а потом уже запустить sudo с некоторым аргументом arg1
я это пояснил потому что интутивно кажется что команда
	$ sudo 	./181.exe  > /tmp/2.txt
якобы выглядит так
	$ sudo 	arg1
что якобы баш нужно запустить sudo с аргументом arg1
далее когда запущен уже sudo то
он якобы отрывает 2.txt , присобачиывает его к STDOUT и потом запускает 181.exe
ЭТО НЕТАК!
строка
		$ sudo  ./181.exe  > /tmp/2.txt
полностью аналогична строке
		$ cat ./1.txt  > /tmp/2.txt
совершенно понятно что cat читает 1.txt и выводит его в stdout к котрому
прилеплен 2.txt
тоесть баш вначале прилепляет к stdout 2.txt а уже потом запускает процесс
cat с аргументом ./1.txt


а теперь вот что 
рассмотрим команду

$ sudo cat /1.txt

здесь уже сам баш перед запуском sudo он не открывает файл /1.txt нет.
файл 1.txt открывает сама программа cat
тоесть

баш клониует себя. в чайлде он запускает sudo. 
sudo клонирует себя и в чайлде запускает cat
ну а уже сам cat открывает файл 1.txt
это означает что проблем которые описаны выще у нас уже не будет.
используя это можно теперь писать в файл в который может писать root
не через команду
        $ sudo bash -c "echo 123 > /tmp/2.txt"
а через команду
        $  echo "11" | sudo tee  /tmp/2.txt
либо через 
        $  echo "11" | sudo tee  -a /tmp/2.txt


если tee запускается без ключа -a то он пеертирает содержимое файла до нуля
а если с ключом -a то онделает "append"


ВОТ!

