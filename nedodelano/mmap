| mmap
| malloc
| brk

начну с mmap
обычно это команда нужна чтобы можно было файл спроецировать в память. чтобы
ездия туда сюда по памяти мы ездили внутри файла. в чем фишка
вместо read() write() незнаю. 
в мане привоится пример 

...
  fd = open(argv[1], O_RDONLY);
...
addr = mmap(NULL, length + offset - pa_offset, PROT_READ,
                       MAP_PRIVATE, fd, pa_offset);
...
 s = write(STDOUT_FILENO, addr + offset - pa_offset, length);


тоесть отрывается файл. получаем fd для него.
потом этот fd подсовываем в mmap. теперь обращаясь по адресу addr
и так далее мы ездиим не по памяти а внутри файла.
далее мы печатаем на stdout то что лежит по адресу addr длинной length.
все же не очень понимаю как особый прок от mmap по сравнению с read()
или write()
инутититивно есть тольк оощущение что когда у нас файл замаплен в память
и мы уже можем раобтать с файлом на диске просто как с куском памяти.
то наверное скажем искать в таком куске памяти удобнее чем если чтото
искать в файле читая его по кускам анализируя и потом опять читая
какойто кусок. 
ладно. пока нпонятно. двигаем дальше

так вот при запуске

$ cat /tmp/1.txt

в ее трейсе я увидел такую команду


mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f9c2c9b4000

я заинтереосвалася нахрен cat нужен mmap. 

и вылез  интересный флаг 
MAP_ANONYMOUS

он говорит о том что на самом деле кусок памяти 139264 байта который
запрашивается он не будет вести ни на какой файл! о чем также
дальге свидествутуает число -1 это типа номер файл дескриптора
который игнориуется если мы такой флаг юзаем. 


 MAP_ANONYMOUS
              The  mapping  is  not  backed  by any file; its contents are initialized to zero.  The fd argument is ignored; however, some implementations
              require fd to be -1 if MAP_ANONYMOUS (or MAP_ANON) is specified, and portable applications should ensure this.  The offset  argument  should
              be zero.  The use of MAP_ANONYMOUS in conjunction with MAP_SHARED is supported on Linux only since kernel 2.4.

получается такое испльзование mmap приводит к тому что ядро
берет кусок вирт памяти процесса. весь его зануляет. (тоесть у нас не будет
ошиьбки segmentaion fault при обращении внутрт этого куска)
и возврашает нам адрес начала этого куска. фишка также в том что этот 
кусок от иницаилизируется не в области стека и не в области статической
памяти процесса а в области heap. тоест если нашему процессу нужен кусок
инициализированой непрерывной памяти где то в heap то можно заюзать
mmap например чобы потом туда какйото массив начать писать. вобщем неочень
понятно нахрен это нужно команде cat но  вцелом прикольно было об этом узнать


работа команды cat выгоялдит так

openat(AT_FDCWD, "./kubernetes.txt", O_RDONLY) = 3
fstat(3, , ...}) = 0
fadvise64(3, 0, 0, POSIX_FADV_SEQUENTIAL) = 0
mmap(NULL, 139264, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f3161e1a000
read(3, "...."..., 131072) = 131072
write(1, ..."..., 131072) = 131072
...
...
read(3,)
write(1,)
read(3,)
write(1,)
munmap(0x7f3161e1a000, 139264)          = 0

тоесть открыается файл который нужно читаать.
счтываеются его параетры свойства.
делается указание ядру что мы будем щас читат секвенциально
в памяти heap у ядра закаызается кусок памяти инициализованной размер 139264 байта
потом идет куча read() write() когда cat читает из файла на диске
и пишет в stdout то что он прочитал.
и когда файл считан то запускется unmap чтобы вернуть память ядру
нахрен был нужен этот mmap munmap хрен знает


далее malloc 
это не системный вызов это си функция. поэтому в strace мы никакого
malloc не увидим. также это можно поняь если вызвать 
	$ man malloc
и будеь написано
MALLOC(3) 
вот эта тройка (так называемая третья секция) означает что это не сист вызов.
практика поазывает что malloc использует при своем запуске brk() и mmap()
их мы увидим в strace


[vasya@lenovo 4930]$ 
[vasya@lenovo 4930]$ cat /proc/$(pidof 183.exe)/maps
556cf4b17000-556cf4b18000   /home/vasya/git/docs/C/183.exe
556cf4d17000-556cf4d18000   /home/vasya/git/docs/C/183.exe
556cf4d18000-556cf4d19000   /home/vasya/git/docs/C/183.exe <== это mmap с файлом
556cf522c000-556cf524d000   [heap] <=== это brk
7fea897c9000-7fea899b0000    /lib/x86_64-linux-gnu/libc-2.27.so
7fea899b0000-7fea89bb0000    /lib/x86_64-linux-gnu/libc-2.27.so
7fea89bb0000-7fea89bb4000    /lib/x86_64-linux-gnu/libc-2.27.so
7fea89bb4000-7fea89bb6000    /lib/x86_64-linux-gnu/libc-2.27.so
7fea89bb6000-7fea89bba000  
7fea89bba000-7fea89be3000    /lib/x86_64-linux-gnu/ld-2.27.so
7fea89caf000-7fea89db2000 
7fea89de3000-7fea89de4000    /lib/x86_64-linux-gnu/ld-2.27.so
7fea89de4000-7fea89de5000    /lib/x86_64-linux-gnu/ld-2.27.so <== это mmap с файлом
7fea89de5000-7fea89de6000      <==== это mmap без файла
7fffa3aa2000-7fffa3ac3000    [stack]
7fffa3b9e000-7fffa3ba1000    [vvar]
7fffa3ba1000-7fffa3ba2000    [vdso]
ffffffffff600000-ffffffffff601000 [vsyscall]
 
каждая сеция имеет флаг "r-xp"
55eb7f979000-55eb7fa7d000 r-xp 00000000 103:02 25690119   /bin/bash
он покзыат что с этой сецией можно делать. 
эту скцию можно чиать и выполнят ее код. тоесть это тот кусок 
фала баша где лежит код. "p" означет я думаю protected?


посчитаь размер стека  <==================
посмратитать размер каждого сегмента 183.exe <==================
подмапить файл посмотеть что он повиятся тоже в списке  <==================
после тго как я выделил памят через malloc (тоесть brk или mmap) <==================
   попроать там поприсваивать значения ячейкам произволльным.  <==================
   даст ли ядро или будет segmnation fault ? <==================
vvar ? <==================
vdso ? <==================
vsysvall ? <==================


