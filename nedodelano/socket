| socket
| pipe

как сокет работает.
что это такое.

хотя в статье также я нехило пайп рассматриваю тоже.

сокет это такая ядерная структура через которую 
два процесса могуо другс другом обениваться данными. тоеть
это элемент IPC.

вобще все элементы работы прцоесса почти они все лежаь в ядре. 
а процесс все время просит ядро с этими обьектами 
лежашими в ядре  чтото сделать. тоест 
это как иметь деньги в банке на счете. у вас к ним досутпа нет.
вы лишь можее попросить банк служащего чтото сделать с ними. 
и он делает это а вам дает лишь справку. тоже самое с прцоессом
и ядерными структурами. например процесс открыл файл. но нет. на самомд
деле это ядро открыло файл. а у вас есть лишь справка на руках
о том что он открыт. это (файл дескриптор). точнее это не справка
это якорь в памяти ядра об этом открытом файле. (смотри "| file descriptor")
а если и мы хотм чтото считать из файла. то читает 
не сам процесс а читает ядро. а нам ядро через окошко (сисколл) выдает то что 
ядро прочитало из файла. а точне даже так. ядро само записывает в некоторую
ячейку памяти памяти процесса то что ядро считало из файла. 
но даже когда данные уже лежат в памяти процесса сам процесс вобщемто
нихуя неможет с ними ничего сделать. почти ничего.
например сам процесс может сложить две переменные. для этого 
наконец то ядро об этом просить ненадо

	int a = 10;
	int b = 20;
	int c = a + b;

но чтобы напечатать "c" нужно опят же просить ядро. 
забавно.


перед сокетами поговорим про пайпы.
как это работает. мы просим ядро  - создай нам пайп.
ядро как я понимаю создает буфер в ядерной памяти 
далее ядро создает два файл дескриптора тоесть якобы ядро открыло
два файла и вот один файл дескриптор указывает на один файл
а второй указывает на второй открытый файл. хотя по факту
они оба указывают на один файл. только это не файл а буфер в ядерной
памяти. и получается что один fd позвоялет толко читать из этого
файла буфера а второй fd позволяет только писать в этот файл 
буфер. вот и весь пайп по своей сути. при вызове функции пайпа
мы через аргументы передаем две int переменные только не в виде
двух разных переменных а в виде int массива на 2 элемента
		int f[2];
и ядро возвращает в этих двух элементах два номера двух 
файл дескрпиторов
		f = pipe();
f[0] позвволяет толтко читать а fd[1] позволяет тольо писать.
процесс может вначале записать в fd[1] а потом прочитать из fd[0]
обычно мы создаем чайлда. у чайлда закрываем fd[1] а у мастера
закрываем fd[0]. и тогда мастер пишет в fd[1] а чайлд читает из fd[0]
и вот у нас интепроцесс коммуникейшн через буфер-файл в ядерной памяти.


щас покажу код


#include <stdio.h>
#include <stdbool.h>
#include <signal.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <string.h>


static void handler(int sig) {    struct sigaction act = { 	.sa_handler = SIG_DFL, 	.sa_flags = 0,     };
    sigaction(sig, &act, NULL);
    printf("Got signal %d\n", sig);
    kill(getpid(), sig);
}



int main(int argc, char **argv) {
    int pipefd[2];
    bool ignore = argc > 1 && argv[1][0] != '0';


    struct sigaction oldact, act = { 	.sa_handler = ignore ? SIG_IGN : handler, 	.sa_flags = 0,     };
    sigaction(SIGPIPE, &act, &oldact);



    pipe(pipefd);
    //close(pipefd[0]); // reader


    char ch3[1024];
    memset(ch3, '0', sizeof(ch3));


    for (int t=0; t<100; t++)
    {
    if (write(pipefd[1], ch3, sizeof(ch3)) < 0)
    {
	perror("write()");
	printf ("Error no is : %d\n", errno);
        printf("Error description is : %s\n",strerror(errno));
    }
    printf ("t = %i\n", t);
    }




    char ptr_buf[100];
    memset(ptr_buf, 0x00, sizeof(ptr_buf));



    if (read(pipefd[0], ptr_buf, 10) == -1)
    {
	perror("read()");
	printf ("Error no is : %d\n", errno);
        printf("Error description is : %s\n",strerror(errno));
    }


    char const * ptr_buf2 = ptr_buf;
    fputs(ptr_buf2, stdout);
    fputc(0x0a,stdout);


    sigaction(SIGPIPE, &oldact, NULL);



    return 0;
}






я хотел прокоментировать строчку
    if (read(pipefd[0], ptr_buf, 10) == 0)
она говорит чтобы ядро прочитало из файла 10 байтов.
но если файл меньше размером то прочитать сколько есть. 


тут мне пришло в голову а какой размер пайпа в буфере ядра прописан?
я нашел вот такое
$ ulimit -a
pipe size            (512 bytes, -p) 8

тоесть 512*8 = 4KB получается
ксати можно про пайп почитать через 
	$ man 7 pipe

моя програма она записывает по 1KB в пайп и пишет 
об этом  в форме t=1
максимум я пытаюсь засунуть в пайп 100KB
а читать я в этот момент не читаю. так вот там буфер 
в памяти получается забивается. и практика показала
что 63 или 64KB ядро принимает.
потому что на экране запись закнанчиватеся на 
t=63
и потом программа висить тоеть процесс входит в сон. 
потому что буфер забит и ядро проецсс сует в сон раз запрос 
write() не может выполниться.
и в свойствах процесса wchan он 
пишет что pipe_wait. из чего я делаю вывод
что почемуто предел пайпа по дефолту 64KB. 
но откуда она берется? я пока не понял 
соотвсвтенно если я начинаю читать из пайпа то запист успешно
продолжается и в итоге все 100KB проходят через пайп.
вопрос - где регулируется что размер пайп буфера в памяти ядра 64 KB? 
ага ! Я НАШЕЛ!==> в man 7 pipe написано что 
по дефолту это 16 СТРАНИЦ ПАМЯТИ. А РАЗМЕР СТРАНИЦЫ У МЕНЯ 4КБ ,
ЗНАЧИТ РАЗМЕР ПАЙПА ПО ДЕФОЛТУ 64КБ! СОВПАЛО!

размер страницы можно посмотреьть 
как 
	$ getconf -a | grep -i page
PAGESIZE                           4096
PAGE_SIZE                          4096


$ ulimit -a
pipe size            (512 bytes, -p) 8

а вот эта штука она оброзначает не размер пайпа а то какими 
атоарными порциями ядро должно записывать в буфер пайпа данные
принимая от процесса эти данные. тоесть что либо 4К либо ничего? (<===
проверить!)


с пайпом в целом картина начинает вырисовываться. 
есть два процесса. в одном указан write() и в нем указано сколько желательно
байт записать в файл. например 1024 байта. если ядро понимает 
что по каким то приинам оно не может записать все 1024 байта
то оно кладет процесс в сон. до тех пор пока ядро поймет
что оно может записать все 1024 байта. (<==== верно?)
в итоге процесс либо запиывает все 1024 байта либо нихрена и тогда он спит.
будет спатьдо тех пор пока ядро не сможет выполнить заказ.
кода процесс запиешет то есть его write() отоаботает то процесс
просто проддолжит работу дальше. также есть процесс с read() у него
указано сколько байт желательно прочитать напримре 2048 байт.
если ядро понимает что 2048 байт сейчас в буфере ядра нет то яддро
пооложит этот процесс спать. положим првый прцоесс записал 1024 байта.
у нас в буере ядра 1024 байта а этот процесс просит считать 2048 байт.
что будет делать ядро? как я погимаю оно положит читающий поцесс в
сон до тех пор пока в буфере неоказется 2048 байт! тоесть навечно
если првй проецесс бльше несобирается ничего писать (<===== проверить!)
также по попводу желатено прочитать 2048 байт. если ядро понимает
что достинут "конец файла" буфера  а читающий процесс заказал 128КБ
данных на чтение то как я понимаю ядро понимает что размер файла 64КБ
и выдаст из буфера все что есть не кладя его в слип. (<=== так?)
непоняно когда ядро принимет ершение что достигнут "конце" файла и некладет
процесс читаюий в слип!
и еще на счет SIGPIPE
вот есть связка команд
	 $ cat kubernetes.txt | head -c 1
я их пранализурую стрейcосом
	 $ strace -f cat kubernetes.txt | head -c 1
и видно что в процесс cat прилетает сигнал SIGPIPE

...
openat(AT_FDCWD, "/home/vasya/git/docs/kubernetes.txt", O_RDONLY) = 3
...
read(3, "0\220 KUBERNETES\r"..., 131072) = 131072
...
--- SIGPIPE {si_signo=SIGPIPE, si_code=SI_USER, si_pid=22992, si_uid=1000} ---
+++ killed by SIGPIPE +++

также видно что файл открывается в дескрпиор 3. и то что 
cat заказывает чтение кусками размером по 131072 байта.
тут кстати вопрос - что будеьделать ядро. оно обеспечит read 
именно 128КБ данных както .или оноп оложить процесс спть?
практика покзывает что ядро дает 64Кб для cat! (<==== разобраться)
и cat посылает это в head. тот считывает первый 1 байт. выводит
на экран и выходит ! но cat то продолжает работаь! ему надо дочитаьт
весь файл до конца! и тут получается прикол. со стороны cat открыт
файл ведущий в пайп буфер! а со стороны head уже ничего не откртыто
ибо этого прцоесс нет! и тодга при ппоытке записать cat новую порцию
в буфер ядра пайпа посылается сигнал в cat SIGPIPE означащий что
писатьв пайп бесподезно так как никто читать потом не будет! вот
пррода возниканеонеия SIGPIPE! единсвтенное что я ее не пойму
это почему сигнал посылает не ядро а процесс!?!!?!?  si_code=SI_USER, si_pid=22992
что за хрень!?!??! (<==== разюраться!)


$ strace -f -e file,read  /bin/cat ~/git/docs/kubernetes.txt 2>&1 | grep  -E openat(AT_FDCWD, "/home/vasya/git/docs/kubernetes.txt", O_RDONLY) = 3
read(3, "\r\n\320\243\320\241\320\242\320\220\320\235\320\236\320\222\320\232\320\220 KUBERNETES\r"..., 131072) = 131072

еще один стрейм показыаютщий что cat читаем данные кусками по 128КБ!
вот эта билиберда 
"\r\n\320\243\320\241\320\242\320\220\320\235\320\236\320\222\320\232\320\220 KUBERNETES\r"
в read(
это показано содержимое того что было прочитано read из файла!


<========== непонятно в read() write() фраза про размер. читат писать 
влоть до?!?!?!!?










