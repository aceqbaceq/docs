bash 
local variable (shell variable) vs global variable (environment variable)

значит есть переменные которые видны в рамках текущего процесса bash они называются
local variables\shell variables:
Local variables are only available in the current shell.

есть переменные global variable\environment variable они передаются дочернуму процессу 
который запускает текущий процесс баша. тоесть еще раз они видны и нашему башу и дочернему 
процессу. они туда передаются копируются. и далее естественно если мы меняем глобальную
перменную в парент процессе то это никак не влияет на дочерний процесс и если дочерний
процесс меняет переменную то она меняется только в дочернем но не меняется в парент процессе.

щас с примерами разберем.

посмотреть локальные переменные можно через 

$ set

правда она покажет и локальные и глобальные

глобальные можно псмотреть через
$ printenv
или 
$ env

 ябы сказал что все переменные которые неглобальные они локальные. 
 тоесть в дочерний процесс будут переданы только глоабальные перменные.

 как посмотреть узнали. двигаем дальше.

разбираемся как это глобальные перменные передаются в дочерний процесс.
варианты либо через env либо через export либо через субшелл(об этом отдельно щас скажем)



(шелл1)$ vasya=5
(шелл1)$ /bin/echo $vasya
5
(шелл1)$ bash
(шелл2)$ /bin/echo $vasya

видно что так как vasya локальная переменная ( от обратного что она неглобальная) то дочерний
баш невидит этой переменной.

теперь сделаем ее глобальной через export:

(шелл1)$ vasya=5
(шелл1)$ export vasya;
(шелл1)$ bash
(шелл2)$ /bin/echo $vasya
5

видна в дочернем процессе!

сделаем переменную глобальной через env:
$ echo $$
6798
$ echo $kk2

$ env kk2="!" /bin/bash 
$ echo $$
6982
$ /bin/echo $kk2
!
$ set | grep kk2
kk2='!'
$ printenv  | grep kk2
kk2=!
$ bash
$ echo $$
7009
$ echo $kk2
!

 теперь про субшелл.
 $ (...)

 вот так форкается парент при запуске команды $ bash
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f1fc8b5e490) = 7212

вот так форкается парент при запуске субшелла $ ( echo 1)
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f1fc8b5e490) = 7254 

из чего я делаю вывод что с точки зрения вызова сисколла clone() что запуск $ bash
что запуск $ () это одно и тоже.


насколко я понял флаги в clone подставляются через знак пайпа
видимо из за того что флаги это биты в каком то байте через который переадаются флаги
 pids[i] = clone(childFunc, stackTop,
                    CLONE_CHILD_CLEARTID | CLONE_CHILD_SETTID | SIGCHLD, NULL);



значение параметров:
child_stack=NULL    = это насколько я понял значит то что чайлд получает копию стека парента
SIGCHLD = это насколько понял означает что когда чайлд сдох от паренту слать именно этот сигнал.

		- эти флаги непонятны
CLONE_CHILD_CLEARTID = ?
CLONE_CHILD_SETTID = ?
надо сделать минимальный С прогиамму с примером clone() и посмтреть что strace покажет
мне кажется это некие стандартные флаги по дефолту.
я создал программу на С которая делает pid = fork();

$ ./22.exe

это вот как баш себя форкает при запуске моего бинарника:
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f1fc8b5e490) = 9925

это уже мой бинарник форкает себя:
clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f61ad684e50) = 9926

видно что флаги clone у баша и у меня одинаковые. так что ... читаем дальше.
я прочитал man fork и вижу что этот libc wrapper при вызове его как pid = fork() то 
он вобщем то неделает ничего особого, память у чайлда будет точно такая же как у парента.


это форкнутый баш запускает внутри себя мой бинарник:
execve("./22.exe", ["./22.exe"], ["CLUTTER_IM_MODULE=xim",..., "_=./22.exe", "OLDPWD=/home/vasya/Asm"]) = 0

это синтаксис из man execve:
int execve(const char *filename, char *const argv[],
                  char *const envp[]);

а вот я запустил 22.exe с параметрами

$ ./22.exe 01 02 03 04 05

и получил execve

execve("./22.exe", ["./22.exe", "01", "02", "03", "04", "05"], 

видно что 
const char *filename = "./22.exe" ; ссылка на стринг в котором путь к бинарнику

char *const argv[]   = ["./22.exe", "01", "02", "03", "04", "05"] ; ссылка на массив параметров которые нужно будет передать бинарнику

char *const envp[]  = ["CLUTTER_IM_MODULE=xim",..., "_=./22.exe",...]
 envp is an array of strings, conventionally of the form key=value, which are passed as environment to the new program.   The  argv  and  envp  arrays  must  each
       include a null pointer at the end of the array

а вот вроде нашел ответ на вопрос - как же программа которую запускают может 
всосать в себя эти параметры с которыми ее запускают ? 
The argument vector and environment can be accessed by the called program's main function, when it is defined as:

           int main(int argc, char *argv[], char *envp[])

    - фунадметанлаьльный вопрос , центральная проблема написано что программа которую запускают может в себя принять переменные окружения если в ее main функии прописан char *envp[]
    int main(int argc, char *argv[], char *envp[])
    ну тогда примерно понятно как программу которую запускают черех execve получаеь переенные окружения. 
    но далее написано что в posix такого не предустмотрено поэтому лучше так неделать в вызываемой прошрамме а вместо этого   использвать environ. и это я немогу понять.

пока что полагаю вот что - мы вызываем сисколл 
execve("./22.exe", ["./22.exe"], ["CLUTTER_IM_MODULE=xim",..., "_=./22.exe", "OLDPWD=/home/vasya/Asm"]) = 0

для сисколла мы полгтоваливаем ряд переменных.
вызвали сисколл. процесс остановился а ядро заработало.
сисколл создает новый процесс то есть в памяти он для него выделяет вирт пространство
и как я понимаю он туда видимо в стек процесса сует вот эти вот данные
"./22.exe"
["./22.exe"]
["CLUTTER_IM_MODULE=xim",..., "_=./22.exe", "OLDPWD=/home/vasya/Asm"]

мехагнизм такой же как при вызове функции из тела в рамках одного процесса.
когда мы ее выызаем то в простом случае у новой функции в стеке будет кучка
переменных.

и еси мы рассмотрим нашу в новом процессе прогармму ее фукцнию main
int main(int argc, char *argv[], char *envp[])

то получаетя в ее стеке она ожидает увидеть три переменные
argc
argv
envp

так что я думаю ядерный код сисколла он качает данные перменные окружения которые ему передали
чрез третий параметр
execve("./22.exe", ["./22.exe"], ["CLUTTER_IM_MODULE=xim",..., "_=./22.exe", "OLDPWD=/home/vasya/Asm"]) = 0

и сует их в стек в новом процессе.
таким образом при старте main  в новом процессе  у нее вс теке.

а что если наша ызваемая main функция ового процесса несождержит третий паараметр 
и наш exec ve тоженесодрежит третий параетре



execve("./22.exe", ["./22.exe"])

int main(int argc, char *argv[])

это значит что этот механизм уже неработает.

и туту вступает в строй волшебная переенная

extern char **environ

$ cat 58.c
#include <stdio.h>
#include <stdlib.h>
  
extern char **environ;
 
int main(void)

я ночень понимаю но  я так понимаю что execve автоматом создать в новом процессе environ
и накачает туда данные об переменных оркружения автомтом.

 я нашел вменяемое оьяснение в man 3 environ у freebsd

 The exec family of functions shall replace the current process image with a new process image. The new image shall be constructed from a regular, executable file called the new process image file. There shall be no return from a successful exec, because the calling process image is overlaid by the new process image.

When a C-language program is executed as a result of this call, it shall be entered as a C-language function call as follows:

int main (int argc, char *argv[]);
where argc is the argument count and argv is an array of character pointers to the arguments themselves. In addition, the following variable:

extern char **environ;

is initialized as a pointer to an array of character pointers to the environment strings. The argv and environ arrays are each terminated by a null pointer. The null pointer terminating the argv array is not counted in argc. 

твак что ясчитаю что exec аавтоматом внутри новго процесса создает эту переменную.
и наполняет ее перменнцыми окружения. чтобы нам ее заюзать  надо вначале взываемой программы
име просто ее обьявление
#include <stdio.h>
#include <stdlib.h>
  
extern char **environ;

и тогда сисколл он туда запишет поинтер на массив.
вот у меня в моей проге этой видна как мне кажется обьявленная эта переменная
$ readelf -s  ./58.exe | grep -i environ
     8: 0000000000201010     8 OBJECT  WEAK   DEFAULT   24 _environ@GLIBC_2.2.5 (2)
     9: 0000000000201010     8 OBJECT  WEAK   DEFAULT   24 environ@GLIBC_2.2.5 (2)
    10: 0000000000201010     8 OBJECT  GLOBAL DEFAULT   24 __environ@GLIBC_2.2.5 (2)
    53: 0000000000201010     8 OBJECT  WEAK   DEFAULT   24 environ@@GLIBC_2.2.5
    61: 0000000000201010     8 OBJECT  GLOBAL DEFAULT   24 __environ@@GLIBC_2.2.5

    надо будет понять на какую секцию в памяти (text bss итп) указывает поинтер environ.
    тоесть куда сисколл пишет все эти перменные окрухежения когда он создает процесс.

    



	- надо понять про execve он стирает всю память от прошлой программы?
	- разобрать субшелл то что через него все лолкальные передаются
	- разобрать разницу в clone() при запуске субшелл и запуске bash
	 я думаю именно во флагах разница которая приводит к тому что субшелл видит все
	 переменные что были в родителе а bash ничего невидит.
	- как так /bin/echo внешнаяя программа умеет искать переменные баша в памяти?
	- вот мы сделали export vasya=5. как в дочернем процессе псмотреть эту переменную 
	не через /bin/echo ?
	- посмотреть через strace как передается множество переменных дочернему процессу.
	- man fork, man clone. проработать плотно все тамошнюю инфо.
	- что то я непойму как работает вот это => extern char **environ;
	- system() в C - разобраться man system

====



- непонятно на диске есть блок и на фс есть блок. ОС ядро работает с каким ?
вообще тема мутная. во первых как я понимаю есть скажем диск.  линуксе есть так называемый блочный драйвер к этому диску. он дает то что другие части ядра и также юзер из юзерспейса могут работаь с этим диском как с набором блоков от 0 до 1000000. тоесть и ядро и юзер(через /dev/sda) могут писать на диск в блок Х и читать с диска блок Х. Это дает блочный драйвер 
от этого диска. Файлоовй соситемы пока что нет и в помине. далее появлыется утилита юзерская mkfs.ext4 /dev/sda эта утилита из юзерспейса обращается к диску в блочном режиме
тоесть она пишет в сектор 1 такой то байт. а  в сектор 5 такой то байт. и все это из юзерспейса. тоесть она в блочном режиме чтото там насоывает на сектора на диске.
далее мы монтируем этот диск через драйвер уже файловой системы. драйвер кода ему подсунули диск то он обращается к этому дику через блочный драйвер в режиме ядра и начиает читать 
опреелееленные сектора ожидая там увидеть некую инфо и он там ее видит. таким обоаохом драйвер понимает что диск размечен. значит на нижгнем уровне драйвер фс по прежнему работает
с диском в блочном режиме через блочный драйвер а на более верхний уровень он уже 
отдает ядру некотоырй более выскооуровневый API. тоесть поялеяется ткое понятие как путь. как папки. как файлы. как отырыть файл. этот функционал драфер фс предостсвляет друим частям ядра. так я это понимаю. при этом такое понятие как фс блок это сугубо внутренняя виртуалная кухня драйвера фс которая сидит исключетльно в его голове. потому что на нижне уровне 
все поп режнему . там сплоные сектора диска. на верхнем уровне там такие понятия как открыть айл. у файла такойто путь. открыт каталог. у него такой то путь. там тоже нет никаких секторов. приколно что в /dev/devices указано только два типа устройсв это блочные и charatcer devris. никаких фс там нет. таким образом в /dev/ устройств которые прекдстаовляют
ФС API таких нет. к дискам разделам только блочный доступ. я бы сказал что фС API представляется драйвером фс ядру его VFS. а уже к ее API мы получе доступ через сисколлы и libc.  поэтому я вижу это так

[блочнй дравер диска(либо md\lvm\raid) - драйвер фс - VFS ] - (syscall\libc)
                        тоесть
[                          ядро                           ] - (юзер спейс) 
таким образом драйвер фс он не для юзерсейса. он позволяет связать одни хрени 
в ядре с другими хренями в ядре.

еще есть некоторые утилиты в юзреспейсе которые позволяют оарщатся к ФС сточки зрения 
ее понятий. непример ее блоков. 


- ext4 wiki



- линукс создать файл с юникод именем
решение:
$ touch  $'\u2234\u2192\u263f\u2605'.txt
$ ls -1 | grep  $'\u2234\u2192\u263f\u2605'
∴→☿★.txt
круто. только непонятно как это работает
и отсюда кстати еще вытекает такой момент - что файловая система ей пофиг какое имя 
имеет файл. она с кодировками неработает. для фс имя файла это просто набор байтов.
имя файла это ропсто набор байтов в блоках иноды которая за папку отвечает. типа
интерпретация байтов зависит от наверное конечного приложения юзерского?
единсвтенное что NUL-terminated, '/'-delimited sequence of bytes" запрещены.
но вопрос. если фс понятия неимеет о наешей кодировке то где может быть проблмеа тогда 
возникнуттьь ?

- статья https://habr.com/ru/post/462849/
- про иноды атрибуты.
- blockdev --getpbsz /dev/sdb
- разница между hdd блоком и ext4 блоком 
- archivemount
- find / -xdev -printf '%h\n' | sort | uniq -c | sort -k 1 -n
- xargs. 
тут дело в том что скажем команда rm tmp* прежде чем вызвать rm баш найдет все
файлы tmp* составит их список и будет вызывать rm подсоывася ей кучу названий файлов
в виде кучи переменных. так вот прикол в том что этот список он ограничен. так что 
более умно делаь чеерз xargs. тоесть есть огарничение на количество парамтров передаываемых
в execve. 
- что такое hashtree. линукс назначает ее папке автоматом если надо
- каков размер блока на ext fs ?


- что такое файловый дескриптор  и файловая таблица и vnode таблица 
- apue process relationship 9.1

- (если на этот вопрос ответил наверху то стереть) как работает ssh клиент между нашим хостом и сервером = на нашем компе запускается процесс ssh он имеет сеетвой сокет. из него он читает и переводит на экран. в в него он пишет с кнопок.
на удаленном компе запускется sshd процесс. он запускает bash там. что  я не пойму то что у того баш процесса все открытые файлы это /dev/pts/0. хорошо. на нашем компе ssh шлет в сетевой
сокет. там sshd процесс читает из сокета и шлет на /dev/pts/0 таки макаром тот баш получает 
наши кнопки. а вот надо понять как вывод баша в /dev/pts/0 ловится на той стороне sshd. каким макаром он /dev/pts/0 сканирует.
     что за ptmx?
     информация о сокете сетевом куда ведет на какой ip:port?



- остается два вопроса. каким макаром так нестроено что если кидать данные в /dev/pts/1 то они автоматом переслыаеются ядром в /dev/ptmx
второй вопрос. если я на компе открою баш в граф оболочке то у этого баш тоже будут 
на бекенде открыты файлы вида /dev/pts/X так вот вопрос каким макаром то что вылетает 
из /dev/pts/X появляется на экране терминала в граф оболочке. тоесть условно говоря почему
в одном случае данные летят в /dev/pts/X и в итоге они отображаются на экране а вдругом
случае напрвляем дарные в /dev/pts/X и они летят в сеть а на экране ничего нет.
  -bash что за минус перед баш?

- проанализиовать $ ssh git@github.com -v
- я вот чото непойму . на гитхабе столкулся у меня сгенерирован ed25519 ключ. но при конекте к гитхабу он конектился успешно через этот ключ но по протоколу ECDSA
попробовать такое провернуть на примере связи с вирт машиной.
а так чтобы исключить это гавно я почистил known_hosts
и в config добавил
$ cat ./config 
HOST github.com
    HOSTNAME github.com
    IdentityFile /home/vasya/.ssh/id_ed25519
    user git
    FingerprintHash sha256     # в каком виде нам показывать хэш 
    HostKeyAlgorithms ssh-ed25519  # по какому ассим протоколу стучать на гитхаб




- vagrant ssh имя банально себя форкает и запускает /usr/bin/ssh c параметрами а сам уходит в wait. вот и весь секрет
- git push -v себя форкает и запускает /usr/bin/ssh c параметрами вот и весь секрвет. так что у него нет встроенного клиента ssh он юзает тот что на хосте. 
- вопрос как git push -v понимает как ключ надо использовать для аутентифкации. ведь у меня их много. как я понял git имеет встоенный ssh клиент. в момем случае он просто перебирал
все ключи что у меня есть  в ~/.ssh. а так получается что встроеннй в git клиент ssh 
тоже умеет использовать ~/.ssh/config файл.мне так кажется. с чего я это взял. потому что 
я в config создал запись для гитхаб и там указал специально неверный ключ. и связь с гитзабом
через git перестала работать (проверить еще раз это)

- man 8 sshd искать формат known_hosts. прочитать проработать
- known_hosts как там найти заданный хост или хэш ? его формат есть в man 8 sshd
- формат known_hosts

- расмотреть случай когда HashKnownHosts yes
- из примера что выше почему в 
(удаленный сервер)# cat /etc/ssh/ssh_host_rsa_key.pub 
есть root@vagrant
а в
(наш комп)$ cat known_hosts
его уже нет

- ssh-rsa vs ecdsa-sha2-nistp256 vs ssh-ed25519

- выяснилась офимегнная вещь. есть sshd_config а  есть ssh_config.
sshd_config это конфиг для сервера ssh тоесть когда наш комп является сервером и принимает
запросы от других и это его конфиг файл. а ssh_config это когда мы с нашего пользуемся клиентом ssh и это его конфиг файл! 
- непонятно ~/.ssh/config это локальный аналог sshd_config или ssh_config. 
насколько я понимаб локального аналога для sshd_config быть неможет . поэтому
~/.ssh/config это аналог ssh_config. тогда непонятно почему опция HashKnownHosts no 
прописанна я в config несрабаывает и срабатывает если ее запихунть только в ssh_config

- HashKnownHosts yes
- формат публичного ключа
- sshd -T 
- ssh-keyscan
- написать какие файлы мы уже затронули для чего ни используется в ssh (наример known_hosts)
- чтобы несравнивать глазами как сравнить два хэша ?
- md5sum binary vs text? какая разница?
- On  systems like GNU that do not distinguish between binary and text
     files, this option merely flags each input mode as binary: the MD5
     checksum is unaffected
- md5sum для публичного ключа несовпдаает с ssh-keygen
тоесть
cat /etc/ssh/key.pub | md5sum  
и
ssh-keygen -fl /etc/ssh/key.pub 
выдает совсем разные хэши. почему? непонятно
- что интересно md5sum он всегда вавыодит хэш без знаков : в отличие от ssh-keygen
- < vs  << vs <<< bash ?
- man md5sum : Do not use the MD5 algorithm for security related purposes. почему?
- надо понять sha256 это наш клиент по деолту так просит или сервер по дефолту так шлет
- где посмотреть какой асиметрик метод первым шлется на сервер (  я про ECDSA который по дефолту предлагается)
- я щас покажу как нам узнать какой метод был выбран чуть ниже. 
- $ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
дебилизмы с -o
- где на клиенстой машине берется публичный ключ который шлется серверу. 
тот публичный ключ котоый используется для создания первичного безопасного канала
- еще такой вадный момент что мы рассматривали как нам важно узнать что публик кей реально 
от сервера. а что насчет сервера? важно ли ему чтобы он знал что наш клиенсткий
ключ исходит именно от нас. в общем случае нет. любой публичнй ключ что от нас что 
от злодея для сервера это полноценный ключ. на основе этих ключей будет устанолвен безопасный
канал между сервером и нами либо между сервером и злодеем. в любом случае небудет тресторонней
цепочти типа мы злодей сервер. тоесть канал шифрования дает то что между точно сервером и 
непонятно каким то есть любымт клиентом  с гарантией что нет третьего участинка устаналивается
безпонаснвй канал. когда он устанолвен то наступает фаза аутентификации клиента. клиент аутентифиаицирцется внутри этого безпоасного канала либо через логин пароль либо через публичный ключ и так понимаю что это неможет быть другой ключ отличный от того что участвовал
в создании безопасного канала (верно неверно?). через аутентифцаицию сервер понимает что 
эт непросто вообще клиент а именно этот клеинт. есл через ключ то на сервере нужно заблаговременно добавлять хэш публичного ключа клиента ( верно неверно?)

- вопрос асиметрик метод и симетрик метод о них договоариваются сразу на первом этапе за один раз или на разных
этапах. 

- вопрос симметрис vs asymtryc. на первом этапе неиспользуется асссиметричное шфиование. почему?потому что с его помощью невозможно беопасно выработать общий ключ ? типа асиметрик шифрование
это единственный способ? ассмтерик шифрование неиспользуеся дляпердачи больших данных потому 
что оно супер тяжелое по сравнению с симметрик шифрованием ?

- как договвариваются клиент и сервер (причем надежно чтоб мэн ин зе мидл не влез) о 
о начальных параметрах сеанса. например о способе ассметриченого шифрования.
- ssh vs ssl ?
- ssh vs ipsec
- дифи хельман ?
- ssh на циско
- походу ssh это всегда async шифрвание вначале  а потом sync шифрование?
- а какой протокол на sync у ssh ?
- получается три фазы? фаза обмена параметрами, асинк шифр, синк шифр? разница с ipsec?
- hmac ?
- при команде $ vagrant ssh имя_вируталки 
по факту в списке процессов появлется такой
/usr/bin/ssh vagrant@127.0.0.1 -p 2222 -o LogLevel=FATAL -o Compression=yes -o DSAAuthentication=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /home/vasya/.vagrant.d/insecure_private_key -o ForwardAgent=yes
разобрать ключи. 
кстати сразу видно какой приватный ключ используется === -i /home/vasya/.vagrant.d/insecure_private_key


==
