авто suspend на ноутбуке сдеатлать
===
poll


#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <unistd.h>

/*
 * Monitor memory partial stall with 1s tracking window size
 * and 150ms threshold.
 */
int main() {
      const char trig[] = "some 150000 1000000";
      struct pollfd fds;
      int n;

      fds.fd = open("/proc/pressure/memory", O_RDWR | O_NONBLOCK);
      if (fds.fd < 0) {
              printf("/proc/pressure/memory open error: %s\n",
                      strerror(errno));
              return 1;
      }
      fds.events = POLLPRI;

      if (write(fds.fd, trig, strlen(trig) + 1) < 0) {
              printf("/proc/pressure/memory write error: %s\n",
                      strerror(errno));
              return 1;
      }

      printf("waiting for events...\n");
      while (1) {
              n = poll(&fds, 1, -1);
              if (n < 0) {
                      printf("poll error: %s\n", strerror(errno));
                      return 1;
              }
              if (fds.revents & POLLERR) {
                      printf("got POLLERR, event source is gone\n");
                      return 0;
              }
              if (fds.revents & POLLPRI) {
                      printf("event triggered!\n");
              } else {
                      printf("unknown event received: 0x%x\n", fds.revents);
                      return 1;
              }
      }

      return 0;
}

ссылка
https://docs.kernel.org/accounting/psi.html
разобрать пример


==

что за хрень dnsmasq

/usr/bin/dbus-daemon --config-file=/usr/share/defaults/at-spi2/accessibility.conf --nofork --print-address 3


$ sudo cat /var/lib/libvirt/dnsmasq/default.conf
##WARNING:  THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
##OVERWRITTEN AND LOST.  Changes to this configuration should be made using:
##    virsh net-edit default
## or other application using the libvirt API.
##
## dnsmasq conf file created by libvirt
strict-order
user=libvirt-dnsmasq
pid-file=/var/run/libvirt/network/default.pid
except-interface=lo
bind-dynamic
interface=virbr0
dhcp-range=192.168.122.2,192.168.122.254
dhcp-no-override
dhcp-authoritative
dhcp-lease-max=253
dhcp-hostsfile=/var/lib/libvirt/dnsmasq/default.hostsfile
addn-hosts=/var/lib/libvirt/dnsmasq/default.addnhosts
 


===
новые линуксы юзают nftables
надо ее поизучить

===
если есть секвая карта и в нее процесс пишет
то как это найти в lsof
напрмиер qemu при старте открыает сет карту на хосте. 
как это в proc увидеть ?


===
в убунту есть вот такая хрень
 man 8 fanatic

 что это за хрень?!?!?! fan network

 

==


ознакосмиться для чего все эти утилиты
(это из пакета util-linux)

$ dpkg -L  util-linux | grep bin/
/bin/dmesg
/bin/findmnt
/bin/lsblk
/bin/more
/bin/mountpoint
/bin/su
/bin/wdctl
/sbin/agetty
/sbin/blkdiscard
/sbin/blkid
/sbin/blkzone
/sbin/blockdev
/sbin/chcpu
/sbin/ctrlaltdel
/sbin/findfs
/sbin/fsck
/sbin/fsck.cramfs
/sbin/fsck.minix
/sbin/fsfreeze
/sbin/fstrim
/sbin/hwclock
/sbin/isosize
/sbin/mkfs
/sbin/mkfs.bfs
/sbin/mkfs.cramfs
/sbin/mkfs.minix
/sbin/mkswap
/sbin/pivot_root
/sbin/runuser
/sbin/sulogin
/sbin/swaplabel
/sbin/switch_root
/sbin/wipefs
/sbin/zramctl
/usr/bin/addpart
/usr/bin/choom
/usr/bin/chrt
/usr/bin/delpart
/usr/bin/fallocate
/usr/bin/fincore
/usr/bin/flock
/usr/bin/getopt
/usr/bin/hardlink
/usr/bin/ionice
/usr/bin/ipcmk
/usr/bin/ipcrm
/usr/bin/ipcs
/usr/bin/last
/usr/bin/lscpu
/usr/bin/lsipc
/usr/bin/lslocks
/usr/bin/lslogins
/usr/bin/lsmem
/usr/bin/lsns
/usr/bin/mcookie
/usr/bin/mesg
/usr/bin/namei
/usr/bin/nsenter
/usr/bin/partx
/usr/bin/prlimit
/usr/bin/resizepart
/usr/bin/rev
/usr/bin/setarch
/usr/bin/setpriv
/usr/bin/setsid
/usr/bin/setterm
/usr/bin/taskset
/usr/bin/uclampset
/usr/bin/unshare
/usr/bin/utmpdump
/usr/bin/whereis
/usr/sbin/chmem
/usr/sbin/ldattach
/usr/sbin/readprofile
/usr/sbin/rtcwake
/sbin/getty
/usr/bin/i386
/usr/bin/lastb
/usr/bin/linux32
/usr/bin/linux64
/usr/bin/x86_64


====
проработать локи к файлам
надо прорабовтаь:
  - статью 
    https://www.baeldung.com/linux/file-locking#:~:text=The%20lslocks%20Command,file%20locks%20in%20our%20system.&text=In%20the%20above%20list%2C%20we,locked%20files%20in%20the%20system.
  - маны по трем функциям
    $ man 2 flock
    $ man 3 lockf
    $ man 2 fcntl   <======


====
  If pshared is nonzero, then the semaphore is shared between processes, and should be located in a region of shared memory (see shm_open(3), mmap(2), and  shmget(2)).   (Since  a
       child created by fork(2) inherits its parent's memory mappings, it can also access the semaphore.)  Any process that can access the shared memory region can operate on the sema‐
       phore using sem_post(3), sem_wait(3), and so on
       
       
       что?????
       
       
  sem_init() initializes the unnamed semaphore at the address pointed to by sem.  The value argument specifies the initial value for the semaphore.


чайлд он имеет копию памяти парента. но обе памяти незавсиимые.
один клон другго но связи между ними нет.
а если семаор хранится в памяти процесса. то как два процесса парент и чаолд
могут делить один семафор?? что хуйня. он же у каждого свйоп получется?!?!?!

===

инсталляция qemu на комп

1998  apt-get install qemu-system-x86
 1999  apt-get install qemu-user-static
 2004  apt-get install qemu-guest-agent
 2005  apt-get install gnome-terminal
==
$ qemu-img create -f qcow2 manj.img 15G
==
qemu entwork tap



запуск устанвоки
 qemu-system-x86_64 -name manj11 -m 2G -cdrom ~/Downloads/manjaro-cinnamon-23.0.1-230921-linux65.iso   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -display sdl   -smp 2 -M pc-q35-2.11   -vga virtio    -netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:01

$  qemu-system-x86_64 -name manj11 -m 2G -cdrom ~/Downloads/manjaro-xfce-24.0-240513-linux69.iso  -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -display sdl   -smp 2 -M pc-q35-2.11   -vga virtio    -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02




manjao 1GB это вообще неподходит. нужно миимум 2ГБ при устанвке. 
пишет при згрзуе устанвощика что qemu agent dependency failed как лечить незнаю

==
==
чо вотэто за хуня
qemu ....   -device virtio-serial-pci
==
полезные комнды
# stty cols 158
# stty rows 39

-==
надо проверяеть какой менелжер в сиетме устанолвен.
systemd-networkd vs networkmanager vs netplan ?
==
удалить пакет и его депеденси
 pacman -Rsc package_name
 ==
 
 
 у манаджаро нет подеофтлут никкого файрвллвла
 ==
 ебусь с разрешением в тект консоли лин8укск арча
 pacman -S hwinfo
 hwinfo --framwbuffer
 
 ТЕКСТ косоль она в tty 1 нерартает. надо тыкать в alt+f2
 там кноки рабоиаюи
 
 sudo -s
echo 4 > /sys/class/graphcis/fb0/blank #monitor should be off
echo U:1280x720p-30 > /sys/class/graphics/fb0/mode
echo 0 > /sys/class/graphcis/fb0/blank #monitor should be on again



===

tty
из за пуллимута который в mkinitcpio которй в initramfs занято tty1сука
ив процессах висел процесс у котрого все было deleted!!!! и в maps
 я  вналле нихрен не понялу!
==

оазершить iptables на docker0 конейренры внутри нуттубка а именно ssh!
==
узнать как ядро было загуркжено в граб

s# cat /proc/cmdline 
BOOT_IMAGE=/boot/vmlinuz-6.2.0-32-generic root=UUID=9893ccba-b082-43ec-82c4-dea1d578316d ro quiet intel_pstate=disable cryptdevice=UUID=18762ff8-3aed-4810-9a56-d59aba30e533:luks-18762ff8-3aed-4810-9a56-d59aba30e533 root=/dev/mapper/luks-18762ff8-3aed-4810-9a56-d59aba30e533 resume=/dev/mapper/luks-46b7c787-735a-4251-a15c-f41f57ce4e16


===

2.0 /proc/consoles
------------------
Shows registered system console lines.

To see which character device lines are currently used for the system console
/dev/console, you may simply look into the file /proc/consoles:

  > cat /proc/consoles
  tty0                 -WU (ECp)       4:7
  ttyS0                -W- (Ep)        4:64

The columns are:

  device               name of the device
  operations           R = can do read operations
                       W = can do write operations
                       U = can do unblank
  flags                E = it is enabled
                       C = it is preferred console
                       B = it is primary boot console
                       p = it is used for printk buffer
                       b = it is not a TTY but a Braille device
                       a = it is safe to use when cpu is offline
  major:minor          major and minor number of the device separated by a colon

у меня
# cat /proc/consoles 
tty0                 -WU (EC p  )    4:1



===

nomodeset

In the beforetime the resolution (or screen mode) was set differently in a bunch of different places: the BIOS would set the initial mode, then Grub would set a mode supported by the ancient VESA BIOS Extensions (VBE) system, dependent on which obsolete video card your GPU pretended to be, then X would set a different mode dependent on the driver and the detected display. Lots of mode switches, and lots of mess, and no shared infrastructure. Then Kernel ModeSetting (KMS) was developed that scraps all of that nonsense in favour of simply letting the Linux kernel handle it since the kernel has to interact with the hardware anyway and the software needs to interact with the kernel anyway. nomodeset tells the kernel not to do KMS, so you fall back to the prior hodge-podge. It's useful when nouveau (the open-source driver for Nvidia hardware) fails to detect things properly through KMS, but not for much else.

For newer AMD drivers than the ones that came with the initial 18.04 release you'd want the Hardware Enablement Stack (HWE) selected (the default for fresh installs from 18.04.2 onwards) and a newer version of Mesa. There are different PPAs available that give versions of Mesa with different levels of newness.

===
смотрим модел викллеоартычерез
lscpi

а смотрим драйрве который эту железку рулит
lspci -v

00:02.0 VGA compatible controller: Intel Corporation 4th Gen Core Processor Integrated Graphics Controller (rev 06) (prog-if 00 [VGA controller]) <==== видеокрта модель
	Subsystem: Lenovo ThinkPad T440p
	Flags: bus master, fast devsel, latency 0, IRQ 29
	Memory at f0000000 (64-bit, non-prefetchable) [size=4M]
	Memory at e0000000 (64-bit, prefetchable) [size=256M]
	I/O ports at 3000 [size=64]
	Expansion ROM at 000c0000 [virtual] [disabled] [size=128K]
	Capabilities: <access denied>
	Kernel driver in use: i915
	Kernel modules: i915   <======= драйвер

===
qemu 
узниаит какие железки она может показать внутри VM

qemu-system-x86_64 -device help

оно покжает все желещки


видеоарты
Display devices:
name "ati-vga", bus PCI
name "bochs-display", bus PCI
name "cirrus-vga", bus PCI, desc "Cirrus CLGD 54xx VGA"
name "isa-cirrus-vga", bus ISA
name "isa-vga", bus ISA
name "qxl", bus PCI, desc "Spice QXL GPU (secondary)"
name "qxl-vga", bus PCI, desc "Spice QXL GPU (primary, vga compatible)"
name "ramfb", bus System, desc "ram framebuffer standalone device"
name "secondary-vga", bus PCI
name "sga", bus ISA, desc "Serial Graphics Adapter"
name "VGA", bus PCI
name "vhost-user-gpu", bus virtio-bus
name "vhost-user-gpu-pci", bus PCI
name "vhost-user-vga", bus PCI
name "virtio-gpu-device", bus virtio-bus
name "virtio-gpu-gl-device", bus virtio-bus
name "virtio-gpu-gl-pci", bus PCI
name "virtio-gpu-pci", bus PCI, alias "virtio-gpu"
name "virtio-vga", bus PCI
name "virtio-vga-gl", bus PCI
name "vmware-svga", bus PCI


CPU devices:
name "486-v1-x86_64-cpu"
name "486-x86_64-cpu"
name "athlon-v1-x86_64-cpu"
name "athlon-x86_64-cpu"
name "base-x86_64-cpu"
name "Broadwell-IBRS-x86_64-cpu"
name "Broadwell-noTSX-IBRS-x86_64-cpu"
name "Broadwell-noTSX-x86_64-cpu"
name "Broadwell-v1-x86_64-cpu"

но более того. можно смотерть екакие опции парметры можно по железе указатьа

$ qemu-system-x86_64 -device qxl,help  <======
qxl options:
  acpi-index=<uint32>    -  (default: 0)
  addr=<int32>           - Slot and optional function number, example: 06.0 or 06 (default: -1)
  cmdlog=<uint32>        -  (default: 0)
  debug=<uint32>         -  (default: 0)
  failover_pair_id=<str>
  global-vmstate=<bool>  -  (default: false)
  guestdebug=<uint32>    -  (default: 0)
  max_outputs=<uint16>   -  (default: 0)
  multifunction=<bool>   - on/off (default: false)
  ram_size=<uint32>      -  (default: 67108864)
  ram_size_mb=<uint32>   -  (default: 4294967295)
  revision=<uint32>      -  (default: 5)
  rombar=<uint32>        -  (default: 1)
  romfile=<str>
  romsize=<uint32>       -  (default: 4294967295)
  surfaces=<int32>       -  (default: 1024)
  vgamem_mb=<uint32>     -  (default: 16)
  vram64_size_mb=<uint32> -  (default: 4294967295)
  vram_size=<uint64>     -  (default: 67108864)
  vram_size_mb=<uint32>  -  (default: 4294967295)
  x-pcie-extcap-init=<bool> - on/off (default: true)
  x-pcie-lnksta-dllla=<bool> - on/off (default: true)
  xres=<uint32>          -  (default: 0)
  yres=<uint32>          -  (default: 0)

===
showconsolefont
setfont ter-v24n

шрифт на стадии загрузки зашит в initramfs
а туда он поаадет от 
mkinitcp -H cosnolefont
а там наисано что шоитф бертя из vconsole.cfg
шриыт для консоли лежат в /usr/share/kbd/consolefont/

==
окзываетс есть 16 битныйй протокл загрузки ядра линукс
есть 32 быитный протокоол загрузки ядра линукс

===
grub
set pager=1
vbeinfo
==
граф настройки
qemu -device qxl-vga,id=video0,vgamem_mb=64,xres=1900,yres=1000
fbset = опзовялет посмртеть
video=1900x1000M@60
grub_gfxmode=1600x900x32
grub_gfxpayload_LINUX=....
grub_terminal_output=console
==
со шрфитами
mkinitcp -P
хук consolefont
читаем имя фонта из /etc/vconosle.cfg
грифты лжат в /usr/share/kbd/consolfeont
првроеть щас шрфит эт 
serfont ....
посмтеть текущий конльны шрифт это 
showconsolefont -i -v  -C ,,,,
==
по пводу qemu и виедокарт
как я пнял самая клаяаная видеокрта
это ели у ебя на буке две карты. иодну
из них ожно пробростить в виртуалку!
это будет саая ыстрая схема!
==
qemu aget позоволяет из libvirt
слтать комнду в ВМ
spixe agent позволяет иметь типа 
каоассуную граф связь с витуалкой
например мышка клсно рабоатет
видимо переход програзный от хсота
в вм

==
spice
их строка
qemu-system-x86_64 -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent

моя строка
qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -display sdl   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02  -device qxl-vga,id=video0,vgamem_mb=16

моя новая строка
qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02  -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
==

virt-manager -c qemu:///session

==

libvirt

/usr/bin/qemu-system-x86_64 
-name guest=manjaro,debug-threads=on 
-S 

-object {
"qom-type":"secret",
"id":"masterKey0",
"format":"raw",
"file":"/home/vasya/.config/libvirt/qemu/lib/domain-2-manjaro/master-key.aes"} 

-machine pc-q35-6.2,usb=off,vmport=off,dump-guest-core=off,memory-backend=pc.ram 
-accel kvm 
-cpu host,migratable=on 
-m 2048 

-object {"qom-type":"memory-backend-ram","id":"pc.ram","size":2147483648} 

-overcommit mem-lock=off 
-smp 1,sockets=1,cores=1,threads=1
-uuid 3922d246-c833-437e-80b6-8ddea7a7538b 
-no-user-config 
-nodefaults 
-chardev socket,id=charmonitor,fd=29,server=on,wait=off 
-mon chardev=charmonitor,id=monitor,mode=control 
-rtc base=utc,driftfix=slew -global kvm-pit.lost_tick_policy=delay 
-no-hpet 
-no-shutdown 
-global ICH9-LPC.disable_s3=1 
-global ICH9-LPC.disable_s4=1 
-boot strict=on 
-device pcie-root-port,port=16,chassis=1,id=pci.1,bus=pcie.0,multifunction=on,addr=0x2
-device pcie-root-port,port=17,chassis=2,id=pci.2,bus=pcie.0,addr=0x2.0x1 
-device pcie-root-port,port=18,chassis=3,id=pci.3,bus=pcie.0,addr=0x2.0x2 
-device pcie-root-port,port=19,chassis=4,id=pci.4,bus=pcie.0,addr=0x2.0x3 
-device pcie-root-port,port=20,chassis=5,id=pci.5,bus=pcie.0,addr=0x2.0x4 
-device pcie-root-port,port=21,chassis=6,id=pci.6,bus=pcie.0,addr=0x2.0x5 
-device pcie-root-port,port=22,chassis=7,id=pci.7,bus=pcie.0,addr=0x2.0x6 
-device pcie-root-port,port=23,chassis=8,id=pci.8,bus=pcie.0,addr=0x2.0x7 
-device pcie-root-port,port=24,chassis=9,id=pci.9,bus=pcie.0,multifunction=on,addr=0x3 
-device pcie-root-port,port=25,chassis=10,id=pci.10,bus=pcie.0,addr=0x3.0x1
-device pcie-root-port,port=26,chassis=11,id=pci.11,bus=pcie.0,addr=0x3.0x2 
-device pcie-root-port,port=27,chassis=12,id=pci.12,bus=pcie.0,addr=0x3.0x3 
-device pcie-root-port,port=28,chassis=13,id=pci.13,bus=pcie.0,addr=0x3.0x4 
-device pcie-root-port,port=29,chassis=14,id=pci.14,bus=pcie.0,addr=0x3.0x5 
-device qemu-xhci,p2=15,p3=15,id=usb,bus=pci.2,addr=0x0 
-device virtio-serial-pci,id=virtio-serial0,bus=pci.3,addr=0x0 

-blockdev {"driver":"file","filename":"/home/vasya/.local/share/libvirt/images/manjaro.qcow2","node-name":"libvirt-2-storage","auto-read-only":true,"discard":"unmap"} 

-blockdev {"node-name":"libvirt-2-format","read-only":false,"discard":"unmap","driver":"qcow2","file":"libvirt-2-storage","backing":null} 

-device virtio-blk-pci,bus=pci.4,addr=0x0,drive=libvirt-2-format,id=virtio-disk0,bootindex=2 

-blockdev {"driver":"file","filename":"/home/vasya/Downloads/manjaro-cinnamon-23.0.1-230921-linux65.iso","node-name":"libvirt-1-storage","auto-read-only":true,"discard":"unmap"} 

-blockdev {"node-name":"libvirt-1-format","read-only":true,"driver":"raw","file":"libvirt-1-storage"} 

-device ide-cd,bus=ide.0,drive=libvirt-1-format,id=sata0-0-0,bootindex=1 

-netdev user,id=hostnet0 -device virtio-net-pci,netdev=hostnet0,id=net0,mac=52:54:00:42:ae:99,bus=pci.1,addr=0x0 

-chardev pty,id=charserial0 

-device isa-serial,chardev=charserial0,id=serial0 

-chardev socket,id=charchannel0,fd=27,server=on,wait=off 

-device virtserialport,bus=virtio-serial0.0,nr=1,chardev=charchannel0,id=channel0,name=org.qemu.guest_agent.0 

-chardev spicevmc,id=charchannel1,name=vdagent 

-device virtserialport,bus=virtio-serial0.0,nr=2,chardev=charchannel1,id=channel1,name=com.redhat.spice.0 

-audiodev {"id":"audio1","driver":"spice"} 

-spice port=5900,addr=127.0.0.1,disable-ticketing=on,image-compression=off,seamless-migration=on 

-device qxl-vga,id=video0,ram_size=67108864,vram_size=67108864,vram64_size_mb=0,vgamem_mb=16,max_outputs=1,bus=pcie.0,addr=0x1 

-device virtio-balloon-pci,id=balloon0,bus=pci.5,addr=0x0 

-object {"qom-type":"rng-random","id":"objrng0","filename":"/dev/urandom"} 

-device virtio-rng-pci,rng=objrng0,id=rng0,bus=pci.6,addr=0x0 

-sandbox on,obsolete=deny,elevateprivileges=deny,spawn=deny,resourcecontrol=deny 

-msg timestamp=on

==
получается virt manager юзает virt-view а оно бзает spice чтоы нам показывать дисплей виртуалкуи.
и это хуже чем -display sdl
дает задежкру и размтытая ккартинка
==
можнооднврременоп подключиться к вм через spice и sdl
==
чрез spice в гграф ржиме дункск  мышка летает круто. 
а вот через sdл мышка тормзит. поэтому тут spice вне конкуррекцнии
===
 а вот -dsiplay gtk
уже работает мышь охуенно. и спайс никкой не нужен!
==
конечночная хуййня что раоатет

qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02  -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent -display gtk --spice  disable-ticketing=on,image-compression=off,seamless-migration=on,gl=off,unix=on,addr=/tmp/spice.sock -device qxl-vga,id=video0,ram_size=67108864,vram_size=67108864,vram64_size_mb=0,vgamem_mb=16,max_outputs=1,bus=pcie.0,addr=0x1 

gtk + spice

==

пооходу -vga qxl это урощеннавея версия когда пишем 
-device qxl-vga,id=video0,ram_size=67108864,vram_size=67108864,vram64_size_mb=0,vgamem_mb=16,max_outputs=1,bus=pcie.0,addr=0x1 

тоесть второе это более подробное.
а оба сразу нельяз ошлет нахер

==
qxl vs qxl-vga = ?

=

$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02      -sandbox on,resourcecontrol=allow     -device virtio-mouse -device virtio-keyboard -device virtio-vga -display gtk,gl=on
vasya@thinkpad:~/VM/manj2$ 

граф режиме окей хотя и llvm
а текстовый хуйня


получается с qxl охуенная четкость в тесктомров режиме
2$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -vga qxl 

нов графичекомм хуйня  нрпимер нельзя поменять разрешение

а с virtiio размыто в тестоммвом но классно  в графическом
vasya@thinkpad:~/VM/manj2$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -vga virtio 

ввот так прям отлично в тектсом режиме
$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -device qxl-vga,id=video0,vgamem_mb=16,xres=1800,yres=900
даже в grub ненжн преедвать разрешение. он сам выставит

==
чужаястрочка
qemu-system-x86_64 -enable-kvm -boot order=c -drive file=storage/sda,format=qcow2 -m 6G -smp cores=2 -vga none -device qxl-vga,vgamem_mb=128 -spice port=5900,disable-ticketing -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent -netdev bridge,id=hn0 -device virtio-net-pci,netdev=hn0,id=nic1 -daemonize

===
аоискк кета по маске
pacman -Ssq <regex>

==

по деолту у amjaro нет драйвера X11 от карты qxl
есть только дравер какото там. 
поэтому кодга старутет x11 то юзает драйыер mendenso. чкототкте
нужно посвтитьдфрайфайр x11 и наптсать окнфинеогиг

pacman -S xf86-video-qxl

/usr/share/X11/xorg.conf.d/50-qxl.conf 

Section "Device"
Identifier "qxl"
Driver "qxl"
Option "ENABLE_SURFACES" "False"
EndSection

reboot

check /var/log/X11.log

нихера неопонятно ибо lspci риует что драйыер для qxl конечно есть сука

--
кк добавить spice

-device virtio-serial-pci,id=virtio-serial0,bus=pci.3,addr=0x0
-chardev spicevms,id=charchannel1,name=vdagent
-device virtserialport,bus=virtio-serial0.0,nr=2,chardev=charchannel1,id=channel1,name=com.redhat.spice.0

сранвим  с моей строчкой
-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent   
 --spice  disable-ticketing=on,image-compression=off,seamless-migration=on,gl=off,unix=on,addr=/tmp/spice.sock

===
как  добавить qwmeu aagent

запустить виртулки вот тстакийи флгаами
-chardev socket,path=/tmp/qga.sock,server=on,wait=off,id=qga0 \
 -device virtio-serial \
 -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0


на ВИМ ставим паувет 

# pacman -S qemu-user-agent

запускаеслубу
# systemctl daemon-reload
#systemclt emable  qemu-user-agent  --now
#systemclt status  qemu-user-agent  --now

все должно гореить дещеленым


но устанволенный агент qemu и драйыер qxl для X11 все равно недает днамичреки менять разрегение раб сстола!
только через spice конект! а это хрень!
==
сторка и с qemu агентом и spice

 qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -device qxl-vga,id=video0,vgamem_mb=16,xres=1800,yres=900 -chardev socket,path=/tmp/qga.sock,server=on,wait=off,id=qga0  -device virtio-serial  -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0   -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent   --spice  disable-ticketing=on,image-compression=off,seamless-migration=on,gl=off,unix=on,addr=/tmp/spice.sock 

gl=off потому что иначе segmntaiotn fault

конект 
 remote-viewer spice+unix:///tmp/spice.sock

поеичем что дебиально. якобыы через spice клиент экран диначесичаски масштабирцетс. но это брехня.
если посмотеть через xrandr то разареение остатется прежним. !!! просто spice  делает zoom
тоесть все начинает раслыыватьсят!

==
олучается видеале вот так
в этой окманде задаем разленрешшнеие xres=1920,yres=990

$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -device qxl-vga,id=video0,vgamem_mb=16,xres=1920,yres=990 -chardev socket,path=/tmp/qga.sock,server=on,wait=off,id=qga 

в груб ничего пропсиыать ненадо.
н и в принципе все. даже драйвер qxl можн не стаить.
ни qemu агента ни spice агента. нихрна это ненадо
===
основыне этапы:
разрешнеие экрана на grub
шрифт размер на загрузке
разрение экрана в текстовом режиме
spice ненужен
qemu agetnt ненеужен
3d openl ускорения нет.
прброс второй видеораты с бука в вм это я пока неумею
==

===
lxd
при поытыатке запцстить контйнер говорт ошел нахуй
manjaroo lxc newuidmap failed
или
Error: LXD doesn't have a uid/gid allocation.

# ls -1 /etc/sub*id
/etc/subgid
/etc/subuid


и вставить в них
vasyaa:1000000:1000000000

далее надо убедиться что /etc/lxc/ default.conf отсутсвтует

перзапускаем lxd
systemctl restart lxd

но в archlnux это еще не все только root может запусать конейнеры.
а чтбы не рут мог то 
тут читай 
https://wiki.archlinux.org/title/Linux_Containers  <===================== !!!

===
dnsmasq vs systemd-resolvd ?
====
arch+полная шифровка попробвать
===
как войти в нстйроки lxqt панели
одна хуйня про опен бокс про desktopall = no
вторая про поднырривание панели под окна
третье что окна со всех столов покзаывалист - как исправить


$ sudo apt install sysfsutils
~$ systool -m i915 -av
Module = "i915"

  Attributes:
    coresize            = "3883008"
    initsize            = "0"
    initstate           = "live"
    refcnt              = "39"
    srcversion          = "88E5C59BD440FED46FD060D"
    taint               = ""
    uevent              = <store method only>

  Parameters:

  Sections:

$ modinfo i915

чо это за хцйння?
$ 
vasya@thinkpad:/var/log$ cat Xorg.0.log | grep LoadModule
[  1419.434] (II) LoadModule: "glx"
[  1419.453] (II) LoadModule: "modesetting"
[  1419.455] (II) LoadModule: "fbdev"
[  1419.456] (II) LoadModule: "vesa"
[  1419.463] (II) LoadModule: "fbdevhw"
[  1419.465] (II) LoadModule: "glamoregl"
[  1420.253] (II) LoadModule: "fb"
[  1420.589] (II) LoadModule: "libinput"
vasya@thinkpad:/var/log$ 


===
немножко попробвать что такое генту?
=======
как wireguard работает с роутингом?
ip -c r sh table 0
=======


qemu запуск виртувлак через
командную строку с сетью
видеоконсолью либо пробросом serial   порта ( настройки grub и кернел и шрифтов ttyS0  терминала)

lxd запуск subuid subgid

настройука букв tty терминала ( шрифт включая рпзмер букв, ппереключение руский неруский язык, времкнная настройка постоянная , увязка initrd  и systemd,  что такое keymap,
systemd console-setup    сломан на убунту, dpkg reconfigure console-setup   и keyboard как он делает,  keymap tty консоли и xorg это две отдельные настройки localecto set-keymap и x11 -set-keymap,  в сухом остатке понять как  играть со шрифтами и языками для tty  консоли . что такое кеймап.  размер меняь умею а язык нет , переключатель менять языка нет ,  кеймап консоли незнаю что делает.  увязка настроек  когда ос уже загружена    и запись этих же настроек в initrd. )

настройки  клавы в tty  и в режиме  xorg это две отдкльные незавимимые истории




авария- понять что сломал той командой тоесть понять keymap.
аонять как исправить когда сломал,
grub -  работа в rescue shell а именно как 
монтирование luks раздела чтобы он стал виден из граб шелла,  граб модули  куда он их сохраняет ведь /boot/grub недоступен он на люксе лежит и что они дают,
запуск линукса руками из  grub rescue shell когда нет grub.cfg вналичии а линукс загрузитть надо,  аварийный шелл линукса.  как им пользоваться когда нужно найти  "/" раздел линукса.
активиповать доступ по ssh между буками.

--
граф режим это 
окно логина 
панель задач внизу
оконный менеджер
вот что нужно чтобы заработал граф режим.
до этого цровнем ниже драйвер видеокарты и настроенный запущенный xorg service


бэкап нужен обоих буков и посекторный чтобы  восстановииь на тот же бук
и файловый да еще несколько экзмепляров может даже и в дигитал оушн засунуть

почему через граб+кернел нкльзя поменять кеймап?

если есть файловый бэквп машины на luks+lvm как ее вручную  перераьотать чтобы ее запустить скажем наивиртуалке или дигитал оушн без лукс и лвм.



lxd виртуалки делает через qemu а  контейнеры через  lxc.
тоесть точто создано lxd должно быть видно чепещ инструменты qemu и lxc  инастройки должны через них успешно меняться

про граб. вощможно когда диск незашифрован то граб в шелле имеет больше команд.
потомучто он возможно считывает с диска модули?
или надо модули указывать при установке граба и тогда он их записывает (куда?). надо посмотреть мой thinkpaf какое имеет разбиенте по разделам. какие разделы незашиырованы и как там на незашфированеых разделах лежит  граб.


как можно с livecd  ввести паррль и примонтрировать раздел загиырованный люксом


subuid subgid наверно относятся к .usernamespace. когда юзер в этом спеейсе имеет свой uid авдругом спейсе другой а бзер тотже


надо создать раздел.
нанего засунуть толко vmlunuz
и initrd ( зачем оно нужно? а если ядро сонолмт оно нужно? там шрифт консольный длявывода звгпузки и дрова от контролоера дисков). прлучается в ядре нет шрифта ниодного.
так вот сощдать раздел и там засунуть только vmlinuz ibitrd и sh и все и попробовать это загрузить  граьом. а граб поставить отдельно с livecd

ядро просто так незапустмтся.
его надо полрдить по определенному адресу и полготовить всяко разно
и только потом запускать его.
пожтому граб должен быть очень умный. он дроден умкть много из того что умеют ядпра. он долден уметь раьотать с желещом. например иметь драйвер контроллера дискоа и понимать ФС. ему нало найти диск, фс, и файлы. это много чего умение значит
ращные клавы они разнве сканкоды на одну кнопку посылают? а если нет нахуй кейкоды нужны.
шрифт это связь кейколов и глифов? клааа - ядро драйвер клавы-  баш- ядро линия дисципоина - ядро видеодрайвер
что ядоро шлет башу после нажатия кнопки? кейкод?
шрифт нужен для вывода для ваода нет.
что вюзер приложение поступает от ядра от нажатия кеопки? кейкод? а utf-8 кодировка причем тут?

локале она от x11 зпвтсит?
поменять локале. посмотреть вывод времени или чисел.

кеймап это связь кейколов с чем?
iso8859-1 это что?


в ядре есть шрифьы нафиг тогда шрифт есть в initrd?  заглянуть в initrtd чотоам есть и зачем

сощдать файльс utf-8 именем чепещ си и баш?




=======
  <<<<<<<<========
  <<<<<<<<========
AVARIYA

разобраться с ебаной аварией
надо активироватьт чтобы по ssh можно было зайти с компа на комп
на такой случай!

firewall провермть что все порты закрыты на обоих нотубках!

interrupts  timerы
jiffy/tickless ядра

NetworkManager описание

==

как посмотреть все железки котоыре есть в компе.
почти все железки в компе сидят на pci шине 
поэтому можно запустиь 
    $ lspci

фишка в том что если ты pci желека то можно сделать спец запрос по шине и ты обязан откликнуться.
поэтому если в линуксе нет дрвайверов от железки то она все равно будет покзаана 
в отклике lspci!

нов компе есть нетлоко pci шина но isa шина или ее некий аналог. 
там тоже могу сидть isa pnp железки. дальгше непонятно. отклиаются ли  они на lspci 
или нет.

в итоге есть странынй ммонет 
вот железкт которые поукывывает lspci

d$ lspci
00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v3/4th Gen Core Processor DRAM Controller (rev 06)
00:02.0 VGA compatible controller: Intel Corporation 4th Gen Core Processor Integrated Graphics Controller (rev 06)
00:03.0 Audio device: Intel Corporation Xeon E3-1200 v3/4th Gen Core Processor HD Audio Controller (rev 06)
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04)
00:16.0 Communication controller: Intel Corporation 8 Series/C220 Series Chipset Family MEI Controller #1 (rev 04)
00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I217-LM (rev 04)
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04)
00:1b.0 Audio device: Intel Corporation 8 Series/C220 Series Chipset High Definition Audio Controller (rev 04)
00:1c.0 PCI bridge: Intel Corporation 8 Series/C220 Series Chipset Family PCI Express Root Port #1 (rev d4)
00:1c.1 PCI bridge: Intel Corporation 8 Series/C220 Series Chipset Family PCI Express Root Port #2 (rev d4)
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04)
00:1f.0 ISA bridge: Intel Corporation QM87 Express LPC Controller (rev 04)
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04)
00:1f.3 SMBus: Intel Corporation 8 Series/C220 Series Chipset Family SMBus Controller (rev 04)
03:00.0 Network controller: Intel Corporation Wireless 7260 (rev 6b)
vasya@thinkpad:/etc/NetworkManager/conf.d$ 

а вот желзк котыоер мокзывает interrrupts
$ cat /proc/interrupts 
           CPU0       CPU1       CPU2       CPU3       
  0:         22          0          0          0   IO-APIC   2-edge      timer
  1:          0        837          0          0   IO-APIC   1-edge      i8042
  8:          0          0          0          0   IO-APIC   8-edge      rtc0
  9:          0     145335          0          0   IO-APIC   9-fasteoi   acpi
 12:        175          0          0          0   IO-APIC  12-edge      i8042
 16:         31          0          0          0   IO-APIC  16-fasteoi   ehci_hcd:usb2
 18:          6          0          0          0   IO-APIC  18-fasteoi   i801_smbus
 23:          0          0          0         35   IO-APIC  23-fasteoi   ehci_hcd:usb1
 26:     353800       9199          0          0  PCI-MSI-0000:00:1f.2   0-edge      ahci[0000:00:1f.2]
 27:          0          0          7      59149  PCI-MSI-0000:00:19.0   0-edge      enp0s25
 28:          0          0          0     326998  PCI-MSI-0000:00:14.0   0-edge      xhci_hcd
 29:          0        285     742049          0  PCI-MSI-0000:00:02.0   0-edge      i915
 30:          0          0         71          0  PCI-MSI-0000:00:16.0   0-edge      mei_me
 31:          0    1033652          0        160  PCI-MSI-0000:03:00.0   0-edge      iwlwifi
 32:        246          0          0          0  PCI-MSI-0000:00:03.0   0-edge      snd_hda_intel:card0
 33:          0       2150          0          0  PCI-MSI-0000:00:1b.0   0-edge      snd_hda_intel:card1


например на компе есть таймер который сидит внутри IO-APIC микрсоххемы. 
но мы его  в lspci не увидим. а ведь это тоже лежезка.
поэтому тут непонятно. как же нам посмотеть ВСЕ железки внутои комп сидящие.

IO-APIC это контолллер внутри котрго в частности есть таймер.который юзает комп при загузке.
вообще ядру очен унужен источник часов. 
аесть LOCAL APIC он уже внутри ядра цпу. в /pric/interpprups он показан в строке LOC

LOC:   19143350   15579364   16815023   15044160   Local timer interrupts

причем  в ней зашифровнаы все таймеры кроме того что сидит в IO-APIC

поэтому с спсоком железок на компе непняо. как его получить полный.
но точно изветно что lspci покжет ВСЕ желеки сдящие на PCI шине даже если у ядра нет 
доайеров от этой железки

еще прикол в том что номер интрата котоырй покзывает /pric/interpapts 
и lspci 
это не всгде дно и тоже

/proc/interrupts and lspci may show two different values because they are displaying different things.  SOMETIMES they are the same, but not always.

This is because the numbers obtained from the system irq vector should be considered a "cookie" value.  In the case of legacy ISA interrupts, the cookie is the same as the vector.  In the case of MSI/MSI-X, the assignment is a bit more arbitrary.

As such, the irq vector slot is not the same thing as the value being programmed into a PCI device's register.

Furthermore, the PCI device register may not reflect updates from quirks and fixups, so pdev->irq may differ from the PCI device register value in uncommon cases.

So:
1) /proc/interrupts displays a platform-specific, CPU-specific enumeration of the system's irq vectors.
2) lspci displays PCI device register values.

While sometimes the values will be the same, there is no guarantee



в завсиимости от флага в lspci он может покзываеть "реальный " номер IRQ 
а может покызвать "вируталный " номер irq. как я пнял рельрный это релаьный а виртуальный этот
который думает железка сама у нее есть. тоже хуй понятно.



==

на теелфоне у меня открыта ккуча чайтов посвязенщеных keymap клавиутуры.
их надо все перенести на комп
===
хрени которые я изучаю щас : 
  авария (grub,luks,kbd keymaps)
  qemu 
  kbd keymaps, \
  jiffy + interrutps+ разные вид IDLE режимов ядра,
  NM(_susyemd+netwotkd),

==
wiregiueard
я так и непонял как вайргард работает связь.
оно это делает через катомную табрлицу маршутизации. 
но как сука это в итоге то работатет?!?!?!!?

==
$ touch  $'\u2234\u2192\u263f\u2605'.txt
ssh.txt:$ ls -1 | grep  $'\u2234\u2192\u263f\u2605'
[ LENOVO ]$(&) strace -e execve touch  $'\u2234\u2192\u263f\u2605'.txt 
execve("/usr/bin/touch", ["touch", "\342\210\264\342\206\222\342\230\277\342\230\205.txt"], 0x7ffcde5c6038 /* 73 vars 

===
systemctl --user ....
чо за хрень.
https://wiki.archlinux.org/title/Systemd/User

===
bash PS1 дописать 
и в стековерфлоу выложить свой приколный вариант с PS1


PS1=' $(printf "\U0000$(   echo "obase=16;$(($RANDOM % 250))" | bc  )$(   echo "obase=16;$((50+($RANDOM % 200)))" | bc  )") '
ss

==
ращбираюсь  с локалбю locale1.txt

==

        файл sysfs2.txt
e
!!!!!
дописать 
         ssh+bash.txt  про разобрться вконце
         jiffy.txt jiffy про USER_HZ и CONFIG_HZ 
         locale1.txt про locale
         udev.txt про udev
         lxd.txt про LXD unix socket "/var/snap/lxd/common/lxd/unix.socket
         sysfs2.txt   про fan_mode и про LPC и про то как узнать установен ли 
          драйвер для железки
         попробовать загрузку новго ядра через kexec !
         файл grub2+initrd.txt про то как работает загрузка линукса 
         разобраться ((https://unix.stackexchange.com/questions/765565/starting-qemu-as-another-user))  
         что такое mount move ? например mount -n -o move /run ${rootmnt}/run

==
надо провереть на финкпаде что модуль граба usbkeyboard
реально отвечает за то чтобы кнопки вводить с usb клавы чтобы она работала
==
леново. загрузить новое ядро чтобы проверить /sys/class/..../VBC 24 
который позволяет регулировать работу вентилятора . потому что на ядре 5
он нихуя неделает как надо

==
>>>>>>>>>
initrd:
вопросы:


расписать все класнно про grub и инитрд
надо устаноить линукс на полносью защирфованные разделы.
а потом из другого граба расшифрвать раздел и даже загрузиться  с него

вобще центровая тема уметь ловко орудовать переносом запуском линукск
который был устанолвен на LVM+LUKS уметь его переносить и запускать из 
граба. и все это конечно завязано на initrd

непонятный моменты:

mount -t tmpfs udev /dev
                /\
                ||
            здесь по идее должосоять имя устрйства
сразу после заупска комнды там пусто. а только птом если запустить 
udev демона то там заполянется. видимо udev демон рнаходит эту папку 
и прост рукми через mknod создает веместо нас там устйроства . и все.

если хотим полклчться к устроссву то делается это так. у ядра дожлен быть 
дравер. этот дравйвер находит жеделхку и назнчает ей номер  а мы должны 
кактот этот номент узнать. например. граф экран у граба это tty1
и нам надосзать через mknod именно tty1 а не tty20
        # mknod 4 1 /dev/tty1
причем tty1 можно сзтаь где угодно необязательно в /dev это вобше неважно
важно только его major и минор а негде он лежит или как зовут файл 
можно назать и tty20 но мажор=4 а минор=1 и тогда процсс обращается на эттот файл


вопросы по тому как работает initrd
udev от ядра узнает все ннетлинку а что это на практие? 
в скриптх я видел /proc/hotplug 
udev-# It's all over netlink now
udev:echo "" > /proc/sys/kernel/hotplug
о чем это как это ?

также в скриптах настривалсялись шрифты консоли. разобраться.

также оказалос что чтобы заработа run-init
самый корень это сделать перенаравление ввода вывода в /dev папку которая 
лежит в новом корне. иначе почемуто фигня. у нас получается что у процесса 
как я понимаю смениласи точки монтрования. процесс теперь  через запро к ядру
в виде древоивдной системы может видеть другие файл ы и ппаки. но у него
stdin stdout указыать на дсрпиторы от файлоы /dev/console коооыторые лежат 
в друой видимо муааунт нейспейсе. нуи что? глнаове что мы дескипторы знаем.
нам  вэтом плане на фс уже насритать . но почему то мы будет видеть 
только голый корень и /root пустую папку. такое щущение что  run-innit
и его сисколлы для нашего процесса удляет все точки монторвания нона псоедней 
стадии у него не получаетяс создать для нас точу монтрования нового корня
в итоге наш процесс остается тупо  темноте. такое ощущнеие что run-init
рукодвствтуется тем куда у нас смотрит stdin stdout такой както бред.
я думаю да что вот эта непонятнка когда мы делем run-init
а у нас в итоге пустой  корень и в нем пустой /root
ялумаю run-init вычищает все маунт поинты но в конце недобалвяем новые
и наш процесс окзываетая в своем "старом" маун неймсаейсе
это можно проверить по mountnfi там будут написнаы номера маунт точек
и после натравливаенися run-init номер у / и /root должен остаться прежний
а синткксаис котоыйр приводит к успеху вот такой вот 
  $ run-init /root /sbin/init -i  </root/dev/console >/root/dev/console 2&1
причем неважно какйо у тебя pid . равен он 1 или нет. это похеру. 
абсолютно.
вобще зачем нужны маунт поиты. таким макаром прцоесс  абстрагивтся от железки
диска на котоырй он хочет записть и его раздела. ядро смотрит какой диск
ялвяеся бекендом для этого "фалового пути" и понимает куда ему надо лезть.
тоест процесс как ыб говорит - эй ядр запиши в корент того диска что ты 
подсунул в качеств корня файл 1.txt
понято что у ядра могут быть в дсутпе другие диски но он процессу 
их через маунт поинты может и и не выдать. эт завбавно но по идее у
процесса может не быть ни одного маунт поинта и даже ни одного деескриорпп 
ооткрытого. зато упроцесса всегда есть глвный канал связи с ядром это сиколыы.
тоесть процесс может пооожтить в цпу в регтсры араметры и взывать на цпу
сисколлл. и ядро может все что процесс захочет подкчьбить ему без проблем
.  и отключить тоже. 
что значт процесс видит файл на фс. на смаомом деле он ничего не видит
и маунт поинты это полная фикция. просто процсс поысылыае т через сисколл
ascii путь к файлу.  ядро видит маунт поинт и понимает что у процесса в принципе
есть "разрешнение " но недосутп к этому диску.   прцоссу вобще ненужно иметь 
маунт поинты. ему главное чтобы ядро взрващало содержимое файлов на диске 
по запрому. маунт поинты это полный фуфел это просто вид файл пермишснов. 
я бы даже сказал вид "диск пермиднсов" со стороны ядра к процесу. это табличка
на камере у зека о том кто он и что он для надизирателя. вот ив се
у процесса вобще ни к акому железку нет доступа кроче цпу куда его шедулер 
иногда пихает. и то к части регистров только.
маунт поинт это листик на стене кухни с картинкой гаваев. доуступа нет туда
просто ядро нам позвояет с гававев ингда получать посылки. вот и вес доступ.

рзобрать  работу initrd всех его скриптов. 
ксатти chrroot в манжаро нерабоатет. наверное из за hardened керенала.
видимо запршены какието сисколлы

надо отписатьс на форму suse там где у мужика не получалось 
как и  меня chroot сделть !

на ядре 2.6 run-init еще работает не длля pid=1 
надо попробвать ядро постстраше потмоу что на 5.10 уже неработает
(они допилили)



                            <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
docker stat  имя_контейнера 
покажет стаститику не для всеъ конетенов а только для искомгого!

CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O          BLOCK I/O        
ea4435dedd67   bash1     0.00%     12.99MiB / 437.5MiB   2.97%     32.4MB / 291kB   115MB / 81.9MB

==
можно подкрутить сколько мощности цпу можно потребрять контйенеру.
причем это можно обновляьт налету. ненужно ни стопить конйенер
ни перезапускать. все работает мгновенно!

# docker update --cpus=0.2 bash1

--cpus=0.2 = это означает что конйерер может максимально жрать 20% от одного ядра!
класс!

==
изучай это = https://labs.iximiuz.com/tutorials/containers-vs-pods
systemd-cgls --no-pager ==?
какой лимит по памяти и свапу в контйенер по дефолту? (узнать из cgroups)

использую это = https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/using-cgroups-v2-to-control-distribution-of-cpu-time-for-applications_managing-monitoring-and-updating-the-kernel

cpu.mac = 10000 100000 =>  0.01s   0.1s > 10% , означает что на отрезке 0.1s нашеу
процессу можно работать 0.01s остаьно время процсс должен спать. вопрос на 
скольких цпу ему можно раобоатьт ?

# grep ""  memory.max
62914560
 это 60MB 
 тоесть процессу монжно жрать только 60МБ оперативки?
 sleep infinit = охрнееть





терминал
баш сидя на слейв конце дает команды в терминал( в дисциплину линии)
так чтобы нажатия кнопок которые приеиают от терминала ( от процесса 
который держит мастер конец ptmx) чтобы дисциплина линии передавала в баш
кнопку сразу а не чтобы дисциалина линии ждала от термиала нажатия Enter
либо Ctrl+D



клава ->---- xterm ptmx -->- дисицплиана линии -->- pts/10 bash

а по дефолту  дисциплина линии ведет себя так что кнопка которая
прилетает от ptmx дисицлипина линии обратно в ptmx шлет 
подтверждение кнопки ( и потму на термиала при нажатии кнопки рсиуется
символ) но в pts/10 дициалпина линпии не шлет! онаждет нажатия Enter!

и вот бащ это меняет!




в начальном вопросе есть вопрос - хочется понять как это работает.
это ключевой и частый вопрос. его я хочу просвятить.


дохрена статьей про терминал.
но либо они слишком теоретичный. либо они слишком сложны.
либо слишком пусты. 
в итоге выхлопа на практчеком понимании дает ноль.
дохрена сттей для тех уто уже все занет very well
кто знает ноль это ад и каша

я прделагаю оттклунться от практики  и сразу появится солко то но 
реального понимания. 
после этого уже можно читать теоречтиекие статьи - навешивать мясо на кости.

поаать как содатеся два процесса соединных терминалом.
потом надо передать сиволы с мастера на слейв. там получить и напечатать 
обрато чтото. мастер получает и печаатет.

конец

====

//dev/ptmx заменет провода от мейнфремы до терминала.
xterm это сам терминал. его задача полученные байты по проду ptmx
как то донести до человека. мы их будем печатать на экране.
между ptmx и pts/N сидит line disciline. пусть там и сидит.
за pts/N сидит слейв программа. 

показать как арботает ctrl+C
как ctrl+D
как работает sigHUP

обяснить что значит процесс имеет pts/12 в свйотвах ps

показат цеопчку для ssh как там все устроено






что за хуйня sysig ?


написть как поставил arch 

qemu как подклчт сеть

$ qemu-system-x86_64 -name arch11 -m 128M   -boot d -hda ./arch.img  -drive file=arch.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -sdl   -smp 2 -M pc-q35-2.11   -vga virtio   -serial /dev/tty  -netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:01


загрузка с grub руками чрез меню
qemu -serial tty раобтает только если граф окно осталвяеем


оухуенная вещь
как узнать размер окна теринала
# stty size
39 158
чтобы его поменять надо цифрв переставить
#stty columns 158 rows 39
охренеь!



а как рбаботает wagrant? его нет в route table!
проуерить iptables-save



похоже я  понял что кернел работает в process context. 
то есть то что кернел код видит прострнстно процесса. наверное это 
потмоу что цпу содержит в себе регистры отвчающие за адреное процестанвтсов
процесса. поэтому и ядерный код тоже видит адресное простанство процесса?
==
The System V IPC facilities include semaphores, shared memory, and message queues==

==
виртулка это доступ к цпу памяти и периферии.
kvm дает доступ к цпу\памяти
qemu к периферии





>>> недописанные текст файлы
    interrupt.txt
    timer_list.txt
    watchdog.txt
    hpet-tsc.txt
    avariya.txt
    semaphores.txt
    serial-com-io.txt
    lxd-vmstat-st-steal.txt
    login.txt
    procinfo.txt
    mmap-malloc-brk.txt
    open-read-write.txt
    socket-pipe.txt
    ncat.txt
    tty2.txt
    affinity.txt
    midnight-commander.txt
    hyper-threading.txt
    zombie-docker.txt
    cgroups.txt
    tty3.txt
    lsns.txt
    linux-ipc.txt
    k8.txt
    minikube2.txt
    io.txt
    nginx-architecture.txt
    midnight-commander2.txt
    



    план работ связанный  с этими файлами:
      brk mmap malloc
      kvm qemu
      archlinux устанвокаи приколы
      archlinux encrypt entire system
      semaphores



>>> файл  qemu-spice.txt  для отдыха начал ставить gentoo но вылезло что вначале
нужно наладить связь с ноутбука на удаленную машину через ssh тоннеель к qemu серверу через spice клиент.



>>> файл bios-uefi.txt начал писать

вопрос - в чем разница между systemd slice vs scope vs service vs target
         начни с чтения man systemd
>>> systemd-pid.txt начал писать
>>> manjaro-install.txt пишу



>>> книги pdf которые не обработаны(лежат на леново в папке Downloads)
    iwDocumentation.pdf
    acpi.pdf
    6300esb-io-controller-hub-datasheet.pdf
    walter_ibm_linux_challenge.pdf
    Understanding Linux Kernel.pdf
    IO-Port-Programming.pdf
    understand.pdf


>>> все необработынные сайты в форме сешшн бади лежат тут:
     docs/nedodelano/30-may-2024.json








