авто suspend на ноутбуке сдеатлать
===
poll


#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <poll.h>
#include <string.h>
#include <unistd.h>

/*
 * Monitor memory partial stall with 1s tracking window size
 * and 150ms threshold.
 */
int main() {
      const char trig[] = "some 150000 1000000";
      struct pollfd fds;
      int n;

      fds.fd = open("/proc/pressure/memory", O_RDWR | O_NONBLOCK);
      if (fds.fd < 0) {
              printf("/proc/pressure/memory open error: %s\n",
                      strerror(errno));
              return 1;
      }
      fds.events = POLLPRI;

      if (write(fds.fd, trig, strlen(trig) + 1) < 0) {
              printf("/proc/pressure/memory write error: %s\n",
                      strerror(errno));
              return 1;
      }

      printf("waiting for events...\n");
      while (1) {
              n = poll(&fds, 1, -1);
              if (n < 0) {
                      printf("poll error: %s\n", strerror(errno));
                      return 1;
              }
              if (fds.revents & POLLERR) {
                      printf("got POLLERR, event source is gone\n");
                      return 0;
              }
              if (fds.revents & POLLPRI) {
                      printf("event triggered!\n");
              } else {
                      printf("unknown event received: 0x%x\n", fds.revents);
                      return 1;
              }
      }

      return 0;
}

ссылка
https://docs.kernel.org/accounting/psi.html
разобрать пример


==

что за хрень dnsmasq

/usr/bin/dbus-daemon --config-file=/usr/share/defaults/at-spi2/accessibility.conf --nofork --print-address 3


$ sudo cat /var/lib/libvirt/dnsmasq/default.conf
##WARNING:  THIS IS AN AUTO-GENERATED FILE. CHANGES TO IT ARE LIKELY TO BE
##OVERWRITTEN AND LOST.  Changes to this configuration should be made using:
##    virsh net-edit default
## or other application using the libvirt API.
##
## dnsmasq conf file created by libvirt
strict-order
user=libvirt-dnsmasq
pid-file=/var/run/libvirt/network/default.pid
except-interface=lo
bind-dynamic
interface=virbr0
dhcp-range=192.168.122.2,192.168.122.254
dhcp-no-override
dhcp-authoritative
dhcp-lease-max=253
dhcp-hostsfile=/var/lib/libvirt/dnsmasq/default.hostsfile
addn-hosts=/var/lib/libvirt/dnsmasq/default.addnhosts
 


===
новые линуксы юзают nftables
надо ее поизучить

===
если есть секвая карта и в нее процесс пишет
то как это найти в lsof
напрмиер qemu при старте открыает сет карту на хосте. 
как это в proc увидеть ?


===
в убунту есть вот такая хрень
 man 8 fanatic

 что это за хрень?!?!?! fan network

 

==


ознакосмиться для чего все эти утилиты
(это из пакета util-linux)

$ dpkg -L  util-linux | grep bin/
/bin/dmesg
/bin/findmnt
/bin/lsblk
/bin/more
/bin/mountpoint
/bin/su
/bin/wdctl
/sbin/agetty
/sbin/blkdiscard
/sbin/blkid
/sbin/blkzone
/sbin/blockdev
/sbin/chcpu
/sbin/ctrlaltdel
/sbin/findfs
/sbin/fsck
/sbin/fsck.cramfs
/sbin/fsck.minix
/sbin/fsfreeze
/sbin/fstrim
/sbin/hwclock
/sbin/isosize
/sbin/mkfs
/sbin/mkfs.bfs
/sbin/mkfs.cramfs
/sbin/mkfs.minix
/sbin/mkswap
/sbin/pivot_root
/sbin/runuser
/sbin/sulogin
/sbin/swaplabel
/sbin/switch_root
/sbin/wipefs
/sbin/zramctl
/usr/bin/addpart
/usr/bin/choom
/usr/bin/chrt
/usr/bin/delpart
/usr/bin/fallocate
/usr/bin/fincore
/usr/bin/flock
/usr/bin/getopt
/usr/bin/hardlink
/usr/bin/ionice
/usr/bin/ipcmk
/usr/bin/ipcrm
/usr/bin/ipcs
/usr/bin/last
/usr/bin/lscpu
/usr/bin/lsipc
/usr/bin/lslocks
/usr/bin/lslogins
/usr/bin/lsmem
/usr/bin/lsns
/usr/bin/mcookie
/usr/bin/mesg
/usr/bin/namei
/usr/bin/nsenter
/usr/bin/partx
/usr/bin/prlimit
/usr/bin/resizepart
/usr/bin/rev
/usr/bin/setarch
/usr/bin/setpriv
/usr/bin/setsid
/usr/bin/setterm
/usr/bin/taskset
/usr/bin/uclampset
/usr/bin/unshare
/usr/bin/utmpdump
/usr/bin/whereis
/usr/sbin/chmem
/usr/sbin/ldattach
/usr/sbin/readprofile
/usr/sbin/rtcwake
/sbin/getty
/usr/bin/i386
/usr/bin/lastb
/usr/bin/linux32
/usr/bin/linux64
/usr/bin/x86_64


====
проработать локи к файлам
надо прорабовтаь:
  - статью 
    https://www.baeldung.com/linux/file-locking#:~:text=The%20lslocks%20Command,file%20locks%20in%20our%20system.&text=In%20the%20above%20list%2C%20we,locked%20files%20in%20the%20system.
  - маны по трем функциям
    $ man 2 flock
    $ man 3 lockf
    $ man 2 fcntl   <======


====
  If pshared is nonzero, then the semaphore is shared between processes, and should be located in a region of shared memory (see shm_open(3), mmap(2), and  shmget(2)).   (Since  a
       child created by fork(2) inherits its parent's memory mappings, it can also access the semaphore.)  Any process that can access the shared memory region can operate on the sema‐
       phore using sem_post(3), sem_wait(3), and so on
       
       
       что?????
       
       
  sem_init() initializes the unnamed semaphore at the address pointed to by sem.  The value argument specifies the initial value for the semaphore.


чайлд он имеет копию памяти парента. но обе памяти незавсиимые.
один клон другго но связи между ними нет.
а если семаор хранится в памяти процесса. то как два процесса парент и чаолд
могут делить один семафор?? что хуйня. он же у каждого свйоп получется?!?!?!

===

инсталляция qemu на комп

1998  apt-get install qemu-system-x86
 1999  apt-get install qemu-user-static
 2004  apt-get install qemu-guest-agent
 2005  apt-get install gnome-terminal
==
$ qemu-img create -f qcow2 manj.img 15G
==
qemu entwork tap



запуск устанвоки
 qemu-system-x86_64 -name manj11 -m 2G -cdrom ~/Downloads/manjaro-cinnamon-23.0.1-230921-linux65.iso   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -display sdl   -smp 2 -M pc-q35-2.11   -vga virtio    -netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:01

$  qemu-system-x86_64 -name manj11 -m 2G -cdrom ~/Downloads/manjaro-xfce-24.0-240513-linux69.iso  -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -display sdl   -smp 2 -M pc-q35-2.11   -vga virtio    -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02




manjao 1GB это вообще неподходит. нужно миимум 2ГБ при устанвке. 
пишет при згрзуе устанвощика что qemu agent dependency failed как лечить незнаю

==
==
чо вотэто за хуня
qemu ....   -device virtio-serial-pci
==
полезные комнды
# stty cols 158
# stty rows 39

-==
надо проверяеть какой менелжер в сиетме устанолвен.
systemd-networkd vs networkmanager vs netplan ?
==
удалить пакет и его депеденси
 pacman -Rsc package_name
 ==
 
 
 у манаджаро нет подеофтлут никкого файрвллвла
 ==
 ебусь с разрешением в тект консоли лин8укск арча
 pacman -S hwinfo
 hwinfo --framwbuffer
 
 ТЕКСТ косоль она в tty 1 нерартает. надо тыкать в alt+f2
 там кноки рабоиаюи
 
 sudo -s
echo 4 > /sys/class/graphcis/fb0/blank #monitor should be off
echo U:1280x720p-30 > /sys/class/graphics/fb0/mode
echo 0 > /sys/class/graphcis/fb0/blank #monitor should be on again



===

tty
из за пуллимута который в mkinitcpio которй в initramfs занято tty1сука
ив процессах висел процесс у котрого все было deleted!!!! и в maps
 я  вналле нихрен не понялу!
==

оазершить iptables на docker0 конейренры внутри нуттубка а именно ssh!
==
узнать как ядро было загуркжено в граб

s# cat /proc/cmdline 
BOOT_IMAGE=/boot/vmlinuz-6.2.0-32-generic root=UUID=9893ccba-b082-43ec-82c4-dea1d578316d ro quiet intel_pstate=disable cryptdevice=UUID=18762ff8-3aed-4810-9a56-d59aba30e533:luks-18762ff8-3aed-4810-9a56-d59aba30e533 root=/dev/mapper/luks-18762ff8-3aed-4810-9a56-d59aba30e533 resume=/dev/mapper/luks-46b7c787-735a-4251-a15c-f41f57ce4e16


===

2.0 /proc/consoles
------------------
Shows registered system console lines.

To see which character device lines are currently used for the system console
/dev/console, you may simply look into the file /proc/consoles:

  > cat /proc/consoles
  tty0                 -WU (ECp)       4:7
  ttyS0                -W- (Ep)        4:64

The columns are:

  device               name of the device
  operations           R = can do read operations
                       W = can do write operations
                       U = can do unblank
  flags                E = it is enabled
                       C = it is preferred console
                       B = it is primary boot console
                       p = it is used for printk buffer
                       b = it is not a TTY but a Braille device
                       a = it is safe to use when cpu is offline
  major:minor          major and minor number of the device separated by a colon

у меня
# cat /proc/consoles 
tty0                 -WU (EC p  )    4:1



===

nomodeset

In the beforetime the resolution (or screen mode) was set differently in a bunch of different places: the BIOS would set the initial mode, then Grub would set a mode supported by the ancient VESA BIOS Extensions (VBE) system, dependent on which obsolete video card your GPU pretended to be, then X would set a different mode dependent on the driver and the detected display. Lots of mode switches, and lots of mess, and no shared infrastructure. Then Kernel ModeSetting (KMS) was developed that scraps all of that nonsense in favour of simply letting the Linux kernel handle it since the kernel has to interact with the hardware anyway and the software needs to interact with the kernel anyway. nomodeset tells the kernel not to do KMS, so you fall back to the prior hodge-podge. It's useful when nouveau (the open-source driver for Nvidia hardware) fails to detect things properly through KMS, but not for much else.

For newer AMD drivers than the ones that came with the initial 18.04 release you'd want the Hardware Enablement Stack (HWE) selected (the default for fresh installs from 18.04.2 onwards) and a newer version of Mesa. There are different PPAs available that give versions of Mesa with different levels of newness.

===
смотрим модел викллеоартычерез
lscpi

а смотрим драйрве который эту железку рулит
lspci -v

00:02.0 VGA compatible controller: Intel Corporation 4th Gen Core Processor Integrated Graphics Controller (rev 06) (prog-if 00 [VGA controller]) <==== видеокрта модель
	Subsystem: Lenovo ThinkPad T440p
	Flags: bus master, fast devsel, latency 0, IRQ 29
	Memory at f0000000 (64-bit, non-prefetchable) [size=4M]
	Memory at e0000000 (64-bit, prefetchable) [size=256M]
	I/O ports at 3000 [size=64]
	Expansion ROM at 000c0000 [virtual] [disabled] [size=128K]
	Capabilities: <access denied>
	Kernel driver in use: i915
	Kernel modules: i915   <======= драйвер

===
qemu 
узниаит какие железки она может показать внутри VM

qemu-system-x86_64 -device help

оно покжает все желещки


видеоарты
Display devices:
name "ati-vga", bus PCI
name "bochs-display", bus PCI
name "cirrus-vga", bus PCI, desc "Cirrus CLGD 54xx VGA"
name "isa-cirrus-vga", bus ISA
name "isa-vga", bus ISA
name "qxl", bus PCI, desc "Spice QXL GPU (secondary)"
name "qxl-vga", bus PCI, desc "Spice QXL GPU (primary, vga compatible)"
name "ramfb", bus System, desc "ram framebuffer standalone device"
name "secondary-vga", bus PCI
name "sga", bus ISA, desc "Serial Graphics Adapter"
name "VGA", bus PCI
name "vhost-user-gpu", bus virtio-bus
name "vhost-user-gpu-pci", bus PCI
name "vhost-user-vga", bus PCI
name "virtio-gpu-device", bus virtio-bus
name "virtio-gpu-gl-device", bus virtio-bus
name "virtio-gpu-gl-pci", bus PCI
name "virtio-gpu-pci", bus PCI, alias "virtio-gpu"
name "virtio-vga", bus PCI
name "virtio-vga-gl", bus PCI
name "vmware-svga", bus PCI


CPU devices:
name "486-v1-x86_64-cpu"
name "486-x86_64-cpu"
name "athlon-v1-x86_64-cpu"
name "athlon-x86_64-cpu"
name "base-x86_64-cpu"
name "Broadwell-IBRS-x86_64-cpu"
name "Broadwell-noTSX-IBRS-x86_64-cpu"
name "Broadwell-noTSX-x86_64-cpu"
name "Broadwell-v1-x86_64-cpu"

но более того. можно смотерть екакие опции парметры можно по железе указатьа

$ qemu-system-x86_64 -device qxl,help  <======
qxl options:
  acpi-index=<uint32>    -  (default: 0)
  addr=<int32>           - Slot and optional function number, example: 06.0 or 06 (default: -1)
  cmdlog=<uint32>        -  (default: 0)
  debug=<uint32>         -  (default: 0)
  failover_pair_id=<str>
  global-vmstate=<bool>  -  (default: false)
  guestdebug=<uint32>    -  (default: 0)
  max_outputs=<uint16>   -  (default: 0)
  multifunction=<bool>   - on/off (default: false)
  ram_size=<uint32>      -  (default: 67108864)
  ram_size_mb=<uint32>   -  (default: 4294967295)
  revision=<uint32>      -  (default: 5)
  rombar=<uint32>        -  (default: 1)
  romfile=<str>
  romsize=<uint32>       -  (default: 4294967295)
  surfaces=<int32>       -  (default: 1024)
  vgamem_mb=<uint32>     -  (default: 16)
  vram64_size_mb=<uint32> -  (default: 4294967295)
  vram_size=<uint64>     -  (default: 67108864)
  vram_size_mb=<uint32>  -  (default: 4294967295)
  x-pcie-extcap-init=<bool> - on/off (default: true)
  x-pcie-lnksta-dllla=<bool> - on/off (default: true)
  xres=<uint32>          -  (default: 0)
  yres=<uint32>          -  (default: 0)

===
showconsolefont
setfont ter-v24n

шрифт на стадии загрузки зашит в initramfs
а туда он поаадет от 
mkinitcp -H cosnolefont
а там наисано что шоитф бертя из vconsole.cfg
шриыт для консоли лежат в /usr/share/kbd/consolefont/

==
окзываетс есть 16 битныйй протокл загрузки ядра линукс
есть 32 быитный протокоол загрузки ядра линукс

===
grub
set pager=1
vbeinfo
==
граф настройки
qemu -device qxl-vga,id=video0,vgamem_mb=64,xres=1900,yres=1000
fbset = опзовялет посмртеть
video=1900x1000M@60
grub_gfxmode=1600x900x32
grub_gfxpayload_LINUX=....
grub_terminal_output=console
==
со шрфитами
mkinitcp -P
хук consolefont
читаем имя фонта из /etc/vconosle.cfg
грифты лжат в /usr/share/kbd/consolfeont
првроеть щас шрфит эт 
serfont ....
посмтеть текущий конльны шрифт это 
showconsolefont -i -v  -C ,,,,
==
по пводу qemu и виедокарт
как я пнял самая клаяаная видеокрта
это ели у ебя на буке две карты. иодну
из них ожно пробростить в виртуалку!
это будет саая ыстрая схема!
==
qemu aget позоволяет из libvirt
слтать комнду в ВМ
spixe agent позволяет иметь типа 
каоассуную граф связь с витуалкой
например мышка клсно рабоатет
видимо переход програзный от хсота
в вм

==
spice
их строка
qemu-system-x86_64 -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent

моя строка
qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -display sdl   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02  -device qxl-vga,id=video0,vgamem_mb=16

моя новая строка
qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02  -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent
==

virt-manager -c qemu:///session

==

libvirt

/usr/bin/qemu-system-x86_64 
-name guest=manjaro,debug-threads=on 
-S 

-object {
"qom-type":"secret",
"id":"masterKey0",
"format":"raw",
"file":"/home/vasya/.config/libvirt/qemu/lib/domain-2-manjaro/master-key.aes"} 

-machine pc-q35-6.2,usb=off,vmport=off,dump-guest-core=off,memory-backend=pc.ram 
-accel kvm 
-cpu host,migratable=on 
-m 2048 

-object {"qom-type":"memory-backend-ram","id":"pc.ram","size":2147483648} 

-overcommit mem-lock=off 
-smp 1,sockets=1,cores=1,threads=1
-uuid 3922d246-c833-437e-80b6-8ddea7a7538b 
-no-user-config 
-nodefaults 
-chardev socket,id=charmonitor,fd=29,server=on,wait=off 
-mon chardev=charmonitor,id=monitor,mode=control 
-rtc base=utc,driftfix=slew -global kvm-pit.lost_tick_policy=delay 
-no-hpet 
-no-shutdown 
-global ICH9-LPC.disable_s3=1 
-global ICH9-LPC.disable_s4=1 
-boot strict=on 
-device pcie-root-port,port=16,chassis=1,id=pci.1,bus=pcie.0,multifunction=on,addr=0x2
-device pcie-root-port,port=17,chassis=2,id=pci.2,bus=pcie.0,addr=0x2.0x1 
-device pcie-root-port,port=18,chassis=3,id=pci.3,bus=pcie.0,addr=0x2.0x2 
-device pcie-root-port,port=19,chassis=4,id=pci.4,bus=pcie.0,addr=0x2.0x3 
-device pcie-root-port,port=20,chassis=5,id=pci.5,bus=pcie.0,addr=0x2.0x4 
-device pcie-root-port,port=21,chassis=6,id=pci.6,bus=pcie.0,addr=0x2.0x5 
-device pcie-root-port,port=22,chassis=7,id=pci.7,bus=pcie.0,addr=0x2.0x6 
-device pcie-root-port,port=23,chassis=8,id=pci.8,bus=pcie.0,addr=0x2.0x7 
-device pcie-root-port,port=24,chassis=9,id=pci.9,bus=pcie.0,multifunction=on,addr=0x3 
-device pcie-root-port,port=25,chassis=10,id=pci.10,bus=pcie.0,addr=0x3.0x1
-device pcie-root-port,port=26,chassis=11,id=pci.11,bus=pcie.0,addr=0x3.0x2 
-device pcie-root-port,port=27,chassis=12,id=pci.12,bus=pcie.0,addr=0x3.0x3 
-device pcie-root-port,port=28,chassis=13,id=pci.13,bus=pcie.0,addr=0x3.0x4 
-device pcie-root-port,port=29,chassis=14,id=pci.14,bus=pcie.0,addr=0x3.0x5 
-device qemu-xhci,p2=15,p3=15,id=usb,bus=pci.2,addr=0x0 
-device virtio-serial-pci,id=virtio-serial0,bus=pci.3,addr=0x0 

-blockdev {"driver":"file","filename":"/home/vasya/.local/share/libvirt/images/manjaro.qcow2","node-name":"libvirt-2-storage","auto-read-only":true,"discard":"unmap"} 

-blockdev {"node-name":"libvirt-2-format","read-only":false,"discard":"unmap","driver":"qcow2","file":"libvirt-2-storage","backing":null} 

-device virtio-blk-pci,bus=pci.4,addr=0x0,drive=libvirt-2-format,id=virtio-disk0,bootindex=2 

-blockdev {"driver":"file","filename":"/home/vasya/Downloads/manjaro-cinnamon-23.0.1-230921-linux65.iso","node-name":"libvirt-1-storage","auto-read-only":true,"discard":"unmap"} 

-blockdev {"node-name":"libvirt-1-format","read-only":true,"driver":"raw","file":"libvirt-1-storage"} 

-device ide-cd,bus=ide.0,drive=libvirt-1-format,id=sata0-0-0,bootindex=1 

-netdev user,id=hostnet0 -device virtio-net-pci,netdev=hostnet0,id=net0,mac=52:54:00:42:ae:99,bus=pci.1,addr=0x0 

-chardev pty,id=charserial0 

-device isa-serial,chardev=charserial0,id=serial0 

-chardev socket,id=charchannel0,fd=27,server=on,wait=off 

-device virtserialport,bus=virtio-serial0.0,nr=1,chardev=charchannel0,id=channel0,name=org.qemu.guest_agent.0 

-chardev spicevmc,id=charchannel1,name=vdagent 

-device virtserialport,bus=virtio-serial0.0,nr=2,chardev=charchannel1,id=channel1,name=com.redhat.spice.0 

-audiodev {"id":"audio1","driver":"spice"} 

-spice port=5900,addr=127.0.0.1,disable-ticketing=on,image-compression=off,seamless-migration=on 

-device qxl-vga,id=video0,ram_size=67108864,vram_size=67108864,vram64_size_mb=0,vgamem_mb=16,max_outputs=1,bus=pcie.0,addr=0x1 

-device virtio-balloon-pci,id=balloon0,bus=pci.5,addr=0x0 

-object {"qom-type":"rng-random","id":"objrng0","filename":"/dev/urandom"} 

-device virtio-rng-pci,rng=objrng0,id=rng0,bus=pci.6,addr=0x0 

-sandbox on,obsolete=deny,elevateprivileges=deny,spawn=deny,resourcecontrol=deny 

-msg timestamp=on

==
получается virt manager юзает virt-view а оно бзает spice чтоы нам показывать дисплей виртуалкуи.
и это хуже чем -display sdl
дает задежкру и размтытая ккартинка
==
можнооднврременоп подключиться к вм через spice и sdl
==
чрез spice в гграф ржиме дункск  мышка летает круто. 
а вот через sdл мышка тормзит. поэтому тут spice вне конкуррекцнии
===
 а вот -dsiplay gtk
уже работает мышь охуенно. и спайс никкой не нужен!
==
конечночная хуййня что раоатет

qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02  -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent -display gtk --spice  disable-ticketing=on,image-compression=off,seamless-migration=on,gl=off,unix=on,addr=/tmp/spice.sock -device qxl-vga,id=video0,ram_size=67108864,vram_size=67108864,vram64_size_mb=0,vgamem_mb=16,max_outputs=1,bus=pcie.0,addr=0x1 

gtk + spice

==

пооходу -vga qxl это урощеннавея версия когда пишем 
-device qxl-vga,id=video0,ram_size=67108864,vram_size=67108864,vram64_size_mb=0,vgamem_mb=16,max_outputs=1,bus=pcie.0,addr=0x1 

тоесть второе это более подробное.
а оба сразу нельяз ошлет нахер

==
qxl vs qxl-vga = ?

=

$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02      -sandbox on,resourcecontrol=allow     -device virtio-mouse -device virtio-keyboard -device virtio-vga -display gtk,gl=on
vasya@thinkpad:~/VM/manj2$ 

граф режиме окей хотя и llvm
а текстовый хуйня


получается с qxl охуенная четкость в тесктомров режиме
2$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -vga qxl 

нов графичекомм хуйня  нрпимер нельзя поменять разрешение

а с virtiio размыто в тестоммвом но классно  в графическом
vasya@thinkpad:~/VM/manj2$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -vga virtio 

ввот так прям отлично в тектсом режиме
$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -device qxl-vga,id=video0,vgamem_mb=16,xres=1800,yres=900
даже в grub ненжн преедвать разрешение. он сам выставит

==
чужаястрочка
qemu-system-x86_64 -enable-kvm -boot order=c -drive file=storage/sda,format=qcow2 -m 6G -smp cores=2 -vga none -device qxl-vga,vgamem_mb=128 -spice port=5900,disable-ticketing -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent -netdev bridge,id=hn0 -device virtio-net-pci,netdev=hn0,id=nic1 -daemonize

===
аоискк кета по маске
pacman -Ssq <regex>

==

по деолту у amjaro нет драйвера X11 от карты qxl
есть только дравер какото там. 
поэтому кодга старутет x11 то юзает драйыер mendenso. чкототкте
нужно посвтитьдфрайфайр x11 и наптсать окнфинеогиг

pacman -S xf86-video-qxl

/usr/share/X11/xorg.conf.d/50-qxl.conf 

Section "Device"
Identifier "qxl"
Driver "qxl"
Option "ENABLE_SURFACES" "False"
EndSection

reboot

check /var/log/X11.log

нихера неопонятно ибо lspci риует что драйыер для qxl конечно есть сука

--
кк добавить spice

-device virtio-serial-pci,id=virtio-serial0,bus=pci.3,addr=0x0
-chardev spicevms,id=charchannel1,name=vdagent
-device virtserialport,bus=virtio-serial0.0,nr=2,chardev=charchannel1,id=channel1,name=com.redhat.spice.0

сранвим  с моей строчкой
-device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent   
 --spice  disable-ticketing=on,image-compression=off,seamless-migration=on,gl=off,unix=on,addr=/tmp/spice.sock

===
как  добавить qwmeu aagent

запустить виртулки вот тстакийи флгаами
-chardev socket,path=/tmp/qga.sock,server=on,wait=off,id=qga0 \
 -device virtio-serial \
 -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0


на ВИМ ставим паувет 

# pacman -S qemu-user-agent

запускаеслубу
# systemctl daemon-reload
#systemclt emable  qemu-user-agent  --now
#systemclt status  qemu-user-agent  --now

все должно гореить дещеленым


но устанволенный агент qemu и драйыер qxl для X11 все равно недает днамичреки менять разрегение раб сстола!
только через spice конект! а это хрень!
==
сторка и с qemu агентом и spice

 qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -device qxl-vga,id=video0,vgamem_mb=16,xres=1800,yres=900 -chardev socket,path=/tmp/qga.sock,server=on,wait=off,id=qga0  -device virtio-serial  -device virtserialport,chardev=qga0,name=org.qemu.guest_agent.0   -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent   --spice  disable-ticketing=on,image-compression=off,seamless-migration=on,gl=off,unix=on,addr=/tmp/spice.sock 

gl=off потому что иначе segmntaiotn fault

конект 
 remote-viewer spice+unix:///tmp/spice.sock

поеичем что дебиально. якобыы через spice клиент экран диначесичаски масштабирцетс. но это брехня.
если посмотеть через xrandr то разареение остатется прежним. !!! просто spice  делает zoom
тоесть все начинает раслыыватьсят!

==
олучается видеале вот так
в этой окманде задаем разленрешшнеие xres=1920,yres=990

$ qemu-system-x86_64 -name manj11 -m 2G   -boot d -hda ./manj.img  -drive file=manj.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm   -smp 1  -M pc-q35-2.11        -netdev tap,id=mynet0,ifname=tap1,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:02   -device virtio-serial-pci    -sandbox on,resourcecontrol=allow        -display gtk,gl=on  -device qxl-vga,id=video0,vgamem_mb=16,xres=1920,yres=990 -chardev socket,path=/tmp/qga.sock,server=on,wait=off,id=qga 

в груб ничего пропсиыать ненадо.
н и в принципе все. даже драйвер qxl можн не стаить.
ни qemu агента ни spice агента. нихрна это ненадо
===
основыне этапы:
разрешнеие экрана на grub
шрифт размер на загрузке
разрение экрана в текстовом режиме
spice ненужен
qemu agetnt ненеужен
3d openl ускорения нет.
прброс второй видеораты с бука в вм это я пока неумею
==

===
lxd
при поытыатке запцстить контйнер говорт ошел нахуй
manjaroo lxc newuidmap failed
или
Error: LXD doesn't have a uid/gid allocation.

# ls -1 /etc/sub*id
/etc/subgid
/etc/subuid


и вставить в них
vasyaa:1000000:1000000000

далее надо убедиться что /etc/lxc/ default.conf отсутсвтует

перзапускаем lxd
systemctl restart lxd

но в archlnux это еще не все только root может запусать конейнеры.
а чтбы не рут мог то 
тут читай 
https://wiki.archlinux.org/title/Linux_Containers  <===================== !!!

===
dnsmasq vs systemd-resolvd ?
====
arch+полная шифровка попробвать
===
как войти в нстйроки lxqt панели
одна хуйня про опен бокс про desktopall = no
вторая про поднырривание панели под окна
третье что окна со всех столов покзаывалист - как исправить


$ sudo apt install sysfsutils
~$ systool -m i915 -av
Module = "i915"

  Attributes:
    coresize            = "3883008"
    initsize            = "0"
    initstate           = "live"
    refcnt              = "39"
    srcversion          = "88E5C59BD440FED46FD060D"
    taint               = ""
    uevent              = <store method only>

  Parameters:

  Sections:

$ modinfo i915

чо это за хцйння?
$ 
vasya@thinkpad:/var/log$ cat Xorg.0.log | grep LoadModule
[  1419.434] (II) LoadModule: "glx"
[  1419.453] (II) LoadModule: "modesetting"
[  1419.455] (II) LoadModule: "fbdev"
[  1419.456] (II) LoadModule: "vesa"
[  1419.463] (II) LoadModule: "fbdevhw"
[  1419.465] (II) LoadModule: "glamoregl"
[  1420.253] (II) LoadModule: "fb"
[  1420.589] (II) LoadModule: "libinput"
vasya@thinkpad:/var/log$ 


===
немножко попробвать что такое генту?
=======
как wireguard работает с роутингом?
ip -c r sh table 0
=======


qemu запуск виртувлак через
командную строку с сетью
видеоконсолью либо пробросом serial   порта ( настройки grub и кернел и шрифтов ttyS0  терминала)

lxd запуск subuid subgid

настройука букв tty терминала ( шрифт включая рпзмер букв, ппереключение руский неруский язык, времкнная настройка постоянная , увязка initrd  и systemd,  что такое keymap,
systemd console-setup    сломан на убунту, dpkg reconfigure console-setup   и keyboard как он делает,  keymap tty консоли и xorg это две отдельные настройки localecto set-keymap и x11 -set-keymap,  в сухом остатке понять как  играть со шрифтами и языками для tty  консоли . что такое кеймап.  размер меняь умею а язык нет , переключатель менять языка нет ,  кеймап консоли незнаю что делает.  увязка настроек  когда ос уже загружена    и запись этих же настроек в initrd. )

настройки  клавы в tty  и в режиме  xorg это две отдкльные незавимимые истории




авария- понять что сломал той командой тоесть понять keymap.
аонять как исправить когда сломал,
grub -  работа в rescue shell а именно как 
монтирование luks раздела чтобы он стал виден из граб шелла,  граб модули  куда он их сохраняет ведь /boot/grub недоступен он на люксе лежит и что они дают,
запуск линукса руками из  grub rescue shell когда нет grub.cfg вналичии а линукс загрузитть надо,  аварийный шелл линукса.  как им пользоваться когда нужно найти  "/" раздел линукса.
активиповать доступ по ssh между буками.

--
граф режим это 
окно логина 
панель задач внизу
оконный менеджер
вот что нужно чтобы заработал граф режим.
до этого цровнем ниже драйвер видеокарты и настроенный запущенный xorg service


бэкап нужен обоих буков и посекторный чтобы  восстановииь на тот же бук
и файловый да еще несколько экзмепляров может даже и в дигитал оушн засунуть

почему через граб+кернел нкльзя поменять кеймап?

если есть файловый бэквп машины на luks+lvm как ее вручную  перераьотать чтобы ее запустить скажем наивиртуалке или дигитал оушн без лукс и лвм.



lxd виртуалки делает через qemu а  контейнеры через  lxc.
тоесть точто создано lxd должно быть видно чепещ инструменты qemu и lxc  инастройки должны через них успешно меняться

про граб. вощможно когда диск незашифрован то граб в шелле имеет больше команд.
потомучто он возможно считывает с диска модули?
или надо модули указывать при установке граба и тогда он их записывает (куда?). надо посмотреть мой thinkpaf какое имеет разбиенте по разделам. какие разделы незашиырованы и как там на незашфированеых разделах лежит  граб.


как можно с livecd  ввести паррль и примонтрировать раздел загиырованный люксом


subuid subgid наверно относятся к .usernamespace. когда юзер в этом спеейсе имеет свой uid авдругом спейсе другой а бзер тотже


надо создать раздел.
нанего засунуть толко vmlunuz
и initrd ( зачем оно нужно? а если ядро сонолмт оно нужно? там шрифт консольный длявывода звгпузки и дрова от контролоера дисков). прлучается в ядре нет шрифта ниодного.
так вот сощдать раздел и там засунуть только vmlinuz ibitrd и sh и все и попробовать это загрузить  граьом. а граб поставить отдельно с livecd

ядро просто так незапустмтся.
его надо полрдить по определенному адресу и полготовить всяко разно
и только потом запускать его.
пожтому граб должен быть очень умный. он дроден умкть много из того что умеют ядпра. он долден уметь раьотать с желещом. например иметь драйвер контроллера дискоа и понимать ФС. ему нало найти диск, фс, и файлы. это много чего умение значит
ращные клавы они разнве сканкоды на одну кнопку посылают? а если нет нахуй кейкоды нужны.
шрифт это связь кейколов и глифов? клааа - ядро драйвер клавы-  баш- ядро линия дисципоина - ядро видеодрайвер
что ядоро шлет башу после нажатия кнопки? кейкод?
шрифт нужен для вывода для ваода нет.
что вюзер приложение поступает от ядра от нажатия кеопки? кейкод? а utf-8 кодировка причем тут?

локале она от x11 зпвтсит?
поменять локале. посмотреть вывод времени или чисел.

кеймап это связь кейколов с чем?
iso8859-1 это что?


в ядре есть шрифьы нафиг тогда шрифт есть в initrd?  заглянуть в initrtd чотоам есть и зачем

сощдать файльс utf-8 именем чепещ си и баш?




=======
  <<<<<<<<========
  <<<<<<<<========
AVARIYA

разобраться с ебаной аварией
надо активироватьт чтобы по ssh можно было зайти с компа на комп
на такой случай!

firewall провермть что все порты закрыты на обоих нотубках!

interrupts  timerы
jiffy/tickless ядра

NetworkManager описание

==

как посмотреть все железки котоыре есть в компе.
почти все железки в компе сидят на pci шине 
поэтому можно запустиь 
    $ lspci

фишка в том что если ты pci желека то можно сделать спец запрос по шине и ты обязан откликнуться.
поэтому если в линуксе нет дрвайверов от железки то она все равно будет покзаана 
в отклике lspci!

нов компе есть нетлоко pci шина но isa шина или ее некий аналог. 
там тоже могу сидть isa pnp железки. дальгше непонятно. отклиаются ли  они на lspci 
или нет.

в итоге есть странынй ммонет 
вот железкт которые поукывывает lspci

d$ lspci
00:00.0 Host bridge: Intel Corporation Xeon E3-1200 v3/4th Gen Core Processor DRAM Controller (rev 06)
00:02.0 VGA compatible controller: Intel Corporation 4th Gen Core Processor Integrated Graphics Controller (rev 06)
00:03.0 Audio device: Intel Corporation Xeon E3-1200 v3/4th Gen Core Processor HD Audio Controller (rev 06)
00:14.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB xHCI (rev 04)
00:16.0 Communication controller: Intel Corporation 8 Series/C220 Series Chipset Family MEI Controller #1 (rev 04)
00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I217-LM (rev 04)
00:1a.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #2 (rev 04)
00:1b.0 Audio device: Intel Corporation 8 Series/C220 Series Chipset High Definition Audio Controller (rev 04)
00:1c.0 PCI bridge: Intel Corporation 8 Series/C220 Series Chipset Family PCI Express Root Port #1 (rev d4)
00:1c.1 PCI bridge: Intel Corporation 8 Series/C220 Series Chipset Family PCI Express Root Port #2 (rev d4)
00:1d.0 USB controller: Intel Corporation 8 Series/C220 Series Chipset Family USB EHCI #1 (rev 04)
00:1f.0 ISA bridge: Intel Corporation QM87 Express LPC Controller (rev 04)
00:1f.2 SATA controller: Intel Corporation 8 Series/C220 Series Chipset Family 6-port SATA Controller 1 [AHCI mode] (rev 04)
00:1f.3 SMBus: Intel Corporation 8 Series/C220 Series Chipset Family SMBus Controller (rev 04)
03:00.0 Network controller: Intel Corporation Wireless 7260 (rev 6b)
vasya@thinkpad:/etc/NetworkManager/conf.d$ 

а вот желзк котыоер мокзывает interrrupts
$ cat /proc/interrupts 
           CPU0       CPU1       CPU2       CPU3       
  0:         22          0          0          0   IO-APIC   2-edge      timer
  1:          0        837          0          0   IO-APIC   1-edge      i8042
  8:          0          0          0          0   IO-APIC   8-edge      rtc0
  9:          0     145335          0          0   IO-APIC   9-fasteoi   acpi
 12:        175          0          0          0   IO-APIC  12-edge      i8042
 16:         31          0          0          0   IO-APIC  16-fasteoi   ehci_hcd:usb2
 18:          6          0          0          0   IO-APIC  18-fasteoi   i801_smbus
 23:          0          0          0         35   IO-APIC  23-fasteoi   ehci_hcd:usb1
 26:     353800       9199          0          0  PCI-MSI-0000:00:1f.2   0-edge      ahci[0000:00:1f.2]
 27:          0          0          7      59149  PCI-MSI-0000:00:19.0   0-edge      enp0s25
 28:          0          0          0     326998  PCI-MSI-0000:00:14.0   0-edge      xhci_hcd
 29:          0        285     742049          0  PCI-MSI-0000:00:02.0   0-edge      i915
 30:          0          0         71          0  PCI-MSI-0000:00:16.0   0-edge      mei_me
 31:          0    1033652          0        160  PCI-MSI-0000:03:00.0   0-edge      iwlwifi
 32:        246          0          0          0  PCI-MSI-0000:00:03.0   0-edge      snd_hda_intel:card0
 33:          0       2150          0          0  PCI-MSI-0000:00:1b.0   0-edge      snd_hda_intel:card1


например на компе есть таймер который сидит внутри IO-APIC микрсоххемы. 
но мы его  в lspci не увидим. а ведь это тоже лежезка.
поэтому тут непонятно. как же нам посмотеть ВСЕ железки внутои комп сидящие.

IO-APIC это контолллер внутри котрго в частности есть таймер.который юзает комп при загузке.
вообще ядру очен унужен источник часов. 
аесть LOCAL APIC он уже внутри ядра цпу. в /pric/interpprups он показан в строке LOC

LOC:   19143350   15579364   16815023   15044160   Local timer interrupts

причем  в ней зашифровнаы все таймеры кроме того что сидит в IO-APIC

поэтому с спсоком железок на компе непняо. как его получить полный.
но точно изветно что lspci покжет ВСЕ желеки сдящие на PCI шине даже если у ядра нет 
доайеров от этой железки

еще прикол в том что номер интрата котоырй покзывает /pric/interpapts 
и lspci 
это не всгде дно и тоже

/proc/interrupts and lspci may show two different values because they are displaying different things.  SOMETIMES they are the same, but not always.

This is because the numbers obtained from the system irq vector should be considered a "cookie" value.  In the case of legacy ISA interrupts, the cookie is the same as the vector.  In the case of MSI/MSI-X, the assignment is a bit more arbitrary.

As such, the irq vector slot is not the same thing as the value being programmed into a PCI device's register.

Furthermore, the PCI device register may not reflect updates from quirks and fixups, so pdev->irq may differ from the PCI device register value in uncommon cases.

So:
1) /proc/interrupts displays a platform-specific, CPU-specific enumeration of the system's irq vectors.
2) lspci displays PCI device register values.

While sometimes the values will be the same, there is no guarantee



в завсиимости от флага в lspci он может покзываеть "реальный " номер IRQ 
а может покызвать "вируталный " номер irq. как я пнял рельрный это релаьный а виртуальный этот
который думает железка сама у нее есть. тоже хуй понятно.

==

lxc launch  local:f1dd0e76efe8  cont1  --vm  -c limits.memory=512MB  -c limits.cpu=1

lxc exec cont1 -- bash

стаивим containerd      (https://www.techrepublic.com/article/install-containerd-ubuntu/)

wget https://github.com/containerd/containerd/releases/download/v1.6.8/containerd-1.6.8-linux-amd64.tar.gz




==

на теелфоне у меня открыта ккуча чайтов посвязенщеных keymap клавиутуры.
их надо все перенести на комп
===
хрени которые я изучаю щас : 
  авария (grub,luks,kbd keymaps)
  qemu 
  kbd keymaps, \
  jiffy + interrutps+ разные вид IDLE режимов ядра,
  NM(_susyemd+netwotkd),

==
wiregiueard
я так и непонял как вайргард работает связь.
оно это делает через катомную табрлицу маршутизации. 
но как сука это в итоге то работатет?!?!?!!?

==
$ touch  $'\u2234\u2192\u263f\u2605'.txt
ssh.txt:$ ls -1 | grep  $'\u2234\u2192\u263f\u2605'
[ LENOVO ]$(&) strace -e execve touch  $'\u2234\u2192\u263f\u2605'.txt 
execve("/usr/bin/touch", ["touch", "\342\210\264\342\206\222\342\230\277\342\230\205.txt"], 0x7ffcde5c6038 /* 73 vars 

===
systemctl --user ....
чо за хрень.
https://wiki.archlinux.org/title/Systemd/User

===
bash PS1 дописать 
и в стековерфлоу выложить свой приколный вариант с PS1


PS1=' $(printf "\U0000$(   echo "obase=16;$(($RANDOM % 250))" | bc  )$(   echo "obase=16;$((50+($RANDOM % 200)))" | bc  )") '
ss

==
ращбираюсь  с локалбю locale1.txt

==

        файл sysfs2.txt
e
!!!!!
дописать 
         ssh+bash.txt  про разобрться вконце
         jiffy.txt jiffy про USER_HZ и CONFIG_HZ 
         locale1.txt про locale
         udev.txt про udev
         lxd.txt про LXD unix socket "/var/snap/lxd/common/lxd/unix.socket
         sysfs2.txt   про fan_mode и про LPC и про то как узнать установен ли 
          драйвер для железки
         попробовать загрузку новго ядра через kexec !
         файл grub2+initrd.txt про то как работает загрузка линукса 
         разобраться ((https://unix.stackexchange.com/questions/765565/starting-qemu-as-another-user))  
         что такое mount move ? например mount -n -o move /run ${rootmnt}/run

==
надо провереть на финкпаде что модуль граба usbkeyboard
реально отвечает за то чтобы кнопки вводить с usb клавы чтобы она работала
==
леново. загрузить новое ядро чтобы проверить /sys/class/..../VBC 24 
который позволяет регулировать работу вентилятора . потому что на ядре 5
он нихуя неделает как надо

==
по дефолту докер пробрасыавет stdout и stderr на хост. 
для этого ненущжно ниакких доп ключей

еси мы добавлыем -i то еще пробратывает и stdin с контнера на хост

пруф
docker run --name t1 busybox sleep 2
$ docker inspect t1 | grep -i std
            "AttachStdin": false,
            "AttachStdout": true,
            "AttachStderr": true,
            "OpenStdin": false,
            "StdinOnce": false,

            
==


почему если запустиьт docker -itd то все что конейер пишет на stdput оно 
есть в docekr logs
а если docker -d
то в docker logs ничего нет

==

где докер хранит логи контейнера?
смотрим в 
# docker inspect 129 | grep Log
        "LogPath": "/var/lib/docker/containers/cf2be129a981d006913759fc06cc954f8da718e257a808a1c1ffe4eb02c1da33/cf2be129a981d006913759fc06cc954f8da718e257a808a1c1ffe4eb02c1da33-json.log",

значит в /var/lib/docker/container_id/*.log

проверяю
# cat *.log
{"log":"SIGTERM is caught....shutting down\r\n","stream":"stdout","time":"2024-04-26T15:01:11.293692941Z"}
{"log":"SIGTERM is caught....shutting down\r\n","stream":"stdout","time":"2024-04-26T15:01:53.626111287Z"}
{"log":"SIGTERM is caught....shutting down\r\n","stream":"stdout","time":"2024-04-26T15:07:15.833573819Z"}
{"log":"SIGTERM is caught....shutting down\r\n","stream":"stdout","time":"2024-04-26T15:08:11.797026673Z"}
{"log":"SIGTERM is caught....shutting down\r\n","stream":"stdout","time":"2024-04-26T15:08:30.999712198Z"}

десвтиетно!

а где докер хранит фс которую он монтирует внутро контейнера?


# docker inspect 129 | grep MergedDir
                "MergedDir": "/var/lib/docker/overlay2/7134eb1f1b2ae32c36e614035102fce26f4d096fe274d554279ed74cb8365450/merged",

тоесть в /var/lib/docker/overlay2/...





==

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
когда ктото (процесс юзерский или ядро его какойто кусок) шлют сигнал процессу
это значит что другой кусок ядра в свойствах процесса вносит пометку о так
назыаемом сигнале. это приводит к тому что третий кусок ядра шедулер когда доходит
до этого процесса вместо того чтобы на цпу совать код этого процесса сует на цпу 
обработчик этого сигнала




---

как докер стоит контйенер. он шлет процессу запущенному в контейнере сигнал SIGTERM.
потом ждет 10с. если процесс все еще не сдох то он шлет сигнал SIGKILL
так вот вопрос - если у нас контенер сидит в своем pid неймспейсе то понятно что 
легко понять какому процессу нужно слать сигнал ==> pid=1
а если процесс (контейнер) сидит в pid namepsace друогого контейнера. то наш
процесс который крутится в контейнере уже имеет хрен знает как pid. как тогда 
докер выкрчитвается?

--
если в контейнере есть несклоько процессов. мы нажали docker stop ID
то головной 

--
процесс с pid=1 имеет такие дефолтовые хендлеры что они игнорирует все сигналы. 
даже SIGKILL. и только если код этого процесса имеет свои кастомные хендлеры
тогда посылка сигнала таому процессу приведет к успеху. кстати прикол еще в том
что для sigterm\sigint итп можно напсать кастомные хндлер а для sigkill по прежнему
нет. 
также если запустить
bash в качесвте pid=1 то он среагиурет на сигнал. а если systemd то вивдимо пошлет нахер.

--







$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

про сигналы
вот скрипт

~# cat 01.bash 

pid=$1
cat /proc/$pid/status|egrep '(Sig|Shd)(Pnd|Blk|Ign|Cgt)'|while read name mask;do
    bin=$(echo "ibase=16; obase=2; ${mask^^*}"|bc)
    echo -n "$name $mask $bin "
    i=1
    while [[ $bin -ne 0 ]];do
        if [[ ${bin:(-1)} -eq 1 ]];then
            kill -l $i | tr '\n' ' '
        fi
        bin=${bin::-1}
        set $((i++))
    done
    echo
done



натрвлаиеи нп процесс и видим вот такое

# ./01.bash 1
SigPnd: 0000000000000000 0 
ShdPnd: 0000000000000000 0 
SigBlk: 0000000000000000 0 
SigIgn: 0000000000001000 1000000000000 PIPE 
SigCgt: 0000000180000a00 110000000000000000000101000000000 USR1 USR2 
root@7dcb5e2d2540:~# cat 01.bash 





методом провекри я  пришел к выводу что те сигналы которые указаны в стркое
SigCgt:
для них в коде программы прописаны кастомные хендлеры!
напрмиер эта строчка
SigCgt: 0000000000006002 110000000000010 INT ALRM TERM
означает что у процечсса есть три кастмоным хендлера. для INT, ALRM, TERM



$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$



<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

некий неразобранный кусок


docker
получется почемуто если docker -d то то что срет на stdout прцоесс не видно в 
docker logs
а если -dit то видно
почему?




еще раз для себя открыл вот что. если у нас код
возврата процесса больше 128 это напрямую 
укзывает что процесс был убит снаружи сигналом. 
номер сигнала можно узнать как $exit_code-128
анмреир если код возарата 137 значит поцесс был убит
сигналом 137-128=9 
смотрим в kill -L
и видим что 9 это сигнал SIGKILL!

==
еще прикол

# docker inspect nginx:latest | jq '.[].Config.StopSignal'
"SIGQUIT"

в самом имадже зашито какой игнал докер оолжен посылать в процесс
по команде

docker stop !

===
в итге я вот к чему пришел.
у нас есть процесс. ему шлют sigterm. если у процесса нет своего обработчкиа. 
тогда ядро заупсукает свой дефолтовый обработчик. и практическо мгновннео процесс будет уничожен.
дефолтовый обрабочтки хранится в ядре. 
далее мы запускаем тот же процесс в докер контенере. натрваливаем тот же sigterm
но при этом нихрена не произодет. а почему? а потому что ели процесс имеет pid=1 
и не имеет своего обарчоика то дефтолотовый обарботчки лдя pid=1 равен нихрена не делать!
пэтому если процесс в контейнере имеет pid<>1 и мы натрваим на него sigterm то он 
подхднет также быстро как и вне контйенера! а если он pid=1 то нихнера ядро делать небудет!
как можно узнать что упроцесса есть кастмнй обраюочтик для SIGTERM?
надо узнать пид процесса и натрвить сркитпт

pid=$1
cat /proc/$pid/status|egrep '(Sig|Shd)(Pnd|Blk|Ign|Cgt)'|while read name mask;do
    bin=$(echo "ibase=16; obase=2; ${mask^^*}"|bc)
    echo -n "$name $mask $bin "
    i=1
    while [[ $bin -ne 0 ]];do
        if [[ ${bin:(-1)} -eq 1 ]];then
            kill -l $i | tr '\n' ' '
        fi
        bin=${bin::-1}
        set $((i++))
    done
    echo
done


он покажет всяко развно но нас интерсует строчка с "SigCgt"
SigCgt: 0000000180000a00 110000000000000000000101000000000 USR1 USR2

если в ней справа мы не видим TERM значит у процсса не своего кстмоног обаоктика для TERM!

самая жрпа остояит вот том что строка с SigCgt вылядит тоно также если ьы ее сморш из 
неймсейса хста либо из контйенера!

длае я вычснил на освное этой статьи (там прогрмма на C) https://www.codequoi.com/en/sending-and-intercepting-a-signal-in-c/#:~:text=In%20order%20to%20block%20a,to%20a%20dedicated%20function%2C%20sigprocmask%20.

что вот эта строка

SigBlk: 0000000000000004 100 QUIT
она означает что мы программе сами руамми заблокировали такие то сигналы.
а вот эта строка 
ShdPnd: 0000000000000004 100 QUIT
означает что сигнал прилетел но так как он бликрорван то стоит и ждет

из этго я хочу сказать что из этих строк
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 7be3c0fe28014a03
SigIgn: 0000000000001000
SigCgt: 00000001800004ec
мы никогда не увидим ничего про деолтовые хендлеры яра!

The following is the field definition from Linux man proc(5).

SigPnd, ShdPnd: Number of signals pending for thread and for process as a whole (see pthreads(7) and signal(7)).

SigBlk, SigIgn, SigCgt: Masks indicating signals being blocked, ignored, and caught (see signal(7)).


что интерсно для pid=1 я поыалают сигналы но при этом даже в SndPnd и SigPnd 
все равно остается пусто!

что осатетя непонятным - если зайти изунри контейнера то даже  kill -SIGKILL 1 
не сработает. но! если снаружи попробвать kill -SIGKILL 1212 то уже срабатвыает !
тоесть надо попроват создать руками +1 pid namespace. заупсить там процесс 
у котрого нет ни одного кастомного хенделала. и оттуда изнутри его грохнуть поровать. 
проверить что sigkill инути не работает. а снаоужи рабтает!
и девйсивтельно япрверил так и есть что из егоного неймспейса sigkill нераатебоаатет.
а из неймсесйса хоста хотя sigetrm тоже нерабрие ер sigkill уже рабаитеет
и ккстати убийство pid=1 походу автоматом уничтожает все соталыне процессы. 
поход уничожение pid=1 ывзвыает то что ядро все соталыне прцоссы автмоато уивает через 
sigkll!! а какже зомби получить? надо чтобы pid=1 был прцесс без SIGCHLD. чтобы он
заупстил скажем жинкс. а тот запустил своих чайлодов. потом глолвной жинкс биваем
у нас получается pid=1 и чайлды. потом мы чалда стопим. и он висит как зомби. 
но если мы pid=1 грохнет то ядро это зомби тоже навенрно грохнет?
вроле бы в этой сттье я нашел что что если у нас есть pid namesapce от котооошо
был рожлоен наш новый неймспейс то из предка можно послать в новый неймспйес SIGKILL
даже pid=1. что и обьясняет почему иунтри в пил=1 сигкилл не послать а снаружи с хоста
очень даже послать!

походу никто никгда не думал из какого нйеспейса докер удаляет процессы. 
ели бы он жто делал изунти то он бы замучался оперляеть под каким номер там процесс
крутится. он это делает снаружи. тога вознивакт вопорс  а как тогда исчезают все 
другие процессы которые там крутися? они поож=ходу об этм н задумылась. их удадяет не докер.
из удаляет само ядро. из за того что убили pid=1 

походу никт не заудмвался толком как в конйетенер процессы все исчезают.

получается веселухаю если ест 5 онтейнейров они делят 1 pid. мы в этом pid удаляем 
pid=1 то по идее ядро должно тогда убить все пцрцоецсы и аким обраом отсавноить всю групу
контерерв. тоесть грохнуть весь под?

==
пооходу unsahre --net это сопособо осздать новый сет неймспес "плохим способом"
==
из статьи 
(https://lwn.net/Articles/532748/)
PID namespaces implement some analogous behavior for the namespace-specific init process. Other processes in the namespace (even privileged processes) can send only those signals for which the init process has established a handler. This prevents members of the namespace from inadvertently killing a process that has an essential role in the namespace. Note, however, that (as for the traditional init process) the kernel can still generate signals for the PID namespace init process in all of the usual circumstances (e.g., hardware exceptions, terminal-generated signals such as SIGTTOU, and expiration of a timer).

Signals can also (subject to the usual permission checks) be sent to the PID namespace init process by processes in ancestor PID namespaces. Again, only the signals for which the init process has established a handler can be sent, with two exceptions: SIGKILL and SIGSTOP. When a process in an ancestor PID namespace sends these two signals to the init process, they are forcibly delivered (and can't be caught). The SIGSTOP signal stops the init process; SIGKILL terminates it. Since the init process is essential to the functioning of the PID namespace, if the init process is terminated by SIGKILL (or it terminates for any other reason), the kernel terminates all other processes in the namespace by sending them a SIGKILL signal.

Normally, a PID namespace will also be destroyed when its init process terminates. However, there is an unusual corner case: the namespace won't be destroyed as long as a /proc/PID/ns/pid file for one of the processes in that namespaces is bind mounted or held open. However, it is not possible to create new processes in the namespace (via setns() plus fork()): the lack of an init process is detected during the fork() call, which fails with an ENOMEM error (the traditional error indicating that a PID cannot be allocated). In other words, the PID namespace continues to exist, but is no longer usable.

это лянсятея еопочему из pid namespapsce мы нне можем kill а из пранета момжем!

==

я не могу понять как работат в новом pid namespace имея при этом старый mount namepace!

-=
что интерсно wait и waitpid() они останавлиавются выполение программы и ждут 
пока от чалйда не прилеит код возврата. поэтому можно убивать чайлдов даже
без всяких хендлеров. правада при этом основаной парент процесс будет стоять.
а так приколноэ
waitpid ждет серти конкретнго pid чайлда
а wait ждет смерти любого первого смерти чайлда
==
вот у нас есть php-fpm
и он обращается к базе данных и база не отвечает она
загружена. как при этом будет выглядеть этот проецесс php-fpm ?
он будет на 100% загружен по цпу? или он будет в состоянии S ?
или он будет в D состоянии? как он будет себя вести?
==
заадали вопрос - берем браузер опишите что просходит когда мы вбили в нем
адрес. тут надо не вестисиь и думать про бразуер что это не хром это 
нам ни к чему. нужно думать что браузер это любой просто текстовый браузер
например тот же самый curl ! и тогда станвится все просто как оно дальше работает

значит я для начала посмотреть как работает ping. потому что то как он 
работает это уже очнь много от того как работает браузер.
из ттго что я увидел - юзер программа делает запрос к ядру и получает
адрес dns сервера. потому юзер программа через сисколл делает запрос 
резолвинга dns имени в запросе в ip адрес. когда юзер программа получила
ip адрес. то она отркывает сетевой сокет через ядро указывая там ip адрес
куда мы конектимся. ядро выаолняет сетевой конект (syn\synack\ack установление
tcp конекта) который для юзер процесса невиден. это внутрнуенняя грязная хрень
которую делает ядро. юзер процесс получает дескпритор. в который юзер
процесс может писать читать. и там далее как то происходит работа с этим
сокетом чтобы "сделать" пинг. так вот браузер (типа даже curl) он просто
напрсто начинает пихать в этот дескпритор текст обычный сраный текст
в формате языка HTTP.  то есть процесс начинает пихать в дескритор текст.
и принимать текст. вот нахрен и все как работае этот ебаный бразуер

==
задали вопрос чем HTTP отличется от HTTPS 
как у нас HTTPS работает в подрбностях
==

==
как у нас происходит созание нового pid namepsapce. через сискол clone()
это значит что у нас есть процесс. мы из него вызываем clone() тогда ядро клонирует 
наш процесс 

закончил на том что процесс клонирует себя при этом клон уже оказыатся в другом pid namespace
но '/proc ' остается прежним поэтому процесс видит proc того процесса. а чтобы ему
увидить свой проц ему надо смогтировать proc самому в друую папку.  а почему на отмнотирвать ту?
а потому что тот proc исползется другими процессами котрые лежат в исхнодм неймсейсе. а вот
если мы еще и маунт неймспейс клогировали то мы можем спокойно отмонтроват тот проц и 
смонтировать свой!

в парент неймсейсе у нас будет виден unshare и его чайлд bash
а в дочернем pid namesapece будет виден только bash. 


==
прогармаа из книши clone( с флагами NEWNS) а на практкие напрмиер umshare 
делает по другому. онаделает вызов unshare а потом fork

==
надо еще поднять что дает новый маунт неймспейс аотому что он в оличиие от 
ноого сетвого нейсейса или говго пид неймпейса недает новые диски. так а
 что он дает ?

 # unshare -f --pid --mount  --propagation=private --mount-proc=/proc  /opt/134.exe 
parent: parent PID=1...
parent: child PID=2...


# strace -f -e clone,fork,execve,unshare  -p 12027

clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f892ac3ca10) = 12788
strace: Process 12788 attached
[pid 12788] execve("/usr/bin/unshare", ["unshare", "-f", "--pid", "--mount", "--propagation=private", "--mount-proc=/proc", "/opt/134.exe"], 0x56399fec4af0 /* 11 vars */) = 0
[pid 12788] unshare(CLONE_NEWNS|CLONE_NEWPID) = 0
[pid 12788] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7a34fd7a10) = 12789
strace: Process 12789 attached
[pid 12789] execve("/opt/134.exe", ["/opt/134.exe"], 0x7fff6dc9beb8 /* 11 vars */) = 0
[pid 12789] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f7d4e8c1a10) = 2
strace: Process 12790 attached
[pid 12790] +++ exited with 0 +++
[pid 12789] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=2, si_uid=0, si_status=0, si_utime=0, si_stime=1} ---

баш форкается и в этом дочернкм процессе запускает exwcve с программной /usr/bin/unshare 12788
этот unshare запускает сисколл unshare c фланами CLONE_NEWNS|CLONE_NEWPID
CLONE_NEWNS= это новвй маунт неймспейс
CLONE_NEWPID= это новый пид неймсейс.
это мнгновенно этот процесс пеереводит в новый маунт неймспес. 
а что касатеся пид неймспейс то он осздается но этот процес к нему не переключается.
так задуман пид нейспейс. только теперь дети этго процесса попадут в новый пид 
неймспйес. 
поэтому когда unshare делет clone+execve для 134.exe 127889 то он уже нахрится и в 
новом маунт неймспейсе и в новом пид неймсепйсе. опять что интерсно что он при этом
наърится и в старом нейспейсе с точеи зрения родиетлсьного процесса. 
а далее кода 134.exe тоже делает форк то новый прцоесс134.exe 12790 тоже ественно
нахрлися в новмо маунт нейсмейсе и новом пид нейтсмесе. итооо


bash - старый маунт нейсмпейс, старый пи нейспейс
  \
  unshare  новый ммунт нейспейс, сьарый пид гейспейс
    \
     134.exe новый маунт нейспейс новый пид нейсмейс
      \
       134.exe новый маунт нейспейс новый пид нейсмейс
     
 запускается unshare и он делает сисколл unshare. этот сисикол помещает ээтот процесс
 в новые нейспейсы (кроме случая pid неймспейс. в него будет поемещен только дочерний прцоесс)
 далее если програма unshare без ключа -f запущена то она замещает себя той програмооной
 которая у нее указана скажем 134.exe тоесть процесс unshare.exe преварщается в процесса
 134.exe значит у него будет новый маунт нейсмекйс но старый пид нейспейс. 
 и только у чайлда 134.exe будет новый маунт и новый пид нейспейс. поэтому елси 
 мы хотим ккую то программу запустить в новом пид нейсейсе то обязательоно адо 
 юзать unshare с ключом -f . чтобы unshare процесс остался в старом пид нейспйемпейсе
 а наша прогарма уже попада в новый нейсийпеййс. 

 еще раз как рабоатет /usr/bin/unshare без ключа -f
/usr/bin/unshare ... /bin/bash:
  12788 (номер процесса) /usr/bin/unshare ---> запускает сисколл unshare (CLONE_NEWPID) --
  --> execve (/bin/bash) ----> 12788 /bin/bash в старом пид нейспейсе 
  тоесть процесс 12788 в котормы был  бианарник /usr/bin/unshare
  превращается в процесс с бинаркником /bin/bash и причем в старом pid нейспейсе. 
  а вот уже его дети они будут запускать в новом пид нейспейсе. 
  это значит что родиетель их видит. можетт им сигналы посылать. а дети родиетеля
  уже не видят. баш имеет такую моду после старта еще создать кучу детей. дети 
  делают всякую вспомогатеьную шнягу а потом они подыхают. получается 
  очень нехорошая картина. 

  есть головной баш. он запускает дочку. он видит дочку а дочка его нет.
  дочка делает свои дела и подыхает. что интерсно SIGCHLD от дочки прилетает к родителю. 
  потому что для роиетьского прцоесса дочка все равно лежит в том же пид нейсейсе. 
  это для дочки не суествте родиетля. ха ха. это значит что роедиетьль может запустить
  хендлер SIGCHLD и выполнить wait(). и значит ядро может коректно завершить дочерний 
  процесс. тоесть дочка при номрально хендлере SIGCJLD родилетя не будет висеть в Z статусе.
  а вот если родеитлье бех хенжнрднлра то будет!(проверить) тесть чьоюы процсс в своем
  пид нейспейсе могут закить работу обязаельно нунжно чтобы ее рдиель из родиелсьнкоого
  нейспейса выполнил wait(). иначе дочка будет всиесть в своем нйеспсе в статусе Z !
  тоесть ядро просто так нахаляву не будет ее вычищать из Z состтояия. нихуя.
  пусть родель име хенле SIGCJLD. все дочка в итоге стерта из ядра
а    дочка в свом нейспейсе имела pid=1 , и получается что в соем пид нейспейсе
исчез процесс pid=1 это ядур совсем не нраится. и тоогда припоыатке создать новый 
проеас в этомновоновом нейспейсе ядро недаст! оно скажет нет памяти! хаха. так
просходит при запуске bash через unshare без ключа -f. !

~# unshare --pid  /bin/bash
bash: fork: Cannot allocate memory 

к проблема с пмтятью это не имеет нкиакго отноения! это просто ядро недает создать новый
прцоесс. еще как это получается. запускется процесс /usr/bin/unshare он делает сисколл unshare
с ключом CLONE_NEWPID. это дает то что ядро создает новый пид нейспейс но ядро не переводит
текущий процсс в этот пид нейспейс (такова архитекртура работы с пид нейспейс у ядра).
но если текущией процесс создаст дочерний процесс то его уже ядро поместит в новый пид нейспейс.

   unshare (12788 -номер процесс)  - старый пид нейспейс

далее 12788 делает execve(без форк!) и ядро заменяет /usr/bin/unshare на  /bin/bash
поэтому мы получаем 

   bash (12788 -номер процесс)  - старый пид нейспейс

теперь баш (он так устроен) пордждает свой дочерний проесс 12789 

и вот уже его(дочерний процесс) ядро сует в новый пид нейспейс. это значит кстати что 
этот новый процесс он как бы одновременно сидит в двух пид нейспейсах (ебануто придумали).
для парент процесса дочерний процесс сидит в старом нейспейсе. и парент процесс может 
слать сигналы к дочеренему. и ядро будет обратно слать автоматом SIGCHLD к паренту. 
одновременно с этим дочерний процесс уже никкого не видит. он видит только себя в новом
пид нейспейсе. о родителе он не догадываетя. родителем у него назначен pid=0 тоесть
никто. 

  bash (12789) - новый пид нейспейс.

 рисую цепочку

старый пид нейсмейс
 bash(12788) ---- bash (12789)

для парента 12788 для него дочка выгляит как 12789.
но для самой дочки она выглядит как pid=1 и родиетелей у нее нет

новый нейспейс
никого-----bash(1)


12789 и 1 это один и тотж же процесс в разных пид нейспейсах (ебануться)

так как 12789 это дочерний процесс баша то он делает некую мелокую работу и заканчивает 
свои действия и ызывает exit(0). тогда ядро его преврашает в Z . и послывает родиелю 
синал SIGCHLD. парент в своем старом пид нейсмейсе его получает и делает wait()
и ядро уже полностю вычищает 12789 он же 1 из памяти. тогда получается в новом пид
нейспейсе исчезает процсс pid=1 для ядра это ужасная ситуация. она ему ненравится. 
и это приводит к тому что ядро далее запрещает создавать новые процессы в новом пид
нейсейсе. навсегда. поэтому когда 12788 пытается соодать следующую дочку (ибо у баша при старте
возникает дхера дочек) то ядро шлет нахер этот fork запрос с ошибкой 
  fork: Cannot allocate memory
и на этмо старт баша заканывается. 

вопрос а если у нас pid-1 в новом нейсмейс висит в состоянии  Z и родитель в старом 
нейспейсе не запускает wait() то можно ли тода родителю запутить новвую дочку? даст 
ли ядро. хер знает. не проверял. 

я не понимаю вчем проблема почему при запуске ссиколаа unshare нельзя ткущий процесс 
поместить в новый пид нейспейс. ведь мы уже знаем что процесс будет однрврепменно 
сидеть и в своем старом пид енйспейсе и в в нвоом и ну и в чем пробелма? они пишут что 
якобы у нас у прцоесса поменяться пид. это хуйня полнейщая. у нас пид в текуще нейейсе
ниухя не поменятся. он просто приоебреет новый пид в ново м пид нейспейе ну и что? 
дочерний проеыесс имеет два пида ни нкиаких претенезий у дяра при этмо не возникает. 
так хуйле? непоянтно

а чем е разница запуска /usr/bin/unshar с ключаом -f ? а втом что когда стартунул 
процсс /usr/bin/unshare и он выполнил сисколл unshare то он недаелет execve(bash)
он делает fork +execve (bash) таким образом bash у нас стартует не в теуще роцессе
а в новом. и эт означит что bash сратуте в новом пи нейспейсе. сам он при этом получается
в новом пид нейспйсе pid=1 а его дочерний баш котоыйр старутет в новом нейспйсе
уже получается какйото pid<>1 и значит коода дочерний сделает exit() то в этом пид нейсйесе
головной то баш pid=1 как работал так и работает. то что подох дочерни  с pid<>1 так
и похеру. поэтмуо головной бащ может спопйно апускать следущрий дочерний процесс !

таким образрм я более рагбрался как рабраиетт pid naneosace, ка кработаеи unshare

итак если сисколл unshare неает теукущему процссу перелезть в пид нейспейсе
а толко его ребнку то сисколл clone(NEWNS) он создает дочерний уже в новом пид
нейспейсе ? (проверяю)

как посвтить gcc

# apt-get install build-essential

кстати /ust/bin/unshare это программа для создания новыех нейсейов! а не для 
подключения к уже усущестуюущими!!!!







 
баш - в итге какой его тред осаттс живым после заупска? знаит я проверил. 
когда стартует голвной бащ процесс. то он запускает кучу чайлдов. чась чайлдов
заупукскает своих чайлодв. в итоге они все выходят и осатеся только тот самый
изначальный головной прцоессб баща. 

вот у нас процесс сидит в пид неймсейсе. а как нам это проверить ?
как нам псмотрет список процессов ? обычно мы это делаем либо рукми через ls -1 /proc
либо чрез ps aux который за нас лезет в /proc   . значит я поискал как все пишут (спецааисты)
это то что нет никакого сисколла\функции наподобие getpid() чтобы получить список процессов
в текущем пид нейспейсе кроме как обратиться в /proc. хаха. пид нейспейс нам нужен 
чтобы наш процесс неимел досутпа как то полвиять на другие процессы. например не мог им
послать сигнал. но чтобы кому то послать сигнал нао для начала занть список номеров процссов
в моем пид нейспейсе. можно конечно посылаи и вслепую толко это нчео не даст. если мы 
послываем сигнал процсессу номера которого нет в тпкущем пид нейспейсе то это имеет нулеой
реуу=зульатат. так что в слепую ничего не полуится. список можно унать через /proc
но тут проблема. вот мы имеем процесс который сидит в новом пид нейспейсе. но этот 
процесс был получен путем клонирования из какогто другого процесса и нам достался маунт
нейспейс от какогото другого процесса. предполжим чтот тот процесс сидит в другом пид 
нейсмейсе. это згачит что при создании нащего процесса у нас будет наш маунт нейсммейс
от того процесса. и даже если у нас наш процесс создан с новым маунт нейсмейсом то 
все равно фактически псоел клониврания вид папок будет как у того процесса ! это знчит
что /proc будет покывзаь список прцоессов того процесса из того пид нейспейса!
неважно в нашем процессе новый маунт нйесмпейс или старный маунт нейспейс это никак 
не влияет на вид папок при клонировании в новй процесс. вид папок будет абсолютрно
такойже как у прошлого процесса! (это пиздец). а раз у того процесса был друой пид нейсмпйс
то его /proc/ и наш /proc будет одинаковый ! (это здец) это значит сидя в новом пид
нейсмейсе мы неможем получить список процессов которые сидя в наем пид нейспйсе.
типа ебнутый парадокс. это не значит что мы ищ нашего пид нейспейса может как то пволяиять 
на те прцоессы! нет! просто мы невидим список наших роцесов а видим список тех процессов!
нам нужно в новую папку заново смонтирвать proc тогда в этой папке будет  список пцроессов
которые сидят в том же пид нейспйесе что и процесс который монтировал proc!
значит мы можем либо монтирвать proc  в новую папку. и наконец увидить спсик процессов
нащего пид нейсмейса.  но это неклево. нам надо как то отмонтиовать шатануую папку /proc
и в нее примонтиовать новый /proc и вот тут у же на сцену вылезает какой у нашего прцоесса
маунт нейспйес. он старый или новый. если старый. то мы не сможем отмонтровать /proc
потому что он тогда отвалится и для тех процесов которы сидят в старом пид неспспейсе. 
нам просто напишут что ест открые файлв в /proc а вот ели у нас в нашем новом процессе 
новый маунт нейспейс. то тгда мы отмонтруется /proc никак не вляем на /proc в который
смотретя процессы из того пид неййспцса! и тгаа все окей!  поэтому я бы сказал что 
нет смысла созавать новый пид нейспейс и при этом не создаватвь новый маунт нейспейс 
для процсса или группы процессов! создание новоого пид нейспйса доожпо влечт за собой 
и создание новго маунт нейспесп! тогда мы без прбелм отмонтпуем старый /proc
и примонтуем нвой /proc

<===== закончил тут 
mount("none", "/", NULL, MS_REC|MS_PRIVATE, NULL) = 0
mount("none", "/proc", NULL, MS_REC|MS_PRIVATE, NULL) = 0
mount("proc", "/proc", "proc", MS_NOSUID|MS_NODEV|MS_NOEXEC, NULL) = 0



таким макамроя пходу разобратлся как докер грохает с помощть ядра все процессы
в контйенере


странно если выставить sigterm handler а потом делать clone то сказано что 
чайолд процесс по дейолту унасоедоует все хендлеры. однако по крайней
мере при клонировании в другой пид нейспейс и pid=1 ча1лд процесс нихрена не наследует
терм хендер. приходистя его грохать из род нейсмейса через sigkill <=====



докер как грохает все пцреоссы в контереер? если там sigterm нет  <====



если сигнлы это жлемент IPC то новый pid ns это уже новый ipc то нахуй нужен ipc 
namespace и флаг  CLONE_NEWIPC ?  <======



по моему груповое убивние процессов работает только при зарытии темринала
а болье никгада. тольк ирдиудаьано <=====

<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



>>>>>>>>>
initrd:
вопросы:


расписать все класнно про grub и инитрд
надо устаноить линукс на полносью защирфованные разделы.
а потом из другого граба расшифрвать раздел и даже загрузиться  с него

вобще центровая тема уметь ловко орудовать переносом запуском линукск
который был устанолвен на LVM+LUKS уметь его переносить и запускать из 
граба. и все это конечно завязано на initrd

непонятный моменты:

mount -t tmpfs udev /dev
                /\
                ||
            здесь по идее должосоять имя устрйства
сразу после заупска комнды там пусто. а только птом если запустить 
udev демона то там заполянется. видимо udev демон рнаходит эту папку 
и прост рукми через mknod создает веместо нас там устйроства . и все.

если хотим полклчться к устроссву то делается это так. у ядра дожлен быть 
дравер. этот дравйвер находит жеделхку и назнчает ей номер  а мы должны 
кактот этот номент узнать. например. граф экран у граба это tty1
и нам надосзать через mknod именно tty1 а не tty20
        # mknod 4 1 /dev/tty1
причем tty1 можно сзтаь где угодно необязательно в /dev это вобше неважно
важно только его major и минор а негде он лежит или как зовут файл 
можно назать и tty20 но мажор=4 а минор=1 и тогда процсс обращается на эттот файл


вопросы по тому как работает initrd
udev от ядра узнает все ннетлинку а что это на практие? 
в скриптх я видел /proc/hotplug 
udev-# It's all over netlink now
udev:echo "" > /proc/sys/kernel/hotplug
о чем это как это ?

также в скриптах настривалсялись шрифты консоли. разобраться.

также оказалос что чтобы заработа run-init
самый корень это сделать перенаравление ввода вывода в /dev папку которая 
лежит в новом корне. иначе почемуто фигня. у нас получается что у процесса 
как я понимаю смениласи точки монтрования. процесс теперь  через запро к ядру
в виде древоивдной системы может видеть другие файл ы и ппаки. но у него
stdin stdout указыать на дсрпиторы от файлоы /dev/console коооыторые лежат 
в друой видимо муааунт нейспейсе. нуи что? глнаове что мы дескипторы знаем.
нам  вэтом плане на фс уже насритать . но почему то мы будет видеть 
только голый корень и /root пустую папку. такое щущение что  run-innit
и его сисколлы для нашего процесса удляет все точки монторвания нона псоедней 
стадии у него не получаетяс создать для нас точу монтрования нового корня
в итоге наш процесс остается тупо  темноте. такое ощущнеие что run-init
рукодвствтуется тем куда у нас смотрит stdin stdout такой както бред.
я думаю да что вот эта непонятнка когда мы делем run-init
а у нас в итоге пустой  корень и в нем пустой /root
ялумаю run-init вычищает все маунт поинты но в конце недобалвяем новые
и наш процесс окзываетая в своем "старом" маун неймсаейсе
это можно проверить по mountnfi там будут написнаы номера маунт точек
и после натравливаенися run-init номер у / и /root должен остаться прежний
а синткксаис котоыйр приводит к успеху вот такой вот 
  $ run-init /root /sbin/init -i  </root/dev/console >/root/dev/console 2&1
причем неважно какйо у тебя pid . равен он 1 или нет. это похеру. 
абсолютно.
вобще зачем нужны маунт поиты. таким макаром прцоесс  абстрагивтся от железки
диска на котоырй он хочет записть и его раздела. ядро смотрит какой диск
ялвяеся бекендом для этого "фалового пути" и понимает куда ему надо лезть.
тоест процесс как ыб говорит - эй ядр запиши в корент того диска что ты 
подсунул в качеств корня файл 1.txt
понято что у ядра могут быть в дсутпе другие диски но он процессу 
их через маунт поинты может и и не выдать. эт завбавно но по идее у
процесса может не быть ни одного маунт поинта и даже ни одного деескриорпп 
ооткрытого. зато упроцесса всегда есть глвный канал связи с ядром это сиколыы.
тоесть процесс может пооожтить в цпу в регтсры араметры и взывать на цпу
сисколлл. и ядро может все что процесс захочет подкчьбить ему без проблем
.  и отключить тоже. 
что значт процесс видит файл на фс. на смаомом деле он ничего не видит
и маунт поинты это полная фикция. просто процсс поысылыае т через сисколл
ascii путь к файлу.  ядро видит маунт поинт и понимает что у процесса в принципе
есть "разрешнение " но недосутп к этому диску.   прцоссу вобще ненужно иметь 
маунт поинты. ему главное чтобы ядро взрващало содержимое файлов на диске 
по запрому. маунт поинты это полный фуфел это просто вид файл пермишснов. 
я бы даже сказал вид "диск пермиднсов" со стороны ядра к процесу. это табличка
на камере у зека о том кто он и что он для надизирателя. вот ив се
у процесса вобще ни к акому железку нет доступа кроче цпу куда его шедулер 
иногда пихает. и то к части регистров только.
маунт поинт это листик на стене кухни с картинкой гаваев. доуступа нет туда
просто ядро нам позвояет с гававев ингда получать посылки. вот и вес доступ.

рзобрать  работу initrd всех его скриптов. 
ксатти chrroot в манжаро нерабоатет. наверное из за hardened керенала.
видимо запршены какието сисколлы

надо отписатьс на форму suse там где у мужика не получалось 
как и  меня chroot сделть !

на ядре 2.6 run-init еще работает не длля pid=1 
надо попробвать ядро постстраше потмоу что на 5.10 уже неработает
(они допилили)



                            <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
docker stat  имя_контейнера 
покажет стаститику не для всеъ конетенов а только для искомгого!

CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O          BLOCK I/O        
ea4435dedd67   bash1     0.00%     12.99MiB / 437.5MiB   2.97%     32.4MB / 291kB   115MB / 81.9MB

==
можно подкрутить сколько мощности цпу можно потребрять контйенеру.
причем это можно обновляьт налету. ненужно ни стопить конйенер
ни перезапускать. все работает мгновенно!

# docker update --cpus=0.2 bash1

--cpus=0.2 = это означает что конйерер может максимально жрать 20% от одного ядра!
класс!

==
изучай это = https://labs.iximiuz.com/tutorials/containers-vs-pods
systemd-cgls --no-pager ==?
какой лимит по памяти и свапу в контйенер по дефолту? (узнать из cgroups)

использую это = https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_monitoring_and_updating_the_kernel/using-cgroups-v2-to-control-distribution-of-cpu-time-for-applications_managing-monitoring-and-updating-the-kernel

cpu.mac = 10000 100000 =>  0.01s   0.1s > 10% , означает что на отрезке 0.1s нашеу
процессу можно работать 0.01s остаьно время процсс должен спать. вопрос на 
скольких цпу ему можно раобоатьт ?

# grep ""  memory.max
62914560
 это 60MB 
 тоесть процессу монжно жрать только 60МБ оперативки?
 sleep infinit = охрнееть





терминал
баш сидя на слейв конце дает команды в терминал( в дисциплину линии)
так чтобы нажатия кнопок которые приеиают от терминала ( от процесса 
который держит мастер конец ptmx) чтобы дисциплина линии передавала в баш
кнопку сразу а не чтобы дисциалина линии ждала от термиала нажатия Enter
либо Ctrl+D



клава ->---- xterm ptmx -->- дисицплиана линии -->- pts/10 bash

а по дефолту  дисциплина линии ведет себя так что кнопка которая
прилетает от ptmx дисицлипина линии обратно в ptmx шлет 
подтверждение кнопки ( и потму на термиала при нажатии кнопки рсиуется
символ) но в pts/10 дициалпина линпии не шлет! онаждет нажатия Enter!

и вот бащ это меняет!




в начальном вопросе есть вопрос - хочется понять как это работает.
это ключевой и частый вопрос. его я хочу просвятить.


дохрена статьей про терминал.
но либо они слишком теоретичный. либо они слишком сложны.
либо слишком пусты. 
в итоге выхлопа на практчеком понимании дает ноль.
дохрена сттей для тех уто уже все занет very well
кто знает ноль это ад и каша

я прделагаю оттклунться от практики  и сразу появится солко то но 
реального понимания. 
после этого уже можно читать теоречтиекие статьи - навешивать мясо на кости.

поаать как содатеся два процесса соединных терминалом.
потом надо передать сиволы с мастера на слейв. там получить и напечатать 
обрато чтото. мастер получает и печаатет.

конец

====

//dev/ptmx заменет провода от мейнфремы до терминала.
xterm это сам терминал. его задача полученные байты по проду ptmx
как то донести до человека. мы их будем печатать на экране.
между ptmx и pts/N сидит line disciline. пусть там и сидит.
за pts/N сидит слейв программа. 

показать как арботает ctrl+C
как ctrl+D
как работает sigHUP

обяснить что значит процесс имеет pts/12 в свйотвах ps

показат цеопчку для ssh как там все устроено






что за хуйня sysig ?


написть как поставил arch 

qemu как подклчт сеть

$ qemu-system-x86_64 -name arch11 -m 128M   -boot d -hda ./arch.img  -drive file=arch.img,media=disk,if=virtio,format=qcow2,file.locking=off  -cpu host -enable-kvm -sdl   -smp 2 -M pc-q35-2.11   -vga virtio   -serial /dev/tty  -netdev tap,id=mynet0,ifname=tap0,script=no,downscript=no -device virtio-net-pci,netdev=mynet0,mac=52:55:00:d1:55:01


загрузка с grub руками чрез меню
qemu -serial tty раобтает только если граф окно осталвяеем


оухуенная вещь
как узнать размер окна теринала
# stty size
39 158
чтобы его поменять надо цифрв переставить
#stty columns 158 rows 39
охренеь!



а как рбаботает wagrant? его нет в route table!
проуерить iptables-save



похоже я  понял что кернел работает в process context. 
то есть то что кернел код видит прострнстно процесса. наверное это 
потмоу что цпу содержит в себе регистры отвчающие за адреное процестанвтсов
процесса. поэтому и ядерный код тоже видит адресное простанство процесса?
==
The System V IPC facilities include semaphores, shared memory, and message queues==

==
atop
надо его man прочитать
==
виртулка это доступ к цпу памяти и периферии.
kvm дает доступ к цпу\памяти
qemu к периферии

==
прикольно поставить голвый граб на флэшку
чтобы можно было с нее грузить любой комп  любого диска любой линукс
==
ВОПРОС: как докер проверяет здовроьвье контейнера?
==
  файл sysctl.txt 
      man sysctl 
      котоырй указвает на /proc/sys 
      а в нем есть кусок /proc/sys/net
      про который подробно написано в man 7 tcp 
      прочитать эту хрень  бегло
==
parent fork() --> чайлд
  картина memory mmap одинаковая ? а если memory map shared ?
  а если execve выполнитть? какие регионы памяти сохраняются?
==
если у нас есть процесс (типа докер контйенер) и мы выставивили 
лимит по памяти. то что будет когда он начнет выжирать память? я ссчитаю
что ядро вначале начнет совать процесс в свап. тоесть начнет выделять ему
память но не в RAM а из свап. а потом он его уже грохнет. надо провреить
так это или нет
 
==
>>> недописанные текст файлы
    bridge-veth.txt
    iptables.txt
    promisc.txt
    bridge.txt
    ip-netns.txt
    kubernetes-pause-контейнер2.txt
    docker-pid.txt
    podman.txt
    tcpdump-iptables-bridge.txt
    crictl2.txt
    mount-namespace.txt
    mount-namespace2.txt
    sigterm2.txt
    sighup.txt
    pid-namespace-pipe.txt
    fork-clone-pseudoterminals.txt
    docker-pause-container-manually.txt
    kubernetes-pause-конейтенер.txt
    alarm.txt
    interrupt.txt
    timer_list.txt
    watchdog.txt
    hpet-tsc.txt
    avariya.txt
    semaphores.txt
    serial-com-io.txt
    lxd-vmstat-st-steal.txt
    login.txt
    procinfo.txt
    mmap-malloc-brk.txt
    open-read-write.txt
    socket-pipe.txt
    ncat.txt
    tty2.txt
    affinity.txt
    midnight-commander.txt
    hyper-threading.txt
    zombie-docker.txt
    cgroups.txt
    tty3.txt
    lsns.txt
    linux-ipc.txt
    k8.txt
    minikube2.txt
    io.txt
    nginx-architecture.txt
    midnight-commander2.txt
    qemu-spice.txt (тут я хотел настрить связь с виртуалкой которая на другом коммпе)
    update-alternatives.txt
    kexec.txt
    wireguard2.txt
    
    



    план работ связанный  с этими файлами:
      brk mmap malloc
      kvm qemu
      archlinux устанвокаи приколы
      archlinux encrypt entire system
      semaphores
      timeshift (бэкап утилита)


>>> файл  qemu-spice.txt  для отдыха начал ставить gentoo но вылезло что вначале
нужно наладить связь с ноутбука на удаленную машину через ssh тоннеель к qemu серверу через spice клиент.

>>> digital ocean droplet. настроить внутрейнний iptables помимо 
    внешнего файрволла. (помнить что веб консоле нихрена неработает если сеть отрубится
    то пипец. на машину не войти.)

>>> файл bios-uefi.txt начал писать

вопрос - в чем разница между systemd slice vs scope vs service vs target
         начни с чтения man systemd
         
>>> systemd-pid.txt начал писать

>>> manjaro-install.txt пишу


>>> вопрос про lxd + qemu
    файл lxd-qemu.djvu
>>> тема tty терминала. в том числе tty дисциплина
    файл tty.djvu


>>> книги pdf которые не обработаны(лежат на леново в папке Downloads)
    iwDocumentation.pdf
    acpi.pdf
    6300esb-io-controller-hub-datasheet.pdf
    walter_ibm_linux_challenge.pdf
    Understanding Linux Kernel.pdf
    IO-Port-Programming.pdf
    understand.pdf


>>> все необработынные сайты в форме сешшн бади лежат тут:
     docs/nedodelano/30-may-2024.aes


непонянно как тключить вот этот протокол IP номер 58 это якобы IPv6-ICMP
# netstat -nlpw
Proto   Local Address     Foreign Address    State       PID/Program name    
raw6    :::58             :::*               7           23098/systemd-networkd 
raw6    0 :::58           :::*               7           23098/systemd-networkd 


>> vfat.txt
>> manjaro-setup.txt
>> usb-flash-zero.txt


>> session buddy "16-jun-2024"


>> список файлов session buddy сохранил куда? смотрит об этом в todo.txt

>> disk-block-dd-max_sectors_kb.txt 
    пытался разобраться с /sys/block/sda/...


>> system.map.txt
>> перечитать законченную но важную статью top-free-memory-used-explanation.txt


>> на леново есть psi epxress nvme диск у котоого в его натройкаих указано
что он имеет блок(сектор) 512 байт.  а можно его сделать как 4 килобайт. надо
так сделать. и померить скокрость на обоих режимах.




