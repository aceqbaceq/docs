| streams

итак что такое файл дескриптор что когда зачем и как
все понятно. смотрим "file descritptor"

теерь что такое streams.

значит как мы раотботаем  с файлом. для начала нужно ядро попросить
чтобы оно файл "открыло". дада. открывает файл не процесс. он вобще
нихуя ничего не может. отрывает файл ядро. и открывает оно его 
ДЛЯ СЕБЯ. поотому что фактиччески читает и пишет в ядро само ядро.
мы лишь его просим. поэтому открывая оно делает всякие разные штуки
которые нужны ядру чтобы оно могло с файлом фактически работать. 
что оно там делает хрен знает. ясно одно оно для файла делает
кучу записей в нескольких таблицах. толкьо после этого
ядро готово с файлом читать писать. 

фактически из юзерспейса процесс может попросить открыть ядро 
через сискол. но понятно также что програмируя на си програмист не делает
этого реально чрез сисколл. он это делает через функцию си. через предустановл
енную функцию создателей си языка которая была придумана чтобы прогрмисту
было "проще" открывать файл. поэтому програсит исползуется функцию си open()
в которую передает параметры. а она уже делает всю грязную работу 
по подгтоовке запроса к ядру через сисколл об отыкрытии файла. итак

  мы ---> си функция open() -----> syscall openat() ----> ядро

в ответ нам ядро возвращает кончик хвости зацепку некий билетик как номер 
в камере хранения на вокзале. чтобы потом мы могли ядру этот номер обратно
преедать и таким образом обяьсянсить ядру с каким файлом мы хотим далее
рабоатать ! это файл дескриптор.  это кусок данных из области паяти 
ядра про наш файл. 

так вот создатели си незнаю нахуя но они взяли и написали еще более высокоуров
невую функцию кторая еще больше абстраширует нас от подробностей внутренней
требухи ядра и если мы будем открывать файл чреез эту функцию то она нам
вместо файл дескриптоар вернет другую хрень она нам веренет поинтер.
этот поинтер в отличие от файл дескриптора он не связан с ядром.
он указывает на кусок памяти в юзерспейс процесса. в ктотором понятным
языком для функций си записано какой файл мы до этого открыли. 
таким образом если мы этот поинтер будем посдосовыать особому классу си 
функций котоыре понимают о чем идет речь. то они идут по тому понтеру. 
считывают то что там написано и они знают что нужно передать ядру чтобы ядро
поняло о каком файле идет речь. по адрему в том поинтере коненчо есть 
инфо и об дескприоре которое файл имеет в ядре. 
тоесть если рантше мы в си функцию read() подставляли номер fd дескрпиора
а он его передавал в ядро. то  теперь можно использовать фукнцию fread()
и внутнт поставит поинтер на инфорацию об файле записанную в юзерспейсе.

зачем было городит доп огород   я пока не понимаю.
это выгдядит так. я положил деньги в банк. мне банкир сказал твоя ячейка 148.
далее я сам в банк нехочу я нанял клерка. раньше я ему гвооил прилешь 
в банк скажи ячейка 148. а теперь он мне говорит. слушай я ходил в банк
открыл тебе счет. но номер ячейки я тебе на скажу. тебе ее знат нахер
ненадо. но я тебе скажу как я ее тебе буду обзывать. ячейка М1. 
поэтому ты мне говорит ячейка М1. а я уж по своим бумажкам разберусь
какая там на самом деле ячейка в банке.

пиздец.

и вот плучается в си ест две группы фуцнкйи. одни нам сообщают файл 
дескриптор. и мы его потом в них вставляем. а оно его передает ядру.

а ест другой класс фунций. они нам не сообщают файл дескриптор. они 
нам сообщают поинтер. я тгда им сообщаю обратно поинтер. а они
уже шарят по нему и понимаю каакой файл дескриптор надо собщить ядру.

этот поинтер указывает как я понял на struct (структуру) которая 
обзывается FILE. а этот поинтер называется stream . вот такая хуета.

пример как работать с файлом через файл дескприпотор
смотри по "|file descriptor"

теперь как выглядит работа через stream.


#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>


int main(void) {


  printf ("pid = %i\n", getpid() );

  char const * ptr_path = "/tmp/1.txt";
  char const * ptr_mode = "r";
  FILE * i_stream = NULL;

  i_stream = fopen(ptr_path,  ptr_mode);

  sleep(30);
  fclose(i_stream);

 exit(0);

}


$ ls -1al /proc/12282/fd/
...
lr-x------ 1 vasya vasya 64 мая  8 23:10 3 -> /tmp/1.txt



что тут ирнтерсного. 
во первых

	FILE * i_stream = NULL;

тоесть у нас идет поинтер на некий sctruct. тоест это не void * 
это не int * это FILE *

во творых вместо close идет fclose;

в третьх флаг открытия это "r" что отливается от флагов при юзании open()


что интерсно это то что в фунуциях которые принимают не файл 
дескрпиоры а стримы там можно вставлять предопределнные стримы такие как
 stdin
 stdout
 stderr

вот!

опять же нахуй нужны стримы если есть файл дескрпиоры я ответа ячсного
не нашел.

превый раз я столкунлся со стримиаи кодга натолкнкулся на putc() 
функции. об этом смотрим "| fputc"

