когда ядро шлет процессу сигнал SIGHUP ?

The SIGHUP signal is sent to a process when its controlling terminal is closed. 

тоесть если у процесса в свойствах есть открвтое устройство терминал 
и если этот терминал "закрыватся" то ядро шлет процессу этот сигнал.

напрмие мы открыли терминал в нем баш. баш имеет тткрытм устройство терминал. /dev/pts/3
потом мы с помощью баша запускает програмуму у котоой есть хендлер сигнала SIGHUP
и также баш при клонировании ей тоже передает открыет устройство терминал /dev/pts/3
потом если мы в граф интерефейсе закроем терминал (нажмем на крестик) то устройство
/dev/pts/3 исчезне его ядро закроет. и при этм оно пошлет всем прогаиммаам
у которых было это устройство открыто сигнал SIGHUP.

вот прогиамма

[vasya@lenovo C]$ cat 129.c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

static void sigdown(int signo) {
  psignal(signo, "Shutting down, got signal");
  exit(0);
}


static void sigterm(int signo) {
  printf("SIGTERM is caught....shutting down\n");
  exit(0);
}

static void sighup(int signo) {
  printf("SIGHUP is caught....shutting down\n");
  exit(0);
}




static void sigreap(int signo) {
  while (waitpid(-1, NULL, WNOHANG) > 0);
}

int main() {

  if (sigaction(SIGINT, &(struct sigaction){.sa_handler = sigdown}, NULL) < 0)
    return 1;
  if (sigaction(SIGTERM, &(struct sigaction){.sa_handler = sigterm}, NULL) < 0)
    return 2;

  if (sigaction(SIGHUP, &(struct sigaction){.sa_handler = sighup}, NULL) < 0)
    return 3;


  if (sigaction(SIGCHLD, &(struct sigaction){.sa_handler = sigreap,
                                             .sa_flags = SA_NOCLDSTOP},
                NULL) < 0)
    return 4;

  for (;;)
    pause();
  fprintf(stderr, "Error: infinite loop terminated\n");
  return 42;
}

если она ловаитт SIGUP то пишет об этом.


открываем два терминала. 
в первом находим его pid. во втором зпускам strace котоырй будет этот pid мониторить

$ strace -f -e  write    384433

в первом термирнале зауска на шу прогармму
gcc -o 129.exe 129.c
./129.exe

потом жмем на крестик и таким образом наш терминал его устройство исчезает из системы
а в strace можно увидеть во такое тогда
[pid 384458] --- SIGHUP {si_signo=SIGHUP, si_code=SI_USER, si_pid=384433, si_uid=1000} ---
[pid 384458] write(1, "SIGHUP is caught....shutting dow"..., 34) = -1 EIO (Input/output error)


эт реально доказывает на счет откуда  в ситстеме пявляется сигнал SIGHUP. !!!!

логика такая- если у нас открыто окно темринала. (работ у стройство теоминал железное)
то все прогарммы которые запускаются из него. ополучают открытым его устройство.
если терминал сломался и устройство его исчезло. то логично что все прорграммы которые
были запущены через этот тмеринал над грохнуть! тем более что  у этх прогиммрамм их 
fd\0 fd\1 stdin stdput были напрлвены нв етмринал. а еси его уже нет. то откуда пограма
будет получать данные и куда она их будет пистьа?  поэтому их ядро всех убивает точнее
им всем шлет SIGHUP сигнал.

моно заблокиррова это сигнал вт так наприе

$ nohup /bin/sleep 120

тогда смотрим его маску мигналов

$ pstree -Asp $(pidof sleep)
systemd(1)---systemd(3311)---gnome-terminal-(17549)---bash(384402)---sleep(384737)


$ ./01.bash 384737
SigPnd: 0000000000000000 0 
ShdPnd: 0000000000000000 0 
SigBlk: 0000000000000000 0 
SigIgn: 0000000000000001 1 HUP 
SigCgt: 0000000000000000 0 

вот видно. что на сигнал HUP наложен игнор!

это значит я щас закрою окно терминала.(выключу железное устройство термиал также 
как выключчить кнопку на модеме).

а процсс продллжить жить. я проврил так и есть. закрыл окно теринала.
а процесс продожлиж жить в списке процессаов!!

===
вот это в strace
kill(-385882, SIGHUP)

хрень под минусом это не номер процесса. это номер группы! группы процессов!

==
==
иключить несколько сигнало
strace -e 'trace=!read,write'

==

при закрыти граф окна кто шлет сигнал SIGHUP???
как у нас выглдяит дерево процессов для граф терминала


# pstree -AspT $$
systemd(1)---systemd(3311)---gnome-terminal-(386027)---bash(386631)---sudo(386656)---bash(386657)



или
systemd(1)---xterm(387312)---bash(387317)

bash процесс
lrwx------ 1 vasya vasya 64 апр 26 23:21 0 -> /dev/pts/1
lrwx------ 1 vasya vasya 64 апр 26 23:21 1 -> /dev/pts/1
lrwx------ 1 vasya vasya 64 апр 26 23:21 2 -> /dev/pts/1
lrwx------ 1 vasya vasya 64 апр 26 23:21 255 -> /dev/pts/1


xteerm
lr-x------ 1 vasya vasya 64 апр 26 23:20 0 -> /dev/null
l-wx------ 1 vasya vasya 64 апр 26 23:20 1 -> /home/vasya/.cache/lxsession/LXDE/run.log
l-wx------ 1 vasya vasya 64 апр 26 23:20 2 -> /home/vasya/.cache/lxsession/LXDE/run.log
lrwx------ 1 vasya vasya 64 апр 26 23:20 3 -> 'socket:[342124162]'
lrwx------ 1 vasya vasya 64 апр 26 23:20 4 -> /dev/ptmx





или даже вот так
systemd(1)---xterm(387312)---sleep(387317)



(процсс xterm)
lr-x------ 1 vasya vasya 64 апр 26 23:13 0 -> /dev/null
l-wx------ 1 vasya vasya 64 апр 26 23:13 1 -> /home/vasya/.cache/lxsession/LXDE/run.log
l-wx------ 1 vasya vasya 64 апр 26 23:13 2 -> /home/vasya/.cache/lxsession/LXDE/run.log
lrwx------ 1 vasya vasya 64 апр 26 23:13 3 -> 'socket:[342125238]'
lrwx------ 1 vasya vasya 64 апр 26 23:13 4 -> /dev/ptmx


(процесс sleep)
lrwx------ 1 vasya vasya 64 апр 26 23:16 0 -> /dev/pts/1
lrwx------ 1 vasya vasya 64 апр 26 23:16 1 -> /dev/pts/1
lrwx------ 1 vasya vasya 64 апр 26 23:16 2 -> /dev/pts/1

соотвесвтенно прцоесс sleep это не графический процесс. он не доагдватся о том
что есть какйото там графический режим.



а так выглядит дерево процессов
если открыть tty3 окно (ctrl-alt-f3) (типа ее графический режим)
systemd(1)---login(19527)---bash(387600)

login:
lrwx------ 1 root root  64 апр 26 22:38 0 -> /dev/tty3
lrwx------ 1 root root  64 апр 26 22:38 1 -> /dev/tty3
lrwx------ 1 root root  64 апр 26 22:38 2 -> /dev/tty3
lrwx------ 1 root root  64 апр 26 23:28 3 -> 'socket:[342134163]'
l-wx------ 1 root root  64 апр 26 23:28 6 -> /run/systemd/sessions/826.ref


bash:
lrwx------ 1 vasya vasya 64 апр 26 23:28 0 -> /dev/tty3
lrwx------ 1 vasya vasya 64 апр 26 23:28 1 -> /dev/tty3
lrwx------ 1 vasya vasya 64 апр 26 23:28 2 -> /dev/tty3
lrwx------ 1 vasya vasya 64 апр 26 23:28 255 -> /dev/tty3

в случае неграфичекого я дуаю тут так это рабтает

                                       / ----> процесс (bash)
                                      / 
клава-->--- ядро--->-----------/dev/tty3
              |                       \  
              |                        \-----> процесс (login) но он спит в wait() пока баш работает
              |
              |    
              |
экран--<----ядро--------<-----/dev/tty3 ---<--- процесс (bash)
                                       \
	                                    \--<-- процесс (login) но он спит в wait() пока баш работает



тоесть процесс login он спит в wait() пока процесс баш неумер
нажимаем кнопку (клава это железка как диск) нажатие летит в ядро через драйвер
ядро сует этот байт в /dev/tty3. оттуда его читает баш. так у нас копка с клавы поступает 
в бащ процесс.
если баш чтото хочет написать то он пишет в /dev/tty3. это посутпает в ядро.
и ядро это уже рисует на экране (экран это железка как диск) через драйвер. в формет символов.
клава плюс экран составляют типа железку терминал сточки зрения ядра. если эта железка
"ломается" то ядро должно это распознать и послать сигнал SIGHUP группе процессов которая
была заущена с этого термиала. признак это то что все прцоессы сидят в одной группе (pgroup)
и ядро пошлет сигнал группе. номер группы это первый процесс который стартунул на этом 
терминале. тоесть открыл устройсто и полуичил утсроуство терминала /dev/tty3.
видимо в нашем случае это процесс login 19527. значит все процессы запущенные на этом 
тмериале будут иметь pgrrp 19527. ядро пошлет сигнал kill SIGHUP -19527
минус означает что сигнал направлен не процессу а группе с этим номером.
и все эти прцоессы будут убиты скоре всего. если только у них невыставлен игнор
для SIGHUP.

ни баш ни login понятия не имеют что такое экран и клава. они слепы они сидятв темноете
все что у них есть это файл ввода вывода /dev/tty3
про экран и клаву знает только ядро. 

а что такое с точки зрения асемблера /dev/tty3 
чтение и запись у процесса идет через вызов сисколла. при вызыве ссикола юзер процесс
кладет в регистры определенные хрени числа. потом идет преелюючене цпу в привилигированный
режим. заупскается ядро. оно читает те праметры которые юзер процесс записал в регистры цпу.
пооложим там есть некоторое число кодирующее /dev/tty3 скажем это число 15. 
и ядро понимает для себя что имелось ввиду абстрактное устройство /dev/tty3 
и физиески за это вирт устройство отвечает ккойто буфер в памяти кусок памяти. 
както так это рабоает.
тоесть аример юзер процсс хочет заисать чтото в /dev/tty3. 

вот как выглядит процесс записи и чтения 


#include <stdio.h>
#include <unistd.h>

int main ()
{

int fd;
fd = 0;

void *pbuf;
char bufer[10];
pbuf = &bufer;

size_t a;
a = 10;

read ( fd, pbuf, a );
write ( fd, pbuf, a);
printf ( "\n" );


return 0;
}


значит заводятся переменные в памяти юзер процесса. 
тоесть куски памяти резрвируются. потом вызывает сисколл и он просит у ядра
я хочу чтобы ты для меня то что было нажато на клаве считал 10символов максиум
и засунул то с клавы к тебе прилетело в мою юзерскую память туда где у меня
обозначена переменная pbuf. видимо юзер процесс в цпу сует
адрес пеерменной pbuf напрмиер и сует номер сисколла в цпу и  вызывается сисколл. 
через регистр в цпу . 
просыпается ядро все это видит  и ждет нажатия кноопок. мы тыкаем кнопки. ядро принимает байты.
с клавы. потом оно эти байты сует в ту область памяти куда попросил юзер процесс.
далее ядро засыпает а юзер процесс просыпается. и проснувшись он уже имеет в своей памяти
там где pbuf что там уже есть данные.
это примерно выгляди так - ребенок пишет записку бабушке - завтра сходим в магазин
и купи три хлеба в магазине. потом принести домой и положи мне в ящик стола в моей
комнате в третий сверху. и ребенок засыпает. просыается бабка. видит записку. 
делает все как надо. идет в магаз. покупае хлеб. придит сует хлеб в стол.
и засыпает. далее ребенок просыпается и у него уже в столе есть этот хлеб где 
он заказал. таким макаром ребенок не ходя сам в магазин ибо это отсвственная 
задача ему не разрешают имеет в столе хлеб из магазина. или - ребенок из пластилина
слепил игрушку. засунул в стол. написал бабке - залезб в стол . ящик такойто. возьми
игрушку и пойди отдай  в магазин. и засыпает. бабака берете игрушку откуда 
ей сказалию идет в магащин и отдает. 
бабка- это ядро. ребенок - это юзер программа. магазин это и экран и клаава.
игрушка из палстилина это то что мы пишем на экран. 
хлеб это то что нам прилетает с клавы.

/dev/tty3 это некое условное обозначение некотрого буфера куска ячейки памяти в 
области памяти ядра. можно кодировать какойто цифрой в коде юзер процесса.
а ядро уже там само знает в какую конкретно ячейку ядерной памяти это совать. 
тоесть юзерский код говори возьмто то что у меня в паяти лежит по адресу 1231212123123
и запиши туда что у тебя закодировано как 15. где 15 это кодвое название /dev/tty3
а ядро понимает что ему это надо засунуть в железку.
или юзерский пройесс говорит - запиши мне из 15 10 байт в мою память по адреу 1123123123
а ядро понимает что нужно взять из железки считать и засунуть в память в 1123123123
как все сложно...



==



