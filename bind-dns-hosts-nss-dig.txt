| dns
| hosts
| hostname
| bind
| NSS

эта дока это самая основополагающая
из всей серии про dns hosts и bind


поговорим щас о многом

во первых рассмотрим /etc/hostname
что это такое. туда мы записыываем текстовый
идентификатор. его при загрузке читает init скрипт
и он запускает глибц фунцию 

   sethostname()

что приводит к тому что в ядре будет записана
эта перменная.

что она дает. она устаналивае идентификатор для
данного инстанса ОС. что важно что этот идентификтор
он никак не связан с сетевым стеком. пока это
мало что значит но позже все прояснится.
зачем он нужен. по какойто причине он нужен 
процессам на компе. когда они работают то им 
хочется знать какой у нас ХОСТНЕЙМ. напрмиер он 
нужен локальному процессу чтобы когда он делает 
записсь в лог то он каждую свою строку помечает
на какой хостнейме работает этот процесс.
узнать текущий хостейм можно через 

   gethostname()

он будет считан с ядра а не из файла /etc/hostname

еще раз почедекрну что этот идентфикатор он никак
не связан с сетью , с сетвой идетифифкацией, с
сетевым стеком. он находится вне этого. над этим.
он нужен лкальномы процссам чтобы они знали на 
каком компе они работают

следущий момент это файл /etc/hosts
он повяился вот как. мы на комп добавляет сет 
карту. и на нее лепим IP адрес. без наличия 
ип адреса файл хостс нахрен ненужен.
далее удаленный юзер хочет с нашим компом связаться
на основе ип адреса. он в программе которая умеет
лазить в сеть вбивает ип сет карты нашего компа.
ип получаеся это как адрес на конверте. получается
с точки зрения удаленного юзера с точки зрения
сетевой прогарммы которая умеет работать на ип
уровне   - ип сет карты нашего компа ялвяется
идетификатором нашего компа. 
так вот запоминать ип адрес очень тяжело для 
члеоека тогда решили кодировать ип адреса через
текстовые идетфикаторы. человек вбивает тектовый
лебейл в сеетвую прогрмму на удаленном компе.
та программа преобразует на основе данных из
файла хостс в ип адрес. подставляет его. и делает
конект в нашей сетевой карте. так вот файл хостс
он содержит ип адрес и тестовый лейбл удаленного
компа. эти текстовые метик зовут хостнеймами, хотя
по сути это не хостнеймы это ипнеймы потому что
они кодирую не хост целиком они кодирую только
ип одной сетевой карты. и данне хостнеймы они
никак с хостнеймом который хранится в файле 
/etc/hostname не свзаны вообще  абсолютно.
хостнейм в файле хостнейм он явлтется меткой для
всего компа целиком и не явлется никаким алиасом
с точки зрения каких либо сеетвых адресов. 
а хостнейм в файле хостс это текстовый алиас
для всего навсего одного ип адреса компа. таких 
ип адресов на компе может быть вагон. поэтому 
хостнейм котоырй лежит в файле хостнейм он 
всегда один на компе. а хостнеймов которые в файле
хостс их может быть миллион для одного компа
если у него миллион сетевых карты. 
и если хостнейм из файла хостнейм является
идентфикаиатором ЭТОГО КОМПА и нужен локалрным
процессам моего компа для понимания на  каком компе
онираюотают, то хсотнейм их файла хостсс нужен 
на моем компе узкому кругу процессов, сетевых
процессов коьорые 
умеют выходит в сеть через ип адрес. и этот хостнейм
явялется кодировкой абревиатурой ип адреса сетевой
карты но не моего компа а удаленного тоесть 
другого компа. 
тоесть у этих хостнеймо у них соверешенно разная
природа , назначение, цели , задачи, потребители.

таким образом хостнейм из файла хостнейм совершенно
никак не связан с файлом хостс и теми сущноятсями
которые там есть.


поэтому хостнейм из файла хостенейм совершенно
необязан присутсовать среди хостнеймов которые
сидят в файле хостс


как узнать чему равен хостнейм который из 
файла хостнем
через gethostname()

эту фунцию юзает кли команда
  $ hostname

  # ltrace -e gethostname hostname 
  hostname->gethostname("kukushka",128) = 0


можно сравнить с тем хостнеймом который указан 
в файле 

# cat /etc/hostname 
kukushka

подчеркну что gethostname() он читает даныные
не из файл /etc/hostname а из ядра
а файл хостнаейм читет при загрузке инит процесс
и он его исползует для того чтобы выставить этот
хостнейм через 

    sethostname('kukushka')



таким образом природа суть цели потребителия
названеие хостнейма из файла хостнейм и из файла
хостс они совершенно разные. хотя по дебильному
оба этих лейбла назвыают одинаковым термином что
ужасно.

кстати гововря в файла хостс может быть ип адрес
порта нашего компа а нетолько удаленного. и тогда
хостнейм в хостс будет значит лейбл ип адреса
сет карты нашего компа. 
тогда можно срванить хоснтейнм из файла хостнейм
с названием всего замка или башни и при этом
хостнейм для ип карты нашего компа с  названеим
всего одного окна или одной двери этого замка.


теперь про файл хостс. его синатксис можно найти
всего в одном месте это 

  $ man hosts

и он такой каждоая строка это 


 ип_адрес    хостнейм1 хостнейм2 ... хостнеймN


и рабоает это так что если мы в сетевую программу
на нашем компе подставляем  некое текстовое слово
например vasya то далее так случаеся(за счет конкретно будет щас
говорить) что происходит парсинг в этой файле хостс
и в нем ищется vasya среди хостнеймов и если на
ходится то обратно вовзращается ип адрес и он уже
используется сетевой программой для установления 
конекта с удаленным компом
и получается что мы можем использовать любой
хостнейм в программе чтобы в итоге он был преобразован
в ип адрес тоесть
мы имеем в хостс

172.16.100.30   vasya petya  kuku12  super10

если мы подставим в сетевую программу ping любое
из этих слов 

  ping vasya
  ping petya
  ping kuku12
  ping super10

то в итоге любая эта команда превраиться в одну
и туже

  ping 172.16.100.30

нет никакой проблемы иметь много текстовых лейлов
ведь они все превращаются в один и тот же ип.

но есть прблема в оратную сторону. бывает что 
прогиамма имеет ИП а ей хочется узанть текстовый
лейбл. тогда у нас получается неоднозначность - в
какой из списка ип его прверащать? и тогда придумали
что в строке хостс самый ближний лебел в ип адресу
явялется так называемым каноническим хостнеймом
и именно в него и система будет первращать при запросе
ип адрес.
в нашем случае какнинчесим хостнеймом явялется vasya

по поводу какому стандарту подчинаяются хостнеймы
в файле хостс. согласно man hosts они начаинаются
либо с буквы либо с цифры . потом идут либо буквы
либо цифры, либо знак _ , либо точки, правда точки
не могут насколко я понял идти подряд. и полсдений
символ это либо буква либо цифра. 
файл хостс неимеет никакой связи с системой ДНС
из интернета. и правило именования хостнеймов в
нем абсолютно не подчиняется правила образования
имени домена. файл хостс и ДНС из итенета это две
абослютно незавииимые системы. это очень важно понять.
также с точки зрения хостс неважно заглавня ли  буква
или мелкая. они счиатаются одинаеовыми.

теперь какова цепочка между юзер программой
и резолвингом текстового лейбла в ип адрес.
схема такая - файл /etc/hosts является на самом
деле конфигурационным файлом GLIBC подсистемы NSS
когда то давно не было этой подсистемы (подсистема
я имею ввиду это такая условно говоря библиотека
glibc). а все работало  вот как. у нас есть 
либц функция gethostbyname() в ней прям в явном
виде было вшито что нужно залезть в файл /etc/hosts
и там пошарится. но таких источников где записана
связь между текстом и ип адресом может быть много
ими могут быть ими могут быть

      file (/etc/hosts)
      dns  (клиент встроенный в libc)
      mdns
      nis
      кастомный днс клиент
      ldap 
      wins

эти все источники данных нужно было бы 
в явном виде интегрировать в тело функции 
gethostbyname() , но это была бы еще фигня,
нужно под каждый истчник данных интегирировать 
модуль доступа. в  общем решили идти другим
путем. решили что напишут ряд либц функций
которые все условно обьедилнили в группу nss
и тогда схема выглядит так:
я беру свою функцию gethostbyname()
в ней я пишу
  #include<nss.h>

у меня в теле моей функции становятся доступными
ффункции из nss.h
и у нас пояявляется фунция условно

  nss_func1()

я ее вызываю в теле моей фунции. она в свою
очередь лезет в конфиг 

   /etc/nsswitch.conf

и там указано в какие источники данных нужно 
лезть. указано это там в строке hosts:

# cat /etc/nsswitch.conf 

passwd:         files systemd
group:          files systemd
shadow:         files systemd
gshadow:        files systemd

hosts:          files myhostname mymachines resolve [!UNAVAIL=return] dns
networks:       files

protocols:      db files
services:       db files
ethers:         db files
rpc:            db files

netgroup:       nis


это хитрожопый файл. в нем в каждой строке
указана отдельная разновидность поиска.
тоесть например в  строке "passwd:" уазыватся
источники данных которые на входе принимают
имя юзера а далее указаны источники данных 
где искать пароль для этого юзера

passwd:         files systemd


так вот в строке "hosts:"

hosts:          files myhostname mymachines resolve [!UNAVAIL=return] dns


у нас указаны источники данных которые занимаются
тем что им на входе мы даем  текстовое слово
а на выходе они выдадут ИП адрес
так вот в нашей функции NSS которую мы 
вставляем в теле нашей фунции gethostbyname()
я вставляю явное слово "hosts"
чтобы указать этой функции какого класса поиск
мы хотим вести

  nss_func1("hosts")

тогда она будет искать в файле /etc/nsswtch.conf
именнов строке 


hosts:          files myhostname mymachines resolve [!UNAVAIL=return] dns


в правой части этой строки указаны разные 
источкники данных в форме имен плагинов которые
умеют в них искать. тоесть плагин


files - он умеет искать ип адрес в /etc/hosts
myhostname - это плагин systemd-resolved, если 
             ему навход подать текст который прописан
             в /etc/hostname то он в ответ вернет
             все ип адреса локальных сетевых карт
             подробнее как работает этот плагин
             смотри в $ man nss-myhostname
mymachines - это плагин от systemd-resolved
             он умеет искать ип адрес на основе
             имени контейнера который запущен в
             систме через systemd-nspawn
             тоест мы запускаем на хосте контенер
             через systemd-nspawn и он както
             регистриует ип контейнера на хосте.
             тогда этот плагин если мы ему навход
             дадим имя конейтра то он выдаст его ип
             я щас рассмотрю на практике как 
             этим плагином пользоваться. о том
             как запустить конейтнер через 
             systemd-nspawn читайт тут systemd-container.txt

 resolve - это плагин systemd-resolved и он тупо
           обращается к сереру systemd-resolved 
           который резолвит запрос как днс клиент

вот эта хрень [!UNAVAIL=return]  означает то 
что если плагин который указан левее этой скобки
в данном случае плагин "resolve"  если он по 
какойто причине вернул ошибку то это значит
что systemd-resolved тупо не отвечает
так вот эта хрень она приведет к тому что дальнейший
перебор плагинов будет прекращен. это сделано так
потому что считается что если сломался системд-резолвд
то это считается критическая ошибка в системе 
и лучше если человек ее сразу бы заметил

dns - этот плагин это днс клиент который встроен
      в саму glibc , по идее еси на компе устанолвен
      systemd-resolved и мы уже пропсиали плагин resolve то ползоваться  этим плаигином нет
      смысла

итак наш NSS проблегает по всем этим "источникам"
данных. и либо находит ответ либо нет. 

если мы хотим убрать какойто источник данных
то просто убираем имя плагина из списка в 
файле /etc/nsswitch.conf

как проверить что вся эта шарманка раотает.
есть супер прога getent

можнопочитать 

   # man getent

как проверить что у нас работает плагин file
берем файл

# cat /etc/hosts
127.0.0.1	localhost
127.0.0.2	host1.dom.loc	host1


тогда  я делаю запрос

	# getent hosts host1.dom.loc
	127.0.0.2       host1.dom.loc host1

работает и в обратную сторону

	# getent hosts 127.0.0.2
	127.0.0.2       host1.dom.loc host1

согласно man getent  команда getent host KEY
работает так что если я  в key подствляю тектоый
ключ то моя прога взывает  функуцию 
gethostbyname2() 
а елсли я в KEY ставлю ип адрес то моя прога зпускает gethostbyaddr()

первая функция gethostbyname2()  я думаю раотает вот как. у нее на входе идет массив из char 
символов. она подставляет поинтер на этот массив
и также слово "hosts:" в некую nss функцию 
пусть это будет фуцния
   
    nss_func1 ()

которая  доступна внутри gethostbyname2() из за 
include <nss.h>

тоесть вызов выглядит вот так

  nss_func1 ("hosts:", "text")

эта фуцния идет в nsswtch.conf 
и находит строку "hosts:""

hosts:          files myhostname mymachines resolve [!UNAVAIL=return] dns


и она начинает взывать модули указнные в строке
один за одним и им передает поинтер на этот 
массив из char символов.
кадый модуль анализиурет что за аршумент 
им пеедали. и делают нужные дейтсвия.
например модул file ищет переданный массив
в фале хостс
а скажем модуль resolve видит что ему пределали
текст в аргументе и он формирует днс запрос
вида

  текст.    IN    A

и шлет запрос на днс сервер


как результат обратно эта nss_func1 фукция
возвращает ИП адрес.
тогда фунция gethostbyname2() сохраняет 
ответ в структ  hostent

      struct hostent {
               char  *h_name;            /* official name of host */
               char **h_aliases;         /* alias list */
               int    h_addrtype;        /* host address type */
               int    h_length;          /* size of address */
               char **h_addr_list;       /* list of addresses */
           }
           #define h_addr h_addr_list[0] /* for backward compatibility */



я думаю она в char  *h_name кладет  аргумент хостнейм который мы ей передали
а в char **h_addr_list кладет найденный ип

а уже наша прога getent заглдывает в структ
и выбирает то поле которое мы хотеили найти.

вторая фунция gethostbyaddr()
работает почти точно также как и gethostbyname2()
за исключеним того что у нее на входе аргумент
идет не в формет *char а в форме бинарной хрени
где лежит ип адрес. так вот я думаю она 
преобразует этот ип в *char а далее
ровно точно также взывает 

  nss_func1 ("hosts:", "text")

и он отрабывает точно также.
и фишка в том что уже сами плагины берут то 
что лежит в этот "text" и сами проверяют что 
там лежит хостнейм или ип в текстовом виде.
и в зависимости от этого они выполняют поиск
в результате они возврашают уже нам не ип
а текст (хостнейм) а наша функция gethostbyaddr() 
опять же заополняет тот же самый структ hostent
и кладет этот хостнейм в нужное поле.

поэтому обе фуцнии gethostbyaddr()
gethostbyname2() очень похожи отличаюьтся 
лишь детальками. обе в итоге врвращают приложению
в данном случае getent один и тот же структ hostent
где есть и ип   и хостнейм. тоесть они не возрващают
готовый ответ. и уже наше приожложение getent
должно взять из структа то что ему надо . тость
либо ип либо хостнейм.

да вот так эта шраманка рабтает. 

видим что сработало

тепрь понятно как мы физичски получаем
этот резултат

	# getent hosts host1.dom.loc
	127.0.0.2       host1.dom.loc host1

	# getent hosts 127.0.0.2
	127.0.0.2       host1.dom.loc host1


если запрошенной инфо нет водном плагине
то nss перходит к опросу второго плагина в
списке и так до конца


таким образом можно замтеть важную вещь.
с точки зрения юзер приложения в нашем случае
getent оно понятия не имеет ни о каких днс и прочей
хрени.  с точки зрения юзер приложения ему на вход
постуипил какйто текст (хостнейм) а нашей проге
нужен ип для дальнейшей работе. и оно предает 
этот текст в NSS и пусть оно там разбирается как
преобразовать этот текст в ип.
а nss оно тоже разбираться не собирется. 
оно этот аргумент предает в разные плагины
каждый из которых умеет обращаться к некотроому
виду хранилища данных. плагин анализирует аргумент
после этого плагин формирует нужный запрос
исходя из аругмента и выполняет поиск в базе
данных  с котрой он умеет рабоатть. 
еси скажем у нас плагин file то у него все просто
он берет аргумент и грепает его в файле. 
а если плагин это днс клиент то он создает
запрос более сложно - он формирует параметры днс
записи для запроса. он берет аргумент добавляет
к нему точку и это будет имя днс записи, тип
записи он берет А. и этот запрос он шлет
на днс сервер. получает ответ тоесть запись 
потом вычлняет из нее ип адрес и отдает обратно.
тоесть все нетак просто. 

таким макаром я хоетлкл подчркунуть что файл 
хостс не имеет отношения к днс системе из интернета
никакого. это отдельная база даных со своим
синатаксисами и правилами. 

плагин myhostname интересно работает. он проверяет
равен ли аргумент хостнейму ОС тоесть той хрени
которая лежит в /etc/hostname если да то 
он возвращает  в качестве ип тот ип который 
есть на сетевых карточках компа. очень интернсный
плагин. он полеезен тем что как я раньше писал
что хостнейм из файла хостнейм он неимеет никакой
связи с файлом хостс. а если мы хотим чтобы он 
резолвися в ип то нам нужно в хотс доблвять 
запись. а если мы этого не хотим делать если мы 
не хотим ради этого модифиуицрвать хостс то 
плагин myhostname нам позволяет получть резултат
без модфиикации хостс
забавыйн интернсный плагин

плагин mymachines умеет искать ип среди контйреров
котоырй были заущены через systemd

через гетент тестоваиние всех этих NSS плагинов
идет очень просто

  # getent hosts   хостнейм

и этот хостнейм будет направлен послоедовталеьно
через все плагины в nsswitc.conf
в строке 

hosts:          files myhostname mymachines resolve [!UNAVAIL=return] dns


хочень меняй в нем порядок плагинов.
хочегь убирай их хочешь добавляй


далее подчеруну что для того чтобы юзер приожение
заюзало NSS оно просто напросто долэно
заюзать либц фунции 

	gethostbyaddr()
	gethostbyname2() 

а они уже непосдрественнно юзают NSS
исползовать ли NSS или нет это выбор самого
приожения.

например ping эту подсстму NSS юзает.

а напрмиер dig неюзает. диг вместо этого  формирует
днс запрос и шлет его на тот днс сервер который
мы ему указали.

чтобы узнать юзает ли прога nSS надо проверить
открывается ли файл nsswotch.conf в ходее ее 
выполенияэ

$ strace -e openat ping vasya -c1 2>&1 | grep nssw
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 5

значит ping юзает NSS


я хотел пдодчеркнуть что файлы
  
  /etc/hosts
  /etc/resolv.conf

это на самом деле конф файлы подсистемы NSS
хотя проги котоыре ее не используют тоже 
любят  в них заглядывать

я хотел подчрунуть что какието программы
такие как dig они в ходе своей детатлеьости
реально обращаются сами к днс.

но многие сетвые прогрммы такие как ping, или ssh

 strace -e openat ssh vasya -c1 2>&1 | grep nssw
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3

они когда получют на входе не ип адрес
а текст то они понятия не имеют ни про какой днс.
для них тот текст что мы в них сунули они 
воспринимают как "какаято текстоая хрень"
и они просто ее отдают скажем в  gethostbyname2()
или в gethostbyaddr() те возможно чуть чуть
модфииицируют аргумент и суют его в NSS 
фунцию. а та особо тоже не парится она 
это все передает в свои nss плагины. а уже 
те анализирует что им передали в аргументе
то ли хостнейм толи ип адрес. и в зависисоти
от этого тем или иным сопосбом ищут инфо
в той базе данных  с котоым этот плагин умеет
раотаьть. эти все базы независимые.
одна база это днс, другая это файл хостс,
это все нзависмые хрени. третья это myhostnmae
четвертая это скажем ldap

тким макармо я хоетел подчернуть тот момент
что файл hosts это ни разу нахрен не днс.
это отдельная база данных со своими стандартами.
это важно понять.

вот интересные тесты.
беру хостс

# cat /etc/hosts
127.0.0.1	localhost

беру 
nsswotch.conf

# cat /etc/nsswitch.conf | grep hosts
hosts:          files

# getent ahostsv4 'localhost'
127.0.0.1       STREAM localhost
127.0.0.1       DGRAM  
127.0.0.1       RAW    
127.0.0.1       STREAM 
127.0.0.1       DGRAM  
127.0.0.1       RAW    

логично

беру
# getent ahostsv4 'localhost.'

ответ пустой. все логично потому что в хостс
нету хостнейма 'localhost.'

тогда я добавляю в nssitwitch.conf следудщий
плагин

# cat /etc/nsswitch.conf | grep hosts
hosts:          files myhostname

повторяю запрос

# getent ahostsv4 'localhost.'
127.0.0.1       STREAM localhost
127.0.0.1       DGRAM  
127.0.0.1       RAW    

тоесть это уже срабтал второй плагин
о том как он работет читай в man nss-myhostname
вот ещеодна прколюха от этого плагина

# getent ahostsv4 '_gateway'
172.16.100.1    STREAM _gateway
172.16.100.1    DGRAM  
172.16.100.1    RAW    
172.16.100.1    STREAM 
172.16.100.1    DGRAM  
172.16.100.1    RAW    

а вот еще прикол

# getent ahostsv4 'kuku.localhost.'
127.0.0.1       STREAM localhost
127.0.0.1       DGRAM  
127.0.0.1       RAW    

а вот еще приколюха от этого плагина

# getent ahostsv4 'kuku.localhost.localdomain.'
127.0.0.1       STREAM localhost
127.0.0.1       DGRAM  
127.0.0.1       RAW    

очень прикьольно!





вопрос как узнать чему равен хостнейм компа
тот который из файла хостнейм

    $ hostnamectl

или

    $ hostname

а вот эта команда делает полную хрень

    $ hostname --fqdn


она берет хостнейм из gethostname()
потом она ищет этот лейбл в хостс который к нему
неимеет никакого отношения. а если находит
то в этой строке берет "канонический хостнейм"
и выводит это на экран как якобы ДНС FQDN что вообще
не имеет никакого отношения к этой штуке!
это пиздец 





а вот следующая приколюха
крупная приклюха!


вот мой nsswitch.conf


# cat /etc/nsswitch.conf | grep hosts
hosts:        



тоесть тут пусто ни одного нсс плагина.


далее я делаю вот так

# dig -4 @127.0.0.53  -t A 'bb.fs'

;; flags: qr aa rd ra ad; 


;; ANSWER SECTION:
bb.fs.			0	IN	A	127.16.100.30


мы точно знаем что диг он нсс неисползует.
да если бы и испольлзовал то у нас неакитиврован 
ни один нсс плагин.


на ип адресе 127.0.0.53 сидит системд-резолвд

так вот зпрос от диг точно летит именно в систед 
резолвд и никуда более.

так вот я считаю что систмд -резволд он пред тем как 
лезить в инет он сам лезет в хостс и ищет там инфо. 
(тоеть он это делает заместо нсс плагина file)
и он там ее находит потмоу что вот мой хостс фаайл


127.16.100.30	bb.fs


тоесть системд резолвд получает от диг запрос на 
днс запись.
и он летез в хостс хотя этот файл ни разу не связан 
с днс и не являтся зоной днс. и он оттуда берет строку
и слепляет из нее типа запись тип-А 
как бутто он считал запись из локальной автортивной 
зоны. и обратно выдает эту хрень да еще под 
флагом АА

это же просто пиздец. это обман!



также я могу из диг направтить вот такой запрос

# dig -4 @127.0.0.53  -t A 'kuku.localhost.localdomain.'

;; flags: qr aa rd ra ad; 

;; ANSWER SECTION:
kuku.localhost.localdomain. 0	IN	A	127.0.0.1


то что я вижу мне доказывает то что систмд-резолвд
также работает как nss плагин myhostname

как тебе такие приколы?


прикол в том что такие проги как пинг или ссш 
они юзают нсс поэтому когда мы им даем текст лейбл

    $ ssh vasya

то они понтия не имеют что это днс домен или 
друая хрень. им все равно для них это некий
текст. они просто отдают это в нссс и все. 
пусть сам разбирается. у нас нет трбования от 
приложения что это имя домена. 


а вот когда мы юзаем диг то раобтает строго по 
стандарту днс и требует в ответ нам отдать именно 
запись днс которая была получена от днс 
сервера который входит в состав  иерархии днс 
сереров интеренета. а наш систмед револвд 
отаедт дигу в ответ хрень которую он прочитал в 
хостс и превратил ее в запись тип -А это же полное 
вранье. да еще он отдает ответ  с флагом АА.
как бутто эти записи хранятс на нем и он за них 
автортиивен!


но еще больштй прикол что если я добавлю 
флаг +norecurse то системд резволд уже неотдаст ничего.

# dig -4 @127.0.0.53  -t A 'bb.fs' +norecurse

;; flags: qr ra; QUERY: 1, 



это что за бред. если днс сервер отдает ответ 
на ркурсивный запрос с флагом АА это значит что 
он якобы хости на себе автортвиную зону.
и если я делаю итеративный зарпос то тогда он 
должен отдасть эту же запиь снова. а он этого 
неделает. что за бред


я считаю что системд может отдавать записи на базе 
хостс при ркурсивных запросах но без флага АА.
а при итертаинвых запросах он не должен отдавть ничего

либо в обоих случаях одтвать записи из хотс с флагом АА
а то что он делает это полная дичь

таким образом системд-резолвд это очень странный
резолвер. с приколами.



как лучше всего помнетять хостнейм из файла
хостейм. 

  # hostnamectl set-hostname vasya

оно поменяет значение и текущее в ядре
и в сам файл хостнейм запишет новое значение
очень удбная штука!



если в nsswirch.conf убрать плагин file
то если я на комп зайду по ssh и потом 
запущу sudo bash
то у меня баш упадет с segfault и получается
преключися в рута не получится



если я вижу такую фигню
$ sudo bash
sudo: unable to resolve host bind-01: Temporary failure in name resolution
[sudo] password for noroot: 

это значит что судо читает gethostname()
а потом ищет его в хостс что дебильно.
поэтому чтобы этого избежать то нужно в хостс
добавить строку в которой будет ип и текст лейбл
совпдааюий с хостнейм из файла хостнейм.





в целом  я думаю я смог хорошо раписать 
что такое файл хостнейм.
что такое файл хостс.
что такое днс.
что между этми тремя хрнеями вобщето нет
никакой связи . ввооббще.

и также еще раз хорошо расписал про NSS

то что творит systemd resolved либо через NSS
свои плагины либо без плагинов это полный прикол!
берет данные из файла хостс который к днс
неимеет никакго отношения и выдает в ответ на 
днс запрос как днс записи! это просто жесть вранья!
приччем отдает не рекурсиный запрос с флагом АА!
как бутто эти записи у него есть в его локальной
автортивной зоне! а при итервтивном запросе не
выдает ничего! это просто супер логика!
также он когда шарится по хостс то он записи 
которые там находит он их воспринимает как 
бутто они все на конце имеют точку. тоесть он 
трактует файл хостс как файл корневой зоны!

