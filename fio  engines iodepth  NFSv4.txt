| fio
| engines
| движки
| архитектура
| под капотом


вначале про чтение запись из обычного файла. как это рабоает.
вначале файло нужно окрыть

   open()

а потом уже над ним делать 

  read()
  write()


так вот в open() мы задаем флаги как мы хотим рабоатть с файлом например мы хотми
еготолько читать или только писать или и то и друогое
и там еще можно ставять интеереныые флаги

  O_ASYNC
  O_SYNC
  O_NONBLOCKING
  O_DIRECT



так вот флаги 

	O_ASYNC
	O_NONBLOCKING

они вобще к работе с обычными файлами нерпименинмы. они работают только на пайпах терминалах
и прочей спецдряни. так что про них можно забыть.
остаются флаги 

  O_SYNC
  O_DIRECT


щас про них поговорим.
так вот если эти флаги я не заюзал в open()
то тогда запись через write() рабоатет вот как.   мы его вызываем и данные просто 
кладутся в пейдж кеш ядра. и ядро возаращает управление на код нашей программы.
а уже потом само ядрокогда то там решает как наши куски засунуть в файл на диск.
если я читаб из файла через read() то данные ищутся ядром не надиске а втомже самом пейджкеш.
если даннных нет или они есь частично то ядро наш процесс усыпляет (блокирует как они говорят)
и только когда данные с диска поуступят в пейж кеш тогда ядро копирует их в память  процесса
куда попрсил read() и плсе этого будит наш процесс чтобы он мог дальше свои команды 
пихать. тот факт что при остутсвии данных ядро усыпляет наш процесс ознаачает что 
команда read() она синхронная. пока данные мы не получим ядро не позволит намшему коду
двигаться дальше. комнда write() тоже получется синхронная. хотя она выглядит якобы как нет.
дело вот в чем. так как запись идет в пейдж кеш тоесть в буфер ядра то она в отлиии от
read() отсреливается как правило мгннвенно. отсда возникает ощущение что она асинхронная.но 
это нетак. если мы будем постянно пихать в пейж кеш данные то рано или поздно мы перввысим
лимит и ядро заблокирует нашу команду пока не сольет наши данные из пейдж кеша на диск. 
в люлом сдучае write() этл синхронная комнада потому что формально она не просыпаеется не возраща
ется из кода ядра пока данные которая она просит записать не будут засунуты в ядро. 
теость она тоже синхронная.

что дает флаг    O_DIRECT он дает то что мы просим чтобы при запуске write()
ядро не пихало наши данные в пйеджж  кеш а просим чтобы оно сразу их пихнуло в диск 
а точнее в его буфер на запись. 


что дает   O_SYNC
мы взыываем write() и ядро анчале запишет наши данные в пейдж кеш но не вернет 
управление в write() а наш процесс будет дальше спать. и дальше ядро сует данные в 
буфер на запис диска. и потом еще ядро просит опустощшить диск свой буфер тоесть
чтобы он нашу запись перенес на пластины.


в любом сулчае все эти шарманки нееняют тот момент что read() write()
это сихноронные операции. тоесть то что если мы просим чтото считать то ядро не верет
управление нашей программе пока недобудет данные которые мы запросили. не будет такого что
мы разместиили этот заказ. ядро приняло заказ. сразу вернуло нашей проге упаврение а потом
позже просто нам прислывает сигнал условно чреез seelect() poll()
и мы тогда узнает что данные подьехали и их можно забрать.
тоже самое с write() мы просим ядро принять от нас даныне и записать их куда надо.
чуть ситуаия полусинхронная. тоесть ядро принмиает наши данные в пейж кеш. если он 
незаполнен (услоно) то даыне будт приняты и правление вернется к нашей проге сразу.
а ядро асипхроннно запишет данные потом кода ни будт  надиск в тоервемя как наша прога
давно уже занимаетс воими делами. но если пейж кеш переполнен то ядро заблокрирует наш
вызов. поэтому write() я бы назвал полуасинхронной командой.

так вот оазкывается что есть и ругие команды работы с  файлоами на диках котоыре
реаьно позволяют делать это асинхроннно. тоесть мы размеаем заказ ядру. он говорит
я ваш заказ принял. уплавнеие переается сразу обратно ангей прорарамме. а ядро
потом просто увеомлет что заказ принять и мы его забиреаем. а между тем как мы заказали
и посутупил сионал что заказ выполнен  наша прога может спокойно выпонять милиарды 
другогого кода.

одна из этих хереней наыватся libaio

# man 3 io

io(3)                                           Linux AIO                                          io(3)

NAME
       io - Asynchronous IO

SYNOPSIS
       #include <errno.h>

       #include <libaio.h>



прикол ее в том что она требует  O_DIRECT флага. иначе все опять будет синхронно.


и есть наконец нормальная асинхронная хрень это io_uring
это сворменнаая блатная штука по настоящему хорошо асинхронная


# man io_uring

io_uring(7)                             Linux Programmer's Manual                            io_uring(7)

NAME
       io_uring - Asynchronous I/O facility

SYNOPSIS
       #include <linux/io_uring.h>




как пшиет нейронка мы созаем два кольца(два конца)
в одно кладем задания в другом получаем ответы и все это асинхронно.
при этом как я понимаю хотя не разбирался уже исползуется не команды

  read()
  write()

а другие.




ЕЩЕ МОМЕНТ. про NFS. 
если мы открывает файл лежаший на NFS то  тогда попытка open() с флагом O_DIRECT
может закончится ошибкой.
я не знаю почему. но вроде как простецкое оьяснение состоит в том что когда мы 
хотим открыть файл который принадлжежит какото файловой сситеме то ядро при открытии
спрашиывет дайрвер ФС умеет ли оно работает с этим флагом. если драйвер фс неумеет то 
ядрошлет нас нахрен. так что поддержка этого флага при октрйтыии файла завсиит от 
поддежки этого флага драйвром этой ФС.





так вот 
у fio есть движки по факту это просто куски кода
которые как раз таки исполуют те или иные походы что я указал при раоботе с файлами


движок sync  
		пишет читает чрезе read() write()
поэтому это синхронный движок. и это означает что через него нельзя задать iodepth>1


движок 	psync
		он юзает pread() pwrite()
		он такиеже как read() write() просто 
		эти команды позволят в своих аргументах задать параметр offset
		для файла а предыдущие команды это делают чрез предварительый вызов seek()
		тлоько и всего.
		тоесть этот движок тоже iodepth>1 несможет



движок  posixaio
        он юзает aio_read()  aio_write()

рабоатет это так. если я задаю iodepth>2 то этабилиотека прсто создает кучу юзер тредов
за меня. каждй из них запускает свой pread() pwrite() и вот так это работает.


движок libaio
	io_setup(2) — создает контекст для запросов.
	io_submit(2) — отправляет пачку запросов в ядро.
	io_getevents(2) — забирает результаты выполненных операций

движое io_uring 
        наконец самый правилый. реально асинхронный. в линксе надо юзать только его.
Вызовы: Основной вызов — io_uring_enter(2). Для настройки используются io_uring_setup(2) и io_uring_register(2).
Механика: Создаются два кольцевых буфера (Submission Queue — куда вы кладете задания, и Completion Queue — откуда забираете результат), которые разделяются (shared memory) между вашей программой и ядром.

ПОЛУЧАЕТСЯ в линуксе если моя цель iodepth=1 то движок sync и флаг --direct=1
что пейж кеш шел нафик.

а если iodepth>1 то движок io_uring и флаг --direct=1




А елси ФРИБСД то в случае iodepth=1 это движко sync
а если iodpeth>1 то это движок  posixaio   только в фрибсд он раатет по другому.
если в линуксе созздаются юзер треды на вызов aio_read() aio_write()
то во фрибсл это треды создаются прям в ядре поэтому это отличное ршеенешение.
толко нужно подгузить модуль чтоб зарабоатло

   # kldload aio


лимиты
sysctl vfs.aio.max_aio_queue_per_proc=65536
sysctl vfs.aio.max_aio_queue=131072


они испольщуются комадами 

aio_read()
aio_write()
lio_listio() — групповой запуск нескольких операций ввода-вывода за один вызов.
aio_fsync() — асинхронная синхронизация данных файла на диск.
aio_readv() и aio_writev() — асинхронные операции с сегментированными буферами (scatter/gather), добавленные в более новых версиях FreeBSD (например, v13+). 


вот пример iodepth>2 через posixaio


fio --name=nfs_test \
--directory=/mnt/nfs_share \
--ioengine=posixaio \
--rw=randread \
--bs=128k \
--size=1G \
--iodepth=32 \
--numjobs=1 \
--runtime=60 \
--group_reporting


если файл лежит на NFS то можно провериить


nfsstat -w 1


Если ты видишь, что количество RPC-вызовов в секунду растет вместе с увеличением iodepth в fio — значит, всё работает. Также можешь использовать top -z, чтобы увидеть системные потоки aiod.


NFSv4

сервер
nfs_server_enable="YES"
nfsv4_server_enable="YES" # Включаем именно V4
nfsuserd_enable="YES"     # Обязательно для маппинга имен
nfs_server_flags="-u -t -n 64" # -n 64 увеличивает число потоков сервера
nfsuserd_flags="-domain mycloud.local"  # Придумай любое имя
nfsuserd_flags="-domain mycloud.local"  # Придумай любое имя

/etc/exports
V4: /exports -network 192.168.1.0/24
/exports/data -maproot=root 192.168.1.5


На сервере: chown ivan:staff /exports/data
На сервере: chmod 755 /exports/data
Теперь, когда ivan зайдет с клиента, nfsuserd увидит запрос от ivan@mycloud.local, сопоставит его с локальным ivan и разрешит запись.

Как проверить, что nfsuserd работает?
Зайди на смонтированную шару на клиенте и введи:
bash

ls -al

Use code with caution.

    Если видишь реальные имена (ivan, root) — всё настроено верно.
    Если видишь nobody или 65534 — значит, nfsuserd не смог сопоставить домены или имена. Проверяй -domain в rc.conf.

    


клиент
nfsuserd_enable="YES"
nfsuserd_flags="-domain mycloud.local"  # Придумай любое имя
