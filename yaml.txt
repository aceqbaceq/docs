yaml

ямль файл. 

1) список имеет несколько равнозначных обозначений 
первый способ
- 1
- 2
- 3

после минуса обязательно пробел

второй способ

- 
  1
- 
  2
- 
  3
 

также тоже самое  толи с точки зрения
ямль то ли с точки зрения json можно обозначить вот так
третий способ

[1, 2, 3]

после запятой обязательно пробел

эти три записи равнозначны.

также можно смешать первый и второй способ

- 1
- 
  2
- 
  3

это как бы равнозначный четвертый способ

это очень важно чтобы в дальнейшем очень хорошо понимать синтаксис ямль файлов

тоже самое про дикшионари.

дикшионари это

a: 1
b: 2

после двоеточия обязательно пробел

равнозначаная запись выгоядит как

a: 
   1
b: 
   2


еще одна равнозначаня запись выглядит как 
 
{a: 1, b: 2}

после двоеточия и запятой обязательно пробел

эти три обозначения дикшионари равнозначны

далее. следущая важная вещь.
заметим что во всех примерах выше вкачестве значений элементов были просто
цифры.

возьмем к примеру список

- 1
- 2
- 3

1 , 2, 3 = это значения элементов  списка.
если значение это просто набор цифробукв 

- 23oir2oiruioto2it2i
- 23ij2o3irji2otj2itoi23
- 095056945960i54906549604i906

то никакой проблемы нет.

вопрос возникает когда значением является не набор цифробукв(стринг) а
другой список, как это обозначается?
самый простой ответ - надо вложенный список обозначить через скобки тоесть 
третьим способом


- [ 4, 5, 6 ]
- 2 
- 3

обозначим тоже самое через смесь первого и второго 

-
  [ 4, 5, 6 ]
- 2
- 3

а теперь превратим это все в первый способ

-
  - 4 
  - 5 
  - 6
- 2
- 3

также можно еще и вот так


- - 4 
  - 5 
  - 6
- 2
- 3

только это ну типа "некрасиво" выглядит . но тоже валидно.



поскольку элементом списка может быть другой список а тот список в свою
очередь может содержать еще список и так до бесконечности 
то нам надо очень хорошо разбираться в обозначении этого.


а теперь соберем всю эту шарманку к виду способа три.

[[4, 5, 6], 2, 3]



таким образом нам надо хорошо уметь понимать как представить
список как в максимально безскобочном (вертикальном) виде
так и в максимально однострочном горизонтальном скобочном виде.

еще пример
- 1

эквивалент
[1]

а вот это 
- [1] 
неявляется его эквивалентом потому что оно раскладывается в

- 
  - 1



сечас я разобрал случай когда список внутри списка внутри списка.
так вот значением элемента списка может быть нетолько другой список 
но и другой дикшионари.
когда значением элемента является нестринг а дикшионари то его обозначают 
тоже через скобки способом три.


пример
- 1
- 2
- {name: task1}


также теперь вобщем то понятно что внутри списка\дикшионари может сидеть 
дофига вложенных список\дикшионари


следующее. выяснилась очень важная вещь.
если у нас есть ямль файл то он может внутри себя содержать
либо один список либо один дикшионари.
ямль файл неможет содержать два списка , или три списка , или сто списков,
или список и дикшионари, или два дикшионари. все это неможет быть 
внутри ямль файла. если мы взяли ямль файл то внутри него либо список
в количестве одна штука. ибольшетам ничего нет
либо внутри дикшионари в количестве одна штука и больше там
ничего нет.
это очень инетресно и очень важно для понимания.


соотвественно ямль файл внутри выглядит либо как
[ ....... ]
либо как
{ ....... }



понятно что структурв внутри это огромный гроб. но сама по себе макрофигня
всегда ровно одна. либо грообразный список либо гробообразный дикшионари.

такого в ямль файле быть неможет

- 1
- 2
a: 1
b: 2

здесь мы имеем один список + один дикшионари. этого небывает.

также это снимает такие вопросы

- 1
- 2

это у нас один список из двух элементов или два списка в каждом
из которых под одному элементу.
ответ: это один список из двух элементов. потому что внутри ямль файла
если там список то он там только один. и кроме него там ничего нет


a: 1
b: 2

это у нас один дикшионари из двух элементов или два дикшионари 
у кажжого из которых по одному элементу.
ответ - это один дикшионии из двух элементов потому что внутри ямль файла
если там дикшиорнаии то он только один и кроме него там ничего больше нет

далее. важно.
поскольку дикшионари обозначается как { ... } в ямль а ансибл в свою очередь
обозначает переменные как {{ имя }} то это требует чтобы переменная 
заключалась в файле в кавычки "{{ имя }}" иначе интерпретатор ямль будет
думать что мы хотим задать +1 суб дикшионари с точки зрения ямль
а мы не это хотим. мы хотим с точки зрения ансибл который базируется
на ямл но также имеет и свой доп синтаксис определить переенную.
это разьясняетя вопрос зачем переменные в ансибл надо брать в кавычки.


пример живого ямль файла


- name: test playbook
  hosts: vagrant5
  gather_facts: false
  become: true

  vars:
    ansible_python_interpreter: "/usr/bin/python3"

  tasks:
    - stat: path=/etc/hosts
      register: host_info

 
для понимания как преобразоывать из одного вида вдругой
по частям преобразуем этот файл.

берем

     - stat: path=/etc/hosts
       register: host_info

это список элементом которого явяется дикшионари
дикшионари в однострочном виде обозначается через фигурные скобки (способ три)
эквивалентный вид

     - {stat: path=/etc/hosts, register: host_info}

подставляем в tasks получаем

  tasks:
    - {stat: path=/etc/hosts, register: host_info}

это дикшонари у которого элементом является список.
преобразуем в вид

  tasks: [{stat: path=/etc/hosts, register: host_info}]


подставляем в исходный

- name: test playbook
  hosts: vagrant5
  gather_facts: false
  become: true

  vars:
    ansible_python_interpreter: "/usr/bin/python3"

  tasks: [{stat: path=/etc/hosts, register: host_info}]
  
  
 берем кусок
  

vars:
    ansible_python_interpreter: "/usr/bin/python3"
	
	это дикшионари у которого элемент другой дикшионари

	преобразуем
	
vars: { ansible_python_interpreter: "/usr/bin/python3" }

подсталвяем в исходное


- name: test playbook
  hosts: vagrant5
  gather_facts: false
  become: true

  vars: { ansible_python_interpreter: "/usr/bin/python3" }

  tasks: [{stat: path=/etc/hosts, register: host_info}]
  
убираем лишние пустые строки

- name: test playbook
  hosts: vagrant5
  gather_facts: false
  become: true
  vars: { ansible_python_interpreter: "/usr/bin/python3" }
  tasks: [{stat: path=/etc/hosts, register: host_info}]

мы видим что это список элеметом у которого яляется дикшионари
преобразуем

- { name: test playbook, hosts: vagrant5, gather_facts: false, become: true, vars: { ansible_python_interpreter: "/usr/bin/python3" }, tasks: [{stat: path=/etc/hosts, register: host_info}] }
 
таким образом теперь есть понимание
как сворачивать в строчку и растягивать в вертикальный вид
один и тот же yaml файл.


----
то что ниже переработать.

насколько я понял и подтвердил экспериментом selectattr 
можно использовать только всегда в связке с list

 selectattr('department', 'equalto',
'Engineering') | list 

без list ничего вменяемого не выведется на экран.











поговорим из чего он состоит

он наполнен двумя сущностями
список и маппинг


список имеет вид

	- рама
	- дверь
	- фундамент

это набор элементов, каждый элемент обозначается как 
   - значение
   
значением может быть число, слово и другой список или маппинг
 
  
маппинг имеет вид

	кошка : черная

кошка это имя мапинга
черная это значение 


значением может быть число, слово и другой список или маппинг

рассмотрим примеры кодгда значение это другой список\маппинг


 - вася
 - 
   - 1
   - 2
   - 3
 - петя
  
видно что вася и петя это простые значения а 
-
  - 1 
  - 3
  - 3

это когда в значении стоит список

еще пример
  - 1
  - вася: 1
  - 3
  
  1 и 3 это когда когда в значении просто число а
  
 - вася: 1

это когда в значении маппинг
  
рассмотрим примеры с маппингом

вася: т:34

у нас в значении стоит маппинг т:34

вася:
   - 1
   - 2
   
 у нас в значении стоит список

поскольку в значении может стоят список\маппинг внтри которого может стоят другой список\маппинг то ямль файл  имеет вид гробов


ПЕРВОЕ ОТКРОВЕНИЕ.

маппинг 

	кошка : черная

также можно записать как
	
	кошка : 
	    черная

и также он может быть записан как

	кошка : 
	    - черная

на счет эквивалентности третьего я не уверен. но ансибл обрабатывает
все три записи абсолютно одинаково. тоесть

вот записи которые ансибл обраабатывает одинаково

---
- name: test
  hosts: vagrant1

---
- name: test
  hosts:
      vagrant1

---
- name: test
  hosts:
     - vagrant1
	

если мы возьмем любой ямль файл то все что внутри у него есть это набор списков и маппингов и больше там ничего нет.

тоесть любой ямль файл выглядит всегда вот так

	- 1
	- 2
	- 3
	
	вася: 1
    петя: 2

	кошка : 
	    черная

	кошка : 
	    - черная
      

все. 


далее.
очень важный момент поговорим что из себя представляет элемент списка или маппинга. 
элементом может быть число , слово или ВНИМАНИЕ другой список\маппинг.
ОБА!
ИМЕННО ИЗ ЗА ЭТОГО ЯМЛЬ файлы имеют вид гробов.

давайте научимся расшифрровать гробы. 

пример гроба

spec:
  containers:
    - name: front-end
      image: nginx
      ports:
        - containerPort: 80
    - name: rss-reader
      image: nickchase/rss-php-nginx:v1
      ports:
        - containerPort: 88
		
разберем

в этом ямле один маппинг spec:
у которого значение это гроб

тоесть исходный ямль можно схематично описать в виде

spec: значение
	
или

spec:
   значение

где значение это гроб

как выяглядит  значение маппинга spec 

  containers:
    - name: front-end
      image: nginx
      ports:
        - containerPort: 80
    - name: rss-reader
      image: nickchase/rss-php-nginx:v1
      ports:
        - containerPort: 88

что из себя представляет данное значение? это еще один маппинг 

containers:
     значение

что из себя представляет значение? это список

    - name: front-end
      image: nginx
      ports:
        - containerPort: 80
    - name: rss-reader
      image: nickchase/rss-php-nginx:v1
      ports:
        - containerPort: 88
		

что из себя представляет элемент1

  -	name: front-end
    image: nginx
    ports:
       - containerPort: 80


в нем три маппинга
name
image
ports


name и image явалются типа классическими маппигами

	name: front-end
	image: nginx

у них значение это просто слово

а у ports у него значение это список из одного элемента

    ports:
       - containerPort: 80

  
на засыпку интересно какая разница

между 

a: 1
b: 2

и 

- a: 1
- b: 2

