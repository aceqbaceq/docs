| iptables
| conntrack



значит берем классический иптбейлс
в ядре есть хуки

  PREROUTING
  INPUT
  OUTPUT
  POSTROUTING


внури хуков у нас правила которые разделены искуст
венно по группам (таблицам)

смотрим на таблицу про цепочки тут

	https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html

или вот тут 

	tables_andreasson-schema.jpg


смотрим на схему по каким цепочкам пойдет пинг 
который влетел к нам на хост и летит к ядру


				[RAW-PREROUTING]      
       					|                
				[MANGLE-PREROUTING]      
       					|             
				[NAT-PREROUTING]      
       					|
       					|
       					|             
      __________(    ROUTING   )
      |         (    DECISION  )    
      |
[MANGLE INPUT]      
	  |          
[FILTER INPUT]   
      |
      |          
   <LOCAL>
   <PROCESS>


наишу по другому 


СЕТЬ - [RAW-PREROUTING] - [MANGLE-PREROUTING] - [NAT-PREROUTING] - [MANGLE INPUT] - [FILTER INPUT] - LOCAL PROCESS


ТАК ВОТ! - если у нас в правилах нет правила который
бы использовал модуль conntrack то ядро непрогоняет
пакет через правила таблицы NAT! тоесть схема не будет
иметь вот эту цепочку [NAT-PREROUTING]
тоесть схема будет такая 

СЕТЬ - [RAW-PREROUTING] - [MANGLE-PREROUTING] - [MANGLE INPUT] - [FILTER INPUT] - LOCAL PROCESS


а теперь показую на практике,
вот таблица правил которая нам позволит поймать
тракт пролета пакета по цепочкам

# cat ipt
# Generated by iptables-nft-save v1.8.9 (nf_tables) on Thu Feb 20 11:33:35 2025
*mangle
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
-A PREROUTING -p icmp -j LOG --log-prefix "[MANGLE-PRE icmp] "
-A INPUT -p icmp -j LOG --log-prefix "[MANGLE-INP icmp] "
-A OUTPUT -p icmp -j LOG --log-prefix "[MANGLE-OUT icmp] "

COMMIT

# Completed on Thu Feb 20 11:33:35 2025
# Generated by iptables-nft-save v1.8.9 (nf_tables) on Thu Feb 20 11:33:35 2025

*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
-A PREROUTING -p icmp -j LOG --log-prefix "[RAW-PRE icmp] "
-A OUTPUT -p icmp -j LOG --log-prefix "[RAW-OUT icmp] "

COMMIT

# Completed on Thu Feb 20 11:33:35 2025
# Generated by iptables-nft-save v1.8.9 (nf_tables) on Thu Feb 20 11:33:35 2025

*filter
:INPUT ACCEPT [26:1776]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [46:3082]
-A INPUT -p icmp -j LOG --log-prefix "[FILTER-INPUT icmp] "
#-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A OUTPUT -p icmp -j LOG --log-prefix "[FILTER-OUTPUT icmp] "
#-A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
COMMIT

# Completed on Thu Feb 20 11:33:35 2025
# Generated by iptables-nft-save v1.8.9 (nf_tables) on Thu Feb 20 11:33:35 2025

*nat
:PREROUTING ACCEPT [2:168]
:INPUT ACCEPT [2:168]
:OUTPUT ACCEPT [34:2278]
:POSTROUTING ACCEPT [34:2278]
-A PREROUTING -p icmp -j LOG --log-prefix "[NAT-PRE icmp] "
-A OUTPUT -p icmp -j LOG --log-prefix "[NAT-OUT icmp] "
-A POSTROUTING -p icmp -j LOG --log-prefix "[NAT-POST icmp] "
COMMIT

# Completed on Thu Feb 20 11:33:35 2025



пускаю снаружи пинг. 
смотрю логи


[RAW-PRE icmp] 
[MANGLE-PRE icmp]
[MANGLE-INP icmp]
[FILTER-INPUT icmp]

тоесть все подтвердилось! если у нас в правилах 
нет правила котоое юзает conntrack модуль то 
прохождения через таблицу NAT  непроисходит. 
скажу еще то что если у нас нет правил юзающих
модуль conntrack то ядро вообще не будет создавать 
коннтрак таблицу. таблица конктов будет пустая.
а что это дает. а это дает то что у нас файрволл
stateless. тоеть для ядра любые пакеты которые вле
тают и вылетают обрабатываются индивидуально согл
асно таблице иптейблс. еще раз -каждый пакет который
даже принадлежит скажем одному потоку тцп когда
он пролетает через иптеблс будет обрабываться 
индиивидуально незавиисимо. как бутто эти пакеты
друг от друга никак не зависят. и пакеты летящие
туда и пакеты летящие в ответ обратно. 
хорошо а что дает введение в строй модуля conntrack
и сование правил иптейблс такого вида

 -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

 -A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT


что оно меняет. оно дает то что ядро начинает 
группировать пакетты которые относятся например 
к какотому тцп потоку для себя в логический 
поток. тоесть когда прилетает следущий пакет
принадлежащий одному и тому же тцп потоку то ядро
это уже понимает. это не просто какйото там еще 
один другой новый пакет. и имея эту статистику по
"потокам" тоест ядро теперь солгасно таблице конн
трак узнает в новых пакетах не просто новые пакеты
а пакеты которые принадлежат уже однму и тожму же
потоку. и сование правил что я вставил выше в 
иптбейлс правила дает то что теперь мы можем раотать
с пакетами на уровен потока а не отдельных пакетов.
например как я указал в паривлах выше мы можем 
уже не прогонять пакет который принадлежит одному 
и тому же потоку через всю цепочку правил в таблице
filter а сразу его "одобрять". это называтся 
statefull фарволл. также имея статситику по конктам
(или потокам) мы можем делать NAT\SNAT\DNAT для
пакетов одного потока (без conntack модуля мы 
получается это делать не можем ибо ядро просто на
просто непрогоняет пакеты через NAT таблицу а 
только в ней можно делать NAT дейтсвия). более 
того прогон пакета по таблице NAT нужен тлько для
первого пакета из потока. далее для всех осатальных
пакетов этого потока ядро автоматом применет NAT 
правила не прогоняя их через правила таблицы NAT.
ядро будет примнеять правила натирования автоматом. 


далее
дополняя картину для исходящего потока. для 
потока который из себя рожает ядро или процесс
и который рвется наружу. OUTPUT поток.
. я покажу какие цепочки  входят в этот тракт.


LOCAL PROCESS - [RAW-OUTPUT] - [MANGLE-OUTPUT] - [NAT-OUTPUT] - [FILTER OUTPUT] - [MANGLE-POSTROUTING]- [NAT-POSTROUTING] - СЕТЬ

так вот если у нас нет в иптеблс правил связанных с
коннтраком то у нас в этой цепине будет правил из 
таблицы NAT тоесть не будет [NAT-OUTPUT], [NAT-POSTROUTING]

тоесть у нас будет 

LOCAL PROCESS - [RAW-OUTPUT] - [MANGLE-OUTPUT] - [FILTER OUTPUT] - [MANGLE-POSTROUTING]- СЕТЬ


ТАКИМ ОБРАЗОМ - я хотел показать и доказать 
мысль о том что если у нас  в  наших правла иптейблс
нет правил свзяннанных с коннтрак то ядро не будет
прогонять пакеты через цепочки из таблицы NAT !
это очень важно знать. без коннтрака в правилах
(непросто модуль загрузить в память а именно обязательно нужно включить хотя бы одно праивило связанное с коннтрак в 
таблицу ипбейлс ) у нас цепочек NAT в нашем тракте
не будет.


а что будет если мы добавим в правила ипейблс правила
с коннтрак.  - добаляем правила что я указал 
выше и смотрим в логах ядра (dmesg -w или journalctl -f)

вначале я напоминаю как выглядит "полная" цепочка
обработки для входящего пакета

СЕТЬ - [RAW-PREROUTING] - [MANGLE-PREROUTING] - [NAT-PREROUTING] - [MANGLE INPUT] - [FILTER INPUT] - LOCAL PROCESS

теперь как выглядит тракт через котоырй протаскиывает
ядро входящий пинг1 через цпочки

[RAW-PRE icmp] 
[MANGLE-PRE icmp]
[NAT-PRE icmp]     <****
[MANGLE-INP icmp]
[FILTER-INPUT icmp]

видно что как только мы доавили коннтракт то у
нас ядро стало протакивать пакет через NAT таблицу
тоесть все совпало.

теперт посмотрим что будет с цепочками через 
ктоый протащит ядро обратный ответный пакет пинга
исходящий.

вначале я привожу "полную" волну цепочек

LOCAL PROCESS - [RAW-OUTPUT] - [MANGLE-OUTPUT] - [NAT-OUTPUT] - [FILTER OUTPUT] - [MANGLE-POSTROUTING]- [NAT-POSTROUTING] - СЕТЬ


а вот лог через какие цепочки ядро реально протаски
вает ответный исходящий пинг1 наружу

[RAW-OUT icmp]
[MANGLE-OUT icmp]
[FILTER-OUTPUT icmp]
[MANGLE-POST icmp]

и мы видим что у нас полностью нет ни одной цепочки
с NAT. почему. потому что этот ответный пинг это 
с точки зрения ядра второй по счету пакет (первый
был входящий) который относится к "потоку пингов"
и ядро применяет к этому второму пакету все те 
правила NAT который оно применило к первому пакету
только в обратном порядке. и делает это ядро уже
автоматом. поэтому протаскивать по таблицам NAT 
второй пакет ненужно. потму что ядру же понятно
какие правила NAT нужно к нему применить! тоест
это незначит что правла не примеябтся! это значит
что ядро уже знает какие правила нужно прмиенять!

теперь посмоитрим как дела обсттоять для третьего
пакета из "потока пингов"
тоесть для 

входящего пинга2
[RAW-PRE icmp]
[MANGLE-PRE icmp]
[MANGLE-INP icmp]
[FILTER-INPUT icmp]

и мы видим что в отличии от первого пинга у нас 
уже и здест нет цеопчки NAT! потому что третий пакет
приандлежит вот тому же потоку пингов к которому
отноится первый пакет. поэтому ядру уже все понятно
какие правила NAT нужно применять и к этому пакету
и ко всем другим пакетам поинадлежащим этому потоку!


ответный пинг2 или пакет четыре из потока пингов
[RAW-OUT icmp]
[MANGLE-OUT icmp]
[FILTER-OUTPUT icmp]
[MANGLE-POST icmp]


здесь тоже как и ожидалось нет ни одног вхождения
в NAT таблицы!

вот оно как михалыч оказывается!

при этом забавно то что  (в контру тому что толко 
что было сказано) иптбейлс по прежнму будет 
протаскивать пакеты принадлежащие к этому потоку
через все осталные правила всех осталных таблиц.
а ведь логично было бы сделать так что если уж
мы протащили первый пакет по цепочкам и правилам
и выработали для него некую стратегию обработки 
то для всех остальных пакетов этого потока АВТОМАТОМ
применять уже эти выработанные правила как для 
первого пакета! но нет! они так неделают. они 
видимо посчитали что это нужно будет для каждого 
потока сохранять в памяти те конкретные правила
которые нужно применять к этому потоку. а это видимо
накладно. поэтому они тупо протактсивают все пакеты
одного и того же поткоа по всем цепочкам и правилам
раз за разом! за исключением правил  таблицы NAT !
вот как они сделали архитектурно. видимо в частноси
они решили а вдруг у нас  праивла поменяются 
в какомто месте. пэтому нужно каждй пакет каждй
раз прогонять по всему тому что есть. если мы 
доабвим какоето новое правило то оно тут же прмиенистя
к следующему пакету в потоке. и только приавла 
в таблице NAT если мы их поменяем (как я понимаю)
уже не влияяют на те потоки котоыре уже влетели в 
комп ранее. для них правла ната применяются ровно 
те котоыре были на компе на момент прилета первого
пакета данного поткоа. 
во как они сделали! а если мы хотим чтобы к потокам
уже имеющиимся заново применились новые NAT правла 
то как я понимаю нужно затирать табицу conntrack


ИТАК:  я хотел показать какое влиенияем имеют
праивила conntrack модуя в списке текущих правил
иптейблс на прохождение пакетами через NAT таблицы
правил.



