| printf 
| UTF
| UTF-8
| UTF-16
| UTF-32
| Unicode

у него в мануале написано хуй знает непонятно что


$ man printf
       \uHHHH Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)

       \UHHHHHHHH
              Unicode character with hex value HHHHHHHH (8 digits)


так вот дело в том что UTF неважно какой он UTF-8/16/32
у него есть две хрени о которых может идти речь.
первая называется "Unicode CodePoint" это число которое поставлено в соотвесвтие символу. 
а вторая хрень это представление символа в виде последовательности байтов.

Дело в том что стандарт построен вот как. взяли таблицу и сделали две колонки. в первой колонке стоит 
порядковый номер 1,2,3, 1000000
во второй колонке стоит символ. вот этот порядоковый номер нзаыватется CodePoint.
это универсально и верно для всех UTF-8/16/32
а дальше сделали вот что. сделали вариативным кодирование кодпоинта в последовательность байтов. 
тоесть в UTF-8 сделали хитро. часть кодпоинтов кодирвется 1 байтом. часть двумя, часть тремя и часть четырьмя.
и получается такая штука что самые частые символы они занимают 1 или 2 байта. и такой текст очень компактный
на диске. но мудота с вариативностью.

UTF-16 сделали вот как. код поинт кодирчется либо 2-мя либо 4-мя байтами отсюда плюсы и минумы
UTF-32 кодрует все кодпоинты через 4 байта.

код поинт во всех UTF один и тот же. таблица код поинтеов одна и таже. разлиачается байтое представление.
и конечно же насколько  понимаю если скажем мы возьмем некую двухбайтовую хрень из UTF-8 то она 
как я понимаю не будет кодировать тот же код поинт что эти же 2 байта в UTF-16.
хотя я не проверял. на компе в линуксе установлена UTF-8.
так вот я возвращаюсб к принтф и его дебилному мануалу.

когда я ссмотрю на их запись	
	 \uHHHH
или
	 \UHHHHHHHH
я не могу понять эт числа это что кодпоинт? или это уже байтовое предсталавние?

метдом пратктического тыка я вычяснмил что обе хрени это КОДПОИНТ! и это он указан в hex виде.
и разница этих опций у принтф тлоько в том что опция \u позоволяет печаать символы с код поинтами
номер которого не превышает два байта то есть от 0 до 2^16=65536 а опция \U позвоялет печатать 
уже все код поинты с любыми номерами. 
щас я это покаэу докажу 


 $ printf "\u0402\n"
Ђ
$ printf "\U00000402\n"
Ђ

тоесть мы поулиили на экране один и тот же символ. соосвттенно если код поинт имеет  размер два байта
то для \U просто дблавяляем неулей . но это и понятно просто напросто это же число скажем 
	0x0402 = 1026(dec)
и просто напросто оно заниает два байта. а четырехбайтовом предтславлении просто слева добалвляется два 
нулевых байта. вот и все.
так они бы суки в мане хотя бы пояснили. что надо подставлять и какая разница

и щас я покажу что у них у обоих одинаковое байтовое представление


$ printf "\U00000402" | od -t x1
 d0 82
$ printf "\u0402" | od -t x1
d0 82

кстти в \U если код поинт кроткий то нули можно лидирующие и не вставлять. и так работает
$ printf "\U0402\n"
Ђ

тоесть я бы скммарно скаазал так что чтобы не задумываться всегда юзай \U подойдет лбой код
поинт и ненужно ни очем думать

а вот кстати он отлично трехбайтовый код поинте печатает
$ printf "\U1038C\n"
𐎌

опять же что удобно ненужно слева набивать нули до четырех байтов. очень удобно по уму сделано

еще ради интереса посмотрим стрейсом как баш запускает execve
с разными скобками и без

$ strace -e execve printf "\U1038C\n" 2>&1 | grep execve
execve("/usr/bin/printf", ["printf", "\\U1038C\\n"], 0x7ffce6c001b8 /* 69 vars */) = 0

$ strace -e execve printf '\U1038C\n' 2>&1 | grep execve
execve("/usr/bin/printf", ["printf", "\\U1038C\\n"], 0x7ffef9e022b8 /* 69 vars */) = 0

$ strace -e execve printf \U1038C\n 2>&1 | grep execve
execve("/usr/bin/printf", ["printf", "U1038Cn"], 0x7ffc077ea748 /* 69 vars */) = 0

и вот третий случай инетерсен я не поставил скобки и бащ запустид принтф с аргументом 
	U1038Cn
соовственно такой вызывао принт закончится ошибкой. потому что он не понимает что это за аругмент U
также видно что баш обрезал \n до n

 $  printf \U1038C\n 
U1038Cn 

дело в том что без скобок баш делает анализиурет строку. и он счиатет что мы через "\" экранируем некие
спецсимволы. применение экрана на ообыкноенный символ  \U  в итоге даст просто символ U
поэтому баш выкинул слэши ив аргумнт подставил уже просто символы. а если мы хотим без скобок все таки слэш 
пропихунть варгумент тогда надо слэш проэкранироавать. тогда он пройдет

$ printf \\U1038C\\n 
𐎌

$ strace -e execve printf \\U1038C\\n 2>&1 | grep execve
execve("/usr/bin/printf", ["printf", "\\U1038C\\n"], 0x7fff1cf700f8 /* 69 vars */) = 0

 
