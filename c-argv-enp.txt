| c
| argv[] 
| envp[]

вопрос:
	да но согласись что можно было вообще обоайтись без argc.  а просто напросто первый элемент сохранять в фиксированном адресе в стеке напрмиер ebp+8. а конец массива задаетс через NULL элемент. и тогда мы прекрасно знаем и где первый эелмент и где конец. и тогда argc как бы и ненужен

значит суть вопроса - суть вопроса о том как у нас происходит передача аргументов при старте
от одно программы к другой. я буду этот вопрос рассматривать с хвоста. с обратного порядка.

значит известно вот что - известно то что этот порядок задается через документ 

	  System V ABI для процессора x86

вот там и прописано. 
в частности там прописано что вот у нас есть процесс. там есть код который выполняется.
и мы хотим в рамках этого процесса запустить другой код через execve() 
тогда в рамках этого процесса ядро заменит код нашей программы кодом другой программы.
так вот при этом можно той вызываемой программе передать на старте параметры. 
а именно массив аргументов и массив переменых окружения. вопрос - а как же это делается?
так вот документ 

	  System V ABI для процессора x86

он предписывает как это делать. 
значит наша вызывающая программа должна создать два массива. один массив будет отвечать
за аргументы. а второй массив будет отвечать за перменные окружения. далее наша взывающая
программа при запуске exeсve() туда укажет эти два массива.  и тогда эти два массива 
они будут ядром переданы в новую программу. особым образом. и если та программа понимает 
что такое  договор об "System V ABI для процессора x86" то та программа при старте 
она будет знать где и как искать эти два массива. 

итак как нужно готовить первый массив аргументов перед запуком execve().
в этом массиве нужео чтобы каждый элемент был поинтер. этот поинтер доллжен указывать на 
стринг тость массив чаров который должен заканчиваться 0х00 байтом.
так вот каждый аргумент он является эоементом такого массива.  execve() ему плевать
на что будут поинтеры указывать. ему главное чтобы ты ему подсунул массив поинтеров. но 
вобще то ABI предпсывает чтобы поинтеры каждый из них указывал на поинтер на стринг.
так вот еще execve() он еще подсовывает новой программе доп параметр argc в котоом
он новой программе обьсяняет в явном виде сколько элементов в массиве.  

ровно по такой же схеме готовится массив для переменных окружения. опять же это массив состоящий
из элементов  каждый из котоорых явялется поинтером. опять же каждй поинтер соглансо systemv ABI
должен иметь вид стринга. который заканяиывается 0х00 байтом. и еще такой стринг он должен 
иметь внутри особый вид 

         KEY=VALUE

возникает вопрос извиниет  а согласно какой кодировки оно должно так быть? пока это мутно
но вроде согласно ии ровно такой кодиоовке с которой работает программа котору мы запускаем
чтобы главное она поняла. 
ну и вот я спросил у  ИИ - а почему ядро для массива аргументов создает паарметр argc в котром
указыет число элементов а для массива переменных окружения нет. 
ну и ИИ написал что типа того что массив аргументов это важная хрень а массив переменных 
окружения это вещь второстепенная. тоесть для работы программы реально важны аргументы. 
от них завиисит ее работа. а вот массив пееренных окружения это вещь реально третьестепенная.
и вобщем так давно истрически завеедено.  просто дело в том что чисто технически программа
которая будет читаь оба массива - она может путем доп усилий сама опредеелить сколько 
элементов в обоих массивах. а ксатти я вспоминил вот такой кусок кода который я подсмортрел
и сам применяю часто 

      if(argc != 2)
    {
    printf("\n Usage: %s </path/to/file> \n",argv[0]);
    return 1;
    }

тоесть как и сказал ИИ что многие программы уже как бы ожидают что ядро им обязатеьно выдаст
переенную argc и поэтому имено на основе существоавания этой пременной проги проверяют
сколько элементов в массиве argv[] . тоесть проги сами руками не проверяеют реальное 
число в массиве argv[] а они полагаются именно на выдаенное ядром  перенменную argc. в коотоой
ядро бьет себя пяткой о том что число элементов в массиве аргументов равно argc.
вобщем получается многие прогаммы обязательно ожидают налчиия этой пременной и полагаются
на ее существоавние в своей работе.

еще раз скажу что и  в массиве аргументов и в массиве переменных окружения у нас же стринги
должны быть. так вот еще раз про кодировку - что главное чтобы пограмма которую мы вызываем
она понимала кодировку в которой ей подсунули. тоесть требований к кодировке нет. главное 
чтобы программа-1 (которая вызывает программу-2) закодировала стринги в той кодрровке которую
поримает прогиамма-2 и все. самому execve() на это совсем все равно.

покажу ксати как выглядит этот вызов через си

 int execve(const char *pathname, char *const _Nullable argv[],
                  char *const _Nullable envp[]);


значит нужно пеедать три константы (хотя можно чтобы это были и не когнстанта)
это стринг который путь к файлу бинарника,  и два массива - один с аругументами а второй
массив с переменными окружения

