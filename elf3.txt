| ELF



### Разница между секциями `.got` и `.got.plt`:

1. **.got** — **Global Offset Table**:
   - Это таблица, которая используется для хранения адресов глобальных переменных и функций, к которым программа обращается во время выполнения.
   - В этой таблице хранятся реальные адреса функций и данных после того, как динамическая линковка разрешила все символы и функции.
   - В процессе выполнения программы значения в таблице GOT будут изменяться, если ссылаются на динамически связываемые функции или данные.

2. **.got.plt** — **GOT для PLT**:
   - Это особая часть таблицы GOT, которая используется для хранения адресов **функций**, которые ещё не были разрешены в момент старта программы.
   - Эта таблица используется для функций, которые вызываются через **PLT (Procedure Linkage Table)**, то есть для динамически связываемых функций, которые на момент загрузки не имеют адреса.
   - В начале выполнения программы адреса в `.got.plt` не будут разрешены, и они будут указывать на код в PLT. Когда программа выполняет первый вызов функции, загрузчик динамических библиотек заменяет значения в `.got.plt` на реальные адреса функций, что позволяет последующим вызовам использовать уже разрешённый адрес.

### Основные различия:

- `.got` — хранит **разрешённые** адреса (включая данные и функции).
- `.got.plt` — хранит **неразрешённые** адреса для функций, которые будут разрешены через PLT на первом вызове.

### Где находится GOT таблица?

- **.got** — это основная таблица, которая хранит **окончательные** адреса глобальных данных и функций. Она будет использоваться в процессе выполнения программы, и все динамически загруженные функции после разрешения будут указывать на реальные адреса в этой таблице.
  
- **.got.plt** — это специальная таблица GOT, которая хранит **неразрешённые** адреса для динамически связываемых функций, которые будут разрешены в процессе выполнения через PLT.

### Пример работы GOT и GOT.PLT:

1. **До загрузки программы**:
   - В таблице `.got` может быть пусто, или там могут быть заглушки для глобальных переменных и функций.
   - В таблице `.got.plt` будут храниться заглушки для динамических функций, которые нужно разрешить. Адреса в `.got.plt` будут указывать на код в **PLT**.

2. **Во время первого вызова функции**:
   - Когда программа вызывает динамически линкованную функцию (например, `puts`), она сначала обращается к записи в таблице `.got.plt`, которая указывает на код в PLT.
   - В PLT выполняется код, который вызывает загрузчик динамической библиотеки для поиска фактического адреса функции.
   - Когда адрес функции найден, он сохраняется в таблице `.got.plt`, и в дальнейшем таблица `.got` будет использовать этот адрес.

3. **После того, как адрес функции был разрешён**:
   - Адрес функции теперь записан в таблице `.got`. Для последующих вызовов функции в таблице `.got` будет находиться её реальный адрес, и PLT уже не будет использоваться.

### Как это выглядит в секциях ELF:

При выполнении команды `objdump` на линкованном ELF-файле с динамическими зависимостями, вы можете увидеть секции `.got` и `.got.plt` (если это применимо) как отдельные области памяти. Эти секции будут содержать **адреса** (или их заглушки), которые указывают на глобальные переменные или функции.

### Пример:

Для программы, слинкованной с динамическими зависимостями, такой как ваша, можно увидеть что-то вроде следующего в выводе `objdump`:

```asm
Disassembly of section .got.plt:
   0x08048400 <_start+0>:  jmp    QWORD PTR [rip+0x200]
   0x08048406 <_start+6>:   push   0x0
   0x0804840b <_start+11>:  jmp    0x804830 <puts@plt>

Disassembly of section .got:
   0x0804a000: 0x00000000  // тут может быть значение адреса после разрешения функции
```

- `.got.plt` будет содержать переходы на код, который вначале занимается разрешением адреса функции.
- `.got` будет хранить окончательные адреса, после того как они были разрешены.

### Подытожим:

- **.got** — таблица, в которой хранятся **окончательные** адреса (например, адреса глобальных переменных и функций).
- **.got.plt** — часть GOT, которая хранит **неразрешённые** адреса для динамически связываемых функций, которые будут разрешены через PLT во время выполнения программы.






=====

PLT
 # ᡋ  $ objdump -j .plt  hello.exe -d -M intel

Disassembly of section .plt:

08049020 <__libc_start_main@plt-0x10>:
 8049020:   ff 35 f8 bf 04 08       push   DWORD PTR [0x804bff8]
 8049026:   ff 25 fc bf 04 08       jmp    DWORD PTR [0x804bffc]
 804902c:   00 00                   add    BYTE PTR [eax],al
   ...

08049030 <__libc_start_main@plt>:
 8049030:   ff 25 00 c0 04 08       jmp    DWORD PTR [0x804c000]
 8049036:   68 00 00 00 00          push   0x0
 804903b:   e9 e0 ff ff ff          jmp    8049020 <__libc_start_main@plt-0x10>

08049040 <puts@plt>:
 8049040:   ff 25 04 c0 04 08       jmp    DWORD PTR [0x804c004]
 8049046:   68 08 00 00 00          push   0x8
 804904b:   e9 d0 ff ff ff          jmp    8049020 <__libc_start_main@plt-0x10>
 





GOT.PLT
 $ objdump -j .got.plt  hello.exe -d -M intel
0804bff4 <.got.plt>:
 804bff4:   00 bf 04 08 00 00       add    BYTE PTR [edi+0x804],bh
 804bffa:   00 00                   add    BYTE PTR [eax],al
 804bffc:   00 00                   add    BYTE PTR [eax],al
 804bffe:   00 00                   add    BYTE PTR [eax],al
 804c000:   36 90                   ss nop
 804c002:   04 08                   add    al,0x8
 804c004:   46                      inc    esi
 804c005:   90                      nop
 804c006:   04 08                   add    al,0x8
 


GOT
$ objdump -s -j .got  hello.exe 
Contents of section .got:
 804bfe8 00000000 00000000 00000000           ............    
 


------------


### Шаг 3: Смотрим на секцию `.plt`

Рассмотрим содержание секции `.plt`:

```
08049040 <puts@plt>:
 8049040:   ff 25 04 c0 04 08       jmp    DWORD PTR ds:0x804c004
 8049046:   68 08 00 00 00          push   0x8
 804904b:   e9 d0 ff ff ff          jmp    8049020 <__libc_start_main@plt-0x10>
```

Когда программа вызывает функцию `puts`, она обращается к адресу в секции `.plt`, который, в свою очередь, указывает на правильный адрес в `.got.plt` (в частности, на адрес `0x804c004`).

1. **Первый шаг**: `jmp` по адресу, который находится в таблице GOT (Global Offset Table). В данном случае это адрес `0x804c004` — адрес в секции `.got.plt`, который указывает на фактический адрес функции `puts` в динамической библиотеке.
   
2. **Второй шаг**: Пушим аргумент в стек (в данном случае это строка `"Hello, world!"`, то есть аргумент для `puts`).

3. **Третий шаг**: Переход на более высокую инструкцию в секции `.plt` для обработки вызова.

### Шаг 4: Секция `.got`

Теперь давайте заглянем в секцию `.got`. Секция `.got` используется для хранения адресов внешних функций и других глобальных данных, которые могут быть изменены во время выполнения программы.

```
Contents of section .got:
 804bfe8 00000000 00000000 00000000           ............ 
```

Этот участок памяти содержит адреса, которые могут быть обновлены в процессе связывания. Вначале в таблице `.got` для `puts` может быть записан нулевой адрес, который затем будет обновлён с реальным адресом функции в динамической библиотеке при первом вызове через `.plt`.

Когда программа начинает выполнять функцию через `.plt`, она пытается получить адрес функции через запись в `.got` и обновить её с реальным адресом функции `puts`.

### Шаг 5: Разрешение адреса функции

При первом вызове функции из библиотеки (например, `puts`), система производит следующий процесс:

1. Переход по инструкции `jmp` в `.plt`, которая указывает на соответствующий адрес в `.got.plt`.
   
2. Если в `.got` ещё не записан адрес для этой функции, программа выполняет вызов через `__libc_start_main`, который инициализирует загрузку и связывание библиотеки.

3. После успешного связывания адрес функции `puts` будет записан в соответствующую ячейку в `.got`.

4. В дальнейшем программа будет использовать этот уже разрешённый адрес для вызова `puts`, минуя секции `.plt` и `.got`, что ускоряет дальнейшие вызовы функций.

### Шаг 6: Переход на реальную функцию

После того как адрес функции был разрешён, программа может перейти на реальную функцию `puts` в динамической библиотеке.

- Сначала выполняется переход на адрес в `.got` (который теперь содержит реальный адрес `puts`), и выполнение переходит непосредственно в код `puts` из библиотеки.

### Шаг 7: Выполнение `puts`

Теперь программа вызывает `puts` в динамической библиотеке, которая выводит строку `"Hello, world!"` на экран.

### Итоговый процесс

1. В начале, при первом вызове `puts`, выполнение переходит в `.plt`, где происходит джамп на адрес в `.got.plt`.
2. В `.got` может не быть записан реальный адрес `puts`, и тогда происходит динамическое связывание.
3. Когда адрес разрешён, он сохраняется в `.got`, и в дальнейшем для вызова `puts` используется уже этот адрес.
4. При последующих вызовах `puts` программа использует напрямую адрес из `.got`, минуя `.plt`.

Так работает механизм динамического связывания с использованием `.got`, `.plt` и `.got.plt` в 32-битных ELF-исполняемых файлах.

---
имею два файла на си


$ cat hello.c  f.c


// hello.c
void f(void);

int main() {
    f();
    return 0;
}


// f.c

#include <stdio.h>

void f(void) {
    puts("Hello, world!");
}


здесь важный момент.   : план о чем надо расскзаать
  1) как скопилироваьт прогаимму остоязющую из неокльких си айлов
  2) ебала с f.h
  3) -no-pic 
  4) makefile

5) ксатаии можно все откопиилирвать статичски
  538  gcc -c hello.c f.c 
  539  gcc -o hello.exe hello.o f.o -static

  ---
  elf формат как он грузится в память
elf формат как рабоает динамическая линковка фукнций?

 
---

смотри возвращаемся к GOT, PLT
вот я имею 32 бит элф файл.

вот его секция с функцией f()
08049166 <f>:
 8049166:   55                      push   ebp
 8049167:   89 e5                   mov    ebp,esp
 8049169:   53                      push   ebx
 804916a:   83 ec 04                sub    esp,0x4
 804916d:   e8 1f 00 00 00          call   8049191 <__x86.get_pc_thunk.ax>
 8049172:   05 82 2e 00 00          add    eax,0x2e82
 8049177:   83 ec 0c                sub    esp,0xc
 804917a:   8d 90 14 e0 ff ff       lea    edx,[eax-0x1fec]
 8049180:   52                      push   edx
 8049181:   89 c3                   mov    ebx,eax
 8049183:   e8 b8 fe ff ff          call   8049040 <puts@plt>     <====== 
 8049188:   83 c4 10                add    esp,0x10
 804918b:   90                      nop
 804918c:   8b 5d fc                mov    ebx,DWORD PTR [ebp-0x4]
 804918f:   c9                      leave
 8049190:   c3                      ret

меня интересует процесс динамической линковки. тоесть пошагово как она работает
начиная с команды
 8049183:   e8 b8 fe ff ff          call   8049040 <puts@plt>


также мы знаем что  puts это динамическая функция
$ readelf  --symbol  hello.exe  | grep -E "table|Value|puts"
Symbol table '.dynsym' contains 7 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.0 (3)
Symbol table '.symtab' contains 29 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
    15: 00000000     0 FUNC    GLOBAL DEFAULT  UND puts@GLIBC_2.0


и и в таблице .rel.plt написано что что адрес этой дин функции можно будет найти 
по адресу 0804c004 
$ readelf -r ./hello.exe
..
..
Relocation section '.rel.plt' at offset 0x3b4 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804c004  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0

ксатти адрес GOT таблицы
$ nm ./hello.exe  | grep  804bff
0804bff4 d _GLOBAL_OFFSET_TABLE_


вот его таблицы GOT, PLT, GOT.PLT

PLT
 # ᡋ  $ objdump -j .plt  hello.exe -d -M intel
08049020 <__libc_start_main@plt-0x10>:
 8049020: ff 35 f8 bf 04 08     push   DWORD PTR [0x804bff8]
 8049026: ff 25 fc bf 04 08     jmp    DWORD PTR [0x804bffc]
 804902c: 00 00                 add    BYTE PTR [eax],al
  ...

08049030 <__libc_start_main@plt>:
 8049030: ff 25 00 c0 04 08     jmp    DWORD PTR [0x804c000]
 8049036: 68 00 00 00 00        push   0x0
 804903b: e9 e0 ff ff ff        jmp    8049020 <_init+0x20>

08049040 <puts@plt>:
 8049040: ff 25 04 c0 04 08     jmp    DWORD PTR [0x804c004] # 0x804c004=GOT, [0x804c004]=0x08049046
 8049046: 68 08 00 00 00        push   0x8
 804904b: e9 d0 ff ff ff        jmp    8049020 <_init+0x20>
 


GOT.PLT  (походу именно эта секция это GOT table а не в секции .got)
 $ objdump -j .got.plt  hello.exe -d -M intel
0804bff4 <.got.plt>:
 804bff4:   00 bf 04 08 =  0x0804bf00
 804bff8:   00 00 00 00 =  0x00000000   
 804bffc:   00 00 00 00 =  0x00000000         
 804c000:   36 90 04 08 =  0x08049036                 
 804c004:   46 90 04 08 =  0x08049046     <======  вот здесь якобы искать адрес puts              

то что тут находится в реальности при запуске процесса
 804bff4:  0x0804bf00  
 804bff8:  0xf7ffda20  
 804bffc:  0xf7fd8f10  
 804c000:  0xf7d87c10
 804c004:  0x08049046  <======  вот здесь якобы искать адрес puts

 gdb читает таблицы .dynsym и syntab и тоже знает что  в 804c004 нужно искат адрес puts
 только gdb называет эту ячеку почему то puts@got.plt  а увидеть это можно вот так

  x /1xw 0x804c004
0x804c004 <puts@got.plt>: 0x08049046

тоесть почемуто он этот адрес назыает не puts@GLIBC_2.0  а puts@got.plt хуй знает почему




 

GOT
$ objdump -s -j .got  hello.exe 
Contents of section .got:
 804bfe8 00000000 00000000 00000000           ............    
 


вопросы:
ты пишешь 

8049040: ff 25 04 c0 04 08       jmp    DWORD PTR [0x804c004]
Здесь происходит переход по адресу, который содержится в GOT (Global Offset Table). GOT — это таблица, в которой хранятся адреса всех глобальных переменных и функций.

я вижу что  адрес 0x804c004 лежит в секции GOT.PLT
а ты пишешь что это GOT таблица. так что реально таблица GOT внутри файла эльф лежит в 
секции GOT.PLT ?


---
Когда вы видите такой вывод в GDB:

```
0x804c004 <puts@got.plt>: 0x08049046
```

Это означает, что по адресу `0x804c004` хранится указатель на функцию `puts`, и эта функция находится по адресу `0x08049046`.

### Пояснение:
1. **`puts@got.plt`** — это просто аннотация в GDB, которая означает, что данный символ (`puts`) относится к таблице `.got.plt`. То есть, это информация о том, что `puts` — это динамическая ссылка, которая будет разрешена через таблицу GOT (Global Offset Table) и таблицу PLT (Procedure Linkage Table) в процессе выполнения программы.

2. **Что такое `.got.plt`?**
   - **`.got.plt`** — это секция в ELF-файле, содержащая глобальную таблицу смещений (GOT), которая используется для разрешения адресов динамических функций. Когда программа вызывает динамическую функцию, она обращается к этому адресу, который в свою очередь указывает на место в таблице PLT, где выполняется дальнейшая обработка вызова (например, загрузка адреса функции из динамической библиотеки).

3. **Как работает разрешение?**
   - При запуске программы таблица GOT и PLT обычно не содержит актуальных адресов для динамических функций, таких как `puts`. Они будут разрешаться динамически во время выполнения программы.
   - Вначале таблица GOT содержит адресы, которые указывают на код в таблице PLT. Когда программа вызывает функцию через GOT, она сначала выполняет код в PLT, который в свою очередь, разрешает настоящий адрес функции в библиотеке.

4. **Что мы видим в GDB?**
   - `puts@got.plt` указывает на адрес в таблице GOT, который на момент начала работы программы содержит указатель на код в таблице PLT, который в свою очередь будет ссылаться на настоящий адрес функции `puts`.
   - В вашем случае, на адресе `0x804c004` (в таблице GOT) находится значение `0x08049046`, что указывает на местоположение кода в PLT, который будет выполнить дополнительные шаги для разрешения адреса функции.

### В GDB:

- Когда вы выполняете команду:
  ```
  x /1xw 0x804bff4+16
  ```
  Это отображает 4 байта, которые содержат адрес, на который будет направлен переход (в данном случае это адрес в таблице GOT для функции `puts`).
  ```
  0x804c004 <puts@got.plt>: 0x08049046
  ```
  Это означает, что по адресу `0x804c004` находится значение `0x08049046`, которое указывает на код в PLT (функция `puts`).

### Как это работает в процессе выполнения:

1. Когда программа выполняется и достигает точки вызова `puts`, она сначала выполняет команду в таблице PLT.
2. Код в PLT будет использовать таблицу GOT, чтобы получить адрес функции `puts` в динамической библиотеке (например, в `libc`).
3. На первом вызове PLT для функции будет выполнен код, который загрузит настоящий адрес функции в таблицу GOT, и этот адрес будет использоваться для последующих вызовов.

### Пример:
- Таблица GOT:
  - До первого вызова: по адресу `0x804c004` находится указатель на таблицу PLT (например, `0x08049046`).
  - После первого вызова: таблица GOT обновляется, и по адресу `0x804c004` теперь будет находиться настоящий адрес функции `puts` в динамической библиотеке.

### Почему это важно?
Использование GOT и PLT позволяет программе работать с динамическими библиотеками, загружая адреса функций только во время выполнения. Это позволяет, например, использовать общие библиотеки без необходимости на стадии компиляции знать точные адреса функций.

Если функция будет вызвана заново, программа будет обращаться уже непосредственно по тому адресу, который был разрешен и сохранен в GOT.
---
Для того чтобы использовать эту защиту в своем коде, тебе нужно компилировать и линковать программу с поддержкой Intel Control Flow Enforcement Technology (CET) и Indirect Branch Tracking (IBT), например, через опцию -fcf-protection в GCC или Clang.

---
puts = 0xf7de2f60

полезняшки gdb

(gdb) info functions  puts
All functions matching regular expression "puts":

Non-debugging symbols:
0x08049040  puts@plt
0xf7de1580  _IO_fputs
0xf7de1580  fputs
0xf7de2f60  _IO_puts
0xf7de2f60  puts
0xf7decfd0  fputs_unlocked
0xf7ec2040  putsgent
0xf7ecf010  putspent


(gdb) info address puts
Symbol "puts" is at 0xf7de2f60 in a file compiled without debugging.


---
старт проги начинается с Entry point 
$ readelf -h ./hello.exe  | grep Entry
  Entry point address:               0x8049050

в табице символов ищем что за символ кроется по этому адресу
$ nm ./hello.exe  | grep 8049050
08049050 T _start

T - значит что этот элемент сиидит внутри .text секции этого эльф файла
ксатти таблица символов она для запуска процесса из эльф файла и ненужна. так 
чисто для человека справочная зуйня. или дебагеру помогает . но для именно превраещения
кода из элфа в процесс таблица символов нахуй не нужна.


вобщем мы узнали что старт в проге наступает с адреса  0x08049050 который также обозначем
как символ _start 
тогда из gdb можно начать дизассеблчерещ

> disass _start
либо 
> disass  0x08049050


_start


Dump of assembler code for function _start:
   0x08049050 <+0>:  xor    ebp,ebp
   0x08049052 <+2>:  pop    esi
   0x08049053 <+3>:  mov    ecx,esp
   0x08049055 <+5>:  and    esp,0xfffffff0
   0x08049058 <+8>:  push   eax
   0x08049059 <+9>:  push   esp
   0x0804905a <+10>: push   edx
   0x0804905b <+11>: call   0x8049079 <_start+41>
   0x08049060 <+16>: add    ebx,0x2f94
   0x08049066 <+22>: push   0x0
   0x08049068 <+24>: push   0x0
   0x0804906a <+26>: push   ecx
   0x0804906b <+27>: push   esi
   0x0804906c <+28>: lea    eax,[ebx-0x2f77]
   0x08049072 <+34>: push   eax
   0x08049073 <+35>: call   0x8049030 <__libc_start_main@plt>
   0x08049078 <+40>: hlt
   0x08049079 <+41>: mov    ebx,DWORD PTR [esp]
   0x0804907c <+44>: ret
   0x0804907d <+45>: jmp    0x80491a2 <main>


тут мжно замтить вызов фнукции 
 call   0x8049030 <__libc_start_main@plt>

а что это за хрень?
$ nm ./hello.exe  | grep libc_start_main
         U __libc_start_main@GLIBC_2.34

U — символ неопределен (например, ссылка на внешнюю функцию).

смотим рим дальше
$ readelf -r ./hello.exe 
Relocation section '.rel.plt' at offset 0x3b4 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804c000  00000107 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.34  <====
0804c004  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0

и мы видим что  __libc_start_main это оказвыатеся такая фнукция очеивдно недоступная
при процесс компиляияции значит ее в бинарнике. нет. значит он к нам подкгужетается
уже из прималпенного откполиварнного файла. и ее адрес мы найдем по адресу 0804c000

далее у нас есть такая инфо 
тут я малек нихуя не понимаю что это за адреса и что за названия
(gdb) info functions __libc_start_main
Non-debugging symbols:
0x08049030  __libc_start_main@plt
0xf7d87c10  __libc_start_main

пока так накидаю 
(gdb) x /3i 0x08049030 
   0x8049030 <__libc_start_main@plt>:  jmp    DWORD PTR ds:0x804c000
   0x8049036 <__libc_start_main@plt+6>:   push   0x0
   0x804903b <__libc_start_main@plt+11>:  jmp    0x8049020

это точно адрес 0xf7d87c10 внутри примапленного libc.so.6 файла
> info proc mappings
Start Addr   End Addr       Size     Offset  Perms   objfile
...
...
   0xf7d67000 0xf7d86000    0x1f000        0x0  r--p   /usr/lib32/libc.so.6
   0xf7d86000 0xf7f19000   0x193000    0x1f000  r-xp   /usr/lib32/libc.so.6  <== где то здесьь 
   0xf7f19000 0xf7f94000    0x7b000   0x1b2000  r--p   /usr/lib32/libc.so.6
   0xf7f94000 0xf7f96000     0x2000   0x22c000  r--p   /usr/lib32/libc.so.6
   0xf7f96000 0xf7f97000     0x1000   0x22e000  rw-p   /usr/lib32/libc.so.6


из этого куска следует и я проверил

   0x08049073 <+35>: call   0x8049030 <__libc_start_main@plt>
   0x08049078 <+40>: hlt
   0x08049079 <+41>: mov    ebx,DWORD PTR [esp]
   0x0804907c <+44>: ret
   0x0804907d <+45>: jmp    0x80491a2 <main>

что на самом деле если все окей то возврат из  call   0x8049030 <__libc_start_main@plt>
не происходит никоогда. поэтому запуск jmp    0x80491a2 <main> идет каким то другим
путем

это пока все что яхотел тскзать пор функцию __libc_start_main


я далее  я хотепл покзать про GOT,PLT , puts
идем в фнкцию f()
(gdb) disass f
Dump of assembler code for function f:
   0x08049166 <+0>:  push   ebp
   0x08049167 <+1>:  mov    ebp,esp
   0x08049169 <+3>:  push   ebx
   0x0804916a <+4>:  sub    esp,0x4
   0x0804916d <+7>:  call   0x80490a0 <__x86.get_pc_thunk.bx>
   0x08049172 <+12>: add    ebx,0x2e82
   0x08049178 <+18>: sub    esp,0xc
   0x0804917b <+21>: lea    eax,[ebx-0x1fec]
   0x08049181 <+27>: push   eax
   0x08049182 <+28>: call   0x8049040 <puts@plt>   <====
   0x08049187 <+33>: add    esp,0x10
   0x0804918a <+36>: sub    esp,0xc
   0x0804918d <+39>: lea    eax,[ebx-0x1fe6]
   0x08049193 <+45>: push   eax
   0x08049194 <+46>: call   0x8049040 <puts@plt>
   0x08049199 <+51>: add    esp,0x10




видим
   0x08049182 <+28>: call   0x8049040 <puts@plt>   <====

где 0x8049040 это часть .plt таблицы

смотрм что там
=> 0x8049040 <puts@plt>:   jmp    DWORD PTR ds:0x804c004 = jmp [0x804c004]
   0x8049046 <puts@plt+6>: push   0x8
   0x804904b <puts@plt+11>:   jmp    0x8049020


смотрим эту окманду
jmp [0x804c004]
где  0x804c004 эта адре лежазщий  в GOT=.got.plt таблице
смотрим значение в [0x804c004]=  0x08049046

что нас из GOT таблицы взвращает обратно в plt таблицу.
раз мы верулис обратно то тогда 

jmp    0x8049020

эта хрень нас напорявеляет в plt таблицу но вдруу ее секцию

(gdb) x /2i 0x8049020
   0x8049020:  push   DWORD PTR ds:0x804bff8
   0x8049026:  jmp    DWORD PTR ds:0x804bffc

превый пуш пока пропускем.
вттоар строка 

jmp    [804bffc]

где  0x804bffc этообпять же адрес из GOT талблицы
[804bffc] = 0xf7fd8f10
а что это за адрес такой

> info proc mappings
   0xf7fc9000 0xf7fed000    0x24000     0x1000  r-xp   /usr/lib32/ld-linux.so.2

это получается запускается динмамик линкер. 
по идее вот этот пуш

push   DWORD PTR ds:0x804bff8

это передача линкеру прааметра того какую функцию ему надо искать. тока я не понимаю
что ему передается в качестве параметра [0x804bff80] = 0xf7ffda20

видно вот что 

(gdb) x /15i 0x08049020
   0x8049020:  push   DWORD PTR ds:0x804bff8
=> 0x8049026:  jmp    DWORD PTR ds:0x804bffc
   0x804902c:  add    BYTE PTR [eax],al
   0x804902e:  add    BYTE PTR [eax],al

   0x8049030 <__libc_start_main@plt>:  jmp    DWORD PTR ds:0x804c000
   0x8049036 <__libc_start_main@plt+6>:   push   0x0
   0x804903b <__libc_start_main@plt+11>:  jmp    0x8049020

   0x8049040 <puts@plt>:   jmp    DWORD PTR ds:0x804c004
   0x8049046 <puts@plt+6>: push   0x8
   0x804904b <puts@plt+11>:   jmp    0x8049020


видно что puts кладет 0x8 в стек и вызвыает линкер
а __libc_start_main кладет 0 в стек и ввзывает линкер
из чего я делаю выввд что команда 

  push   DWORD PTR ds:0x804bff8 

это часть привязанная к линкеру нежелеи чем к параметрам puts или __libc_start_main
я тока не понимаю как число 0 обьяняет линукеру что надо найти  __libc_start_main
а число 8 обьсняет ему что надо найти puts
это оставим на потом. надо дбавить еще какую то функцию  в программу например sleep()
и посмтреть какой для нее будет push в таблице plt 


а щас мне непонятно куда происходит возврат 
из этой команды

(gdb) x /15i 0x08049020
   0x8049020:  push   DWORD PTR ds:0x804bff8
=> 0x8049026:  jmp    DWORD PTR ds:0x804bffc
   0x804902c:  add    BYTE PTR [eax],al
   0x804902e:  add    BYTE PTR [eax],al

ну пока мне кажетя что по крайней мере удато сюда
Dump of assembler code for function f:
   0x08049166 <+0>:  push   ebp
   0x08049167 <+1>:  mov    ebp,esp
   0x08049169 <+3>:  push   ebx
   0x0804916a <+4>:  sub    esp,0x4
   0x0804916d <+7>:  call   0x80490a0 <__x86.get_pc_thunk.bx>
   0x08049172 <+12>: add    ebx,0x2e82
   0x08049178 <+18>: sub    esp,0xc
   0x0804917b <+21>: lea    eax,[ebx-0x1fec]
   0x08049181 <+27>: push   eax
   0x08049182 <+28>: call   0x8049040 <puts@plt>
   0x08049187 <+33>: add    esp,0x10 <======

и вот я проверчю что стало с записью для путс в GOT таблице
имеем таблицу релокации

 $ readelf -r ./hello.exe 
Relocation section '.rel.plt' at offset 0x3b4 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804c000  00000107 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.34
0804c004  00000307 R_386_JUMP_SLOT   00000000   puts@GLIBC_2.0



x /1xw    0x804c004
0x804c004 <puts@got.plt>:  0xf7de2f60

смотрим что это за адрес
(gdb) info functions puts
      0xf7de2f60  puts


так что в GOT мы имем запись 0xf7de2f60 реального адреса путс


> x /1xw    0x0804c000
0x804c000 <__libc_start_main@got.plt>: 0xf7d87c10

(gdb) info functions __libc_start_main
0xf7d87c10  __libc_start_main


и в GOT имеем реаьный адрес функции __libc_start_main 


---

https://gist.github.com/CMCDragonkai/10ab53654b2aa6ce55c11cfc5b2432a4?permalink_comment_id=3062537

https://users.cs.utah.edu/~aburtsev/5460/hw/hw2-elf/hw2-elf.html


https://lwn.net/Articles/631631/



https://cpu.land/becoming-an-elf-lord

https://ics.uci.edu/~aburtsev/238P/hw/hw3-elf/hw3-elf.html#0

https://lewinb.net/posts/24_elf_linking_and_loading/



https://medium.com/@masjadaan/dynamic-linker-0180aed1acba



https://blog.memzero.de/dynamic-linking-linux-x86-64/

https://maskray.me/blog/2021-09-19-all-about-procedure-linkage-table

https://docs.thecodeguardian.dev/operating-systems/linux-operating-system/understanding-plt-and-got

https://jeffjerseycow.github.io/2017/12/what-are-the-got-and-plt-pt1

https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html






https://mirzafahad.github.io/2021-05-08-text-data-bss/