| arg
| >
| bash

замечу разницу между

  $  prog1 ./file1

и 

  $ prog1 < file1


во втором случае баш  отрывает файл "file1"
потом себя клонирует себя. потом через dup2() привязывает этот откртый файл к fd/0
и потом делает execve(prog1) и мы получаем что у нас  создан файл дескриптор 0 котрый
указывает на файл file1.  но насльно байты из файла внутрь программы незсунуешь . поэтому 
баш свое дело сделал. теперь если в саомй программе есть код котоырй читает из fd/0

   read(0,....)

то внутрь прогаммы попадет содержимое файла file1
вот так будт выглядеть дескриптооры

  0 ---> file1
  1 ---> /dev/tty2
  2 ---> /dev/tty2


таким образом через конструкцию <

    prog1 < file1


мы заставили баш так создать новый процесс чтобы у него доескрипттор 0 смотрел на файл file1
но это еще не гарнетиурет что данные из файла ппоападут внутрь процесса. баш при поомощи
ядра подключил к дескриптору 0 файл. но внутрь файла загнять байты насильно неполучится. нужно
чтобы самкод проецсса  дал команду на чтение из дскриптора 0. 


   read(0,....)


таким образом если внутри процесса в коде есть команда

   read(0,....)

то с помощью  директивы "<"  мы можем  такой процесс заставить проичитать из любого нам нужнго
файла.  


теперь про эту комбинацию

$  prog1 ./file1


она всего навсего дает то что внтрь процесса будут предано то что при запуске процсса 
аргумент1=file1 и все. и больше ничего.

