| dmesg 
| syslog
| kmesg
| journalctl
| systemd-journald.service
| logging


большая статья про то как устроена система логирования влинуксе


прежде чем говорить про dmesg надо расказать о другом.
мы шас будем говрить про логинг системы в линуксе.
первый момент - в ядре есть журнал событий. kernel log. он лежит чисто в памяти ядра.
это место называется kernel log buffer. еще в народе он наывается кернел ринг. он ограничен
по размеру . у меня это 130 КБ. я дальге покажу как узнать его размер. когда он переполняется
то он перезаписывется. в  коде ядра когда там запускетс фнуция

	printk(KERN_INFO "Message: %s\n", arg);

то это ведет к тому что мессага будет записана этот кернел журнал. и также этой мессеге
будет назначен уровень важности кртичности равный указнному KERN_INFO уровню. итак чтобы  в 
журнале появилась запись нужно чтобы в коде ядра был вызван printk() вот откуда в журнале 
ядра берутся записи. помимо журнала ядра запись также может быть также распечатана на так
называемой console (system console). это что за хрень. давным давно кода были мейнфремы
то рядом с ним был ящик называется консоль. это был ящик с монитором и клавой. это называлось
консоль. на ней можно было посмотреть как дела обстоять с этим мейнфйреймом. консоль находилась
физически рядом с телом мейнфрейма. а все осталные юзеры были подклчены к менфрейму
уже через модемы через удаленные терминалы. тоест консоль отличается от терминала
тем что терминал обычно это удаленная хрень от тела мейнфрейма а коснсоот это 
терминал который стоял рядом с мейнфрмом. это может быть такой же термиал только
он стоит рядом. у линукса консолей может быть несколько. щас мы это все коснемся.
так вот - вот мы запулили printk() мессага прилетела в лог ядра. у нее есть уровень
срочности. еще в ядре есть спец переменная

	$ cat /proc/sys/kernel/printk
	1	4	1	4

нам щас важно первое число 1. 
так вот сроночность мессаги задается через  KERN_INFO по сути это число от 0 по 7 
так вот если срочность(номер) нашей мессаги более крутой(тоесть меньше) чем первая 
цифра в /proc/sys/kernel/printk  то тогда такую мессагу ядро нетолько запишет
в кернел лог но и пошлет(напечатает ) на коносль или консоли. положим что у нас

	$ cat /proc/sys/kernel/printk
	4	4	1	4

а наша мессага имеет вид

	printk(3 "Message: vasya \n");

то тогда эта мессага будет записана нетолько в кернел лог (туда запмываются все
мессаги) но направлена на консоль (или консоли) потому что срочность важность
нашей мессаги равна 3. а в линуксе чем более важная мессага тем у нее номер 
меньше. у нас задано выше число 4 а оно бльше чем 3. значит мессагу нужно тиснуть
на console. 

что значат отсльыне цифры

	$ cat /proc/sys/kernel/printk
	4	4	1	4

я пожже коснусь. ксати их можно менять . просто делаем вот так

   # echo " 1 2 3 4 " > /proc/sys/kernel/printk

скажу то последняя цифра определяеяет повеение при загрузке ядра (видимо до
момента запуска init процесса). тоесть у нас это цифра 4. значит при загрузке 
ядра все логи важнее чем уровень 4 ( тоесть 0-3) будут печаататься на консоле.
это мы и видим при загрузке компа. когда на черном экране бегут тексторвые 
строчки. 

как узнать куда напоавлена косоль сейчас

	$ cat /sys/class/tty/console/active 
	tty0

это значит кооснлью на нашем компе является tty0

консоь это устройство сточки зрения ядра (как диск или сетеваякарта) и в юзер
спейсе она видна как 

	/dev/console

тоесть если  я хочу чтото направти на коснсоль я могу сделать

   # echo "123" > /dev/console

сразу скажу что /dev/console это прям самостоятельно устройство а не симлинк на tty0.
проброс на tty0 идет где то там внутри ядра. 


как обьяснить ядру на стадии загрузки какая железка явлется для нас консолью.
для этого в grub надо задать параметр

   console=tty0

можно задать сразу несклоько консолей

   console=tty0 console=tty1

тогда дело будет вот так - ядро будет пихать мессагу сразу на все эти устройтва.
а из юзер спейса если мы будем обращаться к консоли открывая /dev/console то  
у нас будет откртьывться последнее устройствов в строке в данном случае tty1

если мы в параметрах ядра не указали console= в явном виде то по дефолту ядро 
считет что console=tty0

с консолью разобрались. но как я уже скзаал туда попадает только часть логов
ядра. остальное все лежит в кернег буфере. как туда попасть из юзер спейса. 
есть ДВА пути. и НЕСКОЛЬКО  инструментов которые юзают эти пути. 

один способ через который юзер спейс прога может получить доступ до кернел буфера
(кернел журнала) это файл 


	/dev/kmsg

правда доступ к этом файлу требует root прав
вот пример записи в журнале ядра

	$ sudo cat /dev/kmsg | head -n1
	6,579446,2251619882797,-;wlp2s0: send auth to 06:7f:c6:b9:18:cd (try 1/3)

в часотности остой состоит в том что время указано в ебнутом формате. поэтому
удобнее "читать " этот файл через спец утилиту. но об этом дальше.
тут важно сказать что когда мы леезем на  /dev/kmsg то на самом деле мы непопадаем
в сам кернел буфер. как я понимаю мы попадаем в некую хрень в которую копириуюится
данные из кернел буфера. тоесть это некая копия кернел буфера. а что там творится
в самом кернел буфере хрен знает , мы получаем доступ  к вторичной базе данных,
к какойто копии. а первоизсточник остается не доступным. это сущесвтеный момент.
также важный момент что через этот файл даже юзер программа может  добавить запись
в самом кернел ринге. делается это вот так 


   # echo "123 vasya " > /dev/kmsg

открываем один терминал и там вводим

	(term1)  # cat /dev/kmsg 

открываем второй терминал

	(term2) $ echo "123 vasya " | sudo tee /dev/kmsg

и тогда на первом теримнале мы увидим

	12,580192,2293223306122,-;123 vasya


также прикол в том что из /dev/kmsg может одновременно читать куча процессов
и каждоый из них получит свою полную копию. тоесть /dev/kmsg это типа "мультиплексор"
файл. 
доступ к кернел буферу через файл /dev/kmsg считается современным методом


есть еще метод. это через файл 

  /proc/kmsg

доступ к нему тоже тербует прав root
правда опятьт как я понял мы не имемм через нено доступ к самому кернел буферу.
к нему как я понял мы вобще никода и никак не имеет из юзер спейса доступа. 
файл /proc/kmsg это тоже некая копия. мы работаем  с копией. этот файл имеет особен
ности. вот если мы читаем из /dev/kmsg то сколько бы мы из него ни читали это никак
не влиет на его контент. он там как был так и есть.  а если я читаю из /proc/kmsg
то вот сколько байт я оттуда считаю то они оттуда сразу исчезают. тоесть это 
работает как бутто мы из пайпа читаем. все что считали там уже нет. это дает то 
что если несколко процессов одновременно открывает этот файл и будут пытаться из 
него читать конкурирую друг с другом то они будут получать куски того что там
лежит. тоесть мультиплексии нет на этом файле. доступ к копии кернел журнала через
этот файл считается более древним и устаревши. еще раз скажу что если мы с него
считали строчку то при повтонорном обращении ее там уже не будет. также писать 
чтото в этот файл ( в отличии от /dev/kmsg) нельзя. 


в чем же разница между  /dev/kmsg  и  /proc/kmsg  .  что лежит в самом кернел
буфере хрен знает. то что лежит в /dev/kmsg это полная копия кернел буфера.
в /proc/kmsg лежит изначально тоже копия кернел буфера но то что мы оттуда читаем
оно в этом же обьеме сразу оттуда удаляется. если в оригинальный буфер добавляются
новые строки то они автоматом и добавляются в этот файл. 

если мы представим кернел лог как бескнечную простыню то в /dev/kmsg лежат 
последние 130КБ этого лога. через этот файл мы можем всегда узнать как говоирится
хвост этого кернел лога. размер хвоста или окна 130КБ. тоесть если мы хотим  
посмтреть последние 130КБ лога то мы идем в /dev/kmsg
по идее можно открыть этот файл считать все что там есть. а потом если в исходный
лог будет чтото долетать то мы и через этот файл будем это получать. 

файл /proc/kmsg наверно удобней тем что вот мы с него все что там было считали
и мы можем его закрыть. потом при повторном обращении мы можем точно быть уверены
что если там чтото есть то только чтото свежее. что мы до этого не читали. 
там ттолько свежая информация. 

итак  я описал два способа как из юзер спейса получить доступ к копиями ориги
нального кернел лога к котому доступа из юзер сейса нет. есть только доступ к 
копиям. причем как видно доступ несколкьо разный по своему характеру.  

есть и третий путь доступа из юзер спейса к копии кернел ринга
через функцию GLIB Си

       #include <sys/klog.h>

       int klogctl(int type, char *bufp, int size);

а эта функция по факту пуляет в  ядро  сисколл 

 	int syscall(SYS_syslog, int type, char *bufp, int size);

этот сисколл по факту читает из /proc/kmsg. толко он это делает изнутри ядра
тоесть он это читает не из юзер спейса прям из файла /proc/kmsg а он это делает 
сразу из ядерной структуры. тоесть мы не увидим какттого сисколла read (/proc/kmsg)
однако вот что - если у нас /proc/kmsg пустой то вызов  klogctl() не даст ничего.
потому что если в ядре пусто там где лежит структура на которую указывает /proc/kmsg
то и читать нечего. поэтому в приниципе в какото степени что читать из файла 
/proc/kmsg что запустить klogctl() это одно и тоже.

теперь кода все способы загрлянуть в  копии буфер лога ядра я расказал.
теперь про инстурменты которым это можно делать. 


во первых это банально cat

  # cat /dev/kmsg
  # cat /proc/kmsg


во вторых наконец мы дошли до dmesg
по факту эта утилита естсвтенно не может добраться до кренел лога никак иначе
кроме как через один из способов который я указал выше. она читает /dev/kmsg

 $ sudo strace -e openat dmesg 1>/dev/null
   openat(AT_FDCWD, "/dev/kmsg", O_RDONLY|O_NONBLOCK) = 3


теперь в чем прикол этой утилиты. 
первое - у нас контент в керел логе имеет дебильный формат времени. а dmesg
умеет преобразовать и показать время к человеческому виду. показываю

 $ sudo dmesg -T | head -n1
[Пн фев 10 09:36:10 2025] [RAW OUTPUT icmp] ... 

вторая фича этой утилиты что она может отфиьтровать те мессаги которые имеют
опредленный уровень срочности. тоесть вспоминаем printk() он сует нетлоько мессагу
влог но и ее важность. мессаги имеют 7 степеней важности . так вот dmesg позволет
показать мессаги нужной важности 

 $ sudo dmesg -T -l 3 | head -n3
[Пн фев 10 21:10:07 2025] usb 1-1: device descriptor read/64, error -71
[Пн фев 10 21:10:08 2025] usb 1-1: device descriptor read/64, error -71

в этом примере я показыаю только мессаги уровня 3

где потсмреть список этих уровней и что они значат

	https://www.kernel.org/doc/html/latest/core-api/printk-basics.html
    dmesg  --help
    man klogctl

в dmesg можно левелы вставлять через слова а можно прям через цифры

вот и все фишки dmesg  в плане прросмотра кернел лога
в добавок скажу что дмесг также может читать файлы в которых контент в формате
syslog хотя мне кажется эта его фича никому нахуй ненужна. именно иза за этого 
в дмесг есть ключ -f который обозначает --facility это все из мира syslog (который
кстати имеет свой rfc) . там каждая запись в логе имеет нетолько тело и левел 
срочности но и источник записи  - фасилити. с точки зрения анализа кернел лога
там фасилити всегда один это kern . насколко я поимаю вот тарабоарщина которая
стоит вначале каждый записи в себе скрывает нетлоько время и срочность но и 
фасилити. наверно кернел лог формат тоже подчиняется стандарту syslog

	$ sudo cat /dev/kmsg | head -n1
	4,579487,2255145163493,-;[RAW OUTPUT icmp] ...

видимо здесь 4,579487,2255145163493,- это все зашито


ꟙ  $ sudo  dmesg -k  -l3 -T -H
[Пн фев 10 21:10:07 2025] [фев10 21:10] usb 1-1: device descriptor read/64, error -71
[Пн фев 10 21:10:08 2025] [  +0,230089] usb 1-1: device descriptor read/64, error -71

есть еще ключ -k  который явно сообщает дмесг чтобы он читал логи именно
ядра из /dev/kmsg 
ключ -H дает то что у нас сообщеи будут выводены цветные . в зависиомости 
от сровночти мессаги она будет иметь разный цвет.  

есть у этой утилиты и еще одна фишка. вспминаем про настройку в ядре

   $ cat /proc/sys/kernel/printk
     1	4	1	4

первая цифра задает уровень важности мессаг такой что если новая мессага 
в кернел логе имеет число меньше (более важная) то эта мессага будет ядро
засунута не только в кернел лог но и послана на системные консоли. 
так вот можно менять это число через 

   # echo "5 4 1 4" >  /proc/sys/kernel/printk

а можно это сделать через 

  # dmesg -n 5

покаываю

	# cat /proc/sys/kernel/printk
	1	4	1	4

	# dmesg -n 5

	# cat /proc/sys/kernel/printk
	5	4	1	4

	# dmesg -n 1
	# cat /proc/sys/kernel/printk
	1	4	1	4

есть и еще прикольная настройка
по моему она просто первую цифру в 1 превращает
	# dmesg --console-off
	# cat /proc/sys/kernel/printk
	1	4	1	4

а вот еще
	# dmesg --console-on
	# cat /proc/sys/kernel/printk
	1	4	1	4

откуда он знает какую цифру оратно вернуть хрен знает.
последняя цифра это какой уроень важности выводит на экране при загрузке
ядра. что значит вторая и третья цифра непомню. можно найти в инете. или в
man 5 proc


далее я покажу прогу на СИ которая юзает метод через klogctl()



  $ cat 418.c
#include <stddef.h>
#include <sys/klog.h>
#include <stdio.h>
#define SYSLOG_ACTION_SIZE_BUFFER 10
#define SYSLOG_ACTION_SIZE_UNREAD 9
#define SYSLOG_ACTION_READ 2
#define SIZE 264000


int main() {


    int size = SIZE;
    char c[size];
    char *p = &c[0];

    int fd = klogctl(SYSLOG_ACTION_SIZE_BUFFER, NULL, 0);
    if (fd <0){
      printf ("ОШИБКА: нужны права root\n");
      return 1;
    }

    printf ("размер кернел ринг  = %i bytes\n", fd);


    fd = klogctl(SYSLOG_ACTION_SIZE_UNREAD, NULL, 0);
    if (fd <0){
      printf ("ОШИБКА: нужны права root\n");
      return 1;
    }

    printf ("сколько байт лежит в кернел ринге  = %i bytes\n", fd);
    if (fd == 0){
      printf ("в кернел ринг лежит 0 байт поэтому просто выходим\n");
      return 0;
    }



    printf("читаю данные из кернел ринга\n");
    fd = klogctl(SYSLOG_ACTION_READ, p, size);
    if (fd <0){
      printf ("ОШИБКА: нужны права root\n");
      return 1;
    }
    printf("данные из кернел ринга прочитаны успешно\n\n");

    printf (" %s \n", p);


    fd = klogctl(SYSLOG_ACTION_SIZE_UNREAD, NULL, 0);
    if (fd <0){
      printf ("ОШИБКА: нужны права root\n");
      return 1;
    }

    printf ("сколько байт лежит в кернел ринге  = %i bytes\n", fd);



return 0;
}


вывод на экран

 $ sudo ./418.exe
размер кернел ринг  = 131072 bytes
сколько байт лежит в кернел ринге  = 0 bytes
в кернел ринг лежит 0 байт поэтому просто выходим


немного вернусь к dmesg  как я уже сказал он работат так что он читает из 
/dev/kmsg где всегда лежит копия буфера 130КБ размером. однако можно запустить
dmesg вот так

$ sudo strace -e syslog dmesg -c
syslog(10 /* SYSLOG_ACTION_SIZE_BUFFER */) = 131072
syslog(3 /* SYSLOG_ACTION_READ_ALL */, "", 131080) = 0
syslog(5 /* SYSLOG_ACTION_CLEAR */)     = 0
+++ exited with 0 +++

нам здесь важен 

  syslog(5 /* SYSLOG_ACTION_CLEAR */)     = 0

из man klogctl можно прочиать что это значит

SYSLOG_ACTION_CLEAR (5)
 The call executes just the "clear ring buffer" command.  
 The bufp and size arguments are ignored.
 This  command  does  not really clear the ring buffer.  
 Rather, it sets a kernel bookkeeping variable that determines the
 results returned by commands 3 (SYSLOG_ACTION_READ_ALL) and 
 4 (SYSLOG_ACTION_READ_CLEAR).  This command has no effect  on
 commands 2 (SYSLOG_ACTION_READ) and 9 (SYSLOG_ACTION_SIZE_UNREAD).

и как бы я не очень понимаю что происходит далше. это сисколл он по идее влияет
на содержимое /proc/kmsg а у нас же dmesg он читает из /dev/kmsg однако!
после этого сисколла у нас  
		
		# dmesg 

непокажет нихуя.
хотя
     
       # cat /dev/kmsg

покажет что содержимое у файла не изменилось. 
при этом ИИ утверждает что обьяснение в том что dmesg в отличии от cat 
непросто тупо читает из файла а перед этим запускает хитрый lseek()
а уже потом читает

$ sudo strace -e openat,lseek,read dmesg
openat(AT_FDCWD, "/dev/kmsg", O_RDONLY|O_NONBLOCK) = 3
lseek(3, 0, SEEK_DATA)                  = 0
read(3, 0x5c94156f10a8, 2047)           = -1 EAGAIN (Resource temporarily unavailable)


в чем же хитрость этой команды

	lseek(3, 0, SEEK_DATA)                  = 0

офиицаилньно она работат так.
мы указали наальный офсет 0 и далее флаг SEEK_DATA который говорит ядру что
нужно вернуть такой офсет после офсета 0 чтобы там лежали данные. тоесть 
если внутри файла с места где я указал лежит куча нулей то это пропускается и 
как толко встречается место где уже неноль то курсор будет установлен на это
место ну и для српавки код возврата это адрес этого офсета. 
ну и в итоге мы видим что ненулевые данные лежат в файле прям с самого 
начала файла. поэтмоу я считаю что lseek не дает никакого эфекта. почему
тогда dmesg выводит пусто после команды dmesg -c при том что cat /dev/kmsg
невыводит пусто  = непонятно. да и хер с ним. замудили на пустом месте.
итак dmesg  рассмотрели.




К ЭТОМУ МОМЕНТУ я рассмотрел кернел лог. его кернел буфер. и методы 
посмтреть чо там лежит. но это еще не конец. ибо это лог журнал куда ядро
пишет события с точки зрения кода ядра. а унас в линуксе еще есть журнал куда
юзер спейс программы пишут о том как у них дела происходят. пишут они это в user 
space журнал.  в настоящее время за этот журнал отвечает служба 

	systemd-journald




 $ systemctl status systemd-journald
● systemd-journald.service - Journal Service
     Loaded: loaded (/usr/lib/systemd/system/systemd-journald.service; static)
     Active: active (running) since Mon 2024-12-23 22:41:21 MSK; 1 month 18 days ago
 Invocation: fd7ea885270141d9adb17d9b5f266dad
TriggeredBy: ● systemd-journald-dev-log.socket
             ● systemd-journald.socket
             ○ systemd-journald-audit.socket
       Docs: man:systemd-journald.service(8)
             man:journald.conf(5)
   Main PID: 388 (systemd-journal)
     Status: "Processing requests..."
      Tasks: 1 (limit: 18808)
   FD Store: 56 (limit: 4224)
     Memory: 34M (peak: 192M swap: 2.1M swap peak: 2.2M)
        CPU: 3min 9.126s
     CGroup: /system.slice/systemd-journald.service
             └─388 /usr/lib/systemd/systemd-journald



это юзер спейсе журнал событий.


как же юзер программа если захочет может написать в этот журнал ?
обычно очень просто - ей нужно заюзать glibc фукцкции openlog() + syslog()


   $ cat 415.c
#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>

int main() {
    // Инициализируем системный журнал
    openlog("MyProgram", LOG_PID | LOG_CONS, LOG_USER);
    
    // Записываем сообщение в системный журнал
    syslog(LOG_INFO, "Это информационное сообщение в журнале!");

    // Закрываем журнал
    closelog();

    return 0;
}


  $ ./415.exe


заглянуть в юзер журнал можно через
 ঒  $ journalctl -f
фев 10 23:06:22 lenovo MyProgram[1190186]: Это информационное сообщение в журнале!

теперь как это работает под капотом
функция openlog() недаелает никкикакаих сисколлов
а вот syslog() делает. 

$ strace ./415.exe
...
socket(AF_UNIX, SOCK_DGRAM|SOCK_CLOEXEC, 0) = 3
connect(3, {sa_family=AF_UNIX, sun_path="/dev/log"}, 110) = 0
sendto(3, "<14>Feb 10 23:08:33 MyProgram[11"..., 113, MSG_NOSIGNAL, NULL, 0) = 113

получется по факту делается конект к локальному юникс сокету /dev/log
причем по датаграмному протоколу SOCK_DGRAM 
и далее в этот сокет пишется мессага. 
понятно.

теперь смотрим что за файл /dev/log

$ stat /dev/log
  File: /dev/log -> /run/systemd/journal/dev-log
  Size: 28        	Blocks: 0          IO Block: 4096   symbolic link

это симлинк

двигаем дальше
$ stat /run/systemd/journal/dev-log
  File: /run/systemd/journal/dev-log
  Size: 0         	Blocks: 0          IO Block: 4096   socket


получется факически сокет это файл /run/systemd/journal/dev-log
и логично что породжает его systemd
теперь проверим что этот файл открыт у процесса systemd-journald


 $ sudo lsof -Pnp $(pidof  systemd-journald) 2>/dev/null | grep dev-log
systemd-j 388 root   3u     unix 0x00000000e3867583      0t0      2170 /run/systemd/journal/dev-log type=DGRAM (CONNECTED)

получаем что да. получается наша прога подключается к юник сокету который
слушает наш процесс-журнал. пихает туда данные а процесс-журнал их принимает.
и далее сует их в свой бекенд сторадж. а мы потом их видим через journalctl

я немножко поменял программу 415.c в плане того что она шлет в лог.
и запустил. 
и я поймал этот факт принятия информации через сокет со стороны systemd-journald

# strace -p пид_systemd_journald
recvmsg(3, {msg_name=0x7ffdc74db020, 
         msg_namelen=128 => 0, 
         msg_iov=[{iov_base="<14>Feb 10 23:20:51 
                     415.exe[1192"..., iov_len=192495}], 
                     msg_iovlen=1, ... ) 


самое главное здесь это 415.exe это и есть часть того тела которое я передал 
через syslog()

таким образом любая программа на компе если хочет сделать запись в юзер журнал
то не проблем , запускай syslog() и будет щастье.

так называемые демоны или сервисы они часто гадят в лог через другой 
механизм. а именно - они просто пишут то что хотят занести в журнал на свой STDOUT 
или STDERR полагая что тот файл куда это все наравлено он ведет через скажем пайп 
или сокет напрямую в systemd-journald. а он это принимает и пихает в журнал на 
диске. правда насколько я понял systemd-journald ожидает что сервисы будут 
писать то что они хотят зафикисровать в журнале соотвтвуя некоему стандарту. 
какому я не понял. но если сервис просто будет срать на свой STDOUT\STDERR 
то sj(system-jouranld) напишет в том же журнале что он не смог распарсить то что
ему прислали. показыаю на примере.
вот я создал сервис


# cat /lib/systemd/system/name01.service
[Unit]
Description=cat server


[Service]

ExecStart=/home/noroot/419.exe
ExecReload=/home/noroot/419.exe
KillMode=process


[Install]
WantedBy=multi-user.target
Alias=name01.service


и вот смотри как хитро запукает этот процесс systemd

# lsof -Pnp 1537
COMMAND  PID USER FD   TYPE             DEVICE SIZE/OFF   NODE NAME
...
419.exe 1537 root 0r   CHR                1,3      0t0      4 /dev/null
419.exe 1537 root 1u  unix 0x00000000904b0afd      0t0  23612 type=STREAM (CONNECTED)
419.exe 1537 root 2u  unix 0x00000000904b0afd      0t0  23612 type=STREAM (CONNECTED)

тоесть STDIN завернут на /dev/null
STDOUT звернут на  unix (STREAM)
STDERR завернут на unix (STREAM)

тоесть fd/1 и fd/2 завернуты на юникс сокеты. щас мы их найдем

# ss -xp | grep 23612
u_str ESTAB 0      0       /run/systemd/journal/stdout 23613            * 23612 users:(("systemd-journal",pid=219,fd=24),("systemd",pid=1,fd=32))                                          
u_str ESTAB 0      0                                 * 23612            * 23613 users:(("419.exe",pid=1537,fd=2),("419.exe",pid=1537,fd=1))                                     

тоесть в нашем процессе его stdout и stderr завернуты на юникс сокет 
/run/systemd/journal/stdout который слушает процесс sj на его дескипторе fd=24

тоесть как это было. системд себя клонировал. потом он открыл юникс сокет 
файл  /run/systemd/journal/stdout ктторый слушает sj это привело к тому что 
ядро для sj процесса создало +1 дескриптор 24 который будет обрабатывать этот
конект. и также ядро созало +1 декоиптор для процесса systemd. он клонировал 
этот декиптор в fd/1 и fd/2 и далее он сделлал execve(419.exe)
все . теперь все что процесс 419.exe высрет на свои fd/1 и fd/2 то это все
автоатом прилетит на sj процесс на его fd=24
таким образом все что будет из себя высирать сервис прямиком летит в журнал-процесс.
именно так устроен механизм логирования всех сервисов линукса как я понимаю. 
они даже syslog() не вызывают. они просто срут на свой STDOUT\STDERR и все.
едснвтенное важно то что есть некий проокол может это даже сислог формат которым
сервис должен гадить в эфир иначе sj напишт в журнале что он не может распарсть
то что в него прилетело. 


еще раз скажу что посмтреть куда щас указвает системная консоль можно через

 	$ cat /sys/class/tty/console/active 
	tty0



ВОТ в целом плюс минус как устроена система журналиования в ядре и в юзер
спейсе.



теперь ссылки (в обратном порядке)
(ссылки проработаны не полностью)

https://www.kernel.org/doc/Documentation/admin-guide/serial-console.rst
https://www.kernel.org/doc/html/latest/core-api/printk-basics.html
https://www.kernel.org/doc/html/v4.14/admin-guide/kernel-parameters.html
https://en.wikipedia.org/wiki/Printk#cite_ref-:4_5-0
https://www.kernel.org/doc/Documentation/ABI/testing/dev-kmsg
https://unix.stackexchange.com/questions/205883/understand-logging-in-linux/294206#294206
https://unix.stackexchange.com/questions/503059/writing-to-dev-kmsg-randomly-shows-up-in-proc-kmsg-and-always-in-dmesg
https://unix.stackexchange.com/questions/585919/what-is-the-difference-between-proc-kmsg-and-dev-kmsg
https://en.wikipedia.org/wiki/Linux_console
https://en.wikipedia.org/wiki/Printk
https://docs.kernel.org/core-api/printk-basics.html
https://superuser.com/questions/351387/how-to-stop-kernel-messages-from-flooding-my-console
https://unix.stackexchange.com/questions/60641/linux-difference-between-dev-console-dev-tty-and-dev-tty0
https://unix.stackexchange.com/questions/74940/dev-console-points-to-tty0

