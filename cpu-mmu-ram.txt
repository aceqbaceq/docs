| cpu
| intel
| memory
| mmu


если посмотреть параметры этого цпу то вот что 


 $ cat /proc/cpuinfo  | tail -n 3
address sizes	: 39 bits physical, 48 bits virtual


тоесть данный цпу имеет 39 адресных линий до памяти. 
это шина адреса. ненадо ее путать с шиной данных. шина данных судя 
по словами ИИ у него щина  данных 64 бита. 

через 39 бит шины адреса можно адресовать 512 GB
но контроллер памяти у цпу такой что он неработает с таким обьмемом. он 
работает с 64ГБ макс. для этого достаточно 36 бит шины данных в принципе.
так что ширина щины адреса еще не дает нам  информацию о макс обьема RAM котоую мы можем
на этом цпу адресовать.

48 bits  это размер вирт адресного пространства. это 256 TB

через mmu который встроен в цпу у нас идет маппинг 48 бит вирт адрес пространства
в 39 битное физ аресное пространство. а по факту в 36 битное физ пространство.


теперь просвязь между mmu и контроллером памяти. цпу выставляет адрес вирт адрес простраснтва
и передает его в  mmu. это такая микросхема внутри цпу. эта хрень нужна чтобы найти 
физ адрес на основе выденного ему вирт адреса. он ищет это в TLB кеше. если там нет то mmu
делает запрос к памяти через контроллер памяти к области памяти где лежать page tables.
и на основе этого узнает чему равен физ адрес. и передает физ адрес обратно на цпу. 
тот узнав физ адрес ищет на его основе данные в кешах (L1,L2,L3). если там нихуй нет 
то цпу делает запрос на контрллер памяти. далее цпу начинает делать другие дела выполнять 
другие команды (согласно ИИ). контроллер памяти загржуает данные в кеш цпу.  при этом об 
этом событии увеломление в цпу не происходит. далее цпу должен сам повторно заглугуь в кеши.
и найдя там данные наконце то заняться делом. 

шина данных 8 байт. так что за 1 раз по шине в кеши прилетает 8 байт. получается цпу выставлвяет
на щине адреса адрес одного байта. но конрроллер памяти обратно по шине данных возвращает в 
кеш не 1 байт а сразу 8 байт за один высер шины данных. но на самом деле даже еще хуже. размер линии кеша 64 байта поэтмоу якобы за несколько проходов контрллер памяти счиытвает из памяти 
не 8 байтов а все 64! так сказал ИИ. и кладет это в кещ. ИИ также утрвежтдает что якобы 
на шину адерса можно выставить адрес невыровненный ни по 8 байт ни по 64 байта тогда просто
закачка этих 64 байт замет больше времени.

ИИ сказал что кеш у цпу рабоатет асинхронно от цпу. тоесть цпу выставил адрес на контроллер 
памяти. а далее цпу пробует заниматься своими делами. и не ждать пока данные из памяти 
поступят в кеши. так скзаал ИИ.

одна ассемблерная команда

   mov eax, (1234)

она по факту разиывается на целую кучу суб операций. тоесть
цпу переадает вирт адрес 1234 на mmu. тот возвращает физ адрес.
цпу ищет данные в кешах.
если их там нет то выставляет физ адрес на контроллер памяти. 
так вот в любой из этих моментов может на цпу прилетет интеррапт. я спросил у ИИ 
и что будет. будет ли цпу прерывать выполененеие незаверенной ассембле команды или нет.
ответ - it depends.  если цпу получил интеррапт то у нас запустился шедулер . он сунул на цпу
ругой процесс. потом обратно в итоге у нас шедуоер засунул код нашего исходного процесса
на цпу и он както знает что команда застыла посередине. и цпу повторно сунется в кеш
и к тому моменту данные по идее уже должны быть. 


таким маккаром  я описал как все увязано - цпу, mmu, размер шины адреса , размер вирт адресного
простраснства, кеши.

далее  я хочу описать как рабтает PAGE TABLES.

