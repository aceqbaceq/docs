| cpu
| intel
| memory
| mmu
| real mode
| protected mode

изначально эта статья была про mmu но в итоге
пришлось изучить гораздо больше.


если посмотреть параметры этого цпу то вот что 


 $ cat /proc/cpuinfo  | tail -n 3
address sizes	: 39 bits physical, 48 bits virtual


тоесть данный цпу имеет 39 адресных линий до памяти. 
это шина адреса. ненадо ее путать с шиной данных. шина данных судя 
по словами ИИ у него щина  данных 64 бита. 

через 39 бит шины адреса можно адресовать 512 GB
но контроллер памяти у цпу такой что он неработает с таким обьмемом. он 
работает с 64ГБ макс. для этого достаточно 36 бит шины данных в принципе.
так что ширина щины адреса еще не дает нам  информацию о макс обьема RAM котоую мы можем
на этом цпу адресовать.

48 bits  это размер вирт адресного пространства. это 256 TB

через mmu который встроен в цпу у нас идет маппинг 48 бит вирт адрес пространства
в 39 битное физ аресное пространство. а по факту в 36 битное физ пространство.


теперь просвязь между mmu и контроллером памяти. цпу выставляет адрес вирт адрес простраснтва
и передает его в  mmu. это такая микросхема внутри цпу. эта хрень нужна чтобы найти 
физ адрес на основе выденного ему вирт адреса. он ищет это в TLB кеше. если там нет то mmu
делает запрос к памяти через контроллер памяти к области памяти где лежать page tables.
и на основе этого узнает чему равен физ адрес. и передает физ адрес обратно на цпу. 
тот узнав физ адрес ищет на его основе данные в кешах (L1,L2,L3). если там нихуй нет 
то цпу делает запрос на контрллер памяти. далее цпу начинает делать другие дела выполнять 
другие команды (согласно ИИ). контроллер памяти загржуает данные в кеш цпу.  при этом об 
этом событии увеломление в цпу не происходит. далее цпу должен сам повторно заглугуь в кеши.
и найдя там данные наконце то заняться делом. 

шина данных 8 байт. так что за 1 раз по шине в кеши прилетает 8 байт. получается цпу выставлвяет
на щине адреса адрес одного байта. но конрроллер памяти обратно по шине данных возвращает в 
кеш не 1 байт а сразу 8 байт за один высер шины данных. но на самом деле даже еще хуже. размер линии кеша 64 байта поэтмоу якобы за несколько проходов контрллер памяти счиытвает из памяти 
не 8 байтов а все 64! так сказал ИИ. и кладет это в кещ. ИИ также утрвежтдает что якобы 
на шину адерса можно выставить адрес невыровненный ни по 8 байт ни по 64 байта тогда просто
закачка этих 64 байт замет больше времени.

ИИ сказал что кеш у цпу рабоатет асинхронно от цпу. тоесть цпу выставил адрес на контроллер 
памяти. а далее цпу пробует заниматься своими делами. и не ждать пока данные из памяти 
поступят в кеши. так скзаал ИИ.

одна ассемблерная команда

   mov eax, (1234)

она по факту разиывается на целую кучу суб операций. тоесть
цпу переадает вирт адрес 1234 на mmu. тот возвращает физ адрес.
цпу ищет данные в кешах.
если их там нет то выставляет физ адрес на контроллер памяти. 
так вот в любой из этих моментов может на цпу прилетет интеррапт. я спросил у ИИ 
и что будет. будет ли цпу прерывать выполененеие незаверенной ассембле команды или нет.
ответ - it depends.  если цпу получил интеррапт то у нас запустился шедулер . он сунул на цпу
ругой процесс. потом обратно в итоге у нас шедуоер засунул код нашего исходного процесса
на цпу и он както знает что команда застыла посередине. и цпу повторно сунется в кеш
и к тому моменту данные по идее уже должны быть. 


таким маккаром  я описал как все увязано - цпу, mmu, размер шины адреса , размер вирт адресного
простраснства, кеши.

про режмы работы цпу от intel
real mode так назыветм потоиу что цпу и софт работает с реальными физ адресами.
нет никакой вирт памяти. нет никакой защиты памяти. софт может лезть куда хочет. в этом 
режиме у нас 1МБ памяти. такй режим был в 8086\8088 цпу.  к настоящему моменту якобы 
даже текущие цпу интел могу работат в этот режиме. 

адресные линии шины адреса имеют имена A0, A1, A2.... причем A0 передает младщий бит адреса.
интел 8086 8088 имели 20 адресных линий A0-A19 что даваоли им возможность адресовать 2^20=1MB
памяти. 20 бит если их выражать в hex буквах то это 5 букв 
получается адреса будут лежать в диапазооне 
	0x00000  0xFFFFF
прикол в том что адреные регистры этих цпу имели всего 16 бит(четыре буквы) поэтому чтобы задать
адрес который 20 бит(пять букв) делали вот что - было два 16 бит регистра. и адрес 20 бит через них
задаваолся вот как. значение одного регистра както сдвигалось на 4 бита влево (незнаю как 
это выглядело в железе) тоесть скажем у нас регистр AABB а если его сдвинуть на 4 бита влево
то это уже будет AABB0 и к этому числу прибавлялся второй 16 битный регистр. например CCDD
получаем адрес AABB0 + CCDD = AABB0 + 0CCDD = 1ADA5
так как у нас адрес получался из суммы то можно было задать один и тот же адрес множством
способов. ну дествително если рассмотреть на отвелеченном примере. есть число 10 его можно
получит из суммы кучей путей

   1+9
   2+8
   3+7

итп

так вот расмотримна прмиерах

	F000:FFFF = F0000 + FFFF = FFFFF
	FFFF:000F = FFFF0 + 000F = FFFFF
	F555:AAAF = F5550 + AAAF = FFFFF
    F800:7FFF = F8000 + 7FFF = FFFFF

насколко я понял была микросхема котоаря брала два этих регистра и делала вычисление
где то у себя в голове. так вот был и прикол. легко можно увидеть что можно задать 
два этих регистра но резулььтат будет больше чем FFFFF например 

	F800:8000 = F8000 + 8000 = 100000

тоесть мы получили адрес который превосходит 20бит. так вот на 8086\8088 там как я понял
в этом случае работало как на спидометре. как толко результат превосходил FFFFF то у нас 
шло обнуление и все по новой тоесть 

	F800:8000 = F8000 + 8000 = 100000 давал  00000 тоесть так как у нас шина адреса
20 бит то все старшие биты резулбьтаа котоыре выше этих 20 бит они просто отабрасываются
тоесть   1|00000 = 00000

или если мы скажем задаем
	F821:8233 = F8210 + 8233 = 100443 ==> 1|00443 давал  00443 
и этот адрес 00443 и подавался на шину адреса


так вот 
на 286-м процессоре который поддерживал real mode и поэтому у него работала в этом режиме
такая же схема задания адреса у него шина адреса была 24 бита а не 20 как у 8086\8088
а 24 бита дают 2^24=16MB тоесть он мог через нее адресовать 16МБ памяти но правда эти 16МБ
были доступны уже только в другом режиме protected. так вот он для обратной совместимости
мог работать и в real режиме. так вот когла он работал в real mode (а я напомню что рил моде
в частности означает что у нас нет никакой виртуально адресации у нас тот адрес памяти  который указан в коде программы к тому адресу памяти цпу и лезет напрямую) и мы в его 16 битные регистры памяти совали числа

	F821:8233

и микросхема их плюсовала по схему что я расписал выше 

	 = F8210 + 8233 = 100443

так вот если результат превышал 20бит (тоест 5 hex букв) то так как шина адреса была на 286-м
24 бита то число уже не обрезалось до 20бит а вот прям какое оно получалось такое оно 
и пихалось на шину адреса!  и у нас программа которая работала на 286-м цпу который работал
в режиме real mode получала взоможность работать не с ОДНИМ мегабайтом памяти (номера адресов
0х00000 -  0хFFFFF ) а с обьемом памяти чутьчуть побольше! а именно наши адресные регистры(16 битные или четырехбуквеннные) макимально могут выглядеть как 
  
   FFFF:FFFF

 тогда если мы их сложим (с учетом сдвига налеов на 4 бита)

  FFFF0 + FFFF = 10FFEF

тоесть теперь наша программа получала доступ к диапазону адресов 

 0x00000 - 0x10FFEF

тут важно заметить еще одну особенность - даже самый максимальный физ адрес с точки зрения
его битового вида имеет вид 

	10FFEF = 1 0000 1111 1111 1110 1111



так вот видно то что это число имеет 20 бит. и имеет всего +1 бит сверху. 

	1|0FFEF = 1 | 0000 1111 1111 1110 1111

так вот из этого четко видно то что даже самый максимально возможный адрес что касается
его вида за пределами двадцати бит имеет всего +1 бит. и он получается он либо равен 0
либо он равен 1. если он равен 0 то этот адрес по факту имеет длину 20 бит. а если адрес
превышает 20 бит то у нас длина адреса превышает 20бит всего на +1 бит. 
тоесть шарманка выставления адреса через два 16битный регистра

  XXXX:XXXX

она дает нам адресное пространство длиной 21 бит при том что физически на 286 цпу 
имеет 24 бита для адресной шины.   мы еще к этому вернемся.

далее
разница на которую мы превысили 1МБ это 10FFEF - FFFFF = 65520 байт = 64KB -16B
итак особенность 286-го цпу нам дает доступ к дополниельным ~64КБ


теперь я обратно возвращаюсь к тому что на 286-м цпу в real mode адресное пространство 
длиной 21бит в отличии от 8086\8088 в котором адресное простраснтво длиной 20 бит.
если мы запускали программу на 8088 цпу и совали в адресные регистры значения которые
превышали 20 бит то комп просто обрубал биты которые старше 20бит ( как пишут в литерктуре
вычисляли число по модулю 20бит), так вот на 286 цпу в real mode если адрес превышал 20бит 
то цпу ничего неделал ну превысил и превысил  и осталял как есть. так вот как я показал выше
макс размер адресного пространства в 286 в рил моде это 21 бит. так вот проги которые писали
для 8088 они могли специально совать такие данные в адресные регистры чтобы адрес превысил
20бит и цпу сам обрезал адрес до 20бит.  так вот такие проги запущненные на 286-м начинали
работать неправилно потому что вместо того чтобы попадать вначало памяти они попадали в зону
за пределами 1МБ. 
так вот создатели мат плат для 286-го цпу они вставляли какуюто микросхему в мат плату 
на линию A20, эта микросхема она сидела между цпу и какойто шиной на линии A20.
так вот эта микросхема она недавала это линии перейти в состояние 1 она ее всегда держала
в состоянии 0. это означает что какие бы адресные регистры мы не выставили у нас получалось
всегда число длиинной 20 бит ровно как это и было на 8088 процессоре! и тогда программы
работали старые как надо! этот контроллер условно назывался "A20 line". потому что 
вот мы берем макс возможный адрес в рил моде на 286 цпу

		10FFEF

и если мы погасим 21-ый бит то этот адрес превратится в 


		00FFEF = 0FFEF

что полностю соотвтвует длине 20бит.
тоесть этот контроллер который всегда заставлят на 21-ый линии иметь 0 приводил поведение
2860го процессора условно говоря в точное повдеение процессора 8088.
возникает вопорос но на 286-м там же 24 линии . поему мы гасим только 21-ый бит,
почему мы негасим 22-ый, 23-ый, 24-ый. ответ потому что их гасить недется потому что я выше
показал что максимльно высиляемый адрес который получатся если мы выставим адресные регистры
в их макисмльное занчение

   FFFF:FFFF

то мы получаем число 10FFEF которое импееет длину 21 бит. поэтому нам запариваться на счет
22-го, 23-го и 24-го битов нет нужды!

таким макаром я расказал чтоэто за натсройка "A20 line" в биосе компа на базе 286 цпу.
эта настройка имеет занчение только для real mode на этом цпу.

единственное что я непонял это в какое положение нужно перевести этот контроллер. тоесть
если я его актиивирую то он переводит A20 в 0 или в 1?

важно также понять что на самом 286-м цпу этой настоки нет. эта настройка явлется настройкой
на самой мат плате. это фишка мат платы того времени для этого цпу. 

далее я прочитал что начиная с 486-го цпу у него появилась спец ножка A20M которая позволяла
делать контролировать и настривать тоже самое но уже средствами самого цпу а не матплаты.

на osdev так и написано что все пришлось городить потому что придурки програмисты для 
программ на основе 8088 вместо того чтобы выставлять коретно данные на регситры памяти просто
использовали такой момент что цпу сам автоматом отбарсывал лишние биты при превышении размера
адреса выше 20бит.

насколько я понял активация A20 приводила к тому что у нас УБИРАЛОСЬ ограничение на 1МБ.
и наша программа имела доступ к 1МБ+64КБ-16Б памяти. 

также забавно написано что контроллер который контролировал A20 каким то макаром располагался
в контроллере клавиатуры на мат плате потому что у этого контроллера был лишний пин. вот нанего
эту роль и вешали. контрллер клаиваитуры находиттся не в клавиутаре а на мат плате.

написано что GRUB при своем старте активрует A20. таким макаром у него в доступе оказыается
память чуть больше чем 1МБ тоесть 1МБ+64КБ-16Б

по умолчанию при загрузке линия A20 установлена в 0 и будет так установлена все время.
поэтому если мы хотим в рил моде иметь доступ выше чем 1МБ то нам нужно ее активировать
итак это все по поводу что такая за хрень real mode

ссылки где я прочитал про эту хрень A20
	https://aeb.win.tue.nl/linux/kbd/A20.html
	https://wiki.osdev.org/A20_Line
	https://en.wikipedia.org/wiki/Real_mode (кусок про A20)


на счет 8086 цпу. у него регистры 16 бит. при этом шина адреса 20 бит(1MB).
на счет 286 цпу. у него были 16 бит регистры. но шина адреса была 24бит(16MB).
у него была поддержка protected mode. хотя корявая. в чем корявость хрен знает.
как я уже скзаал что 286-ый в real mode имел доступ к 1MB+64KB памяти но отнюдь 
не к 16MB. в режиме protected mode  у него был доступ к ???? памяти.
у него был всроенный внутри mmu. 
насколкь я понял он мог переключться из protected mode в real mode только путем
буквально физического reset. а это долгая процедура. при этом контент памяти сохранялся.
тость проблема была в том что он супер долго переключался. напомню real mode это такой режим
когда у нас цпу дает доступ коду программы напрямую к памяти. тоесть если в коде программы
написано что надо долезть до адреса 1234 то цпу туда и дает доступ. никакой виртуальной 
адерсации нет. в память код может лазить напрямую. программный ресет цпу можно было сделать
путем посылки нужного сигнала на контроллер клавы 8042. проблема ещераз скажу в том что это 
было очень долгий процесс. 
так как у 286 цпу были регистры 16бит и прееключение в протектед моде ничего не меняло
поэтому непонятно как эта система позволяла ему работать с 16МБ памяти. тоесть щина то у него
была 24 бита, но регистры то были по 16бит. непонятно. 
в режиме протктед моде он не мог дать работаь прогам которые были написаны для real mode.
нужно было ресетить цпу чтобы он обратно пееркелючился в real mode. это была долгая операция.
плюс получатся бардак. в real mode он прогармме дает доступ напрямую к первым 1МЮ памяти.
а потом мы возвращааемся в протктед моде а там у нас виртулная память и маппинг на физ 
память. вобщем мутная история. и тогда почти все программы были написаны для рил моде
поэтому сумарно на этом цпу протктед моде незашел.
но что полезного можно отсюда вынести. real mode может работать в режиме 16бит.
протектед моде тоже может работать в режиме 16бит.  битность означает какого размера регистры 
испольщуются в коде в этом режиме работы цпу.

цпу 386 - у него были уже 32 битные регистры. у него был встроенный mmu. у него был уже 
нормальный протектед моде. у него был виртуальный real mode эмулятор этот режим 
работы цпу назывался "virtual 8086 mode" .
 таким макаром цпу ненужно
было выключаться из протектед моде чтобы при этом можно было запустить рил моде прогу.
тоесть у 286го было два режиме real mode, protected mode. 
а у 3860го было трирежиме. real mode, prorected mode и внутри этого режима был 
суб режим "virtual 8086 mode"(VM86)
насколько я понимаю в режиме real mode он предсталвялт 16 битные регистры.
что касается protected mode то как я понимаю он представлял либо 16 бит либо 32 бит 
регистры.

процессор 286 имел  mmu но не имел фнкции paging. это мало понятно так как роль mmu это 
как раз раотать с page table и на основе нее преобразоаывать вирт адрес в физ адрес.
так что - что это был за mmu такой на 286 хуй понятно.
видимо этот mmu преоабразыввал вирт адрес выставлынный в цпу в физ адрес но на основе
какойто более простой хрени чем page tables. поэтому считвтется что mmu на 286 не имел
фичи paging.

на счет 286. он мог иметь доступ к 16МБ(2^24) физ памяти  в протктед моде. при этом в этом же
моде его вирт адресация была 1ГБ(2^30) , непонятно какой смысл иметь 1ГБ вирт адрес пространства
если оно мапится всего в 16МБ физ памяти. mmu у него встроен.

далее я захотел пощупать 286 или 386 руками в связке со старым линуксом. для этого я установил 86Box прогу.

	https://github.com/86Box/roms/releases/tag/v4.2.1

она идет в формате AppImage. скачиваем его. также нужно скачать так называемые ROM. 
они идут в форме зип файла там все ромы сразу в одной куче. кладем их в папку roms
тамже где и бинарник. 
значит в ней все интутивно понятно но есть пара хуйни.
самый мудеж состоит в том что мы там выбираем цпу+мат плату(биос) + контроллер диска + контроллер флоппи.
так вот есть несовсстимые друг с другом компоненты. поэтому нужно выбрать цпу+мат плату.
а потом под них методом перебора подобрать контроллер диска и контроллер флоппи которые
успешно определятся биосом. значит нужно было найти старуй линукс который заведется на 386 цпу.
причем 286 не подойдет. потому что 386 это первый цпу интел который поддерживает page tables
а без них линукс не завеедется. такой линукс вот он 

	https://archive.debian.org/debian/dists/hamm/main/disks-i386/2.0.10_1998-07-21/


на самомо деле есть еще одна засада с линуксом. через флоппи устанвоить линукс нихкя не 
получилось у меня. когда дело доходит до последнейго флопи файла то линукс шлет нахуй. 
единсвтенный способ которым мне удалось установить линукс вот какой. в флоппи я загружаю
первый бут флопи resc1440.bin  и загружаюсь с него. кстаи если выбрать мат плату на 386 
то она неумеет грузиться с cd-rom из биоса. так вот гружусь с флопи.  итакже в cdrom 
я подсааываю саодельный cd диск в форме имаджа. его я делаю вот так
беру папку

	base2_0.tgz
	drv1440.bin
	resc1440.bin

эти файлы  я скачал руками соссылкисверху.
потом из этой папки я говотовлю исо образ 

	$ mkisofs -o ../cd.iso  ./folder

и вот этот iso  ясую в cd-rom
у меня происодит загрузка установщика линукса через флопи. а там он спросит откуда его 
ставить , указываем что с cd-rom и тода он его успешно ставит. по другому никак устанвоить 
не получится!

но в итоге я октазался от этого эмулятора потому что он круто тормозит. поэтому нахуй.

а вот еще полезнаяха вылезла. если у нас есть файл как его преврить в блочное у
устройство

		# losetup /dev/loop0 /file.txt

если он будет ругаться что устройствао загято это значит что данный loopN нельзя 
юзать , пробуй подставить loop(N+1)


теперь можно на нем разделы создавать итп.
когда закончим то удаляем блочное устройство вот так

	# losetup -d /dev/loop0

взял отсюда 

	https://www.jamescoyle.net/how-to/2096-use-a-file-as-a-linux-block-device


в целом можно использовать даный эмулятор чтобы посмтреть как раньше биосы
выглядели.


на 286 цпу у нас появяляется protected mode. что он дает. он дает несклоько колец внутри
цпу. тоесть кольцо0 позволяет выполнять все команды. кольцо3 позволяет выполнять только
част команд. также оно дает виртуальную память. тоесть код программы указывает вирт адрес
но физический адрес находится ему соответвующий уже по алгоритму. таким макаром юзер
прораммы не могут шарится в физ памяти где хотят. также он дает доступ к 16МБ памяти.

кстати 8086 цпу он формально давал право лазит по 1МБ памяти. но! создатели мат платы под
этот цпу а именно фирма ibm она обломила тут! дело в том что в компе помимо цпу и памяти
ест еще периферийные устройства. с точки зрения железа они выглядят так что это тоже некоторые
ячейки памяти в которые нужно писать и читать. возникает вопрос как цпу к этим ячейкам 
будет иметь доступ? есть два пути - есть отдельная шина называется она шина портов. 
и если запись в память идет чрез команду MOV то запись в регистр устройства которое сидит
на шине портов идет через комады IN или OUT, есл ядрес ячейки памяти называется адрес то
адрес регистра железки которая сидит на шине портов назвыается порт.
у 8086 что касается памяти не было отдеьной шины адреса памяти и отдельной шины данных памяти.
это все быо соединенино на одних и техже ножках

  A0-A19 это адресная шина памяти
  A0-A15 это дата шина памяти (они называются D0-D15 хотя они сидят на техеженожках 
  что и A0-A15)

так вот прикол в том что 8086 неимел отдеьных ножек для портов. это были все теже самые
A0-A15 и они тоже одновременно служии и для оозначения адреса и для передачи данных.
при этом чтобы отличать куда мы пишем в память или в порты доп исопльзовался регистр M/IO
он обозначал пишем ли мы в память или в порт.   для адреса порта использовались A0-A15 
поэтому адреса портов колеблятся в пределах 0-65535 
хотя для самого цпу получается данные хоть от порта хоть от ячейки памяти приетают через 
одни и теже ноги но как я понимаю мат плате были разведены разные шины для памяти и для
устройств. просто на мат плате видимо сидел какойто мульитиплексор перед цпу. так вот 
я описал то что в програмном смысле досту к памяти и регистру железкти идет в коде 
по разному

для памяти
   mov ....

для железкт через поорты
   IN ...



так вот есть еще один путь. мы на шине адреса памяти цпу выставляет адрес. это все летит
в контроллер памяти на мат плате. а тот для определенного диапазона перенаполавяет данный 
запрос на железки а не напамять!  да таким макамро мы лишаемся доступа к диапазону
памяти. зато например у нас доступ к железке идет как бутто этот память через команду

   mov .....

это называется memory mapping I\O

вот так и сдеалали IBM когда они создали мат плату для 8086. сам цпу тут ни причем.
это все мат плата. если мы на цпу выставляем адрес в пределах 640КБ то тогда контроллер 
памяти это пердает в память а если мы выстваляем адрес 640КБ-1М то контроллер памяти нас
направляет нев памть а на какую то железку или в биос. поэтому мы теярем 340КБ памяти.
но зато раотаем с регстрами железок так как бутто это просто память. 
вот откуда взялась эта хрень 640КБ

у 286 появляется  protected mode но он  корявый потому что у него нет page table который 
бы делил физ память на одинаковые страницы. а вместо этго есть одноуровненые таблицы GDT и LDT. которые делят физ память на сегменты разного размера. эти тадлицы это прообразы пейдж тейбл
в будущем.  протектед моде это такой режим цпу который позволяет недать юзер коду получить
доступ к физ памяти. тоесть юзер код он если захочет посмотреть что лежит по такомуто адресу
физ паяти то у него нет такой возможности.нет таких команд. юзер код работая с командаами
которые якобы раотают с адресами памяти на самомо деле они работают с аресами вирт памяти
и далее запчасть mmu преоразует незаметно и прозрачно эти вирт адреса в физ адреса. 
для юзер кода физ память абсолютно абстрагирована и изолирована если цпу работает в протктед
моде. таким образом код рабоатет с вирт адресным пространствтвом. а оно уже заним числом
мапится на физ проатсратсснтво. 286-ый оперирует 1GB вирт памяти и мапит ее в 16МБ физ памяти.
итак точно имеет место то что в протекте моде юзер программа когда она оперирует якобы с 
адресом памяти то на самом деле она оперирует фиктивным адресом , фикцией. это не адрес
физ памяти. получить доступ к физ памяти программа неможет. программа передает цпу адрес виртуал
ьный а цпу далее (через mmu ) превращает этот вирт адрес в физический по своему усмотрению
, проверяет есть ли у программы права доступа к этому куску и только потом обращается к 
физ памяти.  тоесть программа может указать только вирт адрес. а цпу уже сам решает 
к какой физ памяти обратиться и обратиться ли вообще. условно говоря в привлигированном режиме
код ос выделяет юзер программе кусок физ памяти и мапит ее на вирт адреса. и тода юзер программа
обращаясь на вирт адреса может только шарится в выделенном ей со стороны ос куске физ памяти.
и не может шариться в остальных кусках физ памяти.  протектед моде это  именно о том что 
цпу активирует фичу виртуальной памяти , говоря другими словами цпу закрывает для програм
прямой доступ к физ памяти. вот что такое режим протектед моде. пртектится именно доступ к 
физ памяти. он закрыавается. все остальные фичи проектктед моде они вторичные. протектед 
моде он прежде всего про закрытие доступа к физ памяти и активацию вирт памяти. 

на 286 протектед моде работает вот как. у нас адрес вирт памяти который программа указывает 
для цпу  чтобы попасть в ячейку  памяти состоит из двух 16 битных числа. тоесть это 32 битное
число. так как регистры 16битные то это адрес приходится вводить в цпу диковинным способом.
старшие  16 бит от этого 32битного числа  программа вводит в один из сегментных регистров
например в регстр CS.  а младшие 16бит программа указывает в параметраах самой команды MOV
напрмиер вот у меня 32 битный вирт адрес 0x12341111

	mov ax, 0x1234      
	mov cs, ax          ; вот я в  CS записал старшие 16бит  0x1234
	mov bx, 0x1111      ; в bx записал младшие 16бит 0x1111

	mov ax, 0x1012      ; это контент который я хочу сунуть в память
	mov [cs:bx], ax     ; Записываем значение в память по виртуальному адресу


вроде бы последнюю кманду можно еще вот так записать

	mov [cs:0x1111], ax

как раз то очем я говоил - часть вирт адреса я ввожу через сегментный регистра а вторую 
часть адреса как параметр самой команды

это конечно неривычно что 32 битный вирт адрес вводится не в привычном 32битном виде
а разбит на две 16 битные части. это потому что регистры у нас по 16 бит.

теперь по поводу этих 32бит. формально  32бит дают нам 4 милиона разных вариантов. тоесть
якобы у нас обьем вирт памяти 4ГБ. но это не так. дело в том что 2 бита  в этой констркции
ообозначают не вирт адрес а некую хрень в плане пермишнс я пока мало понимаю но якобы в этих
двух бита наша прога заявляет цпу с каким правами доступа наша прога леезет по этому вирт адресу
а цпу проверяет доступ и шлет лесом или не шлет. таким образом наш 32 битный адрес сжимается
до 30 бит. поэтому обьем вирт адресного простраснтва сжимается до 1ГБ. спрашивется что 
за бред. у нас макс обьем физ памяти 16МБ. нахуй нам 1ГБ вирт памяти? ответ разумный есть!
щас раскажу. значит для этого я раскажу как вирт адрес превращается в физический.
первые 16бит они указывают не некую таблицу  в памяти которую ОС заранее подготовила
точнее таких таблиц может быть несклько. точнее для каждого процесса это может быть две 
возможных таблицы GDT либо LDT. обе таблицы для процесса готовит ОС. так вот старшие 16бит
они обозначают для цпу в какую таблицу из двух цпу должен заглянуть точнее я думаю не цпу 
должен заглянуть а его mmu должен заглянуть  и там найти заданный ентри, потому что старшие
16 бит обозначаю в какую таблицу надо mmu заглянуть и какой там ентри найти. в этом ентри
указан физический адрес! это так называемый базовый адрес сегмента. а младшие 16 бит(64КБ) они 
укзыавают оффсет относительно этого адреса сегмента.  так вот если  я как ОС хочу разбить 
физ память на куски размером 64КБ которые не пересекаются друг с другом то мне для этого 
достаточно 16МБ\64КБ = 256 сегментов.  номера этих сегментов 0-255.  а число 255 это 0xFF
тоесть это 8 бит. 
я проясню какой формат имеет старшие 16 бит
  13 бит - это номер индекса в таблице 
  1 бит - это признак с какой таблицей мы работаем GDT либо LDT
  2 бита - это RPL биты они связаны с пермишнс к сегменту . об этом потом. 

так вот как я только что посчитал если я хочу разбить 16МБ на куски размером 64КБ то мне
для этгого доастатно 256 сегментов или 8 бит под номер индекса.
однако как я уже сказал цпу создатели под этот индекс выделлили 13бит тоесть  в 16 раз 
больше. спраишивается нахуя?  а разгадка вот в чем -  програмисту могут понадобится сегменты
разного размера! в том числе маленькие. вот возьем прикинем если я хочу сделать все сегменты
размером 512 байт , то сколько физ памяти я смогу замапить если у меня число сегментов
равно 2^14=16 384 (почему в четырнадцатой а не в тринадцатой потому что у нас 13 бит это 8192 ентри
но еще один бит  у нас признак про какую таблицу идет речь GDT или LDT. если мы их обе сложим
то у нас общее число ентри будет в 2 раза больше. поэтому общее число ентри тоесть сегментов 
в обоих таблицах составиит 2^14) ===>  16 384 * 512 = 8МБ ! вау! тоесть оказываетя что 
если сегменты досттаточно мелкие то нам наших сегментов может и не хватит на то чтобы охваитть
все 16МБ физ памяти!  тоесть нам даже не хватвает битов под сегменты!
поэтому 1ГБ вирт памяти это некий такой фейк. если мы насоздаем  нерерывные сегменты по 64КБ
то у нас вирт память тоже будет непрерывная и по размеру она составит 16МБ.
а если мы насоздаем мелких сегементов то у нас суммарная замапленная вирт память будет порой
даже меньше чем 16МБ и она будет прерывная , кусочечная. вобщем главное что надо понять что
старшие 16бит по факту это 14бит. и что такое число дает нам возможность создавать сегменты
нетолько размером 64КБ но и мелкие сегменты и при этом мы сможем охватить всю физ память. 
тоесть еще раз - если бы создатели цпу выделили бы под сегмент не 16 бит а 11 бит. тоесть
у нас бы общее число сегменто  в оббоих таблица составляло 256 сегментов то тогда разраб
был бы обязан создавать сегменты размером только по 64КБ чтобы охватить всю физ память. 
при этом мы бы получили большую фрагментированность памяти тоесть большие потери. пото мучто 
условно  - каждый сегмент это память под новый процесс. и далеко не кадому процессу нужно 64КБ
было в далеком 1982 году. поэтому увеличисли макс число сегментов с 11 бит до 16 бит
тоест с 256 до 16384. это дает возможность создавать как большие сегменты так и маленкие.
16384 сегмента дает вомзожность охватить всю физ память если размер сегмента ~1KB
при таком раскладе мы получаем большую свободу - тоесть если у нас каждый сегмент равен хотя бы 1KB то нам точно хватит доступных сегментов для того чтобы охватить всю физ память. тоест
если я создаю новый очеедной сегмент и его размер хотя бы 1КБ то я могу быть точно уверен 
что оставшееся число сегментов мне позволит охватить всю физ память целиком.  а вот эта цифра
дурацкая 1ГБ возникла просто как тупое математич недоразумение. просто как то что
еслли мы умножим 2^30 то мы получим 1ГБ. и это сбивает с толка.
так что структура  вирт адреса 16б+16б взята не с потолка. в идеале было бы круто если бы они 
увеичлили эту структуру еще на 8 бит. это бы нам давало возможность разбить память на сегменты
размером 4 байта. но они разумно посчитали что и два по 16 бит это и так уже дохрена расходуется
битов на вирт адрес.
так что тайна кажуегося дурацким на первый взгляд размером 32бит виртуального адреса разагадана.
окзвыатся оно не дурацкое а имеет очень даже разумный смысл. очень даже именно оно прям
круто на самомо деле привязано к 16МБ а не просто взято с потолка.

вот еще кусок про тоже самое что я только что описал
я прмиено понял почему они нагородили 1ГБ вирт адресов при наличии всего лишь 16МБ физ памяти.

начнем вот с чего. вот у нас есть офссет 16бит это 64КБ, посморим склоько у нас будет непересекающихся сегментов каждый из которых имеет такой размер 

bc <<< "  (16*1024*1024) / (2^16)"
256

это получается сегменты  0-255. или 0-0xFF

а оффсеты внутри каждого сегмента будет иметь вид
0x0000 - 0xFFFF

соедияем сегменты с офсетами,
получается диапазон адресов виртуальной памяти будет 

0x0 - 0xFFFFFF

общее число байтов будет 0xFFFFFF+1 = 0x1000000
это ровно то число байт которое равно 16МБ.

получается вот это число 0xFFFFFF имеет 24 бита.
тоесть если бы мы создавали все сегменты строго размером 16бит то нам бы хватило 24бита под виртуальное адресное пространство.  тоесть 16бит на офссет и 256 сегментов.

а потом они подумали о том что програмист захочет создавать сегменты нетолько размером 16бит но и меньше.
и они расширили макс возможное число сегментов с цифры 256 до 16384.  тогда у нас биты отвечающие за размер сегмента увеличились с 8 бит до 14 бит.
безусловно что  16384 сегмента не имеют никакого смысла если мы каджый сегмент будет создавать размером 16бит потому что мы превысим размер физ памяти 16МБ намного , но! если мы будем создавать сегменты разного размера в том числе очень маленького то даже наоборот указанное число сегментов не сможет покрыть всю физ память. например если я буду создавать сегменты по 512 байт каждый тогда 16384 * 512 = 8МБ. тоесть в этом случае мы не покроем всю память. 

если я буду создавать маленькие сегменты то с точки зрения адресов вирт пространства у меня в программе будет наблюдаться то что у меня виртуальные адреса будут идти с "дырками" тоесть у меня будут идти разрывы с точки зрения виртуальных адресов. например примерно вот так

скажем сегмент длиной 512 байт. 
сегмент   = 0x0001
офсеты  0x0 - 0x01FF

сегмент = 0x0002
офсеты  0x0 - 0x01FF

суммарно виртадреса будут выглядеть вот так

непрервыный блок:
0x00010000
0x00010001
0x00010002
...
0x000101FF

потом разрыв
0x00020000
далее опять непрерывно
0x00020001
0x00020002
...
0x000201FF

в общем если у нас сегменты маленького размера то тогда
размер  сегментной части виртуального адреса размером 14бит имеет смысл  при размере физ памяти 16МБ. я бы даже сказал что в идеале нам нужно чтобы размер сегментной части был даже еще больше в битах. 


сотвтвтенно вот пример. скажем я формально хочу записать в вирт адрес 800 MB
это в hex 0x32000000
разберем эту конструцию

  0x32000000 = 3200 0000

значит у нас старшие 16бит  = 3200 
а младшие равен 0000 
это значит что оффсет у нас 0 байтов.
а сегмент закодирован в виде 3200

3200 офицаиально называется segment selector а  0000 называется segment offset

значит формат segmet selector вот такой

  15     3  2  1   0
+---------+---+-----+
| Index   |TI | RPL |
+---------+---+-----+


тоесть 
	биты 0,1 - это RPL хрень связана с пермишнс досутпа к сегменту
	бит 2 - это TI , если он равен 0 то сегмент из GDT таблицы а если 1 то из LDT
	биты 3..15 - это номер ентри в табллице


формально RPL это число 0,1,2,3 означает номер ринга цпу. но пока что мало понятно что это 
дает.


расмаотрваиваем наш 3200
у него RPL=0 
TI = 0 это значит мы работаем с сегментом из GDT таблицы

как на по быстрому преврартить число 0x3200 в число которое на 3 бита сдвинуто вправо. 
а вот как при сдвиге на 1 бит наше число уменьшается в 2 раза. значит надо его поделиь
на 8. в итоге номер индекса равен 0x640 или 1600 в dec
так что наш исходный вирт адрес 800МБ он же  0x32000000 это по факту означает 
что нужно цпу залезть в GDT таблицу в ентри 1600 , найти какой там указан физ адрес.
потом отнего сделать смщение 0 байт. и пойти по тому адресу. а уж какой там будет физ 
адрес хрен знает.


GDT и LDT это аналог пейдж тейблс. причем однуроовневая.
она делит память не на страницы а на сегменты а по сути сегменты это теже самые страницы
только переменной длинны. 

еще - если подумать то в адреспции памяти в режиме real mode унас получаетс программа 
кодирует адрес памяти как  segment:offset и это 32битный указатель. приходит на ум
идея что в рил моде у нас тоже идет виртуалная адресация потому что что такое виртуалная 
адресация это когда идентицикатор адреса памяти в программе отличается от иднетициакатора
адреса как она на самом деле есть в физ памяти.  но однако в рил моде у нас не виртульная 
память. да - у нас адрес памяти в програме оттличается от ирелаьного физ адреса но! - 
виртуалная адресация это такая штука что какой бы адрес программа не выставляла она не может
получить доступ к физ памяти к любой ячейкке, прогармма не может пошариться в физ памяти 
по всем адресам. она будет шариться только там где ей позволит цпу и ос. вот что такое
вирт память и вирт адресация. так вот в рил моде у нас не виртуалная память потому что 
программа если будет шаманить с разнообразными segment:offset то она в итоге сможет прошерстить
всю физ память плюс минус целиком. поэтому я бы сказал что в рил модет у нас адресация как
бы вириуальная но режим работы с памятью не виртуальный а физический реальный. 
и только в протекткед моде у нас и адресация памяти виртульная и фактический доступ к памяти
тоже виртуальный! так что рил моде адресация памяти похожа по внешейней форме на виртуальный
доступ к памяти но нет, у рил моде тлоько виртуалный режим адерсации памяти но доступ к 
памяти физический реаьный! вот такой чоередной запутанный звездвец!

 








далее  я хочу описать как рабтает PAGE TABLES.

