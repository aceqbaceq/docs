traefix

у него есть штуки из арехитектуры

entry points:
 - это порты сетевые. через которые траефки принимает входящий трафик


routers :
 - эта хрень которая управляет на какой сервис нарпавить влетевший поток


 - middleware:
 сидят между роутерами и сервисами. позволяют модицифировать 
 поток летяший туда или обратно


 - services:
 конечная точка сброса потока который влетел в траефик


 ===
 траефик имеет в композер кофниге строку


 command: --api.insecure=true --providers.docker

 эта опция она меняет параметр CMD но не при создании имадже
 как это ест у CMD для Dockerfile а она менет CMD  при запуске контейнера.

 вот что мы увидим в сойствах уже запущенного контейнера

           "Cmd": [
                "--api.insecure=true",
                "--providers.docker"]



еще если глуюбже подуть то  command:  походу пьесы это полны аналог того что кода мы запускаем
докер руками то мы руками чтот вбили вот так

$ docker  .....   image  "--api.insecure=true" "--providers.docker"

вот в чем глубокий смысл опции comamnd: в докер комопзер конфиге.
и это логчно. так как композер это просто некая обертка чтобы docker run незапускать руками. 
вот и все. тоесьт кеще раз command^ он неменяет свойства  имаджа который собиратеся или скачивыается!
он имадж нетрогает. он по друную стадию - когда запускается контейенр то он туда вбивает разные
параметры. этот параметр это все те кастомные опции которые вбиваются после имени имаджа!

посмторим что стоитв ентрипоинт в имадже трафика

 docker inspect traefik:v2.10 | grep -iE "entry"  -A 4
            "Entrypoint": [
                "/entrypoint.sh"
            ],


  таким макаром при старте траефика внутри контейнера будет запущено:

(внутири контейнера)$ /entrypoint.sh  "--api.insecure=true" "--providers.docker"

теперь понятно!


написано что command: можно вбтивать в двух формах

command: bundle exec thin -p 3000
или
command: ["bundle", "exec", "thin", "-p", "3000"]

и в отичие от CMD как я понял в случае command: вобще похеру в какой форме. результат 
будет один и тот же




посморим на докер композ конфиг для траефка



vversion: '3.5'

networks:
   vasya:

services:
  reverse-proxy1:
    # The official v2 Traefik docker image
    image: traefik:v2.10
    # Enables the web UI and tells Traefik to listen to docker
    command: >
               --api.insecure=true 
               --providers.docker
    ports:
      # The HTTP port
      - "90:80"
      # The Web UI (enabled by --api.insecure=true)
      - "8090:8080"
    volumes:
      # So that Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - vasya






это композер в итоге запустит вот такую команду

$ docker run   -p 90:80      \ 
               -p 8090:8080   \
               -v /var/run/docker.sock:/var/run/docker.sock:ro  \  # (рид онли доступ мы даем только)
               traefik:v2.10   \
               --api.insecure=true  \
               --providers.docker

ну и там еще с сетью будет какой то ключ. ладно. вигаем дальеш


чтоважно сказать про комозпер конфиг трафека:
одна часть настроек предназначена чтобы траефик изунтри контейнера запустил 
некотоыре свои фичи. чтобы он их актививроал.
а вторая часть настроек композера это мы снаружи к траефкику прикрепляем неоходимые 
ресурсы хоста. потому что чтобы траефик заработал надо чтобы он со свой стороны актививроавл 
те или иные свои опции а с друной стороны чтобы мы пробросили с хоста часть ресурсов внутрь контейнера
иначе тоже ничего незаработает. 
расмморим подробно.

вот есть опции командной строки

 --api.insecure=true 
 --providers.docker


 эти опции это укзаание траефику чтобы он изснутри контейнера атктививовал часть своих фич.
 первая фича
  --api.insecure=true

  командует о том чтобы трафеки изутри контейнера начал слушать порт 8080 (изутри!)
  на этом порту ему надо посадить свой веб сервер на котором у него его UI веб морда управления.
  сотвсвтенно если мы эту фичу неукажет то у трафека веб морда управления небудет активиована
  и мы в нее войти не сможем.

  теперь чтобы мы смогли с хоста на эту веб морду попасть нам надо из контейнепа наружу
  проороосмть этот порт 8080
  мы это делаем через

  ports:
      # The Web UI (enabled by --api.insecure=true)
      - "8090:8080"


  таким макаром мы актвировали веб морду изунтри и ообемпечил к ней одступ снаружи!
  важно отемтить что еси нам веб морде ненужна то тода обе эти опции нам нахер ненужны!
  также хочу заметить что порт 8090:8080 он небует участовать в принятии боевого трафика . он будет 
  участовать только в том что через него мы получаем доступ к вем морде. это тоже важно понять.


  далее.
  фича

  --providers.docker

  она собщает тарфекику чтобы он изнутри искал файл /var/run/docker.sock через который он должен 
  поклчться к докеру чтобы узнать обо всех контейнерах  в системе.
  это мы атививровали фичу инутри кнтейнера. теперь надо снаружи прорборсить сокет нашего докер демона
  чтобы этот фаункционал сороссяя

  делаем через

      volumes:
      # So that Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock:ro

  итак эту фичу мы изнутри и сранужи активировали!

 у нас осталась последяяя оация

 ports:
      # The HTTP port
      - "90:80"

 зачем она. делом в том что  траейфик при старте без свяких настрок начинает слущать изунтри
 когнтейнера порт 80. на него он ждет уже боевой трафик который он будет проксировать.
 тоесть изнутри это активироват ненадо. нам надо лишь теперь сранужи с хоста прорстьи порт
 через который мы будет вливать трафик в траефки для этого мы и юзаем 90:80 опцию.


 также важнопонять что еслимы посе стрта контейнера зайдем на http://localhost:90 
 то мы там получим отлуп в втде 

 404: not found

 и это логично!!! потому что зачем мы поперлись на этот сокет? мы хотели попасть в веб морду ? так? 
 но я еще раз опдчеркну такую ошибку котору я вначале доппускал --- на порт 90:80 ВЕБ МООДЫ НЕТ! 
 веб морда сидит на 8090:8080 там она! туда надо идти!
 а на порту 90:80 трафик ждет БОЕВОЙ ПРОКСИ ТРАФИК! а у нас как только мы запстил траекфик
 еще ничего ненастроено в плане боевого трафика. итак на 90:80 ниаких веб морд рнет! веб модра на ругом портуу!
 через порт 90:80 мы будем попадать в нутрь контйенеров! но только после того как мы это дополниетлно настроим!!!
 тыпонял!?!?!?!!?!


 итак  с портам и опиями  и веб мордой разборалсит.

 вопрос - к какой сети целяется траефик при старте? ответ он создает +1 новую докер сеть тип бридж
 и там он сидит!


 теперь вопрос - а как нам на компе несолкько траефиков запутсить? ответочень просто!


берем наш конфиг и копируеис его в другую папку



version: '3.5'

networks:
   vasya:

services:
  reverse-proxy1:
    # The official v2 Traefik docker image
    image: traefik:v2.10
    # Enables the web UI and tells Traefik to listen to docker
    command: >
               --api.insecure=true 
               --providers.docker
    ports:
      # The HTTP port
      - "90:80"
      # The Web UI (enabled by --api.insecure=true)
      - "8090:8080"
    volumes:
      # So that Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - vasya



в нем надо всего навсего поменять
"90:80"  ==>  "91:80"
"8090:8080"  ==> "8091:8080"

все !  тоесть мы поменял просто напросто порты которые пробрастыаем на хост от веб модры
и для боевго трафика. это понятно.
а больне менять ничего ненало.
воникает вопрос а какое имя будет у новго контейнера ? ответ : по деолту комопзер беерет имя сервиса 
"reverse-proxy1" и прибавляет к нему имя папки в которой лежит комозер конфиг. таким маккмро обеспеичивается 
уникальность имени новго контейнера.  возникает вопрос - но мы же можем положить конфиг в ппку с таким же названеим(имеется
ввиду имя папки ближней к нам в которвй мы лежит а не полуный путь) и тогда имя контейнера будет неукикальным.= скажу честно
задоблался все прояерять. незнаю. проверь и узнай сам.
есть и другой вариант. если мы в файле .env котоырй по деолфту является файлом откуда комозер читет перемнные
мы вствавии переменную 

cat .env
COMPOSE_PROJECT_NAME=kuku1

то тогда комозер будет при созднаии контейнера прибавлять к имени сервиса не имя папки а COMPOSE_PROJECT_NAME
я считаю что так более удобнее потому что тогда комозер когфиг можно сопококно переносит из папки
в папку и это не приведет к озданию контенера с новым имененм.


в итоге я вот как сделал

$ cat .env
COMPOSE_PROJECT_NAME=v0-1
HTTP_HOST_PORT=93
UI_HOST_PORT=8093



$ cat docker-compose.yml
version: '3.5'

networks:
   vasya:

services:
  reverse-proxy1:
    # The official v2 Traefik docker image
    image: traefik:v2.10
    # Enables the web UI and tells Traefik to listen to docker
    command: >
               --api.insecure=true 
               --providers.docker
    ports:
      # The HTTP port
      - "${HTTP_HOST_PORT}:80"
      # The Web UI (enabled by --api.insecure=true)
      - "${UI_HOST_PORT}:8080"
    volumes:
      # So that Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - vasya
    restart: always



теерь нам еси=ли мы хотим поднять +1 трафеки то нам ненужно трогать композер файл
а только менять .env файл

фуууууххх!!!!!



| кстати полезно еще добавить оаацию чтобы траефик запускался атовмтом при преезашруке компа
restart: always



| далее

я выяснмл что траефик можно проксировать только те контейнры 
которые сидят с ним в одной сетисука! 

значит напомню что кода стартует контейнер то он засоывается в 
сеть. удокера 4вида сетей. 
host - это сеть самого хоста. с доступом к реальным сетевым картам
null - хрен знает
overlay - что значит эта сеть в случае докера\композера поканеясно.
а вот случае сворма это значит что компы сидщие в этой сети прозрачно 
доступны с других хостов сворма.
bridge - это самая частая сеть докера. в ней под дефолту сидят контейнеры.
это отдельная  ip сеть. в ней  с хоста можно пинговать контенеры. но только с этого хоста.
что значит сеть типа bridge. это значит что докер создает +1 вирт бридж (посмотреть 
можно через brctl show) и  за ним уже помещает контенеры. 

так вот еще момент какой важный - это то что в iptables сидят правила котоыре 
туда добавляет докер о том чтобы между контейнерами сидящими за разными bridge сетями небыло
связи! это важно! да мжоно кастомоные правила руками доаблять коорые это решат
но по дефолту контенеры с разныз bridge сетей друг с другом связи неимеют!
да можно нарпимер руками один контейнр одновеменно включить сразу в несколкьо бридж сетей
и таким макаром он сможет свзаться с контейнарами с другой сети.

из этого идет огромный вывод - что траефик он сможет запроксировать доступ 
только к тем контейнерам котоыре сидят в его же сети!!!!! понятно?!?!?!?
если контейнер сидит в другой отличной сети то траефик неможет с ним сам 
связаться и не может к нему и когото допроксировать.

это очень важная инфо.


когда стартует контейнер котоырй указан в композ конфиг файле то композер так
задает параметры в докер что докер сует этот контйенер в новую бридж сеть. 
и все контйенеры из этого комоз файла сует туда же.
для кажого композ файла своя новая бридж сеть.

а также можно указат название бридж сети котрую докер создаст 
при старте контенеров из композ конфига

version: '3.5'

networks:      # указываем какое название хотимиметь для сети котторая будет создана автоматом
   vasya:      # сеть vasya плюс там будет добавлен автомат префикс


# сервис траефка
services:
  traf-01:
    ...
    networks:
      - vasya


# здесь я добавляю некий простейцеий сервис.
  whoami-05:
     image: traefik/whoami
     labels:
        - "traefik.http.routers.whoami5.rule=Host(`whoami05.docker.localhost`)"
     networks:
       - vasya



traefik/whoami = это такой  простецкий веб сервер. которйы при обращении к нему
пише свой ip адрес и адрес того кто к нему обратисля. удобная вещь для тестрования рабоиы
траефкика


видно что и траефика и whoami  сидят в одной сети "vasya"
значит траеик сможет проксировать доступ к этому контейнеру.


labels:
   - "traefik.http.routers.whoami5.rule=Host(`whoami05.docker.localhost`)"


эта хрень добавляет к контейенеру метку label. с точки зрения докера это бесопзеная хрень.
но траефик читает через докер сокет инфо об контейнерах и ищет у них метки.
траефик находит метку. читаеь ее . и вноситизмненеия в свой конфиг. 
пока что точное значение этой метки с точки зрения траефика я незнаю. но на праатике оно 
даст то что если обратитться на порт траефика на который он ждет вхлящий поток для проксирования
то завернет этот трафик на наш контйенер whoami , только надо чтобы это был http запрос, 
и чтобы в параметре host было указано whoami05.docker.localhost
тоесть

$ curl  -H "Host:whoami05.docker.localhost"  http://127.0.0.1:90


90 = это порт на который мой трафеик принимает коммерческий трафик проксиования.

если мы достучались до контейнера whoami 
то он в ответ выдаст


IP: 172.30.0.2
RemoteAddr: 172.30.0.3:54358


тоесть он покажет свой локальный внутриконтейнерский ip 
и ip компа с котлрого к нему прилетел сигнал.
лнгко проверить что 172.30.0.3 это именно адрес нашего прокси сервера траефкиаа

$ docker inspect last-traf-01-1  | grep IPAddr
                    "IPAddress": "172.30.0.3"

ура!

итак выяснлась ряд важных вещей.
при старте докеров из композер файла он по дефолту их сует в отдельнуую сеть за бриджем.
или в терминах докера в отдельную бридж сеть.
контенера с разных бридж сетей не могу друг с другом комуницировать. 
поэтому траефик не может проскировать контейнеры которе нележат с ним воной сети.

для того чтобы трафеик понял что мы от него хотим в отошениии нового контейнера нужно 
новому контейнеру добавить докер метку. и в ней оисать что мы хотим.

labels:
   - "traefik.http.routers.whoami5.rule=Host(`whoami05.docker.localhost`)"


то через трафик можно достучаться до нашего новогог котнейрера через http запрос

curl  -H "Host:whoami05.docker.localhost"  http://127.0.0.1:90

где 90 это номер порта на который мы запрограмировали трафеик принимать комммерческий трафик.
(помним о том что у траефика у него неколько поортов. на один из них он принимает коммерческий трафик
чтобы его перенеравлять на контенеры. а вторйо порт это веб морда. эти два порта имееют соверщенно 
разное предназначение)

ЗАДАЧА: а можно ли покдлчить траефик к уже сущестуюещейсетям  и таким макаром прокировать доступ к
некольми бриджам?

ОТВЕТ: да. 


вот пример:
# .env
COMPOSE_PROJECT_NAME=who
# первый композер
# в нем после запуска сеть будет называться who_vasya
version: '3.5'

networks:
   vasya:

services:
  whoami-05:
     # A container that exposes an API to show its IP address
     image: traefik/whoami
     labels:
        - "traefik.http.routers.whoami5.rule=Host(`whoami05.docker.localhost`)"
     networks:
       - vasya


# .env
COMPOSE_PROJECT_NAME=who2
# второй композер
# в нем после запуска сеть будет называться who2_vasya
$ cat docker-compose.yml 
version: '3.5'

networks:
   vasya:

services:
  whoami-06:
     # A container that exposes an API to show its IP address
     image: traefik/whoami
     labels:
        - "traefik.http.routers.whoami6.rule=Host(`whoami06.docker.localhost`)"
     networks:
       - vasya


# .env
COMPOSE_PROJECT_NAME=last
#комопзер с траефиком
version: '3.5'

services:
  traf-01:
    # The official v2 Traefik docker image
    image: traefik:v2.10
    # Enables the web UI and tells Traefik to listen to docker
    command: >
               --api.insecure=true 
               --providers.docker
    ports:
      # The HTTP port
      - "90:80"
      # The Web UI (enabled by --api.insecure=true)
      - "8090:8080"
    volumes:
      # So that Traefik can listen to the Docker events
      - /var/run/docker.sock:/var/run/docker.sock:ro
    restart: always
    networks:
       -  vasya
       -  who_vasya
       -  who2_vasya


networks:
  vasya:
  who_vasya:
    name: who_vasya
    external: true
  who2_vasya:
    name: who2_vasya
    external: true


мы говоим комопозеру чтонадо покдлючить траефик к двум уже существующим (extrenal) сетям.
и тоогда тарефик без проблем проксиурет досту из себя до двух совршенно разных бридж сетей!
только есть проблема в том что при запуске нового контейнера если в нем указать неверный label
то он ломает весь трафик в траефике/
таким образом лучше все таки мнекажтеся все настроки делать в одном месте - в кпомозере траефика
центарилидованно. а не на внеших композерах других контейнеров.


далее пркол
restart:always
нельзя ограничить число перзагрузок. при рестарт олвейс оно бесконечное.
можно огранчить только если restart:on-failure:5
но прикол этой настроки что при ребуте компа конейнер небудет автоматом запущен.
остой.


про кониейнер whoami

version: '3.5'

networks:
   vasya:

services:
  whoami-05:
     # A container that exposes an API to show its IP address
     image: traefik/whoami
     labels:
        - "traefik.http.routers.whoami5.rule=Host(`whoami05.docker.localhost`)"
     networks:
       - vasya




  "traefik.http.routers.whoami5.rule=Host(`whoami05.docker.localhost`)"  = трефкик читает эотот докер лейбейл
  и поинимает что мы хотим. мы хтиим чтобы этот контейнер был досутпен если мы обрается на трефик по http/https
  и если хост хидер = whoami05.docker.localhost тогда надо направлять запрос на этот контейнер.

  обарщаемся на трафеик чтбы войти на этот контейнер вот так

$ curl -H "Host:whoami05.docker.localhost" localhost:90

Hostname: 8fa3b1f89113
IP: 127.0.0.1                            # ip контейнера 
IP: 192.168.64.2                         # ip контйенеа
RemoteAddr: 192.168.64.3:41070           # с какого ip на котенер потучасли
GET / HTTP/1.1
Host: whoami05.docker.localhost          # какой был http хост хидер в запросе
User-Agent: curl/7.58.0                  # далее идут HTTP header паарметры которые передал на whoami сам трафеки как прокси
Accept: */*
Accept-Encoding: gzip
X-Forwarded-For: 172.21.0.1
X-Forwarded-Host: whoami05.docker.localhost
X-Forwarded-Port: 80
X-Forwarded-Proto: http
X-Forwarded-Server: ce70071ae1b6
X-Real-Ip: 172.21.0.1


вывод - это портянка котоую сам whoami контейнер нам выдает. 
-H "Host:whoami05.docker.localhost"  = вот так мы передали нужный хост хидер



====
по дфеолту траефки обращется через сокет к докеру и читает инфо обо всех контейнерах.
и птыается их все аврматом к себе в конфиг засунуть.
нам это ненадо.

поэтому в настойки траефика доавбялем строку

command:
    --providers.docker.exposedByDefault=false

 она говорит о том что ненадо пихать в конфиг проксирования никакой контейрер по дефолту.
 таким макмром только кнтейнеры котоыре мы в явной форме рарешим проксировать будут доаблвены.
 это делается через настройку 

labels:
  - "traefik.enable=true"

только если этастрока будет доавблена в композер контейнера. только тоода он будет доавден 
в прокси конфиг траефка. отлчино!


--

строчка на юзерском контенере

 labels
 - "traefik.http.services.whoami5.loadbalancer.server.port=80"

дает то что мы сообщаем траефику на какой порт юзерского контейнера напрвлять внешний трафик.
ведь у контейнера может быть несколько портов. тоесть было бы непонятно

---

вот эти строки в траефике
command: >
             --entrypoints.http-int.address=:80
             --entrypoints.http-ext.address=:81

они про энтирипоинты
http-int и htt-ext это просто их имена
энтрипоинтов может быть хоть милльон.

далее еще более интересно. то что энтри поинты быают двух типов! UDP и TCP
вот UDP

command:
   --entrypoints.http-ext.address=:85/udp


 а вот tcp 
command:
   --entrypoints.http-ext.address=:85/tcp


по дефолту всегда tcp !!


---
ВОПРОС:
- как сделать чтобы роутинг связывал конеретный ентрипоинт с конкетным сервисом. другими 
словамт мне ненадо чтобы обращение на любой ентрипоинт вело на мой сервис.
мне надо чтобы я мог заэкспоузить мой сервис на конеретный энтрипоинт. тогда можно 
контролировать что mysql контейнер открыт для доступа исключеительно внутри хоста
а вебсерве1 открыт для доступа из интернета.


ОТВЕТ:
это регулируется в роутинге. 
по умолчанию когда мы обьявили в сервисе (при публикации ноговго контенера) что
мы хотим подключиться к траефку

labels:
        - traefik.enable=true
        - traefik.http.routers.whoami5.rule=Host(`whoami05.docker.localhost`)
        - traefik.http.services.whoami5.loadbalancer.server.port=80


тотогда трафеик создает роутер. и по дефолту этот ротуер связывает 
этот сервис со всеми entrypoint-ами!


вот мои энтрипоиинты
               --entrypoints.http-int.address=:80/tcp
               --entrypoints.http-ext.address=:81/tcp

  тоесть их имена
  http-int
  http-ext

одна из нх ведет в интернет
ав торая в локалку


 вот какой роутер будет создан по дефолту
 $ curl http://localhost:8090/api/rawdata | jq

"whoami5@docker": {
      "entryPoints": [
        "http-ext",
        "http-int"
      ],
      "service": "whoami5",
      "rule": "Host(`whoami05.docker.localhost`)",
      "status": "enabled",
      "using": [
        "http-ext",
        "http-int"
      ]
    }


тоесть  внем прописаны все точки ентрипоринты.

а нам то надо настрить чтобы выходб ыло только в ентрипоирнт который ведет в локалку

и вот она эта волшебная настройка

labels:
          - traefik.http.routers.whoami5.entrypoints=http-int

она говорит траетку что новый рутер должен смотреть только на htt-int энтрипоинт!
класно!

тогад поулуичмим

 "whoami5@docker": {
      "entryPoints": [
        "http-int"
      ],
      "service": "whoami5",
      "rule": "Host(`whoami05.docker.localhost`)",
      "status": "enabled",
      "using": [
        "http-int"
      ]
    }


видно что врутере остался один ентрипоинт
теперь при пулиукации нового контейнера можно контроливароровать куда он 
будет смотреть  - в лоалку или в интернет


но тут возникает одна бзаовая проблема - если мы поднимаем +1 контенер который имеет HTTP\s
порты то  мы легко может подмонтировать его к существующей ентри поинт. потому что 
через одну ентрипоинт может легко мультиплекситсья куча  hTTP потоков. мы их все
различаем через host паарметр.
 а вот если мы подмиаем +1 контейнер в котором будет простой tcp порт типа 3306 от мускула
 то чтобы его заэкспоузить нам нужен на траефике отедьный ентрипоинт. и тут 
 прблема  втом что чтобы доабвить в траефик +1 ентрипоинт , нужно менять его статик конфиг и 
 перезагружать его. а это жопа. потому что трафик будет рваться. кстатис сказать 
 мы не может использваться на хосте два инстанса траефика. потому что они оба будут 
 читать полный конфиг докера. и кждый будет в себя лепить они и теже сервисы. тоест 
 мы неомжем разделить контейнеры так чтобы одни смотрели в один траефик а другтие в другой.

 тоесть вся эта фишка что трефик динамически обнволяет свой конфиг без перезагрузок
 она работает только для HTTP трафика!!!!! 
 между прочим если делть точже самое через жинкс то он умеет пеерчитыать конфиг 
 налету! в трафеике при добавлеии нового контейнера мы не правим конфиг трефака но
 вбиваем конфиг в кажый новый контейнер. единетсвенное что если бы мы вбивали 
 конифг в жинкс то мы должны были бы вбивать в коинф Ip  конейнера или его hostname а 
 в траефике мы вбиваем в какой ентрипоинт надо подвязываться. плюс траефик 
 автоматом удаляет строки в коинфиге при удалении контейнера. в общем трафике 
врооде как поудонее. но вот то что он неумеет перчитывать конфиг на лету это очень плохо.
если я создаю много новыйх http контейнеров тогда все клеов. а если я создаю моного tcp 
контейорвов тогда с траефиком жопа.
есть еще выход это юзать tcp+tls(host sni) но это имеет свои минусы. помоему это также
значит что инцииаттор запросы дожжджен инциировать сопдениене чреез tls. 
а это уже совсем невседа взможсно. так что tls это остой вариат

отсетеся еще вариант - при публикации контейра если у него tcp порт то экспоузить
его на хост без использования траефика а прямо через спек его композера на хост.
тоесть по старинке. вот и приехали...

еще одн плюс траефка что он умеет сам всасывать сертификта в себя letecnryt
и сам умеет их одбновлять. вроде бы это выглядит попроще чем поднимать 
контенер с нжикс+supervisor+cron+certbot и все там настраивать.... или непроще?


==




ВОПРОСЫ:
- как перегрузить на гоярчую стат конфигурацию

ОТВЕТ:
никак

==

что надо сделать чтобы активироват досуту п конейтнерпу по HTTPS + создать сертвикиат через letseycnrypt

надо в конфиге траефкиа добавить
command:
       - --certificatesresolvers.le.acme.email=${LETS_EMAIL?Variable not set}
       - --certificatesresolvers.le.acme.storage=/letsencrypt/acme.json
       - --certificatesresolvers.le.acme.tlschallenge=true
volumes:
      - "./letsencrypt/acme.json:/letsencrypt/acme.json"

также надо создать папку
./letsecncrypt  (perm=700)
и файл пустой ./letsecncrypt/acme.json (perm=600)

также в .env
LETS_EMAIL=krivosheev@foxay.ru


вописание овгого контейнера добавить
labels:
        - traefik.http.routers.whoami-1.rule=Host(`${PRIMARY_DOMAIN}`)
        - traefik.http.routers.whoami-1.tls=true
        - traefik.http.routers.whoami-1.tls.certresolver=le

в .env
PRIMARY_DOMAIN=vasya.pupkin.ru

готово!

сертикаты он будет хранить в acme.json



==
настрока для перенрвления HTTP на HTTPS

на траефкиике:

command:
         # опрееляем ентрипоинты
       - "--entrypoints.http-ext.address=:80/tcp"
       - "--entrypoints.https-ext.address=:443/tcp"

         # для HTTP ентрипоита задаем правило редиркета
       - "--entrypoints.http-ext.http.redirections.entryPoint.to=https-ext"
       - "--entrypoints.http-ext.http.redirections.entryPoint.scheme=https"
       - "--entrypoints.http-ext.http.redirections.entrypoint.permanent=true"

        # эта хреното нам сериификаты изготваливает .а без них https нерабоатет
       - "--certificatesresolvers.le.acme.email=${LETS_EMAIL?Variable not set}"
       - "--certificatesresolvers.le.acme.storage=/letsencrypt/acme.json"
       - "--certificatesresolvers.le.acme.tlschallenge=true"

==
и тут следущий вопрос - а  как принимать на контейнер и HTTP и HTTP трафик?
ответ - нужно создать два ротуера. один для hTTPS а второй для HTTP
и чтобы кадый из роутров вел на отдельный entrypoint.
настрваиется в свойствах контейнера


  labels:
        # активация траефика
            - "traefik.enable=true"
        # говооиим трафеику что на контенера сутчать на порт 80    
            - "traefik.http.services.ft-nginx.loadbalancer.server.port=80"
        # первый роутер он связывается ентри поинт https-ext по протоколу HTTPS
        # с контейнером елси $host=${ERP_DOMAIN}
        # где $host это поле в протоколе HTTPS
            - "traefik.http.routers.ft-nginx-https.rule=Host(`${ERP_DOMAIN}`)"
            - "traefik.http.routers.ft-nginx-https.tls=true"
            - "traefik.http.routers.ft-nginx-https.tls.certresolver=le"
            - "traefik.http.routers.ft-nginx-https.entrypoints=https-ext"
        # второй роутер. он связывает ентри поинт http-int с контйенором
        # если $host=${ERP_DOMAIN}
        # где $host это поле в протоколе HTTPS
            - "traefik.http.routers.ft-nginx-http.rule=Host(`${ERP_DOMAIN}`)"
            - "traefik.http.routers.ft-nginx-http.entrypoints=http-int"


или можно вобще этого неделать того что мы только сделали
а пойти другим путем:
а сделаьт на самом траефике следущий фокус: если приходит завпрос
 на http://127.0.0.1:80  с хидером "domain"
то редиректить этот запрос на https://ext-ip с хидером "domain"  тоесть
если мы делаем

curl http://127.0.0.1:80 -H "Host:erp.fastrans.ru"
то он будет направлен на ext-ip ентрипоинт уже по протоколу https тоесть наш запрос 
правретиться в curl httpS://https-ext -H "Host:erp.fastrans.ru" 
тость мы HTTP запросы влетающие в локалхост перебарсываем на тот порт на котором сидит сертификат и 
запограмиован https, меняя наш запрос с http на https.
тоесть мы с внутреннего web порта все редиректим на внешний https порт. вот.






==

а если несклько доменов надо на контенер направлять ???
ответ: надо просто одбавить +1 роутер к контейнеру


     labels:
# общее
        - traefik.enable=true
        - traefik.http.services.whoami-1.loadbalancer.server.port=80
# domain-1
        - traefik.http.routers.whoami-1.rule=Host(`${PRIMARY_DOMAIN}`)
        - traefik.http.routers.whoami-1.entrypoints=https-ext
        - traefik.http.routers.whoami-1.tls=true
        - traefik.http.routers.whoami-1.tls.certresolver=le
# domain-2
        - traefik.http.routers.wh1-d2.rule=Host(`${PRIMARY_DOMAIN_2}`)
        - traefik.http.routers.wh1-d2.entrypoints=https-ext
        - traefik.http.routers.wh1-s2.tls=true
        - traefik.http.routers.wh1-d2.tls.certresolver=le

===

TCP port

как пробросить tcp порт наружу

в траефике доабвляем

   command: 
       - "--entrypoints.tcp5512-int.address=:5512/tcp"   ##
    ports:
      - "127.0.0.1:5512:5512"   # The TCP5512(LAN)  port в интернет


в контецнернер доавбялем
labels:
        - "traefik.tcp.routers.prosodyc2s.entrypoints=tcp5512-int"          #####  ентрипоинт имя (откуда прилетает сигнал)
        - "traefik.tcp.routers.prosodyc2s.rule=HostSNI(`*`)"                ##### так как tls выключен то вот ттак  
        - "traefik.tcp.routers.prosodyc2s.tls=false"                        #####  выключен tls
        - "traefik.tcp.routers.prosodyc2s.service=prosodyc2s"               #####  просто инфо плашка. типа смысл порта 
        - "traefik.tcp.services.prosodyc2s.loadbalancer.server.port=80"     #####  на какой порт принимать 
     

еще раз полчеркну что traefik.tcp.routers.prosodyc2s.service=prosodyc2s  это просто мы сами для себя
типа коментируем какой смысл иммеет проррос этого порта. например типа "mysql"
===
охиренная штка

вот  унас есть composer config котоыйр имеет нестартадартное имя.
вопорос - а как тогда билдить имадж из такого компзера? ведь

$ docker compose build 

он ишет исчключиетльно docker-compose.yml файл.

ответ
создай .env и  в него впиши 
COMPOSE_FILE=docker-compose-treafik.yml

и вуаля! docker compose build будет лезть в нужный нам файл


кстати скзаать запусить сервис из нестартаного компзер файла тут без пробелем
 
$ docker compose -f docker-compose-treafik.yml   up -d
==

host.docker.internal неработае сука.
но можно вот как сделать

 extra_hosts:
             - "host.docker.internal:host-gateway"

host-gateway тоженерезовалисят
но вот с добавкой мы получим в /etc/hosts запись на гейтвей докера.
и тогда host.docker.internal будет резолвится на гейтвей докера.

дебилим. баге уже 5 лет.

====
про линукс. прикол

у нас есть папка /01
на нее мы имеем полыне права

и у нас есть папка /01/02

на нее права имеет только root
так вот это дает то что в папку /01/02 может писать тоько root
предположим она пустая. так вот мы можем удлить папку /01/02 
потому что удаление этой папки это изменение записи в /01 а на нее мы имемм полгные права. вот такой прикол

 
====

