| context switch
| preemption

это пиздец даже здесь засада
цпу состоит из двух вещей. первая это то что 
внутри цпу есть маленький кусок памяти \ RAM это его регистры.
а второй его кусок это та часть в которую грузятся команды 
которые он исполняет. тоесть у него есть иполнятельная часть.
за что он собственно и называется цпу. едиснвтенное что  я только 
не особо могу примопнить хотя бы одну команду ассемблера которая 
с одной стороны чтот делает а с другой стороны не меняет при этом
хотя бы один регистр. 

также я прочитал тут 
	(https://stackoverflow.com/questions/65173072/where-are-program-registers-stored-during-an-interrupt-in-x86-64)
о том что если случился hardware interrupt
то сам цпу сохраняет только вот эти регистры
	Interrupts / exceptions only save CS:RIP, RFLAGS, and the user-space SS:RSP
а все остальные сам цпу не сохраняет. и это уже работа интеррапт хендлер
кода чтобы сохранить те регистры которые он собирается менять.
как я понял RIP хранит инфо где лежит следущая команда
RSP хранит адрес где лежит стек.
RFLAGS это флаги.

тут еще вопрос - вот случился интрапт. и на цпу загрузилась 
первая комана интеррапт хендлера. а при этом случаетя новый интеррапт
что происходит далее - загружается код нового интерапт хендлера на цпу?
и еще - важно понять в случае когда интерапт идет по той же линии IRQ 
или он случился на другой линии IRQ

получается как только код интрапта загузился на цпу он дожен первым делам
нахер запреить все остальные интарпты. потом сохранить те регистры которые 
он будет менять. поделать свои дела. потом вернуть обратно поменянные
регистры обратно. потом снять запрет интераптов. 

а что в это время с железами происходит? они перестают обслуживать события или что?
например пакеты придетают в сетевую карту. они что дропятся железой или что?

===

| atomic context
| process context

часто про ядро пишут эту хрень.
как я понял это означает то что код ядра работает на цпу в таком режиме 
что его оттуда невыковырять ничем. тоесть в этотт момент этот код заблокировал
все интерапты. поэтому он может сидеть на цпу солко хочет времени. раз интерпаты
залкировны то никккой другой код в цпу влезть (сдделать примпт)  несможет.
и только этот код сам доброводно может вернуть обратно цпу.

как я понял шедулер когда делает свои черные дела как раз раобтает в этом режиме.
ососбенно когда он двигает регистры от одного прцоесса другому. если его в это
момент прервать будет залупа? тоесть я так понимаю что context switch
это атомарная операция. ?

когда атомик контекст то ядро так умудряется все заблокировать сидя на цпу
что его оттуда никто не выдавит пока оно само себя оттуда не выдавит.

а process context это когда ядро делает чего то для процесса 
и это неособо важная хрень поэтому интеррапт разрешен который выдавит preempt
это код ядра нахер оттуда.
