| terminal
| console
| gnome-terminal
| xterm


вот у нас есть черное окно от gnome-terminal
я тыкаю кнопку как потом оно куда летит?


keyboard - Xorg - gnome-terminal -/dev/ptmx -- 
-- tty driver -- /dev/pts/10 --- bash



я тыкаю кнопку в черном графичеаком окне. оно 
летит в драйвер клавы а от туда граф подсистему услонво говоря в Xorg 
процесс. оно через локальный юникс сокет посылает
этот байт в  gnome-terminal он это обрабаывает
и (тут важно)

gnome-terminal связан с прцоессом bash 
через связку


gnome-terminal                     bash
         /dev/ptmx -----  /dev/pts/10

причем между ними еще в ядре сидит tty driver



gnome-terminal                                 bash
         /dev/ptmx --(tty-driver)---  /dev/pts/10


так вот настройках гном-терминал 

  edit-preferences-profiles-comptibility


там есть такие настроки как 

 backspace key generates:
 delete key generates:

и у них ест вот такие пункты
ctrl-h
ascii del
esq sequence

как это работает? и хер ли оно тут делает?
а раобтает это так что когда
мы тыкнули кнопку backspace или del
то она из граф подсистемы как я описал выше
влетает внутрь процесса гном-терминал
и он этот байт может сопоконйнько заменить на лету.
а уже потом этот байт шлется в tty driver через
/dev/ptmx
а уже только потом через него  в баш. 
так вот получается что прежде чем байт с клавы
попадет в tty driver он вначале попадает в gnom-termi
nal. поэтому он может менять этот байт на лету
поэтому мы в гном терминал настроках можем управлять
какой байт попадет в ttydriver если мы нажали
на клаве кнопки backspace или del

также в этом же меню есть натсройка 
  Encoding:

она нужна уже в обратном направлении. когда 
из tty driver в /dev/ptmx летит каойто байт
влтает в gnom-terminal то он его должен проинтерпре
тирвать в какойни будь глиф который он уже потом
пошлет на граф подсистему (в Xorg) поэтому тут
и играет роль закладка encoding. мы получается можем
из баша или другой юзер пргарммы слать на gnom-ter
minal байты в дикованиной кодриовке типа koi8-r
и чтоы гном0-терминал мог прроинтерпетировать эти
байты в нужные нам глифы можно поменять кодировку
в его этом меню.

так вот  с помощью напрмиер 

  $ strace -xx cat

можно выяснить какой байт код гном-терминал шлет
в /dev/ptmx а значит и в tty driver а значит и в
дальнейший /dev/pts/10 и в юзер приложение в конечно
м итоге при нажатии на кнопку DEL
и пнуктах в меню

Contrl-H
ASCII DEL
Esc sequence
TTY ERASE


давай выяснять.

   $ strace -xx cat

ключ -xx даеет то что в выводе strace в сисколах
read() write() он будет риосвать hex вид байтов а
не трансировать их в граф символы.

нажимаем del и Enter (потому что  у нас на термина
ле канон режим. поэтому байты из tty driver попдают
в юзер приложение только после нажатия enter)

у меня выставлено в gnome-terminal

  DELelete key generates: ESCape sequence

вижу на экране

read(0,"\x1b\x5b\x33\x7e\x0a", 262144) = 5
write(1, "\x1b\x5b\x33\x7e\x0a", 5
)  = 5

на самом деле меню названо делиьно. нало его
было бы назвать "во какой байт gnome-terminal
преобразует байт прилетевший с клавы при нажатии
DEL и направляет его в tty drvier"

тоесть я хочу скзаать что по факту DEL генеиррует
другой байт кодд а в этом меню мы его МОДИЙИЦИРУЕМ.

итак получается что если в гном-териминал выставлено

  DELelete key generates: ESCape sequence

то он преобразует байт нажатия DEL в 

     \x1b\x5b\x33\x7e

и это байт код прилетит в tty driver а затем в юзер
процесс который сидит за терминалом. скажем в баш

а что это за  секвенс

\x1b\x5b\x33\x7e = ESC  [  3  ~

в умной литература по термиалам ESC [  называют CSI
в итоге 

      CSI 3 ~

именно так и нужно искать в инете инфо по этой
секвенс.


ИТУТ ОТКРЫЛСЯ ОЧЕРЕДНОЙ АД связанный с DEL
welcome to hell

итак начну расписывать АД.

для начала малек в сторону вот тут
 
  https://en.wikipedia.org/wiki/Newline

расписан тот ад о том что какие символы LF или CR+LF
дожны исплзоваться чтобы на приентере или дсиплее
у нас курсорк\каретка отехала в начало строки
и прокрутило курсор на одну строку вниз. мудота
та еще. могу еще раз скаазать что что касается 
линукса то тут это дело регулируется в двух местах.
в настройках самого терминала можно отрегулировать
что если в него прилетает LF или CR то терминал 
автоматом реагирует так как бутто в него приелетел
LF+CR . а можно настроить что прилет LF дает 
толко LF а прилет CR дает только CR. дело в том
что в линуксе вот каконо есть LF это только опускание
каретки на одну строку вниз без вовзарта в начало
строки. а CR это пеерход в начало строки без 
опускниея курсора вниз.
есь и второе место это tty driver так вот в нем
есть настройки о том что если поток летит на дисплей
то если летит LF то заменить его на LF+CR
и за счет этого трюка когда мы шлем текст из файла
на экране терминала и в тексте у нас идет LF(0x0A)
то в терминал приелетает LF+CR и мы видим на экране
перенос строки.

возвращаемся к кнопке DEL
начинаем читать про телеприентеры
  https://en.wikipedia.org/wiki/Teleprinter
я если четсно непонял в чем раница между
телпринтером и телетайпом. ну вроде как теелетайп
это частный случай телеприентров в том плане что
телппринтеры работали через разные типы каналов
а телетайп работаел через общие телефонные линии.
но это неточно. хер поймешь.
так вот там написано что были телепринтеры. это
как печатная машинка но ты тыкаешь на кнопки
и она во первых генерирует печатный знак на бумаге.
а еще она печатает на перфоленте 5-ти битовый 
значок либо 7-ми битовый значок.тоесть перфолента
была как жесткий диск на компе только из бумаги.
на котором печатлся байт. в одном случае пятибитовый
(код бодо) в другом сулчае семибитовый (ASCII).
и далее это сигнал улетао по каналу связи на такой
же удаленный телепринтер. 
далее переходим к известной модели  

  teletype model 33  ASR


https://en.wikipedia.org/wiki/Teletype_Model_33


ASR значит что у него была клава. был перфопринтер.
написано что клава была такова что машина в итоге
гегнерировала только заглавные буквы от ASCII.
генерация байт кодов мелкийх букв не была предусмо
трена.

так вот на картинке видно какая была там клава

https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Mappa_Teletype_ASR-33.jpg/440px-Mappa_Teletype_ASR-33.jpg


это была одна изпервых машин которая использовала семи
битный способ кодировки. тоесть ascii. мы жали на 
кнопку и она хеачила в канал связи 7 бит плюс
один бит контроля четности. 


в какйото степени данные машины работали с цифровыми
сигналами. и использовали байты размером 7 бит.
тоесть по каналу связи идет сигнал который потом
трансформируется так или иначе в 7битный байт
и трансофрминуется в символы или хуй знает.

так вот возвращаюсь к клаве этого аппарата

https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Mappa_Teletype_ASR-33.jpg/440px-Mappa_Teletype_ASR-33.jpg

эта клава поддерживала генерацию не всех байт
кодов таблицы ascii но часть кодов она могла генери
ровать согласно кодироваке этой таблицы.
в частности не было маленьких букв. были только
большие.
но это неглавное

главное
там были кнопки
BACKSPACE
LINE FEED
RETURN 
RUBOUT

значит как видно тут нет кнопки DEL\DELETE которая
есть на сворменных клавах. есть кнопка RUBOUT которой
щас нет. есть кнопка LINEFEED.
короче рассмотрим эти кнопки.
но вначале вот что еще надо сказать. телепринтер
это было сочленение трех хреней. клава, обычный
приентер и перфопринтер. мы нажимае клаву и происходит
какоето действие на обычном приентере - прчием два
типа там событий либо чтото печатеся либо двигается
кусор\каретка либо двигается вал прокрутки листа,
также происходит печать на перфопринтере байт кода
который породила клава. ну и еще байт код полетел
по проводу кудато. таким образом важно то что нажатие
клавы нетолько печатает на обычном принтеер  но
и еще печатает на перфопринтере. перфопринтер нужен
затем что потом можно в него засунуть эту ленту
с байтами и тогда можно запулить байты в сеть и
напечатать символы на принтере без нажатия на клаву.
перфопринтер это аналог древеней дискеты только 
в отличии от дискеты на ней нельзя заменить один 
байт другим. одноразовый носитель информации. типа
как cd-r диск. наажатие на клаву порождает запись
байтов на перфобумагу, печать символа на обычном
принтере, и отсылка байта в сеть. 
теперь рассмотрим конкетные кнопки на клаве.

нажатие на BACKSPACE вело к тому что на обычном
принтере(дале просто принтер) каретка сдвигалась
на одну позицию влево. никакого при этом затирания
символа не было и в помине просто перемещалась каретка
и не более того! на перфопринтеер печатался 0x08
а теперь сразу сравним что происходит на соверменных
компах. у нас есть эта кнопка. но при ее нажатии
происходит чтот совершенно другое. и байт код генер
ируется совершенно другой! 
во первых я напомню схему между клавой и юзер 
приожением для случая линукс текст консоли


keyboard - драйвер клавы - эмулятор терминала --- 
-- tty driver -- /dev/tty2 --- юзер процесс(ЮП)


здесь важно что что на пути байт кода который
реально рождает клава к ЮП (там где мы его реально
можем поймать) у нас сидит эмулятор терминала который
можем поменять байт код и сидит tty driver который
тоже может поглотить или изменить байт код.
в приницпе мы можем рассмотреть байт код неисполь
зуя ЮП а используя tty driver. можно его вклюить
в режимы echo echoctl
это даст то что если в него влетает байт с клавы
то он автоматом шлет обратно либо этот же байт
либо в случае если байт котоырй овтечает не за граф
мисволы а байт управляющий (0x00-0x1F, 0x7F) то он
оратно пошлет два символа ^N где N это исходный байт
к которому приавбено 0x40 а в случае 0x7F он от него
отнимет 0x40 


для случая граф терминала

keyboard - Xorg - gnome-terminal -/dev/ptmx -- 
-- tty driver -- /dev/pts/10 --- bash


тут прикол в том что эмулятор терминала такой как
gnome-terminal он при влете в него с клавы управля
ющих байтов их на лету модифицирует и дальше пускает
именно модифиицрваонный байт. а именно идем в настрой
ки его в 

edit-prefrrences-profile-compatibilty
    backspace key generates: ASCII DEL
                               /|\
                                |
                             вот тут можно 
                             редактировать

таким образом в данном случае при нажатии на клаве
на бекспейс какойто байт код хер знает какой
влетает в гном-терминал и он из себя выпустит 7F 
байт код. который уже и влетит в tty driver.

в xterm я тоже думаю это можно подкручитваь. потому
что он тоже стоит между клавой и tty driver

    клава --...--xterm-- tty driver -- ЮП

еще раз что дает echoctl. если у нас включен режим
эхо то tty driver при получения байта с клавы 
автоматом обратно шлет исхдоный байт. но! управляющие
байты ониже если их прислать на терминал то они же
никакие глифы не кодируют. они всякие вещи делают
например двигают курсор. поэтому если мы хотим 
видеть на дисплее какойто визуализиовнный явным обра
зом глиф для упровлящего байта то момжно ппопросить
ттай драйвер чтобы если он получает байт управляющий
с клавы чтобы он обратно слал не его два других 
байты каждый из которых это класический граф глиф.
вот это и делает echoctl . тогда ттай дрвер пошлет
обратно на дисплей символ ^ и символ N где
N это (исходный байт + 0х40) а если это был 7F
то (7F-40)

нпрмиер если исходный байт 0x08 то он обратно пошлет
  ^ и 0x48 или  ^H

таким образом чтобы нам понять какой байт влетел 
с клавы в ттай дрвер мы откидываем ^ берем H находим
его байт код в ascii и отнимает от него 0х40 и узнаем
какой байт код влетел.
для символа 7F это будет ^?

еще нам надо отключить канон режим потому что 
в этом режиме если ттайдрайвер получает байты 
котрые у него указаны вот тут 

 # sttya -a
 intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O;

то тогда он как правило такой байт не оптравляет
ни к ЮП ни обратно на терминал а вмето этого делает
спецдействие. а это нам ненадо. а вот если у нас
НЕканон режим то он на эти байты нерегирует. он 
их пеересылает к ЮП и\или обратно на дисплей.
например вот у него прописано 
 intr = ^C
это значит что если в него влетит 0x03 то он 
небует этот байт то он вызовет SIGINT для ЮП процесса.
это нам все щас ненадо.
поэтому щас будем ловаить байты которые при нажатии
клавы летят в tty driver и в ЮП через вот ттакой
план. запускаем

   # strace -xx cat

далее в другом терминале для этгого терминала
устанавливаем ттай дарйвер настрйоки

  # stty --file=/dev/(ttyN/pts/K) -icanon echo echoctl

тогда мы увиди и с точки зрения стрейс какойто байт
ттай дравер просунет в ЮП и также сам татй дравер
нам пришлет на дисплей инфо о том какой байт он 
получил с клавы.

запускаем эту хрень на линукс консоле
и жмем кнопку BACKSPACE

read(0, ^?"\x7f", 262144)                 = 1
write(1, "\x7f", 1)                     = 1

вот здесь ^? нам ттай драйвер послал на дисплей
инфо о том байте который он получил с клавы.
это 7F и сам стрейс нам покзыает что 

read(0, "\x7f", 262144)                 = 1
write(1, "\x7f", 1)                     = 1

он поучил от ттай драйвер 7F

итак в линукс консоле если я тыкаю BACKSPACE
то терминал получив это нажатие шлет в ttydriver
байт 7F

клава -- драйвер клавы --эмулятор терм VT100 --
--tty driver

теперь делаю тоже самое для гном-темринал
read(0, ^?"\x7f", 262144)                 = 1
write(1, "\x7f", 1)                     = 1

получаю тожесамое. тоесть гном терминал получив
от клвы мы незнаем каокй байт код он пмхает в 
ттай драйвер 7F
в данном случае оно приоисходит так понятно почему
потому что я уставновил всвойствах гном терминала
вот эту настройку

edit-prefrrences-profile-compatibilty
    backspace key generates: ASCII DEL

тоесть я скзаал гнмо терминалу что если в него
с клавы влетает байт код с кнопки бекспейс(причем
мы незнаем чемуравен этот байт код) то чтобы
он в ттай драйвер пихал вместо него байт ASCII DEL
символа тоесть 0x7F

теерь тестирую в xterm
в нем все по другому!

read(0, ^H"\x08", 262144)                 = 1
write(1, "\x08", 1)                     = 1

xterm полуив с клавы каойто байт шлет на ттай
драйвер байт 0x08  
и мы это видим как по показанияем стрейс

read(0, "\x08", 262144)                 = 1
write(1, "\x08", 1)                     = 1

так и попопказаняием echoctl от tty driver
    ^H

код H это 0x48
отнмиает от него 0х40 и получаем 0x08

итак я соирпаю табицу про нажатиа не BACKSPACE
какой байт разные эмуляторы терминала суют в ттай
драйвер

lnux console 0x7F (ASCII DEL)
gnome-term   0x7F (ASCII DEL)
xterm        0x08 (ASCII BACKSPACE)


по сути мы щас что сэмулировали. мы сидит да теле
принтером и нажали кнопку BACKSPACE и смотрим какой
байт был напечатан не перфопринтере.
и видим что только xterm работает как телеприентер.
остальные термиалы работают по другому!

что еще тут важно заметить. что получается нажатие
на кнопку далеко не всегда влечет за собой что
у нас будет сгенерирован тот ASCII код название
которого напсрвано на кнопке! тоесть у нас есть 
ASCII симолв BACKSPACE 0x08 мы на клаве жмем
кнопку под назанием backspace однако телппринтер
нам генреирует совершенно не одноименный байт код!!
теперь такой момент. что если в терминал послать 
байт код 0x08  тоесть послать ascii backspace.
а будет вот что (ксати совсеременные термиалы отли
чабтся от телринтеров тем что у современных эмулято
ров териалов нет устроства перфопринтера тоесть
нет устройства куда сохранятся байты. хотя опосредо
ванно оно есть - байты пихаются в ЮП. тость храни
лищем байтов от телепринтера явялется память ЮП.
хотя может быть ЮП эмулирует канал электросвязи
потому что байт пихался нетолко на перфопринтер
но и в сеть)

тоесть раньше было так


            |---- сеть
 клава ---- |---- притер
            |---- перфопринтер


а щас стало

            |---- ЮП
 клава ---- |---- дисплей


так вот если я шлю на дислелй 0х08 (считай что 
этот байт прилеетел на телепринтер из сети)
то у меня каретка\курсор смещается на экране на 
минус 1 символ влево. при этом содержимое ранее
напечатанного символа не затрагивается. тоесть
при смещении каретки у меня символ незатирается.

итак получается ascci BACKSPACE символ он не приводит
к затиранию! он только приводит к смещению курсора!
а какой ксати в этом может быть смысл? ну напрмиер 
такой что мы напечатли текс. а потом хотим его граф
ически зчеркнуть. для этого мы печатем текст. потом
смещаем обратно каретку. и печатем поверх него
знак '-' и у нас будет воткой зачеркнутый текст.
это в случае принтера. на дислпеет терминала понятно
что каждый глиф он занмает всю матрицу целиком поэтому
на дислпее никаких наложений не будет засчет этого
трюка. 

итак к этом  моменты мы выяснили пока что вот какие
вещи  - нажатие кнопки BACKSPACE в разных терминалах
приводит к тому что эти терминалы суют разные байт
коды в ттай драйвер. нажатие на кнопку с какимто
символом нариосванным не влетчет за собой чтобы
именнно одноименный байт код был порожлден этой
кнопкой (да вот такой прикол и парадокс).
байт код ascii backspcae 0x08 если его направит
на телепринтер то он ведет к тому что символ слева
не затирается а просто курсор смещается влево. 
кстати это полность вкладывается в случай когда
у нас устроство отображения принтер. дело в том
что нажатие на SPACE у нас делает то что каретка
просто сдвинается на 1 позицию вправо при этом она
ничего не печатает! поэтому BACKSPACE ASCII код
он делает тоже самое. он ничего не печатает. он просто
двигает каретку на позицию влевло. если ascciii space
двигает каретку на позицию вправо то ascii bacjspace
двигает картеку на позицию влево. так рабоатло это
на телепринтерах. а что будет если я на термиал
направю ascii SPACE 0x020 ? он просто сдвинет 
курсор или он еще зарисует позицию черным квадратом?
ответ - он сидвинет курсор и зарисует позицию черным
квадраторм. тоесть он затирет сивол. тоесть еще
раз если  я шлю 0x08 то на дислпее затирания нет
есть толкьо сдвиг каретки. а если я шлю 0х20
тои идет исвиг каретки и затирание символа. 
это повдение не советвует повеедению телепринтеров.
итак фиксиуруем такой момент.
ascii BACPSPACE 0X08 байт его физ смысла для тееле
принтеров был в том чтобы сдвинуть каретку налево.
в терминалах нащих это действие сохранилось.
ascii space 0x20 приаодил к тому что сдвигалась
каретка на позцию напраов. 
в свременных термиалах. действие 0х08 соханиалось
а дествие 0х20 несохранилось.
запомнили. 


выше я показал что при нажатии на бексейс у нас
в систему шлетс нетолько 0х08 но и 0х7F 
что будет если в терминал сунуть 7F как он это "отрисует"?
ответ - он никак это не отрисует! тоесть в окне
терминала ничего не произойдет. РОВНЫМ СЧЕТОМ НИЧЕГО!
я поробвал это на всех трех теримналах.
а что же делало 7F на древних телепринтерах?
а делало оно вот что (совсем нето что мы думаем).
а дело было так. на приборе модел 33 была какая то
кнопка которая неприводила к генерации никакого 
байта на перфопринтере и ничего не делала на обычном
приентере. вместо этого она позволяла прокрутить
головку перфопринтера на некоторый байт. и если
он был ошибочный то была кнопка на клаве RUBOUT нажатие на которую на обычном принтере ничего не
делало. а на перфопринтере пробивались все 7 дырок.
тоесть ведь любой байт семибитовый в итоге можно 
прраить всегда в 7F. и что это давало? это давало
то что если потом эту перфоленту вставить в лепреинтер
и сказать  - печатай что тут закодировано то если
он встречал 7F то это для него был знак что в этом
месте был ранее напечаатн какойто ошибочный байт код
и это его так закрасили. и он его просто игнорировал.
вот какой изнчлный физ смысл байт кода 7F это чтото
типа признакака BADBLOCK. замечу что при встрече
7F (пусть он даже из сети прилеетел) на обычно
принтере ничего не происходило! вот это поведение
мы и видим на диспееллее терминала. потому что 
дислпй это в какойто степени аналог обычного принтера.
насколко я понимаю при нажатии на RUBOUT было действие
только на перфопринтре а всеть этот байт не улетал.
потому что можно было путем покруивания какйото 
там ручки выбрать любой байт на перфоленте. 
и эта инфо конечно же не предавалась по сети.
замечу еще то что байт 7F (ASCII DEL) генеровался
по кнопке с названеим RUBOUT а не DEL что тоже по
мне дебильно. полная путаница. кнопки DEL вобще
небыло на телперинтере MODEL 33.
теперь когда стало понятен физ смысл кода ASCII DEL
возникает вопрос - а нахуй этот байт код генерирвать
в случае наших термиалов. ведь у них нет никакой 
перфоленты!(как я понимаю теперь оптрава с клавы
байта в ЮП это аналог отправки байта с телепринтера
в сеть!). ну я еще встречал в вкипедии хотя там 
путано что якобы! якобы! если я жму RUBOUT то
у меня печтается 7F и якобы это еще могло значит
что якобы преддыдущий символ невалидный. но по мне
это полная хуйя. потому что тогда телпринтер 
при обработке перфоленты должен был бы читать по 
два байта за раз чтобы проверять не явялется ли 
второй байт 7F и значит первый байт типа ненадо
петчать. поо мне это все бред. по мне рабоало
именно как в первом слчае. оператор крутил перфоленту
руками. выбирал байт. тыкал RUBOUT и помечал его
что это неваоидный байт. в сеть этот 7F непредавался.
поэтому в нашем случае этот байт код по мне 
абсолютно бесполеезен ибо у совренных терминалов 
нет никакой перфоленты. ну еще когда бы это имело
смысл. челоек напечатл символ. не телеприенере
потом тыкает rubout и на перфопринтере замеаешатся
последний нажатый байт в 7F. ну тогда это бы
имело смысл и для отправки по сети. типа вот 
мы отправили символ поседний а на самом деле это
мусор. ну тогда бы на простом принтере по хорошему
должно было бы быть то что картека взрващается
и посдений символ както там закрашивает. но!
насколко я понял ничего это небыло!
вот что пищет виикпедия

The Teletype Model 33 provided a key labelled RUB OUT to punch this character (after the user backed up the tape using another button), 

ксати вот тут я нашел манул от МОДЕЛ 33

https://deramp.com/downloads/teletype/Model%2033/TTY-33%20Theory%20of%20Operation.pdf

и там на картинке нарисовано что кнопка называеласт
не RUBOUT а DELETE! хотя вэтмо же тексте она
называется RUBOUT
кстаи там написано что байт перадвался вот как.
был один старт бит. потом 7 бит данных. потом один
бит для кода четности ( по правилу even parity)
и потом было 2 стоп бита. таким образом чтобы передать
7 бит инфо испольолзловалось 11 бит рабочих.

вот я еще нашел воттут
https://sites.google.com/view/elizaarchaeology/blog/2-talking-to-eliza-on-an-asr-33-teletype


When you press a key on the ASR 33 keyboard, the machine transmits eleven bits: 1 start bit, 7 ASCII data bits, 1 even parity bit and 2 stop bits. It transmits these at 110 baud, which means it can transmit at a maximum of 10 characters per second. It receives data at the same rate.

вот приколно еще написано
The teletype needs the linefeed (LF) to be sent after the carriage return (CR) to give the carriage time to return to the first column. But the carriage might still be returning when the linefeed is complete, in which case the first character on the next line might be printed in the wrong place. It was common practice to send a non-printing ASCII NUL character after the linefeed to give the carriage that additional tenth of a second to get home. I found I needed to send two NULs to be sure the carriage was home. This isn’t necessary for glass teletypes, i.e. Visual Display Units. A more complete solution might make this configurable.

вот тоже приколоно написано
When the carriage gets to the end of the line it simply stops moving right. Every character sent to it by the computer is printed in the last column on top of the previous one. I added code to automatically return the carriage to the start of the next line once column 72 is reached. This should be configurable.

вот тоже прикольно напсисано
My ASR 33 has a 3-position knob marked SIMPLEX, LOCAL and DUPLEX. When in simplex mode a keypress is both printed and transmitted. When in duplex mode a keypress is transmitted but not printed. In this mode only characters received through the serial cable are printed. In my implementation I assume the teletype is in full duplex mode and echo back characters so the user can see what they have typed. This should be configurable.

и вот наконец что он пишет на счет RUBOUT
If you mistype a character on the teletype, what are you going to do? There is no backspace. There is a RUB OUT key that transmits ASCII DEL. This could be used to virtually delete the previous character. (Once the character is printed on the paper the ASR 33 has no means of erasing it.)

во первых непонятно как это там нет бексейса
когда на клаве наисовано что он есть(в вики это
нарисовано). во вторых
нпонятно какой смысл слать по сети ASCII DEL.
что это даст? ведь предыдущий симовол уже напе
чатан!
а вот в этом мануале

https://bitsavers.org/communications/teletype/33/273B_Mod32_33_TechMan_Jan63.pdf

статница 248 нарисовано что действиетльно! никакой
кнопки backspace не было! 

на старнице 236 нарисована та часть ascii табицы 
тоесть те 7битовые байты которые данный апарат 
поддерживал. то есть он их понимал он чтото делал
когда он их получал. фишка в том что модел 33
понимала только ЧАСТЬ из битовых хреней таблицы 
ASCII.  что еще странно что они утерваждают что
в сеть они предавали 11 бит при предаче 7битного
аски кода. вот таком виде 

 1 старт бит 7 бит аски 1 бит чет парити 2 стоп бита

так вот на стр 236 почему то в таблице восьмой бит
нарисован все время закрашенным. как я понимаю
биты в этой таблице нарсиованы так как они передавал
ись в сеть и печатались на перфоленте.  в этом
разрезе непонятно почему 8-ой бит у них сука все
время включен?!?!!?!?!?

согласно табице на стр 236 если конешно я ее понимаю
то мало того что на клаве небыло кнопки backspace
но и в таблице подеживаемвых байт кодов у нас
нет поддержки кода 0x08 ascii backspace. 
тоесть вроде как у этой машины ни кнопки не было
такой и также она не поддрежилавала байт код такой.

значит я взял табицу ascci из ascii.txt
и я в левой колонке нарисовал те байт коды
которые как я понимаю распознавал телетйап 
модел 33. наскоко я понимаю если в него прилетал
байт код котрый он не распознавал то он нихуя
при этом не делал. если в левой колнке в строке
ничего не нпасано значит этот байт код он
не понимал. 
таким образом по моим понятиям он 
распознавал 80 байт кодов. тоесть 64 печатных символа
и 16 управляющих байт кодов.


         
Model33    BIN      Hex   Char                        
─────────────────────────────────────────────────
          0 00 00000   00    NUL '\0' 
          0 00 00001   01    SOH 
          0 00 00010   02    STX 
          0 00 00011   03    ETX 
EOT       0 00 00100   04    EOT 
WRU       0 00 00101   05    ENQ 
RU        0 00 00110   06    ACK 
BELL      0 00 00111   07    BEL '\a' 
          0 00 01000   08    BS  '\b' (backspace)     
TAB       0 00 01001   09    HT  '\t' (horizontal tab)
LINE FEED 0 00 01010   0A    LF  '\n' (new line)    
VT        0 00 01011   0B    VT  '\v' (vertical tab)
FORM      0 00 01100   0C    FF  '\f' (form feed)   
RETURN    0 00 01101   0D    CR  '\r' (car return)
          0 00 01110   0E    SO  (shift out)        
          0 00 01111   0F    SI  (shift in)         
X ON      0 00 10000   10    DLE (data link escape) 
TAPE      0 00 10001   11    DC1 (device control 1) 
X OFF     0 00 10010   12    DC2 (device control 2) 
TAPE(зач) 0 00 10011   13    DC3 (device control 3) 
          0 00 10100   14    DC4 (device control 4)  
          0 00 10101   15    NAK (negative ack.)     
          0 00 10110   16    SYN (synchronous idle)  
          0 00 10111   17    ETB (end of trans. blk) 
          0 00 11000   18    CAN (cancel)            
          0 00 11001   19    EM  (end of medium)     
          0 00 11010   1A    SUB (substitute)        
          0 00 11011   1B    ESC (escape)            
          0 00 11100   1C    FS  (file separator)    
          0 00 11101   1D    GS  (group separator)  
          0 00 11110   1E    RS  (record separator) 
          0 00 11111   1F    US  (unit separator)   
          
 SPACE    0 01 00000   20    SPACE                  
 !        0 01 00001   21    !                      
 "        0 01 00010   22    "                      
 #        0 01 00011   23    #                      
 $        0 01 00100   24    $                      
 %        0 01 00101   25    %                      
 &        0 01 00110   26    &                      
 '        0 01 00111   27    '                      
 (        0 01 01000   28    ( 
 )        0 01 01001   29    ) 
 *        0 01 01010   2A    * 
 +        0 01 01011   2B    + 
 ,        0 01 01100   2C    , 
 -        0 01 01101   2D    - 
 .        0 01 01110   2E    . 
 /        0 01 01111   2F    / 
 0        0 01 10000   30    0 
 1        0 01 10001   31    1 
 2        0 01 10010   32    2 
 3        0 01 10011   33    3 
 4        0 01 10100   34    4 
 5        0 01 10101   35    5 
 6        0 01 10110   36    6 
 7        0 01 10111   37    7 
 8        0 01 11000   38    8 
 9        0 01 11001   39    9 
 :        0 01 11010   3A    : 
 ;        0 01 11011   3B    ; 
 <        0 01 11100   3C    < 
 =        0 01 11101   3D    = 
 >        0 01 11110   3E    >
 ?        0 01 11111   3F    ?
          
 @        0 10 00000   40    @
 A        0 10 00001   41    A
 B        0 10 00010   42    B
 C        0 10 00011   43    C
 D        0 10 00100   44    D
 E        0 10 00101   45    E
 F        0 10 00110   46    F
 G        0 10 00111   47    G
 H        0 10 01000   48    H
 I        0 10 01001   49    I
 J        0 10 01010   4A    J
 K        0 10 01011   4B    K
 L        0 10 01100   4C    L
 M        0 10 01101   4D    M
 N        0 10 01110   4E    N
 O        0 10 01111   4F    O
 P        0 10 10000   50    P
 Q        0 10 10001   51    Q
 R        0 10 10010   52    R
 S        0 10 10011   53    S
 T        0 10 10100   54    T
 U        0 10 10101   55    U
 V        0 10 10110   56    V
 W        0 10 10111   57    W
 X        0 10 11000   58    X
 Y        0 10 11001   59    Y
 Z        0 10 11010   5A    Z
 [        0 10 11011   5B    [
 \        0 10 11100   5C    \  '\\'
 ]        0 10 11101   5D    ]
 ^        0 10 11110   5E    ^
 _        0 10 11111   5F    _
            
          0 11 00000   60    `
          0 11 00001   61    a
          0 11 00010   62    b
          0 11 00011   63    c
          0 11 00100   64    d
          0 11 00101   65    e
          0 11 00110   66    f
          0 11 00111   67    g
          0 11 01000   68    h
          0 11 01001   69    i
          0 11 01010   6A    j
          0 11 01011   6B    k
          0 11 01100   6C    l
          0 11 01101   6D    m
          0 11 01110   6E    n
          0 11 01111   6F    o
          0 11 10000   70    p
          0 11 10001   71    q
          0 11 10010   72    r
          0 11 10011   73    s
          0 11 10100   74    t
          0 11 10101   75    u
          0 11 10110   76    v
          0 11 10111   77    w
          0 11 11000   78    x
          0 11 11001   79    y
          0 11 11010   7A    z
          0 11 11011   7B    {
ACK       0 11 11100   7C    |
ALT MODE  0 11 11101   7D    }
          0 11 11110   7E    ~
RUB OUT   0 11 11111   7F    DEL



что интерсно, согласно таблице на стр238 модел 33
разделял все байты на четыре группы на основе 6-7 бита
первая группа где 6-7 = 00
вторая группа где 6-7 = 01
третья группа где 6-7 = 10
четвер группа где 6-7 = 11
поэтму я всю таблицу аскии и разделил на четыре
таких куска

опять же повторюсь что по идее восьмой бит он 
заполнялся на основе "четной парити" тоесть он 
должен быть 1 если число битов в позициях 0-7 нечет
ное и долже быть равен 0 если оно ччетное чтобы
общее число битов было четное. однако на старнице
238 у них все время восьмой бит установен.
что за хуйня.


как видно выше модел 33 понимал не все байты
самый большой блок байт кодов который он не понимал
это 0x60-0x7B (были и другие котоыре он не понимал
но это был самый большой блок в нем в основном 
латинские буквы мелкого размера)
 


правда что странно это что 
вот эти символы которые в аски это просто
печатные символы у него это были управляющие
байт коды


Model33    BIN      Hex   Char                        
─────────────────────────────────────────────────

ACK       0 11 11100   7C    |
ALT MODE  0 11 11101   7D    }




и еще вот эти два символа у него почему то в книжке
обозначены другими глифами незнакомымим
просто я не смог их найти поэтому в левой колонке
нарисовал обычные глифы


Model33    BIN      Hex   Char                        
─────────────────────────────────────────────────

 ^        0 10 11110   5E    ^
 _        0 10 11111   5F    _



возвращаюсь к нашей осовной теме
если все что я описал верно то получается
из управлябщих символов он получается реально
не понимал ASCII 0x08 bacspace  байт.

далее
я так я так и ненашел что происходило при нажатии
на кнопку RUBOUT то ли он на перфоленте в новой
позиции печатал 7F и плюс передавал ее по сети
то ли он в указанной позиции
которую можно было руками там подкрутить он печатал
7F и не передавал ее по сети.

теперь если мы предположим что у нас с нашей стороны
лиукс терминал. и мы связались с удаленным телеприн
тером model 33 тоесть у нас за нашим tty драйвером
сидит на баш а сидит прога которая кидает байты
которые в нее прилетают через канал связи на удаленный
телеприентер модел 33 тоесть у нас как бы связь
нашего терминала с удаленным телепринтом.

то в этом плане конечно имеет смысл с нашей стороны
посылать туда байт код 7F но только в том случае
если вся эта шарманка с 7F работает вот как.
вот я нажал на телпринте кнопку. он байт в перфо
принтер записал. потом я жму RUBOUT и он этот же
байт (а не следующий) преехерачивает в 7F тогда
это экивалентно тому что последний символ был "удален"
но правда вопрос а что если я еще раз нажму на RUBOUT?
это опять же имеет смысл только если головка на
перфопринтре при этом сместится на преддыущий байт
и в него запишет 7F. но тогда при нажатии кнопки
на телепринтер головка на перфопринтере должна 
перелтеть обратно на пустое место. тоесть

вот так скажем было 

  1A   3A  34 46  
               ^

скобкой поаказано где стоит головка
я жму два раза RUBOUT либо 7F прилетает из сети
два раза тогда

  1A   3A  7F 7F  
           ^
 

далее я жму обычную кнопку и головка должна
вот сюда перелететь 

  1A   3A  7F 7F 1B  
                 ^

умел ли model 33 длеать чтото такое непонятно.


ясно только то что байт код 08 он не понимал.
также при нажатии на RUBOUT на перфопринтре печатался
7F но в какой позиции неясно. и отпарвлялся ли он 
в сеть тоже непонятно.

на класичском принтере при rubout у нас ничего
не происходило. возможно поэтому посылка 7F на 
терминал с дислпеем ничего неделает на терминале.
может поэтму? ибо типа дислпей это прообраз принтера
обычного.

если дисплей это аналог принтера. и мы уже знаем
что при нажатии на RUBOUT (и генерации 7F) у нас
на принтере ничего не происходило. значит и на 
дислпейллейном терминале тоже ничего происходит
недолжно. по идее 7F это байт код который говорит
что надо чтото сделать на перфопринтре. если у
нас терминал без перфопринтера то в итоге этот 7F
по идее в плане дисплея ничего неделает. 
если 7F прилеет на телепритер с перфопринтером
то это указание на то чтобы телепринтер в каокйто
позции перфопринтера напечатал 7F

хотя по мне было бы логично что если на терминал с
дислпеем прилеает 7F то он берет и удаляет последний
символ на экране. это было супер логично.
почему так не просиодит я не понмиаю.

значит чтом не сказал ИИ про это дело. он сказал
что при нажатии на RUBOUT у меня на перфоленте
в текущей позиции заменялся последний байт на 7F
это означает что 100 раз наимать нет смысла. то
есть можно исправит только подений символ. 
при этом в сеть 7F нешлется. 
вот так якобы это работало.

таким образом насколко я понмиаю генерация 7F 
на клаве телепринтера\терминала это всегда 
сигнал для его исполняющей части только о том 
что нужно пойти на перфопринтер и там последний
байт заменить на 7F если перфопринтера на нем
нет то генерировать этот байт нет никкого смысла

получаетя все байты в таблце аскии котоыре генериро
вала клава были предназначены для обычного принтера
чтобы он чтото нарисовал или подвигал кареткой
и только один байт предназнчался для управением
перфоприентера.

итак 7F байт код это сигнал для телепринтера 
о том чтобы он пошел на свой перфопринтер и там
"удалил" последний байт. 

когда мы подкочаеся нашим VT100 терминалом к
линукс боксу то у нас ттай драйвер выопняет роль
удаленного телепринтера. а его буфер по мне
это аналог перфоприентера. когда с терминала на 
ттай дарйвер прилетает 7F то по идее это ему сигнал
что он дллжен на своем перфопринтере помеитьт
последний байт как бракованный. так вот ttydrover
в канон режиме слушается вот эти настройки

intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O

в частности вот эта 
  erase = ^?;

ему говорит отом что если из терминала к нему
влетел байт 7F то он должен пойти в свой буфер
и удалить последний справа там байт!
поэтмоу на мой взгляд tty driver выступает в роли
телепринтера к которому полкючен наш терминал
а его буфер выстаупает в роли перфопринтера с 
перфолентой!  ну а юзер процесс который лежит 
за ттай драйвером выступает в роли следюущего
по счету телепринтера. типа того. 
таким образом получается 7F это сигнал для телеприн
тера или терминала у корторого есть перфопринтер
о том чтобы на нем исправти последний байт на 7F
важно тут еще то что байт 7F означает для телепринте
тера что на осовном принтере оыбчном делать НИЧЕГО
НЕНАДО! это обьясняет то что если я пошлю 7F 
на VT100 вот так

   printf '\x7F' > /dev/tty2

то на экране ничего неизменися. почему? потомучто
дислей это анаолог ОБЫЧНОГО приентера. а 7F
имет влияение на перфопринетре. а у VT100 нет прерфо
приентера или его аналога. и потвторюсь 7F никакого
влияния на обычный приентер\дислей не имеет.
поэтому на экране ничего не просиходит!!

далее  я ракзвыают тонкую вещь без разжовыеия
простых деталей. 
баш у нас работает так что он прекчает ттай
драйвер в некакнический режим и отключает у него
эхо.  это дает то что если с терминала чтото
влеает в ттай дарер то он вответ ничего сам
не шлет. и также он перестает реагировать вот
на эти байты котоыре могут влететь именно со 
сторны теринала

intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>; swtch = <undef>;
start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O

так вот если на терминале я сгенерриую 7F
то баш в ответ шлет на дисей терминаала воттакое

\x08\x1b\x5b\x4b

где 0x08 это ASCII bacskapce что командует 
дислею чтобы он сметсил кусора на -1 позиицю налево
без старния символа. далее идет ESc секвенс

  ESC [  K  

котрая комадует терминалу чтобы он стер все
символы в строке начина с текущей позции до 
самого конца.
если у меня курсор сотоит где в средине строки
и я нажму 7F то баш вот что сделает.
он сделает то же самое

\x08\x1b\x5b\x4b

и потом он еще пошлет все те символы которые стояли
правее символа который я хотел стереть. 
вот таким извраеием баш удаляет 1 символ в средине
строки на экране. странно что на терминале нет
такой ESC секвенс котоаря бы удалаля один символ 
слева. очень странно.

но можно удалить символ на экране и по другому.
замораживаем баш или запускем юзер приложеие
которое ничего неделает с ттай драйвер. 
далее меняем на ттай дарйвер режим на вот такой

  icanon echo -echoctl


при этом у нас втупает вот эта настройка в силу

  erase = ^?

и что происходит? если я шлю с клавы териминаа 7F
то оно влтает в ттай дайвер. у него стоит настройка
эхо. это значит что он должен сам чтото отправить
обатно. далее у него настройка -echoctl
это значит что если влетел управляющий байт (
из дипааона 00-1F, 7F) то он недолжен в ответ
посылать ^N а по идее должен обратно отправить 
оригинальный байт.  но! видимо это еще не конец.
втупает  в силу еше вот эта нстрокка

    erase = ^?

она как я понимаю говит то что воо первых тай
драйвер дожен в своем буфере удалить один символ
самый последний. а второе она говрит то что
он должен ЧТОТО послать на терминал ТАКОЕ чтобы
на термимнле на его диспле удалился символ 
стоящий слева!! и вот что он шлет туда НЕИЗВЕСТНО!
ивестно тоько как это вындяит на дислпее.
если было 
   
   123456789
        ^
и я нажму два раза backspace
то на экране будет вот так

   1234  789
       ^

тоест у нас удалится два символа но строка не 
слохпнетс. тоесть два символа заменятся на пробелы.
ну как я полагаю что оптравляет tty driver он
отправлет 0х08 и 0x20 (SPACE) и опять 0x08 чтобы
вернуться вэту позицию.
но как узнать точно непонятно.

а если я вкючу настройку  echoctl
то он непокажет что он шлет на дислплей в преды
лущем случае!!! он всего навсего покажет то что 
в него влетело в завуалидррваном виде '^?' 
а это я итак знаю! я знаю что в  него влетело 7F


так что воттакой очень хитрый по своему физ
смыслу 0x7F ASCI DEL байт. тоесть по своему
изначланому смыслу он преднанаался для обозначнеия
дейтсвий на перфопринтере. а если у терминала
нет перфопринтера  то тут начинаются всякие 
чудеса как этот терминал проинтепретиурет смысл
этого байт кода. 
тоесть баш при посутлпнии этого байта
обратно шлет вот это

\x08\x1b\x5b\x4b


tty driver это у него какнонн режим и -echoctl 
шлет чтото но что непонятно.
а если у него echoctl то он шлет ^?


у VT100 термианал на месте текущй кнопки BACSCKPACE
компа была кнопка котоаря называлась DELETE и 
при ее нажатии он генерировал 7F 
ровно тоже самое делает текстовый консольный 
терминал линукса. 

но вот в том то и прикол что на текущей клаве 
эта кнопка называется BACKSPACE. хотя еее линукс
эмулятор воспрнимает как DELETE как утого терминала
было и навешивает на нее 7F.

вот вопрос - какой байт код надо сделать чтобы
генеиролвала эта кнопка. 

ну мы что хотим - мы хотим чтобы при нажатии 
на эту кнопку у нас :
  если работает канон режим:
     то чтобы ттай драйвер в своем буфере удалил
     последний символ и на экране нам скоретировал
     картинку - вцелом это раотает если мы установим
     на ттай дравере ключи
       icanon echo -echoctl erase 0x7F

  если у нас неканон нережим:
    обычно в нем рабоатает баш 
    и он отлично понимает то от него в этом
    случае хотят


ну можно преедать чтобы при нажатии на backsapce
у нас с клавы летело 0x08 что на саоммо деле 
неозначает что мы хотим удалть символс слева а 
означает что мы хотим сдвинуть курсор влево ну
в разрезе баш то что у него есть в память буфер
где хрнится наша строка и там есть курсор. 
тоже самое ест у ттай драйвер когда он рабоатет
в канон режиме. вобщем конечно возникает вопрос
вот этот буфер у баща и буфер у ттай дарйвер
это аналог приетера телетайпа с печаттнойкареткой
в такой то позииции или это аналог перфопринтера
с головуой в такой то позиции? - это вопрос. 
в общем по мне название кнопки BACKSPACE некоректное
если мы отталкиываеися от смысла ASCII BACKSPACE

а есть еще кнопка на клаве DEL
она была на клаве VT100 
и ненадо путать кнопку DELETE на vt100
и кнопку DEL это две разные кнпоки.
так вот кнопка DEL она генерировала на терминале
VT100 байт код 

    CSI 3 ~

или 

    ESC [ 3 ~


так что кнопка DEL на VT100 она изначально неимел
нкаикго отншения к гененрации ASCII DEL 7F байт
кода.  это была чисто кнопка котоая геерирвала 
байт код  

   ESC [ 3 ~


насолкьо я понимаю этот севенс если его направти 
в терминал то он ничего само по себе не сделает.
то есть это просто такой секвенс котоый просто 
уникально идентициурет эту кнопку. тоесть приложение
типа баш может поянть что это на клаве нажали 
кнопку DEL и както уже реагиррвать.

