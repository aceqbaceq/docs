| openswitch
| pfsense
| router
| vlan

задача. устанвоим опенсвич. несколько виртуалок qemu и пфсенс.
и будем учиться переносить виланы с одного роутера(пфсенс) на второй роутер.


ставим свич

	# pacman -Sy openvswitch

создаем свич

	# ovs-vsctl add-br openswbr2


считается что обычный линукс свич простой а опенсвич это сложно - полная хуйня.
наоборот. опесвич это полная миоашка

если на обычном свиче только один порт может иметь ИП на в опенсвиче дохрена
портов могут иметь ИП.

свич стартует за счет службы поэтому надо поставить на автозагрузку

 	# systemctl enable --now ovs-vswitchd
 	# systemctl enable --now ovsdb-server


смоирим инфо

# ovs-vsctl  show
    Bridge openswbr2
        Port openswbr2
            Interface openswbr2
                type: internal



у опенсвич есть два типа портов это internal порт и неинетернал порт.
интернал порт означает что это нефизический порт а порт который опенсвич сам создал
он софтовый.

если порт интенал то он так ясно и обозначается


       Port openswbr2
            Interface openswbr2
                type: internal


если порт неинтрнел то тогда это както вот так

        Port vport109
            trunks: [11, 20, 30, 40, 99]
            Interface vport109

если порт неинтрнел то это  значит что это тот порт который уже сусщетсвтует на 
хосте и который мы подключили в свич. при этом этот порт тоже может быть софтовым
но гавное это то что этот порт не был создан силами опенсвич.

зачем нужен интрнел порт. на него можно повестьи ИП адрес. и получается с хоста 
куданибудь пингануть.  этот порт нельзя будет использовать для qemu потому что он не
явялется TUN портов. еще раз - инттенал порт заводится силами опенсвич для того чтобы 
на него навесить ип адрес и с хоста подключться к сети того вилана который навешен 
на этот интернал порт. 

если мы создали порт (интенрнал) либо взяли ужесущсуштвующий порт и втсавли его в опенсвич (далее
просто свич) то этот конфиг схоаранится после перезагрузки.

если это инернал порт то навесить на него ип можно силами 

     # ip -c a a ....

но это не соахранится после перзагщуки.
чтобы это сохранилось можно либо заюзать NetworkManager то он нихера неработает с опенсвич
по крайней мере на манжаро.
поэтому другой путь - сделать это через systemd-networkd.
тоесть сам порт будет создан силами опенсвич при перезагрзуке.
а ип на него навесит  systemd-netowrkd
делается это вот так



		# cat /etc/systemd/network/90-vport100.network 
[Match]
Name=vport100

[Network]
Address=192.168.1.2/29


[Route]
Destination=192.168.1.0/24
Gateway=192.168.1.1


как я уже сказал этот интернал порт негодится чтобы к нему подключить виртуалку.
потому что она не TUN типа. 
для этогонужно создать уже нашими силами TUN порт.
сделать это можно либо чреез NetworkManager
либо через systemd-netowrkd


если через NetworkManager

	# nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname vport109  con-name vport109 autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up vport109

если через systemd-netowrkd

	# cat /etc/systemd/network/90-vport101.netdev 
[NetDev]
Name=vport101
Kind=tap

	# cat /etc/systemd/network/90-vport102.network 
[Match]
Name=vport102

[Network]
DHCP=no

[Link]
Unmanaged=no
RequiredForOnline=yes




япредполчту чреез NM (NetowrkManager)

	# export VVPORT="vvport2"; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT


теперь подключаем этот порт в свич

	# ovs-vsctl add-port openswbr2  $VVPORT

делаем порт тип trunk
и разрешаем тег влан 5
	# ovs-vsctl set port $VVPORT vlan_mode=trunk
	# ovs-vsctl set port $VVPORT trunks=[5]


смотри что получилилось

# ovs-vsctl show

    Bridge openswbr2
        Port vvport2
            trunks: [5]
            Interface vvport2
        Port openswbr2
            Interface openswbr2
                type: internal


посмтрим еще раз с другого угла ифно про прорт vvport2

 #  ovs-vsctl --columns=name,tag,trunks,vlan_mode list port vvport2
name                : vvport2
tag                 : []
trunks              : [5]
vlan_mode           : trunk

это я создал порт для LAN карты для пфсенс.

теперь создадим карту WAN для пфсенс

	#
	export VVPORT="vvportWAN"; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT

	ovs-vsctl add-port openswbr2  $VVPORT
	ovs-vsctl set port $VVPORT vlan_mode=trunk
	ovs-vsctl set port $VVPORT trunks=[99]
	ovs-vsctl --columns=name,tag,trunks,vlan_mode list port $VVPORT

name                : vvportWAN
tag                 : []
trunks              : [99]
vlan_mode           : trunk


если у нас есть виланы то нахер нам два порта две сет карты для пфсенс.
потому что у пфсенс несморя на виланы есть центровая концепция что одна карта
это WAN и на ней он запускает нат и файрволл. а вторая это лан и к ней по другому все
применяеися. поэтому две карты.

смотрим конфиг свича

    Bridge openswbr2
        Port vvport2
            trunks: [5]
            Interface vvport2
        Port vvportWAN
            trunks: [99]
            Interface vvportWAN
        Port openswbr2
            Interface openswbr2
                type: internal


 тоесть унас один инернал порт. для того чтобы с хоста достуаться до веб морды
 пфсенс. и два порта TUN для того чтобы на их базе зпустить ВМ и на ней поствить 
 пфсенс.



 запускаем вм

 qemu-system-x86_64 \
      -name pfsense3 \
      -m 312M \
      -boot d \
      -cdrom dvd.iso \
-device virtio-scsi-pci,id=scsi \
-drive file=hda.img,format=qcow2,if=none,id=drive-virtio0 \
-device scsi-hd,drive=drive-virtio0 \
      -cpu host \
      -enable-kvm \
      -smp 1 \
      -M q35 \
      -device virtio-balloon \
      -device VGA,vgamem_mb=8 \
      -display sdl \
      -netdev tap,id=mynet1,ifname=vvportWAN,script=no,downscript=no \
      -device virtio-net-pci,netdev=mynet1,mac=ba:ec:24:5c:33:01 \
      -netdev tap,id=mynet2,ifname=vvport2,script=no,downscript=no \
      -device virtio-net-pci,netdev=mynet2,mac=ba:ec:24:5c:33:02 \
      -serial /dev/tty ; reset

тут  я вот что подчеркуну. про мак адреса
	mac=ba:ec:24:5c:33:01
	mac=ba:ec:24:5c:33:02

это те мак адреса котоыре будет видеть софт внутри вм. тоесть кему софт 
создает эмулирует сетевые карты которые он покзыает софту внутри вм. 
под такими маками. тоесть такие маки мы увидим внури ос внутри вм.
однако этим сет карты сещувтуют только внутри памяти qemu.
по факту те сет карты к которым релаьно процесс кему подключен снаружи они 
будут иметь совершенно другие маки. тоесть на хосте мы посмтрим на сет карты
vvportWAN и vvport2 на хосте будут иметь другие маки. 
так что это надо понимать.
тоесть искать на хосте маки 
	mac=ba:ec:24:5c:33:01
	mac=ba:ec:24:5c:33:02
бесполезно
нахосте надо искать порты vvportWAN и vvport2 и смотреть какие маки они имеют.

	 $ ip -c l sh dev vvportWAN
197: vvportWAN: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel master ovs-system state DOWN mode DEFAULT group default qlen 1000
    link/ether 82:50:41:ae:da:dd brd ff:ff:ff:ff:ff:ff
 
	$ ip -c l sh dev vvport2
196: vvport2: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc fq_codel master ovs-system state DOWN mode DEFAULT group default qlen 1000
    link/ether 36:b8:d7:ed:c6:7e brd ff:ff:ff:ff:ff:ff

тоесть мы видим маки
	82:50:41:ae:da:dd
	36:b8:d7:ed:c6:7e

возникает вопрос так какие маки будет иметь л2 фрейм от вируиалки кему?
пакеты летящие из вм будут иметь маки проысанные при старте qemu.
а вот эти маки
	82:50:41:ae:da:dd
	36:b8:d7:ed:c6:7e
будут упакетов только если мы нашим этим TUN портам с хоста назначим ип адреса.
вот так вот хитро!


теперь  устанвлиываем пфсенс
я поставил так что: 
на лан порту я навесил vlan5 (192.168.2.1/29)
на ван порту я навесил vlan99 и пока парится не стал.
наша задача достуаться до веб морды





смотрим на свич
    Bridge openswbr2
        Port vvport2
            trunks: [5]
            Interface vvport2
        Port vvportWAN
            trunks: [99]
            Interface vvportWAN
        Port openswbr2
            Interface openswbr2
                type: internal


у него уже есть интернал порт.
навесим на него ип средватми systmd-netorkd
чтобы с него можно было ходит на веб морду пфсенс



 # cat /etc/systemd/network/90-openswbr2.network 
[Match]
Name=openswbr2

[Network]
Address=192.168.2.2/29


[Route]
Destination=192.168.2.0/24
Gateway=192.168.2.1



	# systemctl restart systemd-netowrkd


 # ip -c a s dev openswbr2  | grep "inet "
    inet 192.168.2.2/29 brd 192.168.2.7 scope global openswbr2


еще раз смотрим на интенал порт
        Port openswbr2
            Interface openswbr2
                type: internal


его надо сделать акцесным и навесить 5 vlan

	# ovs-vsctl set port openswbr2 vlan_mode=access
	# ovs-vsctl set port openswbr2 tag=[5]


 # ovs-vsctl --columns=name,tag,trunks,vlan_mode list port openswbr2
name                : openswbr2
tag                 : 5
trunks              : []
vlan_mode           : access


 # ping 192.168.2.1 -c2
PING 192.168.2.1 (192.168.2.1) 56(84) bytes of data.
64 bytes from 192.168.2.1: icmp_seq=1 ttl=64 time=1.07 ms
64 bytes from 192.168.2.1: icmp_seq=2 ttl=64 time=0.462 ms

все связь с хоста до веб морды пфсенс есть




теперь небольшая разьяснаял про ип сети с маской 29

  0    0   0   0    0   000
 128  64  32   16   8   (1-6)

192.168.2.0+(1-6) =  192.168.2.(1-6)		
192.168.2.8+(1-6) =  192.168.2.(9-14)		
192.168.2.16+(1-6)=  192.168.2.(17-22)		
192.168.2.24+(1-6)=  192.168.2.(25-30)		
192.168.2.32+(1-6)=  192.168.2.(33-38)		
192.168.2.40+(1-6)=  192.168.2.(41-46)		





далее схема такая на пфсенс у нас на LAN карте будут виланы

VLAN5   net 192.168.2.0/29   ip 192.168.2.(1-6)  (веб морда)
VLAN10  net 192.168.2.8/29   ip 192.168.2.(9-14)
VLAN20  net 192.168.2.16/29  ip 192.168.2.(17-22)
VLAN30  net 192.168.2.24/29  ip 192.168.2.(25-30)


при создании вланов в пфсенс в Interfaces-Assignemtns-VLANS нужно внимательно 
смотерть какой родительский порт выбирется. а то можно легко выбрать WAN порт. 
из за этого потом хер поменяешь налету. и нужно будет перегружать виртуалку!

на пфсенс для каждого влан порта я задал ип

VLAN5   ip 192.168.2.1/29 (web морда)
VLAN10  ip 192.168.2.9/29
VLAN20  ip 192.168.2.17/29
VLAN30  ip 192.168.2.25/29


таким образом с хоста с порта openswbr2 192.168.2.2/29 я имею 
связь с веб мордой через 192.168.2.1/29 на пфсенс


теперь  я создам три вирулктаки на дебиане 

	hostVLAN10 
		IP 192.168.2.10/29 VLAN10 

	hostVLAN20 
		IP 192.168.2.18/29 VLAN20 

	hostVLAN30
		IP 192.168.2.26/29 VLAN30 


виланы я обепечу чеерез опенсвич . порты vvport3 vvport4 vvport5 будут акцесные

	
	export VVPORT=vvport3; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT

	ovs-vsctl add-port openswbr2  $VVPORT
	ovs-vsctl set port $VVPORT vlan_mode=access
	ovs-vsctl set port $VVPORT tag=[10]
	ovs-vsctl --columns=name,tag,trunks,vlan_mode list port $VVPORT


	export VVPORT=vvport4; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT

	ovs-vsctl add-port openswbr2  $VVPORT
	ovs-vsctl set port $VVPORT vlan_mode=access
	ovs-vsctl set port $VVPORT tag=[20]
	ovs-vsctl --columns=name,tag,trunks,vlan_mode list port $VVPORT



	export VVPORT=vvport5; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT

	ovs-vsctl add-port openswbr2  $VVPORT
	ovs-vsctl set port $VVPORT vlan_mode=access
	ovs-vsctl set port $VVPORT tag=[30]
	ovs-vsctl --columns=name,tag,trunks,vlan_mode list port $VVPORT

в итоге поулчаетм такие порты на свиче

 #      ovs-vsctl --columns=name,tag,trunks,vlan_mode list port vvport3
name                : vvport3
tag                 : 10
trunks              : []
vlan_mode           : access
 #      ovs-vsctl --columns=name,tag,trunks,vlan_mode list port vvport4
name                : vvport4
tag                 : 20
trunks              : []
vlan_mode           : access
 #      ovs-vsctl --columns=name,tag,trunks,vlan_mode list port vvport5
name                : vvport5
tag                 : 30
trunks              : []
vlan_mode           : access
 # 



 запускам три вруатлки вот такие

 qemu-system-x86_64 -name host2A \
                   -m 266M -boot d \
                   -drive file=hda.img,media=disk,if=virtio,format=qcow2,file.locking=on \
                   -cpu host -enable-kvm -smp 1 -M q35 \
                   -device virtio-balloon -device VGA,vgamem_mb=8 -display none \
                   -netdev tap,id=mynet1,ifname=vvport3,script=no,downscript=no \
                   -device virtio-net-pci,netdev=mynet1,mac=ba:ec:24:5c:33:03 \
                   -serial /dev/tty ; reset


qemu-system-x86_64 -name host2B \
                   -m 266M -boot d \
                   -drive file=hda.img,media=disk,if=virtio,format=qcow2,file.locking=on \
                   -cpu host -enable-kvm -smp 1 -M q35 \
                   -device virtio-balloon -device VGA,vgamem_mb=8 -display none \
                   -netdev tap,id=mynet1,ifname=vvport4,script=no,downscript=no \
                   -device virtio-net-pci,netdev=mynet1,mac=ba:ec:24:5c:33:04 \
                   -serial /dev/tty ; reset



qemu-system-x86_64 -name host2C \
                   -m 266M -boot d \
                   -drive file=hda.img,media=disk,if=virtio,format=qcow2,file.locking=on \
                   -cpu host -enable-kvm -smp 1 -M q35 \
                   -device virtio-balloon -device VGA,vgamem_mb=8 -display none \
                   -netdev tap,id=mynet1,ifname=vvport5,script=no,downscript=no \
                   -device virtio-net-pci,netdev=mynet1,mac=ba:ec:24:5c:33:05 \
                   -serial /dev/tty ; reset


в итоге мы получаем три виртуалки (так как на свиче порты акцесные то на виртлукалах
ненужно вырезать субинтерфейсы с виланами)

host2A
VLAN10  access

auto enp0s
iface enp0s3 inet static
    address 192.168.2.10/29
    gateway 192.168.2.9



host2B
VLAN20  access



auto enp0s3
iface enp0s3 inet static
    address 192.168.2.18/29
    gateway 192.168.2.17




host2C
VLAN30  access

auto enp0s3
iface enp0s3 inet static
    address 192.168.2.26/29
    gateway 192.168.2.25


момент истины с хоста пытасю пинговать host2C


$ ping 192.168.1.26 -c2
PING 192.168.1.26 (192.168.1.26) 56(84) bytes of data.
64 bytes from 192.168.1.26: icmp_seq=1 ttl=63 time=3.05 ms

SUCCESS


тоесть с хоста  с порта openswbr2 который 192.168.2.2\29 и котоый на опенсвич ацесный
для VLAN5 сигнал летит на vvport2 опенвича где 5 вилан это транковый.
и потом на пфсенс это все руотится и плюется на VLAN30 который тарнковый который
опять же уходит на физ порт vvport2 на опенсвиче и далее через свич он летит
на порт vvport5 который ацесный и несет вилан 30  и потом внутрь вм!воткак

собиарем теперь второй роутер  routerB и на нем создаем VLAN11

192.168.2.32+(1-6)=  192.168.2.(33-38)		VLAN11

данный вилан  я натяну между роутерB и пфсенс как канал связи.

и на роутерB я создам VLAN40 и создам +1ВМ hostD в этом вилане.

VLAN40
192.168.2.40+(1-6)=  192.168.2.(41-46)		VLAN40

сам роутер получит ip 192.168.2.41
а виртуалка получит 192.168.2.42

и тогда будет схема связи между хостом и hostD будет такая


хост            пфсенс                    routerB                hostD
  (vlan5) ----- (vlan5)
                (vlan10) 
  				(vlan11) --------------  (vlan11)
  				(vlan20)                 (vlan40)  -----------  (vlan40)
  				(vlan30)                  


переброс между вилаинами идет на счет роутига конечно


	export VVPORT=vvport6; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT

	ovs-vsctl add-port openswbr2  $VVPORT
	ovs-vsctl set port $VVPORT vlan_mode=access
	ovs-vsctl set port $VVPORT tag=[10]
	ovs-vsctl --columns=name,tag,trunks,vlan_mode list port $VVPORT



создаем routerB
для него порт.
и три вилана
VLAN99  172.16.11.2/29   (под WAN)
VLAN40 
VLAN11


	export VVPORT=vvport7; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT

	ovs-vsctl add-port openswbr2  $VVPORT
	ovs-vsctl set port $VVPORT vlan_mode=trunk
	ovs-vsctl set port $VVPORT trunks=[11,40,99]
	ovs-vsctl --columns=name,tag,trunks,vlan_mode list port $VVPORT


создаем ВМ для routerB на базе этого порта


qemu-system-x86_64 -name routerB \
                   -m 266M -boot d \
                   -drive file=hda.img,media=disk,if=virtio,format=qcow2,file.locking=on \
                   -cpu host -enable-kvm -smp 1 -M q35 \
                   -device virtio-balloon -device VGA,vgamem_mb=8 -display none \
                   -netdev tap,id=mynet1,ifname=vvport7,script=no,downscript=no \
                   -device virtio-net-pci,netdev=mynet1,mac=ba:ec:24:5c:33:07 \
                   -serial /dev/tty ; reset



итак на этом хосте



auto enp0s3.99
iface enp0s3.99 inet static
    address 172.16.11.2/29
    vlan_raw_device enp0s3
    gateway 172.16.11.1



auto enp0s3.11
iface enp0s3.11 inet static
    network 192.168.2.32
    address 192.168.2.34/29
    vlan_raw_device enp0s3
    #VLAN5
    up ip route add 192.168.2.0/29  via 192.168.2.33 
    down ip route del 192.168.2.0/29  via 192.168.2.33
    #VLAN10
    up ip route add 192.168.2.8/29  via 192.168.2.33  
    down ip route del 192.168.2.8/29  via 192.168.2.33 
    #VLAN20
    up ip route add 192.168.2.16/29 via 192.168.2.33  
    down ip route del 192.168.2.16/29 via 192.168.2.33
    #VLAN30
    up ip route add 192.168.2.24/29 via 192.168.2.33 
    down ip route del 192.168.2.24/29 via 192.168.2.33  




auto enp0s3.40
iface enp0s3.40 inet static
    network 192.168.2.40
    address 192.168.2.41/29
    vlan_raw_device enp0s3




и на пфсенс нужно пробросить маршрут в сеть на  VLAN40 и гейтвей 192.168.2.34
через который можно вэту сеть попасть



вот схема виланов и хостов


VLAN5	  net 192.168.2.0/29 		pfsense 192.168.2.1 		хост    192.168.2.2
VLAN10 	  net 192.168.2.8/29 		pfsense 192.168.2.9 		hostA   192.168.2.10
VLAN20    net 192.168.2.16/29 		pfsense 192.168.2.16 		hostB   192.168.2.17
VLAN30    net 192.168.2.24/29 		pfsense 192.168.2.25 		hostC   192.168.2.26 
VLAN11    net 192.168.2.32/29  		pfsense 192.168.2.33 		routeB  192.168.2.34
VLAN40    net 192.168.2.40/29 		routeB  192.168.2.41 	 	hostD 	192.168.2.42



а вот еще раз картину вспоминаем


хост            пфсенс                    routerB                hostD
  (vlan5) ----- (vlan5)
                (vlan10) 
  				(vlan11) --------------  (vlan11)
  				(vlan20)                 (vlan40)  -----------  (vlan40)
  				(vlan30)                  


делаю трейсроут
# traceroute -I -d -n 192.168.2.2
traceroute to 192.168.2.2 (192.168.2.2), 30 hops max, 60 byte packets
 1  192.168.2.41  0.758 ms  0.702 ms  0.690 ms    (роутерB)
 2  192.168.2.33  2.494 ms  2.487 ms  2.453 ms    (pfsense)
 3  192.168.2.2  3.562 ms  3.554 ms  3.547 ms     (хост компа)


и вот видно что на пути пакет проходит три хопа



а теперь выцарпаем VLAN30 и перенесем его на роутер2
для этого:
  1)на опенсвиче:
    удаляем 30 вилан на порту пфсенс
    приавляем 30 вилан на порту routerB
  2) на пфсенс удаляем интерфейс с вилан30
  прибалвяем маршурут на сеть вилана30 через роутерБ
  3) на роутереБ:
      заводим субинтфрейс виалан30 + ИП
      убираем мршррут на сеть вилана30 через гейтвей


поехали
1)
порт пфсенс
 #      ovs-vsctl --columns=name,tag,trunks,vlan_mode list port vvport2
name                : vvport2
tag                 : []
trunks              : [5, 10, 11, 20, 30]
vlan_mode           : trunk
 # 
 #      ovs-vsctl set port vvport2 trunks=[5,11,10,20]
 # 

 #      ovs-vsctl --columns=name,tag,trunks,vlan_mode list port vvport7
name                : vvport7
tag                 : []
trunks              : [11, 40, 99]
vlan_mode           : trunk


#      ovs-vsctl set port vvport7 trunks=[11,30,40,99]
# 
#      ovs-vsctl --columns=name,tag,trunks,vlan_mode list port vvport7
name                : vvport7
tag                 : []
trunks              : [11, 30, 40, 99]
vlan_mode           : trunk
# 

2)
маршурут в сеть 192.168.2.24/29

в итоге я все сдеал.
захожу на hostC и пингую хост ноутбука

# traceroute -I -d -n  192.168.2.2
traceroute to 192.168.2.2 (192.168.2.2), 30 hops max, 60 byte packets
 1  192.168.2.25  0.493 ms  0.450 ms  0.442 ms   (routerB  vlan30)
 2  192.168.2.33  1.346 ms  1.342 ms  1.338 ms   (pfsense  vlan11)
 3  192.168.2.2  1.987 ms  1.983 ms  1.980 ms    (хост vlan5)

тоесть путь пакета через роутеры
 hostC --->routerB ---> pfsense ---> host


тоесть все сработало


тока оказалос что дебиан12 на routerB и его ifup сетевой мееджер почемуто 
не смог успешно заососавть из конфига вот этот кусок про новый вилан30



auto enp0s3.30
iface enp0s3.30 inet static
    network 192.168.2.24
    address 192.168.2.25/29
    vlan_raw_device enp0s3


тоесть перезагрузка сететвго менедежера нихера ничего не давала.
пришлось перезарузить routerB



начинаю заниматься WAN портом пфсенс.  он имеет 99 влан
ему даю ип 4.4.4.2\30
а смотреть он будет на дебиан gw1 который будет иметь 4.4.4.1\30

создаю порт для вм gw1
	export VVPORT=vvport8; nmcli connection add   type tun  mode tap owner 1000 group 1000  ifname $VVPORT  con-name $VVPORT autoconnect yes save yes ipv4.method disabled ipv6.method disabled; nmcli conn up $VVPORT

	ovs-vsctl add-port openswbr2  $VVPORT
	ovs-vsctl set port $VVPORT vlan_mode=access
	ovs-vsctl set port $VVPORT tag=[99]
	ovs-vsctl --columns=name,tag,trunks,vlan_mode list port $VVPORT



вобщем у меня 
    пфсенс 
      WAN порт (влан 99) имеет 4.4.4.2/24

    и он уходит на 
    вм gw1 
       enp0s3 4.4.4.1\24


картинка
      pfsense 4.4.4.2 ------------ 4.4.4.1  gw1



теперь я хочу с gw1 пинговать 4.4.4.3 и чтобы это проходило внутрь  на 192.168.2.10
который лежит на VLAN5 и который подключен к этому пфсенс.
первое что надо сделать  это пойти в VirtualIP и там создать ип 4.4.4.3 тип ProxyARP
это дает то что когда gw1 будет посылать в сеть ARP запрос мол какой комп имеет ип 4.4.4.3
то мой пфсенс хотя неимеет этот ип но ответи обратно с арп ответом. теперь gw1 знает 
dest mac для  ип 4.4.4.3 и пакеты чисто физически начнут прилетать на WAN порт пфсенса.
теперь нужно пойти в "NAT 1:1" и там прописать 

   			External subnet IP   - Address -  4.4.4.3
   			Internal IP          - Address -  192.168.2.10


это даст вот что.  

   в пфсенс влетает пакет вида             NAT его преобразует в 
    dst IP  4.4.4.3 							dst IP  192.168.2.10
    src IP  4.4.4.1  							src IP  4.4.4.1 


дальше он попдает в таблицу маршрутизации и плывет до коенчного хоста hostA
на него он прилетает в точности в этом же виде

   dst IP  192.168.2.10
   src IP  4.4.4.1 


тоесть при проходе NAT во внутрь PFSENSE у нас только заменяется DST IP.
когда пакет летит обратно 

   SRC IP 192.168.2.10    DST IP 4.4.4.1

и проходит NAT пфсенс то у него АВТОМАТОМ меняется SRCIP на 4.4.4.3 
тоесть на интрнет хост пакет прилетает в виде

   SRC IP 4.4.4.3    DST IP 4.4.4.1

тоесть нам на пфсен дополтнтельно SNAT настрвить ненужно.
а на интрнет хосте логика такая. он пинговал 4.4.4.3 и он с "него" пакет и получил.


и конечно чтобы это все сработало надо еще на Rules разершить ICMP на WAN порту для 4.4.4.3
и на VLAN5 порту проход для src 4.4.4.3 и dst 192.168.2.10


тоесть мы при NAT 1:1 имеем банальный DNAT. когда пакет летит вовнутрь у него 
dst ip меняется на 192.168.2.10
а когда он обратно летит наружу у него для src ip автмоатом происодит обратное 
преоборваазование
(!!)ЕЩЕ РАЗ ВАЖНЫЕ МОМЕНТЫ- NAT 1:1 дает такой плюс что нам ненужно доплолнительно настраивать SNAT
он будет автоматом. ИТАКЖЕ если мы работаем с WAN IP которого нет на нашем WAN 
порту то нужно создать Virtual IP (тип ProxyARP).



все хорошо при условии что 192.168.2.10  имеет наш пфсенс в качетве гейтвея.
но все уже плохо если локальная машина на которую идет проброс лежит за вторым роутером 
за routerB , напрмиер машина из VLAN40 192.168.2.42


                gw1             INternet
          VLAN99 |                |
                 |     VLAN11     |     VLAN40
              pfsense -------- routerB -------- hostD
 


например я создаю на пфсенс Virtual IP (тип ProxyARP) 4.4.4.4
и я делаю NAT(1:1)   4.4.4.4 ---> 192.168.2.42


значит я с gw1 пинугую 4.4.4.4 тоесть летит пакет
    SRC IP 4.4.4.1      DST IP 4.4.4.4   
он влетает в pfsene и пребразуется в   
   SRC IP 4.4.4.1      DST IP 192.168.2.42

согалнсо записи в тадице марщрутизации

Destination        Gateway            Flags     Netif Expire
192.168.2.40/29    192.168.2.34       UGS       vtnet1.11


он влетает в routerB (потому что 192.168.2.34 это роутерB)
из него он летит на hostD все отлично.
проблема начинается когда ответный пакет летит обратно.
он влатет в ротуерB и имеет вот такйо вид
   SRC IP 192.168.2.42      DST IP 4.4.4.1

а у роутераB у него есть еще один порт который ведет в интенрнет 
и имеет деволтовый маршрут 

   default via 6.6.6.1 dev WAN

который на картнке я нарисовал как стрелка ведушая вверх в интрренет
и наш пакет улетает в интернет а не обратно в pfsense!  поэтому чтобы обратный пакет
заствить влететь в пфсенс  я на routerB добавляю маршрут

		ip -c r add 4.4.4.1/32 via 192.168.2.33 dev enp0s3.11  

тогда обратый пакет влетает в пфсенс. далее с ним происодит обратный нат преобразование.
из такого
   SRC IP 192.168.2.42      DST IP 4.4.4.1
он превращается в такой
   SRC IP 4.4.4.4      DST IP 4.4.4.1
и успешно влетает в наш gw1

и тут мы видим проблему. так как в этом маршруте на роутереБ

		ip -c r add 4.4.4.1/32 via 192.168.2.33 dev enp0s3.11  

адрес 4.4.4.1 это адрес произвольнгого клиента из интернета.
(!!) ИЗ ЧЕГО Я ДЕЛАЮ ТАКОЙ СУММАРНЫЙ ВЫВОД -что если мы пеереносим VLAN с пфсенс
на роутерБ и если в этом влан если локальная машина для которой на пфсенс настроен dnat\NAT1:1
то вместе с пеереносом влана и его стат маршрутов также сразу нужно на роутерБ переносить
этот самый dnat\NAt1:1

НО! далее я вот что придумал.
мы берем нашу таблицу маршрутизации и делаем так что 
деолфтовый маршрут default route у нас идет через vlan11
все проблема с обарным ходом пакетов решена!
если на роутутер есть другие виланы которым нужно ходт в интернет 
то наши виланы можно засунуть в VRF (см. systemd-networkd-VRF.txt)
но пока забудем про это.
вот у нас есть


# cat interfaces

source /etc/network/interfaces.d/*

# The loopback network interface
auto lo
iface lo inet loopback


auto enp0s3.99
iface enp0s3.99 inet static
    address 4.4.4.10/24
    vlan_raw_device enp0s3



auto enp0s3.11
iface enp0s3.11 inet static
    network 192.168.2.32
    address 192.168.2.34/29
    gateway 192.168.2.33 metric 10
    vlan_raw_device enp0s3
    #VLAN5
    up ip route add 192.168.2.0/29  via 192.168.2.33 
    down ip route del 192.168.2.0/29  via 192.168.2.33
    #VLAN10
    up ip route add 192.168.2.8/29  via 192.168.2.33  
    down ip route del 192.168.2.8/29  via 192.168.2.33 
    #VLAN20
    up ip route add 192.168.2.16/29 via 192.168.2.33  
    down ip route del 192.168.2.16/29 via 192.168.2.33
    #VLAN30
    #up ip route add 192.168.2.24/29 via 192.168.2.33 
    #down ip route del 192.168.2.24/29 via 192.168.2.33  



auto enp0s3.30
iface enp0s3.30 inet static
    network 192.168.2.24
    address 192.168.2.25/29
    vlan_raw_device enp0s3




auto enp0s3.40
iface enp0s3.40 inet static
    network 192.168.2.40
    address 192.168.2.41/29
    vlan_raw_device enp0s3



вот наща таблица роутов

default via 192.168.2.33 dev enp0s3.11 metric 10 onlink 
4.4.4.0/24 dev enp0s3.99 proto kernel scope link src 4.4.4.10 
192.168.2.0/29 via 192.168.2.33 dev enp0s3.11 
192.168.2.8/29 via 192.168.2.33 dev enp0s3.11 
192.168.2.16/29 via 192.168.2.33 dev enp0s3.11 
192.168.2.24/29 dev enp0s3.30 proto kernel scope link src 192.168.2.25 
192.168.2.32/29 dev enp0s3.11 proto kernel scope link src 192.168.2.34 
192.168.2.40/29 dev enp0s3.40 proto kernel scope link src 192.168.2.41 


тоесть девотоый рут тдет чреез VLAN11

тоесть в плане роутинга у нас со связью все окей.
теперь представим что мы взяли и WAN IP с пфсенс перенесли на руотерБ.
который скажем предназанчен для VLAN40
как нам теперь сделать чтобы для него дефолт гейтвей поменялся
и шел через WAN нашего сервера а для других сетей все осталось по прежнму?
ответ POLICYROUTING. он дает то что при определнии маршурута будет проверться не
только dest ip но и src ip
добавляем вот сюда сторку

# cat /etc/iproute2/rt_tables
200	vlan40  <====!!!!!!=========
255	local
254	main
253	default
0	unspec


далее создаем правила

	ip route add 192.168.2.40/29 dev enp0s3.40 src 192.168.2.41 table vlan40
	ip route add default via 4.4.4.1 dev enp0s3.99 table vlan40

сюда ксати нужно добавить и все локльные маршруты  в остальные виланы
те которые лежат  в основй таблцие маршрутиациии

смотрим на эту таблицу

	# ip -c r sh table vlan40
default via 4.4.4.1 dev enp0s3.99 
192.168.2.40/29 dev enp0s3.40 scope link src 192.168.2.41 


теперь добавляем правило кода в эту таблицу лазить

	ip rule add from 192.168.2.40/29 table vlan40 pref 1001


# ip rule
0:	from all lookup local
1001:	from 192.168.2.40/29 lookup vlan40  <=== наша кастоаная таблица
32766:	from all lookup main     <==== деолфтовая
32767:	from all lookup default


еще вот эти правла добавляет в iptables
-A PREROUTING -d 4.4.4.10/32 -j DNAT --to-destination 192.168.2.42
-A POSTROUTING -s 192.168.2.40/29 -j SNAT --to-source 4.4.4.10

все! у нас работает!
если я снаружи стучу на WAN 4.4.4.10 то идет DNAT на 192.168.2.42
и обрвтный пакет опрееляет маршурут на базе таблицы маршрзуатиацщии "VLAN40"


	# ip -c r sh table vlan40
default via 4.4.4.1 dev enp0s3.99 
192.168.2.40/29 dev enp0s3.40 scope link src 192.168.2.41 


и улетает он не в девфолт гейтвей талблиыцы main который ведет в VLAn11
а в WAN порт!

