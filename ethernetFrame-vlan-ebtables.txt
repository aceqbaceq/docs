| ebtables
| vlan


я открыл просто шок вещь.

возьмем эзернет фрейм. какой у него формат.

                                                                       
                                                                                                               
| Destination MAC (6 байт) | Source MAC (6 байт) | EtherType (2 байта) |               PAYLOAD             | FCS (4 байта) |
|--------------------------|---------------------|---------------------|-----------------------------------|---------------|
| 00:11:22:33:44:55        | 66:77:88:99:AA:BB   | 0x0800              | IPv4 пакет                        | CRC           |


что важно в этом формате. 
важно то что есть поле EtherType
в чем же его прикол
это поле представляет собой интерес для свичей,
роутеров и ядер ОС.
в чем же прикол.
в этом поле указыается какой протокол имеет пакет
который вложен в поле payload. например если у нас
в payload одержится пакет формата ipv4 то 
etherType=0800
ну и какой толк 
на практике от этого поля? а дело вот в чем.
если этот фрейм влетает в роутер или линукс
то им это поле дает то что они исходя из этого 
поля СРАЗУ знаю какой пакет находится в пейлоад поле.
ведь если этого поля нет то роутеру или ядру ОС
нужно было бы ПЕРЕБИРАТЬ все протоколы пытаясь 
опрееделить какой протокол заключен в пакете  который
сохранен в поле payload.
тоесть от этого поля есть огромный практический
смысл  - роутерам и ядру ос  ненужно гадать . 
они сразу знают и это круто.

так. а есть ли смысл от этого поля для свича? ведь
ему похеру на то что лежит в пейлоад. он ведь
работает на основе src_mac и dst_mc 
оказвается тоже есть. смысл наступает если у нас 
фрейм приналежит к тегированному вилан трафику.
если у нас фрейм принадлежит к тегированнму вилан 
трафику то поле EtherType=8100 
и в этом случае свич ищет поле "802.1Q header" 
которое есть таком фрейме и которое содержит 
номер вилана. таким образом  если EtherType=8100 то
это поле используется и свичем!

далее следующий прикол. ну хорошо положим 
EtherType=8100  тогда как же в этом случае
роутеры и ядра ос опрееделяют  протокол пакета
который лежит в payload? ОКАЗЫВАЕТСЯ что в этом
случае в payload лежит еще один эзернет фрейм!
точно такой же фрейм только нетегиованный!
поэтому когда роутер или ос получают тегированный
фрейм то они лезут в пейлоад , и там они ожидают
найти хрень которая по формату является нетегированным
эзернет фреймом! и там ос ищет поле EtherType 
и в нем находят тот пртокол который вложен в 
полей payload уже этого фрейма!

вот картинка

|           тегированный фрейм                |
|  |ET=8100|    |      payload1           |   |

смотрим внутрь paylaod1


|      payload1           |
|  нетегированый фрейм    |
|ET=8100| |payload2    |  |


и вот внутри payload2 у нас уже лежит IPv4 пакет!
охренеть!


еще раз  у нас внутри тегированного фрейма
в поле пейлоад хранится всегда еще один эзернет
фрейм только нетегированный

тут вытекает момент. вот влетел тегиварный фрейм
в свич. а у него часть портов АКЦЕСС то есть он 
он дожлен из них высирать нетегровный трафик. 
тода что делает свич. он просто напросто вытаскивает
из пейлоад этотнетегированный фрейм и сует его
в сеть через АКЦЕСС порт. охренеть

далее мелочевка - где моно всегда найти 
чему равен номер в поле EtherType для проткола
ipv4 или vlan

$ cat /etc/ethertypes | grep -E "IPv4|802" 
IPv4	0800    # Internet IP (IPv4)
802_1Q	8100    # 802.1Q Virtual LAN tagged frame
 

тепрь кога это все стало понятно 
перейдем к ebtables
эта штука тоже работает с полем EtherType
вот посмотрим на два правила


-A PREROUTING  -p IPv4   --ip-proto icmp --log-level notice --log-prefix "[nat PRE icmp]" -j CONTINUE

-A PREROUTING  -p 802_1Q --vlan-id 2     --log-level notice --log-prefix "[nat PRE vlan2] " -j CONTINUE


вот этот ключ -p  он как раз  указвыает какой 
протокол указан в поле EtherType
тоесть если 
  
  -p IPv4  

то это мы отлавиваем фреймы с EtherType=0800
а если  я указвыаю

-p 802_1Q

то я оталвабваю фреймы с EtherType=8100

полуается первое правило отлвивает обычные фреймы
в пейлоад которых сидит ipv4 пакет

а второе правило отлвилвает тегированый вилан 
трафик внутри которых нахоится обычный нетегированный
эзернет фрейм с хрен знает каким пейлоадом внутри.


зная все это можно тепер понять что если я 
укажу правило


-A PREROUTING  -p IPv4   --ip-proto icmp --log-level notice --log-prefix "[nat PRE icmp]" -j CONTINUE


то я смогу поймать только те пинги которые обернуты
нетегированным эзернет фреймом. если пинги обернуты
тегировнным эзернет фреймом то это праивило нихрнена
ничего не покажет! мы не отловим такие пинги

а чтобы отловить такие пинги нужно юзать 
вот такое правило

-A PREROUTING  -p 802_1Q --vlan-id 2     --log-level notice --log-prefix "[nat PRE vlan2] " -j CONTINUE

правда оно будет лоавить нетлоько icmp трафик 
а вообще любой l3 трафик обернутый в тегированный
эзернет трафик.


с поомощью ИИ можно помтреть какую серию правил 
можно написать чтобы отловить именно icmp внутри
тегиорванного трафика

но это еще не конец этого пиздеца.


рассмотрим сквозной трафик который течет внутри
свича тоесть трафик влетает водин свич порт
и дожен выдететь через другой свич порт.
так вот вот какие шаги пройдет фрейм


 PREROUTING - ROUTING  -  FORWARD - POSTROUTING
 HOOK         DECISION    HOOK      HOOK



 и вот тут очерная хитрость. положим у нас в 
 свич влетел тегированный фрейм. значит 
 в prrouting hook он будет тегировнный по прежнему.
 далее идет шаг routing decision
 и тут может выясниться что этот фрейм нужно 
 выплюнуть из порта который явялется ACCESS
 это значит что нужно превратить тегировный трафик
 в нетегиованнный! пуст так и есть тогда свич преоб
 разует фрейм в нетегированный и сует в следующий
 шаг в FORWARD HOOK фрейм уже в нетегированном виде!

вот  у меня такой случай и случился.
и я словил вот такой прикол. у меня в преротутинг
хуке сидело правило

-A PREROUTING  -p IPv4   --ip-proto icmp --log-level notice --log-prefix "[nat PRE icmp]" -j CONTINUE

и в форвард хуке у меня сидело правило

-A FORWARD -p IPv4 --ip-proto icmp --log-level notice --log-prefix "[filter FORWARD]" -j CONTINUE

и у меня в свич влетал тегирваный трафик 
а вылетал он в нетегированный порт. 
и я в читая логи никак не мог понять почему
первое правило нихера ничего не показыает
а второе показывает!

а разгазка именно в этом. оба правила ловят только
нетегированный трафик. поэтому первое правило
нихера не показыает.
вылет трафика идет в нетегировный порт поэтому 
на стадии routing decision тегировнный фрейм 
превращается в нетегиорвный и поэтмоу второе 
правилло уже  ловит трафик!

ОХРЕНЕТЬ!!!!


в вот кстаи как выглдят правила в nft

ether type ip xt match "ip" xt target "log" counter packets 2 bytes 168

ether type 8021q xt match "vlan" xt target "log" counter packets 272 bytes 17074


первое правило ловит фрейм у которого ethertype=ipv4

а второе правило ловит фрейм у которого ethertype=802.1q

