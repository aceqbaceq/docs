gitlab

----
установка

для его установки надо плюс минус 5 ядер цпу E5 2680-v4
и памяти 6-7 GB иначе постоянно будет крутить файл подкачки

если делать памяти меньше то там начинаются дикие операции чтения записи
и процесс установки и без того супер долгий становится просто бесконечным

гитлаб ставится очень долго. минут 15-20 наверно.


черновой ансибл плейбук по его установке - gitlab-ansible-playbook.txt (смотри
в ансибл проектах)

когда он очень очень очень долго прекрутит и установится
то проверить статус что все установилось вот так можно

$ sudo -i gitlab-ctl status

vagrant@ubuntu-xenial:~$ sudo -i gitlab-ctl status
run: alertmanager: (pid 17248) 45s; run: log: (pid 16659) 196s
run: gitaly: (pid 17140) 48s; run: log: (pid 16106) 357s
run: gitlab-exporter: (pid 17132) 49s; run: log: (pid 16598) 212s
run: gitlab-workhorse: (pid 17098) 50s; run: log: (pid 16498) 231s
run: grafana: (pid 17267) 44s; run: log: (pid 17000) 93s
run: logrotate: (pid 16021) 370s; run: log: (pid 16033) 367s
run: nginx: (pid 16528) 227s; run: log: (pid 16539) 226s
run: node-exporter: (pid 17115) 49s; run: log: (pid 16573) 220s
run: postgres-exporter: (pid 17259) 44s; run: log: (pid 16686) 189s
run: postgresql: (pid 16231) 347s; run: log: (pid 16245) 344s
run: prometheus: (pid 17153) 48s; run: log: (pid 16639) 202s
run: puma: (pid 16438) 245s; run: log: (pid 16448) 242s
run: redis: (pid 16051) 364s; run: log: (pid 16062) 361s
run: redis-exporter: (pid 17134) 48s; run: log: (pid 16621) 206s
run: sidekiq: (pid 16455) 239s; run: log: (pid 16465) 238s
vagrant@ubuntu-xenial:~$ sudo -i netstat -tnlp

как видно должно работать если все в порядке куча куча куча компонентов.
если их меньше значит чтото незавелось.

после установки вэб морда будет доступна через 

	http://127.0.0.1:80
	

дефолтовый юзер : admin@example.com
а пароль вэб морда прредложит установить с самого начала

----



----

/etc/gitlab/gitlab.rb 

это походу главный конфигурацияонный файл у гитлаба

--

так случилось что я сразу забыл юзера и пароль 
от вэб морды


чтобы сбросить пароль от вэб морды 
надо зайти на линукс на котором крутится гитлаб 
далее повысить права до root и запустить rails console

# gitlab-rails console -e production

далее как сбросить пароль написано здесь - https://docs.gitlab.com/12.10/ee/security/reset_root_password.html

но рецепт оттуда нихуя неработает. потому что его недостаточно.
а работает вот какой рецепт в итоге

> user = User.where(id: 1).first
> user.password = 'secret_pass'
> user.password_confirmation = 'secret_pass'

(а вот та команда которой нехватало)
> user.skip_reconfirmation!

> user.save!

все, можно заходить в вэб морду под root и новым паролем


----
проекты в гитлабе имеют три степени видимости

в общем случае видимость по русски означает лишь права на чтение 
файлов проекта. но никак не права на запись.


public: виден всем , юзеры без акаунта на сервере тоже видят проект

internal: виден всем кто имеет акаунт на сервере.

private: чтобы получить доступ к проекту надо чтобы тебя включили в группу проекта

проект в гитлабе это по сути +1 новый гит репозиторий.

----

как добавить ssh ключ для юзера который щас вошел в морду гитлаб:

попали на главную страницу гитлаба - вверху справа тыкаем на  наш аватар - preferences -
потом слева в меню в форме вертикального списка ищем SSH keys - мы попали куда надо


в итоге система работы с гитом у гитлаба выглядит так : мы к проекту добавляем в группу
юзера а у юзера в его профиле прописаны ssh ключи. так что через ssh ключ (вместо пароля) 
юзер аутентифиуироется когда стучится через гит клиент на гит сервер ,
и стучится юзер в конретный гит репозиторий ( ака гитлаб проект) и гитлаб сервер
смотрит этому юзеру можно читатьь\писать в этот гит репозиторий\проект
----

почему то в книжке по гитлабу написано что для одного акаунта можно
юзать только один ssh ключ. хотя не пойму в чем проблема юзать сто ssh ключей.
и вэб морда позволяет добавить милион ssh ключей к акаунту

----

git add .

говорит о том что мы делаем staging. тоест мы сообщаем что мы хотим засунуть 
в следущий комить такие то файлы

-----

типа как зафигачить удаленный репозиторий
и чтоб было по минимуму мудоты с пушами


$ git init
$ git clone git@gitlab.example.com:vasya/project-01.git

по дефолту гит коммитит в origin тока надо его поднастроить


$ git remote add origin git@gitlab.example.com:vasya/project-01.git

$ git add .
$ git commit -m "first commit"
$ git push -u origin master

далее можно уже будет коммитить просто через 

$ git push

проверить всю эту шарманку ( то что с удаленными реопзиториями бранчами
мудрота проведена успешно) можно через

$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master

$ git remote
origin


origin это чтото вроде алиаса для удаленного чегото там

посмотреть более подробную инфу по origin можно через


$ git remote show origin
* remote origin
  Fetch URL: git@gitlab.example.com:vasya/project-01.git
  Push  URL: git@gitlab.example.com:vasya/project-01.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)


таким образом мы убеждаеся что origin =  git@gitlab.example.com:vasya/project-01.git
тоесть все подучилось
-------


как я понимаю расшифровку это команды

$ git push –u origin master

запушить коммит в удаленный репозиторий origin в ветку master на нем

-------

создать ветку

$ git branch first-branch

-----

перейти в ветку и проверить что мы на ней сидим

$ git checkout first-branch

$ git branch
* first-branch
  master

-----
 
 $ git push -u origin first-branch
 
 пушим в удаленный репозиторий алиас которого origin 
 в его ветку first-branch
 
------
 
для того чтобы замержить ветку first-branch в ветку master нужно для начала
перейти в ветку master

$ git checkout master

теперь мерджим

$ git merge first-branch --no-ff 

--no-ff  = опция дает то что при мердже будет создан в мастере новый коммит.
а если неукзать этот ключ то гит как то там будет по другому выкрчиваться.
а мы неузнаем на каком коммите былы соединены две ветки

мердлж двух веток это как перекресток двух дорог
----

удалить на удаленном репозитрии ветку first-branch

$ git push -u origin --delete first-branch

замечу что эта ветка в локальном репозитории ОСТАНЕТСЯ

чтобы удалить ветку в локальном репозитории нужно:

$ git branch -d first-branch


------

тут полезно взять паузу и прочитать что такое merge
и что такое rebase (как они работают ) тут - http://aceqbaceq.blogspot.com/2017/10/git-z0.html

------

полезная команда как посмотреть лог коммитов 
в граф виде

$ git log --oneline --graph

*   1f7bd7a Merge branch 'first-branch'
|\
| * 8f26349 change to new branch
|/
* ee49e65 added file.txt
* ec3d739 first commit
* 1e7db1a Initial commit

------

хотелось поговорить про мерджи.

что такое коммит в гите. это набор файлов на какотой конкретный момент 
времени. их бэкап еще можно сказать. также говорят снэпшот. но мне 
этот термин ненавится потому что снэпшот делается на уровне блоков на блочном
устройстве типа диске. а гит работает (на нижнем уровне) не сблоками 
на диске а с файлами. поэтому коммит это бэкап файлов на какуюто дату.

мы меняем файлы потом делаем их бэкап. коммиты это  бэкапы. цепочка , множество
бэкапов.

множество коммитов образует бранч, ветку. 

изобразим бранч как это принято

A0 -> A1 -> A2

пусть каждый коммит состоит в том что мы создаем одноименный текстовый файл.
тоесть коммит A0  состоял в том что мы создали файл A0.txt и забэкапили (закоммитили)
такое состояние файловой системы.

коммит A1 сосоял в том что мы имели состояние файловой системы A0 ( наличие A0.txt )
и создали на этой фс файл A1.txt и закоммитили (забэкапили ) это состояние 
файлов. 

коммит A2 состоял в том что мы имели нашу фс и добавили к ней файл A2.txt

итак состоние файловой системы на уровне каждого коммита


A0 ( A0.txt )
A1 ( A0.txt + A1.txt )
A2 ( A0.txt + A1.txt +A2.txt )

зачем расписан этот пример.

каждый коммит это итеративный процесс. мы имеем некоторое состояние файлов на фс.
мы незнаем в общем случае необязаны знать детали состояния этих фалов. 
просто у нас есть некое текущее состоняие файлов на фс. это нам дано.
и мы на этой фс делаем некоторое изменнеие. если состояние фс до изменнеия
нам известно плохо и слабо. то вот наше текущее изменение в чем оно состоит
мы знаем отлично. например коммит A2. мы взяли фс (хер пойми из чего состоящую)
и добавили к ней файл A2.txt , еще раз что там и как на фс творится из чего 
она состоит мы в общем случае плохо знаем. зато мы когда делаем коммит
твердо знаем то изменнеие которрое мы делаем. мы в описании коммита напишем
именно само изменение типа " добавлен файл A2.txt ". это все ведется к тому 
что если мы имеем некоторый коммит например A2  
и хотим иметь полное представление что делалось на фс на всем протяжении 
от ее начала то нам описания самого коммита A2 дает лишь последнюю ступень последний 
шаг. а чтобы понять полную историю картину изменений на фс надо 
брать описание самого первого коммита A0 и потом идти по всей цепочке коммитов
до нашего A2 собирание описание что делалось , только тогда мы поймем 
из чего состоит наша текущая фс во всех деталях.

с одной стороны состояние файлов фактическое на момент коммита A2 представляет 
собой полную эволюцию от A0 до A2. но при этом описание коммита A2 содержит 
в себе только последний шаг этой эволюции. поэтому описани коммита A2 нам недает 
полную картину состояния файлов на фс а дает только последний шаг.
тоесть фактическое состояние фс несоотсветвует описанию в любом коммите кроме
самого первого.

в этом жопа.

нам чтобы понимать что из себя файлы на фс представляют на момент конкретного коммита
нужно знать всю цепочку коммитов в бранче от текущего до самого первого (отматывая назад)
сам коммит на уровне файлов ествеенно содержит актуальное состояние 
файлов на дату комммита отражая всю эволюцию от первого коммита до текущего
но описание коммита несодержит полную эволюцию а только последний шаг.

таким образом с точки зрения независимости одного коммита от другого  - они 
полностью автономы и независимы с точки зрения фактического набора файлов (бэкапа).
каждый коммит это полный независимый бэкап . все отлично. 
а вот описания представления полного о том что за изменнеия были внесены
в файлы этого коммита. мы назнаем. коммит об этом информации ненесет. 
в нем только есть информация о последнем изменений относительно предыдущего коммита.

в этом жопа коммита. поэтому в этом плане текущий коммит неразрывно связан 
со всеми  предыдущими коммитами, другим словами коммит неразрывано связан с бранчем.
коммит неотрывен от бранча. 

еще раз. на уровне самих файлов - коммит полностью автономен. как пирожное 
которое готово. но рецепта приготовления этого пирожного в коммите нет. для 
этого нужно иметь всю ветку. все другие коммиты до нашего коммита. тогда мы 
будем иметь нетолько готовое пирожное но и его точный рецепт.

 
 


при это существенно что надо понимать это то что 

коммит A0 содержит в себе фиичи A0
A1 содержмит в себе фичи A0+A1
A2 содержит в себе фичи A0+A1+A2

 

 
