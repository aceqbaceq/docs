gitlab

----
установка

для его установки надо плюс минус 5 ядер цпу E5 2680-v4
и памяти 6-7 GB иначе постоянно будет крутить файл подкачки

если делать памяти меньше то там начинаются дикие операции чтения записи
и процесс установки и без того супер долгий становится просто бесконечным

гитлаб ставится очень долго. минут 15-20 наверно.


черновой ансибл плейбук по его установке - gitlab-ansible-playbook.txt (смотри
в ансибл проектах)

когда он очень очень очень долго прекрутит и установится
то проверить статус что все установилось вот так можно

$ sudo -i gitlab-ctl status

vagrant@ubuntu-xenial:~$ sudo -i gitlab-ctl status
run: alertmanager: (pid 17248) 45s; run: log: (pid 16659) 196s
run: gitaly: (pid 17140) 48s; run: log: (pid 16106) 357s
run: gitlab-exporter: (pid 17132) 49s; run: log: (pid 16598) 212s
run: gitlab-workhorse: (pid 17098) 50s; run: log: (pid 16498) 231s
run: grafana: (pid 17267) 44s; run: log: (pid 17000) 93s
run: logrotate: (pid 16021) 370s; run: log: (pid 16033) 367s
run: nginx: (pid 16528) 227s; run: log: (pid 16539) 226s
run: node-exporter: (pid 17115) 49s; run: log: (pid 16573) 220s
run: postgres-exporter: (pid 17259) 44s; run: log: (pid 16686) 189s
run: postgresql: (pid 16231) 347s; run: log: (pid 16245) 344s
run: prometheus: (pid 17153) 48s; run: log: (pid 16639) 202s
run: puma: (pid 16438) 245s; run: log: (pid 16448) 242s
run: redis: (pid 16051) 364s; run: log: (pid 16062) 361s
run: redis-exporter: (pid 17134) 48s; run: log: (pid 16621) 206s
run: sidekiq: (pid 16455) 239s; run: log: (pid 16465) 238s
vagrant@ubuntu-xenial:~$ sudo -i netstat -tnlp

как видно должно работать если все в порядке куча куча куча компонентов.
если их меньше значит чтото незавелось.

после установки вэб морда будет доступна через 

	http://127.0.0.1:80
	

дефолтовый юзер : admin@example.com
а пароль вэб морда прредложит установить с самого начала

----



----

/etc/gitlab/gitlab.rb 

это походу главный конфигурацияонный файл у гитлаба

--

так случилось что я сразу забыл юзера и пароль 
от вэб морды


чтобы сбросить пароль от вэб морды 
надо зайти на линукс на котором крутится гитлаб 
далее повысить права до root и запустить rails console

# gitlab-rails console -e production

далее как сбросить пароль написано здесь - https://docs.gitlab.com/12.10/ee/security/reset_root_password.html

но рецепт оттуда нихуя неработает. потому что его недостаточно.
а работает вот какой рецепт в итоге

> user = User.where(id: 1).first
> user.password = 'secret_pass'
> user.password_confirmation = 'secret_pass'

(а вот та команда которой нехватало)
> user.skip_reconfirmation!

> user.save!

все, можно заходить в вэб морду под root и новым паролем


----
проекты в гитлабе имеют три степени видимости

в общем случае видимость по русски означает лишь права на чтение 
файлов проекта. но никак не права на запись.


public: виден всем , юзеры без акаунта на сервере тоже видят проект

internal: виден всем кто имеет акаунт на сервере.

private: чтобы получить доступ к проекту надо чтобы тебя включили в группу проекта

проект в гитлабе это по сути +1 новый гит репозиторий.

----

как добавить ssh ключ для юзера который щас вошел в морду гитлаб:

попали на главную страницу гитлаба - вверху справа тыкаем на  наш аватар - preferences -
потом слева в меню в форме вертикального списка ищем SSH keys - мы попали куда надо


в итоге система работы с гитом у гитлаба выглядит так : мы к проекту добавляем в группу
юзера а у юзера в его профиле прописаны ssh ключи. так что через ssh ключ (вместо пароля) 
юзер аутентифиуироется когда стучится через гит клиент на гит сервер ,
и стучится юзер в конретный гит репозиторий ( ака гитлаб проект) и гитлаб сервер
смотрит этому юзеру можно читатьь\писать в этот гит репозиторий\проект
----

почему то в книжке по гитлабу написано что для одного акаунта можно
юзать только один ssh ключ. хотя не пойму в чем проблема юзать сто ssh ключей.
и вэб морда позволяет добавить милион ssh ключей к акаунту

----

git add .

говорит о том что мы делаем staging. тоест мы сообщаем что мы хотим засунуть 
в следущий комить такие то файлы

-----

типа как зафигачить удаленный репозиторий
и чтоб было по минимуму мудоты с пушами


$ git init
$ git clone git@gitlab.example.com:vasya/project-01.git

по дефолту гит коммитит в origin тока надо его поднастроить


$ git remote add origin git@gitlab.example.com:vasya/project-01.git

$ git add .
$ git commit -m "first commit"
$ git push -u origin master

далее можно уже будет коммитить просто через 

$ git push

проверить всю эту шарманку ( то что с удаленными реопзиториями бранчами
мудрота проведена успешно) можно через

$ git branch -a
* master
  remotes/origin/HEAD -> origin/master
  remotes/origin/master

$ git remote
origin


origin это чтото вроде алиаса для удаленного чегото там

посмотреть более подробную инфу по origin можно через


$ git remote show origin
* remote origin
  Fetch URL: git@gitlab.example.com:vasya/project-01.git
  Push  URL: git@gitlab.example.com:vasya/project-01.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)


таким образом мы убеждаеся что origin =  git@gitlab.example.com:vasya/project-01.git
тоесть все подучилось
-------


как я понимаю расшифровку это команды

$ git push –u origin master

запушить коммит в удаленный репозиторий origin в ветку master на нем

-------

создать ветку

$ git branch first-branch

-----

перейти в ветку и проверить что мы на ней сидим

$ git checkout first-branch

$ git branch
* first-branch
  master

-----
 
 $ git push -u origin first-branch
 
 пушим в удаленный репозиторий алиас которого origin 
 в его ветку first-branch
 
------
 
для того чтобы замержить ветку first-branch в ветку master нужно для начала
перейти в ветку master

$ git checkout master

теперь мерджим

$ git merge first-branch --no-ff 

--no-ff  = опция дает то что при мердже будет создан в мастере новый коммит.
а если неукзать этот ключ то гит как то там будет по другому выкрчиваться.
а мы неузнаем на каком коммите былы соединены две ветки

мердлж двух веток это как перекресток двух дорог
----

удалить на удаленном репозитрии ветку first-branch

$ git push -u origin --delete first-branch

замечу что эта ветка в локальном репозитории ОСТАНЕТСЯ

чтобы удалить ветку в локальном репозитории нужно:

$ git branch -d first-branch


------

тут полезно взять паузу и прочитать что такое merge
и что такое rebase (как они работают ) тут - http://aceqbaceq.blogspot.com/2017/10/git-z0.html

------

полезная команда как посмотреть лог коммитов 
в граф виде

$ git log --oneline --graph

*   1f7bd7a Merge branch 'first-branch'
|\
| * 8f26349 change to new branch
|/
* ee49e65 added file.txt
* ec3d739 first commit
* 1e7db1a Initial commit

------

хотелось поговорить про мерджи.

что такое коммит в гите. это набор файлов на какотой конкретный момент 
времени. их бэкап еще можно сказать. также говорят снэпшот. но мне 
этот термин ненавится потому что снэпшот делается на уровне блоков на блочном
устройстве типа диске. а гит работает (на нижнем уровне) не сблоками 
на диске а с файлами. поэтому коммит это бэкап файлов на какуюто дату.

мы меняем файлы потом делаем их бэкап. коммиты это  бэкапы. цепочка , множество
бэкапов.

множество коммитов образует бранч, ветку. 

изобразим бранч как это принято

A0 -> A1 -> A2

пусть каждый коммит состоит в том что мы создаем одноименный текстовый файл.
тоесть коммит A0  состоял в том что мы создали файл A0.txt и забэкапили (закоммитили)
такое состояние файловой системы.

коммит A1 сосоял в том что мы имели состояние файловой системы A0 ( наличие A0.txt )
и создали на этой фс файл A1.txt и закоммитили (забэкапили ) это состояние 
файлов. 

коммит A2 состоял в том что мы имели нашу фс и добавили к ней файл A2.txt

итак состоние файловой системы на уровне каждого коммита


A0 ( A0.txt )
A1 ( A0.txt + A1.txt )
A2 ( A0.txt + A1.txt +A2.txt )

зачем расписан этот пример.

каждый коммит это итеративный процесс. мы имеем некоторое состояние файлов на фс.
мы незнаем в общем случае необязаны знать детали состояния этих фалов. 
просто у нас есть некое текущее состоняие файлов на фс. это нам дано.
и мы на этой фс делаем некоторое изменнеие. если состояние фс до изменнеия
нам известно плохо и слабо. то вот наше текущее изменение в чем оно состоит
мы знаем отлично. например коммит A2. мы взяли фс (хер пойми из чего состоящую)
и добавили к ней файл A2.txt , еще раз что там и как на фс творится из чего 
она состоит мы в общем случае плохо знаем. зато мы когда делаем коммит
твердо знаем то изменнеие которрое мы делаем. мы в описании коммита напишем
именно само изменение типа " добавлен файл A2.txt ". это все ведется к тому 
что если мы имеем некоторый коммит например A2  
и хотим иметь полное представление что делалось на фс на всем протяжении 
от ее начала то нам описания самого коммита A2 дает лишь последнюю ступень последний 
шаг. а чтобы понять полную историю картину изменений на фс надо 
брать описание самого первого коммита A0 и потом идти по всей цепочке коммитов
до нашего A2 собирание описание что делалось , только тогда мы поймем 
из чего состоит наша текущая фс во всех деталях.

с одной стороны состояние файлов фактическое на момент коммита A2 представляет 
собой полную эволюцию от A0 до A2. но при этом описание коммита A2 содержит 
в себе только последний шаг этой эволюции. поэтому описани коммита A2 нам недает 
полную картину состояния файлов на фс а дает только последний шаг.
тоесть фактическое состояние фс несоотсветвует описанию в любом коммите кроме
самого первого.

в этом жопа.

нам чтобы понимать что из себя файлы на фс представляют на момент конкретного коммита
нужно знать всю цепочку коммитов в бранче от текущего до самого первого (отматывая назад)
сам коммит на уровне файлов ествеенно содержит актуальное состояние 
файлов на дату комммита отражая всю эволюцию от первого коммита до текущего
но описание коммита несодержит полную эволюцию а только последний шаг.

таким образом с точки зрения независимости одного коммита от другого  - они 
полностью автономы и независимы с точки зрения фактического набора файлов (бэкапа).
каждый коммит это полный независимый бэкап . все отлично. 
а вот описания представления полного о том что за изменнеия были внесены
в файлы этого коммита. мы назнаем. коммит об этом информации ненесет. 
в нем только есть информация о последнем изменений относительно предыдущего коммита.

в этом жопа коммита. поэтому в этом плане текущий коммит неразрывно связан 
со всеми  предыдущими коммитами, другим словами коммит неразрывано связан с бранчем.
коммит неотрывен от бранча. 

еще раз. на уровне самих файлов - коммит полностью автономен. как пирожное 
которое готово. но рецепта приготовления этого пирожного в коммите нет. для 
этого нужно иметь всю ветку. все другие коммиты до нашего коммита. тогда мы 
будем иметь нетолько готовое пирожное но и его точный рецепт.

 
вернемся к нашему бранчу

A0 -> A1 -> A2


описание каждого коммита

A0 - небыли ниодного файла, создали A0.txt
A1 - натой фс что была создали дополнительно A1.txt
A2 - натой фс что была создали дополнительно A2.txt

фактическое состояние фс на момент каждого коммита

A0 ( A0.txt )
A1 ( A0.txt + A1.txt )
A2 ( A0.txt + A1.txt +A2.txt )

коммит описывает что было ногов сделано относиельно предыдущего состояния.
а какой полный набор всех изменений (фич) чтобы это узнать нужно 
знать нетолко текущий коммит а всю истоию цепочки комитов в бранче.

получается на момент комита A2 из описания мы знаем что мы создали A2.txt 
а все что остальное там под капотом фс нам неизвестно.

мы идем к предыдушему комиту A1. 
мы знаем что мы только что создали A2.txt ,
описание комита A1 нам дает то что был создан A1.txt а что остального
под капотом фс мы назнаем.
таким образом мы уже значем что
	был создан A2.txt
	до этого был создан A1.txt
	а остальное что там в фс мы незнаем.
	
идем в еще предыдущий комит A0 и узаем что он первый и в нем был создан A0.txt
таким образом на момент комита A2 мы знаем что история фс под капотом такова:
	создан A0.txt, затем создан A1.txt, затем создан A2.txt

если это рассматривать как фичи в программе которую мы пишем то 
на момент комита A2 наша программа имеет фичи
	A0
	A1
	A2


таким образом когда мы смотри на бранч из комитов A0 -> A1 -> A2
и мы обращаем свой взор на конктеный комит то мы должны понимать что
с точки зрения набора файлов на фс каждый комит он полный автономный 
бэкап набора файлов на тот момент бери да пользуйся (компилируй в программу итд).
тоесть в этом плане каждый комит полностью автономен и независит 
от других комитов как готовое пирожное - просто бери и ешь - оно готово.
но с точки зрения что там под капотом в содержимом файлов тут комит неавтономен
он неотделим от бранча , он неотделим от всей цепочки других комитов.
рецепт начинки пирожного хранится не комите а эта информация (рецепт начинки) 
размазан по всем комитам. это внатуре как взяли рецепт разрезали на 100 частей
и в каждый комит положили только часть рецепта. поэтому рецепт нехранится
в отдельном комите. нет. он спрятан во всех комитах по кусочку. 
если хотим знать ркцепт начинки в конкрнетном комите надо выцарпывать этот рецепт 
из всего множества комитов в бранче.


вот такая мудота

таким образом если мы имеем бранч

A0 -> A1 -> A2 -> A3

и мы берем комит A2 то мы теперь знаем что его рецепт , набор фич 
на момент комита A2 это A0+A1+A2

а теперь переходим к мерджам.


у нас например есть две ветки


A0 -> A1 -> A2
	  \
	   B0
	   

B0 это коммит но в новую ветку. ( для простоты примера будем считать что 
коммит B0 руками делает вот что он создает файл B0.txt )

B0 в себе содержит фичи = A0+A1+B0
A2 в себе содержит фичи = A0+A1+A2

далее мы делаем два комита A3 и B1 и  нас бранчи уже выглядят вот так


A0 -> A1 -> A2 -> A3
	  \
	   B0->B1
	   
а дальше мы хотим сделать мердж который даст такую картину


A0 -> A1 -> A2 -> A3 -M4 
	  \              /
	   B0->B1-->-----


M4 это коммит. он является резултатом мерджа ветки B в ветку A после
коммита A3

а теперь самое интересное что такое мердж одной ветки в другую.
мердж это коммит, который представляет собой сумму последнего комита в одной
ветке и последнего комита в другой ветке.
в нашем случае 

M4=A3+B1

поскольку A3=A0+A1+A2+A3 и B1=B0+B1 то подставляем получаем
M4 = (A0+A1+A2+A3)+(B0+B1)

при этом конечно важно какую ветку в какуб мы мерджим. содержимое 
коммита будет совершенно разное.

если бы мы мерджили ветку A в ветку B 
то коммит бы выглядл с точки зрения фич совсем по другому

M4'=(B0+B1)+(A0+A1+A2+A3)

поскольку каждый комит это конкртеные изменения с содержимым файлов 
а точнее последовательность то в общем случае порядок последователности
имеет значение и может привоадить к разным резудльтатам в зависимости
от порядка членов в последователности  , поэтому я и гооврю что M4 
в общем случае неравен M4'. хотя в частных случаях они могут и давать
на уровне фс одинаковый файловый набор.

важное следствие такого коммита как мердж это то что 
нам понимать какой набор фич присутсвует на фс на момент мерджа 
становится еще труднее потому что нам нужно теперть просматривать историю 
всех комитов нетолько в одной ветке но и тащить историю комитов 
в другой ветке.

также хочу отметить что при мердже похеру B1 был сделан раньше по времени относительно
комита A2 или нет. (это для примера). временной параметр относительности 
когда были сделаны комиты одной ветки относииелно другой  никак невлияет
на резульатт мерджа.

расмотрим пример для еще лучшего понимания мерджа
имеем три ветки

A: A0 -> A1 -> A2 -> M1A ->    A3
          \         /           \       
B:         B0 ->   B1 -> B2 -B3 -M1B 
                                   \
C: C0 ----------------------------- M1C


нас интересует какой набор фич в комите M1C
сразу приведу конечный ответ
M1C = C0 + (B0+B1+B2+B3) + (A0+A1+A2) + (B0+B1) +A3

а теперь разберем

мердж  по определению это комит который сумма последних комитов двух веток.
при этом порядок важен.

M1C=C0+M1B

M1B=B3+A3 = B3 +A3 = B0+B1+B2+B3 +A3


A3 = M1A+A3
M1A=A2+B1 = A0+A1+A2 + (B0+B1)

подставляем все это наверх

A3= A0+A1+A2 + (B0+B1) +A3
M1B = (B0+B1+B2+B3) + (A0+A1+A2) + (B0+B1) +A3

M1C = C0 + (B0+B1+B2+B3) + (A0+A1+A2) + (B0+B1) +A3


таким образом видна одна очень важна штука - когда у нас несколько веток
и мы между ними делаем мерджи то очень быстро 
становится очень трудно понять какой же рецепт содержит тот или иной коммит.

поэтому двигаясь дальше периодически нужно мерджи заменять ребейзами.
это дает то что у нас деревоо комитов так хитро меняется что нам легко
становится понимать какой рецепт содержит комит.
а теперь подробнее:


	


 

 
