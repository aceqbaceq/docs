| README

в этом файле будет вся полезная информация по поводу что в этой папке находится







| файлы и папки


r_sr_za_*min.bash   - это основно цимес этой папки.
Это скрипт(ы) которые считывают R(t) в течение 1\5\30\90 минут. потом на основе
этого они высчитывают средний R на этом промежутке. также они высчитывают la*min и ema*min
скрипт учитвает настройки локале LC_NUMERIC и если нужно коректирует данные при подаче в принфт потому что если это не учитывать то при подаче в принфт дробных чисел с неправильным разделителем
дробной части он пошлет нахер (см "|locale "). также два варианта расчета числа процессов R+D
один через ps а второй через /proc/stat

ema1min это сколько воды в баке прям шас.
la1min это скольво вытечет воды из бака за слудующие 5 секунд (в течение следущих 5 секунд)
тоесть ema1min показывает склько у нас воды в баке ЩАС а la1min показывает 
насколлько уменьшится обьем воды который ЩАС через 5секунд.
в целом мат модель процесса такая. у нас ЩАС в баке есть воды ema1min
проходит 5сек и у нас из бака вытекает воды la1min тоесть в баке становится воды
	(ema1min - la1min)
и после этого в тот момент (now+5s) мы мгновенно доливает в бак воды r(now+5s)
и в баке становится уровень воды ema1min(now+5s)

показываю на примере (цифры условные)
t=now     ema1min(now)=10  сколько воды щас в баке
          la1min(now)=2    скоько воды вытечет из баща за следущие 5с
t=now+5s  уровень воды в бакет стал  ( ema1min(now) - la1min(now) ) =10-2=8
          r(now+5s) =3  мы мгновенно доливаем в бак эту воду
          у нас новый уровень воды стал 8+r(now+5s) = 8+3=11
          значит новый текущий уровень воды в баке ema1min(now+5s)=11
          новый la1min(now+5s)=2.3 это сколько воды вытечет от текущего ema1min(now+5s)
          через 5с
вот такая мат модель. вот что на практике значат цифры
		ema1min(t0)
		r(t0)
		la1min(t0)


остальные файлы в остальном вспомогательные или шлак







| про ошибку 	line 94: printf: 98,3580: invalid number


если при запуске баш программ

r_sr_za_1min.bash
r_sr_za_5min.bash
r_sr_za_30min.bash
r_sr_za_90min.bash

на экране вылезает ошибка 

	./r_sr_za_5min.bash: line 94: printf: 98,3580: invalid number


то это потому что эти баш скрипты при запуске имеют такую настройку локали а конкретно ее куска
под названием 
		LC_NUMERIC
в котором указано что разделителем в дробных числа является точка!
а в скрипте дробны числа  обоазначаются через запятую а printf
он работает используя настройки локали которые ему передаются и он 
если видит что числа дробные должны согласно тому что 
прописано в LC_NUMERIC разделсять чреез точку в программе ему подсовывают 
числа с запятой то принтф посылает нахер!!

хотя я вскрипте это дело анализирую и если что налету меняю.
поэтому уже этой ошибки недолжно вылезать

как узнать текущие настройки про это дело . в целом я это поробно
описываю в "| locale"  но здесь тоже кратно напишу

текущие настройки смотрим в терминале
	$ locale LC_NUMERIC -k | grep decimal_point
	decimal_point="."

какой выход? надо посмотреть все локали которые установлены на компе
	$ locale -a
C
C.utf8
POSIX
de_DE.utf8
en_GB
en_GB.iso88591
en_US.utf8
es_AR
es_AR.iso88591
ru_RU.utf8

потому нужно псмотреть насторйки каждой локали и найти такую в котрой
указано что разеделлителем дроных чисел является запятая
например проверим к с этим делом у локали ru_RU.utf8

	$ LC_NUMERIC=ru_RU.utf8 locale LC_NUMERIC -k | grep decimal_point
    decimal_point=","

у нее запятая то что нужно значит запукать скрипт нужно воттак 

		$ LC_NUMERIC=ru_RU.utf8 ./r_sr_za_1min.bash
или вот так без разница
	    $ env LC_NUMERIC=ru_RU.utf8 ./r_sr_za_1min.bash

и все ошибка исчезнет!
в первом случае мы меняем локаль срествами самого баша
а во втором случае мы меяем локаль средствами внешнего бинарника /usr/bin/env








| более подробно про мат модель

во первых какая мат модель. берется ema функция. у нее вот такая мат модел - у нас есть бочка с дыркой снизу и сверху.
мы в бочку воду постоянно доливаем разными порциями и из бочки вода выливатся точже разными порциями. 
параметры бочки : 
о том насклоьо бочка дырявая заадается через коэфициенты  в мат функции. мы рассматриваем мат функцию ema1min
она описывает бочку дырявую в таком  количестве что если мы прекраащаем доливать в нее воду то в ней увроень воды 
упадет за 1мин в e~2.7 раз. вот такую бочку и таукю мат функцию это описывающую мы рассматриваем. 

процесс дискретный. данные снимаются каждые 5секунд и выглядит это так. на данный момент у нас в бочке есть 
уровень воды равный ema1min (еще раз подчеркну что 1min\5min\15min в названии функции ema отражает степень дырявости 
бочки. тоесть в супердырявой бочке ema1min уровен воды падает в 2.7 раза за 1 минуту если мы пркрктили доливаь в нее
воду а самая недырявая бочка это ema15min у нее вода падает в 2.7 раза за 15 минут. но в этой порге мы конкретно
работаем  с бочкой ema1min). так вот проецсс физический происходит вот так - вот у нас есть момент времени now.
и  у нас в бочке уровень воды равен ema1min , исходя из нее мы расчитываем значение la1min
это предсказание насколько уменьшится обьем воды в бочке ema1min через 5сек.
проходит 5с. вода вытекает и уменьшаетс в бочке на велчиину la1min
далее мы мгнвоенно в тот же момент времени доливаем сверху r воды. и в итоге у нас
через 5с в бочке будет уровень воды равен ema1min(+5s)=ema1min(now)-la1min(now)+r(+5s)

честно говорря ебуться можно с этой ema функкцией.
так как функции ema и la связаны то я высчитыаю одну из них а точнее la
а потом на основе ее значения высчивыаю ema. тоесть каждую по отдельности я не высчитываю








| LA 
| r_sr_za_1min.bash
| r_sr_za_30min.bash
| r_sr_za_5min.bash
| r_sr_za_90min.bash


если посмотреть на вывод моих прог по поводу LA
то можно увидеть что я не вывожу LA прочитанный из proc
я вывожу только мой рассчитанный самими моими руками.
возникает вопрос почему? надо ведь выводить и мой расчитанный руками
и тот что высчитывает само ядро. ОДднаком тут кроется польебка!
поэоому я их и не вывожу!

обьясняю:

насколько я понимаю мои проги не показывают la из proc
потому что la очень сильно будет отличаться 
если мы его считаем на основе R(t) где t оно лежит на не тех 
точках времени.тоесть

комп считает la на основе точек R(t) причем точки t
у него свои.
а я  считаю la в совей 
программме на освнео R(t) на основе точек t своих поэтому если я 
буду в программе сравниавать la(t) ихний из proc и свой la(t)
в одной и той же точке t то оно будет сильно отличаться 
щас покажу



|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
  |---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


верхний ряд это ихний сэплинг t
а нижний это мой.
в промежутке считается что нихрена не происходит.
а по факту происходит. поэтому если я вычситал LA(t0)


|---|-o-|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
  |---o---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|


а потом запращивают его из proc  и сраниваю со своим то он будет очень
даже не совпадать. учитывая то что мат функция LA она очень чутвителная
на каждое изменение R(T)

вот я показал на графикет "o" это та точка времени t=t0 в которой
я высчитвают la(t0) и  да я могу прочиать в этот момент занчение из proc
но у них  это будет LA  не во время t=t0 а на самом деле у них я получу
LA  от времени немного левее 


|---x-o-|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
  |---o---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|

я  показал через "x" на LA на какоой момоен времени я получу.
я говорю что LA это очень чуствителная функция даже к одному добаввлению
нового R(t) поэтому  в своих программах я не показываю на экране
LA из проц. потому что сравнивать его со своим нет смысла.
вот!






