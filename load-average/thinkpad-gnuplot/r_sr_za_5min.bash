#!/bin/bash

#
# по всем вопросам и ошибкам при запуске  
# смотри README.txt
#
#
# кратко:
# (i)считываем r=R(t) в течение 5 минут
# как только программа стартанула она набивает массив r() 
# начальными значениями равными la1min(now) а потом считываем
# через каждые 5с секунд уже реальнцю точку r и вставляем ее в массив
# и заменяем  искусственное начальное значение поэтому чтобы начать видеть 
# реальную картину ситуации на компе после запуска надо подождать 5 минут
# массив r на старте набивается поддельными начальными значениями чтобы
# как раз таки не сидеть перед черным экраном и неждать 5минут 
#
# (i)на основе это высчитываем 
#     ema1min 
#     la1min 
#     r_sr_5min_pr (среднее r  за 5 минут )
# а далее можно визуально сравнить насколько совпадают либо отличаются 
#    la1min и r_sr_5min_pr
#
# (i)почему мы собираем r(t) в течение именно 5 минут.
# потому что читай в файле la.txt
# 
#
#
#
# (i)типичный вывод на экран
# r=.56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 .56 2 2 2 2 2 2 |
# 100.0% [||||||||||||||||||||||||||||||||||||||||||||||||||]
# r_summa=42.80 ema1min=14.08 la1min=1.13  |  ema1min/r_summa=32.90% la1min/r_summa=2.63%  | r_sr_5min_pr=0.70  r_sr_5min_pr/r_summa=1.62%   
#
#
#
# [|||| ... ] - полоска прогресса это как бы busytime у cpu высчитывается очень 
# просто мы суммируем число точек где r != 0 и делим на общее 
# число точек
#
#  r_summa=42.80   - сумма r за 5 минут
#  ema1min=14.08   - ema1min количество воды в баке на данный момент
#  la1min=1.13     - la1min сколько воды вытечет из база в течение следущих 5секунд
#  ema1min/r_summa=32.90%   - отношение сколько воды щас в баке в отношении к сумме залитой воды за 5 минут
#                             (в процентах)
#  la1min/r_summa=2.63%     - отношение сколько воды вытечет из бака в течение следущих 5 секунд
#                             в отношении к сумме залитой воды за 5 минут
#                             (в процентах)
#  r_sr_5min_pr=0.70  - среднее значение r за 5 минут
#  r_sr_5min_pr/r_summa=1.62% -  отношение среднего значения r за 5 минут к сумме воды залитой
#                                в бак за 5минут
#                                (в процентах)
#
#
#
# (i)при анализе того что выводится на экран нас прежде
# всего интересует сравнение 
#                la1min vs  r_sr_5min_pr             
# насколько близки значения из  
#
#





#
# основные переменные
#
f_m="5"  # сколько даннных для начала нужно набрать в минутах
r=();la_p=0;la_now=0;b_t_5min=0;la_m1min=0;b_t_5s=0;b_t_5s_array=();
size_f_m="$(( $f_m*12 + 1 ))";




#
# функции
#
function initialize_arrays  {
    size_r="$size_f_m"   


    la_p=$(  bc <<< "scale=2; $(cat /proc/loadavg | awk '{print $1}')/1"    )

    r_sr=$la_p ;  # набиваю массив r из r=r_sr
    for i in $(seq 0 1 $(( $size_f_m-1 ))  ); do
        r+=( "$r_sr"   )           ;
    done
}



function initialize_palki {
    dlinna="50"
    palki=$( for i in $(seq 1 1 $dlinna); do echo -en "|"; done   );  tochki=$( for i in $(seq 1 1 $dlinna); do echo -en "."; done   ); # переменные визуалиаззации

}



function find_alpha {

    local min=1;   # задает это у нас la1min\la5min\la15min 
                   # в данном случае мы задали la1min
    alpha=$( bc -l <<< "scale=11; e(-5/($min*60) )      "       ) 

}



function progress_bar {
    
    local busy=$( bc <<< "scale=5; $dlinna * ($b_t_5min/100) " | cut -d"." -f1   ); [[ -z "$busy" ]] && busy="0"; \
                                   [[ $( bc <<< "scale=11; $busy>=($dlinna-1)"   )  -eq 1   ]]  && busy="$dlinna" ; # echo "$busy" ; 
    local idle=$( bc <<<  "scale=5; $dlinna - $busy " | cut -d"." -f1  );  # echo $busy $idle

    b_t_5min_graph=$(    echo -en "["; \
	                 echo -en  ${palki:0:$busy };\
    	                 echo -en  ${tochki:0:$idle };\
        	         echo "]" \
            	     );
}


function sleepy() {

   if [[ "$1" -le 0 ]]; 
   then  
      echo "функция sleepy аргумент \$1 должен быть >= 1"
      exit 1
   fi

   printf "\n"

   a_ar=( '|' '/' '='  '\' '|' '/' '--' '\' ); 
   for i in $(seq 0 $(( "$1" -1 )) ); 
   do   
      printf "Жду $1с...[%s]\r" "${a_ar[$i]}";
      sleep 1; 
   done

}



function main_init() {

    printf "Инициализация ...1/3\r" 
    initialize_arrays
    initialize_palki
    find_alpha
    sleepy 5; # мы ждем 5 секунд не просто так. 
          # нужно выждать 5с после перед тем как начать
          # считывать r после того как мы считали начальный la 
    printf "Инициализация ...3/3[100%%]\n\n" 

}



###############################################################################
# начало тела
###############################################################################

#
# иницилизация
#
main_init



#
# главное тело рабочее
#
while true; do  

    r=( ${r[@]:1:$size_r} ); 

    # два способа найти число R+D тредов
    # выбирай любой
#   r+=( $( ps -A -L -o cmd,stat  | grep -E "R|D" | grep -v -E "STAT|bash|grep|ps|wc" | sed 's/\(.*\)\( .*$\)/\2/' | grep -E "R|D" | wc -l   )  )   ;  
    r+=( $((  $(grep "procs_running" < /proc/stat | awk '{print $2}') + $(grep "procs_blocked" < /proc/stat | awk '{print $2}')  ))             )   ;

    r_summa="0"; for i2 in ${r[@]}; do  r_summa=$(    bc <<< "scale=2; $r_summa+$i2    ")   ; done;
    la_now=$( bc <<< "scale=2;     ($alpha)*$la_p+(1-$alpha)*${r[-1]}     ");
    r_sr_5min_pr=0; for i13  in ${r[@]}; do  r_sr_5min_pr=$(    bc <<< "scale=4; $r_sr_5min_pr+$i13/$size_f_m    ");   done;
    b_t_5min=0; for i in ${r[@]}; do  [[  $(    bc <<< "scale=2; $i>0    ")  -eq 1 ]]  &&   b_t_5min=$(    bc <<< "scale=4; $b_t_5min+100/$size_f_m    ");   done;   



    progress_bar


    printf  " r=%-20s |\n %.1f%% %s\n r_summa=%s ema1min=%-5.2f \033[32mla1min=%-5.2f\033[0m |  ema1min/r_summa=%s%% la1min/r_summa=%s%%  | \033[32mr_sr_5min_pr=%-5.2f\033[0m r_sr_5min_pr/r_summa=%s%%   \n\n"                               \
                                     "${r[*]}"    \
                                      $( [[ "$(locale LC_NUMERIC | head -n1)" == "," ]] && tr "." "," <<< "$b_t_5min" || printf "$b_t_5min"  )   \
                                     "$b_t_5min_graph" \
                                     "$r_summa" \
                                      $( [[ "$(locale LC_NUMERIC | head -n1)" == "," ]] && tr "." "," <<< "$( bc <<< "$la_now*12.5" )" || printf "$( bc <<< "$la_now*12.5"  )"  )  \
                                      $( [[ "$(locale LC_NUMERIC | head -n1)" == "," ]] && tr "." "," <<< "$la_now" || printf "$la_now"  )  \
                                      $( bc <<< "scale=2; 100*($la_now*12.5)/$r_summa" ) \
                                      $( bc <<< "scale=2; 100*($la_now)/$r_summa" ) \
                                      $( [[ "$(locale LC_NUMERIC | head -n1)" == "," ]] && tr "." "," <<< "$r_sr_5min_pr" || printf "$r_sr_5min_pr"  )  \
                                      $( bc <<< "scale=2; 100*($r_sr_5min_pr)/$r_summa" )  \
                                      | tr "," "." 

#
# здесь можно заметить интересное про bc
# спрашивается зачем нужно делить на 1
#           ( bc <<< "scale=2; ($la_now)/1"      )
# а дело в том что у дебила bc у него ограничение scale=2 работтает только 
# для операций деления! а если мы просто число ему суем или операцию уножения
# то он не будет на выводе ограничивать число цифр запятой. дебил !
# поэтому нужно всегда резулльтат делить на 1
#

# также можно заметить такой кусок интересный
#   ... locale LC_NUMERIC ...
# дело в том что printf он работает учитывая настройки locale 
# и если в нашей локали указано что числа с запятой должны иметь разделитель 
# в виде запятой а мы в принтф суем число  с разделителем точка а модификатор указали %f
# то принтф выдаст ошибку и пошлет нахер поэтому я это учитываю и при необходимости
# модифицирую аргумент заменяя знак разделителя дробной части



    la_p="$la_now"
    sleepy 5


done;  
exit 0


###############################################################################
# конец тела
###############################################################################




