#!/bin/bash
#
# скрипт работает так
# он проверяет есть ли файл $FN на диске
# если он есть то число процессов $p и load average 
# считывается с файла
# далее идет расчет расчетного la и среднего арифметического
# и все это выводится обратно в файл
#
# причем в чем еще прикол. если надоело ждать 
# пока снимутся все данные можно прервать выполнение
# запустить еще раз и так как файл уже есть
# то будет посчитано среднее
#





# блок инициализации
MEAN_ENABLE="0"   # нужно ли считать среднее арифметическое
PRINT_SCREEN_ENABLE="0"  #нужно ли печатать на экране 
FN_ALLOWED_SIZE="320" # макс число строк которое можно считать из файла с данными


a=$( bc -l <<< "scale=11; e( -1/12 )" ) # коэифициент который  отвечает какой процент берется от прошлого LA

amount=11   # сколько суммарно минут мы будем собирать точки из  /proc/loadavg
FN="./1.input"  # имя файла с данными
F_OUTPUT="./1.output"
k=13   # по скольким точкам усредняем среднее арифметичское
       # расчет такой: скажем  хотим 5 минут. 300с/5+1=61
       # для одной минуты k=13
       # для двух минут k=25
       # для трех минут k=37
       # итд
step=5  # длинна одного промежутка в секундах
[[ -f "$FN" ]] &&  time="$(wc -l < $FN)"  || time=$((  $amount*60/$step+1   ))   # число точек  когда снимаются данные 
                                                                                 # их на +1 больше чем  промежутков
								                 # число точек должно быть кратно числу точек $k 
								                # по которым делаем усреднение

t=0
t_array=();  # время
p_array=();  # процессы
LA_array=(); # LA померянный из практики
e_array=();  # LA расчетный



 
# препринт
if [[ "$PRINT_SCREEN_ENABLE"  -eq 1  ]]; then
	printf "\nкоэфициент = %s\nt-время\np-число R\D процессов\np_LA-реальный LA\nc_LA-расчетный LA \n\n" "$a"
	printf "%3s | %4s | %5s | %5s | \n" "t" "p" "p_LA" "c_LA"      # p_LA реальный LA, c_LA расчетный LA
	printf "%s\n" "----------------------------"

fi


# если файл $FN есть то читаем данные оттуда
if [[ -f "$FN" ]]; then
    FN_SIZE=$(wc -l < "$FN"); [[ "$FN_SIZE"  -gt "$FN_ALLOWED_SIZE"   ]] && { echo "размер $FN_SIZE файла \"$FN\" больше чем разрешенный $FN_ALLOWED_SIZE, урезаю размер чтения..."; FN_SIZE="$FN_ALLOWED_SIZE"; }
    for i in $(seq "$FN_SIZE"); do  
	str_temp="$(head  -n +"$i" < $FN | tail -n1)"
	p="$(  awk '{print $2}' <<< $str_temp  )";  p_array+=("$p")     # число процессов
	LA="$( awk '{print $3}' <<< $str_temp  )";  LA_array+=("$LA")   # LA
	t="$(  awk '{print $1}' <<< $str_temp  )";  t_array+=("$t")     # время t
	[[ "$i" -eq 1 ]] &&  e="$LA" || e=$( printf "%.2f" $( bc -l <<< "scale=11; $e*$a+$p*(1-$a)" | tr "." "," ) | tr "," "." ); e_array+=("$e")


if [[ "$PRINT_SCREEN_ENABLE"  -eq 1  ]]; then
	printf "%3s | %4s | %5s | %5s | \n" "$t" "$p" "$LA" "$e"
	[[  ! "$i" -eq 1  &&  $(( ("$i"-1) %  12 )) -eq 0  ]] &&  { printf  "^минута %s\n------\n"   "$(( i/12 ))"; }
fi



    done
    #echo "p=${p_array[*]}"
    #echo "LA=${LA_array[*]}"
    #echo "t=${t_array[*]}"
    #exit 1


else
    # если файла $FN нет то основной блок вычислений
    # в момент t=0 мы не можем начать считать расчетный LA который обозначаен переменной e
    # потому что у нас нет расчетного e предыдущего поэтому первый e я принимаю 
    # равным LA из эксперимента 
    # тоеть e(0)=LA(0)
    # а уже следущие e высчитываются по формуле
    for i in $(seq 0 1 "$(( time-1 ))")
    do 
	p=$(   ps -A -L -o cmd,stat  | grep -E "R|D" | grep -v -E "STAT|bash|grep|ps|wc" |  sed 's/\(.*\)\( .*$\)/\2/' | grep -E "R|D" | wc -l       ); p_array+=("$p")
	LA=$( awk  '{print $1}' < /proc/loadavg | tr  -d "\n"); LA_array+=("$LA")
	[[ "$i" -eq 0 ]] &&  e="$LA" || e=$( printf "%.2f" $( bc -l <<< "scale=11; $e*$a+$p*(1-$a)" | tr "." "," ) | tr "," "." ); e_array+=("$e")


if [[ "$PRINT_SCREEN_ENABLE"  -eq 1  ]]; then
	printf "%3s | %4s | %5s | %5s | \n" "$t" "$p" "$LA" "$e"
	printf "%3s %4s %5s %5s %8s \n"      "$t" "$p"  "$LA" "$e" >>  $F_OUTPUT
fi


	sleep "$step"
	t_array+=($t); let t+=("$step")
    done


fi




# вычисление среднего арифетического
# высчитываем так:  для n-ый точки например t=60s
# берем последние 13 точек включая нашу t=60 
# тоесть t=0,1,2,3...60 
# между ними интервал 1 минута
# для этих точек высчыиавем сренднюю арифм
# и эту среднюю наносим в t=60
# поэтому первая точка среднего арифметического появится 
# на графике только начиная с t=60
# для точек которые раньше у нас просто нет 
# материала на котором можно было бы считать
#
# пример k=13
# t=60s это n=12
# значит надо просуммировать элементы 0 1 2 3 4 5 6 7 8 9 10 11 12
# тогда c=12
# $(( c-(k-1) )) = 0
# будет for j in $(seq 0 1 12)
#
#
#
if [[ "$MEAN_ENABLE" -eq 1 ]]; then

	a_array=() # среднее арифметическое число процессов за одну минуту'
	for  (( c="0"; c<"${#p_array[@]}"; c++ )); do 
	    a_sum=0
	    if [[ "$c" -lt "$(( ($k-1) ))"   ]]; then 
		average="undef"   # для t<60s мы не можем посчитать среднее арифм поэтому приравниеваем к  undef

	    else 
		for j in $( seq  "$(( $c-($k-1) ))"   1  "$c"  ); do
		    let a_sum=a_sum+"${p_array[j]}"
		done

		average=$( printf "%.2f" $( bc <<< "scale=11; $a_sum/$k" | tr "." "," ) | tr "," "." );
	    fi


	    a_array+=("$average")


	done

else a_array=()


fi    #  конец от if [[ "$MEAN_ENABLE" -eq 0 ]];





#echo  "a_array=${a_array[*]}"; echo  "a_array size=${#a_array[*]}"
#exit 1

if [[ "$PRINT_SCREEN_ENABLE"  -eq 1  ]]; then
	# вывод суммарной инфо на экран и в файл
	printf "\n\nвывод суммарной инфо \n"
	printf "\nкоэфициент = %s\nt-время\np-число R\D процессов\np_LA-реальный LA\nc_LA-расчетный LA\na_array-среднее арифметическое \n\n"  "$a"

	printf "%3s | %4s | %5s | %5s | %8s |\n"     "t" "p" "p_LA" "c_LA" "a_array"      # p_LA реальный LA, c_LA расчетный LA a_a среднее арифметическое
	printf "%s\n" "---------------------------------------"
fi


[[ -f "$F_OUTPUT" ]] && true > $F_OUTPUT
for  (( c=0; c<"${#p_array[*]}"; c++ )); do 

    if [[ "$PRINT_SCREEN_ENABLE"  -eq 1  ]]; then
	    printf "%3s | %4s | %5s | %5s | %8s | \n"      "${t_array[c]}" "${p_array[c]}"  "${LA_array[c]}" "${e_array[c]}" "${a_array[c]}"
	    [[  ! "$c" -eq 0  &&  $(( ("$c") %  12 )) -eq 0  ]] &&  { printf  "^минута %s\n------\n"   "$(( c/12 ))"; }
    fi


    printf "%3s %4s %5s %5s %8s \n"      "${t_array[c]}" "${p_array[c]}"  "${LA_array[c]}" "${e_array[c]}" "${a_array[c]}" >>  $F_OUTPUT
done



