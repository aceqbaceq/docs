| iptables схема

вотесть схема

https://wiki.nftables.org/wiki-nftables/index.php/Netfilter_hooks


на ней есть две важнейшие штуки - слева посредние
написано "bridge port" а справа вверху написано
"bridge device" в чем разница? она огроманая.
bridge port это L2 порты бриджа(tap1, tap2, veth1 тп).  а bridge device это L3 порт бриджа (br0)

теперь очен важный кусок картины
то что они называют Local process это на самом деле
сокет в ядре. нкакого процесса нигде нет. есть сокет
в ядре из которрго ядро берет данные ровно также
как оно это делает из порта сет карты
так вот схема



 socket ---
          |
       (route
       decision) -- output  
                     hook
                      |
                      |
             postrouting ---- bridge (no) --> eth0(L3)
                    hook      device
                                 |(yes)
 L3                              |
=================================|===================== L2                              |
                                 |
               Output ___________|
               bridge
                  |
                  |
                 ...

на что хочу обратить внимание. вот у нас в ядро
поступает пакет из сокета(так скажем) и ядро 
наичинает прогонять пакет через l3 иптейблс правила
первый шаг routing decison здесь ипейблс на основе
дест ип ишет в таблице марштиацзации запись 
исходя из которой определяет src_ip для ип пакета
и имя сет карточки в которую нужно будет сунуть
этот ип пакет. положим что это eth0
далее пакет проходит через OUTPUT и POSTROUTING 
хуки. дальше по идее пакет уже  надо соовать в сет
карточку eth0 и выплевыыват в сеть. так вот 
пере этим ядро делает доп проверку. называется
на картинке этот шаг (bridge device) на этом шаге
ядро проверяет а не явлется ли случайно наш 
destination L3 порт еще в добавок к этому L3 поортом
в составе свича. это очень важно понять. тоеть
он проверяет наш eth0 L3 порт ( который мы опредедлили
на шаге (routinf decision) на оснвое записи из таблицы
маршраутизации ) еще в добавок L3 портом в составе
бриджа. дело в том что когда мы создаем бриж  у него
есть два типа портов. основая часть портов это 
L2 порты через котоыре трафик прогоняется на освнове
свичинга по мак адресам. но также есть один особый
порт он как бы тоже с точки зрения свича является
свичевым тоесть L2 и нанего тоже свич посылвает
например бродакаст трафик итп. но также на этом порту
находится и софт который обрабтывает трафик на освное
IP заголовков. тоесть этот порт он L2+L3 
обычно этот порт имеет имя br0 
c точки зрения внешнего наблюдателся это просто L3
порт. а сточки зрения изнутри свича это L2+L3 порт.
я имею ввиду что изнутри свича на этот порт пакеты
шлются на основаии мак адресов тоесть они туда 
свячатся. просто на этом порту стоит доп софт который
анализировать засвиченный на неготрафик еще и с
точки зрения ип заглоовков. а снаружи этот порт
выгядит как обычный маршрутизируеый тоесть на него 
снаружи все шлется не наоснвое свичинга а на основе
роутинга. 

так вот если eth0 этообвыкновенный порт то ядро
просто "пихает" в него пакет в TX очередь. и на этом
обработка пакета закачиватся. он попдает в сет карту
и оттуда в сеть. ну имею ввиду если eth0 это реальный
физ адрес то пакет попадет в сеть. а если eth0 
это вирт карточка то пакет попадает в ядро (как
говорится из ядра в ядро) но в какую то другую часть
ядра в какйто другой кусок ядра кторый предназначен
дя обработки потока который был сунут на карту


ядро
   ======> TX eth0  ===> ядро (другой кусок)


так вот если у нас eth0 это br0 тоесть L3 порт 
входящйий в состав бриджа то ядро вобщемто 
на самом деле сует пакет  в этот br0 а там
его уже ждет софт который обслуживает код виртуаль
ного свича. и софт так написано что еси поток
влетает  в него из br0 порта то нужно сразу 
прыгнут на OUTPUT HOOK в этом софте. я считаю что
картинка вверху хуево нарисована она мислидинг
она нам говорит что якобы ядро несует поток в
карту br0 А ВМЕСТО ЭТОГО якобы сразу сует поток
в output hook    внутри софта свича. я считаю 
что это наебалоово. только путает. на саомом 
деле ядро по любому сует поток в ту L3 карту котрая
была ввыбрана стадии routing decision. а далее
этот поток принимает софт который обслуживает 
эту карту. если это софт вирт свича то он принимает 
этот поток. и логика у этого софта такая : еси 
пакет влеетел в софт через br0 порт то суй его
сразу на outut  hook. а если пакет влетел в софт
свича через L2 порт (tap,veth)то суйэтот пакет
в PREEOUTING HOOK вот и все. а не как они показывают
что якбы если L3 порт это br0 то в него пакет не
суется. это вранье. суется и еще как.
тоесть вот такая картинка правльная


         _________________________________
         |
         |
  ===>br0=====  output hook ----....
  ===>tap0===== prerouting hook ----....
         |
         |_________________________________


это в точности можно увидеть в логах

[NAT-POSTROUTING icmp] IN= OUT=br0   (iptables)
[filter OUTPUT] IN= OUT=tap0          (ebtables)


вот получается у нас верхняя строка это последнее
правило в postrouting хуке который лежит в ядре
в области L3 обработки потока. и видно что 
выходным портом задан br0
если тцпдам включить

  # tcpdump -epn -i br0 

то можно будет увидеть что пакет реально был от
правлен ядро в карточку br0 тоесть в ее TX очередь
тоесть с точки зрения ядра это исходящийтрафик
через эту карту куда то там наружу. тоест ядро
реально запихнуло чтото в нее. ну а дале на той
стороне карты ее пакет уже ждет ebtables софт. 
ну и он рисует вот такое

		IN= OUT=tap0

ненужно смуаться что докалыает что пакет попал в
софт бриджа в ebtables якобы через порт IN=
это на саммо деело дебильно закодированное обознчение
порта br0. дело в том что ебтейблс в этих графах 
отображает тлоко чистые L2 порты поэтому коода  в 
свич влеает пакет из vr0 котоырй L2+L3 то он этот
факт обозначает такойдебилной строкой

   IN=

что пакет якобы из воздуха появился.

вобщем вот такая дебильая мислиинг каринка на сайте.
вот что такое bridge device и bridge port
вот как ебтйеблс обозначает факт если пакет 
влетел в свич чрез br0 порт. 
сплощные ебанутости короче.


далее  хочу подчерунть что строки в логах

[RAW OUTPUT icmp] IN= OUT=br0  
[NAT-OUTPUT icmp] IN= OUT=br0  
[FILTER-OUTPUT icmp] IN= OUT=br0 
[NAT-POSTROUTING icmp] IN= OUT=br0 

они покаазывают путь по цепочкам иптейблс
еще до того как пакет засунуть в br0  
тоесть это обработка не после того как он 
был заснууть в br0 а до того.


а вот полный тракт прхода по цепочкам когда
мы с компа пиганули виртуалкуи внутри бриджа

вначале идет обработка пакета внутри
иптбейлс цепочек после того как пакет забрали
из сокета но до того как его сунули в br0
[RAW OUTPUT icmp] IN= OUT=br0  
[NAT-OUTPUT icmp] IN= OUT=br0  
[FILTER-OUTPUT icmp] IN= OUT=br0 
[NAT-POSTROUTING icmp] IN= OUT=br0 

потом его наконец заснули в br0 и он попадает
в софт ebtables как часть софта бриджа.
пакет оказывается внутри свича
и вот через какие цепочки ебтейблс его протаскивает
ядро

[filter OUTPUT] IN= OUT=tap0 
[nat OUTPUT] IN= OUT=tap0 
[nat POST] IN= OUT=tap0 


как я уже сказал обозначение   IN=  обонзначает 
что пакет попал в свич через br0  порт. вот такое
дебилное обозначеие этого факта.

итак вот она поная цепочка собйтий уже без 
коментариев


 сокет
  |
  iptables 
[RAW OUTPUT icmp] IN= OUT=br0  
[NAT-OUTPUT icmp] IN= OUT=br0  
[FILTER-OUTPUT icmp] IN= OUT=br0 
[NAT-POSTROUTING icmp] IN= OUT=br0 
  |
  ebtables
[filter OUTPUT] IN= OUT=tap0 
[nat OUTPUT] IN= OUT=tap0 
[nat POST] IN= OUT=tap0 
  |
  VM



а вот другая схема. до этого мой пакет влетал 
в свич через br0  порт. котрый как я сказал особый
для свича потму что для него это не просто L2 порт
а для него это L2+L3 порт поэтмоу к нему особое
отношение. особые цепочки проходит пакет внутри
ебтейблс если влетел чрез тот порт.
так вот другой случай когда пакет влетел в свич
через стаданртный L2 порт .тут обработка будет
совсем другая


вот такая схема

                 _____________________
IP=...           |                   |
vethP1 ------ =vethP2               br0=
                 |____________________|
                                     

из vethP1  я шлю внутрь свича пакет через vethP2
котоыый для свича является обычным L2 портом

вначале идет стадантная уже частть изобраажающая
обабтку пакета когда он был взят из сокета
процесса но еще не был засунут в L3 карту
так как он еще не влетел в свич то эта часть
такая же как в предыдущем случае

[RAW OUTPUT icmp] IN= OUT=vethP1
[NAT-OUTPUT icmp] IN= OUT=vethP1
[FILTER-OUTPUT icmp] IN= OUT=vethP1
[NAT-POSTROUTING icmp] IN= OUT=vethP1 

значит кода ядро заснуло пакет в vethP1 в его
TX очередь  то там его уже ждат veth софт ядра
который этот пакет берет и без участия иптейблс
сует в RX очередь порта vethP2 а там его уже
ждет софт бриджа так как этот порт вставлен в бридж.
и тамже его ждет ебтейблс. 
итак у нас пакет оказаться внутри свича. с точки
зрени свича он в него влетел из порта vethP2
что мы и видим в логе в куске  IN=vethP2

[broute BR] IN=vethP2 OUT= 
[nat PRE] IN=vethP2 OUT= 
[filter FORWARD] IN=vethP2 OUT=tap8 
[nat POST] IN= OUT=tap8 

можно замттить что правила котоыре обарабтывают
этот пакет в свиче. сущесвтенно оличаются от правил
пореддущего случая коода пакет влетел в свич
через br0

в этом и состит разница влетелли пакет в свич
чрез br0 или через L2 порт.  - разница в наборе
правил чрез котоыре ебтейблс прогонит пакет внутри
себя.

еще раз покажу тракт пролета пакета и какой софт
его где обрабывает



сокет --- иптбейлс --- vethP1 ----- веф софт ---vethP2--- бридж соф, ебтейблс ---....

замечу то что при преедаче пакета из vethP1 в vethP2
иптейлс не участвует. также софт бриджа понятия 
неимеет что пакет изанлаьно леетел чрез vethP1 
для брлжа видно только то что пакет влетел в 
бридж через vethP2


а вот теперь вот такой случай

сокет ---------bondV2.2 --
-- bondV2 --- veth3-1 ---- veth3-2 --- tap14


значит что здесь. bondV2 это бондинг порт. 
в его состав входит порт veth3-1 
с точки зрения ядра и bondV2  и  veth3-1 являются
L3 портами. тоесть они не 2 порты , они не свиче
вые поэтому проход трафика через них небдует
виден в ебтейблс. но не сморя на то что эти два 
порта L3 при передаче инфо на них и с них не 
участвует ип тейблс поэтому они для него невидимые.
veth3-2 это напарник от veth3-1 но он воткнут 
в свич поэтому он рабтает на уровне L2
tap14 это тоже L2 порт свича. итак в свиче 
два порта.

теперь я покауж по частям какой софт отвечает 
за передачу пакета между портами

первый кусок тракта


      [iptables]
сокет ----------bondV2.2


тоесть от сокета до bondV2.2 протаскивает пакет
у нас иптейблс




второй кусок тракта

        [      bond софт ]
bondV2.2 ---- bondV2 --- veth3-1 ---- veth3-2


тоесть как тока мы засунули пакет в bondV2.2
то его берет бонд софт и без участия иптейлс
протксивает через два порта

         [веф софт]
  veth3-1 ---------veth3-2

как тока пакет заснули в первый веф то его 
похывает веф софт и без участия иптейлс протаскивает
и запихывает во второй веф. 

итак у нас уже два участка без участия иптейлс.
згначи эти порты будутневимые в его логах

       [ebtables   ]
       [bridge софт]
veth3-2 ------------ tap14

как тоько пакет оказался в этом веф порту его
встрчает бриж софт и протаскиывает до tap14 и сует 
туда 
примечательно что на этом участке работает ebtables

таким образом в логах мы увидим тлько вот этот
участок


      [iptables]                   [ebtables ]
сокет ----------bondV2.2---veth3-2 --------tap14

причем в логах выглядеть будет так что пакет
сунули в bondV2.2 а дальге он загадоным образом
при этом вылетел из veth3-2 и оказался в свиче

тоесть как бутто вот эти порты это рельные
физ порты 

   bondV2.2  veth3-2

и между ними лежит реальная физ сеть

а теперь псмоортрим что видно в логах
относительно первого участка вот его лог


[RAW OUTPUT icmp] IN= OUT=bondV2.2  
[NAT-OUTPUT icmp] IN= OUT=bondV2.2  
[FILTER-OUTPUT icmp] IN= OUT=bondV2.2  
[NAT-POSTROUTING icmp] IN= OUT=bondV2.2

стаадартный лог никакх сюрпризов. это путь 
обработки пакета когда его взялои из сокета
но в порт bondV2.2 еще не засунули

вот лог втторого участка кода у нас пакет
внутри свича


[filter FORWARD] IN=veth3-2 OUT=tap14
[nat POST] IN= OUT=tap14

тоесть по мнению ебтейблс пакет влетел в свич
через L2 порт IN=veth3-2
правда непогятно поемму во втором правиле вдруг 
исчезла инфо откуда приелетел пакет.

но уидвиельно другое. по мне в этом случае набор
правил должен быть вот такой


[broute BR] IN=vethP2 OUT=
[nat PRE] IN=vethP2 OUT=
[filter FORWARD] IN=vethP2 OUT=tap8
[nat POST] IN= OUT=tap8


>>>>>>>>>ЗАКОНЧИЛ ТУТ <<<<<<<<<<<
надо будет вот чо проверить. "праивльный график"
он покзывает на схеме

   ip      [свич] 
   веф - веф  - тап

и подключен он к br0

а непавилный 


ip                [свич      ] 
vlan - bond - веф- веф - порт

и подключен он к бриджу br3\4


пообовать эту схему
   ip      [свич] 
   веф - веф  - тап

подключить к брижу br3/4


пообовать к этой схеме добавит вилан


ip           [свич     ] 
vlan-   веф - веф  - тап


может чтот о и проянится на счет логов




