| proc
| process running
| runnable
| uninterruptible sleep
| iowait
| R state
| D state

щас я обсужу несклько вещей


в /proc есть интересное место

/proc/stat

$ cat /proc/stat
cpu  4721737 21576 1636313 56013236 21500 0 32164 0 871770 0
cpu0 1168534 4828 394858 22597623 8237 0 6433 0 220313 0
cpu1 1150680 5550 377133 11175716 4386 0 17068 0 210190 0
cpu2 1204062 7722 435046 11109192 4629 0 5075 0 222604 0
cpu3 1198459 3475 429275 11130703 4246 0 3586 0 218662 0
ctxt 488212260
btime 1716190979
processes 741103
procs_running 1    <====  **
procs_blocked 0    <====  **
softirq 138098337 780915 15216060 260 5311571 773763 3 269048 86472933 3796 29269988

есть две интересные строчки

	procs_running 1  (1)
	procs_blocked 0  (2)


первая строчка показывает сумму числа процессов которые имеют R сосотяоние
тоесть runnable

вторая строчка показывае число процессов в D сосотоянии

таким образом с какой то степенью точности можно узнавать 
число R+D тредов (кстати да оно показывает не число процессов а число тредов!
дело в том что с точки зрения ядра его програмирования то что зовется 
тредами в юзерской литераутту в ядрерном програмиорвании называется процесс
а то что мы называем процессы в юзерской литературе в ядреной лтературруе
называтеся группа процессов) путем суммиорвания этих двух
строчек

вот как это можно делать

$ for i in $(seq 0 10); do echo $((  $(grep "procs_running" < /proc/stat | awk '{print $2}') + $(grep "procs_blocked" < /proc/stat | awk '{print $2}')  ));  sleep 5;  done
3
2
1
5
1
1



я еще одну итересную штукю обсудю.
в строке про cpu есть пятый столбик
                                     ||
                                     \/
cpu  4721737 21576 1636313 56013236 21500 0 32164 0 871770 0


вот что про него написано
 iowait (since Linux 2.5.41)
                            (5) Time waiting for I/O to complete.  This value is not reliable, for the following reasons:

                            1. The CPU will not wait for I/O to complete; iowait is the time that a task is waiting for I/O to complete.  When a CPU  goes
                               into idle state for outstanding task I/O, another task will be scheduled on this CPU.

                            2. On a multi-core CPU, the task waiting for I/O to complete is not running on any CPU, so the iowait of each CPU is difficult
                               to calculate.

                            3. The value in this field may decrease in certain conditions.


 по мне написано хуево. а смысла на самом деле такой
 когда срабатывает таймер и на цпу залезает шедулер. то он обновляет статистику 
 использования цпу. она вот тут и отражена. шедулер помечает что очередной слайс
 времени между преддыдушим срабатываанием шедулера и щас цпу отработал либо 
 в юзер режиме либо в кернел режиме либо обрабаывая интеррапт и так далее. 
 ксатти пришел вопрос вот у нас шедулер засунул код процесса на цпу и запуситил его.
 цпу раотает  в режиме юзерском. юзерская программа делает сисколл. цпу переключается
 в привлигиорваый режиме (то что зовется system time. ) у меня вопрос при этом
 переклчючении всегда сразу взывается шедулер который смотрит что случилось 
 или код сискола который мы вызывали сам сразу начинает работу ведь ядерный сисколл
 который вызывали он дожлен сделать некоторую работу для текущего прцоесса тоесть этому 
 ядерному коду нужны все решистры которые оставил там юзерский прцоесс. поэтому по идее
 шедудлер нам ненужен . ибо его задача выдавить код процесса с цпу и вастности 
 вычитстить все регистры этогоо процесса и залить туда нвого а нам это пока ненадо.
 если предеположить 
 что код ядра сисколла сам сразу начнает работу а шедулера код появляется только 
 тогда когда срабатывает таймер (говорящий о том что пора бы процесс сидящий на цпу 
 выдаавливать нахер и дать другим процессами работать ) то тогда воропс получется что 
 между тем временем как шедулер появлялся в прошлый раз процессом мог смнеить режим 
 работы он мог пораобать часть времени как юзер а часть как ядро. откуда шедулер 
 знает скоко времени цпу отрабтал так и так. ? или все таки  как тлоко идет смена 
 режима то всерда автоматом взывается шедуоер? непонятно. навскидку в инете ненашел.

в общем плюс минус я вижу это так  - кажоый раз когда вызывается шедулер который 
должен выдавить текущий процесс  с ядра тоесть зачиитть все регистры и засунуть 
регистры для нового процесса то шедулер так иили иначе записыввет сколко времени 
цпу проработал с момнта преддыдущеей записи в режиме юзер кернел итп. и вот еще в 
этот момент шедулер так как он же занимается освободжением цпу от процесса 
и сованием новного процесса на цпу тоесть оно внимательно смотрит на очередь из процессов
то он смотрит а есть ли в очереди хотя бы один процесс который находится в D состоянии. 
и если есть то он шедулер делает для данного цпу об этом пометку. в отдельный столбик. 
вопрос только в том в столбике записвыается время и вот что за время шедулер пишет 
для этого процесса ? 

вобщем в инете я наешел обьяснение которое похоже на правду хотя 100% скзать что 
этоправда  я пока не могу. --> вот щедулер вылез по таймеру. он смотрт в очередь
и видит что задач в статутсе R нет. тогда у него возникаео желание назначить на выолпненеие
задачу idle и записать себе что цпу на нее потратит время. но в эототот момент он 
долполниетльно провяеряет а есть ли в очереди хотя бы один процесс в D состоянии
если да то цпу записвыает что время цпу будет потрачено не на idle а на iowait.
таким макаром iowait это разновидность idle тоесть 
  idle = ilde + осутствиве D процессов
  iowait = idle + налиичие D процеоосов

  соовтвтенно полный idle на компе это сумма idle + iowait !
тоесть если мы видим на экране nmon что у нас 20% времени цпу прорабоатл в %user
10%  в %sys и 70% idle
то мы мы понимаем что 30% времен у нас цпу пахал а 70% времени ему нчего было делать.
поому что процессы на компе все сделали что хотели и они отдыхали. 

если мы видим 20% user 10%  sys 20% iowait 50% idle 
то мы понимает что 30% цпу пахал и 70% времени цпу делать было нечего.
резултатт такой же. но мы также понимаем что  втовремя когда у нас цпу было нечего
делать  у нас процессы компе они не отдыхали они ждали диск. тоесть у нас в это время
тормозила дисковая система. тоеть возмоно если бы диск был быстрее то процессы бы
в это время грузили бы цпу а может быть и не грузили. по мне так странно 
в статистике загрузки цпу пихать параметр показывающий загрузку дисковой сситемы.
рзаве это не дебиьльно?  
более того если у нас на экране нет iowait это не значит что наша систе дисковая нетормозит!
преставим что у нас два процесса. один на 100% грузит цпу  а второй охуенно грузит диск.
тода у нас цпу будет 100% загружен у него idle не будет  а значит у него iowait повяится 
ниак не может ! так как шедулер начинает проверять на iowait только если цпу неработате
если ему нехер делать. а ему все время есть что делать. тоесть похрошему нунжно 
было бы в графике нагрузки цпу делать две тогда незваииые полоски. а именно. 
одна полоска это загрузка цпу. а вторая покзывает ВСЕ ВРЕМЯ есть ли в очереди шедулера
процессы которые ждут дисовую систему или нет! но эти дебилы так не сделали. 
я бы сказал что iowait это же тот самый %busy time для диска котоырй показывает iostat!
и они его пеернесли или прилепили в датчики цпу! ну недебилы ли?только они решили 
вот как сделать  - они сказали - мы будем награфике загрузки цпу рисовать busy time 
дисковой системы но не все время а только тогда когда процессор idle! охуеть дебилы!
они как бы решили про себя - мол когда цпу есть чем заняться то и так понятно
что система занята. а вот когда цпуделать нечего почему бы нам в этот моммент не рисовать
на графике агрузки цпу загруз-ку дисковой системы! вот дебилы!
им надо было идти еще дальше и сказать себе - а давайте когда у нас цпу делать нечего
и дисковая система не томрозит давайте на гарфике загрузки цпу будем рисовать процент
загрузки видекарты!!! охуеть долбоебы!
а когда у нас и видеокарта стоит надо было рисовать но сетевя карта нагружена 
то нужно было бы ее тоже запихать на график цпу !
   
