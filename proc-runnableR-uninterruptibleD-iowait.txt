| proc
| process running
| runnable
| uninterruptible sleep
| iowait
| R state
| D state

щас я обсужу несклько вещей


в /proc есть интересное место

/proc/stat

$ cat /proc/stat
cpu  4721737 21576 1636313 56013236 21500 0 32164 0 871770 0
cpu0 1168534 4828 394858 22597623 8237 0 6433 0 220313 0
cpu1 1150680 5550 377133 11175716 4386 0 17068 0 210190 0
cpu2 1204062 7722 435046 11109192 4629 0 5075 0 222604 0
cpu3 1198459 3475 429275 11130703 4246 0 3586 0 218662 0
ctxt 488212260
btime 1716190979
processes 741103
procs_running 1    <====  **
procs_blocked 0    <====  **
softirq 138098337 780915 15216060 260 5311571 773763 3 269048 86472933 3796 29269988

есть две интересные строчки

	procs_running 1  (1)
	procs_blocked 0  (2)


первая строчка показывает сумму числа процессов которые имеют R сосотяоние
тоесть runnable

вторая строчка показывае число процессов в D сосотоянии

таким образом с какой то степенью точности можно узнавать 
число R+D тредов (кстати да оно показывает не число процессов а число тредов!
дело в том что с точки зрения ядра его програмирования то что зовется 
тредами в юзерской литераутту в ядрерном програмиорвании называется процесс
а то что мы называем процессы в юзерской литературе в ядреной лтературруе
называтеся группа процессов) путем суммиорвания этих двух
строчек

вот как это можно делать

$ for i in $(seq 0 10); do echo $((  $(grep "procs_running" < /proc/stat | awk '{print $2}') + $(grep "procs_blocked" < /proc/stat | awk '{print $2}')  ));  sleep 5;  done
3
2
1
5
1
1






