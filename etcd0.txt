| etcd


значит etcd это strict serialize база данных.
что это за хрень?


strict serialize = serilize + linerize



что такое сералайз.
вначале более простая хрень.

read uncommited:
база может работать в режиме read uncommited
этот режим вот о чем. что такое транзакция. это набор
элементарых команд по базе которые обьединены в некий батч.
и либо весь батч буден успешно выполнен либо база будет откачена
на состояние до этого батча.
так вот положим что у нас одновременно запулили на базу кучу транзакций.
и вот положим в транз1 мы читаем таблицу. потом в другой транз2 мы модифиицрем
эту таблицу. потом в транз1 мы опять читаем таблицу. так вот режим 
режим read uncommited это когда мы в транзации1 видим изменения в базе
котоыре следадли в этот момент другие субокманды других транзакций
которые еще не доработали до своего конца то есть их дейцствия еще не закомичены.
разница между закмиченой транз и незакомиченой в том что  когда идет транзация
и она еще не дошла до конца то база ведет undo лог на случай если трназакция успешно до конца
не дойдет то база сможет откатить состсоние базы до начала транзации. все что дедает 
транзация пока она не закомтилсь это некая вреенная пробная хрень. потому что она может до конца
и недойти. так вот если база работает как read uncommited то моя траназкция видит данные
которые засунуты в базу от дейсатвий субкоманд незакомиченных транзакций. 

вобще есть три вида аномалий приколов в базе. 
дерти риды - это когда мы в своей траназации видим данные которые лежат в базе за счет 
дейвтсий субкоманд транзакций которые еще не закомтились

нон рипитбл риды. это когда я в транзации читаю из базы. потом четото делаю.
потом опять читаю тот же запрос и  у меня в запросе число строк тоже самое но 
их контент ячеек изменился за счет действий за это время других транзакций которые успели 
сделать свое делать и закомитться

фантомные риды - это когда я в своей транзации читаю . потом чето делаю. потом опять читаю
и контент в строках не изменился но изменилось число строк стало болше и ли меньше
засчет действий других закомченных транзакций.

режим read uncommited ловит все три бага.


на счет комита. и транзакций. как я примерно понимаю когда база делает команды из 
транзакции то она по факту неменяет нчего в базе. тоесть если мы в танзацнии в субокоманде
пишем скажем вставить такие то сроки в ттакую то таблицу то база создает какуюто
временную хрень и туда это все сует. хотя нашей транзации кажется что изменния были
сделаны именно в такойто таблице. а на самом деле создается некая временная структура из кусков
таблиц. а уже когда тнанзация дает команду коммит вот тогда база начинает реально сращивать
этот новодел с уже реаьно самой базой.


следущий режим 
read commited
он делает то что моя тразнация пока она работает она при чтении видит только те данные
которые на данный момент закомитили другие транзакциии. тоесть я на время транзааии вижу
изменния в базе , но изменения только от транзакций которые уже полностью отработали
и закомитились. а изменния от незакомченных транзаций я невижу.
тоесть
я в транз1 делаю рид из табл1
потом четото делаю
в этой время транзация2 успевает изменить таблицу1 закомититься и сдохнуть
я делаю повторный рид в моей транзации и я увижу эти изменения.
таким макром этом режим решает проблему  дерти рид.  а рипттабл рид и фантом рид
осатается.

следущий режим
repeatable read
он не видит изменения от незакочиенных транзакций поэтому он тоже решает пролблму дерти рид.
и также он невидит нон репитбл аномалии. тоесть если какая транзакция поменет контент ячееккк 
в строках и закомитить то моя транзация этго не уивдит. но все еще остаются фонтомне риды.
тоесть если какяато трназкция удалить строки ил добавит и закомитит то моя транзакция
это увидит

и вот следущий режим
serializable
в нем все три аномалии невидны. ни дертириды ни нонрипииьл риды ни фантомные риды.
по своей внешней форме сериализабл режим выглядит так что как бутто у нас база  невыполняет тран
заакции а как бутто база выпоняет только одну транзакций каждый момент времени. делает 
одну. потом берет друугую и так она их последовательно по одной выполняет.
на самом деле это нетак. это толко так внешне выглядит. потому что именно если бы база 
выпонялся строго одну транзация каждый ммоент времени то понятное дело что никакие друие
транзации в этот момент не меняли бы данные в базе и поэтому то мы и невидели 
бы ни дерти ридов ни фантом ридов ни нон рипитбл ридов. как говорят в книжках что если 
база работает в режиме сериализабл то при запуске кучуи транзакций база в конечном итоге
будет выглядеть так как буттто она выполнялся строго одну транзакцию каждый момент времени
едиснстенное что порядок их выполнения будет не такой по времени как их запулили в базу
а какойто другой переставленнный.
с практиеской точки щрения если база ралотает  в сериализабл режиме то мы точно можем
быть уверены что ни дерти ридов ни нон риптибл ридов ни фатнтомыных ридов мы несловим.
в режиме сериализибл если я прочитал какоую то таблицу и получил какието строки
то при повторных чтенияех я буду получать 100% тоже самое и посрать что в это время
были друние транзакции которые изменили эту таблицу и закомитили свои действия. 


теперь что такое режим linearizable.
честно говоря найти чтото точное и толковое на этот счет нихуя не получилось.
единсвтенное что я добился от ии это вот что.  в обычной базе которая не линеризованная
если база приняла комит от транзакции то результат фиксируется в какойто части базы
но не навсех кусках базы. поэтому получается следущая хуйня - клиент который подключен к одному
куску базы увидит результат комита а клиент который подключен к другой части базы 
(ВНИМАНИЕ) нихуя не увидит этот комит. и нужно какоето время чтобы он увидел этот комит.
тоесть скжаем база аостоит из 100 нод.  и комит сделан на ноде1. и он до сотой ноды
докатится не сразу. таким образом я в ахуе что значит комит в обычной базе.
так вот если база линеаризибл то база считет что комит был совершен только и только 
тогда когда результат транзакции комит был записан во все все все все куски базы
так что если мы сделаем запрос к этой базе из любого ее куска мы получим одно 
и тоже.




значит я еще раз хочу сказать что такое сериализбл режим на практике как он выглядит.
если я запустил траназакцию то база ведет себя для команд этой транзакции так как бутто на данный
момент только эта транзакция работет с базой и никакая другая. это приводит нас  к фундатментальному следствию о том что при запросах на чтение к базе во время выполнения
транзакции я небуду видеть измееннения  в таблицах котоыре поступили в базу врезулдбтатте
коммитов завершившихся транзаакций за это время. тоесть если моя транзакция работает 
и в это время происходят изменения в базе за счет комитов других траназакций то моя транзация
этого ничего не заметит не увидит. иначе бы это нарушало принцип о том что наши транзакции
обслуживаются базой так как бутто в каждый момент времени только одна эта транзация 
работает и только она монопольно упрлавляет базой. 
поэтому чтобы там ни комитили другие транзакции в таблицу1 если моя транзакция 
будет читать из этойтаблицы она ничего не увидит. наша транщакция во время повторных чтений
ттаблицы будет получать один и тот же результат как и в начале транзаации. и источником
измненеий в табдице для нашей транзакции может быть толкьо наша тнранзация и больше никто.
поэтому еще раз наша трнанщация во время всей транзации невидит изменния которые 
комиятят другие трнанзации. 


еще раз что такое линеаризация. во первых что такое комит. эта такая команда которая просит
то что мы наваяли во время траназции ( и при этом база как я понимаю изменения сует в какоето
временное место) записаьт эти изменения уже реально в базу. и тут тонкость.  если база 
нелинеарзованнная то она записывает изменения на ту ноду где обрабатывался этот комит. и возвращает
оюратно статус что комит сделан успешно. при этом надргуих нодах резульатт комита еще не 
долетел. поэтому при тако хуйне еси клиент сделает азпрос к базе на этой ноде то он увидит
новые данные а если он сделет на удаленной ноде то неувидит ибо нужно время чтобы туда долетело.
а если база линераищварная то она при запросе на комит вначале пропихиывает новые данные во все
свои места и толко кодга поймет что новые данные запимсаны во все места только тогда 
она возврщает статус что комит успешно прошел. и это дает то что  клиент может обращаться в любое
место бюазы на любую ноду и везде будет получать один и тот же резульатт.



интеернсный пример по сериализонванную базу.
две транзациии 1 и 2 начинают одновременно рабтать. читают одну таблицу и одну строку.
в ней данные равны изначально вася.
в транз1 стоит команда если в строке вася то замени на петю
в транз2 стоит команда если в строке вася то замени на колю

обе тразнации получили от базы инфо что в строке вася. первая меняет на петю 
вторая на колю. потом обе пыаются сделать комит. 
и база одну транзакцию заапрувит а вторую реджекнет. потому что итговый результат доложен 
быть такой как бутто транзакии работали непаалельно а последователно по одной штуке за раз.
если первая транзаи1 "отработала" бы первая. то вася стал бы петей. а если бы потом 
отработаьала бы вторая транзакция то она бы обломилась. поэтому база отреджектит.
тоесть база когда анализирует что в нее хотят комитнуть она смотрит ненарушается ли 
принцип сриализации (последователного выполенения )



так вот база ETCD она strict serialized = serialized + linearized


итак это значит что если база нам сказала что наш комит успешно прошел то это значит что 
обратившись к любой ноде базы мы прочтем одно и тоже - то что было в комите. тоесть изменение
записыется во все точки базы гарантрованно. 
и также это означает что если мы делаем транзацию то сколкьо бы мы ридов неделали на этапе транзакции ридов мы будем получать на всем времени транзации одни и теже данные. не будет
интервениций данных от других транзацкйи ни дерти ни комитнутных. не будет ни имзенения 
данных ни изменнеия числа строк. наша тарзакцния полноеценный монопльный владалец всей базы.
другое дело что если комит противорчеит сериалиазции то база его отвергнет на стадии комита.


МТ



ставим две ВМ.
на каждую в /usr/local/bin качаем бинарники отсюда
	https://github.com/etcd-io/etcd/releases/download/v3.6.4/etcd-v3.6.4-linux-amd64.tar.gz



на первой машине запускаем
/usr/local/bin/etcd \
      --name etcd1 \
      --data-dir ./etcd1 \
      --listen-client-urls http://0.0.0.0:2379  \
      --advertise-client-urls http://172.16.10.25:2379  \
      --listen-peer-urls http://0.0.0.0:2380  \
      --initial-advertise-peer-urls http://172.16.10.25:2380  \
      --initial-cluster etcd1=http://172.16.10.25:2380,etcd2=http://172.16.10.26:2380   \
      --initial-cluster-token tkn  \
      --initial-cluster-state new  \
      --log-level info  \
      --logger zap  \
      --log-outputs stderr



на второй машине запускаем
/usr/local/bin/etcd \
      --name etcd2 \
      --data-dir ./etcd2 \
      --listen-client-urls http://0.0.0.0:2379  \
      --advertise-client-urls http://172.16.10.26:2379  \
      --listen-peer-urls http://0.0.0.0:2380  \
      --initial-advertise-peer-urls http://172.16.10.26:2380  \
      --initial-cluster etcd1=http://172.16.10.25:2380,etcd2=http://172.16.10.26:2380   \
      --initial-cluster-token tkn  \
      --initial-cluster-state new  \
      --log-level info  \
      --logger zap  \
      --log-outputs stderr



потом заходим еще раз на одну из машин и проверяем что кластер 
сросся


~$   /usr/local/bin/etcdctl --endpoints='127.0.0.1:2379'  member list  -w table
+------------------+---------+-------+--------------------------+--------------------------+------------+
|        ID        | STATUS  | NAME  |        PEER ADDRS        |       CLIENT ADDRS       | IS LEARNER |
+------------------+---------+-------+--------------------------+--------------------------+------------+
| 1bb3d091cee7b172 | started | etcd2 | http://172.16.10.26:2380 | http://172.16.10.26:2379 |      false |
| 7f96ea95e27a8e1c | started | etcd1 | http://172.16.10.25:2380 | http://172.16.10.25:2379 |      false |
+------------------+---------+-------+--------------------------+--------------------------+------------+



как померить перфоманс кластера. 
тут прикол в том что etcd очень юзает диск жесткий диск для протоколирования 
транзакций


