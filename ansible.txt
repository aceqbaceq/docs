ansible

заметки

поговорим про mysql
вот мы его поставили и по дефолту у root юзера пароль пустой.
также напоминаю что у mysql доступ происходит нетолько по 
login+пароль как обычно бывает у программ а еще 
подключается фактор с какого хоста идет коннект от клиента
тоесть у mysql авторизация идет на основе
login+пароль+хост с которого звонят

поэтому в базе mysql логин как бы выглядит в виде

root@hostname пароль

так вот для после установки mysql пароль для

root@localhost
root@127.0.0.1

он пустой.

тоесть зайдя на хост с mysql в него можно войти как

# mysql -u root

все пароль ненужен.


так вот переходим  к сути .
мы хотим через ансибл поменять пароль для root@hostname

а именно для

root@localhost
root@127.0.0.1
root@::1

для этого мы пишем кусок ансибл кода



  - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       when: root_pass.changed


так вот этот код несработает. и я щас обьясню почему.
собсвтенно весь этот кусок текста посвящен тому чтобы обьяснить почему
он не сработает. точнее он сработает частично и вылетит с ошибкой

во первых проясню поля

name:
password:
host:

это не логин и пароль под которым ансибл стучит на mysql чтобы получить
к нему доступ. для этого у модуля mysql_user есть другие поля такие как
login_user
login_password
login_host

так как мы их неуказали в mysql_user то по умолчанию как я понял ансибл
примает по дефолту что

login_user=root
login_password=пусто
login_host=localhost

а поля
name:
password:
host:

прописывают совершенно другое , они используются недля аутентификации
а указывают что менять в базе после того как мы к ней подключились.


так как изначаьно mysql нетребует пароля для root@localhost
то 

так вот кусок ансибля наверху он будет пытаться поменят пароль для

root@localhost
root@::1
root@"{{ inventory_hostname }}"
root@127.0.0.1

при этом он будет подлючаться к базе используя login_user=root, login_host=localhost и пустой пароль. 

значит как mysql_user модуль  будет действовать,
1. он попыватется подлючиться к базе без пароля и у него
это получится и далее он поменяет пароль для 

root@localhost

это все пока успешно.

далее как я понимаю либо ансибл отключается от базы либо база сама выкиывает ансибл от себя так как пароль для root@localhost стал непустым.
в любом случае 

на втором шаге ансибл опять пытается подключиться к базе без пароля 
тоесть как 

login_user=root
login_password=пусто
login_host=localhost

и ОПА! у него больше это неполуится так как не предыдущем шаге мы сами установили непустой пароль для root@localhost. ВСЕ! ансибль больше неможет
подлкючться к базе и делать дальнейшие изменения какие бы то ни было.

вот поэтому кусок кода вверху он вылетит с ошибкой.

так  что в частности работа с with_items это когда ансибл делает последовательно одно тоже но шаг с шагом. напервом шаге берет первое значение и прогоняет , потом второе и прогоняет тоже самое то есть with_items это классической цикл.

тоесть mysql_user в связке с with_items он не применить одну какую то мегакоманду которая за одну mysql транзакцию единовременно изменит сразу 
несколько ячеек в базе mysql. нет такого небудет. 
за первуб транзакцию к mysql изменится одна ячейка root@localhost
потом начнется вторая транзакция за которую должна была быть измнена ячейка root@::1 и так далее.

таким образом как конкрентно работает ансибл с with_items разобрались.
как классический цикл. берет первое значение и делает то что с ним сказано, потом берет второе значение и делает то что сказано. потом третье. а не так что берет сразу первое второе и третье и делает единровременно с ними мегатранзакцию.


про механизм обработки ансиблем with_items разобрались.

возврашается к изначальной задаче. так как же ее сделать.

ответ вот как.


в два прхода

за первый проход мы обращается к базе без пароля
и меняем пароль для root@localhost

  - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
       when: root_pass.changed


теперьмы к базе по старому без пароля подключиться неможем.
потому что локальный питон скрипт крутится на хосте с mysql и поэтому он обращается от имени root@localhost

значит на следующем щаге нам нужно стучаться к базе используя пароль.

это можно сделать двумя путями.
либо в mysql_user модуле прописать 
login_user=root
login_password=пароль
login_host=localhost

либо можно на хосте где крутится mysql записать файл /root/.my.cnf 
вот такого вида

[client]
user=root
password=пароль

и тогда в mysql_user модуле можно не прописывать login_user, login_passwrd,login_host потому что этот модуль он по умолчанию ищет
~/.my.cnf и если его находит то читает креды оттуда

так что финальный кусок когда выглядит так


# обращаемся к базе без пароля и меняем его толко для root@localhost
 - name: mysql change root@localhost password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
            - localhost
       register: root_pass

# записываем .my.cnf
     - name: save  .my.cnf on remote host
       template:
         src: templates/mysql/my.cnf
         dest: /root/.my.cnf
       when: root_pass.changed


# меняем пароль для остальных 
# 	root@::1
# 	root@"{{ inventory_hostname }}"
# 	root@127.0.0.1 , 
# модуль при автоматом читает .my.cnf 
# и обращется к базе уже через пароль
     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       when: root_pass.changed

также может возникнуть хитрожопая мысль. а может нам надо 
просто хитро перегруппировать 

            - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1


вот эти вот штуки чтобы все таки можно было все сделать за один раз. 
например вот так

            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
            - localhost


у меня не сработало.
как только система установила пароль для root@127.0.0.1
то она уже немогла подключиться к базе без пароля 
такое ощущение что для mysql root@localhost эквивалентен root@127.0.0.1
поэтому меняя пароль для одного автоматом ты его установил и для другого.

в одной умной книге по ансибл этот тонкий момент 
вообще нифига не освящен а указано что якобы можно все сделать за один 
проход.


конец.

---

ansible стоит на yaml

в yaml есть типы данных
dictionary
и  mapping

dictionary
это

- 1
- 2
- 3

mapping 
это
a: 1
b: 2

так вот нам надо уметь получать доступ к элементам этих штук
например 

имеем вот такую переменную


 var1:
         a: 1
         b: 2
         c:
           - a
           - b
           -
             elk: stack
             abc: d


так вот. если мы хотим получить доступ к элементу маппинга
то ставим точку и пишем имя маппинга

var1.a = 1
var1.b = 2
var1.c = [ a, b, { elk: stack, abc: d ]


НО! такой фокус непрокатывает когда мы хотим получить доступ 
к элементу dictionary
как я понял тут только прокатывает доступ через порядковый номер

var1.c.0 = a
var1.c.1 = b
var1.c.2 =  { elk: 'stack', 'abc': 'd'}"

ну и последний пример

var1.c.2.elk= stack

значит если мы где то видим обращение к переменной вот такого вида

a.b

это значит что переменная а содержит маппинг вида

a:
  xxx:yyy
  b: ...
  zzz: uuu
  
а если мы видим переменную вот такого вида

a.0

это значит что переменная a имеет вот такой вид

a:
   - ...
   - .....
   - .......
   
   
   
 вот еще переменная a имеет вот такой вид
 
 

changed: false

msg: "u'All items completed'"

results: 
  - 
    ansible_loop_var: u'item'
    failed: false
    item: u'localhost'
    u'changed': false
    u'invocation': 
      u'module_args': 
        u'append_privs': false
        u'ca_cert': None
        u'check_implicit_admin': false
        u'client_cert': None
        u'client_key': None
        u'config_file': u'/root/.my.cnf'
        u'connect_timeout': 30
        u'encrypted': false
        u'host': u'localhost'
        u'host_all': false
        u'login_host': u'localhost'
        u'login_password': None
        u'login_port': 3306
        u'login_unix_socket': u'/var/run/mysqld/mysqld.sock'
        u'login_user': None
        u'name': u'root'
        u'password': u'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
        u'priv': None
        u'sql_log_bin': true
        u'state': u'present'
        u'update_password': u'always'
        u'user': u'root'
    u'msg': "u'User unchanged'"
    u'user': u'root'

warnings: 
  - "u'Module did not set no_log for update_password'"
  
  
  
  
 тогда мы можем получить доступ к ее элементам в таком виде
 
 a.changed
 a.message
 a.results
 a.results.0.ansible_loop_var
 
 
===

подлянки ansible

модуль unarchive

- name: Extract  
  unarchive:
    src: 1.tar.gz
    dest: /var/lib/vasya
	
если dest папка несуществует тогда модуль несможет разархивировать
и будет выдавать такую тупую ошибку


"/bin/gtar\" could not handle archive. 
Command \"/usr/bin/unzip\" could not handle archive."


еще раз скажу причина совсем вдругом. несуществует dest папки.  а
без этого модуль неможет.
нужно создать dest папку и все сразу станет отлично

==

модуль file

- name: create nginx directory
  file:
    path:  "{{ wp_docroot }}"
    state: directory
    owner: "{{ wp_owner }}"
    group: "{{ wp_group }}"
    mode: 0775

если переменная wp_docroot имеет такой вид:

doc_root: " /1/2/3 "

то есть в ней есть пробел  в конце и вначале
то модуль file напишет что он все сделал но по указанному 
пути папку НЕСОЗДАСТ.

как исправить. надо исправить переменную , убрать пробелы

doc_root: "/1/2/3"

вот теперь модуль file отработает нормально

==

