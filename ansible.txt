ansible

заметки


=========
про установку ансибля.
его можно поставит через apt-get install
можно через ppa
а можно через pip\pip3

так вот отдельно поговорим про установку ансибля через pip\pip3 в файле python.txt

=========
про то как работает ансибл. смотри ansible-archit.txt
=========
про переменные:

они бывают разных типов. и их можно хранить\совать\обьявлять в разных 
местах.

их можно обьявлять в инвентори файле\файлах, в ее подпапке group_vars\host_vars,
в плейбуке, в ролях.

так какие и куда совать?

в inventory папке должны (помимо спимска хостов) храниться ровно те переменные
которые относятся к свойствам самих хостов.
а переменные которые относятся к свойствам плейбуков недолжны там храниться
а дрожны хранитться в плейбуках.
с другой стороны в плейбуках недолжны храниться перменные которые оттностся к свойствам
хостов.
 а в ролях должны храниться дефолтовые переменные на случай если их забыли указать
 в плейбуке
еще правило переменные которые в плейбуке надо выносить из тела плейбука
в отдельный ini file. а из плейбука их считывать сканирываем через lookup
потому что одни и теже переменные могу быть нужны в разных плйбуках. 
поэтому заебешься их править сразу в нескольких плейбуках. а коогда 
переенная забита в ini файл то тогда ты правишь ее в одном файле и автомтаом 
все плейбуки увидят новое значение.
а если у нас несколько плейбуков исполщуют точно таекой же набор переменных то удобнне
тогда завести отедьный var file но в формате yuml

  vars_files:
       - vars/vars.yml

и вставить эту строку в плейбуки. потому что добавение новой переменнйо
тогда удобно делать в этот файл. тогда в во всех плейбуках она сразу повитися


===============

как проще всего установить самоый последний ансибль внезавимости 
какое deb пакет есть в репозитории текущего дистрибутива потому что пакет там
может быть старый а хочется иметь последний ансибль

решение
через ppa


$ sudo add-apt-repository --yes --update ppa:ansible/ansible
$ sudo apt-get update
$ sudo apt-get install ansible
=====================================

далее:

вот эта переменная 

ansible_ssh_common_args: '-o StrictHostKeyChecking=no'

позволяет то что при убиении и создании заново VM ансибль неругается на то что
он неможет приконектиться к VM потому что у нее изменился ssh key.
для тестовой среды на вагранте это самое то что нужно.

пихать ключ лучше всего в group_vars/all

$ cat ./inventory/group_vars/all

ansible_ssh_common_args: '-o StrictHostKeyChecking=no'

============
далее:

такой момент 
хотим чтобы name в таске был многострочный красивый при выводе на экран.
например вот такой

- name:
     - change mysql password for
     - root@'::1'
     - root@"{{ inventory_hostname }}"
     - root@'127.0.0.1'
     - root@'localhost'
  mysql_user:

однако ансибл недает ругается и пишет что

ERROR! The field 'name' is supposed to be a string type

так что облом.

максимум можнро записать вот так

- name: change mysql password for
     root@'::1'
     root@"{{ inventory_hostname }}"
     root@'127.0.0.1'
     root@'localhost'
  mysql_user:

 а на экране оно будет в одну строку вот так
 
 TASK [db.local : change mysql password for root@'::1' root@"machine2" root@'127.0.0.1' root@'localhost'] ***


===============
далее:

еще прикол

- name: change mysql password for  root@'{{ inventory_hostname }}'

даже одинакрные кавычки неэкранируют то что внутри.
поэтому на экране будет вывеено значение переменной.
как полностью закэкроанировать непонятно.

в иттге пришлось пока ростановиться на варианте

- name: change mysql password for  root@'{ inventory_hostname }'


====================================
далее:
поговорим про MYSQL
многострадальная тема

после установки мускула у него дефолтный логин\пароль на вход=root\пусто

мы хотим это поменять.


тут еще надо сказать что вход в мускул регулируется нетолько по логину\паролю
но и по dns имени сервера (внимание) с которого стучит клиент. у мускула этот параметр
называется hostname в книжках.
тоесть важно нетолько  с каким логином паролем ты ломишься на мускул но и с какого 
сервера ты на него стучишь. мускул берет src_IP клиента. лезет в DNS пытается там это 
зарезолвить в DNS имя. если это ему неудается то мускул считает что hostname=ip адресу.

в таблице доступа в одной строку мускул хранит:
логин, пароль, hostname, степент доступа к базам и таблицам.

если логин один и тотже а hostname разные то в таблице доступа эти записи 
занимают отдельные строчки.

вот пример:



mysql> use mysql;
mysql> select  user,host,authentication_string from user where user='root';
+------+-----------+-------------------------------------------+
| user | host      | authentication_string                     |
+------+-----------+-------------------------------------------+
| root | localhost | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
| root | 127.0.0.1 | *908BE2B7EB7D7567F7FF98716850F59BA69AA9DB |
| root | ::1       | *7534F9EAEE5B69A586D1E9C1ACE3E3F9F6FCC446 |
| root | machine2  | *7534F9EAEE5B69A586D1E9C1ACE3E3F9F6FCC446 |
+------+-----------+-------------------------------------------+


юзер один, хостнеймы разные. и поэтому строки разные.
также замечу что в этой таблице нет столбца password
вместо нее authentication_string 


нахрена такой разбор. потому что если ломишься по вроде верному логину паролю
но мускл непускает значит надо четко понимать где могло сломаться.
значит если неработает то надо четко понимать в какой hostname мускул резолвит IP компа 
с которого стучишь на мускул.

скажу сразу что если стучишь на мускул стого же компа где мускул крутится то 
мускул резолвит хостнейм такого клиента в 'localhost' (а не в 127.0.0.1 к примеру)
так что за доступ к мускулу локально ответчает строка в таблице

+------+-----------+-------------------------------------------+
| user | host      | authentication_string                     |
+------+-----------+-------------------------------------------+
| root | localhost | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
+------+-----------+-------------------------------------------+

очевидно что для разных hostname могут быть соврешенно индивидуальные пароли.

также отсюда следует что параметр --host при входу на мускул через консольный клиент
задает не хостнейм клиента а задает хостнейм сервера на который клиент хочет стучать.
тоесть это совершенно разные хостнеймы.

также если мы стучим клиентом и неуказыаем логин и пароль или неуказвыаем пароль 
а только логин то клиент ищет файл в ~/.my.cnf в котором это может быть прописано.
отсюда тоже вытекает важное следствие. вот мы зашли на сервер 

$

далее мы ввели команду

$ sudo bash
#

мы знаем что там есть файл  /root/.my.cnf и в нем указан правльный логин\пароль

мы вводим

# mysql 

но получаем от мускула отлуп. почему? ведь все верно.

потому что команда $ sudo bash она переключает на рута но переменна $HOME остается
равной папке непривилигированная юзера условно говоря $HOME=/home/vasya/
поэтому mysql ищет .my.cnf не в /root а в /home/vasya

чтобы при переключении на рута и домашняя папка переключилась на /root надо юзать

$ sudo -i bash

тогда $HOME=/root

вот такие все тонкости надо понимать чтобы успешно входить на мускул.

также надо понимать что если мы поменяли  в таблице доступа мускула пароль для

root@'127.0.0.1' то это никак неизменило\неповлияло на вход на пароль для
root@'localhost'

к чему я это говорю. возвращаясь к исходной задаче мы поставили мускул.
новый мускул в таблице доступа содержит для root только вот такие строки 
доступа

mysql> use mysql;
mysql> select  user,host,authentication_string from user where user='root';
+------+-----------+-----------------------+
| user | host      | authentication_string |
+------+-----------+-----------------------+
| root | localhost |                       |
+------+-----------+-----------------------+

тоесть доступ к мускулу разрешен только с 'localhost'  для root и больше нискакого сервера
и пароль пустой.

сразу скажу что поразительно. во первых понятно что пользователи прописанные в таблице
мускула это совершенно разные пользователи от тех что прорписаны в самом линуксе, 
они неимеют друнг к другу никакого отношения. root мускула неимеет никакого отношения
к руту линукса. так вот что странно. если мы постучим на мускул из баш сесии обычного
линукс юзера нерута хоотя в сам мускул мы пытваемся попасть под рутом

$ id
vagrant

$ mysql -u root

то мускул нам непустит.

а если мы перейдем в баш сессию под линукс рутом и постучим в мускул под мускул рутом
то он пустит

# id
root

# mysql -u root
mysql > 

это непонятно. какое отношение имеет линукс бащ юзер к мускул юзеру.
однако это имеет место когда мы только поставили мускул.
далее когда мы установим пароль для мускул рута то это уже будет неважно. это прекратит
так быть. когда мускул рут юзер получит пароль (потому что сразу после установки мускул
рут юзер неимеет пароля) то мускул будет пускать по логину паролю уже и из баш рут 
сесии и из баш нерут сессии.



а мы хотим прописать на мускуле доступ для следущих конекшн стрингов:


        - localhost
        - ::1
        - "{{ inventory_hostname }}"
        - 127.0.0.1


"{{ inventory_hostname }}" = это хостнейм сервера с которого мы запускаем ансибл плейбук
через переменную ансибля (ибо да мы будем менять конекшн стринги на мускуле через ансибл)


когда мы тока поставили мускул никаких .my.cnf ни вкаких папках нет.
что странно что вход на мускул из под баш сессии непривилигированного пользователя
почемуто неработает, пошлет нахер

$ mysql -u root 

а сработает только вход из под баш сессии рута

# mysql -u root

хотя какая разница мускулу под каким линукс юзером мы сидим на своем сервере 
если его мускульный юзер это совершенно другая сущность.

Еще важный момент про хостнейм клиента. на мускул можно стучать через TCP\IP сокет
(что тривиально и понятно) а можно стучать через юникс сокет в случае когда 
мы входим прям с того сервера где и сам мускул крутится. так вот что непонятно
так это как при этом мускул определяет DNS имя клиента , ведь для этого нужен IP клиента
а какой нафиг у клиента src IP может быть если клиент неиспользует tcp\ip проотокол
а входит через юникс сокет. непонятно. но проверка на практике показал что в этом случае 
у клиента hostname=localhost по мнению мускула.

вот сколько тонкостей и подводных подлянок по поводу процесса логина на мускул.

так я возвращаюсь к нашей задаче. мы хотим для рута добавить\поменять конекшн стринги 
для хостнеймов

		- localhost
        - ::1
        - "{{ inventory_hostname }}"
        - 127.0.0.1

для этого мы заюзаем такой кусок кода (наконец то дошли до ансибл)


     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
		  state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       

щас мы разберем подводные камни использования этого куска кода.
модуль mysql_user позволяет подключаться через питон клиент к мускулу 
и менять у него конекшн стринги.
чтобы этот модуль успешно отработал надо чтобы на сервере мускула был установлен 
питон клиент для мускула. это таакие пакеты как:

        - python-mysqldb
        - python3-mysqldb
  
строка 
	login_unix_socket: /var/run/mysqld/mysqld.sock
говорит модулю что стучаться на мускул надо нечерез tcp\ip сокет а через юникс сокет.
почему так. с одной стороны у меня были какието проблемы с последними версиями мускула
когда я стучался на него через tcp\ip сокет а через юникс сокет таких проблем нет.
и второе раз уж мы запускаем клиент на том же сервере что и мускул то логично юзать
юникс сокет ибо и клиент и сервер сидят на одном сервере. нафиг им этот tcp\ip

вот эти строк

          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
они неимеют отношения к логину паролю на коннект от питон клиента к мускулу. ведь 
прежде чем что то менять в мускуле надо еще к нему подключиться. так вот эти строки 
они не про подключение нашего ансибль\питон клиента к мускулу. за это отвечают
другие строки такие как

	     login_password: "1 "
	     login_user: root
	     login_host: localhost
 

которых мы невидит в нашем коде. а почему. а потому что если мы их неуказали то 
mysql_user модуль заюзает по умолчанию 


	     login_user: root
	     login_password: пусто
	     login_host: localhost
		 
а ведь ровно такие креды и есть когда мы тока установили мускул. 
поэтому такой фокус прокатывает.
единсвтенное что непонятно какой смысл имеет строка login_host:, потому что это не клиент
ее подсовывает мускулу а мускул сам определяет ее на основе IP клиента и обращения к DNS
серверу. ну да ладно.

итак после установки мускула такой фокус прокатит. но если мы поменяем пароль для
root@'localhost' то верхний код уже несработает потому что пароль к рут стал непустой.
как это обойти будет дальше.

так что же значат тогда строки

          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
а они значат то что когда мы подконектились к мускулу то он ищет для добавления либо 
модификации указаннвый в этих строках конекшн стринг. вот что значат эти строки.

еще важный момент. mysql_user модуль он ищет  ~/.my.cnf и если находит то 
ищет там логин и пароль на вход в мускул. 
возникает вопрос а что превалирует логин пароль на вход на мускул указанный вот здесь

	     login_user: root
	     login_password: пусто
	     login_host: localhost
	
или то что указано в ~/.my.cnf
ответ превалируют 	

	     login_user: root
	     login_password: пусто
	     login_host: localhost
	

еще тут важно понимать что в зависимости от под каким юзером ансибл зашел по ssh на сервер
будет разная папка для ~/.my.cnf

если у нас ansible_user=vagrant то ~/.my.cnf будет искать в /home/vagrant
а если к примеру помимо этого у нас прописано become=yes тогда .my.cnf будет
искаться в /root потому что питон скрипт ансиблевский будет исполнться от рута.

вот такие подлянки на которые можно попасть.
тоесть все вот это надо понимать чтобы код отработал успешно или если он неработает
то где искать причины.

возвращаемся опять к коду

     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
		  state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       
если все остальное правильно этот код неотработает. почему. потому что :
как работает with_items это полный аналог цикла for.
возьмется первое верхнее значение localhost и запустится mysql_user.
.my.cnf файла на сервере у нас нет, также строки

	     login_user: root
	     login_password: пароль
	     login_host: localhost
	
у нас в коде непрописаны. поэтому mysql_user полезет на мускул с дефолтными кредами
root@'localhost' пароль пустой. и успешно войдет и поменяет конекшн стринг для
root@'localhost' пароль установит {{ var1 }}

после этого mysql_user закончит свою работу и дисконектится от мускула.
пока что все хорошо. но вот дальше все уже плохо.

дальше with_items берет следующее значение ::1 и вызывает mysql_user,
модуль как и прежде лезет на мускул с кредами root@'localhost' пароль=пусто
но пароль то уже непустой мы на предыдущем шаге его поменяли. поэтому ансибль останавливатеся
и пишет что ошибка.
и это все теперь понятно и логично.  но это можно все исправить.
надо достаточно поменять порядок строк в with_items чтобы пароль для localhost менялся
самым последним


     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
		  state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
            - localhost
      

тогда первые три прохода для with_items мы успешно входим под пустым паролем.
меняем конекшн стринги но это никак невлияет на нашего клиента который каждый раз
входит из под localhost
и на четвертом шаге мы меняем уже пароль для localhost но это для нас  уже неимеет 
значения ибо модуль закончит работу.

ественно что если мы намудили с порядком строк в with_items то чтобы модуль полностью 
отработал надо либо переставить мускул, либо зайти на него руками и руками стереть пароль
для localhost.

вот какая огромная куча подводных камней в вопросе входа на мускул и  в вопросе 
смены конекшн стрингов на нем. чуть где какая ошибка и на мускул уже незайти.

как выглядит ~/.my.cnf

[client]
user=root
password=пароль



если мы чтото намудили и неможем войти на мускул. то надо стопить сервис мускула
и входит в него в режиме когда он разрешает вход без аутентификации и разбираться.
как это сделать:

стопим службу
# service mysql stop

дальше
# mysqld_safe --skip-grant-tables &

дальше
# mysql

дальше
mysql> UPDATE mysql.user SET Password=password('NEWSTRONGPASSWORD') WHERE User='root';
mysql> FLUSH PRIVILEGES;
mysql> exit;

запускаем сервис мускула проверяем

# service mysql start
# mysql -u root -p


соотвественно когда наш код отработает даже целиком его повторно запустить уже
неполучится. потому что как ни крути пароль для root@'localhost' поменялся.
а модуль будет как и прежде стучаться через пустой пароль.

соотсвтенно нужно скопировать .my.cnf с новым паролем на сервер в /root/.my.cnf
 (если мы используем become:yes)
тогда mysql_user при повторном запуске плейбука будем искать .my.cnf находить его 
и юзать обновленный пароль оттуда для входа на мускул

итого вот финальный код


- name: change mysql password for
          root@'::1'
          root@'{ inventory_hostname }'
          root@'127.0.0.1'
          root@'localhost'
  mysql_user:
     name: root
     password: "{{ mysql_root_pass }}"
     host: "{{ item }}"
     login_unix_socket: /run/mysqld/mysqld.sock
#     login_password: "1 "
#     login_user: root
#     login_host: localhost
  with_items:
     - '::1'
     - "{{ inventory_hostname }}"
     - '127.0.0.1'
     - localhost
  no_log: true
  ignore_errors: false
  tags:
     - 'change pass'

- name: copy .my.cnf
  template:
       src: my.cnf.yml
       dest: /root/.my.cnf
  tags:
     - 'change pass'

 

все в этом коде выстрадано. и обьясненено. 
только еще скажу про строчку

	  no_log: true
	  
если ее нет то ансибл будет ругаться что мол в логах ансибля можно подсмотреть пароль
который мы пихаем на мускул а это мол небезопасно. данная опция делает то что
в логах ансибля пароль будет невидим.
тэги добавлены просто для удобства.


еще какие ошибки я напарывался когда делал код:
вот эта вот строка

password: "{{ mysql_root_pass }}"

я вставил пробел ненужный вот так

password: "{{ mysql_root_pass }} "

в итоге у меня в базу записывался пароль с лишним пробемло на конце. а я потом
немог понять почему пароль навход неподходит.

также еще раз хочу обратить внимание на то что питон скрипт ансибля на сервере
исполняется под рутом если у нас использутеся в плейбуке опция become:yes
поэтому .my.cnf нужно копировать в /root/.my.cnf 
а не в /home/vagrant

опятьже отходя в сторону если мы по какимто причинам копируем .my.cnf  в /home/vagrant
то нужно оследить чтобы файл там получил правильные пермишнсы чтобы владельцем был
vagrant.vagrant а не root.root

также остался непроверенным момент. скажем у нас глобально обьявлен become:yes
скажем мы это прописали в ./inventory/group_vars/all
и в тоже время в модуле мы локально указываем
become:no
вопрос что сильнее в этом модуле окажется. непроверял.

далее. значение в переменной которая хранит новый пароль лучше взять в кавычки
на случай там спецсимволов, чтобы небыло неожиданных приколов. даже исходя из того чтобы 
неналепить в конце пароля невидимых лишних пробелов.

mysql_root_pass: '123'

и наконец ссылка на полный плейбук

https://github.com/aceqbaceq/ansible/tree/master/mysql


============================================

такой момент.

в ансибле можно запускать таски только с определенным тэгом
пример

$ ansible-playbook -i ./inventory test.yml -t 'имя тэга'

а можно наоборот запускать все таски кроме тасков с тэгом.
и порой это очень тоже удобно.
пример

$ ansible-playbook -i ./inventory test.yml --skip-tags'имя тэга'

может быть даже несколько тэгов одновременно можно использовать.

================================================
===============
далее:

ansible стоит на yaml

в yaml есть типы данных
dictionary
и  mapping

dictionary
это

- 1
- 2
- 3

mapping 
это
a: 1
b: 2

так вот нам надо уметь получать доступ к элементам этих штук
например 

имеем вот такую переменную


 var1:
         a: 1
         b: 2
         c:
           - a
           - b
           -
             elk: stack
             abc: d


так вот. если мы хотим получить доступ к элементу маппинга
то ставим точку и пишем имя маппинга

var1.a = 1
var1.b = 2
var1.c = [ a, b, { elk: stack, abc: d ]


НО! такой фокус непрокатывает когда мы хотим получить доступ 
к элементу dictionary
как я понял тут только прокатывает доступ через порядковый номер

var1.c.0 = a
var1.c.1 = b
var1.c.2 =  { elk: 'stack', 'abc': 'd'}"

ну и последний пример

var1.c.2.elk= stack

значит если мы где то видим обращение к переменной вот такого вида

a.b

это значит что переменная а содержит маппинг вида

a:
  xxx:yyy
  b: ...
  zzz: uuu
  
а если мы видим переменную вот такого вида

a.0

это значит что переменная a имеет вот такой вид

a:
   - ...
   - .....
   - .......
   
   
   
 вот еще переменная a имеет вот такой вид
 
 

changed: false

msg: "u'All items completed'"

results: 
  - 
    ansible_loop_var: u'item'
    failed: false
    item: u'localhost'
    u'changed': false
    u'invocation': 
      u'module_args': 
        u'append_privs': false
        u'ca_cert': None
        u'check_implicit_admin': false
        u'client_cert': None
        u'client_key': None
        u'config_file': u'/root/.my.cnf'
        u'connect_timeout': 30
        u'encrypted': false
        u'host': u'localhost'
        u'host_all': false
        u'login_host': u'localhost'
        u'login_password': None
        u'login_port': 3306
        u'login_unix_socket': u'/var/run/mysqld/mysqld.sock'
        u'login_user': None
        u'name': u'root'
        u'password': u'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
        u'priv': None
        u'sql_log_bin': true
        u'state': u'present'
        u'update_password': u'always'
        u'user': u'root'
    u'msg': "u'User unchanged'"
    u'user': u'root'

warnings: 
  - "u'Module did not set no_log for update_password'"
  
  
  
  
 тогда мы можем получить доступ к ее элементам в таком виде
 
 a.changed
 a.message
 a.results
 a.results.0.ansible_loop_var
 
 
=================
далее:

подлянки ansible

модуль unarchive

- name: Extract  
  unarchive:
    src: 1.tar.gz
    dest: /var/lib/vasya
	
если dest папка несуществует тогда модуль несможет разархивировать
и будет выдавать такую тупую ошибку


"/bin/gtar\" could not handle archive. 
Command \"/usr/bin/unzip\" could not handle archive."


еще раз скажу причина совсем вдругом. несуществует dest папки.  а
без этого модуль неможет.
нужно создать dest папку и все сразу станет отлично

===================
далее:

модуль file

- name: create nginx directory
  file:
    path:  "{{ wp_docroot }}"
    state: directory
    owner: "{{ wp_owner }}"
    group: "{{ wp_group }}"
    mode: 0775

если переменная wp_docroot имеет такой вид:

doc_root: " /1/2/3 "

то есть в ней есть пробел  в конце и вначале
то модуль file напишет что он все сделал но по указанному 
пути папку НЕСОЗДАСТ.

как исправить. надо исправить переменную , убрать пробелы

doc_root: "/1/2/3"

вот теперь модуль file отработает нормально

=======================
далее:

в ансибль есть такая тема мудотная со скобочками.

сразу скажу что часть мыслй здесь неверная. 
верные мысли уже пришли позже внизу начиная со слов "нам необязательно использовать with_items"

тем не менее:
скобочками обозначаются переменные а еще dictionary и lists.

щас  я покажу как через скобки все эти штуки обозначаются.

но перед этим  типа ты спросишь а какая разница между переменной и dictionary

разве dictionary\lists это неразновидность переменной ? ведь и дикшонари и лист могут являться переменной.

захера их тогда по разному обозначать?

а еще у нас есть loops. их к чему отнести  - это  переменные, дикшнари или это списки ?

и как это все к скобкам возвращается в итоге ?

начнем :

в целом в ансибль мудота.

я бы сказал что такие структуры как dictionary и lists это несамостоятельные структуры в ансибль, они всегда являются частью 
чего-то. тоесть когда ты слышишь слово dictionary или list то этого недостаточно, это неговорит о назначении их применения. обьясняю.
в ансибль есть директивы , команды а есть данные. так вот dictionary 
и list они могут применяться как составная часть диркетив так и составная
часть данных. поэтому когда ты слышишь dictionary или list этого недостаточно, ты незнаешь идет ли речь о кусочке директивы или о 
кусочке данных.

это как например мороженое было бы нетолько еда а еще и стройматериал и часть животного. но нет. когда мы слышим мороженое то знаем что оно только еда и только еда. 

пример когда dictionary является частью ансиблбь команды, ансибль диркетивы

  debug:
      msg: "12"
	  
 в этом примере показана диркетива ансибля debug. dictionary является составной частью директивы. 
 
 еще пример
 
 vars:
    a: 1

в этом примере dictionary является частью некоманды а переменной.

таким образом dictionary и аналогично list помогают организоват совершенно разные структуры , как команды так и данные. а это совершенно разные веши.

получается дикшонари или список это кусок кода в общем и целом неизвестно что обозначающий но оформленный по орпделенному синтаксическому
правилу.

для словаря это правидло выгдядит как

a: значение-1
b: значение-2

значение может быть сложное выражение

список выглядит при оформлении как

- значение-1
- значение-2

значение может быть сложное выражение


возврашаемся к скобкам. 
словари и списки могут иметь бесскобочный вид. но всегда их можно преобразовать в экивалентный но вид скобочный. 
каждый дикшонари всегда можно преобразовать  его обозначение через { } скобки.

a: 1
b: 2

этот дикшонари имеет эквивалент обозначение через скобочный вид

{ a: 1, b: 2 }


каждый список подразумевает что его можно изобразить через скобочный вид.
используется [ ] скобки

- 1
- 2
- 3

имеет эквивалентный скобочный вид

[ 1, 2, 3 ]



скобочный вид и нескобочный они эквиваленты. просто когда то удобно 
внешне применить один а когда то другой. а так они равнозначны для машины.


ансибль использует эти синтаксические структуры для выражения своих команд\директив  а также для выражения своих данных.


- name: task 1
  debug:
      msg: "1"
	  
эта хрень напечатает "1" на экране. тоесть эта штука в целом это директива ансибля. его команда. в своем оформлении она выражена
через структуру список со сложным значением.


приведем это к скобочному виду

[ { name: task 1, debug: { msg: "1" } } ]

таким образом ансибливские команды используют списки и дикшонари 
как свои составляющие части как кирпичи.

но помимо использования словарей и списков как часть синтаксиса команд
они также юзаются для организации переменных тоесть данных. команды и переменные разные вещи

vars:
 a:1
 b:2
 c:
   - 1
   - 2
   
 
 в данном случае списки и словари используются не для организации команд
 а организации данных  , создания переменных.

таким образом когда мы слышим или видим что в куске ансибль файла встретился дикшонри или список то нам это ничего не говорит. участвует ли он в опписании команды или в создании переменной.

однако скобочки позволяют однозначно сказать внутри нее содержится списк или словарь.

[ ] = список
{ } = словарь

как выглядит конкретная команда в ансибль какие конкретно на содедржит комбинации списков и словарей зависиит от создателей команды.

при создании переменной мы можем внутрть нее напихать список или словарь любой сложности и вида. это уже зависит от нас.

так вот далее. некоторые команды позволяют внутри себя вставлять внутрь них переменные которые мы ранее определили тоесть другими словами вставлять данные. и тут важно понять что 
не все команды позволяют внутрь себя вставлять данные и эти данные вставляются в виде переменных, причем какая то команда принимает переменную только типа словарь а другая только типа список. 
таким образом важно понять 
а) не все команды позволяют вставлят в себя данные
б) данные втсвляются только через переменные а не голые списки и словари
в) команды обычно четко прорписыавет какого вида может быть переменная
внутри нее это либо только список либо тлько переменная.

как выглядит обьявление переменной мы уже видели

vars:
  a: 1
  b: { c: 3, d: 5 }
  
 а сейчас скажу как выглядит обращение к переменной внутри некоторой команды для примера
 
 debug:
    msg: "{{ a }}"
	
таким образом мы видим что переменная вызываетс через двойные скобки {{ }}
и только если комарнда поддерживает в соотствующем месте внутри себя
подстановку вместо значения переменной. причем перменная дожна иметь 
заранее определенный тип, либо словарь , либо спмсок.
нельзя в команду всавить переменную типа словарь если команда прддерживает  только тип список.

каки-то конмады поддеживают перменные обоих типов.

например команда debug

вот я определил три переменные

  vars:
     petya: mc

     vasya:
        name:  apache2
        state: latest

     masha:
         - 1
         - 2



и далее хотя они разного типа я могу их все распечатать командой debug

    - name: phase 0
       debug:
          msg: "{{ masha }}"


конкретно команде debug пофиг какого типа переменная. но другим командам нет в целом.


сущестенно то что вместо значения для подставновки данных мы 
используем переменную которую опредлили раньше.

 еще раз разница между переменной и словарь\список. 
 словарь и список они исопльзуются как его части при обьявлении переменной. переменная имеет имя. а например тот же самый список неимеет имени. 
 
 про перменную еще скажу важное когда мы ее вызываем через двойные скобки {{ имя }} то всегда надо ее брать еще и в двойные кавычки
 
 "{{ имя }}" потому что ансибль опирается на yaml интерпретор ( тот отрабатыавает первее ) а yaml интерпретатор ничего знает о синтаксисе кроме как для него весь текст это набор словарей и списков не более того 
 если он встречает в тексте скобки { или [ то он тогда считает что начинается словарь или список. поэтому чтобы заставить ямль интрепретор 
 условно говоря рассматривать {{ имя }} не как словарь внутри которого словарь условно говоря а набор литер то есть экранировать мы берем 
 {{ }} в кавычки. "{{ }}"
 
еще раз это так как ямль обрабыает текст первым и тлько потом его обрабатыавает ансибль интерпретоор. то надо заэкранировать кавычки потому что тогда ямль будет думать что он напоролся на словарь. короче неудачно выбраны символя для обозначения переменных в ансибл. таким макаром ямл пропускает этот кусок а ансибл когда дооходит до него очередь
уже понимает что это обращение к переменной.

дальше возникает вопрос. а можно как то скажем в debug засунуть не переменную а словарь например. 
 
 
  - name: phase 0
       debug:
          msg: "{ a: 1}"

ну в таком виде как я понимаю ансибл это все воспринимате просто как 
набор литер. и тут неидет речь о печати именно словаря а просто печается набор литер. 
на экране получим вот так

 msg: '{ a: 1 }'
 
 теперь убираем кавычки
 
 
  - name: phase 0
       debug:
          msg: { a: 1}


к счастю для нас команда debug она умеет печатать словари. так что
команда успешно прходит

на экране будет вот так

 msg:
    a: 1
	

как говорится почутвуй разницу

попробуем распечатать список

  - name: phase 0
       debug:
          msg: [ 1,2 ]
		  
		  
и debug со списками тоже успешно работает

на экране будет

  msg:
  - 1
  - 2


а теперь уже понятно что если мы попробуем таккую команду


 - name: phase 0
       debug:
          msg: "{ masha }"
		  
	то мы просто распечааем литеры
	
	 msg: '{ masha }'
	 
а если вот такую команду 


 - name: phase 0
       debug:
          msg: { masha }


то получим интересный резульат

 msg:
    masha: null

тоесть ансибль распечатал словарь в котором ключ=маша а значение не определено. опять же важно понимать что тут не шло обращение к переменной masha. шло обращение совсем к другой вещи.


и тут я подхожу еще к одной вещи это у loops
выглядят они вот так обычно

  - name: phase 1
       debug:
          msg: "{{ item  }}"
       with_items:
           - [ mc ]

на экране получим

 msg: mc
 
 что в тарабарщине лупов важно понять:  после with_items идут элементы
 списком. при этом как я понимаю директива with_items автоматом создает
 переменную с именем item  которая по своему типа это список и она содержит все эелменты списка которые указаны после with_items
 таким образом если мы в debug хотим обратиться к этим элементам
 нам надо обратиться к переменной items.
а раз это переменная то мы уже знаем как обращаться к переменным
                    "{{ item }}"
					
что мы и делаем 

msg: "{{ item  }}"

поскольку мы обращаемся к переменной то мы используем синтаксис 
"{{ имя }}"

соотсвтенно если мы вместо этого поставим

msg: "{ item  }"

то ансибль просто рапечатает набор литер  { item  }

а если вставим

msg: { item  }

то ансибль будет обращшатся не к переменной iten а печтать словарь
в котором ключ=item а значение = null

тоесть это совсем другая структура.

таким образом важно помнить что with_items невидимо и автоматом
создает переменную с именем item  к которой мы и должны обращаться 
через "{{ item }}"


таким образом надо понимать в какой команде какое поле может в себя принимать значение в виде
а) словаря напрямую
б) списка напрямую
в) переменную типа словарь
г) переменную типа список
д) переменную обоих типов.

это все от команды зависит конкретной.

например комнда apt

  - name: phase 2
       apt:
          name: { apache2 }
          state: latest


вот такой номер абсолютно непройдет. 
потому что мы в качестве имени пакета суем словарь. в котором
имя = apache2 а значение = null.

команде apt нужно только имя без всякий значений. он так и напишет 
что мы ему подсунули dict а ему нужно list

 а вот такая команду уже отлично пройдет
 
   - name: phase 2
       apt:
          name: [ apache2 ]
          state: latest

потому что здесь мы подуснули список.

а если мы будем подсовывать переменную 


   - name: phase 2
       apt:
          name: "{{ masha }}"
          state: latest

то надо обязательно чтобы эта переменная имела тип список.

далее.

нам необязательно использовать with_items 
чтобы создать переменную типа список для того чтоюбы потом ее использовать
можно и самому создать эту переменную

  vars:

     masha:
         - apache2
         - mc


 tasks:

     - name: A
       apt:
           name: "{{ masha}}"
           state: present


  apt абсолютно успешно сожрет переменную masha и поставить пакеты.
  для этого прям вот with_items необядательно использовать.
  
  таким образом with_items это никакой нахер не loop 
  это сопособ создавать переменную только в дебильном иносказщатительном
  запутанным способом. переменная будет иметь имя item и 
  иметь тип список.
  
  
  вот эти оба способа одинаковы

способ 1  
  
  vars:

     item:
         - apache2
         - mc

  

  способ 2

  with_items:
             - apache2
             - mc
			 
один прямой второй иносказательный.
в первом случае перменую можно ввызывать отовсюду
а во втором я неуверен что эта переменная может быть вызвана сто раз.


для модуля apt оба способы одинаковы.

   - name: A
       apt:
           name: "{{ item }}"
           state: present


и прикольно что модуль apt он умеет работать со списками.
ты ему кормишь ему список а он из него сам берет элемент за элементом.

это нето как раньше. содзал массив. а потом надо вызывать цикл чтобы 
из массива выбирать элементы поштучно чтобы их можньо было подсовывать 
уже другим командам.

хотя разница все таки есть между класиически созданной переменной
и переменной заданной через loop


  vars:

        masha:
         - [apache2,mc]
         - [zlib,nginx]





     - name: 234
       debug:
          msg: "{{ masha  }}"



выведет на экране

 ok: [machine1] =>
  msg:
  - - apache2
    - mc
  - - zlib
    - nginx


кстати apt с таким списком masha несможет работать.


     - name: loop
       debug:
          msg: "{{ item  }}"
       with_items:
            - [1,2]
            - [a,b]


выведет на экране

 ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2
ok: [machine1] => (item=a) =>
  msg: a
ok: [machine1] => (item=b) =>
  msg: b


все таки видна разница между двумя этими способами.
в первом случае debug типа получает себе врожу сразу 
весь ворох данных за один раз.

во втором случае как я понимаю дебаг ансиблем как бэ запускается многократно и каждый раз дебагу подсовывается новое значение.

поэтому with_items это чтото типа того вот такого



    - name: loop

начало цикла
       with_items: item= - [1,2]
                         - [a,b]

       debug:
          msg: "{{ item  }}"
конец цикла           
       
	  with_items это как бы классический for i
	  а внутри него тело цикла.
	  и получается как уже сказал что debug системой взывается 
	  много раз. и каждый раз дебагу подслвыается новое значение.
	  
	  

в случае же такой конструкции

     - name: 234
       debug:
          msg: "{{ masha  }}"


дебаг выщывается один раз. но он информацию полуает сразу всю целиком
всю скопом.

если в первом случае дебаг  за раз полуается всего одно значение.
то во втром случае дебаг получается сразу весь список.
соотвесвтенно в первом случае дебаг  моэеть быть тупым. то втором
случае дебаг доожен уметь сам работать со списками.

таким образом разница есть. и огромная. 

поэтому with_itenms это настоящий цикл for.

отсюда становится понятно почему вот такой код небудет работать

  - name: loop
       debug:
          msg: "{{ item[0]  }}"
       with_items:
            - [1]
            - [a]


потому что item это типа не массив не список не дтикшнари.
это типа просто значение.

===================
прикол то что 


  - - apache2
    - mc
  - - zlib
    - nginx

и 


  - 
    - apache2
    - mc
  - 
    - zlib
    - nginx

это один и тот же список.

и тот же самый список выглядит еще вот так

  - [ apache2, mc ]
  - [ zlib, nginx ]


===================

теперь рассмотрим прогу
и сразы что она будет выводить:


- name: play 1
  hosts: machine1
  become: yes

  vars:
     petya: mc

     vasya:
        name:  apache2
        state: latest

     masha:
         - - apache2
           - mc
         - [zlib,nginx]




  tasks:

     - name: print "masha"
       debug:
          msg: "{{ masha  }}"
       tags:
          - d


здесь мы смотрим что он напечатает при обращении к 
переменной masha

TASK [print "masha"] ****************************************************************************************************************************************
ok: [machine1] =>
  msg:
  - - apache2
    - mc
  - - zlib
    - nginx


видно что печатает сразу весь список. весь массив.
это значит что если бы мы совали машу не в модуль debug 
а в модуль apt то этот модуль должен уметь работать со списками.
иначе будет ошибка. тоесть если мы подставляем переменную в модуль
то модуль должен уметь сам разбивать список на элементы.


     - name: print loop with_items
       debug:
          msg: "{{ item  }}"
       with_items:
            - [1,2]
            - [a,b]
       tags:
          - d


теперь посмотрим что напечатает переменная item 
которую образовали через with_items

TASK [print loop with_items] ********************************************************************************************************************************
ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2
ok: [machine1] => (item=a) =>
  msg: a
ok: [machine1] => (item=b) =>
  msg: b
  
видно что при печати печатается тлоько один элемент из всего массива
за раз. это значит что если бы мы подставли item не другой модуль 
например apt то модуль абсолютно может быть тупой и не уметь работать
со списками или дикшионари. так как ему with_items скармливает всего
один элемент из всего массива за раз.

в этом и есть фундаментная разница между влиянием классической переменной
если мы ее пихаем в модуль и перменной образованной с помощью with_items

еще раз : если мы используем классическую переменную в моделу то внутрь модуля вываливается весь массив за раз. и это уже проблема самого модуля умеет он работать с масивами или нет.  а если мы исмпользуем переменную item которую создает with_items то внутрь модуля вываливаеися 
только один элемент массива. поэтому модуль может быть очень тупой.
модуль небудет иметь представления обо всем массиве. он всегода будет 
втидеть только один элемент.

что еще важно заметить.  если при описании with_items
мы используем список

 with_items:
            - [1,2]
            - [a,b]
			
то в выводе мы видим НЕСПИСОК. 

ok: [machine1] => (item=1) =>
  msg: 1

мы видим как бы просто скалярный элемент.
хотя было бы логично что мы увидим один элемент но это был бы тоже список.
но нет. мы виим чисто скалярный элемент.
почему это важно. почему важно что элемент печатаемый это не список.
потому что чуть ниже мы попробуем напечатать нулевой элемент item[0]
и мы получим ошибку. потому что item[0] означает напечатай нулевой элемент списка item. так вот так как item это несписок то будет ошибка. 



     - name: print masha[0]
       debug:
          msg: "{{ masha[0]  }}"
       tags:
          - d


смотрим печать нулевого элемента переменной masha 


TASK [print masha[0]] ***************************************************************************************************************************************
ok: [machine1] =>
  msg:
  - apache2
  - mc

полученный результат логичен.


далее смотрим нулевой элемент переменной item

     - name: loop
       debug:
          msg: "{{ item[0]  }}"
       with_items:
            - [1]
            - [a]
       tags:
          - d


и получаем ошибку. и это тоже логично. потому что item это не список как это было видно чуть выше. а нотация item[0] просит напечатать нулевой элемент списка, а item еще раз этонесписок. поэтому ошибка. item это типа скаляр.

--
теперь когда мы в деталях поняли в чем разница между
классической перменной 

vars:
  vasya: 1 
  
и переменной item образованной с помощью with_items
  
  
мы поняли что item образованной через with_items
это скаляр. это несписок состоящий из одного элемента, не дикшонари,
это скаляр из одного элемента.

with_items полностью аналогичен циклу 

for i=
end

а item в нем играет роль индексной переменной i


теперь можно переходить к with_nested

берем такой код

   - name: print with_nested
       debug:
          msg: "{{ item }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]



и посмотрим что покажет вывод

TASK [print with_nested] ************************************************************************************************************************************
ok: [machine1] => (item=[1, u'a']) =>
  msg:
  - 1
  - a
ok: [machine1] => (item=[1, u'b']) =>
  msg:
  - 1
  - b
ok: [machine1] => (item=[2, u'a']) =>
  msg:
  - 2
  - a
ok: [machine1] => (item=[2, u'b']) =>
  msg:
  - 2
  - b

откуда видно что за один раз with_nested он в item подставляет
список (уже список а не скаляр!) и видно что with_nested аналогичен
вложенным циклам 

for i=
  for j=
  end
end


соотсветсвенно если мы вот такой код запилим


     - name: print with_nested
       debug:
          msg: "{{ item }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]
         - [ '#','#']


то вложенный цикл уже будет тройной. аналогичен циклу

for i=
 for j=
   for k=
   end
 end
end


ну а в переменную item будет подставляться список из трех элементов
например

ok: [machine1] => (item=[2, u'b', u'#']) =>
  msg:
  - 2
  - b
  - '#'


теперть мы знаем что подставлят в item цикл with_nested.
поскольку в данном случае item это список то мы можем оперировать
элементами уже этого списка. например

берем такой кусок кода



     - name: print with_nested
       debug:
          msg: "{{ item[0] }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]


и смотрим вывод

TASK [print with_nested] ************************************************************************************************************************************
ok: [machine1] => (item=[1, u'a']) =>
  msg: '1 '
ok: [machine1] => (item=[1, u'b']) =>
  msg: '1 '
ok: [machine1] => (item=[2, u'a']) =>
  msg: '2 '
ok: [machine1] => (item=[2, u'b']) =>
  msg: '2 '

таким образом у нас печатался не весь item целиком. а только его нулевой 
элемент.

опять же подчеркну что такой фокус с item[0] неработае с циклом with_items
потому что тот подставляет в item несписок из одного элемента а просто скаляр из одного элемента. тоесть item у with_items это не список.
а item у with_nested это список. 
в этом вчастности разница между with_items и with_nested

вот эта вот тем в чем разгица мжду классической перменоой и перемпной
item которая образуется через with_items\with_nested нигде неописано. а 
это оченть важно.


=========================================
а еще можно вот такой прикол сделать
можно в with_items данные ввести не руками стаические а через 
переменную


  vars:
     kuku:
      - 1
      - 2


    - name: print one more with_items
       debug:
           msg: "{{ item }}"
       with_items:
         - "{{ kuku }}"


интересный кусок здесь 

       with_items:
         - "{{ kuku }}"


распечатка на экране будет 

TASK [print one more with_items] ****************************************************************************************************************************
ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2


тоесть with_items абсолютно корректно в себя всосал список через перменную kuku

==================================

далее посмотрим на еще один цикл with_subelents

код такой

  vars:

     kuku2:
       - name: vasya
         database:
           - a
           - b

       - name: petya
         database:
           - c
           - d


   tasks:
   
     - name: print with_subelements
       debug:
           msg: " {{ item }}"
       with_subelements:
          - "{{ kuku2 }}"
          - database


вывод на экран

TASK [print with_subelements] *******************************************************************************************************************************
ok: [machine1] => (item=[{u'name': u'vasya'}, u'a']) =>
  msg: ' [{u''name'': u''vasya''}, u''a'']'
ok: [machine1] => (item=[{u'name': u'vasya'}, u'b']) =>
  msg: ' [{u''name'': u''vasya''}, u''b'']'
ok: [machine1] => (item=[{u'name': u'petya'}, u'c']) =>
  msg: ' [{u''name'': u''petya''}, u''c'']'
ok: [machine1] => (item=[{u'name': u'petya'}, u'd']) =>
  msg: ' [{u''name'': u''petya''}, u''d'']'


он берет vasya и пробегает по a, b
потом берет petya и пробегает по c,d

пробегает он по тому полю которое мы указали в данном случае 
это database

в итоге item будет такими

item:
  - name: vasya
    a: null
	
item:
  - name: vasya
    b: null


item:
  - name: petya
    c: null
	
item:
  - name: petya
    d: null


соттвесвтенно если item имеет такую структуру - список
то можно обращатся к отдельным элементам этого списка через

item[0]

и

item[1]

соттвесвтенно если мы чуть изменим код


     - name: print with_subelements
       debug:
           msg: " {{ item[0].name }}, {{ item[1] }}"
       with_subelements:
          - "{{ kuku2 }}"
          - database


то получим красивый вывод

TASK [print with_subelements] *******************************************************************************************************************************
ok: [machine1] => (item=[{u'name': u'vasya'}, u'a']) =>
  msg: ' vasya, a'
ok: [machine1] => (item=[{u'name': u'vasya'}, u'b']) =>
  msg: ' vasya, b'
ok: [machine1] => (item=[{u'name': u'petya'}, u'c']) =>
  msg: ' petya, c'
ok: [machine1] => (item=[{u'name': u'petya'}, u'd']) =>
  msg: ' petya, d'
  
 
 также какойто дебильный прикол в with_subelements
 
 
 если kuku2 
 будет иметь вид
 
  kuku2:
       - "vasya"
         database:
           - a
           - b

       - "petya"
         database:
           - c
           - d

то ансибль выдаст ошибку при обработаке через with_subelemts

а вот если вместо "vasya" и "petya"
мы вставим дикшонари

 kuku2:
       - name: vasya
         database:
           - a
           - b

       - name: petya
         database:
           - c
           - d

то оно отработает нормально.
непонятно чем vasya хуже name: vasya


==================================================

 в продолжение темы переменные vs with_items

вот кусок

- name: install jre
  apt:
     name: "{{ item }}"
     state: present
  with_items:
      - openjdk-8-jdk
      - openjdk-8-doc
    
как мы уже знаем модуль apt может совершенно тупой от него нетребуется умения
работать с списками или дикшионари потому что with_items будет вставлять в item
одиночное значение. и вызывать apt несколько раз.


соверщенно другой случай показан внизу

- name: install jre
  apt:
     name:
        - openjdk-8-jdk
        -  openjdk-8-doc
     state: present

хотя он визуально похож на предыдущий случай но разница колоссальная.
во первых нет with_items 
и во вторых мы сразу в apt засунули весь список целиком.
поэтому apt просто обязан уметь работать со списками. разбивать список на элементы.

поэтому два куска кода визуально похожи друг на друга но они 
соверщенно по разному кормят apt

-------
выяснилось  что когда обращаетмя к переменной через {{ }} то можно подставлять внутрь 
неетолько имя переменной например

{{ vasya }}

но и данные напрямую

{{ ['a','b','c' ] }}


- name: test
  debug:
      msg: "{{ ['a','b']  }}"


========================================

 ансибл по архитектуре все же ебнутный язык или как оно там
 официальнро называется.
 
 есть такие штуки которые непонятно чем они являются как структура в нем
 например.
 
 есть плейбуки.
 
 в нем есть модули.
 в нем есть переменные.
 
  а вот такие хрени как
  
  hosts: ....
  remote_user: ....

что это за структуры? чем глубже занимаешься ансиблем тем в этом плане
возникает много вопросов.


еще вот эта ебнутая вещь что переменные можно пихать в миллион мест.
и при этом запомнеить какое место перебивает какое хер запомнишь.
это непрактично. мне нет времени запоминать эту херню.

============================================

те перменные которые мы определыяем в плейбуке через 

vars:

относятся к  host variables

а (как я понял) такие штуки как  

hosts:

это переменная но другого типа - connection variable.

мозгоебки в архитектуре ансибля много

это пиздец какойто - есть facts, hostvars, есть inventiry vars, есть magic variables, 
connection varibales.. такой курятник. и эти пременные можно запихнуть в 100 разных мест.
а потом еще думать какой файл с перменными перебьет какой...
блядь... архитектура. какие куры это придумали.

а эта ебала что remote_user в плейбуке это одно и тоже что и  ansible_user в inventory
и это тоже самое что ansible_ssh_user в inventory. => нахуя это все так было размножено.
к чему этот миллиард сущностей об одном и томже
==========================================================

я скажу так про эти ебнутые переменные в ансибл.

есть переменные которые помогают ансиблю подключиться по ssh к  хосту.
а есть переменные которые связаны уже с данными которые мы юзаем в плейбуках
который будет запущен на хосте ( тоесть мы уже к хосту смогли поюключиться)
таким макаром мы поняли что переменные делятся на две группы по их назначению.

далее важно что переменные можно указать в плейбуке а можно таукже в совершенно в
другом файле - в инвентори, или еще в другом месте - в папке group_vars\host_vars
таким образом мы поняли что переменную можно засунуть в разные места чисто физически.

далее важно понять что если мы обьявляем переменную 
в плейбуке то синтаксис ее описания там  зависимости от назначения переменной 
переменная которая несвязана с параметрами ssh подключения ансибля к хосту
прописывается в плейбуке через

vars:

а переменная которая свяазана с параметрами ssh подключения ообявляется совершенно 
по другому. а именно такая переменная неимеет никакой доп секции   в плейбуке 
а просто указывется в шапке плейбука. тоесть вся та хрень которая указана в плейбуке
до поля 

tasks:

это указаны ssh коннекшн переменные.

как тебе такой курятник в архитектуре? похоже на женскую сумку если открыть и там 
полный бардак.

пример

- name: play 1
  remote_user: vagrant
  become: yes
  hosts: all
  tasks:
  ....
  
  
  многое из того что  между name и tasks это  переменные ssh коннекшена.
  в данном примере конкретно это 
  
  remote_user: vagrant
  become: yes
 
  
  а далее уже практический момент ради чего все это разбирается.
  скажем нам надоело в каждом плейбуке каждый раз писать эту хрень одну и туже.
  мы хотим обьявить эти переменные глобально для всех хостов сразу где "повыше"
  а не в плейбуке. тоесть вопрос куда засунуть 
  
  remote_user: vagrant
  become: yes

 чтобы неуказывть это в каждом плейбуке.
 
 как уже напиал выше переменные любые неважно какоеих назначение помимо плейбука 
 можно обьявить и в других местах. например в inventory файле.
 и тут очередной "гениальный" момент. название ssh конекшн переменной из плейбука
 когда мы ее хотим перенести в инвентори имеет другое название.
 
 вот эта ссылка которая связывает название в плейбуке с названием в инвентори
 
 https://github.com/ansible/ansible/blob/c600ab81ee/lib/ansible/playbook/play_context.py#L46-L55
 
 из чего следует что remote_user в плебйуке это 'ansible_ssh_user'или 'ansible_user'
 в инвентори.
 
 аналогично become в плейбуке это ansible_become в инвентори.
 
 
 итак в инвентори файле мы напишем вот так
 
 
  ansible_user: vagrant
  ansible_become: yes

но это немножко недостаточно. еще в инвентори для переменных надо указать 
к какой группе хостов мы это относим или какому конкретному хосту.
в данном случае я хочу для всех хостов. значит это группа all ну и в итоге
в инвентори это будет вынглядет вот так

[all:vars]
ansible_ssh_user=vagrant
ansible_become=yes


немноговато ли мудежа на пустом месте.

если мы хотим тоже самое перенести в папку group_vars то это будет выглядет так

# cat ./inventory/group_vars/all

ansible_ssh_user: vagrant
ansible_become: yes

опять заметим мудеж и здесь. уже вместо '=' надо юзать ':'

=====================================================
каким бы макаром переменная нибила обьявлена дока ансибля пишет что перед тем как
плейбук начнет выполняться все переменные прибиваются\разворачиваются\привязываются
 к конечным хостам , тоесть перед выполененнием плейбука каждый хост получает
 полный набор переменных которые ему полагаются.
 
======================================================
дока ансибля пишет что ихняя рекомендация чтобы переменные нехранили в инвентори файлах
а хранили отдельно. либо в плейбуке либо в group_vars\host_vars папках. главное чтоб отдельно
чтобы несмешивать список хостов и их переменные.

окей будем стараться так и делать

хотя по мне переменные которые относятся именно к хостам. например
скажем в инвентори такая строчка


machine1  ansible_ssh_host=192.168.61.11 ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key

так вот переменные которые относятся прям к хосту их логиченее хранить
сразу в инвентори файле рядом с именем хоста, типа так нагляднее.
смысл хранить ее отдельно?

получается что вместо того чтобы в одном файле иметь и список хостов\групп хостав + тутже 
их переменные тоесть все в одном месте мы будем иметь миллион файлов. информация будет
разбосана по миллиону разных мест.

пример

ивентори файл в котором только список хостов\групп хостов


[servers]
machine1
machine2



[build_agents]
machine1


[cassandra]
machine2


файл в котором переменные которые относятся к группе хостов

# cat ./inventory/group_vars/all

ansible_ssh_user: vagrant
ansible_ssh_private_key_file: /home/mkadm/.vagrant.d/insecure_private_key
ansible_become: yes

тоесть здесь мы указали где ансиблю брать ключ ssh , под каким юзером ходить на
хосты по ssh, и то что всегде для всех хостов юзать супер пользователя.
таким образом эту хрень ненужно каждый раз вставлять для каждого хоста в инвентори 
файле , вот как это было до этого , как выглядел инвентори файл


[servers]
machine1  ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key ...
machine2  ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key ...


тоесть полная мудота

далее файлы с инвидидуальными переменными хостов

# cat ./inventory/host_vars/machine1

ansible_ssh_host:   192.168.61.11

# cat ./inventory/host_vars/machine2

ansible_ssh_host:   192.168.61.12

раньше этот параметр ansible_ssh_host прописывался в инвенторти файле , таким
образом

[servers]
machine1  ansible_ssh_host=192.168.61.11 ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key ...


теперь все разделено.
файл со спсоком хостов отдельно.
переменные которые применяются к группе хостов заснуты в отдельный файл
переменные которые применяются к отедбьному хосту засунуты отдельно.

полное разделение данных по разных местам\файлам

при таком подходе плейбук выглядит также компактно.

вот как было:

# cat play.yml

- name: playbook
  hosts: all
  remote_user: vagrant
  become: yes
  tasks:
    ...

как стало

# cat play.yml


- name: playbook
  hosts: all
  tasks:
    ...

ненужно каждый раз как обезьяна прописывать remote_user и become.

получается что если у нас есть переменные ssh конекшена то их логичнее
неписать в плейбуке потому что они не являются по природе относящимися именно к 
плейбуку они относятся к свойствам самих хостов например переменная под каким логином
стучать на хост по ssh , так вот таким переменные логично убрать из плейбука
и унести в group_vars папку. почему унести именно в group_vars. потому что плейбук
применяется к группе хостов. значит переменную надо унести именно в группу переменных
значити в group_vars.

поэтому remote_user и become отличные кандидаты на перенос из плейбука в group_vars

с друнгой стороны все переменные которые по приоде происходят именно для данного 
плейбука логично оставить именно в плейбуке (по мне) потому что если  мы будем к группе
хостов применять другой плейбук то переменные из перврого плейбука ко второму плейбуку
неимеюти никакого отношения. поэтому захер им лежать в group_vars папке.

тоесть архитектурные вопрос групповые переменные их куда праивльнее пихать в плейбук
или в group_vars

еще с другой стороны: инвентори файл у нас имеется изначально. берется от нашей структуры
железной. плейбук мы качаем отткуда то из интернета. далее мы натравливаем этот плейбук
на наш инвентори файл\файлы. тоесть инвентори файл родился от одной штуки - от нашей физ 
структуры. а плейбук родился от другогого источника от интернета.  и возникает 
вопрос а переменные то куда пихать в group_vars или в плейбук ?
и здесь еше раз я думаб надо делать так:
   - те переменные которые относятся по своей приоде к свойствам хостов,
     например ssh логины, ssh порты, ssh IP адреса = эти переменные надо прописывать
	 в group_vars\host_vars.  
	 смысла их пихать в плейбук нет. плейбуки будут менятся  а эти переменные они остаются
	 неизменными. потому что порождены хостами а не плейбуками.
	 
   - те переменные которые по приоде рождены конкретным плейбуком их ненужно пихать в
      group_vars\host_vars. так как при смене плейбука мы на хосте будем иметь кучуненужных
	  переменных. зачем нам это. такие переменные надо пихать именно в плейбук. 
	  (или в роли плейбука).
	  
таким образом отвечено на вопрос "когда переменную пихать в group_vars\host_vars а когда
в плейбук". ну а типа согласно доке ансибля в сам инвентори файл типа переменные
лучше вобще непихать. там тока список хостов.

вот такой мудеж в ансибле
=======
	  
что еще интересно.

вот у нас есть инвентори файл

5$ cat ./inventory/hosts



[servers]
machine1
machine2




[build_agents]
machine1


[cassandra]
machine2

[db]
machine2
db2


как видно к примеру хост db2 входит в группу [db]
фишка в том что в плейбуке я могу указать хост db2

- name: play1
  hosts: db2
  
 и плейбук будет выполнять только для хоста db2. 
 фишка в том что  в инвентори файле нет нужды указыывать db2 отдельно вне группы.
 
 это удобно. это умно.
 
 потому что в книжках обычно приучают что в инвентори файле вначале надо указать 
 все хосты отдельно без вхождения в группы. 
а только потом уже их в составе групп. типа как бы они навязывают что в  инвентори
файле в шапке якобы должы быть перечислены все хосты без вхождения в группы.
оказывается это ненадо.
===========================
 
дальше.

очень недобно сделано с переменными  в ансибль

удобно когда можно переменные записать в одном файле. и потом
чтобы плейбуки их читали .
тоесть удобно имет все перменные котоыре относятся ко всем плейбукам
не в плейбуках  а некотором файле. а плейбуки завставить этот файл чиатть 
и из него брать данные.

пример


файл с переменными лежит на 

$ cat ./vars/vars.yml
mysql_root_pass=123

rails_user=rails
rails_pass=456

appservers_ip=['192.168.61.11','192.168.61.12', '192.168.61.15']



вот это оченть важный момоент. еще раз как в ini файле указать list тип переменной
вот так
lvol_names=['2g-1','2g-2','2g-3']


далее в плейбуку мы читаем знаения переменных из этго файла



$ cat db-play.yml
---


- name: install db
  hosts: db2
  
  vars:
    rails_pass:   "{{ lookup('ini', 'rails_pass type=properties file=./vars/vars.yml') }}"
    rails_user:   "{{ lookup('ini', 'rails_user type=properties file=./vars/vars.yml') }}"
    appservers_ip: "{{ lookup('ini', 'appservers_ip type=properties file=./vars/vars.yml') }}"


в этом плейбуке значения трех переменных считывается из файла с переменными.
очень удобно.

если таких плейбуков пять. то лазить в каждый и искать 
и править там значения переменных это дебилизм.


а так кодга у нас переменные происаны в однмо файле а плейбуки 
из него их читают это уже хорошо.


также замечу что в файле с переменными показан хороший пример переменной
типа список

вот таким макаром мы там можем прописать переменную типа список

appservers_ip=['192.168.61.11','192.168.61.12', '192.168.61.15']

дело втом что файл спеременныии мы читаем плагином ini
поэтому обьявление переменных в ini формате имеет особенности.


===

что пока енпонятно :
чтобы можно было обьявить переменную которую ансибль соберет динамически
из нескольких переменных.

пример.

каждый хост в инвентаре имеет переменую ansible_ssh_host

предположим нам нужно узнать все ansible_ssh_host для хостов которые входят
в группу app_servers.

в плейбуке это можно посмотреть вот так

    - name: print ssh ip addrress for hosts in app_servers group
      debug:
          var: hostvars[item].ansible_ssh_host
      with_items:
         - "{{ groups.app_servers  }}"

на экране получим

ok: [db2] => (item=appserver) => {
    "ansible_loop_var": "item",
    "hostvars[item].ansible_ssh_host": "192.168.61.11",
    "item": "appserver"
}
ok: [db2] => (item=centos) => {
    "ansible_loop_var": "item",
    "hostvars[item].ansible_ssh_host": "192.168.61.12",
    "item": "centos"
}


вопрос как из этих отдельных высеров сформировать единую переменную
вот такого вида

a:
 - "192.168.61.11"
 - "192.168.61.12"
 
======

про hostvars

что это такое.

это переменная. это ее имя.

она встроенная , ее формирует сам ансибль . 
и она привязывается не к хосту а к  плейбуку целиком.


еще раз. индивидуально на хосте ее нет.
она одна на весь плейбук.
у нас же обычно переменные привязаны к хосту в плейбуке.
а эта переменная особенная. она выще этого. она привязыватся к плейбуку.
и внутри себя содержит все перменные для всех хостов. 
типатакая мегапеременная.
единсвтенное что она несодержит кастомные переменные которые мы определяем сами.
она содержит переменные которые модуль setup собирает с хостов.

чтобы узнать значение переменной с "имя_переменной" которая прописана 
на хосте с именем "имя_хоста" то в hostvars это можно найти по адресу

{{ hostvars[имя_хоста].имя_переменной }}

например переменная ansible_ssh_host на хосте db2

{{ hostvars[db2].ansible_ssh_host }}

еще раз отмечу что в hostvars находятся только те переенные которые ансибль 
определяет и собирает сам с хостов через выполенние модуля setup.
наших собственных переменных которые мы опредяем в плейбуках в hostavars нету.
это важно понимать

далее хитренький пример.
хотим узнать ip адреса по которым ансибль по ssh обращается к хостам

    - name: print ssh ip addrress for hosts in app_servers group
      debug:
          msg: "{{ hostvars[item].ansible_ssh_host }}"
      with_items:
         - "{{ groups.app_servers  }}"


во первых мы в этом примере испольщуем еще одну встроенную переменную анстбля {{ groups }}
но это не главное. главное это как мы прописали item.
мы привыкли что обращение к переменной в ансибле идет через скобки да еще 
с кавычками

"{{ имя_переменной }}"

поэтому интуитивнро хочется написать вот так


          msg: "{{ hostvars["{{item}}"].ansible_ssh_host }}"
ну или вот так
          msg: "{{ hostvars[{{item}}].ansible_ssh_host }}"

но это все несработает. выдаст ошибку. 
почему - незнаю.

почему то item в hostvars надо прописвыать в виде просто item
	msg: "{{ hostvars[item].ansible_ssh_host }}"

почеу незнаю. но это факт. обращение к имени переменной идет без скобок

кстати говоря в модуле debug вместо msg можно воспользоваться var
и тогда даже hostavars - это же тоже имя переменной оно тоже будет указывать без 
скобок.


    - name: print ssh ip addrress for hosts in app_servers group
      debug:
          var: hostvars[item].ansible_ssh_host
      with_items:
         - "{{ groups.app_servers  }}"


почему надо так - незнаю.
вобще эта дебилистика в ансибле что в одних случаях к переменной обращается со скобками
да еще в кавычках "{{ имя_переменной }}" а в других случай и без всего  имя_ переменной
по мне это очень дебильно. но у них так.

кстати когда юзать msg а когда var  в debug.
по мне var это чисто когда мы хотим напечать значение переменной и все.
а msg это когда мы хотим напечать вообще все что угодно. более расширенный функционал.


====
закончил на том что :
1) как я вроде выяснил ансиблю создает переменную hostvars в которой
находятся все переменные от модуля setup который он прогоняет в начале
заупска плейбука в которой содержатся пременные от ВСЕХ ХОСТОВ которые есть в 
инвентори!
да. шок именнов этом. в плейбуке может быть указан всего один хост конкрнетный
из инвентори. а ангсиблю прогоняет setup походу пьесы на всех хостах.

но я неомгу этопроверить потому что я хочу записать эту переменную в файл
чтобы споконйо просмотреть. и немогу
так как  copy + delagete_to приводит к идиотской ошибке 

 "Failed to get information on remote file 
 
 адалее в плейбуке app_server я хочу либо через hostavrs либо 
 через 
 
 tasks:
    - name: Gather facts from db servers
      ansible.builtin.setup:
      delegate_to: "{{ item }}"
      delegate_facts: true
      loop: "{{ groups['dbservers'] }}"
	  
	заполучить ansible_ssh_host для app_servers хотя плебйук запускаб для db2
	и подавстиь все это в mysql_user


вобщем я нерешил проблему когда мы пишем в файл на локаьном хосте. ну и хер с ним.
тем не менее дейтвительно выяснился такой дебилизм анстбля  - неважно на какой хост
или группу хостов указывает плейбук через hosts:, ансибль при запуске плейбука
кодга запускает модуль setup то этот дебил собирает переменные ансибливские СОВСЕХ ХОСТОВ 
ПРОПИСАННЫХ В ИНВЕНТОРИ. тоесть нетолько с тех хостов что мы указали в плейбуке 
а вобще со всех хостов инвентори.

===

в ансибль в плейбуке когда мы определили Hosts:
тонепонятно можно ли роль выполниить на другом хосте.
но точно можно таск выполнить на другом хосте.


- name: play 1
  hosts: app_servers

  tasks:
     - name: create database 
       mysql_db:
          name: rails
          state: present
       delegate_to: db_servers
      
	  

в этом примере плейбук говорит чтобы таски исполнялись на хостах
из группы app_servers. 
но первый таск будет исполняться на хостах из группы db_servers

тоесть в delegate_to мы указываем хосты и группы прописанные в inventory.

прикольно.


еще тут же хочу рассказать про with_items
чуть исправим наш код

 tasks:
     - name: create database 
       mysql_db:
          name: rails
          state: present
       delegate_to: "{{ item }}"
       with_items:
          - "{{ groups.db_servers }}"

в этом примере item применяется не для
основного модуля mysql_db а для вспомогательного delegate_to, тоесть переменную
item можно пихать нетолько в основной модуль но и во вспомогательные

это тоже перл.

 
====

еще раз хотел подчеркнуть что круто когда мы переменные 
прописываем водном файле для всех плейбуков и всех ролей, а плейбуки и роли этот файл сканируют
и оттуда для себя нужные себе переменные читают.

вот пример как это выглядит в плейбуке


- name: prepare databases for appsever install
  hosts: db_servers
  vars:
    rails_pass:   "{{ lookup('ini', 'rails_pass type=properties file=./vars/vars.yml') }}"
    rails_user:   "{{ lookup('ini', 'rails_user type=properties file=./vars/vars.yml') }}"
    rails_database:  "{{ lookup('ini', 'rails_datbase type=properties file=./vars/vars.yml') }}"



=====

вот еще важный пример

сам плейбук выполнятеся на хостах db_servers
но в модуле mysql_user нам нужные данные которые отностся  к другим хостам.
хостам из группы app_servers. нам нужно оттуда вытащить из ssh ip адреса.

как это делается
через 
	{{ groups.app_servers }}
мы получаем хосты входящие у группу app_servers
и подставляем названия полученных хостов в hostvars

{{ hostvars[item].ansible_ssh_host }}"

и получаем нужные нам IP.
еще раз сам плебук исполняется на одних хостах а IP нам надо получить от других
хостов поэтомутакой мудеж.

что еще здесь важно заметить это то что  я подметтил уже раньше.
то что ансибль так устроен что при запуске плейбука он читает переменные системные
через модуль setup несхостов которые укащаны в плейбуке а ВООБЩЕ СОВСЕХ ХОСТОВ ПРОПИСАННЫХ
В ИНВЕНТОРИ. поэтому когда мы укащываем имена хостов которые не входят в данный плейбук
то этоневызывает ошибку. данные там есть.
вот такой тонкий момент
а вот собственно код

- name: play 1
  hosts: db_servers

  tasks:
     - name: create mysql user {{ rails_user }} with full permissions on {{ rails_database }} database
       mysql_user:
          name: "{{ rails_user }}"
          password: "{{ rails_pass }}"
          host: "{{ hostvars[item].ansible_ssh_host }}"
          state: present
          login_unix_socket: "/run/mysqld/mysqld.sock"
          priv: '{{rails_database}}.*:ALL'
       with_items:
         - "{{ groups.app_servers }}"
       no_log: true


фишка здесь в строках:
          hosts: db_servers
          host: "{{ hostvars[item].ansible_ssh_host }}"
       with_items:
         - "{{ groups.app_servers }}"

====

еще есть тонкий архитектурный момент.
вот нам надо поставить программу из четырех компонентов.

эти компоенты в итоге лягут на три группы серверов.

можно взять все таски. потом их разделить по тому на каких серверах они доложны 
быть выопнены и таким образом сгруппировать таск по плейбукам\ролям.

тогда каждый плейбук будет состоять из кусочков которые ставят части разных программ.

например плейбук который работает на группу хостов где базы данных.
и такой плебук вначале модифицирует базу данных для программы 1, далее он ее модифицирует
для программы 2 потом 3 и 4.

помне такой метод гавно. потому что глядя в такой плейбук непонятно вот этот пользователь 
для какой программы ставится. это похоже на каталоги в линуксе. скажем /bin
туда насованы все бинарники. и непонятно какой из них к какому пакету относится.

есть другой способ. плейбук привязывается не к хосту а к приложению которое ставится.
и тогда плейбук включает в себя несколько плейбуков в котором шаг за шагом прописано 
на каких хостах что мы делаем кокнеретно чтобы зарабтал именно это прилоежение.

помне это более легко читаемо и понимаемо. таким оюоразом мы обьединяем таски 
в плейбуке не по хостам на которых они бдут выполняться а по приложеинию которое мы 
щас ставим.
к прмиеру такой плейбук будет включать два плебйука. первый плейбук менять базу данных 
под прилоежение. второй плебйук ставит веб сервер скажем.в итгге мы смотрим в такой
плейбук(состоящий из двух плейбуков) и у нас легкое целостное логичное понимание
складывается для чего каждая таска.

потому что вот потом когда нам надо чтото помнетять в установке какогто программы
то нам надо искть по всем плйбукам куски ее установки. это я говорю о случае когда 
плейбуки собираются из тасков исходя из хоста на коттором эти тиаски выполняются.
эт оочень неудобно по мне .

===
опишу дурацкую систему su, sudo на линуксе.

значит у нас есть два хоста. 
один хост это 
ansible_host 
это хост на котором мы запускаем плейбук.
и есть 
dest_host
это хост на который заходит ансибль и запускает там плейбук.

значит мы хотим подключиться к хосту dest_host ансиблем. под юзером vagrant
и в плейбуке у нас прописано что become: yes
это значит что после входя в dest_host  под вагрантом далее питон попробует получить
 повышенные права. что надо сделать чтобы это все сработало.

во первых надо заветсти на dest_host юзера vagrant

(dest_host)# adduser vagrant

далее надо настроить на dest_host так чтобы вход по ssh  
под вагрантом происходил не по логину\паролю а без пароля но по сертификату.

значит что надо сделать для этого. надо на ansible_host на котором мы запускаем ансибль
сгенерировать приватный и публичный ключ( здесь описывать это небуду).

далее надо  взять публичный ключ тоесть содержимое файла id_rsa.pub  и добавить его
на dest_host в папку /home/vagrant/.ssh/known_hosts

далее на dest_host в файле
/etc/ssh/sshd_config
надо добавить либо раскоментировать строки
RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile      %h/.ssh/known_hosts

и надо на dest_host перезапустить службу ssh.

теперь по ssh через ансибль либо из командной строки 
можно заходить по юзером вагрант на dest_host без пароля а по сертификату.

а вот далее начинается более интересная мудота. это то как нам сделать
чтобы ансибль мог выполнить become:yes на dest_host причем
без вводя пароля.

ибо это отдельная тема.

значит эта магия она задается на dest_host в файле 
/etc/sudoers


сразу скажу что чтобы при вводе команды sudo -i bash неспрашивало пароль
надо в файле /etc/sudoers отредактироват строчку вот в такой вид

%sudo  ALL=(root) NOPASSWD: ALL

после этого надо сделать выход вход в баш терминал и оно заработает.

синтаксис этого файла это мудота и та еще магия.

значит отойдем малек в сторону. как повышаются права в системе - через su или sudo
$ su root
или 
$ sudo -i bash

а что на выходе. на выходе как я понимаю  новый процесс
под пользователем root. это может быть как и командная строка типа bash так и 
отдельный бинарник какойто. важно то что это не исходный пользователь получает
некие повышенные права - нет. это просто запускается друнгой процесс именно под рутом.
просто нашему васе дале такую возможость запустить новый процесс под рутом.

тоесть после sudo -i bash если набрать id то он покажет что мы это root

так что su\sudo это неповышение прав. это запуск процесса под рутом. исходный юзер
какие права имел такие и остался иметь. а зачем нам чтото зпускать по рутом. азатем 
что ряд команд неработает если непод рутом. тот же fdisk или halt или reboot
или просмотр каких то папок. тот же apt и yum.

как система узнает что если вася пытается запустить через su\sudo процесс от имени рута
можно ли ему это делать. она читает ою этом в /etc/sudoers.
сразу скажу что какойто охуенной необходимости его редактировать именно через visudo вобще
нихуя нет как об этом пишут все. можно любым редактором зайти в /etc/sudoers
и супер отлично его отредактировать без этой блядской мудоты с vi иему подобным уродами.
так вот формат этого файла надо смотреть в инете через man sudoers.
там целый толмут никому ненужной информации.


значит в /etc/sudoers 
можно прописать чтобы вася мог запускать под юзером рут новый процес путь 
кбинарнику которого такойто 

например
добавляем строчку

vasya test-ansible.mk.local = (root) NOPASSWD: /bin/cat, /sbin/fdisk -l

что она даст.
непривилигорованый юзер vasya сможет запускать в себя в баш вот такие 
команды

$ sudo cat /etc/shadow
$ sudo fdisk -l

и это будет успешно.

и cat и fdisk будут запущены как root. поэтому они успешно отработают.

что сущесвтенно что fdisk можно будет запустить только с ключом -l
как это указано в /etc/sudoers а уже с любым другим ключом нельзя.
это удобно.

расшифрую поля в строке

vasya test-ansible.mk.local = (root) NOPASSWD: /bin/cat, /sbin/fdisk -l

	vasya - это имя непривилигорванного юзера из под которого будет вызываться sudo
	test-ansible.mk.local - это полное доменное имя хоста $ hostname --fqdn.
		дело втом что когда ктот запускет sudo на хосте то линукс вызывает hostname --fqdn
		и опредеяет свой полный хостнейм. потом лезет в /etc/sudoers и ищет строку в 
		которой прописан этот хостнейм.  захера таакая система. дело втом что мы можем иметь 
		один единый файл sudoes и его через ансибль\чеф\паппет разослать на миллион разных 
		хостов. и тогда на кажом хосте за правила будет отвечат своя строчка отличающаяся
		своим хостнеймом. дебилизм? дебилизм. но невпервый раз.
	(root) - это имя юзера по которым мы пытаемся запустить новый процесс. потому что 
			можно же и так вот пытатться
					$ su petya
			таким образом при (root) васе разрещено запускать процессы от имени рута
	 NOPASSWD:  означает что после ввода sudo у нас небудет еще раз спрашиваться пароль 
				от васи. (да именно от васи а не от рута)
				
	 /bin/cat, /sbin/fdisk -l = список команд даже с опциями которые васе разрещено за
						пускать от имени рута.

если мы нехотим парться то мы можем заменить для васи строчку на более общую

vasya ALL = (ALL) NOPASSWD: ALL

она говорит о том что вася может через sudo на компе запускать любые команды 
от имени лююого пользователя который создан на хосте.
первый ALL который обозначает хостнейм. это означает то что мы нехотим париться
и вписывать конкретный хостнейм данного сервера. тоесть при имзеннеии хостнейма
сервера строка с васей будет по прежнему работать. как бы ALL означает что 
мол любой тот конкретный хостнейм который щас имеет сервер. имеется ввиду именно
полный хостнейм который мжоно посмотреть командой $ hostname -fqdn

возвращаемся к исходной задаче. нам надо чтобы питон скрипт который вошел по ssh 
на dest_host мог выполнить себя от имени рута.
тогда по идее нам надо в /etc/sudoers вставить


vagrant ALL = (ALL) NOPASSWD: ALL

если мы зайдем на хост в баш. и проверим работае ли sudo на запуск процесса от имени рут
например 

$ sudo cat /etc/sudoers

то все отработает усмпешно

ОДНАКО!!!!  почемуто ансибль напишет ошибку при выпоеннеии плейбука. о том что 
он несмог успешно поднять свои права до рута.

типа как я понимаю питон ансиблевский использует не команду sudo а чтото другое
для того чтобы поднять свои права. какойто другой механизм. 
так что все что оисано выше оно верно для работы в баш и запуска команды sudo.
но для ансибль этовсе неработает. увы.

а вот что релаьно сработает:

1. надо добавить юзера vagrant в группу sudo

# usermod -aG sudo vagrant

замечу что все что я написал до этого там вобще было неважно состоит ли юзер в группе sudo 
или нет. вобще похер. 

2. а на втором шаге в /etc/sudoers надо вставит вот такую строку

%sudo  ALL=(root) NOPASSWD: ALL

И ТОЛЬКО ПОСЛЕ ЭТОГО АНСИБЛЬ МОЖЕТ ПОНЯТЬ СВОИ ПРАВА НА dest_host до рута.
и исполнить плейбук!

формально эта строка она описвыает что юзеры которые входят в группу sudo
могут запускать от имени рут любые команды.

при этом непонятно чем была хуже опция что выше о том что вагрант может от имени 
рута запускат любые команды. непонятно почему та опция неотрабаывает с питоном ансибля.

также непонятно если у нас в /etc/sudoers для юзера написаны одни 
правила и втоже время он входит в группу sudo и для это для этой группы прописаны
другие правила какое из них преобладает. но разбираться с этим уже нехочется.

итак шаг 1 и 2 нужны чтобы на dest_host у нас ансибль мог зайти по ssh от юзера 
вагрант и запустить бинарник любой от имени рута.
ура.

опять же . можно вобще еще меньше запариться и на шаге 2 прописать 

%sudo  ALL=(ALL) NOPASSWD: ALL

это значит что юзер из группы sudo может запускать бинарник
любой нетолько от рута а вообще от любого юзера на том хосте.

также добавлю важную вещь.

~/.ssh/authorized_keys = этот файл позволяет серверу аутентифицировать клиента.
это файл на удаленном сервере куда мы хотми подключиться по сертификату без пароля.
в него мы добавляем наш публичны ключ

~/.ssh/known_hosts = это файл на нашем компе. он позводляет клиенту аутентифицировать
сервер. в этот файл автоматом линукс прописывает фингерпринт который он получает 
от сервера. и если на сервере меняется фингерпринт ( мы удалили и создали заново ту виртуалку)
то наш линукс при попытке подулкючитьмся к той ВМ начинает страшно ругаться
типа внимание возможно что man-inthe middle атака. и все такое.
надо зайти у себя на компе в known_hosts и удалить соотвствующую строку.


====

книжка пишет что ансиблю ищет некоторые переменные пока непонятно
какие конкретно в таком порядке в таких местах
1. переменные окружения
2 ansible.cfg в папке плейбука
3. .ansible.cfg в домашней папке
4. /etc/ansible/asnible.cfg

в каком первом месте первее найдет то и берет.

==

походу ansble_ssh_host 
 нужно прописвыать если только комп неможет зарезолвить IP через DNS компа
 
==
еще можно в плейбуке указать сразу список ip а в inventory вобще может ничего небыть

==
 
 про дебидизмы с переменными.
 
 обычно их надо при вызове оформлять в скобки да еще и в кавычки
 
 "{{ имя_переенной }}"
 
 но в ряде случае этого делать ненужно
 
 пример
 
 
     - name: apt install apachae
      apt:
         name: apache2
         state: present
      when:
        - ansible_distribution  == 'Ubuntu'
		

это дебилим.

=====

поговорим про спецоператоры  > и |

это спецоператоры не ансибля а yaml на который он опирается. то есть 
текста вначале анализируется ямлем. а уже потом ансиблем как я понимаю.

так вот > и | это спецоператоры yaml.

если у нас есть поле  значение. значения чего? ответ : чегото. 
например  значение дикшонари или списка. 
и мы хотим в это значение внести значение мультистроковое.


вначале я беру две переменные у которых значения мультистроковые
и неиспользуются спецоператоры > и |

  vars:
     a1: mama
         mila
         ramu


     a2:
        - mama
          mila
          ramu


далее я беру еще две переменные в которых уже использую операторы > и |


     a3: |
         mama
         mila
         ramu


     a4: >
          mama
          mila
          ramu
		  
		  
и теперь посмотрим вывод. какая же разница в резульатте:
		  
		  

    "a1": "mama mila ramu",
 "

    "a2": [
        "mama mila ramu"
    ],
    

    "a3": "mama\nmila\nramu\n",
    

    "a4": "mama mila ramu\n",
    

толи модуль debug такой умный толи что но только даже без применения спецоареторов
без проблем мжоно использовать мультисроковое значение как это видно 
из вывода a1 и a2. 
по мне когда мы неиспользуем никакой спецоператор то это аналогично случаю когда мы исполь
зуем оператор > . потому что в обоих случаях много строковое значение 
обьединяется в одну строку причем символы новой строки заменяются на пробелы.
(правда почемуто для a3 вконце добавлен знак новой строки).
а в случае оператора | мы получаем одну строку в которой сохранены символы новой строки.


еще важно что после операторов > и | уже неможет стоять никакой символ , и надо 
вводить значение с новой строки. тоесть вот такой варианто непрокатит

a3: | mama
      mila
      ramu

еще подчеркну что > и | можно использовать нетлоько для значения дикшонари 
но и для значения списка


в целом получается это не опция ансибля это опция ямля который прогоняется первым
при запуске плейбука и он меняет текст плейбука на основе операторов. это некий 
текстовый предпроцессор.


===

прикольно как работает with_items


    - name: print with_items stuff
      debug:
        msg: "{{ item }}"
      with_items:
          -
            - 1
            - 2
          - 3
    


вывод на экран

TASK [print with_items stuff] *******************************************************************************************************************************
ok: [db2] => (item=1) => {
    "msg": 1
}
ok: [db2] => (item=2) => {
    "msg": 2
}
ok: [db2] => (item=3) => {
    "msg": 3
}

	
прикольно как видно то что если у нас элементом списка является тоже список
то with_items автоматом разрезает вложенный список на элементы и посылает в основной
модуль элемент субсписка.

тоесть можно было бы ожидаь что with_items первым элементом пошлет

-1
-2

а вторым

-3

но with_items первым эелментом как видно послал

-1

вторым

-2 

и третьим 

-3

это интересно

это немодуль debug такой умный а именно with_items  разрезал вложенный список 
на отдельные субэлементы.

я так понял.

таким образом как по мне то в операторе > вобще нет никакого смысла оно так и
рабоает по умолчанию.
а оператор pipe | позволяет вбить многострокое значение и сохранить 
знак переноса строки в нем. тобишь с пайпом многостроковое остается многостроковым
а с > (и вобще без всякого оператора) многострокое сообщение становится
одностроковым.

что я замечаю что оператор > он добавляет в значение в конец его знак переноса 
строки.почему непонятно.пример этого :

vars:
vars:
   petya:
            - >
                 ehal
                 greka
				 

вывод на экран

 "petya": [
        "ehal greka\n"]

как видно вконце ансибл добавиил знак переноса строки.


вот такая суть.
 
 
=====
		  
еще примеры операторов | и >


vars:
   petya:
            - >
                 ehal
                 greka

            - |
              shla sasha
              po shosse
			  

вывод на экран:

"petya": [
        "ehal greka\n",
        "shla sasha\npo shosse\n"
    ]



как видно в первом случае энтеры превратились в пробелы плюс в конце добавился 
знак переноса строки
а во втором случае были сохранены энтеры.


======
	
еще раз обращу вниание на прикол.

есть переменная

   kolya: mama
          mila
          ramu



в значении находится стринг в котором есть переносы строки.
так вот даже без оператора > ансибль по умолчанию удаляет переносы
строки . вот это видно из вывода на экран

"kolya": "mama mila ramu"

причем в отличие от оператора > по умолчанию ансибль недоавбляет в конец знак 
переноса строк попросту энтер



====

еще раз по поводу того как with_items 
разбивает массив на элементы. вопрос был в том что если массив состоит
из субмассива разбивает ли он его на субэлементы


пример

переменная

    vasya:
           -
             - 1
             - 2
           - 3


код

   - name: print var vasya
      debug:
         msg: "{{ item }}"
      with_items:
             - "{{ vasya }}"





вопрос, with_items будет пулять в основной модуль 1,2, 3 или 1+2 и 3

вывод на экране


TASK [print var vasya] **************************************************************************************************************************************
ok: [db2] => (item=[1, 2]) => {
    "msg": [
        1,
        2
    ]
}
ok: [db2] => (item=3) => {
    "msg": 3
}


как видно первый item равен item=[1, 2]

а второй item  равен item=3

таким образом with_items неразбивает массив на субэлементы и
первый элемент как видно это 1+2
второй элемент это 3

но главное что 1 и2 образуют единый элемент.

======

эти долбоебы из ансибля до сих пор несделали нормальной 
поддержвки python 3 хотя постоянно ругаются если юзаешь питон 2 
мол мы скоро это выпилим.
поэтому даже если его включить питон 4 через переменную интерпретатора
то эта сука даже модуль пинг выполнить нормально неможет
возвращает ошибку


ansible ping No module named 'exceptions

выход - ставить питон2.

# apt-get install python

на компе без проблем может одновременно сидеть питон 2 и питон 3

долббоебы

===

в hosts: в плейбуке можно укзаать хосты напрямую через :

hosts: centos:db2

===

что будет когда ансибл выпролняет таск из плейбука на групппе хостов
и на одном из хостов таск невыполняется успешно.
будет то что ансибл на этом хосте прекратит выподеннеие этого и остальных 
тасков
а на других хостах продолжить выполнение.
получается в итоге у нас часть хостов будут иметь один конечный вид а другая 
часть хостов другой вид. это жопа

тоесть ансибл исполняет плейбук до тех пора есть хотя бы один хост на котором
все идет без ошибок.

но есть еще тонкость.
есть опция 

serial: 1

она нарущает предыдушее правило.
она прописвыает сколько одновременно хостов надо обрабаывать.

если поставить serial: 1  и этот хост  зафейлится то весь плейбук остановится 
и посрать что на остальых хостах плейбук прошел бы.

тоесть одно правило противочеречит другому.

==

вот есть поелезная опция

max_fail_percentage: 30

это число хостов на которых таск развалился

если она превышена то плейбук прекрашает выполняться на всех хостах.
эта полезная опция если мы хотим на всех хостах гарантированно 
иметь одно и тоже состояние

тогда ставим

max_fail_percentage: 0

хотя тоже несовсем так. таск на котором полезут ошибки в итоге он на части 
выполнится а на части хостов нет. да следущие таски уже будут остановлены
и небудут выполенны на всех хостах, но таск с ошибками на части хостов выполнится
а на части нет. ив этом плане хосты все равно небудут в одном состоянии.
но хотя бы дальше это расхождение неполезет чтоб еще хуже нестало.

===

по дефолту хосты обрабатываются ансиблем в том пордяке каком они прописаны
в инвентори.

и берется одновременно столько то штук на обработку.

можно сменить чтобы хосты обрабаывались по алфавиту например. 


order: sorted

===
опция 

become: yes

уже известна.

есть к ней полезное доолнение

become_user : vasya

теперь ансиблю понятно в кого конкретно надо превращаться

===
sudo = хорошо
su = плохо

поэтому

become_method: sudo

===
оказыается можно использовать ": " а можно  "=" 

пример

   - name: check apache start page http://localhost
      uri:
        url: http://localhost




   - name: check apache start page http://localhost
      uri:
        url=http://localhost


я говрю про строчки параметры модуля

 url: http://localhost
 url=http://localhost
 
 главное что если = то нельзя пробелы совать нидо нипосле


========

еще одна полезная вещь


- name: install db
  hosts: "{{ var1 }}"

  vars:
    var1: db2


тоесть можно переменную вставлять в поле hosts:
но вопрос куда можно вставить переменную чтобы ансибль ее мог вовремя
считать

так вот оказвыается что переменная из vars считывается ансиблем
до поля hosts

===

скажем есть такая штука


     - name: make mysql listen all the net interfaces
       template:
          src: mysql.cnf.yml
          dest: /etc/mysql/mysql.cnf
          owner: root
          group: root
          mode: 0644
       notify: restart mysql


значит выше я писал что ансибл если видит поле значение и это значение 
имеет несколько строк то ансибл превращает эти несколько строк в одну а знаки 
переноса строки энтеры он заменяет на пробелы. таким образом одно равноценно
другому.  смотрим на код в нем ключ это template: а все что дальше до notify: это 
значение многостроковое. таким образом если мы желаем мы можем сами 
превратить это значение в одностроковое 

- name: make mysql listen all the net interfaces
  template: src: mysql.cnf.yml  dest: /etc/mysql/mysql.cnf   owner: root    group: root  mode: 0644
  notify: restart mysql


единственное то что такой код будет неработать потому что двоеточия ансибл
херово переносит в одной строке. поэтому их можно заменить на =. ибо 
': ' экваивалентно "="
тогда

- name: make mysql listen all the net interfaces
  template: src=mysql.cnf.yml  dest=/etc/mysql/mysql.cnf  owner=root   group=root  mode=0644
  notify: restart mysql

таким образом теперь понятно. многострочка превращается в однострочку 
потому что ансибл так сам делает. заменяя энтеры на пробелы. поэтому мы можем
тоже это сделать сами. также мы помнис что двоеточик и равно это эквтивалентные 
операторы в много строчном выражении. а вот когда в одну строчку то ансибл 
двоеточия нелюбит. 


таким образом мы всегода можем преврашать мнрогострочку  в однострочку
и наоборот. когда захотим.

многочтроку в однострочку превращает неансибл а ямл интерпретатор который отрабатывает
еще до ансибля.

почему нельзя двоеточие оставить в однострочку. потому что это спецсимвол и ансибл
думает что стринг имеетвнутри себя дикшонари, получатеся

левая часть стринга + дикшонари + правая часть стринга

а это уже типа некоректно. а вот знаки равно похеру ансиблю. поэтому
тогда для него это все просто однострочка.
ну как то так.

====

ну а если очень хочется двоеточия оставить в однострочку то пожалуйста

  tasks:
     - name: make mysql listen all the net interfaces
       template: {src: mysql.cnf.yml, dest: /etc/mysql/mysql.cnf,  owner: root,   group: root,   mode: 0644}
       notify: restart mysql

но такая запись уженеинтересная потому что корявая. хотя и рабочая.
===

делаю плейбук
mysql + apache + python


конфиг апача

s$ cat 000-default.conf
<VirtualHost *:80>

 <Directory /var/www/test>
   Options +ExecCGI
    DirectoryIndex index.py
  AddHandler cgi-script .py .cgi
 </Directory>



        ServerAdmin webmaster@localhost
        DocumentRoot /var/www/test


        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

</VirtualHost>



конфиг питона

$ cat index.py
#!/usr/bin/python

import pymysql

# Print necessary headers.
#Chapter 2 ansible playbooks64
print("Content-Type: text/html")
print "" #use this double quote print statement to add a blank line in the script
print()

# Connect to the database.
conn = pymysql.connect(
db='testdb',
user='root',
passwd='{{ mysql_root_pass }}',
host='localhost')
c = conn.cursor()

# Print the contents of the table.
c.execute("SELECT * FROM test;")
for i in c:
 print(i)


подчеркну вот эту строчку

print "" #use this double quote print statement to add a blank line in the script

она очень важна 
потому что надо оставить пустую строку между  "Content-Type: text/html" 
и остальным текстом 
иначе апач будет писать  ошибку

malformed header from script 'index.py': Bad header: ()

=====

чтобы содеинить несколько плейбуков мы можем использовать include а можем 
import_playbook  .

- include: play1.yml

или

- import_playbook: play1.yml


 в чем разница.
 
когда мы запускаем плейбук на исполненеие то как я понял идет две фазы.
на первой фазе yaml интерпретатор анализирует текст. фишка еще в том что 
ямл интепретатор на этой фазе анализирует полностью весь текст вобще всего - всех вложенных
плейбуков и ролей. весь текст за исключеием тех плейбуков которые указаны через include.

на второй фазе уже ансибл запускает таски. ансибл запускает таски один за одним по очереди
по мере того как закончит с одним и потом прееходит к другому. таким образом ансибл проанали
зирует и увидит все плейбукт входящие в состав нашего влейбука тока в самом конце
когда увидит последнгий таск.

таким образом ямл видит обарабтывает весь текст целиком.
а ансибл видит текст кода только по шагам шаг за шагом.


так вот если мы используем import_playbook 
то этот плейбук будет проверен ямл интерпертатором на первой стадии.

а если используем include то ямл интепретатор его проверять на первой стадии небудет. он его пропустит
а проверять этот плейбук будет уже ансибл когда дойдет до исполнения этого плейбука.

несколько противорчиво описано. но както так.

сам ансибл рекомендует неиспользовать include а использовать import_playbook
====

как выполнить mysql query 

надо поставить коммьюнити пакет

# ansible-galaxy collection install community.mysql

и потом вот такой код

 - name: check if dump sql is already imported
       community.mysql.mysql_query:
           login_db: testdb
           query: select * from test where message='Ansible is fun'
           login_unix_socket: /run/mysqld/mysqld.sock
       register: temp

=========================
тэг в итоге назначается таску.
можно назначть тэг один за одним каждой таске.
а еще можно назначить роли. тогда автомтом все таски 
это роли получат тэг.
вобщем важно понимать что в конечном итоге тэг прикрепляется к таске или таскам.
хотя мы его скажем лепим формально к роли.

========
есть плейбук main.yml 
который импортирует другие плейбуки



- name: db install play
  import_playbook: db-play.yml

- name: apache+python install play
  import_playbook: web-play.yml


- name: django install play
  import_playbook: django-play.yml


мы запускаем main.yml с тэгом --tags=vasya

так вот даже если в db-play.yml либо в  web-play.yml либо в django-play.yml
нет тасков с тэгом вася то все равно эти плейбуки будут запущены 
с модулем setup. тоесть ансибль соберет факты со всех хостов всех плебуков 
внезваисимости есть там таски с нужным тэгом или нет.

=====

на счет как ориентировтися в выводе на экран.

прежде всего ансибл пишет что начал выподнять такой то плей

PLAY [dc-play.yml]

поэтому удобно поле -name в плее называть также как файл в который он записан.
тогда будет четко понятно какой плей щас выполняется из какого файла.

вот пример моего плея

- name: dc-play.yml

тоесть я в описании плея указал название файла. 

далее кактока ансибл указа какой плей он выполняет он тогда
пишет название роли если она из этого плея вызывается и название таска этой роли.

вот пример

PLAY [web-play.yml]  ( вначале название плея)

TASK [web_server.local : print temp_dir var]  (дальше название роли и названия таска
из этой роли)

таким образом ткперь можно леегко ориентироваться какой файл на данный момент
исполнял ансибл.

как тока он закончит плей и начнет другой то он напишет имя нового плея.

вот пример

TASK [webserver installation status] ************************************************************************************************************************

PLAY [django-play.yml db part]

тоесь закончил таск из текущего плея. и перешел к следующему плею.
таким ообразом говорю что легко тогда понимать как ансбиль движется от плея к плею
от файла к файлу поэтому выводу на экран.

поскольку имя роли нам ничего не гвоорит из какого файла она вызывана то надо искать 
глазами наверх имя плея. а если имя плея содержит имя файла в котором этот плей то 
тогда сразу понятно из какого файла вызывается эта роль.

потому что наша задча исходная это из вываода на экран понимать в каком файле
мы сейчас находимся

еще пример

PLAY [web-play.yml]

TASK [web_server.local : print temp_dir var]

TASK [web_server.local : install pymysql]

TASK [webserver installation status]

из этого куска вывода можно понять 
что роль web_server.local вызывется из web-play.yml

===
пишут что тэг always гарантирует что такой то таск будет выполнен всегда

===
одна из самых важных вещей что надо делать в ансибль проекте
это все переменные публиковать в одном файле. и чтобы все плейбуки и роли
забирали их оттуда. это централизует все настройки в однодм месте.
и этот файл также можно зашифровать
забирать вот так

 vars:
    rails_pass:   "{{ lookup('ini', 'rails_pass type=properties file=./vars/vars.yml') }}"
    rails_user:   "{{ lookup('ini', 'rails_user type=properties file=./vars/vars.yml') }}"
    appservers_ip: "{{ lookup('ini', 'appservers_ip type=properties file=./vars/vars.yml') }}"


===
как указать файл с паролем у ansible vault 
=> 
--vault-password-file

$ ansible-playbook --vault-password-file ~/vault/pass.txt  -i ./inventory/ main.ym

====

чтобы поменять тот редактор который вызывается при команде

$ ansible-vault edit

то надо в ~/.bashrc вставить в конце

export EDITOR=/usr/bin/mcedit

====

установить роль с сайта galaxy
в определенную свою папку

$ ansible-galaxy install elasticsearch --roles-path ~/roles


=====
чтобы вывод на экране был форматированый при запуске плоебйука. 
чтобы знак переводк строки учитыался надо созжат в папке с плейбком 
файл ansible.cfg

$ cat ansible.cfg
[defaults]
stdout_callback= yaml
======

когда мы юзаем delegate_to то мы на тот удаленный хост 
заходим все под тем же ansible_ssh_user

тоесть не под рутом.


===
очередная залупа в ансибль.

если у нас есть некоторый lookup (коих дохера)
например такой

lookup('community.general.random_string', length=12, base64=True)


напечатать его значение можно так

debug:
  var: lookup('community.general.random_string', length=12, base64=True)
  
 
 так вот чтобы его И ВОБЩЕ ЛЮБОЙ lookup засунуть в переменную то
надо этот lookup обернуть в "{{        }}" 

пример

  vars:
    - rand_num: "{{ lookup('community.general.random_string', length=12, base64=True) }}"

если небудет "{{ }}" вокруг лукапа то будут проблемы

=====
что выяснилось. 
в целом вроде как это вроде как очеивдно. однако окончатльно стало 
понятно только после добления лбом об стену,
а именно: вот мы сидим под юзером vasya на ансибль хосте в баше.
и запускаем плейбук ансибля.  при этом на нашем компе запускается некий код на питоне
этот код стучится на удаленный комп под юзером petya который мы указали в плейбуке как
ansible_ssh_user и на том удаленном компе запускается некий код на питоне 
под юзером либо petya либо уже под root если в плейбуке был указан become: yes

так вот возвращаемся на наш хост ансибля и вопрос так под каким юзером запущен 
код питона на этом компе. под petya ? под root ? нет. под vasya
под тем юзером под которым мы сидим в bash.

что тут важно понять. когда мы запустили плейбук на нашем хосте ансибля то далее 
мы имеем два независимых процесса. один процесс на нашем компе а второй процесс
на удаленном компе. наш процесс работает под vasya а на удаленном компе под root
ну или petya.

окей. а какая нам разница . а этот момент всплывает вот когда.

предположим мы запустили модуль fetch в плейбуке этот модуль берет файл с удаленного
компа и копирует на наш комп так вот если на удаленном компе код работал под root 
то там он может влезть в любую папку и прочитать любой файл а вот когда мы начнем сохранять
прочитанный и переданный нам на наш комп файл в папку нашего компа то (ВНИМАНИЕ!)
всплывает то что на нашем компе мы можем сохранить принятый файл только в ту папку
в которую имеет права писать пользователь vasya (о-па!) а поскольку vasya это не root
на нашем компе то сохранить он может файл далеко не в каждой папке а только в той
где у него есть права на запись.

мы же интуитивно думая что become: yes считаем что раз на том компе ансибль имеет root
то и на нащем компе он имеет root. а это категорически полностью нетак. 
поэтому если мы в fetch в dest: укажем папку куда vasya писать не имеет прав то 
фетч нас пошлет , скажет нет прав. и то что там мы root это неимеет никакой роли 
под какими правами ансибль код исполняется на нашем компе.

==========

теперь немного про модуль fetch
он несколько мудацкий

во первых по дефолту он тянет файл с удаленного компа сохроаняя структуру каталогов
в котоой он там сидит, но это еще пол беды, беда в том что он  к голове пути добавляет
$hostname нашего компа на который он пишет. чтобы убрать этот дебилизм чтобы фетч
писал только файл в строго указаный нами путь надо юзать опцию flat: yes

второй прикол в том что если мы напишем

fetch:
  dest=/path
  
 то этого каталога недолно сущестовать. он сам его создать хочет
 а если мы хотим писать в существующий каталог то обязательно нужно на конце добавить
 слэш

fetch:
  dest=/path/
  
  дебилизм 


====

 с опцией var в debug тоже залупа
 если мы хотим напечтать переменну через msg то переменную нужно "{{ }}"
 
 
 
    - name: print tmp_dir
      debug:
         msg: "{{ tmp_dir }}"



а вот если через var то это стандартное обозначение переменной по всему ансиблю
приведет к ошибке

    - name: print the same
      debug:
        var: "{{ tmp_dir }}" 
		

разве это не ебанизм?

прокатит только такой вариант

    - name: print the same
      debug:
        var: tmp_dir 

дебилы

если уж они допускают укороченный вариант для var то долно поддерживаться два способа
и как tmp_dir и как "{{ tmp_dir }}"

кстати а как правильно обозначтиь 

"{{ tmp_dir}}".path   (непавильный вариант)

или

"{{ tmp_dir.path}}"		(правильный вариант)




====

про with_items

если определим переменую

vars:
   vasya: 
      - 1
	  - 2
	  - 3
	  
и потом вот так к ней обратимся


  debug:
      var: item
  with_items: "{{ vasya }}"
  
  то item примет значения :  1 потом 2 потом 3
  
  тоесть мы разобьем спмсок на отделльные элементы
  
  
  а еслимы вот так  обратимся
  
  debug:
      var: item
  with_items: 
      - "{{ vasya }}"
 

то скормленная переменная небудет разбита неэлементы. item примет значение
всего списка целиком.


item = [1, 2, 3]

в этом огрромная разница применения.
надо чтетко понимать хотим ли мы чтобы with_items разбил наш массив
на субэлементы или нет.
===============================
в доках как раз написано 
что часть модулей умеет принимтаь данные в форме списков
как apt а часть неумеет и им надо скармливать по одному элементы спимска
как раз через with_items

====

надо подчекрнуть что with_items
он в качестве входных данных принимает ттолтько список. только его.

а если например у нас есть dict

vars:

   vasya:
       a:1
       b:2

то его нужно првеаращать в спмсок с помощью dict2list типа того

===

прикол в сэтим with_items

- name: pl1
  hosts: localhost
  vars:
    vasya:
      - ['1', '2', '3' ]
      - ['a', 'b', 'c' ]


  tasks:
    - name: with_items
      debug:
         var: item
      with_items: "{{ vasya }}"


при таком раскладе items принимает значения не такие как

items = ['1', '2', '3' ]
items = ['a', 'b', 'c' ]

как я ожидал.

а вот такие:

item =1
item = 2
item = 3
item = a
item=b
item =c

тоесть with_items при правиильной подставке разбил исхходный спимсок
до самого основания на элементарные элементы

круто

в отличие от with_items который разбивает подсписки на эдементы with_list этого
неделает

поэтому 

with_list даст то что 

item = ['1', '2', '3' ]
item = ['a', 'b', 'c' ]

====

очень удобно все настройки переменных держат в одном файле.
также это касается настройки hosts в плейбуке.
удобно ее значение указыать тоже в файле с переменными 
чтобы не лазить в плейбук. 

делается это так



- name: 'play1: create LVM mountpoint'
  hosts: "{{ current_working_set }}"
  vars_files:
       - vars/vars.yml



     
а в файле с переменными мы указквыаем

$ cat vars.yml
current_working_set: kub2_data_nodes


фишка в том что ансибл вначале грузить файл с переменнымы
а потом уже обрабатывает поле hosts:

поэтому проблем нет

зато очень удобно - все все все настройки хранятся в одном месте.
ненужно лазить по миллиону файлов

========================

ansible galaxy
для того чтобы качать и устанавливать роли совсем
ненужен акаунт на сайте галакси.

а вот чтобы туда пихать свои роли он уже нужен.

когда акаунт создан на их сайте то нужно зайти в preferences
и скопировать ключ.

и этот ключ надо засунуть в

~/.ansible/galaxy_token

причем в таком виде

 token:  ключ

а если туда засунуть прсто ключ то 
при попытке скажем скачать роль будеь вылезать ошибка

ERROR! Unexpected Exception, this is probably a bug: 'str' object has no attribute 'get'

=======

galaxy

такой прикол 

пытаюсь удалить роль 

# ansible-galaxy remove имя_роли

оно пмшет что родль успешно удалена
но потом проверяю

# ansible-galaxy list

а роль все равно висит

непонятно

====
 
запуск ансибля в режиме проверки

ключи

--check

--check --diff ( если --diff  и мы хотим чтобы изменнеий небыло то обязательно 
в паре с --check)


дифф больше заточен на показку файлов что в них будет поменяно.
а check на ну хер знает


так вот ряд задач они же зависят от предыдущих так что в режиме чек 
или чек дифф будет показвыать ошибку. то есть пока реально неначнеш ставить 
оно неисправится. так что такие задачи можно дизейблить на исполнение
на стадии чек диф.  вот таким образом  when: not ansible_check_mode


- name: ewwer
  debug:
      var: vasya
  when: not ansible_check_mode 


дело в том что коогда мы запускаемся с ключом --check

$ ansible-paybook -i hosts play.yml --check

то ансибль выставляет переменную ansible_check_mode в True


так что с таким when таск при ключе check будет пропущен


==========================================
еще важная тема
о том как премпнные  указываются в плейбуке

а как в jinja template в файле


в плейбуке мы пишем

- name: set fact
  set_fact:
     a: localhost

- name: vasya
  debug:
       var: hostvars["{{ a }}"]


а теперь посмотрим  как эту же перменную a надо записывать уже в
файле когторый будет jinja обрабатвыать


вот берем файл в templates/vastya.j2

{% for a in balancer_upstreams %}
    {{ hostvars[a] }}
	{% endfor %}
	
	
а теперь заметь разницу между 
	
	hostvars["{{ a }}"]   и  {{ hostvars[a] }}
	
	
	первый это из пдейбука а второй из темлпейт файла.
	
	
	вот такая ебала спеременными
	
=====================================================

вот есть такой код он создает учетку юзера на сервере


##### CREATE USER

- name: 'create a  user  WITH password |  Debian like OS '
  user: name='{{ item.name }}' password='{{ item.password }}' comment='{{ item.comment }}' shell='/bin/bash'
  with_items:
    -  '{{ users }}'
  when:  ('enable' in item.role )  and  ('password' in item.role )  and ( item.server_groups | intersect(group_names) )


- name: 'create a  user  WITHOUT password |  Debian like OS '
  user: name='{{ item.name }}' password='!$6$HbqVO21G$7PViddFST9yim36Ucj3du03vtmEwQwkCi2oV5Gabpe.TJaSbylup0ByyWuSR7nIBOOjj.N1EoBzGfAcs1Vbbd1' comment='{{ item.comment }}' shell='/bin/bash'
  with_items: '{{ users }}'
  when:  ('enable' in item.role ) and  ('password' not in item.role )    and ( item.server_groups | intersect(group_names) )

######



переменная user имеет такой вид
# cat ./group_vars/all/users

  - name: vasya
    comment: vasya ,,,
    password: '$6...'
    ssh_key: 'ssh-rsa A...'
    role:
     - user
     - root
     - enable
    server_groups:
     - none
     - vagrant
     - fastrans_all
     - glavtrasa_all
     - yandex


так вот из всего кода хочется осветить вот этот кусок

when:  ('enable' in item.role )  and  ('password' in item.role )  and ( item.server_groups | intersect(group_names) )

а точнее даже вот этот субкусок:
item.server_groups | intersect(group_names)



значит group_name это встроенная перменная ансибля представляет собой list тоесть список всех групп
куда входит текущий хост в инвентаре ансибля

item.server_groups это тоже список  и для нашего текущего пользователся он равен

item.server_groups  =     server_groups  = [none, vagrant, fastrans_all, glavtrasa_all, yandex ]

так вот задача вышеуказанного куска кода item.server_groups | intersect(group_names)
состоит в том что мы имеем два списка и нам надо выяснить вот что - вот у нас есть текущий сервер на котором
исолняется ансибль. этот сервер входит в группу или группы в инвентаре и нам надо понять есть ли хоть один 
элемент из этого списка который был бы в свойствах юзера в его списке server_groups
например у нас

group_names = [ vagrant]
server_groups  = [none, vagrant, fastrans_all, glavtrasa_all, yandex ]


соотсвтенно мы видим что vagrant эелмент есть в server_groups.
таким образом для нас это признак того что данный акаунт нужно создавать на данном сервере потому что акаунт юзера
входит в туже группу сереров в которую входит этот сервер в инвентаре.
так вот вот этот код

item.server_groups | intersect(group_names)

он проверяет если у нас есть два списка то есть ли между ними intersection в смысле множеств. 
и если интерсекшн не пустой то значит результат true. 

вот пример более простой

# return only the common elements of list1 and list2
# list1: [1, 2, 5, 3, 4, 10]
# list2: [1, 2, 3, 4, 5, 11, 99]
{{ list1 | intersect(list2) }}
# => [1, 2, 5, 3, 4]

вот отсюда взял = https://docs.ansible.com/ansible/devel/collections/ansible/builtin/intersect_filter.html

тоесть фишка в том что будет возвращен true если есть хотя один общий элемент в обоих списках.
это как раз то что надо.

а вот например такой код нам не подходит

vars:
    a: [1,2,3,4,5]
    b: [2,3]
tasks:
    - debug:
        msg: "A includes B"
      when: a is superset(b)

    - debug:
        msg: "B is included in A"
      when: b is subset(a)


потому что тут требование чтобы все эллементы одного массива входили в другой. 
такого у нас нет. (пример взял отсюда = https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_tests.html#tests)

далее
как можно увидеть из строки 
when:  ('enable' in item.role )  and  ('password' in item.role )  and ( item.server_groups | intersect(group_names) )

еще есть  фильтр "in"
'enable' in item.role

я им хотел вначале воспользоваться то есть вот так пробовал заюзать
item.server_groups in  group_names
но такое в данном случае несработает потому что слева от "in" должен стоять тип данных string или 
как он там называется . тогда да "enable" ищется во всех элементах списка. но у нас не константа
не string а тоже список слева item.server_groups  поэтмоу команда "in" нихрена недает.

поэтому очень важно понимать не только что команда делает но и с какими типами данных
она умеет проавильно работать.

====================
как сделать чтобы таск исполнялся на другом хосте отличном от заданного. 
ответ 

- name: play 1
  hosts: app_servers

  tasks:
     - name: task 1
       mysql_db:
          name:  rails
          state: present
       delegate_to: db_servers

==================
тэги
tags

щас я хочу поговорить про тэги

значит в чем коленкор. 
если мы берем плейбук и там мы можем задачам назначить тэги

- name: task1
  ...
  tags: tag1

- name: task2
  ...
  tags: tag2


посмотреть какие тэги в итоге ансибль видит. какие тэги имеют таски

    $ ansible-playbook   admins.yml  --list-tags

   playbook: vasya.yml

  play #1 (localhost): localhost	TAGS: []
      TASK TAGS: [tag1, tag2]

вот видно какие тэги имеет плейбук.


и тогда можно при старте плейбука указать таски с каким тэгом выполнять.
по дейфолту если тэг не указать то анссибль выполнить все таски со всеми тэгами.
все красиво все хорошо.
жопа наступает тогда когда мы внутри роли тоже прописвыаем тэги у тасков.
и тут оказывается что ансибль эти тэги невидит.

ниже ответ с примерами.
краткая выжимка такая - неиспользовать include_tasks внутри роли
а использовать только import_tasks 
и тогда проблем небудет.


  
if we use `include_tasks` in a role --> then we have troubles with tags.  
if we use `import_tasks` in a role --> all is ok
  
  
example:  
  
    $ ansible --version
    ansible [core 2.11.7] 

  

a playbook: **admins.yml**

    - hosts: localhost
      roles:
        - { role: admins}

a role:
./roles/admins/tasks/**main.yml**  

    ---
    
    
    - name:  ' create | Debian ' 
      ansible.builtin.include_tasks:  "Debian/create.yml"

  
  
/roles/admins/tasks/Debian/**create.yml**  

    ---
    
    - name: tag2
      debug:
         msg: "tag2"
      tags: tag2
    
    
    - name: tag3
      debug:
         msg: "tag3"
      tags: tag3
  
  
  

lets list tags:  

    $ ansible-playbook   admins.yml  --list-tags
    
    playbook: admins.yml
    
      play #1 (localhost): localhost	TAGS: []
          TASK TAGS: []

  
  
So we have troubles with tags.
Lets test it.
  
   

    $ ansible-playbook   admins.yml  -t "tag3"
    
    PLAY [localhost] 
    TASK [Gathering Facts] 
    ok: [localhost]

So zero tasks is accomplished.  

lets change **main.yml**
  
  

    ---
    
    
    - name:  ' create | Debian ' 
      ansible.builtin.import_tasks:  "Debian/create.yml"

  
  
Now we dont have troubles with tags:  
  

    $ ansible-playbook   admins.yml  --list-tags
    playbook: admins.yml
    
      play #1 (localhost): localhost	TAGS: []
          TASK TAGS: [tag2, tag3]
  
  
Lets test it.  
  
  

    $ ansible-playbook   admins.yml  -t "tag3"
    
    PLAY [localhost] 
    TASK [Gathering Facts] 
    ok: [localhost]
    
    TASK [admins : tag3] ok: [localhost] => {
        "msg": "tag3"
    }


все ок.


в заключении поясню вот еще что

вот еще плейбук

- hosts: newline_all
  roles:
    - { role: admins, tags: [ 'admins']}

что это за хрень с тэгом. 
это всего навсего мы говорим ансиблю что мол присвой всем таскам внутри роли автоматически тэг 'admins'
таким макаром если мы  запустим 

$ ansible-playbook main.yml -t 'admins'

то будут выполенены все таски из этой роли.

а что там с тэгами в случае когда таски внутри роли имеют свои прописанные тэги?
посмотрим что скажет ансибль

$ ansible-playbook   admins.yml  --list-tags

playbook: admins.yml

  play #1 (localhost): localhost	TAGS: []
      TASK TAGS: [admins, tag2, tag3]

видно то что у нас есть все тэги: admins назначенный из плейбука, а tag2 и tag3 пропсанный внутри роли.
если мы запустим с тэгом admins то будут выполнены все таски из роли.
а если мы запустим  с тэгом tag2 то будут запущены таски в роли только те которые имеют тэг  tag2
таким образом одни тэги другим не мешают.

таким образом имея тэги внутри роли можно их исполтзовать при запуске плейбука и это позволит запустить толко часть задача в роли. это отлично.
а указание тэга роли из плейбука дает возможность при запуске ансибля указать что мы хотим выполнить только таски их такой то роли при этом 
таски из других ролей мы не хотим выполнять. тоесть это позвояет получить инструмент который позволяет нам рулить из командной строки какие роли 
из плейбука мы хотим запустить потому что по дфеолут ансибль такого переключателя нам недает.

====================
ansible
ad-hoc

выполнить команду grep -v '#' /etc/fstab  на множестве хостов 

$  ansible yandex  -i hosts.prod  --limit '!fw-erp-newline-demo-v4-a'    -m shell -a "grep -v '#' /etc/fstab" 


yandex - это группа хостов в инвентаре 
--limit '!fw-erp-newline-demo-v4-a'   = а это позволяет исключить отдельный хост из группы при исполнении
кавычки обязателно одиночные иначе будет ошибку выдавать

а вот как надо делать чтобы тоже самое задать не у адхока а привыполнении плейбука

$ ansible-playbook admins.yml -i hosts.prod  --diff -b  -l 'yandex,!fw-erp-newline-demo-v4-a'

эта хрень будет выпоняться на группе серверов 'yandex' но из нее будет исключен хост fw-erp-newline-demo-v4-a


===================
var.a
var['a']

есть ли разница ?

============================

| venv
поговоим про установку ансибля в виртальном окружении питона.

с какойто версии ансибль разделился на два пакета модуля питона.
это ansible-core\ansible-base это типа базовое ядро над котрым трудтся самые козыреные
програмисты и просто пакет ansible это уже над которм трудятся остальные 
колхозники.

ансибль так как он нписано на питоне то его разумно ставить как модуль питона 
причем в виртуальном пространстве питона. чтобы этот ансибль не мешал системе в целом.
типа как докер контейнер.  что для этого надо - алгоритм установки ансибля в вируалном
окружении питона смотри в файле "kubespray-ansible.txt"
	

===============

| filters

рассмотрим маниупцляицю данными через filters jinja (через фильтры джинджы).
это большая и мудацкая тема. так как ансблть написан на питоне. также как там все коряво
так и в ансибле все очень корявл в с этим

имеем конфига ансибля

$ cat ansible.cfg 
[defaults]
inventory = inventory
remote_user = vasya
private_key_file = /home/vasa/id_ed25519
host_key_checking = False
stdout_callback = yaml
interpreter_python= auto_legacy
nocows=1


имеем плейбук


$ cat play.yml 
---

- name: play.yml
  hosts: localhost



  vars:

     list_one: [ "a", "b" ]


     domain_definition:
       domain:
         cluster:
         - name: cluster1
         - name: cluster2
         server:
         - name: server11
           cluster: cluster1
           port: '8080'
         - name: server12
           cluster: cluster1
           port: '8090'
         - name: server21
           cluster: cluster2
           port: '9080'
         - name: server22
           cluster: cluster2
           port: '9090'
         library:
         - name: lib1
           target: cluster1
         - name: lib2
           target: cluster2




  tasks:
    - name: print list_one
      debug:
         var: list_one


    - name: print list_one (first element)
      debug:
         var: list_one[0]




    - name: print list_one via with_items
      debug:
         var: item
      with_items: '{{ list_one }}'



    - name: print list_one via loop
      debug:
         var: item
      loop: '{{ list_one }}'


    - name: create variable "home"
      set_fact:
         home: "{{ list_one  }}"


    - name: print variable "home"
      debug:
         msg: "home = {{ home  }}"



    - name: create variable "home2"
      set_fact:
         home2: "{{ domain_definition | json_query('domain.cluster[*]') }}"



    - name: print variable "home2"
      debug:
         msg: "home2= {{ domain_definition | json_query('domain.cluster[*]') }}"



    - name: print variable "home3"
      debug:
         msg: "home3= {{ domain_definition | json_query('domain.cluster[*].name')  }}"



    - name: print variable "home4"
      debug:
         msg: "home3= {{ domain_definition | json_query('domain.cluster[*].name') | list }}"





    - name: Display all cluster names
      debug:
        var: item
      loop: "{{ domain_definition | json_query('domain.cluster[*].name') }}"


    - name: Display all server names
      debug:
        var: item
      loop: "{{ domain_definition | json_query('domain.server[*].name') }}"





# ansible-playbook play.yml

расмотрим вывод.
причем я буду давать код ансибля из плейбука
и соотвествующий ему вывод на экран



    - name: print list_one
      debug:
         var: list_one


TASK [print list_one] ************************************************************************************************************************************************************************
ok: [localhost] => 
  list_one:
  - a
  - b


здесь мы видим что имя пеереннной list_one можно указать без всякийх кавычек
и скобок это особенность "var:" в модуле debug
переменная выведены целиком



    - name: print list_one (first element)
      debug:
         var: list_one[0]


TASK [print list_one (first element)] ********************************************************************************************************************************************************
ok: [localhost] => 
  list_one[0]: a


здесь я вывожу только одну строчку списка. в списке элементы нумеруются натуральными
числами начиная с нуля. вот нам нулевой элемент и выведен. 
тоессть вот эта хрень list_one[0] это означает показать нулевой элемент списка list_one


    - name: print list_one via with_items
      debug:
         var: item
      with_items: '{{ list_one }}'

TASK [print list_one via with_items] *********************************************************************************************************************************************************
ok: [localhost] => (item=a) => 
  ansible_loop_var: item
  item: a
ok: [localhost] => (item=b) => 
  ansible_loop_var: item
  item: b

здесь список печатается по элеметно (аналог for ) 
можно заментить что переменная уже должна быть заключена в '{{ имя_переменной }}' 



    - name: print list_one via loop
      debug:
         var: item
      loop: '{{ list_one }}'

TASK [print list_one via loop] ***************************************************************************************************************************************************************
ok: [localhost] => (item=a) => 
  ansible_loop_var: item
  item: a
ok: [localhost] => (item=b) => 
  ansible_loop_var: item
  item: b


тоже самое но вместо with_items юзается loop


    - name: create variable "home"
      set_fact:
         home: "{{ list_one  }}"

TASK [create variable "home"] ****************************************************************************************************************************************************************
ok: [localhost]


создаем переменную home на освное переменной list_one


    - name: print variable "home"
      debug:
         msg: "home = {{ home  }}"


TASK [print variable "home"] *****************************************************************************************************************************************************************
ok: [localhost] => 
  msg: home = ['a', 'b']



напечатать переменную home
заметим что в случае msg в модуле debug уже переменную нужно заклюать в '{{ имя_пееременной }}'




    - name: create variable "home2"
      set_fact:
         home2: "{{ domain_definition | json_query('domain.cluster[*]') }}"


TASK [create variable "home2"] ***************************************************************************************************************************************************************
ok: [localhost]


тут уже пошел самый смак. создаем пеермную home2 на основе переменной domain_definition.
учтитываем то что в ансибле если dictionary вложен в dictionary то доступ (адресация) идет в 
виде dic1.dic2 . тоесть

dic1:
  dic2: vasya


чтобы добраться до vasya надо будет набрать dic1.dic2
а если у нас список то элемент списка выбирыется на основе того что строчка обозначается
через натуральное число тоесть

a:
- "vasya"
- "petya"

тогда чтобы добраться до vasya нужно будет набрать a[0]

соовтственно если у нас переменная выглядит как

     domain_definition:
       domain:
         cluster:
         - name: cluster1
         - name: cluster2

то добараться до cluster1 можно через  domain_definition.domain.custer[0].name
толкьо это даст cluster1


таквот вот эта конструкция
         home2: "{{ domain_definition | json_query('domain.cluster[*]') }}"

она берет переменную domain_definition и потом начинает из нее филтровать
субстрат из этой переменной выбирается дикшонари domain.cluster[*]
тоесть по факту выбирается вот такая хрень
domain_definition.domain.cluster[*]  
где [*] означает строки списка причем с любыми индексами.
почему просто нельзы записат без мозгоебки в виде
         home2: "{{ domain_definition.domain.cluster[*] }}"
непонятно. спасибо долбоебам создателям ансибля.




    - name: print variable "home2"
      debug:
         msg: "home2= {{ domain_definition | json_query('domain.cluster[*]') }}"

TASK [print variable "home2"] ****************************************************************************************************************************************************************
ok: [localhost] => 
  msg: 'home2= [{''name'': ''cluster1''}, {''name'': ''cluster2''}]'


печатаем переменную home2
получаем на экране по сути

home2:
   - name: cluster1
   - name: cluster2






    - name: print variable "home3"
      debug:
         msg: "home3= {{ domain_definition | json_query('domain.cluster[*].name')  }}"

TASK [print variable "home3"] ****************************************************************************************************************************************************************
ok: [localhost] => 
  msg: home3= ['cluster1', 'cluster2']


ну тут мы вошли чуть глубже мы запросили domain_definition.domain.cluster[*].name

получили 
home3:
  - cluster1
  - cluster2

вроде как возникает вопрос по идее мы в запросе получили вроде как просто одельные
элементы "cluster1" и "cluster2" которые по идее не образуют ничего ни список
ни дикшонари. однако вывод на вывел их в форме списка.. ну окей. 



    - name: print variable "home4"
      debug:
         msg: "home3= {{ domain_definition | json_query('domain.cluster[*].name') | list }}"

TASK [print variable "home4"] ****************************************************************************************************************************************************************
ok: [localhost] => 
  msg: home3= ['cluster1', 'cluster2']


в этом примере мы добавили доп фильтр  ...| list ..
который берем отдельные элементы "cluster1" , "cluster2" и составили из него список.
по факту мы получили в точности тоже что в пршлом примере. хотя этот пример 
более правльный синтаксичски алогритмически

home3:
 - cluster1
 - cluster2





    - name: Display all cluster names
      debug:
        var: item
      loop: "{{ domain_definition | json_query('domain.cluster[*].name') }}"

TASK [Display all cluster names] *************************************************************************************************************************************************************
ok: [localhost] => (item=cluster1) => 
  ansible_loop_var: item
  item: cluster1
ok: [localhost] => (item=cluster2) => 
  ansible_loop_var: item
  item: cluster2


как работает эта штука. создается список через кусок кода
"{{ domain_definition | json_query('domain.cluster[*].name') }}"

причем я замеу что этот кусок кода почемуто раотает в точности как
"{{ domain_definition | json_query('domain.cluster[*].name') | list }}"
и мы получаем по факту список

- cluster1
- cluster2

а далее на него натравливается loop . тоесть команда в итоге как бы эквивалетна

loop: [ cluster1, cluster2]

или 

loop:
  - cluster1
  - cluster2


а весь код как бы эквивалентен к виду
    - name: Display all cluster names
      debug:
        var: item
      loop: 
        - cluster1
        - cluster2

и мы в итоге мы и видим на экране
ok: [localhost] => (item=cluster1) => 
  ansible_loop_var: item
  item: cluster1
ok: [localhost] => (item=cluster2) => 
  ansible_loop_var: item
  item: cluster2


тоесть мы видим
cluster1
и 
cluster2








    - name: Display all server names
      debug:
        var: item
      loop: "{{ domain_definition | json_query('domain.server[*].name') }}"

TASK [Display all server names] **************************************************************************************************************************************************************
ok: [localhost] => (item=server11) => 
  ansible_loop_var: item
  item: server11
ok: [localhost] => (item=server12) => 
  ansible_loop_var: item
  item: server12
ok: [localhost] => (item=server21) => 
  ansible_loop_var: item
  item: server21
ok: [localhost] => (item=server22) => 
  ansible_loop_var: item
  item: server22


тут тоже самое. мы имем код
      loop: "{{ domain_definition | json_query('domain.server[*].name') }}"

вначале у нас вычисляется тот массив данных та переменная которая ялвятеся аргументом у loop
	
	"{{ domain_definition | json_query('domain.server[*].name') }}"

    эта штука вычленяет domain_definition.domain.server[*].name


напомню как выглядит исходная переменная
     domain_definition:
       domain:
         cluster:
         - name: cluster1
         - name: cluster2
         server:
         - name: server11
           cluster: cluster1
           port: '8080'
         - name: server12
           cluster: cluster1
           port: '8090'
         - name: server21
           cluster: cluster2
           port: '9080'
         - name: server22
           cluster: cluster2
           port: '9090'
         library:
         - name: lib1
           target: cluster1
         - name: lib2
           target: cluster2


значит этот фильтр нам даст элементы "server11", "server12", "server21", "server22"
и как я уже сказал что ансибль почемуто из этих элемпнтов создает автомтом список
как бутто у нас код выглядел бы вот так

    "{{ domain_definition | json_query('domain.server[*].name') | list}}"
    тоеть мы получаем переменную вида


- server11
- server12
- server21
- server22

и наш код преобразуется как бы к такому



    - name: Display all server names
      debug:
        var: item
      loop: 
        - server11
        - server12
        - server21
        - server22

вот поэтому на экране мы и увидим эти элементы

ok: [localhost] => (item=server11) => 
  ansible_loop_var: item
  item: server11
ok: [localhost] => (item=server12) => 
  ansible_loop_var: item
  item: server12
ok: [localhost] => (item=server21) => 
  ansible_loop_var: item
  item: server21
ok: [localhost] => (item=server22) => 
  ansible_loop_var: item
  item: server22


ура теория совпала с теорией

=====


| tags
| role



if we use include_tasks in a role --> then we have troubles with tags.
if we use import_tasks in a role --> all is ok

example:

$ ansible --version
ansible [core 2.11.7] 
a playbook: admins.yml

- hosts: localhost
  roles:
    - { role: admins}
a role: ./roles/admins/tasks/main.yml

---


- name:  ' create | Debian ' 
  ansible.builtin.include_tasks:  "Debian/create.yml"
/roles/admins/tasks/Debian/create.yml

---

- name: tag2
  debug:
     msg: "tag2"
  tags: tag2


- name: tag3
  debug:
     msg: "tag3"
  tags: tag3
lets list tags:

$ ansible-playbook   admins.yml  --list-tags

playbook: admins.yml

  play #1 (localhost): localhost    TAGS: []
      TASK TAGS: []
So we have troubles with tags. Lets test it.

$ ansible-playbook   admins.yml  -t "tag3"

PLAY [localhost] 
TASK [Gathering Facts] 
ok: [localhost]
So zero tasks is accomplished.

lets change main.yml

---


- name:  ' create | Debian ' 
  ansible.builtin.import_tasks:  "Debian/create.yml"
Now we dont have troubles with tags:

$ ansible-playbook   admins.yml  --list-tags
playbook: admins.yml

  play #1 (localhost): localhost    TAGS: []
      TASK TAGS: [tag2, tag3]
Lets test it.

$ ansible-playbook   admins.yml  -t "tag3"

PLAY [localhost] 
TASK [Gathering Facts] 
ok: [localhost]

TASK [admins : tag3] ok: [localhost] => {
    "msg": "tag3"
}

----

| tags

еще раз про тэги

с тэгами такой моент. тот тэг что указан в плейтбуке для роли он 
присваивает все таскам в роли этот тэг.
напрмиер 

$ cat admins.yml 
- hosts: all
  roles:
    - { role: admins, tags: [ 'admins']}

тоесть всем таскам в роли присватеивается тэг 'admins'
это дает то что если мы хотим выполнить из плебйбука только те таски котоыре сидят в этой роли ( а ролей в плейбуке может 
быть дохера) то мы запустим плбейтук с тэгом -t 'admins'
но это не значит что тэги которые назначены в роли отдельным таскам потреялись. нет.
если в роли у тасков есть свои тэги то их тож можно заюзать.
и тоода выолпнять ся толкько таски из роли с заданным тэгом. пример
вот таски из роли

- name: 'create a  user  WITH password |  Debian like OS '
  user: name='{{ item.name }}' password='{{ item.password }}' comment='{{ item.comment }}' shell='/bin/bash'
  ...
  tags:
    - create_user


- name: search "authorized_keys" files
  find:
...
  tags:
     - delete_ssh_keys


как видно что у одного таска тэг "create_user" а у доругого таска тэг "delete_ssh_user"
таким оразом еси мыхотим из роли выполнить только так с тэгом "delete_ssh_user" то мы
при запуске полейбуке укажем этот тэг и полвниться из этой роли только этот таск.
таким обрзаом кажый таск имеет в этойроли свои индвидуальный тэг и еще каждый таск имеет 
общий тэг 'admins' котоырй незримо назначен из плейбука.



чтоб 
посмотреть список тэгов в плейбуке (включая тэги в его ролях)
$ ansible-playbook -i environments/ovh   admins.yml    -l "ovh-bhs8-lxc-sitebuilder-01"   -b   --list-tags

playbook: admins.yml

  play #1 (all): all    TAGS: []
      TASK TAGS: [admins, create_user, delete_ssh_keys]



видим тэги:  admins, create_user, delete_ssh_keys


посмтреть какие будут выполнены задачи если мы выберем тэг "create_user"
$ ansible-playbook -i environments/ovh   admins.yml    -l "ovh-bhs8-lxc-sitebuilder-01"   -b   -t create_user  --list-tasks

playbook: admins.yml

  play #1 (all): all    TAGS: []
    tasks:
      admins : create a  user  WITHOUT password |  Debian like OS   TAGS: [admins, create_user]
      admins : Allow 'sudo' group to have passwordless sudo TAGS: [admins, create_user]
      admins : Add SSH keys to user accounts    TAGS: [admins, create_user]


===

| ssh

можно ансибль запулить так чтобы у него  было много форков
это дает то что ансибль будет стучать сразу на N хостов сразу ( если N форков )
задается это через ключ   -f N
по дефолту ансибль запускает 5 или 10 форков.

далее вот что важно - если у нас ансибль стучится до хостов через бастион тоесть через единый хост
то у ssh сервера котоырй там крутится есть ограничение  на число входящих подключений. и если 
мы начнем через ансиль туда стучать и заададим кучу форков то бастион нас нахер пошлет.
 у него есть ограничение на 10 одновременных соединений. как исправть - надо на бастионе 
исправтить вот этт ключ

 MaxStartups
             Specifies the maximum number of concurrent unauthenticated
             connections to the SSH daemon.  Additional connections will
             be dropped until authentication succeeds or the
             LoginGraceTime expires for a connection.  The default is
             10:30:100.

             Alternatively, random early drop can be enabled by
             specifying the three colon separated values start:rate:full
             (e.g. "10:30:60").  sshd(8) will refuse connection attempts
             with a probability of rate/100 (30%) if there are currently
             start (10) unauthenticated connections.  The probability
             increases linearly and all connection attempts are refused
             if the number of unauthenticated connections reaches full
             (60).

и будет шоколад

====


| inventory
у ансибля инвентарь может иметь три формата
INI
YAML
TOML

проще всего писать инвентраь в формает INI

| children
| group


можно делать такой прикол

[hw:children]
hw_ingress
hw_storage


[hw]
host3       
host4       

[hw_ingress]
host1

[hw_storage]
host2



так вот вопрос какие хосты будет содержать [hw] группа?
ответ она будет содержать все хосты указанные тоесть

host3
host4
host1
host2

это прикол


| ansible
