ansible

заметки

поговорим про mysql
вот мы его поставили и по дефолту у root юзера пароль пустой.
также напоминаю что у mysql доступ происходит нетолько по 
login+пароль как обычно бывает у программ а еще 
подключается фактор с какого хоста идет коннект от клиента
тоесть у mysql авторизация идет на основе
login+пароль+хост с которого звонят

поэтому в базе mysql логин как бы выглядит в виде

root@hostname пароль

так вот для после установки mysql пароль для

root@localhost
root@127.0.0.1

он пустой.

тоесть зайдя на хост с mysql в него можно войти как

# mysql -u root

все пароль ненужен.


так вот переходим  к сути .
мы хотим через ансибл поменять пароль для root@hostname

а именно для

root@localhost
root@127.0.0.1
root@::1

для этого мы пишем кусок ансибл кода



  - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       when: root_pass.changed


так вот этот код несработает. и я щас обьясню почему.
собсвтенно весь этот кусок текста посвящен тому чтобы обьяснить почему
он не сработает. точнее он сработает частично и вылетит с ошибкой

во первых проясню поля

name:
password:
host:

это не логин и пароль под которым ансибл стучит на mysql чтобы получить
к нему доступ. для этого у модуля mysql_user есть другие поля такие как
login_user
login_password
login_host

так как мы их неуказали в mysql_user то по умолчанию как я понял ансибл
примает по дефолту что

login_user=root
login_password=пусто
login_host=localhost

а поля
name:
password:
host:

прописывают совершенно другое , они используются недля аутентификации
а указывают что менять в базе после того как мы к ней подключились.


так как изначаьно mysql нетребует пароля для root@localhost
то 

так вот кусок ансибля наверху он будет пытаться поменят пароль для

root@localhost
root@::1
root@"{{ inventory_hostname }}"
root@127.0.0.1

при этом он будет подлючаться к базе используя login_user=root, login_host=localhost и пустой пароль. 

значит как mysql_user модуль  будет действовать,
1. он попыватется подлючиться к базе без пароля и у него
это получится и далее он поменяет пароль для 

root@localhost

это все пока успешно.

далее как я понимаю либо ансибл отключается от базы либо база сама выкиывает ансибл от себя так как пароль для root@localhost стал непустым.
в любом случае 

на втором шаге ансибл опять пытается подключиться к базе без пароля 
тоесть как 

login_user=root
login_password=пусто
login_host=localhost

и ОПА! у него больше это неполуится так как не предыдущем шаге мы сами установили непустой пароль для root@localhost. ВСЕ! ансибль больше неможет
подлкючться к базе и делать дальнейшие изменения какие бы то ни было.

вот поэтому кусок кода вверху он вылетит с ошибкой.

так  что в частности работа с with_items это когда ансибл делает последовательно одно тоже но шаг с шагом. напервом шаге берет первое значение и прогоняет , потом второе и прогоняет тоже самое то есть with_items это классической цикл.

тоесть mysql_user в связке с with_items он не применить одну какую то мегакоманду которая за одну mysql транзакцию единовременно изменит сразу 
несколько ячеек в базе mysql. нет такого небудет. 
за первуб транзакцию к mysql изменится одна ячейка root@localhost
потом начнется вторая транзакция за которую должна была быть измнена ячейка root@::1 и так далее.

таким образом как конкрентно работает ансибл с with_items разобрались.
как классический цикл. берет первое значение и делает то что с ним сказано, потом берет второе значение и делает то что сказано. потом третье. а не так что берет сразу первое второе и третье и делает единровременно с ними мегатранзакцию.


про механизм обработки ансиблем with_items разобрались.

возврашается к изначальной задаче. так как же ее сделать.

ответ вот как.


в два прхода

за первый проход мы обращается к базе без пароля
и меняем пароль для root@localhost

  - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
       when: root_pass.changed


теперьмы к базе по старому без пароля подключиться неможем.
потому что локальный питон скрипт крутится на хосте с mysql и поэтому он обращается от имени root@localhost

значит на следующем щаге нам нужно стучаться к базе используя пароль.

это можно сделать двумя путями.
либо в mysql_user модуле прописать 
login_user=root
login_password=пароль
login_host=localhost

либо можно на хосте где крутится mysql записать файл /root/.my.cnf 
вот такого вида

[client]
user=root
password=пароль

и тогда в mysql_user модуле можно не прописывать login_user, login_passwrd,login_host потому что этот модуль он по умолчанию ищет
~/.my.cnf и если его находит то читает креды оттуда

так что финальный кусок когда выглядит так


# обращаемся к базе без пароля и меняем его толко для root@localhost
 - name: mysql change root@localhost password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
            - localhost
       register: root_pass

# записываем .my.cnf
     - name: save  .my.cnf on remote host
       template:
         src: templates/mysql/my.cnf
         dest: /root/.my.cnf
       when: root_pass.changed


# меняем пароль для остальных 
# 	root@::1
# 	root@"{{ inventory_hostname }}"
# 	root@127.0.0.1 , 
# модуль при автоматом читает .my.cnf 
# и обращется к базе уже через пароль
     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       when: root_pass.changed

также может возникнуть хитрожопая мысль. а может нам надо 
просто хитро перегруппировать 

            - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1


вот эти вот штуки чтобы все таки можно было все сделать за один раз. 
например вот так

            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
            - localhost


у меня не сработало.
как только система установила пароль для root@127.0.0.1
то она уже немогла подключиться к базе без пароля 
такое ощущение что для mysql root@localhost эквивалентен root@127.0.0.1
поэтому меняя пароль для одного автоматом ты его установил и для другого.

конец.

---

