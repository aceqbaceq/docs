ansible

заметки

=========
про переменные:

они бывают разных типов. и их можно хранить\совать\обьявлять в разных 
местах.

их можно обьявлять в инвентори файле\файлах, в ее подпапке group_vars\host_vars,
в плейбуке, в ролях.

так какие и куда совать?

в inventory папке должны (помимо спимска хостов) храниться ровно те переменные
которые относятся к свойствам самих хостов.
а переменные которые относятся к свойствам плейбуков недолжны там храниться
а дрожны хранитться в плейбуках.
с другой стороны в плейбуках недолжны храниться перменные которые оттностся к свойствам
хостов.
 а в ролях должны храниться дефолтовые переменные на случай если их забыли указать
 в плейбуке

===============
далее:

вот эта переменная 

ansible_ssh_common_args: '-o StrictHostKeyChecking=no'

позволяет то что при убиении и создании заново VM ансибль неругается на то что
он неможет приконектиться к VM потому что у нее изменился ssh key.
для тестовой среды на вагранте это самое то что нужно.

пихать ключ лучше всего в group_vars/all

$ cat ./inventory/group_vars/all

ansible_ssh_common_args: '-o StrictHostKeyChecking=no'

============
далее:

такой момент 
хотим чтобы name в таске был многострочный красивый при выводе на экран.
например вот такой

- name:
     - change mysql password for
     - root@'::1'
     - root@"{{ inventory_hostname }}"
     - root@'127.0.0.1'
     - root@'localhost'
  mysql_user:

однако ансибл недает ругается и пишет что

ERROR! The field 'name' is supposed to be a string type

так что облом.

максимум можнро записать вот так

- name: change mysql password for
     root@'::1'
     root@"{{ inventory_hostname }}"
     root@'127.0.0.1'
     root@'localhost'
  mysql_user:

 а на экране оно будет в одну строку вот так
 
 TASK [db.local : change mysql password for root@'::1' root@"machine2" root@'127.0.0.1' root@'localhost'] ***


===============
далее:

еще прикол

- name: change mysql password for  root@'{{ inventory_hostname }}'

даже одинакрные кавычки неэкранируют то что внутри.
поэтому на экране будет вывеено значение переменной.
как полностью закэкроанировать непонятно.

в иттге пришлось пока ростановиться на варианте

- name: change mysql password for  root@'{ inventory_hostname }'


====================================
далее:
поговорим про MYSQL
многострадальная тема

после установки мускула у него дефолтный логин\пароль на вход=root\пусто

мы хотим это поменять.


тут еще надо сказать что вход в мускул регулируется нетолько по логину\паролю
но и по dns имени сервера (внимание) с которого стучит клиент. у мускула этот параметр
называется hostname в книжках.
тоесть важно нетолько  с каким логином паролем ты ломишься на мускул но и с какого 
сервера ты на него стучишь. мускул берет src_IP клиента. лезет в DNS пытается там это 
зарезолвить в DNS имя. если это ему неудается то мускул считает что hostname=ip адресу.

в таблице доступа в одной строку мускул хранит:
логин, пароль, hostname, степент доступа к базам и таблицам.

если логин один и тотже а hostname разные то в таблице доступа эти записи 
занимают отдельные строчки.

вот пример:



mysql> use mysql;
mysql> select  user,host,authentication_string from user where user='root';
+------+-----------+-------------------------------------------+
| user | host      | authentication_string                     |
+------+-----------+-------------------------------------------+
| root | localhost | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
| root | 127.0.0.1 | *908BE2B7EB7D7567F7FF98716850F59BA69AA9DB |
| root | ::1       | *7534F9EAEE5B69A586D1E9C1ACE3E3F9F6FCC446 |
| root | machine2  | *7534F9EAEE5B69A586D1E9C1ACE3E3F9F6FCC446 |
+------+-----------+-------------------------------------------+


юзер один, хостнеймы разные. и поэтому строки разные.
также замечу что в этой таблице нет столбца password
вместо нее authentication_string 


нахрена такой разбор. потому что если ломишься по вроде верному логину паролю
но мускл непускает значит надо четко понимать где могло сломаться.
значит если неработает то надо четко понимать в какой hostname мускул резолвит IP компа 
с которого стучишь на мускул.

скажу сразу что если стучишь на мускул стого же компа где мускул крутится то 
мускул резолвит хостнейм такого клиента в 'localhost' (а не в 127.0.0.1 к примеру)
так что за доступ к мускулу локально ответчает строка в таблице

+------+-----------+-------------------------------------------+
| user | host      | authentication_string                     |
+------+-----------+-------------------------------------------+
| root | localhost | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
+------+-----------+-------------------------------------------+

очевидно что для разных hostname могут быть соврешенно индивидуальные пароли.

также отсюда следует что параметр --host при входу на мускул через консольный клиент
задает не хостнейм клиента а задает хостнейм сервера на который клиент хочет стучать.
тоесть это совершенно разные хостнеймы.

также если мы стучим клиентом и неуказыаем логин и пароль или неуказвыаем пароль 
а только логин то клиент ищет файл в ~/.my.cnf в котором это может быть прописано.
отсюда тоже вытекает важное следствие. вот мы зашли на сервер 

$

далее мы ввели команду

$ sudo bash
#

мы знаем что там есть файл  /root/.my.cnf и в нем указан правльный логин\пароль

мы вводим

# mysql 

но получаем от мускула отлуп. почему? ведь все верно.

потому что команда $ sudo bash она переключает на рута но переменна $HOME остается
равной папке непривилигированная юзера условно говоря $HOME=/home/vasya/
поэтому mysql ищет .my.cnf не в /root а в /home/vasya

чтобы при переключении на рута и домашняя папка переключилась на /root надо юзать

$ sudo -i bash

тогда $HOME=/root

вот такие все тонкости надо понимать чтобы успешно входить на мускул.

также надо понимать что если мы поменяли  в таблице доступа мускула пароль для

root@'127.0.0.1' то это никак неизменило\неповлияло на вход на пароль для
root@'localhost'

к чему я это говорю. возвращаясь к исходной задаче мы поставили мускул.
новый мускул в таблице доступа содержит для root только вот такие строки 
доступа

mysql> use mysql;
mysql> select  user,host,authentication_string from user where user='root';
+------+-----------+-----------------------+
| user | host      | authentication_string |
+------+-----------+-----------------------+
| root | localhost |                       |
+------+-----------+-----------------------+

тоесть доступ к мускулу разрешен только с 'localhost'  для root и больше нискакого сервера
и пароль пустой.

сразу скажу что поразительно. во первых понятно что пользователи прописанные в таблице
мускула это совершенно разные пользователи от тех что прорписаны в самом линуксе, 
они неимеют друнг к другу никакого отношения. root мускула неимеет никакого отношения
к руту линукса. так вот что странно. если мы постучим на мускул из баш сесии обычного
линукс юзера нерута хоотя в сам мускул мы пытваемся попасть под рутом

$ id
vagrant

$ mysql -u root

то мускул нам непустит.

а если мы перейдем в баш сессию под линукс рутом и постучим в мускул под мускул рутом
то он пустит

# id
root

# mysql -u root
mysql > 

это непонятно. какое отношение имеет линукс бащ юзер к мускул юзеру.
однако это имеет место когда мы только поставили мускул.
далее когда мы установим пароль для мускул рута то это уже будет неважно. это прекратит
так быть. когда мускул рут юзер получит пароль (потому что сразу после установки мускул
рут юзер неимеет пароля) то мускул будет пускать по логину паролю уже и из баш рут 
сесии и из баш нерут сессии.



а мы хотим прописать на мускуле доступ для следущих конекшн стрингов:


        - localhost
        - ::1
        - "{{ inventory_hostname }}"
        - 127.0.0.1


"{{ inventory_hostname }}" = это хостнейм сервера с которого мы запускаем ансибл плейбук
через переменную ансибля (ибо да мы будем менять конекшн стринги на мускуле через ансибл)


когда мы тока поставили мускул никаких .my.cnf ни вкаких папках нет.
что странно что вход на мускул из под баш сессии непривилигированного пользователя
почемуто неработает, пошлет нахер

$ mysql -u root 

а сработает только вход из под баш сессии рута

# mysql -u root

хотя какая разница мускулу под каким линукс юзером мы сидим на своем сервере 
если его мускульный юзер это совершенно другая сущность.

Еще важный момент про хостнейм клиента. на мускул можно стучать через TCP\IP сокет
(что тривиально и понятно) а можно стучать через юникс сокет в случае когда 
мы входим прям с того сервера где и сам мускул крутится. так вот что непонятно
так это как при этом мускул определяет DNS имя клиента , ведь для этого нужен IP клиента
а какой нафиг у клиента src IP может быть если клиент неиспользует tcp\ip проотокол
а входит через юникс сокет. непонятно. но проверка на практике показал что в этом случае 
у клиента hostname=localhost по мнению мускула.

вот сколько тонкостей и подводных подлянок по поводу процесса логина на мускул.

так я возвращаюсь к нашей задаче. мы хотим для рута добавить\поменять конекшн стринги 
для хостнеймов

		- localhost
        - ::1
        - "{{ inventory_hostname }}"
        - 127.0.0.1

для этого мы заюзаем такой кусок кода (наконец то дошли до ансибл)


     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
		  state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       

щас мы разберем подводные камни использования этого куска кода.
модуль mysql_user позволяет подключаться через питон клиент к мускулу 
и менять у него конекшн стринги.
чтобы этот модуль успешно отработал надо чтобы на сервере мускула был установлен 
питон клиент для мускула. это таакие пакеты как:

        - python-mysqldb
        - python3-mysqldb
  
строка 
	login_unix_socket: /var/run/mysqld/mysqld.sock
говорит модулю что стучаться на мускул надо нечерез tcp\ip сокет а через юникс сокет.
почему так. с одной стороны у меня были какието проблемы с последними версиями мускула
когда я стучался на него через tcp\ip сокет а через юникс сокет таких проблем нет.
и второе раз уж мы запускаем клиент на том же сервере что и мускул то логично юзать
юникс сокет ибо и клиент и сервер сидят на одном сервере. нафиг им этот tcp\ip

вот эти строк

          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
они неимеют отношения к логину паролю на коннект от питон клиента к мускулу. ведь 
прежде чем что то менять в мускуле надо еще к нему подключиться. так вот эти строки 
они не про подключение нашего ансибль\питон клиента к мускулу. за это отвечают
другие строки такие как

	     login_password: "1 "
	     login_user: root
	     login_host: localhost
 

которых мы невидит в нашем коде. а почему. а потому что если мы их неуказали то 
mysql_user модуль заюзает по умолчанию 


	     login_user: root
	     login_password: пусто
	     login_host: localhost
		 
а ведь ровно такие креды и есть когда мы тока установили мускул. 
поэтому такой фокус прокатывает.
единсвтенное что непонятно какой смысл имеет строка login_host:, потому что это не клиент
ее подсовывает мускулу а мускул сам определяет ее на основе IP клиента и обращения к DNS
серверу. ну да ладно.

итак после установки мускула такой фокус прокатит. но если мы поменяем пароль для
root@'localhost' то верхний код уже несработает потому что пароль к рут стал непустой.
как это обойти будет дальше.

так что же значат тогда строки

          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
а они значат то что когда мы подконектились к мускулу то он ищет для добавления либо 
модификации указаннвый в этих строках конекшн стринг. вот что значат эти строки.

еще важный момент. mysql_user модуль он ищет  ~/.my.cnf и если находит то 
ищет там логин и пароль на вход в мускул. 
возникает вопрос а что превалирует логин пароль на вход на мускул указанный вот здесь

	     login_user: root
	     login_password: пусто
	     login_host: localhost
	
или то что указано в ~/.my.cnf
ответ превалируют 	

	     login_user: root
	     login_password: пусто
	     login_host: localhost
	

еще тут важно понимать что в зависимости от под каким юзером ансибл зашел по ssh на сервер
будет разная папка для ~/.my.cnf

если у нас ansible_user=vagrant то ~/.my.cnf будет искать в /home/vagrant
а если к примеру помимо этого у нас прописано become=yes тогда .my.cnf будет
искаться в /root потому что питон скрипт ансиблевский будет исполнться от рута.

вот такие подлянки на которые можно попасть.
тоесть все вот это надо понимать чтобы код отработал успешно или если он неработает
то где искать причины.

возвращаемся опять к коду

     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
		  state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       
если все остальное правильно этот код неотработает. почему. потому что :
как работает with_items это полный аналог цикла for.
возьмется первое верхнее значение localhost и запустится mysql_user.
.my.cnf файла на сервере у нас нет, также строки

	     login_user: root
	     login_password: пароль
	     login_host: localhost
	
у нас в коде непрописаны. поэтому mysql_user полезет на мускул с дефолтными кредами
root@'localhost' пароль пустой. и успешно войдет и поменяет конекшн стринг для
root@'localhost' пароль установит {{ var1 }}

после этого mysql_user закончит свою работу и дисконектится от мускула.
пока что все хорошо. но вот дальше все уже плохо.

дальше with_items берет следующее значение ::1 и вызывает mysql_user,
модуль как и прежде лезет на мускул с кредами root@'localhost' пароль=пусто
но пароль то уже непустой мы на предыдущем шаге его поменяли. поэтому ансибль останавливатеся
и пишет что ошибка.
и это все теперь понятно и логично.  но это можно все исправить.
надо достаточно поменять порядок строк в with_items чтобы пароль для localhost менялся
самым последним


     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
   
		  state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
            - localhost
      

тогда первые три прохода для with_items мы успешно входим под пустым паролем.
меняем конекшн стринги но это никак невлияет на нашего клиента который каждый раз
входит из под localhost
и на четвертом шаге мы меняем уже пароль для localhost но это для нас  уже неимеет 
значения ибо модуль закончит работу.

ественно что если мы намудили с порядком строк в with_items то чтобы модуль полностью 
отработал надо либо переставить мускул, либо зайти на него руками и руками стереть пароль
для localhost.

вот какая огромная куча подводных камней в вопросе входа на мускул и  в вопросе 
смены конекшн стрингов на нем. чуть где какая ошибка и на мускул уже незайти.

как выглядит ~/.my.cnf

[client]
user=root
password=пароль



если мы чтото намудили и неможем войти на мускул. то надо стопить сервис мускула
и входит в него в режиме когда он разрешает вход без аутентификации и разбираться.
как это сделать:

стопим службу
# service mysql stop

дальше
# mysqld_safe --skip-grant-tables &

дальше
# mysql

дальше
mysql> UPDATE mysql.user SET Password=password('NEWSTRONGPASSWORD') WHERE User='root';
mysql> FLUSH PRIVILEGES;
mysql> exit;

запускаем сервис мускула проверяем

# service mysql start
# mysql -u root -p


соотвественно когда наш код отработает даже целиком его повторно запустить уже
неполучится. потому что как ни крути пароль для root@'localhost' поменялся.
а модуль будет как и прежде стучаться через пустой пароль.

соотсвтенно нужно скопировать .my.cnf с новым паролем на сервер в /root/.my.cnf
 (если мы используем become:yes)
тогда mysql_user при повторном запуске плейбука будем искать .my.cnf находить его 
и юзать обновленный пароль оттуда для входа на мускул

итого вот финальный код


- name: change mysql password for
          root@'::1'
          root@'{ inventory_hostname }'
          root@'127.0.0.1'
          root@'localhost'
  mysql_user:
     name: root
     password: "{{ mysql_root_pass }}"
     host: "{{ item }}"
     login_unix_socket: /run/mysqld/mysqld.sock
#     login_password: "1 "
#     login_user: root
#     login_host: localhost
  with_items:
     - '::1'
     - "{{ inventory_hostname }}"
     - '127.0.0.1'
     - localhost
  no_log: true
  ignore_errors: false
  tags:
     - 'change pass'

- name: copy .my.cnf
  template:
       src: my.cnf.yml
       dest: /root/.my.cnf
  tags:
     - 'change pass'

 

все в этом коде выстрадано. и обьясненено. 
только еще скажу про строчку

	  no_log: true
	  
если ее нет то ансибл будет ругаться что мол в логах ансибля можно подсмотреть пароль
который мы пихаем на мускул а это мол небезопасно. данная опция делает то что
в логах ансибля пароль будет невидим.
тэги добавлены просто для удобства.


еще какие ошибки я напарывался когда делал код:
вот эта вот строка

password: "{{ mysql_root_pass }}"

я вставил пробел ненужный вот так

password: "{{ mysql_root_pass }} "

в итоге у меня в базу записывался пароль с лишним пробемло на конце. а я потом
немог понять почему пароль навход неподходит.

также еще раз хочу обратить внимание на то что питон скрипт ансибля на сервере
исполняется под рутом если у нас использутеся в плейбуке опция become:yes
поэтому .my.cnf нужно копировать в /root/.my.cnf 
а не в /home/vagrant

опятьже отходя в сторону если мы по какимто причинам копируем .my.cnf  в /home/vagrant
то нужно оследить чтобы файл там получил правильные пермишнсы чтобы владельцем был
vagrant.vagrant а не root.root

также остался непроверенным момент. скажем у нас глобально обьявлен become:yes
скажем мы это прописали в ./inventory/group_vars/all
и в тоже время в модуле мы локально указываем
become:no
вопрос что сильнее в этом модуле окажется. непроверял.

далее. значение в переменной которая хранит новый пароль лучше взять в кавычки
на случай там спецсимволов, чтобы небыло неожиданных приколов. даже исходя из того чтобы 
неналепить в конце пароля невидимых лишних пробелов.

mysql_root_pass: '123'

и наконец ссылка на полный плейбук

https://github.com/aceqbaceq/ansible/tree/master/mysql


============================================

такой момент.

в ансибле можно запускать таски только с определенным тэгом
пример

$ ansible-playbook -i ./inventory test.yml -t 'имя тэга'

а можно наоборот запускать все таски кроме тасков с тэгом.
и порой это очень тоже удобно.
пример

$ ansible-playbook -i ./inventory test.yml --skip-tags'имя тэга'

может быть даже несколько тэгов одновременно можно использовать.

================================================
===============
далее:

ansible стоит на yaml

в yaml есть типы данных
dictionary
и  mapping

dictionary
это

- 1
- 2
- 3

mapping 
это
a: 1
b: 2

так вот нам надо уметь получать доступ к элементам этих штук
например 

имеем вот такую переменную


 var1:
         a: 1
         b: 2
         c:
           - a
           - b
           -
             elk: stack
             abc: d


так вот. если мы хотим получить доступ к элементу маппинга
то ставим точку и пишем имя маппинга

var1.a = 1
var1.b = 2
var1.c = [ a, b, { elk: stack, abc: d ]


НО! такой фокус непрокатывает когда мы хотим получить доступ 
к элементу dictionary
как я понял тут только прокатывает доступ через порядковый номер

var1.c.0 = a
var1.c.1 = b
var1.c.2 =  { elk: 'stack', 'abc': 'd'}"

ну и последний пример

var1.c.2.elk= stack

значит если мы где то видим обращение к переменной вот такого вида

a.b

это значит что переменная а содержит маппинг вида

a:
  xxx:yyy
  b: ...
  zzz: uuu
  
а если мы видим переменную вот такого вида

a.0

это значит что переменная a имеет вот такой вид

a:
   - ...
   - .....
   - .......
   
   
   
 вот еще переменная a имеет вот такой вид
 
 

changed: false

msg: "u'All items completed'"

results: 
  - 
    ansible_loop_var: u'item'
    failed: false
    item: u'localhost'
    u'changed': false
    u'invocation': 
      u'module_args': 
        u'append_privs': false
        u'ca_cert': None
        u'check_implicit_admin': false
        u'client_cert': None
        u'client_key': None
        u'config_file': u'/root/.my.cnf'
        u'connect_timeout': 30
        u'encrypted': false
        u'host': u'localhost'
        u'host_all': false
        u'login_host': u'localhost'
        u'login_password': None
        u'login_port': 3306
        u'login_unix_socket': u'/var/run/mysqld/mysqld.sock'
        u'login_user': None
        u'name': u'root'
        u'password': u'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
        u'priv': None
        u'sql_log_bin': true
        u'state': u'present'
        u'update_password': u'always'
        u'user': u'root'
    u'msg': "u'User unchanged'"
    u'user': u'root'

warnings: 
  - "u'Module did not set no_log for update_password'"
  
  
  
  
 тогда мы можем получить доступ к ее элементам в таком виде
 
 a.changed
 a.message
 a.results
 a.results.0.ansible_loop_var
 
 
=================
далее:

подлянки ansible

модуль unarchive

- name: Extract  
  unarchive:
    src: 1.tar.gz
    dest: /var/lib/vasya
	
если dest папка несуществует тогда модуль несможет разархивировать
и будет выдавать такую тупую ошибку


"/bin/gtar\" could not handle archive. 
Command \"/usr/bin/unzip\" could not handle archive."


еще раз скажу причина совсем вдругом. несуществует dest папки.  а
без этого модуль неможет.
нужно создать dest папку и все сразу станет отлично

===================
далее:

модуль file

- name: create nginx directory
  file:
    path:  "{{ wp_docroot }}"
    state: directory
    owner: "{{ wp_owner }}"
    group: "{{ wp_group }}"
    mode: 0775

если переменная wp_docroot имеет такой вид:

doc_root: " /1/2/3 "

то есть в ней есть пробел  в конце и вначале
то модуль file напишет что он все сделал но по указанному 
пути папку НЕСОЗДАСТ.

как исправить. надо исправить переменную , убрать пробелы

doc_root: "/1/2/3"

вот теперь модуль file отработает нормально

=======================
далее:

в ансибль есть такая тема мудотная со скобочками.

сразу скажу что часть мыслй здесь неверная. 
верные мысли уже пришли позже внизу начиная со слов "нам необязательно использовать with_items"

тем не менее:
скобочками обозначаются переменные а еще dictionary и lists.

щас  я покажу как через скобки все эти штуки обозначаются.

но перед этим  типа ты спросишь а какая разница между переменной и dictionary

разве dictionary\lists это неразновидность переменной ? ведь и дикшонари и лист могут являться переменной.

захера их тогда по разному обозначать?

а еще у нас есть loops. их к чему отнести  - это  переменные, дикшнари или это списки ?

и как это все к скобкам возвращается в итоге ?

начнем :

в целом в ансибль мудота.

я бы сказал что такие структуры как dictionary и lists это несамостоятельные структуры в ансибль, они всегда являются частью 
чего-то. тоесть когда ты слышишь слово dictionary или list то этого недостаточно, это неговорит о назначении их применения. обьясняю.
в ансибль есть директивы , команды а есть данные. так вот dictionary 
и list они могут применяться как составная часть диркетив так и составная
часть данных. поэтому когда ты слышишь dictionary или list этого недостаточно, ты незнаешь идет ли речь о кусочке директивы или о 
кусочке данных.

это как например мороженое было бы нетолько еда а еще и стройматериал и часть животного. но нет. когда мы слышим мороженое то знаем что оно только еда и только еда. 

пример когда dictionary является частью ансиблбь команды, ансибль диркетивы

  debug:
      msg: "12"
	  
 в этом примере показана диркетива ансибля debug. dictionary является составной частью директивы. 
 
 еще пример
 
 vars:
    a: 1

в этом примере dictionary является частью некоманды а переменной.

таким образом dictionary и аналогично list помогают организоват совершенно разные структуры , как команды так и данные. а это совершенно разные веши.

получается дикшонари или список это кусок кода в общем и целом неизвестно что обозначающий но оформленный по орпделенному синтаксическому
правилу.

для словаря это правидло выгдядит как

a: значение-1
b: значение-2

значение может быть сложное выражение

список выглядит при оформлении как

- значение-1
- значение-2

значение может быть сложное выражение


возврашаемся к скобкам. 
словари и списки могут иметь бесскобочный вид. но всегда их можно преобразовать в экивалентный но вид скобочный. 
каждый дикшонари всегда можно преобразовать  его обозначение через { } скобки.

a: 1
b: 2

этот дикшонари имеет эквивалент обозначение через скобочный вид

{ a: 1, b: 2 }


каждый список подразумевает что его можно изобразить через скобочный вид.
используется [ ] скобки

- 1
- 2
- 3

имеет эквивалентный скобочный вид

[ 1, 2, 3 ]



скобочный вид и нескобочный они эквиваленты. просто когда то удобно 
внешне применить один а когда то другой. а так они равнозначны для машины.


ансибль использует эти синтаксические структуры для выражения своих команд\директив  а также для выражения своих данных.


- name: task 1
  debug:
      msg: "1"
	  
эта хрень напечатает "1" на экране. тоесть эта штука в целом это директива ансибля. его команда. в своем оформлении она выражена
через структуру список со сложным значением.


приведем это к скобочному виду

[ { name: task 1, debug: { msg: "1" } } ]

таким образом ансибливские команды используют списки и дикшонари 
как свои составляющие части как кирпичи.

но помимо использования словарей и списков как часть синтаксиса команд
они также юзаются для организации переменных тоесть данных. команды и переменные разные вещи

vars:
 a:1
 b:2
 c:
   - 1
   - 2
   
 
 в данном случае списки и словари используются не для организации команд
 а организации данных  , создания переменных.

таким образом когда мы слышим или видим что в куске ансибль файла встретился дикшонри или список то нам это ничего не говорит. участвует ли он в опписании команды или в создании переменной.

однако скобочки позволяют однозначно сказать внутри нее содержится списк или словарь.

[ ] = список
{ } = словарь

как выглядит конкретная команда в ансибль какие конкретно на содедржит комбинации списков и словарей зависиит от создателей команды.

при создании переменной мы можем внутрть нее напихать список или словарь любой сложности и вида. это уже зависит от нас.

так вот далее. некоторые команды позволяют внутри себя вставлять внутрь них переменные которые мы ранее определили тоесть другими словами вставлять данные. и тут важно понять что 
не все команды позволяют внутрь себя вставлять данные и эти данные вставляются в виде переменных, причем какая то команда принимает переменную только типа словарь а другая только типа список. 
таким образом важно понять 
а) не все команды позволяют вставлят в себя данные
б) данные втсвляются только через переменные а не голые списки и словари
в) команды обычно четко прорписыавет какого вида может быть переменная
внутри нее это либо только список либо тлько переменная.

как выглядит обьявление переменной мы уже видели

vars:
  a: 1
  b: { c: 3, d: 5 }
  
 а сейчас скажу как выглядит обращение к переменной внутри некоторой команды для примера
 
 debug:
    msg: "{{ a }}"
	
таким образом мы видим что переменная вызываетс через двойные скобки {{ }}
и только если комарнда поддерживает в соотствующем месте внутри себя
подстановку вместо значения переменной. причем перменная дожна иметь 
заранее определенный тип, либо словарь , либо спмсок.
нельзя в команду всавить переменную типа словарь если команда прддерживает  только тип список.

каки-то конмады поддеживают перменные обоих типов.

например команда debug

вот я определил три переменные

  vars:
     petya: mc

     vasya:
        name:  apache2
        state: latest

     masha:
         - 1
         - 2



и далее хотя они разного типа я могу их все распечатать командой debug

    - name: phase 0
       debug:
          msg: "{{ masha }}"


конкретно команде debug пофиг какого типа переменная. но другим командам нет в целом.


сущестенно то что вместо значения для подставновки данных мы 
используем переменную которую опредлили раньше.

 еще раз разница между переменной и словарь\список. 
 словарь и список они исопльзуются как его части при обьявлении переменной. переменная имеет имя. а например тот же самый список неимеет имени. 
 
 про перменную еще скажу важное когда мы ее вызываем через двойные скобки {{ имя }} то всегда надо ее брать еще и в двойные кавычки
 
 "{{ имя }}" потому что ансибль опирается на yaml интерпретор ( тот отрабатыавает первее ) а yaml интерпретатор ничего знает о синтаксисе кроме как для него весь текст это набор словарей и списков не более того 
 если он встречает в тексте скобки { или [ то он тогда считает что начинается словарь или список. поэтому чтобы заставить ямль интрепретор 
 условно говоря рассматривать {{ имя }} не как словарь внутри которого словарь условно говоря а набор литер то есть экранировать мы берем 
 {{ }} в кавычки. "{{ }}"
 
еще раз это так как ямль обрабыает текст первым и тлько потом его обрабатыавает ансибль интерпретоор. то надо заэкранировать кавычки потому что тогда ямль будет думать что он напоролся на словарь. короче неудачно выбраны символя для обозначения переменных в ансибл. таким макаром ямл пропускает этот кусок а ансибл когда дооходит до него очередь
уже понимает что это обращение к переменной.

дальше возникает вопрос. а можно как то скажем в debug засунуть не переменную а словарь например. 
 
 
  - name: phase 0
       debug:
          msg: "{ a: 1}"

ну в таком виде как я понимаю ансибл это все воспринимате просто как 
набор литер. и тут неидет речь о печати именно словаря а просто печается набор литер. 
на экране получим вот так

 msg: '{ a: 1 }'
 
 теперь убираем кавычки
 
 
  - name: phase 0
       debug:
          msg: { a: 1}


к счастю для нас команда debug она умеет печатать словари. так что
команда успешно прходит

на экране будет вот так

 msg:
    a: 1
	

как говорится почутвуй разницу

попробуем распечатать список

  - name: phase 0
       debug:
          msg: [ 1,2 ]
		  
		  
и debug со списками тоже успешно работает

на экране будет

  msg:
  - 1
  - 2


а теперь уже понятно что если мы попробуем таккую команду


 - name: phase 0
       debug:
          msg: "{ masha }"
		  
	то мы просто распечааем литеры
	
	 msg: '{ masha }'
	 
а если вот такую команду 


 - name: phase 0
       debug:
          msg: { masha }


то получим интересный резульат

 msg:
    masha: null

тоесть ансибль распечатал словарь в котором ключ=маша а значение не определено. опять же важно понимать что тут не шло обращение к переменной masha. шло обращение совсем к другой вещи.


и тут я подхожу еще к одной вещи это у loops
выглядят они вот так обычно

  - name: phase 1
       debug:
          msg: "{{ item  }}"
       with_items:
           - [ mc ]

на экране получим

 msg: mc
 
 что в тарабарщине лупов важно понять:  после with_items идут элементы
 списком. при этом как я понимаю директива with_items автоматом создает
 переменную с именем item  которая по своему типа это список и она содержит все эелменты списка которые указаны после with_items
 таким образом если мы в debug хотим обратиться к этим элементам
 нам надо обратиться к переменной items.
а раз это переменная то мы уже знаем как обращаться к переменным
                    "{{ item }}"
					
что мы и делаем 

msg: "{{ item  }}"

поскольку мы обращаемся к переменной то мы используем синтаксис 
"{{ имя }}"

соотсвтенно если мы вместо этого поставим

msg: "{ item  }"

то ансибль просто рапечатает набор литер  { item  }

а если вставим

msg: { item  }

то ансибль будет обращшатся не к переменной iten а печтать словарь
в котором ключ=item а значение = null

тоесть это совсем другая структура.

таким образом важно помнить что with_items невидимо и автоматом
создает переменную с именем item  к которой мы и должны обращаться 
через "{{ item }}"


таким образом надо понимать в какой команде какое поле может в себя принимать значение в виде
а) словаря напрямую
б) списка напрямую
в) переменную типа словарь
г) переменную типа список
д) переменную обоих типов.

это все от команды зависит конкретной.

например комнда apt

  - name: phase 2
       apt:
          name: { apache2 }
          state: latest


вот такой номер абсолютно непройдет. 
потому что мы в качестве имени пакета суем словарь. в котором
имя = apache2 а значение = null.

команде apt нужно только имя без всякий значений. он так и напишет 
что мы ему подсунули dict а ему нужно list

 а вот такая команду уже отлично пройдет
 
   - name: phase 2
       apt:
          name: [ apache2 ]
          state: latest

потому что здесь мы подуснули список.

а если мы будем подсовывать переменную 


   - name: phase 2
       apt:
          name: "{{ masha }}"
          state: latest

то надо обязательно чтобы эта переменная имела тип список.

далее.

нам необязательно использовать with_items 
чтобы создать переменную типа список для того чтоюбы потом ее использовать
можно и самому создать эту переменную

  vars:

     masha:
         - apache2
         - mc


 tasks:

     - name: A
       apt:
           name: "{{ masha}}"
           state: present


  apt абсолютно успешно сожрет переменную masha и поставить пакеты.
  для этого прям вот with_items необядательно использовать.
  
  таким образом with_items это никакой нахер не loop 
  это сопособ создавать переменную только в дебильном иносказщатительном
  запутанным способом. переменная будет иметь имя item и 
  иметь тип список.
  
  
  вот эти оба способа одинаковы

способ 1  
  
  vars:

     item:
         - apache2
         - mc

  

  способ 2

  with_items:
             - apache2
             - mc
			 
один прямой второй иносказательный.
в первом случае перменую можно ввызывать отовсюду
а во втором я неуверен что эта переменная может быть вызвана сто раз.


для модуля apt оба способы одинаковы.

   - name: A
       apt:
           name: "{{ item }}"
           state: present


и прикольно что модуль apt он умеет работать со списками.
ты ему кормишь ему список а он из него сам берет элемент за элементом.

это нето как раньше. содзал массив. а потом надо вызывать цикл чтобы 
из массива выбирать элементы поштучно чтобы их можньо было подсовывать 
уже другим командам.

хотя разница все таки есть между класиически созданной переменной
и переменной заданной через loop


  vars:

        masha:
         - [apache2,mc]
         - [zlib,nginx]





     - name: 234
       debug:
          msg: "{{ masha  }}"



выведет на экране

 ok: [machine1] =>
  msg:
  - - apache2
    - mc
  - - zlib
    - nginx


кстати apt с таким списком masha несможет работать.


     - name: loop
       debug:
          msg: "{{ item  }}"
       with_items:
            - [1,2]
            - [a,b]


выведет на экране

 ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2
ok: [machine1] => (item=a) =>
  msg: a
ok: [machine1] => (item=b) =>
  msg: b


все таки видна разница между двумя этими способами.
в первом случае debug типа получает себе врожу сразу 
весь ворох данных за один раз.

во втором случае как я понимаю дебаг ансиблем как бэ запускается многократно и каждый раз дебагу подсовывается новое значение.

поэтому with_items это чтото типа того вот такого



    - name: loop

начало цикла
       with_items: item= - [1,2]
                         - [a,b]

       debug:
          msg: "{{ item  }}"
конец цикла           
       
	  with_items это как бы классический for i
	  а внутри него тело цикла.
	  и получается как уже сказал что debug системой взывается 
	  много раз. и каждый раз дебагу подслвыается новое значение.
	  
	  

в случае же такой конструкции

     - name: 234
       debug:
          msg: "{{ masha  }}"


дебаг выщывается один раз. но он информацию полуает сразу всю целиком
всю скопом.

если в первом случае дебаг  за раз полуается всего одно значение.
то во втром случае дебаг получается сразу весь список.
соотвесвтенно в первом случае дебаг  моэеть быть тупым. то втором
случае дебаг доожен уметь сам работать со списками.

таким образом разница есть. и огромная. 

поэтому with_itenms это настоящий цикл for.

отсюда становится понятно почему вот такой код небудет работать

  - name: loop
       debug:
          msg: "{{ item[0]  }}"
       with_items:
            - [1]
            - [a]


потому что item это типа не массив не список не дтикшнари.
это типа просто значение.

===================
прикол то что 


  - - apache2
    - mc
  - - zlib
    - nginx

и 


  - 
    - apache2
    - mc
  - 
    - zlib
    - nginx

это один и тот же список.

и тот же самый список выглядит еще вот так

  - [ apache2, mc ]
  - [ zlib, nginx ]


===================

теперь рассмотрим прогу
и сразы что она будет выводить:


- name: play 1
  hosts: machine1
  become: yes

  vars:
     petya: mc

     vasya:
        name:  apache2
        state: latest

     masha:
         - - apache2
           - mc
         - [zlib,nginx]




  tasks:

     - name: print "masha"
       debug:
          msg: "{{ masha  }}"
       tags:
          - d


здесь мы смотрим что он напечатает при обращении к 
переменной masha

TASK [print "masha"] ****************************************************************************************************************************************
ok: [machine1] =>
  msg:
  - - apache2
    - mc
  - - zlib
    - nginx


видно что печатает сразу весь список. весь массив.
это значит что если бы мы совали машу не в модуль debug 
а в модуль apt то этот модуль должен уметь работать со списками.
иначе будет ошибка. тоесть если мы подставляем переменную в модуль
то модуль должен уметь сам разбивать список на элементы.


     - name: print loop with_items
       debug:
          msg: "{{ item  }}"
       with_items:
            - [1,2]
            - [a,b]
       tags:
          - d


теперь посмотрим что напечатает переменная item 
которую образовали через with_items

TASK [print loop with_items] ********************************************************************************************************************************
ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2
ok: [machine1] => (item=a) =>
  msg: a
ok: [machine1] => (item=b) =>
  msg: b
  
видно что при печати печатается тлоько один элемент из всего массива
за раз. это значит что если бы мы подставли item не другой модуль 
например apt то модуль абсолютно может быть тупой и не уметь работать
со списками или дикшионари. так как ему with_items скармливает всего
один элемент из всего массива за раз.

в этом и есть фундаментная разница между влиянием классической переменной
если мы ее пихаем в модуль и перменной образованной с помощью with_items

еще раз : если мы используем классическую переменную в моделу то внутрь модуля вываливается весь массив за раз. и это уже проблема самого модуля умеет он работать с масивами или нет.  а если мы исмпользуем переменную item которую создает with_items то внутрь модуля вываливаеися 
только один элемент массива. поэтому модуль может быть очень тупой.
модуль небудет иметь представления обо всем массиве. он всегода будет 
втидеть только один элемент.

что еще важно заметить.  если при описании with_items
мы используем список

 with_items:
            - [1,2]
            - [a,b]
			
то в выводе мы видим НЕСПИСОК. 

ok: [machine1] => (item=1) =>
  msg: 1

мы видим как бы просто скалярный элемент.
хотя было бы логично что мы увидим один элемент но это был бы тоже список.
но нет. мы виим чисто скалярный элемент.
почему это важно. почему важно что элемент печатаемый это не список.
потому что чуть ниже мы попробуем напечатать нулевой элемент item[0]
и мы получим ошибку. потому что item[0] означает напечатай нулевой элемент списка item. так вот так как item это несписок то будет ошибка. 



     - name: print masha[0]
       debug:
          msg: "{{ masha[0]  }}"
       tags:
          - d


смотрим печать нулевого элемента переменной masha 


TASK [print masha[0]] ***************************************************************************************************************************************
ok: [machine1] =>
  msg:
  - apache2
  - mc

полученный результат логичен.


далее смотрим нулевой элемент переменной item

     - name: loop
       debug:
          msg: "{{ item[0]  }}"
       with_items:
            - [1]
            - [a]
       tags:
          - d


и получаем ошибку. и это тоже логично. потому что item это не список как это было видно чуть выше. а нотация item[0] просит напечатать нулевой элемент списка, а item еще раз этонесписок. поэтому ошибка. item это типа скаляр.

--
теперь когда мы в деталях поняли в чем разница между
классической перменной 

vars:
  vasya: 1 
  
и переменной item образованной с помощью with_items
  
  
мы поняли что item образованной через with_items
это скаляр. это несписок состоящий из одного элемента, не дикшонари,
это скаляр из одного элемента.

with_items полностью аналогичен циклу 

for i=
end

а item в нем играет роль индексной переменной i


теперь можно переходить к with_nested

берем такой код

   - name: print with_nested
       debug:
          msg: "{{ item }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]



и посмотрим что покажет вывод

TASK [print with_nested] ************************************************************************************************************************************
ok: [machine1] => (item=[1, u'a']) =>
  msg:
  - 1
  - a
ok: [machine1] => (item=[1, u'b']) =>
  msg:
  - 1
  - b
ok: [machine1] => (item=[2, u'a']) =>
  msg:
  - 2
  - a
ok: [machine1] => (item=[2, u'b']) =>
  msg:
  - 2
  - b

откуда видно что за один раз with_nested он в item подставляет
список (уже список а не скаляр!) и видно что with_nested аналогичен
вложенным циклам 

for i=
  for j=
  end
end


соотсветсвенно если мы вот такой код запилим


     - name: print with_nested
       debug:
          msg: "{{ item }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]
         - [ '#','#']


то вложенный цикл уже будет тройной. аналогичен циклу

for i=
 for j=
   for k=
   end
 end
end


ну а в переменную item будет подставляться список из трех элементов
например

ok: [machine1] => (item=[2, u'b', u'#']) =>
  msg:
  - 2
  - b
  - '#'


теперть мы знаем что подставлят в item цикл with_nested.
поскольку в данном случае item это список то мы можем оперировать
элементами уже этого списка. например

берем такой кусок кода



     - name: print with_nested
       debug:
          msg: "{{ item[0] }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]


и смотрим вывод

TASK [print with_nested] ************************************************************************************************************************************
ok: [machine1] => (item=[1, u'a']) =>
  msg: '1 '
ok: [machine1] => (item=[1, u'b']) =>
  msg: '1 '
ok: [machine1] => (item=[2, u'a']) =>
  msg: '2 '
ok: [machine1] => (item=[2, u'b']) =>
  msg: '2 '

таким образом у нас печатался не весь item целиком. а только его нулевой 
элемент.

опять же подчеркну что такой фокус с item[0] неработае с циклом with_items
потому что тот подставляет в item несписок из одного элемента а просто скаляр из одного элемента. тоесть item у with_items это не список.
а item у with_nested это список. 
в этом вчастности разница между with_items и with_nested

вот эта вот тем в чем разгица мжду классической перменоой и перемпной
item которая образуется через with_items\with_nested нигде неописано. а 
это оченть важно.


=========================================
а еще можно вот такой прикол сделать
можно в with_items данные ввести не руками стаические а через 
переменную


  vars:
     kuku:
      - 1
      - 2


    - name: print one more with_items
       debug:
           msg: "{{ item }}"
       with_items:
         - "{{ kuku }}"


интересный кусок здесь 

       with_items:
         - "{{ kuku }}"


распечатка на экране будет 

TASK [print one more with_items] ****************************************************************************************************************************
ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2


тоесть with_items абсолютно корректно в себя всосал список через перменную kuku

==================================

далее посмотрим на еще один цикл with_subelents

код такой

  vars:

     kuku2:
       - name: vasya
         database:
           - a
           - b

       - name: petya
         database:
           - c
           - d


   tasks:
   
     - name: print with_subelements
       debug:
           msg: " {{ item }}"
       with_subelements:
          - "{{ kuku2 }}"
          - database


вывод на экран

TASK [print with_subelements] *******************************************************************************************************************************
ok: [machine1] => (item=[{u'name': u'vasya'}, u'a']) =>
  msg: ' [{u''name'': u''vasya''}, u''a'']'
ok: [machine1] => (item=[{u'name': u'vasya'}, u'b']) =>
  msg: ' [{u''name'': u''vasya''}, u''b'']'
ok: [machine1] => (item=[{u'name': u'petya'}, u'c']) =>
  msg: ' [{u''name'': u''petya''}, u''c'']'
ok: [machine1] => (item=[{u'name': u'petya'}, u'd']) =>
  msg: ' [{u''name'': u''petya''}, u''d'']'


он берет vasya и пробегает по a, b
потом берет petya и пробегает по c,d

пробегает он по тому полю которое мы указали в данном случае 
это database

в итоге item будет такими

item:
  - name: vasya
    a: null
	
item:
  - name: vasya
    b: null


item:
  - name: petya
    c: null
	
item:
  - name: petya
    d: null


соттвесвтенно если item имеет такую структуру - список
то можно обращатся к отдельным элементам этого списка через

item[0]

и

item[1]

соттвесвтенно если мы чуть изменим код


     - name: print with_subelements
       debug:
           msg: " {{ item[0].name }}, {{ item[1] }}"
       with_subelements:
          - "{{ kuku2 }}"
          - database


то получим красивый вывод

TASK [print with_subelements] *******************************************************************************************************************************
ok: [machine1] => (item=[{u'name': u'vasya'}, u'a']) =>
  msg: ' vasya, a'
ok: [machine1] => (item=[{u'name': u'vasya'}, u'b']) =>
  msg: ' vasya, b'
ok: [machine1] => (item=[{u'name': u'petya'}, u'c']) =>
  msg: ' petya, c'
ok: [machine1] => (item=[{u'name': u'petya'}, u'd']) =>
  msg: ' petya, d'
  
 
 также какойто дебильный прикол в with_subelements
 
 
 если kuku2 
 будет иметь вид
 
  kuku2:
       - "vasya"
         database:
           - a
           - b

       - "petya"
         database:
           - c
           - d

то ансибль выдаст ошибку при обработаке через with_subelemts

а вот если вместо "vasya" и "petya"
мы вставим дикшонари

 kuku2:
       - name: vasya
         database:
           - a
           - b

       - name: petya
         database:
           - c
           - d

то оно отработает нормально.
непонятно чем vasya хуже name: vasya


==================================================

 в продолжение темы переменные vs with_items

вот кусок

- name: install jre
  apt:
     name: "{{ item }}"
     state: present
  with_items:
      - openjdk-8-jdk
      - openjdk-8-doc
    
как мы уже знаем модуль apt может совершенно тупой от него нетребуется умения
работать с списками или дикшионари потому что with_items будет вставлять в item
одиночное значение. и вызывать apt несколько раз.


соверщенно другой случай показан внизу

- name: install jre
  apt:
     name:
        - openjdk-8-jdk
        -  openjdk-8-doc
     state: present

хотя он визуально похож на предыдущий случай но разница колоссальная.
во первых нет with_items 
и во вторых мы сразу в apt засунули весь список целиком.
поэтому apt просто обязан уметь работать со списками. разбивать список на элементы.

поэтому два куска кода визуально похожи друг на друга но они 
соверщенно по разному кормят apt

-------
выяснилось  что когда обращаетмя к переменной через {{ }} то можно подставлять внутрь 
неетолько имя переменной например

{{ vasya }}

но и данные напрямую

{{ ['a','b','c' ] }}


- name: test
  debug:
      msg: "{{ ['a','b']  }}"


========================================

 ансибл по архитектуре все же ебнутный язык или как оно там
 официальнро называется.
 
 есть такие штуки которые непонятно чем они являются как структура в нем
 например.
 
 есть плейбуки.
 
 в нем есть модули.
 в нем есть переменные.
 
  а вот такие хрени как
  
  hosts: ....
  remote_user: ....

что это за структуры? чем глубже занимаешься ансиблем тем в этом плане
возникает много вопросов.


еще вот эта ебнутая вещь что переменные можно пихать в миллион мест.
и при этом запомнеить какое место перебивает какое хер запомнишь.
это непрактично. мне нет времени запоминать эту херню.

============================================

те перменные которые мы определыяем в плейбуке через 

vars:

относятся к  host variables

а (как я понял) такие штуки как  

hosts:

это переменная но другого типа - connection variable.

мозгоебки в архитектуре ансибля много

это пиздец какойто - есть facts, hostvars, есть inventiry vars, есть magic variables, 
connection varibales.. такой курятник. и эти пременные можно запихнуть в 100 разных мест.
а потом еще думать какой файл с перменными перебьет какой...
блядь... архитектура. какие куры это придумали.

а эта ебала что remote_user в плейбуке это одно и тоже что и  ansible_user в inventory
и это тоже самое что ansible_ssh_user в inventory. => нахуя это все так было размножено.
к чему этот миллиард сущностей об одном и томже
==========================================================

я скажу так про эти ебнутые переменные в ансибл.

есть переменные которые помогают ансиблю подключиться по ssh к  хосту.
а есть переменные которые связаны уже с данными которые мы юзаем в плейбуках
который будет запущен на хосте ( тоесть мы уже к хосту смогли поюключиться)
таким макаром мы поняли что переменные делятся на две группы по их назначению.

далее важно что переменные можно указать в плейбуке а можно таукже в совершенно в
другом файле - в инвентори, или еще в другом месте - в папке group_vars\host_vars
таким образом мы поняли что переменную можно засунуть в разные места чисто физически.

далее важно понять что если мы обьявляем переменную 
в плейбуке то синтаксис ее описания там  зависимости от назначения переменной 
переменная которая несвязана с параметрами ssh подключения ансибля к хосту
прописывается в плейбуке через

vars:

а переменная которая свяазана с параметрами ssh подключения ообявляется совершенно 
по другому. а именно такая переменная неимеет никакой доп секции   в плейбуке 
а просто указывется в шапке плейбука. тоесть вся та хрень которая указана в плейбуке
до поля 

tasks:

это указаны ssh коннекшн переменные.

как тебе такой курятник в архитектуре? похоже на женскую сумку если открыть и там 
полный бардак.

пример

- name: play 1
  remote_user: vagrant
  become: yes
  hosts: all
  tasks:
  ....
  
  
  многое из того что  между name и tasks это  переменные ssh коннекшена.
  в данном примере конкретно это 
  
  remote_user: vagrant
  become: yes
 
  
  а далее уже практический момент ради чего все это разбирается.
  скажем нам надоело в каждом плейбуке каждый раз писать эту хрень одну и туже.
  мы хотим обьявить эти переменные глобально для всех хостов сразу где "повыше"
  а не в плейбуке. тоесть вопрос куда засунуть 
  
  remote_user: vagrant
  become: yes

 чтобы неуказывть это в каждом плейбуке.
 
 как уже напиал выше переменные любые неважно какоеих назначение помимо плейбука 
 можно обьявить и в других местах. например в inventory файле.
 и тут очередной "гениальный" момент. название ssh конекшн переменной из плейбука
 когда мы ее хотим перенести в инвентори имеет другое название.
 
 вот эта ссылка которая связывает название в плейбуке с названием в инвентори
 
 https://github.com/ansible/ansible/blob/c600ab81ee/lib/ansible/playbook/play_context.py#L46-L55
 
 из чего следует что remote_user в плебйуке это 'ansible_ssh_user'или 'ansible_user'
 в инвентори.
 
 аналогично become в плейбуке это ansible_become в инвентори.
 
 
 итак в инвентори файле мы напишем вот так
 
 
  ansible_user: vagrant
  ansible_become: yes

но это немножко недостаточно. еще в инвентори для переменных надо указать 
к какой группе хостов мы это относим или какому конкретному хосту.
в данном случае я хочу для всех хостов. значит это группа all ну и в итоге
в инвентори это будет вынглядет вот так

[all:vars]
ansible_ssh_user=vagrant
ansible_become=yes


немноговато ли мудежа на пустом месте.

если мы хотим тоже самое перенести в папку group_vars то это будет выглядет так

# cat ./inventory/group_vars/all

ansible_ssh_user: vagrant
ansible_become: yes

опять заметим мудеж и здесь. уже вместо '=' надо юзать ':'

=====================================================
каким бы макаром переменная нибила обьявлена дока ансибля пишет что перед тем как
плейбук начнет выполняться все переменные прибиваются\разворачиваются\привязываются
 к конечным хостам , тоесть перед выполененнием плейбука каждый хост получает
 полный набор переменных которые ему полагаются.
 
======================================================
дока ансибля пишет что ихняя рекомендация чтобы переменные нехранили в инвентори файлах
а хранили отдельно. либо в плейбуке либо в group_vars\host_vars папках. главное чтоб отдельно
чтобы несмешивать список хостов и их переменные.

окей будем стараться так и делать

хотя по мне переменные которые относятся именно к хостам. например
скажем в инвентори такая строчка


machine1  ansible_ssh_host=192.168.61.11 ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key

так вот переменные которые относятся прям к хосту их логиченее хранить
сразу в инвентори файле рядом с именем хоста, типа так нагляднее.
смысл хранить ее отдельно?

получается что вместо того чтобы в одном файле иметь и список хостов\групп хостав + тутже 
их переменные тоесть все в одном месте мы будем иметь миллион файлов. информация будет
разбосана по миллиону разных мест.

пример

ивентори файл в котором только список хостов\групп хостов


[servers]
machine1
machine2



[build_agents]
machine1


[cassandra]
machine2


файл в котором переменные которые относятся к группе хостов

# cat ./inventory/group_vars/all

ansible_ssh_user: vagrant
ansible_ssh_private_key_file: /home/mkadm/.vagrant.d/insecure_private_key
ansible_become: yes

тоесть здесь мы указали где ансиблю брать ключ ssh , под каким юзером ходить на
хосты по ssh, и то что всегде для всех хостов юзать супер пользователя.
таким образом эту хрень ненужно каждый раз вставлять для каждого хоста в инвентори 
файле , вот как это было до этого , как выглядел инвентори файл


[servers]
machine1  ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key ...
machine2  ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key ...


тоесть полная мудота

далее файлы с инвидидуальными переменными хостов

# cat ./inventory/host_vars/machine1

ansible_ssh_host:   192.168.61.11

# cat ./inventory/host_vars/machine2

ansible_ssh_host:   192.168.61.12

раньше этот параметр ansible_ssh_host прописывался в инвенторти файле , таким
образом

[servers]
machine1  ansible_ssh_host=192.168.61.11 ansible_ssh_private_key_file=/home/mkadm/.vagrant.d/insecure_private_key ...


теперь все разделено.
файл со спсоком хостов отдельно.
переменные которые применяются к группе хостов заснуты в отдельный файл
переменные которые применяются к отедбьному хосту засунуты отдельно.

полное разделение данных по разных местам\файлам

при таком подходе плейбук выглядит также компактно.

вот как было:

# cat play.yml

- name: playbook
  hosts: all
  remote_user: vagrant
  become: yes
  tasks:
    ...

как стало

# cat play.yml


- name: playbook
  hosts: all
  tasks:
    ...

ненужно каждый раз как обезьяна прописывать remote_user и become.

получается что если у нас есть переменные ssh конекшена то их логичнее
неписать в плейбуке потому что они не являются по природе относящимися именно к 
плейбуку они относятся к свойствам самих хостов например переменная под каким логином
стучать на хост по ssh , так вот таким переменные логично убрать из плейбука
и унести в group_vars папку. почему унести именно в group_vars. потому что плейбук
применяется к группе хостов. значит переменную надо унести именно в группу переменных
значити в group_vars.

поэтому remote_user и become отличные кандидаты на перенос из плейбука в group_vars

с друнгой стороны все переменные которые по приоде происходят именно для данного 
плейбука логично оставить именно в плейбуке (по мне) потому что если  мы будем к группе
хостов применять другой плейбук то переменные из перврого плейбука ко второму плейбуку
неимеюти никакого отношения. поэтому захер им лежать в group_vars папке.

тоесть архитектурные вопрос групповые переменные их куда праивльнее пихать в плейбук
или в group_vars

еще с другой стороны: инвентори файл у нас имеется изначально. берется от нашей структуры
железной. плейбук мы качаем отткуда то из интернета. далее мы натравливаем этот плейбук
на наш инвентори файл\файлы. тоесть инвентори файл родился от одной штуки - от нашей физ 
структуры. а плейбук родился от другогого источника от интернета.  и возникает 
вопрос а переменные то куда пихать в group_vars или в плейбук ?
и здесь еше раз я думаб надо делать так:
   - те переменные которые относятся по своей приоде к свойствам хостов,
     например ssh логины, ssh порты, ssh IP адреса = эти переменные надо прописывать
	 в group_vars\host_vars.  
	 смысла их пихать в плейбук нет. плейбуки будут менятся  а эти переменные они остаются
	 неизменными. потому что порождены хостами а не плейбуками.
	 
   - те переменные которые по приоде рождены конкретным плейбуком их ненужно пихать в
      group_vars\host_vars. так как при смене плейбука мы на хосте будем иметь кучуненужных
	  переменных. зачем нам это. такие переменные надо пихать именно в плейбук. 
	  (или в роли плейбука).
	  
таким образом отвечено на вопрос "когда переменную пихать в group_vars\host_vars а когда
в плейбук". ну а типа согласно доке ансибля в сам инвентори файл типа переменные
лучше вобще непихать. там тока список хостов.

вот такой мудеж в ансибле
=======
	  
что еще интересно.

вот у нас есть инвентори файл

5$ cat ./inventory/hosts



[servers]
machine1
machine2




[build_agents]
machine1


[cassandra]
machine2

[db]
machine2
db2


как видно к примеру хост db2 входит в группу [db]
фишка в том что в плейбуке я могу указать хост db2

- name: play1
  hosts: db2
  
 и плейбук будет выполнять только для хоста db2. 
 фишка в том что  в инвентори файле нет нужды указыывать db2 отдельно вне группы.
 
 это удобно. это умно.
 
 потому что в книжках обычно приучают что в инвентори файле вначале надо указать 
 все хосты отдельно без вхождения в группы. 
а только потом уже их в составе групп. типа как бы они навязывают что в  инвентори
файле в шапке якобы должы быть перечислены все хосты без вхождения в группы.
оказывается это ненадо.
===========================
 
дальше.

очень недобно сделано с переменными  в ансибль

удобно когда можно переменные записать в одном файле. и потом
чтобы плейбуки их читали .
тоесть удобно имет все перменные котоыре относятся ко всем плейбукам
не в плейбуках  а некотором файле. а плейбуки завставить этот файл чиатть 
и из него брать данные.

пример


файл с переменными лежит на 

$ cat ./vars/vars.yml
mysql_root_pass=123

rails_user=rails
rails_pass=456

appservers_ip=['192.168.61.11','192.168.61.12', '192.168.61.15']


далее в плейбуку мы читаем знаения переменных из этго файла



$ cat db-play.yml
---


- name: install db
  hosts: db2
  
  vars:
    rails_pass:   "{{ lookup('ini', 'rails_pass type=properties file=./vars/vars.yml') }}"
    rails_user:   "{{ lookup('ini', 'rails_user type=properties file=./vars/vars.yml') }}"
    appservers_ip: "{{ lookup('ini', 'appservers_ip type=properties file=./vars/vars.yml') }}"


в этом плейбуке значения трех переменных считывается из файла с переменными.
очень удобно.

если таких плейбуков пять. то лазить в каждый и искать 
и править там значения переменных это дебилизм.


а так кодга у нас переменные происаны в однмо файле а плейбуки 
из него их читают это уже хорошо.


также замечу что в файле с переменными показан хороший пример переменной
типа список

вот таким макаром мы там можем прописать переменную типа список

appservers_ip=['192.168.61.11','192.168.61.12', '192.168.61.15']

дело втом что файл спеременныии мы читаем плагином ini
поэтому обьявление переменных в ini формате имеет особенности.


===

что пока енпонятно :
чтобы можно было обьявить переменную которую ансибль соберет динамически
из нескольких переменных.

пример.

каждый хост в инвентаре имеет переменую ansible_ssh_host

предположим нам нужно узнать все ansible_ssh_host для хостов которые входят
в группу app_servers.

в плейбуке это можно посмотреть вот так

    - name: print ssh ip addrress for hosts in app_servers group
      debug:
          var: hostvars[item].ansible_ssh_host
      with_items:
         - "{{ groups.app_servers  }}"

на экране получим

ok: [db2] => (item=appserver) => {
    "ansible_loop_var": "item",
    "hostvars[item].ansible_ssh_host": "192.168.61.11",
    "item": "appserver"
}
ok: [db2] => (item=centos) => {
    "ansible_loop_var": "item",
    "hostvars[item].ansible_ssh_host": "192.168.61.12",
    "item": "centos"
}


вопрос как из этих отдельных высеров сформировать единую переменную
вот такого вида

a:
 - "192.168.61.11"
 - "192.168.61.12"
 
======

про hostvars

что это такое.

это переменная. это ее имя.

она встроенная , ее формирует сам ансибль . 
и она привязывается не к хосту а к  плейбуку целиком.


еще раз. индивидуально на хосте ее нет.
она одна на весь плейбук.
у нас же обычно переменные привязаны к хосту в плейбуке.
а эта переменная особенная. она выще этого. она привязыватся к плейбуку.
и внутри себя содержит все перменные для всех хостов. 
типатакая мегапеременная.
единсвтенное что она несодержит кастомные переменные которые мы определяем сами.
она содержит переменные которые модуль setup собирает с хостов.

чтобы узнать значение переменной с "имя_переменной" которая прописана 
на хосте с именем "имя_хоста" то в hostvars это можно найти по адресу

{{ hostvars[имя_хоста].имя_переменной }}

например переменная ansible_ssh_host на хосте db2

{{ hostvars[db2].ansible_ssh_host }}

еще раз отмечу что в hostvars находятся только те переенные которые ансибль 
определяет и собирает сам с хостов через выполенние модуля setup.
наших собственных переменных которые мы опредяем в плейбуках в hostavars нету.
это важно понимать

далее хитренький пример.
хотим узнать ip адреса по которым ансибль по ssh обращается к хостам

    - name: print ssh ip addrress for hosts in app_servers group
      debug:
          msg: "{{ hostvars[item].ansible_ssh_host }}"
      with_items:
         - "{{ groups.app_servers  }}"


во первых мы в этом примере испольщуем еще одну встроенную переменную анстбля {{ groups }}
но это не главное. главное это как мы прописали item.
мы привыкли что обращение к переменной в ансибле идет через скобки да еще 
с кавычками

"{{ имя_переменной }}"

поэтому интуитивнро хочется написать вот так


          msg: "{{ hostvars["{{item}}"].ansible_ssh_host }}"
ну или вот так
          msg: "{{ hostvars[{{item}}].ansible_ssh_host }}"

но это все несработает. выдаст ошибку. 
почему - незнаю.

почему то item в hostvars надо прописвыать в виде просто item
	msg: "{{ hostvars[item].ansible_ssh_host }}"

почеу незнаю. но это факт. обращение к имени переменной идет без скобок

кстати говоря в модуле debug вместо msg можно воспользоваться var
и тогда даже hostavars - это же тоже имя переменной оно тоже будет указывать без 
скобок.


    - name: print ssh ip addrress for hosts in app_servers group
      debug:
          var: hostvars[item].ansible_ssh_host
      with_items:
         - "{{ groups.app_servers  }}"


почему надо так - незнаю.
вобще эта дебилистика в ансибле что в одних случаях к переменной обращается со скобками
да еще в кавычках "{{ имя_переменной }}" а в других случай и без всего  имя_ переменной
по мне это очень дебильно. но у них так.

кстати когда юзать msg а когда var  в debug.
по мне var это чисто когда мы хотим напечать значение переменной и все.
а msg это когда мы хотим напечать вообще все что угодно. более расширенный функционал.


====
закончил на том что :
1) как я вроде выяснил ансиблю создает переменную hostvars в которой
находятся все переменные от модуля setup который он прогоняет в начале
заупска плейбука в которой содержатся пременные от ВСЕХ ХОСТОВ которые есть в 
инвентори!
да. шок именнов этом. в плейбуке может быть указан всего один хост конкрнетный
из инвентори. а ангсиблю прогоняет setup походу пьесы на всех хостах.

но я неомгу этопроверить потому что я хочу записать эту переменную в файл
чтобы споконйо просмотреть. и немогу
так как  copy + delagete_to приводит к идиотской ошибке 

 "Failed to get information on remote file 
 
 адалее в плейбуке app_server я хочу либо через hostavrs либо 
 через 
 
 tasks:
    - name: Gather facts from db servers
      ansible.builtin.setup:
      delegate_to: "{{ item }}"
      delegate_facts: true
      loop: "{{ groups['dbservers'] }}"
	  
	заполучить ansible_ssh_host для app_servers хотя плебйук запускаб для db2
	и подавстиь все это в mysql_user
	
	====
	



