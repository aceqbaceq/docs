ansible

заметки


поговорим про mysql
вот мы его поставили и по дефолту у root юзера пароль пустой.
также напоминаю что у mysql доступ происходит нетолько по 
login+пароль как обычно бывает у программ а еще 
подключается фактор с какого хоста идет коннект от клиента
тоесть у mysql авторизация идет на основе
login+пароль+хост с которого звонят

поэтому в базе mysql логин как бы выглядит в виде

root@hostname пароль

так вот для после установки mysql пароль для

root@localhost
root@127.0.0.1

он пустой.

тоесть зайдя на хост с mysql в него можно войти как

# mysql -u root

все пароль ненужен.


так вот переходим  к сути .
мы хотим через ансибл поменять пароль для root@hostname

а именно для

root@localhost
root@127.0.0.1
root@::1

для этого мы пишем кусок ансибл кода



  - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       when: root_pass.changed


так вот этот код несработает. и я щас обьясню почему.
собсвтенно весь этот кусок текста посвящен тому чтобы обьяснить почему
он не сработает. точнее он сработает частично и вылетит с ошибкой

во первых проясню поля

name:
password:
host:

это не логин и пароль под которым ансибл стучит на mysql чтобы получить
к нему доступ. для этого у модуля mysql_user есть другие поля такие как
login_user
login_password
login_host

так как мы их неуказали в mysql_user то по умолчанию как я понял ансибл
примает по дефолту что

login_user=root
login_password=пусто
login_host=localhost

а поля
name:
password:
host:

прописывают совершенно другое , они используются недля аутентификации
а указывают что менять в базе после того как мы к ней подключились.


так как изначаьно mysql нетребует пароля для root@localhost
то 

так вот кусок ансибля наверху он будет пытаться поменят пароль для

root@localhost
root@::1
root@"{{ inventory_hostname }}"
root@127.0.0.1

при этом он будет подлючаться к базе используя login_user=root, login_host=localhost и пустой пароль. 

значит как mysql_user модуль  будет действовать,
1. он попыватется подлючиться к базе без пароля и у него
это получится и далее он поменяет пароль для 

root@localhost

это все пока успешно.

далее как я понимаю либо ансибл отключается от базы либо база сама выкиывает ансибл от себя так как пароль для root@localhost стал непустым.
в любом случае 

на втором шаге ансибл опять пытается подключиться к базе без пароля 
тоесть как 

login_user=root
login_password=пусто
login_host=localhost

и ОПА! у него больше это неполуится так как не предыдущем шаге мы сами установили непустой пароль для root@localhost. ВСЕ! ансибль больше неможет
подлкючться к базе и делать дальнейшие изменения какие бы то ни было.

вот поэтому кусок кода вверху он вылетит с ошибкой.

так  что в частности работа с with_items это когда ансибл делает последовательно одно тоже но шаг с шагом. напервом шаге берет первое значение и прогоняет , потом второе и прогоняет тоже самое то есть with_items это классической цикл.

тоесть mysql_user в связке с with_items он не применить одну какую то мегакоманду которая за одну mysql транзакцию единовременно изменит сразу 
несколько ячеек в базе mysql. нет такого небудет. 
за первуб транзакцию к mysql изменится одна ячейка root@localhost
потом начнется вторая транзакция за которую должна была быть измнена ячейка root@::1 и так далее.

таким образом как конкрентно работает ансибл с with_items разобрались.
как классический цикл. берет первое значение и делает то что с ним сказано, потом берет второе значение и делает то что сказано. потом третье. а не так что берет сразу первое второе и третье и делает единровременно с ними мегатранзакцию.


про механизм обработки ансиблем with_items разобрались.

возврашается к изначальной задаче. так как же ее сделать.

ответ вот как.


в два прхода

за первый проход мы обращается к базе без пароля
и меняем пароль для root@localhost

  - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
	        - localhost
       when: root_pass.changed


теперьмы к базе по старому без пароля подключиться неможем.
потому что локальный питон скрипт крутится на хосте с mysql и поэтому он обращается от имени root@localhost

значит на следующем щаге нам нужно стучаться к базе используя пароль.

это можно сделать двумя путями.
либо в mysql_user модуле прописать 
login_user=root
login_password=пароль
login_host=localhost

либо можно на хосте где крутится mysql записать файл /root/.my.cnf 
вот такого вида

[client]
user=root
password=пароль

и тогда в mysql_user модуле можно не прописывать login_user, login_passwrd,login_host потому что этот модуль он по умолчанию ищет
~/.my.cnf и если его находит то читает креды оттуда

так что финальный кусок когда выглядит так


# обращаемся к базе без пароля и меняем его толко для root@localhost
 - name: mysql change root@localhost password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
            - localhost
       register: root_pass

# записываем .my.cnf
     - name: save  .my.cnf on remote host
       template:
         src: templates/mysql/my.cnf
         dest: /root/.my.cnf
       when: root_pass.changed


# меняем пароль для остальных 
# 	root@::1
# 	root@"{{ inventory_hostname }}"
# 	root@127.0.0.1 , 
# модуль при автоматом читает .my.cnf 
# и обращется к базе уже через пароль
     - name: mysql change root@*  password
       mysql_user:
          name: root
          password: "{{ var1 }}"
          host: "{{ item }}"
          state: present
          login_unix_socket: /var/run/mysqld/mysqld.sock
       with_items:
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
       when: root_pass.changed

также может возникнуть хитрожопая мысль. а может нам надо 
просто хитро перегруппировать 

            - localhost
            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1


вот эти вот штуки чтобы все таки можно было все сделать за один раз. 
например вот так

            - ::1
            - "{{ inventory_hostname }}"
            - 127.0.0.1
            - localhost


у меня не сработало.
как только система установила пароль для root@127.0.0.1
то она уже немогла подключиться к базе без пароля 
такое ощущение что для mysql root@localhost эквивалентен root@127.0.0.1
поэтому меняя пароль для одного автоматом ты его установил и для другого.

в одной умной книге по ансибл этот тонкий момент 
вообще нифига не освящен а указано что якобы можно все сделать за один 
проход.


конец.

---

ansible стоит на yaml

в yaml есть типы данных
dictionary
и  mapping

dictionary
это

- 1
- 2
- 3

mapping 
это
a: 1
b: 2

так вот нам надо уметь получать доступ к элементам этих штук
например 

имеем вот такую переменную


 var1:
         a: 1
         b: 2
         c:
           - a
           - b
           -
             elk: stack
             abc: d


так вот. если мы хотим получить доступ к элементу маппинга
то ставим точку и пишем имя маппинга

var1.a = 1
var1.b = 2
var1.c = [ a, b, { elk: stack, abc: d ]


НО! такой фокус непрокатывает когда мы хотим получить доступ 
к элементу dictionary
как я понял тут только прокатывает доступ через порядковый номер

var1.c.0 = a
var1.c.1 = b
var1.c.2 =  { elk: 'stack', 'abc': 'd'}"

ну и последний пример

var1.c.2.elk= stack

значит если мы где то видим обращение к переменной вот такого вида

a.b

это значит что переменная а содержит маппинг вида

a:
  xxx:yyy
  b: ...
  zzz: uuu
  
а если мы видим переменную вот такого вида

a.0

это значит что переменная a имеет вот такой вид

a:
   - ...
   - .....
   - .......
   
   
   
 вот еще переменная a имеет вот такой вид
 
 

changed: false

msg: "u'All items completed'"

results: 
  - 
    ansible_loop_var: u'item'
    failed: false
    item: u'localhost'
    u'changed': false
    u'invocation': 
      u'module_args': 
        u'append_privs': false
        u'ca_cert': None
        u'check_implicit_admin': false
        u'client_cert': None
        u'client_key': None
        u'config_file': u'/root/.my.cnf'
        u'connect_timeout': 30
        u'encrypted': false
        u'host': u'localhost'
        u'host_all': false
        u'login_host': u'localhost'
        u'login_password': None
        u'login_port': 3306
        u'login_unix_socket': u'/var/run/mysqld/mysqld.sock'
        u'login_user': None
        u'name': u'root'
        u'password': u'VALUE_SPECIFIED_IN_NO_LOG_PARAMETER'
        u'priv': None
        u'sql_log_bin': true
        u'state': u'present'
        u'update_password': u'always'
        u'user': u'root'
    u'msg': "u'User unchanged'"
    u'user': u'root'

warnings: 
  - "u'Module did not set no_log for update_password'"
  
  
  
  
 тогда мы можем получить доступ к ее элементам в таком виде
 
 a.changed
 a.message
 a.results
 a.results.0.ansible_loop_var
 
 
===

подлянки ansible

модуль unarchive

- name: Extract  
  unarchive:
    src: 1.tar.gz
    dest: /var/lib/vasya
	
если dest папка несуществует тогда модуль несможет разархивировать
и будет выдавать такую тупую ошибку


"/bin/gtar\" could not handle archive. 
Command \"/usr/bin/unzip\" could not handle archive."


еще раз скажу причина совсем вдругом. несуществует dest папки.  а
без этого модуль неможет.
нужно создать dest папку и все сразу станет отлично

==

модуль file

- name: create nginx directory
  file:
    path:  "{{ wp_docroot }}"
    state: directory
    owner: "{{ wp_owner }}"
    group: "{{ wp_group }}"
    mode: 0775

если переменная wp_docroot имеет такой вид:

doc_root: " /1/2/3 "

то есть в ней есть пробел  в конце и вначале
то модуль file напишет что он все сделал но по указанному 
пути папку НЕСОЗДАСТ.

как исправить. надо исправить переменную , убрать пробелы

doc_root: "/1/2/3"

вот теперь модуль file отработает нормально

==

в ансибль есть такая тема мудотная со скобочками.

сразу скажу что часть мыслй здесь неверная. 
верные мысли уже пришли позже внизу начиная со слов "нам необязательно использовать with_items"

тем не менее:
скобочками обозначаются переменные а еще dictionary и lists.

щас  я покажу как через скобки все эти штуки обозначаются.

но перед этим  типа ты спросишь а какая разница между переменной и dictionary

разве dictionary\lists это неразновидность переменной ? ведь и дикшонари и лист могут являться переменной.

захера их тогда по разному обозначать?

а еще у нас есть loops. их к чему отнести  - это  переменные, дикшнари или это списки ?

и как это все к скобкам возвращается в итоге ?

начнем :

в целом в ансибль мудота.

я бы сказал что такие структуры как dictionary и lists это несамостоятельные структуры в ансибль, они всегда являются частью 
чего-то. тоесть когда ты слышишь слово dictionary или list то этого недостаточно, это неговорит о назначении их применения. обьясняю.
в ансибль есть директивы , команды а есть данные. так вот dictionary 
и list они могут применяться как составная часть диркетив так и составная
часть данных. поэтому когда ты слышишь dictionary или list этого недостаточно, ты незнаешь идет ли речь о кусочке директивы или о 
кусочке данных.

это как например мороженое было бы нетолько еда а еще и стройматериал и часть животного. но нет. когда мы слышим мороженое то знаем что оно только еда и только еда. 

пример когда dictionary является частью ансиблбь команды, ансибль диркетивы

  debug:
      msg: "12"
	  
 в этом примере показана диркетива ансибля debug. dictionary является составной частью директивы. 
 
 еще пример
 
 vars:
    a: 1

в этом примере dictionary является частью некоманды а переменной.

таким образом dictionary и аналогично list помогают организоват совершенно разные структуры , как команды так и данные. а это совершенно разные веши.

получается дикшонари или список это кусок кода в общем и целом неизвестно что обозначающий но оформленный по орпделенному синтаксическому
правилу.

для словаря это правидло выгдядит как

a: значение-1
b: значение-2

значение может быть сложное выражение

список выглядит при оформлении как

- значение-1
- значение-2

значение может быть сложное выражение


возврашаемся к скобкам. 
словари и списки могут иметь бесскобочный вид. но всегда их можно преобразовать в экивалентный но вид скобочный. 
каждый дикшонари всегда можно преобразовать  его обозначение через { } скобки.

a: 1
b: 2

этот дикшонари имеет эквивалент обозначение через скобочный вид

{ a: 1, b: 2 }


каждый список подразумевает что его можно изобразить через скобочный вид.
используется [ ] скобки

- 1
- 2
- 3

имеет эквивалентный скобочный вид

[ 1, 2, 3 ]



скобочный вид и нескобочный они эквиваленты. просто когда то удобно 
внешне применить один а когда то другой. а так они равнозначны для машины.


ансибль использует эти синтаксические структуры для выражения своих команд\директив  а также для выражения своих данных.


- name: task 1
  debug:
      msg: "1"
	  
эта хрень напечатает "1" на экране. тоесть эта штука в целом это директива ансибля. его команда. в своем оформлении она выражена
через структуру список со сложным значением.


приведем это к скобочному виду

[ { name: task 1, debug: { msg: "1" } } ]

таким образом ансибливские команды используют списки и дикшонари 
как свои составляющие части как кирпичи.

но помимо использования словарей и списков как часть синтаксиса команд
они также юзаются для организации переменных тоесть данных. команды и переменные разные вещи

vars:
 a:1
 b:2
 c:
   - 1
   - 2
   
 
 в данном случае списки и словари используются не для организации команд
 а организации данных  , создания переменных.

таким образом когда мы слышим или видим что в куске ансибль файла встретился дикшонри или список то нам это ничего не говорит. участвует ли он в опписании команды или в создании переменной.

однако скобочки позволяют однозначно сказать внутри нее содержится списк или словарь.

[ ] = список
{ } = словарь

как выглядит конкретная команда в ансибль какие конкретно на содедржит комбинации списков и словарей зависиит от создателей команды.

при создании переменной мы можем внутрть нее напихать список или словарь любой сложности и вида. это уже зависит от нас.

так вот далее. некоторые команды позволяют внутри себя вставлять внутрь них переменные которые мы ранее определили тоесть другими словами вставлять данные. и тут важно понять что 
не все команды позволяют внутрь себя вставлять данные и эти данные вставляются в виде переменных, причем какая то команда принимает переменную только типа словарь а другая только типа список. 
таким образом важно понять 
а) не все команды позволяют вставлят в себя данные
б) данные втсвляются только через переменные а не голые списки и словари
в) команды обычно четко прорписыавет какого вида может быть переменная
внутри нее это либо только список либо тлько переменная.

как выглядит обьявление переменной мы уже видели

vars:
  a: 1
  b: { c: 3, d: 5 }
  
 а сейчас скажу как выглядит обращение к переменной внутри некоторой команды для примера
 
 debug:
    msg: "{{ a }}"
	
таким образом мы видим что переменная вызываетс через двойные скобки {{ }}
и только если комарнда поддерживает в соотствующем месте внутри себя
подстановку вместо значения переменной. причем перменная дожна иметь 
заранее определенный тип, либо словарь , либо спмсок.
нельзя в команду всавить переменную типа словарь если команда прддерживает  только тип список.

каки-то конмады поддеживают перменные обоих типов.

например команда debug

вот я определил три переменные

  vars:
     petya: mc

     vasya:
        name:  apache2
        state: latest

     masha:
         - 1
         - 2



и далее хотя они разного типа я могу их все распечатать командой debug

    - name: phase 0
       debug:
          msg: "{{ masha }}"


конкретно команде debug пофиг какого типа переменная. но другим командам нет в целом.


сущестенно то что вместо значения для подставновки данных мы 
используем переменную которую опредлили раньше.

 еще раз разница между переменной и словарь\список. 
 словарь и список они исопльзуются как его части при обьявлении переменной. переменная имеет имя. а например тот же самый список неимеет имени. 
 
 про перменную еще скажу важное когда мы ее вызываем через двойные скобки {{ имя }} то всегда надо ее брать еще и в двойные кавычки
 
 "{{ имя }}" потому что ансибль опирается на yaml интерпретор ( тот отрабатыавает первее ) а yaml интерпретатор ничего знает о синтаксисе кроме как для него весь текст это набор словарей и списков не более того 
 если он встречает в тексте скобки { или [ то он тогда считает что начинается словарь или список. поэтому чтобы заставить ямль интрепретор 
 условно говоря рассматривать {{ имя }} не как словарь внутри которого словарь условно говоря а набор литер то есть экранировать мы берем 
 {{ }} в кавычки. "{{ }}"
 
еще раз это так как ямль обрабыает текст первым и тлько потом его обрабатыавает ансибль интерпретоор. то надо заэкранировать кавычки потому что тогда ямль будет думать что он напоролся на словарь. короче неудачно выбраны символя для обозначения переменных в ансибл. таким макаром ямл пропускает этот кусок а ансибл когда дооходит до него очередь
уже понимает что это обращение к переменной.

дальше возникает вопрос. а можно как то скажем в debug засунуть не переменную а словарь например. 
 
 
  - name: phase 0
       debug:
          msg: "{ a: 1}"

ну в таком виде как я понимаю ансибл это все воспринимате просто как 
набор литер. и тут неидет речь о печати именно словаря а просто печается набор литер. 
на экране получим вот так

 msg: '{ a: 1 }'
 
 теперь убираем кавычки
 
 
  - name: phase 0
       debug:
          msg: { a: 1}


к счастю для нас команда debug она умеет печатать словари. так что
команда успешно прходит

на экране будет вот так

 msg:
    a: 1
	

как говорится почутвуй разницу

попробуем распечатать список

  - name: phase 0
       debug:
          msg: [ 1,2 ]
		  
		  
и debug со списками тоже успешно работает

на экране будет

  msg:
  - 1
  - 2


а теперь уже понятно что если мы попробуем таккую команду


 - name: phase 0
       debug:
          msg: "{ masha }"
		  
	то мы просто распечааем литеры
	
	 msg: '{ masha }'
	 
а если вот такую команду 


 - name: phase 0
       debug:
          msg: { masha }


то получим интересный резульат

 msg:
    masha: null

тоесть ансибль распечатал словарь в котором ключ=маша а значение не определено. опять же важно понимать что тут не шло обращение к переменной masha. шло обращение совсем к другой вещи.


и тут я подхожу еще к одной вещи это у loops
выглядят они вот так обычно

  - name: phase 1
       debug:
          msg: "{{ item  }}"
       with_items:
           - [ mc ]

на экране получим

 msg: mc
 
 что в тарабарщине лупов важно понять:  после with_items идут элементы
 списком. при этом как я понимаю директива with_items автоматом создает
 переменную с именем item  которая по своему типа это список и она содержит все эелменты списка которые указаны после with_items
 таким образом если мы в debug хотим обратиться к этим элементам
 нам надо обратиться к переменной items.
а раз это переменная то мы уже знаем как обращаться к переменным
                    "{{ item }}"
					
что мы и делаем 

msg: "{{ item  }}"

поскольку мы обращаемся к переменной то мы используем синтаксис 
"{{ имя }}"

соотсвтенно если мы вместо этого поставим

msg: "{ item  }"

то ансибль просто рапечатает набор литер  { item  }

а если вставим

msg: { item  }

то ансибль будет обращшатся не к переменной iten а печтать словарь
в котором ключ=item а значение = null

тоесть это совсем другая структура.

таким образом важно помнить что with_items невидимо и автоматом
создает переменную с именем item  к которой мы и должны обращаться 
через "{{ item }}"


таким образом надо понимать в какой команде какое поле может в себя принимать значение в виде
а) словаря напрямую
б) списка напрямую
в) переменную типа словарь
г) переменную типа список
д) переменную обоих типов.

это все от команды зависит конкретной.

например комнда apt

  - name: phase 2
       apt:
          name: { apache2 }
          state: latest


вот такой номер абсолютно непройдет. 
потому что мы в качестве имени пакета суем словарь. в котором
имя = apache2 а значение = null.

команде apt нужно только имя без всякий значений. он так и напишет 
что мы ему подсунули dict а ему нужно list

 а вот такая команду уже отлично пройдет
 
   - name: phase 2
       apt:
          name: [ apache2 ]
          state: latest

потому что здесь мы подуснули список.

а если мы будем подсовывать переменную 


   - name: phase 2
       apt:
          name: "{{ masha }}"
          state: latest

то надо обязательно чтобы эта переменная имела тип список.

далее.

нам необязательно использовать with_items 
чтобы создать переменную типа список для того чтоюбы потом ее использовать
можно и самому создать эту переменную

  vars:

     masha:
         - apache2
         - mc


 tasks:

     - name: A
       apt:
           name: "{{ masha}}"
           state: present


  apt абсолютно успешно сожрет переменную masha и поставить пакеты.
  для этого прям вот with_items необядательно использовать.
  
  таким образом with_items это никакой нахер не loop 
  это сопособ создавать переменную только в дебильном иносказщатительном
  запутанным способом. переменная будет иметь имя item и 
  иметь тип список.
  
  
  вот эти оба способа одинаковы

способ 1  
  
  vars:

     item:
         - apache2
         - mc

  

  способ 2

  with_items:
             - apache2
             - mc
			 
один прямой второй иносказательный.
в первом случае перменую можно ввызывать отовсюду
а во втором я неуверен что эта переменная может быть вызвана сто раз.


для модуля apt оба способы одинаковы.

   - name: A
       apt:
           name: "{{ item }}"
           state: present


и прикольно что модуль apt он умеет работать со списками.
ты ему кормишь ему список а он из него сам берет элемент за элементом.

это нето как раньше. содзал массив. а потом надо вызывать цикл чтобы 
из массива выбирать элементы поштучно чтобы их можньо было подсовывать 
уже другим командам.

хотя разница все таки есть между класиически созданной переменной
и переменной заданной через loop


  vars:

        masha:
         - [apache2,mc]
         - [zlib,nginx]





     - name: 234
       debug:
          msg: "{{ masha  }}"



выведет на экране

 ok: [machine1] =>
  msg:
  - - apache2
    - mc
  - - zlib
    - nginx


кстати apt с таким списком masha несможет работать.


     - name: loop
       debug:
          msg: "{{ item  }}"
       with_items:
            - [1,2]
            - [a,b]


выведет на экране

 ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2
ok: [machine1] => (item=a) =>
  msg: a
ok: [machine1] => (item=b) =>
  msg: b


все таки видна разница между двумя этими способами.
в первом случае debug типа получает себе врожу сразу 
весь ворох данных за один раз.

во втором случае как я понимаю дебаг ансиблем как бэ запускается многократно и каждый раз дебагу подсовывается новое значение.

поэтому with_items это чтото типа того вот такого



    - name: loop

начало цикла
       with_items: item= - [1,2]
                         - [a,b]

       debug:
          msg: "{{ item  }}"
конец цикла           
       
	  with_items это как бы классический for i
	  а внутри него тело цикла.
	  и получается как уже сказал что debug системой взывается 
	  много раз. и каждый раз дебагу подслвыается новое значение.
	  
	  

в случае же такой конструкции

     - name: 234
       debug:
          msg: "{{ masha  }}"


дебаг выщывается один раз. но он информацию полуает сразу всю целиком
всю скопом.

если в первом случае дебаг  за раз полуается всего одно значение.
то во втром случае дебаг получается сразу весь список.
соотвесвтенно в первом случае дебаг  моэеть быть тупым. то втором
случае дебаг доожен уметь сам работать со списками.

таким образом разница есть. и огромная. 

поэтому with_itenms это настоящий цикл for.

отсюда становится понятно почему вот такой код небудет работать

  - name: loop
       debug:
          msg: "{{ item[0]  }}"
       with_items:
            - [1]
            - [a]


потому что item это типа не массив не список не дтикшнари.
это типа просто значение.

----
прикол то что 


  - - apache2
    - mc
  - - zlib
    - nginx

и 


  - 
    - apache2
    - mc
  - 
    - zlib
    - nginx

это один и тот же список.

и тот же самый список выглядит еще вот так

  - [ apache2, mc ]
  - [ zlib, nginx ]


----

теперь рассмотрим прогу
и сразы что она будет выводить:


- name: play 1
  hosts: machine1
  become: yes

  vars:
     petya: mc

     vasya:
        name:  apache2
        state: latest

     masha:
         - - apache2
           - mc
         - [zlib,nginx]




  tasks:

     - name: print "masha"
       debug:
          msg: "{{ masha  }}"
       tags:
          - d


здесь мы смотрим что он напечатает при обращении к 
переменной masha

TASK [print "masha"] ****************************************************************************************************************************************
ok: [machine1] =>
  msg:
  - - apache2
    - mc
  - - zlib
    - nginx


видно что печатает сразу весь список. весь массив.
это значит что если бы мы совали машу не в модуль debug 
а в модуль apt то этот модуль должен уметь работать со списками.
иначе будет ошибка. тоесть если мы подставляем переменную в модуль
то модуль должен уметь сам разбивать список на элементы.


     - name: print loop with_items
       debug:
          msg: "{{ item  }}"
       with_items:
            - [1,2]
            - [a,b]
       tags:
          - d


теперь посмотрим что напечатает переменная item 
которую образовали через with_items

TASK [print loop with_items] ********************************************************************************************************************************
ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2
ok: [machine1] => (item=a) =>
  msg: a
ok: [machine1] => (item=b) =>
  msg: b
  
видно что при печати печатается тлоько один элемент из всего массива
за раз. это значит что если бы мы подставли item не другой модуль 
например apt то модуль абсолютно может быть тупой и не уметь работать
со списками или дикшионари. так как ему with_items скармливает всего
один элемент из всего массива за раз.

в этом и есть фундаментная разница между влиянием классической переменной
если мы ее пихаем в модуль и перменной образованной с помощью with_items

еще раз : если мы используем классическую переменную в моделу то внутрь модуля вываливается весь массив за раз. и это уже проблема самого модуля умеет он работать с масивами или нет.  а если мы исмпользуем переменную item которую создает with_items то внутрь модуля вываливаеися 
только один элемент массива. поэтому модуль может быть очень тупой.
модуль небудет иметь представления обо всем массиве. он всегода будет 
втидеть только один элемент.

что еще важно заметить.  если при описании with_items
мы используем список

 with_items:
            - [1,2]
            - [a,b]
			
то в выводе мы видим НЕСПИСОК. 

ok: [machine1] => (item=1) =>
  msg: 1

мы видим как бы просто скалярный элемент.
хотя было бы логично что мы увидим один элемент но это был бы тоже список.
но нет. мы виим чисто скалярный элемент.
почему это важно. почему важно что элемент печатаемый это не список.
потому что чуть ниже мы попробуем напечатать нулевой элемент item[0]
и мы получим ошибку. потому что item[0] означает напечатай нулевой элемент списка item. так вот так как item это несписок то будет ошибка. 



     - name: print masha[0]
       debug:
          msg: "{{ masha[0]  }}"
       tags:
          - d


смотрим печать нулевого элемента переменной masha 


TASK [print masha[0]] ***************************************************************************************************************************************
ok: [machine1] =>
  msg:
  - apache2
  - mc

полученный результат логичен.


далее смотрим нулевой элемент переменной item

     - name: loop
       debug:
          msg: "{{ item[0]  }}"
       with_items:
            - [1]
            - [a]
       tags:
          - d


и получаем ошибку. и это тоже логично. потому что item это не список как это было видно чуть выше. а нотация item[0] просит напечатать нулевой элемент списка, а item еще раз этонесписок. поэтому ошибка. item это типа скаляр.

--
теперь когда мы в деталях поняли в чем разница между
классической перменной 

vars:
  vasya: 1 
  
и переменной item образованной с помощью with_items
  
  
мы поняли что item образованной через with_items
это скаляр. это несписок состоящий из одного элемента, не дикшонари,
это скаляр из одного элемента.

with_items полностью аналогичен циклу 

for i=
end

а item в нем играет роль индексной переменной i


теперь можно переходить к with_nested

берем такой код

   - name: print with_nested
       debug:
          msg: "{{ item }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]



и посмотрим что покажет вывод

TASK [print with_nested] ************************************************************************************************************************************
ok: [machine1] => (item=[1, u'a']) =>
  msg:
  - 1
  - a
ok: [machine1] => (item=[1, u'b']) =>
  msg:
  - 1
  - b
ok: [machine1] => (item=[2, u'a']) =>
  msg:
  - 2
  - a
ok: [machine1] => (item=[2, u'b']) =>
  msg:
  - 2
  - b

откуда видно что за один раз with_nested он в item подставляет
список (уже список а не скаляр!) и видно что with_nested аналогичен
вложенным циклам 

for i=
  for j=
  end
end


соотсветсвенно если мы вот такой код запилим


     - name: print with_nested
       debug:
          msg: "{{ item }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]
         - [ '#','#']


то вложенный цикл уже будет тройной. аналогичен циклу

for i=
 for j=
   for k=
   end
 end
end


ну а в переменную item будет подставляться список из трех элементов
например

ok: [machine1] => (item=[2, u'b', u'#']) =>
  msg:
  - 2
  - b
  - '#'


теперть мы знаем что подставлят в item цикл with_nested.
поскольку в данном случае item это список то мы можем оперировать
элементами уже этого списка. например

берем такой кусок кода



     - name: print with_nested
       debug:
          msg: "{{ item[0] }} "
       with_nested:
         - [ 1, 2 ]
         - [ a, b ]


и смотрим вывод

TASK [print with_nested] ************************************************************************************************************************************
ok: [machine1] => (item=[1, u'a']) =>
  msg: '1 '
ok: [machine1] => (item=[1, u'b']) =>
  msg: '1 '
ok: [machine1] => (item=[2, u'a']) =>
  msg: '2 '
ok: [machine1] => (item=[2, u'b']) =>
  msg: '2 '

таким образом у нас печатался не весь item целиком. а только его нулевой 
элемент.

опять же подчеркну что такой фокус с item[0] неработае с циклом with_items
потому что тот подставляет в item несписок из одного элемента а просто скаляр из одного элемента. тоесть item у with_items это не список.
а item у with_nested это список. 
в этом вчастности разница между with_items и with_nested

вот эта вот тем в чем разгица мжду классической перменоой и перемпной
item которая образуется через with_items\with_nested нигде неописано. а 
это оченть важно.


-----------------------
а еще можно вот такой прикол сделать
можно в with_items данные ввести не руками стаические а через 
переменную


  vars:
     kuku:
      - 1
      - 2


    - name: print one more with_items
       debug:
           msg: "{{ item }}"
       with_items:
         - "{{ kuku }}"


интересный кусок здесь 

       with_items:
         - "{{ kuku }}"


распечатка на экране будет 

TASK [print one more with_items] ****************************************************************************************************************************
ok: [machine1] => (item=1) =>
  msg: 1
ok: [machine1] => (item=2) =>
  msg: 2


тоесть with_items абсолютно корректно в себя всосал список через перменную kuku

-------

далее посмотрим на еще один цикл with_subelents

код такой

  vars:

     kuku2:
       - name: vasya
         database:
           - a
           - b

       - name: petya
         database:
           - c
           - d


   tasks:
   
     - name: print with_subelements
       debug:
           msg: " {{ item }}"
       with_subelements:
          - "{{ kuku2 }}"
          - database


вывод на экран

TASK [print with_subelements] *******************************************************************************************************************************
ok: [machine1] => (item=[{u'name': u'vasya'}, u'a']) =>
  msg: ' [{u''name'': u''vasya''}, u''a'']'
ok: [machine1] => (item=[{u'name': u'vasya'}, u'b']) =>
  msg: ' [{u''name'': u''vasya''}, u''b'']'
ok: [machine1] => (item=[{u'name': u'petya'}, u'c']) =>
  msg: ' [{u''name'': u''petya''}, u''c'']'
ok: [machine1] => (item=[{u'name': u'petya'}, u'd']) =>
  msg: ' [{u''name'': u''petya''}, u''d'']'


он берет vasya и пробегает по a, b
потом берет petya и пробегает по c,d

пробегает он по тому полю которое мы указали в данном случае 
это database

в итоге item будет такими

item:
  - name: vasya
    a: null
	
item:
  - name: vasya
    b: null


item:
  - name: petya
    c: null
	
item:
  - name: petya
    d: null


соттвесвтенно если item имеет такую структуру - список
то можно обращатся к отдельным элементам этого списка через

item[0]

и

item[1]

соттвесвтенно если мы чуть изменим код


     - name: print with_subelements
       debug:
           msg: " {{ item[0].name }}, {{ item[1] }}"
       with_subelements:
          - "{{ kuku2 }}"
          - database


то получим красивый вывод

TASK [print with_subelements] *******************************************************************************************************************************
ok: [machine1] => (item=[{u'name': u'vasya'}, u'a']) =>
  msg: ' vasya, a'
ok: [machine1] => (item=[{u'name': u'vasya'}, u'b']) =>
  msg: ' vasya, b'
ok: [machine1] => (item=[{u'name': u'petya'}, u'c']) =>
  msg: ' petya, c'
ok: [machine1] => (item=[{u'name': u'petya'}, u'd']) =>
  msg: ' petya, d'

-------------
 в продолжение темы переменные vs with_items

вот кусок

- name: install jre
  apt:
     name: "{{ item }}"
     state: present
  with_items:
      - openjdk-8-jdk
      - openjdk-8-doc
    
как мы уже знаем модуль apt может совершенно тупой от него нетребуется умения
работать с списками или дикшионари потому что with_items будет вставлять в item
одиночное значение. и вызывать apt несколько раз.


соверщенно другой случай показан внизу

- name: install jre
  apt:
     name:
        - openjdk-8-jdk
        -  openjdk-8-doc
     state: present

хотя он визуально похож на предыдущий случай но разница колоссальная.
во первых нет with_items 
и во вторых мы сразу в apt засунули весь список целиком.
поэтому apt просто обязан уметь работать со списками. разбивать список на элементы.

поэтому два куска кода визуально похожи друг на друга но они 
соверщенно по разному кормят apt

-------

продолжение следует.
====

 

