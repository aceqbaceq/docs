encryption


здесь будут разные темы про vpn и encryption.
та часть которую можно писать открыто.




=================================================================================
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\НАЧАЛО ТЕМЫ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
=================================================================================

ПОЛЕ КОНЕЧНОГО РАЗМЕРА. ГАЛУА. МНОГОЧЛЕНЫ. ОБЬЯСНЕНИЕ.

здесь я уже более менее связно излагаю эту тему.

главная задача цель штука которую нужно понять это как построить поле конечного
размера. это значит нужно найти его элементы. и построить таблицы сложения и умно
жения.
здесь вроде как я уже излагаю более менее связно.



так  я щас еще раз хочу с самого верха до самого 
низа описать начиная с того что такое сумма проивзедение и заканчивая фактор
кольцом и закончиь тем что : факторкольцо кольца многочленов K[x] от одной переменной над полем является полем тогда и только тогда, когда соответствующий идеал порожден неприводимым многочленом.

про ОПЕРАЦИИ. сумма или умножение. в  общем изначальном смысле оно не иммеет ниакой связи
с реальным складыванием или умножением. тоесть мы привыкли что сложение это когда чтото 
где то стало больше. но это фигня. это частынй случай. в общем случае это не прото что
мы взяли 3 яблока. положилив корзину. потом взяли 5 яблок доложили в корзину и в корзине 
стало БОЛЬШЕ яблок. тоесть мы привыкли что у нас есть однородные сушности напмример яблоки.
мы их набираем в кучу. потом туда доблаввяем еще этих сущностей. и в итоге у нас в корзине
стало дохрена этих сущностей. в общем случае это вобще про другое. у нас есть  множество
однородных сущностей. пускай даже яблок. { яблоко1, яблоко2, яблоко3, яблоко4, ....}
они все одинаковые неотличимые. как точки проставленные на бумаге. а еще лучше вот как 
у нас на пульте лежит куча лампочек элеактрических. 
так вот сложение изначально оно вот про что.  мы на пульте нажимаем на две некоторые лампочки.
и  у нас на пульте загорается некоторая третья лампаочка! вот что такое сложение. название
сложение оно тоже плохое. таким же образом можно было бы назвать что это операция "кирыкмультук"
это будет равносильно. потому что никакого физического сложения непроисходит изначально!
ничего нигде не прибавляется! у нас на бумаге есть куча одинаковых точек. мы берем две точки
и у нас на бумаге от этого обводится третья точка. ! вот и все это назвыается бинаная
операция. тоесть на вход поступает две точки из множества одинаковых элементов
и на выходе у нас загорается еще одна точка этоо множествао. пусть у нас в корзине лежит
куча одинаквых яиц. мы берем два яйца и сжимаем их. и при этом у нас сжимаетя еще 
какое то третье яйцо. едиснвтенное что элементы имеют свой номер порядковый. то есть 
сам элемент по себе одинаков с друнгим у них просто разыне поорядковые номера.
если рассмотрим числа натуральные. мы привыкли что число 1 оно меньше чем 5. но 
по идее это одинаковые точки на линии. просто одна имеет более боьлщшой порядковый 
номер. а так точка такая же как и тчока 1. вобщем возварщаемся к корзине с яйцами.
они все одинаковые просто они пронумерованы. мы берем два яйца нажимаем на них
и у нас загорается некоторое третье яйцо. то какое яйцо загорится задается наша бинарная
операция. к бинарной операции есть требования:
     1) наша бинарная операция (функция) должна быть так усроена чтобы среди 
        яиц было такое яйцо "ноль" что чтобы при натравливании на него и любой другое
        яйцо x на выходе наша бинарная операция(далее бо) зажигала яйцо x.
        такое яйцо услоно называют "ноль" 
        приходит в голову такой пример. пусть мгожество это разные краски. 
        имеется ввиду все возмжные оттенки. так вот мы берем любую краску x и белую
        краску и мажем ими на листике в итоге получим как результат краску x
        прадда пример не очень в том плане что тут у нас опять же имеется прям физ
        операция сложения смешивания. причем разнородных элементов. при бинарной операции
        у нас необязательно нужно чтобы чтот смешивалось или складывадось.  унас операция
        бо она просто ставит в соотвствие двум входным элементам множества третий
        элемент множества

            a,b ---->  c
        и это соверешенно незначит что a и b должны быть смешаны друг с другом. как
        яблоки в корзине. 

        например берем множество {яблоко, морковь, капуста, "пустой пакет",     }
        и задаем на этом множстве бинарную операцию.бо такую что 
        бо(яблоко, пакет) = яблоко
        бо(морковь, пакет) = морковь
        бо(капуста, пакет) = капуста

        
        так вот тут видно что никто ничего ни с кем не складываем. просто берется
        два аргумента элемента мносжвте и бо нам показвыает подсвечивает некий третий 
        элемент. но никто ничего не склладывает физически и не смеишивае вместе. 
        просто нажатие двух лампочек зажигает некую треью лампочку. элемент пакет
        в данном множестве при данной бо играет роль так назвыаемого нуля. потому что 
        если он идет как аргумент бо(x, пакет) то результатом будет x
        далее пустой пакет я буду обозначать как 0

        добавим к нашей бо вот такую его работу

        бо(яблоко, морковь) = 0
        бо(морковь, капуста) = 0
        бо(капуста, морковь ) = 0

        при такой работе бо у нас   яблоко и морковь являются так называемыми обратными
        элементами. потому что когда мы их подсталяем в бо то получаем элемент 0
        элемент морковь по отношению к яблоку условно обозначается как -яблоко
        ествественно что морковь физически не является никаким -яблоком. это условное
        обозначение которое нам говорит о том что если мы подставим яблоко и морковь в бо
        то оно нам выдаст услованый элемент 0. а по факту нет никакого нуля вместо него
        пустой пакет. нет никакого -яблока вместо него морковь.  а отрицательные сушнсти
        и 0 это все просто условные обозначения которые нам чтото дожлны донести. 
        навание что бинарная операия явялется операцией суммрования это тоже все условно. 
        с таким же успехои я могу назвать эту бинарную операцию как "операция карамультук".
        это ярлык не более того. 
        если бинарная операция такова что она обладает тремя свойствами тогда данное 
        множество и данную операцию вместе называют как "группа" а свойства такие
          1) сушествует такой элемент z что если мы возьмем любой x множества то 
            бинарная операция выдаст всегда x
                 бо(z,x)=x
            этот элемент z условно обозначают как 0 . но это физически никакой не 0 из 
            мира простых чисел. это просто такое условное обозначение. тогда
                 бо(0,x)=x
            особенность этого условия еще в том что этот услованый "0" он один на всем
            множестве. тоесть для всех x элемент 0 один и тотже а не индивидуальная штука.
         2) для каждого x множества существует обратный элемент y 
            причем в отличие от элемент 0 обратный элемент y необязан быть один 
            и тотже для всех x. это буду пары. так вот x и y пара будет такая что  

              бо(x,y) = 0

         3) для каждого a,b,c множества выполняется ассоциативное условие
            находим q=бо(a,b)
            находим r=бо(q,c)
            находим p=бо(b,c)
            находим s=бо(a,p)
            так вот мы требуем чтобы
                 r=s
            усвловие три еще вот так обозначают
            бо( бо(a,b), с) = бо (a, бо(b,c))
            еще вот так обозначают. если обоззначит бинарную операция бо(a,b) как a*b
            то тогда третье условие можно обозначить как требование
              (a*b)*c = a*(b*c)
            знак * это опять же чисто условный вместо него можно использовать любой другой
            символ например  
               (a#b)#c = a#(b#c)
            причем в раной лттеруре бо(a,b) обозначют по разному. где то через 
              a*b
            а гдето 
              a+b
            еще раз скажу это все абсолютно условно. это просто обозначение не более
            того. никакого физ смысла что это "складваеие" то бишь взятие элементов
            и собирание их вместе в одной корзине или физ операции уменожения и речи
            тут об этом не идет. 
            в этом первый прикол в теории групп\колец\полей

так вот если у нас есть множсетво элементов и на них задана бо которая удовлетворяет
трем условиям то это множество вместе с этой операцией назыается группа.

далее вводится понятие кольцо. это множество на кототором задана бо. которая кстати
обрзначается как "+" точнее a+b
у которой есть нетолько три условия которые  я уже указал( наличие нуля, наличие обратного элеента для каждого элемента, ассоциативность (a+b)+c=a+(b+c)) но и наличие четвертго усвловия - комм
утативность то есть a+b=b+a
поэтому кольцао автоматом явялется группой по операции сложения.  
также на этом множестве задана еще одна бинарная операция которая условно называется умножением.
хотя я говрю   с таким же успехом ее можно назвать операция "куку". обозначается она
условно "*" или "a*b"
это умножение должно выполнят условие. 
    a * (b * c) = (a * b) * c     - ассоциативность

и еще есть одно условие которое в одинаковой степени затрагивает и сложение 
и умножение. это условие связывеывает вместе сумму и умножение
     a * (b + c) = a*b + a*c
    (b+c)*a = b*a + c*a

тогда такое множество с таиким двумя бинарными опрерациями называется кольцо.
как видно кольцо или группа чтобы их образоывать дело в не в элементах можеснтва  а в том
как создать задать две хиртрые операции. в них вся сложность и соль.

теперь я хочу пояснить про такое понятие как "полином" или "многочлен".
и здест я хочу подсветить что есть сущности. а есть операции над сущностями.
например бо сумма или бо умножение это  операции. это не сущности. да результатом
этих операций тоже явялется сущность но все же сумма и умножение это не сущнности как 
элементы множества. это операции. операции котоыре на входе берут сущнсоти и возвращают
сушность. но сама оперция это не сущнсоть. это как рецепт и продукты. сущности это продукты.
рецепт это процесс. он берет сущности. и возвращает сущность но сам рецепт есть нельзя
он не сущность.
я это к чему что полином
        2*x + 3*x^2 + 4
он выглядит якобы как сущност но на самом деле это процесс. так же как и операция + и *
полином это форма записи некоторой очередности  операций + и * выполняемый друг 
за другом. удобняшка что эту череду + и * записать вместе и покороче. например
мы хотим
    a+b получаем c
    потом мы хотим
    c+b получаем d
    потом мы хотим 
    c*d
    это все очень длинно расписывать. нужно более компактно
    ((a+b)+b)*d = (a+b+d)*d = a*d+b*d+d*d= a*d+b*d+d^2
получили полином
    d^2+b*d+a*d
он не явялетс сущносттью. это процесс. форма записания череды последовательных операций * и +
да на выходе он выдает сущность. но как результат обработки исходных сущностей на входе. 
а сам по себе он сущностью не является. бинарная операция это рецепт процесс получения 
сущности исходя из двух сущностей на входе. а полином это операция получения сущности
через серию операций * и + у которых в свою очередь есть сущности на входе.



                      сущность5
                        /\
                     полином
             /                     \
            +                      *
     /           \            /        \
   сущность1  сущност2   сущность3 сущность4
  


тоесть бинарные операции засасывают по две сущности в себя и высирают из себя третью сущность.
полином в себе содержит серию операций * и +  и в конце концов высирает из себя сущность.
еще раз говорю что полином это не сущность. и не новая какая то структура. это просто 
последовательный набор ряда операция * и +. и все. резулататом его явялется сущность. 
вутри полинома в конце концов все сводится к финальной операции * или + с двумя некоторым
аргументами и как результат выдается сущность. ее полином и выдает как результат своего рецепта.
обычно полином это не серия * и + с конкретнеыми элементами множества. а он описывает некий
класс таких оперкций. обычно в + и * один из аргументов жестко задан а второй неопредеелен.
например полином

     x+2
тоесть мы видим что полином содержитв себе одну оперция + у которой среди аргумтов один 
жестко задан как элемент 2 а второй незадан четко а задан как x
тоже самое про операцию *
     x*3

в поиноме в операциях * и + обычно один агумент жетко задан как уже сказал а второй нет.
либо оба не заданы но это один и тот же аргумент тоесть

    x*x
или
    x+x

итак полиномы которые я буду обычно расатривать это в итоге некая через операций * и +
в которых один аругумент задан явно  а второй нет либо обоа аргумента не заданы но это 
один и тот же аргумент. например полином
     x^2+x+1
это серия * и + вот таких
    x*x 
    x+1
потом мы берем результат первой и втрой операции и скалдываем 
    y+z
это и есть смысл полинома. физический смысл полинома. это рецепт набор операций * и +
но не сущность. хотя как результат он выдает сущность из себя
чтобы полином выдал на выходе из себя новую сущность конкретную нужно ему на входе
подать исходную сущность например вот этому полиному
   x^2+x+1
чтобы он выдал на сущность элемент ему навход нужно дать конкретный элемент вместо x
когда мы посчитаем результат. элемент. то тогда говорят "полином принял значение"
я бы сказал что более правильно было бы сказать ряд операций * и + ВЫДАЛИ значение. 
полином ничего не принимает. он выдает результат. когда мы варим борщ по рецепут то 
рецепт ВЫДАЕТ на борщ как результат. но рецепт не принимает никакого значения. когда
говорят полином чемуто равен. то по факту это на самом деле значит что те операции * и +
которые зашиты внутри полинома в итоге привели нас к элементу. выдали его. а нето что
полином принял какоето значение. это фигня. это тоже самое когда гвоорят что сумма
приняла значение или операция уможения приняла значение. они ничего не принимают. у них
нет ничего куда бы они могли чтото принять. они выдают нам некотрое значение. они 
сами ничего не принимают. у них нет органа принималик. у них нет нкиакой сумки куда можно
чтото было бы положить . у них нет кастрюли. куда можно чтото налить и сказать вы знате
сумма приняла значение. сумма и * похжи на бочку с дыркой. если мы влили в бочку 
сверху 2 и 2 литра то на выходе мнвоенно вылилсь 4 литра. бочка на выдала 4 литра. но 
внутри бочки ничего незадерживается. поэтому принимать какоето значение она не может.
если только это не рассматривать "приняла" в том смысле что через бочку прошел некий обьем
насквозь. тогда да.  но я и тут не согласен.  у нас в бочку например в сумму входит
два элемента  5 и  обратный к 5. на выходе из бочки будет элемент 0. но это не значит
что сквоз бочку прошел элемент 0. он выщел на выходе. а сколвьзь бочку прошло два элемента
5 и -5. она их приняла. в общем я считали фраза полином\сумма\умножеие приняла значение
это очень неправильно. правлно казать сумма\полином\умнгжение выдали значение!
это как скзать баба приняла ребенка. нет. она его родила как результат но не приняла. принимает
баба нечто другое. это как про еду. человек принимает в себя одно а высирает чтото другое.
так вот сумма\полином\умножение они  в себя принмиают аргументы а высирают они резулбтат.
итак когда  полином выдал некоторый элемент, выдаел некоторое как говорят значение
то это значит что в подином подставли вместо x конкетный элемент на входе. далее мы 
высчитали внутри все операции * и + и в итое вся эта череда выдала навыходе на элемент A.
и они тогда говорят полином принял значение A

   f(x)=x+2+x^2
   f(5)=5+2+5^2=32
на вход поинома мы подали конкренвый элемент 5. и на выходе подином нам выдал элемент 32

итк когда они говорят полином принял значение 0 это значит что результатом операций
внутри полинома стал элемент 0.

от чего завиисит то чтобы на выходе из полинома получился элемент 0. это зависит от 
коэфициентов полинома. тоесть жестко заданных элементамх множества в операцих + и *
внутои полинома. например 
   f(x) = (x+5) + (x+7)
здесь мы имеем поинм с две операции  + у каждой из них два аргумента. 
  x+5
  x+7

один аргумент вкажой операции у нас уже задан это элементы 5 и 7. 
бещусловно ели мы поменяем эти элементы на другие то это повляет на результат этих сумм,
а второй элемент не задан поэтому это тоже влияет какой результат выдаст сумма.
и еще результат  зависит от того к каким элементами приведут операции +  и * 
на данном множестве элементов. 
например я имею полином

    f(x) = (x+5) + (x+7)

я в него подставлю x=1
    (1+5) + (1+7)

так вот в одном множестве опрация + может привести к одним элементам а вдругой группе
к другим элементам. например  в одном моежстве  бинарная оерация 1+5 может выдать элемент 10
а в ждругом можестве 1+5 может выдать 15. 1 и 5 это не числа а услонвное обозначение
некотоых элементов множества.

корень N полинома это значит такой элемент N поданный на вход полина  вместо x
что при вычислении внутри всех сумм и * полином нам выдает в итоге элемент 0.
опять же важно понять что не сам элемент нам выдаст элемент 0. операция сумма 
или операция уможения коорая будет выполнена последняя внутри череды операций защитых 
в рецпете полинома.
операция сумма или умножит это как дейтвие "пожарить" или "порезать" или "сварить"
применительно  к элементам овощам. а полином это рецепт который содержит череду таких
"пожарить" "порезать" "помыть" тоесть сам полином он новых реальным операций с эелментами
не вводит. он лишь содержить череду таких элементарных операций.
это как в качалке. есть реальные управжения- поднянуться. отжаться, гантенлю на бицепс, присед.
это аналог операций сложение и умножение. а  полином это список череды таких "отжатся"
"гатнетелю на бицепм" "присесть". вот и все. 
полином это 
    отжаться 3 раза с 50кг  (умножить)
    присед 10 раз с 60кг    (сложить)
    полятнуься 10раз с 50кг (еще одна биранрная операция)

едисненнное что вполиноме обычная каждая следущая операия она в качестве аргумента
берет результат от предыдущей операции. в оотличие оттренировки где то что поднимают 
в следущем упражнении не связано с тем сколько ты поднял на предудщем управженнии.

просто я хочу показать то что полином это совереешенно не самотоятельная сущность. 
это даже не операция. (аналог упражнения на тренировке) это всего навсего список операций.
это как есть скажем реальные штуки - поесть , поспать, попрыгать.  если эти штуки делать
они имеют реальное влияение на тело. а  полином это всего навсего спсок этих действий. 
всю реальную работу выполняют именно действия (умжение сумма) а полином это записанная
череда этих дейсвтий. чтобы было удобнее эту череду записывать. 

что значит полином на это множестве имеет корень. это значит что если подставим в полином
один из элемнтов этого множества то череда операций * и + которая сидит внутри в итоге
нас выведет к элементу 0 этого множетва. анпример полином

  (x+5)+(x+2)
  это всего навсего более добно запианная череда трех операций сложения
  x+5
  x+2
  y+z

справшивается если операция ложени и умножени бинарная. тоесть нам всегда над два аргумента
хотя бы даже одинаковых то почеу мы в полном обычноподсталвяем только один элемент на входе.
ответ такой что для каждой бинарной опецрии внутри полинома вторйой аргумент уже там защит.
через коэфицинты полинома. тоесть мы видм что в сумме
  x+5
у нас аргумент 5 уже зашит. так и для доугих.
в итое чтобы полином тоесть череда операций сложения иумножения привела нас к элементу 0
то это завсиит от коэфицинтов полинома. входного элемента, и то как устроена оперция 
сложения и умножения на данном множестве. к каким элементам они приводят.

почему один и тот же полином то есть один и тот же список сложений и умгжений на одном
множестве приводит к нулю а на другом множестве не приводит. - два фактора. во первых
на первом множестве может не быть такого исходного элемента который мы подаем на вход
чтобы череда умножений и сложений могла привести к нулю. условный пример

первое множство = {0 1, 2, 3, 4, 5, 6}
    полином  (x+5)+(x+2)
  эквалентная череда операций
  x+5
  x+2
  y+z

пробуем все элементданнного можества
  1+5 = 6
  1+2 = 3
  3+6 = явно не ноль

и так с остальными элементами этого множества

второе можество = {  -3.5   0    1.5   2    5    }
  -3.5 + 5 = 1.5
  -3.5 + 2 = -1.5
  -1.5 + 1.5 = 0

приводит нас к элементу 0

тоесть банально у нас в первом множестве не было такого входноо элемента чтобы
череда операций могла приветси к элементу 0. тоесть было узкое множество элементов.

и вторая причина. еще завсиит от того как построены сами операции на множестве. 

условно гвооря я беру исходное первое можество {0 1, 2, 3, 4, 5, 6}
и у него вот так заданы операции сложения 
  если 1 и 5 складываем то выдаем  6 
  если 2 и 5 скалдываем то выдаем 4
  если 6 и 4 скадываем то выдаем 0 
 
  тогда подтставляем в поином элемент 1

  1+5 = 6
  1+2 = 4
  6+4 = 0

получили 0. потому что мы подргуому определелили как работае операция условного 
сложения.

итак что такое группа. что такое операция бинарная (сумма умножение) обьяснил.
что такое полином тоже поляснил.

теперь про смежный класс.
вот у нас есть группа G в ней есть подргуруппа H. 
далее мы берем элемент a из G и фиксируем его. так как G это группа то на этом 
множестве определена операция условного умножения. тогда мы начинаем умножать наш a 
на все элементы из H тоесть

     a*h1 = b1
     a*h2 = b2
     a*h3 = b3

и так мы пробегаем все h из H. в итоге у нас образуется какотое множество B
это множество B называется левым смежным классом множества G по множеству H и обозначается 

       aH

где a это элемент из G  а H это подмножество которое мы пробегаем. 

если мы будем перемножать поставив элемент a справа вот так

     h1*a = b1
     h2*a = b2
     h3*a = b3

то полученное множество B назвыается правое смежное множество. обозначается вот так

     Ha

теперь вот еще какой ммоент. есть так называемое нормальная подгруппа. 
это что такое. а вот что. мы берем наш a из G и подмножество H
вначале находим левый смежный класс B

      B1=aH

потом для этого же a и H находим правый смежный класс

     B2=Ha

а теперь мы сравниваем совпадают ли B1 и B2
если они совпдадают. то мы берем следущий элемент из G некоторый c . множество H у нас 
остатся прежнее. и мы находим для этого c и H левый смежный класс (левое смежное множество)
и правый смежный класс. 

   C1=cH
   C2=Hc

далее сравниаваме совпдает ли C1 и C2
   С1 ?= С2 

если да то хорошо. и таким образом мы перебираем все элементы из g. 
и и кадый раз сранвием совпдаает ли левый смежный класс или правый. так вот.
если для всех элементов из G левый смежный класс совпдаает с правым смежным классом от множества H
то тогда это множество H называют "нормальная подгруппа" множества H.

справшивается а зачем нам эта нормальная подгруппа? дело в том что внутри G есть много
вариантов какое множество H выбрать. по которому строить смежные классы. но если
мы внутри множества G выберем именно множество H которое является нормальной подгруппой
то мы получим выгоду. дело вот  в чем. мы берем множество G. потом внутри него каким то
макаром находим нормальную подгруппу H. далее мы находим все левые смежные классы 
внутри G(если мы взяли H что это нормальная подгруппа то нам без разницы что 
искать что левый смежный класс что правый смежный класс они совпадают ), это будут 
какието множества. и далее мы берем каждое такое множество и говорим что это элемент 
нового множество. тоесть мы создаем новое множество в котором элемнтом является тоже множество
а именно левый смежный класс. хотя конечно это непривычно когда у нас элементо множетва
являетя не какаято цифра или вещь а тоже множество. и вот это новое множество называется
ФАКТОРГРУППА. как она обозначается? если исходное множество G и нормальная подгруппа H 
то факторгруппа обознается как G/H
факторгруппа это группа. но чтобы она была группой на ней нужно задать бинарную операцию.
удовлетвовюрядющую 3 свойствам что я писал выше. щас опрееделим. итак элмементами
факторгруппы являются смежные множества кажый из который обозначается как aH
тогда факторгруппы выглядит как
        { aH, bH, cH, dH, ...}
ксатти смежное множество 
так вот для такого множества бинарная операция для ее эдемнтом задается закноном

         (aH) * (bH)= (ab)H

наверно такая формула умножения соотвесвтет трем правилам которым должна удовеляетрять би
нарная операция для группы. вот теперь факторгруппа у нас действительно группа.
еще раз что непривычно в этой грппе.это то что ее элментом является множество а не единичный
элемент

        { aH, bH, cH, dH, ...}

где aH это {a*h1,  
            a*h2,
            a*h3,
            a*h4,
            ...
            a*h100
                   } 

где a принадлежит G а h1-h100 принадлежат H         

щас я покажу все на примере. но надо еще потерпеть.

дело в том что часто еще вводят бинарную операцию эквивалентности. и говорят так.
пусть у нас множество G и подмножество H берем два элемента из G  а именно "a" и "b"
тогда говорят что 
    a~b (а подобно b )  если есть такое h из H что выполняется формула

        a*h=b

а далее мы вот что делаем. мы фиксируем a  и начинаем его умножать на все h лежащие в H
получим нкоторое множество. в котором каждый элемент c таков что

      a~c
так вот получаенное множество называют классом эквивалентности и обозначают как

     [a]

поняно что класс экивалваентности имеет смысл если у нас указан G котрому принадлежит a
и если указано подмножество H. 


а теперь посмотрим что такое левое смежное множество для элемента a исходя из того
о чем мы говорили выше

 aH  =      {a*h1,  
            a*h2,
            a*h3,
            a*h4,
            ...
            a*h100
                   } 

тоесть множество aH это как раз множество всех элементов которые были как получены?
мы взяли a закрепили его. а потом пробегаемся по всем h умножая и то что получаем это элемент aH.
тоесть множство aH таково что каждый элемент c которы там лежит обладает свйоством

    a~c

получается что множество aH и [a] это одно и тоже. они совпадают. это я к чему.
элементы фактор группы можно запивать двумя способами

 {aH, bH, cH, dH,...}

или
 
 {[a], [b], [c], [d], ...}

едиснвтенное что нужно помниить что множество H оно не абы какое а выбирается так чтобы 
оно было нормальной подгруппой. только при таком H мы можем образовать фактор группу.

спрашивается нафига нам эта фактор группа. при опрделеенных условиях фактор группа будет
являтся полем. а это и есть конечная задача на данном этапе - нужно научиться строить поле.
тоесть если задан размер поля  - число его элементов надо научиться строить поле с этим
числом элементов. а именно нужно найти эти элементы. и построить таблицы сложения и умножения.
если у нас есть элеметнты и таблицы сложения и умножения у нас есть поле. а это то что мне 
нужно как конечная задача. при определенных условиях фактогруппа будет полем. щас к этому
придем

я уже упоминал кольцо. что кольцо это во первых группа. потому что на это множестве определена
бинарная операция которая удовлетворяет трем требованиям ( наличие нуля, наличие обратного
элемента по этой операции для каждого элмента, ассоцативность ) , плюс эта операция имеет 
коммутативность. и они говорят что эта бинарная операция называется операцией сложения. 
что я не могу понять почему они ее называют операцияей сложения. с таким же успехом это 
операция может быть названва операция уможения или операцией "мамба намба файв". это мне непонятно.
если это операция сложения то тода это знак +. ассоциативность значит что a+(b+c)=(a+b)+c
коммутативность означает a+b=b+a
тоесть это такая продвинутая группа. ( так как у нас операция суммирования на ней задана то гвоорят
что это аддитивная группа). и плюс к этому задана бинарная операция уможения (почему они ее называют операцией умножения а не поерацией куку). которая обладает свойством 
ассоциативности.  (a*b)*c=(a*b)*c
и еще одно своство есть этих двух бинарных операций котоыре увязывают их воедино.
это вот такое свойство оно назвыается дистрибутивност
      a*(b+c)=a*b + a*c
      (b+c)*a=b*a + c*a

видно что в кольец опрация умножения урезанная по требованияем к ней. нам не трубуется иметь наример 1 по умножению. не нужно иметь обратный элемент по умножению также. 
итак далее. 
так вот кольцо это группа но группа по операции сложения. а по отношению к операции умножения
множество образующее кольцо оно недоделанное в плане требований которые предьявляются к 
группе по уможению. (когда три условия : наличие едииничного элемент "e" такого что 
a*e=e*a=a , наличие обратного элемента к каждому a*a^(-1)=e, асоциативность (a*b)*c=a*(b*c),
последне условия в кольце выполнятеся кстати )
а унас повторюсь в кольце умножение слушается тлоько вот этого требования
   (a*b)*c=(a*b)*c
и мы хотим в этом кольце создать фактор группу.  фактор группа создается из классов смежности
построенных на основе нормальной подгруппы H. выше я писал что нормальная подгруппа это 
такое множество H что если мы возьмем любой элемент g из G построим для него левый смежный 
gH класс по этому H  тоесть gH={ g*h(i), h принадлежит H} тоесть gH это произвеедение g на 
все элемнты h  и правый смежный класс Hg тоесть это все элемнты h перемножим на g  h(i)*g
то эти два множества совпадут. причем это будет верно для всех элементов g которые мы будем
брать из G.  так вот мне непонятно в кольце операция умножения задана. почему нельзя
внутри кольца найти нормальную подгруппу. но насклько я понял почемуто нихрена нельзя. 
я нашел еще одно определение что такое нормальная подгруппа H для множества G:
   для любого g из G и любого h из H должно выполняться:
               g*h*(g^(-1)) должен принадлежать H
если исходить из этого определения нормальной подгруппы то на кольце мы ее типа неможем
найти потому что в кольце для операции умножения не задано требования наличия элемент 
единичного e такого что a*e=e*a=e и как следствие не задано требования наличия обратного
элемента g^(-1) для элемента g такого что g*g^(-1)=e . раз этого на кольце нет то 
и g^(-1) вообще нет по определению.  значит исходя из этого нормальную подгруппу мы
найти на кольце не можем. значит и фактор кольцо идет нахрен. хотя я замечу еще раз что
если исходит из того что с другой сторны нормальная подгруппа это такое H что gH=Hg
для любого g из G то по мне очень даже можно нормальную подгруппу найти внутри кольца.
так вот они идут друигим путем. они вместо нормальной подгрппы на кольце вводят понятие
двустороннего идеала I. 
что такое идеал. идеал это множество внутри кольца такое что 
   если мы возьмем элемент из идеала i и умножим его на любой g из G то тоесть i*g 
   то этот элемент будет лежать внутри идеала I
   левосторонний идеал это когда для любого i из I и любого g из G выполняется 
   что i*g лежит внутри I
   правосторонний идеал это когда для любого i из I и любого g из G выполняется 
   что g*i лежит внутри I
   двустронний идеал когда левый и правый совпадают
   кстати я замечу что в кольце вообще то умножение не коммутативно вобщем. тоесть
   по дефолту такого нет требовния что a*b=b*a  так что такого что у нас идеал 
   всегда двусторонний такого нет. это надо еще искат такой идеал. вообщето.
   хорошо положим что у нас так случислоь что умножение коммутивно то есть что a*b=b*a
   тогда у нас нет этих проблем с уможением слева или справа. сравним свойства нормаьной
   подгруппы и двустороннего идеала. пусть у нас H это нормальная подгруппа внутри
   кольца. возможно прикол вот в чем. у нас нормальная подгруппа это тоже группа (поскольку
   сказано же что она подгруппа значит это группа внутри группы.) а группа у нас задается
   либо на операции сложения либо на операции умножения. но чтото одно. и так как у нас
   нормальная подгруппа определеяется через смежные классы. а классы как я понимаю опреде
   ляются через операцию умножения. то отсюда я делаю вывод что исходная группа и 
   нормальная подгруппа они задаются на операции уможения. тоесть исходная группа G задается
   на операции уможения. подгруппа H это тоже группа получается с операций умножения. 
   смежные классы уж точно определяются через операцию умножения. то получается что к этому
   умножению как для группы G так и для подгруппы H есть требования к умножению в том
   плане что оно должно удоволетвоврорять трем требованиям(наличие нуля, ассцоиативность и наличие
   обратного элеента для каждого элемента) так вот наше кольцо оно в плане умноженэто когда для любого i из I и любого g из G выполняется 
   что i*g лежит внутри Iия 
   неудовлветворяет этим трем требовниям. наверное это значит что и любое подмножество 
   будет неудовлетворяеть или не всегода удовлвтвроять этим трем требованяием. тоесть
   подмноество которое мы выберем внури кольца это уже не будет подгруппой. или группой.
   тоесть операция умножения на элементах этого подмножества не сможет удовлетрворить 
   трем требованием к умнжоению чтобы мы могли подможество назвать группой по умножению.
   тоесть еще раз логика такая - нормальная подгруппа это получается группа внутри группы.
   группа это множество с заданой на нем бинарной операцией либо сложения либо умножения
   которое удволветвовряет трем тербованияем. посолку подгруппа задается через смежные
   классы а те через операцию умнжения то я делаю ввыод что  нормальрная подгруппа она
   группа внутри группы опредлеенной на операации умножения. потому что если предположить 
   что исходное мнжество G это группа по сложению (аддтивиная) то как на ней находить смежные
   классы если у нас операции умнжения пртсо не существуе в этой группе (хотя как уже сказал
   по мна незвание операции оно абсолбтно условное ибо требованеия к операции сложения и 
   умножения обсолбтно одинаковые).значит смежные классы и норалрная подгруппа они задаются
   только если исходная группа мултиликативная(тоесть создана с заданной операцией умножения)
   котоаря еще должна удовлетвеорять трем требованяием. посколку сказано что нормальная 
   подгруппа это подгрппа значит к ней предьявнядлятся трбования как и к группе в плане 
   бинарной операции. значит нормальная подгруппа внутри нее операция уможения на ее 
   элеентах должна тоже удовлетворять три требования к операции умгожения. иначе это 
   не будет подгруппа мулитипликативной группы. значит если наше множество не удовлетворяет
   требованияем мултпликативной группы то это неможет быть нормальная подгруппа. также
   подгруппа поразуемеват что группа обладает теми же качеатвамми. так вот если это так
   то наше кольцо оно не мультпликативное оно аддтивиное. оно является группой только
   в плане операции сложения не не уменожения. поэтому видимо в кольце мы не можем 
   говорить ни о какой нормальной подгруппе. и поэтому вместо нее вводят некий аналог
   идеал.
итак мы перешли к идеалу. двухстороннему. это такое множество I внутрикольца что 
для любого i из I  и любого g из G (кольца) выполняется 
         g*i=i*g и это принадлежит все тому же I
для сравнения в случае нормальной подгруппы требование выглядело так
         g*h=h*g но не было трбования чтобы элемент принадлежал H это могло быть какоето 
другое множество. главное чтбобы g*h=h*g причем для каждого g это могло быть свое множество B
итак идеал это некая скажем так некий частный случай нормальной подгруппы, более жесткий
случай и еще на идеале не выполняются требования к операции умножению как оно должно быть 
на группе. как оно длжно быть иначе говорят на нормальной подгруппе. 
так мы нашли двустроронний идеал.  далее пользуясь этим идеалом нам надо разрезать
наше исходное кольцо G на отдеьные субмножества. в случае нормальной подгруппы мы как это 
делали. мы брали элемент g из G. потом прогоняли его через умножение на все р

      g*h1
      g*h2
      g*h2
      g*h3
      ...
      g*h100

и получаенное множество которое является левым классмо смежности(врочем правый класс
смежности h(i)*g даст нам тоже множество ) мы отрезали от G,
и из этих множеств создавали новое множество. 
в случае идеала или еще кручу двух сторонненго идеала это делать бесполезно потому что
     g*i(j) всегда нас приведет в I
и прогон g по всем i принадлежащим I нам вырежет только наш I или его кусок. тоесть это 
неточто надо. вместо этого берут g и G и прибавляют к каждому i из I этот g
тоесть вырезается множество вида

   g+i(1)
   g+i(2)
   g+i(3)
   ...
   g+i(100)

потом это множество вырезают из G. смотрим что осталось в G, берем еще какйото
оставшийся элемент из G напрмиер b и опять вырезаем из G множество элеметов

  b+i(1)
  b+i(2)
  b+i(3)
  ...
  b+i(100)


последним куском которы останется в G это сам I и его можно вырезать через 

  0+i(1)
  0+i(2)
  0+i(3)
  ...
  0+i(100)

полученные куски которые мы вырезали называются не смежные классы конечно
они называются классы эквивалентности. 
и вот из них мы образуем новое множество. в котором элементом явлется класс эквивалентности
кстати вырезанные куски я назвал классом экваивалентности не просто для красного словца.
вспоминаем что такое бинарная операция эквивалентности. 
значит эквивалентность это бинарная операция. требует два аргумента на входе и для
элемнтов a и b она обозначается как

          a ~ b

ее конкретная реаизация оставляется на откуп человеку. но она должна удвляетворять трем
условиям

      1) должно быть всегда верно что a ~ a
      2) должно быть всегда верно что если a ~ b то верно b ~ a
      3) должно быть всегда верно что если a ~ b и b ~ c то верно a ~ c



так вот мы вводим операцию эквивалентности на множестве кольца вот так. 
мы говоим что элемент g из G и элемент b из G эквивалентны если 

         g-b лежит в I , где I это двусторонний идеал

проверим что при таком механизме эквивалентстнои у нас выполняются все три требовения
к условию эквилентсности.
      1) подставим g и g
         g-g=0 надо доказать что элмент 0 принадлежит идеалу. 
так вот я там где то читал что идеал это тоже кольцо. это значит на нем выполняюся
все 4 условия к операции сложения. значит на множестве I котрое кольцо должен лежать
внутри элемент 0. потому что это одно из тоебований к операции сложения на кольце. а идеал
это кольцо потому что я об этом где то прочитал. итак это выполенно.

     2) нам дано то что a ~ b тоесть a-b принадлежит к I
тут дело вот в чем. пусть (a-b) это с  у нас дано что этот элемент c принадлежит к I
так как I это такое же кольцо как исходный G то в нем выполняются 4 тоебования к операции
сложения. значит для каждого c существует -c который лежит в этом кольце. 
с другой стороны -c это b-a , так как -c принадлежит к I  а   с другой стороны
-c это b-a значит b-a принадлежит к I а это как раз таки означет что   b~a . значит тоже 
работает.

    3) условие видмто тоже верно.

значит заданная нами операция  a~b если a-b принадлежит к I это дейтвттеьо операция
экивалентности а не какая просто бинарная операция. правда в отличие от бинарнйо операции
сложения или умгожения где для того чтобы операция состоялась нам реально нужно всего
два аргумента два эелмента на входе то в случае нашей "бинрной" операции нам нужно два
элемента и еще в добавок заданный I который как бы аргументом не является. наверное 
имееется ввиду что a и b меняются раз от раза а I осстется константой поэтому он типа 
не аргумент. как коэфицинт в полиноме. типа того.

так вот раз у нас задана реально операция экваивалентности то она подразумевает что 
из нее мы можем пострить класс экивалентности. ( https://ru.wikipedia.org/wiki/%D0%9E%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D1%8D%D0%BA%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D0%B8)

для этого берем элемент a из G, берем I,  и находим все элементы экваивалентные нашему a
тоесть находим все x: x~a 

а теперь вспомним какие куски мы вырезали из G ранее . мы брали число a , потом пробегали 
по всем i из I и вырезали вот такой кусок

   a+i(1)
   a+i(2)
   a+i(3)
   a+i(4)
   ...
   a+i(100)

полученные точки они все экивалентны нашей a. причем это абсолютно все такие точки.
поэтому наш вырезнный кусок это ни что иное как вырезанный класс экивалентности которые
обознвачаетеся как
    
     a + I
или 
     [a] при заданном G и a из G и заданном I

итак мы вырезали из G все классы экивалентснотси [a]  [b]  [c] ... пока у нас нестался
сам I который мы тоже вырезали через вот такой элемент [0]

и теперь мы образуем новое множестве где элементом является каждый выраезннанный класс
экивалентностсти

    { [0], [a], [b], [c], ... }


на этом множестве элементов задается опредяеляется две операции бинарные. сложоения
и умножения по правилу

          (a+I) + (b+I) =  (a+b) + I или   [a] + [b] = [a+b]
и
          (a+I) * (b+I) =  (a*b) + I или   [a] * [b] = [a*b]


и тогда  они  говорят что это множество якобы является кольцом.тоесть унего эти две биарные
операции якобы удовлетворяют требованиям к операциями на кольце. и такому кольцу даже имя дали
фактор-кольцо. обозначается оно также как и фактор-группа  G/I где G это исходное кольцо
а I это двухсторонний идеал.

мы еще недошли до поля но щас дойдем.

ПОЛЕ
что такое поле.
что такое поле. это заапгреженное кольцо. 
вспоминаем что такое кольцо. это множество с двумя задаными баинррными операциями 
сложения   и умножения.  к сложению имеются три требования такие же как у группы:

  (требования к сожению как у группы)
   1) существует элемент 0 такой что a+0=a для всех a из G
   2) ассоциативность (a+b)+c=a+(b+c)
   3) у кждого a есть такой парный элемент x называется обратным к a что 
       a+x=0
    этот обратный эдмент x условно обозначается как -a
 (доп требование к сложению характретное тлько для кольца)
   4) коммуттиваность a+b=b+a

   также на кольце к умножению есть только 1 требование
   (требование к умножению)
   1) ассоциативность   (a*b)*c=a*(b*c)

есть еще одно требование которое связявает слоожени и уможение
  1) дистрибутивность
     (b+a)*c=b*c+a*c
     c*(b+a)=c*b+c*a

так вот в поле как логично предполоить допбавлвтся к умножению теже требоввания что 
и есть у сложения

 (доп требования к умножению на поле)
  1) коммутивнсоть a*b=b*a
  2) суещуетсует e такое что a*e=e*a=a
  3) сущуетвует обратный по умножению элемент y такой что  a*y=y*a=e
  такйо y условно обозанчают a^(-1) но это чисто форма обозначения без всякий физ 
  смыслов степеней.

кстати я тут перечиьал. есть еще треование к полю. во первых  требование к элементу e
  2) суещуетсует e такое что a*e=e*a=a
оно не совсем такое. оно должно быть верно для всех элеметов кроме элемента 0 по сложению.
при умножении 0*e у нас нет требования чтобы 0*e=e*0=e этого требования нет. 
тоесть в поле неподразумевается обратный элемент к элементу 0 по сложению. 
нет в поле элемента обратного по умножению для 0 (элемента по сложению).
но также сказано что для всех элементов втом чсиле и для нуля должна выполнятся
дистрибубивность

 1) дистрибутивность
     (b+a)*c=b*c+a*c
     c*(b+a)=c*b+c*a


дальше возгикает задача как построить поле. 
причем я сразу рассматриваю поля конечного размера. тоесть в этом множетве а поле
это множество. в нем число элементов конечное. так вот докзывает что в коненом
поле число элементов всегда только равно p^n где p-простое (prime) число. а n-это нату
ральное число.  тоесть число элементов в поле может быть 2 3 5 7 
9 11 13 15 17 итд. тоеть простое число в первой степени. 
либо например  2^3 или 13^13

мин число элементов множества поля это два. потмоу что у нас есть 0 для опреации
сложения. и у нас есть e для операции умножения. 
сосавим таблице сложения для  этого поля
 
 + 0  e
 0  
 e

0+0 должно быть 0 потмуо что a+0=a

 +  0  e
   ======
 0| 0  e
 e| e  0



0+e должно быть e потому что 0+a=a

e+0=0+e из за комутивтиваности сложения занчит равно у

e+e = 0 почему? потому что у нас для каждого элеента по операции сложения длжен быть 
обратный элемент который с ним в сумме даст 0. получается что элемент может быт сам себе
обратным поечему нет. тоесть e=-e

операция умножения. таблица. составим и ее

 *  0  e
   ======
 0|   
 e| 

e*0 будет 0 потому что e*a=a
значит и 0*e=0 из за комутивтианости умножения

 *  0  e
   ======
 0|    0   
 e| 0

e*e=e почему. потому что e*a должен быть равен a и потому что у e нужно задать 
обратный элемеент такой чтобы e*x=x поэтому e*e=e удовлвтворяет обоим этим условиям

 *  0  e
   ======
 0|    0   
 e| 0  e


значит обоатный элемент по умоножеию для нуля у нас нет необходимости его создавать.
но нужно чобы выполнялась дистрибитивность. 
в общем у нас два вариант 0*0=e и 0*0=0
проверим дистрибивность

     (b+a)*c=b*c+a*c
     c*(b+a)=c*b+c*a


пусьт 0*0=e
пусть c=0 и b=0 и a=e тогда
     c*(b+a)=0*(0+e)=0*e=0  сдругой стороны       c*b+c*a=0*0+0*e=e+0=e
получаем нарщуние закона дистрибтвности
     0 != e

значит вариант 0*0=0
проверим
    c*(b+a)=0*(0+e)=0*e=0      и    c*b+c*a=0*0+0*e=0+0=0
       0 = 0 
закон дистрибутвности выполняется зачит 0*0=0

итогвая табица умнжения
 *  0  e
   ======
 0| 0  0   
 e| 0  e


и итговая таблица сложения

 +  0  e
   ======
 0| 0  e
 e| e  0


получаем унас поле F[2]= {0,e}
и таблицы

 +  0  e
   ======
 0| 0  e
 e| e  0


 *  0  e
   ======
 0| 0  0   
 e| 0  e


так как мы можем менять символы обозначающие на какие угодно то можно симвлол e заменить
на символ 1

тогда

получаем унас поле F[2]= {0,1}
и таблицы

 +  0  1
   ======
 0| 0  1
 1| 1  0


 *  0  1
   ======
 0| 0  0   
 1| 0  1

там в книжке докывзается что если у нас число эементов поля 

тогда у нас для 0 и e есть обраный элемент. и также выполянется что e*a=e
в том числе когда a тоже равен "e"

напомню что и сложение и умнгжения к раельным операция сложения иумножения как для 
просто чисел неимеет никакого отгшения. умнжение (сложение) это просто законн который ставит
в соовесвтие двум элемтнам на входе некий третий элемент. это закон соотвевтия двум элементами
третий. и все.

в книжке доказываетяс что если число элементов поля это прайм число в первой степени
то тогда таблицы кэли (таблицы сложения и умножения элементов поля) полностью аналогичны
арифметике c вычетами. а именно если число элемнтов поля скажем 5 
то элементы поля булут {0, 1, 2, 3, 4}
а арифметика будет такая

для сложения:  (a+b) = мин пол вычет от (a+b) mod 5
для умножения: (a*b) = мин пол вычет от (a*b) mod 5

таблицы будут такие

+  0 1 2 3 4 
  ==========
0| 0 1 2 3 4
1| 1 2 3 4 0
2| 2 3 4 0 1
3| 3 4 0 1 2
4| 4 0 1 2 3


*  0 1 2 3 4 
  ==========
0| 0 0 0 0 0 
1| 0 1 2 3 4
2| 0 2 4 1 3
3| 0 3 1 4 2 
4| 0 4 3 2 1


тут надо понимать что эементы поля обозначенные как якобы простые числа 0 1 2 3 4
это в реальном поле некоторые элементы и это совсем не простые числа. просто мы
как бы переоозначили реальные ээлементы на типа простые числа. и таблица для реального
поля и для простых чисел от модулюсов она совпдаает. тоесть более верно вот так
написать табллицы


+  0 e b c d 
  ==========
0| 0 e b c d
e| e b c d 0
b| b c d 0 e
c| c d 0 e b
d| d 0 e b c


*  0 e b c d 
  ==========
0| 0 0 0 0 0 
1| 0 e b c d
b| 0 b d e c
c| 0 c e d b 
d| 0 d c b e


под e я обозначаю единичный элемент в плане операуции умнжеения. а 0 ээто 0 элемент
в плане суммирования

поля где N=(prime)^1 назаются простыми. 
а поля где степень больше 1 это называется расширенные поля.
и нам надо научться их строить

поле где N=(prime)^1  в них арифметика ровно такая же как в случае с модулюсами
для обычных чисел


ну ка посмотриоим поле для трех элементов.
элемнатами поля буудут 0  1  b


+  0 e b
  =======
0| 
e|  
b|  


пользуемся  тем что 0+a=a для всех a значит

+  0 e b
  =======
0| 0 e b 
e| e 
b| b

у нас для каждого x в палне суммыиования должен быть обратный элемент.
логично положить что для e это b а для b это e то есть
e+b=b+e=0 значит

+  0 e b
  =======
0| 0 e b 
e| e   0 
b| b 0

дальше у нас ест такое свйсовто этих таблиц кели для сложения такое что если 
мы берем строку и ли стролбец т в ней дожны быть все элементы поля и не должны повторяться
значит  исходя из этогого e+e=b чтобы во втором столбце были все челны поля

+  0 e b
  =======
0| 0 e b 
e| e b 0 
b| b 0

последний элемент в таблилце исходя из этого это e

+  0 e b
  =======
0| 0 e b 
e| e b 0 
b| b 0 e

смотрим на все столбцы и строки. нигде элемент не повторяется и везде у нас присутвтвуют
все элементы поля

переходим к  таблице умножения

*  0 e b  
  =======
0|   
e|  
b|  
 
пользуемся тем что a*e=a при любом a даже если a=e

*  0 e b  
  =======
0|   0
e| 0 e b  
b|   b


далее два варианта. либо b*b=0 и тогда b*0=0*b=e
либо b*b=e и b*0=0*b=0
будем проверять на законе дистрибутивности 

     (f+g)*h=f*h+g*h
     f*(g+h)=f*g+f*h

проверяем для варианта b*b=0 и b*0=0*b=e
пусть f=b  g=0 h=e 
тогда 
      f*(g+h)=b*(0+e)=b*e=e
      f*g+f*h=b*0+b*e=e+b=0
получили что e != 0
знчит осатетя вариант  b*b=e и b*0=0*b=0
проверим f=b  g=0 h=e
      f*(g+h)=b*(0+e)=b*e=b
      f*g+f*h=b*0+b*e=0+b=b
      b = b
работает
значит итоговая таблица уможения

*  0 e b  
  =======
0|   0 0
e| 0 e b  
b| 0 b e

далее три варианта для 0*0
   0*0=0
   0*0=e
   0*0=b

будем проверять варианты через то что нужно чтобы закон дистрибуции ненарушался
пусть 0*0=e
проверим пусть f=0  g=0 h=b
      f*(g+h)=0*(0+b)=0*b=0
      f*g+f*h=0*0+0*b=e+0=e
      0 != e
значит вариант 0*0=e в помойку

пусть 0*0=b
проверим пусть f=0  g=0 h=b
      f*(g+h)=0*(0+b)=0*b=0
      f*g+f*h=0*0+0*b=b+0=b
      0 != b
значит вариант 0*0=b в помойку

пусть 0*0=0
проверим пусть f=0  g=0 h=b
      f*(g+h)=0*(0+b)=0*b=0
      f*g+f*h=0*0+0*b=0+0=0
      0 = 0
значит вариант 0*0=0 то что надо . итоговая таблица сложения и умножения

+  0 e b
  =======
0| 0 e b 
e| e b 0 
b| b 0 e


*  0 e b  
  =======
0| 0 0 0
e| 0 e b  
b| 0 b e


заменим элемнты поля обозначение e на 1 и b на 2
{0 1 2}

и в таблицах тоже

+  0 1 2
  =======
0| 0 1 2 
1| 1 2 0 
2| 2 0 1


*  0 1 2  
  =======
0| 0 0 0
1| 0 1 2  
2| 0 2 1


а теперь пробежимся по таблтцам и убедимся что таблицы полностью совпдаают
если расчет вести на основе модулюса 3 и формул

для сложения:  (a+b) = мин пол вычет от (a+b) mod 3
для умножения: (a*b) = мин пол вычет от (a*b) mod 3

и это так.

поому что как уже сказал  в книжке написано что если числ N=(prime)^1
в нашем случае N=3^1
то элементы поля и ариметика поля полностью совпдают с множеством всевемозможных
мин пол вычетов для модулюса N то есть элементы поля это числа {0,1,.... N-1}
действительно если N=3 то его все возможыне мин пол вычеты это 0 1 2 
а арифметика с этими элементами такая же как арифметика нахожддения мин пол вычета
для множества вычетов с модулюсом N и одним из членов последовательности равным (a+b)
либо (a*b)
тоесть если мы хотим найти для поля чему равен (a*b)
то для этого надо найти мин пол вычет для можества вычетов в котором моудлюс N
и один из членов множества вычетов явлется (a*b)
      мин пол вычет от мноества вычетов (a*b) mod N

и если мы хотим найти для поля чему равен (a+b)
то для этого надо найти мин пол вычет для можества вычетов в котором моудлюс N
и один из членов множества вычетов явлется (a+b)
      мин пол вычет от мноества вычетов (a+b) mod N

как я понимаю то что я описал только что это поле. оно по факту построено не на типа
просто числах а вот так  у нас есть множество целых чисел G=Z 
            G={..., -4, -3 ,-2, -1, 0, 1, 2, 3, ..}
на этих числах у нас наверное задана обычная числовая арифметика. 
  -4+ -3 = -7
  4 * -3 = -12
далее берем вот такое множество
            I={.. -10 -5 0 5 10 15 ...}
оно будет идеалом. почему. потому что если мы возьмем любой элемент  из I
и умножим ( по законам классической арифметики) на любой g из G то этот элемент
будет лежать обратно в I.  если мы тут вспомним про модулюсы то множество I 
можно еще вот так описать  0 mod 5
и теперь мы разрежем G на куски по  классам экивалентности, мы говорим что a и b из G
эквивалентны a~b, если a-b лежит в I 
теперь режем первый класс эквавентности. берем a из G напримре это элемент 1
и формируем множество из элеметов вида 
         1+I = { .. -9 -4 1 6 11 16 ... }
все эти числа в 1+I они эквиваленты с 1 тоесть
         1 ~ с любым из  { .. -9 -4 1 6 11 16 ... }
поэтому 1+I это класс экивалентности с элементом 1

вырезали его и выкинули из G
берем следущий a из G который в нем остался. это число 2 и вырезаю класс экивал
         2+I = { .. -8 -3 2 7 12 17 ... }
вырезали его и выкинули из G
берем следущий a из G который в нем остался. это число 3 и вырезаю класс экивал
         3+I = { .. -7 -2 3 8 13 18 ... }
и так мы далее вырезаем класс за классом экивалентности
         4+I = { .. -6 -1 4 9 14 19 ... }
остался  последний класс экивалентнсоти это сам I , его мы тоже щас вырежем
         0+I = {.. -10 -5 0 5 10 15 ...}

в итоге наш G распался на 5 классов экивалентнсоити

        {.. -10        -5        0       5       10       15 ...}
          { .. -9        -4        1      6        11       16 ... }
            { .. -8        -3       2      7         12       17 ... }
               { .. -7       -2       3     8          13       18 ... }
                 { .. -6       -1      4     9           14       19 ... }

видно четко что эти 5 множеств они полностью вычерпывают наше исходное множество G

[0] =    {.. -10        -5        0       5       10       15 ...}
[1] =    { .. -9        -4        1      6        11       16 ... }
[2] =    { .. -8        -3       2      7         12       17 ... }
[3] =    { .. -7       -2       3     8          13       18 ... }
[4] =    { .. -6       -1      4     9           14       19 ... }


теппрь мы составляем новое множество из этих классов экивалентсноти где каждый класс
это класс экиваленнсости

G/I = { [0], [1], [2], [3], [4] }

ксати каждый элемент(он же класс экивалентности) можно еще вот так описать

G/I = { 0 mod 5, 1 mod 5 , 2 mod 5 , 3 mod 5, 4 mod 5 }

конечно мы можем заменить обозначения элементов вот так

G/I = { 0, 1 , 2 , 3, 4 }

соовтесвтенно эти цифры это непросто числа. это получатся образующий элемент 
в классе экивалентности. мы просто заменили обозначение но реально за каждой из этой цифр
лежит множество класс экивалентсоности. и получается по физике каждая это цифра это один
из возможных мин полож вычетов для модулюса 5.

ну или к такой форме записи вернемся

G/I = { 0+I,  1+I, 2+I, 3+I, 4+I }

для этих элементов задаем две бинарные операции 
     (a+I) + (b+I) = (a+b) + I
     (a+I) * (b+I) = (a*b) + I

или 
     [a] + [b] = [a+b]
     [a] * [b] = [a*b]

вроде как просто. но тут хитрость. 
рассмотрим на пример на примере

    (3 + I) + (2 + I) = чему будет равно? казалось бы 5 + I 
а нифига. 0+I
щас покажу

берем можество I 
     {.. -10        -5        0       5       10       15 ...}
прибавляем к каждому элементу 3+2 
     {.. -10+3+2        -5+3+2        0+3+2       5+3+2      10+3+2      15+3+2 ...}
получаем
     {.. -5        0       5      10      15      20 ...}
а это множество эквалентно можноеству I или 0+I что одно и тоже.
тоесть когда мы проводим арифм операция в 


G/I = { 0+I,  1+I, 2+I, 3+I, 4+I }

пользуясь этими праивлми

     (a+I) + (b+I) = (a+b) + I
     (a+I) * (b+I) = (a*b) + I

то надо понмить что конечный ответ должен принадлежат к тому множеству. не вылезать 
за него.

получается что как бутто это правило 
     (a+I) + (b+I) = (a+b) + I
оно не совсем такое а такое что когда  мы посчитали  (a+b) + I
сложив a+b по классической арифметике 
то мы смотрим невылезает ли (a+b) + I за наружу наших элемнтов поля. и если да то 
пытаемся его выразить через заданные элементы. поэтому это меня приводит к мысли что 
когда мы берем G

            G={..., -4, -3 ,-2, -1, 0, 1, 2, 3, ..}

то арифметику на нем мы берем не обычную а сразу модулярную. 
а именно. берем для начала задаем модулюс 5.
и сумма двух элеметов из G это 
    не просто a+b а вот так
    (a+b) =  мин пол вычет от (a+b)  mod 5
например -3 + -5 =  мин пол вычет от (-3+-5 mod) 5 = 2
    -3 + -5 = 2 
задаем идеал I : 0 mod 5 = { ... -15 -10 -5  0  5  10  15 ... }
посколтку арифметика у нас моульная проверим что она работаем в том плане что 
для g из G и i из I   должно g*i принадлежать всегда I

     g=7 i=25    g*i= мин пол вычет от (g*i) mod 5 = мин пол вычет 175 mod 5 = 0 
а 0 принадлежит I
понятно что при любом g и любом i у нас произвеление g*i всегда будет 
у нас всего один элемент 0  потому что  
     
     мин полож вычет (a*(число кратное 5)) mod 5 это всегда = 0

српшиватся а зачем тогда брать можество I такое большое если произвдеение g*i это всегда 0.
может надо взять I состоящим из одного нуля? ответ нет. надо брать I широко. чтобы
класс экивалентности вырезал сразу дофига элементов из G

но зато при модульной арифметике с самого начала мы буем иметь вот что

   G/I = { [0], [1], [2], [3], [4] }

при сложении элементов по правилу
  
        (a+I) + (b+I) = (a+b) + I

мы будем сразу получать то что надо. без коректировки руками. щас покажу

     (4+I) + (3+I) = (4+3) + I

высчитываем чему равно (4+3) = мин пол вычет от (4+3) mod 5 = 2
значит

     (4+I) + (3+I) = 2 + I

и это правильно. и нам ненужно руками пеерводить 7+I в 2+I если бы это была обычная 
арифметика. 

в общем я хотел показать и докаать что если у нас N=prime^1 напрмиер N=5
то элемеатми такго поля являтся не просто цифры. а являются  множества. а именно
классы экивалентности. каждый класс состоит из да простых чисел. но арифметика 
для работы с этими числами она модулярная.  тоесть
 
    { 0, 1 ,2, 3, 4, }

это на самом деле 

{ 0 + I , 1+ I , 2+I , 3+I , 4+I }

а оно по факту это 

{ {0,5,10,15,20,...},    {1,6,11,16,21,...},    {2,7,12,17,22...}, ...             }

и сложение двух элементов выглядит вот так

1+I + 2+I это = {1,6,11,16,21,...} + {2,7,12,17,22...} 
и тут опять же нао помнить что сложение это никакое не сложение. это операция которая
берет два эелмента поля и ставить в соотсветие ему третий элемент поля. она нчиего не складывает.
нам лишь надо понять какой третий эдемент взять. поэтому пофакту эти множества
они не склдываются. это условность.
тоесть

1+I + 2+I это на саомм деле f(  1+I, 2+I   ) = некий третий элмент поля.

насколко я понимаю формулу  (a+I)  + (b+I) = (a+b) +I 
то она расшиыроывется так. чтобы нам найти тертий элемент поля. чтобы нм понять какой элеент
поля ставится в соовеавтие надо взять образующий эемент из первого аругмента это "a"
и взять образующий элемент второрого аргумента "b" и сложить из по арифметики исходного поля G
потому что  a и b это элементы именно исходного поля G. и эти элменты нужно обрабатввыать 
той бинарной операцией сложения к которой эти элементы приандлежат. тоеть фраза

  (a+b) она перводится так =  опрееделить к какому множвству принадлежит элемент a , далее
опредеиьт к какому множеству принадежит элемент b. они по иде должны поианадлежать одному
множству. например это G. далее найти таблицу сложения для множства G. заглянуть в нее
и найти какой элемент выдает таблица сложения поля G для a и b. 
тесть важно понять что для вот этго сложения

    (a+I)  + (b+I)

берется бианрная операция сложения которая введена на поле G/I потому что эементы
(a+I) и (b+I) принадлжат к полю G/I

а операцию сложения  вот такую 
    (a+b)

надо проводить по правилам сложения в поле G потому что элеенты a и b приадлежат полю G 

поэтому вот в этой форуле

(a+I)  + (b+I) = (a+b) +I 

рассматривая левую часть 
   
   (a+I)  + (b+I)

у нас идет операция  сложения двух элементов из поля G/I поэтому надо заглядывать в
таблицу сложения элементов поля G/I и там наоходить третий элемент.
справа по хитрее

  (a+b) +I 


вот этот кусочек (a+b) он гоорит о том что у нас идеи операция сложения в поле G
берется элемент a из G  , беретя эдемент b из G и им ищется по таблице сложения из G
некий третий эдмент. пусть это элемнт c тогда подсатляем

   c + I 

с одной стороны это множство которое образуется вот как
мы берем элемент c из G , мы берем некотоырй элемент i из I  причем этот i также принадлежит G
и мы слкадыаем
   
     c+i по законму сложения двух элементов из G по таблице сложения из G

мы пееребирваем всем i и получаем множсвто

   c+i(1)
   c+i(2)
   ,,,
   c+i(end)


немножко конечно стремно что мы его обозначаем как 

   c+I 

потому что это операция сложения с двумя аргументами. левый аргумент это единичный 
лемент поля G а правый арунмент это множество. тоесть у нас не совсем обычная привычная
бинарная операция слоения потому что у нее  два аргумента не являются одинаковыми сущностями
что стремно. слева единичный элмент а спрва множство.

поэтму когда мы видим знак  +   , бинарная операция условного сложения то нам надо 
сразу четко понимать к какому множеству элементов она принадлежит. потому что операция 
сложения ее таблца задается на конкретном множестве. на конкреным элементах. 
а в случае сложения вида 

   c+I 

это вообще стремная операция. отому что она задается на множстве элемнтов из множества G
я про левый арумент. и подмножестве множества G , я про правый аргумент.

тоесть таблица сложения для c+I выглядит вот так


 с+I = {  c+i(1),
          c+i(2),
           ...
          c+i(end) }



тогда формула

   (a+I) + (b+I) =  (a+b) +I

имеет такой смысл. если мы работаем в можестве где элементами являются множества
вида q+I и мы берем два таких элемнта которые получатся имеют вид


       {  a+i(1),              {   b+i(1),
          a+i(2),        и         b+i(2),   
           ...                     ...
          a+i(end) }               b+i(end) }

и хотим найти их условуню сумму. тоесть поставить им в соотсвутие какое то множеств
вида 


  {  q+i(1),              
     q+i(2),           
     ...           
     q+i(end) }          


то вот этот q мы выситываем по формуле (a+b) и тогда наше итговый элемент будет иметь вид

  {  (a+b)+i(1),              
     (a+b)+i(2),           
     ...           
     (a+b)+i(end) }          

причем (a+b) мы вычисляем по правилу суммирования элементов поля G исходного

во такое правило выбора третьего элмента из G/I при "сложении " двух элементов из G/I

эта вся схема составления поля если  N=prime^1

тогда у нас элементом поля в этом случае  является множество и а имено класс эквивалентсности. 
и это множство состоит из набора просто обычных чисел с одинакомы расстоянием между соседними
например на примрее поля которое мы только что расматрвали

  G/I = Z/(0 mod 5) = { 0+I, 1+I, 2+I, 3+I,4+I        }
где скажем элемент 1+I это 

1+I={1, 6, 11, 16, 21, 26, ....}

итак еще раз что я хочу пдреодчекрунуть что элементом такого поля яявется множество
состоящее из обычкновенных чисел между котрыми одинаковое расстояние. 
такова подноготная элемнтов такого поля.

это важно понять потмоуу что щас мы начнем сотавлять поле где N=p^n и n>1
и там элементом такого поля будет тоже множество но оно не бует состоять из просто чисел
равнодуаленных. оно будет состоять из чегото другого.


что делабт дальше. берут поле такое как мы только что рассматривали где N=prime^1
наример F[2]
мы имеем эдементы и арифметику над этими элементами тоесть таблицу сложения и умножения
с этмими элемнетами.

далее берут и составляют полином вида

   i(n)*(y^n) + i(n-1)*(y^(n-1) + ... + i(0)*(y^0)

где i(n), i(n-1), i(n-2),  это элементы поля F[2]
так как поле F[2] состоит из условных элементов 0 и e или 0,1 
то все эти i это либо 0 либо 1.  только нао понмать что  0 и 1 неропсто числа а 
элементы поля F[2] с таблицами арифметики над этим полем.

рассмотрим для начала простой полином  из одного члена
 
        i*y
  
они  часто пишу что y это некая формальная перменная не имеющая отношения к элементам
поля F[2] но  я считаю что это хрень собачья потому что. что мы видим формально. 
мы видим что у нас задана операция сложения. и ее два аргумента. я бы даже вот так всегда писал
не в виде

      i*y 

а в виде  

     *(i,y) 

и не в виде

      a+b

а в виде

      +(a,b)

потому что такая запись более точно отражает суть. что * что + эта функия с двумя аргументами.
поэтому запись виде

      +(a,b)
      *(a,b)

она точно отражает суть
а запись вида

      a+b
      a*b

она только путает


так вот полином как я говоил ранее это просто суперпозиция , череда операций сложения
и умножения. и не более того. вот  у нас простой полином в котором всео навсего
одна операция умножения больеше ничего

    i*y


кода мы гвооим про умножение либо суммиование то надо понимать что эта функия она 
не сама по себе она задается над некоторрым множеством G. из которого она берет 
два элемнта приандлежащих этому множеству. вот в данном случае взято два элемента 
   i и y 
до этого мы все время рассматривали такие опецрации умножения в которых оба элмета
принадлежать однму множеству. 
также был диковинный случай сложения

  a+I

когда у нас один аргумент a это просто элемент приандлежащий полю G а второй аргумент
это множетво (а непросто элемент) но это I тоже принадлежит G

теперь же они говорят что y может и не принадлежать тому же множеству что и i
тоесть данное умножение это якобы функция которая берет i из одного множества как арнумент
и y из другого мноества.  и выдает элемент который  какому множеству принадлежит? первому
или второму? непонятно. хрень какаято. поэтому  я буудт считать как и прежде что и
первый аргумент i и второй аргумент y оба принадлежат однму множеству а именно множеству
в котороом лежит i тоесть F[2]

тоесть наш полином

   i*y 

это умножение двух элемнетов из F[2] на снове таблциуцы умножения элементов в F[2]
простов полиноме один из арументов задается в явном виде тоеть указвается прям какой 
жлемент из G мы берем как аргумент нпрмиер i=1 тогда полином

   1*y

либо i=0 тгда полином

 0*y

а второй аргумент не указывается в полиноме. а является переменной. но эта перемена
это как я уже сказал тоже ежлемент поля F[2] прсто он явно не указан. 

выражение вида y^2 означает на самом деле просто y*y 
а скажем y^n это y*y*y*y...y просто n раз. такое всегда можно вычислить 
умножая y*y ищем по таблице умножения в G и потом продолжаем умножать. пролем нет.

так вот берут и составляют всеовзомэные полиномы вида

  i*y^n + i*y^(n-1) + ... + i

при каждом y нас свой i. конечно они разные

так как i это элемент поля F[2] и y это элемент поля F[2] и полном это просто череда
суммироания и умножения резултатом которых явялется тоже элемент F[2] то поулучается что 
конечны продуктом полином явялется просто напросто какойто элемент из F[2]!!!
это важно понять. что полиом это просто напросто черед сумм и умножений впыполенных
последоваетлно и в итоге оно нам просто выдаст как резултатт некоторый элемент из F[2] и все!
значит мы составялем вот такие полиномы всех степеней. коэифициенты при y  у нас это 
как я уже сказал элементы из F[2]
и мы из этих полиномов составляем множество. оно бескоенчное. элементом ялется полином.
хотя по факту если подставит вместо y какйото элемент из F[2] то пофакту это множество
полиномов это просто будет множество элементов из F[2] и ничего более. шас покажу.

вот у нас есть поле F[2]= {0,e}

далее начинаем создвать полиномы с клэфицентами из F[2] 

0 
e
e*y
0*y
e*y^2

ну и хватит. понятно что множество полиномов бесконечно. но будем ситать для примера
что оно конеченое

множество полиномов тогда это = { 0, e, e*y, 0*y, e*(y^2) }
выглядии загадочно. на саомом деле подставляем y=e тодга получаем
 

 { 0, e, e*e, 0*e, e*(e^2) } = { 0, e, e, 0, e }

а теперь подствим y=0 тогда множествао наших полномов это 

 { 0, e, e*0, 0*0, e*(0^2) } = { 0, e, 0, 0, 0 }

тоесть в итоге множество полиномов это просто череда повторярябщихся элементов поля F[2]= 0 и e
и все! теость в коенчоом итоге каждый полином составленый над полем F это просто напросто
один из элементов этого поля F и все!
просто в поле который множество каждый элеенмент приствует один раз.
а в множстве полиновом каждый элемент из F пристувутет огомромное количетво раз. 
но это все тоже самое мнеотве из тех же самых элементов!! вот что важно понять. 
еще напимре еслт поле у нас F[3] = {0,e, b}

то множествао полиномов над этим полем это в конечном итоге

   {0,e,b, b,b, e, 0,b,e,b ....}

и не более того

так что полином в конечно итое это всего нвсего элемент множества G элементы которого
прсиутвтужт в полиноме как его так назвыаммые коэфицианты. а перемнная в полиноме онаже
тоже явелсяется элементом из этоо поля. поэтому полином это всегонавсего закодиоыванный
один из элементом поля G и все! это элемент! 

итак у нас есть поле F у него ест эелменты.
мы создаи всемозомжыне полиномы с кэфицентами из элемтов этого поля F
далее мы создали можество из этих полиномов.
дальше мы для этго множетсва полиномов задаем операции сожения и умножения. тоеть 
они берут два полинома и ставят в соосвтвие третий полином из этого множества. 
причем эти опрации они должны удовлеть треобованиям  операций сложения и умножения 
на кольце. хорошо. мыполучили так называемое кольцо полиномов над полем F 
это кольцо обозанчают как  тоесть задано поле F[N] и над ним задано F[x]
если мы всесто x подстави элемент из F[N] то в конечном итоге множество F[x]
это просто ножестов элементов из F[N] котооую идут чередой рандомно. вот и все.

по поводу арифм операций с полиномами

(x+1) + (x+0)

как мы это считаем. а вот как

(x+1) + (x+0) = (1*x+1) + (x+0) = (1+1)*x+(1+0)

тоесть на выхлопе операция сложения двух полинов ставит всооветввие конечно же 
тоже полином. коэфицианты мы этом третьем полиноме мы вычсиытываем на оснвое поераций
сложения и умножения элементов поля F[2] ! тоесть

 1+1 = ?
 1+0 = ?
 мы ищем какой элемент дают эти сложения пользуясб правилом сложения элементов в поле F[2]!
тоесть так как в поле F[2]  1+1 дает нам элемент 0 то  1+1=0 и 1+0=1 в поле F[2]
тогда 

(1+1)*x+(1+0) = 0*x+1

поскольку в поле F[2] 0*a= 0 при любом a тогда

(1+1)*x+(1+0) = 0*x+1 = 0+1 =1

значит

(x+1) + (x+0) = 1

тут ксатти мы четко видим что итого полинома на выхлопе явялется ни что иное как
просто один из элементов исходного поля F[2] в данном случае это элемент  1 он же e
и ничего друого полином не означает!


дальше вводят понятие неприводимого полинома в этом F[x] при поле F[N]
это такой полином который не разбивается на две скобки. как их искать это отдельная тема.
я ее неизучал. непонятно.

например полином y^2+1 он явлется нерпиводимым над полем F[2]
почему? потому что если бы он был приводимым тогда он бы представлвялся в виде двух 
скобок. значит так как полином второй степени он неразбиватся на две скобки кроеме
как так что в каждой скобке у нас полином первой степени. больге никак не разбить.
если поином первой степени он выглядит как то вот так
   
    A*y+B*1
ну или
    A*y+B*e
 
тгда y^2+1 = (A*y+B*e) * (C*y+D*e)
раскрываем скобки

A*C*y^2+A*D*y+B*C*y+B*D = (A*C)*y^2+(A*D+B*C)*y+B*D 

получаем 

   y^2+1 =  (A*C)*y^2+(A*D+B*C)*y+B*D 

чтобы два подинома совпало надо чтобы совпаи все его коэфиценты значит

|   1 = A*C
|   0 = A*D+B*C
|   1 = B*D


так как поле у нас F[2] то у нас каджый из A,B,C,D это либо 0 либо e
просто попробуем все вариаанты

варианты такие

A B C D
0 0 0 0
0 0 0 1
0 0 1 0
0 0 1 1
0 1 0 0
0 1 0 1
0 1 1 0
0 1 1 1
1 0 0 0 
1 0 0 1
1 0 1 0
1 0 1 1
1 1 0 0
1 1 0 1
1 1 1 0
1 1 1 1


так как у нас 1 = A*C а мы занем что в F[2] произвдение на ноль никоода 1 не даст
это значит что и A и C должен бть кажый только 1
значит число вариантов сокращается

A B C D
1 0 1 0
1 0 1 1
1 1 1 0
1 1 1 1

так как 1=B*D  то это требует чтобы B=1 и D=1
значит вариант сокращаются до

A B C D
1 1 1 1

подставляем во второе

A*D+B*C = 1*1 + 1*1 = 1 + 1 = 0 

кхм... вроде подходит.

значит y^2+y+1 = (y+1) * (y+1)
еще раз проверим 

(y+1) * (y+1) = y^2+y+y+1=y^2+(1+1)y+1=y^2+0+1 = y^2+1

значит y^2+1 не явелтся нерпиводимым над F[2]

а вот y^2+y+1 точно не явялется нерпиводимым!
все тоже самое толко 

A B C D
1 1 1 1

вот эта штука  A*D+B*C = 1*1 + 1*1 = 1 + 1 = 0  она должна быть равна 1.
а она ноль значит

y^2+y+1 неприводимый полином. 

а вот интересно. пусть y=0 тода   y^2+y+1=0*0+0+1=0+0+1=1
                 пусть y=1 тогда  y^2+y+1 = 1*1+1+1 = 1+1+1=0

посмотрим с привоимым 
y^2+1

                 пусть y=0 тода   y^2+1 = 0*0+1=1=1
                 пусть y=1 тогда  y^2+1 = 1*1+1=0

немнго непонятен физ смысл неприводимого полинома. ведь он в конце концов
всег лишь элемент поля F[2] так что такого особого в этом элементе. как мы видим
что привдимый полином что нрпиводимвый при разных y в итоге выдают оба элемента поля F[2]
в этом плане они одинаковые. 

посмотрим на приводимый через призму скобок

   (y^2+1)=(y+1)(y+1)

   y=0   (0+1)(0+1)=1*1=1
   y=1   (1+1)(1+1)=0*0=0

тоесть если полио приводмый это в конечно итое значит что наш элемент поля F он
выражается как произвдеение двух элементо поля 

    ()*() = ()

непонятно. у нас что приводимый полином принимает занчение конечное 1 и 0 
и эти элементы они выражатся спокойно чререз проивзеение 1*1 и 0*0
так и непиводимый полином примает занчения 1 и 0 но почемуто этот 1 и 0 
не выржается через проивзведение двух элементов поля. странно. 

ну как бы получется что если полином выоажется через две скобки то это как бутто 
значит то что в этом случае работает дистрибутивный закон. который раксклывает эти
две скобки на сумму произведений. а если полино не раскладывается на две скобки то 
это значит что невозможно подобрать две скобки так чтобы для них был верен 
такой вид дистрибутивного закона.
в обшем неочень понятен физ смысл неприводимого полинома. тоесть понятно что полином
это череда умножений и суммирований в итоге. если полином приводимый то значит та череда
умножений и суммирований которая в нем указана она представима в виде просто умножения 
двух элементов. каждый из которых это тоже сумма умножений и суммрования. в общем неопнчент
понятна физ разница полинома непиводимого и поиводоимого. 
понянтно только то что полином это чререда суммиорваний и умножений элементов из F[2]
и на выходе полином это всего нвсего элемент из F[2] .

вобщем находим нерпиводимый полином такой то степени. потому что на самом деле бывает
куча полиномов непиводимых над полем F одной степени. и разных степеней.

находим хотя бы один и выбираем его. на основе этого полинома мы строиим идеал в этом
множестве полиномов. идеал строим так. это все полиномы которые можно преставить в виде

   f(y)*(.......)

тоесть это все полиномы которые можно представить в виде скобки f(y) и еще какойто скобки.
где f(y) это наш выбрарный нерпиводмый полином.

это наш идеал

I= { f(y)*(..), f(y)*(...), f(y)*(....), ...}

какой бы мы полином из нашего G=F[y] ни взяли и какоц бы полином из I мы ни взяли
перемножаем их и  итговый полином будет иметь всегда иметь вид

  (........)*f(x)(.....) = f(x)*(.............)

тоесть итоговый полином принадлежит I. тоесть это реально идеал. 

потом мы на множестве полиномв задаем криетрий экивалентности в виде

   g(y) ~ t(y)  если   g-t лежит в I

далее берем g из F[y] фикисируем его. и сдвигаем наш идеал на g тоесть это будет 
множество

   g + I

это будет класс эктвалентности.

и вот таким макаром мы режем наш исходный G=F[x] бескоенченое множество полиномов
на классы экивалентнсости. 

прикол в том что несморя на то что полиномов беск множество в F[x]
но классов экиваентности (этих множеств) в штуках будет конечное количесво

рассмотрим это на примере идела созданного на непривдеенном полиноме

       y^2+y+1

идеал будет выглядеть как  множество полиномов вида

   (y^2+y+1)* (......)


теерт вот что. берем самый мелкий элемент множества полиномов а это 0 но начнем все 
таки с 1 и вырезаем из F[y] все полиномы вида


1 + I 

это мы вырезали один класс экивалентсности.

теперь присмотримся к этому клкссу полиномов.  в чем их суть. возьмем любой полином
из вырезанного класса. 

g = 1 + (y^2+y+1)* (......)

если мы раскроем собки и предем подбрные то получим некий полином. если мы его через 
стоолбик поделим на (y^2+y+1) то получим проиведение вида (y^2+y+1)* (......)
а 1 это будет остаток от деления!  таким образом в нашем первом класс экивилентснотси
попали все полиномы которые при делении на (y^2+y+1) имеют в остатке 1 ! вот что 
их обьедиянет.

а теперь подумаем на глобальным общим вопросом. если у нас есть полиномы и мы их 
делим на (y^2+y+1) тот как будут выглядеть отстатки от деления ? если подлить пару
примеров любобго полинома из F[2] на (y^2+y+1) то станет заметен закон. о том что 
остаток от деления это всегда полином вида на одну степень меньше чем самая старшая
степен полинома на который мы делим. тоеть. мы делимна подином 2-ой степени значит
всевоможное множество остатков при делении на такой полином это полином 2-1 степени
тоесть 1-ой стпени. как выглядит в общем виде полном первой степени

   A*y+B*1

где A и B это элементы поля F[2] тоесть это либо 0 либо  1 он же e
тоесть множетство всех полиномов остатков будет иметь вот какой вид

 0*y+0*1 = 0 
 0*y+1*1 = 1
 1*y+0*1 = y 
 1*1+1*1 = y+1

если мы рассмотрим полином как разложение некотрого числа по  базису или
системе счисления то схематично это выглядит так

00
01 
10 
11

ничего не нпопминает ? да это же байт из двух бит!
кажый бит это y^n а значение бита это всевзможные значения поля F[2]
как это нам может быть полезно? представим что у нас было бы в основании поле F[3]
тогда вот такое "битовое" представление полинома удобно тем что черезз него очень 
просто и удобно получит весь набор всемозомжных значений. показываю.
если каждый бит принимает знаения 0,1,b то тогда

00 = 0*y+0*1 = 0
01 = 0*y+1*1 = 1
0b = 0*y+b*1 = b
10 = 1*y+0*1 = y+0
11 = 1*y+1*1 = y+1
1b = 1*y+b*1 = y+b
b0 = b*y+0*1 = b*y+0
b1 = b*y+1*1 = b*y+1
bb = b*y+b*1 = b*y+b

напоминаюю таблицу сложения и умнжения доля поля F[3]

+  0 e b
  =======
0| 0 e b 
e| e b 0 
b| b 0 e


*  0 e b  
  =======
0| 0 0 0
e| 0 e b  
b| 0 b e


но возвращаемся пока обратно к полю F[2]
и идеалу на основе полинома f=y^2+y+1
и всевозможным остатткам от деления любого полинома из F[y] на f

0 
1
y 
y+1


получается когда мы поделим все полиномы из F[y] на f то всевозможные осотатки 
которые будут при этом у этих полиномов это всего 4 штуки. будет этих остатков.
и говоряр другими еще словами если мы возьмем любой подином из F[y]
то он будет представим в виде одного из четырех форм

(y^2+y+1)*(......) + 0
(y^2+y+1)*(......) + 1
(y^2+y+1)*(......) + y
(y^2+y+1)*(......) + (y+1)

теперь мы замечаем что (y^2+y+1)*(......) это полином принадлежащий I
а в целом запись вида 

(y^2+y+1)*(......) + Q

она описывает все полиномы лежащие в одном классе экивалентности Q . тоесть 
любой полином предсавтимый в этом виде он экивалентен элементу Q из F[x]

значит наше исходное множество полиномов F[y]
в итоге распадается на четыре класса эквивалентности 

  0 + I,   1 + I,  y + I,   (y+1) + I


теперь я опять взвращаюсь к такому вопросу - мы взяли для формирования идела полином
второй степени. в итоге я указал (исходя из практики) что при делении бесконечного числа
полиномов из F[x] у нас будет в остатке полином не выше первой степени. дальше мы нашли
всевозможные полиномы первой степени с элементами из F[2]. их 4 штуки. 
теперь представлю что мы взяли непривдимый полином 3-ей степени. сколько будет остатков 
всевозможных(сколько классов эквивлваентности) ? если мы делим на полином 3-ей стеени
значит в остатоке будут всевоможные полиномы 2-ой степени с всеповожмыныи коэифицнтаами
из F[2] поля. полином 2-ой степени выгядит в общем случае так

    (A)*y^2 + (B)*y^1 +  (C)*e

где A,B,C это всевозможные элеенты из F[2] тоесть 1(он же e) и 0
найдем все эти возомжные виды этого полинома 2-ой степени.

ABC
000
001
010
011
100
101
110
111

тоесть будет 8 возможных остатков. будет 8 классов экиваилентснотси. 
так вот если посидеть и это все покрутить то приходит в итоге правило вот какое.

если у нас есть исходное поле F[N] из N элементов. и мы над этим полем создаем кольцо 
полиномов F[y] и потом выбираем идеал на основе нерпиводимого полинома степени k
то количество всевозможных остатток от делеия этих полиномов на этот полином оно 
будет равно

   N^(k)

тоесть мы взяли F[2] и взяли полином k=2-ой степени получили 2^2=4 остатка или 
4 класса экивалентсности.

взяли F[2] и полином 3-ей степени и получили 2^3 8 остатоков. или 8 класов эквивалености.
причем вид этих остатков он независит от кокннетного вида  неприводимого полинома (от его
коэфициантов) а зависит только от степени этого непривоимого полинома и разнообразия
элментов в поле F. тоесть если мы берем два полинома нерпиводимых одной степени
например 2-ой то множество остатков будет в обоих случаях одно и тоже.
тоесть вот мы брали непривдимый полином
  
  y^2+y+1 
предпоожим (в теории) что на поле F[2] ест еще один неприводимый полином второй степени
  y^2+1 (хотя он привоимы но это неважно чисто для примера)
так вот в обоих случаях множество всеовзможых осттатков от деления будет одно итоже

0 
1
y 
y+1


тоесть конкрнетный вид полинома нерпивдимого тоесть его кофэифиценты они на вид 
остатков никак не влияют. влияет только степень этого полинома и влияет она на количество
этих остатков. если в поле F[2] мы берем полином второй степени то число остатков будет

  2^2=4

если берем полином 3-ей степени то числоа остатков будет

 2^3=8

если возмьем полином 8-ой степени то чило остаттков будет

 2^8=128 штук

 2 - это количество элементов в исходном поле F

итак еще раз если мы берем исходное поле F[N] в котром N штук элентов.
потом над этим полем сздаем кольцо полиномов. 
потом выбираем непривоимый полином степени k. создаем идеал на основе него.
потом на основе этого иделала мы разрезаем наше колцо полиномов F[y] на классы эквивалетнрстти
то этих классов в штуках будет 

      N^k штук

тоесть если я возьму поле F=[5] в нем пять элементов. {0,e,b,c,d}
и таблица сложений умножений для этих эеметов.
потом с этим клэфиицентами построю кольцо полиномов F[y]
потом найду полином 8-ой степени на этом кольце. потом создам идеал на освное эого полинома.
потом разрежу по этому иделау наш F[y] на классы экивалентности то таких классов 
в штуках будет 

   5^8 штук

спрашивется а с чего сыр бор? зачем нам эти классы эквивлантности по этой схеме?
а дело в том что из этих классов экивилентсности - можно собрать новое множество.
где кждый элемент это класс экивалентсности. потом для этих элментов определить что
такое операция сложения и умнжения по схеме

   (a+I) + (b+I) = (a+b) + I
   (a+I) * (b+I) = (a*b) + I
   

и книжка утрведжждает что это множество F[y]/I будет являеться полем!
тоесть мы знаем его элементы и мы можем написать таблицу слоожений и умножения 
для этих эдементов на основе заданных правил

   (a+I) + (b+I) = (a+b) + I
   (a+I) * (b+I) = (a*b) + I


которые якобы так они гвоорят будут удовлетворять всем правилам сложения и умножения 
в поле


таким образом согласно всей этой эпопоеи мы науичлислись строить поля с заданным числом
элементов. и  таблицей сложенияи умножения в этом поле для этих элементов.

вот ради чего все это было.

прикольно что в этом большом поле элементом явялется множество полиномов. а полином
как мы помним это в конце концов элемент исходного поля на котором он строится. 

мне кажетяс я понял смысл этой строки

   (a+I) + (b+I) = (a+b) + I

если мы берем два элемента расширенного поля то сумма ставит в соотвесвтие этим двум
элементам такой элемент что его порождающий элемент расчитывается по формуле
 
    (a+b)

сумма расчитывается по правилам суммирования элемнтов в исходном поле F[N]
например 

у меня есть поле F[4] из элеметов   { 0 + I,   1 + I,  y + I,   (y+1) + I }
тоесть оно состоит из классов экивалентнсотей ,
где 0,1,y, y+1 это порждающие элементы этих классов эктвалентсостей которые лежат 
в поле F[2] на базе которого мы создали это поле F[4]

тогда операция "суммирования" в этом поле для элементов 

  (y+I)  + (y+1 +I) она этим двум элеметам ставим в соотвеавтие элемент этого поля

вот такой   (y+y+1) + I

где (y+y+1) это некий элемент который приадлжеит элементу поля F[2]
давайте надем этот элемент.

 (y+y+1)= (1+1)y+1 = 0*y+1=0+1=1

 значиит

(y+y+1) + I это 1+I

значит 
операция суммирования в поле F[4] двум элементам

  (y+I)  + (y+1 +I) 

ставим в соотвесвтуие элемент 

  1+I

принадлежить ли множество 1+I к множеству элементов поля F[4] ?
ответ да принадлежит

  F[4] =   { 0 + I,   1 + I,  y + I,   (y+1) + I }


тепрт найдем какйо элемент поля F[4]  ставится в сооовествие для элементов 
   (y+I) и (y+1 +I)  операцией умножения

тоесть мы берем два эелмента этого поля

(y+I)  и  (y+1 +I)   и хотим узнать какой элемент этого поля ставится им в соотвесвтие
операцией умножения 

          *(y+I, (y+1) +I )  = ?

или в более привычном но делильном виде

        (y+I)  *  (y+1 +I)   = ?


согласно правилу для умножения заданрому на этом поле им ставится в соотсветвие элемент
этого поля вот такой

    (a*b) + I или   (y*(y+1)) + I


где (y*(y+1)) это элемент поля F[2] давайте его найдем

(y*(y+1))=y^2+y

вроде бы как получется что это элемент который имеет  вид следущего множества 


              (y^2+y) + I

смотрим на множества которые соствляют элемента поля F[4] 

  F[4] =   { 0 + I,   1 + I,  y + I,   (y+1) + I }

чтото мы тут не видим такое множество.

и тут разгадка вот в чем. само множество которое мы нашли оно правильное

      (y^2+y) + I

но оно входит в одно из множеств которое указано в F[4]
осталось найти в какое множество оно входит и дело в в шляпе.

y^2+y | y^2+y+1
       ==========
        1

y^2+y+1
-----------
-1

получается что

y^2+y = (y^2+y+1)*1 -1 

-1  это элемент поля F[2] обозначающий его жлемент обратный к 1 и это элемент 1
значит

y^2+y = (y^2+y+1)*1 +1 

теперь смотрим на наше выражение которое мы изначально получили 

  (y^2+y) + I = (y^2+y+1)*1 +1 + I

I у нас это выражение вида  (y^2+y+1)*(.....)  , подставляем

  (y^2+y) + I = (y^2+y+1)*1 +1 + I = (y^2+y+1)*1 +1 + (y^2+y+1)*(.....) = 
собираем вместе члены с скобкой (y^2+y+1) получаем

=  1 + (y^2+y+1)*(.....+1)

тоесть еще раз у нас есть выржание вида


1+ (y^2+y+1)*1 + (y^2+y+1)*(.....) 

и я просто группирую  вместе  (y^2+y+1)*1 и  (y^2+y+1)*(.....) и получаю (y^2+y+1)*(..... +1)

итого 

  (y^2+y) + I = 1 + (y^2+y+1)*(..... +1)

вторая часть этого выржаение это полином принадлежащий I значит

  (y^2+y) + I = 1 + I

таким образом мы обнаружили что наш ответ это просто по другому записанное множество

   1 + I

а это можество уже является элементом F[4]

итак 
резулттатом умножения  в поле F[4] элемента  (y+I) и элемента (y+1 +I)

        (y+I)  *  (y+1 +I)  

является элемент 1+I
он им ставмися в соотвесвтие


        (y+I)  *  (y+1 +I)  = 1+I

напомню что поле   { 0 + I,   1 + I,  y + I,   (y+1) + I } в плане ее элементов
или вот так

     F[4] = { [0], [1], [y], [y+1] },  y это любой который принадлжит F[2]

по факту кажоый элемент это множество полиномов. кажое множество это класс эквиалентности
созданный из полиномов. каждый полином это список последователных операций сложения и умножения элементов поля F[2], конечным резулттатом или смыслом каждого полинома явялется некоторый элемент поля F[2] тоесть полином это на самом деле некотоырй элемент поля F[2]
чтобы узнать что это за элемент нужно высчитать полином. чтобы его вычистать в него нужно
вместо y подставить любой конкретный элемент из поля F[2]

распишем таблицу сложения и умножения для этого поля
в таблице сложения у буду каджый элемент обозначать вместо [y] как просто y
потому что и так понятно про какой элемент идет речь


 +    0    1    y    y+1
    =====================
0   | 0    1    y    y+1
1   | 1    0    y+1  y
y   | y    y+1  0    1
y+1 | y+1  y    1    0


таблица сложения в F[2] она щас нам пригоилдися

 +  0  e
   ======
 0| 0  e     
 e| e  0

или

+   0  1
   ======
 0| 0  1     
 1| 1  0



0+0 = 0 согласно F[2] сложению
0+1 = 1
1+y = 1+ (y+0)=(1+0)+y=1+y=y+1
y+y = (1+1)y=0*y=0



итак вот таблица сложения

 +    0    1    y    y+1
    =====================
0   | 0    1    y    y+1
1   | 1    0    y+1  y
y   | y    y+1  0    1
y+1 | y+1  y    1    0


доп проверка что она приавлальная в том что каждоая строка и кждый столбец
содержвать все элементы поля. и не повторов.

теперь таблица умножения


 x    0    1    y    y+1
    =====================
0   | 0    0    0    0
1   | 0    1    y    y+1
y   | 0    y    y+1  1
y+1 | 0    y+1  1    y


пригодися таблица умножения для F[2]

 *  0  1
   ======
 0| 0  0   
 1| 0  1

y*(y+1) = y^2+y , выше я установил что это аналоично 1, также зная y*(y+1) я знаю  (y+1)*y тоже 1

y*y = y^2, тоесть я получил множество вида y^2 + I

y^2 |  y^2+y+1
    ===========
       1

y^2+y+1
----------

-y-1

-y-1 = (-1)*y -1 
число -1 это число обратное к 1 по сложению по таблице сложения F[2] это элемент 1 значит
-y-1 = y+1

значит y^2 +I  =  (y^2+y+1)*1 + (y+1)  + I

я вот что постулирую если у нас два полинома из I то их сложение порождает полином
который тоже принадлежить I. так вот  полином (y^2+y+1)*1 лежит в I поэтому 

(y^2+y+1)*1 + I это просто полином лежащий в I тоесть 
 
    (y^2+y+1)*1 + I = I

тогда 

y^2 +I = (y+1) + I

значит y^2=(y+1)  в таблице


(y+1)*(y+1) = y^2+y+y+1=y^2+(1+1)y+1=y^2+0*y+1=y^2+1

y^2+1 | y^2+y+1
      ======== 
        1
y^2+y+1
----------
-y

-y это +1*y=y

значит y^2+1 + I = y + I
значит (y+1)*(y+1)=y в таблице


иттого табдлица умножения

 x    0    1    y    y+1
    =====================
0   | 0    0    0    0
1   | 0    1    y    y+1
y   | 0    y    y+1  1
y+1 | 0    y+1  1    y

проверкрй ее явялется то что  для y обратный элемени это y+1
а для y+1 обраный элемени это y

ксати почему ля таблицы сложения мы не делим на y^2+y+1 как мы это делаем 
поррой для талица уножения. да потому что элемент который мы получаем 
в таблице сложения ее порождающий элемент имеет степен 1. и в целом это можество
сразу уже выглядит как элемент нашего поля. 

финальная таблица

элементы поля     F[4] = { [0], [1], [y], [y+1] },  y это любой который принадлжит F[2]

две таблицы

 +    0    1    y    y+1
    =====================
0   | 0    1    y    y+1
1   | 1    0    y+1  y
y   | y    y+1  0    1
y+1 | y+1  y    1    0




 x    0    1    y    y+1
    =====================
0   | 0    0    0    0
1   | 0    1    y    y+1
y   | 0    y    y+1  1
y+1 | 0    y+1  1    y


теперь я могу заменить все элементы поля на просто буквы или цифры тоесть 

a=[0], b=[1], c=[y], d=[y+1]

либо 

0=[0], 1=[1], 2=[y], 3=[y+1]

и тогда можно вобще забыть про всю поднгогтноую этих элементов.


  F[4] = { 0, 1, 2, 3 }


 +    0    1    2    3
    =====================
0   | 0    1    2    3
1   | 1    0    3    2
2   | 2    3    0    1
3   | 3    2    1    0



 x    0    1    2   3
    =====================
0   | 0    0    0    0
1   | 0    1    2    3
2   | 0    2    3    1
3   | 0    3    1    2

и нам вообще все равно что там реально скрывается за этим элементами.

мы построили поле. элементы у нас есть. и праивла их сложения и умножения у нас тоже есть.


можно заметить что заполнять таблицу умоения очень даже трудоемко.
а если полле большое? замучаешься. и тогда они идут дальше

они говорят что в конечном поле есть такие элементы среди элементов поля что 
если мы будем согласо этой таблице элемент уможать сам на себя то это породит нам
вообще все элементы поля. такой элеиент поля называется "примитивным"
по мне термин ужасный.

есть теорема о том сколко таких примтиивных элементов есть в поле размера N.
число примтичныйх элментов равно Ф(N-1) где Ф это функция эейлера.
унас N=4 значит Ф(3)=2
значит среди нащих 4 элемегтов нашего F[4] поля есть 2 примтивных элемента

что такое фунукиция элейра от числа N 
это надо взять все числа натуральные от 1 по N-1 и  найти все которые являются взаимно
простыми с N и посчитаь их сумму. поехали

N=3 |  1 3 

 1 2  

1 и 2 явялется взаимно простым с 3 . значит сумма таких чисел 2.
значит Ф (3) = 2


значт элементы нашего поля это   0    1    2   3
0 и 1 вряд ли явобятся примтивными попробуем 2


 x    0    1    2   3
    =====================
0   | 0    0    0    0
1   | 0    1    2    3
2   | 0    2    3    1
3   | 0    3    1    2


2
2*2 = 3
2*2*2 = 3*2 = 1
2*2*2 = 1*2 = 2

получаем 

2^1=2
2^2=3
2^3=1
2^4=2

мы полуили все элементы поля кроме 0. тоесть элемент 2 яялется примтивным элемнтом этого поля.
он видимо и так понято что есть в поле
также видно что если степень у нас больше 3 то у нас ответ начинает циклическо
повторться тоесть нам для степени достаточно сделать n mod 3 и мы получим такой же
ответ. например нам надо 2^15 . нам нет необхимдости переножить 2 на себя 15 раз.
досатточно 2^ (15 mod 3) = 2^0=1

запишем то что получили  по другому

таблица 1
2=2^1
3=2^2
1=2^3

это нам позволяет любой элмент поля (кроме элемент 0 ) выразить через 2^x

и вот эту таблицу тоже сюда присунем

таблица 2
2^1=2
2^2=3
2^3=1



теперь если нам надо умножить два элемента от мы вот как делаем.
нпример нам надо умножить 2*2

2*2=2^1 * 2^1 = 2^(1+1 mod 3) =2^2
смотрим в таблицу2  

   2^2=3


другой пример 

2*3= 2^1 * 2^2  = 2^(1+3 mod 3) = 2^(1) = 2

 представл 3 как 2^2 согласно таблцие 1


и получается вот что классно. вот мы нашли все эдементы поля. 
  
   0 1  2 3 

берем ненулевой элемент. скажем 2
начинаем его самого на себя уможать.
 
  2 
  2*2
  2*2 
  2*2*2

если выясняется что через него можно получить 
все другие элементы. занчит он примтитивный. плюс мы кода это выянсли мы узнали как выразит
любой эемент поля через примтиный эдемент в такойто стеени. 


2=2^1
3=2^2
1=2^3


тееперь нам ненадо соатавлят
таблицу умнжения. если нам надо убмножить один элемент на другой. мы смотрим  в нашу
таблице. находим советвие элемента 3 что это 2^2

а далее просто рабоатетм со степенями 

  2*3=2^1 * 2^2 = 2^(1+2 mod 3) = 2^1 

  2^1 мотрим  в туже таблице находии что это 2

все мы посчитали призвление. 

для поля из 4 элементов это вроде как неважно но для поля из 9 элементов это уже круто. 
потому что чтобы заполнить классичскую таблицу умножения надо посчитать 9*9 примеров
тоест 81.

а если мы нашли примтивный элемент. а это у нас займет 9 примеров. то мы уже считай что
всю таблицу умножения нашли и заполнили ! вот что круто



Есть еще одна теорема о том что ели мы нашли притиный эелмент. то так как стальыне элементы
поля можно получить из него взводя его в степень то все сотальые примтичные элементы можно
найти просто возвеля наш приммтиный эемент в некоторую степень. так вот какая это степень ?
ответ такой что это степень такая и только такая что 
это такое число лежащее в диапазоне 1..N-1 что онно явялется взаимно
простым  с числом (N-1)

напимер N=4
N-1=3

3| 1 3

диапазон чисел 1..N-1 =  1 2 3 
взаимно простые числа с 3 это 1 и 2 

значит в поле N=4 если мы нашли пртимтиный элемент g то остальыне примтивные элменты
это g^1 и g^2 
ну g^1 это просто g это наш же уже известные примтнй эдмент. поэтому мы это отбрастываем
получается второй примтивный эдоемент это g^2

вот я нашел что элемент 2 явялется примтвиным 
значит второй примтивный элемент это 2^2  = 3

итак полуается что в поле F[4] = { 0 1 2 3 }
у нас два примтиных элемента 2 и 3


далее. при построении полей нужно понимаь  а как его лучше построить ?
например можно строит его как

2^3 тоесть это изначлаьно поле F[2]={0,1} и потом сверху на него наклдывается 
неприводимый полином 3-ей степени.  тогда остаток будет иметь вид полинома 2-ой
степени 
    (A)*y^2 + (B)*y + (C)
с коэфициантами 0 и 1. 

ABC
000
001
010
011
100
101
110
111

будет 8 штук остатков. поле из 8 элеметов мы построим.

а можно строить как 3^2
тоесть изачально поле F[3]={0,1,2}
на него налдывает полином непривоыдимый степени 2. 
тогда у него будет в остатке полином 1-ой стеени 

      (B)*y + (C)

а коэфициаент будут прыгать между 0,1,2

00
01
02
10
11
12
20
21
22

получается как условно говоря мы строим поле либо на том что у бит больше в байте
либо на том что у нас бит может принмиать больше разных значений. 
хотя может быть я вобще не в ту сторону все интерпретирую.

ну и я к чему. если мы хотим эдементу из поля поставит в соотвествие биты в компе.
то наверное логичнее строить поле на базе F[2] потому что бит у нас принимает либо 0
либо 1 ну и число бит обычно кратно 2. 
поэтому поле 2^2 или 2^2 или 2^8 выглядит логичнее для построения. чтобы потом
каждому жлементу поставитьв соответсвие бит в байте на компе

вот мы поле 2^2 уже построили это как бы байт из двух бит


  F[4] = { 0, 1, 2, 3 }


 +    0    1    2    3
    =====================
0   | 0    1    2    3
1   | 1    0    3    2
2   | 2    3    0    1
3   | 3    2    1    0



 x    0    1    2   3
    =====================
0   | 0    0    0    0
1   | 0    1    2    3
2   | 0    2    3    1
3   | 0    3    1    2

элемент 0 из поля это 00 байт
элемент 1 из поля это 01 байт
элемент 2 из поля это 10 байт
элемент 3 из поля это 11 байт

перепишу таблицу сложения тогда  с учетом этого сопоставлеия

 +    00    01    10    11
    ======================
00  | 00    01    10    11
01  | 01    00    11    10
10  | 10    11    00    01
11  | 11    10    01    00

так вот видно что ровно такая же таблица получится если мы на компе будем
складывать наш 2битный байт по этой же таблице на операции XOR
а XOR рабтает вот как:

  0 XOR 0 = 0
  0 XOR 1 = 1
  1 XOR 0 = 1
  1 XOR 1 = 0

тоесть если мы берем два элемента из таблицы и склдываем их чисто на компе по XOR

 11 XOR 11 = 00

то мы будем получать ровно тоже самое что нужно получать по таблице сложения элементов поля!

на счет таблица умножения я не знаю. но получается сопоставив элментам поля биты из компа
можно по крайней мере операцию суммы считать на компе в чистом виде. тоеть получать
ровно теже элементы что в таблице сложения эдментов поля ! аэто уже неполохо!


ксаььати в поле число его элеметов N это либо прайм число в первой степени.  тоесть само N
прайм. типа N=1,3,5,7,9,11,13...
либо N непрайм. но оно должнобыть представимо в виде prime^n где n натуральное
например

N=8  

8 непростое. но имеет вид 2^3
где 2 это простое а 3 это натулральное

непонятно вот что. пордок поля тоесть число его элементов это всегда  некоторый прайм
в натуральной степени. тоеть

2^n или 5^n или 13^n итд.

а вот к примеру поле размером N=2^155 + 2^62 + 1
совершенно точно что N не является степень числа 2. а тогда степенью какого числа
явялется это N? чтобы можно было утверждать что можно создать поле для этого числа
элементов ?


как на питоне проверить что число явялется прайм числом

ставим пакет
 # pacman -Sy python-sympy

далее надо создать вирт среду иначе пошлет нафиг (взял решение тут https://stackoverflow.com/questions/75602063/pip-install-r-requirements-txt-is-failing-this-environment-is-externally-mana)

$ python3 -m venv .venv
$ source .venv/bin/activate
$ python3 -m pip install -r requirements.txt


сама прога

  #!/usr/bin/python

  import sympy
  num = 2**155 + 2**62 + 1
  if sympy.isprime(num):
    print(f"{num} is a prime number.")
  else:
    print(f"{num} is not a prime number.")
 


частов инете праймы даются в hex виде

#!/usr/bin/python

import sympy
num = 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A63A3620FFFFFFFFFFFFFFFF
if sympy.isprime(num):
    print(f"{num} is a prime number.")
else:
    print(f"{num} is not a prime number.")




а вот еще прога которая поволяет указать полином и проверить
приводимый он или нет

https://github.com/TheSil/irreducibility_criteria_checker

вот так у нее работает авточек

$ python -m unittest discover

вот так она запускается уже для практического использования

$ python3 check_all.py  "x^256+x^16+x^3+x+1"

прога испольует несколько крртитериев для проверки что полином неприводимый.

чтобы использовать только один какйто криеткрерйи ее якобы можно 
запускать вот так

$ python criteria/eisenstein.py "x^3-2*x^2+2*x+2"

однако я сраз уговорю что так нифига не работает.

также возникает вопрос а над каким базовым полем проверяется неприводимость
полинома? исходя из коды для всех полей от 2 по 30. тоесть для полей F[2] , F[3], ... F[30]




дале следущий момент. 
обычно при описании поля или построении поля указывают исходное простое поле
например F[p] от котороо мы отталикваеимся и указывают неприводимый полином 
степени "^n" над этим полем.
исходя из этого можно посчитать сколько будет точек (элеметов) в конечном поле.
тоесть p^n 
можно узнать как будут выглядеть элементы этого поля. и посчитать таблицы сложения
и умножения.
в rfc oakley и нетолько в этом rfc а и в других rfc посвященны криптографии
(https://datatracker.ietf.org/doc/html/rfc2412#appendix-A)  поле описывают 
несколько по другому.  они нам сообщают размер КОНЕЧНОГО поля в виде F[2^155]
несообщают начальное поле тоесть мы должны догадаться что это F[2] и сообщают
нам непривидимый (irreducible) полином x^155+x^67+1


длаее. по поводу таблицы построения таблицы умножения через перемножение примтивного 
элемента на самого себя. например поле F[2^3] неприводимый элемент y^3+y+1
элеенты этого поля  все возможные полиномы степени (3-1)=2 первой степени. где
коэфиициенты принадлежат полю F[2] тоесть
  полином 2-ой стеени выглядит как

      A*y^2+B*y+C*1
начнем варьировать A B по всем возможным вариантам из F[2]

ABC
000 = 0
001 = 1
010 = y
011 = y+1
100 = y^2
101 = y^2+1
110 = y^2+y
111 = y^+y+1

значит поле F[2^3] иммет элееменыты { 0+I, 1+I, y+I, (y+1)+I, y^2+I, (y^2+1)+I, (y^2+y)+I,
(y^2+y+1)+I  }

примтивных элементов у этого поля Ф(8-1)=6 
получается можно взять любой элемент кроме [0] и [1] и он будет примтмитивный. даже искаь
ненадо.
берем элемент y+I онже [y]

так вот. я не буду строить таблиу умнжения. я буду перенмножать элемент сам на себя
и таким макаром "построю" таблицу уможения но быстрее.

(y + I)^1 = [y]
[y]^2=[y]*[y]=(y+I)*(y+I)=(y^2) + I = [y^2]
[y]^3=[y^2]*[y]=[y^3]


данный элемент (y^3) + I вроде как остутвтует средим множеств который задают элементы
поля. но на самом деле это множество совпадает с одним из элемпнтов поля. просто надо 
его переформулировать.

y^3=(y^3+y+1)*1+(-y-1)=(y^3+y+1)*1+(y+1)=(y+1) + i(1)
где i(1) это полином принадлежащий множству I

тогда 

(y^3) + I = (y+1) + i(1) + I

рассмотрим i(1) + I  , если мы к любому полиному из I прибавим полином i(1)
то получим некотоый полином принадлежащий I поэтому 
  i(1) + I = I
значит 

(y^3) + I = (y+1) + I = [y+1]

значит

[y]^3=[y]*[y]*[y] = [y+1]

тоесть у меня был вопрос а как можно заполнить таблицу y*y*y если мы незнаем
таблицу умножения. а мы чтобы вычислит y^n мы исопльзуем арифметику нижележащего
поля F[2]. и еще мы то что получим немного перегруппируем чтобы понять какой класс
экввалентности мы получили.

[y]^4=[y]*[y]*[y]*[y] = [y+1]*[y] = ((y+1)*y + I = (y^2+y) +I = [y^2+y]
[y]^5=[y^2+y]*[y]= (y^3+y^2) + I = 

y^3+y^2 | y^3+y+1
        =========
           1
y^3+y+1
-------------
y^2-y-1 = y^2+y+1


[y]^5=[y^2+y]*[y]= (y^3+y^2) + I = (y^3+y+1)*1 + (y^2+y+1) + I = (y^2+y+1) + I = [y^2+y+1]
[y]^6=[y^2+y+1]*[y]=(y^3+y^2+y)+I =

y^3+y^2+y | y^3+y+1
          =========
           1
y^3+y+1
----------------
y^2-1=y^2+1

[y]^6= (y^3+y+1)*1 + (y^2+1) + I = [y^2+1]
[y]^7=[y^2+1]*[y]=(y^3+y) + I =

y^3+y | y^3+y+1
      =========
           1
y^3+y+1
----------------
-1=1

[y]^7=(y^3+y+1)*1 + 1 + I = (1) + I = [1]

итого 

[y]^1 = [y]
[y]^2 = [y^2]
[y]^3 = [y+1]
[y]^4 = [y^2+y]
[y]^5 = [y^2+y+1]
[y]^6 = [y^2+1]
[y]^7 = [1]

элемент [0] мы не получим. он как бы и так понятно что есть. итого мы получли все 8 
элементов поля

F[8] = [ 0,  1,  y,   y^2,  y+1, y^2+y,   y^2+y+1,  y^2+1        ]

 я спецаильно убрал скобки [] потому что оот них глаза рябит


еще раз напишу вот что : 
факторкольцо кольца многочленов K[x] от одной переменной над полем является полем тогда и только тогда, когда соответствующий идеал порожден неприводимым многочленом.



=================================================================================
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\КОНЕЦ ТЕМЫ\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
=================================================================================



| elliptic curves

шифрование на ээллиптических кривых (множествах)
работаю по этой статье 

  https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/

ксатти к этой стье есть репо в гихаб с файлыми для баурзера где можно покрутит 
графики. графики очень крутые
       url = https://github.com/andreacorbellini/ecc.git



во первых как выглядит элиптрическая кривая. ее формула

   y^2 = x^3 + ax + b,  где a,b это кофиценты, еще есть требование 4(a^3)+27(b^2) != 0
                       откуда это требоване даже разбираься не хочу. есть и есть.
                       это видим как с параболами. чтоб дискриминат не был равен нулю
                       и график не был вырожденным. типа того.



про термины у них и у нас.
тербования к группе:
   у них есть требование чтобы если G это группа и a и b приандлежат
   к группе то (a+b) должен принадлежать к группе. у них это своайство называется closure.
   а нас оно называется замкнутость.

   нулевой элемент в бинарной операции сложения у них он назвыается "identity element"

они определяют группу где элементом группы является точка лежащая на эллиптической линии.
тоесть , группа это у нас множество плюс бинарная операция которая если взят два 
элемента множества ставит в соотвествие этим двум элементам третий элемент этого множества.
эта бинарная операция понятно что должно удовлетврять трем требованиям (если мы говорим
про бинарное сложение то это наличие элемента ноль такого что a+0=a для любого a, 
ассоциативность (a+b)+c=a+(b+c), для каждого элемента a есть обратый элемент x такой что a+x=0.
обратны элмент к a называется -a. это условное обозначение. никакого минуса нигде в помине 
нет).
так вот я возвращаюсь к тому что группа это множество и операция бинарная на этом множестве
заданная. так вот они когда задают группа на эллиптоических кривых то они в качестве 
множества берут множество координат (x,y) которые лежат на эллиптической линии.
итак множество состоит из множества точек.

{ (x1,y1), (x2,y2), (x3,y3), (x4,t4), .... }

нулевой элемент (identity element) они берут что это точка лежащая в бесконечности. 
тут непонятно это какая точка (+inf,y)  (+inf, +inf), (-inf,y) итд. 
какую координату иммеет. дело в том что "0" в бинарной операции сложения это не 
число 0. это условное обознаение некоторого элемента x, а в нашем случае  это (x_zero,y_zero) который обладает свойством таким что если мы в качестве аргументов всунем в операцию 
сложения  любой элемент множества (x,y) и элемент (x_zero,y_zero) то на выходе операция
сложения этим двум элементам поставит в соотвествие элемент (x,y)
тоесть если операция суммирования это как бы функция от двух аргументов то 

 операция суммирования от ( (x,y), (x_zero,y_zero)  )  ставит в соответствие элемент (x,y)

или

 (x,y)   +   (x_zero,y_zero) = (x,y)


так вот вопрос. раз у нас множество на котором задана группа это множество точек.
и сказано что  "нулевой" элемент лежит в беконечности. вопрос какие координаты имеет
эта точка бесконечности

точкой (элементом) обратным к данному является точка симетричная относительно оси X
тоесть получается если есть точка (x,y) и обратная к ней это (x,y) то согласно определению 
что такое обратный элемент относииельно операции бинарного сложения получаетяс что 

 (x,y)  + (x, -y )  = нулевой элемент "0"

еще раз почерну что нулевой элемент для нашего множетва точек на плоскости это не элмент
с координаами (0,0). нет. 

нулевой элемент опрееляется из того как задана операция сложения. исходя из нее 
нужно на множестве найти такой элемент. который бы  при подстановке в операци сложения 
как один из аргументов приводил к тому что операция сложения выдает нам в качестве ответа
вторйо аргумент. они авторы статьи пишут что они так определили операцию сложения что  
нулевой элемент у них это точка в бесконечности. 
ну исходя из того что опять же как они говорят что по их же определению операции 

 (x,y)  + (x, -y )  = нулевой элемент "0"

так как линия провееденная через точку (x,y) и (x,-y) это линия паралельная оси Y то 
это значит что точка лежащая в бесконечности это либо точка (x,+inf) либо (x,-inf)

тоесть получается что если мы берем две точки (x,y) и (x, -y )  то ихняя операция 
сложения ставит этим двум точка в соотвесвтие точку лежащую в бесконечности. условную
точку лежащую в бесконечности


далее они пишут что же такое по их опредедению операция сложения на этом множестве.
потому что до этого мы рассмотрли частный случай сложения.
так вот они гооврят вот что. берем две точки  на плоскости которые лежат на эллиптичской
линии. проводим через них линию. эта линия перескает эллиптическую линию еще  в какойто
третьей точке (R,Z). мы отражаем эту точку относиельно оси X тоесть получаем точку (R,-Z)
и вот эту точку (R,-Z) ихняя операция сложения ставит в соотвествтие исходным двум точкам.
в этом смысле дейстивиельно  операция сложения определена как бинарная операция. 
она берет две точки как арнумент. и выдает в ответ третью точку этого множества.

они вводя на бумаге операцию сложения   совсем по другому  более дебильным путающим способом.
они говорят что проводим на бумаге прямую линию. она пересекает эллиптичекую линию 
в трех точка. и что по их определению сумма от этих трех точек выдает нулевой элемент.
 сумаа от трех точек P,Q,R лежащих на прямой и однрвременно лежащих на эллиптической
по их опредеелению выдаст в соотвесвтие нулевой элемент. 
и я такой стоп! подождтите! сумма это операция с двумя аргументами на входе. 
с двумя элементами множества на входе! так указано в определении математических групп!
а вы мне суете опрееление операции сумма как операцию от трех аргументов! але! вы
что? вы что подсовываете?!!

    P+Q+R=0 (где 0 это не 0 и не (0,0) это (x,+inf) или (x,-inf , ))

я хочу скзаать дорогие товарищи что так сумма неопределяется. 
это аболютно безотвесвтенно хамское поганое определение суммы. это уже следсвтие я считаю 
исходя из того определения что Я ДАЛ ВЫШЕ. то что они говорят это изначально даже не выглядит
как бинарная операция! у нас доожно быть два аргумента. а сразу суют три! это уроды.!

то что они записали это следсствие. но никак не определение суммы. нас щас самим придется
его вывести! значит до этого они указали одно из свойств суммы о том что 
есл у нас есть точка P=(x,y) то обратная ей точка -P=(x,-y)
и по свойству бинаной операции суммиорвания 

 
  P+(-P) = 0 ( где 0 нулевой элемент точка лежащая в бесконечности)

я хочу обратить внимание что вообще то обратный элемент должен не из воздуха браться
а он должен принадлежать множеству элементов группы. так спрашивается с какого перепуга
если для точки приадлежащей множству точек элл крийо (x,y) у нас обратная будет точка (x,-y)
тоесть с чего мы взяли что точка (x,-y) она принадлежит тоже нашему множству. оказывается
да. эллиптичская кривая она симметричная относииено оси X поэтому у нас дествтительно 
в можестве точек эллиптической криваой есть и точки (x,y) и для нее всегда есть точка (x,-y)
тоесть я хочу сказать что чтобы точку (x,-y) можно было для операции сложения считать  
обратной надо для начала чтобы эта точка вообще то принадлежала множеству с которым
мы работаем. потому что точка на бумаге конечно есть. но лежит ли она на эллиптичской кривой
это еще вопрос. так вот ответ - что да лежит. потому что эллиптическая кривая симметрична
отсносиель оси x. поэтому если мы берем точку P=(x,y) то обязательно есьт и точка Z(x,-y)
которая лежит на этой же кривой

значит еще раз. у чтобы была группа надо задать две штуки. надо выбрать множество 
элемнтов. и на этом мнжоестве надо задать операцию бианрную операцию сложения или 
умножения (хотя разницы между ними никакой кроме названия). и чтобы эта бинарная операция
удовлетворяла трем требованиям к бинарной операции. 
теперь к нашей ситуации. в качестве множества выбирается множество точек которые лежат
на эллиптической линии. точка это пара чисел (x,y). итак множестве мы выбрали.
эллиптическая линия обладает симметрией относиельно оси X. это значит что если есть точка 
(x,y) то это значит что на этой эллиптической кривой есть и точка с координатаами (x,-y)
кстати еще к множеству точек которые лежат на эллиптической линии они добавляют точку
лежащую в бесконечности. учитывая что множество точек лежащих на кривой имеет вид
координат (x,y) мне непонятно как выяглядит точка лежащя в бесконеочности. какие у нее
координаты. но факт есть факт к множеству точек которые принадджележат эллиптрической
кривой они дболавляют "точку на бесеонечности". как она выглядит фактиески непонятно.

итак множество у нас есть. теперь надо задать операцию (скажем суммирования) на этом множестве.
они ее задают. щас раскажу как.

они говорят будем создавать операцию суммирования. 
для операции суммирования нужен нулевой элемент такой что если в качестве аргумента
в бинарную операцию скормить этот нулевой элемент и еще элемент a то операция суммирования
выдаст наружу элемент a 

    a+0=a

но я специально записал словами а не форулой. потому что приелось как кислота то что 
подсознательно из мира обычных чисел кажется что суммирование это когда где было сколько 
то шаров. а потом туда добавили еще шаров и их стало больше. в мире групп суммирование
совершенно не связано ни с каким физическим складыванием вместе каких то сущностей в мешок.
биарнаярн операция это прсто закон сооветсвтия когда на вход подается два эелмента а функция
выдает некий третий который она им ставит в соответсвие. она по факту ничего не суммирует.

так вот они говрят что операция суммиования такова что точка множства которая лежит на 
бесконечности обладает свойствами нулевого элменента. они это постулируют. они так 
конструируют эту бианрную операцию (дальше сокращенно бо).

тоесть если в бо скормить аргумент a и "0" то бо выдаст a

дальше они говорят что бо у нас будет такая что если взять элемент (x,y) из множества
и элемент (x,-y) из множества
(второй элемент у нас лежит тоже в нашем множестве потому что эллиптическая кривая 
симметрична относиеттлено оси X , поэтому елси есть (x,y) значит автоматом есть и (x,-y))
так вот если взять P=(x,y) и Q=(x,-y) то бинарная операция поставиит им в соовтствие 
точку "0"
тоесть 

   P+Q=0

это значит что элемент Q это элемент -P 
таким образом если мы взяли тчоку (x,y) то обратная ей по бинаной операции будет точка (x,-y)

итак у нас задан "0" элемент на можестве. у нас заданы обратные элементы к элементам.

далее они говорят очень нехорошую вещь. они говорят возьмем три точки из множестве P,Q,R
геометрически они связаны тем что они лежат на одной прямой ( эту связь можно выразить 
математически через кординаты. ) то они постулируют что сумма этих трех элементов 
выдаст элемент "0"

    P+Q+R=0

как мы знаем операция суммирования на группе это бинарная операция. поэтому то что они 
написали это скоство. это выражение от трех аргуентов. поэтому эту хрень нужно дешифровывать
до уровня нормального выражения для суммы и двух аргументов.

мы еще не знаем как нам высчитывать сумму. у нас пока есть толко элемент 0 и обратные
элементы и все. но нам уже нужно разгадывать чтото сложеное про сумму. как она работает.

у нас заданы две точки P , Q
если мы на них натравим сумму 

  P+Q

то она нам выдаст какойто элмемент C

  P+Q=C

так вот они говорят о том что этот C при сложении с R даст нам 0-ой элемент

   C+R=0

это возможно только  в одном случае если R это обратный элемент к C тость R=-C

  C+ (-C)=0

теперь вспоминаем какой элемен у нас является обратным к заданному согласно их же правилу.
если C = (x,y) тогда R это (x,-y)

это нас приводит вот к какому выводу. R у нас известен. он лежит на одной прямой 
с P и Q. при этом R яялется обратным  к C где C это элемент который является суммой P+Q
это значит что суммой P+Q является вот какой элемент : мы берем точки P и Q проводим через
них прямую линию. она где то пересекает эллптическую кривую в точке R=(x_r,y_r)
мы берем точку R и отображаем ее относиельно оси X получаем (x_r, -y_r)
эта точка и является элементом который операция бинарного суммирования ставит в соовтесвтие
двум аргументам на входе P,Q

у меня вопрос - почему этр дебилы не написали это сразу прямо. зачем они задали некую 
хрень. распутыая которую мы путем долгих разбебываений должны сами догадаться так как
же все такие работает операция суммиярования?

ТОЕСТЬ вместо идиотской фразы берем три точки P,Q,R которые лежат на одной прямой
и в тоже время перемекают элптиекую кривую и их сумма ведет в 0.
надо этим дебилам было написать нечто совершенно другое:
  операция суммирования работает вот так : берем две точки два аргумента потому что
  операция суммования это бинарная операция ей на входе надо дать два параметра. 
  пррводим прямую линию. находим на графике третю точку пересечения с эллиптричсеской кривой.
  далее у этой точки меняем y координату с плюса на минус. ЭТО и есть элемент множества
  который возвращает операция суммиорвания! 
НО НЕЕЕЕЕЕЕЕЕЕЕЕЕЕТ. они нам дали суммирование в форме

           P+Q+R=0

НУ НЕУЕБКИ ЛИ?

геометрическая метода нахождения элемента который является суммой имеет приколы конечно.
  если P=0 значит точка в бесконечности. откуда вести линию и куда. тут на помощь 
  приходит простая аналитика. а именно. свойство нуля. а именно
             P+0=P
  что если мы складываем P и -P на графике это будет линия паралельная оси Y проходящая
  через точку P. но нам все равно. мы опять же пользуемя аналитикой
            P+(-P)=0


  и еще один интересный случай 

           P+P 
  вот мы ставим ручку на точку P а куда линию вести? ведь второй точки как бы нет. точнее
  она совпдаает с исходной. а как вести линию если линия проходит через две точки?
  они говорят а пресдставиье что вторая точка не P но близка к P. и вот мы проводим
  через P и близкую к P линию. ну понятно. и они говорят . а теперь мы начнем двигать
  эту точку близку к P к нашей P. и тогда они говорят чьо будет? правильно. линия в итоге
  пройдет через P по касательной. вот! они говорят. вот так и надо линию проводит в случае
  когда мы складываем 
     P+P

и тогда точку в которой касаетльная пересечет эллиптическую кривую и будет элемент суммы!

еще один случай рассматрвиается интересный. вот  у нас P и Q, P неравен Q.
проводим прямую линию но она не пересекает элллипт кривую больше ни в одной точке.
такое можно увидеьт например для  линии  y2 = x3 - 3x + 1
P=(-0,5; 1.5411)   Q=(1.535; 0.10865)
такой случай возможен только если либо в P либо в Q  у нас наша прямая линия проходит 
по касательной. вот в этом конкретном случае прямая проходит через точку Q а через точку P
она проходит по касательной. так вот у нас уже есть подсказка. если линия проходит 
по касательной значит в этой точке слилось в одну две точки. значит в точтке P у нас
точка P и точка P таким образом наша прямая она проходит как бы через три точки
          P,P,Q

возникает вопрос так  какая точка из этих трех будет третья? ответ - ну конечно точка P.
почему? потому что мы же изначально складываем точку P и точку Q. они аргументы. значит их
мы "отбрасываем". значит третья точка ту которую мы искали это оставшаяся точка P. значит
элемтом суммы в этом случае будет точка

      P+Q=-P

тоесть ответом будет точка вот какая если P=(x,y) то P+Q = (x,-y)
тоесть точку P надо отразить отноительно оси X. это и будет искомое.
чтобы лучше понять надо подставитьь цифры y^2 = (1)*x^3 + (-3)*x + 1
P=(-0,5; 1.5411)   Q=(1.535; 0.10865) 
и посмтре картинку на графике.
а как посмореть ?  либо в статье. но лучше зайти на гитхаб там есть репозирий
к этой статье
   
    url = https://github.com/andreacorbellini/ecc.git

скачать его и открыть файл reals-add.html  в браузере

итак  у нас общий алогоритм операции сложения двух точек таков: 
мы берем две точки исходные P,Q а суммой будет такая точка что :
       мы проводим через P и Q прямую линию.ищем третью точку которая будет 
       пересечением нашей линии и эллиптической кривой. и потом мы эту точку 
       отражаем относительно оси X. 

частные интересные случаи:
   1) нам надо сложить 
      P+P
   тоесьт P=P, Q=P
   мы ставим точку P на картинке. а куда вести линию? аолгоритм говорит что у нас две 
   точки и они типа супер рядом. поэтому надо через точку P провести касательную.
   а дальше мы смотрим где эта касательная пересечет  кривую эллиптическую.
   видим ту точку Z. дальше ее отраэаем относиельно оси X . готово это ответ.

   2) нам надо сложить P=P и Q=-P
   так как P=(x,y )  а -P=(x,-y) то провея линию мы получим что она параельна оси Y
   и уходит вверх в бесконечность а наш график больше нигде не пересеккает. вот и ответ.
   третья точка это "точка в бесконечнсоти "  тоесть элемент 0 значит
     
       P+(-P) = 0 
   все совпало

   3) P=P, Q=Q
   прводим прямую но она нигде не персекает болше нашу кривую. помне так ответ должен быть
   что третья точка это бесконечность. но нет. они говорят по другому.
   такая ситуация возникает всегда если у нас либо в P либо в Q прямая проходит по отноениею
   к эллиптичекой кривой по касательной. пусть это будет касаетельная в точке P.
   у нас уже есть подсказка. если у нас график проходит по касательной значит в этой точке
   как бы зашито две точки. просто они сидят в одном месте. значит наша третья точка 
   это точка P 

   тоесть мы имеем точки P, Q, P
   значит ответом для P+Q будет -P 
   также понятно что неважно мы прибавляем P+Q или Q+P все равно ответ будет -P


таким макаром мы научилсись графически находить бианрную операцию суммы на этом множестве.
типа теперь мы имеем ГРУППУ. то что такая операция суммы отвечает 3 требованияем к операцим
суммы для группы я поверю им наслово.


дальше они для этой группы определяют операцию скалярного умножения. щас я сразу поясню 
в чем разница между второй бинарной операцией "умнжоение" и скалярной операцией умножения.
потому что я группах или кольцах мы всеггда говорим только про бинарную операцию умножения.
тоесть мы берем два эелментма множства и "перемножаем" их натрвиаливая на них бинарную 
операцию умножения которую еще нужно правильно заадать. так вот скалярная операция умножения.
это нечто совсем другое. это просто сокращенное выражение для операции сложения. причем
специфического вида если мы хотми сложить вот такие элементы

     P+P+P+P+P+P+P....+P

и таких складываний у нас n штук. то мы просто придумали сокарешнную форму для такого СЛОЖЕНИЯ.
тоесьт по факту это никакое не умножение. и тем более не бинарная операция умножения  в группе.
это всего нвсего операция сложения. просто ее частный вид. и мы дляэтого частного вида
придумали удобняшку в форме обозначения.

   nP=P+P+P+P+P+P+P....+P

еще раз поясню почему это не бинарная операция умножения. потому что правая часть это не
умножение а сложение. а у нас операция бинарного умножения определяется совершенно незавиимо
от операции сложения. во вторых левая часть 
 
   nP
или
  n*P

у нее один из операндов P  приандлежит исходному мноеству что хорошо, а второй операнд
или аргумент не принадлежит нашему множеству! n это элемент из совершенно другого множества
из множества N натуральных чисел. тоесть у нас перемножаеются элементы из разных множеств.
этого абсолютно нет в бинарной операции умножения в группах. 

поэтому nP это никакое не умножения в плане бинарной операции в группах,
это просто частная форма операции сложения в группах которая имеет некоторое сокращение 
в обозначении.

далее идет вторая часть этой статби
там вначале пишут хрень а именно там пишут что поле конечное оно обозначется
как GF(p) либо Fp_ где p_ это я имею ввиду что p в форме нижнего индекса.
с этим всем я согласен. либо как Z/p . вот это полная хрень. ибо это лишь частная 
форма поля. когда у нас p это (прайм^1)   . а p  это число элементов в поле.
если p не прайм то его не образовать через Z/p где Z/p это  говоря по колхозному 
колцо вычетов. а говоря по человечески это множество составленное из классов экваилентности
вот такого вида

   Z/p = { 0+I, 1+I, 2+I, .... (p-1) + I}

где 0,1,2..,p-1 это просто числа классические принадлежащщие натуральным.
а I это множество вида обычных целых чисел из множества 0 mod p

и для элеметнтов этгого мноежства вводятся операции сложения и умножения вида

   (a+I) + (b+I) = (a+b) +I
   (a+I) * (b+I) = (a*b) +I
   
вобщем может чегото недоскаал или напутал. ибо не люблю я это кольцо вычетов.
но главное что поле получится по этой схеме если p=(prime число )^1

в осталлных случаях составление поля из Z/p это полный провал.

поэтому конечное по размеру поле обозначается вот так GF(p) либо Fp_
а вот так обозначаетс частный случай поля Z/p, когда p=(prime число )^1


насколько я понял из второй части статьи(дальше просто статьи) далее они рассматривают 
поля в которых p это искючительно prime^1

ну чтож хорошо. это облегчит понимание.

так я пока не будут вспоминать как точно образуется поле Z/p
но раз уж мы с ним щас начем работать я точно знаю его элементы и арифметику с этими 
элементами в этом поле.

F[p] = {0,1,2,3,.... p-1}

(a+b) = мин пол вычет от (a+b) mod p
(a*b) = мин пол вычет от (a*b) mod p

так вот. задали p. получили поле. получили элементы. и мы теперь в этом поле элементов 
будем искать пару элемнтов  таких что 


     y^2  ≡ x^3 + ax +b (mod p),  где  a,b это зафиксированные элементы из поля Fp_

например p=19, 

элементы поля F[19]={0, 1, 2, 3, 4, .... 18}
только надо понимать что 0 1 2 итд это не просто простецкие числа это условное обозначение
элементов поля. я могу их с таким же успхом обозначитб
             F[19]={a,b,c,d,..... m}
тоесть мы их обозначили как цифры просто для удобства
но! все таки несовсем так. так уж повезло что таблица сложения и умножения для этих 
элемнтов поля работает так как бутто эти элементы дейтсивильно простецкие числа 0..18
и арифметика для них почти что как для простецких чисел а именно она модульная
а именно

  (g+p) = мин пол вычет от (g+p) mod 19
  (g*p) = мин пол вычет от (g*p) mod 19

где g,p это любые два элемента этого поля. 

так вот мы фиксируем два элемента этого поля в статье они берут типа элементы -7 и 10
но это лажа полная. потому что элемента -7 в нашем поле нет. -7 так обозначается обратный
элемент x к элементу 7 такой что 
             x+7 = 0 
щас мы выяснмм чему он равен. 

     x+7 = 0 элемент значит
     мин пол вычет от (x+7) mod 19 = 0
     тоесть 
     мин пол вычем от A mod 19 = 0
     значит A=19
     значит x+7=12
     и дейтвсително мин пол вычет от (12+7) mod 19 = 0
значит наши элементы из поля это 12 и 10
значит


     y^2  ≡ x^3 + (12)*x +10 (mod p)

я считаю что это выражение это какая то неведомая немыслимая хрень. почему.
потому что справа у нас полином 

        x^3 + (12)*x +10

реузтатом полином если в него подставить конкртный x это будет не число а элемент поля.
например 

вычислю как я для начала полином

    x^3 + (12)*x +10

например если в него подставить элемент x=1

   1^3 + 12*1 + 10 = 1+12+10 = (1+12) + 10 = 13 + 10
надо выполнить опрациб сложения в нашем поле для элемента 13 и 10
давайте сделаем, используем формулу для сложения

  (g+p) = мин пол вычет от (g+p) mod 19

   (13+10) мин пол вычет от (g+p) mod 19 = 4

значит наш полином привел нас к элементу 4.

получается 

  f(1)=x^3 + (12)*x +10=4

тоесть полином это на самом деле закодированный элемент поля 4
получаем загадочную запись

   y^2 ≡ 4 (mod p)

слева тоже стоит полином

   y^2

если в него подставить конкоретный элемент поля то мы получим элемент поля на выходе
и мне непонятна запись вида

  элемент поля1 ≡  элемент поля2  (mod p)

это что за хрень ?

я знаю для элементов полей бинарную операцию "эквивалентности" которую еще нужно задать 
описать как она вычисляется. 

поэтому я вижу эту фигню совсем по другому надо записать
а именно вот так

     y^2  = x^3 + (12)*x +10 

и работает это так. мы берем полином справа
  
  x^3 + (12)*x +10 

подставляем в него элемент из поля. вместо x
получаем некоторй элмент поля. потому что полином это всего навсего черед сумм и произвеений
над двумя элементами поля резултатом которого является в итоге некотоырй элемент поля

вот я выше подставил x=1 получил что 

x^3 + (12)*x +10  = 4

значит далее мы имеем

   y^2 = 4

слева у меня тоже полином.  я его возьму отдельно

      y^2 = y*y

и подсавлю в него ввсе элементы поля 

используем правило умножения элементов поля 

     (g*p) = мин пол вычет от (g*p) mod 19


(0*0) = 0
(1*1) = 1
(2*2) = 4
(3*3) = 9
(4*4) = 16
(5*5) = 6
(6*6) = 17
(7*7) = 11
(8*8) = 7
(9*9) = 5
(10*10) = 5
(11*11) = 7
(12*12) = 11
(13*13) = 17
(14*14) = 6
(15*15) = 16
(16*16) = 9
(17*17) = 4
(18*18) = 1


 теперь смотрим когда у нас этот полином выдает элемент 4 так же как правый полином
получаптся в двух случаях


   (2*2) = 4
   (17*17) = 4

значит наше загодочное выражение 


     y^2  = x^3 + (12)*x +10 

сводится к системе двух полиномов

   | x^3 + (12)*x +10 = A
   | y^2 = A

наша задача находить такие элементы x и y при которых оба полинома приводят к одному
и тому же элементу поля. 
в нашем случае мы получили что

   при x=1 у нас полином 

       x^3 + (12)*x +10 = 4

   и при y=2 и y=17 
   у нас полином

       y^2 = 4

тоесть при 

   x=1 и y=2 либо y=17 мы имеем

   | x^3 + (12)*x +10 = 4
   | y^2 = 4


таким образом мы нашли две пары "точек"  (1,2)  и (1,17)
хотя по факту это никакие не точки а элементы поля F[19]

соотвсвтенно что мы делаем дальше. мы берем все элементы поля F[19]
и подставляем в полином

    x^3 + (12)*x +10

в его x.

смотрим какие элементы A мы получаем на выходе

   x^3 + (12)*x +10 = A

потом мы берем полином

   y^2

подставляем туда тоже все элементы поля F[19]
получаем тоже какието B на выходе. 

получаем две таблицы. таблицу A вида

x | A
======
0 | ..
1 | 4
...
...
18| ..

и таблицу B вида

y | B
======
0 | ..
1 | ..
2 | 4
...
17| 4
18| ..

мы берем строчку из таблицы A , например x=1, A=4
смотрим в таблицу B ищем строки в которых B=4 находим y=2 B=4, y=17 B=4
и состалвяем пары  (x,y)  и (x,y)

когда мы найдем все пары. то мы получим искомое множество. 
которое типа называется эллиптическая кривая построенная над конечным полем. 
хотя по мне она такая же эллиптичккая кривая как я пианист.

по факту мы делаем вот что. мы берем поле. на нем вычисляем два полинома при всех 
элементах поля. а потом собираем пары (x,y) при которых оба полинома приводя к одному
и тому элементу в поле.

надо еще обдумать это все.

по факту мы обсчитываем два полинома в одном поле. и парочка (x,y) показывает при каких
элементах поля у нас значения двух полиномов совпадают. вот и все. 

я вот думаю что мне это напоминает. напоминает когда с обычными числами задана
функция но не в виде 
 
   y=y(x)

а в виде вот таком

   y^2=t
   t=x^2+x+1

ты подставляшь x вычисялешь t. потом подтсвлятвешь t в y. вычиляешь y.
получаешь пару точек (x,y1)  (x,y2) и потом их строишь на грифике

я бы даже так сказал 

   y = t^4+t^3+sqrt(t)
   x = t^2+t+200
 
 и ты подтсвляешь t . отдельно вычисляешь x и y получаешь (x,y) и только потом строищь


Значит что такое функция. обычная привычная 
  
     y=x^2+x+5

это два полинома

    y

и 

   x^2+x+5


заданных на одном множестве тоесть это

   x
   x^2+x+5


далее мы ищем такую пару чисел чтобы подставить ее в первый полином
и во второй полином и получить в обоих полиномах один и тот же элемент.

наприммер в это случае это пара (7,1) 
и мы называем это точкой на графике

в обычной жизни первый полином это просто x 
напомню что полином это просте посоедовательность сложений и умножения собранных в кучку
из нескольких штук. итогом полинома является просто число. 

так вот чтобы полином имел смысл нужно чтобы было задано множество элементов над 
ними операции сложения и умножения. и они чтобы были собраны в череду. тогда мы имеем полином.
в обычной жизни полином расчитывается над полем обычных чисел. 

и вот пару полиномов вида


   x
   x^2+x+5

над полем обычных чисел мы зовем графиком функции. 
итак график функции это пара полиномов заданная над полем обычных чисел

так вот нам ничего не мешает обсчитать ту же самую пару полиномов над полем каким то 
другим. например над  конечным полем.  полином сохранят вид тот же самый. 
просто изменится множество элементов. и изменится резултат  который будут выдавать 
суммы и умножения если подставить тот же самый элемент из нового поля. хотя 
это тоже некоректно так гвооиит. потому что у разных полей по идее эдементы нельзя
сранивать друг с другом.  так вот пары точек которые мы получим (x,y) это будет график
этой же "функции" но над другим полем. 

пример

 y=x^2

это 

 y 
 x^2

 или

 x
 x^2

 для обычного поля рац чисел это будут пары

  (1,1)  (4,2)  (9,3)  (16,4)  (25,5)  график функции y=x^2 прекрастно известен.

теперь посчитаем ту же самую "фунцию" , ту же саму пару полиномов но над полем F[4]



 x    0    1    2   3
    =====================
0   | 0    0    0    0
1   | 0    1    2    3
2   | 0    2    3    1
3   | 0    3    1    2



x^2
y

подтставляем x=0  тогда x^2=x*x=0*0=0
получаем y=0
значит пара   (0,0)

подтставляем x=1  тогда x^2=x*x=1*1=1
получаем y=1
значит пара   (1,1)

подтставляем x=2  тогда x^2=x*x=2*2=3
получаем y=3
значит пара   (2,3)


подтставляем x=3  тогда x^2=x*x=3*3=2
получаем y=2
значит пара   (3,2)

итого "график" функции y=x^2 над полем F[4]

  (0,0) (1,1) (2,3)  (3,2)


ксатти таблица же умножения у конечного поля зависит от непривоимого полинома. 
в этом плане я не знаю вот что. мы же пробегаемся по всем элементам. поэтому график
фукнции будет зависеть от неприводимого полинома или нет?

в приниципе можно проверить. у меня есть таблица умножения для F[9]
при неприводимом полиноме x^2+1 ( вот здесь https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D0%BE%D0%BB%D0%B5#%D0%9F%D0%BE%D0%BB%D0%B5_%D0%B8%D0%B7_%D0%B4%D0%B5%D0%B2%D1%8F%D1%82%D0%B8_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)

0*0=0
1*1=2
2*2=1
i*i=2i
(i+1)(i+1)=2i+2
(i+2)(i+2)=(2i+1)
2i*2i=i
(2i+1)(2i+1)=(i+2)
(2i+2)(2i+2)=(i+1)

заменю названия элементов этого поля вот так 

0=0
1=1
2=2
i=3
i+1=4
i+2=5
2i=6
2i+1=7
2i+2=8

тогда

0*0=0
1*1=2
2*2=1
3*3=6
4*4=8
5*5=7
6*6=3
7*7=5
8*8=4



тогда мы для функции

 y
 x^2

 на поле F[9] и нерпиодимы полиномом x^2+1 (тоесть с определенной таблицей умжоения) будем иметь
 график

 (0,0) (1,2) (2,1) (3,6) (4,8) (5,7) (6,3) (7,5) (8,4)

 щас я его нарисую
            
 |          _   
 |              _
 |        _  
 |                  
 |                    _
 |                 _     _
 |  _
 |     _    
 |
 -==|==|==|==|==|==|==|==|==
 0  1  2  3  4  5  6  7  8  


щас я построю таблицу умножения для того же F[9] но с нерпиводимым полиномом x^2+x+2

поле элементов прежнее 

0
1
2
i
(i+1)
(i+2)
2i
(2i+1)
(2i+2)

таблица сложения и умножения для F[3] на котором построено F[9]

+  0 1 2
   =====
0| 0 1 2
1| 1 2 0
2| 2 0 1


*  0 1 2
  ======
0| 0 0 0
1| 0 1 2
2| 0 2 1



0*0=0
1*1=1
2*2=1
i*i=i^2

i^2| i^2+i+2
   ========
     1

i^2+i+2
---------
-i-2=(-1)*i-2=2i+1

i^2+I=(i^2+i+2)*1+(2i+1) +I = (2i+1) +i + I = (2i+1) + I
значит
i^2=(2i+1)


(i+1)*(i+1)=i^2+i+i+1=i^2+(1+1)i+1=i^2+2i+1

i^2+2i+1 | i^2+i+2
         ========
           1
i^2+i+2
----------
i-1=i+(-1)=i+2

занчит 

(i+1)*(i+1)=(i+2)


(i+2)*(i+2)=i^2+2i+2i+(2*2)=i^2+(2+2)i+(2+2)=i^2+i+1

i^2+i+1 | i^2+i+2
         ========
           1
i^2+i+2
----------
i^2+i+1-(i^2+i+2)=+1-2=-1=2

значит 

(i+2)*(i+2)=2


2i*2i=(2i+I)*(2i+I)=(2*2)i=i  (порой я забываю что значит все эти 2i+1 а потом вспоминаю
что это остаток от деления в полиноме. или образующий элемент класса эквивалетности на множестве
полиномов)

(2i+1)*(2i+1)=i^2+2i+2i+1=i^2+i+1=2


(2i+2)*(2i+2)=i^2+i+i+1=i^2+2i+1 = i+2

значит в итоге мы имеем

0*0=0
1*1=1
2*2=1
i*i=(2i+1)
(i+1)*(i+1)=(i+2)
(i+2)*(i+2)=2
2i*2i=i  
(2i+1)*(2i+1)=2
(2i+2)*(2i+2)=(i+2)

теперь провожу замену 

0=0
1=1
2=2
i=3
i+1=4
i+2=5
2i=6
2i+1=7
2i+2=8

тогда получаю

0*0=0
1*1=1
2*2=1
3*3=7
4*4=5
5*5=2
6*6=3
7*7=2
8*8=5

строим график
 |             
 |              
 |        _  
 |                       _      
 |           _        
 |                 _        
 |              _     _
 |  _  _        
 |
 -==|==|==|==|==|==|==|==|==
 0  1  2  3  4  5  6  7  8  

теперь сравним с предудыщим графиком
 |          _   
 |              _
 |        _  
 |                  
 |                    _
 |                 _     _
 |  _
 |     _    
 |
 -==|==|==|==|==|==|==|==|==
 0  1  2  3  4  5  6  7  8  


итого мы увидели что "график функции" для двух полиномов

   x^2
   y

он отличается если мы его строим на одном и том же поле. на одном и томже получается
множестве элементов. но с разным неприводимым полиномом. получается таблица умноженияэ
тогда разная. и получается что операция умножения выолпнненая на одной и той же паре элементов
арругементов даст совершенно другой ответ результат элемент. а это значит что полином 
в котором содержатся операции умножения в который мы подставим один  и тот же аргумент
выдаст совершенно разные ответы при разных таблицах умножения тоесть разных непривдимых 
полиномах.

тоесть когда мы строим "график функции" над конечным полем надо понимать что он будет зависеть
еще и от того на каком идеале или неприводмом полиноме построено это поле. 
потому что построить поле это нетолько найти его элементы. но и построить таблцы сложения
и умггожения. так вот при разных иделах - неприводимых полиномах у нас получается разная
таблица умножения.  едиснвтенное что если поле имеет число элементов равноые прайм числу
то на этом поле ненужен неприводимый полином. и на этом поле таблица умнжения задается
однозначно. и на таком поле у нас будет всего один возможный "график фнукции" от двух полиномов

так вот. эллиптическая кривая над конечным полем это два полинома(где полином это череда
операций суммирования и умножений запсанных в одну строку выполняемые над элементами поля,
полином в итоге выдает некоторый элемент поля)


   | x^3 + (12)*x +10
   | y^2


или

   | x^3 + (12)*x +10
   | x^2


так вот мы берем первый элмент поля подтвляем вместо x в первый полином. получаем некоторый
элемент A. а потом находим при как элементе поля подставленном во второй полином на

   (1)^3 + (12)*(1) +10 => A

а потом берем второй полином 

   x^2

прогоняем через него все элементы поля. и находим такие при которых этот второй полином 
тоже равен A  например это происхит при x=2


   2^2 = A

тогда мы получаем 

   (1)^3 + (12)*(1) +10 => A
    2^2 => A

значит мы нашли что елемент 1 подставлыенный  в первый полином приводит его к тому
же самому элементу что и второй полином в который подставили элемент 2.
у нас образуется пара x,y  = (1,2)
это и есть "точка на графике от функции  y^2=x^3 + (12)*x +10 которая высчитана 
над конечным полем.

вот как надо высчитывать функцию над конечным полем. вот как надо получать точки функции
над конечным полем. вот что значит функция. вот что
значит функция задана над конечным полем.

а вот эта запись она просто мислидинг и идиотская для функции над полем

   y^2 ≡ x^3 + (12)*x +10 (mod p)

то как я описал это имеет полный смысл. тоесть у нас есть поле. тоесть унас есть множество
элементов. задана операция сожения и умножения двух элементов. у нас в поле есть понятие полином.
это всего череда последовательных сложений и умножений записанных в удобной форме в одну
строчку. в полиноме обычно для каждой операции сожения и умножения один их операндов тоесть
один из элементов поля уже задан в явной форме. тоесть например  полином

   x+2
состоит из всего одной операции сложения. и в ней один операнд уже явно задан это элемент 
поля 2

так вот а второй операнд в полиноме обычно не задан. он обозначен условной буквой x.
когда говорят "посчитать " полином это значит нужно вместо x подставить второй явный операнд
необходимый для бинарных операций. и высчитать череду сложений и умножений.  
например

  (x+5) + (x+2)

у нас полином это по факту три последовательные операции сложения

  x+5, x+2, и сложить вместе то что в них получилось 

подставляем второй недостающий аргумент. необходимый для бианрных операций. например x=2
 2+5, 2+2, 
 2+5=7
 2+2=4
 7+4=11

 в итоге

 (x+5)+(x+2) = 11 при x=2
у нас как бы вбита в башку мысль полином при x=2 равен 11. а по факту это нечто другое.
череда трех операций сумм 
  2+5 2+2  7+4  равна 11
тоесть череда суммирования приводит к элементу 11. а нам кажется что есть некая сущность 
полином. и он при x=2 равен 11. это как скзаать шкура коровы при сьедании 1 кг травы дает 100г
молока. а на самом деле кишки внутри корорвы которые снаружи обтянуты шкурой дают 100г молока
полином это всего навсего удообная форма записи череды реальных операций над элементами поля
(суммирование и умножение) которые при одно аргументе заданном явно а второй может варьироватся
приводит в итоге к некоторму элементу. вот что значит полином чему то равен при x=2

итак задано поле. заданы элементы. заданы таблица сложения унжоения. берем два полинома.
и мы требуем чтобы оба полинома давали один и тот же элемент. это называется задать функцию
над полем. все очень логично. все исходит из базовых понятий поля. операция суммирования
и умножения. потом полиномы. мы всего навсего взяли два полинома и ищем такие элементы
поля при которых эти два полинома дают одно и тоже. вот и все. это и есть функция. 
множество всех пар (a,b) которые мы можем подставит в полиномы и получить в каждом из 
них будет значение этой функции на этом поле. еще раз я взял два полинома. и ищу при каком
аргументе x подставленном в каждый полином эти оба полинома дают одно и тоже. вот ивсе.

а то как они задают фкцнию над полем

   y^2 ≡ x^3 + (12)*x +10 (mod p)

это какойто бред.
во первых что это за операция ≡ в поле ? вот это что за хрень  в поле (mod p) ?
они вводят некие новые операции в поле но ничего не говоорят. вот это ≡ скорей всего
аналог операции экивавалентсности ~ . но это еще надо доказать. итд. поэтому нафиг эту
хрень

кстати - получается что функция это не ее график!!!! ведь я привык из мира обычных чисел
если я вижу y=x^2 то рисуется в голове парабола! и ты думаешь - о! это и есть x^2 !
а нифига! оказывается функция это набор полиномов! это неменяется! тоесть функция это 
конкретна последовательноть операций сумм и умножений с заданными коэифицнтами! вот
это функция. а ее график он оказывается он меняется от поля к полю и даже 
на одном поле от одного таблицы умножения до другой таблицы умножения! тоесть график
функции это вещь эфемерная!! это не функция. это ее одна имиллиона форм! форма зависит
от поля и таблицы умножения. оно все разное. и поэтому график функции постоянно меняется.
вот это удвительно. поэтому когдмы говоримя фунцмя y=x^2 или y=sin(x) то прежде всего
в голове в качевте "что такое функция" рисуется именно график! а оказвается что график
это не функция. это ее одно из многочисленных лиц! это вторичная вещь. функция это 
два полинома. их вид тоесть 

  y^3+y^2+1
  x^1+2

вот это функция. это ее неизменное и истинное лицо. вот что важно понять. что график
функции это не функция. это удвиелно! это вот на что похоже. есть атомы воды H2O
это функция.  а вот лед, жидкость, пар. это состояния воды. это график функции. вот что
я хотел сказать. сами атомы H20 они неизменны. это аналог функции. в нашем случае это 
вид полинома 

  y^3+y^2+1
  x^1+2

это неизменно.
а вот вид этих атомов в прирде - лед, пар, жидкость. это график функции. 
на одном поле график один. на другом поле. графиу другой.  поле тоже самое но другая
таблица умножения график другой !! вот что удивтельно!





итак возвращаюсь тогда к моей формулиоовке и конкнретике функции эллиптической 
кривой над конечным полем
над полем задана эллиптическая кривая тоесть дано поле , дана таблица сложения и умножения.
(табица умножения дана значит должен быть указан неприаодимый полином (идеал)на базе которого
она построена либо не укзаан если поле таково что в нем возможна всего одна тадблица умно
жеия тоесть если число элентов в поле это N=prime^1) и на этом поле задано два полинома
имеющим достаточно специфический вид. функция эллиптичкская это всего навсего значит что
задано два полинома конкнретного специфического вида 


   | x^3 + (12)*x +10
   | y^2


и эти два полинома высчитываются над конечным полем


пришла вот еще какая идея. что такое функция над полем. это даже не два полинома. а один 
полином. тоесть функция над полем это реально всего навсего один полином. просто в нем
две переменные. не x как в привычном полиноме. а x и y. но суть полинома от этого не меняется.  
     
          x^3 + (12)*x +10 - y^2 = 0


суть что полином - это череда умножений и суммирований. записанных не в виде цепочки x+2, x+5,
x*5 а в форме более короткой записи. и итогом полинома является всего навсего элемент поля.
так вот суммирование и умножение требуют два аргумента. обычно один из арументов он  уже 
задан в полиноме. например x+2 , второй арнумент 2 уже задан. а недостающий аршумент мы 
подставляем в форме x. так вот полином с двумя прееменными это когда нам нужно в полином
подставить второй элемент поля. тоесть обычно полином требует подтсавить в него один полином.
а тут мы должны вставить два элемента поля. это ничего принциапииально не меняет. 
таким же макамро можно написать полином в который надо подтсавит 3 элемента

          x^3 + (12)*x +10 - y^2 +3z = 0

возврашаюсь к эллпичтическйо кривой 

          x^3 + (12)*x +10 - y^2 = 0

в ней два элемента нужно подставить.
на выходе этот полином выдает элемент 0. и мы ищем все  x,y при которых этот полином будет 0

теперь вопрос как на пратктике находит все эти  пары элементов x,y которые  приводят к тому
что полином в итоге выдает нам ноль. мы делаем вот что 

          x^3 + (12)*x +10  = 0 + y^2
          x^3 + (12)*x +10  = y^2

у нас два полинома. и указано что они оба выдают один и тот же элемент. какой неважно.
главное что один и тот же. значит получаем систему из двух полиномов

          y^2 = A
          x^3 + (12)*x +10  = A

а теперь делаем вот что. мы прогоняем второй полином где икс по всем элементам поля. 
подтставляяя их вместо икс. получаем на выходе какойто элемент A. 

          x^3 + (12)*x +10  = A


далее берем первый полином и тоже его прогоняем по всем элементам поля. тоже получаем какието элементы B

          y^2 = B


а далее требуем чтобы

        A=B

тоесть мы берем строку из одной таблицы для полином  с икс

       x=2    x^3 + (12)*x +10 =4


и ищем этот же элемент "4" во второй таблице

       y^2=4    y=17
       y^2=4    y=2


значит мы нашли две пары  (x,y)=(2,17)  (x,y)=(2,2)


окей. вроде разобрался.  взвращаюсь к статье.
там они приводят для элиптичсеской кривой формулу

      x^3 + (-7)*x +10 - y^2 = 0


(https://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/) приводят вот такую формулу

так вот я ее привожу к другому виду

   | x^3 + (-7)*x +10 = A 
   | y^2              = A

элемент -7 такого элемента в поле N=19 нет! элемент -7 это условное обозначение с точки
зрения операции сожения элемента 12. потому что 7+12=0


   | x^3 + (12)*x +10 = A 
   | y^2              = A


или в форме одного полинома

       x^3 + (12)*x +10 - y^2 = 0


итак вот функция 

   | x^3 + (12)*x +10
   | y^2


теперь я буду искать ее график на  поле N=19. непривоимый полином ненужен потому что 
19 это прайм. и значит таблица умножения на этом поле одна.
найдем ее график. найдем "вид" этой фунции на этом поле. 
тоесть найдем все те (x,y) при котоорых оба полинома на этом поле выдают одинаноковый элемент

найдем к каким элементам приводит первый полином при подстановке всех элементов поля.

x^3 + (12)*x +10 (0) = 0+12*0+10=10
x^3 + (12)*x +10 (1) = 1*1*1+12*1+10=1+12+10= мпв 23 mod 19 = 4
x^3 + (12)*x +10 (2) = 2^3+12*2+10=8+24+10= мпв 42 mod 19 = 4
x^3 + (12)*x +10 (3) = 3^3+12*3+10=27+36+10= мпв 73 mod 19 = 16

я начала руками считать значение первого полинома. но продолжу считать на компе

$ for x in $(seq 0 18); do echo -n "x=$x polinom=" ; echo $(( $( echo "$x^3 + (12)*$x +10" | bc)  % 19   )); done
x=0 polinom=10
x=1 polinom=4
x=2 polinom=4
x=3 polinom=16
x=4 polinom=8
x=5 polinom=5
x=6 polinom=13
x=7 polinom=0
x=8 polinom=10
x=9 polinom=11
x=10 polinom=9
x=11 polinom=10
x=12 polinom=1
x=13 polinom=7
x=14 polinom=15
x=15 polinom=12
x=16 polinom=4
x=17 polinom=16
x=18 polinom=16

теперь посчитаем значение второго полинома y^2 на всех элементах поля

$ for y in $(seq 0 18); do echo -n "y=$y polinom=" ; echo $(( $( echo "$y^2" | bc)  % 19   )); done
y=0 polinom=0
y=1 polinom=1
y=2 polinom=4
y=3 polinom=9
y=4 polinom=16
y=5 polinom=6
y=6 polinom=17
y=7 polinom=11
y=8 polinom=7
y=9 polinom=5
y=10 polinom=5
y=11 polinom=7
y=12 polinom=11
y=13 polinom=17
y=14 polinom=6
y=15 polinom=16
y=16 polinom=9
y=17 polinom=4
y=18 polinom=1


вторую таблицу я переделаю сортировку строк

polinom=0 y=0

polinom=1 y=1
polinom=1 y=18

polinom=4 y=17
polinom=4 y=2

polinom=5 y=10
polinom=5 y=9

polinom=6 y=14
polinom=6 y=5

polinom=7 y=11
polinom=7 y=8

polinom=9 y=16
polinom=9 y=3

polinom=11 y=12
polinom=11 y=7

polinom=16 y=15
polinom=16 y=4

polinom=17 y=13
polinom=17 y=6



теперь делаем вот как 
берем из первой таблицы строчку 

    x=0 polinom=10

и ищем во  второй таблице строчку или строчки где полином равен тому же
видим что во второй таблице нигде полином нерваен 10. значит пролет.

   (0,-)

берем вторую строку из первой таблицы

   x=1 polinom=4
  

и видим что во второй таблице у нас полином равен 4 при таких y

polinom=4 y=17
polinom=4 y=2

значиит "точки" нашей функции 
  (1,2)  
  (1,17)

берем cледущую строку из первой таблицы

   x=2 polinom=4

ищем чтобы полином равен 4 на второй таблце

polinom=4 y=17
polinom=4 y=2

значит мы имеем еще точки нашей функции
  (2,2)
  (2,17)

и так мы проходим все строчки из первой таблицы. 
и ищем им соответсвие во второй таблице
тогда у нас будут вот такие точки

  \
== \  (1,2)     (2,2)   
== /  (1,17)    (2,17)  
  /


  \
== \  (3, 15)   (4, -)   (5, 10)   (6, -)     (7, -)    (8, -)    (9, 12)   (10, 16)    (11, -) 
== /  (3, 4)    (4, -)   (5, 9)    (6, -)     (7, 0)    (8, -)    (9, 7)    (10, 3)     (11, -)
  /

  \
== \  (12, 18)  (13, 11) (14, -)   (15, -)    (16, 17)  (17, 15)  (18, 15)
== /  (12, 1)   (13, 8)  (14, -)   (15, -)    (16, 2)   (17, 4)   (18, 4) 
  /

это получается 23 точки. плюс еще одна "точка" в бесконечности.

построим этот график этих "точек"

                      | ======================== |
                      |  y^2 = x^3 + (12)*x +10  |
                      | ======================== |

__                                    _                         
18| _  _                                          _           
__|                             _                             
16|        _                                         _         
__|                                                            
14|                                                            
__|                          _                                  
12|                                      _                    
__|              _                                            
10|              _                                            
_ |                                      _                     
8 |                          _                                 
_ |                                                           
6 |                                                           
_ |        _                                         _         
4 |                             _                             
_ |  _  _                                         _            
2 |                                   _                       
  |                                                           
   ==|==|==|==|==|==|==*==|==|==|==|==|==|==|==|==|==|==|==
  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18
 

мой "график" совпал с тем что нарисовано в статье (https://andrea.corbellini.name/2015/05/23/elliptic-curve-cryptography-finite-fields-and-discrete-logarithms/)

видно что точки графика имеют симметрию относииельно горизонтальной линии x=9.5
а 9.5 это p/2 тоесть N=19,   N/2=19/2=9,5

это прям похоже на поведение графика эллиптичской кривой над полем обычных чисел. 
там была симметрия отоносиелно линии x=0

также можно заметить то что "y" кооордината точек которые лежат на одном x то их сумма 
равна 19. например 

   (1,2)  (1,17). и видно что 2+17=19
или
   (13,8) (13,11) . видно что 8+11=19


так ну хорошо мы получили множство этих точек. тоесть множество пар где в каждой паре
стоит два элемента поля F[19]



далее
если имеем полином вида
  
  f(x)-y=0 

то мы его споойно можем передалать в 

   y=f(x)

и это означае элемент слева равен элемнту справа

  y=A
  f(x)=A

в случае когда полином вида

 y^2+f(x)=0

это хуже
потоу что мы неможем выразить y в чистом виде тогда

   y^2=A
   f(x)=A

далее частный случай полином от двух аргументов

  ax+by+c=0

я хочу избавится от коэфициента b при игрек
мы всегда можем домножить это выражение на

    (b^-1)*a*x+(b^-1)*b*y+(b^-1)*c=0

тогда получим

    (b^-1)*a*x+y+(b^-1)*c=0

тогда получим

   -y = (b^-1)*a*x+(b^-1)*c=0


фишка такого вида полинома в том что мы прогоняем правый полином через икс по всем элементам
поля. и то чему этот полином будет равен нам дает сразу чему равен y. тоесть мы легко находим
все x,y для этого полинома. мы находим его "график"




далее рассмтривают полином еще раз

        ax+by+c = 0 

это полином и мы хотим чтобы если подставить два элемента из поля то он привел 
нас к элементу 0

чобы найти a,b,c надо иметь три точки которые принадлежат этому множеству.

у меня такое есть 
беру уже готовый полином с известнми коэфициентами

      10x-y+16 =0

тогда
      y=10x+16

проблемжимся по всем элментам поля в x найдем все y
значит мы сразу найдем все пары (x,y) которые принадлежат этому можеству 10x-y+16 =0

x=0 y=16
x=1 y=7
x=2 y=17
x=3 y=8
x=4 y=18
x=5 y=9
x=6 y=0
x=7 y=10
x=8 y=1
x=9 y=11
x=10 y=2
x=11 y=12
x=12 y=3
x=13 y=13
x=14 y=4
x=15 y=14
x=16 y=5
x=17 y=15
x=18 y=6


тееррь я беру точки моей элиптичкой кривой

    
  \      
== \  (1,17)  (2,17)*     
== /  (1,2)   (2,2)    
  /              


  \
== \  (3, 15)   (4, -)   (5, 10)    (6, -)     (7, -)    (8, -)    (9, 12)   (10, 16)    (11, -) 
== /  (3, 4)    (4, -)   (5, 9)*    (6, -)     (7, 0)    (8, -)    (9, 7)    (10, 3)     (11, -)
  /

  \
== \  (12, 18)  (13, 11) (14, -)   (15, -)    (16, 17)  (17, 15)*  (18, 15)
== /  (12, 1)   (13, 8)  (14, -)   (15, -)    (16, 2)   (17, 4)   (18, 4) 
  /


и смотрю какие точки элиптичскй кривой совпдаают с тем множеством

видно что попало ровно 3 точки. (2,17)  (17,15)  (5,9)



теперь я рассматриваю обратную задачу которая меня как раз интерсует 
больше всего, у меня есть три точки эллиптичекой кривой 

        (2,17)  (17,15)  (5,9)

которые по сторонней 
информации принадлежат также множеству

    ax + by + c = 0

моя задача найти эти коэфициенты a,b,c 


     (17,15) =>  a*17+b*15+c = 17a + 15b + c = 0
     (2,17)  =>  a*2+b*17+c  =  2a + 17b + c = 0
     (5,9)   =>  a*5+b*9+c   =  5a + 9b  + c = 0

выражаю c из первого 
    с = -17a-15b
подтславляю во второе
    2a + 17b + c = 2a + 17b -17a-15b = 2a -17a + 17b -15b = -15a +2b = 0
подтсавляю в третье
    5a + 9b   -17a-15b = -12a-6b = 0

беру второе урваение
    -15a +2b = 0
    2b=15a
    b=10*15a=17a
    b=17a
подставляю в третье
    -12a-6b = -12a-6(17a)=-12a-7a=0
    -19a=0
    0*a=0
это значит что a можно взять любой
берем a=1
    b=17a=17
    c=-17a-15b=-17*1-15*17=-17-8=-25=13

значит

    1*x+17*y+13=0

проверим это дело на точках  (2,17)  (17,15)  (5,9)

    (2,17)    1*(2)+17*(17)+13 = 0
    (17,15)   1*17+17*15+13 = 0
    (5,9)     1*5 +17*9+13 = 0

вроде работает

беру эту хрень

    1*x+17*y+13=0

домножаем на (17^-1)=9

    9*1x+y+13*9=0
    9x+y+3=0

проверю эту формулу еще раз на то что три точки (2,17)  (17,15)  (5,9) по прежнуму лежат на ней

    (2,17)    9*2+17+3 =  0
    (17,15)   9*17+15+3 = 0
    (5,9)     9*5+9+3 = 0

по прежнему все работает

по прежнму берем
    
    9x+y+3=0

приводим к 

    y=-9x-3=10x+16
    y = 10x + 16

проверю еще раз что три точки (2,17)  (17,15)  (5,9) лежат по прежнему в этом полиноме
проверил. да они по прежнему лежат на этом полиноме

найдем все эти точки этого полинома

(0, 16)  (1, 7)  (2, 17)  (3, 8)  (4, 18)  (5, 9)  (6, 0)   (7, 10)  (8, 1)  
(9, 11)  (10, 2) (11, 12) (12, 3) (13, 13) (14, 4) (15, 14) (16, 5)  (17, 15)  
(18, 6) 

пострим график этих точек

                           | =========== |
                           | 10x-y+16 =0 |
                           | =========== |
__            _                                                             
18|     _                                                       
__|     *                                                                                     
16|                                                  _          
__|                                            _     *            
14|                                      _                      
__|                                _                             
12|                          _                                  
__|                    _                                        
10|              _                                               
_ |        _     *                                                
8 |  _                                                          
_ |                                                     _      
6 |                                               _            
_ |                                         _                    
4 |                                   _                         
_ |                             _                                
2 |                       _                                      
  |                                                            
  |==|==|==|==|==|==-==|==|==|==|==|==|==|==|==|==|==|==|==
  0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18


          _
  через   * я обозначил такую точку в которой совпало два множства ax+by+c=0 и эллиптичекая
кривая y^2 = x^3 + (12)*x +10
 

в целом даже на конечном поле ax+by+c=0 это множество выглядит как прямая линия! что удвиетльено!
тоесть ax+by+c=0 выглядит как прямая на обычных числах. и получается на конечном поле тоже
она выглядит как ряд прямых линий. 
странно то что в статье для точек (2,17)  (17,15)  (5,9) они нарисовали ax+by+c=0
другие линии. у меня она растет слева направо. а у них она падает справа вниз. непонятно.


полуучается мы проводим на картине множество таких "палок прямых". и задеваем 3 точки.
они говорят в статье что если мы провели прямые палки. тоесть нашли все точки которые образут
множество точек (x,y) удовлетвояряющих

    ax + by + c = 0 

и если  это множество пересекается в трех точках с эллиптичекой кривой то говорят что 
три точки эллиптической кривой лежат "на одной прямой". а по факту имеет пересечение 
с множеством ax + by + c = 0 в трех парах элементов.
можно еще по другому  сказать у нас дано два полинома

    ax + by + c = 0 
    x^3 + (12)*x +10 -y^2 = 0

и мы находим такие элементы x,y которые подтсвляем в оба полинома и оба полинома 
приводят к нулю.
в целом из них можно и один полином составить

    ax + by + c + x^3 + (12)*x +10 -y^2 = 0


будет тоже самое. найти x,y который если поставить в этот полином то в итоге будет 0
можно разделить на два полинома

    x^3 + (12+a)x +10  = A
    y^2 - by - c       = A

пробегаем по всем элементам поля в обоих полиномах.  а потом в обоих таблицах ищем одинакоые
элементы

рассмотрим еще одну линию

   ax+by+c=0

поле F[127]  имеем три точки  (16,20)   (41,120)   (86,46) из эллиптической кривой y^2=x^3+126x+3
найду линию для этих трех точек

|  a*16+b*20+c=0
|  a*41+b*120+c=0
|  a*86+b*46+c=0

c = -a*86 -b*46

a*16+b*20 -a*86 -b*46 = (16-86)a +b(20-46)  =  -70a -b26 = 0
a*41+b*120-a*86 -b*46 = (41-86)a +b(120-46) =  -45a  +74b = 0


    45a = 74b
    48*45*a=48*74*b
    a=123b

-70a -b26 = -70*(123b)-26b=-(70*123+26)b=0
    0*b=0
значит b можно взять любой. например b=1
    a=123*b=123*1=123
    c = -a*86 -b*46 = -86*(123)-46*1=-86*123-46=-(86*123+46)=-83=44

    123x + y + 44=0


проверю еще раз на трех точках (16,20)   (41,120)   (86,46)

    $ x=16;y=20; echo $((    (  123*$x + $y + 44 )    % 127 ))
    0

     $ x=41;y=120; echo $((    (  123*$x + $y + 44 )    % 127 ))
    0

    $ x=86;y=46; echo $((    (  123*$x + $y + 44 )    % 127 ))
    0

все сработало.

так вот они говорят вот что. что пользуясь этим правилом если мы нашли три точки P,Q,R 
которые лежат "на одной прямой  ax+by+c=0" то они говорят вот о чем что исходя из этого правила 
они форумулируют правило для "сложения" двух точек P,Q  принадлежащих эллиптической кривой.
мы находим точку R которая тоже лежит на этой "прямой" ax+by+c=0  и мы берем эту точку R=(x,y)
и берем обратную точку для этой R. а обратной точкой называется точка с координатами (x, p-y)
где p- это  размер поля. или размер модулюса. напрмиер вот у нас есть три точки 
P=(16,20)   Q=(41,120)   R=(86,46) эллиптической кривой и у нас поле F[127]. 
тогда P+Q = -R   где -R=(86,127-46)=(86,81)

итак у нас есть поле F[prime]
на базе элементов поля у нас задано сложение  и умножение на базе модулюса так скажем.
главное что это реально сложение и умножение отвечающее тоеовованиям для поля. далее
на этом поле задают полином

    -y^2 + x^2 + 12*x + 10 = 0

пока все строго в рамках как дожно быть у поля

потом находят все элементы поля x,y которые уловлетворяют этому полиному. это тоже нормал
получается это условные пары (x,y) элеементов поля. нормал
потом берут две пары таких элементов  P=(x,y)  Q=(x1,y1) 
потом добавляют еще один полином такой что он в себе тоже содержит P и Q


    ax+by+c=0


и далее ищут точку R такую что она лежит одновременно в обоих этих полиномах

    -y^2 + x^2 + 12*x + 10 = 0
     ax + by + c=0

в итоге у нас получается три пары элементов P,Q,R  каждая пара если ее подставить 
в любой полином то она приведет к 0.

пока все четко в рамках поля. его правил жизни.

а вот далее они делают вот какой шаг. они образуют новое множество элементов из 
этих пар элментов . тоеть из точек эллиптиеской кривой. и на этом множестве они задают 
операцию бинарную сложения для двух элементов этого множества. и говорят что если у нас
есть три элемента (три точки P,Q,R) которые одновременно лежат в двух мноежствах


    -y^2 + x^2 + 12*x + 10 = 0
     ax + by + c=0

то P+Q = -R
где элемент -R это такая точка которая если R=(x,y) то -R=(x,N-y)
тоесть в рамках их операции сложения "для точек" сложение двух элементов которые лежат на одном
x а суумма их y дает N ставить в соотвевтие 0-ой элемент. 0-ой элемент поля точек это абстарктная
точка лежащая в бесконечности
дальше они якобы докывают что эта операция сожения для точек имеет обратный элемент для каждого
элемета и это значит что мы получили группу на этих точках. у нас есть элементы множества.
есть операция сложеия подчинаяющаяся якобы тоеоениям к закону сложения для группы (наличие 0 элемента, наличие обратного элемента, ассоциаттивный закон (P+Q)+R=P+(Q+R) ) - то значит мы 
имеем группу. 

интересно то что раньше я расматрвал кольцо из полиномов надо конечным полем. полиномов 
было бесконечно много. и они все были от одной переменной. и это было кольцо то есть  там
было задано и операция сложения полиномов и операция умножения. 
здесь же над конечным полем построена группа причем конечаня. при простронии используется
полином от двух переменных. и для новых элементов заадана групповая операция сложения.
элементом группы явялется пара элементов исходного поля. 

когда говорят задана эллиптическая кривая над конечнмы полем. то иемеется ввиду что 
над конечным полем задан полином от двух переменных. этот полином задается "формулу" эллптической
кривой. а физическим резульаттом этой кривой явялется некоторый набор пар элементов 
исходного поля. каждая пара характерна тем что ели ее посдатвить в полином то он приведет 
к элементу 0 исходного поля.  в какойто стемени это множество точек это график функции от полинома на этом поле. аналог классического гарфика функции от полинома когда исходное поле это обычные
числа.

прикол в том что когда у нас подином задан наб бесконечным полем типа как обычные числа
то число пар (x,y) имеет бесконечное количество. а когда мы берем поином от двух перменных
над конечным полем элементов то график будет иметь конечное количество "точек"
посльку мы из "точек" создали группу. то число этих точек зоветя "порядок группы"

итак мы берем поле. тоесть множество элементов. поле конечное. значит элементов конечное
число. на этом поле определяем "полевое" сложение и умножение элментов поля. операции требуют
два аргумента. требуют два элемента поля. и ставят ему в соотвсвтие третий эдемент поля.
на этом поле задаем полином от двух переменных. далее выбираем все эти пары переменных
удовлятеоворящюих полиному. полином это набор операций сложения и умножеения который беерет
два аргумента и выбирает третий элемент. в итоге полином(набор операция сложения и 
умножения ) при данном наборе аргументов
часть из которых задана изанчально а два штуки мы подсталяем приводит нас к элементу 0.
мы выбираем пары x,y удоволяетворябщих полиному. и формируем из них новое множество. 
каждый элмент нового множества это пара элементов из начального поля. далее для элементов
нового множества задается операция сложения. она берет два эелмента и выдает как результат
третий элемент этого множества. операция сложения работает так что - она берете элементы
нового множества и находит пересечение с некоторым множеством называмое условно  "прямая линия"
эта прямая линия выражается в виде полинома в исходном поле
        ax+by+c0
на пересеении мы получаем 3 точки нового множества. и тогда сумма двух точек это третья
точка из пересечения но не она сама (x,y) а ее "обратный " элемент. (x,N-y)
где N это число точек нового множества.
также они говорят что сложение в новом множестве удовляетвворяет требованиям к сложению 
в группе. значит новое множетва явялется группой

число точек в группе точек называется порядок группы
в этой аддитивной группе (группа с заданной операцией сложения) они не определяют операцию
умножения групповую. но они задают некоторый кусочек операции умножения  = скалярное
умножение. если P это элемент наего множества точек. то 

   n*P = P+P+P+P+P+P...+P сделааннное n раз.

например

   10*P = сложить P+P 10 раз. где 10 это чисто оббычное число десятичной системы счисления.

   n*P назыается скалярное проивзеение. по факту это бинарная операция умножения в которой
   два аргумента. оба аргумента из разных полей. n это обычное число с десятичной сисетмы
   счисления а P это элемент поля точек. но также можно сказать что это "скалярное" умножение
это по факту просто многокрастная операция сложения а nP эта некая удобняшка обозначения
некотоорой частной операции сложения. 

возникает вопрос а что такое "касательнся в точке к линии " в кончном поле. ответ - графически
фиг знает. видимо ответ только матеиматически. 

на данном этапе мне непонятно как "аналитически"   быстро искать сумму от двух элементов-точек.
на данном этапе я только могу вот что делать. если даны три точки

     P+Q=R

то я могу найти точку -R и могу найти "прямую линию" которая содржит в себе точки P,Q,-R




###############################
###############################
###############################

ПРО ПРИМИТИВНЫЙ ЭЛЕМЕНТ 
ПОРОЖДАЮЩИЙ ЭЛЕМЕНТ
ИХ ЧИСЛО В ПОЛЕ И ГРУППЕ


 ТАК ВОТ ЧТО ТАКОЕ ПРИМИТИВНЫЙ ЭЛЕМЕНТ (согласно вот этому http://vmath.ru/vf5/gruppe/galois/vspom2) в конечном поле
первообразный корень степени (N-1) из единицы называется ПРИМИТИВНЫМ ЭЛЕМЕНТОМ ПОЛЯ

тоесть если скаже поле F[7]
то примтиный элемент этого поля это такой  а что 

a^1 != e
a^2 != e
a^3 != e
a^4 != e
a^5 != e

a^6 = e

в поле F[7] это элемент a=3

важное свойство примтивного элемента конечного поля состоит в том что 
    1) с помощью него 
можно породить все элементы поля кроме нулевого элемента (нулевой элемент относиетельно 
операции сложения) . тоесть мы порождаем все элементы поля но кроме одного. кроме 0.
    2) порождабщий элемент в степени N-1 равен e. где N это порядок поля.
    3) в конечном поле всегда есть хотя бы один примитивный элемент
    4) количество примтивных элементов в конечном поле равно Ф(N-1)
потому что если мы нашли один примтиный элемент то все остальные являтся его степенью.
в какую стеепень надо вощвести примтиный элемент чтобы получить другой примтиный элемент?
так как наш примитиный элемент иммееет вот такое свйоство

    a^(N-1) = e

то все остальные примтинвые элементы можно найти вот как. надо для числа (N-1) найти все
его взаимно простые делители. так как функция эейлера Ф(R) ищет сумму взаимно простых делитлей
для числа R то значит количество взаимно простых делителеей для числа (N-1) это Ф(N-1)
значит число примтииных элементов в поле размером N равно Ф(N-1)
посмотрим сколько примитиных элементов в поле порядок которого это прайм число

F[7]  Ф[6]=2
F[9]  Ф[8]=4
F[11] Ф[10]=4
F[13] Ф[12]=4
F[17] Ф[16]=8

когда мы хотим узнать число примтивных эементов в поле то надо помнить что в функцию эейлера
нужно подставлять не число элементов поля а на одну меньше. это очень важно помнить

также важно помнить что при помощи примтивного элемента мы получим в новом множестве все
элементы исходного поля кроме элемент 0.
например если у нас поле F[7] = { 0, e, 2, 3, 4, 5, 6}
то примитиный элемент a=3 нам породит { e , 2, 3, 4, 5, 6} 

x  e 2 3 4 5 6
  =============
e| e 2 3 4 5 6
2| 2 4 6 e 3 5
3| 3 6 2 5 e 4
4| 4 e 5 2 6 3
5| 5 3 e 6 4 2
6| 6 5 4 3 2 e 

исходя из этой таблицы умножения видно что она удволетвеоряет требованиям умножеию в группе.
это значит что примитиный элемент в конечном поле порождает конечную мултипликатинвую подгруппу.
и ее порядок (N-1) тоесть он на 1 меньше чем у исходного поля.
если поле размером 7 то примтиный элемент сгенерирует подгруппу по умножению размером 6

цикличеcкая группа что это. вначале нужно ввести понятие n-ая степент элемента или элемент
в n-ой степени в мультипликативной группе. n у нас это Z целое число. так вот 
элемент a^n это a*a*a*a*a..*a эн раз при условии что n>0 тоесть

n=5>0 a^5=a*a*a*a*a

если n=0 то мы это определяем как a^0=e это просто по нашему определению

если n<0 то a^n=a^(-1) * a^(-1) * a^(-1) * a(^-1) эн раз
напрмиер 

n=-5  a^(-5)= a^(-1) * a^(-1) * a^(-1) * a^(-1) * a^(-1)

теперь a^n где n принадлежит Z обрело смысл через опеарцию умножения.

если у нас группа аддтивтиная то вместо a^n вводят понятие na (они назвыают это число кратное
к а или вот втстье нерусской они это назыают скалярное произвеление но я всеже считаю что 
скалярное произвденеие термин это хуеовый термина а  вот элемента кратный к а это уже норм)
тогда 

если n>0 то   na=a+a+a+a+....+a  эн раз
если n=0 то   na=0   мы уже это видел в статье в форме 0P=0
если n<0 то   na=-a + -a + -a + -a +.... -a эн раз



та вот циклическая группа это группа в которой есть хотя бы один элемент "a" из которого можно породить все 
элементы этой группы. что значит породить. если группа мультипликативная то все элементы
в этой группе можно получить через 

                  a^n, где n принадлежит Z

а если гурппа аддитивная то все элементы в ней можно получить через 

                  na, где n принадлежит Z

итак циклическая группы это значит  в ней есть элемент из которого можно породить все элементы
этой группы. сразу вспоминаем про притиный элемент поля. и щас мне сразу понятно в чем разница
между ними. во первых примитиный элемент он задается через операцию a^n тоесть через умножение.
а порождающий элемент он задается как через умножение так и через сложение. но это еще не все.
примтиный элемент он неможет пороодить все элементы поля их себя. он не может породить элемент
0. а порождающий элемент группы он способен породить из себя все элементы исходной группы.

если циклическая группа конечная имеет размер N то число породжюащих в ней элементов равно 
Ф(N). сразу отметим разницу с полями. в поле размером N у нас число примитивных элментов
равно Ф(N-1) в группе размером N число породжающих элементов равно Ф(N)

получается число примтивных элементов в поле размером N совпдаает с числом порождающих
элемнтов в группе размером N-1 
если мы выкинем из поля его элемент 0. то это поле станет группой размером N-1.
причем это будет мультпликативная группа. (поттому что исходное поле имело и операцию 
сложения и умножения. но так как мы выкинули элемент 0 то операцию сложения нужно откинуть
ибо она стала не валидна над этим множством а элемент e остался поэтому операция умножения
над новым множеством досих пор валидна).
и порождающие элементы этой мультипликативной группы совпадут с примтивным элемтнтами исходного поля. тоесть примтивные элементы поля размера  N и поорождающие элементы мульитипликативной
группы которая образована из поля путем отбрасывания элемента 0 совпадают. и сами элементы
и их число.

ксатти вот еще что надо тут подсветить. 
возьмем пораждающий элемент мултипликатвной группы. значит каждый элемент этой группы
может быть представлен в виде

    a^n где n это целое число. тоеть оно нетолько 1, 2, 3, 5, но и может быть 0 и -1, -2 итд

и при этом мы породим каждый элмемент исходной группы.

в тоже время примитивный элемент поля размера N значит его элементы это 0..N-1
он такой что 
для k= 0 .. (N-2)  у нас a^k != e
и для a^(N-1) = e

так вот если мы их будем сравнивать чисто качественно то примтиный элемент он не генерирует
элемент 0 исходного поля. он гененрирует все остальные. а поорождающий эдемент мулььтипликативн
ой группы он генерирует все элементы исходной групппы. другое дело что в мультипликативной
группе там по опеределению нет элемент 0 . потому что элемент 0 это условное обоначение некото
рого элмента который связан  с операцией сложения. которой в мультпликтикной гурппе просто нет.
второй момент что приитиный элемент он возводится тоолько в натуаральные степени. тоесть
натуральное число это 1 2 3 4 5  ( а целоые это еще 0 -1 -2 ) а порождающий элемент
он возводится и в степень 0 и в стеепень -1 и встепень -2. вот такая между ними есть 
и схожесть и непохожесь


щас покажу на примере

F[7], число прим эл = Ф(6) = 2  
группа из 6 элементов, число порожд эл = Ф(6) = 2

показываю.
поле F[7] =  { 0, 1, 2, 3, 4, 5, 6}

показываю что в этом поле 2 примтивных элемента. примитвиный элемент значит согласно
определению это такой что 

   a^(N-1)=e, где N это порядок поля. в нашем случае N=7 значит N-1=6 значит
   a^6=e=1
и все 
   a^k != e, где k натуральное тоесть k>0 

давай искать примтивные элементы поля. 
тоесть нужно взять каждый элемент поля 0..6 и возвести каджый элемент в степени 1..6
при степенях 1..5 он недолжен выдавать 1. а при степени 6 должен выдать 1.
тоесть в итоге если это наш элемент то он доллжен выдать все элементы поля кроме элемента 0
и a^6 должен выдать 1 
это и будет примтиынй элемент. согласно эйлеру их 2 штуки в F[7]
еще раз замечу что мы берем элемент a и возводим его в степень то есть a*a*a (а не a*3)

0^1=0
0^2=0
0^3=0
0^4=0
0^5=0
0^6=0

1^1=1
1^2=1
1^3=1
1^4=1
1^5=1
1^6=1

2^1=2
2^2=4
2^3=1
2^4=2
2^5=4
2^6=1

3^1=3
3^2=2
3^3=6
3^4=4
3^5=5
3^6=1

4^1=4
4^2=2
4^3=1
4^4=4
4^5=2
4^6=1

5^1=5
5^2=4
5^3=6
5^4=2
5^5=3
5^6=1

6^1=6
6^2=1
6^3=6
6^4=1
6^5=6
6^6=1

мы видим что примтинвыех элемента два. это элемент 3 и элемент 5


3^1=3
3^2=2
3^3=6
3^4=4
3^5=5
3^6=1

5^1=5
5^2=4
5^3=6
5^4=2
5^5=3
5^6=1





каждый из них выдал все элементы поля кроме 0. и a^6=1
это вчастности подтверждило то что я писал выше

    F[7], число прим эл = Ф(6) = 2  


теперь берем это же поле F[7] = {0,1, 2, 3, 4, 5, 6}
выкидываем из него элемент 0. и получаем мультпликативную группу размера 6
причем она циклическая

    группа[6] = {1, 2, 3, 4, 5, 6}
это группа из 6-ти элементов. где 6 это не прайм. но табица умножения для этой группы
будет такая же как для поля из 7 элементов щас покажу

x  e 2 3 4 5 6
  =============
e| e 2 3 4 5 6
2| 2 4 6 e 3 5
3| 3 6 2 5 e 4
4| 4 e 5 2 6 3
5| 5 3 e 6 4 2
6| 6 5 4 3 2 e 

тоесть модулюс надо брать 7


будем искать все порождающие элементы вэтой циклической группе. согласно теории их тут Ф(6)=2 штуки
порождающий элемент как его искать. я беру каждый элемент и начинаю умножать на самого
себя тоесть возводить в степень a^n начиная с n целое. причем я вот как сделаю. я будут 
возводить a^n где n в диапазоне -6 .. +6
для начала я рассмоьрю при n=0 .. 6

 $ for j in $(seq 1 6); do for i in $(seq 0 6); do [ "$i" -eq 0 ] && echo $j^$i=1 ||  echo $j^$i=$((  ($j**$i) %  7 )); done; echo ""; done

1^0=1
1^1=1
1^2=1
1^3=1
1^4=1
1^5=1
1^6=1

2^0=1
2^1=2
2^2=4
2^3=1
2^4=2
2^5=4
2^6=1

3^0=1
3^1=3
3^2=2
3^3=6
3^4=4
3^5=5
3^6=1

4^0=1
4^1=4
4^2=2
4^3=1
4^4=4
4^5=2
4^6=1

5^0=1
5^1=5
5^2=4
5^3=6
5^4=2
5^5=3
5^6=1

6^0=1
6^1=6
6^2=1
6^3=6
6^4=1
6^5=6
6^6=1


 
итак я рассмотрел все 6 элементов этой группы. элементы 3 и 5
являются порождающими


3^0=1
3^1=3
3^2=2
3^3=6
3^4=4
3^5=5
3^6=1


5^0=1
5^1=5
5^2=4
5^3=6
5^4=2
5^5=3
5^6=1


тоесть при степенях 0..5 он породиле все элементы группы. и при степени 6 он породил e
и их количество два штуки совпало с тем что нам гооворит ейлер.
посколку мы уже все порожающие эдементы группы нашли то искать еще какието 
изголяяссь с отрицтательными степенями n нет нужды!

далее еще интересный момент. вот у нас есть конечная циклическая группа (которая является
подгруппой поля 7 но щас это неважно) как скажем в нашем случае это 

    группа[6]={ 1 2 3 4 5 6}

так вот товарищ лагранж говорит о том что если мы в этой группе попробуем выделить подргруппу
то эта подгруппа будет иметь количестов элементов не абы какое а делители числа 6. 
тоесть делители числа элементов этой группы. 
делаители числа 6

6| 6  3 2 1

что это значит на практике. если мы возьмем любой элемент этой группы. и начем его возводить
посоедовательно в степени 0..6
то это начнет нам генерировать элементы этой группы. на какойто степени мы получим e
а до этого будет получать элементы этой группы например показываю

2^0=1
2^1=2
2^2=4
2^3=1

так вот получуенное мноежство элементов {1 2 4} это будет подгруппа. и ее число членов
то есть ее порядок как мы видим равен 3. где число 3 являеся одним из множителей числа 6
где число 6 это число элементов в исходной группе.
количество элементов подгруппы которое можно сгенерировать из элемента исходной группы
называется порядком этого элемента. тоесть для элемента 2 группы из 6-ти элемнтов его
порядок равен 3.

ксати как уже стало понятно у конечной цикличекой группы ее подгруппы тоже циклические

теперь как создать бытро и просто конечную циклическую группу. если мы возьем 
число элементов в группе равное prime. то группа состоящая из элемтов

 G[p] = {0 ..  p-1}

и операция сложения модулярная по модулю p 
нам даст правльную таблицу сложения. 
и это будет циклическая группа

пример

p=5

G[5] = { 0 1 2 3 4}
табица сложения

    modulus 5

+   0 1 2 3 4
   ==========
0|  0 1 2 3 4 
1|  1 2 3 4 0
2|  2 3 4 0 1
3|  3 4 0 1 2 
4|  4 0 1 2 3 


можно построить мультипоикативную группу размером (prime-1)
дело вот в чем. построим для предудщей группы таблицу умножения

      modulus 5 

x   0 1 2 3 4
   ==========
0|  0 0 0 0 0 
1|  0 1 2 3 4
2|  0 2 4 1 3
3|  0 3 1 4 2
4|  0 4 3 2 1 


теперь беерем удаляем из таблицы все что связано с элемнтом 0


x   1 2 3 4
    ========
1|  1 2 3 4
2|  2 4 1 3
3|  3 1 4 2
4|  4 3 2 1 

в итоге мы получаем группу из элемнтов = { 1 2 3 4}  в группе у нас 5-1=4 элемнта
плюс правильная таблица умножения. 
тоесть если мы берем элемент то умножение нужно счиатать по модулюсу 5. и все 
получится



теперь когда нуаучились  быстро и просто строить аддитивную циклическую группу
и мулттипликативную циклическую группу. то 
теперь представим что у нас есть конечная циклическая группа но размером не 4-5 
элементов а условно говоря 2^155 элементов.
как нам проврерить какой порядок будет у элемента a=2 если его взять. из того что  я описал
надо сесть и начать последовательно умножать  2 на само себя начиная с 2^0 и так до 2^155.
пока мы не выйдем на 2^n=e . это очень долго. есть теорема которая позволяет вот как
исхитриться :
    вот у нас есть циклическая группа размером N. значит какой бы мы ни взяли элемент из этой группы он образует подгруппу порядка такого как делители N. например N=13*7*2=182
    182 | 1 2 7 13 182 

значит все элементы этой группы имеют порядок либо 1 либо 2 либо 7 либо 13 либо 182
так вот теорема о чем говорит. если мы возьмем делитель из указанных такой что он 
еще при этом является праймом в данном случае 13 то если элемент сответсвтует вот такой
формуле

   a^(N/13) != e

h=(N/13) называется кофактор подгруппы, размер подгруппы в данном случае размером по крайней
мере 13. 


то это нам точно гарантирует что этот элемент 'a' имеет порядок ПО КРАЙНЕЙ МЕРЕ 13. 
а может и выше. тоеть может он у элемента и выше. но мы это уже незнаем негарантруем. это
надо дополниельно считать проверять. зато мы точно знаем что он у него минимум 13!

щас еще пример дам
возьмем мультпликативную группу размером 53-1=52 элемента. 
53 это прайм число. 
элементы группы вот такие {1 .. 52}
для них работает таблица умножения

 a*b= мпв (a*b) mod 53

число элементов вггруппе N=52

раскалывдаем на множители число 52  | 1 2  4   13   26  52
берем из делителей максимальное прайм число. это число 13
находим для него кофактор

    h=52/13=4

теперь ишем элемента a такой что 

   a^h != e

тоесть

    a^4 != e

когда мы его найдем то это нам гарантрурет что порядок элемнта 'a' нениже чем 13.
поехали

$ for j in $(seq 1 52); do   a=$((  ($j**4) %  53 )); [ $a -gt 1 ] && { echo $j**4=$a; break; };  done 

2**4=16

тоесть мы берем числа среди элемнтнов группу {1 .. 52}
возвоимэто число в 4 степень и проверяем что оно не равно 1

    a^4 != 1

и мы нашли такой элемент это эелмент 2

проверим руками что его порядок точно не ниже чем 13


 $ for j in $(seq 1 52); do   echo 2**$j=$((  (2**$j) %  53 )); done; 
2**1=2
2**2=4
2**3=8
2**4=16
2**5=32
2**6=11
2**7=22
2**8=44
2**9=35
2**10=17
2**11=34
2**12=15
2**13=30
2**14=7
2**15=14
2**16=28


я спцально в  баше ставлю "**" потому что у него это операци возведенив я стпепень.

мы видим что все 2^k при k=1..13 они не переходят в 1


едисвнненное что я замететил что начиная с каких то чисел баш уже не тянет
а тянет олько питон

питон
>>> (3**40) % 53
16

баш
 $ echo $(( (3**40) % 53 )) 
-52

но в баше пока числа положительные - значит он тянет


про циклические группы. как  я понял элемент порождающий циклическую группу
называется генератор (или порождающий элемент) но в инете в статьях часто его зовут
генератор.
все элементы циклической группы являются генераторами циклических подгрупп

немного источников

( частично источники
    https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B0#%D0%9A%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D1%8B%D0%B5_%D1%86%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D1%8B

    http://halgebra.math.msu.su/wiki/lib/exe/fetch.php/%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0_3%D1%81%D0%B5%D0%BC%D0%B5%D1%81%D1%82%D1%80.pdf 

    http://www.unn.ru/books/met_files/teor_gr.pdf  (прааграф 2 циклические группы)

    http://vmath.ru/vf5/gruppe/galois/vspom2

    )





###############################
###############################
###############################


вовзращается теперь к нашему конечныму полю. нашему эллиптическому полиному заданному
на этом поле. нашей эллиптической кривой которая является множеством которая явлется следствием этого полинома. и которое множество образует аддтивную группу

значит было сфорумлировано правило сложения элемнтов в этой группе. 
оно звучит так. вот у нас есть исходное поле F[N] состоящее из элементов. ммы на этом поле 
задаем полином от двух переменных эдементов

   -y^2+x^3+12x+10 = 0

находим все пары  x , y 
где x y это все элементы поля F
которые удовлтетворяют этому полиному
назовем это множество таких пар (условных точек) как M

потом мы берем две точки P=(x,y) Q=(x2,y2) из этого множества и ищем такой полином на этом поле 

  ax+by+c=0

чтобы если я подставлю в него точки P,Q и еще какуюто точку из множства M
то они все удовляетворяют этому полиному

тоесть я ищу пересечениедвух множеств

   -y^2+x^3+12x+10 = 0
  ax+by+c=0

так чтобы в него вошли две заданные точки из первого. и третья которую мы не знаем.
тогда найденая точка R и P,Q в множестве M они гвоворят образуют суммму

  P+Q = (-R)

они этой оппрации сложения P и Q пытаются на краттинке придать графическй смысл. 
так вот для варианта вот такого
 
 P+P = ?

уже как я понял особо графического смысла хрент найдешь. и в ход идут тоько аналитичекие
формулы.


что из указанного уменю вычислять я. 
я вроде как зная точки P и Q котоыре лежат на элиптичкой кривой могу найти вид
полинома 

    ax+by+c=0

потом я могу через него прогнать все элемены из поля и таким макаром нащупать точку -R
зная ее я могу найти точку R
давай попробуем

поле F[19]

полиномы
   -y^2+x^3+12x+10 = 0
    ax+by+c=0

все точки первого полинома
  \
== \  (1,2)     (2,2)   
== /  (1,17)    (2,17)  
  /


  \
== \  (3, 15)   (4, -)   (5, 10)   (6, -)     (7, -)    (8, -)    (9, 12)   (10, 16)    (11, -) 
== /  (3, 4)    (4, -)   (5, 9)    (6, -)     (7, 0)    (8, -)    (9, 7)    (10, 3)     (11, -)
  /

  \
== \  (12, 18)  (13, 11) (14, -)   (15, -)    (16, 17)  (17, 15)  (18, 15)
== /  (12, 1)   (13, 8)  (14, -)   (15, -)    (16, 2)   (17, 4)   (18, 4) 
  /


P=(3,15) Q=(12,18)

значит из того что явидел все время когда  я знал все три точки и искал вида ax+by+c=0
я увидел что один из кэфицентов я могу задать сам. пусть b=1 тогда

    ax+y+c=0

тогда

P=(3,15)   a*3+15+c=0
Q=(12,18)  a*12+18+c=0 , с= -a*12-18, подтславяем в первое


3a+15+c= 3a+15   -12a-18 = -9a-3=0
9a=-3
17*9*a=-3*17=-13=6
a=6
c= -a*12-18 = -12*6-18= -1(12*6+18)=-14

6*x+1*y-14 = 0

a=6
b=1
c=-14

    6*x+1*y-14 = 0   =>  -6x-y+14 = 0 ===>  y= -6x+14 ==> y=13x+14

итак
    y=13x+14

прогоняем все элементы поля 0..16  через x получаем пару x,y удовялтеоворяющую этому 
полиному

1 8
2 2   <======
3 15  <=====
4 9
5 3
6 16
7 10
8 4
9 17
10 11
11 5
12 18 <=====
13 12
14 6
15 0
16 13
17 7
18 1

итак в столбик потказны точки которые удовлетвворят полтиному

    y=13x+14

а стрелками я указал преемечение этого полином с полиномомом эллиптичекой кривой это 
три точки 

 (3,15)  (12,18)   (2,2)

две точки я сам задал чтобы они пересекались а я искал треттью точку.
тоесть вот эти три точки они одноврменно лежат в обоих полиномах

   -y^2+x^3+12x+10 = 0
    y=13x+14

оним получается пересечение двух этих мносжтв.

далее вот что. они гооворят создаим нове можество из "точек" которые уовлетворяют первому 
полиному.
и зададим на этом множстве опрацию сложения элементов. она будет работать так. подаем
ей на вход два элемента P,Q . будем искать элемент K  этой группы
который операция сложения будет ставит в соотвевтие этим P и Q

     P+Q=K

P,Q знаем. ищем K
   
будем находить вот
так. => ищем полином вида ax+by+c=0  в котором лежат точки P,Q
я его нашел это 

  y=13x+14

далее ищем третью точку которая лежит одновременно в обобих полиномах

   -y^2+x^3+12x+10 = 0
    y=13x+14

нашли эту точку R
так вот они говорят что элемент K который мы ищем и элемент R который нашли они связаны
вот таким законом

    K = -R

а что значит обратный элемент к данному элементу в рамках нашей операции сложения.
непонятно. и свйоства суммы которая подчинаяется требованиям группы мы знаем что 
что 

  R+(-R) = 0

но что это нам дает? по идее этот вид нам гвоорит о том что наш полином наш график
"прямой" линии на конечном поле ax+by+c=0 наверное в этом случае должен вырождаться
в полином вида

   ax=c
или 
   x=c1

пусть x=2

тогда

   -y^2+x^3+12x+10 = 0
    x=2

посморим какие точки из первого полинома пеерсекаются со вторым полиномом

(2,2)
(2,17)

а если x=3?

(3,15)
(3,4)

понятно по идее что одна из этих точек основаня а вторая ей обратная.
потому что при таких полиномах только три точки из можества точек будут лажать 
на одной прямой

(3,15)
(3,4)
 и точка в бесконечности

 что сосвбенно также отажается в формуле

  R+(-R) = 0

или 

  R+(-R) + 0 = 0

из чего я делаю вывод что скажем 

(3,15)
(3,4)

что (3,15 ) это осованя точка а (3,4) это ей обратная. 
ну и видна связь. между ним - икс остается тот же самый а игрек связан отншоением N-y


в нашем случае N=19 
найденная точка R=(2,2) значит -R=(2,19-2)=(2,17)
значит

   K=-R=(2,17)

значит

 P+Q=(3,15) + (12,18) = (2,17)

и это действително так совпдаадает с тем ! если провериить через  граф утилиту (modk-add.html)

ха! возникает следущий вопрос. а как находить  P+P ?

как должен выглядеть второй полином чтобы она считальая "кастаельной прямой условное линией"
на над полем? потому что понятно что это просто вопрос вида второго полинома. я так понимаю
что этот полином таков что пересение множетва его точек и точк элптичекой кривой дает 
только две общие точки. одна точка будет это наша P а вторая это искомая.

я вот думаю чем отличается ax+by+c=0 котоырй имеет  3 точк пересевчения с первым полиномом
в отличае от ax+by+c=0 кторая имеет две точки прересечения с первым полиномом. 

как я видел выше если задано 3 точки то вид

    ax+by+c=0

разрешается однонакчно. то есть коэфиыинты a,b,c тогда можро найти однозначно причем один
клэфициент произвольный. а два других пляшут от него. 

непоянтно как найти клэфициенты ( ax+by+c=0) чтобы первый полином (   -y^2+x^3+12x+10 = 0)
имел только две точки пересечения.

можно вот как сделать. взять точку P. посмтреть в граф утлиту чему равно P+P
получим эту Q. найдем -Q значт у нас есть 2 точки котоыре лежат на этой прямой. 
и сосавить этот ax+by+c=0 и посмтреть не него. реально у него тлоько 2 точки пересечения?
если нет. то тогда ax+by+c=0 это не тот полином оторый заадает касатеульную

тоесть еше раз идея такая.  я полааю что второй полином это ax+by+c=0
я беру P, я сморюв  граф ултитлту чему равен P+P. исходя из этогоу меня ест 2 точки
которые якобы лежат сразу  в двуъ плиномах. я могу вычслить вид 

    ax+by+c=0

вычсмить а потом посмтреть о том что раельно ли он имеет вего 2 точки пересения  с перым
полиномом.
если нет то уравнение касательрной имеет не вид ax+by+c=0 а хрен знает какой вид


берем точку (2,2) они пишут что 

        (2,2) + (2,2) = (13,8)

значит на самом деле "на одной прямой" лежат точки (2,2) и (13,11)
положим что они приандлежать по прежнему кривой вида  

    ax+by+c=0

а точнее 

    ax+y+c=0


(2,2) и (13,11)
    
    a*2+2+c=0
    13*a+11+c=0

    c = -(a*2+2) = -2a-2
    13*a+11+c= 13*a + 11 -2a -2 =11a + 9
    11a=-9
    11a=10
    7*11a=7*10
    a=13
    b=1
    c = -(a*2+2) = -(2*13+2) = -(9)

    13x+y-9=0
    -13x-y+9=0
    y=-13x+9=6x+9

    y=6x+9

прогоним по всем элементам поля на икс. найдем все x,y

1 15
2 2
3 8
4 14
5 1
6 7
7 13
8 0
9 6
10 12
11 18
12 5
13 11
14 17
15 4
16 10
17 16
18 3


все точки эллиптической кривой
  \
== \  (1,2)     (2,2)   
== /  (1,17)    (2,17)  
  /


  \
== \  (3, 15)   (4, -)   (5, 10)   (6, -)     (7, -)    (8, -)    (9, 12)   (10, 16)    (11, -) 
== /  (3, 4)    (4, -)   (5, 9)    (6, -)     (7, 0)    (8, -)    (9, 7)    (10, 3)     (11, -)
  /

  \
== \  (12, 18)  (13, 11) (14, -)   (15, -)    (16, 17)  (17, 15)  (18, 15)
== /  (12, 1)   (13, 8)  (14, -)   (15, -)    (16, 2)   (17, 4)   (18, 4) 
  /


общие точки двух полиномов

(2,2) (13,11) 

тоесть реаьно полином 

        y=6x+9

имеет с полиномом эллиптической кривой

       -y^2+x^3+12x+10 = 0

всего две точки общие.

тоесть еще раз два полинома два мноества точек

       -y^2+x^3+12x+10 = 0
        y=6x+9

имеют в пересечении всего две точки общие.

это мне доказало то что полином который отвечает за "касательную прямую линию"
имеет по прежнему вид

    ax+by+c=0

ровно такой же вид когда пересечение имеет 3 общие точки.

получается если P=(2,2) то 

    P+P = (13,8)

потому что у нас два полинома имеют две общие точки (2,2) и (13,11)
поскольку (2,2) это точка P аргумент значит (13,11) это точка "ответа
точнее надо найти точку  обратную к (13,11) это будет точка (13,19-11)=(13,8)

итак если P=(2,2) то 

  (2,2) + (2,2) = (13,8)


я тогда взял и проверил. 
так как если P=(2,2)

и мы хотим вычислить 

 P+P то это экивалетнтно nP где n=2
я зашел у граф утилите скалярного умножения над полем F в  "modk-mul.html" 
ввел там  P=(2,2) и n=2
и получил от них подтвеждение 

  nP = (13,8)


но так как умножение это всего навсего сложение то я зашел в граф утилите в раздел
сложения 

ввел что P=(2,2) и Q=(2,2)
и он выдал (13,8)


итак еще раз - как работает - как работает построение "касательной прямой линии к точке P"
если у нас дана точка P=(2,2)
то мы ищем такую вторую точку Q принадлежащую эллиптической кривой чтобы прямая линия
построенная для этих двух точек

  ax+by+c=0

была таковая чтобы все точки этой прямой имели с эллиптической кривой только эти две 
пересечения P и Q и больше никаких общих точек.
тоесть как выглядит практический алогоритм нахожддения касатльной прямой правада он очень
ресурсо затраный потому что основан на методе перебора. нам дана точка P нам нужно к ней
построить касательную прямую. мы берем какойто элемент любой элемент Q1  принадлежащий множеству точек эллиптического полинома. двух точек P Q1  достаточно чтобы вычислчить коэфициенты a,b,c для прямой

    ax+by+c=0

тоесть ее точный вид. 

когда мы вычисли конкретный вид этой прямой. мы строим все ее точки. а потом прроверяем 
сколько эта прямая имеет с эллиптической кривой точек пересечения. мы уже знаем что две
точки пересечения точно есть. но может она имеет три точки пеересеения. если она имеет всего
две точки мы нашли касательную прямую. а если  она имеет в итоге три точки пеересеения то
мы эту прямую отбрасываем и эту точку Q1 отбрабысыываем. берем следущую точку Q2 эллиптичекой кривой любую вместо Q1. опять для точек P,Q2 находим  ax+by+c=0 опять поверяем сколько она имеет точек пересечения с эллиптиесческой кривой. две или три.  и в конце концов методом перебора
мы найдем такую точку Q125 при которой прямая ax+by+c=0 будет иметь с эллиптической кривой всего
две точки пересечения. это знчит что мы нашли "касательную прямую" в точке P к эллиптической
кривой. ну а дальше по аналогии с логикой когда мы рассматривали эллиптиекую кривую и 
касательуную над полем обычнымх чисел. то мы считаем что хотя  у нас всего две точки пересечения
но их якобы три. просто еще одна точка персеченмя это еще одна точка P через которую проходит
касаетяльная. 
итак у нас был задан P мы нашли еще точку Q125. значит  типа точки P, P, Q125 лежат
на одной прямой. это значит точки P,P,Q125 одновремено принадлежат и эллиптическому ножеству
точек и множеству прямой линии. и согласно постулату про что такое сумма для точек
эллиптической кривой мы имеем

    P+P+Q125=0

значит 

    P+P = -Q125


теперь вот какая идея. у меня была задана точка P и мы нашли  Q125 такую что они являются
едиснвтенными точками пересечения которые лежат и в эллиптической кривой и на "прямой линии".
тогда возникает идея о том что "касательная" линия ax+by+c=0 которую мы нашли к точке P
будет точно такая же (имееть теже коэфициенты a,b,c) и в точке Q125 ! тоесть в отичии от 
обычногго графика функций на обычных числах где в каждой точке графика своя индивиудауаьная
линия касательной то в случае конченых полей и эллпитичких кривых  у них касаетельная 
линия одна и таже для двух точек. в данном примеере и для точки P и для точки Q125
анпример мы уже выячнили что если дана точка (2,2) то есть "прямая" которая пересекает эллипти
ческую кривую в этой точке (2,2) и еще в точке (13,11) и больше ни в какой точке. 
из чего мы как бы говорим что в точке 2,2 у нас  прямая ax+by+c=0 проходит по касательной 
а в точке 13,11 она пересекает график элиптичской кривой. так ровно такая же логика работает
в обратную сторону. если изначально зададим точку 13,11 мы обнаружим что прямая которая
пересекает эллиптичекую кривую только двух точках она такова что вторая точка это 2,2
и ровно также можно сказать что касательная касается точки 13,11 а в точке 2,2 она пересекает
кривую эллиптическую. поэтому я и говорю что такое впечателние что у нас касаетльная одна
и таже для пары точек на элиптической кривой.

из этого по идее на практике вот что должно следовать

 (2,2) + (2,2) = -(13,11) = (13,8)
и
 (13,11) + (13,11) = -(2,2) = (2,17)

но почему то граф утилита выдвает вот такой ответ

(13,11) + (13,11) = (16,2) 
значит   -(16,2)=(16,17) они утверждают что точки (13,11) и (16,17) образуют прямую которая
имеет с эллиптической кривой только эти две точки пересечения.

так что получается что у нас если есть точка P то есть несколько точек Q1, Q2 итд 
что если провести прямую через эти две точки то эта прямая будет иметь с эллиптичемкой
кривой всего две точки пересечевния?  я щас вот как проверю я щас найду такую точку поля 
чтобы граф утилита мне выдала

  P+P = (2,17)

это будет значит что точка P и точка -(2,17)=(2,2) они образуют прямую которая имеет
только эти две точки пересеентя с элиптиеской кривой. но  я то уже ранее нашел что у нас 
точки (2,2) и (13,11) образуют такую прямую. так вот щас найдем тогда еще одну такую.

так вот прикол. я перепробовал все точки поля складывая из P+P
но граф утилита мне не выдала ни одного точки такой чтобы 

    P+P=(2,17)

более того я выяснил что  сумма двух P она для разных P приводит к одним и тем же точкам.
зато нет такого P чтобы P+P мне выдал хотя бы одну из этих точек


(1,2)     (2,2)   
(1,17)    (2,17)   

(3, 15)   (9, 12)        
(3, 4)    (9, 7)         

(10, 16)   (17, 15)
(10, 3)    (17, 4)


тоесть некоько касательных могут быть в одну и туже точку. но при этом нет такой касательной
ни к какой точке чтобы она била в точку (2,2) или (2,17)

мне только остается проверить что точки (13,11) и (16,17)
образуют такую прямую которая имеет только эти две точки общие с эллиптичекой кривой. 
если это так то получится что через точку (13,11) можно провести как миниумум две прямые
так что каждая из этих прямых будет иметь пересечение с эллптиеской кривой только в двух 
точках.
тоеть тогда одна прямая строится на точках (2,2) (13,11)
вторая прямая на точках (13,11) (16,17)

(ксатти похооду точка вбесконечности у них это (inf,inf))

проверяем

(13,11) и (16,17)

   ax+by+c=0

   13a+11+c=0
   16a+17+c=0

   c = -16a-17

   13a+11+c = 13a+11-16a-17 = -3a -6 = 0
   3a=-6
   13*3a=-13*6
   a=-2=17
   b=1
   c=-16a-17=-(16*17+17)=-(4)
   17x+y-4=0
   -17x-y+4=0
   y=-17x+4
   y=2x+4

   y=2x+4

строим это множество

1 6
2 8
3 10
4 12
5 14
6 16
7 18
8 1
9 3
10 5
11 7
12 9
13 11   <======
14 13
15 15
16 17   <======
17 0
18 2


все точки эллиптической кривой
  \
== \  (1,2)     (2,2)   
== /  (1,17)    (2,17)  
  /


  \
== \  (3, 15)   (4, -)   (5, 10)   (6, -)     (7, -)    (8, -)    (9, 12)   (10, 16)    (11, -) 
== /  (3, 4)    (4, -)   (5, 9)    (6, -)     (7, 0)    (8, -)    (9, 7)    (10, 3)     (11, -)
  /

  \
== \  (12, 18)  (13, 11) (14, -)   (15, -)    (16, 17)  (17, 15)  (18, 15)
== /  (12, 1)   (13, 8)  (14, -)   (15, -)    (16, 2)   (17, 4)   (18, 4) 
  /

в итоге действителбно прямая

   y=2x+4

и эллптическая кривая

   -y^2=x^3+12x+10

имеют всего две общие точки

(13,11) и (16,17)

это меня приводит к тому что получается через одну точку P на эллиптической кривой можно 
провести несколько прямых линий так что в итоге эта прямая линия пересечет эллиптическую
кривую в двух точках. в моем случае это на примере P=(13,11) это

 (13,11)  (16,17 ) прямая 
 (13,11)  (2,2)    еще одна прямая

это меня приводит к выводам следущим:
У нас есть группа элементов. на ней нужно построить операцию сложения. 
0 элемент они берут бесконечность. обратный элемент у нас есть всегда. 
у нас для каждого x всегда есть две точки. они берут что эти две точки и есть обратный
элемент друг другу. значит обратный элемент есть.
далее заполняют таблицу сложения. мы ее можем заполнять как хотим.главное чтобы она удволет
воряла требованием групповой суммы. вот мы заполнили эту таблицу. далее они говорят важноу
вещь - о! какое совпадение в ряде случае элемент из таблицы сложения совпадает с элементом
который можно получить геометрическим способом. а имееено. если мы берем два элемента 
P и Q и то они однозначно задаюь полином вида ax+by+c=0 этот полином они условно называют
прямой линией. так вот они говорят что если этот полином имеет с множеством группы (эллипти
ческая кривая) не две точки пересечения а три то третий элемент R совпадает с "суммой" из 
таблицы. точнее элемент суммы равен -R тоесть

    P+Q = -R
    Q+P = -R
но этот геометрический способ он работает не во всех случаях. если у нас только две точки
пересечения этой "прямой" и эллиптической кривой то геометрический способ в лоб не работает.
тогда в статье пишут что просто используют некие формулы чтобы найти P+Q
но сравнил таблицу сложения и геометричский вариант и как бы сам додумал как в этом
случае можно пользоваться гемоетричским способом а не таблицей для находждения суммы.
Если у нас есть точки P,Q мы находим уравнение ax+by+c=0 и оно имеет только две точки
пересечения с эллитической кривой то модифициорванный геометрический способ для находдения
P+Q работает вот как - одна из точек P либо Q считается что в этой точке эта "прямая"
проходит условно по касательной. хотя понятие касательной тут непримнимо так как понятие
касательная строится на осове понятия непрерывность. а тут вообще нет никаких непрервынойтей
поэтому я говорю проходит условно по касатеельной. и тогда  как бы появялется третья условная
точка пересечения этой прямой и эллиптиескрй кривой (далее эк) это будет еще одна точка
в которой прямая проходит по касатейльной. далее прямую я буду условно обозначать P-Q
так вот есои касательная проходит в точке P то третья точка это P и тогда сумама P+Q будет
равна -P

    P+Q = -P

если касательная проходит через точку Q то третья точка это Q и тогда

    P+Q = -Q

главный вопрос а как понять в какой точке проходит "касательная". в этом отношении я незнаю
как это определить. но это абсолютно точный  результат что если у нас есть P,Q есть прямая P-Q
и она только в двух точках пересекает эк то у нас 

 P+Q = -P
либо 
 P+Q = -Q

это четко видно из графической утилиты суммиорвания. я лишь даю этому результатут некую 
геометриескую интеретацию. 

еще момент это кода мы скаладываем  P+P. здесь модицфииварнная гемотричексая интрператация
того что мы получаем в качестве суммы такая. я беру точку P и беру любую точку Q1 их эк
далее я строю прямую P-Q1 и проверяю чтобы эта прямая имела только две точки пересечения с эк.
так вот оакзывается что таких прямых из точки P можно построить несколько. так вот одна из 
этих прямых ими выбирается как "касательая". по какому принципу они выбирают я не знаю. но
именно одна из таких прямых выбирается. так вот. тогда 

    P+P = -Q1

это точно. так что я теперь умею считать сумму P+Q через геометрический способ. почти. загвоздка
у меня тогда когда P-Q имеет только две точки пересечения с эк. и тут нужно знать через
каку точку проходит касательная. и случай P+P тут тоже надо знать как проходит касательная. 
поэтому эти два случая надо смотреть через граф утилиту.  но хотя бы какоето понимание есть!
еще раз хочв подчеркнуть что прежде всего решает таблица сложения. а геометричкская фигня 
это вторичная вещь которая пытается находить элемент суммы не через таблицу а "осмысленным"
гемоетричесим способом но этот способ должен конечно прежде всего попадать в то что в таблице
записано. таблица первична. а геометрия вторична. а таблица должна удовлетворять требованиям
к сумме для групп.

приведу пример когда P Q образуют P-Q котрая имеет только две точки пересечения с эк


   (13,11) + (2,2)

значит прямая на базе этих точее персекает элл кривую только в этих двух точках. и согасно
граф утилите 

   (13,11) + (2,2) = (2,17)

это значит что граф утилита счтает что касателная идет через точку (2,2) и значит
третья точка это (2,2) тогда 

(2,2) +(2,2) +(13,11) = 0
значит

    (2,2) +(13,11) = -(2,2) = (2,17)

главня сложность понять у нас кастельная в точке Q или в токе P потому что если она 
в тчоке Q то тогда

P + Q = -Q

а если в точке P то 

P + Q = -P


еще раз по случай когда Q=P тоесть P+P

вслучае если нам дана только точка P и прост найти P+P
я могу пострит несококьо прямых P-Q1  P-Q2  P-Q3
но какая из этих прямых кссатетльная  я не знаю как это отличить.

P+P=-Q1
P+P=-Q2
P+P=-Q3

но если мы знаем например это P-Q2 то

P+P=-Q2


в целом еще раз с точки зрения групповой операции суммы. ей вобще пофиг на геом интерпетацию.
там главное таблицу заполинть. 


еще пример 

(2,2) + (13,11)  = ?
имеем что P-Q имеет две точки пеерсечения с эк
но в какой точке касательная в (2,2) или (13,11)?
они говорят что касательная в (2,2) значит третий элемент третья точка пересечения
P-Q и эк это  (2.2)

значит

(2,2) + (13,11) + (2,2) = 0
значит

(2,2) + (13,11)  = -(2,2) = (2,17)

другой пример 

(13,11) + (16,17) = ?

тоесть опять мы видим точку 13,11 но P-Q тут уже это касатеная к 13,11 
тогда третья тока это 13,11

(13,11) + (16,17) + (13,11) = 0
значит

(13,11) + (16,15) = (13,8)


могу точно подтвердить то что вот у нас есть две точки

(2,2) + (13,11)

и P-Q имеет две точки пересечения. так вот данная линия она определяет только одну 
касательную. в данном случае для (2,2)

а касательная к (13,11) она имеет другую прямую а именно 

(13,11) + (16,17)

так есть потому что через одну точку можно провести кучу прямых каждая из которых имеет только две 
точки пересечения с эк. поэтому  у нас такого нет чтобы две точки P1, Q1 задавали касательную
сразу и для точки P1 и для Q1

еще момент. вот скажем касатльная к 13,11 образована точками  (13,11)  (16,17)
скажу по другому касательная(условная касательная) проходящая через 13,11 пересекает
эк в точке 16,17 
а как я сказал что сумма двух одинаковых точек P+P равна обратной точке пересечения с эк
в данном случае касательная пресекает эк  в (16,17) значит P+P будет равна -(16,17)
тоесть

    P+P=-(16,17)=(16,2)

тут я хочу обратить внимание что когда мы скалывдаем точку и P и P , где P=(13,11) 
то есть (13,11)+(13,11)
по факту мы работаем с прямой   (13,11)-(16,17)
а третьей точкой мы берем (16,17)

так вот когда мы складываем (13,11) + (16,17)  то мы работаем с той же самой прямой!
но мы берем треттью точку другую  (13,11)

а точнее у нас три точки все время теже самые 

  P+P+Q=0

но в случае когда мы считаем P+P мы выбираем вот так

    P+P=-Q

а в случае 
    
    P+Q=-P


а прямая одна и таже. прямая состоиит из трех точчек P,Q,P
поэтому хотя три точки одни те же. прямая одна и таже но ответ будет разный в случае

 P+P=-Q=-(16,17)=(16,2)
 P+Q=-P=-(13,11)=(13,8)



ТАКИМ образом я худо бедно научился сам руками находить P+Q
или хотя бы понимать как примерно оно высчитывается.
К сожалению как высчитывать P+P прям от и до руками я не умею. я могу для такого случая
найти всех кнадидатов на касательную. но как выбрать именно из них ту самую касательную
это мне непонятно. поэтому P+P я будут далее брать из граф утилиты.

итак мы задали множество (точек ) из пар элементов из F(19) , задали групповое сложение 
с этими элементами. тоесть мы задали группу. далее мы вводим условное обозначение
для частной операции сложения

 nP это сокрашение от суммы P+P+P+P+P+P...+P выполеннеое n раз. 
назовем такой частный случай сууммы как "скалярное  проивзедение"
замечу что это ниразу не групповое умножение. потому что в частсности группое уможение у него
оба аргумента это элементы одного множества.а у нас n это обычное число скажем 10.
а P это элемент нашей группы. поэтому эта фраза "скалярное умножение" это соверенно условная
фигня. по факту это СУММА просто частного вида.

ксстати выше когда я с касательными разибирался я для себя открыл вот что. если мы возьмем
и из каждой точки провередем "касетельную" то она пересекает эк в какйто точке. так вот 
какието касатеьные пересекают одну и туже точку. а какие то точки у нас вообще ни одной каса
тельной не перееспкаются. тоесть есть такие точки в которую ни одна касательная не приходит.
еще раз - не то что в какйото точке нет касательной. нет. в каждой точке можно провести 
кастаетльную. но эта же касательная она куда то летит. и в полете пересекает эк. так вот 
есть такие точки эк в которые не прилетает ни одна касатльая. а есть точки куда прилетает
несколко каасательных. вот такое наблюдение.

при вычислении nP они нашли алгоритм которые работает быстрее чем если в лоб складывать
каждый раз +P
тоесть лобовой алгоритм для сложение  

  P+P+P+P 

как выглядит.

P+P=A
A+P=B
B+P=C

значит

P+P+P=C

чтобы найти 3P нам пришлось сдлать 3 сложения. они нашли как можно делать меньше 
этих итераций.

итак мы имеем аддтивную группу конечную. дальше окаывазывается что эта группа оказывается
циклическая. тоесть есть такие точки что если мы будем ее саму с собой складывать то 
она породит все элементы группы. 
так еще раз чем отличется конечная циклическая группа от конечной нециклической группы.
значит мы знаем из свойства суммы что ее элемнтом явялется какйто элемент поля. 
тогда это значит что если мы делаем 

 P+P то мы получаем какото элемент поля. например 

  P+P=Q
  P+P+P=Q+P=R

так вот в нециклической группе если мы процесс продолжим то он очень быстро выйдет на элемент 0
(ведт 0 это тоже элемент группы). и если дальше продолжить этот процесс то те эементы которые
мы будем получать они просто повторятся. так вот эта штука раотает для любой коненой группы.
в нециклической группе когда мы складываем элемент сам с собой он не успевает породит все 
элементы группы и сваливается в 0. а в циклической группе склдывая элемент сам с собой он 
успевает пробежать породить все элементы группы.
то сколкьо раз при складывании элемента самого с собой он успевает порродить элементы пока
не дойдет до элемента 0 называется порядком элемента. включая щаг когда мы получили элемент 0. понянтно что если группа циклическая
и мы в ней взяли порождающий элемент (ибо не каждый элмент в циклической группе поодающий)
то его порядок будет N.
рассмотрим нашу группу из 24 точек (24 элементов)  построенную на базе поля F[19].
будем брать каждую точку и складывать ее саму с собой и посмотрим есть ли в этой группе 
хотя бы один породжающий элемент.

беру первые 4 элемета нашей группы
== \  (1,2)     (2,2)   
== /  (1,17)    (2,17)  

и начиаю проверять. начинаю склдывать его самого с собой. так как я сам это счтаь не 
умею то юзаю граф утилиту

P=(1,2) 2P=(P+P)=18,15   3P=(P+P+P)=9,12   4P=7,0    5P=9,7   6P=18,4   7P=1,17  8P=(inf,inf)=0
получается порядок (1,2)  равен 8 и это не порождающий элемент

P=(1,17) его порядок 8

P=(2,2) 2P=13,8   3P=1,2   4P=16,17    5P=10,3   6P=18,15   7P=3,15  8P=12,1  9P=9,12 10P=5,10
        11P=17,15   12P=7,0   13P=17,4 14P=5,9    15P=9,7    16P=12,18  17P=3,4  18P=18,4 
        19P=10,16   20P=16,2  21P=1,17 22P=13,11  23P=2,17   24P=0,0

вывод - элемент (2,2) является порождающим. и его порядок 24. четко видно что он привел к 
0 на 24-м шаге. где 24 это размер группы.

примечательно что 

nP при n=0 это 0P 

  0P=0

там гораздо выше я приводил запись о том что это так задается по определению

P=(2,17) его порядок 24. 

из чего видно что если я знаю порядок элемента R=(x,y) то ровно такойже порядок у элемент -R

рассматриваю остальые элементы причем я сразу откаиыаю обртные элементы. 
(3, 15)   (5, 10)       (7, 0)        (9, 12)   (10, 16) (12, 18)  (13, 11)     (16, 17)  
(17, 15)  (18, 15) 

P=(3, 15) порядок 24
P=(5, 10) порядок 12
P=(7, 0)  порядок 2
(9, 12)   порядок 8
(10, 16)  порядок 24
(12, 18)  порядок 3
(13, 11)  порядок 12
(16, 17)  порядок 6
(17, 15)  порядок 24
(18, 15)  порядок 4

итого сколько мы имеем поорождающих элементов:  (2,2), -(2,2), (3,15), -(3,15), (10,16), -(10,16),
(17,15), -(17,15)  это будет 8 штук

мы получили что у нас в аддитивой циклической  группе из 24 элементов ( 23 точки и точка бесконечноть обозна
чаемая как 0 )  у нас 8 порождающиъ элементов. как  я писал гораздо выше то для циклической
группы число ее порожающих элементов равно Ф(24) = 8 .
тоесть теория совпаа с парактикой!

далее они пишу что 

   nP+mP = (P+P+P+....+P) + (P+P+P+....+P)   = (P+P+P+....+P) = (n+m)P
           |____________|   |_____________|    |_____________|
              n раз            m раз                n+m

где n+m мы считаем чисто пользуясь правлос сложеия обычных десятичных чисел
скажем

   100P+150P=250P

другое дело то что есл элемент P имеет порядок k то понятно что каждые k сложений у нас 
резултатт будет опять циклически повторяться и поэтому 

  (n+m)P = по факту (n+m mod k) P


далее они спрашивают себя вот мы взяли элемент P
как нам узнать его порядок? 
ага опять щас погооврим про порядок элемента в циклической группе.
мой метод простой но дуболмоный. а именно. я беру P
а потом начинаю по одному приавлять P и так делаю до тех пор пока не получу 

    nP=0

тогда порядок элемента P равен n
но это надо много считать. есть более короткий. 
если число точек в нашей группе равно N то 
мы вот что делаем - мы находим все делители числа N
из множества 1..N, 
например это числа 1 3 5 7 N
далее я беру наш P и беру наименьшее число из чисел  1 3 4 7 N  в данно случае 
наименьшее это 1  и вычисляю

    1P

если оно равно 0 тоесть

     1P=0

значит 1  это и есть порядок элемента P
если же

    1P != 0

то я беру из чисел  1 3 4 7 N следущее которое больше тоесть это число 3 и считаю

    3P ?=0 

если оно равно 0 то порядок элемента P равен 3 если же оно неравно 0 беру следущее.
в конце концов мы найдем порядок.

тут я хочу подчеркнуть одну СУПЕР ВАЖНУЮ деталь.  я используюю букву N порой для разных 
задач иногда я через нее обрзначаю порядо конечного поля F[N]
а иногда я через нее обозначаю число точек эллиптическойкой кривой которая является группой. а это совершенно  разые сущности. итак надо четко понимать я обозначаю сейчас через N число точек пооля
или число точек группы точек эллпитичекой кривой. 

давай проверим. у нас N=24 (эллиптическая кривая имеет 24 точки) .
его делители 
  24 | 24 12 8 6 4 3 2 1


тоесть точка в группе может иметь порядок только либо 24 либо 12 либо 8 либо 6 либо 4 либо 3
либо 2 либо 1
далее будем предложен еще более мощнйы алгоритм поиска порядка элемента
а пока  помотрим какие порядки я получал когда высчитывал порядки элеентов руками

P=(3, 15) порядок 24
P=(5, 10) порядок 12
P=(7, 0)  порядок 2
(9, 12)   порядок 8
(10, 16)  порядок 24
(12, 18)  порядок 3
(13, 11)  порядок 12
(16, 17)  порядок 6
(17, 15)  порядок 24
(18, 15)  порядок 4

все совпало. каджый элемент имеет порядок в точкности как указано верху.


далее насколько я понял они утверждаю что если взяли точку P и начнем ее скалдывать саму
с собой то ножество элементов которомы получим оно относииельно операции уножения будет
тоже составлять группу! (подгруппу). это прикольно. тоесть если мы сложим любой элемент
из этого множества соглансо нашему правилу сложения для осовной группы то мы всегда полуим
элемент из подгруппы. тоесть мы будем иметь замкнтнутое множество. это прикольно. 

давай для примера проверим. 
берем P(18, 15)  порядок 4

0P=(inf,inf)=0
1P=(18,15)
2P=(7,0)
3P=(18,4)
4P=(inf,inf)=0

полуаем мггожество элемегтов ( 0, (18,15),  (7,0),   (18,4)  )
я их переобозначу как  ( 0 a  b   c  )

нарисую таблцу сложения

    0 a b c 
   ========
 0| 0 a b c 
 a| a 
 b| b
 c| c

теперь я их будут складывать пользуяюсь графичекой утиитой и сразу переводитв таблицу в виде
a b c

например a=(18,15)

a+a= (18,15) + (18,15) = (7,0) = b


    0 a b c 
   ========
 0| 0 a b c 
 a| a b 
 b| b
 c| c


итак далее 

    0 a b c 
   ========
 0| 0 a b c 
 a| a b c 0
 b| b c 0 a
 c| c 0 a b

в итоге я получил что сумма двух любых элементов из из множества которое порождается
из P оно принадлежит этому же множству элементов. и что таблица сложения между элементами
которая получается она удовтлворяте требваниям таблцы сложения для группы. отсьюда вывод
что дейтствиельно - множетво элемнтов порождается из P где P это множесто точек эллиптри
ческой кривой само является группой! получается что максмальная погруппа оно будет равна
исходной группе

далее они вот что говорят. они говорят что - мы уже выяснили что если у нас наша группа
точек имеет порядок N то каждый элемент составляющий нашу группу он имеет порядок только 
такой что это делитель числа N
так вот они говорят что они хотят научиться искать среди элементов группы элемент с заданным
порядком. по мне надо искать тольлко тот элмент который имеет порядок N зачем нам элементы
с другим порядоком?

далее они вот что говорят. они говорят про cofactor
 вот у нас есть N есть можество его делителей 
например N=10 его делители это 1 2 5 10
теперь они рассматривают вот такое число - мы делим N на его делитель

 10/2 = 5  и они говрят что такое частное назвыается КОФАКТОР
ТУТ ОПЯТЬЖЕ важно подчеркнуть что если я умножу кофактор на делитель то я получу число точек
в группе точек эллиптической кривой. я не получу число точек  в конечном поле. число точек
в конечном поле и число точек эллиптической кривой это два совершенно разных числа. 
так вот 10 это число точек эллиптической кривой которые образуют группу. 
далее они говорят что для каждой точки P нашей группы выполяняется

    NP=0

дейсвтеилно это так. если у нас для кажой точки P верно то что у нее

 kP=0

где k это делитель N. то понятно что если мы вот так сделаем

  kP+kP+kP..+kP = 0+0+0+0+0

мы складываем kP столько раз чтобы k+k+..+k=N а это всегда возможно потому что k это делитель N
поэтмоу да для каждого P верно

        NP=0

далее так как N=k*h, где k это делитль k а h это кофактор
    
    NP=h(kP)=0

тоесть если N=10 и порядок группы равен 5 то его кофактор 2. и это значит что 
сложив 5 раз P мы получаем 0 

 P+P+P+P+P=0 (из того что порядок группы равен 5)

и мы поуличим тот же ноль если сложим эту сумму 2 раза. ровно сколько кофактор


 (P+P+P+P+P) +  (P+P+P+P+P)=0+0=0

соеренно понятно что мы получим тот же ноль если мы сложим сумму из 2 элментом но 5 раз

 (P+P) + (P+P) + (P+P) + (P+P) + (P+P)  =  (P+P+P+P+P) + (P+P+P+P+P) = 0

почему. поому что мы раскромем скобки перегруппируем и вернеся к вариенту 5 на 2. 


но вот эту сумму ее можно вот так обозначить

  k(hP) и она как мы показали равна 0.

то есть мы изначально имели

  NP=0

потому мы имели
  (kh)P=0

потом мы имели

 h(kP)=0

и в итоге мы получили что 

k(hP)=h(kP)=NP=0
или

k(hP)=0

в нашем конкнетном примере k=5 N=10 h=2

но вот это выражение его с фрмальной точки зреия можно вот так переписать

  k*Q=0

да. потому что hP это некоторый элемент Q дейстеильно

5(2P) = (P+P)+ (P+P)+ (P+P)+ (P+P)+ (P+P) =  (P+P+P+P+P) +  (P+P+P+P+P)=0+0=0
так вот действелно P+P= некоторму Q поэтому

Q+Q+Q+Q+Q = 0

а это можно записать как

5Q=0

где Q=hP где h=N/k где k это делитель от N
далее они както доказывают что если k это прайм число как скажем в нашем случае k=5
то Q никак и никогда не будет 0 элементом. тоесть если k-prime 
то   Q=h*P != 0 никогда

тогда алгоритм такой. мы хотим найти P такой чтобы его порядок был равен k. 
мы берем h=N/k причем так как k мы хотим чтобы был большой напримр для N=10 мы хотим
чтобы k=10 то тогда оратная величина h будет очень малекньая. в нашем случае h=1
и как я уже сказал они доказали что еси k=prime то Q = hP != 0 никогда.
тогда мы берем произвольный элемет P из нашей группы и вычисляем 
    
        hP

и так как k у нас большой то h у нас число очень маленьой поэтому число суммрований h 
котроео нужно пррвести оно очень небольшое то есть мало делать вычислений.
и если мы получаем Q котоороне нервано 0 то это значит что наш P который мы взяли имеет
порядок k. отично! а если Q=0 то мы берем следущий элемент P из группы и проверяем для него

 hP

и так до тех пор пока мы ненайдем такой P что hP != 0 . 
круто. круто то что можетбыть точек P нам придется проверить много. но вычисление 
 
  hP

требует мало вычисляительных итераций. оно простоое и быстрое.


давайка проверим

N=24  я хочу такой P что его порядок k=24 . БАМ!!! такое k брать нельзя потому что оно
не прайм! получается максимльный k который я могу для этого N взять это k=3
тогда h=24/3=8 и я ищу P такой что 

 8*P != 0 
 тоесть P+P+P+P+P+P+P+P+P  должен быть != 0


давай искать. вот наше множствет точек группы



  \
== \  (1,2)     (2,2)   
== /  (1,17)    (2,17)  
  /


  \
== \  (3, 15)   (4, -)   (5, 10)   (6, -)     (7, -)    (8, -)    (9, 12)   (10, 16)    (11, -) 
== /  (3, 4)    (4, -)   (5, 9)    (6, -)     (7, 0)    (8, -)    (9, 7)    (10, 3)     (11, -)
  /

  \
== \  (12, 18)  (13, 11) (14, -)   (15, -)    (16, 17)  (17, 15)  (18, 15)
== /  (12, 1)   (13, 8)  (14, -)   (15, -)    (16, 2)   (17, 4)   (18, 4) 
  /


8*(1,2)=(inf,inf)=0
так как -0=0  то я думаю что 8*(1,17) это тоже 0 
поэтому если нам не подошло число R то и число -R нам не подходит

8*(2,2)=(12,1) != 0 значит P=(2,2) имеет порядок k=3
а на самом деле порядок для этой точки равен 24.
насколко я понимаю. найденная нами точка имеет порядок НЕНИЖЕ чем k . может и выше 
но точно нениже. вот в чем прикол.

а вот возьеме точку у которой точо порядок равен 3 это (12,18)
для нее
8*(12,18)=(12,1) != 0

вобщем это логично. если у нас известно что 

3P=0 тоесть

P+P+P=0 тогда 8P=(P+P+P)+(P+P+P)+(P+P) = 0 + 0 + (P+P) = (P+P) 
и этот P+P неможет быть равен 0. потому что если P+P равен 0 то 
мы знаем точно из 3P=0 что 

 P+P+P=0
также мы предположили что P+P=0 тогда

 P+P+P = (P+P)+P=0 
с другой стороны  P+P=0 . тогда подтслвяем

(P+P)+P=0+P=0 
но такое воможно только водном случае кога P=0 а он точно неравен 0 значит P+P !0 
значит 

   8P != 0

это я к тому что если k это прайм P != 0 то 

   hP != 0 

где h=N/k

таким макаром если у нас есть N и мы береем у него максмиаьльно взомжный k но чтобы он 
при этом был prime то
мы находим такой P что

   (N/k)P != 0 

и тогда мы точно знчаем что порядок у P точно нениже а может и выше чем k
плюс этого алгоритма в том что если бы мы проверяли что порядок у P нениже чем k 
то для этого нам надо было бы проверить что нетолько 

 k*P=0 
а и то что для всех q<k выполняется
 
 q*P != 0 

это дохрена вычислений. а так вместо этой тучи вычислений мы делаем всего одно
вычисление

  (N/k)P 

во первых у нас h=N/k очень маленкой так как k большое. во вторых  вместо тучи вычислений
мы делаем тлоько одно.
едивнтенное что нам придется искать это P тоесть нам надо будет все такие перебирать точки
из группы. но все равно видимо это более быстро.

дальше они говория рассмотрим что у нас дана точка Q
и дана точка P причем они связаны соотноеием

   Q=kP

но k мы незнаем. легко ли найти это k?
если прикинуть что k надо найти из множества скажем 2^155 то наверное это трудно. очень
трудно.

единвтенное что ненужно будет перебирвать все k потому что k это прайм. но все равно
видимо этих праймов будет море.




###################
###################
###################

тогда у нас типа все готово для алгоритма Диффи-Хельмана на эллиптической кривой на конечном поле.
мы берем конечное поле которое задается через число N которое прайм например N=19. для такого p поле строится супер легко и быстро. потому что оно аналогично полю Z/N (тоесть ненужно строить поле
на основе полиномов). таблица сложения умножени одна. и она строится на основе вычетов.
потом берем полином описывающий эллиптическую кривую. для этого нам надо число a , b которые
зададут этот полином. напрмиер a=12, b=10 тогда

  -y^2=x^3+12x+10

далее у нас образуется группа на основе точек (x,y) которые удоволветворяют этому полтному
над этим полем. далее нам нужен элемент этой группы G такой что он имеет порядок не 
ниже чем k где k это прайм. они пишут что еще нужно задать кофактор число. но непонятно 
зачем его нужно нам сообщать если мы его можем уже сами посчиать h=N/k

таким макаром зная N G=(x0,y0) k h=N/k  мы можем вот что сделать. мы можем использовать 
эту шарманку с диффи-хельманом. а именно

  если мы возьем точку G и загадаем както число l такое что оно l<k 
и посчитаем  элемент 
    
   Q=lG 

то у нас l явлется приватным ключом. а Q явялется публичным ключом.  потому что если 
злодей знает G и знает Q он ни фига не может вычислить наш l. потому что k очень большое. 
и он замучается перебирвать варианты. ведт у нас еще в чем фишка. когда мы каждый раз приабвляем
 
 P+P=Q1
 Q1+P=Q2
то у нас Q2 отличается от Q1 очень сильно и неизвстно на какой эелемент прыгнет в слудещий
раз наше 

 Qi+P

так вот алгоритм дифи-хельмана через эллипт линию.
вася и петя знают 

   N G=(x0,y0) k h=N/k

и здлоей знает.

ваяся загадываеь l<k  и высчитывает 

  Q_v=lG

петя загадывает s<k и высчитывает 

  Q_p=sG

вася с петей и злодоемм обмениваются точками Q_v Q_p
тогда вася вычисляет

  l*Q_p=l(sG)=(ls)G

петя вычисялет 

  s*Q_v=(sl)G

и получается что и у васи и пети получился один и тот же элемент (ls)G
при этом ни злодей не может расчтать (ls)G потому что у него нет ни l ни s
и вася с петей не могут расчитать приватный ключ друг друга. зато у них появился 
общий шаред секрет. 
прикольно


###################
###################
###################

интересно какая связь между полином задающим элл кривую 

  -y^2 = x^3 + 12x +10

и числом точек конечного поля N
и числом пар (x,y) которые удоволяетворяют этому полиному назочем это число z. 
у меня для N=19 получилось z=24 точки. получается поле 19 элементов породило группу из  24 
элементов.  я это к чему говорю. у нас N имеет размер столько то бит. а порждает число точек
которое больше в битах. тоесть количество вариантов перебора получается больше чем
число точек в исходом поле. тоесть условного говорят можно иметь поле длиной 8 бит
а есть криптостойкость будет условного говоря 9 бит.
например судя по граф утилте если N=487 то число точек равно 516. тоесть это на 5% больше
чем размер исходного поля. ну если это сохраняется то например N=300 бит длинной это
301 бит число элементов поля тогда это 316 бит число точек эллипт кривой. тоесть это 315 бит
ну разница между 300 и 315 бит это 30 000 примерно. тоесть 4 порядка. тоесть поле имеет
длинну 300 бит а число точек элл кривой больше на 4 порядка. что конечо приятно.

интересно то что если я укажу поле размером N и укажу полином эллиптичской кривой то 
сходу нихрена непонятно а сколько точек Z получится в эллиптической кривой. 

далее они пишут что если у нас выбран G который имеет порядок k прайм и в тоже время
k=N то такой элемент G использовать ненужно. что для таких 
G люди научились за разумеое время искать l<k для уравеннеия

   Q=lG


####################
####################
####################

далее набор параметров описывающих поле и эллптическую кривую и точку G 
тоесть (N, a, b, G, k, h) называется доменом параметров.

где N - это  число точек в кнечном поле тоесть F[N]
a,b - коэфициаенты эллиптического полинома

   -y^2=x^3+ax+b

G=(x,y) это один из элементов группы точек эллиптичекской кривой 

k - это делитель Z, где Z это число точек в группе элементов эллиптической кривой

h - это кофактор
И ТУТ ОЧЕНЬ ВАЖНО подчеркруть зачем приводится кофактор. он приводится потому что мы незнаем
чему равно число Z которое обозначает количство элементов в группе образующей эллиптичекую 
кривую. мы незнаем это число Z. мы знаем число N которое обозначает нечто соверешенно другое.
N обозначает число точек в конечном поле. но дело в том что это не число Z. и зная число N
и полином эллиптической кривой нетак то легко высчитать число Z. поэтому надо нужно в списке
параметров указать либо число Z и его множитель k. тогда мы сможем сами высчитать кофактор
h=Z/k , либо мы можем не указывать число Z а вместо него указать k который делитель Z
и кофактор который Z/k. мы вместо Z сразу укаываем кофактор h. потому что в конечном итоге
нам нужен кофактор h. зная k и h можно для спортивного интереса узнать Z=k*h
а я вначале никак не мог понять зачем нам приводят h ведь у нас извествен N. но я спутал 
N с Z. нам чтобы высчитать h нам надо знать Z потому что h=Z/k но никак не h=N/k как я ошибочно
думал. поэтому и указывается h. 


###################
###################
###################

далее я добавлю ВАЖНУЮ ХРЕНЬ - если мы посмотрим на наше поле p=19  F[19]
и в этом поле из 19 элементо заадан полином элл крив 

   -y^2 = x^3+12x+10

и этот полином нам дает группу из 24 элементов Z=24

так вот видно что Z != p

действительно 

19 != 24

так вот оказалось что есть такие эллиптичекие кривые (тоесть полиномы от двух переменных вида -y^2 = x^3+ax+b) у которых  число Z совпадает с число p тоесть

    p=Z

или еще вот так это можно написать

   p=h*k

и оказалось что для таких элл кривых искать логарифм очень даже можно. такие кривые 
получается слабые и для шифрования не подходят. они называются слабые кривые. 
еще раз это такие кривые у которых число точек Z совпадает с число точек поля p.

    Z=p

а я ванчале напутал я думал что идет речь о том что если у нас есть кривая с числом точек
Z то нельзя выбирать элемент G такой что у него порядок равен Z тоесть у которого порядок 
n такой что 
  Z=nh
как теперь понятно я думал полную фигню. слабая кривая это совсем не  о том.(возможно я ниже
где то еще раз описал эту фигню но искать не стал.) итак слабая кривая это если число точек
элл кривой совпдаает с число точек поля.



#####################
#####################
#####################

далее я пререшел к следущей части этой статьи 
    (https://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/)


 они пишут вот что. если я хочу с кем  тот же самый дифи хельман провести алгоритм.
то этому человеку должен передать домен параметров

        (N, a, b, G, k, h)

еще раз подчеркну что N это число точек поля F[N] а k и h относятся не к полю, они относятся
к группе точк эллиптической кривой. у которой число ее точек некоторое Z а k его делитель.
и Z k h связаны отношенеим Z=k*h
поэтому парамтер h совершенно не являтся лишим при указании как я ошибочно думал.

далее может возникнуть вот какой вопрос.
есть эллиптрические кривые такие что для них решение задачи о логарифмиовании
делается относиельно легко тоесть  есть слабые кривые. поэтому мне надо убедить человека на том конце провода котторому я шлю

    (N, a, b, G, k, h)

что я ему предлагаю   "надежную" эллиптиеческую кривую. как ему в этом 
убедиться. есть стандарт ANSI X9.62 (http://www.secg.org/sec1-v2.pdf) который придумали 
типа умные люди. в этом стандарте как я понял они предлагают вот что. в этой доке
написано как можно придумать случайное число S. и на основе этого числа выбрать парамтры
эллипт кривой а имнно кэфииценты a,b которые будут создавать типа безопасную эллпитичекую
кривую. (кто проверял ее безоапасность не неизвестно. тоесть мы доверяем в этом каким то 
дядям.) далее я передаю по открытому каналу это число S и все паарметры эллиптической 
кривой которые я рассчитал по формуле от этого S.  получается я передаю васе вот это

     S и (N, a, b, G, k, h)

вася берет S, на основе ANSI X9.62 высчитывает (N, a, b, G, k, h) и сравнивает с тем что 
я ему прислал.  это типа гаранттруем что мы выбрали кривую непросто из воуздуха а наосове
стандарта.    вчастности считаетс что хрен получится вначале придумать слабую эллптиеческую
кривую. а потом исходя из ее параметров руками сгененировать S. считатся что только можно
сделать наоборот. выбрать S и сгенеррировать парамтеры кривой. в целом тогда я 
не понимаю зачем вообще тогда пеердавать вот это васе (N, a, b, G, k, h)
вместо этого васе только надо передат S а все остальное он расчивтает сам. если по дооороге
злодей перехватит S и заменит его на S1 то в целом страшного ничего нет. тогда мы с злодеем
получим одинаквые параметры  (N, a, b, G, k, h) и сможем с ним на основе дифи хельмана
выработать одинаковый шаред сикрет. поднять между мной и злоддееем безопасный канал что
только  я и он  читаем друг друга. а дальше уже вопрос за аутентификацией. злодею нужно 
будет себя смочь аутентифицировать за друого. а это задача протокла аутетиаицкации ему 
это не дасть сделать.

вобем задача S и ANSI x9.62 в том что  если уменя и уваси один и тот же S то мы пользуясь
доверенным  стандарттом ANSI x9.62 генерируем друг перед другом паарметры эллипт кривой
которая гарантируется вляется належной по заверением людей написавщих стандарт. тоесть мы 
с васей в этом вопросе начинаем доверять людям из стандарта

далее.
ECDH - дифи хельман на базе эллипической кривой над конечным полем
напоминаю что дифи хельман относится к key-agreement протокол.
в частности статья пищет что это значит что задача дифихельмана выработать общий ключ
между двумя чуваками. так что бы третьи лица не могли его себе заграбастать. а какой 
алгоритм шифрования будет использоваться потом с исипользованием этого общего ключа это 
задача не дифихельмана. а другого рода. он только позволяет выработать ключ. что будет 
далье его не волнует.
иатк задача дфифи-хелмана вырабоатть общий ключ путем обмена между васей и петей кускамт
информации через открытый канал тоесть злодей может читать свободно то что мы с васей
шлем друг другу. но это не должно дать злодею нихрена.

итак как еще раз работает ECDH.
и у меня и у васи есть домен параметров

     (N, a, b, G, k, h)

мы ими обменялись по открытому каналу. считаем что их злодей не подменил. как  я понимаю
далее считаем что злодей толко читает в канале но не меняет данные.

вася  придумывает  свой приватный ключ это число l<k и генерирует публичный ключ в 
виде элемента элл кривой

     H_v = lG

и посылает по открытому каналу H_v к пете

петя  придумывает  свой приватный ключ это число s<k и генерирует публичный ключ в 
виде элемента элл кривой

     H_p = sG

и посылает по открытому каналу H_p к васе

вася получает петин публичный ключ H_p  это элемент элл кривой. и вася на основе этого
элемента вычисляет следущий элемент элл кривой по форумуле

   shared1 = l*H_p

петя получает васин публичный ключ H_v  это элемент элл кривой. и петя на основе этого
элемента вычисляет следущий элемент элл кривой по форумуле

   shared2 = s*H_p

фишка в том что то что пполучит вася и петя это будет один и тот же элемент

   shared1 = shared2

потому что 

shared1 = l*H_p=l(s*G)=(ls)G
shared2 = s*H_v=s(l*G)=(ls)G 

отсюда видно что shared1=shared2

прикол в том что злодей зная 

     (N, a, b, G, k, h)

и зная H_p и H_v

он не может вычислить ни l ни s из формул

H_v = lG
H_p = sG


поэтому вася и петя имеют выработаннный единый ключ. который они могут юзать для
шфироваки друг другу сообщений используя симметричный алгоритм шифрования. 
а злодей в пролете.


далее. как я понял был чувак Коблиц выделил из эллптических кривых такие у которых
задачу вычисления nP можно вычислять каким то макаром быстрее. такие эллптические
кривые зовут я кобы кривые Коблица или аномальные кривые. при том что термин аномальные
кривые еще как я понял используетс совершенно в руго смысле а именно если мы взяли 
кривую эллпитическую. в ней точку G  и k такой что k=N то такая подгруппа будет аномальной
потому что когда k=N то люди научились искать  решение логарифма как то быстро. вобщем
такая финя.


###########################
###########################
###########################


далее афтор статьи берет элип кривую 

        secp256k1

ее можно найти вот тут

    https://www.secg.org/sec2-v2.pdf

ее параметры

p = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE
FFFFFC2F

где p это размер конечного поля F[p]
я проверил что да. это число это прайм

почему то помимо хекс вида они это число дают вот в такой форме =

=2^256 − 2^32 − 2^9 − 2^8 − 2^7 − 2^6 − 2^4 − 1

я даже вначале подумал может  число p не прайм. может это нам дан неприводимый полином.
но нет. число p это прайм. и никакие неприводмые полиномы нам нахрен не нужны.
просто они привели прайм в двух видах в хекс виде и в виде разницы из степеней двоек(видимо
такой математичекий выебон)

итак порядок поля у нас есть.

далее даются коэфииициеты a , b полинома эллиптичской кривой

 -y^2 = x^3+ax+b

 a = 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000

b = 00000000 00000000 00000000 00000000 00000000 00000000 00000000
00000007

как видно a  у нас это банально 0 а b это у нас всего навсего десятичное число 7
тоесть эллиптическая кривая выглядит как 

     -y^2 = x^3+7


базовая точка (она же просто точка на элиптическо кривой)
дана в виде "uncompressed form"

G = 04 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9
59F2815B 16F81798 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448
A6855419 9C47D08F FB10D4B8


вначале я непонял что это за хрень. ведь точка G это два числа x и y 
а у нас тут одно число. 

но из статьи  я понял то что обе координаты "зашиты " в одно число тоесть

x_G = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9
59F2815B 16F81798

y_G = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448
A6855419 9C47D08F FB10D4B8

uncompressed form означает что обе координаты и икс и игрек вшиты в G

еще в стандарте (https://www.secg.org/sec2-v2.pdf) точка G может быть предтавлена
в виде "compressed form"

G = 02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9
59F2815B 16F81798

это значит нам представили как я понимаю только икс координату этой точки

x_G = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9
59F2815B 16F81798

видимо координату y нам предлагают найти самим

подставтив в эту формулу

     -y^2 = x^3+7

мне этот ход тоже не совсем понятен. дело в том что даже на примере p=19 мы видим что
для одного x есть два подоходящих y. тоеть у нас сидит неколько точек элл кривой на одной
линии x=A ну и какую точку нам выбирать тогда? с каким игрекром? да все эти точки наверное
будут иметь тот же самый. но вы извините если я начну "крутить" точку R это будет один элемент на выходе а если  я начну крутить -R то это будет другое число на выходе. а именно

     nR=Q1
     n(-R)=?

например 
    P=(2,2)
    2P=(13,8)
    P=-(2,2)=(2,17)
    2P=(13,11)

тоесть видно что 

   nR=Q1
   n(-R)=-Q1

в любом случае Q1 != -Q1

ну и представть  мне и васе вместо обоих координат от точки G приносят только ее икс
коордианту

x_G = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9
59F2815B 16F81798

тогда мы подствляем в полином эллиптикей кривой.
вася в итге себе берет такой игрек что у него элемент G
а я себе берут такой игек что у меня -G
мы начинаем ими пользоватья. но этоже будет пиздец! отому что мы должны поьзоваться одним
и тем же G!!!!!!!
поэтмоу зачем давать обрезаннй G Я НЕПОНИМАЮ!

но это так делается не в статтье а  вот тут (https://www.secg.org/sec2-v2.pdf) в статье 
все ормально. все по челоеквески




далее дается  порядок n точки G в виде  ( n еще  является делителем числа Z числа точек кривой)

n = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C
D0364141

замечеие такое что какой точно порядок у точки G мы незнаем но мы точно знаем что он 
НЕНИЖЕ ЧЕМ n. 

и кофактор h этого числа G относительно общего количества точек Z содеражщегося в эллиптической
кривой

h = 01

получается еслимы хотим узнать солько точек Z содержит эллиптичекая кривая над конечным полем
с число точек p то надо посчитать

    Z=n*h



как бы все. поле у нас задано. эллиптический полином задан. точка G на эллиптичекой кривой
выбрана. порядок n этой точки G указан ( по крайней мере порядок этой точки не ниже n может
быть он и выще мы не занем. но главное точне не ниже ).

кофактор h для точки G указан а значит число точек элл кривой над этим полем мы знаем 
        
        Z=n*h

можем работать с этой элиптичекой кривой

так вот далее приводится скрипт ecdh.py который берет 

     (N, a, b, G, k, h)

из secp256k1

и на основе этого делает дифи-хельмана или ECDH


###########################
###########################
###########################

тут я малек пеерскочил вперед и начал изучать ECDSA но он супер сложный и я начал
изучать просто DSA

для начала малая теорема Ферма: если n простое число то оно удовлетворяет 

    a^(n-1) ≡ 1 (mod n)

где a это целое которое не делится на n

это необходимое условие но недостаточное

я малек непонял диапазон для числа а.  но в примере в вики укаазано что а берут в диапазоне

    1  < a <  n-1

вот так гораздо понятнее.

проблема в том что эта малая теорема ферма это только необходимое условие тоесть если n
реально прайм то он должен удовлетвторять теореме малой ферма. но если мы начинаем
проверять число через эту теорему и у нас вроде все в шоколаде то это не факт что 
прверяемое число реально прайм. чем больше а мы перепробуем тем больше шансов что это
реально прайм.  есть числа непрайм которые выполняют эту теорему для много а. например
числа кармайкла они составные но выполняют эту теорему для всех а которые взаимно простые с n

пример  число 713

берем a=3

713 не делится на 3. значит такой а нам подходит


        a^(n-1) ≡ 1 (mod n)

3^(712) ?≡ 1 mod 713

значит на компе надо провертить что число 3^(712) - 1  делится на 713
в итоге я получил что не выполняется то есть он не прайм.

теперь беру реальный прайм 719

3^(718) ?≡ 1 mod 719

и вот так считаю

$ n=719; echo  " (3^($n-1)-1)  -     ((3^($n-1)  -  1 ) / $n) * $n   " | bc     
0

так как эта теорема это необходимое условие это значит что если оне не выполянется то 
это точно не прайм. а если мы знаем что это прайм она точно выполняется.
если мы незнаем прайм это или не прайм а теореама выполняется то это "кандидат в прайм".

если мы точно знаем что n это непрайм но теорема выполняется то тогда n называется 
"лжец ферма". и еще такой n называется псевдопрайм.

если мы взяли n и а и у нас теорема не выполняется то тогда говорят что а это свидетель 
доказательство того что n является непраймом


#####################
#####################
#####################





про обычногого дифи хельмана. 
мы берем прайм число p  и берем так называемый число генератор  g
далее вася и петя загаюыват числа k и s

вася: загадал k , а пете щлет число V

        V= мин пол вычет от (g^k) mod p

петя: загадал s , а васе щлет число  P

        P= мин пол вычет от (g^s) mod p

тогда вася берет P и делает с ним вот так

      мин пол вычет от (P^k) mod p

замечу вот что 

    P ≡ (g^s) mod p

и у нас есть свойство  у вычетов такое что  если 

    a ≡ b mod p 

то верно

    a^n ≡ b^n mod p 

поэтом раз мы имеем что     

    P ≡ (g^s) mod p

то верно 

    P^k ≡ (g^s)^k (mod p)
а это экиввалентно
    P^k ≡ (g^sk) (mod p)

значит мин пол вычет от (P^k) mod p = мин пол вычет от (g^sk) (mod p)
так вот петя получит туже хрень мин пол вычет от (g^sk) (mod p)

так вот что такое 


    g^x (mod p)


эта записана формула как оно высчитывается. 


откуда это ? а это вот откуда. мы взяли прайм p. мы можем создать конечное поле с элементами

        F[p] = {0.. p-1}

в этом поле есть в часноти операция умножения. умножение работтает по правилам вычетов.
в этом поле мы можем выделить конечную циклическую мультипликативную подгруппу 
с элементами 

        G[p-1] = {1.. p-1}

так вот когда мы выбираем элемент g который принадлежит этой группе мы получается выбираем 
порождающий элемент или генератор циклической подгруппы этой подгруппы

        K[] = <g>

размер этой подгруппы будет такой какой порядок у этого элемента g

так вот формула

        g^x

она таким образом нам генерирует некоторый элемент принадлежащий этой подгруппе K

итак когда мы видим 


      g^k (mod p)

они пишут это значит что у нас взята конечная циклическая группа. 
в ней кадый элемент может породит циклическую подгруппу вида

   { 1, g^1, g^2, ... , g^n}

где n это порядок элемента g. так вот 

    g^k (mod p)

это генерация одного из элементов подгруппы  K = <g>
точно ивзвестно что порядок элемнта g он явялется делителем числа элементов исходной 
группы. 

тоесть еще раз я хочу что сказать. дифи хельман основан на формуле


   мпв g^k (mod p)

так вот физ смысл этой формулы это то что мпв g^k (mod p) это  элемент циклической конечной
подгруппы. тоесть то что мы работаем с циклической подгруппой основной группы. 
циклическая группа это группа где все ее элементы могут быть порождены от одного элемента.
ксатти g это и есть этот порождающий элемент. еще его зовут генератор.

здесь заметка полезная - есть аномальные элл кривые это такие что число точек в этой группе
равно числу точек в исходном поле над которым группа построена. минус этих кривых (этой группы)
в том что в ней каким то макамро дискретный логарифм ищется быстро. так вот есть еще "аномальные
бинарные кривые" и они к стремным плохим аномальным кривым не относятся. хотя имеют похожее
название. аномаьными бинарными кривыми называются кривые Коблица. они заданы на полем
исключительно F[2^n], имеют какую то особую форму и их фишка в том что на них задача 
вычисления P+P, P+P+P тоесть nP занчительно выполняется быстрее. в этом их прикол. тоесть
я хочетл сказатьчто эти дебилы они называют термином аномльная кривая два совершенно разных
класса эл кривых. один класс из которых обозначает что все стремно. а второй что все круто.
заметка закончена.

###################
###################
###################

на счет модулярной арифметики.  в чем ее смысл.
когда они пишут

    (a*b)  mod p

то имеют ввиду что нужно перемножит по классике a*b получим некоторый c

   c mod p

а далее они вот этой операцией они находят ОСТАТОК от деления c/p
тоесть для них это ОСТАТОК

например a=5  b=10  p=13

    a*b=5*10=50 

    50 mod 13

50/13 = 3*13 + 11

и они берут остаток 11


а для математики которая на основе гаусса выражение

    (a*b)  mod p

оно про другое. да мы по классике перемножаем a*b получаем c
а потом мы ищем МИНИМАЛЬНЫЙ ПОЛОЖИТЕЛЬНЫЙ ВЫЧЕТ который входит в одно множество вычетов
с числом c
тоесть c=50   модулюс 13  
значит у нас можество вычетов это 

      50, 37, 24,  11, -2, ...

и вот мы видим что мпв у этого множества 11. и мы его берем. 

так что для "математика" модулярная арифметика состоит в том что мы находим число по 
классической арифметике. потом на его основе вычиляем множество всех вычетов. а потом в
этом множетсве находим МИНИМАЛЬНЫЙ ПОЛОЖИТЕЛЬНЫЙ ВЫЧЕТ. и его берем как ответ.

а для всех остальных ответ это просто ОСТАТОК от деления. вот какая разница.

также я скажу когда ОНИ пишут 


    c mod p

например

    50 mod 13

то они такой фразой имеют ввиду остаток от 50/13

но в математике фраза

    50 mod 13

имеет совершенно другой смысл. она задает МНОЖЕСТВО вычетов. а не одно число. 
множество вот такое

    50+13*k

а если мы хотим обозначиит ОСТАТОК от деления от это надо коректно записывать вот так

    мпв от 50 mod 13


###################
###################
###################

теперь нам нужно понтять что такое АЛГОРИТМ ЕВКЛИДА. он ищет наибольший общий делитель НОД онже gcb для двух целых наверно чисел.
каков физ смысл. возьмем два числа 

    a  b

и положим что оба из них разбиваются на множеители какието

  a= 2 * 4 * 17 * 31 * 5 * 19
  b= 3 * 2 * 21 * 37 * 5 *19

так вот можно выделить сравнивая их либо один общий множитель либо несклько общих
множителей. 

например в нашем случае это 5*19 = 95
значит оба этих числа можно представит вот так

  a= (5 * 19) * 2 * 4 * 17 * 31 = (5*19) * A = g *A
  b= (5 * 19) * 3 * 2 * 21 * 37 = (5*19) * B = g *B

так вот g это и есть НОД. тоесть если мы взяли два числа разбили на множители.
то НОД это тот одинаковый множитель который общий у обоих чисел. либо одинаковая группа
множителей.

далее утрвеждается такая теорема или лемма о том что если у нас есть два числа  


    a  b

и у них есть общий НОД который еще ксатти назвается gcb  то у числа


    мпв a mod b

и

    мпв b mod a


будет тот же самый НОД. тоесть у чисел


   a   b    мпв a mod b     мпв b mod a

один и тот же НОД.
пусть для определенности b>a
пусть gcb = g

    a = g * A
    b = g * B

мпв b mod a =  a-b*k = (g*A - g*B*k) =  g*( A - B*k ) = g*S

тоесть 

    мпв b mod a = g*S

тоесть четко видно что в мпв у него тоже точно есть множитель g.

и вот нам надо както вычленить этот g из исходных чисел. 

далее фишка в том что 

 | мпв | < |a| < | b |

 мпв = g*S
 a = g*A

 значит

 S < A

 значит мы получили число в котором множитель стоящий при g он стал меньше 
 чем он есть в исходных числа a и b

 вот у нас было два числа   b   a 
 стало

    b  a    мпв(b mod a)

все они имеют одинаковый НОД но третье число  у него множитель S стоящий при g он меньше
чем этот множитель у исходных чисел.
дальше мы вот что сделаем
обозначим как z = мпв(b mod a)
далее мы можем теперь расспотреть не числа  b  и а ,  а новую пару

   a    z

у нас a>z. также они имеют одинаковый НОД.
и мы сделаем также как с исхоными числами а именно

    q=мпв(z mod a)

полученное число q оно еще меньше по модулю чем a и z и у него множетель при g 
стал еще меньше. и вот так повторая вноврь и вновь мы придем к тому что множертель 
стоящий при g станет равен 1. и у нас получится в мпв число g. оно проявится мы его узнаем.
так мы можем на практие найдт НОД.
пример

35  20

мпв 35 mod 20 = 15

новая пара

20 15

мпв  20 mod 15 = 5

новая пара

15 5

мпв  15 mod 5 = 0

значит наше число 5 это и есть НОД всех этих чисел. 

35  20  15  5

все они имеют единый НОД=5

ну и  я щас покажу как сжимался множетель при g в кажом числе на каждом шаге

35=5*7  20=5*4  15=5*3  5=5*1

так что множетель мусорный сжимался начиная с 7 и закончился на 1.

эта методика когда мы находим НОД для двух чисел путем взятия mod mod mod mod назыается
алгоритм евклида. или типа того

еще пример дам

720  15

мпв 720 mod 14 =  6

15  6

мпв 15 mod 6 = 3

6 3

мпв  6 mod 3 = 0

значит НОД (720,15) = 3


вот что дает алгоритм евклида. 

щас распишу как вычислять  алгоритма евклида в английской википедии.(https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm) 
пользуются вот такими формулами
пусть у нас дано два натуральных числа a b
и a>b

    r0 = a
    r1 = b
    r2 = r0 - q1*r1, где q1=r0//r1  (знак // явзял из питона он значит целое от деления)
    r3 = r1 - q2*r2  где q2=r1//r2
    ..
    ..
    r(i+1) = r(i-1)-q(i)*r(i)

    для всех r выполняется   0 <= r(i) < r(i-1)

расчет r ведется вниз до тех пор пока мы не получим что r(i)=0
тогда НОД=r(i-1)

показываю на примере

    a=35
    b=15
    a>b (тут я обращаю внимание на то что обычно я все расписываю при b>a но в описании
         этого алгортма все наоборот a>b)

    r0=a=35
    r1=b=15
    r2=35-(35//15)*15=35-2*15=5 
    r3=r1-q2*r2=15-(15//5)*5=0
    раз мы получили 0 значит можно остановится. и значит что НОД(35,15)=r2=5



###########################
###########################
###########################

далее есть ВЫРАЖЕНИЕ БЕЗУ, ТОЖДЕСТВО БЕЗУ

оно выглядит так, для натуральных чисел a,b   есть такие натуральные числа x,y что 
выполняется равенство


    a*x - b*y = НОД (a,b)

но как их искать он не сказал.

итак a,b задано. НОД(a,b) мы можем вычислить. осталось понять как искать x,y
а искать их надо на основе РАСШИРЕННОГО АЛГОРИТМА ЕВКЛИДА. этот алгоритм расписан вот 
тут ( https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)


правда в компах выражение безу несклько по другому запиывают


    a*x + b*y = НОД (a,b)

и говорят что x,y они целые но не ноль я так понял. 
итак как искать x, y, НОД(a,b) на основе  РАСШИРЕННОГО АЛГОРИТМА ЕВКЛИДА.
итак берем a,b > 0 и a>b 
тут я обращаю внимание на то что обычно я все расписываю при b>a но тут я обращаю внимание
на то что a>b
тогда алгорит говорит что нужно вычислить вот такие штуки
записываем в два стоолбика

    r0=a        
    s0=1        
    t0=0        

    r1=b
    s1=0
    t1=1

    ...
    ...
    r(i+1)=r(i-1)-q(i)*r(i),        0 <= r(i) < r(i-1),  
    q(i)=r(i-1) // r(i)       (знак // я взял из питона он значит целое от деления) 
    s(i+1)=s(i-1)-q(i)*s(i)
    t(i+1)=t(i-1)-q(i)*t(i)
    
расчет прекращается когда очередной r(i)=0 
тогда gcb(a,b)=НОД(a,b)=r(i-1)
и коэфициенты s(i-1)  t(i-1) для выражения безу

  a*s(i-1) + b*t(i-1) = gcb(a,b)

мы тоже нашли.
это и есть расширенный алгоритм евклида.
покажу на примере

    a=125   b=15, a>b

    r0=125
    s0=1
    t0=0

    r1=15
    s1=0
    t1=1


i=1 q(i)=r(i-1) // r(i) 
    q(1)=r0 // r1 = 125 // 15 = 8
    r(2)  = r(0) -q(1)*r(1)=125-(125//15)*15=125-8*15=5
    s(2)  = s(0) -q(1)*s(1)=1-8*0=1
    t(2)  = t(0) -q(1)*t(1)=0-8*1=-8

    
i=2 q(2)=r1 // r2 = 15 // 5 = 3
    r(3)  = r(1) -q(2)*r(2)= 15-3*5=0  <== мы получили 0 значит стоп алгоритму
    s(3)  = s(1) -q(2)*s(2)=
    t(3)  = t(1) -q(2)*t(2)=

значит gcb(125,15)=r(2)=5
    s(2)=1  t(2)=-1 это коэфициенты безу

    a*s(2) + b*t(2) = gcb

    125*1 + 15*(-8) = 125-120=5
    5 = 5

все сработало.  расширенный алгоритм евклида сработал


а дальше я расматриваю другой способ найти коэфициенты безу. оно встречается
в компьютерных сайтах.

прежле чем прейти к вопросу как искать x,y я вот что скажу.  
я могу доказать что выражение безу оно точно верное 

    a*x + b*y = 1

для некоторого частного случая

так вот. возьмем вот такое выражение

    (b*x) ≡ 1 mod a

что оно значит

   (b*x-1)=k*a

раскрываем скобки

   b*x - k*a = 1

заменим -k = n

    b*x + a*n = 1
или
    a*n + b*x = 1
мы знаем a и b, мы незнаем n и x. они целые.

получили выражение аналогичное

    a*x + b*y = 1

теперь рассмотрим как искать x, y для выражения безу.
толлько для начала я заменю x,y на t,v 

итак нам надо два числа натуральных a,b
причем  я буду считать что b>a
    
        b*t + a*v = НОД(a,b)

тоесть слева стоит число которое больше по модулю. 
надо найти t,v, НОД(a,b)
ну НОД то мы уже умеем искать. вопрос как найти t,v

наконец перехожу к этому другому способу поиска коэфициентов безу.

они говорят так - предположим что мы уже какимто макаром нашли все три числа для каких 
то M и N  где опяьт же M>N тогда


         M * t'  + N * v' = НОД (M, N)


чтобы быть более точным  предполжим что мы нашли это для чисел  "a"  и "мпв от b (mod a)"
причем мы же знаем что  a > "мпв от b (mod a)"
поэтому у нас первым будет идти "a" а вторым будет идти "мпв от b (mod a)"
запишу это 

     a * t'  + (мпв от b mod a) * v' = НОД (a, мпв от b (mod a))

итак приведу сразу оба выражения вместе


     b * t   +       a          * v  = НОД(a,b)
     a * t'  + (мпв от b mod a) * v' = НОД (a, мпв от b (mod a))


во первых замечу что мы уже знаем из того что я расотрел выше что 

НОД (a, мпв от b (mod a)) = НОД (a, b)
таким макаром 


     b * t   +       a          * v  = НОД (b,a)
     a * t'  + (мпв от b mod a) * v' = НОД (a,b)

тоесть я привел два выражения безу для двух пар чисел   одна пара b,a
вторая пара это a, (мпв от b mod a)

так вот мы говорим что предположим для чисел a, (мпв от b mod a) мы каким то макаром
нашли t' и v'
но для начала более подробно рассмотрим само вырражение

     a * t'  + (мпв от b mod a) * v' = НОД (a,b)      (1)

    а именно кусок (мпв от b mod a)
    z = (мпв от b mod a)  
    b-z = a*[b/a],   где [b/a] это целая часть от деления b на a
    z = b - a*[b/a]

подтславяем это в уравнение (1)

     a * t'  + (b - a*[b/a]) * v' = НОД (a,b)    


раскрвыаем скобки и собираем вместе то что рядом  с a и b


     a * t'  + b*v'  - a*[b/a]) * v' = НОД (a,b)    
     b*v' + a*(t'-[b/a]*v') = НОД (a,b)

итак сравним то что нам надо найти с тем что мы пока что получили


     b*t  + a*v             = НОД (b,a)
     b*v' + a*(t'-[b/a]*v') = НОД (a,b)

и получается что если мы знаем t' и v' то мы как бы можем вычислить чему равен t и v
сравнивая эти два выражения

    t = v'
    v = (t'-[b/a]*v')

и далее логика как берем два числа b,a   b>a
смотрим можем ли мы для них налету подобрать t,v если нет то 
вычисляем  мпв(b mod a)  и берем новую пару

    a  мпв(b mod a)

смотрим можем ли вы для них както легко вычислить t' v'
если нет то берем еще новую пару. для начала обозначим  z=мпв(b mod a)
и новая пара вот такая

   z   a mod z

смотрим можем ли мы для нее подобрат t'' v''
в конце концов у нас пара чисел станет очень простая. и мы для них подберем числа в выражение
безу. а потом начнем движение наверх. как я уже сказал когда мы выбрраем пары именно
таким оюразом то прикол в том что НОД неменяется. он остается тем же самым.

пример. вначле пример так чтобы у нас была всего одна итерация.

  b=20   a=15


20 15

  20*t + 15*v = НОД(20,15)

ну мы неможем вычслить  t,v вот так сразу. тогда

 мпв 20 mod 15 = 5
 тогда новая пара это 

15  5

и вот так мы запиываем выражние безу

15*t' + 5*v' = НОД (15,5)

НОД мы можем сразу вычислить это 5. значит и исходный нод тоже 5


15*t' + 5*v' = 5

далее  

15 mod 5 = 0

это значит что мы дошли до того состояния что одно из чисел в паре это НОД.
тоесть дальше двиаться вниз мы неможем. итак мы имеем

15*t' + 5*v' = 5

берем t'=1   v'=-2

15*(1) + 5*(-2) = 15-10=5

 5=5

 тоесть мы имеем

исходно выражение

 20*t + 15*v = НОД(20,15)

и выржание для вспомогателное

15*t' + 5*v' = 15-10=5

t'=1   v'=-2

тогда юзаем формулы


   | t = v'
   | v = (t'-[b/a]*v')


t = -2
v = 1-[20/15]*(-2) = 1-1*(-2)= 3

подставляем

 20*t + 15*v = НОД(20,15) 
 20*(-2)+ 15*(3) = 5
 провреяем
 -40 + 45 = 5
 5 = 5

 сработало

много шагов вниз будет если у нас два числа взаимно простые то есть у них общий множеитель
тобишь НОД =1 . пока мы внизу дойдем чтобы у нас один из чисел в паре стал 1 это 
будет много шагов.


спрашивается  а зачем нам этот безу? а он нам вот зачем. вспоминаю выражение

    (b*x) ≡ 1 mod a


совершенно понятно что элемент x это элемент b^(-1) с точки зрения мультипликативной
группы.

расклывадем это выражение 

  b*x -1 = k*a
  b*x - k*a = 1

  заменяем -k=n

  b*x + a*n = 1

мы получилли выражение безу. если у нас b и a взаимнопростые то то что стоит справа 1 это
как раз таки НОД (b,a). если a это прайм. то конечно при любом b у нас НОД(a,b)=1
и мы имеем точно выражение безу. перепишу его

  b*t + a*v = 1

так вот мы уже умеем искать t,v  и  как я уже сказал t это будет b^(-1) элемент с точки
зрения мультпликативной группы.  тоесть если мы зададим элемент b и  модулюс a 
то через методику что выше мы можем найти элемент обратный к b такой что

        b*t = e

тоесть эта методика позволяет находить обратный по умножению элемент к элементу в мультипликат
ивной группе. а это нам понадобится в DSA алгоритме. вот зачем все это надо.
потому что если группа бльшая например в ней 2^155 элементов то в лоб найти обратный элемент
это нереальная задача. а так следуя алгоритму уже реальная задача по вычисленияем.

покажу на примере. вот  унас  b=5  и a=13
тоесть у нас группа из элементов {1..12}
в ней расчет умноения идет по модулюсу 13 и я хочу найти элемент v такой что

   5*v = e

итак у нас есть пара чисел

13  5

пишем безу

    13*t + 5*v = 1

слева всегда пишем то число которорое больше по модулю.

формируем следующую пару

  мпв(13 mod 5)=3

5  3

    5*t' + 3*v' = 1

формируем следущую пару

мпв (5 mod 3) = 2

3 2 

    3*t'' + 2*v'' = 1

формируем следущую пару

мпв(3 mod 2) = 1

2  1

    2*t''' + 1*v''' = 1

мы получли что одно из чисел в паре это 1. значит мы дошли до дна. 

(нод у нас неменяется что сверху что снизу)

берем t'''=1  и v'''=-1

тогда начинаем подниматься наверх.
берем выражение чуть выще

    3*t'' + 2*v'' = 1

и ишем для него t'' и v'' по формулам

    t'' = v ''' = -1
    v'' = t''' - v'''*[b''/a''] = 1 - (-1)*[3/2] = 1+1*[3/2]=1+1*1=2

подсталвяе проверяем

    3*(-1) + 2*(2) ?= 1
    -3 + 4 = 1

совпало

берем выражение еще выше на 1 левел

    5*t' + 3*v' = 1

высчитабваю t'  и   v' по формулам учитвая что t''=-1      v''=2

    t' = v '' = 2
    v' = t'' - v''*[b'/a'] = -1 - 2*[5/3]= -1 -2*1=-3

подставляют проверяю

    5*t' + 3*v' = 5*2+3*(-3)=10-9=1 = 1 
совпало

подтсвляем в самый верхний учитывая что t'=2     v'=-3


    13*t + 5*v = 1


    t = v ' = -3
    v = t' - v'*[b/a] = 2 - (-3)*[13/5] = 2+3*2=8

    13*(-3) + 5*(8) = -39 + 40 = 1
    1=1

все совпало. в итоге


    (13)*(-3) + (5)*(8) = 1

и получается число 8 это число обратное к 5 в мультпликативной группе элементов {1..12}
где умножение идет через модулюс 13

проверяем

  мпв (5*8) mod 13 = мпв 40 mod 13 = 1

тоесть да

    (5*8) ≡ 1 mod 13


тоесть алгоримт позволил найти  5^(-1) элемент группы.

тоесть я еще раз хочу подчеркнуть вот у нас есть числа a и p
где p это прайм.
я ищу x такой что

   (a*x) ≡ 1 mod p

что такое число (a*x) это получается такое число которое имеет мпв=1
например a=5 x=8 a*x=40.   40 и 1 лежат в одном множестве вычетов и 1 явялется мпв
этого множества.

а теперь вспомним про умножение в мулипликативой группе. какой элемент явлетя обратным - 
это такой элемент который при умножении на данный элемент приводит к числу мпв которого
равно 1. что мы и имеем. поэтому x это обратное по умножению число в мулттипликативной
группе.

если мы распишем выражение (a*x) ≡ 1 mod p  томы получим
 

    a*x + p * (-k) = 1

очевидно что это выражение безу. справа стоит 1 который для a и p конечно как раз выражает
НОД(a,p), так как p=prime то НОД всегда 1. короче мы получили форменное выражение безу.
а как мы уже знаем мы можем найти x и k. а нам надо как раз найти x.
поэтму вся эта хрень с безу как раз ради этого - ради алгорттма поиска обратного 
элемента в мультипликативной группе


еще раз запишу эту формулу поиска кэфициентов
имеем исходное выражение

    b*t + a*v = g    , g=NOD(b,a), b>a
если мы знаем коэфициенты вот для этой формулы
    a*t'+(b mod a)*v' = g
то тогда для исходной формулы мы можем найти кэфиценты чрез формулу
    | t= v'
    | v= t' - v'[b/a]

под выражением (b mod a)  я имел ввиду "мпв от (b mod a)" просто покороче его записал.

еще раз подчеркну что НОД для чисел a,b и для чисел a, мпв(b mod a) он один 
и тот же. поэтому правая часть в безу. вот этот вот g он один и тот же что для исходной
пары чисел что для всех пар ниже!!! это важно понять. изначально мы его незнаем.
но мы когда спустимся вниз. и получим простую пару . то мы для нее элементарно этот НОД 
и узнаем. !


( вот две ссылки в котороых кое как это все опсано про расчет безу
  http://e-maxx.ru/algo/export_extended_euclid_algorithm
  https://ru.algorithmica.org/cs/modular/extended-euclid/ 
  )


если взять выражение

  b*x ≡ 1 (mod p)

где p это прайм

то это превращается в безу

  b*x + p*(-k) = 1

который мы умеем решать относительно x

и тогда получется что мы умеем решать частную задачу ну если не дискретного логарифмирования
то чтото наподобие. 

тоесть я скажу по другому что решая выражение безу вот такого вида


  b*x + p*(-k) = 1

то по факту мы находим решение вот такого "дискретного уравнения"

  b*x ≡ 1 (mod p), p=prime

котрое попробуй как руками найти решение. например 

  (13*x) ≡ 1 mod 23

то есть смотри понятно что вот такое выржение

  (y) ≡ 1 mod 23

его просто решить. это числа

24, 47, 60, .... 

а теперь положим что y=13*x 
так вот среди этих чисел теперь попроуй найди то которое делится на 13. 
а мы с нашим алогоритмом можем.

общее выражение безу

    b*x + a*y = НОД(a,b)

оно экивалентно решениею уравеннеия

    (b*x) ≡ НОД(p,b) mod  p 

при этом уже p необязателно чтобы был праймом. он может быть любым натральным числом.
главое чтобы b,p были подобраны так чтобы они были равны коэфициенту перед словом mod
чтобы этот коэфициент был равен НОД(p,b)

например берем b=35 p=20  тогда НОД(35,20)=5 тогда вот такое уравение мы имеем

 (35*x) ≡ 5 mod  20          (2)
 
и вот такое уравенние оно анаолоично вот такому безу

    35*x + 20*y = 5

который мы можем решить через наш алгоритм. и значит найти x и значит решить (2)

тоесть безу позволяет решать некоторый дискретные уравнения. вот что  я хочу сказать.
да это не решение дискретного логарифма. но все такие это тоже нетакие легкие задачи.
а он решает

по поводу алгоритма нахождеие коэфицентов безу. еще раз вот что.
вот рассмотрим изначальную пару

13 5
и далее у нас будут вспомогательные пары
5  3
3  2
2  1

распишу это вот так

 b1=13  a2=5
 b2=5   a2=3
 b3=3   a3=2
 b4=2   a4=1

 отсюда формула

b(n)=a(n-1)  a(n)=мпв ( b(n-1) mod a(n-1) )

я рассматриваю далее случай исключельно когда НОД=1 тогда
мы вниз когда пойде то дойдем до 

  a(n)=1

а b(n)  будет равен какому то k

  b(n)=k

и наш безу будет выглядеть как

    k*t(n) + 1*v(n) = 1

и тогда это означает что мы дошли до дна. 
мы дошли до такой пары чисел

k 1

и понятно что у такой пары есть только один НОД это 1 
и кофиценты безу тут можно выбрать вот такие

  t(n)=1    v(n)=-k

и начать подььем обратно. это я про напиание программы расчета. вот к чему веду.



теперь поговорим про компьютерную  програму расчета просто алгоритма евклиада. и алогритма
вычисления коэфициентов выражения безу. 


вначале немного про python есть такая строка

    a, b = b, a % b

что она значит. она на самом деле значит вот что
во временные переменные вычисляется то что стоит справа. тоесть

temp1 = b
temp2 = a % b

а после этого оно присваивается тому что стоит слева тоесть

    a=temp1
    b=temp2

напрмиер пусть a=100 b=13
тогда 

    temp1=13
    temp2=100%13=9

    a=temp1=13
    b=temp2=9

в чем ебанутость такой записи

    a, b = b, a % b

она в том что она освершенно не эквивалентна 
записи

 a=b
 b=a%b

как казалоссь. потому что 
если бы это было так то 
наш случай a=100 b=13
он бы привел вот к такому

 a=b=13
 b=a%b=13%13=0

почуствуй разницу с прердущим обьяснением когда
в итоге

a=13
b=9

поэтому вот эта строчка

    a, b = b, a % b

ее нормаьный не ебанутый 
эквивалент вот такой

  temp1=b
  temp2=a%b

  a=temp1
  b=temp2





а они все это записывают в форме выебона чтобы уухудщить читаебельность

вот как выглядит программа расчета коэфициентов в выражении безу 
(на чем она основана на расширеннном алгоритме евклида или на альтерантивном способе
я даже щас разбираться не буду)

    x  = 1
    xx = 0
    y  = 0
    yy = 1

    while b:
        q = a // b

        a = b
        b = a % b


        temp1=xx
        temp2=x - xx*q
        x = temp1
        xx = temp2

        temp1=yy
        temp2=y - yy*q
        y = temp1
        yy = temp2


значит сама прога лежит в файле "euclid-adv.py"

запускаю ее с числами 1025  100500
на выходе имеем

a= 1025 b= 100500
(a) * 1961 + (b) * -20 = 25 =НОД(a,b)
x= 1961 y= -20

видно что НОД=25
и a и b на него делятся


поиск коэфициентов безу нам очень нужно 
для нахождение элемента обратного к данному в мултипликатичной группе. 
  
занчит расширенный алгоритм евклида он нам для двух чисел a,b  находит три числа

x,y,НОД

вот в примере выше для a=1025 и b=100500 он нам выдал

(a) * 1961 + (b) * -20 = 25

где 25 это НОД. а 1961 и -20 это два числа x,y
так вот берем мультипликативную группу 

    {1 .. 12 } 

в ней работает умножение по модулюсу 13

так вот можно вот что сделать. если у нас например элемент 5 и мы хотим для него найти 
обратный элемент такой что

   5*x = e

или в рамках конкнекретики нашего умножения

   (5*x) ≡ 1 (mod 13)

так вот они говорят что если мы подставим в  AE (расшиеный алгоритм евклида) 
a=13 где 13 это модулюс а b=5 где 5 это элемент для котороо мы ищем обратный то 
AE нам высчитает что НОД=1 

 a*x+b*y=1

и число y которое он высчитает будет как раз таки элементом обратным к 5. тоеть 5^(-1)
подставляем проверяем

a= 13 b= 5
(a) * 2 + (b) * -5 = 1 =НОД(a,b)
x= 2 y= -5

вот видно что АЕ высчитал что НОД=1 и высчитал то что

(a) * 2 + (b) * -5 = 1 

и утрвеждается что -5 это элемент обратный к 5.
проверим.

-5 это 8

мпв (8*5) mod 13 = мпв 40 mod 13  = 1

получается что да. 8 это обраттный элемент к 5 в груупе где умножение работает по правилу
арифемтики модулюс 13

   8*5=e

правда меня что смущает АЕ нам выдал элемент -5. я его перевел в 8 на основе операции сложения
групповой. а у  меня изначально группа имеет только оперцию умноежния.
тоесть с точки зрения мультипликтивной группы нет смысла в элемнте вида -5. вот что стремно.

вот еще я взял пример. ищу в мультипликативной группе элементов {1..52} 
с операцией умножения по модулюсу 53 обратный элемент к 17
тоесть

  (17*x) ≡ 1 (mod 53)

получил

a= 53 b= 17
(a) * -8 + (b) * 25 = 1 =НОД(a,b)
x= -8 y= 25

получется он утвержает что 

  17*25 = e

проверяю

$ echo $(( (25*17) % 53 ))
1

действиетльно так и есть.
чтобы расчитать AE выполнил три ходки цикла

я взял модулюс 17*17*17 
элемент 53
ищу к нему обратный
получаю 927

проверяю
$ echo $(( (927*53) % (17*17*17) ))
1

реально работает. чтобы найти 927 прога сделала 6 раз проходку цикла

значит прикольны алогрим потому что находить лобовой поиск обратного элемента в группе в ко
торой скажем 100500000 элементов это ад. меня смущает два момента. 
один это надо понять почему алгоритм работает. и второе как понимать получаение отрицательных
чисел ведь группа у меня мултипликативная


поиск обратного элемента оказывается можно сделать и по другому. без коэфициентов безу.
дело вот в чем. если у нас модулюс это прайм. то мы воспользуемся малой теоремой ферма о том
что 


    a^(p-1) ≡ 1 (mod p)

для любого натурального a или типа того ( p это прайм)
так вот  возьмем ка мы вместо a элемент k 


    k^(p-1) ≡ 1 (mod p)


далее пользуемся свойством что если 

   a ≡ b

то также верно что 

    m*a ≡ m*b

тогда доомножим левую и правую часть на k^(-1)
получим


    k^(p-2) ≡ k^(-1) (mod p)

получается что элемент k^(-1) и элемент k^(p-2) лежат в одном множестве вычетов.
получается что если мы возьмем и посчитаем чему равен k^(p-2) а потом вычислим
на основе этого числа какой мпв у множества вычетов

   k^(p-2) mod p

то это будет тот же самый мпв что  и для вычета k^(-1) потому что они с ним лежат
в одном множестве вычетов. более того! k^(-1) сам является мпв. поэтому 
если мы посчитаем

    мпв ( k^(p-2) mod p ) 

то мы узнаем чему равен элемент k^(-1)
это и есть альтерантивный способ как зная k найти для него k^(-1) без вычисления
коэфициентов безу. то есть

мпв (k^(-1) mod p ) =  мпв (k^(p-2) mod p ) = k^(-1)

поэтому если у нас есть k. мы его возводим в степень p-2 потом делим на p
находим остаток от деления и получаем k^-1
проверяем.

беру k=5  p=13

    5^(13-2)=48828125

    ( 5^(13-2) ) % 13 = 8

    (5*8) mod 13 = 1

тоесть реально 8 это обратный элемент к 5


далее я пробую возвратиться на основе всего этого изученного к тому как же работает DSA?
значит во первых я считаю что DSA это полная насмешище над идеей то как должна работать
цифровая подпись. во всех обычных статьях пишут о том что такое цифровая подпись.
якобы мы имеем приватный ключ. мы берем хеш(исходное сообщение) и шфируем его приватным ключом
получаем какойто шифротекст на выходе. человек берет этот шифротекст. далее берет 
публичный ключ расшифроывает этот шифр. получает исходное собщение или его хеш.
далее берет исодное собщение вычисялет от него хеш и сравнивает. если совпадает то 
все окей. тоесть еще раз цфировая подпись она должна работать так - нам дается публичный
ключ, шифротекст, и исходный текст. мы накладываем публичный ключ на шифротекст и получаем
оригинальный текст на выходе. сраниваем с открытым текстом. если совпадает значит текст
подлинный. тоесть цифровая подпись должна восстанавливать исходный текст (или его хеш без 
разницы) через публичный ключ.  
НО DSA работает СОВЕРШЕННО НЕ ТАК!. это насмешка какаято.
но пока еще кое что опишу прежде чем переходит к DSA.
что такое решение дискретного логарифма. нам дается число А. нам дается число g.
решение это такое число x что 

    g^x = A

считаеся что зная А и g хрен найдешь этот x


также мой вариант как должна работать цифровая подпись. мы берем число g, число k,
модулюс p, берем хэш H, 
далее мы вычисляем

    A=g^k
    B=g^(k+H)

мы публикуем g, A, B. ну а H человек и так знает.
тогда человек берет A и вычисляет 

    Q=A^(-1) 

по факту это получается g^(-k)
далее он умножает Q на B 

    W=Q*B=g^H

и пофакту число W которое мы получаем оно равно g^H
потому что 

  W=A^(-1)*B=g^(-k) * g(k+H) = g^H

далее человек берет исходный текст H и возводит g в степень H

    g^H

и то что получилось сравнивает с W

я тут согласен с тем что тут я противрочеу сам себе в том плане что мой вариант "цифровой
подписи" тоже не подходит по классику потому что мы не восстановили из B оригинальный H
мы восстановили g^H а это не одно и тоже. тем не менее фишка в чем. если человек незнает
чему равно k он никаким макаром неможет сгенерировать число B

    B=g^(k+H)

тоько человек знающий k может сгенерировать число B. также из того что мы опубликовали
    
    A=g^k
    B=g^(k+H)

наскоько я понимаю нельзя вычислить этот к.
втоже время этот метод позволяет удовтстовериься что именно тот человек который знал k
он вычислил g^(k+H) тоесть то что имено он "подписал" документ. или скажем еще по другому
что он его прочитал а потом подписал.
на мой взгляд если человек взломщий будет нам приылать на подпись разные H 
то таким макаром он все равно никак не вскроет наш k. ведь даже имея A=g^k где нет никакого
H это все равно взломщику нихрена недает.
итак свой вариант как я бы делал цифроую подпись я описал.

теперь вот о чем поговорим. возьмем некоторое число k и представим его  в таком виде
и найдем число s такое что 

  s=k*r*x

где r,x это тоже некоторые числа.

так здесь важно понять и увидеть что и я думаю это очевидно что число k оно абсолютно
независит ни от r ни от x ни от s. оно абсолютно самостоятельное. здесь все три числа 
k,r,x они не зависят друг от друга. едиснвтенное число которое завиисит от других это число s
а теперь вот такое посмотрим. 

1      1                     s
== =  ======  ===>  k =    ========
s      k*r*x                 r*x

и из этой формулы начинается казатться что k являеется деривативом зависимым от других чисел.
так вот это все конечно же полная наебалово. k по прежнму полностью независимая штука
если мы подставим чемму равно s

     s = k*r*x 

то мы получим тупо тождество

            k*r*x
     k =  ========== = k
            r*x


тоесть выражение

         s
k =    ========
        r*x

оно не о том что k является деривативом от  r,x,s  а оно на самом деле о том что в этой 
формуле r,x по прежнему свободные перменные. и нужно в эту формулу такое подставит s
чтобы мы получили в итоге k.
вот в чем прикол.  тоесть мы привыкли что справа стоят независимые переменные а слева стоит
уже зависимая переменная дериватив. но в нашем случае это не так. это нам пригодится
дальше

нет никаих операций деления. напрмиер 

    10
   ====
    5

операции деления в природе нет. есть только операция умножения. по факту на самом деле
вот что имеет место на самом деле вот эта запись


    10
   ====
    5

на самом деело это условное обозначение для вот такого 

    10*( 5^(-1) ) 

тоесть


 1
 = это условное обозначение для 1* 5^(-1)
 5


поэтому вместо операции деления 10/5  мы имеем по факту ОПЕРАЦИЮ УМНОЖЕНИЯ.


    10*( 5^(-1) ) 


а множитель   5^(-1)  это на самом деле условное обозначение для такого элемента x который
по факту мы еще не знаем но этот элемент x отвечает вот таким требовованиям


    x*5=1

поэтому
исходное выражение

10
===
5

это на самом деле операция


    10*x

где x это некоторый элемент который мы еще пока незнаем. но мы точно знаем что он такой
что 

   5*x=1

если у нас 10 и 5 это не просто числа а элементы поля скажем. скажем при арифметике 
под модулюсом 13. тогда получается в этом поле 5^-1 это по факту элемент 8
поэтому  в таком поле

10
===  =   10*8
5

вот это очень удивительно и важно понимать

DSA DSA DSA DSA DSA DSA DSA:
итак пробую начать распутывать как работает DSA:
для начала как грубо формально работает алгоритм.
берется два прайма q p, они должны принадлежать определенной битности причем друг 
относиельно друга. например согласно вики вот один из вариантов

    p=1024 bit
    q=160 bit

так вот на основе прайма p формируется мультипликативная группа с 
элементами 

    { 1..(p-1) }

правило умножения в группе работает по правилу модулюса p
далее q помимо размера 160 bit есть еще требование чтобы q был праймом и чтобы q был делителем
числа (p-1) , тоесть 

    (p-1)/q = целое число

это нам дает вот что. пока схематично - если я беру в конечной циклической мулбтипликативной
группе любой элемент "a" и начинаю умножать сам на сам себя то он порождает мультипликативную
циклическую подгруппу. число элементов этой подгруппы или что тоже самое порядок этого 
элемента равен

    a^(N/q)

где N это число элемнтов в исходной группе а q это один из делителей числа N.
например если в исходной группе 12 элементов то подгруппа в такой группе может иметь только

12/12=1
12/6=2
12/3=4
12/2=6
12/1=12

элементов

так вот ест теорема которую я неприавльно понял а щас понял правильно о том что если я возьму
элемента a и для него выполняется

    a^(N/q) != e , причем q это прайм

то тогда элемент  g = a^(N/q) имеет порядок q
моя ошибка состояла в том что я думал что в этом случае порядок элемента a составляет q.
а это огромная ошибка. доказательство этой теоремы пока я непонял.
а вот пример
группа   

    {1, 2, 3, 4, 5,6 }

в ней математика на основе модуло 7
число элементов 6
возможные подгруппы имеют порядок 1 2 3 6
выбираем 3 как прайм делитель. 
начинаем искать

  a^(6/3)= a^2 != e

пусть a=1  1^2=1 неопдоходит
      a=2  2^2=4 подходит.
значит согласно теореме элемент 4 имеет порядок 3.
проверим

  4^0=1
  4^1=4
  4^2 mod 7 = 16-14=2
  4^3 mod 7 = 64 mod 7 = 7*9+1 = 1

видим что действительно элемент 4 порождает подгруппу размера 3 = {1, 2, 4}
важные замечения при порождении подгруппы начинаем со степени 0. а не 1.
если есть конечная группа размера N то любой элемент a имеет свойство

    a^n = e

если группа аддтивная то 
    na = 0

возвращаемся к DSA.
у нас группа имеет размер (p-1)
у нас ее делитель равен q и он прайм.
берем элемент h из группы { 1..(p-1) }
провяеряем что 
        h^( (p-1)/q ) != e
если это так то согласно теорме что я описал элемент
    
        g=h^( (p-1)/q )

порождает подгруппу размера q
яже неправильно понимая теорему думал что сам элемент h порождает такую подгруппу. 
это неправильня идея.
поэтому теперь понятно почему они g ищут именно по такой формуле.
ксатти они там делают вот такое замечение вот о чем. если у нас элемент g имеет порядок q
то тогда должно выполняться вот что 

   g^q = e

потому что как я уже сказал если группа размером N то для любого элемента выполняется что 

    a^N=e (для мулипликативой группы)
    na=0 (для аддттивной)

значит

  g^q = h^(p-1) =   h^(p-1) mod p 
мы знаем что p у нас прайм. тогда есть малая теорема ферма о том что если p это прайм
то для любого h>0 выполяется что 

    h^(p-1)  ≡  1 mod p

ну а поскольку мы работаем постоянно с мпв то получается что 

мпв h^(p-1) mod p  =  мпв 1 mod p = 1 = e
тоесть мы получили что 

мпв g^q = мпв h^(p-1) mod p  =  мпв 1 mod p = 1 = e
или

    g^q = e

что нам докзывает что порядок элемента g  у нас q
правда может быт такой прикол что у нас наш полученный порядок он кратен какому то 
более мелкому порядоку тоесь например. пусть у нас порядок элемента равен 2. а мы 
высчитали

   g^4 = e

и тут непонятно . то ли порядок равен 4 то ли 2. 
но у нас q это прайм. а прайм число не разбивается на какое то более мелкое число в какойто
степени вот как например 8 это 2^3  тоесть вот мы взяли посчитали что

  g^8 = e

а у нас еще ест делитель 2 . тогда может быт вот такой вариант

  (g^2)^3 = e

наша подгруппа с порядком 8 на самом деле может оказаться с порядком 2.
если же q прайм его никак не представить в виде какотого числа в какойто степени.

единственное что мне непонятно почему мы берем q значительно меньше чем p.
тоесть они говорят что такие размеры должен иметь p,q

    p=1024 bit
    q=160 bit


получается у нас основная группа размером 1024 бит.
а подгруппа g будет иметь размер всего 160бит. непонятно почему она должна быть такая
маленькая


теперь двигаем далее.

берется число k, оно  не прайм. и  k берется из диапазона  { 1...(q-1) } так сказано в википедии
далее вычисляется вот такое

    r=(g^k mod p) mod q

эта формула на самом деле означает вот такое

    r= мпв от ( (мпв от g^k mod p) mod q )

дальше я буду для сокращения тоже использовать ихнее обозначение но в голове будем
помнить что на самом деле оно значит.
рассмотрим значение этого выражения

далее поскольку g это элемент поля из элементов {1.. (p-1)  }
и порядок у этого элемента равен как мы выяснили равен q
так вот малек меня смущает что k согласно вики берется не из диапазона {1..q} а из диапазона 
{1..(q-1)}
ну окей берем мы  "к" из этого диапазона и это нам гарантирует то что элемент g^k mod p
будет без повторений. тоесть отображение взаимно однозначное. незнаю что это еще дает
итак формула   g^k mod p     нам генерирует элемент из поля {1.. (p-1)  }  тоесть
элементом    g^k mod p    навыхлопе будет любой элемент из диапазона {1.. (p-1)  }  
просто мы знаем что если бы я пробежал k из всего диапазона  {1.. (p-1)  } тоеcть если
бы "к" пробежал по всему диапазону  {1.. (p-1)  } то на выхлопе я бы получил кучу элементов
из диапазона {1.. (p-1)  } но это будет неполный диапазон а в штуках их будет q штук
если обозначить через   C=g^k mod p или вот так

    C= g^k в группе p

тоесть элемент C принадлежит группе p тоесть {1.. p-1 }

еще раз что дает то что элемент g имеет порядок q. это дает то что если мы будем прогонять
по всем k={1..q} то у нас элемент C всегода будет уникальный. тоесть если мы возьмем два 
любых k1 и k2 из диапазона {1..q}  то C1 и C2 всегда будут разные. поэтому между к и C
однозначное соотвесвтие

потом берется

    W = мпв C mod q

по мне это прикол. по факту как это работает. берем число C делим на q и берем остаток.
можно и с другой стороны зайти. берем множество вычетов

  .... C-2q, C-q   ,C, C+q, C+2q, ....

и в этом множестве находится тот элемент который лежит в диапазоне  0 < мпв < q
поэтому понятно что мпв лежит в диапазоне  0 < мпв < q

вобщем получается такая схема что формула

        (g^k mod p) mod q

она берет элемент g из группы p возводит в степень и получаем элемент из группы p
если по всем k=1..q пробежаться то в штуках таких элементов будет q штук. 
так получаем элемент из группы p
а потом переводим его в элемент из группы q. да получается прикол. в подгруппе g
у нас элементы лежат в p. но в штуках их q штук. и мы берем такой элемент и переводим
его в другую группу где элементов тоже q штук. но если в гурппе p она разбросаны
по этой группе. то в группе q они лежат в плотном диапазоне.
я щас приведу утрированный пример. пусть группа p состоит из 10 элементов.
и в ней наша подгруппа состоит из 3-ех элементов, скажем 2,5,8. их три штуки.
когда мы вторую операцию делаем то эти 2,5,8 проецируются в элементы 1,2,3.
тоесть первая часть операции

        С=(g^k mod p)

она нам "создает" подгруппу из трех элементов 2,5,8 которые разбросаны по группе из 10-ти 
элементов.  
на втором шаге

        C mod q

наши элементы переводятся  в группу где их тоже три элемента но они неразбросаны среди 
чисел 1-10 а они собраный в кучку 1-3
тоесть еще раз.
вот у нас есть исходная группа 

    p = {1 2 3 4 5 6 7 8 9 10}

в ней есть подгруппа которую создает элемент g через операцию 

    g^k mod p = {2 5 8}

в этой подгруппе количество  элементов q в данном случае q=3 

вторая операция переводит эти три элемента в три элемента но зато эти элементы
сидят попрорядку начиная с 1

    C mod q = {1 2 3}


тоесть двойная операция (g^k mod p) mod q мапит три разнобойных элемента из группы p
в группу элементов которые лежат по порядку { 1 2 3 }
тоесть еще раз есть множество { 1 2 3 4 5 6 7 8 9 10 } мы из него берем элементы { 2 5 8 }
и мы их маппим в { 1 2 3 }

щас покажу на живом примере. 

p=23  {1 .. 22}
q=11  

значит число q у нас задает какого размера подгруппу мы будем искать внутри 
исходной группы. значит подгруппа будет состоять из 11-ти штук.
для поиска подгруппы надо найти ее порождающий элемент.
ищем 

    g=h^( (p-1)/q ) != e

берем h=2

    g=h^( (p-1)/q ) = 2^(22/11)=2^2= 4 mod 23 = 4 != e 

значит порождающий элемент g=4
далее убедимся на практике что подгруппа реально состоит из 11-ти штук.
начинаем формировать подгруппу перемножая g на сам себя. почему так. потому что мы ищем 
циклическую подгруппу. да потому что мы в нашем исходной группе ищем не просто подгруппу 
из 11-ти элементов. но и чтобы эта подгруппы была циклическая. а это значит что все ее 
элементы являются степенями порорждающего элемента

 $ g=4; k=22; modulus=23; echo $g**0=1; for j in $(seq 1 $k); do   a=$((  ($g**$j) %  23 )) ; echo $g**$j=$a; [ $a -eq 1 ] && break ;   done; 
4**0=1
4**1=4
4**2=16
4**3=18
4**4=3
4**5=12
4**6=2
4**7=8
4**8=9
4**9=13
4**10=6
4**11=1

итак да. g=4 порождает множество из 11-ти элементов. 
тоесть

   g^k = { 1 2 3 4 6 8 9 12 13 16 18  }

k пробегает диапазон 0..10 получается 0..q-1
в вики они пишут что для DSA надо брать k=1..q-1
это нас приводит к тому что g^k будет без единичного элемента e

   g^k = { 2 3 4 6 8 9 12 13 16 18  }

получается мы ищем подгруппу из q элементов но по факту мы из нее используем q-1
элементов

на втором шаге мы переводим это множество (эти элементы) в элементы 0..q-1
показываю

 2 mod 11 = 2
 3 mod 11 = 3
 4 mod 11 = 4
 6 mod 11 = 6
 8 mod 11 = 8
 9 mod 11 = 9
 12 mod 11 = 1
 13 mod 11 = 2
 16 mod 11 = 5
 18 mod 11 = 7

итого

{ 1 2 3 4 5 6 7 8 9 }

получается достаточно забавно то что в итоге  у нас действиельно в итоге элементы
из g^k замапились в 1..9 и у нас было только два повторения

2 mod 11 = 2
13 mod 11 = 2

тоесть у нас q-1 исходных элементов замапилось в q-2 элементов. это достаточно прикольно
потому что у нас куча элементов могла мапиться на одни и теже мпв. тоесть у нас куча
элементов могла принадлежат одному множеству вычетов. как наприер элементы 2 и 13
ибо 2 и 13 они принадлежат одному множетсву вычетом при модулюсе 11

  2 ≡ 13 (mod 11)


вобще это интересный вопрос - вот у нас есть группа А основанная на прайме p. мы в ней
находим подгруппу B . понятно что в ней элеенты накиданы "рандомно". эта подгруппа B 
имеет порядок q. и мы берем и мапим эту подгруппу B в подгруппу  D с элементами {1..q-1}
реально интересно сколоько элементов из B будут лежать в одном множестве вычетом по модулюсу q

возьму еще один пример.
q=13
p=53

группа A = { 1 .. 52 }
ищем подгруппу размером q=13 элементов. для этого ищем порождающий элемент

    g = 2^(52/13) mod 27 = 16 mod 53 =16

ищем элементы подгруппы размером 13 штук с порождающим элементом g=16

$ g=16; k=13; modulus=53; echo $g**0=1; for j in $(seq 1 $k); do   a=$((  ($g**$j) %  $modulus )) ; echo $g**$j=$a; [ $a -eq 1 ] && break ;   done; 
16**0=1
16**1=16
16**2=44
16**3=15
16**4=28
16**5=24
16**6=13
16**7=49
16**8=42
16**9=36
16**10=46
16**11=47
16**12=10
16**13=1

<16> = { 1 10 13 15 16 24 28 36  42  44 46 47 49   }

поскольку сказано в вики что степень которая пробегает у порождающего элемента
пробегает не как положено 0..q-1 а 1..q-1  то множество B будет без 1

B = { 10 13 15 16 24 28 36  42  44 46 47 49   }

мапим это множество в множество mod 13

10 mod 13 = 10
13 mod 13 = 0
15 mod 13 = 2
16 mod 13 = 3
24 mod 13 = 9
28 mod 13 = 2
36 mod 13 = 12 
42 mod 13 = 3
44 mod 13 = 5
46 mod 13 = 7
47 mod 13 = 8 
49 mod 13 = 10

C = { 0 2 3 5 7 8 9 10 12  }

получили 9 элементов из 12 которые маппили

так вот получается очень стремная наверно вещь у нас из множества g^k элементы 15
и 28 в итоге мапятся в один и тот же элемент 2
получается несколко стремная вещь у нас получается есть два k таких что 

  (g^k mod p) mod q 

будет для них один и тот же. 
так как у нас исходное сообщение которое мы подписывыавем в конечном итоге кодируется 
числом к то получается что у нас может быть два сообщения одно из них кодирвется через к1
а второе через к2 но цифроую подпись (g^k mod p) mod q  они покажут одну и туже. вот 
что стремно. у нас получается странная вещь судя по вики длинну хеша подбирают равной q
если хеш длиннее то его обрезают до длинны q видимо потому что у нас g^k имеет 
размер q элементов тоесть в битах равно столько бит сколько бит число q.
соовественно если хеш тоже длинной как и q это нам дает прямое сооствевствие кажодго 
хеша и элемента g^k mod p но получается на втором шаге когда мы делаем mod q
это все нахрен  портится ибо у нас два элемента или даже несколько элементов из B могут
замаиться в один элемент из C получается одна цифровая подпись может соотвесвттовать некольким
исходным хешам. единсвтенное что может быт помогает бороться с этим это то что у них 
групаа А берется широкая 1024 бита скажем. а q берется относиельно него узкое скажем 160бит
соотшенеие ~ 6:1
у меня же 53 : 13 = 4 : 1 
ну я не знаю....

забавно что в вики q они назыавют модулюсом а p ключом. хотя по мне они оба модулюсы.
также прикольно то что у нас исходный хеш длинной ровно столько  бит сколько битов в числе q 
тоесть |H| = |q| в итоге мапится в некоторое число длинной |q| бит. почему. потому что 
у нас стоит 

   (g^k mod p)  mod q 

соответенно получаемое число (мпв) лежит в диапазоне 0..q-1 тоесть оно вкладывается в |q| бит
тоесть  я говорю у нас в ходе всей этой байды берется хеш который число длинной столько же
сколько длинны числа q и мапиттся в другое число такой же длинны

  |H| = | q  | ===>  | q | 


получается мы создаем группу длинной |p| бит. мы берем хеш длинной |q| бит.
подставляем его в k который |q| бит длинной. этот хеш тогда мапится в число длинной |p|
бит а потом это число мапиится в число |q| бит. вот так получается

далее вот еще какие мысли: если у нас есть группа. и внутри есть подгруппа то ровно какое 
правило для бинарной операции работает для группы ровно такоеже работает и для подгруппы. 
например групаа

   { 1, 2, 3, 4, 5, 6}

у нее правило умножения через модулюс 7
выделяем подргруппу через элемент 4

4^0 mod 7 = 1
4^1 mod 7 = 4
4^2 mod 7 = 2
4^3 mod 7 = 1

итак подгруппа  { 1 2 4 }
так вот в ней тоже работате правило умножени через модулюс 7. воще то это круто
и вобщето это необязательно должно было быть так

      1 2 4
     ======
  1 | 1 2 4
  2 | 2 4 1 
  4 | 4 1 2

как видно пользуясь умножением через модулюс 7 как у родителской группы мы видим что
при умножении двух элементов подгруппы получаем элемент этойже подгруппы то есть 
опреациия замнутая. во вторых что все строки истолбцы удовлетвовряют тредованием к 
умножению в группе. поэтому мы реально для подгруппы можем использовать умножение через
моделюс 7 как у родительской группы. было бы абсолютннл нормлаьно если при умножении через
правило умножения для 

если у нас есть циклическая группа котоорую порождает элемент g то в какую бы степент
мы его не возвели все равно то что оно породит будет лежать внутри этой группы. 

    g^k mod p 

к может быть сколько угодно большой. причем k это обычное десятичное число не являющееся
в целом элементом группы g^k это всего лишь условное обозначение для операции умножения

 g*g*g*g*g*g*g*g ,,,, *g 

мы такое уножмние УСЛОВНО обоначаем как g^k где k это десятичное число оборжначащее 
сколько раз нужно уножит элемент сам на себя. ксатати

g^(-k) это условное обзначение для g^-1 * g^-1 * g^-1 ...... 

тоесть это реально прикол что в формуле g^k у нас g  это элемент группы а вот k 
неимеет к элементам групы в целом никакого отношения. это просто индикатор выраженный
обычным число сколько раз элемент будет умножатся сам на себя. так вот я говорю что к
может быть сколько угодно большм все равно g^k будет принадлежать группе которую он 
порождает. единсвтенный момент в том что если порядок элемента g равен Q то как
то если k<Q то мы будем генеирировать уникальные элменты с кажым к. а если k>Q то у нас
элементы уже будут повторяться. тоесть если мы говорим что мы хотим ограничить к:

    0 < k < Q

то все g^k которые будут сгенпрированвы они все будут книукльные.
а если 

   0 < k < +inf 

то мы уже не гарантируем уикальность g^k будут повторы

если у нас  0 < k < Q и под к скажем мы будем подразумевать число которое мы хотим 
зашифровать то при таком диапазоне мы можем быть уверенв что что между

  k <----> g^k

есть однозначное соответаиие. 


а если вот так     0 < k < +inf   то имея некоторый C=g^k мы неможем однозначно сказать
какой к использоваться для получения С. потому что наш С можно сегенерировать через
несколлько разных к.

итак я рассмотрю ситцацию у нас ест хеш длинной |q| бит. я будут подставлять вот так

   k=хэш

тогда чтобы у нас быол однозначно соответсвие между хеш и g^k то нам нужна циклическая
группа размером |q|. как ее сгенеирировать.  обозначу для опрделелеенности размер
q не через биты а через число. пусть q=125 тоеть наши хэши они числа и лежат в диапазоне

   1..125

так вот нам нужна циклическая группа размером 125 элементов. как ее как можно проше
и быстрее построить. один вариант это если наше число 125 можно разложить в виде
prime^n но 125 так не разложишь.  скажем если бы имели 75 то это 5^3 тогда можно взять
поле F[5] и через многочлены построить поле F[5^3]  а потом в нем вычленить группу.
но это все огромный мудеж. гораздо проще вот как сделать. положим что 125+1 = prime^1
ну 125 не подходит но 126 подходит потому что 126+1=127 это прайм.так вот для N=127
очень просто построить поле. это элементы {0 .. 126} и математика на основе модулюса 127.
из такого поля лешгко вычленить группу {1 .. 126 } с математикой по пренжнему на основе 
модулюса 127. эта группа будет циклическая. но есть проблема как нам найти порождающий
эдемент с порядком 126. сразу скажу что это нужно тупо брать каждый элемент проверять
что 

   g^k != e  k<126
   g^k = e   k =126

поэтому тако способ нам не подходит. потому что вреальности нам нужны группы с очень
бльшим числом элементов. 

и тогда нам на помощь приходит тот метод который юзается в DSA. мы берем группу 
размером p такую что p+1 это прайм. 
также мы выбираем наш p так чтобы у него был делитель размера q и при этом q должен 
быть прайм. например пусть хэши варбируются 1-29 тоесть q=29 это прайм. тогда
число 29*2=58 это число жлементов в группе а 58+1=59 это прайм .
получаем у нас  вгруппе 58 элеметов. математика в группе на основе модулюса 59
число 29 является делителем 58 и также 29 это прайм. тогда в этой гурппе из 58 
элементов мы можем достаточно быстро и просто найти цликоическую подгруппу в которой
29 элементов. делатеся это вот так. мы берем любой элемент h нашей группы и 
проверяем что 

   h^(p/q) != e

например берем h=2

  2^(58/29) mod 59 = 4 mod 59 = 4 != e

тогда теорема говорит о том что элемент   4 является в этой группе порождающим 
подгруппу размером 29 элементов!

итак для 29 хешей мы быстро смогли соордудить циклическую подгруппу через котору 
мы можем однозначно шифровать эти хеши вот так

   С=4^k mod 59

где вместо к подставляем наш хеш который лежит в диапазоне  1..29
и мы для разных k будем получать разные C это нам гаатирует то что если мы взяли 
какойто C то его породил однозначный к. между ними однозначное соотвествие. тоесть
толко один к поорождает определенный С и определенный С порождает однозначным к

правда в DSA он юзают чуть более ложную форулу

   (g^k mod p) mod q

я считаю что mod q нахуй ненужен вообщето. могу только предположить зачем он нужен вот 
с такой точки зерния. у нас хеш или к по факту имеет длину |q|. например если q=1..29
то |q|=5 бит.  тоеть k  у нас имеет длинну 5 бит. но g^k будет иметь длинну |p|=|58|=6 бит
тоесть если сам хеш имеет длину 5 бит то зашифовнный хеш имеет длинну 6 бит потому что 
он шифретяс через элементы группы размером p. получатся у нас на входе скажем 5 бит хэш
а на выходе шифрованный хеш g^k уже 6бит. так вот если       g^k mod p  еще порезать по 
mod q 

       (g^k mod p) mod q

то на выходе у нас будет число длинной 5 бит. ровно столько сколько имеет оригинальный 
хеш. тоесть едсинвенная идея зачем два модулюса это для того чтобы на выходе мы имели
элемент такой же длиннной как и исходный хеш. а так на мой взглдяд сточки зрения
шифрования второй модулюс наухй не нежуен.

далее делаем вот что. я  беру j произвольно из диапазона 1..q
и высияляю вот такую хрень

у нас  H  хэш  имеет длинную |q| я вычисляю

C1 = (g^H) mod p

так как H лежит в диапазоне |q| то элемент связь между H и C1 она однозначная. тоест
С1 мог породить только один какойто H. два разных H немогу породить один C1
C1 у нас принадлежит конечно же нашей подгруппе. 

далее я вябираю j такой что он лежит в диапазоне |q| и делаю вот так

 C2= (C1)^j (mod p) = (g^H)^j  (mod p) = g^(H*j)  (mod p)

здесь  я уже вижу что для C2 нарушается принцип того что у нас при заданном C2 аргумент
H*j задан однзначно. это не так. при заданном Н если мы возьем  j=1..q то у нас есть
несклько j при которым g^(H*j) бдует один и тотже
щас покажу
пусть N=58 (число элементов в групе), модулюс p=59
q=29
g=4
пусть H=28
хотя на практике почемуто не повторяется

$ cat py.py 
#! /usr/bin/python

for x in range(1,29,1):
  print((4**(28*x)) % 59  )

$ ./py.py  | sort
12
15
16
17
19
20
21
22
25
26
27
28
29
3
35
36
4
41
45
46
48
49
5
51
53
57
7
9

непонятно. почетмуто g^(H*j)
где H,j принадлежат 1..q-1  порождают уникальные элементы

скажем у меня q=29 элементов в подгруппе. чтобы элемент повтоился надо чтобы 
H*j стал равен k*29 = 2*29, 3*29 итд. значит j у нас пробегает 1..28 тоесть уже не 29.
и вроде как полчается что H*j никогда не будет иметь комбинацию 2*29, 3*29
ну хорошо. но зато точно понятно что будет совреенно одинакоый C2


C2= g^(H*j)  (mod p)

вот в таком случае

H1=1 j1=10
H2=10 j2=1

получсется если мы имеем C2 то это якобы однозначно задает (H*j) но можно подобрать пару

H1=1 j1=10
H2=10 j2=1

что C2 будет у них один и тотже. тоесть в итоге между C2 и H нет однозначного 
соотсвтеиея.

так вот я высчитываю C2 и публикую его


    C2

и я публикую j , чтобы человек мог взять H и j подставиь k=(H*j) 
в

  g^k mod p 

и тоже получить C2

а что это нам в итоге дает? пока не очень понятно. 

в вики педии указано что в кончном итоге

(g^k mod p) mod q = ( (g^u1)* (y^u2) mod p ) mod q
так вот что мешает злодею сделать слещудщее. он берет публиный мой ключ y
дальше рандомно приудмывывает числа u1, u2 подставляет


( (g^u1)* (y^u2) mod p ) mod q 

получает некоторое число C1

так вот злодей далее сообщает мне этот C1


u1= H*w mod q

здесь злодей спокойно подставляет вместо w чтото что он придумал

u2 = r * w (mod q)



как технически счиать DSA я понял. но почему он так выглядит мне походу не понять
я думаю я буду сворачивать эту тему нахуй




#####################
#####################
#####################


===============
ВОПРОСЫ:
!!! как работает DSA  я нихрена не понял
!!! TLS vs SSH
!!!! надо исправить по тексту то как я неправиьльно понял теорему о поиске подгруппы размером 
     с прайм
???? разобраться как образуется поле из вычетов Z/p



ССЫЛКИ:
https://security.stackexchange.com/questions/50878/ecdsa-vs-ecdh-vs-ed25519-vs-curve25519
https://crypto.stackexchange.com/questions/27593/hashing-a-diffie-hellman-result
https://datatracker.ietf.org/doc/html/rfc3526#page-3
https://crypto.stackexchange.com/questions/90373/what-is-the-role-of-sha-1-on-diffie-hellman-group1-sha1
https://datatracker.ietf.org/doc/html/rfc3526#page-6
https://datatracker.ietf.org/doc/html/rfc4253#page-23
https://www.ietf.org/rfc/rfc4419.txt
https://datatracker.ietf.org/doc/html/rfc3526#page-3
https://www.datai.net/article/ipsec-diffie-hellman-groups/
https://docs.ssh.com/manuals/server-admin/66/csc-algorithms-kexs.html
https://www.cyberciti.biz/faq/openssl-get-common-name-cn-from-ssl-certificate-on-linux-unix/
https://qna.habr.com/q/1221696





