| bash
| coproc
| redirect
| read
| while

здесь я рассмотрю такие билтины как "coproc" и "read" "while"



но 
для начла я хочу поговорить про bash redirect
потому что он пригодится


для начала вот он оператор редиректа. или директива редиректа

	>


и тут кроется дохуя особенностей и ебанизмов

вот я напишу вот так

  $ echo "1" > vasya


тогда у меня баш когда он создаст новый процесс под echo он привяжет fd/1 этого процесса
к файлу vasya. таким маккаром то что высрет echo на stdout то будет записано в файл vasya

но дальше начинается ад с ПРОБЕЛАМИ

 $ echo -n "1"> vasya
 $ echo -n "1" >vasya
 $ echo -n "1">vasya

пока что все окей. по прежнему вывод echo будет падать в файл vasya
далее

 $ echo -n kuku> vasya
 $ echo -n kuku >vasya
 $ echo -n kuku>vasya

пока тоже все окей

 echo -n 1 > vasya
 echo -n 1 >vasya

пока все окей

 $ echo -n 1> vasya
 $ echo -n 1>vasya

и вот в этих обоих случаях уже пизда , потому что у нас файл будет создан 
но он будет пустой. в нем "1" не будет. почему? а потому что -
дело в том что диркетива 

    > 

это на самом деле сокращенная форма от 
директивы в полной форме 

    1>

поэтму наши две строки если их привести к сокращенной форме дирктивы то наши 
две стороки превращаются

 $ echo -n > vasya
 $ echo -n >vasya

поэтому мы видим что у нас echo запускается без аргументов которые нужно напечатать.
тоесть echo посути пустой. поэтому в файл vasya ничего  и не летит!

итак директива  > это не аргумент нового процесса это директива для баша чтото сделать ПЕРЕД
ТЕМ КАК ЗАПУСТИТЬ НОВЫЙ ПРОЦЕСС. тоесть чтото нужно сделать до запуска execve()
так вот директива  >  это сокращенная форма  от полной формы директивы  1>
и я считаю что зря они сделали сокращенную форму. потому что это охенно путает. есть 
есть и более общая форма этой директивы

    N>


прикол в том что эта хрень она составляет единую хрень. она неразделимая. если мы напишем 

  N > 

это совершенно другое. это вот такое

  N 1>

тоесть N это будет аргумент для вызываемой программы.  а наша директива  это 1>
так вот N это номер дескриптора fd/N  и директива N> сообщает башу что он должен при создании
нового процесса прикрепить к дескриптору fd/N файл который будет указан справа
например 

  5> vasya

это означает что  в новом процесса дескриптор fd/5 нужно прикрепить к файлу vasya на фс в текущем
каталоге. тоесть мы требуем чтобы в новом процессе дескриптор 5 вел на файл vasya
итак
 
  echo 1> vasya  

тут 1 входит в состав директивы 1>   
я бы даже сказал что тело директивы сотавлвяет 

    1> vasya

таким образом  у echo нет ни одного аргумента. и поэтому echo высрет ничего. и поэтому 
файл vasya будет пустой.

а если вот так

   echo 1 > vasya 

то это на самом деле это вот так

   echo 1 1> vasya 

и здесь первая единица это аргумент для эхо.  а вторая невидимая единица это часть директивы.
и здесь эхо высрет 1 и запишет его в файл vasya

тоесть еще более полное тело директивы вот такое вот 

     N> /path/to/file

между N и > неможет быть ни одно пробела. это супер важно.
наличие пробела сразу означает совершенно другое

     N > /path/to/file
это на самом деле значит

     N 1> /path/to/file

где тело директивы это вот это   1> /path/to/file
а N это уже аргумент при запуске команды. оно к телу директивы неимеет отношения.
при этом насколко я понимаю полная форма директивы имеет две возмжные формы


     N> /path/to/file
     N>/path/to/file

тоесть наличие пробела справа от галочки неимеет уже занчения. что тоже дебиьльно.


но это еще не конец ада. справа у нас по своей форме нужно ставить путь к файлу на фс.
но вместо этого можно вставить номер другого дескриптора этого нового процесса. а чтобы башу
четко понимать что стоит справа путь к файлу на фс или номер дескриптора то добавляет амперсанд


     N>&P

где P это номер дескриптора fd/P. 
это не значит что один дескриптор будет вести на другой дескиптор. нет.
это значит что дескриптор P будет вести на тот же файл на который ведет дескриптор N
причем ОБЯЗАТЕЛЬНО СПРАВА УЖЕ ТОЖЕ НЕЛЬЗЯ ПРОБЕЛ.


  15> &2 \\тоесть вот так будет ошибка

потому что если справа поставили пробел то это уже обязан быть имя файла на фс. уже это неможет
быть дескриптор! поэтому вобще нахуй они разрешили пробел для пути к файлу. надо чтобы было
чтобы справа по любому нельзя было использовать пробел никогда

причем еще дебилизм вот так вот 

  15> &2 

он откзвыатся это принимать что справа стоит дескриптор 2 но и также он откзывается считать что
справа чтоит имя файла "&2"   . дебил.
он тупо выдает ошибку и все.
если я хочу спавра поставит имя файла &2 то надо делать вот так

  15> "&2"

ПОЭТОМУ СУММАРНО я бы сказал что вот такая форма у директивы
	если мы хотим писать в файл на фс то 
   		N> /path/to/file
   		N>/path/to/file

	если мы хотим направить на другой дескриптоор то 
   		N>&P


где N,P это числа обозначающие номер дескриптора.

если перед галочкой нет никакого числа то это такой дебилное сокраешение от 1>
тоесть
  
    test > vasya

это на самом деле

    test 1>vasya


поэтому каждый лишний пробел может доставить чудовищные проблемы в понимании.

поэтому теперь проокоментирую живые примеры


	$ echo 2>&1
	$ echo 2> &1
	$ echo 2 > vasya
	$ echo 2> vasya

первый пример. здесь соблюдена полная форма N>&P 
при этом у нас для echo неостается аргументов. поэтому эхо у нас запускается с нулем
аргументов. а в процессе дескриптор 2 смотрит на тот же файл на который смотоит дескриптор 1

второй пример. будет ошибка. раз у нас после галочки спрва стоит пробел значит там
обязатено должно стоять путь к файлу на фс. а мы там пыатается вставить номер другого 
дескриптоора. но если мы хотим там вставить номер дескриптора то пробел справа от галочки
запрешен.  в общем в итоге будет тупо сообщеие об ошибке.

третья комнда это сокрашеная форма директивы от  echo 2 1> vasya
таким образом 2 это аргумент у эхо. а сама директива это  1> vasya
что значит что дескриптор 1 будет смотреть на файл vasya
в итоге в файл vasya будет записано число 2

четвертый пример это коректная полная форма. у нас дескриптор 2 будет смотреть на файл vasya.
а эхо запускается без аргументов. так как 2 это канал вывода ошибок а ошибок не будет то в итоге
в vasya не будет записано ничего.


вот такая мегабала на пустом месте в баше.


ТЕПЕРЬ перехожу к билтин coproc
в мане какойото некоректное описание которое неработает. 
начнем с более простого случая


$ coproc acpi_listen
[1] 2617211

$ pstree -Aspt 2617211
systemd(1)---systemd(1181)---gnome-terminal-(1970)---bash(2617163)---acpi_listen(2617211)

$ echo $$
2617163


значит что мы видим. текущий номер процесса баша это 2617163
строчка [1] 2617211 означает что наш баш создал дочерний процесс 2617211 и засунул его 
в background process group. и что с точки зрения нашего баша это типа так назывемый job который
имеет номер 1. 
на дереве процессов тоже все видно.
видно что был запущен бинарник acpi_listen в дочернем процессе.
спрашивается а чем это все отличается от запуска процесса в бекграунд режиме через 

  $ acpi_listen&

а вот чем 
так вот еще создается две пары  пайпов. один пайп прикрепляется к fd/0 нового процесса 
а второй его конец остается в нашем баше. второй пайп прикрелпется к fd/1 нового процесса
а второй конец остатется в нашем процесе. и номера этих пайпов в нашем процессе записываются
в массив с именем COPROC тоесть их можно посмтреть через ${COPROC[0]}  и ${COPROC[1]}
кстати опят же сделано дебильно. в ${COPROC[1]} записывается номер пайпа который ведет в fd/1
в новом процессе. (хотя было бы логичено чтобы это был конец который ведет в fd/0)
теперь мы можем читаь и писать в этот новый процесс используя дескрипторы в нашем процессе.
показываю

  $ lsof -Pnp $$
COMMAND     PID   USER  FD   TYPE DEVICE SIZE/OFF      NODE NAME
...
bash    2617163 noroot txt    REG  254,0  1116976 805306515 /usr/bin/bash
bash    2617163 noroot  60w  FIFO   0,15      0t0  14776676 pipe
bash    2617163 noroot  63r  FIFO   0,15      0t0  14776675 pipe

 $ lsof -Pnp 2617211
COMMAND       PID   USER  FD   TYPE             DEVICE SIZE/OFF      NODE NAME
...
acpi_list 2617211 noroot txt    REG              254,0    14664 805308201 /usr/bin/acpi_listen
acpi_list 2617211 noroot   0r  FIFO               0,15      0t0  14776676 pipe
acpi_list 2617211 noroot   1w  FIFO               0,15      0t0  14776675 pipe


тоесть в процессе с acpi_listen егоные fd/0 и fd/1 через пайпы прокинуты в мой баш процесс
на дескрипторы 60 и 63

щас мы убедимся  в этом. 


  $ echo ${COPROC[0]}
63
  $ echo ${COPROC[1]}
60


причем исходя из NODE мы четко видим что перменная ${COPROC[0]} в себе хранит тот номер
дескритора в нашем баше который ведет на fd/1 в том процессе. а ведь хотелось бы чтобы
он вел на fd/0

это нам дает то что мы можем через дескриптор fd/63 в нашем баше прочитать все то что 
высрал на свой STDOUT процесс acpi_listen 
мы через coproc билтин создали процесс и запроксировали его stdin и stdout на свои 
пайпы.
итак я хочу через свои пайпы(пайпы в нашем процессе  ) хочу прочитать все то что пишет 
acpi_listen на свой stdout. будем читать из пайпов через cat

$ cat 0<&${COPROC[0]}
cd/prev CDPREV 00000080 00000000 K
cd/next CDNEXT 00000080 00000000 K
cd/prev CDPREV 00000080 00000000 K
cd/prev CDPREV 00000080 00000000 K


рассмотрим эту констркцию 

   0<&${COPROC[0]}

это у нас как раз таки директива редиректа в полной форме как  я описывал выше. 
0 указывает что в новом процессе (который cat) я хочу чтобы fd/0 указываел 
на тот же файл котрый указан справа от галочки
справа от галочки стоит &${COPROC[0]}
мы видим & это значит что справа от галочки стоит не путь к файлу а номер дескриптора нового  процесса. значит вот это ${COPROC[0]} это должно быть число , которое обозначает номер 
дескриптора который открыт у нового  процесса. так как новый процесс создаетс путем 
клонирования из текущего то наши пайпы они перейдут на cat процесс. в итоге 
после подстановк мы получаем форумулу

  0<63

это значит что у процесса cat у него дескриптор 0 будет смотреть на тот же файл на который
смотрит его дескриптор 63. тоесть STDIN у cat будет смотреть на тот же пайп на который
смотрит едскриптор 63. поэтому наш cat он читает из пайпа который своим вторым концом 
направлен на stdout процесса acpi_listen


поэтому мы на экране и видим вывод acpi_lsiten

$ cat 0<&${COPROC[0]}
cd/prev CDPREV 00000080 00000000 K
cd/next CDNEXT 00000080 00000000 K
cd/prev CDPREV 00000080 00000000 K
cd/prev CDPREV 00000080 00000000 K

если вставлю пробел 

 $ cat 0< &${COPROC[0]}

то я получу мгнвоенно ошику. ибо это нарушение синтаксиса директивы. 
если я вставлю пробел слева от галочки

	$ cat 0 <&${COPROC[0]}

то это тоже наоушение синстаксмса директивы

так что coproc это что то типа того как рабоатет ssh который запускает другой процесс
и его проксирует на себя правда там несколько по другому не бууду углубляться

получается можно запустьи каку то команду в заднем режиме  в этом терминале но она 
не будет мешать своим вывод нашему башу. а потом можно к ней подключаться когда удобно
и проверять какой там статус например.  запускаем journalctl -f  и он там висит и 
показывает нам логи журнала. а мы периодически пдключаимся и смотрим есть ли чтото новенькое

  $ coproc journalctl -f
[1] 2619214

  $ cat 0<&${COPROC[0]}
янв 13 11:15:22 lenovo rtkit-daemon[1670]: Supervising 11 threads of 8 processes of 1 users.
янв 13 11:16:08 lenovo systemd[1181]: Started VTE child process 2618679 launched by org.gnome.Terminal process 1970.
янв 13 11:17:36 lenovo root[2618876]: ACPI group/action undefined: cd/prev / CDPREV

к сожалению нет удобной команды как остановит процесс раоботающий в бекграунд 
режиме. 

для баша этот процесс являетс в том числе и джобом. поэтому можно посмтреть какой щас
список дджобов

	$ jobs -p
	2619214

и тогда оставнить процесс можно вот так

	$ kill $(jobs -p)
[1]+  Terminated              coproc journalctl -f


единсвтенное что через coproc можно запустиь только те процессы которые не требуют 
в своей работе терминала. например top его требует. 

 $ coproc top
[1] 2619456
  top: failed tty get

поэтому процесс незапуститься

как видно выше названия дескрипорров хранться в массиве COPROC

а что если два раза запустить coproc ?

  $ coproc cat
  $ coproc journalctl -f

то у нас же два дочерних процесса а массив по сохранению дескрипторов один. 
даже не хочу разбираться. дело в том что есть вариант такой что при запуске corpoc
можно указать в какую перменную класть номера дескриптороов. в ман написано вот так

   coproc [NAME] command [redirections]

 тоесть якобы

   $ coproc VASYA  cat

и тогда дескрипторы буудут сохранены в VASYA[0] и VASYA[1]
но к сожалению в ман баш написана хуйня. так не сработает!

$ coproc VASYA cat
[1] 2619989
bash: line 34: VASYA: command not found
[1]+  Exit 127                coproc VASYA cat

там мудрено все запутано. в итоге чтобы все сработало надо запускать команду вот в таком
виде

  coproc NAME { command [redirections]; }

я так и непонял скобочки это такая дирктива баша как субшелл или это не имеет отношения
к субшеллу а просто часть дебилного синтасиса билтина coproc
но в итоге работает оно вот так

$ coproc VASYA { acpi_listen;  }
[1] 2620623

посмотрим
 ὘  $ echo $$
2618679

  $ pstree -Aspt $$
systemd(1)---systemd(1181)---gnome-terminal-(1970)---bash(2618679)-+-bash(2620623)---acpi_listen(2620624)

таким образом при таком синтаксисе у нас баш себя клонирует. а потом еще раз клонирует
и только там запускает нужную команду

проверяем что массив VASYA содержит номера дескрипторов

$ echo ${VASYA[0]}
63
 $ echo ${VASYA[1]}
60


проверяю что все раобтает
 $ cat 0<&${VASYA[0]}
cd/prev CDPREV 00000080 00000000 K
cd/next CDNEXT 00000080 00000000 K




теперь что касается билтина READ
есть дока в man bash поэтому билтину.
там у него есть всякие флаги

простой режим
  $ read a b c 
1 2 3


  $ echo $a 
1
 $ echo $b
2
  $ echo $c
3


он читает с терминала данные и сует их в те перменные которые мы в нем указали

можно запиывать данные сразу в массив. масив можно обьяить или он сам его создаст.

	$ declare klava
 	$ read -a klava
1 2 3 4 34 34 34 34 34  6456  657 56 56 567 56 56 56 56   <=== это  я вводил с клавы

теперь у меня все эти числа лежит в массиве

$ echo ${klava[@]}
1 2 3 4 34 34 34 34 34 6456 657 56 56 567 56 56 56 56

это гораздо удобнее с клавы сохрнаять данные не  в отельные перменные а в массив

на счет что такое массивы в баше и как с ними работать обязатеьно прочти "bash-array.txt"
потому что там есть тоже своя ебала с их пониманием

вобще у read куча флагов
 read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]

я так и непонял а можно ли набить массив значениями не с клавы терминала а указав имя файла,
но он точно умеет читать из дескриптора. это ключ -u fd

поэтму можно например сеодинить coproc и read

 	$ coproc journalctl -f
	[1] 2621824

	$ declare klava
 	$ read -a klava -u ${COPROC[0]}

 	$ echo ${klava[@]}
янв 13 11:53:40 lenovo systemd[1]: Starting Network Manager Script Dispatcher Service...

	$ echo ${klava[0]}
	янв
 
 	$ echo ${klava[1]}
	13
 
 
значит read он считыет данные до момента пока не увидит в потоке байтов знак новой строки
тоест Enter или чтото типатого. тоесть он раотает только в пределах одной строки в потоке
байтов.

а если  я хочу работать с несклолькими строками? тогда надо read вызывать несколько раз
каждый раз он будет обрабатывать одну строку
тоесть

 	$ read -a klava -u ${COPROC[0]}
 	$ read -a klava -u ${COPROC[0]}
 	$ read -a klava -u ${COPROC[0]}

теперь вопрос а какой код возврата из этой фнкции или билтина

$ read a b c ; echo $?
1 2 3
0
 $ read a b c ; echo $?  ( тут я нажал Ctrl+D)
1

вобщем типа если read хоть чтото считал то он возврщает 0 ( тоестьОК)
а если он ничего не считал то он возвраащает 1 (тоесть ERROR)

это поможет при понимании while.
как работает while
вот ее синтаксис

	 while list-1; do list-2; done

она запускает команду list-1 и проверет у нее код возврата. если он 0 то запусекается
тело цикла.

возвраащаетмся к read ,   если я его вставлю в while


	 while read -a klava -u ${COPROC[0]}; do list-2; done

то он будет выполнться до тех пор пока у нас read не получит сигнал об окончании файла (Ctrl+D)
а значит строчек больше нет. тоггда он вернет 1 и цикл остановится.

вот тогда вот такой в итоге полный текст


 	$ coproc journalctl -f
	$ declare klava
	$ while read -a klava -u ${COPROC[0]}; do  echo ${klava[@]} ; done

на экране увидим вот такое
янв 13 12:02:55 lenovo systemd[1181]: vte-spawn-2672570d-3633-4612-8753-a58efac9853f.scope: Consumed 3.218s CPU time, 17.1M memory peak.
янв 13 12:02:55 lenovo root[2622119]: ACPI group/action undefined: cd/prev / CDPREV
янв 13 12:02:55 lenovo acpid[2493223]: client 2620624[1000:1000] has disconnected
янв 13 12:02:56 lenovo root[2622121]: ACPI group/action undefined: cd/prev / CDPREV


можно вместо echo ${klava[@]} вставить какойто скрипт орбрабтки типа
   
   script.sh  ${klava[@]}

либо 

   script.sh  "${klava[@]}"


в чем разница первого от второго. я об этом пишу в файле посвященном массивам "bash-array.txt"
о том что формулировка "${klava[@]}" ее нужно трактовать  чисто как исклчение из правил.
и вот что получаем. прежде чем баш запустит скрипт он конструкцию справа должен заменить 
на готовые значения. так вот он заменит  херь  ${klava[@]}  на ряд из всех значений эттго
массива. покажу напримере попроше . пусть у нас вот такой масив

		$ klava=("1 2" "1 3" "1 4")

тогда он заменит первую строчку на 


	  script.sh  1 2 1 3 1 4

и скрипт будет запущен с 6-ю перменными.

а во второй строчке повтрорюсь вот эта хрень "${klava[@]}" ее расшифровка неимеет логики
это просто надо запомнить как ичклюение. так вот  эта хрень будет заменена на 


	script.sh   "1 2" "1 3" "1 4"

и тогда скрипт будет запущен с тремя параметрами


тоесть вот эта хрень ${klava[@]} бертся в скобки "${klava[@]}"только тогда когда 
мы хотим чтобы баш при наличии пробелов в элментах массива чтобы он условно говоря 
при замене этой хрени на элементы массива он выставил дополнетльные скобки чтобы у нас 
элементы массива оригинальные не распались на бОльшее число элементов за счет пробелов.
щас обьясню

вот у нас есть массив
		$ klava=("1 2" "1 3" "1 4")

если я пишу 

    echo ${klava[@]}

то преде запуском эхо баш замнеит эту хрень на конетенте массива вот в таком виде

  echo 1 2 1 3 1 4

ну формально он прав потому что кавычек в элемнтах массива на самом дееле нет. 
кавычки klava=("1 2" "1 3" "1 4") это мы просто когда заностили эти элементы в массив то 
кавычки это дирекива башу чтобы ему обьяснить границы элментов. в самих элементах кавычек нет.
так вот если я хочу чтобы баш добавил эти кавычки каждому элементу то я юзаю  "${klava[@]}"

тогда если  я пишу

   echo "${klava[@]}"

то баш при замене ${klava[@]} он выдаст на экран элементы этго массива и также он к каждому 
элементу присобачит слева и справа кавычки! хотя их внутри элементов нет

   echo "1 2" "3 4" "5 6"

а зачем нам кавычки? потому что далее баш опять анализирует строку и эти кавычки являются
для него директивой о том что то что внутри кавычек это единая логическая хрень и пэтому он 
коода будет execve запускать то он массив argv составит из трех элементов. таким образом
у нас массив аругментов будет состояи из трех элеметов ровно точно равных элеметам из исходогог
массива klava.  потому что если мы кавычки убрем то мы получим

  echo 1 2 1 3 1 4

и здесь при вызоыве execve у нас баш составить argv массив из 6-и аргументов. 

таким образом в чем разница вот этой строки

	$ while read -a klava -u ${COPROC[0]}; do  script.sh ${klava[@]} ; done

и вот этой строки

	$ while read -a klava -u ${COPROC[0]}; do  script.sh "${klava[@]}" ; done


в первом случае у нас когда баш будет менять ${klava[@]} на строку из значений элементов
массива то он их подсавить как они есть.
а в этом случае "${klava[@]}" он вокруг каждого элемнта массива еще присобачит кавычки
а это значит что если элемент массива содержит пробел или пробелы то во втором случае 
это не приведет к тому что у нас как бы число элемнтов массива увечлитится. оно останется прежним
а вот в первом случае это приведет к тому что исходное число аргументов массива распадется
на большее число элементов.

ну  я дам пример 
пусть  klava=("file 1" "file 2")

тогда если у меня внутри тело while будет стоять 

   cat ${klava[@]}

то баш подставит значения в точности как они есть и мы получим

   cat file 1 file 2

теперь баш еще раз парсить строку и формально вней он видит 4 аргуметов.
поэтому далее баш будет вызыват execve и он туда в массив argv вставит 4 аргуметов
поэтому у нас cat будет пытаться прочитать 4 файла с именами file, 1, file ,2
что для нас непримемиломо

а если я напишу вот так

   cat "${klava[@]}"

то баш при подставновке элементов массива окружит каждый элемент еще насильно в кавычки

   cat "file 1" file 2


теперь баш еще раз парсит строку и видит  в ней 2 аргумента. поэтому он вызывоае execve 
и в него вставит 2 аргумента. и поэтому наш cat будет пытатся прочесть два файла
оди имеет имя "file 1" ну или вот так file\ 1 и второе имя файла "file 2"

тоест это имеет кооласальную разницу и силу.


ест такая еще билтин как trap

$ trap 'echo "я поймал Ctrl+C"' SIGINT

что он делает. он ждет сигнал SIGINT и если он поступает в процесс то он выполняет команду
которая указан в кавычках
если мы терминале такое напишем то при каждом нажатии на ctrl+С у нас на экране будет выкаквать

я поймал Ctrl+C

я поймал Ctrl+C

есть и осбые хрени и с этим билтином. напириме можно вместо сигнал указать EXIT это 
означает событие что скрипт завершил работу.



теперь как апофеоз рассмотрим вот этот скрипт

	#!/bin/bash
	coproc acpi_listen	
	trap 'kill $COPROC_PID' EXIT

	while read -u "${COPROC[0]}" -a event; do
    	handler.sh "${event[@]}"
	done


как он падла работает
вначале через coproc мы запускаем на бекграунден  acpi_listen	 
и получаем запроксированым через пайпы его stdin и stdout на дескрипторы в нашем прцесе.
при этом pid этого процесса хранится в перменной $COPROC_PID
в перенной ${COPROC[0]} хранится дескриптор в нашем процесе который ведет на STDOUT процесса
acpi_listen	 , в перенной ${COPROC[1]} хранится дескриптор в нашем процесе который ведет на STDIN процесса acpi_listen

устаналиваем trap чтобы при завершении скрипта он завершил процесс  acpi_listen
чтобы кога мы скрипт завершили чтобы у нас этот бекгруанд процесс не остался висяшим и работающим

далее я читаю то что выввалиывается на STDOUT в рамках одной строки от acpi_listen в массив event
и я подсталвяют этот массив event в качестве набора аргументов при вызывае скрипта handler.sh
при этом кавычки "${event[@]}" дают то что баш при вызове скрипта сохранит в точности то 
число аргументов равным числу эелменто в массиве. тоесть если внутри элемента в массиве есть
пробел то это никак не повляет на аргумент. не будет разбиания элемпнтов массива на более
мелкие аргументы при вызове скрипта. 
и все  я это делаю в цикле while таким образом  я обабываю нетолько одну строку в выводе STDOUT от
acpi_listen а обрабатваю все строки.

воттакой ппздецовый мелкий скрипт но требующий охуенный знаний чтобы понять что и как в нем
и почему работает!!!!

