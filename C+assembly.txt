
C - programming language
=============================

обьявление переменных
int vasya

это обьявляет переменную vasya типа integer

далее можно присвоить знаение
vasya = 15

можно сразу сделать два дела и обьвявить перееменную и присвоить ей значение
int vasya = 15

int = это целоый тип
float = это с точкой
char = это литеры ascii я так понял





====

| thread


если программа создает треды 
то нужно дать доп ключ комплиятору иначе он пошлет нахер

    $ gcc -pthread -o 3.exe  3.c
    
    
    
    
пример прогарммы с тредами

]$ cat thread.
cat: thread.: No such file or directory
[vasya@lenovo C]$ cat thread.c
#include<stdio.h>
#include<string.h>
#include<pthread.h>
#include<stdlib.h>
#include<unistd.h>

pthread_t tid[2];

void* doSomeThing(void *arg)
{
    unsigned long i = 0;
    pthread_t id = pthread_self();

    if(pthread_equal(id,tid[0]))
    {

        printf("\n First thread processing\n");

     while (1) {

     __asm__("NOP");

    }


    }
    else
    {
        printf("\n Second thread processing\n");

      while(1) {
     __asm__("NOP");
     }


    }

while (1) {

     __asm__("NOP");


}




}

int main(void)
{
    int i = 0;
    int err;

    while(i < 2)
    {
        err = pthread_create(&(tid[i]), NULL, &doSomeThing, NULL);
        if (err != 0)
            printf("\ncan't create thread :[%s]", strerror(err));
        else
            printf("\n Thread created successfully\n");

        i++;
    }

    sleep(5);


while (1) {

     __asm__("NOP");


}



    return 0;
}


замечу что vmstat покывает статистку для тредов сразу! а не для процессов.
чтобы ps показал треды нужно 

ps -L


далее

/proc/loadavg покаывает статтику не для процессов а для тредов!

так что надо всегда смотреьттт статисткиу для треодов а не процессов



возникает вопрос 
вот мы послали мультитрдоовой программе сигнал скажем SIGTERM а дело в
том что сигнал программой kill посылается не процессу! (процесс это группа тредов.
шедулер на цпу сует не код процесса а код треда). так вот pid в команде kill $pid он
задает не имя процесссса (группы тредов) а он задает номер треда!!!!
и сигнал летит к треду! просто если у нас процес состоит из одного треда 
то  у него номер треда совпадает с номеро процесса и мы думаем что послали сигнал
по номеру процеса а мы послали сигнал по номеру треда! просто номер треда и номер
процесса в данном случае совпадают! 
так вот сигнал летит к треду!
и возникает желаение закончить тред но не заканчивать оостальные треды процесса!
как это сделать? дело в том что если выполнять exit(0) то убьет все треды 
а мы хотим закончить только тред в который прилетел этот сигнал. 
и тогда на помощь приходит 

    pthread_exit(0);


а вот пример программы целиком


#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/mman.h>
#include <stdlib.h>
#include <sys/prctl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <sys/syscall.h>



void *threadfn1(void *p)
{
    printf("Thread ID: %ld, pid=%i\n", syscall(SYS_gettid), getpid());
    while(1){
    //printf("thread1\n");
    sleep(2);
    }
    return 0;
}

void *threadfn2(void *p)
{
     printf("Thread ID: %ld, pid=%i\n", syscall(SYS_gettid), getpid());
    while(1){
    //printf("thread2\n");
    sleep(2);
    }
    return 0;
}

void *threadfn3(void *p)
{
    printf("Thread ID: %ld, pid=%i\n", syscall(SYS_gettid), getpid());
    while(1){
    //printf("thread3\n");
    sleep(2);
    }
    return 0;
}


void handler(int signo, siginfo_t *info, void *extra) 
{
        // int i;
    //puts("signal");
    //sleep(2);
       printf("\n============\nThread ID: %ld, pid=%i\n===============\n", syscall(SYS_gettid), getpid());
       pthread_exit(0);
}

void set_sig_handler(void)
{
        struct sigaction action;


        action.sa_flags = SA_SIGINFO; 
        action.sa_sigaction = handler;

        if (sigaction(SIGTERM, &action, NULL) == -1) { 
            perror("sigusr: sigaction");
            _exit(1);
        }

}

int main()
{
    printf("Thread ID (main thread): %ld, pid=%i\n", syscall(SYS_gettid), getpid());
    pthread_t t1,t2,t3;
    set_sig_handler();

    pthread_create(&t1,NULL,threadfn1,NULL);
    pthread_create(&t2,NULL,threadfn2,NULL);
    pthread_create(&t3,NULL,threadfn3,NULL);
    for(;;)    
      sleep(1);
    //pthread_exit(NULL);
    return 0;
}





она всего навсего запускает несклоько тредов. и если мы шлем треду
SIGTERM то этот тред прекращает свое существование.
и на экране будет написано в какой тред прилетел сигнал

вот как выглдяит на экране

$ gcc -pthread -o thread3.exe  thread3.c

$ ./thread3.exe 
Thread ID (main thread): 23591, pid=23591
Thread ID: 23592, pid=23591
Thread ID: 23593, pid=23591
Thread ID: 23594, pid=23591

если у этой проги сменить SIGTERM на SIGINT запустить ее и тыкнуть то мы увидим

$ ./thread3.exe 
Thread ID (main thread): 26448, pid=26448
Thread ID: 26449, pid=26448
Thread ID: 26450, pid=26448
Thread ID: 26451, pid=26448
^C
============
Thread ID: 26448, pid=26448    <==== куда прилетел сигнал
===============


интересно то кто физически является иниициатором сигнала SIGINT в тред?
я отследил чрез strace
вот так выглядит сигнад когда источником иницатором сигнала был юзерский
процесс
- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=26568, si_uid=1000} ---

si_pid=26568  ===> это процесс из которого выстрели сигнал
si_uid=1000   ===> юзер под которым работал процессс 26568

а вот такой сигнал я вижу когда тыкаю Ctrl+C
--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---

тоесть его реально походу шлет само ядро.
как видно шлет оно его мастер треду если што

это интересно и забавною. щас обьясню.

значит есть у нас граф окно  на мониторе. мы тыкаем Ctrl+C на железке на клаве.
сигнал летит в ядро. потому что все что из железок выливается летит в драйвер
железки в ядро. 

как откомпилрвать *.c код который связан с X11

gcc -o icon icon.c -L/usr/X11/lib -lX11 -lstdc++

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< 






===
// my first program on C
#include <stdio.h>
#include <unistd.h>

int main ()
{

int vasya = 15;
int *pvasya = &vasya;

printf ( "$vasya = %d\n", vasya  );
printf ( "$vasya = %d\n", *pvasya );

vasya = 16;
printf ( "new $vasya = %d\n", vasya );

*pvasya = 17;
printf ( "new $vasya = %d\n", *pvasya );


return 0;
}

===
printf
%x - позволяет распечатать только 32 битное hex число максимум, а
%lx - уже позволяет распечатать 64 битное hex число !

===

тип переменной определяет для компилятора и проги сколько байт надо выделять под нее 
в памяти и в каком формате туда писать и  как интерпретировать  байты при считывании.
условно говоря если переменная целого типа значит при считывании и печати числа и нее
просто печатать число на экране а если переменная типа char то считанное число 
интерпретировать в литеру.  переменная типа поинтер хранит не значение а адрес памяти по которому
лежит значение тоесть в переменной мы храним незначение а ссылку в памяти где лежит значение 
этой переменной. почему то принято считать что поинтер указывать на память где хранится
значение другой переменной. а на самом деле в поинтере хранится значение самой переменного поинтера.
пример

int a = 1;
int *pA = &a;

получсется мы имеем две переменные которые имеют одинаковый бекенд. и как тут сказать 
какая из них на самом деле владее значением.   походу поинтер это как хардлинк на фс на файл.
несколко хардлинков указвают на один бекенд. 

когда программа напарывается на поинтер то она понимает что в этой переменной pA хранится незначение
переменной а ссылка на то где искать это значение. а значит некоторые операции доступные для обычных
переменных недоступны для переменной типа поинтер а ннекоторые новые операции зато доступны
для переменной поинтер которые недоступны для обычных переменных.

==================

printf

коогда мыхотим напечатать переменную то нужно в явном виде сказать принтф 
какой тип у переменной хотя ведь мы при созании перееменной это явно прописываем.

теме неменее это так  увы


#include <stdio.h>

int main () {

   int  var1 = 500;


printf( "var1=%d\n", var1 );
printf( "octal form=%#o\n", var1 );
printf( "hex form=%#x\n", var1 );
printf( "HEX form=%#X\n", var1 );

printf ( "\n"  );


float var2 = 600.5;
printf( "var2=%f\n", var2 );
printf( "var2=%#A\n", var2 );
printf( "var2=%#a\n", var2 );
printf( "var2=%#g\n", var2 );



   return 0;
}



в этом примере обьявляется переменная var1 с типом int
так вот что интересно что принтф позволяет при распечатке ее конвертировать ее вывод
из дефолтового (десятичного)  в другие виды. что существенно и в чем подьебка что конвертация
доступны не во все виды а только в некоторые

вот такой будет вывод на экран

var1=500
octal form=0764
hex form=0x1f4
HEX form=0X1F4

var2=600.500000
var2=0X1.2C4P+9
var2=0x1.2c4p+9
var2=600.5


таким образом int переменную можно при распечатке вывести в восьемричном виде, hex виде и 
на этом и все.  тоесть например нельзя переменную int типа вывести в виде с плавающей точкой
почему непонятно в чем проблема.


тоже самое касается переменной var2 типа float. 
ее можно при печати вывести в hex виде, но попытка выести ее в виде целочисленном
выдаст ошибку. 

если дефолтовая форма как обьяснить принтф какой тип имеет печатаемая переменная это 
%d
%x
%f

итп, то алтернативный вида задается в виде %#x. вобщем я бы сказал бы что просто напросто
 целочисленныую переменную можно ввывести в dec,hex,oct формате тоесть это блять никакое 
 не преобразование как об этом пишут в man это всего навсего меняется система счисления.
 а переменную с точкой можно вывести в dec,hex форматах. вот и все что касается %# в принтф.

 итак при выводе с помощью %# целое остаетс целым а с точкой осается с точкой 
 просто вывод идет по разным система счисления.

 а если мы хотим целое вывести как с точки или с точкой вывести как целое то для этого
 надо  на переменную натраваить функцию которая ее преобразует. пример

float var2 = 600.5;
printf( "var2=%i\n", ( int ) var2 );

вывод на экране
var2=600.500000
var2=600

вообще я непонима смысл этой решетки %# потому что - тип данных имеет скажем целый тип.
тоесть число без точки. от того что мы печаатем его в hex или dec или oct или bin виде 
от этого тип данных неменяется. поэтому на мой взгляд 

%x = %#x
%X = %#X

непойму нахуя вобще этот оператор # .

потому что и без него все рабоатет.

еть у нас var1 с типом int. окей. теперьмы для себя определяемся в какой системе исчисления
мы хотим распечатать переменную. еси в dec виде то 

printf ("%i", var1);

если в hex виде то 

printf ("%x", var1);

если в HEX виде то 

printf ("%X", var1);

нахуя нам тогда этот #  ??????????? он ничего непреобрзует. и никаких новых возможностей недает!


====

\\ 
C += A is equivalent to C = C + A
\\

=============
pointers
printf

еще интерснейщие пример
он про указатели. 
про принтф


#include <stdio.h>

int main () {

   int  var1 = 500;
   printf( "var1 = %i\n", var1  );


   int *pVar1;
   pVar1 = &var1;
   printf( "Address of var1 variable in memory(hex) =  %p bytes\n", pVar1  );
   printf( "Address of var1 variable in memory(dec) =  %li bytes\n", ( long int ) pVar1  );
   printf( "Address of var1 variable in memory(dec) =  %li TB\n",( ( long int ) pVar1 ) /1024 /1024 /1024 /1024);


   printf( "var1 = %i\n", *pVar1 );


   char var2 = 'a';
   printf ( "var2=%c\n", var2 );
   printf ( "var2=%d\n", ( int ) var2 );






   return 0;
}


вывод на экран:
var1 = 500
Address of var1 variable in memory(hex) =  0x7ffe4bbe0c1c bytes
Address of var1 variable in memory(dec) =  140730169166876 bytes
Address of var1 variable in memory(dec) =  127 TB
var1 = 500
var2=a
var2=97



разберем


   int  var1 = 500;
   printf( "var1 = %i\n", var1  );

  наэкране
  var1 = 500

  обьявляет целую переменную и печатает ее обьясняя принтф что мы собираемся печатать 
  перменуую целого типа. все таки непонятно если мы уже указали что перменная целого типа зачем
  еще раз это прописывать в принтф





   int *pVar1;

   обявляем поинтер переменную которая укащывает на ячеку памяти в которой лежит значение
   целого типа, 


   pVar1 = &var1;

   записываем в pVar1  адрес  переменной var1




   printf( "Address of var1 variable in memory(hex) =  %p bytes\n", pVar1  );

   на экране
   Address of var1 variable in memory(hex) =  0x7ffe4bbe0c1c bytes


   печатаем адрес ячейки памяти который хранится в поинтере. получается в принтф переменная
   типа поинтер указывается как %p.
   заметим что pVar1 указывается без всяких *
   таким образом если мы хотим заглянуть в сам поинтер(тоесть узнать адрес) то  указвыаем его имя pVar1 без  звезд. а если хотим узнать неадрес а знаение ячейки куда этот адрес указываемт то используем звезду *pVar1.
     как видно по дефолту значение поинтер переменной тоесть адрес  печается на экране в виде hex.


далее. хотим узнать знаение ячейки куда  адрес(поинтер) указываемт  используем звезду *pVar1.
   printf( "var1 = %i\n", *pVar1 );

   на экране
   var1 = 500

итак поинтер это адрес. звезда поинтер это значение.

   поскольку значение
   в ячейке имеет целоый тип то для принтф указываем %i

еще раз
   pVar1 = 0x7789798798dc   адрес ячейки памяти
   *pVar1 = 500  значение которое лежит по адресу втой ячейке памяти

   соотвестенно для принтф
   %p = указывает что печатаем переменную поинтер типа
   %i = указываем что печаатем переенную целого типа

прикольно то что нет просто переменной понинтер типа. помимо поинтер типа этот тип еще 
дожен иметь целый тип итп. хотя нет можно создать переменную типа поинтер без типа это будет

    void *pVar1 = переменная поинтер типа ведущая на ячейку неопределенного типа

	int * pVar1 = переменная поинтер типа ведущая на ячейку целого типа





   printf( "Address of var1 variable in memory(dec) =  %li bytes\n", ( long int ) pVar1  );
   printf( "Address of var1 variable in memory(dec) =  %li TB\n",( ( long int ) pVar1 ) /1024 /1024 /1024 /1024);

   на экране
	Address of var1 variable in memory(dec) =  140730169166876 bytes
	Address of var1 variable in memory(dec) =  127 TB

 здесь интересно то что я хотел распечатать поинтер на экране не в дефолтовом виде hex 
 а в десятичном виде. если переводить адрес памяти в из hex в dec то он очень большой и влезает 
 только в тип данных long int  поэтому я преобразовал hex в long int для этого я заюзал функцию  ( long int )  которую натрваил на pVar1. в английских книгах преобразование одного типа данных в 
 другой называется type casting  или просто casting. 
 в принтф я тоже указал что мы печатаем на экране тип данных %li.
 во второй строке  я применили арифмтические операции и перевоел байты в терабайты при этом получается число которое влезает в тип данных integer поэтому для принтф я указал %i

получается про принтф. в нем мы укаваем какой тип данных имеет переменная а потом указываем
эту переменную

printf ( "%тип_данных_у_переменной", имя_переменной)

вот так эта хрень работает.


или в более сложном вариенте принтф вместо переменной мы можем указать функцию которая берет пременную ее значение и тип и пребразует
ее значение вдругой тип

printf ( "%тип_данных_у_переменной",  (функция ) имя_переменной)

на выходе функции должны полчаться данные ровно того типа что мы указали в %.

теперь вспомним что написано в man 3 printf. там написано что если мы в принтф юзаем %p
то принтф ожидает увидеть переменну с типом void *. тоеть переменную котора была обьявлена 
вот так 

void * pVasya

тоесть перменная должна быть поинтером да непросто какого то там типа а воид типа.
если же мы посмотрим как унас вверху заюзано

	int *pVar1;
	pVar1 = &var1;

	printf( "Address of var1 variable in memory(hex) =  %p bytes\n", pVar1  );

   	на экране
   	Address of var1 variable in memory(hex) =  0x7ffe4bbe0c1c byte


то мы увидим что в принтф мы подставили перменную pVar1 которая да поинтер 
но она не воид типа а int типа. хм... почему же компилятор незаругался и у нас все сработало?
может имеет место автопреобразование со стороны компилятора?

тоесть моя практика показывает что принтф если указать %p то в качестве переменной он принимает
переменую типа поинтер абсолютно любого типа ему пострать это int * или void * или long * 
абсолютно похер. главное чтобы был тип поинтер неважно какого типа.
ключ %p печаатает адрес который хранится в поинтере. поэтому ему как бы похер на какой 
тип данных этот адрес ссылается.
 
 я считаю вот эта мудота с обозначением поиинтера как int * или void * это полный идиотизм
 вместо этого надо было ввести обозначениее для создания поинтера чтото типа  такого 

 int * var1  ----> pointer_i  var1
 void * var1 ----> pointer_v  var2

 вместо этих дурацкий звезд. а то сиди иломай мозг разгадывая смысл этих звезд.



=================

потихоньку начинает вырсиываотся смысл

ssize_t read(int fd, void *buf, size_t count);

получается функция read резульаттом является данные с типом ssize_t ( об этом потом) там отличие 
ssize_t от size_t  в том что может вернуться -1 

int fd = тип переменной целое, смысл переменной это файловый дескриптор (файл) из которого читаем
void *buf =  тип переменной поинтер, тип у поинтера void. смысла ее это буфер в который пишем что прочитали
size_t count = тип переменной size_t . смысл ее это размер читаемого в байтах


какой смысл у поинтера который указыаем на ячейку в котрой хранятся данные типа void.
воид это значит что тип данных неизвестен. я так поимаю что запись в поинтер который указывет 
на ячейку с неизвестным типмо данных дает нам взможность типа того что писать туда данные в raw формате. 

но void * var1 поинтер будем подрообнее анализивать и обсуждать ниже.

===========


соатновился на задаче как счиатть 1 символ с клавы
а потом выести на экран

вот этот код считыает с клавы 1 символ

#include <stdio.h>
#include <unistd.h>

int main () {

    int klava = 0;

    void * bufer;
    char k[1];
    bufer = &k;

    printf ( "void address = %p\n", bufer );

    size_t count;
    count = 1;

    read( klava, bufer, count);

   return 0;
}

( прикол read это сисколлл а не команда языка C, мы заюзали сисколл!)

что здесь существенно. 
если просто обьявить void поинтер 

void * bufer;

то как показал практика в реале он неиницилизируется и ни на какую ячейку памяти
непоказывает. поэтому нужна вот такя комбианация чтобы bufer начал релаьно укзатьвыа на
ячеку в памяти

void * bufer;
char k[1];
bufer = &k;


ну а эта строчка

printf ( "void address = %p\n", bufer );

это просто проверка что ячейка понинтер кудато реально указывает.

поопутно как я понимаю тип char это 1 байт в памяти под каждый char обьект. по факту 
это число от 0 до 255. целое.
поэтому наша воид поинтер по факту указыает на ячейку 1 байт длинной.



правлная инциализация void - то что он сам по себе никуда незукывает.
его плюс в том что его можно директить на соврешенно разные типы бекенд ячеек

int a = 10;
char b = 'x';

void *p 
p = &a;  
p = &b; 


минус в том что с этой поинтера нельзя напрямую печатать

int main()
{
    int a = 10;
    void *ptr = &a;
    printf("%d", *ptr);
    return 0;
}

если даже на бекенде сидит у нас int то получаетс что по определению void поинтер указывает 
на ячейку памяти в которой сидит занчение перменной у котроой нет типа!!!! а раз нет типа
то ее нельзя распечатать.

поэтому воид поинтер надо конвертить ( и он конвертирится в любой тип без проблем) в тот 
тип данных что мы хоим печатать

int main()
{
    int a = 10;
    void *ptr = &a;
    printf("%d", *(int *)ptr);
    return 0;
}

на счет вот этой хрени  *(int *)ptr


(int *)ptr  = создает поинтер нового типа. адрес в нем такой же а вот тип данных который лежит в
 ячейке по адреу поинтера утверждоаетс что новый тоесть

 int a = 1;
 void * vasya;
 vasya =  &a;

 хотя мы знаем что в ячеке пойинтереа лежит целое но C этого незнает.
 пожтому что мы заявили что по адресу поинтера vasya лежат какието данные но их тип определить
 невозможно.

 поэтому

 int * petya;
 petya = ( int *) vasya;

 тоест мы сконевертировали воид поинтер в int поинтер и подсунули адрес а petya

 теперь petya смотрит тудаже куда и вася но для C уже понятрно что бекенд пети это интеджер.

 поэтому его можно печатать.

 printf ( "%c", *petya  );



так вот я про вотэту команду

*(int *)ptr

она преобразует воид поинтер и вызывает значение по его адресу.

пример

#include <stdio.h>
#include <unistd.h>

int main () {

    void * pVasya;
    char a = 'a';
    pVasya = &a;

    printf ( "pointer pVasya = %p\n", pVasya   );

    char * pa;
    pa = (char *) pVasya;

    printf ( "pointer pa = %p\n", pa);

    printf ( "char = %c\n", *pa  );

   return 0;
}

вывод на экран:
pointer pVasya = 0x7fff5d948237
pointer pa = 0x7fff5d948237
char = a



видно что поинтеры указывают на одну ячейку.

так ну пока я невижу какогот то полезного смысла в воид поинтер
кроме такого что  его указатель можно менять на любые типы препеменных.


int a = 10;
char b = 'x';

void *p;
p = &a;  
p = &b; 

прикольно. но какой в этом болшой смысла на практкие хер его знает


ясно одно кога мы создаем воид поинтер то мы четко заявляен стстеме что тип данных у ячейки остуствует. его нет. мы неможем его определит. данные есть но их тип неопреелим. несущетсвует.
поэтому принтф для воид поинтера неработает. 
для самого адреса %p конечно работает а вот для занчения перменной в ячейке нет.



==========
cast
type cast
type conversion

это все слова о том что можно натравливать на переменную одного типа функцию
которая превратит данные этой переменной в другой тип и эти новыве данные нового типа
можно будет присвоить новой переменной

(type_name) expression

из этого получается что в выражении void * vasya кусок void * является одним целым
и означает тип данных.

тоесть 

int
double 
float
char
int *
void *

это все так обозначаются типы данных. но меня больше всего тут заинтересовало int * и void *

==

#include <stdio.h>


int main () {

    int a;
    printf ("%p\n", &a );

    int * pVasya;
    printf ( "%p\n", pVasya );


    void * pVasya2;
    printf ( "%p\n", pVasya2 );


   return 0;
}

vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~/C$ gcc -o 15 15.c; ./15
0x7fff55d56584
0x5570162325a0
0x7fff55d56680


странно.
переменным неприсовено никакого значения но под них 
уже зарезервированы ячейки в памяти.
===

вот еще пример


#include <stdio.h>


int main () {

    int a;
    printf ("variable \"a\" memory address = %p\n", &a );
    printf ("var a = %i\n", a );


    int * pVasya;
    printf ( "variable pVasya points to memory address = %p\n", pVasya );
    printf ( "*pVasya = %i\n", *pVasya );



    void * pVasya2;
    printf ( "pointer pVasya2 points to memory address = %p\n", pVasya2 );


   return 0;
}


$ gcc -o 15 15.c; ./15
variable "a" memory address = 0x7ffe1165e0c4
var a = 21881
variable pVasya points to memory address = 0x5579416f95a0
*pVasya = -1991643855
pointer pVasya2 points to memory address = 0x7ffe1165e1c0


видно что мы обьявили пермеменные но не присвоили значения
однако значения у них уже есть! это чтото !

=========

пример cast преоббразования одних типпов данных в другие


#include <stdio.h>


int main () {

int a = 10;
int b = 2;

double count;


count = (double ) a / b;

printf ( "%i / %i = %f\n", a, b, count    );


   return 0;
}


vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~/C$ ./15
10 / 2 = 5.000000

======

поговорим про ascii
станадартк кодирования символов. типа есть текст с байтами их надо 
как то транслировать в символы. man ascii
кодирование сосотоит из 128 символов. на него хватвает 7 бит.
часть кодов это несимволы а упправляющие сигналы. кодировка уходит
во времена печаатающих маштнок ( typewriter). и электрических печатных машин ( teletype writer)
так вот хочу про два спец символа сказать

CR - carriage return это когда на печатной машинке мы беремся за железную такую ручку
и тащим налево это приводит к тому что печатная гооловка оказывается опять в левом крайнем
положении. что важно отметить что при этом мы остаемся в тойже строке тоесть бумага при этом
на прокручивается вверх вертикально. ( хотя как я помню из своего опыта печатания на печатной
машинке то при перенеосе головки влево и бумага автоматом прокручивается вверх на одну линию)

LF - line feed. прокрутка листа бумаги на одну линию вверх. при этом с головкой ничего непросиходит
так что печать начнется с тойже позициив строке а не с левой крайней.

поэтому получается что на классическом матричном принтере если закончилась строка то чтобы
начать печатать с новой строки надо подать два сигнала оба тоесть CR + LF либо LF + CR
более того я прочитал что якобы для матричных принтеров нужно было дать несколько таких
сигналов типа CR + CR +CR +LF потому что якобы они неусмевали дотащить головку влево 
за время одного CR что по мне бред ведь они печатают из буфера а не стой скоростью с которой
 в них прилетают сигналы.

 тем не менее теперь понятна разница между CR и LF.
 LF часто называют "new line". а так тепер стало понянто. CR это перметсить печатную голову влево
 а LF это прокруттить рулон бумаги вверх.

 итак вся эта хрень относилась к элетрическим печатным машикам по которым по проводам телеграммы
 летели.  а когда перешли к  теримналам с электронными экранами то ( как я понял ) необходимость
 для переноса строки юзать два символа типа пропала. поэтому в файлах начали изать для этой цели
 обычно один символ либо CR либо LF и  терминалу стало понятно что надо сделать CR + LF.

 поэтому в линуксе в текстовых файлах знаком конца строки и начла новой строки является символ
 LF тоесть байт который в себе несет значение 10 (dec) или 0A (hex)

 тут еще раз важно отметить что символ LF формально должен только пркручиваь бумагу на 1 строку 
 вверх а голвка при этом остается на том же месте. но в линуксе в его терминале это приводит к тому
 что экран прркучиватеся на 1 строку вверх и также при этом и гооловка печаатающая возвращается
 в левое крайнее положение

 вот программа

 $ cat 1.bash 
#!/bin/bash

sleep 1; 

echo -n "v"; 
sleep 1; 

echo -n  "a"; 
sleep 1; 

echo -n "s"; 
sleep 1; 

echo -n "y"; 
sleep 1; 

echo  -n "a"; 
sleep 1;

echo -n -e "\x0D"; 
sleep 2; 



echo -n "*"
sleep 1;

echo -n "*"
sleep 1;

echo -n -e  "\x0A"
sleep 1;


echo -n "!"
sleep 1;

echo -n -e  "\x0A"
sleep 5;

вот ее вывод

**sya
!

теперь разберем.
вначале програ печаате по буквам слово vasya

vasya

печатется оно буквам в одной строке. ключ -n  в echo дает то что при выводе буквы после 
нее непроисходит прокрутки бумаги и возврата головки(курсора) в левое положение ( условно говоря
не вставляется enter)

потом печатная головка (курсор мигающий) возвращаетмя в начало строки (без прокрутки бумаги).
за это отвечает команда echo -n -e "\x0D".  0D это символ CR (возврат головки влево) в hex 
формате. здесь важно отметить еще раз что при возврате каретки бумага непрокручивается. так что 
печать остается в тойже строке.
и далее начинает затираться строка печатая две звездочки. так что мы увидим вот такое

**sya

этим я хотел еще раз подчеркуть что при поступлении в терминал ( котрорый можно сравнить с матричным принтером) символа CR ( 0D hex ) происходит возрат головки вначало строки и не происходит
прокрутка бумаги. так что печать начинает затирать ранее набранные символы.

далее в
 бумага прокручивается вверх  потому что на терминал поступает байт 0A (hex ).
это делается командой echo -n -e  "\x0A"
0A (hex) этот байт это  символ LF - line feed - прокрутка  бумаги наверх. но помимо покрутки бумаги также происходит и возврат головки
 вначало строки. здесь уже 0A ни причем это чисто отсебятина linux терминала.

терминал можно сравнить с матричным принтером. а байты которые в него влетают с управляющими командами. если прилетает байт 76(hex) то принтер печаатает головкой литеру "v"
если прилетает байт 61 (hex) то принтер печатает литеру "a"
а если прилетает байт 0D (hex) то принтер ничего непечаатает он возвращает головку в левое положение
в начало строки.
а если прилетает байт 0A (hex) то принтер пррокручивает бумагу на одну строку вверх. и еще добавляет  от себя возврат головки в начало строки.



так вот когда напечаатся **sya то происходит пркрутка бумаги и  возврат в начало строки 
и печается !

**sya
!

далее происходит опять пркоуркртка бумаги и возврат в начало строки.

ключ -e позволяет через echo передвать байты в hex виде.
ключ -n засталвяет echo невставлять автоматом LF в конце команды. так что мы имеем полный контроль
над выводом в терминал.

такми мккаром мы изучили влияние и работу CR и LF.

также полчается если у нас есть файл и мы запустим его вывод на терминал 

$ cat vasya.txt

то файл содержит байты. так вот терминал (ядро линукса) он как матричный принтер рассматривает каждй байт в файле как 
литеру ascii таблицы и либо печатает сооветвующую литеру или если это нелитера а управляющая команда
такая как CR или LF то прокручивает бумагу (то бишь экран) или возвращает головку (курсор) в начало
строки. таким образом голые байты в файле превращаются  в набор литер на экране. (ну или на бумаге) есл бы это был принтер.

таким образом в файле никакие литеры нехранятся ( как это могло бы интуитивно показаться). 
файл это не бумага. в файле литер нет. там только голые байты.


далее. что инересно.
если мы откроем скажем в mcedit файл в котлром есть байты которые в таблице asccii отвечают 
за упраляющие команды то на экране  в определенных местах будут стремные символы например для 
байта CR на экране в тексте будет что то типа ^M

вообще это интересно. потому что при просто выводе на экран такого ничего нет.
курсор терминала просто делает что ему предписано прокручивает бумагу или возвращает курсор 
в начало строки. так что при просмотре файла никаких стремных символов нет. потому что просмотр файла  это аналогично печати на принтер. где каждый байт это либо литера либо управляющая команда
для головки принтера (курсор)

вобще полчучется файл это поток байтов которй по проводам предавался от одгной электро печатной машинки на другую и использоваолся чтобы набрать текст в автоматическом режиме.


типа это как рецепт изготовления пирога.

принтер является поваром а файл рецептом.

терминал выступает в роли принтера.

когда мы открваем файл на редактирование то получается в определеннымх местах нам надо 
как то показывать что здесь сохранен непросто литера а управляющая команда. 
это как открыть файл ворда. там помимо голого текста еще напихана куча управляющей информации.
таким образом это власть текстового редактора показывать каким либо одразом управляющие символы
ascii или их скрывать.

mcedit например байт CR показывает как ^M

===

ascii

рассмотрим следущий байт

00 (hex)

он означает то что при получении этого байта терминал ничего неделает. ни печатает и с головой
ничего неделает.


пример

$ echo -n -e "\x00v\x00a\x00s\x00y\x00a"

здесь получается слово vasya и между буквами вставлены байты 00 (hex) 
на экране мы увидим просто слово 

vasya

между буквами ничего небудет никаких лишних символов.
возможно в teletype writeer машиных этот символ вставляли для того чтобы у принимащей
машины были паузы при печати незнаю для чего эти паузы. чтобы машины не перегревались.

этот как в процессоре команда nope которая ничего неделает 1 цикл.


что при этом существенно что если мы направим вывод в файл 

echo -n -e "\x00v\x00a\x00s\x00y\x00a" > ./vasya2.txt

то конечно внутри него попимо байтов отвечающих за литеры vasya еще будут байты 00 (hex)

делаем следущий экспримент

$ cat /dev/zero

на экране терминала небудет отображаться ничего. потому что в темринал поступают байты у которых
значение 00 (hex) поэтому драйвер терминала  ( ака виртуальный матричный принтер) интерпретурует
данную команду как ничего непечатать и неделать.

(а совсем не так как казалось бы интуитивно раз поступают байты с нуля то на экране побегут нули. хаха)

в тоже время если направить эту штуку в файл то конечно файл забьется байтами 00 (hex)
и это можно отлично посмотрет в hex редакторе файлов.


итак с 00 (hex) байтом в ascii разоборались
===

ascii

написано что в бинарном виде заглавная буква отличается от маленькой буквы только одним битом.
я проверил это так.

например

dec 87 = 'W'
dec 119 = 'w'

$ echo 'obase=2;87' | bc
1010111

$ echo 'obase=2;119' | bc
1110111

напписано что на мехаических teletypewriter такая схема облегачала 
их програмирование их контсрукции

===
ascii

вначае был морзе. потом бодо(ita1). потом ita2

в морзе буква от буквы при передаче отделяются опреденной паузой размером как три точки.
слово от слова отделяется еще более длинной паузой как семь точек.

морзе можно передавать  через один провод.
кодирование идет ну типа двоичное но на каждый симовол уходит много бит потому что еще идут и стоп биты. условно говоря если точка это 0
а тире это 1 , то буква A = 01, буква B = 1000 что касается букв то максимум 4 бита используется, 
например H = 0000 
но прикол в том что чтобы передать слово из одной буквы уходит слишком много битов еще и на стопы.
передача слова из одной буквы выглядит так:
стоп-(от одного до  четырех бит)-стоп-стоп-стоп

при наборе даже одной буквы между точкаи и тире делается пауза в размере одной точки по длине.
получается берем букву A: A = 01, тогда передача выглядит по времени как

0-пауза-1-пауза-пауза-пауза

вобщем да очень много стоп битов так скажем при передаче чтобы уметь отделять на слух буквы друг от друга и слова от слов.



далее был бодо. его код уже работает только через ПЯТЬ проводов ! зато уже нет этих многочисленных
стоп пауз.

у бодо уже чисто двоичная кодировка символов. как я понял схема работала на практике так.
с нашей стороны аппарат с клавой на 5 кнопок потом в поле уходит пять проводов,
на той стороне принимающий аппарат и принтер. принтер это полоска бумаги.


на нашей стороне мы жмем комбинацию из 5 кнопок. например A = 10000 
этот сигнал по пяти проводам полетел туда. там на ленте пробивается столбик. в котором одна дырка
и четыре места где нет дырок. соотвесвтенно на пяти битах можно запрграмировать 32 символа.

тоесть на той стороне будет лента на которой будет вот такая лента. каждая буква
это отдельный символ

--------
1 1 0 0
0 0 0 0
0 0 1 1
0 0 1 1
0 0 0 0
---------

на этой ленте запрограмировано AABB сообщение.
при этой схеме человек сидит печаатет и сообщение улетает в режиме онлайн.

как я понял бодо изобрел и метод кодировки и сам аппарат по отправке сообщений.
на аппарате небыло как я понимаю клавы с символами  а было просто реально пять кнопок
каждая из которых была привязана к одному проводов которые шли через леса и поля на ту сторону
приемника.

потом мюррей придумал такой аппарат что можно на нашей стороне набрать собщение которое
у нас же отпечаается в форме ленты с дырками. потом взять эту ленту засунуть в другой апарат
и он уже автоматом по этой ленте отправит собщение. так что набор сообщение стал отделен от 
процесса отправки сообщения. также как я понимаю мюррей уже привязал печатную машинку с полноценной
клавой к этой кодировке бодо. тоесть человек нажимал на кнопки на которых были нарисованы уже буквы. что сущесвтеннно улучшает удобство отправки. как на печатной машинке. и также как уже сказал
мюррей сделал асинхронным процесс набора текста и его отправку. 
также как я понимаю что касается приема сообщений все оставалось неудобным тоесть на 
принимающей стороне люди получали ленту с дырками а не печатный текст. ленту получается
надо было еще руками дешифровать. но хотя бы отправка удобная стала.



как я примерно понял кодировка бодо на пяти битах называется также ita1
ita это чтото типа телеграфный стандарт алафита.


потом сделали ita2
он тоже базируется на 5 проводах.но! в нем сделали хитрую штуку. добавили спец символ 11011
и таким макаром получили двойную емкость символов. выглядело так.
есть закодированный набор букв от 00000 до 11111 ( за исчключением некоторых комбиацний  в частности спец символ 11011). и есть закодированный набор уже доп символов всякие там цифры
знак доллара, знак вопроса, знак фунта, кавычки запятые условно говоря всю эту группу назовем
группа цифр. так вот если мы хотим отправить цифру то мы вначале шлем на ту сторону спецсимвол а уже за ним код символа. спец символ 11011 это что типа прообраза кнопки Shift на клаве.
для того чтобы показать что мы обратно вернулись к отправке букв был тоже спецсимвол 11111

тогда отправка выгляди так

11011 - цифра-цифра-цифра-11111-буква-буква-буква-буква

как видно если подряд идет несколько бука или цифр то между ними спецсимвол каждый раз неставиться
он ставиться только вначале группы.

пример 

буква A = 11000
цифра 1 = 11101

тогда передаем AA11 сообщение:


11111(спецсимвол группы букв)-11000-11000-11011(спецсимвол цифр)-11101-11101


и вся эта хрень на той стороне выбиывалась на ленте в форме дырок вот так:


					-------------	
					|o o o o o o
					|o o o o o o
начало ленты=>		|o       o o        <== конец ленты
					|o     o  
					|o     o o o
					|-------------

буквами 'o'  я обозначил дырки на ленте в бумаге.

в этой кодировке также был символ для пробела. символ прокрутки бумаги на одну строку (line feed), символ переноса каретки влево вначало строки.

как бы спрашивается какая хрен каретка. каретка она же у печатной машинки только есть.
тоесть зачем пеересылать на ту сторону знак прокрутки бумаги или знак возврата печати символа 
с левой позиции. я так понимаю что эти симфолы форматирования текста отсылались на ту сторону
в форме дырок на ленте чтобы человек который дешифрует сообщение мог понимать как ему форматировать  текст уже на бумаге на печатной машинке чтобы текст невыглядел как сплошная длинная одна строчка. может так ? и видимо на каком то этапе все таки сделали автоматический аппарат который вместо человека считывал дырки и печатал литеры уже на печатной машинке автоматом с соблю
дением форматирования. тем более что на печатной машинке нужно по любому переносить строку 
потому что лист то имеет конечную ширину (чото я непомню если печатть на печатной машинке  и дошел до конца строки она что делает продолжает долбит в последнюю позицию в строке или что ?)

 с точки зрения печатных машинок непонятно какой смысл имеет CR без функции LF.
 какой смысла на печатной машине вернуть головку вначало строки и начать запечатыывать а именно
 поверх старых символов херачить сверху новые символы. мы же наавоз получим на бумаге.
 это непонятно. по мне CR всегда должен быть с автоматичеким LF. непонятно

 однако имеенно на этом этапе ita2 появились управлящие спец символы CR и LF.

 эти симолв предназанчались для тех усторйств которые декодировали ленты с дырками 
  и печатали текст на печатных машинках на бумаге (типа проорбразы принтеров) чтобы текст получался
  полноценно форматированным. типа такого


  ------------------------------
  |мама мыла                   |
  |раму.                       |
  ------------------------------

тоесть CR и LF нам позволяет начать печатать новое слово с новой строки в любой момент.


таким образом уже видно что CR и LF символы были придуманы для управления принтерами печатными 
устройствами но не электронно-лучевыми мониторами терминалов.

это важно понять откуда зачем почему для чего появились символы CR и LF.
короткий ответ - для автоматического управления принтерами. для форматирования текста при печати.
ровно как это есть при печати на матричном принтере!

единственное мне пока остается непонятным как же они ухитирились создать аппарат котоырй автоматом
умел расшифроввыать дырки на ленте и потом печаать правильные буквы на печатной машине.
как это можно было сделать без компов и микросхем с процессорами.

так вот забегая вперед скажем про ASCII.
ascii хотя я неочень понял это стандарт кодирования символов в телекоммуникациоонном оборудовании
и в компах. походу поскольку телеграфные устройства это тоже телекомуникационное оборудование
то типа того что ascii это апгреженный вариант кодирования бодо. только уже на 7 проводах.
потому что используется 7 бит для этого. так вот получается что управляющие символы в кодировке этой опять же предназначены для того чтобы на принмающей поток стороне  принтеры (телепринтеры так вроде их звали) правильно форматировали текст. тоесть еще раз в ascii кодировке управляющие символы это символы управления форматироваиния печати на принтерах. тоесть эти символы придумывались изначально для принтеров ! а не элт экранов терминалов.


тоесть принимает телепринтер телеграмму и поступают к нему буквы он их печаатет. потом в потоке
поступает символ CR+LF и телепринтер прокручивает бумагу пеерводит печатную головку вначало строки
и дальнейшая печать идет с новой строки. таким образом передаваемый поток содержал нетолько инфо 
что печатать но и как печатать как форматировать.
====

ascii

получсется код бодэ был придуман чтобы по шине 5бит передавать буквы.
где хранилась данная инфо в цифровом виде. ответ нигде.
кроме как в виде дырок на ленте. лента была как файл и жесткий диск одновременно.
данное цифрая инфо только летела по шине (проводам) и все больше нигде не хранилась.

 важный вопрос что такое кодировка? =  получается кодировка бодэ это отправка от источника к приемнику информации о букве  в виде двоичного кода длинной 5 бит.
за что отвечает кодировка на что она влияет? = если у нас есть цифровой канал от источника
к получателю и мы отсылаем символ из предоопределенной таблицы ( букву "a") через этот канал 
то согласно кодировке этот символ будет иметь конкретный вид битовый. 00100. кодировка этот 
метод преобразования литеры в 5битовое слово.  в разных кодировка литера будет иметь другой вид
этого слова. получается если у нас есть поток буквенной информации и мы этот поток шлем по 
цифровому канаду в виде битов то кодировка определяет конкоетный битовый вид для литеры.

поток литер может идти как с клавы так и из файла. в файле поток сразу выглядит в форме потока
битов. если поток идет  с клавы то вначале коды нажатия клавиш надо преобразовать в коды литер
согласно кодировке. а потом отправлять получателю. получаетель должен получить при приеме поток 
битов и байтов составленный согласно кодировке. 

кодировка позволяет набор литер преобразовать в битовый\байтовый массив. в цифровой вид. нули и единицы. эта же кодировка позволяет преобразовать битовый массив в человеческие литеры. 

получается 


 литеры на бумаге  --> кодировка -->  массив байтов 
 литеры на бумаге  <-- кодировка <--  массив байтов


применительно к компьюетеру а не телеграфу = есть файл на диске в виде набора байтов.
нам его надо вывести на монитор или принтер в виде букв литер. для этого надо их преобразовать.
преобразование , поиск какой байт кодирует какую литеру идет через таблицу кодировки.

в случае телеграфа кодировка позовляла задать для буквы на бумаге или кнопки на клаве 
конкретный цифровой сигнал битовый который уже можно отправит по шине. по каналу связи. через
электричество. 

кодировка позволяет имея битовый сигнал узнать что за буквы за ним кроются.
или имея буквы трансформировать их в битовое представление.

получается еще раз что позволяет кодировка

aABjqwdkqwdkd  --> кодировка --> 01010101001010100101
или
0101010101011  --> кодировка --> Abbdbdbdbwdjewbfjwfb


пуолчается кодировка нам позволяет информацию из литерного вида перевести в битовый вид
и наоборот из битового вида в литерный вид.

битовый вид можно передавать по каналам связи. а литерный нет. поэтому то и нужна кодировка
чтобы как преобразовать литерный вид в битовый.

остается вопрос где этот битовый поток информации живет и существует. что является его носителем.
где байты рождаются и где умирают и где хранится что их носитель.
для телеграфа это  канал связи. и походу только в нем и все. ну еще на перфорированной ленте.
человек тыкает кнопку на телетайпе , аппарат создает битовый поток на этой стороне провода. это место рождения этого потока этих бит. потом аппарат его пихает в канал связи. канал связи носитель этого потока бит.поток прилетает на приемник и там как цифровой вид он умирает. остается в форме дырок на бумажной ленте. лента это носитель. но это уже не цифровой вид потока. хотя...наверное цифровой все таки. просто немагнитный носитель а так цифровой.

для компьютера поток хранится во первых в файлах. в файлах записаны биты. биты имеют опреденный порядок как раз на основе кодировки. биты текстовой информации естественно потому что ascii это 
таблица кодировки символов литер букв. где еще.. еслы мы говорим о кодировке значит
должен быть где то в компе поток либо битов которые надо перевести в литеры на бумаге или экране
либо поток чегото еще (например кодов нажатия кнопок на клаве) в поток битов. когда мы говорим
 о кодировке значит сейчас у нас есть поток литер букв которые нужно перевести в поток битов
 либо у нас есть поток битов которые нужно перевести в литеры.  там где кодировка там обязательно 
 должен быть поток либо либо битов либо литер. потому что кодировка это трансляция букв в биты 
 либо в битов в буквы. это процесс. как горение. а как же клава. при чем здесь кодировка.
 мы нажали кнопку и программа обработчик берет код нажатия кнопки  и понимает что это литера 
 "A" и ей нужно преобразовать эту литеру этот код нажатия в биты в битовый вид согласно 
 правилу преобразования на основе кодировки и эти биты куда то потом отправить какому то получаетелю. если говорим о кодировке значит есть отправитель и получаетель.  вцелом получается
 кодировка позволяет взять литеры на одном конце преобразовать их в биты и послать на другой конец.
 или наоборот. взять биты на одном конце полать в другой и там их преобразовать в литеры.

 кодировка это получаеся всегда два процесса преобразование и передача.

а то получается непонятно было . кодировка это про буквы и биты. а где эти буквы где 
эти биты. все висело в воздухе.

для компа в самом простом случае если мы говорим кодировка то вспоминаем файл внутри которого
лежат биты и байты и кодировка нам позволяет получить из битов и байтов литеры буквы текст.
позоволяет полученные нули и единицы преобразовать в понятный текст. на заре интернета часто 
при заходе на страницу надо было выбирать кодировку для страницы. потому что - страница имеет 
вид битов и байтов и типа тогда почемуто браузер непонимал какой кодировкой закодирован текст
внутри этих битов и байтов.  получаетс в одном из случаев если мы получили некий кусок байтов
некий набор байтов то применив на них кодировку мы можем получить набор букв. текст. превратить
набор битов и байтов в текст. 

получается когда слышим слова кодировка то на ум должно прходить сразу два ее спутника : некий поток набор байтов и  набор текста.  кодировка позволяет превратить одно в другое.
если мы хотим бумажный текст на листе засунуть в комп то нужно составить массив байтов согласно 
кодировке и поместить в комп. если у нас на компе есть файл из байтов а мы хотим его прочитать 
то нужно на читать массив байт за байтом искать в таблице кодировки за какую литеру отвечает 
текущий байт и писать на бумажку эту литеру. таким макаром мы из байтов получим текст

в чем прикол кодировки. это как слово горение. оно лишь часть картины. горение это 
процесс. значит если есть горение значит есть дрова и продукты отходов горения и  продукт полезный от горения. и это надо все вместе значть понимать и рассматривать. это как полет.
полет это процесс. есть обьект полета - самолет. есть куда он летит откуда. и другие атрибуты полета они все неотделимы от полета. полет лишь часть картинки. надо всю картинку представлять.

тоже самое про кодировку. есть обьекты кодирровки - это литеры и биты. есть процесс пееревода 
одно в другое. есть носители обьектов - бумага, жесткий диск. так что  одного слова кодировка
мало чтобы оно говорило обо всей картине в целом.  а важна именно картинка  в целом.

если мы скажем полет. то ничего непоняно. что летит. куда летит откуда летит. как быстро летит.
итд итп.  слово полет это лишь часть картины. это процесс. но одного слова полет мало чтобы 
было все понятно.


так и кодировка. что кодиируется . во что кодируется. что является носителем источника
и результата. 

согласно man ascii кодируются литеры  ( а что такое литеры в целом говоря ?) в байтовый вид.
но этого мало.  что является носителем литер. кто делает преобразование. что является носиелем
байтов. 

ясно одно если мы слышим слово кодировка ascii то значит где то там мы будем иметь дело с литерами
и с байтами  и преобразовывать одно в другое.

это как слово костер. значит гдето там мы будем иметь дрова и высокую температуру. 
неотьемилимые свойства костра.

так и с кодировкой. буквы и байты это ее неотьемлимный свойства

=======

OCT, HEX, DEC

вопрос захера нам oct вид в компьютерах. заодно и hex.
где это все полезно на практике?



в файле все записано битам 01010101010101101010101010
но по факту они на диске разбиты на байты

байт байт байт байт байт байт байт байт



распечатаем на экране содержимое файла в виде байтов. причем в трех вариантах.
вначале байт будет представлять в десятичном виде, в шестнадцарритриицном и в восьемирочном.

(dec) 118  97 115 121  97  13  42  42  10 118  97 115 121  97  10
(hex)  76  61  73  79  61  0d  2a  2a  0a  76  61  73  79  61  0a
(oct) 166 141 163 171 141 015 052 052 012 166 141 163 171 141 012


возникает какой из этих видов проше всего позволяет налету глазами конвертировать байт в битовый 
двоичны вид 0101010101 чтоб неприбегать к калькулятору. ответ восьмеричный вид! щас разберем так. поэтому то он и существует!


в восьемричном исчислении знаков восемь 0,1,2,3..7
семерка  в битовом представлении это 7 = 111

получается один символ собой кодирует три бита. 
в самом деле

0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111

как видно если у нас есть восьмеричное число на данный момент состоящее из одной цифры
то можно точно сказать что за ней кроется три бита.


поэтому скажем за двухзначным oct числом кроется всегда шесть бит. неболее шести бит

57 = 101 111

проверим (oct) 57 = ( dec (8^1)*5 + (8^0)*7  ) = (dec 47) = 101 111

так вот у oct чисел ест два охуенных свойства.  первое это то что если перевести oct число в битовый вид то число бит будет небольше чем число oct цифр * 3. тоесть

(oct) x = 3 бита
(oct) xу = 6 bit
(oct) xyz = 9 bit итд

пример

(oct) 7 = 111
(oct) 77 =  111 111
(oct) 777 = 111 111 111

7 - это макс число из одной цифры в oct счислении
77 - это макс число из двух цифр в oct счислении
777 - это макс число из трех цифр в oct счислении

поэтому тут я доказал эту щтуку что если у нас есть oct число 3457676 то в битовом виде
оно будет занимать 7цифр * 3бита = 21 бит

и второе суперкрутое свойство это то что для того чтобы перевести oct число в битовый вид
надо взять каждую цифру в числе и представить в битовом виде
тоесть

57 = 5 и 7 
5 это 101
7 это 111

значит 57 = 101 111

и это суперкруто! потому что такое правило совершенно неработает в десятичном представлнии байта.

еще пример

(oct ) 456 
4 это 100
5 это 101
6 это 110

значит (oct) 456 = 100 101 110

это совершенно фантастичкское свойство oct чисел.
ничего подобного у dec чисел абсолютно нет!
чтобы пеервести dec число в битовый вид это нужно поебаться конкретно.

приведу пример
вот битовое представление некоторых dec чисел

dec
 9 								1001
 99 						110 0011
 999 					11 1110 0111
 9999 			   10 0111 0000 1111
 99999 		   1 1000 0110 1001 1111

как видно даже и близко тут неработает правило что битовый вид является суммой
отдельных цифр.

единственное что верно для dec чисел это то что если dec число состоит из n цифр 
то его битовый вид займет не более чем n*4 бит. получается за каждой dec цифрой скрывается 
четыре бита. или до четырех бит точнее. но поскольку инфо на дисках хранися в виде байтов то есть
в виде неменее 8 бит то получается что 

пример есть у нас число 

(dec)  1212338898898234980

оно состоит из 19 цифр. значит оно занимает 19*4 бит = 76 бит
дополняем до полных байтов итого 80 бит или 8 байт.

таким макаром мы умеем представлять сколько бит надо надо на диске в зависимости от того 
сколько цифр в dec числе.  за 1 dec цифрой кроется 4 бита.это хорошо. но как уже сказал dec числа плохи тем что зная цифровой вид dec числа его совершенно непросто переввести в битовый вид.


а вот oct числа переводятся просто прекрасно. за одной oct цифрой кроется 3 бита.
и битовый вид можно получить записав битовый вид отдельных цифр.

как уже говорил вот пример

(oct)  1237701 = 

берем табличку для цифр

0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111

получаем
1237701 = 001 010 011 111 111 000 001

проверим на компе 
$ echo "obase=2; ibase=8; 1237701" | bc
1 010 011 111 111 000 001

полное совпадение!

тут сразу скажу про obase и ibase их нужно вставлять в echo именно в порядке что 
obase первый а ibase второй всегда. если наоброт то будет полная хуйня. 
obase это счисление которое хотим получить а ibase исходное.


чтоб было еще лучше видно то что 
цифры в dec числе  никак не вяжутся с ббитами вот картинка



dec
 9 								1001
 99 						110 0011
 999 					11 1110 0111
 9999 			   10 0111 0000 1111
 99999 		   1 1000 0110 1001 1111

в тоже время oct и hex числа отлично переводятся в биты

oct
 7 				111
 77 		111 111
 777 	111 111 111


hex
 F 			 	    1111
 FF			   1111 1111
 FFF 	  1111 1111 1111


это потому что последняя цифра и в oct и в hex выражается через биты у которых 
все единицы


тоесть 7 (oct) = 111
       F (hex) = 1111


hex счисление отличается от oct только тем что hex цифра за собой скрывает четыре бита
а в oct цифра скрывает три бита вот и вся разница.


тоесть если мы видим 

hex ABC4567F 

то мы можем смело понимать что в битах это число занимает n*4 бит = 8 * 4 = 32бита
тоесть каждая цифра в hex отбражает половину байта. таким образом если наше hex число 
можно отбразить в байтовом виде как

(AB)(C4)(56)(7F)

кстати говоря в oct виде байт занимает три цифры.
поскольку байт в dec максимально это 255 посмотрим чему оно равно в oct.
dec 255 = bin 1111 1111 = 11 111 111 = oct 377

правда тут несовем понятно ведь 3 = 011 тоесть 377 = 011 111 111 это 9 бит а не 8 бит
так что неочень понятно в точности как это байт можно в oct представить. мы типа 0 откинули в 
oct 3.

а вот у hex все впорядке одна цифра это 4 бит. так что две цифры это 8 бит или байт.
так что любой байт  в hex это две цифры.

таким образом в целом говоря кода мы смотрим на oct или hex мы сразу понимаем сколько бит
занимает данное цисло и можем достаточно быстро на лету перевести в битовый вид.
ну для hex это сложнее потмоу что надо помнить в битовом виде  16 значений ( для 0, 1, 2,... F)
а вот для oct это существенно проще так как там нужно помнить всего 7 битовых значений
для 0,1, 2, ... 7

причем как уже сказал чтобы перевести из hex,oct в битовый вид надо просто взять 
перевести в биты каждую цифру и просто соединить. эьто очень круто и очень просто дает 
вохможность налету переводить окты и хексы в битовый вид.


возвращаемся к нашему исхоному примеру.
у нас есть файл в котором есть байты. я их 
распечатал в трех разных методах отображения байтов


(dec) 118  97 115 121  97  13  42  42  10 118  97 115 121  97  10
(hex)  76  61  73  79  61  0d  2a  2a  0a  76  61  73  79  61  0a
(oct) 166 141 163 171 141 015 052 052 012 166 141 163 171 141 012

dec вобщн бесполезен для трансформации в 010011 вид
hex сложноват ибо за одним символм кроется аж четыре бита
oct самый простой для визуальной трансформацмии  в 010 вид ибо за одним символом кроется всего три бита.

берем строчку

(oct) 166 141 163 171 141 015 052 052 012 166 141 163 171 141 012

уже находу я могу много ее кусков перевести на лету в битовый вид

(oct) 001хххххх 001ххх001 001хххххх 001111001 001ххх001 000001ххх 000хххххх ...


потмому что в oct виде 1= 001, 7= 111, 0= 000

тоесть даже помня всего две цифры в битовом виде ( один и семь) я уже сразу 
существенно понимаю как в битовом виде выглядят байты в файле. это огонь.

еще раз в чем прикол oct и hex счислений.
инфо на диске ханится в виде байтов.  байт состоит из битов.
в конечно итоге на диске хранятся биты.
0101010100101101010101010101010110101011010101001

тоесть инфн на диске хранися в двоичной системе
отображать инфо в форме битов (двоичная систе) очень громоздко накладно.

далее можно конечно всмопнмить что все таки в прграмму инфо считывается в форме байтов тоесть
в группах по 8 бит. 

далее мы можем отобразить каждый байт в dec системе  тогда соедержимое файла это будуц
цифры то 0 до 255

123 111 000 007  012 017 итп

в чем минус такого отображения что налету из dec числа трудно его преобразить в битовый вид.
а нам порой это хочется. также если у нас есть небайтовый вид а битовый

010101001010101010101010 

то его вобще  в dec отобразить сложно

толидело когда мы юзаем oct

для того чтобы байт отобразить в oct надо просто напросто разбить его на группу по три бита

aabbbccc  правда у нас нехваетает одного бита но вместо него добавляем незначащий 0
тоесть

0aabbccc

а далее мы ищем для каждой группы просто цифру по таблице. пример

11010110 = 11 010 110 = 011 010 110

таблица


0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111

получаем

011 010 110 = (oct) 326 

вот так мгновенно и легко мы биты превратили в oct
более того нам похеру сколько у нас бит в потоке. 

берем поток 
0101010110101010110101010110100110

разбиваем его на группы по три. применяем таблицу и получаем это число  в oct виде.

тоже самое для hex счисления. только там группы по 4 бита и таблица на 16 символов.

таким образом бинанрный вид биты можно буквально на лету трансофирировать в oct поток
ну и если чуть более постараться то и в hex поток.


верна и обратная задача . если есть oct число  то его супер легко трансформироваь в битовый вид

пример

(oct) 24577453562 = 010 100 101 111 111 100 101 011 101 110 010

все по тойже таблице
 

таблица


0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111

просто берем цифру и ее превращаем в три бита.

это все просто супер. и в тоже время для dec преобразований вида dec -> bin , bin -> dec
ничего подобного неработает. в этом и фишка hex и oct счислений.

в следущей части я разобрал почему 377 (oct) в bin виде имеет четко 8 бит а не 9бит
как это нам казалось.
============
bit, byte
octal 
bin

прежде всего байт это группа битов в размере 8 штук. (как кучка семечек которых 8 штук)
а что такое бит. бит это некая хрень которая может принимать два значения. условно
 говоря либо значение "a" либо значение "b". бит это чисто математическое понятие
 тоесть абстрактное. физическим носителем бита может быть что угодно. например кружка воды.
 она может быть полная или пустая. далее нужна некая система которая будет считывать 
 физический носитель бита и выдаваь нам такое: бит (состояние ) = полный\пустой. 
 или бит(состояние) = жив\мертв
 далее нам же похеру каким физ свойством закодировано состояние бита нам главное 
 понимать суть состояния. поэтому далее некая машина нам преобразует физ свойство в
 мат величину. например. полный = a, пусто = b
 получаем 
 bit = a
 или
 bit = b

 далее вспоминаем что в байте битов у нас 8 
 значит мы имеем группу сущностей вида abbababa
 вместо a и b можно заюзать 0 и 1
 получаем 

 байт это множество вида 0100110
 причем байт это непросто множество битов а оно еще и упорядоченное то есть
 у битов есть порядковые номер тоесть биты нельзя переставлять местами

 ну хорошо у нас куча байтов

 01010101
 01010110
 01001010
 01010101

 тоесть некая система нам генерирует эти байты.

 далее можно этому обьекту сопоставить число. потому что по случайности 
 ровно такой же вид имеют числа в бинарной записи

 таким образом у нас абстрактный мат обьект как бы превратился в число.
 ну или мы можем всяегда для байта найти однозначное сооовествие в форме числа которое 
 имеет такой же вид в бинарной системе счисления.

дален интересно. если у нас есть bin число то мы всегда можем его 
преобразовать по алгоритму в dec число

01001011 =  (2^7)*0+ (2^6)*1+ (2^5)*0+ (2^4)*0+ (2^3)*1+ (2^2)*0+ (2^1)*1+ (2^0)*1= 75 (dec)  

(oct)64*x+8*y+1*z=(dec) 75
x=1

8*y+z=11
y=1

z=3

113 (oct) = (dec) 75
из верхнего мы уже знаем что (dec) 75 = (bin) 01001011

полуаетчся что 113(oct) = (bin) 01001011
далее мы берем цифры 113 и смотрим что
1(oct) = (bin) 001
3(oct) = (bin) 011

и мы замечаем что 113 (oct) = 010 010 011 где каждые три бита представляют собой его же цифры.
010 = 1(oct)
010 = 1(oct)
011 = 3(oct)

берем 255 dec

255(dec) = 11111111 
255(dec) = 64*x+8*y+z
x=3
8*y+z=63
y=7
z=7

значит

255(dec) = 377(oct)

значит 377(oct) = 255(dec) =  11111111
значит
377(oct) = 1111 1111

теперь посмотрим а какой бинарный вид имеют цифры в числе 377(oct)

3(oct) = 3(dec)=(bin) 011
7(oct) = 7(dec) = 111

выпишем рядышком 3(oct)7(oct)7(oct)= 011 111 111 = 0 1111 1111

сравниваем 377(oct) =   1111 1111
и 3(oct)7(oct)7(oct)= 0 1111 1111

видно что из второго числа можно получть первое если отбросить лидирующий ноль.

получаем такое правило: если мы хотим преобразоать oct в bin то прямой способ точный 
это преобразовать oct в dec а уже dec в bin. но есть быстрый способ - берем каждую цифру 
в oct числе. преботазауем ее в bin. потом записываем вместе все биты и отрасываем головной бит "0"

посмотрим а может ли быть такой вариант что головной бит будет "1"
мин число в бинарном было бы вида 100 000 000 = 1 0000 0000 = 1 0000000 . тоесть это число
уже больше чем 1 байт. 
также посмотрим из каких oct цифр 100 000 000 оно бы состояло = 4(oct)0(oct)0(oct)
(oct) 400 > (oct) 377
тоесть если мы говорим о преобразовании oct чисел не превышающих байт то 
вышеописанное правило точно работает.

прикольно что правило oct -> dec -> bin это реальное правило преобразования
а правило (oct) abc -> a(bin)b(bin)c(bin) минус лидирующий бит "0" это некая удачная эмпирическая формула. поэтому то мы ноль и убираем чтобы подогнать эмпирическую формулу под строгий мат результат. поэтому то 377 (oct) и занимает 8 бит а никак не 9 бит. 9бит это чисто погрешность
эмпирической формулы.

еще раз почеркну что полноцеееный способ перевода октал в бин это октал перевести в дек
а дек перевестив бин. а способ кодга мы еберем цифры в окт и каждую раскладываем в три бита
а потом собираем вместе это эмпирическая формула поэтому то она в случае с (oct)377 и дает
девять бит. тоесть эмпирическуб формулу надо использовать с поправкой в итоге. никаких девяти
бит там нет. также стоит заметиь что для бин числа что  11 что 00000000011 это одно и тоже 
поэтому вобщем и целом эмпирическя формула дает верный результат даже без поправки

============
откуда 
скачал intel книжки по cpu 

https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html


============
octal 2 byte

если записать в файл символы "1 " (один  и пробел)

$ echo -n "1 " > ./text1

далее мы читаем этот файл через od в режиме oct и в режиме когда поток байтов в файле
разбивается на биты и далее обьединяется в группы размером 1 байт

$ od -t o1 ./text1 
0000000 061 040

0000000 это просто адрес офсета смещения относительно начала файла.
(oct) 061 отвечает за "1"
(oct) 040 отвечает за " "

пока все нормально все ожидаемо.

далее мы читаем этот же файл в режиме когда считыаемый поток разбивается на биты а потом
эти биты обьединяется в группу по 2 байта.

$ od -t o2 ./text1
0000000 020061


 пеерведем байты в биты

(oct) 061  = 00 110 001 = 00110001  
(oct) 040  = 00 100 000 = 00100000  

(oct) 020061 = 0 010 000 000 110 001 = 00100000 00110001

ожидалось что мы будем иметь 
00110001 00100000 = 0 011 000 100 100 000  ( oct 030440 )


а программа показала нам что на диске
00100000 00110001 = 0 010 000 000 110 001  ( oct 020061 )

тоесть байты поменяны местами.


на самом деле вот в чем дело. на диске биты байтов записаны в порядке
little endian. это значит что первым на диск пишется LSB (least siginificant bit тот который
2^0) а последним пишется MSB (most significant bit тот который 2^7)

берем (oct) 061 = 0011 0001 он будет записан на диске вот в таком виде 
(начало файла) --> 1000 1100

после него (oct) 040  = 0010 0000 будет записан на диске в виде
0000 0100

и таким образом оба байта будут записаны на диске виде битовой последовательности
(начало файла) --> 1000 1100  0000 0100 --> (конец файла)

при этом еще раз бит с 2^0 он находится несправа как мы привыкли а слева в каждом байте

еще раз битовый вид как мы ожидали

00110001 00100000

а вот как по факту 

10001100 00000100

как видно сами байты расположены в томже порядке. но каждй байт зеркально отражен 
относительно своей середины. потому что (еще раз) комп пишет биты байта в файл начиная с младшего
бита а не старшего. потому что intel цпу они хранят байты в оперативке а значит и на диске
согласно "little endian" правила. мы же обычно на бумаге записывем биты в порядке "big endian" 
чего нет на цпу интел. точнее в регистрах цпу интел тоже биты хранятся в режиме big endian но в
оперативке и походу значит на диске биты хранятся в порядке little endian.

еще раз покажу где находится 2^0 бит в файле как мы полагали 

    (начало файла)-->  (2^7)00110001(2^0)    (2^7)00100000(2^0)

а вот как по факту они записаны в файле

    (начало файла)--> (2^0)10001100(2^7)     (2^0)00000100(2^7)



собственно далее как происходит расшифровка битов в случае файла с big endian.

есть поток битов
01010101 10101010 1011010 1010101...

мы говорим что мы хотим его расммотреть в разрезе скажем по три байта. выбираем первые 
три байта
01010101 10101010 10110101

если кернел знает что биты записаны как big-endian то комп их расшифроваывает вот так:
(2^23)--> 01010101 10101010 10110101 <--(2^0)

если же кернел знает  что биты записаны как little endian то он эти же биты расшифроывает как
(2^0)--> 01010101 10101010 10110101 <--(2^23)


покажу на примере как выглядит разбивка потока битов в файле скажем когда мы хотим 
посмотреть разбивку по 2 байта

(2^0)01010101 01010101(2^15) (2^0)010101010 00101010(2^15) (2^0)10101010 10101010(2^15) (2^0)10101010 10101010(2^15) (2^0)10101010 10101010(2^15) (2^0)10101.. 


получаетс чтобы правильно понимать как записаны биты байтов в файл надо знать какой endian
юзатеся на компе. тоже самое для обратной задачи. если мы читаем биты с файла то чтобы их 
интерпретровать в байты надо знать как endian юзается на компе потмоу что одна и таже последова
тельность битов можно интерптретировать двояко


(2^0)01010101 01010101(2^15)

либо

(2^15)01010101 01010101(2^0)

 биты одни и теже. а числа будут разныве в итоге.




еще раз возьмем исходный пример

(oct) 061  = 00 110 001 = 00110001  
(oct) 040  = 00 100 000 = 00100000

пишем 061 на диск. пишем как bigendian. первым пишем старший бит в байте.
00110001

далее пишем 040 получаем 

00110001 00100000

далее читаем биты и  интеретируем помня что это bigendian

(2^15)00110001 00100000(2^0) = 0 011 000 100 100 000 = (oct) 030440


теперь пишем на диск тот же 061 и 040 но используем little endian тоесть первым на диск
идет младщий бит байта

10001100 00000100

читаем эти биты помня что это litle endian.

(2^0)10001100 00000100(2^15)

переписываем эти биты в стандарной бинарной нотации

00100000 00110001 =  0 010 000 000 110 001 = (oct) 020061


теперь понятно почему мы получили 020061

$ od -t o2 ./text1
0000000 020061



далее. запишем в файл "1 1"
$ echo -n "1 1" > ./text1

посмотрим побайтно
$ od -t o1 ./text1 
0000000 061 040 061

попробуем предсказать как будеь выглядеть ответ если мы посмотрим потрехбайтно.


(oct) 061  = 00 110 001 = 00110001  
(oct) 040  = 00 100 000 = 00100000

на диске "1 1" в битовом виде с учетом того что комп их туда пихает в виде little endian
будет вылядеть как

10001100 00000100 10001100

далее мы вспоминаем каков порядок битов в little endian

(2^0)10001100 00000100 10001100(2^23)

перепишем биты в стандартной нотации бинарной

00110001 00100000  00110001 = 001 100 010 010 000 000 110 001 = (oct) 14220061

проверяем на компе

$ od -t o3 ./text1
od: invalid type string ‘o3’;
this system doesn't provide a 3-byte integral type

хахаха! od неподдерживает трехбайтовый вид.

прикольно что и hex трехбайтовый неподдерживается утилитой od
$ od -t x3 ./text1 
od: invalid type string ‘x3’;
this system doesn't provide a 3-byte integral type




endiness зависит от модели цпу.




пока что я понял вот что. кернел для процесса в памяти создает page table в которой записан 
маппинг между вирт адресации памяти ( с которой оперирует программа в юзер спейсе) и физ памятью.
между цпу и шиной памяти стоит mmu железка. цпу всегда оперирует внутри себя тоесть знает
только вирт адресное пространство. как он он физ адресацию незнает невидит не вкурсе.
цпу обращается к вирт адресу. запрос от цпу приходит на mmu. как я понял в регистр CR3 цпу кернел
записывает адрес в физ памяти с которого начинается page table для текущего процесса. так что mmu читая тот регистр знает где ей в физ памяти искать page table. таким образом mmu для вирт адреса
в оперативке в page tabe находит физ адрес. этот адрес mmu и выставляет на шину адреса памяти
для запроса. 

таким образом работа кернела в том чтобы в памяти для процесса создать page table
заполнить ее а в цпу в CR3 регистр пихнуть адрес page table. после этого работа ядра по настройке
mmu закончена. а mmu имеет все для того чттбы сделать свою работу -> преборазовать вирт адрес
в физ адрес.

context switch. это коогда мы из цпу выдавливаем все инфо от одного процесса
и загружаем в него инфо от друого процесса. как я понял это на данный момент истории происходит
так - шедулер ядра копирует значения регистров цпу в память в область ядра. в ту структуру 
в памяти которая описывает процесс. далее шедулер загружает в цпу в регистры значения регистров
того процесса который будет следущим запущен на цпу. когда все регистры загружены то 
шедулер копирует как я помнимаю в спец регистр адрес начала кода нового процесса на который
мы будем пеереклчаться. и далее как я понимаю происходит (неким образом)возможно чеерз int 
возврат цпу из режим ринг 0 в ринг 3. и процессор получетя имеет все регистры с данными от процесса
и также начинает иполнять ту команду ссылка на которую у него хранится тоже в спец регистре.
так что вуаля - новый процесс начнет выполняться в тайм слайсе. фишка главная в том что context
switch это не какая то там особая секретаня загадочная процедура а просто тупо баналоьно упрощенно
говоря шедулер(кусок кода ядра) копирует регистры от процесса в память в таблицу информации
 о процессе или наоборот из памяти в цпу.  руками как говорится. есть еще и процесс
 когда сохраннеиео инфо о регистрах можно делать неруками и типа одной командой цпу (тоесть hardware context switch) но типа он якобы менее гибкий ибо сохраняет все регистры а это может 
 быть и ненадо и типа и медленней. ведь каждый регистр сохранить это обращение к памяти поэтому 
 ручное сохранение происходит  типа в кончено итоге быстрее.


=========
bios 

окаывается что это просто программа. просто кусок кода.
который хранится условно говоря на флэшке внутри компа.

цпу так устроен что он когда стартует то лезет читать данные по определенному адресу
в RAM. и так устроено что содержимое биоса маппится или копируется (незнаю) по этому адресу
таким образом цпу начинает исполнять программу кода биоса.

=====
640k mem

на счет цпу вначале истории линейки от интела.
было 4004 и 8008 и 8080 и потом был 8086.

так вот все текущие процессоры по крайней мере которые 32 битные (тоесть не 64 битные) 
они все в режиме real mode если им подсунуть один и тот же exe (бинарный) файл
то они все его выполнят без проблем. что 8086 что условно говоря pentium 4.
тоесть коды команд в бинарном виде ( оп коды) кодируют на всех этих цпу одни и теже
команды. тоесть у всех цпу начиная от 8086 и выше бинарная совместимость. не говоря уже
про source code совместимость. естственно она совместимость обратная тоесть коод от 8086
прокати на p4 но не наоборот.

так вот все цпу начиная с 8086 тоесть >= 8086 они совместимы в том смысле в котором уже
описал. а вот скажем 8080 и 8086 уже несовместимы ни на уровне source code ( команда асемблера которые еще нужно откомпилировать) ни на бинарном уровне ( готовые exe elf файлы).
если вы брали откоипилированный файл для 8080 то он неработает на 8086.
если взять txt файл с асемблером от 8080 то его неоткомпилует комплиятор для 8086.
итак эти цпу несовместимы. единственное что была программа которая шла к 8086 которая преобразо
вывала текстовый файл с асемблером от 8080 в текстовый файл с асемблером для 8086.
но это несовместимость это преобразование одного асемблера в другой. а потом уже компиляция комилятором для 8086. итак эра 8086 началась с процесссора 8086. об более древних можно забыть.


возврашаепся к исходному вопросу : изучаем откуда взялся этот лимит памяти 640k

для этого берем цпу:

intel 8088

сразу скажу что 8088 это ровно такой же 8086 но у него обрезана шина данных с 16 бит ( как у 8086)
до 8 бит. вот и вся разница. это позволило присобачивать этот цпу на мат платы которые (как я понял
из книжки морзе который автор цпу) были предназначены ранее под 8080. в любом случае так как 
шина данных имела не 16 а 8 бит это экономило стоимость мат платы компа. да из того что я понял
8 битная шина данных почемуто делала его совместимым с кучей перифериных микросхем которые
до этого употреблялись для мат плат с 8080 который был 8 бит и хотя как я уже сказал 8080
и 8086\8088 были несовместимы на уровне бинарном(откомпилированных файлов) и уровне source code
(на уровне тектовых файлов с асемблером которые нужно компилировать еще) но на уровне микросхем 
которые крепились на мат платы 8 шина данных от 8088 делала его совместимым с периферийными 
микросхемами и это было круто чтобы чип сразу пошел в рынок под него ненужно было изготаливать
перифериыные микросхемы. 

что еще супер примечательно - именно 8088 цпу выбрал ibm для своего первого ibm pc. того
самого с которого началась эра ibm pc персоанльных компьютеров.


прикольно то что в фирменных документах от интел он назван как 8-битный.
а на самом деле щас его относят к 16 битным.
разберемся:

это 16 битный процессор. 
что значит что процессор столько то битный. например 16 битный. это значит нето что он обязан иметь возможность адресовать память размером 16 бит (шина адреса  16 бит). нет.
это всего навсего значит что  в цпу регистры общего назначения (да есть такие там регистры) имеют 16 бит. и все! опять же это незначит что ширина шины данных 16 бит. нет! у процессора могут быть
регистры по 16 бит а шина данных 8 бит. 
воюбще это забавно. текущие 64 битные процессоры имеют внутри себя 64 битные регистры
а в памяти то байты по прежнему имеют размер 8 бит.  

что дает то что у цпу регистр имеет столько то бит. например 16 бит. это значит
что цпу может взять такой регистр выполнить сложение  с другим таким же регистром.
это будет математическая операция. в чем разница если бы в цпу были 8 битные регистры в чем
улучшение. в том что на регистрах в 8 бит мы можем выполнять математику на числах по 255



разница его с 8080 8086. (уже описал выше) 


термины:
byte = 8bit
word = 16bit

8088 его способ доступа к памяти. способ адресации ячейки памяти. способ указания
адреса ячейки досутп 1 048 575.

данный цпу имел шину адреса шириной 20 бит.
в двочной системе на двадцати битах можно закодировать числа от нуля до 1 048 575.
1 048 575 это 1 Mбайт в двоичной системе.
1 048 575(dec) = 11 1111111 111111 (bin)

таким образом через 20 битную шину адреса можно адресовать миллион ячеек памяти. 

1MB (dec) обозначается в hex счислении как FFFFF

1MB = FFFFFh

таким образом мы узнали какой обьем RAM памяти способен был адресовать данный процессор.

Далее прикол в том что внутри процессора небыло 20 битного регистра в который бы можно было 
совать значения чтобы напрямую адресовать ячейки из памяти. типа выставил биты в 20 битном регистре
и таким образом обозначил в какую ячейку памяти ты хочешь иметь доступ. такого там небыло чудо 
регистра.

внутри цпу были только 16 битные регистры. так что чтобы получить доступ к ячейке памяти 
надо помудить.

значит адрес по которому хранится следующая команда на исполнение вычислялся так:
берется два регистра: CS регистр 16  битный + IP регистр 16 битный.

далее цпу делал так, он брал CS и добавлял к нему 4 бита нулевых справа

был CS(FFFFh): 1111 1111 1111 1111 
стало(FFFF0h):         1111 1111 1111 1111 0000

далее цпу брал регистр IP и складывал с тем что стало

IP(0001h): 0000 0000 0000 0001


сложение(FFFF0h+0001h):

	1111 1111 1111 1111 0000
+	     0000 0000 0000 0001
   ------------------------
    1111 1111 1111 1111 0001 (FFFF1h) 

 получаем что цпу хочет обратится к ячейке с адресом FFFF1h = 1 048 561  байт
вспоминаем а сколько байт в  1МБ (1 048 575).

далее вопрос а если вот такую компбинацию зададим

	1111 1111 1111 1111 0000   (FFFF0h)
+	0000 1111 1111 1111 1111   (FFFFh)
   ------------------------
  1 0000 1111 1111 1110 1111   (10FFEFh) 

10FFEFh = 1 114 095 > 1MB (1 048 575) 
непонятно что происходит с цпу когда он указывает на адрес в памяти больше чем 1МБ
скорей всего так как ответ превышает 20бит то какой нибудь флаг срабатывает о переполнении
и цпу посылает нахуй такой адрес потому что физически на линии адерса всего 20 линий так что
двадцать первая линия там никак неможет повятся. как я понимаю если резудьтат сложение CS+IP
дает резудльтат больше чем FFFFFh то срабыватет флаг об ошибке.


далее комбинации:
CS:IP -- code segment:instruction pointer points to the physical address of the next instruction in memory to execute.
SS:SP -- stack segment:stack pointer points to the stack in memory, a temporary storage place for data.
DS:DI -- data segment:destination index points to the physical address in memory where data is to be stored using a pointer.
DS:SI -- data segment:source index points to the physical address in memory where data is to be retrieved using a pointer.

пока все равно непонтно откуда появляется ограничение на 640К по памяти ? (забегая вперед
я вроде нашел откуда ограничение 640к. в компах от IBM использовался memory map io. это 
значит что между цпу и памятью стоят memory arbiter. запросы от цпу по шинне адреса шли на мемори
арбитр и все запросы по адресу выше 640к он переадресовывал на периферийные устроуства. для цпу
это выглядело как запросы к паяти выше 640к а на самом деле шел доступ к регистрам перифеиных
устройств. вот и весь секрет как был сделано ограничение на 640k памяти со стороны ibm)



=====
8086\88

на счет мульттаскинга

в книге указано что  адрес памяти задается через комбинацию двух регистров.
например CS+IP получаетс в форме segment+offset.

в книжке написано что типа это дает следущее удобство - что операционная система сможет 
контролировать регистр сегмента а пользовательская программа будет иметь свободный доступ
к регистру смещения. значит  можено будет удобно иметь несколько программ в оперативке 
которые непересекаются в памяти.

при этом я непонял каким образом ОС будет захватывать контроль над сегментым регистром
как я понял у 8086\88 нет такого мехагизма потому что у него нет колец. поэтмоу каждая прога
имеет полный доступ к цпу со всеми его функциями. 


также по поводу мультииаскинга. как это на практике в этом цпу можно настроить.
прочел что только кооператиный мультитаскинг . что это. это значит что программа пользоваетьская
должна быть написана так чтобы она САМА периодичеки возращвала упралвение операционной системе.

все таки непонятно. как я понимаю ограничение в 640к это не желеное ограничение не хардварное
а софтварное со стороны самой DOS. так если программа запускаемая в дос получала полный доступ
к цпу то ей по идеебыло глубоко похер на то что думает дос. и она могла лазить по любым адресам.
непонятно. абсолютно непонятно. у прцоессеесаора небыло протектед режима так что любая программа
лазила напрямую в память и плюс имела полный доступ ко всем функциям цпу потому что также
небыло никаких колец. програме ничегонемешало лазить по адресам выше 640К. непонятно.
возможно тут фича в том что программа в досе которая запускалась она непросто сама посебе
на асемблере все функции работы в себе имел а опиралась на api который предоставлял дос.
таким образом вожмно если программа скажем хранила свои данные за пределом 640к то возможно
если дос нужно было туда слазить то дос писало что мол программа корявая нарушает договоренности.
может как то так ?

пока про это все

=====
8086

состоит из двух частей
каждля из которых работает асинхронно от второй

блок EU он выполняет команды
блок BUI он качает данные из памяти и в память.

как   я понял то что два блока рабоиают асинхронно называется pipelining в цпу

в BUI находятся сегментые регистры и IP регистр
в EU находятся регистры общего назначения
=====
8086

регистры

наскько я понял адрес стека задается через SS:SP
непонятно что делает BP регистр. как я понял в ряде случаев вместо SP юзается BP 
но когда и зачем непонятоно
====
8086

как я понял если шина простаивала то цпу его bui блок автономмно подкачивал команды
в размере 6 штук и клал их в спец регистры (без имени) это типа как предикитианый механизм
чтобы некачать команды а уже их иметь . типа кэш команд. как я понял команды он брал
начина я с адерса CS:IP
====
8086

пра работу с памятью. как мы помним 8086 имеет 16 битную шину данных. тоесть он качает 
всегда 2 байта за раз. 

так вот на шине адреса как я понял всегда выставляется только четный адрес в независимости
что мы прописали в команде.

а именно если мы напишем

mov BX, [00520]

то так как он четный то гнашине адреса будет выставлен 00520h
и за один проход будут скачаны ячейки 00520h и 00521h и засунуты в BX

а если мы наппишем

mov BX, [00521]

то тут начнется хитрое. получается посольку у нас регистр BX двухбаыйтный то получается мы 
хотим скачать два байта и указали первый. получается мы хотим скачать байты 00521+00522
тогда цпу выставит на шине адреса адрес 00520 и скачает 00520+00521 за раз. отбросит значение из 00520
и засунет 00521 в BL. далее еще раз выставить на шине адреса адрес 00522 скачает 00522+00523
отбросит 00523 и засунет 00521  в BH.

таким образом если мы задаем четный адрес то он слово скачиывается за 1 такт.
а если мы задаем нечетный адрес то слово скачивается за 2 такта.

интреано!
 
====
8086

сегмент это количество байтов у которых оффсет лежит в диапазоне  
от 00000000 00000000 до 11111111 11111111 

поскольку  
 11111111 11111111 это 65535 то плюс еще нулевой адрес и мы получаем 65536 штук байтов.

далее мы вспоминаем что в 1KB = 1024 байт. тогда делим получаем

65536 : 1024 = 64KB

в сегменте 64 килобайта 
===
8086

interrupt

какие регистры цпу сам самостоятельно автоматически сохраняет прежде чем переключиться на ISR(Interrupt Service Routine):
    When an interrupt occurs, the CPU does the following:

    Push the current address (contents of the Instruction Pointer) onto the stack; also, push the processor flags (but not all the other processor registers)
    Jump to the address of the ISR (Interrupt Service Routine), which is specified in the Interrupt Descriptor Table.

если цпу 32 битный значит сохранение IPE(32bit)+Flags register(32bits) = 16 байт укладывается в стек. если цпу 64битный то 32байта укладывается в стек. А в какой стек юзерский или ядерный? ответ - вот в каком режиме (ring0 или ring3 работал цпу ) цпу работал в тот стек он и уложит.

теперь про ISR:
    The ISR should do the following:

    Push any registers which it intends to alter (or, push all registers)
    Handle the interrupt
    Reenable interrupts
    Pop any registers which it pushed
    Use the IRET instructions, which pops the CPU flags and Instruction Pointer value from the stack (and thus returns to whatever was executing when the interrupt occured).

у этого цпу есть ножка которая сигнаизирует цпу об прерывании от железок

также я так понял что прерываение можно инициировать и софтеверно

я не очень понял как одна ножка это же один бит по факту так вот как одна ножка
позволяет цпу различать номер прерывания.

первые 1024 байт 0000-03FFh в RAM зазерезированы под таблицу interrupt vectors
содержит адреса кода в RAM обработчика события интерапта

одна запись это 4 байта. потому что адрес обрабочика хрнаится в виде Segment:Offset
поскольку каждый по 16 бит то в итоге 4 байта на один вектор. 
значит 1024\4 = 256 штук векторов под 256 разных прерываний.

также последние 16 байт в памяти FFFF0h - FFFFFh зазервериврованы я так понимаю под маппинг кода биоса или его куска или чтото типа того. потому что после сигнала RESET 8086\88 бросается
исполнять код исключительно по адресу FFFF0h

NMI и INTR это hardware interuts
INT n это software interrupts


maskable interrut это такой который может быть проигноиррван или отменен
uunmaskable который несможет цпу ни проигнорироваь ни отменить


интерапт можно активировать програмно но щас интересует больше хардварный метод.
итак на ногу цпу прилетает сигнал что есть интерапт.
он кладет флаги в стек, дизейблит дальнешее получение сигнала о следущем интерапте, и 
считывает по дата bus один байт в котором находится типа номер интерапта. (тут интересный 
момент в том что цпу получает байт по шине данных при этом невыставляя ничего не шине адреса как я понял)
далее он этот номер интерапта умножает на 4 и читает из памяти по адресу "номер интерапта*4" где
же находится процедура обработки этого интерапта.

например NMI немаскируемое пррываение имеет номер интерапта 2. поэтому цпу обращается к
памяти по адресу 2*4=8 тоесть адрес= байт номер 8 и оттуда он считывает адрес процедуры
которая обрабаыавет немаскируемый интерапт.

ну теперт хоть сталоп онятно как цпу различает интерапты между собой. я так примерно понимаю
что номер интерапта который летит в цпу по дата басу его туда засоывает контроллер интераптов. 

спасибо индусу = https://nptel.ac.in/content/storage2/courses/106108100/pdf/Teacher_Slides/mod1/M1L3.pdf

далее индус пишет что софтвейр интерапт имеет номер 3. хм... так что получается что софт интер
апт всегда будет иметь запись в вектор таблице по адресу 3*4 ? а как же тогда номер интерапта
который укаызвается в команде INT <номер интерапта> ?

вобще я так и непонял что получает цпу по дата шине толи номер интерапта толи его приоритет.а!
походу это одно и тоже! номер интерапта он же его приоритет! он же его тип. так тоже бывает 
называют.

NMI интерапт. на серверах есть кнопка тыкая которую мы активируем на цпу nmi интерапт. 
что обычно вызывает немедленное прекрашение выполннения кода и старт выполнения хэндлера nmi интерапата. спрашивается захера эта кнопка нужна. 
как я понял типа ее назначение такое - у нас завис сервер и мы хотим снять дамп памяти чтобы разобраться что с ним было. если тыкнем ресет то ничего неузнаем а если тыкнем nmi то во первых
как бы ни завис сервер цпу 100% прекратит выполгнять то что оно выполняло и кинется выполнять
хэндлер nmi интерапта. и как я понял в том хэндлере можно прописать чтобы был снять дамп всей 
памяти.

при поступлении интерапта цпу помещает в стек регистры с флагами CS:IP регистры, также 
устаналиватс в ноль флаги TF и IF. TF если равен 1 то цпу будет выполнять одну команду а затем
цпу сам будет генерировать прерываение номер 1 и будет выполгнять вектор для этого прерывания.
так как мы уже заняты обработкой прерывания то комады которые мы будеи выполнять по адресу вектора
прерывания нам нужно выполгнить без всяких остановок так что TF надо поставть точно в 0.
когда потом вернемся из векторп прерыания и вытащим регистрс флагами то если там был установлен
Tf=1 то он будет восстановлен. IF=1 дает то что если он устаролвен то цпу может принимать 
сигнал об интераптамх и исполнять их. а если мы поствим IF=0 то прилетающие сигналы об интераптах
будут игнорирваться . это имеет смысл ибо мы уже заняты обоработкой интерапта.



итак еще что происходит когда цпу обрабатывает интерапт.
если от внешнего устройства через ногу на цпу приетает сигнал - то цпу понимат что 
надо запустить интерапт. интерапт через ногу - это внешний хардвейр интерапт.

также интерапт можно инциировать из порограммы через команду int n это софтвейр интерапт

также цпу сам может инциировать интерапт например когда он поделил на ноль. 

значит  при интерапте цпу надо узнат какой номер у интерапта. еслт это хардвейр интерапт 
через ногу то тогда контроллер интерапта (как я понял)  по шине данных посылает на цпу 
один байт в котором указаон номер интерапта.

если это програмный интерапт то int n указывает номер интерапта.

если это сам цпу гененирует интерапт типа при делении на ноль то цпу уже знает какой интерапт
он генениририует.


итак имеем номер интерапта.

цпу кладет CS:IP в стек.также обнуляет флаги TF и IF

далее он умножает на 4 номер интерапта. получаает адрес в памяти откуда он счиывает
два байта.  младщий байт он кладет в IP старший кладет в CS . далее юзая CS:IP он 
качает команду из памяти. и начинает ее выполнять. таим образом в RAM по адресу CS:IP
должна леджать процедура обработки интерапта. выход из процедуры пооисходит по команде IRET.


тут важно отметить что часть интеравтов уже заранее заняты предопределены.
напрмиер


номера интераптов:

0) деление на ноль
int 0  = автоматом генерируется саимим цпу при делении на ноль.

так как номер = 0 , то 4*0 = 0

значит цпу лезет по адресу 0000h и 0001h и качает этт два байта в IP
далее он лезет в 0002h + 0003h и качает эти два байта в CS

итак считыватся байта 0000h,0001h,0002h,0003h

и потом он лезет по адреу cs:ip и ищет там обаботчик деления на ноль.

важно отметить что это анмаскабл интерапт. то есть цпу в него 100% впадет если мы поделим
на ноль. так что от него нескроешься

1) single step interrupt

если мы установим флаг TF.

то цпу после выполенения каждой команды будет сам автомтом вызывать интерапт 1.
эта хрень юзается при отладке программ.

это наверное тоже анмаскабл хотя я незнаю

из таблицы векторов считываются байты

0004h, 0005h, 0006h,0007h


2) NMI

это точно анмаскабл.

происходит от нажатия на кнопку на корпусе компа ( на серверах она таакая есть).

из таблицы векторов считыватся байты c 8-го по 11-ый


3) one byte interrpt

это софтвейр интерапт.
он вызвыается чрез 

int3

исполщуется для дебагинга как точка остановки. еси мы посмтеим в программе 
комаду int 3 то будет сделан интерпапт и цпу выполнит  обрабочткик интерпатпта по 
адресу 3*4 = 12 (dec) = 000Сh адресу

если у нас линукс и мы в нем запустим откомпилированную программу на асемблере
в которой будет команда int3 то в ответ на эту команду ядро линукса убьет процесс создаст 
на диске dump памяти процесса. в терминале появится надпись "Trace/breakpoint trap (core dumped)".
если запускать программу в связке с strace то он покажет что был получен сигнал SIGTRAP.
что значит процесс получил сигнал. это значит что в ядро прилетел сигнал и ядро этот сигнал 
записывает в таблице свойств процесса. когда в очередной раз шедулер собирается пихать процесс
на цпу то он проверяет нет ли какого сигнала который процесс должен обрабоать. если есть
то (как я понимаю) шедулер вместо того чтобы пихать на цпу процесс он запустит обработчик 
этого сигнала при условии что программа когда запускалась то она зарегистрировала в ядре 
обработчик. если прога этого несделала то шедулер запускает для этого сигнала дефолтовый обработ
чик на стороне ядра. дефолтовое действие на сигнал SIGTRAP это убить процесс и записать 
на диск его дамп. что ядро и сделало. в целом я полагаю что цепочка работает вот так: 
на цпу оказывается команда int3 это заставляет цпу запихать регистры в стек. далее цпу запускает
обработчик прерывания считав адрес обработчика из 3*4=12 байта в памяти. 
ну и видимо тот обработчик прерывания запускает кусок кода ядра который генерирует сигнал SIGTRAP
для нашего процесса. генерирует это значит что как уже сказал что в таблицу информации процесса
записвается доп поле что этот процесс получил свойство SIGTRAP. потому что да что значит процесс
получил сигнал. это по факту значит что структура данных в ядре которая описывает свойства 
процесса получила новое свойство. вот и все. сам процесс при этом вобще ничего нечуствует
и незнает тоесть навход всяких там файловых дескрипторов которые открыты у процесса ничего не
прилетает. тоесть область оперативной памяти самого процесса вобще не вкурсе ни о каких сигналах.
появляется запись в области ядра а не вобласти памяти процесса. поэтому в целом эта фраза 
что процесс получает сигнал это херня. получает сигнал ядро. это как сказать что младенец получил
пособие по рождению. его получает немладенец а его родичи. так и здесь. процесс никакой сигнал в форме входящего потока информации на свои открытые файловые дескрипторы неполучает. получает 
ядро - одик кусок ядра сообщает другому куску ядра что вот этот процесс получил новое свойство.
это изовется тем что "процесс получил сигнал". этот сигнал он недля кода процесса он для 
шедулера для куска кода ядра. сигнал о том что для данного процесса нужно вызывать обработчик
данного сигнала. если сравнить процесс с дельфинами то фраза "дельфины получили сигнал" по факту 
значит что сигнал о делфинах получили их дрессировщики что их надо кормить. и обработкой сигнала
занимает ядро а не код процесса. единственное что ( как я понял ) для ряда сигналов процесс при запуске может в ядре зарегистрировать действительно свой обработчик. тогда при "поступлении сигнала" шедулер запустит код обработчика который зарегистрировал  процесс при старте.  

интересно что меняется когда мы запускам программу (дальше для ясности назову ее 2.exe) под дебагером. ведь в этом случае 
по команде int3 терминации 2.exe непроисходит. во первых как работает gdb. 
он запускает 2.exe как свой child процесс. я попробовал притаачится к 2.exe через strace
но нетутто было. толи потому что может к нему gdb уже приаттачен либо потому что 2.exe
находится в состоянии T как процесс (тоесть остановлен). но  я смог приаттачится к gdb
через strace и там видно что у него проскакивает инофрмация что типа его child получил
сигнал SIGTRAP. причем gdb тоже обо этом напишет на экране: 

	Program received signal SIGTRAP, Trace/breakpoint trap.
	0x0000555555554601 in main ()

каким макаром gdb недает ядру затерминейтить процесс я пока без понятия.  
про SIGTRAP немного можно посмотреть тут  $ man 7 signal



4) Interrupt on Overflow 

если у нас при арифметике срабывает переполнение. например.
мы скадывали  11111111 + 1111111  то очевидно что в 8 бит результат не помещается
тоесть происходит переполнение. тогда цпу выставляет флаг OF =1 чтобы нам об этом скзаать.

так вот если на это важно. то мы можем при событии когда цпу высталвяет флаг OF то мы можем
запускат прерыаение. для этго надо после кода арифтиеческих опреаций вставить команду INTO

она и будет озанчать что если OF =1 то запусти  как цпу четвертый интерапт обработку.

советсвенно вектор обработчи будет искаться по адресу 4*4 = с 16-го байта (dec) = 00010h
по 19-ый байт. 

далее.
интерапты с 5 по 31 были зарезерировны на будущее.
так что для софтовых целей остатся доступными для програмирования интерапты с 32 по 256


===

8086

asm

 яп ходу понял почпму почти все операции идут с регсистраом A 
 потому что у нас каждоая операция имеет свой опкод. скажем OB

 и если бы скажем у нас можно было делать 

 mov любой регистр, любой регистр

 то для этой команды нужно скажем три байта к примеру. первый байт чтобы закодировать команду
 mov вторйо для операнда и третий для перанада.

 если же у нас команда mov уже привязана толькок к регистру A то мы одним байтом кодирует
 и команду и первый операнда
 тоесть OB = mov A,

 это большая экономия на коичество опкодов внутри цпу

====

freedos

установка небез подьебок.

скачиваем iso = https://www.ibiblio.org/pub/micro/pc-stuff/freedos/files/distributions/1.2/FD12CD.iso

далее создаем виртуабокс ВМ. в свойствах высталяем 32MB RAM,
чипесет выставляем PIIX3

грузимся с CD.

выбираем установку на harddisk

далее подьебка полетят ошибки "invalid opcode" и установка обломится. 
решение. когда видим картинку "install from harddisk" тыкаем "tab" и дописываем в конце raw

тыкаем enter. вот теперь установка пройодет успешн8о.

перегуржаеся (обяиазтельно надо перзагурится!)
грузимися с диска

запускаем программу FDIMPLES
она позволит потавить разные полезные пакеты с CD. ставим NASM ассемблер комплияторы.

он поставится в папку c:\devel\nasm\nasm.exe
путь к нему небудет прописан в PATH:
идем в autoexec.bat и там добавляем его в path

также ставим из пакетов (через fdimples) ассемблер дебагер insight
и добавляем в path в autoexec.bat путь к нему c:\insight\


далее через msedit состалвяем asm файл.
а собираем егов опкоды через 
> nasm -0 19.com 19.asm

теперь его можно загрузить в дебагер 

> insight

F1 - кнопка справки в insight 


код. пример

19.asm

bits 16
MOV AH, 0 
MOV AL, 6 
ADD AL, 5 
AAA


> nasm -f bin -o 19.com 19.asm

это создать com файл внутри которые только опкоды который может раотать под дос.

директива bit16 говорит nasm чтобы он делал опкоды от 16-bit асемблера

почемуто запуск в дос 19.com приводит к зависагию а раньше все было окей.
тем немнее можно запутстиь код 19,com  вдебагере insight
и там тыкая на F8 смотреть выоплнение шаг за шагом

nasm manual = https://www.nasm.us/xdoc/2.09.10/html/nasmdoc0.html

из тго что я понял nasm генрруиет obj файл. в котором голые опкоды. такой код можно
запускать только в дос. в линуксе запуск такого файла ничего недаст. а скажем в линуксе после nasm нужно по файлу еще проходится линкером
только линкер превратит файл в готовый к исполненмию файл. детали пока туманны.

если мы сидим в линукс и имеем  файл который хотим дизассемблиоровать то:
$ objdump -b elf64-x86-64  -M "intel" -d 27.exe

-b = тип формата файла. он может быть elf64-x86-64, а может быть binary.

обычно узнать формат файла можно через подсказку самого objdump 

$ objdump -f 27.exe
27.exe:     file format elf64-x86-64

-M "intel" = это настройка чтобы асемблерный текст был в красивом формате intel а не уродском AT&T

-d = означает чтобы дизасемблить только ту часть файла где исполняемый код. есть
еще ключ -D это дизасемблить весь файл целиком со всеми секциями.

также objdump умеет сам автоматом распознавать типы файла так что можно 
его вобщем то сразу запускать вот так:
$  objdump -d ./51.exe -M intel

также удобно откомпилировать программу чтобы  в нее были включены debug символы (текст программмы
на C) и потом objdump покажет микс из ассемблера и программы на C:

$  gcc -g -m64 -o 51.exe 51.c
$  objdump -S -d ./51.exe -M intel

пример программы:
$ cat 51.c
#include<stdlib.h>
#include<stdio.h>
#include<sys/wait.h>

int main(){


// обьявляем переменные

char d = 1;

while(1){
};


return(0);
};


пример что покажет objdump в микс режиме:
$  gcc -g -m64 -o 51.exe 51.c
$  objdump -S -d ./51.exe -M intel


00000000000005fa <main>:
#include<stdlib.h>
#include<stdio.h>
#include<sys/wait.h>

int main(){
 5fa:   55                      push   rbp
 5fb:   48 89 e5                mov    rbp,rsp


// обьявляем переменные

char d = 1;
 5fe:   c6 45 ff 01             mov    BYTE PTR [rbp-0x1],0x1

while(1){
 602:   eb fe                   jmp    602 <main+0x8>
 604:   66 2e 0f 1f 84 00 00    nop    WORD PTR cs:[rax+rax*1+0x0]
 60b:   00 00 00 
 60e:   66 90                   xchg   ax,ax


важно еще раз заметить что objdump может дизасемблить и object файлы *.o и готовые бинарники типа elf64

возвращаемся конкретно кнашему примеру. у нас бинарный файл.

$ objdump -D -b binary -mi386 имя_файла

Disassembly of section .data:

00000000 <.data>:
   0:	b8 41 00 83 c0       	mov    $0xc0830041,%eax
   5:	30 ba f8 03 ee 66    	xor    %bh,0x66ee03f8(%edx)
   b:	b8 00 c0 00 00       	mov    $0xc000,%eax
  10:	66 ff e0             	jmpw   *%ax

как видно по дефолту заюзан формат вывода "at&t" мне же удобнее когда асемблер выглядит 
в виде "intel"

$ objdump -D -b binary -m "i386" -M "intel" 22.bin

Disassembly of section .data:

00000000 <.data>:
   0:	8b ec                	mov    ebp,esp


вот это уже то что надо.



также можно как альтернативу можно заюзать дизасемблер от самого nasm

 $ ndisasm -b16 20.com


еще раз напомн как через nasm откопилировать асемблер текст в 16-bit опкоды  (он же object файл)

$ nasm -f bin -o 19.com 19.asm


а вот как откомпилировать 64-bit код в elf файл 

$  nasm -f elf64 2.asm
$  ld -s -o 2.exe 2.o


ключ -s в ld = Omit all symbol information from the output file.
можно запускать ./2.exe



или вот еще пример компиляции в 64-bit
(взято с https://gist.github.com/yellowbyte/d91da3c3b0bc3ee6d1d1ac5327b1b4b2)


$ nasm -f elf64 -o hello.o hello.asm
$ ld -o hello.exe hello.o

а вот пример как откомпилировать с debug символами (чтобы потом в gdb смотреть)
$ nasm -g -f elf64 -l hello.lst -o hello.o hello.asm
$ ld -o hello.exe hello.o

-g = включить дебаг символы 
-l = в явном файле показать что там за дебаг символы будут вставлены



=====

8086

онлайн эмулятор. где сразу можно програировать на асмеблере

https://yjdoc2.github.io/8086-emulator-web/compile

===
8086

opcodes.

приступил к разбору как асемлер переводить руками в машинные коды.
на примере команды mov.

описать вариант старый который  у людей с бумажки.
и вариант  с книжки интел.

расмотрим  примеры

1. mov bp,sp
первый вариант машинного кода: код 89  для "Move r16 to r/m16" , когда двигаем 
из регистра в регистр либо память. где r16 это операнд откуда двигаем  то есть 
из sp. смотрим таблицу 2-1. в горизонтальной линии выбираем операнд sp. опускаемся вниз 
и ищем строчку с вторым параемтром bp получаем E5. 
Итого машин код = 89 E5

подставляем проверяем
$ echo -n -e "\x89\xE5" > 22.bin
$ ndisasm -b16 22.bin
00000000  89E5              mov bp,sp

все правилььно.

второй вариант машинного кода: код 8B для "MOV r16,r/m16 RM" когда двигаем из регистра или памяти 
в регистр. тут важно отметить что в этом случае наш операнд это первый параметр после слова mov 
(а в предыдущем примере это был первый параметр после mov). в данном случае этот параметр=bp
(а впрошлом случае параметр был равено sp). берем параметр bp и постдавляем в таблицу 2-1 
в строку с r16/r опускаемся по столбцу вниз ищем строку с SP. получаем на пересечении код EC
Итого машин код = 8B EC

подсталяем проверяем
$ echo -n -e "\x8B\xEC" > 22.bin
$ ndisasm -b16 22.bin
00000000  8BEC              mov bp,sp

все совпало все правильно!

тоесть для одной команы на асемблере есть несколько команд в машинных кодах !

еще примеры:
2. mov ax, 0x1020
3. mov dx, 0x1020

=====
8086
640k

по моему я наконец понял откуда взялся этот блядский 640к ограничение по размеру памяти доступному 
для программ если работать на intel 8086\88.

вообще хуй найешт явный ответ как же сука они это сделали ведь цпу может адресовать 1MB памяти. так как? как суки как?

так вот гна стековерфлоу я нашел уопминание в коментариии что остальрые 340к были замаплены периферийными устройствами через 
memory map io.   вот оно бляь !!!!!! наконец то ответ!!!!!

и это сделало ibm как я понимаю через ихние ibm материнские платы. цпу был от интел а мат платы были от ibm.

так вот как работает memory map io. 

цпу подключен к шине ( шина это набор трех шин - шина адреса, шина данных, шина управления. шина у простом смысле это проводки.) шина покдлючена к микросхеме на мат плате под названием memory arbiter , также к шине подключены 
все перифериные устройства. так вот когда цпу выставляет на шине адреса адрес а на шину управления сигнал что он хочет сделать (прочитать или записать инфо) то этот запрос приходит на мемори арбитр и он делает вот что. он смотри по какому адресу идет запрос. если это адрес в диапазоне
таком то то арбитр через линии управления высылает сигнал на все периферийные устройства и на все модули памяти кроме одной о том чтобы они все
заткнулись и не трогали шину данных. а на один конкнетный модуль памяти арбитр памяти пукскает через
шину контроля сигнал на чтение запись порции данных. так вот когда цпу выставить определенный 
адрес на шину адреса то арбитр вырубает все модули памяти точнее посылает им сигнал чтоб неприксались
к шине данных и активирует через шину контроля ПЕРИФЕРИЙНОЕ УСТРОУСТВО! таким макаром с тчоки зрения
цпу это выглядит как запрос к RAM а по факту он начинает работать с перифериным устроством.
это и есть memory map io. когда цпу обращаясь к памяти по факту попадает на периферинйо устройство.
область адресов при которых мы попадае на то или иное периферийное устройство зависит как я понял от
арбитра памяти. то есть от железки от мат платы. так вот так как мат плату делали в ibm то они на ней
на арбитре памяти запрогармировали что если цпу обращается к памяти выше 640к то он уже в память 
непопадает. он попадает на то или иное периферийное устровство!!!! вот она разгадка 
как это так на параткие сделали что цпу может обращаться к 1МБ а по факту он 
для программы доступно только 640к!. при обращении по адресу выше чем 640к цпу попадаел не в память
а в периферийное устроуство. вроде бы так. ну конечно если мы  при обращении к адресу выше чем 640к
попадаем в перифериноу устройство то конечно ячейки памяти на RAM с адресами выше 640к на модулях
памяти никогда небудут достинуты процессором. тоесть эат память она пропадает выпадает из 
использования процессором!
пока у меня такое видение загадки 640к!








====
8086

дебаг 

gdb

nasm

debug

я нащупал как можно дебагить в линуксе асемблер

берем файл

$ cat 2.asm

section .data
    msg db      "hello, world!"

section .text
    global main
main:
    int3
    int3
    int3
    int3
    int3
    int3
    int3
    int3
    int3
    int3
    int3


компилиуруем его с символами дебаг внутри (это важная фишка которую надо уметь делать иначе позже 
gdb выдаст ошибку "gdb No symbol table is loaded" )
важно также чтобы была секция main чтоб успешно gcc отработал.

 $  nasm -g -f elf64 -l 2.lst  2.asm
 $  gcc -m64 -o 2.exe  2.o

или еще вариант без gcc потому что он в код вставляет кучу доп команд. если мы хотим более голый
оригинальный вариант получить то компилируем:

$ nasm -g -f elf64 -l 2.lst -o 2.o 2.asm
$ ld -o 2.exe 2.o


запускаем gdb

 $  gdb 2.exe

если с дебаг символами все окей то gdb напишет
Reading symbols from 2.exe...done

а вот тут инструкция по быстрому старту с gdb

https://www.csee.umbc.edu/portal/help/nasm/nasm_64.shtml

тоесть как запустили gbd используем команды:

> break main
(устанавливает брейкопоинт на секции main пограммы)

>run
...
Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000555555554601 in main ()

устанавливаем чтобы ассемблер имел вид intel а не at&t
>set disassembly-flavor intel

>disassemble main
Dump of assembler code for function main:
   0x0000555555554600 <+0>:	int3   
=> 0x0000555555554601 <+1>:	int3   
   0x0000555555554602 <+2>:	int3   
   0x0000555555554603 <+3>:	int3   
   0x0000555555554604 <+4>:	int3   
   0x0000555555554605 <+5>:	int3   
   0x0000555555554606 <+6>:	int3   
   0x0000555555554607 <+7>:	int3   
   0x0000555555554608 <+8>:	int3   
   0x0000555555554609 <+9>:	int3   
   0x000055555555460a <+10>:	int3   
   0x000055555555460b <+11>:	nop    DWORD PTR [rax+rax*1+0x0]
End of assembler dump.



> x/12bx main
0x555555554600 <main>:	0xcc	0xcc	0xcc	0xcc	0xcc	0xcc	0xcc	0xcc
0x555555554608 <main+8>:	0xcc	0xcc	0xcc	0x0f
 

>info registers
rax            0x555555554600	93824992232960
rbx            0x0	0
rcx            0x555555554610	93824992232976


>print /x $rsp
$7 = 0x555555554610

>nexti
>stepi
>next

>info float


>info stack
>q
>y


хочу прокоментироваь команды gdb
	>x /12bx main
эта команда позволяет посмотреть содержимое оперативки
вначале начну с более простой формы этой команды
	> x 0x0000555555554600
	0x555555554600 <main>:	0xcccc

сама команда это "x".  
0x0000555555554600 это адрес в памяти который мы хотим посмотреть содержимое.
можно адрес задать и по другому , например main - это таким образом задан адрес. поскольку у нас есть секция main то gdb сам знает с какого адреса она начинается. 
видно что по дефолту команда считала 2 байта. и вывела содержимое в hex виде.
это можно поменять. можно вывести значение в десятичном виде например

	>x /u 0x0000555555554600
	0x555555554600 <main>:	52428

/u означает decimal unsigned формат.

далее. память то у нас состоит из байтов. а вывели мы значение двухбайтное. 
это тоже можно менять. вот так выводится значение одного байта

	>x /bu 0x0000555555554600
	0x555555554600 <main>:	204

/b означает что мы просим считать только один байт.


	>x /hx 0x0000555555554600
	0x555555554600 <main>:	0xcccc

/h означает что мы хотим считать двухбайтовое выражение издеь важно заметить что когда мы 
считали два байта то мы их интерпретируем не как два отдельных байта а как единое 16 битное 
выражение.


 	>x /wx 0x0000555555554600
	0x555555554600 <main>:	0xcccccccc

/w этот ключ говорит что мы хотим считать 4 байта и инерпретировать 32бита как единое число



окей. до настоящего момента мы считывали только одну порцию памяти. не втом плане что один байт
а втом плане что назначли размер куска ( байт. два байта, четыре байта) и читали один этот кусок.
далее мы хотим считывать несколько таких кусков. окей.

	>x /5wx 0x0000555555554600
	0x555555554600 <main>:	0xcccccccc	0xcccccccc	0x0fcccccc	0x0000441f
	0x555555554610 <__libc_csu_init>:	0x56415741

/5 означает что мы хотим считать пять кусков с памяти, размер одного куска 4 байта.
вот мы и получили пять четырехбайтовых кусков: 0xcccccccc	0xcccccccc	0x0fcccccc	0x0000441f 0x56415741.
напомню что /x означает что мы хотим видеть интерпретацию битов в hex виде.
здес также важно отметит что число кусков почемуто всегда задается в dec виде. тоесть /5 это
пять в десятичном счислении. тоесть если мы захотим считат 100 кусков то надо будет 
писать /100

вернемся к исходному примеру
	>x /12bx main
значит адрес первого байта заан через переменную main
/12 это число кусков которые мы хотим считать
/b размер куска равен один байт
/x содрежимое памяти отобоажать в hex виде
итого получим
	x555555554600 <main>:		0xcc	0xcc	0xcc	0xcc	0xcc	0xcc	0xcc	0xcc
	0x555555554608 <main+8>:	0xcc	0xcc	0xcc	0x0f

кстати вот еще прикольная тема. когда мы хотим посмотреть память в бинарном виде это ключ /t
пример
 	> x /3bt 0x0000555555554600
	0x555555554600 <main>:	11001100	11001100	11001100
/3 счиатть три куска
/b размер куска один байт
/t вывести содержимое куска в бинарном виде

тут я хочу важный момент подчеркнуть с которым поебался
надо цифру солько кусков памяти покаывать вставлять сразу после слэша.
> x /8bx 0x6000d8

а не вот так
> x /bx8 0x6000d8
в этом случае будет писать ошибка!


итак с командой "x" разобрались
кстати можно посмотреть справку по команде x через
	> help x

прикольно что память разбита на блоки как жесткий диск на блоки.  а файл может занимать несколько
блоков на диске так и наша переменная записанная в память может занимать от 1 до 8 байт 
а при желании и больше. тот же самый регистр имеет размер 8 байт.
грубо говоря размерность памяти внутри цпу (регистры) несовпдатает с размерностью в оперативной
памяти

еще есть команда print сокрашенно p
если x в качестве аргурмента берет значения и памяти тоесть лазиит в ячейки памяти и достает 
то что там есть то команд print работает не с памятью как источником а с переменными тоесть еще раз
у команды x аргуменотом является некий адрес в памяти  а у команды p аргументом является имя переменной. большая разница. но также у команды p аргументом может быть сразу голове число
примеры

(gdb) p /t 8
$1 = 1000
(gdb) p /t 255
$2 = 11111111
(gdb) p /2t 255
Item count other than 1 is meaningless in "print" command.
(gdb) p /t 255
$3 = 11111111
(gdb) p /t 255.1
$4 = 11111111
(gdb) p f
No symbol "f" in current context.
(gdb) p /t 128
$5 = 10000000
(gdb) p /t 255.1
$6 = 11111111
(gdb) p /du 11111111
$7 = 11111111
(gdb) p /d 11111111
$8 = 11111111
(gdb) p /du 11111111
$9 = 11111111
(gdb) p /du 8
$10 = 8
(gdb) p /du -8
$11 = 4294967288
(gdb) 

ключи форматов ( /t /d /du ) такие же как у команды x ( help x)
и тут важно тметить что для комнды print если мы указали выходной формат бинарный /t а
аргументом является число c точкой то число с точкой будет округлено до целого а потом уже 
переведено в бинарный вид 
пример

(gdb) p /t 255.1
$6 = 11111111

вивдно что мы ввели 255.1 а на выходе получили 255

прикольно что есть ieee754 который описывает как через бинарный вид можно кодировать числа с точкой.

(gdb) p /f 0x4a9f060f
$20 = 5210887.5
(gdb) p /u 0x4a9f060f
$21 = 1251935759
(gdb) 

получается в зависимости от нашей интерпретации один и тотже бинарное число можно интерпетировать
и как целое и как число с плааавающей точкой

как уже сказал в команде print если мы будем пытаться перевести число с плаюващей точкой
в бинарный вид то система небудет переводить его в бинаный вид на основе ieee754 , она окгругит
число до целого и переведт именно целое в бинарный вид

также в чем прикол! - man gdb говоит что он предназначен для дебагинга програм на C а про 
асемблер нислова! так вот формат чисел gdb испольует такой же как как  в C. поэтому hex числа задаются в виде 0x1212121 а бинарные числа задаются как 0b101010101010101
таким образом еслимы хотим перевести двочное число в десятичное надо

	> p /u 0b01001010100111110000011000001111
	$35 = 1251935759

а вот перевод бинарного в плавающую точку
	>p /f 0b01001010100111110000011000001111
	$36 = 5210887.5

так что двоичное число задается через 0b.....
тажке видно что в зависиомсти от интерпретации одно и тоже бинарное число может быть 
интерпетировано и как целое и как с плавающей точкой

с командой print надо быть осторожным. как я уже сказал это команда при 
переводе из float в bin вначале округляет число до целого а потом уже переводит его 
в bin. второй момент связан с регистрами.

и в продолжение темы. вот мы имеем в C программе переменную скажем с именем f.
и мы хотим посмотреть ее значение. так вот лучше cмотреть через x а не через p

	>x/tw &f
	0xbffff3f4: 01001010100111110000011000001111


далее
	>info registers - это смотрит показания что внути регистров. 
		rax            0x555555554600	93824992232960
		rbx            0x0	0
		rcx            0x555555554610	93824992232976

тут особеннрость такая что gdb показывает значение регистра и в hex и в dex виде. поэтому 
на один регистр сразу два значения
у современных интел цпу в 32 битном режиме 8 регистров общего назначения (всего лишь)
а в 64 битном режиме 16 регистров общего назначения (всего лишь)

далее
	>print /x $rsp
		$7 = 0x55555555461
эта команда показывает содержимое отдельного регистра. ключ /x говорит чтобы на экране 
вывод был в hex формате. ключ $7 незначит ничего в выводе чисто временная служебная хрень.
в этом можно убедиться если запустить команду повторно тогда увидим что уже будет $8
	>print /x $rsp
		$8 = 0x55555555461


далее
	>nexti

	>stepi

сравним эти две команды сразу. истинный +1 шаг выполняется командой stepi. будет 
выполнена точно +1 инструкция асемблера и небольше. nexti делает побольше будет выполнена
+1 инструкция а если встретится вызов subroutine то этот субротин будет выполнен целиком.
есть также инструкции step и next. в чем разница их с nexti и stepi.
дело в том что gdb он умеет дебажиь нетолько асемблрные программы но и С программы поэтому
next и step предназначены для прохода по тексту C программы. а именно step выполняет машинный код
который соотвествует одной строке программы на C. втоже время как stepi выполняет ровно одну машинную команду. в этом и разница  - выполнить машинный код который соотвествует одной строке
на C или ровно одну команду машиинного кода. при этом если step попадет на вызов какото то субфункции то он выполнит только первую команду на C внутри этой субфункции. втоже время как next за один проход выполнит все что внутри этой субфункции.

далее
	>info float
показывает состояние регистров математического сопроцессора ( FPU )
	R7: Empty   0x4002b1c5dc0ab47e8f94
  	R6: Empty   0x00000000000000000000
  	R5: Empty   0x00000000000000000000
  	R4: Empty   0x00000000000000000000
  	R3: Empty   0x00000000000000000000
  	R2: Empty   0x00000000000000000000
  	R1: Empty   0x00000000000000000000
	=>R0: Empty   0x00000000000000000000

по идее вроде как они должны называться st0,st1 итд у меня же они назвыаются почемуто R0-R7
это реально регистры сопроцессора потому что они длинной 80-bit ( а не 64бит как у обычных )
эти регистры используются если мы хотим делать мат операции над числами с плавающей точкой. 
для этого юзаются эти спец регистры и спец команды. тоесть эти регистры предназначены только 
для этого. что интересно данные в них можно закачать только из оперативки а из обычных регистров
почмуто туда данные нельзя совать. результат тоже можно записать из этиъ регистров только в 
память а в обычные регистры нельзя. при записи в память результат из 80-бит округляется до 64-бит
естественно. 

хотя когда я ввел команду
	> info all-registers
то оно показало уже верные имена регистров st0-st7
	st0            123.450000000000002842	(raw 0x4005f6e6666666666800)
	st1            0	(raw 0x00000000000000000000)
	st2            0	(raw 0x00000000000000000000)
	st3            0	(raw 0x00000000000000000000)
	st4            0	(raw 0x00000000000000000000)
	st5            0	(raw 0x00000000000000000000)
	st6            0	(raw 0x00000000000000000000)
	st7            0	(raw 0x00000000000000000000)

тут мы вспоминаем что комада print может печатать значения регистров а нетолько переменных.
с целочисленными регистрами она работает коректно и хорошо. а вот с st-st7 она работает 
как то плохо. попроуем посмотреть st0 в hex формате через print
	> print /x $st0
		$10 = 0x7b
в то время как info all-registers нам показыавает что st0=0x4005f6e6666666666800
так что команда print ненадежная. то при выводе в /t она переводит float в integer и толко 
потом в bin. то теперь значение float регистра отображает неверно. поэтому то что печатает 
команда print как то доверять нельзя. хотя для целочисленных регистов она работает верно. и 
только с помощью нее можно посмотреть на содержимое регистра в бинарном виде.

 	>print /t $eax
		$11 = 10000000000010010100000
	>print /t $rsp
		$12 = 11111111111111111111111111111111101110000101000

однако возвращаемся к FPU регистрам.

пример программы которая юзает эти регистры
\\\
global main

section .data
    val: dq 123.45   ; define quadword (double precision)

section .bss
    res: resq 1      ; reserve 1 quadword for result

section .text

main:
    ; load value into st(0)
    fld qword [val]  ; treat val as an address to a qword
    ; compute square root of st(0) and store the result in st(0)
    fsqrt
    ; store st(0) at res, and pop it off the x87 stack
    fstp qword [res]
    ; the FPU stack is now empty again

    ; end of program
\\\

компилируем ее вот так а то вылезет ошибка ( relocation R_X86_64_32 against `.data' can not be used when making a PIE object; recompile with -fPIE )
$ nasm -g -f elf64 -l 3.lst  3.asm
$ gcc -m64 -o 3.exe  3.o -no-pie

запускаем gdb и смотрим

	$ gdb ./3.exe
	> break main
	> run
	> nexti
	>info float
		=>R7: Valid   0x4005f6e6666666666800 +123.4500000000000028

так как программа сует в регистр константу из памяти. посмотрим проверим 
а что там в памяти лежит откуда она берет

	>disassemble main
		Dump of assembler code for function main:
		0x00000000004004a0 <+0>:	fldl   0x601028
		=> 0x00000000004004a7 <+7>:	fsqrt  
   		0x00000000004004a9 <+9>:	fstpl  0x601034
		End of assembler dump.

видим что переменная была считана из адреса 0x601028. 
читаем из него руками

	>x /1gx 0x601028
		0x601028 <val>:	0x405edccccccccccd

смотрим еще раз чему равно значение этой же переменной уже в fpu регистре
	>info float
		=>R7: Valid   0x4005f6e6666666666800 +123.4500000000000028

получается в hex виде отличается 0x405edccccccccccd <> 0x4005f6e6666666666800. 
сравним в float виде

	>x /1gf 0x601028
		0x601028 <val>:	123.45

123.45 ~ 123.4500000000000028

ну чтож так лучше. (хотя непонятно откуда на конце 28 появилось.)

итак мы убедились что число из памяти было закачано в FPU registr R7 (st0)

двигаем дальше по программе
 	>nexti
	>disassemble main
		Dump of assembler code for function main:
   		0x00000000004004a0 <+0>:	fldl   0x601028
   		0x00000000004004a7 <+7>:	fsqrt  
		=> 0x00000000004004a9 <+9>:	fstpl  0x601034
		End of assembler dump.

	>info float
		=>R7: Valid   0x4002b1c5dc0ab47e8f94 +11.11080555135405125 

итак получили 11.11...

двигаем дальше
	>nexti
проверяем какое число было в итоге записано из FPU в память
	>x /1gf  0x601034
		0x601034 <res>:	11.110805551354051

сравниваем его с тем что было в FPU (RAM)11.110805551354051 ~ (FPU)11.11080555135405125
как видим одно и тоже число. просто оно стало покороче ибо его нужно было округлить из 80битного
прдеставления в 64битное.


моменты:
 - проблема компиляции программы


гоча!
===
disassemble
gdb
objdump
nasm


еще пример дизассемблирования


имеем
текст на asm

$ cat 27.asm
; 27.asm
section .text
    global _start
_start:
BITS 64
    mov       rax,0xff11ff11ff11ff11
    push      rax
    pop       rax
    push      0x7a
    pop       rax
    push      0x8a
    pop       rax


; call exit(0)
    mov    rax, 0x3c
    mov    rdi, 0x0
    syscall



компилируем (причем с дебаг символами чтобы gdb мог успешно работать):
$ nasm -g -f elf64 -l 27.lst -o 27.o 27.asm
$ ld -o 27.exe 27.o


диаззассемблируем(objdump):
$ objdump -b elf64-x86-64  -M "intel" -d 27.exe
27.exe:     file format elf64-x86-64
Disassembly of section .text:

0000000000400080 <_start>:
  400080:   48 b8 11 ff 11 ff 11    movabs rax,0xff11ff11ff11ff11
  400087:   ff 11 ff 
  40008a:   50                      push   rax
  40008b:   58                      pop    rax
  40008c:   6a 7a                   push   0x7a
  40008e:   58                      pop    rax
  40008f:   68 8a 00 00 00          push   0x8a
  400094:   58                      pop    rax
  400095:   b8 3c 00 00 00          mov    eax,0x3c
  40009a:   bf 00 00 00 00          mov    edi,0x0
  40009f:   0f 05                   syscall 

вобщем то видим что имеем поочти то то что в исходном файле.

диаззассемблируем(ndisasm): лучше неиспользовать иногда как то он хуево работает 
и выдает совсем нетот код который там есть внутри.

дизассемблирвем (через gdb):
$ gdb hello.exe
> break _start
>run
> set disassembly-flavor intel
> disassemble _start

=> 0x0000000000400080 <+0>: movabs rax,0xff11ff11ff11ff11
   0x000000000040008a <+10>:    push   rax
   0x000000000040008b <+11>:    pop    rax
   0x000000000040008c <+12>:    push   0x7a
   0x000000000040008e <+14>:    pop    rax
   0x000000000040008f <+15>:    push   0x8a
   0x0000000000400094 <+20>:    pop    rax
   0x0000000000400095 <+21>:    mov    eax,0x3c
   0x000000000040009a <+26>:    mov    edi,0x0
   0x000000000040009f <+31>:    syscall 
End of assembler dump.


получили тоже самое. 
отлично

кстаи в gdb чтобы дизассемблировать необязательно устанавливать breakpoint и запускаить программу.
тоесть команды
> break _start
>run
они лишние если мы хотим только дизассемблировать


таким образом умеем компиилровать из кода. плюс в файле будет дебаг символы.
потом дизасемблим через objdump и через gdb

===
8086
asm

наконецто! раскрылась правда про чтото непонятное.
а именно.

вот берем создаем минимальный asm файл

$ cat 28.asm
; 28.asm
  GLOBAL _start
  SECTION .text
  _start:
      hlt

во первых куча мусора будет после gcc
во вторых причем здесь секции ведь будет исполняться машинный код там нет никаких секций
там только mov,jmp итд. там нет никаких .text

что значит _start  в чем отличие если написать _main 
если копилировать через gcc или через nasm+ld

почему gcc сует туда кучу мусора

программа стартует с точки _start

теперь сталоп онятно зачем нужны ipC итп. потому что процессы сидят в своем виртпростанстве
и никак не могут обменяться инфой с другими процессами. кроме как через дескрипторы файлов
которые доступны сразу  обоим процессам// нужна дверь обмена

поехали.
вначаале elf файла идет HEADER. рассмотрим конкретно elf64 файл.
хидер начинается с офсета 0 и занимает 64 байта.

структура HEADER имеет формат\структуру:

{
  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info    (16 bytes) */
  Elf64_Half	e_type;			/* Object file type    (2 bytes) */
  Elf64_Half	e_machine;		/* Architecture        (2 bytes) */
  Elf64_Word	e_version;		/* Object file version (4 byte)  */
  Elf64_Addr	e_entry;		/* Entry point virtual address    (8 bytes) */
  Elf64_Off	e_phoff;		/* Program header table file offset   (8 bytes) */
  Elf64_Off	e_shoff;		/* Section header table file offset   (8 bytes) */
  Elf64_Word	e_flags;		/* Processor-specific flags  (4 bytes) */
  Elf64_Half	e_ehsize;		/* ELF header size in bytes  (2 bytes) */
  Elf64_Half	e_phentsize;		/* Program header table entry size (2 bytes)  */
  Elf64_Half	e_phnum;		/* Program header table entry count    (2 bytes)  */
  Elf64_Half	e_shentsize;		/* Section header table entry size  (2 bytes) */
  Elf64_Half	e_shnum;		/* Section header table entry count     (2 bytes) */
  Elf64_Half	e_shstrndx;		/* Section header string table index    (2 bytes)  */
} Elf64_Ehdr;

итого 64 байта.

это структура хидера для elf64 типа файла.

ну чтож легко запомнить elf64 его HEADER занимает 64 байта.

EI_NIDENT= 16(dec)
поэтому unsigned char e_ident[EI_NIDENT]  это массив из 16 символов то есть 16 байт в итоге.

итак вначале хидера идет e_ident 16 байт размером, разберем что там в этих байтах:
и сразу разберем на примере:
$ hexdump -C -n 16 a.out
00000000  7f 45 4c 46 02 01 01 00     00 00 00 00 00 00 00 00  |.ELF............|

0x7f - константа
0x45 - символ 'E' в ASCII
0x4c - символ 'L' в ASCII
0x46 - символ 'F' в ASCII

0x02 - это поле это какой машинный код внутри 32\64бит. для 64 бит поле = 0х02
0x01 - порядок битов в байте littlen или big endian. для little endian(для цпу intel) поле = 0x01 
0х01 - File version byte index. что это такое непонятно. но на данный момент это поле всегда = 0x01


чтоб понять дальше то надо понять что такое api. все как попугаи твердят что api это некая хрень которая позволяет одной программе 
обмениваться данными с другой программой. 
разницу между 'rest vs http'. судя по интернету rest это некий набор правил  которым должна подчинятся
программа а http это такой 

>>>>>> отсановился на том что такое 'os abi' vs 'abi'. для этого надо понять что такое api. для этого надо понять http vs api.
для этого надо понять rest vs http , POSIX ?<<<<<

канонические адреса вирт памяти в 64битном режиме.
11111111 11111111 100000000000000000000000000000000000000000000000
...
00000000 00000000 011111111111111111111111111111111111111111111111

00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 

разбираем его поля. 

$ hexdump -C -n 64 a.out
00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  02 00 3e 00 01 00 00 00  80 00 40 00 00 00 00 00  |..>.......@.....|
00000020  40 00 00 00 00 00 00 00  98 00 00 00 00 00 00 00  |@...............|
00000030  00 00 00 00 40 00 38 00  01 00 40 00 03 00 02 00  |....@.8...@.....|
00000040

его поля описаны в /usr/include/elf.h
7f - константа
45 - символ 'E' в ASCII
4c - символ 'L' в ASCII
46 - символ 'F' в ASCII




===
8086

ELF, a.out , linker





The smallest unit of an object file is a section. A section is a block of code or data that occupies contiguous space in the memory map. Each section of an object file is separate and distinct.


In Binutils, how sections are put into segments by ld is determined by a text file called a linker script
You can get the default one with ld --verbose, and set a custom one with -T.
For example, my default Ubuntu 17.04 linker script contains:

  .text           :                                                                                                                                                             
  {                                                                                                                                                                             
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)                                                                                                                         
    *(.text.exit .text.exit.*)                                                                                                                                                  
    *(.text.startup .text.startup.*)                                                                                                                                            
    *(.text.hot .text.hot.*)                                                                                                                                                    
    *(.text .stub .text.* .gnu.linkonce.t.*)                                                                                                                                                                                                                                                  breadbox@muppetlabs.com                                             
  } 
which tells the linker to put sections named .text.unlikely, .text.*_unlikely, .text.exit, etc. in the .text segment.


===
???&&&&&&&&&&&???????????????????????????????????
??????????????????????????????????????????????????
??????????????????????????????????????????????????
как устроен a.out, elf формат, что такое object file vs executable file 
закончил на том что коментирую команды gdb (закончил на том что читаю какие регистры
испольщуюстя при работе с плавающей точкой арифметикой)
описать AAA команду , посмотрет его опкоды
asm debugger for ubuntu 
numa vs miltichannel memory controller без нума vs memory interleaving. причем у  cpu fsb 64bit всего. также \
как выглядит распределение физ адресов в таких случаях для линукса ?
память ранки?(читать мою доку)
если у нас есть цпу. у него есть мемори контроллер. у него есть два канала к памяти. одна планка воткнута
	в первый канал вторая во второй. вопрос как распредеелена нумерация физ памяти межу первой планкой и второй.
	идет ли нумерация так что 1-я планка от 1 до 1000 000 потом вторая планка от 1000 001 до 2000 000.
	или нумерация идет так что первый байт на 1-ой планке вторйо байт на второй планке. третий байт
	на первой планке четвертный байт на второй планке ?


???&&&&&&&&&&&???????????????????????????????????
??????????????????????????????????????????????????
??????????????????????????????????????????????????
===
8086
asm

теперь стало понятно 16-bit код, 32-bit код, 64-bit код. вот скажем у нас есть
64 битный цпу и он может выпонять 32-бит программы и 64-бит программы. что это значит на уровне
кода. 
дело в том что машиный код (команды в двоичном виде) имеет разные опкоды условно говоря
для одних и техе же команд. я имею ввиду те команды у которых нет регистров как параметры.
и также 32-бит код отличается от 64-бит код тем что регистры имеют другие имена.

===
assembly


как выглядит обьявление констант в асемблере 
в разных системах счисления:

 	mov     ax,200          ; decimal 
    mov     ax,0200         ; still decimal 
    mov     ax,0200d        ; explicitly decimal 
    mov     ax,0d200        ; also decimal 
    mov     ax,0c8h         ; hex 
    mov     ax,$0c8         ; hex again: the 0 is required 
    mov     ax,0xc8         ; hex yet again 
    mov     ax,0hc8         ; still hex 
    mov     ax,310q         ; octal 
    mov     ax,310o         ; octal again 
    mov     ax,0o310        ; octal yet again 
    mov     ax,0q310        ; octal yet again 
    mov     ax,11001000b    ; binary 
    mov     ax,1100_1000b   ; same binary constant 
    mov     ax,1100_1000y   ; same binary constant once more 
    mov     ax,0b1100_1000  ; same binary constant yet again 
    mov     ax,0y1100_1000  ; same binary constant yet again

 =======

===
linux 
signals

сигналы



Что интересно signal определяют в книжке по libc как software interrupt доставленный со стороны
ОС процессу. тоесть они проводят аналогию между cpu interrupt и сигналами. в случае cpu interrupt 
обьектом назначения является цпу. к нему поступает интеррапт. получается что в случае сигналов
по аналогии целью назначения является процесс. тоесть процесс выступает в той же роли что и цпу 
если аналогии проводить.  еще раз:

(hardware interrupt ) цель = cpu
(signal) цель = process

в случае cpu interrupt он(цпу) сразу все бросает тоесть останавливается и бросается обслуживать
интеррапт.

в случае  process interrupt (так я дальше буду порой называть signal) : во первых сам код процесса
мало на что влияет. схема такая что один кусок ядра порписывает в таблице процессов в его свойствах в поле сегналов наш сигнал. тогда шедулер в следущий таймслайс когда он собирается помещать процесс на цпу вместо этого запускает обработчик сигнала. тоесть вобще то реагирующим 
субьектом на сигнал является некод процесса а шедулер. тоесть похорошему целью интеррапта является шедулер. процесс в отличие от цпу и так постоянно прерывается шедулером без всяких сигналов вот
в чем прикол.  так вот когда наступает очередной шедулер тайм слайс в котором проецесс должен исполняться на цпу то шедулер вместо размешения кода процесса на цпу направляет цпу на обработчик сигнала. да в этом смысле выполение процесса прерыается на выаолнение обработчика. 

в случае цпу интеррапта сигнал к нему прилетает от контроллера интерраптов а к контроллеру сигнал 
летит от железки (  и нетолько но неважно). в случае сигнала он летит к процессу ( а точнее к шедулеру) от ядра. единственное что к ядру он запрос ( не сигнал а запрос на формирование сигнала) поступает от : яддра, самого процесса, другого процесса, кнопки с клавы. 

ну а так да. сигнал это в какомто смысле прерыватель нормальной работы процесса из внешнего мира.
другое дело что и без сигналов работу процесса постоянно прерывавет тот же самый шедулер.

цпу интерапты называют синхронными 

есть станартные сигналы которые можно послать процессу. каждый сигнал имеет номер.
нафиг они нужны. ну например  послать сигнал это способ закончить программу досрочно.
в целом это способ сообщить чтото из внешнего мира процессу. как то повлиять на него.
причем мы хотми повлиять таким способом который независит от открытых файлов этим процессом.
дело в том что обычно процесс общается с внешним миром путем того что он открывает несколько
файлов из которых пишет или читает. сколко он откроет файлов и в каком формате процесс ждет посту
пающей инфо это все завиисит от прихотей процесса. а нам нужен способ донести какуто информацию
какой то приказ внезависимости от возможностей которые предоставляет сам процесс. если сравнить
процесс с человеком который сидит в квартире за закрытой дверью и это дело самого человека
кому открыть кому неоткрыть а нам нужен способ сообщать чтот человеку внезависимости от 
его открытой закрытой двери скажем этот способ это громкая связь.

далее тонкий момент в том что сигнал может быть обработан как кодом самого процесса так и 
кодом ядра без участи кода процесса вообще.
как я понял обычно работае так. запускается процесс и он регистрирует в ядре процедуры своего 
кода которые могут обработать тот или иной конкретный сигнал ( с конкретным номером. потому что сигнал идентифицируется номером). далее если мы шлем процессу сигнал то что при этом происхдит -
ядро присваивает некое свойство таблице данных которая содержит описательное инфо о процессе.
это как в личном деле человека появляется новая заметка. далее когда шедулер собирается 
пихнуть процесс на цпу он проверяет таблицу записей этого процесса нет ли там заметки о том что
к процесс имеет свойство о том что ему послали сигнал. более точно  я считаю было бы говориить что 
сигнал непослали процессу а назначили присвоили процессу. как орден присвоили. так вот шедулер 
смотрит неприсвоен ли процессу сигнал. если да то шедулер код процесса непихает на цпу . нет.
далее шедулер смотрит зарегистрировал ли процесс какойто свой обработчик для данного сигнала. если
да то шедулер запускает этот обработчик. тоесть в этом случае можно сказать что процесс получил
сигнал. ибо код процесса стал его обрабатывать. а если процесс при своем старте незарегистриовал
обработчик этого сигнала то тогда шедулер запускает дефолтовый обработчик сигнала через кусок 
предопредленного кода ядра. в этом случае формально получется что процесс ничего неполучал.
сигнал обрабатывается исключительно ядром.
поэтому я бы сказал что более верно было бы говориить что сигнал посылается непроцессу а ядру о том
чтобы присвоить сигнал процессу.  это как послать письмо матери школьника о школьнике. а далее
может быть это письмо и будет выдано школьнику для обработки а может быть и нет и останется на 
оббработке матери.

так вот так называемые стандартные сигналы. а есть real time сигналы.

вначале про стандартные сигналы.
все сигналы имеют дефолтовый обработчик в ядре. это значит что если процесс неимеет своего 
обработчика то сигнал все равно будет обработан но уже ядром.
для части сигналов можно запрограмирвать в процессе что он эти сигналы примет но ничего не будет
делать в ответ. тоесть он "как бы" эти сигналы может игнорировать. 
а часть сигналов процесс неможет игнорировать на наних точно нужно выполнить действие.
но на самом деле плохая терминалогия. для таких "неигноруемых " сигналов на самом деле до кода 
процесса они просто недойдут их обработкой займется само ядро и обычно смысл этих сигналов том
чтобы либо остановить временно процесс тоесть пока его больше не помещать на цпу и недвигаться
под коду процесса или втом чтобы уничтожит процесс. так что неигнорируемые сигналы процесс просто
необрабатывает они до негоо просто недоходят до его кода. это скорее четкий приказ ядру.

итак для части сигналов можно настроить процесс что он при желании может иметь свой обработчик
для этих сигналов, может неиметь этого обработчика и тогда будет запускаться обработчик в коде
ядра. можно настроить обработчик в коде процесса который будет принимать сигнал но ничегонеделать
в ответ (так называемое игнорирование сигнала).  в любом случае если у процесса нет своего 
оработчика то для каждого сигнала у ядра всегда есть обработчик так что в любом случае сигнал
будет обработан либо обработчиком самого процесса либо ядром. другое дело как я сказал 
что для ряда синалов обработчик процесса в ответ может позволить ничего неделать.


а для другой части сигналов ответеное действие обязательно, причем обработка кодом процесса
даже недопускается а обработчка сразу идет через обработчик ядра. обычно требуется такие действия
как приостановить процесс  или уничтожить.

станадартные сигналы имеют предопреледенные исторические значения.
это значит что ядро генерирует конкретные сигналы в ответ на возникновения конкретных событий.
и приложение в целом может быть уверено что если прилетел сигнал номер X то это значит что 
до этого произошло определенное событие Y.


рил тайм сигналы это как я понимаю типа доп множество сигналов. ( условно говоря если 
сигнал когда мы его шлем определяется его номером то рил тайм сигналы их номера от 32 по 64). 

значение рил тайм сигналов неопределено. это значит что если приложение получило сигнал номер
34 то  в целом приложению неизвестно какое событие послужило причиной этого сигнала и получается
что на этот сигнал в ответ от процесса хотят.
если у процесса нет своего обработчика этого сигнала то по дефолту ядерный обработчик 
как ответное действие просто уничтожает процесс.

сигнал это как домашнее задание для процесса. если сам процесс неделает домашнее задание то за него
егоделает ядро. а делает так - просто уничтожает процесс.

как я понимаю рил тайм сигналы ( я бы их назвал просто доп сигналы с неопрееленным значением 
чтобы мозги незаебыываь некоректными терминами) в целом могут использованым для написания 
программ у которых несколько компонентов тоесть несколько процессов. и тогда один процесс может посылать другому процессу вот эти вот доп сигналы чтобы сообщать о своих каких то кастомных событиях.  

есть еще три свойства для рил тайм сигналов которых нетакие как у стандартных сигналов.

1 если послать несколько станадртных сигналов процессу то в каком порядке эти сигналы будут применены
для процесса является неизвестным. чисто будет работать рандомная статистика.
если же послать процессу нескоько рил тайм сигналов то они будут приходит к процессу на обработку
ровно в том порядке в каком они были изначально посланы по времени. тоесть как FIFO.

2 если послать несколько стадартых сигналов одинаковых то в иттге процесс получит только 
один такой сигнал. а если послать несоклько рил тайм сигналов одинаковых то будут доставлены
на обрабтку все

3 при отправке рил тайм сигнала ему также можно дополнительно вложить некие дополниельные 
переменные которые прибудут к процессу вместе с этим сигналом. тоесть вместе с сигналом можно 
передавать значения. а процесс сможет их получить и обрабатывать. 
стандартные сигналы непозволяют передавать процессу никакие значения. процесс только получает
инфо о самом сигнале и больше ничего. 
стандартный сигнал можно сравнить с тем что процесс получает инфо в форме тольк одной цифры. тоесть
процесс получает инфо такого вида : к вам поступил сигнал номер 1. на этом все.
а с рил тайм сигналом процесс получает инфо такого вида: к вам поступил сигнал номер 34 и вместе с ним еще шло число 45.

signal handler (код обработки прилетевшего сигнала) может быть прерван другим сигналом если 
особо неустановлено (незнаю где наверно в свойствах хендлера) что его нельзя прерыывать пока
он отрабатывает.  в связи с этим непонятно что происхдоит дальше. будет ли возврат обратно.
вроде как блокировку нового сигнала можно задать через некую спец маску для процесса  неуверен
что ее коректно изменять из хэндлера. а вот вроде нашел - To avoid this, you can use the sa_mask member of the action structure passed to sigaction to explicitly specify which signals should be blocked while the signal handler runs. тоесть когда в коде описываем кастомный хэндлер
то в его свйоствах можно указать маску которая говорит ядру что когда будет запущен хендеор то его
нельзя прерывать такими то сигналами. и далее - When the handler returns, the set of blocked signals is restored to the value it had before the handler ran. So using sigprocmask inside the handler only affects what signals can arrive during the execution of the handler itself, not what signals can arrive once the handler returns. вот еще нашел что если хендлер уже стартанул то 
если прилетит такойже сигнал то он прерывает наш хендлер - When a handler function is invoked on a signal, that signal is automatically blocked (https://www.gnu.org/software/libc/manual/html_node/Blocking-for-Handler.html) 

есть и другой прикол. вроде. если прилетел сигнал и запустился хендлер этого сигнала
и если прилетел ТАКОЙЖЕ еще сигнал то вроде как прерываение данного хендлера непроисходит
правда вопрос что будет с тем сигналом когда хендлер закончит он будет обработан или он будет
потерян?

кстати я походу я понял по поводу деления на ноль на цпу. такой операции просто непроисходит.
как только цпу собирается это сделать срабаывает встроенная защита о том что эта операция запрещена. вот ивсе. срабатывает interrupt , интеррапт вызывает то что цпу начнет выполнять 
обработчик интеррапта который ОС поставляет. обработчик интеррапта(который ядерный код) сгенерирует сигнал который будет послан процессу. интересно если ядерный код поделит на ноль
то что будет. ведь процесса при выполнении ядерного кода нет.


в C libc функция которая позволяет установить кастомный сигнал хендлер это signal()
которая по факту обращается к кернел сисколу sigaction()

пример программы
$ cat 39-kids.c
#include<unistd.h>
#include<sys/wait.h>
#include<stdio.h>
#include<signal.h>

// five-children.c
static const size_t kNumChildren = 10;
static size_t NumChildrenExit = 0;


static void reapChild(int sig) {
  waitpid(-1, NULL, 0);
  NumChildrenExit++;
}

int main(int argc, char *argv[]) {
  printf("The program is started.\n");

  signal(SIGCHLD, reapChild); // install signal handler



  // lets create kNumChildren children via fork()
  for (size_t kid = 1; kid <= kNumChildren; kid++) {
    pid_t pid_c = fork();
    if (pid_c > 0){
       printf("Create #%zu child\n", kid);
    };
    if (pid_c == 0) {
      sleep(30 * kid); // sleep emulates "play" time
      printf("Child #%zu is finished the work... -->exit.\n", kid);
      return 0;
    }
  }



  // main loop in parent process
  while (  1  ) {
    sleep(5); // custom fn to sleep uninterrupted
    if (NumChildrenExit == kNumChildren){
       printf("To exit press Ctrl+C.\n");
    };
  }
  return 0;
}


вывод на экран:
$ ./39-kids.exe 
The program is started.
Create #1 child
Create #2 child
Create #3 child
Create #4 child
Create #5 child
Create #6 child
Create #7 child
Create #8 child
Create #9 child
Create #10 child
Child #1 is finished the work... -->exit.
Child #2 is finished the work... -->exit.
Child #3 is finished the work... -->exit.
Child #4 is finished the work... -->exit.
Child #5 is finished the work... -->exit.
Child #6 is finished the work... -->exit.
Child #7 is finished the work... -->exit.
Child #8 is finished the work... -->exit.
Child #9 is finished the work... -->exit.
Child #10 is finished the work... -->exit.
To exit press Ctrl+C.
To exit press Ctrl+C.


что она делает. она устанавливает обработчик сигнала SIGCHLD,
создает 10 чилдренов. чилдрены спят какоето время потом они выходят,
в парент поступает SIGCHLD он его отрабатывает забирает код возврата от чайлда,
после этого ядро наконце убивает процесс чайлда полностью.  итак пока все чидрены
не закончат.
 на этом конец программы.
что интересно вот создал парент 10 чилдренов. если после этого грохнуть через kill -15 
парента то чидрены конечно же продолжат жить (потому что в паренте нет кастомного обработчика сигнала -15 который бы убивал чилдренов а по дефолту убиение парент процесса неприводит к автоматическому убиению чидренов). при этом чилдрены сменят парента (на процесс "systemd --user"
а не на pid=1). и поскольку сообщение "Child #7 is finished the work... -->exit." сидит в теле
чилдрена то прикольно как на экране будут появляться собщения эти. тоесть парента уже нет
а чилдрены работают и выводят на экран. в целом чуда нет но прикольно. чуда нет потому что  
если один процесс грохнуть то почему другие должны автоматом быть грохнуты. недолжны. 
а так как все они имеют станадртный вывод на один терминал то на экране будут вылезать эти мессаги.

далее прикол втом что если мы заменим строчку 

sleep(30 * kid);

на 

sleep(1);

это будет значит что все чилдрены одновременно (более менее) закончать свою работу.
тогда получится то что (надо обьяснить почему) часть чайлдов окажется необработанной 
сигнал хендлером и они останутся висеть как Z. 
чтобы этого небыло наизменить хэендлер вот с такого

static void reapChild(int sig) {
  waitpid(-1, NULL, 0);
  NumChildrenExit++;
}

на такой (обьяснить почему это даст эффект)

static void reapChild(int sig) {
    while (1) {
       pid_t pid = waitpid(-1, NULL, 0);
       if (pid < 0) break;
       NumChildrenExit++;
    }
}


(обьяснить почему это даст эффект)



===
8086

cs регистр якобы неможет быть измненен напрямую.. кхм странно
ss и ds можно изменить нарямую через инстркуию POP

как я понял SP указывает офсет начала вершины стека а BP это уже произвольный офсет 
который юзается чтобы иметь доступ к данным где то в глубине от вершины стека

===
8086

в регистрах биты расположены в режиме big endian
тоесть левый это MSB а правый это LSB

а память наоборот. младший бит и байт пишутся первыйми а старщий байт и старший бит пишутся
последними



===
8086\88

dma

в цпу есть две ножки про dma
если устройство внешгнее хочет занять шину то оно в цпу послыает запрос по одной ножке
а цпу подрверждает что он освободит шину (на следущем цикле) по второй ножке
===
PAE

после пентиума (тот который P5) у которого ширина шины адреса была 32 бита и позволяла адресовать
4ГБ RAM был выпущен pentium pro (который P6) у которого ширина шины адреса была 36 бит и это ему
позволяло адресовать уже 64ГБ памяти. это был первый цпу у интел с шириной шины адреса больше чем 32 бита.
тоесть в теории в комп с цпу pentium pro можно было
вставить до 64ГБ RAM. но внутри него регистры 32 бит значит напрямую это неполучится сделать.
ровно также как это было с 80888 у котрого регистры 16 бит а ширина шины адреса 20 бит.тоесть
нужно изголяться. но все равно сам факт что пентиум про это был первый от интел 32 битный процессор который позволял работать с памятью больше чем 4ГБ (знаменитый предел 4ГБ для 32 битных процессоров).  
?????????????????????????????

=====
640k mem

segmentaion in real mode типа нетоже самое что segmatation в protected mode = ?


ext4 - имена файлов хранятся в directory entry. что я непонял эти directory entry тоже хранятся
в inodes или вчемто другом ?

bios memory map addr по какому адресу мапится биос код ?


cpu mode: real vs protrcted vs 8086virtual
адресация памяти : segment vs page




процесс когда хочет писать в память он переклчается в режим ядра  а если нет как же 
утвержлоение что доступ к железу от процесса идет тлоько через ядро?

paging - разееление памяти на 4к.  а как тогда обратится к байту отедьнуму?

paging vs segmantaion ?

кто пишет данные в tlb ? сам цпу или кернел участвует

как цпу знает где лежит page table


mmu и os. как os управляет mmu











===========
утилита od

предыдущая тема теерь здорово поможет при расммотрении утилиты od
она позволяет выводит на экран содержимое файла в виде байтов . причем 
моэно выбирать в каком счислении эти байты будут отображены. ведь байт это просто число.
вопрос только в том   в какой системе счисения мы это число выводим. dec, hex, oct

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


=============
???????????????????????
понять как поменят кнопку и литеру в которую она резолвится. key remapping.
приколльно есть scan коды клавы, есть ascii, есть escape коды терминала
====
linux locale. связь с ascii

====
ascii
escape симолв и терминал escape коды и ASCII взаимосвязь ?

=======
kill process
terminate process

kill -9  $pid
kill -15 $pid


еще раз обсудим как происходит убиение процесса в системе.
дело в том что процесс это целая структура разных штук которые обеспечивают каркас процессу.
процесс неможет просто сам взят и както там испариться. если мы хотим удалить процесс то 
мало просто взят не помещать его код на цпу. в памяти остаесят куча разных стркутур которые 
давали каркас сущности процесс.

вначале дам список как это можно сделать:
один вариант - сам процесс делает вызов к сисколлу 60 exit().
второй вариант - процесс уничтожается по инициативе ядра.
третий вариант - процесс уничтжается по просьбе от другого процесса.
четвертый вариант - по кнопке от пользователя. 


рассмотрим подробно:

один вариант - сам процесс делает вызов к сисколлу 60 exit().
что дальше происходит. 

$ cat 31.asm
section .data
section .text
    global _start
_start:

    mov    rax, 60
    mov    rdi, 0
    syscall

$ nasm -g -f elf64 -l 31.lst  31.asm
$ ld -o 31.exe 31.o


проверим сразу ради интереса получим ли мы в программе ровно тот код который заказали
или там будет насовано куча доп кода

$ objdump -d ./31.exe -M intel

./31.exe:     file format elf64-x86-64


Disassembly of section .text:

0000000000400080 <_start>:
  400080:   b8 3c 00 00 00          mov    eax,0x3c
  400085:   bf 00 00 00 00          mov    edi,0x0
  40008a:   0f 05                   syscall 

видно что получили ровно тот код который заказали. это хорошо. ( а если бы мы вместо ld заюзали gcc то он бы напихал в шапку нашей программы еще кучу своего кода).

окей но щас речь не об этом. 
запускаем strace и наблюдаем какие сисколлы и сигналы происходят
с процессом при вызове exit() 

$ strace ./31.exe
execve("./31.exe", ["./31.exe"], 0x7ffcb39fd0e0 /* 74 vars */) = 0
exit(0)                                 = ?
+++ exited with 0 +++

значит видно что процесс делает сисколл exit() и после этого конец наступает процессу.
вроде бы логично. но здесь важно что - поскольку код сисколла exit неизвестен то интересно было узнать посылает ли ядро к процессу сигналы -15 или -9 после вызова exit или ядро грохает процесс сразу. так вот видно что убивается сразу без 
посылания сигнала процессу. если бы сигнал прилетал то strace бы это 
отобразил. значит получается что когда процесс просит ос прикончить его и вызывает сисколл exit() то кернел убивает процесс уже сразу без каких то дополнительных механизмов например без посылок сигналов -9 и -15 процессу.
опять же тут важно понять что сам процесс если он выполнил все что хочет и хочет прекратить свое существование то он неможет сам себя убить. потому что убить процесс в системе это значит то что 
нужно убит вычистить все структуры вспомогательные которые образуют каркас процесса. что это за структуры - структуры которые задают виртуальную память  , структуры 
которые в ядре описывают все настройки сущности процесса. вот это все сам процесс убить неможет
это все может убить только ядро. поэтому сам процесс может только попросить об этом ядро через 
сисколл exit(). важные слова неможет и попросить. а вычисткой уже занимается исключительно ядро.
и кстати как уже помним что ядро по факту в ответ на эту просьбу откликается и удаляет почти все структуры которые обеспечивают обвязку процесса но хвостик остается и пока парент процесс несчитает код возврата от чайлда через wait() ядро неудалит этот хвостик этот остаток от процесса.
и все таки еще раз очень существенно понять что процессы сами себя ни создать немогут и уничтожить себя из системы немогут. все это делает исключительно ядро (по своей инициативе, по просьбе 
самого процесса, по просьбе другого процесса.)

второй вариант - процесс уничтожается по инициативе ядра.
вот пример программы:
$ cat 38.c
#define _GNU_SOURCE
#include<stdlib.h>
#include<unistd.h>
#include<stdio.h>
#include<sched.h> 


int variable, fd;

int do_something() {
   variable = 42;
   printf("The parent: the variable = %d\n", variable);
   _exit(0);
}

int main(int argc, char *argv[]) {
   void **child_stack;
   char tempch;

   variable = 9;
   child_stack = (void **) malloc(16384);
   printf("The parent: the variable = %d\n", variable);

   clone(do_something, child_stack, CLONE_VM|CLONE_FILES, NULL);
   sleep(60);

   printf("The parent: the variable is =  %d\n", variable);
   return 0;
}


смотрим что покажет strace:
$ strace ./38.exe
clone(child_stack=0x56047fea9250, flags=CLONE_VM|CLONE_FILES) = 17642
nanosleep({tv_sec=60, tv_nsec=0},  <ptrace(SYSCALL):No such process>
<... nanosleep resumed> <unfinished ...>) = ?
+++ killed by SIGSEGV +++
Segmentation fault (core dumped)

тут видно что ядру чтото непонравилось и оно уничтожило процесс. а как оно это 
сделало через какой механизм? а через сигнал SIGSEGV, ядро послало этот сигнал процессу. а далее
так как мой процесс неимел хэндлера по обработке этого сигнала то вступил в силу дефолтовый обработчик этого сигнала от ядра а он процесс уничтожает в ответ на такой сигнал. ( а еще возможно (я непроверял) сигнал SIGSEGV неигнорируемый тоесть процесс неможет его заблокировать . единственное что я незнаю неигнорируемый сигнал может ли у него быть обработчик в программе или сразу начинает действоват ядерый хендлер сигнала). итак в случае когда само ядро инициирует унитожение процесса то оно это делает через посылку сигнала процессу.


третий вариант - процесс уничтжается по просьбе от другого процесса.
самый простой вариант. самый привычный.

в первом окне запускаем bash под strace
(окно1)$ bash strace

во втором окне определяем pid запущенного баша.
(окно2)$  ps aux | grep strace
vasya    18194  0.5  0.0  20800  3244 pts/155  S    00:25   0:00 strace bash

наши pid strace, щас найдем его чайлда который нам и нужен:

$ pstree  -A  -s  -p  18194
systemd(1)---systemd(1718)---gnome-terminal-(3866)---bash(18175)---bash(18184)---strace(18194)---bash(18196)

итак нашли pid баша = 18196

просим ОС завершить тот процесс:
(окно2)$ kill -15 18196

что увидим в первом окне
(окно1)$ --- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=18213, si_uid=1000} ---
rt_sigreturn({mask=[]})                 = -1 EINTR (Interrupted system call)

таким образом мы видим то что когда другой процесс (через сисколл конечно) ос завершить
другой процесс, то ядро завершает тот другой процесс через отсылку тому другому процессу 
сигнала. причем что интересно вот из этой строки 

--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=18213, si_uid=1000} ---

видно что

si_code=SI_USER, si_pid=18213, si_uid=1000

тоесть в прилетевшем сигнале
указано кто был его инициатором, что инициатором посылки сигнала был юзерский процесс,
и даже указан его pid и под каким юзером он работал.


четвертый вариант - по кнопке от пользователя. 
$ strace bash

далее тыкаем на кнопках Ctrl+C
и что мы видим

--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---

тоесть нажатие кнопки породило что ядро направило в процесс сигнал. 
причем в сигнале видно что заказчиком является как бы само ядро si_code=SI_KERNEL.
хотя ядро всего лишь исполнитель заказчиком является юзер за терминалом.

В целом что хочется сказать напоследок. видно что во всех случая процесс убивается 
через отсылку ему сигнала. а уже хендлер сигнала убивает этот процесс. за исключением случая
когда уничтожение процесса происходит по просьбе самого процесса через сисколл exit().
тогда убиение процесса происходит както сразу ядром напряму без отыслки сигнала процессу.или 
я как то пока несмоге его отловить.



=======
multitasking 
как это работает.


у нас есть таймер на компе. он периодически через ножку на цпу передает на цпу интеррапт сигнал.
когда это происходит то цпу прерывает то что он делает и лезет в хендлер этого интеррапта ( а хэндлер интеррапта записан в память операционной системой загодя таким образом хэндлер интеррапта 
то тоже код ядра) , насколько я понимаю этот хендлео он перенаправляет выполнение на шедулер.
а шедулер уже смотрит на очередь процессов и принимает решение какой процесс следущим пихать
на цпу. так работает мудьтиитаскинг. что непонятно кто отвественен за сохранение и восстановление
регистров в оперативке в случае интеррапта. это сам цпу автоматом делает когда сигнал интеррапта
на его ножку прилетает или это делает хэндлер или на какой стадии кто сохраняет состояние 
регистров которое было до наступление интеррапта.  4


из того я нашел во время происходит все вот как. 
прилетает сигнал на ножку цпу которая про интеррапт. потом по шине данных от контроллера
преррываений прилетает номер прерываения. окей цпу знает номер прерываения.

далее цпу сам автоматом сохраняет EIP (регистр который указывает на адрес в памяти следующей 
команды которую надо выполнить. хотя тут пока неясно ведь EIP это не единственный регистр который 
нужен чтобы определить адрес команды в памяти) в память. сохраняет как я понял через команду
push тоесть в стек. но стек это все равно память. вопрос но ведь ссылку на стек тоже нужно где то сохранять.  но вроде как EIP это единственный регистр который цпу сохраняет сам. далее цпу передает
управление на хэндлер. и уже отвественность хэндлера за то чтобы сохранить все остальные регистры
чтобы можно было удачно вернуться.тут тоже интересный момент если перед моментом запуска хендлера
цпу сохраняет всего один регистр а далее передает на хэндлер прерывания то возникает вопрос 
может ли хендлер интеррапта быть прерван другим интерраптом ведь если да то легко может получится
что текущий хендлер еще неуспел сохранить все регистры а уже его код прерывал другой хендлер другого интеррапта.  Interrapt handler зовется еще по другому ISR - Interrupt Service Routine.

 я нашел что да один интеррапт может прерываться другим интерраптом. положим что первый интеррапт
 только начал сохранять регистры и сохранил два регистра из тридцати и тут случился более важный
 интеррапт. как я понимаю тут логика такая - каждый интеррапт хендлер прежде чем начать чтото делать сохраняет все регистры или по крайней мере те регистры которые собирается менять таким 
 образом вызов ISR внутри другого ISR неломает систему данных в регистрах. но при такой системе
 все упирается в акуратносить прогарммирования в то что ISR прежде чем чтот делать должен прежде
 всего сохранить все регистры и только потом начинать чтото делать.

 тутже я напоролся на такой термин как reentrant. в программировании он значит что если у нас
 ест какойто код (функция) то оназывается reentrant если если мы можем прервать ее выполнение
 в любом месте запустить заново (на этом или другом цпу) и при этом мы сможем получить резуль
 тат коректрный который ничего не поломает при условии что предыдущий вызов функции еще
 неотработал.  пример такой . вот у нас функция и она входе своего выолпнения блокирует
 некий ресурс  и тут бах срабатывает например интеррапт хендлер и и он тоже иползует этот ресурс
 и получается хендлер неможет отработать потому что ресурс уже заблокирован исходной
 функцией а она стоит у нас. 

я пока еще непонял на счет момента относительно когда у нас выполняется ISR (interrapt service routeint) тоесть хэндлер интеррапта как там насчет заблокировано ли прерываение этого хендлера 
или нет. пока я понял что что код хендлера вначале своего исполнения может заблокировать прием со стороны цпу новых интерраптов пока выполняется наш хэндлер. однако есть как я понимаю и вариант
что хендлер неблокирует прием новых интерраптов со стороны цпу и тогда наш хендлер может быть
прерван другим интерраптом. что также известно что сам цпу неимеет никакого никакой очереди 
в которой бы накапливались интеррапты. он может либо принять интеррапт либо непринять.
работу по интерраптам на себя берет контроллер интерраптов. что делает контрроллер прерыаений: если у нас несколько интерраптов приключаилось то у них есть приоритетность так вот контроллер
инерраптов выбирает тот который самый приориеттный и только его пихает на цпу. также контроллер
как я понял может подержать в очереди один или два прерывания. однако если цпу все таки будет 
медленно обрабатывать прерывания и скажем в очереди будет три прерывания то как я понял часть прерываений начнет скажем так "теряться" что это значит на практике я незнаю пока.

на счет вообще зачем нужны интерапты затем что устройство хочет чтобы цпу обработал порцию байтов
от устройства чтобы в итоге байты от устройства перекочевали в некую область оперативной памяти
а поскольку устройство незнает куда в память качать данные и как это сдлеать то нужен цпу а цпу чтобы это знать надо запусить хендлер который знает куда в память качать байты от устройства.
да устройства может качат данные в память без участия цпу через DMA контроллер. но там все равно
хоть и отчасти нужен цпу. итак инфо которая поступает в устройства их нужно пееркачать в память 
без цпу условно говоря это несделать. что дает именно мехаизм интерраптов это то что вместо 
того чтобы ждать когда от железки поступит сигнал цпу делает другие дела  а когда в жеелезку поступает сигнал то интеррапт дергает цпу за руку.

по поводу статуса процесс как S (interruptible sleep)  вэтом состоянии процесс (его код контекст)
шедулером несуется на цпу потому что процессу нечего делать. как я понимаю там регистрируется в ядре что мы ждем некое событие. и пока оно непроизойдет ядро шедулер небудет совать процесс на цпу.
а вот когда заказанное событие произойдет тогда цпу и "разбудит " процесс другими словами сунет 
код процесса обратно на цпу ибо у него пояивилось что делать снова. на счет того что он интерраптибл как я понимаю это значит что процесс процессу можно послать сигнал. например kill -9 или kill -15 и либо кастомный хендлер либо деолфтотвый от ядра отрадотает на этом процессе.
но главное что я хотел подчеркнуть что если процесс в состоянии S то его код несуется на цпу. это ключевой момент. есть еще статус процесса D (uninterrptuble sleep) такой процесс тоже его код
несуется шедулером на ядро но этот процесс небудет отвечать на сигналы потому что он ждет 
ответа от ядра обычно это работа с диском например тоесть если процесс грохнуть то как я понимаю
можно получить на диске какой то мусор. тоесть corrupt данных. поэтому надо ждать пока
ядро ответит процессу. 


про семафоры. что это такое.
есть две функции P и V. они отвечают за доступ к некоему критичному ресурсу к которому одновременно
можно чтобы имело доступ скажем один процесс или несколько скажем три. как это работает.
процесс лезет в функцию P и проверяет чтобы она была >0 если это так то процесс получает
доступ к ресурсу. и одновременно значение функции P уменьшается на 1. а если при доступе
процесса ( а скорее всего все таки треда) к P показыает что значение функции 0 или меньше нуля
(правда неочень понятно как оно может быть меньше нуля) то процесс (или тред пока неясно) ждет пока P станет больше нуля чтобы получить доступ к ресурсу. (как он ждет тоже непонятно он регулярно обращается или там есть какойто механизм уведомления).  если у нас изначально P=1 
значит только один процесс может иметь доступ  к ресурсу такой вид семафора называется mutex (mutual exclusion). а если P>1 изначално скажем P=2 то к ресурсу может иметь одноверменно 
доступ два процесса это уже семафор . мьютекс тоже семафор но конкретный частный случай.

тут еще пришла мысль а нафига нам нужно было придумывать такую штуку как stack то есть в цпу есть команды push\pop  есть регистры которые укзываются на стек. стек это кусок в памяти в которую 
можно пихать данные туда и обратно в цпу не через mov команды а через push и pop вот и возникает 
вопрос нахера вобще стек если можно было бы mov использовать? пока ответа ненашел.
зато: кажоый процесс имеет два стека. один используется когда цпу работает в ring3 с кодом
процесса (юзерский код) а второй стек используется когда через сисколл цпу переключается на ring0
и на ядерный код. тогда другой стек используется.



про context switch(синонимы process switch\task switch). есть понятие cpu context switching а есть linux process context switching
 а есть software context switching а есть cpu hardware context swithing.
поехали.во первых линукс неиспользует intel tss. потому что это очень медленно. гораздо быстрее
это делать вручную тоесть руками а не с помощью железных возможностей цпу. это делает код 
более переносимым якобы и это выполняется быстрее потому что зачастую ненужно сохранять 
все хрени и этого хватит для переключения процессов а выполнится быстрее.
набор регистров которые нужны чтобы процесс мог успешно продолжть свою работу называется 
hardware context. в линуксе часть hardware context сохраняется в кернел стеке а часть в процесс
дескрипторе.(о как!) , тоесть часть регистров пихается в стек а часть в процесс дескриптор.

что такое intel tss - одно уже известно сразу. в 64битном варианте нет никакого режима TSS.





================


syscall


где можно найти список всех сисколлов.
один способ это 

man 2 syscalls
хотят тут несовсем сиколлы а libs обертки которые уже обращаются к ядерным сисколлам
прикол в том что порой они имеют одинаковые имена а порой и нет. тамже ( man 2 syscalls) указано
в каких манах искать тот или иной "сисколл". но в этих манах нет порядкового номера сисколла


второй способ это 
в файле /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h
можно посмотреть какие сисколлы есть в линуксе. они там все указаны и там также указан порядковый
номер сисколла. (порядковый номер нам нужен если мы собираемся вызываь сисколл через ассемблер)

выглядит это так:

#ifndef _ASM_X86_UNISTD_64_H
#define _ASM_X86_UNISTD_64_H 1

#define __NR_read 0
#define __NR_write 1
#define __NR_open 2
#define __NR_close 3
...

это и есть те самые fork() итд.

каждый сисколл имеет имеет свой номер

write = 1
fork = 57

signal - c этим интересно. согласно man 2 signal - By default, in glibc 2 and later, the signal() wrapper function does not invoke the kernel system call.  Instead, it calls sigaction(2).
и все верно. в unistd_64.h мы ненайдем сисколла signal. его просто нет. а вот sigaction есть.
таким образом signal это не сисколл. это wrapper функция libc вызывающая настоящий сисколл sigaction. sigaction имеет номер 13
 
waitpid - c ним тоже самое. это не сисколл. это libc обертка по вызову сисколла wait4. 
в unistd_64.h мы ненайдем сисколла по имени waitpid. а вот wait4 тут есть. с номером 61.
о том что waitpid это не сисколл а обертка написано в man 2 waitpid - On some architectures, there is no waitpid() system call; instead, this interface is implemented via a C library wrapper function that calls wait4(2)

mmap =9

кстати спросите а зачем нам номер этого сисколла. дело в том что когда мы в C программе вызываем
тот или иной сисколл по имени то компилятор вызывает на асемблере сисколл именно по номеру.
в опрееленный регистр цпу на асемблере кладется именно номер сисколла. а далее вызывается асмеблерная команда syscall. и когда цпу переключаился в привлигированный режим то он смотрит в
определный регистр и ищет там номер чтоб понять к какойму сисколлу юзер программа хочет обратиться.
сисколл с точки зрения кода ядра его некоторая функция.

пример вызыва сисколла с номер 1 тоесть тот который сисколл write.

$ cat 1.asm
section .data
    msg db      "hello, world!"
    msg1 db     10
section .text
    global _start
_start:
    mov     rax, 1
    mov     rdi, 1
    mov     rsi, msg
    mov     rdx, 13
    syscall

    mov     rax, 1
    mov     rdi, 1
    mov     rsi, msg1
    mov     rdx, 1
    syscall

    mov    rax, 60
    mov    rdi, 0
    syscall


компилим
$ nasm -g -f elf64 -l 1.lst  1.asm
$ ld -o 1.exe 1.o

запускаем
 $./1.exe
hello, world!

в этой программа вызывается три сискола.
первый сискол это сисколл 1 тоесть write

есть такой станарт ABI он определяет в какие регистры и что надо положить
чтобы при вызыве ассемблерной команды syscall цпу\ос (или кто там я незнаю) поняли какой сисколл
просит запустить юзерская программа у ядра и в каких регистрах искать праметры с которыми
запускать этот сисколл.(ибо сисколллы требуеют параметры). сисколл еще раз это с одной стороны
команда цпу (тоесть свойство железки )  с другой стороны это функция в пространстве кода ядра.

иатк про регистры что куда надо класть перед запуском цпу команды syscall

RAX — This register contains the system call number. сюда надо записать номер сисколла который 
мы хотим вызвать. в нашем соучае мы туда пишем 1 единицу

mov     rax, 1

номера сисколллоа надо искать в unistd_64.h (тот который выше указан)

RDI — this register contains the value of the first argument to be passed to the system call
в случае нашего сисколла write первый параметр это номер файлового десктриптора куда 
мы хотим чтото писать. в нашем случае это станадртный вывод. тоесть дестриктор =1 поэтому

mov     rdi, 1


RSI — this register contains the value of the second argument
втторой аргемент для write это то что мы хотим записать. точне туда кладется ссылка на ячейку
памяти в которой лежит то что мы хотим записать

mov     rsi, msg

RDX — 3rd argument
третий аргумент сколько байт наше сообщение занимает. внашем случае 13 байт.


mov     rdx, 13

все . все перменные для вызова сисколла write подгтовлены можно его вызывать

syscall

на экане будетт напечаатано 


hello, world!

проблема в том что небует знака переноса строка. я незнаю как его красиво
вставить в  msg db      "hello, world!"  поэтому для печати символа переноса строки 
это ascii сивол с dec номером 10 ( man ascii)  я исползую следущий второй сискол write

        msg1 db     10

        mov     rax, 1
    mov     rdi, 1
    mov     rsi, msg1
    mov     rdx, 1
    syscall


третий сисколл это сисколл которйы просит ядро завершит процесс. убить его. это сисколл с номером 60
который называется exit


        mov    rax, 60
    mov    rdi, 0
    syscall


в rax мы калдем номер сиколла 60
в rdi мы кладем номер кода возврата 0 ( все успешно)
тоесть всего два регистра нам надо запрограммировать

и мы вызываем сисколл через команду цпу

syscaall

победа!

важно понять что наш вывзов сисколла когда цпу переключится в привилигорваннй режим обрабатывает
код ядра операционной сситемы. если бы когда цпу перклювился в привлигированнй режим там бы небыло операционной системы то небыло бы никакого эффекта. нужен код ядра по ту стороны от непривилигированного режима. тоесть мы юзаем асемблер только для того чтобы передать переменные
на ту стороны из непривлигорванного режима в режим привлигоровынный чтобы тамошний код по ту сторону
смог получить переменные.  если бы небыло ос по ту сторону то запустив голвый асемблер код мы бы ничего неполучили в иттоге  цпу переключился бы а там нихера нет никакого кода который бы мог 
принять наши переменные.

что интересно - для того чтобы создать процесс мы в нашей программе недолжны использовать никакой
сисколл. это как на автоматате происходит а вот завршение работы программы неможет быть 
выполнено на автомате. мы должны сами в коде в явном виде попросить сообщиь ядру о том что 
наша программа хочет завершить свою жизнь через сисколл 60 exit.

интересно что даже через голый асемблер из юзерспейса мы неможем получить доступ к голому железу
наппрямую. на примере сисколла write - мы только можем сунуть данные в некую асбтракцию файловый 
дескрпитор который является некой асбтракцией представленной ядром. и только то.

поскольку сисколл это детище ОС ее функции то получается в коде ос надо искать спецификацию
какие переменные нужны для вызовра сисколла. в каком виде итд если мы хотим запускать сисколлы
через асемблер. например для сисколла write = man 2 write 

NAME
       write - write to a file descriptor

SYNOPSIS
       #include <unistd.h>

       ssize_t write(int fd, const void *buf, size_t count)

и там написано что 

write() writes up to COUNT bytes from the buffer starting at BUF to the file referred to by the file descriptor FD.

тоесть видим что три переменные. и что они значат. ровно их мы и юзали (четвертая переменная rax 
использовалась чтбы сообщить ядру номер сисколла кооторый хотим юзать)

        mov     rax, 1

    mov     rdi, 1
    mov     rsi, msg1
    mov     rdx, 1


так. ну тут еще надо при этом понять что как я понимаю что через man если искать то мы 
на самом деле ищем формат не кернел сисколла а libc оболочки которая вызывает сисколл.
но все же man имя_сисколл это хороший источник посмотреть спецификацию сисколла чтобы его 
верно вызывать через асемблер.


по поводу каков механизм сисколла. как это все происходит. еще раз.
юзер программа кладет в в eax\rax регистр номер сисколла который мы хотим вызвать а в
регистры rdi,rsi, и другие кладет аргументы для сисколла (параметры). далее юзер программа
использует цпу команду syscall ассемблерную
что делает цпу выполняя команду syscall ассемблерную - цпу пеерклчаеся в привилигированный
режим. и в цпу есть спец регистры называются MSR их целая кучка. они служат разным особым целям и 
вот там среди них есть спец регистры которые служат исключительно целям обеспечения работы 
ассемблер команды syscall\sysret. эти регистры программируются ядром линукса заранее.

первый регистр: STAR
 STAR регистр переводится как SYSCALL/SYSRET Target Address Register (STAR) и содержит в себе
the target EIP address used by the SYSCALL instruction and the 16-bit code and stack segment selector bases used by the SYSCALL and SYSRET instructions.
а что за смысл eip ? ответ - EIP is a register in x86 architectures (32bit). It holds the "Extended Instruction Pointer" for the stack. In other words, it tells the computer where to go next to execute the next command and controls the flow of a program. вот еще про смысл eip - eip, or the instruction pointer, is a special-purpose register which stores a pointer to the address of the instruction that is currently executing. хмм. тоесть написано что внем содержится адрес в памяти команды которая щас выполняется. хотя чуть дальше там же пишут что - After each instruction, a value equal to the size of the instruction is added to eip, which means that eip points at the machine code for the next instruction. тоесть все таки это регистр содержит 
адрес в памяти команды которая должна будет быть выполнена следующей. тоесть указан адрес где искать команду которую надо будет выполнить следующей. ну уже понятней.
правда eip у нас 32 бит. а какже обстоит делов случае x64. ну ладно это уже сложные детали.

значит еще раз  у этого регистра который 64 бита длинной биты содержат такие штуки:

биты 0-31 содержат = TARGET EIP address (тоесть адрес в памяти где лежит следущая команда которую надо будет выполнить)  я так понимаю там лежит адрес ядерного хендлера или как там эта хрень называется короче та самая функция обработки всех сисколлов. обработчик сисколлов верхнего уровня.(кусок кода уровня ядра).


биты 32-47 содержат = syscall cs selector и ss selector base

отсановился на том что надо понять смысл cs и ss регистров в разрезе 64бит памяти по сути
надо понять linux 64 bit memory model через какие регистры происходит адресация в памяти.
я понял что когда унас real mode режим памяти тогда адрес в памяти определется через сумму
CS:IP, оба регистра 16бит. это 64KB. адрес в памяти вычисляется по формуле 

memory address = CS*0x10+IP

в таком режиме можно адресовать 1МБ памяти. тоесть

FFFF*10+FFFF " | bc
10FFEF

а 10FFEF байт это 1МБ.


Некоторое отступление от темы но тоже очень важное = вот у нас работает процесс в режиме ring3
юзерский режим. вот мы вызываем syscall и цпу переключился на ring0 и запустил код ядра. вопрос
какой статус будет иметь процесс в top либо ps. и тут прикол вот в чем. насколько я понимаю 
код ядра будет выполняться с точки зрения шедулера в том же самом таймслайсе что был выделен
исходному процессу. пока немогу прям точно все расписать и аргументировать но для шедулера
все остается типа по прежнему тот же самый процесс работает без изменений. Это значит что 
далее статус процесса зависит от кода самого сисколла. например если коду сисколла мало что 
надо и скажем только достаточно цпу то статус процесса будет 'R'.
я провел важный эксперимент:
запустил команду
$strace dd if=/dev/urandom of=/dev/null bs=30M count=1000

она показывает на экране постоянно вот такую картину
read(0, ",g\32155\320,\16\16\261\22\240\27b\303\34\311\276\240M0\33)\331"..., 31457280) = 31457280
write(1, ",g\321\366\20332\2261\22\240\27b\303\34\311\276\240M0\33)\331"..., 31457280) = 31457280
read(0, "\20W\340M;j\233\3247\361\317\252fiD\374"..., 31457280) = 31457280
write(1, "\20W\340M;j\233\31316\247\361\317\252fiD\374"..., 31457280) = 31457280

то есть процесс по факту все время делает только сисколлы и больше нихера.
логично предположить что процесс буквально все время сидит в кернел моде.

далее смотрим в top либо ps и там видно что статус процесса все время 'R'
ну уже как бы верится что этот R он неможет быть из за того что цпу пашет в юзерском режиме
ибо в юзеском режиме там просто нихера нет кода никакого. но хотим еще убедитсяь надежнее
запускаем 
$nmon

и видим что цпу на 100% занят только кернел моде нагрузкой.
но нам и этого мало. может быть ненаш процесс работает в режиме кернела а какойто другой
компонент системы. мы тогда лезем в procfs и там постоянно считываем две цифры 
из статуса процесса


$ awk '{print $14, $15}' /proc/18774/stat
0 3915

первая цифра это = Amount of time that this process has been scheduled in user mode, measured in clock ticks
вторая цифра это = Amount of time that this process has been scheduled in kernel mode, measured in clock ticks

и мы будем видеть что первая нихера нерастет а вторая постояно растет.
так что мы получили 100% подтверждение что наш процесс имеет 'R' и эта R связана именно с тем
что выполняется код ядра "от имени нашего процесса" с точки зрения шедулера.
детали надеюсь смооу обьяснить позже.
вопрос родился потому что навсидку реально мало понятно что происходит с процессом после того 
как он вызывал сисколл с точки зрения шедулера как меряется статус процесса. может быть он 
условно говоря сразу в спячку (состояние S впадает или в состяние D к примеру.). более того 
я нашел на стэковерфлоу неверный ответ там утвержали что процесс автоматом впадает в состояние D.
что намой взгляд верно но только в части случаев но отнюдь невсегда. а зависит именно от самого
кода сисколлаа и всякого другого. если бы скажем я писал данные не на/dev/null а на шпиндельный
диск который медленный тогда получается что наш сисколл вынужджен был бы ждать ответ 
от диска  и тогда бы да был бы статус D но не из за сисколла как такоовоо а из за последубщего
компонента - медленного диска. пока вопрос остаетя в некотором роде открытым.
Насколько я понимаю на данный момент когда мы запускаем команду syscall\int 80 то мы



далее надо разобратсья так как же через какие регистры происходит адресация в 64 битном режиме
в протектед моде  в режиме ядра

...
=====================
gcc

как компилировать чтобы он сохранял код ассемблера чтобы можно 
было посмотреть без дизассмблирования. причем чтобы он писал код ассемблера
в intel формате


$ gcc -S -masm=intel 51.c 
$ cat 51.s



=====================
leave

очень часто вначале main идут команды

    push   rbp
    mov    rbp,rsp

так вот есть команда которая делает все наоборот это LEAVE она делает:

    mov  rsp,rbp
    pop  rbp

кстати первые две команды эквиваленты команде ENTER. но она гораздо дольше работает 
чем две отдельные. в этом плане LEAVE вроде как работает достаточно быстро по сравнению с 
ее двумя командами эквивалентами поэтому leave все таким применяют сейчас а enter нет.

а в чем разница leave с ret?

=====================
push
pop

значит я проверил что реально когда мы суем push в стек
то он сдвигается на 8 байт ( 64bit код) и 4 байта (32bit код)

пример программы:
64bit:

$ cat 32.asm
section .data
section .text
    global _start
_start:

    mov    rax, 0xffaaaa
    push   rax
    pop    rax

    ; exit(0)
    mov    rax, 60
    mov    rdi, 0
    syscall



32bit:

$ cat 32.asm
section .data
section .text
    global _start
_start:

    mov    eax, 0xffaaaa
    push   eax
    pop    eax

    ; exit(0)
    mov    eax, 60
    mov    edi, 0
    int 80

(замечу что в 32битном виде у цпу нет команды syscall а вместо нее только int 80)

компилируем в 64bit код

а вот пример как откомпилировать с debug символами (чтобы потом в gdb смотреть)
$ nasm -g -f elf64 -l 32.lst -o 32.o 32.asm
$ ld -o 32.exe 32.o

компилируем в 32bit код

а вот еще как откомпилировать с debug символами в 32bit файл
$ nasm -g -f elf32 -l 32.lst -o 32.o 32.asm
$ ld  -m elf_i386   -o 32.exe 32.o


$ gdb ./32.exe
> b _start
(gdb) set disassembly-flavor intel
(gdb) disassemble
(gdb) run
(gdb) info registers
(gdb) nexti


в случае 64бит код после команды push esp изменяется 
с
0x7fffffffdc60
до
0x7fffffffdc58

разница 8 байт , верхушка стека движется вверх.



в случае 32бит код после команды push esp изменяется 
с
0xffffce40
до
0xffffce3c

разница 4 байт , верхушка стека движется вверх.
===================
ia32
x86-32
32bit  mode

вобщем открыл для себя что 
вот у нас есть 32битный код машинный. и в нем мы хотим вызывать сисколл.

во первых номера сисколлов для 32 битного режима и для 64 битного они разные.
пример для сисколла exit

$ cat /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_64.h | grep exit
#define __NR_exit 60

$ cat /usr/src/linux-headers-5.4.0-91-generic/arch/x86/include/generated/uapi/asm/unistd_32.h | grep exit
#define __NR_exit 1

тоесть в 64битном режиме это 60-ый номер а в 32-битном режиме это номер 1.



далее. если в в 64 битном режиме мы кладем:
номер сисколла в RAX
первый параметр сисколла в RDI

то в 32 битном режиме мы кладем:
номер сисколла в EAX
первый параметр сисколла в EBX



далее. в 32битном режиме мы неможем использовать асемблерную команду syscall для вызова
сисколла она просто там неработает. ее там нет.  и попытка ее вызова вызовет то что 
ядро пришлет процессу сигнал SIGILL.

(я правда непонимаю 
почему компилятор позволяет ее использовать в 32 битном коде почему не посылает с ошибкой).
пример , вызываем сисколл exit()  в 32 битном режиме

$ cat 34.asm
section .data
section .text
    global _start
_start:

    mov    eax, 1    ; номер сискола exit()
    mov    ebx, 0    ; код возврата
    syscall

$  nasm -f elf32 -o 34.o 34.asm
$  ld  -m elf_i386   -o 34.exe 34.o

а вот еще как откомпилировать с debug символами в 32bit файл
$ nasm -g -f elf32 -l 32.lst -o 32.o 32.asm
$ ld  -m elf_i386   -o 32.exe 32.o

$  strace ./34.exe
execve("./34.exe", ["./34.exe"], 0x7ffd56c744b0 /* 74 vars */) = 0
--- SIGILL {si_signo=SIGILL, si_code=ILL_ILLOPN, si_addr=0x804806a} ---
+++ killed by SIGILL (core dumped) +++
Illegal instruction (core dumped)


вызов сисколла через int 0x80 в 32 битном режиме работает без проблем:
$ cat 34.asm 
section .data
section .text
    global _start
_start:

    mov    eax, 1
    mov    ebx, 0
    int 0x80


$ strace ./34.exe 
execve("./34.exe", ["./34.exe"], 0x7ffc5dad7880 /* 74 vars */) = 0
strace: [ Process PID=12424 runs in 32 bit mode. ]
exit(0)                                 = ?
+++ exited with 0 +++


а вот вызов сисколла в 32битном режиме через sysenter имеет реальные приколы.
если мы заменим int 0x80 на sysenter то мы получим ошибку SEGFAULT.
а в чем же дело? ответ нашел вот здесь - https://reverseengineering.stackexchange.com/questions/2869/how-to-use-sysenter-under-linux :

the sysenter instruction expect to have the stack forged in that way:
0x______0c  saved_eip   (ret)
0x______08  saved_%ecx  (pop %ecx)
0x______04  saved_%edx  (pop %edx)
0x______00  saved_%ebp  (pop %ebp)

хотя по факту судя по коду из ответа и я проверил на практике надо сделат и еще кое что.
итого перед вызовом sysenter надо кое чего сделать дополнительно :

в самом начале функции надо добавить команды

        push ebp
        mov  ebp, esp

а перед вызовом sysenter надо вставить

        push   $_start
        push   ecx
        push   edx
        push   ebp
        sysenter 

итого скажем для вызова сисколла exit(0) в 32битном режиме через systenter надо

$ cat 34.asm
section .data
section .text
    global _start
_start:
    push ebp
    mov  ebp, esp

    mov    eax, 1
    mov    ebx, 0

    push   $_start
    push   ecx
    push   edx
    push   ebp
    sysenter


для сравнению приведу тот же самый сисколл через int 0x80
чтобы была видна разница сколько всего нужно добавить чтобы тотже сисколл успешно
прошел через sysenter

$ cat 37.asm
section .data
section .text
    global _start
_start:

    mov    eax, 1
    mov    ebx, 0

    int 0x80


как говорится почуствуй разницу.
а если вот эту обвязку вокруг sysenter несделать то програма будет вылетать с ошибкой SIGFAULT.

естественно сама инструкция sysenter на цпу невиновата (тоесть цпу ни причем) а виноват
хендлер ядра линукск который обрабатывает по разному переход в сисколл в зависимости от команды
цпу ( я так понял).

общий вывод такой по сисколлам :
для 64 битного машиноого кода - юзай syscall
для 32 битного машинного кода - юзай int 0x80

и никакой ебалы тогда небудет.

sysenter якобы работает быстрее но вот с ним дополниельные заморочки нужно делать.


также видно что в тексет асемблера используется необычная инстркция

push   $_start

она приводит к тому что будет в файле подставлен адрес начала функции _start.
тоесть это делается средставами компилятора. как получить в программе адрес старта текущей
функции я пока незнаю.

вот как выглядит дизасембл код: 

08048060 <_start>:
 8048060:   55                      push   ebp
 8048061:   89 e5                   mov    ebp,esp
 8048063:   b8 01 00 00 00          mov    eax,0x1
 8048068:   bb 00 00 00 00          mov    ebx,0x0
 804806d:   68 60 80 04 08          push   0x8048060
 8048072:   51                      push   ecx
 8048073:   52                      push   edx
 8048074:   55                      push   ebp
 8048075:   0f 34                   sysenter


соотвтсвенно  push   0x8048060, 
где  0x8048060 это адрес старта функции <_start>:

далее для понимания входов в сисколл полезно все таки понять - на сколько смещается стек
когда в него чтонибудь пихают, насколько смещается стек когда используется инструкция call,
когда используется инстрация ret.
рассмотрим случай когда мы вызываем функцию в C программе.
только текст сразу напишем на асемблере.

$ cat 38.asm
section .data
section .text
    global _start
_start:                                     0xffffce40

xor  eax,eax
mov  ax, 0x1        #word1
push ax                     -2b             0xffffce3e
mov  ax, 0x2        #word2
push ax                     -2b             0xffffce3c
call vasya                  -4b             0xffffce38
pop ax                                      0xffffce3e
pop ax                                      0xffffce40 (полностью восстановили стек поинтер обратно)

mov eax, 0x1
mov ebx, 0x0
int 0x80


vasya:

push ebp                    -4b             0xffffce34
mov  ebp,esp
xor  eax,eax

получается расстояние от ebp до начала программы (start) = 12байт (4+4+2+2)
а word1 ближе к ebp на 2 байта. значит от ebp до word1 = 10байт
подставляем в следующую команду

mov  ax, [ebp+10]   # word1 

word2 находится к ebp ближе еще на 2 байта. значит между ebp и word2 = 8байт
подставляем в следующую команду

add  ax, [ebp+8]    # word2
pop ebp                     +4b             0xffffce38
ret 0                       +4b             0xffffce3c (ровно то значение которое было у esp 
                                                до того как инструкция call начала выполняться 
                                            таким образом ret аннигилует смещение стека от call )


напротив команды я написал чему равен esp после того как эта команда уже
выполнена (тоесть недо ее выполнения а после уже)

Видно что при запуске call эта команда сует EIP (4 байта  в 32битном режиме) в стек тоесть она как бы делает push EIP.
Команда ret вытаскивает из стека в EIP 4 байта тоесть ret как бы делает pop EIP а далее цпу делает jmp на этот EIP уже сам.

Также теперь видно что переменные передаются функции через предвариетельное сование их в стек.

по поводу gdb.
чтобы установить брейкпоинт не на название функции а на адресе
то 

(gdb)  b *0x23432131

чтобы напечататать занчение у регистра

(gdb) print /x $esp

чтобы узнать содержимое ячекки памяти

(gdb) x /(число_юниов_памяти)(в каком виде показать содержимое)(размер юнита памяти)

например число юнитов = 2
показать в  hex виде = x
размер юнита памяти это байт= b

тогда

(gdb) x /2xb

если забыл то

(gdb) help x 

хочу на верхнем примере пояснить на счет команды ret n
если n=0 то это эквивалентно 

ret

или 

ret 0

при этом ret что делает. он просто вытаскивает из стека в EIP 4 байта ( в 32 битном режиме)
и далее цпу делает jmp на этот EIP.
итак при n=0  у нас ret из стека вытаскивает 4 байта.
если n=1, тоесть

ret 1

то тоже самое только ret вытащит из стека +1 дополнительный байт. тоесть он вытащит 4 байта в EIP и еще +1 байт. единственное только я незнаю куда он его вытаскивает. возможно что он 
просто смещает esp на 1 байт.

соответсвтенно если n=4, тоесть

ret 4

то он вытащит 4 байта в EIP и еще +4 байта будет смещение стека к его основанию.
захера это надо - я еше  это точно неуточнил но тут вопрос в том что мы перед вызовом функции 
(инстркция call) пихаем в стек через push переменные к этой функции . возникает вопрос.
то ли размешаеть потом pop команды после вызова функции как я это сделал выше. тоесть мы 
в основном теле программы засунули параметры в стек вызывали функцию вернулись из нее и сами
вытащили в теле основном эти переменные обратно тоесть очистили стек. а можно очищеие
стека от переменных делать в вызываемой функции в ее конце через ret n.

вот пример. я модифицировал вернхнлюю программу когда мы через ret n чистим переменные в 
теле вызываемой функции тогда в теле основной функции нам уже это делать ненадо (через кучку pop)

$ cat 38.asm
section .data
section .text
    global _start
_start:

xor  eax,eax
mov  ax, 0x1
push ax
mov  ax, 0x2
push ax
call vasya

mov eax, 0x1
mov ebx, 0x0
int 0x80


vasya:

push ebp
mov  ebp,esp
xor  eax,eax
mov  ax, [ebp+10]
add  ax, [ebp+8]
pop ebp
ret 4



как говорится найдти три отличия.
а так тут важно понимать что значит цифра в ret 4. 
важно понимать на сколько байт осядет стек esp после ret4 . он осядет на 4байта+4байта =8байт


Возвращаемся к сисколам.
 важный момент: по поводу через какую асемблер команду надо вызывать сисиколл (входить в сисколл). Что касается режима 64bit то это прописано в "System V Application Binary Interface" = .
 тут надо сразу поорттянку "system V ABI"писать про очередную мудоту.
 есть три стандарта:
 POSIX
 Single UNIX Specification
 Open Group Base Specifications?

 а есть еще стандарт:
 System V Interface Definition

 так вот он както относится  к тем трем что выше.
 в целом эти стандарты (я не смоотрел документы кроме POSIX) описывают как в операционной 
 системе все должно выглядеть с точки зрения ( и тут заминка хуй обьяснишь потому что еще только нет понятия.) разного рода деталей таких как: например там написано что ОС должна
 иметь такие хрени как сигналы такие как SIGKILL, SIGSTOP и еще там куча сигналов, еще там написано что When a terminal device file is opened, it normally causes the thread to wait until a connection is established. и там много еще каких моментов требований к ОС указано. пока почти нечитал. так вот там все прописано с точки зрения програмный софтовых моментов
 но софт крутится на реальном железе например на цпу в котором есть регистры. так вот 
 "system V ABI" он увязывает POSIX грубо говоря и как его накладывать на железо. например
 там указано что если в ОС происходит вызов сискола то номер сискола надо положить в регистр RAX. а если сисколл имеет параметр то положить его в такойто регистр. тоесть происходит привязка софтовых моментов к реальному железу. захера это надо... турдно сказать. например часто пишут что это дает то что одна функция может пользуясь аби положить переменные в железку в цпу а вторая функция зная что первая ответчает ABI она сможет эти параметры считать зная где они лежат. 
 для каждого типа архитектуры цпу и каждого условно говоря posix будет свой avi документ.
 если брать только один posix и его неменять и взять три архитерутуры цпу - intel 32bit, intel 64bit, arm 32bit то уже получаем три abi. 

кстати что прикольно в плане железки рассматриветася как я понял только цпу. другие железки
неучаствую в формировании abi. наверное потому что программа в виде машинных кодов юзерская
она напрямую работает соприкасается только с цпу в голом виде а со всеми другими железками
юзерская прогармма соприкасается только через сисколлы абстракцию обеспечиваемую ОС.
вобщем по факту со стороны железок в abi участвуют только цпу и никакие другие железки.
что забавно.

так вот в abi для интел 64 бит(железка ) с одной стороны  и posix( а ля линукс) с другой стороны про сисколлы прописано что:

A system-call is done via the syscall instruction
The number of the syscall has to be passed in register %rax 

вот это я ихотел  в итоге выразить.

а вот для интел 32 и линукса abi уже ничего неговорит как же там положено делать сисколл.
через какие асемблерные инструкции и регистры положено все это вызывать.
вот это меня удивило.

насколько я понимаю скажем код ОС написан на машинных кодах . машинные коды
они жестко прописаны в цпу. но у них очень мелкие последствия что они делают - скачать байт из
памяти сложить с другим байтом. записать из одного регистра вдругой. они похожи на атомы
тоесть если рассматривать вещь на уровне атомов то там супер примитивная хрень происходит.
так вот из атомов уже делаются молекулы и более крупные хрени в природе. вот так и в программе. на уровне кодов происходит все время некая мелкая хрень - чтения запист из памяти
и сложения умножение этих чисел и все. но из мелкой хрени образуется уже крупные структуры
такие как например функции, типы данных, логический вид файловой структуры. и вот примернр
на этом уровне это все уже расписывает POSIX. я бы сказал что posix это как layer 3 к примеру
по аналогии с OSI. вот к чему это и зачем. некий опрееднный стандарт который описывает связь 
между уровнем что ниже  его и уровнем что выше его (хрен знает что это за уровни покачто). 

как бутто это вот так выглядит: 
машинные коды это L2 - тоесть это уже не электрические сигналы а поток логических нулей
и единиц.
ассемблер это L3 - абстрагирует нас от нулей и единиц в сторону команд в текстовом редакторе
C это L4 - абстрагирует нас от асемблера в сторону функций и примитивов более высокого порядка
POSIX это L5 - описывает связь между функциями и прочиими сущностями C и сущностями более высокого порядка абстракции.

тоесть да мы берем сущности из языка C и на основе POSIX лепим из них сущности более
высокого порядка абстракции.


ABI получается это некое доп требования к уровню L3 (асемблер) чтобы сущности из мира
POSIX (L5) реализовыавть в командах асемблера только так а неиначе. (номер сисколла передавать через регистр RAX например). а как же L4? как его проскакиваем...получаетс что L4 
это слой позволяющий превращать сущности уровня абстракции L5(posix сущности) в уровень L3(асемблер) но при этом асемблер код должен удовляетоврять ABI. abi описывает если мы берем сущность из L5 и превращаем ее в сущность L3 то какие детали свойств она должна иметь.
получается L4 ( язок программирования) должен давать возможность или всегда делать тоже как
сказало abi.  у нас конечный продукт это L3 с точки зрения abi , можно создавать L5 сущности
инструментами уровня L3 (помня что они должны соотвестоват требованиям abi) а можно это делать чуть проще делая сущности L5 через инстурменты уровня l4 которые сами уже умеют
превращать L4 в L3 и чтобы они соотвествовали abi L3.

пока как то так. надо читать этот посикс. что он там требует и abi что он там требует.

пока все про эту долбежную тему.

========
.h
header files

у нас в /usr/include есть файл /usr/include/stdio.h

мы в коде нашей програмы пишем

#include<stdio.h>

значок <> говоорит препроцессору 


========
AT&T 
as
gas

если у нас программа в AT&T синтаксисе то его nasm непонимает.

$ cat 36.asm
.data
msg:
    .ascii "Hello World!\n"
    len = . - msg

.text
.globl _start
_start:
;    pushl  %ebp
;    movl   %esp, %ebp

    movl   $0, %ebx
    movl   $1, %eax
# Setting the stack for the systenter
    pushl  $_start
    pushl  %ecx
    pushl  %edx
    pushl  %ebp
;    movl   %esp,%ebp
    sysenter



и его можно откомплировать тогда через as

для 32битного кода это выглядит так



$ as 36.asm -o 36.o --32
$ ld  -m elf_i386   -o 36.exe 36.o

=====================
что такое и зачем stack alignment? и связанный  с ним вопрос - а что такое assmbly function? как это с abi связано?

$ cat 27.asm
; 27.asm
section .text
    global _start
_start:
BITS 64
    mov       rax,0xff11ff11ff11ff11
    push      rax
    pop       rax
    push      0x7a
    pop       rax
    push      0x8a
    pop       rax


; call exit(0)
    mov    rax, 0x3c
    mov    rdi, 0x0
    syscall


компилируем
$ nasm -f elf64 27.asm
$ ld -s -o 27.exe 27.o

а вот пример как откомпилировать с debug символами (чтобы потом в gdb смотреть)
$ nasm -g -f elf64 -l hello.lst -o hello.o hello.asm
$ ld -o hello.exe hello.o

а вот еще как откомпилировать с debug символами в 32bit файл
$ nasm -g -f elf32 -l 32.lst -o 32.o 32.asm
$ ld  -m elf_i386   -o 32.exe 32.o



заходим в gdb

=> 0x0000000000400080 <+0>: movabs rax,0xff11ff11ff11ff11
   0x000000000040008a <+10>:    push   rax
   0x000000000040008b <+11>:    pop    rax
   0x000000000040008c <+12>:    push   0x7a
   0x000000000040008e <+14>:    pop    rax
   0x000000000040008f <+15>:    push   0x8a
   0x0000000000400094 <+20>:    pop    rax
   0x0000000000400095 <+21>:    mov    eax,0x3c
   0x000000000040009a <+26>:    mov    edi,0x0
   0x000000000040009f <+31>:    syscall 

первое . проверим а вот сам текст с командами он тоже выровненный лежит в памяти или нет.
выровненный значит то что сущности (перменная или команда) размещаются в опертивке только
по адресам которые как минимум четные.вобще кода мы гооворим об выровненнности надо уточнять
по какому размеру выравниваем. если выравниваем по размеру 16бит (2 байта) то значит что 
сущности размещаются в памяти только по четным адресам получается оставляя дырки в памяти.
гнапример у нас первая переменная равна 1 байт. а вторая  2 байта. тогда в памяти они буудт помещены согласно правилу выровенности по двум байтам вот так:

0000 переменная-1
0001 пусто
0002 переменная-2
0003 переменная-2

видно что байт с адресом 0001(нечетный)  оставлен пустым. зачем так делается - например процессор
8086 или 8088 (точно непомню) имел ширину шины данных 2 байта плюс память так устроена что 
в ней данные читаются строками а неоотдельными байтами в итоге это приводит к тому что 
на том цпу за один такт можно было считать байты 0000 и 0001, либо 0002 и 0003. а вот если 
нам нам над было считать байты 0001 и 0002 то это занимало бы два такта. потому что вначале
цпу читает 0000 и 0001 отбрасывает ненужное осталяет 0001 и потом читает за второй такт
0002 и 0003 отбрасывает ненужное и осталвяет 0002. итак в этом виновата щирина шины данных на цпу
и то что из памяти на самом деле байты нельзя считать произвольные. можно только читать некоторой
кучкой. поэтому вся эта чехарда с размещением в памяти данных только по определенным адерсам
из за того чтобы потом когда кэтим данным обращаться чтобы небыло доступа за несколько тактов.
чтобы доступ был быстро за минимальное число тактов. вот ради чего все это.

так вот смоирим на gdb на то как текст программы размеене в памяти и проверяем выровнены ли 
они компилятором.

   0x0000000000400080 = 4194432 
   0x000000000040008a = 4194442
   0x000000000040008b = 4194443
   0x000000000040008c = 
   0x000000000040008e = 
   0x000000000040008f = 
   0x0000000000400094 = 
   0x0000000000400095 = 
   0x000000000040009a = 
   0x000000000040009f = 

таким образом видно что команды в памяти располагаются без выравнивания. окей поняли это.


регистр RIP = в нем рамзмещен адрес по которому лежит следующая команда. (в рамках тогоже сегмента).

для нашей программы внаале ее выполнения это выглядит:
rip =           0x400080

и смотрим по какому адресу лежит стек вначале выполенения программы:
rsp =           0x7fffffffdc60

вот как это посмотреть:
> info registers
rsp            0x7fffffffdc60   0x7fffffffdc60
rip            0x400080 0x400080 <_start>

далее выполняем команду из программы

push rax

смотрим как меняется адрес вершины стека:
было 0x7fffffffdc60  стало 0x7fffffffdc58.
разница = 8байт.
и это правильно потому что мы же пихаем в стек значение регистра rax который 64бита длинной.
все совпало.

далее замечаем что как положено вершина стека после того как в него чтото вложили
смещается наверх в сторону уменьшения адреса.

проверим адрес вершины стека выровнен ли относительно 64бит(8байт)
$ echo "obase=10;ibase=16;7FFFFFFFDC60" | bc
140737488346208

$ echo "obase=10;ibase=10;140737488346208/8" | bc
17592186043276

адрес поделился на 8 нацело. значит адрес вершины стека выровнен относиельно 8 байт.
значит чтение и запись в стек будет идти по времени на минимальном числе цпу тактов.
я так понимаю полагается что ширина шины данных у 64битного процессора тоже 64бит.

итак получается что величина на котору сдвигается вершина стека при операциях с ним
должна двигаться ровно на то число байт сколько по размеру регистры в цпу.
тоесть: 

mod|предыдущее значение вершины стека - текущее значение вершины стека| = mod | размер регистра цпу|

почему mod потому что мы можем как соватьв стек таки ивытаскивать с него. поэтому знак неизвестен.

тоесть мы щас обсудили дельтту сдвига вершины стека.
а вот сам адрес должен быть выровнен ... относииельно чего? причем мало выровнять изначально.
ведь кажый положенный регистр в стек может поломать выровненность...

положим размер регистра 8 байт а ширина шины 16 байт.
положим стек набит и вершина стека лежит по адреу 0.
rsp=0

вытаскиваем первый элемент из стека( байты 0-7). 
0
1
2
3
4
5
6
7

вершина сдвигается в 
rsp=8 байт.

чтобы счиатать по шине 0-7 байт мы сделаем это за 1 такт цпу (условно ) потомучто
цпу считает за раз 16 байт (0-15). все окей.

далее вытаскиваем еще один элемент из стека. (байты7-15). они тоже будут считаны за 1 такт.
потому что цпу считает 

????????????????????????????????????


| trigraphs
| триграф

также я тут рассмотрю такую хрень как триграф. об этом есть в вики.
как я понял в ASCII есть 
символы кооторых нет в iso646(хрен знает о чем это)
поэтому чтобы можно было в C использовать эти символы их кодировку заменили через
оставшиеся символы. по факту эта херь более неактуальна но тем не менее

??=	#
??/	\
??'	^
??(	[
??)	]
??!	|
??<	{
??>	}
??-	~


тесть компиляотор C понимает что '??=' это на самом деле '#'


$ cat 115.c 
#include <stdio.h>
#include <stdlib.h>



int main(void)
{

/*  trigraphs */
printf ("триграф1 = ??= \n");

exit (0);

}


комплиировать нужно с доп ключом
    $ gcc -trigraphs -o 115.exe 115.c  
    $ ./115.exe 
    триграф1 = # 




    

| char
| signed char
| unsigned char
| printf

у  C есть разные типы данных. типы переменных.
они имеют разную длинну в байтах. типы переменных  отличаются на бекенде по тому сколко
байтов памяти они занимают. второй момент что байт это всего нвсего набор битов.  а нам нужны
скажем не байты а числа. поэтому надо интепретировать эти биты в числа,
как это присходит хер знает, но надо четко понимать что в памяти 
где по факту в конечном итоге хранятся переменные  там нет никаких чисел. 
там есть просто нули и единицы битов. и все.
второй момент касающийся интепретации это то что одни переменные подразумевают
числа со знаком а вторые без знака. еще раз подчеркну байты в любом случае хранятся
как байты. там нет ни чисел ни знаков. это уже вопрос интепретаиции цпу когда он 
вытаскивает эти биты и как то там их распознает как числа. как то так.

окей. мы обявили тип переменной. мы ее инициализировали. вылезает
следущая проблема.
так вот вторая проблема это то как эти разные типы переменных напечать на экране 
через printf чтобы мы узнали значение этой переменной . потому что надо взять байты из памяти 
и по какомуто закону их трансформиррвать в дургие
байты которые соотвествуют таблице ASCII и послать их на терминал. 
а терминал преобразует эти байты на основе аски уже в печатные глифы.
мы неможем брать байты из памяти и напряую их пихать 
на терминал. потому что условно говоря в памяти число 1 в виде однобайтовой хрени
хранится в в виде 0x01 а на терминале чтобы мы увидел глиф 1 это надо в терминал сунуть 
байт в виде 0x31
потом момент о том что у нас число может состоять из некольких байтов. и тоже будет хуйня. например
число 767 в памяти может хранится в виде двух байтов 255(dec) и 512(dec)
кстати напомню что на цпу интел если число много байтовое то первым сохраняется
младший байт (little endian закон)
если мы байты из памяти  будем напрямую пихать на терминал то мы не получим на экране глифы 767 
мы получим на экране хрень.

итак я преехожу к освящению вопроса типов переменных в C и то как их 
напечатать на экране

первый тип данных это CHAR
CHAR в C это тип данных длинной 1 байт. возникает вопрос какой длинны байт на нашей системе?
ответ можно найти в 
    $ man limits.h
но этого мана по дефолту нет. его нужно птсавить в пакете
    $ sudo apt-get install manpages-posix-dev
    
    и там я читаю 
    {CHAR_BIT}
             Number of bits in a type char.
             Value: 8

итак байт у меня это 8 бит
итак на моей убунту CHAR эти тип длиной 1 байт который длинной 8 бит
также прикол в том что в самом limits.h нет ничего даже и близко подобного
только в его мане

CHAR 
может бытть трех видов. 
    просто CHAR
    signed char
    unsigned char
    
в любом случае все три вида относятся к более крупному типу Integer,
то что они относятся к integer видно означает что 
в конечном итоге те байты котоыре хрантся в этих переменных
они интепретиуруются языком C как числа, а точнее как целые числа ( кстати это еще вопрос 
кем интпретиууются). наверное я бы так сказал елси переенная имеет тип ingeger наверное
это значчит что язык C с этими переменным поддерживает арифметические операции с целыми 
числами . наверное отслюда ноги растут.

я думаю тут еще вот в чем дело. в любом случае любые данные это байты. 
но если мы указали тип то с данным байтом C будет на цпу запускать команды 
для целочисленной арифметики или скажем дробной арифметики. один и тот же байт 
может быть обработан на компе и как целое число и как дробное. все зависит от того 
как мы сами для себя интерпетиурем этот байт.  я лдумаю это касается
и многобайтовых данныъ\переменных


в любом случае каждый из этих трех типов CHAR занимает 
в памяти 1 байт. 
я кстати считаю что название char оно плохо и ебанутое. оно только путает.
надо было назвть тип как однобайтовый. это точно передает его.

итак это три разные типа. 
когда мы говорим про тип переменной тут есть неколлко моментов
когда это важно на практике. первый момент.
вот мы написал на C прогрмму. в виде текста. например обявляем
перменную и присваиваем ей значнеие

unsigned char var1 = 127;


так вот компилятору нужно транформировать этот ascii текст в реальный байт в 
памяти. и вот в зависимости от типа переменной у нас байт в памяти будет положен
совершенно разный.
вот два примера

unsigned char var1 = 1;
char var1 = '1';

в первом случае в памятт будет лежать байт вида 0x1
а во втором случае будет лежть байт вида 0x31
и это совершенно разные байты.

следудщий важнй момент что каждый тип переменных имеет диапзон допустмых значений.
и если мы попрбуем присвоить нетому типу нето значение то компиятор поршлет нахуй


char var1 = '12';

это выдаст ошибку потому что справа у нас стоит двух байтовое выражение а слева
у нас обьявляется однобайтовая перменная

а теперь я расскажу что это за три типа пермеенных
когда мы задаем CHAR то это говорит компиляитору что переменая будет 1 байт длинной
и инициализируется эта переменная   вот так

char a = 'w'

когда компилятяор видит такую строку то он берет символ  'w' находит для него 
байт в таблилце ASCII и именно этот байт и пихает  в память. он не пихает никакой 'w'
в память. он пихает байт.
есть и другой способ задать этот тип

char a = 0x31;

тогда компилятор берет и прям этот байт 0x31 пихает в память. он не пихает ascii коды 
четрых символов '0' 'x' '3' '1' нет. он имено пихает один байт 0x31

важно понять по поводу операций которые можно делать с char. насколок я понимаю 
хотя этот тип относится к integer но вроде как он не дожен поддерживать арифеметические
операции потому что для C смысл этой перменной это именно сам байт. без какой бы то ни было
его математической интпретации. а раз нет мат интепретации то и мат операций нет поддерживатся.

тоесть CHAR это такой тип переменной что он просто позволет засунуть байт в память. 
и этот байт воспиинимается 
языком C как просто байт. без какйото бы ни было инетпретации его  в числа.
этот байт можно задать 
на стадии ицинициализации либо в виде прям байта. либо в виде символа для которого
компилятор найдет по таблице ascii  соотуветстующий байт. 

    char a='w';
    char a=0x08;


теперь истоический вопрос а как напечатать на экране содержимое переменной. 
это тонкий вопрос потому что печать происходит так 
наш процесс шлет байты на терминал он интепретирует эти байты
и на экране рисует глифы. тоесть терминал принимает  байт.
потом он этому байту находит по таблце ASCII  глиф и рисует на экране этот глиф. 

поэтому для данного типа переменной можно как поступить. можно просто брать этот байт 
из памяти и слать на терминал. он нам будет по таблице аски переделывать этот байт в граф
символ. и мы видя символ можем по таблице обратно преобразовать и понять какой байт
хранисят в перменной в памяти. пример

    char a = 0x34;  // инициализирум перемпнную
    printf  ("%c \n", a);  // печатаем на терминале
на экране терминала получим
    4
cмотрим в аски таблицу и видим что глифу "4" соотвтует 0x34 байт.
таким обрзом надо четко понимать что в памяти не лежит цифра 4. там лежит байт 0x34
а 4 это интерпетация терминала если в него всунуть байт 0x34

теперь поговорим про принтф. про его синтаксис.
во первых принтф имеет вид
    printf ("....", arg1, arg2, arg3);
все что внутри кавычек называется поле формата.
в поле формат прописвается что надо напечатать на stdout,
далее идут аргументы через запятую.
внутри поля формата встречаются штуки которые имеют вид %NN
в нашем данном случае это %c . 
штука %NN внутри кавычек в принтф называется  "conversion  specification"
когда код принтф его встречает то он понимает что сюда надо вставить аргумент.
тогда принтф берет аргумент преобразует его так как это предписывает поле %NN
и направляет на печать. важно отметить что почти всегда аргумент претерпревает
обработку\транформацию и только потом то что получиолось направляется на терминал

ксатти говоря принтф в  баш 
работает также. в баше в %NN подставялется аргумент , преобразуется 
и только потом направоляется на печать.
единсвтенное что в баше аргументы они не имеют типа. я имею ввиду что 
в баше когда мы вставляем в аргумент переменную то переменые в баше неимеют
разных типов. точнее они там все одного типа string
а в C переменные имеют разные типы.
тоесть в баше принтф берет аргумент и конвертруе его в какйото другой вид данных,
и в С также. 
так вот еще раз хрень %NN назвывается в C как conversion specification.
и она имеет тоже свой формат. весьма непростой. вот он (его можно найти в man 3 printf):

conversion  specification  начинается с  % и заканчивается на conversion specifier
между % и conversion specifier находится: 
    zero or more flags, 
    an optional minimum field width an optional precision, 
    an optional length modifier
    
итого conversion  specification =
    % +
    zero or more flags + 
    an optional minimum field +
    an optional precision + 
    an optional length modifier +
    conversion specifier
    
где    
флаги это:
    #
    0
    -
    space
    +
    '
    
field width это:
    число
    
optional precision это:
    точка+число
    
length modifier это:
    hh
    h
    l
    ll
    q
    L
    j
    z
    Z
    t
    

conversion modifier:
    i = signed int , длинна типа в памяти 2 байта
    u = unsigned int , длинна типа в памяти 2 байта
    e
    f
    g
    a
    c
    s
    C
    S
    p
    n
    m
    %

значит все полня являются необязательными кроме первго и поеследнего тоесть
в миимальном виде 
    conversion  specification = %conversion  specier
   
что такое флаги, field width, precision я пока опущу.
я остановлюсь подробнее на length modifier и conversion modifier.

как я понял conversion modifier задает тот тип данных в который нужно конвертирвать 
аргумент. меня пока что будет интересовать только три типа данных i, u, c.
"i" обозначает signed integer. этот тип данных занимает 2 байта
и "u" он обозначает unsiged integer и занимает тоже два байта в памяти.
"c" обозначает char тип данных.

тоесть 
        printf  ("%i \n", a);
говорит принтф что нужно считать байты которые хранятся в a
преобразовать этот байт в десятичное число  signed integer тоесть в целое число со знаком,
потом для каждой цифры и знака найти в таблице ascii свой байт и послать все эти байты
на терминал. итак заметим что у нас берется байт или байты из памяти они преобразуются 
в десятичное число,  а потом это число преобразуется в другие байты и они шлются на 
терминал
        printf  ("%u \n", a);
говорит принтф что нужно считать байты которые хранятся в a
преобразовать их десятичное число unsigned integer тоесть в число которое целое со знаком плюс
потом для каждой цифры и знака найти в таблице ascii свой байт и послать все эти байты
на терминал
        printf  ("%c \n", a);
говорит принтф что нужно считать байты которые хранятся в a
эти байты ни во что не преобразовыывать а сразу направить на терминал

таким образом один и тот же байт в зависиомсти от указанного conversion specification
может быть сконвертирован в разные вещи и на терминале мы получим совершенно 
разные глифы. все зависит от того какой conversion specifiacation мы указали
        
кстати в баш синтаксис другой
    printf "%c \n"  "$a"
    
а вот пример из баша
где мы видим тоже самое. входной аргумент
один и тот же а на терминале напечатано разное 
в зависимости от %NN
    $ a="10"; printf "%s \n"  "$a";
    10 
    $ a="10"; printf "%x \n"  "$a";
    a 

тоесть перенная у нас неменяется. но за счет разных модификаторов %NN у нас принтф
транфсормирует содержимое перменной в разные штуки. 

возвращаемся в С. если мы хотим чтобы аргумент (а аргументом может быть переменная)
был интепретиррован как  char нужно использвать модификатор %c

прикол в том что char поддержтвет 
байты в диапазоне 0x00-0xff но таблица ascii она имеет последний символ только для байта 0x7f
поэтому что будет отображать терминал когда на него шлется байт больше чем 0x7f это вопрос
щас покажу

    char a = 0x9f;
    printf  ("%c\n", a);

на экране
    $ gcc -o 118.exe 118.c
    ]$ ./118.exe
    �
    $ ./118.exe | od -t x1
    0000000 9f 0a
    
тоесть видно что в терминал реаьно прилетело 0х9f
а дальше он был отображен на экране  в виде символа хрени.

посмотрю ка я через баш какие символы на экране рисует терминал. для байтов 0x00-0xff

$ for i in $(seq 1 255); do echo "obase=16;" "$i" | bc | tr A-Z a-z | sed 's/^/\\x/' | xargs -L1 -n1 -I% echo -e "i=$i,"   '\%' ; done
i=1, 
i=2, 
i=3, 
i=4, 
i=5, 
i=6, 
i=7, 
i=8, 
i=9, 	
i=10, 

i=11, 

i=12, 

i=13, 
i=14, 
i=15, 
i=16, 
i=17, 
i=18, 
i=19, 
i=20, 
i=21, 
i=22, 
i=23, 
i=24, 
i=25, 
i=26, 
i=27, 
i=28, 
i=29, 
i=30, 
i=31, 
i=32,  
i=33, !
i=34, "
i=35, #
i=36, $
i=37, %
i=38, &
i=39, '
i=40, (
i=41, )
i=42, *
i=43, +
i=44, ,
i=45, -
i=46, .
i=47, /
i=48, 0
i=49, 1
i=50, 2
i=51, 3
i=52, 4
i=53, 5
i=54, 6
i=55, 7
i=56, 8
i=57, 9
i=58, :
i=59, ;
i=60, <
i=61, =
i=62, >
i=63, ?
i=64, @
i=65, A
i=66, B
i=67, C
i=68, D
i=69, E
i=70, F
i=71, G
i=72, H
i=73, I
i=74, J
i=75, K
i=76, L
i=77, M
i=78, N
i=79, O
i=80, P
i=81, Q
i=82, R
i=83, S
i=84, T
i=85, U
i=86, V
i=87, W
i=88, X
i=89, Y
i=90, Z
i=91, [
i=92, \
i=93, ]
i=94, ^
i=95, _
i=96, `
i=97, a
i=98, b
i=99, c
i=100, d
i=101, e
i=102, f
i=103, g
i=104, h
i=105, i
i=106, j
i=107, k
i=108, l
i=109, m
i=110, n
i=111, o
i=112, p
i=113, q
i=114, r
i=115, s
i=116, t
i=117, u
i=118, v
i=119, w
i=120, x
i=121, y
i=122, z
i=123, {
i=124, |
i=125, }
i=126, ~
i=127, 
i=128, �
i=129, �
i=130, �
i=131, �
i=132, �
i=133, �
i=134, �
i=135, �
i=136, �
i=137, �
i=138, �
i=139, �
i=140, �
i=141, �
i=142, �
i=143, �
i=144, �
i=145, �
i=146, �
i=147, �
i=148, �
i=149, �
i=150, �
i=151, �
i=152, �
i=153, �
i=154, �
i=155, �
i=156, �
i=157, �
i=158, �
i=159, �
i=160, �
i=161, �
i=162, �
i=163, �
i=164, �
i=165, �
i=166, �
i=167, �
i=168, �
i=169, �
i=170, �
i=171, �
i=172, �
i=173, �
i=174, �
i=175, �
i=176, �
i=177, �
i=178, �
i=179, �
i=180, �
i=181, �
i=182, �
i=183, �
i=184, �
i=185, �
i=186, �
i=187, �
i=188, �
i=189, �
i=190, �
i=191, �
i=192, �
i=193, �
i=194, �
i=195, �
i=196, �
i=197, �
i=198, �
i=199, �
i=200, �
i=201, �
i=202, �
i=203, �
i=204, �
i=205, �
i=206, �
i=207, �
i=208, �
i=209, �
i=210, �
i=211, �
i=212, �
i=213, �
i=214, �
i=215, �
i=216, �
i=217, �
i=218, �
i=219, �
i=220, �
i=221, �
i=222, �
i=223, �
i=224, �
i=225, �
i=226, �
i=227, �
i=228, �
i=229, �
i=230, �
i=231, �
i=232, �
i=233, �
i=234, �
i=235, �
i=236, �
i=237, �
i=238, �
i=239, �
i=240, �
i=241, �
i=242, �
i=243, �
i=244, �
i=245, �
i=246, �
i=247, �
i=248, �
i=249, �
i=250, �
i=251, �
i=252, �
i=253, �
i=254, �
i=255, �


так вот видно что после байта 127(dec) который экваилваент 0x7f  у нас 
вместо символов одна хрень это кончно соовтеатует аски таблице но терминалеже работает
в режиме utf-8 и согласно utf-8 для этих байтов тоже вооще то есть символы.

ну ладно.

вобщеи тип char удобен тем что его в программе C можн завать не вивде байтов
а сразу в виде символов ascii. а коплиилятор уже сам преоблразует  в байты. 
таким макаром можно через char хранить какито преддоожения текста например

char a = 'v';
char b = 'a';
char c = 's';
char d = 'y';
char e = 'a';

printf  ("%c%c%c%c%c\n", a, b, c, d, e);

на экране
vasya

тость char уодбен тем что мы в прогармму вбиваем символы, комплиятор их сам преобзует в
байты. потом они шлются на терминал и там терминал их рисует как теже самые символы.
хотя по факт в памяти нет никаких символов. там чисто байты сидят.

проблем char в том что в переменной может сидеть только 1 байт. так как char 
ограничыает длинну перееной в 1 байт.
поэтому преждение в ней не сохранить.


следущий тип это 
тип unsighned char.
это тоже 1 байт. тольлко его С инпретпретиует как целое положительное число [0;255]
задаем переменную с этим типом вот  так

unsigned char a = 12;

кодга компиятор такое видит то он преобразует 12 в байт 0x0c
можно инициализировать переменную не виде числа а сразу в виде байта 
например в hex виде  

unsigned char a = 0x0c;
он тогда засунет в память как 0x0c

теперь вознкает вопрос как помотреть такую переменную на терминале.
конечно через принтф. и тут еще раз хочу подчеркнуть тонкую вещь. 
переменная в памяти хранится в форме байта.  или байтов. 
сами по себе байты это не числа и не символы. принтф когда эти байты прочитает
ему нужно их както проинтепретировать , например можно никак не проинтепретировать 
а просто послать на терминал. терминал же всегда работает одинаково. он для каждого
поступившего байта ищет по таблице аски глиф. и печатает этот глиф на экране.
это нам подходит если у нас тип данных char. но это нам не подходит
для других типов данных. поэтому нам нужен conversion specification
который обьяснит принтф что байты нужно проинтепретирровать как unsigned char
тоесть как десятичное целое число со знаком плюс длинной 1 байт.   а потом для каждой 
цифры этого числа найти аски байт. и толлько потом полученные байты направить
в терминал.
так вот таким conversion specification является %hhu
где "hh" это length modifier а "u" это conversion specifier.
u говорит принтф чтобы прочитанные байты из аргумента рассматривать как
unsigned int (длинна которого 2 байта). а hh уточняет что на самом деле нужно рассмотреть 
подкласс этого множества а именно unsigned char длинной 1 байт. 
я неочень понимаю нахуя принтф нагордил такие сложности неужели нельзя было 
вместо %hhu придумат чтото типа %k и все. зачем было вводить подклассы?
таким образом hh=length modifier, он никогда не исполщуется самостоятельно
а только вместе с "u" или "i" которые являются conversion specifier и обозначает
что мы хотим подкласс от "u" или "i" длинной 1 байт. тоесть это либо unsigned char
либо signed char, тоесть зацени разницу

    printf ("%u \n", a);
говорит принтф прочитай из аргумента (переменная a) байты из памяти 
и интепретируй их как unsigned int (длинна 2 байта)

    printf ("%hhu \n", a);
говорит принтф прочитай из аргумента (переменная a) байты из памяти 
и интепретируй их как однобайтовый подкласс от двухбайтового класса unsigned int 
который ничто иное как unsigned char


    printf ("%i \n", a);
говорит принтф прочитай из аргумента (переменная a) байты из памяти 
и интепретируй их как signed int (длинна 2 байта)

    printf ("%hhi \n", a);
говорит принтф прочитай из аргумента (переменная a) байты из памяти 
и интепретируй их как однобайтовый подкласс от двухбайтового класса signed int 
который ничто иное как signed char


также важно уточнить - когда я писал интепретируй на самом деле оно означает преобразуй.
потому что conversion specifier  в переводе означает "конвертируй в ..."

и в связи  с этим здесь важно отметить что тип данныху аргумента может быть один
а мы просим принтф конвертировать его в другой тип данных. поэтому если мы хотим 
посмотреть содержимое переменной а не сконверттированную во чтото другое величину
то нужно в conversion specifier указвать такой же тип данных что и у аргумента.
концепция принтф непривычная скажем после echo "$a" в баше. потому что баше эхо 
укзаываем именно содержимое переменной. а принтф в общем случае показывает несодрежимое
переенной а сконвертиррованную в вдругую хрень. 
щас  я покажу на примерах случаи когда мы печатаем на экране
содержимое перменной а когда сконверттрованную хрень.

кстати я забыл сказать что unsogned char позволяет нам сохранять числа
в диапазоне [0;255]

пример. 
мы заводим переменную unsigned char
и через принтф конвертируем его в unsigned char то есть другими 
словами по факту конвертации нет и мы просто получааем содержимое 
переменной

unsigned char a11  = 34;
printf ("a11 = %hhu \n", a11 );


на терминале
a11 = 34


итак как это работает.
мы компилируем программу
$ gcc ...
компилятор видит что нужно создать unsogned char переменную равную 34.
но 34 в память не засунешь. он вычисляет для нее байт 0x22
и кладет его в память. 
далее идет принтф и он говоорит возьми байт из a11 который равен 0x22
и сконвертируй его в unsigmed char число. он получает 34 далее для каждой цифры
найди в аски таблице байт. получается байты 0x33 и 0x34 и пихай их на терминал
терминал получает на вход байты 0х33 и 0х34 и ищет какие симыол в аски соотвевтуют
этим байтам. получаем "3" и "4" и он печаатет эти глифы на экране.
таким макаром применим верный %hhu мы смогли на экране получить содержимое переменной
таким образом вэтом примере у нас принтф по факту преобразовал данные к типу которым
обладал сам аргумент. тоесть преобразваония по факту и не было. а вот 
другой пример


unsigned char a11  = 34;
printf ("a11 = %u \n", a11 );

у нас аргумент имеет тип unsigned char (1 байт)
а принтф мы просим преобразовать аргумент в тип unsigned int

на терминале получим
a11 = 34

почему же мы получили число 34.  ведь мы же преобразовали один тип в другой
тип.  а потому что unsigmed char это субкласс от unsigned int поэтому 
1 байтовое выражение просто было дополнеено до двухбайтового. тоесть было
0x22 а  стало 0x22 0x00 ( litle endian  младший байт первый)
но по факту если мы эти байты переводим в число то число осталось тоже самое!

а вот другой пример когда у нас число хранится в более широком
двухбайтовом классе а мы его конвертируем в более узкий однобайтовый класс


unsigned int  a12  = 257;
printf ("a12 = %hhu \n", a12 );


на терминале
a12 = 1

дело вот в чем. число 257 имеет двух байтовый вид 1(dec) и 255(dec)  ( по правилу 
little endian младщий байт хранится первым)  соовственно принтф считывает из памяти
два байта 1(dec) и 255(dec) далее мы просим принтф сконвертировать двух байтовое число в
одно байтовое. это невомзожно. поэтому принтф берет первый байт этого числа 1(dec)
и далее трактует его как unsigned char получаем число 1 далее находит для него байт
в таблице аски и пихает на термиал. терминал преобразует байт в глиф и мы видим на экране
символ "1"

этим примером я хотел показать что conversion specification %NN в целом независит от 
типа аргумента и занимается тем что преобразует тип данных из аргумента в тот тип данных
который мы укажем. и выводит то что вышло на экран. если мы хотим чтобы на экране
мы увидели не хрень а именно то что хранится в переменной то нам надо в %NN указать
тот тип данных которым обладает аргумент или более широкий тип данных. чтобы у нас байты
не обрезались.

еще пример
char a13 = 'r';
printf ("a13 = %c \n", a13 );
printf ("a13 = %hhu \n", a13 );


на терминале
a13 = r 
a13 = 114 

этот пример показывает то что используя одну и туже переменную 
мы через принтф на экране увидим разные вещи в зависимости от того
в какой тип данных мы конвертируем байты переменной в принтф


еще пример

unsigned char f = 12;
unsigned char g = 0x0a;

printf ("f=%hhu \n", f);
printf ("g=%hhu \n", g);


на экране
f=12 
g=10


    
видно наскольлко огоромная разница между реальным содеримым переменной и того что 
посылается на терминал. заметим что кода мы печатали через принтф переенную типа char 
то никакго преобразование не было ровно то что сидело в памяти то и посылалсь на терминал.

также я непроверял но насколько я пнимаю unsigned char поддержвает арифестические операции.



следущий тип signed char
размером 1 байт. 
но С инерпттрует этот байт как числа в диапазоне [-128;0;+127]
если ноль считать положитеельным то таким макаром унас 128 отрчиетльных чисел и 128 
положиетльных

байт остается байтом меняется его интерпреттация программой на C.
задатьтакую переменную можно вот так

signed char a = -10;

или в форме сразу байта

signed char = 0xfa;

псмотреть занчение перенной можно через %hhi

printf ("%hhi", a);

прмиер
signed char h = -10;
signed char i = 0xfa;
printf ("h=%hhi \n", h);
printf ("i=%hhi \n", i);


на экране
h=-10 
i=-6 


а вот еще пример
когда одна и таже перменная конвертрууется через принтф в разные 
типы и поэтому на экране совсем разный результат


char  a14  = 0xf9;
printf ("a14 = %c \n", a14 );
printf ("a14 = %hhu \n", a14 );
printf ("a14 = %hhi \n", a14 );




на терминале
a14 = � 
a14 = 249 
a14 = -7 


итак еще раз. переменная одна и таже. но принтф нам выдает совсем разные вещи.
потому что мы конвериритум байты в разные типы данных. 
также замечу что когда мы в принтф юзаем %c то он ничего не конверттруем он просто
байты сидящие в аргументе шлет на терминал. значит на темринал было отправлен байт 0xf9
а терминал ненашел для этого байта в аски глифа поэтому напечатал мусор. 
я это говорю к тому что если у нас тип данных char это незначит что для этого типа
данных всегда есть символ в аски на термиале. и это логично ибо как я уже сказал
байт имеет диапазон 0x00-0xff а таблица аски имеет диапазон 0x00-0x7f


кстати далеко не всегда принтф может сконвертирровать аргумент в заказаный
тип 
пример

size_t          a5 = 0xfa;
printf ("a5=%hhi   \n", a5);

пробую комплирвать
    $ gcc -o 118.exe 118.c
    118.c: In function ‘main’:
    118.c:46:16: warning: format ‘%hhi’ expects argument of type ‘int’, 
    but argument 2 has type ‘size_t {aka long unsigned int}’ [-Wformat=]
    printf ("a5=%hhi   \n", a5);
             ~~~^


кстати на счет того какая длинна в байтах для char , его подвидов
и int я прочел в вики - (ttps://en.wikipedia.org/wiki/C_data_types)
 
еще 
 пример

char          a1 = 0xfa;
unsigned char a2 = 0xfa;
signed   char a3 = 0xfa;
printf ("a1=%c   \n", a1);
printf ("a2=%u \n", a2);
printf ("a3=%i \n", a3);

на экране
a4=-6 
a1=�   
a2=250 
a3=-6 






а теперь я хотел рассмотреть интересные типы переменых это 
    off_t
    size_t
    ssize_t
    
    
дело в том что до этого я смотрел типы данных у которых был размер байтов
которые жрет переменная фиксированный. это неудобно стало когда нппример цпу стали 
от 32 битных до 64 битных. нужен такой тип переменных который бы зависел от этого.
чтобы мы указали этот тип а уже компилятор в  зависисомсти от архитектуры цпу
менял прогу. тоесть это вот такие "динамические" типы данных. тоесть их длинна меняется
от цпу к цпу. 

значит начнем с off_t
про него есть в манах информация. но не в убунту18 а в убунту22 начиная тольлко.
опять же для этогонужно поставить пакет

    $ sudo apt-get install manpages-dev
    
и тогда man off_t
выдаст вот что
чтобы использовать его в своей проге надо 
    #include <sys/types.h>
и там написано что 
    off_t is used for describing file sizes.  It is a signed integer type.
тоесть эта хрень позволяет использовать его для переменных которые должны играть 
роль оффсета в файлах. и намнадо иметь настколько большое число чтобы его хватило на самый
большой файл. и еще оно должно иметь знак. потому что оффсет задается от какойто точки
и влево либо вправо от нее.
найду ка я какой размер у нее в моем компе через оператор sizeof (что такое оператор С
надо читать отдельно).


    off_t  a15;
    printf ("a15 sizeof = %lu \n", sizeof(a15) );


на терминале
    a15 sizeof = 8
    
итак длина 8 байтов тоесть 64 бита.
а сколкоже это терабайт? тут надо понмить что один бит в этой хрени используется 
для хранения знака. поэтому считай что у нас 63бита под оффсет. это значит что макс
размер файла будет 

    $ bc <<< "(2^64)/1024/1024/1024/1024"
    16777216

овердохрена

теперь задача распечататаь переменную этго типа через принтф. 
нужно выяснить какой conversion specification у него надо выбрать

оказывается у принтф нет прямого conversion specification для печати
этого типа, но можно сконвертировать этот этот тип в другой более широкий таким 
макаром сохранив число неизменным. заметим что off_t это signed integer.
значит надо взять самый большой signed integer класс. как я понял таковым является
класс intmax_t. читаю про него в man intmax_t 

intmax_t  is  a  signed integer type capable of representing any value of any basic signed
       integer type supported by the implementation.  It is capable  of  storing  values  in  the
       range [INTMAX_MIN, INTMAX_MAX].
    

так вот для intmax_t есть прямой conversation specification = %ji
тоесть "i" означает двухбайтовый signed int а  "j" расширяет его до intmax_t
проверяем

off_t  a15=-44674407370955161 ;
printf ("a15 sizeof = %li \n", sizeof(a15) );
printf ("a15  = %ji \n", a15 );


на терминале
a15  = -44674407370955161    
работает

попробуем еще какойнибудь мелкий класс который относится к signed int
посмотреть через %ji

пример

signed char  a16 = -15;
printf ("a16  = %ji \n", a16 );


на терминале
получаем однако ошибку при попытке компиляции

$ gcc -o 118.exe 118.c
118.c: In function ‘main’:
118.c:106:19: warning: format ‘%ji’ expects argument of type ‘intmax_t’, but argument 2 has type ‘int’ [-Wformat=]
 printf ("a16  = %ji \n", a16 );

если честно я эту ошилку непонимаю. он пишет что аргумент ожидается имеет формат intmax_t,
я как бы непонял какая разница к какому типу относияст аргумент если я прошу принтф
преобразовать аргумент какой бы он ни был к intmax_t.. непонятно..

и тут я прихожу к предположению что по крайней мере иногда принтф неможет преобразовать
тип аргумента к типу который мы заказываем и это надо сделать руками.
значит нас эта ошибка просит чтобы мы руками преобоазовали signed char в intmax_t
для этого есть операция называется cast выглядит он так

    #include <inttypes.h>
    printf ("%ji \n", (intmax_t)a16 );
    
или в полном виде

    #include <inttypes.h>
    signed char  a16 = -15;
    printf ("%ji \n", (intmax_t)a16 );

тоесть (intmax_t)a16 преобразует char в intamax_t и у нас в принтф тип аргумента
и тип данных прописанный  в %NN становится одинаковый. и тогда у принтф нет проблем с его
напечаткой.

почему же в других случая когда у нас аргумент имел тип данных отличный от типа данных в %NN
у нас принфт неруугался? непонятно...

почему off_t ненужноруками преобразоывать в intmax_t ??

ладно. переходим к size_t
читаем в 
    $ man size_t

     size_t Used  for  a  count of bytes.  It is the result of the sizeof() operator.  It is an
              unsigned integer type capable of storing values in the range [0, SIZE_MAX].
 
хорошая новость состоит  в том что для этого типа у принтф есть готовый length modifier
это "z"  , и так как это unsigned integer значит его conversion specifier это "u"
значит в итоге надо юзать %zu;
провреяем

size_t a17  = 55000;
printf ("%zu \n", a17);


терминал
55000

сработало

я тольо не понял про физ смысл этого типа. "count of bytes" чего ??
а так получается это положительное целое число.

следущий тип это ssize_t
это тоже самое что предыдущая хрень только со знаком.
в принтф для него используется опять же "z" тоесть "%zi"
пример


ssize_t a18  = -55000;
printf ("%zi \n", a18);


теримнад
-55000

срабтало

в мане от ssize_t написано

   ssize_t
              Used for a count of bytes or an error indication.  It  is  a  signed  integer  type
              capable of storing values al least in the range [-1, SSIZE_MAX].


как видим он может хранить не только -1 среди отрицателных чисел

итак подвожу итог какой тип каким %NN можно посмотрерь

char:
    printf ("%c \n", a);
    

signed char:
    printf ("%hhi \n", a);
    
unsigned char:
    printf ("%hhu \n", a);


off_t:
    printf ("%ju \n", a);
либо 
    #include <inttypes.h>
    printf ("%ju \n", (intmax_t)a);
    
size_t:
    printf ("%zu \n", a);

ssize_t:
    printf ("%zi \n", a);


    
    
как я примерно понял posix это стандарт котоырй описывает API который ядро любой unix
совместимой операционной систем должен подчиняться глядя в user space.
какая то такая хуня
тоесть ядро внутри может быть ккое угодно на в юзер спейс смотреть одинаково для всех unix
подобных систем. както так


также отностельно типов данных в С    
нашел в вики (https://en.wikipedia.org/wiki/C_data_types)
1 байт это char
2 байт это int
4 байт это long
8 байт это long long

но это как я уже сказал типы данных у которых размер статический.
гораздо хитрее когда тип данных таков что его длинна завсиит от типа цпу.


далее я нашел портянку обьясняющую принфт развернуто
    https://www.pixelbeat.org/programming/gcc/format_specs.html


а именно

%[flags][min field width][precision][length]conversion specifier
  -----  ---------------  ---------  ------ -------------------
   \             #,*        .#, .*     /             \
    \                                 /               \
   #,0,-,+, ,',I                 hh,h,l,ll,j,z,L    c,d,u,x,X,e,f,g,s,p,%
   -------------                 ---------------    -----------------------
   # | Alternate,                 hh | char,           c | unsigned char,
   0 | zero pad,                   h | short,          d | signed int,
   - | left align,                 l | long,           u | unsigned int,
   + | explicit + - sign,         ll | long long,      x | unsigned hex int,
     | space for + sign,           j | [u]intmax_t,    X | unsigned HEX int,
   ' | locale thousands grouping,  z | size_t,         e | [-]d.ddde±dd double,
   I | Use locale's alt digits     t | ptrdiff_t,      E | [-]d.dddE±dd double,
                                   L | long double,  ---------=====
   if no precision   => 6 decimal places            /  f | [-]d.ddd double,
   if precision = 0  => 0 decimal places      _____/   g | e|f as appropriate,
   if precision = #  => # decimal places               G | E|F as appropriate,
   if flag = #       => always show decimal point      s | string,
                                             ..............------
                                            /          p | pointer,
   if precision      => max field width    /           % | %


частчино она неточная например она говорит что z это size_t
однако это брехня , z это еще и ssize_t

расмотрим тип string
пример

const char  *a19 = "vasya";
printf ("%s \n", a19);

либо

char  *a20 = "vasya";
printf ("%s \n", a20);


терминал
vasya
vasya


тоесть рабтает и так и так

const char насколько я пнимаю отличактся от char тем что const char это константа
и ее нельязя менять, зведзодчка означает что это поинтер. что это такое надо еще 
изучать

теперь когда с "lenght" и "conversion specifier"  в некотором роде
разобраись, то разеремся с другм полями.

но для начала я прыгну в сторону. я заметил в интернее вот такой трюк.
если мы хотим узнать макс значение для какого то типа то надо воспользоваться 
cast (кастом) и подставить такое число которого заведомо не может быть в этом типе.
например берем тип в котором нет отрицаиельных чисел и подставляем туда отрциательное
число
пример

printf ("%hhu \n", (unsigned char)(-1) );

тоесть мы говорим что мы хотим напечатать unsined char %hhu
а в аргументе ставим cast от -1
в итоге получаем 255

терминал
255

используя такой макар посмотрим какой макисум у off_t, size_t,  intmax_t

для off_t:
    printf ("%ju \n", (intmax_t)(off_t)(-1) );
на терминале
    18446744073709551615



для size_t:
    printf ("%zu \n", (size_t)(-1) );
на тмерминале
    18446744073709551615

    
    
для intmax_t:
    printf ("%ju \n", (intmax_t)(-1) );
терминал
    18446744073709551615
    

переходим  к разбору других полей
начнем с поля флаги.

флаг #

начну вот с чего в C есть типы данных типа как signed char или unsigned int.
а есть форма через которую мы записываем число в текстовой программе. 
например мы можем число записать в десятичном виде  255, можно в hex виде 0xff
а можем в octal виде  0377
так вот надо непутать типы данных ибо тип данных это число байтов которое в памяти отвоодиттся
на переменную и из него вытекает диапаззон котоыре переенная может прирнмиать.
а форма ввода данных через тектовую программу это в каком виде мы указываем значение
переенной в тестовй программе. кстати формат данных его можно использовать и при вводе данных
( при инициализации переменной) так и при выводе данных ( в принтф)
также нужно помнит что тип данных задается через length modifer+conversion specifier


показываю пример
тип данных unsigned long int ( 32 бита)
форма ввода данных dec, hex, oct
формат вывода данных dec, hex, oct


unsigned long a24 = 0666;
printf ( "oct view %lo \n",  a24 );
printf ( "dec view %lu \n",  a24 );
printf ( "hex view %lx \n",  a24 );


на теоминале
oct view 666 
dec view 438 
hex view 1b6 


тоесть я при инициализаииц задал число через oct вид,
а при печати преробразовал в oct,dec,hex 

получется %u это не только ознаачает unsigned int 2 байта это еще означает 
десятичный вид отображения. то есть %u задает нетолько тип данных но и вид ото
бражения!
ксаттаи получается что lenght modifier он реально всего навсего изменяет длинну байт
кторая задана в %u или %i тоесть  в conversion specifier. 
скажем %u задает 2 байта а %lu уже задает 4 байта.

так вот флаг # он как бэ помогает понять в каком формает у нас нарисован вывод

добаволяю кусок

printf ( "oct view %#lo \n",  a24 );
printf ( "hex view %#lx \n",  a24 );


на темрианлаеале
oct view 0666 
hex view 0x1b6 

тооесть для oct view флаг # добаляет 0
а для hex view флаг # добавляет 0x



следущий флаг это цифры которые задают по факту минимальную колонку по ширрне для результата
но если результат превысит ширину то конечно он будет напечаатан целиком на экране
вот пример. я задаю ширину колонки 2 символа. но так как резульатат больше символов
то по факту эта настрокаи нихрена не влияет

unsigned long a24 = 0666;

printf ( "oct view %02lo \n",  a24 );
printf ( "dec view %02lu \n",  a24 );
printf ( "hex view %02lx \n",  a24 );

на термианале
oct view 666 
dec view 438 
hex view 1b6 


а вот мы щас ставим 5 символов ширина колонки

unsigned long a24 = 0666;

printf ( "oct view|%10lo| \n",  a24 );
printf ( "dec view|%10lu| \n",  a24 );
printf ( "hex view|%10lx| \n",  a24 );

на термианале
oct view|       666| 
dec view|       438| 
hex view|       1b6| 


спраивается нахер нужны колонки? я уже это обслуждал. это нужно кода у нас
несколько значений которые удодбно разбть по колонкам и выравнивать не руками
но это удобно делать вкупе с еще одним флагом "-" он дает то что выравниерние 
идет по левому крвю колонки потому что по деолфту по правому


printf ( "oct view|%-10lo| 1\n",  a24 );
printf ( "dec view|%-10lu| 23\n",  a24 );
printf ( "hex view|%-10lx| 234\n",  a24 );


термианал
oct view|666       | 1
dec view|438       | 23
hex view|1b6       | 234


и вот  выходит еще один флаг на сцену '0' он работает только если мы указали минимальную
ширину колонки и также нельзя использовать флаг "-"  и тогда этот флаг работает
он дает то что все позиции слева которые в колонке будут забиты нулями.

пример

printf ( "oct view|%010lo| 1\n",  a24 );
printf ( "dec view|%010lu| 23\n",  a24 );
printf ( "hex view|%010lx| 234\n",  a24 );


терминал
oct view|0000000666| 1
dec view|0000000438| 23
hex view|00000001b6| 234

еще пример
в нем уже реально виден колонок
если задана колонка то следующий аргумент будет печататься строго после колонки 

printf ( "oct view|%010lo| %10s|\n",  a24, "1" );
printf ( "dec view|%010lu| %10s|\n",  a24, "23" );
printf ( "hex view|%010lx| %10s|\n",  a24, "234" );

термианал
oct view|0000000666|          1|
dec view|0000000438|         23|
hex view|00000001b6|        234|



еще прикол в том что флаг "0" нелья использовать с %s . будет ругаться
                                ^
118.c:172:32: warning: '0' flag used with ‘%s’ gnu_printf format [-Wformat=]
 printf ( "dec view|%010lu| %010s|\n",  a24, "23" );

 
далее прикол   в том что вывод в oct и hex форме работает ТОЛЬКО для unsigned чисел.
если применяем  signed чисел то понятное дело что мы получим неверную интепретацию 
байтов

пример

signed char a25 = -15;
printf ( "oct view|%10hho| %10s|\n",  a25, "1" );
printf ( "dec view|%10hhi| %10s|\n",  a25, "23" );
printf ( "hex view|%10hhx| %10s|\n",  a25, "234" );



темианал
oct view|       361|          1|
dec view|       -15|         23|
hex view|        f1|        234|

тесть %10hho = говорит что печаатй резулаьтат в колонке 10 символов.
конвертруй резултат в 1 байтовый unsigned число (unsigned char) и выводеи на 
экраане в октал виде. 
только %10hhi дает коректный рездутат потому что i это signed числа.и также 
i это вывод в десятичной форме.


следущий два флага " " и "+" работают только для signed чисел. тоесть сознаком.
для чисел unsigned эти два флага неработают.
флаг "пробел" дает то что если число положиетльное то перед ним печатается пробел
а флаг "плюс" дает то что если число положителное то перед ним в явном виде
печатается знак плюс
напомианаю что флаг "-" дает то что резултатт выравниевается по левому краю

пример

signed char a26 = 15;
printf ( "view|%-10hhi|\n",  a26 );
printf ( "view|%- 10hhi|\n",  a26 );
printf ( "view|%-+10hhi|\n",  a26 );


в верхне строке у нас просто печаатется резульатт без двух новых флагов
во второй строке мы длбавляем флаг пробле
в третьей строке мы добавляем флаг плюс

терминал
view|15        |
view| 15       |
view|+15       |


видно как отличается резудьтат
эти флаги нужны чтобы у нас крсиво шли цифры. щас покажу

signed char a27 = 15;
signed char a28 = -16;
signed char a29 = 0;

printf ( "view|%-+10hhi|\n",   a27 );
printf ( "view|%-+10hhi|\n",  a28 );
printf ( "view|%-+10hhi|\n",  a29 );


трмианал

view|+15       |
view|-16       |
view|+0        |

итак мы видим что у нас нет такого что из за минуса у нас числа невыврвонены.
все красиво

далее расмтрим следущий флаг "'"
он дает то что на основе настроек локали у нас тысячи в целых числах будут разделены
тем разделителем который указан в локали.
далее прикол в том что по деолфту когда мы запускае программу на C то (незнаю почему)
она запуксается не стой локалью которая укзаан в 
    $  locale
а запускется с локалью "С" а вней нет знака для разделения тысяч. поэтому 
по дефолту дбавлка этого флага нихрена не даст.
что нужно сделать. нужно ради интереса проверить под какой локалью стартует 
прогармма и поменять эту локаль на время выолпненения программы для этого

#include <locale.h>
#include <string.h>

char *old_locale, *saved_locale;

/* Get the name of the current locale.  */
old_locale = setlocale (LC_ALL, NULL);

/* Copy the name so it won't be clobbered by setlocale. */
saved_locale = strdup (old_locale);
printf ("default locale = %s \n", saved_locale);

setlocale(LC_NUMERIC,"ru_RU.UTF-8");



после этого уже можно добаволять наш кусок программы

signed int a27 = 15000;
signed int a28 = -16000;
signed int a29 = 3845;

printf ( "view|%'-+10i|\n",   a27 );
printf ( "view|%'-+10i|\n",  a28 );
printf ( "view|%'-+10i|\n",  a29 );


темрианал
default locale = C 
view|+15 000 |
view|-16 000 |
view|+3 845  |

из чего видно что мы заюзали флаг "'"
и видно что начальная локаль "C"
я ее сменил на "ru_RU.UTF-8"
и в итоге у нас тысячи разелены пробелом.

теперт я поменяю локаль на en_US

резултат

default locale = C 
view|+15,000   |
view|-16,000   |
view|+3,845    |


видно что тычсячи уже разделены запятой

поидее аналогом флага "'" является флаг "I"
но почемуто он нихера неработает

по  идее  я разобрал все флаги. и в общем и в целом я разобрал весь синтаксис
функции printf

следущий этап разобрать эти примеры

printf("%08X",32_bit_var);	0000ABCD
printf("%lu",32_bit_var);	43981
printf("%'d",32_bit_var);	43,981
printf("%10s","string");	    string
printf("%*s",10,"string");	    string
printf("%-10s","string");	string    
printf("%-10.10s","truncateiftoolong");	truncateif


первй пример
printf("%08X",32_bit_var);	0000ABCD

где
32_bit_var = 
здесь мы говорим что у нас аргумент это 32 битная штука. тоесть это long
то ли со знаком то ли без. 
X = и мы просим его конвертировать в hex и чтобы буквы 
были напечатаны большим букаваии поэтму флаг "X" . так как hex вид у нас коректно
работает только для unsigned числе то это значит что аргумент тоже имеет смысл
имееть unsigned.  
8 = мы говорим что минимальрная ширина колонки 8 символов. 
0 = по дефолту выранивание идет по правому краю поэтому мы говорим что 
если число менше чем 8 символов то надо остальные позциии забить нулями.
смотрим на пркакткие

unsigned long a30 = 0x3ab;
printf ( "view|%8lX|\n",  a30 );
printf ( "view|%08lX|\n",  a30 );

темрианал
view|     3AB|
view|000003AB|

я добавил в формат l потому что если юзать просто X то это поодразумевает что
арумент должен быть 2 байта. а  у нас указано что аргумент 4 байта. поэтому нужно не X а lX
юзать

второй пример
printf("%lu",32_bit_var);	43981

он берет аргумент и печаатает его в десятичном виде. и все


следудийи прмиер
printf("%'d",32_bit_var);	43,981

он печатает аргумент с разделитеелем между тысячами исполльщуя знак для этого
кторый прописан в локале. 
аналогичный пример я разобрал выше


следущий рпимпример
printf("%10s","string");	    string

мы печатаем стринг говорря что минимальная ширина колонки 10 симовлов
но если стринг будет боолше то стринг напечатается полностью без обрезки

следущий пример
printf("%*s",10,"string");	    string


зедсь как я понимаю ширину колонки заменили на знак * а число вынесли 
отделно. а так этот пример ровно такой же самый как и прошлый.
покажу на прмиере

printf ( "%*s \n", 10, "0123456789abc" );

темрианал
0123456789abc

в целом это приколтно что можно выносить параметры %NN наружу


следущий приер
printf("%-10s","string");	string    


он печаатет стринг в минимальной колонке 10 симвовлов. но если стринг длинннее
то его обрезать не будут. и он вырываниывается по левому краю так как по дефолту
вырвание идет по аравому краю



printf("%-10.10s","truncateiftoolong");	truncateif

это пример печатает стринг.  вырыванивая его по левому краю.
в колнке шириной 10 символов и он обрезает в этом стринге все символы которые 
дальше чем 10 символов.
прмиер

printf ( "%10.10s \n", "0123456789abc" );
printf ( "%*.10s \n", 10, "0123456789abc" );
printf ( "%*.*s \n", 10, 10, "0123456789abc" );


термианал
---- 
0123456789 
0123456789 
0123456789 


все три строчки имеют одианковый физ смысл
вынос параетров это прикол.




| pointer

итак поинтеры. 
вот так мы обьявляем простую переменную.

#include <stdio.h>

int main(void) {
    
    int i;
    i=1;

    return(0);
}



в чем прикол простой переменной. при обращении по имени мы попадаем в значение. тоесть как бы
имя переменной хранит значение.
поинтер пееременная при обращении по имени нам выдаст адрес в оперативке.  и если мы на втором шаге
по этому адресу пройдем то мы уже получим значение.

простая переменная обббяввляется как
    int i;
означает зарещервирууй ячейку в памяти к которйо можно обращатся под ярлыком "i"
эта ячейка будет иметь длинну int (не помню сколько это байт). в этой ячейке 
будет хранится значение.

поинтер обьявляется вот так
    int *iPtr;
и пеереводистя создай в памяти ячейку к которой можно будет обращаться по имени iPtr.
это будет не просто переменная. это будет переменная типа поинтер. и в ней будет хранится
номер адреса памяти. а есьи мы обратиимся уже по адресу этому то мы наткнемся на значение 
типа int.
  iPtr хранит адрес памяти. если обратиимся по которому то найдем число типа int
  
еще раз что значит эта хрень int *iPtr;
она значит что имя переменной iPtr
что это не просто переменная а переменная поинтер. на это указыавет звездочка *
переменная поинтер хранит незначение а адрес оперативной памяти. получается нам чтобы 
прочитать значение конечной переменной то нам надо из iPtr прочитать ее значение тоесть 
адрес. потом пройти по адресу прочитат что там лежит и только тогда наконец мы узнаем
значение переменной. так вот int означает что если мы пройдем по адресу то там лежит значение
которое укладывается в диапазон integer
итак

iptr ---> адрес -----> значение  в диапазоне integer

итак

int i;  # создаем переменную i значение которой лежит в диапазоне int
int *vasya # хранит адрес по которому если пройти то там лежит значение в диапазоне int

если переменная поинтер то в нее можно записать получается какойто адрес.
это можно сделать в том числе и руками. тоесть можно вписать адрес по которому еще ничего не 
лежит. для начала можно вписать 0 или NULL это считается одно и тоже почти. NULL более
предпочтителен. он означает "ничто" . null это макро который опрееделен в stddef.h
что такое макро хуй знает. я занглянул в вики и в этот stddef.h и нашел там два 
определения что NULL это  0  или  ((void *)0)
хуй знает что это значит. пока буду считать что NULL это 0.

так вот когда мы гооворим про поинтеры то есть полезный оператор &. он делает вот что .
если его натравить на обычную переменую то он возвращает адрес по кторому она хранится.
           int i;
           i=1;
           &i

наскоклько я понял из практики адрес который будет возвращен его нельзя записать 
в переменную int его только можно записать в переменную типа поинтер.
тоесть
            int b;
            b=&i 
пошлет нахер

а сработает только вот так

   int *vPtr;
   vPtr = &i;


у printf это ключ %p который как раз обозначает что аргумент это адрес.
тогда можно вот так

    int i;
    i = 1;

    int *vPtr;
    vPtr = &i;

    printf ("%p %p \n",  &i, vPtr );


тоесть чтобы посмотреть адрес переменной необязательно 
его присваивать переменной поинтер. 

на экране увидим вот это
$ ./123.exe
0x7fff73f6a0cc 0x7fff73f6a0cc 

тоесть увидим сугубо только адрес. а не значение переменной.

дальше идет настоящая побьебка. дело в том что знак * используется для двух совершенно
разных целей. как я уже показал он используется для обьявления переменной поинтер.

    int *vPtr;
тоесть он обьясняет компилятору что мы не просто хотим создать переменную типа int с именем vPtr
а мы хотим создать переменную типа поинтер. который будет хранить не значение переменой а 
адрес который указывает на переменную типа int. если к обычной переменной мы обращаемся по имени
то этой переменной типа int мы обращаемся через поинтер. так вот значок * еще используется еще 
для совершенно другой цели. для того чтобы взять адрес который хранится в поинтере сходит по нему
прочитать значение оттуда и выдать его нам. тоесть

    int a;
    a=1;
    
    int *vPtr;   # обявили поинтер
    vPtr=&a;     # записали в vPtr адрес по которому хранится a
    
    int b;
    b=*vPtr;     # сходили по адресу который хранится в vPtr и записали его в b
если бы мы записали вот так
    b=vPtr  
то в b записался бы адрес который хранится в vPtr а не значение которое хранится по тому
адресу. просто компилятор при этом пошлеот нас нахер ибо он недает в перемнную int записывать
адрес который хранится в поинтере.


    
    int i;
    i = 1;

    int *vPtr;
    vPtr = &i;

    printf ("адрес i=%p,  адрес i=%p \n",  &i, vPtr );


    int b;
    b=*vPtr;

    printf ( "значение переменной адрес которой хранится в vPtr=%i \n\n ", b );


на экране
]$ ./123.exe 
адрес i=0x7fff624bf378,  адрес i=0x7fff624bf378 
значение переменной адрес которой хранится в vPtr=1 


что дает переменная типа поинтер. ну хрен знает. 
без нее можно вот так делать
a=1
c=a
b=2
c=b

а с поинтером можно делать тоже самое вот так

int a = 1;
int *vPtr;
vPtr=&a;

int b = 2;
vPtr=&b;

какой при этом выигрыш пока хер понятно

во первых сама пееременная поинтер тоже жрет память.  потому что она хранит адрес.
во вторых чтобы считать значение на которое поинтер указвавыает надо два раза сходить
в память. вначале чтобы адрес считать а потом чтобы прочитать значение по этому адресу.


когда мы читаем значение переменной на которую укзаываем поинтер исползуя звездочку 
    *vPtr
это называется дереференсинг. (типа пройти по адресу котоырй в себе хранить поинтер)

далее
я обьявляю поинтер. и смотрю где хранится в памяти сам этот 
поинтер. 
    int *aPtr;
    printf ( "%p \n", &aPtr  );


еще я хочу отметить то что поинтер хоть он по сути и хранит в себе адрес.
но при его обьявлении нужно обязательно указать какой тип имеют данные на которые 
этот адрес указывает. все наши текущие примеры гооворят что адрес указывает на данные типа int
тоесть понятно что сам адрес имеет всегда одинаковый формат скажем адрес состоит из 8 байт.
но при обьявлении поинтера этого мало. надо уточнить какой типа данных будет хранится по адресу
который сохранен в поинтере.  если првооооводит аналогию с символьными сслыкам на фс линукса 
то при создании символик линка нам нужно было бы указывать нетолько файл на который мы указываем
но и тип этого файла на том конце. линукс этого не требует. а  язык си этого требует.

 int *aPtr;
    printf ( "сама переменная aPtr хранится по адресу=%p \n", &aPtr  );

    int  i2 = 1;
    aPtr = &i2;

    printf  ( "сама переменная aPtr хранится по адресу=%p,\n"
              "в переменной aPtr хранится значение=%p,\n"
              "по этому адресу хранится int число=%i,\n"
              "у нас есть переменная aPtr покажи что она хранит=%p,\n"
              "зайди в aPtr прочитай значение, расссматривая значение как адрес перейди по адресу только покажи не содержимое а сам адрес=%p\n"
              ,     &aPtr,   aPtr, *aPtr, *&aPtr, &*aPtr    ) ;


на экране
$ ./123.exe 
адрес i=0x7ffdd232366c,  адрес i=0x7ffdd232366c 
значение переменной адрес которой хранится в vPtr=1 

сама переменная aPtr хранится по адресу=0x7ffdd2323678 
сама переменная aPtr хранится по адресу=0x7ffdd2323678,
в переменной aPtr хранится значение=0x7ffdd2323670,
по этому адресу хранится int число=1,
у нас есть переменная aPtr покажи что она хранит=0x7ffdd2323670,
зайди в aPtr прочитай значение, расссматривая значение как адрес \
         перейди по адресу только покажи не содержимое а сам адрес=0x7ffdd2323670


так
значит что мы имеем
    &aPtr  = покажет адрес где хранится сама переменная aPtr
    aPtr   = покажет значение aPtr
    *aPtr  = прочитает значение из aPtr и рассматривая это значение как адрес пройдет далее
             по адресу и прочитает то значение и покажет нам
    *&aPtr = определи по какому адресу хранится перемнная aPtr, пройди по этому адресу и считай 
             значение. коротко говоря прочитай значение переменной aPtr
             
    &*aPtr = зайди в переменную aPtr считай значение, рассмотри значение как адрес памяти, 
             пройди по тому адресу в памяти и считай значение а потом вместо значения выдай
             адрес по которому это значение было считано. дебилизм.
             
в итоге *&aPtr = &*aPtr = aPtr  это одно и тоже


также что еще забавно это то что printf можно вот так юзать
    printf ( "" "" "" "" ) 


чтоб понять дальше про поинтеры немного отоойдем в сторону и повернемся
к функциям.
как их задавать в си. 
значит над главным телом main задается прототип функции.
потом идет главное тело программы.
а после него уже тело функции



#include <stdio.h>


int f1 ( int n );  /* прототип функции */





int main(void) {
    f1(5);           /* <===== а вот это я вызывают функцию из тело программы */ 
    return(0);
}                    /* главная функция */






int f1 ( int n ) {
printf ( " n=%i \n", n );
}                     /* тело функции */



что такое прототип фукнкции понятно это тело функции но без тела. только
заголовок.
как вызывать функцию тоже понятно -  я пишу имя функции и скобках указываю числа
которые ей надо передать. и вот  я дошел до тела функции и тут важно отметить что 
те числа(параметры) которая функция будет принимать они принимаются сразу в переменные. 
и эти переменные определяются не в теле функции а в заголовке. это непривычно но это так.
тоесть вот эта хрень int f1 ( int n ) говорит о том что первое число которое будет передано
фукнции надо запомнить в переменную n которая int. кстати насклко я понимаю переменные указанные
в заголовке фукнции или ее теле они все сугубо локальные внутри фукцнии. на основное тело
программы эти переменые на распотраняются. таикм образом при вызове фукнции f1(5)
мы говооим эй функция f1 лови число 5
а заголовок функции int f1 ( int n ) говорит о том что прилетевщее число 5 надо запомнить
внутрт переменной n и то что прилетевшее число 5 должно принадлежать int 
значт когда мы в баше определяем функцию то мы в заголовке не указываем никакие переменные

function vasya () {

}

при вызывае фукнции из баша все аргументы которые мы ей передадим будут автомтом присвоены 
переменным $1 $2 $3

$ cat 05.bash 
#!/bin/bash

function vasya () {
    echo '$1='$1 '$2='$2
}


vasya 3 4 

exit 0

на экране
$ ./05.bash 
$1=3 $2=4

  
возвращаемся к си.
при вызове функции как я уже скахзал 
надо указать числа которые мы хотим предать фукнкции.
можно указывать сразу голые числа. но можно указать имя переменной.
тогда перед вызвовом функции будет считано значение этой переменной.
и затем будет вызывана функция с уже голыми числами. 


$ cat 124.c
#include <stdio.h>


int f1 ( int n );




int main(void) {
    int i = 1 ;   /* <============== */
    f1(i);        /* <============== */
    return(0);
}





int f1 ( int n ) {
printf ( " n=%i \n", n );
}



таким образом f1(i) не передает в функцию имя переменной i. нет нихуя. 
будет считано из i что оно равно 1. и функция в конечном итоге будет вызывана как f1(1)
это важно понять. ни имя переменной i ни ее адрес это ничего в функцию непередается. 
это все считывается перед вызовом. в фугкцию передается голое готовое число.
далее открывается тело функции и это голое число присваиевается локальной переменной n.
это тоже важно понять. этовсе щас пригодися для понимания когда начнем при вызывае функции юзать
поинтеры.

насколььько я примерно помню как работает передача чисел в фкнцию. она работает через стек. 
тоесть из переменной i ссчитывается 1 и оно пихается в стек. далее запускается тело функции. 
и оно начинает вытаскивать числа те что насованы в стек. и присваивать эти числа своим внутренним
переменным. так вот залупа в том что нам чтобы передать кучу аргументов в  функцию приходится 
пользоваться промежуточной хренью - стеком. это хреново. по крайней мерев в ряде случаев. 
но щас не об этом. минус получается в том что у нас данные из переменной которая лежит 
в главном теле программы читается суется в стек и присваивается локальной переменной 
внутри функции. это значит что если мы хотим обратнов главное тело программы вернуть
обновлленное значение то нам нужно изголяться. потому что еще раз подчеркну что функция 
никакой связи с переменной в главном теле прогарммы не имеет. потому что еще раз подчеркну
что перед вызывом функции значение из переменной читается. суется в стек. фнукция читает
число из стека присваивает своей локальной переменной. 
а как бы нам сделать так чтобы функция меняла значение  переменной из главного тела
программы тут приходят на 
помощь поинтеры.


определяю заголовок функции как
    int f1 ( int *nPtr )
он говорит о том что то число которое прилетит из стека(снаружи) внутрь функции  
его надо присвоить локальной
переменной nPtr которая по своему типу поинтер.  таким образом у нас опять же юзается стек.
у нас опять же заводится локальная переменная видная тлько внутри функции но так как
эта переменная поинтер на ячейку памяти из глобальной секции то функция работая  с поинтером
уже меняет значение не в своей локальной переменной а глобально. !
раньше я упоминал о том что обычно поинтеру руками значение не присваивают. обычно заводят 
обычную переменную. потом через & узнают ее адрес. и этот адрес подпихивают поинтеру. 
поэтому в случае когда в голове функции указано что прилетевшее число это поинтер то у нас не получится
вызывать эту функцию указав при ее вызове адрес руками. нам нужно будет юзать переменную.
тогда:


int f1 ( int *nPtr );   /* здесь я говорю что то число которое прилетит
                        в фунцию f1 ей надо засунуть в поинтер nPtr */




int main(void) {
    int i = 1 ;
    int *bPtr;
    bPtr = &i;        /* присваиваю адрес i в поинтер bPtr   */

    f1( bPtr );      /* в bPtr хранится адрес и я его кидаю в функцию f1 */
    return(0);
}





int f1 ( int *nPtr ) {
printf ( " *nPtr=%i \n", *nPtr );
}    /* фнукция f1 принимает адрес , сует его в nPtr поинтер 
      а далее я говорю напечатай то значение которое лежит по адресу хранящемуся в nPtr*/


на экране

$ ./124.exe 
 *nPtr=1 

таким макаром эта прога сделала то что у нас в функцию прилетел адрес переменной i
тоесть функция получили доступ к переменной из главного тела программы. и мы из внутри
фнукции напечаалли значение i.

теперь модифиуирую программу
я получаю внутрь функции адрес переменной i из главного тела программы.
я увеличиваю эту переменную на +1 из внутри фукнции. а потом из главного тела
программы печатаю обновленное значение переменной i


int f1 ( int *nPtr );




int main(void) {
    int i = 1 ;
    printf ("исходное значение i=%i\n", i  );

    int *bPtr;
    bPtr = &i;

    f1( bPtr );
    printf ("новое  значение i=%i\n", i  );

    return(0);
}





int f1 ( int *nPtr ) {
   int b;
   b=*nPtr;
   b++;
   *nPtr=b;

}


на экране
$ ./124.exe 
исходное значение i=1
новое  значение i=2


функцию можно сделать и короче по размеру


int f1 ( int *nPtr ) {
   *nPtr++;

}


таким образом поинтеры позволяют функциям получать доступ к переменным из главного тела
программы. и менять их. в этом их полезность.


еще раз подчеркну что значит заголовок  фнукции
    int f1 ( int *nPtr )
заголовок функции показывает в какую внутреннюю переменную будет скопирован первое
число которое будет передано функции. 
int *nPtr показвыает что первое число переданное функции будет скопировано в переменную nPtr
которая поинтер который указывает на значение типа int

далее я также хочу сказать что при обьявлении переменной можно заюзать
скобочки. я не знаю что они значат но они нихрена не меняют

    int (*vPtr);
    vPtr = &i;
    (vPtr) = bPtr;

    int (vasya);
    vasya = 1;
    (vasya) = 3;

причем скобочками как видно можно пользоваться нетолько на стадии
иницаилизации но и на стадии присвоения значения.


далее я вот к чему перейду - в си можно получить адрес в памяти не только для переменной
но и для функции. можно узнать по какому адресу находится фунция.
тут появляется такой момент что для того чтобы получить адрес функции нам нужно
инициализировать не просто поинтер а поинтер на функцию.
например
есть функция

int f1 ( int *nPtr ) {
    ...
}

мы обьявляем поинтер. 
и хотим в него скопировать адрес функции

    int (*vPtr);
    vPtr = &f1;

в этом случае комплиятор пошлет нас нахер.
потому что мы неможем получить адрес функции в просто поинтер.
нам нужно обьявить поинтер на функцию

    int (*gPtr) ( int *nPtr );

и тогда уже можно получить в переменную gPtr адрес функции
    gPtr = &f1;

итак у нас есть просто поинтеры. поинтеры на переменную. а есть поинтеры на функцию.

что интересно  если я заменю 
    int (*gPtr) ( int *nPtr );
на 
    int *gPtr ( int *nPtr );
то эта хрень будет иметь уже какойто другой смысл. 
потому что команда
    gPtr = &f1;
уже не отработает.

итак поинтер на функцию. это переменная котоаря хранить в себе адрес фнукции.
и в этом поинтере зачем то надо описыывать аргументы которые эта фнукция принимает. захер это
надо делать непонятно.

так вот когда у нас есть поинтер на функцию. то мы можем вызывать функцию уже не по имени
а используя ее поинтер вместо имени

    (*gPtr)( &i );
тоесть вместо 
    f1 ( &i );
юзаем 
    (*gPtr)( &i );
нахуй это нужно? а это нужно в одном интересном деле. 
если у нас есть функци1 и фугкция2 и функция3
и мы хотим внутри функции1 вызывать либо функцию2 либо функцию3
и чтобы это можно регулировать снаружи.
щас покажу. но для начала хочу еще важную вещь пояснить. если мы оказались
внутри фнукции то из ее нутри ей недоступны никакие данные и переменные снаружи.
фнукция это 100% автономыный кусок кода от внешнего мира.
например у нас  вглавном теле есть переменная i
тогда я не могу к ней обратиться изнутри фнукции


int main(void) {  
    int i = 1 ;           <===== переменная в главном теле программы
}



void f2 ( void ) {
    printf ( " i=%i ", i );

}


комплиятор такую фукнкцию пошлет нахуй. он скажет что никакой 
переменой i он незнает внутри фцнкции.

тоже самое касается прооблемы если мы внутри фцнкции хотим запустить другую функцию.
мы это можем сделать только в главном тееле программы. там мы можем заускать разные 
функции. а чтобы внутри фнкции запустит друугую функуию нужно сделать дополниельные 
телодивжения.  самый распостраненный подход - надо в функцию1 передать поинтер на функцию2
и тогда изнутри фукцнии1 можно будет вызывать функцию2. вот где нужен поинтен на функцию.
вот где он играет реальный рояль. плюс ко всему это дает еще и тот выигрыш что при таком 
макаре мы можем изунтри функции1 вызывать хоть милиард разных других функций. все
опрееделяется на кого указывает поинтер функции котоырй передается функции1.
еще важный момент скажу такой что если мы опреедяем фукцию то обязатеььно это делать
правилно . а именно нао внизу написать тело фукнкции. а вверху обязательно написать 
заголовок (прототип ) функции. иначе компиядятор будет послыть нахуй. тоесть
вот так непраивльно (нет прототипа фкнкции)



int main(void) {

    int (*aPtr) ( int a );
    aPtr = &f1;

    return(0);
};



int f1 ( int a ) {                                        <=== есть тело фкнции
    printf ( "привет изнутри функции f1 \n"     );

};



а вот так приавльно


int f1 ( int a );    <==== есть прототип


int main(void) {

    int (*aPtr) ( int a );
    aPtr = &f1;




    return(0);
};



int f1 ( int a ) {        <==== есть тело
    printf ( "привет изнутри функции f1 \n"     );

};



итак я вовзращаюсь к примеру когда я хочу чтобы 
фнкция запускалась ищнутри другой фнукции. и сделать это 
можно в основном только через поинтер на функцию


#include <stdio.h>


int f1 ( int (*bPtr)( void ) );   /* <=====  я определяю прототип f1 */
int f2 ( void );                  /* <=====  я определяю прототип f2 */



int main(void) {

    int (*aPtr) (void );           /* <=====  я определяю поинтер на функцию такую что 
                                      у нее  нет аргументов */
    aPtr = &f2;                    /* <=====  я записываю в aPtr адрес фнукции f2
                                        теперь мы можем обращаться к фвнкции f2 нетлоько 
                                           по имени но и через ее поинтер*/

    (*aPtr) ();                    /* <=====  я запускаю f2 из главного тела */

    
    f1( aPtr );                    /* <=====  я запускаю f1 и передаю ей имя функции f1 
                                        чеерз поинтер */


    return(0);
};



int f1 ( int (*bPtr)( void ) ) {                           /* <=====  я определяю тело f1 */
    printf ( "привет изнутри функции f1 \n"     );
    (*bPtr) ();

};


/*  функция f1 приняла в себя снаружи адрес поинтера на функцию и записала этот адрес в
свой локальный поинтер на функцию bPtr, теперь мы можем изнутри f1 вызвать фукнцию f2
через поинтер bPtr что я и делаю*/


int f2 ( void ) {                                          /* <=====  я определяю тело f2 */
    printf ( "привет изнутри функции f2 \n"     );

};



вывод на экран
$ ./124.exe
привет изнутри функции f2    <=== это мы взывали f2 из главного тела программы
привет изнутри функции f1    <---- это мы внутри f1 
привет изнутри функции f2    <==== это f2 когда он был вызыван изнутри f1


при такой схеме я могу внутрь f1 передавать поинтер на любую фукнцию и эта фукнция будет 
вывзываться изнутри f1 без изменения кода самой f1.

пример

#include <stdio.h>


int f1 ( int (*bPtr)( void ) );
int f2 ( void );
int f3 ( void );



int main(void) {

    int (*aPtr) (void );

    aPtr = &f2;
    f1( aPtr );

    aPtr = &f3;
    f1( aPtr );



    return(0);
};



int f1 ( int (*bPtr)( void ) ) {
    (*bPtr) ();

};


int f2 ( void ) {
    printf ( "привет изнутри функции f2 \n"     );

};


int f3 ( void ) {
    printf ( "привет изнутри функции f3 \n"     );

};




вывод на экран
$ ./124.exe
привет изнутри функции f2    <== мы взывали изнутри f1 функцию f2 потому что в f1 было передано имя f2
привет изнутри функции f3    <== мы взывали изнутри f1 функцию f3 потому что в f1 было передано имя f3


как на практие применяется эта хренота.
если у нас f2 запиывает число на экран 
а f3 запиывает число в файл то получается что скажем f1 делает расчеты по каким то числам.
и в зависимости от того какой поинтер будет передан f1 либо на f2 либо на f3 наша фукнция f1

вобщем еще раз - это технолгия поволяет изнутри функции сделать вызов другой функции.

главное тело программы {

f1 ( имя функции f2)

}

фнкция f1 (p=имя фукнции) {
    p   <== вызвыают функцию имя которой нам передали через аргумент

}

фнкция f2 () {
    ...
}

в книжке прриваодится такой пример - у нас есть массив. и мы хотим его остортиовать
методом пызырька. (ох уж эти ебнутые названия) 
так вот можно сортировать на убиваение а можно на возрастание.
в главном теле мы запраиваем с клавы как мы хотим сортирвать на убываериние или возрастание.
в зависисомсти от этого мы передаем в функцию f1 имя той функции f2 или f3 которая 
сортирует на убываение или возрастание.
таким маккаром f1 сортирует масив польузуясь либо фукнкией f2 или f3


ксати выше я приводи функцию которая прибавляет единицу
к переенной на которую укаызает поитер

int f1 ( int *nPtr ) {
   *nPtr++;

}


так вот этот код неверный. этот код увелиичвает на единице не переменную адрес которой
ъранися в поинтере а уавелиичвает на единицу сам адрес хранящрейся в поинтере. что нам совсем 
ненужно.
правильный код вот такойэ


int f1 ( int *nPtr ) {
   (*nPtr)++;

}


теперь когда стало поняно как запускать функцию изнутри функции 
плавно подходим к понятию call back в си.

хотя пока отложим эту мудоту.

команда scanf. позволяет считать чтото с клавы.
мануал к команде кончено конечно бесполезный.
в итоге выглядит это так
    scanf ("%i", iPtr)
я так и не понял формат этой команды. слева  в кавычках 
описываем формат того что будем считывать например %i означает что 
будем считывать целое число. а справа надо указать поинтер куда в память это будет считано.
естественно если мы считываем %i то поинтер тоже должен быть формата integer.
надо заметить что scanf ничего не печатает на экране. только считывает. непонятно нахуя
нужна та часть которая в кавычках если у нас переменная поинтер уже задает тип того
что мы хотим считать. ну а дальше прикол.
вначале я сделал вот так

    int *iPtr;
    printf ("введи число: ");
    scanf ("%i", iPtr );
    return(0);

и после ввода числа программма выдавала segmentaton fault.
потом я допер о том что когда мы дали команду int *iPtr то значение iPtr равно по дефолту
нулю. и когда мы даем команду scanf ("%i", iPtr ) то scanf пытается писать в тот адрес
который указан в iPtr тоесть по адресу 0. и ос посылает нахуй при этом. поэтому 
надо делать вот так

    int i;
    int *iPtr;
    iPtr = &i;

    printf ("введи число: ");
    scanf ("%i", iPtr );

    printf ("ты ввел число: %i\n", (*iPtr) );
    return(0);


тоесть мы заводим переменную классическую i. которую ос куда то там пихает.
потом мы находим ее адрес и суем этот адрес в iPtr. поэтому когда scanf будет писать 
по тому адресу то все будет хорошо.

в мануале написано в scanf нужно пихать переменную поинтер. однако вот такой трюк
почемуто тоже срабатывает

    int b;
    scanf ("%i", &b );
    
непонятно нахуй нужен поинтер либо &b почему надо было изьебываться а не вводить просто 
имя переменной. 

далее. 
вот такое не прокатит
    int f = &c;
потому что &c тоесть адрес это не интежер. это в их терминал имеет тип поинтер.

кстати вот такая хуйня работает

    int c = 1;
    int f = *&c;

тоесть хотя c это не поинтер но *&c на ней работает. тоесть &c находит адрес переменной c
а *(&c) дает доступ к содержимому по этому адресу. тоесть c и *&c это одно итоже.тоесть
    int f = c;
аналогичен
    int f = *&c;
    

    int c = 3;
    int f = *&c;
    printf ("c=%i, f=%i\n", c, f);

вывод на экране
    c=3, f=3


    
далее. сложение целых числе работает очень просто

    int c = 3;
    int d = 5;
    int e = c + d;


далее. имя переменной лучше чтобы не превышало 31 символ

далее
оказывается %d первеодится как decaimal integer. тоесть целое в десятичном формате.


далее как ввести два числа в одном scanf. как он их отличает при ввводе?
оказывается через пробел



    int i, j;
    printf ("введи число: ");
    scanf ("%i%i", &i, &j);
    printf ("ты ввел числа: %i %i \n", i, j );



далее. как выглядит if

    int i, j;
    printf ("введи число: ");
    scanf ("%i%i", &i, &j);
    printf ("ты ввел числа: %i %i \n", i, j );

    if ( i > j  ) {
	printf ("%i > %i \n", i, j);
    }

    return(0);



а вот как выглядит if else

    int i, j;
    printf ("введи число: ");
    scanf ("%i%i", &i, &j);
    printf ("ты ввел числа: %i %i \n", i, j );

    if ( i > j  ) {
	printf ("%i > %i \n", i, j);
    }
    else {
	printf ("%i < %i \n", i, j);
    }

    


далее. цикл while
    int k = 1;
    while (k < 10) {
	printf ("k=%i\n", k);
	k = k + 1;
    }


далее
операции с целыми числами


    int i,j;
    i=10;
    j=3;
    int k = i / j;
    printf ("i=%i, j=%i, k=%i\n",    i, j, k);

вывод на экран
i=10, j=3, k=3

операции с дробными числами
вот это я не очень понимаю
    int i,j;
    i=10;
    j=3;
    float l;
    l = i / j;
    printf ("i=%i, j=%i, l=%f \n",    i, j, l);


вывод на экран
i=10, j=3, l=3.000000
почему у нас l=3.
тоесть у него идея такая что арифм операция на int числами это конечно же
int число. то есть разрядность результируюшего числа завсиит не от типа 
переменной слева. это похуй а от самих операндов чисел. тоесть так как i это int
и j это int то опреации над ними это будет int. и потом мы просто этот int присваиваем
в float переменную.
а если мы хотим чтобы у нас результпрующее число было float надо чтобы 
все операнды были float. например это можно сделать вот таак

   int i,j;
    i=10;
    j=3;
    float l;
    l = (float) i / (float) j;
    printf ("i=%i, j=%i, l=%f \n",    i, j, l);


вывод на экран
i=10, j=3, l=3.333333

тоесть (float) i превращает число 10 в число 10 но в формате float.
также я проверил - если у нас справа хоття бы одно число float то результат
тоже будет float тоесть
    l = (float) i /  j;
либо
    l = i / (float) j;


на счет скобок я не понимаю.
вот так правильно
    l = i / (float) j ;
а вот так нет
    l = i / (float j) ;

в тоже время 
вот так неработает
    int (*)iPtr;
а работает только вот так
    int (*iPtr);
тоже самое и вот с этим
вот так правильно
    iPtr = (&m);
а вот так нет
    iPtr = (&)m;

почемуже тогда с float все наоборот?


далее
    c = c + 3
аналог
    c += 3
более того
    c /= 3
    c *= 3
    c %= 3

далее. есть еще забавные операторы ++ и --

    int i = 1;
    printf ("%i\n", i++);
    printf ("%i\n", i);
    printf ("%i\n", ++i);
    printf ("%i\n", i);

вывод на экран
    1
    2
    3
    3

фишка в чем. i++ он в выражении использует текущее значение i. а уже после выполнения
команды увелиичивает его на 1. а ++i наоборот. он вначале увеличивает текущее значение i
а потом запускает команду printf
тоесть i++ это увеличение уже после выполенения printf
а ++i это увеличение перед выполенеием команд
эти операторы дают интересную вещь. 
они дают то что можно прям в операторе while вставить хрень которая увеличивает 
счетчик. это супер удобно.


    int i = 0;
    
    while (i++ < 10) {
        printf ("%i ",i);
    }
    
    printf ("\n");
    return(0);

на экране
    1 2 3 4 5 6 7 8 9 10
    
замечу еще то что обычно после команды надо ставить ;
но этого ненужно делать для {} в команде while


далее. как выглядит цикл for

    for ( int a=1; a < 10; a++ ) {
        printf ("%i ",a);

    }


я попробовал отдельно скобку ( int a=1; a < 10; a++ ) но комплиятор шлет нахер


далее. если подклачать
    #include math.h
то чтобы все успешно скомпилировалось нужен доп ключ в gcc
    $ gcc -o 125.exe 125.c -lm
иначе компляитор пошлет нахер

далее. кстати всякие там *.h файлы например stdio.h можно найти в /usr/include
напрмиер в stdio.h прописано чему равна переменная EOF . она по факту равна -1


далее. 
функция getchar()
она читает данные из stdin 
насколько я понял из ебнутого мана она читает ровно 1 байт. его она и возвращает.
тоесть на stdin поступает байтовый поток. она читает один байт из этого потока.
странно то что в описании этой функции стоит то что она возвращает int а не char.
ведь байт имеет размерность char а не int. хотя понятно что char это подмножество int.

пример

    char a;
    a = getchar();
    printf ("%c", a);



на экране
    $ echo -n "k" | ./125.exe 
    k

тут я более подрбно поясню
    $ echo -n "k" | od -t x1
    6b

тоесть мы щлем байт 0x6b  в stdin. 
getchar его жрет. и присваивает его в переменную a

    $ echo -n "k" | ./125.exe | od -t x1
    6b
    
при этом 
    printf ("%c", a);
он берет 0x6b из памяти и за счет %c срет в stdout ровно тот же 0x6b
а терминал преобразует этот байт в картинку в виде "k"
тоесть все четко - мы впитали 6b из stdin, запомнили 6b в память. потом высрали этот же 6b 
в stdout.

так вот ещераз скажу непонятно почему getchar имеет в описании тип int. она возвращает только один 
байт а это char но никак не int.

в чем разница между getchar и scanf хуй знает. разбираться сложно пока не буду.
вроде как scanf может забрать из stdin больше чем 1 символ за вызов.

если я пошлю больше чем 1 байт на stdin то будет взять только один байт. пример
пример
шлю два байта
    $ echo -n "Я" | od -t x1
    d0 af

    $ echo -n "Я" | ./125.exe | od -t x1
    d0 
    
тоесть берется только d0.
а далее прикол в том что для байта d0 нету никакого печатного символа.
потому что например в ascii есть символы только для 0x00-0x7F это 0dec-127dec
а 0xd0 это 208dec
поэтому на экране мы увидим вместо печатного символа мусор

    $ echo -n "Я" | ./125.exe 
    �

это уже следствие терминала. потому что он не понимает какой символ надо рисовать
если в него прилетело 0xd0

тут еще приходит вопрос. если запустуть 125.exe то чтобы ввести символ надо его нажать
а потом нажать Enter. почему же символ без проблем вводится без всяких энтеров когда
мы юзаем пайп? я думаю ответ такой что если мы вводим руками символ через терминал то пока мы 
ненажали enter то что мы делаем происходит исключиетельно на устройстве "терминал" и запоминается
в его буфере. а когда мы тыкаем enter то уже устройство терминал шлет то что мы натыкали в его буфер
в "канал". как по модему. а этот канал ведет в stdin процесса 125.exe
грубо говоря мы сидим в броузере и вводим чтото в строке поиска. редактируем и прочее.
обработкой этой хрени занимается наш браузер локально на компе.  и только когда мы тыкаем enter 
это все улетает на удаленны сервер и только тогда тот сервер начинает заниматься обработкой того что в
него прилетело. так вот и здесь. пока мы не нажали enter обработкой того что мы ввели занимается
устройство терминал. к процессу 125.exe это не имеет отношения. потому что он пока что ничего не 
получил. он как удаленный сервер. а терминал как локальный браузер. и только после того как
мы тыкнули enter терминал собирает все что мы натыкали и посылает на удаленный сервер тоесть процесс
125.exe 
когда мы юзаем pipe то никаких символов enter нам вводить ненадо потому что у нас один процесс
срет на свой stdout который через посредника ядро приходит на stdin процесса 125.exe 
тоесть echo "k" говоорит "эй команда эхо!, высри на свой stdout "k" и он это делает. 
комбинация "k" обьясняет команде echo что мы от нее хотим. и нам ненужно добавлять "enter" 
тоесть "k+enter" чтобы обьяснить команде echo что мы от нее хотим. она высирает это на свой stdout
он летит в ядро. а оно это подсовывает на stdin для 125.exe 
поэтому в связке
    echo "k"  | 125.exe
нам не нужно после k вставлять символ "enter" чтобы все сработало.
enter появялется когда мы используем усройство терминал чтобы с помощью него сформировать
байтовый поток который мы хотим послать на stdin процесса 125.exe 
нам както надо добраться до процесса 125.exe точнее до его stdin
мы это можем сделать через терминал либо через другой процесс
надо передать байтвый поток туда. если мы это делаем через терминал то терминалу надо понять
когда мы закончили вбивать то что мы хотели и эту шнягу уже можно посылать. для терминала таким
признаком что мы закончили писать свою телеграмму явялется нажатие на enter.
если мы используем другой процесс например echo то эхе такой признак ненужен. мы просто эхе
подсовываем сам байтовый поток и она его шлет.

далее я покажу очень любопытные вещи про терминал. все не так очевидно 
как казалось. например оказалось что вроде как наверное логично но  яне замечал этого - 
оказалось то что когда мы тыкаем enter (у которого байтовый код 0x0a) то терминал принимает
это событие не только как команду о том что наш вводе в его окно закончен и надо все данные
которые мы вбили отсылать процессу 125.exe но и то что само нажатие на enter тоесть код 0x0a
он тоже шлется процессу! тоесть нажатие на enter делает сразу два события - байтовый код 0x0a
добавляет к суммарной байтовой последовательности и вся последоватлеьность шлется процессу.
мне интутивно думалось что нажатие на enter это всего только сигнал терминалу что все что мы ему
вбили можно слать процессу. но не приходилоа в голову что и сам байт код кнопки 0x0a тоже 
отправляется процессу!

центарльный вопрос на котором я закончил это что будет если unsigned char
присвоить -1
тоесть мы в тексте программы пишем

    unsigned char a = -1 

что будет ?  <===== ????

для того чтобы ответить нужно вначале изучить понять узнать что такое 
операция modulo. и я щас начинаю рассматривать эту большую и мудацко 
изложенную тему.

        MODULO

есть два целых числа a,n
так вот далее вводится такая штука, ищется вот такое выражение

     a = q*n + r    (1)
точнее ищется два числа q, r.
и на выражение налагается условия
     2) q это целое число ( -10, -15, 0,  1, 3, 100 итд )
     3) |r| < |n|


из этого вытекает что r это тоже буде конечно же целое число. итак все числа 
в выражении (1)  оказываются целые. 
далее оказывается что числа q и n они неединственны. тоесть есть две пары q,n чисел которые
удовлетворяют всем условиям выше. щас я это покажу докажу
делим (1) на n получаем
    
    a/n = q + r/n  (4)

далее a/n можно представит в виде дробного числа вида +-N.98234792847238973284 (где N цифра больше нуля)
q у нас целое число поэтому оно выглядит в виде десятичной дроби как +-P.00000000000000 (где P цифра
которая больше нуля),
далее также из (3) следует что r/n это положительное либо отрицательное число которое
по модулю меньше единицы. поэтому r/n можно представить в виде +-0.898689560860859438789347987,
где важно заметить что в целой части стоит обязатеьно ноль.
итак подставим все это в (4)

    +-N.98234792847238973284 = +-P.00000000000000   +-0.898689560860859438789347987
    
приведу пример для наглядности, пусть слева число положительное и N=5,

    +5.895498648945798 = +-P.00000000000000   +-0.898689560860859438789347987

я обозначу три этих числа как  (1) (2) (3)
        (1)            =         (2)                      (3)          

и вот смотрим на выражение справа от равно и видим что  число (2)  имеет только целую
часть а число (3)  имеет только дробную часть, причем по модулю оно меньше единицы,
и чтобы нам образовать в итоге
число (1) у которого есть и целая и дробная часть то возможно только два варианта: 
либо P образует целую часть равную целой части числа (1)  а число (2) 
образует собой дробную часть числа (1). тоесть

        +5.895 = +5.000   +0.895

либо второй вариант - число P оно на единицу больше чем целая часть числа (1) тоесть P=5+1=6
а число (3) оно отрицательное и оно отнимает от (2) ровно столько чтобы образоывать дробную 
часть от числа (1) . тоесть
    
        +5.895 = +6.000   -0.105

тоесть еще раз. если число (1) положительное то возможно всего два варианта пары q,r

тогда получаем формулу. значит число (2) это q. значит для нахожддения q мы нашли то что 
q у нас либо равно a/n с обрезанной дробной частью, тоесть берем только целое от деления.
либо q у нас на единицу больше чем предыдущее q. тоесть
    
    q1 = целое от (a/n)             # q положительный 
    q2 = ( целое от (a/n) ) + 1     # q положительный
    
далее зная q уже можно вычислить ему полагающийся r. тоесть
    r1 = a - q1*n
    r2 = a - q2*n
    
итак мы получили две возможные пары q,n которые удовлетворяют все условиям которые я в самом 
выше обозначил

    q1 = целое от (a/n)
    r1 = a - q1*n

    q2 = ( целое от (a/n) ) + 1
    r2 = a - q2*n
    
это я рассмотрел случай когда a/n это положителтное число.
рассматрим  случай когда a/n это отрицательное число.   и пусть 
для наглядности опять же N=5

    -5.98234792847238973284 = +-P.00000000000000   +-0.898689560860859438789347987
        (1)                         (2)                     (3) 
    
опять же один вариант это когда P равен целой части числа (1) тогда (2) = -5.000000

    -5.98234792847238973284 = -5.00000000000000   +-0.898689560860859438789347987
        (1)                         (2)                     (3) 

тогда число (3) должно быть такое что оно должно образовыаться дробную часть такую же
как у числа (1) ну и понятно что знак должен быть тоже с минусом

    -5.98234792847238973284 = -6.00000000000000   -0.98234792847238973284
        (1)                         (2)                     (3) 


а второй вариант который возможен это когда (2) такой что P у нас по модулю на 1 больше ну и конечно 
тоже с минусом , тоесть (2) = -6.00000000000000
а число (3) должно прибавить такую дробную часть чтобы она отнялась от числа (2) и в итоге 
дала и дробную часть равную (1) и целое подвинуло на единицу. тоесть

    -5.982 = -6.00000000000000   +0.018
        (1)        (2)             (3) 

            
таким макаром мы опять же нашли две пары q,n которые удовлеятворяют все условиям исходным.
тогда один q это он равен целой части от деления a\n а второй q он меньше на единицу от первого q
тоесть

    q1 = целое от (a/n)       # соотвественно q отрицательный
    q2 = целое от (a/n) - 1   # соотвественно q отрицательный

    
тогда я собираю все в одну кучу:
    если a/n положительное тогда у него есть две пары q,n
        q1 = целое от (a/n)             # q1 положительное
        r1 = a - q1*n

        q2 = ( целое от (a/n) ) + 1     # q2 положительное
        r2 = a - q2*n
    
    если a/n отрицательное  тогда у него есть две пары q,n
        q1 = целое от (a/n)       # соотвественно q отрицательный
        r1 = a - q1*n
    
        q2 = целое от (a/n) - 1   # соотвественно q отрицательный
        r2 = a - q2*n

        
        
покажу на конкретных примерах.
    a=7, n=3
    a/n>0 a/n=2,333333...  
    целая часть от a/n = 2
    значит
    q1 = 2
    q2 = 3
    r1 = 7 -2*3 = 1 , проверяем что |1| < |3| . все верно
    r2 = 7-3*3 = -2,  проверяем что  |-2| < |3|. все верно
        
    
    a=7, n=-3
    a/n<0 a/n=-2,333333...  
    целая часть от a/n = -2
    значит
    q1 = -2
    q2 = -3
    r1 = a-q1*n = 7 - (-2)*(-3) = 7 - 6 = 1 , проверяем  что |1| < |-3|  . все верно
    r2 = a-q2*n = 7 - (-3)*(-3) = 7 - 9 = -2,  проверяем что  |-2| < |-3|. все верно
    
таким макаром видно что мы нашли правило как находить q,r при заданных a,n
совершенно четко видно что q,n они не единственные. а их две пары. 
отсюда приходит очень вывод что если у нас просят найти q,r при заданных a,n 
то надо уточнять какую пару надо найти или обе пары надо найти ?
так вот нахождение r называется в мире компьютеров  операция MODULO.
тоесть наконец я добрался до этого слова modulo.
( по аналогии операция сложения , операция умножения, также операция modulo). для
операции сложения умножения вычитания нам нужно два операнда. тоже самое для операции modulo
нам надо два операнда. два целых числа. от них находится modulo. по русски говоря на основе их
находится r. это r называется на ихнем языке modulus. тоесть r они обзывают modulus.
по аналогии как резульат сложения называют сумма, результат вычитания называют разность,
результат деления называют частное. резульатом от modulo называют modulus.
дебилизм конечно. так вот из того что я показал выше невозможно получить только r мы получаем
обязательно два числа q и r. причем эти числа не ууникальны. для заданного a и n у нас
всегда есть две пары q1 r1 и q2 r2. также совершенно четко видно что r мы всегда получаем узнав
q. r мы получаем на основе узнанного q. а q мы получаем путем деления a на n а дальше мы вычленяем
целую часть из дроби и либо ее берем как есть либо мы еще к ней доблавяем единицу или отнимаем.
из всего этого сказанного вытекает то что если  у нас программа посчитала r (modulus) от a,n
то надо обязательно знать на основе какого из двух возможных q она это сделала. в языках 
програмирования вычисления q,r от a,n обозначается через знак %. и в целом выглядит вот так
    a % n 
на выхлопе нам выдают r один из двух возможных. 
конечно для получения r на заднем плане программа высчитывает вначале q
а потмо на основе него уже r. выдают нам только r а q молча остается за кадром. 
причем еще раз подчеркну что из двух возможных r выдается только один. какой конкретно
зависит от того как об этом решили авторы языка программирования. вот в чем наебка 
подьеька прикол и особенность. если бы для a,n пара q,r была бы одна то проблемы бы не было.
но поскольку пары две. а значит и вариантов r у нас всегда два а программа a % n выдает 
всегда только один r то супер важно понимать и знать что есть и второй r но он остался 
за кадром. и нам надо знать какой q был использован для получения данного r.  это еще раз 
скажу зависит от автором языка программирования. непонятно почему они не сделали так чтобы
выдавалось оба r. тогда бы не было бы никаких прблем.


итак еще раз вернусь к примерам
    a=7, n=3
    a/n>0 a/n=2,333333...  
    целая часть от a/n = 2
    значит
    q1 = 2
    q2 = 3
    r1 = 7 -2*3 = 1 , проверяем что |1| < |3| . все верно
    r2 = 7-3*3 = -2,  проверяем что  |-2| < |3|. все верно
        
    
    a=7, n=-3
    a/n<0 a/n=-2,333333...  
    целая часть от a/n = -2
    значит
    q1 = -2
    q2 = -3
    r1 = a-q1*n = 7 - (-2)*(-3) = 7 - 6 = 1 , проверяем  что |1| < |-3|  . все верно
    r2 = a-q2*n = 7 - (-3)*(-3) = 7 - 9 = -2,  проверяем что  |-2| < |-3|. все верно


тоесть другими словами  я из формул получаю вот что 
    7 %  3  = 1 или -2
    7 % -3  = 1 или -2
    
а теперь посмотрим что нам покажут разные программы:
    bash: 
        $ echo $(( 7 % 3 ))
        1

        $ echo $(( 7 % -3 ))
        1

        
    C:
        7 %  3  = 1
        7 % -3  = 1


    питон3:
            >>> 7 % 3
            1
            >>> 7 % -3
            -2


    awk:
        $ awk 'BEGIN { a = 7; b = 3; print (a % b) }'
        1
        $ awk 'BEGIN { a = 7; b = -3; print (a % b) }'
        1


    

    perl:
        $ perl -le 'print 7%3'
        1
        $ perl -le 'print 7%-3'
        -2

    

    
хочу сказать что в википедии и в стековерфлоу эта тема раскрыта полностью по мудацки.
куча мусора. люди не понимают нихрена собирают в кучу правду и неправду. куча мусора. ад.


как можно заметить что весь поиск q,r основывается базируется отталкивается от перво наперво
поиска q. зная q мы сразу находим его r. как видно из моих формул я нахожу оба q основыываясь 
на знаке выражения a/n  в зависимости от того оно положительное или отрицательное.

в википедии  и интернетах q ищут по нескольким правилам, все они в итоге находят те же 
самые q но обставлено это все значительно замуденннее и загадочнее на пустом месте.
расказываю

первый подход называется truncated division.
они делят a/n получают дробное число. а далее они его округляют вот по такому правилу
    23.7 gets rounded to 23, and −23.7 gets rounded to −23
и это число и равно q.
округление работает по такому принципу - мы округляем число до ближайшего целого в сторону x=0.
тоесть если число положительное то мы округляем до ближайщего целого влевую сторону смотря.
а если число отрицательное от округляем в сторону ближайшего целого смотря направо. туда
куда мы смотрим мы смотрим в сторону x=0. поэтому подход и называется округление в сторону нуля.
как можно заметить при таком подходе для заданного a,n они получают всего навсего одну 
пару q,r. а не две. тоесть половина решения теряется.  после того как нашли один q.
уже легко по формуле найти его r.  
    r = a - q*n

посмотрим какие ответы мы получим по этому подходу
    7 % 3
    a/n=7/2=2.333333....
    2.3333 округояем до ближайщего целого смотря в ту сторону где x=0 тоесть влево
    значит округляет до 2. значит q=2
    тогда r=a-q*n=7-2*3=1
    итого 
    r=1
    
    7% -3
    a/n=-2.3333333
    -2.3333 округляем до ближайщего целого смотря в сторону нуля тоесть направло. значит
    оругляем до -2 , тоогда q=-2 тогда r=7 - (-2)*(-3) = 7-6=1
    итого 
    r=1
    

смотрим наверх и сравниваем с теми r котоырые мы получили в разных программах,
значит bash, C, awk они работают по методу "truncated division".

прежде чем перейти к следущему методу находждения q,r  я хочу рассмотреть две фнукции 
которым заебывают без нужды при описании данной темы. одна называется floor функция (функция потолок)
и ceiling функция (функция пол) 

floor функция работает так. мы берем число дробное скажем 0.9 и округляем его до ближайщего целого
находящегося слева от него. скажем для 0.9 это 0 
а скажем для -1.5 это число -2 
тоесть при округлении мы всегда смотрим влево тоесть в сторону -inf

ceiling функция работает так. мы берем число 0.9 и округляем его в сторону ближайшего целого
числа стоящего справа. в данном случае 1.  а для числа -1.5 ближайшее целое число стоящее справа это -1.
тоесть мы при округлении всегда смотрим направо в сторону +inf

замечу еще вот что в обоих эту функциях  ( и ceiling и floor) если у нас аргумент уже целое 
число то резулбтат будет само это число. тоесть floor(2)=ceiling(2)=2,
floor(-2)=ceiling(-2)=-2
тоесть в этом плане с ними легко и единообразно.

нахуя был их называть пол и потолок хуй его знает. видим чтобы мозг дополниельно заебывать 
загадочностью.

так вот для примера видно что truncated division оно для (a/n)>0 при округлении так как мы смотрим
налево то получается мы как бы применяем функцию floor (смотрим налево в сторону -inf в поисках
ближайщего целого цисла) а если (a/n)<0  то при так как мы при округлении смотрим направо то это экви
валентно округлению по правилу ceiling функции. итого:

                            | floor(a/n),   при (a/n)>0
    truncated division(a/n)=|
                            | ceiling(a/n), при (a/n)<0
                      
            

таким образом truncated division (a/n) если говорить по простому еще раз повторю он работает так
мы берем a/n , получаем какое то дробное число. далее округляем его до ближайщего целого если 
смотреть в сторону (a/n)=0 и результат округления это и есть q. зная q вычисляем r.
есои же говорить макисмлаьно загадочно то мы говорим что если (a/n)>0 то мы к дроби применяем
floor функцию, а если (a/n)<0 то применяем ceiling фукцию. в итоге расутат такую формулировку
до практиеских результатов очень тяжело.

опять же подчеркну что в итоге примеения подхода truncated division мы не получим какието 
новые q,r которые я получаю своим способом. мы получим всего одну пару q,r из двух возможных пар.
вот и все.

и truncated division и все последущие методы поиска modulo тоесть r они все всего навсего
находят только одну пару q,r из двух всегда существующих. и только и всего. никаких новых q,r
по сравнению с моим методом что я описал они не находят.



следущий метод называется "floored division", (или метод дональда кнута)
тоесть если a/n равно  23.7 gets rounded to 23, а если a/n равно  −23.2 gets rounded to −24.
тоесть у нас для всех a/n применяется функция floor , которая округляет дробное число
до ближайшего слева. вот и все.


рассмотрим те же самые два примера 7 % 3 и 7 % -3
напомню что truncated division нам дал
    7 %  3  = 1
    7 % -3 = 1

итак 
    7 % 3
    a/n = 2.33333
    применяем к нему floor тоесть округляем до ближайшегго целого слева это число 2
    значит q=2, значит r=a-q*n=7-2*3=1
    тоесть r=1 
    
    7 % -3
    a/n=-2.333333
    примнем  к нему функцмию floor. тоесть округляем до блиайайшего целого слева. 
    это число -3. значит q=-3 , значит r=7-(-3)*(-3)=7-9=-2
    тоесть r=-2
    
подвожу итог

    truncated division нам дал
    7 %  3  = 1
    7 % -3  = 1

    floor division нам дал
    7 %  3  = 1
    7 % -3  = -2
    
    
получается (если отмотать наверх ) по правилу floor division работает питон3 и perl.

кстати сказать и в методе truncated division и в методе floor division заявлено некая операция
деления. по факту нихуя никакого "особого" деления не происходит. деление происходит по классическому
правилу деления. а происходит по факту ОСОБОЕ ОКРУГЛЕНИЕ. и в этом у них еще один долбоебизм.
тоесть по нормальному надо было называть round to zero и  round to -inf 
причем нахуй тут какоето деление для меня полная загадка. тоесть просто суки путают на ровном месте.


следущий метод это euclidian division ( деление по евклиду)
опять же. деления особого никакого нет. деление обычное. вся фишка в округлении.но 
не в делении.
так вот этот метод работает так. в предыдущих методах мы поделив a/n смотрели либо в сторону
нуля либо все время влево. так вот в текущем методе мы смотрим на знак n. 
если n>0 то мы округляем налево. а если n<0 то округляем направо. тоесть этот метод 
похож на метод truncated division потому что там мы округляли (a/n) в сторону нуля
а здесь мы округляем (a/n) тоже в сторону нуля только если там по оси X был как бы отложен (a/n)
то в этом примере по оси X как бы отложен n.

пример тот же самый
    7%3
    n=3. 3>0 значит округляет a/n влево. a/n=2.3333 значит округленное число 2. значит q=2
    значит r=1
    
    7 % -3
    n=-3 , -3<0 значит a/n округляем вправо. a/n=-2.333 значит округленное число -2.
    значит q=-2
    значит r=7-(-2)*(-3)=1

итого 


    truncated division нам дал
    7 %  3  = 1
    7 % -3  = 1

    floor division нам дал
    7 %  3  = 1
    7 % -3  = -2

    евклидово деление
    7 %  3  = 1
    7 % -3  = 1
    

так как метод евклидова деления смотрит только на знак n 
можно рассмотреть еще случай  -7%-3  и -7%3 для всех методов

    truncated метод
    -7 % -3 
    a/n=2.333, округляем в сторону нуля. будет 2 значит q=2. значит r=-7-2*(-3)=-1
    -7 % 3
    a/n= -2.3333 округляем в сторону нуля. будет -2. значит q=-2. знчит r=-7-(-2)*3=-1
    
    
    floor метод
    -7 % -3
    a/n=2.33333 округляем влево получаем 2. значит q=2 значит r=-1
    -7 % 3
    a/n= -2.3333 округляем влево получаем -3. значит q=3 значит r=-7-(-3)*3=2
  
    эвклидово деление
    -7 % -3
    n=-3, -3<0 значит округляем вправо.  
    a/n=2.33333 округление вправо дает 3. значит q=3
    значит r=-7 - 3*(-3)=2
    -7 % 3
    n=3, 3>0 значит округляем влево
    a/n= -2.3333 округление вправо дает -3. значит q=-3 значит r=-7-(-3)*3=2
    
итого тогда мы имеем


                              7 %  3    7 % -3    -7 % -3     -7 % 3
    truncated division          1         1         -1          -1
    floor division              1        -2         -1           2
    евклидово деление           1         1          2           2


или в таком виде



    truncated division нам дал
    7 %  3  =  1
    7 % -3  =  1
   -7 % -3  = -1
   -7 %  3  = -1
    
    
    floor division нам дал
    7 %  3  =  1
    7 % -3  = -2
   -7 % -3  = -1
   -7 %  3  =  2

    евклидово деление
    7 %  3  = 1
    7 % -3  = 1
   -7 % -3  = 2
   -7 %  3  = 2


жесть.
также эти умники делают такое замечание которое по мне неимеет какойто
существенной ценности - то что в truncated division знак r такой же как у делимого,
в методе floor знак у r такой же как у делителя.  методе евклидова деления r всегда  >= 0
ну и что?

итак вся эта мудота заварена тлоько из за того что высчитывать оба q1 и q2 и оба r1 и r2
никто не хочет. поэтому нужно как то определяться какой q и какой r ( хотя как я уже сказал
q обычно осатется за кадром и на экране показывают только r) из двух надо показать на экране.
вот эти "методы" этим и занимаются. в одним выбираются такой r из двух в других другой r
из двух. вот и вся суть этой мудоты с "методами". если бы они возвращали оба r вообще никаких
методов и мудоты не было бы. 

итак теперь когда стало понятно что такое модуло. как оно вычисляется. также стало понятно
что программы типа баша, си, питона, перла и прочие они не вычисляют оба r. нет. 
они все ограничиваются только вычислением одного r.  так вот вовзращаемся теперь кокнретно
к си. путем экспериментного тыка я выяснил что си при операции a % n вычисляет тот r
который можно вычислить пользуясь правилом truncated division.
доказываю:

значит я посчитал руками что 
    truncated division нам дал
    7 %  3  =  1
    7 % -3  =  1
   -7 % -3  = -1
   -7 %  3  = -1

теперь посмотрим что покажет си:
  int a;
    a = 7 % 3;
    printf (" 7 %% 3 = %i    \n", a);

    a = 7 % -3;
    printf (" 7 %% -3 = %i    \n", a);

    a = -7 % -3;
    printf (" -7 %% -3 = %i    \n", a);

    a = -7 % 3;
    printf (" -7 %% 3 = %i    \n", a);

вывод на экран
    7 %  3  =  1    
    7 % -3  =  1    
   -7 % -3  = -1    
   -7 %  3  = -1    

тоесть вывод на экран полностью совпадает то что я руками посчитал по методу
truncated division.

итак по какому правило работает modulo тоесть a % n  и высчитывается modulus тоесть r
в си я узнал.

теперь я перехожу к тому вопросу с которого все началось
если в тексте программы пишем

    unsigned char a = -1 

какое значение будет у переменной ?
тут опять же я хочу вначале рассмотреть похожий вопрос

    unsigned int a = -1 

потому что дело в том что мы проверяем содержимое переменной через printf
а у него нет такого %X чтобы он показывал именно char тип. у него есть точный %i
который показывает содержимое типа signed integer или %u который показывает unsigned integer
а если мы будем пытаться таким макаром посмотреть переменную char то он ее модифицирует, превратит
в integer а это нам пока совсем ненадо. нам и так несладко. поэтому работаем с этим примером

    unsigned int a = -1 

можно еще измениь и смоделироваьт по другому

    unsigned int a = 0;
    a = a -1;
    
суть будет одна и таже.

так вот в такой ситуации когда мы пытаемся записать в переменную данные которые в этот
тип не влазиит то си руковдствуется вот чем - 
    subclause 6.3.1.3, paragraph 2 [ISO/IEC 9899:2011
а оно гласит
    1. When a value with integer type is converted to another integer type other than _Bool, if
the value can be represented by the new type, it is unchanged.
    2. Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or
subtracting one more than the maximum value that can be represented in the new type
until the value is in the range of the new type.60)
    3. Otherwise, the new type is signed and the value cannot be represented in it; either the
result is implementation-defined or an implementation-defined signal is raised.

   
так вот что происходит по руски. берется максимальное число которое можно записать в данный
тип переменной ( UINT_MAX в данном случае. чему он равен можно найти в  /usr/include/limits.h) , 
далее это число UINT_MAX увеличивается на 1. и эта хрень прибавляется к нашему
значению которое у нас не влезает  в наш тип.  вот так действует то ли компилятор то ли код 
который он сгенерирует. 
итак. исходя из примера выше мы пытаемся записать -1 в unsigned int который неподдерживает 
цифры со знаком минус. тогда си берет -1 и прибавляет к нему UINT_MAX+1 в итоге
внутри переменной a у нас окажется цифра UINT_MAX которая отлично вмещается в unsigned int
соотсвтевенно если мы захотим всунуть -100 в unsigned int то в итоге внутри переменной окажется
цифра -100+UINT_MAX+1 = UINT_MAX-99 который тоже отлично влезет  в unsgned int
согласно limits.h  
    #  define UINT_MAX	4294967295U
итак проверим вот что 
мы попытаемся записать -1 в unsigned int. и в итоге внутри переменной должно оказаться число = 
= -1 + 4294967295 + 1 = 4294967295

код:
    unsigned int a = 0;
    a = 0 - 1;
    printf ("%u  \n", a);

на экране:
    $ ./127.exe 
    4294967295  

вывод: все сработало как предполагалось.

теперь попытаемся записать -100 в unsigned int
тогда в теории мы должны получить в переменной -100 + 4294967295 + 1 = 4294967196

код:
    unsigned int a = 0;
    a = 0 - 100;
    printf ("%u  \n", a);

на экране:
    $ ./127.exe 
    4294967196  
видим что теория опять совпала с практикой

итак я ответил на вопрос что будет если пытаться в перемнную с типом без знака
пытаться записать отрицательное число. тогда спрашивается нахрена я до этого так долго 
и так трудно рассматривал тему с модуло ведь в итоге оно не пригодилось. ответ такой - 
в стековерфлоу твердили что при этой процедуре используется операция модуло. а по факту
нифига она не исползуется. вот такой прикол.

немного еще продолжу всю эту тему.
вот код подключив limits.h можно записать в переменную ее макс значение:

код:
    #include <stdio.h>
    #include<limits.h>


    int main(void) {

        unsigned char b = UCHAR_MAX;
        printf ("%u \n", b);

    }


на экране:
    255
    

следущий пример
интересен тем что 
%hhu означает unsined char тип
%hhx означает unsigned char в шестнадцартиричном виде

    unsigned char b = UCHAR_MAX;
    printf ("%hhu \n", b);
    printf ("%hhx \n", b);


на экране:
    255 
    ff 


следущий пример 
интересен тем что он печатает содержмое ячейки unsigned когда мы туда 
попровали записать -100 и печатает это в 
в формате unsigned char
в десятичном виде и в шестнадцартрииричном виде


    unsigned char c = 0;
    c = 0 - 100;
    printf ("%hhu \n", c);
    printf ("%hhx \n", c);


на экране
    156 
    9c 



далее я в стандарте iso/iec 9899:201x (далее я буду его упоминать как просто iso)
обнаружил в 6.2.5 часть 9 вот такое:

The range of nonnegative values of a signed integer type is a subrange of the
corresponding unsigned integer type, and the representation of the same value in each
type is the same. A computation involving unsigned operands can never overflow,
because a result that cannot be represented by the resulting unsigned integer type is
reduced modulo the number that is one greater than the largest value that can be
represented by the resulting type.
    
также  в 6.5.5 я обнаружил:

The operands of the % operator shall
 have integer type.

The result of the / operator is the quotient from the division of the first operand by the
second; the result of the % operator is the remainder. In both operations, if the value of
the second operand is zero, the behavior is undefined.

When integers are divided, the result of the / operator is the algebraic quotient with any
fractional part discarded.(this is often called truncation towards zero). 
If the quotient a/b is representable, the expression
(a/b)*b + a%b shall equal a; otherwise, the behavior of both a/b and a%b is
undefined.

итак что мы видим. начну разбирать по частям
    The operands of the % operator shall
 have integer type.
здесь они говорят о том что хрень оператор % работает только с целыми числами. тоесть
указано с каким полем он работает. хорошо. значит работает он только с целыми.

далее они пишут
    The result of the / operator is the quotient from the division of the first operand by the
    second; the result of the % operator is the remainder. In both operations, if the value of
    the second operand is zero, the behavior is undefined.


Итак они говорят что оператор % показывает некий остаток для двух операндов.
вобщем я пока решил не траить свое время на подготовку ответа что на самом деле такое modulus
для стэковерфлоу. это займет много время и сил. я не хочу на это траить свои силы. 

но перед этим я сделаю вот что. мы уже знаем что если значение не помещается в тип переменной
то тогда срабатываеи формула  "значение + max + 1"
наример если -100 не влазиит в unsigned char то тогда в переменную будет записано 
значение  "-100 + 255 + 1" = "156"
но также как видно выше из хрени iso что эту же ситуацию еще раз расписывают по другому
что если значение не помещается в тип переменной то к этому значению применяют формулу
    "значение % (max+1)" 
при этом эти долбоебы не уточняют по каому правилу они модуло вычисляют. 
значит нам придется это щас понять самостоятельно.
я сделаю вот что.
посчитаю какой % я получу при разных алогоритмах ( трункейтед, флор, евклидов) для двух примеров:
    -100 % 256
     258 % 256
  
  
  truncated метод
  -100 % 256
    a/n=-100/256=-0.39 , округляют по направлению к нулю(а ноль  у нас справа) до целого получаю 0
    значит q=0 значит r=-100-0*256=-100
    
 мы уже знаем что при попытке записать -100 в uns char у нас там будет 156. 
 значит модуло вычисляется точно не по правилу транкейтед
 
 floor метод
 -100 % 256
 a/n=-0.39 округляем влево  до целого получаю -1. значит q=-1
 значит r=-100 - (-1)*256 = -100+256 = 156, значит r=156
 и ровно такоже значение у нас по факту получается в си.
 
 рассмотрим следудщий пример
 258 % 256 
 a/n=1.007 округляем влево до целого. получаем 1 значит q=1
 значит r=258-1*256=2
 
 теперь прикинем чему будет равно занчение переменной uns char при попытке 
 туда записать 258.  "258 + 255 +1 " это будет число явно больше 255. в том ебанутом
 правиле там написано что max+1 может прибавляться а может отниматься. значит
    "258 - (255+1)" = 258-255 -1 = 2 
    
щас проверим реально через код
код
      unsigned char a = 0;
      a = 0 + 258;
      printf ("%hhu  \n", a);

вывод на экран:
 ./127.exe 
2  

итак я получаю что :
    если попробвать записать -100 в uns char то в итоге си туда запишет 156
    если попробовать записать 258 в uns char то в итоге си туда запишет 2
и ровно теже самые цифры я получаю если через floor правило посчитаю
    -100 % 256 = 156
     258 % 256 = 2
      
это значит что то что написано в iso:
The range of nonnegative values of a signed integer type is a subrange of the
corresponding unsigned integer type, and the representation of the same value in each
type is the same. A computation involving unsigned operands can never overflow,
because a result that cannot be represented by the resulting unsigned integer type is
reduced modulo the number that is one greater than the largest value that can be
represented by the resulting type.

к нему надо добавить существенное разьяснение о том по какому правилу эти доблбоебы
высчитваывают эту модуло. и как оказалось по правилу floor modulo. эти дебилы об этом
не говорят. не понимаю или умалчивая что модулу можно высичтитывать на основе миллиона
разных правил. и поэтому когда мы говорим про модулу то нужно сразу уточнять о какой сука
модуле вы суки ведете речь падлы.


кстати проверим чему равны теже прмиеры но если считать на основе евклидова правила
    -100 % 256
     n=256, 256 > 0 значит округлять будет влево
     a/n=-0,390625 , округляем влево получаем -1 значит q=-1
     r=-100-(-1)*256=-100+256=156
     
     258 % 256 
     n=256, 256 >0 значит округляем будем влево
     a/n=1,0078125 , округляем получаем 1 значит q=1
     r= 258 - 1*256= 2
     
     кхм... получается что у нас в случае когда  N % 256 то у нас что floor что евклидово
     правило дают одинаковый резулат... полуачется что точно нельзя сказать каким
     правилом пользуется си.. в этом случае.. ладно..
     
     
еще раз вернемся к этому тексту
When integers are divided, the result of the / operator is the algebraic quotient with any
fractional part discarded.(this is often called truncation towards zero). 
If the quotient a/b is representable, the expression
(a/b)*b + a%b shall equal a; otherwise, the behavior of both a/b and a%b is
undefined.

из него получаем         
    (a/n)*n +a%n=a
    также в тексте указано что a/n выссчитывается так что у дробного числа отбрасываются
    его дробная часть. тоесть есл у нас a/n= 3.2343242 то его округленная число будет 3
    а если a/n=-3.234234 то его округленное число будет -3 
    и действииельно такое округление равносильно делению на основе truncated to zero
    правила. тоесть
    
    trunc(a/n)*n + a%n=a
    из этой формулы сразу становистя понятчно что q=trunc(a/n)
    a%n= a - q*n
    вобщем становится понятчно что операция modul % в си высчиытвыается на основе
    truncated to zero правила.
    
    
итак итого выяснилось вот что:
    что касается операции a % n то  в си это операция модуло которая высчитвыается на основе
    правила truncated to zero
    
    также вычснилось что если мы хотим в uns char\int записть занчение которое отрицательное
    либо которое больше чем максимум для этого типа то система дейсвтуеи вот как:
    если число отрицательное напрмиер -100 то в переменную будет записано вот такое число
       -100 + max +1
    где max это макс число которое влезвает в данный тип. например для char это 255.
    макс значение для типа можно посмтреть в limits.h
    если же число положтельное и оно явно больше чем max то ситема тогда в переенную запишет
    вот такое значение (для примера мы хотим записать 1000)
            1000 - (255 +1 ) = 744
    это число невлезает в наш тип. ибо максимум мы выдержим 255. тоода процедура повтоярется
        744 - (255+1) = 488
    опять невлезает , опять повтояем
        488 - 256 = 232
    наконце получили число котооорое влезло . его система и запишет в перменную.
    тоже самое если мы хотим записать -1000
      -1000 + (255+1 )= -744  невлезает. повтоярем
      -744 + 256   = -488 невлезает. повтоярем
      -488 + 256 = -232 невлезает
      -232+ 256 = 24 влезло
    тут надо заметить то что поерация повтояряется до тех пор пока новое число не влезет
    и то что если мы впихиваем отриацатльеное число то нужно приабавлять (max+1)
    а если мы впихываем положительное число то нужно  отнимать -(max+1)
    и еще я узнал то что вместо вот такого ручного отнимания приавления си дейсвтует
    другим способом. (вобще хуй знает каким способом он дйствует ибо эти долблоебы из iso
    написали что во вреся одной и тойже ситуации действует сразу два алгоритма якобы). так
    вот вместо ручного прибавления убавленя якобы дейтсвтуте алгоритм модуло. они не написали
    но я выяснили проверкой что работает алгоритм модулы по евклиду или флор.какой из них
    алгоритм работает точно непонятно. но они в данном случае (когда n>0 нармимер для uns char
    n=256) оба алгоиритма дают одинакоый результат. поэтому можно считать пользуясь любым
    алгоритмом из двух
    так вот при попытке записи числа которео невлазиит в тип то в перемену будет записно
    число
            N % (max+1)
    например N=-1000 , пишем мы в uns char значит max=255 тогда
        -1000 % 256 (по алгориму евклида или алгоритму floor)
        я воспользуюсь оботми чтобы показать что получим одно и тоже
        floor
        a/n=-3.90 , округляем влево полкчаем -4 , зачит q=-4
        r= -1000  - (-4)*256=-1000 + 1024 = 24
        евклиов алгоритм
        n=256 >0 значитокругляем влево.
        a/n=-3.90 окруляем получаем -4 , значт q=-4, значит r=24
        получили одно и тоже.
        
        следущий  пример
        258 % 256 
        floor
        a/n = 1,0007 , окрруляем влево поулчаем 1 значит q=1
        r=258-1*256=2
        евклидов аолгоритм
        256>0 значит окргуляем влево.
        a/n=1,0007 округляем получаем 1 значит q=1 значит r=2
        все опять совпало.
        
тепер проверим через код
    unsigned char a = -1000;
    printf ("%hhu  \n", a);

    a = 258;
    printf ("%hhu  \n", a);

на экране
24  
2  

все сошлось.

divisor = делитель
        

modulo
    у гаусса
    у евклида
    в си
    

гаус в своей книге "Disquisitiones Arithmetica" говорит.
есть число a которое назовем модуль.
числа b и c называются сравнивыми по a если 
b-c= k*a, где k целое. тоесть b-c должно делиться нацело на a.
также тогда b назвыается вычетом c по модулю a
c называется вычетом b по модулю a
также вытекает что c-b = k2*a

если зафиксировать a и c то все b можно найти по формуле
b=k*a+c, где k это любое целое цисло.
например  a=12, c=3 тогда 
     b(k)=k*12+3, k = -inf... 0 ... +inf
     b=...-21 -9 3 15 27 ...
        

сравнимость двух чисел обозначаем 
    a _=_ b (mod n)
    
причем (mod n) это как бы в скобках справочная информация чтобы было понятно 
при каком модуле это верно.

A=4, m=12
A+k*m=4+k*12=-8, 4, 16, 28

A=-4 m=12
-4+k*12= -4 8

A=12 m=12
12+k*12=12, 0

A=11 m=12
11+k*12, 11, -1

A=-13 
-13+k*12= 
 k =-2 -13-24 =-37
 k=-1  -13 -12 =-25
 k=0     -13
 k=1     -13+12 =-1
 k=2      -13+24=11
        
A=-13 m=5
-13+k*5 , 2 -3

A=5 m=7
5+k*7 5 -2

итак я увидел как сам гаусс ввел понятие модуля. сравнимых чисел.
какое это имеет геометрический смысл.
теперь надо найти тоже самое но в английских терминах.

n - modulus
"a is congruent to b modulo n"  
a_=_b (mod n)

если есть число a и число m то числа сравнимые с a лежат от него на расстоянии кратном m.
следствие 

a-b = k*n, где k это целое
или
b-a = k1*n, где k1 это целое

из гаусса видно что такое modulus и что такое modulo
modulus этo m  а modulo это не самостоятельное понятие а часть большой фразы

modulus это как бы сусществиетльное "модуль"
а modulo это как бы фраза "по модулю" или "от модуля" или "вследствие модуля"
или "относительно модуля" 

a=3 b=12
3+k*12, -9, 3, 15, 

3_=_-9 (mod 12)

по русски говоря расстояние между 3 и -9 кратно 12
походу метод евклиа ищет наименьший положительный вычет при заданном вычете и modulus

a=-10 b=12
-10+k*12 == это все вычеты для данного модулюса и заданного вычета
наименьший положиелный вычет это 2

-10-2=k*12, k=-1

-10=(-1)*12+2

perfect passive participle

fourth principal


        
вопросы:
отисаться на стековерфлоу на счет того что такое модулюс
что такое call back в си ?
void ? (это пиздец какая тема для старта)

короче - далее я занялся изучением как работает арифм операции на Си и 
модулюс хрень и записал все что узнал нездесь а ручками на бумажке. 
для этого смотри вот такую папку - /docs/modulus

===








| pointer
| execve 

будет очень важное замечание на счет execve в конце статьи. 
так что обрати внимание

все примеры которые здесь рассмотрел в 157.c

хочу быстро набрость на счет поинтеров  в С

началось все с сисколаа execve 

int execve(const char *filename, char *const argv[],
                  char *const envp[]);

думаешь такой что эта шифровка значит.

итак про переменные а в особенности 
про поинтеры.

на счет переменных где они хранятся.
значит в памяти память программы (процесса) разбита на куски. это heap, stack,
bss, rodata, text, data

в text хранятся команды программы.
в rodata хранятся константы
в heap хранятся данные которые туда пишутся динамически уже во время выполенениия
программы. остается stack, bss, data.
стек это тоже как бы динамическое хранение данных. но оно такое - простенькое
если в heap чтобы получить куско памяти нужно вызывать malloc()
то со стеком работа попроще. в стеке во время выполнения хранятся переменные
которые указаны внутри функций. также через стек происходит передача параметров
которые входные для функций. у нас остается bss и data.
все "обычные" переменные которые указаны в main() программы они статически еще 
до начала выполенения программы суются в bss и data и там они сидят всю программу.
как я понял в bss записываются переменые которые обьявлены но им не назначено 
значение. а в data записаны перменные которые обьявлены и им присвоено значение.
я незнаю можно и регулировать какой размер занимают эти секции. 

так вот перехожу к поинтерам. положим мы говорим о поинтерах которые
мы опишем в main() они ничем не выделяются. они будут сохранены либо в rodata
(если они консанты то ест их менять нельзя) либо в bss если мы их обьявили но не указали
значение, либо в data если обьявили и задали значение.


теперь по сути кто такие поинтеры. 
вначале как идет обращение внутри программы к простым переменным на уровне ассемблера.
я думаю что компилятор в тексте программы если мы обьявили простую переменную
int a = 1;
то в тексте на ассемблере это выглядит как типа mov 0x2342123, 1
тоесть просто указан статический адрес и к нему идет обращение. тоесть зная адрес
мы можем добраться до значения.  а адрес он в тексте кода программы вбит.
 
поинтеры я думаю точно также к ним идет обращение то есть в тексте есть просто 
вбитый адрес и идет
    mov 0x323432, 1
но в тексте программы там как то помечено что значение котоотрое лежит по адресу
оно не конечное а что там лежит еще один адрес и вот если уже сходит по второму
адресу то наконец доберемся до значения!

вовращаеся теперь от асемблера к с. 
если обычная переменная задается через имя и указав имя мы доберемся до значения
то поинтер тоже имеет имя но указав имя мы доберемся до адреса по которому нужно
сходит и мы доберемся до значения

при обьялвении переменной мы указаеем ее тип

int a;

при обявлении поинтера тоже нужно указать какой типа хранится по тому адресу
который он в себе хранит

int * a;

на счет присвоения занчений
тут как всегда в с сплошные приколы !
дело вот  в чем. 
оказыается когда мы обьявили эту переменную то почемуто как я понял
компилятор назначает адрес этой переменной там где ее искать НО 
при этом совершенно не запаривается какое число записано  в памяти по тому
адресу. поэтому эта переменная начинает указывать хрен знает куда.
как я понимаю очень часто оно указывает нааверное например  в ту память
которая относится к heap. а как я уже сказал в heap просто так взять и чтото
записать нельзя. нужно маллок() вызывать для начала. вобщем как то ядро
знает в какие адреса виртуальной памяти можно писать (и читать конечно)
а в какие нельзя. тоесть я это вижу так.

вот мы обьявили обычную переменную

int a;

линукс себе где то там записал о том что :
зарезервирована ячейка памяти 1234 для переменной.
теперь если мы попробуем чтото записать по адресу 1234 то это будет валидно. 
ибо адрес 1234 где то там указан в его потрохах что в него писать можно. что адрес 
по которому обращаются дествительно  был ранее правильно зарезервирован

причем насколко я понимаю когда мы обьявляем простую переменую (непоинтер)
то компилятор ее АВТОМАТОМ перетирает и назначает значение 0.

показываю


unsigned short int b;
unsigned short int c;
c = b;

printf ("c=%hu\n", c);

вот я обьявил две переменные. то есть по факту теперь можно читать и писать в два 
адреса в памяти. когда я c присваваю значение b то программа не ругается.
теперь интересное - что же выведет програма на экран. если несколько раз запустит
программу то вобщем то каджый раз выскакивают разные числа! 
это значит что когда мы инициализируем переменную это фактически значит только 
то что ядро где то там себе записывает что теперь по адресу 1234 будет 
хранится переменная. НО! при этом ядро абсолютно не трогает значение по этому
адресу. вот что там лежит то и лежит. поэтому при много кратном запуске программы
там лежит то одно число то другое. инициализация переменной значит только найти
свободный адрес в памяти. и пометить себе что к этому адресу теперь можно обращаться.
а какое там значение лежит - да похеру.  внести туда начальное значение - это проблема
програмиста. у ядра дело маленькое - найти адрес ячейки свободной. 

тут еще важный момент - если писать программу хоть на с хоть на асемблере и обратиться
по рандомному адресу вирт памяти (я даже не беру физ уровень) то ядро пошлет нас нахер!
оно выдаст ошибку SIGSEGV - Signal Segment Violation. суть этой ошибки в том что с одной
стороны программа может читать по крайней мере с любого адреса вирт памяти (или почти
со всей. но будем считать что со всей). но! прежде чем это можно будет сделать нужно 
сделать спец запрос к ядру о том что вот по такому адресу я собираюсь читать 
или писать. ядро делает там себе пометку и только потом можно на тот адрес
посылать запрос на чтение запись. 

так вот я перехожу к поинтерам. и суть в том что так как механизм  
обьявеления переменной оказывается как я показал не включает в себя автоматический
механизм инициализации переменной (тоесть ядро резервирует адрес но не трогает 
то изначальное содержимое которое там есть) и так как ячейка поинтера хранит
не конечное значение а адрес по которому нужно обратится чтобы получить значение
то это приводит  к злой шутке!


вот мы обьявили поинтер

int * a;

фактически это означает что 
ядро себе пишет что добавилась ячейка памяти с адресом 5678 из которой 
можно читать и в которую можно писать. что там щас лежит изначально ядру похер.
он туда нелезет. 

далее надо различать одна команда дается чтобы записат в ячейку "a" некоторый
адрес. она выглядит вот так:
если у нас есть поинтер "a" и поинтер "b" то для того чтобы сходить в ячейку b
прочитать там адрес который там хранится и записать его в "a" надо

a = b;

если у нас есть переменная "b" которая не поинтер а обычня переменная то узнать адрес
где она хранится можно вот так &b тогда этот адрес можно записать в "a" вот так

a = &b;

записать в "a" адрес напрямую руками нельзя. можно только по моему адрес 0 туда 
записать но я не стал уже искать детали. вот так навсикдку я помню что напрямую адрес
ты хер туда запишешь.

если же мы хотим записать не адрес в "a" а мы полагаем что в "a" уже указан коректный
адрес куда можно читаь и писать то тогда записать значение уже в конечную точку можно
вот так

*a = 12;


итак стало понятно что есть две формы записи. в сам поинтер и по адресу который
хранится в поинтере.

теперь представим код

int * a;
*a = 1;

такой код вызовет SIGSEGV
потому что будует вот как -  первая строка даст то что ядро выберет в памяти адрес 5678
и пометит себе что здесь теперь чтот будет хранится. сюда можно читать и писать. окей.
что там на данный момент хранися ядру насрать. он туда не смотрит.
во второй строке мы говорим ядру - пойди по адресу 5678 прочитай там число.
а теперь пойди по адресу указанному в этмо числе и уже ТУДА запиши число 1.
ядро читает то что написано в 5678 видит там скажем 1245. окей.
далее ядро собирается записть 1 по адресу 1245 и тут оно понимает что адрес 1245
небыло к этому моменту у ядра зареервирован для операций чтения записи и ядро
шлет нахер вот так
$ ./157.exe 
Segmentation fault

поэтому в СИ получается МАЛО охуенно мало взять и обьявить переменную! хоть 
простую хоть поинтер!  в СИ нужно ее обьявить и еще обязаетелно проинициализировать!!!!
два этапа нужно обязательно! в оличие от других языков где ты обьявляешь переменную
а ядро или ктот там ее АВТОМТОМ еще и инициализирует сука!

получается самое правильное вот так !

int a;
a = 1;

int *b;
int c;
c = 1;
b = &c;


все! никких проблем с программой . никких проблем с доступом нетуда!

иногда можно  обьявление и иницализацию делать в одной строке но все равно
надо помнить что это два этапа. они отдельные. и оба обязаельные.
например 
int a = 1;

как в одной строке оьбявить и иницаилизивать поуинтер хуй знает.

поинтер сука полукчается имеет слишком много колхознхы оособенностей.
напрямую в него адрес не запихнешь.
в итоге при инициализации поинтера нужно еще обьявить и иницаилизировать обычную
перемнную! охеренеть!

спрашивается а нахрен нужен этот поинтер. а я думаю вот зачем. 

обьявлю как я две обычные переменные

int a1;
a1 = 10;

int b1;
b1 = 20;

а теперь обьявлю поинтер

int * Ptr_c1;
Ptr_c1 = &a1;



кстати на счет знака "*" хорошо что его можно лепить
как угодно. тоесть 

int* ptr
int *ptr
int * ptr

все три формы одинаковые. еще бы и тут ебала была бы. это была бы жесть!
никаких проблем





и теперь какой полезный смысл поинтера. я могу  в программе 
написать вот так

если небо сегодня синее то 
Ptr_c1 = &a1
а если небо сегодня темное то
Ptr_c1 = &b1

далее в другом куске программы я напишу 
установить значение жалюзей на окне на уровне 

jaluzi = *Ptr_c1;

все! у меня кусок которйы регулирует уровень жалюзей один и тот же что небо
синее что темное! тоест иначе мне было пришлось писать:
если небо синее то   jaluzi = a1;
или если небо темное то jaluzi = b1;

да. коенчо по факту мы все равно как бы эти две строчк запрграммировали выше. 
Ptr_c1 = &a1
Ptr_c1 = &b1
тоесьт как бы код не сократился в итоге. но это другой вопрос. 

поинтер работает как симлинк в какото степени на диске. он позволяет конечному
потребителю абстрагироваться от конкретики куда конкретно что ведет. для конечного
потребителя значение лежит в *Ptr_c1 а там хоть трава не расти. идея такая что 
на уровне нижнего конечного потребителя всегда удобнее все абстрагирорвать. 
условно говоря. есть прога на компе  у юзера или в контйенере. типа мускул.
и у него есть переменная конекшн стринг. надо чтобы это был симлинк или прокси или типа
того чтобы в случае необходимости поменять конекшн стринг мы это сделали на сервере
а у мускула это выглядит также как и было в форме поинтера. чтобы нам мускул не троагать.
не перезагружать. или условнодругой случай. 1000 контееров. везде мускул. 
у них стоит симлинк на переменную где то врнутри компа. мы меняем одну эту переменую.
а для 1000 контеенров соазу меняется симлинк. это удобно. вмиесто тгого чтобы руками
менять вкишках 1000 контйереов этот конекшн стринг.


так начало с поинтерами прояснили.
следущий момент. поинтеры это любимая хуйня в линуксе.
и с ними любят городить огромные огороды. 
вот статья
( https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const#:~:text=So%20in%20your%20question%2C%20%22int,to%20the%20thing%20after%20it. )

а вот примеры

int* ptr
int const * ptr
int * const  ptr
int const * const  

int **  ptr
int ** const ptr 
int * const *  ptr
int const **  ptr
int * const * const  ptr


const int * const ptr
const int * ptr


int const * const ptr

int *p const = ошибка 
int const int * ptr

значит для расшифровк мы используем правила:
  всегда начинаем справа и идем налево  
  самым правым всегда должно стоять имя переменной 
  если видим const значит слово левее его составляет с ним одно целое
  расшифроыать лучше сразу английскими словами 



поехали переводить примеры

int* ptr  = ("ptr") IS (a pointer_ OF (int). итак ptr это переменная поинтер. которая
ведет на адрес по которому хранится целое
проверяем на практкие
поехали
//
int * ptr_C2;
int c2;
c2 = 10;
ptr_C2 = &c2;
int c3;
c3 = 20;
ptr_C2 = &c3;
c3 = 30;

никких проблем





int const * ptr = ("ptr") IS (a constant of int) = ptr это поинтер который
указвает на константу . константа имеет тип инт. это значит что мы адрес в поинтере
менять можем. а вот значение которое хранится по адресу менять не можем. здесь 
важно помнить что если видим слово контанта то она всегда относитеся к слову 
которое левее от нее стоит. поэтому условно говоря запись аналогична
(int const) (* ptr) я имею ввиду в логическом смысле. си такое я думаю не примет.

//
int const * ptr_D2;
const int d2 = 10;
ptr_D2 = &d2;
никаких проблем

добавляем строку
*ptr_D2 = 40;
шлет нахер. гвоорить что куда мы пытаемся записть там же константа!

далее
//
int const * ptr_D2;
const int d2 = 10;
ptr_D2 = &d2;
int d3 = 30;
ptr_D2 = &d3;
никаких проблем.

добавляем строку
d3 = 40;
никких проблем

обавляем строку
*ptr_D2=30;
шлет нахер. 

это говорит о чем что если у нас поинтер указывает якобы на константу то эту константу
нельзя менять через поинтер. но по факту за поинтером может быть не костанта
а просто переменная. которую через саму переменную менять можно! ее нельзя менять
только лишь через поинтер!








int * const  ptr = (ptr) IS (a constant  pointer)  of int = птр это константа. и это
поинтер. это значит что адрес который хранится в поинтере менять нельзя. а сам
поинтер указывать на ячейку типа int.
тут мы подошли к теме констант в си.
для начала как нужно обьявлять константу простой преенной
//
const int EE1 = 10;
нет проблем
а вот так
//
const int EE1;
EE1 = 10;
пошлет нахер. напишет что мы пытаемя изменить коснтанту. охренеть!

так вот только вот так можно обьявить поинтер константу!
//
int e3 = 40;
int * const  ptr_E3 = &e3 ;

охрнететь! окей убираем ее.

добавляем строчку
e3 = 50;
нет прблем

добавялем строку
int e4 = 50;
нет пробелмем

добавляем строку
ptr_E3 = &4;
шлет нахрен. понятно.



следущий пример
int const * const ptr = (ptr) IS (constant pointer) TO (const int) = птр это константа
поинтер который указываем на констатнту int

обьявляем и инициализируем конаттсанту инт
const int f1 = 10;
нет проблем
обявлям поинтер
int const * const ptr = &f1;
нет проблем
так как это коснанта поинтер его тепер хрен изменишь. все.

делаю заново
обьявляю переменную int
int f2;
f2 = 20;
пробую ее вснууть в поинтер
int const * const F = &f2;
кхм.. прокатило.

добавляю строку 
f2 = 30;
кхм.. прокатило..


так. вобшем хватит разбирать примеры по расшифовке. 
еще раз скажу где помсмотреть как расшифровавваь сложно выглядящие поинеры= 
= ( https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const#:~:text=So%20in%20your%20question%2C%20%22int,to%20the%20thing%20after%20it. ) 

есть еще о чем поговоить про поинтеры.
вообще  в си с перемеными есть несклоко шагов ебалы.
по первых что такое переменая сточки зрения ассемблера. да там
нет такого понятия! хахаха! там просто есть команда которяа позволяет
уазать ей адрес в памяти (виртуальной но неважно) и дать команду
считать из нее в регистр либо наобро из регистра записать в память.
тут как я понима вылезает проблема в том что мы неможем просто взять и записать
в память. для начала нужно ядру обьявить что мы собираемся писать  в такую то ячейку
памяти. это делается один раз за запуск программы. ядро такое - так вот эта ячейка
будет использоваться. окей. а уже далее мы даем команду прочитай по такому то адресу.
вообще то  я не помню чтобы на ассемблере был такой порядок работы с памятью. 
так что я незнаю как они это сделали но факт остатется фактом.  при попытке порчитаь\за
писать в ячейку памяти о котоой мы до этого не анонсиролваи ядру  - нас пошлдют нахер
с ошииькой SIGSEGV. 
анонсирование ячейки это как раз таки в си так называемое "обьявление"  перееменной. 
итак во первых ячейку памяти для работы с ней нужно анонсировать. в терминах си
нужно переменную обьявить.

 int a;

второй шаг - нужно эту ячейку проинициализировать. тоесть дать ей начальное значение.
чтобы потом не было не предсказуемых последсвтий. и да да да. при обьявлении переменной
ядро не инициализирует ячейку. это наша забота. итак это уже два шага ебалы.

a = 1;

третий шаг надо понимать что в ячейку записывается байт или байты а не числа или символы.
это надо понимать. поэтому когда мы пишем в тексет программы a = 1 и потом запускаем
компилятор то он анализирует эту нашу "1" и преобразует этот символл значок
в некоторый байт ! в зависимости от типа переменной. так что никакого числа 1 в памяти
не лежит. там лежат помидоры.

есть еще четветрый этап ебалы. как нам посмртеть глазами что там в памяти лежит.
тут выходит printf. он читает БАЙТ из памяти а далее он в зависсимости от того что мы 
ему указали преобразует байт в печатные символы. поэтому один и тот же байт может быть
преобоазован в символ "число"  а может быть преобоазован в символ "буква".

так что ебалы с памятью в си хватает!


теперь про типы переенных в си - это числа, символы.  числа бывают разной длинны, со
знаком и без знака. тут открывается огроманя тема ебала. я в нее не буду угулубляться

возьмем числа. тип целое без знака (натуральное) , 16 бит. это unsigned short int.
это 0-65535 , другим словами если мы хотим сохранить и обратно прочитать число в диапазоне 
0 - 65535 то нужно юзать ubsigned short int.


unsigned int g1 = 65535;
printf ( "%hu \n" ,g1);

запускаем полкчаем на экране
$ ./157.exe 
65535 

тут открывается целое море хрени такой как например а что если я в тексте
прогарммы укажу число кторое выходит за диапазон. я ответче - что комплиятор
это сожрет. и програма отарботает

unsigned int g1 = 65536;
printf ( "%hu \n" ,g1);
$ ./157.exe 
0

а что если я засунун число с минусом оно же вылаезает за дипаазон.
отвеачаюю. комплиято сожрет. ипрогамма отарбтатет.

unsigned int g1 = -20;
printf ( "%hu \n" ,g1);
$ ./157.exe 
65516 

откуда эти цифра. почему эти цифры. почему компилятор пропускает такой текст
а не выдает ошибку. это огромнпя и мудотная тема. иди в папку "modulus" там о
огромная портяна на тему модульной математики.
кратно скажу так когда комплиятор видит строку
    unsigned int g1 = -20;
то конечно он понимает что число -20 оно никак  к 0-656535 не относится. 
компилятор преобзаует это число вдругое число коорое лежит в дипазоне разрешенном.
птом преобооазует его  в байт (16бит) и  сует его в память. и нет прблем.
а принтф раотате так 
printf ( "%hu \n" ,g1);
я говорю - прочитай из памяти байт котоырй хранится в ячйке g1. он его читает. 
а дальше я говорю ему. интерпретиуруй этот байт как тип unsigned short int ( это через %hu за
дано). тогда принтф понимает что считанный байт это число в диапазоне 0-65535. он 
байт преобразует в число. и потом подбирает печатный символы соовсветавущие этому числу.
и пеатает  
65516 
тема огроманя мудотаня.  я ее раскраывать не буду. все написано в папке "modulus".

так я вовращаюсь к поинтерам. как его совать в принтф. а вот так *Ptr_C
и нужно в принтф указать на какой типа данных указыает поинтер. и нет проблем.
тоесть


unsigned short int h1;
h1 = 10;
unsigned short int * ptr_H1;
ptr_H1 = &h1;

printf ( "H1 = %hu \n"   ,*ptr_H1);


$ ./157.exe 
H1 = 10 

тоеть  я создал простую переменную h1 типа int.
потмо я создал на нее поинтер.
в принтф я подсунул поинтер. как *ptr_H1
если бы я засунул в принтф ptr_H1 то это бы означало что нужно прочитать не то куда 
указывает поинтер а прочитать сам адрес в поинтере. 
и я указал принтф что то куда указывает поинтер имеет интерпретировать как тип данных 
unsigned short int через %hu

кстати я выше скаазал что копилятор позволяет делать дурацикие фортеля.
в тексте программы присвивть переменным числа которые вылаезают из разерещенного
диапазона. а что если поробвать засунуть в переменную буквы в которой мы 
обьявили что хотим хранить " числа". может и тут компилято сожрет гавно?

//
unsigned short int h2;
h2 = ab;
h2 = "ab";
h2 = 'ab';

во всех этих случая комплиятор пошлет нахер. 
не то чтобы он был в шоке. но он не очень понимает в какой байт преобоазовать 
эти печатные символы. толи мы хотим кажду букву чтобы он преоброзовал в байт в ASCII 
кодировке или что. ну что уже неплохо.
это вроде бы мелочь но щас она нам пригодится.
а вот в таком вариенте он сожрет
h2 = 'a';
показываю
//
unsigned short int h4;
h4 = 'a';
printf (" h4 = %hi    \n",  h4);

$ ./157.exe
h4 = 97    


значит что эта вся хрень значит. насколько я понимаю когда мы в тексте программы
пишем 'a' это просто напросто форма записи байта. точно также как есть hex форма 0x15
записи байта или OCT форма записи 075 (нооль перед числом означает что это octal)

h4 = 0x15;
printf (" h4 = %hx    \n",  h4);
h4 = 016;
printf (" h4 = %ho    \n",  h4);

$ ./157.exe
 h4 = 15    <== засунули 15 в hex ,  вытащили обратно и распечатали в hex
 h4 = 16    <== засунули 16 в oct , вытащили и распечатали в oct


тесть когда мы пишем
h4 = 'a'
это говриить комплиятору помори в таблицу ASCII найди там символ 'a' найди какой ему
ссоотвествует число и пеерведи его в байтовую форму и вот этот байт засунуть в эту
ячейку памяти. птому что какя бы ни была переенная в памяти она лежит в форме байтов!
когда мы пишем
h4 = 2 
то компиляиор работает похожим образом он берет символ 2. пеерводит его в своей голове
в число 2. число 2 переводит в байт. тоест 2 в двоичную форму. и это сует в память.

кода мы пишем 
h4 = 'a'
то чуть подлинее. он смоотрит в таблицу ascii  види что для символа 'a' сооствтует число 
dec 97. тоесть считай что мы записали 
h4 = 97 
 адальше все как сказал. перводит число 97 в двоичную байтовую форму и сует в память. 
 (так все сложнее если число вылезает за диапазон. модульная арифестика смотри папку "modulus"
 щас не будут это все расписывать. потому что эо то пиздец)

 едтиснвтенное что непонятно это то что форма 'a' позволяет кодирвать всего 1 байт.
 а если у нас переменная такая как int имет длину 4 байта. как в нее записать 4 байта
 через 'a' ? 
поэтому 'a' это считай такая форма записи в байта в ASCII форме обозначения
так вот такую форму записи байта можно скормить любому типа даннных в СИ. 
по крайней мере всем форматам типа INT.(signed, unsogned, short, long, char, итп)



идем дальше.
есть другой тип данных который  тоже число . оно целое. натуральное. тоесть без знака
имеет длину 8 бит. называется  unsigned char диапазон 0-255


//
unsigned char h3;
h3 = 10;
printf ( "h3 = %hhu \n",  h3);

$ ./157.exe
h3 = 10 


еще раз подчеркну про этот тип  данных что это ЧИСЛА. длинна у
него 1 байт. он отсноится  к подклассу классса INT. поэтому тоже можно пркаррасно
указать комплиятору какой байто засунуть в эту ячейку через ASCII формат записи байта.
тем более что у нас теперь все классно совпало. у нас и ячейкеа длинной 1 байт. 
и кодировка ASCII нам позоволяет указать толко 1 байт. отлично!


//
unsigned char h3;
h3 = 'a';                          <=========== !!!!!
printf ( "h3 = %hhu \n",  h3);

$ ./157.exe
h3 = 97 

соотвтевенно комплиятор види 'a' он пониаает  - ага да тут байт закодирован .
он лезет в ascii . нахоит что ему соовтутует число 97. он его кодирует в байт и сует
в память. когда делаем принтф обраный проецесс. принтф считывает байт.
мы ему говорим интерпретирууй байт как десятичное число в двойичной записи 
и он его инерптриует в 97. а потом их на экране рисует символами. 

получаетс очень смешная вещь. у нас char или int это классы переенных которые конечно
в памяти ниакие не числа а байты. но с друной стороны это тип переменных который как бэ
хранит числа целые. но вот можно на стадии инициализации им подсовываь числа зашифрованные
дикрвинным способом - через ascii кодировку. смешно.


далее
рассмотрим массивы.
массив это множество или куча элементов одного типа

как его обьявить 

//
int i[2];

число в скобках означает сколько элементов есть в массиве.
в данном случае их два. 
номер первого элемента начинатеся  с нуля.  
значит в нашем случае инндексы будут 0, 1. 
есть частный случай массива  - это когда элементы имеют тип char
и последний элемент в массиве обязательно ноль байт 0x00 
причем этот ноль байт мы должны сами незабыть указать и такой массив
называется string. но об этом  я расскажу ниже, а пока важно знать
что в обычном массиве на конце нет никакого ноль байта.


и вот как инициализировать
i[0] = 1;
i[1] = 2;

можно инициализировать еще вот так

int j[ 2 ] = { 2, 3 };

видим что в скобках стоит [ 2 ] и справа у нас два элемента.



как напечаатать элемент
printf ( "i[0] = %hu \n"   , i[0]    );


$ ./157.exe
i[0] = 1 

распечатать весь массив командой принтф не получится. нужно создавать цикл
и печатать по однму элементу. об этом ниже.

к сожалению весь массив можно задать за один раз только при инициализации.
а потом такое уже нельзя сделать. пример
 int a[ 3 ] = { 1, 2, 3}
если после этого мы передумали и хотим полностью поменять весь массив
за одну строку то хер получится
a [ 3 ] = { 1, 2, 3}
это вызовет ошибку. потому что слева стоит элемент массива а с индексом три.
а справа стоит массив целиком.
a = {1, 2, 3}
тоже будет ошииббка


если мы обяялвем массив но не иницилизируем в одной строке то размер 
массив указать обязаелно
char l[  ];
вот так выдаст ошибку

а если мы обяялвем + иницаилизруем в одной строке то можно размер не указывать
char l[  ] = { -1, 2, -3};
вот так прокатит




далее надо сказать сама переменная типа массив i[] представляет внутри машины поинтер
на первый элемент массива. 
на практике это значит что для того чтобы сделать поинтер на массив это делается вот так
//
int d34[] = { 1, 2, 3 };
int * prt_d43 = d34;
обрати внимание что стоит справа после "=" во второй строке. там 
стоит d34. то есть не &d34 а d34. потому что переменная которая обозначает массив
является поинтером. поэтому поинтер напрямую приравнивается к поинтеру!




а теперь рассмотрим такой массив

char k[4];


получается это множество элементов типа char. тоест каждый эемент имеет в длинну
1 байт. и когда мы каждый элемент инициализируем то компилятор в ответ на то что 
мы ему подсунем будет это конвертирвать в число в диапазоне [-128, 127]
конвертироват это в байт. и совать это в память. 
фишка опять же в том что мы можем задавать в тексте программы на стади инициализаци
элементы через четыре формы:
  обычная форма в виде числа
  oct форма
  hex форма
  ascii форма


k[0] = -1;
k[1] = 02;
k[2] = 0x7;
k[3] = 'a';

печаатаю

printf ( "k[0] = %hhi \n"   , k[0]    );
printf ( "k[1] = %#hho \n"   , k[1]    );
printf ( "k[2] = %hhX \n"   , k[2]    );
printf ( "k[3] = %hhu \n"   , k[3]    );


$ ./157.exe 
k[0] = -1 
k[1] = 02 
k[2] = 7 
k[3] = 97 

можно заметить что ровно те хрени которые мы ввели в тесксте программы
именно их и напечтало в итоге на экране.
суть сей магии в том что внутри компе нет чисел или символов там байты. поэтому 
одна задача это обьяснить комьютеру на стадии ввода данных тоесть через текс прогаммы
какие байты мы хотми внутрь засунуть. байты можно кодирват по разному.
вот я показал 4 способа. 

k[0] = -1;
k[1] = 02;
k[2] = 0x7;
k[3] = 'a';

и потом обратная задача когда мы считывали байт из памяти то как его интерпетировать.
это что ? число? символ? что это?  эта задаа выполняется через 
модификаторы принтф  %#hho 
модфиикаторы принтф это отдельная мудацкая огроманая тема. я ее раскрыать щас не буду.

а вот еще можно иницаиализировать массив вот так.
но замеч только инциализировать . потом уже такой трлюк для изменеия зачения не 
раотает
char n[ 4 ] =  { -1, 02, 0x7, 'a'    };

а теперь рассмотрим такой пример

char n[ 5 ] =  { 'v', 'a', 's', 'y', 'a'    };

значит вот они ASCII коды для этих букв

v = 0x76
a = 0x61
s = 0x73
y = 0x79

проверим что имено эти байты комп засунул в память


//
unsigned char p[ 5 ] =  { 'v', 'a', 's', 'y', 'a'    };
for (   unsigned char t1=0;     t1<(  sizeof(p) / sizeof(p[0])  );      t1++) {
   printf ( "p[%hhu] = %hhX \n"   , t1,p[t1] );
}


./157.exe
p[0] = 76 
p[1] = 61 
p[2] = 73 
p[3] = 79 
p[4] = 61 

как видно в памяти лежат в точности те байты кооторые я заказал
заавно то что соглано интеренту никак нельзя чтобы принтф сам распечаатал массив.
нужно именно тколько через цикл. и без цикла никак. жаль
( цикл нашел тут https://stackoverflow.com/questions/8442729/is-there-a-way-to-have-printf-properly-print-out-an-array-of-floats-say)

а теперь я распечаатаю эти же байты но не в форме байтов а интерпетироьванные
в ASCII символами!

for (   unsigned char t1=0;     t1<(  sizeof(p) / sizeof(p[0])  );      t1++) {
   printf ( "p[%hhu] = %c \n"   , t1,p[t1] );
}

$ ./157.exe
p[0] = v 
p[1] = a 
p[2] = s 
p[3] = y 
p[4] = a 

полчается я нашел способ "совать" внутрь массива компа буквы хотя по факту там 
байты. и обратно считывая байты превраащать их в буквы!

а теперь в одну строчку
for (   unsigned char t1=0;     t1<(  sizeof(p) / sizeof(p[0])  );      t1++) {
   printf ( "%c"   , p[t1] );
}
printf ( "\n" );

$ ./157.exe
vasya


НО ЭТО ЕЩЕ НЕ ВСЕ, оказывается что массив можно иницилизировать еще 
одним способом

unsigned char q[ 6 ] =  "petya";

"petya" эта хрень когда ее видит компилятор воспринимается им как string. 
string это всего навсего абревиатура чегото уже нам знамого но с небольшой
модификацией. string это массив из char элементов у которого на конце обязательно
еще есть нулевой байт в качестве элемента 0x00 
тоесть как я понимаю когда комплилятор видит в тексте запись вида
"petya" то он воспринимает как бутто там написано вот такое

{  'p', 'e', 't', 'y', 'a', 0x00 };

тоесть наща запись вида 

    unsigned char q[ 6 ] =  "petya";
ее полный эквивлаент
    unsigned char q[ 6 ] =  {  'p', 'e', 't', 'y', 'a', 0x00 };

просто это такая удобнаяха. ну конечно удобнее написать "petya"
что вот эту портянку  {  'p', 'e', 't', 'y', 'a', 0x00 };
ВАЖНО заметить что размер массива 6. тоеть элемент 0x00 тоже входит в состав размера
массива.




печатаем

for (   unsigned char t1=0;     t1<(  sizeof(q) / sizeof(q[0])  );      t1++) {
   printf ( "q[%hhu] = %c \n"   , t1,q[t1] );
}
for (   unsigned char t1=0;     t1<(  sizeof(q) / sizeof(q[0])  );      t1++) {
   printf ( "%c"   , q[t1] );
}
printf ( "\n" );


$ ./157.exe
q[0] = p 
q[1] = e 
q[2] = t 
q[3] = y 
q[4] = a 
petya


пробуем модифицироват один элемент
q[0] = 'm';
for (   unsigned char t1=0;     t1<(  sizeof(q) / sizeof(q[0])  );      t1++) {
   printf ( "%c"   , q[t1] );
}
printf ( "\n" );


$ ./157.exe
metya



получется string это такой субкласс массивов!


сразу замечу что такая хрень уже с массивом  из элементов int непрокаытывает!
    unsigned short int r[ 6 ] =  "kolya";
выдаст ошибку.

а вот такое прокатывает 
//
unsigned short int r3[ 6 ] =  { 'k', 'o', 'l', 'y', 'a', 0x00 } ;

это мне соверешенно однозначно доказыает что "petya"
это для компилятора массив из CHAR элементов поэтому конечно их не записать 
в массив из INT элементов. 
когда мы пишем 
    "petya"
это значит массив из 6-и элементов кадый из который 1 байт размер. итого 7 байт
условно.
а вот эта запись
    unsigned short int r3[ 6 ] =  { 'k', 'o', 'l', 'y', 'a', 0x00 } ;
ну понятно что справа у меня идут однобайтовые члены. но видимо компиялятор
автоматом переделывает каждй однобайтовй элемент в двухбайтовый?


далее вот интересно
у принтф есть интереный модификатор %s
он исползуется для поинтер переменной вот такой  const char * что эквивалент
char const * тоесть переменная поинтер котоый указывает на ячейку типа char
и еще эта ячейка константа тоемть
    (ptr) -----> (const char)
более того принтф ожидает что на том конце не просто какойто там одиночный сраный char
элемент. а что на том конце массив из char элементов который заканчивается ноль байтом
тоесть 0x00 
так вот если это так то фишка втом что тогда принтф читает такой массив одной командой
за один раз! и ненунжен цикл for. и он все это печаатает на экране в форме ascii
символов. а конец массива он находит по ноль байту!
класс проверим


//
unsigned char u[ 6 ] = { 'v', 'o', 'r', 'o', 'n', 0x0 }; 
char const * ptr_u = u;
printf ("%s\n", ptr_u);
printf ("==========================\n");

$ ./157.exe
voron
сработало!
что в этом коде интересно. а интересно дохера.
во первых в принтф - указываем именно поинтер тоесть адрес. тоесть ptr_u
а не *ptr_u
во вторых в строке обьявлением ptr справа после "=" ставим просто u а не &u
потому что мы ссылаемся на массив а имя массива это уже переменная типа поинтер.
в третьих что размер массива 6 потому что 5 букв и ноль байт. 
в четвертых что этот пример доказыает что 
форма записи 
    { 'v', 'o', 'r', 'o', 'n', 0x0 };
и 
    "voron"
это для комплияотора одно и тоже !
в пятых что еще удивительно что при обьявлении ptr мы говорим что он указывает
на ячейку типа char(а значит signed char) но более того она еще и константа! а в итоге
я ему подсовываю ячейку типа unsigned char и она не константа! но ptr все равно
спокойно это хавает ! это как !?!?!?

я проверил 
    char a;
это сокращеный экивлваент
    signed char a;
тоесть на самом деле более коректный пример это вот так

//
char const v[ 6 ] = { 'v', 'o', 'r', 'o', 'n', 0x0 }; 
char const * ptr_v = v;
printf ("%s\n", ptr_v);
printf ("==========================\n");


тоесть я реально создал char const и на него уже сделал ссылку птр.
причем заметь я const именно правее поставил от char потому что  я говорил что более
козырно когда const стоит слева от того к чему он относится.

а теперь я покажу  полный эквивалент
//
char const w[ 6 ] = "voron";
char const * ptr_w = w;
printf ("%s\n", ptr_w);
printf ("==========================\n");


тоесть я заменил 
    { 'v', 'o', 'r', 'o', 'n', 0x0 };
на
    "voron"

а теперь я сделаю еще короче
//
char const * ptr_w2 = "voron";
printf ("%s\n", ptr_w2);
printf ("==========================\n");

такая форма самая конечно непонятная если нихрена не понимать. но да 
самая короткая. здесь получется мы имеем редчайший случай состояшй в том что 
мы инициализируем ptr но в явном виде мы не создали char массив! за нас его создал 
сам комприлятор. по мне на самом деле это придурошная фича. лучше бы было 
чтобы нужно было в явном виде создавать массив char давать ему имя и в явном
виде приравнивать поинтер  прикручивать к этому массиву ! это было бы явно и стройно!


теперь следущий важный момент.
так как стринг
    "ventilyator";
это всего навсего другая форма записи массива из char(тоесть signed char) элементов и плюс полсдений элемент этого массива обязательно ноль байт 0x00 тоесть
    { 'v', 'e', 'n', 't', 'i', 'l', 'y', 'a', 't', 'o', 'r', 0x00 };
то присваивать эту "ventilyator" хрень мы спокойно можем вот к какому типу
переенной char w3[], тоесть
    char w3[] = "ventilyator";
и это коректно
соотвевтенно char w3[] это массив из char элементов. 
а раз это массив то мы можем в нем менять все элементы если хотим. 
как я уже сказал когда мы создали этот "спец" массив. то мы можем создать
уже поинтер который бы на него указывал.

char * ptr_w3 = w3;

итак
//
char w3[] = "ventilyator";
char * ptr_w3 = w3;
так вот компилятор видимо для супер ленивых дебилов 
позволяет этот процесс сократить до 

//
char * ptr_w4 = "ventilyator";
тоесть компилятор сам создаст автоатом char массив и привяежет его первый 
элемент к поинтеру. хотя по мне это пиздец как некрасиво. неявно и замучивает мозг.

так вот книжках пишут что последняя моя формула она может быть не такой
а только другой а именно

//
char const * ptr_w4 = "ventilyator";
тоесть что автоинициализация стрином может только если поинтер указыает
на char массив который ко всему прочему константа. так вот это полная хуйня!
необязаотельно поинтеру указывать на константу! и без константы тоже работает
как я показалл в предыдущем примере!
тоесть работют оба варианта
    char * ptr_w4 = "ventilyator";
и
    char const * ptr_w4 = "ventilyator";
оба работают!

ровно также как работают оба варианта
    char w3[] = "ventilyator";
и 
    char const w3[] = "ventilyator";
оба тоже работают!
просто если мы знаем что мы этот массив менять не будем то конечно
его лучше сделать константой! поому что он тогда будет записать в область
памяти rodata и значит в области памяти data будет больше места. а это классно!
птому что констнт обычно мало и там памяти дохрена пропадает. а пеерменных обычных
гораздо больше! поэтому конечно если можно надо все совать в область коснтант!
ну и второй момент что как я сказал что printf его свич %s ожидает что
поинтер который мы ему подсунем он все таки имеет тип 
    char const *
хотя я проверил все отлично работает если ему подсунуть вот такой
    char * 


теперь переходим к вишне не торте. 
вот мы говорили о поинтере. а можно еще иметь массив из поинтеров. дейсвтиельно
почему бы поинтеры не собрать в кучу  и не создать из них множество. 
пример
//
int a20 = 1;
int a21 = 2;
int a22 = 3;
int * ptr_a20a [ 3 ] = { &a20, &a21, &a22 };


распечатаем массив
for (   unsigned char t1=0;     t1<(  sizeof(ptr_a20a) / sizeof(ptr_a20a[0])  );      t1++) {
   printf ( "ptr_a20a[%hhu] = %i\n"   , t1, *ptr_a20a[t1] );
}
printf ("==========================\n");


$ ./157.exe
ptr_a20a[0] = 1
ptr_a20a[1] = 2
ptr_a20a[2] = 3


и как пишут чаще всего массив поинтеров собирают (создают) чтобы он вел на кучу стрингов.
нука давай такое сделаем!


//
char const bb1[] = "mama";
char const bb2[] = "mila";
char const bb3[] = "ramu";
char const  * ptr_bb [ 3 ] = { bb1, bb2, bb3 };

for (   unsigned char t1=0;     t1<(  sizeof(ptr_bb) / sizeof(ptr_bb[0])  );      t1++) {
   printf ( "ptr_bb[%hhu] = %s\n"   , t1, ptr_bb[t1] );
}
printf ("==========================\n");



так первые три строки все понятно. в каждой мы создаем массив множество
из элементов типа char плюс там еще в конце идет ноль байт 0x00
и  у нас этот массив является констатой тоест его нельзя менять он хранистя в области
памти rodata.
четвертая строчка слева написано что мы создаем не просто одиночный поинтер 
ведуший на ячейку с типом char которая лежит  в области rodata а что мы создаем
массив из таких поинтеров. тоесть ptr_bb это поинтер который ведет на первый элемент
этого массива. итак мы хотим создать множесво каждый элемент котрго в себе содержит
в своем занчении адрес где хранися char ячкейка, поэтому справа когда я начиаю набивать этот
массив или иницализировать то я туда пишу bb1 потому что он уже как раз таки в себе 
и содержит адрес ячейку где хранится char элемент. тоже самое bb2 и bb3.
далее поскольку ptr_bb это переменная которая заадает имя массива то я ее и пихаю 
в for без измннений.
далее идем в printf. 
и тут для поимания я хочу кое что добавить если у нас есть запись
    int * ptr
то это переводим как ptr это поинтер ведущий на ячейку char
а если у нас
    int * ptr [3]
то по мне это читается так ptr это имя массива который состоит из поинтеров каждый
из которых ведет на ячейку char
тоесть важно отметиь что в первом случае ptr это поинтер, а во втором случае это не поинтер
это ИМЯ МАССИВА. это важно! потому что тогда у нас есть разница
    ptr[1]
и 
    *ptr[1]
в первом случае это мы переходим к поинтеру в множестве и считываем из него адрес. тоесть
мы получем адрес. тоесть ptr[1]  это по сути поинтер. то есть значение будет адрес
а второй случай это берем поинтер из множества, берем адрес кооторый у него записан
и идем по тому адресу и читаем что там лежит!
поэтому я возвращаюсь к примеру и строке с принтф
    printf ( "ptr_bb[%hhu] = %s\n"   , t1, ptr_bb[t1] );
у нас %s требует чтобы мы предоставили поинтер. тоесть адрес. а он уже сам 
слазиит по тому адресу и считает оттуда стринг. поэтому 
я юзаю ptr_bb[t1] а не *ptr_bb[t1]
офигеть..


можно наш пример укоротить. 
будет менее понятно как оно рабтает но будет короче код
//
char const  * ptr_bc [ 3 ] = { "klara", "u" , "karla" };

for (   unsigned char t1=0;     t1<(  sizeof(ptr_bc) / sizeof(ptr_bc[0])  );      t1++) {
   printf ( "ptr_bc[%hhu] = %s\n"   , t1, ptr_bc[t1] );
}
printf ("==========================\n");


$ ./157.exe
ptr_bc[0] = klara
ptr_bc[1] = u
ptr_bc[2] = karla






и ТЕПЕРЬ НАКОНЕЦ  подошли  к тому ради чего все это было обучение наверху.
EXECVE
есть сисколл execve

#include <unistd.h>
int execve(const char *filename,   char *const argv[],   char *const envp[]);


кстати чтобы он заработал нужно
    соотвесвтенно надо понять что в него пихать

const char *filename - (filename) IS (pointer) OF (const char) = тоесть нужно предоставить
поинтер который указвывает на константу которая по своему типа это char, и как 
я догадываюсь это не просто const char а это string.  


char *const argv[] = argv это массив поинтеров. argv имя этого массива.(множесва).
итак это множество поинтеров. причем каждый поинтер это константа и 
поинтер указывает на string.

char *const envp[] = тоже самое. envp это имя массива. это массив поинтеров.
каждый поинтер это константа и указывает на string. 

надо заметить что первый аргумент это поинтер который указывает на константу.
а второй и третий аргумент массивы поинтеров. и они указыавют не на константы
но сами поинтеры константы.


string это массив состойщий из элементов CHAR плюс полсдений элемент это ноль байт.
и еще этот массив это константа он лежит в rodata оболасти памяти.


в итоге программа 158.exe которая форкает себя. и запускает 155.exe
через execve и передает ей пару переменных через env. далее она сидит и
ждет через wait(),
а 155 печатает на экране что ей прилетело через arg и env и выходит.
тогда 158 выходит из wait() и тоже выходит.



//////////////////////////////////////////
$ cat 158.c
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <locale.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


int main(int argc, char *argv[], char *envp[])
{

char const path[] = "./C/155.exe";
char const * ptr_path = path;

char arg1[8] = "155.exe";
char * const ptr_arg[] = { arg1, NULL };


char env1[22] = "VAR1=12";
char env2[22] = "VAR2=folder";
char * const ptr_env[] = { env1, env2, NULL };


      pid_t pid = -1;
      pid = fork();

        if (pid == -1)
        {
           printf("ERROR: fork() is failed\n");
           exit(1);
           } 

        else if (pid == 0)
        {
              int ret_c = -1;
              ret_c =  execve(ptr_path, ptr_arg,  ptr_env);
     
                if (ret_c == -1)
                {
                    printf ("ERROR: execve() is FAILED\n" );
                    exit(1);
                    } 


           exit(0);
            }


        else if (pid > 0)
        {
          pid_t pid_p = getpid();
          printf("parent: parent PID=%d...\n", pid_p);
          printf("parent: child PID=%d...\n", pid);

          int wstatus = -1;
          int ret_c = -1;
          ret_c = wait(&wstatus);

          if ( ret_c == -1 )
          {

               if ( WIFEXITED(wstatus) )
               {
                 int exit_status = WEXITSTATUS(wstatus);        
                 printf("Exit status of the child was %d\n",  exit_status);
                                     }

           exit(2);
                  }

          else 
            printf ("notice: the child process has exited successfully.\n");
       


          exit(0);
                }


exit (0);



}
////////////////////////






//////////////////////////
$ cat 155.c
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <locale.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

int main(int argc, char *argv[], char *envp[])
{



unsigned int i=0;
while(argv[i]) {
  printf("argv: $%u=%s\n", i, argv[i]);
  i++;
};

printf ("----------\n");

i=0;
while(envp[i]) {
  printf("envp: $%u=%s\n", i, envp[i]);
  i++;
};

printf ("----------\n");



pid_t p;
p=getpid();
printf ("155.exe : pid=%u\n", p);


exit (0);



}
/////////////////////////////


$ gcc -o 155.exe 155.c
$ gcc -o 158.exe 158.c
$ ./158.exe
parent: parent PID=545826...
parent: child PID=545827...
argv: $0=155.exe
----------
envp: $0=VAR1=12
envp: $1=VAR2=folder
----------
155.exe : pid=545827
notice: the child process has exited successfully.




проанализирую 158.c и 155.c
в 158.c 
меня удивило что массивы поинтеров arg и env которые подготавливаются
для execve им нужно на конце добавить NULL или ноль байт. 
если этого не сделать то execve при передаче arg в итоге передает массив
являющийся суммой arg+env и тогда вместе с аргументами в строку аргументов подсталвяются
и переменные окружения. если же добавит ноль байт 0x00 (NULL) то тогда все четко =>
execve в аргументе там где arg подставляется передает именно arg,
там где env подставляется передает именно env. иначе говорю если NULL не подставить
то в arg передается сумма arg и env.


char * const ptr_arg[] = { arg1, NULL };
char * const ptr_env[] = { env1, env2, NULL };

я еще вернус  этому вопросу ниже

далее

char const path[] = "./C/155.exe";
char const * ptr_path = path;

первой строчкой я создаю CHAR массив path[]( который еще и константа тоесть его нельзя
поменять ) в скобочках не ставлю размер, пусть
компилятор сам определяет размер.  справа стоит string. который как раз является
CHAR массивом у которого на конце еще есть NULL 0x00 баайт тоесть
    "./C/155.exe" это экивлваентно 
    { '.',  '/',   'C',   '/',   '1',  '5',  '5',  '.',   'e',  'x',  'e',   0x00 }

тоесть первая строчка экивалента
char const path[ 12 ] =  { '.',  '/',   'C',   '/',   '1',  '5',  '5',  '.',   'e',  'x',  'e',   0x00 }

замечу что NULL байт он тоже должен входить в размер 12 массива

во второй строчке  я делаю птр поинт(ptr_path) на массив path[](который еще и константа) из первой строчки.
фишка констант в том что они сохраняются в спец блоке памяти rodata у процесса
этот поинт ptr_path он нужен будет как первый аргумент при вызове execve.
скажу что такое переменная обозначающая массив. по  факту  внутри программы си
это  поинтер на первый элемент массива. 

далее я задумался над так называемыми массивами в си. хранится ли в памяти размер 
массива вместа с массивом или нет. вроде бы это элементарная хуйня которую 
походу они не сделали или сделали плохо. далее я наткнуся на эту тему - 
-  https://softwareengineering.stackexchange.com/questions/237286/why-do-c-arrays-not-keep-track-of-their-length

правда читать ее очень трудно все как куры квохчут и нахваливают как охуенно придумано
не сохранять размер массива вместе с масссивом. и как это совершенно не возожмно 
сделать. по моему это полнейшая хуйня.  нехватило у меня сил сидеть и читаь этих кур.
я так и не понял хранит ли си вместе с массивом и его длинну или нет. но точно
известно вот что :
    если мы в главном теле программы где мы обьявляем и иницаилизируем массив
    мы вызовем sizeof и натравим на массив то  он размер массива определит
    что наводит меня на мысль что все таки рзамер массива вроде бы где то хранится.
    также точно известно вот что - когда мы в качесте аргумента передаем массив
    в функцию - то в функцию передается поинтер на первый элемент массива, 
    и точно известно что функция никак не может опрееделить длинну массива.
    и если изнутри функции натраватмь sizeof на массив то он нихрена не определит.
    из прочитанного я пришел к выводу что вот что присходит когда мы обьявляем
    и инициализируем массив - компилятор определяет какой размер у массива,
    и выделяет в памяти непрервыный кусок такого размера. после этого компилятор сует туда значения элементов массива, после этого создается поинтер на первый элемент массива.
    и размер массива где то там теряется. и у нас от массива в кишках программы
    остается толко поинтер на первый элемент. теперь  весь наш массив с точки 
    зрения си это поинтер на первый элемент. а какой размер у массива хуй знает
    это програмист доожен был где то на бумажке записать. насолкьо я понимаю
    если мы в программе попробуем считать элмент массива которого на самом 
    деле нет (скажем вместо 10-го мы пробуем 11-ый) то у нас будет со стороны 
    ядра ошибка SIGSEGV - типа хуйле ты лезешь туда куда до этого не заказывал.
    давайка поверим
//
int i[ 3 ] = { 1, 2, 3 };
printf (  "%i  \n", i[0]   );
printf (  "%i  \n", i[20]   );

странно. программа не выпадает в SIGSEGV. почему? мы ведь лезем в те ячейки
памяти которые мы до этого не обьявляли?

еще раз как работает компилятор си. мы ему говорим создай нам вот такой масив
    int i[ 3 ] = { 1, 2, 3 };
он говорит окей. он выделаяет в памяти 3 ячейки размером int (4 байта)
туда сует элементы 1 , 2, 3. после этого он создает поинтер на первый элемент
массива и дает нам этот поинтер. это i. дальше вроде как он нигде не сохраняет 
длнуу массива полагая что програмист ее записал на бумажке (что полный ебанизм).
хотя если мы вызовем в теле main()  sizeof(i) то он как то определяет размер 
массива. как незнаю.
действииено я добаляю вот такой код
//
unsigned int b = sizeof(i);
printf (  "b = %u  \n", b   );

и он выводит что b=12 байт. дейсивиельнр 3 элемента * 4 байта = 12 байт.
тоесть все таки он где то хранит размер массива?!?!?!?!!?
Но! совершенно точно ищвестно что когда мы суем поинтер массива в функцию
как аргумент то функция уже нихуя неможет определить размер массива.
ПОЭТОМУ когда я создал массивы  в которых на конце не было NULL
и передал эти массивы как аргументы в функцию execve она не могла 
определить конец этих массивов и она их слепливала вместе!
вот эти массивы
    char * const ptr_arg[] = { arg1, NULL };
    char * const ptr_env[] = { env1, env2, NULL };

если не вставить им в хвост NULL как признак конца массива и передать в execve 
то она неможет определить конец этих массивов и начинает их слепливать вместе.
вобщем пиздец начинается. про это нигде сука ненаписано. ни  в man нигде
я это решение подсмотрел у чувака ( вот здесь https://jameshfisher.com/2017/02/05/how-do-i-use-execve-in-c/)
это пиздец

итак я еще раз хочу вернуться к строчкам

char const path[] = "./C/155.exe";
char const * ptr_path = path;


получается path это на самом деле поинтер на первый элемент массива !
то есть массивы в си это понятно что сам блок данных в памяти и как интерфейс
для связи с ним это поинтер! path это поинтер! и получается с точки зрения 
синтаксиса массив отличает то что у него есть скобочки [] при обьявлении.
без скобочек это одиночный char элемент в памяти. просто перемнная типа char

char const path[12];  <==== массив из 12-ти элементов CHAR
char const path;      просто один элемент типа  CHAR

кстати получается в принципе что когда мы обявляе "просто" переменную то это как 
бы массив у коиторого один элемент. вот и все

int a;

а дальше я хочу про эту строчку поговрить
    char const * ptr_path = path;

получается вот что - когда мы смотрим на синктсис поинтера то в целом 
мы нихуя не знаем на что он указывает - то ли на единичный элемент в памяти CHAR
то ли там целый массив сидит. вот что прикольно по мне. тоесть эта строчка будет
выгллядеть ровно также и когда у нас поинтер указывает на одиночный CHAR тоесть 
простую переменную и когда у нас "там" скрвается массив. это очень забавно. (ебануто)
хотя учитываю что одиночный элемент (ака просто переменная) это частный случай массива
у котрого один элемент и то что  при передаче в функуию размер массива не укзвается
то полуучается "все нормально". все соответсует ихней архитектуре языка.
ведь когда у нас  в функию пердается поинтер на массив то фунция по любому не знает
то ли там в массиве один элемент хоть тыща. поэтому в обоих случаях таких массивов
синтаксис поинтера будет такой же. 
то есть я бы тода синтаксис этих двух строка расшифровал бы вот так

    char const path[12] = "./C/155.exe";
    char const * ptr_path = path;

ядро  в памяти выделяет блок из 12 элеметов по 1-му байту. туда суется "./C/155.exe"
потом в область данных нашей программы возврашается поинтер на первый элемент. 
если мы кому то этот поинтер передадим то по нему невозможно определить (если специа
льно не знать) сколько же элементов CHAR скрывается за тем поинером. 1 или 1000000
спрашивается если path это уже по сути поинер то нахуй нам на него создавать еще
один поинтер? тоесть 
                                             массив
  поинтер path                  элемент1      элемент2
адрес в памяти(123)            адрес (5678)   адрес (5679)
значение (5678)                 значение '.'  значение '/'


зачем нам создавать еще один поинтер ptr_path который будет указыать на тот же 
адрес на который укзывает path? дело в том что мы при создании ptr_path
мы в него копируем адрес который записан в path, так что в path и ptr_path
по факту будут однаковый адрес записан!
и действительно он нахуй не нужен и так все работтает. тоеть в execve можно 
в качетве первого аргумнта передать path и все будет заебись.
я даже щас докажу , во первых во второй строке стоит прямой знако равенства. 
    char const * ptr_path = path;
если бы тут стояло вот так
    char const * ptr_path = &path;
то конечно была бы разница. но тут такого нет
еще щас покажу на практике

char const path[] = "./155.exe";
char const * ptr_path = path;

printf ( " path = %p\n path[0] = %p\n ptr_path = %p\n" ,   path, &path[0], ptr_path     );


./159.exe
 path     = 0x7ffca958bdce
 path[0]  = 0x7ffca958bdce
 ptr_path = 0x7ffca958bdce

поэтому массив точнее переменная массива это сраный поинтер по факту!
который указывает на адрес где сидит первый элемент массива.

а теперь покажу чтото интересное.  мы возьмем переменную. найдет ее аадрес и 
запишем в поинтер , а потом найдем адрес поинтера и запишем в другой понтер


char a = 12;
char * p_a = &a;
char * * p_p_a = &p_a;
printf ( " &a = %p\n p_a = %p\n &p_a = %p\n " , &a, p_a,  p_p_a  );


результат
 &a   = 0x7ffdfb8ded33
 p_a  = 0x7ffdfb8ded33
 &p_a = 0x7ffdfb8ded38

видно что первые две строки совпдают а третья новая. все логично.
 самая интересная вот эта строка
    char * * p_p_a = &p_a;
она позволяет найти поинте на поинтер.
замечу что символ & означает "а какой адрес у переменной?"

а теперь непонтная хуйня = я хочу найти адрес поинтера который указвает на массив
берем массив
    char const path[] = "./155.exe";
тоесть понятно что path указывает туда где лежит &path[ 0 ]
тут кстати видна синтаксическая хуета. если path это поинтер то path[0]
это "содержимое ячейки на которую указывает поинтер path"
а path[1]  это "содержимое ячейки на которую указывает поинтер плюс сдвинуться
на один елемент направо" - неарвда ли полная хуйня??
итак показыавю

char  path[] = "./155.exe";
printf ( " path = %p\n &path[0] = %p\n",  path, &path[0]     );

результат
 path = 0x7fffa2b1558e
 &path[0] = 0x7fffa2b1558e

если path это просто обычый поинтер. то конечно синтаксис path[0] это полный 
пиздец. тоесть фактически он экаивалентен *path,
тогда синтаксис path[1] эквивалентен *path+1ячейка направо. что за пиздец?
ну ладно. важно другое ожидается что &path покажет адрес где хранится
сам поинтер path но нихуя  в случае когда поинтер указывает на массив
это неработает

char  path[] = "./155.exe";
printf ( " path = %p\n &path[0] = %p\n &path = %p\n",  path, &path[0], &path     );

рзултат
 path     = 0x7fffc1bfc55e
 &path[0] = 0x7fffc1bfc55e
 &path    = 0x7fffc1bfc55e   <=== это что за пиздец?
если поинтер непросто поинтен а поинтен на массив то &path вместо
того чтобы указать где лежит сам поинтер он нам покзывает адрес первого
элемента массива что за пиздец?

и ееще дин пиздец. я пытаюсь в прграмме присовить адрес path другому поинтеру
//
char  path[] = "./155.exe";
char * * z  = &path;
printf ( " path = %p\n &path[0] = %p\n &path = %p\n",  path, &path[0], &path     );


но компилятор рисует ошику! во второй строке .говорт что левая и права часть
имеет разный тип. пиздец. а как верно написать хуй знает.
итак один из выводов - что поинтер на массив он хоть вроде и поинтер. 
но сука с особенностями непонятными. 

единсвтенная операция с ним как с поинтером у меня сработала только 
вот такая

char const * ptr_path = path;

тоесть прямое копирование его значеия в другой поинтер. 
а как определить где лежит сам этот поинтер хуй знает как это сделать



продолжаю  разбор программы 158.с и 155.c


следующий кусок

char arg1[8] = "155.exe";
char * const ptr_arg[] = { arg1, NULL };


что здесь примечаатнольно это то что тут поинтер вот какой - это массив из поинтеров.
каждый из которых это константа то есть его нельзя менять тоесть адрес который в 
нем хранится менять нельзя и указывает он на ячейку типа CHAR.
как я уже сказал кода у нас поинтер указыавет на ячейку то в си незаложена такая
вещь как то что непонятно сколько ячееек данных хранится там куда указывает поинтер.
это может быьт одна ячейка а может миллион. это незисветно. поинтер при это 
прорписывается одинаково. это единсвтенное можно увидеть только по строке
инициализации. но фишка в том что строка иницаилизации она для компидяторра. 
предназначена для стадии "изгтотовления" переменных. тоесть чтобы компилятор
все подгтовил и засунул данные в память. а вот потом на стадии исполеннея программы
нам компидлятор не дает данные как там все в памяти изгтовллено. я имею 
ввиду именно поинтеры. в первой строке создается массив из 8-ми CHAR ячеек 
и нам выдается поинтер на первый элемент. имея этот поинтер и не имя вот этой первой
строки хрен узнаешь сколько там этих элементов может 8 а может 128 000.
во второй строке изготавливется массив из двух элементов. каждый элемент это 
поинтер. первый поинтер указывает на первый элемент массива из 8-ми элементов CHAR,
второй поинтер хрен зрает на что укаызвает щас выясним.

int * ptr_a1 = NULL;
printf ( " ptr_a1 = %p\n ",  ptr_a1     );
printf ("============================\n");

резульаттот
ptr_a1 = (nil)

здесь(https://www.scaler.com/topics/null-pointer-in-c/) я прочитал что NULL поинтер
он указывает на адрес в памяти где только начинается секцяи где хранятся переменные
поэтому как бы он намекает что я "указываю на невалидный адрес в памяти поэтому
пойми что не указываю нихрена никуда". 
можно вместо NULL ставить 0 .  я все таки думаю что NULL это прям реально число 0
запиывется  в поинтер. тоесть ноль байт 0x00 прям.
и потом когда си такой поинтер видит он понимает что это намек ему на то что
поинтер указывает на какуюто хрень. тоесть вникуда. ну потому что область переменных
статических либо инмичеких она внутри вирт пространства памяти никогда не указывает 
на адрес 0. начиная с адреа 0 сидит текс программы. там никгда области данных тоесть
переенных быть неможет

int * ptr_a2 = 0;
printf ( " ptr_a2 = %p\n ",  ptr_a2     );
printf ("============================\n");

ptr_a2 = (nil)

nil означает null pointer. нахуй было его называть nil вместо null pointer непонятно!

далее я делаю вот так
int * ptr_a1 = NULL;
printf ( " ptr_a1 = %p\n " ,  ptr_a1     );
printf ("============================\n");
if (ptr_a1 == 0 )
printf ("ptr_a1 = 0\n");
if (ptr_a1 == NULL )
printf ("ptr_a1 = NULL\n");

рзудтат
ptr_a1 = 0
ptr_a1 = NULL


итак я возваращаюсь к куску

char arg1[8] = "155.exe";
char * const ptr_arg[] = { arg1, NULL };

в первой строке у нас будет поинтер который указыает на первый элемент массива CHAR
вторая сторка это массив поинтеров. каждый из которых константа то ест нельзя
менять адерс который в нем запиан. и укызает он на ячейку типа CHAR. причем по поинтеру
нихрена не узнаешь где закачивается массив. первый поинтер указывает на первый 
элемент массива CHAR элементов который мы создали в прошлой строке. второй поинтер
указывает на адрес 0. тоесть вникуда. поинтер ptr_arg пердается в execve 
как второй аргумент. и видимо в коде той функции есть проверка мол если мы натнулись
на NULL поинтер значит мы достигли конца маассива!
еще раз скажу что примечетаельно что ptr_arg это масив поинтеров



далее кусок

char env1[22] = "VAR1=12";
char env2[22] = "VAR2=folder";
char * const ptr_env[] = { env1, env2, NULL };


в первой строке мы задаем массив из CHAR символов и получаем поинтер на него
во вторй строке задачем второй аналогичнй массив.
в третьей строке мы задаем массив из поинтеров. каждый из которых константа тоест
нельзя менять адрес записанный в поинтере . ккажый поинтер указывает на CHAR элемент.
массив состоит из поинтера на первый элемент первого массива и поинтер на первый
элмент вторго масива и NULL поинтер который является признаком что массив законился.
потому что другого способа как то оьбяснить функции которой мы передадиим третий
поинтер где конец массива не придумали. что забавно нахре постоянно все делать консанто.й
это потмоу что чтобы код функции котой мы преддадим поинер не мог поменять массив.


дальше у нас запускаесят execve в который мы поставляем нащи поинтеры.
что примеичално что когда мы передаем фнукции поинтер на массив поинтеров то скобки 
использовать ненужно. тоесть вместо ptr_arg[] мы исплщуем ptr_arg

//
 ret_c =  execve(ptr_path, ptr_arg,  ptr_env);

первый аргумент это путь к бинарнику на фс, второй аргумент это список аргументов
который передается команде которая запускатся. что мне непонятно нахуя в спмске
аргументов передавать имя файла ведь оно у нас и так есть в первом параметре. непонятно.
третий аргумент это список переменных окружения. команад которая будет запущена 
просто обязана использовать спмсок арнумнентов. а вот на счет списка окружения тут 
уже по ее желениаю. она может его просто проигнорировать. 

там у нас форк делался поэтом есть парент и есть чайлд. так вот в  паренте 
вставлена wait() функция чтобы мы могли счиатт в родителе код возарвта чтобы кода 
чайлд выйдет то через найш wait() ядро могло полностью вычистить чайлда чтоы он не
висел как Z. вот этот кусок с wait()

int wstatus = -1;
          int ret_c = -1;
          ret_c = wait(&wstatus);

          if ( ret_c == -1 )
          {

               if ( WIFEXITED(wstatus) )
               {
                 int exit_status = WEXITSTATUS(wstatus);        
                 printf("Exit status of the child was %d\n",  exit_status);
                                     }

           exit(2);
                  }


в wait() написано что если чайлд выщел успешно тоест кодом возврата 0 то wait() возвратить pid чайлда , ну а если чайлд вышел не с 0 . то wait() вернет -1 это  я и проверяю.
и если чайлд вышел неуспешно то запускается хрень WIFEXITED(wstatus) которая покажет
детали неуспешного выхода.
насколько японимаю строка 
     if ( WIFEXITED(wstatus) )
это эквивлаент
     if ( WIFEXITED(wstatus) != NULL )
щас проверим как раз через NULL поинтер
//
char * ptr_a3 = "vasya";
if ( ptr_a3 )
printf ("ptr_a3 is NOT  NULL\n");


экран
ptr_a3 is NOT  NULL

да все подтевирдислось !

еще раз скажу что когда коиипиятор видит стринг "vasya" это говоии компилятору что 
нужно выделить в памяти неперрвыный кусок памяти размером  6 ячеек по 1 байту. далее
записать туда такие байты которые закодированы символами ASCII в этом стринге и доавить
на конце NULL байт тоесть ноль байт тоесть 0x00 , и поэтому если мы создаем поинтер
на этот массив то поинтер может быть только такой который в своем спеке указыает 
что он указывает на элемент типа CHAR и никак иначе! если я напишу
    int * ptr_a3 = "vasya";
то компияор пошлет нахер. потому что слева указан спец что поинтер указыает на 
элемент типа INT. а это полная хуйня. 
кстаи я считаю что создание массива через заапись 
    char * ptr_a3 = "vasya";
она более честная. более явная. чем запись
    char env1[22] = "VAR1=12";
потому что по факту у нас при сздании масссив происходиит именно то что уазано
в первой строке. тогда нахуй было городить вторую.

еще интерный момент что можно вот так еще поинтен на стринг создать
    void * ptr_a4 = "vasya";
про поинтер типа воид пока в книжке не нашел но наскоько я помню это такой 
типа "ленивый" поинтер или универсальный. тоесть понятрно что в нем как обычно
записан адрес указывающий на память. но не указан тип  данных на которые он 
укзывает. поэтому при его создании мы как бы гвооим - мы щас создади поинтер
засунем в него адрес а какой типа данных мы скажем потом когда уже начнем
кокниено эти данные считывать. потом указать рано или позно придется  так как си
надо понимать сколько байт занимат один элемент по тому адресу - 1 байт или 8 байт.

по поводу поинтеров и массивов.
так как уже понятно что переменная задающая массив это всего навсего обычный
поинтер то с ним можно и обращться как с поинтером. и в частности на основе поинтера
можно ходит и выбирать элементы массива щас покажу

char ptr_a5[] = "petya";
char q = *(ptr_a5+0);
printf ("q=%c\n", q);

экран
q=p

тоесть вот эта запись *(ptr_a5+0) она говории пойди по адресу записанному 
в поинтере ptr_a5 и сделай смещение на 0 элементов и принеси нам то что там записано.
тоесть вот это *(ptr_a5+0) эквиалветно ptr_a5[0]
по мне нахуя было придумывать вторую форму записи котоарая сука только все 
замутила. нужно было осталвять только первую форму и не ебать мозги

далее. насколько я понимаю переменная обозначающая фунцию это ТОЖЕ ВСЕГО НАВСЕГО
СРАНЫЙ ПОИНТЕР ! когда мы пишем
 int main ()
то main это всего навсего поинтер туда где начинается код функции! прикол!

на этом вобщем то все фишковые места 158.exe заканчивются!

перходим к анализу 155.c
насколько я понимаю смысл модификатора %s у принтф то ! - он подразумевает
что мы ему передадим поинтер который указывает на ячеку типа CHAR. но поскольку
имея поинтер мы никогда нихрена не знаем сколько там ячеекк данных сохранено
то принтф ожидает что там будет признак конца блока данных (массива) через 0x00 байт!
таким образом в частнсоти я хочу скзать что поинтер вот такого типа
    char *argv
в целом он нас не обязывает чтобы ячейки на коорые он указывает заканчивадись 
ноль байтом! необязывает ! ему все равно! но если мы этот поинтер будем
пихать в принтф с ключом %s то принтф это ожидает! поэтому будьте добры! а что будет
если мы не вставим нолль байт?  я думаю такое поведение не опредеелено. то есть 
мы получим проблемы!

char c1[] = { 'v', 'a', 0x00 };
char * ptr_c1 = c1;
printf ("%s\n", ptr_c1);

экран
va

убираю ноль байт
char c2[] = { 'v', 'a' };
char * ptr_c2 = c2;
printf ("%s\n", ptr_c2);
printf ("============================\n");


экран
vava

мы видим что поинтеру при создании похуй всттавили мы в массив ноль байт 
или нет. это никто не проверяет.
принтф начинает читать байты оттуда куда указал поинтер. и будет их читать пока
не встерить ноль байт. если это будет километр данных он нам прочитает километр.
единсвтенное что мне понятно почему ядро не выдает SIGSEGV. ведь мы лезем в те ячейки
которые не положено!!!

на этом анализ 155.c тоже закончен

кстати чтобы передать в функицию массив  в качестве аргумента нужно
только передать имя переменной массива а скобки при этом указываьт ненужно.
пример из книги
есть массив
    int hourlyTemperatures[ 24 ];
передаем его в функцию(испльзуем имя без скобок)
    modifyArray( hourlyTemperatures, 24 )



также что инересно . когда мы вписываем понитер при обращении к функции то ! 
значение поинтера читается из памяти и копируется в новую переменную уже внутри
функции! тоесть фукция кога начинает работать то она читает не из исходного поинтера
его значение а именно что функция main() она считывает значение поинтера - тот адорес
на который поинтер указвыает и передает этот адрес функции (видимо через стек)
а функция берет это начение из стека и копирует уже в своб локалбную переменную. тоесть
создвает свой новый поинтер  с тем адресом что ей преедали!
это мелочь но важно понимать
поэтому мы когда функцию описываем мы у нее в шапке прописыем переменные не для красоты!
    int func1(int argc, char *argv[], char *envp[])
это как раз локальные переменные которые будут созданы когда начнет работать фнукция
и в которые она из стека возьмем значения котоыре ей были переданы функцией main()!




также,
все больше прихожу к выводу что типа данных в си это всего навсего хрень
которая ему позволяет понять сколько байт нужно выделить под ячейку памяти (переменную)
скажем один байт или 4 байта. и второе что это ему дает это то что когда он 
находит строчку в тексте программы в которой идет иницлизация переменной чтобы комплитятору
понять в какой байт преобразовать те символы которые указаны в этой строке. вот и все.
потому что конечным итогом работы комлитора вляется то что в памяти в ячейке 1-8 байт
будут лежать такие то байты. там внутри нет ни знаков ни чисел ни симолов. там 
только байты. и все. тип данных позволяет сконверртрвать входные данные из 
текста прогаммы в байты. а когда обратный процесс то это принтф. он считывает эти
голыые байты и модификаторы принтф позволяют ему сконевертировать эти голые байты
в числа со знаками и без знаком большре и маленькие или в символы. внутри этого нихрена
нет. условно говоря внутри компа это склад с полками на них ящики и яблоки.
это система кодиорвания. комп берет нашу строку
  int  a = 'v'
и кладет внутри на полку 8 в ящие номер 20 четыре яблока.
  а если бы было написано условно
  unsigned char b = 'v'
то он положил бы в два ящика по 7 яблок в каждый. 
вот что дают типы переменных. 
обратный процесс. принтф считывает с двух ящиков по 7 яблок и пытается понять что ему
на основе этого нарисовать на экране. смотрит в модификатоы %0hhu условно и риусет
нам символ. а есдли у него другой модификао %c то рисует нам символ 'v'
вот зачем нужны типы данных (для ввода, для перевод текста в программе  в яблоки) и зачем нужны модификторы в принтф (для вывода, чтобы конвертирвать яблоки в симолы на экране)


ВАЖНОЕ ЗАМЕЧАНИЕ ПРО EXECVE.
напоминаю как выглядит вызов  execve

int execve(const char *filename, char *const argv[],  char *const envp[]);


первое что важно понять что все эти вызовы это всего навсего сраные ФУНКЦИИ. 
с точки зрения си это просто функции. нет никакой магии что это какойто там магическоий
и загадочный сискол. это просто обычная си функция.


так вот  я обнаружил нечто очень важное. и хочу на это щас пролить свет.
я хочу обьяснить более точно какой смысл вот этих трех аргументов которые подставляются
при вызове функции execve. 

во первых поговорим про то как вызывается и запускается функция в си. 
вот пример программы


#include <stdio.h>
#include <stdlib.h>

int square( unsigned char a );   <=== прототип функции


int  main() {                      |
                                   |
   unsigned char c1 = 9;           |
   unsigned char b1 = 0;           | <== это главный модуль main()
   b1 = square(c1);                |
   printf ("b1 = %hhu\n", b1);     |
  exit(0);                         |
}                                  |


int square (unsigned char a ) {                                       |
                                                                      |
    printf ("I am inside square function, argument a = %hhu\n", a);   |
    unsigned char sq = a * a;                                         | <== это функция square()
                                                                      |
  return(sq);                                                         |
                                                                      |
}                                                                     |


теперь что тут существенно  мы когда функцию обьявляем
    int square (unsigned char a )
мы указываем в ней НЕТОЛЬКО тип данных которые ей надо передать НО! и в ней
мы указываем ИМЯ ПЕРЕМЕННОЙ которая будем создана внутри памяти фукции когда она 
будет запущена. И В ЭТУ ПЕРЕМЕННУЮ буду скоированы те данные которые в фцнкцию передадут 
снаружи при ее запуске. это очень важно заметмть. 
итак из тела main() я вызываю запускаю функцию square и при запуске нее я ей передаю
значение переменной c1. тоесть программа прочитает значение из c1 засунет незнаю 
там куда наверное в какой нибудь стек и вызовает уже код функции square

    b1 = square(c1);

поскольку в описании функции вот так вот прописано
    int square (unsigned char a )
то когда функция square стартаент то она СОЗДАСТ переменную "a" и в нее скопирует 
из стека значение c1 котоорое там уже лежит!!! таким образом функция square еще 
нихрена несделал но у нее уже появилась переменная да еще с значением. 
такой механизм передачи данных  в функцию снаружи я называют "запуск с копированием"
потому что у нас значение c1 было прочитано кодом функции main() и засунуто в стек.
а потом фкнкция square его прочитала из стека , создала переменную новую и туда 
записала значение. кстати в коде есть строка с прототипом функции
    int square( unsigned char a );   <=== прототип функции
ее можно запиывать не указывая имя перееннной которая будет создана при запуске
функции тоесть вот так
        int square( unsigned char );
а вот уже когда мы опиываем тело функции то тут уже обязательно нужно указать 
имя переменной. 
кстати в man execve как раз указан прототип без указания имен переменных.
так самое важное что я хотел этим куском донести это то что если мы видим прототип 
фукнции и в ней сколько то аргументов то НАДО ЧЕТКО ПОНИМАТЬ ЧТО при запуске этой
функции для каждого аргумента фугкция создаст переменную. вот что важно понять.
поэтому те данные которые передаются снаружи в функцию они попадают не в космос
они попадают именно в специально созданные переменные.  и потом сидя в теле 
функции можно к этим переменным иметь доступ. и соотвесвтенно читать отттуда 
или писать. тоесть мы привыкли что переменные у функции обявлятся в теле функции
вот как например переменная 
    unsigned char sq
она обьтявлена уже  в теле функции square, она бросатеся в глаза и легко
фиксируется мозгом. а переменная "a" ее обьявления нет  в теле функции и легко
потерять в голове вот это погнимание что вообще то у этой функции еще есть одна
переменная обьявленная. просто она обьявлена не в теле фнкции а в ее заголвке
    int square (unsigned char a )
вот это надо четко осознавать!

итак когда мы сосмрим на фукнкцию

int square (unsigned char a ) {                                       
                                                                      
    printf ("I am inside square function, argument a = %hhu\n", a);   
    unsigned char sq = a * a;                                                                                                               
  return(sq);                                                         
                                                                      
}                                                                     

мы теперь понимаем что  у нее будет создано две переменные. это "a" и sq.
еще раз что я хочу донести - что если у нас указано в протттипе функции что  у нее три
аргумента

    int execve(const char *filename, char *const argv[],  char *const envp[]);

тоэто значит что при запуске этой функции у нее будет создано три переменные.
и в первую будет записано  то что прилетело в первом аргументе, во вторую перееную запишется
то что прилетело во втором аргументе и в третью переменную запишется то что прилеело
в третий аргумент! таков физ смысл этих трех полей внутри круглых скобок! тоесть как 
бы указано три переменные которые будут созданы просто их имена не уазаны. указан их тип.
и идет намек на то что при вызове этой функции ей будет надо передать три аргумента.
таков физ смысл. 
ну из деталей нужно добавить что вместо того чтобы копировать значения переменных
из одной функции в другую чреез стек можно просто передать адрес в котором лежит
значение переменной. тогда это выглядит вот так


#include <stdio.h>
#include <stdlib.h>




int square( unsigned char * );


int  main() {


   unsigned char c1 = 9;
   unsigned char * ptr_c1 = &c1;

   unsigned char b1 = 0;
   b1 = square(ptr_c1);
   printf ("b1 = %hhu\n", b1);




  exit(0);
}


int square (unsigned char * a ) {

    printf ("I am inside square function, argument a = %hhu\n", *a);
    unsigned char sq = (*a) * (*a);



  return(sq);
}



значит в теле main() мы помимо переменной c1 еще создаем на нее поинтер ptr_c1 в 
котором  хранится  адрес памяти ячейки в которой лежит c1

       unsigned char c1 = 9;
       unsigned char * ptr_c1 = &c1;

в прототиппе
    int square( unsigned char * );
как и в заголовке тела фунции
    int square (unsigned char * a )

мы указываем что при запуске функции ей надо создать новую переменую "a"
у которой тип поинтер. итак функция square при старте создаст поинтер "a"

далее мы из главного тела программы вызываем фцкнцию square
       b1 = square(ptr_c1);
и делаем мы это вот так. код программы читат значение переменной ptr_c1 
тоесть адрес который там хранится. и он это значение этот адрес копирует в стек.
далее стартует функция square и создает переменую "a" типа поинтер.
и она читает значение из стека которое там лежит . а лежит там адрес . и она
этот адрес копирует в "a".
таким образом при запуске фнкции square у нас происходит копирвание и обмен данными
через стек по прежнему. но перемещается не значение переменной а только адрес где
она лежит. в чем спраивается прикол? а прикол в том что если предавать всего
навсего одну несчатную переменную то можно и без поинтеров обойтись.
а если нам надо внутрь функции передать массив из миллиона элементов. то копировать его
было бы очень накладно. поэтому гораздо выгоднее преедать всего навсего адрес 
указвыающий на первый элемент массива что вообще копейки по накладным расходам
и вуаля у нас фнкция имеет доступ к огромадному массиву без копирования значений
его элементов!

так вот это все было к чему. я теперь взозвращась к нашей фнкции execve

    int execve(const char *filename, char *const argv[],  char *const envp[]);

у нее указано три аргумента  
    const char *filename
    char *const argv[]
    char *const envp[]

значит при старте этой функции внутри нее будет создано три переменные имен мы их
незнаем но неважно. все эти переменные будут иметь тип поинтер. это значит что через 
стек будет передано только три адреса которые в эти поинтеры и будут скопированы
а данные как лежали где то там в памяти так и они и будут лежать. 

теперь мы вспоминаем а что делает эта функция. она берет бинарник с диска. вычищает
в процессе весь код который был в нем до этого и сует код из бинарника. так вот
неважно какой там код в этом бинарнике перед тем как этот код будет запущен в любом
случае адресном пространстве этого кода будут созданы и доступны три переменные.
и в них будет содержаться в каждой тот адрес в памяти который был засунут нами
в фнукцию execve при ее вызове.  и вот этот код который был в бинарнике  и котрый
стартанет он обратившись  к этим переменным ( а он может это сделать незнаю как
он о них узнает но он узнает и он может) при желании успешно считает все что 
хранится в этих переменных !

теперь вспоминаем что функцию execve выпоняет по факту ядро. так вот 
самому ядру чтобы запустить новый бинарник важен только первый аргумент! на второй
и третий ему насрать! абсолютно ! ядру важно лишь то чтобы путь к бинарнику
указнный в первом аргументе существовал ! все! ему остальное похер  . тоесть

вот скажем я в программе приготовил эту перемнную

char const path[] = "./155.exe";
char const * ptr_path = path;

теперь чтобы программа 155.exe успешно была скопирвана в процесс и запустилась 
всего навсего надо чтобы она реально лежала по пути "./155.exe"

а второй и третий аргумент они нужны НЕ ЯДРУ ДЛЯ ЗАПУСКА 155.exe !!! 
они нужны уже самой программе 155.exe ! и то не факт! дело в том что с точки зрения
си execve это фнукция сраная функция и бльше ничего! у функции есть входные аргументы
и есть код возврта.  и больлше ничего такого! поэтму когда у нас запустится код 155.exe
то как бутто это и есть тот самый сходный код execve. 
и есть программа 155.exe (или любая другая котоую мы вызваем)
так я  к чему веду. вот мы запустили функцию с тремя аргументами. но функци не обязана
использовать ни один из скормленных ей аргументов! верно? если мы напишем функцию
у котрой указано 100 аргументов. то это не обязывает эту функцию потом их использовать.
это все на усмортрение кода фнукции! поэтому когда мы видим в strace например 
как баш используя execve запускает скажем ls

$ strace -e execve ls -1 /mnt
execve("/bin/ls", ["ls", "-1", "/mnt"], 0x7ffede862920 /* 72 vars */) = 0

то мы видим вот что 
первая переменая = "/bin/ls"
и ее использует ядро чтобы закачат код ls в тело процесса.

вторая переменная имеет вид  ["ls", "-1", "/mnt"]
тоесть это массив из трех значений  
    "ls"
    "-1"
    "/mnt"

понятно что сам массив не пихается в функцию execve . пихается поинтер. просто strace
смотрим куда указывает поинтер и показывает что там лежит. так вот ядру на этот второй
аргумент полностью насрать. ядро просто создает переменную поинтер которая указывает 
на этот массив. и запущенный ls ЕСЛИ ЗАХОЧЕТ то он эту переменную видит и может прочитать
что записано в этот массив.  А ЕСЛИ НЕ ЗАХОЧЕТ ТО ЧИТАТЬ НЕ БУДЕТ и ничего в этом плохого
нет.  третий аргумент это ссылка на массив из переменных. на нее тоже ядру насрать
при запуске ls. ядро лишь создает поинтер на этот массив и если ls захочет то он может
этот массив прчиать. а если не захочет то читать не будет. и ничего страного нет!
код ls в своей работе может пользоваться этим данными которыми ему передали 
а может абсолютно не пользоваься! вот в чем прикол! чтобы ядро могло успешно стартунуть
ls все что требуется это только верно указать первый аргумент с путем где находится
бинарник ls. тоесть первый аргумент предназначен для ядра. второй и третий ядру насрать
они предназначены уже для той программы которую мы запускаем. и она имеет свободу
она может пользоваться этими данным а может и нет!
ксати первый аргумнт он тожет будет ядром записан в переменную которая будет доступна
для кода ls и он если захочет тоже может его прочиать. 
я так долго все это рассказывал чтобы было понятно кому (ядру или новой программе) нужен
первый, второй , третий аргумент. и на  что это влияет.
исходя из этого тепрь кода понятно зачем и когда это все надо . я покажу то что
во втором аргументе первым элементом абсолютно нахрне необязательно указыать имя 
вызываемой программы! тоесть вместо вот такого массива
    ["ls", "-1", "/mnt"]
можно абсолютно спокойно предать вот такой массив
    ["blablabla", "-1", "/mnt"]
и это ни на что не повлияет. 
я сомневаюсь что код ls проверяет что указано в этом элементе. потому что он 
не несет никакой функциональной нагрузки! как бы понятно что вторйо аргумент содержит 
аргументы для новой программы чтобы она понимала чего мы от нее хотим. но меня всегда
убивало нахрена нужно первым элементом вставлять имя вызывамой программы! это не 
несет нихрена никакго функционально смысла!
это как ели бы мы в баше запускали ls вот так
    $ /bin/ls ls -1 /mnt
что за хрень!?!?!?!? мы никодга так не делает. так нахер этот лишиний ls они
пихают во второй аргумент?!?!?!!?!?!? это бессмысленно!
щас докажу

вот берем программу
//
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <locale.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


int main(int argc, char *argv[], char *envp[])
{

char const path[] = "/bin/ls";
char const * ptr_path = path;

char arg1[] = "blablablabla";
char arg2[] = "-1";
char arg3[] = "/mnt";
char * const ptr_arg[] = { arg1, arg2, arg3,NULL };


char env1[22] = "VAR1=12";
char env2[22] = "VAR2=folder";
char * const ptr_env[] = { env1, env2, NULL };


      pid_t pid = -1;
      pid = fork();

        if (pid == -1)
        {
           printf("ERROR: fork() is failed\n");
           exit(1);
           } 

        else if (pid == 0)
        {
              int ret_c = -1;
              ret_c =  execve(ptr_path, ptr_arg,  ptr_env);

                if (ret_c == -1)
                {
                    printf ("ERROR: execve() is FAILED\n" );
                    exit(1);
                    } 


           exit(0);
            }


        else if (pid > 0)
        {
          pid_t pid_p = getpid();
          printf("parent: parent PID=%d...\n", pid_p);
          printf("parent: child PID=%d...\n", pid);

          int wstatus = -1;
          int ret_c = -1;
          ret_c = wait(&wstatus);

          if ( ret_c == -1 )
          {

               if ( WIFEXITED(wstatus) )
               {
                 int exit_status = WEXITSTATUS(wstatus);        
                 printf("Exit status of the child was %d\n",  exit_status);
                                     }

           exit(2);
                  }

          else 
            printf ("notice: the child process has exited successfully.\n");
       


          exit(0);
                }


exit (0);



}
//



вот она задает первый аргумент

char const path[] = "/bin/ls";
char const * ptr_path = path;


вот она задает второй аргумент

char arg1[] = "blablablabla";
char arg2[] = "-1";
char arg3[] = "/mnt";
char * const ptr_arg[] = { arg1, arg2, arg3,NULL };


и вот как выглядит execve при запуске через strace
execve("/bin/ls", ["blablablabla", "-1", "/mnt"], 0x7fffd9353a60 /* 2 vars */) = 0

и вот как выглядит вывод ./164.exe

$ ./164.exe
parent: parent PID=1127...
parent: child PID=1128...
01
02
1.txt
ext
mirror
notice: the child process has exited successfully.

а вот как выглядит вывод ls если его через баш заупстить
$ ls -1 /mnt
01
02
1.txt
ext
mirror

тоесть моя программа успешно запустила ls. передала ей массив аргументов
в виде 
    ["blablablabla", "-1", "/mnt"]
а не в виде как это делает бащ
    ["ls", "-1", "/mnt"]

и ls на это АБСОЛЮТНО ПОХУЙ! потому что первый элемент этого маассива 
не несет нихуя никакоой полезной нагрузки! зачем его туда вообще 
вставлять абсолтно непонятно! а когда первый раз увидел в strace  я был 
в щоке нахуй оно там нужно! я думал может ядру для чегото надо. оказаось нихуя. 
просто "так принято". пц.

но это еще не конец интерсного! оказыается в /proc можно увидеть то что было 
передано в процесс на момент его запуска через второй аргумент! находится
оно в 
    /proc/pid/cmdline
вот у меня есть прога 155.exe неважно о чем она. это щас роли не играет.
я ее запускаю через bash и исползуем strace чтобы посмореть какой второй
аргумент зарядит баш

$ strace -e execve ./155.exe 123 a 456 b 789 c
execve("./155.exe", ["./155.exe", "123", "a", "456", "b", "789", "c"], 0x7ffd320eb0c0 /* 72 vars */) = 0

итак мы просили запустиь нашу прогу вот c таким набором параметров
    123 a 456 b 789 c
а баш по факту в execve зарядил во такой массив во втором аргументе
    ["./155.exe", "123", "a", "456", "b", "789", "c"]
теперь  я иду в proc и смоьрю что там у нас для этого процесса в файле cmdline

$ cat /proc/$(pidof 155.exe)/cmdline
./155.exe123a456b789c

тоесть действиельно в cmdline находится в точности то что было передано во второй
аргумент execve при его вызове! только оно без пробелов! ну тоест ровно так как оно 
в паяти лежит. там же пробелов никаких нет.

тоесть теперь мы умеем находить чему был равен второй аргумент execve при запуске
любого процесса! когда мы смотрим на эту запись
    ./155.exe123a456b789c
мы понимаем что никакого 155.exe не было в строке аргументов когда эту программу
запускали. это туда добавляет сам бащ.
тоесть цепочка такая

набор символов в баш -----> баш читает эут строку символов и готовит аргументы
для execve ----> запуск execve ----> запись в cmdline в proc

поняно что в proc записан второй аргумент при вызове execve и строго говоря совершенно
необязательно что когда набирали команду  в баше или другой прграмме которая сделала 
вызов execve то команда выглядела так. тоесть я могу написать код тако что 
в строке человек вводит 
            >> -1 /mnt ls blabalaklal
моя программа читает эту строку а execve вызывает уже вот так
                ["ls", "-1", "/mnt"]
и в cmdline будет запись вида
                ls-1/mnt
поэому если мы виидим запись в cmdline то она нам тлько говорит как был запущен execve
а какой был исходный тектовый вид команды ХУЙ ЗНАЕТ вобщем случае. 
просто если это был баш то понятно что мы можем сразу это сказать ! вот что я хотел
сказть!
так что еще раз - запис в /proc/pid/cmdline показывает какой был второй арумент при вызывае
execve при запуске  процесса pid

так вот я хочу вернуться к первому элементу во втором аргументе execve
                    ["ls", "-1", "/mnt"]
в данном случае это ls.
можно найти процесс баша у которого cmdline выглядит вот так:
    $ cat /proc/31464/cmdline
    -bash
и я как бы такой ЧЕГО????? я уже давно эту хуйню замечаю но ниак не мог 
опнять что за нахй.

вот как это выяглдит в выводе ps где чаще всего это и можно увидеть
$ ps aux | grep tty1
vasya    31464  0.0  0.0  22692  5400 tty1     S+   00:34   0:00 -bash

и ты такой смотриш на это думаешь а что это за хуета?
дело в том что раньше я думал что cmdline показыавет именно строку парамтров
как была запущена программа! Я ЖЕ НЕЗНАЛ ЧТО ЭТО СОВСЕМ НЕТАК. что это показан
как я уже сказал второй аргумент execve при запуске процесса и что в него входят
нетлько аргументы запуска новой программы но и бесполезный первый элемент который
нихуя никакой функциональной нагрузки не несет. а также я же незналл что баш 
при запуске любой программы сует этот первый бесполезный элемент в execve!
так вот "-bash" это как раз тот самый первый элемент массива второго аргумента execve!
тоесть вот в этом массиве оно бы стояло вот тут
                        ["-bash"]
точннее даже нетак
                        ["-", "bash"]
так как мы помгим что cmdline он покаывает весь массив без пробелов. поэому хуй
поймешь где там пробелы
хотя ксати не знаю какой вариант правильный потому что оба из них дадут "-bash"
в cmdline
кстати вот еще пример
$ ps aux | grep tty1
root     31351  0.0  0.0  80860  3780 tty1     Ss   00:30   0:00 /bin/login -p --

мы видим справа что есть пробелы а теперь смотрим cmdline
    /bin/login-p--

тоесть как ps из этого умудряется увидеть пробелы хуй знает
ну и раз ps неразделил "-" с "bash" то я все таки полагаю что с башем
массив выглядит именно так
                            ["-bash"]
а вот как в man bash про это написано:
    A login shell is one whose first character of argument zero is a -

то есть через такую хрень обозначается login шелл. в чем его загадочное фишка?
как я понял ни в чем. просто при старте баш проверяет этот параметр и найдя его таким
читает несколько другие конфигурационные файлы чем если он стартанут без этого параметра
вот и все!
но фишка в том что мы из баша такой баш никогда не сможем запустить! потому что 
как мы уже поняли первый элемент при вызове execve баш вставляет имя файла! посолку
файла "-bash" нет то как сказал никогда из баша мы такого не добьемсся ! но 
мы такое добьемся из си!

берем вот эту программу


//
#include <stdio.h>
#include <stdlib.h>
#include <inttypes.h>
#include <locale.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>


int main(int argc, char *argv[], char *envp[])
{

char const path[] = "/bin/bash";
char const * ptr_path = path;

char arg1[] = "-bash";
char * const ptr_arg[] = { arg1, NULL };


char env1[22] = "VAR1=12";
char env2[22] = "VAR2=folder";
char * const ptr_env[] = { env1, env2, NULL };


      pid_t pid = -1;
      pid = fork();

        if (pid == -1)
        {
           printf("ERROR: fork() is failed\n");
           exit(1);
           } 

        else if (pid == 0)
        {
              int ret_c = -1;
              ret_c =  execve(ptr_path, ptr_arg,  ptr_env);

                if (ret_c == -1)
                {
                    printf ("ERROR: execve() is FAILED\n" );
                    exit(1);
                    } 


           exit(0);
            }


        else if (pid > 0)
        {
          pid_t pid_p = getpid();
          printf("parent: parent PID=%d...\n", pid_p);
          printf("parent: child PID=%d...\n", pid);

          int wstatus = -1;
          int ret_c = -1;
          ret_c = wait(&wstatus);

          if ( ret_c == -1 )
          {

               if ( WIFEXITED(wstatus) )
               {
                 int exit_status = WEXITSTATUS(wstatus);        
                 printf("Exit status of the child was %d\n",  exit_status);
                                     }

           exit(2);
                  }

          else 
            printf ("notice: the child process has exited successfully.\n");
       


          exit(0);
                }


exit (0);



}
//



вот  в ней такой первый и второй аргумент

char const path[] = "/bin/bash";
char const * ptr_path = path;

char arg1[] = "-bash";  <===== вот это то что нам нужно!
char * const ptr_arg[] = { arg1, NULL };

компилируем запускаем

$ gcc -o 162.exe 162.c

$ ./162.exe
parent: parent PID=1719...
parent: child PID=1720...
vasya@lenovo:~/git/docs/C$ 

смотрим что вышло

$ pidof 162.exe
31785 
$ pstree -AspT 31785
...---162.exe(31785)---bash(31786)

по идее баш 31786 это как раз то что нам нужно
    $ cat /proc/31786/cmdline
    -bash

вот оно!

а вот еше пруф

$ ps aux  | grep -- "-bash"
vasya    31786  0.0  0.0  19816  4572 pts/70   S+   00:41   0:00 -bash

так что никогда мы баш из баша таким образом не запустим!
вот что это значит!
и вот как мы можем это сами так запустить !

это просто ппц..

есть еще файл /proc/pid/comm
в нем записано как называется файл который был запущен

    $ cat /proc/31786/comm
    bash

$ pidof 162.exe
31785 
$ cat /proc/31785/comm
162.exe

фишка в том что  в "comm" укаано именно голое имя файла без всяких путей


| gcc
| X11
| x11

пример прорграммы коорая создает графическое окно в X11


#include <X11/Xlib.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>


int main(void) {
   Display *d;
   Window w;
   XEvent e;
   const char *msg = "Hello, World!";
   int s;

   d = XOpenDisplay(NULL);
   if (d == NULL) {
      fprintf(stderr, "Cannot open display\n");
      exit(1);
   }

   s = DefaultScreen(d);
   w = XCreateSimpleWindow(d, RootWindow(d, s), 10, 10, 100, 100, 1,
                           BlackPixel(d, s), WhitePixel(d, s));
   XSelectInput(d, w, ExposureMask | KeyPressMask);
   XMapWindow(d, w);

   close(0);
   close(1);
   close(2);



   while (1) {
      XNextEvent(d, &e);
      if (e.type == Expose) {
         XFillRectangle(d, w, DefaultGC(d, s), 20, 20, 10, 10);
         XDrawString(d, w, DefaultGC(d, s), 10, 50, msg, strlen(msg));
      }
      //if (e.type == KeyPress)
        // break;
   }

   XCloseDisplay(d);
   return 0;
}


что ее откомпилировать нужны доп флаги

$ gcc -o icon icon.c -L/usr/X11/lib -lX11 -lstdc++




====

| struct

изуючаю отсюда 
    https://beej.us/guide/bgc/html/#structs


что это такое.
это мы можем заадать новый тип из кучи уже старых типов.

$ cat 202.c

void main () {

struct car {
    char *name;
    float price;
    int speed;
};

}




что прикольно даже include никакого ненадо. 
наверно хотя бы это умеет делать сам компиятор.

 厵  $ ltrace ./202.exe 
+++ exited (status 25) +++


$ ldd 202.exe
    linux-vdso.so.1 (0x000077ee8ffb5000)
    libc.so.6 => /usr/lib/libc.so.6 (0x000077ee8fd96000)
    /lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x000077ee8ffb7000)

забавно что функции из libc.so.6 все равно подключаются к моей проге.


таким макмро был создан новый тип "struct car"
причем важно дбавлять слово struct. оно видимо как бы явно намекает 
что это нестадартны тип данных а кастомный.

создаем переменую этого типа

        struct car lada01; 

отдельные хрени этого типа называются fileds. как нам в переменной 
lada01  задать отельные поля? а через точку


lada01.name = "kalina";
lada01.price= 2.3;
lada01.speed = 100;



итого 

 = ⵱  $ cat 202.c
#include <stdio.h>

void main () {

struct car {
    char *name;
    float price;
    int speed;
};


struct car lada01;

lada01.name = "kalina";
lada01.price=2.3;
lada01.speed = 100;

printf ("name  = %s \n", lada01.name );
printf ("price = %f \n", lada01.price );
printf ("speed = %i \n", lada01.speed);


}


вывод на экран

  $ ./202.exe
name  = kalina 
price = 2.300000 
speed = 100 


чтот тут примечательно. а то что когда мы обращается к полю такой
структ переменной. то мы же в структе указали какой типу  поля. 
например у поля .speed тип integer. поэтому у си нет никаких проблем
с типами когда мы обращаетмя к полю. он знает тип этого поля.
можно например сделать без проблем присвоение

        int vasya = lada01.speed;

у нас слева тип int и справа  у нас тоже тип int потому что так 
в struct написано 




еще можно вот так можно создать переменную этого
типа + задать знавение этой переменной со всеми полями

struct car lada02 = { "name", 2.3, 200   };





теперь про работу с поинтерами на переменные которые имеют тип struct
как нам заадть поинтер на такую пеерменную

        struct car *p_p1;

тоесть смысл этой строки в том что я задаю переменную p_p1
которая является поинтером на некотрую пеерменную которая имеет тип 
struct car

теперь вот так задаем значение для этого поинтера

        p_p1=&lada01;


теперь пеереходим к важному вопросу. когда я имел дело с поинтерами
котоыре указывали на переменную с известным типом мы жем указвыали 
тип этой переменной уже при задании поинтера

   int *p_p3;

тоесть эта строка она говорит что перпенная p_p3 она поинтер и она 
точно будет указывать на переменную с типоv int; нампрмиер

  int *p_p3;
  int petya = 5;
  p_p3 = &petya;


и когда у нас поинтер имеет заранее известный тип , тоесть понятно
что поинтер это просто поинтера. а тип поинтера это значит на переменную
какого типа он указывает. так вот с этим понтером проблем нет в плане
распечатки. потому что он указывает на int
хотя я щас еще для интеерса создам другую пеерменую которую присвою
на освное этого поинтера

  int kuku = *p_p3;
  printf ("kuku = %i \n", kuku );

а вот как расечатать значение (дереференс) сразу из p_p3

  printf ("*p_p3 = %i \n", *p_p3 );

тоесть если p_p3 это поинтер, то его значение(дереференс) можно посмотреть
через *p_p3

вобщем кода поинтер имеет какойто тип то его дереференс проблем нет
ни при печати ни при операциях присвоение.  а есть же void поинтер.
и поэтому чтобы потом чтото распечаатть из этого void поинтера нужно 
вначале си обьяснить в явном виде а какой тип там на самом деле лежит

задаю int пееременную
  int petya = 5;

задаю void поинтер
  void *p_p4;

задаю что поинтер указывает на переменную petya
  p_p4 = &petya;

создаю новый поинтер p_p5 который будет указывать на int данные
а справа я беру наш void поинтер p_p4

  int *p_p5 = p_p4;

таким макаром нет никакой проблемы скопирровать один поинтер в другой.
потому что тупо адрес копируется с одной точки в другую. адрес он и есть
адрес. нет проблем. просто слева я указываю уже в явном виде что наш
новый поинтер он указвыает на точку в которой хранится переменная
с типом int.  я считаю что когда в поинтере указыватся тип то это просто 
обьясняет компилятору какую асмблерную команду вставить а именно сколко
байтов надо счиать по указангому адресу. это может один байт а можно и 8 
байт. 

кстати очень дебивльная вещь в си с поинтерами. если у нас стоит слева
от равно знак *p_p1 то это значит что  мы обьявили поинтер.

    int *p_p1 = &vasya;

а если у нас стоит *p_p1 то это значит "покажи мне содрежимое по адресу
который возьми из поинтера"

   int a = *p_p1;

разве это не дебизилм? неужвели нельзя было задавать поинтер одним знаком
а обрщаться к нему другим?


итак еще раз

  void *p_p4;
  p_p4 = &petya;
  int *p_p5 = p_p4;
  int kolya = *p_p5;
  printf ("*p_p5 = %i \n", *p_p5 );
  printf ("=====================\n\n");

вот какая длинная цепочка чтобы я мог распечтаать значние исходной переенной
ссылка на которую была изначально сохранена в void pointer 
а я хочу распечатать эту переменную через поинтер. так как чеерез воид 
поинтер ты хер распечатаешь. ибо си незнает сколько байтов надо читтать 
из адреса по этому поинтеру.

но все таки есть и более короткий путь. называтся cast. (дебильный термин
как обычно)
а вот более короткий путь

  void *p_p4;
  p_p4 = &petya;
  printf ("*p_p4 = %i \n", *(int *) p_p4 );

вот эта хрень *(int *) это и есть cast
она говорит о том что надо из адреса p_p4 считат столько байтов сколько 
содержит int тип.
тоесть если бы поинтер p_p4 сразу был бы int то печать переменной на которую
он указывает булет вот просто так

  printf ("*p_p4 = %i \n", *p_p4 );

а так как p_p4 имеет тип воид. то си как то надо обьяснить сколко байт
считать из этого поитера

  printf ("*p_p4 = %i \n", *(int *) p_p4 );

как я понимаю   (int *) p_p4  эта штука она "как бы преобразует" воид
поинтер из войд типа в int тип поинтера. и тогда   *(int *) p_p4  уже
читает из этого "нового" поинтера столько байт сколько int требует

вся эта ебала с кастами только потому что если у нас есть void поинтер
то мы неможем из него нихуя вытащить. нужно его вначале "преобразовать"
в поинтер в котором указан тип данных . и только потом можно чтото вытащить
из этого поинтера!
эту всю хрень можно увидеть в 202.c

так вот я  все распинался вот почему. потому что возвращаюсь к 
поинтерам на struct. если  я создал новый тип данных через struct


struct car {
    char *name;
    float price;
    int speed;
};


если ты создал переменную с этим типом

    struct car lada01;


и ты инициализировал эту переменную

    lada01.name = "kalina";
    lada01.price=2.3;
    lada01.speed = 100;


и ты неможешь неможешь взять и просто распечатать эту переменную.
так нихуя не срабоает. 

  printf ("...",  lada01);

потому что слева в "" внутри нужно вставлят модификатор скажем %s
и фишка в том что нет такого модификатора %N коорый бы мог распечаать
мою struct переменную.!  мы можем распечааать только поля этого
структа. потому что каждое поле по крайней мере в моем структе имеют
built-in тип данных
    
    printf ("name  = %s \n", lada01.name );
    printf ("name  = %s \n", lada01.name ); 
    printf ("price = %f \n", lada01.price );
    printf ("speed = %i \n", lada01.speed);


итак пока что у нас была просто переменная lada01 с типом struct car,
а теперь усложняем двигаем дальше , вводим поинтер на эту пеерменную

    struct car *p_p1 = &lada01;

а теперь самый главный контент к которому я шел. как нам получить 
доступ вычленить кокретное поле в переменной на которую указывает 
поинтер если перменная имеет тип struct. а делается это вот так

    float i1 = p_p1->price;

ну и печать уже обычной привычной переменной i1
    printf ("i1 = %f \n", i1 );


или одной строкой

    printf ("price = %f \n", p_p1->price );


тоесть 

    p_p1->price

эта хрень означает что p_p1 это должен быть поинтер. поинтер на переменную
которая имеет тип struct , и в этом структе есть поле с именем .price


далее. теперь погговорим вот мы создали структ. создали над ним переменую.
дали ей значение. далее создали поинтер на эту стркуткт перееменную.
а теперь мы хотим этот поинтер использовать в аргументах вызова функции.
напомню что когда мы в главной функции main() задали переменную A

 int A = 1;

а потом когда мы встаовляем имя переменной A при вызове функции func1 (A) 
то когда стартует код функции func1 то  у нее есть стек.в этот стек 
будет засунуто значение этой A. и функция может считать это занчение из 
стека в своб локальную переменную B. и работать уже с этой B. при этом
изменеия в B никак не скажутся на A. потому что они хрантся соврещенно
в разных кусках памяти.


  $ cat 204.c
#include <stdio.h>


// declaire list of functins 
void func1 (int B);
void main();




// specify main body
void main() {
    
int A = 1;

func1(A);

 printf ("A=%i \n", A);


}




// specify func1 body
void func1 (int B){
    
 printf ("B=%i \n", B);

 B=10;

 printf ("B=%i \n", B);

}


замечу злесь как выглядит весь текст программы.
мы указвмем 
   
   include

с фнукциями коорые я будутиспользовать в своих функциях.

потом я укаыают специифиацию моих фнукций кооторые дальше будут
в тексте. их имена и аргументы

    void func1 (int B);
    void main();

причем что дебильно. что почемуто делать описние функции main()
неозаятаельно. поэтому потом когда нужно делать описание дугих фнукций
ты такой думаешь а нахуй это надо ?  аоказывается что это надо делть
фвсегда просто для main эти дебилы не требуют. 

а потом уже ниже идет конкнетно тела моих функций



// specify main body
void main() {
..
..    

}



// specify func1 body
void func1 (int B){
..
..

}


и вот функцию я вызывают подстляя в нее A из главного тела

    func1(A);

а в описании функции указано 

    void func1 (int B);

и механизм такой что значение A читается и копируется в стек. 
а потом когда выполянется функция func1 то в нее создатеся локальная 
перменная B и в нее из стека копирется то что там лежит. атам лежит
значение перенной A из главного тела. 
это получется передать фнкции аргумент через копирвание. а теперь 
представить что A это массив 100ГБ размером. услвовно. его копировать
при кждом вызоывае функции func1 это пиздец

 а вот вывод

  ./204.exe
B=1 
B=10 
A=1 

видно что при такой механизме вызоыва у нас A не модифицировался

это получется передать фнкции аргумент через копирвание. а теперь 
представить что A это массив 100ГБ размером. услвовно. его копировать
при кждом вызоывае функции func1 это пиздец
поэтому ест другой механизм через поинтер.


я в главном теле добавляю поинтер

    int A = 1;
    int *p_p1 = &A;

и опрееделяю фнуцию вот так


    void func1 (int *p_B);


и тело фнукции будет вот такое

void func1 (int *p_B){
    
 printf ("*p_B=%i \n", *p_B);

 B=10;

 printf ("*p_B=%i \n", *p_B);

}


и функцию мы будем взывать
 
  func1(p_p1);



итого суммарно вот так

  $ cat 205.c
#include <stdio.h>

// declaire list of functins 
void func1 (int *p_B);
void main();


// specify main body
void main() {

  int A = 1;
  int *p_p1 = &A;

  func1(p_p1);

 printf ("A=%i \n", A);


}


// specify func1 body
void func1 (int *p_B){
    
 printf ("*p_B=%i \n", *p_B);

 *p_B=10;

 printf ("*p_B=%i \n", *p_B);

}


вывод на экран

 $ ./205.exe
*p_B=1 
*p_B=10 
A=10 

так вот как работает вывзов функии в этом случае. у нас есть поинтер p_p1
на переменную A в главной функции main()
и при вызовае фукнции func1() у нас значение поинтера то есть адрес
копируется в стек. а потом функция стартует func1() и в ее локальную
пеерменную p_B  которая поинтер копиркется то что в стеке. поэтому 
p_B имеет адрес на туже переменную A. и поэтому меняя в фнкции func1()
чтото что хранится по адресу p_B мы по факту меняем A.
и это и видно ввыоде. 
но еще главная хрень в том что когда мы передаем в фнкцию поинтер. да 
его значение тоже копируется также как когда мы до этого передавали
не поинтер. но поинтер это всегда маленькая пременная по обьему. это всего
8 байт. тоесть скопровать поинтер в стек это очень быстро. а просто
перменная это можетбыть массив на 100ГБ и его копироать очень даже
долго. а фнкция может вызываться 1000 00 раз в секунду. поэтому при 
взывае фкнции горазо выгоднее с точки зренеи ясокрости пердатьав не 
просто переменную. а поинтер на нее. тогда это очень быстро с точки
зрения того обьема который нужно скопировать в стек. у нас всегда буде
кировать только 8 байт. внезавсимости от обьема той переменной на которую
укзваывает поинтер. а в целом разницы никакой - что работать с классичи
перменной что с поинтер внутри функции. 
поэтому передча поинтер в фкнциб это очень выгонодно.


