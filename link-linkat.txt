| link
| linkat
| hardlink
| softlink
| symlink

с помощью link() linkat()
можно создать так называемый hardlink 
для файла.
вот как выглядит функция
	    link ("/tmp/6.txt", "/tmp/7.txt");



вот программа


#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>


char const f_path[] = "/tmp/6.txt";


int main()
{

    int fd = open(f_path, O_RDWR|O_CREAT|O_TRUNC, 0666);
    if (fd == -1)
    {
        perror("open");
        return 1;
    }

    int ret =close(fd);
    if (ret != 0)
    {
        perror("close");
        return 1;
    }

    printf ("start pause 30 sec\n");
    sleep (30);
    printf ("pause is over\n");

    ret = link ("/tmp/6.txt", "/tmp/7.txt");   /*<=======*/
    if (ret == -1)
    {
        perror("link");
        return 1;
    }


    return 0;
}


программа создает файл /tmp/6.txt
потом делает паузу 30с чтобы можно было псмотрть свойства 6.txt через
скажем stat.
а потом создает хардлинк 7.txt для 6.txt


вот как выглядит статисткиа когда 6.txt только создан
$ stat /tmp/6.txt
  File: /tmp/6.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15860320    Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)


мы видим что у него 
	Links: 1



а вот как выдяит статика для этого же 6.txt 
когда у него есть брат акробат 7.txt

$ stat /tmp/6.txt
  File: /tmp/6.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15860320    Links: 2
Access: (0664/-rw-rw-r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)

поменялось то что теперь у него изменилось поле 
		Links: 2


а вот статитсткиа для 7.txt
$ stat /tmp/7.txt
  File: /tmp/7.txt
  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file
Device: 10302h/66306d	Inode: 15860320    Links: 2
Access: (0664/-rw-rw-r--)  Uid: ( 1000/   vasya)   Gid: ( 1000/   vasya)


и 6.txt и 7.txt укзвыают на одну и туже иноду
	Inode: 15860320

и у обоих 
	Links: 2

так что такое хардлинк?
дело вот  в чем - я подробно это все изучаю в "ext4.txt"
а здесь только бегло. так вот как хранится файл на диске.  есть куча блоков
на диске. это просто голый диск с магазина. потом мы натравливаем на диск
драйвер ФС и он создает на диске файловую систему. как это? он обьединяет
блоки диска в блоки ФС. и с ними уже рабатеает. так вот файл это тело 
файла  это куча блоков ФС на ФС.  и это метаданные от файла. в котоых
записано в каких блоках искать тело файла. файл пермишнсы на этот файл.
кто владелец файла. итп. так вот эти метаданые хранятс в особых блоках
на фс эти блоки назваются inodes. (дебил название). если ядро хочет порабтаьт
с телом файла то оно читает inode от файла и тогда уже знает где хранится его
тело . хотя скорее я думаю что ядро сообщает драйверу фс с какой inode этот
драйвер фс должен поработать. и уже с блоками фс работает именно драйвер фс 
а не ядро. (драйвер фс это тоже ядро. но более специфичский кусок).
файловая система похожа на огронмый шкаф с полками. полки имеют номера. 
внутри полок хрантся листочки разных книг. и чтобы книгу целиком прочитать
надо знать в какие полки надо слазить. для этого у щкафа есть отдельная секция.
где внутри каждой полки лежит описание одной книги. там указано в каких полках
искть ее листочки. и кому можно это делать. эта спец полка это inode.
ядро говори драйверу фс - эй! сходит там открой иноду 24 и прочитай из
книжки за которую она ответчает 200 байт с оффсета 0! и драйвер фс идет
и приносит копию и отдает ее ядру!
все хорошо - но мы когда пишем 
	$ cat /tmp/6.txt
то мы не указваем иноду. значит нужно где то хранить связь между "/tmp/6.txt"
и номером ееной иноды 
			Inode: 15860320
эта ифномация хранися в другой спец иноде оназывается "папка".
в иноде которая отвечает не за файл а за папку /tmp/"
хранится список имен файлов (и папок) и инод которые за эти файлы отвечают!
тоеть в иноде которая отваеаачаает за папку "/tmp"
есть информация о том что файл "6.txt" имеет иноду 15860320
тоесть ели мы залезли в иноду отвечающую за папку "/tmp"
то мы зная имя файла 6.txt сразу находим ее иноду. зная иноду мы уже
можем работать с файлом! мы его нашли! так вот эта вот запись вида
		6.txt -|-> 15860320 которая хранится в иноде папки "/tmp"
это и есть хардлинк
это связь между именем файла и его инодой.
ровно также хардлинк
		7.txt -|-> 15860320
имеет такой же смысл.
хардлинк позволяет связать иноду ФС  с именем файла в папке.
замеччу что в иноде нехранится никакого имени файла. имя файла хранится
в хардлинке.
одна инода может иметь миллион хардлиноков в папках. и все они ведут
на один физ файл на диске. 

вопрос как ядро или драйвер ФС находит иноду отвечающую за папку /tmp
тут дело вот в чем. у нас путь к файлу укзывается в виде
		/AA/BB/CC/6.txt
это означает папка /
внутри нее папка AA
внути нее папка BB
внутри нее папка СС
далее дело в ом что инода отвечающая за корневую "/" папку имеет фикиованный
номер всегда. он заранее известен. 

$ stat /
  File: /
  Size: 4096      	Blocks: 8          IO Block: 4096   directory
Device: 10302h/66306d	Inode: 2           Links: 27

это инода 2 !
а дело в том что драйвер ФС он сами иноды на диске если известен ее номер
умеет искать! тогда поиск выгдяит так

драйвер фс идет на диске в иноду 2. там он ищет в списке какой номер иноды
имееи папка AA. находит. идет в иноду папки AA. там ищет номер иноды папки BB
. находит. идет туда и ищет номер иноды папки CC. находит.иед в ниноду папки CC
и там ищет иноду файла 6.txt - находит! и вот наконец драйвер фс нашел
номер иноды файла! теперь он идет в иноду файла и там находит все что ему 
нужно а именно список блоков ФС в которых хранится тело файла!
вот так это работает !
таким образом человеку не приходится запоминатьь номера инод файлов на диске!
вмсто этого человек надо знать "путь через папки " к файлу и имя файла!
так драйвер фс может найти номер иноды файла. и само тело файла!

в нашем случае путь  = /tmp/1.txt тоесть 
папка / + папка tmp/ + файл 6.txt
смотим

папка / имеет inode 2 в ней он нахрдит номер иноды для /tmp
$ stat /tmp
  File: /tmp
  Size: 32768     	Blocks: 72         IO Block: 4096   directory
Device: 10302h/66306d	Inode: 15859713    Links: 83
в ней он находит номер иноды для 6.txt --> 15860320

при создании файла всегда на фс  аллоцируется (занимается) +1 инода
в которой указаны все параметры файла (кроме его имени).

так создание хардлинка это не создаие файла. поэтому при создании
хардлинка конечно же новыые иноды на аллоцируются!

а вот при создании симлинка как раз таки создается новый файл и поэтому
аллоцирвется +1 новый симлинк!
в иноде этого файла указано что это не просто regular file
а что это спец тип файла это симлинк. и указано на какой файл "ведет " этот
симлинк. насколько я помню есть какойто предел сколько симлинков может
быть максимум в цепочке прежде чем они приведут на реальный файл. 
так вот когда мы драверу фс говорим мол
	 $ cat /tmp/8.txt
а 8.txt это симинк на 6.txt
то драйвер фс понимая что 8.txt это симлинк в итоге "выдет" на 6.txt 
и читать он будет 6.txt конечно же!

в хардьнке хранися номер иноды файла! а симлинке хранится путь к файлу в
в виде  через папки тоеть в виде "/tmp/6.txt"
поэтому хардинк может вести только на иноду которая лежит на той же фс 
что и сам хардлинк где он лежит а вот симлинк может вести на файл
который лежит на другой фс.

если мы удалим все хардлинки от файла то у нас по момему сама инода она
иницаилизируется (зануляется) а блоки с данными как лежали на диске 
нетронутые так и лежат. но как нам узнать их номера еслиони были запианы
в иноде?

если мы удалили один хардлинк а второй остался то страшнго ничего нет.
у нас по прежнему есть полная инфо чтобы добравться до тела файла. просто
теперь мы донего можем добартаться только по одному пути. хардлинк 
похож на дорогу к цирку. положим таких дорог 10. удаляем 9 остатется 
одна дорога. цирк по прежнму на месте. доступен. нет прблем!

итак создание файла на фс это записат даныне в блоки данных с телом файла
на фс. потом записать иноду  в которой указано в каких блоках лежит 
тело файла. и записать в иноде папки имя файла и его номер иноды!
все - файл создан. три шага.
для драйвера ФС чтобы открыть и рабоат с файлом нужен толко номер иноды!

(!TIP) полезный ништячок найти имена файлов\папок по номеру иноды
	$ find / -inum 3932325 -xdev 2> /dev/null

значит в ext4.txt я выснил (ищи там как "| O_TMPFILE") что 
при удалении файла через rm\unlink
из трех частей из которых сосоит файл удлатеся только одна часть.

файл состоит из блоков данных там где тело. иноды и хардлинка.
в иноде указывается солкьо хардлинков указвыает на эту иноду.

так вот приудалении файла все что у него удалется это не файл
а тлоько сраный хардьинк. и в иноде уменшсется число 
		LINKS:
на единицу.
если число LINKS: стало 0 
то данная инода обратно возрвщатеся в список свободных инод.
но ни в иноде данные не стираются ни  в дата блоках 
до тех пор пока эта инода или те дата блоки не понадобятся 
для новых файлов. это все я проверил через debugfs и dumpe2fs
так что смотри там в ext4.txt

