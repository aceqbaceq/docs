| terminal


читаю вот это 


https://herbert.the-little-red-haired-girl.org/html/glibc/libc_12.html#SEC248


isatty()
  с ее хелпом можно проверить что дескриптор 
  укзвыает на файл за которым сидит ттай драйвер.
  то есть что файл в итоге ведет на железку 
  терминал


ttyname()
вернет им терминала


и я написал 430.c котоырй поукзвает как это 
использовать


в своствах tty driver можно встаыить

    ixon

флаг который вот о чем. у нас из терминала даныне
летят в tty driver и у него есть входной и выходной
буферы. так вот  если например из терминала скажем
с клавы в ттай драйвер летит дохрена данных 
а у ттай драйвера буфер забит то он шлет обратно
на терминал видимо байт XON


model 33     BIN      HEX   ASCII 
meaning                     meaning
_______________________________________________
X ON      0 00 10000   10    DLE (data link escape) 
X OFF     0 00 10010   12    DC2 (device control 2) 


так вот виимо он шлет 0x12 байт на терминал 
сообщая ему то больше пока ничего слать ненадо.
а потом когда очередь у ттай дайрвера расссасывается
то он шлет байт 0x10
прикол в том что у аскии таблице нет никаких 
x-on x-off байтов. вместо них у него стоят DLE,DC2
они есть только в докуменатции к model 33 железке


длинна очереди прописана в параметрах ядра
которые можно поменять только перкопиилровав ядро
а посмореть чему оно равно вот тут


#sudo cat /usr/include/linux/limits.h | grep MAX_INPUT

#define MAX_INPUT        255	/* size of the type-ahead buffer */


проверяю чему равно прям щас

$ getconf -a | grep MAX_INPUT
MAX_INPUT                          255
_POSIX_MAX_INPUT                   255


ещ можно посмтреть это через 

  # getconf -a | grep MAX_INPUT

а вот как эта комнад аработает я не понял

то что я называю буфером у ттай драйвер это и есть
тот самый один из queue котрый указан выше


вот это мне понравилось
Most programs use canonical input mode, because this gives the user a way to edit input line by line. The usual reason to use noncanonical mode is when the program accepts single-character commands or provides its own editing facilities.


как  я понял все настройка ттай драйвера для даннного
терминала собирается в ядре в структ

  struct termios

который можно счиать и обратно записать обратно
через tcgetaddr() tcsetaddr()


далее написано что если я меняю этот структ через
tgsetaddr() то натройки сразу летят в терминал и 
применяются

ксатти именно по этому линку можно еще раз прочитаь
значение флагов stty помимо man termios


на счет флага 

   ECHOE

что он дает. если у меня установлен ICANON 
то он учитывает тот байт который указан в 

   ERASE  ^?

вот в ттатй драйвер влетает 7F у нас icanon 
он лезет в ERASE видит что там 7F и он понимает
что юзер хочет удалить 1 символ слева от курсора
на экране. НО!!! ттайдрайвер будет посылать 
на терминал байты которые должны заставить его 
удалить символ слева ТОЛЬКО если установлен 

    ECHOE

а если он не установлен то ттай драйвер делать 
нихуя не ббудет!!!! это идиотизм. 
кстати при таком режиме

		icanon echo  echoe echoctl  erase 0x7F


нажатие на бекспейс будет удалять символ слева
на экране
а вот в таким режиме

		icanon echo  -echoe echoctl  erase 0x7F

при нажтаии на бейсейс я буду получать

         ^?^?^?^?^?^?^?
на экране вместо удаления

как походу это работает. вот я нажал backspace
он влетает в tty driver
он смотрит установлен ли  icanon. устанолвен
тогда он дальше роверяет установлен ли echo
установлен. тогда он дальше провереыет устанолвен
ли echoe  если установлен то он обратно на терминал
шлет такие байты(хуй знает кастати каикие) которые
затвляют терминал удалит 1 символ слва от курсора.
а если не устанолвен он прояеряяет дальше установ
лен ли echoctl если да он он шлет на терминал ^?
а если не устанолвен то не шлет нихуя.


тоесть схема вот такая


7F -----|  icanon -| echo - |echoe - послать байты на терминал которые удалят символ на экране - конец
        |          |        |-echoe - |echoctl -отправить ^? на терминал - конец
        |          |                  |-echoctl - неделать ничего - конец
        |          | -echo ....
        |
        | -icanon - ...



следущий интерсный флаг 

 ECHOPRT

он аналогичен echoe но! рабоаем немного по ругому
тоесть echoe делает то что ттай дравер щлет на тер
минал такой набор байтов чтобы он стер слева один
символ. так вот если -echoe  то ттай драйвер проверяет
установлен ли echoprt и если он устанолвен то при
влете  erase байта в ттаай драйвер то он шлет на
терминал символ 
   
     \

а  следующим символом он рисует на экране тот
символ который ттай драйвер удалил из буфера.
вот пример вот на экране

   1234567890

и то же самое у нас в буфере ттай драйвера.
я тыкаю backspace и вот что увижу на экране

   1234567890\0

тоесть вот этимим символами \0 нам ттай драйвер
собщает о том что он удалил из буфера символ '0'
и если я продолжу нажимать я увижу

   1234567890\0987654321

и если я продужу жать то я увижу

   1234567890\0987654321/

вот эта палка в конце показыает что буфер пустой

а вот еще пример

 1234567890\0/1  

это значит что я напечатал вначале 1234567890
потом я нажал backspace и он удалил символ 0
а потом я нажал 1 и он его добавил в буфер
тоесть вот это вот \0 покаызает что он стер из 
буфера. а вот это /1 показывает что я прекратил 
стирать и нажал 1

вот что удобно сделано

isig icanon iexten echo -echoe echok -echonl -noflsh -xcase -tostop echoprt -echoctl echoke -flusho

как я понял ттай драйвер анализирует эти настройки
он реально их смотрит слева направо
и если он находит то что нужно то далее направо 
он и нелезет. нармиер первое он смотрит isig  и 
если -isig то он понимает что реагиоовать 
на INTR, QUIT, and SUSP
ненужно тоесть на

intr = ^C; quit = ^\; susp = ^Z; 

ненужно. в независимостиот канон илинеканон. не
играет роли

а вот еше бит интереный

Macro: tcflag_t TOSTOP
    If this bit is set and the system supports job control, then SIGTTOU signals are generated by background processes that attempt to write to the terminal. See section Access to the Controlling Terminal. 



так!  я походу понял на счет флага IXON
дело вот в чем. если он установлен то ттайдрайвер
ссмотрит еще на два флага

  start = ^Q; stop = ^S;

и работает это так. если с клавы терминала в ттай
драйвер прилетит байт 'Ctrl+S' 0x13 то для ттай
драйвера это сигнал о том что терминал нам сообщает
X-OFF тоесть он нам сообщает о том что далее он 
не готов от нас нихера принимать байты! и он просит
нас ему их не присылать! ТОГДА если юзер программа
сует байты в ттай драйвер а сует она через какой
нибудь write() то ядро этот сисколл суспендит 
блокирует. а сам ттай драйвер перестает отсылать 
на темринал какие либо байты!!!! тоесть уадленный
терминал нам сообщает через байт указанный в 
нстройке

   stop = ^S;

о том что он неможет пока принимать от нас байты.
и ог просит нас их не посылать нму. и ттай дарвер
пересатет их посылать. а еси наше юзер прилжоение
пытается сунуть байты вв ттай драйвер то ядро
этот write() суспендит! визуально на карне терминала
ввывод замрет. при этом у нас курсор продолжит 
мигать! (к сожалению). нажатие кнопок в экране 
терминала ничего не будет менять. байты от клавы
будут терминалом посылаться на ттай драйвер при этом!
но так как наш терминал попросил его ему ничего
не присылать то ттай драйвер ничего не терминал
обратно слать не будет! тоесть еще раз - с терминала
байты по прежнму с клавы будут терминалом направолться
на ттай драйвер. и он будет их сохрансять в своем
буфере. но обратно на терминал он ни сам в режиме 
эхо ни башу не позволит слать байты на на терминал!
до тех пор пока  с клавы терминала не прилетит
байт 


    start = ^Q;

который сообщит ттай драйверу со стороны терминала
то что X-ON то что терминал теерт готов принмать
байты от нашего ттай дравера! и тогда все заработает
снова!

вот как рабоатет и в чем смысла IXON START STOP
в настройках tty драйвера.

через START STOP мы обяснем нашему ттай драйверу
какие байты нам пришлет удаленный терминал 
который будут значиить X-ON и X-OFF  байты.
при этом неважно какой режим каноникал или не
каноникал.

в model 33 за X-ON отвечал байт 0x10 (Ctrl+P)
а за X-OFF отввечал байт 0x12 (Ctrl+R)
об этмо я написал в "terminal-DEL.txt"


далее вот этот флаг 

lnext = <undef>;

правада по дефолту байт для него не задан 
и он работает только если флаг iexten активен.
так вот он дает то что если в ттай дарйвер
влетает этот байт. то тогда слелующий байт
какой бы он нибыл он не будет рассматриваться как
"особый". тоесть он лишает силы особенности
"особые" байты. на одну штуку. тоеть условно 
в ттай драйвер влетел lnext байт. и тогда если 
далее нажать "Ctrl+C" то он не будет иметь силы
в течение одного байта.

в НЕканонич реиме ERASE и KILL символы игнориу
руются.
цитирую
In noncanonical input mode, the special editing characters such as ERASE and KILL are ignored. The system facilities for the user to edit input are disabled in noncanonical mode, so that all input characters (unless they are special for signal or flow-control purposes) are passed to the application program exactly as typed. It is up to the application program to give the user ways to edit the input, if appropriate. 

в неканон режиме параметры MIN, TIME
вступают в силу. тут важно кто из них ноль
а кто неноль.
все случаи я рассатрвать не буду. расмотрю тот
который имеет месте кода у нас баш прицеплен 
к терминалу

MIN=1 TIME=0

читаю 

TIME is zero but MIN has a nonzero value. In this case, read waits until at least MIN bytes are available in the queue. At that time, read returns as many characters as are available, up to the number requested. read can return more than MIN characters if more than MIN happen to be in the queue. 

по факту это означает что как тоько в ттай драйвер
прилетает хотя бы 1  байт то тут же он будиит read()

конец статьи по tty driver.
вообще же это все часть огромной книги 

    The GNU C Library


далее читаю вот это 

    http://www.unixwiz.net/techtips/termios-vmin-vtime.html

и тут написано что stty это всего навсего тулза
для работы с struct termios который в свою очередь
является той хренью в которой записаны все настройки
ттай драйвера который работает конкнтертно щас с 
таким то терминалом.
чтобы круто шарить в termios как програмисту
советут книгу

   POSIX Programmer's Guide by Donald Lewine


насоклько я понимаю то что я поколхозному называю
tty driver походу на самом деле назыается line disci
pline

вобщем в этой статье чувк рассматривает некакнон
режим и обсуждает нахен нужны
   
   MIN
   TIME

параметры.

а дело вот в чем. вот мы из юзер программы типа
баша запулили сисколл read()


   int n = read(fd, buffer, nbytes);


если бы небыло бы параметрм MIn TIME то если в 
ттай драйвер из терминала прилетает хотя бы 1 байт
то он бы будил этот read()
и поучается хуйня в том плане что если мы будем 
будить и исполнять сисколл read() на каждый байт
прилетающий из термиала то это очень доорогостящая
операция. потому что сисколл это долгая по времени
опрация из за контекст свич. есть смысл сделать
по другому. параметр TIME задается в долях 0.1с
напрмиер 

   TIME=3

вот у нас в ттай драйвер прилетел первый байт.
вклчается таймер равный 3*0.1=0.3с и идет обратный
отсчет.и read() при этом не будится. если за 0.3с
влетает новый байт то счетчкивремени переустанавли
вается. скажем к нам влетело по быстрому 10 байт.
и вот они все лежат в бууфере и рид() при этом
не будитс. и вот у нас после 10-го байта уже долго
нет нового байта. прошло 0.3с. и только тепеь 
ядро разбудить read() . таким обарзом вмсто того чтобы
10 раз будить read() у нас вся эта шаблоебла байтов
будет скоирована в юзер спейс за всего один read()

справщивется с какой точки зрегия такой подход
более эфективный? где тут профит? а профит  в том
что если запускат сискол read() 10 раз  то это
круто нам загрузить процессор. и все ради того 
чтобы каждый раз закачать в юзер прогу всего 1 
байт. да приожению хорошо.  но! у нас цпу который
мог бы делать чтото боле полезное круто грузится
из за херни. проблема в том что чтобы выполнить
сисколл нужно переключать кольцо цпу  и еще на нем
менять контекси и еще выполнять ядерный код. это
все куча времени которое цпу будет занят. а мог
бы за это же время выполнить кучу какото более
важной и полезной работы. поэтому жерткуют отклика
емосьтью у приложения. но типа круто освобождают
цпу . это как гонять камаз туда сюда 50км
чтобы первезти всего 1 стакан воды.  

далее перехожу к башу. он насрваивает ттай драйвер
вот так

   MIN=1  TIME=0

тест если хотя бы 1 байт посутипил из терминала
в ттай драйвер то ядро обязано разбуить read()
чтобы он этот байт скопировал из ядра в баш.
так как TIME=0 то если байтов нет то read() будет
спать вечно.тоесть таймер равен бесконечности 
при остуствиии байтов для данного случая.
так вот тутже можно скзать но это же как раз 
пиздец. будить read() всего из за одного байта!
прикол тут в том что баш это интерактиваная программа
она дожно как можно менее лагать. и еще пркол в том
что чувачок за клавой вводить кнопки небыстро. 
типа 1 символ за 0.2с поэтому типа с точки зрения
"нагружать цпу из за ерунды"получается типа нормал.
поменять MIN TIME имеет смысла если программа
неинтерактивная и если поток байтов из  терминала
льется высокоскоростной рекой. вот как!
поэтому если у нас за COM портом сидит не терминал
а датчик. и он шлет данные пакетами то вот 
для него и будет круто поменять 

  MIN=X TIME=Y

чтобы из за кажого байта котоырй прилетел от 
него не гонять цпу попусту!

