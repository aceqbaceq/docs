| sock_nonblock

есть такое понятие как неблокирующий дескриптор.
замечу важное замечение  - нет неблокирующего файла или неблокирующего сокета. 
а есть всего навсего неблокирущий дескриптор! тоесть это свойствао самого дескрипора а не
обьекта на который он укзывает!

так вот есть такой извстный флаг который меняет своство десктриптора это флаг 

  O_NONBLOCK

он дает то что если мы читаем или пишем через например read() write()
указав там какойто дескриптор , то если на десрипторе свойство O_NONBLOCK 
не устанолено то ядро тогда смотрит - если оно может выполнить реквест прям щас то 
ядро еговыполняет и сразу возвращается из функций read() write() а если ядро не может 
выполнить реквест прям щас то оно "блокирует" процесс. он становится суспендед и 
вовзрватится толко тогда когда ядро сможеть выполнить заказ.
так вот если у десриптора выставлен флаг 

  O_NONBLOCK

то ядро вернется мговоенно из фнкции внезавсиимости может оно выополнить реквест или нет.
если ядро неможет выполнеить реквест пряс щас то оно веренет ошиьку и в деталях ошики
оно укажет точную причину.

как уствноаить этот флаг дескриптора. ест два вариант.
вариант один например когда мы толкьо создаем дескриптор наример через open()
то в нем можно указать с какими свосйствами нужно его создавать

 int c=  open("/pah/1.txt", O_NONBLOCK,....)

и тогда дскрекриптор "c" будет сразу создан с этим флагом.

или можно поменять свойтва дескрипотора уже после того как он создан ччерез fcntl()
а провериь свойства деакриптора можено тоже через fcntl

так вот теперь пееходим к сокетам.
арпимер tcp сокет.
вот положим у нас есть слушающий сокет.

int s  = socket()
bind()
listen()

int c = accept(s,....)


если мы хотим чтобы наш десриптор c был не блокирующим то мы можем на него 
натраваит  fcntl
который будет его превращать в неболкирующий после того как он уже создан


    int flags = fcntl(с, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        exit(EXIT_FAILURE);
    }


можно пойти еще другим путем  есть accept4()
она позволяет использовать флаги в отлиии от accept()


  #define _GNU_SOURCE             /* See feature_test_macros(7) */
  #include <sys/socket.h>

       int accept4(int sockfd, struct sockaddr *_Nullable restrict addr,
                  socklen_t *_Nullable restrict addrlen, int flags);



по поводу ееных флагов

    $ man   accept4


  If  flags  is  0, then accept4() is the same as accept().  The following values can be bitwise ORed in flags to obtain different
       behavior:

       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the open file description (see open(2)) referred to by the new  file  descriptor.  Using this flag saves extra calls to fcntl(2) to achieve the same result.





тоогда вместо 

		int c = accept(s,....)

надо в прогармме юзать

       int c = accept4(s, (struct sockaddr *)&addr, &(addr_len), SOCK_NONBLOCK );

тогда при создании дскриптора "c" у нас он автоматом будет иметь флаг O_NONBLOCK

таким макаром нам нуженно вызывать fcntl() мы экономи вызов одного сисколла.
еще раз подчеркну что флаг SOCK_NONBLOCK он НЕДАЛЕТ сокет неблокирующим такой хуйнинет.
он заставляет ядро при создании дескриптора сделать его дескриптор не блокирующим путем 
прилепление к нему флага O_NONBLOCK
то что этот флаг у него есть потом можно проверить через 

int check_socket_non_blocking(int sockfd) {

    int flags = fcntl(sockfd, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    // Проверяем, установлен ли флаг O_NONBLOCK
    if (flags & O_NONBLOCK) {
        printf("Сокет  %i в O_NONBLOCK режиме \n", sockfd);
    } else {
        printf("ПРОБЛЕМА: Сокет  %i в блокирубщем режиме .\n", sockfd);
        return 1;
    }





}

проверить при желании естсвтенно. 
я првеорил релаьно эта хреньрабоатет.

если все правилно сделано то в у нас будет например такой стрейс

accept4(5, {sa_family=AF_INET, sin_port=htons(46518), sin_addr=inet_addr("127.0.0.1")}, [112 => 16], SOCK_NONBLOCK) = 7


видим что у нас accept4() а не accept() и что у него выставлен флаг SOCK_NONBLOCK
но опять же повтррсюсь. это не сокет делает неболкирующим. нет. это в итоге делает 
дсекитор не неболокирующим. путем того что на десктриптор навещивется свовйство O_NONBLOCK

того же самого ожно добаиться уже после создания декоиптора путем натрваилывания на него
fcntl()



    int flags = fcntl(с, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        exit(EXIT_FAILURE);
    }


вот такая петрушка


