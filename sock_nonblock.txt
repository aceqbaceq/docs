| sock_nonblock

есть такое понятие как неблокирующий дескриптор.
замечу важное замечение  - нет неблокирующего файла или неблокирующего сокета. 
а есть всего навсего неблокирущий дескриптор! тоесть это свойствао самого дескрипора а не
обьекта на который он укзывает!

так вот есть такой извстный флаг который меняет своство десктриптора это флаг 

  O_NONBLOCK

он дает то что если мы читаем или пишем через например read() write()
указав там какойто дескриптор , то если на десрипторе свойство O_NONBLOCK 
не устанолено то ядро тогда смотрит - если оно может выполнить реквест прям щас то 
ядро еговыполняет и сразу возвращается из функций read() write() а если ядро не может 
выполнить реквест прям щас то оно "блокирует" процесс. он становится суспендед и 
вовзрватится толко тогда когда ядро сможеть выполнить заказ.
так вот если у десриптора выставлен флаг 

  O_NONBLOCK

то ядро вернется мговоенно из фнкции внезавсиимости может оно выополнить реквест или нет.
если ядро неможет выполнеить реквест пряс щас то оно веренет ошиьку и в деталях ошики
оно укажет точную причину.

как уствноаить этот флаг дескриптора. ест два вариант.
вариант один например когда мы толкьо создаем дескриптор наример через open()
то в нем можно указать с какими свосйствами нужно его создавать

 int c=  open("/pah/1.txt", O_NONBLOCK,....)

и тогда дскрекриптор "c" будет сразу создан с этим флагом.

или можно поменять свойтва дескрипотора уже после того как он создан ччерез fcntl()
а провериь свойства деакриптора можено тоже через fcntl

так вот теперь пееходим к сокетам.
арпимер tcp сокет.
вот положим у нас есть слушающий сокет.

int s  = socket()
bind()
listen()

int c = accept(s,....)


если мы хотим чтобы наш десриптор c был не блокирующим то мы можем на него 
натраваит  fcntl
который будет его превращать в неболкирующий после того как он уже создан


    int flags = fcntl(с, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        exit(EXIT_FAILURE);
    }


можно пойти еще другим путем  есть accept4()
она позволяет использовать флаги в отлиии от accept()


  #define _GNU_SOURCE             /* See feature_test_macros(7) */
  #include <sys/socket.h>

       int accept4(int sockfd, struct sockaddr *_Nullable restrict addr,
                  socklen_t *_Nullable restrict addrlen, int flags);



по поводу ееных флагов

    $ man   accept4


  If  flags  is  0, then accept4() is the same as accept().  The following values can be bitwise ORed in flags to obtain different
       behavior:

       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the open file description (see open(2)) referred to by the new  file  descriptor.  Using this flag saves extra calls to fcntl(2) to achieve the same result.





тоогда вместо 

		int c = accept(s,....)

надо в прогармме юзать

       int c = accept4(s, (struct sockaddr *)&addr, &(addr_len), SOCK_NONBLOCK );

тогда при создании дскриптора "c" у нас он автоматом будет иметь флаг O_NONBLOCK

таким макаром нам нуженно вызывать fcntl() мы экономи вызов одного сисколла.
еще раз подчеркну что флаг SOCK_NONBLOCK он НЕДАЛЕТ сокет неблокирующим такой хуйнинет.
он заставляет ядро при создании дескриптора сделать его дескриптор не блокирующим путем 
прилепление к нему флага O_NONBLOCK
то что этот флаг у него есть потом можно проверить через 

int check_socket_non_blocking(int sockfd) {

    int flags = fcntl(sockfd, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    // Проверяем, установлен ли флаг O_NONBLOCK
    if (flags & O_NONBLOCK) {
        printf("Сокет  %i в O_NONBLOCK режиме \n", sockfd);
    } else {
        printf("ПРОБЛЕМА: Сокет  %i в блокирубщем режиме .\n", sockfd);
        return 1;
    }





}

проверить при желании естсвтенно. 
я првеорил релаьно эта хреньрабоатет.

если все правилно сделано то в у нас будет например такой стрейс

accept4(5, {sa_family=AF_INET, sin_port=htons(46518), sin_addr=inet_addr("127.0.0.1")}, [112 => 16], SOCK_NONBLOCK) = 7


видим что у нас accept4() а не accept() и что у него выставлен флаг SOCK_NONBLOCK
но опять же повтррсюсь. это не сокет делает неболкирующим. нет. это в итоге делает 
дсекитор не неболокирующим. путем того что на десктриптор навещивется свовйство O_NONBLOCK

того же самого ожно добаиться уже после создания декоиптора путем натрваилывания на него
fcntl()



    int flags = fcntl(с, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        exit(EXIT_FAILURE);
    }



в целом смотири програму 379.c чтоб на прмиере посмтреть




вот такая петрушка


встретил такую штуку. человек написал о том что он сделал вот так

       int c = accept4(s, (struct sockaddr *)&addr, &(addr_len), SOCK_NONBLOCK );

и он думал что флаг SOCK_NONBLOCK сделает вызов accept4() неблокирующим. 
А ЭТО ОШИБКА! что делает этот флаг в этой фнкциии. он делает вот что - у нас отрабатывает 
эта функция и в результаате у нас создается новый сокет и создается новый дескриптор "c"
и этот дескриптор "c" когда будет создаваться то ему автоатматом будет присвоено свойство
O_NONBLOCKING. что это дает ? это НЕ дает что сам вызов accept4() будет неблокирующим. НЕТ
НЕТ и НЕТ! ОТ ЧЕГО ЗАВИСИТ будет ли фунция блокирующей? это зависит от свойства дескрпторра
который стоит как аргумент внутри фнкции. 
посмтим на нашу фукнцию

       int c = accept4(s, .... );

нужно себя спросить. какой дескриптор стоит внутри? ответ десериптоор "s".
теперь надо себя спросить - он имеет свойство блокирующего или свойство неблокирующего? 
скорей всего он блокирующий по тому что по дефьолту все декрскрипторы создаются блокирующими.
ПОЭТОМУ сам вызов accept4() будет блокирующим! флаг SOCK_NONBLOCK никак не влияет на то
бует ли блокирующим или не блокирующим вызов avccept4() потому что он не влияет на дескриптор "s"
он влияет на десктриптор "c" а это два охреренно разных дескриптора!
если мы хотим чтобы вызов accept4() был не блокирующий то нужно чтобы десриптор s был не блок
кирующий! блокирующая функция будет или нет лзависит от свойств того дескрптоора к которому
она обращается! поэтому чтобы вызов был неблокирующий нужно нам сделать дескриптоор s 
неблокирующим пред вызыововм нашей фнкции. по классике десктриптор неблокирующим делает 
запуск фукнкции fcntl() типа вот так


   int s =  socket(AF_INET, SOCK_STREAM, 0);

   fcntl(s, F_SETFL, flags | O_NONBLOCK)

а уже после этого можно вызывать accept4()

   int c = accept4(s, .... );


вот в чем секрет. есть и еще один трик или хак. согласно man 2 socket можно конкнетно
в данном случае избежать использования fcntl. в фнкции socket() есть спец флаг 
который позволяет уже при создании сокета создать его с нужными свойствами. тоесть fcntl она
меняет совйтва уже сущевтвующего дескриптора. но иногда можно уже на стадии создания 
дескрпттора указать ядру с каким свойтвами его создавать. итак 
вместо трех строчек что выше можно сделать это через две строчки

   int s =  socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);

   int c = accept4(s, .... );


таким образом у нас сокет s будет СОЗДАН уже с флагом O_NONBLOCK
и нам не придется прибегать к fcntl() 

ровно такая же логика и тут

   int c = accept4(s, .... SOCK_NONBLOCK);

этот флаг нас СОЗДАСТ дескриптор "c"  с  заданным свойством O_NONBLOCK
что позволит дальнейшие операции с этим дскриптором чтобы были неблокируюие. такие как

   read(c, ...)
   write(c, ...)


ест и еще один пример коода мы можем на стадии уже создания десктрпитоора задать нужные
нам свойства. 

    int d = open("/temp/1.txt", O_RDONLY | O_NONBLOCK);

тогда наш десктриптор 'd' будет СОЗДАН с уже заранее заданным флагом O_NONBLOCK

еще раз тут хочу подчеркнуть что у нас не бывает блокирующих и ли нелокирующих сокетов!!
бывают только блокрующие дескрипторы! и также бывает блокирующий и неблокирующий вызов 
функции.  

