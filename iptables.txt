про IPTABLES.

-----
предположим мы хотим делать NAT.
тоесть заменить src ip в пакете.

это делается через POSTROUTING правило.

когда это правило срабатывает?

1. пакет должен влететь через сетевую карточку в систему. в ядро.
это значит что изменить src ip до того как пакет влетел в сет карточку неполучится.

вроде выглядит логично. да это вынлядит логично кода пакет влетает из физ сети в 
рельную физ карту

{сеть} --- eth0 --- ядро

в этом случае понятно что пока пакет непопадет внутрь компа пройдя eth0 ее изменить нельзя.
однако это выглядит нетак очеивдно когда пакет влетает в комп не из физ сети а из виртуальной сети 
внутри компа нпример у нас есть некий сетевой неймспей и мы из него в комп (тоесть в деолфтовый сетевой неймспейс) шлем пакет


<неймспейс вася,  eth0> -----|----< деволтовый неймспейс eth1> ---- ядро


из eth0 мы шлем пакет в 8.8.8.8

возникает вопрос на каком этапе можно поменять src ip этого пакета в дефолтовом неймспейсе.
мол можно ли это сделать когда пакет уже вылетел из eth0 и влетел в наш неймспейс но еще 
не влетел в eth1. ответ нет нельзя. пакет можно будет изменить через правила iptables только после
того как он пролетел eth1 и влетел в ядро. это очень важно.  таким образом правило 

-t nat -A POSTROUTING -o eth1 -j SNAT  === небудет работать
также если на eth0 у нас IP = 10.10.10.10\24
то правило
-t nat -A POSTROUTING -s 10.10.10.0\23 -j SNAT  === тоже небудет работать


тоеть как ни ухтиряйся никкое правилоао SNAT на iptables небудет рабоать в нашем нейиспейсе
пока пакет не пролетит eth1. вот кгда он его пролетит тогда уже он постуил в ядро и тогда уже
iptables может начать с ним работать.


это первый супер важный момент.

отсюда вытекаетвторой суперважный ммоент. -- на каком интерфейсе можно будет через tcpdump
отловить отследить что SNAT сработал. ответ это нельзя сделать на eth1. потому что на вылете из него
пакет еще неизменен. это надо будет ловить на какомто другом интрфейсе из которого пакет будет 
вылетать. это тоже очень важно понять.

например


<неймспейс вася,  eth0> -----|----< деволтовый неймспейс eth1> ---- ядро  ----- eth2 --- <внешний интенррнет>

так вот SNAT (тоесть то что у нас поменялся src ip ) можно будет поймать  только на eth2

# tcpdump -n icmp -i eth2


еще один оуенно важный момент. предпооложим у нас внутри компа 
в нашем дефолтовом сет неймспейсе есть нескькол вирт уальных сетевых карточек.
и через них пойдет наш пакет тоесть


<неймспейс вася,  eth0> -----|----< деволтовый неймспейс eth1> ---- ядро  ----- eth2 ---ядро
eth3 ---ядро --- eth4 --- <внешний интенррнет>


преодположим пакет вылетает из eth0 имеет srcip=10.10.10.10 dst ip = 8.8.8.8
и мы в нашем деофлтовом неймспейсе определили что 

-t nat -A POSTROUTING -s 10.10.10.0\24 -j SNAT --to-source 3.3.3.3

пакет пролетает eth1. влетает в ядро. и оно ему на основе этого правла меняет src ip . на 3.3.3.3

далее на основе роутинг таблицы так получается что пакет должен пролтететь через внутренний вирт карточку eth3 и только потом на физ карточку eth4 которая ведет в интернет.

предаопложим мы для карточки eth4 пропмсалли доп SNAT правило

-t nat -A POSTROUTING -o eth4 4 -j SNAT --to-source 110.45.56.67

наш пакет пролетает карту eth3 снова попадает в ядро. 
к нему в теориии должно примениться перед тем как ее выплюнет на eth4 правило котроорое 
должно помментять еще раз его src ip на 110.45.56.67  , НО этого непроизойдет. вот такой трындец.
почему. потому что ( и щас будет сложная муть) iptables это лишнь надстройка над хренью netfilter который 
уже непосредстевенно рулит пакетами. так вот упрощенно скажу так - если при движении внутри компа внутри ядра
пакету суждено несколько раз попадаьт в таблицу nat в правила POSTROUTING то к пакету будет приенено толкьо 
первое правило POSTROUTING а все остальные правила POSTROUTING будут проигнорированы. вот такая хуйня.
посколку пакет уже один раз прошел POSTROUTING то больше он его прходить небудет на других картах. ко всем пакетам из того же содениения будет применять только первый POSTROUTING. поэтому когда пакет доходит 
до второго построутинга то ядро просто нахрен забиает на этот второй построутинг. и поэтому src ip небудет
изменен второй раз.

более точное обтяснение состоитт в том что ядро прежде чем примеять postrouting правило из таблицы нат
смотритв таблицу conntrack. если согасно этой таблице данное соединение еще тлоько устанавливается то 
псотроутигнг правило примняется. а если содениеие уже установлено то правило неприменяется.

более подробные детали на данный момент слишком муторные чтобы их описывать.
на простой практике я говорю все сводится к тому что  только первый по счету построуипнг будет прмиенсяться 
к соединению . а все остальыне будут игнорроваться.

как этого избежать. можно заюзать iptables zones.  пример этого вот тут  - https://serverfault.com/questions/1012570/why-an-iptables-nat-does-not-happen-in-the-network-namespace-separated-transpare


отдельнй мудеж с линукс виртуальныый свич ( so caleed virtual bridge) в плане iptables.
во первых непонятно какой интерфейс считать внешним через которй пакет влетел в ядро. пример


  неймспейс вася   |   деволтовый неймспейс
     eth0-----|------veth1---br0--eth2--интернет


итак у нас есть нейсмпйе вася. есть дефолтовый неймспейс.
eth0 и veth1 = это парочка veth интерфейсов.
eth0 имеет  IP а veth1 неимеет. br0 имеет IP.
veth1  и br0 составляют линукс бридж.

мы хотим изменить src ip пакетв который влетает из eth0.
по логике внешняя карта это veth1 поэтому по идее src ip должно меняться в ядре после veth1 уже на br0.
но этго не происходит на практике.

если мы создаим правило

-t nat -A POSTROUTING -s 10.10.10.0\24 - j SNAT --to-source 3.3.3.3

где 10.10.10.0\24 это сеть на eth0 

и потом если мы будем через tcdump ловить на каком же интерфейсе мы увидим поменявиися src ip
то мы убвдеиммся что на br0 IP адрес пакета не будет изменен. он будет прежним.
а будет он изменен толко при прохожддении eth2 карточки. и это тоже абсолютно непонятно.
как бутто veth1 это не порт а просто блядь какйто кусок провода. 

по мне схема должна работаь так:


  неймспейс вася   |   деволтовый неймспейс
     eth0-----|------veth1-ядро--br0-ядро -eth2--интернет


поэтому по мне уже после veth1 дожны начать работаь правила iptables. а по факту они начаинают работат
только после прходжение br0. и пэтому мы видим замену src ip уже только на eth2 карте.


Еще одна хуйня связанная с линукс бридж.

вот у нас есть два бриджа и за ними два контейнера


ns1     |   дефолтовый ns                     |   ns2
eth0 ---| --- veth1 -- br0 ----- br1 ---veth2 | --- eth1

eth0= 172.17.0.4
veth1= без ip
br0=172.17.0.1
br1=172.19.0.1
veth2 = без ip
eth1 = 172.19.0.2


я с eth0 пингую eth1

(eth0) # ping 172.19.0.2

в дефолтовом неймсейсе у меня настроен NAT

-t nat -A POSTROUTING -s 172.17.0.0/24 -j SNAT --to-source 172.17.0.1

и как бы да tcpdump на br1 покажет что прилетает пакет с src ip = 172.17.0.1

казалось бы обрратный пакет тоже должен иметь dest ip = 172.17.0.1 
а хуй там. 
обратный пакет почемуто имеет dst ip = 172.17.0.4 
это пиздец

вот покаызвыаю:
# sudo tcpdump icmp -n -i  br-d45b22610886

05:36:51.977952 IP 172.17.0.1 > 172.19.0.2: ICMP echo request, id 57, seq 0, length 64
05:36:51.977993 IP 172.19.0.2 > 172.17.0.4: ICMP echo reply, id 57, seq 0, length 64


тоесть туда летит echo request 172.17.0.1 > 172.19.0.2
обратно летит echo reply 172.19.0.2 > 172.17.0.4

это пиздец.


если же я пингую контейнер который не за бриджом а просто это пара veth интерфейсов. показываю

ns1     |   дефолтовый ns              |   ns2
eth0 ---| --- veth1 -- br0 ----- veth3 | --- eth1


где veth3 имеет IP
и если я с eth0 пингую eth1 то все работает просто прекрасно.

тоесть как и прежде у меня настроен NAT для eth0

-t nat -A POSTROUTING -s 172.17.0.0/24 -j SNAT --to-source 172.17.0.1

таким образом eth1 видит пакет от eth0 не как от eth0 а как от br0 и в ответ шлет 
ожидаемый коректный dsc ip.

тоесть


eth0= 172.17.0.4
veth1 =без ip
br0 = 172.17.0.1
veth3= 10.0.10.100
eth1 = 10.0.10.10

(eth0) # ping 10.0.10.10

# sudo tcpdump icmp -n -i  veth3
05:42:11.800429 IP 172.17.0.1 > 10.0.1.10: ICMP echo request, id 58, seq 0, length 64
05:42:11.800514 IP 10.0.1.10 > 172.17.0.1: ICMP echo reply, id 58, seq 0, length 64

тоесть все коректно.
то есть непонятная хуйня  с обратный dest ip происходит толко потмоу что 
мы стучимся на контейнер через линукс бридж. он корень проблемы.

поэтмоу два основных вывода  - линукс бридж приводит к непонятной хуйне. 
и второй ценный инфо что POSTROUTNG   правило применяется только первый раз.  если у нас 
несколько postrouting правил выпадает для пакета то второе правило третье и следущие они просто 
игнориуются !!!!






----


вощникает вопрос как понять какой пакет попадает на INPUT?
как это понять. нам говорят так - мол в INPUT идут пакеты которые
предназначены для локальных процессов. а как это пнять на практике?

а вот как.


у нас на компе в нашем базовом неймспейсе сидят карты


eth0
br0
docker0
eth1
wls2p0

эти карты имеют IP

eth0=IP1
br0=IP2
docker0=IP3
eth1=IP4
wls2p0=IP5


важно что все эти карты и их IP лежат в нашем базовом неймспейсе.

и процессы сидят в нашем сетеовом неймспейсе и они слущают сокеты

IP1:3000 = nginx
IP2:8181 = mysql

итд.

вот она связь между локальными процессами и этими же процессами в плане IP:port

таким образом если пакет предназначен для IP1, IP2, IP3, IP4 то для iptables
означает что пакет надо сунуть в INPUT.
local process на картинках с iptables  это в разрезе iptables это ничто иное 
как сетевой сокет IP:port где IP - это ip который лежит в сетевом неймспейсе 
процесса init. вот что это!!! итак local process это не процесс а IP 
который лежит в сетевом неймспйсе  процесса init.
картинка про это. сет интерфейсы внутри палочек это интерфеймы которые лежат 
в нашем неймспейсе в неймспйсе процесса init. за палочками сидят интерейы
в контейнерах в других неймспейсах.



eth0--|--vethX--docker0            br0--vethY--|--eth1


 docker0 = IP1
 br0 = IP2

тогда  если у пакета dest IP = IP1 или dest IP = IP2 то это значит что пакет предназначен для цеопчки INPUT




а вот за docker0 скажем сидит часть сетвых карточек в другом неймспейсе что если 
пакет предназчен для карточек в тех неймсейсах - в какой цепочку сунет iptables такой пакет - ответ 
в цеопчку FORWARD. потмоу что dest IP лежит вне нашего неймспейса.

а вот предположим в том забриджером конейтнрном неймспейсе родитлся пакет и через veth0 он прровался в наш неймспейс. вопрос в какую цепочку сунет его iptables ?  если на 8.8.8.8 то в цепочку FORWARD 
если в IP от docker0 то это INPUT
ели в IP br0 то это INPUT
если в IP который сидит за br0 в другом неймспейсе то это FORWARD
---

опция -o ethX обозначает ту карту в которую пакет БУДЕТ ВСУНУТЬ. тоесть не ту карту
иp которой пакет вылетел  а ту карту в которую пакет еще только влетит.
на то какая карта будет выбрана при роутинге в качестве -o карты влияет dest IP. dest IP
на это влияет.

теперь переходим к проблеме как нам поменять src IP. ответ через цепочку POSTROUTING.
прикол в том что в этой цепочке можно задавать только -o карточку карточку в которую он еще только влетит. 
(а -i карточку нельзя карточку из которой он вылетел). 

теперь посмотрим на практиеческую задачу


eth0--veth0in--|--vethX--docker0            br0--vethY--|--veth1in--eth1


пакет вылетает из контейнера из eth0 в чужом пространстве. потом он влетает 
в наше простнаство сетевое в vethX и потом вылетает из docker0.
значит поменять src ip на eth0 мы нехотим чтобы не лазить в контейнер потому что 
нужно будет меняь правла iptables изнутри контейнера. это неудобно.

согласно таблице про iptables из интернета первый POSTROUTING случается с пакетом
который прилетел из внешней сети ( а  пакет от eth0 и есть пакет из внешней сети потому что он лежит во внешнем неймспейсе) случается после того как пакет пролетел первый сетевой интерфейс который смотрит во внешний мир 
но перед вторым сетевым интерфейсом. тоесть согласно таблице POSTROUTING цепочка встрчается пакету тогдда
когда он влетел внутрь компа преодолев первый сет интерфейс и перед тем как влететь во второй сет интфрейс.
vethX - это сет интерфейс который смотит во внешний мир.
docker0 - второй сет интерфейс который встрчается пакету из внешнего мира.

поэтому на мой взгляд правило

iptables -t nat -A POSTROUTING -o docker0 -j SNAT --to-source 172.16.1.100

должно отрабатывать и приводить к тому что когда пакет вылаеет внутрь компа из docker0  у него
должен src IP = 172.16.1.100
НО ЭТОГО НЕПРОТСХОДИТ! непонятно почему. может потому что первый сетевой интфрейс во внешний мир должен быть
уровня L3? а  унас veth в случае докера это интерфейс уровня L2. может в этом дело?

тоест мне нужно заставить работат NAT на docker0 а он неработает.

-----

IP 
protocol

этот протокол он connectionless.
что это значит на практике без вот этого ебучего булшита которйы
можно найти в инете.

оттолкнеся от обратного. что такое connection oriented протокол -  если протокол connection oriented то перед тем
как начать передавать первую порцию данных отправитель шлет получателю запрос 
о том что он хочет чтото передать. получатель должен прислать подтвреждение что он 
согласен и мы его должны получить. и например в TCP пртокле на третьем шаге отправитель
шлет получетаюелю подвержение что отправитель получил подтвержение от получаетеля 
таким макаром получатель знает что отправитель получил согласие получаетя. и только 
тогда отправитель начинает сдать данные. данные деляться на куски нумеруются и отправтель
ждет от получаетя подвердлжление о том что получатель получил кажый нумерованный кусок.

всего этго нет у connection less протокола. он ничего преждвариетльно с получателем не согласовавыет.
он неделит инфо на куски и не нумеруеют. их он просто берет кусок данных
и кидает в сеть. и на этом все. отправитель не знает получил получаетль этот кусок или нет.
это похоже на отправтку письма. кинул в ящие -а дальше непясно получили его или нет.


итак еще раз connectio less протоколв имеет три важных свойства - кода мы отправли кусок данных в сеть
то мы не получаем подтвеждения от получается поэтому мы незнаем получем этот кусок или нет.
каджый кусок данных отправляется независимо от других кусков. нет никакой сесссии из серии данных.
перед отправкой данных не происходит установления соединенеия то есть отправитель не сообщает 
получателю что мы будем чтото слать. получатель об этом не вкурсе. а отправтель незнает получатель 
вообще жив ли есть ли и готов ли чтото получать. мы кидаем данные на ближайший рутер а что потом 
просиходит мы не вкурсе.




ip протокол он connectionless. 
более того спустимся ниже - ethernet тоже connectonlesss протокол.
вот мы каким то образом узнали dest mac. мы формируем фрейм и плюем его в провод. что происходит 
далее мы не вкурсе. таким образом ethernet протокол не дает нам никакой инфо о том доставлен 
ли фрейм или нет. мы просто плюемв трубу фрейм и все. доставлен он или недоставлен мы незнаем.

итак еще раз conection less протокол таков  что - мы не устаналиваем предвариельную связь с получаетлем.
поэтому ни получатель о нам не знает ни мы не знаем о получателе есть ли ли он вообще и готов ли 
принимать данные. мы берем кусок инфо и плюем в сеть. после этого мы ничео незнаем. 

connection oriented протокол - устааливаем связь с получаетелем - провверяем есть ли он вообще, готов
ли получать данные. делит данные на пронумерованные куски, шлет эти куски и ждет от получаетля
пдтвреждение что каждй нкумерованный кусок дошел. если какйото кусок недошел то отправляет повторно 
этот кусок.

так вот если у нас внизу сидят connection less протокол то тогда задачу по проверке доставки на себя
берет протокл который выше.

 ethernet это connection less протокол. идем выше.
ip это connection less протокол. идем выше
и только tcp протокол наконец connection oriented.


мне это вот что напоминает : человек это tcp. он пишет пиьсмо идет на почту и кидает в ящик.
местное отделение почты это ip  - она берет письмо и отдает водителю который везет его вдругой город чтобы отдать на местную 
почту. и на этом этапе местна япочта непроверяет доставил водитель письмо или нет.
почтальон в другом городе это ethernet.  почтальон берет письмо и кладет в ящик в доме у получаетеля.
но почтальон не проверяет вытащил ли из ящика человек письмо или нет.
в итоге почтальон (ethernet) незнает забрал  ли получатель письмо из ящика.
местна почта (ip) незнает доставил ли водитель письмо в другой город.
все разруливает лишь отправитель. он сидит и ждет ответное письмо от получателя. если он его неполу
чает за какйото срок то делает вывод что чтото нето. пишет повторое письмо и шлет его повторно.

ethernet без понятия доставлн ли фрейм в рамках нашей локальной сети
ip без понятия доставлен ли пакет удаленному хосту.

когда каждый протокол отправил ( по их понятиям ) кусок инфо на этом их роль заканчивается и они успокаи
ваются.  и они незнают дошло или недошло.

что делает ethernet он с помощью arp узнает dest mac. после этого эзернет плюет в провод фрейм и считает что все окей.

что делает ip. когда мы знаем dest ip то по таблице маршрутизации мы определяем в какой сетевой порт
надо выплюнуть пакет , также через ip гейтвея и ARP мы узнаем какой dest mac у гейтвея. подготовив эту
инфо мы это все передаем в ethernet слой. и на этом ip успокаиывается.
тоесть вся работа ip слоя на компе стсоит в том что по таблице маршрутизации определить сет карту в которую
нужнл выпдюнуть пакет и взяв из таблицы маршрутиацзии адрес гейтвея через arp найти его dest mac и передать
к ethernet слою. вот и все. на этом ip считает что пакет отправлен.

когда ротур получил фрейм из сети. то он смотрит по таблице в какую сет карту выплюнуть этот пакет далее
и какой dest mac от следущего гейтвея нужно юзать. и передает пакет на ethernet слой. все. работа выполнена.

таким макаром использя ethernet или ip мы никогда незнаем доставлен ли наш кусок инфо или нет.
оба эти протокола не подразумевают получение никакого ответа!!!  если даже получатель получил то он необязан
нам ничегоотвечать! захочет ответит захочет нет!

icmp это тоже connection less портокол. перед отравой данных он не проверяет жив ли получаетель. а если
жив то готов ли принимать инфо от нас. есть ли на том конце тоже icmp протокол. он исользуя ip просто шлет
кусок инфо и все. icmp иснкапуслирует свое тело внутрь ip пакета.
получается нет никако гарантии долетит ли наш icmp дата кусок до удаленного хоста или нет. а если долетит
и на том конце есть icmp протокол будет ли ответ. мы такую инфо неполучим.
другое дело что если на тмо конце получили наш icmp дата и там есть icmp протокол то если удаленный хост
захочет он может послать ответ. но этот ответ может потеряться в дороге и мы его может быть получим 
а может быть и нет. и тот удаленный комп об этом тоже неузнает.

поэтому эта связка выглядит так. мы шлем ip пакет внутри котоого icmp дата. этот пакет может долетел
до того компа а может и нет. мы незнаем. удаденый комп если получил и послал ответ он может долетит
до нас а может и нет. и тот удаеннй комп этого незнает. но если ответ все жедо нас долетел
то тогда мы знаем что наш пакет долетел. а еще раз вот удаленный комп незнает долетел до нас его
ответ или нет.
тот удаенный комп может послат свой эхо реквест. мы на него ответим. если он получит ответ 
то он будет знать что его реквест долетел. а вот мы небудем знать долетел ли до него наш ответ или нет.

на нашем комее это будет выглядеть так.  к нас на комп леттят эхо реквесты. и мы на каэдый отвечаем.
а на удаленном компе это может выглядеть так что он шлет реквесты а ответов нет.

хотя скорей всего нетак. скрей всего когда мы щлем эхо реквесты то они нумеруются. скажем мы отправили
туда реквест номер 1. и вответ ожидаем получить ответ номер 1. значит инфо долетела тудаи обратно.
а если мы в ответ нихера не получим то будем слать повторно реквест  с номером 1. поэтмому с нашего 
компа будут лететь повторно реквесты с номером 1 если от того компа мы неполучаем ответы с номером 1.

таким макаром по мне icmp имеет некоторые признаки протокола TCP.
да icmp неустаналивает содеиненеи перед оптравкой. но зато нумерует свои пакеты. и ждет подверждения
получения их . а если подтвержения нет то шлет этот же пакет заново.
также icmp имет поле identification который позволяет отличать пакет отпралвенные одним процессом
от пакетов отправленных другим процессом этого компа. это аналог порта от tcp.












