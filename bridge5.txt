| bridge

хотел рассмотреть кейс.

у меня был бридж br4

и на нем висел tap17

а на нем висела виртуалка.
и я с хоста никак не мог пингаовать эту
виртуалку. и изнутри виртуалки я не мог
пинговать хост.

в иптейблс стояло все разрещено и стояли 
правиал на логи.

но логи были пусты.

ОКАЗАЛОСЬ все дело было в том что у меня 
бридж был включен в режиме VLAN AWARE
и поэтому с хоста в br4 пакет влетал. дальше
он в ядре никуда не двигался. тоесть если  я  
с хоста пытаюсь пигануть вирталку то у меня
в иптейблс будет срабыать только LOG правиало для
INPUT цепочки. как я уже сказал приложение на хосте
пихает пакет в сокет. оттуда ядро через иптбейлс
пихает его в интервейс BR4  и на этом все заканчи
валось. в реальной сети за br4 должен был сидеть
желеный свич.  в нашем случае пакет влетая в br4 
попадет в  кусок ядра который  ebtables который
обрабывает трафик на уровне свичинга.  итам
этот пакет застревает. и уже в tap17 он недолетает

                                                   ____________ 
                                                   |ebtables   |
приоожение ---- сокет --- ядро иптейблс --- BR4 ---|вирт свич  --- tap17 -- VM
                                                   |ядро       |
                                                   |___________|

вот там в ebtables он и застревает. и уже до tap17
тоесть вирталки не долетает. 
потому что у меня свич был в режиме VLAN AWARE.

если же я пинги инциировал изнутри виртуалки.
тоони влетаеют в tap18 попадают в ebatbles и там
подыхают. и на хосте в iptables логах вообще ничего
не будет. 

если я хотел бы увидеть логи внутри ebtables то 
мне нужно было бы вставлять LOG правила в 
ebtables таблицу.

как распознать то что бридж находится в режиме
VLAN AWARE

 $ nmcli conn sh br3 | grep vlan
 bridge.vlan-filtering:                  yes
 bridge.vlan-default-pvid:               0
 bridge.vlans:                           --


а вот как выглдяит бридж у котрого виланы
выклчены

$ nmcli conn sh br0 | grep vlan
bridge.vlan-filtering:                  no
bridge.vlan-default-pvid:               1
bridge.vlans:                           --


как пеерключить бридж  в режим выклченных виланов
для этого нужно обязтаельно погасить конект.
поменять настройки на порту. и поток обратно
его включить. все три шага обязательны иначе 
не сработает. надо и выключить и включить чтобы
все сраоботало

nmcli conn down br3
nmcli conn modify br3  bridge.vlan-filtering  no
nmcli conn modify br3  bridge.vlan-default-pvid  1
nmcli conn up br3


далеее  я обращаю внимание на праивла иптбейлс.
что там должно стоять чтобы связь работала.
с точки зрения иптбейлс bridge интфрейс это всего 
навсего обычный L3 интфрейс.  с точки зрения 
иптейлс за портом br4 уже лежит сеть. то что за ним
лежит ebtables и порт  tap17 об этом иптбейлс
неподозревает. когда мы с хоста пингует виртуалку
то с точки зрения иптейсс пакет просто через OUTPUT 
цепочку суется в br4 и все. дальше типа он улетел
в сеть. 
а когда с виртуалки летит пакет то для иптейбс все
выглядит так что пакет влетает через порт br4 
в цеопчку INPUT
поэтому с точки зрения иптейблс должны быть вот
такие праивла
никакаго FORWARD нет. потому что с точки зрения
ипьейлс мы пихаем пакет в обывный Л3 порт
и обратно пакет влетает в стек ядра через этот же
Л3 порт. 

            
>>>>   стек ядро ---- OUTPUT ------ br4

             
   стек ядро ----  INPUT ------ br4  <<<<<
   

тоест нет никакоой переброски с порта на порт
поэтому нет никакго FORWARD только OUTPUT 
и INPUT

поэтому
для прохождения трафика который рождается 
на хосте нужны правила

-A OUTPUT -o br+ -p icmp  -j ACCEPT
-A INPUT   -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT



для трафика котоый рождается на виртуалтной
машине нужны правила

-A INPUT  -i br+  -p icmp -j ACCEPT
-A OUTPUT   -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT


теперь когда у нас правално настроен бридж
и кода у нас заданы правла на иптбейлс то пинги
наконец должны начать ходить


замечу еще раз что пинги ходят исключетельно 
через br4 порт и больше не через какой. тоесть 
вот так

   сокет --- br4


мжно воспомнить что в каких то случаях у нас 
пакеты ходят в LO интфрейс. в данном случае этот
кейс не происходит потому что пакеты ходят в LO
интфрейс только в том случае если я из процесса
внутри компа пингую IP сетевого порта нашего
хоста. тоесть например у меня  есть порт em1 
с IP=192.168.10.10
если я из процесса на хосте начну пинговать
192.168.10.10 то ядро будет совать пакеты из сокета
не впорт em1 а в порт LO

в нашем случае если я буду пинговать IP который
имеет сам порт BR4 то ядро будет пихть пакеты
в LO порт. но так как я пингую IP=192.168.10.100
который сидит на tap17 который сидит за BR4 то 
поэтому ядро пихает пакет в BR4  а не в LO.
тоесть с точки зрения ядра 192.168.10.100 это 
хост\порт который находится где то в сети за 
портом BR4 поэтому он в него пакет и сует.
а если я пигую 192.168.10.10 который привязан к BR4
то пихать пакет в этот порт нет смысла. тоесть
физичеки выпускать пакет  в сеть нет смысла.
поэтому он его пихает вместо этого в LO порт.

в общем этот кейс попил у меня крови.

