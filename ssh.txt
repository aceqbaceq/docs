ssh

есть такой файл ~/.ssh/config

в него можно много чего вставлять

HOST  vasya

параметр HOST это алиас для  хоста при доступе по ssh.

если честно неочень понятно зачем это были им городить 
если есть доменная система DNS, однако они нагородили (создатчики ssh проги)

HOST означает ту хрень которую мы будем писать после ssh в командной строке
например


$ ssh vasya
$ ssh petya

если мы хотим для этих хреней особые параметры подключения то мы в 
~/.ssh/config пишем

HOST vasya
HOST petya

также в строке HOST может быть несколько алиасов. они перечисляются через пробел.

HOST vasya petya klava


но это только начало секции. ниже HOST мы уже прописываем так какие 
кастомные параметры мы хотим для них сделать.


параметр HOSTNAME. он неиспользуется сам по себе. его должен предварять
параметр HOST

HOST vasya
   HOSTNAME 8.8.8.8 
   
 
тогда когда мы в строке напишем

$ ssh vasya

то ssh заглянет в конфиг и в реальности постучится на сервер вот так

ssh 8.8.8.8

таким образом HOST как бы выполняет роль доменного имени 
а HOSTNAME как бы выполняет роль IP адреса в который он как бэ резолвится 
ssh прогой и уже именно под ним он стучится на сервер

или 

HOST vasya petya klava
	 HOSTNAME 8.8.8.8

или более диковынные приемчики HOST

Host 192.168.0.?

Host *.co.in

Host *

	 

в HOSTNAME может быть нетолько IP но и доменное имя 
например

HOST vasya
	HOSTNAME mail.ru
	
	
следущий параметр это user

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	
таким образом когда мы 

$ ssh vasya 

то по факту будет 
$ ssh 8.8.8.8 -u pupkin


аналогично параметр port

также можно заходить под логином паролем. 
скажем при таком конфиге 
	
HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin


вход будет под юзер pupkin и будет под логином паролем.

а можно входить вместо пароля под юзер\RSA ключ

тоесть RSA ключ вместо пароля.

тогда конфиг будет 


HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
	
причем тут тоже мудота. как пишут в инете. опция IdentityFile даже 
если мы указали какой кастомный ключ мы хотим юзать все равно вначале
шлет на удаленный хост ключ дефолотовый ~/.ssh/id_rsa или ~/.ssh/id_dsa 
а если удаленный хост это отвергает то тогда уже наш кастомный.
поэтому чтобы этой мудоты небыло также надо добавить опцию

  IdentitiesOnly yes
  
  

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
	
	
с IdentitiesOnly yes будет слаться только тот ключ который мы указали. ура товарищи.


далее есть такая хрень. опция LocalForward

вот мы зашли на сервер по ssh
получается между нашим компом и удаленным поднялось TCP содинение вида

наш_IP:некий порт <-------> удаленный_IP:22

так вот если мы заюзаем опцию LocalForward 



HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
    LocalForward 3308    localhost:9200


то когда мы зайдем на удаленный комп по ssh
то и на нашем компе и на удаленном сервис ssh начнет слушать дополнительно порты.
а именно

	на нашем компе он начнет слушать порт 3308 причем для IP=127.0.0.1
   причем именно прям бинарник ssh ( потому что если сокет какойто 
   поднят на компе его поднял какойто конкретный бинарник)

	$ netstat -tnlp
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:3308          0.0.0.0:*               LISTEN      31349/ssh

а на удаленном компе ssh неподнимает никакой доп сокет для себя нет.
там уже должен быть поднят сокет каким то сервисом. 

причем между компами никакого дополнительной tcp конекшнена несоздается.
далее схема такая

если мы на нашем компе обратимся по сокету  127.0.0.1:3308
то ssh перенеправить через наше текущее ssh соедниение реквест (проксирует)
на удаленный комп на его сокет localhost:9200 
таким образом мы имеем проброс порта. обращаясь на сокет нашего компа
мы попадаем на сокет удаленного компа. 
едиснвтенное что непонятно это как на удаленном компе система различает 
пернаправлять реквест  который пришел на localhost:9200 на удаленный мой комп 
или нет. может там в iptables прписываются доп правила?

в любом случае вот такое назначение опции localforward. пробросить локаьный порт
на удаленный комп через ssh соединение.

при этом опять же важно понимать что порты localforward никоим образом невлияют
на порты по которым устанавливается самое ssh содеиненеи.

опция ProxyCommand - позволяет указать первый ssh сервер через который мы хотим попасть на 
другой ssh сервер

например ProxyCommand ssh -q -A vasya@kuku nc %h %p

-q = quiet mode
-A = enable forward как я поимаю именно эта опция позволяет аутентифицроваться
на одном хосте и на втором уже этого повторно делать ненадо

vasya это логин
kuku это alias первого ssh сервера. раз алиас значит
надо его распиывать в ~/.ssh/config  

nc это утилита netcat. и эта хрень тоже участвует в проброске TCP
содененеия с одного компа на другой. 
с этим надо еще разбираться.

   
------
для того чтобы при входе в ssh ненужно было вводить пароль
от RSA приватного ключа то нужно запустить ssh agent

как япроверил от имени непривлигорванного пользлователя. тоесть под тем же
юзером что и тот юзер под которым ты входишь в ssh


$ ssh-agent

провереяем что он запутился как процесм

$ ps aux | grep ssh-agent

далее надо добавить в него налету приватный ключ

$ ssh-add ~/.ssh/название_приватного_ключа

готово.

после перзагурзки компа опять все заново.

----------------
начинаю фундаментальную статью как работает ssh

значит работа ssh начинается с такого этапа насколлько  я понял как договаривание
о методе ассиметричного шифрования(их несколько). пока здесь я оставлю пусто вместо описания как это происходит.

асиметричный алогритм зачем он в чем его фишка в том что для шифровки иползуется один ключ а для расшифровки другой. о нем еще поговорим ниже но конечная цель применения ассиметричного шифрования это выработать некую комбинацию символов (ключ). это конечная цель применения на этом этапе ассмиетричнго широфвания. как только на клиенте и сервере появился этот ключ то можно начинать использовать уже симметричное шифрование. а полученный ключ как раз будет 
использоваться как ключ этого симметричного шифрования. таким образом ассиметричное шифрование
позволяет незная друг о друге почти ничего создать канал безопасный связи и по этому каналу
передать друг другу (договориться) небольшой кусочек информации а именно ключ. насколько я понимаю использовать на первом этапе симметричное шифрование невозможно потому что в отличие 
от ассиметричного шифрования в симметричном нельзя создать канал связи незная друг о друге ничего. ассиметричное шифрование однако сильно грузит цпу поэтому для передачи больших обьемов данных подходит плохо. для устанолвения безопасного канал связи друг с другом незная друг о друге ничего оно подходит хорошо. для передачи небольшого количество информации тоже подходит
нормально а вот для передачи большого обьема ифонмаации уже плохо ибо оно цпу грузит . поэтому 
коненым продуктом ассиметрик шифрвания будет всего навсего ключик. а далее уже запукается симетричный алогритм шифрования который использует выработанный на прердыдущем этапе ключ
который есть уже и на клиенте и на сервере и при своей работе он негрузит цпу так сильно.
итак мы поняли зачем нужен какая роль у ассметрик широфания и у симметрик шифрвания.
про ассиметрик шифования. генерируется два ключа приватный и публичный. 
приватный хранится на сервере в секрете. а публичнй сообщается всем кому подряда наружу. 
любой кто снаружи (клиент) может взять и с поомощью публичного ключа сервера зашифровать
сообщение и послать серверу. фишка в том что толлько сервер имея приватный ключ может 
расшировать сообщение. также фишка в том что зная приватный ключ из него легко получается публиынй ключ. а наоборот невозможно. тоесть зная публичный ключ невзомжно из него вычислить приватный ключ. поэтому то публичный ключ и можно без боязни всем раздавать.


покончили с теорией возврашаемся обратно. итак клиент и сервер договориллись о методе асметрик широфания.
когда они договорлись о методе они к нему приступают.
теперь их задача обеменяться друг с другом своими публичными ключами. 
причем нас как клиента очень интересует как то проверить что полученный от сервера 
публичный ключ что это действтельно публичный ключ от сервер а не от злодея посередине. потому что да меджу нами и сервером может сидеть злодей. он контролрует канал междунами и сервером
и он может легко на наш запрос нам послать свой злодейский пубичнйы ключ который к серверу неимеет никакого отношения. так что нам надо проверить что полученный ключ ддействиительно
от сервера. и тут как я понимаю красивого компьютерого способа нет! а есть способ ручной.
тоесть человек который сидит на сервере он берет публичный ключ на сервере ( на линуксе асиметричные ключи сервера называются host keys. лежат они в папке /etc/ssh )

$ ls -1 /etc/ssh
ssh_host_ecdsa_key
ssh_host_ecdsa_key.pub
ssh_host_ed25519_key
ssh_host_ed25519_key.pub
ssh_host_rsa_key
ssh_host_rsa_key.pub


значит видно что у нас несколько штук этих ключей. есть приватный и есть ему публичный. 
их несколько видов потому что линукс поддерживает несколко видов ассиметричного шифрования. 
почему я и сказал что на первом этапе клиент и сервер должны догвоорится(в автоматическом режиме) какое именно
асмиетрик шифрование они будут совмпстно юзать. так вот положим что используется 
RSA шифроание. тогда человек ( да да именно человек) должен руками зайти на сервер
найти публичный (дада именно публичный) ключ и вычислить от него хэш руками. обычно у нас два алгоритма для хэша это sha256 и md5. итак человек берет и руками на сервере вычисляет 
хэш для публичного ключа сервера (ключ берется тот который соотсвтетует выбранному ранее в автоматическом режиме между клиентом и сервером асиметрик виду шифрования). тут  я еще раз хочу подчеркнуть что вид асиметрик шифрования выбирается между клиентом и сервером автоматически без участия человека. я щас покажу как нам узнать какой метод был выбран чуть ниже. так вот что еще я хочу подчеркнуть что человек должен зайти на сервер и уже неавтоматически а руками уточнить хэш для публичного ключа соотсвтуетющего выбранному методу асметрик шифрования. руками. руками!

sha256
# ssh-keygen -l -E sha256 -f ./ssh_host_rsa_key.pub 
2048 SHA256:iBSI/ZduKsZ3V6TzyQmgc5/vLxEVnmCOiK2F3nw/NZ0 root@vagrant (RSA)

# ssh-keygen -l -E md5 -f ./ssh_host_rsa_key.pub 
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

и далее самое главное этот человек с сервера должен сообщить нам (клиенту) через какойто человеческий способ комуникации тоесть через телефон или по почту послать либо sha256 хэш
либо md5 хэш.  на мой взгляд хэш sha256 абсолютно непригоден для общения между людьми. 
и только хэш md5 пригоден.
итак человек с сервера звонит нам по телефону и голосом сообщает эту строку
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

что такое хэш. хэш это маппинг отображения аргумента в некоторый более компактный вид.
в чем фишки хэша. в одну сторону он вычисляется быстро и просто .то есть если есть x то хэш(x)
вычсляется быстор и просто а вот зная хэш высчитать исходный x невозможно. это очень хорошо.
и второе что хэш по размеру гораздо компактнее чем исходный x. где применяется хэш. например 
для хранения паролей. но не в открытом исходном виде а ввиде хэша. что это дает. 
на линуксе человек вводит пароль. ос высчитывает от него хэш а затем сравнивает с сохраненным в файле хэшем. если они совпали то человек ввел правильый пароль. если ктото спер с хоста файл с хэшами о это злодею ничего недаст ибо зная хэш вычислить исходный x невозможно. насколько я понимаю считается что нет двух таких x чтобы у них было общий хэш или для этого мала вероятность. тоесть скажем мы незнаем пароль но мы ввели левый пароль и так совпало что его хэш совпал с хэшем от реального пароля типа так небывает. таким образом хэш это досттаточно хороший способ проверить достоверность исходного x. например мы скачали прогу и у нас от нее есть полученный через надежный канал хэш. мы высиляем на компе хэш от файла скачаной проги и сравниваем с хэшем что у нас есть . если совпало значитможно достверно верить что мы скачали оригинальную программу а не подкоректрованную. (crc в этом плане ненадежно ксати ибо можно так подделать исходный x что мы будем иметь тот же crc). 

так вот взрвршаемся к нашей задаче. нам нужно как клиенту убедиться что полученый от сервера
публичный ключ дейвительно получен от сервера а  не от злодея. для этого человек с сервера 
нам должен по телефону сообщить публичный ключ сервера. но публичный ключ сервера очень длинный
например
# cat  ./ssh_host_rsa_key.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9 root@vagrant

совершенно невозможно такой ключ диктовать по телефону. и потом сраавнивать с тем что мы получим от сервера. поэтому человек с сервера по телефону нам передает несам публичный ключ а
передает его хэш. еще раз можно было бы передать по телефону сам публичный ключ в его оригинальном виде ибо это не секретная информция. но как видно ключ очен длинный. а его нужно 
будет нетолько получить по телефону но и и потом сравнить с тем что мы получим от сервера.
пэтому исползуется хэш как средство сжатого вида.

значит по телфону нам продиктуют хэш md5
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

видно что такой вид очень компактный  и с ним можно раоботаь глазами.
итак мы получили от человека с сервера хэш публичного ключа сервера.

далее. мы с клиента начинаем ломиться на сервер.
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здест я хочу сказать о некотором дебилизме клиента ssh. дело в том что опции -o нельзя указать
сразу все. их можно указывать только строго по одной. тоесть вот так работает 
ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa
а вот так неработает
ssh -o FingerprintHash=md5,  HostKeyAlgorithms=ssh-rsa

теперь про сами опции
100.0.0.6 === это понятное дело адрес сервера
HostKeyAlgorithms=ssh-rs === это мы сообщаем на сервер что мы хотим с ним связываться через RSA
(дело в том что в линуксе по дефолту клиент пытается установить связь не через RSA а через ECDSA)
FingerprintHash=md5 === это мы сообщаем серверу чтобы он нам прислал хэш публичного своего ключа в виде md5 потому что по дефолту он шлет нам его в виде SHA256 который как мы уже поняли
совершенно нечитаемый

итак опции разобрали. в них мы заказываем на сервере параметры связи.
посмотрим что мы видим на экране в результате.

The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здесь мы видим что сервер нам прислал md5 хэш своего публичного ключа.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

точнее мы пока что незнаем то ли эта инфо прилетела от сервера то ли от злодея между нами 
и сервером. но мы теперь можем сравнить совпадает ли md5 с бумажки которую нам по телефону
продиктовали  с тем что мы увидели на экране.

бумажка:
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

экран:
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

значит мы видим что нам присылали бумажку для RSA ключа и экран нам показывает 
что RSA ключ. теперь сравним сами хэши

бумажка:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5
экран:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5

сравниваем глазами совпадает. это значит что действительно мы получили хэш публичного ключа 
сервера именно от сервера а не хэш публичного ключа от сервера злодея.
Итак отмечаю здесь еще раз то проверить достоверность полученного  хэша что он действиельно
от сервера автоматическим способом невоможно. нужен звонок друга и проверка вручную глазами.

что это нам дает. то что теперь когда мы знаем что полученный хэш дейсвтиельно оригинальный
то я так подразумеваю что вместе с хэшем от сервера прилетает и сам публичный ключ 
и мы теперь зная что хэш подлинный можем взять присланный публичный ключ посчитать сами
от него хэш сравниить с присланными понять настоящий ли он. и поняв что он настоящий 
мы теперь можем зашифровать нечто и послать на сервер и только сервер это сможет расширофвать.
тут еще важное дополнение что глазами сличать хэш с хэшем с бумажки приедется только один 
раз в жизни. еслимы подтверждаем на экране что хэш верный то он заносится на клиенте в файл known_hosts о чем  нам на экране ssh пишет и при всех следущих конектах к хосту
наша ос небудет нас спрашивать про достверность хэша а будем сличать с тем что в known_hosts.
а если когда то она получить хэш который несовпдает с тем что сохранен в known_hosts
то она на экране напишет что внимание я получила хэш другой чем в known_hosts и это скорее всего означает что хэш нам прислал злодей. и нужно отказатся от сеанса связи такой.

вот как на экране система пишет что она сохранила хэш когда мы подтвердили что он 
поодлинный в файл known hosts:
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '100.0.0.6' (RSA) to the list of known hosts.

файл у нас (клиента) этот лежит в 
$ ls -1 /home/vasya/.ssh
...
known_hosts

итак для хоста 100.0.0.6 хэш его публичного ключа был записан системой в known_hosts.
поищем ка теперь его там.

вот как выглядит known_hosts если мы запретили хэшить имя удаленного сервера
(наш комп)$ cat known_hosts
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

вот как на самом удаленном сервере выглядит файл с публичным ключом
(удаленный сервер)# cat /etc/ssh/ssh_host_rsa_key.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9 root@vagrant

почему то на нашем компе в known_hosts нет root@vagrant. непонятно об этом мы поговорим
где то ниже. в остальном получается что known_hosts строчка состоит из полей:

имя_сервера    тип_ассиметричного_шифрования     публичный_ключ(нехешированный)

Но! на самом деле так known_hosts выглядит если на нашем компе в /etc/ssh/ssh_config ( это файл отвечает за настройки ssh клиента (тоесть когда мы с нашего компа ломимся на удаленный сервер в отличие от sshd_config конфига когда наш комп используется как сервер на принятие от ругих ssh соединений)) стоит настройка 
(наш комп)$ cat /etc/ssh/ssh_config | grep -i hash
    HashKnownHosts no

так вот обычно там стоит как раз обратная настройка. то есть yes. 
когда она yes то у нас имя сервера ( в нашем примере это 100.0.0.6 ) записывается не в открытом  виде а в виде хэша. (зачем пока незнаю). но еще раз скажу пока мы рассматриваем
случай когда HashKnownHosts no. случай когда он равен yes рассмотрим ниже несейчас.
так вот.  еще раз. мы постучали с нашего компа на удаленный сервер
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6

при этом на нашем компе в known_hosts получили запись
$ cat known_hosts
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

далее очень интеересный момент. стучим на тот же сервер но требуем использовать не RSA
в качесвте асиметричного шифрования а ecdsa-sha2-nistp256 (об нем подробнее ниже)
и получаем жесточайший варнинг от линукса
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

суть этой надписи в том что наш комп имеет уже сохраенный ключ асмиметричного
шифрования который мы ранее одобрили. далее наш комп подключается к серверу и получаем
 в ответ публичный ключ совершенно другой. из чего комп делает вывод что получнный публичный
 ключ не от сервера а от злодея который сидит между нами и сервером. в  данном случае никакого 
злодея нет. просто мы к тому же серверу обращаемся по другому ассиметричному протоколу и получаем другой публичный ключ. ОТСЮДА я делаю вывод что в known_hosts для одного удаленного
сервера который идентифицируется в нашем случае ip адресом может находиться ТОЛЬКО ОДНА СТРОЧКА! линукс непозволяет иметь несколько строчек для одного удаленного сервера даже если
в этих строчках указаны разные асиметричные алгоритмы шифрования. это очень важно.

узнать какие алгоритмы шифроваия поддеживает удаленнй сервер по быстрому можно через ssh-keyscan

$ ssh-keyscan  100.0.0.6

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAqCgW5Mlx2VpC61acc0G4VMZUAauQDoK5xIzdHzdDLPXt0GqsoIw1fuwTSSzSy8RFmGU5PNHiWn0egoUwlXdc4=

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

он просканровал удаленный сервер и узнал что тот поддеживает RSA, ecdsa-sha2-nistp256, 
ssh-ed25519

Далее еще один очень важный момент. Когда мы обращаемся к удаленному серверу по IP 
то все понятно в known_hosts будет указан IP. а что если мы обращаемся к удаленному 
серверу через доменное имя. что вэтом случае будет в known_hosts.
ответ такой - если у нас прописан резоволинг dns в IP в /etc/hosts либо такой же резолвинг
идет через внешний DNS сервер то в known_hosts будет содержаь доменное имя+IP 
пример:
$ cat /etc/hosts
100.0.0.6 vasya.local

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
The authenticity of host 'vasya.local (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? yes

смотрим что в known_hosts
$ cat known_hosts
vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

тоесть мы видим что указано и vasya.local и 100.0.0.6

также видно что когда мы устанавлаием соединенеи то эта же инфо указана в
The authenticity of host 'vasya.local (100.0.0.6)' can't be established
тоесть нам клиент уже подсказывает что он пропишет в качестве идентификатора сервера в
known_hosts

в man 8 sshd указано что в known_hosts можно указывать вайлдкарды. тоесть скажем вместо
vasya.local указать vasya*


$ cat known_hosts
vasya*,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

и это реально работает! однако это работает только при настройке  HashKnownHosts no. когда у нас domain name\IP нехэширован. когда же он хэширован то мы так уже подкоректировать руками
known_hosts не сможем.

Так вот я продолжаю тему о том что если у нас доменное имя не прописано в /etc/hosts
или во внешнем доменном сервере а вместо этого мы используем ~/.ssh/config
вот с такой записью:

$ cat ~/.ssh/config 
HOST vasya.local
    HOSTNAME 100.0.0.6

и мы обращаемся к серверу по доменному имени
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local

то тогда в known_hosts будет записано не доменное имя а  IP как идентификатор удаленного сервера.
я проверил это. 
также практика показала что если есть запись в /etc/hosts и есть запись в ~/.ssh/config
то запись в ~/.ssh/config превалирует. 
Таким образом если мы хотим чтобы в known_hosts присутсовало именно доменное имя
то надо чтобы если мы используем ~/.ssh/config то там хост был прописан как доменное
имя а не как IP адрес. например.

$ cat ~/.ssh/config


HOST vasya.local
    HOSTNAME vasya.local

при этом
$ cat /etc/hosts
100.0.0.6 vasya.local


тогда 
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
даст
$ cat known_hosts
vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9


но опять же можно заметить что даже если у нас система вписала доменное
имя то она всегда обязательно прорисывает и IP адрес. так что от IP адреса
никак неизбавиться.!

что интересно. я зашел на удаленнйы хост и сменил его ip на 100.0.0.8
далее я на нашем компе постучал на сервер 
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
тогда система вот что сделала
$ cat known_hosts

vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9


она добавила новую строчку и использовала IP=100.0.0.8
далее я удаляю верхнюю строчку в known_hosts
еще раз стучуь по доменному имени
получаю такое в known_hosts

$ cat known_hosts

100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

vasya.local ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

далее я удаляю строчку с vasya.local
стучусь еще раз
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

удаляю строчку с 100.0.0.8
стучу еще раз получаю

$ cat known_hosts
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg
100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

удаляю обе строчки
стучу еще раз
получаю

$ cat known_hosts
vasya.local,100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

из чего я суммарно делаю вывод - если мы стучиммся на сервер по его доменному имени
и в config нет его резоолвинга в IP то клиент ищет в known_hosts строчку где указано 
доменное имя. если в этой строчке указано толко доменное имя без IP то клиент
делает еще доп проверку и ищет строчку где есть IP и сравнивает одинаковые ли ключи или нет.
если нет то клиент ругается. как это было в этом случае:

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

в целом я бы сдела такой вывод - как ни извращайся но клиент будет всегда вставлять строчку в known_hosts которая обязательно будет содержать IP сервера (неважно как мы  к нему обращаемся по IP или по доменному имени). если мы обращаемся к серверу по IP то  в файле будет прописан IP. если мы обращаемся к серверу первый раз и по доменному имени то в файле в одной строке
будет указано и доменное имя и IP. если в файле уже есть либо такой IP либо такое доменное
имя то будет создана доп строчка с тем чегонехватает. тоесть если мы обратлись по доменному имени а в файле для IP уже есть запись то будет созана вторая строчка с только доменным
именем. если у нас есть две строчки в которой в одной только доменное имя а в другой только
IP и указаные разные ключи (так хитро мы смогли сделать) то система будет ругаться и говорить
что у нас одна строка противорчеит другой как в этом примере:

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg


в целом я бы сказал так что для себя клиент в конченом итоге идентифицирует хост именно по IP 
как ни ивзращайся и с этим IP обязатлеьно будет строчка в known_hosts и еще то что 
для одного IP в known_hosts может быть только один ключ. неможет быть два ключа даже 
если при этом указаны разные алгоритмы несимметричного шифрования. система будет ругаться вот так:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

так что если уж когда то полкючились к хосту через RSA и такой то ключ
то будь добр только так к этому хосту и подключаться. а если решил сменить 
RSA на ECSA то вначале удали из known_hosts прежний ключ вотак

$ ssh-keygen -f "/home/vasya/.ssh/known_hosts" -R "100.0.0.6"

еще раз подчеркн что  хост неможет иметь в known_hosts разные ключи.тоесть строчка может 
быть только одна! при этом неважно что раньше мы связывалист с ним по RSA а щас по ECDSA.
невоможно это обойти тем что мы будет обращаться к хосту скажем по IP по RSA
а по доменному имени по ECDSA. этот номер непродет. как бы мы ни обраащались к хосту в коечном итоге клиент ожидает что в known_hosts либо есть одна строка с одним ключом и в этой строке
укзано и доменное имя и IP либо там есть две строки в одной IP в другой доменное имя 
но в обоих строках ключ должен быть одинаковый. так что обмануть обойти это недуастся.
итого - одному хосту один ключ один алгоритм ассмиетричного шифрования. так подразумевает
клиент. иначе он будет псоылать нахер.

в этом плане ксати интересно что github опубликовал хэши своих публичных ключей
https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 (RSA)
SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM (ECDSA)
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU (Ed25519

вот что показывает про github ssh-keyscan

$ ssh-keyscan github.com

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=

таким образом через ssh-keyscan
мы знаем что github поддерживает для связи с ним по ssh следущие ассиметричные 
протоколы:ssh-rsa, ssh-ed25519, ecdsa-sha2-nistp256

и что для этим протоколов оригинаьоьные хэши публичных ключей являются:
SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 (RSA)
SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM (ECDSA)
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU (Ed25519)


таким образом мы можем выбрать протокол который нам больше нравится
и знаем как дожен выглядеть оригиальный хэш публичного ключа. 

вот как выглядит known_hosts 
после того как мы вошли мы подключлись к гитхабу по ssh
$ cat known_hosts
github.com,140.82.121.3 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=

здесь мы видим и доменное имя и IP

еще раз полезная команда которая дает хэш публичного ключа(неважно это наш публичный клиентский ключ которым мы аутентифицируемся на гитхабе к примеру или это публичный ключ 
нашего ssh линукс сервера который видят клиенты котрые к нему покдлючаются)
$ ssh-keygen -l -f id_ed25519.pub
256 SHA256:f+lgxW9HzT1QCQj3GvKmtQh6LwJ/1d3STiDQ5cuHNHI vasya@gmail.com (ED25519)



- проанализиовать $ ssh git@github.com -v
- я вот чото непойму . на гитхабе столкулся у меня сгенерирован ed25519 ключ. но при конекте к гитхабу он конектился успешно через этот ключ но по протоколу ECDSA
попробовать такое провернуть на примере связи с вирт машиной.
а так чтобы исключить это гавно я почистил known_hosts
и в config добавил
$ cat ./config 
HOST github.com
    HOSTNAME github.com
    IdentityFile /home/vasya/.ssh/id_ed25519
    user git
    FingerprintHash sha256     # в каком виде нам показывать хэш 
    HostKeyAlgorithms ssh-ed25519  # по какому ассим протоколу стучать на гитхаб




- вопрос как git push -v понимает как ключ надо использовать для аутентифкации. ведь у меня их много
- man 8 sshd искать формат known_hosts. прочитать проработать
- known_hosts как там найти заданный хост или хэш ? его формат есть в man 8 sshd
- формат known_hosts

- расмотреть случай когда HashKnownHosts yes
- из примера что выше почему в 
(удаленный сервер)# cat /etc/ssh/ssh_host_rsa_key.pub 
есть root@vagrant
а в
(наш комп)$ cat known_hosts
его уже нет

- ssh-rsa vs ecdsa-sha2-nistp256 vs ssh-ed25519

- выяснилась офимегнная вещь. есть sshd_config а  есть ssh_config.
sshd_config это конфиг для сервера ssh тоесть когда наш комп является сервером и принимает
запросы от других и это его конфиг файл. а ssh_config это когда мы с нашего пользуемся клиентом ssh и это его конфиг файл! 
- непонятно ~/.ssh/config это локальный аналог sshd_config или ssh_config. 
насколько я понимаб локального аналога для sshd_config быть неможет . поэтому
~/.ssh/config это аналог ssh_config. тогда непонятно почему опция HashKnownHosts no 
прописанна я в config несрабаывает и срабатывает если ее запихунть только в ssh_config

- формат публичного ключа
- sshd -T 
- ssh-keyscan
- написать какие файлы мы уже затронули для чего ни используется в ssh (наример known_hosts)
- чтобы несравнивать глазами как сравнить два хэша ?
- md5sum binary vs text? какая разница?
- On  systems like GNU that do not distinguish between binary and text
     files, this option merely flags each input mode as binary: the MD5
     checksum is unaffected
- md5sum для публичного ключа несовпдаает с ssh-keygen
тоесть
cat /etc/ssh/key.pub | md5sum  
и
ssh-keygen -fl /etc/ssh/key.pub 
выдает совсем разные хэши. почему? непонятно
- что интересно md5sum он всегда вавыодит хэш без знаков : в отличие от ssh-keygen
- < vs  << vs <<< bash ?
- man md5sum : Do not use the MD5 algorithm for security related purposes. почему?
- надо понять sha256 это наш клиент по деолту так просит или сервер по дефолту так шлет
- где посмотреть какой асиметрик метод первым шлется на сервер (  я про ECDSA который по дефолту предлагается)
- я щас покажу как нам узнать какой метод был выбран чуть ниже. 
- $ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
дебилизмы с -o
- где на клиенстой машине берется публичный ключ который шлется серверу. 
тот публичный ключ котоый используется для создания первичного безопасного канала
- еще такой вадный момент что мы рассматривали как нам важно узнать что публик кей реально 
от сервера. а что насчет сервера? важно ли ему чтобы он знал что наш клиенсткий
ключ исходит именно от нас. в общем случае нет. любой публичнй ключ что от нас что 
от злодея для сервера это полноценный ключ. на основе этих ключей будет устанолвен безопасный
канал между сервером и нами либо между сервером и злодеем. в любом случае небудет тресторонней
цепочти типа мы злодей сервер. тоесть канал шифрования дает то что между точно сервером и 
непонятно каким то есть любымт клиентом  с гарантией что нет третьего участинка устаналивается
безпонаснвй канал. когда он устанолвен то наступает фаза аутентификации клиента. клиент аутентифиаицирцется внутри этого безпоасного канала либо через логин пароль либо через публичный ключ и так понимаю что это неможет быть другой ключ отличный от того что участвовал
в создании безопасного канала (верно неверно?). через аутентифцаицию сервер понимает что 
эт непросто вообще клиент а именно этот клеинт. есл через ключ то на сервере нужно заблаговременно добавлять хэш публичного ключа клиента ( верно неверно?)

- вопрос асиметрик метод и симетрик метод о них договоариваются сразу на первом этапе за один раз или на разных
этапах. 

- вопрос симметрис vs asymtryc. на первом этапе неиспользуется асссиметричное шфиование. почему?потому что с его помощью невозможно беопасно выработать общий ключ ? типа асиметрик шифрование
это единственный способ? ассмтерик шифрование неиспользуеся дляпердачи больших данных потому 
что оно супер тяжелое по сравнению с симметрик шифрованием ?

- как договвариваются клиент и сервер (причем надежно чтоб мэн ин зе мидл не влез) о 
о начальных параметрах сеанса. например о способе ассметриченого шифрования.
- ssh vs ssl ?
- ssh vs ipsec
- дифи хельман ?
- ssh на циско
- походу ssh это всегда async шифрвание вначале  а потом sync шифрование?
- а какой протокол на sync у ssh ?
- получается три фазы? фаза обмена параметрами, асинк шифр, синк шифр? разница с ipsec?
- hmac ?
- при команде $ vagrant ssh имя_вируталки 
по факту в списке процессов появлется такой
/usr/bin/ssh vagrant@127.0.0.1 -p 2222 -o LogLevel=FATAL -o Compression=yes -o DSAAuthentication=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /home/vasya/.vagrant.d/insecure_private_key -o ForwardAgent=yes
разобрать ключи. 
кстати сразу видно какой приватный ключ используется === -i /home/vasya/.vagrant.d/insecure_private_key

