ssh

есть такой файл ~/.ssh/config

в него можно много чего вставлять

HOST  vasya

параметр HOST это алиас для  хоста при доступе по ssh.

если честно неочень понятно зачем это были им городить 
если есть доменная система DNS, однако они нагородили (создатчики ssh проги)

HOST означает ту хрень которую мы будем писать после ssh в командной строке
например


$ ssh vasya
$ ssh petya

если мы хотим для этих хреней особые параметры подключения то мы в 
~/.ssh/config пишем

HOST vasya
HOST petya

также в строке HOST может быть несколько алиасов. они перечисляются через пробел.

HOST vasya petya klava


но это только начало секции. ниже HOST мы уже прописываем так какие 
кастомные параметры мы хотим для них сделать.


параметр HOSTNAME. он неиспользуется сам по себе. его должен предварять
параметр HOST

HOST vasya
   HOSTNAME 8.8.8.8 
   
 
тогда когда мы в строке напишем

$ ssh vasya

то ssh заглянет в конфиг и в реальности постучится на сервер вот так

ssh 8.8.8.8

таким образом HOST как бы выполняет роль доменного имени 
а HOSTNAME как бы выполняет роль IP адреса в который он как бэ резолвится 
ssh прогой и уже именно под ним он стучится на сервер

или 

HOST vasya petya klava
	 HOSTNAME 8.8.8.8

или более диковынные приемчики HOST

Host 192.168.0.?

Host *.co.in

Host *

	 

в HOSTNAME может быть нетолько IP но и доменное имя 
например

HOST vasya
	HOSTNAME mail.ru
	
	
следущий параметр это user

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	
таким образом когда мы 

$ ssh vasya 

то по факту будет 
$ ssh 8.8.8.8 -u pupkin


аналогично параметр port

также можно заходить под логином паролем. 
скажем при таком конфиге 
	
HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin


вход будет под юзер pupkin и будет под логином паролем.

а можно входить вместо пароля под юзер\RSA ключ

тоесть RSA ключ вместо пароля.

тогда конфиг будет 


HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
	
причем тут тоже мудота. как пишут в инете. опция IdentityFile даже 
если мы указали какой кастомный ключ мы хотим юзать все равно вначале
шлет на удаленный хост ключ дефолотовый ~/.ssh/id_rsa или ~/.ssh/id_dsa 
а если удаленный хост это отвергает то тогда уже наш кастомный.
поэтому чтобы этой мудоты небыло также надо добавить опцию

  IdentitiesOnly yes
  
  

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
	
	
с IdentitiesOnly yes будет слаться только тот ключ который мы указали. ура товарищи.


далее есть такая хрень. опция LocalForward

вот мы зашли на сервер по ssh
получается между нашим компом и удаленным поднялось TCP содинение вида

наш_IP:некий порт <-------> удаленный_IP:22

так вот если мы заюзаем опцию LocalForward 



HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
    LocalForward 3308    localhost:9200


то когда мы зайдем на удаленный комп по ssh
то и на нашем компе и на удаленном сервис ssh начнет слушать дополнительно порты.
а именно

	на нашем компе он начнет слушать порт 3308 причем для IP=127.0.0.1
   причем именно прям бинарник ssh ( потому что если сокет какойто 
   поднят на компе его поднял какойто конкретный бинарник)

	$ netstat -tnlp
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:3308          0.0.0.0:*               LISTEN      31349/ssh

а на удаленном компе ssh неподнимает никакой доп сокет для себя нет.
там уже должен быть поднят сокет каким то сервисом. 

причем между компами никакого дополнительной tcp конекшнена несоздается.
далее схема такая

если мы на нашем компе обратимся по сокету  127.0.0.1:3308
то ssh перенеправить через наше текущее ssh соедниение реквест (проксирует)
на удаленный комп на его сокет localhost:9200 
таким образом мы имеем проброс порта. обращаясь на сокет нашего компа
мы попадаем на сокет удаленного компа. 
едиснвтенное что непонятно это как на удаленном компе система различает 
пернаправлять реквест  который пришел на localhost:9200 на удаленный мой комп 
или нет. может там в iptables прписываются доп правила?

в любом случае вот такое назначение опции localforward. пробросить локаьный порт
на удаленный комп через ssh соединение.

при этом опять же важно понимать что порты localforward никоим образом невлияют
на порты по которым устанавливается самое ssh содеиненеи.

опция ProxyCommand - позволяет указать первый ssh сервер через который мы хотим попасть на 
другой ssh сервер

например ProxyCommand ssh -q -A vasya@kuku nc %h %p

-q = quiet mode
-A = enable forward как я поимаю именно эта опция позволяет аутентифицроваться
на одном хосте и на втором уже этого повторно делать ненадо

vasya это логин
kuku это alias первого ssh сервера. раз алиас значит
надо его распиывать в ~/.ssh/config  

nc это утилита netcat. и эта хрень тоже участвует в проброске TCP
содененеия с одного компа на другой. 
с этим надо еще разбираться.

   
------
для того чтобы при входе в ssh ненужно было вводить пароль
от RSA приватного ключа то нужно запустить ssh agent

как япроверил от имени непривлигорванного пользлователя. тоесть под тем же
юзером что и тот юзер под которым ты входишь в ssh


$ ssh-agent

провереяем что он запутился как процесм

$ ps aux | grep ssh-agent

далее надо добавить в него налету приватный ключ

$ ssh-add ~/.ssh/название_приватного_ключа

готово.

после перзагурзки компа опять все заново.

----------------
начинаю фундаментальную статью как работает ssh

значит работа ssh начинается с такого этапа насколлько  я понял как договаривание
о методе ассиметричного шифрования(их несколько). пока здесь я оставлю пусто вместо описания как это происходит.

асиметричный алогритм зачем он в чем его фишка в том что для шифровки иползуется один ключ а для расшифровки другой. о нем еще поговорим ниже но конечная цель применения ассиметричного шифрования это выработать некую комбинацию символов (ключ). это конечная цель применения на этом этапе ассмиетричнго широфвания. как только на клиенте и сервере появился этот ключ то можно начинать использовать уже симметричное шифрование. а полученный ключ как раз будет 
использоваться как ключ этого симметричного шифрования. таким образом ассиметричное шифрование
позволяет незная друг о друге почти ничего создать канал безопасный связи и по этому каналу
передать друг другу (договориться) небольшой кусочек информации а именно ключ. насколько я понимаю использовать на первом этапе симметричное шифрование невозможно потому что в отличие 
от ассиметричного шифрования в симметричном нельзя создать канал связи незная друг о друге ничего. ассиметричное шифрование однако сильно грузит цпу поэтому для передачи больших обьемов данных подходит плохо. для устанолвения безопасного канал связи друг с другом незная друг о друге ничего оно подходит хорошо. для передачи небольшого количество информации тоже подходит
нормально а вот для передачи большого обьема ифонмаации уже плохо ибо оно цпу грузит . поэтому 
коненым продуктом ассиметрик шифрвания будет всего навсего ключик. а далее уже запукается симетричный алогритм шифрования который использует выработанный на прердыдущем этапе ключ
который есть уже и на клиенте и на сервере и при своей работе он негрузит цпу так сильно.
итак мы поняли зачем нужен какая роль у ассметрик широфания и у симметрик шифрвания.
про ассиметрик шифования. генерируется два ключа приватный и публичный. 
приватный хранится на сервере в секрете. а публичнй сообщается всем кому подряда наружу. 
любой кто снаружи (клиент) может взять и с поомощью публичного ключа сервера зашифровать
сообщение и послать серверу. фишка в том что толлько сервер имея приватный ключ может 
расшировать сообщение. также фишка в том что зная приватный ключ из него легко получается публиынй ключ. а наоборот невозможно. тоесть зная публичный ключ невзомжно из него вычислить приватный ключ. поэтому то публичный ключ и можно без боязни всем раздавать.


покончили с теорией возврашаемся обратно. итак клиент и сервер договориллись о методе асметрик широфания.
когда они договорлись о методе они к нему приступают.
теперь их задача обеменяться друг с другом своими публичными ключами. 
причем нас как клиента очень интересует как то проверить что полученный от сервера 
публичный ключ что это действтельно публичный ключ от сервер а не от злодея посередине. потому что да меджу нами и сервером может сидеть злодей. он контролрует канал междунами и сервером
и он может легко на наш запрос нам послать свой злодейский пубичнйы ключ который к серверу неимеет никакого отношения. так что нам надо проверить что полученный ключ ддействиительно
от сервера. и тут как я понимаю красивого компьютерого способа нет! а есть способ ручной.
тоесть человек который сидит на сервере он берет публичный ключ на сервере ( на линуксе асиметричные ключи сервера называются host keys. лежат они в папке /etc/ssh )

$ ls -1 /etc/ssh
ssh_host_ecdsa_key
ssh_host_ecdsa_key.pub
ssh_host_ed25519_key
ssh_host_ed25519_key.pub
ssh_host_rsa_key
ssh_host_rsa_key.pub


значит видно что у нас несколько штук этих ключей. есть приватный и есть ему публичный. 
их несколько видов потому что линукс поддерживает несколко видов ассиметричного шифрования. 
почему я и сказал что на первом этапе клиент и сервер должны догвоорится(в автоматическом режиме) какое именно
асмиетрик шифрование они будут совмпстно юзать. так вот положим что используется 
RSA шифроание. тогда человек ( да да именно человек) должен руками зайти на сервер
найти публичный (дада именно публичный) ключ и вычислить от него хэш руками. обычно у нас два алгоритма для хэша это sha256 и md5. итак человек берет и руками на сервере вычисляет 
хэш для публичного ключа сервера (ключ берется тот который соотсвтетует выбранному ранее в автоматическом режиме между клиентом и сервером асиметрик виду шифрования). тут  я еще раз хочу подчеркнуть что вид асиметрик шифрования выбирается между клиентом и сервером автоматически без участия человека. я щас покажу как нам узнать какой метод был выбран чуть ниже. так вот что еще я хочу подчеркнуть что человек должен зайти на сервер и уже неавтоматически а руками уточнить хэш для публичного ключа соотсвтуетющего выбранному методу асметрик шифрования. руками. руками!

sha256
# ssh-keygen -l -E sha256 -f ./ssh_host_rsa_key.pub 
2048 SHA256:iBSI/ZduKsZ3V6TzyQmgc5/vLxEVnmCOiK2F3nw/NZ0 root@vagrant (RSA)

# ssh-keygen -l -E md5 -f ./ssh_host_rsa_key.pub 
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

и далее самое главное этот человек с сервера должен сообщить нам (клиенту) через какойто человеческий способ комуникации тоесть через телефон или по почту послать либо sha256 хэш
либо md5 хэш.  на мой взгляд хэш sha256 абсолютно непригоден для общения между людьми. 
и только хэш md5 пригоден.
итак человек с сервера звонит нам по телефону и голосом сообщает эту строку
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

что такое хэш. хэш это маппинг отображения аргумента в некоторый более компактный вид.
в чем фишки хэша. в одну сторону он вычисляется быстро и просто .то есть если есть x то хэш(x)
вычсляется быстор и просто а вот зная хэш высчитать исходный x невозможно. это очень хорошо.
и второе что хэш по размеру гораздо компактнее чем исходный x. где применяется хэш. например 
для хранения паролей. но не в открытом исходном виде а ввиде хэша. что это дает. 
на линуксе человек вводит пароль. ос высчитывает от него хэш а затем сравнивает с сохраненным в файле хэшем. если они совпали то человек ввел правильый пароль. если ктото спер с хоста файл с хэшами о это злодею ничего недаст ибо зная хэш вычислить исходный x невозможно. насколько я понимаю считается что нет двух таких x чтобы у них было общий хэш или для этого мала вероятность. тоесть скажем мы незнаем пароль но мы ввели левый пароль и так совпало что его хэш совпал с хэшем от реального пароля типа так небывает. таким образом хэш это досттаточно хороший способ проверить достоверность исходного x. например мы скачали прогу и у нас от нее есть полученный через надежный канал хэш. мы высиляем на компе хэш от файла скачаной проги и сравниваем с хэшем что у нас есть . если совпало значитможно достверно верить что мы скачали оригинальную программу а не подкоректрованную. (crc в этом плане ненадежно ксати ибо можно так подделать исходный x что мы будем иметь тот же crc). 

так вот взрвршаемся к нашей задаче. нам нужно как клиенту убедиться что полученый от сервера
публичный ключ дейвительно получен от сервера а  не от злодея. для этого человек с сервера 
нам должен по телефону сообщить публичный ключ сервера. но публичный ключ сервера очень длинный
например
# cat  ./ssh_host_rsa_key.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9 root@vagrant

совершенно невозможно такой ключ диктовать по телефону. и потом сраавнивать с тем что мы получим от сервера. поэтому человек с сервера по телефону нам передает несам публичный ключ а
передает его хэш. еще раз можно было бы передать по телефону сам публичный ключ в его оригинальном виде ибо это не секретная информция. но как видно ключ очен длинный. а его нужно 
будет нетолько получить по телефону но и и потом сравнить с тем что мы получим от сервера.
пэтому исползуется хэш как средство сжатого вида.

значит по телфону нам продиктуют хэш md5
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

видно что такой вид очень компактный  и с ним можно раоботаь глазами.
итак мы получили от человека с сервера хэш публичного ключа сервера.

далее. мы с клиента начинаем ломиться на сервер.
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здест я хочу сказать о некотором дебилизме клиента ssh. дело в том что опции -o нельзя указать
сразу все. их можно указывать только строго по одной. тоесть вот так работает 
ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa
а вот так неработает
ssh -o FingerprintHash=md5,  HostKeyAlgorithms=ssh-rsa

теперь про сами опции
100.0.0.6 === это понятное дело адрес сервера
HostKeyAlgorithms=ssh-rs === это мы сообщаем на сервер что мы хотим с ним связываться через RSA
(дело в том что в линуксе по дефолту клиент пытается установить связь не через RSA а через ECDSA)
FingerprintHash=md5 === это мы сообщаем серверу чтобы он нам прислал хэш публичного своего ключа в виде md5 потому что по дефолту он шлет нам его в виде SHA256 который как мы уже поняли
совершенно нечитаемый

итак опции разобрали. в них мы заказываем на сервере параметры связи.
посмотрим что мы видим на экране в результате.

The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здесь мы видим что сервер нам прислал md5 хэш своего публичного ключа.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

точнее мы пока что незнаем то ли эта инфо прилетела от сервера то ли от злодея между нами 
и сервером. но мы теперь можем сравнить совпадает ли md5 с бумажки которую нам по телефону
продиктовали  с тем что мы увидели на экране.

бумажка:
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

экран:
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

значит мы видим что нам присылали бумажку для RSA ключа и экран нам показывает 
что RSA ключ. теперь сравним сами хэши

бумажка:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5
экран:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5

сравниваем глазами совпадает. это значит что действительно мы получили хэш публичного ключа 
сервера именно от сервера а не хэш публичного ключа от сервера злодея.
Итак отмечаю здесь еще раз то проверить достоверность полученного  хэша что он действиельно
от сервера автоматическим способом невоможно. нужен звонок друга и проверка вручную глазами.

что это нам дает. то что теперь когда мы знаем что полученный хэш дейсвтиельно оригинальный
то я так подразумеваю что вместе с хэшем от сервера прилетает и сам публичный ключ 
и мы теперь зная что хэш подлинный можем взять присланный публичный ключ посчитать сами
от него хэш сравниить с присланными понять настоящий ли он. и поняв что он настоящий 
мы теперь можем зашифровать нечто и послать на сервер и только сервер это сможет расширофвать.
тут еще важное дополнение что глазами сличать хэш с хэшем с бумажки приедется только один 
раз в жизни. еслимы подтверждаем на экране что хэш верный то он заносится на клиенте в файл known_hosts о чем  нам на экране ssh пишет и при всех следущих конектах к хосту
наша ос небудет нас спрашивать про достверность хэша а будем сличать с тем что в known_hosts.
а если когда то она получить хэш который несовпдает с тем что сохранен в known_hosts
то она на экране напишет что внимание я получила хэш другой чем в known_hosts и это скорее всего означает что хэш нам прислал злодей. и нужно отказатся от сеанса связи такой.

вот как на экране система пишет что она сохранила хэш когда мы подтвердили что он 
поодлинный в файл known hosts:
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '100.0.0.6' (RSA) to the list of known hosts.

файл у нас (клиента) этот лежит в 
$ ls -1 /home/vasya/.ssh
...
known_hosts





- known_hosts как там найти заданный хост или хэш ? его формат есть в man 8 sshd
- чтобы несравнивать глазами как сравнить два хэша ?
- md5sum binary vs text? какая разница?
- On  systems like GNU that do not distinguish between binary and text
     files, this option merely flags each input mode as binary: the MD5
     checksum is unaffected
- md5sum от ключа несовпдаает с ssh-keygen
- что интересно md5sum он всегда вавыодит хэш без знаков : в отличие от ssh-keygen
- < vs  << vs <<< bash ?
- man md5sum : Do not use the MD5 algorithm for security related purposes. почему?
- надо понять sha256 это наш клиент по деолту так просит или сервер по дефолту так шлет
- где посмотреть какой асиметрик метод первым шлется на сервер (  я про ECDSA который по дефолту предлагается)
- я щас покажу как нам узнать какой метод был выбран чуть ниже. 
- $ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
дебилизмы с -o
- вопрос асиметрик метод и симетрик метод о них договоариваются сразу на первом этапе за один раз или на разных
этапах. 

- вопрос симметрис vs asymtryc. на первом этапе неиспользуется асссиметричное шфиование. почему?потому что с его помощью невозможно беопасно выработать общий ключ ? типа асиметрик шифрование
это единственный способ? ассмтерик шифрование неиспользуеся дляпердачи больших данных потому 
что оно супер тяжелое по сравнению с симметрик шифрованием ?

- как договвариваются клиент и сервер (причем надежно чтоб мэн ин зе мидл не влез) о 
о начальных параметрах сеанса. например о способе ассметриченого шифрования.
- ssh vs ssl ?

