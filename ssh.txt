ssh

| ssh-agent
| ssh-add
способ запуска
взялотсюда  https://unix.stackexchange.com/questions/132065/how-do-i-get-ssh-agent-to-work-in-all-terminals


добавить в 
~/.bashrc:

export SSH_AUTH_SOCK=~/.ssh/ssh-agent.$HOSTNAME.sock
ssh-add -l 2>/dev/null >/dev/null
if [ $? -ge 2 ]; then
  ssh-agent -a "$SSH_AUTH_SOCK" >/dev/null
  	ssh-add -l 2>/dev/null >/dev/null; 
  	[ $? -ge 2 ] && echo "WARNING: ssh-add canNOT connect to ssh-agent" 1>&2

fi

как это работает. .bashrc запусаается с каждый новым открытым терминалом. ( в отличие от .profile который запускется только один раз
при первом логине). 

таким образом для каждого терминала этот скрипт будет сраабывать. как работает скрипт. ssh 
клиент когда мы его запускаем то он ищет в окружении переменную
 
		SSH_AUTH_SOCKET

далее ssh через этот юникс сокет стучится в ssh-agent и там ищет ключи.
как работает ssh-agent если его запустить без опций 
то он создает некий рандомный по имени сокет файл в /tmp для связи с ним.
а связываться с ним будет ssh-add и клиент ssh.  
поэтому после того как мы запустили ssh-agent без параметров
то  нам надо руками создать переменную SSH_AUTH_SOCKET в баше
в которую нужно прописать путь к сокет файлу имя которого надо найти
в /tmp папке после того как мы запустили ssh-agent
и тогда наш ssh-agent при запуске будет сканировать свои
переменные окружения найдет там SSH_AUTH_SOCKET 
обратиться на этот файл и сможет подключиться к ssh-agent и добавить
в него ключи.  и далее ssh клиент тоже найдет переменную SSH_AUTH_SOCKET 
смоожет связаться с ssh-agent и получить от него ключ и успешно ввести
его при аутентиицкации.

итак еще раз про схему. мы запускаем на компе ssh-agent и он создает на 
компе в папке /tmp  сокет файл. если мы теперь заупстим друную программу
которой нужен этот ssh-agent то эта друная программа должна поустучаться 
на этот сокет файл. у нас есть такие две программы это ssh клиент и 
ssh-add. эти две программы они ищут в своих переенных окружения переменную
с именем SSH_AUTH_SOCKET в которой они ожидают увидеть путь к соккет файлу
который ведет к ssh-agent
если мы просто запустим ssh-agent но в баше не создадиим эту переменную
то при запуске ssh или ssh-agent они просто напросто незнаю как им связаться
с ssh-agent и будет облом!

так вот теперь нам надо научиться на компе запускать ssh-agent
потом находить его сокет файл  в /tmp который он создает. причем имя у него
всегда разное. потом нам надо автомтом создавать переменную SSH_AUTH_SOCKET
после этого мы уже можем руками запускать ssh-add добавлять ключ. 
далее нам надо чтобы какой бы мы новыый экран процесс баша не запустили
у нас всегда эта переменная SSH_AUTH_SOCKET уже была в памяти.
поэтому тут я прибегаю к двум хитростям. первая хитрость в том что при запуске
ssh-agent ему можно указать под каким именем создавать ему этот сокет
файл. поэтому мы всегда заранее его будем знать! вторая хитрость в том что
мы скрипт запуска ssh-agent добавим в 
		.bashrc
этот файл баш читает каждый раз когда мы запускаем баш поэтому какой бы 
новый баш мы ни запустлии он сразу сработает. 


смотрим на скрипт

export SSH_AUTH_SOCK=~/.ssh/ssh-agent.$HOSTNAME.sock
ssh-add -l 2>/dev/null >/dev/null
if [ $? -ge 2 ]; then
  ssh-agent -a "$SSH_AUTH_SOCK" >/dev/null
  	ssh-add -l 2>/dev/null >/dev/null; 
  	[ $? -ge 2 ] && echo "WARNING: ssh-add canNOT connect to ssh-agent" 1>&2

fi




как он работает.
во первых мы юзаем билтин экспорт. зачем? дело в том что наличие этого 
куска кода нам обеспечить только то что при открытии нового окна терминала
и старте баша этот баш прочитает файл и получит в свои закрома переменную
			SSH_AUTH_SOCK
но если мы сидя в этом баше запустим любую новую программу то баш сука
он эту переенную не передаст при экспорте! поэтому переменную нужно пометить
чтобы ее баш при fork() тоже передавал в execve тоже!
итак мы создаем переменную которая ведет к сокет файлу. файл будет 
иметь фиксированное значение.
далее мы запускаем ssh-add -l эта опция она заставляет ssh-add покключиться 
к ssh-agent и получить список ключей которые там уже есть.
прикол в том что если ssh-agent еще незапущен на компе то ssh-add  с ним 
связаться не сможет и как написано в man ssh-add код возврата из программы
если она не смогла связаться сс ssh-agent равен 2. поэтому мы прообуем связаться
с ssh-agent и получить с него спсок ключей. если связи с ним нет тоесть
код возврата 2 то вследущей строке мы это проверяем и если это так
то мы сами запускаем ssh-agent причем мы ему говорим чтобы он создал 
сокет файл ровно с тем именем котоырый НАМ нужен и который константа.
если же  ssh-agent уже нами ранее был запушен то ssh-add с ним успешно свяжется
и нам ненужно запускать ssh-agent
но при этом у нас в памяти уже сидит переенная  SSH_AUTH_SOCK 
поэому клиент ssh может успешно связываться  с ssh-agent
после запуска ssh-agent я еще раз пробую с ним связаться через ssh-add
и если это не получается то наа STDERR выходит сообщение
ура.



послесловие.
как проверть что ssh-agent уже запущен

$ ssh-agent -s
SSH_AUTH_SOCK=/tmp/ssh-XXXXXXBNIeob/agent.72651; export SSH_AUTH_SOCK;
SSH_AGENT_PID=72652; export SSH_AGENT_PID;
echo Agent pid 72652;


если мы применим eval вот так

$ eval `ssh-agent -s`

это даст то что текст который ssh-agent вывел на экран он будет непросто
напечатан а bash попробует его выполнить. 
а так как мы видим что в выводе идут команды баша
да еше и полезные то это полезный трюк

когда мы запустили ssh-agent и добавили его переменные 
в окружение то этого мало. надо еще добавить в него наши ключи

$ ssh-add ~/.ssh/id_rsa


============


есть такой файл ~/.ssh/config

в него можно много чего вставлять

HOST  vasya

параметр HOST это алиас для  хоста при доступе по ssh.

если честно неочень понятно зачем это были им городить 
если есть доменная система DNS, однако они нагородили (создатчики ssh проги)

HOST означает ту хрень которую мы будем писать после ssh в командной строке
например


$ ssh vasya
$ ssh petya

если мы хотим для этих хреней особые параметры подключения то мы в 
~/.ssh/config пишем

HOST vasya
HOST petya

также в строке HOST может быть несколько алиасов. они перечисляются через пробел.

HOST vasya petya klava


но это только начало секции. ниже HOST мы уже прописываем так какие 
кастомные параметры мы хотим для них сделать.


параметр HOSTNAME. он неиспользуется сам по себе. его должен предварять
параметр HOST

HOST vasya
   HOSTNAME 8.8.8.8 
   
 
тогда когда мы в строке напишем

$ ssh vasya

то ssh заглянет в конфиг и в реальности постучится на сервер вот так

ssh 8.8.8.8

таким образом HOST как бы выполняет роль доменного имени 
а HOSTNAME как бы выполняет роль IP адреса в который он как бэ резолвится 
ssh прогой и уже именно под ним он стучится на сервер

или 

HOST vasya petya klava
	 HOSTNAME 8.8.8.8

или более диковынные приемчики HOST

Host 192.168.0.?

Host *.co.in

Host *

	 

в HOSTNAME может быть нетолько IP но и доменное имя 
например

HOST vasya
	HOSTNAME mail.ru
	
	
следущий параметр это user

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	
таким образом когда мы 

$ ssh vasya 

то по факту будет 
$ ssh 8.8.8.8 -u pupkin


аналогично параметр port

также можно заходить под логином паролем. 
скажем при таком конфиге 
	
HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin


вход будет под юзер pupkin и будет под логином паролем.

а можно входить вместо пароля под юзер\RSA ключ

тоесть RSA ключ вместо пароля.

тогда конфиг будет 


HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
	
причем тут тоже мудота. как пишут в инете. опция IdentityFile даже 
если мы указали какой кастомный ключ мы хотим юзать все равно вначале
шлет на удаленный хост ключ дефолотовый ~/.ssh/id_rsa или ~/.ssh/id_dsa 
а если удаленный хост это отвергает то тогда уже наш кастомный.
поэтому чтобы этой мудоты небыло также надо добавить опцию

  IdentitiesOnly yes
  
  

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
	
	
с IdentitiesOnly yes будет слаться только тот ключ который мы указали. ура товарищи.


далее есть такая хрень. опция LocalForward

вот мы зашли на сервер по ssh
получается между нашим компом и удаленным поднялось TCP содинение вида

наш_IP:некий порт <-------> удаленный_IP:22

так вот если мы заюзаем опцию LocalForward 



HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
    LocalForward 3308    localhost:9200


то когда мы зайдем на удаленный комп по ssh
то и на нашем компе и на удаленном сервис ssh начнет слушать дополнительно порты.
а именно

	на нашем компе он начнет слушать порт 3308 причем для IP=127.0.0.1
   причем именно прям бинарник ssh ( потому что если сокет какойто 
   поднят на компе его поднял какойто конкретный бинарник)

	$ netstat -tnlp
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:3308          0.0.0.0:*               LISTEN      31349/ssh

а на удаленном компе ssh неподнимает никакой доп сокет для себя нет.
там уже должен быть поднят сокет каким то сервисом. 

причем между компами никакого дополнительной tcp конекшнена несоздается.
далее схема такая

если мы на нашем компе обратимся по сокету  127.0.0.1:3308
то ssh перенеправить через наше текущее ssh соедниение реквест (проксирует)
на удаленный комп на его сокет localhost:9200 
таким образом мы имеем проброс порта. обращаясь на сокет нашего компа
мы попадаем на сокет удаленного компа. 
едиснвтенное что непонятно это как на удаленном компе система различает 
пернаправлять реквест  который пришел на localhost:9200 на удаленный мой комп 
или нет. может там в iptables прписываются доп правила?

в любом случае вот такое назначение опции localforward. пробросить локаьный порт
на удаленный комп через ssh соединение.

при этом опять же важно понимать что порты localforward никоим образом невлияют
на порты по которым устанавливается самое ssh содеиненеи.

опция ProxyCommand - позволяет указать первый ssh сервер через который мы хотим попасть на 
другой ssh сервер

например ProxyCommand ssh -q -A vasya@kuku nc %h %p

-q = quiet mode
-A = enable forward как я поимаю именно эта опция позволяет аутентифицроваться
на одном хосте и на втором уже этого повторно делать ненадо

vasya это логин
kuku это alias первого ssh сервера. раз алиас значит
надо его распиывать в ~/.ssh/config  

nc это утилита netcat. и эта хрень тоже участвует в проброске TCP
содененеия с одного компа на другой. 
с этим надо еще разбираться.

   
------
для того чтобы при входе в ssh ненужно было вводить пароль
от RSA приватного ключа то нужно запустить ssh agent

как япроверил от имени непривлигорванного пользлователя. тоесть под тем же
юзером что и тот юзер под которым ты входишь в ssh


$ ssh-agent

провереяем что он запутился как процесм

$ ps aux | grep ssh-agent

далее надо добавить в него налету приватный ключ

$ ssh-add ~/.ssh/название_приватного_ключа

готово.

после перзагурзки компа опять все заново.

----------------
начинаю фундаментальную статью как работает ssh

значит работа ssh начинается с такого этапа насколлько  я понял как договаривание
о методе ассиметричного шифрования(их несколько). пока здесь я оставлю пусто вместо описания как это происходит.

асиметричный алогритм зачем он в чем его фишка в том что для шифровки иползуется один ключ а для расшифровки другой. о нем еще поговорим ниже но конечная цель применения ассиметричного шифрования это выработать некую комбинацию символов (ключ). это конечная цель применения на этом этапе ассмиетричнго широфвания. как только на клиенте и сервере появился этот ключ то можно начинать использовать уже симметричное шифрование. а полученный ключ как раз будет 
использоваться как ключ этого симметричного шифрования. таким образом ассиметричное шифрование
позволяет незная друг о друге почти ничего создать канал безопасный связи и по этому каналу
передать друг другу (договориться) небольшой кусочек информации а именно ключ. насколько я понимаю использовать на первом этапе симметричное шифрование невозможно потому что в отличие 
от ассиметричного шифрования в симметричном нельзя создать канал связи незная друг о друге ничего. ассиметричное шифрование однако сильно грузит цпу поэтому для передачи больших обьемов данных подходит плохо. для устанолвения безопасного канал связи друг с другом незная друг о друге ничего оно подходит хорошо. для передачи небольшого количество информации тоже подходит
нормально а вот для передачи большого обьема ифонмаации уже плохо ибо оно цпу грузит . поэтому 
коненым продуктом ассиметрик шифрвания будет всего навсего ключик. а далее уже запукается симетричный алогритм шифрования который использует выработанный на прердыдущем этапе ключ
который есть уже и на клиенте и на сервере и при своей работе он негрузит цпу так сильно.
итак мы поняли зачем нужен какая роль у ассметрик широфания и у симметрик шифрвания.
про ассиметрик шифования. генерируется два ключа приватный и публичный. 
приватный хранится на сервере в секрете. а публичнй сообщается всем кому подряда наружу. 
любой кто снаружи (клиент) может взять и с поомощью публичного ключа сервера зашифровать
сообщение и послать серверу. фишка в том что толлько сервер имея приватный ключ может 
расшировать сообщение. также фишка в том что зная приватный ключ из него легко получается публиынй ключ. а наоборот невозможно. тоесть зная публичный ключ невзомжно из него вычислить приватный ключ. поэтому то публичный ключ и можно без боязни всем раздавать.


покончили с теорией возврашаемся обратно. итак клиент и сервер договориллись о методе асметрик широфания.
когда они договорлись о методе они к нему приступают.
теперь их задача обеменяться друг с другом своими публичными ключами. 
причем нас как клиента очень интересует как то проверить что полученный от сервера 
публичный ключ что это действтельно публичный ключ от сервер а не от злодея посередине. потому что да меджу нами и сервером может сидеть злодей. он контролрует канал междунами и сервером
и он может легко на наш запрос нам послать свой злодейский пубичнйы ключ который к серверу неимеет никакого отношения. так что нам надо проверить что полученный ключ ддействиительно
от сервера. и тут как я понимаю красивого компьютерого способа нет! а есть способ ручной.
тоесть человек который сидит на сервере он берет публичный ключ на сервере ( на линуксе асиметричные ключи сервера называются host keys. лежат они в папке /etc/ssh )

$ ls -1 /etc/ssh
ssh_host_ecdsa_key
ssh_host_ecdsa_key.pub
ssh_host_ed25519_key
ssh_host_ed25519_key.pub
ssh_host_rsa_key
ssh_host_rsa_key.pub


значит видно что у нас несколько штук этих ключей. есть приватный и есть ему публичный. 
их несколько видов потому что линукс поддерживает несколко видов ассиметричного шифрования. 
почему я и сказал что на первом этапе клиент и сервер должны догвоорится(в автоматическом режиме) какое именно
асмиетрик шифрование они будут совмпстно юзать. так вот положим что используется 
RSA шифроание. тогда человек ( да да именно человек) должен руками зайти на сервер
найти публичный (дада именно публичный) ключ и вычислить от него хэш руками. обычно у нас два алгоритма для хэша это sha256 и md5. итак человек берет и руками на сервере вычисляет 
хэш для публичного ключа сервера (ключ берется тот который соотсвтетует выбранному ранее в автоматическом режиме между клиентом и сервером асиметрик виду шифрования). тут  я еще раз хочу подчеркнуть что вид асиметрик шифрования выбирается между клиентом и сервером автоматически без участия человека. я щас покажу как нам узнать какой метод был выбран чуть ниже. так вот что еще я хочу подчеркнуть что человек должен зайти на сервер и уже неавтоматически а руками уточнить хэш для публичного ключа соотсвтуетющего выбранному методу асметрик шифрования. руками. руками!

sha256
# ssh-keygen -l -E sha256 -f ./ssh_host_rsa_key.pub 
2048 SHA256:iBSI/ZduKsZ3V6TzyQmgc5/vLxEVnmCOiK2F3nw/NZ0 root@vagrant (RSA)

# ssh-keygen -l -E md5 -f ./ssh_host_rsa_key.pub 
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

и далее самое главное этот человек с сервера должен сообщить нам (клиенту) через какойто человеческий способ комуникации тоесть через телефон или по почту послать либо sha256 хэш
либо md5 хэш.  на мой взгляд хэш sha256 абсолютно непригоден для общения между людьми. 
и только хэш md5 пригоден.
итак человек с сервера звонит нам по телефону и голосом сообщает эту строку
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

тут я еще раз хочу этот момент подчеркнуть этот момент.
вот я стучуть на удаленный комп

(наш комп)			$ ssh thinkpad
			The authenticity of host 'thinkpad (192.168.0.104)' can't be established.
			ECDSA key fingerprint is SHA256:UDRp2j4s06/9aBI8XC51GqAKA3c9F9ougvbENBXVjlA.
			Are you sure you want to continue connecting (yes/no)?

и я вот вижу на экране что? я вижу на экране хэш публичного ключа удаленного компа, тоесть
это удаленный комп. на нем есть публичный ключ. и этот удаленый комп нам показывает свой
публичный ключ. но показывает он нам его не в прямом виде потому что выглядит он так

(удаленный сервер)			$ cat /etc/ssh/ssh_host_ecdsa_key.pub 
			ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBBnsLZxz3vxmWzLMJO5NM9ZDQWA8XzVuejjZbFg1Xt7WruMldbWWg1o9ebWBckjhfLYi/x0KUxk+u1SeALixtws= root@thinkpad

но показывается нам на экране не этот публичный ключ а этот ключ в виде хэше. почему
потому что дело вот в чем. если у нас между нашим компом и удаленным сервереом сидит злодей
то он перехватит трафик и нам подсунет свой публичный ключ. и наша задача состоит в том что
человек с удаленного сервера по другому каналу связи например по телефону нам сообщает
публичный ключ своего сервера в виде хэша. чтобы когда мы увидим на экране хэш чтобы мы могли
сравнить то что на экране и что нам по телефону сказали. если то что мы видим на экране (хэш)
совпадает с тем хэшем что нам сказали по телефону то значит мы получили действиельно пакеты
по сети от настоящего сервера а не злодея по середине между нашим компм и удаленным сервером.
почему в виде хэша? потому что публичеый ключ очень длинный и его сверить очень трудно глазами
а вот хэш он короткий и его уже сравнить с тем что по телефону.

а как админу с удаленного сервера узнать хэш своего публичного ключа формата ECDSA
sha256
	# ssh-keygen -l -E sha256 -f ./ssh_host_rsa_key.pub 
	2048 SHA256:iBSI/ZduKsZ3V6TzyQmgc5/vLxEVnmCOiK2F3nw/NZ0 root@vagrant (RSA)

и вот эту хрень	
	SHA256:iBSI/ZduKsZ3V6TzyQmgc5/vLxEVnmCOiK2F3nw/NZ0
нужно и сообщить клиенту по теелфону. а клиент должен усебя на компе увидеь именно это


что такое хэш. хэш это маппинг отображения аргумента в некоторый более компактный вид.
в чем фишки хэша. в одну сторону он вычисляется быстро и просто .то есть если есть x то хэш(x)
вычсляется быстор и просто а вот зная хэш высчитать исходный x невозможно. это очень хорошо.
и второе что хэш по размеру гораздо компактнее чем исходный x. где применяется хэш. например 
для хранения паролей. но не в открытом исходном виде а ввиде хэша. что это дает. 
на линуксе человек вводит пароль. ос высчитывает от него хэш а затем сравнивает с сохраненным в файле хэшем. если они совпали то человек ввел правильый пароль. если ктото спер с хоста файл с хэшами о это злодею ничего недаст ибо зная хэш вычислить исходный x невозможно. насколько я понимаю считается что нет двух таких x чтобы у них было общий хэш или для этого мала вероятность. тоесть скажем мы незнаем пароль но мы ввели левый пароль и так совпало что его хэш совпал с хэшем от реального пароля типа так небывает. таким образом хэш это досттаточно хороший способ проверить достоверность исходного x. например мы скачали прогу и у нас от нее есть полученный через надежный канал хэш. мы высиляем на компе хэш от файла скачаной проги и сравниваем с хэшем что у нас есть . если совпало значитможно достверно верить что мы скачали оригинальную программу а не подкоректрованную. (crc в этом плане ненадежно ксати ибо можно так подделать исходный x что мы будем иметь тот же crc). 

так вот взрвршаемся к нашей задаче. нам нужно как клиенту убедиться что полученый от сервера
публичный ключ дейвительно получен от сервера а  не от злодея. для этого человек с сервера 
нам должен по телефону сообщить публичный ключ сервера. но публичный ключ сервера очень длинный
например
# cat  ./ssh_host_rsa_key.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9 root@vagrant

совершенно невозможно такой ключ диктовать по телефону. и потом сраавнивать с тем что мы получим от сервера. поэтому человек с сервера по телефону нам передает несам публичный ключ а
передает его хэш. еще раз можно было бы передать по телефону сам публичный ключ в его оригинальном виде ибо это не секретная информция. но как видно ключ очен длинный. а его нужно 
будет нетолько получить по телефону но и и потом сравнить с тем что мы получим от сервера.
пэтому исползуется хэш как средство сжатого вида.

значит по телфону нам продиктуют хэш md5
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

видно что такой вид очень компактный  и с ним можно раоботаь глазами.
итак мы получили от человека с сервера хэш публичного ключа сервера.

далее. мы с клиента начинаем ломиться на сервер.
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здест я хочу сказать о некотором дебилизме клиента ssh. дело в том что опции -o нельзя указать
сразу все. их можно указывать только строго по одной. тоесть вот так работает 
ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa
а вот так неработает
ssh -o FingerprintHash=md5,  HostKeyAlgorithms=ssh-rsa

теперь про сами опции
100.0.0.6 === это понятное дело адрес сервера
HostKeyAlgorithms=ssh-rs === это мы сообщаем на сервер что мы хотим с ним связываться через RSA
(дело в том что в линуксе по дефолту клиент пытается установить связь не через RSA а через ECDSA)
FingerprintHash=md5 === это мы сообщаем серверу чтобы он нам прислал хэш публичного своего ключа в виде md5 потому что по дефолту он шлет нам его в виде SHA256 который как мы уже поняли
совершенно нечитаемый

итак опции разобрали. в них мы заказываем на сервере параметры связи.
посмотрим что мы видим на экране в результате.

The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здесь мы видим что сервер нам прислал md5 хэш своего публичного ключа.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

точнее мы пока что незнаем то ли эта инфо прилетела от сервера то ли от злодея между нами 
и сервером. но мы теперь можем сравнить совпадает ли md5 с бумажки которую нам по телефону
продиктовали  с тем что мы увидели на экране.

бумажка:
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

экран:
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

значит мы видим что нам присылали бумажку для RSA ключа и экран нам показывает 
что RSA ключ. теперь сравним сами хэши

бумажка:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5
экран:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5

сравниваем глазами совпадает. это значит что действительно мы получили хэш публичного ключа 
сервера именно от сервера а не хэш публичного ключа от сервера злодея.
Итак отмечаю здесь еще раз то проверить достоверность полученного  хэша что он действиельно
от сервера автоматическим способом невоможно. нужен звонок друга и проверка вручную глазами.

что это нам дает. то что теперь когда мы знаем что полученный хэш дейсвтиельно оригинальный
то я так подразумеваю что вместе с хэшем от сервера прилетает и сам публичный ключ 
и мы теперь зная что хэш подлинный можем взять присланный публичный ключ посчитать сами
от него хэш сравниить с присланными понять настоящий ли он. и поняв что он настоящий 
мы теперь можем зашифровать нечто и послать на сервер и только сервер это сможет расширофвать.
тут еще важное дополнение что глазами сличать хэш с хэшем с бумажки приедется только один 
раз в жизни. еслимы подтверждаем на экране что хэш верный то он заносится на клиенте в файл known_hosts о чем  нам на экране ssh пишет и при всех следущих конектах к хосту
наша ос небудет нас спрашивать про достверность хэша а будем сличать с тем что в known_hosts.
а если когда то она получить хэш который несовпдает с тем что сохранен в known_hosts
то она на экране напишет что внимание я получила хэш другой чем в known_hosts и это скорее всего означает что хэш нам прислал злодей. и нужно отказатся от сеанса связи такой.

вот как на экране система пишет что она сохранила хэш когда мы подтвердили что он 
поодлинный в файл known hosts:
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '100.0.0.6' (RSA) to the list of known hosts.

файл у нас (клиента) этот лежит в 
$ ls -1 /home/vasya/.ssh
...
known_hosts

итак для хоста 100.0.0.6 хэш его публичного ключа был записан системой в known_hosts.
поищем ка теперь его там.

вот как выглядит known_hosts если мы запретили хэшить имя удаленного сервера
(наш комп)$ cat known_hosts
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

вот как на самом удаленном сервере выглядит файл с публичным ключом
(удаленный сервер)# cat /etc/ssh/ssh_host_rsa_key.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9 root@vagrant

почему то на нашем компе в known_hosts нет root@vagrant. непонятно об этом мы поговорим
где то ниже. в остальном получается что known_hosts строчка состоит из полей:

имя_сервера    тип_ассиметричного_шифрования     публичный_ключ(нехешированный)

Но! на самом деле так known_hosts выглядит если на нашем компе в /etc/ssh/ssh_config ( это файл отвечает за настройки ssh клиента (тоесть когда мы с нашего компа ломимся на удаленный сервер в отличие от sshd_config конфига когда наш комп используется как сервер на принятие от ругих ssh соединений)) стоит настройка 
(наш комп)$ cat /etc/ssh/ssh_config | grep -i hash
    HashKnownHosts no

так вот обычно там стоит как раз обратная настройка. то есть yes. 
когда она yes то у нас имя сервера ( в нашем примере это 100.0.0.6 ) записывается не в открытом  виде а в виде хэша. (зачем пока незнаю). но еще раз скажу пока мы рассматриваем
случай когда HashKnownHosts no. случай когда он равен yes рассмотрим ниже несейчас.
так вот.  еще раз. мы постучали с нашего компа на удаленный сервер
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6

при этом на нашем компе в known_hosts получили запись
$ cat known_hosts
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

далее очень интеересный момент. стучим на тот же сервер но требуем использовать не RSA
в качесвте асиметричного шифрования а ecdsa-sha2-nistp256 (об нем подробнее ниже)
и получаем жесточайший варнинг от линукса
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

суть этой надписи в том что наш комп имеет уже сохраенный ключ асмиметричного
шифрования который мы ранее одобрили. далее наш комп подключается к серверу и получаем
 в ответ публичный ключ совершенно другой. из чего комп делает вывод что получнный публичный
 ключ не от сервера а от злодея который сидит между нами и сервером. в  данном случае никакого 
злодея нет. просто мы к тому же серверу обращаемся по другому ассиметричному протоколу и получаем другой публичный ключ. ОТСЮДА я делаю вывод что в known_hosts для одного удаленного
сервера который идентифицируется в нашем случае ip адресом может находиться ТОЛЬКО ОДНА СТРОЧКА! линукс непозволяет иметь несколько строчек для одного удаленного сервера даже если
в этих строчках указаны разные асиметричные алгоритмы шифрования. это очень важно.

узнать какие алгоритмы шифроваия поддеживает удаленнй сервер по быстрому можно через ssh-keyscan

$ ssh-keyscan  100.0.0.6

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAqCgW5Mlx2VpC61acc0G4VMZUAauQDoK5xIzdHzdDLPXt0GqsoIw1fuwTSSzSy8RFmGU5PNHiWn0egoUwlXdc4=

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

он просканровал удаленный сервер и узнал что тот поддеживает RSA, ecdsa-sha2-nistp256, 
ssh-ed25519

Далее еще один очень важный момент. Когда мы обращаемся к удаленному серверу по IP 
то все понятно в known_hosts будет указан IP. а что если мы обращаемся к удаленному 
серверу через доменное имя. что вэтом случае будет в known_hosts.
ответ такой - если у нас прописан резоволинг dns в IP в /etc/hosts либо такой же резолвинг
идет через внешний DNS сервер то в known_hosts будет содержаь доменное имя+IP 
пример:
$ cat /etc/hosts
100.0.0.6 vasya.local

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
The authenticity of host 'vasya.local (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? yes

смотрим что в known_hosts
$ cat known_hosts
vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

тоесть мы видим что указано и vasya.local и 100.0.0.6

также видно что когда мы устанавлаием соединенеи то эта же инфо указана в
The authenticity of host 'vasya.local (100.0.0.6)' can't be established
тоесть нам клиент уже подсказывает что он пропишет в качестве идентификатора сервера в
known_hosts

в man 8 sshd указано что в known_hosts можно указывать вайлдкарды. тоесть скажем вместо
vasya.local указать vasya*


$ cat known_hosts
vasya*,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

и это реально работает! однако это работает только при настройке  HashKnownHosts no. когда у нас domain name\IP нехэширован. когда же он хэширован то мы так уже подкоректировать руками
known_hosts не сможем.

Так вот я продолжаю тему о том что если у нас доменное имя не прописано в /etc/hosts
или во внешнем доменном сервере а вместо этого мы используем ~/.ssh/config
вот с такой записью:

$ cat ~/.ssh/config 
HOST vasya.local
    HOSTNAME 100.0.0.6

и мы обращаемся к серверу по доменному имени
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local

то тогда в known_hosts будет записано не доменное имя а  IP как идентификатор удаленного сервера.
я проверил это. 
также практика показала что если есть запись в /etc/hosts и есть запись в ~/.ssh/config
то запись в ~/.ssh/config превалирует. 
Таким образом если мы хотим чтобы в known_hosts присутсовало именно доменное имя
то надо чтобы если мы используем ~/.ssh/config то там хост был прописан как доменное
имя а не как IP адрес. например.

$ cat ~/.ssh/config


HOST vasya.local
    HOSTNAME vasya.local

при этом
$ cat /etc/hosts
100.0.0.6 vasya.local


тогда 
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
даст
$ cat known_hosts
vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9


но опять же можно заметить что даже если у нас система вписала доменное
имя то она всегда обязательно прорисывает и IP адрес. так что от IP адреса
никак неизбавиться.!

что интересно. я зашел на удаленнйы хост и сменил его ip на 100.0.0.8
далее я на нашем компе постучал на сервер 
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
тогда система вот что сделала
$ cat known_hosts

vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9


она добавила новую строчку и использовала IP=100.0.0.8
далее я удаляю верхнюю строчку в known_hosts
еще раз стучуь по доменному имени
получаю такое в known_hosts

$ cat known_hosts

100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

vasya.local ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

далее я удаляю строчку с vasya.local
стучусь еще раз
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

удаляю строчку с 100.0.0.8
стучу еще раз получаю

$ cat known_hosts
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg
100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

удаляю обе строчки
стучу еще раз
получаю

$ cat known_hosts
vasya.local,100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

из чего я суммарно делаю вывод - если мы стучиммся на сервер по его доменному имени
и в config нет его резоолвинга в IP то клиент ищет в known_hosts строчку где указано 
доменное имя. если в этой строчке указано толко доменное имя без IP то клиент
делает еще доп проверку и ищет строчку где есть IP и сравнивает одинаковые ли ключи или нет.
если нет то клиент ругается. как это было в этом случае:

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

в целом я бы сдела такой вывод - как ни извращайся но клиент будет всегда вставлять строчку в known_hosts которая обязательно будет содержать IP сервера (неважно как мы  к нему обращаемся по IP или по доменному имени). если мы обращаемся к серверу по IP то  в файле будет прописан IP. если мы обращаемся к серверу первый раз и по доменному имени то в файле в одной строке
будет указано и доменное имя и IP. если в файле уже есть либо такой IP либо такое доменное
имя то будет создана доп строчка с тем чегонехватает. тоесть если мы обратлись по доменному имени а в файле для IP уже есть запись то будет созана вторая строчка с только доменным
именем. если у нас есть две строчки в которой в одной только доменное имя а в другой только
IP и указаные разные ключи (так хитро мы смогли сделать) то система будет ругаться и говорить
что у нас одна строка противорчеит другой как в этом примере:

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg


в целом я бы сказал так что для себя клиент в конченом итоге идентифицирует хост именно по IP 
как ни ивзращайся и с этим IP обязатлеьно будет строчка в known_hosts и еще то что 
для одного IP в known_hosts может быть только один ключ. неможет быть два ключа даже 
если при этом указаны разные алгоритмы несимметричного шифрования. система будет ругаться вот так:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

так что если уж когда то полкючились к хосту через RSA и такой то ключ
то будь добр только так к этому хосту и подключаться. а если решил сменить 
RSA на ECSA то вначале удали из known_hosts прежний ключ вотак

$ ssh-keygen -f "/home/vasya/.ssh/known_hosts" -R "100.0.0.6"

еще раз подчеркн что  хост неможет иметь в known_hosts разные ключи.тоесть строчка может 
быть только одна! при этом неважно что раньше мы связывалист с ним по RSA а щас по ECDSA.
невоможно это обойти тем что мы будет обращаться к хосту скажем по IP по RSA
а по доменному имени по ECDSA. этот номер непродет. как бы мы ни обраащались к хосту в коечном итоге клиент ожидает что в known_hosts либо есть одна строка с одним ключом и в этой строке
укзано и доменное имя и IP либо там есть две строки в одной IP в другой доменное имя 
но в обоих строках ключ должен быть одинаковый. так что обмануть обойти это недуастся.
итого - одному хосту один ключ один алгоритм ассмиетричного шифрования. так подразумевает
клиент. иначе он будет псоылать нахер.

в этом плане ксати интересно что github опубликовал хэши своих публичных ключей
https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 (RSA)
SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM (ECDSA)
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU (Ed25519

вот что показывает про github ssh-keyscan

$ ssh-keyscan github.com

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=

таким образом через ssh-keyscan
мы знаем что github поддерживает для связи с ним по ssh следущие ассиметричные 
протоколы:ssh-rsa, ssh-ed25519, ecdsa-sha2-nistp256

и что для этим протоколов оригинаьоьные хэши публичных ключей являются:
SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 (RSA)
SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM (ECDSA)
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU (Ed25519)


таким образом мы можем выбрать протокол который нам больше нравится
и знаем как дожен выглядеть оригиальный хэш публичного ключа. 

вот как выглядит known_hosts 
после того как мы вошли мы подключлись к гитхабу по ssh
$ cat known_hosts
github.com,140.82.121.3 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=

здесь мы видим и доменное имя и IP

еще раз полезная команда которая дает хэш публичного ключа(неважно это наш публичный клиентский ключ которым мы аутентифицируемся на гитхабе к примеру или это публичный ключ 
нашего ssh линукс сервера который видят клиенты котрые к нему покдлючаются)
$ ssh-keygen -l -f id_ed25519.pub
256 SHA256:f+lgxW9HzT1QCQj3GvKmtQh6LwJ/1d3STiDQ5cuHNHI vasya@gmail.com (ED25519)

Еще раз хотел сказать насчет того случая когда мы стучимся на удаленный сервер (100.0.0.8 для примера)
по ssh и на экране вдруг видим варнинг:
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

что это значит с технической точки зрения.
это значит что когда то мы уже стучались на 100.0.0.8 и  у нас система спросила что мол 
она получила такой то публичный ключ подтверждаем ли мы что он действиельно от 100.0.0.8,
мы подтвердили и система сохранила подтвержденный нами публичный ключ удаленного сервера
в файле known_hosts , также она сохранила и имя  ассиметричного алгоритма. так вот 
проблема в том что сейчас когда мы стучим на 100.0.0.8 то наша система получила публичный 
ключ от удаленного сервера который нетакой, который отличается от того что был сохранен
ранее. Ровно об этом и говорит варнинг. Он говорит о том что полученный публичный ключ
отличается от сохранненого , который мы получали ранее от этого хоста. Какие причины могут
для этого быть. Самая хреновая это то что между нами и удаленным сервером сидит злодей. 
Он перхваетывает пакеты от нас к 100.0.0.8 и подменяет их своими. Именно поэтому нас так 
ярко информируют. Нам говорят что возможно злодей посылает нам пакеты от имени сервера 100.0.0.8 соотвественно надо отстановится задуматься итд. НО! причина может быть и не в злодее.
Первая причина незлодейская может быть в том что на удаленном сервере сменили приватный и соотвественно публичный ключ. Но тогда надо связаться с тем кто заведует тем сервером и спрросиить так ли это или нет. Может быть и еще одна незлодейская причина - дело  в том 
что удаленный сервер обычно поддеживает несколько асиметричных типов шифрования. так вот 
мы могли ранее связываться с ним по одному асиметричному методу а сейчас по другому. А дело втом что публичные ключи от разных асиметричных шифрованиях они конечно разные. Тоесть 
если мы стучим на сервер по одному асиметричному протокул то он нам вернет один публичный ключ
а если мы стучим на сервер подргуому асиметричному протоколу то он нам ответит другим
публичным ключом. Соотвесвтенно в этом случае выиноваты только мы. На сервере ничего непоменялось. И злодея нет. Как это проверить - нам надо узнать по какому асимтеричному
шифрованию мы обращались к серверу ранее, для этого надо заглянуть в known_hosts
там будет указан публичный ключ (его хэш) для сервера и имя алгоритма шифрования асиметричного как раз то что нам нужно. Также пользуемся тем что для одного IP в known_hosts всегда есть только одна строчка. Несколкьих строчек неможет быть для одного IP. Как я писал выше known_hosts недаст нам иметь для одного IP несколько строчек с разными ключами даже при условии
что в каждой строчке свой другой алгоритм шифрования асиметричный. Поэтому я и говорю что 
в known_hosts можно узнать по какому алгоритму асимм шифрования мы обращались в прошлый раз
к серверу и какой был от него публичный ключ. если known_hosts имеет вид когда ip адреса
сервров незахэшированный то можно посмотреть просто через cat

$ cat ~/.ssh/known_hosts | grep 100.0.0.8
vasya.local,100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

но чаще всего known_hosts имеет вид когда ip адрес сервера предсталвен в виде хэша (об этом будем говорить позднее), в этом случае искать IP серверов и их ключи надо через ssh-keygen

$ ssh-keygen -F 100.0.0.8
# Host 100.0.0.8 found: line 1 
vasya.local,100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

значит из этой инфо мы понимаем что ранее мы связывалсь с сервером через ssh-ed25519
а сейчас я с ним связывался по RSA тоесть 

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.8

соотвестенно в данном случае никакого злодея нет. просто мы на нашем клиенте
поменяли асим шифрование поэтому и ключ другой получаем от сервера . так что ничего 
плохого непроизошло. для дальнейшей работы нам просто надо решить либо обрашатся к
серверу по ed25519 либо стереть ключ из known_hosts обратится чеерез RSA и запомнить в known_hosts новый публичый ключ. Обрашаться к сервер то через RSA то через ed25519 неполучится.
система каждйы раз будет ругаться. чтобы удалить ключ из known_hosts юзают команду:

$ ssh-keygen -f "/home/vasya/.ssh/known_hosts" -R "100.0.0.8"

таком обраом мы разобрали все три случая когда может появляться варнинг
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

разобрали как проверить какой случай в нашем случае. и что это все значит.
один из главных выводов: невсегда эта надпись означает что нам пишет злодей.
в ряде случаев это происходит по незлобным причинам. в любом случае сразу надо 
разбираться.

Далее. также еще раз опишем что значат для чего предназанчены некоторые файлы
котрые встерчются при работе с ssh.

/etc/ssh/sshd_config = это конфиг файл для сервиса sshd который обслуживает подключения к нашему серверу от клиентов ssh из внешнего мира. тоесть наш хост работает как ssh  сервер а люди снаружи покдючатся к нашему серверу через клиентов.

/etc/ssh/ssh_config = это совсем другой файл. это когда мы с нашего компа стучимся на удаленнйы
сервер а наш комп выступает как клиент. так вот ssh_config это настройки для нашего клиента.
~/.ssh/config = это ровно такой же файл как предыдущий только для конкретного юзера на хосте. его локаьные настройки. вообще получается что ~/.ssh/ все файлы в этой папке это файлы которые
используются для клиента. тоесть когда мы клиентом стучися на удаленный сервер то в этой папаке
лежат файлы которые при этом могут понадобиться. хотя все таки я несовсем прав. в этой папке
есть по крайней мере один файл который испольуется не клиентом а сервисом sshd когда наш хост выступает как сервер ssh. это файл authorized_keys. 

~/.ssh/authorized_keys = в этом файле указаны публичные ключи удаленных пользователей
который стучат на наш хост как на сервер ssh. и они при этом предбявляют в качестве аутентификации публичный ключ и логин под которым они хотят войти на наш сервер. так вот 
если удаленный юзер хочет войти под логином petya без пароля а по поубличному ключу то 
его публичный ключ должен быть добавлен в /home/petya/.ssh/authorized_keys
что примечательно что в authorized_keys может быть хоть милион разных публичных ключей и под каждый из них можно аутентифиицироваться и войти на наш сервер как petya. публичный кюлч предьявляется нашему серверу вместо пароля. но в authorizeed_keys указыается не только публичный ключ но и например какую команду нужно выполнить сервису sshd после проверки ключа.
тоесть можно устроить так что баш нельзя запускать юзеру после аутентиицкации а только скажем
команду git. более детально aurhorized_keys рассматрим ниже далее. еще раз подчернкну что  в 
aiuthoized_keys неуказывается логин под которым разрешено зайти юзеру , а указан только 
публичный ключ. логин же определяется папкой в которой лежит authoized_keys. тоесть 
если публичный ключ лежит в /home/petya/.ssh/authoeized_keys то тогда удаленный юзер может предетдовать на вход как petya
а если  некий публичный ключ лежит в /home/frosia/.ssh/authoeized_keys то тогда удаленный
юзер может претендовать на вход как frosia.

~/.ssh/known_hosts = этот файл используется клиентом ssh. когда мы с хоста стучимся на удаленный сервер. в этом файле система сохраняет публичный ключ удаленного сервера после того 
как мы руками подтверждаем при первом стуке что хэш публичного ключа дейтсивтетельно верный.
(верность хэша мы проверяем глазами на основе переданного нам ранее каким то человеком по телефону либо через бумажку записи этого самого хэша).
-------------------
еше важая тема
имеем windows putty
и в нем нам надо натроить чтобы мы заходили через публичный ключ на один хост 
исполльзуя другой хост.


для примера конечный хост 172.16.0.21
промежутоный хост 8.8.8.8

логин на обоих хостах vasya

приватный ключ лежит в папке c:\users\vasya\.ssh\private.ppk

тут важно сказать что путти непонимает линуковский формат приватных ключей.
надо взять утилиту puttygen и через нее сконевертировать openssh формат в ppk.


значит как нсастроить:

в главном окне путти (session окно ) в строке host вбиваваем : vasya@172.16.0.21

потом идем в окно : ssh-auth-credentials и там в строке "private key file for authentication"
вбиваем путь к приватному ключу c:\users\vasya\.ssh\private.ppk

потом идем в окно Proxy . выбираем proxy type = Local (run a subprogram to ...)
proxy hostname = 8.8.8.8
port =22
username = vasya
print proxy diagnostic = yes
command to send = 
= plink.exe -v -ssh %user@%proxyhost -P %proxyport -nc %host:%port   -i "c:\Users\vasya\.ssh\vasya.ppk"


конекктимся. готово.

ЕЩЕ ВАЖНО: если у нас приватный ключ защищен паролем то шарманка описнная незаработает потому
что надо вводить пароль от ключа а запрос не появится поэтому и не заработает поэтому надо также
загрузить доп утилииту от путти называется pagent и в нее добавит наш приватный ключ. тогда 
путти будет искать пароль через эту утилиту.


далее. оказывается можно сделать тоже самое что я только что описал но чисто 
через командную строку, это мегафохуенно:

putty.exe -proxycmd "plink.exe vasya@8.8.8.8 -P 22 -nc 172.16.0.21:22 -i c:\Users\vasya\.ssh\private.ppk " vasya@172.16.0.21  -i c:\Users\vasya\.ssh\private.ppk


а вот я опубликовал на стековерфлоу все то что я описал с картинками:

https://stackoverflow.com/questions/28926612/putty-configuration-equivalent-to-openssh-proxycommand/75191807#75191807

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
тут указан новый материал. который надо всунуть  в текст основго
текста который выше

1) как на сервере опредеить фингерпринт чтобы его передать человеку


ключ в голом виде (считай бесползена хрень)
$ cat ~/.ssh/known_hosts | grep '\[94.247.130.176\]:10223'
[94.247.130.176]:10223 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAfS3sFK738obrzogmaCnTUu95Yay0lvfz1rQh96soenzQlZrJGa7mbOVZAMYr5etp820YyRWFfeF8B8D9jyDeI=


фингепринт от этогоже ключа (уже то что надо )
$ ssh-keygen  -F [94.247.130.176]:10223 -l -E sha256
# Host [94.247.130.176]:10223 found: line 135 
[94.247.130.176]:10223 ECDSA SHA256:QUQ7k27XyiMrUuNUuTpgZNHijLuplwEEZkLeFUFj4nQ 

 
  ssh-keygen  -F 176.99.7.202  -l -E sha256 -f ~/.ssh/known_hosts
# Host 176.99.7.202 found: line 18 
176.99.7.202 ECDSA SHA256:8e9xUr1TAecRNWqKv+1dyusWfWuocEhhlobqhp8f+Qo


вот ключи которые срвер снаружи показал
$ ssh-keyscan   176.99.7.202 

# 176.99.7.202:22 SSH-2.0-OpenSSH_7.4
176.99.7.202 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDFmb5EWnJ5rVqoWRw0x5wI+BMeqLzofNsjBsT/RJ8ZZMxVTY225sih9YhI7hzB3swqU6Yc4LhHqGNN20UI7HlUX9eltCkSD+duzxQOf+bcY3fFcHWzGXpefA61XS+eSDQssO40LMURFbVsUv27Prc3/oKmo6wzbzPji3a4krtvWDw9nE4/o56QnXX3kIr2wrqboGPLn2OKsRhPA9MJ/DzTUeNDilovEYCULS0xcv2++N0ZycPZuk07jm/6EkHoGDRSQQnBGayR7By/6pLxWcw9idAzCqgibd0aT+E+wuYjQlo5YSIAdrMCi7RIDiOPjHxoqs33TSJAEUtwrKbbZ/8P

# 176.99.7.202:22 SSH-2.0-OpenSSH_7.4
176.99.7.202 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBA5EcRBy4/lNGsAhPSAgySYEfKo/2dlcA2NtcZVG6tPdYs2JEIt0sYln3Gu/D4DMolppzw2lO8oBqyo0SgJGYL8=

# 176.99.7.202:22 SSH-2.0-OpenSSH_7.4
176.99.7.202 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGbJDBZW7TEtpCpouVNbt0tWx0oothfgMe/lqgngUcAB


в таком виде их можно прям вставиь в known_hosts

также можно в шифрованном виде сразу вствит в known_hosts


$ ssh-keyscan   -H 176.99.7.202  

# 176.99.7.202:22 SSH-2.0-OpenSSH_7.4
|1|2Cjkor38fsbtZ+zhW8n5yaVYIdQ=|/noulaO/3tvV/ldjf11uX1BX3nU= ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDFmb5EWnJ5rVqoWRw0x5wI+BMeqLzofNsjBsT/RJ8ZZMxVTY225sih9YhI7hzB3swqU6Yc4LhHqGNN20UI7HlUX9eltCkSD+duzxQOf+bcY3fFcHWzGXpefA61XS+eSDQssO40LMURFbVsUv27Prc3/oKmo6wzbzPji3a4krtvWDw9nE4/o56QnXX3kIr2wrqboGPLn2OKsRhPA9MJ/DzTUeNDilovEYCULS0xcv2++N0ZycPZuk07jm/6EkHoGDRSQQnBGayR7By/6pLxWcw9idAzCqgibd0aT+E+wuYjQlo5YSIAdrMCi7RIDiOPjHxoqs33TSJAEUtwrKbbZ/8P

# 176.99.7.202:22 SSH-2.0-OpenSSH_7.4
|1|83fs8lNmeV9gmiQ1//jjj10C+00=|/7OGivivIRqZC/x3RdCBDL095zA= ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBA5EcRBy4/lNGsAhPSAgySYEfKo/2dlcA2NtcZVG6tPdYs2JEIt0sYln3Gu/D4DMolppzw2lO8oBqyo0SgJGYL8=

# 176.99.7.202:22 SSH-2.0-OpenSSH_7.4
|1|XHdJr6BqLKtAyyCbbrWpADAck18=|GdlTwJO6IALypFvQPswcpm4kMu0= ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGbJDBZW7TEtpCpouVNbt0tWx0oothfgMe/lqgngUcAB
[vasya@lenovo Desktop]$ 


как нам из ключей получить их фингрепринты
вначле запишем ключи в файл (проббраз known_hosts)

$ ssh-keyscan   -H 176.99.7.202   > 23.txt

теперь получим из него фингепринты

$ ssh-keygen  -F 176.99.7.202  -l -E sha256 -f ./23.txt

# Host 176.99.7.202 found: line 1 
176.99.7.202 RSA SHA256:pymgWwZ9iCaAGF2QLr2HcWRDA0zAMYycM06YGK6fmMo 
# Host 176.99.7.202 found: line 2 
176.99.7.202 ECDSA SHA256:8e9xUr1TAecRNWqKv+1dyusWfWuocEhhlobqhp8f+Qo 
# Host 176.99.7.202 found: line 3 
176.99.7.202 ED25519 SHA256:WROSbsMWpnruUKegmoyNbHbVzrKtz/JJGlnJepLf5yI 


можно и без записи в файл. но тогда он покажет только первый фингер

$ ssh-keyscan   176.99.7.202  | ssh-keygen  -F 176.99.7.202  -l -E sha256
# Host 176.99.7.202 found: line 18 
176.99.7.202 ECDSA SHA256:8e9xUr1TAecRNWqKv+1dyusWfWuocEhhlobqhp8f+Qo 


на хосте у сервера публичные ключи лежат в 
/etc/ssh/*.pub

вот как для примера выглядит один из пабкеев

# cat ssh_host_ecdsa_key.pub
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBDzJejgbCqxiiAmsee4R2zqqFSqHR8+vIP2ByLXsZSfDXFXTekJ/O9i6sgE+LGB1pU+KyEUHVX+zlRtiVXcvavY= root@vasya-Lenovo-IdeaPad-L340-15IWL

как видно паблей не содержит IP адреса сервера. поэтому тепрь мы это знаем.
что фингепринт он не содержит инфо об адресе. фигнеприент это хэш только пабкея и видимо
метода широывания ecdsa-sha2-nistp256

а вот как на хосте из поубличных ключей получить их фингеы чтобы можно было людффм ссобщить

# ssh-keygen -l -f ssh_host_ecdsa_key.pub
256 SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10 root@vasya-Lenovo-IdeaPad-L340-15IWL (ECDSA)
 
# ssh-keygen -l -f ssh_host_ed25519_key.pub
256 SHA256:ac9ka4z5yT9kjLM/kQC3PMjOJY6JNmIqKhKNWYyOod0 root@vasya-Lenovo-IdeaPad-L340-15IWL (ED25519)
 
# ssh-keygen -l -f ssh_host_rsa_key.pub
2048 SHA256:f71Lr8hSHwOJclkzXFhQRt/iPt/IpNtXCH4HVGhUZuU root@vasya-Lenovo-IdeaPad-L340-15IWL (RSA)

#  ssh -o HostKeyAlgorithms=ecdsa-sha2-nistp256  -o FingerprintHash=sha256 localhost
The authenticity of host 'localhost (127.0.0.1)' can't be established.
ECDSA key fingerprint is SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10.
Are you sure you want to continue connecting (yes/no)? 

сравним SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10
с тем что получали выше путем расчета руками 
        SHA256:u4EoTU6dXVDXdCt3fRtBDukP+OEJxgKf+fuKij4Hc10

видно полное совпадение.(точка на конце она неимеет отношения к фингеприенту )


такми макаром чтомы научились:
на сервере - брать публиный ключ и вычислаьт от него фингепринт. теперь его можно сособщать клиентам,
на клиенте - запрашивать все пабкеи котоыре сервер предлагает. и вычисляеть от них фингепримнты,
научились искать в known_hosts пабкеи от удаленного сервере и вычислять от них фингепринты. поэтомму
теперь мы можем иъ сравгить с тем что прделагает сервер хотя это автоматом делает система сама.




2) как понять подрживет ли серевр публик кей аутентфиикаци.

ssh -G  удаленный_хост

масса полезной ифно

# ssh -G localhost | grep -E "^pubkeyauth|^passwordauth|^pubkeyacceptedkeytypes"
passwordauthentication yes
pubkeyauthentication yes
pubkeyacceptedkeytypes ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384-cert-v01@openssh.com,ecdsa-sha2-nistp521-cert-v01@openssh.com,ssh-ed25519-cert-v01@openssh.com,ssh-rsa-cert-v01@openssh.com,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,ssh-ed25519,rsa-sha2-512,rsa-sha2-256,ssh-rsa

видно что удаленный сервер принимает аутентицифкаиаию по ключам и по паролям.
также виден формат пубкев который он приниммает


# cat ~/.ssh/PS.pub 
ssh-rsa AAAAB3NzaC1yc... vqH 

а это  посмотрел какого формата мой публичный ключ. 
ну что он подходит.


   -Q query_option
             Queries ssh for the algorithms supported for the specified version 2.  The available features are: cipher (supported symmetric ciphers), cipher-auth (supported symmetric
             ciphers that support authenticated encryption), mac (supported message integrity codes), kex (key exchange algorithms), key (key types), key-cert (certificate key types),
             key-plain (non-certificate key types), and protocol-version (supported SSH protocol versions).




вот этотс способ поиска хоста
подойдет только уесли у нас known_hjosts незашиорыванный

# cat ~/.ssh/known_hosts | grep 94.247.130.176
94.247.130.176 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBF53bZ4iZxmuHKkf+YrK6f3nT5+iV9Drs+Sg3yxQmQqZ5xvkPjXBXRG7HFoNRQyqye0/3v8fEpA+K/rPZjEcwAU=
[94.247.130.176]:10222 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAfS3sFK738obrzogmaCnTUu95Yay0lvfz1rQh96soenzQlZrJGa7mbOVZAMYr5etp820YyRWFfeF8B8D9jyDeI=
[94.247.130.176]:10223 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAfS3sFK738obrzogmaCnTUu95Yay0lvfz1rQh96soenzQlZrJGa7mbOVZAMYr5etp820YyRWFfeF8B8D9jyDeI=
[94.247.130.176]:23 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAfS3sFK738obrzogmaCnTUu95Yay0lvfz1rQh96soenzQlZrJGa7mbOVZAMYr5etp820YyRWFfeF8B8D9jyDeI=


зато четко видно в каком формете зывисывается ip и порт. если порт 22 то просто IP
а если порт кастомный то формате  [IP]:порт
это вадно знаь потому что если файл заширофынный то там записи будут в виде 

|1|XHdJr6BqLKtAyyCbbrWpADAck18=|GdlTwJO6IALypFvQPswcpm4kMu0= ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGbJDBZW7TEtpCpouVNbt0tWx0oothfgMe/lqgngUcAB

и там ты хреь поймешь какой ip и какой порт. 
только тип ключа и ключ.

а хост нейм ипорт важно знать чтобы искать через ssh-keygen

# ssh-keygen -F "[94.247.130.176]:10223"  -l -E sha256 -f ~/.ssh/known_hosts
# Host [94.247.130.176]:10223 found: line 135 
[94.247.130.176]:10223 ECDSA SHA256:QUQ7k27XyiMrUuNUuTpgZNHijLuplwEEZkLeFUFj4nQ 

вот почмуважно знаи в каком формет указывать ip и порт в ssh-keygen при поиске

важно замтеть что ECDSA это на смом дееле ecdsa-sha2-nistp256
тоеть в ssh -o подтсвляется именно ecdsa-sha2-nistp256  а не ecdsa

ssh -G позукывает хрень знает что. скорей всего настйоки локального лкиента. но никак не 
настойки удаленного серверва !!!!



# ssh-keyscan  -4 -p 10223  94.247.130.176 > 12.txt
# ssh-keygen  -F "[94.247.130.176]:10223"  -l -E sha256 -f ./12.txt
[94.247.130.176]:10223 RSA SHA256:TMrW/lwZay8QUO/alEmvd+sgSv6jikRlya8hR5aXLR8 
[94.247.130.176]:10223 ECDSA SHA256:f5BIx7AXMSq3iWrz0+dkVs+CbhWAZWfI6mRj3ktrOJ0 
[94.247.130.176]:10223 ED25519 SHA256:qeADXJfnq1vGUlZKfhGcCA+fXQCddmB3ubrj/jVEm9g 

а ум еня накомпе вот такой ключ

]$ ssh-keygen  -F "[94.247.130.176]:10223"  -l -E sha256 -f ~/.ssh/known_hosts
[94.247.130.176]:10223 ECDSA SHA256:QUQ7k27XyiMrUuNUuTpgZNHijLuplwEEZkLeFUFj4nQ 


срванваю. 
на компе       ECDSA SHA256:QUQ7k27XyiMrUuNUuTpgZNHijLuplwEEZkLeFUFj4nQ 
в интернегте   ECDSA SHA256:f5BIx7AXMSq3iWrz0+dkVs+CbhWAZWfI6mRj3ktrOJ0

чтото явно не совпдаатает !!


забавно выгляди команда на удаление фиггенра  из known_jhosts
$ ssh-keygen -f "/home/vasya/.ssh/known_hosts" -R "[94.247.130.176]:10223"

тоесть оопятбеже мы видим "[94.247.130.176]:10223"

====

ssh -G = ????? показаывает ли он что удаленный сервер потцениаьно
разрешил входпо ключу или нет ???? ПРОЯСНИТЬ!!!!

==
суер важны момент пири конетке на ssh срвереве

деажим через ssh -vvvv

$ ssh -vvv
...
debug1: Server host key: ecdsa-sha2-nistp256 SHA256:f5BIx7AXMSq3iWrz0+dkVs+CbhWAZWfI6mRj3ktrOJ0
...
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password
...
debug1: Next authentication method: publickey
debug1: Offering public key: RSA SHA256:XzR4kVrDUalGvF2fq+HXLlCRUBtTdD0Z7wtgzQsslKY /home/vasya/.ssh/PS



то есть во первых сосмотрим чему равен фингер
во вторых какие методы аутентифицкаии нам доступны по факту
в третьих последние стоки показывают как выглядят строки когда происходит вход по ключу

а вот пример когда в списке аутентификаций нет пубкея
Authentications that can continue: gssapi-keyex,gssapi-with-mic,password

хотя сам сервер поддерживает но каким то макаром фортигейт вырезал эту опцию в пакете 
котоый прилетел нащеуму клиену. поэтом наш клиент небудет пробовать так входить

даже такое не поможет 
ssh ds01.lcwaikiki.com  -vvv  -p 22 -o PAsswordAuthentication=no -o PubKeyAuthentication=yes  -o PreferredAuthentications=publickkey

далее. ssh -G IP = эта команда нихуя незначит. то что она покзвыает это полная хуйня.
в ее выводе есть инфо  том пддерживатет ли хост аутертицфикаци по паролю или ключу. но 
непонятно к какому хосту эта инфо имеет отношение. по факту у меня ни на локальном компе неразрешен
вход по паролю ни на удаленном. но вывод этой комнды покажет что разрешен на какомто непонятно 
хосте вход п паролю  поэтому на вывод это йомандй надо положить хуй. единсвтеннйы реальнй способ понять
подежвает ли хосьт вход по паролю или ключу это вывод команды:

$ ssh -vvv root@kvs12-test.waba.bot 2>&1 | grep Authentications
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic

вот только отслюада моно точно опрееить какой сопоб аутенфтикациии ест на удаленном хосте !!!


далее. еще раз еще  о том как взять файл на сервере с его хост ключами и вычислить 
для них финерприент

# ls -1 /etc/ssh/*.pub | xargs -L 1 -I %  ssh-keygen   -l -E sha256 -f  %
256 SHA256:sGKXxLKWM1EtlgYjHmU4t3Ac068fIqb69Fx+Z1jWFqc no comment (ECDSA)
256 SHA256:q7t6yVOlVqfNIIL4KnPm4dDBpJEs6FfBYsOL8xButDo no comment (ED25519)
3072 SHA256:rMGMZBxMXzLF9tuG/8yQ84Y6CeMWopU0KorHWIik3cs no comment (RSA)

а вот смотрим какой по факту нам этот удаленный серчер ключ предьявляет:
$ ssh -vvv root@kvs12-test.waba.bot 2>&1 | grep -i "Server host key"
debug1: Server host key: ecdsa-sha2-nistp256 SHA256:sGKXxLKWM1EtlgYjHmU4t3Ac068fIqb69Fx+Z1jWFqc

также напоминаю что ECDSA и ecdsa-sha2-nistp256  это одно и тоже


| далее.  -o PubkeyAuthentication
вопрос нам надо заути на удаленный сервер тольео по паролю. а по ключу нам ненадо.
наша цель -  понять реально ли на удаленном серверер запрещена аутентификация по паролю.
для этого надо запретить вход по ключу. как это сделать 
отввет

$ ssh -o PubkeyAuthentication=no ...

тоест вот этот ключ запрещает испольовать RSA ключи для аутентфикации


или второй вариант

$ ssh -o PubkeyAuthentication=no -o PreferredAuthentications=password  example.com

но тогда в истории bash останется пароль

| далее. ProxyJump


как зайти на хост B через хост A

хост A  = 8.8.8.8
хост B  = 10.10.10.10

$ ssh -J ubuntu@8.8.8.8  vasya@10.10.10.10

а теперь как это запиать в ssh config 


Host host-b  10.10.10.10
HostName 10.10.10.10
IdentityFile /home/vasya/.ssh/id_rsa
ProxyJump ubuntu@8.8.8.8
Port 22
User vasya
ForwardAgent yes

опцию ProxyJump подерживают только новые версии ssh демона. а старые нет. 
вместо этого тогда надо юзать опцию ProxyCommand


Host yandex-demo-erp      172.16.0.21
   HostName 172.16.0.21
   user  vasya
   IdentityFile /home/vasya/.ssh/id_rsa
   ProxyCommand           ssh -q -A vasya@8.8.8.8 nc %h %p
   Port 22


| далее. запретить вход по паролю.
для этого достаточно в конфиг sshd_config вставить строку

PasswordAuthentication no

и перезапустить сервис. НО! подстава состоит в том что также надо 
посмотреть какие файлы еще есть в папке /etc/ssh/sshd_config.d 
дело в том что если там есть файлы то они ссука перебивают настройки
из основного файле. например там может быть вот такой файл

# cat /etc/ssh/sshd_config.d/50-cloud-init.conf 
PasswordAuthentication yes

тогда он ссука пеербивает настрйоки в основном файле и у нас по прежнему работаут вход
через ssh по паролю !!!!





@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



- я пытаюсь разобраться как работает ssh клиент
для начала надо научиться узнавать какой сокет в в /proc/pid/fd ведет в какой IP:port
пример. имеем
вот я подключился к удаленнму 100.0.0.8
имеем на нашем хосте процесс
vasya    27757  0.1  0.0  57320  5804 pts/20   S+   22:08   0:00 ssh root@100.0.0.8
смотрим какие файлы он открыл
$ ls -1al /proc/27757/fd
total 0
dr-x------ 2 vasya vasya  0 июл 11 22:08 .
dr-xr-xr-x 9 vasya vasya  0 июл 11 22:08 ..
lrwx------ 1 vasya vasya 64 июл 11 22:08 0 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 1 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 2 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 3 -> 'socket:[1017376]'
lrwx------ 1 vasya vasya 64 июл 11 22:08 4 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 5 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 6 -> /dev/pts/20

видим что один из файлов это сокет. 
мы хотим узнать куда ( в плане IP:port ) ведет этот сокет
$ lsof -n | grep '1017376'
ssh       27757                  vasya    3u     IPv4            1017376       0t0        TCP 100.0.0.1:53266->100.0.0.8:ssh (ESTABLISHED)

теперь мы поимаем что когда процесс пишет в этот "файл" то по факту байты улетают на 
удаленный сервер 100.0.0.8:22

кстати теперь зайдем на удаленный сервер и посмотрим какой процесс там заведует 
обработкой принятых байтов. тоесть у какого процесса на той стороне открыт сокет который
принимает байты от нас. 

(удаленный сервер)
# lsof -n | grep -i 53266
sshd      1438                root    3u     IPv4              23957      0t0        TCP 100.0.0.8:ssh->100.0.0.1:53266 (ESTABLISHED)

это процесс с pid=1438
(удаленный сервер)
# ps aux | grep 1438
root      1438  0.0  1.0 107984  7028 ?        Ss   19:08   0:00 sshd: root@pts/1

(удаленный сервер)
# pstree -Asp 1438
systemd(1)---sshd(1337)---sshd(1438)---bash(1542)---pstree(1584)

(удаленный сервер)
# ps aux | grep -E "1438|1337"
root      1337  0.0  0.8  72296  5584 ?        Ss   18:38   0:00 /usr/sbin/sshd -D
root      1438  0.0  1.0 107984  7028 ?        Ss   19:08   0:00 sshd: root@pts/1


таким образом мы видим что поток с нашего компа на удаленном компе обслуживает
принимает процесс sshd но не главный а его дочерний процесс форк (который кстати запущен по рутом заметим)

а какие же там файлы открыты у 1438

(удаленный сервер)
# ls -1al /proc/1438/fd
total 0
dr-x------ 2 root root  0 Jul 11 19:08 .
dr-xr-xr-x 9 root root  0 Jul 11 19:08 ..
lrwx------ 1 root root 64 Jul 11 19:08 0 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 1 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:18 10 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:18 11 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:08 2 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 3 -> 'socket:[23957]'
lrwx------ 1 root root 64 Jul 11 19:08 4 -> 'socket:[22651]'
lr-x------ 1 root root 64 Jul 11 19:08 5 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 6 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 7 -> /run/systemd/sessions/5.ref
lrwx------ 1 root root 64 Jul 11 19:18 8 -> /dev/ptmx

в том числе открыт  socket:[23957] котоырй принимает байты с нашего хоста 

получатеся на нашем компе процесс 27757 ssh root@100.0.0.8 имеет открытый файл-сокет /proc/27757/fd/3 -> 'socket:[1017376]'  в который он пишет байты ( и принимает) а эти
байты уже по сети летят на удаленный сервер и там их принимает процесс 1438 sshd: root@pts/1
через  файл /proc/1438/fd/3 -> 'socket:[23957]'

но это только часть картины. когда 1438 получил байты с нашего компа то ему нужно их
послать в баш с которым мы хотим там работать. 
из этой картины видно на удаленном сервере 1438 sshd запустил баш(1542)
(удаленный сервер)
# pstree -Asp 1438
systemd(1)---sshd(1337)---sshd(1438)---bash(1542)  

вот в него 1438 и должен пихать полученные байт.
посмотрим какие файлы открыты у 1542
(удаленный сервер)
# ls -1al /proc/1542/fd
total 0
dr-x------ 2 root root  0 Jul 11 19:08 .
dr-xr-xr-x 9 root root  0 Jul 11 19:08 ..
lrwx------ 1 root root 64 Jul 11 19:08 0 -> /dev/pts/1
lrwx------ 1 root root 64 Jul 11 19:08 1 -> /dev/pts/1
lrwx------ 1 root root 64 Jul 11 19:08 2 -> /dev/pts/1
lrwx------ 1 root root 64 Jul 11 19:18 255 -> /dev/pts/1

видно что никаких сокетов пайаов и прочих хитрых файлов неоткрыто у баша 1542.
это значит что условно говоря баш знать незнает и неподозревает что на нем работают 
в удаленном режиме. для него вся работа происходит как бутто на локальном компе с ним работают. в моем понимании 1438 sshd он тупо посылает полученные байты в /proc/1542/fd/0
и это как бы просто понятно воольготно.  что меня больше интересует это как 1438
сканирует станадртный вывод /proc/1542/fd/1 ведь 1438 должен ловит все что вылетает из баша 
и отправлять обратно через /proc/1438/fd/3 ->'socket:[23957]'
Если мы еще раз посмотрим на открытые файлы  у 1438
(удаленный сервер)
# ls -1al /proc/1438/fd
total 0
dr-x------ 2 root root  0 Jul 11 19:08 .
dr-xr-xr-x 9 root root  0 Jul 11 19:08 ..
lrwx------ 1 root root 64 Jul 11 19:08 0 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 1 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:18 10 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:18 11 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:08 2 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 3 -> 'socket:[23957]'
lrwx------ 1 root root 64 Jul 11 19:08 4 -> 'socket:[22651]'
lr-x------ 1 root root 64 Jul 11 19:08 5 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 6 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 7 -> /run/systemd/sessions/5.ref
lrwx------ 1 root root 64 Jul 11 19:18 8 -> /dev/ptmx

то мы увидим что /dev/null нас неинереусует. что пайп начинается и заканчивается
сам на себе. тоесть он выходит из данного процесса и входит в него же. 
таким образом мне только приходдит в голову что по идее все что летит на стандартный вывод
 у баша 1542 возможно возможно автоматом ядро дублирует (или типа того ) на какойто /dev/ptmx у 1438 тоесть примерно говоря все что баш 1542 отправляет в /proc/1542/fd/1 -> /dev/pts/1
 все это ядро автоматом дублирует на какойто /dev/ptmx у 1438. вот это надо проверить с этим надо разобраться потому что надо понять каким макаром то что баш 1542 пихает на свой 
 стадантртый вывод попадает в 1438 sshd чтобы он мог это отправить нашему клиенту.
 для этого мы начнем strace процесса 1438 

 (удаленная машина)
# strace -f -p 1438
strace: Process 1438 attached
select(11, [3 5 10], [], NULL, NULL
тоесть мы видим что select пасет появление информации на файлах 3,5,10
ну 3 это у нас сетевой сокет щас он нас неинтереусет, 5 это пайп и если чстно я непонимаю
что он вообще делает зачем нужен, а вот 10 это /dev/ptmx вот я ожидаю что с него и польется 


далее я взял на удаленной машине и посла в /dev/pts/1 мессадж.
(удаленная машина)
# echo "111" > /dev/pts/1
тоесть я проэмулировал что баш 1542 чтото выплюнул на свой старнадартнй вывод.
и вот что я вижу у 1438

(удаленная машина)
# strace -f -p 1438
...
read(10, "111\r\n", 16384)

и точно как мы видим из файла 10 тоесть их /proc/1438/fd/10 -> /dev/ptmx
прилетели "111" которые мы направили в /dev/pts/1 таким образом все что вылетает ищ баша 1542 в стандартный вывод /proc/1542/fd/1 -> /dev/pts/1 оно автоматом ядром направляется в 
/proc/1438/fd/10 -> /dev/ptmx и таким макаром 1438 sshd получает автоматом в свои недра 
все что вылетело из баша 1542. ну и далее было бы логично что получив эти данные 1438 должен 
их пихать в сетевой сокет 3 чтобы это улетело на удаленный хост к нашему клиенту
и это так и есть  потому что далее я вижу

(удаленная машина)
# strace -f -p 1438
...
read(10, "111\r\n", 16384)
...
write(3, "\32q\274_\225\316\374\265\"\352\313g}d\34\311\303\334\25\236\254\235\"i\215\303\374\274E\1\226#"..., 44) = 44

3 это сокет socket:[23957] , тоесть когда 1438 пишет в 3 то ядро эти байты посылает  в сеть 
в 100.0.0.1 тоесть в наш хост который клиент (напомню 100.0.0.8 это удаленный сервер а 100.0.0.1 это наш хост который клиент)

и да эти "111" и вижу на моем клиенстком компе
(локальный комп)
root@test:~# 111

остается два вопроса. каким макаром так нестроено что если кидать данные в /dev/pts/1 то они автоматом переслыаеются ядром в /dev/ptmx
второй вопрос. если я на компе открою баш в граф оболочке то у этого баш тоже будут 
на бекенде открыты файлы вида /dev/pts/X так вот вопрос каким макаром то что вылетает 
из /dev/pts/X появляется на экране терминала в граф оболочке. тоесть условно говоря почему
в одном случае данные летят в /dev/pts/X и в итоге они отображаются на экране а вдругом
случае напрвляем дарные в /dev/pts/X и они летят в сеть а на экране ничего нет.

- думаю самое время изучить как работает ptmx. смотрим не man ptmx ибо там мало что полезного а сразу 
$ man 4 pty 
и оказывается очень интересно - /dev/pty/X файл появляется в системе тоггда когда процесс
открывает файл ptmx. ксати странно что я нашел два файла ptmx.
$ find /dev/ -name ptmx
/dev/pts/ptmx
/dev/ptmx
какой из двух надо открыать? ( по этому вопросу я прочитал в инете что неважно как называется
файл важно какой major mimnor у этого файла. если один и тот же то похер какой открывать  . будет 
одно и тоже)
из свойств процессов на /proc  я выяснил что везде используется /dev/ptmx
и неисползуется /dev/pts/ptmx пример
# stat  /proc/1438/fd/11
  File: /proc/1438/fd/11 -> /dev/ptmx
  Size: 64        	Blocks: 0          IO Block: 1024   symbolic link
Device: 4h/4d	Inode: 25342       Links: 1

и кстати на сайт ibm  я нашел то что Because a symbolic link refers to a file by its path name rather than by its inode number, a symbolic link can refer to files in other mounted file systems. фишка здесь  в том что в симболинк линке ссылка на файл идет не по иноде
а по пути. что и видно из stat
ладно это мы отвлклись


в любом случае  совсем непонятно это то что 
у нас куча pts файлов и всего один (скорей всего /dev/ptmx)  ptmx файл. 
так вот в man pty написано что когда мы открыли ptmx файл в программе у нас появлется
новый /dev/pts/X файл и то что если мы шлем инфо в /dev/pts/X то она автоматом (как через пайп) вылает из ptmx файла. и наоборот если мы пишем в ptmx то оно вылетает из /dev/pts/X
получается типа такого 
/dev/pts/ptmx <--- ядро ---> /dev/pts/X
теперь из этого совершенно понятно каким макаром 1438 sshd получает автоматом себе на вход в 
/proc/1438/fd/10 -> /dev/ptmx то что выплюнул bash 1452 в /dev/pts/1
теперь это стало абсолдтно понятно. 

- но возникает вопрос если у нас для всех /dev/pty/X всего навсего один /dev/ptmx то вопрос вот у нас есть процесс 1438 у него открыто несколько 
ptmx  
# ls -1al /proc/1438/fd
total 0
lrwx------ 1 root root 64 Jul 11 19:18 10 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:18 11 -> /dev/ptmx
как нам узнать к каким /dev/pty/X они ведут ?? совершенно непонятно.
и еще вопрос вот мы шлем в /dev/pty/11 чтото значит автомтом оно вылетает в /dev/pty/ptmx
но ведь у нас у кучи процессов открыт /dev/pty/ptmx они что все одновременно это получаются? что за бред. какой смысл. 

значит я пробовал пихать в /dev/ptmx но толку никакого. нигде ничего не вылезает.
еще я пробовал перехватывать данные из /dev/ptmx при условии что я кидаю данные 
в /dev/pts/1 но мне вручную поймать данные вылетающие из /dev/ptmx не удалось.
мое впечателение что когда данные в /dev/ptmx появляются то ядро их отдает только процессу
который открыл изначально /dev/ptmx и создал /dev/pts/1 
я только так могу это обьяснить. что не могу даные рукамт словить из /dev/ptmx 
Но так в целом я понял систему нипель о том что ссш на той стороне открывает /dev/ptmx
при этом ядро создает /dev/pts/1 при этом ссш создает bash который она крепит  к /dev/pts/1
далее ссш сует прилетвшие данные с той стороны в /dev/pts/1 и таким макаром баш полуает команды на вход.
и обратное явление - когда баш высирает данные в /dev/pts/1 то ядро эти данные автоматом перекачивает в 
/dev/ptmx который открыт у ссш поэтому вывод баша уалетает по сети обратно клиенту ссш. таким макаром
то что уклиента не терминале на лжпотпе вводится оно через эти прокладки прилетает на уделенный комп
в stdin. а что то баш высирает на stdout в итоге через прокладки доставляется обратно на терминал клиента.
и возникает вот эта иллюзия что баш запушен локально на лэптопе.


далее. 
вобщем в итоге стало понятно что ссш запускает на удаленном сервере баш процесс.
и перехватвыает ввывод с него и отправляет обратно клиенту. и таким макаром проксирует
ввод на него. проксирует путем того что открывает /dev/ptmx . ядро при этом создат /dev/pts/1
далее ссш запускает баш и к нему прикрелмяет в его fd/0 fd/1 fd/1 вот этот /dev/pts/1
и его баш срет вывод на fd/1 то ядро автоатом это пеересылвает на /dev/ptmx который слушает ссш.
на а пеередать от клиента на ввод баща ввобше нет проблем. таким ммкаром ссш проксирует 
ввод и вывод на баш процесс.

вот еще раз я покажу какие файлы открты у ссш процесса на той стороны

$ pstree -A -s -p 26233
systemd(1)---sshd(8716)---sshd(26199)---sshd(26232)---bash(26233)---pstree(26513)

$ sudo ls -1al /proc/26232/fd
dr-x------ 2 root  root   0 сен 15 01:33 .
dr-xr-xr-x 9 vasya vasya  0 сен 15 01:33 ..
lrwx------ 1 root  root  64 сен 15 01:33 0 -> /dev/null
lrwx------ 1 root  root  64 сен 15 01:33 1 -> /dev/null
lrwx------ 1 root  root  64 сен 15 01:33 10 -> /dev/ptmx
lrwx------ 1 root  root  64 сен 15 01:33 12 -> /dev/ptmx
lrwx------ 1 root  root  64 сен 15 01:33 13 -> /dev/ptmx
lrwx------ 1 root  root  64 сен 15 01:33 2 -> /dev/null
lrwx------ 1 root  root  64 сен 15 01:33 3 -> 'socket:[365573483]'
lrwx------ 1 root  root  64 сен 15 01:33 4 -> 'socket:[365572669]'
lrwx------ 1 root  root  64 сен 15 01:33 5 -> 'socket:[365574337]'
lr-x------ 1 root  root  64 сен 15 01:33 6 -> 'pipe:[365575207]'
l-wx------ 1 root  root  64 сен 15 01:33 7 -> /run/systemd/sessions/43889.ref
l-wx------ 1 root  root  64 сен 15 01:33 8 -> 'pipe:[365575207]'
lrwx------ 1 root  root  64 сен 15 01:33 9 -> 'socket:[365572680]'

вот мы видим что ссш открыл /dev/ptmx


а вот еще так посмотрим тоже самое
$ sudo lsof -p 26232
sshd    26232 vasya    0u   CHR                1,3      0t0         5 /dev/null
sshd    26232 vasya    1u   CHR                1,3      0t0         5 /dev/null
sshd    26232 vasya    2u   CHR                1,3      0t0         5 /dev/null
sshd    26232 vasya    3u  IPv4          365573483      0t0       TCP localhost:ssh->localhost:44606 (ESTABLISHED)
sshd    26232 vasya    4u  unix 0xffff9ef0cbe0e400      0t0 365572669 type=DGRAM
sshd    26232 vasya    5u  unix 0xffff9eee8b5e6000      0t0 365574337 type=STREAM
sshd    26232 vasya    6r  FIFO               0,12      0t0 365575207 pipe
sshd    26232 vasya    7w  FIFO               0,25      0t0    106237 /run/systemd/sessions/43889.ref
sshd    26232 vasya    8w  FIFO               0,12      0t0 365575207 pipe
sshd    26232 vasya    9u  unix 0xffff9ef0cbe0c400      0t0 365572680 /tmp/ssh-u0wFcT0P7E/agent.26232 type=STREAM
sshd    26232 vasya   10u   CHR                5,2      0t0        88 /dev/ptmx
sshd    26232 vasya   12u   CHR                5,2      0t0        88 /dev/ptmx
sshd    26232 vasya   13u   CHR                5,2      0t0        88 /dev/ptmx



отсюда видно что сокет 'socket:[365573483]' как раз это сокет "TCP localhost:ssh->localhost:44606 (ESTABLISHED)"


далее смоитрим уже файлы открытые  у баш
$ sudo ls -1al /proc/26233/fd
total 0
dr-x------ 2 vasya vasya  0 сен 15 01:37 .
dr-xr-xr-x 9 vasya vasya  0 сен 15 01:37 ..
lrwx------ 1 vasya vasya 64 сен 15 01:37 0 -> /dev/pts/11
lrwx------ 1 vasya vasya 64 сен 15 01:37 1 -> /dev/pts/11
lrwx------ 1 vasya vasya 64 сен 15 01:37 2 -> /dev/pts/11
lrwx------ 1 vasya vasya 64 сен 15 01:37 255 -> /dev/pts/11


таким образом проксификация ввода и вывода баш у ссш идет через /dev/ptmx

мы можем поавторить тоже самое указав ссш явно что ему надо зайти на комп и запустить bash

$ ssh -t   localhost bash
мы получим тоже самое. проксификация к баш от ссш идет через /dev/ptmx
тоесть вот этот ключ -t он говорит ссш что он должен создать терминал через /dev/ptmx 
запустить баш и к нему прикрепить /dev/pts/1
вот что значит ключ -t
ну тоесть создание вирт терминала тоесть создание pts (аналог tty) нужен ссш только для 
того чтобы можно было типа удобно перехыватывать вывод с баша процесса и наверное чтобы более удобно
было пихать в бащ процесс.


 а если мы запустим без ключа -t то механизм прокрсирования будет другой.
 показываю
$ ssh  localhost  bash 
tty
not a tty
echo $$
4873

видно что  у нас на экране нет приглащения баш. но по факту у нас наудаленном компе баш заупстился.
только у него нет fd/0 , fd/1, fd/2 направленных на /dev/pts/1

вот как на удленном компе выглядит процесс баша в ps
$ ps -p 4873
  PID TTY          TIME CMD
 4873 ?        00:00:00 bash

и видно что этот процесс неимеет TTY (то бишь /dev/pts/1)

посмтрим куда же ведую fd/0 fd/1 fd/2 у этого процесса
ls -1al /proc/$$/fd
total 0
dr-x------ 2 vasya vasya  0 сен 15 01:53 .
dr-xr-xr-x 9 vasya vasya  0 сен 15 01:53 ..
lr-x------ 1 vasya vasya 64 сен 15 01:53 0 -> pipe:[365710372]
l-wx------ 1 vasya vasya 64 сен 15 01:53 1 -> pipe:[365710373]
l-wx------ 1 vasya vasya 64 сен 15 01:53 2 -> pipe:[365710374]

тоесть мы видим что 0,1,2 ведут не в pts/1 а в пайпы.
и логично предполить что эти папйпы все ведут в ссш. проверяем
sudo ls -1al /proc/4872/fd
total 0
dr-x------ 2 root  root   0 сен 15 01:56 .
dr-xr-xr-x 9 vasya vasya  0 сен 15 01:56 ..
lrwx------ 1 root  root  64 сен 15 01:56 0 -> /dev/null
lrwx------ 1 root  root  64 сен 15 01:56 1 -> /dev/null
l-wx------ 1 root  root  64 сен 15 01:56 11 -> pipe:[365710372]
lr-x------ 1 root  root  64 сен 15 01:56 12 -> pipe:[365710373]
lr-x------ 1 root  root  64 сен 15 01:56 14 -> pipe:[365710374]
lrwx------ 1 root  root  64 сен 15 01:56 2 -> /dev/null
lrwx------ 1 root  root  64 сен 15 01:56 3 -> socket:[365709578]
lrwx------ 1 root  root  64 сен 15 01:56 4 -> socket:[365709586]
lrwx------ 1 root  root  64 сен 15 01:56 5 -> socket:[365706899]
lr-x------ 1 root  root  64 сен 15 01:56 6 -> pipe:[365710370]
l-wx------ 1 root  root  64 сен 15 01:56 7 -> /run/systemd/sessions/43893.ref
l-wx------ 1 root  root  64 сен 15 01:56 8 -> pipe:[365710370]
lrwx------ 1 root  root  64 сен 15 01:56 9 -> socket:[365710371]

и мы видим совпадение файлы 11,12,14 как раз имеют теже номера пайпов.
таким макаром если мы запустили баш без терминала то ссш проксирует ввод и вывод через пайпы.
 
 ^
^|^
^|^
|||==== закончил тут 






----------
ssh
windows
proxy
putty
plink

как в виновсе войти по ssh через прокси хост

=> putty.exe -proxycmd "plink.exe vasya@81.163.39.39 -P 22 -nc 10.10.10.10:22 -i c:\Users\vasya\.ssh\fire.ppk " vasya@10.10.10.10  -i c:\Users\vasya\.ssh\fire.ppk

----------
ssh
tunnel
windows
putty
proxy
plink


как пробросить порт через ssh+proxy например к мускулу
в командной строке :

putty.exe -ssh -proxycmd "plink.exe vasya@81.163.39.93 -P 22 -nc 10.10.10.10:22 -i c:\Users\vasya\.ssh\fire.ppk "  vasya@10.10.10.10  -i c:\Users\vasya\.ssh\fire.ppk   -L  127.0.0.1:3307:10.10.10.10:3306

пробросится порт на локальный 3307


там правда еще на экране терминал ssh открывается. которой по идее ненужен. чтобы экран с shell  не пявлялся надо 
добавить ключ -N

----------
| config

как посмтреть настйроки на sshd сервере

# sshd -T
-----------
| ssh_exchange_identification: Connection closed by remote host

итак стучимся на хост ssh а в ответ такая хуйня
ко виноват и что делать


 я столкнулся с такой ошибкой когда стучался на ssh хост через другой ssh хост
 тоесть я иду на хост "B" через хост "A" (ssh proxy/ ssh tunnel)

 я --->  "A" ----> "B"

 так вот в чем была проблема в моем случае это в том что я указал в 
 ssh конфиге на своем компе неверный IP компа "B"
 поэтому до хоста "A" конект проходил успешно. а с хоста "A" конект шел в никуда.


 теперь важные моменты как траблшутить ssh конект коода он идет 
через ssh proxy/ssh tunnel

1. важный момент на прокси ssh сервеере в логах ssh даже при успешном конекте 
до хоста B никакой инфо НЕТ. тоесть

(хост "A") # journalctl -f -u ssh
он будет пустой!!!! поэтому какието логи искать на прокси ssh бесолезно.
я потыкася в инетет и пришео к выводу что чтобы както это логрировать надо както
изощренно мудить.


2. логи о ssh будут только на хосте "B"  при успешном конкете будет запись

Jun 27 15:44:44 nl-test-05 sshd[2215]: Accepted publickey for vasya from 172.16.10.1 port 33586 ssh2: RSA SHA256:SVN6k7AI9km/72M7XyPJdb5WtMHItT9G89nJBo9Esi8
Jun 27 15:44:44 nl-test-05 sshd[2215]: pam_unix(sshd:session): session opened for user vasya(uid=1000) by (uid=0)
d

ПОЭТОМУ я хочу сказать что если есть прлблема с конектом до ssh хоста через прокси ssh
хост то основной дебаг остатется делать только на стороне клиента!


привожу примео конфига ssh на стороне клиента

есть два вариант анастрйоки как мы подключаемся через прокси.

1) ProxyJump nl-proxy-01-test
2) ProxyCommand           ssh -q -A vasya@nl-proxy-01-test nc %h %p

ProxyJump работае на более новых версиях sshd
а ProxyCommand на более старых

итак два аривнта конфига

1)
Host nl-test-05  172.16.10.21
HostName 172.16.10.21
IdentityFile ~/.ssh/vasya
ProxyJump nl-proxy-01-test
Port 22
User vasya
ForwardAgent yes



2)
Host nl-test-05  172.16.10.21
HostName 172.16.10.21
IdentityFile ~/.ssh/vasya
ProxyCommand           ssh -q -A vasya@nl-proxy-01-test nc %h %p
Port 22
User vasya
ForwardAgent yes


так вот что я хочу скзать дебаг делаем через вот так


$ ssh -vvv nl-test-05


и если мы используем ProxyCommand  то дебаг будет мегаубогий.
а вот если мы юзаем ProxyJump то дебаг будет очень даже информативный.


вот еще моментик.
как выгядит вход по парою и как по RSA ключу


Jun 27 15:40:00 nl-test-05 sshd[1155]: Accepted password for vasya from 172.16.10.1 port 53980 ssh2
Jun 27 15:40:00 nl-test-05 sshd[1155]: pam_unix(sshd:session): session opened for user vasya(uid=1000) by (uid=0)




Jun 27 15:41:03 nl-test-05 sshd[1252]: Accepted publickey for vasya from 172.16.10.1 port 48000 ssh2: RSA SHA256:SVN6k7AI9km/72M7XyPJdb5WtMHItT9G89nJBo9Esi8
Jun 27 15:41:03 nl-test-05 sshd[1252]: pam_unix(sshd:session): session opened for user vasya(uid=1000) by (uid=0)


вот и все. смотрим дебаг пытается понять

-------

| MaxStartups

в лоагх sshd можно заметить вот такое

# journalctl -u ssh --since today | grep Max

июн 27 08:12:30 vl-proxy-test sshd[828]: error: beginning MaxStartups throttling
июн 27 08:12:30 vl-proxy-test sshd[828]: drop connection #10 from [197.26.19.193]:38230 on [10.120.1.10]:22 past MaxStartups

июн 27 08:12:33 vl-proxy-test sshd[828]: exited MaxStartups throttling after 00:00:03, 10 connections dropped


о чем эта хрень.

смотрим в конифг sshd

# sshd -T  | grep -i max
maxstartups 10:30:100

что значать эти цифры

10: Number of unauthenticated connections before we start dropping

30: Percentage chance of dropping once we reach 10 (increases linearly for more than 10)

1000: Maximum number of connections at which we start dropping everything

тоетсть это типа некая такая DDos защита чтоли



запись будет и  journalctl -u ssh и  в /var/log/auth.log

====


| ssh
| ansible

можно ансибль запулить так чтобы у него  было много форков
это дает то что ансибль будет стучать сразу на N хостов сразу ( если N форков )
задается это через ключ   -f N
по дефолту ансибль запускает 5 или 10 форков.

далее вот что важно - если у нас ансибль стучится до хостов через бастион тоесть через единый хост
то у ssh сервера котоырй там крутится есть ограничение  на число входящих подключений. и если 
мы начнем через ансиль туда стучать и заададим кучу форков то бастион нас нахер пошлет.
 у него есть ограничение на 10 одновременных соединений. как исправть - надо на бастионе 
исправтить вот этт ключ

 MaxStartups
             Specifies the maximum number of concurrent unauthenticated
             connections to the SSH daemon.  Additional connections will
             be dropped until authentication succeeds or the
             LoginGraceTime expires for a connection.  The default is
             10:30:100.

             Alternatively, random early drop can be enabled by
             specifying the three colon separated values start:rate:full
             (e.g. "10:30:60").  sshd(8) will refuse connection attempts
             with a probability of rate/100 (30%) if there are currently
             start (10) unauthenticated connections.  The probability
             increases linearly and all connection attempts are refused
             if the number of unauthenticated connections reaches full
             (60).

и будет шоколад

===

| ssh
| openssl
| tp-link
| archer

значит есть вай фай точка коробочка
я на нее стучуть по ssh
в ответ получаю некую хуйню
    # ssh admin@router
    Unable to negotiate with 192.168.0.1 port 22: no matching key exchange method found. Their offer: diffie-hellman-group1-sha1
решение:
 $ ssh -oKexAlgorithms=+diffie-hellman-group1-sha1  -oHostKeyAlgorithms=+ssh-dss   -c aes128-cbc admin@router

далее я нашел вот такую строчку.
config.bin это конфиг файл который можно скачать через веб морду
так вот была идея его "вскрыть" превратить в xml текстовый формат.
спрашивется нахуя? ответ - чтобы в этом конфиге отключить порт 22 потому что 
веб морда этого недает сделать.
я нашел строчку для этого
    $ openssl aes-256-cbc -d -in config.bin -k 'Archer C1200' -md md5 | openssl zlib -d -out config.tar 
начнем разбирать что значит эта портянка

openssl мегауебическая утилита. в том плане что 
хелп от этой программы просто сука нихуя не показывает из ключей которые 
эта программа поддерживает. ебаные скоты.
например берем субкоманду "dgst" она вычисляет хэш
так вот  я хочу узнать какие типы хэша поддерживает эта опция. сука как же это понять?
оказывается через двух ходовку. уебки.
шаг первый узнаем какие хэши поддерживает

    # openssl help
    ...
    Message Digest commands (see the `dgst' command for more details)
    blake2b512        blake2s256        gost              md4               
    md5               rmd160            sha1              sha224            
    sha256            sha3-224          sha3-256          sha3-384          
    sha3-512          sha384            sha512            sha512-224        
    sha512-256        shake128          shake256          sm3       

из этого шага мы узнали какие хэши поддерживает программа.
теперь второй вопрос как указать тот хэш алгоритм который мы хотим юзать.
для этого делаем второй шаг
    # openssl dgst -help
    ...
    -*                  Any supported digest

из этого наконец мы собираем паззл. значит если хотим заюзать хэш скажем md5
то это надо сделать вот так
    # openssl dgst -md5 file
охуеть

    # openssl dgst -md5 iphone3
    MD5(iphone3)= 2c99f1ee72d79c94a529d8550a989727

    # openssl dgst -sha256 iphone3
    SHA256(iphone3)= ab4e74a8d7ca61b273f06b558ed4f1ab31c65d221faf3a62b989550581918845

от хэширования переходим к симметричному шифрованию (cipher)
тут уже лучше. так как чтбы узнать все поддерживаемый ciphers 
ненужно делать двух ходовку. можно нихуя себе узнать за один проход!
    # openssl enc -ciphers
    Supported ciphers:
    -aes-128-cbc               -aes-128-cfb               -aes-128-cfb1             
    -aes-128-cfb8              -aes-128-ctr               -aes-128-ecb              
    -aes-128-ofb               -aes-192-cbc               -aes-192-cfb              
    -aes-192-cfb1              -aes-192-cfb8              -aes-192-ctr              
    -aes-192-ecb               -aes-192-ofb               -aes-256-cbc              
    -aes-256-cfb               -aes-256-cfb1              -aes-256-cfb8     


шифруем файл через cipher
    # openssl enc -e  -camellia-192-ecb -in iphone3 -out  file1.enc
    enc = зашифровать либо расшифровать через симметричный алгоритм (cipher)
    -e  = зашфровать
    -camellia-192-ecb = алгоритм которым шифровать
    -in = файл который на входе
    -out =  файл на выходе
        
    
расшифруем файл
    # openssl enc -d  -camellia-192-ecb -in file1.enc  -out  file2.unenc
    -d = расшифровать
    
замечу что если мы шифруем расшифровываемся не из файла а из STDIN STDOOUT
то  там есть приколы. про это смотри в linux-general.txt по слову "| openssl"


идиотизм субкоманды "enc" состоит в том что эти суки в мане пишут что якобы эта опция
только для зашифрования. цитирую man openssl
    enc Encoding with Ciphers.
а на самом деле эта опция она и шифрует и расшифрует. суки 

а еще прикол этой субкоманды состоит в том что ее можно вот так ебануто запустить
    # openssl  camellia-192-ecb -e -in iphone3 -out  file3.enc
то есть как видно что субкоманда "enc" просто нахуй пропущена. cipher указан без "-"
тоесть аналогичная команда это 
    # openssl enc -e  -camellia-192-ecb -in iphone3 -out  file1.enc
они идетичны. вопрос нахуй так делать. у нас верхняя команда сука не имеет опции которая 
бы указывала а что вообще делать. суки.

двигаемся дальше по опциям субкоманды enc . 
     -k 126 = опция которая описывает пароль для симметричного шифрования. 
дело в том что симметричное шифрование требует пароль
тоесть чтобы программа не спрашивала пароль то "-k" позволяет его прописать

про salt зачем он был придуман. вот у нас есть файл с паролями юзеров зашифрованными через
симметричное шифрование. получается что если несколько юзеров имеют один пароль то 
их шифрованный вид будет один и тот же. тогда придумали при шифровании к паролю которым
шифруется информация добавлять еще некоторую хрень. тогда шифрованная штука будет разная
даже если исходная информация одна и та же потому что salt все время выбирается разный.
правда при расшифровке нужно помимо пароля еще знать и salt

    # openssl enc -e  -camellia-192-ecb -k 123 -md md5   -in iphone3 -out  file1.enc
как я понял опция "-md md5" при шифровании дает то что при шифровании формируется salt
как он формируется хуй знает. так вот при шифровании опция "-md md5" вычисляет salt
на основе  пароля который мы вводим. если мы зашифровали с опцией -md md5 то при расшифровании
нужно обязательно будет тоже эту опцию указать. возможно эта хуйня работает так что 
на основе пароля вычисляется хэш и он используется как salt. так наверно.
опять же как я понимаю если при шифровании -md md5 не указывать то salt все равно создается
только хуй знает чему он равен
таким макаром я расшифроваю что значит вот эта команда
    $ openssl aes-256-cbc -d -in config.bin -k 'Archer C1200' -md md5 
во первых ее полный аналог
    $ openssl enc -d -aes-256-cbc  -k 'Archer C1200' -md md5 -in config.bin   
    enc = зашифровать \расшифровать  в зависимости от дальнейших опций
    -d  = уточнение которое говорит что именно расшифровать
    -aes-256-cbc = алгоритм шифрования
    -k 'Archer C1200' = пароль для расшифрования
    -md md5 = самая непонятная опция. она говорит как нужно вычислить salt который тоже
    юзается при шифровании. потому что нам чтобы расшифровать нам нужно знать salt
    как видно мы его в опциях не указываем но указываем как его вычислить. эта опция 
    показывает что salt как я понял равен хэшу по алгоритму md5 от пароля! охуеть
    -in config.bin = файл на входе
получается что для расшифровывания файла нужно знать иначе невозможно расшифровать:
    1) алгоритм шифрования (aes-256-cbc)
    2) пароль расшифровки  ('Archer C1200')
    3) хрень которая позволяет вычислить salt который юзается (-md md5)
    
теперь когда стало понятны все опции в openssl команде расшифруем нашу исходную команду
    $ openssl aes-256-cbc -d -in config.bin -k 'Archer C1200' -md md5 | openssl zlib -d -out config.tar 
она берет файл config.bin и расшифровыывает его через цифер aes-256-cbc используя пароль 'Archer C1200'
и используя salt котоырй вычисляется из пароля на основе md5 хэша от него , результат выдается на stdout
и через pipe передается на другой openssl который его разжимает их архива.
к слову скажу что моя версия openssl очевидно скомпилирована без поддержки zlib потому что 
    # openssl help
    Standard commands
    asn1parse         ca                ciphers           cms               
    crl               crl2pkcs7         dgst              dhparam           
    dsa               dsaparam          ec                ecparam           
    enc               engine            errstr            gendsa            
    genpkey           genrsa            help              list              
    nseq              ocsp              passwd            pkcs12            
    pkcs7             pkcs8             pkey              pkeyparam         
    pkeyutl           prime             rand              rehash            
    req               rsa               rsautl            s_client          
    s_server          s_time            sess_id           smime             
    speed             spkac             srp               storeutl          
    ts                verify            version           x509       
не содержит zlib
ксатти еше один ебанизм в том что в каких случая справа вызывается через help
а в каких то через -help

далее я взял config.bin со своего Archer C24 и тут оказалось что у него он зашифрован не через 'aes-256-cbc'
    # openssl enc -aes-256-cbc -d -in config.bin  -k 'Archer C24' -md md5
    bad magic number
далее я посмотрел а можно как то определить через какой цифер зашифрован файл. ответ нет нельзя. его надо 
сразу знать. 
на этом работа  с config.bin закончена

| openssl

померять скорость цпу 

    # openssl speed rsa
    Doing 512 bits private rsa's for 10s: 67604 512 bits private RSA's in 10.00s
    Doing 512 bits public rsa's for 10s: 1184926 512 bits public RSA's in 10.00s
    Doing 1024 bits private rsa's for 10s: 30904 1024 bits private RSA's in 10.00s
    Doing 1024 bits public rsa's for 10s: 514288 1024 bits public RSA's in 10.00s
    Doing 2048 bits private rsa's for 10s: 4865 2048 bits private RSA's in 10.00s

| openssl
некий вменяемый док по этой команде
    https://www.madboa.com/geek/openssl/

| ssh

как зайти исключительно по паролю

ssh  -o PreferredAuthentications=password -o PubkeyAuthentication=no     -v   noroot@IP



 
| ssh

как он работает. во первых надо прочиать все rfc про это дело. 
а так пока из того что я вроде как знаю:
есть файл /etc/ssh/moduli (man moduli где то я об этой файле подробно написал).
в этом файле кроме всякой служебной инфо по факту в каждой строке ест 
всего навсего простое число (2 или 3 или 5) называемое генератор (математика этой
темы изложена отдельно , ищи) и модулюс. по факту клиент и сервер догововари
ваются чтобы использовать из этого файла одинаковый модулюс и его генеоратор.
далее клиент и сервер используют алгоритм (класс таких алгоритмов называется както
непомню) который позволит им выработатть общий ключ который позволит его исполь
зовать как ключ для симметричного шифрования. Таких алгоритмов оказывается щас
мегадохрена. раньше это был просто Дифи-Хельман. Потом был Дифи-Хельман 
на элиптической кривой. А щас таких алгоримов дохерна! Я их всех условно для
себя все называются ДифиХельман.
а вот сколько этих алгоритмов щас в ssh :

		curve25519-sha256,
		curve25519-sha256@libssh.org,

		ecdh-sha2-nistp256,
		ecdh-sha2-nistp384,
		ecdh-sha2-nistp521,

		sntrup761x25519-sha512@openssh.com,

		diffie-hellman-group-exchange-sha256,
		diffie-hellman-group16-sha512,
		diffie-hellman-group18-sha512,
		diffie-hellman-group14-sha256,

		kex-strict-s-v00@openssh.com


значит вот эта группа протоколов выработки ключа

		diffie-hellman-group-exchange-sha256,
		diffie-hellman-group16-sha512,
		diffie-hellman-group18-sha512,
		diffie-hellman-group14-sha256,

это все классческий дифи-хельман , причем что вот это конкнтено значит
diffie-hellman-group-exchange-sha256 я так и ненашел. 
а про остальные я могу точно сказать

		diffie-hellman-group16-sha512,
		diffie-hellman-group18-sha512,
		diffie-hellman-group14-sha256,

значит что значит дифи хельман группа 16, 18, 14 или другой номер? я нащел
вот тут
  https://www.datai.net/article/ipsec-diffie-hellman-groups/


Diffie-Hellman      Diffie-Hellman                           RFC
Group Number	        Group Name
 	
Group 1	            768-bit modulus MODP Group             	RFC 7296
Group 2	            1024-bit modulus MODP Group	            RFC 7296
Group 5	            1536-bit modulus MODP Group	            RFC 3526
Group 14	          2048-bit modulus MODP Group	            RFC 3526
Group 15	          3072-bit modulus MODP Group	            RFC 3526
Group 16	          4096-bit modulus MODP Group	            RFC 3526
Group 17	          6144-bit modulus MODP Group	            RFC 3526
Group 18	          8192-bit modulus MODP Group	            RFC 3526
Group 19	          256-bit random Elliptic Curve Group   	RFC 5903
Group 20	          384-bit random Elliptic Curve Group	    RFC 5903
Group 24	          2048-bit MODP Group with 256-bit        RFC 5114 
                        Prime Order Subgroup	


так что 14,16,18 это у нас модулюс разного размера 2048-8192 бита
если выбрать эти алгоритмы выработчки общего ключа то как раз таки 
будет использован файл /etc/moduli потому что именно оттуда ssh будет эти 
модули искать. потому что такие модулюсы налету не вырабтаешь. они нужны
быть заготовлены заранее.  я посмтреть в файл moduli и там да. внизу есть
модулюсы 8192 бита длинной. правда там написано что их длинна 8191 бит. 
что интересно -а  интересно очень много. когда гооворят про группу 14 для примера
дифи хельмана. то это значит что задан модулюс опрделенного размера тоесть
2048 бит , и непросто размера и еще и конкретный модулюс. это прям одно
заданное число. также задан и генаратор. тоесть когда мы говоирим про группу
дифии хельмана номер такой то. то в ней четко задан модулюс определенного
размера и задан генератор. у модулюса залана нетлько его длинна но и его 
строгое значение. наример  группа 18 дифи хельмана согласно rfc3526 это
генерато 2 и модулюс 

      FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1
      29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD
      EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245
      E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED
      EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE45B3D
      C2007CB8 A163BF05 98DA4836 1C55D39A 69163FA8 FD24CF5F
      83655D23 DCA3AD96 1C62F356 20855 ...
      ...
      60C980DD 98EDD3DF FFFFFFFF FFFFFFFF


тоесть еще раз важно понять что группа дифи хельман 18 задает строго
чему равен генеартор. и какая длпиинна у модулюса . и чему он прям
равен. 
теперь присмотримся к параметру названия kex (kex значит алгоритм выработчки
общего ключа) алогоритма

         diffie-hellman-group18-sha512

и видим что помисмо группы 18 дифихельмана еще указан зачем то хеш.
нахрен он всрался? а всрался он потому что в реузльтате работы дифихельмана
у нас получается число. причем число это будет длинной от 0 1 бита 
до 8192 бита длинной. так вот потом к этому числу применяют этот хеш. а хеш
у нас всегда имеет фикированную длинну. так вот хеш котрый получится уже и 
будет исплользован как ключ к симметричному шифрованию.

так вот вроде разобрались но вот какой вопрос - если группа дифихельмана
однозначно задает непросто длинну модулюса а и чему он равен. тогда что за 
херня. в файле /etc/moduli там во первых нет именно такого модулюса я проверил.
а вместо него есть куча других модулюсов длинной 8192 бита. получается ссш
неиспользует на самом деле тот модулюс который релаьно отвечает за гурппу 18.
вместо этого как я понимаю ссш использует модулюс такой же длинны но другой. 
причем там в moduli таких модулюсов 8192 бит их несклько и ман пишет что 
он выбирается из них рандомно.  вот в этом и прикол. 
ну а в итог получается вот что. клиент звонит на сервер. они както решают
как kex аолгоритм они будут юзать. как видно выше их целая куча. если будет
заться классической ДФ(дифи хельман на основе формулы a^x mod p) то тогда 
толлько и юзается файл /etc/moduli , а для других kex алогоритмов он отншения
не имеет. 

вот эти kex алгоритмы

		curve25519-sha256,
		curve25519-sha256@libssh.org,

		ecdh-sha2-nistp256,
		ecdh-sha2-nistp384,
		ecdh-sha2-nistp521,

я считаю что они все основаны на ДФ на эллиптической кривой
почему лдя них нет своего аналога moduli файла не знаю. видимо там както
можно быстро налету все посчитать.

вот так я заускаю ssh

  $ ssh do-vpn-wan   -c  chacha20-poly1305@openssh.com    -m  hmac-sha2-512     -o KexAlgorithms=diffie-hellman-group18-sha512  -v 2>/tmp/2.txt

$ cat /tmp/2.txt | grep diffie-hellman-group18-sha512
debug1: kex: algorithm: diffie-hellman-group18-sha512

и вот видно какой kex алгоритм был выбран. 
это к ворпросу как выбрать этот kex алогоритм при старте сеанса. 
в выводе виден список всех доступных алогоритмов. я уже выше показал.
этт список. как я понял клиен и серервер договариватся какой будут юзать
из условия что оба длжны его уметь делать и беретя самый совеременный из 
списка самый силтный. по дефолту выбиарется вот этот

		sntrup761x25519-sha512@openssh.com,

чтоэто такое хуй знае. я думаю что 25519 это опять же элл кривая. 
а что такое sntrup761  я так и непонял. допускаю что в sshd_config можно
както указать список тех kex алогримтов из списка которые я разершаю 
использовать. 

когда через ДФ ключ вырабооан и поднять шифро тонель между клиетом и сервером.
тогда идет следущий шаг аутеентифиукация. по сути как я понмаю аутентификация
наверно идет на оснвое алгоримтов цифровой подписи. на клиенте ссш
вот такие файлы отвечают за аутентфикацию клиента перед сервером

ssh_host_ecdsa_key
ssh_host_ecdsa_key.pub

ssh_host_ed25519_key
ssh_host_ed25519_key.pub

ssh_host_rsa_key
ssh_host_rsa_key.pub

они назваются host keys. название очень хуево придумано. 
значит опять же есть список алгоритмов аутентифицкаии котоыре поддерживает 
клиент. вот этот список

 
server-sig-algs=

	ssh-ed25519,

	sk-ssh-ed25519@openssh.com,

	ssh-rsa,
	rsa-sha2-256,
	rsa-sha2-512,

	ssh-dss,

	ecdsa-sha2-nistp256,
	ecdsa-sha2-nistp384,
	ecdsa-sha2-nistp521,

	sk-ecdsa-sha2-nistp256@openssh.com,

	webauthn-sk-ecdsa-sha2-nistp256@openssh.com


сраниванивая список host key с компа и список алогоримов аутентификации
странно что алгоритмов больше заявлено а ключей выработано меньше.

там дальше в логе написано что для аунтаиенфикации будеи испольован 
алгоритм
   ecdsa-sha2-nistp256


дальше важная хуйня вот эти файлы из /etc/ssh/


ssh_host_ecdsa_key
ssh_host_ecdsa_key.pub

ssh_host_ed25519_key
ssh_host_ed25519_key.pub

ssh_host_rsa_key
ssh_host_rsa_key.pub

они испольщуются на моем компе для аутентфиикации только если МОЙ КОМП
ВЫСТУПАЕТ КАК СЕВРЕР SSH!!! 

А ЕСЛИ МОЙ КОМП ЭТО КЛИЕНТ SSH ТО ФАЙЛЫ АУТЕНТАЦИИКАЦИИ ИЩУТСЯ 
СОВЕРШЕННО ВДРУГОЙ ПАПКЕ

    ~/.SSH/.....

поэтому дя аутентикациии на моем компе иопльзовались файлы

debug1: identity file ~/.ssh/id_ed25519 type 3

а на серверре уже  файл

  /etc/ssh/ssh_host_id_ed25519

в зависимости какой алогитм выбран такой хост кей файл и будеи использован!
вот зачем нужны хост кей файлы. для ауткнтифкации. уже после подятие 
шифрованного тонеля. 

итак когда и для чего /etc/ssh/moduli файл используется я понял.
для чего и как и когда использются файлы /etc/ssh/ host key файлы  я понял

деибильно то что называют привабный публичный ключ ssh для клиента
они назвыают хост кей файлы когда мы говорим про сервер. хотя это одно итоже.
по своей природе. 
так вот для аутентифкации используется два файла. один файл приватный у нас 
на компе лежит. а второй публиный надо заранее скопироать на вторую сторону. 
тогда для аунетиаицикации отравитль чтото шифрует мудит используя приватный ключ
принимающая сторона принимает и мудит с тем что прилано исполуя публичный ключ
который как я сказал заранее надо скопироать на ту стороны. и проверяет ствпао
или нет. если совпало то аунтетацикция умспешная.  клиенский публинй ключ мы
реально копируем на сервер в /home/user/.ssh/authorized_keys файл 
того. а публичный ключ с сервера обычно попадает к нам не путем того что 
его ктото кпирует к нам на компа заранее. мы звоним на сервер и он нам его шлет
как я понимаю на лету. а нас на экране вылаезат надпись о том что доверям
ли мы этому пулличному ключу. если да то этот ключ записывется к нам в 
файл ~/.ssh/known_hosts

забавно. наш публ ключ и серверный публ ключ по приоде это одна и таже природа.
но клиенсктий мы копируем заранее. серврный к нам прилетает на лету.
клиенстий пишется в один файл. серврный в другой файл. и формат разный.
клиентский просто дбаляется в файл authorized_keys
а серверный публиный ключ непрсто длбавляется в файл known_hostst а еще
там пишется какой IP или доменнное имя соовтесвтввет этому ключу. 

вот ткая раная у них судьба.

что меня смущает еще это то что ECDSA это цифровая подпись. это значит что 
вообще то чтот должнобыть подписано. а непросто публичный и приватный ключ.
еще меня смущает при чем здесь хеш опять же. 


			ecdsa-sha2-nistp256


может это гоовиит о том что бертся некий хеш sha2 (у него размер кастаи от 
224 до 512бит). затем он шифруется приватным ключом. получается цифровая
подпись. тоеть я к тому что укаанный хеш - это сущность на которую и при
меняется цифровая подпись? нам пислают шифрвнанную хрень. мы ее через публичный
ключ дешифруем. и получаем исходный хеш.  и он у нас именно про этот хеш и 
српшвивает мол довеяряешь этому хешу? тому который был запширофыван цифр
подписью.тоест еще раз мберется хеш такой то длинны. шифруется через 
цирую подпись. послывается нам. мы его дешируем публпныым ключом. получаем
этот исхоный хеш. на экране его показываем мол доверяешь? ты говоиь да.
и аутенитикаци заеонццена. тоест хеш который вылаезает на экране это не 
публичный ключ который засоывается в .. вобщем это езе надо выясгить 
тот хеш который нам на экане позуыаают это что? это хеш пуличного  ключа серврера?
или что ?

//
видимо вот эта пара файлов (хост кеев)

	ssh_host_ecdsa_key
	ssh_host_ecdsa_key.pub

за него отвечает.





что такое HMAC?
