ssh

есть такой файл ~/.ssh/config

в него можно много чего вставлять

HOST  vasya

параметр HOST это алиас для  хоста при доступе по ssh.

если честно неочень понятно зачем это были им городить 
если есть доменная система DNS, однако они нагородили (создатчики ssh проги)

HOST означает ту хрень которую мы будем писать после ssh в командной строке
например


$ ssh vasya
$ ssh petya

если мы хотим для этих хреней особые параметры подключения то мы в 
~/.ssh/config пишем

HOST vasya
HOST petya

также в строке HOST может быть несколько алиасов. они перечисляются через пробел.

HOST vasya petya klava


но это только начало секции. ниже HOST мы уже прописываем так какие 
кастомные параметры мы хотим для них сделать.


параметр HOSTNAME. он неиспользуется сам по себе. его должен предварять
параметр HOST

HOST vasya
   HOSTNAME 8.8.8.8 
   
 
тогда когда мы в строке напишем

$ ssh vasya

то ssh заглянет в конфиг и в реальности постучится на сервер вот так

ssh 8.8.8.8

таким образом HOST как бы выполняет роль доменного имени 
а HOSTNAME как бы выполняет роль IP адреса в который он как бэ резолвится 
ssh прогой и уже именно под ним он стучится на сервер

или 

HOST vasya petya klava
	 HOSTNAME 8.8.8.8

или более диковынные приемчики HOST

Host 192.168.0.?

Host *.co.in

Host *

	 

в HOSTNAME может быть нетолько IP но и доменное имя 
например

HOST vasya
	HOSTNAME mail.ru
	
	
следущий параметр это user

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	
таким образом когда мы 

$ ssh vasya 

то по факту будет 
$ ssh 8.8.8.8 -u pupkin


аналогично параметр port

также можно заходить под логином паролем. 
скажем при таком конфиге 
	
HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin


вход будет под юзер pupkin и будет под логином паролем.

а можно входить вместо пароля под юзер\RSA ключ

тоесть RSA ключ вместо пароля.

тогда конфиг будет 


HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
	
причем тут тоже мудота. как пишут в инете. опция IdentityFile даже 
если мы указали какой кастомный ключ мы хотим юзать все равно вначале
шлет на удаленный хост ключ дефолотовый ~/.ssh/id_rsa или ~/.ssh/id_dsa 
а если удаленный хост это отвергает то тогда уже наш кастомный.
поэтому чтобы этой мудоты небыло также надо добавить опцию

  IdentitiesOnly yes
  
  

HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
	
	
с IdentitiesOnly yes будет слаться только тот ключ который мы указали. ура товарищи.


далее есть такая хрень. опция LocalForward

вот мы зашли на сервер по ssh
получается между нашим компом и удаленным поднялось TCP содинение вида

наш_IP:некий порт <-------> удаленный_IP:22

так вот если мы заюзаем опцию LocalForward 



HOST vasya
	HOSTNAME 8.8.8.8
	user pupkin
	IdentityFile ~/.ssh/mykey
    IdentitiesOnly yes
    LocalForward 3308    localhost:9200


то когда мы зайдем на удаленный комп по ssh
то и на нашем компе и на удаленном сервис ssh начнет слушать дополнительно порты.
а именно

	на нашем компе он начнет слушать порт 3308 причем для IP=127.0.0.1
   причем именно прям бинарник ssh ( потому что если сокет какойто 
   поднят на компе его поднял какойто конкретный бинарник)

	$ netstat -tnlp
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 127.0.0.1:3308          0.0.0.0:*               LISTEN      31349/ssh

а на удаленном компе ssh неподнимает никакой доп сокет для себя нет.
там уже должен быть поднят сокет каким то сервисом. 

причем между компами никакого дополнительной tcp конекшнена несоздается.
далее схема такая

если мы на нашем компе обратимся по сокету  127.0.0.1:3308
то ssh перенеправить через наше текущее ssh соедниение реквест (проксирует)
на удаленный комп на его сокет localhost:9200 
таким образом мы имеем проброс порта. обращаясь на сокет нашего компа
мы попадаем на сокет удаленного компа. 
едиснвтенное что непонятно это как на удаленном компе система различает 
пернаправлять реквест  который пришел на localhost:9200 на удаленный мой комп 
или нет. может там в iptables прписываются доп правила?

в любом случае вот такое назначение опции localforward. пробросить локаьный порт
на удаленный комп через ssh соединение.

при этом опять же важно понимать что порты localforward никоим образом невлияют
на порты по которым устанавливается самое ssh содеиненеи.

опция ProxyCommand - позволяет указать первый ssh сервер через который мы хотим попасть на 
другой ssh сервер

например ProxyCommand ssh -q -A vasya@kuku nc %h %p

-q = quiet mode
-A = enable forward как я поимаю именно эта опция позволяет аутентифицроваться
на одном хосте и на втором уже этого повторно делать ненадо

vasya это логин
kuku это alias первого ssh сервера. раз алиас значит
надо его распиывать в ~/.ssh/config  

nc это утилита netcat. и эта хрень тоже участвует в проброске TCP
содененеия с одного компа на другой. 
с этим надо еще разбираться.

   
------
для того чтобы при входе в ssh ненужно было вводить пароль
от RSA приватного ключа то нужно запустить ssh agent

как япроверил от имени непривлигорванного пользлователя. тоесть под тем же
юзером что и тот юзер под которым ты входишь в ssh


$ ssh-agent

провереяем что он запутился как процесм

$ ps aux | grep ssh-agent

далее надо добавить в него налету приватный ключ

$ ssh-add ~/.ssh/название_приватного_ключа

готово.

после перзагурзки компа опять все заново.

----------------
начинаю фундаментальную статью как работает ssh

значит работа ssh начинается с такого этапа насколлько  я понял как договаривание
о методе ассиметричного шифрования(их несколько). пока здесь я оставлю пусто вместо описания как это происходит.

асиметричный алогритм зачем он в чем его фишка в том что для шифровки иползуется один ключ а для расшифровки другой. о нем еще поговорим ниже но конечная цель применения ассиметричного шифрования это выработать некую комбинацию символов (ключ). это конечная цель применения на этом этапе ассмиетричнго широфвания. как только на клиенте и сервере появился этот ключ то можно начинать использовать уже симметричное шифрование. а полученный ключ как раз будет 
использоваться как ключ этого симметричного шифрования. таким образом ассиметричное шифрование
позволяет незная друг о друге почти ничего создать канал безопасный связи и по этому каналу
передать друг другу (договориться) небольшой кусочек информации а именно ключ. насколько я понимаю использовать на первом этапе симметричное шифрование невозможно потому что в отличие 
от ассиметричного шифрования в симметричном нельзя создать канал связи незная друг о друге ничего. ассиметричное шифрование однако сильно грузит цпу поэтому для передачи больших обьемов данных подходит плохо. для устанолвения безопасного канал связи друг с другом незная друг о друге ничего оно подходит хорошо. для передачи небольшого количество информации тоже подходит
нормально а вот для передачи большого обьема ифонмаации уже плохо ибо оно цпу грузит . поэтому 
коненым продуктом ассиметрик шифрвания будет всего навсего ключик. а далее уже запукается симетричный алогритм шифрования который использует выработанный на прердыдущем этапе ключ
который есть уже и на клиенте и на сервере и при своей работе он негрузит цпу так сильно.
итак мы поняли зачем нужен какая роль у ассметрик широфания и у симметрик шифрвания.
про ассиметрик шифования. генерируется два ключа приватный и публичный. 
приватный хранится на сервере в секрете. а публичнй сообщается всем кому подряда наружу. 
любой кто снаружи (клиент) может взять и с поомощью публичного ключа сервера зашифровать
сообщение и послать серверу. фишка в том что толлько сервер имея приватный ключ может 
расшировать сообщение. также фишка в том что зная приватный ключ из него легко получается публиынй ключ. а наоборот невозможно. тоесть зная публичный ключ невзомжно из него вычислить приватный ключ. поэтому то публичный ключ и можно без боязни всем раздавать.


покончили с теорией возврашаемся обратно. итак клиент и сервер договориллись о методе асметрик широфания.
когда они договорлись о методе они к нему приступают.
теперь их задача обеменяться друг с другом своими публичными ключами. 
причем нас как клиента очень интересует как то проверить что полученный от сервера 
публичный ключ что это действтельно публичный ключ от сервер а не от злодея посередине. потому что да меджу нами и сервером может сидеть злодей. он контролрует канал междунами и сервером
и он может легко на наш запрос нам послать свой злодейский пубичнйы ключ который к серверу неимеет никакого отношения. так что нам надо проверить что полученный ключ ддействиительно
от сервера. и тут как я понимаю красивого компьютерого способа нет! а есть способ ручной.
тоесть человек который сидит на сервере он берет публичный ключ на сервере ( на линуксе асиметричные ключи сервера называются host keys. лежат они в папке /etc/ssh )

$ ls -1 /etc/ssh
ssh_host_ecdsa_key
ssh_host_ecdsa_key.pub
ssh_host_ed25519_key
ssh_host_ed25519_key.pub
ssh_host_rsa_key
ssh_host_rsa_key.pub


значит видно что у нас несколько штук этих ключей. есть приватный и есть ему публичный. 
их несколько видов потому что линукс поддерживает несколко видов ассиметричного шифрования. 
почему я и сказал что на первом этапе клиент и сервер должны догвоорится(в автоматическом режиме) какое именно
асмиетрик шифрование они будут совмпстно юзать. так вот положим что используется 
RSA шифроание. тогда человек ( да да именно человек) должен руками зайти на сервер
найти публичный (дада именно публичный) ключ и вычислить от него хэш руками. обычно у нас два алгоритма для хэша это sha256 и md5. итак человек берет и руками на сервере вычисляет 
хэш для публичного ключа сервера (ключ берется тот который соотсвтетует выбранному ранее в автоматическом режиме между клиентом и сервером асиметрик виду шифрования). тут  я еще раз хочу подчеркнуть что вид асиметрик шифрования выбирается между клиентом и сервером автоматически без участия человека. я щас покажу как нам узнать какой метод был выбран чуть ниже. так вот что еще я хочу подчеркнуть что человек должен зайти на сервер и уже неавтоматически а руками уточнить хэш для публичного ключа соотсвтуетющего выбранному методу асметрик шифрования. руками. руками!

sha256
# ssh-keygen -l -E sha256 -f ./ssh_host_rsa_key.pub 
2048 SHA256:iBSI/ZduKsZ3V6TzyQmgc5/vLxEVnmCOiK2F3nw/NZ0 root@vagrant (RSA)

# ssh-keygen -l -E md5 -f ./ssh_host_rsa_key.pub 
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

и далее самое главное этот человек с сервера должен сообщить нам (клиенту) через какойто человеческий способ комуникации тоесть через телефон или по почту послать либо sha256 хэш
либо md5 хэш.  на мой взгляд хэш sha256 абсолютно непригоден для общения между людьми. 
и только хэш md5 пригоден.
итак человек с сервера звонит нам по телефону и голосом сообщает эту строку
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

что такое хэш. хэш это маппинг отображения аргумента в некоторый более компактный вид.
в чем фишки хэша. в одну сторону он вычисляется быстро и просто .то есть если есть x то хэш(x)
вычсляется быстор и просто а вот зная хэш высчитать исходный x невозможно. это очень хорошо.
и второе что хэш по размеру гораздо компактнее чем исходный x. где применяется хэш. например 
для хранения паролей. но не в открытом исходном виде а ввиде хэша. что это дает. 
на линуксе человек вводит пароль. ос высчитывает от него хэш а затем сравнивает с сохраненным в файле хэшем. если они совпали то человек ввел правильый пароль. если ктото спер с хоста файл с хэшами о это злодею ничего недаст ибо зная хэш вычислить исходный x невозможно. насколько я понимаю считается что нет двух таких x чтобы у них было общий хэш или для этого мала вероятность. тоесть скажем мы незнаем пароль но мы ввели левый пароль и так совпало что его хэш совпал с хэшем от реального пароля типа так небывает. таким образом хэш это досттаточно хороший способ проверить достоверность исходного x. например мы скачали прогу и у нас от нее есть полученный через надежный канал хэш. мы высиляем на компе хэш от файла скачаной проги и сравниваем с хэшем что у нас есть . если совпало значитможно достверно верить что мы скачали оригинальную программу а не подкоректрованную. (crc в этом плане ненадежно ксати ибо можно так подделать исходный x что мы будем иметь тот же crc). 

так вот взрвршаемся к нашей задаче. нам нужно как клиенту убедиться что полученый от сервера
публичный ключ дейвительно получен от сервера а  не от злодея. для этого человек с сервера 
нам должен по телефону сообщить публичный ключ сервера. но публичный ключ сервера очень длинный
например
# cat  ./ssh_host_rsa_key.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9 root@vagrant

совершенно невозможно такой ключ диктовать по телефону. и потом сраавнивать с тем что мы получим от сервера. поэтому человек с сервера по телефону нам передает несам публичный ключ а
передает его хэш. еще раз можно было бы передать по телефону сам публичный ключ в его оригинальном виде ибо это не секретная информция. но как видно ключ очен длинный. а его нужно 
будет нетолько получить по телефону но и и потом сравнить с тем что мы получим от сервера.
пэтому исползуется хэш как средство сжатого вида.

значит по телфону нам продиктуют хэш md5
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

видно что такой вид очень компактный  и с ним можно раоботаь глазами.
итак мы получили от человека с сервера хэш публичного ключа сервера.

далее. мы с клиента начинаем ломиться на сервер.
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здест я хочу сказать о некотором дебилизме клиента ssh. дело в том что опции -o нельзя указать
сразу все. их можно указывать только строго по одной. тоесть вот так работает 
ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa
а вот так неработает
ssh -o FingerprintHash=md5,  HostKeyAlgorithms=ssh-rsa

теперь про сами опции
100.0.0.6 === это понятное дело адрес сервера
HostKeyAlgorithms=ssh-rs === это мы сообщаем на сервер что мы хотим с ним связываться через RSA
(дело в том что в линуксе по дефолту клиент пытается установить связь не через RSA а через ECDSA)
FingerprintHash=md5 === это мы сообщаем серверу чтобы он нам прислал хэш публичного своего ключа в виде md5 потому что по дефолту он шлет нам его в виде SHA256 который как мы уже поняли
совершенно нечитаемый

итак опции разобрали. в них мы заказываем на сервере параметры связи.
посмотрим что мы видим на экране в результате.

The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? 

здесь мы видим что сервер нам прислал md5 хэш своего публичного ключа.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

точнее мы пока что незнаем то ли эта инфо прилетела от сервера то ли от злодея между нами 
и сервером. но мы теперь можем сравнить совпадает ли md5 с бумажки которую нам по телефону
продиктовали  с тем что мы увидели на экране.

бумажка:
2048 MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 root@vagrant (RSA)

экран:
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.

значит мы видим что нам присылали бумажку для RSA ключа и экран нам показывает 
что RSA ключ. теперь сравним сами хэши

бумажка:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5
экран:
MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5

сравниваем глазами совпадает. это значит что действительно мы получили хэш публичного ключа 
сервера именно от сервера а не хэш публичного ключа от сервера злодея.
Итак отмечаю здесь еще раз то проверить достоверность полученного  хэша что он действиельно
от сервера автоматическим способом невоможно. нужен звонок друга и проверка вручную глазами.

что это нам дает. то что теперь когда мы знаем что полученный хэш дейсвтиельно оригинальный
то я так подразумеваю что вместе с хэшем от сервера прилетает и сам публичный ключ 
и мы теперь зная что хэш подлинный можем взять присланный публичный ключ посчитать сами
от него хэш сравниить с присланными понять настоящий ли он. и поняв что он настоящий 
мы теперь можем зашифровать нечто и послать на сервер и только сервер это сможет расширофвать.
тут еще важное дополнение что глазами сличать хэш с хэшем с бумажки приедется только один 
раз в жизни. еслимы подтверждаем на экране что хэш верный то он заносится на клиенте в файл known_hosts о чем  нам на экране ssh пишет и при всех следущих конектах к хосту
наша ос небудет нас спрашивать про достверность хэша а будем сличать с тем что в known_hosts.
а если когда то она получить хэш который несовпдает с тем что сохранен в known_hosts
то она на экране напишет что внимание я получила хэш другой чем в known_hosts и это скорее всего означает что хэш нам прислал злодей. и нужно отказатся от сеанса связи такой.

вот как на экране система пишет что она сохранила хэш когда мы подтвердили что он 
поодлинный в файл known hosts:
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
The authenticity of host '100.0.0.6 (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '100.0.0.6' (RSA) to the list of known hosts.

файл у нас (клиента) этот лежит в 
$ ls -1 /home/vasya/.ssh
...
known_hosts

итак для хоста 100.0.0.6 хэш его публичного ключа был записан системой в known_hosts.
поищем ка теперь его там.

вот как выглядит known_hosts если мы запретили хэшить имя удаленного сервера
(наш комп)$ cat known_hosts
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

вот как на самом удаленном сервере выглядит файл с публичным ключом
(удаленный сервер)# cat /etc/ssh/ssh_host_rsa_key.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9 root@vagrant

почему то на нашем компе в known_hosts нет root@vagrant. непонятно об этом мы поговорим
где то ниже. в остальном получается что known_hosts строчка состоит из полей:

имя_сервера    тип_ассиметричного_шифрования     публичный_ключ(нехешированный)

Но! на самом деле так known_hosts выглядит если на нашем компе в /etc/ssh/ssh_config ( это файл отвечает за настройки ssh клиента (тоесть когда мы с нашего компа ломимся на удаленный сервер в отличие от sshd_config конфига когда наш комп используется как сервер на принятие от ругих ssh соединений)) стоит настройка 
(наш комп)$ cat /etc/ssh/ssh_config | grep -i hash
    HashKnownHosts no

так вот обычно там стоит как раз обратная настройка. то есть yes. 
когда она yes то у нас имя сервера ( в нашем примере это 100.0.0.6 ) записывается не в открытом  виде а в виде хэша. (зачем пока незнаю). но еще раз скажу пока мы рассматриваем
случай когда HashKnownHosts no. случай когда он равен yes рассмотрим ниже несейчас.
так вот.  еще раз. мы постучали с нашего компа на удаленный сервер
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6

при этом на нашем компе в known_hosts получили запись
$ cat known_hosts
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

далее очень интеересный момент. стучим на тот же сервер но требуем использовать не RSA
в качесвте асиметричного шифрования а ecdsa-sha2-nistp256 (об нем подробнее ниже)
и получаем жесточайший варнинг от линукса
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

суть этой надписи в том что наш комп имеет уже сохраенный ключ асмиметричного
шифрования который мы ранее одобрили. далее наш комп подключается к серверу и получаем
 в ответ публичный ключ совершенно другой. из чего комп делает вывод что получнный публичный
 ключ не от сервера а от злодея который сидит между нами и сервером. в  данном случае никакого 
злодея нет. просто мы к тому же серверу обращаемся по другому ассиметричному протоколу и получаем другой публичный ключ. ОТСЮДА я делаю вывод что в known_hosts для одного удаленного
сервера который идентифицируется в нашем случае ip адресом может находиться ТОЛЬКО ОДНА СТРОЧКА! линукс непозволяет иметь несколько строчек для одного удаленного сервера даже если
в этих строчках указаны разные асиметричные алгоритмы шифрования. это очень важно.

узнать какие алгоритмы шифроваия поддеживает удаленнй сервер по быстрому можно через ssh-keyscan

$ ssh-keyscan  100.0.0.6

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBAqCgW5Mlx2VpC61acc0G4VMZUAauQDoK5xIzdHzdDLPXt0GqsoIw1fuwTSSzSy8RFmGU5PNHiWn0egoUwlXdc4=

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

# 100.0.0.6:22 SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3
100.0.0.6 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

он просканровал удаленный сервер и узнал что тот поддеживает RSA, ecdsa-sha2-nistp256, 
ssh-ed25519

Далее еще один очень важный момент. Когда мы обращаемся к удаленному серверу по IP 
то все понятно в known_hosts будет указан IP. а что если мы обращаемся к удаленному 
серверу через доменное имя. что вэтом случае будет в known_hosts.
ответ такой - если у нас прописан резоволинг dns в IP в /etc/hosts либо такой же резолвинг
идет через внешний DNS сервер то в known_hosts будет содержаь доменное имя+IP 
пример:
$ cat /etc/hosts
100.0.0.6 vasya.local

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
The authenticity of host 'vasya.local (100.0.0.6)' can't be established.
RSA key fingerprint is MD5:e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5.
Are you sure you want to continue connecting (yes/no)? yes

смотрим что в known_hosts
$ cat known_hosts
vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

тоесть мы видим что указано и vasya.local и 100.0.0.6

также видно что когда мы устанавлаием соединенеи то эта же инфо указана в
The authenticity of host 'vasya.local (100.0.0.6)' can't be established
тоесть нам клиент уже подсказывает что он пропишет в качестве идентификатора сервера в
known_hosts

в man 8 sshd указано что в known_hosts можно указывать вайлдкарды. тоесть скажем вместо
vasya.local указать vasya*


$ cat known_hosts
vasya*,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

и это реально работает! однако это работает только при настройке  HashKnownHosts no. когда у нас domain name\IP нехэширован. когда же он хэширован то мы так уже подкоректировать руками
known_hosts не сможем.

Так вот я продолжаю тему о том что если у нас доменное имя не прописано в /etc/hosts
или во внешнем доменном сервере а вместо этого мы используем ~/.ssh/config
вот с такой записью:

$ cat ~/.ssh/config 
HOST vasya.local
    HOSTNAME 100.0.0.6

и мы обращаемся к серверу по доменному имени
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local

то тогда в known_hosts будет записано не доменное имя а  IP как идентификатор удаленного сервера.
я проверил это. 
также практика показала что если есть запись в /etc/hosts и есть запись в ~/.ssh/config
то запись в ~/.ssh/config превалирует. 
Таким образом если мы хотим чтобы в known_hosts присутсовало именно доменное имя
то надо чтобы если мы используем ~/.ssh/config то там хост был прописан как доменное
имя а не как IP адрес. например.

$ cat ~/.ssh/config


HOST vasya.local
    HOSTNAME vasya.local

при этом
$ cat /etc/hosts
100.0.0.6 vasya.local


тогда 
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
даст
$ cat known_hosts
vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9


но опять же можно заметить что даже если у нас система вписала доменное
имя то она всегда обязательно прорисывает и IP адрес. так что от IP адреса
никак неизбавиться.!

что интересно. я зашел на удаленнйы хост и сменил его ip на 100.0.0.8
далее я на нашем компе постучал на сервер 
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  vasya.local
тогда система вот что сделала
$ cat known_hosts

vasya.local,100.0.0.6 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9


она добавила новую строчку и использовала IP=100.0.0.8
далее я удаляю верхнюю строчку в known_hosts
еще раз стучуь по доменному имени
получаю такое в known_hosts

$ cat known_hosts

100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

vasya.local ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9

далее я удаляю строчку с vasya.local
стучусь еще раз
$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

удаляю строчку с 100.0.0.8
стучу еще раз получаю

$ cat known_hosts
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg
100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

удаляю обе строчки
стучу еще раз
получаю

$ cat known_hosts
vasya.local,100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

из чего я суммарно делаю вывод - если мы стучиммся на сервер по его доменному имени
и в config нет его резоолвинга в IP то клиент ищет в known_hosts строчку где указано 
доменное имя. если в этой строчке указано толко доменное имя без IP то клиент
делает еще доп проверку и ищет строчку где есть IP и сравнивает одинаковые ли ключи или нет.
если нет то клиент ругается. как это было в этом случае:

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

в целом я бы сдела такой вывод - как ни извращайся но клиент будет всегда вставлять строчку в known_hosts которая обязательно будет содержать IP сервера (неважно как мы  к нему обращаемся по IP или по доменному имени). если мы обращаемся к серверу по IP то  в файле будет прописан IP. если мы обращаемся к серверу первый раз и по доменному имени то в файле в одной строке
будет указано и доменное имя и IP. если в файле уже есть либо такой IP либо такое доменное
имя то будет создана доп строчка с тем чегонехватает. тоесть если мы обратлись по доменному имени а в файле для IP уже есть запись то будет созана вторая строчка с только доменным
именем. если у нас есть две строчки в которой в одной только доменное имя а в другой только
IP и указаные разные ключи (так хитро мы смогли сделать) то система будет ругаться и говорить
что у нас одна строка противорчеит другой как в этом примере:

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-ed25519  vasya.local 
The authenticity of host 'vasya.local (100.0.0.8)' can't be established.
ED25519 key fingerprint is MD5:75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'vasya.local' (ED25519) to the list of known hosts.
Warning: the ED25519 host key for 'vasya.local' differs from the key for the IP address '100.0.0.8'
Offending key for IP in /home/vasya/.ssh/known_hosts:1
Are you sure you want to continue connecting (yes/no)? ^C

$ cat known_hosts
100.0.0.8 ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDTRQx4ZmXMByEs6dg4VTz+UtM9X9Ljxt6SU3oceqRUlV+ohx56xdD0ZPbvD0IcYwUrrqcruMG0xxgRxWuzV+FQAJVQe76ED966+lwrwAnUsVFQ5apw3N+WKnD53eldUZRq7/2nGQQizrefY7UjAGX/EZonSVOWZyhVyONu2VBBwg0B0yA3UBZV+yg+jGsrZ9ETEmfNbQRkbodEAwoZrGQ87UEdTkfj+5TGmfzqgukmBvvVV7KoXgSQIZNkqRmkAVKKXeEfydnOR37KMglBUXIR/50jkIswxWbNk2OtS6fz6UiPeEY39f4f0gwLx/HwUyel9yzH4dkDb+LBS6X/X9b9
vasya.local ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg


в целом я бы сказал так что для себя клиент в конченом итоге идентифицирует хост именно по IP 
как ни ивзращайся и с этим IP обязатлеьно будет строчка в known_hosts и еще то что 
для одного IP в known_hosts может быть только один ключ. неможет быть два ключа даже 
если при этом указаны разные алгоритмы несимметричного шифрования. система будет ругаться вот так:

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

так что если уж когда то полкючились к хосту через RSA и такой то ключ
то будь добр только так к этому хосту и подключаться. а если решил сменить 
RSA на ECSA то вначале удали из known_hosts прежний ключ вотак

$ ssh-keygen -f "/home/vasya/.ssh/known_hosts" -R "100.0.0.6"

еще раз подчеркн что  хост неможет иметь в known_hosts разные ключи.тоесть строчка может 
быть только одна! при этом неважно что раньше мы связывалист с ним по RSA а щас по ECDSA.
невоможно это обойти тем что мы будет обращаться к хосту скажем по IP по RSA
а по доменному имени по ECDSA. этот номер непродет. как бы мы ни обраащались к хосту в коечном итоге клиент ожидает что в known_hosts либо есть одна строка с одним ключом и в этой строке
укзано и доменное имя и IP либо там есть две строки в одной IP в другой доменное имя 
но в обоих строках ключ должен быть одинаковый. так что обмануть обойти это недуастся.
итого - одному хосту один ключ один алгоритм ассмиетричного шифрования. так подразумевает
клиент. иначе он будет псоылать нахер.

в этом плане ксати интересно что github опубликовал хэши своих публичных ключей
https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 (RSA)
SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM (ECDSA)
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU (Ed25519

вот что показывает про github ssh-keyscan

$ ssh-keyscan github.com

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl

# github.com:22 SSH-2.0-babeld-7f91b4d6
github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=

таким образом через ssh-keyscan
мы знаем что github поддерживает для связи с ним по ssh следущие ассиметричные 
протоколы:ssh-rsa, ssh-ed25519, ecdsa-sha2-nistp256

и что для этим протоколов оригинаьоьные хэши публичных ключей являются:
SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8 (RSA)
SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM (ECDSA)
SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU (Ed25519)


таким образом мы можем выбрать протокол который нам больше нравится
и знаем как дожен выглядеть оригиальный хэш публичного ключа. 

вот как выглядит known_hosts 
после того как мы вошли мы подключлись к гитхабу по ssh
$ cat known_hosts
github.com,140.82.121.3 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=

здесь мы видим и доменное имя и IP

еще раз полезная команда которая дает хэш публичного ключа(неважно это наш публичный клиентский ключ которым мы аутентифицируемся на гитхабе к примеру или это публичный ключ 
нашего ssh линукс сервера который видят клиенты котрые к нему покдлючаются)
$ ssh-keygen -l -f id_ed25519.pub
256 SHA256:f+lgxW9HzT1QCQj3GvKmtQh6LwJ/1d3STiDQ5cuHNHI vasya@gmail.com (ED25519)

Еще раз хотел сказать насчет того случая когда мы стучимся на удаленный сервер (100.0.0.8 для примера)
по ssh и на экране вдруг видим варнинг:
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

что это значит с технической точки зрения.
это значит что когда то мы уже стучались на 100.0.0.8 и  у нас система спросила что мол 
она получила такой то публичный ключ подтверждаем ли мы что он действиельно от 100.0.0.8,
мы подтвердили и система сохранила подтвержденный нами публичный ключ удаленного сервера
в файле known_hosts , также она сохранила и имя  ассиметричного алгоритма. так вот 
проблема в том что сейчас когда мы стучим на 100.0.0.8 то наша система получила публичный 
ключ от удаленного сервера который нетакой, который отличается от того что был сохранен
ранее. Ровно об этом и говорит варнинг. Он говорит о том что полученный публичный ключ
отличается от сохранненого , который мы получали ранее от этого хоста. Какие причины могут
для этого быть. Самая хреновая это то что между нами и удаленным сервером сидит злодей. 
Он перхваетывает пакеты от нас к 100.0.0.8 и подменяет их своими. Именно поэтому нас так 
ярко информируют. Нам говорят что возможно злодей посылает нам пакеты от имени сервера 100.0.0.8 соотвественно надо отстановится задуматься итд. НО! причина может быть и не в злодее.
Первая причина незлодейская может быть в том что на удаленном сервере сменили приватный и соотвественно публичный ключ. Но тогда надо связаться с тем кто заведует тем сервером и спрросиить так ли это или нет. Может быть и еще одна незлодейская причина - дело  в том 
что удаленный сервер обычно поддеживает несколько асиметричных типов шифрования. так вот 
мы могли ранее связываться с ним по одному асиметричному методу а сейчас по другому. А дело втом что публичные ключи от разных асиметричных шифрованиях они конечно разные. Тоесть 
если мы стучим на сервер по одному асиметричному протокул то он нам вернет один публичный ключ
а если мы стучим на сервер подргуому асиметричному протоколу то он нам ответит другим
публичным ключом. Соотвесвтенно в этом случае выиноваты только мы. На сервере ничего непоменялось. И злодея нет. Как это проверить - нам надо узнать по какому асимтеричному
шифрованию мы обращались к серверу ранее, для этого надо заглянуть в known_hosts
там будет указан публичный ключ (его хэш) для сервера и имя алгоритма шифрования асиметричного как раз то что нам нужно. Также пользуемся тем что для одного IP в known_hosts всегда есть только одна строчка. Несколкьих строчек неможет быть для одного IP. Как я писал выше known_hosts недаст нам иметь для одного IP несколько строчек с разными ключами даже при условии
что в каждой строчке свой другой алгоритм шифрования асиметричный. Поэтому я и говорю что 
в known_hosts можно узнать по какому алгоритму асимм шифрования мы обращались в прошлый раз
к серверу и какой был от него публичный ключ. если known_hosts имеет вид когда ip адреса
сервров незахэшированный то можно посмотреть просто через cat

$ cat ~/.ssh/known_hosts | grep 100.0.0.8
vasya.local,100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

но чаще всего known_hosts имеет вид когда ip адрес сервера предсталвен в виде хэша (об этом будем говорить позднее), в этом случае искать IP серверов и их ключи надо через ssh-keygen

$ ssh-keygen -F 100.0.0.8
# Host 100.0.0.8 found: line 1 
vasya.local,100.0.0.8 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFZ/jrfDX1aK1I0A/sLRVb2qoCF9xHWbVW+gBCV8dSmg

значит из этой инфо мы понимаем что ранее мы связывалсь с сервером через ssh-ed25519
а сейчас я с ним связывался по RSA тоесть 

$ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.8

соотвестенно в данном случае никакого злодея нет. просто мы на нашем клиенте
поменяли асим шифрование поэтому и ключ другой получаем от сервера . так что ничего 
плохого непроизошло. для дальнейшей работы нам просто надо решить либо обрашатся к
серверу по ed25519 либо стереть ключ из known_hosts обратится чеерез RSA и запомнить в known_hosts новый публичый ключ. Обрашаться к сервер то через RSA то через ed25519 неполучится.
система каждйы раз будет ругаться. чтобы удалить ключ из known_hosts юзают команду:

$ ssh-keygen -f "/home/vasya/.ssh/known_hosts" -R "100.0.0.8"

таком обраом мы разобрали все три случая когда может появляться варнинг
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!

разобрали как проверить какой случай в нашем случае. и что это все значит.
один из главных выводов: невсегда эта надпись означает что нам пишет злодей.
в ряде случаев это происходит по незлобным причинам. в любом случае сразу надо 
разбираться.

Далее. также еще раз опишем что значат для чего предназанчены некоторые файлы
котрые встерчются при работе с ssh.

/etc/ssh/sshd_config = это конфиг файл для сервиса sshd который обслуживает подключения к нашему серверу от клиентов ssh из внешнего мира. тоесть наш хост работает как ssh  сервер а люди снаружи покдючатся к нашему серверу через клиентов.

/etc/ssh/ssh_config = это совсем другой файл. это когда мы с нашего компа стучимся на удаленнйы
сервер а наш комп выступает как клиент. так вот ssh_config это настройки для нашего клиента.
~/.ssh/config = это ровно такой же файл как предыдущий только для конкретного юзера на хосте. его локаьные настройки. вообще получается что ~/.ssh/ все файлы в этой папке это файлы которые
используются для клиента. тоесть когда мы клиентом стучися на удаленный сервер то в этой папаке
лежат файлы которые при этом могут понадобиться. хотя все таки я несовсем прав. в этой папке
есть по крайней мере один файл который испольуется не клиентом а сервисом sshd когда наш хост выступает как сервер ssh. это файл authorized_keys. 

~/.ssh/authorized_keys = в этом файле указаны публичные ключи удаленных пользователей
который стучат на наш хост как на сервер ssh. и они при этом предбявляют в качестве аутентификации публичный ключ и логин под которым они хотят войти на наш сервер. так вот 
если удаленный юзер хочет войти под логином petya без пароля а по поубличному ключу то 
его публичный ключ должен быть добавлен в /home/petya/.ssh/authorized_keys
что примечательно что в authorized_keys может быть хоть милион разных публичных ключей и под каждый из них можно аутентифиицироваться и войти на наш сервер как petya. публичный кюлч предьявляется нашему серверу вместо пароля. но в authorizeed_keys указыается не только публичный ключ но и например какую команду нужно выполнить сервису sshd после проверки ключа.
тоесть можно устроить так что баш нельзя запускать юзеру после аутентиицкации а только скажем
команду git. более детально aurhorized_keys рассматрим ниже далее. еще раз подчернкну что  в 
aiuthoized_keys неуказывается логин под которым разрешено зайти юзеру , а указан только 
публичный ключ. логин же определяется папкой в которой лежит authoized_keys. тоесть 
если публичный ключ лежит в /home/petya/.ssh/authoeized_keys то тогда удаленный юзер может предетдовать на вход как petya
а если  некий публичный ключ лежит в /home/frosia/.ssh/authoeized_keys то тогда удаленный
юзер может претендовать на вход как frosia.

~/.ssh/known_hosts = этот файл используется клиентом ssh. когда мы с хоста стучимся на удаленный сервер. в этом файле система сохраняет публичный ключ удаленного сервера после того 
как мы руками подтверждаем при первом стуке что хэш публичного ключа дейтсивтетельно верный.
(верность хэша мы проверяем глазами на основе переданного нам ранее каким то человеком по телефону либо через бумажку записи этого самого хэша).






- я пытаюсь разобраться как работает ssh клиент
для начала надо научиться узнавать какой сокет в в /proc/pid/fd ведет в какой IP:port
пример. имеем
вот я подключился к удаленнму 100.0.0.8
имеем на нашем хосте процесс
vasya    27757  0.1  0.0  57320  5804 pts/20   S+   22:08   0:00 ssh root@100.0.0.8
смотрим какие файлы он открыл
$ ls -1al /proc/27757/fd
total 0
dr-x------ 2 vasya vasya  0 июл 11 22:08 .
dr-xr-xr-x 9 vasya vasya  0 июл 11 22:08 ..
lrwx------ 1 vasya vasya 64 июл 11 22:08 0 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 1 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 2 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 3 -> 'socket:[1017376]'
lrwx------ 1 vasya vasya 64 июл 11 22:08 4 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 5 -> /dev/pts/20
lrwx------ 1 vasya vasya 64 июл 11 22:08 6 -> /dev/pts/20

видим что один из файлов это сокет. 
мы хотим узнать куда ( в плане IP:port ) ведет этот сокет
$ lsof -n | grep '1017376'
ssh       27757                  vasya    3u     IPv4            1017376       0t0        TCP 100.0.0.1:53266->100.0.0.8:ssh (ESTABLISHED)

теперь мы поимаем что когда процесс пишет в этот "файл" то по факту байты улетают на 
удаленный сервер 100.0.0.8:22

кстати теперь зайдем на удаленный сервер и посмотрим какой процесс там заведует 
обработкой принятых байтов. тоесть у какого процесса на той стороне открыт сокет который
принимает байты от нас. 

(удаленный сервер)
# lsof -n | grep -i 53266
sshd      1438                root    3u     IPv4              23957      0t0        TCP 100.0.0.8:ssh->100.0.0.1:53266 (ESTABLISHED)

это процесс с pid=1438
(удаленный сервер)
# ps aux | grep 1438
root      1438  0.0  1.0 107984  7028 ?        Ss   19:08   0:00 sshd: root@pts/1

(удаленный сервер)
# pstree -Asp 1438
systemd(1)---sshd(1337)---sshd(1438)---bash(1542)---pstree(1584)

(удаленный сервер)
# ps aux | grep -E "1438|1337"
root      1337  0.0  0.8  72296  5584 ?        Ss   18:38   0:00 /usr/sbin/sshd -D
root      1438  0.0  1.0 107984  7028 ?        Ss   19:08   0:00 sshd: root@pts/1


таким образом мы видим что поток с нашего компа на удаленном компе обслуживает
принимает процесс sshd но не главный а его дочерний процесс форк (который кстати запущен по рутом заметим)

а какие же там файлы открыты у 1438

(удаленный сервер)
# ls -1al /proc/1438/fd
total 0
dr-x------ 2 root root  0 Jul 11 19:08 .
dr-xr-xr-x 9 root root  0 Jul 11 19:08 ..
lrwx------ 1 root root 64 Jul 11 19:08 0 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 1 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:18 10 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:18 11 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:08 2 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 3 -> 'socket:[23957]'
lrwx------ 1 root root 64 Jul 11 19:08 4 -> 'socket:[22651]'
lr-x------ 1 root root 64 Jul 11 19:08 5 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 6 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 7 -> /run/systemd/sessions/5.ref
lrwx------ 1 root root 64 Jul 11 19:18 8 -> /dev/ptmx

в том числе открыт  socket:[23957] котоырй принимает байты с нашего хоста 

получатеся на нашем компе процесс 27757 ssh root@100.0.0.8 имеет открытый файл-сокет /proc/27757/fd/3 -> 'socket:[1017376]'  в который он пишет байты ( и принимает) а эти
байты уже по сети летят на удаленный сервер и там их принимает процесс 1438 sshd: root@pts/1
через  файл /proc/1438/fd/3 -> 'socket:[23957]'

но это только часть картины. когда 1438 получил байты с нашего компа то ему нужно их
послать в баш с которым мы хотим там работать. 
из этой картины видно на удаленном сервере 1438 sshd запустил баш(1542)
(удаленный сервер)
# pstree -Asp 1438
systemd(1)---sshd(1337)---sshd(1438)---bash(1542)  

вот в него 1438 и должен пихать полученные байт.
посмотрим какие файлы открыты у 1542
(удаленный сервер)
# ls -1al /proc/1542/fd
total 0
dr-x------ 2 root root  0 Jul 11 19:08 .
dr-xr-xr-x 9 root root  0 Jul 11 19:08 ..
lrwx------ 1 root root 64 Jul 11 19:08 0 -> /dev/pts/1
lrwx------ 1 root root 64 Jul 11 19:08 1 -> /dev/pts/1
lrwx------ 1 root root 64 Jul 11 19:08 2 -> /dev/pts/1
lrwx------ 1 root root 64 Jul 11 19:18 255 -> /dev/pts/1

видно что никаких сокетов пайаов и прочих хитрых файлов неоткрыто у баша 1542.
это значит что условно говоря баш знать незнает и неподозревает что на нем работают 
в удаленном режиме. для него вся работа происходит как бутто на локальном компе с ним работают. в моем понимании 1438 sshd он тупо посылает полученные байты в /proc/1542/fd/0
и это как бы просто понятно воольготно.  что меня больше интересует это как 1438
сканирует станадртный вывод /proc/1542/fd/1 ведь 1438 должен ловит все что вылетает из баша 
и отправлять обратно через /proc/1438/fd/3 ->'socket:[23957]'
Если мы еще раз посмотрим на открытые файлы  у 1438
(удаленный сервер)
# ls -1al /proc/1438/fd
total 0
dr-x------ 2 root root  0 Jul 11 19:08 .
dr-xr-xr-x 9 root root  0 Jul 11 19:08 ..
lrwx------ 1 root root 64 Jul 11 19:08 0 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 1 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:18 10 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:18 11 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:08 2 -> /dev/null
lrwx------ 1 root root 64 Jul 11 19:08 3 -> 'socket:[23957]'
lrwx------ 1 root root 64 Jul 11 19:08 4 -> 'socket:[22651]'
lr-x------ 1 root root 64 Jul 11 19:08 5 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 6 -> 'pipe:[22775]'
l-wx------ 1 root root 64 Jul 11 19:18 7 -> /run/systemd/sessions/5.ref
lrwx------ 1 root root 64 Jul 11 19:18 8 -> /dev/ptmx

то мы увидим что /dev/null нас неинереусует. что пайп начинается и заканчивается
сам на себе. тоесть он выходит из данного процесса и входит в него же. 
таким образом мне только приходдит в голову что по идее все что летит на стандартный вывод
 у баша 1542 возможно возможно автоматом ядро дублирует (или типа того ) на какойто /dev/ptmx у 1438 тоесть примерно говоря все что баш 1542 отправляет в /proc/1542/fd/1 -> /dev/pts/1
 все это ядро автоматом дублирует на какойто /dev/ptmx у 1438. вот это надо проверить с этим надо разобраться потому что надо понять каким макаром то что баш 1542 пихает на свой 
 стадантртый вывод попадает в 1438 sshd чтобы он мог это отправить нашему клиенту.
 для этого мы начнем strace процесса 1438 

 (удаленная машина)
# strace -f -p 1438
strace: Process 1438 attached
select(11, [3 5 10], [], NULL, NULL
тоесть мы видим что select пасет появление информации на файлах 3,5,10
ну 3 это у нас сетевой сокет щас он нас неинтереусет, 5 это пайп и если чстно я непонимаю
что он вообще делает зачем нужен, а вот 10 это /dev/ptmx вот я ожидаю что с него и польется 


далее я взял на удаленной машине и посла в /dev/pts/1 мессадж.
(удаленная машина)
# echo "111" > /dev/pts/1
тоесть я проэмулировал что баш 1542 чтото выплюнул на свой старнадартнй вывод.
и вот что я вижу у 1438

(удаленная машина)
# strace -f -p 1438
...
read(10, "111\r\n", 16384)

и точно как мы видим из файла 10 тоесть их /proc/1438/fd/10 -> /dev/ptmx
прилетели "111" которые мы направили в /dev/pts/1 таким образом все что вылетает ищ баша 1542 в стандартный вывод /proc/1542/fd/1 -> /dev/pts/1 оно автоматом ядром направляется в 
/proc/1438/fd/10 -> /dev/ptmx и таким макаром 1438 sshd получает автоматом в свои недра 
все что вылетело из баша 1542. ну и далее было бы логично что получив эти данные 1438 должен 
их пихать в сетевой сокет 3 чтобы это улетело на удаленный хост к нашему клиенту
и это так и есть  потому что далее я вижу

(удаленная машина)
# strace -f -p 1438
...
read(10, "111\r\n", 16384)
...
write(3, "\32q\274_\225\316\374\265\"\352\313g}d\34\311\303\334\25\236\254\235\"i\215\303\374\274E\1\226#"..., 44) = 44

3 это сокет socket:[23957] , тоесть когда 1438 пишет в 3 то ядро эти байты посылает  в сеть 
в 100.0.0.1 тоесть в наш хост который клиент (напомню 100.0.0.8 это удаленный сервер а 100.0.0.1 это наш хост который клиент)

и да эти "111" и вижу на моем клиенстком компе
(локальный комп)
root@test:~# 111

остается два вопроса. каким макаром так нестроено что если кидать данные в /dev/pts/1 то они автоматом переслыаеются ядром в /dev/ptmx
второй вопрос. если я на компе открою баш в граф оболочке то у этого баш тоже будут 
на бекенде открыты файлы вида /dev/pts/X так вот вопрос каким макаром то что вылетает 
из /dev/pts/X появляется на экране терминала в граф оболочке. тоесть условно говоря почему
в одном случае данные летят в /dev/pts/X и в итоге они отображаются на экране а вдругом
случае напрвляем дарные в /dev/pts/X и они летят в сеть а на экране ничего нет.

- думаю самое время изучить как работает ptmx. смотрим не man ptmx ибо там мало что полезного а сразу 
$ man 4 pty 
и оказывается очень интересно - /dev/pty/X файл появляется в системе тоггда когда процесс
открывает файл ptmx. ксати странно что я нашел два файла ptmx.
$ find /dev/ -name ptmx
/dev/pts/ptmx
/dev/ptmx
какой из двух надо открыать? 
из свойств процессов на /proc  я выяснил что везде используется /dev/ptmx
и неисползуется /dev/pts/ptmx пример
# stat  /proc/1438/fd/11
  File: /proc/1438/fd/11 -> /dev/ptmx
  Size: 64        	Blocks: 0          IO Block: 1024   symbolic link
Device: 4h/4d	Inode: 25342       Links: 1

и кстати на сайт ibm  я нашел то что Because a symbolic link refers to a file by its path name rather than by its inode number, a symbolic link can refer to files in other mounted file systems. фишка здесь  в том что в симболинк линке ссылка на файл идет не по иноде
а по пути. что и видно из stat
ладно это мы отвлклись


в любом случае  совсем непонятно это то что 
у нас куча pts файлов и всего один (скорей всего /dev/ptmx)  ptmx файл. 
так вот в man pty написано что когда мы открыли ptmx файл в программе у нас появлется
новый /dev/pts/X файл и то что если мы шлем инфо в /dev/pts/X то она автоматом (как через пайп) вылает из ptmx файла. и наоборот если мы пишем в ptmx то оно вылетает из /dev/pts/X
получается типа такого 
/dev/pts/ptmx <--- ядро ---> /dev/pts/X
теперь из этого совершенно понятно каким макаром 1438 sshd получает автоматом себе на вход в 
/proc/1438/fd/10 -> /dev/ptmx то что выплюнул bash 1452 в /dev/pts/1
теперь это стало абсолдтно понятно. 

- но возникает вопрос если у нас для всех /dev/pty/X всего навсего один /dev/ptmx то вопрос вот у нас есть процесс 1438 у него открыто несколько 
ptmx  
# ls -1al /proc/1438/fd
total 0
lrwx------ 1 root root 64 Jul 11 19:18 10 -> /dev/ptmx
lrwx------ 1 root root 64 Jul 11 19:18 11 -> /dev/ptmx
как нам узнать к каким /dev/pty/X они ведут ?? совершенно непонятно.
и еще вопрос вот мы шлем в /dev/pty/11 чтото значит автомтом оно вылетает в /dev/pty/ptmx
но ведь у нас у кучи процессов открыт /dev/pty/ptmx они что все одновременно это получаются? что за бред. какой смысл.  <==== закончил тут





- непонятно на диске есть блок и на фс есть блок. ОС ядро работает с каким ?
вообще тема мутная. во первых как я понимаю есть скажем диск.  линуксе есть так называемый блочный драйвер к этому диску. он дает то что другие части ядра и также юзер из юзерспейса могут работаь с этим диском как с набором блоков от 0 до 1000000. тоесть и ядро и юзер(через /dev/sda) могут писать на диск в блок Х и читать с диска блок Х. Это дает блочный драйвер 
от этого диска. Файлоовй соситемы пока что нет и в помине. далее появлыется утилита юзерская mkfs.ext4 /dev/sda эта утилита из юзерспейса обращается к диску в блочном режиме
тоесть она пишет в сектор 1 такой то байт. а  в сектор 5 такой то байт. и все это из юзерспейса. тоесть она в блочном режиме чтото там насоывает на сектора на диске.
далее мы монтируем этот диск через драйвер уже файловой системы. драйвер кода ему подсунули диск то он обращается к этому дику через блочный драйвер в режиме ядра и начиает читать 
опреелееленные сектора ожидая там увидеть некую инфо и он там ее видит. таким обоаохом драйвер понимает что диск размечен. значит на нижгнем уровне драйвер фс по прежнему работает
с диском в блочном режиме через блочный драйвер а на более верхний уровень он уже 
отдает ядру некотоырй более выскооуровневый API. тоесть поялеяется ткое понятие как путь. как папки. как файлы. как отырыть файл. этот функционал драфер фс предостсвляет друим частям ядра. так я это понимаю. при этом такое понятие как фс блок это сугубо внутренняя виртуалная кухня драйвера фс которая сидит исключетльно в его голове. потому что на нижне уровне 
все поп режнему . там сплоные сектора диска. на верхнем уровне там такие понятия как открыть айл. у файла такойто путь. открыт каталог. у него такой то путь. там тоже нет никаких секторов. приколно что в /dev/devices указано только два типа устройсв это блочные и charatcer devris. никаких фс там нет. таким образом в /dev/ устройств которые прекдстаовляют
ФС API таких нет. к дискам разделам только блочный доступ. я бы сказал что фС API представляется драйвером фс ядру его VFS. а уже к ее API мы получе доступ через сисколлы и libc.  поэтому я вижу это так

[блочнй дравер диска(либо md\lvm\raid) - драйвер фс - VFS ] - (syscall\libc)
                        тоесть
[                          ядро                           ] - (юзер спейс) 
таким образом драйвер фс он не для юзерсейса. он позволяет связать одни хрени 
в ядре с другими хренями в ядре.

еще есть некоторые утилиты в юзреспейсе которые позволяют оарщатся к ФС сточки зрения 
ее понятий. непример ее блоков. 


- ext4 wiki



- линукс создать файл с юникод именем
решение:
$ touch  $'\u2234\u2192\u263f\u2605'.txt
$ ls -1 | grep  $'\u2234\u2192\u263f\u2605'
∴→☿★.txt
круто. только непонятно как это работает
и отсюда кстати еще вытекает такой момент - что файловая система ей пофиг какое имя 
имеет файл. она с кодировками неработает. для фс имя файла это просто набор байтов.
имя файла это ропсто набор байтов в блоках иноды которая за папку отвечает. типа
интерпретация байтов зависит от наверное конечного приложения юзерского?
единсвтенное что NUL-terminated, '/'-delimited sequence of bytes" запрещены.
но вопрос. если фс понятия неимеет о наешей кодировке то где может быть проблмеа тогда 
возникнуттьь ?

- статья https://habr.com/ru/post/462849/
- про иноды атрибуты.
- blockdev --getpbsz /dev/sdb
- разница между hdd блоком и ext4 блоком 
- archivemount
- find / -xdev -printf '%h\n' | sort | uniq -c | sort -k 1 -n
- xargs. 
тут дело в том что скажем команда rm tmp* прежде чем вызвать rm баш найдет все
файлы tmp* составит их список и будет вызывать rm подсоывася ей кучу названий файлов
в виде кучи переменных. так вот прикол в том что этот список он ограничен. так что 
более умно делаь чеерз xargs. тоесть есть огарничение на количество парамтров передаываемых
в execve. 
- что такое hashtree. линукс назначает ее папке автоматом если надо
- каков размер блока на ext fs ?


- что такое файловый дескриптор  и файловая таблица и vnode таблица 
- apue process relationship 9.1

- (если на этот вопрос ответил наверху то стереть) как работает ssh клиент между нашим хостом и сервером = на нашем компе запускается процесс ssh он имеет сеетвой сокет. из него он читает и переводит на экран. в в него он пишет с кнопок.
на удаленном компе запускется sshd процесс. он запускает bash там. что  я не пойму то что у того баш процесса все открытые файлы это /dev/pts/0. хорошо. на нашем компе ssh шлет в сетевой
сокет. там sshd процесс читает из сокета и шлет на /dev/pts/0 таки макаром тот баш получает 
наши кнопки. а вот надо понять как вывод баша в /dev/pts/0 ловится на той стороне sshd. каким макаром он /dev/pts/0 сканирует.
	что за ptmx?
	информация о сокете сетевом куда ведет на какой ip:port?



- остается два вопроса. каким макаром так нестроено что если кидать данные в /dev/pts/1 то они автоматом переслыаеются ядром в /dev/ptmx
второй вопрос. если я на компе открою баш в граф оболочке то у этого баш тоже будут 
на бекенде открыты файлы вида /dev/pts/X так вот вопрос каким макаром то что вылетает 
из /dev/pts/X появляется на экране терминала в граф оболочке. тоесть условно говоря почему
в одном случае данные летят в /dev/pts/X и в итоге они отображаются на экране а вдругом
случае напрвляем дарные в /dev/pts/X и они летят в сеть а на экране ничего нет.
  -bash что за минус перед баш?

- проанализиовать $ ssh git@github.com -v
- я вот чото непойму . на гитхабе столкулся у меня сгенерирован ed25519 ключ. но при конекте к гитхабу он конектился успешно через этот ключ но по протоколу ECDSA
попробовать такое провернуть на примере связи с вирт машиной.
а так чтобы исключить это гавно я почистил known_hosts
и в config добавил
$ cat ./config 
HOST github.com
    HOSTNAME github.com
    IdentityFile /home/vasya/.ssh/id_ed25519
    user git
    FingerprintHash sha256     # в каком виде нам показывать хэш 
    HostKeyAlgorithms ssh-ed25519  # по какому ассим протоколу стучать на гитхаб




- vagrant ssh имя банально себя форкает и запускает /usr/bin/ssh c параметрами а сам уходит в wait. вот и весь секрет
- git push -v себя форкает и запускает /usr/bin/ssh c параметрами вот и весь секрвет. так что у него нет встроенного клиента ssh он юзает тот что на хосте. 
- вопрос как git push -v понимает как ключ надо использовать для аутентифкации. ведь у меня их много. как я понял git имеет встоенный ssh клиент. в момем случае он просто перебирал
все ключи что у меня есть  в ~/.ssh. а так получается что встроеннй в git клиент ssh 
тоже умеет использовать ~/.ssh/config файл.мне так кажется. с чего я это взял. потому что 
я в config создал запись для гитхаб и там указал специально неверный ключ. и связь с гитзабом
через git перестала работать (проверить еще раз это)

- man 8 sshd искать формат known_hosts. прочитать проработать
- known_hosts как там найти заданный хост или хэш ? его формат есть в man 8 sshd
- формат known_hosts

- расмотреть случай когда HashKnownHosts yes
- из примера что выше почему в 
(удаленный сервер)# cat /etc/ssh/ssh_host_rsa_key.pub 
есть root@vagrant
а в
(наш комп)$ cat known_hosts
его уже нет

- ssh-rsa vs ecdsa-sha2-nistp256 vs ssh-ed25519

- выяснилась офимегнная вещь. есть sshd_config а  есть ssh_config.
sshd_config это конфиг для сервера ssh тоесть когда наш комп является сервером и принимает
запросы от других и это его конфиг файл. а ssh_config это когда мы с нашего пользуемся клиентом ssh и это его конфиг файл! 
- непонятно ~/.ssh/config это локальный аналог sshd_config или ssh_config. 
насколько я понимаб локального аналога для sshd_config быть неможет . поэтому
~/.ssh/config это аналог ssh_config. тогда непонятно почему опция HashKnownHosts no 
прописанна я в config несрабаывает и срабатывает если ее запихунть только в ssh_config

- HashKnownHosts yes
- формат публичного ключа
- sshd -T 
- ssh-keyscan
- написать какие файлы мы уже затронули для чего ни используется в ssh (наример known_hosts)
- чтобы несравнивать глазами как сравнить два хэша ?
- md5sum binary vs text? какая разница?
- On  systems like GNU that do not distinguish between binary and text
     files, this option merely flags each input mode as binary: the MD5
     checksum is unaffected
- md5sum для публичного ключа несовпдаает с ssh-keygen
тоесть
cat /etc/ssh/key.pub | md5sum  
и
ssh-keygen -fl /etc/ssh/key.pub 
выдает совсем разные хэши. почему? непонятно
- что интересно md5sum он всегда вавыодит хэш без знаков : в отличие от ssh-keygen
- < vs  << vs <<< bash ?
- man md5sum : Do not use the MD5 algorithm for security related purposes. почему?
- надо понять sha256 это наш клиент по деолту так просит или сервер по дефолту так шлет
- где посмотреть какой асиметрик метод первым шлется на сервер (  я про ECDSA который по дефолту предлагается)
- я щас покажу как нам узнать какой метод был выбран чуть ниже. 
- $ ssh -o FingerprintHash=md5 -o  HostKeyAlgorithms=ssh-rsa  100.0.0.6
дебилизмы с -o
- где на клиенстой машине берется публичный ключ который шлется серверу. 
тот публичный ключ котоый используется для создания первичного безопасного канала
- еще такой вадный момент что мы рассматривали как нам важно узнать что публик кей реально 
от сервера. а что насчет сервера? важно ли ему чтобы он знал что наш клиенсткий
ключ исходит именно от нас. в общем случае нет. любой публичнй ключ что от нас что 
от злодея для сервера это полноценный ключ. на основе этих ключей будет устанолвен безопасный
канал между сервером и нами либо между сервером и злодеем. в любом случае небудет тресторонней
цепочти типа мы злодей сервер. тоесть канал шифрования дает то что между точно сервером и 
непонятно каким то есть любымт клиентом  с гарантией что нет третьего участинка устаналивается
безпонаснвй канал. когда он устанолвен то наступает фаза аутентификации клиента. клиент аутентифиаицирцется внутри этого безпоасного канала либо через логин пароль либо через публичный ключ и так понимаю что это неможет быть другой ключ отличный от того что участвовал
в создании безопасного канала (верно неверно?). через аутентифцаицию сервер понимает что 
эт непросто вообще клиент а именно этот клеинт. есл через ключ то на сервере нужно заблаговременно добавлять хэш публичного ключа клиента ( верно неверно?)

- вопрос асиметрик метод и симетрик метод о них договоариваются сразу на первом этапе за один раз или на разных
этапах. 

- вопрос симметрис vs asymtryc. на первом этапе неиспользуется асссиметричное шфиование. почему?потому что с его помощью невозможно беопасно выработать общий ключ ? типа асиметрик шифрование
это единственный способ? ассмтерик шифрование неиспользуеся дляпердачи больших данных потому 
что оно супер тяжелое по сравнению с симметрик шифрованием ?

- как договвариваются клиент и сервер (причем надежно чтоб мэн ин зе мидл не влез) о 
о начальных параметрах сеанса. например о способе ассметриченого шифрования.
- ssh vs ssl ?
- ssh vs ipsec
- дифи хельман ?
- ssh на циско
- походу ssh это всегда async шифрвание вначале  а потом sync шифрование?
- а какой протокол на sync у ssh ?
- получается три фазы? фаза обмена параметрами, асинк шифр, синк шифр? разница с ipsec?
- hmac ?
- при команде $ vagrant ssh имя_вируталки 
по факту в списке процессов появлется такой
/usr/bin/ssh vagrant@127.0.0.1 -p 2222 -o LogLevel=FATAL -o Compression=yes -o DSAAuthentication=yes -o IdentitiesOnly=yes -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i /home/vasya/.vagrant.d/insecure_private_key -o ForwardAgent=yes
разобрать ключи. 
кстати сразу видно какой приватный ключ используется === -i /home/vasya/.vagrant.d/insecure_private_key


