==============
|сменить unix_socket на password аутентфикацию

как для ползоавтеля сменить тип аутентификации с метода unix_socket (когда без пароля входим)
на вход по паролю

метод через alter user(про который постоянно пишут!) появился только в 10.2 
а если версия mariadb более старая то там просто напросто 
этого alter user его нет, поэтому через компнду:


update mysql.user 
 set authentication_string=password('mypass'),  
 plugin='mysql_native_password' 
where user='root'; 


MariaDB [(none)]> select host,user,plugin,password from mysql.user;
+-----------+------------+-----------------------+-------------------------------------------+
| host      | user       | plugin                | password                                  |
+-----------+------------+-----------------------+-------------------------------------------+
| localhost | root       | mysql_native_password | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
| localhost | vasya      |                       | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
+-----------+------------+-----------------------+-------------------------------------------+

что интересно что если в поле plugin стоит пусто 
то это считается что вход наод делать через пассворд.

==
| slow

отклчюить slow query log

[mysqld]
slow_query_log  = 0

===
|старт в режиме когда грант тейблс отключены (single user режим)

изначит можно войти без пароля

# systemctl stop mariadb

# mysqld --skip-grant-tables  &

проверем что гратнт тейблс отключены:
MariaDB [(none)]> show grants for root@localhost;
ERROR 1290 (HY000): The MariaDB server is running with the --skip-grant-tables option so it cannot execute this statement

когда уже вошли то активировать обратно grant tables можно 
чрез команду
MariaDB [(none)]> flush privileges;
Query OK, 0 rows affected (0.00 sec)

MariaDB [(none)]> show grants for root@localhost;
+----------------------------------------------------------------------------------------------------------------------+
| Grants for root@localhost                                                                                            |
+----------------------------------------------------------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY PASSWORD '*23AE809DDACAF96AF0FD78ED04B6A265E05AA257' |
| GRANT PROXY ON ''@'%' TO 'root'@'localhost' WITH GRANT OPTION                                                        |
+----------------------------------------------------------------------------------------------------------------------+



пароль для юзера можно имзенить тоько когда grant tables активны.

поэтму если нет рут пароля то дезактиивируем эти таблицы, заходоим,
активирет обратно, потом меняем пароль как описано выше.



============================
| как запустить mysql в режме skip-grant-tables когда для входа ненужен пароль и 
потом сменить пароль для root юзера



убунту 18:
> select version();
+----------------------------------+
| version()                        |
+----------------------------------+
| 10.1.48-MariaDB-0ubuntu0.18.04.1 |
+----------------------------------+



# systemctl stop mariadb

# mysqld --skip-grant-tables  &
# mysql
>  flush privileges;
> update mysql.user  
       set authentication_string=password('789'),  
       plugin='mysql_native_password'  
       where user='root' and host='localhost';
>exit

# kill -15 $(ps aux | grep mysqld | grep -v grep | awk '{print $2}')
# systemctl start mariadb
# mysql -u root -p
Enter password: 789

MariaDB [(none)]> select user();
+----------------+
| user()         |
+----------------+
| root@localhost |
+----------------+


значит начиная с mariadb 10.2 ввели alter user поэтому тогда уже вместо

> update mysql.user  
       set authentication_string=password('789'),  
       plugin='mysql_native_password'  
       where user='root' and host='localhost';


надо юзать alter user ... (https://mariadb.com/kb/en/alter-user/)


а начиная с 10.4 все стало еще круче:
MariaDB-10.4+ the mysql.user is a view rather than a table.
Its recommend to stop copying off old blogs to do any authentication relates changes in MySQL and MariaDB, the mechanisms are being updated and no longer apply. Always check the official documentation.
Use SET PASSWORD or ALTER USER to manage user authentication.
Also modifying a user/host component of the username will put triggers, events, plugins, grants, roles etc out of sync with the combined username (aka broken). So just DROP/CREATE users rather than manipulate them.


убунту 22:
> select version();
+--------------------------------------+
| version()                            |
+--------------------------------------+
| 10.6.12-MariaDB-0ubuntu0.22.04.1-log |
+--------------------------------------+


====
|revoke all privileges

"To revoke all privileges, use the second syntax, which drops all global, database, table, column, and routine privileges for the named user or users:

REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] ..."

=====
|создать юзера с входом по паролю


> CREATE USER foo2@test IDENTIFIED BY 'password';


MariaDB [(none)]> select host,user,plugin,password from mysql.user;
+-----------+------------+-------------+-------------------------------------------+
| host      | user       | plugin      | password                                  |
+-----------+------------+-------------+-------------------------------------------+
| localhost | vasya      |             | *23AE809DDACAF96AF0FD78ED04B6A265E05AA257 |
+-----------+------------+-------------+-------------------------------------------+


======
| replication
| gtid

как настроить slave replication репликацию

в какой конфиг писать = cat /etc/mysql/mariadb.conf.d/50-server.cnf 

||master||

у меня
[mariadb]
server_id=1
bind-address=0.0.0.0
log-bin
gtid_strict_mode=1
log-bin = /var/log/mysql/binlogs/binlog


в книге
[mysqld]
server-id=1
bind-address = 0.0.0.0
gtid_strict_mode=1
log_bin=/var/log/mysql/mariadb-bin
expire_logs_days=10
sync_binlog = 1
slave_compressed_protocol = 1
binlog_format = row


суммарный конфиг:

# mkdir /var/log/mysql/binlogs
# chown mysql.mysql  /var/log/mysql/binlogs



[mariadb]
server_id=1
bind-address=0.0.0.0
gtid_strict_mode=1
log-bin
log-bin = /var/log/mysql/binlogs/binlog
expire_logs_days=10
sync_binlog = 1
slave_compressed_protocol = 1
binlog_format = row


# systemctl restart mariadb; systemctl status mariadb 


> create user 'replication'@'10.113.151.143' identified by 'ieJug7pu7baamoh2Soph5eChe';
> grant replication slave on *.* to 'replication'@'10.113.151.143';
> FLUSH PRIVILEGES;


backup

# apt install -y mariadb-backup
# mkdir -p ~/backup/01

вместо mariadb-backup




ставим qpress. вроде бы для сжатия базы он mariabackup ненужен.
но всеже ставим на всякий случай. qpress нужен при выполнении --decompress (тоесть он точнопонадбится на slave ноде).
но все же ставим и на мастере
#  wget https://repo.percona.com/apt/percona-release_latest.$(lsb_release -sc)_all.deb
#  dpkg -i /root/percona-release_latest.jammy_all.deb 
#  apt-get update
# apt-get -y install qpress    

# mariabackup \
         --defaults-file=/etc/mysql/my.cnf \
         --backup \
         --compress \
         --target-dir=~/backup/01 \
         --user=root


# tar cvpzf ~/01.tar.gz  ~/backup/01
# scp ~/01.tar.gz ...
или
# lxc file pull mar-3/root/01.tar.gz .
# lxc file push ./01.tar.gz mar-4/root/









||slave||
у меня:
[mariadb]
server_id=2
bind-address=0.0.0.0
log_error=mariadb.err
log_error=/var/log/mysql/mariadb.err





в кнжке:
[mysqld]
server-id=3
bind-address = 0.0.0.0
slave_compressed_protocol = 1
binlog_format = row
read_only
gtid_strict_mode=1


в итоге:
[mariadb]
server_id=2
bind-address=0.0.0.0
slave_compressed_protocol = 1
binlog_format = row
read_only
gtid_strict_mode=1
log_error=/var/log/mysql/mariadb.err


# systemctl restart mariadb; systemctl status mariadb
# systemctl stop mariadb





# systemctl stop mariadb
# apt install -y mariadb-backup
# rm -r /var/lib/mysql/*    # знак * обязательно иначе удалить и саму папку /var/lib/mysql
# mkdir -p ~/backup/01
#  tar xpvzf   ~/01.tar.gz  -C ~/backup/01


#  wget https://repo.percona.com/apt/percona-release_latest.$(lsb_release -sc)_all.deb
#  dpkg -i /root/percona-release_latest.jammy_all.deb 
#  apt-get update
# apt-get -y install qpress    # qpress нужен mariabackup при ввыполнении --decompress. иначе напишет что ей
                               # нужен  qpress 


# mariabackup --decompress \
              --remove-original \
              --target-dir=~/backup/01


# mariabackup --prepare \
              --target-dir=~/backup/01


prepare запускаем только после decompress. иначе он бует писать что неможет найти файл backup-my.cnf

# mariabackup --copy-back \
   --target-dir=~/backup/01 \
   --datadir=/var/lib/mysql





# chown -R mysql:mysql /var/lib/mysql/

# systemctl start mariadb; systemctl status mariadb;

# cat /var/lib/mysql/xtrabackup_info | grep -i GTID

binlog_pos = filename 'binlog.000001', position '820', GTID of the last change '0-1-3'

значит GTID='0-1-3'


MariaDB [(none)]> stop slave;
MariaDB [(none)]> reset slave;
MariaDB [(none)]> set global gtid_slave_pos = "0-1-3";
MariaDB [(none)]> change master to master_host='10.113.151.222', master_port=3306,
master_user='replication', master_password='ieJug7pu7baamoh2Soph5eChe', master_connect_retry=10,
master_use_gtid=slave_pos;

проверяем что устаолвен 'read_only'

> show variables like "read_only";
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| read_only     | ON    |
+---------------+-------+


MariaDB [(none)]> start slave;
> select @@gtid_slave_pos;
> show slave status\G;


если данные активно реацлируется на slave 
то на нем постоянно будем расти

> select @@gtid_slave_pos;
+------------------+
| @@gtid_slave_pos |
+------------------+
| 0-1-2880         |
+------------------+


прикольно что на мастере тоже есть gtid

> SHOW GLOBAL VARIABLES LIKE '%gtid%';
+-------------------------+----------+
| Variable_name           | Value    |
+-------------------------+----------+
| gtid_binlog_pos         | 0-1-7633 |
| gtid_binlog_state       | 0-1-7633 |
| gtid_cleanup_batch_size | 64       |
| gtid_current_pos        | 0-1-7633 |
| gtid_domain_id          | 0        |
| gtid_ignore_duplicates  | OFF      |
| gtid_pos_auto_engines   |          |
| gtid_slave_pos          |          |
| gtid_strict_mode        | ON       |
| wsrep_gtid_domain_id    | 0        |
| wsrep_gtid_mode         | OFF      |
+-------------------------+----------+



также хотел добавит что вместо mariadb-backup
можно поставить percona xtra backup

запускать бэкап тогда вот так

$ xtrabackup --backup --compress --compress-threads=2 \
--target-dir=/data/compressed/

число тредов это число цпу на компе





===========

ошибка

 [Warning] Could not increase number of max_open_files to more than 32768 (request: 128439)

 как исправить. 
 через drop-in файл

# mkdir -p /etc/systemd/system/mariadb.service.d/ 
# touch  /etc/systemd/system/mariadb.service.d/Limitnofile_custom.conf

[Service]

LimitNOFILE=131072


незнаю что тут важно написать имя параметра в точности LimitNOFILE соблюдая большие буквы
или то что число должно быть кратно 32768.
но когда я написал вот так

[Service]

Limitnofile=130000

нихера незаработало.
так что обращаю внимание на точность соблюдения рецепта.



# systemctl daemon-reload &&  systemctl restart mariadb ; systemctl status mariadb


если все сработало то в выводе status болше ошибки 
 [Warning] Could not increase number of max_open_files to more than 32768 (request: 128439)
 быть не должно

 ===
 slowlog
 slow log

 при настройке slow log надо обязательно отключить опцию


[mysqld]
log_queries_not_using_indexes =0

смысл ее в том что она логирует запросы которые исполльзуют FULLSCAN.
вроде как выглядит идея красиво. только прикол в том что в логи будут попадать запросы длинной 0.000003с
нахер они там нужны

==
slow log

тако еще прикол - почемуто не все транзакции имеют поле дата.
тоесть какието имеют каието нет.
тоесть не вегда понятно в какйо день и какое вреомя трнзаакция случилась 
пример

один и тот же файл:

# Time: 230525 17:56:10
# User@Host: gt[gt] @  [192.168.5.206]
# Thread_id: 74987  Schema: erp  QC_hit: No
# Query_time: 0.000467  Lock_time: 0.000176  Rows_sent: 0  Rows_examined: 0
# Rows_affected: 0  Bytes_sent: 1558
# Tmp_tables: 1  Tmp_disk_tables: 0  Tmp_table_sizes: 0
# Full_scan: Yes  Full_join: Yes  Tmp_table: Yes  Tmp_table_on_disk: No
# Filesort: Yes  Filesort_on_disk: No  Merge_passes: 0  Priority_queue: No
SET timestamp=1685026570;
...

# User@Host: gt[gt] @  [192.168.5.206]
# Thread_id: 74987  Schema: erp  QC_hit: No
# Query_time: 0.000081  Lock_time: 0.000029  Rows_sent: 0  Rows_examined: 0
# Rows_affected: 0  Bytes_sent: 86
# Full_scan: Yes  Full_join: No  Tmp_table: No  Tmp_table_on_disk: No
# Filesort: Yes  Filesort_on_disk: No  Merge_passes: 0  Priority_queue: Yes
SET timestamp=1685026570;
...


как видно одна запист имеет поле
# Time: 230525 17:56:10

а вторая нет.

непонятно

===

cardinality

это по русски количество уникальных строк в столбце таблицы.
и эта характеристика прписывается в индексе. ну обычно ее можно посмотреть в индексе от столбца у таблицы.

> show index from table_3;
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| table_3 |          1 | in_a     |            1 | a           | A         |           2 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+

ну типа это примерное занчение. а не точное.
так вот я выяснил еще из практики что вот мы вставляем новые стровки в столбик
но кардиналити при этом показыает неверное у индекса.  я вствлял одни и теже строки и кардиналити рос.
хотя строки одни и теже. и толко после того как  я  запусьил команду

> analyze table table_3;

только тогда  кардиналити в индексе стало коректным.

вот пример

MariaDB [db1]> select * from table_3 order by a asc;
+------+
| a    |
+------+
|    1 |
|    1 |
|    1 |
|    2 |
+------+
4 rows in set (0.001 sec)

MariaDB [db1]> show index from table_3;
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| table_3 |          1 | in_a     |            1 | a           | A         |           4 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
1 row in set (0.000 sec)


две уникальные строчки. а кардиналиьи 4.

добавляем еще строчку

MariaDB [db1]> insert into table_3 (a) values (1);
Query OK, 1 row affected (0.056 sec)

MariaDB [db1]> show index from table_3;
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| table_3 |          1 | in_a     |            1 | a           | A         |           5 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
1 row in set (0.001 sec)

уже кардиналити 5

 я удалили и пересозда индекс но это не помогло!

 MariaDB [db1]> drop index in_a on table_3;
Query OK, 0 rows affected (0.013 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [db1]> show index from table_3;
Empty set (0.001 sec)

MariaDB [db1]> create index in_a on table_3 (a);
Query OK, 0 rows affected (0.019 sec)
Records: 0  Duplicates: 0  Warnings: 0

MariaDB [db1]> show index from table_3;
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| table_3 |          1 | in_a     |            1 | a           | A         |           4 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
1 row in set (0.001 sec)

MariaDB [db1]> select * from table_3 order by a asc;
+------+
| a    |
+------+
|    1 |
|    1 |
|    1 |
|    1 |
|    2 |
+------+
5 rows in set (0.000 sec)


и только когдя сделал anayze то все исправилось

MariaDB [db1]> analyze table table_3 persistent  for all;
+-------------+---------+----------+-----------------------------------------+
| Table       | Op      | Msg_type | Msg_text                                |
+-------------+---------+----------+-----------------------------------------+
| db1.table_3 | analyze | status   | Engine-independent statistics collected |
| db1.table_3 | analyze | status   | OK                                      |
+-------------+---------+----------+-----------------------------------------+
2 rows in set (0.013 sec)

MariaDB [db1]> show index from table_3;
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| Table   | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Ignored |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
| table_3 |          1 | in_a     |            1 | a           | A         |           2 |     NULL | NULL   | YES  | BTREE      |         |               | NO      |
+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+
1 row in set (0.002 sec)

===
logrotate

по дефолту с mariadb ставит  logorate скрипт  
/etc/logrotate.d/mariadb

прикол в том что он коректно отарабтаыет толко если для root@localhost 
доступ к мускула идет без пароя а через unix_socket

так что надо это учитыать


проверить как щас дела у мукула с атуентфикаей root

> select user,host,password,plugin  from  mysql.user where User="root";
+------+-----------+----------+-------------+
| User | Host      | Password | plugin      |
+------+-----------+----------+-------------+
| root | localhost |          | unix_socket |
| root | %         |          | unix_socket |
+------+-----------+----------+-------------+
2 rows in set (0,001 sec)


как поменять на unix_socket если щас стоит парольный тип досутпа

> ALTER USER root@`localhost` IDENTIFIED VIA unix_socket;



===

| размер базы

SELECT table_schema AS "Database", 
ROUND(SUM(data_length + index_length) / 1024 / 1024, 2) AS "Size (MB)" 
FROM information_schema.TABLES 
GROUP BY table_schema;

===

| пример ускорения запроса


запрос

root@mar-single-1:~/mysql/02# cat orig-an.sql 
analyze
(SELECT insurance_acceptance.*,
            `order`.title AS 'order_title',
            `order`.date AS 'order_date',
            `order`.appraised_value,
            `order`.service_id as order_service_id,
            invoice.draw_date AS credit_invoice_draw_date,
            waybill_insurance.service_id,
            waybill_insurance.invoice_id,
            waybill_insurance.sum_debit,
            waybill_insurance.sum_credit,
            waybill_insurance.pricing_debug,
            service.title service_title,
            company.client_id company_client_id
            FROM insurance_acceptance USE INDEX (is_active_idx)
            INNER JOIN waybill waybill_insurance ON (insurance_acceptance.waybill_id = waybill_insurance.waybill_id AND waybill_insurance.service_id IN (93,94,21,22))
            INNER JOIN `order` ON (waybill_insurance.order_id = `order`.order_id)
            INNER JOIN service ON (waybill_insurance.service_id = service.service_id)
            INNER JOIN invoice ON (waybill_insurance.invoice_id = invoice.invoice_id)
            INNER JOIN `account` client_account ON (invoice.from_account_id = client_account.account_id)
            INNER JOIN `account` company_account ON (invoice.to_account_id = company_account.account_id)
            INNER JOIN `company` ON (company_account.company_id = company.company_id)
            LEFT OUTER JOIN waybill waybill_main ON waybill_main.order_id=`order`.order_id AND waybill_main.service_id IN (93,94)
            LEFT OUTER JOIN insurance_acceptance acceptance_main ON acceptance_main.waybill_id=waybill_main.waybill_id AND acceptance_main.is_active=1
            WHERE insurance_acceptance.status_id IN (1,13,21)
            AND insurance_acceptance.is_active = 1
            AND client_account.subject_id = 1403887
            AND insurance_acceptance.invoice_from_client_id =  1403887
            AND company.client_id IS NOT NULL
            AND invoice.draw_date >= '2020-10-01'
            AND `order`.date >= '2020-11-01'
            AND insurance_acceptance.acceptance_number != ''
            AND LENGTH(insurance_acceptance.acceptance_number) > 5
            AND `order`.service_id IN (45,46,47,48,100,11662,333196,942285,1001790,2050499,2187663)
            AND (waybill_insurance.parent_service_id NOT IN (93,94) OR waybill_insurance.parent_service_id IS NULL
                OR (acceptance_main.status_id=7)
            )
            ORDER BY insurance_acceptance.status_date LIMIT 50) 
            UNION
            
            (SELECT insurance_acceptance.*,
            history.title AS 'order_title',
            history.date AS 'order_date',
            history.appraised_value,
            history.service_id as order_service_id,
            null AS credit_invoice_draw_date,
            insurance_acceptance.service_id AS service_id,
            waybill_history.invoice_id,
            waybill_history.sum_debit,
            waybill_history.sum_credit,
            null AS pricing_debug,
            service.title service_title,
            company.client_id company_client_id
            FROM insurance_acceptance 
            INNER JOIN order_history history ON (history.order_id = insurance_acceptance.order_id 
            AND history.revision_id = (SELECT MAX(oh.revision_id) FROM order_history oh INNER JOIN waybill_history wh ON oh.revision_id = wh.revision_id
            WHERE oh.order_id = insurance_acceptance.order_id AND wh.invoice_id IS NOT NULL))
            LEFT JOIN waybill_history ON history.revision_id = waybill_history.revision_id AND waybill_history.waybill_id = insurance_acceptance.waybill_id
            LEFT JOIN service ON (insurance_acceptance.service_id = service.service_id)
            LEFT JOIN `company` ON (insurance_acceptance.invoice_to_company_id = company.company_id)
            LEFT OUTER JOIN waybill waybill_main ON waybill_main.order_id=`history`.order_id AND waybill_main.service_id IN (93,94)
            LEFT OUTER JOIN insurance_acceptance acceptance_main ON acceptance_main.waybill_id=waybill_main.waybill_id AND acceptance_main.is_active=1
            WHERE insurance_acceptance.status_id = 16
            AND insurance_acceptance.is_active = 1
            AND insurance_acceptance.service_id IN (93,94,21,22)
            AND insurance_acceptance.invoice_from_client_id =  1403887
            AND company.client_id IS NOT NULL 
            AND history.report_date >= '2020-10-01'
            AND history.date >= '2020-11-01'
            AND insurance_acceptance.acceptance_number != ''
            AND (waybill_history.parent_service_id NOT IN (93,94) OR waybill_history.parent_service_id IS NULL
                OR (acceptance_main.status_id=7)
            )
            GROUP BY insurance_acceptance.entry_id
            ORDER BY insurance_acceptance.status_date LIMIT 10)
root@mar-single-1:~/mysql/02# 



orig:

exp
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------------------------------------------------------------------------------------------------------------+
| id   | select_type        | table                | type        | possible_keys                                                                                                                                                      | key                                             | key_len | ref                                                           | rows  | Extra                                                                                                          |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------------------------------------------------------------------------------------------------------------+
|    1 | PRIMARY            | order                | ALL         | PRIMARY,fk_order_service_id_idx,date_idx,service_id                                                                                                                | NULL                                            | NULL    | NULL                                                          | 20195 | Using where; Using temporary; Using filesort                                                                   |
|    1 | PRIMARY            | waybill_insurance    | ref         | PRIMARY,fk_waybill_order_id_idx,fk_waybill_service_id_idx,fk_waybill_parent_service_id_idx,fk_waybill_invoice_id_idx,service_waybill_contact_idx,order_service_idx | fk_waybill_order_id_idx                         | 4       | erp2.order.order_id                                           | 1     | Using where                                                                                                    |
|    1 | PRIMARY            | service              | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 4       | erp2.waybill_insurance.service_id                             | 1     |                                                                                                                |
|    1 | PRIMARY            | invoice              | eq_ref      | PRIMARY,fk_invoice_from_account_id_idx,fk_invoice_to_account_id_idx,draw_date_is_credit_status_idx                                                                 | PRIMARY                                         | 4       | erp2.waybill_insurance.invoice_id                             | 1     | Using where                                                                                                    |
|    1 | PRIMARY            | client_account       | eq_ref      | PRIMARY,subject_id                                                                                                                                                 | PRIMARY                                         | 4       | erp2.invoice.from_account_id                                  | 1     | Using where                                                                                                    |
|    1 | PRIMARY            | waybill_main         | ref         | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                    | order_service_idx                               | 4       | erp2.order.order_id                                           | 1     | Using where; Using index                                                                                       |
|    1 | PRIMARY            | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx                                                                                         | fk_insurance_acceptance_waybill_id              | 4       | erp2.waybill_main.waybill_id                                  | 2     | Using where                                                                                                    |
|    1 | PRIMARY            | company_account      | eq_ref      | PRIMARY,fk_account_company_id_idx                                                                                                                                  | PRIMARY                                         | 4       | erp2.invoice.to_account_id                                    | 1     |                                                                                                                |
|    1 | PRIMARY            | company              | range       | PRIMARY,fk_company_client_id_idx                                                                                                                                   | fk_company_client_id_idx                        | 5       | NULL                                                          | 2     | Using where; Using index; Using join buffer (flat, BNL join)                                                   |
|    1 | PRIMARY            | insurance_acceptance | ref         | is_active_idx                                                                                                                                                      | is_active_idx                                   | 2       | const                                                         | 33572 | Using where                                                                                                    |
|    2 | UNION              | insurance_acceptance | index_merge | fk_insurance_acceptance_status_id,is_active_idx,acceptance_number_idx,order_idx                                                                                    | fk_insurance_acceptance_status_id,is_active_idx | 4,2     | NULL                                                          | 169   | Using intersect(fk_insurance_acceptance_status_id,is_active_idx); Using where; Using temporary; Using filesort |
|    2 | UNION              | history              | eq_ref      | PRIMARY,order_history_order_id_idx                                                                                                                                 | PRIMARY                                         | 8       | func                                                          | 1     | Using where                                                                                                    |
|    2 | UNION              | waybill_history      | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 12      | erp2.history.revision_id,erp2.insurance_acceptance.waybill_id | 1     |                                                                                                                |
|    2 | UNION              | waybill_main         | ref         | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                    | order_service_idx                               | 4       | erp2.insurance_acceptance.order_id                            | 1     | Using where; Using index                                                                                       |
|    2 | UNION              | service              | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 4       | erp2.insurance_acceptance.service_id                          | 1     | Using where                                                                                                    |
|    2 | UNION              | company              | range       | PRIMARY,fk_company_client_id_idx                                                                                                                                   | fk_company_client_id_idx                        | 5       | NULL                                                          | 2     | Using where; Using index; Using join buffer (flat, BNL join)                                                   |
|    2 | UNION              | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx                                                                                         | fk_insurance_acceptance_waybill_id              | 4       | erp2.waybill_main.waybill_id                                  | 2     | Using where                                                                                                    |
|    3 | DEPENDENT SUBQUERY | wh                   | ALL         | PRIMARY                                                                                                                                                            | NULL                                            | NULL    | NULL                                                          | 1     | Using where                                                                                                    |
|    3 | DEPENDENT SUBQUERY | oh                   | eq_ref      | PRIMARY,order_history_order_id_idx                                                                                                                                 | PRIMARY                                         | 8       | erp2.wh.revision_id                                           | 1     | Using where                                                                                                    |
| NULL | UNION RESULT       | <union1,2>           | ALL         | NULL                                                                                                                                                               | NULL                                            | NULL    | NULL                                                          | NULL  |                                                                                                                |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------------------------------------------------------------------------------------------------------------+

anal
> source /root/mysql/02/orig-an.sql
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------+----------+------------+----------------------------------------------------------------------------------------------------------------+
| id   | select_type        | table                | type        | possible_keys                                                                                                                                                      | key                                             | key_len | ref                                                           | rows  | r_rows   | filtered | r_filtered | Extra                                                                                                          |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------+----------+------------+----------------------------------------------------------------------------------------------------------------+
|    1 | PRIMARY            | order                | range       | PRIMARY,fk_order_service_id_idx,date_idx,service_id                                                                                                                | date_idx                                        | 4       | NULL                                                          | 10097 | 20821.00 |    59.32 |      91.77 | Using index condition; Using where; Using temporary; Using filesort                                            |
|    1 | PRIMARY            | waybill_insurance    | ref         | PRIMARY,fk_waybill_order_id_idx,fk_waybill_service_id_idx,fk_waybill_parent_service_id_idx,fk_waybill_invoice_id_idx,service_waybill_contact_idx,order_service_idx | fk_waybill_order_id_idx                         | 4       | erp2.order.order_id                                           | 1     | 3.11     |    56.71 |      24.08 | Using where                                                                                                    |
|    1 | PRIMARY            | service              | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 4       | erp2.waybill_insurance.service_id                             | 1     | 1.00     |   100.00 |     100.00 |                                                                                                                |
|    1 | PRIMARY            | invoice              | eq_ref      | PRIMARY,fk_invoice_from_account_id_idx,fk_invoice_to_account_id_idx,draw_date_is_credit_status_idx                                                                 | PRIMARY                                         | 4       | erp2.waybill_insurance.invoice_id                             | 1     | 1.00     |    50.00 |     100.00 | Using where                                                                                                    |
|    1 | PRIMARY            | client_account       | eq_ref      | PRIMARY,subject_id                                                                                                                                                 | PRIMARY                                         | 4       | erp2.invoice.from_account_id                                  | 1     | 1.00     |     0.01 |     100.00 | Using where                                                                                                    |
|    1 | PRIMARY            | waybill_main         | ref         | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                    | order_service_idx                               | 4       | erp2.order.order_id                                           | 1     | 3.27     |    56.71 |      30.55 | Using where; Using index                                                                                       |
|    1 | PRIMARY            | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx                                                                                         | fk_insurance_acceptance_waybill_id              | 4       | erp2.waybill_main.waybill_id                                  | 2     | 6.13     |    33.46 |      16.31 | Using where                                                                                                    |
|    1 | PRIMARY            | company_account      | eq_ref      | PRIMARY,fk_account_company_id_idx                                                                                                                                  | PRIMARY                                         | 4       | erp2.invoice.to_account_id                                    | 1     | 1.00     |   100.00 |     100.00 |                                                                                                                |
|    1 | PRIMARY            | company              | range       | PRIMARY,fk_company_client_id_idx                                                                                                                                   | fk_company_client_id_idx                        | 5       | NULL                                                          | 2     | 2.00     |   100.00 |      50.00 | Using where; Using index; Using join buffer (flat, BNL join)                                                   |
|    1 | PRIMARY            | insurance_acceptance | ref         | is_active_idx                                                                                                                                                      | is_active_idx                                   | 2       | const                                                         | 33572 | 16787.00 |   100.00 |       0.00 | Using where                                                                                                    |
|    2 | UNION              | insurance_acceptance | index_merge | fk_insurance_acceptance_status_id,is_active_idx,acceptance_number_idx,order_idx                                                                                    | fk_insurance_acceptance_status_id,is_active_idx | 4,2     | NULL                                                          | 169   | 0.00     |    50.09 |     100.00 | Using intersect(fk_insurance_acceptance_status_id,is_active_idx); Using where; Using temporary; Using filesort |
|    2 | UNION              | history              | eq_ref      | PRIMARY,order_history_order_id_idx                                                                                                                                 | PRIMARY                                         | 8       | func                                                          | 1     | NULL     |   100.00 |       NULL | Using where                                                                                                    |
|    2 | UNION              | waybill_history      | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 12      | erp2.history.revision_id,erp2.insurance_acceptance.waybill_id | 1     | NULL     |   100.00 |       NULL |                                                                                                                |
|    2 | UNION              | waybill_main         | ref         | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                    | order_service_idx                               | 4       | erp2.insurance_acceptance.order_id                            | 1     | NULL     |    56.71 |       NULL | Using where; Using index                                                                                       |
|    2 | UNION              | service              | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 4       | erp2.insurance_acceptance.service_id                          | 1     | NULL     |   100.00 |       NULL | Using where                                                                                                    |
|    2 | UNION              | company              | range       | PRIMARY,fk_company_client_id_idx                                                                                                                                   | fk_company_client_id_idx                        | 5       | NULL                                                          | 2     | NULL     |   100.00 |       NULL | Using where; Using index; Using join buffer (flat, BNL join)                                                   |
|    2 | UNION              | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx                                                                                         | fk_insurance_acceptance_waybill_id              | 4       | erp2.waybill_main.waybill_id                                  | 2     | NULL     |    33.46 |       NULL | Using where                                                                                                    |
|    3 | DEPENDENT SUBQUERY | wh                   | ALL         | PRIMARY                                                                                                                                                            | NULL                                            | NULL    | NULL                                                          | 1     | NULL     |   100.00 |       NULL | Using where                                                                                                    |
|    3 | DEPENDENT SUBQUERY | oh                   | eq_ref      | PRIMARY,order_history_order_id_idx                                                                                                                                 | PRIMARY                                         | 8       | erp2.wh.revision_id                                           | 1     | NULL     |   100.00 |       NULL | Using where                                                                                                    |
| NULL | UNION RESULT       | <union1,2>           | ALL         | NULL                                                                                                                                                               | NULL                                            | NULL    | NULL                                                          | NULL  | 50.00    |     NULL |       NULL |                                                                                                                |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------+----------+------------+----------------------------------------------------------------------------------------------------------------+
20 rows in set (11 min 3.265 sec)

время 11m !!!


самая проблема  в запросе это кусок
LEFT OUTER JOIN insurance_acceptance acceptance_main ON acceptance_main.waybill_id=waybill_main.waybill_id AND acceptance_main.is_active=1

в плане это кусок выглядит как
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------------------------------------------------------------------------------------------------------------+
| id   | select_type        | table                | type        | possible_keys                                                                                                                                                      | key                                             | key_len | ref                                                           | rows  | Extra                                                                                                          |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+-------+----------------------------------------------------------------------------------------------------------------+
|    1 | PRIMARY            | insurance_acceptance | ref         | is_active_idx                                                                                                                                                      | is_active_idx                                   | 2       | const                                                         | 33572 | Using where                                                                                                    |
+------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

хотя в колонке key и укаан идекс но в колонке extra неуказано что индекс будет использован.
значит как я понимаю этот where будет испольнятся без индекса. а строк 33 000!

поэтому надо сделать имзеения
> create index in_1_1 on insurance_acceptance (waybill_id, is_active);
> analyze table insurance_acceptance persistent for all;

ии также делаем анализ остальных таббицы запроса

> analyze table for имя_тфблицы persistent for all;
для таблиц:
insurance_acceptance 
waybill 
`order` 
service 
invoice 
account
company            
order_history 
waybill_history 


тогда план меняется на:
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+--------+----------------------------------------------------------------------------------------------------------------+
| id   | select_type        | table                | type        | possible_keys                                                                                                                                                      | key                                             | key_len | ref                                                           | rows   | Extra                                                                                                          |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+--------+----------------------------------------------------------------------------------------------------------------+
|    1 | PRIMARY            | insurance_acceptance | ALL         | is_active_idx                                                                                                                                                      | NULL                                            | NULL    | NULL                                                          | 100437 | Using where; Using temporary; Using filesort                                                                   |
|    1 | PRIMARY            | waybill_insurance    | eq_ref      | PRIMARY,fk_waybill_order_id_idx,fk_waybill_service_id_idx,fk_waybill_parent_service_id_idx,fk_waybill_invoice_id_idx,service_waybill_contact_idx,order_service_idx | PRIMARY                                         | 4       | erp2.insurance_acceptance.waybill_id                          | 1      | Using where                                                                                                    |
|    1 | PRIMARY            | service              | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 4       | erp2.waybill_insurance.service_id                             | 1      |                                                                                                                |
|    1 | PRIMARY            | order                | eq_ref      | PRIMARY,fk_order_service_id_idx,date_idx,service_id                                                                                                                | PRIMARY                                         | 4       | erp2.waybill_insurance.order_id                               | 1      | Using where                                                                                                    |
|    1 | PRIMARY            | waybill_main         | ref         | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                    | order_service_idx                               | 4       | erp2.waybill_insurance.order_id                               | 3      | Using where; Using index                                                                                       |
|    1 | PRIMARY            | invoice              | eq_ref      | PRIMARY,fk_invoice_from_account_id_idx,fk_invoice_to_account_id_idx,draw_date_is_credit_status_idx                                                                 | PRIMARY                                         | 4       | erp2.waybill_insurance.invoice_id                             | 1      | Using where                                                                                                    |
|    1 | PRIMARY            | company_account      | eq_ref      | PRIMARY,fk_account_company_id_idx                                                                                                                                  | PRIMARY                                         | 4       | erp2.invoice.to_account_id                                    | 1      |                                                                                                                |
|    1 | PRIMARY            | company              | range       | PRIMARY,fk_company_client_id_idx                                                                                                                                   | fk_company_client_id_idx                        | 5       | NULL                                                          | 2      | Using where; Using index; Using join buffer (flat, BNL join)                                                   |
|    1 | PRIMARY            | client_account       | range       | PRIMARY,subject_id                                                                                                                                                 | subject_id                                      | 4       | NULL                                                          | 3      | Using where; Using index; Using join buffer (flat, BNL join)                                                   |
|    1 | PRIMARY            | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx,in_1_1                                                                                  | in_1_1                                          | 6       | erp2.waybill_main.waybill_id,const                            | 3      | Using where                                                                                                    |
|    2 | UNION              | insurance_acceptance | index_merge | fk_insurance_acceptance_status_id,is_active_idx,acceptance_number_idx,order_idx                                                                                    | fk_insurance_acceptance_status_id,is_active_idx | 4,2     | NULL                                                          | 169    | Using intersect(fk_insurance_acceptance_status_id,is_active_idx); Using where; Using temporary; Using filesort |
|    2 | UNION              | history              | eq_ref      | PRIMARY,order_history_order_id_idx                                                                                                                                 | PRIMARY                                         | 8       | func                                                          | 1      | Using where                                                                                                    |
|    2 | UNION              | waybill_history      | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 12      | erp2.history.revision_id,erp2.insurance_acceptance.waybill_id | 1      |                                                                                                                |
|    2 | UNION              | service              | eq_ref      | PRIMARY                                                                                                                                                            | PRIMARY                                         | 4       | erp2.insurance_acceptance.service_id                          | 1      | Using where                                                                                                    |
|    2 | UNION              | company              | range       | PRIMARY,fk_company_client_id_idx                                                                                                                                   | fk_company_client_id_idx                        | 5       | NULL                                                          | 2      | Using where; Using index; Using join buffer (flat, BNL join)                                                   |
|    2 | UNION              | waybill_main         | ref         | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                    | order_service_idx                               | 4       | erp2.insurance_acceptance.order_id                            | 3      | Using where; Using index                                                                                       |
|    2 | UNION              | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx,in_1_1                                                                                  | in_1_1                                          | 6       | erp2.waybill_main.waybill_id,const                            | 3      | Using where                                                                                                    |
|    3 | DEPENDENT SUBQUERY | oh                   | ref         | PRIMARY,order_history_order_id_idx                                                                                                                                 | order_history_order_id_idx                      | 4       | erp2.insurance_acceptance.order_id                            | 37     | Using index                                                                                                    |
|    3 | DEPENDENT SUBQUERY | wh                   | ref         | PRIMARY                                                                                                                                                            | PRIMARY                                         | 8       | erp2.oh.revision_id                                           | 3      | Using where                                                                                                    |
| NULL | UNION RESULT       | <union1,2>           | ALL         | NULL                                                                                                                                                               | NULL                                            | NULL    | NULL                                                          | NULL   |                                                                                                                |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+--------+----------------------------------------------------------------------------------------------------------------+

а время выполенния запроса теперь 0.4 с !!!!

видно что наш новый индекс in_1_1 прмиеняется аж два раза ,
для верхнего половинки union (верхний селект) и для нижней половинки union (нижний селект)

+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+--------+----------------------------------------------------------------------------------------------------------------+
| id   | select_type        | table                | type        | possible_keys                                                                                                                                                      | key                                             | key_len | ref                                                           | rows   | Extra                                                                                                          |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+--------+----------------------------------------------------------------------------------------------------------------+
|    1 | PRIMARY            | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx,in_1_1                                                                                  | in_1_1                                          | 6       | erp2.waybill_main.waybill_id,const                            | 3      | Using where                                                                                                    |
|    2 | UNION              | acceptance_main      | ref         | fk_insurance_acceptance_waybill_id,is_active_idx,set_acceptance_number_idx,in_1_1                                                                                  | in_1_1                                          | 6       | erp2.waybill_main.waybill_id,const                            | 3      | Using where                                                                                                    |
+------+--------------------+----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------+---------+---------------------------------------------------------------+--------+----------------------------------------------------------------------------------------------------------------+

как я помню нижний селект отарбтывает мнговноеенно.
тоесть моя задача была ускорит в верхнем селекте эту строку

LEFT OUTER JOIN insurance_acceptance acceptance_main ON 
acceptance_main.waybill_id=waybill_main.waybill_id AND acceptance_main.is_active=1

именно она давала главное торможение

а вот ее analyze план 
после ускорения ( используем analyze format=json)
            



                "table": {
                  "table_name": "acceptance_main",
                  "access_type": "ref",
                  "possible_keys": [
                    "fk_insurance_acceptance_waybill_id",
                    "is_active_idx",
                    "set_acceptance_number_idx",
                    "in_1_1"
                  ],
                  "key": "in_1_1",
                  "key_length": "6",
                  "used_key_parts": ["waybill_id", "is_active"],
                  "ref": ["erp2.waybill_main.waybill_id", "const"],
                  "r_loops": 109,
                  "rows": 3,
                  "r_rows": 1,
                  "r_table_time_ms": 0.621893633,
                  "r_other_time_ms": 0.871348066,
                  "filtered": 100,
                  "r_filtered": 100,
                  "attached_condition": "trigcond(waybill_insurance.parent_service_id not in (93,94) or waybill_insurance.parent_service_id is null or acceptance_main.status_id = 7) and trigcond(trigcond(waybill_main.waybill_id is not null))"
                }
            


видим что используется индекс   in_1_1
                  "key": "in_1_1",


видим что у этого индекса используются поля
                  "used_key_parts": ["waybill_id", "is_active"],


видим что в этом индексе ищется вхождение:
                  "ref": ["erp2.waybill_main.waybill_id", "const"],


что в точности соответвует то что в запросе
            acceptance_main.waybill_id=waybill_main.waybill_id AND acceptance_main.is_active=1


время выполенения этого блока:
                  "r_table_time_ms": 0.621893633,
                  "r_other_time_ms": 0.871348066,

                  

общее правило такое: 
- смотрим план.ищем где укаано много строк.
далее смотрим направо в графу "Extra" если там указан where или join 
но при этом не указан индекс  значит жопа. надо исправлять
- используем analyze format=json . он покажет время торможеия на каждом шаге плана




==========

ошибка

May 27 23:29:29 mar-single-1 mariadbd[290]: 2023-05-27 23:29:29 0 [ERROR] Plugin 'InnoDB' registration as a STORAGE ENGINE failed.
May 27 23:29:29 mar-single-1 mariadbd[290]: 2023-05-27 23:29:29 0 [Note] Plugin 'FEEDBACK' is disabled.
May 27 23:29:29 mar-single-1 mariadbd[290]: 2023-05-27 23:29:29 0 [ERROR] Unknown/unsupported storage engine: InnoDB
May 27 23:29:29 mar-single-1 mariadbd[290]: 2023-05-27 23:29:29 0 [ERROR] Aborting
May 27 23:29:29 mar-single-1 systemd[1]: mariadb.service: Main process exited, code=exited, status=1/FAILURE
May 27 23:29:29 mar-single-1 systemd[1]: mariadb.service: Failed with result 'exit-code'.
May 27 23:29:29 mar-single-1 systemd[1]: Failed to start MariaDB 10.6.12 database server.



решение 

# systemctl stop mariadb

далее удалить /var/lib/mysql
и там надо удалить log файл. (имеется ввиду dblog)

# systemctl start mariadb
# systemctl status mariadb

===

analyze 
одно плана



              waybill 
              parent_order 
           LEFT JOIN waybill ON (`order`.order_id = waybill.order_id)
              LEFT JOIN `order` parent_order ON (`order`.parent_id = parent_order.order_id AND `order`.service_id = 1001790)
              LEFT JOIN waybill shipping ON (IFNULL(parent_order.order_id, `order`.order_id) = shipping.order_id AND shipping.service_id = 90)
              LEFT JOIN account ON (`order`.account_id = account.account_id)
              LEFT JOIN client ON (account.subject_id = client.client_id)
              LEFT JOIN client_relation_history ON (client.client_id = client_relation_history.child_client_id
              LEFT JOIN client parent_client ON (parent_client.client_id = IFNULL(client_relation_history.parent_client_id, client.client_id))
              LEFT JOIN contact parent_client_contact ON (parent_client.contact_id = parent_client_contact.contact_id)
              LEFT JOIN employee ON employee.user_id = parent_client.user_id
              LEFT JOIN contact office ON office.contact_id = employee.office_contact_id
              LEFT JOIN contact from_contact ON from_contact.contact_id = `order`.from_contact_id
              LEFT JOIN contact to_contact ON to_contact.contact_id = `order`.to_contact_id
              LEFT JOIN geo from_geo ON from_geo.geo_id = `order`.map_from_city_id
              LEFT JOIN geo to_geo ON to_geo.geo_id = `order`.map_to_city_id
              LEFT JOIN geo office_geo ON office_geo.geo_id = office.geo_id
 

новый хороший план 
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+
| id   | select_type | table                   | type   | possible_keys                                                                                                                                                                            | key                     | key_len | ref                             | rows  | r_rows   | filtered | r_filtered | Extra                                        |
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+
|    1 | SIMPLE      | order                   | ALL    | fk_order_service_id_idx,fk_order_category_id_idx,report_date_idx,giveout_date_service_status_idx,inactive_clients_idx,status_service_fin_result_date_idx,service_id,in_2,in_3,in_4,in_13 | NULL                    | NULL    | NULL                            | 20821 | 20821.00 |   100.00 |      19.13 | Using where; Using temporary; Using filesort |
|    1 | SIMPLE      | waybill                 | ref    | fk_waybill_order_id_idx,order_service_idx                                                                                                                                                | fk_waybill_order_id_idx | 4       | erp2.order.order_id             | 3     | 3.18     |   100.00 |     100.00 |                                              |
|    1 | SIMPLE      | parent_order            | eq_ref | PRIMARY,in_order_service,in_12                                                                                                                                                           | PRIMARY                 | 4       | erp2.order.parent_id            | 1     | 0.02     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | shipping                | ref    | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                                          | order_service_idx       | 8       | func,const                      | 1     | 1.00     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | account                 | eq_ref | PRIMARY                                                                                                                                                                                  | PRIMARY                 | 4       | erp2.order.account_id           | 1     | 1.00     |   100.00 |     100.00 |                                              |
|    1 | SIMPLE      | client                  | eq_ref | PRIMARY                                                                                                                                                                                  | PRIMARY                 | 4       | erp2.account.subject_id         | 1     | 1.00     |   100.00 |     100.00 | Using where; Using index                     |
|    1 | SIMPLE      | client_relation_history | ref    | PRIMARY,fk_client_relation_history_child_client_id_idx                                                                                                                                   | PRIMARY                 | 4       | erp2.client.client_id           | 1     | 0.00     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | parent_client           | eq_ref | PRIMARY,fk_client_user_id_idx                                                                                                                                                            | PRIMARY                 | 4       | func                            | 1     | 1.00     |   100.00 |      97.69 | Using where                                  |
|    1 | SIMPLE      | employee                | ref    | fk_employee_user_id_idx,fk_employee_office_contact_id_idx                                                                                                                                | fk_employee_user_id_idx | 5       | erp2.parent_client.user_id      | 1     | 1.00     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | office                  | eq_ref | PRIMARY,fk_contact_geo_id_idx                                                                                                                                                            | PRIMARY                 | 4       | erp2.employee.office_contact_id | 1     | 1.00     |    56.50 |      53.28 | Using where                                  |
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+



старый плохой план
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+-------------------------------------------------+
| id   | select_type | table                   | type   | possible_keys                                                                                                                                                                            | key                     | key_len | ref                             | rows  | Extra                                           |
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+-------------------------------------------------+
|    1 | SIMPLE      | employee                | ALL    | fk_employee_user_id_idx,fk_employee_office_contact_id_idx                                                                                                                                | NULL                    | NULL    | NULL                            | 182   | Using where; Using temporary; Using filesort    |
|    1 | SIMPLE      | office                  | eq_ref | PRIMARY,fk_contact_geo_id_idx                                                                                                                                                            | PRIMARY                 | 4       | erp2.employee.office_contact_id | 1     | Using where                                     |
|    1 | SIMPLE      | order                   | ALL    | fk_order_service_id_idx,fk_order_category_id_idx,report_date_idx,giveout_date_service_status_idx,inactive_clients_idx,status_service_fin_result_date_idx,service_id,in_2,in_3,in_4,in_13 | NULL                    | NULL    | NULL                            | 20821 | Using where; Using join buffer (flat, BNL join) |
|    1 | SIMPLE      | waybill                 | ref    | fk_waybill_order_id_idx,order_service_idx                                                                                                                                                | fk_waybill_order_id_idx | 4       | erp2.order.order_id             | 3     |                                                 |
|    1 | SIMPLE      | parent_order            | eq_ref | PRIMARY,in_order_service,in_12                                                                                                                                                           | PRIMARY                 | 4       | erp2.order.parent_id            | 1     | Using where                                     |
|    1 | SIMPLE      | shipping                | ref    | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                                          | order_service_idx       | 8       | func,const                      | 1     | Using where                                     |
|    1 | SIMPLE      | account                 | eq_ref | PRIMARY                                                                                                                                                                                  | PRIMARY                 | 4       | erp2.order.account_id           | 1     |                                                 |
|    1 | SIMPLE      | client                  | eq_ref | PRIMARY                                                                                                                                                                                  | PRIMARY                 | 4       | erp2.account.subject_id         | 1     | Using where; Using index                        |
|    1 | SIMPLE      | client_relation_history | ref    | PRIMARY,fk_client_relation_history_child_client_id_idx                                                                                                                                   | PRIMARY                 | 4       | erp2.client.client_id           | 1     | Using where                                     |
|    1 | SIMPLE      | parent_client           | eq_ref | PRIMARY,fk_client_user_id_idx                                                                                                                                                            | PRIMARY                 | 4       | func                            | 1     | Using where                                     |
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+-------------------------------------------------+



новый план
> source /root/mysql/03/orig-an.sql
+---------+---------------+----------+-------------+
| ym      | sum_debit     | volume   | realization |
+---------+---------------+----------+-------------+
| 2023-04 | 28189601.5400 | 8304.348 |     3394.56 |
+---------+---------------+----------+-------------+
1 row in set (0.659 sec)

старый план
> source /root/mysql/03/orig-an.sql
+---------+---------------+----------+-------------+
| ym      | sum_debit     | volume   | realization |
+---------+---------------+----------+-------------+
| 2023-04 | 28189601.5400 | 8304.348 |     3394.56 |
+---------+---------------+----------+-------------+
1 row in set (32.377 sec)




новый план
| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 650.1737211,
    "filesort": {
      "sort_key": "if(`order`.service_id = 1001790,date_format(`order`.report_date,'%Y-%m'),if(date_format(`order`.report_date,'%Y-%m') = date_format(`order`.giveout_date,'%Y-%m'),date_format(`order`.giveout_date,'%Y-%m'),if(date_format(`order`.giveout_date,'%d') <= if(date_format(`order`.giveout_date,'%c') = 1,15,10),date_format(`order`.giveout_date - interval 1 month,'%Y-%m'),date_format(`order`.giveout_date,'%Y-%m'))))",
      "r_loops": 1,
      "r_total_time_ms": 0.010820549,
      "r_used_priority_queue": false,
      "r_output_rows": 1,
      "r_buffer_size": "472",
      "r_sort_mode": "sort_key,rowid",







      "temporary_table": {
        "table": {
          "table_name": "order",
          "access_type": "ALL",
          "possible_keys": [
            "fk_order_service_id_idx",
            "fk_order_category_id_idx",
            "report_date_idx",
            "giveout_date_service_status_idx",
            "inactive_clients_idx",
            "status_service_fin_result_date_idx",
            "service_id",
            "in_2",
            "in_3",
            "in_4",
            "in_13"
          ],
          "r_loops": 1,
          "rows": 20821,
          "r_rows": 20821,
          "r_table_time_ms": 35.97328376,
          "r_other_time_ms": 37.04338319,
          "filtered": 100,
          "r_filtered": 19.13452764,
          "attached_condition": "`order`.`status` in ('store','sf','trip','dep_store','closed') and (`order`.service_id = 46 and (`order`.category_id not in (4177,4178,4179) or `order`.category_id is null) or `order`.service_id = 11662 or `order`.service_id = 333196 or `order`.service_id = 100 or `order`.service_id = 46 and `order`.category_id = 4177 or `order`.service_id = 46 and `order`.category_id = 4178 or `order`.service_id = 46 and `order`.category_id = 4179 or `order`.service_id = 1001790) and (`order`.service_id <> 1001790 and (`order`.report_date between '2023-04-01 00:00:00.000000' and '2023-04-30 23:59:59.000000' and `order`.giveout_date between '2023-04-01 00:00:00.000000' and '2023-05-10 23:59:59.000000' or `order`.report_date < '2023-04-01 00:00:00' and `order`.giveout_date between '2023-04-11 00:00:00.000000' and '2023-05-10 23:59:59.000000') or `order`.service_id = 1001790 and `order`.report_date between '2023-04-01 00:00:00.000000' and '2023-04-30 23:59:59.000000')"
        },



  из этого 
           "r_loops": 1,
           "r_rows": 20821,
видно чтоб это был select.
потмоу что только у него идет такая выборку тучи строк за 1 loop
строки выбирали без ирдекса потому что
            "access_type": "ALL",




        "table": {
          "table_name": "waybill",
          "access_type": "ref",
          "possible_keys": ["fk_waybill_order_id_idx", "order_service_idx"],
          "key": "fk_waybill_order_id_idx",
          "key_length": "4",
          "used_key_parts": ["order_id"],
          "ref": ["erp2.order.order_id"],
          "r_loops": 3984,
          "rows": 3,
          "r_rows": 3.177459839,
          "r_table_time_ms": 76.61924326,
          "r_other_time_ms": 65.93940162,
          "filtered": 100,
          "r_filtered": 100
        },


тут вроде тоже всеобычно





        "table": {
          "table_name": "parent_order",
          "access_type": "eq_ref",
          "possible_keys": ["PRIMARY", "in_order_service", "in_12"],
          "key": "PRIMARY",
          "key_length": "4",
          "used_key_parts": ["order_id"],
          "ref": ["erp2.order.parent_id"],
          "r_loops": 12662,
          "rows": 1,
          "r_rows": 0.024956563,
          "r_table_time_ms": 11.60759066,
          "r_other_time_ms": 10.29223212,
          "filtered": 100,
          "r_filtered": 100,
          "attached_condition": "trigcond(`order`.service_id = 46 and (`order`.category_id not in (4177,4178,4179) or `order`.category_id is null) or `order`.service_id = 11662 or `order`.service_id = 333196 or `order`.service_id = 100 or `order`.service_id = 46 and `order`.category_id = 4177 or `order`.service_id = 46 and `order`.category_id = 4178 or `order`.service_id = 46 and `order`.category_id = 4179 or `order`.service_id = 1001790 and (parent_order.service_id = 46 and (parent_order.category_id not in (4177,4178,4179) or parent_order.category_id is null) or parent_order.service_id = 11662 or parent_order.service_id = 333196 or parent_order.service_id = 100 or parent_order.service_id = 46 and parent_order.category_id = 4177 or parent_order.service_id = 46 and parent_order.category_id = 4178 or parent_order.service_id = 46 and parent_order.category_id = 4179)) and trigcond(trigcond(`order`.service_id = 1001790 and `order`.parent_id is not null))"
        },


тут все как обычно





        "table": {
          "table_name": "shipping",
          "access_type": "ref",
          "possible_keys": [
            "fk_waybill_order_id_idx",
            "fk_waybill_service_id_idx",
            "service_waybill_contact_idx",
            "order_service_idx"
          ],
          "key": "order_service_idx",
          "key_length": "8",
          "used_key_parts": ["order_id", "service_id"],
          "ref": ["func", "const"],
          "r_loops": 12645,
          "rows": 1,
          "r_rows": 1,
          "r_table_time_ms": 118.1388654,
          "r_other_time_ms": 17.2581996,
          "filtered": 100,
          "r_filtered": 100,
          "attached_condition": "trigcond(ifnull(parent_order.order_id,`order`.order_id) = shipping.order_id)"
        },

вот это непонятно
      "ref": ["func", "const"],


строчка для этго куска из скрипта
LEFT JOIN waybill shipping ON 
(IFNULL(parent_order.order_id, `order`.order_id) = shipping.order_id AND 
shipping.service_id = 90)

походу это все прясняет. тоесть из диска читаются строки котоыре  равны константе
и еще чтото связанное с фугкцией. а функцию мы видим IFNULL



        "table": {
          "table_name": "account",
          "access_type": "eq_ref",
          "possible_keys": ["PRIMARY"],
          "key": "PRIMARY",
          "key_length": "4",
          "used_key_parts": ["account_id"],
          "ref": ["erp2.order.account_id"],
          "r_loops": 12645,
          "rows": 1,
          "r_rows": 1,
          "r_table_time_ms": 15.51612031,
          "r_other_time_ms": 1.188380973,
          "filtered": 100,
          "r_filtered": 100
        },


аналогично тму что ниже





        "table": {
          "table_name": "client",
          "access_type": "eq_ref",
          "possible_keys": ["PRIMARY"],
          "key": "PRIMARY",
          "key_length": "4",
          "used_key_parts": ["client_id"],
          "ref": ["erp2.account.subject_id"],
          "r_loops": 12645,
          "rows": 1,
          "r_rows": 1,
          "r_table_time_ms": 36.14160058,
          "r_other_time_ms": 1.066939879,
          "filtered": 100,
          "r_filtered": 100,
          "attached_condition": "trigcond(trigcond(`account`.subject_id is not null))",
          "using_index": true
        },


таблца client
доступ по инедксу. столбец client_id
число выбранных считанных с дискс строк 12645*1, чиатли строки чтобы они были равны erp2.account.subject_id
прошло через фильтр where 100%



        "table": {
          "table_name": "client_relation_history",
          "access_type": "ref",
          "possible_keys": [
            "PRIMARY",
            "fk_client_relation_history_child_client_id_idx"
          ],
          "key": "PRIMARY",
          "key_length": "4",
          "used_key_parts": ["child_client_id"],
          "ref": ["erp2.client.client_id"],
          "r_loops": 12645,
          "rows": 1,
          "r_rows": 0.004349545,
          "r_table_time_ms": 36.26720175,
          "r_other_time_ms": 18.54786229,
          "filtered": 100,
          "r_filtered": 100,
          "attached_condition": "trigcond(client_relation_history.date_start <= cast(`order`.report_date as date) and (client_relation_history.date_end >= cast(`order`.report_date as date) or client_relation_history.date_end is null) and trigcond(`client`.client_id is not null))"
        },


все агалогично то  что ниже. 
но есть один интеренсный момент. строка
                     "r_rows": 0.004349545,
непонятно. как это ? за реквест было найдено меньше чем 1 строка?
что за хуйня?
скорей всего это значит вот что =>
                     "r_loops": 12645,
показывает сколько оббрашейний было к этой таблице. тоесть к ней обрашались 12545 раз.
каждый раз к ней обращаст спрашивая есть ли такая то строка как вот в этом столбце. 
тоесть брали строку из столбца erp2.client.client_id и искали ее в этой таблице. таких обращенйи было 12545.
ТАК ВОТ! в итоге берут то колчество строк которое было найдено и делят на то колчиество обращений которые сделали!
все таблицы ниже они показыают 
                     "r_rows": 1
это значит что при кажом обращении такая строка в этой табице была! поэтому срденее значение 1.
а в нашем случае дохрена было кейсов когда то что искали в нашей таблце нет!!! 
поэтому получается из 12545 случаев поиска только малая часть нашлас в нашей таблице. если 
тоеть r_rows вроде как полуается это средеен колчиество строк котрое было найдено отсносиельно числа запросов


правда тогда вобще нихуя епонятно вот из этого примера (отойду в строну)

> select * from t10 where id=399;
+-----+
| id  |
+-----+
| 399 |
+-----+


> analyze format=json select * from t10 where id=399;
| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.004862801,
    "table": {
      "table_name": "t10",
      "access_type": "const",
      "possible_keys": ["PRIMARY"],
      "key": "PRIMARY",
      "key_length": "4",
      "used_key_parts": ["id"],
      "ref": ["const"],
      "r_loops": 0,
      "rows": 1,
      "r_rows": null,
      "filtered": 100,
      "r_filtered": null,
      "using_index": true
    }
  }
} |


совренно непонятно как это интерпеттировать:

      "r_loops": 0,
      "rows": 1,
      "r_rows": null

ттпа небыло ниодного цикла поиска? 
и не было найдено ни одной строки? что за хуйня??!?!?

+------+-------------+-------+-------+---------------+---------+---------+-------+------+--------+----------+------------+-------------+
| id   | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | r_rows | filtered | r_filtered | Extra       |
+------+-------------+-------+-------+---------------+---------+---------+-------+------+--------+----------+------------+-------------+
|    1 | SIMPLE      | t10   | const | PRIMARY       | PRIMARY | 4       | const | 1    | NULL   |   100.00 |       NULL | Using index |
+------+-------------+-------+-------+---------------+---------+---------+-------+------+--------+----------+------------+-------------+
1 row in set (0.000 sec)


а вот этот пример выгдяит совершенно понянтно

> create table t4 (a int);


> select a from t4 where a=1;
+------+
| a    |
+------+
|    1 |
+------+

> analyze select a from t4 where a=1;
+------+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+-------------+
| id   | select_type | table | type | possible_keys | key  | key_len | ref  | rows | r_rows | filtered | r_filtered | Extra       |
+------+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+-------------+
|    1 | SIMPLE      | t4    | ALL  | NULL          | NULL | NULL    | NULL | 3    | 3.00   |   100.00 |      33.33 | Using where |
+------+-------------+-------+------+---------------+------+---------+------+------+--------+----------+------------+-------------+

> analyze format=json select a from t4 where a=1;
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ANALYZE                                                                                                                                                                                                                                                                                                                                                                                                            |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.031119746,
    "table": {
      "table_name": "t4",
      "access_type": "ALL",
      "r_loops": 1,
      "rows": 3,
      "r_rows": 3,
      "r_table_time_ms": 0.016627583,
      "r_other_time_ms": 0.007882531,
      "filtered": 100,
      "r_filtered": 33.33333333,
      "attached_condition": "t4.a = 1"
    }
  }
} |

тоеесть был 1 цикл поиска.
тип посика был full scan тоесть мы неискали строку которая удвловтвероряет какомуто 
условию мы прото брали любую строку.
было выбрано строк 3 штуки. 
получается число выбрарных строк = 3. количетсво поисковых циклов =1 
получаем r_rows = (общее число выбранных строк) \(количество цисклов поика) = 3\1 =3
совпдаает с

      "r_rows": 3,


что иентеересно что у нас есть два типа разнцых соверщенно процессов!
первый процесс это мы выбираем строки в память из таблицы. это назыается r_loop.
и выбранные стрроки идут в r_rows.
так вот а есть последбущая обработка выбранных строк. и это соврешенно другой процесс. отдеьный. 
и вот where он неприяенсят на стадии выборки строк из таблицы!!! хотя казалось бы что он должен быть там.
нихуя. where прмиенсят толкьо тогдк кода строки уже выбраны из диска и сидят в памти. и статиксикпо where
идет в соврщенно другое место

      "r_filtered": 33.33333333,
      "attached_condition": "t4.a = 1"

в строке attached_condition указыается условие  where. 
и сколко where отфильтровал из строк кторые лежали в буфере присыается в r_filtered  

тоесть подучаеся поразительная вещь. есть процесс чтения строк из диска в память. и на этой стадии where 
не прмиенсятеся.не участвует. какзлось бы надо уже при чтении строк учитыать where но нихуя. 
строки вначле читаются с диска в памяти. и колиество чтрок прочитанных идет в статиктику
     "r_loops":1
     "r_rows": 3,


а уже потом когда они оказалси в памтия. то к ним начаинается прмиенстьяс where.
и эта стиатсика идет в

      "r_filtered": 33.33333333,
      "attached_condition": "t4.a = 1"

причем r_rows это среднее колчство строк прочитанных за один цикл выборки . так получатеся.
берется общее число прочитанных строк и делится на число циклов выборки.



посмотрим на наш основной пример. на его план в формет таблицы

MariaDB [erp2]> source /root/mysql/03/2.sql
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+
| id   | select_type | table                   | type   | possible_keys                                                                                                                                                                            | key                     | key_len | ref                             | rows  | r_rows   | filtered | r_filtered | Extra                                        |
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+
|    1 | SIMPLE      | order                   | ALL    | fk_order_service_id_idx,fk_order_category_id_idx,report_date_idx,giveout_date_service_status_idx,inactive_clients_idx,status_service_fin_result_date_idx,service_id,in_2,in_3,in_4,in_13 | NULL                    | NULL    | NULL                            | 20821 | 20821.00 |   100.00 |      19.13 | Using where; Using temporary; Using filesort |
|    1 | SIMPLE      | waybill                 | ref    | fk_waybill_order_id_idx,order_service_idx                                                                                                                                                | fk_waybill_order_id_idx | 4       | erp2.order.order_id             | 3     | 3.18     |   100.00 |     100.00 |                                              |
|    1 | SIMPLE      | parent_order            | eq_ref | PRIMARY,in_order_service,in_12                                                                                                                                                           | PRIMARY                 | 4       | erp2.order.parent_id            | 1     | 0.02     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | shipping                | ref    | fk_waybill_order_id_idx,fk_waybill_service_id_idx,service_waybill_contact_idx,order_service_idx                                                                                          | order_service_idx       | 8       | func,const                      | 1     | 1.00     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | account                 | eq_ref | PRIMARY                                                                                                                                                                                  | PRIMARY                 | 4       | erp2.order.account_id           | 1     | 1.00     |   100.00 |     100.00 |                                              |
|    1 | SIMPLE      | client                  | eq_ref | PRIMARY                                                                                                                                                                                  | PRIMARY                 | 4       | erp2.account.subject_id         | 1     | 1.00     |   100.00 |     100.00 | Using where; Using index                     |
|    1 | SIMPLE      | client_relation_history | ref    | PRIMARY,fk_client_relation_history_child_client_id_idx                                                                                                                                   | PRIMARY                 | 4       | erp2.client.client_id           | 1     | 0.00     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | parent_client           | eq_ref | PRIMARY,fk_client_user_id_idx                                                                                                                                                            | PRIMARY                 | 4       | func                            | 1     | 1.00     |   100.00 |      97.69 | Using where                                  |
|    1 | SIMPLE      | employee                | ref    | fk_employee_user_id_idx,fk_employee_office_contact_id_idx                                                                                                                                | fk_employee_user_id_idx | 5       | erp2.parent_client.user_id      | 1     | 1.00     |   100.00 |     100.00 | Using where                                  |
|    1 | SIMPLE      | office                  | eq_ref | PRIMARY,fk_contact_geo_id_idx                                                                                                                                                            | PRIMARY                 | 4       | erp2.employee.office_contact_id | 1     | 1.00     |    56.50 |      53.28 | Using where                                  |
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+

а именно сроку с client_relation_history которая нас ввела вступор со своим непонятным
"r_rows": 0.004349545,



+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+
| id   | select_type | table                   | type   | possible_keys                                                                                                                                                                            | key                     | key_len | ref                             | rows  | r_rows   | filtered | r_filtered | Extra                                        |
+------+-------------+-------------------------+--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------+---------+---------------------------------+-------+----------+----------+------------+----------------------------------------------+
|    1 | SIMPLE      | client_relation_history | ref    | PRIMARY,fk_client_relation_history_child_client_id_idx                                                                                                                                   | PRIMARY                 | 4       | erp2.client.client_id           | 1     | 0.00     |   100.00 |     100.00 | Using where                                  |
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


значит мы видим что в табице r_rows вообще = 0.
тоесть в табличной форме analyze все округляет.

получается!!!! что r_rows это не общее число строк которые было прочитано на этом шаге. это полная хуйня!!
хуйняполнейшая суки бляди.    это срднее количество строк котрое было прочитано за 1 цикл r_loop!
вот что это такое!! а чтобы узнать общее число строк которое было считано надо знать r_loop 
и умножить его на r_rows ! вот суки. а в книгах пишут полную хуйню. 

еще раз сравним табличны вид analyze и его json вид

  "table": {
          "table_name": "client_relation_history",
          "access_type": "ref",
          "possible_keys": [
            "PRIMARY",
            "fk_client_relation_history_child_client_id_idx"
          ],
          "key": "PRIMARY",
          "key_length": "4",
          "used_key_parts": ["child_client_id"],
          "ref": ["erp2.client.client_id"],
          "r_loops": 12645,
          "rows": 1,
          "r_rows": 0.004349545,
          "r_table_time_ms": 36.26720175,
          "r_other_time_ms": 18.54786229,
          "filtered": 100,
          "r_filtered": 100,
          "attached_condition": "trigcond(client_relation_history.date_start <= cast(`order`.report_date as date) and (client_relation_history.date_end >= cast(`order`.report_date as date) or client_relation_history.date_end is null) and trigcond(`client`.client_id is not null))"
        },


    таблицный получается полная хуня. воще неинфомратциный.
    надо юзать толко json формат!!!


  теперь занчение r_rows и его загадноый вид когда он меньше 1 разгадан!



толкко еще остаются вопросы.  если where вобще неучитыася при считывании строк из диска.
то тогда по каким условиям строки считываются  с диска? непонятно зачем считывать сдиска бесолезные строки 
чтобы потом их уже в пмяти фильрвать по where если можно сразу учитыать where  при счтытвании с диска или из индекса.
а получается что когда делаем join и мускул ищет в таблице занчение на оснвое строки из первой таблицы то поемуто 
на этой стадии это учитыватся в при счиытании строк с таблицы. дебидизм какойто.


и еще остается вот эта загка

> analyze format=json select * from t10 where id=399;
| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.004862801,
    "table": {
      "table_name": "t10",
      "access_type": "const",
      "possible_keys": ["PRIMARY"],
      "key": "PRIMARY",
      "key_length": "4",
      "used_key_parts": ["id"],
      "ref": ["const"],
      "r_loops": 0,
      "rows": 1,
      "r_rows": null,
      "filtered": 100,
      "r_filtered": null,
      "using_index": true
    }
  }
} |

считываем по индексу. почему же тоода "r_loops" = 0
неонятно.
полчается что "r_rows": null, 
и сооствтеегнно r_loop * r_rows = nul * 0 = ?
тоесть типа хуй знает сколько строк было считано. а ведь тем не менее у нас была считана 1 строка из таблцы
непонятно нихуя сука.


тем не менее. все таки остаеимся при таком правиле что : если мы хотим узнать сколько строк
было считано из таблицы то 

общее число стчиатнынх строк = (r_loops) * (r_rows)

где r_loops количство  обращений к таблице
r_rows среднее значение числа строк считанных из таблицы за одно обращение !!!!  озуеть!!! ка к оги все запутали суки













вовзращаеимся к нащему примеру обратно:

        "table": {
          "table_name": "parent_client",
          "access_type": "eq_ref",
          "possible_keys": ["PRIMARY", "fk_client_user_id_idx"],
          "key": "PRIMARY",
          "key_length": "4",
          "used_key_parts": ["client_id"],
          "ref": ["func"],
          "r_loops": 12645,
          "rows": 1,
          "r_rows": 1,
          "r_table_time_ms": 22.04059886,
          "r_other_time_ms": 1.85290321,
          "filtered": 100,
          "r_filtered": 97.69078687,
          "attached_condition": "parent_client.client_id = ifnull(client_relation_history.parent_client_id,`client`.client_id) and parent_client.user_id is not null"
        },



все агалогично то  что ниже. 



        "table": {
          "table_name": "employee",
          "access_type": "ref",
          "possible_keys": [
            "fk_employee_user_id_idx",
            "fk_employee_office_contact_id_idx"
          ],
          "key": "fk_employee_user_id_idx",
          "key_length": "5",
          "used_key_parts": ["user_id"],
          "ref": ["erp2.parent_client.user_id"],
          "r_loops": 12353,
          "rows": 1,
          "r_rows": 1,
          "r_table_time_ms": 81.03471898,
          "r_other_time_ms": 48.89083086,
          "filtered": 100,
          "r_filtered": 100,
          "attached_condition": "employee.office_contact_id is not null"
        },



из таблицы "employee"            
              "table_name": "employee",

читали по ееному индексу
          "key": "fk_employee_user_id_idx",

который неUNIQUE.тоесть одному занчению в таблице есть нескоько
значений. поэтмуо указно не "eq_ref" а "ref"
          "access_type": "ref",

в индексе использовали вот этот столбик
          "used_key_parts": ["user_id"],

искали используя значение в столбике
          "ref": ["erp2.parent_client.user_id"],

количество таких поисков было 
          "r_loops": 12353,
неочен понятно но якобы каждый раз находили тлоько одну строку. 
          "r_rows": 1,
непоняното . а елси бы  в какойто раз нашли две строки . как бы они это обозначили?

также для найдденной строки применялос доп условие филтрации
          "attached_condition": "employee.office_contact_id is not null"

в итоге от надйенных 12353 строк было отфильтровано (тоесть скольв итоге прошло фильтр успешно) 100% строк
          "r_filtered": 100,






        "table": {
          "table_name": "office",
          "access_type": "eq_ref",
          "possible_keys": ["PRIMARY", "fk_contact_geo_id_idx"],
          "key": "PRIMARY",
          "key_length": "4",
          "used_key_parts": ["contact_id"],
          "ref": ["erp2.employee.office_contact_id"],
          "r_loops": 12353,
          "rows": 1,
          "r_rows": 1,
          "r_table_time_ms": 5.044910609,
          "r_other_time_ms": 9.659755703,
          "filtered": 56.49983978,
          "r_filtered": 53.28260342,
          "attached_condition": "office.geo_id in (558,593,21094450,150,35,36,615,634,638,149,21068127,43,633,21321624,596)"
          }



разбор этого куска:
строчка из плана:    LEFT JOIN contact office ON office.contact_id = employee.office_contact_id
перепишем строчку:    LEFT JOIN contact office ON employee.office_contact_id = office.contact_id 
левая таблица result set и столбик employee.office_contact_id
 правая таблица contact   и столбик contact_id
  вот и в плане написано сращиваем по столбцу  
    "ref": ["erp2.employee.office_contact_id"]



получается обарщались к таблцице "office"
"access_type": "eq_ref",  = означает что читали из нее по внешнему запрому. то есть снаружи приходило
значение которое надо ыло найти в этой табллице. также означает что в этой таблцие искали по уникалному индексу
это значит что на любое вхождение находилась только одна строка.
искали по индксу с именем "primary"
в этом индесе искали по столбику "contact_id"
"ref": ["erp2.employee.office_contact_id"], = значения которые искали приетали из столбика employee.office_contact_id
тоесть брали одну строку из employee.office_contact_id и ее искали в "office"
"r_loops": 12353, = число обрашений к этой таблце office при посике было 12353 раза. 
"r_rows": 1,  = каждый раз находиили только одну строку

таким образом было из этой таблицы найдено и выбрано 12353 строки
но это еще не конец

"attached_condition": "office.geo_id in (558,593,21094450,150,35,36,615,634,638,149,21068127,43,633,21321624,596)"  =
= помимо поиска строки совпадающей с заданынм значением из  employee.office_contact_id было еще наложено
доп условие коорое прписано в этой строке.
так вот всеэти  12353 строки оони прошли доп фильтрацию (тоесть до этого была выборка а еще была фильттрация)
и фильтррацию прошли только 53%  об этом написано здесь

"r_filtered": 53.28260342,


учттывая что мне быол сказано что план пищется по вермени снизу то что первое а сверху то что послденее
пока что получается как то наборот чтоли. 







      }
    }
  }
} |


LEFT JOIN waybill ON (`order`.order_id = waybill.order_id)
              LEFT JOIN `order` parent_order ON (`order`.parent_id = parent_order.order_id AND `order`.service_id = 1001790)
              LEFT JOIN waybill shipping ON (IFNULL(parent_order.order_id, `order`.order_id) = shipping.order_id AND shipping.service_id = 90)
              LEFT JOIN account ON (`order`.account_id = account.account_id)
              LEFT JOIN client ON (account.subject_id = client.client_id)
              LEFT JOIN client_relation_history ON (client.client_id = client_relation_history.child_client_id
              LEFT JOIN client parent_client ON (parent_client.client_id = IFNULL(client_relation_history.parent_client_id, client.client_id))
              LEFT JOIN contact parent_client_contact ON (parent_client.contact_id = parent_client_contact.contact_id)
              LEFT JOIN employee ON employee.user_id = parent_client.user_id
       
              LEFT JOIN contact from_contact ON from_contact.contact_id = `order`.from_contact_id
              LEFT JOIN contact to_contact ON to_contact.contact_id = `order`.to_contact_id
              LEFT JOIN geo from_geo ON from_geo.geo_id = `order`.map_from_city_id
              LEFT JOIN geo to_geo ON to_geo.geo_id = `order`.map_to_city_id
              LEFT JOIN geo office_geo ON office_geo.geo_id = office.geo_id


=====
| index  , rebuild indexes

как пеерстроить все индексы для задданной таблицы

> OPTIMIZE TABLE имя_табл

====
| INSERT

INSERT INTO person (first_name, last_name) VALUES ('John', 'Doe');
===
union

как он делается

(select)
union
(select)

вопрос как для этого реквеста псмотреть explain
а очень просто

explain 
(select)
union
(select)

===
|explain
|analyze

explain запрос = эта штука пишет нам план по которому будет действоать мускул. выполняется мгновенно
потому что сам запрос при этом не выполняется.

analyze запрос = исполняется запрос (поэтому работает медленно). и рисует по какому плану 
он действовал. и там еще подробности выполенения плана.


но в целом и то и другое это хуйня. надо юзать с ключом format=json
вот там уже реально подробности


MariaDB [db1]> select * from table_1 limit 1;
+---+------+
| a | b    |
+---+------+
| 5 | J    |
+---+------+
1 row in set (0.012 sec)

MariaDB [db1]> explain select * from table_1 limit 1;
+------+-------------+---------+------+---------------+------+---------+------+------+-------+
| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | Extra |
+------+-------------+---------+------+---------------+------+---------+------+------+-------+
|    1 | SIMPLE      | table_1 | ALL  | NULL          | NULL | NULL    | NULL | 25   |       |
+------+-------------+---------+------+---------------+------+---------+------+------+-------+
1 row in set (0.001 sec)

MariaDB [db1]> analyze select * from table_1 limit 1;
+------+-------------+---------+------+---------------+------+---------+------+------+--------+----------+------------+-------+
| id   | select_type | table   | type | possible_keys | key  | key_len | ref  | rows | r_rows | filtered | r_filtered | Extra |
+------+-------------+---------+------+---------------+------+---------+------+------+--------+----------+------------+-------+
|    1 | SIMPLE      | table_1 | ALL  | NULL          | NULL | NULL    | NULL | 25   | 1.00   |   100.00 |     100.00 |       |
+------+-------------+---------+------+---------------+------+---------+------+------+--------+----------+------------+-------+
1 row in set (0.001 sec)

MariaDB [db1]> explain format=json  select * from table_1 limit 1;
| {
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "table_1",
      "access_type": "ALL",
      "rows": 25,
      "filtered": 100
    }
  }
} |


MariaDB [db1]> analyze format=json  select * from table_1 limit 1;
                                                                                                                                                                                                                                                           |
| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.063087868,
    "table": {
      "table_name": "table_1",
      "access_type": "ALL",
      "r_loops": 1,
      "rows": 25,
      "r_rows": 1,
      "r_table_time_ms": 0.026666029,
      "r_other_time_ms": 0.018218721,
      "filtered": 100,
      "r_filtered": 100
    }
  }
} |


=================================================

размер таблиц в базе
упорядочивает по размеру таблиц

size table


>  SELECT table_schema as `DB`, table_name AS `Table`,
           ROUND(((data_length + index_length) / 1024 / 1024), 2) `Size (MB)`
           FROM information_schema.TABLES  
           WHERE table_schema="имя_базы"       
           ORDER BY (data_length + index_length) DESC

упорядвичоваем по имени таблиц

>  SELECT table_schema as `DB`, table_name AS `Table`,
           ROUND(((data_length + index_length) / 1024 / 1024), 2) `Size (MB)`
           FROM information_schema.TABLES  
           WHERE table_schema="имя_базы"       
           ORDER BY table_name

==========================================
| size 
| rows

посмотреть сколько строк в каждой таблице в базе. очень удобно

> SELECT table_name,TABLE_ROWS   FROM INFORMATION_SCHEMA.TABLES    WHERE TABLE_SCHEMA = 'db2' order by table_rows desc;


=====================================================


| analyze table

как для нескольких таблиц сразу

> analyze table t1,t2,t3 persistent for all

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

| TRIGGERS


КАК создать новый триггер на основе уже сущетвующего триггера.
дело в том что если была таблица и мы ее переименовали и после этого создали 
новую через команду

> create table new like old;
то новая таблица небудет содержать триггеров от старой. триггеры будут по прежнему 
прикреплены к старой.
как их перекрепить к новой неясно. поэтому выбрать путь такой что мы берем каждый триггер из старой 
таблрцы и создаем по аналогиии такой же новый.




таблицы которые я менял:

> show tables like "%old%";
+----------------------+
| Tables_in_db (%old%) |
+----------------------+
| clientold            |
| invoice_options_old  |
| oldorder             |
+----------------------+

====================================



список триггеров в таблице oldorder

> SHOW TRIGGERS WHERE `Table` = "oldorder"\G


*************************** 1. row ***************************
             Trigger: order_BINS
*************************** 2. row ***************************
             Trigger: order_BUPD
*************************** 3. row ***************************
             Trigger: order_AUPD


еще спмсок триггеров у таблицы можно посмтреть вот так
> SELECT      ACTION_STATEMENT
FROM        INFORMATION_SCHEMA.TRIGGERS
WHERE       TRIGGER_SCHEMA = 'Db_name'
AND         EVENT_OBJECT_TABLE = "table_name";

а еще можно получить вот так

> select event_object_schema as database_name,
       event_object_table as table_name,
       trigger_name,
       action_order,
       action_timing,
       event_manipulation as trigger_event,
       action_statement as 'definition'
from information_schema.triggers 
where trigger_schema not in ('sys','information_schema', 
                             'mysql', 'performance_schema')
order by database_name,
         table_name;




теперь узнаем какой командой создать каждый из них
> SHOW CREATE TRIGGER имя_триггреа



******************************order_BINS*************************************
> SHOW CREATE TRIGGER order_BINS \G

 CREATE DEFINER=`kompaniets`@`localhost` TRIGGER `order_BINS` BEFORE INSERT ON `oldorder` FOR EACH ROW BEGIN

        SET @need_set_title = (NEW.title = '');
        SET @need_set_from_city = (NEW.map_from_city_id IS NULL OR NOT NEW.map_from_city_id);
        SET @need_set_to_city = (NEW.map_to_city_id IS NULL OR NOT NEW.map_to_city_id);

        IF @need_set_title OR @need_set_from_city OR @need_set_to_city THEN


                SELECT

                        IF(map_virtual.to_geo_id = NEW.map_from_city_id,
                            NEW.map_from_city_id,
                                IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), geo.geo_id, cover_geo.geo_id)),

                        IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), IFNULL(geo.code, 'XXX'), IFNULL(cover_geo.code, 'XXX')),

                        geo.parent_id
                INTO
                        @map_from_city_id,
                        @code_from,
                        @from_country_id
                FROM contact
                        LEFT JOIN geo ON geo.geo_id = contact.geo_id
                        LEFT JOIN map ON map.to_geo_id = contact.geo_id AND map.`type` = 'coverage'
                        LEFT JOIN geo AS cover_geo ON cover_geo.geo_id = map.from_geo_id
                        LEFT JOIN map AS map_virtual ON map_virtual.from_geo_id = IFNULL(cover_geo.geo_id, contact.geo_id) AND map_virtual.`type` = 'virtual'
                WHERE contact.contact_id = IF(NEW.service_id = 717145, NEW.operation_storehouse_id, NEW.from_contact_id)
                GROUP BY contact.contact_id;


                SELECT

                        IF(map_virtual.to_geo_id = NEW.map_to_city_id,
                            NEW.map_to_city_id,
                            IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), geo.geo_id, cover_geo.geo_id)),

                        IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), IFNULL(geo.code, 'XXX'), IFNULL(cover_geo.code, 'XXX')),

                        geo.parent_id
                INTO
                        @map_to_city_id,
                        @code_to,
                        @to_country_id
                FROM contact
                        LEFT JOIN geo ON geo.geo_id = contact.geo_id
                        LEFT JOIN map ON map.to_geo_id = contact.geo_id AND map.`type` = 'coverage'
                        LEFT JOIN geo AS cover_geo ON cover_geo.geo_id = map.from_geo_id
                        LEFT JOIN map AS map_virtual ON map_virtual.from_geo_id = IFNULL(cover_geo.geo_id, contact.geo_id) AND map_virtual.`type` = 'virtual'
                WHERE contact.contact_id = IF(NEW.service_id = 717145, NEW.operation_storehouse_id, NEW.to_contact_id)
                GROUP BY contact.contact_id;


                IF @need_set_from_city THEN
                        SET NEW.map_from_city_id = @map_from_city_id;
                END IF;


                IF @need_set_to_city THEN
                        SET NEW.map_to_city_id = @map_to_city_id;
                END IF;


                IF @need_set_title THEN
                        INSERT INTO order_counter (id) VALUES (NULL);
                        IF NEW.service_id = 717145 THEN
                                SET NEW.title = CONCAT(@code_from, '-ОТВ-', LAST_INSERT_ID(), '/', DATE_FORMAT(CURRENT_TIMESTAMP, '%y'));
                        ELSEIF NEW.service_id = 1 THEN
                                SET NEW.title = CONCAT(@code_from, '-Х-', LAST_INSERT_ID(), '/', DATE_FORMAT(CURRENT_TIMESTAMP, '%y'));
                        ELSEIF NEW.service_id NOT IN (717145, 1) THEN
                                SET @country_prefix = IF(3152713 IN (@from_country_id, @to_country_id), 'KZ-', '');

                                SELECT contact_options.code
                                INTO @storehouse_code
                                FROM contact_options
                                WHERE contact_options.contact_id = NEW.giveout_storehouse_id;

                                SET NEW.title = CONCAT(
                                        @country_prefix, 
                                        @code_from, 
                                        '-',
                                        @code_to, 
                                        IF(@storehouse_code IS NOT NULL AND @storehouse_code != '', CONCAT('(', @storehouse_code, ')'), ''), 
                                        '-',
                                        LAST_INSERT_ID(),
                                        '/',
                                        DATE_FORMAT(CURRENT_TIMESTAMP, '%y')
                                );
                        END IF;
                END IF;

        END IF;

        IF NEW.main_account_id IS NULL OR NEW.main_account_id = '' THEN
                SET NEW.main_account_id = NEW.account_id;
        END IF;

END

******************************order_BINS*************************************


значит sql скрипт который создаст этот триггер будет несколько другой:

DELIMITER |
CREATE TRIGGER ...
...
BEGIN
...
END|
DELIMITER ;



тоесть


 $ cat order_BINS.sql 
DELIMITER |
CREATE DEFINER=`kompaniets`@`localhost` TRIGGER `order_BINS_1` BEFORE INSERT ON `order` FOR EACH ROW BEGIN

        SET @need_set_title = (NEW.title = '');
        SET @need_set_from_city = (NEW.map_from_city_id IS NULL OR NOT NEW.map_from_city_id);
        SET @need_set_to_city = (NEW.map_to_city_id IS NULL OR NOT NEW.map_to_city_id);

        IF @need_set_title OR @need_set_from_city OR @need_set_to_city THEN


                SELECT

                        IF(map_virtual.to_geo_id = NEW.map_from_city_id,
                            NEW.map_from_city_id,
                                IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), geo.geo_id, cover_geo.geo_id)),

                        IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), IFNULL(geo.code, 'XXX'), IFNULL(cover_geo.code, 'XXX')),

                        geo.parent_id
                INTO
                        @map_from_city_id,
                        @code_from,
                        @from_country_id
                FROM contact
                        LEFT JOIN geo ON geo.geo_id = contact.geo_id
                        LEFT JOIN map ON map.to_geo_id = contact.geo_id AND map.`type` = 'coverage'
                        LEFT JOIN geo AS cover_geo ON cover_geo.geo_id = map.from_geo_id
                        LEFT JOIN map AS map_virtual ON map_virtual.from_geo_id = IFNULL(cover_geo.geo_id, contact.geo_id) AND map_virtual.`type` = 'virtual'
                WHERE contact.contact_id = IF(NEW.service_id = 717145, NEW.operation_storehouse_id, NEW.from_contact_id)
                GROUP BY contact.contact_id;


                SELECT

                        IF(map_virtual.to_geo_id = NEW.map_to_city_id,
                            NEW.map_to_city_id,
                            IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), geo.geo_id, cover_geo.geo_id)),

                        IF(cover_geo.geo_id IS NULL OR NEW.service_id IN (1,717145), IFNULL(geo.code, 'XXX'), IFNULL(cover_geo.code, 'XXX')),

                        geo.parent_id
                INTO
                        @map_to_city_id,
                        @code_to,
                        @to_country_id
                FROM contact
                        LEFT JOIN geo ON geo.geo_id = contact.geo_id
                        LEFT JOIN map ON map.to_geo_id = contact.geo_id AND map.`type` = 'coverage'
                        LEFT JOIN geo AS cover_geo ON cover_geo.geo_id = map.from_geo_id
                        LEFT JOIN map AS map_virtual ON map_virtual.from_geo_id = IFNULL(cover_geo.geo_id, contact.geo_id) AND map_virtual.`type` = 'virtual'
                WHERE contact.contact_id = IF(NEW.service_id = 717145, NEW.operation_storehouse_id, NEW.to_contact_id)
                GROUP BY contact.contact_id;


                IF @need_set_from_city THEN
                        SET NEW.map_from_city_id = @map_from_city_id;
                END IF;


                IF @need_set_to_city THEN
                        SET NEW.map_to_city_id = @map_to_city_id;
                END IF;


                IF @need_set_title THEN
                        INSERT INTO order_counter (id) VALUES (NULL);
                        IF NEW.service_id = 717145 THEN
                                SET NEW.title = CONCAT(@code_from, '-ОТВ-', LAST_INSERT_ID(), '/', DATE_FORMAT(CURRENT_TIMESTAMP, '%y'));
                        ELSEIF NEW.service_id = 1 THEN
                                SET NEW.title = CONCAT(@code_from, '-Х-', LAST_INSERT_ID(), '/', DATE_FORMAT(CURRENT_TIMESTAMP, '%y'));
                        ELSEIF NEW.service_id NOT IN (717145, 1) THEN
                                SET @country_prefix = IF(3152713 IN (@from_country_id, @to_country_id), 'KZ-', '');

                                SELECT contact_options.code
                                INTO @storehouse_code
                                FROM contact_options
                                WHERE contact_options.contact_id = NEW.giveout_storehouse_id;

                                SET NEW.title = CONCAT(
                                        @country_prefix, 
                                        @code_from, 
                                        '-',
                                        @code_to, 
                                        IF(@storehouse_code IS NOT NULL AND @storehouse_code != '', CONCAT('(', @storehouse_code, ')'), ''), 
                                        '-',
                                        LAST_INSERT_ID(),
                                        '/',
                                        DATE_FORMAT(CURRENT_TIMESTAMP, '%y')
                                );
                        END IF;
                END IF;

        END IF;

        IF NEW.main_account_id IS NULL OR NEW.main_account_id = '' THEN
                SET NEW.main_account_id = NEW.account_id;
        END IF;

END|
DELIMITER ;


еще важно заметить что в рамках одной базы не может быть двух триггеров с одним именем. и неважно 
что они прикреплены к разным таблицам. поэтому если создаем триггер  на основе уже существуюзего 
триггггера то новый триггер должен иметь другое имя.



смотрим какие триггеры у таблицы clientold
MariaDB [db]> SHOW TRIGGERS WHERE `Table` = "clientold"\G
*************************** 1. row ***************************
             Trigger: create_client
*************************** 2. row ***************************
             Trigger: client_AUPD
*************************** 3. row ***************************
             Trigger: delete_client



@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@


| dump

$ mysqldump  -R -E --triggers --single-transaction имя_базы| gzip > /root/mysql/gd-site-db-fullbackup.sql.gz

-----------

| rename table

> RENAME TABLE old_table TO backup_table, new_table TO old_table;
----
| show

вот когда мы select делаем то мы можем выбирать where фильтр
а когда делаем show 
то такое мудачество что там  зависит от того что стоит за show
в 

> show processlist 
нельзя добавить where

 а вот в 

 > show triggers;
  можно

> show triggers where Timing like "AFTER"\G

===

| foreign key

если есть таблица как узнать все таблицы котрые ссылаются на эту таблицу через foregn key


SELECT 
  TABLE_NAME,COLUMN_NAME,CONSTRAINT_NAME, REFERENCED_TABLE_NAME,REFERENCED_COLUMN_NAME
FROM
  INFORMATION_SCHEMA.KEY_COLUMN_USAGE
WHERE
  REFERENCED_TABLE_SCHEMA = '<database>' AND
  REFERENCED_TABLE_NAME = '<table>';

===

| количество строк в таблице


способ мгновенный. но недает точный результат

> show table status like '<TABLE NAME>' \G

====

| JOIN


как работает join.
рассмотрим inner join. 

рассмотрим джоин двух таблицы



mysql> select count(*) from account_access;
+----------+
| count(*) |
+----------+
|      290 |
+----------+


mysql> select count(*) from bank_detail;
+----------+
| count(*) |
+----------+
|      626 |
+----------+



эти две таблицы имеют общий столбик. только он называтся по разному в каждой.

account_access (account_id)
bank_detail (identification_account_id)





как работает иннер джоин. он берет таблицу ту у которой меньше всего строк.
потом он читает с этой таблицы все строки (да да именно все строки читает), 
когда он уже прочитал все строки в память то он от них отбрасывет те строки в которых account_id = NULL
тут важно отметить что обрасывание происходит не на моменте считывания строк нет. все строки из таблицы
будут прочитана. а уже находясь в памяти от отбрасывает.  поэому если в таблице 1 0000 0000 строк то они будут все 
прочитаны в память. без этого никак.  после этого  берется каждая строка которая осталась а точнее берутся строки  в столбце
по которому идет срашивание (строка в столбце конечно же вырождается до ячейки)  и потом каждая ячейка ищется 
уже во второй таблице. 

положим у нас в первой таблице 100 строк а  во второй 200 строк.
значит читается 100 строк из первой таблицы в память. а потом берется первая ячейка в столбце account_id из 
этих 100 строк и ищется во второй таблице. если находится то ок результат пишется в резултирующую таблицу. потом берется
вторая ячейка из 100 строк и ищется во второй таблице и так 100 таких циклов.  отсюда понятно 
почему данные вначале читаются из той таблицв которая имеет меьше строк потому что  есть разница

считать 100 строк и потом  их искать во другой таблце
или считать 200 строк и потом их искать в другой таблице

поэтму в случае двух таблиц неважно какая с какой джойгится.  планировщик всегда будет  считывать ту в которой меньщше 
строк  а потом искать эьти строки во вторйо таблице.

посморим на анализ такго джоина


> analyze format=json select aa.account_id  from account_access aa  inner  join bank_detail  bd on ( aa.account_id = bd.identification_account_id );

| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.725095048,



    "table": {
      "table_name": "aa",
      "access_type": "index",
      "possible_keys": ["fk_account_access_account_id_idx"],
      "key": "fk_account_access_account_id_idx",
      "key_length": "5",
      "used_key_parts": ["account_id"],
      "r_loops": 1,
      "rows": 287,
      "r_rows": 290,
      "r_table_time_ms": 0.433329826,
      "r_other_time_ms": 0.078135736,
      "filtered": 100,
      "r_filtered": 16.20689655,
      "attached_condition": "aa.account_id is not null",
      "using_index": true
    },



    "table": {
      "table_name": "bd",
      "access_type": "ref",
      "possible_keys": ["fk_bank_detail_identification_account_id_idx"],
      "key": "fk_bank_detail_identification_account_id_idx",
      "key_length": "4",
      "used_key_parts": ["identification_account_id"],
      "ref": ["db.aa.account_id"],
      "r_loops": 47,
      "rows": 1,
      "r_rows": 0.021276596,
      "r_table_time_ms": 0.175520774,
      "r_other_time_ms": 0.012482651,
      "filtered": 100,
      "r_filtered": 100,
      "using_index": true
    }



  }
} |




план изложен. присутпаю к комментированию

 у нас одна account_access имеет 290 строк (смотри выше)
 а bank_detail 626 строк.
 поэтому ожидается что будет считаны 290 строк из account_aacccess
 и они будут искать уже в bank_detail





| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.725095048,



    "table": {
      "table_name": "aa",
      "access_type": "index",
      "possible_keys": ["fk_account_access_account_id_idx"],
      "key": "fk_account_access_account_id_idx",
      "key_length": "5",
      "used_key_parts": ["account_id"],
      "r_loops": 1,
      "rows": 287,
      "r_rows": 290,
      "r_table_time_ms": 0.433329826,
      "r_other_time_ms": 0.078135736,
      "filtered": 100,
      "r_filtered": 16.20689655,
      "attached_condition": "aa.account_id is not null",
      "using_index": true
    },


во первых отсюда видно  что в распечатке плана  то что делается первее идет сверху
а то что делается в последнюю очередь идет внизу.
значит в этом блоке написано что было обраение к таблице aa (account_access)
строки из нее читались по индексу, в индексе использовался для этого столббец account_id
в целом так как нам надо при джине прочитать все строки из таблицы в целом использование индекса вобщем то 
мало что дает. просто через индекс это будет чуть быстрее (почему хз).

"r_loops": 1,  = говорит о том что к таблице обращались всего 1 раз
"r_rows": 290, =  этот показатель r_rows сука это хитрая вещь.
везде пишут что это число строк которые было прочитано из таблицы суммарная. на самом деле это полная хуйня.
этот показатель показывает нечто совсем другое ( о чем я постоянно забываю ) он показывает сколько В СРЕДНЕМ 
за один цикл поиска было прочитано строк с диска. тоесть это величина не измеренная а высчитанная.
берется общее число прочитанных строк с диска (которые мы незнаем и нам его не говорят суки) и делят его 
на число циклов считыаения r_loops и это число уже нам рисуют в выводе.

поскольку r_loops=1 тоесть число цикловы считыания равно 1. и посольку на говорят что r_rows =290 
то 290 *1 = 290 строк было суммарно прочитано с диска. еще раз подчеркну что обшее число считанных строк 
с диска мы не взяли из r_rows а получили через "r_rows" * "r_loops"

двигаем дальше 290 общее число считанных строк совпдаает с размером таблицы и с теорией которую я изложил.

ужже после того как строки были прочитаны в память часть из них была отфилрованна обракована 
отброшена об этом говорит вот что 

"r_filtered": 16.20689655,  = говорит о том что из числа прочианны строк часть была отброшена и осталос только 16.2%


что прикольно. если "r_rows" показыает СРЕДНЕЕЕ АРИФМ ЧИСЛО считанных строк за цикл чтения
то количество строк прочитанных в ШТУКАХ
то "r_filtered" уже ни с каким циклами не связано и показыает абсолютное число причем в процентах
он показывает число осталвнных строк после применения фильтра в ПРОЦЕНТАХ ! тоесть после прмиенения фильтра
осталсь 16% от числа считанных строк.


"attached_condition": "aa.account_id is not null",    = это указано условие по котррому работал фильтр.
еще раз подчеркну что фильтр применяется не до того как строки прочитаны а только после того как они прочитаны
и уже сидят в памяти

получается что из 290 прочитанных строк те которые NOT NULL оказалось 16.2 процента это 47 строк 
в штуках.

получетс что r_* поазатели они имеют аболюто разные размерности величин. где это среднее
где то это процент. где то это абсолютное число. тоесть полный пиздец. реальнр. 



    "table": {
      "table_name": "bd",
      "access_type": "ref",
      "possible_keys": ["fk_bank_detail_identification_account_id_idx"],
      "key": "fk_bank_detail_identification_account_id_idx",
      "key_length": "4",
      "used_key_parts": ["identification_account_id"],
      "ref": ["db.aa.account_id"],
      "r_loops": 47,
      "rows": 1,
      "r_rows": 0.021276596,
      "r_table_time_ms": 0.175520774,
      "r_other_time_ms": 0.012482651,
      "filtered": 100,
      "r_filtered": 100,
      "using_index": true
    }


далее комп брал каждую из 47 строк и искал ее в таблице bd тоесть bank_detail.


"r_loops": 47,  = это говорит о том что к таблице обращалсиь 47 раз

"ref":    = это говорит о том что поиск в таблице велся на основе ячейки из другой таблицы.

"ref": ["db.aa.account_id"],  = это говорит о том что другая таблица это aa  = account_access у нее берется 
ячейка из столбца account_id и ее значение ищется в этой таблице. 

"r_rows": 0.021276596,  =  как я уже сказал выше то величина не измеряемая а калькулируемая.
берется общее число считанных строк   за все циклы r_loops и делится на число циклом r_loops
значит если умножим одно на другое мы узнаем сколько по факту строк суммарно было считано с диска 
 47 *  0.021276596 = 1  то получим что в итоге было счтана 1 одна строка.


так а какжет так велся то поиск. быо 47 запросов а считана тлоько одна строка. тоесть 
скажем берем первое число из первой таблицы из числа 47 строк. наример число 5 и ищем его во второй таблице.
это пошел первый цикл поиска. но как можно искать во второй таблице если нужно для этого прочитать все
строки из второй и потом уже в памяти сравнивать. но мы же видим что по факту была считана только одна строка  с диска.
ответ в том что можно искать значения в таблице в столбике если для этого столика есть индекс. таким образом 
можно сразу понять есть ли в столбице второй таблицы то или иное значение без считыания фактически столбцов второй
таблицы с диска. досаттчно посмтрет в индексе а индекс уже лежит в памяти. таким образом если бы 
индекс у столбца identification_account_id неыло бы индекса то r_rows был бы вот такой ==> число 
столбуов во второй таблице 626 делим на 47 циклов поиска тогда

626 : 47 = 13,319148936 тоесть  r_rows былбы

r_rows = 13,319148




итак поиск без считвания строк с диска возможен если у нас есть идекс для столбика.
поскльку мы знаем что 

"r_loops": 47,
"r_rows": 0.021276596,

то 47 * 0.021276596 = 1

тоесть в итоге было найдено было всего 1 совпдаение.

  }
} |


а теперт посмтрим чтоже выдал результата запроса

> select aa.account_id  from account_access aa  inner  join bank_detail  bd on ( aa.account_id = bd.identification_account_id );
+------------+
| account_id |
+------------+
|         87 |
+------------+


тоесь да . в обоих таблицах общая только одна строка.



тут возикает интетенсый вопрос . вот ут нас есть блок обрашения к таблице ( какойто там )




    "table": {
      "table_name": "bd",
      "access_type": "ref",
      "possible_keys": ["fk_bank_detail_identification_account_id_idx"],
      "key": "fk_bank_detail_identification_account_id_idx",
      "key_length": "4",
      "used_key_parts": ["identification_account_id"],
      "ref": ["db.aa.account_id"],
      "r_loops": 47,
      "rows": 1,
      "r_rows": 0.021276596,
      "r_table_time_ms": 0.175520774,
      "r_other_time_ms": 0.012482651,
      "filtered": 100,
      "r_filtered": 100,
      "using_index": true
    }


    и нам надо его деширофать.
нам был хотелоь понять это блок который вызыван чем select или join или еще чем.
и тут важный момент - select \ join и прочая хрень это лишь внешний скриптой язык фронтедовый к мускулу
а блоки из планера это уже работа внутренних механизом и хреновин мускула. суь в том что фротнтенд котманды
непонятно на какие внутренний блоки мускула распадаются. это важно понять.
тоесть условно говорят просто селект взоывает два таких блока а select joib вызовет 4 таких блока
и какой блок отнести к селекут а какой к джоину это еще хрнео поймешь. тоже самое как если полсать 1 человека
на базар для двух лиц. и сропсть сколько время он потратил на одного и надругого. как это вычитать если часть
оперций отноися к обоим лицам.

ясно только то что каждый блок это обращение к таблице точнее к той структуре которая  в памяти мускула отвечает за таблицу.
сама табица лежит на диске. это надо различать. так вот  при обрашении к струтурруре таблицы ищется некоторое значение
которео приелетло еще надо разбираться откуда и если у столбика есть индекс то поиск идет по инедксу которйы в памяти
и если есть совпдаение в индесе то только тогда идет считыание уже с диска где лежат данные таблицы. 

теоесть еще раз . такой блок показыает скольк было обращений (циклов)  к  памяти мускула где лежат метаданные 
от таблицы. если там быд нужнй индекс то им пользовались. при обращении обычно чтото ищут. если индекса нет
то тгда надо счтать в память все стоки с диска и уже там искать. если индекс есть то читать с диска ничо ненадо
можно искать в индексе который в памяти. также в этой секци будет написано то что искали. скажем
эта строчка "ref": ["db.aa.account_id"], говоит о том что искали некоторео значение которые взяли из столбка
account_id из таблицы account. тоемть блок говорит о том то чтото ищут по заказу от когото, если еть индекс
юзают его. если индекса нет читают все строки с длиска. если еть индекс и есть совпдание то толкь тогда чиают с диска.
поэтому если есть индекс то обращений может быть дохера (число циклов)  а считанных строк мало потому что если мало совппдений
то это вищно в индексе. и читаются только строки котоыре совпаои с поиском.


еще очень интеемный момент- что хранится в индексе? возмьем простой индекс для прмиера. когда у нас индкс по 
одному столбику и этот столбик это числа. хранятся ли эти числа прям в индексе. ответ да.
тогда српрашивается если мы нашли в таблице по индексу совпадеие для столбика то нахер нам читать при этом
эту строку ведь у нас в индексе записано значение которые мы искали. прикол в том что мы искали строчку целиком 
в которой ячейка по одному столбтку совпдаает с искомым значением.  тоест у нас есть строка в исходной базе
у котрой есть заданная ячейка мы ищем в другой таблице есть ли эта же ячейка в некотором столбец. индекс гвоорит что есть.
но нам то нужна не ячейка а нам нужна  строка из второй таблицы так что индекс хранит адрес на диске где 
лежит эта строка в томичисле содержащая эту ячейку. прикол в том что индекс нехранит строку целиком. он хранит
только одну ячейку из этой строки. поэтому найдя ячейку в индексе который  в памяти нам посде этого надо пойти на
диск и сделать считыание с диска этой строки.



как раобоатет inner join для трех таблиц. ну так то суть понятна. 
есть два вариант когда все три таблицы имеют аналогичный столбец  . тода понятно надо взять столбец этот в каждой таблице
и псмотреть где есть пересечение эьтих трех столбцов. скажем это строка 2 и 5. значит тогда берем
из трех таблиц строку номер 2 и слепить вместе все их столбики. 
тоже самое со строй 5. получим в итоге две строки но у новой таблицы будет дохера столбиков.
подчркну что строк будет всего две.  просто в них будет дохера столбиков. 



пример. три таблицы

mysql> select * from t1;
+------+------+
| a    | b    |
+------+------+
|    1 | a    |
|    2 | b    |
+------+------+

mysql> select * from t2;
+------+------+
| a    | c    |
+------+------+
|    1 | a    |
|    3 | q    |
+------+------+

mysql> select * from t3;
+------+------+
| a    | d    |
+------+------+
|    1 | a    |
|    4 | z    |
+------+------+


будем их соденияь по столбцу "a"
видно что по нему у нас тлоько одна общая строка - когда "a" =1.
значии в сумманой таблице будет 1 строка. но  у нее будет дрхера строблбцлов.
смотрим

mysql> select * from t1 inner join t2 on (t1.a=t2.a) inner join t3 on (t1.a=t3.a);
+------+------+------+------+------+------+
| a    | b    | a    | c    | a    | d    |
+------+------+------+------+------+------+
|    1 | a    |    1 | a    |    1 | a    |
+------+------+------+------+------+------+


как видим строчка одна . та где a=1.
а вот столбики прилеены со всех таблиц

таким образром inner join он число строк в суммарной таблице уменьшает а вот число столбцов 
жиреет в бока.

если у нас  три таблицы неимеют общего столбика то надо чтобы тогда была одна таблицы из трех у которой
есть по столбику из кажой оставшейся тоесть

a (id), b(id, vasya)  c(vasya)

вот такие три таблицы можно с джойнить.


вот такие три таблицы

mysql> select * from a;
+------+
| id   |
+------+
|    1 |
|    2 |
+------+

mysql> select * from b;
+------+-------+
| id   | vasya |
+------+-------+
|    1 | a     |
|    4 | z     |
+------+-------+

mysql> select * from c;
+-------+
| vasya |
+-------+
| a     |
| q     |
+-------+

mysql> select * from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);
+------+------+-------+-------+
| id   | id   | vasya | vasya |
+------+------+-------+-------+
|    1 |    1 | a     | a     |
+------+------+-------+-------+


получается что inner join он находит общие строки в том смысле что не вся строка совпдаает 
а только по заданному столбику в этой строке. то бишь в ячйке. а потом он берет каждую такую строку
из кажой таблицы и вместе их содеиняет горизонталтно. причем одинакоые столбцы по кторым он искал 
он их не схлопвает нет. они остаются каждй в своей позиции.

чтоб так как вверу название ятсолбиков сопвпадают то с непривычки как то это путает. поэтому пример полегче



mysql> select * from a1;
+------+
| id   |
+------+
|    1 |
|    2 |
+------+



mysql> select * from b1;
+------+-------+
| id_1 | vasya |
+------+-------+
|    1 | a     |
|    4 | z     |
+------+-------+


mysql> select * from c1;
+---------+
| vasya_1 |
+---------+
| a       |
| q       |
+---------+


> select * from  a1  inner join b1 on (a1.id=b1.id_1) inner join c1 on (b1.vasya=c1.vasya_1);
+------+------+-------+---------+
| id   | id_1 | vasya | vasya_1 |
+------+------+-------+---------+
|    1 |    1 | a     | a       |
+------+------+-------+---------+


суьт в том что ни один столбик ни из одной из таблиц непропадает . каждый войдет в 
сумманую таблицу.




это кстати обьясняет вот такую вещь.
беру этот пример


mysql> select * from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);
+------+------+-------+-------+
| id   | id   | vasya | vasya |
+------+------+-------+-------+
|    1 |    1 | a     | a     |
+------+------+-------+-------+


пробую сделать вот так
> select id  from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);
ERROR 1052 (23000): Column 'id' in field list is ambiguous


говори поше нахер

потому что он непонимает какой из id столбиков я хочу посмтреть.
потому что левый id отсноистя к исхоной табице "a" а правый id относистя к таблице b.
тогда делаем вот так

> select b.id  from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);
+------+
| id   |
+------+
|    1 |
+------+

и нет проблем!



итак джин трех таблиц



есть три таблицы



mysql> select count(*) from account_access;
+----------+
| count(*) |
+----------+
|      290 |
+----------+


mysql> select count(*) from bank_detail;
+----------+
| count(*) |
+----------+
|      626 |
+----------+





mysql> select count(*) from account;
+----------+
| count(*) |
+----------+
|    78385 |
+----------+


у них увсех есть общий столбик. он назыается  account_id либо identification_account_id

значит алсюолютно без разницы как мы пропием в реквесте запрос

SELECT account_id   
FROM  `account_access` aa  
INNER JOIN `account` a  ON ( aa.account_id = a.account_id ) 
INNER JOIN `bank_detail` bd  ON  ( aa.account_id = bd.identification_account_id );




SELECT account_id   
FROM  `account` a  
INNER JOIN `account_access` aa  ON (  a.account_id = aa.account_id ) 
INNER JOIN `bank_detail` bd     ON  ( a.account_id = bd.identification_account_id );




SELECT a.account_id   
FROM  `account` a  
INNER JOIN `account_access` aa  ON ( a.account_id = aa.account_id ) 
INNER JOIN `bank_detail` bd     ON ( a.account_id = bd.identification_account_id );

они все отработают по одному плану


а план будет такой. мускул найдет таблицу в которой менше вего строк . это account_access
далее как "aa".

он считет с диска все ее строки. справивтся нахера читать строки если значение accoun_id ячейки 
уже есь в индексе. ответ такой что мы сраивем не ячейки а в конечном итоге строки. так что 
нам надо чиать именно строки для всех таблиц ксати. просто первая чиатется целиком тоесть все строки. а другие будут чатться
только для для тех строк где еть совдпание . (еси бы небыло индеков то и там бы читались все строки).

потом берертся каждая строка точнее в этой стрке берется анчение ячейки в столбце account_id 
и далее идет обращение к одной из оставшихся таблиц. там по индексу ищется есть ли совдпание по этой ячейке.
еси ест то эта строка чиытается в память. если нет то ничего не счиытется с диска. (считется только индекс но он уже 
лежит в памяти).  таких циклов поика в воторой таблице будет ровно столкььо сколько строк в перво таблце минус 
ее строки с NULL. если у нас в таблице accunt_access 290 строк из них только 47 не NULL то во втоорой таблцие 
будет сделано 47 циклов поиска. в итоге мы полуичим какоето число строк которое сопвдпло между первой и второй таблцей
в ячейкках в стобце account_id .скажем таких строк 5.  после этого берется именн толко эти 5 строк . значение ячеекк 
в столблец acccount_id и именно они ищутся уже в треттьей таблице прием поо индексу этой третьек таблицы. 
поэтому при втоором поиске нам насрать на размер третьей таблцы ( при наличии в троетей таблице индекса) нам толко
важно солкьо строк у нас пресеклось между первой и второй. находится это прсечение . и это и есть ответ. 
точнее этоесть толко номер астрок. а потом уже с кажой таблицы буорется эти строки и их столбцы склеиваются.

таким оразом если у всех таблиц есть нужные индкексы тогда время  джоина завиаисит от того соклько строк 
есть в самой мелкоей таблице + сколько получиолось строк на пересечении первой и второй . а вотна размер троетьей таблицы
нам полностю пелвать хоть миллиард строк. главное повторю счто бы у всех атблицы были нужные индексы. 

 > select aa.account_id, a.account_id, bd.identification_account_id   from account_access aa  inner join bank_detail bd on ( aa.account_id = bd.identification_account_id ) inner join account a on (a.acco
+------------+------------+---------------------------+
| account_id | account_id | identification_account_id |
+------------+------------+---------------------------+
|         87 |         87 |                        87 |
+------------+------------+---------------------------+


план

| {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.781174374,


    "table": {
      "table_name": "aa",
      "access_type": "index",
      "possible_keys": ["fk_account_access_account_id_idx"],
      "key": "fk_account_access_account_id_idx",
      "key_length": "5",
      "used_key_parts": ["account_id"],
      "r_loops": 1,
      "rows": 287,
      "r_rows": 290,
      "r_table_time_ms": 0.443957572,
      "r_other_time_ms": 0.098981314,
      "filtered": 100,
      "r_filtered": 16.20689655,
      "attached_condition": "aa.account_id is not null and aa.account_id is not null",
      "using_index": true
    },

итак план читаем сверху вниз.
таблица aa была считана по индексу все ее строки. можно было бы читать и без индекса потмоу что 
строки то в индексе не хранися. а прочитать их надо все. таблица aa самая мелкая поэтому прочитали именно  ее.
прочитали за один цикл  "r_loops": 1,  срденее число прочиатлнных с диска строк "r_rows": 290, 
значит всего было прочиатно по факту 1 * 290  = 290 строк
из них после фиольтрации осталвсь "r_filtered": 16.20689655, всего 16% строк. это где то 47 строк.




    "table": {
      "table_name": "bd",
      "access_type": "ref",
      "possible_keys": ["fk_bank_detail_identification_account_id_idx"],
      "key": "fk_bank_detail_identification_account_id_idx",
      "key_length": "4",
      "used_key_parts": ["identification_account_id"],
      "ref": ["db.aa.account_id"],
      "r_loops": 47,
      "rows": 1,
      "r_rows": 0.021276596,
      "r_table_time_ms": 0.188911134,
      "r_other_time_ms": 0.013526627,
      "filtered": 100,
      "r_filtered": 100,
      "using_index": true
    },


далее мускул полез в таблицу bd . точнее не втаблицу а в свою память там где хранятся метаданные этой таблоицы.
лазил мускул 47 раз . тоесть ровно столько соклько строк мы выбрали и отфлиальтрвали из таблицы aa. "r_loops": 47,
при каждом обращении мы искали во такое значение "db.aa.account_id" это ячека в столбце account_id из таблицы aa
из числа тех 47 строк. по порядоку. искали мы эту ячейку по индексу. так как ячеки в индекса хранятся ( нестроки целиком
в индексе хрантся а ячейки ) то лазить на диск для этого нам ненадо. нам надо только если есть совпадение. 
для такого совдпадения мы строку уже будет чиатьт. видно что было 47 циклов поиска но среднее число прочитанных с диска
строк "r_rows": 0.021276596,  это ознчаает что совдападений было мало. инлекс показыает что такой ячейки у него в столбце
accoutnt_id нет. так скольк оже строк в иттге совпало ? ( "r_rows": 0.021276596,)  * ("r_loops": 47,) = 1
получем что совпала толко 1 строка. и она была прочитана. 
значит между aa таблцией и bd таблицей вышло толко 1 совпдаение. получается что теперь толкьо надо 
проверить есть ли эта строка в тртьей таблице




    "table": {
      "table_name": "a",
      "access_type": "eq_ref",
      "possible_keys": ["PRIMARY"],
      "key": "PRIMARY",
      "key_length": "4",
      "used_key_parts": ["account_id"],
      "ref": ["db.aa.account_id"],
      "r_loops": 1,
      "rows": 1,
      "r_rows": 1,
      "r_table_time_ms": 0.015809801,
      "r_other_time_ms": 0.005833914,
      "filtered": 100,
      "r_filtered": 100,
      "using_index": true
    }


видим что что мускула лазил в метаданые в своей памяти для третьей таблицв всего 1 раз.
"r_loops": 1,
потмоу что на прпдыддщем шаге всего 1 строка совпала. посольку наша результрующся таблица (result set) 
 спрдыдщуего шага уже содержит и все столбцы с перовй таблицы и все столбцы со второй таблицы то насне должна
 смущать строка  "ref": ["db.aa.account_id"], она говорит что запрос на поиск был из таблицы aa ее столбика account_id
 на самом деле был запрос из result set в котоором был этот стобик ( это еще один камень в дебильность разрабов мускула котоыре не могут рисовать наормальный понятный план.)
 итак был один цикл поиска "r_loops": 1  и срденее число найдыннех строк   и прочитынных "r_rows": 1,
 знаит в итоге было прочитанно 1 * 1  = 1 строка. 
 значит в финальном result set у нас всего 1 строка. что и выидно в ввыводе

 дебилизм ситации в том что получаетсы вот из этой записи

     "ref": ["db.aa.account_id"],

никдга нельзя понять из какой таблицы на самом деле шел реквест  в эту таблицу. мы толкьо знаем 
типа столбик а вот откуда он прилеел хуй занет толи из таблицы aa то ли из result set.



  }
} |



на десерт план того как выполнлся джоин трех таблиц
у которыех нет единого общего столбика

> analyze format=json select *  from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);



mysql> select * from a;
+------+
| id   |
+------+
|    1 |
|    2 |
+------+

mysql> select * from b;
+------+-------+
| id   | vasya |
+------+-------+
|    1 | a     |
|    4 | z     |
+------+-------+

mysql> select * from c;
+-------+
| vasya |
+-------+
| a     |
| q     |
+-------+
2 rows in set (0,00 sec)



получается у нас есть центральяна таблица


+------+-------+
| id   | vasya |
+------+-------+
|    1 | a     |
|    4 | z     |
+------+-------+


левый ее строблбик есть в левой таблице
а правй ее стобик есть в правой 


получается что только такая строка из b попадет в финальный расклад когда левое занчение есть в леовой табице
и одновеменно с этим ее правое занчение еть в правой таблице тоесть

берем строку


+------+-------+
| id   | vasya |
+------+-------+
|    1 | a     |
-----------------


если в левой таблице есть 1 а в правой таблице есть a одновременно с этим то такая строка 
точно входит уже в финашльный результат.



щас нарисую более прикольный пример

+-------+--------------+---------+
|table a|     table b  | table c |
+-------+------+------+----------+
|id_a   | id   | vasya|  kuku    |
+-------+------+------+----------+
|   1   |   1  | a    | a        |
|   6   |   4  | z    | f        |
|   9   |   5  | q    | g        |
+------+-------+-----------------+

и вот видно что только строка 


+------+-------+
| id   | vasya |
+------+-------+
|    1 | a     |
-----------------

из таблицы b имеет и слева такую цифру и справ такую же букву
осталные нет. 

я все пытаюсь на айти аналогию логики склейки трех таблицы кода у нас нет едтного столблца на все
три таблицы. аналогия получается такая по мне что у нас как бутто все равно есть некий универсальный единый столюик
на три таблицы


+--------------+
|     table b  |
+------+-------+
| id   | vasya | 
+-------+------+
| a    | a     |
|   4  | z     | 
|   5  | q     |
+-------+------+


 унас как бы получается что наш столбик он имеет две кодировки . и что средня таблица как раз владеет
 этим ключом пперекодровки 


для леов йтаблицы у нас стробик это 


|   a  | 
|   4  |  
|   5  |
+-------+



для правйо это столбик


| a     |
| z     | 
| q     |
+------+

но на саоммо деле это как бы один и тот же столбик только он перекодирован.

тоесь как бы можно взять 

| a     |
| z     | 
| q     |
+------+


перекодировать его в столбик



|   a  | 
|   4  |  
|   5  |
+-------+

вставить  в правую таблицу и у нас как бы получается три таблицы с единым столбиком на все три таблицы.
просто еще раз хочу сказать что у нас какбы в самой праваой таблице наш стобик перекодирован . 
тоесть условно говоря в двух таблцах у нас английские буквы в этом столбике а в правом русские. 
ну и мы как бы понимаем о чем идет речь. 

поэтому врроде как  в целом я понял физ смысл сращивания трез таблиц когда  у них фрмально нет 
единого столбтка

тость еще раз . кога сращивам три таблицы у которых формлаьно получается есть две табицы у которые общий столбик
а в третьей таблице его нет. но он там как бы есть просто он записан в перекодированной форме. 
и тогда заача сводится к сращиванию трех таблиц по единому столбику


+-------+--------------+---------+
|table a|     table b  | table c |
+-------+------+------+----------+
|id_a   | id   | vasya|  kuku    |
+-------+------+------+----------+
|   1   |   1  | a    | a        |
|   6   |   4  | z    | f        |
|   9   |   5  | q    | g        |
+------+-------+-----------------+

оесть если мы примем как основной столбик с цифрами


1
4
5

то тогда перая и вторая таблица имеют этот единый стобик а третья как бы нет.
но исползуя вторую таблицу как правило перекодирования мы можем сказать что  a в третьей 
таблице это как бы 1 ну и остальные буквы по аналогии. поэтому третья таблица как бы тожеимеет 
этот же столбик

поэтмоу иполучсется что из табицы b водут только те строки для котоых и слева  и справа однвоеменнно 
есть такой же ключ.

тоесть скаже мвозьмеп трутью строку из b = (5, q)
чтбы эта строка вошла в фигальное ршение нао чтобы в таблице слева было 5 в какойто строке  ( мы помнимчто строки 
неимеют номеров их можно тасовать как кубик рубик) и чтобы в стаблице права было в какойто строке q.
тоода это будет подхдядщая стрчка.



щас я нарисую джоин для 5 таблиц в которых нет единого столбика для всех одинкоговоо.
 и сразу станет все понятнро



+-------+-------------+----------+---------+---------+----------------+
|table a|     table b |       table c      | table d | table e        |
+-------+------+------+----------+---------+---------+--------+-------+
|id_a   | id_b | ch_b |  ch_c    |  id_c   | id_d    |  id_e  | ch_e  |
+-------+------+------+----------+---------+---------+--------+-------+
|   1   |   1  | a    | a        |  6      |  6      |  6     |  s    |
|   6   |   4  | z    | f        |  9      |  8      |  9     |  q    |
|   9   |   5  | q    | g        |  12     |  15     |  8     |  w    |
+------+-------+-----------------+---------+---------+--------+-------+


вот у нас 5 таблиц.


в иттогу у нас только одна верхняя строка будет в финальном result set
а джони будет выглядеть вотак


select * 
from  table_a a
inner join table_b b ( a.id_a = b.id_b)
inner join table_c c ( b.ch_b = c.ch_c)
inner join table_d d ( c.id_c = d.id_d)
inner join table_e e ( d.id_d = e.id_e)


строка которая в итоге попадет в финальрый result set  ее ячейки должны удоляеть условию

 ( a.id_a = b.id_b) AND ( b.ch_b = c.ch_c) AND ( c.id_c = d.id_d) AND ( d.id_d = e.id_e)

кода у нас  3 табицы и единый столбик то это вырождается в 

 ( a.id_a = b.id_b) AND ( b.id_b = c.id_c)

или это вырождается в

 ( a.id_a = b.id_b = c.id_c)



возвращаемся к примеру. 
резултатт
> select *  from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);
+------+------+-------+-------+
| id   | id   | vasya | vasya |
+------+------+-------+-------+
|    1 |    1 | a     | a     |
+------+------+-------+-------+


план
> explain  select *  from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);
+------+-------------+-------+-------+---------------+------+---------+------+------+--------------------------------------------------------+
| id   | select_type | table | type  | possible_keys | key  | key_len | ref  | rows | Extra                                                  |
+------+-------------+-------+-------+---------------+------+---------+------+------+--------------------------------------------------------+
|    1 | SIMPLE      | a     | index | i_1           | i_1  | 5       | NULL | 2    | Using index                                            |
|    1 | SIMPLE      | c     | index | i_4           | i_4  | 2       | NULL | 2    | Using index; Using join buffer (flat, BNL join)        |
|    1 | SIMPLE      | b     | ALL   | i_2,i_3       | NULL | NULL    | NULL | 2    | Using where; Using join buffer (incremental, BNL join) |
+------+-------------+-------+-------+---------------+------+---------+------+------+--------------------------------------------------------+



анализ
> analyze format=json select *  from  a  inner join b on (a.id=b.id) inner join c on (b.vasya=c.vasya);

 {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.103712296,


    "table": {
      "table_name": "a",
      "access_type": "ALL",
      "r_loops": 1,
      "rows": 2,
      "r_rows": 2,
      "r_table_time_ms": 0.031632395,
      "r_other_time_ms": 0.009065398,
      "filtered": 100,
      "r_filtered": 100
    },

 у нас счиались все строки из табл а

    "block-nl-join": {
      "table": {
        "table_name": "b",
        "access_type": "ALL",
        "r_loops": 1,
        "rows": 2,
        "r_rows": 2,
        "r_table_time_ms": 0.008337341,
        "r_other_time_ms": 0.010043743,
        "filtered": 100,
        "r_filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "65",
      "join_type": "BNL",
      "attached_condition": "b.`id` = a.`id`",
      "r_filtered": 25
    },


считались все строки из таблицы b 
и они с помощью спец буфера начали сверяться
и после  отфильтрования осталось  25%
прчим видно что сравагивалась табл а и табл б


    "block-nl-join": {
      "table": {
        "table_name": "c",
        "access_type": "ALL",
        "r_loops": 1,
        "rows": 2,
        "r_rows": 2,
        "r_table_time_ms": 0.006218244,
        "r_other_time_ms": 0.025134386,
        "filtered": 100,
        "r_filtered": 100
      },
      "buffer_type": "incremental",
      "buffer_size": "130",
      "join_type": "BNL",
      "attached_condition": "c.vasya = b.vasya",
      "r_filtered": 50
    }

а здесь срванивалас таблица "c" с табицей b

  }
} |

непоняно а где описано как сверялся потом первый resul set со вторым result set


поле этого я создал все нужыне индексы и вот как изменился план 
этгого же запроса



 {
  "query_block": {
    "select_id": 1,
    "r_loops": 1,
    "r_total_time_ms": 0.097440657,



    "table": {
      "table_name": "a",
      "access_type": "index",
      "possible_keys": ["i_1"],
      "key": "i_1",
      "key_length": "5",
      "used_key_parts": ["id"],
      "r_loops": 1,
      "rows": 2,
      "r_rows": 2,
      "r_table_time_ms": 0.024974202,
      "r_other_time_ms": 0.009869654,
      "filtered": 100,
      "r_filtered": 100,
      "using_index": true
    },


счиаталист все строки из a

    "block-nl-join": {
      "table": {
        "table_name": "c",
        "access_type": "index",
        "possible_keys": ["i_4"],
        "key": "i_4",
        "key_length": "2",
        "used_key_parts": ["vasya"],
        "r_loops": 1,
        "rows": 2,
        "r_rows": 2,
        "r_table_time_ms": 0.007138188,
        "r_other_time_ms": 0.009558186,
        "filtered": 100,
        "r_filtered": 100,
        "using_index": true
      },
      "buffer_type": "flat",
      "buffer_size": "65",
      "join_type": "BNL",
      "r_filtered": 100
    },


получается что из c тоже были считаны все строки. это пздц
потому что    ( "r_rows": 2,)  *    ( "r_loops": 1,) = 2
и     "r_filtered": 100 

тоесть из трех таблиц "a" и "c" были прочитаны целиком

    "block-nl-join": {
      "table": {
        "table_name": "b",
        "access_type": "ALL",
        "possible_keys": ["i_2", "i_3"],
        "r_loops": 1,
        "rows": 2,
        "r_rows": 2,
        "r_table_time_ms": 0.009428037,
        "r_other_time_ms": 0.026085477,
        "filtered": 100,
        "r_filtered": 100
      },
      "buffer_type": "incremental",
      "buffer_size": "76",
      "join_type": "BNL",
      "attached_condition": "b.vasya = c.vasya and b.`id` = a.`id`",
      "r_filtered": 12.5
 

наскольо я понимаю и третья талица была прочитана  в память целиком!

и вот наконец то чудо

      "attached_condition": "b.vasya = c.vasya and b.`id` = a.`id`",
      "r_filtered": 12.5
 

    }
  }


по мне если мы сравнивем "b" с "c"  и "a" с "c" 
 тогда надо быол читать одну таблицу b целиком.
а с другими сравнвать по ингдексам. это же сука корочео по времени !
нашли бы слева result set и справа result set и потом его уже бы сравнили 
методом перебора.
либо статитика плана неполная. либо алгоритм дебилный. он полностью закачивает 
внурь себя три таблицы


надо потсмртеь еще раз на трех больших по размеру таблицах . он там тоже все три 
будет  в себя засасыавть ?


ВНИМАНИЕ ! очент важная инфо про joins

если мы хотим чтобы у нас джоин двух таблиц ( для простоты двух а так дейвтуеи и на боьльшее число)
выполнятся по индексам а не чтобы в плане было написано ужасный приговор BNL LOOOP который очень долгий
то требования минимальные для двух таблиц такие:

надо чтобы в обоих таблицах был создан индекс по тому столбику по которому мы джойнимся
и надо чтобы в двух таблицах был PRIMARY ключ причем неважно что этот ключ относится к столбику по которому
мы джойнимся или к какотому то леовму столбику.  либо вместо primary ключа надо чтобы для какойтого столбика
было сразу два условия в свойствах столбика укзано NOT NULL + для этго столбика создан UNIQUE KEY.
тогда джоин для этих таблиц будет идти без записи BNL в планере. 

пример.




create table ab1 ( 
                   a int,
                   b int,
                   key b (`b`)
                  ) engine=innodb;



create table ab2 (
                   a int NOT NULL,
                   b int,
                   unique key a (`a`),
                   key b (`b`)
                  ) engine=innodb;



explain  
SELECT * 
FROM ab1   
INNER JOIN ab2   
    ON (ab1.b = ab2.b);



explain  format=json
SELECT * 
FROM ab1   
INNER JOIN ab2   
    ON (ab1.b = ab2.b);


drop table ab1, ab2;



+------+-------------+-------+------+---------------+------+---------+-----------+------+-------------+
| id   | select_type | table | type | possible_keys | key  | key_len | ref       | rows | Extra       |
+------+-------------+-------+------+---------------+------+---------+-----------+------+-------------+
|    1 | SIMPLE      | ab1   | ALL  | b             | NULL | NULL    | NULL      | 1    | Using where |
|    1 | SIMPLE      | ab2   | ref  | b             | b    | 5       | db2.ab1.b | 1    | Using index |
+------+-------------+-------+------+---------------+------+---------+-----------+------+-------------+
                                                                                                                                                                                                                                                                                                                                                                                                    |


| {
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "ab1",
      "access_type": "ALL",
      "possible_keys": ["b"],
      "rows": 1,
      "filtered": 100,
      "attached_condition": "ab1.b is not null"
    },
    "table": {
      "table_name": "ab2",
      "access_type": "ref",
      "possible_keys": ["b"],
      "key": "b",
      "key_length": "5",
      "used_key_parts": ["b"],
      "ref": ["db2.ab1.b"],
      "rows": 1,
      "filtered": 100,
      "using_index": true
    }
  }
} |



в этом римере таблица ab2 имеет солбика "a" котоыйр NOT NULL
и для него также пропмсано UNIQUE key.


причем мы джойнимяс не по столбтку "a" а по дргому столбку.


выще я написао что обе таблицы должны тметь условия . на самом деле только одна. вторая таблица в планере.
вторая таблица этобоычно таблица у которой меньше строк. вобщем чтобы недумать лучше чтобы уловие было в обоих таблицах.
тогда все чик пибабум.



===

|query
| запрос

был запрос

analyze format=json

    (
                         SELECT account.subject_id AS client_id
                         FROM account
                         WHERE 1 
                            AND account.type_id = 21
                            AND account.account_id IN (
                                   SELECT DISTINCT `order`.account_id
                                   FROM storage
                                       LEFT JOIN cargo USING (cargo_id)
                                       LEFT JOIN `order` USING (order_id)
                                   WHERE `order`.account_id IN (SELECT account.account_id
                     FROM client
                     LEFT JOIN account ON (account.subject_id = client.client_id)
                     LEFT JOIN employee curator ON (curator.user_id = client.user_id)
                            LEFT JOIN contact curator_office ON (curator_office.contact_id = curator.office_contact_id) 
                     WHERE 1
                         AND client.is_collecting = 0
                          AND account.type_id = 21
                          AND curator_office.geo_id = 35)
                                       AND !`order`.no_invoice
                                       AND `order`.status = 'closed'
                                       AND GREATEST(
                                          CAST(`storage`.amount_start_total AS SIGNED),
                                          (
                                              CAST(`storage`.amount_start_total AS SIGNED)
                                              + CAST(`storage`.amount_in AS SIGNED)
                                              - CAST(`storage`.amount_out AS SIGNED)
                                          )
                                       ) > CAST(`storage`.amount_draw AS SIGNED)
                            )
                     )
                     UNION DISTINCT
                     (
                         SELECT account.subject_id AS client_id
                         FROM account
                         WHERE 1 
                            AND account.type_id = 21
                            AND account.account_id IN (
                                   SELECT DISTINCT `order`.account_id
                                   FROM storage_service
                                       LEFT JOIN waybill USING (waybill_id)
                                       LEFT JOIN `order` USING (order_id)
                                   WHERE `order`.account_id IN (SELECT account.account_id
                     FROM client
                     LEFT JOIN account ON (account.subject_id = client.client_id)
                     LEFT JOIN employee curator ON (curator.user_id = client.user_id)
                            LEFT JOIN contact curator_office ON (curator_office.contact_id = curator.office_contact_id) 
                     WHERE 1
                         AND client.is_collecting = 0
                          AND account.type_id = 21
                          AND curator_office.geo_id = 35)
                                       AND !`order`.no_invoice
                                   GROUP BY IFNULL(waybill.parent_waybill_id, waybill.waybill_id)
                                   HAVING SUM(storage_service.amount) > 0
                            )
                     )



выпонлнялся 17 минут


ускорил запрос  стало (15с)
как ускорил:
 - обрезал `order`
 - исправил query вот так:
     -  создал индекс  ( > create index in_cust_1 on `order` (no_invoice,status); )
     - и вставил FORCE INDEX (in_cust_1)
тоесть было
       LEFT JOIN `order`  USING (order_id)
стало
       LEFT JOIN `order` FORCE INDEX (in_cust_1) USING (order_id)






новый кьюри:
explain   format=json
    (
                SELECT account.subject_id AS client_id
                FROM account
                WHERE 1 
                AND account.type_id = 21
                AND account.account_id IN (
                    SELECT DISTINCT `order`.account_id
                    FROM storage
                        LEFT JOIN cargo USING (cargo_id)
                        LEFT JOIN `order` FORCE INDEX (in_cust_1) USING (order_id)
                    WHERE `order`.account_id IN (SELECT account.account_id
            FROM client
            LEFT JOIN account ON (account.subject_id = client.client_id)
            LEFT JOIN employee curator ON (curator.user_id = client.user_id)
                LEFT JOIN contact curator_office ON (curator_office.contact_id = curator.office_contact_id) 
            WHERE 1
                AND client.is_collecting = 0
                    AND account.type_id = 21
                 AND curator_office.geo_id = 35)
                        AND !`order`.no_invoice
                        AND `order`.status = 'closed'
                        AND GREATEST(
                        CAST(`storage`.amount_start_total AS SIGNED),
                        (
                            CAST(`storage`.amount_start_total AS SIGNED)
                            + CAST(`storage`.amount_in AS SIGNED)
                            - CAST(`storage`.amount_out AS SIGNED)
                        )
                        ) > CAST(`storage`.amount_draw AS SIGNED)
                )
            )
            UNION DISTINCT
            (
                SELECT account.subject_id AS client_id
                FROM account
                WHERE 1 
                AND account.type_id = 21
                AND account.account_id IN (
                    SELECT DISTINCT `order`.account_id
                    FROM storage_service
                        LEFT JOIN waybill USING (waybill_id)
                        LEFT JOIN `order` USING (order_id)
                    WHERE `order`.account_id IN (SELECT account.account_id
            FROM client
            LEFT JOIN account ON (account.subject_id = client.client_id)
            LEFT JOIN employee curator ON (curator.user_id = client.user_id)
                LEFT JOIN contact curator_office ON (curator_office.contact_id = curator.office_contact_id) 
            WHERE 1
                AND client.is_collecting = 0
                    AND account.type_id = 21
                 AND curator_office.geo_id = 35)
                        AND !`order`.no_invoice
                    GROUP BY IFNULL(waybill.parent_waybill_id, waybill.waybill_id)
                    HAVING SUM(storage_service.amount) > 0
                )
            )



до изменений кусок из плана выглядел так

"table": {
                "table_name": "order",
                "access_type": "ref",
                "possible_keys": [
                  "PRIMARY",
                  "fk_order_account_id_idx",
                  "orders_to_draw_idx",
                  "inactive_clients_idx",
                  "status_service_fin_result_date_idx"
                ],
                "key": "fk_order_account_id_idx",
                "key_length": "4",
                "used_key_parts": ["account_id"],
                "ref": ["newlove.account.account_id"],
                "r_loops": 28784,
                "rows": 20,
                "r_rows": 97.487,
                "r_total_time_ms": 32421,
                "filtered": 100,
                "r_filtered": 43.445,
                "attached_condition": "((`order`.no_invoice = 0) and (`order`.`status` = 'closed'))"
              },


после измеений кусок из плана выглядел уже вот  так



       "table": {
                "table_name": "order",
                "access_type": "eq_ref",
                "possible_keys": ["in_cust_1"],
                "key": "in_cust_1",
                "key_length": "6",
                "used_key_parts": ["no_invoice", "status", "order_id"],
                "ref": ["const", "const", "newlove.cargo.order_id"],
                "r_loops": 281415,
                "rows": 1,
                "r_rows": 0.978,
                "r_total_time_ms": 1724.6,
                "filtered": 100,
                "r_filtered": 100,
                "index_condition": "(`order`.`status` = 'closed')"
              },




полный новый план:

| {
  "query_block": {
    "union_result": {
      "table_name": "<union1,4>",
      "access_type": "ALL",
      "r_loops": 1,
      "r_rows": 22,
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "r_loops": 1,
            "r_total_time_ms": 4983.8,
            "duplicates_removal": {
              "table": {
                "table_name": "storage",
                "access_type": "ALL",
                "possible_keys": ["fk_storage_cargo_id_idx"],
                "r_loops": 1,
                "rows": 622397,
                "r_rows": 617977,
                "r_total_time_ms": 1611,
                "filtered": 100,
                "r_filtered": 45.538,
                "attached_condition": "(greatest(cast(`storage`.amount_start_total as signed),((cast(`storage`.amount_start_total as signed) + cast(`storage`.amount_in as signed)) - cast(`storage`.amount_out as signed))) > cast(`storage`.amount_draw as signed))"
              },
              "table": {
                "table_name": "cargo",
                "access_type": "eq_ref",
                "possible_keys": ["PRIMARY", "fk_cargo_order_id_idx"],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["cargo_id"],
                "ref": ["newlove.storage.cargo_id"],
                "r_loops": 281415,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 953.13,
                "filtered": 100,
                "r_filtered": 100
              },
              "table": {
                "table_name": "order",
                "access_type": "eq_ref",
                "possible_keys": ["in_cust_1"],
                "key": "in_cust_1",
                "key_length": "6",
                "used_key_parts": ["no_invoice", "status", "order_id"],
                "ref": ["const", "const", "newlove.cargo.order_id"],
                "r_loops": 281415,
                "rows": 1,
                "r_rows": 0.978,
                "r_total_time_ms": 1724.6,
                "filtered": 100,
                "r_filtered": 100,
                "index_condition": "(`order`.`status` = 'closed')"
              },
              "table": {
                "table_name": "account",
                "access_type": "eq_ref",
                "possible_keys": [
                  "PRIMARY",
                  "account_type_subject_idx",
                  "type_id_balance_idx"
                ],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["account_id"],
                "ref": ["newlove.order.account_id"],
                "r_loops": 275212,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 94.005,
                "filtered": 100,
                "r_filtered": 100,
                "attached_condition": "(account.type_id = 21)"
              },
              "table": {
                "table_name": "account",
                "access_type": "eq_ref",
                "possible_keys": [
                  "PRIMARY",
                  "account_type_subject_idx",
                  "type_id_balance_idx",
                  "i_subj"
                ],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["account_id"],
                "ref": ["newlove.order.account_id"],
                "r_loops": 275212,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 13.448,
                "filtered": 100,
                "r_filtered": 100,
                "attached_condition": "(account.type_id = 21)"
              },
              "table": {
                "table_name": "client",
                "access_type": "eq_ref",
                "possible_keys": ["PRIMARY", "fk_client_user_id_idx", "i_10"],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["client_id"],
                "ref": ["newlove.account.subject_id"],
                "r_loops": 275212,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 97.014,
                "filtered": 100,
                "r_filtered": 23.427,
                "attached_condition": "((`client`.is_collecting = 0) and (`client`.user_id is not null))"
              },
              "table": {
                "table_name": "curator",
                "access_type": "ref",
                "possible_keys": [
                  "fk_employee_user_id_idx",
                  "fk_employee_office_contact_id_idx"
                ],
                "key": "fk_employee_user_id_idx",
                "key_length": "5",
                "used_key_parts": ["user_id"],
                "ref": ["newlove.client.user_id"],
                "r_loops": 64475,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 121.87,
                "filtered": 100,
                "r_filtered": 100,
                "attached_condition": "(curator.office_contact_id is not null)"
              },
              "table": {
                "table_name": "curator_office",
                "access_type": "eq_ref",
                "possible_keys": ["PRIMARY", "fk_contact_geo_id_idx"],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["contact_id"],
                "ref": ["newlove.curator.office_contact_id"],
                "r_loops": 64475,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 20.694,
                "filtered": 100,
                "r_filtered": 5.8674,
                "attached_condition": "(curator_office.geo_id = 35)"
              }
            }
          }
        },
        {
          "query_block": {
            "select_id": 4,
            "r_loops": 1,
            "r_total_time_ms": 15916,
            "table": {
              "table_name": "<subquery5>",
              "access_type": "ALL",
              "possible_keys": ["distinct_key"],
              "r_loops": 1,
              "rows": 32312,
              "r_rows": 21,
              "r_total_time_ms": 0.1039,
              "filtered": 100,
              "r_filtered": 100,
              "materialized": {
                "unique": 1,
                "query_block": {
                  "select_id": 5,
                  "r_loops": 1,
                  "r_total_time_ms": 15913,
                  "having_condition": "(tmp_field > 0)",
                  "temporary_table": {
                    "table": {
                      "table_name": "storage_service",
                      "access_type": "ALL",
                      "possible_keys": [
                        "waybill_id_cargo_id_draw_waybill_id",
                        "fk_storage_service_waybill_id_idx"
                      ],
                      "r_loops": 1,
                      "rows": 32312,
                      "r_rows": 33254,
                      "r_total_time_ms": 70.621,
                      "filtered": 100,
                      "r_filtered": 100
                    },
                    "table": {
                      "table_name": "waybill",
                      "access_type": "eq_ref",
                      "possible_keys": [
                        "PRIMARY",
                        "fk_waybill_order_id_idx",
                        "order_service_idx"
                      ],
                      "key": "PRIMARY",
                      "key_length": "4",
                      "used_key_parts": ["waybill_id"],
                      "ref": ["newlove.storage_service.waybill_id"],
                      "r_loops": 33254,
                      "rows": 1,
                      "r_rows": 1,
                      "r_total_time_ms": 9108.3,
                      "filtered": 100,
                      "r_filtered": 100
                    },
                    "table": {
                      "table_name": "order",
                      "access_type": "eq_ref",
                      "possible_keys": [
                        "PRIMARY",
                        "fk_order_account_id_idx",
                        "orders_to_draw_idx",
                        "in_cust_1"
                      ],
                      "key": "PRIMARY",
                      "key_length": "4",
                      "used_key_parts": ["order_id"],
                      "ref": ["newlove.waybill.order_id"],
                      "r_loops": 33254,
                      "rows": 1,
                      "r_rows": 1,
                      "r_total_time_ms": 6272,
                      "filtered": 100,
                      "r_filtered": 99.594,
                      "attached_condition": "(`order`.no_invoice = 0)"
                    },
                    "duplicates_removal": {
                      "table": {
                        "table_name": "account",
                        "access_type": "eq_ref",
                        "possible_keys": [
                          "PRIMARY",
                          "account_type_subject_idx",
                          "type_id_balance_idx",
                          "i_subj"
                        ],
                        "key": "PRIMARY",
                        "key_length": "4",
                        "used_key_parts": ["account_id"],
                        "ref": ["newlove.order.account_id"],
                        "r_loops": 33119,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 205.7,
                        "filtered": 100,
                        "r_filtered": 100,
                        "attached_condition": "(account.type_id = 21)"
                      },
                      "table": {
                        "table_name": "client",
                        "access_type": "eq_ref",
                        "possible_keys": [
                          "PRIMARY",
                          "fk_client_user_id_idx",
                          "i_10"
                        ],
                        "key": "PRIMARY",
                        "key_length": "4",
                        "used_key_parts": ["client_id"],
                        "ref": ["newlove.account.subject_id"],
                        "r_loops": 33119,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 119.99,
                        "filtered": 100,
                        "r_filtered": 74.667,
                        "attached_condition": "((`client`.is_collecting = 0) and (`client`.user_id is not null))"
                      },
                      "table": {
                        "table_name": "curator",
                        "access_type": "ref",
                        "possible_keys": [
                          "fk_employee_user_id_idx",
                          "fk_employee_office_contact_id_idx"
                        ],
                        "key": "fk_employee_user_id_idx",
                        "key_length": "5",
                        "used_key_parts": ["user_id"],
                        "ref": ["newlove.client.user_id"],
                        "r_loops": 24729,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 69.156,
                        "filtered": 100,
                        "r_filtered": 100,
                        "attached_condition": "(curator.office_contact_id is not null)"
                      },
                      "table": {
                        "table_name": "curator_office",
                        "access_type": "eq_ref",
                        "possible_keys": ["PRIMARY", "fk_contact_geo_id_idx"],
                        "key": "PRIMARY",
                        "key_length": "4",
                        "used_key_parts": ["contact_id"],
                        "ref": ["newlove.curator.office_contact_id"],
                        "r_loops": 24729,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 15.421,
                        "filtered": 100,
                        "r_filtered": 36.94,
                        "attached_condition": "(curator_office.geo_id = 35)"
                      }
                    }
                  }
                }
              }
            },
            "table": {
              "table_name": "account",
              "access_type": "eq_ref",
              "possible_keys": [
                "PRIMARY",
                "account_type_subject_idx",
                "type_id_balance_idx"
              ],
              "key": "PRIMARY",
              "key_length": "4",
              "used_key_parts": ["account_id"],
              "ref": ["<subquery5>.account_id"],
              "r_loops": 21,
              "rows": 1,
              "r_rows": 1,
              "r_total_time_ms": 3.5975,
              "filtered": 100,
              "r_filtered": 100,
              "attached_condition": "(account.type_id = 21)"
            }
          }
        }
      ]
    }
  }
} |


после я еще изменил,

я заметил кусок

  "table": {
                      "table_name": "order",
                      "access_type": "eq_ref",
                      "possible_keys": [
                        "PRIMARY",
                        "fk_order_account_id_idx",
                        "orders_to_draw_idx",
                        "in_cust_1"
                      ],
                      "key": "PRIMARY",
                      "key_length": "4",
                      "used_key_parts": ["order_id"],
                      "ref": ["newlove.waybill.order_id"],
                      "r_loops": 33254,
                      "rows": 1,
                      "r_rows": 1,
                      "r_total_time_ms": 6272,
                      "filtered": 100,
                      "r_filtered": 99.594,
                      "attached_condition": "(`order`.no_invoice = 0)"
                    },


и создал +1 индекс
> create index in_cust_2 on `order` (order_id,no_invoice);

и заменил строку
   LEFT JOIN `order` USING (order_id)
на
   LEFT JOIN `order` FORCE INDEX (in_cust_1) USING (order_id)

секция в плане превратилась в 

"table": {
                      "table_name": "order",
                      "access_type": "ref",
                      "possible_keys": ["in_cust_2"],
                      "key": "in_cust_2",
                      "key_length": "5",
                      "used_key_parts": ["order_id", "no_invoice"],
                      "ref": ["newlove.waybill.order_id", "const"],
                      "r_loops": 33254,
                      "rows": 1,
                      "r_rows": 0.9959,
                      "r_total_time_ms": 1844.6,
                      "filtered": 100,
                      "r_filtered": 100
                    },


и запрос стал выполнться за 10с 

видно что в этом куске используется оба столбика из нового индекса  "used_key_parts": ["order_id", "no_invoice"],
единстенное что почемкто в плане ненаписано что "used index"



 обновленный план:

| {
  "query_block": {
    "union_result": {
      "table_name": "<union1,4>",
      "access_type": "ALL",
      "r_loops": 1,
      "r_rows": 22,
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "r_loops": 1,
            "r_total_time_ms": 3233.1,
            "duplicates_removal": {
              "table": {
                "table_name": "storage",
                "access_type": "ALL",
                "possible_keys": ["fk_storage_cargo_id_idx"],
                "r_loops": 1,
                "rows": 622397,
                "r_rows": 617977,
                "r_total_time_ms": 1255.9,
                "filtered": 100,
                "r_filtered": 45.538,
                "attached_condition": "(greatest(cast(`storage`.amount_start_total as signed),((cast(`storage`.amount_start_total as signed) + cast(`storage`.amount_in as signed)) - cast(`storage`.amount_out as signed))) > cast(`storage`.amount_draw as signed))"
              },
              "table": {
                "table_name": "cargo",
                "access_type": "eq_ref",
                "possible_keys": ["PRIMARY", "fk_cargo_order_id_idx"],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["cargo_id"],
                "ref": ["newlove.storage.cargo_id"],
                "r_loops": 281415,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 561.64,
                "filtered": 100,
                "r_filtered": 100
              },
              "table": {
                "table_name": "order",
                "access_type": "eq_ref",
                "possible_keys": ["in_cust_1"],
                "key": "in_cust_1",
                "key_length": "6",
                "used_key_parts": ["no_invoice", "status", "order_id"],
                "ref": ["const", "const", "newlove.cargo.order_id"],
                "r_loops": 281415,
                "rows": 1,
                "r_rows": 0.978,
                "r_total_time_ms": 877.9,
                "filtered": 100,
                "r_filtered": 100,
                "index_condition": "(`order`.`status` = 'closed')"
              },
              "table": {
                "table_name": "account",
                "access_type": "eq_ref",
                "possible_keys": [
                  "PRIMARY",
                  "account_type_subject_idx",
                  "type_id_balance_idx"
                ],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["account_id"],
                "ref": ["newlove.order.account_id"],
                "r_loops": 275212,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 25.927,
                "filtered": 100,
                "r_filtered": 100,
                "attached_condition": "(account.type_id = 21)"
              },
              "table": {
                "table_name": "account",
                "access_type": "eq_ref",
                "possible_keys": [
                  "PRIMARY",
                  "account_type_subject_idx",
                  "type_id_balance_idx",
                  "i_subj"
                ],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["account_id"],
                "ref": ["newlove.order.account_id"],
                "r_loops": 275212,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 12.25,
                "filtered": 100,
                "r_filtered": 100,
                "attached_condition": "(account.type_id = 21)"
              },
              "table": {
                "table_name": "client",
                "access_type": "eq_ref",
                "possible_keys": ["PRIMARY", "fk_client_user_id_idx", "i_10"],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["client_id"],
                "ref": ["newlove.account.subject_id"],
                "r_loops": 275212,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 43.413,
                "filtered": 100,
                "r_filtered": 23.427,
                "attached_condition": "((`client`.is_collecting = 0) and (`client`.user_id is not null))"
              },
              "table": {
                "table_name": "curator",
                "access_type": "ref",
                "possible_keys": [
                  "fk_employee_user_id_idx",
                  "fk_employee_office_contact_id_idx"
                ],
                "key": "fk_employee_user_id_idx",
                "key_length": "5",
                "used_key_parts": ["user_id"],
                "ref": ["newlove.client.user_id"],
                "r_loops": 64475,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 99.217,
                "filtered": 100,
                "r_filtered": 100,
                "attached_condition": "(curator.office_contact_id is not null)"
              },
              "table": {
                "table_name": "curator_office",
                "access_type": "eq_ref",
                "possible_keys": ["PRIMARY", "fk_contact_geo_id_idx"],
                "key": "PRIMARY",
                "key_length": "4",
                "used_key_parts": ["contact_id"],
                "ref": ["newlove.curator.office_contact_id"],
                "r_loops": 64475,
                "rows": 1,
                "r_rows": 1,
                "r_total_time_ms": 15.514,
                "filtered": 100,
                "r_filtered": 5.8674,
                "attached_condition": "(curator_office.geo_id = 35)"
              }
            }
          }
        },
        {
          "query_block": {
            "select_id": 4,
            "r_loops": 1,
            "r_total_time_ms": 6589.5,
            "table": {
              "table_name": "<subquery5>",
              "access_type": "ALL",
              "possible_keys": ["distinct_key"],
              "r_loops": 1,
              "rows": 32312,
              "r_rows": 21,
              "r_total_time_ms": 0.101,
              "filtered": 100,
              "r_filtered": 100,
              "materialized": {
                "unique": 1,
                "query_block": {
                  "select_id": 5,
                  "r_loops": 1,
                  "r_total_time_ms": 6589.3,
                  "having_condition": "(tmp_field > 0)",
                  "temporary_table": {
                    "table": {
                      "table_name": "storage_service",
                      "access_type": "ALL",
                      "possible_keys": [
                        "waybill_id_cargo_id_draw_waybill_id",
                        "fk_storage_service_waybill_id_idx"
                      ],
                      "r_loops": 1,
                      "rows": 32312,
                      "r_rows": 33254,
                      "r_total_time_ms": 38.49,
                      "filtered": 100,
                      "r_filtered": 100
                    },
                    "table": {
                      "table_name": "waybill",
                      "access_type": "eq_ref",
                      "possible_keys": [
                        "PRIMARY",
                        "fk_waybill_order_id_idx",
                        "order_service_idx"
                      ],
                      "key": "PRIMARY",
                      "key_length": "4",
                      "used_key_parts": ["waybill_id"],
                      "ref": ["newlove.storage_service.waybill_id"],
                      "r_loops": 33254,
                      "rows": 1,
                      "r_rows": 1,
                      "r_total_time_ms": 4493.9,
                      "filtered": 100,
                      "r_filtered": 100
                    },
                    "table": {
                      "table_name": "order",
                      "access_type": "ref",
                      "possible_keys": ["in_cust_2"],
                      "key": "in_cust_2",
                      "key_length": "5",
                      "used_key_parts": ["order_id", "no_invoice"],
                      "ref": ["newlove.waybill.order_id", "const"],
                      "r_loops": 33254,
                      "rows": 1,
                      "r_rows": 0.9959,
                      "r_total_time_ms": 1844.6,
                      "filtered": 100,
                      "r_filtered": 100
                    },
                    "duplicates_removal": {
                      "table": {
                        "table_name": "account",
                        "access_type": "eq_ref",
                        "possible_keys": [
                          "PRIMARY",
                          "account_type_subject_idx",
                          "type_id_balance_idx",
                          "i_subj"
                        ],
                        "key": "PRIMARY",
                        "key_length": "4",
                        "used_key_parts": ["account_id"],
                        "ref": ["newlove.order.account_id"],
                        "r_loops": 33119,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 52.567,
                        "filtered": 100,
                        "r_filtered": 100,
                        "attached_condition": "(account.type_id = 21)"
                      },
                      "table": {
                        "table_name": "client",
                        "access_type": "eq_ref",
                        "possible_keys": [
                          "PRIMARY",
                          "fk_client_user_id_idx",
                          "i_10"
                        ],
                        "key": "PRIMARY",
                        "key_length": "4",
                        "used_key_parts": ["client_id"],
                        "ref": ["newlove.account.subject_id"],
                        "r_loops": 33119,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 53.969,
                        "filtered": 100,
                        "r_filtered": 74.667,
                        "attached_condition": "((`client`.is_collecting = 0) and (`client`.user_id is not null))"
                      },
                      "table": {
                        "table_name": "curator",
                        "access_type": "ref",
                        "possible_keys": [
                          "fk_employee_user_id_idx",
                          "fk_employee_office_contact_id_idx"
                        ],
                        "key": "fk_employee_user_id_idx",
                        "key_length": "5",
                        "used_key_parts": ["user_id"],
                        "ref": ["newlove.client.user_id"],
                        "r_loops": 24729,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 49.008,
                        "filtered": 100,
                        "r_filtered": 100,
                        "attached_condition": "(curator.office_contact_id is not null)"
                      },
                      "table": {
                        "table_name": "curator_office",
                        "access_type": "eq_ref",
                        "possible_keys": ["PRIMARY", "fk_contact_geo_id_idx"],
                        "key": "PRIMARY",
                        "key_length": "4",
                        "used_key_parts": ["contact_id"],
                        "ref": ["newlove.curator.office_contact_id"],
                        "r_loops": 24729,
                        "rows": 1,
                        "r_rows": 1,
                        "r_total_time_ms": 13.359,
                        "filtered": 100,
                        "r_filtered": 36.94,
                        "attached_condition": "(curator_office.geo_id = 35)"
                      }
                    }
                  }
                }
              }
            },
            "table": {
              "table_name": "account",
              "access_type": "eq_ref",
              "possible_keys": [
                "PRIMARY",
                "account_type_subject_idx",
                "type_id_balance_idx"
              ],
              "key": "PRIMARY",
              "key_length": "4",
              "used_key_parts": ["account_id"],
              "ref": ["<subquery5>.account_id"],
              "r_loops": 21,
              "rows": 1,
              "r_rows": 1,
              "r_total_time_ms": 0.0718,
              "filtered": 100,
              "r_filtered": 100,
              "attached_condition": "(account.type_id = 21)"
            }
          }
        }
      ]
    }
  }
} |


===

| slow log

его забейшься атктиивииировать. именно для mariab

хитротьс   в том что надо вбивать настройки slow log только в секцию [mariadb]



[mariadb]

log_output=FILE
slow_query_log
slow_query_log_file=/var/log/mysql/bullseye-slow.log
long_query_time=1.0


хотя может быть еще хитрсть в этой настроке
log_output=FILE



а вот еще ссылка может пригодится
https://vettabase.com/logging-all-mariadb-and-mysql-queries-into-the-slow-log/#MariaDB_106

===

| partitioning

во первых сразу скажу что мы будем говорить только о таблицах InnoDB
и тут супер важно сразу сказать что если мы хотим разбить таблицу на партишены 
то такая таблица не может иметь foreign keys(тоесть колонки которые ссылаются на примари 
колонку в другой таблице) и также таблицу нельзя разбить на партиции если в таблице есть 
колонки на которые ссылаются foreign ключи  с других таблиц!
тоесть еще раз - в партионированной таблице столбцы не могут быть foreign 
и на столбцы такой таблицы не могут ссылаться другие таблиы.
и это звездец. на мой взгляд это ставит практически на 100% крест
на примененеии этой технологии.




HASH партишн.

очень мнгого мусора бла бла булшита про эту тему.

один из видов партишенга это hash партишн.

в чем его прикол. для наачала расскауж про другие виды партишенга. - обычно в других вида партишенга надо руками задавать расчитывать 
услвие при котором куски таблицы в какой партишен надо запихнуть. это первый минус других видов.
второй минус что в других видах обычно партишен его границы уже строго записан (например мы пропсиали что последний партишен 
имеет id<3000) поэтому в конце концов он забивается  и нужно руками добавлять +1 партишен.

так вот хэш сопосб он неимеет этих минусов. - мы задаем сколкьо то партишенов скажем 5. и они будут набваться бесконечно.
сколько угондно.  мускул опредяет куда ему писать запрос на тот ииили иной партишен как остаток от деления ячейки в стооблике строке котрую запмсывам на число паритишенов напрмиер

MOD(YEAR('2005-09-01'),4)
=  MOD(2005,4)
=  1

в чем прикол такого партишенга еще - в том что мускула можно происать на какую папку сохарнять тот или иной партишен.
говоря более прямо - это дает вомхзомжнсть указать на ккой диск будет идти запист того ии ли иного
партшена.
вот пример


ALTER TABLE `a`
partition by key(special_key) PARTITIONS 12  
(
PARTITION p0 ,
PARTITION p1 ,
PARTITION p2 ,
PARTITION p3 DATA DIRECTORY='/media/p1/mysql_table_a',
PARTITION p4 DATA DIRECTORY='/media/p1/mysql_table_a',
PARTITION p5 DATA DIRECTORY='/media/p1/mysql_table_a',
PARTITION p6 DATA DIRECTORY='/media/p1/mysql_table_a',
PARTITION p7 DATA DIRECTORY='/media/p2/mysql_table_a',
PARTITION p8 DATA DIRECTORY='/media/p2/mysql_table_a',
PARTITION p9 DATA DIRECTORY='/media/p2/mysql_table_a',
PARTITION p10 DATA DIRECTORY='/media/p3/mysql_table_a',
PARTITION p11 DATA DIRECTORY='/media/p3/mysql_table_a',
);

видно ккой партишен где будет лежать.
вомжнос эта фича есть у всех видов партишенга. 

тода фича хэша  в том что ожно задать фикс число партшенов раз и навсегда  и абыть об этом.
плюс колонка может ыть како угондно по которой рещежм. в итоге вся эта шняга можнь быть полезан только 
в одном случае - когда у анс идет охиернаая запис в таблицу такая что никаких дисков нехватает.
тогда можно раздить это все на эту тучу дисков. раз и навсегда. 

только вопрос - если запист идет супе силно то как оттуда чиать вобще непонятно по скороссти.

вобщем хэш по мне гавнр. для опреацти чтения вобзе  никакого выбиграыша нет.


---
| uniq

как узнать сколько видов разных знаений есь в столбике


> SELECT ID, FirstName, LastName FROM table GROUP BY(FirstName)

---
| upgrade

когда мы установили новую версию мускула(машки тобишь) а база то у нас старая 
то надо запустить сервер мускула. а потом надо заупстить команду
котоая проапгрейдиит системыне таблицы и будет все чик пибабум

$ mysql_upgrade -u root  -p  (для более старой версии машки)
либо
$ mariadb-upgrade -u root -p  ( для новой версии машки)

----
| histogram

для создания прдвинутой статисткии по тадице надо юзать  histograms

вначале надо в конфиге прописать тип гистограм . самый крутой это тип JOSN
[mariadb]
histogram_type = JSON_HB


сами гситтограммы они создаются чрееез команду

> analyze table имя_таблицы persistent for all

проверить что для табицы гсторамма создана через команду

> SELECT db_name,table_name,column_name,hist_type,
  hex(histogram),decode_histogram(hist_type,histogram) 
  FROM mysql.column_stats WHERE db_name='test' and table_name='origin';


ссылка = https://mariadb.com/kb/en/decode_histogram/
----

| count
| group


есть таблица в ней поле to_account_id с повторябщимися строками.
надо узнатьт сколько одинаковых строк по каждой строке


> select to_account_id, count(to_account_id) as invoice_sum from invoice     group by  to_account_id desc order by invoice_sum desc  limit 30;
+---------------+-------------+
| to_account_id | invoice_sum |
+---------------+-------------+
|       1917035 |      477343 |
|       1354630 |      407951 |
|       4005540 |      338192 |
|        246042 |      312117 |
|        246062 |      311200 |
|        246114 |      287182 |
|        246338 |      251460 |
|       4005529 |      164395 |
|       2920275 |      106116 |
|        246112 |       78453 |
|        246326 |       76402 |
|        246133 |       57408 |
|       2149977 |       55336 |
|       4005534 |       45752 |
|        246127 |       34384 |
|        246644 |       33221 |
|        246085 |       32152 |
|        246093 |       25917 |
|        156523 |       25058 |
|       1440226 |       25013 |
|        246148 |       22946 |
|        246256 |       22570 |
|        246126 |       19070 |
|        246225 |       18912 |
|        246165 |       17614 |
|        246100 |       17411 |
|        246257 |       17377 |
|        246187 |       17025 |
|        246170 |       16695 |
|       4005530 |       16467 |
+---------------+-------------+
30 rows in set (3.49 sec)

===

| trigger

продолжение

посмтреть имена всех триггеров в базе "db2"

> select trigger_name from triggers where trigger_schema="db2" \G

или так
> select trigger_name from triggers where trigger_schema="db2" order by trigger_name;

| timezone

временные тайммзоны хранятся в mysql.time_zone
только там по дефолту пусто. их надо заполнять

# mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root mysql

чтобы с этим не ебаться можно в конфиге указать в таком виде

[mariadb]
default_time_zone = '+3:00'


это раобтает без всякого заполенния что очнень удобно если мы запускаемя из докера

| update

еси мы запускамем мускула с уже развернутой базой причем база от мускула прошлой версии.
то надо создать переменную MARIADB_AUTO_UPGRADE=1 для докер конейтенрера которую мускуал считает и автомтмом проапгредйит системные 
таблцы в базе

# cat .env
MARIADB_AUTO_UPGRADE=1


есди эту перменую несоздать то контейнер незапустится будет писат ошибку что базу надо проагпгрелйдить

===
| dump triggers


# mysqldump -u... -p... --no-data --routines --triggers dbname | gzip > DBSchema.sql.gz

прблема в том что обратно их хуй накатишь на базу. ибо она дропнет все табицы итд.
пиздец

===
