
$ docs
назначение репозитория -> for different notes
*
*
*
По дефолту git pull и git push сейчас качает через https, надо переделать чтобы связь была по ssh.
Для этого:
    - генерируем ключ
      $ ssh-keygen -t ed25519 -C "aceqbaceq@gmail.com"
    - запускаем ssh-agent
      eval `ssh-agent -s`
    - добавляем ключ в агент
      ssh-add ~/.ssh/id_ed25519
    - копируем в буфер содержимое публичного ключа и вставляем на github.com в  profile-settings-ssh and gpg keys
      cat ~/.ssh/id_ed25519.pub
    - тестируем связь по ssh с github
      $ ssh -T git@github.com
        Hi aceqbaceq! You've successfully authenticated, but GitHub does not provide shell access

      тут возникает вопрос а как же происходит аутентификация получается мы стучимся на гитхаб под ssh логином git а как же это так 
      ведь у нас логин aceqbaceq в веб морде, плюс мы неуказали ssh ключ. По поводу ключа - при попытке аутентификации ssh клиент будет пробовать в качестве ключа
      все ключи которые лежат в папке ~/.ssh/* путем их перебора. С ключом разобрались. По поводу логина git под которым мы по ssh стучимся на github. Дело в том что
      как выглядит процесс добавления ssh юзера на удаленном сервере. На удаленном сервере мы идем в папку /home/имя_юзера/.ssh/authorized_keys  и в этот файл 
      добавляем наш публичный ключ либо руками через copy/paste либо через команду ssh-copy-id имя_юзера@remote_host. в итоге файл authorized_keys будет иметь
      вид
	$ cat authorized_keys 
	ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINa9Cne2PSkLOruVDWdHyj6eKFLswfLFtyeIJf/jppen aceqbaceq@gmail.com

      после этого мы можем стучаться на удаленый сервер через ssh имя_юзера@remote_host
      отсюда вытекает то что если мы на удаленном сервере можем добавить наш публичный ключ к любому линукс юзеру на удаленном хосте, может дбавить сразу к куче 
      юзеров 
	/home/vasya/.ssh/authorized_keys
	/home/petya/.ssh/authorized_keys
	/home/klava/.ssh/authorized_keys
      и значит мы сможем входить с нашим ключом под любым юзером vasya, petya, klava
	ssh vasya@IP
	ssh petya@IP
	ssh klava@IP
      тоесть от нашего ключа ничего независит все зависит в какую папку на удаленном сервере добавят наш ключ.
      очевидно что когда мы регистрируемся на сайте гитхаб то наш публичный ключ добавляют в папку /home/git/.ssh/authorized_keys
      поэтому мы можем стучаться на сайт гитхаба по ssh от имени юзера git. а то что у нас в веб морде гитхаба используется логин aceqbaceq а не git это совсем другая история.
      потому что логин для службы ssh и логин для http службы это совершенно разные назависимые логины.(хотя по интуитивной логике кажется что если мы на веб входим под логином
      aceqbaceq то и для ssh входа тоже должен использовтся логин aceqbaceq). если попробовать войти как ssh aceqbaceq@github.com то он пошлет, что совершенно однзначно докзывает
      что гитхаб добалвяет наш публичный ключ именно для линукс юзера git и это все зависит от архитекторов гитхаба а не с нашей стороны. публичный ключ таким образом играет роль
      пароля а какой логин это нам надо самим знать исходя как это настроено на удаленном сервере. получается что на удаленный сервер мы можем зайти под неким логином под разными
      публичными ключами это как бы как по аналогии что можно было бы зайти на комп под одним логином и одновременно несколкьими паролями. прикол. 
      и тут следубщий еще прикол совершенно логично что все кто ломится на гитхаб по ssh они все ходят под логином git то есть ssh git@github.com - это уже понятно. все их публичные
      ключи добавлены в файл /home/git/.ssh/authorized_keys. вопрос в другом что когда мы вошли то гитхаб распознает что вошел под юзером git человек с публичным ключом aceqbaceq
      а именно:
      $ ssh -T git@github.com
        Hi aceqbaceq! You've successfully authenticated, but GitHub does not provide shell access

      как же гитхаб это делает ? подобная технология используется в другой программе gitlab. там тоже все юзеры по ssh ломятся под юзером git как ssh git@gitlab
      однако гитлаб при этом всех различает индивиуадьно. как он это делает -> 
	    а делает он это через файл ~/.ssh/authorized_keys. дело в том что если юзеор зашел 
      на комп по ssh под юзером для примера git то в файле authorized_keys можно прописать
      какой бинарник будет запущен это необязательно должен быть bash, также там можно указать
      доп переменные которые должны появиться у юзера в окружении. таким образом можно жестко
      зарегулировать что и как будет запущено в ssh сессии когда юзер аутентифиуировался.

      вот как выглядит ~/.ssh/authorized_keys на примере его из установленного на машине гитлаба для ssh юзера git 
          command="/opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell key-1",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINa9Cne2PSkLOruVDWdHyj6eKFLswfLFtyeIJf/jppen

      здест указано что после аутентификации должна быть запущена команда /opt/gitlab/embedded/service/gitlab-shell/bin/gitlab-shell key-1. далее указаны доп опции которым сессия ограничивается и в конце концов указан публичный ключ для которого это все верно. тоесть для каждого публичногло ключа можно указать свои индицидуалььные опции.

      параметры в authorized_keys их обьяснение можно посмотреть в man authorized_keys
      таким образом гитлаб распознает публичному ключю что вошел имена вася через свой бинарник гитлабовский gitlab-shell. он както там распознает что данному публичному ключу соответсвует 
      гитлабовский юзер вася.

рассмотрим как можно добиться того же простыми средствами:
для этого:
  в /etc/ssh/sshd_config 
обязательно нужна активированная опция 
    PermitUserEnvironment yes
тогда 
  в ~/.ssh/authorized_keys 
вставляем строку c опцией environment="REMOTEUSER=jrhacker"

тоесть ~/.ssh/authorized_keys:
    command="/bin/bash -c 'echo Welcome $REMOTEUSER!' ",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty,environment="REMOTEUSER=jrhacker" ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINa9Cne2PSkLOruVDWdHyj6eKFLswfLFtyeIJf/jppen aceqbaceq@gmail.com


теперь когда юзер зайдет по ssh git@IP то у нас в окружении переменных будет переменная
  REMOTEUSER=jrhacker
и мы будем ее просто печатать при входе через 
  command="/bin/bash -c 'echo Welcome $REMOTEUSER!' "

вот как вышлядит на практике:
  $ ssh vasya@localhost
    Welcome jrhacker!

таким образом мы вошли под ssh юзером vasya но по публичному ключу мы распознали что вошел jrhacker
(ибо еще раз мы помним что под одним и тем же ssh юзером может войти миллион разных публичных ключей как бы получается что под одним юзером может войти миллион юзеров вот такой каламбур. если публичный ключ индентифицировать с паролем то получается что один юзер имеет миллион разных паролей)


таким образом вставляя в authorized_keys для каждого публиного ключа индивиудальный $REMOTEUSER
мы получаем возможность различать для нас какой же юзер зашел по ssh на акаунт git, какой 
публичный ключ был использован. что- то такое и используется на гитхабе.



	??- что такое процесс без tty. процесс который имеет tty это знчит что в /proc/pid/fd есть дескриптор файла который ссылается на /dev/tty? устройство.что такое tty устройство.
		кнопки с клавы летят в ядро а ядро пихает эти кнопки на соотвествующее tty устрйоство. с которого уже процесс получает эти кнопки. если процесс пихает в tty буквы то они ядром выводятся на экран. 
	    если кнопки нажимаются то они летят в какоето tty\pty устройство к которому уже может иметь доступ процесс. tty устрйство это устройство через которое процесс получает кнопки с клавы
	    если же в обратнуб сторону то буквы летят в экран. чтоб проесс мог получать поток с клавы он должен иметь прикрепенный к нему tty устройство. именно в tty устройство ядро перенапрвляет буквы  с клавы.
	    чтоб процесс мог пихать буквы на экран он должен иметь приклрелнный tty\pty устройство
	??- переработать устаовку гитлаба на полный автомамт через poetry
	??- добавить .vagrant папку в игнор









пропишем удаленный репозиторий как дефолтовый на нашем компе

$ git remote add origin git@github.com:aceqbaceq/docs.git

$ git push -u origin master

теперь нам ненадо прописывать полный путь к удаленному репозиторию 
а юзать просто git push, а именно для записи в репозиторий

$ git add .

$ git commit -m "comment smth here"

$ git push

если все таки на git push оно ругается то пишем полный путь

$ git push git@github.com:aceqbaceq/docs.git master

если после этой команды мы получаем отлуп

Enter passphrase for key '/c/Users/a.v/.ssh/id_rsa':
git@github.com: Permission denied (publickey).
fatal: Could not read from remote repository.

это какойто дурацкий глюк. запускаем еще раз команду. система спросит пароль от ключа. и мы успешно запушим коммит.

для загрузки с github
$ git pull git://github.com/aceqbaceq/docs.git master


/
