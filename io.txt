| IO

здест я буду говрорить у input output операциях 


читаю книжку Linux Programing Interaface (LPI)

значит в целом пишут о том что если наш процесс ломиться на ядро
чтобы чтото прочитать либо записать в файл дескриптор open() write()
то если на данный момент у ядра нет данных для этого дескриптора
то ядро ваш процесс засунет в спящий режим! и получается программа наша
она  в итоге остановилась , замерла. это называется blocking I\O
дебиальное название. я бы назвали sleeping I\O

тут еще важно какой беекенд у дескриптора. то ли он смотрит на физ диск
то ли он смотртит в pipe, то ли в сокет

если у нас за дескрптором сидит физ диск то обычно запись на диск идет 
без блокирования процесса потому что запись идет не надиск в кэш линукса. 
поэтомуоперация обычно не блокирующая то есть процесс сможет целиком 
записать данные в буфер и продолжит работу дальше и его ядро не будет 
помещать в sleep сосоатние пока запись не закончится. 
а обычно при записив в дескриптор если на той стороне нет места под запись (в буфере нет
места ) то ядро засунет процесс в S\D стейт  пока буфер не освободится. 
это они так пишут. тока у меня вопрос - точно видно что при запист больших файлов
на диск процесс все равно суется в D стейт. поэтому они тут тоже как то пиздят

значит можно при открытии файла через open() указать флаг O_NONBLOCK
это приведет к тому что при запросе на чтение\запись через этот дескриптор
если ядро неможет выполнить запрос прям щас то оно не будет помещать процесс
в S\D состояние оно сразу вернут ответ процесссу об ошибке. и в коде возврата
будет указано причина. при таком подходе нам нужно регулярно пытаться повторит операцию
(называется polling) в надежде что наконец то ядро может выполгить наш запрос. 
плюс этого в том что процесс может за это время сделать кучу другой полезной
работы. когда говорят об I\O или что делется non-blocking I\O имеют ввиду 
что процесс делает запрос на чтение запись через open\write через файл дескриптор
и при ядро не помещает процесс в S\D стейт если ядро неможет выполнить запрос 
а просто напросто возвращает процессу мгнвоенно ответ что пошел нахер и процесс
неспит а может обрабоаттать ошибку и выполнять какйото свой другой код. тоест
процесс может начать пытаться писать в дрйгой файл или считать сколько будет 10+20
а к этому файлу обратиться попозже. вместо того что ядро тупо процесс останвоить
уберет из шедулер очерели и процесс просто заснет пока ядро наконец не выполнит
I\O запрос процесса

если они говорят процесс блок то эти дебилы имеют ввиду что процесс впал в 
спящее состояние S\D. что его дальнешее иполнение заблокировано запросом
на чтение запись. 

другая техника как это решиить - создать чайлда. и пусть он находится в
заблоченном этим запросом сосотянии. а парент может продолжит выполнять какйто
другой свой код. причем при создании чайлда можно создать как новый тред в 
новом процессе (своя память) так и новый тред в нашем процессе.
они пишут что тред пул можно иметь что он полезен тодга когда наша прога
должно обратиться к другой проге (вилимо через дескриптор сокета например)
и та другая прога нихрен не отвечает сразу и она заблочит наш процесс. 
ну и чем это отличается от того что я выше написал. какая нам разница куда ведет
дескриптор в ядро или другу прогу. важно что запрос на чтение запись
не отвечает. 

далее я открыл некую стью их хабр. там написано что синхронный код программы
это как я понял когда  у нас программа как раз таки впадет в спячку(заблокируется)
ядром пока не будет выполнен запрос чтения\записи


асинхоронный код это как я понял когда у нас программа так использует сисколлы
что при запросе чтение записи ядро не блокрирует наш процесс если ядро
неожмет прочитать записать данные. а оно сразу шлет нахер. и процесс
может делать все что хочет дальше. 

далее в этой хабар статье пишут что в асинхроонном коде тогда получил отлуп
от ядра поступаю двумя путями - либо через какоето время заново пытаются
сделать чтение\записьь запрос (техника повторных опросов poll)
либо делают так что ОС нам как то должна позже сама сообщить что наконец то 
наш запрос она готовы выполпнить (тенхика push)

вообще конечно вопрос что такое они имеют ввду когда процесс заблокироован
по их понятиям. я так понимаю это процесс в состонии S\D. обычно в это сосотоние
процесс подпаает когда он выывает сисколл ядра свяанный с операцией чтения
записи с дескриптором. причем надо понимать что если процессс в состоянии
S\D это значит его код убран пока что из очереди на цпу шедулером. и важно
понимать что код процесса может быть убран шедулером из очереди тольок
если само ядро таак решит. а когда оно так может рещить толькотогда 
когда юзерский код вызывал некоторый ядерный сисколл!!! и этот сисколл являяясь 
кодом ядра уже делает указание шедулеру убрать процесс из очереди на цпу!
тоесть это гоорит о том что если прцоесс в сосотониии S\D это значит что 
он сделал зпрос к ядру через сисколл. это обязатеьно. и то что нетлько
юзерский код не выполняется на цпу НО и код ядра который в этом сисколле
находится тоже не выполняется! очевино что в ядре стоит либо таймер либо
триггер на какоето событие! только после отработки таймера или наступления
события ядерный код сисколла продолжит свою работу! а затем после
этого когда сисколл наконец то закончит то что он доолжен был сделать
он вернет оюратно на исполнениее код пцреосса и аоменяет его статус на R.
я бы скзаал что если процесс S\D это значит что на данный момент код процесса 
вообще на цпу не попадает. он побоку пока. на данный момент вызыван некий сисколл
который должен чтото сделать полежное для процесса. но он тоже на цпу не поадает!
потому что ему чтото мешает! тоесть коду процесса мешает неотраотавший сисколл
поэтому он цпу не попадает. коду сисколла мешает тоже чтото! чтобы ему отработать.
это чтото это лиьбо таймер либо ненаступившее событие! поэтому они все "спят"
 и код процесса и код сисколлла! состение S\D означает что сисколлу чтото мешает.
 он тоже заснул. он не выполняется. ожидается либо отработака таймера
 либо возникноение события. так вот они называю процесс заблоченным если 
 процесс находится в состоянии S\D . так вот процесс в этом состние
 может попатсь не олько потому что он вызывал сисколлы свызяанные с чтением
 и записью. есть еще куча сисколлов которые также приведут к этому состоянию.
 например сисколл sleep(). он никак не связан с чтенеим записью. он просто
 выставляет таймер. а потом спит. и мы все ждем пока таймер отарботает. тоест
 sleep() "мешает"" отработатьь таймер. как только таймер отарботает. sleep()
 тогда может тоже "отработать" и верент обратно процесс к R. 
поэтому когда говорят про асинхронное рограммиорвание они как бы говорят - мы нехотим
чтобы процесс впада в S\D состтояние при вызове сисколлла read() write()
это слишком долго. мы хотим мгнвоенного ответа. нашему коду есть чем заняться. мы 
тогда веренся к запроу просто позже.  так я говорю  о том что - а как они собиараются
в этом же ключе другие сисколлы "исправлять". есть куча других сисколлоа в которые
тоже могут отрабатвыать долго.  они тоже "блокируют" прцоесс. как они с этим собираются
исправлять ситуцию?  они все вцепились только к двум сисколлам read() и write()
, это хоршо. а как насчет остальных????



вообще "блокиование" процесса означает что в данный момент код прцоесса не выполняется.
более того невыполняется даже сисколл который процесс вызывал до этого ( а это обязатеьно
всегда имеет место , потому что только сисколл может пометить процесс в S\D
состояние тоесть выдавит его из шедулер очереди на цпу). и этот сискоолл щас чегото
ждет. либо чтобы отщелекал таймер либо наступление события. сам код сисколла
тоже "спит". за наступлением события следит другой кусок ядра. если это таймер то 
выставляется реально на железном таймере время. и далее пока крутится таймер
никакой код за ним не следит. когда таймер отшелакает он вызовет IRQ прерыаение. 
это вызввввввввет взоыв хендлера прерврывания. а это уже разбудит сисколл. 
на счет возниккновение события там уже туманнно. оэтому когда мы видим фразу "процесс 
блокиорован" дожно возникать картинка "процесс в состоянии S\D"
а это дожо выываьть картнку - код прцоесса не выополянется. код сисколла не выполняется.
все "ждут" либо настуения таймера. либо какоготто события.





далее они говорят про "мультиплексиорвание". что за хуйня такая?
когда у нас сигнао передается то это обычно значит что через один канал передается
сразу куча сигналов. например по проводу передается сразу куча теелефонных разгвооров
одновмерененно.или типа видеоролик - у нас видеосигнал и аудиосссигнал одноврменно
передаются. или в магнитофонной ленте. там сразу две дорожки левая и правая. 
мультиплесирование это когда чегото несколько предается за один раз. там вроде
так вот вопрос какое это оношение имеет к си языку,?
и вот я вроде нашел разумительнй ответ тут (https://aljensencprogramming.wordpress.com/2014/12/18/io-multiplexing/)
Multiplexing essentially means reading from or writing to multiple file descriptors simultaneously.

по идее когда говоряь про multiplexing I\O то вообще то это по идее должно подразумевать
что мы как бутто одновремнно читаем не с одного файл дескриптора (файл акоторы за ним сидит)
а сразу с несолкьких. кстати прмимер мультиелесирования это открыть на экране 4 мини
окна и там зпустиь 4 фильма. будет мультиплеисивранный просмотр.
если просто I\O это чтение (запист) с одного файл дескпритора(файла)
то мултиплскированный i\o по идее значит однрвременное чение с кучи файл 
дескриптторов (файлов). с точки зрения цпу это обычно называют мульититаскинг. кога
цпу однрвеменно на несклоьких ядра обрабывает несколько программ. этотоже мульиплексирование?
дебильное слово.
и тут вылзает функция select()  которая якоы этим занимается. 
у нее есть так называемвые MACRO. чтт такое макро? это элемент такой хрени в си как
препроцессор. это вот что. когда мы запускаем *.c текст на комплияцию то он еще не готов
ее пройти. перед этим нужно *.c текст модифицировать. эти и занимается препроцессов. 
например он нахрдит файлы котоыре указаны в 
	#include
и физически их подставляет в текст. тоесть процемпроцессов он как текстовый редактор
он модифиицрует текст нашейго *.c файла! а уже потом этот файл натраливается на комплиятор!
так вот МАКРО это кусок текста на си. который подствляется в наш *.c файл  препроцессором
когда он орабывает наш файл. это типа как акроним нарпимер мы говорим LPI а по факту это 
значит "Linux Programming Interaface". вот преррыпоцесор берет наш акроним МАКРО
и вместо него в текст втвляет кусок си кода! так вот у seelect() есть макро. видимо
они зашиты  в #include <sys/select.h>
про макро мы еще поговоиим. что делает select(). мы ему даем спмсок дейсприкров
из которых хотим читать и список дексптиторов которые хотим писать. далее мы
вызываем эту фнуцию и наш процесс блочится! тоесть код выдывалися из цпу
и сисколл тоже неработает! ожидается что хотя бы один файл декспритор на чтение
или запись будет "ready". щас я ьбясню ниже. и кактольк это происходит то сисколл
оживает. отрабаывает. и возвращается управление процессу нащему и мы получаем
спсиок тех декприоров которые "ready". так вот если они считают что этот сисколл
позволяет сделать на шу программму асинхррноой то конено же нет!!! у нас 
прогрмма по прежнму осатется синхронной! поому что она "залипает" засыпает 
на опредеелнной команде в тексте и ппц. какая же она при этом асинхронная?!?!!?!?
она по прежнему синхронная! вообще термин снхронная асихрронная он вообще сука
тут неверно применется! нужно было гвоорить программа блочистая неблочистая хотя бы!
( и здесь они насрали).  без select() у нас каакая была жизнь. ест процесс. у него
откртыты дескрпиры. одни на чтение друие на запись. нам нужно монтирить их состоение.
тоесть  дескрпиторы на чтение мы должны регулярно опрашивать  - вдруг с них чтото
прилееело новенького в прогу? дескрпирыр на запись ттоже надо мониторить опрашивать
потому что  у нас есть что туда записать но всегда можно записать в дскрпитор
на стороне ядра может быть чтото не готово!  положим у нас один  fd/0 на чтние 
и один fd/1 на запись. ядро по дефолту ( и это прикол) ниак не информацирует процесс что
fd/0 имеет некую новую информацию что туда чтото прилетело. ядро об этом молчит.
как прцоессу узнать? надо поровать прочитать оттуда. если мы гвороим
	 (read,fd/0...)
а там ничего нет то ядро наш процесс засунет в S\D состояние и код нашего процесса
перестанет выполнсться! пока чего нибуд реано не прилетит в fd/0 
это отстой!
можеты мы хотели тогда чтото на экране написать в fd/1 - нихуя. поздно.
код процесса уже останолвен. 
другой вариант. при содании fd/X через open() указать флаг O_NONBLOCK
тогда при поыватке чтения с fd/0 ядро наш процесс не усыпляет а сообщает что
ошибка. нихуя нет. значит процесс не уснул. но нам теперь надо регулярно
выполнять пробные чтения. read()
это тоже отсой потому что мы только зря тратим цпу мощности. тоест мы впустую 
выполняем запрс на сисколл из юзерспейса и тлько зря напрягаем код ядра. в итге
у нас есть нагрузка на цпу которая по факту занимается хуйней. это похоже вот на что.
есть повар вася(цпу) есть рецепт (программма) есть магазин( дескприптор).
дректор магазина(ядро)
вася читает в рецепте - купить 1кг капусты. он откадывает рецепт. и идет в магазин
и провеяет есть ли там капуста а дирктор маагазина говоиит капутсы нет. 
а цпу проделла кучу работы читая рецпет и бегая в магазин. далее цпу идем домой
вытаскивает рецепт там написано сделай то се. а потом опят написано -купи капусты.
и вот он так бегает и пытается
купить капусты.  бегание за капустй которая нет это пустая трата времени для цпу.
зато он может кончно и друие хрени делать что в рецпете указаны.
а если  у нас дескрпиров несклоько. то будет слишком много циклов занято
на пустую работу. плюс мы же в ядро переключаемся и обратно. это тоже дорого по
времени. 
так вот select() всего нвсего дает то что наш процесс засыпает. и сисколл заспает
до того момента когда другой кусок ядра не увидит(а как увидит? дело  в том что ready состояние
дескрпиора на чтение насуатупает тгда когда в буфер который стоит за этим дескиптором чтото
прилетит. но оно не приелетает само собой. туда положит контент тоже ядро просто другой
кусок. и видимо в свойствах дескрпиора высталяется что как только тут чтото появится 
нужно сразу пробудит select() сисколл. ). тоесть если бы у нас прсто процесс поробоват 
прочитать из декрпиора то его бы усыпили и если на другой дескприорп риелели данные
то процесс бы этого не узнал потому что он спит. 
если открывать оба дескрипора через O_NONBLOCK то забеешся их бегать проверять поппусту.
поэтому select() усыпляет процесс. но зато если чотот о прилетло хотя бы в 1 дескрпитор 
то ядро сразу разбудит процесс. тоесть просиходит блокирование это да. но типа 
"толковое" блокирование.
замечу то что блокирование все равно прооиходит и seelect() от него НЕЛЕЧИТ!
если я хочу во время невозможнсоити считать с дескрпиора вычсситывать мат формулы
это этот сисколл гавно. он эту прблему не решает! 
так напрмиер работает баш. если он от нас ждет нажатия кнопки то его ждет через
select(). 
так вот select() называют multiplexing I\O 
я счтаю что они уебки и назвыают неправльно. это не мультиплексинг I\O !
это мультиплексинг проверки на I\O ! дебилы!
мульииплсинг это одновремнноть чегото. мультиплексинг i\o означает что у нас происходит
одноверенно несколько операций ввода ввыода. например однрверменно читаем с
несклоких файлов. а мы этого недалем! мы одновменно проверяем на готовность к чтению(записи).
поэтому multiplexing of checking of ready to I\O
кстати что такое read сосотояние дескпритора. нарпимер на чтение. это нетолько то что
там чтото появислось и это можно счиать. но это и то что достгнут конец файла!
там схема такая мы выыхваем
 	read(fd/0,)
за fd/0 сидит буфер ядерный. он пустой или не пустой. если он пустой то ядру передват 
процессу нечего. поэтому дескрипотор не рейди. а вот когда в буфере чтото появится 
то он станет рейди. потому что видимо одна часть ядра скажем read() заимается перемещением
данных из буфера который в памяти ядра в ячейки памяти которые в памяти уж процесса!
а другая часть ядра занимается тем что переносит данные откуда то там в буфер ядра (наверно).
так вот мы делеаем запром
	read(fd/0, ...)
и скажем мы читаем сдиска. и тут вдруг ядро выяняет что уже достинли конца файла!
на это надо время чтобы это выясить. и тогда ядро в буфер кладет видимо ноль байт или 
каую то хрень обозначющую конец файла. и синализрирует read() что буфер уже непуст. он рейди
тогда read() аналиирует что там в буфере видимт символ EOF(end of file) и возвращается с 
кодом возврата 0. означает что быол считано 0 байт. а это признак что мы дсотисгли конца
файла. я к тому что дескптор на чтение он имеет статус рейди нетолько когда в буфере 
чтото есть но и когда достинунт конец файла. видимо там есть какая хрень которую кладет
ядро в буфер смотрия на которую read() понимает что это признак конца файла. 

<=====
<===== закончил на том что читаю что такое select() и асинх IO - это основной вопрос
но параельно возник доп мелкий впрос:
также на том что происходит когда в терминале тыкаю Ctrl+D(EOF=????wtf)
и как тыкнуть EOT ??
Ctrl+\
также - в read() стоит void * p
он что просто байты пихает с ядра в память процесса?
<=====
EOF опредялется в stdio.h как
$ cat /usr/include/stdio.h | grep EOF -A1
#ifndef EOF
# define EOF (-1)
#endif
это макро препроцессора си
тоесть если он ее встречает в тексте *.c ткста то он ее меняет на -1
получается
проверяею

#include <stdio.h>
#include <errno.h> // for the definition of errno
#include <stdlib.h> // for exit()
int main(void)
{

	printf ("EOF = %i", EOF);

return 0;
}


вывод
$ ./99.exe 
EOF = -1


насколкьо я понял  getchar() при достичжении конца файла возвращает EOF 
тоесть байт 0xff
а read() при достжении конца файла невозвращает ничего. ноль байтов.

в языке си есть функции си это libc а они уже запускают сисколлы. 
поэтому точто фугкция libc возраает щависит от того что вернул сисколл + то 
что в этом случае запрогамировано в этой фукнции!! скаже сисколл возвращет 0 ьайт
а уже фнкция нам возвраащет скажем -1 !!

терминал+(ctrl+d) = как эта хуйня работает?
как я понимаю EOF=-1=0xff это чисто интеретация фунукций libc на некоторые события.
как я понимаю ядро не шлет юзер проге никакой символ EOF=0x00 зато шлет коды возврата
ошиьки а libc глядя на это в некоторых своих фнкциях нам возрващает (как изврващеный иди
катор) не в ошиьках а в выоде самих утилит EOF. хотя ядро ниакого EOF нам не присылало!

а ctrl+d в терминале это совсем другая хуйня. это всем другое тех событие.
был железный термиал. у него был lie discpiine. это встроенный редатор текста.
и были упрялющие нажтаия кнопок. в том числе ctrl+D который в виде байта 0x04 чтоли?
xev подтвредил что ctrl+D это 0x04 в ascii это EOT(end of trnasmsison )
так вот в терминале был бфуер куда склвдываись симолы. и кодгмы мы жмем ctrl+D 
это собщвет термиалу что нужно то что в буфре отправить в комп! вот как оно 
раоботает! это как бы вместо Enter. а если в буфере еще ничего нет то мне
непонятно как тогда терминал чтото мог отправить в линию!?!?!?!?
но так как щас терминал виртуальнйы. то ядро "понимает" и отправляет в буфер 
терминал файла 0 байт. а бфуер сообщает нашей бзер проге что буфер обновился. принимай 
0 байт. такая хкйня. 
вопрс в чем разница между enter и ctrl+D , ответ акой. eneter ывзвет что буфер 
line dosciploe шлтеся в линию. + \n 
а crrl+D не прибавляет \n! вот в чем дело!


такде
у меня вопорос.  >    экран---(socket)гном терминал(/dev/ptmx)----(pts/10 прога) 

прога запустила read из (fd/0 --->pts/10)
я с другого процесса пуляю в /pts/10 оно на экране рисуется
а вот read у проги нихуя не покзывает! почему? потому что то что пихаю в /pts/10
с угой проги расценивается ядром как буто это програвысирает через свой fd/1
и оно лтит в /ptmx а  оттуда на экран! а вот то чтобы в fd/0 прилетело это надо 
чтобы именно либо с кнопок лбибо гном терминал сиранул.!
из чего яделаю вывод что как убтто у pts/10 есть два буфера. один на прием другой
на преедачу. что ли . 

                                       (pts/10)
 экран <----- ptmx -------------------> (buf1)---------------> /fd/0 прога
                   <------------------- (buf2) <--\-------------  /fd/1прога
                                                   \-----------   левая прога
                  
то что левая прога сиранула в pts/10 оно леттит на экран
но кто сказал что оно летит в buf1 ? нет! поэтому оно на вход проги fd/0 
не поадает ни разу
тоже самое если програ срет на fd/1 оно лтети на экран но не в buf1 !!!!
поэтому левой прогой можно воротвать то что летит из pts/10 в STDIN проги
и можно срать на экран куда она срет. но леовй прогой не получится ничго
полать что то на STDIN ее

нажатие на enter типа приводит к тому что буферр шлется проецессу. в худшем
случае \n суется вбуфер ишлется проыесу. и это не омжет быть сигалом для окочния
ппредачи.
а Ctrl+D только буфер шлет. и смиволы недобавлет. поэтому ctrl+d с упучтой сторрокой
может быт сиганолм онца файла. для сисколла на том конце. или либцэ либрари?
Ctrl+D говорит ядру чтобы он взял буфер терминала и послал процессу.
Cttrl+C просит ядро послать процессу сигнал SIGINT который обозначает 
что юзер хочет чтобы программа закончила свое существоаоние!вот смысла SIGINT!!


пиздец




как я понимаю решение всх проблем идет на первом уровне решения это выбор
в сторону select() а во втором уровне через epoll()
вот их и надо понять
а есть еще библиотка libuv которая еще более якобы прдивнутая (на каких сисколлах 
тога она работает?)