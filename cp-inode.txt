| cp 
| inode
| xfs
| ext4

возник вопрос если у нас есть файл. и я 
копирую в него другой файл.
скажем у нас есть файл

 01.txt

и я в него копирую 02.txt

 $ cp 02.txt 01.txt

так вот возник вопрос - после того как команда cp
отрабтает у нас у файла 01.txt изменит свой номер
иноды или нет?

как вообще под капотом процесс cp копирует тело
файла в другой файл.

ведь cp это обычный юзер процесс. в нем нет никакой
магии. может возникнуть задача самомму написать 
свою версию программы которая бы умела копировать
тело одного файла в тело другого файла.

самый простой подход открыть оба файла через 

    openat(src)
    openat(dest)

а потом из первого читать через read()
а во второй писать через write()

при этом номер иноды у дест файла коечно неизменится.

при этом такой поход для копироания самый лоховской
потому что мы пеерключаеисся в ядро. оно копирует
байты из файла в юзер спейс. потом мы обратно перкклю
чаемся в юзер спейс. потом обратно в ядро и оно 
копирует из памяти процесса в файл. это все ненужная
бесполезная канитель.
есть другой подход. есть глибц функция


    copy_file_range()

а именно

ssize_t copy_file_range(int fd_in, off_t *_Nullable off_in, 
int fd_out, off_t *_Nullable off_out,
  size_t size, unsigned int flags);


эта штука копирует даные из одного файла в другой
целиком только в ядреном пространстве.
без ненужных перекюлчений в юзер спейс. и без ненужн
ого копирвания байтов в память процесса.

при таком подходе тоже инода у дест файла
осатется той же самой.


есть еще один подход самый пиздатый.
есть вот такой ioctl

  ioctl(4, BTRFS_IOC_CLONE or FICLONE, 3) = 0


он работает тлько на XFS или BTRFS
и он делает вот что. 

   $  man FICLONE

   int ioctl(int dest_fd, FICLONE, int src_fd);


этот иоктл делает то что файл 4 будет иметь тот 
же набор дата блоков что и файл 3. тоесть у нас же
в иноде есть массив из номеров дата блоков которые
составляют тело файла. если мы хотим чтобы у нас
какой то файл имел такое же тело как другой файл
то логично не копировать данные из дата блоков 
файла источника в новые дата блоки а просто в иноде
дест файла прописать тот же самый массив номеров 
дата блоков. вот что делает этот иоктл. поэтому
он крут тем что мы можем чепез него "скопировать"
файл огромадного размера в милисекунды.

номер иноды у нас при этом у дест файла сохранится.

таким образом каким бы образом мы не "копироали" файл
номер иноды у дест файла останеся прежним.

так вот команда cp она умеет использовать все
три указанных метода. 

если мы запустим cp без спец паарметров тоесть
вот так
  

  $ cp 02.txt 01.txt

то он открывает оба файла

openat(AT_FDCWD, "02.txt", O_RDONLY) = 3
openat(AT_FDCWD, "01.txt", O_WRONLY|O_TRUNC) = 4

первый на чтение. второй на запись.
плюс флаг O_TRUNC дает то что ядро дает команду
драйвер фс чтобы он обнулил массив дата блоков 
котоый записан в иноде. тоеть его дата блоки
возрващатся в пул "свободных" дата блоков а файл
пересатет иметь тело.

и далее cp 
попробует вначале "скопировать " тело файла
самым быстрым и крутым способом через иоктл

ioctl(4, BTRFS_IOC_CLONE or FICLONE, 3)

если у нас фс XFS\BTRFS то это срабатывает. конец
истории. если  у нас ext4 то этот иоктл верентся
с ошибкой и тогда cp  заюзает 

   copy_file_range(3, NULL, 4, NULL, 9223372035781033984, 0) = 2


еще я хочу скаать что при таком способе
ioctl(4, BTRFS_IOC_CLONE or FICLONE, 3)
копирования файла можно легко убедиться что 
число занятях\свободных байтов на диске неменяется.

   $ df -B M /
   $ cp ...
   $ df -B M /

мы увиидим что число занятых мегабайтов на диске
не изменилось. но естесвтенно если после копирония
мы залеем в файл и начнем менять его контент то 
все те куски куда мы будем вствлять новый контент
они потребуют новых блоков. и тогда место на диске
начем потребляться.

завбно то что я пока не понимаю как нам узнать
какие файлы имеют одни и теже дата блоки.
тоесть вот  унас в папке есть два файла где 
второй файл получен путем копирвания чрез иоктл.
если я будут смотреть инфо об этих файлах
чрез 

$ stat ./ub18.img 
  File: ./ub18.img
  Size: 2147483648	Blocks: 4194304    IO Block: 4096   regular file

$ stat ./temp.img 
  File: ./temp.img
  Size: 2147483648	Blocks: 4194304    IO Block: 4096   regular file

то он мне покажет что оба файла занимают 4194304
кажый. хотя на самом деле эти файл используют
одни и теже дата блоки.
если  я натравлю du на папку

$ du -B M $(pwd)
4096M	/home/noroot/VM/fake

он мне покажет что размер файлов в папке 4ГБ.
хотя по факту суммарно оба файла занимают 2ГБ !!

у нас получается только df показыает честно сколко
байтов на диске занято. у нас при таком способе
копирования очень легко может быть ситация что 
если мы посчитаем обьем файлов на диске через du
то он будет больше чем реаьный обьем занятый на 
диске который можно увидеть чрез df !!

далее. когда мы юзаем cp то его можно заставит
чтобы он обязательно копиароал только через ioctl()

  $ cp --reflink=always  02.txt 01.txt

если у него через иоктл не получится то он 
вернет ошибку. напомню что по дефоту он также пытается
скопироать через иоктл но если не получется исползует
другие методы.


как cp заствить копировать через copy_file_range() 
в явном виде я незнаю.

а если заюзать вот так


  $ cp --reflink=none  02.txt 01.txt

тогда он будет копироваь самым тупым способом
через 

 read()
 write()


КСАТТИ я провеирил midnight commander он копирует
тоже с ипользованием IOCTL() !!! так что нет 
проблем! все круто!

так как ext4 не поддерживает ioctl(FICLONE)
а xfs поддерживает то я считаю xfs имеет огоромад
ное преимущество над ext4 !!! можно сэконрмть огмро
мную кучу места если у нас много файлов с похожими 
телами. да тот же самый приер с файлами под 
вирт машины. копируем файл пять раз. на диске
он занимает место как один файл. а потом ровно
настолько насколько каждая вирт машина наизменяет
свой файл ровно настолько и будет занимать на диске
этот файл! так что xfs у меня круто поднялся
а ext4 круто упал в моих глазах!!!

если на фс успешно отрабатывает ioctl(FICLONE)
то это значит ФС поддерживает reflink


ext4 не поодерживает эту фичу

а вот тут я нашел таблицу

  https://www.ctrl.blog/entry/file-cloning.html

в котро йуказано какие фс и на каких ос
подреживают эту фичу

интересно куда все это вывело

