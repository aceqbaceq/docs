| ansible
| setup

итак я хочу описать как ставить ансибль.

сначала может показаться что описание слишком длинное. но на самом деле
чтобы понять всю хуйню целиком рекомендую все таки все прочитать целиком

значит начну вот с чего. ансибль это всего навсего на 100% кучка сраных скриптов
на python.

так вот вначале нам нужно несклько разобраться как все устроено у такой помойки 
как питон.

вначале нам нужно поставить питон через пакетный менеджер. очень часто
питон уже устанолвен в системе по дефолту сразу.


  $ stat $(which python)
  File: /usr/bin/python -> python3

итак это симлинк

$ stat $(which /usr/bin/python3)
  File: /usr/bin/python3 -> python3.12

а он тоже симлинк

 $ stat $(which /usr/bin/python3.12)
  File: /usr/bin/python3.12

наконец обычный файл

  $ file /usr/bin/python3.12
	/usr/bin/python3.12: ELF 64-bit 

и он эльф. тоесть питон это эльф бинарник. окей питон интепретатор устанолвен.


итак есть бинаик питона. он может работаьт в косольном режиме. ровно также как работает 
бинарник баш. а можно написать текстовый скрипт. и на ненго натравить интепретатор.
точно ктакже как в баш файлы скриптов.


как войти в питоне в режиме консоли

	$ python
	>>>


далее как я понял изнутри питона с его точки зрения у нас есть неймспейсы. это такой уровень
изоляции обьектов. обьектами являются переенные и фнукции. какие еще есть обьекты хуй знает.
итак у нас есть разные неймспейсы. а внутри каждого нейспейса есть кучка пеерменыных и функций.

вопрос - как создать новый неймспейс в консоли.
ответ хуй знает. но можно создать новый неймсейс если мы создадим файл vasya.py
и внутри него напихаем переменных и функкций. далее идем в консоль и "импортируем" этот файл.
правда питон дебил. он не умеет импортировать нихуя если указать путь. нужно добавить 
путь в спец переменную. и только тогда можно импортировать файл 

создаю папку

	/home/noroot/temp/21

создаю в ней файл

	$ cat p1.py 
	#!/usr/bin/python3

	y = 10


далее в консоли делаю так

	>>> import sys
	>>> sys.path.append("/home/noroot/temp/21/")

теперь можно ипортиовать наш файл

	>>> import p1

при этом питон создась неймсппейс p1
как получить список всех неймспейсов у питона прям щас.
походу вот так

>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'p1', 'pip', 'pprint', 'sys', 'venv']


зато знаю как получить список всех обьектов сущеностей внутри неймспейса если 
мы знаем его имя

	>>> dir(p1)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'y']

как можно заметить в p1.py  я не создавал ничего кроме переменной "y"

откуда же в p1 нейспейсе взялась целая куча других обьектов. а их создал сам питон
интепретер когда проитал файл и создавал неймспеейс.

посмотрим какой тип у кажого обьекта. и что там внутри этих обьектов

>>> type(p1.__builtins__)
<class 'dict'>

это дикшонари. чтобы красиво напечаать дикшонари на экране нужно импортировать еще
одну хрень

>>> import pprint

тогда любой дикшонари можно красиво напечататьв вот так

>>> pprint.pprint (p1.__builtins__)
{'ArithmeticError': <class 'ArithmeticError'>,
 'AssertionError': <class 'AssertionError'>,
 'AttributeError': <class 'AttributeError'>,
...
...

хрень неинтресеная.
следущий обьект

>>> type(p1.__cached__)
<class 'str'>

>>> print (p1.__cached__)
/home/noroot/temp/21/__pycache__/p1.cpython-312.pyc

он показывает где лежит откомпилированный файл 


следущий оьект
>>> type(p1.__doc__)
<class 'NoneType'>

по идее в нем должно быть описание неймспейса

>>> print (p1.__doc__)
None

пусто. псмотрим как в других неймспейсах

>>> import venv
>>> print (venv.__doc__)

Virtual environment (venv) package for Python. Based on PEP 405.


>>> import pip
>>> print (pip.__doc__)
None


>>> type(p1.__file__)
<class 'str'>
>>> print (p1.__file__)
/home/noroot/temp/21/p1.py




>>> type(p1.__loader__)
<class '_frozen_importlib_external.SourceFileLoader'>
>>> print (p1.__loader__)
<_frozen_importlib_external.SourceFileLoader object at 0x76203cc7f530>


>>> type(p1.__name__)
<class 'str'>
>>> 
>>> print (p1.__name__)
p1


>>> type(p1.__package__)
<class 'str'>
>>> print (p1.__package__)



>>> type(p1.__spec__)
<class '_frozen_importlib.ModuleSpec'>
>>> 
>>> print (p1.__spec__)
ModuleSpec(name='p1', loader=<_frozen_importlib_external.SourceFileLoader object at 0x76203cc7f530>, origin='/home/noroot/temp/21/p1.py')



>>> type(p1.y)
<class 'int'>
>>> print (p1.y)
10


итак я посмотрел  на все обекты внутри неймсейса. в том числе и пеерменная "y"
она как ожидалось равна 10


так вот еще раз обрисую картину - директива "import" она импортирует обьекты из модуля. 
и потом создает новый неймспейс и сует туда эти обьекты.
теперь нам важно понять что такое модуль в питоне.

источником модуля может быть две хрени. либо либо. 
одним источником модуля может быть файл с диска. внутри файла питон скрипт.
это ровно то что я сделал выше. через файл p1.py

беререм любую папку на компе

	/home/noroot/temp/21/

внутри нее создаем файл *.py
внутрь файла накидываем питон сущностей - фкнкции, переменные.

чтобы питон нашел модуль основанный на файле нужно ему добавить в спец переменную путь К ПАПКЕ в которой лежит этот файл. тоесть нужно не путь к файлу указать а путь к папке в котором лежит
этот файл 

	>>> import sys
	>>> sys.path.append("/home/noroot/temp/21/")

(на конце 21 можно ставить слэш можно не ставить пофиг работает  и так и так)

и теперь можно импортиовать этот файл-модуль

	>>> import p1

питон будет исктаь файл p1 во всех своих пропсианных папка в том числе и в папке 

	/home/noroot/temp/21/

питон создаст неймспейс p1 и напихает в него все сущности из файл p1.py


так вот вторым источником для модуля при импорте может быть папка. и такой тип модуля называется - пакет. модуль-пакет.
хочу подчеркнуть что пакет это не отдельная сущность в питоне а это бекенд для модуля. 
тоесть нет такого в питоне что есть модули а есть пакеты. это хуйня.  пакет это бекенд для модуля. пакет является источником для модуля. носителем пакета явялется папка на диске . тоесть эти дебилы в народе они обычно говорят
я импортирую модуль. или я импортирую пакет. на самом деле это подразумевает то что 
когда говорят я импортировал модуль имеется ввиду что был импортиррован модуль с источником
файл. а если говорят импртирировал пакет это значит что импортировал модуль где источником была
папка. 

команда import всегда импортррует модуль. а его носителем может быть либо файл как в пре
дыдщум случае либо папка как в этом случае. когда папка то такой модуль называют пакет. хотя
более точно сказать модуль имеет тип пакет.

теперь разберем что это за модуль когда у него источник папка. 
значит сами питоновцы нихуя не понимают что такое пакет это отлично видно вот тут

	https://stackoverflow.com/questions/7948494/whats-the-difference-between-a-module-and-package-in-python



как создать модуль-пакет из папки. 
берем папку любую

	/home/noroot/temp/pip2

в ней создаем ПУСТОЙ файл 

		__init__.py 

название дебилоидное конечно

все мы создали модуль-пакет.

названием модуля будет папка pip2

чтобы модуль pip2 импортировать ВАЖНО указать путь не к pip2 как я это сделал вначале

		sys.path.append("/home/noroot/temp/pip2")

это огромандая ошибка !

нужно указать путь к папке на один уровень выше!

	sys.path.append("/home/noroot/temp/")


ну или более точно

	>>> import sys
	>>> sys.path.append("/home/noroot/temp/")

и теперь можно импортироват омдуль pip2

	>>> import pip2

тоесть когда мы пишем пиотону 
	
	>>> import vasya

то он берет все папки которые у него указаны в переменной где хранться пути к модулям
и ищет в каждой папке либо файл vasya.py либо ищет в каждой папке подпапку ./vasya и  в 
этой подпапке обязательно одолжен быть файл __init__.py

поэтому когда я указывать папку

	/home/noroot/temp/pip2

а потом писал

	import pip2

то он брал папку   /home/noroot/temp/pip2 и искал внутри нее либо файл pip2.py
либо подпапку /home/noroot/temp/pip2/pip2 внутри которой был бы файл __init__.py
понятно что ни того ни другого не было! вот какможно наебатся на пустом месте в этом
прекрасно питоне

теперь вопрос а что же за обьекты в итоге будут созданы в неймспейсе pip2 ?
ведь мой модуль pip2 нихрена не содержит !
ответ - только системные 

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__']


а теперь сделаем поинтереснее. 
создадим внутри pip2 папки два .py файла

../pip2
├── __init__.py
├── p1.py
├── p2.py

вот их контент

 $ cat p1.py 
	a = 1

 $ cat p2.py 
	b = 2

импортируем модуль pip2 снова. 
неужели ничего из этих .py файло наш питон не загрузит внутрь себя?

>>> import sys
>>> sys.path.append("/home/noroot/temp")
>>> 
>>> import pip2
>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__']

>>> from pip2 import *
>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__']

как видно нет - автоматом неимпортировалось нихрена!


если мы хотим импортировать обьекты из p1 то это надо сделать руками в явном виде воттак

>>> import pip2.p1

и тогда в неймспейсе pip2
появится обьект p1

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1']

где p1 имеет тип модуль

>>> type (pip2.p1)
<class 'module'>


>>> print(pip2.p1.a)
1

как видно сработало


щас я скажу то что все прояснит. когда мы пишем 

	>>> import pip2

то по факту питон грузит в себя ровно то что указано в  __init__.py
а так как там нихрена нет то он нихерна и не грузит. только создает нейммсейс pip2 
и там свои систенмые обьекты сует. 
так вот если мы хотим чтобы у нас при загрузке pip2 загрузились автоматом сущности из p1.py
и p2.py то это НАДО ПРОПИСАТЬ В __INIT__.PY  и все будет!


	$ cat __init__.py 
	from . import p1
	from . import p2



пробуем теперь импортиовать наш модуль-пакет

$ python
>>> import sys
>>> sys.path.append("/home/noroot/temp")

>>> import pip2

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1', 'p2']


вот видно что автоматом при импорте pip2 засосались обькты p1 и p2

	>>> print(pip2.p1.a)
		1

	>>> print(pip2.p2.b)
		2

таким образом при правильно настроенном __init__.py  и команде import pip2
нам ненужено руками испортирвать p1 и p2. они уже тоже импортррованы. 

теперь я добавлю функцию hello() в p1.py

	$ cat p1.py 
		a = 1

		def hello():
  			print("hello")


заново импортирую pip2 модуль.
состав обьектов в неймспейсе тот же самый


>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1', 'p2']

а вот как  я запускаю эту фнуциию

	...
	>>> import pip2
	>>> pip2.p1.hello()
	hello


при понимании модулей-пакетов мне помогли статьи
	https://www.freecodecamp.org/news/module-not-found-error-in-python-solved/
	https://martinxpn.medium.com/what-are-packages-in-python-and-what-is-the-role-of-init-py-files-82-100-days-of-python-325a992b2b13
	https://medium.com/@nydas/how-to-create-and-publish-your-own-python-package-8e4f3fd70506
	https://stackoverflow.com/questions/15746675/how-to-write-a-python-module-package
кстати вот родная статья от питон сайта тоже небесполезная но не супер
	https://docs.python.org/3/tutorial/modules.html


теперь я для себя ответил на вопрос - а что же импортируется в питон при импорте модуля-пакета
тоесть модуля-папки я так его бы назвал - ответ все то что прописано в __init__.py если там
нихрена не прописано то неимпортруется нихерна

возьмем для примера модуль venv
это модуль-пакет. у него бекенд папка. 

>>> import venv

посмтрим какие обьекты лежат в его нейсмпейсе
>>> dir(venv)
['CORE_VENV_DEPS', 'EnvBuilder', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'create', 'logger', 'logging', 'main', 'os', 'shutil', 'subprocess', 'sys', 'sysconfig', 'types']

посмотрим из какого файла он создан
>>> print(venv.__file__)
/usr/lib/python3.12/venv/__init__.py

ага четко видно что это модуль-пакет\модуль-папка

среди обьектов неймсейса кроме системных __*__ мы видим вот такие

CORE_VENV_DEPS
EnvBuilder
create
logger 
logging 
main
os 
shutil 
subprocess 
sys
sysconfig
types

эти обьекты должны както быть импортированы в тексте __init__.py через import

проверим

	$ cd /usr/lib/python3.12/venv/
	$ cat __init__.py | grep import
import logging
import os
import shutil
import subprocess
import sys
import sysconfig
import types
import _winapi
import argparse

ну и как бы видно что есть соовтесвтие. 
тоесть обьекты которые выше образовались при импорте модуля pip потому что они были в явной
форме импортированы в теле __init__.py через import директиву. только поэтому

а вотт ееще в пакете есть файл __main__.py зачем он нужен незнаю и щас разбираться не бууду.

для себя я так скажу - в чем прикол модуля-пакета. в том что импортируя только его тоесть
через одну строку

	import pip

мы фактически импортируем сразу адовое количество модулей-файлов. а это реально удобно. 
тоесть предаставиим у нас есть папка VASYA в ней 10 модулей-файлов

	p1.py
	...
	p10.py

чтобы их импортировать это надо писать 10 раз

  import p1
  import p2
  ...
  import p10

а так мы создаем в папке файл __init__.py 
с контентом
		import p1
		import p2
		..
		import p10

и тогда в нашей основной программе мы пишем одну строку

	import VASYA

и все. готово. все p1-p10 у нас будут импортированы автоматом
вот в чем прикол модуля-пакета. и также стало понятно какие модули файлы будут импотрированы
при импорте модуля-пакета.


далее из мелочи
как узнать какая версия питона щас стоит на компе

>>> import sys
>>> sys.version
'3.12.6 (main, Sep  8 2024, 13:18:56) [GCC 14.2.1 20240805]'


ксатти удобняшка. если у нас есть глобальная перменная в файле-модуле внутри модуля-папки
то ее можно напечатать без применения команды print()


../pip2
├── __init__.py
├── p1.py
├── p2.py

вот имеем модуль-папку pip2
внутри нее файл-модуль p1.py с контентом

 $ cat p1.py 
	a = 1

импортруем модуль

	import pip2

и печатаем перменную "a" просто вот так

	>>> pip2.p1.a
	1

тоест нет необходимости делать вот так
	>>> print (pip2.p1.a)
	    1

конечно это срботает только если в __init__.py у нас вот так

  ఻  $ cat __init__.py 
		from . import p1
		from . import p2

кстати вот  у нас нееймспейс модуля pip2

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1', 'p2']

а так как p1 по совему типу это тоже  модуль

>>> type(pip2.p1)
<class 'module'>

то  чреез dir() можно постмреть его конентент
>>> dir(pip2.p1)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'hello']

и вот нам прекрасно видна его перменная "a"


так вот когда мы делаем

>>> sys.version
'3.12.6 (main, Sep  8 2024, 13:18:56) [GCC 14.2.1 20240805]'

то это экивлатентно 

>>> print(sys.version)

и мы смотрим чему равна пременная version внутри файл-модуля sys
правда едиснверннное что у модуля sys носетелем явялется не питон скрипт файл 
а elf бинарник самого интпретатора питона. 
потому что 

	
>>> dir(sys)
['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__', '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__' ...


не имеет __file__ обьекта.

также об этом пишет 

	>>> help(sys)
	...

	FILE
    	(built-in)

замечу что dir() надо юзать обязательо БЕЗ кавычек. а вот help() обаязательно  с кавыяками!


найдем сам бинарник питона

насколько я понимаю этот модуль встроен в сам бинарник питона
 $ which python3
/usr/bin/python3
 $ file $(which python3)
/usr/bin/python3: symbolic link to python3.12

 $ stat $(which python3)
  File: /usr/bin/python3 -> python3.12
 $ file $(which python3.12)
/usr/bin/python3.12: ELF 64-bit 



теперь когда разобрались с модулями-файлами и модулями-пакетами питтона
надо выяснить у нас модуль venv установлен или нет
далее если мы вводим dir() без имени то он покзывает список всех неймсейсов щас имеющися
в питон интерптретатторе

>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']


псмотрим какой тип у неймспейса  __builtins__
	>>> type(__builtins__)
	<class 'module'>

ага это модуль. посмотрим он встроенный в бинарник питона или он загружается через 
питон-скрипт файл или папку

	>>> help(__builtins__)
    ...
    ....
    FILE
    	(built-in)

тоесть этот модуль содержится в питон бинарнике. 
посмотрмим что за обьекты внутри этого модуля


>>> dir(__builtins__)
[.... , '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', ..., 'hash', 'help', 'hex', 'id', ...'zip']

посмотрим какйо тип  у обьектов help , id , hash

>>> type(__builtins__.help)
<class '_sitebuiltins._Helper'>
>>> type(__builtins__.id)
<class 'builtin_function_or_method'>
>>> type(__builtins__.hash)
<class 'builtin_function_or_method'>


можно посмтреть справку по help, id, hash
ну а применяем вот так

>>> a=1

>>> id(a)
125298215205576

>>> hash(a)
1
>>> hash(123)
123

>>> hash('12334')
-5531871577535261644


тоесть кода мы вошли в консоль. то все функции\команды которые мы в ней юзаем это все
обьекты из неймспейса  __builtins__ 
и походу если это обьект оттуда то название модуля\неймспейса вводит необязательно

	>>> id(a)
	125298215205576	
	>>> __builtins__.id(a)
	125298215205576

видим что да . это одно и тоже.

прикол.

ксатти когда я создал "a" в консоли то это стало вот так выглядть с точки зрения
неймспейсов

>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a']

далее я псомтрел модуль venv не входит  в список обьектов в неймсейсе __builtins__
а его нужно загружать 

>>> import venv
>>> 
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'venv']

>>> type(venv)
<class 'module'>


вот у нас откуда этот модуль грузится

>>> venv.__file__
'/usr/lib/python3.12/venv/__init__.py'

тоесть это модуль-пакет



а теперь я хочу выяснить какой pacman пакет установил этот файл 

	$ pacman -F usr/lib/python3.12/venv/__init__.py
		usr/lib/python3.12/venv/__init__.py is owned by core/python 3.12.5-1

а! понятно

изнутри питона список установленных  модулей можно вот так посмотреь
	
	>>> help('modules')
	...
	venv

нам важно чтобы этот модуль был устанолвен в питоне.
посмотрим от него справку. к сожалению из консоли справка гавно

 >>> help(venv)

а вот в таком режиме

 $ pythom -m venv -h
толку больше

usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps]
            ENV_DIR [ENV_DIR ...]

по факту нам нужен тлоько один ключ это ENV_DIR он укаывает в какую папку надо поставить
все хрени чтобы это была как бы автономаная инсталляция питон интерперетатора.
это суперважная штука потому что так часто бывает что мы ставим питон модуль-пакет а он требует
наличия других модулей-пакетов привем опредеелнных версий. а это может нахрен сломать всю эту
питона шарманку. потому что часто разные модули треюуют в системе наличчие разных версий одного
и того же модуля. например  я ставлю модуль-пакет А  и требует наличия в системе модуль-Б версии 1.1
и потом ставлю модуль-пакет C а он трбует налиичия в системе модуль-Б версии 1.2 и полчается
конфликт. поэтому такая дебиьная сситема. -- если я ставлю в систему какойто питон модуль не
через pacman менедже а руками или через pip менеджер ( о нем дальше) то нужно делать 
автномную инсталляицю питон интрпетатора в одельную папку. и там уже ставить все что заблаго
расудится. это никак не отарзится на питоне общесистмном.

делаем автоному инсталляицю вот так

  $ python -m venv ~/.venv/ansible1

запустить интпререатор питона в из этой папки можно вот так

	$ source  ~/.venv/ansible2/bin/activate
	(ansible2)$ 

	(ansible2)$  python
	>>> hepl ('modules')
	...
	pip


чем нам важен этот модуль. тем что он лезет в центарльный репозиторий питона и оттуда 
устанавливает модуль котоырй мы скажем. так вот ансибль это тоже модуль-пакет питона!
и ставим мы его вот так

	(ansible2)$ pip install ansible

а лучше вот так

	(ansible2)$  pythom -m pip install ansible

проверяем

	 $ python -m pip list | grep ansible
	ansible      10.5.0
	ansible-core 2.17.5

правда потом почему то вот так хреново срабатывает

 $ python -m ansible "--version"
usage: python -m ansible {adhoc,config,connection,console,doc,galaxy,inventory,playbook,pull,vault,test}
python -m ansible: error: the following arguments are required: entry_point

только вот так

$ ansible --version
ansible [core 2.17.5]
  config file = None
  configured module search path = ['/home/noroot/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/noroot/.venv/ansible2/lib/python3.12/site-packages/ansible
  ansible collection location = /home/noroot/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/noroot/.venv/ansible2/bin/ansible
  python version = 3.12.6 (main, Sep  8 2024, 13:18:56) [GCC 14.2.1 20240805] (/home/noroot/.venv/ansible2/bin/python)
  jinja version = 3.1.4
  libyaml = True

хотя наверное я понимаю. может быть. 
в итоге у нас есть модуль питона ansible
лежит вот здесь

>>> import ansible
>>> ansible.__file__
'/home/noroot/.venv/ansible2/lib/python3.12/site-packages/ansible/__init__.py'

а есть фронт-енд файл который с этим модулем работат. тоже на питоне написан.
но лежит вот тут

$ which ansible
	~/.venv/ansible2/bin/ansible

 $ file  $(which ansible)
/home/noroot/.venv/ansible2/bin/ansible: Python script, ASCII text executable

тоесть это тоже питон скрипт. но это модуль-файл. а тот ансибль это модуль-папка.
это разные вещи.










теперь проверим устанолвен ли модуль pip

>>> help('modules')

ищем в списке pip

если его там нет то нужно через пакетный менеджер поставить пакет в котором будет 
два слова python и pip

	$ pacman -Q | grep python | grep pip
	python-pip 24.2-1
	python-pipx 1.6.0-1


далее к сожалению нихера не понял как сидя в питон консоли запустить модуль питона.
но что значит запустить модуль. на самом деле это означает как я понимаю что нужно запустить
некотоую функцию из этого модуля с параметрами. нокак это сделать из консоли питона я 
непонял.

вот список функций которые выставлены наружу в модуле

>>> help('pip')

Help on package pip:

NAME
    pip

PACKAGE CONTENTS
    __main__
    __pip-runner__
    _internal (package)
    _vendor (package)

FUNCTIONS
    main(args: Optional[List[str]] = None) -> int


тоесть есл я понял то модуль нам при импторте дает функцию main()
но ее вызов нихера недает

 >>> pip.main()

но можно запусить код модуля неиз консоли а неинтерактивно

	 $ python3  -m pip help


и через этот модуль pip можно ставить модули питона которые лежат в интернете в центральном
репозитории питона.
для начала можно посмотреть какие модули устанолвены в питоне но чтобы нам показала это не 
консоль питона а этот модуль

 	 $ python3  -m pip  list 2>/dev/null | grep pip
		pip                 24.2

это именно список модулей питона а не какието там пакеты самого pip. нет нихуя.
сам pip слава богу своего формата модулей не придумал. 

однако странно. если я ищу модуль venv через pip то покажет что такого модуля нет

	$ python3  -m pip  list 2>/dev/null | grep venv
    пусто

 а если  я ищу через консоль питона

 	$ python3
 	>>> help ('modules')
 	...
 	venv

если я запущу
  
    >>> help('venv')
	NAME
    	venv - Virtual environment (venv) package for Python. Based on PEP 405.

	MODULE REFERENCE
    	https://docs.python.org/3.12/library/venv.html

    ...

	FILE
    /usr/lib/python3.12/venv/__init__.py

видно где этот мтдуль лежит

значит что удивтельно - через консоль питона хуй посмотришь доки от модуля. 
это можно сделать толкько вне консоли вот так


 $ python3 -m venv -h
usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps]
            ENV_DIR [ENV_DIR ...]

Creates virtual Python environments in one or more target directories.

positional arguments:
  ENV_DIR               A directory to create the environment in.

...
...


модуль venv он нам очень щас будет полезен. потому что он позволяет засунуть все что 
нужно для запуска питон модулей в отдельную папку. типа устанвоить "инстанс" питон интепретатора
в отдельную папку. и далее в этуже папку ставить модули питона. таким образом она будет 
независима от системных файло и папок питона на системе. немешая друг другу. 

так вот. ансибль хранися в центральном репозитории питона как питон модуль может даже более 
точнее как питон пакет. питон пакет это кучка питон модулей какимто макаром соединенных
в одну логическую сущность. хуй знает. я рассатриваю в чем разица между модулем питона
и пакетом питона в python.txt 
так вот 



