| nvme



  # nvme format  /dev/nvme0 -n1 -b4096 -s1 -p0 -m0 -r -f

  # nvme  id-ns /dev/nvme0 -n1  -H



| parted

print = поазывает партишены
тоесть схему партишенов. тоесть она для каждого партишена показывает его первый и 
последний сектор. 

print free =  покажет первый и последний сектор на диске который невходит ни 
в один партишен. Так вот  что интересно если только юзать схему партишенов

  # mklabel gpt

и посмотреть  

  # print free

то он покажет что свободное место начинается с 6 сектора. тоесть первые 6 секторов
заняты схемой партишенов ( так назвыаемый LABEL)
print его не покажет. 

mkpart  primary  fat32  1MiB 10MiB 

Так вот прикол в том что  parted последний сектор партишена сделает не 10MiB а
10MiB-1сектор



parted  нач_сектор конеч_сектор 
вторая цифра это не размер раздела. а именно адрес конечного сектора раздела.


| nvme

nvme0  n1  


nvme0 - имя контроллера
n1 - имя неймспейса

nvme0n1 - это аналог sda как по старому


| parted

пример диск с сектором 4 КБайт

   # mkpart  primary  fat32  256s 10MiB
   # units
   # p

   Number   Start   End     Size   FS
     1      256s    2559s   2304s  fat32


видно что конец партишена имеет 2559s но мы заказывали другой конец 10MiB =
= (10*1024)/4=2560s


Тоесть вместо заказанного 2560s  parted сделал последним сектором 2559s тоесть 10MiB-1сектор

Хотя если использовать именно сектора то приказ будет выполнен в точности

   # rm 1
   # mkpart  primary fat32  256s  2560s
он точно так и сделает старт 256s  и последний сектор 2560s , а если вот так


  # mkpart primary fat32  1MiB  10MiB
то последний сектор будет 10MiB-1сектор

  # unit s
  # p


   Number   Start   End     Size   FS
     1      256s    2559s   ...    ...

причем если выставить юниты МБ

  # unit MiB


то он наврет и скажет что якобы партишен заканчиыается в 10MiB

  # p

   Number   Start     End     Size   FS
     1      1.00MiB   10MiB   ...    ...
                      /|\
                       |
                     это брехня


поэтому работает такая штука

# mkpart  primary fat32 1MiB 100MiB
# mkpart  primary fat32 100MiB  200MiB


Казалось бы будет пересечение партишенов. Но нет. Т.К. если мы (как я уже сказал)
указали конец у партишена не через сектора то parted отнмает  1 сектор тоесть 
100MiB по факту будет (100MiB-1sector)
поэтому пересечения нет.


Если gpt лейбл то при создании партишена какой какой смысл  писать primary?

  # mkpart  primary fat32 1MiB  100MiB

ответ никакого. Это для msdos (MBR) лейбла есть primary , extended, logical 
пртишены. у GPT  диска этого нет! но parted почемуто даже для GPT диска застав
ляет primary указывать. 

получается parted покажет правду про разбивку на партишены только если 
юниты указаны в секторах. В остальных единицах он может ВРАТЬ!!!

какой смысл  указывать тип FS котрая будет лежать на партиешене при создании
партишена через parted. ==> я не знаю! как будет влиять указанный тип FS 
при создании партишена на то что потом будет лежать на партишене хрен знает!

	# info parted

	# align-check min/opt 1


!!! в mkpart необязателно добавлять primary  если у нас  GPT схема разделов

	# mkpart  xfs 1MiB 100MiB

общий формат 
 	mkpart [ PART-TYPE  NAME FS-TYPE] START END


 	# mkpart boot fat32  20MiB 512MiB
 	# mkpart swap linux-swap(v1) 512MiB 16GiB
 	# mkpart other xfs 16GiB 92%

 	где other это имя партишена, xfs тип FS будущей


 	# info parted
 	говорит о том что USB флэшки сделанные в 2011-2012 годах
 	что для них партишены нужно делать выровненные на 4МБ

 	далее там про флаги
 	ESP флаг = UEFI

 	# set  1 ESP on

при установке манажаро  помимо разбивки на партиции нужно еще руками отформат
тиовать 
		#mkfs.vfat -f32 /dev/sda1
		#mkswap /dev/sda2
		#mkfs.xfs /dev/sda3

parted флаги. 
  это походу флаги партишена. когда он пишет File System то не факт что на парт
  тишене именно эта FS. "File System" это тоже видимо какоето свойство партишена
  но не того что реально лежит внутри паритишена. вот такая наебка.



  parted:
     model: название диска железки



  parted:
     partition table: loop 



есть еще cgdisk. как я понял это другая морда к партед.



/proc/sys/kernel/random/uuid


parted flag по факту ???? партишен  GUID
еще по факту это ????????  поменять через TYPE


далее. есть PARTTYPEGUID а есть PARTUID

lsblk -p -o NAME, PARTTYPE, PARTUUID

sudo blkid

далее
Есть блочное устройство  sda и sda1,  для ???? это все равно. Это
просто блочное устройство. что такое партишен. Это искусств метод разделить
физ диск на несколько вирт дисков и все. для линукса нет нкиаких партиенов
а есть блочное устройство. Иногда на бекенде блочного устройства сидит партишен.

далее.
parted, gdisk, они чуют что им подсунут диск. тоесть на нем они ожидают
найти партшен лейбл. для каржодго партшена указан PARRTYPE который подразумевает
что на этом партишене сидит FS. какая там реально FS покажет blkid/lsblk

далее.
задача. 
взять диск и узнать какие FS сидят на его партишенах. 
parted= плохо это делает. 
gdisk= лучше.   
    ef00(EFI system partition)
    8309 (Linux LUKS)

gdisk покажет

	1= EF00 (EFI system partition)
	2= 8309 (Linux LUKS)
	3= 8309 (Linux LUKS)
	4= 8300 (Linux file system)

Если parted подсунуть не диск а чтот другое то он пошлет нахер а gdisk напишет
херню.

1 = VFAT


далее
прикол таблицы разделов. неважно GPT\MBR
раздел может лежать в середине диска. 

|=================================|
|           |       |             |
|           |раздел |             |
|           |       |             |
|           |       |             |
|           |       |             |
|=================================|


а вокруг раздел пустое место. и номер этого партишена будет 2
номер раздела походу определяется на основе какой это кусок от начала диска.
на USB манжаро там первый кусок на диске это пустое место, но ксатти по факту
там данные лежат

далее.
gdisk удобно показывает таблицу партишенов. START END покаазан в секторах
а размер показан в MB и GB

далее
  #lsblk -fs /dev/sda

 мощная команда она показывает разделы которых даже в PARTITION TABLE 	нет.


далее.

parted, gdisk - им нужно скармилвать блочное устройство диск. не не блочное
устройство партишены. чтобы получит инфо о призволльном блочном устройстве надо
юзать blkid или lsblk

далее
можно разбит файл на партиции. но как на эту партицию писать непонятно

ДАЛЕЕ
   
   # parted
   # mklabel gpt
   # p free

 можно увидеть колько секторов ушло на организацию лейбла.(таблрцы разделов)

далее.
parted, blkid, lsblk они FS  показывают не на основе флага в таблице партишенов.
а они читают контент лежащий на партиешене. 
получается в вводе лежащем на партишене важная штука это FSTYPE  ане партишен
инфо. Смотри какой  FSTYPE  а потом проверяем утилитами которые облуживают
эту FS что там реаьно лежит. Partition info и контент на партишене (фс реальная)
могут несовпадать. fstype который мы указываем при создании партишена влияет
только на GUID партишена и больше ни на что. тоесть он ни на что не влияет.




