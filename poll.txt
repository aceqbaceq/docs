| poll

значит преед чтением этой статьи я советют вначале прочитьа select.txt
и только потом уже эту.

значит я писал в select.txt в самом низу про его минусы.
читай об этом там.

был придуман poll() как более крутая штука по сравнению с select()

а именно если в select() мы передаем ссылку на битовую хрень в которой
закодировано какие номера дескрпиторов нас интереуют 

 1 101010 01010101 10101010101


и нужно ядру сидеть и каждый бит проверять на тему того интерасует он нас
или нет. тоесть в селект мы преедаем инфо и о тех дескрпиторрах которые нас НЕ интерсуеют
так и инфо отех дескрпиторах которые нас интересуют.

то в poll() мы передаем инфо только о тех дескрипторах котоыре нас реано интерсуют.
тоесть ядру ненужно вычленять из входного потока инфо о тех дескрипторах которые нас релаьно
интерауют из массив где указаны дескрпиторы котооые нас неинтерсуют и которые нас интересуют.

второй плюс что при повторном использовании селект мы должны массив из дескрпиторов
формирвать заново снуля. если даже номера интересующих нас дерпиоров не имзенислись. 
а вот в poll() мы задаем эту структуту данных один раз . и при повторном запуске poll()
нам ненужно ее заполнять заново. это тоже плюс.

От ИИ я только недобился что еще такого есть в poll() из за чего он работает быстрее чем
select()

правад у селект есть какой плюс. если я хочу передать в селект инфо об одном десприпторе то 
мне для этого нужен 1 бит. а полл этот занимает 8 байт.

как я понял селект вызов это удел старых ядер. его стоит примерять если я собиараюсь
запускать мою программу на супер старых ядрах и опрашивать не более чем 1024 дескрпитора
причем макм номер десприптора это 1023

poll() это замена селект на более новых ядрах линукса

значит   я прочитал 

  $ man 2 poll


там ест пример программы. я ее засунул в 257.c

значит когда юзаем poll() то ему нужно подготовить структуру в которой мы укаыазем
те деспрптторы котоыре поллл должен отслеживать. каждый десприптто имеет вот такую хрень 
которая его опиывает

     struct pollfd {
               int   fd;         /* file descriptor */
               short events;     /* requested events */
               short revents;    /* returned events */
           };



итак для каждого дескприптора.
в первое поле "fd" суем номер дсеприптора. 
во втоое поле суем "events" событиЕ или событиЯ которые мы бы хотели поймать.
в третьем поле "revents" ядро указыват то событиЕ или событиЯ которые проищошли с этим 
десприпттором. 

прикол ужасный состоит в том что ядро вернется из полл внезависимости тех событий которые мы 
указали в поле "events". в этом полный дебилизм этого поля. ядро верентся при ЛЮБОМ событии
котоое случится с дескприптором и запишет его в третье поле внезависиомсти от того что мы
указали во втором поле.  таким обрзаом то что мы пишем во втором поле это просто нам же напомин
алка что мы хотели поймать. а в теретьем поле указао что реально произошло.

также важный момент в том что с десприптором может прозойти неодно а сразу несклоько событий
и об этом будет должено в третьем поле. события  во втором и третьем полях кодируются через биты.
поэтому то в одном поле успешно заширофрвывается несклоько событий одновременно без проблем.
а что значит несколько событий с дескприпттомоом произошли одновременно? а вот что скжажем мы
открыли файл пайпа. скажем с той стороны тоже открыли второй конец пайпа сунули в него байты
и закрыли тот конец. так вот это все будет зафикисровано. и полл вернет два индикатора

	POLLIN и POLLHUP

перый указывает нам что в нашем файле чтото появилось и это можно прочитать без блокировки
а второе означает что с той стороны закрыли тот конец пайпа. 
вот как это выглядит в strace

	poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLIN|POLLHUP}])

в этой строке

	fd=3, revents=POLLIN|POLLHUP

он показывает что для fd=3 произлшли события POLLIN+POLLHUP
тоесть в наш fd=3 прилетеели байты которые можно прочитать и что с той стороны закрыли файл
того второго конца пайпа.

значит POLLHUP флаг вылезает если с той стороны процесс выполнил close() над файлом который
является той стороной пайпа , при условии что мы через poll отслеживам нащу сторону пайпа.
далее важно понять что если мы повторно запустим poll() то он многвенно к нам вернется с POLLHUP
тоесть в ядре это событие не сбрасывается. а остается навсегда пока у нас ктото с той стороны
не откроет заново ту сторону пайпа.
вот так это будет выглядеть в стрейс

poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLHUP}])
poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLHUP}])
poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLHUP}])
poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLHUP}])
poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLHUP}])
poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLHUP}])
poll([{fd=3, events=POLLIN}], 1, -1)    = 1 ([{fd=3, revents=POLLHUP}])

бесконечный поток этих событий. 

тоесть полл возрващает нам POLLHUP в том случае когда стой стороны процесс выполнил close()
тоесть это событие оно как бы нам намекает что с той стороны файла пайпа уже нет никакого
процесса и что ждать оттуда чттобы чтото прилетело бесполезно. но все таки строго гооворя
это значит то что тот конец пайпа тоесть тот второй файл неоткрыт. или закрыт что одно и тоже.
при работе с пайпом ядро блокирует open() до тех пор пока еще оди процесс не откроет тот
второй файл который второй конец пайпа. тоесть невзможно  "открыть" файл пайпа (именноый пайп я имею ввиду) и получить десприптор если одновременно нет второго процесса который бы пытался 
открыть тот второй конец пайпа. поэтому POLLHUP будет означать что тот конец был открыт
но процесс закрыл через close() тот конец.  в случае если мы раотаем с tcp сокетом то 
pollhup веренется если с той стороны выполнили shutdown()
итак я пыатаюсь себе рзяснить о чем думать если я увидел POLLHUP. 
итак если мы работаем с пайпом то это значит что файл который тот конец пайпа был закрыт
через close() именно на событие close() с той стороны с этой стороны poll() вернем POLLHUP
если это tcp сокет то на событие shutdown() или close() вернет нам с этой стороны POLLHUP
когда процесс с той стороны запишет в пайп и сразу его закроет то с этой стороны полл
вернет POLLIN+POLLHUP 
если мы с нашей стороны непрочитаем того что лежит в пайпе то повтооный вызов poll 
вернет нам POLLIN+POLLHUP потому что с точки зрения нашего десприптоора ничего не изменилось. 
тоесть данные как лежали в пайпе так и лежат и та сторона пайпа как была закрыта так и продолжает
быть закрытой. еще раз повторный вызов poll вернет тоже самое POLLIN+POLLHUP,
если мы прочитаем данные из пайпа то флаг POLLIN будет сброшен а POLLHUP останется потому что
тот конец пайпа как был закрыт так и остатся закрыт. 

кстати вот мы видим список открытых файлов у процесса. например 

  $ lsof -Pnp $(pidof 260.exe) 2>/dev/null
COMMAND     PID   USER  FD   TYPE DEVICE SIZE/OFF      NODE NAME
260.exe 3033750 noroot cwd    DIR  254,0    12288 403710483 /home/noroot/git/docs/C
260.exe 3033750 noroot rtd    DIR  254,0      234       128 /
260.exe 3033750 noroot txt    REG  254,0    15784 403776588 /home/noroot/git/docs/C/260.exe
260.exe 3033750 noroot mem    REG  254,0  2014520     55931 /usr/lib/libc.so.6
260.exe 3033750 noroot mem    REG  254,0   228376     46492 /usr/lib/ld-linux-x86-64.so.2
260.exe 3033750 noroot   0u   CHR 136,86      0t0        89 /dev/pts/86
260.exe 3033750 noroot   1w   CHR    1,3      0t0         4 /dev/null
260.exe 3033750 noroot   2u   CHR 136,86      0t0        89 /dev/pts/86


так вот вопрос кто открыывает все эти файлы? особенно шаред библиотеки *so* ? ответ - 
буквально 99% процентов открытых файлов открывает именно юзер код нашего же процесса.
тоесть  в данном случае это файлы
вот трейс для нашего процесса

 $ strace -e openat ./260.exe  1>/dev/null
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/home/noroot/temp/nc/fifo1", O_RDONLY

остальная часть файлов открытых - это унаследоанные открытые файлы от парент процесса 
потому что наш проецсс был получаен при клонировании. и все откртые файлы парент процесса
унаследовал и наш процесс.
что касается верхних трех файлой

	/home/noroot/git/docs/C
	/
	/home/noroot/git/docs/C/260.exe

то их открывает для нашего процесса  видимо ядро при создании нашего процесса
но вот вопрос еще интересный вот я вижу

openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libc.so.6", O_RDONLY|O_CLOEXEC) = 3

но в моем коде нет таких команд у меня в коде нет команда

 open(/etc/ld.so.cache)
 open(/usr/lib/libc.so.6)

так вот дело в том что как я понимаю это компилятор при создании конечного файла ДОБАВЛЯЕТ
эти команды в нашу программу без нашего ведома. вот откуда это берется в коде нашей програмы

теперь возвращаюсь к нашему poll() я проверил на примере программ 258.exe и 260.exe то что
если я пишу на той стороне в пайп но не закрываю то полл мне возвратит только POLLIN
сообщая что в наш файл чтото прилетело. если повторно взыывать полл то он мгнвенно возвращается
опять же с POLLIN. это лоично - потому что байты по прежнму лежат в ффайле никуда не делись
ждуть когда мы их прочтем. если же я на той стороны запишу и также сразу закрою десприпттор
на той стороне то полл вернет сразу POLLIN + POLLHUP, таким образом полл нам сообщает о том 
что в наш десриптор чтото прилтело а на той стороне десприпртор закрыли. в целом флаги
POLLIN и POLLHUP это я так понимаю свойства которые ядро записывает в  десприпттор который
мы открыли. и что забавно что он записыват в него нетолько свойства которые касаются нетльлко
свойств файла на который указывает указывает наш дескприптор но также в наш десприптор запис
ываеся информация о состоянии либо файла либо десприптоора с той стороны пайпа. вот это 
очень неоычно и примечательно. тоесть в нашем десприпторе запмыватся POLLHUP обозначая
что десприптор на той стороне закрыт. это офигеть
если мы прочитаем байты из файла на который укавзывает наш десприпттор то 
при повторном вызове полл он флаг POLLIN не вернет. он будет сброшен 
зато он снова вернет флаг  POLLHUP . потому что в  дсекрпиторе по прженму этот флаг устанолвен.
потому что файл с той стороны по прежнему закрыт и ядро не собирается обнулять флаг POLLHUP
в нашем дескрипторе.
теперь когда с флагами несклкьо разобралсис. посмотрим как огранзовывыать работу с poll()
как его "готовить"



 L 儕  $ 
 K ¹  $ cat 260.c
#include <stdio.h>
#include <unistd.h>
#include <poll.h>
#include <unistd.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>



int main() {


int fd;
mode_t mode = O_RDONLY;
char *filename = "/home/noroot/temp/nc/fifo1";
fd = open(filename, mode);

if (fd < 0) {
      perror("Creation error");
      exit (1);
}



    struct pollfd fds[1];
    fds[0].fd = fd;
    fds[0].events = POLLIN;
    fds[0].revents = 0;


//    while (1) {
        int ret = poll(fds, 1, -1);
        if (fds[0].revents & POLLIN) {
            printf("Something on fd!\n");
                 char buffer[256];
                 int len = read(fd, buffer, sizeof(buffer) - 1);
                 if (len > 0) {
                    buffer[len] = '\0';  // Null-terminate the string
                    printf("READ DATA FROM fd : %s", buffer);
                 }


        }

        if (fds[0].revents & POLLHUP) {
            printf("Something on fd!\n");
        }


sleep(60);
//    }

exit (0);
}


вот у нас есть какйото десрпитор у процесса скажем fd
я обьявяляю перемннную fds[] которая массив и элементом этого массив явялется структ pollfd

    struct pollfd fds[1];

далее я заношу значения в этот элемент структ
я заношу номер десприптора, я заношу желамое событие которое я хочу отловить и в третьем
поле я просто ставлю 0.

    fds[0].fd = fd;
    fds[0].events = POLLIN;
    fds[0].revents = 0;

пооллин при возврате в тертьем поле возвратит в виде битовой маски набор флагов которые 
кодируют события которые с десприптором произошли.
вот и я все подготовка перед запуском poll()
итак первое поле это номер дсеприптора за котормы мы хоим следить. второе поле это вобщемто
чушь собачья. а третье поле это туда полл запишет те события которые с дескрпитором произошли.
запишет он их туда в форме битовой маски потому что событий может быть сразу несклько. 
как расшифрвать эту битовую маску покажу ниже. 
если я хочу еще один десприпттор за ним следить то надо вот так его одавиьб


    fds[1].fd = 5;
    fds[1].events = POLLIN;
    fds[1].revents = 0;

таким макаром  я добавил еще десприпттор номер 5 для слежения
ну и конечно для этого вот тут

    struct pollfd fds[1];

нужно указать нужный размер массива.
потому что мы добавили новвый элемент в массив

на счет значения второго поля - туда заносятся те флаги а ля те события которые мы бы хотели 
поймать через полл. однако это поле неимеет никакой силы. потому что полл вернется при наступлении
любых событий а не тех что мы от него просили! поэтому второе поле оно лишь нужно нам для 
того чтобы вспомнить что мы хотели поаймать через полл и сравнт с тем что в итоге этот полл 
нам поймал и вернул. вэтом неыбчная дебилная логика полл.

дальше все готоово и мы запускаем полл

 int ret = poll(fds, 1, -1);

как его резулбттат он в нашем массиве для кжадого элемента с которым чтото произошло
поменял третье поле. теперь нам надо пройти по всем элементам массива и провероить
поменялось ли там чтото и ли нет. кстати то что будет взвращено в ret это будет количство
десприпторов суммарное  с которым чтото произошло. 
так вот как выглядит проверка элемента [0] на наличие установленного флага POLLIN


        if (fds[0].revents & POLLIN) {
        ..
        ..
                 }


соотвесвтенно вот кусок как нам в этом случае считать из файла 
ведь POLLIN нам указывает что в файле чтото появилось


        if (fds[0].revents & POLLIN) {
            printf("Something on fd!\n");
                 char buffer[256];
                 int len = read(fd, buffer, sizeof(buffer) - 1);
                 if (len > 0) {
                    buffer[len] = '\0';  // Null-terminate the string
                    printf("READ DATA FROM fd : %s", buffer);
                 }


если хотим проверить на POLLHUP то делать это над вот так


        if (fds[0].revents & POLLHUP) {
        ..
        ..
                 }



соотсвтвенно если мы получили с той стороны такой флаг то пайп уже закрыт и дальше 
нам ждать что с пайпа чтото прилетит нет смысла. и надо закрывть файл пайпа  с нашей стороны
сбросить этот флаг никак не получится. поэтому надо закрывтвать файл  и отркрвыыват его заново,
на операции открытия ядро заблокирует наш вызов пока с той стороны не откроют пайп заново.
а если просто оставить poll() в цикле while() то он будет постоянно возвращаться мгновенно 
и таким макамро будет тока грузит цпу ненужными циклами
я модифицировал 260.c вот так


    while (1) {
        int ret = poll(fds, 1, -1);

        if (fds[0].revents & POLLIN) {
            printf("Something on fd!\n");
                 char buffer[256];
                 int len = read(fd, buffer, sizeof(buffer) - 1);
                 if (len > 0) {
                    buffer[len] = '\0';  // Null-terminate the string
                    printf("READ DATA FROM fd : %s", buffer);
                 }
        }


        if (fds[0].revents & POLLHUP) {
            close (fd);
            fd = open(filename, mode);
        }


    }


итак плюсы этой хрени поллл() перед селект()  видны.
еще добалю что также как в третьей строке у нас через битовую маску ядро может засунуть
сразу кучу флагов. так вот также можно засунуть сразу кучу флагов в во вторую строку. 
правда как это сдлать на пратике хрен знает да и пофиг.


значит  в чем минус подхода poll() . насолько я понял когда у сокета меняется статус
то ядро записывает либо в сам сокет либо в какуюто стркутуру связанную с сокетом разные 
флаги например POLLIN. поэтому если ядру нужно понять изменилась ли ситуация с сокетом
на который указыает десриптор то  ядру нужно залезть в сокет и провероить там какие флаги 
стоят.  поэтому когда мы запускаем poll() он  проходит по каждому дескприптору который
мы указали находит сокет на который он укзаывает  , залазиит в этот сокет читаем его
есть ли там какеито флаги или нет.  это тоже труды. если никакой сокет неимеет флагов 
на момент проверки то тогда уже ядро не занимается регуляно проверкой. потому что оно так
хитро делает что если в каком то сокете возникнет событие то ядро это узнает сразу через 
уведомление.  тоесть еще раз - когда мы только запустили poll() то ядру надо пробежаться 
по всем дескриипторам которые мы ему предоставили.  чем больше дескприпторов тем больше
ему надо пробегаться.  но если ни один из сокетов нихрена неимеет событий то дальше ядру
пробегаться ненадо в этом плюс. оно там както хитро все настраивает что если событие пролисходит
на одном из сокетов то ядро об этом узнает сразу без необоходимости повторного сканирования. 
в общем минус в том что когда запустили poll() то вначале ядру нужно сделать перый раз полное
сканиеровние всех сокетов дескрпиторво во всем массиве. поэтому при каждом повторном 
вызове poll() это нужно делать каждый раз. насолко  я понмаю при вызове select там еще 
хуже в том плане что  при вызове poll() ядро сразу имеет массив из интересующих нас
дескприпторов а при вызове select() ядру нужно еще вычленить из массива который ему скормили 
подмассив из интересующих нас дескрипоров. 

тоесть работа select():
мы ему формально скрмиливаем массив в котором есть как интерсующие нас дескприпторры
так и не интерсуюищие. ядро вначале сканирует этот массив и вычленяет из него инетрсующие
десприпторы. это первый шаг. на втором шаге скаирует все сокеты на которые указывают выбраные
дескрпиторы. если никакой десприптор не имеет событий то ядро так все хитро настраивает что
если на сокете одного из нужных дескприпторов чтото произойдет то ядро об этом сразу узнает
поэтому повторно сканровать регуляно ненужно.
еще момент - при поворотоном вызове селетка нужно в юзер программе заново удалить и создать
массив дескрипторов. что тоже неклево  плане скоорости. 

как работает poll()
он делает тоже самое но у него остутвует первый шаг, отому что ядро сразу имеет массив
только из дескпрпиторов которые нас интересуют. 
также при повтрном вызове ненужно пересоздавать массив дескрипоров. 
вот и вся разница с селектом. 


как рабтает epoll()
у него нет минусов ни от селект ни от полл. ему даже ненужно делать первый прогон. 
почему  - потому что для полл мы передаем массив как аргумент из юзер спейса тоесть перед вызовом
полл ядро понятие не имеет какие десприпторы имнтересуют нас. 
а при вызове epoll ядро уже зарнее знает какие десприптооры нас интерсуют и ядро заранее
уже подгоотовила эту инфомрацию. потому что мы заранее настучали в ядро о каких деспритороах 
мы будем хотеть иметь инфомрацию. эта инфомрация уже лежит в ядре. уже до того как мы собираемся 
вызвать epoll(). поэтому при вызове poll() ядро незнает о каких деспрпиоторах пойдет речь
и мы эти дескрпиторы тлоько толоько предеаем в ядро. и оно знакмится с их списком а при вызове
epoll ядро уже знает тот список десприпторов который нас интерсует. поэтому еполлу ненужно
делать сканиерование всех этих десприпторов. он заранее зная список заранее закфикировал в 
своей памяти те десрпиторы сокеты которыех изменились.
еще прикол еполл в том что если мы юзаем полл и у нас сокет имеет какйото флаг то при повторном
вызове полл мы опять же этот флаг получим в ответе если с сокетом ничего нового не случилось. 
а вот еполл это можно настраивать. он может также как и полл постоянно возвращает имеющийся
флаг в сокете а может это сделать толко один раз кога этот флаг тлько пояивлися а потом несмотря
на наличие этого флага он нам его возвраащать боьше не будет.  это называется настроить
Level-triggered или edge-triggered. подроности читай в epoll.txt

еще момент - сколько дескрпиторов может иметь процесс. это задает такое свойство у
процесса как softlimit и hardlimit
посмтреть чему они равны для роцесса можно через 



  $ cat /proc/$$/limits 
Limit                     Soft Limit           Hard Limit           Units     
Max cpu time              unlimited            unlimited            seconds   
Max file size             unlimited            unlimited            bytes     
Max data size             unlimited            unlimited            bytes     
Max stack size            8388608              unlimited            bytes     
Max core file size        unlimited            unlimited            bytes     
Max resident set          unlimited            unlimited            bytes     
Max processes             62855                62855                processes 
Max open files            1024                 524288               files     
Max locked memory         8388608              8388608              bytes     
Max address space         unlimited            unlimited            bytes     
Max file locks            unlimited            unlimited            locks     
Max pending signals       62855                62855                signals   
Max msgqueue size         819200               819200               bytes     
Max nice priority         0                    0                    
Max realtime priority     0                    0                    
Max realtime timeout      unlimited            unlimited            us        



вот в частности видно

Limit                     Soft Limit           Hard Limit           Units     
Max open files            1024                 524288               files     


теперь разниа между софтлимит и хардлимит.  процесс можно по дефолту открыть 
файлов столько стлкол указано в софтлимит. но при желании процесс может увелчить софт
лимит до уровня хардлимит. а измнеит хардлимиит можно тлоко через рут права.
обычно эти свойства наслеуются от родиетеля к чайлду. для текуего баш процесса
а следовтелно и для процеграам которые он будет запускать это можно поемнеть через 
билтин баша ulimit.
на уровне системы это можно поменять чрез файл 

    /etc/security/limits.conf

хардлимит тоже имеет сверху ограничение котоерое можно найти в файле 

    $ cat /proc/sys/fs/file-max
      9223372036854775807


кстати много чего можно про параметры процесса посмотреть в /proc/pid/status



еще момент.
вот я беру процесс обычный у котрго как правило  три первых дескрпитооар смотрять на 
файлы терминала


 0 ---> /dev/pts/10
 1 ---> /dev/pts/10
 2 ---> /dev/pts/10

и начиаю через poll() мониторить  скажем все три 

 poll(0,1,2...)

потом я жму кнопку на в графичеком окне скажеи xterm и он посылает эту кнопку в 
файл  /dev/ptmx а ядро посылает эту кнопку тогда в /dev/pts/10 файл.
так вот так как все три десприптора смотрят на этот один и тот же файл то полл вернет
информацию POLLIN ДЛЯ ВСЕХ ТРЕХ ДЕСКРПИТОРОВ 0,1,2  потому что с точки зрения каждого дескрпитора
егоный файл получил байты! это обьянчяет почем полл вернет все три дескриптора и 0 и 1 и 2 
ну и понятно что файл /dev/pts/10 он же особенный некобвконенный. тоесть если я из файла
/dev/pts/10 прочитаю  байты скажем через дескррптор 0  то пробовать читать из этго файла
повторно через люббые десприптооры бесполезно. там уже пусто.  наклоко я понимаю ситация что 
файл опустел она с точки зрения seelct и poll не порождает никаких событий\флагов

ВАЖНЫЙ МОМЕНТ
касается проверки 

        if  ( fds[0].revents & POLLIN ) {
          ...
          ....
         }


так вот знак & означает что мы трубуем чтобы этот флаг был включен а чтотам остльаными
флагами нам похрен. 
а вот такая проверка

        if  ( fds[0].revents == POLLIN ) {
          ...
          ....
         }


она требует чтобы только этот флаг был устанолвен а остальные нет.



следущий момент 
как задать сразу несклько условий
а вот так

    fds[1].events = POLLIN|POLLHUP;

по факту эта хрень активирует биты отдельные.

