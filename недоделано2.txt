-----
info
info info
man man

-----
logrototate = как он заставляет приоложение закрыть файл в который приложение пишет
umask = как это работает
rename = какой сисколл
rm = какой сисколл

как работает эта хрень что место на дсике освооождается
когда закрыт последний файловый десприптор к файлу


touch использует openat()
openat(AT_FDCWD, "1.txt", O_WRONLY|O_CREAT|O_NOCTTY|O_NONBLOCK, 0666) = 3



прикол udev /dev хосится в памяти
# df .
Filesystem     1K-blocks  Used Available Use% Mounted on
udev             8033820     0   8033820   0% /dev

и туда спокойно можно сождававть папки и писать обычные файлы



tty - controlling terminal - controlling process - session leader - session - process group - 

uid, euid, ruis, fuid , ouid, suid
$ ps o uid,euid,ruid,fuid,ouid,suid  -p $$
  UID  EUID  RUID  FUID OWNER  SUID
 1000  1000  1000  1000 1000   1000


 Когда вы применяете sticky bit, пользователь может удалять файлы, только если выполняется одно из следующих условий:

Пользователь является владельцем файла;
Пользователь является владельцем каталога, в котором находится файл.



создал папку ./root c правами
Access: (0754/drwxr-xr--)  Uid: (    0/    root)   Gid: (    0/    root)
существенно то что для others разрешено только чтение (запись и execute запрешена)

далее юзером васей пытаюсь читать список файлов внутри этой папки и получаю:
$ ls  -1 ./root
ls: cannot access './root/root2.txt': Permission denied
ls: cannot access './root/root.txt': Permission denied
ls: cannot access './root/root-dir': Permission denied
root2.txt
root-dir
root.txt


$ ls  -1al ./root
ls: cannot access './root/root2.txt': Permission denied
ls: cannot access './root/.': Permission denied
ls: cannot access './root/root.txt': Permission denied
ls: cannot access './root/root-dir': Permission denied
ls: cannot access './root/..': Permission denied
total 0
d????????? ? ? ? ?            ? .
d????????? ? ? ? ?            ? ..
-????????? ? ? ? ?            ? root2.txt
d????????? ? ? ? ?            ? root-dir
-????????? ? ? ? ?            ? root.txt


тоесть он список файлов читает из папки но неможет прочитать пермишнсы от них

и только если я на папку ./root добавляю пермишнс execute
только тогда он читает и и список файлов и их пермишнсы

$ ls  -1al ./root
total 12
drwxr-xr-x 3 root  root  4096 июн 16 11:15 .
drwxrwxrwx 3 vasya vasya 4096 июн 16 11:11 ..
-rw-r--r-- 1 root  root     0 июн 16 11:15 root2.txt
drwxr--r-- 2 root  root  4096 июн 16 11:15 root-dir
-rw-r--r-- 1 root  root     0 июн 16 11:14 root.txt


походу я понял.
папка это по факту файл. файл этот хранит список файлов
тоесть наша папка это на диске файла типа папка.txt с сооедеоржмимым внутри:
root2.txt
root-dir
root.txt

а как же тога мы проваливаемся в папку что происходит?
по факту мы неможем никуда перейти потому что папка это файл. мы только можем
считать файл но никак туда не"перейти"
когда мы тыкаем в mc войти в папку это по факту мы никуда непроваливаеммся а мы читаем
содержимое файла-папка и получаем список файлов и он этот спмсок отрсиоываыет а нам кажется
что мы провалились в папку. а  по факту мы просто считали содежимре файла.
так вот 

read на папку  - дает то что мы можем читать содержимое этого файла тоесть прочитать солежимое афайла. поскольку внутри файла спсок то мы читая получим список файлоы

так почему же мы неможем при это увидеть пермишнсы на файлы. потому что 
наша папка-файл хранит только имя файлы и его иноду. а пермишнсы от файла они хранятся внутри иноды а не внутри папкифайла. тоест внутри папки файла нет информации о пермишнсах на файл.

тость читай нечитай наша файл-папка в нем этой инфо просто нет!!!!
чтобы пполучиить пермишнсы на файл надо перейти на иноду на диске и считать с нее пермишнсы
на файл.

(найти имя файла по его иноде.)

(прикол еще в том что файл по факту это инода + тело. поэтому файл понятие неимеет о том 
в какой папке о нем упоминается. это как стихотворение в книге. книга и стиъотвоерниея понятия неимют в какой газете о них пишут. вот такая же савязь между файлом и записью о нем в папках)

(интересня штука

fstat(1, {st_dev=makedev(0, 24), st_ino=185, st_mode=S_IFCHR|0620, st_nlink=1, st_uid=1000, st_gid=5, st_blksize=1024, st_blocks=0, st_rdev=makedev(136, 182), st_atime=1655368744 /* 2022-06-16T11:39:04.464846020+0300 */, st_atime_nsec=464846020, st_mtime=1655368744 /* 2022-06-16T11:39:04.464846020+0300 */, st_mtime_nsec=464846020, st_ctime=1655366519 /* 2022-06-16T11:01:59.464846020+0300 */, st_ctime_nsec=464846020}) = 0

fstat - значит смотрели свойства файла. 
а что же это за файл?

лежит этот файл на устройстве с мажром 0 и минором 24 =  st_dev=makedev(0, 24)



)



(sort


$ cat 04.txt; echo "========"; cat 04.txt | sort -k 2.2  -b
111      215    456
222      123    678
111      123    090
222      419    965

========

111      215    456
222      419    965
111      123    090
222      123    678
$ cat 04.txt; echo "========"; cat 04.txt | sort -k 2.2  
111      215    456
222      123    678
111      123    090
222      419    965

========

111      123    090
222      123    678
111      215    456
222      419    965

опчему ??

дефолтовый разделитель полей (fileeds sepratator) это   
 -t, --field-separator=SEP
              use SEP instead of non-blank to blank transition

$ cat 04.txt; echo "========"; cat 04.txt | sort  -t"*" -k2.3
111***!15
222***123
111***123
222***459


========


111***123
222***123
111***!15
222***459
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~/bash$ 
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~/bash$ cat 04.txt; echo "========"; cat 04.txt | sort  -t"*" -k2.4
111***!15
222***123
111***123
222***459


========


111***!15
111***123
222***123
222***459
vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~/bash$ cat 04.txt; echo "========"; cat 04.txt | sort  -t"*" -k2.5
111***!15
222***123
111***123
222***459


========


111***123
222***123
111***!15
222***459

непонятно почему ! стоит ниже чем 1 ведь ! в ascii\utf-8 имеет более маленький код



LC_CTYPE=C.UTF-8

! = 041h
1 = 061h
: = 072h
> = 076h
? = 077h

LC_CTYPE=en_US.UTF-8

! = 041h
1 = 061h
: = 072h
> = 076h
? = 077h

ASCII

! = 021h
1 = 031h
: = 03Ah
> = 03Eh
? = 03Fh

хм.. коды хуйняя. так что онипоказывают?
в чем разница между locale и utf-8 ?

лбщая канва 

ld /dev | sort --> sort ---> c.utf-8 vs en_us.utf-8 ---> locale --> locale vs utf-8 -->
locale vs encoding vs charset ?

все руские буквы в utf-16

$ LC_CTYPE=ru_RU.utf8; for i in {0..47}; do  printf "\xd0\x$(echo "obase=16; ibase=10; 144+$i"| bc)";  done;  LC_CTYPE=ru_RU.utf8; for i in {0..15}; do  printf "\xd1\x$(echo "obase=16; ibase=10; 128+$i"| bc)";  done; echo

АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя


utf8 vs utf16 vs unicode ?


17 16-bit "planes"‡‡ (log₂(17×2¹⁶)≈20.1bits).

unicode:
$ builtin echo -e "\u0428"
Ш

$ builtin echo -e "\u0410"
А

$ builtin echo -e "\u0048 \u0045 \u004C \u004C \u004F"
H E L L O

u0048 = code point. ( по мне это буква другими словами)

на сайте юникода я вижу что code point имеет вид 4 или 5 цифр в hex формате
5 цифра в hex это = 1 048 575 букв закодировано уже в юникод

еще нашел такое определение юникода : Unicode - a mapping of characters to integers ("code points") in the range 0 through 1,114,111 (откуда эта цфиар незнаю)

итак юникод это маппинг буквы в число. для каждой буквы (символа) задается число. 
называется это число code point. обозначается U-XXXXX где X это цифра из hex формата.

Unicode provides a unique number for every character, no matter what the platform, no matter what the program, no matter what the language.

encoding? codepage? charset?

в чем разница преоюрвзаования unicode в utf8 против utf16?
буква Ё
Unicode  = U-0401
UTF-8 = D081h	
UTF-16BE = 0401h
UTF-16LE = 0104h


$echo -e "\u0401"
Ё
$echo -e "\xd0\x81"
Ё

так насколко я понял из pdf документа о юникоде code points они начнаются с U-0000
и заканчиваются U-10FFFF
получается что этим можно закодировать 1 114 112 букв(символов)

как я понял unicode он делает соотвествие между множеством символов и целыми числами.
и это чисто такая математическая абстракция без привязки к компам.
и юникод это не кодировка.

а далее вступает в бой уже кодировка. такая как utf-8,utf16,utf32.
что они делают. они берут это целое число из предыдущего пункта и трансформируют его 
в другое число котороу уже привязано к компьютеру.

в чем прикол такой схемы в том что мы ввели дополнтельный уровень абстракции. 
что это дает. так как кодировка в той или иной мере завязана на подробности компа 
то если архитетктура компа меняется то у нас прерыдущий пункт осатется без изменений
а тольк меняется вот этот пункт которйый нижележащий. и еслискажем программа работает на уровне
предыдущего пунка то ее переписыать ненадо ибо от нее нижний уровень абстракции скрыт.
пока как то так.

As of Unicode version 14.0, there are 144,697 characters

 ISO/IEC 10646-1: 1993 полностью совпдатает с unicode 2.0

 вобщем насколко я понял юникод что он по сути делает он берет символ и дает ему номер порядковый - называется эникод число и обрзначается U-число. число обычно в hex формате.
 номера идут в диапазоне 0-10FFFF (10FFFF это почти три байта) это где то лимон символов можно закодировать. 
 но это чисто математическая хрень к применению на компе это еще негодится. далее юникод 
 предлагает дополниельное преобразование(преобразования бывают UTF-8, UTF-16LE, UTF-16BE, UTF-32 и они прописаны в стандарте юникода) которое берет юникод число и преобрзует в другое
 число и вот это уже число предлгается использовать для обрзначения символ в текстовых 
 файлах на компе. еще я хочу сказать что полный набор символов юникода напоминает язбуку 
 только мировую. туда собраны все символы всех алфавитов мира. полнйы набор символов юникода 
 от U-0 до U-10FFFF называется репертуаром.
  итак еще раз выглядит это так


 символ Ё --> U-0401 ---> (доп преобразование) ----> 81d0
и именно вот этот 81d0 можно использоать в текстовых файлах для обохначение буквы Ё.




 	- зачем двойное преобразование , почему вместо 0x81d0 неиспользовать в текстовых файлах сразу число 0x0401. резонный вопрос. 

 	- есть несколько преобразований. зачем несколко ?
 	- вопросы echo и printf они какой  поддерживают utf8, utf16, utf32?
 	- utf8 он до 1 до 4 байт. utf16 он 2 или 4 байта utf32 он 4 байта толко.
 все они поддерживают кодирование всех U- символов. тоесть полный набор (или говоря языком
 юникод документа весь репертуар). UTF-8 он может для кодирования одного символа использовать
 то 1 до 4 байт. дада. для каких то символов хватит и одного байта а для каких то целых четыре.
UTF-16 кодирует символ либо через 2 байта либо через 4. UTF-32 кодирует символ всегда через 4 байта. нафига такая чехарда. каждый encoding имеет свои плюсы и минусы. расмотрим UTF-8 его фишка в том что если у нас текст сосотоит из английских символов то UTF-8 кодирует каждый английскй симол используя только один байт. если бы мы использовали порядковый номер юникода 
то нам бы нужно было для каждого символа использовать три байта а тут для английских симвлов всего один . получаем сумашедшу экономию в три раза дискового места. плюс коды символов 
в UTF-8 для английских смиволов совпаюают с кодами английских символов в ASCII encoding
таким образом если мы закодировали анлийский текств UTF-8 и отсолали на комп который неумеет 
читать UTF-8 а умеет только ASCII то он покажет текст абсолютно коректно! в этом тоже 
чудесная особенность UTF-8 его преимущество. буквы руского алфавта занимв ают по 2 байта на символ это уже конечно больше чем один байт на символ для анлглийской буквы но это занимает 
меньше чем три байта если бы мы испльзовали в качестве байтов unicod номер который три байта длинной. если мы насуем в одини тот же текстовый файл буквы из английского и руского алфавита
в кодировке UTF-8 и пошлем на комп который только умеет ASCII показывать то человек там увидит 
только ангийские буквы коректно. так что то что символы U-0 U-127 которые отвечают за английский алфавит они кодирутся всего одним байтом и эти байты совпадают с кодиовкой ASCII это очень даже большой плюс.
>B чем прикол utf16. во первых она уже несовместима с ASCII. упс! несмертельно но неприятно. 
у нас могут быть старые проги которые выдают поток байтов наружу думая что надо выдавать ASCII. поэтому программ будт думать что она выдает буквы AB а UTF16 будет думать что надо печататаь на экране QW. прикол UTF16 в том что  в юникоде весь набор симоволов все множество (или как они говорят репертуар) он разделен на planes. каждый plane это 65536 символов. так вот  в plane 0 который зовется BMP они включили самые часто используемые символы.  а так как 
65536 это 16бит то получается что через UTF-16 весь этот набор символов BMP он вмещается
в кодировку через два байта. это дает то что если у нас тексты многоязычные и мы будем 
их кодировать через UTF-8 и UTF-16 то скорей всего на UTF-8 с одной стороны часть символов 
будет представлена через однобайтное выражение (английские символы) что более выигрышно
по сравннеию с двух байтным в UTF-16 но часть символов будет идти в трехбайтном представлении
 что менее выгрыно по сравнеию с UTF-16. конечно же часть символов в UTf8 будет идти в двухбайтном выражении также как это есть в UTF-16 что неделает разницы. таким образом
 на какихто текстах и каких то обьемах UTF16 может дать меньший обьем на диске в случае когда тексты многоязычные. я так понимаю. но конешно очень серьезные минусы UTF-16  в том что
 если тексты ангийский то он будет занимать в 2 раза больше чем в UTF8. и то что он ASCII несовместим. есть правда очень сильный плюс utf16  в том что если мы хотим напечатать букву из какого то языка то с огромной доолей вероятности она вхоит в plane0 и это значит что 
 номер в формате юникода U-1234 автоматом нам дает байтовое представление в кодировке UTF16
 потому что она будет точно такая же. примеры:
буква  Ё 
Unicode: U-0401
UTF-16 Encoding:	0x0401

арабская буква ؈
Unicode:U-0608
UTF-16: 0x0608

таким зная порядковый номер буквы в юникоде мы сразу с огромной долей вероятности можем
коректно налету получить байтовое представлени в UTF16. потому что оно ровно такоеже.
Для сравнения двухбайтовое представление в UTF-8 оно коренным образом непростое из юникод номера. например буква Ё(U-0401) в UTf-8 имеет вид 0xD081. согласись что 0401 в D081 никак налету неполучить в уме. поэтому в этом огромная фишка UTF-16.
 >UTF32 дает толлько то что все аюсолютрно символы занимают одинаковый размер 4 байта. хотя мне непонятно зачем было 4 байта когда можно было 3 байта сделать ведь на дайннйы момент
 весь набор эникода это 10FFFF что составляет три байта в ширину. 
 > в целом прикол юникода в том (неважно в какой кодировке UTF8\16\32 хотя utf8 по мне самая сильная кодировка) у нас в тексте который закодирован в utf8\16\32 могут идти слова предложения и буквы сразу из всех языков мира одновременно.
 В любом случае теперь видно почему на компы в текстовые файлы не стали шарашит порядковые
 номера юникода для символов. потому что еси ввести допонительный слой абстракции\преобразования из юникод номера в некоторый новый номер через UTF-8\16\32 то  в определенных случаях у нас получаются более выигрышные по обьему тексты (более маленькие) плюс обратная совместимость с ASCII. и вобще кто знает какой в будущем более выгодный encoding вместо UTF-8\16\32 придумают но при этом то класно непридется менять юникод номера. 
 это очень умно на будущее придумано. дополниельный уровень абстракции на нижнем уровне позоволяет играться с ним менять в будущем и при этом оставить без измеений верхний уровень. очень умно.  также предвариетльно насколько я понял фишка этого энкодинга в том что 
 байтовое представление из юникод номера ровно такое же самое как юникод номер.тоесть зная юникод номер мы сразу знаем предствлени этого символ в utf32 байтовом виде. тоесть для примера
 символ 🌈
Unicode: U-1F308
UTF-32 Encoding:	0x0001F308
ну что очень удобно.

>далее. про терминологию юникода:
code point - 
я узнал как назыается вот это число после U-0401. число называется code point.
unicode character -
символ который  поставлен в соотвествие code point называется unicode character. тоесть берется unicode character ( по нашему символ) и ему в соотвествие ставится
unicode code point
code unit -
значит  у нас есть символ в форме юникод числа (code point) и мы берем encoding (UTF8\16\32) и натравливаем на code point и получаем на выходе набор байтов один или  несколько тоесть некоторое множество байтов. так вот в этом наборе байтов один или несколько байтов назыается
code unit. размер code unit (тоесть сколько байтов он поразмеру) зависит от той encoding который мы использовали для преобразования. тоесть в UTF8 размер code unit = 1 байт.
в UTF16 размер code unit = 2 байта. в utf32 размер code unit = 4 байта. еще раз подчеркну что размер code unit завиисит от конкретного encoding. но в рамках этого encoding он фиксированный. тоесть в UTF8 code unit = 1 байт. в рамках UTF8 он всегда 1 байт  и никак иначе. в рамках UTF16 он всегда 2 байта и никак иначе. в рамках UTf32 он всегда 4 байта и никак иначе. ты меня спросишь но в UTF8 бывают character который занимает 4 байта например символ символ 🌈 (Unicode code point: U-1F308) у него UTF-8 Encoding =	0xF0 0x9F 0x8C 0x88 как это связать с однобайтовым code unit. связать так что поскольку символ занимает четыре байта а размер code unit для utf8 один байт это значит что символ занимает 4 code unit. поскольку размер code unit завиисит от encoding то когда мы говорим про то сколько code unit загимает символ то надо всегда упоминать в каком encoding. иначе нет смысла. итак в нашем случае мы имеем
символ: 🌈
юникод chataracter code point:  U-1F308
encoding UTF8: 0xF0 0x9F 0x8C 0x88, поскольку code unit (UTF8) = 1 байт то символ занимает 4 code unit в UTF8
encoding UTF16: 0xD83C 0xDF08, поскольку code unit(UTF16)= 2 байта то символ занимает 2 code point в UTF16
UTF-32 Encoding:	0x0001F308, поскольку code unit(UTF32) = 4 байта то символ занимает 1 code unit.

физический смысла code unit в том что это минимальный размер (в байтах) в котором в данном encoding может быть закодирован целиком символ. но это верно не всегда для всех символов.
в UTF32 всегда code unit кодирует целый символ. а в UTF8 code unit кодирует для ряда символов
символ целиком а для ряда символов только часть символа. в UTF16 code unit для ряда символов
кодирует в себе символ целиком а для ряда символов только часть символа. 
пример.

символ: 🌈
code point:  U-1F308
encoding UTF8: 0xF0 0x9F 0x8C 0x88,

в этом примере code point кодирует в себе только часть символа

символ !
code point = U-0021
encoding UTF-8 = 0x21

а в этом примере code point в себе закодировал символ целиком!

в этом и есть физический смысла code point.
по своей сути code point это один или несколко байтов.
с другой стороны смысл этого code point  в том что внутри него ( в этих байтах) закодирован
либо символ целиком  либо часть символа(зависит от конкретного символа). 

таким образом если мы знаем размер code point в байтах для данной кодировки то мы знаем
минимальный размер в байтах который нужен этой кодировке чтобы закодировать на диске один символ. да это верно порой не для всех символов но хотя бы для части это верно. размер code point нам дает предсталвение о прожорливости encoding при сохранении символов.



это один или несколько байтов который encoding (UTf8\16\32) использует для того чтобы преобразовать code point (символ) в набор байтов.  
значит в каждой кодировке наш character(символ) имеет вид набора байтов. так вот каждый байт 
называется code unit.

 	 - вопрос как же было раньше до юникода? как в тексте можно было использовать несколько
 	 языков. скажем три. 

 	- почему utf8 без endieness. ведь у него до 4 байт.да ивообще а если 1 байт то что ненадо?
	- обьяснить 
		$ hexdump /tmp/r.txt
0000000 9ff0 888c                              
0000004
$ man hexdump
$ hexdump -C /tmp/r.txt
00000000  f0 9f 8c 88                                       |....|
00000004
	- page vs encoding?
	- /bin/echo vs bash builtin echo они какие из utf-8\16\32 поддерживают? 
тожесамое про printf. у него  как с этим.

берем пример
Ё:
Unicode: U-0401
UTF-8 Encoding:	    0xD0 0x81
UTF-16 Encoding:	0x0401
UTF-32 Encoding:	0x00000401

смотрим что написано в 
$ man bash
echo
              \xHH   the eight-bit character whose value is the hexadecimal value HH (one or two hex digits)
              \uHHHH the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHH (one to four hex digits)
              \UHHHHHHHH
                     the Unicode (ISO/IEC 10646) character whose value is the hexadecimal value HHHHHHHH (one to eight hex digits)

значит я разобрался что они хотели этим сказать:
если у нас echo идет вот в  виде echo e "\xHH\xHH\xHH\xHH..."
то ожидается что текс  в кодировке UTF8. 
вот пример
символ 🌈
Unicode: U-1F308
UTF-8 Encoding:	0xF0 0x9F 0x8C 0x88
UTF-16 Encoding:	0xD83C 0xDF08
UTF-32 Encoding:	0x0001F308

$ builtin echo -e "\xF0\x9F\x8C\x88"
🌈

из примера видно что байтовое представление символа в utf16\32 абсолютно несовпадает
с UTF8 однако именно UTF8 байтовое представлеие нам дало символ.
итак если мы вбиваем в echo некий набор байтов в hex виде то echo ожидает что это UTF8 кодировка. 

остальные два способа передачи инфо о символе \uHHHH и \UHHHHHHHH они не про UTF16 или UTF32.
с этими кодировками builtin echo работать неумеет! в опция \uHHHH и \UHHHHHHHH вбиваеися не байтовое представление из какой либо кодировки а непосредственно сам ЮНИКОД номер!! единственное что если юникод номер от одного до четырех символов то можно использовать
как форму \uHHHH так и форму \UHHHHHHHH а вот если юникод номер более четырех символов 
то можно использоваьт только форму \UHHHHHHHH. еще раз хочу подчеркнуть что в эти форму вставляется не байты из кодировок UTF8\16\32 . нет!  в эти формы вставляется непосредтсенно
юникод номер.примеры
символ 🌈
Unicode: U-1F308
UTF-8 Encoding:	0xF0 0x9F 0x8C 0x88
UTF-16 Encoding:	0xD83C 0xDF08
UTF-32 Encoding:	0x0001F308

поскольку юникод номер больше чем 4 цифры то использум форму с большой буквой U тоесть 

$ builtin echo -e "\U1F308"
🌈
