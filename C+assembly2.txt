| C
| assembly


; Вход в функцию foo
push    ebp                    ; Сохраняем старое значение EBP на стеке
mov     ebp, esp               ; Устанавливаем EBP на текущую вершину стека (это начало кадра стека функции)
sub     esp, 8                 ; Выделяем место для локальных переменных (например, 'y' размером 4 байта)
mov     DWORD PTR [ebp-4], 10  ; Сохраняем значение 10 в локальную переменную 'y'

mov     eax, DWORD PTR [ebp+8] ; Загружаем значение параметра 'x' (параметры функции передаются через стек)
add     eax, DWORD PTR [ebp-4] ; Складываем 'x' и 'y', результат в EAX

push    eax                    ; Помещаем результат сложения на стек для передачи в printf
call    printf                ; Вызов функции printf
add     esp, 4                 ; Очищаем стек от одного параметра (результата из eax)

mov     esp, ebp               ; Восстанавливаем ESP из EBP (вершина стека возвращается на место)
pop     ebp                    ; Восстанавливаем старое значение EBP
ret                            ; Возвращаем управление из функции

--


вот программа

 o ⮉  $ 
 " 㤴  $ 
 W 㕷  $ cat 286.c
#include <stdio.h>


int main()  {

   int arr[1] = {0xBB};


   return 0;
}


вот ее асемблер



0000116d <main>:
    116d:	55                   	push   ebp
    116e:	89 e5                	mov    ebp,esp
    1170:	83 e4 f0             	and    esp,0xfffffff0
    1173:	83 ec 10             	sub    esp,0x10
    1176:	e8 32 00 00 00       	call   11ad <__x86.get_pc_thunk.ax>
    117b:	05 79 2e 00 00       	add    eax,0x2e79
    1180:	65 a1 14 00 00 00    	mov    eax,gs:0x14
    1186:	89 44 24 0c          	mov    DWORD PTR [esp+0xc],eax
    118a:	31 c0                	xor    eax,eax
    118c:	c7 44 24 08 bb 00 00 	mov    DWORD PTR [esp+0x8],0xbb
    1193:	00 
    1194:	b8 00 00 00 00       	mov    eax,0x0
    1199:	8b 54 24 0c          	mov    edx,DWORD PTR [esp+0xc]
    119d:	65 2b 15 14 00 00 00 	sub    edx,DWORD PTR gs:0x14
    11a4:	74 05                	je     11ab <main+0x3e>
    11a6:	e8 15 00 00 00       	call   11c0 <__stack_chk_fail_local>
    11ab:	c9                   	leave
    11ac:	c3                   	ret




значит вот эта штука

    1173:	83 ec 10             	sub    esp,0x10

она расширяет стек на 16 байтов 
тоесть к обьему стека прибавляется 16 байт вкотторые можно чтото записать

ESP(старый)
			1
    		2
    		3
    		4
    		5
    		6
    		7
    		8
    		9
    		10
    		11
    		12
    		13
    		14
    		15
ESP(новый) 	16


потом

    1180:	65 a1 14 00 00 00    	mov    eax,gs:0x14
    1186:	89 44 24 0c          	mov    DWORD PTR [esp+0xc],eax

они чииают из памяти из [gs+0x14] и пишут это в eax
а потом они берут то что в eax и пишут это в стек по адресу esp+12
тоесть вот сююда



ESP(старый)
			1
    		2
    		3
    		4 <========= [esp+12]
    		5
    		6
    		7
    		8
    		9
    		10
    		11
    		12
    		13
    		14
    		15
ESP(новый) 	16

у нас eax=4 байта поэтому это как раз занимает байты 4,3,2,1


ESP(старый)
			1 |
    		2 |
    		3 |   EAX
    		4 |
    		5
    		6
    		7
    		8
    		9
    		10
    		11
    		12
    		13
    		14
    		15
ESP(новый) 	16


далее вот эта сторка

   	mov    DWORD PTR [esp+0x8],0xbb

это она как раз делает то что мы закащали в процгрмее

   int arr[1] = {0xBB};

тоже пишет в стек щас покажу куда


ESP(старый)
			1 |
    		2 |
    		3 |   EAX
    		4 |
    		5   || 0x00
    		6   || 0x00
    		7   || 0x00
    		8   || 0xBB
    		9
    		10
    		11
    		12
    		13
    		14
    		15
ESP(новый) 	16

по всей видимости gcc когда пишет в стек то выравыниывает все по 4-байт кратности


далее вот эта штука

    1199:	8b 54 24 0c          	mov    edx,DWORD PTR [esp+0xc]
    119d:	65 2b 15 14 00 00 00 	sub    edx,DWORD PTR gs:0x14
    11a4:	74 05                	je     11ab <main+0x3e>

она читает из стека там где лежит якоы наш eax. потом она вычитает это с тем 
что лежит в памяи по адресу [gs+0x14]. если получаем ноль  то управлению прыгает на 
комаду по адреу 11ab а там лежит вот что 

    11ab:	c9                   	leave
    11ac:	c3                   	ret

тесть если занчение в сткеке канарейка не была имзенена то прогораммавы ходит по номралу.
leave =  
     mov esp , ebp
     pop ebp

ret = pop eip

а если мы не пполучили ноль то значит ктото поломал стек. и прогу надо аварийно выркубть.
для этооо заускается подпрогармма 
   
           	call   11c0 <__stack_chk_fail_local>

таким оюоазом компилятор поимомо нашей воли доавбляет защуту от поломки стека

вот слебущая прогармма

#include <stdio.h>


int main()  {

   int arr[1] = {0xBB};

       arr [2] = 0xAF;
       arr [3] = 0xAF;

   return 0;
}



ее асемблер


0000116d <main>:
    116d:	55                   	push   ebp
    116e:	89 e5                	mov    ebp,esp
    1170:	83 e4 f0             	and    esp,0xfffffff0
    1173:	83 ec 10             	sub    esp,0x10
    1176:	e8 42 00 00 00       	call   11bd <__x86.get_pc_thunk.ax>
    117b:	05 79 2e 00 00       	add    eax,0x2e79
    1180:	65 a1 14 00 00 00    	mov    eax,gs:0x14
    1186:	89 44 24 0c          	mov    DWORD PTR [esp+0xc],eax
    118a:	31 c0                	xor    eax,eax
    118c:	c7 44 24 08 bb 00 00 	mov    DWORD PTR [esp+0x8],0xbb
    1193:	00 
    1194:	c7 44 24 10 af 00 00 	mov    DWORD PTR [esp+0x10],0xaf
    119b:	00 
    119c:	c7 44 24 14 af 00 00 	mov    DWORD PTR [esp+0x14],0xaf
    11a3:	00 
    11a4:	b8 00 00 00 00       	mov    eax,0x0
    11a9:	8b 54 24 0c          	mov    edx,DWORD PTR [esp+0xc]
    11ad:	65 2b 15 14 00 00 00 	sub    edx,DWORD PTR gs:0x14
    11b4:	74 05                	je     11bb <main+0x4e>
    11b6:	e8 15 00 00 00       	call   11d0 <__stack_chk_fail_local>
    11bb:	c9                   	leave
    11bc:	c3                   	ret


так вот кактостранно рабаотет защиатта от оломки стека.
у нас стек увелчивется на 16 байт. защитная хрень пишет в 


ESP+15
ESP+14
ESP+13
ESP+12

тоестб сюда

ESP(старый)
			1 |
    		2 |
    		3 |   EAX
    		4 |
    		5
    		6
    		7
    		8
    		9
    		10
    		11
    		12
    		13
    		14
    		15
ESP(новый) 	16

а мои данные пиштутся вот сюда
 

           -7     || 0x00  <=============
           -6     || 0x00  <=============
           -5     || 0x00  <=============
           -4     || 0xaf  <=============
           -3   || 0x00  <=============
           -2   || 0x00  <=============
           -1   || 0x00  <=============
ESP(старый) 0   || 0xaf  <=============
			1 |
    		2 |
    		3 |   EAX
    		4 |
    		5  || 0x00   <=============
    		6  || 0x00   <=============
    		7  || 0x00   <=============
    		8  || 0xbb   <=============
    		9
    		10
    		11
    		12
    		13
    		14
    		15
ESP(новый) 	16


таким образом комлиятор давет вомзжность поломать данные в стеке тоесть засунуть их 
туда где лежат уже данные от других фнуайий условно.  при этом фоомаьно канарейка не портится
и программа поэтому заверешается асолютно нормальер ! хрень!

======================
следущий момент

в коде часто встречается вызов функции call   11e3 <__x86.get_pc_thunk.ax>
что она делает?  вот пример 


000011c7 <func1>:
    ...
    11ca:	e8 14 00 00 00       	call   11e3 <__x86.get_pc_thunk.ax>
    11cf:	05 25 2e 00 00       	add    eax,0x2e25



000011e3 <__x86.get_pc_thunk.ax>:
    11e3:	8b 04 24             	mov    eax,DWORD PTR [esp]
    11e6:	c3                   	ret
    11e7:	66 90                	xchg   ax,ax
    11e9:	66 90                	xchg   ax,ax
    11eb:	66 90                	xchg   ax,ax
    11ed:	66 90                	xchg   ax,ax
    11ef:	90                   	nop

значит что длает комага call. 
она делает 

    push eip 

а что тавое команад push. это две команды. сдвигается указатель стека на то число байт 
которое пишется в стек. в данном случае eip длинна 4 байта. поэмтму сдвиг идет на -4 байта. а потом пишутся байты по этим новым адресам

     адрес         |    значение
  ------------------------------------
  ESP(старый) 1234 | старые данные 
              1233 |   ++++     
              1232 |   ++++      
              1231 |   ++++        
  ESP(новый)  1230 |   ++++ 

значит на картинке адрес 1234 это указатель стека до вызова call.
соотественно он сдвинул указатель ESP на 4 байта и он стал 1230


     адрес         |    значение
  ------------------------------------
  ESP(старый) 1234 | старые данные 
              1233 |        
              1232 |         
              1231 |           
  ESP(новый)  1230 |    



а далее новые байты пишутся начиная с ESP новый и далее по мере увеличения адресов памяти 
до тех пор пока мы не запишем все 4 байта из eip


     адрес         |    значение
  ------------------------------------
              1234 | старые данные 
              1233 |  +++++      
              1232 |  +++++       
              1231 |  +++++         
  ESP(новый)  1230 |  +++++  


на картике новые данные которые были добавлены в стект показаны плсами


тоесть помщает в стек текущий eip. eip это реистрв  в котором адрес следущей команды.
после этго она делает 
   jmp addres


тогда получается то что как только отработал call у нас в стеке начиная с текйщего
указателя ESP лежит адрес будущей команды возврата. поэтому если мы тут же считаем 
значение из стека то мы узнаем этот адрес. 


ровно это  и делает фнуция   <__x86.get_pc_thunk.ax> на которую  call деает jmp


000011e3 <__x86.get_pc_thunk.ax>:
    11e3:	8b 04 24             	mov    eax,DWORD PTR [esp]
    11e6:	c3                   	ret



поэтому когда мы делаем 
	mov    eax,DWORD PTR [esp]

у нас в eax считаются байты esp, esp+1, esp+2, esp +3

     адрес         |    значение
  ------------------------------------
              1234 | старые данные 
              1233 |  +++++      
              1232 |  +++++       
              1231 |  +++++         
  ESP(новый)  1230 |  +++++  

я их показал плюсами.
и у нас в eax оказывается значение eip которое там было до вызова call. тоесть 11cf

тоесть вся эта щараманка затетвася тлоьк для тго чтобы узнать чему равен eip 
на шаге 11ca. прикол eip в том что егл нелья ни считать через mov
   mov  eax, eip
 и его нельзя напрмую пометитть в стек
   ppush  eip

 поэому надо заставить сам цпу снуть этт eip в стек через call
 потом только его можно счиатть из стека
   mov eax, [esp]

 а потом мы уже возврааешается из фукнции через

   ret

 котрый делает 

 pop eip
 jmp [eip]

тким орбрзаом эта фунция   <__x86.get_pc_thunk.ax> она нам позвоетлет на доюбом этапе
узгать eip и только то.

воо т это т ее хвост котоырй нкогад не запускается
    11e7:	66 90                	xchg   ax,ax
    11e9:	66 90                	xchg   ax,ax
    11eb:	66 90                	xchg   ax,ax
    11ed:	66 90                	xchg   ax,ax
    11ef:	90                   	nop

это читсто для вырвания текста кода не более того. пустышка болкванка напонитель.



=======

следущий этап - надо в main() ызывать другую фнуцикю. и в ней насоват в стек так много
чтобы он соломал стек от main() и посмтреть что выход из программы авариный!

    116d:	8d 4c 24 04          	lea    ecx,[esp+0x4]            | ESP=?
    1171:	83 e4 f0             	and    esp,0xfffffff0           | ESP ? 
    1174:	ff 71 fc             	push   DWORD PTR [ecx-0x4]
    1177:	55                   	push   ebp
    1178:	89 e5                	mov    ebp,esp                  | ESP=A=?, EBP=ESP=A
    117a:	51                   	push   ecx                      | ESP=EBP-4
    117b:	83 ec 14             	sub    esp,0x14                 | ESP=ESP-20 = EBP-24
    117e:	e8 60 00 00 00       	call   11e3 <__x86.get_pc_thunk.ax> | ESP=ESP-4=EBP-28
    1183:	05 71 2e 00 00       	add    eax,0x2e71
    1188:	65 a1 14 00 00 00    	mov    eax,gs:0x14
    118e:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax      | 
    1191:	31 c0                	xor    eax,eax
    1193:	c7 45 f0 bb 00 00 00 	mov    DWORD PTR [ebp-0x10],0xbb    | bb --> ebp-16
    119a:	83 ec 0c             	sub    esp,0xc                      | ESP=ESP-12=EBP-40
    119d:	8d 45 f0             	lea    eax,[ebp-0x10]
    11a0:	50                   	push   eax                          |ESP=ESP-4=EBP-44
    11a1:	e8 21 00 00 00       	call   11c7 <func1>                 | ESP=ESP-4=EBP-48


вот эта команда
	and    esp,0xfffffff0
она обуналеяет младщие 4 бита  в регистре. таким образом адрес в нем ставноится ближайщим
вниз к адреу кратному к числу 16 в десятиной системе. 
наммреер ESP = 1234  = 10011010010 
после этой комнды он будет =  10011010000 = 1232 и оно кратно 16 да. 

зачем это делается. якобы цпу делает push\pop быстрее когда esp выровнен кратно 16.
плюс там еше всякие соглаения есть. итп.

на данном этапе стек у нас будет

EBP=A
ESP=EBP-48


000011c7 <func1>:
    11c7:	55                   	push   ebp       | ESP=ESP-4=EBP-52, EBP=A
    11c8:	89 e5                	mov    ebp,esp   | ESP1=ESP=EBP-52, EBP1=ESP1
    11ca:	e8 14 00 00 00       	call   11e3 <__x86.get_pc_thunk.ax> | eax=11cf
    11cf:	05 25 2e 00 00       	add    eax,0x2e25                   | eax=3ff4
    11d4:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]      | eax=ebp1+8=EBP-44
    11d7:	83 c0 04             	add    eax,0x4                      | eax=EBP-64 
    11da:	c7 00 ff 00 00 00    	mov    DWORD PTR [eax],0xff         | mov [EBP-64], 0xff
    11e0:	90                   	nop
    11e1:	5d                   	pop    ebp
    11e2:	c3                   	ret

бредятна



код

#include <stdio.h>


void func1 ( int b_arr[]);

int main()  {

   int arr[1];
   arr[0] =  0x4E;
   func1 ( arr  );



   return 0;
}



void func1 ( int b_arr[] ) {

    b_arr[0]++ ;

}






void func1 ( int b_arr[] ) {

    printf ("%i", b_arr[0]);

}






    1188:	89 e5                	mov    ebp,esp | EBP=ESP=A
    118a:	51                   	push   ecx        | ESP=A-4
    118b:	83 ec 14             	sub    esp,0x14   | ESP=ESP-18=A-22
    118e:	e8 75 00 00 00       	call   1208 <__x86.get_pc_thunk.ax>
    1193:	05 61 2e 00 00       	add    eax,0x2e61
    1198:	65 a1 14 00 00 00    	mov    eax,gs:0x14
    119e:	89 45 f4             	mov    DWORD PTR [ebp-0xc],eax
    11a1:	31 c0                	xor    eax,eax
    11a3:	c7 45 f0 4e 00 00 00 	mov    DWORD PTR [ebp-0x10],0x4e   | 0x43-> A-14   (!!!)
    11aa:	83 ec 0c             	sub    esp,0xc        | ESP=ESP-12=A-22-12=A-34
    11ad:	8d 45 f0             	lea    eax,[ebp-0x10] | eax = ebp-14=A-14 = (адрес 0x43)
    11b0:	50                   	push   eax            | ESp=esp-4 = A-38 (в A-38 хранится адрес ячейки стека где хранится 0x43)
    11b1:	e8 21 00 00 00       	call   11d7 <func1>   | ESP=ESP-4=A-42


000011c7 <func1>:
    11c7:	55                   	push   ebp   | ESP=EsP-4=A-46
    11c8:	89 e5                	mov    ebp,esp |ESP1=ESP=A-46, EBP1=ESP1=A-46
    11ca:	e8 15 00 00 00       	call   11e4 <__x86.get_pc_thunk.ax>
    11cf:	05 25 2e 00 00       	add    eax,0x2e25
    11d4:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]  | EBP1+8=A-46+8=A-38
    11d7:	8b 00                	mov    eax,DWORD PTR [eax]
    11d9:	8d 50 01             	lea    edx,[eax+0x1]
    11dc:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]
    11df:	89 10                	mov    DWORD PTR [eax],edx
    11e1:	90                   	nop
    11e2:	5d                   	pop    ebp
    11e3:	c3                   	ret

сама пременная 0x43 хранися в A-14
этот адрес A-14 хранится в A-38 

    11d4:	8b 45 08             	mov    eax,DWORD PTR [ebp+0x8]  | EBP1+8=A-46+8=A-38
    11d7:	8b 00                	mov    eax,DWORD PTR [eax]

первая команда считвает в eax адрес [ebp+8]= A-38
тоесть в eax лежит адрес в стеке где хранится  перпеменная 0x4e
вторая комада считвыетт в eax то что лежит в A-38 тоесть 0x4e
таким образом у меня в eax скопровалась пременная 0x4e
далее

   lea    edx,[eax+0x1]

вот эта команда воще то рабтает с адресами. но зесь она испозуется для краткости.
тоест можно было бы заюзат
   add  eax, 1
   mov edx, eax

вмсто этого юзаеют одну команду

   lea    edx,[eax+0x1]

тут не будет никких адресов. она всего анвсего влзьмет то что в eax увелчиит на 1 и запишет 
в edx



----
Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x08048000 0x08048000 0x00094 0x00094 R   0x1000
  LOAD           0x001000 0x08049000 0x08049000 0x00016 0x00016 R E 0x1000
  LOAD           0x002000 0x0804a000 0x0804a000 0x00040 0x00040 R   0x1000


seg1 , start=134 512 640 - 134 512 788 (148b) (R)
seg2 , start=134 516 736 - 134 516 758 (22b ) (R E)
seg3 , start=134 520 832 - 134 520 896 (64b)  (R)
==========================
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        08049000 001000 000016 00  AX  0   0 16
  [ 2] .rodata           PROGBITS        0804a000 002000 000040 00   A  0   0  4
  [ 3] .symtab           SYMTAB          00000000 002040 0000d0 10      4   9  4
  [ 4] .strtab           STRTAB          00000000 002110 000043 00      0   0  1
  [ 5] .shstrtab         STRTAB          00000000 002153 000029 00      0   0  1


Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 1] .text             PROGBITS        08049000 001000 000016 00  AX  0   0 16
  [ 2] .rodata           PROGBITS        0804a000 002000 000040 00   A  0   0  4


.text 08049000 = 134 516 736 ==> попадает в seg2 (R E)
.rodata  0804a000 = 134 520 832 ==> попадает в seg3 (R)



==========================
Align = 0x1000 = 4096 

seg1 134 512 640 / 4096 = 32 840  == выровнен
seg2 , start=134 516 736 /4096 = 32841  = выровнен



----
vСигнал `SIGPIPE` в Linux (и Unix-подобных системах) отправляется процессу в случае, если он пытается записать в сокет или канал (pipe), который уже закрыт на другой стороне. Проще говоря, сигнал отправляется, когда процесс пытается выполнить запись в поток, но на другом конце соединения или канала нет активного процесса, готового принять данные.

Вот типичные сценарии, когда ядро может послать сигнал `SIGPIPE`:

### 1. **Закрытие сокета на стороне получателя**:
   Если вы используете **TCP-соединение** и пытаетесь записать данные в сокет, но удалённая сторона (хост-Б) закрыла соединение (например, с помощью вызова `close()`), тогда попытка записи на этот сокет приведет к тому, что ядро отправит сигнал `SIGPIPE`. Это происходит потому, что удалённый хост больше не может принять данные, и ядро сообщает об ошибке в виде сигнала.
   
   В этом случае ваша программа может обработать сигнал как ошибку и завершиться, если не перехватить сигнал.

### 2. **Закрытие канала (pipe) на другой стороне**:
   Если вы используете **канал** (pipe) для межпроцессного общения (IPC), и процесс, читающий из этого канала, завершился или закрыл его, попытка записи в этот канал вызовет `SIGPIPE`. В Unix-подобных системах каналы работают как потоковые устройства, и если на другом конце канала нет процесса, который читает данные, ядро отправит сигнал `SIGPIPE`.

### 3. **Прерывание записи в сокет, если нет процесса, который может принять данные**:
   Если ваш процесс пытается записать в сокет, но по какой-то причине удалённая сторона не может принять эти данные (например, из-за сетевых проблем или неполного соединения), то в некоторых случаях будет сгенерирован сигнал `SIGPIPE`.

### Как обрабатывается `SIGPIPE`:

- По умолчанию, если процесс получает сигнал `SIGPIPE`, он завершает свою работу (убивает процесс), поскольку это означает, что соединение или канал закрыты.
- Однако можно настроить обработку сигнала `SIGPIPE` в своей программе:
  - Перехватить сигнал с помощью обработчика с помощью `signal(SIGPIPE, handler)`.
  - Или игнорировать его с помощью `signal(SIGPIPE, SIG_IGN)` (при этом при попытке записи в закрытый сокет или канал вызов `write()` вернёт ошибку `EPIPE`, но программа не завершится).
  - Также можно использовать неблокирующие сокеты и проверку состояния соединения, чтобы избежать возникновения `SIGPIPE`.

### Пример:

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <stdlib.h>

void sigpipe_handler(int sig) {
    printf("Received SIGPIPE\n");
    // Тут можно добавить код обработки ошибки или игнорирования
}

int main() {
    signal(SIGPIPE, sigpipe_handler);

    int pipefds[2];
    char msg[] = "Hello, world!";

    if (pipe(pipefds) == -1) {
        perror("pipe");
        exit(1);
    }

    close(pipefds[0]); // Закрываем сторону для чтения

    // Попытка записи в закрытый pipe приведет к SIGPIPE
    if (write(pipefds[1], msg, sizeof(msg)) == -1) {
        perror("write");
    }

    return 0;
}
```

В этом примере, если мы попробуем записать в канал после того, как его сторона для чтения закрыта, будет сгенерирован сигнал `SIGPIPE`. Вы можете перехватить этот сигнал, чтобы программа не завершалась, а в случае записи в закрытый канал вывести ошибку.

### Важно:
Если ваше приложение не обрабатывает `SIGPIPE` или не игнорирует его, оно завершится с ошибкой, как только произойдёт попытка записи в закрытый канал или сокет. Это может быть не всегда желаемое поведение, особенно для сетевых приложений, где лучше заранее проверить состояние соединения перед отправкой данных.
---
так я продолжаю тему про типы данных.
значит зачем компиятору нужны типы данных.

во первых для того чтобы он знал сколько байт данная переенная суммарно 
займет в памяти. а это повлияет на то какие комады асемблера будуи исползованы 
для создания этой перееменной 
например мы пишем

   int a = 10;


тогда условно компилятор видя "int" знает что эта перееменная должна занимать 4 байта.
и он ее создаст через команду


   mov eax,0xA
   push eax


а если бы мы написали 


 double a = 10;

то компилятор бы ее создал через условно команду

 mov rax, 0x0A
 push rax
 
 тоесть она будет занимать 8 байт.


 итак тип данных влияен на тот КАК через кмакие ассемблер команды бует создана переменна я
 в памяти.


 второй момент котоырй дает тип это то через какие команды эта переменная будет считана
 из памяти

тоесть если мы хотим счиать пееренную int то есть 4 байта то 
она будет считана как

 pop eax

а если хоиим счиать перееную  double то она будет считана как

pop rax

похоже?

===
давай заново расмотрим. я там  случайно на энтер нажал
итак

теперь я тебя хочу спросить про это 

   unsigned int a = 10; 
   unsigned int *p = &a;

на даннмо этапе комплиятор знает что  в переенной p лежит адрес на кусок памяти длинной 4 байта. 
вот как это будет выглядеть в памяти. если p=1234 то 

1234 = 0x00
1235 = 0x00
1236 = 0x00
1237= 0x0A

а вот уменя вопрос что происходит дальше

   long unsigned int *b = (long unsigned int*) &p;

тоесть у нас создается новый поинтер *b который будет указывать на кусок памяти длинной 8 байт. 
и вот что будет происходит на асеблере по капотом? 

у нас будет выбран новый адрес в памяти скажем 2000 и сохранен в b?
и будет прочитан 0x0000000A из p и он будет преобразован в 8 байтов и записан  начиная с 2000 вот так

2000 0x00
2000 0x00
тогда 

1234 = 0x00
1235 = 0x00
1236 = 0x00
1237= 0x0A


==---
https://man7.org/linux/man-pages/man5/proc_pid_root.5.html



https://man7.org/linux/man-pages/man5/proc_pid_root.5.html

https://raw.githubusercontent.com/eklitzke/epollet/refs/heads/master/poll.c

https://www.cyberpunk.rs/assembly-basics-32-bit-linux-gdb


https://www.cyberpunk.rs/buffer-overflow-linux-gdb


https://stackoverflow.com/questions/15335003/what-is-the-purpose-of-segment-registers-in-x86-protected-mode

https://wiki.osdev.org/Segmentation

https://stackoverflow.com/questions/32345320/get-return-address-gdb

https://stackoverflow.com/questions/6988487/what-does-the-brk-system-call-do



https://rada.re/n/radare2.html

https://www.linkedin.com/pulse/elf-linux-executable-plt-got-tables-mohammad-alhyari/



https://habr.com/ru/companies/varonis/articles/576186/

https://ru.stackoverflow.com/questions/277295/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BA%D1%83%D1%87%D0%B8-%D0%B8-%D1%81%D1%82%D0%B5%D0%BA%D0%B0




https://stackoverflow.com/questions/7848771/how-can-one-see-content-of-stack-with-gdb


https://stackoverflow.com/questions/63570447/how-to-do-simple-math-in-gdb

https://stackoverflow.com/questions/6805065/how-to-see-which-line-of-code-next-would-execute-in-gdb

