| array
| bash array

DISCLAIMER:  я там ниже рассматриваю в чем же разница между ${a[@]} ${a[*]}  "${a[@]}" "${a[*]}"
так вот там в середине текста не оченя  я верно разгадал этот ребус. а настоящая разгадка 
в самом конце.



прежде чем говориить про массивы я скажу про вспомгательную тему. 
вот мы создаем переменную в баше 

  a = 10

далее у баш процесса есть некоторый набор переенных которые оно само создает.
так называемые пеерменные окружения. это всего навсего переменные которые баш создает
сам без нашей просьбы. как их посмотреть?  через 

  $ env

при том что там нашей содданной нами перменной не будет

 $ env | grep vasya
пусто


а как постретть все перменные и перменные окружения и наши созданные

 $ set | grep vasya
vasya=100


итак баш раздаеляет перменные на два типа. на пемеренные окружения и на созданные руками.

но можно создать пермеменную руками и попросит баш добавить ее в массив переменных окружения

 $ env | grep petya
petya=100


спрашивается а где еще всплыают перменные окружения? а вот где.
когда мы в баше запускаем бинарник то баш себя клонирует. а потом запускает execve.
вот его синтаксиси

   int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);

значит про эту фнуию я класно описал вот тут "c-array-nullable.txt"
так вот в третий аргумент баш втслваяет массив из своих пременных окружения.
кажоая из которых имеет вид

  NAME=value

это уже дело нвооого процесса будет он это использовать небудет. баш это не колышет.
поэтому если у мы дбавим перменную в массив перменных окружения то баш обятадеьно при
запуске нвого бинарника вставит ее в в execve() и если новая пргамма использует пременные 
окрежения. если она сканирует тот массив либо если та програма исольщуется фукнцию libc getenv()
которая умеет искать перенную в этом массиве по имени то мы можем из баш эту перменную 
передать.  вот я  вот в этом файле  "c-array-nullable.txt" указал программу 382.exe
у нее на вход подается имя перенной. и тоода она ее ищет в этом массиве. тоесть считай что она 
ее использует. вот например у меня скажем нет в в баше перменной vasya в массиве перменных 
окружения. тоест сама перменная есть. но она не доавлена в массив перменных окружения.


вот созда пременную 
  $ vasya=10
  $ echo $vasya
10

но она пока что не входит в массив env
  $ env | grep vasya

поэтому при вызове новго бинаника этой переннойне будет в масиве env[]. и поэтому
моя прогармма не найдет эту пермнную

  $ ./382.exe vasya
переменная vasya НЕ найдена 
я НЕ нашел эту же переменную через getenv() 


теперь я в баше добавляю эту перменную именно в массив envp[] 
  export vasya
  $ env | grep vasya
vasya=10


теперь она передается через envp[] в новый порцесс
и он ее видит и находит

	./382.exe vasya
	переменная 'vasya' найдена.
	vasya=10
	я нашел эту же переменную через getenv(), вот она vasya = 10  


также перменную можно не добавлять в массив env самого баша.
но можно ее передать в этот массив кокнрентно при запуске нвоого бинарника

  $ petya=20 ./382.exe petya
переменная 'petya' найдена.
petya=20
я нашел эту же переменную через getenv(), вот она petya = 20  

можно убедиться что у меня в самом баше нет ни то что перменной petya в массиве env
но даже порсто этой пеменной petya нет

  $ echo $petya

  $ env | grep petya



однако вот эта констуукция 

  petya=20 ./382.exe petya


она засталяет бащ при взываое execve дообавить эту перенную чисто в массив envp налету
потэтому она и будет присутвоатвь в процессе 382.exe  в масиве envp

вот можно вживую увидеть какие занчения переаются в массиве envp башем при взыве execve()

$ petya=20 strace -e execve -v ./382.exe petya
execve("./382.exe", ["./382.exe", "petya"], ["petya=20", "SHELL=/bi.....

тоесьт первый парметр это стринг и он у нас равен 

  "./382.exe"

второй парамтер это массив

	["./382.exe", "petya"]

и третий параетр  это масив enpv[]
и в его самом начале мы видим  нашу перенную 

	["petya=20", "SHELL=/bi.....


вот такая тема. 
а это дает то что если мы в баше пишем фразу вида

   name=value abc ....

то баш это растриват так что мы просим его запустить бинарник abc и приэтом при его вызове
добавить в массив envp переенную name=value
напрмиер 

	$ a=10 sleep 10

вот видно

	$ a=10 strace -e execve -v sleep 10
	execve("/usr/bin/sleep", ["sleep", "10"], ["a=10", "SHELL=/bin/bash


тоесть a=10 это переная добавленная в массив третьего арумшумента execve()
а так то у нас пргармма запускается sleep а 10 это аргумент.

так я  это к чему.веду.  положим я хочу в переменную записать чтотос пробелами 
и вот тут нам поноабдяться скобки

	 $ a=1 2 3
	bash: 2: command not found


потому что здесь бащ считает что мы запускаем программу в которой бинарник имеет имя файла 2
с аругметом 3. и при запуске этой программы 2 я прошу обавить в массив envp перменую a=1
тесть вот эта констуркция она имеет вот такой смысл

	 $ a=1 ls  -1


но мы то хотим совсем другого. мы хотим чтобы 1+пробел+2+пробел+3 были засунут в перменную "a"
вот тут к нам приходит на помощь КАВЫЧКИ!

	$ a = "1 2 3"

вот такая огромная разница между 


	 $ a=1 2 3

и

	$ a = "1 2 3"


совершенно другой физ смысл!!!!!!!
это все был полгтовительный материал.



но это еще не всесь подгтоивитльный материал
вот еще доп подгортиовителный материал.
у баша есть перменые которые имеют очень диковинные имена. 
а тончнее это даже не перменные а константы.
вот и их имена


 *
 @

это символы имеют вот такое значение - это 	ИМЕНА КОНСТАНТ!
тоесть можно создать контнсту с именем vasya или a1 
но они взяли за имена коснтант вот такие стремные символы!


тоесть * это имя константы. и @ это имя константы.
вот такие ебануты имена констант.
в них нельзя засунуть знаение! из них тлько можно считать значение! 


что же там за значения лежат? а вот что - если ты запустил скрипт на баше с аргументами
то в этих константах лежат аргументы запуска скрипта!

так а в чем разница у них? если мы вытаскиваем из этих констант значение вот так $@ $* 
то разницы нет никакой! это тоже дебилизм

возьмем такой скрипт

#!/bin/bash

echo '$@' = $@

echo ""

echo '$*' = $*

echo ""



запустим его

	$ ./01.bash 1 2 3
	$@ = 1 2 3

	$* = 1 2 3


итак и одна и другая константа содержат в себе совершенно одно и тоже - полный набор всех
аргуентов собранный в одну кучу.

теперь еще подгоотвительный материал.
билтин FOR 

$ for i in 1 2 3; do echo $i; done
1
2
3

$ for i in "1 2 3" ; do echo $i; done
1 2 3

значит если мы в нее подставляем элменты через пробел то он их рассматривает как 
отдельные элеенты. но если мы заключаем в кавычки двйоные то засталвяем рассатривать как один
элемент

теперь посмотрим такой пример 
$ a="1 2 3"

$ for i in $a ; do echo $i; done
1
2
3

тоесть перед запуском for у нас баш подставляем занчение переенной a в строку
тоесть было 
	for i in $a ; do echo $i; done
стало
	for i in 1 2 3 ; do echo $i; done

как я уже показал выше если у нас for и в строке есть эелменты через пробел то для for 
это отденые эелменты
и поэтому мы получаем 
1
2
3

кавычки в формуле a="1 2 3" нужны для того чтобы при операции присваивания у нас баш понял
что мы суем в переерную "a" именно все 5 символов "1+пробел+2+пробел+3"
а не чтобы баш подумал что мы запускаем бинарник 2 с аргументом 3 и еще суем в envp 
перееенную a=1 (то что я описал гораздо выше)

теперт вот такие пример 

$ a="1 2"
$ b="3 4"
$ c="5 6"

$ for i in $a $b $c ; do echo $i; done
1
2
3
4
5
6

значит как я уже говорил у нас перед вызывом for будет осущетлвена замена. будут 
поствлены занчения перменных
тоест было 

$ for i in $a $b $c ; do echo $i; done

а баш заменяет на

$ for i in 1 2  3 4  5 6  ; do echo $i; done

поэтому несмотря на то что у нас три ппреременных было а для for это уже 
6 разных элементов

а вот теперь такой пример 

$ for i in "1 2"  "3 4 "   "5 6" ; do echo $i; done
1 2
3 4
5 6

тоесть двойные скобки заставяют баш инптретировать то что внутри кавычек как единая хрень.


$ for i in "$a"  "$b"   "$c" ; do echo $i; done
1 2
3 4
5 6

тоже самое провило раотает здесь 

$ for i in $a $b $c ; do echo $i; done
1
2
3
4
5
6

тоесть когда баш видит консутрция $a то он просто вместо $a подстатвляет зачнеие перменной.4
поэтму наша строка превращется в 

$ for i in 1 2  3 4  5 6  ; do echo $i; done


а если я делаю вот так
$ for i in "1 2"  "3 4 "   "5 6" ; do echo $i; done
1 2
3 4
5 6

то уже другой коленков. потому что. согласо правилу что мы вначале замеяем $a на его занчение
а $b на его занчение, $c на его занчерие то получаем

$ for i in "1 2"  "3 4"  "5 6"  ; do echo $i; done

дале применяем правило касающееся двйоыных кавычек . тоесть все что внутри ниъ рассматрваь
как единое занчение. поэтому и получам 

1 2
3 4
5 6

теперт вовзращаемся к спец коснатнатам * и @  и смотрим как они себя раскрывают в for
значит берем такой скрипт


#!/bin/bash

echo '$@' = $@

echo ""

echo '$*' = $*

echo ""




for i in $@; do echo $i; done

echo ""

for i in $*; do echo $i; done

echo ""


и вот так его заускаем

	$ strace -e execve ./01.bash "1 2"  "3 4" "5 6"
	execve("./01.bash", ["./01.bash", "1 2", "3 4", "5 6"], 0x7ffc1a0104b8 /* 61 vars */) = 0

вот четко видно что у нас мммаасив argv[] = ["./01.bash", "1 2", "3 4", "5 6"]
и как я уже говоирил константы с именами * и @ они в себе содержат этот массив argv[]
кроме его превого элемента. содержат они его  в себе в форме единого спресссованного
выражения. тоесть еслибы я составлял эту констату руами то это выгяддело бытак

  * = '1 2 3 4 5 6'
  @ = '1 2 3 4 5 6'

вот это в точности что они из себя прсталвяют. это не массивы. это тупо вотодна такаая
длинная блямба.


зауска скрипт 

$ ./01.bash "1 2"  "3 4" "5 6"
$@ = 1 2 3 4 5 6

$* = 1 2 3 4 5 6

1
2
3
4
5
6

1
2
3
4
5
6



тоестьвот такая команда 

	echo '$@' = $@

дает на экране

	$@ = 1 2 3 4 5 6

вот такая команда 

	$* = 1 2 3 4 5 6

дает на экране

	$* = 1 2 3 4 5 6


вот такая команда

	for i in $@; do echo $i; done

дает на экране

1
2
3
4
5
6


что логично потому что у нас $@ означает для баща - подставть в это место занчение этой
коснатны\перменной тоесть будет подставлено вот такое
  
  for i in 1 2 3 4 5 6; do ....

а далее каждая хрень между пробелами для for это отдены элемент.

тожесамое получаем для

	for i in $*; do echo $i; done

дает на экране

1
2
3
4
5
6


потом я в скрипте вставляю вот такие штуки


	for i in "$@"; do echo $i; done


	for i in "$*"; do echo $i; done


запускаю скрипт и вот что вижу на экране
для вот этой строки

	for i in "$@"; do echo $i; done

я вижу на экране 
1 2
3 4
5 6

и вот здесь важный момент. НИКАКОЙ ЛОГИКИ в этом результате НЕТ. это надо просто запомить
и принять. потому что если мы следует логике то нужно рассуждать вот так 
так как 

  @ = "1 2 3 4 5 6"

то запись "$@" означает вот что. вначале баш должен вместо $@ подсавить ее занчение. 
тоесть

 "$@" = заменяем на "внутри вставляем заначение" = "1 2 3 4 5 6"
 и тогда получаем в строке


	for i in "1 2 3 4 5 6"; do echo $i; done
а такая штука у нас дает вот такой резултат 
	$ for i in "1 2 3 4 5 6"; do echo $i; done
	1 2 3 4 5 6

поэтому то что мы видим на экране ЭТО ЧУШЬ СОБАЧЬЯ! ЭТО ПРОСТО ТУПО ИСКЛЮЧЕНИЕ И НЕБОЛЕЕ
ТОГО! ЛОГИКИ НЕТНИКАКОЙ!

а уже вот эта строка 

	for i in "$*"; do echo $i; done
раотает как положено
	1 2 3 4 5 6

тоесть баш видит вот эту констурцию "$*" и понимает что нужно вначале замеить $* на ее 
заненчие тоеать
   "$*" = "занчение для *" = "1 2 3 4 5 6"

значит наша строка с for превращается в 
	for i in "1 2 3 4 5 6"; do echo $i; done
и мы логично получаем на эркране
	1 2 3 4 5 6


тоесть в этом случе все раотает КАК ПОЛОЖЕНО! 

а вот в этим констурууиях работает как положено

	echo "$@"

на экране получаем 
   1 2 3 4 5 6

echo "$*"
на экране получаем 
   1 2 3 4 5 6

тоесть тут никких приколов. все как положено. вначале $name заменяется на контент этой
перменной.  а потом просто снаруэ стоят кавычки. естть 


	echo "$@" = echo "1 2 3 4 5 6"
	echo "$*" = echo "1 2 3 4 5 6"

поэтому в обоих случаях
   1 2 3 4 5 6
   1 2 3 4 5 6

тоест никих прикоолов.

тут же я хочу сказать важную вещь. сам бинарник echo он понятия не имеет при своем старте
о какимх то там стремных констуркциях $@ или $*, как  я уже говоил  баш кода мы ему 
скормили строку то он в ней ишет свои директивы спец консутуркции. и он их заменяет уже на 
контент который за ними стоит. тоест 
вот я вбил строку

	echo "$@"

и нажал enter
баш анаизиурет строку и заменяет $@ на ее контент 
	 
	echo "1 2 3 4 5 6"


но этоеще не все. теперт он еще раз аналириует строку. и для него кавычки этотоже ДИРЕКТИВА!
она башу оьябсняет что  все то что внутри кавычек ЭТО ОДИН АРУГМЕНТ! поэтому теерь он наконец 
знает как точно запускать execev 

  $ a="1 2 3"
  $ strace -e execve -v echo "$a"
  execve("/usr/bin/echo", ["echo", "1 2 3"],

тоесть согласно кавякам баша вставил 1 2 3 в виде ОДНОГО агумента в argv массив

а вот какая разница если  я уберут кавычки

     $ a="1 2 3"
     $ strace -e execve -v echo $a
      execve("/usr/bin/echo", ["echo", "1", "2", "3"], [" 

тоесть в этмом случае баш отработал в два захода. он увидел $a и заменил на ее контент

     $ strace -e execve -v echo 1 2 3 

и видя это он запускает echo уже с тремя арументаами  "1", "2", "3"
итак у нас $name это одна директива для баща, а "" это другая директива для баша. 
он "распокаоывет дешифрует " строку пееред запуском в несколько заходов. 
кавычки это таая же диретикваи для баша как нмриемер директива > или директива |

так вот что я еще хочу тут отметиь это то что сам echo он понятим неимеет обо все этих 
хренях типа $a или ""  он получает в аргументах чистые голые конечные данные!

и получается на данный момент все хрени подяисняюся четко логике обработки дирктив. 
кроме вот этого прмиера

	for i in "$@"; do echo $i; done

этот пример это чисто тупое исключение неимющее нкиакого логическгго обясьнения.




таким образом  я  к этмоу моенту показал раскаазал как рассуждает и рабоает for,
что тако * и @ и как оно  раотает в составе for тоесть for + "@" = прикол. 


вот что написано по поводу этих констант в мане от баша


 *      Expands to the positional parameters, starting from one.  When the expansion is not within double quotes, each positional
              parameter expands to a separate word.  In contexts where it is performed, those words are subject to further word  split‐
              ting  and pathname expansion.  When the expansion occurs within double quotes, it expands to a single word with the value
              of each parameter separated by the first character of  the  IFS  special  variable.   That  is,  "$*"  is  equivalent  to
              "$1c$2c...",  where c is the first character of the value of the IFS variable.  If IFS is unset, the parameters are sepa‐
              rated by spaces.  If IFS is null, the parameters are joined without intervening separators.
@      Expands to the positional parameters, starting from one.  In contexts where word splitting      is  performed,  this  expands
              each positional parameter to a separate word; if not within double quotes, these words are subject to word splitting.  In
              contexts where word splitting is not performed, this expands to a single word with each positional parameter separated by
              a  space.   When  the expansion occurs within double quotes, each parameter expands to a separate word.  That is, "$@" is
              equivalent to "$1" "$2" ...  If the double-quoted expansion occurs within a word, the expansion of the first parameter is
              joined with the beginning part of the original word, and the expansion of the last parameter is joined with the last part
              of the original word.  When there are no positional parameters, "$@" and $@ expand to nothing (i.e., they are removed).

так хуй поймешь что тут написано чисто для срправки привел.


а теперь наконец я преехожу  к массива в баше.
во первых есть српвка по массивам в баше. искать надо во так

  $ man bash
  /Arrays

значит массив создается вот так

  a=(1 2 3)

кстати баш неперваривает разрыв между "=" тоесть прблмы ставить слева и справа нельзя
вот так будет оишикбка


  a = (1 2 3)

так вот значит массив задается вот так

  a=(1 2 3)

доступ к эелменту маассива

$ echo ${a[0]}
1

индексы начинаются с нуля.

если пишу вот так $a то баш автматом меняет на лету это на ${a[0]}
тоесть

$ echo $a
1


а теперь самый прикол. нашые старые знакомые @ и * они неожиданно появляются в массивах.
только здесь они имеют СОВЕРШЕННО ДРУГОЙ СМЫСЛ! они тут никак не связаны в аргументами при
вызове сркипта! они тут имеют соверешенно новое незавсиимое занчие. и это полный доблбоебизм!

если я пишу
  ${a[@]}

то бащ если види такое в строке то вся эта консутрукция для него есть единое неделимое целое
и она означает что в этом месте нужно эту хрень заменить на строку составленую из все значений
этого массива. тоесть

	 $ a=(1 2 3)
	$ strace -e execve sleep  ${a[@]}
	execve("/usr/bin/sleep", ["sleep", "1", "2", "3"], 0x7ffe236ebc48 /* 61 vars */) = 0

я спциально взял sleep чтобы не отавлекаться на сам бинарник. 
тоесть наша строка 

   sleep  ${a[@]}

она налету замеяется башем на 

   sleep 1 2 3

ну и тут больше нет нкиаких директив потэтому баш заускает sleep с тремя аругментами.

тот же смысла в рамках массива имеет и *

  $ strace -e execve sleep  ${a[*]}
  execve("/usr/bin/sleep", ["sleep", "1", "2", "3"], 0x7fff556b7b68 /* 

кода баш видим констуркцию ${a[*]} то это ему указание что нужно вэтом месте вставить
строку соатвленную из всех занчений масива
поэтмоу разницы абсолютно никакой!

щас я потрднее массив возьму

 $ a=("1 2"  "3 4" "5 6") 
 $ strace -e execve sleep  ${a[@]}
 execve("/usr/bin/sleep", ["sleep", "1", "2", "3", "4", "5", "6"], 0x7f

 $ strace -e execve sleep  ${a[*]}
 execve("/usr/bin/sleep", ["sleep", "1", "2", "3", "4", "5", "6"], 0x7ffc3c4

тоесть у нас строка 

 sleep  ${a[@]}

 заменяется башем в обоих случаях на  

 sleep 1 2 3 4 5 6 

 а дальге так как нет директив то он заупускает sleep с 6-ю аргументами.

теперт посмотрим что будем если мы сверху добавии директиву ""

 $ strace -e execve sleep  "${a[@]}"
execve("/usr/bin/sleep", ["sleep", "1 2", "3 4", "5 6"], 0x7ffdd1367ae8 /* 61 vars */) = 0


 $ strace -e execve sleep  "${a[*]}"
execve("/usr/bin/sleep", ["sleep", "1 2 3 4 5 6"], 0x7ffed9226e98 /* 61 vars */) = 0

и здесь у нас хрень  "${a[*]}" веде себя как положено. тоесть вначале баш видит диркетиву {a[*]}
и он в этом месте заменяет эту хень на строку составленную из занчений масива

sleep  "${a[*]}" = sleep  "1 2 3 4 5 6"

далее он видит еще одну диретиву "" котоаря ему говотрит что все что внутри скообок это один 
аргумент поттому sleep как пожено запускается с 6-ю арументами ["sleep", "1 2 3 4 5 6"]

а вот  в случае "${a[@]}" мы получаем ОПЯТЬ полуную фигню неимеющую НИККОГО ЛОГИЕЕСКОГО смысла!
это просто тупо надо запомнить как исключение! вот что .
вместо того чтбы как положено запустить sleep с 6-ю аргументами он запускается с тремя

 ["sleep", "1 2", "3 4", "5 6"]

это надо просто запомнить как исчлюние. вот и все.

ровно такая же фигня будет с масивами внутри цикла for

  $ for i in "${a[@]}"; do echo $i; done
1 2
3 4
5 6

$ for i in "${a[*]}"; do echo $i; done
1 2 3 4 5 6

тоесть все тоже самое у нас "${a[*]}" ведет себя как положено. а  "${a[@]}" ведет себя
соверешенно дебилоидно.


вот эта фигня покзвает сколько эелментов в массиве

	$ a=("1 2"  "3 4" "5 6") 
	$ echo  ${#a[@]}
	3
 	$ echo  ${#a[*]}	
	3


а вот эта фигня заменяет нашу хрень на строку из индексов

  $ echo  ${!a[@]}
0 1 2
  $ echo  ${!a[*]}
0 1 2

это хоро потому что ненужно руками городить массив индексов тоесть
 $ for i in   ${!a[@]}; do echo ${a[i]}; done
1 2
3 4
5 6
 $ for i in   ${!a[*]}; do echo ${a[i]}; done
1 2
3 4
5 6



длаее я привожу хорошее оьбяснние  в чем разница для баша ${a[@]} и "${a[@]}"
если обьяснть коротко то консутрция  ${a[@]} заствляет баш вставить в этом месте содержимое
значений элементов массива a. а конструкция "${a[@]}" засвляет сделать тоже самое но при этом
каждый элемент массива будем дополенитльно окружен двойными кавычками.
итак начнем обьясненеим
пусть у нас 

   script.sh  ${klava[@]}

либо 

   script.sh  "${klava[@]}"


в чем разница первого от второго. я об этом пишу в файле посвященном массивам "bash-array.txt"
о том что формулировка "${klava[@]}" ее нужно трактовать  чисто как исклчение из правил.
и вот что получаем. прежде чем баш запустит скрипт он конструкцию справа должен заменить 
на готовые значения. так вот он заменит  херь  ${klava[@]}  на ряд из всех значений эттго
массива. покажу напримере попроше . пусть у нас вот такой масив

		$ klava=("1 2" "1 3" "1 4")

тогда он заменит первую строчку на 


	  script.sh  1 2 1 3 1 4

и скрипт будет запущен с 6-ю перменными.

а во второй строчке повтрорюсь вот эта хрень "${klava[@]}" ее расшифровка неимеет логики
это просто надо запомнить как ичклюение. так вот  эта хрень будет заменена на 


	script.sh   "1 2" "1 3" "1 4"

и тогда скрипт будет запущен с тремя параметрами


тоесть вот эта хрень ${klava[@]} бертся в скобки "${klava[@]}"только тогда когда 
мы хотим чтобы баш при наличии пробелов в элментах массива чтобы он условно говоря 
при замене этой хрени на элементы массива он выставил дополнетльные скобки чтобы у нас 
элементы массива оригинальные не распались на бОльшее число элементов за счет пробелов.
щас обьясню

вот у нас есть массив
		$ klava=("1 2" "1 3" "1 4")

если я пишу 

    echo ${klava[@]}

то преде запуском эхо баш замнеит эту хрень на конетенте массива вот в таком виде

  echo 1 2 1 3 1 4

ну формально он прав потому что кавычек в элемнтах массива на самом дееле нет. 
кавычки klava=("1 2" "1 3" "1 4") это мы просто когда заностили эти элементы в массив то 
кавычки это дирекива башу чтобы ему обьяснить границы элментов. в самих элементах кавычек нет.
так вот если я хочу чтобы баш добавил эти кавычки каждому элементу то я юзаю  "${klava[@]}"

тогда если  я пишу

   echo "${klava[@]}"

то баш при замене ${klava[@]} он выдаст на экран элементы этго массива и также он к каждому 
элементу присобачит слева и справа кавычки! хотя их внутри элементов нет

   echo "1 2" "3 4" "5 6"

а зачем нам кавычки? потому что далее баш опять анализирует строку и эти кавычки являются
для него директивой о том что то что внутри кавычек это единая логическая хрень и пэтому он 
коода будет execve запускать то он массив argv составит из трех элементов. таким образом
у нас массив аругментов будет состояи из трех элеметов ровно точно равных элеметам из исходогог
массива klava.  потому что если мы кавычки убрем то мы получим

  echo 1 2 1 3 1 4

и здесь при вызоыве execve у нас баш составить argv массив из 6-и аргументов. 



итак я хочу еще раз поясить в чем разница у массивов в 

	  ${a[@]} ${a[*]}  "${a[@]}" "${a[*]}"

значит мое суммарное мение щас вот такое. первое когда мы вбили строку в баше и нажали 
enter то он начинает ее анализировать. в строке может быть куча директив баша. причем 
они могу иметь разные степени волженности. так вот он начинает строку модиифицировать 
в несклоко прохоодов . это очень важно понимат. вначале он находит самые  глубокие директивы
и замеяет их на новый текст. потом заново анализирует строку ищет оставшиеся директивы
и их заенят на новый текст и так до самого конца пока не заменит все диретиктивы.
так вот мое мненеи что директивы

		${a[@]} ${a[*]}

они одинаковые. баш втом месте где они стоя заменяет на соверешнно одинакоый текст. а именно
он подталвяет все занчения элементов массива в ряд через пробел. поэтому рузлттат будет 
абсолютно одинаковый для этих двух директив.

теперт я сарввню вот эти две диретиквы

  ${a[@]}  "${a[@]}"


я считаю что эта хрень    "${a[@]}" это не две директивы ${a[@]} + "" а это одна директива.
и означает она то что нужно замениь эту хрень на строку из всех значений массива разделив
эти значения пробелами но также нужно вокруш каждго значения нарисоват двойные кавычки.
поэтому если у нас массив a=("1 2", "3 4", "5 6")
причем я подчеркиваю что данный массив его элеенты не имеют кавычек в своих телах. кавычки
это директива для баша для коректного внеемения элементов в массив иначе он создаст 6 эелметов.
а нам надо три. итак элемент массива неимеют кавычек. так вот ели у нас в сроке идет 


	${a[@]}

то баш ее заменит на 

	1 2 3 4 5 6

а если у нас в строке идет "${a[@]}" то баш ее заменит на

	"1 2" "3 4" "5 6"

тоест вот прям букально он дорисует слева и српава от каждого занчения еще и кавычки которых
реальнонет в этих элементах

теперь вот эту хрень рассмотрим "${a[*]}"
я считаю что в этом случае мы имеем смесь двух директив  ${a[*]} + ""
поэтому эта хрень будет обарабывать в два захода. вначале  ${a[*]} котророе будет замеено
на все зачения массива тоесть

1 2 3 4 5 6

а потом вторая диретива предписывает слева и српава от этого текста дорсиовать кавычки

"1 2 3 4 5 6"

вот какая будет разница. ну и вопрос на что это повллияет.
рассмотрим на примере в свяке с командой echo 




	echo ${a[@]}

баш заменит эту строку на 

  echo 1 2 3 4 5 6

и баш вызлвет execve() с 6-ю аргуметами  1, 2, 3, 4, 5, 6
на экране увидим
1
2
3
4
5
6




	echo ${a[*]}

баш заменит эту строку на 

  echo 1 2 3 4 5 6

и баш вызлвет execve() с 6-ю аргуметами  1, 2, 3, 4, 5, 6
на экране увидим
1
2
3
4
5
6




  echo "${a[@]}"

баш заменит эту строку на 

  echo "1 2" "3 4" "5 6"

и баш вызлвет execve() с тремя аргументами  1 2,  3 4, 5 6
заметим что кавычке нет. потому что баш их снимет при подставноке этих значений в execve
потому что для него кавычки это директив о границах неделимых субстанций в строке
на экране увидим
1 2
3 4
5 6



  echo "${a[*]}"

баш заменит эту строку на 

  echo "1 2 3 4 5 6"

и баш вызлвет execve() с одним аргументом  1 2 3 4 5 6
опятьже заметим что небудет кавычек слева и справа. потому что это просто для баша
диарктива о границах неделмых сущнсотей
на экране увидим
1 2 3 4 5 6



вот такая хитрожопая хрень с этими штуками. очень хтрая. и очень дебильно
неописанная



еще замечу что распечатат несклоко элементов массива нельзя. мжоно либо один 
жлемент 
 
  ${a[0]}

либо все элементы

 ${a[0]}


правда есть вот такой способ

  $ a=(1 2 3 4 5 6 7 8 9 )
   $ echo ${a[@]:4:1}
5
  $ echo ${a[@]:4:2}
5 6

первая цифра это оффсет то есть это скажем так номер индекса в массиве. а вторая цифра
это сколько элементов нужно вернуть. поэтому 4:1  это значит старт на идексе 4 и верни 1 
элемент. поэтмоу получаем 5
4:2  это значит старт на индексе 4 и верни два элемента


вот знаковые примеры
$ ar1=('1 1'  '2 2'  '3 3')
$ echo  ${ar1[@]}
1 1 2 2 3 3

$ echo  ${ar1[*]}
1 1 2 2 3 3


$ for i in  ${ar1[@]}; do echo $i; done
1
1
2
2
3
3

$ for i in  ${ar1[*]}; do echo $i; done
1
1
2
2
3
3

$ for i in  "${ar1[@]}"; do echo $i; done
1 1
2 2
3 3

$ for i in  "${ar1[*]}"; do echo $i; done
1 1 2 2 3 3


но я уже разобрал выше почему такой вывод




еще раз хочу подчеркуть что   ${a[@]} и  ${a[*]} это абсоодолютно одна и та  же дирактива
вот у нас есть масив

a=("1 2" "3 4" "5 6" "7 8" 9 )
тогда
 
 $ strace -e execve echo ${a[@]}
execve("/usr/bin/echo", ["echo", "1", "2", "3", "4", "5", "6", "7", "8", "9"], ...) = 0


  $ strace -e execve echo ${a[*]}
execve("/usr/bin/echo", ["echo", "1", "2", "3", "4", "5", "6", "7", "8", "9"], ...) = 0

вся разница начинается когда у нас вот такие хрени "${a[@]}"    "${a[*]}" 
а именно. 

 $ strace -e execve echo "${a[@]}"
execve("/usr/bin/echo", ["echo", "1 2", "3 4", "5 6", "7 8", "9"], ...) = 0

 $ strace -e execve echo "${a[*]}"
execve("/usr/bin/echo", ["echo", "1 2 3 4 5 6 7 8 9"], ...) = 0




ВРОДЕ ВСЕ ПРО МАССИВЫ




хочу тут еще подсобную тему обсудить

		$  p=10 /usr/bin/echo '$p'

на экране я увижу 
   
   $p


вопрос почему? почему я не увижу 10 а увижу $p

а дело вот в чем. мы написали эту строку тыкнули ENTER.  баша анализирует строку
на директивы. вот он видит  '$p'  . для него одинарные кавычки значат то что внутри 
них стоит неделимая хрень. тоесть один аргумент для будушего процесса. и то что внутри 
этой хрени ненужно искать другие директивы. поэтому в argv через execve он вставит буквально $p
доказываю это 

$ p=10 strace -e execve /usr/bin/echo '$p'
execve("/usr/bin/echo", ["/usr/bin/echo", "$p"], 0x7fff79c25ae8 /* 62 vars */) = 0

тоесть вот он массив argv ["/usr/bin/echo", "$p"]
и вот в нем показан тот аргумент с которым будет запушена функция echo 

    $p


а что значит p=10  вначале? это знак для баша что когда он будет запускать новый прцоесс
то нужно в массив envpp[] добавить новую перменную p=10
щас я докажу

$ p=10 strace -v -e execve /usr/bin/echo '$p'
execve("/usr/bin/echo", ["/usr/bin/echo", "$p"], ["p=10", "SHELL=/bin/bash"....

вот у нас показан массив envp[]
   ["p=10", "SHELL=/bin/bash"....

и мы в нем видим p=10

итае перменая p=10 была передана внутр процесса echo. 
также $p был передан в эхо. так почемуже он гад на экране печатает $p а не 10 ?
потому что  обозначение $p  имеет смысл "найди среди переменных переную с именем p и наечатай
ее значение" имеет силу только для баша. для эхо  литеры $p незначат ничего кроме как буквално
наечатай на экране литеры $p
поэтому мы на экране увидим исключиетльно $p 
потому что эхо понятия неимеет об директивах обозначения перменных с точки зрения баша.


а вот другой дебилный пример

			$ d=10 /usr/bin/echo $d

на экране мы увидим пусто. почему? 
у нас баш перед запуском echo видит хрень $d . для баша это означает что  в этой строке в этом
месте нужно вставить занчеие перееной "d" а она в баше незадана потому там вставлет пустота

			$ d=10 /usr/bin/echo

то что слева стоит d=10 это сигнал о том что при запуске execve нужно в третий рагумент
тоеств массив envp[] вставить новую перенную d=10. но эхо на это плевать. потому что он запускатс
с нулем аргументов. поэтмоу по факту на экране мы увидим просто пустоту.

замечу что в самом баше d=10 не создется. он толко пропхвыается в новыый процесс а в текущем
процессе у нас этой перменной не будет

