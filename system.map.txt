| kernel
| System.map


напоролся на очерендую тему в стиле пиздец

идем в папку /boot

там лежат привычные файлы
	vmlinuz*
	initrd*

и тут я заметил файл вида 

 $ ls -1 /boot/Syst*
/boot/System.map-5.10.0-051000-generic
/boot/System.map-5.4.0-91-generic

а что это за хуйня system.map ??!?!?!?!?!?!!?

смотрим что там внутри

$ sudo cat /boot/System.map-5.4.0-91-generic | head

0000000000000000 D __per_cpu_start
0000000000000000 D fixed_percpu_data
00000000000001e0 A kexec_control_code_size
0000000000001000 D cpu_debug_store
0000000000002000 D irq_stack_backing_store
0000000000006000 D cpu_tss_rw
0000000000009000 D gdt_page
000000000000a000 d exception_stacks
000000000000f000 d entry_stack_storage
0000000000010000 D espfix_waddr


а что это за хрень?

а это так называеммая "SYMBOL TABLE" для ядра. а что это за хуйня ? 
по руски можно?


насколько я понимаю этот файл сам линукс в своей работе не использует.вроде как.
это как я понимаю чисто информационный файл для человека. сама же 
система этот файл нихрена неиспльзует. контент этого файла можно посмтреть 
в живой системе вот так

 $ sudo cat /proc/kallsyms | head
[sudo] password for vasya: 
0000000000000000 A fixed_percpu_data
0000000000000000 A __per_cpu_start
0000000000001000 A cpu_debug_store
0000000000002000 A irq_stack_backing_store
0000000000006000 A cpu_tss_rw
0000000000009000 A gdt_page
000000000000a000 A exception_stacks
000000000000f000 A entry_stack_storage
0000000000010000 A espfix_waddr
0000000000010008 A espfix_stack

причем обязательно нужно запукскать под судо иначе вместо адресов
будут нули.

так вот что жетакое таблица символов? это таблица которая указывает какой 
адрес  в виртуальном пространстве адресов ( что это за хуйня?) имееет 
переменная или функция у ядра. итак symbol это variable или function в ядре.

окей. мало понятно но тем не менее. а на хуй это нужно? из того что я нашел
это нужно для динамической загрузки новых модулей. у нас модуль ядра это 
вроде как такая хрень которая предоставляет какую то новую функцию которая
доступна для запуска когда комп работает в режиме ядра. тока я опяь же не 
пойму эта фунция она доступна для вызова из юзер спейса? или она доступна
для запуска только для кода ядра когда один кусок ядра запускает другой
кусок ядра. пока хуй знает.  так вот что точно я понял что у нас загрузка
однго модуля ядра может предварительно требовать подгрузки другого ядра. 
вот тут и пригождаеется эта SYMBOL TABLE. как я понимаю когда мы пытаемся 
загрузить новый модуль то (то ли само ядро толи этот модуль) он идет 
в эту таблицу и ищет определенные символы . и если они есть то модуль понимает
что все что ему нужно для работы есть и загружается.  а если нет то
посылает нас нахер. при этом при загрзуке нового модуля то в эту таблицу
добавляются символы которые предоставляет наш загруженный модуль.

немного об этом написано в главе "the kernel symbol table" в книге "linux
device drivers"

далее вот полезная статья
	https://sysprogs.com/VisualKernel/documentation/kernelsymbols/

далее вот еще полезная статья
	https://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/

вот еще статья
	https://blog.cloudflare.com/how-to-execute-an-object-file-part-1

только нихрена непонятно потому что нет базовых знаний. еще насколько я понял
вот эти symbols и symbol table она ест нетолько у ядра оно еще есть вот в каком
случае - оно есть в ELF файлах. вот пример есть прога

$ cat 02.c
#include <stdio.h>
int main()
{
printf("hello, world\n");
}


я ее откомпилировал 
$ gcc -0 02.exe 02.c

и теперь я исследую elf файл 02.exe

$ nm ~/C/02.exe | head
0000000000201010 B __bss_start
0000000000201010 b completed.7698
                 w __cxa_finalize@@GLIBC_2.2.5
0000000000201000 D __data_start
0000000000201000 W data_start
0000000000000560 t deregister_tm_clones
00000000000005f0 t __do_global_dtors_aux
0000000000200dc0 t __do_global_dtors_aux_fini_array_entry
0000000000201008 D __dso_handle
0000000000200dc8 d _DYNAMIC

тоесть внутри ELF файла с обычной прогой тоже может быть SYMBOL TABLE
насколко я понима можно откмпилировать прогу так чтобы этой тейбл небыло 
в ELF файле. а если она ест то это хорошо помогает когда мы юзаем gdb
при брейкпоинтах и дебаггинге. подродности на практике пока нет времени
разбираться. также как я понял когда мы комплилиурем прогу то там же компиляция
идет в несколько стадий. там есть линкер. и у нас может быть много .c файлов
и вот у нас вначале для каждго .c файла создается object файл. внутри кторого
есть обязательно symbol table. а уже на следущем шаге компилятор используя
кучу этих object файлов и symbol table внутри каждого собирает один конечный
файл.  к сожадению при остуствии базового бразования пока что только обащая хуйня.
без конкеттики.




