| k8
| k8s
| pause
| pause container


значит pod это группа контейнеров. как минимум эта группа
контейнеров она имеет общий сетевой неймспейс. то есть процессы
в каждом контейнере имеют доступ к одним и тем же сетевым
интерфейсам.

но помимо тех контейнеров которые мы сами руками пропишем 
в манифесте пода к8 автоматом создает еще один контейнер в этой
группе , он называется "pause" контейнером. кстати 
если мы запросим describe пода то мы там его не увидим. 

# kubectl describe pods vasya
...
...
Containers:
  alpine:
    Container ID:  docker://f688c0f1fb87b83d22024ba00220042060ac593904ba3a28409e8fcac22b7b74
    Image:         alpine:latest
    Image ID:      docker-pullable://alpine@sha256:c5b1261d6d3e43071626931fc004f70149baeba2c8ec672bd4f27761f8e1ad6b
    Port:          <none>
    Host Port:     <none>
    Command:
      /bin/sh
      -c
      sleep 1000
    State:          Running
      Started:      Sun, 21 Apr 2024 17:57:16 +0000
    Last State:     Terminated
      Reason:       Completed
      Exit Code:    0
      Started:      Sun, 21 Apr 2024 17:40:36 +0000
      Finished:     Sun, 21 Apr 2024 17:57:16 +0000
    Ready:          True
    Restart Count:  1
    Environment:    <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-8fttp (ro)

вот мы видим только контейнер alpine
а пауз контейнера к8 не показывает. 

но он конечно есть.

# docker ps | grep pause
f14db94dfa66   registry.k8s.io/pause:3.9   "/pause"                 34 minutes ago       Up 34 minutes                 k8s_POD_depl3-54b6cb5c6c-fz5h6_default_bc256bdf-e07c-4b3a-be56-ea5591857af7_0

так вот вопрос  - нахер нужен этот пауз контейнер в поде?
и вот я нашел настоящий хороший ответ --> https://www.ianlewis.org/en/almighty-pause-container

цитирую : First, it serves as the basis of Linux namespace sharing in the pod. And second, with PID (process ID) namespace sharing enabled, it serves as PID 1 for each pod and reaps zombie processes.

щас я все разжую. когда к8 создает под он первым делом создает 
пауз контейнер. что из себя представляет сам процесс который там
запускается?

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

static void sigdown(int signo) {
  psignal(signo, "Shutting down, got signal");
  exit(0);
}

static void sigreap(int signo) {
  while (waitpid(-1, NULL, WNOHANG) > 0);
}

int main() {
  if (getpid() != 1)
    /* Not an error because pause sees use outside of infra containers. */
    fprintf(stderr, "Warning: pause should be the first process\n");

  if (sigaction(SIGINT, &(struct sigaction){.sa_handler = sigdown}, NULL) < 0)
    return 1;
  if (sigaction(SIGTERM, &(struct sigaction){.sa_handler = sigdown}, NULL) < 0)
    return 2;
  if (sigaction(SIGCHLD, &(struct sigaction){.sa_handler = sigreap,
                                             .sa_flags = SA_NOCLDSTOP},
                NULL) < 0)
    return 3;

  for (;;)
    pause();
  fprintf(stderr, "Error: infinite loop terminated\n");
  return 42;
}

я  откомпилировал код и запустил. как консольное приложение. 
раобтает оно нормал. кстати я заглянул какой сисколл у нее
все время выполняется 

$ cat /proc/280557/wchan 
__ia32_sys_pause


значит как  работает этот код. 
он стартует. проверяет как pid у нее. если pid<>1 то программа
ругается но продолжает работать. далее она устанавливает кастомный
хендлер для сигналов SIGINT, SIGTERM, SIGCHLD. если эти кастомные
хендлеру установить неполучается то программа останавливается с 
ошибкой. далее запускается бесконечный цикл for. и внутри него
запускается функция pause. как эта функция работает - The pause function suspends program execution until a signal arrives whose action is either to execute a handler function, or to terminate the process.

итак процесс сразу впадает  в спячку в S состояние и никаких ресурсов
нихрена на пользует. а если вдруг в процесс прилетает сигнал то 
тогда процесс просыпается и обрабатывает сигнал. еслли это SIGINT
или SIGTERM то процесс закончит свое существование. А если это 
сигнал SIGCHLD то запускается хендлер и он грохает этих чайлдов а
потом из за цикла for опять запускается функция pause и процесс
не заканчивается а продолжает жить находясь в состоянии S. 

итак если мы запускаем этот код то создается процесс который нихрена
неделает а просто сразу впадает в S состояние. И выходит из него
только если прилетает сигнал в процесс. Если это SIGINT, SIGTERM
то процесс закончит свою жизнь. А если прилетит SIGCHLD то хендлер
процесса запускает waitpid таким образом будут считаны коды возврата
для всех чайлд процессов и ядро грохнет все зомби чайлд  процессы.
и тут возникает вопрос какие нахрен чайлды у этого процесса? он 
же согласно коду нихрена себя не форкает. у него же нет никаких 
чайлдов!  а дело вот в чем ! - когда к8 запускает под , тоесть к8
создает пауз контейнер соотвесвтеннно процесс получается pid=1
далее к8 создает все контйенеры которые указаны в манифесте пода
и при создании этих контейнеров к8 использует тот же pid неймспейс
что используется в пауз контейнере! получается все контейнеры пода
сидят в одном pid неймспейсе который исходит из пауз контейнера.
и тут вот какой расчет - если в наших контейнерах из манифеста есть
процессы которые порождают своих детей  - например мы запустили
жинкс то он порождает несколько дочерних процессов. далее положим 
родительский жинкс сдох, скажем его ядро аварийно убило за чтото
плохое. тогда у него останутся дочерний процессы. когда умрет
родительский жинкс то родителем автоматом станет pid=1 то есть
пауз процесс в пауз контейнере. и когда мы начнем убивать дочерние
жинкси то они перейдут в Z зомби состояние и к паренту который
у них будет pid=1 то есть пауз процесс полетит SIGCHLD сигнал
и так как пауз процесс имеет обрабочик SIGCHLD сигнала а точнее 
он вызывает waitpid то в итоге коды возврата будут прочитаны 
и ядро окончтельно грохнет зомби процессы! а если бы у нас контейреры
не делили общий pid namespace и если бы пауз процесс не имел pid=1
и если бы пауз процесс не имел хендлера для SIGCHLD который вызывает
waitpid то при аварийном падении парента жинкс у нас бы на хосте
остались бы зомби процессы чайлдов жинкса! вот какая система!
вот каким макаром у пауз процесса могут возникнут чайлды!

таким макаром я расказал одну из причин зачем к8 создает пауз контейнер
при создании пода - для успешного убивания чайлдов остальных процессов.

еще очент важно сказать чтобы вся эта шарманка сработала нужно 
указать в к8 что мы хотим чтобы контейнеры в поде все делили единый
PID namespace, причем который находится в пауз контейнере изначальано.
для этого раньше нужно было подкручивать кубелет а теперь достаточно
добавить опцию       
	shareProcessNamespace: true
в манифест
показываю  как забахать даже не под а деплой с единым pid неймспейсом

apiVersion: apps/v1
kind: Deployment
metadata:
  name: depl3
  labels:
        label1: deploy-alpine
spec:
  replicas: 1
  selector:
    matchLabels:
        label1: deploy-alpine

  template:
    metadata:
      labels:
        label1: deploy-alpine

    spec:
      shareProcessNamespace: true   <== вот эта опция!
      containers:
        - name: alpine
          image: alpine:latest
          command: [ "/bin/sh", "-c", "sleep 1000" ]
          imagePullPolicy: IfNotPresent


проверкой того что у нас единый pid namespace например
состоит в том что мы заходим в контейнер alpine и смотрим
список процессов. в нем мы должны увидеть нетолько sleep 
но и pause процесс причем у него должен pid=1

# kubectl exec   depl3-54b6cb5c6c-fz5h6  -it --   /bin/sh
 # ps aux
  PID USER      TIME  COMMAND
    1 65535     0:00 /pause
   49 root      0:00 sleep 1000
   55 root      0:00 /bin/sh
   61 root      0:00 ps aux


все совпало!


далее. если общий pid неймспейс это опциональная вещь то вот общий
для всех контейенеров сеетвой неймспейс это уже 100% всегда. 
сетевоей нейспейс изначально к8 создает внутри пауз контейнера 
а потом уже для других контейнеров он его расшаривает. 
так вот если бы небыло пауз контейнера то пришлось бы создавать 
сетевой неймспейс на основе каакогото контейнера  из манифеста.
пусть это будет контейнер-А.
и потом расшаривать его с другими контейнерами. получается что если этот контейнер-А упадет ТО ЧТО БУДЕТ??? А??? ( а он может запросто 
упасть в отличие от пауз контйенера. потому что пауз процесс он супер
простой и он хрен упадет а рабочий контейнер из манифеста с какимто 
жинксом или мускулом или пхп может запросто упасть). так вот 
я проверил на докере для начала. я создал контенер alp1 и потом
контейнер alp2 у которого общая сеть с alp1. далее я грохнул процесс
с alp1 он поднялся заново у него IP  был прежний но alp2 уже невидит
его сеть потому что в свойствах процесса указан сетевой неймспейс
котрого уже нет. получается если в группе контейнеоов у нас три
контейнера (то при падении того у кторого был изнаальный сетевой
неймспейс к которому другие конектились) то нужно перезапускать все
три контейнера! это ж пиздец.  единсвтенное что хочу добавить что
что при перезапуска контейнера после падения у него будет тот же самый IP.   а вот если у нас изнаальный сет неймспейс будет сидеть в пауз
контейнере то так как пауз контейнер нихера непадает никогда то 
падение любого другого контенера неломает доступ сети во всех остальных
что круто.  далее я проверил уже на к8.  я взял под. я нашел его
контерер из манифеста и я его грохнул этот процесс через kill -9
и когда под был переподнят а точнее когда к8 пеерсоздал контенер 
из манифеста то в конейнере была сеть и ip был прежний. оно и понятно
почему - у нас остался жив пауз контейнер. а именно он же задает сетвой
неймспейс. поэтому к8 пересоздал контейнер из манифеста и просто 
напросто подключил его к сет неймспейсу пауз контейнера. шикарно.
а вот если уже пауз контейнер убить через kill -9 то уже конечно
надо пересоздвавать все контейнеры из манифеста ибо сеть у них тут
же исчезнет потому что они ссылаются на сет неймспейс процесса кото
рого нет. 

<><>================
ЗАДАЧА: добавить листинг из докера как я создал alp1, alp2
с общей сетью. потом я грохаю alp1. показать вот это

# ls -1al /proc/61236/ns/ | grep net
lrwxrwxrwx 1 root root 0 Apr 21 19:41 net -> net:[4026532955]

 
# ls -1al /proc/61052/ns/ | grep net
lrwxrwxrwx 1 root root 0 Apr 21 19:39 net -> net:[4026532909]

и вот это 

"NetworkMode": "bridge",

"NetworkMode": "container:468f2a8127a80e62789560fa9ec90cd9b05b01a44a9a024827409060f8fdb758"
<><>================
 



есть еще один момент зачем нужен пауз контейнер. все контейнеры могут друг с другом общаться через биндинг на единый интерфейс. тоесть
жинкс может забиндится на lo:46 а мускул на lo:48 и так как они 
оба видят один и тот же lo то они могут общаться друг с другом 
обращаясь к биндингам друг друга. тоесть через биндинг на единый lo
интврейс они могут общаться друг с другом без проблем. спрашиватся
а при чем здесь пауз контейнер --> остальные конейнеры сидят в 
его сет неймспейсе.  если убрать пауз контейнер и все другие конт
тейнеры биндит на неймспейс одного из контейнеров из манифеста 
то они конечно тоже будут видеь друг друга через lo интерфейс
но если этот мастер конейнер упадет то им всем пизда нужно
перзапускаь все конрейнеры в поде.  а когда они все забинеднены
на сет неймспейс пауз контейнера то хрен он упадет так как он 
очень просто и надежный. и падение  любого контейнера из манифеста
требует тольк перезпуска упавшего контейнера. 



