| epoll

значит перед чтением этой статьи я рекомендую прочтать select.txt и poll.txt
а потом уже эту стаью.

плюс epoll (в сравнении с poll)  в том что он возвращает только те события
которые мы у него заказали. а poll возврашает  любое событие которое произошло на 
сокете в независиомсти от того  какое событие мы заказали. 

остальные моменты сравнения poll и epoll я изложил в poll.txt в конце

для начала нужно понять что такое union в си. для этого читай c-union.txt
значит как работает epoll
создается внутри ядра некая хрень - инстанс epoll

    int epfd = epoll_create1(0);

как результат процессу возвращается дескриптор. это некий указатель на наш еполл внутри
ядра. как индентификатор который мы потом будем юзать как индетификатор. это такая же
аналогия как бутто мы сокет создали. только это не сокет а epoll инстанс.


далее нужно обьяснить ядру за какими файловыми дескриптооррами ядро должно следить
для нас. нужно эту инфо записать внутрь нашего epoll инстанса
делаем это мы так 

  epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event)

если  epoll_create1() это аналог socket() то epoll_ctl()  это аналог bind()
тоесть через epoll_ctl мы вносим настройки в epoll инстнас внутри ядра.

первый аргумент epfd это дескриптор еполл инстанса. это ровно тоже самое как мы укаызваем
в bind() дескриптор сокета.

второй аргумент EPOLL_CTL_ADD это мы сообщаем что мы хотим сделать. мы хотим добавить\записать
внутрь епоол инстанса номер нового файл дескриптора. 

третий аргумент file_fd - это как раз номер файл дескриптора котоырй мы хотим записать
внутрь еполл инстанса. это номер файл дескриптора за которым мы хотим чтобы ядро следило.

последний аргумент  &event  - это поинтер. это поинтер на вот такую структуру

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

значит какую роль играет эта структура? в первом ее поле 
    
    uint32_t      events

у нас в форме битовых флагов содержатся события которые ядро должно отслеживать для дескриптоора
номер кторого мы указали в третьем аргументе. 
по мне архитектура достатчно дебильная. почему. потому что у нас номер дескриптора за которым
следить указан в третьем аргументе фукции.  а какие события ловить на этом дескрипторе указано
в четвертом аргументе в его поле. это разнородно и неудобно сделано. я щас сразу покажу как
заносить занчение в первое поле структа epoll_event

   struct epoll_event  event;    \\ обьявляю переменную 
   event.events = EPOLLIN;       \\ присваиваю нашему структу первому полю значение EPOLLIN


где EPOLLIN это такой макрос который на самом деле выставляет некий бит. если мы хотим выставить
несколько битов то это будет примерно вот так

   event.events = EPOLLIN|EPOLLOUT;

размер первого поля структа это 4 байта. 
флаг EPOLLIN означает что в файл на который указывает дескриптор чтото пришло. ну мы не следим
никогда за обычными файлами. потому что у них всегда будет наступать событие EPOLLIN
а если дескриптор указыает например на пайп то вот когда у нас в пайп прилетят данные 
то у нас насутпиит с точки зрения ядра событие EPOLLIN

еще раз посмрим на структ

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

так вот второе поле (ВАЖНО) оно уже нихуя никак не влияет на настройки работы инстанса epoll.
самому epoll это поле вообще нахуй ненужно. так зачем оно нужно? а оно нужно вот зачем.
щас покажу. вот мы через вот такую хрень

   struct epoll_event  event;     
   event.events = EPOLLIN;       
   epoll_ctl(epfd, EPOLL_CTL_ADD, 15, &event)


мы заказываем записываем в епооллл инстанс задание для ядра чтобы если в файл на который 
укызает дескриптор 15 прибыли байты то ядро чтобы оно это заметило и зафиксировало.
теперь нам нужно както в программе узнать что ядро зафикировало интерсующее нас событие
на интерсующем нас дескрипторе. для этого нужно вот так сделать


        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);

у нас events это массив

       struct epoll_event events[MAX_EVENTS];

если мы вставляем имя массива как аргументв фукнцию то компилятор налету меняет текст
нашей прогарммы вот на такой что имя массива менется на поинтер на первый элемент этого
массива тоесть

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

так как у нас events это массив где каждый элемент имеет тип epoll_event
то тогда и первый элемент массива имеет тип struct epoll_event  и тогда поинтер на первый элмент
масива будет иметь тип 

       struct epoll_event*

сравним с тем что требует второй аргумент в спецификации к epoll_wait

        int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

тость второй аргумет имеет тип

        struct epoll_event *

ровно как и есть то что мы подставли в epoll_wait

теперь еще раз смотрим на эту хрень

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

epfd - это  унас дескриптор еполл инстанса. (по аналогии с декрипором сокета)
-1 = это означает сколько времени ядро должно блокировать этот вызов держа проецсс в суспенде
если ничего не происходит. -1 означает что держать процесс в суспегде вечно пока ядро не 
зафиксирует интерсующее нас событие.
так вот второй аргумент это получается поинтер на кусок памяти в области памяти процесса куда ядро запишет массив данных. а это как раз таки будет массив состоящий из элементов гдекаждый 
элемент это 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

значит напомню что я записал в еполл инстанс такую хрень. что дескриптор 15. тоесть нужно
следить за дескриптором 15. и я передал поинтер вот на такую хрень 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

где в первом поле я записал 

   event.events = EPOLLIN;       

во второе поле я тоже кое что записал. я там выше не показал. но это неважно что у нас 
во втором поле. важно то что если у нас на дескриптр 15 поступят данные. то у нас прооисходит
событие EPOLLIN для дескриптора 15. и я дро фисркириует это событие. 
и кода я запущу вот эту хрень

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

то процсс будет лежать в супенде. а как толко произойдет указаное событие то ядро вернет
управление процесу. тоесть возвратится из epoll_wait и ядро запишет по адрусу который я 
указал в поинтере оно запишет целиком содержимое вот всей той хрени 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

которую я скорил ядру когда я совал в еполл настройки дескриптора 15

   epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event)

поэтому я увижу в массиве которое я подсуну ядру я увижу в точности тот контент 
который я вснунул в ядро при сованиив в него десрптора 15 
вот эту хрень я увижу

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

и вот это второе поле data оно нужно не ядру а мне. оно нужно мне чтобы я получил вспомнил
те полезные данные которые нужны именно мне. прикол в том что при насутплении события  с 
дескриптором 15 то ядро мне обратно это число 15 в явном виде не сообщит. оно мне просто
вернет тот масив который я совал в ядро при програмировании дескриптора 15. 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

первое поле оно не содержит номер дескриптора. 
единсвтенное место где я сам для себя мог сохранить инфорацию так с каким же декриптором 
чтото произошло полезное это второе поле. это второе поле нужно именно мне. а не ядру. на
настойки ядра оно не влияет. 

второе поле оно по факту явялется юнионом

     union epoll_data {
           void     *ptr;
           int       fd;
           uint32_t  u32;
           uint64_t  u64;
       };

    typedef union epoll_data  epoll_data_t;


так вот в этот юнион я сам должен записать ту инфорамацию которая мне будет полезна чтобы
я понял так какой же дескриптор у меня в итоге сгенерирровал ивент. 
самое простое взять и записать в этот юнион номер дескриптора вот так 

     struct epoll_event  event;
     event.data.fd = 15;


и тогда мне ядро вернет именно вот такой структ что 
первое поле будет равно EPOLLIN
а второе поле будет равно 15
и тогда смотрю на второе поле вижу там 15 и понимаю что у меня сработал ивент для 15-го 
дескриптора. 
если я сам для себя хочу получить расширеную информацию то я могу в второе поле
засунуть поинтер на любую структуру которая мне будет удобна. например 

   struct struc1 {
     int fd;
     char vasya[10];
   }

   struct struc1 s1;
   s1.fd = 15;
   strcpy(s1.vasya, "Gogy");

   void *p = &s1;

и тогда  суем этот поинтер во второе поле

    event.data.ptr = p;

тогда мне во втором поле ядро вернет этот поинтер. я могу пройти по адресу этого
поинтера и узнать расширеуннную инфомрацию по тот дескриптор котоырй я совал в ядро.
и получается теперь когда я узнать номер дескриптора на которой чтото прилетело. то 
я могу с этим дескриптором уже делать какието полезные дела. 
   


вот пример программы




  $ cat 261.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>


#define MAX_EVENTS 10




int main() {
    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем структуру epoll_event для добавления файловых дескрипторов
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // Добавляем файл в epoll
    event.events = EPOLLIN;  // Слушаем события на ввод
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < n; i++) {

            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }
        }
    }

    close(file_fd);
    close(epfd);

    return 0;
}


в этой прогрмме я выбираю чтобы второе поле лично для меня хранило номер дескриптора
котоорый я засунул в ядро

    event.events = EPOLLIN;  // Слушаем события на ввод
    event.data.fd = file_fd;  // Файл




значит как все работает


    // Создаем epoll инстанс
    int epfd = epoll_create1(0);


далее
создаю первую переменную она будет содержать в первом поле то событие которое я хочу
отловить это будет EPOLLIN и во втором поле она мне будет содержать номер декристора
чтобы мне потом понять на каком же дескрипторе произошло событие

    struct epoll_event event;


теперь создаю вторую перменную это уже массив. 

    struct epoll_event events[MAX_EVENTS];

это массив. где каждый элемент это  epoll_event 
и потом когда я запущу epoll_wait то  в этом массиве каждый элемент будет соотвествовать
событию на одном файл дескрипторе который я зарегистриовал на инстансе еполл.
при регистраиции дескриптора я также сую в ядро структ epoll_event поэтому когда ядро
регисриует событие на десркипторе то оно в ответ этот epoll_event мне обратно верент.
так как я могу зарегистрровать на еполл иснтансе тучу дескрипторов то epoll_wait
мне вернет целый массив элементов epoll_event где каждый из них это роовно та хрень которую
я совал я ядро при регистрации того или иного дескриптора. в моем случае каждый такой элеент
он будет отличаться вторым полем. там будет записано номер дескриптоора на котором получается
и произошол событие. 


открываю файл. мне нужно получмть номер файл дескриптора fd


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }


тепррь используя ранее созданный event  прописываю в нем дескипприптор file_fd 
и желаемое событие EPOLLIN 


    event.events = EPOLLIN;  
    event.data.fd = file_fd; 



теперь я  пихаю  внутрь ядра номер дескрипттора за которым нужно следить через  третий 
аргумент функции и пихаю событие EPOLLIN  которое мы хотим на нем поймать через четвертый аргумент
его первое поле . а второе поле оно на настройки epoll не влияет. это чисто будет мне информация
когда потом ядро мне вернет этот же event обратно.


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


все - мы дескриптоор номер и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас.

если бы я хотел добавит еще один дескриптор скажем 11 то я бы повторил операцию


    event.events = EPOLLIN;  
    event.data.fd = 11; 


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }



все - мы номер дескриптоора и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас. теперь осталось только ждать наступления события
и когда оно наступит забрать у ядра массив в который он насует epoll_event которые 
мы пихали в ядро при регстистрации декрипторов


        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события


epfd - это дескрипттор нашего epoll() ,  events это массив в который еполл вернет ответ,
а MAX_EVENTS это размер этого массива (так как у си не признака конца массива и ему нужно 
об этом говрорить в явной форме)


вот и все. теперь только остается пройтись по массиву.
найти номера дескрипторов в которых чтото произошло а именно прилеетела инфомрация.
и прочитать ее.


            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }

здесь я еще посяню то что у нас в переменной "int n" котоую возвращает epoll_wait() там будет
сумма элементов  массива.  поэтому используется вот эта строка
	
	        for (int i = 0; i < n; i++) {

которая нам дает взомжность пройтись по всему массиву так как через "n" мы знаем размер
этого массива. ну точнее размер массива MAX_EVENTS мы задали ранее. но число вернутых
дескрипторов может легко быть меньше. поэтмоу зачем пеербирать весь массив если можно перебрать
мЕньшее число элементов. 

и тогда мы берем элемет массива

		events[i].data.fd == file_fd

и проверяем есть ли в нем именно нужный нам номер декриптора. когда у нас под наблденеим
один дескриптоор то вроде как нет смысла . а вот когда неколько то смысла конечно есть. 
можно еще при желании лишний раз убедиться что в этм дескрипторпе поймано именно нужное нам
событие

	if (events[0].events & EPOLLIN) {
    	// Обрабатываем событие EPOLLIN (готовность для чтения)
	}


для повторного запуска epoll_wait() если что,  то уже все готово.
через epoll_ctl() можно при желании добавиьт или удалить дескриптор из числа налюдаемых
в данном сулчае укаан команда котооая обавляет дескриптор

	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 

еще раз хочу оподчерунуть что номер дескриптора который мы добавлем он указыается
через третий аргумент функции.  а тот номер дескриптооа котоырй мы записали во второе 
поле четвертого арумента это чисто нам для информации. он на настройки еполл не влияет.

    event.data.fd = file_fd; 




еще раз скажу что плюысы epoll по сравеннеию с poll() указанв в конце  статьи poll.txt 




ВАЖНЫЕ МОМЕНТЫ
можно указать для дескрпитоора сразу несолкько событий сразу. вот так 

    event.events = EPOLLIN|EPOLHUP;  

это логическое OR
тоест  еполл вернет этот дескрипттор если ЛЮБОЕ событие произойдет из  двух.
если же я попытаюсь добавить вначале одно событие

    event.events = EPOLLIN;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 


а потом второе 
    event.events = EPOLLHUP;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 
то на второй попытке добавить тот же дескрипттор линукс пошлет нахер. 
тоесть в ядре для одного дескриптоора сидит только оодна запись. а поэтому нужно все флаги
которые я хочу поймать указыать в одной записи. а если я хочу доавбить флаг то нужно
использовать EPOLL_CTL_MOD тоесть модифицировать запись.

также важно (об этом в man epoll_ctl написан ) что внезавиисмости указали мы флаг EPOLLHUP
или нет то ядро ВСЕГДА вернет это событие!


следущий важный момент. 
касается проверки результата. 
если я вот так буду проверять

  if (  events[i].events == EPOLLIN   ){
  }


то это ТРЕБУЕТ чтобы в events был устанолвен только один флаг. а других чтобы не было.

а если я вот так проверяю

  if (  events[i].events & EPOLLIN   ){
  }


то это требует чтобы в events этот флаг был а что там с другими флагами неважно.


это все имеет занчение когда у нас в ответе устанолвено сразу неколько флагов. например 

   events[i].events=EPOLLIN|EPOLLHUP

тогда если я буду проверять  этот через 

  if (  events[i].events == EPOLLIN   ){
  }

то  я не получу нихрена. потому что "==" требует точного соотвевтия.
а сработает только 

  if (  events[i].events & EPOLLIN   ){
  }


и


  if (  events[i].events & EPOLLHUP   ){
  }


обе эти проверки требуют чтобы был устанолвен такойто флаг а устанолвены ли остальные неважно.
насколко я понимаю вот такя проеверка  требует чтобы был усталовен либо такой флаг 
либо такой. а что касается осталных флагов то неважно


  if (  events[i].events & (EPOLLIN|EPOLLHUP)   ){
  }




следущий важный момент
полслоку у нас EPOLLHUP всегда ловится ядром и возврващается то если мы работаем с пайпом
и стой стороны пайп закрыли то у нас будет постоянно валится событие 

epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1

по крайней мере в рамках level-triggred
а так как они будут постяно валится то процесс будет грузить цпу на 100%
единсвеннй вариант это исключить данный дескриптор из  наблюдения.
закрыть файл пайпа и заново его открыть и вставит дескриптоор файла обратно в 
наблюение. при этом супер важно то что если закрыть файл и открыть файл а дескриптоор
оставит в очереди наблюдения (не удалять его) то это нихрена несраотает. поотому что если 
у нас был дескриптор 3. потому мы его закрыли. потом открыли тот же файл и получили тот же
номер десрипоиорра 3 то с тчоки зрения epoll это соверенно другой дескрипттор и он ничего
ловить не будет! также если закрыть файл. а потом пробовать удалить дескрипттор и еполл
он тоже выдасть ошибку. поэтому едиснвенный саособ это удалить десрпитор из еполл. потом
зкрыть файл. потом открть файл. потом добавить его дескрпитоор в еполл.. вот такая жопа.


в финале программа которая 262.c
которая открывает файл  /home/noroot/temp/nc/fifo1
котоырй именноованый пайп который надо заранее создат чрез

 $ mkfifo /home/noroot/temp/nc/fifo1 


а далее мы с другог отерминала открываем этот пайп и шлем бквы

  $ echo "1234" > ./fifo1

тогда наша программа она это ловит и печаатет. 
если мы несколкьо раз посылаем данные в пайп то она успешно 
их несколько раз ловит и печатает


  $ cat 262.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>

#define MAX_EVENTS 10

int main() {


   // открываем файл с диска
    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }



    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем две переменные одну для сования дескриптороа в ядро
    // а вторую для получения ответа из ядра
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];




    // Добавляем fd/0 плюс  EPOLLIN и\или EPOLLHUP в  ядро
    // добавлять EPOLLHUP необязатльно ибо ядро нам возвратить
    // этот ивент по любому
    event.events = EPOLLIN|EPOLLHUP;  
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd - EPOLLIN");
        exit(EXIT_FAILURE);
    }







    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }


        for (int i = 0; i < n; i++) {
            // ищем в элементе EPOLLIN 
            // и если он есть то читаем файл и печатаем на экране то что прочитали
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLIN)   ){
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from stdin: %s", buffer);
                }
            }

            // ищем в элементе EPOLLHUP
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLHUP)   ){
		     // удаялю его дескрипттор из epoll
		     if (epoll_ctl(epfd, EPOLL_CTL_DEL, file_fd, &event) == -1) {
                        perror("epoll_ctl: file_fd - EPOLL_CTL_DEL");
                        exit(EXIT_FAILURE);
                     }
            // закрываю файл
		     close(file_fd);

                    // открываю файл заново
                    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
                        if (file_fd == -1) { 
                           perror("open");
                           exit(EXIT_FAILURE);
                        }
                    // добалвяю его десприпторр в epoll
                    event.events = EPOLLIN|EPOLLHUP;
                    event.data.fd = file_fd;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
    				perror("epoll_ctl: file_fd - EPOLLIN");
    				exit(EXIT_FAILURE);
		    }

            }



        }
    }

    close(epfd);
    return 0;
}

----
