| epoll

значит перед чтением этой статьи я рекомендую прочтать select.txt и poll.txt
а потом уже эту стаью.

плюс epoll (в сравнении с poll)  в том что он возвращает только те события
которые мы у него заказали. а poll возврашает  любое событие которое произошло на 
сокете в независиомсти от того  какое событие мы заказали. 

остальные моменты сравнения poll и epoll я изложил в poll.txt в конце

итак теперь об как им пользоваться



  $ cat 261.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>


#define MAX_EVENTS 10




int main() {
    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем структуру epoll_event для добавления файловых дескрипторов
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // Добавляем файл в epoll
    event.events = EPOLLIN;  // Слушаем события на ввод
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < n; i++) {

            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }
        }
    }

    close(file_fd);
    close(epfd);

    return 0;
}



значит как все работает


    // Создаем epoll инстанс
    int epfd = epoll_create1(0);


далее
создаю первую переменную я буду пихать в ядро номер дескриптоора
который хочу наблюдать вместе с событием которое на нем хочу отловить 


    struct epoll_event event;


теперь создаю вторую перменную это уже массив. и она будет использоваться чтобы в нее
ядро вернуло при ответе те дескрпторы на которых были пойманы заказанные события
причем замечу что это уже массив  а непросто структ. забегаю сразу вперед на счет 
выбора размера массива через переменную MAX_EVENTS. название у нее дебиьное. дело совсем
не в ивентах. каждый элемент масиива будет содаржть номер дескриптоора. причем обязательно
все номера дескрипторов в массиве который вернет ядро будут уникальными. пэтому можно смело
утверждать что если мы собираемся пихать в ядро два дескриптора к примеру то максимльный размер
массива который ядро может вернуть это массив из двух элементов. ну наскока я понял в практкие
приянянто все таки размер эого массива делать несклолько больше с запасом. потому что сейчас
я засуну в ядро два дескриптора. а через 5 минут глядишь засуну 22 дескрпиптоора. 
тут есть еще один момент epoll() может работать врежиме level-triggres и edge-trigered.
в первом случае если событие на сокете произошло то epoll() будет его возвращать до тех пор
пока ситуация с этим событием на сокете не изменится. а если еполл() работает во втором режиме
то еполл вернет событие только в первый раз. а потом даже если состояние сокета не изменилось
оно уже это событие не возвращает. так вот по дефолту еполл работает на первом режиме. так вот
положим мы засунули в ядро 10 доескрипторов. а для ответа подсунули массив из 5-ти дескрипторов.
то что будет? напримр мы мониторим сокеты на чтение. положим что байты прилетели во все 10 
дескрипторов. а мы для ответа в еполл подсунули массив из 5-ти десктрипторов. епоол нам вернет
в этот массив 5 элементов. мы скажем из них прочитали из каждого пайпа. потом опять запускаем
epoll_wait() у нас получается из 10-ти дескрипороров у 5-ти состояние измеилось у них флаг 
EPOLLIN сбросился. а у 5-ти оставшися по прежнму он выставлен. поэтому нам epoll_wait() вернет
отставшиеся 5 дескрипторов  в наш массив из 5-ти элементов.  поэтом я хочу сказать что 
если массив из числа элементов мньше чем число дескрипторов под наблбдением то это еще не 
приговор. 


    struct epoll_event events[MAX_EVENTS];



открываю файл с пайаом. мне нужно получмть номер файл дескриптора fd


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }


тепррь используя ранее созданный event  прописываю в нем дескипприптор fd 
и желаемое событие EPOLLIN 


    event.events = EPOLLIN;  
    event.data.fd = file_fd; 



теперь я  пихаю  внутрь ядра дескрипттор fd и событие EPOLLIN для регистрации внутрии epoll()
тоесть регистрирую


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


все - мы дескриптоор номер и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас.

если бы я хотел добавит еще один дескриптор скажем 11 то я бы повторил операцию


    event.events = EPOLLIN;  
    event.data.fd = 11; 


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }



все - мы номер дескриптоора и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас. теперь осталось только ее забрать. делаем это


        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события


epfd - это дескрипттор нашего epoll() ,  events это массив в который еполл вернет ответ,
а MAX_EVENTS это размер этого массива (так как у си не признака конца массива и ему нужно 
об этом говрорить в явной форме)


вот и все. теперь только остается проверить что в массиве ответа у нас есть наш дескриптор
и тогда залезть в файл на который он указывает и прочитаь оттуда байты


            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }

здесь я еще посяню то что у нас в переменной "n" котоую возвращает epoll_wait() там будет
сумма от числа дескрипторов которые есть в вернутом массиве.  поэтому используется вот эта строка
	
	        for (int i = 0; i < n; i++) {

которая нам дает взомжность пройтись по всему массиву так как через "n" мы знаем размер
этого массива. ну точнее размер массива MAX_EVENTS мы задали ранее. но число вернутых
дескрипторов может легко быть меньше. поэтмоу зачем пеербирать весь массив если можно перебрать
мЕньшее число элементов. 

и тогда мы берем элемет массива

		events[i].data.fd == file_fd

и проверяем есть ли в нем именно нужный нам номер декриптора. когда у нас под наблденеим
один дескриптоор то вроде как нет смысла . а вот когда неколько то смысла конечно есть. 
можно еще при желании лишний раз убедиться что в этм дескрипторпе поймано именно нужное нам
событие

	if (events[0].events & EPOLLIN) {
    	// Обрабатываем событие EPOLLIN (готовность для чтения)
	}


для повторного запуска epoll_wait() если что то уже все готово.
через epoll_ctl() можно при желании добавиьт или удалить дескриптор из числа налюдаемых
в данном сулчае укаан команда котооая обавляет дескриптор

	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 

что сделано странно и дебилно это то что номер добаляем дескрпитоора он указывается в двух
местах. в аргументе epoll_ctl как это видно и в передаваемом теле переменноц event
в поле data.fd

    event.events = EPOLLIN;  
    event.data.fd = file_fd; 


зачем так сделано дебилно непонятно.


еще раз скажу что плюысы epoll по сравеннеию с poll() указанв в конце  статьи poll.txt 


ВАЖНЫЕ МОМЕНТЫ
можно указать для дескрпитоора сразу несолкько событий сразу. вот так 

    event.events = EPOLLIN|EPOLHUP;  

это логическое OR
тоест  еполл вернет этот дескрипттор если ЛЮБОЕ событие произойдет из  двух.
если же я попытаюсь добавить вначале одно событие

    event.events = EPOLLIN;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 


а потом второе 
    event.events = EPOLLHUP;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 
то на второй попытке добавить тот же дескрипттор линукс пошлет нахер. 
тоесть в ядре для одного дескриптоора сидит только оодна запись. а поэтому нужно все флаги
которые я хочу поймать указыать в одной записи. а если я хочу доавбить флаг то нужно
использовать EPOLL_CTL_MOD тоесть модифицировать запись.

также важно (об этом в man epoll_ctl написан ) что внезавиисмости указали мы флаг EPOLLHUP
или нет то ядро ВСЕГДА вернет это событие!


следущий важный момент. 
касается проверки результата. 
если я вот так буду проверять

  if (  events[i].events == EPOLLIN   ){
  }


то это ТРЕБУЕТ чтобы в events был устанолвен только один флаг. а других чтобы не было.

а если я вот так проверяю

  if (  events[i].events & EPOLLIN   ){
  }


то это требует чтобы в events этот флаг был а что там с другими флагами неважно.


это все имеет занчение когда у нас в ответе устанолвено сразу неколько флагов. например 

   events[i].events=EPOLLIN|EPOLLHUP

тогда если я буду проверять  этот через 

  if (  events[i].events == EPOLLIN   ){
  }

то  я не получу нихрена. потому что "==" требует точного соотвевтия.
а сработает только 

  if (  events[i].events & EPOLLIN   ){
  }


и


  if (  events[i].events & EPOLLHUP   ){
  }


обе эти проверки требуют чтобы был устанолвен такойто флаг а устанолвены ли остальные неважно.
насколко я понимаю вот такя проеверка  требует чтобы был усталовен либо такой флаг 
либо такой. а что касается осталных флагов то неважно


  if (  events[i].events & (EPOLLIN|EPOLLHUP)   ){
  }




следущий важный момент
полслоку у нас EPOLLHUP всегда ловится ядром и возврващается то если мы работаем с пайпом
и стой стороны пайп закрыли то у нас будет постоянно валится событие 

epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1

по крайней мере в рамках level-triggred
а так как они будут постяно валится то процесс будет грузить цпу на 100%
единсвеннй вариант это исключить данный дескриптор из  наблюдения.
закрыть файл пайпа и заново его открыть и вставит дескриптоор файла обратно в 
наблюение. при этом супер важно то что если закрыть файл и открыть файл а дескриптоор
оставит в очереди наблюдения (не удалять его) то это нихрена несраотает. поотому что если 
у нас был дескриптор 3. потому мы его закрыли. потом открыли тот же файл и получили тот же
номер десрипоиорра 3 то с тчоки зрения epoll это соверенно другой дескрипттор и он ничего
ловить не будет! также если закрыть файл. а потом пробовать удалить дескрипттор и еполл
он тоже выдасть ошибку. поэтому едиснвенный саособ это удалить десрпитор из еполл. потом
зкрыть файл. потом открть файл. потом добавить его дескрпитоор в еполл.. вот такая жопа.


в финале программа которая 262.c
которая открывает файл  /home/noroot/temp/nc/fifo1
котоырй именноованый пайп который надо заранее создат чрез

 $ mkfifo /home/noroot/temp/nc/fifo1 


а далее мы с другог отерминала открываем этот пайп и шлем бквы

  $ echo "1234" > ./fifo1

тогда наша программа она это ловит и печаатет. 
если мы несколкьо раз посылаем данные в пайп то она успешно 
их несколько раз ловит и печатает


  $ cat 262.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>

#define MAX_EVENTS 10

int main() {


   // открываем файл с диска
    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }



    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем две переменные одну для сования дескриптороа в ядро
    // а вторую для получения ответа из ядра
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];




    // Добавляем fd/0 плюс  EPOLLIN и\или EPOLLHUP в  ядро
    // добавлять EPOLLHUP необязатльно ибо ядро нам возвратить
    // этот ивент по любому
    event.events = EPOLLIN|EPOLLHUP;  
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd - EPOLLIN");
        exit(EXIT_FAILURE);
    }







    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }


        for (int i = 0; i < n; i++) {
            // ищем в элементе EPOLLIN 
            // и если он есть то читаем файл и печатаем на экране то что прочитали
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLIN)   ){
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from stdin: %s", buffer);
                }
            }

            // ищем в элементе EPOLLHUP
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLHUP)   ){
		     // удаялю его дескрипттор из epoll
		     if (epoll_ctl(epfd, EPOLL_CTL_DEL, file_fd, &event) == -1) {
                        perror("epoll_ctl: file_fd - EPOLL_CTL_DEL");
                        exit(EXIT_FAILURE);
                     }
            // закрываю файл
		     close(file_fd);

                    // открываю файл заново
                    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
                        if (file_fd == -1) { 
                           perror("open");
                           exit(EXIT_FAILURE);
                        }
                    // добалвяю его десприпторр в epoll
                    event.events = EPOLLIN|EPOLLHUP;
                    event.data.fd = file_fd;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
    				perror("epoll_ctl: file_fd - EPOLLIN");
    				exit(EXIT_FAILURE);
		    }

            }



        }
    }

    close(epfd);
    return 0;
}

----







 







