| epoll

значит перед чтением этой статьи я рекомендую прочтать select.txt и poll.txt
а потом уже эту стаью.

плюс epoll (в сравнении с poll)  в том что он возвращает только те события
которые мы у него заказали. а poll возврашает  любое событие которое произошло на 
сокете в независиомсти от того  какое событие мы заказали. 

остальные моменты сравнения poll и epoll я изложил в poll.txt в конце

для начала нужно понять что такое union в си. для этого читай c-union.txt
значит как работает epoll
создается внутри ядра некая хрень - инстанс epoll

    int epfd = epoll_create1(0);

как результат процессу возвращается дескриптор. это некий указатель на наш еполл внутри
ядра. как индентификатор который мы потом будем юзать как индетификатор. это такая же
аналогия как бутто мы сокет создали. только это не сокет а epoll инстанс.


далее нужно обьяснить ядру за какими файловыми дескриптооррами ядро должно следить
для нас. нужно эту инфо записать внутрь нашего epoll инстанса
делаем это мы так 

  epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event)

если  epoll_create1() это аналог socket() то epoll_ctl()  это аналог bind()
тоесть через epoll_ctl мы вносим настройки в epoll инстнас внутри ядра.

первый аргумент epfd это дескриптор еполл инстанса. это ровно тоже самое как мы укаызваем
в bind() дескриптор сокета.

второй аргумент EPOLL_CTL_ADD это мы сообщаем что мы хотим сделать. мы хотим добавить\записать
внутрь епоол инстанса номер нового файл дескриптора. 

третий аргумент file_fd - это как раз номер файл дескриптора котоырй мы хотим записать
внутрь еполл инстанса. это номер файл дескриптора за которым мы хотим чтобы ядро следило.

последний аргумент  &event  - это поинтер. это поинтер на вот такую структуру

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

значит какую роль играет эта структура? в первом ее поле 
    
    uint32_t      events

у нас в форме битовых флагов содержатся события которые ядро должно отслеживать для дескриптоора
номер кторого мы указали в третьем аргументе. 
по мне архитектура достатчно дебильная. почему. потому что у нас номер дескриптора за которым
следить указан в третьем аргументе фукции.  а какие события ловить на этом дескрипторе указано
в четвертом аргументе в его поле. это разнородно и неудобно сделано. я щас сразу покажу как
заносить занчение в первое поле структа epoll_event

   struct epoll_event  event;    \\ обьявляю переменную 
   event.events = EPOLLIN;       \\ присваиваю нашему структу первому полю значение EPOLLIN


где EPOLLIN это такой макрос который на самом деле выставляет некий бит. если мы хотим выставить
несколько битов то это будет примерно вот так

   event.events = EPOLLIN|EPOLLOUT;

размер первого поля структа это 4 байта. 
флаг EPOLLIN означает что в файл на который указывает дескриптор чтото пришло. ну мы не следим
никогда за обычными файлами. потому что у них всегда будет наступать событие EPOLLIN
а если дескриптор указыает например на пайп то вот когда у нас в пайп прилетят данные 
то у нас насутпиит с точки зрения ядра событие EPOLLIN

еще раз посмрим на структ

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

так вот второе поле (ВАЖНО) оно уже нихуя никак не влияет на настройки работы инстанса epoll.
самому epoll это поле вообще нахуй ненужно. так зачем оно нужно? а оно нужно вот зачем.
щас покажу. вот мы через вот такую хрень

   struct epoll_event  event;     
   event.events = EPOLLIN;       
   epoll_ctl(epfd, EPOLL_CTL_ADD, 15, &event)


мы заказываем записываем в епооллл инстанс задание для ядра чтобы если в файл на который 
укызает дескриптор 15 прибыли байты то ядро чтобы оно это заметило и зафиксировало.
теперь нам нужно както в программе узнать что ядро зафикировало интерсующее нас событие
на интерсующем нас дескрипторе. для этого нужно вот так сделать


        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);

у нас events это массив

       struct epoll_event events[MAX_EVENTS];

если мы вставляем имя массива как аргументв фукнцию то компилятор налету меняет текст
нашей прогарммы вот на такой что имя массива менется на поинтер на первый элемент этого
массива тоесть

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

так как у нас events это массив где каждый элемент имеет тип epoll_event
то тогда и первый элемент массива имеет тип struct epoll_event  и тогда поинтер на первый элмент
масива будет иметь тип 

       struct epoll_event*

сравним с тем что требует второй аргумент в спецификации к epoll_wait

        int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

тость второй аргумет имеет тип

        struct epoll_event *

ровно как и есть то что мы подставли в epoll_wait

теперь еще раз смотрим на эту хрень

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

epfd - это  унас дескриптор еполл инстанса. (по аналогии с декрипором сокета)
-1 = это означает сколько времени ядро должно блокировать этот вызов держа проецсс в суспенде
если ничего не происходит. -1 означает что держать процесс в суспегде вечно пока ядро не 
зафиксирует интерсующее нас событие.
так вот второй аргумент это получается поинтер на кусок памяти в области памяти процесса куда ядро запишет массив данных. а это как раз таки будет массив состоящий из элементов гдекаждый 
элемент это 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

значит напомню что я записал в еполл инстанс такую хрень. что дескриптор 15. тоесть нужно
следить за дескриптором 15. и я передал поинтер вот на такую хрень 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

где в первом поле я записал 

   event.events = EPOLLIN;       

во второе поле я тоже кое что записал. я там выше не показал. но это неважно что у нас 
во втором поле. важно то что если у нас на дескриптр 15 поступят данные. то у нас прооисходит
событие EPOLLIN для дескриптора 15. и я дро фисркириует это событие. 
и кода я запущу вот эту хрень

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

то процсс будет лежать в супенде. а как толко произойдет указаное событие то ядро вернет
управление процесу. тоесть возвратится из epoll_wait и ядро запишет по адрусу который я 
указал в поинтере оно запишет целиком содержимое вот всей той хрени 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

которую я скорил ядру когда я совал в еполл настройки дескриптора 15

   epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event)

поэтому я увижу в массиве которое я подсуну ядру я увижу в точности тот контент 
который я вснунул в ядро при сованиив в него десрптора 15 
вот эту хрень я увижу

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

и вот это второе поле data оно нужно не ядру а мне. оно нужно мне чтобы я получил вспомнил
те полезные данные которые нужны именно мне. прикол в том что при насутплении события  с 
дескриптором 15 то ядро мне обратно это число 15 в явном виде не сообщит. оно мне просто
вернет тот масив который я совал в ядро при програмировании дескриптора 15. 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

первое поле оно не содержит номер дескриптора. 
единсвтенное место где я сам для себя мог сохранить инфорацию так с каким же декриптором 
чтото произошло полезное это второе поле. это второе поле нужно именно мне. а не ядру. на
настойки ядра оно не влияет. 

второе поле оно по факту явялется юнионом

     union epoll_data {
           void     *ptr;
           int       fd;
           uint32_t  u32;
           uint64_t  u64;
       };

    typedef union epoll_data  epoll_data_t;


так вот в этот юнион я сам должен записать ту инфорамацию которая мне будет полезна чтобы
я понял так какой же дескриптор у меня в итоге сгенерирровал ивент. 
самое простое взять и записать в этот юнион номер дескриптора вот так 

     struct epoll_event  event;
     event.data.fd = 15;


и тогда мне ядро вернет именно вот такой структ что 
первое поле будет равно EPOLLIN
а второе поле будет равно 15
и тогда смотрю на второе поле вижу там 15 и понимаю что у меня сработал ивент для 15-го 
дескриптора. 
если я сам для себя хочу получить расширеную информацию то я могу в второе поле
засунуть поинтер на любую структуру которая мне будет удобна. например 

   struct struc1 {
     int fd;
     char vasya[10];
   }

   struct struc1 s1;
   s1.fd = 15;
   strcpy(s1.vasya, "Gogy");

   void *p = &s1;

и тогда  суем этот поинтер во второе поле

    event.data.ptr = p;

тогда мне во втором поле ядро вернет этот поинтер. я могу пройти по адресу этого
поинтера и узнать расширеуннную инфомрацию по тот дескриптор котоырй я совал в ядро.
и получается теперь когда я узнать номер дескриптора на которой чтото прилетело. то 
я могу с этим дескриптором уже делать какието полезные дела. 

теперь я дам пример программы

$ cat 359.c
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <errno.h>
#include <stdio.h>








int main() {

    

int epfd, epfd2 ;



    // Создаем epoll инстанс
    epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем epoll инстанс
    epfd2 = epoll_create1(0);
    if (epfd2 == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    sleep(60);

   close(epfd);
   close(epfd2);


};


в ней я создаю два еполл инстанса. 
НО! ОГРОМНЫЙ ПРИКОЛ!
с точки зрения proc и fdinfo оба дескрпторра выглядяит так как бутоо они указывают 
НА ОДИН И ТОТ ЖЕ ИНСТАНС ЕПОЛЛ ОБЬЕКТ В ЯДРЕ! ЭТО ПИЗДЕЦ

$ lsof -Pnp $(pidof 359.exe) | grep -E "FD|event"
COMMAND    PID   USER  FD      TYPE DEVICE SIZE/OFF      NODE NAME
359.exe 952065 noroot   3u  a_inode   0,16        0      1090 [eventpoll]
359.exe 952065 noroot   4u  a_inode   0,16        0      1090 [eventpoll]

  $ cat /proc/$(pidof 359.exe)/fdinfo/3
pos:    0
flags:  02
mnt_id: 17
ino:    1090

  $ cat /proc/$(pidof 359.exe)/fdinfo/4
pos:    0
flags:  02
mnt_id: 17
ino:    1090

свойства декрипторо 3 и 4 АБСОЛЮТНО ОДИНАКОВЫЕ! 
это нас приводит к тому что если я смотрю на дескрипторы epoll в proc то я не смогу
никогда и никак понять эти два декрптора они укаызывают на два разных еполл инстанса
или на один и тот же еполл инстанс в ядре. 
а эт супер важно если у нас ест два процесса и у каждгого есть дескриптор который вдеет не 
еполл. и мы должны понять это два арахных еполл инстаса или он один и тот же. 
например такая задача есть когда мы смотрим на процессы nginx. 
так вот получается - мы это понять не можем! с точки зрения fdinfo якобы это один и тот же обьект
в ядре. а на самом делео получяается хуй знает.





теперь  пример программы
она пока неоченьсложная



  $ cat 261.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>


#define MAX_EVENTS 10




int main() {
    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем структуру epoll_event для добавления файловых дескрипторов
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // Добавляем файл в epoll
    event.events = EPOLLIN;  // Слушаем события на ввод
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < n; i++) {

            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }
        }
    }

    close(file_fd);
    close(epfd);

    return 0;
}


в этой прогрмме я выбираю чтобы второе поле лично для меня хранило номер дескриптора
котоорый я засунул в ядро

    event.events = EPOLLIN;  // Слушаем события на ввод
    event.data.fd = file_fd;  // Файл




значит как все работает


    // Создаем epoll инстанс
    int epfd = epoll_create1(0);


далее
создаю первую переменную она будет содержать в первом поле то событие которое я хочу
отловить это будет EPOLLIN и во втором поле она мне будет содержать номер декристора
чтобы мне потом понять на каком же дескрипторе произошло событие

    struct epoll_event event;


теперь создаю вторую перменную это уже массив. 

    struct epoll_event events[MAX_EVENTS];

это массив. где каждый элемент это  epoll_event 
и потом когда я запущу epoll_wait то  в этом массиве каждый элемент будет соотвествовать
событию на одном файл дескрипторе который я зарегистриовал на инстансе еполл.
при регистраиции дескриптора я также сую в ядро структ epoll_event поэтому когда ядро
регисриует событие на десркипторе то оно в ответ этот epoll_event мне обратно верент.
так как я могу зарегистрровать на еполл иснтансе тучу дескрипторов то epoll_wait
мне вернет целый массив элементов epoll_event где каждый из них это роовно та хрень которую
я совал я ядро при регистрации того или иного дескриптора. в моем случае каждый такой элеент
он будет отличаться вторым полем. там будет записано номер дескриптоора на котором получается
и произошол событие. 


открываю файл. мне нужно получмть номер файл дескриптора fd


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }


тепррь используя ранее созданный event  прописываю в нем дескипприптор file_fd 
и желаемое событие EPOLLIN 


    event.events = EPOLLIN;  
    event.data.fd = file_fd; 



теперь я  пихаю  внутрь ядра номер дескрипттора за которым нужно следить через  третий 
аргумент функции и пихаю событие EPOLLIN  которое мы хотим на нем поймать через четвертый аргумент
его первое поле . а второе поле оно на настройки epoll не влияет. это чисто будет мне информация
когда потом ядро мне вернет этот же event обратно.


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


все - мы дескриптоор номер и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас.

если бы я хотел добавит еще один дескриптор скажем 11 то я бы повторил операцию


    event.events = EPOLLIN;  
    event.data.fd = 11; 


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }



все - мы номер дескриптоора и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас. теперь осталось только ждать наступления события
и когда оно наступит забрать у ядра массив в который он насует epoll_event которые 
мы пихали в ядро при регстистрации декрипторов


        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события


epfd - это дескрипттор нашего epoll() ,  events это массив в который еполл вернет ответ,
а MAX_EVENTS это размер этого массива (так как у си не признака конца массива и ему нужно 
об этом говрорить в явной форме)


вот и все. теперь только остается пройтись по массиву.
найти номера дескрипторов в которых чтото произошло а именно прилеетела инфомрация.
и прочитать ее.


            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }

здесь я еще посяню то что у нас в переменной "int n" котоую возвращает epoll_wait() там будет
сумма элементов  массива.  поэтому используется вот эта строка
	
	        for (int i = 0; i < n; i++) {

которая нам дает взомжность пройтись по всему массиву так как через "n" мы знаем размер
этого массива. ну точнее размер массива MAX_EVENTS мы задали ранее. но число вернутых
дескрипторов может легко быть меньше. поэтмоу зачем пеербирать весь массив если можно перебрать
мЕньшее число элементов. 

и тогда мы берем элемет массива

		events[i].data.fd == file_fd

и проверяем есть ли в нем именно нужный нам номер декриптора. когда у нас под наблденеим
один дескриптоор то вроде как нет смысла . а вот когда неколько то смысла конечно есть. 
можно еще при желании лишний раз убедиться что в этм дескрипторпе поймано именно нужное нам
событие

	if (events[0].events & EPOLLIN) {
    	// Обрабатываем событие EPOLLIN (готовность для чтения)
	}


для повторного запуска epoll_wait() если что,  то уже все готово.
через epoll_ctl() можно при желании добавиьт или удалить дескриптор из числа налюдаемых
в данном сулчае укаан команда котооая обавляет дескриптор

	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 

еще раз хочу оподчерунуть что номер дескриптора который мы добавлем он указыается
через третий аргумент функции.  а тот номер дескриптооа котоырй мы записали во второе 
поле четвертого арумента это чисто нам для информации. он на настройки еполл не влияет.

    event.data.fd = file_fd; 




еще раз скажу что плюысы epoll по сравеннеию с poll() указанв в конце  статьи poll.txt 




ВАЖНЫЕ МОМЕНТЫ
можно указать для дескрпитоора сразу несолкько событий сразу. вот так 

    event.events = EPOLLIN|EPOLHUP;  

это логическое OR
тоест  еполл вернет этот дескрипттор если ЛЮБОЕ событие произойдет из  двух.
если же я попытаюсь добавить вначале одно событие

    event.events = EPOLLIN;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 


а потом второе 
    event.events = EPOLLHUP;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 
то на второй попытке добавить тот же дескрипттор линукс пошлет нахер. 
тоесть в ядре для одного дескриптоора сидит только оодна запись. а поэтому нужно все флаги
которые я хочу поймать указыать в одной записи. а если я хочу доавбить флаг то нужно
использовать EPOLL_CTL_MOD тоесть модифицировать запись.

также важно (об этом в man epoll_ctl написан ) что внезавиисмости указали мы флаг EPOLLHUP
или нет то ядро ВСЕГДА вернет это событие!


следущий важный момент. 
касается проверки результата. 
если я вот так буду проверять

  if (  events[i].events == EPOLLIN   ){
  }


то это ТРЕБУЕТ чтобы в events был устанолвен только один флаг. а других чтобы не было.

а если я вот так проверяю

  if (  events[i].events & EPOLLIN   ){
  }


то это требует чтобы в events этот флаг был а что там с другими флагами неважно.


это все имеет занчение когда у нас в ответе устанолвено сразу неколько флагов. например 

   events[i].events=EPOLLIN|EPOLLHUP

тогда если я буду проверять  этот через 

  if (  events[i].events == EPOLLIN   ){
  }

то  я не получу нихрена. потому что "==" требует точного соотвевтия.
а сработает только 

  if (  events[i].events & EPOLLIN   ){
  }


и


  if (  events[i].events & EPOLLHUP   ){
  }


обе эти проверки требуют чтобы был устанолвен такойто флаг а устанолвены ли остальные неважно.
насколко я понимаю вот такя проеверка  требует чтобы был усталовен либо такой флаг 
либо такой. а что касается осталных флагов то неважно


  if (  events[i].events & (EPOLLIN|EPOLLHUP)   ){
  }




следущий важный момент
полслоку у нас EPOLLHUP всегда ловится ядром и возврващается то если мы работаем с пайпом
и стой стороны пайп закрыли то у нас будет постоянно валится событие 

epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1

по крайней мере в рамках level-triggred
а так как они будут постяно валится то процесс будет грузить цпу на 100%
единсвеннй вариант это исключить данный дескриптор из  наблюдения.
закрыть файл пайпа и заново его открыть и вставит дескриптоор файла обратно в 
наблюение. при этом супер важно то что если закрыть файл и открыть файл а дескриптоор
оставит в очереди наблюдения (не удалять его) то это нихрена несраотает. поотому что если 
у нас был дескриптор 3. потому мы его закрыли. потом открыли тот же файл и получили тот же
номер десрипоиорра 3 то с тчоки зрения epoll это соверенно другой дескрипттор и он ничего
ловить не будет! также если закрыть файл. а потом пробовать удалить дескрипттор и еполл
он тоже выдасть ошибку. поэтому едиснвенный саособ это удалить десрпитор из еполл. потом
зкрыть файл. потом открть файл. потом добавить его дескрпитоор в еполл.. вот такая жопа.


в финале программа которая 262.c
которая открывает файл  /home/noroot/temp/nc/fifo1
котоырй именноованый пайп который надо заранее создат чрез

 $ mkfifo /home/noroot/temp/nc/fifo1 


а далее мы с другог отерминала открываем этот пайп и шлем бквы

  $ echo "1234" > ./fifo1

тогда наша программа она это ловит и печаатет. 
если мы несколкьо раз посылаем данные в пайп то она успешно 
их несколько раз ловит и печатает


  $ cat 262.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>

#define MAX_EVENTS 10

int main() {


   // открываем файл с диска
    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }



    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем две переменные одну для сования дескриптороа в ядро
    // а вторую для получения ответа из ядра
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];




    // Добавляем fd/0 плюс  EPOLLIN и\или EPOLLHUP в  ядро
    // добавлять EPOLLHUP необязатльно ибо ядро нам возвратить
    // этот ивент по любому
    event.events = EPOLLIN|EPOLLHUP;  
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd - EPOLLIN");
        exit(EXIT_FAILURE);
    }







    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }


        for (int i = 0; i < n; i++) {
            // ищем в элементе EPOLLIN 
            // и если он есть то читаем файл и печатаем на экране то что прочитали
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLIN)   ){
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from stdin: %s", buffer);
                }
            }

            // ищем в элементе EPOLLHUP
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLHUP)   ){
		     // удаялю его дескрипттор из epoll
		     if (epoll_ctl(epfd, EPOLL_CTL_DEL, file_fd, &event) == -1) {
                        perror("epoll_ctl: file_fd - EPOLL_CTL_DEL");
                        exit(EXIT_FAILURE);
                     }
            // закрываю файл
		     close(file_fd);

                    // открываю файл заново
                    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
                        if (file_fd == -1) { 
                           perror("open");
                           exit(EXIT_FAILURE);
                        }
                    // добалвяю его десприпторр в epoll
                    event.events = EPOLLIN|EPOLLHUP;
                    event.data.fd = file_fd;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
    				perror("epoll_ctl: file_fd - EPOLLIN");
    				exit(EXIT_FAILURE);
		    }

            }



        }
    }

    close(epfd);
    return 0;
}





А ТЕПЕРЬ пример самой сложной программы с epoll

 ' ჳ  $ cat 358.c
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/epoll.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <semaphore.h>
#define MAX_EVENTS 3


// Глобальная переменная для хранения pid дочернего процесса
pid_t child_pid = -1;
int epfd = -1;  // Глобальная переменная для epoll-дескриптора
sem_t *sem;



int is_fd_valid(int fd) {
    // Проверяем, является ли дескриптор файла валидным
    if (fcntl(fd, F_GETFD) == -1) {
        if (errno == EBADF) {
            // Дескриптор не существует или недействителен
            return 0;  // Дескриптор не существует
        } else {
            // Произошла другая ошибка
            perror("fcntl");
            return -1;  // Ошибка при проверке
        }
    }
    // Дескриптор существует
    return 1;
}



void handle_sigint(int sig) {

    const char *message = "Получен сигнал SIGINT. Завершаем работу...\n";
    write(STDOUT_FILENO, message, strlen(message));  // Используем write вместо printf

    // Завершаем дочерний процесс, если он существует
    if (  (child_pid > 0)  &&  (getpid() != child_pid)  ){
        kill(child_pid, SIGINT);
        waitpid(child_pid, NULL, 0);  // Ожидаем завершения дочернего процесса
    }

    const char *message1 = "закрываем epfd...\n";
    write(STDOUT_FILENO, message1, strlen(message1));  // Используем write вместо printf

    // Закрываем epoll-дескриптор, если он открыт
    if (epfd != -1) {
        close(epfd);
    }


    // Закрываем семафор
        sem_close(sem);
        sem_unlink("/my_semaphore"); // Удаляем семафор


    exit(0);  // Завершить процесс с кодом успеха

}






void make_socket_non_blocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        exit(EXIT_FAILURE);
    }
}




void handle_client(int z)
{
    char buf[8192];
    char *lastpos;

    while (1) {
        ssize_t n  = recv(z, buf, sizeof(buf), 0);
        if (n > 0) {
            // Данные успешно прочитаны
            dprintf(z, "pid = %i | ", getpid());
            lastpos = strchr(buf, '\n');
            send(z, buf, lastpos+1-buf, 0);
        }  else if (n == 0) {
             // Другая сторона закрыла соединение
             printf("Соединение закрыто другой стороной.\n");
             if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
             perror("epoll_ctl: EPOLL_CTL_DEL");
             exit(EXIT_FAILURE);
             };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
             break;
        } else {
            // Ошибка
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // Данных нет (это нормально для неблокирующего сокета)
                break;
            } else {
                // Ошибка соединения
                perror("Ошибка в recv");
            if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
            perror("epoll_ctl: EPOLL_CTL_DEL");
            exit(EXIT_FAILURE);
            };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
            break;
            }
        }
    } // while END


}  // function END







int main() {

    
    // Устанавливаем обработчик для SIGINT
    struct sigaction sa;
    sa.sa_handler = handle_sigint;  // Функция-обработчик
    sigemptyset(&sa.sa_mask);       // Не блокируем другие сигналы
    sa.sa_flags = 0;                // Без дополнительных флагов

    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("Не удалось установить обработчик SIGINT");
        exit(EXIT_FAILURE);
    }



  // Создаем POSIX семафор с именем "/my_semaphore", инициализируем значением 1
    sem = sem_open("/my_semaphore", O_CREAT | O_EXCL, 0644, 1);
    if (sem == SEM_FAILED) {
        perror("Не удалось создать семафор");
        exit(EXIT_FAILURE);
    }
    
    


    int s;
    int c;
    int reuseaddr = 1;
    struct sockaddr_in addr;
    socklen_t addr_len;

    s = socket(AF_INET, SOCK_STREAM, 0);
    if ( s < 0 ){
        perror("не удалось создать сокет");
    };
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));

    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr_len = sizeof(addr);

    if ( bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0  ){
         perror("не удалось сделать bind");
    };
    
    listen(s, 5);






        child_pid = fork(); // клонируемся
        if (child_pid == -1) {
            exit(1);
        } 





    // Создаем epoll инстанс
    epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем две переменные одну для сования дескриптороа в ядро
    // а вторую для получения ответа из ядра
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];


    // Добавляем дескриптор сокета  в еполл инстанс  плюс  EPOLLIN 
    event.events = EPOLLIN | EPOLLET;
    event.data.fd = s;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, s, &event) == -1) {
        perror("epoll_ctl: file_fd - EPOLLIN");
        exit(EXIT_FAILURE);
    }




        while (1) {
            int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
            if (n < 0) {
             if (errno == EINTR) {
                // Если вызов был прерван сигналом, просто продолжаем цикл
                continue;
                };
            perror("epoll_wait");
            exit(EXIT_FAILURE);
            }


            printf("я в цикле после epoll_wait , pid = %i, n = %i\n", getpid(), n);
            for (int k = 0; k < n; k++) {
            if (  (events[k].data.fd == s) && (events[k].events & EPOLLIN)   ){
                   printf("я в цикле после epoll_wait pid = %i, дескриптор = %i\n", getpid(), s);


                   if (sem_trywait(sem) == 0) {
                   // Семафор захвачен успешно
                   printf("Процесс %d захватил семафор\n", getpid());

                    c = accept(s, (struct sockaddr *)&addr, &(addr_len) );
                    if (c == -1) {
                        perror("Ошибка при принятии соединения");
                        continue; // Продолжить цикл, если произошла ошибка
                        } 
                    event.events = EPOLLIN | EPOLLET;
                    event.data.fd = c;  // Файл
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, c, &event) == -1) {
                          perror("epoll_ctl: file_fd - EPOLLIN");
                          exit(EXIT_FAILURE);
                    }
                    make_socket_non_blocking(c);
                    handle_client(c);

        printf("Процесс %d завершил работу и освободил семафор\n", getpid());
        sem_post(sem); // Освобождаем семафор

    } else if (errno == EAGAIN) {
        // Семафор занят
        printf("Процесс %d не смог захватить семафор (занят)\n", getpid());
        break;
    } else {
        // Ошибка при попытке захватить семафор
        perror("Ошибка при захвате семафора");
        break;
    }



                }; //if END
               
  
                if (  (events[k].data.fd != s) && (events[k].events & EPOLLIN)   ) {
                     printf("я  цикле после epoll_wait pid = %i, дескриптор  = %i\n", getpid(), events[k].data.fd);
                     int result = is_fd_valid(events[k].data.fd);
                       if (result == 1) {
                           printf("pid = %i, Дескриптор %d существует.\n", getpid(), events[k].data.fd);
                           handle_client(events[k].data.fd);
                          } else if (result == 0) {
                            printf("pid = %i, Дескриптор %d не существует.\n", getpid(), events[k].data.fd);
                            break;
                          } else {
                                printf("Произошла ошибка при проверке дескриптора %d.\n", events[k].data.fd);
                                break;
                          }


                };  //if END




            }; //for END



    }; //while END
                

           // зарвыаем еполл инстанс
             if (is_fd_valid(epfd) == 1) {
                close(epfd);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", epfd);
              }
      
            // закрываем сокет
             if (is_fd_valid(s) == 1) {
                close(s);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", s);
              }

    // Закрываем семафор
        sem_close(sem);
        sem_unlink("/my_semaphore"); // Удаляем семафор
            
        if (child_pid==0){
           printf ("чайлд программа успешно закончила работу \n");

        };
        

        if (child_pid > 0) {
            waitpid(child_pid, NULL, 0);
           printf ("парент программа успешно закончила работу \n");

        }


};


 $ ./358.exe

теперь мы атакуем эту программы с другого терминала

 $  while(:); do echo "123" |  nc -q1 localhost 8080 ; done 
pid = 953513 | 123
pid = 953514 | 123
pid = 953513 | 123
pid = 953514 | 123
pid = 953514 | 123
pid = 953514 | 123
pid = 953514 | 123
^C


при этом на терминале программы мы увидим
 $ ./358.exe
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953513 захватил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
Процесс 953514 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953513 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
Процесс 953514 захватил семафор
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953513, дескриптор = 3
я в цикле после epoll_wait , pid = 953514, n = 1
Процесс 953513 захватил семафор
я в цикле после epoll_wait pid = 953514, дескриптор = 3
Процесс 953514 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953513 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
^CПолучен сигнал SIGINT. Завершаем работу...
закрываем epfd...
Получен сигнал SIGINT. Завершаем работу...
закрываем epfd...



щас я расскажу все моменты связанные с программой. 
она ракскрыла дохоена всего важного про то как все устроено .
поехали



int main() {

    
    // Устанавливаем обработчик для SIGINT
    struct sigaction sa;
    sa.sa_handler = handle_sigint;  // Функция-обработчик
    sigemptyset(&sa.sa_mask);       // Не блокируем другие сигналы
    sa.sa_flags = 0;                // Без дополнительных флагов

    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("Не удалось установить обработчик SIGINT");
        exit(EXIT_FAILURE);
    }



этот кусок нам устанавливает кастомный хендлер обработки SIGINT который происхдоит 
если мы тыкаем Ctrl+C 
причем если у нас в терминале работает несколко процессов то как сказал ии сигнал SIGINT 
будет послан всем процессам привязанным к этому терминалу.
забегая вперед скажу что у нас будет два процесса. а каждый процесс у нас это независимая
сущность так что данный хендлер будет обрабаыаться обоими процессами самтостельно и отельно

далее второй кусок который отвечает за хендлер обработкчика сигнала SIGINT


void handle_sigint(int sig) {

    const char *message = "Получен сигнал SIGINT. Завершаем работу...\n";
    write(STDOUT_FILENO, message, strlen(message));  // Используем write вместо printf

    // Завершаем дочерний процесс, если он существует
    if (  (child_pid > 0)  &&  (getpid() != child_pid)  ){
        kill(child_pid, SIGINT);
        waitpid(child_pid, NULL, 0);  // Ожидаем завершения дочернего процесса
    }

    const char *message1 = "закрываем epfd...\n";
    write(STDOUT_FILENO, message1, strlen(message1));  // Используем write вместо printf

    // Закрываем epoll-дескриптор, если он открыт
    if (epfd != -1) {
        close(epfd);
    }

    // Закрываем семафор
        sem_close(sem);
        sem_unlink("/my_semaphore"); // Удаляем семафор


    exit(0);  // Завершить процесс с кодом успеха

}



мы что в нем делаем. 
мы определяем где мы щас в  дочернем процессе или парент процессе. если в парент
процессе то мы шлем в дочерйний процесс SIGINT. ждем когда дочь подохнет. и управление
вернетя обратно к нам. далее мы закрываем файл дескриторы. и что важно мы завершаем работу
процесса. этот хендлер будет выполенен как на дочке так и на паренте. с той лишь разницей
что если это парен процесс то он еще пошлет дочке сигнал SIGINT. 
возникает вопрос - если мы жмем Ctrl+C то ядро SIGINT шлет каким процессам? 
во первых вот дказательство что сигнал шлет именно ядро а не кто другой
если скажем у нас есть в терминале баш с pid=956881
то я могу отследить какие сигналы прилетают к нему

$ sudo strace -e trace=signal -p 956881 2>&1 | grep -- "---"
--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---

так вот видно что источкник отправки сигнала именно ядро si_code=SI_KERNEL а некакойто
юзер процес.

теперь вопрос - вот у нас есть куча процессов кторые все имеют открытмм утсроство терминал.
мы жмем Ctr+C - то каким процссами ядро пошлет SIGINT?
ОТВЕТ - дело в том что процессы для ядра обьединяются например по признаку PGID - группа
процессов. (не путать с группой юзеров).  так вот процессы которые имеют откртым данный
терминал они все сидят в разных группа процессов. так вот средит этих групп есть одна
группа особая - она отмечается спец признаком что она явлется непросто группой процесов
а   FOREGROUND PROCESS GROUP .  а все остальыне группы прцессов автоматом явлаются 
backckgrund process groups. фореграунд группа для терминала может быть только одна.
так вот когда мы тыакеаем Ctrl+C то ядро шлет SIGINT все проецссам которвые входят в состав
foreground process group. как нам через ps понять для даного терминала какие процессы
на нем сият. в какие процесс группы они разделаются. и какая группа средит этих групп
является форграуенд? вот эта волшеная формула


 $  ps -eo pid,pgid,tpgid,tty,cmd | grep -E "PID|pts/1 " | grep -v grep
    PID    PGID   TPGID TT       CMD
 956881  956881  960041 pts/1    /bin/bash -rcfile .bashrc
 960041  960041  960041 pts/1    ./358.exe
 960042  960041  960041 pts/1    ./358.exe



значит PGID - это номер группы процессов куда входит данный процесс.
TPGID - это штука покаызывает какой PGID является FOREGROUND PROCESS GROUP. 
тоесть получается что на терминале у нас всего две группы процессов

    PGID
    956881
    960041

и среди этих двух привлигиорванной явлется
    TPGID
    960041

надо подчеркуть что TPGID это всегда штука которая явлется одной из членов PGID
такого неможет быть что у нас TPGID такой что его нету в списке PGID
тогда мы теперь выбрраем проецссы у которых PGID=TPGID=960041

    PID    PGID   TPGID TT       CMD
 960041  960041  960041 pts/1    ./358.exe
 960042  960041  960041 pts/1    ./358.exe


вот именно этим двум процессам и будет направлен со стороны ядра SIGINT!
а так как баш входит в другую группу

    PID    PGID   TPGID TT       CMD
 956881  956881  960041 pts/1    /bin/bash -rcfile .bashrc


то ему этот сигнал направлен не будет!

вот такая вот разгадка о том - каки процессам которые закерплены за терминалом у нас ядро
напоалвяет SIGINT при нажатти Ctrl+C. это далеко не все прцоессы!

исходя из того что я увидел. у нас полуатся два процесса нашей программы они будут входит
в одну форегрунунд группу 

    PID    PGID   TPGID TT       CMD
 960041  960041  960041 pts/1    ./358.exe
 960042  960041  960041 pts/1    ./358.exe


и поэтому пои идее вот этот кусок кода излишний в хендлере


    // Завершаем дочерний процесс, если он существует
    if (  (child_pid > 0)  &&  (getpid() != child_pid)  ){
        kill(child_pid, SIGINT);
        waitpid(child_pid, NULL, 0);  // Ожидаем завершения дочернего процесса
    }

потому что ядро так и так при нажаиии на ctrl+c пошлет сигнал и паренту и дочерней проге.
правда дургое дело если мы пошлем sigint рукамми через командуню строку на парент. 
тогда только благодаря этому куску он еще за компнию прибьет и чайлда. 

это  явсего навсего только пока разобрал обработчик ctrl+C 

естственно есть либц фукнции которые позоляют менять для процесса ту фигню что работает ли
он в форегрануден гурппе процессов или нет. также форграудно группа процессов особенная 
еще и тем что только этим процессам рарзрешается на данный момент читать либо писать в терминал.
если это попрбует сделать поцесс котторый принадлежит к бекгрануд группе прцоессов то его 
ядро остановит через SIGSTOP

если мы возьмем процесс то у него 8-е поле в /proc/pid/stat как раз показыает TPGID
для того терминала к которому прроцесс принадлежит

  man proc

    (8) tpgid  %d
                     The ID of the foreground process group of the controlling terminal of the process.

именно это поле и покзыает ps при ключе tpgid



двигаем дальше по коду.
наша основаня цель понять как работает еполл. какие ттам есть приколы.


  // Создаем POSIX семафор с именем "/my_semaphore", инициализируем значением 1
    sem = sem_open("/my_semaphore", O_CREAT | O_EXCL, 0644, 1);
    if (sem == SEM_FAILED) {
        perror("Не удалось создать семафор");
        exit(EXIT_FAILURE);
    }
    

эта штука создает обьект семафор. внутри ядра. он нам поможет делать арбитраж. об этом 
пожже.



далее

    int s;
    int c;
    int reuseaddr = 1;
    struct sockaddr_in addr;
    socklen_t addr_len;

    s = socket(AF_INET, SOCK_STREAM, 0);
    if ( s < 0 ){
        perror("не удалось создать сокет");
    };


этим я создаю сокет.

далее

    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));


этой строкой я меню свойства сокета. я устанавливаею свойство  SO_REUSEADDR
нахуй оно нужно? 
щас раскажу.
вот у нас между компом-А и компом-Б установлен tcp конект. неважно кто был инициатором.
после создания конекта оба компа становятся абсолютно равнозначными.
так вот далее начинается очень важная хрень. Положим у нас комп-А имеет слушающий сокет.
тоесть он выступает при создании соединения сервером тоесть пассивной хренью. тоесть
конект инцииурется от компа-Б. я уже сказал что якобы неважно кто инициирует конект - да
это в целом неважно но для более легкого понимания я покажу на примере компа который
при создании конкета явлется сервером. и какая проблема там может возникнуть. эта же
проблема может возникнуть и на компе которй инцииатор(тоесть клиент) но это рассмтотрим потом
там это реже возникает хотя тоже вомзожно. просто легче поймать проблему о которой пойдетречь
именно на tcp сервере хотя в целом это неважно! так вот соединение установлено. теперь
у нас одна из сторон начинает гасить конект. очень важно оказывается кто это делает. 
в нашем примерер инцииатором закончить конект будет комп-А (который tcp сервер).
так вот у нас tcp конект характиеруеизется состоянием двух сокетов. сокет на компе-А
и сокет на компе-Б. так вот комп-А шлет FIN пакет на комп-Б
как только комп-А из себя высрал FIN пакет то статус сокета у него становится равным
FIN-WAIT-1


  комп-А (FIN-WAIT-1)--------FIN------>комп-Б

какой статус на компе-Б когда он плучает пакет щас неважно.
в ответ комп-Б шлет пакет ACK+FIN
флагом ack он подтвеждает что получил пакет с флагом fin а флагом fin он показывает что 
тоже со совей стороны закончил соединение. 


  комп-А (FIN-WAIT-1)<--------FIN+ACK-----комп-Б


когда этот пакет влетает на комп-А то у него статус сокета прерващается в FIN-WAIT-2


  комп-А (FIN-WAIT-2)---------------------комп-Б


в ответ комп-А шлет пакет ACK. этим он потдтвеждтае что получил полсанный ему пакет
как только комп-А высрал ack пакет в сеть то статус сокета становится TIME-WAIT

  комп-А (TIME-WAIT)------ACK------------->комп-Б

 

статус сокета на компе-Б становится CLOSE.
на этом обмен пакетами заканчиается.
так как на компе-Б статус сокета становится CLOSE то я не знаю удаляет ли его ядро
из памяти сразу. но по крайней мере сокет удаляется из списка так назыамых активных сокетов.
а это значит что сокета уже как бы нет. тоесть ядро не анализирует его контент при принятии решений при создании нвоых сокетов. дело в том что новый сокет при создании может конфликтовать
с другим старым сокетом и ядро это проверяет. так вот сокет в состоянии CLOSE его уже не
видно в ss. потому его нет в спсике активных сокетов. поэтому его уже как бы и вообще нет.
в таблцие netfuleter вроде бы еще можо видеиь .вот пример


$ sudo conntrack -L | grep -i close
tcp      6 1 CLOSE src=172.16.10.1 dst=172.16.10.11 sport=55434 dport=2080 src=172.16.10.11 dst=172.16.10.1 sport=2080 dport=55434 [ASSURED] mark=0 use=1

тоесть конект в стаблице есть. но такой сокет его уже ненайти в ss выводе.

тоесть в итоге считай что на компе-Б сокет удален из памяти. а вот на компе-А нихуя!
на компе-А сокет еще будет висеть в памяти в списке активных сокетов. хотя достоверно
уже считай что известно что и наш комп тому сообщил что конекта больше нет. и тот комп
нам собщил что у нено тоже корнекта больше нет. зачем же тогда на компе-А висит это сокет?
а висеть он будет порядка 2 минут. есть ключ в /proc котоырй регулирует время таймауте.
так нахуй он висит? а он висит потому что мы отправили на комп-Б ACK пакет но нам соверешенно
незисветно долетел ли он илли нет. потому что ответа неподразумевается в протоколе tcp
поэтому наслучай если этот пакет потерялсяи комп-Б будет слать повторно свой FIN-ACK
то на компе-А сокет и висит в ядре. а если от компа-Б за 2 минуты нчего не прилетит значит
наш комп считает что пакет доолеетли и тогда только ядра удалеяет наконец сокет.
так вот здесь я замечу суперважную вещь. что в итоге сокет зависает в памяти компа только на
компе который инциировал разрыв конекта. тоесть если бы комп-Б ицниировал разрыв то у нас
на компе сокет бы получил статус CLOSE и ядро бы его нахрен удалило. память была бы чиста.
а на комп-Б висел бы сокет в статусе TIME-WAIT 2 минуты. поэтому по окончании работы tcp
конекта у нас сиутация на обоих концах неодинаковая на сокетах. тот кто иницирует разырвыв
конекта тот в итоге и страдает. такого нет что оба сокета висят в состоянии TIME-WAIT.
если мы видим на компе в ss сокеты в состоянии TIME-WAIT то это значит что разрыв tcp конекта
был именно с нашей стороны. мы были инциаторами этого.
вот пример с компа

$ ss -tnla  | grep -E "Recv-Q|TIME-WAIT"
State     Recv-Q Send-Q Local Address:Port  Peer Address:Port
TIME-WAIT 0      0        172.16.10.1:44390 172.16.10.11:22  

тоесть эта строка на симгнализирует что неважно кто инциировал этот конект хотя тут 
это очеивдно . так как в колонке Peer Address:Port мы видим порт 22 то очевидно что инцииролваи
конект мы стучась на ssh сервер. но вцелом неважно кто инциировал конект. хотя опятьже
если мы сидим на нуотбуке то обычно именно наш хост и иницирует 99% всех конектов. 
так вот важно другое. что раз статус этого сокета TIME-WAIT то мы можем точно утвержать что
иниициировали разрыв ИМЕННО МЫ.
так что это вот такое метаасообеие если мы видим сокет в стаусе TIME_WAIT

так вот теперь в чем пизда такого сокета.
мы видим что у каждого ip сокета есть столбики

    Local Address:Port      Peer Address:Port


и у сокета в состянии TIME-WAIT есть тоже такие столбики. 
ксатти если у нас есть слушающий сокет то если мы програму закрываем то ядро такой сокет
сразу вычищает из памяти. с ним пролем нет. он умирает мгновенно. статусы типа ESTABLISHED,
FIN-WAIT-*, TIME-WAIT имеют только tcp сокеты которые именно оабрабатвыали конкретный конект
тоесть чрез этот сокет шла прокачака бвайтов.

так вот если мы на компе запускаем программу в которой мы запусккаем функцию bind()
обычно эут фкунуию запускают если мы хотим создат на компе слушающий сокет. но это необязательно.
вцелом bind() может запускать ии при исходящий конектах но это редкость. так вот в любом
случае если мы запускаена компе bind() то в нем мыуказываем IP+port и эта хрень в итоге
этой фнукцией записывается в новый сокет. НО! это произодет тлоько если у нас на космпе
в списке акивных сокетов нет сокета у которого в колонке 

      Local Address:Port

такого же параметра как мы указываем при запуске bind()
например  вот у нас на компе есть


$ ss -tnla  | grep -E "Recv-Q|TIME-WAIT"
State     Recv-Q Send-Q Local Address:Port  Peer Address:Port
TIME-WAIT 0      0        172.16.10.1:44390 172.16.10.11:22  

значи получается у нас у этого сокета колонка

   Local Address:Port = 172.16.10.1:44390


если я попробую запустить bind(172.16.10.1:44390) то ядро мне выдаст ошибку!
об подробнее поговрим некст тайм <<<



все пакеты везеде долетели


!!!!>>>> закончил вот на каких двух залупах
     1) O_REUSEADR :я не могу добиться ошибки bind() ip address already in use
        и тода непонятно нахуй нужнен флаг O_REUSEADDR
     2) семафоры : я не могу удалить семфор чрез cli. 
        я создаю новый через прогармму а он почемуто нерисутеся в cli 
        каая то пизда со сфетоврами. нужно удалить прогрмму через -9 
        и потом ее запустить. и будем пзда

ниже предвариетльное ообьяснениее


важный момен - слушайющий сокет неимеет никакийх стейтов time-wait и прочее.
такие хуйни имеет только сокеты которые обслуживают конекты конкретные.
слушающий сокет уничтожается мгвновеннов впамяти.
поэтому по оокончанию прогармыы слуашайющий сокет унчиожается мгвнвоенно!
а висеть остаются только сокеты котоыре обслуживали конкртеные соединения!




я в сокете активрую опцию SO_REUSEADDR
что это дает. далее я сделаю этот сокет как слушающий. а далее прикол. когда я закрою 
программу. и она делает close(десркитптор сокета). то сокет в памяти ядра продолжает жить!
как это увидеть в ss ? а вот так 


 $ sudo ss -tna | grep -E "Recv|8080"
State      Recv-Q   Send-Q      Local Address:Port      Peer Address:Port
TIME-WAIT  0        5           127.0.0.1:8080          0.0.0.0:*   


вот я закрыл программу. это было два процесса. каждый из них создал несклько сокетов.
часть сокетов была слушающая. часть сокетов уже которые обрабатыываю конекты.
так вот мой бинд он там ниже по тексту он будет пытаться  писать в сокет в графе 

    Local Address:Port

пытаться писать .....
дальеш пока хуня.

ясно вот что . 


  вася шлет пете FIN а петя его принимете . при этом статусы стороны

    вася fin-wait-1     петя close-wait

петя обратно шлет fin+ack
при этом статусы сторон

  вася fin-wait-2      петя хуй знает

полсе этоого вася шлет ACK
статус стороны

 вася time-wait   петя хуй знает

time-wait уже ничего неперебить. его нужно ждать по таймауту.

я наконец добился что у меня повиляс на сервере time-wait

# ss -tna | grep -E "Recv|8080"
State     Recv-Q Send-Q Local Address:Port  Peer Address:Port 
LISTEN    0      5          127.0.0.1:8080       0.0.0.0:*    
TIME-WAIT 0      0          127.0.0.1:8080     127.0.0.1:38388  <=== ***

и поэтмоу пвяилась ошибка 
$ ./358.exe 
не удалось сделать bind: Address already in use

я бууду ращбиать отдельно как добавитьс ячтоыбы эта шибка появилась. и как сделать 
тобы ее нестало.


скажу тоолько то что она возникает если !! :

  1) у наш проецесс пытается создать слушающий сокет.
    а точннее наш процесс пытается записать в любой сокет через bind()
    параметры local addres: port

  2) наш процесс должен сам по своей воле инциировать закрытие tcp конекта.

тода у нас будут оставлстся сокеты у которых time-wait  и IP:port в парметре local addres:port
если же наш сервер сам никода не инциирует закрытие соедениея то мы этой ошиибки 
никода не пуолчим.

и вот в этмо случае помоагает флаг O_REUSEADDR название дебилодидное . потому что у нас
реюзается нетолько ip адрес но и порт. поэтому название дебилодиное.
в этом примере у нас формально будет несклько сокетов которые у себя в local addres:port
будут иметь одинакое значение 127.0.0.1:8080
однако при этом все равно что касатется слушающего сокета то он с таким биндингом
будет один!
вот еще разсьянеие кода пявлется эта ошибка
слушай я вроде наконец понял как возникает ошибка bind() ip address already in use.

у нас должен быть процесс который при старте пишет в сокет некоторую 
постоянную комбинацию например 127.0.0.1:8080
тоесть он пишет это в сокет в графу Local Address:Port 

далее. важно чтобы наш процесс ОБЯЗАТЕЛЬНО стал инициатором закрытия этого конекта. если инициация будет идти с той стороны то мы никогда не получим ошибку bind() ip address already in use.

так вот когда мы со своей стороны инцииууем конец тцп конекта то у нас на компе остается сокет который имеет статус time-wait (сокет может иметь такой статус только если это не слушающий сокет и если инициацию конца конекта делала наша сторона). и свойствах этого сокета у нас будет 

Local Address:Port  = 127.0.0.1:8080

при повтороном старте нашего процесса. он создаст новый сокет и попытается в графу Local Address:Port  записать 127.0.0.1:8080
но у нас уже есть сокет с таким значением в этом столбке. поэтому ядро пошлет нафик. 

если же иниициацию конца тцп конекта делает ненаша сторона а удаленная сторона то НИКОГДА МЫ НА СВОЕМ КОМПЬЮТЕРЕ НЕ ППОЛУЧИМ СИТАЦИЮ КОГДА ВОЗНИКАЕТ ОШИБКА bind() ip address already in use.

обязательное требование что первым тушить конект инициируем мы со своей стороны. 



при этом есть другой флаг O_REUSEPORT но его преаназчниене вообще охуенное другое. неимеет
никакой связи логической с O_REUSEADDR. его праедназчанение такое что он позвяолет сделать
два слушающих сокета с одинаковым 

local addres:port 127.0.0.1:8080


поэтому название флага тоже дебилодидное но по своему








----
