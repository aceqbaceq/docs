| epoll

значит перед чтением этой статьи я рекомендую прочтать select.txt и poll.txt
а потом уже эту стаью.

плюс epoll (в сравнении с poll)  в том что он возвращает только те события
которые мы у него заказали. а poll возврашает  любое событие которое произошло на 
сокете в независиомсти от того  какое событие мы заказали. 

остальные моменты сравнения poll и epoll я изложил в poll.txt в конце

для начала нужно понять что такое union в си. для этого читай c-union.txt
значит как работает epoll
создается внутри ядра некая хрень - инстанс epoll

    int epfd = epoll_create1(0);

как результат процессу возвращается дескриптор. это некий указатель на наш еполл внутри
ядра. как индентификатор который мы потом будем юзать как индетификатор. это такая же
аналогия как бутто мы сокет создали. только это не сокет а epoll инстанс.


далее нужно обьяснить ядру за какими файловыми дескриптооррами ядро должно следить
для нас. нужно эту инфо записать внутрь нашего epoll инстанса
делаем это мы так 

  epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event)

если  epoll_create1() это аналог socket() то epoll_ctl()  это аналог bind()
тоесть через epoll_ctl мы вносим настройки в epoll инстнас внутри ядра.

первый аргумент epfd это дескриптор еполл инстанса. это ровно тоже самое как мы укаызваем
в bind() дескриптор сокета.

второй аргумент EPOLL_CTL_ADD это мы сообщаем что мы хотим сделать. мы хотим добавить\записать
внутрь епоол инстанса номер нового файл дескриптора. 

третий аргумент file_fd - это как раз номер файл дескриптора котоырй мы хотим записать
внутрь еполл инстанса. это номер файл дескриптора за которым мы хотим чтобы ядро следило.

последний аргумент  &event  - это поинтер. это поинтер на вот такую структуру

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

значит какую роль играет эта структура? в первом ее поле 
    
    uint32_t      events

у нас в форме битовых флагов содержатся события которые ядро должно отслеживать для дескриптоора
номер кторого мы указали в третьем аргументе. 
по мне архитектура достатчно дебильная. почему. потому что у нас номер дескриптора за которым
следить указан в третьем аргументе фукции.  а какие события ловить на этом дескрипторе указано
в четвертом аргументе в его поле. это разнородно и неудобно сделано. я щас сразу покажу как
заносить занчение в первое поле структа epoll_event

   struct epoll_event  event;    \\ обьявляю переменную 
   event.events = EPOLLIN;       \\ присваиваю нашему структу первому полю значение EPOLLIN


где EPOLLIN это такой макрос который на самом деле выставляет некий бит. если мы хотим выставить
несколько битов то это будет примерно вот так

   event.events = EPOLLIN|EPOLLOUT;

размер первого поля структа это 4 байта. 
флаг EPOLLIN означает что в файл на который указывает дескриптор чтото пришло. ну мы не следим
никогда за обычными файлами. потому что у них всегда будет наступать событие EPOLLIN
а если дескриптор указыает например на пайп то вот когда у нас в пайп прилетят данные 
то у нас насутпиит с точки зрения ядра событие EPOLLIN

еще раз посмрим на структ

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

так вот второе поле (ВАЖНО) оно уже нихуя никак не влияет на настройки работы инстанса epoll.
самому epoll это поле вообще нахуй ненужно. так зачем оно нужно? а оно нужно вот зачем.
щас покажу. вот мы через вот такую хрень

   struct epoll_event  event;     
   event.events = EPOLLIN;       
   epoll_ctl(epfd, EPOLL_CTL_ADD, 15, &event)


мы заказываем записываем в епооллл инстанс задание для ядра чтобы если в файл на который 
укызает дескриптор 15 прибыли байты то ядро чтобы оно это заметило и зафиксировало.
теперь нам нужно както в программе узнать что ядро зафикировало интерсующее нас событие
на интерсующем нас дескрипторе. для этого нужно вот так сделать


        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);

у нас events это массив

       struct epoll_event events[MAX_EVENTS];

если мы вставляем имя массива как аргументв фукнцию то компилятор налету меняет текст
нашей прогарммы вот на такой что имя массива менется на поинтер на первый элемент этого
массива тоесть

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

так как у нас events это массив где каждый элемент имеет тип epoll_event
то тогда и первый элемент массива имеет тип struct epoll_event  и тогда поинтер на первый элмент
масива будет иметь тип 

       struct epoll_event*

сравним с тем что требует второй аргумент в спецификации к epoll_wait

        int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

тость второй аргумет имеет тип

        struct epoll_event *

ровно как и есть то что мы подставли в epoll_wait

теперь еще раз смотрим на эту хрень

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

epfd - это  унас дескриптор еполл инстанса. (по аналогии с декрипором сокета)
-1 = это означает сколько времени ядро должно блокировать этот вызов держа проецсс в суспенде
если ничего не происходит. -1 означает что держать процесс в суспегде вечно пока ядро не 
зафиксирует интерсующее нас событие.
так вот второй аргумент это получается поинтер на кусок памяти в области памяти процесса куда ядро запишет массив данных. а это как раз таки будет массив состоящий из элементов гдекаждый 
элемент это 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

значит напомню что я записал в еполл инстанс такую хрень. что дескриптор 15. тоесть нужно
следить за дескриптором 15. и я передал поинтер вот на такую хрень 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

где в первом поле я записал 

   event.events = EPOLLIN;       

во второе поле я тоже кое что записал. я там выше не показал. но это неважно что у нас 
во втором поле. важно то что если у нас на дескриптр 15 поступят данные. то у нас прооисходит
событие EPOLLIN для дескриптора 15. и я дро фисркириует это событие. 
и кода я запущу вот эту хрень

        int n = epoll_wait(epfd, &(events[0]), MAX_EVENTS, -1);

то процсс будет лежать в супенде. а как толко произойдет указаное событие то ядро вернет
управление процесу. тоесть возвратится из epoll_wait и ядро запишет по адрусу который я 
указал в поинтере оно запишет целиком содержимое вот всей той хрени 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

которую я скорил ядру когда я совал в еполл настройки дескриптора 15

   epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event)

поэтому я увижу в массиве которое я подсуну ядру я увижу в точности тот контент 
который я вснунул в ядро при сованиив в него десрптора 15 
вот эту хрень я увижу

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

и вот это второе поле data оно нужно не ядру а мне. оно нужно мне чтобы я получил вспомнил
те полезные данные которые нужны именно мне. прикол в том что при насутплении события  с 
дескриптором 15 то ядро мне обратно это число 15 в явном виде не сообщит. оно мне просто
вернет тот масив который я совал в ядро при програмировании дескриптора 15. 

  struct epoll_event {
           uint32_t      events;  /* Epoll events */
           epoll_data_t  data;    /* User data variable */
       };

первое поле оно не содержит номер дескриптора. 
единсвтенное место где я сам для себя мог сохранить инфорацию так с каким же декриптором 
чтото произошло полезное это второе поле. это второе поле нужно именно мне. а не ядру. на
настойки ядра оно не влияет. 

второе поле оно по факту явялется юнионом

     union epoll_data {
           void     *ptr;
           int       fd;
           uint32_t  u32;
           uint64_t  u64;
       };

    typedef union epoll_data  epoll_data_t;


так вот в этот юнион я сам должен записать ту инфорамацию которая мне будет полезна чтобы
я понял так какой же дескриптор у меня в итоге сгенерирровал ивент. 
самое простое взять и записать в этот юнион номер дескриптора вот так 

     struct epoll_event  event;
     event.data.fd = 15;


и тогда мне ядро вернет именно вот такой структ что 
первое поле будет равно EPOLLIN
а второе поле будет равно 15
и тогда смотрю на второе поле вижу там 15 и понимаю что у меня сработал ивент для 15-го 
дескриптора. 
если я сам для себя хочу получить расширеную информацию то я могу в второе поле
засунуть поинтер на любую структуру которая мне будет удобна. например 

   struct struc1 {
     int fd;
     char vasya[10];
   }

   struct struc1 s1;
   s1.fd = 15;
   strcpy(s1.vasya, "Gogy");

   void *p = &s1;

и тогда  суем этот поинтер во второе поле

    event.data.ptr = p;

тогда мне во втором поле ядро вернет этот поинтер. я могу пройти по адресу этого
поинтера и узнать расширеуннную инфомрацию по тот дескриптор котоырй я совал в ядро.
и получается теперь когда я узнать номер дескриптора на которой чтото прилетело. то 
я могу с этим дескриптором уже делать какието полезные дела. 

теперь я дам пример программы

$ cat 359.c
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <errno.h>
#include <stdio.h>








int main() {

    

int epfd, epfd2 ;



    // Создаем epoll инстанс
    epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем epoll инстанс
    epfd2 = epoll_create1(0);
    if (epfd2 == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    sleep(60);

   close(epfd);
   close(epfd2);


};


в ней я создаю два еполл инстанса. 
НО! ОГРОМНЫЙ ПРИКОЛ!
с точки зрения proc и fdinfo оба дескрпторра выглядяит так как бутоо они указывают 
НА ОДИН И ТОТ ЖЕ ИНСТАНС ЕПОЛЛ ОБЬЕКТ В ЯДРЕ! ЭТО ПИЗДЕЦ

$ lsof -Pnp $(pidof 359.exe) | grep -E "FD|event"
COMMAND    PID   USER  FD      TYPE DEVICE SIZE/OFF      NODE NAME
359.exe 952065 noroot   3u  a_inode   0,16        0      1090 [eventpoll]
359.exe 952065 noroot   4u  a_inode   0,16        0      1090 [eventpoll]

  $ cat /proc/$(pidof 359.exe)/fdinfo/3
pos:    0
flags:  02
mnt_id: 17
ino:    1090

  $ cat /proc/$(pidof 359.exe)/fdinfo/4
pos:    0
flags:  02
mnt_id: 17
ino:    1090

свойства декрипторо 3 и 4 АБСОЛЮТНО ОДИНАКОВЫЕ! 
это нас приводит к тому что если я смотрю на дескрипторы epoll в proc то я не смогу
никогда и никак понять эти два декрптора они укаызывают на два разных еполл инстанса
или на один и тот же еполл инстанс в ядре. 
а эт супер важно если у нас ест два процесса и у каждгого есть дескриптор который вдеет не 
еполл. и мы должны понять это два арахных еполл инстаса или он один и тот же. 
например такая задача есть когда мы смотрим на процессы nginx. 
так вот получается - мы это понять не можем! с точки зрения fdinfo якобы это один и тот же обьект
в ядре. а на самом делео получяается хуй знает.





теперь  пример программы
она пока неоченьсложная



  $ cat 261.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>


#define MAX_EVENTS 10




int main() {
    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем структуру epoll_event для добавления файловых дескрипторов
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // Добавляем файл в epoll
    event.events = EPOLLIN;  // Слушаем события на ввод
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < n; i++) {

            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }
        }
    }

    close(file_fd);
    close(epfd);

    return 0;
}


в этой прогрмме я выбираю чтобы второе поле лично для меня хранило номер дескриптора
котоорый я засунул в ядро

    event.events = EPOLLIN;  // Слушаем события на ввод
    event.data.fd = file_fd;  // Файл




значит как все работает


    // Создаем epoll инстанс
    int epfd = epoll_create1(0);


далее
создаю первую переменную она будет содержать в первом поле то событие которое я хочу
отловить это будет EPOLLIN и во втором поле она мне будет содержать номер декристора
чтобы мне потом понять на каком же дескрипторе произошло событие

    struct epoll_event event;


теперь создаю вторую перменную это уже массив. 

    struct epoll_event events[MAX_EVENTS];

это массив. где каждый элемент это  epoll_event 
и потом когда я запущу epoll_wait то  в этом массиве каждый элемент будет соотвествовать
событию на одном файл дескрипторе который я зарегистриовал на инстансе еполл.
при регистраиции дескриптора я также сую в ядро структ epoll_event поэтому когда ядро
регисриует событие на десркипторе то оно в ответ этот epoll_event мне обратно верент.
так как я могу зарегистрровать на еполл иснтансе тучу дескрипторов то epoll_wait
мне вернет целый массив элементов epoll_event где каждый из них это роовно та хрень которую
я совал я ядро при регистрации того или иного дескриптора. в моем случае каждый такой элеент
он будет отличаться вторым полем. там будет записано номер дескриптоора на котором получается
и произошол событие. 


открываю файл. мне нужно получмть номер файл дескриптора fd


    // Открываем файл для чтения
    int file_fd = open("test.txt", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }


тепррь используя ранее созданный event  прописываю в нем дескипприптор file_fd 
и желаемое событие EPOLLIN 


    event.events = EPOLLIN;  
    event.data.fd = file_fd; 



теперь я  пихаю  внутрь ядра номер дескрипттора за которым нужно следить через  третий 
аргумент функции и пихаю событие EPOLLIN  которое мы хотим на нем поймать через четвертый аргумент
его первое поле . а второе поле оно на настройки epoll не влияет. это чисто будет мне информация
когда потом ядро мне вернет этот же event обратно.


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }


все - мы дескриптоор номер и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас.

если бы я хотел добавит еще один дескриптор скажем 11 то я бы повторил операцию


    event.events = EPOLLIN;  
    event.data.fd = 11; 


    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd");
        exit(EXIT_FAILURE);
    }



все - мы номер дескриптоора и событие засунули внуьрь ядра . ядро уже знает за каким 
дескрпитором мы хотим следить и какое событие мы хотмим поймать. и ядро уже собирает эту
статистику для нас. теперь осталось только ждать наступления события
и когда оно наступит забрать у ядра массив в который он насует epoll_event которые 
мы пихали в ядро при регстистрации декрипторов


        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события


epfd - это дескрипттор нашего epoll() ,  events это массив в который еполл вернет ответ,
а MAX_EVENTS это размер этого массива (так как у си не признака конца массива и ему нужно 
об этом говрорить в явной форме)


вот и все. теперь только остается пройтись по массиву.
найти номера дескрипторов в которых чтото произошло а именно прилеетела инфомрация.
и прочитать ее.


            if (events[i].data.fd == file_fd) {
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from file: %s", buffer);
                }

            }

здесь я еще посяню то что у нас в переменной "int n" котоую возвращает epoll_wait() там будет
сумма элементов  массива.  поэтому используется вот эта строка
	
	        for (int i = 0; i < n; i++) {

которая нам дает взомжность пройтись по всему массиву так как через "n" мы знаем размер
этого массива. ну точнее размер массива MAX_EVENTS мы задали ранее. но число вернутых
дескрипторов может легко быть меньше. поэтмоу зачем пеербирать весь массив если можно перебрать
мЕньшее число элементов. 

и тогда мы берем элемет массива

		events[i].data.fd == file_fd

и проверяем есть ли в нем именно нужный нам номер декриптора. когда у нас под наблденеим
один дескриптоор то вроде как нет смысла . а вот когда неколько то смысла конечно есть. 
можно еще при желании лишний раз убедиться что в этм дескрипторпе поймано именно нужное нам
событие

	if (events[0].events & EPOLLIN) {
    	// Обрабатываем событие EPOLLIN (готовность для чтения)
	}


для повторного запуска epoll_wait() если что,  то уже все готово.
через epoll_ctl() можно при желании добавиьт или удалить дескриптор из числа налюдаемых
в данном сулчае укаан команда котооая обавляет дескриптор

	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 

еще раз хочу оподчерунуть что номер дескриптора который мы добавлем он указыается
через третий аргумент функции.  а тот номер дескриптооа котоырй мы записали во второе 
поле четвертого арумента это чисто нам для информации. он на настройки еполл не влияет.

    event.data.fd = file_fd; 




еще раз скажу что плюысы epoll по сравеннеию с poll() указанв в конце  статьи poll.txt 




ВАЖНЫЕ МОМЕНТЫ
можно указать для дескрпитоора сразу несолкько событий сразу. вот так 

    event.events = EPOLLIN|EPOLHUP;  

это логическое OR
тоест  еполл вернет этот дескрипттор если ЛЮБОЕ событие произойдет из  двух.
если же я попытаюсь добавить вначале одно событие

    event.events = EPOLLIN;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 


а потом второе 
    event.events = EPOLLHUP;  
    event.data.fd = file_fd; 
	epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) 
то на второй попытке добавить тот же дескрипттор линукс пошлет нахер. 
тоесть в ядре для одного дескриптоора сидит только оодна запись. а поэтому нужно все флаги
которые я хочу поймать указыать в одной записи. а если я хочу доавбить флаг то нужно
использовать EPOLL_CTL_MOD тоесть модифицировать запись.

также важно (об этом в man epoll_ctl написан ) что внезавиисмости указали мы флаг EPOLLHUP
или нет то ядро ВСЕГДА вернет это событие!


следущий важный момент. 
касается проверки результата. 
если я вот так буду проверять

  if (  events[i].events == EPOLLIN   ){
  }


то это ТРЕБУЕТ чтобы в events был устанолвен только один флаг. а других чтобы не было.

а если я вот так проверяю

  if (  events[i].events & EPOLLIN   ){
  }


то это требует чтобы в events этот флаг был а что там с другими флагами неважно.


это все имеет занчение когда у нас в ответе устанолвено сразу неколько флагов. например 

   events[i].events=EPOLLIN|EPOLLHUP

тогда если я буду проверять  этот через 

  if (  events[i].events == EPOLLIN   ){
  }

то  я не получу нихрена. потому что "==" требует точного соотвевтия.
а сработает только 

  if (  events[i].events & EPOLLIN   ){
  }


и


  if (  events[i].events & EPOLLHUP   ){
  }


обе эти проверки требуют чтобы был устанолвен такойто флаг а устанолвены ли остальные неважно.
насколко я понимаю вот такя проеверка  требует чтобы был усталовен либо такой флаг 
либо такой. а что касается осталных флагов то неважно


  if (  events[i].events & (EPOLLIN|EPOLLHUP)   ){
  }




следущий важный момент
полслоку у нас EPOLLHUP всегда ловится ядром и возврващается то если мы работаем с пайпом
и стой стороны пайп закрыли то у нас будет постоянно валится событие 

epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1
epoll_wait(4, [{events=EPOLLHUP, data={u32=3, u64=3}}], 10, -1) = 1

по крайней мере в рамках level-triggred
а так как они будут постяно валится то процесс будет грузить цпу на 100%
единсвеннй вариант это исключить данный дескриптор из  наблюдения.
закрыть файл пайпа и заново его открыть и вставит дескриптоор файла обратно в 
наблюение. при этом супер важно то что если закрыть файл и открыть файл а дескриптоор
оставит в очереди наблюдения (не удалять его) то это нихрена несраотает. поотому что если 
у нас был дескриптор 3. потому мы его закрыли. потом открыли тот же файл и получили тот же
номер десрипоиорра 3 то с тчоки зрения epoll это соверенно другой дескрипттор и он ничего
ловить не будет! также если закрыть файл. а потом пробовать удалить дескрипттор и еполл
он тоже выдасть ошибку. поэтому едиснвенный саособ это удалить десрпитор из еполл. потом
зкрыть файл. потом открть файл. потом добавить его дескрпитоор в еполл.. вот такая жопа.


в финале программа которая 262.c
которая открывает файл  /home/noroot/temp/nc/fifo1
котоырй именноованый пайп который надо заранее создат чрез

 $ mkfifo /home/noroot/temp/nc/fifo1 


а далее мы с другог отерминала открываем этот пайп и шлем бквы

  $ echo "1234" > ./fifo1

тогда наша программа она это ловит и печаатет. 
если мы несколкьо раз посылаем данные в пайп то она успешно 
их несколько раз ловит и печатает


  $ cat 262.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <fcntl.h>

#define MAX_EVENTS 10

int main() {


   // открываем файл с диска
    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
    if (file_fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }



    // Создаем epoll инстанс
    int epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем две переменные одну для сования дескриптороа в ядро
    // а вторую для получения ответа из ядра
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];




    // Добавляем fd/0 плюс  EPOLLIN и\или EPOLLHUP в  ядро
    // добавлять EPOLLHUP необязатльно ибо ядро нам возвратить
    // этот ивент по любому
    event.events = EPOLLIN|EPOLLHUP;  
    event.data.fd = file_fd;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
        perror("epoll_ctl: file_fd - EPOLLIN");
        exit(EXIT_FAILURE);
    }







    // Ожидаем событий
    while (1) {
        int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
        if (n == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }


        for (int i = 0; i < n; i++) {
            // ищем в элементе EPOLLIN 
            // и если он есть то читаем файл и печатаем на экране то что прочитали
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLIN)   ){
                char buffer[256];
                ssize_t bytes_read = read(file_fd, buffer, sizeof(buffer) - 1);
                if (bytes_read > 0) {
                    buffer[bytes_read] = '\0';
                    printf("Read from stdin: %s", buffer);
                }
            }

            // ищем в элементе EPOLLHUP
            if (  (events[i].data.fd == file_fd) && (events[i].events & EPOLLHUP)   ){
		     // удаялю его дескрипттор из epoll
		     if (epoll_ctl(epfd, EPOLL_CTL_DEL, file_fd, &event) == -1) {
                        perror("epoll_ctl: file_fd - EPOLL_CTL_DEL");
                        exit(EXIT_FAILURE);
                     }
            // закрываю файл
		     close(file_fd);

                    // открываю файл заново
                    int file_fd = open("/home/noroot/temp/nc/fifo1", O_RDONLY);
                        if (file_fd == -1) { 
                           perror("open");
                           exit(EXIT_FAILURE);
                        }
                    // добалвяю его десприпторр в epoll
                    event.events = EPOLLIN|EPOLLHUP;
                    event.data.fd = file_fd;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, file_fd, &event) == -1) {
    				perror("epoll_ctl: file_fd - EPOLLIN");
    				exit(EXIT_FAILURE);
		    }

            }



        }
    }

    close(epfd);
    return 0;
}





А ТЕПЕРЬ пример самой сложной программы с epoll

 ' ჳ  $ cat 358.c
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/epoll.h>
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>
#include <semaphore.h>
#define MAX_EVENTS 3


// Глобальная переменная для хранения pid дочернего процесса
pid_t child_pid = -1;
int epfd = -1;  // Глобальная переменная для epoll-дескриптора
sem_t *sem;



int is_fd_valid(int fd) {
    // Проверяем, является ли дескриптор файла валидным
    if (fcntl(fd, F_GETFD) == -1) {
        if (errno == EBADF) {
            // Дескриптор не существует или недействителен
            return 0;  // Дескриптор не существует
        } else {
            // Произошла другая ошибка
            perror("fcntl");
            return -1;  // Ошибка при проверке
        }
    }
    // Дескриптор существует
    return 1;
}



void handle_sigint(int sig) {

    const char *message = "Получен сигнал SIGINT. Завершаем работу...\n";
    write(STDOUT_FILENO, message, strlen(message));  // Используем write вместо printf

    // Завершаем дочерний процесс, если он существует
    if (  (child_pid > 0)  &&  (getpid() != child_pid)  ){
        kill(child_pid, SIGINT);
        waitpid(child_pid, NULL, 0);  // Ожидаем завершения дочернего процесса
    }

    const char *message1 = "закрываем epfd...\n";
    write(STDOUT_FILENO, message1, strlen(message1));  // Используем write вместо printf

    // Закрываем epoll-дескриптор, если он открыт
    if (epfd != -1) {
        close(epfd);
    }


    // Закрываем семафор
        sem_close(sem);
        sem_unlink("/my_semaphore"); // Удаляем семафор


    exit(0);  // Завершить процесс с кодом успеха

}






void make_socket_non_blocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        exit(EXIT_FAILURE);
    }
}




void handle_client(int z)
{
    char buf[8192];
    char *lastpos;

    while (1) {
        ssize_t n  = recv(z, buf, sizeof(buf), 0);
        if (n > 0) {
            // Данные успешно прочитаны
            dprintf(z, "pid = %i | ", getpid());
            lastpos = strchr(buf, '\n');
            send(z, buf, lastpos+1-buf, 0);
        }  else if (n == 0) {
             // Другая сторона закрыла соединение
             printf("Соединение закрыто другой стороной.\n");
             if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
             perror("epoll_ctl: EPOLL_CTL_DEL");
             exit(EXIT_FAILURE);
             };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
             break;
        } else {
            // Ошибка
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // Данных нет (это нормально для неблокирующего сокета)
                break;
            } else {
                // Ошибка соединения
                perror("Ошибка в recv");
            if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
            perror("epoll_ctl: EPOLL_CTL_DEL");
            exit(EXIT_FAILURE);
            };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
            break;
            }
        }
    } // while END


}  // function END







int main() {

    
    // Устанавливаем обработчик для SIGINT
    struct sigaction sa;
    sa.sa_handler = handle_sigint;  // Функция-обработчик
    sigemptyset(&sa.sa_mask);       // Не блокируем другие сигналы
    sa.sa_flags = 0;                // Без дополнительных флагов

    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("Не удалось установить обработчик SIGINT");
        exit(EXIT_FAILURE);
    }



  // Создаем POSIX семафор с именем "/my_semaphore", инициализируем значением 1
    sem = sem_open("/my_semaphore", O_CREAT | O_EXCL, 0644, 1);
    if (sem == SEM_FAILED) {
        perror("Не удалось создать семафор");
        exit(EXIT_FAILURE);
    }
    
    


    int s;
    int c;
    int reuseaddr = 1;
    struct sockaddr_in addr;
    socklen_t addr_len;

    s = socket(AF_INET, SOCK_STREAM, 0);
    if ( s < 0 ){
        perror("не удалось создать сокет");
    };
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));

    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr_len = sizeof(addr);

    if ( bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0  ){
         perror("не удалось сделать bind");
    };
    
    listen(s, 5);






        child_pid = fork(); // клонируемся
        if (child_pid == -1) {
            exit(1);
        } 





    // Создаем epoll инстанс
    epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }


    // Создаем две переменные одну для сования дескриптороа в ядро
    // а вторую для получения ответа из ядра
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];


    // Добавляем дескриптор сокета  в еполл инстанс  плюс  EPOLLIN 
    event.events = EPOLLIN | EPOLLET;
    event.data.fd = s;  // Файл
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, s, &event) == -1) {
        perror("epoll_ctl: file_fd - EPOLLIN");
        exit(EXIT_FAILURE);
    }




        while (1) {
            int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события
            if (n < 0) {
             if (errno == EINTR) {
                // Если вызов был прерван сигналом, просто продолжаем цикл
                continue;
                };
            perror("epoll_wait");
            exit(EXIT_FAILURE);
            }


            printf("я в цикле после epoll_wait , pid = %i, n = %i\n", getpid(), n);
            for (int k = 0; k < n; k++) {
            if (  (events[k].data.fd == s) && (events[k].events & EPOLLIN)   ){
                   printf("я в цикле после epoll_wait pid = %i, дескриптор = %i\n", getpid(), s);


                   if (sem_trywait(sem) == 0) {
                   // Семафор захвачен успешно
                   printf("Процесс %d захватил семафор\n", getpid());

                    c = accept(s, (struct sockaddr *)&addr, &(addr_len) );
                    if (c == -1) {
                        perror("Ошибка при принятии соединения");
                        continue; // Продолжить цикл, если произошла ошибка
                        } 
                    event.events = EPOLLIN | EPOLLET;
                    event.data.fd = c;  // Файл
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, c, &event) == -1) {
                          perror("epoll_ctl: file_fd - EPOLLIN");
                          exit(EXIT_FAILURE);
                    }
                    make_socket_non_blocking(c);
                    handle_client(c);

        printf("Процесс %d завершил работу и освободил семафор\n", getpid());
        sem_post(sem); // Освобождаем семафор

    } else if (errno == EAGAIN) {
        // Семафор занят
        printf("Процесс %d не смог захватить семафор (занят)\n", getpid());
        break;
    } else {
        // Ошибка при попытке захватить семафор
        perror("Ошибка при захвате семафора");
        break;
    }



                }; //if END
               
  
                if (  (events[k].data.fd != s) && (events[k].events & EPOLLIN)   ) {
                     printf("я  цикле после epoll_wait pid = %i, дескриптор  = %i\n", getpid(), events[k].data.fd);
                     int result = is_fd_valid(events[k].data.fd);
                       if (result == 1) {
                           printf("pid = %i, Дескриптор %d существует.\n", getpid(), events[k].data.fd);
                           handle_client(events[k].data.fd);
                          } else if (result == 0) {
                            printf("pid = %i, Дескриптор %d не существует.\n", getpid(), events[k].data.fd);
                            break;
                          } else {
                                printf("Произошла ошибка при проверке дескриптора %d.\n", events[k].data.fd);
                                break;
                          }


                };  //if END




            }; //for END



    }; //while END
                

           // зарвыаем еполл инстанс
             if (is_fd_valid(epfd) == 1) {
                close(epfd);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", epfd);
              }
      
            // закрываем сокет
             if (is_fd_valid(s) == 1) {
                close(s);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", s);
              }

    // Закрываем семафор
        sem_close(sem);
        sem_unlink("/my_semaphore"); // Удаляем семафор
            
        if (child_pid==0){
           printf ("чайлд программа успешно закончила работу \n");

        };
        

        if (child_pid > 0) {
            waitpid(child_pid, NULL, 0);
           printf ("парент программа успешно закончила работу \n");

        }


};


 $ ./358.exe

теперь мы атакуем эту программы с другого терминала

 $  while(:); do echo "123" |  nc -q1 localhost 8080 ; done 
pid = 953513 | 123
pid = 953514 | 123
pid = 953513 | 123
pid = 953514 | 123
pid = 953514 | 123
pid = 953514 | 123
pid = 953514 | 123
^C


при этом на терминале программы мы увидим
 $ ./358.exe
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953513 захватил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
Процесс 953514 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953513 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
Процесс 953514 захватил семафор
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953513, дескриптор = 3
я в цикле после epoll_wait , pid = 953514, n = 1
Процесс 953513 захватил семафор
я в цикле после epoll_wait pid = 953514, дескриптор = 3
Процесс 953514 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953513 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
я в цикле после epoll_wait , pid = 953514, n = 1
я в цикле после epoll_wait , pid = 953513, n = 1
я в цикле после epoll_wait pid = 953514, дескриптор = 3
я в цикле после epoll_wait pid = 953513, дескриптор = 3
Процесс 953514 захватил семафор
Процесс 953513 не смог захватить семафор (занят)
Соединение закрыто другой стороной.
Процесс 953514 завершил работу и освободил семафор
^CПолучен сигнал SIGINT. Завершаем работу...
закрываем epfd...
Получен сигнал SIGINT. Завершаем работу...
закрываем epfd...



щас я расскажу все моменты связанные с программой. 
она ракскрыла дохоена всего важного про то как все устроено .
поехали



int main() {

    
    // Устанавливаем обработчик для SIGINT
    struct sigaction sa;
    sa.sa_handler = handle_sigint;  // Функция-обработчик
    sigemptyset(&sa.sa_mask);       // Не блокируем другие сигналы
    sa.sa_flags = 0;                // Без дополнительных флагов

    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("Не удалось установить обработчик SIGINT");
        exit(EXIT_FAILURE);
    }



этот кусок нам устанавливает кастомный хендлер обработки SIGINT который происхдоит 
если мы тыкаем Ctrl+C 
причем если у нас в терминале работает несколко процессов то как сказал ии сигнал SIGINT 
будет послан всем процессам привязанным к этому терминалу.
забегая вперед скажу что у нас будет два процесса. а каждый процесс у нас это независимая
сущность так что данный хендлер будет обрабаыаться обоими процессами самтостельно и отельно

далее второй кусок который отвечает за хендлер обработкчика сигнала SIGINT


void handle_sigint(int sig) {

    const char *message = "Получен сигнал SIGINT. Завершаем работу...\n";
    write(STDOUT_FILENO, message, strlen(message));  // Используем write вместо printf

    // Завершаем дочерний процесс, если он существует
    if (  (child_pid > 0)  &&  (getpid() != child_pid)  ){
        kill(child_pid, SIGINT);
        waitpid(child_pid, NULL, 0);  // Ожидаем завершения дочернего процесса
    }

    const char *message1 = "закрываем epfd...\n";
    write(STDOUT_FILENO, message1, strlen(message1));  // Используем write вместо printf

    // Закрываем epoll-дескриптор, если он открыт
    if (epfd != -1) {
        close(epfd);
    }

    // Закрываем семафор
        sem_close(sem);
        sem_unlink("/my_semaphore"); // Удаляем семафор


    exit(0);  // Завершить процесс с кодом успеха

}



мы что в нем делаем. 
мы определяем где мы щас в  дочернем процессе или парент процессе. если в парент
процессе то мы шлем в дочерйний процесс SIGINT. ждем когда дочь подохнет. и управление
вернетя обратно к нам. далее мы закрываем файл дескриторы. и что важно мы завершаем работу
процесса. этот хендлер будет выполенен как на дочке так и на паренте. с той лишь разницей
что если это парен процесс то он еще пошлет дочке сигнал SIGINT. 
возникает вопрос - если мы жмем Ctrl+C то ядро SIGINT шлет каким процессам? 
во первых вот дказательство что сигнал шлет именно ядро а не кто другой
если скажем у нас есть в терминале баш с pid=956881
то я могу отследить какие сигналы прилетают к нему

$ sudo strace -e trace=signal -p 956881 2>&1 | grep -- "---"
--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---

так вот видно что источкник отправки сигнала именно ядро si_code=SI_KERNEL а некакойто
юзер процес.

теперь вопрос - вот у нас есть куча процессов кторые все имеют открытмм утсроство терминал.
мы жмем Ctr+C - то каким процссами ядро пошлет SIGINT?
ОТВЕТ - дело в том что процессы для ядра обьединяются например по признаку PGID - группа
процессов. (не путать с группой юзеров).  так вот процессы которые имеют откртым данный
терминал они все сидят в разных группа процессов. так вот средит этих групп есть одна
группа особая - она отмечается спец признаком что она явлется непросто группой процесов
а   FOREGROUND PROCESS GROUP .  а все остальыне группы прцессов автоматом явлаются 
backckgrund process groups. фореграунд группа для терминала может быть только одна.
так вот когда мы тыакеаем Ctrl+C то ядро шлет SIGINT все проецссам которвые входят в состав
foreground process group. как нам через ps понять для даного терминала какие процессы
на нем сият. в какие процесс группы они разделаются. и какая группа средит этих групп
является форграуенд? вот эта волшеная формула


 $  ps -eo pid,pgid,tpgid,tty,cmd | grep -E "PID|pts/1 " | grep -v grep
    PID    PGID   TPGID TT       CMD
 956881  956881  960041 pts/1    /bin/bash -rcfile .bashrc
 960041  960041  960041 pts/1    ./358.exe
 960042  960041  960041 pts/1    ./358.exe



значит PGID - это номер группы процессов куда входит данный процесс.
TPGID - это штука покаызывает какой PGID является FOREGROUND PROCESS GROUP. 
тоесть получается что на терминале у нас всего две группы процессов

    PGID
    956881
    960041

и среди этих двух привлигиорванной явлется
    TPGID
    960041

надо подчеркуть что TPGID это всегда штука которая явлется одной из членов PGID
такого неможет быть что у нас TPGID такой что его нету в списке PGID
тогда мы теперь выбрраем проецссы у которых PGID=TPGID=960041

    PID    PGID   TPGID TT       CMD
 960041  960041  960041 pts/1    ./358.exe
 960042  960041  960041 pts/1    ./358.exe


вот именно этим двум процессам и будет направлен со стороны ядра SIGINT!
а так как баш входит в другую группу

    PID    PGID   TPGID TT       CMD
 956881  956881  960041 pts/1    /bin/bash -rcfile .bashrc


то ему этот сигнал направлен не будет!

вот такая вот разгадка о том - каки процессам которые закерплены за терминалом у нас ядро
напоалвяет SIGINT при нажатти Ctrl+C. это далеко не все прцоессы!

исходя из того что я увидел. у нас полуатся два процесса нашей программы они будут входит
в одну форегрунунд группу 

    PID    PGID   TPGID TT       CMD
 960041  960041  960041 pts/1    ./358.exe
 960042  960041  960041 pts/1    ./358.exe


и поэтому пои идее вот этот кусок кода излишний в хендлере


    // Завершаем дочерний процесс, если он существует
    if (  (child_pid > 0)  &&  (getpid() != child_pid)  ){
        kill(child_pid, SIGINT);
        waitpid(child_pid, NULL, 0);  // Ожидаем завершения дочернего процесса
    }

потому что ядро так и так при нажаиии на ctrl+c пошлет сигнал и паренту и дочерней проге.
правда дургое дело если мы пошлем sigint рукамми через командуню строку на парент. 
тогда только благодаря этому куску он еще за компнию прибьет и чайлда. 

это  явсего навсего только пока разобрал обработчик ctrl+C 

естственно есть либц фукнции которые позоляют менять для процесса ту фигню что работает ли
он в форегрануден гурппе процессов или нет. также форграудно группа процессов особенная 
еще и тем что только этим процессам рарзрешается на данный момент читать либо писать в терминал.
если это попрбует сделать поцесс котторый принадлежит к бекгрануд группе прцоессов то его 
ядро остановит через SIGSTOP

если мы возьмем процесс то у него 8-е поле в /proc/pid/stat как раз показыает TPGID
для того терминала к которому прроцесс принадлежит

  man proc

    (8) tpgid  %d
                     The ID of the foreground process group of the controlling terminal of the process.

именно это поле и покзыает ps при ключе tpgid



двигаем дальше по коду.
наша основаня цель понять как работает еполл. какие ттам есть приколы.


  // Создаем POSIX семафор с именем "/my_semaphore", инициализируем значением 1
    sem = sem_open("/my_semaphore", O_CREAT | O_EXCL, 0644, 1);
    if (sem == SEM_FAILED) {
        perror("Не удалось создать семафор");
        exit(EXIT_FAILURE);
    }
    

эта штука создает обьект семафор. внутри ядра. он нам поможет делать арбитраж. об этом 
пожже.



далее

    int s;
    int c;
    int reuseaddr = 1;
    struct sockaddr_in addr;
    socklen_t addr_len;

    s = socket(AF_INET, SOCK_STREAM, 0);
    if ( s < 0 ){
        perror("не удалось создать сокет");
    };


этим я создаю сокет.

далее

    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &reuseaddr, sizeof(reuseaddr));


этой строкой я меню свойства сокета. я устанавливаею свойство  SO_REUSEADDR
нахуй оно нужно? 
щас раскажу. для этого нужно целиком прочитать "tcp2.txt"


двигаем дальше под коду
я заполняю структ который потом подставляю в bind() что приводит к тому что 
он в сокете прописывает поле  "Local address:local_port=127.0.0.1:8080"
идалее яделаю сокет слушающим

    addr.sin_family = AF_INET;
    addr.sin_port = htons(8080);
    addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    addr_len = sizeof(addr);

    if ( bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0  ){
         perror("не удалось сделать bind");
    };
    
    listen(s, 5);



дальше я клониую процесс

        child_pid = fork(); // клонируемся
        if (child_pid == -1) {
            exit(1);
        } 



далее создаю еполл инстанс
    // Создаем epoll инстанс
    epfd = epoll_create1(0);
    if (epfd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }



далее я создаю две пееменные для работы с еполл инстансом.
переменная event нужна будет чтобы совать в нее тип еполл событие котоырй мы хотим
поймать и инфорациоанну информацию коорую мы хотим чтобы ядро намвернуло при наступлении
события.
массив events нужен будет чтобы еполл через него нам вернул массив событий.

    // Создаем две переменные одну для сования дескриптороа в ядро
    // а вторую для получения ответа из ядра
    struct epoll_event event;
    struct epoll_event events[MAX_EVENTS];



дальше  я заполяню пременую event
    // Добавляем дескриптор сокета  в еполл инстанс  плюс  EPOLLIN 
    event.events = EPOLLIN | EPOLLET;
    event.data.fd = s;  // Файл


в первое поле  я вствляю события которые я бы хотел чтобы еполл мне поймал. первое поле
это набор флагов или битов. я их актвирую чрез макросы. EPOLLIN будет ловить событие 
что в дескриптор чтото прилтелело. какието байты. флаг EPOLLET я поясню ниже.
во второе поле я прописаю номер дескриптоора нашего сокета.
итак структ заполен данными.

далее код
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, s, &event) == -1) {
        perror("epoll_ctl: file_fd - EPOLLIN");
        exit(EXIT_FAILURE);
    }

в этом же куске я запиыаю данные в еполл инстанс. 
первйы пармптер это дескриптор еполл инстанса. так как их может быть много. надо 
укзаать с каким конкретно мы работаем.
второй аргумент означает что мы делаем тоесть EPOLL_CTL_ADD означает что мы добавляем
номер дескриптора и другие параметры в еполл инстанс. этот как с сетевым сокетом. когда
мы его создали то он типа почти пустой. а поточ через bind, connect мы дбавляем остальыне
настройки в сокет. так и здесь. epfd указывает с каким еполл инстантом мы рабоатем.
EPOLL_CTL_ADD указывает что кокнено мы будем с ним делать - мы будем в него добавлвять 
парамтеры. s - означает что мы хотим добавить номер дескриптора в инстанс. теперь наш еполл
будет следить за событями котоыре происходят на сокете на который укызает этот декрипор.
третий аргумент он основной. он указывает какой за каким декриптором еполл должен теперь
следит. четвертый параметр &event это поинтер на структ который мы заполнили выше. в нем
находится вторая настройка которая нужна еполл. в нем находится тот тип события или событий
котоые должен отловить наш еполл. в нашем случае мы будем следить за возниквноением
события EPOLLIN тоесть что в сокет поступили байты. второе поле в структе event оно никак
в настроках работы еполл неучаствует. самому еполл второе поле нахер ненужно . оно ни на
что не влияет. зачем оно нужно? щас скоро обьясню.




далее вот такой код

            int n = epoll_wait(epfd, events, MAX_EVENTS, -1);  // Блокируемся на события

значит что длает эта хрень. через epoll_ctl  я добавил в еполл номер десркиптоора 
и событие за котоырм там надо следить. ядро будет внутри себя это все фиксировать.
но как же нам узнать что событие произошло? а вот именно через epoll_wait.
если событий заказанных нет то эта функция просто заблокирована а наш процесс засуспенедед.
но как тольк заказанное особытие на заказанном дескрипторе просиходит то эта фнкция возвращается.
и  в массиве events она возвращает результат. значит что же в массиве будут за данные?
когда мы програмирвали epoll через epoll_ctl то мы записали внутрь еполл инстанса номер 
дескриптора s и также структ epoll_event. так вот если на дескрипторпе s произодйет заказанное
событие то в масив events ядро вернет ровно этот же структ котторый мы в него вносили 
для этого дескриптора s через epoll_ctl ! так как мы можем несколко раз выполнить epoll_ctl
и в каждом из них указать +1 дескриптоор и +1 epoll_event , тоест наш еполл може следить
сразу за кучей дескрипторов то при возврате у нас в массив events будет записано несколко
структов каждый из которх соосттвтует тому десркиптру на котрором был ивент. скажем мы внесли в еполл 3 дескриптора. на двух произошел ивент. тоода epollwait вернет нам два элемента в
массив events. в MAX_EVENTS я указываю размер масива. а в "n" epoll_wait возвращает 
то число элементов которое он записал в этот массив. потому массив может быть из 100 
жоементров. а на данный момент евент мог проузйотйи только на двух декриптоорах. 
итак вот этот вот структ который  я заполняю

    // Добавляем дескриптор сокета  в еполл инстанс  плюс  EPOLLIN 
    event.events = EPOLLIN | EPOLLET;
    event.data.fd = s;  // Файл

я его вначале пихаю внутрь еполл инстанса.
а потом он мне этот же структ вернет как один из желментом масива events.
так вот второе поле оно нужно лично мне для информации. потому что epoll_wait он не 
возвращает номера дескрипторов на которых случился ивент. вместо этого он возвращает структ
который  я пихал в ядро при регситрациии этого дескриптоора. поэтмоу во втором поле удобно
указывать номер дескриптоора. на саму настройку раоы еполл эт не влияет. зато я потом пойму
к какому дескриптору имеет отншение этот структ. вот в чем прикол второго поля. вообще 
второ поле это union. что такое union ищи отдельно в файле "с-union.txt"
так вот если мы нужна какаято расшиоенная информация по дескриптору то  я  во втором поле
могу записать поинтер. а этот поинер уже будет указыать на тот мой кастомный структ в коьторый
я могу напихать лдя себя так много информации по дескриптору как мне надо.
но в данном случае мне доя раоботы достатчно тлько номер десркиптора. 
наш счет флага EPOLLET назййуй он нужен. дело в том что если у нас наступает событие
то по дефолту если я вызову повторно epoll_wait то он мне повторно доложит о том же самом
событии еще раз. и так до того момента пока состояние на сокете неизменится. тоесть скажем
у меня приелетели байты на сокет 15. у меня сработает событие и epoll_wait возвращается и  в events  будет записан структ который я совал в ядро при добавлении дескриптоора 15. 
например структ будует такой

    event.events = EPOLLIN | EPOLLET;
    event.data.fd = 15;

потом я заново запускаю epoll_wait и он мне повторно докладывает об этом событии. насколько 
я понимаю он будет доакладывать об этом событии до тех пор пока я не прочитаю все байты 
из сокета и там байтов не останется. тогда он перестанет доклаывать. и начнет обратно
докладыавть когда снова на сокет прилятт новые байты. так вот это все недобно порой. мне 
достаточно доложить 1 раз о том что на сокете произошло событи и не повторять. до реального
настурпления нового события.  так вот флаг  EPOLLET он как раз укзывает для еполл чтобы 
он мне занимался дублированием докладывания о сбытии о котором он уже доложил. вот зачем
он нужен этот флаг.
MAX_EVENTS это размер массива,
последний параметр -1 это хрень означает что функция доожна быть заблокирована вечно до наступления события. потому что можно укзать сколько мс фукнция спит ожидая событие а если
ничего нет то ядро вернется по любому. нам это ненадо. -1 означает вечное ожидание. 


далее вот этот кусок
он проверяет небыло ли ошибки при выполпнеии epoll_wait

            if (n < 0) {
             if (errno == EINTR) {
                // Если вызов был прерван сигналом, просто продолжаем цикл
                continue;
                };
            perror("epoll_wait");
            exit(EXIT_FAILURE);
            }


при этом зачем нужен вот этот кусок
             if (errno == EINTR) {
                // Если вызов был прерван сигналом, просто продолжаем цикл
                continue;
                };


дело в том что если к процессу подключаиься через strace то он делает SIGSTOP SIGCONT
а это почему то вызывает вызывает возврат epoll_wait и причем возврат с ошибкой.
так вот я проверяю что была за ошибка , если это был EINTR то это все го навсего значит
что наш процесс был прерван через SIGSTOP нуничего страшного. и тогда я просто продолжаю
исполненеи цикла while.

дальше код
это  я начинаю преебирать эелменты массива events
который мне вернул epol_wait
анализирую с каким дескрипторм случился ивент и что конретно за ивент
при этом так как у нас epoll_wait возврашает число элементво котоыре он записал 
в массив то у меня цикл [0;n)

            for (int k = 0; k < n; k++) {


далее разбираю этот кусок
в нем я проверяю что элемент массива таков что у нас второе поле равно номеру дскриптора
который овтвечает за слушаюий сокет. а первое поле у нас это тип события которое произошло
с десркитпром тоесть EPOLLIN (прилет новых байтов в сокет) . иатк еще раз 
этот большой кусок он проверет что произошло событие именно на слущающем дескриторе. 
наша задача тогда снять новый конект с него и создать нвоый сокет через accept


            if (  (events[k].data.fd == s) && (events[k].events & EPOLLIN)   ){
                   printf("я в цикле после epoll_wait pid = %i, дескриптор = %i\n", getpid(), s);


                   if (sem_trywait(sem) == 0) {
                   // Семафор захвачен успешно
                   printf("Процесс %d захватил семафор\n", getpid());

                    c = accept(s, (struct sockaddr *)&addr, &(addr_len) );
                    if (c == -1) {
                        perror("Ошибка при принятии соединения");
                        continue; // Продолжить цикл, если произошла ошибка
                        } 
                    event.events = EPOLLIN | EPOLLET;
                    event.data.fd = c;  // Файл
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, c, &event) == -1) {
                          perror("epoll_ctl: file_fd - EPOLLIN");
                          exit(EXIT_FAILURE);
                    }
                    make_socket_non_blocking(c);
                    handle_client(c);

        printf("Процесс %d завершил работу и освободил семафор\n", getpid());
        sem_post(sem); // Освобождаем семафор

    } else if (errno == EAGAIN) {
        // Семафор занят
        printf("Процесс %d не смог захватить семафор (занят)\n", getpid());
        break;
    } else {
        // Ошибка при попытке захватить семафор
        perror("Ошибка при захвате семафора");
        break;
    }



                }; //if END
               



почастям разберу верхний код
я пробую захватит семафор. если успешно тогда я  занимаю этот семафор

                   if (sem_trywait(sem) == 0) {
                   // Семафор захвачен успешно


если захват семафора удачный то 
 я принимаю 1 конект из слушающего сокета. при этом ядро создает нвоый дескриптор c
под новый конект. 

                    c = accept(s, (struct sockaddr *)&addr, &(addr_len) );
                    if (c == -1) {
                        perror("Ошибка при принятии соединения");
                        continue; // Продолжить цикл, если произошла ошибка
                        } 



далее

                    event.events = EPOLLIN | EPOLLET;
                    event.data.fd = c;  // Файл
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, c, &event) == -1) {
                          perror("epoll_ctl: file_fd - EPOLLIN");
                          exit(EXIT_FAILURE);
                    }


я заполняю структ в который сую EPOLLIN и номер вот этого нового дескриптора c,
и добавляю все это в еполл инстанс. теерь он у меня будет следить нетлоко за слушающим
сокетом s но и за сокетом который сркывается за декриптором c.


далее я делаю сокет дескриптора c как неблокирующий

                    make_socket_non_blocking(c);


далее вот какой прикол. я добавил десокиптор с в еполл. и в сокете который за ним скрывается
уже есть байты. но мне еполл об этом не сообщить. почему. потому что еполл реагирует тольок
на измннеие состояния в сокете. если бы он был пустой на момент его добавления и потом приелетли
был данные то он бы среагировал. а уменя уже в нем есть байты. если в сокет приляетет новые байты
то он срегаирует. а если я хочу забрать уже имеющие байты то после добавляени его в еполл
негнужно ждать от него сигнала. надо сразу залезть в сокет и збарать то что там лежит.
функция  handle_client она забрает читатет байты из сокета. 

                    handle_client(c);

тело этой фнкции рассмотрим потом.
если захвата семфора не произошло то я пеерехожу на новый виток цикла while() а он в свою 
очредь запускат новый раз epoll_wait().
ты скаежшь постой! у тебя есть ивент. но возможно ты не захватил семафор и уже обратно
запустил epoll_wait , он же болше не будео докладывать о тех байтых что уже лежат в сокете.
но тут прикол в том что у меня два процесса(а у них одинаковый код). поэтому один из двух процессов обятазельено захватит событие.и начнет его обарбаывать. собсвтенно тут я хочу 
пояснить важный прикол. у нас два процесса работает. у кажого процесса свой еполл инстанс.
каждй процесс в свой еполл инстанс добавляет слушающий сокет s. 
тогда вопрос - если возникает событие на дескрипторе s то на какой еполл инстансе взникнет
событие? ответ - на обоих! но нам в итоге нужно чтобы только один процесс в своем теле
выполнил команду accept. именно поэтому я позвояляю обооим процессам словить ивент на слушающем
сокете s. но за счет семафора у меня толькодин процесс в итоге запустит accept. и новый сокет
будет доавлен только внутрь одного еполл инстанса. поэтому получаатс два процесса равнмерно
разгребают слушающий сокет но  на оснвое этого новый сокет создается только на одном прцоессе.
поэтмоу у нас новые прилетающие конекты  будут равноемерно расрпеелятся по этим двум епол
инстансам.  я пробовал вариант что оба процесса работат с одним еполл инстансом. но тогда
получается гавно. у нас еполл инстнас он будет брать ивенты и равнмоерно распределять по
обоим процессам. тоесть в итоге нарпимер ивент на слушающем сокете верентся только одному
процессу. что хрош. но! после того как мы на этом проецссе сделаем accept и созадим сокет
на дескрипторе c. и добавим его в еполл инстанс то в следующий раз он может венуть структ
от этого десркипторра на в этот процесс а в другой!  а тот то процесс у него этого дескиптоора
то и нет вовсе! поэтому это жопа это нам ненадо! тоесть полл поалагает так что если мы взяли
несколко процессов и все их направли на один еполл инстанс значит у нас все эт процессы имеют
открытми одина набор дескрипоров. вот он номера событий и разрабываем между ними равеномерно.
но у нас то нетак. у нас в кжаодго процесса будут свои наборы дескриптров. именно поэтому
я сделал так что у нас каждй прцоесс в итоге работаем со своим еполл инсатнсом. поэтому 
каждй еполл возвраааещает только те дескррпиторы своему рпцессу которые у этого процеса есть.
ну а минус в том что у нас дескриптор s добавлерн в оба иснтнанса . и поэтмоу событие о нем
доклаываются на каждый процесс. и тогда нужен семафора чтобы обработкой события 
занисял атлоко один какойтопрцесс.



далее я ищу среди элементов массива те желмены которое отвечают уже на за слушающий
сокет а за сокеты которые занимаются в уежже обработкой конектов.
если такой ивент есть то я взываю  handle_client() функцию которая занимается тем 
что она читает байты из этого сокета
вот эта хрень events[k].data.fd в ней как раз записан номер дескриптора на котормо
произошло событие


                if (  (events[k].data.fd != s) && (events[k].events & EPOLLIN)   ) {
                     printf("я  цикле после epoll_wait pid = %i, дескриптор  = %i\n", getpid(), events[k].data.fd);
                     int result = is_fd_valid(events[k].data.fd);
                       if (result == 1) {
                           printf("pid = %i, Дескриптор %d существует.\n", getpid(), events[k].data.fd);
                           handle_client(events[k].data.fd);
                          } else if (result == 0) {
                            printf("pid = %i, Дескриптор %d не существует.\n", getpid(), events[k].data.fd);
                            break;
                          } else {
                                printf("Произошла ошибка при проверке дескриптора %d.\n", events[k].data.fd);
                                break;
                          }


                };  //if END





далее простецкая часть
где  я просто закрываю все дкскритптторы так как я уже выхожу 
из программы. в том числе я жду код возврата из чайлд процесса


           // зарвыаем еполл инстанс
             if (is_fd_valid(epfd) == 1) {
                close(epfd);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", epfd);
              }
      
            // закрываем сокет
             if (is_fd_valid(s) == 1) {
                close(s);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", s);
              }

    // Закрываем семафор
        sem_close(sem);
        sem_unlink("/my_semaphore"); // Удаляем семафор
            
        if (child_pid==0){
           printf ("чайлд программа успешно закончила работу \n");

        };
        

        if (child_pid > 0) {
            waitpid(child_pid, NULL, 0);
           printf ("парент программа успешно закончила работу \n");

        }


};





далее займемся разбором фкнций
эта фнукия она делает сокет неблокирующим


void make_socket_non_blocking(int fd) {
    int flags = fcntl(fd, F_GETFL, 0);
    if (flags == -1) {
        perror("fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }

    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("fcntl F_SETFL");
        exit(EXIT_FAILURE);
    }
}


эта фукнция проверяет что указанный дескриптор есть в списке дескриптров у нашего процесса

int is_fd_valid(int fd) {
    // Проверяем, является ли дескриптор файла валидным
    if (fcntl(fd, F_GETFD) == -1) {
        if (errno == EBADF) {
            // Дескриптор не существует или недействителен
            return 0;  // Дескриптор не существует
        } else {
            // Произошла другая ошибка
            perror("fcntl");
            return -1;  // Ошибка при проверке
        }
    }
    // Дескриптор существует
    return 1;
}



далее
глоальные перенные. нам нужны глобалные перменные так как мы вставили в код
свой кастомнй хендлер для сигнала SIGINT  а ему нужны глоьальные перменные для доступа.
дело в тмо что хендлер это тоже фукнция. поэтому чтобы из хендлера закрывать всякие
там декрипторы нужно чтобы были глобальные перменные в которых мы и бдем хранить номера
декиптров.


// Глобальная переменная для хранения pid дочернего процесса
pid_t child_pid = -1;
int epfd = -1;  // Глобальная переменная для epoll-дескриптора
sem_t *sem;



и последняня фнукция


void handle_client(int z)
{
    char buf[8192];
    char *lastpos;

    while (1) {
        ssize_t n  = recv(z, buf, sizeof(buf), 0);
        if (n > 0) {
            // Данные успешно прочитаны
            dprintf(z, "pid = %i | ", getpid());
            lastpos = strchr(buf, '\n');
            send(z, buf, lastpos+1-buf, 0);
        }  else if (n == 0) {
             // Другая сторона закрыла соединение
             printf("Соединение закрыто другой стороной.\n");
             if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
             perror("epoll_ctl: EPOLL_CTL_DEL");
             exit(EXIT_FAILURE);
             };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
             break;
        } else {
            // Ошибка
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // Данных нет (это нормально для неблокирующего сокета)
                break;
            } else {
                // Ошибка соединения
                perror("Ошибка в recv");
            if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
            perror("epoll_ctl: EPOLL_CTL_DEL");
            exit(EXIT_FAILURE);
            };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
            break;
            }
        }
    } // while END


}  // function END




в ней я считчаю данные из сокета

        ssize_t n  = recv(z, buf, sizeof(buf), 0);

если n>0 это значит сколько байтов ядро записало в мою переменную buffer
значит из сокета было чтот проичитано. и то что я прочитал
из сокета я обартно шлю на сокет тоеть обратно по сети шлю ремот пиру

            send(z, buf, lastpos+1-buf, 0);


если n=0 

        }  else if (n == 0) {
             // Другая сторона закрыла соединение
             printf("Соединение закрыто другой стороной.\n");
             if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
             perror("epoll_ctl: EPOLL_CTL_DEL");
             exit(EXIT_FAILURE);
             };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
             break;


то ядро таким макаром мне сообщает о том что на саомом деле пока я чесался
то удаленный пир он закрыл тцп конект со своей стороны. тоесть он мне прислал FIN сигнализируя
что больше он мне ничего слать не будет а мое ядро ответило ACK и сокет на моем конце стал
иметь статус CLOSE-WAIT и тогда на запрос чтениз из сокета ядро отвечает нулем байт. и 
возвращает в recv значение 0. теперь читать из сокета бедсполезно. уже ничего нвоого не прилетит
и можно тлко в него писать.  ну а я тогда просто напросто уже со своей стооороны закрываю 
тцп конект и удаляю сокет и егодекриптор 
на самом деле врят ли при первом вызове мы словим n=0  но как видно у меня стоит while(1)
поэтому цикл то будет повторяться. потмуо что у меня сокет неблокирующий. 
правда он будет повтояряться только пири условии что в сокете данных больше чем 
    char buf[8192];
каков размер моей перменной. 


далее

            // Ошибка
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                // Данных нет (это нормально для неблокирующего сокета)
                break;

если n<0 то это значит ошибка. ну и если это конкретно ошибки  (errno == EAGAIN || errno == EWOULDBLOCK) это значит что просто  в сокете щас не т данных .тогда я выхожу из цикла
и выхожу изфнукции.
а если непойми какая ошибка при чтении вышла. то я удаляю этот дескиптор из еполл
и вообще удалю тогда этот сокет. тоесть получается закрываю конект и удаляю этот сокет
и его десткиптор.

            } else {
                // Ошибка соединения
                perror("Ошибка в recv");
            if (epoll_ctl(epfd, EPOLL_CTL_DEL, z, NULL) == -1) {
            perror("epoll_ctl: EPOLL_CTL_DEL");
            exit(EXIT_FAILURE);
            };
             if (is_fd_valid(z) == 1) {
                close(z);
              } else {
                  printf("Дескриптор %d уже закрыт.\n", z);
              }
            break;
            }
        }



вот такая прогармма. ее основне моменты

   - семафоры
   - два процесса
   - два епол инстанса
   - один слушающий сокет
   - не блокирующие сокеты обрабатывающие конкретные конекты
   - O_REUSEADDR





важные моменты - слушайющий сокет неимеет никакийх стейтов time-wait и прочее.
такие хуйни имеет только сокеты которые обслуживают конекты конкретные.
слушающий сокет уничтожается мгвновеннов впамяти.
поэтому по оокончанию прогармыы слуашайющий сокет унчиожается мгвнвоенно!
а висеть остаются только сокеты котоыре обслуживали конкртеные соединения!



про еполл: 
я там выше писал что это таакая прикльная вещь. что если в двух процессах создать 
два незавиисмых еполла то с точки зрения /proc ты их не различишь. якобы это один и тотже 
иснтансс. я там выше рапсисывал.


ну и говорю такие моменты - что если мы создадим два еполла. и в каждй добавиим один 
и тот же декриптор. то при возниуконвоении ивента на этом дескрипторе этот ивент вернет
каджый из двух еполлл инстансов. 
как выглядит раобота   сеполл.
вначле ты просто создаешь голвый еполл.
потом ты заполяенешь структ в котором ты указвыаем тип события которые хочет словить.
также там есть инфорационное поле но оно на саму раоту еполла не влияет. это считай как поле
комент. потом ты суешь в еполл номер дескриптооа и подогтоовныелнй структ.
потом ты запусакаешь epoll_wait который блокируется а верентся только при наступлении хотя 
бы одного ивента. ивенты возвращаются в массиве. ты берешь массив и анализируешь что за ивент
произошел и с каким дескриптором. номер дескриптора тебе не соощается но тебе возврашается в точ
ности тот структ который ты пихал в ядро при совании дескриптора в еполл . потэтому если ты
в инфомрационном поле структа указал какой дескриптор ты имел ввиду то вот в том поле
ты и увиишь этот номер.
вот и вся работа с еполл. 

тоесть скажем подготовил я вот такой структ


                    event.events = EPOLLIN | EPOLLET;
                    event.data.fd = c;  // Файл


потом я добавляю дескриптор c и этот структ event в еполл.

                epoll_ctl(epfd, EPOLL_CTL_ADD, c, &event)


подчеркиваю что епоолл ищет номер дескриптора который я добавил не в структе
а в третьем аргументе.
в структе он ищет тип события который нужно мониторитть.
а вот это поле
                       event.data.fd = c;  // Файл

оно нужно мне потому что epoll_wait() при насутплении события на десркипторе c
он мне просто напросто врнет целиком структ 


                    event.events = EPOLLIN | EPOLLET;
                    event.data.fd = c;  // Файл

я будут в него закядыать и благодаря тому что во втором поле я написал "c"
то  я пойму с каки дескриптором произошле ивент.

в чем еще прикоол программы что она мнопроцессная то еть она позволяет 
разгребать новые конекты используя много ядер . в часотснотсти  2 ядра.
типа аналог жинкс.тоест елси  у нас на слашующий сокет приелет новый конект то 
какойто из двух процессов на себя выгребает этот конект. потом обрабатыает его. 

тема семафоров не раскрыта. читай о ней тут c-semaphore.txt



 
----
