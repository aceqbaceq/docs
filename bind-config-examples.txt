| bind-01
| bind-02
| bind-03
| bind2-03
| dns
| bind9
| .loc
| vasya.loc
| hostname
| hosts


чтобы понять что тут написано полезно 
прочитать bind-dns-hosts-nss-dig.txt

здесь будет описан пример конфигов бинда
поехали


вначале общая инфо

/etc/hostname
здесь лежит ьтекстовый идентфикатор (хостнейм) который явялется идентфикатором
для всего хоста целиком. он никак не связан с сетевым
стеком
отсюда его читает инит процесс и сует его в ядро
через 

    sethostname()

юзер прогаммы читают его оттуда через

   gethostname()



/etc/hosts 
здесь лежат текстовые идентфикторы(тоже зовутся
почемуто хостнеймы хотя более точно было бы 
звать ипнеймы) для отдельных
сеетевых карт этого компа, точнее для отдельных ИП.
тоест каждый хостнейм это абреивиатура для ип
это тот текстовый идентфикатор под которым наш 
хост видят с удаленного компа при обращении на 
такой то ИП. ИП можно считать что это отдельная дверь
в дворце. дворец это комп целиком. а ип это его
отделная дверь.  
формат файла

  ИП  канонический_хостнейм    хостнейм2  хостнейм3 ...


данным файлом пользуется NSS плагин file
а сама NSS это система либц библиотек которая прини
мает на вход аргумент и тип данных которые
мы ищем для этого аргумента (например аргумент
это текст а тип данных которые мы ищем это ИП) а потом используя указанные
в /etc/nsswitch.conf плагины ищет этот аргумент
в разных базах данных и файлах которые отвечают
за хранение указанного типа данных.
 например на входе мы даем текстоый идентфикатор
а тип данных котоыре мы ищем это ИП
и NSS идет в нссвич.конф и там смотрит какие
плагины указаны в строке "hosts:" ибо в этой строке
указываются плагины котоыре ведут в базы данных
которые хранят хостнеймы и ИП 
так вот плагин file в строке "hosts:" он 
отвечает за поиск в файле хостс.
если мы дадим на вход кусок текста то он ищет
этот текст в хостс а выдает обратно ИП
поэтому можно для одного ип иметь много хостнеймов
в хостс потому что преобразование однозначное

канонический_хостнейм используется если мы на входе
в file подали ип адрес  и ему нужно обратно выдать
какойто хостнейм. так как их много то он отдаст
хостнейм самый ближний к ип адресу. так сделано
чтобы при преобразовании ип-->хостнейм у нас
тоже было однозначное преобразование.
канонический_хостнейм по своему виду такойже
самый как все остальные хостнеймы. он не обязан
выглядеть как то по особому. и уже конечно он не
должен иметь вид DNS FQDN потому что данные из хостс
неимеют НИКАКОЙ связи с dns иерархией из интернета.
еще раз - данные из хостс а точнее его хостнеймы
не имеют никакого по своему смысла отношению к
имена доменов DNS иерархии. никакого.


хостнеймы в этом файле никак 
не завсият от хотстнейма в файле /etc/hostname
есть всякие дебилные программы которые читают
gethostname() , а потом они для него ищут в файле
хостс ип адрес или ищут канонический_хостнейм
хотя с хуя ли они это делают непонятно. ибо 
главный хостнейм который gethostname() неимеет
никакого отношения к данным в хостс
но они все равно так делают. например программа 
sudo или ssh так делают. так вот чтобы они 
не ругались лучше добавить в хостс такой же 
текстоый идентфиктор который записан в 
/etc/hostname

вариант /etc/hostname
bind-01

вариант файла хостс
# cat /etc/hosts
127.0.0.1	localhost.localdomain	localhost	bind-01


здесь я добавил  bind-01 из файла хостнейм
в хостс 

вопрос зачем я в каноникал_хостнейм
прописал хрень похожую на DNS домен хотя как
я уже скаазал хостнеймы в файле хостс неимеют
отношения к днс доменам никакого.
дело в том что например есть дебилная команда

  $ hostname --fqdn

она работает очень своеобразно. она читает
gethostname() потом ищет его в хостс и потом
из найденной строки берет какниникал_хостнейм
и выводит его на экран выдывая его за (внимание хохма)
DNS FQDN
поэтому я вот так все и сделал чтобы вывод на экран
выглядел как чтото вменяемое


про DIG
при резолвинге он NSS неиспользует. он шлет
запрос строго на ДНС сервер. но! если я укажу 
ему днс сревер на котоырй нужно стучать не в форме
ип а в формет текста то чтобы найти его ип он 
исользует NSS

пруф
# strace -e openat dig  @localhost -4  -t NS  "vasya.loc."  2>&1  | grep nssw
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 15




значит у меня есть виртуалки
их /etc/hostname
	
	bind-01
	bind-02
	bind2-03



когфигурацрионные файлы этих виртуалок
лежат вот тут

    /home/noroot/git/docs/bind


их мы щас и будем обсуждать
в основном это касается бинд но нетолько



настройки в плане NSS 
# cat /etc/nsswitch.conf
...
hosts:          files dns



на 53 порту висит named
к нему я буду делать запросы через DIG
так как диг  сам NSS не юзает то на его
запромы будет отвечать только бинд.
я проверил бинд в хост не лазиит. 
из хостов указанных в хостс бинд каким то
макаром резолвит только -t A "localhost."
таким мкаром я просто еще раз хочу скзатть что
бинд как и положено в хостс не шарится


зона vasya.loc
размещается на хостах
         
         bind-01 
         bind-02

в файле
 /etc/bind/zones/db.vasya.loc

когда мы внесли изменеия в записи зоны
то нужно обязательно увеличить на единицу 
поле в SOA

		33		; Serial

это далее заставит мастера дать уведомление
на секондари о том что ему нужно синхронизироваться
с мастером по этой зоне

далее провяеряем коректность конфигов. общая
проверка и проверка конкерентно такойто зоны
и если все ок то просим перечитать его свои
конфиги

# named-checkconf && named-checkzone vasya.loc /etc/bind/zones/db.vasya.loc  && kill -HUP $(pidof named)

при этом можно увидеть вот такие варнинги
zone vasya.loc/IN: ftp.vasya.loc/NS 'ns1.ftp.vasya.loc' (out of zone) has no addresses records (A or AAAA)
zone vasya.loc/IN: ftp.vasya.loc/NS 'ns2.ftp.vasya.loc' (out of zone) has no addresses records (A or AAAA)
zone vasya.loc/IN: loaded serial 33
OK


на самом деле все окей. указанные записи есть
просто проверялка у бинда тупая.  он просто неумеет
коректно анализировать зону если в ней есть 
делегирующие записи. об делегирующих записях позже

проверяем что все окей. надо зайти на 

 jounnalctl -f

на обоих нодах. и увидеть что там все окей.
далее заходим на bind-02 который слейв по этой
зоне и делаем реквест (флаг +norecurse делает
итеративный запрос)


# dig  @localhost -4  -t A  "cc.vasya.loc." +norecurse

;; flags: qr aa ra;

;; ANSWER SECTION:
cc.vasya.loc.		604800	IN	CNAME	g.vasya.loc.
g.vasya.loc.		604800	IN	CNAME	gateway.vasya.loc.
gateway.vasya.loc.	604800	IN	A	172.16.100.1

;; AUTHORITY SECTION:
vasya.loc.		604800	IN	NS	ns2.vasya.loc.
vasya.loc.		604800	IN	NS	ns1.vasya.loc.

;; ADDITIONAL SECTION:
ns1.vasya.loc.		604800	IN	A	172.16.100.26
ns2.vasya.loc.		604800	IN	A	172.16.100.27



все работает.
детали как видно я запрашиваю запись

-t A  "cc.vasya.loc."

такой нет. но есть одномиенная типа CNAME
поэтому он возвращает 

cc.vasya.loc.		604800	IN	CNAME	g.vasya.loc.

а далее бинд начинает раскручитваь cname до той
записи А на которую он указывает
а она укзыает на другой синейм

g.vasya.loc.		604800	IN	CNAME	gateway.vasya.loc.

и тогда он ее раскручитвает на запись-А
на которую он укзывает

gateway.vasya.loc.	604800	IN	A	172.16.100.1


на счет файла зоны. в нем нет ничего
особенного.  записи SOA, NS, A , CNAME

для NS записей которые показывают днс сервера
котрые обслуживают зону vasya.loc. как и положено
также добавлены А-записи

; NS servers
@	IN      NS      ns1.vasya.loc.
@	IN      NS      ns2.vasya.loc.


ns1		IN      A       172.16.100.26
ns2    	IN      A       172.16.100.27




далее  директива

$ORIGIN vasya.loc.

означает как трактовать символ '@'тоесть
@=vasya.loc.


также это означает что если у записи в ее 
любом месте указано доменное имя без точки
значит нужно налету приплюсовать домен указанный
в $ORIGIN

если домен указан с точкой на конце(как и положено)
то это значит что данное доменное имя указано
в полной форме и добавлять ничего ненужно

сооветсвтенно эти две записи равнозначны

ftp	            IN 	NS	ns1.ftp
ftp.vasya.loc.	IN 	NS	ns1.ftp.vasya.loc.


далее. в зоне vasya.loc сделано делегирование двух
субзон qqq.vasya.loc и ftp.vasya.loc



; delegate qqq.vasya.loc.
qqq	IN 	NS      ns1.vasya.loc.


; delegate ftp.vasya.loc.
ftp	IN 	NS	ns1.ftp
ns1.ftp	IN	A	172.16.100.30
ftp	IN 	NS	ns2.ftp
ns2.ftp	IN	A	172.16.100.31


собственно вот эта запись
qqq	IN 	NS      ns1.vasya.loc.
она говорит бинду о том что зона 
для домена "qqq.vasya.loc." и поддоменов делегирована
на автортивное хранение и обслуживание реквестов
на днс сервер с доменным именем "ns1.vasya.loc."
это правда сразу делает размещение самой этой
делегирующей записи в этой зоне (в этом файле)
невалидным. но в бинде так принято делать это
самое делгирование. и размещение этой записи 
разрешается в порядке исключения. едиснвтенное
что данная запись считается неавтортивной.
также далее в файле зоны есть для доменного
имени  "ns1.vasya.loc." и запись тип-А
чтоб с этим сервером можно было реально связаться
тоесть мы знали его ИП. 
поскольку домен ns1.vasya.loc. не принадлежит
делегированному домену qqq.vasya.loc  то 
запись

ns1		IN      A       172.16.100.26

явяется автортивиной в этой зоне

а вот другая делегирующая запись


ftp	IN 	NS	ns1.ftp

о том что домен ftp.vasya.loc выносится в отдельную
зону на днс сервер  ns1.ftp.vasya.loc
так как его имя лежит внутри делегированной зоны
то мы просто не сможем найти его ип если мы не
разместим его ип прям в этой зоне в порядке
исключения 
потому что  запись

ns1.ftp	IN	A	172.16.100.30

тоже не является вообще то правомерной для разме
щения в этой зоне. потому что мы делегированли
храрнеия записей с шаблоном имени *ftp.vasya.loc
на другую зону. мы размещаем эту запись 
в порядке исключения. запись не автортивная  
в этой зоне. данная А-запись назыается GLUE 
запись. тоесть эта запись которая сделана в текущей
зоне и хранит в себе
ип адрес днс срервера который хостит делегирровауную
зону при том что днс имя этого сервера лежит
в делегированной зоне и поэтому вобщето данной
записи быть в нашем файле недолжно. 

замечу еще раз что в случае делегирования 
домена qqq.vasya.loc 

qqq	IN 	NS      ns1.vasya.loc.

то А-запись для  его днс сервера

ns1		IN      A       172.16.100.26

не является GLUE. потому что ее нахождение в этой
зоне валидно. она автортивная. она имеет право
находится в этой зоне на законных основаниях 
потому что домен ns1.vasya.loc.  прианадлежит
зоне vasya.loc и при этом не явлется субдоменом
делегированного домена qqq.vasya.loc. 
тоест нахождение в этой зоне данной записи ничего
не нарушает. поэтому это не глю зааись. а обычная
автортвиная А-запист законного находящая в файле
зоны для домена vasya.loc.
тоесть глю запист это запись тип-А которая храниь
в себе ип адрес от днс сервера который
в себе хранит зону делегиорванного домена
но ее нахождение  в файле зоны вообще то не законно
ибо она автортивно может находится только в той
делегиорванной зоне. но она рамещается в текущей
зоне  в порядке ичключения иначе клиент из 
интеренета по другому никак по другому не сможет
узнать ип адрес этого днс срервера.


делегирущие записи являюсят обычными 
статичскими записями. тоесть я хочу скзать что
данный бинд сервер никоим образом не будет 
пытаться связаться с указаннми днс серверами 
которые хостят делегированные зоны.
есть они на самом деле или нет ему плевать.
(в отличии от случая стуб зоны о которой далее).

сделаем запрос к этим записям. так как записи
неавтортивные торекурсиный запрос верент пусто.
их можно запрашивать толко в нерукривном режиме


# dig  @localhost -4  -t NS  "qqq.vasya.loc." +norecurse

;; flags: qr ra;

;; AUTHORITY SECTION:
qqq.vasya.loc.		604800	IN	NS	ns1.vasya.loc.


мы полчили в ответе нашу делегирующую запись.
видим что флага АА нет. оно и понятно потому что
запись неавтортвиная. 


ну а его ип это уже автортивная запись
(флаг АА ) в ответе

# dig  @localhost -4  -t A  "ns1.vasya.loc." +norecurse

;; flags: qr aa ra;

;; ANSWER SECTION:
ns1.vasya.loc.		604800	IN	A	172.16.100.26


с делегированием разобрались



далее. 
если в файлах  /etc/bind/zones
хранятся сами тела зон то в файле

    named.conf.local 

эти самые зоны обьявляются

вот наша зона vasya.loc

zone "vasya.loc" {
    type master;
    file "/etc/bind/zones/db.vasya.loc"; # zone file path
    allow-transfer { 172.16.100.27; };   # bind-02 private IP address - secondary
};

 

в имени файла который будет хранить тело зоны
db.vasya.loc то первое db это не имя домена а
типа подсказка что это датабаза для домена vasya.loc
это я подсмотрел в иенете хотя я щас считаю
что эта первая db  так ненад именовать файл
это только поебывает мозги. нужно имя файлу
давать точно по имени домена зоны

указыаем записи какого домена она будет хостить
какой тип зоны , где файл тела с записями,
и ип адрес  того сервера котрорый если сделает
запрос к нашему серверу отдать файл тела
зоны то он это сделает. то здесь в целом нужно
укзывать ип адреса секонадри днс серверов.


также у нас там есть обьявленная так называемая
"обратная" зона. но  в ней нет ничего сверхественн
ого. это как обычно нагнали магии и тумана
на пустом месте. 
просто напросто выделили отдельный блок 
доменов *in-addr.arpa внутри которых зашифрован 
ип адрес, но от этого доменное имя доменным именем 
не перестает быть
так что это обычный домен обычная зона


zone "100.16.172.in-addr.arpa" {
    type master;
    file "/etc/bind/zones/db.172.16.100";  # 172.16.100.0/24 subnet
    allow-transfer { 172.16.100.27; };  # bind-02 private IP address - secondary
};





далее. рассмотрим стуб зону

zone "db.vasya.loc" {

    type stub;  
    file "/var/lib/bind/db.vasya.loc"; 
    masters { 172.16.100.30; };  # bind2-03

};


она работает вот как. при старте бинда он звонит
на сервер который указан и запрашивает с него
NS и SOA записи  и кладет себе в память. если
сервер недоступен то и записей никаких на нашем
компе не будет. закачанные записи будут неавтортивные.
можно заметить что домен db.vasya.loc который указан
в стуб зоне является вооще то поддоменом
нашей мастер зоны vasya.loc 
чтобы все сросслосб в зоне vasya.loc дополниельно
делегирование для db.vasya.loc прописывать 
ненужно. создание стуб зоны уже автоаматом 
подразуемевает что эта зона делегирована. 
если я сделаю обе вещи и в файле зоны vasya.loc
обьявою деленирование для db.vasya.loc и стуб
зоны для db.vasya.loc создам то в итоге бинд
будет юзать стуб зону а деелегирующие записи
просто игнориуруюся. так что еще раз скажу что
после созания стуб зоны создавать делегируюие
записи в голвной зоне (если мы ее хостим на нашем
сервере) деалать ненужно.

замечу где я указал файл для храения тела 
этой стуб зоны ( которая я напомню будет состоять
всего из SOA и NS записей) /var/lib/bind/db.www.vasya.loc
в этой папке хранятся временные файлы бинда 
чтото типа того. 

проверим что зона работает

# dig  @localhost -4  -t NS  "db.vasya.loc." +norecurse

;; flags: qr ra; 

;; AUTHORITY SECTION:
db.vasya.loc.		604800	IN	NS	ns1.db.vasya.loc.
db.vasya.loc.		604800	IN	NS	ns2.db.vasya.loc.

;; ADDITIONAL SECTION:
ns1.db.vasya.loc.	604800	IN	A	172.16.100.30
ns2.db.vasya.loc.	604800	IN	A	172.16.100.31


видим что все работает.
замечу что стуб зона не обязана касаться
делегированного домена. я могу любой домен
прописать в стуб зону например 


zone "google.com" {

    type stub;  
    file "/var/lib/bind/db.google.com"; 
    masters { 216.239.32.10; };  #  ns1.google.com. 

};


# named-checkconf   && kill -HUP $(pidof named)

провяеряю что работает


важный момент чтобы стуб зона смогла заветсить
и заработать:  первый запрос бинд делает 
запрашивая SOA запись и через UDP протокол.
а вот дальще интереснее. он запрашивает NS записи
через TCP запрос. если TCP 53 закрыт для нашего
бинда на исходящие то наша стуб зона не заведется.
а в логах будет ошибка

: zone google.com/IN: refresh: skipping NS query as primary 216.239.32.10#53 (source 0.0.0.0#0) is unreachable (cached)

если мы успещно скачали NS\SOA записи 
и стаб зона стартанула то у нас будет создан
файл /var/lib/bind/db.google.com
важно то что теперь при перезагзуке бинда
ему ненужно каждый раз лазить и запраивать
эти записи. он будет ждать пока у этих 
записей не закнчится TTL
поэтму есл я хочу их обновить то нужно 
стереть этот файл.

вот такая хтрожопая эта стуб зона.


у нее есть один огромный минус. - для нее 
нельзя указать

    allow-transfer { 172.16.100.27; };   # bind-02 private IP address - secondary


тоесть для нее нельзя укзаать второй днс сервер.
тоесть она сущетвует только на том сервере
где  я  ее руками создал.
но с другой строны - вобщемто проблемы нет.почему?
поому что как у нас создатся слейв зона для мастера?
нам нужно зайти на сервер который будет слевом
и там руками добавит параметры слейв зоны
поэтому на самомо деле ровно также мы заходим
на второй серевер и добавляем эту стуб зону.
в целом тоже самое!
еще раз замечу реултатоом стуб зоны будет 
то что наш серер скачивает с днс сервера 
SOA и NS и A записи для NS. и хранит их у себя локально
в файле. 
как я уже скаал что стуб зона она подходит
для любой внешней зоны а не тлько делерованной.

кстати   бинд скачивает SOA запись но он 
нам ее не отдаст. она у него для внутреннгоо
пользвания. 

можно посмтреть эти записи также через 

 rndc dumpdb -all

и потом идем в  папку /var/cache/bind/.....  
там дамп базы


но если мы говорим про делегируемую зону 
то как лучше сделать - через  делеирумые записи
или через стуб зону.
при делегирумы записях мы хардкодим вид NS
записей  а в стуб зоне мы эти записи скачиваем.
вот в чем разница.


так вот. получется что записе в нашей стуб зоне
как кот наплакал. и они не отдадутся через 
рекурисный запрос. только через итеративный.

а у нас клиенты образадтся почти всегда
через рекурс запрос.

что если я знаю NS серера для зоны и хочу
чтобы если клиент ко мне пришел с запросом
от такой то зоны то я хочу чтобы мой бинд
сревер сразу делал запрос к нужно днс среверу.
для этого подходит forward зона



zone "www.vasya.loc" {
    type forward;
    forward only;
    forwarders { 172.16.100.30; };  # bind2-03

};



опять же. еси она пересекается с нашей мастер
зоной то в мастер зоне ничего вписывать ненужно.
и так все зарабоатет.

если от клиента приходит запрос рекурс
к домену www.vasya.loc то мой бинд делает
рекурс запрос к 172.16.100.30  ждет оттуда 
ответа и возварщает кленту.

но чтобы это все заработало нужно еще 
сжелать вот тут настройку

# cat named.conf.options

options {
	directory "/var/cache/bind";

    ...
    ...

    validate-except
   {
       "www.vasya.loc";
   };


    };


иначе нихуя не заработает. 
потому что там по дефолут какаято нестыкока
на счет DNSSEC


собсвтеенно саммари.
назуй нужна делегаирумеая зона - это просто сигнал
бинду что часть заипсией этой мастер зоны
ей уже не принадлежлит. что они выненсены на другой
файл котоырй лежит либо на этомсерверре либо на 
жругом.

стаб зона позволяетдинмаически загружать nS 
записи от какойто зоне и хранить их у себя.
и отдвть их на итератрный запрос.
 и не более того. 


форвард зона нужна чтобы если ко мне прилетел
рекуриный запрос к зоне и я знаю какой днс
сервер ее осбслуживает то мой бинд 
делате на тот  днс сервер рекурс запрос
вместо того чтобы оарщаться к кореному днс
или форвардрдеруо общего назнчения.


также. еещще одну важную часть днс иерархии
занимает база whois
но про нее писать уже нету сил.



ну еще вопросики по бинду


в SOA  ест поле 

 604800 )   ; Negative Cache TTL


оно укзывает чему равен TTL для пустого 
ответа тоесть когда секция ANSWER возварщется пустая.
чтобы днс клиент закеишировал ответ а не долбил
днс сврер этим запросом повторно



как секндари узнает что нужно обнвовится?
он узнает потмоу что мастер сервер делает
ему нотиификацию. если нотификации нет то 
сеокдари ждет таймаут который указан в SOA (одно
из полей и сам лезет обновляться из мастера)


кешуирующий днс сервер роль - такой роли нет.
просто если у нас на сервере разрешена рекурсия

 $ 
 ? ꨱ  $ cat named.conf.options 


options {
    directory "/var/cache/bind";


        recursion yes; # enables resursive queries
        allow-recursion { trusted; }; 
        ...

то наш бинд будет хрнаиь в памяти те 
записи котоыре приелетли к нему из сети
когда он обарывать запросы рекурс от клиентов
вот тебе и кэширующая роль




деолвтовыый ответ для любой нешсущетсующей
запииси - можно настрить чтобы если в зоне
нет такой запсиси то будет возварщатся некая
деолфтовая. не стал смтреть кк это сдеолать





зачем вобще нужна стаб зона в которо указвыается
NS сервер чтобы потом еще раз скачивать номер
ns серера. это же бред.

в зоне я в явном виде указываю NS сервера
делегированные. а в стаб можно их получать
динамически. 

в стаб зоне  я указваю откуда качать нс записи.
но если этот сервер сдохнет то система сразу
сдохнет. так в чем прикол динмической скачки.?


итератвиные и реурсивные запрсы. в чем разнрца.

стаб зоны, фрвард зоны, делеигирование 
в мастер зоне

если стаб зона надо ли делеирование делать?

