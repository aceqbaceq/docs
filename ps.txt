ps

тема посвящена процессам. как удобно искать все связанные процессы. как увидеть
дерево процессов. всякие штуки тонкости особенности процессов.



и как искать дерево процессов
мы хотим чтобы указать номер процесса а система нам дала всех чилдренов
этого процесса а также и желательно все парентов наверх до pid=1 включиетельно.
тоесть мы хотим увидеть дерево процессов для данного процесса целиком.

в инете предлаагают способ


$ ps --forest -o pid,ppid,pgrp,sess,tty,stat,time,cmd -g $(ps -o sid= -p 17653)
  PID  PPID  PGRP  SESS TT       STAT     TIME CMD
17653 17652 17653 17653 pts/17   Ss+  00:00:00 -bash


он основан на том что они полагают что наш процесс (17653 в данном случае) и его дети имеет 
одну и туже сессию на всех. сессия задается ключом -g 
как видно из вывода у нас для процесса 17653 нашелся только один процесс у которого сессия
такаяже как у процесса 17653. тоесть мы увидели только сам процесс.
на самом деле такой способ поиска детей нверный. потому что дети могут иметь сессии совершенно
другие чем родтелский процесс. 

я предлагаю другой метод. который точно работае.
правда он двухходовый.

вначале
$ pstree  -A  -s  -p   17652
systemd(1)---sshd(1109)---sshd(17601)---sshd(17652)---bash(17653)

что тут круто сразу говорю это то что pstree показывает нетолько детей процесса 17652
но и всех родителей наверх. таким образом мы видим все дерево сразу!
в этом плане pstree очень крутая программа и ps в этом отношении просто отдыхает.
но pstree дает слишком мало информцаии. поэтому теперь когда мы знаем вест список
интересуюищих нас процессов то через ps удобно посмотреть про них

пэтому второй шаг
$ ps -o user,pid,ppid,pgrp,sess,stat,cmd -p 1,1109,17601,17652,17653 --forest
USER       PID  PPID  PGRP  SESS STAT CMD
root         1     0     1     1 Ss   /sbin/init splash
root      1109     1  1109  1109 Ss   /usr/sbin/sshd -D
root     17601  1109 17601 17601 Ss    \_ sshd: vasya [priv]
vasya    17652 17601 17601 17601 S         \_ sshd: vasya@pts/17
vasya    17653 17652 17653 17653 Ss+           \_ -bash

 

как видно процессы которые являются друг другу парентами
и чилдренами тоесть все процессы в спмске являются друг другу либо парентом либо чилдреном
 но неимеют единой общей сессии . и также неимеют единой общей pgrp. так
что верхний метод из иниернетрентеа совершенно  нерабочий а наш рабочий на 100%

===========
следущий момент

про то с какимм параметрами в командной строке прога была запущена.

смотрим в ps что он показывает 

$ ps -p 17600,17601,17855 -u
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
vasya    17600  0.0  0.0  61696  6060 pts/16   S+   16:16   0:00 ssh vasya@localhost
root     17601  0.0  0.0 110084  7276 ?        Ss   16:16   0:00 sshd: vasya [priv]
vasya    17855  0.0  0.0  34112  5604 pts/20   Ss   16:23   0:01 bash

видим 
ssh vasya@localhost

ага значит процесс 17600 был запущен из строки как ssh vasya@localhost

далее видим
bash

значит процесс 17855 был запущен из строки просто как bash

и видим чтото непонятное 
sshd: vasya [priv]

совершенно понятно что в командной строке такая строка непрокатит.
собственно об этом и речь данной темы. понять с каким аргументами как был запущен процесс 17601

так ps берет инфо из proc. в proc инфо об командной строке аргументов хранится в /proc/$PID/cmdline
смотрим

$ cat /proc/17601/cmdline
sshd: vasya [priv]

тоесть мы видим ровно тоже самое что показывает ps.
однако если мы попробует такое запустить из командной строки то будет ошибка.

также похожим образом отобржается nginx

$ ps -u -p $(pgrep nginx)

USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root     15582  0.0  0.0   8848  6252 pts/0    Ss+  15:28   0:00 nginx: master process nginx -g daemon off;
systemd+ 15656  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
systemd+ 15657  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
systemd+ 15659  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
systemd+ 15660  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
systemd+ 15662  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
systemd+ 15663  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
systemd+ 15664  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
systemd+ 15665  0.0  0.0   9236  2624 pts/0    S+   15:28   0:00 nginx: worker process
root     28979  0.0  0.0   8848  6304 ?        Ss   01:08   0:00 nginx: master process nginx -g daemon off;
systemd+ 29052  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process
systemd+ 29053  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process
systemd+ 29055  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process
systemd+ 29056  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process
systemd+ 29058  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process
systemd+ 29059  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process
systemd+ 29061  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process
systemd+ 29062  0.0  0.0   9236  2552 ?        S    01:08   0:00 nginx: worker process


так ну если воркеры нжинкса очевидно запускаются не через командную строку а уже через 
код с вызовом fork() итд то конечно же головной процесс нжинкс запускается то через
командную строку и никак не может быть запущен через 
nginx: master process nginx -g daemon off;

тоесть эту загадку  я пока немогу одьяснить.


ну вот еще чисто для примера для закрепления мтериала

запускем процесс
$ bash -rcfile .bashrc

и смотрим что так указано в cmdline про аргументы
$ cat /proc/$$/cmdline
bash-rcfile.bashrc

тут ксати прикол почемуто в cmdline параметры укаывазаны без пробелов как видно
 
 посмотрим что покажет ps

 $ ps -u -p $$
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
vasya    19916  0.0  0.0  34116  5608 pts/20   S    17:41   0:00 bash -rcfile .bashrc

как видим показал тоже самое.
============

следущая тема
в /proc/$pid/cmdline 
указаны аргументы запуска процесса но не все . так как cmdline имеет ограниченную длину равную page_size (4k)
это никак неисправить кроме как перекомпилировать ядро

так что если командная строка супердлинная запуска процесса то мы и несможем узнать 
все аргументы

=====

