| vxlan 

значит как он примерно работает.
vxlan это какбы такой виртуальный свич только порты у него интересную природу имеют у нас внутри
нескольких компов/ос создается вирт карточка. и вот этот свич состоит из таких портов.
физически это организовывается вот так : у нас Л2 фрейм суется внутрь это вирт карты. 
далее ядро этот л2 фрейм оборачивает в UDP пакет а сверху новый л2 фрейм и сует в сеть.




собрал виртуалки. 
как настроить
настраиваю по книжке





вот у меня есть три компа с карточкой  enp0s3 и ип адресами  172.16.10.25/26/27


на первом компе

  ip link add vxlan110 type vxlan id 110 dstport 4789 local 172.16.10.25 dev enp0s3
  ip link set vxlan110 address 02:00:00:00:00:01
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.26  dev vxlan110 
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.27  dev vxlan110 
  ip -c a add 10.100.100.2/24 dev vxlan110
  ip -c link set dev vxlan110 up





на втором компе

  ip link add vxlan110 type vxlan id 110 dstport 4789 local 172.16.10.26 dev enp0s3
  ip link set vxlan110 address 02:00:00:00:00:02
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.25  dev vxlan110 
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.27  dev vxlan110 
  ip -c a add 10.100.100.3/24 dev vxlan110
  ip -c link set dev vxlan110 up





на третьем компе

  ip link add vxlan110 type vxlan id 110 dstport 4789 local 172.16.10.27 dev enp0s3
  ip link set vxlan110 address 02:00:00:00:00:03
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.25  dev vxlan110 
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.26  dev vxlan110 
  ip -c a add 10.100.100.4/24 dev vxlan110
  ip -c link set dev vxlan110 up





все сразу должно заработаь. тоесть с первого компа
мы пингуем скажем второй

(первый комп)#  ping 10.100.100.3



ВНИМАНИЕ! у меня вначале неработало потому что у меня небыло строки

  ip link set vxlan110 address 02:00:00:00:00:03

а она очень важна потому что : по дефолту незнаю почему у меня на всех трех вирталках
при создании vxlan порта у меня этот порт на всех трех виртуалках будет иметь ОДИНАКОВЫЙ СУКА МАК АДРЕС!
поэтому нужно руками задать мак адрес этого порта чтобы они ни в коем случае небыли одинаковые.
это была единсвтенная ебала. во всем остальном все должно сразу заработать.
ip_forward при этом неважно чему равен. ни в одной ссылке данный феномен не описан !




ксатти тема vxlan  хоршо изложено тут 
              kubernetes-flannel.txt



ссылки
https://ilearnedhowto.wordpress.com/2017/02/16/how-to-create-overlay-networks-using-linux-bridges-and-vxlans/

https://serverfault.com/questions/874438/set-up-bridged-vxlan-network-in-linux


продолжение. работаю со статьей https://vincent.bernat.ch/en/blog/2017-vxlan-linux#fnref-patch1



разберу сами команды


  ip link add vxlan110 type vxlan id 110 dstport 4789 local 172.16.10.25 dev enp0s3


dstport 4789  эта хрень указывает какой UDP порт будет иметь наш пакет в который  мы будем 
заворачивать наш исходный пакет
local 172.16.10.25 это указывает какой срс ип  будет иметь наш пакет
dev enp0s3  это указывает через какой порт плевать в сеть наш пакет


  ip link set vxlan110 address 02:00:00:00:00:01


это мы руками задаем мак нашей vxlan вирт карты чтобы он сука не был таким же как
на другом компе


  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.26  dev vxlan110 
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.27  dev vxlan110 
  

так как vxlan это типа вирт свич (как я сказал выше) то у него должны быть карта(база) портов и мак
адресов. тоесть когда в этот свич в какойто порт влетает пакет то свич смотрит у него src_mac 
и записывает что мол за таким то портом сидит вот такойто мак.
единсвтенрное что я не знаю о каких мак адресах идет речь - ведь у нас один л2 пакет оборачивыается другим
л2 пакетом. поэтом о маках какого пакета идет речь х знает. щас проверю.
значит я проверил. из vxlan карты вылетают пакеты уже распакованные. тоесть мы увидим мак адреса самих vxlan 
портов тоесть мы увидим маки


      02:00:00:00:00:01
      02:00:00:00:00:02
      02:00:00:00:00:03



и они в линуксе записываются в так называемую fdb базу свича.
все fdb базы от всех свичей линукс хранит в одной единой fdb базе
которую можно посмтреть через 

     $ bridge fdb

но все таки вот эти команды

  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.26  dev vxlan110 
  bridge fdb append to 00:00:00:00:00:00  dst 172.16.10.27  dev vxlan110 


они про другое. они указывают что если мы через нашу vxlan карту хотим отослать л2 фрейм у которого
dst_mac любой  00:00:00:00:00:00  то тогда этот л2 фрейм  нужно обернуть в новый л2 фрейм
и направить его на удаленный хост  172.16.10.26 и также на удаленный хост 172.16.10.27
тоеесть честно говоря с какого хуй данная информация суется в fdb базу я хуй знает почему они 
так делают. 



  ip -c a add 10.100.100.2/24 dev vxlan110
  ip -c link set dev vxlan110 up



далее мы нашему vxlan порту назначаем ИП адрес и поднимаем его. хотя есть и другой вариант более
мудотный - можно воткнуть этот vxlan порт в состав обычного br0 лиункс свича. но здесь я так делать
нестал.


в целом шарманка работает так - мы суем l3 пакет в vxlan порт. так как порт уровня л2 то ядро должно обернуть
этот л3 пакет в л2 фрейм. при этом src_mac известен это мак нашего vxlan порта а вот dst_mac неизвестен.
тогда ядро делает создает arp пакет. оборачивает его в UDP пакет и шлет на обе удаленные точки  172.16.10.26 и 172.16.10.27  там vxlan софт это распакоывает и плюет в сеть стек компов через vxlan порт.
вобщем обратно на наш комп прилетает ответ.  и тогда ядро оборачивает наш пакет в л2 фрейм , ставит наденный dst_mac
в этот л2 фрейм и шлет его на тот удаленный хост с которого он прилетел например на 172.16.10.26

таким образом если пакет влетел в наш vxlan порт то ядро пошлет его на все удаленные точки (VTEP)
только видимо для броадкаст траифка или типа того. 



будем считать с вопросом как работает vxlan хрень разобрались

