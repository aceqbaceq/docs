

здесь я буду рассаатривать вопрос работы со шрифтом
который мы загражаем на терминал тоест в драйвер
терминала.
а именно вопрос кодировок. вопрос маппинга. не путать
маппинг шрифта терминала с мапингом клавиутары
терминала. это соврешенно разыне вещи.


что такое мапинг клавиаутры (кеймап) это то что 
мы жмем на кнопку на клаве сидя в терминале. клава
генеирует scan code, ядро его его преобразует в 
кей-код. далее вструпаает в силу загруженнная в 
драйвер терминала  таблица keymap которая 
прервщаает кей-код в кейсим код. и уже его  дрйвер
терминала высирает в tty driver а тот предает его
баш!

так вот тут расматриывает другой мапинг. тут 
мы вгорим вот о чем. у нас из баша летит байт код.
он подает в tty driver тот его предает в драйвер
терминала. а тот его  должен прервратить в порядоковый
номер глифа в таблице глфиов которая загружена 
в драйвер терминала была ранее через шрифт. потому
что байт код прилетевший это одно а номер глифа
в таблце глфиов это другое. нужно чтобы было сделано
преоразрывание. так вот оно делается на оснвое 
мапинг таблицы которая загружается НАМИ вметсе со
шрифтом(таблица мапинга либо встроена в шрифт если
это юникод шрифт либо ее нужно укзаать отделным фай
лом). и уже имемя номер глифа драйвер темринала 
сует этот глиф(это битмап картинка) НА ДИСЛПЛЕЙ!
так вот эту таблицу мапинга мы будем тут 
расматривть. поэтому так как терминал это по сути
две разные железкт = ДИСПДЕЙ и КЛАВА. они слеплены
в одну вирт хрень под назвнаием терминал.
поэтому для каждой из них нужно совать  в драайер 
терминала свои индвиуалные настройки. и нужно
совать для каждой железкт свою таблицу мапинга!

в этом файле мы будем рассатривать настроки 
дисплея. 
поэтому будем говрит о мапинге дисплея.


по сути настройка дислетя состои из следущих аспктов.
мы држлны засунуть в терминал шрифт. тоестт это 
таблица глифов(тоесть битмап картнок) это делается
через сование шрифта. и мы должны засунуть таблицу
мапинга. также мы длжны укзать в каком режиме 
раоатет  дислпей терминала в utf режиме или не utf
режиме. что значит utf не utf. это значит что
если мы пихаем из баша в терминал через /dev/tty1
потко байтов то дравер дислея должен понимать
как ему рассатривть эти байты.  либо ему нужно 
расатрвтать что каждый байт это код одельнгого символа
на основе какойни буд ISO-8859 кодиовки. 
либо влетающие байты корирудют символы на освнове 
UTF-8 кодиовки. вот что это что это значит. тоест
это интерпетиация влтеающегов терминал байт 
потока. вотчто это значит.!





я шлю  с клавы байт код (d0 a8) котоырй сотвтетсутет
какомуто U+abcd. это приывает в дрйавер консоли.
он берет этот байт код , преоабразует в номер 
поинта U+abcd   , далее смотрит в своей таблице кото
рая имеет вид

номер символа(индекс в таблице)  U+NNNN
0x01                             U+1234
0x02                             U+2456

берет U+abcd ищет по таблице. и находит какой
индекс. берет этот индекс идет в шрифт который
я загрузил. и ищет там этот индекс. и берет
ту битмаап картинку которая по этому индексу
и рисует

если я хочу поменять картинку для какогто байт
кода то я должен взятьь оригинальный файл шрифта,
считаь с него оригинальную таблицу соотвесвтия
между номером битмап картинки(индекс) и номер юникод
поинта U-NNNN(будущий байт код). найти нужную картинку
в шрифте. найти ее индекс. взять мой байт код, найти 
какой для него соовтетвует U-MMMM поинт и вписать
номер этого поинта в тот индекс той картинки которую
мы хотим получить. например.
у меня есть байт код  d0 a8 (это русская буква "Ш"
в юнико табице) у нее юникод поинт это U-0428

беру шрифт и получаю из него оригинальную таблицу
U-поинтов. это можно сделать двумя путями

	# psfgettable cached_FullCyrSlav-Terminus24x12.psf  > CYR.map

тогда находим его положение внутри шрифта
	# cat CYR.map | grep 0428
	0x125	U+0428

тоесть индекс его битмап картинки это 0x125(293 dec)

либо если уствнаоен psftools (htищи тут гдето) то 
через psf2txt (там будет виден и символ как выгля
дит и номер юникод поинта)

   # psf2txt cached_FullCyrSlav-Terminus24x12.psf > CYR-tr.txt


# cat CYR-tr.txt | grep 0428 -B30
// Character 293
Bitmap: ------------ \
        ------------ \
        ------------ \
        ------------ \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        -#---#---#-- \
        --#--#---#-- \
        ---#######-- \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------
Unicode: [00000428];

вот тут хорошо видно что этот символ внутри шрифта
это 293-йй по счету битмап. и что он замаплен в таблице
мапов на Unicode: [00000428] тоест на U-0428 поинт.

тоесть если я шлю с компа 
  # printf '\xd0\xa8'
или 
  # printf '\u0428'
то ядро преобразует это из байтов в юникод поинт U-0428
в своей голове . далее пердает  вдрайвер консоли.(в его
видеподсистему часть). там он идет в таблицу шрифта
и ищет какой по счету глиф имеет юникод поинт U-0428
нахходит что это 293-ый по счету глиф. берет его и
сует на экран.

значит если я хочу чтобы когда я шлю на терминал байты
  # printf '\xd0\xa8'
  # printf '\u0428'
то он мне на экране рисовал вместо 'Ш' чтото другое
нам нужно в мапинг таблице взят мапинг таблицу
CYR.map которую я получил через 

	# psfgettable cached_FullCyrSlav-Terminus24x12.psf  > CYR.map

и указать чтобы юникод поинт U-0428 который в обычной
жизни отвечает за глиф "Ш" указывал на другой глиф.
например можно поменять местами глифы для буквы Ш 
и буквы З. юникод код поинт для З это U-0417
поэтому я беру исходную мап таблицу

# cat CYR.map | grep -E "0428|0417"
0x114	U+0417
0x125	U+0428

и меняю для этих код поинтов местами индексы то
есть глифы которые их отрисывавают

потом я засоваю эту мап таблицу в памят терминала tty1
если шрифт мой уже записан был ранее в терминал
то только суем новый мап файл

# setfont -C /dev/tty1 </dev/tty1 >/dev/tty1   -u CYR.map

(я  так и непонял оно на для всех терминалов применятеся или только для tty1)

а если я еще шрифт не пихал на терминал то 
и шрифт укзываем

# setfont -C /dev/tty1 </dev/tty1 >/dev/tty1 cached_FullCyrSlav-Terminus24x12.psf  -u CYR.map 

можно скачать из терминала его текущую мап таблицу
и проверить что изменения вступили в строй

# setfont -C /dev/tty1 </dev/tty1 >/dev/tty1 -ou map.current

# cat map.current | grep -E "0428|0417"
0x125	U+0417
0x114	U+0428

походу да. новый мапинг применииося. 
тестируем


  # printf '\xd0\xa8\n' > /dev/tty1
или 
  # printf '\u0428\n'
или
  # printf 'Ш\n'

мы должны на экране терминала вместо 'Ш'
увтдеть 'З'


Есть прикол. если я введ в консоли

 # showconsolefont 

то я там не замечу подмены. потому что ! эта
команда она печатает на экране таблицу глифов НЕ
на основе его юникод код поинта. а на основе 
индккса глифа в таблице. мы порядок сохранения 
глфиво в шрифте не поменяли! мы всего на всего
поменяли привязку код поинта к номеру глифа тоесть

у нас как бы ест две таблицы. одна таблица хранит
глифы и их порядковые номера просто по счету

1  глиф1='a'
2  глиф2='q'
3  глиф3='s'

эта таблица в памяти драйвер коснли не меняется.
тоесть глифы сохранены в памяти в том порядке как они
записаы в файле шрифта. 
и у нас есть вторая таблица которая свзяывает порядоку
вый номер из первой таблицы и номер юникод код
поинта

1   U-1234
2   U-5678
3   U-7899

так вот мы поменял даныне во второй таблце. а впервой
все безизмения!  так вот showconsolefont он 
печатет на экране первую таблицу.  а она то неменя
лась. порядок харненияглифрв в пмяти не имзенися!
прием печаатет он так. он печтает на экране в столбик
сверху вниз. высота столбика 16 символов. потом
он правее создает новый столбик . тоесть вот атк


  1 17
  2 18
  3 ...
  4
  5
  6
  7
  8

  9
  10
  11
  12
  13
  14
  15
  16


цирами  я указал номер индекса глифа из первой 
таблицы.





таким образом еще раз. вот унас ест терминал 
кторый рабрает в режиме Unicode , перкключить его
в этот режим можно через 

   ESC % G  с клавы в окне терминала

или 

   # printf '\x1B%%G' > /dev/tty1

через кмомандуню строку. (двойно %% нужен из за саомго
printf у которого этот сивол обычно служит для как 
спецсимвол а нам надо имено его и распечатать поэтому
делаем экранирование)

как проверит в каком реиме раотает щас терминал 
(его видеочаст) я незнаю. 

далее мы из проццесса шлем на терминал поток байтов.
так как терминал рабоает в реиме юникод то 
драйвер терминала ожидает что поток байтов будет
в себе кодирвать юникод поинт.
вот мы отправляем поток байтов 0xd0a8


  # printf '\xd0\xa8\n' > /dev/tty1


с точки зрения utf-8 это код поинт U-0428 
дравер терминал принимает этот байтовый поток
и в совей голове понимает что это U-0428
далее он идет в таблицу мапинга которую мы в него 
должны были записать раннее. и ищет там запись для
U-0428

0x114	U+0428

находит число 0x114
оно ему гвоорит о том что теперь надо пойти в таблицу
глифов (котоырй мы записали в драйвер терминала
ранее через загрузку шрифта. потому что шрифт это ни
что иное как таблица глифов и либ встроенная либо
закачанная отдельно таблица мапов).
и там он ищет в этой таблице глиф у которого поряд
ковый номер 0x114 . какой глиф он найдет такой
он на экран и сунет.






еще ПРИМЕР.
восстановим в драйвере терминала 
оригиналный мапинг

# psfgettable cached_FullCyrSlav-Terminus24x12.psf > orig.map
# setfont -C /dev/tty1 </dev/tty1 >/dev/tty1 -u orig.map 



поменяем так чтобы при посылке на тер
минал байт кода для q (0x71) у нас на экране рисовался
глиф r

для байт кода 0x71 ему соовтетаует юникод поин U-0071
а для символа r ему сотвтсвутет юникод поинт U-0072
открываем таблицу мапинов шрифта и ищем там 
эти два юникод поинта

# cat orig.map | grep -E "0071|0072"
0x071	U+0071
0x072	U+0072

значит тут сказано что эти код поинты примаплены
в таблице глифов в к глифам с номерами 0x71=113 
и 0x72=114


хочу подчркнуть что слева стоит число которое НЕ
яявялется байт котдом котоырй мы шлем на терминал
слева стоит порядоквый номер глифа в таблице 
глифов. какая картинк соовтествует этому номеру 
глифа надо смотреть в самом шрифте. давай посмотрим.
распакоываем шрифт и ищем там глифы с номерами
113 и 114

# psf2txt cached_FullCyrSlav-Terminus24x12.psf > font.txt

# cat font.txt | grep -E "Character (113|114)" -A26
// Character 113
Bitmap: ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ---#######-- \
        --#------#-- \
        -#-------#-- \
        -#-------#-- \
        -#-------#-- \
        -#-------#-- \
        -#-------#-- \
        -#-------#-- \
        -#-------#-- \
        --#------#-- \
        ---#######-- \
        ---------#-- \
        ---------#-- \
        ---------#-- \
        ---------#-- \
        ------------

// Character 114
Bitmap: ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        -#---#####-- \
        -#--#------- \
        -#-#-------- \
        -##--------- \
        -#---------- \
        -#---------- \
        -#---------- \
        -#---------- \
        -#---------- \
        -#---------- \
        -#---------- \
        ------------ \
        ------------ \
        ------------ \
        ------------ \
        ------------

ну и реально видно что юпоинты U-0071 укзыает на
глиф 'q' а юпоинт U-0072 указывает на глиф 'r'
мы в этом убедились.
теперь нам надо в мапинг таблице original.map
поменять на какие глифы укаызавают наши код поинты

БЫЛО
# cat orig.map | grep -E "0071|0072"
0x071	U+0071
0x072	U+0072


СТАЛО
# cat mod.map | grep -E "0071|0072"
0x072	U+0071
0x071	U+0072

тепрь намш код поинт U-0071 узывает на глиф 'r'
а код поинт U-0061 указыает на глиф 'q'

суем этот мапинг в драйвер терминала

# setfont -C /dev/tty1 </dev/tty1 >/dev/tty1 -u mod.map

запрашиваем у драйера терминала какой мапинг у него
сидит в голове теперь

# setfont -C /dev/tty1 </dev/tty1 >/dev/tty1 -ou current.map 

# cat current.map | grep -E "0071|0072"
0x72	U+0071
0x71	U+0072


видим что настройка применилась.

проверяем
 # echo "q" > /dev/tty1
на терминале
 r

или вот так
# echo -e "\u0071" > /dev/tty1
на терминале
 r

все сработало

