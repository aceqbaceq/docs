| termnal 
| tty driver
| console



   * зачем имея А0 мы еще и ctrl+d создали.
     оно якобы нужно чтобы юзер за терминалом 
     мог сообщить ядру что передача данных закончена.
     и что? поэтому в потоке между термналом и 
     драрввером ттай не может быть символа 0х04
     поэтому через пайп поток уже может иметь 0х04
     потому что через пайа содеинятся компьютерные
     процссы а чрез терминал собдиянется ядро и юзер



значит у нас террминал в лице двух железок : клава
и дисплей которые засунуты в одну коробку. 
мы такаем на клаве 'Enter' и клава генерирует 0x0D
и шлет на tty driver ( на самом деле клава генериурет
скан код. который летит в ядро . он его трансфорурует
в кейкод. и потом на основе загруженной нами в ядро
таблицы keymap ядро трансформирует этот кей код в 
кейсим который и будет равен 0x0D  который и поступа
ет из условного говорря драйвера клавы в tty driver
в ядре. для простоты  я буду считать что клава на
терминале сразу гененирует кейсим 0x0D)

так вот если tty driver раотает в каноническом режиме
то если в него с терминала прилетают байт коды
то они оседают в его буфере. и он не позволяет
юзер процессу читать из этого буфера. тоесть 
если юзер процесс запустил сискол  read() то этот
сисколл спит в ядре. тоесть байт коды приетают 
с клавы терминала оседают в буфере tty driver но дальше
никуда не летят. прилет 0D в tty driver тоже для него
ничего особенного. но! у него по деолфту есть настройка icrnl  ( # stty -a) которая ему говорит
что если прилетел 0x0D то его нужно на лету преобразовать в 0x0A а это уже сосвсем другой коленкор!
в tty driver зашито что если  так или иначе к нему
поступил 0x0A то это сигнал для tty driver о событии
"новая строка" со стороны юзера который сидит за
терминалом. что делает tty driver - он записывает 0x0A
в буфер к остальным символам котоыре к тому моменту
там накопились. и на втором шаге он будит read()
и позволяет ему прочттать то что лежит в буфере 
и скопировать в область памяти юзер процесса.
при этом read() в коде возврата сообщит о том сколько
байт он скопировал из буфера. если же в буфере ничего
нележало и при этом в tty driver так иначе поступил 
0x0A то он 0x0A записывает в буфер  и при этом
будит read() который копирует этот 0x0A   и в коде
статуса возвращает 1. ну вобщем понятно.
таким образом байт 0A собщает от юзера к ттай дарйверу
о том что юзер закочил нажимать на кнопки и хотел
бы чтобы ттай дайрвер позволил юзер программе считать
все то что нападало от юзера и его клавы в буфер ттай
драйвера. тоест 0A это приказ отюзера к tty driver
"эй ттай дайрвер!  я требую чтобы все что что у тебя 
в буфере накопилось от моих нажатий ты позволил 
юзер процеграмме считать! настало время!"
и тут интересный момент - зачем при этом этот урправля
ющий символ ттай драйвер вставляет в буфер в кучку 
к остальным символам. ведь этот байт код не кодирует
вроде как никакой граф символ. какой смысл это переда
вать далее в юзер программу. ведь по идее этот байт
код пердназначен для общения юзера и ттай драйвера
а к самому  тексту неимеет отношения. однако что
интерсно. этот байт код 0A он имеет управлющее 
отношение еще к одной хрени - к дисплею терминала.
если из ядра на терминал будет послан 0A то(внимание!) на дисплее курсор будет опущен на одну строку вниз.
если при этом курсор располагался внизу в самойй
нижней строке то у нас экран будетпрокручен на одну
строку наверх таким образом затерев самую вернюю
строку а внизу будет добавлена новая чистая строка.
и курсор будет помещен в самое левое положение в строке. еще раз подчеркну тот момент что экран будет
проскроллен только если курсор стоял всамой нижней 
строке. а если он стоял где ни будт посредине экрана
то скроллинга не будет!
таким образом байт 0A является управляющим нетолько
со стороны юзера по отношению к ттай дарйверу 
чтобы он наконец позволил юзер приложению увидеть 
все то что нападало  в буфер . но также этот байт
является упрваляющим для дисплея! он играе роль
формтирующей команды для дисплея! тоесть если 
ядро посылтает текст на терминал то тот его просто
напросто печатает символ за симоволом в строке в 
позииции где стоит курсор. и сдвигает курсор по строке.
если  унас строка закончилась то терминал сам переводит
курсор в начало строки и опускает его вниз на одну
строку вниз. и прдолжает печатать следущий символ. 
если это была самая нижняя строка то терминал сам
прокрути экран на одну строкувверх а внизу нарисует
пустую строку. и продолжит печать. (ровно также как 
действуеи голвка принтера). но! мы можем в файле
вставить управляющий символ 0A и если он поступит
на дислей из ядра то терминал в незавиимости от того
где у нас в строке стоял курсор - у нас терминал
сдвинет курсор на одну строку вниз и пердивинет
курсор в самое начало строки влево. и оттуда продолжит
печать следущего символа. тоесть 0A позвволяет фрмати
ровать вывод текста на экране на дисплее. позволяет
регулировать "длину" очередной строки при печати
нашего текста.  поэтому поскольку байт кодд явлеся
управлябщим нетолько для поведения tty driver
но и для поведения дисплея терминала то поэтому
tty driver коода получает 0A то он его непросто 
слушается а он еще и его сует в буфер. чтобы
юзер прилоение тоже могло его увидеиь. записать 
в файл. на случай если мы помтом будем этот файл
посылать с диска на экран терминала  чтобы 
нетолько еtty driver знал о событии "новая строка"
но и дислпей знал при отображении текста где
наступило событие "новая строка" когда этот тпкст
набирали на клаве и пихали в ядро! именно поэотому
tty driver пихает 0A в буфер и этот байт попдаает
в текст котоырй видит юзер процесс и воможно запиывает
его в файл для последюущего уже вывода на дисплее.
в будущем.

итак  я хоте покчекрунуть на что вляиет байт 0A
и зачем его ттайд драйвер продвигает дальше учитвая
то что этот байт формаьно не имеет никакого печатного
глифа. и еще описать прикол о том что при нажатии
на 'Enter' у нас генерруется не 0x0A а 0х0D но
за счет натроек внутри tty driver он его получив
заменяет на лету на 0x0A
при этом а что если эту настройку отключить то
что будет? если 0D получил ттай драйвер то для него
ничего особго это не означает. он просто положит
этот байт в буфер как бутто это обычный печтный
символ влетел и будет ждать что прилетит дальше.
при этом read() он будить не будет. а что бует
если из ядра послать 0x0D на дисплей терминала?
а будет то что для дислпея это уравляющий символ
и вот что он сделат - он переместит курсор в начало
текущей строки. если адлее мы на терминал будем
слать байт коды обычных граф символов то они начнут
затирать то что в этой строке было выведено ранее.
никакого скрооллинга строки при этом не будет. 
вот какое действие имеет 0D на ттай драйвер
если этот байт прилеетел со стороны клавы
и вот какое дейтсвиие имеет этот байт на дислпей.
по  сути этот байт код полуачется ненужен ни для
отправки его на дисплей ни для отправки его с клавы
на ттай драйвер. (точнее он может быть нужен но 
крайне редко). в этом плане мне неясно зачем было
деать так чтобы кнпка Enter с клавы генерировала 
байт код 0x0D который на нахрен ненужен а не 0x0A который по факту нам реально нужен и постояннно. 
и из за этого ттай драйвер вынужден постоянно налету
менять прилетающий с клавы 0x0D на 0x0A
бред. кстати если я хочу породить на клаве прям
реально 0x0A в чистом виде. тоест чтобы прям именно
клава породила этот байт  код то нужно нажаь Ctrl+j
тгда tty driver получит с клавы именно 0x0A в
чистомвиде и ему ненужно будет ничего преобразоывать

в таблце ascci в 
   $ man ascii 
вот так сказано на счет 0x0A

CHAR
LF  '\n' (new line)

тоесть типа кодовое название у этого байт кода 
согланоно ману линукса 

  LF

хотя! в бумажке от самог о ANSII инстииута где
приудмали ascii 
    https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118033296.oth

там для этго байт кода указано что кодовым назчанием
для этго байт кода является 

  (nl) 

видимо сокращенно
от NewLine. 

значит я тут щас раскажу важную вещь. в целом неважно
как мы называем этот байт код LF(LineFeed ) или 
NL(NewLine)

если в терминал прилетает байт кодд 0x0A то оказывается что поведение терминала бывает РАЗНЫМ!!!!!

во первых изначально этот байт код должен приводить
на терминале к тому что он (ВНИМАНИЕ!) всего навсего
опускает курсор на одну строку вниз. и боьше ничего
не делает. это и есть исходный смысл LineFeed.
тоесть просто на принтере прокручивается вал
и все. по горизонтали курсор сохраняет тоже самое
положение что и было! но! на самом терминале (именно
на терминале а не в настройках tty driver) можно
натрить два режима региарования терминала на прилет
0x0A байта. 

вот эти две настройки

  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)


если у нас вторая настройка то если втерминал
влетает байт LF(0x0A) либо FF(0x0C)  либо VT
то теринал ведет себя так как бутто в него влетел LF
тоесть он просто опускает курсор на одну строку вниз
неменяя его горизонтального положения. 
вот это и написано в скобке
если LF, FF, VT  то это интепретиурется как LF
если же влетает байт CR (0x0D) то теринал на них
реагирует как на то что влетел CR то есть двигает
курсор в начало строки.
нас конкртено инетерсует повдение на влет LF 0x0A
елси он влетел то просто у нас делается лайн фид. ивсе.


НО! на терминале по дефолту работает первый 
режим который можно еще вот так активировать


  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)


что он делает. 
если в терминал влетает LF либо FF либо VT либо CR
то терминал на это реагиует так КАК БУТТТО  в него
влетел CR+LF


таким образом LF изначально по своей сути он не пере
водит курсор вначало стоки. а он всего навсего
двигает курсор на строку вниз. это все что изначально
это байт код должен делать. но можно настроить на
терминале чтобы он на этот байт реагировал как бутто
влетел в комп CR+LF

в реальности комп подкручивает это в другом месте.
можно подкрутить это пведение в tty driver,
вот его настройки  

   # stty -a
   onlcr  ocrnl

что делают настоки tty driver котоырые имеют
в своем названии вначале букву "o"
это настройки которые касаются того что если 
через tty drivrt летит поток байтов в направлении
дисплея терминала то он анализиурет этот поток и 
он может в нем налету делать замену. 
кокнкетно эти две настйоки делают то что 


onlcr = если в потоке есть NL то меняет это на NL+CR
ocrnl = если в потоке есть CR то меняет это на NL+CR


таким образом можно засавтит терминал если мы нанего
из баша шлем 0x0A(NL\LF) то можно либо в tty driver
настроить динмическое прикручивание CR к этому байту
(что комп по дефолту и делает)


либо можно пойти по другому пути на самом терминале сделать  подстройку что я выше писал

  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)


тоесть при прилете LF  терминал будет реагировать
так как бутто в него влетел CR+LF


так что как обычно все опять совсем непросто!



в свете этого дела ставнотьс понятно зачем
естт esc севенс вот такая

  ESC + E   (именно болшая e)

формально она делает вот что 
на термиале курсор переходит на одну
строку вниз и внчале строки.

раньше было непонтно зачем городить этот секвенс
если есть LF байт 0x0A а щас стало понятно. что 
терминал этот прлет этого байта может реагировать 
по разному опяь же в завсиимости от другой настройки
этого терминала - может реагирвоать как LF дейсвтие
так и CR+LF действие. а вот секвенс ESC + E всегда
отработает одинакоово.


поиграться с этми настрйками можно 
подготовив термиал через terminal-prepare.txt
а потом прогнав те натройки что  я выще 
указал.


еще тут хочу скзаать что среди терминалов
линукс консольный терминал и xterm они понимают
настройки 



  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)



а вот gnome-terminal непонимает кокнтено эти 
две настройки. он все время работает врежиме 
     ESC [ 2 0 l

повторюсь два других терминала - xterm и линукс
консольный трминал - они все понимают.

кстаи в man console_codes там брехня на счет
линукс консоле терминала. там сказано что 
он понимает толкьо вот эту настройку


  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)


и что ее если тыкать то она либо включает либо 
выключыет этот режим.

на самом деело он понмиает обе эти настроки



  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)




еще момент. получаетс что символ 0A послааный на
терминал он изачанльно неприводит к новой строке. 
а всего навсего делает line feed. то есть прокручиыт
головку на одну строку вниз. это значит что если
у нас в файле на диске в тексте идет 0xA0 то по
хорошему это не символ новой строки это символ
именно LINE-FEED. а если мы реально хотим сделать
новую строку то нужно бы в тексте вставлять 
 
  LF+CR тоесть  0x0A 0x0D


на счет символа FF(FormFeed) 0x0C
он изначально предназначен для принтеров. он 
длелал то что принтер прокручивал бумагу на одну
страницу вверх. на  дисплее терминала эта команда
действуеи обычно по другому.

исходя из этих двух настроке


  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)



при влете 0x0C в дисплей он обаарбывает этот байт
код как бутто влетел LF либо CR+LF
тоест ни окакой прокрутке на весь экран и речи
не идет


ксатти с клавы 0x0C ожно получтиь нажав Ctrl+l



далее
можно псмотреть какие кнопки какой код рожают
через  "terminal-427.c.txt"
например можно убедиться что Ctrl+L дает 0x0C





* прееходим к следующему байт коду
 0x04 
он генериурется на клаве если я там нажму Ctrl+d
значит вверху  я распмывал детали про байт код
LF\NL 0x0A
а тееерт хочу расписать про другой важный байт 
код 

  0x04 

он же 

  EOT 

согласно таблцие ascci 
в линуксе. кстати он также называется в офицальной
ASCII таблцие ansii






* насчет EOF у glibc