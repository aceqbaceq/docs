| termnal 
| tty driver
| console



   * зачем имея А0 мы еще и ctrl+d создали.
     оно якобы нужно чтобы юзер за терминалом 
     мог сообщить ядру что передача данных закончена.
     и что? поэтому в потоке между термналом и 
     драрввером ттай не может быть символа 0х04
     поэтому через пайп поток уже может иметь 0х04
     потому что через пайа содеинятся компьютерные
     процссы а чрез терминал собдиянется ядро и юзер



значит у нас террминал в лице двух железок : клава
и дисплей которые засунуты в одну коробку. 
мы такаем на клаве 'Enter' и клава генерирует 0x0D
и шлет на tty driver ( на самом деле клава генериурет
скан код. который летит в ядро . он его трансфорурует
в кейкод. и потом на основе загруженной нами в ядро
таблицы keymap ядро трансформирует этот кей код в 
кейсим который и будет равен 0x0D  который и поступа
ет из условного говорря драйвера клавы в tty driver
в ядре. для простоты  я буду считать что клава на
терминале сразу гененирует кейсим 0x0D)

так вот если tty driver раотает в каноническом режиме
то если в него с терминала прилетают байт коды
то они оседают в его буфере. и он не позволяет
юзер процессу читать из этого буфера. тоесть 
если юзер процесс запустил сискол  read() то этот
сисколл спит в ядре. тоесть байт коды приетают 
с клавы терминала оседают в буфере tty driver но дальше
никуда не летят. прилет 0D в tty driver тоже для него
ничего особенного. но! у него по деолфту есть настройка icrnl  ( # stty -a) которая ему говорит
что если прилетел 0x0D то его нужно на лету преобразовать в 0x0A а это уже сосвсем другой коленкор!
в tty driver зашито что если  так или иначе к нему
поступил 0x0A то это сигнал для tty driver о событии
"новая строка" со стороны юзера который сидит за
терминалом. что делает tty driver - он записывает 0x0A
в буфер к остальным символам котоыре к тому моменту
там накопились. и на втором шаге он будит read()
и позволяет ему прочттать то что лежит в буфере 
и скопировать в область памяти юзер процесса.
при этом read() в коде возврата сообщит о том сколько
байт он скопировал из буфера. если же в буфере ничего
нележало и при этом в tty driver так иначе поступил 
0x0A то он 0x0A записывает в буфер  и при этом
будит read() который копирует этот 0x0A   и в коде
статуса возвращает 1. ну вобщем понятно.
таким образом байт 0A собщает от юзера к ттай дарйверу
о том что юзер закочил нажимать на кнопки и хотел
бы чтобы ттай дайрвер позволил юзер программе считать
все то что нападало от юзера и его клавы в буфер ттай
драйвера. тоест 0A это приказ отюзера к tty driver
"эй ттай дайрвер!  я требую чтобы все что что у тебя 
в буфере накопилось от моих нажатий ты позволил 
юзер процеграмме считать! настало время!"
и тут интересный момент - зачем при этом этот урправля
ющий символ ттай драйвер вставляет в буфер в кучку 
к остальным символам. ведь этот байт код не кодирует
вроде как никакой граф символ. какой смысл это переда
вать далее в юзер программу. ведь по идее этот байт
код пердназначен для общения юзера и ттай драйвера
а к самому  тексту неимеет отношения. однако что
интерсно. этот байт код 0A он имеет управлющее 
отношение еще к одной хрени - к дисплею терминала.
если из ядра на терминал будет послан 0A то(внимание!) на дисплее курсор будет опущен на одну строку вниз.
если при этом курсор располагался внизу в самойй
нижней строке то у нас экран будетпрокручен на одну
строку наверх таким образом затерев самую вернюю
строку а внизу будет добавлена новая чистая строка.
и курсор будет помещен в самое левое положение в строке. еще раз подчеркну тот момент что экран будет
проскроллен только если курсор стоял всамой нижней 
строке. а если он стоял где ни будт посредине экрана
то скроллинга не будет!
таким образом байт 0A является управляющим нетолько
со стороны юзера по отношению к ттай дарйверу 
чтобы он наконец позволил юзер приложению увидеть 
все то что нападало  в буфер . но также этот байт
является упрваляющим для дисплея! он играе роль
формтирующей команды для дисплея! тоесть если 
ядро посылтает текст на терминал то тот его просто
напросто печатает символ за симоволом в строке в 
позииции где стоит курсор. и сдвигает курсор по строке.
если  унас строка закончилась то терминал сам переводит
курсор в начало строки и опускает его вниз на одну
строку вниз. и прдолжает печатать следущий символ. 
если это была самая нижняя строка то терминал сам
прокрути экран на одну строкувверх а внизу нарисует
пустую строку. и продолжит печать. (ровно также как 
действуеи голвка принтера). но! мы можем в файле
вставить управляющий символ 0A и если он поступит
на дислей из ядра то терминал в незавиимости от того
где у нас в строке стоял курсор - у нас терминал
сдвинет курсор на одну строку вниз и пердивинет
курсор в самое начало строки влево. и оттуда продолжит
печать следущего символа. тоесть 0A позвволяет фрмати
ровать вывод текста на экране на дисплее. позволяет
регулировать "длину" очередной строки при печати
нашего текста.  поэтому поскольку байт кодд явлеся
управлябщим нетолько для поведения tty driver
но и для поведения дисплея терминала то поэтому
tty driver коода получает 0A то он его непросто 
слушается а он еще и его сует в буфер. чтобы
юзер прилоение тоже могло его увидеиь. записать 
в файл. на случай если мы помтом будем этот файл
посылать с диска на экран терминала  чтобы 
нетолько еtty driver знал о событии "новая строка"
но и дислпей знал при отображении текста где
наступило событие "новая строка" когда этот тпкст
набирали на клаве и пихали в ядро! именно поэотому
tty driver пихает 0A в буфер и этот байт попдаает
в текст котоырй видит юзер процесс и воможно запиывает
его в файл для последюущего уже вывода на дисплее.
в будущем.

итак  я хоте покчекрунуть на что вляиет байт 0A
и зачем его ттайд драйвер продвигает дальше учитвая
то что этот байт формаьно не имеет никакого печатного
глифа. и еще описать прикол о том что при нажатии
на 'Enter' у нас генерруется не 0x0A а 0х0D но
за счет натроек внутри tty driver он его получив
заменяет на лету на 0x0A
при этом а что если эту настройку отключить то
что будет? если 0D получил ттай драйвер то для него
ничего особго это не означает. он просто положит
этот байт в буфер как бутто это обычный печтный
символ влетел и будет ждать что прилетит дальше.
при этом read() он будить не будет. а что бует
если из ядра послать 0x0D на дисплей терминала?
а будет то что для дислпея это уравляющий символ
и вот что он сделат - он переместит курсор в начало
текущей строки. если адлее мы на терминал будем
слать байт коды обычных граф символов то они начнут
затирать то что в этой строке было выведено ранее.
никакого скрооллинга строки при этом не будет. 
вот какое действие имеет 0D на ттай драйвер
если этот байт прилеетел со стороны клавы
и вот какое дейтсвиие имеет этот байт на дислпей.
по  сути этот байт код полуачется ненужен ни для
отправки его на дисплей ни для отправки его с клавы
на ттай драйвер. (точнее он может быть нужен но 
крайне редко). в этом плане мне неясно зачем было
деать так чтобы кнпка Enter с клавы генерировала 
байт код 0x0D который на нахрен ненужен а не 0x0A который по факту нам реально нужен и постояннно. 
и из за этого ттай драйвер вынужден постоянно налету
менять прилетающий с клавы 0x0D на 0x0A
бред. кстати если я хочу породить на клаве прям
реально 0x0A в чистом виде. тоест чтобы прям именно
клава породила этот байт  код то нужно нажаь Ctrl+j
тгда tty driver получит с клавы именно 0x0A в
чистомвиде и ему ненужно будет ничего преобразоывать

в таблце ascci в 
   $ man ascii 
вот так сказано на счет 0x0A

CHAR
LF  '\n' (new line)

тоесть типа кодовое название у этого байт кода 
согланоно ману линукса 

  LF

хотя! в бумажке от самог о ANSII инстииута где
приудмали ascii 
    https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118033296.oth

там для этго байт кода указано что кодовым назчанием
для этго байт кода является 

  (nl) 

видимо сокращенно
от NewLine. 

значит я тут щас раскажу важную вещь. в целом неважно
как мы называем этот байт код LF(LineFeed ) или 
NL(NewLine)

если в терминал прилетает байт кодд 0x0A то оказывается что поведение терминала бывает РАЗНЫМ!!!!!

во первых изначально этот байт код должен приводить
на терминале к тому что он (ВНИМАНИЕ!) всего навсего
опускает курсор на одну строку вниз. и боьше ничего
не делает. это и есть исходный смысл LineFeed.
тоесть просто на принтере прокручивается вал
и все. по горизонтали курсор сохраняет тоже самое
положение что и было! но! на самом терминале (именно
на терминале а не в настройках tty driver) можно
натрить два режима региарования терминала на прилет
0x0A байта. 

вот эти две настройки

  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)


если у нас вторая настройка то если втерминал
влетает байт LF(0x0A) либо FF(0x0C)  либо VT
то теринал ведет себя так как бутто в него влетел LF
тоесть он просто опускает курсор на одну строку вниз
неменяя его горизонтального положения. 
вот это и написано в скобке
если LF, FF, VT  то это интепретиурется как LF
если же влетает байт CR (0x0D) то теринал на них
реагирует как на то что влетел CR то есть двигает
курсор в начало строки.
нас конкртено инетерсует повдение на влет LF 0x0A
елси он влетел то просто у нас делается лайн фид. ивсе.


НО! на терминале по дефолту работает первый 
режим который можно еще вот так активировать


  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)


что он делает. 
если в терминал влетает LF либо FF либо VT либо CR
то терминал на это реагиует так КАК БУТТТО  в него
влетел CR+LF


таким образом LF изначально по своей сути он не пере
водит курсор вначало стоки. а он всего навсего
двигает курсор на строку вниз. это все что изначально
это байт код должен делать. но можно настроить на
терминале чтобы он на этот байт реагировал как бутто
влетел в комп CR+LF

в реальности комп подкручивает это в другом месте.
можно подкрутить это пведение в tty driver,
вот его настройки  

   # stty -a
   onlcr  ocrnl

что делают настоки tty driver котоырые имеют
в своем названии вначале букву "o"
это настройки которые касаются того что если 
через tty drivrt летит поток байтов в направлении
дисплея терминала то он анализиурет этот поток и 
он может в нем налету делать замену. 
кокнкетно эти две настйоки делают то что 


onlcr = если в потоке есть NL то меняет это на NL+CR
ocrnl = если в потоке есть CR то меняет это на NL+CR


таким образом можно засавтит терминал если мы нанего
из баша шлем 0x0A(NL\LF) то можно либо в tty driver
настроить динмическое прикручивание CR к этому байту
(что комп по дефолту и делает)


либо можно пойти по другому пути на самом терминале сделать  подстройку что я выше писал

  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)


тоесть при прилете LF  терминал будет реагировать
так как бутто в него влетел CR+LF


так что как обычно все опять совсем непросто!



в свете этого дела ставнотьс понятно зачем
естт esc севенс вот такая

  ESC + E   (именно болшая e)

формально она делает вот что 
на термиале курсор переходит на одну
строку вниз и внчале строки.

раньше было непонтно зачем городить этот секвенс
если есть LF байт 0x0A а щас стало понятно. что 
терминал этот прлет этого байта может реагировать 
по разному опяь же в завсиимости от другой настройки
этого терминала - может реагирвоать как LF дейсвтие
так и CR+LF действие. а вот секвенс ESC + E всегда
отработает одинакоово.


поиграться с этми настрйками можно 
подготовив термиал через terminal-prepare.txt
а потом прогнав те натройки что  я выще 
указал.


еще тут хочу скзаать что среди терминалов
линукс консольный терминал и xterm они понимают
настройки 



  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)



а вот gnome-terminal непонимает кокнтено эти 
две настройки. он все время работает врежиме 
     ESC [ 2 0 l

повторюсь два других терминала - xterm и линукс
консольный трминал - они все понимают.

кстаи в man console_codes там брехня на счет
линукс консоле терминала. там сказано что 
он понимает толкьо вот эту настройку


  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)


и что ее если тыкать то она либо включает либо 
выключыет этот режим.

на самом деело он понмиает обе эти настроки



  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)




еще момент. получаетс что символ 0A послааный на
терминал он изачанльно неприводит к новой строке. 
а всего навсего делает line feed. то есть прокручиыт
головку на одну строку вниз. это значит что если
у нас в файле на диске в тексте идет 0x0A то по
хорошему это не символ новой строки это символ
именно LINE-FEED. а если мы реально хотим сделать
новую строку то нужно бы в тексте вставлять 
 
  LF+CR тоесть  0x0A 0x0D


на счет символа FF(FormFeed) 0x0C
он изначально предназначен для принтеров. он 
длелал то что принтер прокручивал бумагу на одну
страницу вверх. на  дисплее терминала эта команда
действуеи обычно по другому.

исходя из этих двух настроке


  ESC [ 2 0 h  
     newline mode LF, FF, VT, CR = CR/LF)

  ESC [ 2 0 l  
     line feed mode (LF, FF, VT = LF ; CR = CR)



при влете 0x0C в дисплей он обаарбывает этот байт
код как бутто влетел LF либо CR+LF
тоест ни окакой прокрутке на весь экран и речи
не идет


ксатти с клавы 0x0C ожно получтиь нажав Ctrl+l


байт 0A он по сути нужен вот частности для чего.
вот у меня есть юзер приложение которое сидит
за tty driver. и это юзер приложение оно не имеет
функционала по редактированию юзерского ввоода.
тоесть вот нажал  я на кнопки пару раз. а потом
начал работать стрелками и бекспейсами и получается
ктото должен редактировать весь тот набор кнопок
который был введен до этого. если мое юзер приложе
ние нехочет уметь это делать функции текст редактиро
вания то это можно прееложить на плечи tty driver.
он занимается редактированием символов в буфере.
так вот 0A байт код с клавы юзера укзывает ттай
драйверу что нам нравится контент "строки" и теперь
мы его просим эту готовую строку направить в юзер
процесс. 
с другой стороны вот телетайп (тот который телегра
ммы переслылал) он же как аналог дисплея компа
или тот же самый матричный приентер. так вот 
если мы ЕМУ преедадим 0A то для него это сигнал 
о LineFeed. тоесть прокрутить курсор (печатающую
головку ) на строку вниз. (безе переноса каретки 
это к этому надо добавить CR байт)



далее
можно псмотреть какие кнопки какой код рожают
через  "terminal-427.c.txt"
например можно убедиться что Ctrl+L дает 0x0C


* на счет какнончиесеого и неканнического режима.
неканончиеский режим очень простой (читай man termios)
мы жмем кнопку она приелатет в ттай драйвер и он 
тут же будит read() и тот кпоирует этот байт из 
буфера ттай драйвера в ядре в памть юзер приожения.
все просто. хотя не совсем. есть в этом режиме 
опции такие как например 

  $ stty -a
  min = 1; time = 0;

(  о них читай в man termios)

и можно настроить так что ттай драйвер будет ждать
чтобы прилетело сколько байт либо исчерпался таймер
и только потом он будит read()
в целом в этом режиме обработкой байтов с клавы
терминала занмиается само приложение.

каконичекий режим - это режим когда мы тыкаем на
кнопки и они прилетают в ттай дравер но он их
пишет в свой буфер но не будит read() и таким
образом сам ттай драйвер берт на себя функции тексто
вого редактора. потому что юзер может нажимать стрелки
или backspace и тогда сам тттай драйвер редактирует
байты в своем буфере. тоесть юзер может редактироват
символы и так и сяк. и их обработкий замнаиется
татай драйвер. и толко если с клавы прилеитит 0A
байт то он его тоже пишет в буфер а поом будит read()
таким образом юзе приожение получает уже готовую
отредактированную строку. приожению ненужно в своем
коде иметь код кооторый берет на себя функции
редактора текста в строке.
в этом режиме есть еще одна интересная кнопка
это ctrl+d о ней ниже.
(намопню такой прикол что когда мы тыкаем enter
то клаав генеируует 0D он прилетатт в ттай драйвер
а там стоит настройка icrnl которая налету преобра
зует 0D в 0А )


а вот как работает команда $ cat
она нередактиурет режим терминала. обычно от баша
ей доставтеся терминал в канончиеком режиме 
плюс режимы echo echoctl
это делает то что мы тыкаем на клааве буквы. так
как вкочен режим канона то байты недолетают в cat
зато тта драйвер обратно автоматом шлет те байты
которые в него влетели сс клавы. плюс если прилетают
байты  в диапазоне 0x00-0x1А (управляющие байты)
то он в ответ шлет нечто другое тоесть
  

   ^N

где N символ вычисляется по формуле которую я не 
буду касаться. но как пример при прилете 0x0C
в обратку ттай драйвер пошлет
  
  ^L

так что мы тыкаем кнопки на эркане появлястя
символы. но cat тут ни причем. 
и вот мы нажали Enter. ттай дравер пробудул read()
данные попали в cat и он тогда шлет на дислей
терминаоа те байты что получил.
таким образом мы видим на экране два раза 
те символы что мы тыкнули на клаве.
но  я отвлекся.  возрващаюсь к осовному контенту




* прееходим к следующему байт коду 0x04 
он генериурется на клаве если я там нажму Ctrl+d
(вверху  я расписывал детали про байт код
LF\NL 0x0A
а тееерт хочу расписать про другой важный байт 
код   0x04 он же   EOT  согласно таблцие ascci 
в линуксе. кстати он также называется в офицальной
ASCII таблцие ansii EOT - end of transmission.)


значит что происходит. если у нас включен некакннич
еский режим. тогда все просто ттай драйвер шлет
байт 0х04 в юзер прогу. а она сама реает что ей
жадьше делать.


если же включен какнический режим то ! - ттай 
драйвер не доавляет этот байт в буфер. тоесь
приожение не увидит этот байт код. но он будет
read() и тот копирует то что лежит в буфере  в 
память приложения.

напомню что read() имет два  параметра при возрвате.
во первых та область что мы ей дали он в нее копирует
данные. второй параметр это код вовзрата. в нем
ядро нам сообает сколько байт оно скоиирпировало в
нашу область памяти.

так вот. если в буфере чтото было то у нас рид()
вернет сколько байт оно нам скорровало. если 
прижоение внмиателное то оно может проверить что
на конце этот массива нет символа 0А а значит
рид() был вызывао из за нажатия ctrl+d или 0х04

если же в буфере ничего не было то read() вернет
юзеру код взрата 0. (НОЛЬ) и это яялется для 
приожения признаком о том что передача данных
была с той стороны ( в данном случае юзером за 
терминалом) ЗАКОНЧЕНА. однако это личное дело 
приложения реагировать на это или жить спокойно 
дальше. на уровне системы ничего осоего не поисходит.
прсто  приожение должно понять что ели оно подключено
к терминалу то если мы получил в коде возарата от
read() ноль то эт значит что юзер тыкнул ctrl+D
намекнув что передача данных с его стороны закончена.
что значит передача данных. ну типа как сеанс связи
от юзера к этому юзер приоложению со стороны юзера
намек что пора бы его закончить. ну я скажу так
положим что юзер набирал текст и нажатием ctrl+d 
он намекает что мы достигли конца текста. 
что делать дальще это решать прилоению. ядро ни
коим образом ничего неделает на это нажатие!
ниакого EndOfTransmission не происходит в помине!
физически то что делает ядро - оно всего навсего
будит read() это все что оно делает!!!!
больше ничего!!! никкаого рарзаыва связи ни в каком
смысле не происходит! если мы тыкнем в терминале
100 раз подряа ctrl+D то всего навсего ттай дарвер
100 раз разбудит read() и он сто раз вернет 0 
в коде возарта. ну и что ? а птом мы можем продолжит
набивать текст и нажать enter и этот текст ядро
передаст юзер приоложению.
так что нажатие ctrl+D НИЧЕГО ТАКОГО СТРАШНОГО
НЕДЕЛАЕТ!!! все что ядро делает это будит read()
и на этом все!



баш преключает терминал в НЕканончиеский режим
и сам аанлизуерует байты которые к нему прилеают
в том числе из числа управляющих. так вот если
у нас в строке баща ничего не напечаатно и мы ткаыкм
ctrl+d то для него это сигна что юзер больше не
хочет работаьть с баш и он себя грохает.



вобщем с точки зрения ядра в канончскоем режиме
нажатие ctrl+d непросиходит ничего особенного
оно просто будит read() и боьлше нихрена недает!
а дальше забота приожения как инптретиоовать это!
а именно то что если буфер ттай дарвера  был 
пустой то read() возращает НОЛЬ. и вот еще раз 
скажу что это забота юзер приложения както 
интерпетировать это событие. но приожение может
еего никак не инепртировать!! никак! и ядро тоже
ничего такого неделает как я уже сказал! так что
вот так работает нажатие на ctrl+d тоест 0х04
НИЧЕГО ОСОБОГО ! это не сравнить с  ctrl+c котоое
заставляет ядро сгенерирвать SIGTERM для всей
фореггануд группы прикрепленной к этому термианалу.
вот это да. вот это я понимаю силища.

а ctrl+d рабтает как всего навсего сраный 0A ттолько без запиывания 0x04 в буфер ттай драйвера.
НИЧЕГО ОСОБОГО! никаких прерыаний не будет у
работы ни ядра ни прогармым. еще раз скажу если 
моя прогармма никак не анализурует код возврата
у read() то  все как работало так и будет работать!

еще раз.
я могу нажать 100 раз на ctrl+d 
и моя прорамма получит 0 в коде возврата read()
ну и все как работало так и продожит рабтаьт.
я могу далше споокойно тыкать кнопки.  и нажмать
enter и эти все буквы будут и дальше удачно
падать в мое приолжение.
НИЧЕГО ОСОБОГО!


* еще момент
оказывается если я выключаю канончиский режим
тоест делаю его неканоническим то! при нажатии на
ctrl+C у меня tty driver прекращает посылаьт SIGINT
процессу который сидит за ним! ВАУ!
а вместо этого ттай дарвер просто шлет 0x03 (ETX ASCII) юзер приоложению. а оно уже как хочет 
так и реагирует. 
так что ctrl+c работает как мы привыкли тольок
в канничском режиме!



а вот еше отлчное описние как рабатет какнон
и неканон режимы в плане ттай драйвера 
взял из man termios


In canonical mode:

•  Input is made available line by line.  An input line is available when one of the line  delim‐
iters  is  typed (NL, EOL, EOL2; or EOF at the start of line).  Except in the case of EOF, the
line delimiter is included in the buffer returned by read(2).

•  Line editing is enabled (ERASE, KILL; and if the IEXTEN flag is set: WERASE, REPRINT,  LNEXT).
A  read(2)  returns  at  most one line of input; if the read(2) requested fewer bytes than are
available in the current line of input, then only as many bytes as requested are read, and the
remaining characters will be available for a future read(2).

•  The maximum line length is 4096 chars (including the  terminating  newline  character);  lines
longer than 4096 chars are truncated.  After 4095 characters, input processing (e.g., ISIG and
ECHO*  processing)  continues, but any input data after 4095 characters up to (but not includ‐
ing) any terminating newline is discarded.  This ensures that the terminal can always  receive
more input until at least one line can be read.



 In  noncanonical  mode input is available immediately (without the user having to type a line-de‐
 limiter character), no input processing is performed, and line editing  is  disabled.   The  read
 buffer  will  only accept 4095 chars; this provides the necessary space for a newline char if the
 input mode is switched to canonical.  The settings of MIN (c_cc[VMIN]) and TIME (c_cc[VTIME]) de‐
 termine the circumstances in which a read(2) completes; there are four distinct cases:


хочу пдодчеркнуть что MIN и TIME имеют силу ТОЛЬКО
еси у нас активаовано НЕКАНОН режим!!!! в каон
режиме они нкиакой силы НЕИМЕЮТ!

далее в man termios рамсыаются  детали то как
влияют MIN TIME в нкакничсочеком режиме! читай
в man termios . там просто большая портянка
я ее не сталю сюда вствлять!





* насчет EOF у glibc

мы дошли до этой темы.
если я програмирую на СИ. 
и если я в тексте своей программы считвают данные
из какого нибудь файла а точнее из файла который
смотрит на терминал 

   /dev/tty2
   /dev/pts/10

и если я читаю из этих файлов не через 

  read()

а через GLIBC функции такие как напрмиер fgetc()
то эта фнукия явлется оберткой вокруг сисколаа read()
и она повряет его код возврата. и если он равен НОЛЬ
то она уже в своем коде воврзрата нам возращает 
код возрата в виде не числа а макроса EOF котрый
по факту равен -1. но в мире байтов не бывает 
никаких -1. у нас fgetc() у него не так как у read()
ест прееменная куда он кирует байты а есть код
возврата о статусе у fegetc() у него код врзрата
возращает либо сам байт считанный из СТРИМА (где
стрим это всего навсего поинтер на структуру в
памти проесаа которую сосздает сам глибси код который
встраиется в наш код . это буфер в памяти куда 
он кпирет данные из /dev/fd/0) 
так вот fgect() он в коде взращает либо сам 
байт считаный либо в случае если read() возрващает
ноль то он тогда возварщает в коде воазрвата EOF
. так как код возравта у fgetc() это INT тоест 
4 байта то EOF=-1 это по факту байты вида 0xFFFFFFFF

ИТАк EOF это макрос. который по факту это много байто
вая хрень. 0xFFFFFFFF 
логика тут такая - fgetc() он читает ровно 1 байт
из файла и возвраащает его нам в коде возврата.
его код возарата 4 байта длиной. 
если это реально байт из файла то понтное дело
что тогда весь код возрата должен выглять как

  0x000000NM

тоесть младший байт этой мого байтовой хрени
содержит байт ситанный из файла. а все осталное
ноль байты. если же прооизшла ккаято ошибка
или read() вернул НОЛЬ что значит файл законился
а если это терминал то юзер нажал CTRL+D если
мы сидим в каночесом режиме. 

кстати! если мы сидим в канонич реиме значит
если мы тыкнм Ctrl+D то ттай драйвер небудет
вставлять в буфер 0x04 но разбулит read() и если
в буфере было ноль батов то код водврата в 
read() будет 0 так вот  fgetc() он анаизирует
этот код возварта и елси он ноль то  fgetc() уже 
в своем коде врвзрата возврщаает EOF тоесть 0xFFFFFFFF
НО! также если мы работаем в неканчиесоком реиме
и тыкаем ctrl+d то ттай драйвер уже не парится
если мы тынкули ctrl+d он просто сует этот 0х04
в буфер и будит read() таким образом в fgetc()
прилетает байт 0х04 так вот! я проерил эта
фунци fgetc() она уманя! она понимает что раз
прилеетл 0x04 то  значит мы нажали ctrl+D и 
она тоже возращает в своем коде возврата EOF!!!
вот это прикл! тоесть fgetc() она коректно умеет
распознать нажатие ctrl+D как в канончиском
режиме так и в неканончсикоем!!!! приколно!

EOF тость 0xFFFFFFFF это пдумака чисто глибц 
фунций которые явялются обертккой вокруг сисколла
read() если они видят что он возвратил 0 в коде
возрата либо если он выдал нам код 0x04 уже в 
самих данных то глбиьц фунуции такие как fgetc()
уже в своем коде взарта в нашу прогармму возвращает
байты 0xFFFFFFFF которые обозначаются макросом EOF
само ядро в коде возрата read() никкакого EOF 
иои 0xFFFFFFFF невозращает!!! это надо понять!

 написал прогу 

  429.c

в ней мжно устанвить каоннчсикий режим для
терминала и неканончический

вот эти строки

    // Выключаем канонический режим (если он был выключен)
    term.c_lflag |= ~ICANON;
//     term.c_lflag |= ICANON;



просто выбери какую строку оставить.
так вот - сам fgetc() он читаем один байт из 
СТРИМА! стрим это буфер в паяти процесса который
ораганизуется силами глибц функций.
когда я вызывают fgetc() то за кадром
вызыется сисколл read()
котоырй пытается прочитать из fd/0 сразу 1024
байта
  
  read(0,..,1024)

а уже потом из этого буфера fgetc() заберет один
байт и вернет нам в коде возврата в виде int (4 байта)
в самом младщем его байте! о ккак хиттро!

что это дает?

дает это вот что. если мы запустили в канончиском
режиме. то ттай дайрвер копить наши символы
пока мы ненажемем энтенр. только потом он разубудит
read()

так вот мы тыкаем скажем пять кнопока. потом
нажыаем enter.

у нас 5 байтов будет считано read() в СТРИМ.

так как у меня цикл стоит впрограме

  while(1){
    
    fgetc()
 }


то у нас все пять символов будут считаны из СТРИМА!
ничего не потярется!

бует выглядть это вот так на экране


$ ./429.exe
12345

я получил символ! = 1

я получил символ! = 2

я получил символ! = 3

я получил символ! = 4

я получил символ! = 5

я получил символ! = 


тоесть я тыкнул на клаве 12345'Enter'
после этого в буфере ттай драйвера окаазадись
эти кнопки и они были считаны чрез 

  read(0,,,,,1024)

который зарядил наш глибс. и попали в СТРИМ.

далее цикл 

while{
  
  fgetc()
}

который читает из этого стрима (поинтера)
он выводит 12345 и пустой символ. отому что это 
символ 0А который засунул ттай драйвер  в буфер
на нажатие Ентер. так как fgetc() это глибц фуция
и читает он не из fd/0 а из поинтера стрима то 
он видимо знает сколько байт там было запсано
до этого другой глибц функцией! возможно глибц
фуцния котоорые пуляла read() она дбавляет в конце
0х00 чтобы fgecc() знала где конце данных в этом
стриме!

то есть еще раз!


я запуска погу. она крутит рермиал и выставляет
ттай драйвер в каноникал режим. 
глибц фнуция (какая я езнаю но она есть незримов
коде моей прграмы) пуляет сискол 




   read(0,...., 1024)

повтряю она пулчет его сама  . это не я так делаю.

ттай дрйвер сует этот рид в слип. 
мы тцкаем кнопки 1245 и Enter.
ттай дрвер сует в буфер 
 

  12345 0А


и будит read()

он это копрует куда то в памят моего процесса
в поинтер *stdin который зовется СТРИМ
и както там помечает конец блока данных вдимо
вот так 

 *stdin = 12345 0A 00

далее в явном виде запусктеся fgetc() 
котоырй лезет не в /fd/0 а лезевт в стрим *stdin
и читае оттуда один байт 

  '1'

и выдает его мне.
у меня fgets() стоит в цикле поэтмоу 
я его еще раз запускаю.

виидимо fgetc() ставит какоуто курсор в этом
стриме потому что в следующий раз он уже возра
щает 

  '2'

итд вплоть до 0a который он тоже возращает.

в конце концов он останалиется потому что видиом
напарывается в этом поинтере на 0х00 котрый
ему гворит о том что дальше данных бльше нет.

после этого  неявная глибц фунцию опять 
пуляет новый сисколл

 read(0,....., 1024)


возможно это все вшитов внутри fgetc()

но очегнь познавательно!

тоесть данные приелтают во внутренний буфер 
внутри процесса(в стрим как они говрят)  и потом
их оттуда вычерпывает fgetc() 

в итоег в канон режиме все выглядит вот так

$ ./429.exe
12244

я получил символ! = 1

я получил символ! = 2

я получил символ! = 2

я получил символ! = 4

я получил символ! = 4

я получил символ! = 



а если я запущу в НЕКАНОН режиме. то все 
выгдяит вот так

$ ./429.exe

я получил символ! = 1

я получил символ! = 2

я получил символ! = 3

я получил символ! = 4

я получил символ! = 5

я получил символ! = 6

я получил Ctrl+C!: Success



ращница получется в том что  в канон режиме
я тыкаю пноки и они неулетают в стрим моей памят.
потом я ткываю етнер и целая пачка байтов улетает
в буфер.

а некаон режиме кода я тыкаю кнопку то она
мгвнеоее передается дальше в юзер процесс.
поэтмоу мы сразу вдим отклик на экране!


в любом случае эта глава была посвяшена
что такое EOF как он поулчается с чем его 
едят.



если у меня какон режим то ctrl+d деает то что
ттай драйвер непшиет 0х04 в буфер и взывает read() 
и если в буфере было пусто то red() вернет 0.
и fgetc() анадизиуерет код возврата у read() 
и он понимает что был нжат ктрд-д и он уже в нашу
прогу вернет 0xFFFFFFFF который через макрос EOF 
зовется. по факту он мог бы выернуть любое
двухбайтовую хрень. потому что по опредеделению
fgtec() он чиатет из стрмиа только один байт згачит
признаком того что в его овтете ест живой байт
это то что его ответ выглядит вот так

  0x000000NM

а если он веренет чтот длинее чем 1 байт
типа

 0x0000A1NM

о это уже точно признако какойто проблемы.
в глблиц выбрали что в сулчае 0 у read() они
уже нам в коде возварта возвараащают 0xFFFFFFFF
и зауввуалирвали это макросом EOF

если же у нам неканон режим и мы тцкаем ctrl+d
то ттай драйвер сует 0х04 в буфер и будит read()
это батйт 0х04 прибывает вньутрь нашей прогармммы
и что приклночто fgetc() понимает что если приелетл
0x04 то это тоже значит что cttral+d был нажать.


вот такой пзздаац.


в заклюечении воможно повтор мыслей выше

 контрольный символ 0xA0 он имеет двояукую 
   роль с одной стороны он влияет как сигнал 
   от терминала(юзера) к tty driver о том что 
   юзер прекратил редактировать строку и требует
   от ттай  дайрвера чтобы он ее передал башу.
   (какнончиеский режим по своей природе имеет 
   вот какую цель - ттай драйвер выступает как 
   редактор текста . тоест юзер приожению ненужно
   в себе иметь код по редактированию линии. это 
   все ложиться на ттай драйвер.) тоесть А0 это
   сигнал к ттай драйверу.  но также этот же байт
   влияет ина дислей. если этот байт влетает в 
   дислпей то он ему укзывает что в этом месте
   дисплей должен перенести курсор и текст
   который далее влетит в дислей нужно печатть 
   с новой строки. поэтому А0 он сохранется
   в тексте. 



