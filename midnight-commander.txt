mc

у mc процесса открыто устройствао /dev/tty


процесс fd ---> syscall ядро --> из памяти процесса вставляет в усторсовт терминал -->  (терминал)

и вот то что будет "показано" на терминале можно перехватить прочитав в  /dev/tty
и неважно какой терминал открыт у процесса tty типа или pts типа




===
//в чем прикол про сокет. процесс открывает его. чтобы другие процессы 
могли общаться с нашим процессом. и фишка в том что у сокета нет второго конца
скажем как у пайпа. тоесть это не точка точка. это как приемная в горсовете.
процесс открывает сокет чтобы другие могли в этот сокет написать пообщаться
с этим процессом. тоесть сокет (который не сетевой а unix domain) он не ведет никуда
точнее он ведет в наш же процесс в отличие от пайпа котоорый ведет куда то 
наружу (написать бы прогамму которая открывает сокет а вторая на этот сокет 
чтото там пищет а наша принимает и печаатает на экран)
поэтому коода наша си програма открыла граф окно. и у нее открыт сокет это значит
чтобы как  понимаю ктото другой снаружи мог на него постучать а не чтбы
наша программа через этот сокет комуто куда то стучала

процесс который создал граф окно. он видимо както регситрутется на X11. и отркывает у себя
сокет и сиди его слушает. и X11 если я меняю вид окна то x11 шлет этой проге
мессаги в сокет! из сокета процесс узнает о событиях в своем окне

xterm тоже получается инфо об окне из сокета! теперь понятно. 

получаетс экрран это как жесткий диск. xterm пишет в сокет. но он наверное пишет 
толко тгда кода кдтиент x11 пдклчтлся к сокету. пишет в ответ. 
типа мы выдели окно. и нажали кнопку и эту инфо x11 через сокет шлет 
термиалу. а терминл в ответ шлет чо надо рисовать в окне. 
и xerm тгда чеерз /dev/pts/17 шлет кнопку в баш. баш ответчает через pts/17
оно пртилетает в xterm через /dev/ptmx ,
вопрос как xterm инициирует сам конект к X11 чтоы педать ответ от баша на экран.
потому что кроеме как xterm больше ниу кого этот сокет не открыт. вот что стремно.

а так в целом схема тккая

экран окно == x11 == сокет === xerm == ptmx\pts == bash

unix domain socket - нужна пример программа



//
я сделал эксперимент я открыл xterm в нем автоматом открылся bash и далее 
свою програму thread3.exe
далее я тыкаю Ctrl и мышь вылезает меню. это меню от xterm

там есть послать сигнал. я его шлю. при этом стрейсом ловлю в процессе xterm
kill(-4374, SIGINT)                     = 0
kill(-4374, SIGINT)                     = 0
kill(-4374, SIGINT)                     = 0
kill(-4374, SIGINT)                     = 0
kill(-4374, SIGINT)                     = 0

тоесть это он шлет.

при этом ловлю баше 
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=4372, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=4372, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=4372, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=4372, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=4372, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=4372, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=4372, si_uid=1000} ---

чтеко видим что истточник сиганла процесс 4372(xterm)

при этом в thrad3.exe ничего не ловлю.
потому что очеимвдно что навено bash и thread3 не входят в одну группу? потомк
что -4374 это пид баша. и это посыл в группу в которой программы в сбашем состоят?

вот как в kill написано
Negative PID values may be used to choose whole process  groups
see the PGID column in ps command output

в man ps написано что pgid и pgrp это одно итоже

$ ps o pid,pgid,pgrp,cmd -p 25204,25245,25488
  PID  PGID  PGRP CMD
25204 25204 25204 xterm
25245 25245 25245 bash
25488 25488 25488 sleep 120

как видно почемуто sleep запущенный из баша имеет уже другой pgid
поэтоум если я тыкаю в xterm "send sigterm сигал" он его шлет вот так

kill(-25245, SIGTERM)

тоесть он его шлет группе процессов баша.
так как sleep (котоыйр я запути из баша ) имеет другой pgid то он его не полчает!
полкчает только баш!

так вот я что обнуарружил. ели я тыкаю Ctrl+лева кнокп мыкши. и выбивараю "send signal"
то это приводит  ктому что сам xterm процесс шлет сигнал через kill. 

а если я в окне нажму Ctrl+C то сигал шлет само ядро! причем шлет оно 
его именно тому процессу который щас и работает на терминале последним!
кстатимна счет групп нашел вот такое у баша
setpgid(7061, 7061)


если открыть gnometerminal + bash
и стрейс баша strace -p 7043 2>&1 | grep signo
и тыкат Ctrl+C
--- SIGWINCH {si_signo=SIGWINCH, si_code=SI_KERNEL} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=7043, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=7043, si_uid=1000} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=7043, si_uid=1000} ---
--- SIGIN

то четкко видно что инициалтором сигнала явялется ядро!
а уже потом баш (7043) сам себе шлет сигна!

да!
--- SIGINT {si_signo=SIGINT, si_code=SI_KERNEL} ---
kill(7043, SIGINT)                      = 0
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=7043, si_uid=1000} ---

сигнал от ядра. а потом баш сам себе шлет сигнал повторно!

вопосы - 1)почему ядро нанажатие ctrl+C в граф окне шлет сигнал sigin?
         2) как ядро определяет тот самый процесс котоырй шас висит в терминале?

на второй поврос оказывает  у процесса есть свйоства "terminal foreground process group"
проверяется и выстваляется через

       pid_t tcgetpgrp(int fd);
       int tcsetpgrp(int fd, pid_t pgrp);

еще есть ioctl TIOCSPGRP 
котоыйр с этм связан.
дальше вот что - если процесс имеет связь с терминалом тоест файлы откртые pts/N
и он пробует читаьт или писать с этих файлов тоесть полуать ломить на терминал
то окзывается что у термринала (видимо куско ядра потому что сам теринал это тупая железка)
есть контолль доступа. у процесса есть свойство TPGID
читбаю в man ps
       tpgid       TPGID     ID of the foreground process group on the tty (terminal) that the process is connected to, or -1 if the process is not
                             connected to a tty.

котоорое обозначает "foreground" группу для терминала. и ТОЛЬКО процессы которые входят
в эту группу имеют право читать и писать в терминал!!!!
(так кстати работают загадоные джобы в баше).
ткже как я понял если мы из теримнала шлем Ctrl+C или Ctrl+Z то ядро шлет 
этот сигнал только процессам которые входят в форегрунд группу териминала! охренеть!

когда я зваупскаю в баше процесс в фореграунден то  PID этого нового 
процесса становится TPGID для всех процессов заупущенных из баша

$ ps -o pid,tpgid,sess,cmd -p 26599,29139,23126,13633
  PID TPGID  SESS CMD
13633 13633 26599 sleep 320    <=== вот этот процесс щас активен в терминале
23126 13633 26599 sleep 300
26599 13633 26599 bash
29139 13633 26599 sleep 11121112


насколко я понял только один процесс может нахоится в форегрунд группе (нахйй тогда 
они ее группой назвали? ес там 1 чел макс)

pgrp=pgid это процесс группа. ее смысл только в том что можно чере killpg() послать
сигнал всей группе!

несколко групп могуь входит в состав сессии. сессия это уже хрень связанная 
стерминалом

сессия может имет приркрепленный к нет терминал или нет.
у сессии уже есть свйоство  форегруаунд группа
в чем же прикол этой группы? а вот в чем
This is the group to which a signal will be sent if generated by the terminal (e.g. SIGINT in response to CTRL-C or SIGTSTOP in response to CTRL-Z). Also, only processes within the foreground group can read from the terminal.

получется коода с терминала летят кнопки в ядро  ау нас куча прцоессов котоыре 
прикелны к терминалу то ядро знает что кноки надо слать именно процесу который
входит сессию связанную с этим терминалом в процесс которй в ее форегрунед групп!
(поэтому ctrl+c когда я заупстл xerm+bash+sleep пошел от ядра к sleep!)

есть еще session leaer процесс. 
The session leader is also the process to receive a SIGHUP if the controlling terminal for the session is closed

а вот я нашел в 
man setpgrp


 A child created via fork(2) inherits its parent's process group ID.  The PGID is preserved across an execve(2).

       Each process group is a member of a session and each process is a member of the session of which its process  group  is  a  member.   (See  creden‐
       tials(7).)

       A  session  can  have  a  controlling terminal.  At any time, one (and only one) of the process groups in the session can be the foreground process
       group for the terminal; the remaining process groups are in the background.  If a signal is generated from the terminal (e.g., typing the interrupt
       key  to  generate  SIGINT), that signal is sent to the foreground process group.  (See termios(3) for a description of the characters that generate
       signals.)  Only the foreground process group may read(2) from the terminal; if a background process group tries to read(2) from the terminal,  then
       the  group  is  sent  a  SIGTTIN signal, which suspends it.  The tcgetpgrp(3) and tcsetpgrp(3) functions are used to get/set the foreground process
       group of the controlling terminal.

       The setpgid() and getpgrp() calls are used by programs such as bash(1) to create process groups in order to implement shell job control.

       If the termination of a process causes a process group to become orphaned, and if any member of the newly orphaned process group is stopped, then a
       SIGHUP  signal  followed by a SIGCONT signal will be sent to each process in the newly orphaned process group.  An orphaned process group is one in
       which the parent of every member of process group is either itself also a member of the process group or is a member of a process group in  a  dif‐
       ferent session (see also credentials(7)).


pgid=pgrp в ps



насколько я понял у самого рцоесса есть тлько GID - это группа связнаная  с файлоовой
сситемоей.
есть PGID - это группа процессов.

есть SID - это сеессия

но у прцоесса нихуя нет TPGID! это хрень устанавливется на терминал!тоеть привзктся
к терминалу! а не процссу!  а если процесс стчитс ня этот терминал то ядро срванивет
pgid процесса и TPGID теримнала. если оно совпдаатет то процессу можно чиатть писать
на этот терминал! и ps когда покывзает 


$ ps -o pid,tpgid,sess,cmd -p 26599,29139,23126,13633
  PID TPGID  SESS CMD
13633 13633 26599 sleep 320    <=== вот этот процесс щас активен в терминале
23126 13633 26599 sleep 300
26599 13633 26599 bash
29139 13633 26599 sleep 11121112


то как я пнимаю TPGID он вычисляет ! а миенно он берет сессию. к которому
поключена сесссия. видлимо делает к нему запрос. получем TPGID а потом пририсвовыет ко
всем пцроссам сидящим в одной сеиссиисука! у саомого процесса такоого свофства нет!!


вот пример

$ ps -A -o sess,tty,tpgid,pid,pgid,cmd --sort sess | grep -E "CMD|pts/85"

 SESS TT       TPGID   PID  PGID CMD
10848 pts/85   18518 10848 10848 bash
10848 pts/85   18518 18518 18518 sudo strace -p 7043
10848 pts/85   18518 18519 18518 grep --color=auto -i -E signo|kill
10848 pts/85   18518 18523 18518 strace -p 7043


вот  у нас одна ссессия . у нее один термрианал. у терминала одна форегрунд груупа TPGID
куча pid, один PGID (ну это ксати не всегда один )

смотрим какойй TPGID и сразу понимаем какой pid читает и пишет в терминл! 18518!
осаттальным нельзя!

с xterm интересно

$ pstree -Aspt 29373
systemd(1)---xterm(29373)---bash(29377)---mc(30646)


$ ps  -o sess,tty,tpgid,pid,pgid,cmd --sort sess  -p 29373,29377,30646
 SESS TT       TPGID   PID  PGID CMD
 3926 ?           -1 29373  3926 xterm
29377 pts/53   30646 29377 29377 bash
29377 pts/53   30646 30646 30646 mc -u


что значит в свойствах процесса есть tty? это значит что даный процесс подключен
к удаленному терминалу! не сам процесс является терминалом а он подклвен к удаленному
терминалу! 
видно что у xterm не свойства  термиала. правлно! потому что он сам терминал!
и tpgid=-1 потому что он не подключен ни к какому теримналу!
а вот два процесса которые он породил он уже подкобчены к удаленнму терминалу! 
к xterm! точнее его /dev/ptmx
 у них одна сессия. и tpgid покаызвает что чтать присать разрещно для mc -u 
 а баш должен сидеть молча!

 вот что странно.

вот  унасдвп процесса в терминале. один fg второй bg.
оба имеют pts/12

у процесса есть fd =3 если прцеосс через сисколл
напишет хей ядро запиши 14 в fd=3 . то ядро возьмем 14 и пошлет к мастеру деражеталю
терминала. (то бишь на терминал!) так вот если это попытается сделать bg процесс
то от ядра к нему сразу прилетит сигнал (щас не понмю какой) щас проверю <==
это я запустил в форегрунд

$ ps  -o sess,tty,tpgid,pid,pgid,cmd --sort sess  -p 20223,20262,22851
 SESS TT       TPGID   PID  PGID CMD
 4363 pts/79   20223 20223 20223 xterm  
20262 pts/87   22851 20262 20262 bash
20262 pts/87   22851 22851 22851 ./165.exe

 xterm имеет tty это начит что я его заупстил из дргого теприминала

 TPGID =22851 значит 165.exe срет в терминал

 тепрь 165.exe я заустил в бекгрунд реиме

 $ ps  -o sess,tty,tpgid,pid,pgid,cmd --sort sess  -p 20223,20262,11090
 SESS TT       TPGID   PID  PGID CMD
 4363 pts/79   20223 20223 20223 xterm
20262 pts/87   20262 11090 11090 ./165.exe
20262 pts/87   20262 20262 20262 bash

теперь баш имеет право чиать и пиасть в терминал

потмо я зпупсьил +1 бг процесс. 166.exe
тгда миеем

$ ps  -o sess,tty,tpgid,pid,pgid,cmd --sort sess  -p 20223,20262,11090,27156
 SESS TT       TPGID   PID  PGID CMD
 4363 pts/79   20223 20223 20223 xterm
20262 pts/87   20262 11090 11090 ./165.exe
20262 pts/87   20262 20262 20262 bash
20262 pts/87   20262 27156 27156 ./166.exe

значит процсс 165 он на эаркне рисует "..."
а пцросс 166 на кране ррсует "+++"

в иоге я вжу на экране
...
+++
...
+++

то ест я хочу скзаать что если прцоесс в БЭКГРРАУНД режиме то ему МОЖНО писать 
на терминал! ему нельзя чиатть с терминала! щас я это поймаю!


165.c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>



int main()
{

      pid_t pid = getpid();
      printf("pid = %u\n", pid);

   while(1)
   {

      printf( "...\n"  );      
      sleep(3);
   }
   return EXIT_SUCCESS;
}



166.c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>



int main()
{

      pid_t pid = getpid();
      printf("pid = %u\n", pid);

   while(1)
   {

      printf( "+++\n"  );      
      sleep(3);
   }
   return EXIT_SUCCESS;
}




и вот такая програмаа

[vasya@lenovo C]$ cat 167.c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>



int main()
{

      pid_t pid = getpid();
      printf("pid = %u\n", pid);
      int t = 30;

   for(int w=0; w<t; w++)
   {

      printf( "---\n"  );      
      sleep(3);
   }



    int klava = 0;

    void * bufer;
    char k[1];
    bufer = &k;

    printf ( "void address = %p\n", bufer );

    size_t count;
    count = 1;

    read( klava, bufer, count);



   printf ( "ti vvel s klavi %c\n", *(char *) bufer );

   char * vasya;
   vasya = (char *) bufer;

   printf ( "ti vvel s klavi %c\n", *vasya );


   return EXIT_SUCCESS;
}




$ ps  -o sess,tty,tpgid,pid,stat,pgid,cmd --sort sess  -p 20223,20262,11090,27156,4178
 SESS TT       TPGID   PID STAT  PGID CMD
 4363 pts/79   20223 20223 S+   20223 xterm
20262 pts/87   20262  4178 t     4178 ./167.exe
20262 pts/87   20262 11090 S    11090 ./165.exe
20262 pts/87   20262 20262 Ss+  20262 bash
20262 pts/87   20262 27156 S    27156 ./166.exe

и когда 167.exe поптаылся прочитаь с терминал файла (fd=0)  /pts/87
то ЯДРО послало ему сигнал SIGTTIN


пришлос заново пресзоазть сттенд


$ ps  -o sess,tty,tpgid,pid,stat,pgid,cmd --sort sess  -p 18966,19079,20012,23202,21753
 SESS TT       TPGID   PID STAT  PGID CMD
19079 pts/102  19079 19079 Ss+  19079 bash
19079 pts/102  19079 20012 S    20012 ./165.exe
19079 pts/102  19079 21753 S    21753 ./167.exe
19079 pts/102  19079 23202 S    23202 ./166.exe


когда 167.exe (21753) попытался считать с терминала то 
ядро ему послало SIGTTIN

[pid 21753] --- SIGTTIN {si_signo=SIGTTIN, si_code=SI_KERNEL} ---

и также от ядра прилетело в парент процесс баш у котого 167.exe явялется
чайодом сигнал SIGCHLD

[pid 19079] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_STOPPED, si_pid=21753, si_uid=1000, si_status=SIGTTIN, si_utime=0, si_stime=0} ---

пркольно что в si_code уже не пиется SI_KERNEL хотя инфитатором сиганла явлется именнло
кернел!

и все процесс 167.exe был шедулером или кусоком ядра перевдене в сосотоние t

]$ ps  -o sess,tty,tpgid,pid,stat,pgid,cmd --sort sess  -p 18966,19079,20012,23202,21753
 SESS TT       TPGID   PID STAT  PGID CMD
19079 pts/102  19079 19079 Ss+  19079 bash
19079 pts/102  19079 20012 S    20012 ./165.exe
19079 pts/102  19079 21753 t    21753 ./167.exe
19079 pts/102  19079 23202 S    23202 ./166.exe

в man 7 signal напиано
 SIGTTIN   21,21,26    Stop    Terminal input for background process

 дураукое обяснеие! надо догадсяь что он знаит что прцоесс из беккграуднд темриал
 группы попытался прочитать с терминала. ну а "t" значит застоплен видимо!

 термианал это не черное граф окно на экране. терминал это вирт хрент в памяти
 ядра. которая в юзерспейс выходит через /dev/ptmx и /dev/pts/10 !!

Наконец  я погял с сигналом SIGHUP!!!
я запускаю xterm. он запускает баш. и он открывает в ядре терминал. терминал
сидит в ядре. не в процессе!
один конец мастер конец /dev/ptmx уходит в xterm
второй конец слейв уходит в bash.
далее я в баш через exec запустил sleeepp 1000000
итак у нас схема

xterm --- sleep

далее в xterm шлю SIGTERM сигнал. и да в него этот сигнал прилетает.и он заканвчивает
свою работу. при заканчивании работы у нас всегда закрываются fd дескрпиторы.
ядро это видит. видит что закрывается мастер конец терминала. 
и ТОГДА САМО ЯДРО шлет в процессс sleep сигнал SIGHUP!!

тоесть sighup это сигнал который шлет само ядро всем слейв процессам 
сообщая им этим сигналом что  мастер процесс который держал мастер конец
терминала он сдох. и мастер конец закрыт. вот что значит этоти сигнал и кому он шлется
и когда и зачем! он охгачает что если sleep будет чтото посылать в /dev/pts/10
то эта информация уже никуда не улетит! принимать некому! и еси он будет читать из pts/10
то ничего не считается потому что отравлять нееому!!! вот что и зачем и когда и почему
у SIGHUP!

кстаи схема рабты xterm 


черное окно X11 на экране --- ядро ---- (socket)xterm (ptmx) ----- ядро ---- (pts/10) (bash)


тоесть баш пишет в свой fd/0 который нпавлен в pts/10 это идет в ядро.
ядро это пишет в /dev/ptmx которо идет в fd/0 xxterm. он это пишет в socket 
из сокета в ядро. из ядра в черное окно на экране!

тоже самое про наоорот

клава --- ядро ---- (socket)xterm (ptmx) ----- ядро ---- (pts/10) (bash)


мы тыкаем кнопку.  драйвер ловит. это летит в socket xterm. он это шлет в fd/1 
котрое pmtx оно летит в ядро. ядро это шлет в pts/10 эт олетит в fd/0 у баша. все 
баш принял кнопку!


 я так понимаю xerm когда ывзывает ioctl по имзмнеею паратртмо теримнала
 то меняется просто напросто найстройка внутри ядра того куска который обслуживает
 внутри ядра программу "вирт терминал". тоест эт не меняет насйроки ни xter процесса
 ни bash мпроцесса. это меняет настроки модуля ядра "термианал".  я бы скаал
 чт это ывыглдяит так

 xterm (ptmx) --------- (ядро, модуль терминал) -------------/dev/pts/10 (bash)

я так думаю что если я создам процгирамм которая отрывает ptmx (<<<<<==== надо сделать!)
и потом открою баш. ему дам /pts/10 и потом если я в своей программе сделаю close(fd=3=ptmx)
то ядро сразу же башу пошлет SIGGUP сигнал!!!!!!
потмуо то видимо закрытие ptmx влечет что в ядре унитожчется инстанс теримнала который
лсбудиивал этттт ptmx!!!
так чт закртие ptmx файла влечет посылку SIGHUP сигнала от ядра все слейв процессам! сразуже!

ксати вот есть процесс gnome-terminal-server
это тот самый гном терминал. когда мы его тыкаем то схема такая



черное окно X11 на экране --- ядро ---- (socket)gnome-ter (ptmx) ----- ядро ---- (pts/10) (bash)

возникает вопрос мы же в гном терминал отрквыем кучу окон. в них баш.
сколько при это ptmx у этого прцоесса? ответ - вот ронвно соклько мы окон в гном 
терминал откроем на каждое отыветя новый +1 fd дескриптор который вдеет в ptmx
тоест

вот у нас деревро для гном теримлала

[vasya@lenovo C]$ pstree -AspT 4423 | grep bash
----------------------...----gnome-terminal-(4423)-+-bash(389)---man(23538)-+-man(23567)
                                                   |-bash(1446)-+-grep(14934)
                                                   |-bash(2158)---man(2415)---pager(2425)
                                                   |-bash(2170)---mc(2432)---bash(2434)
                                                   |-bash(2502)
                                                   |-bash(3328)---mc(4186)---bash(4188)
                                                   |-bash(4363)
                                                   |-bash(4387)
                                                   |-bash(4437)
                                                   |-bash(4457)---lx
                                                   ...
                                                   ...



а вот у нас солько дескрипторпо ведещих на ptmx открыто у гном терминал проецесса
]$ ls -1al /proc/4423/fd | grep ptmx
lrwx------ 1 vasya vasya 64 мая  5 18:36 100 -> /dev/ptmx
lrwx------ 1 vasya vasya 64 мая  5 18:36 13 -> /dev/ptmx
lrwx------ 1 vasya vasya 64 мая  5 18:36 16 -> /dev/ptmx
lrwx------ 1 vasya vasya 64 мая  5 18:36 17 -> /dev/ptmx
lrwx------ 1 vasya vasya 64 мая  5 18:36 18 -> /dev/ptmx
lrwx------ 1 vasya vasya 64 мая  5 18:36 19 -> /dev/ptmx
...
...

я посчитал сколко башей (окон) у нас открыто в гном терминал. солко у него чайдлов
$ pstree -AspT 4423 | grep bash | wc -l
79

и вот сколько же декприоров ведущих на ptmx у него же открыто
$ ls -1al /proc/4423/fd | grep ptmx | wc -l
79

тоесть все совпдает до коейпейки!

создание нового вирт темринала в ядре требует откртыий нового ptmx
тоесть создаетяся в умастер процесса новый fd/X дескрпор ведущий на ptmx
и сздание нвоого pts/N файла котоырй уже собщается слейв проессу.
ну и уже после этого гном терминал чрез сокет стучится на X11 и созает там +1 гравф окно!
еслия заорою процесс гном-ьеомнал-сервер то он закровет при выходе все  ptmx
файлы. и на это ядро разушит в ядр памяти все коепии вир т терминала. и ядро
разошлет все процессам слейв у которых был этот терминал сигна SIGHUP.
для слейы впроецесаса. это означает что "термиал которому вы бвли подключены разрушен!"
вотакак оно!!!


//
так   я вот что хотел добавит про терминалы.
вот у нас есть процессы которые сидят все на одной сессии то есть привзныве
к одному терминалу. просто какието входят в бэкграунд группу а ккакотой
прцоесс входит в форегрануд группу. и получается что если процесс в бекграунд группе
попруобет чиатть из fd/0 ---> pts/10 то ядро тутже его зактнет и пошлет SIGTTIN 
котоый этот роцесс застопит. зато можно взят другой прцоесс который подключен
к другому терминалу pts/11 и без прблем начать чиатть чужой pts/10!! и ядрл
ему нихрена ну будет послыать SIGTITIN!!!
прикол!

//
цитирую книжку "Linux programming interface" (LPI)
ив ней 
The key point about a pseudoterminal is that the slave device appears just like a
standard terminal. All of the operations that can be applied to a terminal device
can also be applied to a pseudoterminal slave device. Some of these operations
aren’t meaningful for a pseudoterminal (e.g., setting the terminal line speed or parity),
but that’s okay, because the pseudoterminal slave silently ignores them

так вот я очу сказать что это терминлогия это хуйня. под слев девайсом подрузмевается
файл pts/10
так вот сам файл нихуя ниакикм терминад девайсом не является! это кусок ядра который
сидит за этим файлом он и явелястея "термриналом"! над котрым можно выполгнять вяские
операции поылая их в файл pts/10
тоесть не файл является терминалом. он лиш проводиник. терминало явялется модуль
ядра который сидит где тотам по ту строону!
если процесс имееет откррыйт pts/10 то это знчит что к даному процессу
подключен удаленный терминал! котрыйрый с этим проессом имеем связь чеерзе файл pts/10
тоесть ни процесс не явялется терминалом. ни файл pts/10 не является терминалом!
терминаом явялется кусок ядра который сидит в ядре за этим файлом! процесс это как 
бы сервер чтоли. а файл явлется интерфейсом доступа терминала к прцоессу. фишка 
в том что не процесс ломится на терминал! а темринало обычно ломится на процесс!
не процсс клиент (или слейв)  а термина клиент. а серввер это процесс! мы смидя 
за теоминалом хотим заделезть внутрь процесса. посмотреть чо там. и нам терминал
как микрсокоп позвяеолт зануллянуть в нутро процесса. через интерйфейс файл pts/10 !
другое дело что так как терминад это код ядара а не железа то из этого термиала идет
второй провод к другому процеассу! который общается через ядро-терминал с тем 
процессом а нам уже на эакрне через сокет и лкиент X11 рисует картинкт что он 
там увидел на том процесс! вот такая непростая система!
точно также как /dev/sda это еще не железка ,не жесткий диск. это всего навсего 
ссылка за которой сидит жесткие диск.
которую если в сисколле указать то ядро поймет что мы хотим получить
доступ к железке. также и pts/10 это не терминал. это ссылка. а термрианл сидит
за ссылкой в ядре. в форме куска кода. виртуальная железка зашитая в ядре.


//
pty - это сокращенное от pseudoterminal!
также когда говорят терминал ориентиорвання прорграмма то имеют ввиду что
после запуска эта программа ожидает что к ней будет подлкючен удаленный терминал.
через pts/N файл. 

(программа --- fd/3) ---> (/dev/pts/10 --> ядро) --- com порт ---- (com порт железка терминал)


и эта программа уммеет настраивать этот терминал. посылатьна него управлябщие команды.
и принимать от терминала данные по протоколу терминала

поскольку железный терминал сидит в ядре то схема вот такая


(программа --- fd/3) ---> (/dev/pts/10 --> ядро --модуль  терминал  --/dev/ptmx) --
-----(fd/3 программа владелец терминала ---socket) ---- (ядро --драйвер экрана)---(граф экран) 

охренеть

самая частая ситуация

(bash --- fd/3) ---> (/dev/pts/10 --> ядро --модуль  терминал  --/dev/ptmx) --
-----(fd/3 gnome-terminal-server ---socket) ---- (ядро --драйвер экрана)---(граф экран) 


а вот типа какая цепочка для связи по ssh с удаленным башем



|(bash fd/3 )----(/dev/pts/10 --> ядро --модуль  терминал  --/dev/ptmx)---(<-ssh-server ---)--- ------(socket-- ядро   IP )---сет кар---|-----интернет------|---сет карта------( ядро   IP socket)<-
(<-ssh-client --- fd/3) ---> (/dev/pts/10 --> ядро --модуль  терминал  --/dev/ptmx) --
-----(fd/3 gnome-terminal-server ---socket) ---- (ядро --драйвер экрана)---(граф экран) <-|- ЧЕЛовек

верт палками я показал пределы отдельных компов.
фишка в том что ssh клиент и ssh сервер связывают ся друг  с другом по IP сокету
но баш на той стороне ждет что к нему подключится терминал поэтому ssh сервер
открывает через ядро на том компе терминал. тесть еще раз

|bash ->- (pts/10 ядро терминал ptmx) -<-(ssh сервер) -- (ip сокет ядро сет карта)| --- интернет ---
----(сет карта  ядро  ip сокет) --- (ssh клиент) ---(pts/4 ядро  ptmx) --(gnome terminal) --
-- (unix domain сокет,  ядро , драйвер видеокарта) --- (граф окно)


далее 
как я понял ест два вида эмуляторов терминала в ядре. один это UNIX98
второй это BSD терминал. вроде как на практике чаще встречаются программы которые
умеют работать с UNIX 98 эмулятором терминала

на счет эмулаторя адерного терминала получается как быакая схема


процессА -------- | терминал | ------ процессB  

терминал сидит в ядре в его куске кода. и терминал имеет два порта.один смотрит в одир
процесс а второй порт в другой процесс

процессА --->---- |</dev/ptmx><терминал></dev/pts/10>| --<--- процессB  

или вот так

процессА(fd/3) --->---- |</dev/ptmx> ядро  </dev/pts/10>|--<--- (fd/5)процессB  

так как содание каждого вирт терминала отьедлает сколько памти в ядре
да еще она и не подлежит свапингу то вот тут указано 
сколько макс темриналов мы можем у ядра создать попросить

$ cat /proc/sys/kernel/pty/max 
4096

это число можно увеличивать оно RW

а тут написано солкько щас темриналов создано
$ cat /proc/sys/kernel/pty/nr
110


далее 
есть прога wall 
она пишет мессагу на все терминалы на компе. WOW!
и программа write которая позвоояет юзеру с одного терминала послать мессагу
юзеру на другом терминале на одном компе




прикол еще  в том что люоая программа может начать писать в /dev/pts/10 
и это прилетит в программу владелец терминала.  а вот наоборот нихрнеена неработает.
можно до усрачки писать в /dev/ptmx но в pts/10 нихрена не прилетит!
потому что как я думую ядро проверяет от каого процесса идет поыптка записи в ptmx
вот такой прикол!
получается как бы любой проецсс может послать инфорацию в терминал. но никто не может
послать информацию от имени терминала (то бишь от имени прогарммы владелца теримнала)
эт такой пц котоый я вначале никак не мог понять!

поэтому чтобы начать писать в владельца териминала (назову его мастер) необязательно
быть чайлдом мастера. это может делать любой процесс кооторый знает в какой
pts/N нужно писать. можно и читать из pts/N люому процессу. таким макамром тыря
то чтоприлеетло от мастера. тоесть у нас процесс1 может сидеь и чиатть из pts/10
а мы берем и из руго процесса тоже начаинем чиать. и два процесса будут 
поочереди урввывать куски инфорации. это дебилизм




далее я использую книгу LIP глава 64
и использую man в линукс,
написал супер простую программу (непроверяющую если где то возникают ошибки)
которая открывает ptmx (тоесть заказывает у ядра вирт терминал)
узнает какой pts/N при этом ядро создало
далее форкает себя тоесть создает чайлда.
в этом чайлде закрыает fd/md который указывает на ptmx ибо чайлду оно никчему
далее открывает pts/N в какйото fd/X, клонирует его в  для stdin, stdout, stderr
и закрывает fd/X
далее чайлд спит 90с
родитель просто ждет через wait() когда сдохнет чайлд.
главное то что у нас теперь есть два процесса один это мастер терминала который
сввязан с ptmx а второй это процесс который открыл pts/N
вот эта прога
при написании програмы наткнулся на ошибки при комплияции
о них я распишу ниже а пока текст программы

$ cat 168.c
#define _XOPEN_SOURCE 600
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/wait.h>






int main()
{

  pid_t pid_p = getpid();
  printf("parent PID = %d\n", pid_p);


  int md = -1;
  md = open("/dev/ptmx", O_RDWR | O_NOCTTY);

  int sl1 = -1;
  sl1 = grantpt(md);
  sl1 = unlockpt(md);


  char * ptr_sln = NULL;
  ptr_sln = ptsname(md);
  printf ("pts name = %s\n", ptr_sln);




      pid_t pid = -1;
      pid = fork();

        if (pid == -1)
        {
           close(md);                     /* Don't leak file descriptors */
           printf("ERROR: fork() is failed\n");
           exit(1);
           } 





        else if (pid == 0)
        {

                 if (setsid() == -1)                 /* Start a new session */
                   printf("ERROR: setsid() is failed\n");

                 close(md);                         /* Not needed in child */

                 int slaveFd = open(ptr_sln, O_RDWR);     /* Becomes controlling tty */
                 if (slaveFd == -1)
                     printf("ERROR: open pts/N is failed\n");



                  /* Duplicate pty slave to be child's stdin, stdout, and stderr */
                  dup2(slaveFd, STDIN_FILENO);
                  dup2(slaveFd, STDOUT_FILENO);
                  dup2(slaveFd, STDERR_FILENO);

                  if (slaveFd > STDERR_FILENO)        /* Safety check */
                     close(slaveFd);                 /* No longer need this fd */

                  sleep(180);
                  return(0);
            }



        else if (pid > 0)
        {
          printf("child PID = %d\n", pid);

          int wstatus = -1;
          int ret_c = -1;
          ret_c = wait(&wstatus);

          if ( ret_c == -1 )
          {
               if ( WIFEXITED(wstatus) )
               {
                 int exit_status = WEXITSTATUS(wstatus);        
                 printf("Exit status of the child was %d\n",  exit_status);
                }
           exit(2);
           }

          else 
            printf ("notice: the child process has exited successfully.\n");



          exit(0);
          }


exit (0);



}

компиилиуем заусккаем
$ gcc -o 168.exe 168.c
$ ./168.exe
parent PID = 3020
pts name = /dev/pts/105
child PID = 3021


далее я устанавливаюь на чайлда strace 
$ sudo strace -p 3021 2>&1 | grep signo

и далее я посылаю процессу котрый мастер терминала SIGTERM
при этом я хочу убедиться что при этом ядро пошлет "слейву терминала " SIGHUP
 итак и есть!
strace показывает
	$ sudo strace -p 3021 2>&1 | grep signo
	--- SIGHUP {si_signo=SIGHUP, si_code=SI_KERNEL} ---
ТАКИМ МАКАРОМ  я научился заказывать в ядре создание вирт терминала.
один процесс у меня это мастер терминала с доступом к ptmx файлу
второй процесс это слейв терминала с открытым /dev/pts/N файлом.
далее я убедился при каком условии возникает сигнал SIGHUP.
что его посылает именно ядро. тоесть иницаитор сигнала это ядро.
и шлет оно его процессу слейв терминала в том случае если 
файл /dev/ptmx на мастере терминала закрывается. а когда
он зкрывается то ядро как я пгимаю уничтожает вирт термиал
в своих кишках и через SIGHUP сообщает об этом слейв терминал процессам
далее я еще раз убедился в этом. я модицифировал программу что выше. 
дело в том что раьше я руками посылал в мастер терминала сигнал SIGTERM.
процесс уничтожался и у него автоматом закрывались файл дескрипторы.
я сделел чуть по друому. 
вот я что изменид

  else if (pid > 0)
        {
          printf("child PID = %d\n", pid);

          sleep (60);  <==== добавитл
          close (md);  <==== добавил

          int wstatus = -1;

 я в мастере терминала поставил sleep(60)
а после эого я поставл чтобы мастер пероцесс сам закрыл файл декриптор
который вдет на ptmx.
тоесть мастер проллждает работать но закрыл fd/N котоый вел на ptmx
и дейсвиительно в этом случае ядро само инициирует и шлет сигнал 
процессу слейв теринмнаала SIGHUP!
чайлд выходит. мастер получает SIGCHLD и тоже выходит.

итак я 100% узнал что коогда как почему итак далее на счет сигнала SIGHUP!!!!!


итак на счет проблем с комплияицией при написании программы:

	implicit declaration of function
она означает что в тексте програмы указана функция о которой
над секцией main() не указан прототип. тоест нужно либо указать в явном
виде прототип либо нужно добавить нужный #define
оказалось что нужно добавить срочку
	#define _XOPEN_SOURCE 600
в чем ее смысл?
цитирую стекфоввфлоу (https://stackoverflow.com/questions/5378778/what-does-d-xopen-source-do-mean)

когда мы пишем 
	#define _XOPEN_SOURCE <some number>
или 
	cc -D_XOPEN_SOURCE=<some number>
мы сообщаем комплиятору что хотим заюзать функции которых видимо нет в некотромо
дефолтовом стандарте но они есть в  X/Open and POSIX стандартах
например 600 означает 
	600 - X/Open 6, incorporating POSIX 2004

далее он говорит а как узнать цифру. для этого идем в man той функции которую
мы хотим вставить наприер grantpt()
и читаем про нее
	$ man grantpt

  grantpt():
           Since glibc 2.24:
               _XOPEN_SOURCE >= 500 ||
                   (_XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED)
           Glibc 2.23 and earlier:
               _XOPEN_SOURCE

значит мне нужно цифра 500 как минуим. в итоге я взял 600
и вставил
	#define _XOPEN_SOURCE 600
после этого с компияляцией все стало гладко


теперь понятно что происходит при нажатии на крестик граф черного окна 
с башем. или на крестик при нажасти на окно с хромом.
на счет баш мы имеем такую схему

черный экран ----->(<драйвер видеокарты> ядро <domain socket>) -------- 
--->(gnome-terminal-server <fd/4>) ------> (</dev/ptmx вирт терминал, ядро</dev/pts/10) -----
--->(fd/4 bash)

при закрытии граф окна ядро передает эту инфо через сокет в процесс gnome-terminal-server
а он тогда закрывает fd/4 который ведет на ptmx , тогда ядро разрущает этот 
инстанс вирт терминала в своей памяти. и заодно оно ядро посылвает SIGHUP сигнал
в баш процесс. если у баша нет блока на этот сигнал то баш выходит. конец истории.

про хром
черный экран ----->(<драйвер видеокарты> ядро <domain socket>) -------- 
--->(хром <fd/4>) 

нажимаем на кретстик на экране. ядро собщает об этом в хром процесс через сокет.
а хром уже себя уничтожает.





следущий этап это в чайлд процесс запустить баш. и потом из 
мастер процесса слат туда символы и в ответ читать что баш мне 
прислал и печаать на экране. но пока я отложу эту задачу. 
терминал это тоже ксатти метод IPC - метод передачи информации между процессами.


<=====
<===== разобрать текст программмы более подробно. что почему зачем
<=====





//
на счет pid=1 в новом пид неймсейсппе.
с точки зрения ядра все обнвоилось. надо взять прогамму на си
и выполгяить сисколл pid_t pid=getpid()
он покажет pid=1
а то что проц нам это н показывает это уже друая  истоиия!
тоесть пид еейнймспейс опреедяется то как про пцроеассс дурмает
ядро а не всякие там юзер приблуды!
так что самй адежный способ убдиться что мы в новом пид неймспейсе
это полчить pid через сисколл getpid() а не проц!!!


//
вопрос чтобы по сети чтото опрслать процесс шлет через fd который
ведет на сет сокетом. процесс должен открыть сет сокет.
чтобы его открыть разве нужно сет карточку укзатьывать?
тогда зачем процессами "видеть" сет карты? если они с ними дела не имеют.
для кого тогда эти сет карты видны? если мы просто ткрываем сокет который
ядро отывает само и потом все раобтает на оснвое таблицы маршутизации.
зачем нам тодга видеть сет карты? 
или сет карта нужна тьолько если мы биндинг хотим на сет карту?
и почему то сетервые карты отствтую в дереве /dev/ ??? что за нахрен?


//
xterm /usr/bin/screen
жмем на CTRl и мышь вылезает меню.
там послать сигнал

делаю стрейс screen

[vasya@lenovo C]$ pstree -AspT 4869
systemd(1)---systemd(2690)---gnome-terminal-(4423)---bash(4609)---xterm(4867)---screen(4869)---screen(4870)
[vasya@lenovo C]$ sudo strace -e kill -p 4869
strace: Process 4869 attached
--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=4867, si_uid=1000} ---
+++ killed by SIGTERM +++
[vasya@lenovo C]$ 
[vasya@lenovo C]$ sudo strace -e kill -p $(pidof screen)
strace: Process 15628 attached
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---
kill(15630, SIG_0)                      = 0
--- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=15607, si_uid=1000} ---
kill(15630, SIGINT)                     = 0
kill(15630, SIG_0)                      = 0
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---
kill(15630, SIG_0)                      = 0
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---
kill(15630, SIG_0)                      = 0
--- SIGTERM {si_signo=SIGTERM, si_code=SI_USER, si_pid=15607, si_uid=1000} ---
+++ killed by SIGTERM +++
[vasya@lenovo C]$ 

получаетяс меню обусловлено самим screen а не xterm?



