установка docker
на хост

последняя заапрувленная кубом версия докера
docker v19

напомню значение некоторых важных папок

/var/lib/docker/overlayfs2  (здесть докер хранит контейнеры и имаджи )
/var/lib/docker/containers  (сюда докер пишет логи контейнеров)

между прочим как узнать в какой папке конкретно докер 
сейчас хранит конкретный image

ответ - # docker inspect image IMAGE_NAME

и в вылезшей портянке ишем строку Upperdir

"UpperDir": "/var/lib/docker/overlay2/a5c5c7216a8b543933a8f2abd26e89b2562ed039c318afedc2ae83530a0df8c1/diff"

в ней и лежит имадж.

причем важно понять что лежит он не в форме зип файла итп 
а уже прям полноценнно раскрытая файловая сруктура.



# apt install -y  ebtables ethtool

ebtables это программа аналог iptables но 
работает не с IP а с ethernet фреймами там тоже есть таблицы
и правила. она позволяет как железном свиче настраивать таблицы 
фильтрации по MAC адресам и прочее. в общем настривать порты с точки 
зрения Ethernet фишек

ethtool это прога которая позодляет тюнить настройки eth 
портов . детали и отличие от ebtables неразбирал.



# apt install -y apt-transport-https ca-certificates curl software-properties-common

apt-transport-https = первый позволяет апту качать пакеты через https
ca-certificates  = ставит кучу CA сертфикатов (кстати команда update-ca-certificates позволяет обновлять эти сертификаты)  
software-properties-common = ( штука которая добавляет команду add-apt-repository. эта команда ниже используется)



$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

эта команда выкачивает публичный gpg ключ от репозитория
пакетов и добавляет его в систему.

если какойто файл подписать приватным ключом то через публичный ключ
можно проверить что файл дейситвтельно подписан приватным ключом.
мы выкачали публичный ключ.
apt его использует недля проверки достоверности каждого пакета нет.
это нужно отдельно настраивать. апт использует этот ключ для 
проверки достверности так назыаваемых метаданных репозитория.
детали невдавался что такое конкретно метаданные репозитория.

в целом этот ключ чтот позволяет проверять в плане достоверности 
в процессе установки пакетов. детали неясны.
но это точно не для проверки каждого пакета. чтото более общее.
пишут что подписывание метаданных репозитоирия через gpg защищает 
от атаки мэн-инзэ-миддл. конкретика пока неясна.

# add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"

# sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable edge test"

в итоге всех этих маниупуляций мы корректно добавили репозотирий докера
в систему

# sudo apt update

сморим какие версии доступны

# apt-cache madison docker-ce

# sudo apt install docker-ce=5.19*


тут полезно проверить действительно у нас есть чистый с нуля докер
или он поставился со старыми хвостами. 
проверяем есть ли старые контейнеры и старые имаджи.
их должно небыть

# docker ps -a
# docker images -a

если все пусто отлично. двигаем дальше

# docker run hello-world

теперь должны появиться первые папки в /var/liv/docker/overlay2, /var/lib/docker/containers


установили докер в систему

теперь нужно настроить чтобы докер использовал systemd-эшный 
менеджер для cgroups. 

потому что когда мы будем ставить кубернетес он посмотрит какой менеджер
использует докер и пропишет себе такой же. поэтому нужно сразу
этот вопрос проконтролировать перед установкой кубернетеса.


как узнать какой cgroup driver использует докер прям щас

# docker info | grep -i cgroup
 Cgroup Driver: cgroupfs

если у нас линукс использует systemd то тогда  для докера настройка
Cgroup Driver: cgroupfs это неправильно и нехорошо.
щас обьясню.
 
 значит что такое cgroup. 
 это фича ядра линукса. позволяет разделить процессы на группы и нарезать
 этим группам ресурсы.
 так вот как  я понял можно руками нарезать эти ресурсы. а можно типа
 через менеджер. одна реализация этого менеджера написана в софтине
 systemd. еще раз сам cgroups это фича самого ядра а внутри systemd есть менеджер который призван как то облегчить работу с этим cgroups и будем называть это менеджером cgroups или как на сайтах в интернете пишут не менеджер а драйвер. systemd это процесс с $PID=1 это init процесс.
 но не все линуксы работают через systemd. есть линуксы которые как и прежде
 живут без systemd. так вот создатели докера как я понял написали свой 
 менеджер для работы с cgroups на случай если systemd отсуствует в системе. и назвали этот менеджер дебильно кстати cgroupfs.
 прикол в том что ядерная фича cgroups работает со своей файловой системой
 cgroupfs. так вот дебильно что докеровский менеджер (менеджер как я понял 
 вместо нас с нашими руками както там сам делит процессы на группы и сам
 назначает им границы ресурсов) тоже называется cgroupfs.
 
 так вот докер по дефолту юзает свой cgroupfs менеджер. 
 но убунту 16 использует systemd поэтому типа тупо использовать докеровский
 менеджер когда в системе есть "системный" менеджер от systemd.
 поэтому раз убунту 16 базируется на systemd то надо докер заставить
 использовать мнееджер не свой а системдэшный.
 
 в целом как я понима в целом проблему. настройки cgroups для процессов
 прописываются в псевдофайловую систему /sys/fs/cgroup/...
 это типа бекенд cgroups. и в этом плане нам вообще пофиг хоть миллион
 менеджеров пусть будет в системе ибо они все пишут настройки в одно место.
 но возможно проблема в том что "база данных" сделанных настроек неодна
 а размазана в двух менеджерах докеровском и системдэшном в системе.
 возможно в этом некоторая проблема... непонятно почему нельзя читать
 настройки из бекенда всем и таким образом нам было бы пофиг что менеджеров 
 в системе несколько. так что несовсем понимаю почему в системе
 менеджер должен быть один.
 
 
 итак меняем менеджер\драйвер cgroups для docker 
 как указано в кубер доке ( https://kubernetes.io/docs/setup/production-environment/container-runtimes/
)
 
 # cat > /etc/docker/daemon.json <<EOF
{
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "100m"
  },
  "storage-driver": "overlay2"
}
EOF
 
# systemctl restart docker
# docker info | grep -i cgroup
 Cgroup Driver: systemd
 
 
 
 
 кубернетес когда он стартует он смотрит а какой же
 менеждер использует докер и начинает использовать тоже докеровский.
 
 поэтому и кубернетес тоже надо заставить исполтьзовать системдэшный.
 так пишут в доке от кубера.
 
 в целом получается нужно до установки кубернетеса настроить докер на
 использования системдэшного мнееджера и тогда кубернетес при установке
 тоже будет использовать "правильный" менеджер.
 
 когда говорят что кубернетес использует тот или иной cgroup менеджер по факту  означает (как я нашел) что один из компонентов кубернетеса kubelet 
 его использует. почему другие компоненты кубернетеса при этом не рассматриваются я пока незнаю. ведь кубернетес состоит и из других 
 компонентов.
 
 хотя мы еще кубернетес еще неустановили 
 я забегу вперед и покажу 
 как узнать какой cgroup драйвер использует кубелет прямо щас.

1 # journalctl -u kubelet | grep cgroup
kubelet[21951]: Setting cgroupDriver to systemd

2 # /var/lib/kubelet/config.yaml
cgroupDriver: systemd

3. # ps aux | grep kubelet
root     21951  2.7  4.8 1190824 99076 ?       Ssl  02:55   0:15 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --network-plugin=cni --pod-infra-container-image=k8s.gcr.io/pause:3.2
и мы тут видим в каких файлах можно посмотреть параметры с которыми 
стартует кубелет

прежде чем двинуться дальше скажу от journalctl.
значит раньше у нас логи вел syslog который их пишет в форме текстовых
файлов в /var/log но с появлением systemd  у него появился свой сборщик логов
 systemd-journald.service
 он работает параллельно с syslog.
он пишет логи в бинарном виде ото всех служб в один файл.
по умолчанию он пишет свою базу в /var/run поэтому после перезагрузки
все исчезает. 
чтобы оно неисчезало надо

# mkdir -p /var/log/journal
# systemd-tmpfiles --create --prefix /var/log/journal
# systemctl restart systemd-journald

