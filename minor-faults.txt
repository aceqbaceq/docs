| minflt/s
| minflt
| minor faults
| page fault

в работе ядра и вирт памяти есть такое понятие как PAGE FAULT.
а их еще разделяют на MAJOR PAGE FAULT  и MINOR PAGE FAULT

что это такое. 

цпу работает в протектед моде. если более точное protected virtual memory mode.
в этом режиме код который работает на цпу он когда указывает адрес в RAM
то адрес этот он виртуальный. тоест он не соостуветствует физ адресу куда реально
будет обращение. я об этом подробно буду отдельно гвооирить.а щас скажу то что когда
мы говорим про виртуальное адресоное прострастнство памяти то здесь важно даже не то что
программа указывает адрес 0x10 а по факту обращение идет в физ памяти по адресу 0x20
а что что какой бы адрес код не указал он не сможет никогда и никак получить доступ 
ко всей физ памяти. дело в том что юзер код обращается к тому куску физ памяти который ему
опредееляет ОС тоесть ядро. и как бы процесс ни извращалс с адресами он никогда и никак не 
выереттся из того физ куска памяти который ему определен ядром.  это и есть настоящая
виртуальная память. 
как это работает.

внутри цпу есть микросхема MMU. 
когда юзер код просит обраттьс к памяти по адресу 0x10 то этот адрес передается на MMU
эта штука ищет какой физ адрес в памяти соответвует для этого процесса по этому вирт адресу.
ищет он это в кеше TLB положим там этого нет тогда mmu лезет в память в так назыаемую таблицу
PAGE TABLES. это неотьемлимая часть архитектуры цпу если он работает в режиме протектед моде.
эту таблицу заполяняет ядро. заполняет для кджго процесса. так вот mmu  лезет в эту таблицу
и ищет в этой таблице для этого процесса физ адрес в памяти который соотвестует данннму вирт
адресу 0x10. положим mmu видит в этой таблице что нет физ адреса для этого вирт адреса.
  - ВОТ ТОГДА  MMU генерирует interrupt (прям как 
обычная железка типа диска или сет карты). это событие этот конкртеный интеррапт называется PAGE FAULT.
этот итеррапт приелатает в цпу (хотя mmu это хрень внутри
цпу). и цпу бросает все что делал и запукает обрабоччик интерапата - кусок кода ядра.
этот хендлер шарится там по карманам и выделяет для этого процесса кусок физ памяти размером 4КБ
(физ память для процессов выделяется кусками по 4КБ об этом подробнее  в другом месте).
и ядро делает запись в таблице PAGE TABLES о том что такой то кусок физ памяти размером 4КБ
теперь находится во владении таким то процессом. далее ядро как я понимаю делает запись еще
в TLB кеше про этот кусок. теперь MMU заново лезет в TLB находит начало адреса этой физ 
страницы. в итоге mmu знает какой физ адрес нужно выставить на шине адреса чтобы считать
из памяти по указанному адресу. далее mmu передает этот физ адрес в цпу. тот берет этот адрес
и на основе него начинается шариться по кешам ища - может там уже есть нужный кусок памяти.
положим его там нет. тогда (тут не уверен) либо сам цпу делает запрос к физ памяти либо 
это делает mmu. наверное скорей всего сам цпу делает запрос.
как я понимаю процесс чтения из памяти он асинхронный с блоком
исполенения с ALU цпу. он в это время может делать чтот полезное. далее прикол в том что
щина 64бит даных поэтому из памяти считывается не 1 байт а сразу 8. далее еще хуже. считывается 
это все в кеш цпу. у него есть длина строки. обычно 64 байта поэтому идет несколько скачиываний
из памяти (автоматически) и вся строка кеша заполняется. далее  кеш он никак цпу не уведомлеяет
о том что память приелетал в кеш. цпу должен сам еще раз залезить в кеш и уже он наткнется на 
нужную память. и эта память считывается к регистр цпу. 
вот такой длиннй процесс между командой 

   mov eax, (1234)

и тем моментом когда содержимое 0х1234 наконец попадет в регистр eax
таким обарзом юзер код получит доступ к памяти только если это позволит ОС и для этого заполнит
в page table кусочек. и юзер код может попасть только в тот кусок физ памяти в который ему
пропишет ядро. процесс заперт в куске физ памяти котоырй ему выделлило ядро. 

кажому процессу ядро выделяет физ памяти кусочками по 4КБ.

PAGE FAULT это событие когда юзер код делает запрос к RAM памяти по некоторму вирт адресу 0xN.
далее mmu ищет физ 0xQ адрес для этого вирт адреса 0xN
и если ненаходит запист в PAGE TABLE то c mmu генерирует interrupt котоырй с точки зрения ядра
называется как PAGE FAULT.  и оно означает что mmu ненаходит адрес физ памяти для этого процесса
для данного вирт адреса. а значит цпу непонятно по какому физ адресу нужно искать то что заказал
процесс. неизвестен физ адрес куска памяти.  PAGE FAULT - "mmu орет : эй ядро ! я без понятия
какой физ адрес для этго процесса для этого вирт адреса!"
эти пейдж фолты разделаются на две группы.
если для этого вирт адреса выделяется пустая ячейка в физ памяти это событие назыается "MINOR PAGE FAULT". а если для этго вирт адреса выделяется ячейка в физ памяти но перед этим ядро еще и 
должно в эту ячейку считать данные из диска и положить в эту ячейку прежде чем к ней дать 
достуа прцоессу то это событие назыается "MAJOR PAGE FAULT " (терминалогия дебильная ни о чем
не говорящая).

теперь стало понятно что такое мажор и минор фолты. для каждго процесса можно найти
статистику сколько мажор и минор фолтов случилось для этого процесса 

$ cat /proc/$$/stat
272656 (bash) S 1970 272656 272656 35048 272685 4194304 3283 3454 0 5 13 3 8 15 20 0 1 0 369878800 9666560 1480 18446744073709551615 106012869963776 106012870758561 140731665993296 0 0 0 65536 3686404 1266761467 1 0 0 17 1 0 0 0 0 0 106012870948816 106012870972208 106013539074048 140731666000384 140731666000389 140731666000389 140731666001902 0


в этой файле столбики 10 и 11 отвечают за 

              (10) minflt  %lu
                     The number of minor faults the process has made which have not required loading a memory page from disk.


              (12) majflt  %lu
                     The number of major faults the process has made which have required loading a memory page from disk.

это цифры сколько таких фолтов случилось с момента рождения процесса.


а вот как можно посмотреть в реальном времени случение этих фолтов
через утилиту (хотя можно и просто /proc/pid/stat мониторить)
это пример процесса файрфокс

  $ pidstat -r 1 -p 263908

17:10:51      UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command
17:10:52     1000    263908    213,00      0,00 2951400  523392   3,25  Isolated Web Co
17:10:53     1000    263908    295,00      0,00 2951400  522108   3,24  Isolated Web Co
17:10:54     1000    263908      9,00      0,00 2951400  522108   3,24  Isolated Web Co
17:10:55     1000    263908    459,00      0,00 2951400  523356   3,25  Isolated Web Co
17:10:56     1000    263908     16,00      0,00 2951400  523356   3,25  Isolated Web Co
17:10:57     1000    263908     28,00      0,00 2951400  523484   3,25  Isolated Web Co

столбики  minflt/s  majflt/s


как вообше происходит работа  с памятью у процесса. он делает запрос к ядру чтобы
ядро выделило для процесса кусок виртуальных адресов к которым процесс может обращаться. 
дело в том что если процесс возьмем и просто попробует считать\прочитать из вирт памяти 
"просто так" то ядро убьет процесс. потому что чтобы куда то в памяти полезть процесс
обязаен вначале у ядра запросить разрешение. процес говорит ядру -  дай мне блок вирт адресов
к которым  я  буду иметь право обрашаться. размер куска скажем дай мне 10МБ.
и ядро сообает процессу что теперь процесс может шартьбся в памяти с адресом 0x10 и далее в 
диапазоне +10МБ.  при этом ядро в физ памяти ячейки для этго куска не бронирует. а вот далее
когда процесс начинает делать непосрественно запросы по этому диапазону вирт памяти 
например 

   mov eax, (0x11)

вот тут то и случается PAGE FAULT , вот тутто ядро и начинает по факту запроса выделять 
куски физ памяти для этго процесса.  соотвсвтенно процесс обращается по адресу 0x11
случется PAGE FAULT и тогда ядро выделяет кусок физ памяти размером 4КБ. теперь процесс
может шариться через вирт память по физ памяти размером 4КБ тоесть условно говоря процесс если
будет делать запрос к вирт памяти в диапазоне

  [0x10, 0x10+4KB]

то теперь уже известно к каому куску физ памяти нужно обращться. ПОЭТОМУ при запросах к 
вирт памяти в диапазоне

  [0x10, 0x10+4KB]

уже событий PAGE FAULT НЕБУДЕТ!  для этого диапазона вирт адресов это событие происходит 
ОДИН РАЗ.

ПОЭТОМУ -если видим то что у процесса идет массированный оьбем PAGE FAULT событий это значит
что юзер код массированно обращается к вирт памяти туда куда раньше никуда не обращался
тоесть в первый раз. именно в этот момен ядро для этого процесса выделяет реальную физ память.  
правда есть тут ТОНКИЙ МОМЕНТ. и мажор фолт и минор фолт необязательно означают что у нас 
при этом событии наша свободная физ память уменьшается. это не всегда так.
рассмотрим MINOR FAULT. он случается в двух случаях. если процесс запрашиывает доступ к 
памяти котоыре не связана с файлами на диске (не буду углубляться) тоесть если он эту
память у ядра заказывал через 
   
   brk()
   mmap(anoymous)
   malloc()

то по факту он запршывает доступ к анонимной физической памяти. и тогда это значит что ядро
должно процессу выделить чистый кусок 4КБ физ памяти именно для этго процесса забрав его
из пула свобдной памяти. и тогда мы имеем миноный фолт и тогда обьем нашей свободной физ памяти
уменьшается при этом событии. НО! если процесс запрашывает доступ к памяти которую он заказал
у ядра через 

   mmap( mmaped)

и которая связана с файлами на диске , а этот кусок файла уже есть в памяти то происходит тоже
минорный фолт. ядро тогда невыделяет кусок физ памяти в пользование этго процесса эксклюзивно,
оно берет кусок физ памяти котоыйр уже содержит этот кусок файла и делает симлинк для этого
вирт адреса. делает ссылку на кусок физ памяти который уже лежит в памяти. происходит минорный
фолт но размер физ памяти при этом событии не уменьшается! поэтмоу ответ на вопрос  - уменьшается
ли свободная физ память при минорных фолтах - бывает да а бывает и нет.
в случае с файрфоксом что выше там никаких файлов не было. просто шел прососмтр ютуьа. поэтому
тупо видос заливался в память. в анонимную. и потому да - размер свободной физ памяти уменьшался.

мажорный фолт - это когда процесс леезет в памят которую он закаазал у ядра  с условием что 
ядро в эту память само будет копировать контент файла с диска. когда процесс лезет в эту 
память случается мажорный фолт. ядро выделяет 4КБ физ памяти (забирует ее из пула свободной памяти)
, копирует туда кусок из файла и потом дает доступ уже процессу к этому куску. так вот в этом 
случае размер физ памяти свободной уменьшается. но! данная физ страница она не выделяется этому
процессу эксклчюизивно. она копруется в ядерный page cache. и если другой процесс вдруг захочет
получить доступ к этмуо же файлу то данный кусок физ памяти будет симлинкнут для того второго
процесса. при этом для того процесса будет минорный фолт. и в итоге у нас два процесса будут
замаплены на одну и туже страницу физ памяти. поэтом в этом случае если мы видим мажорный 
фолт - то да размер свободной  физ памяти у нас при этом падает. вроде бы грустно и плохо. 
но есть нюанс. не все так плохо. если процесс захочет сделать запись по этому вирт адресу 
то ядро не позволит процессу писать изменять эту физ память. ядро эту физ страницу оставит
в памяти нетронутой. на случай если другой процесс хочет полуть доступ к этому файлу чрез 
память. вмсто этого ядро выделить процессу уже другую страницу физ памяти чтобы он туда писал
свои изменения. это будет миноный фолт . который опять же отожрет памяти. но! важно то что
та страница физ памяти которая хранит контент файла изначальный и которая была выделена в 
результате события MAJOR FAULT она при неоходимости ядром может быть мгнвоенно освобождена.
потому что контент этой страницы лежит на диске. поэтому если что мы можем его вседа обратно
считать. так как мы страницу не меняли то ее записывать на диск ненужно. и освободить ее можно
быстро и легко. поэтому при мажор фолтах размер свободйно физ пмяти уменьшается. но  - ее
можно очень легко если нужно освободить.  а вот если нужно освободить анонимую память то такого
пути нет - для этого ее контент нужно сбрасывать в свап. при мажор фолте однозначано происхлодит
чтение с диска. есть еще одна ситуация когда будет мажор фолт. вот у нас есть кусок анонимной
памяти но ядро засунуло этот кусок в свап. процесс к этому куску обращается. тогда возникает
мажор фолт. потому что этого вирт куска в физ памяти щас нет. и чтобы процесс или цпу мог получить
доступ к этой памяти ее нужно вначале считать с диска то есть из свапа и засунуть в какойто
кусок физ памяти. тогда пояяится адрес физ памяти куда можно обратиться. в этом случае у нас
уменьшется свободная физ память. и ее легко обратно не вернуть. тлоько если обратно эут страницу
физ памяти пихать в свап. еще ситация - у нас вирт память(кусок) замаплена на физ файл. когда
то мы обратились  к этмоу куску. он лежал в физ памяти. потом ядро забрало эту физ память под
другие нужды. а тут наш процесс опять обратился  к этой вирт памяти. тогда мажор фолт. у нас
нет физ памяти с этим куском файла. нужно выделиь опять физ память. счиатть туда этот кусок
файла тода появится адрес физ памяти куда можно обратиться. таким образм при мажор фолет
у нас всегда происходит уменьение свободной физ памяти. в одним сулчаях ее можно легко вернуть.
в других нет кроме как засунув кнтент физ памяти в свап.

