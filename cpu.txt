
| cpu 
| turbo
| power
| scale
| MHZ
| temperature

тут я опишу как управлять частотой цпу.
повествование будет рваным - верная и неверна информация будет перемежаться.

у интел есть такая фича. если у нас многоядерный проц. но  в данный момент у
нас запущена толькоо одна программа. тоесть по факту может три ядра спать а одно ядро
работать то за счет этого можно на какйото времы повысить частоту одного ядра гораздо 
выше чем его обычная частота. 

есть такая прграмма i7z

вот что она покаызаевает

Cpu speed from cpuinfo 1799.00Mhz
cpuinfo might be wrong if cpufreq is enabled. To guess correctly try estimating via tsc
Linux's inbuilt cpu_khz code emulated now
True Frequency (without accounting Turbo) 1799 MHz
  CPU Multiplier 18x || Bus clock frequency (BCLK) 99.94 MHz

Socket [0] - [physical cores=4, logical cores=4, max online cores ever=4]
  TURBO ENABLED on 4 Cores, Hyper Threading OFF
  Max Frequency without considering Turbo 1898.94 MHz (99.94 x [19])
  Max TURBO Multiplier (if Enabled) with 1/2/3/4 Cores is  39x/38x/37x/37x


штатная частота 1800 MHZ у ядер. но  она может повысистя в рамках TURBO фичи до 39x
тоесть частота шины 100 Mhz * 39 = 3900 MHZ. нехило.

так вот чтобы отклбчить эту фичу можно налету

# "echo 1 >  /sys/devices/system/cpu/intel_pstate/no_turbo"
все. тпеперь у нас турбо фича выключена. прчием сразу для всех ядер.

правдп i7z почемуто все равно будет показывать что якобы TURBO фича активирована.

статья где можго почитать про стейты процессора - https://www.kernel.org/doc/html/v5.0/admin-guide/pm/intel_pstate.html . однако это очень длтинная и скушная статья

она посвяена драйверу intel_pstate который рулит состояниями процессора.

а более кокнретная и полезная статья это 
 вот тут об этом написано - https://wiki.archlinux.org/title/CPU_frequency_scaling


далее я поговрю про управление частотй цпу и его темперауторй как следствие опираясь 
на все тутже статью из archlinux
значит ситуация такая. есть драйвер который управляет частотой цпу и как следствие это влияет
на температуру цпу. 

драйверов обычно два: acpi-cpufreq либо intel_pstate
на более новых убунтах по дефолту работает более новый драйвер intel_pstate
а если его отключить то начинает работать драйвер acpi-cpufreq

как выяснить какой драйвер управляющий частотой работает щас:
# cat /sys/devices/system/cpu/cpufreq/policy*/scaling_driver 
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate
intel_pstate

итак это текущий драйвер управляющий частотой.

как его вырубить чтобы активировать драйвер acpi-cpufreq
идем в 
# cat    /etc/default/grub | grep -v '#'

GRUB_CMDLINE_LINUX_DEFAULT="... intel_pstate=disable ... "

тоесть надо вставить intel_pstate=disable  в /etc/default/grub

далее надо запустить обноавление граба

# update-grub
либо 
# update-grub2


у меня граб2
# dpkg -l | grep grub
ii  grub-common                                   2.06-2ubuntu7.2    

однако у меня даже # update-grub
тоже прокатило.


итак как опрелить как драйвер щас отвечает за частотй цпу узнали.
как выбрать какой из них будет работаь узнали.

как узнать текущую сейчашнюю часоту цпу на компе.
0)
# cat /proc/cpuinfo | grep MHz
cpu MHz		: 400.012
cpu MHz		: 400.000
cpu MHz		: 400.000
cpu MHz		: 400.005
cpu MHz		: 400.007
cpu MHz		: 400.000
cpu MHz		: 400.005
cpu MHz		: 400.002

1) 
# i7z
насколько я понимаю i7z показывает частоту только на реальных ядрах.
гипетрединговые ядра он не показывает
Current Frequency 802.24 MHz [99.73 x 8.04] (Max of below)
        Core [core-id]  :Actual Freq (Mult.)      C0%   Halt(C1)%  C3 %   C6 %   C7 %  Temp      VCore
        Core 1 [0]:       802.24 (8.04x)           1    4.07       0       0    95.7    54      0.6649
        Core 2 [2]:       797.60 (8.00x)        3.31    2.49       1       1    94.5    53      0.6666



2) втоорой вариант 
# cat /sys/devices/system/cpu/cpufreq/policy*/scaling_cur_freq
400011
400019
400026
400016
400010
400009
400025
400014


тут тоже есть свой прикол.
если у нас работает драйвер acpi-cpufreq то у нас помимо счетчика scaling_cur_freq еще один счетчик
cpuinfo_cur_freq
якобы и тот и тот показывает текущу частоту на ядре. однако это не так.
опыты показывают что scaling_cur_freq  показывает реальную частоту а cpuinfo_cur_freq показывает
некую хрень. попытки найти почемутак и что же насамаом деле поркаызвает cpuinfo_cur_freq
ичего недали.  статьи в инетер пишут прямо противоположное.

также эксперимент показывает что и /proc/cpuinfo и i7z показывают именно теже данные 
что в счетчике scaling_cur_freq

еще раз подчеркну что если драйвер intel_pstet то счетчика cpuinfo_cur_freq вообще нет.
он появляется в /sys если драйвер часоты acpi-cpufreq

далее. распишу
что значат все эти счетчики:
affected_cpus
base_frequency
cpuinfo_max_freq
cpuinfo_min_freq
cpuinfo_transition_latency
energy_performance_available_preferences
energy_performance_preference
related_cpus
scaling_available_governors
scaling_cur_freq
scaling_driver
scaling_governor  (туту надо написать то что если мы меняем говерное для одного цпу то автоматом
оно становится тааиким же доля других цпу)
scaling_max_freq
scaling_min_freq
scaling_setspeed

во первых они лежат в папке  /sys/devices/system/cpu/cpufreq/policy0 под каждое ядро своя папка
поехали
	# cat scaling_driver 
intel_pstate

	# cat scaling_driver 
acpi-cpufreq

в нем прописан драйвер который управляет частотой ядра.
также важно то что в зависимости от того какой драйвер в этой папке бывают несколько 
разные счетчики.

# cat base_frequency 
1600000
покаызвает штатную частоту ядра по паспорту

# cat bios_limit 
800000
это незнаю что значит.

# cat cpuinfo_max_freq 
1600000
по мне это тоже самое. макс частота я дра по паспорту

# cat cpuinfo_min_freq
400000
минимальная частотп по паспотрту

# cat cpuinfo_transition_latency 
10000
не знаю что значит

# cat scaling_available_governors  
performance powersave

# cat scaling_available_governors
conservative ondemand userspace powersave performance schedutil 

в зависимости от драйвера  "scaling_available_governors"  показвает доступные говернеры.
гавернер - это такой переключатель который влияет как будет изменяться частота цпу в зависиомтси 
от нагрузки. тоесть 

performance = означает что все время частота ядра прддреживается на максимуме
powersave = означает что все время частота ядра поддежвается на минимуме
забегая вперед скажу что если драйвер "acpi-cpufreq" то гавернер "powersave" работак как надо.
а если драйвер "intel_pstate" то гавернер "powersave" работает как то хреново.  а именно - на холостом
ходу частота несколко выше чем минимальная . скажем минималрая 400МГЦ а он ее делает 600-700.
а при росте нагрузки на цпу частота начинает потихоньку повышаться. 

ondemand = означает что при повышении наггрузки частота цпу будет повышаться. а при сбросе нагрузки
то частота будет сбратсываться до минимальной.

если драйвер intel_pstate то всего два гавернера доступно performance powersave


# cat scaling_cur_freq
400021
показывает текущую частоту цпу. 
этот счетчик постоаянно слегка плавает.  почму. потому что скорость цпу складывается
из двух цифр. одна это коэффициент умножения внутри цпу. а вторая это частота шины цпу.
так вот коэффициуент (напрмиер он равен 8) он постоянный. а частота шины цпу почемуто плавает 
то она 97Mhz то она 100Mhz. из за этого и скорость цпу постоянно несколко плавает.

если у нас дрвайвер  acpi-cpufreq
то у нас есть ещеодин счетчик

# cat  cpuinfo_cur_freq 
800000
по идее оно тоже должно оказывать текущую скорсть ядра. ооднако 
по факту непнятно что значит этот счетчик. если scaling_cur_freq постяоно плавает. то этот 
счетчик всегда застывший. 
эти оба счетчика могут отличаться. я искал в инете  . там статьи противоречат друг другу. 
в одних пишут что один счтечик более верный. вторые пишут что второй счетчик более верный.
если драйвер intel_pstate то в нем cpuinfo_cur_freq вобще отсутствует.
из прктики я выяснил что и /proc/cpuinfo и i7z они пользуются scaling_cur_freq
также atop показыает две цифры
	avgf  800MHz | avgscal  30%
как я понял avgf берется из cpuinfo_cur_freq
а avgscal берется из  scaling_cur_freq (правда показыает не частоту а процент от макс частоты)

в итоге я когда хочу понять какя же частота щас на ядре смотрю на scaling_cur_freq

# cat scaling_max_freq
400000
показыает на какую макс частоту гавернер может переключать цпу. фишка в том что 
этот параметр можно менять налету руками

# echo "800000" | tee  scaling_max_freq
таким макаром можно налету менять верхнюю планку работы цпу

# cat scaling_min_freq
400000
минималная часотат до которой гавернер может опускать часоту ядра. 
ее тжое можно менять на лету.

если драйвер acpi-cpufreq тоесть еще один счетчик
# cat scaling_available_frequencies
2601000 2600000 2500000 2300000 2200000 2100000 2000000 1800000 1700000 1600000 1400000 1300000 1200000 1100000 900000 800000 
она покзаывает по каким частотам может скакать процессор

отталкиываясь от нее понятно что scaling_max_freq неможет быть больше чем 2601000
и scaling_min_freq неможет быть ниже  800000


таким макаром- как можно управлять частотй цпу. можно руками урезать макс и минимальную частоту
ядра. и после этогго мговновеенно ядро будет работаь на заданной частоте. наприммер

# echo "400000" | tee scaling_min_freq
# echo "400000" | tee scaling_max_freq

теперь внезависимости от гавернера у нас ядро зажато в частоте 400 МГЦ.
все гавернеры дергают частоты на цпу именно в заданных рамках 
	scaling_min_freq << текущая частота << scaling_max_freq
 
гавернеры играю ту роль что они позволяют автоматом переключать часоты на цпу автоматом.
powersave гавернер хорош тем что он вне зависимрсти от нагрузки на цпу должен держать частоту 
равной scaling_min_freq (который мы можем в любой момент менять руками)
на драйвере acpi-freq этот гавернер так и рабоатет. а на драйвере intel_pstep этот гавернер
рабоатте как то непонятно.  при остуствии нагрузки частота держится повыше чем минимальная.
но не минималгая. а при нагрузке частта потихоньку начинает расти. 


еще прикол - если мы поменяли гавернер для одного ядра то автомтаом лтинукс меняем гавернер 
для всех ядер

performance гавернер должен держать частоту равной  scaling_max_freq вне зависимости от нагрузки нацпу.
scaling_max_freq тоже можно менять на лету руками.

ondemand - он при отстуствии нагрузки понимжает частоту до минимальной scaling_min_freq
а при возвраостании гарузки на цпу поываывашает ее до scaling_max_freq

гавернеры - можно менять налету. то есть  перкключать их можно с одного на другой в любое время




далее я опишу важный прикол. на одном ноутбуке на убунту 18 я юзаю драйвер intep_pstep
а надругом буке на убунту 22 я юзаю драйвер acpi-freq. 
почему? потмуо что я выяснил ужаснейший прикол. если мы комп суем в супенд
# systemctl suspend
а потом выходим из ждущего реима то (внимание)  частота на компе взлетает до максимума
и насрать на гавернер и на параметр scaling_max_freq. частота будет максимальная и похер на все.
я пробовать менять при этом гавернеры на разные. похеру. часатота держится максимлаьной.

мне удалось добавится чтобы система невыбывалась после выхода из суспенда только вот в таких кониугряциях
как пложено:

intel_pstate +  Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz + Ubuntu 18 + 5.10.0-051000-generic 
acpi-cpufreq +  Intel(R) Core(TM) i5-4210M CPU @ 2.60GHz + Ubuntu 22 + 6.2.0-32-generic


как узнать макс заводскую частотуу ядра.
# lscpu | grep "CPU max"
CPU max MHz:                        2601,0000

насколко я понимаю это число берется из 
# cat cpuinfo_max_freq
2601000

как можно оперативно отсолеживать частоту теукущую на цпу

# i7z
либо
# cat /proc/cpuinfo | grep "cpu MHz"
cpu MHz		: 798.086
cpu MHz		: 798.088
cpu MHz		: 798.088
cpu MHz		: 798.082


далее
еще цпу может переключаться в турбо режим. это кодга у нас на скжаем одном ядре частота повышается
сущесвтенно выше чем шаттная за счет того что остальные ядра при этом ненагуржены.
об еще будет ниже. эту фичу можно отключить.


соотвесвтенно чем ниже частота цпу тем ниже его температура


значит мы поняли что есть драйвер intel_pstate или acpi-freq и он упоаляет частотой.
мы выставляем гавернер. и драйвер уже дергает динамческий частоту ядра.

в целом этого уже достаотточно. 

еще такой момент как температутра цпу. посмтреть ее можно через # i7z либо # sensors
так вот чем меньше частота на цпу и чем меньше на цпу нагрузка тем меньше грееется цпу.

так вот все что  яописал выше оно за температурой неследит у цпу. да если цпу перегревается то внутри
самого цпу есть мехагизм защиты от перегрева. но еще раз - тот драйвер что я описал он не следит
за тспераератутрой цпу. он следит за нагрузкой на цпу и в зависиости от высатлвенного гавернера меняет частоту.

так вот есть еще программы которые сидят выше над всем этим которые следят за тепературой 
и если цпу перегревается то они чтото меняют. ну я так думаю что они могут менять - навернре
они меняют сам гавернер. и меняеют  scaling_min_freq  и scaling_max_freq
но это теория. что они меняют в случае напгрева я пока незнаю.

так одна из таких программ следящих за темереператорой это thermald.
скажу сразу програма полное дерьмо.  у нее менаубеический xml конфиг. который при этом
еще и не понятно что и как в нем менять. поэтому просто стираем эту праарашу и все.

# apt-get purge -y thermald


есть другая прогрмма аналогичная cpupower
работате она ии нет я не знаю потому что с ней есть другая проблема - чтобы ее поставить это мудежь.
показываю

]# cpupower
WARNING: cpupower not found for kernel 5.10.0-051000

  You may need to install the following packages for this specific kernel:
    linux-tools-5.10.0-051000-generic
    linux-cloud-tools-5.10.0-051000-generic


так вот у меня на убунту18 стоит "кастомное" ядро от самого canonical.
и к этому ядру нихрена нет пакетов 

 # linux-tools-5.10.0-051000-generic
 # linux-cloud-tools-5.10.0-051000-generic

поэтому я ее просто не могу поставить.

также прикол в том что по крайней мере так было раншье - что в убунте по дефолту стояло 
сразу несколько таких программ. то есть cpupower и  thermald одновременно. 
и они мешали друг другу.

ниже щас будет материал которйы частично повтоярет то что было уже описано выше.

меня порадовала возможность руками задать верхнюю часоту процессора налету

# echo 400000 | tee /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq

она установить что верхнаяя часотта для cpu0 может быть 400 MHZ
таким макаром надо пройти по всем ядрам.

далее они пишут что есть такая хрень как governor.
для каждого ядра его можно посмотреть тут 
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
powersave
powersave
powersave
powersave
powersave
powersave
powersave
powersave


вот тут можно посмотреть какие виды power governor доступны на данный момент 
для перкключения
# cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors 
conservative ondemand userspace powersave performance schedutil

его можно изменить на лету. и тогда линукс будет динамически менять частоту на ядре. 
задать говернор можно налету вот так

# echo "powersave" | tee  /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor


виды гавернеров
- performance: это значит что ядро будет работать на макс штатной частоте все время.
максимальная частота берется отсюда 
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq
600000
600000
600000
600000

а вот так можно поменять макс частоту на которую цпу может переключаться 
# echo "800000" | tee  /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq
800000
# cat  /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq
800000
800000
800000
800000


- powersave:  это значит что ядро будет работать на мин часоте 
мин частота берется отсюда
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq
400000
400000
400000
400000
400000
400000

моя практика показал что с этим гавернером  хуйня
тоесть у меня на всех ядрах стоит гавнер= powersave
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor
powersave
powersave
powersave
powersave
powersave
powersave
powersave
powersave

тоесть он должен все время держать частоту минимальной.
вот моя минимальная частота
# cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_min_freq
400000
400000
400000
400000
400000
400000

однако эта сука держит частоту в районе 600 MHZ


установка cpupower:
# sudo apt install linux-tools-$(uname -r) linux-cloud-tools-$(uname -r)


atop
он показыавает две вещи в плане cpu
 curf  400MHz | curscal  25%
 первое число  я даже не знаю откуда он берет. потому то 
 частота по факту плавает. а он все время покаызавает ровное число.
 curscal видимо это тоже самое число но впроцентном отношении к макс штатной частоте
 вобщем атоп как показатель ткущей часаоты так себе программа


есть графическаая прога которая покаызает темпреатуру процессаора в GIU это 

# apt-get install psensor

она берет цифры из lm-sensors проги

далее про C-states и P-states
я напоролся на статью небезызвестного мне швейцарца которы это расписсывает.
итак. мы хотим понизить мощность которую жрет цпу (а значит и его теспературу поппутно).
он пишет что мощность падает пропорционально частоте и по квадрату падения вольтажа.
понимажть мощность можно двумя путями. либо вырубать цпу целиком либо вырубать его подсистемы. и за 
это отвеачают C-states. а можно понижать часоту и вольтаж его подистем  этим занимаюстя P-states.
сама стстья - https://metebalci.com/blog/a-minimum-complete-tutorial-of-cpu-power-management-c-states-and-p-states/

C0 - означает банальано просто режим когда цпу херачить на полной сокрости. 
начиная с C1 уже идет реально остановка ядра.  С-состояния происхдоят только тогда когда цпу
нечего исполнять то есть во время idle промежутка времени. тогда просихдоит C-state. остановка
цпу. во время C-state команды на нем не исполняются. за исключением как я сказал режима C0 - это шататный режим кодга процессор херачит. чем больше цифра скажем C7 тем более глубойикий уровень  энергосбережения впдаает
в ядро цпу. в статье есть картинка. 

далее чуак упоминает что cpuid покажет какие C-states доступны в цпу

# apt-get install cpuid

      number of C0 sub C-states using MWAIT    = 0x0 (0)
      number of C1 sub C-states using MWAIT    = 0x2 (2)
      number of C2 sub C-states using MWAIT    = 0x1 (1)
      number of C3 sub C-states using MWAIT    = 0x2 (2)
      number of C4 sub C-states using MWAIT    = 0x4 (4)
      number of C5 sub C-states using MWAIT    = 0x1 (1)
      number of C6 sub C-states using MWAIT    = 0x1 (1)
      number of C7 sub C-states using MWAIT    = 0x1 (1)

как программически войти в c-state. для этого нужно в привигированном режиме запустить комнаду 
MWAIT.


тепер переходим к P-sattes.
читаю такую интерсную вещь
It is possible to use P-states in Intel Xeon E3–1200 v5 in either OS/Operating System controlled (Intel SpeedStep® Technology) or HW/Hardware controlled (Intel® Speed Shift Technology) mode. The information below about P-states is specific to Intel Xeon E3–1200 v5 Family, however, I guess it is same or similar for other modern processors.

если у нас  OS controller p-states то переход осуществлется так - мы пишем в регистр какой режим
хотим активировать. цпу вычисляет какой вольтаж гужен для этого п-стетйта . и цпу переходит в этот режим.

переходы между p-states просходят оченб быстро в отличие от C-states

далее я выясняил что с 4 версии линукса он поддеживает hWP (hardware p states) и что драйвер intel_pstate
как раз таки если он активировался то значит у нас  актививрованы hardware p-states.
также для того чтобы шарманка заработала нужен прцоессор i5. и надо чтобы в биосе эта фича
была актвивирована. она там должна называться "Intel Speed Shift" (не путать с "Intel speed step")

а вот как проверить в журнале линукса что HWP активиорван

# sudo journalctl -b | grep pstate
сен 17 23:19:04 lenovo kernel: Command line: BOOT_IMAGE=/boot/vmlinuz-5.10.0-051000-generic root=UUID=aa7152b0-f48f-4f20-ad1a-7e0c404584d3 ro systemd.unified_cgroup_hierarchy intel_pstate=enable quiet splash vt.handoff=1

сен 17 23:19:04 lenovo kernel: Kernel command line: BOOT_IMAGE=/boot/vmlinuz-5.10.0-051000-generic root=UUID=aa7152b0-f48f-4f20-ad1a-7e0c404584d3 ro systemd.unified_cgroup_hierarchy intel_pstate=enable quiet splash vt.handoff=1

сен 17 23:19:04 lenovo kernel: intel_pstate: Intel P-state driver initializing

сен 17 23:19:04 lenovo kernel: intel_pstate: HWP enabled

получается "journalctl -b"  это полный аналог или некий аналог dmesg -T
показывает лог при загрузке


Starting with kernel 5.7, the intel_pstate driver selects passive mode aka intel_cpufreq for CPUs that do not support hardware-managed P-states (HWP), i.e. Intel Core i 5th gen. or older.


далее я напоролся на стаью от RedHat о частотах цпу и их управлением
	https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/monitoring_and_managing_system_status_and_performance/tuning-cpu-frequency-to-optimize-energy-consumption_monitoring-and-managing-system-status-and-performance#doc-wrapper


вот как в этой стьте описывают C,P,T стейты:
	Sleep (C-states)
	Frequency and voltage (P-states)
	Heat output (T-states or thermal states)

еще раз скажу что переклчение через P стетйты идет очень быстро
а C стейты таковы что чем более энергосерегающий режим заюзан тем болльше времени 
нужно цпу чтобы из него выйти.

есть утилита turbostat которая инфо по цпу дает.
но там чтото очень много на экране она рисует. вагон информации.

далее много внимания прмиеняетя утиите cpupower

посмтреть доступные гавернеры
# cpupower frequency-info --governors
analyzing CPU 0:
  available cpufreq governors: performance powersave
 

далее перетирается утилита perf


 Performance counter stats for 'system wide':

        170895,68      msec cpu-clock                 #    7,999 CPUs utilized          
            20584      context-switches          #    0,120 K/sec                  
               130     cpu-migrations            #    0,001 K/sec                  
             1357      page-faults               #    0,008 K/sec                  
     1413179341        cycles                    #    0,008 GHz                    
       716176297       instructions              #    0,51  insn per cycle         
       144742230       branches                  #    0,847 M/sec                  
         7298401       branch-misses             #    5,04% of all branches        

      21,363827428 seconds time elapsed


это тот самый perf кооорым я обнаружил когда vmware жестко тормозил




возвращаемся к cpupower

# cpupower idle-info
CPUidle driver: intel_idle
CPUidle governor: menu
analyzing CPU 0:

Number of idle states: 9
Available idle states: POLL C1 C1E C3 C6 C7s C8 C9 C10
покажывает все C-стетйы доступные 


посмотреть гавернер , драйвер 
# cpupower frequency-info
analyzing CPU 0:
  driver: intel_pstate
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency:  Cannot determine or is not supported.
  hardware limits: 400 MHz - 1.60 GHz
  available cpufreq governors: performance powersave
  current policy: frequency should be within 400 MHz and 1.60 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: Unable to call hardware
  current CPU frequency: 628 MHz (asserted by call to kernel)
  boost state support:
    Supported: yes
    Active: yes


далее
позврлоляет задать чтобы комп работал на мин частоте
# cpupower set  --perf-bias 15
но пока непонял раотает ли оно реально

проврить применилось ли оно к процу
# cpupower -c all info -b
analyzing CPU 0:
perf-bias: 15
analyzing CPU 1:
perf-bias: 15
analyzing CPU 2:
perf-bias: 15
analyzing CPU 3:
perf-bias: 15
analyzing CPU 4:
perf-bias: 15
analyzing CPU 5:
perf-bias: 15
analyzing CPU 6:
perf-bias: 15
analyzing CPU 7:
perf-bias: 15


вот еще одна команда  смотреть статистику
# cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6  || C0   | Cx   | Freq || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,21|  1,03| 61,11|  0,00||  1,27| 98,73|  1010||  0,01|  1,51|  0,42|  0,22|  0,70|  0,00|  8,79|  0,11| 86,98
   4|  0,21|  1,02| 61,11|  0,00||  1,00| 99,00|   891||  0,00|  0,00|  0,00|  0,01|  0,60|  0,00|  9,89|  0,00| 88,51
   1|  0,08|  1,43| 61,11|  0,00||  2,25| 97,75|  1011||  0,00|  1,20|  0,07|  0,07|  0,38|  0,00|  7,08|  3,97| 84,97
   5|  0,08|  1,43| 61,11|  0,00||  0,89| 99,11|   996||  0,00|  0,12|  0,51|  0,04|  1,22|  0,00|  6,67|  0,00| 90,57
   2|  0,10|  0,67| 61,11|  0,00||  3,54| 96,46|  1165||  0,00|  0,00|  0,04|  0,05|  0,60|  0,00|  7,65|  0,00| 88,13
   6|  0,10|  0,67| 61,11|  0,00||  1,27| 98,73|  1318||  0,00|  0,00|  0,61|  0,08|  0,32|  0,00|  4,20|  0,00| 93,53
   3|  0,15|  0,91| 61,11|  0,00|| 11,93| 88,07|  1549||  0,00|  1,73|  0,04|  0,17|  1,05|  0,05|  6,86|  0,06| 78,09
   7|  0,15|  0,90| 61,11|  0,00||  0,72| 99,28|   986||  0,00|  1,68|  0,16|  0,01|  0,73|  0,00|  6,56|  0,00| 90,18


прикольно. типа подробная статиктика по CPU стеейтам

далее они пишут что эта команда вывела сразу инфо по нескольким "мониторам"
спмсок мониторов можно получить вот так

# cpupower monitor -l
Monitor "Nehalem" (4 states) - Might overflow after 922000000 s
C3	[C] -> Processor Core C3
C6	[C] -> Processor Core C6
PC3	[P] -> Processor Package C3
PC6	[P] -> Processor Package C6
Monitor "Mperf" (3 states) - Might overflow after 922000000 s
C0	[T] -> Processor Core not idle
Cx	[T] -> Processor Core in an idle state
Freq	[T] -> Average Frequency (including boost) in MHz
Monitor "Idle_Stats" (9 states) - Might overflow after 4294967295 s
POLL	[T] -> CPUIDLE CORE POLL IDLE
C1	[T] -> MWAIT 0x00
C1E	[T] -> MWAIT 0x01
C3	[T] -> MWAIT 0x10
C6	[T] -> MWAIT 0x20
C7s	[T] -> MWAIT 0x33
C8	[T] -> MWAIT 0x40
C9	[T] -> MWAIT 0x50
C10	[T] -> MWAIT 0x60


отсюда следует что доступны мониторы:
Nehalem
Mperf
Idle_Stats

тогда можно сделать вот так

# cpupower monitor -m Nehalem

    | Nehalem                   
 CPU| C3   | C6   | PC3  | PC6   
   0|  0,02|  0,32| 68,61|  0,00
   4|  0,02|  0,32| 68,61|  0,00
   1|  0,08|  0,98| 68,61|  0,00
   5|  0,08|  0,98| 68,61|  0,00
   2|  0,04|  0,85| 68,61|  0,00
   6|  0,04|  0,85| 68,61|  0,00
   3|  0,06|  0,34| 68,61|  0,00
   7|  0,06|  0,36| 68,61|  0,00

# cpupower monitor -m Mperf
    | Mperf              
 CPU| C0   | Cx   | Freq  
   0|  1,65| 98,35|   631
   4|  1,70| 98,30|   659
   1|  0,83| 99,17|   789
   5|  0,55| 99,45|   631
   2|  0,83| 99,17|   679
   6|  0,24| 99,76|   638
   3|  0,76| 99,24|   622
   7|  1,29| 98,71|   634

# cpupower monitor -m Idle_Stats
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  0,60|  0,00|  0,00|  0,08|  0,00|  6,61|  0,08| 88,60
   4|  0,00|  0,00|  0,02|  0,02|  0,71|  0,00|  6,99|  0,00| 87,42
   1|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,42|  0,15| 95,32
   5|  0,00|  1,18|  0,05|  0,03|  0,71|  0,00| 10,51|  0,00| 82,35
   2|  0,00|  0,00|  0,01|  0,06|  0,22|  0,00|  8,88|  0,00| 89,56
   6|  0,00|  1,60|  0,06|  0,01|  0,02|  0,00|  9,39|  0,00| 75,09
   3|  0,00|  0,37|  0,02|  0,04|  0,35|  0,00|  1,72|  0,00| 92,89
   7|  0,00|  0,00|  0,00|  0,00|  0,07|  0,00|  3,11|  0,00| 95,03



описание С стейтов

C0
In this state, the CPU is working and not idle at all.

C1, Halt
In this state, the processor is not executing any instructions 
but is typically not in a lower power state. The CPU can continue 
processing with practically no delay. All processors offering C-states 
need to support this state. Pentium 4 processors support an enhanced C1 
state called C1E that actually is a state for lower power consumption.

C2, Stop-Clock
In this state, the clock is frozen for this processor 
but it keeps the complete state for its registers and caches,
 so after starting the clock again it can immediately start processing again.
  This is an optional state.

C3, Sleep
In this state, the processor goes to sleep and does not need to 
keep its cache up to date. Due to this reason, 
waking up from this state needs considerably more time 
than from the C2 state. This is an optional state.

узнать какой драйвер активен
# cpupower frequency-info --driver
analyzing CPU 0:
  driver: intel_pstate


 доступные гавернеры
 # cpupower frequency-info --governor
analyzing CPU 0:
  available cpufreq governors: performance powersave

про powersave гавернер интересно написано
powersave
It forces the CPU to use the lowest possible clock frequency.
 This frequency is statically set and does not change.
  This governor offers maximum power savings, but at the cost of
   the lowest CPU performance. The term "powersave" can sometimes be 
   deceiving though, since in principle a slow CPU on full load
    consumes more power than a fast CPU that is not loaded.
     As such, while it may be advisable to set the CPU to use 
     the powersave governor during times of expected low activity,
      any unexpected high loads during that time can cause the system 
      to actually consume more power. The Powersave governor is more of
       a speed limiter for the CPU than a power saver. It is most useful 
       in systems and environments where overheating can be a problem.



# cpupower  frequency-info
по деолфту покзвыает инфо только про ядро номер ноль.
чтоы опсмореть инфо про все ядра нужно

# cpupower -c all frequency-info


как задать гавернер и верхнюю и нижнюю частоту между которыми будет скакать цпу
# cpupower frequency-set --governor powersave  -d 400MHz -u 1000MHz

проверяем что получислось

# cpupower frequency-info 
analyzing CPU 0:
  driver: intel_pstate
  ...
  current policy: frequency should be within 400 MHz and 1000 MHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: 686 MHz (asserted by call to kernel)
 
 я походу начинаю догонять почему powersave недержит часоту на уровне 400МГЦ.
 потому что было написано что цпу если работет на высокой часототе с меньшей нагрузкой
 жрет меньше чем на меньше частоте но с большей нагрузкой.


в итоге что касается cpupower то всего  две у него главные команды
		# cpupower frequency-set --governor powersave  -d 400MHz -u 1000MHz
		# cpupower set  --perf-bias 15



так вот конфиг pupower я ненашел  в убунте.
тогда я нашел как засунуть его запуск в systemd вот здесь 
		https://sleeplessbeastie.eu/2015/11/09/how-to-set-cpu-governor-at-boot/



# cat<<EOF > /etc/systemd/system/cpupower.service 
[Unit]
Description=CPU powersave
[Service]
Type=oneshot
ExecStart=/usr/bin/cpupower -c all frequency-set --governor powersave  -d 400MHz -u 1000MHz
[Install]
WantedBy=multi-user.target


# systemctl daemon-reload
# systemcl enable cpupower

тип сервиса oneshot тоесть он одноразово отрабатвает при загрузке



на счет вентилятора на цпу. на ноутбуке lenovo программа sensors (или sensors-detect) нихуя ненаходит
датчик вентилятора. поэтому он работает сука сам по себе. а работает он походу так - пока температура 
до 40 градосов не поднялась он не включается. 
по поводу как это настрвиается там где это сделано по человечески смотри тут  - https://wiki.archlinux.org/title/fan_speed_control



далее
тутже я опишу как сделат так чтобы выход из suspend не происходил из за нажатия мышки usb.
нашел тут - https://ubuntu-mate.community/t/how-to-disable-usb-wake-from-suspend/23163

# cat<<EOF> /etc/systemd/system/acpi-wake.service 
[Unit]
Description=ACPI Wake Service
Before=sleep.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c "for i in $(cat /proc/acpi/wakeup| grep enabled| awk '{print $1}'| xargs); do [ $i != PBTN ] && echo $i| tee /proc/acpi/wakeup; done"

[Install]
WantedBy=sleep.target
EOF

# ln -s /etc/systemd/system/acpi-wake.service  /etc/systemd/system/sleep.target.wants/acpi-wake.service
# systemctl daemon-reload

работает эта хрень так что она срабатывает ровно за мгновение до того как комп
впадет в suspend это как бы pre suspend.
он переводит все хрени в /proc/acpi/wakeup в disabled состояние. а хрени что там 
лежат они являются штуками которые могут выводит из suspend. мы их всех отключаем 
за исключением power button. 

также я прочитал и про другой способ (https://blog.christophersmart.com/2016/05/11/running-scripts-before-and-after-suspend-with-systemd/) добавить событие которые должно протсходить
пперед тем как система уйдет в суспенд. а именно надо 
в папку 
	/usr/lib/systemd/system-sleep
добавить bash скрипт

# cat /usr/lib/systemd/system-sleep/acpi-suspend.bash 
#!/bin/sh
if [ "${1}" =  "pre" ]
then
    for i in $(cat /proc/acpi/wakeup| grep enabled| awk '{print $1}'| xargs)
       do 
          [ $i != PBTN ] && echo $i| tee /proc/acpi/wakeup
       done
fi

основное требовние к нему чтобы он сработал это надо в нем отлавливать аргумент "pre"
что я и сделал. ну и тело скрипта что он должен делать. тогда он будет выполнться
перед тем как система уходит в суспенд.

в итоге я выполнил эту настройку вдвух вышеукаазных местах и таким маккаром у меня бук
перетал просыпаться от деррания мышки. вообще от всего перестал просываться кроме как от нажаття 
на кнопку POWER. очень удобно.




проверяем
# systemctl suspend

я узнал что у thinkpad t440p он не может войти в suspend
он ругался что некое устроуство мешает перейти в suspend.
в  итоге оказалось что его тачпад этому мешает. мне тачпад нахер не встрался на нем.
я его просто нахер выкючил. для этого
		# cat /etc/modprobe.d/rmi.conf 
			blacklist rmi-smbus


далее. у меня на работал переход в suspend для thinkpad t440p если закрыть его крышку ( в  литературе она назыывается LID).
чтобы исправти эту хуйню надо сделат вот что :
0) основаня причина в том что на буке стоит LUBUNTU
у нее в "панели управления" есть "POwer management" там есть закладка LID.
LID это как раз крышка ноутбука. и там в "панели управления - power management -LID " лубунты стоит настройка . во первых о том что еслт крышка закрыта то ничего на ноутбуке недолжно происходить. 
это и есть основаня прична того что при заркытии крышки бук не входит в suspend.
причем четко видно вот что - кода мы находиимся в окне где вводится логин и пароль ( кстати на lubuntu 
display manager это sddm если его перезапустит то мы автоматом logout и оказыатся в окне вводда логина
пароля) то там при закрытии крышки система входит в suspend 
а если мы ввоеди логин пароль то уже система нереагируетс на закрытие крышки
так вот надо в том месте что указал поправить и указать чтобы при закрытии крыши система
входила в suspend.

также помимо этого можно сделать доплениельные дейтсвия :

1) надо поставить пакет 
		# apt install pm-utils

2) надо исправить файл
		# cat /etc/systemd/logind.conf | grep -v '#'
		[Login]
		HandleLidSwitchDocked=suspend
		HandleSuspendKey=suspend
		HandleLidSwitch=suspend
		HandleLidSwitchDocked=suspend

3) перезагрузить службу
		# systemctl restart systemd-logind



теперь можно протестировать закрываем крышку. по идее он наконец должен начать 
впадать в suspend.

в целом я 
попроьвал разобратся с /proc/acpi/wakeup но как обычно это сложно плюнул и забил.


далее. 
как быстро выямнить какой гавернер у нас выставлен. чтобы не лазит руками в /sys
		# cpupower frequency-info



далее.
я узнал что есть утилита 
	# inxi
она предназначена чтобы лузры юзеры могли легко через эту утилиту собрать всю инфо о компе
чтобы отправить ее более умным калдырям.
вобщем inxi милая утилита
напрмиер
# inxi -C
CPU:       Quad core Intel Core i5-8265U (-MT-MCP-) cache: 6144 KB
           clock speeds: max: 1600 MHz 1: 840 MHz 2: 1070 MHz 3: 936 MHz 4: 1128 MHz 5: 1003 MHz 6: 1143 MHz
           7: 860 MHz 8: 856 MHz

# inxi -s
Sensors:   System Temperatures: cpu: 34.0C mobo: N/A
           Fan Speeds (in rpm): cpu: N/A


далее. 
как вручную сменить яркоть экрана а вот так
# echo "2100" >  /sys/class/backlight/intel_backlight/brightness


далее.
я выяснил что все LED индикаторы компа сидят в папке
/sys/class/leds
при этом на финкпаде папка которая отвечает за подсвекутп клавиатуры находистя в папке
/sys/class/leds/tpacpi::kbd_backlight

а чтобы включить подсветку надо сделать так
# echo  1 > /sys/class/leds/tpacpi::kbd_backlight/brightness

и тут я пришел к другой мысли - если прошелкивание всех подпапок в /sys/class/leds
не приводит к тому чтобы клава засветилась то значит в ней нет подсветки.
также на всех ideapad у котоых клава с подсветкой должны на кнопке "space" дллжны иметь значок
подсветки. если его нет то клава не имеет подстветки.   в инете я нашел что кокнертно на мой idepad
есть как я понял альтеранативные клавы в которых уже есть подсветка. и на их конпке "space" есть занчок
подсветки.  активируется подсвтетка через "Fn+Space" причем внезависимости от драйверов. тоесть
если оно есть то должно всегда активроваться через комбинацию этих клавищ.


на счет гавернеров что я выяснил из практики. плюс тут также надо уточнять на каком драйвере
работает гавернер. во первых гавернер это производная тоесть свтойство драйвера. тоесть именно драйвер
является поставщиком списока гавернеров. причем также важно что у разных драйверов гавернеры могут
иметь одинаковые имена но это не значит что они будут давать одинаковое поведение. 
у драйвера acpi-freq он создает целую кучу гавернеров
		# cat scaling_available_governors 
			conservative ondemand userspace powersave performance schedutil 
а драйвер intel_pstate у него всего два гавернера: performance и powersave
так вот powesave у acpi-freq работает по дргому чем у драйвера intepl_psstate.
powersave у драйвера acpi-freq реально все время держит частоту на уровне нижней заданной частоты
тоесть если мы задали 
	# cpupower frequency-set -g powersave -d 800MHz -u 1200MH
а потом запустили стресс тест 
	# stress --cpu 2  --vm-bytes 128M --timeout 30
то все это время частота будет держаться равной 800МГц.
а если у нас драйвер intel_pstate то фиг там. если мы у него задали гавернер powersave
	# cpupower frequency-set -g powersave -d 400MHz -u 1200MHz
то во первых даже в хоолостом состоянии частота будет находится на уровне 600МГц а не 400МГц
(может потому что у меня была запуещена гарфическая среда. а если ее потушить то будет в районе 400МГц).
но если запустить стресс тест то частота через какоето время уйдет в 1200МГЦ
потом когда тест закочнится то частота обратно вертся на уровне 600МГц. поэтому это да эт powersave
но совсем не такой как у дарйвера acpi-freq

минимальную частоту можно помимо cpupower также задать руками для кждого ядра через
/sys/..../scaling_min_freq
просто через cpupower это удобнее. а так пофакту он всего навсего за нас лезет в /sys и там меняет эти 
датчики.

также важно отметиь что драйвер intel_pstate он более хитрый чем драйвер acpi-freq потому что у него 
на /sys есть своя отдельная секция (своя отдельная папка)
		/sys/devices/system/cpu/intel_pstate
и в этой папке у него есть два счетчика 
		max_perf_pct
    min_perf_pct 


эти счетчики ограничивают макс частоту и мин частоту. 
при этом те счетчики ограичеия частоты которые я назвал выше которые лежат в другой папке и 
относятся к ядрам
		/sys/devices/system/cpu/cpufreq/policy*/scaling_max_freq
		/sys/devices/system/cpu/cpufreq/policy*/scaling_min_freq
они тоже есть. и тоже ограничвают верхнбб и нижню частоту
возникает вопрос . как они соотносятся? 
ответ такой что max_perf_pct и min_perf_pct  - они более главные. причем надо замеит что max_perf_pct и min_perf_pct они влияют сразу на все ядра одноврменно а счетчики scaling_max_freq и scaling_min_freq они 
у каждого ядра свои.  так вот max_perf_pct и min_perf_pct  - они более главные. и это значит что 
макс скорсть ядра не может быть больше чем  max_perf_pct , тоесть scaling_max_freq он может быть меньше чем
max_perf_pct. но никак не больше. аналогично для счетчиков для частоты снизу. тоесть 
работае вот такое правило
		scaling_max_freq <= max_perf_pct
если scaling_max_freq будет выставлен больше чем max_perf_pct то система это проионорирует
и все равно будет выставлять макс частоту на основе max_perf_pct

аналогично для
				scaling_min_freq >= min_perf_pct
тоесть scaling* неможет быть ниже чем min_perf_pct

также замечу что 
		/sys/devices/system/cpu/cpufreq/policy*/scaling_max_freq
		/sys/devices/system/cpu/cpufreq/policy*/scaling_min_freq
занчения в них указываются в мегагерцах
а в 
		max_perf_pct
    min_perf_pct 
занчения указываются в процентах. за 100%  берется так назыаемая макс часатота возожмная у ядра.
та которая может быть после применения турбо буста. для примера.
# lscpu
Model name:          Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz
CPU max MHz:         3900,0000
CPU min MHz:         400,0000

у него штатная частота это 1600NHZ
а турбочастота это 3900-4000MHZ.
так вот за 100% будет взято 4000 MHZ. и сооовсвтенно скажем 10% это 400МГЦ.
поэтому если мы выставим 
		max_perf_pct = 30
то это 30% от 4000МГЦ тоесть это 1200МГЦ
тоесть здес важно понимать что в max_perf_pct и min_perf_pct ставятся проценты и за 100%
берется не штатная частота 1600МГЦ как могло интуитвино показаться а турбо часатота 4000МГЦ.
также посмтреть какая штатная частаота а какая турбо у цпу можно через i7z

# i7z
  TURBO ENABLED on 4 Cores, Hyper Threading ON
  Max Frequency without considering Turbo 1898.94 MHz (99.94 x [19])
  Max TURBO Multiplier (if Enabled) with 1/2/3/4 Cores is  39x/38x/37x/37x
  Real Current Frequency 398.96 MHz [99.94 x 3.99] (Max of below)


таким макаром я на данный момент обьяснил то что: 
1) scaling_max_freq и scaling_min_freq = часатота ставится в мегагцерацах
	max_perf_pct и min_perf_pct = часатота ставится в процентрах.
	за 100% берется не шататная часатота ядра а его турбочасатота.
	узнать турбочастаоут можно либо через lscpu либо чеерз i7z
	либо на сайте интела по нвазванию цпу

2) max_perf_pct и min_perf_pct они превалируют над анаологичными счетчкиками scaling_max_freq и scaling_min_freq


3) что гавернеры это произовадная от драйвера. у каждого драйвера свой спмсок гавернеров.
и если даже навзение гавернера у додного дарйвера совпдает с навзанием у другого даррайврера
это незанчит что эти гавернеры работают одинакоово.


далее. у каждго цпу есть заводской нижний порог часатоты. мы неможем замедлить процессор
медленнее чем этот нижний порог. скажем у одного цпу это 400МГЦ у другого это 800МГЦ.
поэтому скажем если цпу имеет турбо часатоту 4000МГц и у него минимальная нижняя часатота с завода
это 400МГц то миимальной занчение котрорые мы можем выставит для min_perf_pct это 10.
тоесть 10% от 4000МГЦ это будет 400МГц. если мы будем пытаться его вытсватьи в 5% к примеру
то это ничего недаст. там будет стоять 10% по преженму.

теперь возвращаюсь к powersave гавернеру.
у обоих драйеров есть гавернер с таким названеием. 
повторю то что если мы выставили нижнюю часатоту равную минимальной возможно нижней часатоте
то если у нас гавернер powersave от драйвера acpi-freq то эта связка будет держать часатоту равной 
минимально выставленной во что бы то ни стало. а если у нас гавернер powersafe от драйвера intel_pstate
то там часатота будет плавать. я бы сказал что  powersave от intel_psatte работает в точности как 
гавернер ondemand от драйера acpi-freq. тоеть по возможности частаота держится визу но как только нагрузка
растет то она будет повышена. поэтому по факту даже на мин нагрузке powersave от intel_psatte будет 
держать часатоту всегда повыше чем наша мин часатота. скажем вы задаи мин часатот 400МГЦ а он будет
ее держатьв районе 600МГЦ.

покажу на примере "powersave+intel_pstate"
турбо частоат = 4000МГЦ
# cat min_perf_pct 
10  (тоетст это 400МГЦ)
# cat max_perf_pct 
30  (тоесть это 1200МГЦ)

# cpupower frequency-set -g powersave -d 400MHz -u 1200MHz

# cat scaling_min_freq 
400000
# cat scaling_max_freq 
1200000

# cat scaling_driver 
intel_pstate
# cat scaling_governor 
powersave

и вот какая в итоге например будет итоговая частота
# cat scaling_cur_freq 
618766

тоесть не 400МГЦ а 618МГЦ

прмиер с "pwowersave+acpi-freq"
# cat scaling_driver 
acpi-cpufreq
# cat scaling_governor 
powersave
# cat scaling_min_freq 
800000
# cat scaling_max_freq 
1200000

и в итоге факическая частота будет
# cat scaling_cur_freq 
798183

тоесть мы задали 800МГЦ он держит 798МГц

итак мы уяснили на какой часатоте будет держать комп гаверне powersave в случае
обоих драйверов. еще раз скажу что powersave от acpi-freq он реальнорабоатет как powersave
а powersave от intel_psate он рабоатет по факту как ondemadn от acpi-freq

но еще также интересно как себя ведет гавернер performance котоырй есть тоже у обоих 
драйверов. 
так вот там очень инересно. если перключится на этот гавернер то оба они детвуют одинакоово. 
они устанавливают на цпу турбо часатоту. и пытаютя ее макс удержать. поэтому пока позволяет 
температура на чипе то процессор  со штатной часатотой 1.6ГГц он будет работать на частаоте 4.0ГГц.
я это проерил на практике. ка только перелючаю на performance гавернер то часатота на ядрах сразу
влетает в космос в турбо частоту. это хороо видно в i7z

# cpupower frequency-set -g performance -d 400MHz -u 4000Mhz

на всякий случай проясню такой вопорос - как связь между гаверер и драйвер. гавернер это порожение
драйвера. без драйвера нет гавренера. спсок гавернеров и их повдеение определяется драйвером. дарйверов
два acpi-freq и intel_pstate

как ыбстро узнать какой драйвер щас , какой гавренер и какой диапазон частот задан
# cpupower frequency-info
  driver: intel_pstate
  current policy: frequency should be within 400 MHz and 1.20 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: 686 MHz (asserted by call to kernel)

еще пример на другом прцоессоре:
# cpupower frequency-info
  driver: acpi-cpufreq
  hardware limits: 800 MHz - 2.60 GHz
  current policy: frequency should be within 800 MHz and 1.20 GHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: 800 MHz (asserted by call to hardware)

для core-i5 комфортная температура ксати 40-60 градусов.


еще раз также покажу как нам сохранить настройки по гавернру и часатота.
для этого надо создать служба systemd


# cat<<EOF >/etc/systemd/system/cpupower.service 
[Unit]
Description=CPU powersave
[Service]
Type=oneshot
ExecStart=/usr/bin/cpupower -c all frequency-set --governor powersave  -d 400MHz -u 1000MHz
[Install]
WantedBy=multi-user.target
EOF



это все очень интеерсно.

далее. 
еще одна полезяняшка для нуотбука.
включить консервативное сохранение батарейки бука
First make sure the ideapad_laptop kernel module is loaded, with the lsmod command.
If it is, run the following command as root to enable Battery Conservation Mode:
# echo 1 > /sys/bus/platform/drivers/ideapad_acpi/VPC2004:00/conservation_mode
это будет приваодит к тому что батарейка бука ее заряд будет поддерживаться на уровне 60%
и это позицирнируется что это офигенно сохраняет ее срок службы.
я проверирил реально заряд батарейки неподнимтся выше 60%


далее
thinkfan
описываю как на нотубуке thinkpad t440p
как на нем по человечески настроить вентилятор.
чтобы он сука врашался когда и сколько нужно. 
на счет насттройки вращения вентилятора. на thinkpad удалось настроить чтобы он вращался
тогда когда нужно. по деолфту в динуксе эта сука вобще не вращалась и цпу перегревался.
как это сделать,
за основу взял эту статью = https://gist.github.com/Yatoom/1c80b8afe7fa47a938d3b667ce234559

	# apt-get install lm-sensors thinkfan

ищем температурные датчкии
	# find /sys/devices -type f -name "temp*_input"

плоучим чтото типа такого 
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp6_input
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp3_input
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp7_input
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp4_input
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp8_input
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp1_input
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp5_input
/sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp2_input
/sys/devices/platform/coretemp.0/hwmon/hwmon3/temp3_input
/sys/devices/platform/coretemp.0/hwmon/hwmon3/temp1_input
/sys/devices/platform/coretemp.0/hwmon/hwmon3/temp2_input
/sys/devices/virtual/thermal/thermal_zone0/hwmon1/temp1_input

будем совать это в конфиг thinkfan

вот мой рабочий конфиг:

# cat /etc/thinkfan.conf 
hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp6_input
hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp3_input
hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp7_input
hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp4_input
hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp8_input
#hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp1_input
hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp5_input
hwmon /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon2/temp2_input
hwmon /sys/devices/platform/coretemp.0/hwmon/hwmon3/temp3_input
hwmon /sys/devices/platform/coretemp.0/hwmon/hwmon3/temp1_input
hwmon /sys/devices/platform/coretemp.0/hwmon/hwmon3/temp2_input
hwmon /sys/devices/virtual/thermal/thermal_zone0/hwmon1/temp1_input



(0,	0,	30)
(1,	30,	33)
(2,	33,	37)
(3,	37,	40)
(4,	40,	42)
(5,	42,	44)
(7,	44,	32767)


настройка чтобы финфан юзал этот конфиг
    # echo 'THINKFAN_ARGS="-c /etc/thinkfan.conf"' | sudo tee -a /etc/default/thinkfan

первая часть конфига это тепераутарные датчики чтото типа того
вторая часть это таблица с тесператураами и насколько быстро при этом ддолен врашаться
вентиляор.
первая колонка 
 0,
 1,
 2,
 3,
 4,
 5,
 7

 это сокрсть вентилятора обозначенная не в конкретных rpm а
в формате условного ранжироованияю 0 - это внетилятор либо неработает либо врашается по имнимуму
а 7 - это макс обороты вентиятора

вторая и третя колонка это диапазон температур в рамках ккоторых ралотает вентилятор на одной частоте 
врашения

	# echo "options thinkpad_acpi fan_control=1" > /etc/modprobe.d/thinkfan.conf
	modprobe thinkpad_acpi

	# cat /etc/modprobe.d/thinkfan.conf
	options thinkpad_acpi fan_control=1 experimental=1


протестиорвать финкфан до запуска в виде сервиса
	# thinkfan -n

  # sudo service thinkfan start
  # service thinkfan status

  чтобы хрень работала при загрузке надо также добавиьт в /etc/modules
  			thinkpad_acpi
				coretemp

  # sudo systemctl enable thinkfan.service

значит при настройке этой шарманки у меня вылезла (не помню уже где) ошибка
				ERROR: Module thinkpad_acpi doesn't seem to support fan_control 
решение 
		# echo "options thinkpad_acpi fan_control=1 experimental=1" | sudo tee /etc/modprobe.d/thinkfan.conf
    # sudo modprobe -rv thinkpad_acpi
    # sudo modprobe -v thinkpad_acpi
    # service thinkfan restart

и все зараобтало! решение нашел здест (https://github.com/vmatare/thinkfan/issues/45)
при этом и в sensors стало показывать частоту врашения вентилятора а до этого ноль рисовало
 
# sensors
thinkpad-isa-0000
Adapter: ISA adapter
fan1:        3841 RPM   <====
CPU:          +39.0°C  
GPU:           +0.0°C  
temp3:         +0.0°C  
temp4:         +0.0°C  
temp5:         +0.0°C  
temp6:         +0.0°C  
temp7:         +0.0°C  
temp8:         +0.0°C  



также если все заработало то вот тут поле "speed" начнет показывать неноль
    # cat /proc/acpi/ibm/fan
        status:   enabled
        speed:    3846      <=========
        level:    4
        commands: level <level> (<level> is 0-7, auto, disengaged, full-speed)
        commands: enable, disable
        commands: watchdog <timeout> (<timeout> is 0 (off), 1-120 (seconds))


из всего того что я нашел в интернете на lenovo idepad l340 нихуя невозможно заставить 
как то через софт управлять этим ебаным цпу вентилятором. мега долбоебы в этом леново.


есть еще fancontrol и его часть pwmconfig
еще есть yaml для thinkfan.conf
еще есть /sys/class/hwmon  и там видно сколько темп датчиков и что они значат




далее. 
cpupower
что я про него еще открыл.
вот мы хотим посмотреть какой у нас драйвер. какой у нас гавернер.
какие у нас частоты ращреены?
# cpupower frequency-info
analyzing CPU 0:
  driver: intel_pstate
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency:  Cannot determine or is not supported.
  hardware limits: 400 MHz - 1.60 GHz
  available cpufreq governors: performance powersave
  current policy: frequency should be within 400 MHz and 1000 MHz.
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: Unable to call hardware
  current CPU frequency: 778 MHz (asserted by call to kernel)
  boost state support:
    Supported: yes
    Active: yes

видтим что у цпу0 драйвер intel_pstate
что гавернер это powersave
что гавернер будет выбирать часаототы в диапазоне 400-1.6GHz
но по факту в плане разрешенных частот это полная хуйня. потому что 
мы идем в /sys и смотрим для цпу0 настройки 

# cat /sys/devices/system/cpu/cpufreq/policy0/scaling_min_freq 
400000
# cat /sys/devices/system/cpu/cpufreq/policy0/scaling_max_freq 
1000000

тоест несовпаение! cpupower врет!
более того идем еще вот сюда
# cat /sys/devices/system/cpu/intel_pstate/max_perf_pct 
30
# cat /sys/devices/system/cpu/intel_pstate/min_perf_pct 
10

у нас цпу имеет турбо частоту 4000MHz. значит 
max_perf_pct = 1200 MHz
min_perf_pct = 400 MHz

мы видим что эти настройки расходятся с тем что мы только смотрели выше.
также мы вспоминаем что pct настройки они преобраладают. значит в итоге диапазон 
рарешенных частот это 

400 MHz-1200 MHz

таким макром я понял что cpupower врет!


далее.
как на лету перевести ядро в offline режим
	# echo 0 > /sys/devices/system/cpu/cpu2/online
чтобы обратно перевести цпу в online режим
	# echo 1 > /sys/devices/system/cpu/cpu2/online
при этом важно знать что ядро 0 линукс недаст перевести в оффлайн режим. об 
этом надо забыть
при этом я незаметил чтобы ядра выведенные в оффлайн режим чтобы их
тепература начала падать. ну окей - из за теплопроводности они будут такие же как их соседи.
но также я незаметил чтобы пакет package его теппрература начала падать. хотя я это 
тестироварл на холостой системе с неработаютщим вентилятором.

вот как посмотеть какие ядра онлайн а какие оффлайн 
		# lscpu
		Architecture:         x86_64
		CPU op-mode(s):       32-bit, 64-bit
		Byte Order:           Little Endian
		CPU(s):               8
		On-line CPU(s) list:  0-3
		Off-line CPU(s) list: 4-7


важно. надо понимать что если у нас на компе стоит thinkfan 
то при выключении ядер thinkfan у нас он сломается. тоесть он перестанет работать потому что в его
конфиге стоят ссылки на /sys относятшиеся к ядрам. как только какоето ядро переводится в оффлайн
то видимо часть sys ссылок исчезает и финкфан ругается что конфиг некоректный.
так что это надо понимать.

про hotplug читал вот тут - https://www.cyberciti.biz/faq/debian-rhel-centos-redhat-suse-hotplug-cpu/







далее читаю про cpufreq. что это за хрень.
cpufreq.
походу это опция при компиляции линукса котоаря как раз таки дает взможмность в целом конфигурировать 
частоту цпу динамически. 
походу так и есть

# cat /boot/config*91* | grep -i cpufreq
CONFIG_X86_PCC_CPUFREQ=y
CONFIG_X86_ACPI_CPUFREQ=y
CONFIG_X86_ACPI_CPUFREQ_CPB=y

эта подсистема состоит из трех частей. код ядра(общий) + драйвер (acpi-freq \ intel_pstate) + говернер
ну и на самом деле еще папки в /sys через которые можно конфигурировать этот самый говернер.
а эта папка в /sys на самом деле когда мы туда пихаем данные то ядро берет их оттуда преобразует
их и пишет их в MSR регистр процессора. и только тогда шарманка и работает. но эти суки 
об этом не пишут.

Operating Performance Points = тоже самое что P-state

что интересно что P-states они находятся внутри C0 стейта это как бы его субуровни. потому что C0 это стейт когда выполняются команды на цпу.

intel_pstate драйвер может работать в двух режимах. если он может то работает в режиме HWP (hardware p-states)
в этом случае как я понял драйвер делает совсем чуть чуть. он пихает небольшой (как пишут в доке) хинт
цпу. от себя добавля хинт пихается в MSR регистр. а всю работу по переходу в конкртеный p-state делает сам процессор. по моему здесь они тоже пиздя и не договорваивают важные детали.

если hwp активрован быть не может то intel_pstate переключается в software state режиме.
он смотрит поддерживает ли он данный процессор. если да всю работу по опредеению на какой частоте 
и прочее уже софтверно решает драйвер intel_pstate . хотя на практкие нихерна непопнтяно на самом 
деле какая по факту разница между этими режимамими(имею ввиду HWP vs софт режим).  если у intel_pstate драйвера нет данного процессора в списке то тогда ос переключатся на acpi-freq драйвер

далее переходят к драйверу acpi-freq и его гавернеру "powersave" и пишут вот что:
 если у нас установлена низкая макс частота но цпу хуярит на этой частоте с 100% usage и сравнивают с потреблением энергии
цпу у которого установлена высокая макс частота но он работает  в idle режиме то второй случай жрет меньше энергии. по мне тут нет никакой проблемы. если мы во втором случае нагрузим цпу на 100% usage то сожрет вообще овердохуя энергии. гораздо больше чем в первом случае. 
поэтому идите нахуй дока писатели.

чем отличается гавернер ондеманд от conservative. ондеманд мгновенно старается подняться либо до максимума по частоте 
если есть нагрузка либо сброситься до минимума если нет загрузки.  conservative гавернер более инертный по сравнению с ондеманд в ту и другую сторону тоесть он частоты добавляет и сбрасывает более неохотно.
напомню что мы щас рассматриваем драйвер acpi-freq.

как уже известно папка для управления со стороны юзера подсистемой cpufreq это 
			/sys/devices/system/cpu/cpufreq

содержимое папки

affected_cpus
base_frequency
cpuinfo_max_freq
cpuinfo_min_freq
cpuinfo_transition_latency
energy_performance_available_preferences
energy_performance_preference
related_cpus
scaling_available_governors
scaling_cur_freq
scaling_driver
scaling_governor
scaling_max_freq
scaling_min_freq
scaling_setspeed


affected_cpus = обозначает на какой цпу повлияет насторойка в этой папке (на какое ядро)
их может быть несколлько так они пишут но на практике я пока встречал только одно цпу

cpuinfo_transition_latency = показывает сколько наносекунд потратится на переключения между P-states

related_cpus = насколько я понял тут указан список ядер которые взаимосвязаны с этим ядром.
я посмотрел . по факту в этом счетчике всегда содержится то ядро за которое отвечает папка.
короче ничего интересного тут нет. в целом я не понял разницу этого счетчика с affected_cpus

пишут что если меняю scaling_max_freq\scaling_min_freq то вначале надо менять верхнюю планку.

scaling_setspeed = доступен только если выбран гавернер "userspace" драйвера acpi-freq
засовывая сюда частоты можно менять частоту цпу при условии что частота лежит в рамках между 
scaling_max_freq\scaling_min_freq


ксати я пока что все это читаю из статьи из пдф от леново. так вот в ней написано что 
"cpuinfo_cur_freq" это якобы частота на которой реально работает цпу а
"scaling_cur_freq" это якобы часатота на которой ядро линукса думает что цпу работатет (то есть частота на которой ему задал работать драйвер). я считаю что это полная хуйня. во первых потому что если у нас драйвер
intel_pstate то у нас "cpuinfo_cur_freq" вообще нет. так что идите нахуй.

в целом забегая вперед - я уже порядочно на практике поработал с cpufreq и удивляет насколько бесполезная 
документация в интернете. они разволят охуенную воду далекую от практики совершенно. и умалчивают важные детали.
просто космические долбописатели.

как уже сказал intel_pstate драйвер имеет свою доп папку на sysfs поимимо стаднартной папки cpufreq на sysfs 
			/sys/devices/system/cpu/intel_pstate

содержимое папки

hwp_dynamic_boost
max_perf_pct
min_perf_pct
no_turbo
num_pstates
status
turbo_pct

как я уже писал что в  max_perf_pct\min_perf_pct значения частот суются в виде процентов.
так вот воникает вопрос от какой макс частоты это считать от макс турбо частоты либо от штатной
частоты. так вот пдф от леново утвержlает  что это зависит от no_turbo
если 
	no_turbo = 0
это значит что у нас разрешены турбо частоты (или турбо P-states) в этом случае проценты в max_perf_pct\min_perf_pct отсчитываются от макс турбо частоты
а если 
		no_turbo = 1
то проценты рассчитываются от макс НЕтурбо частоты.
так вот ЭТО ПОЛНАЯ ХУЙНЯ. практика показала совсем другое.

покажу на примере. 
у нас штатная частота 1600MHZ а турбо частота 4000MHZ. 
у нас установлено вот так
max_perf_pct = 30%  
min_perf_pct = 10%

если у нас турбо активировано то это должно значить согласно леново что мы отсчитываем проценты
от 4000MHZ.
тоесть 

max_perf_pct = 30%  = 1200MHZ
min_perf_pct = 10%  = 400 MHZ

если я запущу перформанс тест то i7z должен показать что наша частота подскочит до 1200MHZ
я так и сделал запустил стресс тест
 #  stress --cpu 8 --vm-bytes 128M --timeout 20s
и частота подскочила до 1200MHZ.
все окей.

но потом самое интересное я дезактивировал турбо частоты 
  # echo "1" > no_turbo

теперь мы согласно леново пдф дожны отсчитывать процент от штатной частоты 1600MHZ 
а значит 

max_perf_pct = 30%  = 480 MHZ
min_perf_pct = 10%  = 160 MHZ

так вот я запустил тот же стресс тест и моя частота опять же подскочила до 1200MHZ.
это значит что то что пишет ленрово это полная хуйня. и мы всегда должны  рассчитывать процент
в max_perf_pct \ min_perf_pct  от ТУРБО частоты. и неважно активировано оно или нет.

далее важно сказать что нижня частота не может быть ниже чем это зашито в железе. на этом процессоре
это 400МГЦ. ниже никак не опустить ее.

итак проценты высчитываются от макс турбо частоты вне зависимости разрешены ли турбо  частоты или нет.

далее важно сказать что лимиты установленные в max_perf_pct / min_perf_pct / no_turbo 
распространятюся на все ядра. это так сказать генеральные настройки. далее эти суки из леново не говорят 
об одной очень важной вещи - как мы помним у нас есть общая папка по настройке часатоты ядре.
это 
		/sys/devices/system/cpu/cpufreq/policy*/
с параметрами 
scaling_max_freq
scaling_min_freq

в них мы задаем верхнюю и нижнюю частоту для кажого отдельного ядра индивидуально только не в процентах
а в частотах.
возникет вопрос - что если настройки в этих двух местах конфлиуктуют. какая побеждает?
так вот всегда побеждает настройка в папке /sys/devices/system/cpu/intel_pstate
то есть побеждают настройки max_perf_pct / min_perf_pct / no_turbo
то есть scaling_max_freq < max_perf_pct 
а scaling_min_freq  > min_perf_pct
если no_turbo дезактивировано то что бы ни было задано в scaling_max_freq или  в max_perf_pct - макс частота
на цпу не поднимется выше штатной частоты.


я провел всевозможные опыты которые это проверяют. вот один из них
я установил верхнюю частоту равной 2000MHZ в scaling_max_freq через
   # cpupower frequency-set -g powersave -d 400MHZ -u 2000MHz 
то есть сейчас наша верхняя частота установлена в 2000MHZ
в то же время я установил  max_perf_pct = 50%   (4000MHZ * 0.5 = 2000MHZ)
то есть сейчас в обоих настройках наша верхняя частота совпадает.
также  я установил no_turbo=1 то есть она запрещает частоту выше 1600 MHZ
далее я запустил stress тест и i7z показал частоту 1600MHZ.
это говорит о том что если no_turbo  дезактивировано то все остальные настройки могут идти нахер. 
частота выше штатной (которая 1600 MHZ) не поднимается.


далее я установил 
max_perf_pct = 20% ( 800 MHZ)
при том что напоминаю 
scaling_max_freq = 2000 MHZ
запустил стрес тест и i7z показал частоту 800 MHZ
это подтверждает что   max_perf_pct более главная настройка которая перебивает то что указаано в scaling_max_freq


далее такой момент что такое intel speed shift . а это есть ничто иное как HWP тоесть hardware P-states.
как я понял это следующий эволюционный шаг после intel speed step. 
как я понял intel speed step - это когда ОС решает на какую частоту перключаться цпу (из линейки поддерживаемых)
то есть до intel speed step видимо цпу вообще не умели переключать частоту. 
с появлением intel speed step цпу смог переключать частоты во время работы.
но еще важно добавит что  кучу работы по расчету параметров делает ОС. а intel speed shift это когда ОС делает минимальную работу
по расчету параметров а всю работу делает сам процессор. я не знаю что там за супер сложные расчеты но 
по тому что пишут их тупые доки интуитивно следует что то что раньше делала ос в значительной степени 
теперь делает сам процессор в плане расчет всего того что нужно для переключения частоты процессора.
поэтому я бы сказал что softwate p-states это speed step . а HWP это speed shift.
как узнать в каком режиме щас работает наша шарманка. если в 
		# # cat scaling_driver 
intel_pstate
это значит что шарманка работает в режиме HWP

что касается драйвера который отвечает за частоту то такого не может быть чтобы часть ядер обслуживалась
одним драйвером а часть другим. все ядра всегда обслуживаются одним драйвером

еще про affected_cpus - это какие цпу подвержены настройками папки в котором этот счетчик сидит.
но у меня по факту всегда в этом счетчике прописано одно ядро. такого чтобы там было указано 
несколько ядер такого я не видел

related_cpus = не понял разницу между affected_cpus. по моему одно и тоже

scaling_cur_freq - та частота которую драйвер запросил выставить у цпу. по факту
тут всегда я вижу частоту которая по факту и есть на цпу щас.

гавернер schedutil - как я понял это считается эволюция гавернеров ondemand и consrravtive.
он как я понял высчитывает какую частоту надо выставить на ядре исходя из очереди заданий в шедулере
линукса на этом ядре.  подробности описаны хуево поэтому мало понятно

гавернер ондеманд - уже понятно что он выставляет частоту цпу тем выше чем выше нагрузка
и обратно ее убирает до нуля как только нагрузка падает до нуля. минус этого гаернера в том что как написано в  этой доке 
(https://docs.kernel.org/admin-guide/pm/cpufreq.html#:~:text=CPU%20Performance%20Scaling%20in%20Linux&text=The%20CPUFreq%20core%20provides%20the,which%20the%20other%20components%20operate.) то что код этого драйвера
вызывает частый контекст свич (как они это опрелелили?) то есть юзание этого гавернера вызывает некий 
по их мнению ощутмый оверхед. ну хз.

гавернер conservative - такой же как ондеманд но частоту резко не меняет. а делает это 
более тягуче.

no_turbo = определяет разрешено ли гавернеру заказывать турбо частоты. или нет. 
1 означает нельзя. 0 означает можно. если выставлен 0 то это не значит что сейчас в эту
секунду юзаются тубо частоты. это означает что в принципе это разрешено. а дальше решает 
гавернер когда включать эти турбо частоты.


поговорим про драйвер intel_psatte
intel_pstate - он выполнен не в форме модуля а вмонтирован в само ядро. ну мне в этом плане 
похеру.
этот драйвер может работать в активном или пассивном режиме. пока что я разницу не понял. понял
только то что активный режим он как бы полноценный. а пассивный он каличный.

итак активный режим. если драйвер работает в этом режиме то тогда в sysfs счетчик  scaling_driver
будет равен intel_pstate. это вот такой признак что у нас активный режим. этот режим возможен
если cpu поддерживает HWP фишку. 
насколько я понял из хуевой доки (https://docs.kernel.org/admin-guide/pm/intel_pstate.html#coordination-of-p-state-limits) что при таком режиме и таком драйвере можно 
для разных ядер выбрать разный гавернер. но это не рекомендуют. сомнваюсь что это реально так.
в этом режиме доступно два гавернера performance - тут все понятно.
и powersave - а тут засада. работает совсем не так как гаверн драйвера acpi-freeq а работает скорее
как  schedutil\ondemand.
если у нас драйвер intel_psatet и active режим то возникает вопрос а какой тогда по дефолту 
гавернер будет заюзан. ответ такой. идем в config ядра и там проверяем вот что 

$ grep "CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE"  config-5.*91*
CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y

здесь мы видим "y" значит по дефолту будет выбран гавернер "performance"
ну окей. так себе инфо.

как я уже сказал что intel_pstate драйер будет активирован в active режиме только если у цпу 
внутри есть фича HWP. если она есть то она будет автоматом активирована. и после этого ее дезактировать 
уже будет нельзя. ну окей и что нам с того?  
если мы хотим дезактивировать HWP при загрузке то надо в строке GRUB для ядра вставит строку
			intel_pstate=no_hwp
и что? что это дает ? ясно только то что тогда активный режим запуска драйвера intel_pstate
будет невозможен. насколько я понимаю при такой настройке режим работы драйвера intel_pstate 
будет passive. или софт режим. кстати сказать пока что все описания касаются активного режима intel_pstate
а до пассивного режима пока никак добраться не могу.

если у нас активный режим то драйвер will write 0 to the processor's Energy-Performance Preference (EPP) knob (if supported) or its Energy-Performance Bias (EPB) knob (otherwise), which means that the processor's internal P-state selection logic is expected to focus entirely on performance.

knob - означает ручка крутилка. забавно я думал что внутри цпу регистры а не настройки и крутилки.
тут ссука я сразу покажу и обьясню что это значит. у спец регистра процессора MSR есть как я понимаю 
биты , группа битов одна называется EPP а вторая EPB. у старых процессоров есть только биты EPB
у новых процессоров есть и EPB и EPP. далее важно понять что EPP\EPB это и есть то место через 
которое настраивается "Intel Performance and Energy Bias Hint" . это и есть то самое место через которое
это настраивается.  мы суем некоторые числа в эти биты и процессор понимает что мы от него хотим 
в плане "Intel Performance and Energy". далее ниже я отдельно обьясню что после этих настроек делает
цпу на практике. как на практике сказывается подкручивается "Intel Performance and Energy" я покажу ниже дальше отдельно.

далее  я хочу сказать еще раз о том что "Intel Performance and Energy Bias Hint"(сокращенно хинты) 
настраиваются через сование чисел в EPP\EPB. в старых цпу есть только EPB, в новых процессорах 
я встретил что есть и EPB и EPP. так вот если есть сразу две группу битов то процессор принимает во внимание
только то что записано в EPP а то что мы запишем  в EPB ему на 100% насрать в этом случае. эти суки в интернете
об этом нигде не говорят. и только в одном месте некие энтузиасты об этом догадались. я в этом факте убедился
на практике и пока не нашел эту мысль никак не мог понять что за хуйня.

как на практике мы можем совать числа в EPB\EPP.
один способ это мы суем в /sys папку. после этого ядро сует нужные числа уже в сам процессор. 
кстати msr регистр доступен в /dev/proc/cpu*/msr но туда я вобще нелазию. о том как и куда совать в /sys
я покажу ниже. а второй способ засунуть числа в EPB/EPP это утилита 
		# x86_energy_perf_policy

вот так можно посмотреть чему равны EPP\EPB биты в данный момент
		# x86_energy_perf_policy -c0
		cpu0: EPB 0
		cpu0: HWP_REQ: min 4 max 7 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0
		cpu0: HWP_CAP: low 1 eff 7 guar 16 high 39

видим что у процессора есть и EPB и EPP. как уже сказал если есть две группы битов то EPB можно 
игнорировать. значение имеет только EPP. в данном случае он равен 128
теперь поговорим что делают сами значения EPP/EPB. EPB лежит в диапазоне 0-15. но в данном случае
мы на него срем с колокольни. EPP лежит в диапазоне 0-255. чем больше число тем более сильно цпу экономит
электроэнергию. как конкретно он экономит буду показывать ниже. 
как поменять EPP:
		# x86_energy_perf_policy  --hwp-epp 255
		# x86_energy_perf_policy -c0
		cpu0: EPB 0
		cpu0: HWP_REQ: min 4 max 7 des 0 epp 255 window 0x0 (0*10^0us) use_pkg 0
		cpu0: HWP_CAP: low 1 eff 7 guar 16 high 39

(-c0 говорить что мы показываем только цпу CPU0. ибо смотреть настройки для всех цпу накладно)
а так видно что новое значение EPP=255

поговорим что значат другие хрени в x86_energy_perf_policy:
	use_pkg 0 - показывает что ядро находится в сокете 0
  min 4 - показывает что минимальная частота разрешенная на цпу это 400 MHz
  max 7 - устанавливает максимальную частоту разрешенную на цпу это 700 MHz

щас я покажу как менять эти параметры. чуть позже.

строка  HWP_CAP: означает параметры процессора которые по дефолту как я понял зашиты  в цпу
строка  HWP_REQ: означает параметры которые установлены вручную , нами.

меняем параметры вот так 
	# x86_energy_perf_policy  --hwp-epp 255  --epb ...  --hwp-min ...  --hwp-max ... --hwp-desired ...

des 0 означает желаемую (desired) частоту на цпу. если равно 0 то отдается на усмотрение цпу.
я менял этот параметр но это нихрена недало.

итак с помощью это команды можно задать минимальную частоту на цпу (хотя сделать ее меньше чем тот минимум что зашит в цпу не получится. параметр изменится но процессор посрет на нашу настройку) , максимальную частоту,
и EPP. EPP настраивает на цпу то как он будет работать - либо в сторону перфоманса либо в сторону энергосбережения. энергосбережение означает что макс частота цпу будет урезана. об этом все ниже будет подробно.

но возвращаюсь к основной теме мы хотели научиться управлять фишкой "Intel Performance and Energy Bias Hint"
 в практическом смысле а не как пиздят в инете. итак управление хинтами идет через изменение EPB/EPP
 битов в MSR регистре. дальше я будут писать только про EPP потому что новые цпу управляются через EPP 
 а старые через EPB. еще раз скажу что если в цпу есть и EPB и EPP то процесор игнориует EPB и смотрит исключ
 етельно то что в EPP. меняем мы EPP через утилиту x86_energy_perf_policy.
 EPP можно менять от 0 до 255. если 0 то цпу будет херачить на макс частотах то есть макс перформанс.
 а если 255 то цпу будет работать на минимальных частотах и экономить энергию. как это на пракике выглядит об 
 этом дальше и ниже.

вот так все просто. но эти ссуки все описывают в доках пространно и замудрено.

еще EPP можно поменять без утилиты x86_energy_perf_policy а через запись в /sys папку.
об этом щас поговорим

для этого надо изменить датчик
# cat /sys/devices/system/cpu/cpu0/cpufreq/energy_performance_preference 
power

прикол состоит в том что пишем мы туда не числа а слова. например "power"
доступные опции что можно писать туда можно подсмотреть тут

# cat /sys/devices/system/cpu/cpu0/cpufreq/energy_performance_available_preferences 
default performance balance_performance balance_power power 

эта хрень работает так - мы пишем "power в "energy_performance_preference"
ядро преобразует это слово в некоторое число и пишет его в EPP в MSR.

таким макаром через x86_energy_perf_policy мы можем менять EPP более тонко подставляя числа от 0 до 255.
а через energy_performance_preference мы можем подставить только 4 значения. а по факту даже три 
потому что default это какото значение из оставщихся трех.

тут важно добавить что EPB через /sys меняется через другой датчик
		# cat /sys/devices/system/cpu/cpu0/power/energy_perf_bias 
0

и тут приколов нет. EPB через x86_energy_perf_policy меняется в форме чисел от 0 до 15
так вот "energy_perf_bias"  тоже меняется через числа от 0 до 15

вот таким макаром происходит управление "Intel Performance and Energy Bias Hint".

далее надо написать о том  какая связь между  гавернером и хинтами.
и тут связь такая - если установлен один гавернер то хинты нихрена неработают. они игнориуются.
если выбран другой гавернер то хинты начинают работать. например если у нас драйвер intel_pstate + active
+ performance то хинты игнорируются. если intel_pstate + active + powersave то хинты наконец начинают
работать. что касается другого драйвера я не проверял как там с хинтами дела обстоят.

далее есть еще такая хуйня если я пишу в EPP через утилиту  x86_energy_perf_policy
то не факт что это будет отображено в /sys/ в energy_performance_preference
почему? потому что если мы запишем в EPP число 134 то у ядра нет в таблице слова которое соотвествует 
этому числу. потому то еще раз напомню что в   energy_performance_preference указыавется содержимое
EPP но не в форме числа а в форме слова. но слово там отображается если у ядра есть соотвествие 
между числом в EPP и неким словом.


далее я чуть отхожу в сторону

у esxi написано что acpi performance states это P-states а  acpi power states это c-states . ну окей.
еще раз напомню что если прям щас цпу ненужно выполнять никакие команды то его можно отключить 
усыпить через один из C-states. а если у нас щас цпу должен выполнять команду то нефакт что мы хотим ее выполнять на макс скорости. и это p-states. он уменшает частоту и волтаж ядра на некоторое время.
чем более продвинутый c-state тем дольше таймаут чтоб после этого вернуть цпу обратно в строй но 
и экономия энергии больше.

на счет турбо буста в презентации чуавка из чехии универа написано что частота текущая турбо буста
независит от температуры а зависит от последних выполненных инструкций
(https://events.it4i.cz/event/39/attachments/150/344/04-2020-01-29-prace-ee-DC-RS.pdf)


далее я начинаю уже на практике играться с гавернерами и хинтами.

значит я беру драйвер intel_pstate он запущен в active режиме
на гавернере powersave
я активирую турбо частоты

# pwd
  /sys/devices/system/cpu/intel_pstate
# echo 0 > no_turbo
# cat $(pwd)/no_turbo
0

у меня штатная частота цпу это 1600 MHZ. а далее идут турбо частоты до 4000 MHZ
задаем сначала ограничение сверху по частота не уровне 2000 MHz
для этого 

max_pct = 100%
max_scale_frq= 2000MHZ 

в итоге максимальная разрешенная частота будет  2000MHZ

напомню главный регулятор частота прописывается в max_pct
этот регулятор распостраняется на все ядра сразу он превалирует над всеми регуляторами.
а max_scale_frq настраивается уже для отдельных ядер, он не может быть больше чем max_pct
но он может быть меньше
таким образом 

max_pct = 100% задает 4000 MHz настройку главную настройку для всех ядер сверху
max_scale_frq= 2000MHZ   задает 2000 MHz для конкретного ядра. так как 2000 < 4000 то это окей

итоговая частота на ядре будет 2000 MHz

тут важно сказать что штатная частота на цпу это 1600 MHZ поэтому если у нас дезактивированы 
турбо частоты то попытка записи 2000 MHz в  max_scale_frq  не даст ожидаемого эффекта
и фактически там будет 1600 MHz. 

что еще интересно, если мы разрешим турбо частоты (no_turbo=0) при этом порежем верхнюю частоту
радикально (max_pct = 10% это 400 MHz на текущем процессоре) то при этом можно без каких либо проблем
записать в max_scale_frq 2500 MHz. при этом конечно нагрузка на цпу не даст выше того что 
записано в max_perf_pct (выше я сокращал до max_pct) при нагрузке на цпу. 
все это какой то ебанутый архитектуррный дизайн.  max_perf_pct реально ограничивает частоту сверху 
при этом в max_scale_frq можно писать любую чушь. no_turbo тоже реально ограничивает частоту и тут уже
в max_scale_frq херню записать нельзя.  что за ебанаты ?


и тут я важно дополню что когда мы пишем в max_perf_pct в /sys то ядро по факту пишет в EPP 
в MSR в процессоре.
показываю. проверять будем через   x86_energy_perf_policy

	# echo 1 > no_turbo 
таким макаром мы запретили частоты выше 1600 MHz. установили планку что частота <= 1600 MHz
	# echo 17 > max_perf_pct
таким макаром мы установили еще одну планку 680 MHz. (потому что 4000 * 17%)
тут также надо сказать что процессор округляет в сторону увеличения в рамках 100 MHz
поэтому будет 700 MHz

а теперь смотрим что у нас в процессоре в MSR таким макаром установилась верхняя планка 700 MHz
	# x86_energy_perf_policy -c0
cpu0: HWP_REQ: min 4 max 7 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0

видим "max 7"

следущий пример
	# echo 100  > max_perf_pct 
  # cat max_perf_pct 
    100

однако 100% это 4000 MHz. но у нас дезактивированы турбо часатоты через no_turbo=1
тогда посмотрим что в MSR записалось
	# x86_energy_perf_policy -c0
		cpu0: HWP_REQ: min 4 max 12 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0

кхм..
видим что  "max 12"
ну то что max неравен 40 точне 39 (то бишь 3900 MHz потому что i7z показывает что макс турбо частота не 4000 MHz а 3900 MHz). так вот ну то что частота сверху не 3900 MHz это понятно. так как турбо частоты запрешены.
но почему 1200 MHz а не 1600 MHz ?

а потому что 
# cat scaling_max_freq 
1200000

изменим его на 1600 MHz
	# echo 1600000 > scaling_max_freq
и вуаля
	# x86_energy_perf_policy -c0
    cpu0: HWP_REQ: min 4 max 16 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0

получили max = 16 = 1600 MHz

итак что мы имеем еще раз:
	# cat no_turbo 
		1                     <=== (макс частота 1600 MHz)
	# cat max_perf_pct 
		100                   <=== (макс частота установлена 3900 MHz)
	# cat scaling_max_freq 
		1600000               <=== (макс частота установлена 1600 MHz)

	# x86_energy_perf_policy -c0
		cpu0: HWP_REQ: min 4 max 16 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0

итоговая частота макс частота "max 16" = 1600 MHz

я бы сказал что у нас в итоге такое правило:
	scaling_max_freq < max_perf_pct  < no_turbo

этому правилу подчиняются эту счетчики. если пытаться вставить неправильную частоту в эти 
счетчики то система либо пошлет нахер. либо вставить неверное число но по факту проигнорирует 
нашу неверную настройку. в процессор в  MSR в итоге будет записана та частота которая является 
наименьшей из этих трех счетчиков

попробуем записать хрень. в эти счетчики и посмотрим что окажется в итоге в цпу
	# echo 1 > no_turbo
	# cat no_turbo 
		1
итак мы ограничили частота на 1600 MHz

	# echo 30 > max_perf_pct 
	# cat max_perf_pct 
		30
тут мы ограничили частоту на 3900 * 30% = 1170 ~ 1200 MHz
1200 < 1600 значит все окей.

	# echo 1500000 > scaling_max_freq 
	# cat scaling_max_freq 
		1500000
мы установили частоту 1500 MHz

посмотрим что вышло

	scaling_max_freq(1500 MHz) >  max_perf_pct(1200 MHz)  <  no_turbo (1600 MHz)

а нас требование 
		scaling_max_freq < max_perf_pct  < no_turbo

значит чтобы этому удовлетворить этому мы получим частоту 1200 MHz
а теперь смотрим что у нас в итоге записано в цпу
	# x86_energy_perf_policy -c0
		cpu0: HWP_REQ: min 4 max 12 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0

гоча! в цпу мы видим именно  "max 12" тоесть 1200 MHz

таким макаром выяснена связь между тем что будет записано в 
	no_turbo 
	max_perf_pct 
	scaling_max_freq 

и что окажется в итоге в цпу в MSR регистре и таким макаром то какая макс частота будет прописана 
в цпу ( и минимальная частота тоже)

ну и на закрепление темы ограничим частоту цпу между 400 и 700 MHz
	# echo 1 > no_turbo          | установили 1600 Мгц отключили турбо частоты для макс частот
	# echo 17 > max_perf_pct     | установили 700 МГц для макс частоты
	# echo 10 > min_perf_pct     | установил 400 МГц для мин частоты

	# echo 700000 > scaling_max_freq  | установил 700 МГц для макс частоты для конкретного ядра
	# echo 400000 > scaling_min_freq  | установил 400 МГц для мин  частоты для конкретного ядра

	# x86_energy_perf_policy -c0
	cpu0: HWP_REQ: min 4 max 7 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0

	ура. получили то что хотели "min 4" и  "max 7"
  частоты ограничены как  400 MHz и 700 MHz

а вот другой вариант как это сделать по другому и для всех цпу
	# cpupower frequency-set -g powersave -d 400MHz -u 700MHz
	# x86_energy_perf_policy --hwp-epp 255
	# x86_energy_perf_policy  | grep HWP_REQ
		cpu0: HWP_REQ: min 4 max 7 des 0 epp 255 window 0x0 (0*10^0us) use_pkg 0
		cpu1: HWP_REQ: min 4 max 7 des 0 epp 255 window 0x0 (0*10^0us) use_pkg 0
		cpu2: HWP_REQ: min 4 max 7 des 0 epp 255 window 0x0 (0*10^0us) use_pkg 0
		cpu3: HWP_REQ: min 4 max 7 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0
		cpu4: HWP_REQ: min 4 max 7 des 0 epp 255 window 0x0 (0*10^0us) use_pkg 0
		cpu5: HWP_REQ: min 4 max 7 des 0 epp 128 window 0x0 (0*10^0us) use_pkg 0
		cpu6: HWP_REQ: min 4 max 7 des 0 epp 255 window 0x0 (0*10^0us) use_pkg 0
		cpu7: HWP_REQ: min 4 max 7 des 0 epp 255 window 0x0 (0*10^0us) use_pkg 0

в итоге мы видим что у нас EPP=255 то есть режим полнейшего энергосбережения
и частоты на всех ядра установлены в отрезке [400,700]MHz

кстати помимо lscpu можно юзать cpuid для справки про цпу



поехали дальше
дальше я делаю вот что - я на практике рассматриваю как EPP (хинты) влияет на цпу.
делать это можно двуму путями - через x86_energy_perf_policy менять epp 
либо можно менять через /sys  energy_performance_preference

я буду менять через /sys
при этом гавернер будет powersave потому что если гавернер performance то на хинты насрать. 
не знаю кому насрать процессору или гавернеру или ядру но хинты не работают тогда.

напомню что если мы меняем EPP через sys то к сожалению  energy_performance_preference 
может принимать всего 4 значения 

performance 
balance_performance 
balance_power 
power



energy_performance_preference  = power. 
на холостом ходу 500-700
на нагрузке  с активированным турбо частота 1000-1100
время теста 4-7 секунд. четко видно что частота потихоньку но растет и растет и нет этому конца.
тоесть powersave он сука он если долго цпу грузится то он частоту дотянет до хер знает какого 
верха. поэтому если мы хотим реально энергосбережения то нужно ограничивать частоту сверху обязательно

все дальнейшие опыты время тестирования 4-7с

energy_performance_preference  = balance_power. 
на холостом ходу 500-700
на напгуржке  с активированном турбо частота 1900
без турбо 1600 (штатная частота)
тоесть такой EPP задирает частоту выше штатной. но несильно. 
частота задирается мгновенно при нагрузке


energy_performance_preference  = balance_performance. 
на холостом ходу 500-700
на напгурзке  с активированном турбо частота 3700MHZ (эта макс турбо частота когда 4 ядра напгружена)
когда турбо отключено то на нагрузке частота  1600 (штатная)


energy_performance_preference  = performance. 
на холостом ходу от 2000 до 3700 
чуть малейшая нагрузка и сразу прыгает до 3700


получается что если у нас гавернер powersave но energy_performance_preference  = performance 
то гавернер вобщем то неделает то что от него требуется. по факту процессор работает в режиме
перформанс.
получается гавернер powersave это некая глобальная настройка. а вот уровень этого powersave
как бы настраивается "слайдером" в форме energy_performance_preference ( по факту помним что это 
изменение EPP)

 performance --> balance_performance --> balance_power --> power

чем правее мы выбираем настройку тем у нас реально powersave
чем левее "крутим"" ползунок тем от нашего powersave неостается нихрена

обратный эксперимент тоже показателен
ставим гевернер performcance
и далее ставим energy_performance_preference  = power
но у нас даже на холостом ходу частоты максимальные. тоесть в случае гавернера performcance
перстает  работать настройка energy_performance_preference

поэтому я бы суммарно сформулировал такое правило.(пока что мы рассматривем только драйвер intel_pstate+active)
если гавернер performance то про настройку energy_performance_preference можно вобще забыть. она не дейтсвует.
если гаверенер powersave то energy_performance_preference обязательна к настройке и она 
настраивает в какой степени мы получим powersave. причем это касается часатот даже на холостом ходу.

а вот эта настройка = energy_perf_bias  ни на что не влияет в случае моего процессора.
потому что запись в нее меняет EBP. а значение в EBP игнориуется при наличии EPP в цпу 


нашел в инете инфо (https://bbs.archlinux.org/viewtopic.php?id=282383) того что я уже открыл из практики о том что если процессор имеет EPP то он нахер игнориует что у него в EPB

дальше я решил менять EPP через x86_energy_perf_policy

epp=100 частота 3700 MHZ при нагрузке (нагрузка это stress 4-7 секунд)
epp=150 тоже самое
epp=180 частота 2900
epp=186 частота 2000 
epp=192 частота 1900
epp=200 частота 1900 MHZ на нагрузке
epp=230 частота 1700
epp=255 частота 1100 (но  видно что растет и растет если нагрузка не заканчивается )

на примере epp=255 виден такой прикол что на самом деле частота она при всех epp она будет расти и расти
просто при маленьком epp она растет мгновенно а при большом epp она растет но медленно. но как я понял 
она растет все равно до максимума который прописан в max_pct либо scale_max_frq, то есть powersave 
сука он как ondemand у acpi-freq просто в зависиомости от epp он либо медленно растет либо очень быстро.
тоесть нужно если мы выставили intel_pstep + powersave + epp=255 то еще нужно запрещать частоты 
макс в max_perf_pct иначе при длительной нагрузке он нам цпу загрузит на все 40000МГЦ и сожрет всю батарею
и нагреет комп до бела. вот такой дебилизм ( для сравнения acpi-freq + powersave реально железно держит частоту равной min_scale_freq в независимости от длительности нагрузки!!!)


что меня еще убивает это ебнутая терминология epp это  по ихнему "Intel Performance and Energy Bias Hint"
где hint это подсказка совет. но  я вижу что epp это никак не подсказка это прямая настройка 
которая не подсказывает сука а прямо управляет. скоты. немогут коректно называть вещи термины.

получается по факту добиться вменяемого поведения цпу через драйер intel_psatte это намного более 
сложно чем через более старый  драйвер acpi-freq . 

что интересно - вроде как понижение частоты до минимальной у меня это 400МГЦ оно ведет к проблемам
что типа там идут большие токи утечки. по фату я вижу что если холостой цпу работает на частоте 550-700МГЦ
он также нагревается как на 400МГЦ. то есть уменьшенение частоты до 400МГЦ нихрена не охлаждает процессор.
это непонятно.

далее
мне вот эта статистика понравилась

# cpupower monitor
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6   || C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  0,81| 59,85|  0,00||  4,55| 95,45|   399||  0,00|  1,34|  0,03|  0,01|  0,96|  0,00| 11,17|  0,23| 81,87
   4|  0,00|  0,81| 59,85|  0,00||  0,78| 99,22|   399||  0,00|  0,00|  0,00|  0,02|  0,00|  0,00|  2,94|  0,08| 96,24
   1|  0,06|  1,56| 59,85|  0,00||  8,19| 91,81|   399||  0,00|  0,96|  0,65|  0,04|  0,72|  0,00|  9,19|  0,02| 80,31
   5|  0,06|  1,54| 59,85|  0,00||  2,47| 97,53|   399||  0,00|  0,00|  0,00|  0,03|  1,27|  0,00|  4,00|  0,10| 92,19
   2|  0,01|  0,87| 59,85|  0,00||  1,07| 98,93|   399||  0,00|  0,00|  0,37|  0,01|  0,25|  0,00|  2,55|  0,00| 95,81
   6|  0,01|  0,87| 59,85|  0,00||  0,53| 99,47|   399||  0,00|  0,00|  0,00|  0,00|  0,65|  0,00|  2,28|  0,00| 96,57
   3|  0,11|  0,92| 59,85|  0,00||  2,22| 97,78|   399||  0,00|  1,18|  0,95|  0,14|  1,03|  0,00|  7,80|  0,00| 86,78
   7|  0,11|  0,92| 59,85|  0,00||  0,87| 99,13|   399||  0,00|  0,00|  0,00|  0,05|  0,07|  0,00|  1,79|  0,00| 97,07

она показывает что 81-97 процентов ядра проводят в С10 состоянии. это самое
супер глубокое энергосберегающее состояние. а значит и супер холодное.

кстати в x86_energy_perf_policy
des  означает желаемая частота а des 0 означает что это отдается на откуп цпу какую часатоту
он хочет в заданом диапазоне ту пусть и ставит что то типа того. короче это менять ненадо.

еще один прикол.нашел где есть статистика по тротлингу

# pwd
/sys/devices/system/cpu/cpu0/thermal_throttle
# ls -1
core_throttle_count
package_throttle_count

# cat *
0
0

откуда видно что ниаких тротлинов нет ура

еще бы вентилятор заставить работать на этом лэпопе. вообще было бы отлично


далее
я хочу погасить три ядра физ. и посмотреть что будет со статисткой уровня C10
нахоидим топологию ядер

#  cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list
0,4
1,5
2,6
3,7
0,4
1,5
2,6
3,7

получается у нас ядра выглядт так 
реальные ядра это 
0
1
2
3

гипертрединг ядра это 
4
5
6
7


надо в итоге оставить только ядра 0,4

для этого надо погасить ядра 1,2,3,5,6,7

echo 0 | tee /sys/devices/system/cpu/cpu{1,2,3,5,6,7}/online

так вот прикол в том что ядро cpu0 оно вообще не имеет этого дачтика online! тоесть 
его при всем желании не погасить никак ! прикол!


смотрим статистику

# cpupower monitor
WARNING: at least one cpu is offline
    | Nehalem                   || Mperf              || Idle_Stats                                                   
 CPU| C3   | C6   | PC3  | PC6   || C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,42|  7,04| 52,67|  0,00|| 12,43| 87,57|   686||  0,00|  0,01|  1,32|  0,35|  6,02|  0,00| 78,17|  0,32|  1,59
   4|  0,42|  7,04| 52,67|  0,00|| 15,29| 84,71|   687||  0,00|  0,15|  0,80|  0,54|  6,56|  0,00| 76,08|  0,00|  0,79


 а ну прикол!  у нас все оффлайн ядра исчезли из статистики!

# echo 1 | tee /sys/devices/system/cpu/cpu{1,2,3,5,6,7}/online


 # cpupower monitor -m "Idle_Stats"
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  1,58|  0,30|  0,01|  0,11|  0,00| 16,59|  0,37| 73,44
   4|  0,00|  0,67|  0,02|  0,03|  0,94|  0,00| 10,99|  0,51| 84,06
   1|  0,00|  0,39|  0,02|  0,01|  1,10|  0,00| 17,26|  0,64| 77,65
   5|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,11|  0,00| 91,62
   2|  0,00|  1,08|  0,07|  0,13|  1,83|  0,00| 19,10|  0,00| 75,30
   6|  0,00|  1,82|  0,04|  0,03|  0,75|  0,00| 13,01|  1,99| 80,68
   3|  0,00|  0,31|  0,00|  0,00|  0,23|  0,00|  6,12|  0,00| 92,54
   7|  0,00|  0,00|  0,00|  0,00|  0,06|  0,00|  0,97|  0,00| 23,73


а вот еще прикол. на одном буке у меня вот такие C-state доступны
# cat ./cpu0/cpuidle/state*/name
POLL
C1
C1E
C3
C6
C7s
C8
C9
C10


а на другом только такие
# cat ./cpu0/cpuidle/state*/name
POLL
C1
C1E
C3
C6
C7s

и статистика на том другом выглядит вот так

# cpupower monitor 
intel-rapl/intel-rapl:0
0
intel-rapl/intel-rapl:0/intel-rapl:0:2
0
intel-rapl/intel-rapl:0/intel-rapl:0:0
0
intel-rapl/intel-rapl:0/intel-rapl:0:1
0
    | Nehalem                   || SandyBridge        || Mperf              || RAPL                        || Idle_Stats                              
 CPU| C3   | C6   | PC3  | PC6  || C7   | PC2  | PC7  || C0   | Cx   | Freq || pack  | dram | core | unco  || POLL | C1   | C1E  | C3   | C6   | C7s   
   0|  0,22|  0,08| 21,75|  2,49|| 93,90| 52,54|  0,00||  3,48| 96,52|   797||8397744|1695247|113953|112060||  0,00|  0,78|  1,02|  0,26|  0,08| 94,43
   1|  0,01|  0,00| 21,75|  2,49|| 94,18| 52,54|  0,00||  4,50| 95,50|   797||8397744|1695247|113953|112060||  0,00|  0,00|  0,99|  0,01|  0,00| 94,50


RAPL это 
Most modern processors, including Intel processors, provide Running Average Power Limit (RAPL) interfaces for reporting the accumulated energy consumption of various power domains (for example, PP01 or Package).


еше прикол щас покажу команду и откуда она берет свои цифры
и обозначу папку "/sys/devices/system/cpu/cpu0/cpufreq" как ".../" иначе в экране не влезет

# cpupower frequency-info
analyzing CPU 0:                  <=== процессор CPU0
  driver: intel_pstate            <=== взято отсюда  .../intel_pstate
  CPUs which run at the same hardware frequency: 0
  CPUs which need to have their frequency coordinated by software: 0
  maximum transition latency:  Cannot determine or is not supported.
  hardware limits: 400 MHz - 1.60 GHz                 <=== взято из .../cpuinfo_{min,max}_freq
  available cpufreq governors: performance powersave  <=== взято из .../scaling_available_governors
  current policy: frequency should be within 400 MHz and 700 MHz. <=== взято из .../scaling_{min,max}_freq
                  The governor "powersave" may decide which speed to use
                  within this range.
  current CPU frequency: Unable to call hardware  <=== это он искал cpuinfo_cur_freq но его нет
  current CPU frequency: 639 MHz (asserted by call to kernel) <=== взято из .../scaling_cur_freq 
  boost state support:
    Supported: yes
    Active: yes



отсюда видно что cpupower утилита она все берет из папки "/sys/devices/system/cpu/cpu0/cpufreq"
это значит что она полностью игнорирует настройки  в папке "/sys/devices/system/cpu/intel_pstate"
а между прочим игнорировать ее нельзя . потому что там находятся настройки которые перебивают их.
поэтому в целом показатели cpupower могут быть соврешенно некоректные!



далее
поставим
программу cpufreq
она прикольно показывает всякие параметры работы цпу
но поставить ее непросто. надо поебаться

$ mkdir -p ~/temp/cpufreq
$ cd ~/temp/cpufreq
$ wget https://github.com/cyring/CoreFreq/archive/refs/heads/master.zip
$ unzip master.zip
$ cd /CoreFreq-master 
# apt install make

далее на дистрибутиве lubuntu возникли проблемы с установкой пакета build-essential
пришлось выкорячиваться

# apt-get install dpkg-dev
# apt-get install aptitude
# aptitude install g++
он напишет портянку от том что он неможет поставить этот пакет
жмем "n"
он напишет что может задаунгрейдить чтото там.
жмем "Y"
еще портянка
жмем "Y"
в итоге пакет установится

(это решение нашел спасибо здесь https://serverfault.com/questions/993576/debian-apt-install-build-essential-fails-because-of-unmet-dependencies)

теперь наконец то можем установить build-essential
	# aptitude install  build-essential

потом надо вставить еще одну хрень
	# apt install dwarves

>>==
теперь наконец можно переходить к компиляции программы!!!

>>==
однако перед этим нужно исправить 
файл Makefile

было 

.PHONY: module-install
module-install:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install


стало

.PHONY: module-install
module-install:
	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
	depmod -A   <==== новая строка

здесь важно то что когда вставляем "depmod -A" надо использовать <TAB> а не пробелы
иначе при компилировании выдаст ошибку

>>==

сборка и установка
# make
# make install

>>==

теперь надо исправить systemd unit
он тоже написан калично

# cat /usr/lib/systemd/system/corefreqd.service

# CoreFreq
# Copyright (C) 2015-2023 CYRIL COURTIAT
# Licenses: GPL2

[Unit]
Description=CoreFreq Daemon

[Service]
Type=simple
ExecStart=/usr/bin/corefreqd -q
ExecStop=/bin/kill -QUIT $MAINPID
RemainAfterExit=no
SuccessExitStatus=SIGQUIT SIGUSR1 SIGTERM
Slice=-.slice

[Install]
WantedBy=multi-user.target
[root@lenovo system]# 


была неверная строка
ExecStart=corefreqd -q
правильная строка
ExecStart=/usr/bin/corefreqd -q

>>==

наконец
запуск всей этой хрени

# systemctl daemon-reload

# modprobe corefreqk
если вылезает ошибка 
modprobe: FATAL: Module corefreqd not found in directory /lib/modules/6.2.0-33-generic

то идем в 
/lib/modules/$(uname -r)/extra
# dempod -A
 modprobe corefreqk 
           
# systemctl start  corefreqd
  systemctl status corefreqd


>>==

в случае успешной установки мы должны получить файлы:

сервис
	/usr/lib/systemd/system/corefreqd.service
утилиты
	/usr/bin/corefreq-cli
	/usr/bin/corefreqd
модуль
	/lib/modules/$(uname -r)/extra/corefreqk.ko

>>==

наконец
запускаем клиента

# corefreq-cli

получаем на экране профит 
ура. конец установки



возвращаюсь  к чтению этой доки ( https://docs.kernel.org/admin-guide/pm/intel_pstate.html#energy-vs-performance-hints)

поражает сколько бесполезного мислидинг булшита состоят доки в том числе и по intel_pstate.
тоесть хрень в доках это одно а практика это совсем другое

то есть прикольно уже зная как на практике все настраивать и читая доку я как бутто читаю некую хрень
про чтото другое. нифига не узнаю . вот суки

пишут что есть датчик scaling_cur_freq  в котором текущая частота цпу. это полная хуйня. 
когда работает драйвер intel_pstate этого датчика нет. суки

чтобы на процессоре отключить модуль HWP надо в GRUB прописать intel_pstate=no_hwp
видимо тогда будет тот самый passive режиме intel_pstate но пока об этом все.

далее они пишут что если intel_pstate+active+performance то ядро запишет 0 в EPP.
таким макаром по любасу цпу переходит в режим перфоманса
хотя насколко  я проверял на практике если гавернер performance чтобы ты ни пихал в EPP  похуй 
ни на что не влияет.
далее походу читаю про разгадку - сам драйвер записывает в EPP 0 и то что указано в sys становится
похуй. также написано что попытки переписать EPP через sys якобы будут отвергнуты. непонятно кем отвергнуты
ядром или самим цпу. также непонятно если я будут это делать через x86_energy_perf_policy оно будет отвергнуто
или что. насколько я помню я ставил гавернер перфоманс и менял настройки через x86_energy_perf_policy и
цпу было похуй. я еще раз проверил на практике. 
я активировал гавернер перфоманс
поставил верхнюю частоту на 1200 MHZ
и на цпу даже на холостом ходу частота стала 1200
 далее  через x86_energy_perf_policy  я увидел что реально EPP стал 0
и далее через x86_energy_perf_policy я изменил epp  на 255 и он изменился
но  цпу как херачил на скорости 1200 на холостом ходу так и херачил.
так что похуй на то что изменения в sys не будут записан в цпу. если даже они будут записаны в EPP
то в целом этом никак не влияет если гавернер performance. то есть я постулирую то что если гавернер
performance то не знаю кто (цпу гавернер ядро) но по факту EPP то хинты полностью игнорируются. 


значит далее я читаю неожиданную хрень. если  у нас в grub выставлено
intel_pstate=no_hwp
то драйвер будет работать все в том же active режиме ( WTF?)
или если в GRUB выставлено
intel_pstate=active
но цпу не имеет HWP подсистемы
в обоих этих случаях дока ебнутая пишет что все равно драйвер будет работать в active
режиме. по моему хуйня полная

это у них называется active режим без HWP. 
что за хрень ?

в этом режиме у нас опять же два гавернера performance и powersave и работают они также

далее
если в  GRUB мы выставим  intel_pstate=passive
то наконец то мы добрались до пассивного режиме
далее эти долбоебы противоречат сами себе и пишут что если intel_pstate=no_hwp то это тоже 
пассивный режим (WTF?)

достоверным признаком этого режима является scaling_driver=intel_cpufreq

они как я понял пишут о том что гавернеры это не порождение драйвера а порождение кода cpufreq
гавернеры обращаются к драйверу чтобы они переключил cpu  в некоторый P-state.
это верно для "обычных" cpufreq драйверов типа acpi-freq.
intel_pstate является исключением поскольку он подсовыывает системе свои гавернеры которые не являются
порождением cpufreq.

MSR - model-specific registers

далее я узнал что есть еще одна утилита которая показывает расширенную инфо об цпу
		# turbostat
в частности она показывает инфо о C-states
и про TDP
например там вот такое можно увидеть
		cpu0: cpufreq driver: intel_pstate
		cpu0: cpufreq governor: powersave
		cpufreq intel_pstate no_turbo: 1

также можно увидеть там и такое
		cpu0: MSR_HWP_CAPABILITIES: 0x01071027 (high 39 guar 16 eff 7 low 1)
		cpu0: MSR_HWP_REQUEST: 0xff000704 (min 4 max 7 des 0 epp 0xff window 0x0 pkg 0x0)

тоесть ровно тоже самое что показывает x86_energy_perf_policy утилита

ксатти вот эти загадочные названия MSR_HWP_CAPABILITIES это то ли название регистра
то ли название группы битов в регистре MSR




оказалось много всего. оказалось что у проца есть TDP - мощность сколько ватт он выделяет 
на макс нагрузке. так вот этих TDP может быть несколько. если изменить (через регистры) этот TDP
то у проца меняется его макс нетурбо частота. например была 1600 MHz а станет 1800MHz
изменение TDP из ряда возмоожных отдают на откуп например создателям ноутбуков. как я понял стартует
ноутбук. и его биос сует в регсистр цпу какой TDP ему назначить. исходя из этого у цпу ноутбука
возникает его текущая макс нетурбо частота.  TDP выбирают в зависимости от мощности кулера ноутбука.
также получается что можно руками подкрутить этот TDP до следующего ребута.

один из способов программа corefreq-cli которую я ставил выше.
как конкретно я не знаю. мой цпу поддерживает TDP (10W, 15W, 25W).
мой текущий TDP 15W. я бы хотел снизить до 10W.

вроде бы для начала нужно изучит регистр MSR_RAPL_POWER_UNIT он имеет так называемый адрес 
читать из него можно через 
		# rdmsr 
только нужно указать адрес регистра. вроде бы для моего цпу его адрес 0x606

вроде бы адрес регистра можно узнать тут
MSR_RAPL_POWER_UNIT is in Volume 3
List of all MSR for each model is in Volume 4
https://software.intel.com/en-us/articles/intel-sdm


спецификация этого регистра
		 (взял здесь https://gist.github.com/Mnkai/5a8edd34bd949199224b33bd90b8c3d4)

606H MSR_RAPL_POWER_UNIT (RO)
    3:0 = Power unit (W) = 1/2^(decimal)W - def: 0.125W
    12:8 = Energy unit (J) = 1/2^(decimal)J - def: 0.00006103515625J
    19:16 = Time unit (sec) = 1/2^(decimal)sec - def: 0.0009765625sec

согласно tirbostat 
я вижу вот что
		cpu0: MSR_RAPL_POWER_UNIT: 0x000a0e03 (0.125000 Watts, 0.000061 Joules, 0.000977 sec.)


если я его считываю 
	# rdmsr   0x606
			a0e03
то получаю тоже самое число

считываем биты с 0 по 3
		# rdmsr --bitfield 3:0 -d 0x606
			3
согласно вот этой формуле
		   3:0 = Power unit (W) = 1/2^(decimal)W - def: 0.125W
		   получаем что Power unit (W) = 1/2^3 = 0.125 W
то есть ровно тоже самое что нам показывает turbostat

вообще юзаю эту статью
		https://gist.github.com/Mnkai/5a8edd34bd949199224b33bd90b8c3d4

когда мы нашли Power unit мы можем вычислить Power Limit 1 (хрен знает что это значит)
для этого
	# rdmsr --bitfield 14:0 -d 0x610
    144
эту хрень надо умножит на Power Unit и мы получ ватты

144 * 0.125 = 18 W
Это некий Power Limit 1
его можно найти в turbostat
	cpu0: PKG Limit #1: ENabled (18.000000 Watts, 28.000000 sec, clamp ENabled)

обычно люди крутят эти параметры чтобы поднять например турбо частоту или както вобщем разогнать цпу
. я бы наоборот хотел бы понизить частоту штатную. но в итоге  слишком на старте что дальше делать непонятно.
поэтому пока это сворачиваем.

дальше есть полезная штука как  наблюдать за текущей мощностью на цпу и его температурой
# turbostat --Summary --interval 5 --show Avg_MHz,Busy%,Bzy_MHz,IRQ,PkgTmp,PkgWatt,GFXWatt
...
Avg_MHz		Busy%		Bzy_MHz		IRQ			PkgTmp	PkgWatt		GFXWatt
13				2.03		643				3284			40		0.83			0.01
15				2.35		626				3247			40		0.85			0.01
13				1.94		648				3127			40		0.83			0.01
16				2.50		650				3080			40		0.86			0.01      <== idle нагрузка 0.86 W
52				8.32		627				7985			41		1.22			0.05
38				5.85		651				6194			40		1.17			0.10
410				58.70		698				10009			41		2.46			0.05
698				99.75		700				12568			42		3.46			0.01      <== нагрузка stress  3.46 W
698				99.76		700				12438			42		3.49			0.00
175				25.05		700				6202			41		1.55			0.03
19				2.89		672				3879			41		0.91			0.02
12				1.90		636				2999			41		0.83			0.00
21				3.31		638				4114			41		0.94			0.03
26				4.20		628				4782			40		1.02			0.04
12				1.90		635				2116			41		0.82			0.01


расшифровка полей
Avg_MHz = number of cycles executed divided by time elapsed.  Note that this includes idle-time when 0 instructions are executed.
Busy% = percent of the measurement interval that the CPU executes instructions, aka. % of time in "C0" state.
Bzy_MHz = average clock rate while the CPU was not idle (ie. in "c0" state).


что интересно. вот я зафигачил нагрузку на комп. сверху  ограничил частоту в всего 700 MHz
и при этом уже температура на цпу 42 градуса. по моему хреновое охлаждение на цпу. 
хотя насколько я понимаю вентилятор в этом лаптопе начинает вращаться где то после 40 градусов.
а до этого считай пассивное охлаждение.

что еще интересно. что этот цпу он же имеет встроенный видеоконтроллер. и показана 
нагрузка на видеоконтроллер. до этого я никак не мог найти инфо как эту нагрузку смотреть.
ну хотя бы  в ваттах она показана.

я вот еще нашел там датчики загрузки gpu в этом процессоре

# turbostat --Summary --interval 5 --show PkgTmp,GFX%rc6,GFXMHz,GFX%C0,CPUGFX%,GFXWatt
...
PkgTmp	GFX%rc6		GFXMHz	GFX%C0	CPUGFX%	GFXWatt
40			96.87			300			2.86		2.04		0.03
40			85.71			300			14.36		4.41		0.15
40			86.15			300			13.36		13.29		0.14
40			87.14			300			12.41		4.24		0.13
40			86.10			300			13.37		3.62		0.14
40			85.13			300			14.07		3.95		0.15
40			84.71			300			14.87		3.55		0.15
40			86.46			300			13.19		2.87		0.14
41			72.12			300			27.46		11.98		0.28
40			99.16			300			0.65		0.32		0.01
40			99.30			300			0.51		0.50		0.00
40			98.09			300			1.91		1.02		0.02


на счет  GFX%rc6 - The percentage of time the GPU is in the "render C6" state, rc6, during the measurement interval. From /sys/class/drm/card0/power/rc6_residency_ms
не очень понятно все таки что оно показывает

а на счет остального очень понятно. 

только для начала поговорим что значит C0 состоние у цпу. C0 это значит он что то делал. 
в отличии от других C1-..C10 стейтов когда он нихрена не делал. То есть C0 это состояние 
отличное от Idle. Оно выражается в процентах. У нас есть контрольный интервал времени. 
Скажем 30% времени внутри интервала процессор что то делал. Значит 70% времени он был Idle.
далее надо понять что (пусть для простоты в заданном интервале мониторинга частота не менялась и была равна 1000 MHz)
если процессор что то делал то он делал это на частоте 1000 MHz и полностью был занят.
а если он ничего не делал то ничего не делал. тоесть циклы  шли так  1000MHz 1с потом idle 1c потом 1000MHz 2с
потом idle 1c
то есть цпу работает очень просто. некоторый интервал когда он под нагрузкой причем херачит он 
на полную в этот момент. потом интервал ни хера не делания. потом опять интервал работы под нагрузкой.
фишка тут в том что цпу либо работает на полную либо ни хрена не работает. поэтому C0 он показывает 
какой процент времени из заданного интервала мониторинга цпу работал на полную а какую ни хрена не делал.
поэтому С0 в точности обозначает "Cpu Usage" тот самый который показан в top.
столбики в top показывают ровно тоже самое. если мы говорим что цпу занят на 80% это значит 
что 20% времени за интервал мониторинга он нихрена не делал. а 80% времени он выполнял команды на той частоте
которая в тот момент на нем была. (для простоты пусть частота константа). поэтому что важно понять что 
цпу не работает "частично". он либо исполняет команды на полной своей мощности исходя из той частоты которая 
на нем есть. либо находится в Idle. поэтому понятия цпу загружен частично на 40% относится не к тому что 
цпу был как бы не неполной мощности выполнял команды. нет. это обозначает что он не все время за интервал 
выполнял команды. но когда он их выполнял он делал это макс быстро как мог на основе той частоты которая 
на нем была. поэтому простаивающий на 50% процессор означает не то что он сейчас команды как на половине
мощности исполняет. а половина его мощности нерасходуется. нет. это означает что половина времени 
за скажем 1с процессор нихера не делал. а половину времени он херачил но полной мощности. ибо у цпу нет
половинной мощности. он либо делает на той часатоте на которой раотает. либо нихера неделает.
ну конечно дополнительно вспоминаем что частота на нем тоже может прыгать. но это нам щас неважно.
важно то что показатель C0 это как раз таки тот самый показатель в top.
если  мы видим в top что цпу занят на 20%. это значит что за 5с (по моему это дефолтовый интервал мониторинга времени) цпу 20% работал. а 80% был idle.
и этот параметр в точности отображается через C0.
другое дело что если  у нас за интервал мониторинга цпу работал все время то у нас и C0 и top покажут
100% загрузцу цпу, но внутри этого интервала процессор может часть времени работать на частоте 700MHz а часть времени на 2000MHz и это никак из C0 или top не увидеть. именно поэтому скажем atop показывает 
не только загрузку по времени (как top) но и частоту на которой работает цпу.

так вот 
GFX%C0 - по аналогии это  C0 стейт только для GPU.

возвращаемся к графику
# turbostat --Summary --interval 5 --show PkgTmp,GFX%rc6,GFXMHz,GFX%C0,CPUGFX%,GFXWatt
...
PkgTmp	GFX%rc6		GFXMHz	GFX%C0	CPUGFX%	GFXWatt
40			96.87			300			2.86		2.04		0.03
40			85.71			300			14.36		4.41		0.15
40			86.15			300			13.36		13.29		0.14
40			87.14			300			12.41		4.24		0.13
40			86.10			300			13.37		3.62		0.14
40			85.13			300			14.07		3.95		0.15
40			84.71			300			14.87		3.55		0.15
40			86.46			300			13.19		2.87		0.14
41			72.12			300			27.46		11.98		0.28
40			99.16			300			0.65		0.32		0.01
40			99.30			300			0.51		0.50		0.00
40			98.09			300			1.91		1.02		0.02

и видим что частота gpu 300 MHZ
ватты почти он не жрет
и мы видим его C0. мы видим нагрузку на gpu аналогичную как top показывает для cpu.
видим что она 3-28% и это круто. потому что больше пока я не встречал инструментов чтобы 
смотреть загрузку gpu из cli!

далее я взял другой лаптоп thinkpad и на нем запустил opengl бенчмарк
и вот что увидел

PkgTmp  GFX%rc6 GFXMHz  GFXWatt
42      98.62   200     0.00
42      98.64   200     0.00
43      98.62   200     0.00
43      98.63   200     0.00
40      95.54   200     0.02
40      95.92   200     0.02
39      99.12   200     0.00
40      92.64   200     0.04
40      95.22   200     0.05
39      93.28   200     0.04    <=== до запуска бенчмарка
44      90.08   1150    0.48
47      0.00    1150    15.90   <=== после запуска бенчмарка
49      0.00    1150    15.93
51      0.00    1150    16.10
50      0.00    1150    15.93
51      0.00    1150    16.76


видно что частота подпрыгнула с 200 МГЦ до 1150 МГц и ватты подпрыгнули. и температура всего процессора
подпрыгнула. и видно что "GFX%rc6" упало в ноль. из чего я делаю вывод что "GFX%rc6" это некий показатель
что gpu находится в idle состоянии.

так вот имея такой золотой инструмент я что обнаружил
что ебаный хром при просмотре кино сука практически неиспользует gpu видеокарту
и все приходится делать цпу а файрфокс использует. показываю

вот это idle система thinkpad
Busy%   Bzy_MHz PkgTmp  GFX%rc6 GFXMHz  PkgWatt GFXWatt
2.65    928     40      99.56   200     7.90    0.00
3.02    926     40      99.56   200     7.90    0.00


(две строчки потому что  в системе два физ ядра)

видно что цпу работает на частоте ~900 MHz. что почти не занят ничем usage ~ 3%
что gpu имеет частоту 200 MHz и что на 96% gpu находится в состоянии idle.


далее будем тестировать thinkpad и lenovo
на браузерах опера и хром  и на ютуб и кино 
и смотрим где меньше грузится цпу и больше грузится видеокарта


для снятия статистики юзаю команду
# turbostat  --quiet --Summary --interval 10 --show   PkgTmp,Busy%,Bzy_MHz,PkgWatt,GFX%C0,CPUGFX%,GFX%rc6,GFXMHz,GFXWatt


lenovo:
opera youtube 720 dpi
Busy%	   Bzy_MHz	 PkgTmp	  GFX%rc6	  GFXMHz	GFX%C0	CPUGFX%	PkgWatt	GFXWatt
27.00	   674	       38	     86.90	   300   	12.24	   7.29	   1.84	   0.12

chrome youtube 720 dpi
Busy%	   Bzy_MHz	 PkgTmp	  GFX%rc6	  GFXMHz	GFX%C0	CPUGFX%	PkgWatt	GFXWatt
26.72	   671	       38	     70.63	   300	  27.41	   15.69	 1.97	   0.23

получатеся цпу нагружен одинаково и видеокарта нагружена  в 2 раза больше чем у оперы

opera кино 720 dpi
Busy%	   Bzy_MHz	 PkgTmp	  GFX%rc6	  GFXMHz	GFX%C0	CPUGFX%	PkgWatt	GFXWatt
57.51	    697	       40	      29.14	   300	   69.77	  65.01	  3.23	 0.64


chrome кино 720 dpi
Busy%	   Bzy_MHz	 PkgTmp	  GFX%rc6	  GFXMHz	GFX%C0	CPUGFX%	PkgWatt	GFXWatt
40.06	   689	       38	      6.49	   300	   93.07	  75.07	 3.06	   0.73



у оперы цпу нагружен больше а видеокарта меньше

ну вроде как выгоднее хром запускать в плане просмотра видео контента....


я такую фишку открыл что если видео открыть на весь экран то и цпу и gpu нагружены меньше.
тоесть такое ощущение что когда видео маленькое не на весь экран то нужно много цпу чтобы 
ее смаштабировать в мелку картинку. удивительно.


есть еще инструмент которым смотреть загрузку gpu.
для встроенных видеокарт от интел это 
	# apt-get install -y intel-gpu-tools
	# intel_gpu_top
только утилита какая уебищная. там в интеле видимо имбицилам дали ее написать


далее смотрим на thinkpad
opera
кино 720 dpi
Busy%	  Bzy_MHz	PkgTmp	GFX%rc6	GFXMHz	PkgWatt	GFXWatt
55.04	   1250	   43	     63.72	200	     13.44	2.08
56.11	   1260	   43	     65.13	1100	   13.50	2.09
55.66	   1252	   43	     65.01	800	     13.43	2.06
60.28	   1263	   44	     62.31	1100	   13.71	2.08
55.16	   1253	   44	     61.39	1100	   13.47	2.09
56.19	   1246	   44	     60.96	200	     13.48	2.05
55.22	   1256	   43	     66.07	400	     13.42	2.09
55.03	   1255	   44	     69.21	200	     13.34	2.07
54.08	   1247	   44	     61.58	1000	   13.42	2.11
52.38	   1250	   43	     68.52	800	     13.16	2.06
55.28	   1256	   44	     61.95	1100	   13.43	2.07


chrome
кино 720 dpi
Busy%	  Bzy_MHz	PkgTmp	GFX%rc6	GFXMHz	PkgWatt	GFXWatt
58.65	   1270    43	     21.82	500	     13.73	1.88
59.98	   1272	   44	      1.59	200	     14.21	2.05
66.59	   1280	   44	     21.75	200	     14.08	1.86
61.61	   1278	   43	     16.73	200	     14.02	1.94
51.96	   1257	   43	      8.93	200	     13.59	1.89
54.95	   1257	   43	      6.64	200	     13.90	2.11
51.65	   1254	   44	     18.26	200	     13.58	2.01
55.23	   1264	   44	      2.46	200	     13.92	2.02
52.37	   1260	   42	      0.00	200	     13.84	2.06

что касается нагрузки на цпу то одинаково а это главное
хром больше грузит gpu но его частоту задирает мало
а опера меньше по времени грузит gpu но сильно задирает его частоту
но в целом еще раз скажу что вроде как похеру что там на gpu потому что на нагрузку цпу 
это никак не влияет а значит какая разница.




я для себя окончательно убедился что "GFX%rc6" это "Idle time" у gpu


итак надежда влегку сменить TDP я не знаю как 
двигаем дальше

можно в grub вот так поставить
		intel_pstate=per_cpu_perf_limits
и тогда как я понял настройки егоные можно будет подкручивать не для всех ядер одноверменно
а для каждого ядра индивидуально

про эту хрень не понял
hwp_dynamic_boost
This attribute is only present if intel_pstate works in the active mode with the HWP feature enabled in the processor. If set (equal to 1), it causes the minimum P-state limit to be increased dynamically for a short time whenever a task previously waiting on I/O is selected to run on a given logical CPU (the purpose of this mechanism is to improve performance).

нашел еще один признак как понять в каком режиме (active, passive, off) работает intel_pstate
# cat /sys/devices/system/cpu/intel_pstate/status 
active

могу сказать сразу если драйвер этот вобще не используется то этой папки вобще не будет
поэтому настройку вида "off" мы не увидим никогда. дебилы

пишут что якобы в этот счетчик можно писать  и таким макаром сменить режим работы. кхм. сомневаюсь.

удивительно насколко огромные и в то же время бесполезные и пиздабольные доки для практики практически
не только бесполезные но и запутывающие

если драйвер работает в активном режиме то в scaling_driver будет intel_pstate
если драйвер работает в пассивном режиме то будет intel_cpufreq

если выставлено intel_pstate=per_cpu_perf_limits то max_perf_pct и min_perf_pct

далее эти мудаки опимсывают то к чему я пришел. главым регулятором является no_turbo
менее главным max_perf_pct и min_perf_pct
и самым ничтожно главным является scaling_max_freq , scaling_min_freq 

поразительно как писатели доки обходят самые важные тонкие и трудные моменты. просто блядь диву даюсь.
тоесть дока набивается якобы полным описанием жирным и в плане оглавления целостным
а на самом деле дока это фальшивая пустышка. суки

далее с каким настройками можно его запускать в grub

active, passive, disable  = тут все понятно
force = какая то хуйня
no_hwp = не понял в чем разница с passive
hwp_only = означает использовать только если проц поддерживает hwp. тоже хуйня какая то. в чем разница с active?

на этой странице добрые люди раскопали что если есть EPP то EPB игнорируется = https://bbs.archlinux.org/viewtopic.php?id=282383

далее 
прорабатываю вот это - https://www.grid5000.fr/w/CPU_parameters
как быстро проверить активирован прям щас ли HT
	# lscpu | grep 'Thread(s) per core
должно быть два

как по быстрому отключить все гипертред ядра
# for i in $(cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list | awk -F',' '{print $2}' | sort -u); do echo 0 > /sys/devices/system/cpu/cpu$i/online; done

вот так это выяглядит
# cat /sys/devices/system/cpu/cpu*/topology/thread_siblings_list
0,4
1,5
2,6
3,7
0,4
1,5
2,6
3,7

соотвественно они выбирают второй столбик и гасят его. это понятно

как обратно включить все ядра
	# for i in $(ls /sys/devices/system/cpu/cpu*/online); do echo $i; echo 1 > $i; done



далее
супер полезная штука
позволяет узнать с какими параметрами было запущено ядро
# cat /proc/cmdline
BOOT_IMAGE=/boot/vmlinuz-5.4.0-91-generic root=UUID=aa7152b0-f48f-4f20-ad1a-7e0c404584d3 ro systemd.unified_cgroup_hierarchy intel_pstate=enable quiet splash vt.handoff=1

посмотреть доступные C-states 
и их latency(скока время надо чтобы выйти из него видиом в наносекундах)
# cat /sys/devices/system/cpu/cpu0/cpuidle/state*/name
POLL
C1
C1E
C3
C6
C7s
C8
C9
C10
# cat /sys/devices/system/cpu/cpu0/cpuidle/state*/latency
0
2
10
70
85
124
200
480
890

а вот еще прикольно статистика сколько раз цпу был в том или ином C-state
# cat /sys/devices/system/cpu/cpu0/cpuidle/state*/usage
213289
6654993
62993531
18126375
8198970
288341
19190669
795233
22827462

ксати grep более нагляден
# grep "" ./state*/usage
./state0/usage:213365
./state1/usage:6658355
./state2/usage:63069668
./state3/usage:18148288
./state4/usage:8204885
./state5/usage:288341
./state6/usage:19202062
./state7/usage:795750
./state8/usage:22841770

еще вот так можно посмотреть 
# cpupower idle-info
CPUidle driver: intel_idle
CPUidle governor: menu
analyzing CPU 0:

Number of idle states: 9
Available idle states: POLL C1 C1E C3 C6 C7s C8 C9 C10
POLL:
Flags/Description: CPUIDLE CORE POLL IDLE
Latency: 0
Usage: 213414
Duration: 5459876
C1:
Flags/Description: MWAIT 0x00
Latency: 2
Usage: 6660290
Duration: 3345755923
C1E:
Flags/Description: MWAIT 0x01
Latency: 10
Usage: 63120135
Duration: 8695098018
C3:
Flags/Description: MWAIT 0x10
Latency: 70
Usage: 18163008
Duration: 1251233433
C6:
Flags/Description: MWAIT 0x20
Latency: 85
Usage: 8209184
Duration: 4718396659
C7s:
Flags/Description: MWAIT 0x33
Latency: 124
Usage: 288341
Duration: 485049448
C8:
Flags/Description: MWAIT 0x40
Latency: 200
Usage: 19209011
Duration: 36419309836
C9:
Flags/Description: MWAIT 0x50
Latency: 480
Usage: 796102
Duration: 2165680618
C10:
Flags/Description: MWAIT 0x60
Latency: 890
Usage: 22850358
Duration: 213721059571

еще вот так
# cpupower monitor -m Idle_Stats
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  1,71|  0,97|  0,11|  0,40|  0,00|  7,35|  0,03| 86,38
   4|  0,01|  1,83|  0,01|  0,06|  0,97|  0,00|  8,55|  0,00| 83,16
   1|  0,01|  1,59| 34,75|  4,04|  0,97|  0,00|  5,43|  0,00| 31,48
   5|  0,00|  0,00|  0,34|  0,31| 13,04|  0,00| 24,45|  0,44| 53,47
   2|  0,00|  1,26|  0,25|  0,34|  9,90|  0,00| 23,90|  0,57| 62,58
   6|  0,00|  0,45| 18,42|  1,97|  0,10|  0,00|  1,46|  0,00| 73,52
   3|  0,00|  0,01|  0,31|  0,01|  3,57|  0,00| 12,22|  1,60| 78,97
   7|  0,01|  0,91| 25,10|  2,60|  0,53|  0,00|  6,23|  0,02| 54,79

также в
		# powertop
	нажимаем Shift+Tab и попадем в секцию про C-states
закладка Overview показывает кто больше всего цпу будит . чаще всего

в этой же статье показано как отключать C-states ради перфоманса  https://www.grid5000.fr/w/CPU_parameters

если мы говорим про драйвер acpi-freq
то его гавернер powersave он смотрит только на scaling_min_freq и будет держать такую частоту все время
его гавернер performance он смотрит только на scalin_max_freq и будет держать эту частоту все время

пишут что cpufrequtils - старье и использовать ненадо. что это такое хрен знает
видимо это юзерская утилита потому что пишут что надо использовать cpupower

на счет турбо частота. если  у нас intel_pstate драйвер то настраивается через no_turbo
а если acpi-cpufreq то  настраивается через 
  # echo 1 > /sys/devices/system/cpu/cpufreq/boost
ценная инфа

в плане частот пишут что якобы частоты сверху можно ограничивать еще здесь
# cat scaling_available_frequencies 
2601000 2600000 2500000 2300000 2200000 2100000 2000000 1800000 1700000 1600000 1400000 1300000 1200000 1100000 900000 800000 


далее. что такое uncore
"Uncore" is a term used by Intel to describe the functions of a microprocessor that are not in the core, but which must be closely connected to the core to achieve high performance

если используется acpi-freq драйвер и userspace гавернер то можно прям точно задавать  частоту на которой
работать процессору вот так

# echo 700000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed 
# cat /proc/cpuinfo 
cpu MHz  : 697.252 
# echo 900000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed 
# cat /proc/cpuinfo 
cpu MHz  : 976.152

To enable userspace governor you must write userspace into
# echo userspace > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor


далее
какая то хуйня случилась с systemctl suspend оно теперь не работает.
вместо этого работает 
	# pm-suspend


далее.
надо было перезагрузить USB 
я это сделал вот так

for port in $(lspci | grep USB | cut -d' ' -f1); do
    echo -n "0000:${port}"| sudo tee /sys/bus/pci/drivers/xhci_hcd/unbind;
    sleep 5;
    echo -n "0000:${port}" | sudo tee /sys/bus/pci/drivers/xhci_hcd/bind;
    sleep 5;
done

буду разбирать это потом ниже


возвращаюсь к пдф статье

прикол есть intel speed step , есть eist (хуй знает что это ) а есть intel speed shift. суки

из баша кусок
		# echo $(( 8<<1 ))
			16
эта команда берет число 8 переводит в бинарный вид. сдвигает все биты на 1 влево. поэтому становится 16
	# echo $(( 16>>1 ))
		8
соотвественно наоборот. берем число 16 и сдвигаем на 1 бит вправо все биты
	# # echo  $(( 1 << 32 ))
    4294967296
эта команда берет число 1 и сдвигаем все биты на 32 позиции влево. получаем
10....0

эта хрень работает как битовый AND
	# echo  $(( 1 << 1 ))
	2
	# echo  $(( 1 << 1  & 3  )) 
	2

тоесть берется 2 и 3 и делается битовый 2 AND 3 ===> 10 AND 11 = 01 = 2
тоесть знак & это битовый AND

	
	# echo  $(( 1 << 1  |  3  )) 
	3
а это уже битовый OR
битовый OR дает нам то что мы таким макаром можем включить определенный бит.
скажем есть у нас число 7 = 111
и мы хотим включить восьмой бит у этого числа тогда 
	# echo  $(( 1 << 7  |  7  )) 
  135
  действительно
  1 << 7 = 100000000
  7 = 00000111
  тогда 100000000 OR 00000111 = 100000111 = 128+7=135
  надо учесть что 
  # echo  $(( 1 << 0 )) 
   1
  и команда означает сдвинь биты в числе 1 на ноль позиций
  и еще надо учесть что биты нумеруются с нулевого бита тогда если мы хотим сдвинуть биты на семь 
  позиций то 
  # # echo  $(( 1 << 7 )
  таким макаром команда
  # echo  $(( 1 << N  |  X  ))
  позволяет нам в числе X зажечь бит с номер N
  как говорится позволяет установить флаг

 далее вылезает тема как кодируются отрицательные числа в баше или где то там.
 если у нас MSB (самый старщий бит) равено 0 то число положительное
 если MSB =1 то число отрицательное. но есть еще момент чтобы из 7 получить -7 надо
 инвертировать все биты и еще добавить +1 пример

 7 = 0000 0111
 -7 =1111 1000 + 0000 0001 = 1111 1001
захрена так делать ? а чтобы +0 и -0 имели одинаковый бинарный вид тоесть
+0 = 0000 0000
-0 = 1111 1111 + 0000 0001 = 0000 0000

таким макаром чтобы из +N получить -N надо его битово инвертировать и прибавить 1
получается что если мы просто инвертируем биты у N то мы получаем -(N-1)
пример
	# echo $(( ~5 ))
   -6
возвращаюсь к моей задаче я хочу у числа N погасить бит k. как это сделать.
положим N=7
0000 0111
хочу погасить бит 2
посмотрим на его инвертированную форму
нам надо получить число
1111 1011
если мы сделаем AND то бит   2 погасится
0000 0111 AND 1111 1011 = 0000 0011 
число 1111 1011 можно получить путем инвертирования из числа 
      0000 0100 
а это число легко получить вот так 
0000 0100 = $ (( 1 << 2   ))
проверим
	# echo $(( 1 << 2   ))
		4
инвертируем
	# echo $((  ~(1 << 2)   ))
	-5
все верно
	# echo $((  7 & (~(1 << 2))   ))
   3
да все верно. 
было  0000 0111
стало 0000 0011

еше пример берем 16 = 0001 0000
хотим погасить 4 бит
	# echo $((  16  & (~(1 << 4))   ))
    0
да все верно

берем число 129 = 1000 0001
хотим погасить 7-ый бит

	#  echo $((  129  & (~(1 << 7))   ))
		1
да все верно
таким макаром появилась формула как в числе N установить бит k
	# echo  $(( 1 << N  |  k  ))
и как его погасить
  # echo $((  N  & (~(1 << k))   ))

пример когда вначале устанавливаем бит 7 в числе 7 а потом сбрасываем бит 7 обратно
	# echo  $(( 1 << 7  |  7  ))
		135
	# echo $((  135  & (~(1 << 7))   ))
		7

все верно


далее исходя из pdf то активировать Turbo частоты можно через "MSR IA32_MISC_ENABLE 0x1A0H" через его 38 бит
тогда делаю это исходя из битовых правил что выше открыл вот так
	# wrmsr -a 0x1a0H  $((  1 << 38  |   $(rdmsr -d 0x1a0H)   ))
проверяю
	# # cat /sys/devices/system/cpu/intel_pstate/no_turbo 
	1
параметр -a означает записать для всех cpu
интересно что sys папка intel_pstate она же неимеет подпапок связанных с индивидуальным цпу 
поэтому получается что когда мы пишем в no_turbo то ядро берет это число и самостоятельно пихает 
его в каждый MSR каждого цпу. а я думал что есть некий один универсальный MSR регистр который отвечает 
за турбо частоту. получается нет хрен там. у каждого ядра есть свой MSR регистра который отвечает за
турбо частоту.

дезактивируем обратно турбо частоту для всех ядер
	# wrmsr -a 0x1a0H  $((  $(rdmsr -d 0x1a0H)    & (~(1 << 38))       ))
	# cat /sys/devices/system/cpu/intel_pstate/no_turbo 
  0
все сработало!
главное помнить что wrmsr юзать с ключом -a
если без него юзать то видимо он записывает только в цпу0 потом когда проверяю результат
через /sys то вижу что no_turbo без изменений. ксати это вопрос если в одних цпу активирован турбо
в других дезактивирован то что отображается в /sys no_turbo. хрен знает проверяеть не буду.

еще важный момент номер регистра обязательно писать с больших букв. иначе будут непонятный ошибки.

далее написано что номер текущего P-state (кстати я все это рассматриваю когда у нас драйвер intel_pstate)
работает ли это если драйвер acpi-freq незнаю надо проверять но не буду.
так вот номер текущего P-state можно подсмотреть в MSR IA32_PERF_STATUS 0x198H в битах 15:0
смотрим

# rdmsr -a  -d 0x198H  --bitfield 15:0  
1792
1792
1792
1792
1792
1792
1792
1792

ключ -а говорит что надо прочитать на всех ядрах. по дефолту только с ядра 0 считывает.

далее там написано что драйвер intel_pstate если хочет сменить P-state то он кладет номер желаемого
стейта в MSR IA32_PERF_CTL 0x199H в биты 15:0

я попробовал формально работает тоесть хотя бы нахер не посылает 
 # wrmsr -a  0x199H  $(rdmsr -p 1  -d 0x199h) 
но по факту проверить работает или нет не возможно. потому что сам драйвер постоянно меняет 
у меня частоту между 600 и 700 MHz. поэтому я то ее выставляю а он то ее сразу сбивает.

наверно можно было бы попробвать на драйвере acpi-freq и гавернере userspace.
я проверил ксатти что если гавернер userspace то частоту текущую задаем через 
	# echo 80000 > scaling_setspeed
единственное что она должна лежать на отрезке 
		scalin_min_freq << scaling_setspeed << scaling_max_freq 


далее странно почему то на thunkpad-е + ubuntu22 + процессоре  i5-4210M 
я пытаюсь прочитать IA32_PERF_STATUS 0x198H а он пишет что 
	Failed to parse register number

я скачал sdm vol4. там для всех процессоров IA32_PERF_STATUS имеет адрес 0x198H и никакой другой.
непонятно.

ксатати прога cpuid тоже подходит чтобы посмотреть инфо о процессоре
кстати intel SGX как я понял это такая хрень в цпу которую можно через биос активировать и дезактивировать
что прога может создават област в памяти к которым есть доступ только для проги.  с других прог втом
числе и ядра доступа туда нет. типа такая доп защита. 


ксатати rdmsr якобы поддерживает ввод адреса регистра через буквы
 #rdmsr -d IA32_PERF_STATUS --bitfield 15:0
но выводит какую то хрень. так что нахуй это.


вобщем я не понял из за его эта ошибка на thinkpad
		# rdmsr ...
			Failed to parse register number
не работает  с любыми MSR регистрами.


далее MSR регистры APERF (0xE8) MPERF (0xE7)
значит у нас есть некая TSC частота у компа ее можно узнать вот так
# journalctl --boot | grep 'kernel: tsc:' -i
сен 21 03:33:39 lenovo kernel: tsc: Detected 1800.000 MHz processor
сен 21 03:33:39 lenovo kernel: tsc: Refined TSC clocksource calibration: 1800.000 MHz

так вот как я понял MPERF этот счетчик увеличивается на 1 каждый цикл колебания на частоте TSC тоест 
в данном случае 1800 MHz. (ну там еще приписка что при условии что цпу находится в состоянии C0 но тем не менее)

а счетчик APERF он увеличивается на 1 на каждый цикл колебания но уже отталкиваясь ои текущей на данный момент частоты цпу.

поэтому текущую частоту цпу можно рассчитать как 
		F = (delta APERF - delta MPERF) * TSC
где delta это разница между двумя снятыми значениями.

пример
# rdmsr -d 0xE8 && rdmsr -d 0xE7
447779959355
1119623961280

# rdmsr -d 0xE8 && rdmsr -d 0xE7
447798498807
1119635791672

# echo "scale=8; (447779959355 - 447798498807 ) / (1119623961280 - 1119635791672)" | bc | xargs -I % echo "%* 1800" | bc
2820.78678600

получили 2820 MHz
что является верным

замечу что TSC частота она постоянная и не зависит от активации турбо и прочего. это константа все время.
получается что MPERF он по времени прибавляется равномерно потому что TSC не меняется.
а APERF прибавляется так быстро какова текущая частота цпу. если она медленее чем 1800 то будет прибавляться
медленее чем MPERF а если быстрее то быстрее.

таким макаром зная TSC и зная показания этих счетчиков можно узнавать текущую частоту цпу.

прикольно

далее немного обратно вернусь. в 0x198H биты 15:0 у нас указывается текущий P-state 
его номер.

так я взял зажал частоту на 400МГЦ и 700МГц чтобы она не дергалась
и посмотрел чему равен P-state

# cpupower frequency-set -d 400MHZ -u 400MHz
# rdmsr -a  -d 0x198H  --bitfield 15:0
1024
1024
1024
1024
1024
1024
1024
1024

# cpupower frequency-set -d 700MHZ -u 700MHz

# rdmsr -a  -d 0x198H  --bitfield 15:0
1792
1792
1792
1792
1792
1792
1792
1792

отсюда получаем закон если частота N то ее-ный 
	P-state = 2.56 * N


далее они пишут что на основе этих счетчиков также можно вычислить текущий P-state
по формуле
		P = (delta APERF - delta MPERF) * P(max)

где P(max) это макс P-state
я считаю что это полная хуйня. у меня P(max)= 3900MHz * 2.56 = 9984

если мы возьмем предыдущие значения
где мы получили 2820 MHz

# rdmsr -d 0xE8 && rdmsr -d 0xE7
447779959355
1119623961280

# rdmsr -d 0xE8 && rdmsr -d 0xE7
447798498807
1119635791672

то согласно моей формуле 
		P-state = 2.56 * N = 7219

а согласно их формуле
# echo "scale=8; (447779959355 - 447798498807 ) / (1119623961280 - 1119635791672)" | bc | xargs -I % echo "%* 9984" | bc
15645

что очевидно хуйня полная.
в их форулу нужно подставлять не P-max а P соотвествующий частоте TSC 1800MHz , тоесть 1800 * 2.56 = 4608
тогда
получим тоже самое что и по моей формуле
# echo "scale=8; (447779959355 - 447798498807 ) / (1119623961280 - 1119635791672)" | bc | xargs -I % echo "%* 4608" | bc
7221

далее.
как я понял P-state были и до speedShift но спид шифт часть работы по переходу в другой п-стейт
перенес на процессор(что конкретно было перенесено хуй знает) и это дало то что скорость переключения
на п-стейт стало быстрее в 10 раз
еще стало быстрее переключаться с п-стейта до макс частоты
но мне непонятно все равно зачем нам быстрее
особого профита не вижу
мы же непереключается с нуля до максимуа по 1000 раз в секунду. бред

нашел affected_cpus - там будет ядро и его гипертрединг братец

далее. есть сайт где подробно можно также посмотреть инфо про свой  цпу https://en.wikichip.org/wiki/intel/core_i5/i5-8265u

далее. оказывается есть группа инструкций AVX фишка в том что такая инструкция сжирает мегадохнера 
энергии поэтому чтобы процессор не сгорел во время выполнения этой инструкции цпу автоматом понижает свою 
частоту. вот пример таблицы для другого проца 
https://stackoverflow.com/questions/56852812/simd-instructions-lowering-cpu-frequency
для своего я не нашел.

в итоге можно получить прикол - из за того что у цпу уменьшается частота на AVX команде
на одном ядре - на других ядрах тоже частота будет понижена.как я понял только AVX-512 вызывают серьезное
понижение частоты. с остальными все не так плохо.

далее прикольная тема про C-states
как же цпу туда впадает? может быть сам? хуй там!
как я понял шедулер видит что в течение какогото времени цпу будет нехер делать
и тогда шедулер запускает HLT команду и цпу переходит в C1\C1E до того момента пока снаружи интеррапт
не прилетит! гениально.

или шедулер может запустить MWAIT команду и тогда цпу перейдет в более глубойи C* стейт

в пдфке рассматриваются режимы работы intel_pstate но опять же я так и непонял в чем разница
active without HWP по сравнению с passive режимом. эти суки опять сделали вид что вопросов тут нет

что касается C-states то у них тоже есть свои драйверы это intel_idle и acpi_idle
(ровно по аналогии с драйверами не idle состояний intel_pstate и acpi-freq)
текущйи драйвер можно определить через 
		# cat /sys/devices/system/cpu/cpuidle/current_driver
		intel_idle
а так есть два драйвера acpi_idle который типа лоховской например потому что он поддерживает только 
4 вида c-states и козырный это intel_idle
прадва непонятно нахцй это все нужно если все управляется через HLT и MWAIT команды
можно чтото подкручивать через grub
пдфка об этом пишет вот что:


If you want control over C-states, you should use kernel parameters:
intel_idle:
• intel_idle.max_cstate=0: this parameter disables the intel_idle, the Linux kernel will use the acpi_idle driver to use Cstates. System firmware (BIOS) provides a list of available C-states to the operating system using an ACPI table.
• intel_idle.max_cstate=n: Limit the maximum depth of C-state from n = 1 to 9 to specify maximum depth of C-state.
• Disable C1e: C1e can be disabled in BIOS setup for low latency. When C1E is enabled, the processor will try to lower
processor clock speed and voltage when it enters the C1 C-state, which might result in higher latency. From Linux kernel
3.9, the intel_idle driver treats C1 and C1E as separate states. So, the user can control whether C1E is used without
disabling it in BIOS setup.

acpi_idle (intel_idle disable):
• idle=poll: If a user wants the absolute minimum latency, kernel parameter “idle_poll” can be used to keep the processors
in C0 even when they are idle (the processors will run in a loop when idle, constantly checking to see if they are needed).
Hyperthreading should probably be disabled, as keeping processors in C0 can interfere with proper operation of logical
cores. It can improve the performance but will use a lot of power and make the system run hot, not recommended.
• idle=halt: C-states can also be limited to C1 with the kernel parameter “idle=halt”.
• Idle=nomwait: Disable mwait instruction for CPU C-states

далее я временно по idle хрени читаю вот это - https://docs.kernel.org/admin-guide/pm/cpuidle.html

как я понял когда в очереди шедулера нет тасков то там всегда есть таск Idle.
и шедулер помешает этот таск на цпу. в этом таске как я понял там стоят только команды HLT и MWAIT.
таким макаром у нас с точки зрения ОС на цпу всегда выполняется какаято таска. в частности  Idle таск.
а с физической точки зрения в этот момент цпу находится в спящем состоянии одном из C-states (кроме C0 который означает реально работающий цпу). хитро.
это типа как человек имеет список задач. а если задача нет то всегда есть задача - отдохнуть.
с точки зрения планировщика человек занимается отдыхом. а по факту он спит.

написано что Idle task или idle loop как они его зовут работает так - он вначале вызывает governer (про гавернеры idle состояий поговорим ниже)
тот ему там чтото предписывает а потом он  запускает драйвер (intel_idle\acpi_idle) который уже выполняет конкретную команду что ему предписал гавернер. 
вот откуда появляется Idle гавернер и idle драйвер.
потому что перед нами стоит хитрая задача - как нам поглубже засунуть в сон цпу но с другой стороны
угадать с интервалом времеи сна и тд. ведь у нас скоро цпу будет пробужен интерраптом.
как я понял задача гавернера подобоать оптимальную (не знаю с какой точки зрения) конкретную команду
конкретны уровень C-state в который цпу должен перейти. как это высчитывается непонятно. но именно для этого нужен гавернер. пишут то что гавернер принимает решение на абстрактном уровене. после этого шедулер обращается к драйверу. и он уже преврашает абстрактное решение в конкретику этого цпу.
все C-state характеризуются двумя парамтрами - сколько времени надо провести цпу в этот C-state чтобы сохранить больше энергии чем это было бы если бы он вошел в менее энергосберегающий режим. и второй параметр 
сколько времени надо цпу чтобы выйти из этого состояния в рабочее. непонятно первый параметр он включает в себя второй или нет. 
написано что гавернер знает сколько времени спал цпу до этого тоесть некая статистика как до этого было с ц-стейтами. также гавернер видит все таймеры через которые процессы в ОС должны будут быть пробужены в ближайшее время. но это не панацея потому что цпу может быть пробужен не только таймерами.

значит еще раз покажу где посмотреть текущий idle драйевер и текущий idle гавернер
	# cat /sys/devices/system/cpu/cpuidle/current_driver 
	intel_idle
	# cat /sys/devices/system/cpu/cpuidle/current_governor_ro 
	menu

самое интересное что у меня на леново эта папка выглядит по одному а на финкпаде по другому покаызываю
lenovo:
	# pwd
	/sys/devices/system/cpu/cpuidle
	# grep . -Ri
	current_governor_ro:menu
	current_driver:intel_idle

thinkpad:
		# pwd
		/sys/devices/system/cpu/cpuidle
		# grep "" -Ri
		current_governor:menu
		current_driver:intel_idle
		available_governors:ladder menu teo 
		current_governor_ro:menu

то есть видно что в леново нет датчика 
		available_governors:ladder menu teo
непонятно почему

итак тем не менее гавернеры бывают:
	ladder
	menu 
	teo

хотя дока говорит что еще должен быть haltpoll
но я его не вижу

в чем разница гавернеров пока не раскрывается

также я скажу в чем прикол если отключать C-states. помимо увеличения выделения тепла будет и профит
состоит в том что цпу всегда готов выполнять команды. поэтому всякие там сетевые передачи пакетов
и прочие хрени которые требуют низкой латенции все будут рады. идея как бы такая - прилеает пакет в сет карту.
это рождает интеррапт который летит на ядро цпу. а ядро в это время спит в C-10. и нужно время чтобы ядро пробудить. соответственно сетевой пакет его время обработки вырастает. если же мы вырубаем те или иные C-states то такой проблемы нет. 

далее рассматривается вот что. у нас регулярно срабатывает шедулер таймер интеррапт. то есть на цпу прилетает 
сигнал и если он спит то будет разбужен а если он чтото делал то прекратит это делать и в конечном итоге
управление будет передано на шедулер. так вот дока пишет то что если цпу уже находится в состоянии Idle
то будить его вредно потому что как я понимаю если его разбудить раньше времени то вся фишка в энергоэкономии
типа пропадет. правда при этом получается пропадает откликаемость системы.. но тем не менее идея такая - раз уж мы поместили цпу на какоето заданное заранее время в некоторый С-state то трогать его ненадо. 
так вот чтобы  сделать так чтобы на ядро находящееся в C-state не прилетал интеррапт нужно 
либо скомпилировать ядро в с опцией
	CONFIG_NO_HZ_IDLE=y
либо в GRUB указать 
	nohz=on
в этой статье 
	https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt 
читаю вот так про это 
	If a CPU is idle, there is little point in sending it a scheduling-clock
interrupt.  After all, the primary purpose of a scheduling-clock interrupt
is to force a busy CPU to shift its attention among multiple duties,
and an idle CPU has no duties to shift its attention among.

а! ну  я согласен! у нас шедулер таймер это строго периодический процесс целью которого является то что если 
за заданный слайс времени программа не собирается сама ( с помощью спец сисколла) возвращать управления обратно шедулеру то этот таймер через заданны слайс времени заставляет цпу прекратит выполнять то что он выполнял передать управление шедулеру который выкинет нахер код той  программы скорей всего и засунет на
цпу код другого процесса.  а если цпу у нас находится в Idle состоянии то никаких программ которые бы щас конкурировали за цпу нет. и вызывать шедулер просто напросто нахрен нет смысла! согласен.
насколько я понимаю данная настройка отключает на idle цпу прилет только интеррапта от таймера шедулера
все остальные интеррапты при этом остаются. так что если прилетит пакет в сетевую карту то его интеррапт
отлично будет направлен на цпу. так что все окей. я понял.
я где то читал что якобы если цпу в idle то ядро направит интеррапт на другое ядро которое не idle что 
тоже умно.

далее читаю в той же доке
	The CONFIG_NO_HZ_IDLE=y Kconfig option causes the kernel to avoid sending
scheduling-clock interrupts to idle CPUs, which is critically important
both to battery-powered devices and to highly virtualized mainframes.
A battery-powered device running a CONFIG_HZ_PERIODIC=y kernel would
drain its battery very quickly, easily 2-3 times as fast as would the
same device running a CONFIG_NO_HZ_IDLE=y kernel.  A mainframe running
1,500 OS instances might find that half of its CPU time was consumed by
unnecessary scheduling-clock interrupts.  In these situations, there
is strong motivation to avoid sending scheduling-clock interrupts to
idle CPUs.

все понятно

что касается терминов
	An idle CPU that is not receiving scheduling-clock interrupts is said to
be "dyntick-idle", "in dyntick-idle mode", "in nohz mode", or "running
tickless".  The remainder of this document will use "dyntick-idle mode".

там еще  в этой статье указаны всякие полезные моменты про это дело = https://www.kernel.org/doc/Documentation/timers/NO_HZ.txt


вовзращаемся обратно к исходной доке https://docs.kernel.org/admin-guide/pm/cpuidle.html
она говорит что если у нас тиклесс система то ее idle governor обычно равен menu
проверяем как у меня ядро было скомпилировано

# cat config-$(uname -r) | grep -i hz | grep -v '#'
CONFIG_NO_HZ_IDLE=y
CONFIG_NO_HZ=y

эти обе настройки как раз о том чтобы цпу в idle состоянии не было потревожено интерраптом шедулер таймера.
почему две настройки незнаю но вот как об этом написано в прошлой статье
	Omit scheduling-clock ticks on idle CPUs (CONFIG_NO_HZ_IDLE=y or
	CONFIG_NO_HZ=y for older kernels).  This is the most common
	approach, and should be the default.

посмотрим наш текущий idle гаверне
	# cat current_governor_ro 
	menu
ага. все совпадает

вот что статья (более верхняя) пишет о том как работает menu гаверне
	It first obtains the time until the closest timer event with the assumption that the scheduler tick will be stopped. That time, referred to as the sleep length in what follows, is the upper bound on the time before the next CPU wakeup. It is used to determine the sleep length range, which in turn is needed to get the sleep length correction factor.

далее опять малек отскакиваем назад. утилита powertop
она показвывает какие проги и прочие хрени больше всего заставляют цпу выходить из сна.
там тыкаем на Shift+tab и там всякие Tunables - параметры которые подкрутит в /sys чтобы 
меньше жрало энергию.
полезная прога.
правда после такой подкрутки могут быть приколы . например мышка начнет постоянно впадать в спящий режим.
хахаха.

и тогда нас спасет этот скрипт
for port in $(lspci | grep USB | cut -d' ' -f1); do
    echo -n "0000:${port}"| sudo tee /sys/bus/pci/drivers/xhci_hcd/unbind;
    sleep 5;
    echo -n "0000:${port}" | sudo tee /sys/bus/pci/drivers/xhci_hcd/bind;
    sleep 5;
done


двигаю дальше по документу
	The menu governor maintains two arrays of sleep length correction factors. One of them is used when tasks previously running on the given CPU are waiting for some I/O operations to complete and the other one is used when that is not the case. Each array contains several correction factor values that correspond to different sleep length ranges organized so that each range represented in the array is approximately 10 times wider than the previous one



в общем там дальше описывает как работает этот гавернер и еще один гавернер.
но вникать далее в конкретику не стал.

далее интереснее. описание полей в /sys
и также там как бы написано то что  цпу переводится в Idle состояние не так что цпу сам себя туда переводит
а что цпу просит некий другой hardware перевести себя в idle state. цитирую например
	Total number of times the hardware has been asked by the given CPU to enter this idle state.
то есть как я понимаю когда мы на цпу пихаем команду MWAIT то не сам цпу себя сует в C-state а типа что некое внешне к нему оборудование?.. 

итак датчики C-state в /sys
# ls -1 /sys/devices/system/cpu/cpu0/cpuidle/state8
above
below
desc
disable
latency
name
power
residency
s2idle
time
usage


публикую значения
# grep "" -Ri
disable:0           # данный c-state активирован
above:17258501      # 17 миллионов раз цпу находился в спячке меньше чем планировалось. был пробужден раньше
below:0             # сколько раз цпу можно было бы засунуть в более глубокий c-state (таких просто нет)
time:281080574856   # это где то 3-е суток. при том что аптайм у бука 11 суток
power:0             # в этом c-state цпу потребляет 0 милливат
residency:5000      # это 5мс(миллисекунд) если я верно все понимаю
latency:890         # чтобы пробудить цпу из этого c-state надо 0.89 мс
usage:28962786      # этот цпу был помещен в этот c-state 29 миллионов раз
desc:MWAIT 0x60     # видимо в этот стейт можно перейти через эту команду
name:C10            # это стейт C10



disable = отключен ли данный ц-стейт

above  = как я понял это число раз когда данный ц-стейт был запущен но по факту цпу находился в нем
меньше времени чем это планировалось. (например из за интеррапта от сетевой карты как я понимаю)

below = сколько  раз была такая штука что цпу можно было бы держать в idle стейт дольше чем
позволяет этот ц-стейт. или засунуть в более продвинутый c-state . но прикол в том что более глубокого
c-state пока не бывает.Total number of times this idle state had been asked for, but certainly a deeper idle state would have been a better match for the observed idle duration.

time = суммарное время за все время аптайма в течение которого цпу находился в этот ц-стейт. в микросекундах

power = какую мощность потребляет цпу находясь в этом ц-стейт. в милливатах

residency = планируемая длительность нахождения в этом ц-стейте. в микросекундах

latency = сколько нужно микросекунд чтобы пробудить цпу из данного состояния

usage = число раз сколько цпу был помещен в этот c-state

desc = описание этого стейта

name = имя стейта


а вот еще описание того же самого из пдфки
• name: Name of the idle state (e.g. C1).
• desc: Description of the idle state (or the mwait code).
• latency: Exit latency of the idle state in microseconds.
• power: Power drawn by hardware in this idle state in milliwatts (if specified, 0 otherwise).
• residency: Target residency of the idle state in microseconds.
• time: Total time spent in this idle state by the given CPU (as measured by the kernel) in microseconds.
• usage: Total number of times the hardware has been asked by the given CPU to enter this idle state.
• above: Total number of times this idle state had been asked for, but the observed idle duration was
certainly too short to match its target residency.
• below: Total number of times this idle state had been asked for, but certainly a deeper idle state would
have been a better match for the observed idle duration.
• disable: Whether or not this idle state is disabled.


получается из 29 миллионов раз когда цпу был в этом стейте 17 миллионов раз тоесть половина раз
цпу был разбужен раньше чем положено

как  я понимаю above и below в какойто степени показывают эффективность гавернера. что он хорошо
попадает выбирает нужный c-state или плохо.


поле disable позволяет для данного цпу отключить этот ц-стейт.

на счет поля power  пишут что часто его трудно определить поэтому оно равно ноль. но это не значит
что реально ноль а что хрен посчитаешь

далее написан реальный прикол. что поле time оно не отражает время которое провел цпу в этот стейте.
потому что как я понял кернел запускает MWAIT но микросхемы которые отвечают за ввод цпу в данный
idle стейт могут отказаться вводить цпу в данный стейт и ввести цпу в более легкий стейт. или 
вообще отказаться вводить цпу в idle стейт. а ядро может только померять время между заказом вводу в idle стейт
и и моментом когда цпу проснулся. цитирую как об этом дока пишет:
The number in the time file generally may be greater than the total time really spent by the given CPU in the given idle state, because it is measured by the kernel and it may not cover the cases in which the hardware refused to enter this idle state and entered a shallower one instead of it (or even it did not enter any idle state at all). The kernel can only measure the time span between asking the hardware to enter an idle state and the subsequent wakeup of the CPU and it cannot say what really happened in the meantime at the hardware level.

однако опять же непонятно. с одной стороны они пишут что счетчики недостоверные с другой стороны 
что счетчик usage показывает достоверные результаты.

далее в grub можно указать

idle=poll  эта штука дезактивириует acpi_idle и intel_idle. как это далее работает непонятно
idle=halt  эта штука дезактивириует acpi_idle и intel_idle и она дезактивирует MWAIT и только остается HLT

и вот еще настройки:
 intel_idle.max_cstate=<n> and processor.max_cstate=<n> parameters, where <n> is an idle state index also used in the name of the given state's directory in sysfs (see Representation of Idle States), causes the intel_idle and acpi_idle drivers, respectively, to discard all of the idle states deeper than idle state <n>.


далее. как они обозначают микросекунды = microsecond (usec)



далее я разбираю такую хрень как /dev/cpu_dma_latency
с ней придется поебаться (как обычно)
во первых я напомню про утилиту od
значит вот с таким ключами она показывает ровно тот порядок байтов
который есть в файле. тоесть байт с меньшим оффсетом печается на экране в строке в позиции с
меньшим оффсетом. таким образом байты на экране полностью отображают ситуацию в файле.
# echo -en "\x01\x0A"  | od -t x1 
0000000 01 0a
0000002

нахрен это нам надо ? а надо нам это для того чтобы когда мы считали байты из /dev/cpu_dma_latency
мы могли четко интерпретировать какой байт имеет меньший оффсет а какой больший оффсет. это нужно 
чтобы определить значение числа.

значит какой смысл имеет /dev/cpu_dma_latency? =  в нем хранится число в микросекундах (10^-6c)
которое говорит ядру что время выхода из c-state должно быть не больше чем указано в этом счетчике.
то есть когда ядро будет решать в какой c-state засунуть цпу то оно будет учитывать что время 
выхода из этого c-state не может превышать время указанное в этом счетчике

далее из доки известно что в этом счетчике хранится 4 байтовое целое число

дефолтовое значение на леново равно
# od -t x1 /dev/cpu_dma_latency 
0000000 00 94 35 77
0000004

далее мы помним что цпу интел оно пишет многобайтовое число в память по правилу LittleEndian (что такое little endian читай в ext4.txt и в C+assembly.txt)

поскольку я выше написал что команда od с теми ключами что я использовал сохраняет endiness то на экране
мы видим число тоже в little endian
чтоб нам понять чему оно равно надо его перевести в big endian потому что в математике мы используем 
запись по стандарту bit endian. 
транформируем число пользуясь вот такой схемой

little endian = A B C D
bit endian    = D C B A

значит LE (little endian)  00 94 35 77 = BE(big endian) 77 35 94 00
далее уже проще

# echo $(( 0x77359400))
2000000000

это микросекунды значит это равно 2000с
по мне это какойто дикий таймаут.  в том плане что самое число я определил правильно. 
дело в другом получается что по факту мы говорим ядру что время выхода из ц-стейт должно быть меньше чем 2000с
это просто смешно. это значит что ядро будет использовать любой самый глубокий ц-стейт. потому что 
напомню что лейтенси выхода из самого глубокого на данный момент ц-стейт C10 составляет 0.89мс (миллисекунды)

напомню один из способов как посмотреть статистику по C-states

# cpupower monitor -m "Idle_Stats"
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  1,49|  0,81|  0,00|  0,08|  0,00|  4,43|  0,00| 91,79
   4|  0,00|  0,00|  0,01|  0,04|  0,84|  0,00| 11,69|  0,00| 85,29
   1|  0,00|  2,61|  0,04|  0,08|  0,69|  0,00|  8,30|  0,10| 85,96
   5|  0,00|  0,00|  0,00|  0,00|  0,04|  0,00|  0,35|  0,00| 91,87
   2|  0,00|  0,89|  0,01|  0,09|  0,82|  0,00|  8,40|  0,00| 87,71
   6|  0,00|  0,81|  0,01|  0,00|  0,12|  0,00|  4,71|  0,57| 93,25
   3|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,74|  0,00| 92,68
   7|  0,00|  0,10|  0,02|  0,01|  1,09|  0,00| 12,49|  0,58| 78,72

 или 
 	# watch cpupower monitor -m "Idle_Stats"

так вот если мы не хотим чтобы у нас использовались "глубокие" высоколатентные долгопробуждаемые 
C-state то мы можем записать новое число в cpu_dma_latency и якобы это должно сработать

прикол состоит в том что мы не можем просто взять и записать число туда. потому что как только наша 
программа закроет доступ к этому файлу то ОС обратно исправить значение на дефолтовое. 
нужно иметь программу\процесс который держит открытым этот файл постоянно только тогда наше новое
значение будет висеть в системе.
делаем это вот так
я иду и смотрю какое latency у C10  и C9

# cat /sys/devices/system/cpu/cpu0/cpuidle/state{7,8}/{name,latency}
C9
480
C10
890

значит у C9 latency=890 микросекунд
       у C10 latency=480 микросекунд

значит если я задам порог 600 микросекунд то мониторинг C-state должен мне показать что 
использование C10 прекратилось и началось использование C9 на холостой ненагруженной системе.
600 dec  = 258 hex
далее запись в счетчик идет в интересном виде , я про это прочел вот здесь (https://docs.kernel.org/power/pm_qos_interface.html) цитирую - To change the requested target value, the process needs to write an s32 value to the open device node. Alternatively, it can write a hex string for the value using the 10 char long format e.g. "0x12345678". This translates to a cpu_latency_qos_update_request() call.

что значит s32 это  я не понял. а метод через 10 char long format e.g. "0x12345678" работает. 
превращаем наш 0x258 в 4 байтовый вид тоесть 0x258 = 0x00000258
и далее делаем вот так

		# exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
		# od -t x1 /dev/cpu_dma_latency 
			0000000 58 02 00 00
			0000004


как видим все сработало. в плане записи числа в счетчик. 
еще раз скажу что такой заморочны вид потому что нам нужно открыть счетчик. записать значение
и не закрывать счетчик. иначе ос сразу перезапишет его в дефолтовый вид 2000с
( !! подробнейший разбор как работает строка 
		# exec 3<> /dev/cpu_dma_latency; echo -en "0x00000258" >&3
 я сделал в файле bash.txt 
 искать там через 
| bash
| redirect
| exec
 )



теперь проверяем статистику
#  cpupower monitor -m "Idle_Stats"
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  0,78|  0,01|  0,00|  0,31|  0,00|  6,14| 88,13|  0,00
   4|  0,00|  2,52|  0,07|  0,12|  2,20|  0,00| 15,04| 77,88|  0,00
   1|  0,00|  0,00|  0,01|  0,02|  0,41|  0,00|  3,98| 77,89|  0,00
   5|  0,00|  1,20|  0,01|  0,00|  0,26|  0,00|  3,81| 90,32|  0,00
   2|  0,00|  0,75|  0,39|  0,07|  0,76|  0,00|  7,32| 84,85|  0,00
   6|  0,00|  0,00|  0,02|  0,00|  0,00|  0,00|  2,37| 95,50|  0,00
   3|  0,00|  0,83|  0,00|  0,03|  0,25|  0,00|  9,96| 84,13|  0,00
   7|  0,00|  0,65|  0,65|  0,23|  0,45|  0,00| 12,59| 83,59|  0,00

вот! мы видим что использование C10 прекратилось! и щас активно юзается C9!
все получилось!

далее я поубивал все процессы которые держали открытым этот счетчик. и 
ос перезаписала датчик на его дефолтовое значение

# od -t x1 /dev/cpu_dma_latency
0000000 00 94 35 77
0000004

проверяем статистику
#  cpupower monitor -m "Idle_Stats"
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  1,21|  0,01|  0,03|  0,96|  0,00| 11,60|  0,01| 84,38
   4|  0,00|  0,19|  0,02|  0,03|  0,43|  0,00|  7,03|  1,13| 86,66
   1|  0,00|  2,20|  0,03|  0,01|  0,26|  0,00| 12,51|  0,00| 80,53
   5|  0,04|  0,00|  0,00|  0,00|  0,31|  0,00|  7,00|  0,00| 90,46
   2|  0,00|  0,00|  0,21|  0,02|  0,16|  0,00|  2,69|  0,00| 91,94
   6|  0,00|  0,00|  0,00|  0,00|  0,07|  0,00|  0,86|  0,53| 94,89
   3|  0,00|  1,50|  0,38|  0,00|  0,12|  0,00|  4,20|  0,00| 93,16
   7|  0,00|  1,89|  0,10|  0,02|  0,27|  0,00| 10,36|  0,00| 84,00

она снова как была раньше. тоесть C10 активно используется

в целом можно обойтись без такого прям сложного мудежа об необходимости держать открытым файл
и сделать все по другому

дизейблим C10
	# echo 1 | tee /sys/devices/system/cpu/cpu*/cpuidle/state8/disable
	1

смотрим статистику
# cpupower monitor -m "Idle_Stats"
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  1,68|  0,23|  0,08|  0,93|  0,00|  8,17| 80,46|  0,00
   4|  0,00|  0,90|  0,52|  0,05|  0,51|  0,00|  9,35| 84,29|  0,00
   1|  0,00|  3,19|  0,00|  0,00|  0,28|  0,00|  0,47| 91,07|  0,00
   5|  0,00|  0,38|  0,01|  0,06|  0,08|  0,00| 10,49| 84,44|  0,00
   2|  0,00|  0,04|  0,01|  0,03|  0,26|  0,00| 10,31| 85,48|  0,00
   6|  0,00|  0,00|  0,01|  0,01|  0,27|  0,00|  9,37| 80,97|  0,00
   3|  0,00|  0,19|  0,03|  0,02|  1,08|  0,00| 14,23| 82,04|  0,00
   7|  0,00|  1,03|  0,05|  0,07|  0,76|  0,00| 11,88| 80,75|  0,00

да. сработало

возвращаем обратно
	# echo 0 | tee /sys/devices/system/cpu/cpu*/cpuidle/state8/disable
	0
	# cpupower monitor -m "Idle_Stats"
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  0,77|  0,02|  0,03|  1,05|  0,00|  9,96|  0,00| 84,94
   4|  0,00|  0,00|  0,01|  0,00|  0,65|  0,00|  9,03|  0,61| 86,98
   1|  0,00|  1,57|  0,00|  0,00|  0,11|  0,00|  2,42|  1,20| 91,40
   5|  0,00|  1,20|  0,11|  0,06|  0,22|  0,00|  3,62|  0,00| 91,61
   2|  0,00|  2,62|  0,29|  0,25|  2,19|  0,00| 15,48|  0,65| 75,78
   6|  0,00|  0,00|  0,03|  0,06|  1,58|  0,00| 14,56|  0,01| 82,16
   3|  0,00|  3,17|  2,09|  0,07|  0,50|  0,00|  3,80|  0,73| 85,95
   7|  0,00|  0,00|  0,00|  0,00|  0,12|  0,00|  0,76|  0,00| 98,05

да. сработало.

итак я закончил на /dev/cpu_dma_latency
двигаем дальше

cpu_dma_latency=0: Writing a maximum allowable latency of 0 will keep the processors in C0 (like using kernel
parameter “idle=poll”


итак чтобы нам открыть /dev/cpu_dma_latency  и чтобы этот файл оставался открытым
надо выполнить 
	# exec 3>/dev/cpu_dma_latency 
  # ls -1al /proc/$$/fd
 		0 -> /dev/pts/3
 		1 -> /dev/pts/3
 		2 -> /dev/pts/3
 		255 -> /dev/pts/3
 		3 -> /dev/cpu_dma_latency
вот видно что у нас на постоянной основе открыт теперь файл /dev/cpu_dma_latency
в дескриптор 3

в пдфке написано что чтобы запретить все C-state кроме C0 можно сделать засунуть 0 в 
этот супер файл.
числа в этот файл надо совать в формате echo "0xA1A2A3A4"
где 0xA1A2A3A4 это четыребайтовое число. 
итак суем 0
			# echo "0x00000000" 1>&3
			# cat /dev/cpu_dma_latency | od -t x1
				0000000 00 00 00 00
				0000004

и действительно  и i7z и  cpupower показывают что единственный C-state это C0 
			# cpupower monitor -m "Mperf,Idle_Stats"
    | Mperf              || Idle_Stats                                                   
 CPU| C0   | Cx   | Freq  || POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0| 99,69|  0,31|   699|| 95,51|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00
   4| 99,69|  0,31|   699|| 96,11|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00
   1| 99,69|  0,31|   699|| 96,27|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00
   5| 99,69|  0,31|   699|| 95,68|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00
   2| 99,69|  0,31|   699|| 95,88|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00
   6| 99,69|  0,31|   699|| 95,91|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00
   3| 99,69|  0,31|   699|| 96,28|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00
   7| 99,69|  0,31|   699|| 95,89|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00|  0,00


закрываем этот супер файл
			# exec 3>&-
			# ls -1al /proc/$$/fd
 					0 -> /dev/pts/3
					1 -> /dev/pts/3
 					2 -> /dev/pts/3
 					255 -> /dev/pts/3

видно что да файл закрылся.
проверяем исправила ли ОС там число на дефолтовое
			# cat /dev/cpu_dma_latency | od -t x1
			0000000 00 94 35 77
			0000004
да все восстановилось.
а что на счет показаний мониторинга
		# cpupower monitor -m "Idle_Stats"
    | Idle_Stats                                                   
 CPU| POLL | C1   | C1E  | C3   | C6   | C7s  | C8   | C9   | C10   
   0|  0,00|  0,00|  0,08|  0,00|  1,19|  0,00|  1,68|  1,14| 91,07
   4|  0,00|  0,00|  0,95|  0,00|  0,51|  0,00|  6,83|  0,00| 89,20
   1|  0,00|  1,11|  0,01|  0,00|  0,33|  0,00|  8,90|  1,73| 82,57
   5|  0,00|  0,00|  0,02|  0,07|  0,43|  0,00| 10,28|  0,00| 87,61
   2|  0,00|  0,23|  0,00|  0,00|  0,09|  0,00|  2,90|  0,00| 93,59
   6|  0,00|  0,99|  0,13|  0,34|  0,65|  0,00|  8,51|  0,00| 88,06
   3|  0,00|  0,03|  0,00|  0,00|  0,38|  0,00|  4,78|  0,00| 92,01
   7|  0,00|  2,20|  0,04|  0,00|  0,02|  0,00|  3,15|  0,00| 93,01

да все четко. цпу опять сидит в C10 стейт.

также было видно что как только я запретил все стейты кроме C0 то даже работая на холостом ходу
температура взлетела с 33 до 42 градусов. amazing..


далее они пишут что ограничивая C-states мы  автоматом обрезаем сверху турбо частоту.
не знаю как это работает ну окей.


а вот описание что такое MSR регистры:
A model-specific register (MSR) is any of various control registers in
the x86 instruction set used for debugging, program execution tracing,
computer performance monitoring, and toggling certain CPU features

итак MSR это для дебага, мониторинга, и активации фич.

MSR дает инфо о мощности потребления, температуре, и счетчики скорости

хочу сказать что /dev/cpu_dma_latency называется как PM_QOS


далее
малек про corefreq
    # corefreq-cli -c
CPU Freq(MHz) Ratio  Turbo  C0(%)  C1(%)  C3(%)  C6(%)  C7(%)  Min TMP:TS  Max
000   20.47 ( 0.20)   1.14   3.20   4.23   0.03   0.53  92.01  20 / 31:63 / 36
001   15.08 ( 0.15)   0.84   2.25   5.35   0.06   3.07  89.27  21 / 31:63 / 37
002   16.13 ( 0.16)   0.90   2.35   4.61   0.02   0.76  92.26  21 / 32:62 / 37
003    9.04 ( 0.09)   0.50   1.37   5.04   0.03   1.26  92.30  21 / 31:63 / 37
004   13.68 ( 0.14)   0.76   2.02   5.39   0.03   0.53  92.03  21 / 31:63 / 36
005   18.47 ( 0.18)   1.03   3.02   4.58   0.06   3.05  89.29  21 / 31:63 / 37
006    9.16 ( 0.09)   0.51   1.41   5.54   0.02   0.76  92.26  21 / 32:62 / 37
007    8.02 ( 0.08)   0.45   1.28   5.13   0.03   1.26  92.30  22 / 31:63 / 37

    # corefreq-cli -m
CPU Pkg  Apic  Core/Thread  Caches      (w)rite-Back (i)nclusive              
 #   ID   ID    ID     ID  L1-Inst Way  L1-Data Way      L2  Way      L3  Way 
000:BSP    0     0      0    32768  8     32768  8    262144  4   6291456 12 i
001:  0    2     1      0    32768  8     32768  8    262144  4   6291456 12 i
002:  0    4     2      0    32768  8     32768  8    262144  4   6291456 12 i
003:  0    6     3      0    32768  8     32768  8    262144  4   6291456 12 i
004:  0    1     0      1    32768  8     32768  8    262144  4   6291456 12 i
005:  0    3     1      1    32768  8     32768  8    262144  4   6291456 12 i
006:  0    5     2      1    32768  8     32768  8    262144  4   6291456 12 i
007:  0    7     3      1    32768  8     32768  8    262144  4   6291456 12 i

    # corefreq-cli -i
CPU     IPS            IPC            CPI
000     0.031122/s     0.477467/c     2.094384/i
001     0.002259/s     0.165889/c     6.028122/i
002     0.003316/s     0.210896/c     4.741664/i
003     0.002221/s     0.208388/c     4.798741/i
004     0.003764/s     0.214930/c     4.652674/i
005     0.002457/s     0.118093/c     8.467935/i
006     0.003547/s     0.185199/c     5.399586/i
007     0.002950/s     0.088187/c    11.339553/i


вот эта опция дает исчерпывающую инфо о возможностях цпу
      # corefreq-cli -s
Processor                             [Intel(R) Core(TM) i5-8265U CPU @ 1.60GHz]
|- Architecture                                                 [Whiskey Lake/U]
|- Vendor ID                                                      [GenuineIntel]
|- Microcode                                                        [0x000000ea]
|- Signature                                                           [  06_8E]
|- Stepping                                                            [     12]
|- Online CPU                                                          [  8/  8]
|- Base Clock                                                          [100.005]
|- Frequency            (MHz)                      Ratio                        
                 Min    400.02                    <   4 >                       
                 Max   1800.09                    <  18 >                       
              Level1    800.04                    [   8 ]                       
              Level2   1800.09                    [  18 ]                       
               Turbo   1500.07                    <  15 >                       
                                                                                
...
...
Instruction Set Extensions                                                      
|- 3DNow!/Ext [N/N]          ADX [Y]          AES [Y]  AVX/AVX2 [Y/Y] 
|- AMX-BF16     [N]     AMX-TILE [N]     AMX-INT8 [N]    AMX-FP16 [N] 
|- AVX512-F     [N]    AVX512-DQ [N]  AVX512-IFMA [N]   AVX512-PF [N] 
|- AVX512-ER    [N]    AVX512-CD [N]    AVX512-BW [N]   AVX512-VL [N] 
|- AVX512-VBMI  [N] AVX512-VBMI2 [N]  AVX512-VNNI [N]  AVX512-ALG [N] 
|- AVX512-VPOP  [N] AVX512-VNNIW [N] AVX512-FMAPS [N] AVX512-VP2I [N] 
|- AVX512-BF16  [N] AVX-VNNI-VEX [N] AVX-VNN-INT8 [N] AVX-NE-CONV [N] 
|- AVX-IFMA     [N]    CMPccXADD [N]      MOVDIRI [N]   MOVDIR64B [N] 
|- BMI1/BMI2  [Y/Y]         CLWB [N]      CLFLUSH [Y] CLFLUSH-OPT [Y] 
|- CLAC-STAC    [Y]         CMOV [Y]    CMPXCHG8B [Y]  CMPXCHG16B [Y] 
|- F16C         [Y]          FPU [Y]         FXSR [Y]   LAHF-SAHF [Y] 
...
...
и так далее. 
только нет знаний чтобы понять что написано


далее
я поставил софт который управляет вентилятором бука => NBFC
ставил по инструкции:
https://github.com/hirschmann/nbfc/wiki/How-to-install-NBFC-on-Ubuntu-18.04#3-manually-download-nugetexe-and-paste-to-nbfc-latest-stable

удивительно это первый случай когда сложная установка сработала в точности от начала 
и до конца на 100% успешно.  вот так молодцы...
однако проблема в том что моего бука в списке нет.
я применил один из рекомендованных. но увы. хрен так.
программа не видит вентилятора

  # mono /opt/nbfc/nbfc.exe status -a
  Service enabled   : True
  Read-only   : False
  Selected config name  : Lenovo Ideapad U430p
  Temperature   : 35

  Fan display name  : System Fan
  Auto control enabled  : True
  Critical mode enabled : False
  Current fan speed : 0.00
  Target fan speed  : 0.00
  Fan speed steps   : 511


в общем я посмотрел все продукты которые связаны с регулировкой скорости вентилятора на лэптопе
https://wiki.archlinux.org/title/fan_speed_control#NBFC

но как я понял мой бук нельзя никак заставить по человечески работать с вентилятором.



||
===  остановился здесь



$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$

нужно проработать чешскую статью в pdf которая



есть такая ошибка в логах 
: msr: Write to unrecognized MSR 0x38f by i7z (pid: 3751)
пока что решение такое  = echo on | sudo tee /sys/module/msr/parameters/allow_writes


ноутбук lenovo как у него настроить принудительно вентилятор ?




что такое powetop ?


дальнейшее обсуждение:
https://unix.stackexchange.com/questions/87522/why-do-cpuinfo-cur-freq-and-proc-cpuinfo-report-different-numbers
https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.10/

tlp ?


https://wiki.archlinux.org/title/Hardware_video_acceleration

>> wifi
наод проработать соседний текстовый файл который про nmcli который я анписал когда 
с роутером вощился. кстати надо роутер зарестить и пароль вай фай более сильный записать

>> mc медленный старт
вылезал такая пролблема - очень мделнно 3с стартует mc. 
раньше так было когда в /etc/jhosst остутссутвует 127ю.0.0.1 lnovo 
щас оно там ест. можно стартунть быстро mc через mc -u но тогда нет локального шелл
при этом 
# nslookup lenovo 
раотаеает
я поумал что может все таки это из за прблем с dns резвомингом 
потому что 
$ host lenovo 
выдает ошибку
Host lenovo not found: 3(NXDOMAIN)
хуф знеает что эт значит

я подумал что может это из за dnsmasq
я удалил файл из /etc/NetworkManager/dnsmasq.d
и удалил файл из 
/etc/NetworkManager/conf.d
скорировал их в ~/Backup2
перезаустил # systemctl restart NetowrkManager
при этом сломался /etc/resol.conf  был 127.0.1.1 стал 127.0.0.53
я руками заменил на 8.8.8.8
после этого даже nslookup lenovo перстал работать 
я заменил
# cat /etc/nsswitch.conf 

hosts:          files mdns4_minimal [NOTFOUND=return] dns myhostname  
на
hosts:          myhostname files mdns4_minimal [NOTFOUND=return] dns 

новсе равно mс стартует 3 секунды. надо раозобораться в этой всей хукйне

я все конфиги вернуло братно . и выясил вот здеь (https://fedoramagazine.org/using-the-networkmanagers-dnsmasq-plugin/)
что оказыатся по деолту dnsmqsq сука не исползует /etc/hosts 
тогда я добавтл файл 


# cat /etc/NetworkManager/dnsmasq.d/02-add-hosts.conf 
# /etc/NetworkManager/dnsmasq.d/02-add-hosts.conf
# By default, the plugin does not read from /etc/hosts.  
# This forces the plugin to slurp in the file.
#
# If you didn't want to write to the /etc/hosts file.  This could
# be pointed to another file.
#
addn-hosts=/etc/hosts

ретартанул NetwrorkMahager и теперь у меня "lenovo" резврися уппешно

 # # host lenovo
lenovo has address 127.0.0.1

онако mc по пржунму стартутет озуенно долго 

далее я нахуй удлил опоять весь этот dnsmsq
и еще в /etc/sytemd/resolved.conf
удалил
DNSStubListener=no

рестарт netowekrmamager он меняет
/etc/reolsolv.conf на 
127.0.0.53

такжа выынсилоась что на дургх сокета все равно раобатет dnsmsqk потмоу что его 
запустил lxd!
но все равно запуск mc работает попржнму сука долдго!

дело окащалос совсем в другом не в dns. а в .bashrc

вот эти строки охуенно задерживали загрузку mc

# The next line updates PATH for Yandex Cloud CLI.
if [ -f '/home/vasya/yandex-cloud/path.bash.inc' ]; then source '/home/vasya/yandex-cloud/path.bash.inc'; fi

# The next line enables shell command completion for yc.
if [ -f '/home/vasya/yandex-cloud/completion.bash.inc' ]; then source '/home/vasya/yandex-cloud/completion.bash.inc'; fi

суки яндексовские

и вот эти строки

#export NVM_DIR="$HOME/.nvm"
#[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
#[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion


на комее по деолфту /etc/resolv.conf смотрит в /run/systemd/resolvs/stub-resolv.conf
что в нем значит 
		options edns0 trust-ad 
??

dnsmasq vs systemd-resloved ?
dnsmasq как плагин к netowkr mamager
dnsmasq по дефолту не читает /etc/hosts
что вот это за хуйня в nsswitch "mdns4_minimal [NOTFOUND=return]" ?
nlookup vs host ? ( а также ошибка linux Host not found: 3(NXDOMAIN))


что за хрень pm-suspend

по какой то причине хуево работала usb  мышь. 
я захотел перезагрузить USB подсистему. в  итоге помогла эта статья https://gist.github.com/planetceres/917840478e1e4d45f8373667630e51a0
которая привела на эту стать https://davidjb.com/blog/2012/06/restartreset-usb-in-ubuntu-12-04-without-rebooting/
также я захватил эту статью https://www.baeldung.com/linux/control-usb-power-supply
и еще вот это https://superuser.com/questions/1707773/how-to-turn-usb-connected-device-on-and-off-in-linux
в целом непонятно - как находить usb устройства и как их гасить


