| bit
| bits
| 7-bit
| 7-bits
| 7
| 8-bit
| 8bits
| 7bits
| byte


ВНАЧАЛЕ СТАТЬИ Я ПРИХОЖУ К ОДНИМ ВЫВОДАМ
А В КОНЦЕ К ДРУГИМ. ЧИТАТЬ ДО КОНЦА


изначальный вопрос - можно ли кодировать
7-битные байты через hex кодировку, корректно ли это?

что такое бит это обьект вида 1 либо 0 

бит можно сравнить с яблоком. оно либо красное
либо зеленое. еще прикол его в том что его можно
превращать из красного в зеленое из зелного в
красное


биты можно через электроаппараты передавать на 
расстояние от одного носителя битов к другому. то
есть у меня внутри комп1 есть яблоки

красное зеленое зеленое красное зеленое

можно сделать так что за 1000 км внутри друого
компа возникнет точно такое же множество яблок

красное зеленое зеленое красное зеленое

нельзя по проводу скопировать живые яблоки а 
биты можно


кто то может передавать по одному биту за раз
гдето аппараты умеют передавать сразу по несколько
битов за раз


кучка битов образует множество битов

1010101010110101010101001010101 

корзина полная яблок
только не просто корзина , биты имеют еще и 
ящички с номерами в котоыры они лежат

ящик1( красное зеленое красное красное)
ящик2(зеленое красное зеленое зеленое)

ящики это например адрес ячейки RAM
но в целом ящики неважны. ящики это тара упаковка,
важен конкртеный контент

внутри компа обычно биты хранятся  и передаются
от одной запчасти внутри компа в другую кусками
квантами - байтами.

размер байта может быть разным но обычно это 8

0101 0101

тоесть комп это хранитель битов но обрабатыает он
их внутри себя и двигает между своими разными
частями не по одной штуке а 8 штук за раз или 
числу кратному 8 

в целом в разрезе файла важно то что мы имеем
набор битов которые сохранены в упорядоченной форме
тоесть они имеют порядок


самый перый бит
|
\/
10101010101010101010110011010101010101010110
11010010101010110010101101010101010101010101
                                           /\
                                            |
                                         самый 
                                         последний
                                         бит

ценность составляет именно набор упорядеоченных
битов. это как картина - это набор капель (пусть 
картина черно белая) которе нанесены на бумагу
в строгом порядке. поменяй эти же капли на бумаге
в раномные места и от ценного контента картины
не остаентся и следа.

итак нам важны такие моменты: количество битов 
внутри файла (число яблок в корзине) и порядок
в котором они лежат внутри. как буквы внутри книги
имеют строгие порядковвые места. 

итак комп это хранитель битов. их там много.
они хрантся в больших кучах - файлах.
внури файла они свалены не просто в кучу а каждый
бит имеет свое порядковое место.  файлы лежат на
диске. там у нас биты хранятся упорядоченными 
кусками по 512*8 (раньше) и 4096*8 (сейчас) штук.
на ssd дисках размер такого куска еще больше.
эти биты считываются в память сохраняя свой порядок.
но в памяти кусок считанынй с диска разбивается
на тот же набор битов но разрезанный на куски
по 8 бит. кусок размером 8 бит это основной размер
куска которым оперирует комп при работе с битами.
8 бит это минимальный размер которым можно опер
ировать битами в памяти. такой же размер работы
с битами внутри цпу в регистрах. 
аналогия может быть такая - на диске буквы (биты)
хранятся в виде книжек с листочкми.
в памяти буквы уже лежат в форме листочков.
кнмжка это блок на диске. листочек это байт. то
число битов которое хранится в форме единой
хрени в памяти. листочек битов лежит и в регистре
цпу. таким образом между цпу и памятью биты 
циркулирую в группах размером с листочек. тоесть
нельзя прочитать из памяти в цпу отдельный бит
с листочка. из памяти можно в цпу прочитать 
только листочек. внутри цпу можно модифицировать
отдельный буквы в на этом листочке. обратно в память
можно сохранить только целиком листочек битов.
отденый бит в память записать нельзя.

итак бит (яблоко красно зеленое) это носитель 
иформации. остальные штуки - регистры, память,
диск это методы массового хранения этих битов. 

можно еще придумать аналоию с картинами. на диске
картины хранятся в виде точек краски. в каждой
коробке дохрена этих точек. но они там лежат
в упорядоченном виде. в память когда считаем с диска
то эти точки переходя в отдельные картины. 
внутрь цпу из памяти можно копировать толкьо в 
форме картин. внури цпу можно на картине менять
отдельные точки на картине. обратно в память
из регистра можно записать только картину целиком.
если возвращаться к яблокми то в памяти яблоки
хранятся в форме лукошек (как уповка с яйцами).
упаковка такова что яблоки внутри упаковки имеют
номерные места. яблоки из памяти в цпу можно прочи
тать только в форме целой упаковки.
внутри цпу можно модифиуировать отдельыне яблоки
в этой упаковке. можно сделать яблоко номер  1
из зеленого в красное. можно скопировать из 
памяти из ячейки 1 упаковку яблок  и потом 
из цпу эту упаковку можно скопировать оборатно
в память в ячейку 2.

упоаковку яблок в памяти называют байтом.
размер упокаовки - колчесво битов внутри этой 
упаковки называют размером байта.
если в памяти лежит упоакока из 8 битов то 
на этом компе размер байта равен 8.
8 еще называют разрядностью байта.

байт это основная единица  , основной кусок 
которым обрабатывается массив битов внутри 
компа. 

итак комп это такой огромный склад мелких битиков
(как гвоздей). только это не просто куча а это
куча гвоздей имеющих своих номера. и разложенных
по упаковкам. комп  это машина которая постоянно
пеекладывает эти гвозди с одного места на другое.
цпу как экскаватор работает с массивом этиго
моря гвоздей ковшом. а не по одной штуке.
ковш это байт. размер ковша это размерность байта.
обычно это 8. тоесть комп ворочает эту кучу
гору гвоздей по 8 штук. диск это основное место
хранения гвоздей. это огромное море битов. упоря
доченное. как океан это массив капель но они там
неупорядовеннчеые а диск это океан гвоздей только
упорядочнных. там они лежат контенерами внури 
которых много гвоздей. скажем 4096 штук. упорядо
ченных. память это уже море гвоздей. тоесть с диска
гвозди берутся из контейнеров и перекладвыаются
в память и в памяти они раскадываются уже по более
мелким ящичкам. ящики упоряченные и внутри 
ящиков гвозди раскладываются тоже упорядоченно.
поэтому общий порядок гвоздей строго сохранятеся.
поэтмоу можно легко перекладывать из ящиков обратно
в контейнеры и наоброт. просто диск это множество
из больших контейнер гвоздей. а память это место
где находится множество более мелких ящиков из
гвоздей. внутри цпу находится совсем немного 
ящиков. цпу берет ящик из памяти и кладет внутрь
себя. гвозди внутри ящиков внутри цпу уже могут
быть просмотрены со стороны цпу и внутри ящика
гвозди могут быть имзенены. скажем внутри 
ящика ест ячейки. в ячейке либо есть гвоздь
либо его нет. цпу может менять состав ячейки.
может либо вынимать гвоздь либо вставлять.(либо
скажем гвоздь короткий либо длинный)
после тоого как работа с ящиком закончена цпу
может скопировать этот ящик в любой ящик в памяти.
а оттуда его сохранить на диск уже в составе 
большого контейнера. 


итак байт это количество битов которое
цпу обрабатывает за раз (из той огромной кучи 
битов которые вообще хранятся внутри компа). 

так еще представлю - на диске хрантся отдеьные буквы.
в упорядоченном виде. прям отдеьне буквы.
в с диска в память буквы копирются на листочки.
комп и памят обмениваются буквами на уровне листочков.
цпу может внутри себя менять содержимое листочка
и оратно вернуть листочек в память.  на диск
запиываются уже тлоько буквы без листочка. но порядок
сохраняется 

листочек (егообьем)  это тот характеный обьем букв
который цпу обрабваыет буквы из всего того огромад
ного обьема букв хранящися внутри компа.

так как биты лежат упордоченно на листочке то 
листочек имеет характерный рисунок. 
 
 0000 1010

количество битов на листочке - это разрядность байта.

вот эта хрень   0000 1010  это точное буквальное
отображение контента листочка. мы видим сколько битов
лежит внутри листочка и на каких позициях , ведь
нам важны нетолько сами биты их колчество но и их
позиция расположение. 
таким образом форма отображеия

  0000 1010
 
нам показывает всю информацию - сколько бит сидит
внутри байта и на каких позициях. еще аналогия с 
яблоками

  зззз кзкз

з-зеленое яблоко
к-красное яблоко


тоесть 0 это неостутвие информации. это другая
информация. у наас два вида информации 0 и 1
0 это не оствуие инфораии не пустота. просто 
наша инфомрация имеет две ипсостасии. зеленое
яблко и красное яблоко.

бинрная форма - это точная конечаная форма отобра
жения инфомрации. 

далее возникает необходимость придумать какую то
свертку этой информации. новая форма которая 
непозволяет нам видеть информацию но которая 
более компактная при написании на бумаге и которая
нам позволит однозначно восстановить исхдоную форму.
чтото типа того что делает zip алгоритм. он превра
щает исходный файл в новый файл. новый файл контент
напрямую своим видом не предает - инфомрация искажена
но можно при желании точно восставниоиить исходную 
форму. 

тоесть дело в чем
вот у нас исходная информация о битах

0101010101010101010110101010101010101010110101010101

она передает точную информацию о битах. их число
и позицию. но эта форма некомпактная. скажем массив
из 1000 бит займет тысячу знаков на бумаге. неудобно
громоздко.
нужна компактная форма. новая форма будет скрывать
саму информацию но занимать меньше места и по ней
можно всегда точно восстановить исходный массив
битов - их число и их позиции. тоесть если исходный
вид 

01010010101010101010

это буквы сложенную в фразу которую мы можем прочиать
типа

   пустьвсегдабудетсолнце

то нам нужна более компактная форма

   *??*?Р:*

мы ее напрямую уже прочиать не можем но она
занимает меньше места на бумаге. при этом сама ин
формация не потеряна. она свернута.  и ее при желании
можно восстановить. в комапактнйо форме ееудобно
передаавать или фикисровать на бумаге. 

исходя из того что я рассказал выше массив
битов

01010010101010101010

это нетолько единицы. это еще и нули. они тоже
несут ровно такую же полноценную инфомрацию как 
и единицы. нули это не осттие информации. информация
имеет двойной вид. два лица. тоесть это как баба и 
мужик

мжмжмжмжмжмжмжмжмжмжмжмжмжжжмжмжмжмжмжмжммж

тоесть оба вида бита несут информцию. 

а не так что 

м(нет мужика)(нет мужика)мм(нет мужика)...

нет такого нет.
тоест это не так как в вагоне поезда

пассажир(нет пассажира)(нет пассажира)(пасажир)

это так что 

(баба)(баба)(мужик)(мужик)(мужик)....


исходя из этого в массиве данных

01010101010101010101101010101010010101011010

и нули и единицы несут информацию.
тоесть наша информация не имеет вид типа :
     есть информаци
     нет информации

а имеет вид
    инфорация вида 1
    информация вида 2

тоест это как бы вот так

 2121212121212121212121212121212121212121212


просто внутри компа она хранится в виде 

 0101010101011001101010101010101010101010


но ноль это несотвутие инфорации. это тоже
информация. зеленое и красное яблоко.


таким образом полнота информации сохраняется 
тоько тогда когда  сохранено общее число и нулей
и единиц (суммарная разрядность), нули и единицы
сидят на своих местах.
таким макаром я считаю что бит это сущность
в виде 0 или 1  а не просто только 1. 
исходя из этого я считаю что массив битов

  11

и 
  
  0011

это два разных массива битов. соверешенно не совпа
дающие.  впервом сулчае у нас 2 бита в массиве информации а во втором случае 4 бита информации.
два красных яблока против два зеленых и два красных.

итак еще раз у нас есть некая информация. она имеет
две формы два лица. условно это 0 и 1
и 0 и 1 это  двоственная природа одно сущности - информации. это не так что 0 это остувтие иномраиции
а 1 это ее наличие.  это как монета имеет две 
стороны. нет монеты с одной стороной. тоесть 
приода информации двойственна. итак бит это конкртеная
форма  сущности-информации. чтото типа того как 
если бы электрон мог быть отриацательный и положите
льный. оба они электроны. но имеет два лица. 
итак бит это конкртеная форма некоей базовой сущности-информации.

далее мы собирем группу битов.

010101010101101010101

тоесть это сораные в кучку базовые информации в 
их конкретных формах.

мы нашли на земле кучу электронов только какието
из них оказались с плюсом а другие с минусом.
но каждый бит это электрон . а не то что там 
где ноль тамэлектрона нет.  каждый бит это наличие
электрона. 

 0010

в данном массиве у нас 4 электрона. три с минусом
один с плюсом . а нето что у нас один электрон
и три нихрена. 

из этой запииси мы можем скзаать что у нас 4 штуки
информации. ни больше ни меньше. 

так вот собирая элементанные информации в их двух
ипосасиях в кучу мы получаем некую более глобальную
информацию которая заключается в том что 
      * сколько у нас простых 
        информаций в сумме(разрядность)
      * сколкько у нас в сумме 1 и 
        сколко у нас в сумме 0
      * на каких позициях сидят 0 
        а на каких 1

точно также как точки нанеесенные на бумагу 
обрзуют макроинформацию - картину. 


вот это обозначение

  0010

оно нам в точости предает эту макроинформацию.
  * всего битов 4
  * один бит в форме 1
  * три бита в форме 0
  * их точные позиции 0010


итак для полной ппередачи макроинформации
нам нужно знать сколько у нас всего нулей и единиц
сколько из них каждого вида и на каких позициях 
они в точности сидят. только эта совопкупность
нам позволяет востставноиить полноту макроинформации


теперь мы ищем новую форму для этой информации.
новая форма небудет отображать все аспекты что
я описал выше. но она будет более компактная на 
бумаге и в ней будет заширована вся исходная информация тоесть исходную информацию всегда можно
во всей полноте восстановить.

мы берем словарь (множество) из символов
0 1 2 3 4 5 6 7 8 9 0 A B C D E F
это просто значки. символы не более того
на их месте могли быть любые другие. важно что
их 16 штук.

далее мы делаем устанавливаем вот такое 
соовесвие


0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111


таким образом я нашел новую форму обозначения
отображения (сохранения на бумаге) для 4-битного
массива байтов в более короткой форме

старая форма   1101
новая  форма   D

глядя на новую форму я "сходу" не могу увидеть
всю полному исходной информации. новая форма 
ее не передает! гляда на таблицу сверху можно
только скзать то что исходный массив бит состоит
ТОЧНО из ЧЕТЫРЕХ ШТУК! это я могу сказать сразу
точно! но эта форма не передает сколько нулей битов
и единиц битов содержит исходная форма и на каких
позициях. этого новая форма не передает! зато она
в четыре раза более компактная. и она позволяет
по таблице сверху восстановить при желании исходную
форму множства битов. и узнать то что нам надо.

тоесть если раньше чтобы на бумаге нам передать 
массив информации из битов 

 1101 1011  1001 0010 

нам нужно было затраить 16 символов. 16 позиций на 
бумаге. при этом у нас сразу видна вся полнота
информации . то новая более компактная форма 
передает эту информацию в более компактрной форме
через 4 позиции на бумаге

  D B 9 2 


всю полноту исходнйо информации мы не видим из 
этой формы. это минус. но мы можем точно восставноить
эту полноту информации (полный массив битов нулей
и битов единиц в их точном полном исходном количестве
и в точных позициях где они были). мы толоько сходу
можем точно сказать что полное число битов в исходной
информации равно 16бит. это мы сразу можем  сказать.

тут я хочу вернуться еще раз к важному аспекту.
вернемся к исходным битам.
вот есть два набора битов

11  и  0011

вопрос биты слева и справа составляют одинаковую 
информацию?  Я СЧИТАЮ ЧТО НЕТ!
слева у нас две сущности базовой информации
а справа у нас четыре сущности базовой информации.
да слева и справа у нас совпдаает число битов 1,
да у нас ПОЗИЦИИ битов 1 совпадают слева и справа,
но на этом все совпадеия заканчиваются. 
поэтому я считаю что слева и справа массивы информации
несовпадают. что это разные информации.

исходя из этого я считаю что если у нас есть
исходный массив битов
 
  101010110101010101101010101011010

то для его эквивалетного отображения HEX форму (01235
6789ABCDEF) можно использовать ТОЛКЬО ЕСЛИ общее 
число битов кратно 4. а если это нетак то хекс 
форму отображения применять нельзя невзомжно некоректно.

  1 0101 0110 1010 1010 1101 0101 0101 1010


в данном случае видно что обее число битов не 
кратно четырем. значит хекс форму применять нельзя!

почему? потому что у нас нет хекс формы для 
отображения массива битов вида 1

я вот еще как покажу. пусть у нас биты будут
не в строчку в а внутри прямоугльника

  0101011010101010
  0110101010101010
  1011010101011010
  0101011010101010
  1010101011010101


будем считать что это картина
у нас все биты несут часть информации. особенно
это будет очевдно если каждый бит может иметь не
две формы а скажем 16000. тоесть это оттенок цвета.
у нас нельзя из картинвы выколость ни один бит.
это будет не картина а картина с дырками.

так вот картина вида 

 0001

это некартина вида 

 1

потому что на верхней картине у нас все точки
играют роль а нетолько точка с 1. остальне выбро
сить нельщя. поэому

1 и 0001 это не одно и тоже поэтому
бинарный 1 и хекс 1 это не одно и тоже.
хекс 1 это бинарный 0001


исходя из этого я считаю что если у нас 7битная 
кодировка тоесть это такие байты которые имеют
внутри себя 7бит 

 000 1010
 101 0101
 110 0100
 110 0101

их нельзя отобразить с помощью hex вида.это некоректно!

хекс форма валидна только для отображения
исходных массивов битов общее число которых кратно 
четырем! а если это нетак то такие масивы нельзя
коректно превратиь в хекс вид!

посмотрим на OCT форму кодирования массива битов.
возьмем словарь из 8 символов. сиволы могут быть
любые но мы возьмем такие 
0 1 2 3 4 5 6 7

и сделаем соовесвтие между вот такими массивами
битов и oct символами

 0 000
 1 001
 2 010
 3 011
 4 100
 5 101
 6 110
 7 111


у нас каждый OCT символ "кодирует"( тоесть он 
условно его обозначает)  одному трех
битному массиву битов. 

тогда если у нас есть исходный массив битов 
и он кратен трем то мы можем его без потери
исходной информации "пеекодировать" в новую форму.
 
  010 101 101  

это будет
  2   5   5



OCT форма отображения массива битов не подходит
для кодрования массива из 7-и битов ибо этот массив
не кратен трем.!!

тоесть вот еще раз.
у нас есть исходный массив битов


010101101010101010101101010101010110101010110100


по условию задачи по природе информации нам важно
знать  в этом массиве все - общее число всех битов.
общее число каждого вида битов. точное расположение
битов 0 и битов 1
если мы это знаем мы полностью обладаем той ифнормац
ией котрую нам надо знать по условию задачи.
теперь мы ищем более компауную форму сохранения
этой информации. эта форма может не отображаьт все
аспекты этой информации но она должна позволять 
ОДНОЗНАЧНО при необходимости восстановить исходную
полную информацию.
если  я поделю исходны массив битов на групки 
по 4 бита

0101 0110 1010 1010 1010 1101 0101 0101 0110 1010 1011 0100 

а потом по словарю сделаю замену для каждой группы



0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111

то я получу


5 6 С A A D 5 5 6 A B 4 

теперь если я возьму эту форму и отдам ее васе

5 6 С A A D 5 5 6 A B 4 

то вася берет словарь. и по нему делая обратную
подстановку получает вот такой массив битов

0101 0110 1010 1010 1010 1101 0101 0101 0110 1010 

тоесть

010101101010101010101101010101010110101010110100

смог ли он восстановить исходную информаци в ее полноте? - ДА
у нас общее число битов совпадает с иходной формой,
позиция все битов 1 и все битов 0 тоже совпдает
как у исходной формы.

но это все возможно только если исходный массив
битов кратен ЧЕТЫРЕМ. если он не кратен пытаться его
вснууть  в хекс форму это преступление!
нармиер исходный массив битов это

11

и говорить что  хекс форма

3

кодирует этот массив битов это преступление.
согласно нашему словарю 

3 это 0011 

и массив информации 11
и массив информации 0011 
это соверешенно разные вещи.


тоже самое как соверенно разные вещи вот такие
два массива битов


  101010101010110101010010110101010101011000

и
111101010101010110101010010110101010101011000


поэтому считаю что  писать что вот такие хекс
формы кодируют такие то 7 битные массивы битов
это вранье это преступление. 

тоже самое пытатся кодировать 7битные 
масивы битов чреез OCT .

а ведь такое написано в 

  $ man ascii


показываю

   Oct   Dec   Hex   Char
   ───────────────────────
   100   64    40    @
   101   65    41    A


полная хуйня

у нас символ @ и A  имеют соотвсвтие вот таким 
7-битным масивами битов


     Bin      Char
   ─────────────────
   100 0000    @
   100 0001    A


соотвесвтенно они утверждают что 
массив битов   100 0000   и хекс форма  40 
это одно и тоже. хуйня полная.

hex 40 это закодиоравнная форма вот такого массива
битов 0100  0000

теперь сравним настоящий массив битов
 100 0000
и массив битов который они нам подсовывают
0100 0000

еще раз

 100 0000
0100 0000

это два разных массива битов. это две разные
информации.

я вот щас так еще это поясню
у нас две корзины с яблоками (зелеными и красными)

  КЗЗ ЗЗЗЗ
 ЗКЗЗ ЗЗЗЗ


похоже ли это на то что обе корзины яблок одинакоыые?
нЕт! хуня полная! вих ней корзине лишне яблоко!


еще одно вранье которое онипишут втойже таблице
что якобы вот эти два массива битов  которые 
закодированы этими двумя формами явяляются одинак
оывми

  OCT   HEX
  100   40


проверим

OCT 100 это BIN 001 000 000
HEX 40  это BIN 0100 0000

сравним

001000000
 01000000

разве это одно и тоже?

проведу еще раз анаологи с корзинами яблок

ЗЗКЗЗЗЗЗЗ
 ЗКЗЗЗЗЗЗ


конечно же даже на уровне яблок это разные массивы!



напоследок.
а что если словарь состоит из десяти символов
0 1 2 3 4 5 6 7 8 9


попробуем закодировать одно битные массивы

0 = 0
1 = 1

отлично. но еще 7 символов оказались ненужны

порбуем двухбитные массивы битов

0 = 00
1 = 01
2 = 10
3 = 11

уже лучше но все равно остаются незадейтствоаныне
символы  а нахрне тога они ужны.

пробуем трехбиные массивы

0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111

у нас осталось двас мвола 8 и  9 которые не в удел.

пробуем четырех битные массивы


0 = 0000
1 = 0001
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111
8 = 1000
9 = 1001
? = 1010
? = 1011
? = 1100
? = 1101
? = 1110
? = 1111

мы использовали все симвыол из словаря
но проблема в том что у нас еще остались четрыех
бытные массивы котоыре мы уже закоодивать не можем
тоест этой кодировкой можно пользовться но 
только для частных случаев массива битов
тоесть есл у нас массив вида

1000 0110 

то мыможем его закодирвать в

8 6 


а если у нам массив вида


1000 0110  1111

то как его кодировать

 8 6 ?


опять же 
мы можем составить словарь вот так


0 = 0
1 = 111
2 = 101011
3 = 010
4 = 101010101001
5 = 1001010
6 = 01010101001001010
7 = 1010
8 = 1
9 = 11

нас никто не ограничивтает что якобы мы
должны кадждый символ сопоставлят с массивом
битов одинаковой длоинны. нет. 
но пользовться на пракктие такой ситстемой
прккодировки во первых неудобно. во вторых
она позволяет ей пользватся только для 
массива битов котоыре имеют очень частный вид

например массив

 1010 1 11

его можно закодрвать как

7 8 9 

а можно как 

7 8 8 8

тоесть у нас еще и однозначнсти нет!

поэтому такое правило кодирования нам не подходит.



тогда придумали вот такое правило кодирования.

сказали вот что возьмем вот такую формулу

(0/1)*2^n +...+(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0


тоесть это сумма из ДВОЕК в такйото степени
и при них стоит коэфициент либо 0 либо 1.
вначале мы опреляемся какой n взять путь это 
будет n=5 тогда

(0/1)*2^5 +
+(0/1)*2^4 +(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0

на втором шаге мы выбираем значение в каждой 
скобке там где 0 или 1  напимер 


(1)*2^5 +
+(0)*2^4 +(1)*2^3 + 
+ (1)*2^2 + (0)*2^1 + (0)*2^0

теперь считаем что получилось

44

потом берут коэфициенты вскобках и рисуют их
рядышком

101100

и говорят что согласно этому правилу они мапят
символы 44 на массив битов 101100

так как у нас в скобках стоят только 0 и 1
то при таком подходе у нас массив из этих коэфииц
ентов это всегда будет хрень вида
 1010101010101010101010101

и так как арифмт формула использует символы
01234567890
то результатом вседа будет набор символов вида
129371298371928371928

тоесть ровно точно из словаря (01234567890)
который нам нужен

при таком правилу устанолвения соответвия есть
одна проблема. у нас одному и тому же дестичному
числу сооветсвует не один а миллион битовый
массивов. тоесть это 

101100
0 101100
00 101100
и вообще любой массив вида

(0..0)101100

потому что если мы подставим эти коэфиценты в фор
мулу мы всегда получим 44  !

тоесть 
биты ----> 44
преобразуются однзначно 

а
44 ------> биты
непреобразуется однозначно

тоесть если мы видим на бумаге напиасно

 DEC 44

то мы не можем восстановить точно оригинальный
массив битов. 
а это хуйня полная.
единсвтенно как мы это можем сделать если рядом
будет написано какая полная длинна была у оригиналь
ного массива битов . например 

 DEC 44 , 12бит

тогда мы можем сказать что это запист кодирует
оригинаьный массив

 0000 0010 1100

при такой оговоре , наше дес правило и наша DEC 
запись позволет однозначно восстановить информацию
об оригинальном массиве битов


при таком правиле массив битов мапится на
коэифицианты разложения дестичного числа 
по базису степеней  двойки.


возникает вопрос если я беру десятичное 
число  N например 44 то  могу ли я быть уверен
что множество коэфиицентов разложения единственное
или нет. тоесть что наше 44
раскладывается только в 

(0..0)101100

и что нет других вариатов типа

(0..0)111110

итп 

а то у нас получится хуйня. хотя она уже итак
получилась. но тем не мнее что бы у нас не 
получилось так что мы взяли   битовый массив
 
  101100

подставили в формулу , получили 44

записали на бумаге 44

а потом оказалось что есь другой массив

 111010

который при подставновке в формулу дает тот
же самый 44 и это будет п..ц
но тут я думаю математика доказыает что разложение
единственное 

101100

при условии наличия вот еще такого прикола

(0..0)101100

который нам дает нединственность но которая
уже через пень колоду  устранимая.



Далее походу вот как они имеют дело с HEX
они говорят пусть у нас есть десятичное число
тогда его можно разложить с одной стороны 
по степеням двойки. с другой стороны по степянем
десятки(собственно это и есть десятичнрая форма
числа)  с третьей стороны по степеням числа 16
причем в чем прикол. коэфиицент который будет
стоять в каждом члене он будет в диапазоне
интерсном лежать . тоесть 
если мы раскадыдваем число по стееням 10-ки 
то коэфицинет всегда будет в диапазоне

  0<= K <= 9

еси мы раскываем число по степеняем двойки
то 

  0<= K <= 1

по степеням числа 16 

  0<= K <= 15


итого 

44 = (4)*10^1 + (4)*10^0


44 = (1)*2^5 + (0)*2^4 +(1)*2^3 + (1)*2^2 +
      + (0)*2^1 + (0)*2^0


44 = (2)*16^1 + (8)*16^0


одно и тоже дес число мы разложили по 
степеням 10-ки, 2-ки, 16-ки.
как видно кофэицианты при каждом члене
меньше этого числа по степеням которго
мы разлагаем.

так вот они говорят что раз число одно тоесть
сущность во всех трех случая одна и та же
то давайте мы просто возьмем и запишем каждый из
примеров в виде массив кофицинтов

10: 44
2 : 101100
16: 28

ну а дальше они говррят что раз коэфииценты разло
жения единственные то можно использовать эти
все три нотации как заменяющие одна другую
и получается что 

 hex 28  кодирует bin 10100

толко у меня тут маленькая но мерзкая поправочка

это не совсем так. коэфиценты у нас не однозначно
опредяеляются и на самом деле все выглядит вот
так

вот как на самомо деле выглядит разложение
числа 44 

10: (0..0) 44
2 : (0..0) 101100
16: (0..0) 28


если мы рассматриваем эти нули вс кобках как
коэфиценты которые мы подставляем в арифм 
формулы что наверху то они нам погоды не делают
потмоу что в итоге в любых случаях получим одно
и тоже число 44. но! если мы маппим эти нули 
на массив битов то тут уже извините! - если 
нам все равно какой набор коэфиицантов
либо такой

101100

либо такой

00000000000 101100

подтставлять в формулу арифм разложения. потому
что мы получим все равно 44

то массив битов 
такой 101100
или такой 00000000000 101100
это совершенно разные массивы битов!


тоесть вот что получается.
вот у нас есть массив из n битов. и его легко 
можно превратиьт в DEC число подставив в формулу


DEC:  (0/1)*2^n +...+(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0

это прямая формула. мы очень легко можем установить
(замаипить) dec число имея массив битов

биты ------> DEC 

это очень простая легкая быстрая и однозначная
операция. тут поблем нет.
но вот мы передали это DEC число васе
и ему нужно выполнить обратную операцию.
восстановить изначлный массив битов .

и тут как я сказал часть вида массива битов
вася восстановит однозначно. но другая часть
этого массива - ее невзможно определить однозначно.
тоесть дали мы васе 
  
  DEC = 44

вася однозначно узнает что часть массива битов
это точно 

  101100

но невозможно точно как выглядит осталная часть
этого этого массива. это чтото вот такого вида
(0..0)

тоесть любой массив 

(0..0)101100

он сворачивается до 44
поэтому передавая васе 44 мы должны обязательно 
указать сколько бит есть в изначальном массиве битов.
напрмиер 


  DEC = 44,  число битов=10

только тогда вася может восстановить оригинанльный
массив битов который мы ему пердакли вкодированном
виде

   0000 101100


так вот теперь еще хуже. 
мы передаем васе  бумжку где написано


 HEX 28


вася подсталяет эту щтуку в формулу

HEX : (0-15)*16^n +...+(0-15)*16^3 + 
+ (0-15)*16^2 + (0-15)*16^1 + (0-15)*16^0

и получаем

(2)*16^1 + (8)*16^0
= 32+8=44

окей вася выяснил что  HEX 28 кодирует 
деятичное число 44
но нам то нужно не оно а массив из битов.
далее вася дейсвтиует по предыдущему пункту
и получает что  массив битов который подходит это 

(0..0)101100

если мы не сообщили зарнее полное число битов
то вася в пролете. но если мы васе об этом
сказали вот так


  HEX = 28,  число битов=10

только тогда вася может восставноить зашиорвнный
исходный массив битов


   0000 101100



тоже самое для OCT кодивания  . мы можем предсвати
число 44 как разложение по стееням восьмерки
тогда получим

44 = (0-7)*8^2 + (0-7)*8^1 + (0-7)*8^0
     = (0)*8^2 + (5)*8^1 + (4)*8^0

тогда получаем
8: (0..0) 54  


итого все разложения
10: (0..0) 44
2 : (0..0) 101100
16: (0..0) 28
8 : (0..0) 54  



ТАКИМ ОБРАЗОМ:
если  мы берем массив битов. потом этот массив
подсставляем в качестве коэфициентов разложения 
десятичного числа по степенями двойки и получаем
десятичное число то в эту сторону система 
работатет однозначно(BIN->DEC). любой массив битов
приведетпо формуле нас к одному и только одному 
десятичному числу. обратное же преобразование 
(DEC-BIN) неоднозначное если мы не укажем как 
доп условие сколько бит было в оригинальном массиве
битов. 

ну тогда в приницпе получается что мы можем 
через DEC кодировать массив битов любой длины,
главное при этом рядом с DEС указать какой длины
был оригинальный массив битов. это позволит нам
однозначно восстановит BIN из DEC

тогда в этом свете записи в man ASCII имеют 
смысл. тоесть 

вот у нас там написано

   Dec   Char
   ───────────────────────
   101     A


также там написано   It is a 7-bit code.

итак мы имеем

   DEC 101, 7-bit code


тогда да. мы можем имея эту инфо восстанвоить
исходный изначальный бинарный массив битов

(0..0) 110   0101

и теперь выбираем чтобы массив был 7 бит длиной
вот этот оригиналный битовый массив

  110  0101



Итак через DEC форму можно теперь коротко кодировать
битовый массив любой длины. главное при этом 
рядом с DEC формой указывать полную длину исходно
ого массива битов.  это поволит однозначно восста
новить исходный битовый массив.


теперь. про HEX.
вот мы имеем битовый массив. мы подставляем
его в формулу. и получаем DEC число.
зная его мы можем разложить это DEC число
по степням 16-ти и получить HEX представление
этого DEC числа. 


тоесть мы имеем масив битов 110  0101
мы подстлвяем их как коэфицианты в формулу

(1)*64 + (1)*32+ (0)*16 + (1)*8 + (0)*4 + (1)*2
= 101

десятичное число мы нашли. теперь мы можем для
него найти разложение по степеняем числа 16
это будет

HEX: (?)*256 + (?)*16 + (?)*1
    = (0)*256 + (6)*16 + (5)*1

HEX: (0..0)61

тоесть строго говоря   у нас много разложений
можно взять любое. нармиер 

 HEX: 00065

таким макаром мы установили цепочку


BIN 110  0101 ---> DEC 101 ---->  HEX 00065


теперь мы можем предать васе HEX нотацию
но нужно обязательно добавить чему равна полная
длина битоового оригинально массива


    HEX 00065,  длина массива 7



вася возьмем hex пдставить в формулу и найдет
десятичное число, это однозначная операция

  6*16+5*1 = 101

теперь ему нужно найти какой битовый массив
соовествует  этому числу.

вася опредить что это вот такой класс
массивов

(0..0) 110   0101

и используя инфо что длина массива 7 бит
он в итоге вычленит исходный массив

   110   0101



таким образом HEX тоже можно использовать чтобы
кодировать любой длины битовые массивы, но 
нужно обязательно к HEX нотации приклывать инфо
об полной длинне исходного битового массива. 
иначе жопа.


тоже самое про OCT



по какойто счастливой случайности связь HEX нотации
с BIN по арифмеитическому правилу разложения по 
стееням дает точно такой же маппинг 
как и связь между этими же субьектами по моему
правилу простого словаря


0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111


единсвтннное что нужно в конце подкорректировать 
длину массива ноли битами в одну или в другую сторо
ну опирась на то условие какой длины должен быть
конечный массив битов. 
напрмиер  дано


HEX 41,  массив битов 7 бит длиной

берем мой словарь
 4=0100  1=0001

тоесть 41 = 0100 0001

получаем

  0100 0001

теперь нужно откоретировать его длину до 7 бит
обрезав в голове нулевые биты или добавив в 
голове нулевые биты
получаем

    100 0001




чем приколна на практике еще HEX нотация,
тем что она позволяет супер быстро и легко
пррварить массив битов очень большой длины 
в HEX вид при минимальных вычислительных затратарх. 
мы берем   любой массив битов.
делим его на куски по 4 бита начиная от младего
бита к самому старшему. если в голове остается хвост
то мы его дополняем нулями до полных 4 бит.
тоесть дано

  01010101101010

разбиваем

  01 0101 0110 1010

доплняем его до полных 4 бит

  0001 0101 0110 1010

теперь либо по словарю заменяем каждые 4 бита
до HEX символа. либо это можно сделать налету
путем простых выичлсений.
берем 4битную хрень


  1010 

и высиляем для нее dec число. если оно лежит в
пределах 0-9 то это и есть HEX символ. а 
если оно 10-15 то надо помнить в голове небольшой
словарь 

 10=A
 11=B
 12=C
 13=D
 14=E
 15=F

посмотрим на нашем примере


  0001 0101 0110 1010


 0001 = 1 знаичит HEX 1
 0101 = 5 значит  HEX 5
 0110 = 6 значит  HEX 6
 1010 = 10 значит HEX A

значит в итоге

HEX:  156A,  полная длина ориг массиав 14 бит

очень важно указать какой длины был ориги
нальный битовый массив


для сравнения
вычислить HEX на оснвое BIN через разложение 
по кожфициентам стеепеней гораздо более ресурсое
мко!


HEX метод позволяет нам сократить оригиналный 
битовый поток в 4 раза в плане того сколько 
символов надо потраить на бумаге для его записи
ну вот реально оригинальный биотовый поток

  01010101101010

имеет 14 символов длиной на бумаге

а HEX нотация

  156A

имеет всего четыре. (14 дополнили до 16 и поделили
на четыре)


OCT нотация тоже самое . позволяет нам быстро 
и просто прервтить поток битов в более короткий
вид сократив его в три раза.

берем оригинальынй поток

01010101101010

делим на групы по три бита

  01 010 101 101 010

дополняем нулями до полной группы из трех бит

  001 010 101 101 010

тут даже проще. берем каждую группу из трех
битов и вычиялем его dec число. оно и будет OCT
заменой тоесть

  001 = 1
  010 = 2
  101 = 5
  101 = 5
  010 =2

значит 

OCT: 12552 , длина оригинаьного потока 14 бит

обязательно надо добавить. мы просто и быстро
соакртили битовый массив (его запись ) в 3 раза!
при этом нам даже ненужно как в случае HEX запоминать
преобрвзания вида 10=A

круто!!

теперь мне понячно поему в linux permsions 
мы их укзываем в виде OCT типа 666 или 0666

наприме 

 r--r--r--

он хранится в виде битов тоесть

100100100

закодируем этот масив битов в OCT вид

100 100 100

100= 4

значит

OCT: 444 , полная длина оригинаьного  массива 9 бит 

прикольно....

я так скажу! если сравнвить HEX нотаци и OCT 
нотацию то окт круче еще тем что из нее 
гораздо проще в голове восставнить  битовый вид
чем это можно сделать через HEX 

тоесть 
берем пример символ из ASCII

Oct   Dec   Hex   Char
───────────────────────
101   65    41    A



вопрос из какой формы быстрее всего 
я могу узнать битовый вид? ответ -из OCT формы!

OCT: 101

101 = 1 0 1 

1 = 001
0 = 000
1 = 001

значит BIN

001 000 001

и тперь еще вспминаем что символ asccii это 7-бито
вый массив битов
значит оргиналый массив битов это 

  100 0001

просто быстро круто и легко!!!!!


тепррь  я понял фишки и согласен с таблицей
ASCII с ее dec,hex,oct нотациями!





