| bit
| bits
| 7-bit
| 7-bits
| 7
| 8-bit
| 8bits
| 7bits
| byte


ВНАЧАЛЕ СТАТЬИ Я ПРИХОЖУ К ОДНИМ ВЫВОДАМ
А В КОНЦЕ К ДРУГИМ. ЧИТАТЬ ДО КОНЦА


изначальный вопрос - можно ли кодировать
7-битные байты через hex кодировку, корректно ли это?

что такое бит это обьект вида 1 либо 0 

бит можно сравнить с яблоком. оно либо красное
либо зеленое. еще прикол его в том что его можно
превращать из красного в зеленое из зелного в
красное


биты можно через электроаппараты передавать на 
расстояние от одного носителя битов к другому. то
есть у меня внутри комп1 есть яблоки

красное зеленое зеленое красное зеленое

можно сделать так что за 1000 км внутри друого
компа возникнет точно такое же множество яблок

красное зеленое зеленое красное зеленое

нельзя по проводу скопировать живые яблоки а 
биты можно


кто то может передавать по одному биту за раз
гдето аппараты умеют передавать сразу по несколько
битов за раз


кучка битов образует множество битов

1010101010110101010101001010101 

корзина полная яблок
только не просто корзина , биты имеют еще и 
ящички с номерами в котоыры они лежат

ящик1( красное зеленое красное красное)
ящик2(зеленое красное зеленое зеленое)

ящики это например адрес ячейки RAM
но в целом ящики неважны. ящики это тара упаковка,
важен конкртеный контент

внутри компа обычно биты хранятся  и передаются
от одной запчасти внутри компа в другую кусками
квантами - байтами.

размер байта может быть разным но обычно это 8

0101 0101

тоесть комп это хранитель битов но обрабатыает он
их внутри себя и двигает между своими разными
частями не по одной штуке а 8 штук за раз или 
числу кратному 8 

в целом в разрезе файла важно то что мы имеем
набор битов которые сохранены в упорядоченной форме
тоесть они имеют порядок


самый перый бит
|
\/
10101010101010101010110011010101010101010110
11010010101010110010101101010101010101010101
                                           /\
                                            |
                                         самый 
                                         последний
                                         бит

ценность составляет именно набор упорядеоченных
битов. это как картина - это набор капель (пусть 
картина черно белая) которе нанесены на бумагу
в строгом порядке. поменяй эти же капли на бумаге
в раномные места и от ценного контента картины
не остаентся и следа.

итак нам важны такие моменты: количество битов 
внутри файла (число яблок в корзине) и порядок
в котором они лежат внутри. как буквы внутри книги
имеют строгие порядковвые места. 

итак комп это хранитель битов. их там много.
они хрантся в больших кучах - файлах.
внури файла они свалены не просто в кучу а каждый
бит имеет свое порядковое место.  файлы лежат на
диске. там у нас биты хранятся упорядоченными 
кусками по 512*8 (раньше) и 4096*8 (сейчас) штук.
на ssd дисках размер такого куска еще больше.
эти биты считываются в память сохраняя свой порядок.
но в памяти кусок считанынй с диска разбивается
на тот же набор битов но разрезанный на куски
по 8 бит. кусок размером 8 бит это основной размер
куска которым оперирует комп при работе с битами.
8 бит это минимальный размер которым можно опер
ировать битами в памяти. такой же размер работы
с битами внутри цпу в регистрах. 
аналогия может быть такая - на диске буквы (биты)
хранятся в виде книжек с листочкми.
в памяти буквы уже лежат в форме листочков.
кнмжка это блок на диске. листочек это байт. то
число битов которое хранится в форме единой
хрени в памяти. листочек битов лежит и в регистре
цпу. таким образом между цпу и памятью биты 
циркулирую в группах размером с листочек. тоесть
нельзя прочитать из памяти в цпу отдельный бит
с листочка. из памяти можно в цпу прочитать 
только листочек. внутри цпу можно модифицировать
отдельный буквы в на этом листочке. обратно в память
можно сохранить только целиком листочек битов.
отденый бит в память записать нельзя.

итак бит (яблоко красно зеленое) это носитель 
иформации. остальные штуки - регистры, память,
диск это методы массового хранения этих битов. 

можно еще придумать аналоию с картинами. на диске
картины хранятся в виде точек краски. в каждой
коробке дохрена этих точек. но они там лежат
в упорядоченном виде. в память когда считаем с диска
то эти точки переходя в отдельные картины. 
внутрь цпу из памяти можно копировать толкьо в 
форме картин. внури цпу можно на картине менять
отдельные точки на картине. обратно в память
из регистра можно записать только картину целиком.
если возвращаться к яблокми то в памяти яблоки
хранятся в форме лукошек (как уповка с яйцами).
упаковка такова что яблоки внутри упаковки имеют
номерные места. яблоки из памяти в цпу можно прочи
тать только в форме целой упаковки.
внутри цпу можно модифиуировать отдельыне яблоки
в этой упаковке. можно сделать яблоко номер  1
из зеленого в красное. можно скопировать из 
памяти из ячейки 1 упаковку яблок  и потом 
из цпу эту упаковку можно скопировать оборатно
в память в ячейку 2.

упоаковку яблок в памяти называют байтом.
размер упокаовки - колчесво битов внутри этой 
упаковки называют размером байта.
если в памяти лежит упоакока из 8 битов то 
на этом компе размер байта равен 8.
8 еще называют разрядностью байта.

байт это основная единица  , основной кусок 
которым обрабатывается массив битов внутри 
компа. 

итак комп это такой огромный склад мелких битиков
(как гвоздей). только это не просто куча а это
куча гвоздей имеющих своих номера. и разложенных
по упаковкам. комп  это машина которая постоянно
пеекладывает эти гвозди с одного места на другое.
цпу как экскаватор работает с массивом этиго
моря гвоздей ковшом. а не по одной штуке.
ковш это байт. размер ковша это размерность байта.
обычно это 8. тоесть комп ворочает эту кучу
гору гвоздей по 8 штук. диск это основное место
хранения гвоздей. это огромное море битов. упоря
доченное. как океан это массив капель но они там
неупорядовеннчеые а диск это океан гвоздей только
упорядочнных. там они лежат контенерами внури 
которых много гвоздей. скажем 4096 штук. упорядо
ченных. память это уже море гвоздей. тоесть с диска
гвозди берутся из контейнеров и перекладвыаются
в память и в памяти они раскадываются уже по более
мелким ящичкам. ящики упоряченные и внутри 
ящиков гвозди раскладываются тоже упорядоченно.
поэтому общий порядок гвоздей строго сохранятеся.
поэтмоу можно легко перекладывать из ящиков обратно
в контейнеры и наоброт. просто диск это множество
из больших контейнер гвоздей. а память это место
где находится множество более мелких ящиков из
гвоздей. внутри цпу находится совсем немного 
ящиков. цпу берет ящик из памяти и кладет внутрь
себя. гвозди внутри ящиков внутри цпу уже могут
быть просмотрены со стороны цпу и внутри ящика
гвозди могут быть имзенены. скажем внутри 
ящика ест ячейки. в ячейке либо есть гвоздь
либо его нет. цпу может менять состав ячейки.
может либо вынимать гвоздь либо вставлять.(либо
скажем гвоздь короткий либо длинный)
после тоого как работа с ящиком закончена цпу
может скопировать этот ящик в любой ящик в памяти.
а оттуда его сохранить на диск уже в составе 
большого контейнера. 


итак байт это количество битов которое
цпу обрабатывает за раз (из той огромной кучи 
битов которые вообще хранятся внутри компа). 

так еще представлю - на диске хрантся отдеьные буквы.
в упорядоченном виде. прям отдеьне буквы.
в с диска в память буквы копирются на листочки.
комп и памят обмениваются буквами на уровне листочков.
цпу может внутри себя менять содержимое листочка
и оратно вернуть листочек в память.  на диск
запиываются уже тлоько буквы без листочка. но порядок
сохраняется 

листочек (егообьем)  это тот характеный обьем букв
который цпу обрабваыет буквы из всего того огромад
ного обьема букв хранящися внутри компа.

так как биты лежат упордоченно на листочке то 
листочек имеет характерный рисунок. 
 
 0000 1010

количество битов на листочке - это разрядность байта.

вот эта хрень   0000 1010  это точное буквальное
отображение контента листочка. мы видим сколько битов
лежит внутри листочка и на каких позициях , ведь
нам важны нетолько сами биты их колчество но и их
позиция расположение. 
таким образом форма отображеия

  0000 1010
 
нам показывает всю информацию - сколько бит сидит
внутри байта и на каких позициях. еще аналогия с 
яблоками

  зззз кзкз

з-зеленое яблоко
к-красное яблоко


тоесть 0 это неостутвие информации. это другая
информация. у наас два вида информации 0 и 1
0 это не оствуие инфораии не пустота. просто 
наша инфомрация имеет две ипсостасии. зеленое
яблко и красное яблоко.

бинрная форма - это точная конечаная форма отобра
жения инфомрации. 

далее возникает необходимость придумать какую то
свертку этой информации. новая форма которая 
непозволяет нам видеть информацию но которая 
более компактная при написании на бумаге и которая
нам позволит однозначно восстановить исхдоную форму.
чтото типа того что делает zip алгоритм. он превра
щает исходный файл в новый файл. новый файл контент
напрямую своим видом не предает - инфомрация искажена
но можно при желании точно восставниоиить исходную 
форму. 

тоесть дело в чем
вот у нас исходная информация о битах

0101010101010101010110101010101010101010110101010101

она передает точную информацию о битах. их число
и позицию. но эта форма некомпактная. скажем массив
из 1000 бит займет тысячу знаков на бумаге. неудобно
громоздко.
нужна компактная форма. новая форма будет скрывать
саму информацию но занимать меньше места и по ней
можно всегда точно восстановить исходный массив
битов - их число и их позиции. тоесть если исходный
вид 

01010010101010101010

это буквы сложенную в фразу которую мы можем прочиать
типа

   пустьвсегдабудетсолнце

то нам нужна более компактная форма

   *??*?Р:*

мы ее напрямую уже прочиать не можем но она
занимает меньше места на бумаге. при этом сама ин
формация не потеряна. она свернута.  и ее при желании
можно восстановить. в комапактнйо форме ееудобно
передаавать или фикисровать на бумаге. 

исходя из того что я рассказал выше массив
битов

01010010101010101010

это нетолько единицы. это еще и нули. они тоже
несут ровно такую же полноценную инфомрацию как 
и единицы. нули это не осттие информации. информация
имеет двойной вид. два лица. тоесть это как баба и 
мужик

мжмжмжмжмжмжмжмжмжмжмжмжмжжжмжмжмжмжмжмжммж

тоесть оба вида бита несут информцию. 

а не так что 

м(нет мужика)(нет мужика)мм(нет мужика)...

нет такого нет.
тоест это не так как в вагоне поезда

пассажир(нет пассажира)(нет пассажира)(пасажир)

это так что 

(баба)(баба)(мужик)(мужик)(мужик)....


исходя из этого в массиве данных

01010101010101010101101010101010010101011010

и нули и единицы несут информацию.
тоесть наша информация не имеет вид типа :
     есть информаци
     нет информации

а имеет вид
    инфорация вида 1
    информация вида 2

тоест это как бы вот так

 2121212121212121212121212121212121212121212


просто внутри компа она хранится в виде 

 0101010101011001101010101010101010101010


но ноль это несотвутие инфорации. это тоже
информация. зеленое и красное яблоко.


таким образом полнота информации сохраняется 
тоько тогда когда  сохранено общее число и нулей
и единиц (суммарная разрядность), нули и единицы
сидят на своих местах.
таким макаром я считаю что бит это сущность
в виде 0 или 1  а не просто только 1. 
исходя из этого я считаю что массив битов

  11

и 
  
  0011

это два разных массива битов. соверешенно не совпа
дающие.  впервом сулчае у нас 2 бита в массиве информации а во втором случае 4 бита информации.
два красных яблока против два зеленых и два красных.

итак еще раз у нас есть некая информация. она имеет
две формы два лица. условно это 0 и 1
и 0 и 1 это  двоственная природа одно сущности - информации. это не так что 0 это остувтие иномраиции
а 1 это ее наличие.  это как монета имеет две 
стороны. нет монеты с одной стороной. тоесть 
приода информации двойственна. итак бит это конкртеная
форма  сущности-информации. чтото типа того как 
если бы электрон мог быть отриацательный и положите
льный. оба они электроны. но имеет два лица. 
итак бит это конкртеная форма некоей базовой сущности-информации.

далее мы собирем группу битов.

010101010101101010101

тоесть это сораные в кучку базовые информации в 
их конкретных формах.

мы нашли на земле кучу электронов только какието
из них оказались с плюсом а другие с минусом.
но каждый бит это электрон . а не то что там 
где ноль тамэлектрона нет.  каждый бит это наличие
электрона. 

 0010

в данном массиве у нас 4 электрона. три с минусом
один с плюсом . а нето что у нас один электрон
и три нихрена. 

из этой запииси мы можем скзаать что у нас 4 штуки
информации. ни больше ни меньше. 

так вот собирая элементанные информации в их двух
ипосасиях в кучу мы получаем некую более глобальную
информацию которая заключается в том что 
      * сколько у нас простых 
        информаций в сумме(разрядность)
      * сколкько у нас в сумме 1 и 
        сколко у нас в сумме 0
      * на каких позициях сидят 0 
        а на каких 1

точно также как точки нанеесенные на бумагу 
обрзуют макроинформацию - картину. 


вот это обозначение

  0010

оно нам в точости предает эту макроинформацию.
  * всего битов 4
  * один бит в форме 1
  * три бита в форме 0
  * их точные позиции 0010


итак для полной ппередачи макроинформации
нам нужно знать сколько у нас всего нулей и единиц
сколько из них каждого вида и на каких позициях 
они в точности сидят. только эта совопкупность
нам позволяет востставноиить полноту макроинформации


теперь мы ищем новую форму для этой информации.
новая форма небудет отображать все аспекты что
я описал выше. но она будет более компактная на 
бумаге и в ней будет заширована вся исходная информация тоесть исходную информацию всегда можно
во всей полноте восстановить.

мы берем словарь (множество) из символов
0 1 2 3 4 5 6 7 8 9 0 A B C D E F
это просто значки. символы не более того
на их месте могли быть любые другие. важно что
их 16 штук.

далее мы делаем устанавливаем вот такое 
соовесвие


0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111


таким образом я нашел новую форму обозначения
отображения (сохранения на бумаге) для 4-битного
массива байтов в более короткой форме

старая форма   1101
новая  форма   D

глядя на новую форму я "сходу" не могу увидеть
всю полному исходной информации. новая форма 
ее не передает! гляда на таблицу сверху можно
только скзать то что исходный массив бит состоит
ТОЧНО из ЧЕТЫРЕХ ШТУК! это я могу сказать сразу
точно! но эта форма не передает сколько нулей битов
и единиц битов содержит исходная форма и на каких
позициях. этого новая форма не передает! зато она
в четыре раза более компактная. и она позволяет
по таблице сверху восстановить при желании исходную
форму множства битов. и узнать то что нам надо.

тоесть если раньше чтобы на бумаге нам передать 
массив информации из битов 

 1101 1011  1001 0010 

нам нужно было затраить 16 символов. 16 позиций на 
бумаге. при этом у нас сразу видна вся полнота
информации . то новая более компактная форма 
передает эту информацию в более компактрной форме
через 4 позиции на бумаге

  D B 9 2 


всю полноту исходнйо информации мы не видим из 
этой формы. это минус. но мы можем точно восставноить
эту полноту информации (полный массив битов нулей
и битов единиц в их точном полном исходном количестве
и в точных позициях где они были). мы толоько сходу
можем точно сказать что полное число битов в исходной
информации равно 16бит. это мы сразу можем  сказать.

тут я хочу вернуться еще раз к важному аспекту.
вернемся к исходным битам.
вот есть два набора битов

11  и  0011

вопрос биты слева и справа составляют одинаковую 
информацию?  Я СЧИТАЮ ЧТО НЕТ!
слева у нас две сущности базовой информации
а справа у нас четыре сущности базовой информации.
да слева и справа у нас совпдаает число битов 1,
да у нас ПОЗИЦИИ битов 1 совпадают слева и справа,
но на этом все совпадеия заканчиваются. 
поэтому я считаю что слева и справа массивы информации
несовпадают. что это разные информации.

исходя из этого я считаю что если у нас есть
исходный массив битов
 
  101010110101010101101010101011010

то для его эквивалетного отображения HEX форму (01235
6789ABCDEF) можно использовать ТОЛКЬО ЕСЛИ общее 
число битов кратно 4. а если это нетак то хекс 
форму отображения применять нельзя невзомжно некоректно.

  1 0101 0110 1010 1010 1101 0101 0101 1010


в данном случае видно что обее число битов не 
кратно четырем. значит хекс форму применять нельзя!

почему? потому что у нас нет хекс формы для 
отображения массива битов вида 1

я вот еще как покажу. пусть у нас биты будут
не в строчку в а внутри прямоугльника

  0101011010101010
  0110101010101010
  1011010101011010
  0101011010101010
  1010101011010101


будем считать что это картина
у нас все биты несут часть информации. особенно
это будет очевдно если каждый бит может иметь не
две формы а скажем 16000. тоесть это оттенок цвета.
у нас нельзя из картинвы выколость ни один бит.
это будет не картина а картина с дырками.

так вот картина вида 

 0001

это некартина вида 

 1

потому что на верхней картине у нас все точки
играют роль а нетолько точка с 1. остальне выбро
сить нельщя. поэому

1 и 0001 это не одно и тоже поэтому
бинарный 1 и хекс 1 это не одно и тоже.
хекс 1 это бинарный 0001


исходя из этого я считаю что если у нас 7битная 
кодировка тоесть это такие байты которые имеют
внутри себя 7бит 

 000 1010
 101 0101
 110 0100
 110 0101

их нельзя отобразить с помощью hex вида.это некоректно!

хекс форма валидна только для отображения
исходных массивов битов общее число которых кратно 
четырем! а если это нетак то такие масивы нельзя
коректно превратиь в хекс вид!

посмотрим на OCT форму кодирования массива битов.
возьмем словарь из 8 символов. сиволы могут быть
любые но мы возьмем такие 
0 1 2 3 4 5 6 7

и сделаем соовесвтие между вот такими массивами
битов и oct символами

 0 000
 1 001
 2 010
 3 011
 4 100
 5 101
 6 110
 7 111


у нас каждый OCT символ "кодирует"( тоесть он 
условно его обозначает)  одному трех
битному массиву битов. 

тогда если у нас есть исходный массив битов 
и он кратен трем то мы можем его без потери
исходной информации "пеекодировать" в новую форму.
 
  010 101 101  

это будет
  2   5   5



OCT форма отображения массива битов не подходит
для кодрования массива из 7-и битов ибо этот массив
не кратен трем.!!

тоесть вот еще раз.
у нас есть исходный массив битов


010101101010101010101101010101010110101010110100


по условию задачи по природе информации нам важно
знать  в этом массиве все - общее число всех битов.
общее число каждого вида битов. точное расположение
битов 0 и битов 1
если мы это знаем мы полностью обладаем той ифнормац
ией котрую нам надо знать по условию задачи.
теперь мы ищем более компауную форму сохранения
этой информации. эта форма может не отображаьт все
аспекты этой информации но она должна позволять 
ОДНОЗНАЧНО при необходимости восстановить исходную
полную информацию.
если  я поделю исходны массив битов на групки 
по 4 бита

0101 0110 1010 1010 1010 1101 0101 0101 0110 1010 1011 0100 

а потом по словарю сделаю замену для каждой группы



0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111

то я получу


5 6 С A A D 5 5 6 A B 4 

теперь если я возьму эту форму и отдам ее васе

5 6 С A A D 5 5 6 A B 4 

то вася берет словарь. и по нему делая обратную
подстановку получает вот такой массив битов

0101 0110 1010 1010 1010 1101 0101 0101 0110 1010 

тоесть

010101101010101010101101010101010110101010110100

смог ли он восстановить исходную информаци в ее полноте? - ДА
у нас общее число битов совпадает с иходной формой,
позиция все битов 1 и все битов 0 тоже совпдает
как у исходной формы.

но это все возможно только если исходный массив
битов кратен ЧЕТЫРЕМ. если он не кратен пытаться его
вснууть  в хекс форму это преступление!
нармиер исходный массив битов это

11

и говорить что  хекс форма

3

кодирует этот массив битов это преступление.
согласно нашему словарю 

3 это 0011 

и массив информации 11
и массив информации 0011 
это соверешенно разные вещи.


тоже самое как соверенно разные вещи вот такие
два массива битов


  101010101010110101010010110101010101011000

и
111101010101010110101010010110101010101011000


поэтому считаю что  писать что вот такие хекс
формы кодируют такие то 7 битные массивы битов
это вранье это преступление. 

тоже самое пытатся кодировать 7битные 
масивы битов чреез OCT .

а ведь такое написано в 

  $ man ascii


показываю

   Oct   Dec   Hex   Char
   ───────────────────────
   100   64    40    @
   101   65    41    A


полная хуйня

у нас символ @ и A  имеют соотвсвтие вот таким 
7-битным масивами битов


     Bin      Char
   ─────────────────
   100 0000    @
   100 0001    A


соотвесвтенно они утверждают что 
массив битов   100 0000   и хекс форма  40 
это одно и тоже. хуйня полная.

hex 40 это закодиоравнная форма вот такого массива
битов 0100  0000

теперь сравним настоящий массив битов
 100 0000
и массив битов который они нам подсовывают
0100 0000

еще раз

 100 0000
0100 0000

это два разных массива битов. это две разные
информации.

я вот щас так еще это поясню
у нас две корзины с яблоками (зелеными и красными)

  КЗЗ ЗЗЗЗ
 ЗКЗЗ ЗЗЗЗ


похоже ли это на то что обе корзины яблок одинакоыые?
нЕт! хуня полная! вих ней корзине лишне яблоко!


еще одно вранье которое онипишут втойже таблице
что якобы вот эти два массива битов  которые 
закодированы этими двумя формами явяляются одинак
оывми

  OCT   HEX
  100   40


проверим

OCT 100 это BIN 001 000 000
HEX 40  это BIN 0100 0000

сравним

001000000
 01000000

разве это одно и тоже?

проведу еще раз анаологи с корзинами яблок

ЗЗКЗЗЗЗЗЗ
 ЗКЗЗЗЗЗЗ


конечно же даже на уровне яблок это разные массивы!



напоследок.
а что если словарь состоит из десяти символов
0 1 2 3 4 5 6 7 8 9


попробуем закодировать одно битные массивы

0 = 0
1 = 1

отлично. но еще 7 символов оказались ненужны

порбуем двухбитные массивы битов

0 = 00
1 = 01
2 = 10
3 = 11

уже лучше но все равно остаются незадейтствоаныне
символы  а нахрне тога они ужны.

пробуем трехбиные массивы

0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111

у нас осталось двас мвола 8 и  9 которые не в удел.

пробуем четырех битные массивы


0 = 0000
1 = 0001
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111
8 = 1000
9 = 1001
? = 1010
? = 1011
? = 1100
? = 1101
? = 1110
? = 1111

мы использовали все симвыол из словаря
но проблема в том что у нас еще остались четрыех
бытные массивы котоыре мы уже закоодивать не можем
тоест этой кодировкой можно пользовться но 
только для частных случаев массива битов
тоесть есл у нас массив вида

1000 0110 

то мыможем его закодирвать в

8 6 


а если у нам массив вида


1000 0110  1111

то как его кодировать

 8 6 ?


опять же 
мы можем составить словарь вот так


0 = 0
1 = 111
2 = 101011
3 = 010
4 = 101010101001
5 = 1001010
6 = 01010101001001010
7 = 1010
8 = 1
9 = 11

нас никто не ограничивтает что якобы мы
должны кадждый символ сопоставлят с массивом
битов одинаковой длоинны. нет. 
но пользовться на пракктие такой ситстемой
прккодировки во первых неудобно. во вторых
она позволяет ей пользватся только для 
массива битов котоыре имеют очень частный вид

например массив

 1010 1 11

его можно закодрвать как

7 8 9 

а можно как 

7 8 8 8

тоесть у нас еще и однозначнсти нет!

поэтому такое правило кодирования нам не подходит.



тогда придумали вот такое правило кодирования.

сказали вот что возьмем вот такую формулу

(0/1)*2^n +...+(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0


тоесть это сумма из ДВОЕК в такйото степени
и при них стоит коэфициент либо 0 либо 1.
вначале мы опреляемся какой n взять путь это 
будет n=5 тогда

(0/1)*2^5 +
+(0/1)*2^4 +(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0

на втором шаге мы выбираем значение в каждой 
скобке там где 0 или 1  напимер 


(1)*2^5 +
+(0)*2^4 +(1)*2^3 + 
+ (1)*2^2 + (0)*2^1 + (0)*2^0

теперь считаем что получилось

44

потом берут коэфициенты вскобках и рисуют их
рядышком

101100

и говорят что согласно этому правилу они мапят
символы 44 на массив битов 101100

так как у нас в скобках стоят только 0 и 1
то при таком подходе у нас массив из этих коэфииц
ентов это всегда будет хрень вида
 1010101010101010101010101

и так как арифмт формула использует символы
01234567890
то результатом вседа будет набор символов вида
129371298371928371928

тоесть ровно точно из словаря (01234567890)
который нам нужен

при таком правилу устанолвения соответвия есть
одна проблема. у нас одному и тому же дестичному
числу сооветсвует не один а миллион битовый
массивов. тоесть это 

101100
0 101100
00 101100
и вообще любой массив вида

(0..0)101100

потому что если мы подставим эти коэфиценты в фор
мулу мы всегда получим 44  !

тоесть 
биты ----> 44
преобразуются однзначно 

а
44 ------> биты
непреобразуется однозначно

тоесть если мы видим на бумаге напиасно

 DEC 44

то мы не можем восстановить точно оригинальный
массив битов. 
а это хуйня полная.
единсвтенно как мы это можем сделать если рядом
будет написано какая полная длинна была у оригиналь
ного массива битов . например 

 DEC 44 , 12бит

тогда мы можем сказать что это запист кодирует
оригинаьный массив

 0000 0010 1100

при такой оговоре , наше дес правило и наша DEC 
запись позволет однозначно восстановить информацию
об оригинальном массиве битов


при таком правиле массив битов мапится на
коэифицианты разложения дестичного числа 
по базису степеней  двойки.


возникает вопрос если я беру десятичное 
число  N например 44 то  могу ли я быть уверен
что множество коэфиицентов разложения единственное
или нет. тоесть что наше 44
раскладывается только в 

(0..0)101100

и что нет других вариатов типа

(0..0)111110

итп 

а то у нас получится хуйня. хотя она уже итак
получилась. но тем не мнее что бы у нас не 
получилось так что мы взяли   битовый массив
 
  101100

подставили в формулу , получили 44

записали на бумаге 44

а потом оказалось что есь другой массив

 111010

который при подставновке в формулу дает тот
же самый 44 и это будет п..ц
но тут я думаю математика доказыает что разложение
единственное 

101100

при условии наличия вот еще такого прикола

(0..0)101100

который нам дает нединственность но которая
уже через пень колоду  устранимая.



Далее походу вот как они имеют дело с HEX
они говорят пусть у нас есть десятичное число
тогда его можно разложить с одной стороны 
по степеням двойки. с другой стороны по степянем
десятки(собственно это и есть десятичнрая форма
числа)  с третьей стороны по степеням числа 16
причем в чем прикол. коэфиицент который будет
стоять в каждом члене он будет в диапазоне
интерсном лежать . тоесть 
если мы раскадыдваем число по стееням 10-ки 
то коэфицинет всегда будет в диапазоне

  0<= K <= 9

еси мы раскываем число по степеняем двойки
то 

  0<= K <= 1

по степеням числа 16 

  0<= K <= 15


итого 

44 = (4)*10^1 + (4)*10^0


44 = (1)*2^5 + (0)*2^4 +(1)*2^3 + (1)*2^2 +
      + (0)*2^1 + (0)*2^0


44 = (2)*16^1 + (8)*16^0


одно и тоже дес число мы разложили по 
степеням 10-ки, 2-ки, 16-ки.
как видно кофэицианты при каждом члене
меньше этого числа по степеням которго
мы разлагаем.

так вот они говорят что раз число одно тоесть
сущность во всех трех случая одна и та же
то давайте мы просто возьмем и запишем каждый из
примеров в виде массив кофицинтов

10: 44
2 : 101100
16: 28

ну а дальше они говррят что раз коэфииценты разло
жения единственные то можно использовать эти
все три нотации как заменяющие одна другую
и получается что 

 hex 28  кодирует bin 10100

толко у меня тут маленькая но мерзкая поправочка

это не совсем так. коэфиценты у нас не однозначно
опредяеляются и на самом деле все выглядит вот
так

вот как на самомо деле выглядит разложение
числа 44 

10: (0..0) 44
2 : (0..0) 101100
16: (0..0) 28


если мы рассматриваем эти нули вс кобках как
коэфиценты которые мы подставляем в арифм 
формулы что наверху то они нам погоды не делают
потмоу что в итоге в любых случаях получим одно
и тоже число 44. но! если мы маппим эти нули 
на массив битов то тут уже извините! - если 
нам все равно какой набор коэфиицантов
либо такой

101100

либо такой

00000000000 101100

подтставлять в формулу арифм разложения. потому
что мы получим все равно 44

то массив битов 
такой 101100
или такой 00000000000 101100
это совершенно разные массивы битов!


тоесть вот что получается.
вот у нас есть массив из n битов. и его легко 
можно превратиьт в DEC число подставив в формулу


DEC:  (0/1)*2^n +...+(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0

это прямая формула. мы очень легко можем установить
(замаипить) dec число имея массив битов

биты ------> DEC 

это очень простая легкая быстрая и однозначная
операция. тут поблем нет.
но вот мы передали это DEC число васе
и ему нужно выполнить обратную операцию.
восстановить изначлный массив битов .

и тут как я сказал часть вида массива битов
вася восстановит однозначно. но другая часть
этого массива - ее невзможно определить однозначно.
тоесть дали мы васе 
  
  DEC = 44

вася однозначно узнает что часть массива битов
это точно 

  101100

но невозможно точно как выглядит осталная часть
этого этого массива. это чтото вот такого вида
(0..0)

тоесть любой массив 

(0..0)101100

он сворачивается до 44
поэтому передавая васе 44 мы должны обязательно 
указать сколько бит есть в изначальном массиве битов.
напрмиер 


  DEC = 44,  число битов=10

только тогда вася может восстановить оригинанльный
массив битов который мы ему пердакли вкодированном
виде

   0000 101100


так вот теперь еще хуже. 
мы передаем васе  бумжку где написано


 HEX 28


вася подсталяет эту щтуку в формулу

HEX : (0-15)*16^n +...+(0-15)*16^3 + 
+ (0-15)*16^2 + (0-15)*16^1 + (0-15)*16^0

и получаем

(2)*16^1 + (8)*16^0
= 32+8=44

окей вася выяснил что  HEX 28 кодирует 
деятичное число 44
но нам то нужно не оно а массив из битов.
далее вася дейсвтиует по предыдущему пункту
и получает что  массив битов который подходит это 

(0..0)101100

если мы не сообщили зарнее полное число битов
то вася в пролете. но если мы васе об этом
сказали вот так


  HEX = 28,  число битов=10

только тогда вася может восставноить зашиорвнный
исходный массив битов


   0000 101100



тоже самое для OCT кодивания  . мы можем предсвати
число 44 как разложение по стееням восьмерки
тогда получим

44 = (0-7)*8^2 + (0-7)*8^1 + (0-7)*8^0
     = (0)*8^2 + (5)*8^1 + (4)*8^0

тогда получаем
8: (0..0) 54  


итого все разложения
10: (0..0) 44
2 : (0..0) 101100
16: (0..0) 28
8 : (0..0) 54  



ТАКИМ ОБРАЗОМ:
если  мы берем массив битов. потом этот массив
подсставляем в качестве коэфициентов разложения 
десятичного числа по степенями двойки и получаем
десятичное число то в эту сторону система 
работатет однозначно(BIN->DEC). любой массив битов
приведетпо формуле нас к одному и только одному 
десятичному числу. обратное же преобразование 
(DEC-BIN) неоднозначное если мы не укажем как 
доп условие сколько бит было в оригинальном массиве
битов. 

ну тогда в приницпе получается что мы можем 
через DEC кодировать массив битов любой длины,
главное при этом рядом с DEС указать какой длины
был оригинальный массив битов. это позволит нам
однозначно восстановит BIN из DEC

тогда в этом свете записи в man ASCII имеют 
смысл. тоесть 

вот у нас там написано

   Dec   Char
   ───────────────────────
   101     A


также там написано   It is a 7-bit code.

итак мы имеем

   DEC 101, 7-bit code


тогда да. мы можем имея эту инфо восстанвоить
исходный изначальный бинарный массив битов

(0..0) 110   0101

и теперь выбираем чтобы массив был 7 бит длиной
вот этот оригиналный битовый массив

  110  0101



Итак через DEC форму можно теперь коротко кодировать
битовый массив любой длины. главное при этом 
рядом с DEC формой указывать полную длину исходно
ого массива битов.  это поволит однозначно восста
новить исходный битовый массив.


теперь. про HEX.
вот мы имеем битовый массив. мы подставляем
его в формулу. и получаем DEC число.
зная его мы можем разложить это DEC число
по степням 16-ти и получить HEX представление
этого DEC числа. 


тоесть мы имеем масив битов 110  0101
мы подстлвяем их как коэфицианты в формулу

(1)*64 + (1)*32+ (0)*16 + (1)*8 + (0)*4 + (1)*2
= 101

десятичное число мы нашли. теперь мы можем для
него найти разложение по степеняем числа 16
это будет

HEX: (?)*256 + (?)*16 + (?)*1
    = (0)*256 + (6)*16 + (5)*1

HEX: (0..0)61

тоесть строго говоря   у нас много разложений
можно взять любое. нармиер 

 HEX: 00065

таким макаром мы установили цепочку


BIN 110  0101 ---> DEC 101 ---->  HEX 00065


теперь мы можем предать васе HEX нотацию
но нужно обязательно добавить чему равна полная
длина битоового оригинально массива


    HEX 00065,  длина массива 7



вася возьмем hex пдставить в формулу и найдет
десятичное число, это однозначная операция

  6*16+5*1 = 101

теперь ему нужно найти какой битовый массив
соовествует  этому числу.

вася опредить что это вот такой класс
массивов

(0..0) 110   0101

и используя инфо что длина массива 7 бит
он в итоге вычленит исходный массив

   110   0101



таким образом HEX тоже можно использовать чтобы
кодировать любой длины битовые массивы, но 
нужно обязательно к HEX нотации приклывать инфо
об полной длинне исходного битового массива. 
иначе жопа.


тоже самое про OCT



по какойто счастливой случайности связь HEX нотации
с BIN по арифмеитическому правилу разложения по 
стееням дает точно такой же маппинг 
как и связь между этими же субьектами по моему
правилу простого словаря


0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111


единсвтннное что нужно в конце подкорректировать 
длину массива ноли битами в одну или в другую сторо
ну опирась на то условие какой длины должен быть
конечный массив битов. 
напрмиер  дано


HEX 41,  массив битов 7 бит длиной

берем мой словарь
 4=0100  1=0001

тоесть 41 = 0100 0001

получаем

  0100 0001

теперь нужно откоретировать его длину до 7 бит
обрезав в голове нулевые биты или добавив в 
голове нулевые биты
получаем

    100 0001




чем приколна на практике еще HEX нотация,
тем что она позволяет супер быстро и легко
пррварить массив битов очень большой длины 
в HEX вид при минимальных вычислительных затратарх. 
мы берем   любой массив битов.
делим его на куски по 4 бита начиная от младего
бита к самому старшему. если в голове остается хвост
то мы его дополняем нулями до полных 4 бит.
тоесть дано

  01010101101010

разбиваем

  01 0101 0110 1010

доплняем его до полных 4 бит

  0001 0101 0110 1010

теперь либо по словарю заменяем каждые 4 бита
до HEX символа. либо это можно сделать налету
путем простых выичлсений.
берем 4битную хрень


  1010 

и высиляем для нее dec число. если оно лежит в
пределах 0-9 то это и есть HEX символ. а 
если оно 10-15 то надо помнить в голове небольшой
словарь 

 10=A
 11=B
 12=C
 13=D
 14=E
 15=F

посмотрим на нашем примере


  0001 0101 0110 1010


 0001 = 1 знаичит HEX 1
 0101 = 5 значит  HEX 5
 0110 = 6 значит  HEX 6
 1010 = 10 значит HEX A

значит в итоге

HEX:  156A,  полная длина ориг массиав 14 бит

очень важно указать какой длины был ориги
нальный битовый массив


для сравнения
вычислить HEX на оснвое BIN через разложение 
по кожфициентам стеепеней гораздо более ресурсое
мко!


HEX метод позволяет нам сократить оригиналный 
битовый поток в 4 раза в плане того сколько 
символов надо потраить на бумаге для его записи
ну вот реально оригинальный биотовый поток

  01010101101010

имеет 14 символов длиной на бумаге

а HEX нотация

  156A

имеет всего четыре. (14 дополнили до 16 и поделили
на четыре)


OCT нотация тоже самое . позволяет нам быстро 
и просто прервтить поток битов в более короткий
вид сократив его в три раза.

берем оригинальынй поток

01010101101010

делим на групы по три бита

  01 010 101 101 010

дополняем нулями до полной группы из трех бит

  001 010 101 101 010

тут даже проще. берем каждую группу из трех
битов и вычиялем его dec число. оно и будет OCT
заменой тоесть

  001 = 1
  010 = 2
  101 = 5
  101 = 5
  010 =2

значит 

OCT: 12552 , длина оригинаьного потока 14 бит

обязательно надо добавить. мы просто и быстро
соакртили битовый массив (его запись ) в 3 раза!
при этом нам даже ненужно как в случае HEX запоминать
преобрвзания вида 10=A

круто!!

теперь мне понячно поему в linux permsions 
мы их укзываем в виде OCT типа 666 или 0666

наприме 

 r--r--r--

он хранится в виде битов тоесть

100100100

закодируем этот масив битов в OCT вид

100 100 100

100= 4

значит

OCT: 444 , полная длина оригинаьного  массива 9 бит 

прикольно....

я так скажу! если сравнвить HEX нотаци и OCT 
нотацию то окт круче еще тем что из нее 
гораздо проще в голове восставнить  битовый вид
чем это можно сделать через HEX 

тоесть 
берем пример символ из ASCII

Oct   Dec   Hex   Char
───────────────────────
101   65    41    A



вопрос из какой формы быстрее всего 
я могу узнать битовый вид? ответ -из OCT формы!

OCT: 101

101 = 1 0 1 

1 = 001
0 = 000
1 = 001

значит BIN

001 000 001

и тперь еще вспминаем что символ asccii это 7-бито
вый массив битов
значит оргиналый массив битов это 

  100 0001

просто быстро круто и легко!!!!!


тепррь  я понял фишки и согласен с таблицей
ASCII с ее dec,hex,oct нотациями!


НО! это оказалось еще не конец.
Еще важные моменты.

Бит равный 0 это не отсутствие бита! Бит 0
это такоеже полноценное значение бита как и бит1

вопрос - во сколько раз сокращает запись на бумаге
DEC нотация? ответ - ЭТО ЗАВИСИТ содержимого 
бит секвенс! тоесть вот у нас есть секвенс длиной
8 бит и ее контент
 0000 0000

ее DEC 0 
   тоесть занимает 1 символ!

а вот секвенс той же длины 8 бит но с другим контен
том 
  1111 1111

и ее DEC 255
   тоесть он занимает 3 символа!

поэтому отвт на вопрос во сколько раз DEC нотация
сокращает битовую секвенс зависит от контента этой
битовой последоательности. два секвенса одной и 
тойже битовой длины могут иметь соверщенно разный
по длине DEC секвенс. 


далее. выше указано три нотации битовой секвенс
это DEC HEX OCT 
причем DEC самая хуевая потому что ее вычисление
очень труоемкий процесс в обе стороны. тоесть
чтобы вычислить DEC нужно работать сразу со всей
битовой секвенс целиком. если она длинная то 
это пиздец. тоже самое про итоговую длину новой
нотации. вот мы берем хрень длиной 8 бит
 
 хххх хххх и в завсисомсти от ее кокнретнгого 
контента у нас DEC нотация будет от 0 по 255 !
это же бред!

а вот берем HEX и мы точно знаем что ее нотация 
будет всегда всего ДВА hex символа. всегда!
также хекс нотацию легко вычислять! для этого
ненужно работать сразу со всей секвенс. делим ее
на кусочки и работаем с этми кусочками. тоже 
самое про OCT.
но hex немного трудоновато высчитывать в голове
а oct очень легко но он на 30% длинее получается
чем хекс. а можно ли придумать такую нотацию 
чтобы она была корче чем oct но считалась легче
чем hex. ответ к сожалению нельзя. в добавок я 
замечу что OCT это словарь из 8-ми символов
а hex это словарь из 16-и символов. я счиатю что 
размер словаря для "удачных" (тоесть легко считае
мых нотаций таких что можно поток битов разбирвать
на кусочки) зависит от вот такого правила.
берем биты , выстваляем их все в 1 и  смотрим 
какое дек число мы получаем. прибавляем 1 это и 
есть размер удачного словаря. тоесть

  1   

число 1  словарь из двух символов (0 1 )
он нам не интересен

 11

число 3. словарь (0 1 2 3)
я назову этот метод нотации QUADRO 
при ней мы делим поток на группы из двух битов
для них высчииываем дек число. это и есть новый
символ квадро. он легкий. но слабо сокращает
исхдный поток. пример

  10101011011010101010

  10 10 10 11 01 10 10 10 10 10

тогда 

QUAD: 2 2 2 3 1 2 2 2 2 2

далее

 111

это число 8. словарь ( 0 1 2 3 4 5 6 7)
тоесть это как раз метод OCT

далее

1111 

это число 16  . словарь (0 1 2 3 4 5 6 7 8 9 
10 11 12 13 14 15 16) или (0 1 2 3 4 5 6 7 8 9
A B C D E F)
это метод HEX

как видим между OCT и HEX нет  промежутчного метода
кодировки! увы!

далее

11111

число 32. словарь (0 1 2 3 4 5 6 7 8 9 10 11 12
13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
29 30 31) или  (0 1 2 3 4 5 6 7 8 9 A B C D E F G
H I J K L M N O P Q R S T U )
этот метод будет давать в два раза короче нотацию
чем HEX но еще сложнее по вычислению.


ДАЛЕЕ. HEX нотация она мапится не на биты а на 
dec число. это важно понимать.

  HEX --> DEC --> биты

тоесть hex нотация мапиится на биты не нарпмую 
а через посредника. через одно колено. ненарпмую!
еще раз HEX нотация она мапится на обычное число!
это важно понимать!
тоесть
hex нотация это ничто иное как коэифиценты которые
мы должны подстваиим в арфим формулу разложения
числа по степеням числа 16 и эта форумла нам 
дает обычное десятичное число!(причем в нотации
для понтов коэфициенты 10 11 12 13 14 15 16 заменны
на буквы! что усложняет понимание).пример

AB

это на самом деле
10 11

подсталвяем в форулу и она дает

10*16+11*1=160+11=171

итак нотация 10 11 маппится на число 171 но никак
не биты!!!! это уже число 171 както там мапится на
биты! поэтому якобы 10 11 кодирует биты.но в прямом
смысле это нетак!

важно тут еще то что НЕТ никакой связи между 
ДЛИНОЙ HEX нотации и длиной  битовой последрвательно
сти конечных битов.
пример имеем HEX нотацию

HEX: 0000000001
у нее длина как видно  десять символов.
если мы эти коэф подставим в арифм формулу то
получим всего навсего дек число 1.
а это число мапится на целую группу массивов битов
BIN: (0..0)1
которая как видно минимално имет по длине длину 
один бит. а как макисимум бесконечное число бит
по длине! это приводит нас к важному выводу! очень
важному выводу - если я смотрю на hex нотацию
и вижу что она сколько символов длиной например 
как в нашем случае 10 то из этой длины соврещенно
СОВЕРЩЕННО нельзя скзаать какой длины у нас битовая
посделтельность которая ей закодирована!!!! этого
никак не льзя сказать!
есть распотрраненнное заблуждение что если нарпиер
я вижу что у меня HEX это один символ

HEX: A

то это якобы означает что она 100% кодирует 4битовую
последовательно! это полное вранье! приавльный 
ответ - она кодирует целую кучу разннообразных
по длине битовых секвенсов! максималная длина 
такой цепочи равна бесконечномть!!! бесконечноть!!!
а минимальная длина цепочки зависит от .... щас
я разберу от чего она зависит!!
возьмм для начал hex из одного символа
для начала пусть это 0

HEX: 0

он мапится в дек число 0  и это число кодирует
вот такой класс биотовых секвенсов

 (0..0)0

тоесть мкаксиалаяная длина это +inf а минимальный
по длине секвенс это секвенс длиной один бит!

тоесть

 HEX: 0   
   ( кодирует класс битовых секвенс  1 .. +inf)

тоест если у нас HEX нотация это всего навсего один
символ и рваен 0 то я могу точно сказать что он
кодирует минимально один бит. это я точно знаю.
а вот какая на самом деле длина битовой секвенс
неизвестно. может и +inf но точне неменьше чем
один бит.

тоест мы смотрим на HEX:0  и понимаем что битовый
севенс который за ним стоит он точно как минмиум
1 бит длиной! как максимум +inf  , а скоько на
саомм дееле НЕИЗВЕСТНО! это должен был указать в
справке к этой нотации автор этой нотации!
тоесть наприер пусть я этот автор я беру секвенс
 
 00 000

кодирую его в HEX:0 и пишу на бумажке васе

  HEX:0    , длина исходной севенс 5 бит


как видим 5бит полностью попдает в наш интервал
(минмиум 1 бит .... макисиум +inf)


возьмем тепреь нотацию

 HEX: 1

она приводит к числу 1. и классу севенсей 
(0..0)1
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 1 бит .... макисиум +inf)

далее

 HEX: 2

она приводит к числу 2. и классу севенсей 
(0..0)10
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 2 бит .... макисиум +inf)

далее

 HEX: 3

она приводит к числу 3. и классу севенсей 
(0..0)11
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 2 бит .... макисиум +inf)


далее

 HEX: 4

она приводит к числу 4. и классу севенсей 
(0..0)100
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 5

она приводит к числу 5. и классу севенсей 
(0..0)101
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 6

она приводит к числу 6. и классу севенсей 
(0..0)110
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 7

она приводит к числу 7. и классу севенсей 
(0..0)111
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 8

она приводит к числу 8. и классу севенсей 
(0..0)1000
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)




далее

 HEX: 9

она приводит к числу 9. и классу севенсей 
(0..0)1001
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)



далее

 HEX: 10  или   HEX: A

она приводит к числу 10. и классу севенсей 
(0..0)1010
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)


далее соверенно по аналогии для
всех 

HEX: B
HEX: C
HEX: D
HEX: E
HEX: F


она приводит к числу 11-15. и классу севенсей 
(0..0)1011
(0..0)1100
(0..0)1101
(0..0)1110
(0..0)1111


тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)


итого мы получаем таблицу:
если у нас хекс секвенс состоит из одного
символа и это символ

HEX:0
HEX:1

и мы смотрим на эту нотацию и хотим понять какой
длины битовая секвенс которая кроется за этой нота
цией. сколько бит кроется за этой нотацией? 
ответ - точной длины нет. потому что под эту 
нотацию подходят цепочки разной длины. они все
кодируются этой нотацией. сюда подходят как длинные
цеопчки так и короткие. самая длинная цепочка
которая кодируется этой нотацией имеет длину +inf
но с самой короткой больше конкретиики. ее длина
1 бит. итак за данным хексом кроется битовая 
послеовательность как миниум 1 бит длиной. 

если мы видим

HEX:2
HEX:3


то за данным хексом кроется битовая 
послеовательность как миниум 2 бит длиной. 


если мы видим

HEX:4
HEX:5
HEX:6
HEX:7


то за данным хексом кроется битовая 
послеовательность как миниум 3 бит длиной. 


если мы видим

HEX:8
HEX:9
HEX:A
HEX:B
HEX:C
HEX:D
HEX:E
HEX:F


то за данным хексом кроется битовая 
послеовательность как миниум 4 бит длиной. 


я собираю это в более компактную таблицу
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~  HEX: 0/1 ( бит секвенс >= 1 бит)             ~
~  HEX: 2/3 ( бит секвенс >= 2 бит)             ~
~  HEX: 4/5/6/7 ( бит секвенс >= 3 бит)         ~
~  HEX: 8/9/A/B/C/D/E/F ( бит секвенс >= 4 бит) ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

теперь.  а что если  унас хекс секвенс два 
символа длиной.

HEX: NM

что можно сказать про длину бит секвенс за ним?

во первых нужно особым образом рассотеь частный 
случай когда N=0

HEX: 0M

в этом случае этот ноль можно отбросить. потому
что 

HEX: 00000000000000000M
и 
HEX: M

при подставлновке в формулу в качестве коэифициентов
дает одно итоже дек число
поэтому ноль можно отбросить, тоесть этот ноль
он никакого влияния на дек число в формуле влияния
неимеет.  в этом случае мы возврщаемся  к случаю
кода у нас один hex символ. (смотри таблцу выше)
в случае кодга у нас один символ так уже 0 имеет
занчение.

двигаем далее если N это неноль , то 
можно точно сказать что правый символ M в незавимосмти чему он кокнертнр равен кодирует
4 бита. а левый N кодирует то число битов которое
яуказано в таблице выше тоесть завссит от его
кокнркетного значения.
тоесть в общем случае двухбуквеннный секвес кодирует
минимум 5 битов. чтобы более точно скзать нужно
смореть чмему равен символ N
анрмиер 

HEX: 1A

так как 1 кодирует 1+ бит то вся констрауция 
кодиурет миумум 5+ бит

HEX: 90

так как 9 кдирует 4+бит то вся консуткрция
кодирует 8+ бит

Теперь общее правило. если у нас есть  HEX 
нотация 

HEX: 00000012213ABCD13234234


то первым делом мы обрасыаем слева все нули.
они роли не играют

HEX: 12213ABCD13234234


далее мы делим секвенс на две части. 
отрезаем левый символ

HEX: 1 | 2213ABCD13234234

теперь считаем число символов справа. каждый из
них кодирует 4 бита. в данном случае 16*4=64бита

потом берем число слева и ссмотрим таблицу выше
(та котороая прослучай кодга один символ)
в данном случае это 1+ бит

значит в итоге этот HEX он кодирует битовый секвенс
длиной как минимум 65бит

вот как расшифровать сколько бит кроется за HEX 
нотацией.

расмотрим на примре ascii таблицы.
мы знаем что в ней 7битовые секвенсы кроются
за hex  нотациями в диапазоне 00-7F

проверим 7F

HEX: 7F

7F = 7 | F

справа один символ. значит он дает 1*4=4 бита
слева у нас 7 который согласно таблицы выше 3+ бит
значит в итоге эта нотация она под собой кодирует
битовый секвенс длиной как минмум 7бит
ну и собсвтенно 7бит укалдвается внутрь "как минмиум
7бит".

а теперь посмотрим на нотацию 80 проверим что она
неможет в себе кодировать секвенс длиной 7бит

HEX: 80

80 = 8 | 0 
справа один символ что дает 1*4=4бит
слева 8 который соганос таблицы кодрует минимум 4бит
значит суммарно эта нотация кодирует миниум 8бит.
как видим 7бит сюда не укладывается.
проверим вручную
HEX 80 это значит 8*16^1+0*16^0=8*16+0=128 
тоесть hex 80 он мапит обычное число 128
разложим это число по степеням двойки

1*(0) +  2*(0) + 4*(0) + 8*(0) + 16*(0) + 32*(0) +
+ 64*(0) + 128*(1)

получаем ряд коэфициентов
1000 0000
тоесть 128 мапиится вот в такой класс битовых
секвенсов

(0..0)1000 0000

как видим минималный по длине секвенс котоырй 
кроется за 128 это  

1000 0000

а его длина 8 бит. так что за HEX 80  стоят битовые
секвенсы котоыре по длине как миниум 8 бит. и 
7битовый секвенс какой бы он ни был не входит
в этот диапазон!



ДАЛЕЕ. следущий момент.
рассмотрим массив данных. что такое массив
у него есть ячейки с элементами и есть порядковый
номер. тоесть важен нетолько контент но взаимный
порядок элементов друго от друга. 
например массив месяцев года.

(0)     (1)     ... (11)
Январь  Февраль     Декабрь

тоесть за январем приходит февраль но никак не 
декабрь.

теперь вопрос - нам надо сохранить этот массив
в хранилище. это можно сделать двумя способами.
можно начинать пихать в хранилище месяцы начиная от того каоторый имеет самый малый индекс и посленим
передать месяц с самым большим индексом
шаг0
Январь
шаг1
Февраль
...
шаг11
-Декабрь


а можно наоброт. первым переадвть в хранилище
месяц с самым большим индексом
шаг0
Декабрь
шаг1
Ноябрь
...
шаг11
Январь
Декабрь-Январь


тоесть вопос в том какая наша f(t) при сожхранении
этих элементов. какой элемент мы сохраним первым
а какой последним.
так вот если мы первым по времени в сторадж
пихаем элемент с наименьшим индексом то этот 
споосб назыается Low-Endian метод
второй способ назыается Big-Endian метод

я бы по другому это привел пример. вот у нас
есть холдлиник. и у меня есть туша свиньи. я ее
порезал на куски. если первым я пихаю туда 
хвост а последним голову то это Low-Endian
А если я первым пихаю голову а последним хвост
то это Big_Endian
вытаскиваник ксатти будет в том же порядке.
если первым был засунут хвост то хвост будет
вытащен первым. (в отличии от реально холодилиника
где порядок вытаскивания получается будет обратным).

так вот теперь я хочу понять когда мы на бумаге
пишем слово по буквам то это какой метод лоу
ендиан или биг ендиан. 
рассмотрим бумагу. и то как мы на ней пишем
слово. 

     Вася

бумага у нас разбита на ячейки. каждая ячейка 
имеет свой оффсет. офсеты нумеруются слева нанаправо.

(1)(2)(3)(4)(5)(6)....

офсеты читаются в порядке их нумерования
и заполняются в порядке их нумерования
тоесть тут выполняется принцип та буква которую
я запишу по вермени первой потом когда  буду
читать бумажку то она же будет прочитана первой.
это хорошо. это важно потому что если бы при про
чтении у нас бы менялся порядок то бумага бы
нам не подходила. но у нас с этим все окей.

теперт посмотрим на массив букв в слове

     'В' 'а' 'с' 'я' 

хочется понять какая буква имеет наивысщий
индекс а какая самый малый индекс
труно понять какая буква имеет наивысий индекс
потому что на основе чего этот индекс ей назначать?
если его назначать на основе того какая буква 
первее вылетет из рта то это не показатель потому
что та буква которая произносится первой это ана
лог того какой элемент более первее будет записан
или прочитан в\их стораджа. а это как раз таки
зависит от типа сторадж. если сторадж лоу ендиан
то первым будет записан\прочитан элмент с 
наиеньшим идексом. а если сторадж биг ендиан
то первым будет записан\прочитан элмент с 
навысшим идексом. поэтому незная тип стораджа
и услышав перый элемент мы как раз таки неможем
скаать это элмент с наименьшим или наивысшим
индексом! прикол!
поэтому смотрим на само мнжество букв

     'В' 'а' 'с' 'я' 

и пытаемся понять . какая буква имеет наисвысщий 
индекс. если у меня есть массив то что значит
если элемент имеет наимньший индекс или элемент
имеет индекс наибольший индекс , можно ли сказать
что элемент с наименьши индексом имеет мнее
важно значение чем элемент который имеет более
высокий индекс. врят ли. в массиве по идее
все элементы равны. нам важен только поряок
менжду ними. как месяцы в году. все они одинаковое
имеют друг от друга значение. засовыавая их в 
массив мы лишь хотим сохранить этот порядок. 
множество - это куча элементов где у них нет 
никаого взиамного порядка. как яблоки мандарины
и груши в корзине. нам лишь важно наличие элеметов
но неважно как они друг от друга лежат в зависимости.
массив хранит в себе нетлько элементы но и их 
взаимный порядок. тоесть если мы возьмем листок 
бумаги или книгу и вычленим из нее все буквы
и ссыпем их в мешок это будет множство. а если 
мы эти буквы посещаем на листик то это уже массив.
получается очень интересно.
вот уменя есть сторадж. у него есть ячейки
и эти ячейки имеют адреса (1 2 3 4 5 )
по сути стордж это массив. внутри этого стораджа
массива у нас лежат данные. я читаю оттуда данные
в оперативную память которая по своей сути тоже
сторадж тоже массив тоже имеет адреса (1 2 3 4 5)
так вот я читаю со стораджа данные по элементно.
и получаю скажем числа 
 12  3  45  46 99  17 1

поскольку я незнаю какой это тип стораджа то 
я незнаю в таком ли индексном порядке эти элменты
сидели в исходном массиве или обратном. и опредиьт
это неовзможно если несообщат какой это тип
стораджа. 
если у нас исходный массив это 

январь - февраль - март -... -декабрь
тоесли я его запишу вот так
декабрь-...-март - февраль - январь
то взаимное расположение элементов друг отогосите
ьно друга сохраняется. потери информации по сути
нет. распожеие друг относительно друга сохранился.
тоесть декабрь как был относиельно января на расто
янии 12 элемнтов так оно  вобоих случаях и сохра
няется. 

теперь я пытаюсь поняь вот берем слово. оно
состоит из букв. это по сути массив. но как понять
какая буква имеет в нем наоименьший индекс.
на основе какого критерия это можно опрееделить?

я бы сказал что заглавная буква имеет наименьший
индекс

  В[0] а[1] с[2] я[3] 
 
тогда написание этого слова на бумаге
 Вася

нам дает то что бумага является low-ending храни
лищем данных. потому что первой на бумагу ложится
буква В с наимншим индексом а посеним на бумагу
ложится я который имеет наибольший индекс
при чтении также первым к нам  бумага возвращает
символ у  которого в исходном массиве наомеиньший
индекс. 

а что на счет чисел?

  1234

нуууу. написание числа у нас по сути это коэфици
енты разложения числа по степенями десятки

(1)*1,000 + (2)*100 + (3)*10 + (4)*1

нуу... наверное по идее исходя из этого фактора
у нас коэифиуент 1 имеет сущесвтенное влияние на
фактическую его вклад в число. а кэфицинт 4 имеет
минимальрый вклад. исходя из этой логики я бы
предпоожил что эти кофэцинты нужно совать 
в массив вот в таком порядке

4[0]  3[1]  3[2]  1[3]

хотя опят же по мне это вкусовщина. чем хуже
схема вот такая

1[0]  2[1]  3[2]  4[3]

  

если конечно исходить из того принципа что 
массив по своей сути это хранилище кусочков
чего целого чегото более большого а также 
если считать что эти кусочки имеют разное
значение для этого целого 
и если счиать что индекс отоббражает величину
этой ценности тоесть чем ниже индекс тем 
ниже вклад этой хрени в это целое то тогда
вот что будет получаться.
элемент 1 имеет макс вклад в число 1234 потому
что он по собой подразумевает число 1000
элемент 4 имеет мин вклад так как он поарзаме
вает под собой число 4. исходя из всего этого
то массив будет вот такой

4[0]  3[1]    2[2]   1[3]

учитвая что на бумаге мы записыаем этот массив
в виде 

1234

то получается бумага по своей сути это Big_Ending
хранилище данных.


теперь про слова.  если применять туже логику что 
буквы в слове имеют разный вклад. тоест если мы
возьемем слово например

    зеленый

то у него есть предлог есть корень есть суфикс
и есть оконачение. в целом у слова самая важная
хрен это корень. он лежит илив самом начале 
слова или чуть правее. тоест я бы сказал что левая
часть слова более важная чем правая. она хранит
главную смысловую ифномрацию. тут конечно предлог
несколько ломает эту картину. тоесть бя скзаал что
вот как распредлется важность букв в вслове

 пред кор    суфф  окон
|    |     |      |    |
 мало много средне мало


в целом получается предлог+корень имеет больше
значения для преедачи смысла слова чем суфф+оконч

из чего я делаю типа вывод при той логике что я 
обозначил выше что в вслове 

   Вася

его нужно всталять в массив вот так

 я[0]  а[1] с[2]  В[3]

учитвыая что на бумаге оно выглядит как

    Вася

то  получается опять же что бумага это Big-Endian
хранилище!


то есть получается если мы на бумагу заносим какую
то сущность (слоово или число) то более первым 
по времени (или в более младший офсет бумаги) 
кладется бОлее значимый элемент сущности. 
у числа первым кладется его самый мощный коэфицент
который вносит галный вкладв в величину числа
а у числа кладутся его буквы которые входят в состав
корня который вносит самй главный вкклад в передачу
смысла слова (хотя первой на бумагку кладетя притавка
ну да ладно. возможно приставка предает еще более
важный смысла слова чем корень?)

прикол что в устной речи мы говрими также как на
бумаге но в чем прикол - если мы будем рассмарвать
не буквы как элементы а слова как эелменты то 
мы помещаем как правило (по крайней мере амеркианцы)
самое важное слово в конце предожения!

тоесть получается полный прикол! на бумаге или 
в речи что касается фиксации слов или чисел 
через буквы мы юзаем метод Big-Ending а если 
при этом мы рассатрвиемт слова как отдеьные эелменты
то тогда у нас бумгаа и речь прервщаается в Low-Ending хранилище!!! жесть!


теперь нужно еще коечто важно дбавить на счет
HEX нотфиикации. на бумаге мы ее пишем воттак

    ABCD

тут символ 'A' это коэфиицент который в арифм
выражении имеет макс вклад в занчение коенчного
дек числа а  'D' это коэф который в арифм  выражеии
дает мин вклад на занчение дек числа. тоесть
массив имеет вот такой вид

 D[0] C[1] B[2] A[3]


соовтсвтенно опять же бумаг как видно вялется
хранилищем типа Big-Endian

тоест если мы видим на бумаге HEX нотфикацию
то знаяя что бумага это Big_Endan хранилище
для слова, дек чисел и хекс нотификаций 
мы можем четко понимать какой был типа исходный
массив данных. тоесть вот еще раз на счет
hex нотфиикации. 
вот у нас есть разложение числа в коэфицианты

 (12)*1 + (6)*16 + (3)*256

то возникает вопрос как эти коэфиценты заисать
на бумаге. то ли   B63  толи  36B
чтобы человек читая бумагу точно понимал в какой
член нужно вствлть каждый кожфиицент. мы уже
вроде как установили что бумага это Big-Endian
хранилище символов. исходя из этого нам
на бумаге это нужно писать вот так

  36B

потому что коэфицинт 3 делает самый важный вклад
в число а символ B самый мелкий вклад.
если мы знаем начальны оффсет на бумаге и начнем
оттуда чиатть символы то мы четко знаем что первым
записан символ с самым большим вкладом в смысла
слова или числа или HEX числа. а самым последним
мы считаем самый мало значимы символ. поэтому
например мы точно знаем какие из прочитанный
коэфициантов точно куда вставить в hex формулу

значит теперь отметим что экран монитора в режиме
редатора текста для СИ это точный аналог бумаги.
далее если мы пишем на экране HEX нотацию 

   0xAB22CD

то так как экран это полный аналог листка бумаги
то эта нотация втоности совпдает с бумажной
а так как мы выяснили бумага это Big-Endian храни
лище симоволов, элементов массивов. то и на экране
у нас запись  0xAB22CD  указана  в режиме Big-Endian
далее мы помним что hex нотация по своей сути
это кодированная последовательность битов. как
я ранее писал по правильному если мы пишем hex
нотиикацию то также нужно укзывать и полный размер
исходной битовой посдеовтености которую оно кодирует
и тут на компе деействиует незримое правило у компи
лятора (как  я понимаю) он считает что каждый
hex символ кодирует в себе в точности 4 бита. 
далее комплиятор смотрит какой тип данных указан
слева. и если полный набор битов несовпдает с типом
данных слева то он допоняет незримо эту хекс
запись хекс символами 0. тоесть например 

 int i1 = 0xA;

справа по понятиям компилятора стоит 4 бита.
а слева стоит хрень длиной 4 байта. поэтмоу он 
налету заменит строку вот на такую

 int i1 = 0x0000000A;


также важно пнять что память это хранилище битов
кратное 8 бит. поэтому чтобы у нас там не стояло
слева и справа по факту у нас в память полетит
минимум конструция из 8 бит. 
так вот рассмотрим такую констркуицю

  char c1  = 0xA1;


слева у нас стоит хрень длиной 1 байт.
справа по понятим компилятора тоже указана хрень
длиной 2*4 бит или 1 байт.

возникает вопрос какой это будет байт? 
A1 или 1A ? значит комплиятор знает что мы 
пишем на экране как на бумаге поэтому  A это 
старшая часть получабайт а 1 это младшая часть 
полубайта. тоесть это будет вот такой байт 
с точки зрения компилятора

  1100   0001   в записи Big-Endian стораджа
                который умеет хранить побитоово
                
  1000   0011   в записи Low-Endian стораджа
                который умеет хранить побитоово


память у нас работает не  с отдельными битами
а с отдельными байтами. как она хранит биты 
внутри байта неизвестно. но известно то что если
мы в регистр цпу засунем многобайтовый битовый поток
то он его засунет в память с точки зрения сохранения
отдельных БАЙТОВ в Low-End порядке. 

я вовзращаюсь к этой строке

  char c1  = 0xA1;

справа у нас 8 бит, байт
неизвестно как память повторюсь хранит биты на
уровне байта внутри себя. то ли вот так


 младший офсет в памяти
  |
  1100   0001
  |
  самый старший бит


толи вот так


 младший офсет в памяти
  |
  1000   0011
            |
            самый старший бит


но известно что память на уровне отдельных байтов
сохраняет их в порядке Low-Ending
значит скорей всего и на уровне отдельных битов 
он делает также то ест скорей всего вот так 
в итоге 



 младший офсет в памяти
  |
  |         старший офсет в памяти
  |         |
  1000   0011
  |         |
  |         самый старший бит байта
  |
 самый младший бит байта


если бы бумага была low-Ending сторадж
то  наши hex коэфиициенты выглядели бы на ней
вот так

  1A


теперь рассмотрим  вот такую строку в тексте
программы


  short int i2  = 0xA1B1;


слева указана сущность по длине равная 2 байта.
справа указано по мнеению компилятора тоже
сущность по длине 2 байта потмоу что (по мнеению
компиляотора) 4*4=16бит  = 2 байта

с точки зрения бумаги мы записали справа  хекс
кофиифенты в таком порядке что левыый самый
значимный а правый самый ничтожный. (так как бумага
это Big-Ending хранилище) тоесть эти коэфиенты
они вот так подставляются в арифм формулу

(1)*1 + (B)*16 + (1)*16^2 + (A)*16^3
= (1)*1 + (11)*16 + (1)*16^2 + (10)*16^3
что приводит нам к десятичному числу 41393
которое в свою очередь разбивается по степеням
числа 2 вот в такой ряд коэфициентов 


  1010 0001 1011 0001
  |                 |
  2^15              2^0

так как мы знаем что нужно сгенерирвать битовый
поток длиной  2 байта тоесть 16 бит то вот
мы его уже получили


  1010 0001 1011 0001
  |                 |
  старший           младший
  бит               бит


причем если мы делим наш массив битов на куски
по 8 бит тоест на байты то можно еще написать 
воттак

   старший    младший
   байт        байт   
  1010 0001 1011 0001
  |                 |
  самый             самый
  старший           младший
  бит               бит


если мы рассмотрим отдельно старший и младший
байт и попробуем для них найти экваиалентные
hex выражения то мы получим


    A1         B1

  старший    младший
  байт        байт   

  10100001  10110001


далее цпу запишет эти байты в таком порядке 
в память что вначале младший байт потом старший
байт. и как я полагаю что и биты по такому же правилу
поэтмоу в память все будет записано вот так


младший бит       младший бит
младшего байта    старшего байта
|                  |
10001101           10000101

--------------------------------->>>>>>>>
младший адрес                   старший адрес
в памяти                        в памяти




еще раз посмотрим на эти биты и то как 
они будут лежать в памяти



    адреса памяти
--------------------------------->>>>>>>>


младший бит       младший бит
младшего байта    старшего байта
|                  |
10001101           10000101


теперь я запишу  первый массив битов в формате
HEX причем я сохраню при его написании порядок
важности я сделаю Low-Endian
получаем

   1B

и тоже самое про второй массив битов

   1A

в иттоге получаем что биты в памяти лежат 
вот в таком порядке выраженное чрез HEX



          1B   1A

    адреса памяти
--------------------------------->>>>>>>>


тоесть еще раз.  вот у меня записано
первый хекс 
 
  1B

и мы указываем что самый неважный коэфиициент слева
а полная длина массива битов это 8 бит.
я подтслвяю эти коэфииценты в формулу
и нахожу дек число

1*1+(11)*16=176

раскладываю это число в разложение коэфиицентов
ряда из степеней двойки и выписываем их

10001101
|
самый младший бит


теперь 

  1A

учитывая что слева самый слаюый коэфициент
получаем дек число
1*1 + 10*16 = 161


раскладываем его по степеням двойки и выписываем
эти коэфициенты 

10000101
|
самый младший бит


итак мы имеем в памяти 



10001101                     10000101
|                            |
самый младший бит            самый младший бит


а теперь сравним с потоком битов которые
были закодированы на бумаге 


  short int i2  = 0xA1B1;


  1010 0001 1011 0001
  |                 |
  2^15              2^0
  |                 |
  самый             самый  
  старщий           младший
  бит               бит


еще раз посмотрим


10001101  10000101
10100001  10110001

по сути это одна и таже последоватлеьность
битов но она повернута с хвоста на голову.
так вот. получаетя вот как
на бумаге у нас было условно говоря записано

   (старший байт)(млащий байт)

а в памяти оно записано
   (младший байт)(старший байт)

если я будут читать этот поток битов из памяти
в обьеме 2 байта за раз то это неимеет никакого
значения. а вот если я буду читать этот массив
из памяти кусками по одному байту за раз то 
мы получим то что если мы читаем этот поток 
с бумаги (там где сторадж Big-Endian )то первый
байт который мы получим будет (старший байт)
а если мы читаем всего один байт с памяти которая
Low-Endian сторадж то мы получим младший байт!
так вот если мы готовим битовую последовательность
(или байтовую ) для того чтобы потом ее отправить
на терминал , то прикол в том что мы на терминал
байты посылаем из памяти по одной штуке за раз
(при ASCII кодировании) символов , поэтому
учитвая все вышесказанное нам нужно в HEX нотации
в тексте программы указывать их в обратном порядке
чем они должны быть нарисоываны на экране. тоесть
скажем если мы хотим на экране получить

   qrst

и если их коды это 
q=0x71 r=0x72 s=0x73 t=0x74
то в тексте программы нам нужно написать

   int i3 = 0x74737271

эта заморочка имеет место если у нас именно
указано многобайтовый тип данных.
если же мы в явном виде можем указать какой
байт в каком пордке записать в память то 
таких заморочке нет и тогда можно указать прямой
порядок симолов

 char c3[4] = { 0x71, 0x72, 0x73, 0x74  }

собствтенно ради обьяснения этого явления все
то что наверху расписано.


вот пример проги


#include <stdio.h>


int main() {

     int i3 = 0x00737271;
     char c3[5] = { 0x71, 0x72, 0x73, 0x00  };

     printf ("i3 = %s\n", &i3 );
     printf ("c3 = %s\n", &c3);

return 0;

}


вывод на экран

i3 = qrs
c3 = qrs




когда мы сидим в текстовом редакторе
для СИ и в тексте в явном виде указываем массив
его элемент и индексы тоесть

 char c[4] = { 0xa, 0xb, 0xc, 0xd };

здесь мы в явном виде соощаем компилятору какой
инекс имеет кажый элемент. тоесть мы явно
сообщаем что элемент 0xa имеет индекс [0]
а эдемент 0xd имет индекс [3]
тут все понятно. все в явном виде.
