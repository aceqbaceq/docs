| bit
| bits
| 7-bit
| 7-bits
| 7
| 8-bit
| 8bits
| 7bits
| byte
| Endianess
| Low-Endian
| Big-Endian


ВНАЧАЛЕ СТАТЬИ Я ПРИХОЖУ К ОДНИМ ВЫВОДАМ
В СЕРЕДИНЕ К ДРУГИМ. А В КОНЦЕ ОПЯТЬ  К
ИСХОДНЫМ. ПОЭТОМУ НАДО ЧИТАТЬ ВСЕ ЦЕЛИКОМ.






изначальный вопрос - что такое HEX,
и можно ли кодировать
7-битные байты через hex кодировку, корректно ли так
говорить? и ответ на этот вопрос совершенно не прост.
также затрагивается вопрос что за хрень low-endian
big-endian. это тоже хрень еще та.




что такое бит это обьект вида 1 либо 0 

бит можно сравнить с яблоком. оно либо красное
либо зеленое. еще прикол его в том что его можно
превращать из красного в зеленое из зелного в
красное


биты можно через электроаппараты передавать на 
расстояние от одного носителя битов к другому. то
есть у меня внутри комп1 есть яблоки

красное зеленое зеленое красное зеленое

можно сделать так что за 1000 км внутри друого
компа возникнет точно такое же множество яблок

красное зеленое зеленое красное зеленое

нельзя по проводу скопировать живые яблоки а 
биты можно


кто то может передавать по одному биту за раз
гдето аппараты умеют передавать сразу по несколько
битов за раз


кучка битов образует множество битов

1010101010110101010101001010101 

корзина полная яблок
только не просто корзина , биты имеют еще и 
ящички с номерами в котоыры они лежат

ящик1( красное зеленое красное красное)
ящик2(зеленое красное зеленое зеленое)

ящики это например адрес ячейки RAM
но в целом ящики неважны. ящики это тара упаковка,
важен конкртеный контент

внутри компа обычно биты хранятся  и передаются
от одной запчасти внутри компа в другую кусками
квантами - байтами.

размер байта может быть разным но обычно это 8

0101 0101

тоесть комп это хранитель битов но обрабатыает он
их внутри себя и двигает между своими разными
частями не по одной штуке а 8 штук за раз или 
числу кратному 8 

в целом в разрезе файла важно то что мы имеем
набор битов которые сохранены в упорядоченной форме
тоесть они имеют порядок


самый перый бит
|
\/
10101010101010101010110011010101010101010110
11010010101010110010101101010101010101010101
                                           /\
                                            |
                                         самый 
                                         последний
                                         бит

ценность составляет именно набор упорядеоченных
битов. это как картина - это набор капель (пусть 
картина черно белая) которе нанесены на бумагу
в строгом порядке. поменяй эти же капли на бумаге
в раномные места и от ценного контента картины
не остаентся и следа.

итак нам важны такие моменты: количество битов 
внутри файла (число яблок в корзине) и порядок
в котором они лежат внутри. как буквы внутри книги
имеют строгие порядковвые места. 

итак комп это хранитель битов. их там много.
они хрантся в больших кучах - файлах.
внури файла они свалены не просто в кучу а каждый
бит имеет свое порядковое место.  файлы лежат на
диске. там у нас биты хранятся упорядоченными 
кусками по 512*8 (раньше) и 4096*8 (сейчас) штук.
на ssd дисках размер такого куска еще больше.
эти биты считываются в память сохраняя свой порядок.
но в памяти кусок считанынй с диска разбивается
на тот же набор битов но разрезанный на куски
по 8 бит. кусок размером 8 бит это основной размер
куска которым оперирует комп при работе с битами.
8 бит это минимальный размер которым можно опер
ировать битами в памяти. такой же размер работы
с битами внутри цпу в регистрах. 
аналогия может быть такая - на диске буквы (биты)
хранятся в виде книжек с листочкми.
в памяти буквы уже лежат в форме листочков.
кнмжка это блок на диске. листочек это байт. то
число битов которое хранится в форме единой
хрени в памяти. листочек битов лежит и в регистре
цпу. таким образом между цпу и памятью биты 
циркулирую в группах размером с листочек. тоесть
нельзя прочитать из памяти в цпу отдельный бит
с листочка. из памяти можно в цпу прочитать 
только листочек. внутри цпу можно модифицировать
отдельный буквы в на этом листочке. обратно в память
можно сохранить только целиком листочек битов.
отденый бит в память записать нельзя.

итак бит (яблоко красно зеленое) это носитель 
иформации. остальные штуки - регистры, память,
диск это методы массового хранения этих битов. 

можно еще придумать аналоию с картинами. на диске
картины хранятся в виде точек краски. в каждой
коробке дохрена этих точек. но они там лежат
в упорядоченном виде. в память когда считаем с диска
то эти точки переходя в отдельные картины. 
внутрь цпу из памяти можно копировать толкьо в 
форме картин. внури цпу можно на картине менять
отдельные точки на картине. обратно в память
из регистра можно записать только картину целиком.
если возвращаться к яблокми то в памяти яблоки
хранятся в форме лукошек (как уповка с яйцами).
упаковка такова что яблоки внутри упаковки имеют
номерные места. яблоки из памяти в цпу можно прочи
тать только в форме целой упаковки.
внутри цпу можно модифиуировать отдельыне яблоки
в этой упаковке. можно сделать яблоко номер  1
из зеленого в красное. можно скопировать из 
памяти из ячейки 1 упаковку яблок  и потом 
из цпу эту упаковку можно скопировать оборатно
в память в ячейку 2.

упоаковку яблок в памяти называют байтом.
размер упокаовки - колчесво битов внутри этой 
упаковки называют размером байта.
если в памяти лежит упоакока из 8 битов то 
на этом компе размер байта равен 8.
8 еще называют разрядностью байта.

байт это основная единица  , основной кусок 
которым обрабатывается массив битов внутри 
компа. 

итак комп это такой огромный склад мелких битиков
(как гвоздей). только это не просто куча а это
куча гвоздей имеющих своих номера. и разложенных
по упаковкам. комп  это машина которая постоянно
пеекладывает эти гвозди с одного места на другое.
цпу как экскаватор работает с массивом этиго
моря гвоздей ковшом. а не по одной штуке.
ковш это байт. размер ковша это размерность байта.
обычно это 8. тоесть комп ворочает эту кучу
гору гвоздей по 8 штук. диск это основное место
хранения гвоздей. это огромное море битов. упоря
доченное. как океан это массив капель но они там
неупорядовеннчеые а диск это океан гвоздей только
упорядочнных. там они лежат контенерами внури 
которых много гвоздей. скажем 4096 штук. упорядо
ченных. память это уже море гвоздей. тоесть с диска
гвозди берутся из контейнеров и перекладвыаются
в память и в памяти они раскадываются уже по более
мелким ящичкам. ящики упоряченные и внутри 
ящиков гвозди раскладываются тоже упорядоченно.
поэтому общий порядок гвоздей строго сохранятеся.
поэтмоу можно легко перекладывать из ящиков обратно
в контейнеры и наоброт. просто диск это множество
из больших контейнер гвоздей. а память это место
где находится множество более мелких ящиков из
гвоздей. внутри цпу находится совсем немного 
ящиков. цпу берет ящик из памяти и кладет внутрь
себя. гвозди внутри ящиков внутри цпу уже могут
быть просмотрены со стороны цпу и внутри ящика
гвозди могут быть имзенены. скажем внутри 
ящика ест ячейки. в ячейке либо есть гвоздь
либо его нет. цпу может менять состав ячейки.
может либо вынимать гвоздь либо вставлять.(либо
скажем гвоздь короткий либо длинный)
после тоого как работа с ящиком закончена цпу
может скопировать этот ящик в любой ящик в памяти.
а оттуда его сохранить на диск уже в составе 
большого контейнера. 


итак байт это количество битов которое
цпу обрабатывает за раз (из той огромной кучи 
битов которые вообще хранятся внутри компа). 

так еще представлю - на диске хрантся отдеьные буквы.
в упорядоченном виде. прям отдеьне буквы.
в с диска в память буквы копирются на листочки.
комп и памят обмениваются буквами на уровне листочков.
цпу может внутри себя менять содержимое листочка
и оратно вернуть листочек в память.  на диск
запиываются уже тлоько буквы без листочка. но порядок
сохраняется 

листочек (егообьем)  это тот характеный обьем букв
который цпу обрабваыет буквы из всего того огромад
ного обьема букв хранящися внутри компа.

так как биты лежат упордоченно на листочке то 
листочек имеет характерный рисунок. 
 
 0000 1010

количество битов на листочке - это разрядность байта.

вот эта хрень   0000 1010  это точное буквальное
отображение контента листочка. мы видим сколько битов
лежит внутри листочка и на каких позициях , ведь
нам важны нетолько сами биты их колчество но и их
позиция расположение. 
таким образом форма отображеия

  0000 1010
 
нам показывает всю информацию - сколько бит сидит
внутри байта и на каких позициях. еще аналогия с 
яблоками

  зззз кзкз

з-зеленое яблоко
к-красное яблоко


тоесть 0 это неостутвие информации. это другая
информация. у наас два вида информации 0 и 1
0 это не оствуие инфораии не пустота. просто 
наша инфомрация имеет две ипсостасии. зеленое
яблко и красное яблоко.

бинрная форма - это точная конечаная форма отобра
жения инфомрации. 

далее возникает необходимость придумать какую то
свертку этой информации. новая форма которая 
непозволяет нам видеть информацию но которая 
более компактная при написании на бумаге и которая
нам позволит однозначно восстановить исхдоную форму.
чтото типа того что делает zip алгоритм. он превра
щает исходный файл в новый файл. новый файл контент
напрямую своим видом не предает - инфомрация искажена
но можно при желании точно восставниоиить исходную 
форму. 

тоесть дело в чем
вот у нас исходная информация о битах

0101010101010101010110101010101010101010110101010101

она передает точную информацию о битах. их число
и позицию. но эта форма некомпактная. скажем массив
из 1000 бит займет тысячу знаков на бумаге. неудобно
громоздко.
нужна компактная форма. новая форма будет скрывать
саму информацию но занимать меньше места и по ней
можно всегда точно восстановить исходный массив
битов - их число и их позиции. тоесть если исходный
вид 

01010010101010101010

это буквы сложенную в фразу которую мы можем прочиать
типа

   пустьвсегдабудетсолнце

то нам нужна более компактная форма

   *??*?Р:*

мы ее напрямую уже прочиать не можем но она
занимает меньше места на бумаге. при этом сама ин
формация не потеряна. она свернута.  и ее при желании
можно восстановить. в комапактнйо форме ееудобно
передаавать или фикисровать на бумаге. 

исходя из того что я рассказал выше массив
битов

01010010101010101010

это нетолько единицы. это еще и нули. они тоже
несут ровно такую же полноценную инфомрацию как 
и единицы. нули это не осттие информации. информация
имеет двойной вид. два лица. тоесть это как баба и 
мужик

мжмжмжмжмжмжмжмжмжмжмжмжмжжжмжмжмжмжмжмжммж

тоесть оба вида бита несут информцию. 

а не так что 

м(нет мужика)(нет мужика)мм(нет мужика)...

нет такого нет.
тоест это не так как в вагоне поезда

пассажир(нет пассажира)(нет пассажира)(пасажир)

это так что 

(баба)(баба)(мужик)(мужик)(мужик)....


исходя из этого в массиве данных

01010101010101010101101010101010010101011010

и нули и единицы несут информацию.
тоесть наша информация не имеет вид типа :
     есть информаци
     нет информации

а имеет вид
    инфорация вида 1
    информация вида 2

тоест это как бы вот так

 2121212121212121212121212121212121212121212


просто внутри компа она хранится в виде 

 0101010101011001101010101010101010101010


но ноль это несотвутие инфорации. это тоже
информация. зеленое и красное яблоко.


таким образом полнота информации сохраняется 
тоько тогда когда  сохранено общее число и нулей
и единиц (суммарная разрядность), нули и единицы
сидят на своих местах.
таким макаром я считаю что бит это сущность
в виде 0 или 1  а не просто только 1. 
исходя из этого я считаю что массив битов

  11

и 
  
  0011

это два разных массива битов. соверешенно не совпа
дающие.  впервом сулчае у нас 2 бита в массиве информации а во втором случае 4 бита информации.
два красных яблока против два зеленых и два красных.

итак еще раз у нас есть некая информация. она имеет
две формы два лица. условно это 0 и 1
и 0 и 1 это  двоственная природа одно сущности - информации. это не так что 0 это остувтие иномраиции
а 1 это ее наличие.  это как монета имеет две 
стороны. нет монеты с одной стороной. тоесть 
приода информации двойственна. итак бит это конкртеная
форма  сущности-информации. чтото типа того как 
если бы электрон мог быть отриацательный и положите
льный. оба они электроны. но имеет два лица. 
итак бит это конкртеная форма некоей базовой сущности-информации.

далее мы собирем группу битов.

010101010101101010101

тоесть это сораные в кучку базовые информации в 
их конкретных формах.

мы нашли на земле кучу электронов только какието
из них оказались с плюсом а другие с минусом.
но каждый бит это электрон . а не то что там 
где ноль тамэлектрона нет.  каждый бит это наличие
электрона. 

 0010

в данном массиве у нас 4 электрона. три с минусом
один с плюсом . а нето что у нас один электрон
и три нихрена. 

из этой запииси мы можем скзаать что у нас 4 штуки
информации. ни больше ни меньше. 

так вот собирая элементанные информации в их двух
ипосасиях в кучу мы получаем некую более глобальную
информацию которая заключается в том что 
      * сколько у нас простых 
        информаций в сумме(разрядность)
      * сколкько у нас в сумме 1 и 
        сколко у нас в сумме 0
      * на каких позициях сидят 0 
        а на каких 1

точно также как точки нанеесенные на бумагу 
обрзуют макроинформацию - картину. 


вот это обозначение

  0010

оно нам в точости предает эту макроинформацию.
  * всего битов 4
  * один бит в форме 1
  * три бита в форме 0
  * их точные позиции 0010


итак для полной ппередачи макроинформации
нам нужно знать сколько у нас всего нулей и единиц
сколько из них каждого вида и на каких позициях 
они в точности сидят. только эта совопкупность
нам позволяет востставноиить полноту макроинформации


теперь мы ищем новую форму для этой информации.
новая форма небудет отображать все аспекты что
я описал выше. но она будет более компактная на 
бумаге и в ней будет заширована вся исходная информация тоесть исходную информацию всегда можно
во всей полноте восстановить.

мы берем словарь (множество) из символов
0 1 2 3 4 5 6 7 8 9 0 A B C D E F
это просто значки. символы не более того
на их месте могли быть любые другие. важно что
их 16 штук.

далее мы делаем устанавливаем вот такое 
соовесвие


0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111


таким образом я нашел новую форму обозначения
отображения (сохранения на бумаге) для 4-битного
массива байтов в более короткой форме

старая форма   1101
новая  форма   D

глядя на новую форму я "сходу" не могу увидеть
всю полному исходной информации. новая форма 
ее не передает! гляда на таблицу сверху можно
только скзать то что исходный массив бит состоит
ТОЧНО из ЧЕТЫРЕХ ШТУК! это я могу сказать сразу
точно! но эта форма не передает сколько нулей битов
и единиц битов содержит исходная форма и на каких
позициях. этого новая форма не передает! зато она
в четыре раза более компактная. и она позволяет
по таблице сверху восстановить при желании исходную
форму множства битов. и узнать то что нам надо.

тоесть если раньше чтобы на бумаге нам передать 
массив информации из битов 

 1101 1011  1001 0010 

нам нужно было затраить 16 символов. 16 позиций на 
бумаге. при этом у нас сразу видна вся полнота
информации . то новая более компактная форма 
передает эту информацию в более компактрной форме
через 4 позиции на бумаге

  D B 9 2 


всю полноту исходнйо информации мы не видим из 
этой формы. это минус. но мы можем точно восставноить
эту полноту информации (полный массив битов нулей
и битов единиц в их точном полном исходном количестве
и в точных позициях где они были). мы толоько сходу
можем точно сказать что полное число битов в исходной
информации равно 16бит. это мы сразу можем  сказать.

тут я хочу вернуться еще раз к важному аспекту.
вернемся к исходным битам.
вот есть два набора битов

11  и  0011

вопрос биты слева и справа составляют одинаковую 
информацию?  Я СЧИТАЮ ЧТО НЕТ!
слева у нас две сущности базовой информации
а справа у нас четыре сущности базовой информации.
да слева и справа у нас совпдаает число битов 1,
да у нас ПОЗИЦИИ битов 1 совпадают слева и справа,
но на этом все совпадеия заканчиваются. 
поэтому я считаю что слева и справа массивы информации
несовпадают. что это разные информации.

исходя из этого я считаю что если у нас есть
исходный массив битов
 
  101010110101010101101010101011010

то для его эквивалетного отображения HEX форму (01235
6789ABCDEF) можно использовать ТОЛКЬО ЕСЛИ общее 
число битов кратно 4. а если это нетак то хекс 
форму отображения применять нельзя невзомжно некоректно.

  1 0101 0110 1010 1010 1101 0101 0101 1010


в данном случае видно что обее число битов не 
кратно четырем. значит хекс форму применять нельзя!

почему? потому что у нас нет хекс формы для 
отображения массива битов вида 1

я вот еще как покажу. пусть у нас биты будут
не в строчку в а внутри прямоугльника

  0101011010101010
  0110101010101010
  1011010101011010
  0101011010101010
  1010101011010101


будем считать что это картина
у нас все биты несут часть информации. особенно
это будет очевдно если каждый бит может иметь не
две формы а скажем 16000. тоесть это оттенок цвета.
у нас нельзя из картинвы выколость ни один бит.
это будет не картина а картина с дырками.

так вот картина вида 

 0001

это некартина вида 

 1

потому что на верхней картине у нас все точки
играют роль а нетолько точка с 1. остальне выбро
сить нельщя. поэому

1 и 0001 это не одно и тоже поэтому
бинарный 1 и хекс 1 это не одно и тоже.
хекс 1 это бинарный 0001


исходя из этого я считаю что если у нас 7битная 
кодировка тоесть это такие байты которые имеют
внутри себя 7бит 

 000 1010
 101 0101
 110 0100
 110 0101

их нельзя отобразить с помощью hex вида.это некоректно!

хекс форма валидна только для отображения
исходных массивов битов общее число которых кратно 
четырем! а если это нетак то такие масивы нельзя
коректно превратиь в хекс вид!

посмотрим на OCT форму кодирования массива битов.
возьмем словарь из 8 символов. сиволы могут быть
любые но мы возьмем такие 
0 1 2 3 4 5 6 7

и сделаем соовесвтие между вот такими массивами
битов и oct символами

 0 000
 1 001
 2 010
 3 011
 4 100
 5 101
 6 110
 7 111


у нас каждый OCT символ "кодирует"( тоесть он 
условно его обозначает)  одному трех
битному массиву битов. 

тогда если у нас есть исходный массив битов 
и он кратен трем то мы можем его без потери
исходной информации "пеекодировать" в новую форму.
 
  010 101 101  

это будет
  2   5   5



OCT форма отображения массива битов не подходит
для кодрования массива из 7-и битов ибо этот массив
не кратен трем.!!

тоесть вот еще раз.
у нас есть исходный массив битов


010101101010101010101101010101010110101010110100


по условию задачи по природе информации нам важно
знать  в этом массиве все - общее число всех битов.
общее число каждого вида битов. точное расположение
битов 0 и битов 1
если мы это знаем мы полностью обладаем той ифнормац
ией котрую нам надо знать по условию задачи.
теперь мы ищем более компауную форму сохранения
этой информации. эта форма может не отображаьт все
аспекты этой информации но она должна позволять 
ОДНОЗНАЧНО при необходимости восстановить исходную
полную информацию.
если  я поделю исходны массив битов на групки 
по 4 бита

0101 0110 1010 1010 1010 1101 0101 0101 0110 1010 1011 0100 

а потом по словарю сделаю замену для каждой группы



0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111

то я получу


5 6 С A A D 5 5 6 A B 4 

теперь если я возьму эту форму и отдам ее васе

5 6 С A A D 5 5 6 A B 4 

то вася берет словарь. и по нему делая обратную
подстановку получает вот такой массив битов

0101 0110 1010 1010 1010 1101 0101 0101 0110 1010 

тоесть

010101101010101010101101010101010110101010110100

смог ли он восстановить исходную информаци в ее полноте? - ДА
у нас общее число битов совпадает с иходной формой,
позиция все битов 1 и все битов 0 тоже совпдает
как у исходной формы.

но это все возможно только если исходный массив
битов кратен ЧЕТЫРЕМ. если он не кратен пытаться его
вснууть  в хекс форму это преступление!
нармиер исходный массив битов это

11

и говорить что  хекс форма

3

кодирует этот массив битов это преступление.
согласно нашему словарю 

3 это 0011 

и массив информации 11
и массив информации 0011 
это соверешенно разные вещи.


тоже самое как соверенно разные вещи вот такие
два массива битов


  101010101010110101010010110101010101011000

и
111101010101010110101010010110101010101011000


поэтому считаю что  писать что вот такие хекс
формы кодируют такие то 7 битные массивы битов
это вранье это преступление. 

тоже самое пытатся кодировать 7битные 
масивы битов чреез OCT .

а ведь такое написано в 

  $ man ascii


показываю

   Oct   Dec   Hex   Char
   ───────────────────────
   100   64    40    @
   101   65    41    A


полная хуйня

у нас символ @ и A  имеют соотвсвтие вот таким 
7-битным масивами битов


     Bin      Char
   ─────────────────
   100 0000    @
   100 0001    A


соотвесвтенно они утверждают что 
массив битов   100 0000   и хекс форма  40 
это одно и тоже. хуйня полная.

hex 40 это закодиоравнная форма вот такого массива
битов 0100  0000

теперь сравним настоящий массив битов
 100 0000
и массив битов который они нам подсовывают
0100 0000

еще раз

 100 0000
0100 0000

это два разных массива битов. это две разные
информации.

я вот щас так еще это поясню
у нас две корзины с яблоками (зелеными и красными)

  КЗЗ ЗЗЗЗ
 ЗКЗЗ ЗЗЗЗ


похоже ли это на то что обе корзины яблок одинакоыые?
нЕт! хуня полная! вих ней корзине лишне яблоко!


еще одно вранье которое онипишут втойже таблице
что якобы вот эти два массива битов  которые 
закодированы этими двумя формами явяляются одинак
оывми

  OCT   HEX
  100   40


проверим

OCT 100 это BIN 001 000 000
HEX 40  это BIN 0100 0000

сравним

001000000
 01000000

разве это одно и тоже?

проведу еще раз анаологи с корзинами яблок

ЗЗКЗЗЗЗЗЗ
 ЗКЗЗЗЗЗЗ


конечно же даже на уровне яблок это разные массивы!



напоследок.
а что если словарь состоит из десяти символов
0 1 2 3 4 5 6 7 8 9


попробуем закодировать одно битные массивы

0 = 0
1 = 1

отлично. но еще 7 символов оказались ненужны

порбуем двухбитные массивы битов

0 = 00
1 = 01
2 = 10
3 = 11

уже лучше но все равно остаются незадейтствоаныне
символы  а нахрне тога они ужны.

пробуем трехбиные массивы

0 = 000
1 = 001
2 = 010
3 = 011
4 = 100
5 = 101
6 = 110
7 = 111

у нас осталось двас мвола 8 и  9 которые не в удел.

пробуем четырех битные массивы


0 = 0000
1 = 0001
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111
8 = 1000
9 = 1001
? = 1010
? = 1011
? = 1100
? = 1101
? = 1110
? = 1111

мы использовали все симвыол из словаря
но проблема в том что у нас еще остались четрыех
бытные массивы котоыре мы уже закоодивать не можем
тоест этой кодировкой можно пользовться но 
только для частных случаев массива битов
тоесть есл у нас массив вида

1000 0110 

то мыможем его закодирвать в

8 6 


а если у нам массив вида


1000 0110  1111

то как его кодировать

 8 6 ?


опять же 
мы можем составить словарь вот так


0 = 0
1 = 111
2 = 101011
3 = 010
4 = 101010101001
5 = 1001010
6 = 01010101001001010
7 = 1010
8 = 1
9 = 11

нас никто не ограничивтает что якобы мы
должны кадждый символ сопоставлят с массивом
битов одинаковой длоинны. нет. 
но пользовться на пракктие такой ситстемой
прккодировки во первых неудобно. во вторых
она позволяет ей пользватся только для 
массива битов котоыре имеют очень частный вид

например массив

 1010 1 11

его можно закодрвать как

7 8 9 

а можно как 

7 8 8 8

тоесть у нас еще и однозначнсти нет!

поэтому такое правило кодирования нам не подходит.



тогда придумали вот такое правило кодирования.

сказали вот что возьмем вот такую формулу

(0/1)*2^n +...+(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0


тоесть это сумма из ДВОЕК в такйото степени
и при них стоит коэфициент либо 0 либо 1.
вначале мы опреляемся какой n взять путь это 
будет n=5 тогда

(0/1)*2^5 +
+(0/1)*2^4 +(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0

на втором шаге мы выбираем значение в каждой 
скобке там где 0 или 1  напимер 


(1)*2^5 +
+(0)*2^4 +(1)*2^3 + 
+ (1)*2^2 + (0)*2^1 + (0)*2^0

теперь считаем что получилось

44

потом берут коэфициенты вскобках и рисуют их
рядышком

101100

и говорят что согласно этому правилу они мапят
символы 44 на массив битов 101100

так как у нас в скобках стоят только 0 и 1
то при таком подходе у нас массив из этих коэфииц
ентов это всегда будет хрень вида
 1010101010101010101010101

и так как арифмт формула использует символы
01234567890
то результатом вседа будет набор символов вида
129371298371928371928

тоесть ровно точно из словаря (01234567890)
который нам нужен

при таком правилу устанолвения соответвия есть
одна проблема. у нас одному и тому же дестичному
числу сооветсвует не один а миллион битовый
массивов. тоесть это 

101100
0 101100
00 101100
и вообще любой массив вида

(0..0)101100

потому что если мы подставим эти коэфиценты в фор
мулу мы всегда получим 44  !

тоесть 
биты ----> 44
преобразуются однзначно 

а
44 ------> биты
непреобразуется однозначно

тоесть если мы видим на бумаге напиасно

 DEC 44

то мы не можем восстановить точно оригинальный
массив битов. 
а это хуйня полная.
единсвтенно как мы это можем сделать если рядом
будет написано какая полная длинна была у оригиналь
ного массива битов . например 

 DEC 44 , 12бит

тогда мы можем сказать что это запист кодирует
оригинаьный массив

 0000 0010 1100

при такой оговоре , наше дес правило и наша DEC 
запись позволет однозначно восстановить информацию
об оригинальном массиве битов


при таком правиле массив битов мапится на
коэифицианты разложения дестичного числа 
по базису степеней  двойки.


возникает вопрос если я беру десятичное 
число  N например 44 то  могу ли я быть уверен
что множество коэфиицентов разложения единственное
или нет. тоесть что наше 44
раскладывается только в 

(0..0)101100

и что нет других вариатов типа

(0..0)111110

итп 

а то у нас получится хуйня. хотя она уже итак
получилась. но тем не мнее что бы у нас не 
получилось так что мы взяли   битовый массив
 
  101100

подставили в формулу , получили 44

записали на бумаге 44

а потом оказалось что есь другой массив

 111010

который при подставновке в формулу дает тот
же самый 44 и это будет п..ц
но тут я думаю математика доказыает что разложение
единственное 

101100

при условии наличия вот еще такого прикола

(0..0)101100

который нам дает нединственность но которая
уже через пень колоду  устранимая.



Далее походу вот как они имеют дело с HEX
они говорят пусть у нас есть десятичное число
тогда его можно разложить с одной стороны 
по степеням двойки. с другой стороны по степянем
десятки(собственно это и есть десятичнрая форма
числа)  с третьей стороны по степеням числа 16
причем в чем прикол. коэфиицент который будет
стоять в каждом члене он будет в диапазоне
интерсном лежать . тоесть 
если мы раскадыдваем число по стееням 10-ки 
то коэфицинет всегда будет в диапазоне

  0<= K <= 9

еси мы раскываем число по степеняем двойки
то 

  0<= K <= 1

по степеням числа 16 

  0<= K <= 15


итого 

44 = (4)*10^1 + (4)*10^0


44 = (1)*2^5 + (0)*2^4 +(1)*2^3 + (1)*2^2 +
      + (0)*2^1 + (0)*2^0


44 = (2)*16^1 + (8)*16^0


одно и тоже дес число мы разложили по 
степеням 10-ки, 2-ки, 16-ки.
как видно кофэицианты при каждом члене
меньше этого числа по степеням которго
мы разлагаем.

так вот они говорят что раз число одно тоесть
сущность во всех трех случая одна и та же
то давайте мы просто возьмем и запишем каждый из
примеров в виде массив кофицинтов

10: 44
2 : 101100
16: 28

ну а дальше они говррят что раз коэфииценты разло
жения единственные то можно использовать эти
все три нотации как заменяющие одна другую
и получается что 

 hex 28  кодирует bin 10100

толко у меня тут маленькая но мерзкая поправочка

это не совсем так. коэфиценты у нас не однозначно
опредяеляются и на самом деле все выглядит вот
так

вот как на самомо деле выглядит разложение
числа 44 

10: (0..0) 44
2 : (0..0) 101100
16: (0..0) 28


если мы рассматриваем эти нули вс кобках как
коэфиценты которые мы подставляем в арифм 
формулы что наверху то они нам погоды не делают
потмоу что в итоге в любых случаях получим одно
и тоже число 44. но! если мы маппим эти нули 
на массив битов то тут уже извините! - если 
нам все равно какой набор коэфиицантов
либо такой

101100

либо такой

00000000000 101100

подтставлять в формулу арифм разложения. потому
что мы получим все равно 44

то массив битов 
такой 101100
или такой 00000000000 101100
это совершенно разные массивы битов!


тоесть вот что получается.
вот у нас есть массив из n битов. и его легко 
можно превратиьт в DEC число подставив в формулу


DEC:  (0/1)*2^n +...+(0/1)*2^3 + 
+ (0/1)*2^2 + (0/1)*2^1 + (0/1)*2^0

это прямая формула. мы очень легко можем установить
(замаипить) dec число имея массив битов

биты ------> DEC 

это очень простая легкая быстрая и однозначная
операция. тут поблем нет.
но вот мы передали это DEC число васе
и ему нужно выполнить обратную операцию.
восстановить изначлный массив битов .

и тут как я сказал часть вида массива битов
вася восстановит однозначно. но другая часть
этого массива - ее невзможно определить однозначно.
тоесть дали мы васе 
  
  DEC = 44

вася однозначно узнает что часть массива битов
это точно 

  101100

но невозможно точно как выглядит осталная часть
этого этого массива. это чтото вот такого вида
(0..0)

тоесть любой массив 

(0..0)101100

он сворачивается до 44
поэтому передавая васе 44 мы должны обязательно 
указать сколько бит есть в изначальном массиве битов.
напрмиер 


  DEC = 44,  число битов=10

только тогда вася может восстановить оригинанльный
массив битов который мы ему пердакли вкодированном
виде

   0000 101100


так вот теперь еще хуже. 
мы передаем васе  бумжку где написано


 HEX 28


вася подсталяет эту щтуку в формулу

HEX : (0-15)*16^n +...+(0-15)*16^3 + 
+ (0-15)*16^2 + (0-15)*16^1 + (0-15)*16^0

и получаем

(2)*16^1 + (8)*16^0
= 32+8=44

окей вася выяснил что  HEX 28 кодирует 
деятичное число 44
но нам то нужно не оно а массив из битов.
далее вася дейсвтиует по предыдущему пункту
и получает что  массив битов который подходит это 

(0..0)101100

если мы не сообщили зарнее полное число битов
то вася в пролете. но если мы васе об этом
сказали вот так


  HEX = 28,  число битов=10

только тогда вася может восставноить зашиорвнный
исходный массив битов


   0000 101100



тоже самое для OCT кодивания  . мы можем предсвати
число 44 как разложение по стееням восьмерки
тогда получим

44 = (0-7)*8^2 + (0-7)*8^1 + (0-7)*8^0
     = (0)*8^2 + (5)*8^1 + (4)*8^0

тогда получаем
8: (0..0) 54  


итого все разложения
10: (0..0) 44
2 : (0..0) 101100
16: (0..0) 28
8 : (0..0) 54  



ТАКИМ ОБРАЗОМ:
если  мы берем массив битов. потом этот массив
подсставляем в качестве коэфициентов разложения 
десятичного числа по степенями двойки и получаем
десятичное число то в эту сторону система 
работатет однозначно(BIN->DEC). любой массив битов
приведетпо формуле нас к одному и только одному 
десятичному числу. обратное же преобразование 
(DEC-BIN) неоднозначное если мы не укажем как 
доп условие сколько бит было в оригинальном массиве
битов. 

ну тогда в приницпе получается что мы можем 
через DEC кодировать массив битов любой длины,
главное при этом рядом с DEС указать какой длины
был оригинальный массив битов. это позволит нам
однозначно восстановит BIN из DEC

тогда в этом свете записи в man ASCII имеют 
смысл. тоесть 

вот у нас там написано

   Dec   Char
   ───────────────────────
   101     A


также там написано   It is a 7-bit code.

итак мы имеем

   DEC 101, 7-bit code


тогда да. мы можем имея эту инфо восстанвоить
исходный изначальный бинарный массив битов

(0..0) 110   0101

и теперь выбираем чтобы массив был 7 бит длиной
вот этот оригиналный битовый массив

  110  0101



Итак через DEC форму можно теперь коротко кодировать
битовый массив любой длины. главное при этом 
рядом с DEC формой указывать полную длину исходно
ого массива битов.  это поволит однозначно восста
новить исходный битовый массив.











теперь. про HEX.
вот мы имеем битовый массив. мы подставляем
его в формулу. и получаем DEC число.
зная его мы можем разложить это DEC число
по степням 16-ти и получить HEX представление
этого DEC числа. 


тоесть мы имеем масив битов 110  0101
мы подстлвяем их как коэфицианты в формулу

(1)*64 + (1)*32+ (0)*16 + (1)*8 + (0)*4 + (1)*2
= 101

десятичное число мы нашли. теперь мы можем для
него найти разложение по степеняем числа 16
это будет

HEX: (?)*256 + (?)*16 + (?)*1
    = (0)*256 + (6)*16 + (5)*1

HEX: (0..0)61

тоесть строго говоря   у нас много разложений
можно взять любое. нармиер 

 HEX: 00065

таким макаром мы установили цепочку


BIN 110  0101 ---> DEC 101 ---->  HEX 00065


теперь мы можем предать васе HEX нотацию
но нужно обязательно добавить чему равна полная
длина битоового оригинально массива


    HEX 00065,  длина массива 7



вася возьмем hex пдставить в формулу и найдет
десятичное число, это однозначная операция

  6*16+5*1 = 101

теперь ему нужно найти какой битовый массив
соовествует  этому числу.

вася опредить что это вот такой класс
массивов

(0..0) 110   0101

и используя инфо что длина массива 7 бит
он в итоге вычленит исходный массив

   110   0101



таким образом HEX тоже можно использовать чтобы
кодировать любой длины битовые массивы, но 
нужно обязательно к HEX нотации приклывать инфо
об полной длинне исходного битового массива. 
иначе жопа.


тоже самое про OCT



по какойто счастливой случайности связь HEX нотации
с BIN по арифмеитическому правилу разложения по 
стееням дает точно такой же маппинг 
как и связь между этими же субьектами по моему
правилу простого словаря


0 = 0000                        
1 = 0001                       
2 = 0010
3 = 0011
4 = 0100
5 = 0101
6 = 0110
7 = 0111 
8 = 1000
9 = 1001
A = 1010
B = 1011
C = 1100
D = 1101
E = 1110
F = 1111


единсвтннное что нужно в конце подкорректировать 
длину массива ноли битами в одну или в другую сторо
ну опирась на то условие какой длины должен быть
конечный массив битов. 
напрмиер  дано


HEX 41,  массив битов 7 бит длиной

берем мой словарь
 4=0100  1=0001

тоесть 41 = 0100 0001

получаем

  0100 0001

теперь нужно откоретировать его длину до 7 бит
обрезав в голове нулевые биты или добавив в 
голове нулевые биты
получаем

    100 0001




чем приколна на практике еще HEX нотация,
тем что она позволяет супер быстро и легко
пррварить массив битов очень большой длины 
в HEX вид при минимальных вычислительных затратарх. 
мы берем   любой массив битов.
делим его на куски по 4 бита начиная от младего
бита к самому старшему. если в голове остается хвост
то мы его дополняем нулями до полных 4 бит.
тоесть дано

  01010101101010

разбиваем

  01 0101 0110 1010

доплняем его до полных 4 бит

  0001 0101 0110 1010

теперь либо по словарю заменяем каждые 4 бита
до HEX символа. либо это можно сделать налету
путем простых выичлсений.
берем 4битную хрень


  1010 

и высиляем для нее dec число. если оно лежит в
пределах 0-9 то это и есть HEX символ. а 
если оно 10-15 то надо помнить в голове небольшой
словарь 

 10=A
 11=B
 12=C
 13=D
 14=E
 15=F

посмотрим на нашем примере


  0001 0101 0110 1010


 0001 = 1 знаичит HEX 1
 0101 = 5 значит  HEX 5
 0110 = 6 значит  HEX 6
 1010 = 10 значит HEX A

значит в итоге

HEX:  156A,  полная длина ориг массиав 14 бит

очень важно указать какой длины был ориги
нальный битовый массив


для сравнения
вычислить HEX на оснвое BIN через разложение 
по кожфициентам стеепеней гораздо более ресурсое
мко!


HEX метод позволяет нам сократить оригиналный 
битовый поток в 4 раза в плане того сколько 
символов надо потраить на бумаге для его записи
ну вот реально оригинальный биотовый поток

  01010101101010

имеет 14 символов длиной на бумаге

а HEX нотация

  156A

имеет всего четыре. (14 дополнили до 16 и поделили
на четыре)


OCT нотация тоже самое . позволяет нам быстро 
и просто прервтить поток битов в более короткий
вид сократив его в три раза.

берем оригинальынй поток

01010101101010

делим на групы по три бита

  01 010 101 101 010

дополняем нулями до полной группы из трех бит

  001 010 101 101 010

тут даже проще. берем каждую группу из трех
битов и вычиялем его dec число. оно и будет OCT
заменой тоесть

  001 = 1
  010 = 2
  101 = 5
  101 = 5
  010 =2

значит 

OCT: 12552 , длина оригинаьного потока 14 бит

обязательно надо добавить. мы просто и быстро
соакртили битовый массив (его запись ) в 3 раза!
при этом нам даже ненужно как в случае HEX запоминать
преобрвзания вида 10=A

круто!!

теперь мне понячно поему в linux permsions 
мы их укзываем в виде OCT типа 666 или 0666

наприме 

 r--r--r--

он хранится в виде битов тоесть

100100100

закодируем этот масив битов в OCT вид

100 100 100

100= 4

значит

OCT: 444 , полная длина оригинаьного  массива 9 бит 

прикольно....

я так скажу! если сравнвить HEX нотаци и OCT 
нотацию то окт круче еще тем что из нее 
гораздо проще в голове восставнить  битовый вид
чем это можно сделать через HEX 

тоесть 
берем пример символ из ASCII

Oct   Dec   Hex   Char
───────────────────────
101   65    41    A



вопрос из какой формы быстрее всего 
я могу узнать битовый вид? ответ -из OCT формы!

OCT: 101

101 = 1 0 1 

1 = 001
0 = 000
1 = 001

значит BIN

001 000 001

и тперь еще вспминаем что символ asccii это 7-бито
вый массив битов
значит оргиналый массив битов это 

  100 0001

просто быстро круто и легко!!!!!


тепррь  я понял фишки и согласен с таблицей
ASCII с ее dec,hex,oct нотациями!


НО! это оказалось еще не конец.
Еще важные моменты.

Бит равный 0 это не отсутствие бита! Бит 0
это такоеже полноценное значение бита как и бит1

вопрос - во сколько раз сокращает запись на бумаге
DEC нотация? ответ - ЭТО ЗАВИСИТ содержимого 
бит секвенс! тоесть вот у нас есть секвенс длиной
8 бит и ее контент
 0000 0000

ее DEC 0 
   тоесть занимает 1 символ!

а вот секвенс той же длины 8 бит но с другим контен
том 
  1111 1111

и ее DEC 255
   тоесть он занимает 3 символа!

поэтому отвт на вопрос во сколько раз DEC нотация
сокращает битовую секвенс зависит от контента этой
битовой последоательности. два секвенса одной и 
тойже битовой длины могут иметь соверщенно разный
по длине DEC секвенс. 


далее. выше указано три нотации битовой секвенс
это DEC HEX OCT 
причем DEC самая хуевая потому что ее вычисление
очень труоемкий процесс в обе стороны. тоесть
чтобы вычислить DEC нужно работать сразу со всей
битовой секвенс целиком. если она длинная то 
это пиздец. тоже самое про итоговую длину новой
нотации. вот мы берем хрень длиной 8 бит
 
 хххх хххх и в завсисомсти от ее кокнретнгого 
контента у нас DEC нотация будет от 0 по 255 !
это же бред!

а вот берем HEX и мы точно знаем что ее нотация 
будет всегда всего ДВА hex символа. всегда!
также хекс нотацию легко вычислять! для этого
ненужно работать сразу со всей секвенс. делим ее
на кусочки и работаем с этми кусочками. тоже 
самое про OCT.
но hex немного трудоновато высчитывать в голове
а oct очень легко но он на 30% длинее получается
чем хекс. а можно ли придумать такую нотацию 
чтобы она была корче чем oct но считалась легче
чем hex. ответ к сожалению нельзя. в добавок я 
замечу что OCT это словарь из 8-ми символов
а hex это словарь из 16-и символов. я счиатю что 
размер словаря для "удачных" (тоесть легко считае
мых нотаций таких что можно поток битов разбирвать
на кусочки) зависит от вот такого правила.
берем биты , выстваляем их все в 1 и  смотрим 
какое дек число мы получаем. прибавляем 1 это и 
есть размер удачного словаря. тоесть

  1   

число 1  словарь из двух символов (0 1 )
он нам не интересен

 11

число 3. словарь (0 1 2 3)
я назову этот метод нотации QUADRO 
при ней мы делим поток на группы из двух битов
для них высчииываем дек число. это и есть новый
символ квадро. он легкий. но слабо сокращает
исхдный поток. пример

  10101011011010101010

  10 10 10 11 01 10 10 10 10 10

тогда 

QUAD: 2 2 2 3 1 2 2 2 2 2

далее

 111

это число 8. словарь ( 0 1 2 3 4 5 6 7)
тоесть это как раз метод OCT

далее

1111 

это число 16  . словарь (0 1 2 3 4 5 6 7 8 9 
10 11 12 13 14 15 16) или (0 1 2 3 4 5 6 7 8 9
A B C D E F)
это метод HEX

как видим между OCT и HEX нет  промежутчного метода
кодировки! увы!

далее

11111

число 32. словарь (0 1 2 3 4 5 6 7 8 9 10 11 12
13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
29 30 31) или  (0 1 2 3 4 5 6 7 8 9 A B C D E F G
H I J K L M N O P Q R S T U )
этот метод будет давать в два раза короче нотацию
чем HEX но еще сложнее по вычислению.


ДАЛЕЕ. HEX нотация она мапится не на биты а на 
dec число. это важно понимать.

  HEX --> DEC --> биты

тоесть hex нотация мапиится на биты не нарпмую 
а через посредника. через одно колено. ненарпмую!
еще раз HEX нотация она мапится на обычное число!
это важно понимать!
тоесть
hex нотация это ничто иное как коэифиценты которые
мы должны подстваиим в арфим формулу разложения
числа по степеням числа 16 и эта форумла нам 
дает обычное десятичное число!(причем в нотации
для понтов коэфициенты 10 11 12 13 14 15 16 заменны
на буквы! что усложняет понимание).пример

AB

это на самом деле
10 11

подсталвяем в форулу и она дает

10*16+11*1=160+11=171

итак нотация 10 11 маппится на число 171 но никак
не биты!!!! это уже число 171 както там мапится на
биты! поэтому якобы 10 11 кодирует биты.но в прямом
смысле это нетак!

важно тут еще то что НЕТ никакой связи между 
ДЛИНОЙ HEX нотации и длиной  битовой последрвательно
сти конечных битов.
пример имеем HEX нотацию

HEX: 0000000001
у нее длина как видно  десять символов.
если мы эти коэф подставим в арифм формулу то
получим всего навсего дек число 1.
а это число мапится на целую группу массивов битов
BIN: (0..0)1
которая как видно минимално имет по длине длину 
один бит. а как макисимум бесконечное число бит
по длине! это приводит нас к важному выводу! очень
важному выводу - если я смотрю на hex нотацию
и вижу что она сколько символов длиной например 
как в нашем случае 10 то из этой длины соврещенно
СОВЕРЩЕННО нельзя скзаать какой длины у нас битовая
посделтельность которая ей закодирована!!!! этого
никак не льзя сказать!
есть распотрраненнное заблуждение что если нарпиер
я вижу что у меня HEX это один символ

HEX: A

то это якобы означает что она 100% кодирует 4битовую
последовательно! это полное вранье! приавльный 
ответ - она кодирует целую кучу разннообразных
по длине битовых секвенсов! максималная длина 
такой цепочи равна бесконечномть!!! бесконечноть!!!
а минимальная длина цепочки зависит от .... щас
я разберу от чего она зависит!!
возьмм для начал hex из одного символа
для начала пусть это 0

HEX: 0

он мапится в дек число 0  и это число кодирует
вот такой класс биотовых секвенсов

 (0..0)0

тоесть мкаксиалаяная длина это +inf а минимальный
по длине секвенс это секвенс длиной один бит!

тоесть

 HEX: 0   
   ( кодирует класс битовых секвенс  1 .. +inf)

тоест если у нас HEX нотация это всего навсего один
символ и рваен 0 то я могу точно сказать что он
кодирует минимально один бит. это я точно знаю.
а вот какая на самом деле длина битовой секвенс
неизвестно. может и +inf но точне неменьше чем
один бит.

тоест мы смотрим на HEX:0  и понимаем что битовый
севенс который за ним стоит он точно как минмиум
1 бит длиной! как максимум +inf  , а скоько на
саомм дееле НЕИЗВЕСТНО! это должен был указать в
справке к этой нотации автор этой нотации!
тоесть наприер пусть я этот автор я беру секвенс
 
 00 000

кодирую его в HEX:0 и пишу на бумажке васе

  HEX:0    , длина исходной севенс 5 бит


как видим 5бит полностью попдает в наш интервал
(минмиум 1 бит .... макисиум +inf)


возьмем тепреь нотацию

 HEX: 1

она приводит к числу 1. и классу севенсей 
(0..0)1
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 1 бит .... макисиум +inf)

далее

 HEX: 2

она приводит к числу 2. и классу севенсей 
(0..0)10
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 2 бит .... макисиум +inf)

далее

 HEX: 3

она приводит к числу 3. и классу севенсей 
(0..0)11
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 2 бит .... макисиум +inf)


далее

 HEX: 4

она приводит к числу 4. и классу севенсей 
(0..0)100
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 5

она приводит к числу 5. и классу севенсей 
(0..0)101
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 6

она приводит к числу 6. и классу севенсей 
(0..0)110
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 7

она приводит к числу 7. и классу севенсей 
(0..0)111
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 3 бит .... макисиум +inf)



далее

 HEX: 8

она приводит к числу 8. и классу севенсей 
(0..0)1000
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)




далее

 HEX: 9

она приводит к числу 9. и классу севенсей 
(0..0)1001
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)



далее

 HEX: 10  или   HEX: A

она приводит к числу 10. и классу севенсей 
(0..0)1010
тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)


далее соверенно по аналогии для
всех 

HEX: B
HEX: C
HEX: D
HEX: E
HEX: F


она приводит к числу 11-15. и классу севенсей 
(0..0)1011
(0..0)1100
(0..0)1101
(0..0)1110
(0..0)1111


тоесть мы можем сказать что инервал кодиирумых 
секвенсов это 
(минмиум 4 бит .... макисиум +inf)


итого мы получаем таблицу:
если у нас хекс секвенс состоит из одного
символа и это символ

HEX:0
HEX:1

и мы смотрим на эту нотацию и хотим понять какой
длины битовая секвенс которая кроется за этой нота
цией. сколько бит кроется за этой нотацией? 
ответ - точной длины нет. потому что под эту 
нотацию подходят цепочки разной длины. они все
кодируются этой нотацией. сюда подходят как длинные
цеопчки так и короткие. самая длинная цепочка
которая кодируется этой нотацией имеет длину +inf
но с самой короткой больше конкретиики. ее длина
1 бит. итак за данным хексом кроется битовая 
послеовательность как миниум 1 бит длиной. 

если мы видим

HEX:2
HEX:3


то за данным хексом кроется битовая 
послеовательность как миниум 2 бит длиной. 


если мы видим

HEX:4
HEX:5
HEX:6
HEX:7


то за данным хексом кроется битовая 
послеовательность как миниум 3 бит длиной. 


если мы видим

HEX:8
HEX:9
HEX:A
HEX:B
HEX:C
HEX:D
HEX:E
HEX:F


то за данным хексом кроется битовая 
послеовательность как миниум 4 бит длиной. 


я собираю это в более компактную таблицу
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~  HEX: 0/1 ( бит секвенс >= 1 бит)             ~
~  HEX: 2/3 ( бит секвенс >= 2 бит)             ~
~  HEX: 4/5/6/7 ( бит секвенс >= 3 бит)         ~
~  HEX: 8/9/A/B/C/D/E/F ( бит секвенс >= 4 бит) ~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

теперь.  а что если  унас хекс секвенс два 
символа длиной.

HEX: NM

что можно сказать про длину бит секвенс за ним?

во первых нужно особым образом рассотеь частный 
случай когда N=0

HEX: 0M

в этом случае этот ноль можно отбросить. потому
что 

HEX: 00000000000000000M
и 
HEX: M

при подставлновке в формулу в качестве коэифициентов
дает одно итоже дек число
поэтому ноль можно отбросить, тоесть этот ноль
он никакого влияния на дек число в формуле влияния
неимеет.  в этом случае мы возврщаемся  к случаю
кода у нас один hex символ. (смотри таблцу выше)
в случае кодга у нас один символ так уже 0 имеет
занчение.

двигаем далее если N это неноль , то 
можно точно сказать что правый символ M в незавимосмти чему он кокнертнр равен кодирует
4 бита. а левый N кодирует то число битов которое
яуказано в таблице выше тоесть завссит от его
кокнркетного значения.
тоесть в общем случае двухбуквеннный секвес кодирует
минимум 5 битов. чтобы более точно скзать нужно
смореть чмему равен символ N
анрмиер 

HEX: 1A

так как 1 кодирует 1+ бит то вся констрауция 
кодиурет миумум 5+ бит

HEX: 90

так как 9 кдирует 4+бит то вся консуткрция
кодирует 8+ бит

Теперь общее правило. если у нас есть  HEX 
нотация 

HEX: 00000012213ABCD13234234


то первым делом мы обрасыаем слева все нули.
они роли не играют

HEX: 12213ABCD13234234


далее мы делим секвенс на две части. 
отрезаем левый символ

HEX: 1 | 2213ABCD13234234

теперь считаем число символов справа. каждый из
них кодирует 4 бита. в данном случае 16*4=64бита

потом берем число слева и ссмотрим таблицу выше
(та котороая прослучай кодга один символ)
в данном случае это 1+ бит

значит в итоге этот HEX он кодирует битовый секвенс
длиной как минимум 65бит

вот как расшифровать сколько бит кроется за HEX 
нотацией.

расмотрим на примре ascii таблицы.
мы знаем что в ней 7битовые секвенсы кроются
за hex  нотациями в диапазоне 00-7F

проверим 7F

HEX: 7F

7F = 7 | F

справа один символ. значит он дает 1*4=4 бита
слева у нас 7 который согласно таблицы выше 3+ бит
значит в итоге эта нотация она под собой кодирует
битовый секвенс длиной как минмум 7бит
ну и собсвтенно 7бит укалдвается внутрь "как минмиум
7бит".

а теперь посмотрим на нотацию 80 проверим что она
неможет в себе кодировать секвенс длиной 7бит

HEX: 80

80 = 8 | 0 
справа один символ что дает 1*4=4бит
слева 8 который соганос таблицы кодрует минимум 4бит
значит суммарно эта нотация кодирует миниум 8бит.
как видим 7бит сюда не укладывается.
проверим вручную
HEX 80 это значит 8*16^1+0*16^0=8*16+0=128 
тоесть hex 80 он мапит обычное число 128
разложим это число по степеням двойки

1*(0) +  2*(0) + 4*(0) + 8*(0) + 16*(0) + 32*(0) +
+ 64*(0) + 128*(1)

получаем ряд коэфициентов
1000 0000
тоесть 128 мапиится вот в такой класс битовых
секвенсов

(0..0)1000 0000

как видим минималный по длине секвенс котоырй 
кроется за 128 это  

1000 0000

а его длина 8 бит. так что за HEX 80  стоят битовые
секвенсы котоыре по длине как миниум 8 бит. и 
7битовый секвенс какой бы он ни был не входит
в этот диапазон!










ДАЛЕЕ. момент. Big-Ending. Low-Ending.

рассмотрим массив данных. что такое массив
у него есть ячейки с элементами и есть порядковый
номер. тоесть важен нетолько контент но взаимный
порядок элементов друго от друга. 
например массив месяцев года.

(0)     (1)     ... (11)
Январь  Февраль     Декабрь

тоесть за январем приходит февраль но никак не 
декабрь.

теперь вопрос - нам надо сохранить этот массив
в хранилище. это можно сделать двумя способами.
можно начинать пихать в хранилище месяцы начиная от того каоторый имеет самый малый индекс и посленим
передать месяц с самым большим индексом
шаг0
Январь
шаг1
Февраль
...
шаг11
-Декабрь


а можно наоброт. первым переадвть в хранилище
месяц с самым большим индексом
шаг0
Декабрь
шаг1
Ноябрь
...
шаг11
Январь
Декабрь-Январь


тоесть вопос в том какая наша f(t) при сожхранении
этих элементов. какой элемент мы сохраним первым
а какой последним.
так вот если мы первым по времени в сторадж
пихаем элемент с наименьшим индексом то этот 
споосб назыается Low-Endian метод
второй способ назыается Big-Endian метод

я бы по другому это привел пример. вот у нас
есть холдлиник. и у меня есть туша свиньи. я ее
порезал на куски. если первым я пихаю туда 
хвост а последним голову то это Low-Endian
А если я первым пихаю голову а последним хвост
то это Big_Endian
вытаскиваник ксатти будет в том же порядке.
если первым был засунут хвост то хвост будет
вытащен первым. (в отличии от реально холодилиника
где порядок вытаскивания получается будет обратным).

так вот теперь я хочу понять когда мы на бумаге
пишем слово по буквам то это какой метод лоу
ендиан или биг ендиан. 
рассмотрим бумагу. и то как мы на ней пишем
слово. 

     Вася

бумага у нас разбита на ячейки. каждая ячейка 
имеет свой оффсет. офсеты нумеруются слева нанаправо.

(1)(2)(3)(4)(5)(6)....

офсеты читаются в порядке их нумерования
и заполняются в порядке их нумерования
тоесть тут выполняется принцип та буква которую
я запишу по вермени первой потом когда  буду
читать бумажку то она же будет прочитана первой.
это хорошо. это важно потому что если бы при про
чтении у нас бы менялся порядок то бумага бы
нам не подходила. но у нас с этим все окей.

теперт посмотрим на массив букв в слове

     'В' 'а' 'с' 'я' 

хочется понять какая буква имеет наивысщий
индекс а какая самый малый индекс
труно понять какая буква имеет наивысий индекс
потому что на основе чего этот индекс ей назначать?
если его назначать на основе того какая буква 
первее вылетет из рта то это не показатель потому
что та буква которая произносится первой это ана
лог того какой элемент более первее будет записан
или прочитан в\их стораджа. а это как раз таки
зависит от типа сторадж. если сторадж лоу ендиан
то первым будет записан\прочитан элмент с 
наиеньшим идексом. а если сторадж биг ендиан
то первым будет записан\прочитан элмент с 
навысшим идексом. поэтому незная тип стораджа
и услышав перый элемент мы как раз таки неможем
скаать это элмент с наименьшим или наивысшим
индексом! прикол!
поэтому смотрим на само мнжество букв

     'В' 'а' 'с' 'я' 

и пытаемся понять . какая буква имеет наисвысщий 
индекс. если у меня есть массив то что значит
если элемент имеет наимньший индекс или элемент
имеет индекс наибольший индекс , можно ли сказать
что элемент с наименьши индексом имеет мнее
важно значение чем элемент который имеет более
высокий индекс. врят ли. в массиве по идее
все элементы равны. нам важен только поряок
менжду ними. как месяцы в году. все они одинаковое
имеют друг от друга значение. засовыавая их в 
массив мы лишь хотим сохранить этот порядок. 
множество - это куча элементов где у них нет 
никаого взиамного порядка. как яблоки мандарины
и груши в корзине. нам лишь важно наличие элеметов
но неважно как они друг от друга лежат в зависимости.
массив хранит в себе нетлько элементы но и их 
взаимный порядок. тоесть если мы возьмем листок 
бумаги или книгу и вычленим из нее все буквы
и ссыпем их в мешок это будет множство. а если 
мы эти буквы посещаем на листик то это уже массив.
получается очень интересно.
вот уменя есть сторадж. у него есть ячейки
и эти ячейки имеют адреса (1 2 3 4 5 )
по сути стордж это массив. внутри этого стораджа
массива у нас лежат данные. я читаю оттуда данные
в оперативную память которая по своей сути тоже
сторадж тоже массив тоже имеет адреса (1 2 3 4 5)
так вот я читаю со стораджа данные по элементно.
и получаю скажем числа 
 12  3  45  46 99  17 1

поскольку я незнаю какой это тип стораджа то 
я незнаю в таком ли индексном порядке эти элменты
сидели в исходном массиве или обратном. и опредиьт
это неовзможно если несообщат какой это тип
стораджа. 
если у нас исходный массив это 

январь - февраль - март -... -декабрь
тоесли я его запишу вот так
декабрь-...-март - февраль - январь
то взаимное расположение элементов друг отогосите
ьно друга сохраняется. потери информации по сути
нет. распожеие друг относительно друга сохранился.
тоесть декабрь как был относиельно января на расто
янии 12 элемнтов так оно  вобоих случаях и сохра
няется. 

теперь я пытаюсь поняь вот берем слово. оно
состоит из букв. это по сути массив. но как понять
какая буква имеет в нем наоименьший индекс.
на основе какого критерия это можно опрееделить?

я бы сказал что заглавная буква имеет наименьший
индекс

  В[0] а[1] с[2] я[3] 
 
тогда написание этого слова на бумаге
 Вася

нам дает то что бумага является low-ending храни
лищем данных. потому что первой на бумагу ложится
буква В с наимншим индексом а посеним на бумагу
ложится я который имеет наибольший индекс
при чтении также первым к нам  бумага возвращает
символ у  которого в исходном массиве наомеиньший
индекс. 

а что на счет чисел?

  1234

нуууу. написание числа у нас по сути это коэфици
енты разложения числа по степенями десятки

(1)*1,000 + (2)*100 + (3)*10 + (4)*1

нуу... наверное по идее исходя из этого фактора
у нас коэифиуент 1 имеет сущесвтенное влияние на
фактическую его вклад в число. а кэфицинт 4 имеет
минимальрый вклад. исходя из этой логики я бы
предпоожил что эти кофэцинты нужно совать 
в массив вот в таком порядке

4[0]  3[1]  3[2]  1[3]

хотя опят же по мне это вкусовщина. чем хуже
схема вот такая

1[0]  2[1]  3[2]  4[3]

  

если конечно исходить из того принципа что 
массив по своей сути это хранилище кусочков
чего целого чегото более большого а также 
если считать что эти кусочки имеют разное
значение для этого целого 
и если счиать что индекс отоббражает величину
этой ценности тоесть чем ниже индекс тем 
ниже вклад этой хрени в это целое то тогда
вот что будет получаться.
элемент 1 имеет макс вклад в число 1234 потому
что он по собой подразумевает число 1000
элемент 4 имеет мин вклад так как он поарзаме
вает под собой число 4. исходя из всего этого
то массив будет вот такой

4[0]  3[1]    2[2]   1[3]

учитвая что на бумаге мы записыаем этот массив
в виде 

1234

то получается бумага по своей сути это Big_Ending
хранилище данных.


теперь про слова.  если применять туже логику что 
буквы в слове имеют разный вклад. тоест если мы
возьемем слово например

    зеленый

то у него есть предлог есть корень есть суфикс
и есть оконачение. в целом у слова самая важная
хрен это корень. он лежит илив самом начале 
слова или чуть правее. тоест я бы сказал что левая
часть слова более важная чем правая. она хранит
главную смысловую ифномрацию. тут конечно предлог
несколько ломает эту картину. тоесть бя скзаал что
вот как распредлется важность букв в вслове

 пред кор    суфф  окон
|    |     |      |    |
 мало много средне мало


в целом получается предлог+корень имеет больше
значения для преедачи смысла слова чем суфф+оконч

из чего я делаю типа вывод при той логике что я 
обозначил выше что в вслове 

   Вася

его нужно всталять в массив вот так

 я[0]  а[1] с[2]  В[3]

учитвыая что на бумаге оно выглядит как

    Вася

то  получается опять же что бумага это Big-Endian
хранилище!


то есть получается если мы на бумагу заносим какую
то сущность (слоово или число) то более первым 
по времени (или в более младший офсет бумаги) 
кладется бОлее значимый элемент сущности. 
у числа первым кладется его самый мощный коэфицент
который вносит галный вкладв в величину числа
а у числа кладутся его буквы которые входят в состав
корня который вносит самй главный вкклад в передачу
смысла слова (хотя первой на бумагку кладетя притавка
ну да ладно. возможно приставка предает еще более
важный смысла слова чем корень?)

прикол что в устной речи мы говрими также как на
бумаге но в чем прикол - если мы будем рассмарвать
не буквы как элементы а слова как эелменты то 
мы помещаем как правило (по крайней мере амеркианцы)
самое важное слово в конце предожения!

тоесть получается полный прикол! на бумаге или 
в речи что касается фиксации слов или чисел 
через буквы мы юзаем метод Big-Ending а если 
при этом мы рассатрвиемт слова как отдеьные эелменты
то тогда у нас бумгаа и речь прервщаается в Low-Ending хранилище!!! жесть!


теперь нужно еще коечто важно дбавить на счет
HEX нотфиикации. на бумаге мы ее пишем воттак

    ABCD

тут символ 'A' это коэфиицент который в арифм
выражении имеет макс вклад в занчение коенчного
дек числа а  'D' это коэф который в арифм  выражеии
дает мин вклад на занчение дек числа. тоесть
массив имеет вот такой вид

 D[0] C[1] B[2] A[3]


соовтсвтенно опять же бумаг как видно вялется
хранилищем типа Big-Endian

тоест если мы видим на бумаге HEX нотфикацию
то знаяя что бумага это Big_Endan хранилище
для слова, дек чисел и хекс нотификаций 
мы можем четко понимать какой был типа исходный
массив данных. тоесть вот еще раз на счет
hex нотфиикации. 
вот у нас есть разложение числа в коэфицианты

 (12)*1 + (6)*16 + (3)*256

то возникает вопрос как эти коэфиценты заисать
на бумаге. то ли   B63  толи  36B
чтобы человек читая бумагу точно понимал в какой
член нужно вствлть каждый кожфиицент. мы уже
вроде как установили что бумага это Big-Endian
хранилище символов. исходя из этого нам
на бумаге это нужно писать вот так

  36B

потому что коэфицинт 3 делает самый важный вклад
в число а символ B самый мелкий вклад.
если мы знаем начальны оффсет на бумаге и начнем
оттуда чиатть символы то мы четко знаем что первым
записан символ с самым большим вкладом в смысла
слова или числа или HEX числа. а самым последним
мы считаем самый мало значимы символ. поэтому
например мы точно знаем какие из прочитанный
коэфициантов точно куда вставить в hex формулу

значит теперь отметим что экран монитора в режиме
редатора текста для СИ это точный аналог бумаги.
далее если мы пишем на экране HEX нотацию 

   0xAB22CD

то так как экран это полный аналог листка бумаги
то эта нотация втоности совпдает с бумажной
а так как мы выяснили бумага это Big-Endian храни
лище симоволов, элементов массивов. то и на экране
у нас запись  0xAB22CD  указана  в режиме Big-Endian
далее мы помним что hex нотация по своей сути
это кодированная последовательность битов. как
я ранее писал по правильному если мы пишем hex
нотиикацию то также нужно укзывать и полный размер
исходной битовой посдеовтености которую оно кодирует
и тут на компе деействиует незримое правило у компи
лятора (как  я понимаю) он считает что каждый
hex символ кодирует в себе в точности 4 бита. 
далее комплиятор смотрит какой тип данных указан
слева. и если полный набор битов несовпдает с типом
данных слева то он допоняет незримо эту хекс
запись хекс символами 0. тоесть например 

 int i1 = 0xA;

справа по понятиям компилятора стоит 4 бита.
а слева стоит хрень длиной 4 байта. поэтмоу он 
налету заменит строку вот на такую

 int i1 = 0x0000000A;


также важно пнять что память это хранилище битов
кратное 8 бит. поэтому чтобы у нас там не стояло
слева и справа по факту у нас в память полетит
минимум конструция из 8 бит. 
так вот рассмотрим такую констркуицю

  char c1  = 0xA1;


слева у нас стоит хрень длиной 1 байт.
справа по понятим компилятора тоже указана хрень
длиной 2*4 бит или 1 байт.

возникает вопрос какой это будет байт? 
A1 или 1A ? значит комплиятор знает что мы 
пишем на экране как на бумаге поэтому  A это 
старшая часть получабайт а 1 это младшая часть 
полубайта. тоесть это будет вот такой байт 
с точки зрения компилятора

  1100   0001   в записи Big-Endian стораджа
                который умеет хранить побитоово
                
  1000   0011   в записи Low-Endian стораджа
                который умеет хранить побитоово


память у нас работает не  с отдельными битами
а с отдельными байтами. как она хранит биты 
внутри байта неизвестно. но известно то что если
мы в регистр цпу засунем многобайтовый битовый поток
то он его засунет в память с точки зрения сохранения
отдельных БАЙТОВ в Low-End порядке. 

я вовзращаюсь к этой строке

  char c1  = 0xA1;

справа у нас 8 бит, байт
неизвестно как память повторюсь хранит биты на
уровне байта внутри себя. то ли вот так


 младший офсет в памяти
  |
  1100   0001
  |
  самый старший бит


толи вот так


 младший офсет в памяти
  |
  1000   0011
            |
            самый старший бит


но известно что память на уровне отдельных байтов
сохраняет их в порядке Low-Ending
значит скорей всего и на уровне отдельных битов 
он делает также то ест скорей всего вот так 
в итоге 



 младший офсет в памяти
  |
  |         старший офсет в памяти
  |         |
  1000   0011
  |         |
  |         самый старший бит байта
  |
 самый младший бит байта


если бы бумага была low-Ending сторадж
то  наши hex коэфиициенты выглядели бы на ней
вот так

  1A


теперь рассмотрим  вот такую строку в тексте
программы


  short int i2  = 0xA1B1;


слева указана сущность по длине равная 2 байта.
справа указано по мнеению компилятора тоже
сущность по длине 2 байта потмоу что (по мнеению
компиляотора) 4*4=16бит  = 2 байта

с точки зрения бумаги мы записали справа  хекс
кофиифенты в таком порядке что левыый самый
значимный а правый самый ничтожный. (так как бумага
это Big-Ending хранилище) тоесть эти коэфиенты
они вот так подставляются в арифм формулу

(1)*1 + (B)*16 + (1)*16^2 + (A)*16^3
= (1)*1 + (11)*16 + (1)*16^2 + (10)*16^3
что приводит нам к десятичному числу 41393
которое в свою очередь разбивается по степеням
числа 2 вот в такой ряд коэфициентов 


  1010 0001 1011 0001
  |                 |
  2^15              2^0

так как мы знаем что нужно сгенерирвать битовый
поток длиной  2 байта тоесть 16 бит то вот
мы его уже получили


  1010 0001 1011 0001
  |                 |
  старший           младший
  бит               бит


причем если мы делим наш массив битов на куски
по 8 бит тоест на байты то можно еще написать 
воттак

   старший    младший
   байт        байт   
  1010 0001 1011 0001
  |                 |
  самый             самый
  старший           младший
  бит               бит


если мы рассмотрим отдельно старший и младший
байт и попробуем для них найти экваиалентные
hex выражения то мы получим


    A1         B1

  старший    младший
  байт        байт   

  10100001  10110001


далее цпу запишет эти байты в таком порядке 
в память что вначале младший байт потом старший
байт. и как я полагаю что и биты по такому же правилу
поэтмоу в память все будет записано вот так


младший бит       младший бит
младшего байта    старшего байта
|                  |
10001101           10000101

--------------------------------->>>>>>>>
младший адрес                   старший адрес
в памяти                        в памяти




еще раз посмотрим на эти биты и то как 
они будут лежать в памяти



    адреса памяти
--------------------------------->>>>>>>>


младший бит       младший бит
младшего байта    старшего байта
|                  |
10001101           10000101


теперь я запишу  первый массив битов в формате
HEX причем я сохраню при его написании порядок
важности я сделаю Low-Endian
получаем

   1B

и тоже самое про второй массив битов

   1A

в иттоге получаем что биты в памяти лежат 
вот в таком порядке выраженное чрез HEX



          1B   1A

    адреса памяти
--------------------------------->>>>>>>>


тоесть еще раз.  вот у меня записано
первый хекс 
 
  1B

и мы указываем что самый неважный коэфиициент слева
а полная длина массива битов это 8 бит.
я подтслвяю эти коэфииценты в формулу
и нахожу дек число

1*1+(11)*16=176

раскладываю это число в разложение коэфиицентов
ряда из степеней двойки и выписываем их

10001101
|
самый младший бит


теперь 

  1A

учитывая что слева самый слаюый коэфициент
получаем дек число
1*1 + 10*16 = 161


раскладываем его по степеням двойки и выписываем
эти коэфициенты 

10000101
|
самый младший бит


итак мы имеем в памяти 



10001101                     10000101
|                            |
самый младший бит            самый младший бит


а теперь сравним с потоком битов которые
были закодированы на бумаге 


  short int i2  = 0xA1B1;


  1010 0001 1011 0001
  |                 |
  2^15              2^0
  |                 |
  самый             самый  
  старщий           младший
  бит               бит


еще раз посмотрим


10001101  10000101
10100001  10110001

по сути это одна и таже последоватлеьность
битов но она повернута с хвоста на голову.
так вот. получаетя вот как
на бумаге у нас было условно говоря записано

   (старший байт)(млащий байт)

а в памяти оно записано
   (младший байт)(старший байт)

если я будут читать этот поток битов из памяти
в обьеме 2 байта за раз то это неимеет никакого
значения. а вот если я буду читать этот массив
из памяти кусками по одному байту за раз то 
мы получим то что если мы читаем этот поток 
с бумаги (там где сторадж Big-Endian )то первый
байт который мы получим будет (старший байт)
а если мы читаем всего один байт с памяти которая
Low-Endian сторадж то мы получим младший байт!
так вот если мы готовим битовую последовательность
(или байтовую ) для того чтобы потом ее отправить
на терминал , то прикол в том что мы на терминал
байты посылаем из памяти по одной штуке за раз
(при ASCII кодировании) символов , поэтому
учитвая все вышесказанное нам нужно в HEX нотации
в тексте программы указывать их в обратном порядке
чем они должны быть нарисоываны на экране. тоесть
скажем если мы хотим на экране получить

   qrst

и если их коды это 
q=0x71 r=0x72 s=0x73 t=0x74
то в тексте программы нам нужно написать

   int i3 = 0x74737271

эта заморочка имеет место если у нас именно
указано многобайтовый тип данных.
если же мы в явном виде можем указать какой
байт в каком пордке записать в память то 
таких заморочке нет и тогда можно указать прямой
порядок симолов

 char c3[4] = { 0x71, 0x72, 0x73, 0x74  }

собствтенно ради обьяснения этого явления все
то что наверху расписано.


вот пример проги


#include <stdio.h>


int main() {

     int i3 = 0x00737271;
     char c3[5] = { 0x71, 0x72, 0x73, 0x00  };

     printf ("i3 = %s\n", &i3 );
     printf ("c3 = %s\n", &c3);

return 0;

}


вывод на экран

i3 = qrs
c3 = qrs




когда мы сидим в текстовом редакторе
для СИ и в тексте в явном виде указываем массив
его элемент и индексы тоесть

 char c[4] = { 0xa, 0xb, 0xc, 0xd };

здесь мы в явном виде соощаем компилятору какой
инекс имеет кажый элемент. тоесть мы явно
сообщаем что элемент 0xa имеет индекс [0]
а эдемент 0xd имет индекс [3]
тут все понятно. все в явном виде.


ВОБЩЕМ!
у меня там наверху много чего написано.
у меня нет сил щас вычищать эти авгиевы конюшни.
поэтому вместо этого 
я тут щас опишу что я понял к настоящему моменту.

во первых про HEX. хекс нотация 

  A12B4

это по своей сути указаны коэфииценты которые
нужно подсавтяь в арифм формулу которая нам 
даст десятичное число.
причем это вот такое по сути

  A12B4 = (A)(1)(2)(B)(4)

далее вспомниаем что буквы это всего навсего
замена обозначения чисел тоесть

  (A)(1)(2)(B)(4) = (10)(1)(2)(11)(4)

почему я поставил скобки потому что в каждой 
скобек коэфиицент при соотвствующем члене в формуле
потому что 

 (10)(1)(2)(11)(4) != (1)(0)(1)(2)(1)(1)(4)

поэтому скобки важны. 
итак берем эти кофэицианты

(10)(1)(2)(11)(4) и подстлавяем в формулу

 
 (10)*16^4 +(1)*16^3 +(2)*16^2 +(11)*16 +(4)*1
   = 660148

полуили десятичное число. таким образом еще раз
хекс нотификация это не нотикация которая за 
собой скрывает массив битов. это нотиификация которая
за скрывает ДЕСЯТИЧНОЕ ЧИСЛО! просто в более короткой
форме.

ксатти сама запись дестичного числа это тоже всего
навсего массив коэфиицнтов разложения числа по 
стееням числа 10. тоесть прикол в том что само 
число это просто кучка скажем так отдельных единичек
отдельных яблок в корзине тоесть число по своей
сути это огромный набор отдельных элементарных
сущностей которые лежат  в корзинке. если звездочка
это яблоко то число это вот такая по сути куча 
******************************************************************************************************************************************************************************.... ***

тоесть я хочу сказать что само число по своей сути
это не 660148. само число это вот такая огромная
куча звездочек. это вот как у нас есть монетка
и они лежат огромной кучей в сундуке. вот сундук
с огромной кучей монеток это то как выглядит число
по своей природе по своей сути. но с таким видом
числа хреново работать. поэтому ишут какуто форму
записания числа компактно и знаково. и придумали.
берут несколько кучек - степени числа 10. 
тоесть одна кучка в которой одна монетка
                    *
потом вторая кучка в ней уже 10 монеток
                **********
третья кучка в ней 100 монеток
             ************....********
а потом мы берем нашу исходную кучу монет и 
разделяем по этим эталонным кучкам. поэтому теперь
у нас не просто сундук где мы видим непонятную 
гору монет а у нас на полу вся гора разбита по 
эталонным кучкам. теперь у нас пояялется более
качественное ощущение сколко у нас денег.
и мы для числа этих кучек выдумываем символы - значки. мы придумываем вот такие значки
1234567890
но чтобы было еще более понятно то я их заменю
на другие
☀☁☂☃ ☄★☇☉ ☊☘

и мы говорим что если у нас вот сколько кучек
 * то мы это количество монет обозначаем как ☀

если у нас вот такое число кучек монет
   ** то это обозначаем как ☁

итд мы получаем
   ничего    = ☘
   *         = ☀
   **        = ☁
   ***       = ☂
   ****      = ☃
   *****     = ☄
   ******    = ★
   *******   = ☇
   ********  = ☉
   ********* = ☊

так вот мы берем нашу кучу из сундука и 
разбиываем по кучкам разного образца. кучки 
по 1,10,100,1000,10000 монет. потом мы берем
монеты из сундука и разбиаем эту сумму по этим
эталонным кучкам. и далее мы считаем сколько 
у нас кучек каждого образца. и это колчество кучек
мы набумаге ообозначем символами. и справа на бума
ге мы обзначаем число кучек самого малого обьема через символы 
а в самом левом мы обозначаем число кучек самого
большого обьема через символы. получем
вот бреем наше число в привычном для нас виде
660148 и вот аналог   ★★☘☀☃☇

тоесть я хотел показать что мы привыкли что запись
660148 это якобы само число. а это совсем не число
по своей приоде. это такая хитрая форма выражения
числа. но не само число. само число это просто
уродлинвый сундук с горой монет. и на взгляд 
он ничего не покаывазывает в качесвтвенном виде.
это как мы видим лужу на улице и по факту это
вода. но визуально сколкьо там воды непонятно.
нужно ее перелить в какието стандартные обьемы 
посуды. и тогда мы говорим вот здес столкьо то
воды которая вместилась вот в такието то стандарт
тизоыванные куски посуды. так вот хекс это разло
жение числа по степеням числа 16.
привычная нам запись 660148 это разложение числа
по стеепеням числа 10. тоесть мы видим в строчке
коэфиициценты этого разложения. а 1001011010101010
это разложение числа по стеменям числа 2. и в строке
мы видим кэфициенты этоо разложения.

a*16^2+b*16^1+c*1
d*10^2+e*10^2+f*10^0
e*2^7+f*2^6+g*2^5+h*2^4+i*2^3+j*2^2+k*2^2+l*2^0

это все одно и тоже число. выржаенное через 
разные стадратизованные кучки. потом мы ерем
коэфициенты и выпиываем их в ряд
abc
def
efghijkl

и говорим что верхний это хекс, средний это дек,
нижний это бин. тоесть эти разложения это коэфи
циенты из формул. котторые в итоге нам дают 
одно итоже число.
ну и получается что можно считать
что комп внутри себя хранит коэфииценты из бин
разложения. 

теперь кода это разьянено. то 
возьмем число в виде разложнеия по двойкам на
примере числа у которого макс степень это 2^7


(b7)*2^7  +(b6)*2^6  +(b5)*2^5  +(b4)*2^4  +(b3)*2^3
  +(b2)*2^2  +(b1)*2^1  +(b0)*2^0

также мы знаем что кофэиценты в разложнеии 
они меньше чем число по которому мы раскладываем
тоесть все коэфицнты bi это 0-1
ну и получается что данное число имеет вот такой
рядо коэфиицентов
(b7)(b6)(b5)(b4)(b3)(b2)(b1)(b0)
и тоесть по сути это как раз тот массив битов
в которых раскладыавется наше число

так вот возьмем эту сумму и сгруппируем
в две скобки


[   (b7)*2^7  +(b6)*2^6  +(b5)*2^5  +(b4)*2^4  ]  +  [ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]


мы ничего не поменяли. далее вынесем из первой
скобки 2^4

2^4*[ (b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0  ]  +  [ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]

перед второй скобкой стоит 1 он же 2^0

2^4*[ (b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0  ]  + 2^0*[ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]

при этом пока что мы ничего не поменяли 
в исхдной сумме по сути. тосесть число не изме
нилось

а теперь обратим внимние вот на что . 
вот берем первую скобку
(b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0
я уже сказал что каждый bi это либо 0 либо 1.
оценим в каких пределах коебблется эта скобка.
если все коэфициеныты  0 то она 0
а если они все 1 то она 8+4+2+1=15
тоже самое про вторую скобку
тогда я вот так это обозначу

   2^4*[ 0-15 ]  + 2^0*[ 0-15 ]

теперь 2^4=16 = 16^1 
и 2^0=1=16^0 тогда

   [ 0-15 ]*16^1  + [ 0-15 ]*16^0

учитывая что скобках числа лежат в диапазоне 0-15
мы перед своими глазами имеем по факту разложение
числа по стееням числа 16! то есть это хекс 
разложение числа! при этом мы в исходной сумме
ничего не меняли. тоесть это ровно тоже самое
число! если я обозначу то число котоое стоит
в левой скобке как скажем 'M' а число которое
стоит в правой скобке как 'N' то мы получим

   (M)*16^1  + (N)*16^0

тогда мы получаем HEX нотиифкацию
для исходного числа

  HEX: MN

причем что важно отметить что M и N это всего
навсего десятичные числа. это просто сраные деся
тичные числа. которе лежат в диапазоне как
я уже доказал 0-15 тоесть к примеру
M=12 N=4
тогда

  HEX: 12 4

просто что путает в хекс нотфикации то что в ней
(блядь) налету заменяют числа которые больше 9
на буквы A-F  хотя по факту по всей процедуре 
по которой мы получаем хекс коэфициенты - в ней
нет нахуй никих A-F а есть ВСЕГО НАВСЕГО ПРОСТЫЕ
СРАНЫЕ ОБЫЧНЫЕ ДЕСЯТИЧНЫЕ ЧИСЛА! а введение букв
только нахрен сразу все запутывает и затуманивает
на пустом месте. итак M,N это всего навсего десяти
чные числа! которые в свою очредь как коэфэиценты
мы подствляем в арифм выражение чтобы получить
обычное десятичное число! и никакой магии!!

так вот
посмотрим теперь наверх там где расписано чему
равны эти десятичные числа M и N

M=[ (b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0  ]
N=[ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]

посмотрим на первую скобку. что мы в ней видим.
мы видим что в правой скобке стоит разложение
десятичного числа по степеням двойки! тоесть
наше десятичное число M разложено по степеням
двойки! это не мы так придумали это так выходит
на основе тех действий что мы делали. ачто же
прикольгого в этом разложении? а прикольно то
что коэфииценты разложения этого числа M они таковы

      (b7)(b6)(b5)(b4)

что они совпадают со старшими коэфициентами разлож
ения ИСХОДНОГО числа тоже по степеням двойки

     (b7)(b6)(b5)(b4)(b3)(b2)(b1)(b0)

тоесть вдруг оказывается что:
    * если есть дестиячное число в пределах 0-255
      и у нас есть его разложение по степеням двойки
      то если мы возьмем его старшие четыре коэфи
      циента и подставим в формулу разложения 
      числа по степеням двойки с четырьмя слагае
      мыми и посчитаем эту формулу то получим
      десятичное число которое по своей природе
      является одним из коэфициентов разложения
      этого исходного числа по степеням числа 16!
      а если мы возьмем его младшие четыре коэфи
      циента и подставим в формулу разложения 
      числа по степеням двойки с четырьмя слагае
      мыми и посчитаем эту формулу то получим
      десятичное число которое по своей природе
      является вторым из коэфициентов разложения
      этого исходного числа по степеням числа 16!

тоесть вот пример. есть исходное число дестяиное
число в виде суммы разложенеим по двойкам

 (1)2^7  +(0)2^6  +(1)2^5  +(0)2^4
     +(1)2^3  +(0)2^2  +(1)2^1  +(0)2^0 

мы берем его старшие четрые кофициента
   (1)(0)(1)(0)
и посдатавляем их в разложение числа по степеням
двойки когда в сумме четрые члена
  (1)2^3  +(0)2^2  +(1)2^1  +(0)2^0 = 8+2=10

берем младшие четыре коэифиента
     +(1)(0)(1)(0)
подстлавяем их в формулу разложения по степням
двойки когда в сумме четыре члена
  (1)2^3  +(0)2^2  +(1)2^1  +(0)2^0 = 8+2=10

получил два числа 10 и 10 
тогда оказыается что эти числа это коэфииценты
разложения исходного числа по степеням числа 16
тоесть
 (10)*16^1 +(10)*16^0

проверим.
посчитем чему равно исходное число исходя из 
его разложения по степеням двойки
 (1)2^7  +(0)2^6  +(1)2^5  +(0)2^4
     +(1)2^3  +(0)2^2  +(1)2^1  +(0)2^0 = 170

посчтаем какое число мы получаем исходя из разлож
ения по степеням числа 16
 (10)*16^1 +(10)*16^0 = 170

то есть двевиствтельно это одно и тоже число.
тоесть все верно
тоесть получается что если у нас есть исходное
число в виде разложения по степеням двойки
я вот его напишу в форме коэфиицентов этого 
разложения
                1010 1010
то я могу супер легко и супер быстро
найти коэфиенты разложения этого же числа 
по степеням числа 16
я беру старшие 4 коэфициента подсталвяю их в формул
у разложения числа по стеенпеням двойки когда в сумме
всего четыре слагаемых
   1010 = 1*2^3 + 0*2^2 + 1*2^1  + 0*2^0 = 10
это я получил старший коэфициент разложения 
по числу 16.
беру младшие 4 клэфиеиыетнта. и нахожу десятичное
число по этой же формуле
   1010 = 1*2^3 + 0*2^2 + 1*2^1  + 0*2^0 = 10
получаю младший коэфициент разложения исходного
числа по стеепеням числа 16. тоесть
 (10)*16^1 +(10)*16^0
или другими словами я для исходного числа супер
быстро и легко нашел его HEX разожение
  
  HEX: (10)(10)

нам тлко осатется заменить 10 на букву A

 HEX: AA

тоесть еще раз- если у меня есть бинарное разло
жение числа, то я могу мгнвоенно найти по нему 
HEX вид этого числа.
вот у нас бинарный вид числа

  0101 0101

и я нашел его hex вид

 HEX: AA

это очень круто.
соотвтственно верно и обратное! если у меня есть
хекс разложение числа

 HEX: B9

то я могу мгнвоенно найти бинарное разложение
для этого числа.
на первом шаге мы заменяем буквы на десятичные
числа так как символы в хекс разложении они на 
саом деле это обычные десятичные числа а буквы 
введены что заебать мозги. тогда

 HEX: B9 = (11)(9)

теперь я беру каждое десят число и нахожу его
разложение по степеням двойки

 11 = (1)*2^3 +(0)*2^2 +(1)*2^1 +(1)*2^0 
  9 = (1)*2^3 +(0)*2^2 +(0)*2^1 +(1)*2^0 

а далее я говорю о том что полученыне бинарные
коэфииценты вточности совпдают с коэфиициентами
разложения исходного числа по степеням двойки.
у числа 11 эти клэфииценты совпдают со старшими
четырься а у числа 9 они совдают с младшими четерься
тогда
 1011 1001

вот эти кофииценты и есть разложение исходного
числа по степеням двойки. проверим.
найдем исходное дес число исходя из его хекс
записи

(11)*16 +(9)*1= 185

роверим какое дес число мы получаем исходя из
коэф бинарного разложения

1011 1001 = (1)*2^7 +(0)*2^6 +...+(1)*2^0=
              = 1+8+16+32+128= 185

получили тоже самое число 185!


таким образом можно на практкие легко получать
из битовой формы получать HEX форму. и их HEX
нотации получать битовую форму числа!!! охренеть!
еще раз посмтрим как я это получил

я взял число которое разложено по степеням двойки

(b7)*2^7  +(b6)*2^6  +(b5)*2^5  +(b4)*2^4  +(b3)*2^3
  +(b2)*2^2  +(b1)*2^1  +(b0)*2^0


потом сгурпировал элементы

 
2^4*[ (b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0  ]  + 2^0*[ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]

и получил что в первой скобке по оценке стоит
число в диапазоне 0-15, во второй скобке стоит
число 0-15. и получается учитыва что 2^4=16
то в целом мы получили ни что иное как разложение
исходного числа по степеням числа 16.
значит то что стоит в скобках это ничто иное как
коэфииценты разложения исходного числа по стееням
числа16. значит если мы вычислим то что стоит
в скобках то мы получим коэфициенты HEX нотации
исходного числа.  таким образом имея бинарную форму
числа мы на основ нее можем мгоновенно вычислить
коэфииценты hex разложения. в первой собке
старший коэфиицент а во второй младщий. и это прям
считается легко быстро и круто. мы выяснили прямую
связь между битами и хекс кофжфиицентами.

HEX: ( (b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0 )
     ( (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 )

тоесть имея биты. мы сразу получаем хексы.
мгнвоенно. по элементарной формуле

верно получетяс и обратное. если у меня есть хекс
разложение числа
 
 HEX: MN

то так оказалось что разложение кажого из этих 
M N чисел дает бинарные кофдиициенты коттоыре 
в точности совпдают с бинкррыми кофифиентами разло
жения исходного числа.
тость я беру число . оно 0-15
раскыаю его по по степеням двойки

  M 1010 

и ровно такиеже биты имеет исходное число при его
старших кофициентах 
  1010 хххх

беру число N . раслывдаю его по степеням двойки
N 1100

и ровно такиже биты имеет исходное число при своих
младших кофифицнетнатах

   хххх 1100

и получается в итоге разложение исходного чиссла
выглдяит как 

  1010 1100

тоесть у нас есть HEX

 HEX:  MN

мы раскладываем крошесные числа M=1101 и N=1100
а витоге получаем разложение исодного большого
числа на биты 1101 1100

и это круто!

я рассморел ситацию когда у нас исходное дес
число от 0 до 255. тоесть имеет разожеие по 
двойками в диапазоне 

  2^7.....2^0

но таким же макаром можено легкоп показать что 
это верно для любого сколь угодно большого дек
числа. например возмем число которое разлагается
в диапазоне

  2^15...2^0


(b15)*2^15 +...+ (b0)*2^0 =

=2^12*[(b15)*2^3 +(b14)*2^2 +(b13)*2^1 +(b12)*2^0 ]  
+2^8*[ (b11)*2^3 +(b10)*2^2 +(b9)*2^1  +(b8)*2^0 ]
+2^4*[ (b7)*2^3  +(b6)*2^2 +(b5)*2^1  +(b4)*2^0  ]  +2^0*[ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]

внутри каждй скобки стоит число в диапазоне 0-15
за скобками у нас стоят числа 1,16,16^2,16^3
в итоге наша сумма это
 16^3(0-15) +16^2(0-15) +16^1(0-15) +16^0(0-15)

тоесть наша сумма это разложение исходного числа
по степням 16.  а то что нвутири собок это клэфиици
енты хекс разложения. поскольку bi это бинарные
коэфииценты разложения исходного числа. и мы же 
их знаем. то мы их подстлавяляем и получаем 
коэфиценты разожениея исходноого числа в хекс вид

HEX: [(b15)*2^3 +(b14)*2^2 +(b13)*2^1 +(b12)*2^0 ]
     [ (b11)*2^3 +(b10)*2^2 +(b9)*2^1  +(b8)*2^0 ]
     [ (b7)*2^3  +(b6)*2^2 +(b5)*2^1  +(b4)*2^0  ]
     [ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]

как можно заметить что при вычислении хекс коэфи
циента  у нас внутри скобки идет четыре слагаемых
что требует налиичия четрыех коэфициентов бинарного
разложения исходного числа для каждой скобки.
а что если у исходного числа число слалгаемых
бинарного разожения некратно четырем. ответ очень
простой -надо просто добавить к исходному разложе
нию слагаемые снулевыми кофициенатами. они дают
ноль тоесть не влияют на исходное деясятичное число
зато дают нужный слагаемый внутри скобки.
например рассмотрим на примере числа с разложением

11 0011

у него шесть слагамемых. дополняем эти слагаемые
двумя старшими нулевыми слагаемыми тоесть с неуле
выми коэфициентами

0011 0011

понятно что эти слагаемые никакого влияения на 
величину исходного дестичного числа не оказывают.

теперь без прблем можно узнать оба хекс
коэфиценита.
 
 0011 = 3
 0011 = 3

значит 

 HEX: 33

это дает нам взможность быстро узнать хекс вид
любого десятичного числа любой величины говоря
другими словами у которого его бинарный вид имеет
любую сколь угодно большую длинну

 01010101010101010101010101011010100

делим начиная справа биты на группы по 4 штуки.
если слева у нас бит не хватит до четрыех то 
доавляем нулевые биты

010 1010 1010 1010 1010 1010 1010 1101 0100

добавляем один нулевой бит слева

0010 1010 1010 1010 1010 1010 1010 1101 0100

теперь находим дес числа для кдоой группы бит

  2  10    10   10   10   10   10   13   4

готово это иесть хекс кофифиценты для исходного
числа

HEX:  (2)(10)(10)(10)(10)(10)(10)(13)(4)

согласно дебиличистичской нотации надо еще для
"приятности глаза" ( а на самом деле чтобы заебать
мозги искрыть правду) замениьт числа больше чем
9 на буквы

HEX: 2AAAAAAC4

вот так супер быстро просто налету и легко
мы имея BIN нотацию получили HEX нотацию

и наоборот. имея HEX нотацию любой длины мы 
ее супер быстро можем прервратить в BIN вид

просто берем вначале хекс нотаци превращаем
в набоор десятичных чисел заменяя буквы на 
скрытые за ними десятичные числа

HEX: 2AAAAAAC4

HEX:  (2)(10)(10)(10)(10)(10)(10)(13)(4)

теперь ждя кадого дес числа находим его разбиение
по степненям двойки. и вскобках запивыаем эти
коэфииценты

(0010)(1010)(1010)(1010)(1010)(1010)(1010)(1101)(0100)

единственное тонкость что вот что - эти коэфиенты
это разбиание дес числа по степеням двойки. так
вот с этой точки зрени наличие люого количества
нулей слева никак не влияет на величину дестичног
числа но! если мы эти коэифиценты или биты будем
хранить внутри компа то для компа имеет значение
каждый бит. поэтому! при первращении хекс нотации
в BIN нотацию у нас возникает неоднозначнсть
и вобще то человек который готовил HEX нотацию

HEX: 2AAAAAAC4

он дожен вместе с ней указать соклько бинарных
коэфицинтов было в исходной последовательности.
сколкго слагаемых было. или еще по другому сколко
было общее число бит. то есть в данносм случае
надо еще написать вот так 

HEX: 2AAAAAAC4 , исходное число бит 34

но на практкие обычно никто так не делает. 
точнее делаю но в неявной форме. например 
в тексте на си мы слева от этой записи указываем
тип переменной в которую это значение запиывается
наример 

  int i1 = 0x12A12

получается слева мы говорим что у нас длина 
пременной 4 байта. тоесть 32  бита.
слева у нас указано что количество слагаемых
в бинарном разложении у нас как минмум 4*5=20 штук.
тогда комплиятор просто напросто добавит к этим
20-ти штукам еще 12 слагаемых с нулевым коэфици
ентом. вот и все. тоесть
вот мы имеем

HEX: 12A12

BIN:  (0001) (0010) (1010) (0001) (0010)

как я уже сказал с точеи зрения дес числа мы можем
слева добавить любое число нулевых битов. и это
никак не влияет на дес число. тоесть у нас при
преорахвании из hex в bin есть неопределенность
котраая неимеет занчения с точки зрения если 
через bin мы получаем дес число. но это имеет
значение если мы эти коэфицены храним внутри
компа. поэтому нам нужна доп инфо о том сколько
бит было  в исходно бин массиве. компилятор эту
инфо для себя высчитыает исходя из указнного
типа пременной слева от равно. там у нас int
значит это 32 бита. значит
нам нужно добить слева нулями до 32 бит
значит внутр компа будет записано вот такое

(0000)(0000)(0000)(0001)(0010)(1010)(0001)(0010)


с точки зреия величины дес числа асолютно
все равно  вот такой у нас массив кэфициентов

(0001)(0010)(1010)(0001)(0010)

или вот такой

(0000)(0000)(0000)(0001)(0010)(1010)(0001)(0010)

дес число получается одно и тоже


комп поулчается это хранитель коэфтциентов разбиения
десятичых чисел по стееням двойки.


собсвтеннно вверху шло математическое обосование
почему можно так легко преврить биты в хекс
и хекс в биты. почему мы можем взять отделные буков
ки в хекс , превратить их биты. потом собрть в кучку
эти биты и это сопадает с битовым видом исхонного
числа.

ровно таже самая матемаика для OCT нотации.
причем там все еще класнее потому что ненужно 
делать никакой замены числа не буквы и букв на числа
как это нужно делать в хекс. 

в этом плане исходный набор слагаемх по стеням
двойки можно группировать в ощем и в целом с любым
количство слагаемых. при хекс кодиоваии мы 
гурпируем в скобку по 4 слагаемых при ОКТ кодиорвании
мы групппирем по два слагаемых. можно группировать
по пять слагамаеыхм, по 10 , по 60. как хочешь
так и группируй. при этом эффекты будут теже
самые. так как хекс это гурппировака по 4 слагаемых
а ОКТ это гурпровака по три слагаемых то между
ними никакой промежуточной гурппироки к сожалению 
нет. 

тем немнеее я четко покаал на освное математики
почему так легко и как конкненретно можно имея
хекс вид находит бианрный вид. и имея биранрный вид
находить хекс вид. 
    
    BIN -> HEX
    HEX -> BIN

тоже самое касается окт.

    BIN -> OCT
    OCT -> BIN





СЛЕДУЮЩИЙ важный вопрос
  это  Big-Endian
       Low-Endian


дело вот в чем. мы уже поняли что биты это 
коэфиценты разожения дес числа в сумму по степе
ням двойки. эти коэфииценты и хрнтся в нутри компа.

так вот каждый коэфиицент имеет соврещенно неравный
вес в формуле. какойто кофицент делает львиную 
долю вклада в велиичину значения дес числа. а 
какойто минимальный мизерный вклад. если мы
выпиываем эти кофэиценты вряд 
 101010101010110101010

то они должны идти строго по величине своего 
вклада. чтобы мы четко понимали какой из них 
к какому 2^N подставлять. на бумаге мы обычно
самый мощноый коэфиицент укзывае слева 
а самый хилый справа. писать на бумаге мы начинаем
слева. тоесть у нас самый мощный коэфициент ложиться
на бумагу (и соовесвтенно счиывается ) первым.
такой способ сохраенения коэфициентов называтся
Big-Endian

тоесть если у нас есть какойто сторадж  , хранилище
коэфиициентов. они у нас неравны по своей мощности.
и поэтому мы их сохраняем на сторадж в четком порядке. так вот если первым по времени (или другими
словами если в минимальный оффсет стораджа) мы 
первым кладем самый значимый коэфициент то такой
тип сохранения или такой тип стораджа называется
Big-Endian. если же мы бы совали бы первым самый
хилый кофицицент то это бы называлось Low-Endian
сторадж.

тоесть если мы разбили число на сумму степеней 
двойки. и получили кэфиценты. то нам в этом 
массиве коэфиыицнтов если мы их кудато будем
сохранять нужно знать нетолько величину каждого
коэфицеинта но и при каком члене 2^N он стоял.
толко имея первое и второе мы сможем восстановить
исходное дес число. мы могли бы на стораж
запиыат коэфициент и скажем ту степень N при котор
ом он стоял. но решили экономить. мы эти коэфииценты
упорядочиваем от меньшего к боольшему или от болшего
к меньшему. теперь нам досточно только значит
их занчения и знать где сидит самый незначительный
коэфиицент. тогда мы можем опятьже всосттавноить
исходное дес число. если мы сохраняем эту упорядо
ченную групу кэфицентв на сторадж. нчиная с 
адреса ADDR1 то нам только нужно знать сколокьо 
их было всего. и где у этой группы находится самый
слабый коэфиициент. и мы договариваемся что 
все числа котоыре мы будем совать а сторадж
мы будем их совать начиная с  соамого слабого
члена (Low-Endian сторджа) или начиная с самого
сильного члена (Big-Endiab сторадж). вот этот
параметр ендианесс это свойство стораджа.

вчем прикол если мы незнаем ендианесс у стораджа.
прикол в том что если у нас есть наалный адрес
и есть число элеметов. то мы их считываем но мы
никак не сможем понять какое же было сходное число.
тоесть вот мы считали по времени последователнсть

 1111 0000 

и не знаем она была изначально вот такая

 1111 0000
 |
 самый
 слабый
 коэфф

или вот такая

 0000 1111
|
самый
слабый
коэфф

тоесть было ли это изанчально число 15
или это было число 240
это опредеить своершенно невозможно. 
поэтому нам так важно знать параметр ендианнесс
у стораджа.
ну если сторадж воббще просто рандомно хранит
эти коэфиценты то вобоще понять какое было 
число невозможно. 

теперь погвооим про бумагу как сторадж.
вот хочется понять а какой енданесс у бумаги
как стораджа. 
напрмиере записи чисел в десятичной форме.
это можно легко найти . потому что вот берем
число на бумгае

   1234

мы говрим одна тысяча двести тридцать четыре.
первой по времени мы произносим левую цифру
(тоесть оффсет на бумаге начианется слева) и 
этот коэфииент он самый занчиимый по вкладу в 
коенечное дес число. а коэфицеинт 4 самый мало
значинмый. 

самый 
малый 
оффсет
сторадж
   |
   1234
   |
самый
значимый
коэф

это нам дает вывод о том что числа на бумаге
сохраняются в форме Big-Endian
тоесть отнсоиельно храения числе бумага работает
по приницпу Big-Endian


что касается сохранеия слова в форме букв
то тут трудно понять по какому ендиан бумага
это дело хранит. дело в том что если мы мы незнаем
какой изначальный вклад дает каждый символ в 
велчину значения исходной информации да еще и 
незанем тип  ендаинес стораджа то  нихрена 
не опреедилить ни тип стораджа ни  значимость
вклада символов путем прочтения информации со 
стораджа. вот мы пишем

       Вася

вот тип стоража неизвестен. мы хотим понять.
влияние каждый буквы на смысл слова лично мне 
тоже непонятен. поэтому хрен определишт и то 
и другое.
тоест я о том что если мы считали инфомрацию 
со стораджа
 
 1010101010101010101

то по сути это нам ничего недает. ни для нахождения
исходного числа(исходной информации) ни для 
опрделения типа стораджа. вот такой прикол.


ну отнсоиельно букв в слове я могу что предполо
жить. слово состоииз 

 приставка корень суфикс окончание

по идее главный смысл слова заключен в корне.
он обычно стоит в слове в левой части слова
нежели чем в правой. поэтому по крайней мере
левая часть слова более значиная чем правая.
на бумаге эта часть стоит у нас слева
например слово горный


   гор|ный

корень гор стоит слева на бумаге. он играет 
главную роль хранеия смысла слова. значит по идее
в плане соохраения слова по буквам на бумаге
она у нас играет тип Big-Endian

получаетя бумага это Big-Endian сторадж при сохра
нении чисел в десятичной форме или при сохарениии
слов. 

так как бумага получается Big-Endian сторлдж.
то получается что HEX нотация тоже сохранеся
на бумаге в Big-Endiab порядке. тоесть самый 
значимый кофицеинт укзывается первым

 HEX: A123
      |
      самый
      весомый
      коэффф

исходя из этой инфо мы знаем какие коэфф
к каким 16^N подставлять
а именно

 3*16^0 + 2*16^1 +1*16^2  +A*16^3


а тперь заходим на тот момент ради которого 
я этот эендианесс расписывал.  в памяти компа
кофэифиценты разложения числа по степеням двойки(биты) хранятся не форме индицаьных
битов а кучками по 8 штук (байтами) тоесть записать
из цпу в память и прочитать из памяти в цпу можно
не идндиульаный бит а только миниум кучку из 8 бит.
ну это ладно. это еще так себе. ксатти соверешнно неизвестно как внутри себя память
хранит эти биты внутри этой кучки потому что 
с точки зрения цпу (внешнего наблдаетеля) адрес
(оффсет) в памяти имеет только кучка целиком. тоесть
фрмально они в памяти лежат все  8 штук в одной коробке. а ендианесс имеет смысл если чтото 
лежит в одном офсете а чтото в другом. так вот
в памяти компа в одном офсете лежит 8 бит. тоесть
если выше я расписывал ендианесс для отдельных 
символов (букв цифр или битов) то когда мы 
говоим про память компа то получается что в нее
запимвыаются не биты а куски по 8 бит тоесть
байты. и ендианесс обсуждается на уровне байтов.
это как если бы на бумагу можно было бы запсиывать
не отдеьные буквы а только группы по 8 букв. 

тоесть вот у нас есть коэфииценты разбиения
числа по степеням двойуи каокгто числа

10101010101010101010101010101

на бумаге я указал упорядоченно это коэфииценты
так что слева у меня самый сзначимный бит
а справа самый малозначимый.
так вот когда я попрошу цпу записать этот
ряд коэффициентов  в память то он их разоььет
на кучки по 8 штук

 1010101 0101010 1010101 01010101 01010101

далее я обозначу эти кучки как байты

  byte1   byte2   byte3   byte4   
 1010101 0101010 1010101 01010101 


далее цпу будет совать эти кучки в ячейки памяти
начиная с указанного адреса. причем первым
будет записан байт у которого самые малозначимые
биты. вторым будет записан байт в кторого более
значимные биты ... и последним будет записан 
байт у которого самые значинмые биты.
тоесть


addr1   addr2   addr3   addr4     
byte4   byte3   byte2   byte1     


как память хранит биты внутри каждого байта не
известно

если я укажу цпу чтобы он прочитал 4 байта
начиная с addr1 в регистр то цпу зная что память
сохраняет много байтовое выражение по правилу LE
прочитает все 4 байта и перегруппирует прочитанные
биты с учетом того что в первом байте хранятся
самые слабые коэфииценты а в четвертом байте
хранятся самые значимые кофициенты. тоесть в случае
записи четырех байтов за раз и потом чтения 
четырех байтов за раз то тут для юзера все прозрачно.
нам даже думать ненужно. но если я запишу четыре
байта за раз. а потом считаю только 1 байт 
за раз то вылезет то что первый байт будет тот
который содержит самые слабые биты от четыерех
байтного числа.

как это проявляется на пракктике. вот я на бумаге
(в окне си редактора) пищу


 int i5 = 0x12345678


слева у меня указано что перменная в памяти будет
занимать 4 байта. тоесть мы в память пишем много
байтовое число. тоесть такое число которое имеет
разбиание по степеням двойки что число слагаемых
больше чем 8 штук. точное число бит равно 4*8=32шт.
это все следует из левой части. справа у меня
указано значение. по факту указано десятичное
число. указано оно в форме
коэфффициентов разбиения по степеням числа 16.
тоесть по факту справа незримо стоит вот такое
выражение

  (1)*16^7 +(2)*16^6 +(3)*16^5 +...(7)*16^0


тоесть  int i5 =  (1)*16^7 +(2)*16^6 +(3)*16^5 +...(7)*16^0


тоесть у нас стоит по факту

    int i5 = 305419896

 
тоесть справа обыкновенное десятичное число.
точнее в обоих случаях справа стоит число просто в
разных формах записи. в верхнем случае через
кофициенты числа 16 а ниже чрез коэфииценты числа 10

итак берем число выраженное в формате разложения 
по степеням числа 16. и вот как  я писал выше
верно то что если у меня есть бинарное разложение
числа то я могу поделить эти биты на группы по 
4 штуки. потом взять каждую группу из этих 
4 бит отдельно как бутто это отдельное число 
выраженное через степени двойки. посдтавить туда
коэфицинты и вычислить это число. и полученное
десятичное число будем коэфиицентом разложения
исходного числа по степеням 16. верно и наоборот
если у меня есть хекс нотация , то я беру каждый
символ этой нотации. тоесть это будет маленкое
десятичное число.раскалдываю это число по стееням
двойки. получаю 4 коэфиицента. и эти 4 коэфиицента
будут совпаадать с 4 коэфиицентами разложения 
исходного числа в соотвествующем месте.

тоесть еще раз. у меня есть исходное число
выраженное через разложение по степеням двойки


(b7)(b6)(b5)(b4)(b3)(b2)(b1)(b0)

я всего навсего правильно группирую скобки,
выношу кой чего за скобки


2^4*[ (b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0  ]  + 2^0*[ (b3)*2^3 +(b2)*2^2  +(b1)*2^1  +(b0)*2^0 ]


и вдруг оказывается я вижу формулу для вычисления
коэфициентов разложения этого же числа по стееням
числа 16 используя коэфииценты разложения этого
числа по степеням числа 2.
оказывается что наименьший коэфиициент находится
как сумма двоек в степени 0-3 и при каждой двойке
нужно поставить коэфиициент от исходного числа
с номерами 0-3
следущий коэфииент находится как как сумма двоек в степени 0-3 и при каждой двойке
нужно поставить коэфиициент от исходного числа
с номерами 4-7

тоесть алгоритм выглядит так. мы берем коэфициенты
разожения по двойкам исходноо числа. делим их
на группы по 4 штуки. 
  
      ...(bl  bk  bj  bi)...(b4  b2  b1  b0)
 
и потом  каждую такую группу
коэфиицентов  (bl  bk  bj  bi)
мы подствляем в формулу


  (bl)*2^3  +(bk)*2^2  +(bj)*2^1  +(bi)*2^0

и вот то число которое мы полчаем является
очередным hex коэфиицентом разложения. 

соотвесвтенно верно и обратное. если у нас есть
хекс запись. то мы берем каждое хекс число
и раскладыаем его в формулу

  (bl)*2^3  +(bk)*2^2  +(bj)*2^1  +(bi)*2^0

и найдыенные  биты  (bl  bk  bj  bi)  совпадают
с битами исходного числа в соовттвующих позициях.
тоесть биты получающиеся от разложения самого
слабого хекс коэфф дают биты в ращложении исходного
числа по степеням двойки за номерами 0-3
второй хекс коэфф его разложение на биты дает
нам биты исходного числа за номерами 4-7 итд.

тоесть если у нас есть хекс 

NM

то их разложение

N=(b7)*2^3  +(b6)*2^2  +(b5)*2^1  +(b4)*2^0
M=(b3)*2^3  +(b2)*2^2  +(b1)*2^1  +(b0)*2^0

а именно найденные b0-b7 числа
нам дают коэфициенты исходного числа

(b7)*2^7  +(b6)*2^6  +(b5)*2^5  +(b4)*2^4 +
(b3)*2^3  +(b2)*2^2  +(b1)*2^1  +(b0)*2^0

число N нам дает возможность опрееделить старшие
4 бита исходного числа а число M дает возможность
определить младщие 4 бита исходного числа

а что значит если в нотации у нас символы 
стоят рядом? тоесть


  HEX: NM

или

  BIN: 01010


это значит список коэфициентов. их можно было
бы записать через запятую

HEX: N, M

BIN: 0, 1, 0, 1, 0


тоесть сама нотация это список , перечисление.

ну и как бы незримо она шифриует то что между
ними стоит знак плюс


HEX: N + M

BIN: 0 + 1 + 0 + 1 + 0


и я рядом с каждым коэфииентом стоит степень


HEX: N(*16^1) + M(*16^0)

BIN: 0(*2^4) + 1(*2^3) + 0(*2^2) + 1(*2^1) + 0(*2^0)

тоесть нотация это на самом деле такой зашифрованный
знак суммы за которой в конечном итоге скрывается
обычное число. 

NM --> N(*16^1) + M(*16^0) --> 4534663


01010 --> 0(*2^4) + 1(*2^3) + 0(*2^2) + 1(*2^1) + 0(*2^0) --> 4534663


тоесть когда я на бумаге вижу 

    NM

я должен понимать что это такое мат сокращение
для суммы N(*16^1) + M(*16^0)
а сумма по своей сути имеет конечным итогом число!

поэтому кода я вижу что стоят два числа рядом
и нихера непонятно что же это зачит на самом 
деле то мгнвоенно должно прдти в голову что это
просто такое хитрое обозначение суммы а NM это
параметры этой суммы! а сумма
по своей сути это число!


тоест вот я вижу

  A1B1C1D1

что я вижу? я вижу на самом деле сумму!

тоесть еще пример вот я вижу

A1B1C1D1

что я вижу?
A1B1C1D1 ЭТО НА САМОМ ДЕЛЕ ДУРАЦКОЕ СОКРАЩЕНИЕ
СУММЫ A*16^6 + 1*16^6 + B*16^5 + 1*16^4 + C*16^3 + 1*16^2 + D*16^1 + 1*16^0 
а сумма это в итоге число!

а если я вижу
0101010 

что я вижу?  я вижу дурацкое СОКРАЩЕНИЕ СУММЫ
0*2^6 +1*2^5 +0*2^4 +1*2^3 +0*2^2 +1*2^1 +0*2^0 

А что если я вижу 

  N

это тоже дурацкое сокращение суммы

 N*16^0

правда в ней только одно слагаемое

а если я вижу

  MN

это дурацкое сокращение суммы

 M*16^1 + N*16^0


теперь сравним

  MN =  M*16^1 + N*16^0
   N =  N*16^0
   M =  M*16^0 (обращаю внимание что 16^0! а не 16^1)


как видно в трех случаях у нас совсем разные 
числа! еще раз совсем разные числа!

еще кстати сравним

  MN =  M*16^1 + N*16^0
  NM =  N*16^1 + M*16^0

опять же у нас совсем разные числа

если у нас есть число 0<= Q <=15 то оно однозначно
задает сумму разбиения по степеням двойки. еще раз однозначно задает.

    Q = (b3)*2^3 + (b2)*2^2 + (b1)*2^1 + (b0)*2^0

еще раз. если есть число Q  то оно однозначно
задает сумму и коэфиценты в ней

     Q -->  (b3)(b2)(b1)(b0)


тоесть если я задал число в диапазоне 0-15
то это равнозначно что я задал сумму

(b3)*2^3 + (b2)*2^2 + (b1)*2^1 + (b0)*2^0

задать число значит задать эту сумму. причем 
я ее задал однозначно! тоесть если я задал Q
то я при этом однозначно задал столбик коэфиицентов

    (b3)(b2)(b1)(b0)

тоесть он задан однозначно. 

еще раз хочу подчеркнуть
что  Q
и    (b3)*2^3 + (b2)*2^2 + (b1)*2^1 + (b0)*2^0
это одно и тоже
как только задаю Q то мгновенно возникает
и сумма. причем с уникальным набором однозначным
набором коэфиицентов.

ну вот для примера беру Q=12
автоматом сразу возникает 

 (1)*2^3 + (1)*2^2 + (0)*2^1 + (0)*2^0

потому что это одно и тоже. 12=12

теперь берем 

  NM

что  я вижу. я вижу обозначначение суммы. я вижу десятичное число.

  NM = N*16 +M*1 = дес число 

и это число запсиывается внутрь компа. с этой
точки зрения число записанное в форме суммы
по степени 16 нам нихрена ничего недает в плане
деталей. конечно по факту важен лишь модуль
конечного числа. 
но также нас инетерсует сумма этого числа
через степени двойки. в память записывается
число! тоесть нам важен модуль. но запиывется
оно по частям по степеням двойки (потому что оно как бы разобранное по частям
засыается в память как раз частями по степеням
числа двойки).

итак вижу 

NM

значит внутрь компа записвыается число N*16+M
а если я хочу детали какими частями это число 
записывается в память то нужно получить для 
этого числа сумму слагаемых по степеням 2^N.
если N раскладывается в степени двойки так

 N=(b7)*2^3 + (b6)*2^2 + (b5)*2^1 + (b4)*2^0

и M раскладыется в степень двойки так

 M=(b3)*2^3 + (b2)*2^2 + (b1)*2^1 + (b0)*2^0

то число NM раскладывается  в сумму степени двойки
так

NM=(b7)*2^7 + (b6)*2^6 + (b5)*2^5 + (b4)*2^4 +
   (b3)*2^3 + (b2)*2^2 + (b1)*2^1 + (b0)*2^0

и тогда внунтрь компа число записывется вот так

 (b7) (b6) (b5) (b4) (b3) (b2) (b1) (b0)

если NM это число = N*16+M то внутрь компа
записывается массив коофиицентов разложения 
этого числа по степеням двойки

тоесть в компе мы можем записать в тексте 
программы  модуль числа как


  short i = 899345; (дестичный вид)

ведь это по сути то что справа это завулиравнная
сумма а не само число


  short i = (8)*100,000 + (9)*10,000 +(9)*1,000 +
            (3)*100 + (4)*10 + (5)*1

комп высчитывает это число и потом
его разлагает по стееням двойки 
и засовывает не само число а  массив коэфициентов

можно запсиать в тексте  програмымы модуль числа
в виде hex суммы 

 short i = NM

который по сути 

 short i = N*16+M*1

какая разница компу через какие коэфициенты
высчитывает чему равен модуль числа. 
с таким же успехом можно напсиать

 short i =25*100+400*125+78*89

компу вобще пофиг какая арифм операция стоит
справа. тоесть хекс вид это всегонавсего такая
жесумма только скофициантами 16.ну и что. хоть
16 хот 116 комп легко посчитат конеченое занчение
при любой арифм операции справа

а далее комп разлагает это число полученное
на сумму разложения по двойке и сует ее кофииенты
уже в память

если нам интеерсно какие это коэфииценты то 
мы можем для себя их получить из хекс
если хекс 

  NM

то вот такая есть связь между битами разложения
в самого числа NM  и  битами разложения чисел N и M.
если N и M разлагаются вот так 

 N=(b7)*2^3 + (b6)*2^2 + (b5)*2^1 + (b4)*2^0
 M=(b3)*2^3 + (b2)*2^2 + (b1)*2^1 + (b0)*2^0

то тогда мы знаем как разлагается NM

NM=(b7)*2^7 + (b6)*2^6 + (b5)*2^5 + (b4)*2^4 +
   (b3)*2^3 + (b2)*2^2 + (b1)*2^1 + (b0)*2^0


если коэфиценты у  N это (b7)(b6)(b5)(b4)
и если коэфиценты у M это (b3)(b2)(b1)(b0)
то коэфииценты NM это

    (b7)(b6)(b5)(b4) (b3)(b2)(b1)(b0)


еще пример если  у нас число
 
  KLNM

и разложения для отдельных чисел равно 

 K=(b15)*2^3 + (b14)*2^2 + (b13)*2^1 + (b12)*2^0
 L=(b11)*2^3 + (b10)*2^2 +  (b9)*2^1 +  (b8)*2^0
 N= (b7)*2^3 +  (b6)*2^2 +  (b5)*2^1 +  (b4)*2^0
 M= (b3)*2^3 +  (b2)*2^2 +  (b1)*2^1 +  (b0)*2^0

то разложение для числа KLNM выглядит так

KLMN =(b15)*2^15 +(b14)*2^14 +(b13)*2^13 +(b12)*2^12 +(b11)*2^11 +(b10)*2^10 +(b9)*2^9 +(b8)*2^8 +(b7)*2^7 +(b6)*2^6 +(b5)*2^5 +(b4)*2^4 +(b3)*2^3 +(b2)*2^2 +(b1)*2^1 +(b0)*2^0


или чисто массив клэфицентов

(b15)(b14)(b13)(b12)(b11)(b10)(b9)(b8)(b7)(b6)(b5)(b4)(b3)(b2)(b1)(b0)

тут можно один важный момент указать это то что
вот возьмем число K и его разложение


 K=(b15)*2^3 + (b14)*2^2 + (b13)*2^1 + (b12)*2^0

и возьмем ту часть числа KLNM у которой теже 
самый коэфифенты

KLMN=(b15)*2^15 +(b14)*2^14 +(b13)*2^13 +(b12)*2^12+
     +...

из чего видно что в конечной сумме число K записанное
через свою сумму не входит в конечное число в форме
своей суммы! а просто между этими двумя числами
есть такая связь что у них совпдают коэфииценты 
на определенном участке!!! 
и только последнее число N имеет в числом KLMN 
нетолько такиеже коэфииценты разложения но  и 
такие же степени при двойках. поэтому
в чем прикол чисел K, L, M, N и числа KLMN ==>
он в том что если мы разложим все эти пять чисел
по степеням двоек то у этих чисел есть интересные
совпадения друг между другом в плане коэфициентов.

вот эти кэфиициенты (биты) из суммы KLMN и буудут записаны в память.

поэтому когда мы ссмотрим на хекс запист

    NM 

то нам нужно понимать для себя что мы щас видим
то ли конечное десятичное число. то ли сумму по 
стееняем числа 16, то ли сумму по степеняем числа 2.
то ли масссив коэфиицентов разложения по числу 2
и если первые три вещи они в целом означают одно
и тоже потому что десяиное число оно равно значению
первой суммы и второй суммы. то последняя штука
это нечто отдельное . тоесть просто массив коэфициентов это вещь которая не равна строго
говоря хекс записи NM. а она явлется хренью которая
прозрачно поставлена в сооветсвтие к этому числу.
тоесть 

пусть дано  NM=34
тогда строго говоря это значит

NM=34=3*16+4*1
NM=34=52
NM=34=(0)*2^7 +(0)*2^6 + (1)*2^5 +(1)*2^4 +(0)*2^3 +(1)*2^2 +(0)*2^1 +(0)*2^0

что посути одно итоже это число 52

а вот NM=34 -----> 00110100
это уже не прямое значение а маппинг нашего NM=34
на элемент из другого мира.

тоесть еще раз кога мы видим на экране запись
хекс

   0x34

то надо понимать что автор хотел передать. 
прямое строгое фактическое значение этой записи 
тоесть десятичное число. или он под этой записью
на самом деле подразумевает массив битов который
замаплен к этому десятичному числу.

тоесть еще раз - хекс запись это не масив битов.
а это десятичное число. но можно этому десятичному
числу уникальным образом примапить вектор битов.
можно это сделать в явном виде

0x34 -----> 00110100

а можно это сделать завуалированно. как бы подразу
мевая это за скобками

важно то что 0x34 !=  00110100 
это две разные вещи по своей природе


насколкь я понимаю на компе в редакторе си подразу
мевается именно второе. тоесть по факту мы пишем
в текте программы число в том или ином виде а
по сути мы этим намекаем компилятору на тот массив
битов который мы примапили к этмоу числу и хотим
чтобы компилятор догадался об этом массиве. и  его
и записал в память. 
как бы мы говоим компилятору

  short i = 0x1234

мы ему говорим . слушай справа стоит дес число 4660
а ты разложи его по стеееням двойки и запиши в память
массив коэфиициентов при этих двойках стоящие.
тоесть факчиески  в тексте мы справа пишем одну
сущность а просим комипилятор найти на основе нее
друугую сущность и вот уже ее и записать в память.

тоесть хекс 0x1234 это как рецпт борща. коиилятор
варит борщ и уже его а точнее некую его часть уже
пишет в память. но не сам рецепт.


теперь с горем пополам я хочу обсудить Endiness
у памяти компа. 

значит вот у нас есть массив из коэфицентов тоесть
битов
 
 0111010011010101010101010101

значит нам чтобы восставноить само число поэтим
кэфицниетам важны следущий мометы

   * у нас в массиве битов должны быть все 
     до одного кэфииценты из исходной суммы

   * коеффициенты должны быть упорядочены от самого
     важного до самого неважного они не могут
     рандомно быть сгруппиированы как яблоки
     в корзине

   * после того как мы их считали из стораджа
     то нам нужно знать на каком конце находится
     коэфиицент с самым слабым влиянием. тот который
     стоял при 2^0

   * нам нужно знать сколько бит было в исходном
     массиве

если мы считали из стораджа биты в том обьеме 
в котором нам задано. если они упорядочены по степени
важности. если мы знаем на каком конце сидит
бит который стоит при 2^0 то мы тогда знаем в какой
член 2^N нужно подтавлять каждый коэфиицент и мы
можем точно восставноить закодированное дестиячное
изначальное число.


оперативная память она не позволяет записыать
отдельные биты. она позволяет записыать только
кусками кратными 8 бит. точнее 8,16,32,64 бита 
куски. других вариантов нет. биты при считыании
мы получаем в упорядоченном виде. и такой еще
момент- если у нас массив битов исходный более 
чем 8 бит. тоесть скажем 16бит то в первый
адрес памяти записывается кусок 8бит который содер
жит менее весомые биты. а во второй адрес памяти
заиписывается кусок 8бит котрый содержит более
весомые биты.
тоесть

  MN=1234

  1234=00010010 00110100
       |               |
       самый           самый
       весомый бит     слабый бит

значит 
вот эти 8бит   
  
   00010010 

они содержат более значимые биты
а вот эти 8 бит 

  00110100

содержат менее весомые биты
поэтому вначале в память будет засунут 
вот этот кусок

   00110100

а уже в следующую ячейку памяти будет 
засунут вот этот кусок

   00010010 


у нас вот этот массив битов   00110100 
он совпадает с массивом битов у этого числа 0x34
тут важно подчеркнуть что 
вот это 00110100 и вот это 0x34 это неодно  и тоже.
0x34 это десятичное число закодированное в форме
суммы через разожение степеней числа 16 тоесть
0x34 = технически 3*16+4*1=52 у этого числа 52
есть разложение в сумму по степеням двойки(что 
значит разложение это то что данное число 52 можно
пресдавить как сумму. где сумма по факту пориводит
к числу 52) вот 
оно 52=(0)*2^7+(0)*2^6+(1)*2^5+(1)*2^4+(0)*2^3+(1)*2^2+(0)*2^1+(0)*2^0
и это разложение оно уникально только для данного
числа в плане коэфициентов. поэтому можно сделать
маппинг от коэфициентов этого числа к массиву битов

(0)(0)(1)(1)(0)(1)(0)(0) ---> 00110100 

новажно понимать что это именно маппинг. а не
равеснство. мы одной хрени ставим в советсвтие
другую хрень. мы числу 52 ставим в соооветсвтие
обьект из нулей и единиц по факту


    52 ---> 00110100

просто разложеие оьбьясняет почему мы выбираем
именно такое множество нулей и единиц.
поэтому 

 0x34 != 00110100

 а вместо этого

 0x34 ~ 00110100

тоесть прикол в том что если мы знаем 0x34 то момжем
найти чему равен  00110100 и наоброт если мы знаем
00110100 то можем для него найти 0x34
но они неравны друг другу. это разные хрени по 
природе. просто мы можем потавить их друг другу
в сооветсвие.

так вот получается что если у нас изанально 
дано число 0x1234
то в память вначале улетает поток битов который
можно найти на основе числа 0x34 а потом в память 
записывается поток битов который можно найти
на основе числа 0x12

если мы даем команду цпу считать все 2 байта 
за один раз то это все неважно. это для нас 
остается как внутренняя кухная памяти. но если
мы записали 2 байта в память за один раз 
то если мы считываем всего 1 байт то это все становится важно потому что первым память нам
выдаст поток битов сооосвтевующий числу 0x34
и только вторым байтом при следюущем чтении
памть нам выдаст поток битов соовствуеющий числу 0x12
как биты хрантся врамках одной ячейки 8 бит 
неизвестно. но память нам их возвращает в нужном
порядке в регистр цпу. 
то что память запиывает многобайтовый поток 
по байтно и в таком порядке что первым идет в память
байт у которого кэфииценты имеют наименший вес
по вкладу в модуль числа относит память к Low-Endiness типу
стораджа. 


на выхлопе это приводит к тому что если я в тексте
на си укажу

  int i = 0x12345678;

то в память в первую ячйку будет записан 
битовый поток который можно вычислить на основе
числа 0x78, во вторую ячяейку ляжет битовый поток
который сооовтсвтвет числу 0x56, потом 0х34
и потом 0x12

если я потом начну считывать из этого адреса по одному байту то первым байтом который я считаю
будет поток битов соотсвтвтущий числу 0x78 
а последний поток битов котоырй я считаю будет
соосвтастовать числу 0x12

это приводит к тому что на бумаге унас визуаьно
выглядит так что первым указан кусок 0x12
но в память первым залетит кусок 0x78
если я через четырехбайтовое число кодирую четрые
символа ASCII

 int i = 0x71727374;

где 0x71 это 'q'
а 0x74 это 't'
то у нас на бумаге оно выглядит условно вот так

 int i = 'qrst';

но на экране терминала будет напечатано вот так

'tsrq'

потому что как я уже показал первым в память улетит
байт который сосвеотвует числу 0x74 тоесть 't'
а четвертым улетит в память байт 'q'
потом когда я преедам эту преемунную в функцию 
которая пулеяет на термианал то она читает по 
одному байту из памяти. и по одному байту пуляет
на термиал. поэтому первым будет считан байт 't'
вот в чем прикол.


АД какойто. а не тема.


Еще раз такой момент. вот я вижу в тексте на 
си хекс нотацию

  NM

что я вижу? я на самом деле вижу суммму
  N*16+M*1 а эта сумма это десятичное число


NM --> N*16+M*1 --> 78 

а оно в свою очередь может быть выражено
через сумму степеней двойки

78 --> (0)*2^7 + (1)*2^6 + (1)*2^5 + (1)*2^4 +  
       + (1)*2^3 + (0)*2^2 + (0)*2^1 + (0)*2^0

итак

NM --> N*16+M*1 --> 78 --> (0)*2^7 + (1)*2^6 + 
        + (1)*2^5 + (1)*2^4 +  
        + (1)*2^3 + (0)*2^2 + (0)*2^1 + (0)*2^0

последняя сумма она уникальная(тоесть она 
взаимнооднозначная) поэтому это дает
нам основение сделать маппинг числа 78 на 
массив нулей и единиц

   78 ---> 01111000

и вот этот массив комп и пишет в память


хекс сумма NM интресна тем что коэфииценты которые
в нее входят N, M они имеют очень приколную связь
с коэфиицентами суммы через степени двойки.
коэфициент M приколен тем что если я его разложу 
по стееням двойки то в точности такая же сумма
входит в состав числа NM тоесть
если M=(b3)*2^3+(b2)*2^2+(b1)*2^1+(b0)*2^0
то число NM разлооженное в степени два имеет
ровно такиеже слагаемые

 NM= ..... + (b3)*2^3+(b2)*2^2+(b1)*2^1+(b0)*2^0


а число N  интресно тем что если я его разложу
в степени двойки
N=(b7)*2^3+(b6)*2^2+(b5)*2^1+(b4)*2^0

то исходное число разложенное по стееням двойки
имеет точно такие же слагамые только нужно этот 
N умножить на константу

NM=2^4*N+...

тогда получается интреесная вещь в том что 
коэфииценты разложения чисел N и M в точности
совпадают с кэфиицентами разложения числа NM
высчитать коэфиициенты раздожения числа NM сложно
а вычсчтат коэфииценты разложения чисел N и M 
гораздо проще а результатт тот же самый.

по сути получается вот что. если у меня есть 
хекс сумма NM то если я возьму любоые число N 
или M  и разложу его в сумму по стееням двойки то ровно такие же слагаемые есть в числе NM при условии
что я число N или M домножу на константу 2^q
дейсвительно ессли я беру число M
и его разложение по степеням двоуйки вот такое
M=(b3)*2^3+(b2)*2^2+(b1)*2^1+(b0)*2^0

то ровно такиеже слагаемые входят в состав
исхдоного числа при условии что  я домножу M
на 2^0
тоесть вот такие слагаемые есть в исходном числе
2^0* [(b3)*2^3+(b2)*2^2+(b1)*2^1+(b0)*2^0]

тоже самое про второе число N
если его разложение по двойкам это 
N=(b7)*2^3+(b6)*2^2+(b5)*2^1+(b4)*2^0

то точно такие слагаемые входят в состави
исходного числа при условии что я домножу N  на 2^4

2^4* [(b7)*2^3+(b6)*2^2+(b5)*2^1+(b4)*2^0]

так вот прикол в том что так как число на кортоое
мы домножаем оно кратно двойке то это значит
что в итоге каждое слагаемое внутри скобки
если раскрыть скобки оно превращается в двойку
в другой степени а коэфиицент преед двойкой
остаетя неизменным!
например 

  2^4 * (b6)*2^2 = (b6)*2^6

это нам дает то что в конечном итоге слагаемые
разложеним по степеням двойки в исходном числе
будут иметь такие же коэфииценты что и слагаемые
в разложении чисел N и M 
а дело в том что разложить числа N и M в сумму
степеней двойки в 100 раз легче чем разложить 
исходное число поэому то числа N, M намт так
интересны.

итак у нас получается что еси у нас есть разожение
по степеням 16 

 NM = 16*N+1*M

то каджый член этой суммы он очень классно 
легко и красиво разлагается на сумму степеней
двойки


16*N = 16*[(b7)*2^3+(b6)*2^2+(b5)*2^1+(b4)*2^0)]
       = 2^4*[(b7)*2^3+(b6)*2^2+(b5)*2^1+(b4)*2^0)]
       = (b7)*2^7+(b6)*2^6+(b5)*2^5+(b4)*2^4

здесь прекрасно все. и то что любой член 
разложения по степеням числа 16 он разлагается
в точности в четырые члена суммы разложения по
степеням двойки. и то что при этом разложении
коэфииценты разложения числа N по степеням двойки
совпдают с коэфиицентами разложения в конечных
слагаемых
дейвиеттльно сранивм разложение числа N
  (b7)*2^3+(b6)*2^2+(b5)*2^1+(b4)*2^0
и коэфииценты конечных элементов сумммы
  (b7)*2^7+(b6)*2^6+(b5)*2^5+(b4)*2^4

они не неизменились. это прекрасно! а неизменились
они потому что число 16 в любой степени это число
два в некоьтоой степени. поэтому при переменожении
это никак не влияет на коэфициенты!

а теперь сравним это со случаем кошда унас число
прсдтавлено в виде разожения по числу 10
 
скажем 65 = 6*10+5
берем слагаемое 6*10
попробуем туже самую технику . разложим число 6 
по степеням двойки

  6=(1)*2^2 + (1)*2^1 + (0)*2^0

посдтавляем в в слагаемое
  6*10=10*[(1)*2^2 + (1)*2^1 + (0)*2^0]
      = (1)*2^2*10 + (1)*2^1*10 + (0)*2^0*10

так как 10 не явлется степенью двойки то 
нам нужно тупо все пееремножать .

      =(1)*40+(1)*20+(0)*2^0

(1)*40=(1)*32+(1)*8=(1)*2^5+(1)*2^3
(1)*20=(1)*16+(1)*4=(1)*2^4+(1)*2^2

значит 
  =(1)*40+(1)*20+(0)*2^0 = (1)*2^5+(1)*2^3 +
    + (1)*2^4+(1)*2^2 + (0)*2^0 = 
    = (1)*2^5 + (1)*2^4 + (1)*2^3 + (1)*2^2 + (0)*2^0

итак я полчил что 
6*10=10*[(1)*2^2 + (1)*2^1 + (0)*2^0]
=(1)*2^5 + (1)*2^4 + (1)*2^3 + (1)*2^2 + (0)*2^0

а теперь сравним разложение числа 6 
и конечные слагаемые

[(1)*2^2 + (1)*2^1 + (0)*2^0]

(1)*2^5+(1)*2^4+(1)*2^3+(1)*2^2+(0)*2^1+(0)*2^0

как видим в конечной сумме есть все члены 
разложения числа 6 но еще есть целая куча других
членов. тоесть разложения числа 6 нам мало что
дает для определения коэфицентов в конечной сумме
тоесть ели мы беерм член разложения по стееням
десятки

6*10=10*[(1)*2^2 + (1)*2^1 + (0)*2^0]

то исходя из разложеия коэфииециента 6 при  этой
десятике мы мало что можем сказать про конечный
вид этой суммы если ее раскрыть и все првиести
к разложению по степеням двойки. тоесть на коэфици
енты в конечном разложении влияет не только 6-ка
но и 10-ка. все потому что 10-ка это не степень
двойки. тоесть когда унас член выгдяит как

 16*N 

то так как 16 это степень двойки то 16 на коэфииценты
разложения числа 16*N по степеням двойки не влияет.
на коэфиценты влияет только число N. влияет так что
коэфиценты числа N и будут кожфицентами числа 16*N

а случае числа 10*K у нас на кофиценты разложения
этого числа вляют нетолько коэфициенты числа K
но и само число 10. поэтому

если у нас есть сумма 16*N+1*M то только числа N и M
влияют на коэифиценты разложения числа (16*N+1*M)
а если у нас есть сумма 10*K+L то на коэициенты
разожения числа (10*K+L) влияют нетолько числа K и L  но и число 10
поэтому глядя только на числа K и L мы не можем
предскзаать какие будут коэфиценты у числа (10*K+L)
а вот глядя на числа N, M мы можем предскзаать
какие буут коэфицены у числа (16*N+M) потмоу что
число 16 никак не влияет.


Теперь еще раз на счет хекс нотации и 7-бит ных
последовательностях
у нас хекс 

 NM 

это по факту сумма через число 16 и в конечном
итоге это просто десят число. потом оно раскдвыадется
на суму степенй двойки. потом мы смотрим сколько
получилось членов в сумме и какие коэфициенты
и мапим мноество этих коэфицентов на массив битов.
так вот вопрос - может ли число NM разбиватся на
сумму степеней двоек так чтобы в этой суммме было 
7 членов или скажем 5 членов или 3 члена. 
ответ - и да и нет. это зависит от кокнеретных
значений чисел N и M
напрмиер N=1 M=9

19  = 16*1+1*9=25 а 25=(1)*2^4 + (1)*2^3 + (0)*2^2 + (0)*2^1 + (1)*2^0

мы получили 5 членов. и значит число 25 можно 
уникльных образом замапить на массив битов

  25 ---> 11001

так что хекс может спокойно за собой "скрывать"
массив битов длиной и 7 и 5 и 1 бит. но далеко
не кждый хекс. это зависит от кокнтертных коэфицентов
этого хекса.

НО! это чисто только с точки зрения математики.
как бы мы спрашиваем себя а может ли десятичное
число (которое выражено через сумме степеней 16)
при этом раскзывадтся в сумму степеней двойки 
там чтобы в этой сумме было 7 или 5 или 3 или даже
одно слагаемое? так вот с этой точки зрения
да может, но не для всех хекс сумм. а только для
конкретных.

ТАКВОТ прикол в плане компа в том что он хранит
внутри себя не суммы. он хранит внутри себя массив
коэфициентов из этой суммы и! число этих коэфиицентов
может быть минимум 8 штук! ни 5 ни 7 ни 3 а 
минимум 8 штук!  другое дело что мы всегда 
может взять нашу исходную сумму  и дополнить 
ее нулевым слагаемыми тоесть

 25=(1)*2^4 + (1)*2^3 + (0)*2^2 + (0)*2^1 + (1)*2^0
=0+0+0+ (1)*2^4 + (1)*2^3 + (0)*2^2 + (0)*2^1 + (1)*2^0=(0)*2^7+(0)*2^6+(0)*2^5+(1)*2^4 + (1)*2^3 + (0)*2^2 + (0)*2^1 + (1)*2^0

тоесть от того чтомы добавили три нулевых члена
к сумме наше число 25 неизменилось. но зато
теперь мы можем замапить наш 25 на вот такой
массив битов
 
  25 ---> 00011001

поэтому чисто математически хекс может кодировать
7-бит послеателность но внутри компа по факту
у нас неможет хранится 7битная псоедовательность
а миниум только 8битная. а сточки зрения
компа и информациии каждый бит это инфомрация и
масссив 
  11001
и массив
  00011001

это разные наборы информации

еще раз отмечу такой моемент что еесли у нас есть
дек число и мы его раскывадетм по стееням двойки
то вцелом число чденов в сумме неопределено 
потому что мы всегда можем дорисовать слева любое
количстеов нулевых членов. поэтому если минимальное
число членов котоыре мы никак не можем умнегьшить
вот как на прмимере числа 25

2^5+(1)*2^4 + (1)*2^3 + (0)*2^2 + (0)*2^1 + (1)*2^0

минимальное чсло членов 5
но макисмлаьное сколко угодно. 
поэтому когда нас просят разложить дек число на
сумму по стемняем двойки нужно сразу спраить сколько
членов максимум вы хотите там получить. у кажого
дек числа есть минимальное число коорые мы неможете
уенмьньшить но макимальное неоргарнчиено. поэтому
разложеие дек числа на сумму по стенпям двойки 
неоднозначное. в си мы эту неоднозачность решаем
тем что мы слева пишем длинуу будущей переменной

 int i = ....

слева мы говоим что пременаня имеет длину 32бита


 int i = 0xA

тгда понятно в какую суму нужно раскдаывать 
число справа

 A = (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0

это вот сумма разожеия с мимально возможным числом
слагаемех. а теперь мы ее допливаем до заказанного
числа слагаемых

 A = (0)*2^31 + (0)*2^31 +... +(1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0

и тогда наше число можно замапить на
 
  10 ---> 00000000 00000000 00000000 0001010

и вот этот поток битов 00000000 00000000 00000000 0001010 и будет засунут в память

АД. просто АД.


Далее. еще раз хочу подумать на счет хекс
и 7битной кодировки и хекс нотификации.

значит они говорят мы возьмем 7бит и поставим
им в соответствие символ графический. могут
ли они так сделать в теории - могут. но прикол в
том что внутри компа в памяти у нас не может
хранится кусок длиной 7бит. только кратный 8бит.
по идее мы можем обрабатывать 7бит. выглядит 
это так. мы читаем из памяти 8бит внутрт цпу
в регистр длиной 8бит. далее мы можем начать ана
лизировать состав семи бит внутри этих восьми
бит. но это мутор какойто. гораздо проще анализи
ровать восимбитовый кусок. 
в  любом случае в памяти хранится кусок минимум
размером 8 бит но никак не 7бит.

итак технически мы можем хранить 7бит только внутри
куска 8бит. когда нам нужно будет счтать из 
памти в цпу 7бит то мы будем читать 8бит.
и внутри этих 8бит нам нужно будет искать эти 7бит.
с точки зрения памяти мы храним 8бит. с точки
зрения цпу мы считаем из памяти 8бит. тоесть 
нам полюбоу нужно будет гонять туда сюда 8бит.
скачав 8бит в цпу мы можем проанализировать эти
8бит с точки зрения наличия там внутри этих 7бит.
с точки зрения прграммы на си у нас нет такого
типа данных у которого размер 7бит. минимум 8бит.
так что копилятор будет записывать в память 8бит.
когда мы будем ему это приказывать то мы укажем
вид этой 8битной последовательности в формате
хекс (хотя можно и в другой форме).

  char c1 = 0xA

здесь мы говорим ему чтоб он в памяти забронировал
одну ячейку. тоесть 8бит. 
тоесть из цпу в память полетят 8бит. вначале эти
8бит будут "рождены" в регистре внутри цпу.
а потом эти 8бит будут скопрованы в память.
справа у нас стоит по факту арифм формула суммы.
которая выражает десятичное число. компиляторму
нужно найти это число. потом ему нужно разложить
его на сумму по степеням двойки. потом ему нужно
ее дополить до нужного числа членов. потом ему
нужно выделить из этой суммы массив коэфициентов.
и потом этот массив коэфиицентов  записать в память.
поехали.
  0xA=1*10

итак справа записано число 10
разлагаем его в сумму степенй двойки
10=(1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0
это сумма с минимално возможным числом слагаемых.
теперь нам надо ее дополнить до заказанных 
восьми штук. тоеть
10=(0)*2^7 + (0)*2^6 + (0)*2^5 + (0)*2^4 +
   + (1)*2^3 + (0)*2^2 + (1)*2^1 + (0)*2^0

тоесть теперь компилятор понимает что ему нужно 
в память записать вот такой набор битов
  00001010

и он ихсует в память. 
так вот вопрос- может ли хекс нотация кодировать
7бит. хекс нотация кодирует десятичное число.
его можно разложить в сумму степеней двойки.
причем неоднозначно в плане числа членов.
у этой сумму есть минимльное число членов в зависи
омсти от самого числа.  а максимаьное число членов
неограничено. итак у нас хекс нотация по факту 
кодирует ЧИСЛО. обычное число. хекс не кодирует
никакие биты. разложив число в сумму двойки 
мы полуичим какоето число слагаемых и у них 
будут коэфициенты. так вот можно ЗАМАПИТЬ
коэфициенты в слагаемых на массив коэфциентов

0x11=1*16+1=17 =(1)*2^4+(0)*2^3+(0)*2^2+(0)*2^1+(1)*2^0


       мапим с обьектом 
0x11 ------------------->  10001


тоесть хекс нотация 0x11 физически обозначает
число 17.также физически оно обозначает
вот такую суммму
(1)*2^4+(0)*2^3+(0)*2^2+(0)*2^1+(1)*2^0
потому что эта сумма физически тоже число 17
так как коэфииценты уникальны то тогда 
можно ЗАМАПИТЬ число 17 на обьект другой природы

 17 ---------> 10001


потму сам хекс он никакие биты не обозначает
в себе не содержит. он в себе содржит обычное число.
но используя доп механизм можно найти битовый массив
который можно ПОСТАВИТЬ В СООТВЕСВТИЕ тому числу
который содержит в себе хекс. 
еще раз сам хекс в себе биты не содержит ровно 
также как картошка в себе ноты не содержит.
но можно найдя число применить к нему функцию
которая выдаст поток битов который этому числу
ставит ся в соовесвтие. 

условно график этой функции

биты
|
|
|            003
|      002   
|  001
---|----|----|-------------> 
   1   2  3           числа

тоесть когда мы пишем в тексте на си

  char c1 = 0xA

то на самом деле мы пишем

 char c1 = f(0xA)


так вот вопрос. вот я беру хекс нотацию. прмиеняю
к ней эту фнкцию. сколкьо битов будет в результате?
засада в том что эта фукнция она не дает однознач
ный результат. потому что .
у нас есть однозначный результат вот здесь
 0xA1=10*16+1=161
этот реузлттат однозначный. 

а далее функция f(161) она должна разложить 
число 161 в сумму по стенпеям двойки. и это операция
неоднозначная!у этой суммы есть миллион вариантов.
оно лежит в диапазоне от некотрого минималного
числа до бескноенечнго большого. здесь мы должны
придти на помощь к этой функции и ей указать 
какое число мы кнкретно хотим получить. скажем 9.
тогда

 161 = (0)*2^8 +  
       (1)*2^7 + (0)*2^6 + (1)*2^5 + (0)*2^4 + 
       (0)*2^3 + (0)*2^2 + (0)*2^1 + (1)*2^0

исходя из этго f(161) выдаст = 0 1010 0001
тоесть выдаст 9битовый массив

таким образом 0xA1 может при прмиенении к нему
f(0xA1) выдать 9битовый массив

а вот выдать 7битовый он неможет. 

тоесть 0xA1 может "кодировать"  9бит но неможет 7бит

но опять же это чисто в теории. на бумаге. 
потому что бумага может хранить в себе как сторадж
любое число бит любыми кусками. 

а внутри компа у нас f(0xA1) может замапить 
только на массив из бит число которых кратно 8.
тоесть мы не можем внутри компа сохранить кусок 9бит.
мы можем сохранить только кусок 16бит. внутри которых
будет пряаттся этот кусок 9бит.
тоест вот наши 9 бит с бумаги

0 1010 0001

но на компе можно записать только вот такой массив
     
0000000    0 1010 0001

поэтому чисто математичски и на бумаге 0xA1 может
"кодирвать" 9бит. но внутри компа неможет. 
а может только 16бит. 


поэтому получется что вопрос  - а может ли хекс
кодировать 7bit. получается на бумаге да.
и то только при некоторых значениях хекс.
это будут хекс нотации 0x00 - 0x1F
но внутри компа нет. внутри компа через эти
хекс нотации мы можем "маппить" "кодировать"
только 8битные массивы битов когда у нас сторадж
для битов это память.  да если мы загрузим эти
8 бит в цпу. то там мы можем вычленить из этих
8 бит субмассив из 7бит.

пэтому я считаю что на бумаге хекс может "кодировать"
массивы битов длиной 7 штук. но внутри компа нет.
внутри компа компилятор наш хекс преобразует всегда
в 8битный массив. и именно 8битный массив будет
создан внутри цпу и засунут в память. 
поэтмоу например когда мы говорим что символ 'q'
имеет битовый вид закодррованный через хекс 0x71
то это означает что факически и физически внутри
компа это битовый секвенс длиной 8бит а не семь
и вот такого вида

  0111 0001

тоесть если я компилятору напишу

  char c1 = 0x71

то он сгенерирует из этого хекса именно 0111 0001
а не 111 0001 !! и не 1111 0001 !!
и именно 0111 0001 вот это будет засунуто в память!

поэтому я считаю что хекс в рамках компа это 
всегда на выхлопе массив битов кратный 4-ем.
и 7бит сюда никак не попадает.

поэтому все таки по мне 


 
 $ man ascii

где с одной стороны указываются хекс нотации
а с другой стороны наспиано что 

ASCII is the American Standard Code for Information Interchange.  It is a 7-bit code.

то я считаю что это неправильно. на бумаге это
может быть верно. но так как аски приудмыали в
разрезе компов то я считаю что аски это 8битная 
кодировка. 

что еще забовано  я отркыл стандарт ASCII

https://onlinelibrary.wiley.com/doi/pdf/10.1002/9781118033296.oth

и там четко показано что символы мапятся на 
ВОСЬМИБИТНЫЕ МАССИВЫ! А НЕ СЕМИБИТНЫЕ!

в общем конечно с этим хекс плюс то что комп
хранит биты кусками по 8 бит  + ascii = голову
сломаешь....


прикольно еще то что  в памяти то у нас биты хрантся
только кратно 8битам но если мы омеиваемся битами
скажем через модем то там биты передаются не кусками
по 8 штук а по одной штуке. тоесть  я хочу
скаать что через интрфейсы биты могут преедваться
по одной штуке. и там уже нет ограничения на то чтобы
поток был кратен 8бит. по идее.


