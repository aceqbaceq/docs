ssl

как работает аутентификация по сертификатам.

мы как клиент хотим попасть на mail.ru

мы шлем пакет на mail.ru

между нами и сайтом сидит злодей. он перехватвыает наш пакет
и шлет обратно нам сертификат. 

что такое сертификат. он содержит subject - владельца которму он выдан
, в качестве владельца может быть указан IP или dns имя.
subject=mail.ru

он содержит публичный ключ от mail.ru
он содержит имя удостоверяющего центра
он содержит электронную подпись которую поставил удостоверяющий
центр на этом сертификате.

что такое цифровая подпись - удостоверяющий центр берет текст сертификата
и шифрует его с помощью своего приватного ключа и что получается на выходе
это и есть цифровая подпись. приватный и публичный ключ они всегда создаются в паре. 
если у нас есть публичный ключ и шифрованный
текст и мы расшифровавыем текст с помощью открытого ключа  то утверждается
что зашифровать его мог только и только тот у кого есть приватный ключ от этого публичного ключа.

привожу распечатку примера как выглядит сертификат


# openssl x509 -text -noout -in /etc/kubernetes/pki/apiserver.crt
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 7574599387387853718 (0x691e6202c924fb96)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=kubernetes
        Validity
            Not Before: Oct 10 14:07:06 2020 GMT
            Not After : Oct 12 20:20:26 2021 GMT
        Subject: CN=kube-apiserver
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:af:2b:8e:ea:15:2e:60:de:73:31:62:6f:95:29:
                    c8:b8:c4:5a:74:af:c9:71:85:0f:89:7f:e1:bd:a3:
                    e7:b3:55:c4:ee:44:24:41:d3:a9:c0:2b:bd:ee:3a:
                    9b:67:61:55:8d:c6:bc:27:75:91:85:33:f8:50:ed:
                    da:aa:58:c1:49:7f:dd:f0:ad:0e:15:80:65:0e:f0:
                    26:57:83:a0:1b:6a:17:04:d6:61:ad:78:07:cd:b1:
                    4e:f7:dd:d5:88:9f:40:2a:48:0a:0e:eb:a3:47:6e:
                    6e:21:f4:3a:8c:16:c9:ea:7b:87:b2:82:ae:2e:f6:
                    9d:09:92:18:46:ac:9e:8a:27:d8:c8:8f:5a:a5:6f:
                    1b:8b:c6:40:6c:89:20:46:74:02:02:f1:42:30:22:
                    03:24:f1:66:d0:5d:47:64:e1:22:c0:e9:f2:86:d0:
                    55:a8:25:73:d5:4c:97:bf:0d:c6:84:5f:8e:e7:c0:
                    07:b6:c1:f5:b2:a6:da:5b:4a:44:cf:94:57:d7:70:
                    93:ce:cd:53:c2:c6:54:1c:44:bf:00:6b:83:89:c4:
                    d3:85:89:6c:8d:c0:16:e0:f5:02:65:35:81:97:a4:
                    93:1f:0d:72:ab:8d:34:9d:42:05:0e:c9:26:1d:1a:
                    c7:b3:60:34:7b:32:a9:25:7c:77:90:d3:09:df:27:
                    7d:c9
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication
            X509v3 Authority Key Identifier:
                keyid:F4:5B:F4:79:AD:3B:64:DE:91:B9:FD:8A:9B:62:DB:94:7D:70:8C:57

            X509v3 Subject Alternative Name:
                DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:test-kub-04, IP Address:10.96.0.1, IP Address:172.16.102.34, IP Address:172.16.102.100
    Signature Algorithm: sha256WithRSAEncryption
         60:c5:c4:11:55:8c:36:77:0b:af:1b:3d:7c:08:0a:ad:8f:a9:
         c8:45:7f:b4:93:0d:e8:70:d8:f8:e4:95:8d:78:7b:fd:22:54:
         35:6f:51:b6:4f:07:73:ef:81:2c:99:8a:93:89:3a:dd:8f:ee:
         15:ac:c8:9c:b2:47:7a:21:1e:23:66:d0:e3:d4:1b:1b:84:42:
         a9:4e:70:fe:fd:c8:e8:6c:a0:c7:b5:79:84:18:49:a0:19:73:
         d2:56:e2:0b:59:16:95:8d:86:6c:a8:7c:68:d1:69:98:8f:10:
         6e:d2:49:1c:22:9d:6c:5f:0b:c0:95:cb:21:73:92:43:64:1c:
         71:35:02:26:e2:40:51:e3:96:ae:20:d3:62:ed:31:44:c6:34:
         71:13:20:97:30:47:74:c8:40:84:b7:5c:43:77:73:a9:56:74:
         d8:e3:8e:34:fd:48:04:8d:56:a0:da:49:11:34:8c:8e:3f:9b:
         ac:53:6c:51:36:86:1a:5d:d2:5b:72:26:3d:fc:e2:b4:8b:24:
         a8:6d:d2:7a:ca:12:b6:04:ec:66:61:5d:10:39:ad:aa:c2:82:
         8f:ab:5b:bd:e0:58:df:6f:57:09:c3:79:dd:20:7a:1c:61:05:
         c8:02:fa:d9:6a:7a:98:6c:2e:7c:93:e1:9d:2c:d1:1c:24:a8:
         3f:c3:68:f0

как видно еще раз что содержит сертфиикат

Issuer: CN=kubernetes    ( тот кто выдал. удостоверяющий центр)
срок годности

Subject: CN=kube-apiserver (кому выдано. владелец)

Modulus: сам публичный ключ

X509v3 Extended Key Usage: TLS Web Server Authentication (типа преднач
ение ключа. чисто информационное поле)

X509v3 Authority Key Identifier:               keyid:F4:5B:F4:79:AD:3B:64:DE:91:B9:FD:8A:9B:62:DB:94:7D:70:8C:57 =
= что это такое. это хэш (sha-1 вроде)высчитанный из публичного ключа
удостоверяющего центра. тоесть удостоверяющий центр имеет публичный
ключ , на него натравливают sha-1 и получают Authority Key Identifier.
соотсвтсвенно публичный ключ CA знают все, sha-1 на него могут натра
вить все так что AKI это штука которую может вписать с сертификат
любой и она обозначает цифрами а не словами какой CA якобы выписал 
данный сертификат. фишка просто в том что сертификат в целом подписан
цифровой подписью CA и злодею чтобы создать цифровую подпись которую
можно расшифровать открытм ключом CA и получить исходный сертификат 
невозможно так как чтобы ее защифровать и ппотом успешно расшифровать
нужный закрытй ключ CA а не какойто там любой закрытый ключ.
если сертифкат зашифровать какимто закрытым ключом и приложить это 
как цифроую подпись то ее при расшифровке открытм ключом CA неполучится
получить исходный текст сертификата. в этом и фишка.

еще сертифкат может содержать ski - это sha хэш от публичноо ключа
кому сертификат выдан.
aki ski используется нетолько чтобы показать кто владелец того или иного
пубичного ключа через цифры а не буквы в качестве информации 
а и для того чтобы устанавливать цепочку когда у нас сертификат выдан 
васей а васе сертифкат выдал петя а пете сертикат выдал коля.

следущее поле X509v3 Subject Alternative Name:
                DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:test-kub-04, IP Address:10.96.0.1, IP Address:172.16.102.34, IP Address:172.16.102.100

оно показывает альтернативные имена тому кому выдано.
тоест мы можем обрашаться на сайт под любым из этих имен а нетолько
под вот этим Subject: CN=kube-apiserver
это удобно чтобы не выдавать миллион сертификатов. тут несколько 
водном получается.

ну и в конце поле большой Signature Algorithm:
это как я понимаю цифровая подпись удостоверяющего центра.

именно она нам дает возможность проверить что сертифкат настоящий
а не поддельный от злодея.

как это происходит

в сертификате открытым текстом прописано КТО выдал 
сертифкат = Issuer: CN=kubernetes, также тоже самое указано открытм текстом через цифры = X509v3 Authority Key Identifier:               keyid:F4:5B:F4:79:AD:3B:64:DE:91:B9:FD:8A:9B:62:DB:94:7D:70:8C:57

окей. теперь мы знаем кто якобы выдал сертификат. 
но эти поля могут быть подменены злодеем. куда он мог вписать 
все что захочет.

но у нас на компе в браузере есть предустановленные открытые ключи от всех авторитетных центров 
сертифкации . они предустановлены. также у нас в сертификате есть 
цифровая подпись якобы от заявленного центра сертификации.

что такое цифровая подпись. это центр сертиификации берем полный текст
сертификта и шифрует его своим приватным ключом. и вот этот 
шифротекст это и есть цифровая подпись.

мы берем открытый ключ от заявленного центра сертиификации (этот ключ
у нас заранее есть на компе его туда поставил браузер когда мы его
устанавливали) и применяем к цифровой подписи получаем расшифрованный
текст . и если этот текст такой же как текст сертификата то значит
100% цифровая подпись произведенеа на центре сертификации ну и поскольку
сам расшифрованный текст содержит текст сертификата то мы понимаем 
что сертификат произведен именно центром сертификации от  и до.

возникает вопрос нахера прикладывать текст в открытом виде в сертификат
если он содержится в шифрованном виде в цифровой подписи.
во первых из цифровой пописи непонято какой CA ее сделал, во вторых 
людям чтоб проичтать сертификат его ненужно расшировывать, в третьих 
когда создается цифровая подпись то она шифрует не сам текст сертификата
это я изначально написал чтобы упростить понимание в целом, создание цифровой подписи идет немного иначе. берется текст сертификата и из него
вычисляется хэш. сертифкиат длинный и текстовый а хэш короткий и цифровой
а вот уже на хэш натравливается шифрование приватным ключом.
таким образом расширваная цифровая подспись содержит хэш от сертификта
а не сам текст сертификта. поэтому к цифровой подписис втом числе надо
приложить текст сертиификиата в открытом виде.

получается что мы вычисляем хэш из открытго текста сертифкиата, потом
расшироываем цивроую подпись открытм ключом CA получаем тоже типа 
число. и сравниваем его с хэшем и они должны совпдаать.

таким макаром получается что сертифкат невозможно никак подделать
никакие его поля.    а если его подделать то проверка сразу выявит это.

ключевой момент это если в сертификта заявлен центр сертификаци от котогорого у нас нет публичного ключа - то таким сретртификатам 
категорически доверять запрещено. достоверность такого сериификта = ноль.

в чем фишка открытого(публичного) и закрытого(приватного) ключей. если у нас есть закртый ключ
то мы можем всем сказать публичный ключ и тогда люди могут шифровать публинчным ключом текст и посылать нам. и расшифровать его можем только 
мы. только тот у кого есть приватный ключ.
далее фишка - зная привтный ключ можно легко вычислить публичный
ключ. а вот зная публичный ключ (который знают все) никак нельзя
вычислить приватный ключ.

получается приватный ключ дает возмжоность принимать и расшифровывать сообщения кнам<--.
а публичный ключ дает восзожность шифровать и отправлять сообщения отнас-->.

значит еще раз про цифр подпись и сертификат. 
у нас есть текст в котором написано что он якобы был выдан CA. и 
цифровая подпись приложена. мы берем открытый ключ от CA расшифроваыем
цифровую подсптись получаем текст если он совпадает с текстом самого
сертификата значит текст внутри шифровки был зашифрован именно CA.
значит мы можем доверять сертификату он достверный.

если текст сертифката несвязан с цифровой подписью 
то мы расшифровав цфровую подпись это увидим. что одно к другому неотносится. так что неполучится пристыковать подпись от чегото одного
а текст сертифкиат свой. текст сертифктааи цифровая подпись имеют 
однозначное соотсвтетеие друг с другом.
невозможно создать цифровую подпись которая условно говоря содержит
текст исходного сертификата от имени авторитетного CA. потому что ждля
этого надо иметь приватный ключ того CA.

значит злодей нам может прислать только достоверный сертификат и ничто
иное.

иначе мы это сразу раскроем.

мы получаем сертификат из которого мы узнаем что mail.ru
имеет такой то открытый ключ. удостовренный такимто CA.
мы в этом убеждлаемся. далее мы берем некое число\текст который мы
только что придумали и знаем только мы и еще мы берем публичный ключ от нашего компа (на нашем компе мы сами себе придумали публичный и приватный ключ. они относятся к нашему компу) и мы шифруем этот текст 
который мы придумали и публичный ключ нашего компа с помощью открытого ключа mail.ru и шлем обратно на mail.ru

итак на mail.ru улетел [текст+публичный ключ нашего компа] которое
мы зашифровали с помощью публичногло ключа mail.ru 

злодей перехватывает наш пакет он имеет открытй ключ mail.ru тоже
так как он всем доступен но он немжет расширофвать наш исхдный текст
для этого унего нет приватного ключа mail.ru а зная публинчый ключ
mail.ru никак невычислить приватный ключ.

итак злодею только осатеся прекратить или передать пакет на сам 
mail.ru

mail.ru получает пакет расшифровает его с помощью своего 
приватного клоюча и узнает наш текст и наш публичный ключ. 
далее mail.ru нашим публичным ключм шифрует обратно наш текст+некоторый
текст самого mail.ru и отпралвяет оброатно нам.

почему mail.ru неможет шифровать пакет нам с помощью своего приватного 
ключа. потому что такой текст может расшифровать любой используя публичный
ключ mail.ru. поэтому пакет нам мейл.ру шифрует с помощью публичного ключа
который мы ему переслали

злодей перехвает этот пакет но он неможет его расшифровать так как 
у него нет приватного ключа нашего компаа.

и он передает пакет уже нам.

мы пакет расшифровываем и видим во первых текст который мы послали туда
и мы понимаем что mail.ru его получил. и получил только он и никто иной.
тоесть мы получили признак что наша посылка дошла до адресата.

и мы получаем текст самого мейла ру.

а далее происходит вот что мы слепляем из нашего текста и текста мейл ру
некий единый ключ и начинаем его использовать как ключ симметричного
шифрования уже для предачи приема данных между нами и мейл ру. 
и мейл ру делает тоже самое. 

получется пофиг на злодея и мы и мейл ру имеем один и тот же ключ 
для симетричного шифрования.

и пошлп передача данных.

в чем фишка симметричного vs ассмеитричного шифрования.

ассиметричное это когда у нас два ключа.каждый для своей цели. приватный ключ для расшифровки данных  а публичный ключ для шифрования данных.

в чем проблема этого шифрования - оно очень сильное но оно очень цпу загрузка емко. поэтому его нерационалоьно использовать для передачи 
больших обьемов.

симметричное шифрование оно нетакое стойкое , у него исползщуется один ключ и длоя шифрокии для расшгифровки. то есть зная один ключ мы можем 
всегда и зашифровать и расифровать послание. но оно цпу загрузка
отнсительно легкое.

вот так выглядит процесс установление шифрованной связи с сайтом
по https.

ssl он был изначально. и как я понял если мы юзаем версию A то 
она поддерживает и предыдущшие версии. какую то обратную совместимост
хотя неочень опнятно что это на практике значит.

tls это типа тот же ssl но каких то более последних версий и он 
неиммет обратной совмесимости с преддыущими версиями ssl.

то есть тип ssl кждую новую версию создвавали с оглядкой а обратную совм
местимость с преддыдушими версиями. а tls отбросил необходимость
обратной совсестимости.

получается ертифкикаты позволяют удостврерться что мы достучались 
именно до того сервера куда хотели и устнвоить с ним шифрованную 
безопасную связь канал.

--

про сертификаты.

сертификат может хранится в файле в двоичном виде и тогда это DER тип кодирования
сертификата.
вот выдержка с сайта

DER files are digital certificates in binary format, instead of the instead 
of the ASCII PEM format. 
DER files may end with .der or .cer, so to differentiate between DER.cer and PEM.cer files, you may need to use a text editor to read the file.  A DER file should not have any BEGIN/END statements and will show garbled binary content. 
Both digital certificates and private keys can be encoded in DER format.
DER is often used with Java platforms.


также сертификат может хранится в формате PEM этот формат хранит сертификат
используя  ASCII символы

вот пример сертификата который хранится в формате  PEM

-----BEGIN CERTIFICATE-----
MIID8DCCAtigAwIBAgIHAIt4mgEmwTANBgkqhkiG9w0BAQsFADAbMRkwFwYDVQQK
==
-----END CERTIFICATE-----


имеет характерные строчки с BEGIN и END
 
в самом сертификате никак не указано в каком формате он хранится. это 
как вода которая ничего незнает о форме сосуда в котором она лежит.
как определить -  чисто открываем текстовый редактор и смотрим что на экране.
если BEGIN END значит это PEM это мусор какойто то DER.

как посмотреть содержимое сертификата в формате PEM

 $ openssl x509 -text  -inform pem -in ./rui.crt

посмотреть содержимое сертифкта в формате DER

$  openssl x509 -text  -inform der -in ./rui.der

приватный ключ в формате PEM имеет немного другой вид чем
сертификат

-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----

проверить что с приватным ключом все впорядке можно командой

$ openssl rsa -in s1.key -check



===
| get cert 

вот мы стучиися на https как нам выкачать сертификат с той стороны


openssl s_client -connect {HOSTNAME}:{PORT} -showcerts

==

| new
как создать новый самоподписанный сертиификат

$ openssl req -new -x509 -keyout test-key.pem -out test-cert.pem

проверяем созданный сертификат
$ openssl x509 -text -noout -in    ./test-cert.pem 
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            1b:44:23:12:16:1d:37:92:29:e6:2c:4d:d8:23:a3:2d:b0:fd:44:35
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: C = KG, ST = Some-State, O = Internet Widgits Pty Ltd, CN = magento.local
        Validity
            Not Before: Sep 13 18:35:42 2023 GMT
            Not After : Oct 13 18:35:42 2023 GMT
        Subject: C = KG, ST = Some-State, O = Internet Widgits Pty Ltd, CN = magento.local

видим что CN=magento.local



| CA
| cert

вопрос как создать руками свой собтвенный сертификат CA ROOT
интсрукция слегка лоховская в том плане что например DES проскавиваеи.
тоесть интрукция не совсем серьезная.


генерируем приватный ключ(обрати внимание dsa)
    
    $ openssl genrsa -des3 -out myCA.key 2048


из этого ключа создаем приватный сертификат


    $ openssl req -x509 -new -nodes -key myCA.key -sha256 -days 1825 -out myCA.pem

итак мы создали CA ROOT сертификат

теперь наша задача добавить этот рут сертификат в хранилище сертификатов
в линуксе
я не знаю каким макаром приложения ищут на компе ROOT TLS сертификаты
подозреваю что это очередная ебала которую нужно отдельно изучать
также как была ебала с DNS и NSS. так вот из того что я нашел нужно
взять наш новый сертификат  myCA.pem 
далее мы копируем его в папку

        /etc/ca-certificates/trust-source/anchors

тоесть файл будет лежать вот так

        /etc/ca-certificates/trust-source/anchors/myCA.pem

далее надо запустить команду
    
        # update-ca-trust extract

как работает эта команда хуй знает. есть мануал 

    $ man update-ca-trust

но я пришел к выводу что эта команда она берет наш рут сертиифкат
и остльаные рут сертификаты которые лежат в папке 

    /etc/ssl/certs

хотя в этой папке всего лежат симлинки на сертификаты которые лежат в папке

    /etc/ca-certificates/extracted/cadir

в любом случае в этой папке лежат только рут сертификаты. для всех
остальных сертифкатов их нет необходимости хранть на компе. мы
всегда можем прверить любой сертфиикат на основе рут сертификата. 
так что на компе мы хораним только рут ертиифктаы. вот они в этой папке
все и хрантся. так вот как я краем уха понял тот кто хочет проверить чттото
через рут сетифкаты он не берет не читает все файлы каждый из которых соэдержит рут сертифкат. он читает один файл который содержит все рут сертифкаты
которые есть на компе. так вот вот эта команда "update-ca-trust extract"
она берет все рут файлы сертифкатов и слепливает из них один файл - бандл.
файл называется 

    /etc/ca-certificates/extracted/tls-ca-bundle.pem
    также на него есть два симлинка

    # stat /etc/ssl/certs/ca-bundle.crt 
        File: /etc/ssl/certs/ca-bundle.crt -> ../../ca-certificates/extracted/tls-ca-bundle.pem
    # stat /etc/ssl/certs/ca-certificates.crt 
        File: /etc/ssl/certs/ca-certificates.crt -> ../../ca-certificates/extracted/tls-ca-bundle.pem
  

вот какой то из этих файлов а по факту tls-ca-bundle.pem и читает
ктото кто помогает прогаммамм проверять сертифкаты на подлинность 
на основе рут сертификатов хранящихся на компе

как я уже написал  - я сгенеириоовал рут сертифкат. и скопировал его 
в папку 

    /etc/ca-certificates/trust-source/anchors/myCA.pem

и запустил команду 


        # update-ca-trust extract

и она присоединила этот сертификат к бандлу 

        /etc/ca-certificates/extracted/tls-ca-bundle.pem


как взять бандл и просмотреть все сертиифкаты внутри. вот так

    $ openssl crl2pkcs7 -nocrl -certfile ca-certificates.crt  | openssl pkcs7 -print_certs -text -noout > /tmp/1.txt


потому что если взять бандл файл и начать его смотреть как просто 
файл с одним сертификатом 

    $ openssl x509 -noout -text -in cert2.pem

то оно покажет только вверхний сертификат. 
потому что бандл это просто линейно содеиенные обычные файлы сертификатов.

свежедобавленный сертификат ксатти будет самым верхним.

даже рут сертификат добавить на комп это уже ебала. как
все сейчас свяаанное с компом.


вот еще способ как просмотреть все сертиикаты в бандле
и найти свой

$ awk -v cmd='openssl x509 -noout -subject' '/BEGIN/{close(cmd)};{print | cmd}' < /etc/ssl/certs/ca-certificates.crt | grep ROOT-CER

subject=C=SS, ST=Area51, L=NY, O=Internet Space Ltd, OU=Dep31, CN=ROOT-CERT-SS, emailAddress=no@no.no

я ксатти сделал 

   $ strace -e openat curl https://...

и там четко видно что идет открытие файла

openat(AT_FDCWD, "/etc/ssl/certs/ca-certificates.crt", O_RDONLY) = 6

тоесть именно с этого пути какая функция ищет бандл с рут сертификатами.


но это еще не конец. можно еще вот так посмотреть список сертфикатов в бандле.
причем это самый по мне клевый способ


$ echo | openssl s_client -proxy 172.16.10.11:2080 -showcerts -servername youtube.com -connect youtube.com:443 2>/dev/null | openssl storeutl  -noout -text -r -certs /proc/self/fd/0


что меня поразило это то что команда openssl она может АБСОЛЮТНО СПОКОЙНО  читать текстовый 
поток который содержит МУСОР и полезный текст и openssl абслютно спокойно отбрасывает мусор
из потока и выбирает только нужный контент! это поразительно!
тоесть на второй openssl storeutl влетает поток примерно такой 

CONNECTED(00000003)
---
Certificate chain
 0 s:CN=*.google.com
   i:C=US, O=Google Trust Services, CN=WR2
   a:PKEY: id-ecPublicKey, 256 (bit); sigalg: RSA-SHA256
   v:NotBefore: Oct 21 08:36:57 2024 GMT; NotAfter: Jan 13 08:36:56 2025 GMT
-----BEGIN CERTIFICATE-----
MIIOCjCCDPKgAwIBAgIQQagVgnQLepAJtGHnFyDA9DANBgkqhkiG9w0BAQsFADA7
MQswCQYDVQQGEwJVUzEeMBwGA1UEChMVR29vZ2xlIFRydXN0IFNlcnZpY2VzMQww
CgYDVQQDEwNXUjIwHhcNMjQxMDIxMDgzNjU3WhcNMjUwMTEzMDgzNjU2WjAXMRUw
EwYDVQQDDAwqLmdvb2dsZS5jb20wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAARD
7W/bU6abojd0puaRMYsiXqZjXddRl8yW2qlTpw+HOHg3bA183UxWTtZx+yeHSVQE
3k0jMGvR7C4B3FY+n92ao4IL9zCCC/MwDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQM
MAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFIz1r4xlXzoNaxGY
xiGq0aGZuvJpMB8GA1UdIwQYMBaAFN4bHu15FdQ+NyTDIbvsNDltQrIwMFgGCCsG

так вот сначала идет мусор 

CONNECTED(00000003)
---
Certificate chain
 0 s:CN=*.google.com
   i:C=US, O=Google Trust Services, CN=WR2
   a:PKEY: id-ecPublicKey, 256 (bit); sigalg: RSA-SHA256
   v:NotBefore: Oct 21 08:36:57 2024 GMT; NotAfter: Jan 13 08:36:56 2025 GMT


который наш openss спокойно всасывает и откидывает.
и только потом идет полезный контент 

-----BEGIN CERTIFICATE-----
MIIOCjCCDPKgAwIBAgIQQagVgnQLepAJtGHnFyDA9DANBgkqhkiG9w0BAQsFADA7
MQswCQYDVQQGEwJVUzEeMBwGA1UEChMVR29vZ2xlIFRydXN0IFNlcnZpY2VzMQww
CgYDVQQDEwNXUjIwHhcNMjQxMDIxMDgzNjU3WhcNMjUwMTEzMDgzNjU2WjAXMRUw
...
...


это просто удвительно поразительно!


итак с этим наконец разобрались.

сертификат рутовый добавлялся в "хранилище сертификатов" для того чтобы
браузер мог через этот рутовый сертиификат проверить достоверность
обычного сертификта который мы выпустим на основе этого рутового
сертфиката и подсунем в жинкс. вот почему такая ебала. 

теперь начинаем генерировать сертифкат для сайта example.ex на основе нашего
рут сертификата.
    генерируем приватный ключ
    
    $ openssl genrsa -out example.ex.key 2048


    гененируем запрос CSR 

    $ openssl req -new -key example.ex.key -out example.ex.csr

теперь создаем файл с доп конфигурацией а именно с Alternative Name


    $ cat ext.cnf

authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = example.ex
IP.1 = 192.168.10.10


ВАЖНО!> я думал что броузер смотрит прежде всего чему равно поле CN из Subject
,в данном случае CN=example.ex ( я его ввел когда CSR команду запустил. )
а уже если CN несвпадает с доменом который мы вбили в браузере то бразуер
начинает ссмотреть в "Alternative Name" полях которые я указал в ext.cnf
НО!! толи теперь бразуер вобще не смотрит в CN поле. толи он в него не смотрит
если есть поле "Alternative Name" но факт есть факт. если я стучусь на 
example.ex и оттуда мне прилетает сертификат у которого CN=example.ex 
но при этом example.ex остуствует в "Alternative Name" но барзуер пошлет
нас НАХУЙ.   в частности curl напишет

    ssl no alternative certificate subject name matches target hostname

и только когда  я создал сертиификат который имеет и CN=example.ex
и имеет example.ex в секции "Alternative Name" то curl и браузер
перестали ругаться. охуеть. <!ВАЖНО 


теперь генерируем наш сертфиикат для example.ex  подписанный 
корневым рут сертификатом

$ openssl x509 -req -in example.ex.csr   -CA myCA.pem -CAkey myCA.key  -CAcreateserial -out example.ex.pem -days 325  -sha256 -extfile ext.cnf

значит в запросе я указал наш файл запроса

    -in example.ex.csr

рут сертификат и ключ от него

    -CA myCA.pem -CAkey myCA.key

файл с экстра настройками

    -sha256 -extfile ext.cnf


и вот мы получили наш сертификат. его свойства

$ openssl x509 -noout -text -in   example.ex.pem  | grep -E 
"Issuer|Alternative|CN" -A1

        Issuer: C=SS, ST=Area51, L=NY, O=Internet Space Ltd, OU=Dep31, CN=ROOT-CERT-SS, emailAddress=no@no.no

        Subject: C=SS, ST=State, L=city, O=orgname, OU=Unit, CN=example.ex

            X509v3 Subject Alternative Name: 
                DNS:example.ex, IP Address:192.168.10.10


итак видно что сертификат выпустил Issuer  ROOT-CERT-SS
и что CN у сертификата это 

        example.ex   <===

и Alternative Name

        example.ex   <===
        192.168.10.10


еше раз почекну незнаю почему но домен по которму мы стучимся на сайт
должен быть и в основной скции CN и в доп секции "Alternative Name"

ЕЩЕ ВАЖНО!>
вот видно что я  в Alternative Name вставил также IP адрес.
окахыается он нахуй ненужен. я раньше думал что браузер сравнивает тот 
домен который мы ему заказали с  доменом из сертиифката. но также я думал
что браузер ищет в сертификате IP и сравнивает его с dest_IP в свойствах
сокета своего процесса чреез который прилетел пакет. ОКАХЗЫВАЕТСЯ ЭТО НИХУЯ
НЕТАК. никто никакой IP нигде не ищет и ни счем не сравнивает. браузеру
абсолютно похйу с какйого ip прилетел пакет. есть ли какая то связь у этого
ip с доменом илли нет. браузеру все равно. я посмотрел сертификата у гугул
и яху. у них в сертификате нет тоже никаких IP. так что IP неимеет 
никакого значения в TLS, HTTPS. это вот раньше когда может быть на сайт
шли через IP то тогда детвильно брайзер ищет в серфтикате IP. 
те времена прошли. так что так что в совр сертфикатах никакх IP нету
и браузер ннеделает никакой проверки на счет с какого IP прилетел пакет. 
для всей этой TLS+HTTP темы самое главное что если мы дали в браузер домен
example.ex значит должен прилееть серфтикиаат у котрого внутри есть 
example.ex и сертификат подсписан достоверным рут сертификатом. все. 
поэтому между реальным клиентом и сервером можно менять и айпи адреса
и порты tcp. это все похуй. главное чтобы пакет долетел до сервера илл клиента.
если до серера то чтобы попал в жинкс. и главное не менять TLS пейлоад который
был изнаально засунут внутрь на клиенте либо сервере. TLS пакет не меняейтся.
а все что ниже можете менять хоть обосраться. невлияет. поэтому можно 
без всяких прблем зайти через TLS на домен example.ex который сидит 
на твоем же ноутбуке на 127.0.0.1 или на удаленном хосте 8.8.8.8 
вобще похуй. главное чтобы там где сиодит жинкс он отдал нам
сертфикат в котором example.ex это все что нужно браузеру. с какого айпи
отдали сертификат вобще насрать. 
это еще одно важное открыватие. так что ip адреса вобще нненужны в серити
фикате.  а если они там есть нам на них похуй. точнее браузеру.
<ЕЩЕ ВАЖНО!

использовал вот эту хорошую статью 

    https://deliciousbrains.com/ssl-certificate-authority-for-local-https-development/


теперь можно вставит сертификат в nginx



 listen 443 ssl;
 ssl_certificate_key /etc/nginx/certs/example.ex/example.ex.key;    = путь к притваному ключу
 ssl_certificate /etc/nginx/certs/example.ex/example.ex.pem;      = путь к сертификату

ксатти права на файлы сертификатов root.root r--,--,-- 
тоесть их может чиаттать только рут. и это прокатывает.

проверить конфиг жинкса

    # nginx -t

может вылезти ошибка

[warn] could not build optimal types_hash, you should increase either types_hash_max_size: 1024 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size


чтобы ее убрать надо вставить

http {
        ...
        ...
    types_hash_max_size                4096;


еще раз проверяем конфиг

    # nginx -t

уже недолжно быть никаких ошибок



| firefox

оказывается что файрфокс неиспользует установленные на компе линуксе сертификаты которые
лежат в папке 

    /etc/ca-certificates

а файрфокс использует только сертификаты которые устаолвены внутри файрфокса.
через графическую часть их можно посмтреть 

   settings - набираем в поиске certificate - view certificates

там можно посмтреть все root CA которые файрфокс имеет в своих недрах. обновляются они незнаю
как может с обновлением версии самого файрфокса.

поэтому обновление сертифкатов на линукск в /etc/ca-certificates бесполезно для файрфкоса



| s_client


значит я уже знаю как через openssl сделать конект к сайту

        $ openssl s_client -connect ifconfig.co:443


так вот эта прога юзает центральную папку с сертификатами 

    /etc/ca-certificates

и положим там нет нужного рут сертификата. так вот положим у нас есть папка с рут 
сертификатами отдельно. и мы хотим для openssl указать эту альтернативную папку 
но прикол в том что если там просто папка с сертификатами то для опенссл нужно ее приготовить
дело вот  в чем - нужно чтобы имя файла которое содержит сертификат имело особый вид
а именно имя должно иметь вид хэша от строки Subject из сертификата. обьясняю
вот имеем сертификат  и смотрим его

        $ openssl x509 -text -noout -in    ./Alpha.crt

        Issuer: OU=GlobalSign Root CA - R6, O=GlobalSign, CN=GlobalSign
        Subject: C=BE, O=GlobalSign nv-sa, CN=GlobalSign GCC R6 AlphaSSL CA 2023
        ...
        ...
        X509v3 Subject Key Identifier: 
                BD:05:B7:F3:8A:93:3C:73:CB:79:FA:0F:85:12:A1:77:96:18:91:74
        X509v3 Authority Key Identifier: 
                AE:6C:05:A3:93:13:E2:A2:E7:E2:D7:1C:D6:C7:F0:7F:C8:67:53:A0


строка Issuer - указывать кто выдал сертификат
строка Subject - указывает кому выдал сертификат

вот эта строка
        X509v3 Subject Key Identifier: 
                BD:05:B7:F3:8A:93:3C:73:CB:79:FA:0F:85:12:A1:77:96:18:91:74
она указывает хэш данного сертификата. 

вот эта строка
        X509v3 Authority Key Identifier: 
                AE:6C:05:A3:93:13:E2:A2:E7:E2:D7:1C:D6:C7:F0:7F:C8:67:53:A0
она указывает хеш сертиификата того кто выдал данный сертификат

так вот нужно вычислить хэш от строки "Subject:"
        Subject: C=BE, O=GlobalSign nv-sa, CN=GlobalSign GCC R6 AlphaSSL CA 2023
делается это специально командой

        $ openssl x509 -in Alpha.crt  -noout -subject_hash  
        4e79b064

и далее нужно создать в папке с сертификатом симлинк на сертификат с таким вот именем

        $ ln -s ./Alpha.crt  4e79b064.0

тоесть либо надо файл с сертификатом переименовать либо создать симлинк и имя должно
иметь вид
    
        "хэш" + ".0" 

в данном случае

        4e79b064.0

и только вот так специально подготовив папку можно тогда ее указать для openssl
через опцию -CApath

    $ openssl s_client -connect  youtube.com:443 -proxy 172.16.10.11:2080  -CApath /home/noroot/temp/test/

ксатти опция -proxy там в мане явно написано что это будет конект через HTTP прокси протокол
через CONNECT метод. все понятно все прекарасно!


хочу заметить что опция -connect  youtube.com:443 в ней нужно указать только доменное
имя но не ip адрес. нихуя с ип адресом не сработает


а вот еще прикол в том что можно не запускать руками вычисление хэша через опцию -subject_hash 
для кажого сертификтаата и запуска ln а заюзать команду 

        $ c_rehash /папка

и она сама повычисляет хэши для сертификатом и посоздает симлинки!
удобно!






а вот еще то что эта прога покзывает спмсок корневых сертификатов 

  $ openssl s_client -connect  youtube.com:443 -proxy 172.16.10.11:2080   | head -n 20
Connecting to 172.16.10.11
depth=2 C=US, O=Google Trust Services LLC, CN=GTS Root R1
verify return:1
depth=1 C=US, O=Google Trust Services, CN=WR2
verify return:1
depth=0 CN=*.google.com
verify return:1
CONNECTED(00000003)
---
Certificate chain
 0 s:CN=*.google.com
   i:C=US, O=Google Trust Services, CN=WR2
   a:PKEY: id-ecPublicKey, 256 (bit); sigalg: RSA-SHA256
   v:NotBefore: Oct 21 08:36:57 2024 GMT; NotAfter: Jan 13 08:36:56 2025 GMT
 1 s:C=US, O=Google Trust Services, CN=WR2
   i:C=US, O=Google Trust Services LLC, CN=GTS Root R1
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
   v:NotBefore: Dec 13 09:00:00 2023 GMT; NotAfter: Feb 20 14:00:00 2029 GMT
 2 s:C=US, O=Google Trust Services LLC, CN=GTS Root R1
   i:C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
   a:PKEY: rsaEncryption, 4096 (bit); sigalg: RSA-SHA256
   v:NotBefore: Jun 19 00:00:42 2020 GMT; NotAfter: Jan 28 00:00:42 2028 GMT
---
Server certificate



вроде как в манжаро можно обновить корнеывые сертифкаты для папка /etc/ca-certificates
через

        # update-ca-trust

а вот как можно взять файл с сертификатом что этот файл полностью валиден

    $ openssl verify Alpha.crt 
    Alpha.crt: OK
 
