| c
| nullable array

посмтрим например на execve()



   int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);


значит что вот это за тип данных

		char *const _Nullable argv[]


или чуть менее пафоса

		char *const _Nullable p[]

константность можно убрать это неважно

		char *Nullable p[]


так вот это значит что массив поинтеров. каждый из которых указывает на char.
но это еще не все. есть еще одно требование требуют чтобы посленим элементом этого массива
был элемент который равен NULL. что это значит. у нас каждый элемент это поинтер , тоесть
значение этого элемента это адрес. но последний элемент это поинтер который в качестве значение
в качестве адреса содержит NULL

например 

   элемент1  элемент2  элемент3
   1234       6789      NULL


щас покажу на примере

$ cat 383.c
#include <stddef.h>
#include <stdio.h>


int main() {


  char a    = 0x10;
  char *p_a = &a;

  char b    = 0x20;
  char *p_b = &b;

  char *p_c = NULL;

  char *ar[3] = { p_a, p_b, p_c };


  int i = 0;
  while (ar[i] != NULL) {
    printf ("i = %i, ar[%i] = 0x%hhX \n",   i,i,*(ar[i]) );
    i++;

  }; //END while

  return 0;
};




значит мы создаем обычную перменную и поинтер на нее

  char a    = 0x10;
  char *p_a = &a;

птом еще один обычную перменную и поинтер на нее

  char b    = 0x20;
  char *p_b = &b;


потом мы создаем поинтер в котором вместо адреса находится NULL

  char *p_c = NULL;

NULL это макрос. и он его занчение по факту равно 0. но мы используем имеено  NULL
хотя по факту это 0. таким образом этот поинтер указает якобы на тело перенной которое
хранисят начиная с адреса 0.  понятно  что у процесса нет досутпа к адресу 0.  припопопытке
туда слазить ядро выдась SEG FAULT


далее саммое главное я создаю массив из поинтеров. в этмо массиве три элемента

  char *ar[3] = { p_a, p_b, p_c };

тоесть в нем один адрес, второй адрес, третий адрес(который 0 илли NULL)

так вот вот такой массив и называется NULLABLE pointer array.
получается явного синткстиса для такого массива нет. тоесть слева у нас стоит якобы обычный
масив из поинтеров. тоесть слева у нас нет такого что 

  char nullable *ar[3] = { p_a, p_b, p_c };

такой хрени нет
вот такая вот запись в мануале от execve

   char *const _Nullable argv[]

это чисто хрень для документации и аннтации если такое попытасттся использоать в тексте на си
то комиятор выдаст ошибку

также замечу важную вещь когда у нас nullable pointer массив то у нас NULL или 0 это 
именно значение адреса равно этому а не значение пременной на которую поинтер указывает.
тоесть это 

   p = NULL

а не 

   *p = NULL


ну и вот этот кусок


  int i = 0;
  while (ar[i] != NULL) {
    printf ("i = %i, ar[%i] = 0x%hhX \n",   i,i,*(ar[i]) );
    i++;

  }; //END while




здесь мы приабавляем индекс i   и проверяем то что элемент массива тоесть поинтер то есть
адрес который в нем хранится (а не тело перменной на котору он укзывает) неравно NULL.
как толко у нас ar[i] == NULL то мы понимаем что мы дошли до последнего элемента ммаасива. мы
дошли до его конца. такой тип массива нам дает то что если мы его передаем в качетве аргумента
в фнукцию то нам ненужно предвать доп аругментом размер масива потоу что функция может нащупамть
конец массива сама.

замечу то что NULL можно подтавлять только в поинтер как значение

  int *p  = NULL;

либо вот так

  int *p[1] = { NULL };

кстати еще скажу то что напомню что если мы передаем имя массива в функцию то на самом деле
компиялтор на лету создает поинтер который укзывает на первый эелмент этого массива 
и он именно этот поинтер подставляет при взыоыве фнукции. тоесть вот скажем у нас ест
прототип фнкции у которой указан массив как аргумент


   int func1( char * arr[]);


тогда если мы соделаем вот так

  char a  = 0x10;
  char *mas[2] = { &a, NULL };

тогда я могу взывать фнкцию вот так

  func1( mas );

но тоггда комипилятор будет делат маниацляции на лету. 
а можно сделать вот так

 
  char **p1 = &(mas[0]);
  func1(p1);

в обоих случаях 

  func1( mas );
  func1(p1);

у нас по факту подсталяется одно и тоже. толко в во втором случае то как оно есть на самом
деле а в первом случае это такоая фигня котоаря требует от комилятора делать замену налету!
поэтмоу нстоящий прототипп фукнции выгляди не так 


   int func1( char * arr[]);


а вот ттак

   int func1( char **p);


вот полная прогамма

$ cat 384.c
#include <stddef.h>


    int func1( char * arr[]){
      return 0;
    };



int main() {


    char a  = 0x10;
    char *mas[2] = { &a, NULL };
    char **p1 = &(mas[0]);
    func1(p1);


return 0;

};


как четко видно  я передаю в функцию тип char** поэтмоу тип указанный в протоиппе фунции
char * arr[] это всего навсего фикция.






теперь когда в целом стало понятно про то что такое и зачем и как выглядит NULLABLE массив
то посмотрим на execve


   int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);


у нее три аругмента.

первый аргумент это поинтер на стринг. (строго говоря на char но пофакту там всгде стринг).
в нем мы передаем путь на фс  к бинанику котоырй хотим запусить 

второй аргумент это нуллабл массив из поинтерров где кажый поинтер указывает на char 
а по факту на стринг.. где последний поинтер имеет адрес NULL

каждый стринг это аргумент который мы хотим передать фнкции. размер массива мы не укыазаем
потому что функция может его найти сама. аргумент может иметь в себе любой набор байтов. 
абсолютно любой! главное тербвение чтобы в конце аргумента был байт 0х00
ксатти баш нам не позволит преедать аргумент который состоит только из 0x00

вот пример 


 $ echo `echo -en "\x00"`
bash: warning: command substitution: ignored null byte in input

тоесть по факту мы пытаемся заупстить echo 0x00  и согласно ИИ это запрешено в posix
и abi.
и баш нам пишет что мы используем недостпустимый аргумент.


смотри что самое интересное
что хотя баш ругается что аргумент состоит только из нулл байта. но 
при этом он все равно запускает тот процесс который мы ему указали. 
он просто исключает имнно этот аргумент из запуска. и все

$ strace -e execve sleep  echo -en "\x00"
bash: warning: command substitution: ignored null byte in input
execve("/usr/bin/sleep", ["sleep"], 0x7ffc396933d0 /* 60 vars */) = 0

вот и все.

или еще пример 

 $ echo "123" echo -en "\x00"
bash: warning: command substitution: ignored null byte in input
123

теость мы запутили echp с двумя аругметами 123 и 0x00 
и bash он просто выкинул второй корявый аргумент оставил первый и запустил процесс.
а ято думал что вообще запускать прокцееас не будет!


тоесть увидв что  у нас недоспустимый аргумент баш тем не менее
запускет процессс просто без этого "плохого аргумента".


итак 
первый аргумент у execve

		const char *pathname

это просто стринг. ну по факту это путь на бинарнику на фс.

второй аргмунет

		 char *const _Nullable argv[]		

это масив из поинтеров. где последний поинтер имеет адрес NULL
и каждый поинтер указывает на стринг.
а стринг это любо набой байтов где последний эемент равен 0x00 и ест еще хоят бы 1 эдемент
до этого который не равен 0x00

размер этого масива мы не пердаем потому что фунцяи может сама его найти
по своему смыслу это массив из аругментов


третий аргумент


	char *const _Nullable envp[]);


это массив аналоигчны пруддыыудещму. по свой струтктуре. это тоже нуллабл массив из поинтенторов
на char.
но тут по соглащению содержтся не аргументы а перменные. каоая пеоменнная это стринг  
но где то внутри еще должен быть знак "=" в той кодировке которой приедрживается программа
который мы взываем. 

    vasya=213813031 и плюс на конце 0x00

сам execve не будет проверять коректность этго массива. ему важно 
только то что передваемый тип даных это поинтер.  

разер этого массива мы тожене предаем в фнуцию так как фуняия может сама найти его размер.


если мы вспомним какие прамтеры можно получить от ОС в main()
то это три параметра

   main ( int argc, char **argv, char ***envp){}


вот с этими данным нет проблем char **argv, char ***envp  мы их передаем сами при запуске 
execver() а откуда берется вот эта перменная int argc? ее занчение которое равно числу 
элеменов в массиве argv.  ведь мы же при вызове execve не передаем этот параметр. так вот
ответ такой что ядро самоп после запуаска execve сканирует наш argv массив. находит его размер
и сама уже создает эту пемерременную и подставляет ее как первую. вототкуда она берется!


таким макаром я здесь рассказал что такое nullable pointer array.
и подрбности про execve() где он плотно исползуется


далее я привожу прграмму . 


 $ cat 382.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char **argv, char** envp){

    char success = 0x0;
    char *p_arg1;
    char *p1;


    if (argc !=2 ){
      printf("ОШИБКА: нужен ровно один аргумент\n");
      return 1;
    } else {
             p_arg1 = *(argv+1);
      };



    size_t len_arg1 = strlen(p_arg1);


    int len_b1 = len_arg1+1;
    char *b1 = malloc(len_b1);

    memcpy(b1, p_arg1, len_arg1);
    *(b1+(len_arg1) ) = '=';


    char *temp = malloc(len_b1);
    memset(temp,0x0, len_b1);


    int i=0;
    int j=0;
    int ret1;
    while( *(envp+i) != NULL ) {
    
        p1 = *(envp+i);

        for(int j=0; j<(len_b1); j++){
            if( *(p1+j) == 0x0 ){
               break;
                     }
           memcpy(temp+j, p1+j, 1);


        }//END for;



        if (strncmp(b1, temp, len_b1) == 0){
            success = 0x1;
            break;
                    } 
        else {
                memset(temp,0x0, len_b1);
                i++;

                    } 



                    }//END while;



      if (success == 0x1){
           printf("переменная '%s' найдена.\n%s\n",  argv[1], p1);
      } else {
           printf("переменная %s НЕ найдена \n", argv[1]);
      }
      



      char *p3 = getenv(argv[1]);
      if (p3 != NULL) {
          printf ("я нашел эту же переменную через getenv(), вот она %s = %s  \n",    argv[1], p3);
      }
      else {
          printf ("я НЕ нашел эту же переменную через getenv() \n");
      
      }




      free(b1);
      free(temp);
      return 0;
}



в чем ее суть. 

мы ее запускаем и в качевте аргумента вставляем имя перпенной. 
она сама руками сканирует массив env[] и там ее ишет. если находит то печатает.
а в конце я делаю тоже самое. я ищу эту перменную через стандартную фунцию getenv от libc

прмиер 


	$ ./382.exe LC_IDENTIFICATION	
	переменная 'LC_IDENTIFICATION' найдена.
	LC_IDENTIFICATION=ru_RU.UTF-8
	я нашел эту же переменную через getenv(), вот она LC_IDENTIFICATION = ru_RU.UTF-8  

	$ ./382.exe vasya
	переменная vasya НЕ найдена 
	я НЕ нашел эту же переменную через getenv() 



и вот видно что если я нахожу руками то и нахожу через getenv . или ненахожу обоими сопособами.
в целом приколная задача.



