| c
| nullable array

посмтрим например на execve()



   int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);


значит что вот это за тип данных

		char *const _Nullable argv[]


или чуть менее пафоса

		char *const _Nullable p[]

константность можно убрать это неважно

		char *Nullable p[]


так вот это значит что массив поинтеров. каждый из которых указывает на char.
но это еще не все. есть еще одно требование требуют чтобы посленим элементом этого массива
был элемент который равен NULL. что это значит. у нас каждый элемент это поинтер , тоесть
значение этого элемента это адрес. но последний элемент это поинтер который в качестве значение
в качестве адреса содержит NULL

например 

   элемент1  элемент2  элемент3
   1234       6789      NULL


щас покажу на примере

$ cat 383.c
#include <stddef.h>
#include <stdio.h>


int main() {


  char a    = 0x10;
  char *p_a = &a;

  char b    = 0x20;
  char *p_b = &b;

  char *p_c = NULL;

  char *ar[3] = { p_a, p_b, p_c };


  int i = 0;
  while (ar[i] != NULL) {
    printf ("i = %i, ar[%i] = 0x%hhX \n",   i,i,*(ar[i]) );
    i++;

  }; //END while

  return 0;
};




значит мы создаем обычную перменную и поинтер на нее

  char a    = 0x10;
  char *p_a = &a;

птом еще один обычную перменную и поинтер на нее

  char b    = 0x20;
  char *p_b = &b;


потом мы создаем поинтер в котором вместо адреса находится NULL

  char *p_c = NULL;

NULL это макрос. и он его занчение по факту равно 0. но мы используем имеено  NULL
хотя по факту это 0. таким образом этот поинтер указает якобы на тело перенной которое
хранисят начиная с адреса 0.  понятно  что у процесса нет досутпа к адресу 0.  припопопытке
туда слазить ядро выдась SEG FAULT


далее саммое главное я создаю массив из поинтеров. в этмо массиве три элемента

  char *ar[3] = { p_a, p_b, p_c };

тоесть в нем один адрес, второй адрес, третий адрес(который 0 илли NULL)

так вот вот такой массив и называется NULLABLE pointer array.
получается явного синткстиса для такого массива нет. тоесть слева у нас стоит якобы обычный
масив из поинтеров. тоесть слева у нас нет такого что 

  char nullable *ar[3] = { p_a, p_b, p_c };

такой хрени нет
вот такая вот запись в мануале от execve

   char *const _Nullable argv[]

это чисто хрень для документации и аннтации если такое попытасттся использоать в тексте на си
то комиятор выдаст ошибку

также замечу важную вещь когда у нас nullable pointer массив то у нас NULL или 0 это 
именно значение адреса равно этому а не значение пременной на которую поинтер указывает.
тоесть это 

   p = NULL

а не 

   *p = NULL


ну и вот этот кусок


  int i = 0;
  while (ar[i] != NULL) {
    printf ("i = %i, ar[%i] = 0x%hhX \n",   i,i,*(ar[i]) );
    i++;

  }; //END while




здесь мы приабавляем индекс i   и проверяем то что элемент массива тоесть поинтер то есть
адрес который в нем хранится (а не тело перменной на котору он укзывает) неравно NULL.
как толко у нас ar[i] == NULL то мы понимаем что мы дошли до последнего элемента ммаасива. мы
дошли до его конца. такой тип массива нам дает то что если мы его передаем в качетве аргумента
в фнукцию то нам ненужно предвать доп аругментом размер масива потоу что функция может нащупамть
конец массива сама.

замечу то что NULL можно подтавлять только в поинтер как значение

  int *p  = NULL;

либо вот так

  int *p[1] = { NULL };

кстати еще скажу то что напомню что если мы передаем имя массива в функцию то на самом деле
компиялтор на лету создает поинтер который укзывает на первый эелмент этого массива 
и он именно этот поинтер подставляет при взыоыве фнукции. тоесть вот скажем у нас ест
прототип фнкции у которой указан массив как аргумент


   int func1( char * arr[]);


тогда если мы соделаем вот так

  char a  = 0x10;
  char *mas[2] = { &a, NULL };

тогда я могу взывать фнкцию вот так

  func1( mas );

но тоггда комипилятор будет делат маниацляции на лету. 
а можно сделать вот так

 
  char **p1 = &(mas[0]);
  func1(p1);

в обоих случаях 

  func1( mas );
  func1(p1);

у нас по факту подсталяется одно и тоже. толко в во втором случае то как оно есть на самом
деле а в первом случае это такоая фигня котоаря требует от комилятора делать замену налету!
поэтмоу нстоящий прототипп фукнции выгляди не так 


   int func1( char * arr[]);


а вот ттак

   int func1( char **p);


вот полная прогамма

$ cat 384.c
#include <stddef.h>


    int func1( char * arr[]){
      return 0;
    };



int main() {


    char a  = 0x10;
    char *mas[2] = { &a, NULL };
    char **p1 = &(mas[0]);
    func1(p1);


return 0;

};


как четко видно  я передаю в функцию тип char** поэтмоу тип указанный в протоиппе фунции
char * arr[] это всего навсего фикция.






теперь когда в целом стало понятно про то что такое и зачем и как выглядит NULLABLE массив
то посмотрим на execve


   int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);


у нее три аругмента.

первый аргумент это поинтер на стринг. (строго говоря на char но пофакту там всгде стринг).
в нем мы передаем путь на фс  к бинанику котоырй хотим запусить 

второй аргумент это нуллабл массив из поинтерров где кажый поинтер указывает на char 
а по факту на стринг.. где последний поинтер имеет адрес NULL

каждый стринг это аргумент который мы хотим передать фнкции. размер массива мы не укыазаем
потому что функция может его найти сама. аргумент может иметь в себе любой набор байтов. 
абсолютно любой! главное тербвение чтобы в конце аргумента был байт 0х00
ксатти баш нам не позволит преедать аргумент который состоит только из 0x00

вот пример 


 $ echo `echo -en "\x00"`
bash: warning: command substitution: ignored null byte in input

тоесть по факту мы пытаемся заупстить echo 0x00  и согласно ИИ это запрешено в posix
и abi.
и баш нам пишет что мы используем недостпустимый аргумент.


смотри что самое интересное
что хотя баш ругается что аргумент состоит только из нулл байта. но 
при этом он все равно запускает тот процесс который мы ему указали. 
он просто исключает имнно этот аргумент из запуска. и все

$ strace -e execve sleep  echo -en "\x00"
bash: warning: command substitution: ignored null byte in input
execve("/usr/bin/sleep", ["sleep"], 0x7ffc396933d0 /* 60 vars */) = 0

вот и все.

или еще пример 

 $ echo "123" echo -en "\x00"
bash: warning: command substitution: ignored null byte in input
123

теость мы запутили echp с двумя аругметами 123 и 0x00 
и bash он просто выкинул второй корявый аргумент оставил первый и запустил процесс.
а ято думал что вообще запускать прокцееас не будет!


тоесть увидв что  у нас недоспустимый аргумент баш тем не менее
запускет процессс просто без этого "плохого аргумента".


итак 
первый аргумент у execve

		const char *pathname

это просто стринг. ну по факту это путь на бинарнику на фс.

второй аргмунет

		 char *const _Nullable argv[]		

это масив из поинтеров. где последний поинтер имеет адрес NULL
и каждый поинтер указывает на стринг.
а стринг это любо набой байтов где последний эемент равен 0x00 и ест еще хоят бы 1 эдемент
до этого который не равен 0x00

размер этого масива мы не пердаем потому что фунцяи может сама его найти
по своему смыслу это массив из аругментов


третий аргумент


	char *const _Nullable envp[]);


это массив аналоигчны пруддыыудещму. по свой струтктуре. это тоже нуллабл массив из поинтенторов
на char.
но тут по соглащению содержтся не аргументы а перменные. каоая пеоменнная это стринг  
но где то внутри еще должен быть знак "=" в той кодировке которой приедрживается программа
который мы взываем. 

    vasya=213813031 и плюс на конце 0x00

сам execve не будет проверять коректность этго массива. ему важно 
только то что передваемый тип даных это поинтер.  

разер этого массива мы тожене предаем в фнуцию так как фуняия может сама найти его размер.


если мы вспомним какие прамтеры можно получить от ОС в main()
то это три параметра

   main ( int argc, char **argv, char ***envp){}


вот с этими данным нет проблем char **argv, char ***envp  мы их передаем сами при запуске 
execver() а откуда берется вот эта перменная int argc? ее занчение которое равно числу 
элеменов в массиве argv.  ведь мы же при вызове execve не передаем этот параметр. так вот
ответ такой что ядро самоп после запуаска execve сканирует наш argv массив. находит его размер
и сама уже создает эту пемерременную и подставляет ее как первую. вототкуда она берется!


таким макаром я здесь рассказал что такое nullable pointer array.
и подрбности про execve() где он плотно исползуется


далее я привожу прграмму . 


 $ cat 382.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(int argc, char **argv, char** envp){

    char success = 0x0;
    char *p_arg1;
    char *p1;


    if (argc !=2 ){
      printf("ОШИБКА: нужен ровно один аргумент\n");
      return 1;
    } else {
             p_arg1 = *(argv+1);
      };



    size_t len_arg1 = strlen(p_arg1);


    int len_b1 = len_arg1+1;
    char *b1 = malloc(len_b1);

    memcpy(b1, p_arg1, len_arg1);
    *(b1+(len_arg1) ) = '=';


    char *temp = malloc(len_b1);
    memset(temp,0x0, len_b1);


    int i=0;
    int j=0;
    int ret1;
    while( *(envp+i) != NULL ) {
    
        p1 = *(envp+i);

        for(int j=0; j<(len_b1); j++){
            if( *(p1+j) == 0x0 ){
               break;
                     }
           memcpy(temp+j, p1+j, 1);


        }//END for;



        if (strncmp(b1, temp, len_b1) == 0){
            success = 0x1;
            break;
                    } 
        else {
                memset(temp,0x0, len_b1);
                i++;

                    } 



                    }//END while;



      if (success == 0x1){
           printf("переменная '%s' найдена.\n%s\n",  argv[1], p1);
      } else {
           printf("переменная %s НЕ найдена \n", argv[1]);
      }
      



      char *p3 = getenv(argv[1]);
      if (p3 != NULL) {
          printf ("я нашел эту же переменную через getenv(), вот она %s = %s  \n",    argv[1], p3);
      }
      else {
          printf ("я НЕ нашел эту же переменную через getenv() \n");
      
      }




      free(b1);
      free(temp);
      return 0;
}



в чем ее суть. 

мы ее запускаем и в качевте аргумента вставляем имя перпенной. 
она сама руками сканирует массив env[] и там ее ишет. если находит то печатает.
а в конце я делаю тоже самое. я ищу эту перменную через стандартную фунцию getenv от libc

прмиер 


	$ ./382.exe LC_IDENTIFICATION	
	переменная 'LC_IDENTIFICATION' найдена.
	LC_IDENTIFICATION=ru_RU.UTF-8
	я нашел эту же переменную через getenv(), вот она LC_IDENTIFICATION = ru_RU.UTF-8  

	$ ./382.exe vasya
	переменная vasya НЕ найдена 
	я НЕ нашел эту же переменную через getenv() 



и вот видно что если я нахожу руками то и нахожу через getenv . или ненахожу обоими сопособами.
в целом приколная задача.


еще раз вот что скажу - на счет поинтером и NULL. значение NULL его можно присвотть только 
поинтеру. это такой МАКРОС который запишет в поинтер число 0. тоесть адрес 0.

 char *p  =  NULL

физически в поинтер запмыcываеается 0x00

если у нас массив поинтеров то его элементами могут поинтеры которые равны NULL

    char a = 0x10;
    char *p[3] = { NULL,  &a, NULL };

NULL это единственное значение которое можно засунуть в поинтер руками. 


а вот еще один момент. 

    char *p[3] = { "vasya",  "petya",  "kuku" };

у нас слева стоит тип "массив поинтеров" , причем поинтеры на char. это значит что справа каждый элемент это должен быть поинтер, поинтер на char. а что мы видим справа? а это очередной
прикол от компилятора. просто эта строка вот чему эквивлаентна

    char p1[6] = "vasya";
    char p2[6] = "petya";
    char p3[5] =  "kuku";
    char *p_p1 = &p1[0];
    char *p_p2 = &p2[0];
    char *p_p3 = &p3[0];

    char *p[3] = { p_p1,  p_p2,  p_p3 };


просто компилятор создает массивы налету. потом создает налету поинтеры которые указают 
на первый элемент каждого массива . и в массив вставлятся конечно никакие не стринги.
а поинтеры на первый элемент каждого стринга.
хотя ии сказал что это почти так вот его слова:

Компилятор создаёт строковые литералы в памяти программы (в сегменте данных, обычно в неизменяемой области). Эти строковые литералы не являются обычными массивами, которые можно модифицировать. Они являются константными (поэтому в современном C правильно использовать const char* для их хранения). Затем массив p заполняется указателями на первые символы этих строковых литералов.
Грубо говоря, эта строка соответствует следующей логике:

const char  a1[] = "vasya"; 
const char  a2[] = "petya"; 
const char  a3[] = "kuku";  


char *p[3];
p[0] = (char *) &a1[0];    // Указатели на первые символы строк
p[1] = (char *) &a2[0];
p[2] = (char *) &a3[0];

еще разница кода от ии  и моего состоит в том что мой код он создает три массива тело
котороых будет лежать в стеке. а тела массивов в примере от ии они будут лежать в неизменяемой
области в памяти. ну это понятно  это из за const хрени. 

кстати согласно ии нет никакой разницы между типами

  const char*  a[3]
  char const*  a[3]

по всей видимости такие записи нужнр расшифрвовывать справа налево - это массив поинтеров
на char который константа.

как сказал ии то цитирую - В языке C порядок расположения const относительно типа не имеет значения, потому что модификатор const относится к тому, что находится сразу слева от него. Если слева ничего нет, то он относится к тому, что справа.

тоесть вот в этом примере 

  const char*  a[3]

сам поинтер (адрес) можно менять. но то тело на которое он указывает должно быть по своему
типа char+константа

а вот как раз пример про другое

        char *const ptr

начнем дешифровыать справа налево - это постоянный поинтер который укаывзает на char.
тоесть сам поинтер константа (адрес константа) , но то тело на которое он укзывает это char 
и это не коснтантса. 

  const char a = 0x10;
  const char* p_a =  &a;

  const char b = 0x10;
   p_a = &b;

тоесть сам поинтер можно менять. а вот тело перменной на которую он укзывается менятьнельзя.

теперь смотрим на

        char a = 0x10;
        char *const p_a = &a; // инициализируем понинтер
        char b = 0x20;
        p_a = &b  ; // тут будет ошика. нам нелья менять поинтер!

а вот сами a и ли b можно мнять
        a = 0x30


а вот еще прикол

    const char *const ptr

это получается и поинтер коснатанта и укзвает он на константу.
вот так инциализируем 

  const char *const ptr = "hello";

а потом уже ничего менять нельзя ни поинтер ни тело переменной

а вот еще прикол

        char *const a[3];

дешифруем справа налево. это массив из 3 желментом где каджый это поинтер который константа
и укзывает он на char


а вотеще можно так


  char const a1[6] = "hello";
  char const a2[6] = "world";

  char *const p[2] = { a1, a2  };


хотя клмплиятор малек ругаетяс
386.c:9:24: warning: initialization discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]
    9 |   char *const p[2] = { a1, a2  };
      |                        ^~
386.c:9:28: warning: initialization discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]
    9 |   char *const p[2] = { a1, a2  };


он автоматом вместо массива a1 всатвляет поинтер на первый желмент массива.


еще момент.
в execve() указано   char *const _Nullable argv[]
вопрос это что такой синтаксис есть в си? ответ нет. такого синтаксиса нет.
это такое обозначение чисто для нотации а формально синтаксиса такого в си нет.



еще момент.
на счет NULL 
напоминаю что это макрос. это закодиорваное значение для поитеров и ознает адрес 0.
его можно присвавать только поинтерам.
а теперь кусок кода


char *p[1] = { NULL };
if (p[0] == NULL) {  // Проверяем значение p[0]
    printf("gotcha\n");
}

int i = 0;
while (*p[i]) {
...
i++;
}



он неверный. потому что вот эта строка

while (*p[i]) {

она вызовет ошибку при i=0

while (*p[0]) {

потому что у нас p[0]=NULL тоесть p[0]=0  и припопытке сделать дереференс для *p[0]
конечно мы получим SEG FAULT потому что мы хотели посмтреть что лежит по адресу 0. ядро нас
пошлет нахуй.
вместо этого нужно заменить на строку

while (p[i]) {


поэтому вот такой код

 & 䖩  $ cat 389.c
#include <stdio.h>



int main() {
   
    char a = 0x10;
    char *p[2] = { &a, NULL };

    int i = 0;
    while (p[i] != NULL) {
    printf ("i = %i, p[%i] != NULL \n",    i, i);
    i++;
    } 


return 0;
}


тоесть вот она верная строка
    while (p[i] != NULL) {



вот еще код ошибочный

char *p[1] = { NULL };
if (*p[0] == NULL ){
printf ("gotcha\n");
}

у меня p[0] = NULL   (а  не *p[0] = NULL ) 
поэтому когда я пишу *p[0] я пытаюсь прочитать занчение из адреса NULL тоест из адреса 0
и олучаем от ядра SEG FAULT


поэтому вот так будет верно

char *p[1] = { NULL };

if (p[0] == NULL ){
printf ("gotcha\n");
}


следущий моемент вот так писать ошиька

    char a= NULL 

потому что NULL может быть присвое только поинтеры.поэтому можно только вот так

    char *a= NULL 

вот кстаи как опредяется МАКРОС NULL

#define NULL ((void *)0)

по аналогии получсется что я могу запросто вот такое в прогаимме писать

    char *a = ((void *)1234);

другое дело что обращение по этому адресу вызовет SEG FAULT


а вот поленое обьяснение на счет execve()
ВОПРОС:
слушай вопрос про 

 int execve(const char *pathname, char *const _Nullable argv[], char *const _Nullable envp[]);

у нас три аргумента.
однако с точки зрения процесса который мы таким образом заускаем то 
там будет такой аргумент как argc который новому процессу сообщает о 
том сколько элементов внутри масива argv. вопрос как ядро определяет сколкьо элементов содержится в массиве argv ? 
ОТВЕТ:
Хороший вопрос! Ядро определяет количество элементов в массиве `argv` и передаёт его в новом процессе через переменную `argc` следующим образом:

1. **Передача аргументов в стек нового процесса**:  
   Когда вызывается `execve`, массивы `argv` и `envp` передаются ядру. Они должны быть **нулевыми терминальными массивами** — это означает, что последний элемент в `argv` и `envp` равен `NULL`. Это требование установлено соглашениями о вызовах (ABI — Application Binary Interface).

2. **Подсчёт элементов ядром**:  
   Когда ядро готовит новый процесс, оно анализирует массив `argv`, начиная с первого элемента (указателя на строку) и продолжая до тех пор, пока не встретит `NULL`. Количество ненулевых элементов и становится значением `argc`. То же самое происходит и для `envp`, но оно отдельно передаётся как массив окружения.

3. **Передача в пользовательский код**:  
   После того как ядро завершает создание нового процесса, оно размещает `argc`, `argv` и `envp` в стеке нового процесса (обычно в сегменте стека процесса, в порядке: `argc`, указатель на `argv[]`, указатель на `envp[]`). Это позволяет новому процессу при старте получить правильное значение `argc` и массив `argv`.

### Пример в памяти:
Если вы вызываете `execve` так:
```c
char *args[] = {"ls", "-l", "-a", NULL};
char *env[] = {"PATH=/usr/bin", NULL};
execve("/bin/ls", args, env);
```

В памяти ядро размещает:
- `argc = 3` (три элемента в `args`, не считая `NULL`).
- `argv[] = {"ls", "-l", "-a", NULL}`.
- `envp[] = {"PATH=/usr/bin", NULL}`.

Ядро определяет `argc` именно путём подсчёта элементов в массиве `argv` до `NULL`.

### Примечание:
Если массив `argv` или `envp` не является корректно нулевым терминальным (например, вы забыли добавить `NULL` в конец массива), поведение функции `execve` будет неопределённым, и это может привести к ошибкам или сбоям. Ядро не сможет корректно определить длину массива, что нарушит работу процесса.

Таким образом, корректное заполнение `argv` и `envp` с `NULL` в конце — ответственность разработчика.

