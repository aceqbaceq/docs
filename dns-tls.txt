| DNS

значит важно то что DNS сервер он не сбраывает в отве на реквест обратно IP адрес.
это непонимание полное. мы ему шлем запрос а он в ответ прсилыает некую ЗАПИСЬ!
напрмиер запись имеет вид


                mail.ru.        8   IN  A   217.69.139.200

важно понять что с ДНС серера прилетает ЗАПИСЬ ане ip адрес!
записи бывают разные по своему внутреннему содержанию! не во всех есть ip адрес.!
поэтому с днс вцелом неприлетает IP! а прилетает запись. 
а далее на компе резолвер читает эту запсь и ищет внутри нее то что хочет 
найти. в данном случае он будет искать внутри ip адрес. который уже отдаст программе.
тоесть ip адрес выдаст программе не днс сервер. а резолвер (nss dns или nss resolvectl)
из той ЗАПИСИ которая прилетела с днс сервера. 

я это рспиывают в потому что в голове эти суки мне засунуули усатновку что с днс серввера
прилетает в ответе ip адерс. а прилетает не ip адрес а запись. а уже внтри нее иногда 
встречается ip адерс который еще оттуда нужно вытащить. а есть записи где нет никакой ip 
адреса например записи вида CNAME






| DNS
| dig
| TLS
| HTTPS


далее
значит когда то был простой лоховской DNS через порт 53 UDP\TCP
он не имел никакой защиты

после додумали DNSSEC  он работает через тот же 53 TCP\UDP 
он вот что делает - он коненту который в наш комп прилетает прилепляет цифровую подпись.
поэтому обеспечивается достоверность данных и целостность данных. но не конфиденциальности.
тоесть щифрования. если мы гоорим про цифрую подпись то значит на нашем компе должен оказаться
публичный ключ dns серверера. причем он должен быть достоверным. как и откуда он берется
на нашем компе непонятно. 

следущий шаг это DNS over TLS. это уже получается днс с использованием шифрования. 
работает через 853/TCP

еще есть DHS over HTTPS (сокращенно DOH) тоесть снаружи у нас TLS а внутри HTTP . работает через 443/TCP
соотвественнно этот способ тоже обеспечивает шифрование.

спрашивается зачем городили эти две системы. ведь они обе шифруют. а ответ такой что 
одну сситему делали одни а вторую другие. вот и все. 

DOH имеет тот плюс что провайдеры могут нахер все закрыть. а HTTPS останется. и через него
можно получать достоверный DNS

самые известные пулбличные DNS сервера это гугловские 8.8.8.8
и cloudflare 1.1.1.1

клаудфдеер трясет себя пяткой в грудь что у них быстрее они откликаются. 


теперь как это все на практике.

во первых где в линуксе настраивется  адрес dns сервера к которому обращается так называемый
dns клиент или резолвер. обычно щас резоллвером в линуксе явялется 

	systemd-resolved

ВАЖНО: далее будет идти длинное повествование про эту прогу. фишка в том программа
ебануто запутанная. и мало кто в ней разбирается. я разобрался.так вот здесь 
я напишу самое главное - как внутри systemd-resolved (далее sr) происходит выбор 
какой dns сервер будет обрабатывать (резолвить) запрос от клиента. этот момент 
просто ужасно необьяснен и описан. а я разобрался. 
значит статус sr можно посмотреть чего его клиента resolvectl
и вывод выглядит примерно вот так


# resolvectl status
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain: ru   <=============

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: +DefaultRoute   <=====  -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: com    <============


вывод состоит из двух секкций Global секция и  пер-интерфейс секция (секция индиивидуа
льная для интерфейса).

так вот центральный вопрос - через какой днс сервер полетит обрабаотка реквеста
через 172.16.10.1 или 8.8.8.8 а может сразу через два.
так вот это зависит от трех параметров а именно "DNS Domain:" в глобальной секции,
такого же параметра в секции интерфейса. и параметра  "DefaultRoute"
все эти параметры я выделил.  
параметр DefaultRoute может быть либо +DefaultRoute  либо -DefaultRoute,
параметр  DNS Domain: может быть разным. но самые важные его значения это 

  DNS Domain: пусто
  DNS Domain: ~.
  DNS Domain: com ru ~.co.uk

первое значение это просто ничего, пусто.  второе значение это вайлдкард означает 
все домены , любой домен.  эти два значения очень важные. 
третье значение как раз самое обычное. просто перечислены домены com либо ru либо co.uk
домен может быть с тильдой или без тильды. разницы почти нет. домен с тильдой означает
( я ниже буду подробно расказывать) что если в sr прилетел однословный запрос то 
он будет модифицирован путем добавления домена обозначенного тильдой. если  у нас 
запрос хотя бы двухсловный типа vasya.com то  что домен с тильдой что без тильды 
без разницы. так вот как sr принимает решение через какой днс сервер обрабатывать 
реквест. 
в целом алгоритм работает так: у нас в реквесте есть домен. наример vasya.com 
тогда ищутся все секции в которых будет этот домен. или часть домена. тоесть 
ищуттся все секции где 

      DNS Domain: com 
или 
      DNS Domain: ~com 

и после этого  на ВСЕ днс сервера этих секций шлется этот днс запрос. если таких 
секций две то на два днс сервера.  вот пример такой конйигурации


Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain com  <=========

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: +DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: com   <==========


запрос об vasya.com будет направлен и на 172.16.10.1 и на 8.8.8.8

если нет ни одной секции подходящей под домен запроса то тогда запрос будет 
направлен через днс сервер глобальной секции ( в этом случае похер чему в этой секции
будет равен DNS Domain) и через все днс серера тех секций где есть флаг +DefaultRoute

например 

Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain net  <=========

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: +DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: net  <==========

запрос vasya.com не подпадает ни под одну секцию в плане домена. тогда запрос 
будет направлен на 172.16.10.1 потому что она в глобал секции. и через 8.8.8.8
потому что в этой секции есть флаг +DefaultRoute
если бы флаг был -DefaultRoute то через эту секцию запрос бы не пошел.
вот в целом и весь закон. если мы хотим чтобы секция подходила для любого домена 
то ставим   "DNS Domain: ~."  если мы хотим чтобы секция не подходила ни для 
одного домена ставим "DNS Domain: пусто"
если у нас есть несколько секций в которых в обоих есть совпдаение для домена в 
реквесте то выбирается та скция где совпдаение более полное.
пример

# resolvectl 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain ~.

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: com


соотвесвтенно я напраовляю запрос vasya.com он подходит для обоих 
секций но секция с com подходит сильнее. я обоьянсю. 
домена vasya.com на самом деле имеет имя   vasya.com.  (точка на конце)
если мы беерем шаблон ~. , то тильду мы отбрасывем ибо она служмт для подставновки 
в однословные реквесты. поэтому мы получаем шаблон "." сравниываем совпдаение
"." и "vasya.com." получаем совпадение только в одном символе.
а тепер сраниванеим щаблон "com" и "vasya.com." получаем совпадение три символа.
поэтмоу запрос пойдет через секцию enp0s3 поэтому запрос пойдет через 8.8.8.8
. также я хочу сказать что если мы поставим в секции интерфейса параметр
  
    "DNS Domain: пусто"

это не значит что через днс этой секции запросы не пойдут


# resolvectl 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain 

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: com


хотя в глобальной секции у нас стоит шаблон что ни один щаблон домена не подходит
но, как я ужесказал что если будет запрос который явным образом не подпадает под
какуюто секцию то тогда запрос будет напралвен на днс глобальной секции внезависимости
от того чему там равен "DNS Domain:"   плюс как я уже скаал зарпрос будет направлен 
также на интерфейс у которого +DefaultRoute так будет в следущем примерер


# resolvectl 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain vasya 

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: +DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: 

делаем запрос на yahoo.com
запрос не подпадает ни под одну секцию. поэтому он будет нпарвлен на 172.16.10.1
потому что это днс из глобальной секции. и также будет запрос на правлен на 8.8.8.8
потому что в этой секции выставлен +DefaultRoute
еще раз повторю что такая логика дейтвует толко после того как выяснилось что
наш реквест явным образом неопдодпаадет ни под одну секцию. тогда и начинает действовать
"план Б" , в частности поиск параметра  +DefaultRoute идет только в случае 
плана Б.

также я хочу скзаать что очень деблильно сделано то что секции те которые кроме 
глобальной они якобы привызаны к интерфейсам. я считаю это охуенный мислид и конфьюз.
я считаю что интерфейсы тут нихуя ни причем. я считаю что каждая секция это просто
набор из днс сервера и домена 

Section 1:
    DNS Servers: 2.2.2.2
    DNS Domain: com

и завсиимисоти от условий что я описал выше на днс из данной секции либо будет направлен
запрос или нет. причем тут нахуй интерфейс?!?!!?! запрос на тот или иной днс 
сервер будет направлен через тот интерфейс который лучше всего подходит исходя из 
таблицы маршрутизации. поэтому то в какой секции интерфейса мы пропишем днс сервер
неважно. важно то как этот днс сервер роуттится через таблицу маршутизации. исходя из 
этого будет выбран интерфейс через который будет направлен запрос.
поэтому в этом плане создатели sr долбоебы. только все запутали.
в целом это и есть самое главное и самое сложное про sr

ДАЛЕЕ уже подробнное его исследовани, однако как я сказал там есть и ошибочные
выводы. потому что текст который ниже он писался раньше. поэтому там есть ошибочные
выводы:



и его конфиг лежит в 

	/etc/systemd/resolved.conf


и там вот такие строки

DNS=1.1.1.1
DNSSEC=on
DNSOverTLS=yes

чтобы натройки вступлив в силу

	# systemctl restart systemd-resolved
 
как можно проверить текущий статус
какой там адрес dns сервера щас установлен в системе

	$ resolvectl
Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
    resolv.conf mode: foreign
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1




далее в манжаро ставим dig вот так

	# pacman -Sy bind



далее через dig можно потестировать запросы через TLS, или через DOH


значит гугловский 8.8.8.8 поддерживает ответы через TLS.
тестируем это 

$ dig  @8.8.8.8    +tls   mail.ru

;; ANSWER SECTION:
mail.ru.		10	IN	A	217.69.139.200

;; Query time: 286 msec
;; SERVER: 8.8.8.8#853(8.8.8.8) (TLS)

мы видим что запрос идет к 8.8.8.8 и порт 853
также видно что запрос выполнен за 286 msec


клаудфлееровский 1.1.1.1 тоже поддеживает ответы через TLS

$ dig  @1.1.1.1    +tls  mail.ru


;; ANSWER SECTION:
mail.ru.		30	IN	A	217.69.139.200

;; Query time: 226 msec
;; SERVER: 1.1.1.1#853(1.1.1.1) (TLS)

мы видим что запрос идет через 1.1.1.1 и порт 853 
и что ответ за 226 msec

эти же серверра поддерживают ответ через HTTPS

 $ dig  @8.8.8.8   +https   mail.ru
;; ANSWER SECTION:
mail.ru.		20	IN	A	94.100.180.200

;; Query time: 233 msec
;; SERVER: 8.8.8.8#443(8.8.8.8) (HTTPS)



  $ dig  @1.1.1.1    +https   mail.ru
;; ANSWER SECTION:
mail.ru.		32	IN	A	217.69.139.202

;; Query time: 223 msec
;; SERVER: 1.1.1.1#443(1.1.1.1) (HTTPS)


в обоих случая что 853\TCP TLS что 443\TCP HTTPS по факту исопльзуется TLS 
просто в одном случае за ним стоит HTTP а во втором случае не стоит. так вот вот
TLS он использует сертификаты. в сертиифкате есть строка "Subject" в которой указан CN
также в сертификате есть строка "Alternative Name" где тоже указан CN 
так вот TLS он проверяет чтобы IP\DNS в запросе и CN в сертификате от сервера совпадали


если мы вводим вот так

  $ dig  @1.1.1.1    +tls   mail.ru
или вот так
  $ dig  @1.1.1.1    +https   mail.ru


то наш диг он проверяет есть ли в сертификате CN=1.1.1.1 
можно задать руками какой CN будет искать в сертификате диг

	$ dig  @1.1.1.1  +tls    +tls-host=1.1.1.1             mail.ru

тоесть мы попросили выполнить dns over tls через 853 порт и IP=1.1.1.1 и  при получении сертиифкта
проверить что в нем CN=1.1.1.1


    $ dig  @1.1.1.1  +https  +tls-host=cloudflare-dns.com  mail.ru

здесь мы попросили выполнить dns over HTTPS что по факту DNS over TLS over HTTP  через 443 порт и при получении сертиифкта проверить что в нем CN=cloudflare-dns.com


а вот щас запросим чтобы CN был такой котрого нет в сертификате
	$ dig  @1.1.1.1  +https +tls-host=vasya.com  mail.ru
	;; TLS peer certificate verification for 1.1.1.1#443 failed: hostname mismatch

если мы ключ +tls-host=cloudflare-dns.com   неуказаываем то диг ищет CN равный тому
что мы указали в @1.1.1.1


кстати systemd-resolved  не поддерживает DNS over HTTPS (DoH) а только как я уже
сказал подерживает DNS over TLS (DoT) вот ссылка
	https://askubuntu.com/questions/1506255/systemd-resolved-dns-over-https-doh-with-custom-port-and-domain

зато dnsmasq поддерживает DoH

еще раз приведу конфиг как задать в systemd-resolved адреса dns серверов и как
активировать DoT

 # cat /etc/systemd/resolved.conf
[Resolve]
DNS=1.1.1.1
FallbackDNS=8.8.4.4

DNSSEC=on
DNSOverTLS=yes

насколько я понимаю DNSSEC это "расширение" к обычному DNS запросу через 53-ий порт.
и оно я думаю ненужно если мы юзаем DoT но все равно пусть будет.

вопрос а как посмотреть какой сертификат показывает удаленный dns сервер когдмы
мы на него идем по TLS\HTTPS

вот так можно приконектиться

	$ openssl s_client -connect 8.8.8.8:853

Connecting to 8.8.8.8
CONNECTED(00000003)
Can't use SSL_get_servername
depth=2 C=US, O=Google Trust Services LLC, CN=GTS Root R1
verify return:1
depth=1 C=US, O=Google Trust Services, CN=WR2
verify return:1
depth=0 CN=dns.google
verify return:1
---
Certificate chain
 0 s:CN=dns.google
   i:C=US, O=Google Trust Services, CN=WR2
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
   v:NotBefore: Aug  5 07:20:11 2024 GMT; NotAfter: Oct 28 07:20:10 2024 GMT
 1 s:C=US, O=Google Trust Services, CN=WR2
   i:C=US, O=Google Trust Services LLC, CN=GTS Root R1
   a:PKEY: rsaEncryption, 2048 (bit); sigalg: RSA-SHA256
   v:NotBefore: Dec 13 09:00:00 2023 GMT; NotAfter: Feb 20 14:00:00 2029 GMT
 2 s:C=US, O=Google Trust Services LLC, CN=GTS Root R1
   i:C=BE, O=GlobalSign nv-sa, OU=Root CA, CN=GlobalSign Root CA
   a:PKEY: rsaEncryption, 4096 (bit); sigalg: RSA-SHA256
   v:NotBefore: Jun 19 00:00:42 2020 GMT; NotAfter: Jan 28 00:00:42 2028 GMT
---
Server certificate
-----BEGIN CERTIFICATE-----
MIIFsjCCBJqgAwIBAgIQTH4h1szUaTQJK6eEMZyoVjANBgkqhkiG9w0BAQsFADA7
MQswCQYDVQQGEwJVUzEeMBwGA1UEChMVR29vZ2xlIFRydXN0IFNlcnZpY2VzMQww
CgYDVQQDEwNXUjIwHhcNMjQwODA1MDcyMDExWhcNMjQxMDI4MDcyMDEwWjAVMRMw
EQYDVQQDEwpkbnMuZ29vZ2xlMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
AQEArWIzO6kEW2guWJZ/c81G+a4mLFxkZDyOx3sxt5GoIqnzW3fFoWcMgmzPbocE
t6Os3zPAj44kVo/g7EWLPtgrodjsX5aKe0+lEzhqYe1yCNdbjzW6suJiU3dWStJc
WX7GmVgy8hhYX69uMdyFlvm7iFyiJ+X56TSh7lodS5JqY7D/6BaoZrPQ0QWc4P/u
y/eMcVLLn33r2NUJ2OzRZQ1QKdN+Ow2vSQSm63LVEWEpWtPtT0qIrIlalZAsqaBR
YLutjUqfjjAnpd5k9D4elnvHonWYGC5YC26Sv1Cw8ulbEvs3blMEDp/8SAw445nU
NxR9zpJoY+IlJoz3js4VcIQn6wIDAQABo4IC1jCCAtIwDgYDVR0PAQH/BAQDAgWg
MBMGA1UdJQQMMAoGCCsGAQUFBwMBMAwGA1UdEwEB/wQCMAAwHQYDVR0OBBYEFDkm
9Wmetpahz62CCrXYDbP/UnzlMB8GA1UdIwQYMBaAFN4bHu15FdQ+NyTDIbvsNDlt
QrIwMFgGCCsGAQUFBwEBBEwwSjAhBggrBgEFBQcwAYYVaHR0cDovL28ucGtpLmdv
b2cvd3IyMCUGCCsGAQUFBzAChhlodHRwOi8vaS5wa2kuZ29vZy93cjIuY3J0MIGs
BgNVHREEgaQwgaGCCmRucy5nb29nbGWCDmRucy5nb29nbGUuY29tghAqLmRucy5n
b29nbGUuY29tggs4ODg4Lmdvb2dsZYIQZG5zNjQuZG5zLmdvb2dsZYcECAgICIcE
CAgEBIcQIAFIYEhgAAAAAAAAAACIiIcQIAFIYEhgAAAAAAAAAACIRIcQIAFIYEhg
AAAAAAAAAABkZIcQIAFIYEhgAAAAAAAAAAAAZDATBgNVHSAEDDAKMAgGBmeBDAEC
ATA2BgNVHR8ELzAtMCugKaAnhiVodHRwOi8vYy5wa2kuZ29vZy93cjIvOVVWYk4w
dzVFNlkuY3JsMIIBBQYKKwYBBAHWeQIEAgSB9gSB8wDxAHcA7s3QZNXbGs7FXLed
tM0TojKHRny87N7DUUhZRnEftZsAAAGRIZ/pBwAABAMASDBGAiEA9MEVJnQZVuiS
jXcAAKphsDNPwfHPjbmrEpds2SeOlrQCIQDGlzRZ4JwoWFz6/NngjoyKwE3n2Ick
ANRnJqCoXTK4ZwB2AD8XS0/XIkdYlB1lHIS+DRLtkDd/H4Vq68G/KIXs+GRuAAAB
kSGf6SEAAAQDAEcwRQIhANp4abXSPu0P1CXYUkTDma8jMfm87UDIo872JLa1pU8D
AiBcs6Lp0pLoCxcE1dodB4dMfokzGULzQTluEC1ZaSm0BTANBgkqhkiG9w0BAQsF
AAOCAQEAHhGtSpdL5cggiAJhb4CrXB54QR9Q7KAdbpWJcWjegb7rBkkBEEr2JORJ
lO+RkZg2cE7eB1IwfgHhWj8XyFzueCvIRghET6cdNyI7Nc/U0UNzmPy0e0bI5XIf
lXok85hsAimPRMkCfkdrdO+B6Xt/I2JVaRPPcbe9Q87X9/JVWuQbH+LrmaOokNyb
CPyujl9eSWuIVzpJHm5z2m1aQXZb+X1yivQwn6Ik2Wct7poz3Ueb3VwjiTJxm4IY
5gxA092LYw5rvPfjZRBrs4r3OILuefqurN+2StNIhiGz/7ldrPA3+JNQWpLZYyGU
GNScfKLl2B7kJUx2KyWJwgCQLNNkMA==
-----END CERTIFICATE-----
subject=CN=dns.google
issuer=C=US, O=Google Trust Services, CN=WR2


копируем сертификат в тектовый файл. и его 
содержимое можно вот так посмотреть

$ openssl x509 -noout -text -in cert2.pem  | grep Subject
        Subject: CN=dns.google

$ openssl x509 -noout -text -in cert2.pem  | grep "Alternative Name" -A1
            X509v3 Subject Alternative Name: 
                DNS:dns.google, DNS:dns.google.com, DNS:*.dns.google.com, DNS:8888.google, DNS:dns64.dns.google, IP Address:8.8.8.8, IP Address:8.8.4.4, IP Address:2001:4860:4860:0:0:0:0:8888, IP Address:2001:4860:4860:0:0:0:0:8844, IP Address:2001:4860:4860:0:0:0:0:6464, IP Address:2001:4860:4860:0:0:0:0:64


таким образом в сертификате есть CN=8.8.8.8 и CN=dns.google  

а вот что в сертификате с 1.1.1.1

$ openssl x509 -noout -text -in cert.pem  | grep Subject
CN=cloudflare-dns.com

$ openssl x509 -noout -text -in cert.pem  | grep "Alternative Name" -A1
            X509v3 Subject Alternative Name: 
                DNS:cloudflare-dns.com, DNS:*.cloudflare-dns.com, DNS:one.one.one.one, IP Address:1.0.0.1, IP Address:1.1.1.1, IP Address:162.159.36.1, IP Address:162.159.46.1, IP Address:2606:4700:4700:0:0:0:0:1001, IP Address:2606:4700:4700:0:0:0:0:1111, IP Address:2606:4700:4700:0:0:0:0:64, IP Address:2606:4700:4700:0:0:0:0:6400


тоесть в нем есть CN=1.1.1.1 и CN=one.one.one.one и CN=cloudflare-dns.com

поэтому скажем к 1.1.1.1 можно обращаться вот такими любыми способами

  dig  -4 @one.one.one.one  +tls   mail.ru
  dig  -4 @1.1.1.1  +tls   mail.ru

а вот такое почемуто несрабатывает

$ dig  -4 @cloudflare-dns.com  +tls   mail.ru
;; Connection to 104.16.249.249#853(104.16.249.249) for mail.ru failed: timed out.
;; no servers could be reached


вобщем получается в DNS можно ходить как лох через 53\UDP\TCP
можно ходить чуть лучше через DNSSEC
и можно ходить козырно через TLS или через HTTPS
systemd-resolved поддержтвает все кроме HTTPS но его поддеожвает dnsmasq

насчет клайдфлееровский DNS сервреров они написали вот тут
	https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/

насчет гугловский dNS серверов они напиали вот тут
	https://en.wikipedia.org/wiki/Google_Public_DNS


есть вопрос а что быстрее отвевет DoT или DoH и еще вопрос что быстрее 1.1.1.1 или 8.8.8.8
у меня работает все через впн поэтому что так что так по 200-250 msec
но если зайти на сервер где нет впн и сразу в интерне он смотрит то DoH работает в 
миллион раз быстрее. щас покажу


$ dig -4 @8.8.8.8        +tls  ya.ru  | grep msec
;; Query time: 8 msec


$ dig -4 @1.1.1.1        +tls  ya.ru  | grep msec
;; Query time: 44 msec




$ dig -4 @8.8.8.8        +https  ya.ru  | grep msec
;; Query time: 4 msec


$ dig -4 @1.1.1.1        +https  ya.ru  | grep msec
;; Query time: 4 msec


видно что через tls выигрывает гугл. на https одинаково.
и видно что https работает существенно быстрее через tls
дело не втом что tls плохой и меленный. в htts там же тоже tls есть просто 
в "tls методе" там же за ним стоит какйото протокол по которому днс клиент и сервер
разговаривают (tls то это просто шифрвание) и видимо он медленный. а в https методе
там вместо медленного протокола исползуется http который видимо более быстрый
мненанотубке переодить с DoT на DoH нет смысла потому что все равно все запросы идут
через впн и в итоге выходит по 200-250мс. во вторых systemd-resolved не поддерживает DoH
а пееренастраиваться на dnsmasq я нехочу.

чтоб на компе гарантировать что мы раобоем по DoT надо подстрахоываться через iptables.
чтобы там все было запорещено кроме того что разрешено. и там у меня 
вот такое стоит для DNS

:INPUT DROP [39:4773]
:FORWARD DROP [0:0]
:OUTPUT DROP [2603:186514]

-A OUTPUT  -p tcp -m tcp --dport 853 -o tun+  -j ACCEPT

==

| DNSSEC

скажу сразу это тема это очередной ПИЗДЕЦ. и как обычно потому что описано
это все МЕГА ПЛОХО.

через какой порт и протокол оно работает. оно не имеет спец порта оно работает 
через тот порт через котороый работает текущий dns клиент. щас оьбясню.

обычно по деолфту днс клиент ломиться на днс сервер через 53/TCP UDP
если мы юзаем dns over tls то клиент ломиться на сервер через 853/TCP
если мы юзаем dns over https то клиент ломиться на сервер через 443/TCP

так вот если при этом любом режим актииован DNSSEC то он ломиться ровно также по тем
же портам. тоесть DNSSEC он не относится  к тому что мы как то по другому вплане 
порта  ломимся на днс сервер. dnssec относится к тому что мы ПОСЛЕ этого начинаем 
говрить с днс сервером несколько по другому. тоесть dnssec это изменение то как 
мы гооворим с днс серервром уже после того ккак мы с ним наладили конект. поэтому у dnssec
нету "особого" порта. 
далее прикол состоит в том что даже от того что мы актививаролвали режим 
запросов к внешним dns серверам чере dnssec на
нашем ноутбуке это не значит что мы получим ответ реально через dnssec. 

далее начинается зона сплошных непонятных моментов. во первых днс клиент может работать
в двух режимах - в одном режиме он делает запрос к днс-А серверу и тот обычно пишет
что он нихуя не знает и шлет нас на другой днс-Б сервер. тогда мы делаем запрос к днс-Б
серверу тот тоже ничего незнает и шлет нас на днс-Ц сервер. тогда мы делаем запрос 
на днс-Ц сервер. и так несколько раз. этот режим называется итеративный. тоест 
нам например нужно найти host3.vasya.com мы обращаемся на корневой днс сервер и 
говорим а где сидит днс сервер который .com зону обслуживает. он нам шлет.
мы идем туда и спрашиваем а где сидит днс который обслжуивает зону vasya.com
он нас шлет на следущий днс сервер который обслуживает зону vasya.com мы у него спрашиваем
а кто обслуживает host03.vasya.com и наконец блядь мы попали на сервер который обслуживает
зону host03.vasya.com 
естть другой режим - мы шлем запрос на ближайший днс сервер. он делаею всю грузню 
работу а нам возвращает ответ. это рекурсивный режим работы нашего днс клиента.
если я ничего не путаю.  насколько я понимаю 100% всех днс клиентов на домащних компах
и обычных серврерах работают в рекурсивном режиме. 

так я вовзвраащаюсь к днссек. как эта хуета  в целом работает. на днс сервере который
отвечает за зону размещается несколько записей. ктото должен эти записи скачать. 
и проанализировать. а после этого еще скачать записи и головных доменов вплоть до корневого
сервера. и проанализировава куче записей придти к выводу достоверные записи нам предоставил
самый первый сервер или нет. так вот что я не понимаю - все это анализирует наш днс клиент
на ноубтуке или за это все отвечает днс серевер на который мы обращаемся а нам уже только
выдается конечный ответ ? непонятно. 

значит как плюс минус работает dnnsec:
 пусть  у нас есть зона. и мы в ней хозяева. пусть это зона cloudflare.com
 в этой зоне есть записи которые имеют один и тот же вид , например 

 $ dig -4 A  cloudflare.com   +multi
;; ANSWER SECTION:
cloudflare.com.		70 IN A	104.16.132.229
cloudflare.com.		70 IN A	104.16.133.229


значит в данном случае в зоне есть домен cloudflare.com который имеет две записи.
говря другими словами в зоне есть несколько записей у которых один и тот же домен.
так вот такие записи называются RRset. c этого начинается днссек. мы берем группу 
таких записей ( ксатти запись в днс называется RR - resource record) и для этой кучи
записей создаем цифровую подпись. и эту цифровую подпись записываем в эту же зону
в запись типа  RRSIG (RR Signature - Resource Record set Signature)
еще раз эта цифровая подпись создается не для отдельного RR а сразу для кучи RR.
где куча состоит из записей в которых одного называние домена. в вданном случае это  
RRset состоит из
	cloudflare.com.		70 IN A	104.16.132.229
	cloudflare.com.		70 IN A	104.16.133.229

спрашивается как посмотреть цифровую подпись RRSIG для этого RRset ?
ответ - надо запросить RRset указав что мы хоотим использовать при запросе dnssec
и днс сервер нам выдаст и RRset и его RRSIG

$ dig -4 @8.8.8.8  A  cloudflare.com   +multi +dnssec

;; ANSWER SECTION:
cloudflare.com.		274 IN A 104.16.133.229
cloudflare.com.		274 IN A 104.16.132.229
cloudflare.com.		274 IN RRSIG A 13 2 300 (
				20240902224340 20240831204340 34505 cloudflare.com.
				Iv0mqaRfjHvCN0aWkpePZeWEbPqrnVJcSS3NqIpx+Hgi
				8kREH7LZVZYCtkV6KjOBsXWndBBt/h2KNhwG7n9tUA== )


значит я через dig запросил у 8.8.8.8  запись тип A с именем cloudflare.com чеерез dnnsec
а оно в ответ смотрит есть для эттих записей RRSIG запись

ключ +multi говорит для диг  чтобы длинные записи он не обрезал типа того.

соотвесвтенно если мы просим у диг отдать нам днс имя через dnssec и он не показывает
при этом RRSIG то 100% что мы получили домен и ip не через dnssec. почему . по разным
причинам. например у этой зоны не установлен днссек. кстати чтобы получить запись 
cloudflare.com через dnssec то нужно либо обратиться к днс серверу который отвечает 
за эту зону либо к серверу который за нас проделает грязную работу - узнает какой днс
сервер отвечает за зону cloudflare.com сделает к нему запрос через днссек и вернет нам
ответ. значит как узнать какой сервер отвечает за зону clooudflare.com 

$ dig   +trace cloudflare.com

значит как работает этот запрос. без ключа +trace диг делает запрос к тому
днс серерву который прописан в /etc/resolv.conf и ждет от него конечного ответа. 
а если мы юзаем ключ +trace то диг делает запрос к днс прописанному в /etc/resolv.conf
об том какой адрес у корневых днс серверов. получает ответ. потом диг делает запрс
к одному из корневых серверов и спрашивает какие днс отвечает за зону .com
получает ответ. потом он у одного из них спршаивыает какой север отвечает за зону
cloudflare.сom получает ответ. и у одного из них спрашивывает какой ip имеет домен 
cloudflare. com вот как выглядит листинг

вначале список крневых сервров 
и кто дал о них ответ
.			218	IN	NS	m.root-servers.net.
.			218	IN	NS	l.root-servers.net.
            ...
            ...
;; Received 239 bytes from 127.0.0.53#53(127.0.0.53) in 4 ms



потом сервера которые держат зону .com
и кто дал про них ответ
com.			172800	IN	NS	e.gtld-servers.net.
com.			172800	IN	NS	b.gtld-servers.net.
                                ...
com.			86400	IN	DS	19718 13 2 ;; Received 1174 bytes from 2001:500:2f::f#53(f.root-servers.net) in 4 ms



потом кто держит зону cloudflare.com
 и кто дал про них ответ
cloudflare.com.		172800	IN	NS	ns6.cloudflare.com.
                                    ...
;; Received 720 bytes from 192.41.162.30#53(l.gtld-servers.net) in 20 ms



потом инфо о доменах cloudflare.com
и кто дал про них ответ
cloudflare.com.		300	IN	A	104.16.132.229
cloudflare.com.		300	IN	A	104.16.133.229
;; Received 185 bytes from 2400:cb00:2049:1::a29f:121#53(ns4.cloudflare.com) in 0 ms


так вот получается что в предполследеней секции мы узнаем днс сервреа
которые держат зонву cloudflare.com это ns6.cloudflare.com
теперь мы знаем к кому обращаться чтобы получить инфо о домене cloudflare.com 
через dnssec

$ dig    cloudflare.com   @ns6.cloudflare.com +dnssec  +multi

;; ANSWER SECTION:
cloudflare.com.		300 IN A 104.16.132.229
cloudflare.com.		300 IN A 104.16.133.229
cloudflare.com.		300 IN RRSIG A 13 2 300 (
				20240902230553 20240831210553 34505 cloudflare.com.
				6np86HGZsSLSypsWIEpRsphdjJWJsuJDx+0IMtQ/HIzD
				CbPf510eRW/79z7tvNa3WDtpDTCg0w/3z47UNH8/SA== )


итак я обратился к днс серверу ns6.cloudflare.com и попрасил у него выдать инфо 
о домене cloudflare.com (или о записи RR) через dnssec и он выдал именно через дннсек
почему. потому что он нам помимо RR тип A еще выдал тип RRSIG

вот делаю тот же самый запрос без дннсек

$ dig    cloudflare.com   @ns6.cloudflare.com  +multi

;; ANSWER SECTION:
cloudflare.com.		300 IN A 104.16.133.229
cloudflare.com.		300 IN A 104.16.132.229

никакого RRSIG не выдает. 

а вот еще 

$ dig cloudflare.com @ns6.cloudflare.com

;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 58231
;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available


;; ANSWER SECTION:
cloudflare.com.		300	IN	A	104.16.133.229
cloudflare.com.		300	IN	A	104.16.132.229

смотрим вот эту строку
;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

в ней флаг "aa" он типа значит что ответ наш есть  Authoritative Answer
тоесть его раельно дал сервер отвчающий за этот домен

кстати вот еще строка
;; WARNING: recursion requested but not available

это типа о том что мы его попросили сделать за нас всю граузую работу а он 
отказывается? типа того что если мы его просим нам найти запись о каком то левом
домене то он нас нахер пошле?

$ dig -4 google.com @ns6.cloudflare.com

; <<>> DiG 9.18.12-0ubuntu0.22.04.3-Ubuntu <<>> -4 google .com @ns6.cloudflare.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: SERVFAIL, id: 19959
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 65494
;; QUESTION SECTION:
;google.com				IN	A


вроде как да. потому что 
			status: SERVFAIL
типа диг по дефолту делает рекурсивный запрос а этот днс сервер наш шлет нахер.
а если к нему с итеративным подвалить?

$ dig -4 google.com @ns6.cloudflare.com +trace

; <<>> DiG 9.18.12-0ubuntu0.22.04.3-Ubuntu <<>> -4 google .com @ns6.cloudflare.com +trace
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: SERVFAIL, id: 40309

тоже самое status: SERVFAIL,

единсвтенное чего он может обслужить это доменые за которые он сам отвечает

итеративный запрос выдаст пустоту даже для cloudflare.com 
почему. потому что итераитинвый значит то что к тому сервреу первому что мы обращаемся
мы спросим адреса корневых сервеов. а этот сервер нам их не отдаст.

$ dig -4 cloudflare.com @ns6.cloudflare.com  +trace

; <<>> DiG 9.18.12-0ubuntu0.22.04.3-Ubuntu <<>> -4 cloudflare.com @ns6.cloudflare.com +trace
;; global options: +cmd
;; Received 34 bytes from 162.159.3.11#53(ns6.cloudflare.com) in 0 ms


тоесть этот днс облсужываеи только рекурсивный запрос и только по доменам которые он
обслужиывает. и все

так есть команда delv в чем ее прикол. если диг нужно спец ключом +dnnsec просить чтбы
он запрос сделал через днссек то delv делает тлооько днссек запросы и никакие другие. 
его ненужно уговаривать. и  delv в отличеи от диг более явно нам напишет получилось ли
получить данные через днссек или нет. в диг это более расплывачато

кстати более короткий способ узнаьт какой днс  сервер хостит зону

~$ dig -4 cloudflare.com    NS

;; ANSWER SECTION:
cloudflare.com.		5698	IN	NS	ns6.cloudflare.com.
...
...

так вот ксатти ключ +dnssec в диг он сука совсем не про то чтобы диг получил данные
о домене через днссек. НИХУЯ. оно всего лишь про то чтобы он вместе с доменом
запросил RRSIG запись и все. нахуй сука. как я понял диг неумеет работать с днссек. 
он тлько лишь эту маленькую писюлечку может делать - запрашивать RRSIG запись и все.
получается тлоько delv может делать запросы по дннсек. 
так как же работает дннсек. 
рабтает он вот как. у нас в зоне есть однтипные записи. например у нас несколько 
записей cloudlfare.com для них создается запись RRSIG которая много чего внутри себя
включает но главное она включает цифровую подпись сделанную на основе приватного ключа 
ассиметричного шифрвания. публичный ключ запиывается в этой же зоне в запись типа DNSKEY
далее положим что все запросы делает наш днс клиент на компе сам. значит наш днс клиент запрашиывает запись cloudflare.com ему вывалиывается две записи и RRSIG. он запрашиывает
с этого же днс сервера DNSKEY запись. получается мы имеем исходные две записи. имеем
составленное для них цифроую подпись. имеем публичный ключ. значит можем проверить что
контент исходных записей

cloudflare.com.		300	IN	A	104.16.133.229
cloudflare.com.		300	IN	A	104.16.132.229

не был изменен злодеем. (насколько  я понимаю цифровая подпись кода сосавляется то 
она составляется нетолько на основе имени домена cloudflare.com но в нее также входят еще
и IP адреса. пролема в том что естесвтенно ненашел а основе каких полей составляется
цфрроывая подпись)
однако проблема в том что мы незнаем к нам на комп приетлетел настощий публиный ключ 
или всю информацию заменил злодей. в обычной жизни мы бы получили публиный ключ из серти
фиката который бы был бы заверен центром сертификации. а у тут у нас нет сертификата. 
но есть вот что - в родительском  домене лежит запись типа DS она в себе содержит 
хэш от публичного этого ключа. но не просто хеш а хеш зашифрован приватным ключом родительс
кой зоны. и там же в родительской зоне в DNSKEY лежит публичный ключ. значит мы скаыием
с родительской зоны DNSKEY , скачиываем оттуда же DS, расшиывароываем этот DS 
через DNSKEY и получаем хеш нашего публичного ключа. смотрим какой публичный ключ мы 
скачали вычисляем хеш сравниывм. если совпадает то это незлодейтский пуб ключ. но что 
мешает злодею заменить и ту пару DNSKEY , DS . значит надо идти в более родитльскрй
домен и оттуда качать DNSKEY , DS и так до самого корня. на корневом серерве будет DS
но не будет DNSKEY. он уже должен быть на нашем компе как говорится встроен. где 
он хранится в линусе не знаю. в delv он встроен внури программы. тогда провреяем всю 
цепочку. если вся цепь совпала значит все данные достоврыеные. щас покажу 
на примрее.

запраиываем A cloudflare.com +RRSIG_cloudflare.com на серверер ns6.cloudflare.com 
который отвечает за зону cloudflare.com

$ dig -4 cloudflare.com @ns6.cloudflare.com  +dnssec

;; ANSWER SECTION:
cloudflare.com.		300	IN	A	104.16.132.229
cloudflare.com.		300	IN	A	104.16.133.229
cloudflare.com.		300	IN	RRSIG	A 13 2 300 20240903000405 20240831220405 34505 cloudflare.com. wedW9sAEow+A/IIUcQdfxC7Lqml/+PP9Xd1zm2Kuf7XT1dWhVm1XM1Ha yVoNfSWSpKEN7oIetiYH8Hz/Sl8J1A==

далее с этго же серврера запраиываем DNSKEY

$ dig -4 DNSKEY cloudflare.com @ns6.cloudflare.com  


;; ANSWER SECTION:
cloudflare.com.		3600	IN	DNSKEY	257 3 13 mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+GqJxpVXckHAeF+ KkxLbxILfDLUT0rAK9iUzy1L53eKGQ==
cloudflare.com.		3600	IN	DNSKEY	256 3 13 oJMRESz5E4gYzS/q6XDrvU1qMPYIjCWzJaOau8XNEZeqCYKD5ar0IRd8 KqXXFJkqmVfRvMGPmM1x8fGAa2XhSA==

эта не два клюач. это один разбит на два куска.

узнаем сервре который отвечает за родительску зону .com

$ dig -4 NS com. 

;; ANSWER SECTION:
com.			72983	IN	NS	d.gtld-servers.net.
com.			72983	IN	NS	e.gtld-servers.net.


теперь с него запрашиываем DS для домена cloudflare.com

$ dig -4 DS cloudflare.com.  @d.gtld-servers.net

;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 20641

;; ANSWER SECTION:
cloudflare.com.		86400	IN	DS	2371 13 2 32996839A6D808AFE3EB4A795A0E6A7A39A76FC52FF228B22B76F6D6 3826F2B9

очень важно постяно смотреть чтобы в шапке ответа было NOERROR тоесть значит реквест
прошел без ошибок

итак этот DS это DS_от_cloudflare.com   в нем  в виде хэша записан публичный ключ DNSKEY
который мы получили с сервера ns6.cloudflare.com  правда он зашифрован приватным ключом
сервера d.gtld-servers.net, значит надо с этого сервера считать публичный ключ DNSKEY
для этого в запросе нужно указать нетлько сервер но и домен родителтский

~$ dig -4 DNSKEY com.   @d.gtld-servers.net

;; ANSWER SECTION:
com.			86400	IN	DNSKEY	257 3 13 tx8EZRAd2+K/DJRV0S+hbBzaRPS/G6JVNBitHzqpsGlz8huE61Ms9ANe 6NSDLKJtiTBqfTJWDAywEp1FCsEINQ==
com.			86400	IN	DNSKEY	256 3 13 Nps5nxuQHRbY3e9hcbH36kxiELJH5wil+6dC4K1keQI9ci1nqyCP4k1X oXBBn2aeSK4KxwPEs0Opqc0dicuujg==

итак мы имеем DNSKEY_com може расшфировать DS_от_cloudflare.com и получить оттуда 
хэш от DNSKEY_cloudflare.com и сравнить его с DNSKEY_cloudflare.com кторый мы считали
с ns6.cloudflare.com и если они совпадат то с помощью него расшифровать RRSIG_cloudflare.com
а точнее имея оригинальный текст

cloudflare.com.		300	IN	A	104.16.133.229
cloudflare.com.		300	IN	A	104.16.132.229

имея подветженный настоящий DNSKEY_cloudflare.com и имея цифроую подпись RRSIG_cloudflare.com
можно со всем этим поколдовать и сделать вывод совпдаает ли оригинальный текст с цировой
подписью или нет. 
в этом раскаде только одна проблема мы незаем DNSKEY_com настойщий или поддеьный.
для этого идем на сервер отвчающий за родит домен "."  и там ищем DS от ".com"

$ dig -4 DS .   

;; ANSWER SECTION:
.			0	IN	DS	20326 8 2 E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237 C7F8EC8D


провяерм достверномть этого DS через DNSKEY от "." 



$ dig . DNSKEY @8.8.8.8


;; ANSWER SECTION:
.			15568	IN	DNSKEY	256 3 8 AwEAAdSiy6sslYrcZSGcuMEK4DtE8DZZY1A08kAsviAD49tocYO5m37A vIOyzeiKBWuPuJ4m9u5HonCM/ntxklZKYFyMftv8XoRwbiXdpSjfdpNH iMYTTV2oDUNMjdLFnF6HYSY48xrPbevQOYbAFGHpxqcXAQT0+BaBiAx3 Ls6lXBQ3/hSVOprvDWJCQiI2OT+9+saKLddSIX6DwTVy0S5T4YY4EGg5 R3c/eKUb2/8XgKWUzlOIZsVAZZUSTKW0tX54ccAALO7Grvsx/NW62jc1 xv6wWAXocOEVgB7+4Lzb7q9p5o30+sYoGpOsKgFvMSy4oCZTQMQx2Sjd /NG2bMMw6nM=
.			15568	IN	DNSKEY	257 3 8 AwEAAaz/tAm8yTn4Mfeh5eyI96WSVexTBAvkMgJzkKTOiW1vkIbzxeF3 +/4RgWOq7HrxRixHlFlExOLAJr5emLvN7SWXgnLh4+B5xQlNVz8Og8kv ArMtNROxVQuCaSnIDdD5LKyWbRd2n9WGe2R8PzgCmr3EgVLrjyBxWezF 0jLHwVN8efS3rCj/EWgvIWgb9tarpVUDK/b58Da+sqqls3eNbuv7pr+e oZG+SrDK6nWeL3c6H5Apxz7LjVc1uTIdsIXxuOLYA4/ilBmSVIzuDWfd RUfhHdY6+cn8HFRm+2hM8AnXGXws9555KrUB5qihylGa8subX2Nn6UwN R1AkUTV74bU=


а вот так типа можно надежно его скачать 
~$ curl -s https://www.internic.net/domain/root.zone | grep "^\.\s\+[0-9]\+\s\+IN\s\+DNSKEY"


имея DNSKEY_. можно расшифрвать DS_. сравнит его с DNSKEY_. 
если совпадает то с его помощью расшфировать DS_cloudflare.com сравниь с DNSKEY_cloudfalre.com
если совпдаает то проверить цифроую подпись RRSIG_cloudfalre.com с текстом

cloudflare.com.		300	IN	A	104.16.133.229
cloudflare.com.		300	IN	A	104.16.132.229

если совпадает то значит эти две строчки настоящие.
ебала та еще.

то что это все неьльзя подделать упирвается в то что у нас есть заранее достоверный 
DNSKEY_. на нем все держится что достаточно дебильно

далее вот что обнаружил. что для нашего днс клиента systemd-resolved вроде как
ненужно в комп закачивать DS запись от "." домена. так называемый dns root anchor
ибо они пишут в докумнетации что он "встроен". однако 
я все же сделал это рукками.
так вот я взял сделал вот такой запрос

 z 撋  $ dig  .  DS  +multi

			0 IN DS	20326 8 2 (
				E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC
				683457104237C7F8EC8D )

далее надо 0 убрать и скобки убрать и вот так оставить

. IN	DS	20326 8 2 E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D


длаее нужно проверить что цифры ровно такие же как в https://data.iana.org/root-anchors/root-anchors.xml
далее нужно создвать вот такой файл


/etc/dnssec-trust-anchors.d/root.positive
. IN DS 20326 8 2 E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D



далее надо перезапустить 

	# systemct restart systemd-resolved

в логах должно появится

сен 02 03:12:37 lenovo systemd-resolved[157427]: Positive Trust Anchors:
сен 02 03:12:37 lenovo systemd-resolved[157427]: . IN DS 20326 8 2 e06d44b80b8f1d39a95c0b0d7c65d08458e880409bbc683457104237c7f8ec8d

далее типа как проверить что работает dnssec через systemd-resolved


$ systemd-resolve cloudflare.com
cloudflare.com: 2606:4700::6810:84e5           -- link: tun0
                104.16.132.229                 -- link: tun0

-- Information acquired via protocol DNS in 565.6ms.
-- Data is authenticated: yes; Data was acquired via local or encrypted transport: yes
-- Data from: network

нам важна запись 
	Data is authenticated: yes

также проверим 

 $ cat /etc/resolv.conf   | grep -v '#'

nameserver 127.0.0.53
options edns0 trust-ad
search .

значит если мы будем делать запрос через delv то в итоге он пойдет через systemd-resolved
окей. тогда

 $ delv  cloudflare.com +rtrace
;; fetch: cloudflare.com/A
;; fetch: cloudflare.com/DNSKEY
;; fetch: cloudflare.com/DS
;; fetch: com/DNSKEY
;; fetch: com/DS
;; fetch: ./DNSKEY
; fully validated
cloudflare.com.		193	IN	A	104.16.133.229
cloudflare.com.		193	IN	A	104.16.132.229
cloudflare.com.		193	IN	RRSIG	A 13 2 300 20240903015602 20240831235602 34505 cloudflare.com. XcVELgaBlYFzejr1xEL7KwLgcsePWfdXLcb9HGtkpGSUnTZiM4plkUyb 1NX0Me4Vj3lOJYoVWN9xdXFDrhUlig==


получается что чтобы dnssec обеспечить в качестве клиента надо всего навсего 
чобы клиент на компе сделал ряд обычных днс запросов. скачал нужные RR. и сделал 
над ними мамематику. вот и все. никакого чуда.

если пригрлялдетьсся то у нас в описании процесса неуказана а где мы скачивали RRSIG
на самом деле мы его скачиваем на этом этапе

;; fetch: cloudflare.com/A


проделаем туже операцию с большей степнью деталиацзиации


 $ delv cloudflare.com +mtrace

вначале скачиваем 
	A cloudflare.com 
и
	RSIG cloudflare.com

;; fetch: cloudflare.com/A
;; ANSWER SECTION:
;cloudflare.com.		182	IN	A	104.16.133.229
;cloudflare.com.		182	IN	A	104.16.132.229
;cloudflare.com.		182	IN	RRSIG	A 13 2 300 (
;						20240903074442 20240901054442 34505 cloudflare.com.
;						P4VGFsyOkIdD6I21/xAnrwweZKVw
;						sVv+Xy445tpGT+vUMyhugcMsNDo5
;						28sjev/WVIYychybAbUYlzRcXQYU
;						mA== )



потом скачиваем с DNSKEY_cloudflare.com
здесь можно заметить что скачивается ДВА DNSKEY.  один dnskey как и положено содержит публичный ключ которым можно расшифровать RRSIG
а второй как я прочитал на сайте "как доп степень зашиты" содержит копию DS которая хранится
в родительской зоне. это просто треш. очередные накрутки сложности. как видно он нам 
скачал еще и RSIG от DNSKEY. зачем этот ключ нужен хрен знает.


;; fetch: cloudflare.com/DNSKEY
;; ANSWER SECTION:

;cloudflare.com.		604	IN	DNSKEY	257 3 13 (
;						mdsswUyr3DPW132mOi8V9xESWE8j
;						To0dxCjjnopKl+GqJxpVXckHAeF+
;						KkxLbxILfDLUT0rAK9iUzy1L53eK
;						GQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 2371


;cloudflare.com.		604	IN	DNSKEY	256 3 13 (
;						oJMRESz5E4gYzS/q6XDrvU1qMPYI
;						jCWzJaOau8XNEZeqCYKD5ar0IRd8
;						KqXXFJkqmVfRvMGPmM1x8fGAa2Xh
;						SA==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505

;cloudflare.com.		604	IN	RRSIG	DNSKEY 13 2 3600 (
;						20241012045415 20240812045415 2371 cloudflare.com.
;						EGAV8jdo2rRj9Tl5hTM7c4FVKQX2
;						Llep3yQ61cPKqyLSBFpnkJQA2Twh
;						Acng2FfrWMKQ1SzXnppJni6X8W91
;						pg== )




итак на данном этапе у нас есть 
	A_cloudflare.com
	RSIG_cloudflare.com
	DNSKEY__cloudflare.com



на следущем этапе мы скачиваем DS_cloudflare с родиитесосткой зоны
и нам выдают нетолько DS но и цифровую подпись от DS
согласно rfc4304 - DS содержит в себе хеш от DNSKEY. этот хеш никак не зашифрован 
итп. и как я понимаю аутентичность DS проверяется через цифровую подпись через запись RRSIG DS cloudflare.com которая хранится в зоне .com .  непутаем ее с RRSIG A cloudflare.com 
которая хранится в зоне cloudflare.com которая являетяс цифровой подписью записи A_cloudflare.com



;; fetch: cloudflare.com/DS
;cloudflare.com.			IN	DS

;cloudflare.com.		2053	IN	DS	2371 13 2 (
;						32996839A6D808AFE3EB4A795A0E
;						6A7A39A76FC52FF228B22B76F6D6
;						3826F2B9 )
;cloudflare.com.		2053	IN	RRSIG	DS 13 2 86400 (
;						20240908011735 20240901000735 59354 com.
;						Hb4Zkf8qiklvQzEEp6RmjSzJMa9M
;						H8VQdEmerL+G6IIUJ6tZPkJtgNbc
;						YFRu5QYnJ+x0PgEdKaPqAkTaspJK
;						VA== )



итак на данном этапе у нас есть 
	(скачано из зоны cloudflare.com) A_cloudflare.com  +	RSIG_cloudflare.com
	(скачано из зоны .com) DNSKEY__cloudflare.com + DS__cloudflare.com

RSIG_cloudflare.com

теперь скачиваем DNSKEY_.com
он нам позволит 

;; fetch: com/DNSKEY
;com.				IN	DNSKEY

;com.			2228	IN	DNSKEY	256 3 13 (
;						Nps5nxuQHRbY3e9hcbH36kxiELJH
;						5wil+6dC4K1keQI9ci1nqyCP4k1X
;						oXBBn2aeSK4KxwPEs0Opqc0dicuu
;						jg==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 59354
;com.			2228	IN	DNSKEY	257 3 13 (
;						tx8EZRAd2+K/DJRV0S+hbBzaRPS/
;						G6JVNBitHzqpsGlz8huE61Ms9ANe
;						6NSDLKJtiTBqfTJWDAywEp1FCsEI
;						NQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 19718
;com.			2228	IN	RRSIG	DNSKEY 13 1 86400 (
;						20240909140235 20240825135735 19718 com.
;						8dBNzd4TFQj35TTQr1/6MM+BG2mm
;						mgGZfgn231XORw7M2r67xSzo0D5o
;						jdvl5ufLm8guJmKQKG20mbSSTnpu
;						Tw== )


ксатти нихрена не понимаю разницу между зоной и доменом. зато я думаю я понял что 
значит NS серервер. у нас есть записи RR. в каждой записи идет название домена и 
его IP. так вот такие записи они в конечном итоге должны гдето храниться так вот NS
сервер для домена abc.xyz означает что на этом NS сервере физически хранится запись

	abc.xyz  192.168.11.11

есть еще SOA запись. с ней разбиратся не будут. 
поэтмоу когда я ищу NS сервер от cloudflare.com то это значит что мы ищем сервер внутри
которго физически хранятся записи вида

    cloudflare.com   11.12.13.14

в dig можно проставлять флаги в запрос например +aaonly но по факту они нихуя часто
неработают. зато эти флаги очень полезны в статусе при просмотре ответа. нарпример 
флаг aa в ответе означает что ответ нам вернул авторитейтив сервер тоесть именно сервер
на котором физически хранятся запроешенны нами RR записи. вообще смысла дига такой -
мы ему говорим пойди на такой то сервер и принеси нам записи RR с таким то именем
и таким то типом. например выясним чему равны записи с именем google.com и типом NS
будем спрашивать у серврера 8.8.8.8

$ dig @8.8.8.8   NS google.com

;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1

google.com.		21600	IN	NS	ns3.google.com.
google.com.		21600	IN	NS	ns4.google.com.
google.com.		21600	IN	NS	ns1.google.com.
google.com.		21600	IN	NS	ns2.google.com.


в вернутых флагах аа нет. это значит что серврер 8.8.8.8 нехранит внутри себя 
записи NS google.com они хранятся где то в другом месте. когда мы узнали серера указанные
в NS записи то мы узнали сервера внутри которых по идее хранятся все записи относящие
ся к домену google.com  
так вот все да не все. записи типа NS о домене google.com хранятся совсем не на
серверах

	ns3.google.com.
	ns4.google.com.
	ns1.google.com.
	ns2.google.com.

записи NS  google.com хранятся на серверах которые отвечают за родительский домен. 
тоесть серверы которые отвечают за .com (зону или домен хуй знает как это сказать)
именно на них хранятся записи

google.com.		21600	IN	NS	ns3.google.com.
google.com.		21600	IN	NS	ns4.google.com.
google.com.		21600	IN	NS	ns1.google.com.
google.com.		21600	IN	NS	ns2.google.com.

что логично . и получается схема такая. 
мы лазем на 1.2.3.4 который явялется корневым днс сервером. внутри него харнятся
NS записи вида

   NS a.com    server1.a.com
   NS a.com    server2.a.com
   
   NS b.com    server1.b.com
   NS b.com    server2.b.com

   NS yandex.com    server1.yandex.com
   NS yandex.com    server2.yandex.com

   NS vasya.com    server1.vasya.com
   NS vasya.com    server2.vasya.com

замечу что запись типа NS она не содержит IP. она резволвит один домен в другой. 
физ смысл такой что она указывает на сервер который хранит внутри себя записи 
про домен

я так думаю что адреса корневых днс сервром где то вщиты внутри кишок линукса

еще раз подчеркиваю что NS это тип записи в днс файле. физ смысл этой записи 
такой что   у нас берется домен google.com и для него указывается имя сервера ns1.google.com который
содержит почти что все записи для дормена google.com 
все да не все. потому что запись NS google.com хостится не на ns1.google.com а 
на сервере который хостит родительский домен .com

еще раз. 
есть корневйо "." днс сервер 1.2.3.4
внутри него хранятся записи NS с именами  .*

		NS  .*       ...
		NS  .*       ...
		NS  .*       ...

	com.			NS	i.gtld-servers.net.
	com.			NS	c.gtld-servers.net.
	com.			NS	g.gtld-servers.net.

тоесть тип записи NS имя записи "com." и значение i.gtld-servers.net.
эти записи хранятся на корневом сервере c.root-servers.net


$ dig  @c.root-servers.net  com. 

;com.				IN	A

;; AUTHORITY SECTION:
com.			172800	IN	NS	i.gtld-servers.net.
com.			172800	IN	NS	c.gtld-servers.net.
com.			172800	IN	NS	g.gtld-servers.net.


внутри сервером отвечающих за зону\домен com лежат NS записи вида  *.com
в частности yahoo.com

$ dig @c.gtld-servers.net NS  yahoo.com

;; AUTHORITY SECTION:
yahoo.com.		172800	IN	NS	ns1.yahoo.com.
yahoo.com.		172800	IN	NS	ns5.yahoo.com.
yahoo.com.		172800	IN	NS	ns2.yahoo.com.
yahoo.com.		172800	IN	NS	ns3.yahoo.com.
yahoo.com.		172800	IN	NS	ns4.yahoo.com.

внутри сервера ns1.yahoo.com который отвечает за домен yahoo.com лежат 
записи NS   вида *.yahoo.com 

кстати прикол еще в том что всякий домен на конце заканчивается точкой которую 
почемуто принято опускать. скажем mail.ru на самом деле это mail.ru.
это пиздец. это как воздух вроде он есть а вроде его нет. 

так вот еще пример
выясняем какие серера отвечают за домен\зону uk.

смотрим на коренвом сервере
	$ dig  @c.root-servers.net  NS uk. 

;uk.				IN	NS

uk.			172800	IN	NS	nsa.nic.uk.
uk.			172800	IN	NS	dns4.nic.uk.
uk.			172800	IN	NS	dns3.nic.uk.

по мне уебищно что NS запись резолвит не на IP а на доменное имя. что за фигня ?
идем на этот сервер и смотрим на нем записи NS с именем co.uk.

	$ dig  @nsa.nic.uk  NS  co.uk.

;co.uk.				IN	NS

;; ANSWER SECTION:
co.uk.			172800	IN	NS	dns4.nic.uk.

идем на этот сервер и смотрим записи вида NS bbc.co.uk

	$ dig  @dns4.nic.uk  NS  bbc.co.uk.
;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 8, ADDITIONAL: 9
;bbc.co.uk.			IN	NS

;; AUTHORITY SECTION:
bbc.co.uk.		172800	IN	NS	dns0.bbc.co.uk.
bbc.co.uk.		172800	IN	NS	dns0.bbc.com.

видим что это неще на aa ответ.

идем на одни из серверов и опять же ищем NS записи с именем bbc.co.uk.

$ dig  @dns0.bbc.com  NS  bbc.co.uk.

;; flags: qr aa rd; QUERY: 1, ANSWER: 8, AUTHORITY: 0, ADDITIONAL: 1

;bbc.co.uk.			IN	NS

;; ANSWER SECTION:
bbc.co.uk.		900	IN	NS	dns0.bbc.co.uk.
bbc.co.uk.		900	IN	NS	dns0.bbc.com.
bbc.co.uk.		900	IN	NS	dns1.bbc.co.uk.
bbc.co.uk.		900	IN	NS	dns1.bbc.com.

видим что это уже "аа" ответ. 


а вот для www.bbc.co.uk

	$ dig  @dns4.nic.uk  NS  www.bbc.co.uk.

;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 8, ADDITIONAL: 9
;www.bbc.co.uk.			IN	NS

;; AUTHORITY SECTION:
bbc.co.uk.		172800	IN	NS	dns0.bbc.co.uk.
bbc.co.uk.		172800	IN	NS	dns0.bbc.com.

малек я запутался. видно что это "аа" овтет. также видно что сервер хостящий запсии для
домена может принадлежать другому домену. без проблем.


получается если есть сервер который  на каком то другом сервере обозначен в NS записи

  super.com  NS   server1.blabla.com

то это значит на данном сервере хранятся всеовзомжные типы записей (для простоты пусть
все они типа А) и с именем вида


  *.super.com  A   IP_N

и если у данного домена super.com есть подзона  ABC.super.com в которой есть записи 
вида
   
   *.ABC.super.com    A   IP_M

то на этом сервере server1.blabla.com будет NS запись вида


	ABC.super.com   NS   super.server2.com


только мы узнать об этой NS записи можем только если мы знаем имя этой записи

   ABC.super.com  NS

 а если мы незнаем ее имя. то обращаясь к server1.blabla.com мы не можем есго спросить
 мол покажи мне какие NS записи ты имеешь

щас приведу пример


вот у нас есть yandex.ru
щас мы узнаем какой сервер хранит записи вида  


   *.yandex.ru     A    ....


для начала узнаем какой сервер хранит NS записи вида

	   *.ru    NS ...
  yandex.ru    NS ...


	$ dig  @c.root-servers.net  NS ru. 

;ru.				IN	NS

;; AUTHORITY SECTION:
ru.			172800	IN	NS	b.dns.ripn.net.


теперь на этом сервере нужно узнать чему равна запись


  yandex.ru    NS ...


$ dig  @b.dns.ripn.net.  NS yandex.ru. 

;yandex.ru.			IN	NS

YANDEX.RU.		345600	IN	NS	ns2.yandex.RU.
YANDEX.RU.		345600	IN	NS	ns1.yandex.RU.


значит именно на этих серверах хранятся записи вида

  *.yandex.ru   A IP_N

например запросим оттуда запись  news.yandex.ru   A  


$ dig  @ns1.yandex.RU  A  news.yandex.ru. 

;; flags: qr aa rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1

;news.yandex.ru.			IN	A

;; ANSWER SECTION:
news.yandex.ru.		300	IN	A	87.250.250.12
news.yandex.ru.		300	IN	A	87.250.251.12

все верно. мы видим вответе "аа"  флаг. и две записи

news.yandex.ru.		300	IN	A	87.250.250.12
news.yandex.ru.		300	IN	A	87.250.251.12

которые физически храняться на этом сервере.

а есть ли на этом серверер NS записи вида

  *.yandex.ru NS  ....

неузнать. нужно знать имя такой записи
для этого нужно знать имя домена 4 уровня. тогда можно будет указать NS имя 


посмотрим еще пример. вот у меня есть ссылка

huskiecommons.lib.niu.edu

на корневом сервере на котором хостятся записи вида NS   *.
найдем запись 
  edu.    NS    сервер

тоесть о сервере  который хостит домен *.edu


 	$ dig  @c.root-servers.net  NS edu. 

;edu.				IN	NS

edu.			172800	IN	NS	g.edu-servers.net.


внутри этого сервера g.edu-servers.net. найдем запись NS  *.edu 
а именно 

	niu.edu   NS  сервер

которая нам скажем сервер который хостит внутри себя записи *.niu.edu


$ dig  @g.edu-servers.net  NS niu.edu.

;niu.edu.			IN	NS

niu.edu.		172800	IN	NS	dns-ext1.niu.edu.


итак у нас есть сервер 

		dns-ext1.niu.edu

который внутри себя хранит записи вида

	*.niu.edu      A     .......
	*.niu.edu      CNAME .......
	*.niu.edu      NS     .......

будем там искать 

  lib.niu.edu  NS    server


	$ dig  @dns-ext1.niu.edu  NS lib.niu.edu
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 1

;lib.niu.edu.			IN	NS

;; AUTHORITY SECTION:
niu.edu.		3600	IN	SOA	dns-ext1.niu.edu. empty.empty. 2024042074 3600 600 1209600 3600

он говорит о том что нет такой NS записи

будем искаьт на нем запись вида

	huskiecommons.lib.niu.edu   CNAME  ...


	$ dig @dns-ext1.niu.edu. CNAME  huskiecommons.lib.niu.edu

;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;huskiecommons.lib.niu.edu.	IN	CNAME

;; ANSWER SECTION:
huskiecommons.lib.niu.edu. 86400 IN	CNAME	dcniu.bepress.com.


получается внутри *.nit.edu создан CNAME

	huskiecommons.lib.niu.edu. CNAME -->	dcniu.bepress.com.

который перенаправляет на другой домен

	$ dig NS   bepress.com

;bepress.com.			IN	NS

;; ANSWER SECTION:
bepress.com.		5556	IN	NS	ns-739.awsdns-28.net.


проверим что на сервеере    ns-739.awsdns-28.net. лежит запись dcniu.bepress.com


$ dig @ns-739.awsdns-28.net   A   dcniu.bepress.com

;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 4, ADDITIONAL: 1

;dcniu.bepress.com.		IN	A

;; ANSWER SECTION:
dcniu.bepress.com.	60	IN	A	13.57.92.51
dcniu.bepress.com.	60	IN	A	50.18.241.247

видим флаг "аа" значит да. на этом сервере хранится эта запись
в итоге получается домен huskiecommons.lib.niu.edu. должен резволится в 
IP 

	13.57.92.51
    50.18.241.247


$ dig A huskiecommons.lib.niu.edu

;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 1, ADDITIONAL: 1

;huskiecommons.lib.niu.edu.	IN	A

;; ANSWER SECTION:
huskiecommons.lib.niu.edu. 336	IN	CNAME	dcniu.bepress.com.
dcniu.bepress.com.	60	IN	A	13.57.92.51
dcniu.bepress.com.	60	IN	A	50.18.241.247

ага так и есть.



забавно что когда мы запршиваем запись NS с сервера на котором она реально
хранится


$ dig  @c.root-servers.net  NS ru. 

;; flags: qr rd; QUERY: 1, ANSWER: 0, AUTHORITY: 5, ADDITIONAL: 11
;; WARNING: recursion requested but not available

;ru.				IN	NS

;; AUTHORITY SECTION:
ru.			172800	IN	NS	a.dns.ripn.net.

то почему то в ответе нет флага "аа"
но ведь запись 

	ru.				IN	NS	a.dns.ripn.net.


хранится на коренвом серевере

	c.root-servers.net

почему же в ответе нет флага аа ?


зато если обратиться на уже найденный серввер и запросить ту же самую запись NS
то он уже выдаст флаг "аа"

~$ dig  @a.dns.ripn.net.  NS ru. 

;; flags: qr aa rd; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 1

;ru.				IN	NS

;; ANSWER SECTION:
RU.			345600	IN	NS	a.dns.ripn.net.


получается на сервере который указан в NS записи хранится точно такая же запись NS
указывающая сама на себя. 

давай с яндексом проверим

находим сервер хранит NS записи вида  *.ru
	$ dig  @c.root-servers.net  NS ru. 

;ru.				IN	NS

;; AUTHORITY SECTION:
ru.			172800	IN	NS	b.dns.ripn.net.


на этом сервере ищем запись о сервере который хостит зону yandex.ru

	$ dig  @b.dns.ripn.net  NS yandex.ru. 

;yandex.ru.			IN	NS

;; AUTHORITY SECTION:
YANDEX.RU.		345600	IN	NS	ns1.yandex.RU.
YANDEX.RU.		345600	IN	NS	ns2.yandex.RU.


получается на сервере   b.dns.ripn.net хранится запись о том что зону yandex.ru
хостит сервер ns1.yandex.RU

	$ dig  @ns1.yandex.RU.  NS yandex.ru. 

;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 5

;yandex.ru.			IN	NS

;; ANSWER SECTION:
yandex.ru.		604800	IN	NS	ns1.yandex.ru.
yandex.ru.		604800	IN	NS	ns2.yandex.ru.


и на сервере ns1.yandex.RU тоже хранится точно такая же запись о том что он 
сервер ns1.yandex.RU хостит зону yandex.ru
смешно. 
причем ответ с флагом "aa" прилетает при запросе к ns1.yandex.RU а не к серверу
 b.dns.ripn.net.
смешно


далее я хотел показать через DSA как это подписывать файл и проерять подпись
с оригиналом. 

вначале нужно вот так это файло параметров ( что это ?)
	 $ openssl dsaparam -out dsaparam.pem 2048

теперь генерация приватного ключа (че такое des3?)
     $ openssl gendsa -des3 -out priv-dsa.pem dsaparam.pem

теперь генерация приватного ключа
    $ openssl dsa   -in priv-dsa.pem -pubout -out pub-dsa.pem

теперь генерация цифровой подписи
    $ openssl dgst -sha256 -sign priv-dsa.pem  -out arecord.txt.sha256 arecord.txt

теперь проверка оригинала по цифровой подписи
    $ openssl dgst -sha256 -verify pub-dsa.pem   -signature arecord.txt.sha256 arecord.txt


главное чтот тут нужно увидеть это то что для проверки участвуют
		1) цифрова подпись
		2) публичный ключ
		3) оригинал

если чегто из этого нет. то проверка неполучится

теперь я вовзращаюсь к dnnsec
берем запись A cloudflare.com

найдем сервер который хостит эту запись

	$ dig  @h.root-servers.net  NS com.

;com.				IN	NS

;; AUTHORITY SECTION:
com.			172800	IN	NS	h.gtld-servers.net.



	$ dig  @h.gtld-servers.net  NS cloudflare.com.

;cloudflare.com.			IN	NS

;; AUTHORITY SECTION:
cloudflare.com.		172800	IN	NS	ns3.cloudflare.com.


	

	$ dig  @ns3.cloudflare.com  A  cloudflare.com.  +dnssec +multi

;; flags: qr aa rd; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1

;cloudflare.com.		IN A


cloudflare.com.		300 IN A 104.16.132.229
cloudflare.com.		300 IN A 104.16.133.229
cloudflare.com.		300 IN RRSIG A 13 2 300 (
				20240903130233 20240901110233 34505 cloudflare.com.
				jNrY7KD11fQ7hBJeRv2G2OfuVkB5SXFE1i2Cr39fjSP1
				TLlhMPWdo8UdDJWb+gXpeY2mK3Mhan6QsdfzIwAoVg== )



так вот у нас есть "оригинальный текст " это записи 

cloudflare.com.		300	IN	A	104.16.132.229
cloudflare.com.		300	IN	A	104.16.133.229

у нас есть цифровая подпись

cloudflare.com.		300 IN RRSIG A 13 2 300 (
				20240903130233 20240901110233 34505 cloudflare.com.
				jNrY7KD11fQ7hBJeRv2G2OfuVkB5SXFE1i2Cr39fjSP1
				TLlhMPWdo8UdDJWb+gXpeY2mK3Mhan6QsdfzIwAoVg== )


щас мы скачаем публичный ключ

	$ dig  @ns3.cloudflare.com  DNSKEY  cloudflare.com. +multi

;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1
;cloudflare.com.		IN DNSKEY

;; ANSWER SECTION:
cloudflare.com.		3600 IN	DNSKEY 257 3 13 (
				mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+Gq
				JxpVXckHAeF+KkxLbxILfDLUT0rAK9iUzy1L53eKGQ==
				) ; KSK; alg = ECDSAP256SHA256 ; key id = 2371
cloudflare.com.		3600 IN	DNSKEY 256 3 13 (
				oJMRESz5E4gYzS/q6XDrvU1qMPYIjCWzJaOau8XNEZeq
				CYKD5ar0IRd8KqXXFJkqmVfRvMGPmM1x8fGAa2XhSA==
				) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505

из этих двух публичный ключ которым защфирована цифровая подпись это 

cloudflare.com.		3600 IN	DNSKEY 256 3 13 (
				oJMRESz5E4gYzS/q6XDrvU1qMPYIjCWzJaOau8XNEZeq
				CYKD5ar0IRd8KqXXFJkqmVfRvMGPmM1x8fGAa2XhSA==
				) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505


ксттии видно что в RRSIG  есть поле 34505
и в DNSKEY есть тоже самое поле key id = 34505
тоесть в DNSKEY указыается key id, а потом в цифровой подписи заосится признак какой
публичный ключ может быть  использован для расшифровки этой цифровой подписи

итак получается

RRSIG - это цировая подрпись зашифрованная неким приватным ключом

записи типа A это оригиналы
	cloudflare.com.		300	IN	A	104.16.132.229
	cloudflare.com.		300	IN	A	104.16.133.229


DNSKEY это публичный ключ  который получен из приватного и которым можно проверить 
цифроую подпись

а вот тут надо еще кое что добавить. 


значит из того что я прочитал получается вот что. у нас на сервере лежит не один 
ключ DNSKEY cнеким публичным ключом а у нас лежит два DNSKEY ключа. потому что 
создается две пары ассиметричных ключей пара ZSK , пара KSK.
с помощью приватного ZSK ключа создается цифровая подпись для днс записей , и эта 
цифровая подпись сохраняется в запись RRSIG1.
публичный ключ ZSK запиывается в запись DNSKEY1.
с помощью приватного ключа KSK создается цифровая подпись RRSIG2 от DNSKEY1 или другими
словами от публичного ZSK ключа. публичная часть KSK ключа запиывывается на этом же
серверер во второй DNSKEY2. таким образом днс клиент считывается RRSIG1 и с помощью
DNSKEY1 публчиног ключа провряет эту цифровую подпись RRSIG1. подлинность DNSKEY1
проверяется на основе  цифровой подписи RRSIG2 и публичного ключа KSK от нее DNSKEY2
DS в парент зоне содержит хэш от публичного KSK ключа тоест хэш от DNSKEY2
пара ключей ZSK она небоьлшоая по размеру. поэтому шфирование на основе ZSK раобает
быстро. и эти ключи надо менять часто. пара KSK ключей имеет болльшую длинну. и 
их часто менять ненужно. получается при заменее ZSK пары нужно перегенерироттвать RRSIG1
и RRSIG2 
при перегененрации KSK пары нужно заменить DS запиь в парент домене.

получаетя  мы скачиваем RRSIG1, RRSIG2, DNSKEY1, DNSKEY2 все с текущего сервера. 
далее мы с помоью DNSKEY1 проверяем RRSIG1. а далее мы проверяем достоверность
ключа DNSKEY1 через RRSIG2 и ключа от этой цифроваой подписи DNSKEY2.
а потом мы скыычсмем с парента DS и сравниваем его с DNSKEY2

  RRSIG1  <---- DNSKEY1
  DNSKEY1 <---- RRSIG2 <---- DNSKEY1 <---- DS

можно было бы бойтист одной парой но с двумя парами удбонее вроде как. при замене ZSK 
пару нам ненужно перегененировать DS в парень домене. 

ZSK приватный ключ используется для создания RRSIG циврофых подписей днс записей RR
публичный ключ запиываетс в DNSKEY1. и нужен для расшифровки этих цировых подписей.
тоесть ZSK испольуеся для докатзательтва атунетичности днас записей.

KSK приватный ключ используктся для доказетльтсва аутентичности публичного ключа ZSK 
тоесть подлинности DNSKEY1.  для этого создывтае сяцифроыва яподпись RRSIG2 
из DNSKEY1 и приватногол KSK кюча.  публичны KSK кдюч запиываеьсы в DNSKEY2.
и еще его хэш запивается в парент домен в DS запись

из этого следует что DNSKEY1 он же публичный ZSK, он же ключ который используется
для рассшфировки RRSIG1 (RRSIG1 это цифровая подпись от RRset тоесть наших двух
исходных A записей)  это 


;cloudflare.com.		1673	IN	DNSKEY	256 3 13 (
;						oJMRESz5E4gYzS/q6XDrvU1qMPYI
;						jCWzJaOau8XNEZeqCYKD5ar0IRd8
;						KqXXFJkqmVfRvMGPmM1x8fGAa2Xh
;						SA==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505


в описании так и написано что это ZSK имеется ввиду публичный ключ ZSK
alg = ECDSAP256SHA256 означает что этот публичный ключ он от цифровой подписи которая
сделана на основе sha-256 хеша и DSA на эллиптической кривой P-256
также у ключа указан его key id = 34505 - такой же key id должен быть в свойствах 
цифровой записи которую можно расшифроовать этим публичным ключом. key id это штука
добавлена для людей чтолбы можно было быстро визуаьльно понять какой ключ связан
с какой цифровой записью. проверим наш RSIG1 котоорый тоже должен иметь такой же key id


cloudflare.com.		300 IN RRSIG A 13 2 300 (
				20240903130233 20240901110233 34505 cloudflare.com.
				jNrY7KD11fQ7hBJeRv2G2OfuVkB5SXFE1i2Cr39fjSP1
				TLlhMPWdo8UdDJWb+gXpeY2mK3Mhan6QsdfzIwAoVg== )

мы видим что у цифровой подписи тот же key id = 34505
состав полей RSIG,DNSKEY итп можно удобно с примерами иих расшифровкой найти в rfc4034


DS это запись в парент домене являющаяся собой хэш от DNSKEY2. тоесть хеш от KSK 
публичного ключа


значит на одном сервере1 хранятся:
   ориг текст A 
   RRSIG1 от A  (зашифрован приватным ZSK)
   DNSKEY1  (publick ZSK)
   DNSKEY2  (publick KSK)
   RRSIG2 от DNSKEY1  (зашифрован приватным KSK)

в сервере2 парент домена хранится
   DS1 от DNSKEY2



прикол в том что лишь небльшая часть доменов имеют настроенные все эти dnssec записи

	RRSIG1,2
	DNSKEY1,2
	DS

чтобы можно было проверить аутентичность записи через dnssec
поэтому включив dnssec в systemd-resolved   не стоит радотваться что теперь каждый 
днс реквест будет проверен на аутентичность через dnssec
лишь очень малая часть запросов будет иметь возможсность быть проверенной на аутентичность
вот в чем прикол. это как ipv6 если его на компе включить то лишь небольшая часть 
серверрв в интенет его имеет. так что толку от этого ipv6 также и активация dnssec
на днс клиенте на нотбуке даст выхлоп лишь на небьлбшом числе реквестов. взять 
тот же самый gmail или google. важнейшие домены но их не проверить через dnnsec


 $ delv  google.com
; unsigned answer
google.com.		92	IN	A	142.250.181.238

 $ delv  gmail.com
; unsigned answer
gmail.com.		82	IN	A	142.250.186.37


 $ delv  mail.ru
; unsigned answer
mail.ru.		59	IN	A	94.100.180.200
mail.ru.		59	IN	A	217.69.139.202
mail.ru.		59	IN	A	217.69.139.200
mail.ru.		59	IN	A	94.100.180.201

 
 $ delv  ya.ru
; unsigned answer
ya.ru.			87	IN	A	77.88.44.242
ya.ru.			87	IN	A	5.255.255.242
ya.ru.			87	IN	A	77.88.55.242

 $ delv  youtube.com
; unsigned answer
youtube.com.		60	IN	A	142.250.186.46


тоесть все основные сайты неимеют у себя настроенных записей dnssec. так что для них
проверка dnssec аутентичности НЕРАБОТАЕТ ХАХАХАХ!!!!

  $ delv -4  www.usa.gov
; fully validated
www.usa.gov.		277	IN	CNAME	www.usa.gov.external-domains-production.cloud.gov.
www.usa.gov.		277	IN	RRSIG	CNAME 8 3 300 20240929215952 20240830215452 2971 usa.gov. ZnXHhkcpKTNfJKP9CX1EC6GtxG82ivIck5LJQcHsAeYUiCFbcGafP1gV ByLpM8YIBqia79dP7pU5dQsyE/2T7IKU7KGWaK33VO+Znoo3umkWQ/Zz oYbHzSwizpiadwFY1ezx666zMk5NNOB6IWPc9vz1atzxo18emiTDx0cn w+Q=









ЕЩЕ РАЗ посмотрим на работу delv как он производит dnssec   валидацию

	$ delv  cloudflare.com +mtrace

на первом этапе delv запрашивает  A      запись с именем  cloudflare.com
и вместе с этим также запрашивает RRSIG1  запись с именем  cloudflare.com



;; fetch: cloudflare.com/A

;; QUESTION SECTION:
;cloudflare.com.			IN	A

;; ANSWER SECTION:
;cloudflare.com.		143	IN	A	104.16.133.229
;cloudflare.com.		143	IN	A	104.16.132.229

;cloudflare.com.		143	IN	RRSIG	A 13 2 300 (
;						20240904093614 20240902073614 34505 cloudflare.com.
;						hPKMQd4ZPoiGCH+Wu2GEAwcuftFc
;						M+miC3/Hj2gIRxKgwNHN2ttXFmoN
;						ICusmo5x+IQuZj/tKvBs0YnIRHBe
;						3A== )




таким макаром мы получили две A записи и цифровую подпись удостоверяющую их.
эта цифровая подпись подписана приватным ZSK. публичнйы ZSK хранится в одном 
из двух DNSKEY я его будут дальше обознаачать условно DNSKEY1, хотя потянтно
что никакого DNSKEY1 нет. есть две DNSKEY  записи

цифровая подпись  посмотрим на нее 

cloudflare.com   RRSIG	A 13 2 300 (
;						20240903171149 20240901151149 34505 cloudflare.com.
;						HIBUSQVlveUE96VhzxoWE0xdsqRJ
;						5kl8gW/+cOJ1LxwqXrRtn4YjG2AZ
;						YHmc0In0WbwWsBEehdmltTuHt3fU
;						mA== )

в этой записи есть интересная информация. A означает что RRSIG подписала запись 
типа А(хорошо RRSIG подписала кучку А записей), число 13 означает тип алгоритма
цифровой подписи . щас скажу какой

3 = DSA/SHA-1
5 = RSA/SHA-1
6 = DSA/SHA-1/NSEC3
7 = RSA/SHA-1/NSEC3
8 = RSA/SHA-256
10 = RSA/SHA-512
12 = GOST R 34.10-2001
13 = ECDSA/Curve P-256/SHA-256
14 = ECDSA/Curve P-384/SHA-384
15 = Ed25519 (EdDSA/Curve25519/SHA-512)[1][2]
16 = Ed448 (EdDSA/Curve448/SHAKE256)[1][2]

получается 13 означает что в цифровой подписи использован алогоритм DSA основанный
на эллиптических кривых ECDSA на основе эллиптической кривой P-256 , и цифровая подпись
расчитывается на базе хеша стандарта SHA-256 . тоесть берется оригинальный текст. 
в нашем случае это обьедиенная серия записей типа А  из которых получили sha-256.
и вот цифровая подпись ECDSA рассчитывается из хэше sha-256 
это все записано в цифре 13. теперь все понятно как примерно цфироавя подпись 
рассчыается.  цифра 2 означает что имя А записи имеет две части разеленные точкой.
и дейтвительно вот наш RRset

	cloudflare.com.		A	104.16.132.229
	cloudflare.com.		A	104.16.133.229

и у них имя   cloudflare.com и видно что да. оно состоит из двух частей разделенных
точкой. 

кстати запись RRSIG имеет сама ровно тоже самое название (это поле называется owner)
что и в оригинальных А записях входящих в RRset

300 это TTL который был у оригинальной записи А которую подписываем.

так с цифровой подписью более менее разобрались. что в этой записи какая полезная
информация в ней зашита помимо самого тела цифровой подписи.



далее нам чтобы проверить эти две А записи из RRset по цифровой подписи нам нужен публичный ключ ZSK который сможет расшифровать эту цифровую подпись . цифровой ключ можно руками 
найти вот по такому запросу

    тип=DNSKEY имя=cloudflare.com 
тоесть мы ищем

    DNSKEY  cloudflare.com 

эта запись  хранится на том же сервере который хранит в себе и записи 
которые мы уже скачали

;cloudflare.com.		A	104.16.132.229
;cloudflare.com.		A	104.16.133.229
;cloudflare.com.		RRSIG	A 

который мы уже скачали.  это сервер как можно найти самомму руками? 
этот тот сервер который содержится в NS записи

   тип записи=NS  имя записи=cloudflare.com тоесть

   cloudflare.com  NS     имя_сервера



итак delv получает записи DNSKEY 

;; fetch: cloudflare.com/DNSKEY

;; QUESTION SECTION:
;cloudflare.com.			IN	DNSKEY

;; ANSWER SECTION:
;cloudflare.com.		1013	IN	DNSKEY	256 3 13 (
;						oJMRESz5E4gYzS/q6XDrvU1qMPYI
;						jCWzJaOau8XNEZeqCYKD5ar0IRd8
;						KqXXFJkqmVfRvMGPmM1x8fGAa2Xh
;						SA==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505

;cloudflare.com.		1013	IN	DNSKEY	257 3 13 (
;						mdsswUyr3DPW132mOi8V9xESWE8j
;						To0dxCjjnopKl+GqJxpVXckHAeF+
;						KkxLbxILfDLUT0rAK9iUzy1L53eK
;						GQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 2371

;cloudflare.com.		1013	IN	RRSIG	DNSKEY 13 2 3600 (
;						20241012045415 20240812045415 2371 cloudflare.com.
;						EGAV8jdo2rRj9Tl5hTM7c4FVKQX2
;						Llep3yQ61cPKqyLSBFpnkJQA2Twh
;						Acng2FfrWMKQ1SzXnppJni6X8W91
;						pg== )




еще раз скажу что мы скачали к этому моменту и где это хранится. мы
скачали записи


	;cloudflare.com.		A	     104.16.132.229
	;cloudflare.com.		A	     104.16.133.229
	;cloudflare.com.		RRSIG	 A ... 

	;cloudflare.com.		DNSKEY	 ...
	;cloudflare.com.		DNSKEY	 ...
	;cloudflare.com.		RRSIG	 DNSKEY  ...


все эти записи хранятся на условно говоря NS сервере. что такое NS сервер. это такой
сервер который хостит записи зоны\домена. этот сервер можно найти вот как. он записан 
в днс записи типа NS у которой имя  cloudflare.com , этот NS сервер его можно найти через запрос


   $ dig  NS  cloudflare.com

	cloudflare.com.		NS	ns5.cloudflare.com.
	cloudflare.com.		NS	ns4.cloudflare.com.
	cloudflare.com.		NS	ns6.cloudflare.com.
	cloudflare.com.		NS	ns7.cloudflare.com.
	cloudflare.com.		NS	ns3.cloudflare.com.

вот на любом из этих серверов хранятся все эти записи



рассмотрим подробнее DNSKEY записи которые мы скачали

;cloudflare.com.		1673	IN	DNSKEY	256 3 13 (
;						oJMRESz5E4gYzS/q6XDrvU1qMPYI
;						jCWzJaOau8XNEZeqCYKD5ar0IRd8
;						KqXXFJkqmVfRvMGPmM1x8fGAa2Xh
;						SA==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505

;cloudflare.com.		1673	IN	DNSKEY	257 3 13 (
;						mdsswUyr3DPW132mOi8V9xESWE8j
;						To0dxCjjnopKl+GqJxpVXckHAeF+
;						KkxLbxILfDLUT0rAK9iUzy1L53eK
;						GQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 2371


во первых что это значит 

		alg = ECDSAP256SHA256

это значит что данный публичный ключ предназначен для рашифровки цифровой подписи 
которая основана на ECDSA тоесть dsa на эллиптической кривой P-256 которая сделана
над хешем sha-256
далее key id = показывает кей id у цифровой подписи RRSIG от которой этот публичный
ключ. 
отсюда четко видно что публичный ключ с key id = 34505 это публичный ключ от нашего
исходного RRSIG

;cloudflare.com.		1673	IN	DNSKEY	256 3 13 (
;						oJMRESz5E4gYzS/q6XDrvU1qMPYI
;						jCWzJaOau8XNEZeqCYKD5ar0IRd8
;						KqXXFJkqmVfRvMGPmM1x8fGAa2Xh
;						SA==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505


и вот напоминаю наш RSIG1

cloudflare.com   RRSIG	A 13 2 300 (
;						20240903171149 20240901151149 34505 cloudflare.com.
;						HIBUSQVlveUE96VhzxoWE0xdsqRJ
;						5kl8gW/+cOJ1LxwqXrRtn4YjG2AZ
;						YHmc0In0WbwWsBEehdmltTuHt3fU
;						mA== )


еще раз видно что и ключ и подспись имеют одинаковы key id=34505

итак у нас есть две A записи, есть сделанная под ним цфировая подпись RRSIG1,
есть публичный ключ DNSKEY1 который может ее расшифровать. значит наш delv
может провреить неподдельность RRSIG1
но так как все эти полученные записи могут быть поддельными то нужно проверить 
неподдельность DNSKEY1. для этого у нас есть DNSKEY2 и RRSIG2




;cloudflare.com.		1673	IN	DNSKEY	257 3 13 (
;						mdsswUyr3DPW132mOi8V9xESWE8j
;						To0dxCjjnopKl+GqJxpVXckHAeF+
;						KkxLbxILfDLUT0rAK9iUzy1L53eK
;						GQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 2371



;cloudflare.com.		1673	IN	RRSIG	DNSKEY 13 2 3600 (
;						20241012045415 20240812045415 2371 cloudflare.com.
;						EGAV8jdo2rRj9Tl5hTM7c4FVKQX2
;						Llep3yQ61cPKqyLSBFpnkJQA2Twh
;						Acng2FfrWMKQ1SzXnppJni6X8W91
;						pg== )




в RRSIG2 записана цифровая подпись сделанная из DNSKEY1 и расшифровать ее можно
через публичнй ключ DNSKEY2
и RRSIG2 и DNSKEY2 содержать одинаковый key id = 2371

делв так и делает. 
одна только проблема это все тоже может быть сфабриковано поэтому нужно проверить
неподдельность DNSKEY2


поэтму на следующем этапе мы скачиваем DS с серервера который хранит днс записи парент домена.com 



;; fetch: cloudflare.com/DS

;; QUESTION SECTION:
;cloudflare.com.			IN	DS

;; ANSWER SECTION:
;cloudflare.com.		17131	IN	DS	2371 13 2 (
;						32996839A6D808AFE3EB4A795A0E
;						6A7A39A76FC52FF228B22B76F6D6
;						3826F2B9 )

;cloudflare.com.		17131	IN	RRSIG	DS 13 2 86400 (
;						20240908011735 20240901000735 59354 com.
;						Hb4Zkf8qiklvQzEEp6RmjSzJMa9M
;						H8VQdEmerL+G6IIUJ6tZPkJtgNbc
;						YFRu5QYnJ+x0PgEdKaPqAkTaspJK
;						VA== )




DS запись это хеш  сделанный из DNSKEY2 тоесть хеш сделанный из KSK публик кей.
значит у DNSKEY2 и DS по идее должен быть одинаеовый key id.
смоотрим  DS имеет key id = 2371 и публичный KSK ключ DNSKEY2 имеет тот же самый key id

;cloudflare.com.		1673	IN	DNSKEY	257 3 13 (
;						mdsswUyr3DPW132mOi8V9xESWE8j
;						To0dxCjjnopKl+GqJxpVXckHAeF+
;						KkxLbxILfDLUT0rAK9iUzy1L53eK
;						GQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 2371


получется у нас публичный KSK ключ хранится в виде DNSKEY2 на исходном сервере
плюс на сервере родительского домена он же хранится в записи DS но не в откртом виде
а в виде хеша. получается DNSKEY2 и DS хранят одно и тоже . почти одно и тоже. в 
DS хранится хеш от DNSKEY2. также на исходном сервере хранится  RRSIG1 от А которую можно
расшифровать через DNSKEY1, тамже хранится RRSIG2 от DNSKEY1 которую можно расшифровать
через DSNKEY2.


RRSIG1 (сделана от записей А, )  <---- можно расшифрвать чеерз DNSKEY1
RRSIG2 (сделана от DNSKEY1, )    <---- можно расшифрвать чеерз DNSKEY2

DS это хеш от DNSKEY2


тоесть мы берем DSNKEY1 и расшировывыаем RRSIG1. то что получили сверяем с RRset (аутентичность А записей проверили)
потом мы берем RRSIG2 и расшировываем его через DNSKEY2  и проверяем сопал ли он с 
DNSKEY1 (аутентичность DNSKEY1 проверили)

RRSIG1 подиверждает аутентичность А записей
RRSIG2 подтверждает аутентичность DNSKEY1 тоесть ZSK публичного ключа которым мы 
расшировали RRSIG1

нужно подтвердить атунетичнсть DNSKEY2 котормы мы расшироовывыали RRSIG2.

RRSIG1 (потдверждает аутентичность A записей) , расшифровыаем его через DNSKEY1
теперь нужно подтвердить аутентичность DNSKEY1. для это расшироывваем RRSIG2 ключом
DNSKEY2. теперь надо подтрвеодит анутентичность DNSKEY2. для этого скачиваем DS.
DS хранится в парент домене и содержит хеш копиюю от DNSKEY2.
аутентичность DNSKEY2 установили. если только DS неподделка. для того чтобы это 
защтить в парент домеене лежит цифровая подпись которую мы уже скачали 
сделанная над этим DS



;cloudflare.com.		17131	IN	RRSIG	DS 13 2 86400 (
;						20240908011735 20240901000735 59354 com.
;						Hb4Zkf8qiklvQzEEp6RmjSzJMa9M
;						H8VQdEmerL+G6IIUJ6tZPkJtgNbc
;						YFRu5QYnJ+x0PgEdKaPqAkTaspJK
;						VA== )


она сделана ZSK приватным ключом парент домена .com ,(напомню что ZSK пара ключей
используется для шфрования днс записей зоны ),
судя по картинке key id этого ключа 59354
на следущем этапе мы будем его качать


;; fetch: com/DNSKEY

;; QUESTION SECTION:
;com.				IN	DNSKEY

;; ANSWER SECTION:
;com.			6446	IN	DNSKEY	256 3 13 (
;						Nps5nxuQHRbY3e9hcbH36kxiELJH
;						5wil+6dC4K1keQI9ci1nqyCP4k1X
;						oXBBn2aeSK4KxwPEs0Opqc0dicuu
;						jg==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 59354

;com.			6446	IN	DNSKEY	257 3 13 (
;						tx8EZRAd2+K/DJRV0S+hbBzaRPS/
;						G6JVNBitHzqpsGlz8huE61Ms9ANe
;						6NSDLKJtiTBqfTJWDAywEp1FCsEI
;						NQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 19718

;com.			6446	IN	RRSIG	DNSKEY 13 1 86400 (
;						20240909140235 20240825135735 19718 com.
;						8dBNzd4TFQj35TTQr1/6MM+BG2mm
;						mgGZfgn231XORw7M2r67xSzo0D5o
;						jdvl5ufLm8guJmKQKG20mbSSTnpu
;						Tw== )



и вот мы его скачали

;com.			6446	IN	DNSKEY	256 3 13 (
;						Nps5nxuQHRbY3e9hcbH36kxiELJH
;						5wil+6dC4K1keQI9ci1nqyCP4k1X
;						oXBBn2aeSK4KxwPEs0Opqc0dicuu
;						jg==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 59354

у него key id = 59354 как  у цифровой подписи 


теперь надо провреть подлинность этого DNSKEY (key id = 59354)
для этого надо в парент домене найти цифроую подпись этого DNSKEY сделанную 
на основе KSK ключа парент .com домена


вот эта цифровая подпись

;com.			6446	IN	RRSIG	DNSKEY 13 1 86400 (
;						20240909140235 20240825135735 19718 com.
;						8dBNzd4TFQj35TTQr1/6MM+BG2mm
;						mgGZfgn231XORw7M2r67xSzo0D5o
;						jdvl5ufLm8guJmKQKG20mbSSTnpu
;						Tw== )

кстати проблема цифровой подписи в том что в ней указано каким ключом она зашифрована
в данном случае ключом с key id = 19718 - это KSK ключ .com домена

;com.			6446	IN	DNSKEY	257 3 13 (
;						tx8EZRAd2+K/DJRV0S+hbBzaRPS/
;						G6JVNBitHzqpsGlz8huE61Ms9ANe
;						6NSDLKJtiTBqfTJWDAywEp1FCsEI
;						NQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 19718


но в цифровой подписи плохо указано над какой записью она сделана.
тоесть смортрим в цифроую подпись


;com.			6446	IN	RRSIG	DNSKEY 13 1 86400 (
;						20240909140235 20240825135735 19718 com.
;						8dBNzd4TFQj35TTQr1/6MM+BG2mm
;						mgGZfgn231XORw7M2r67xSzo0D5o
;						jdvl5ufLm8guJmKQKG20mbSSTnpu
;						Tw== )


из нее мы видим что она сделана над DNSKEY записью или записями с именем  ".com"
у нас в .com таких DNSKEY записей две

;com.			6446	IN	DNSKEY	256 3 13 (
;						Nps5nxuQHRbY3e9hcbH36kxiELJH
;						5wil+6dC4K1keQI9ci1nqyCP4k1X
;						oXBBn2aeSK4KxwPEs0Opqc0dicuu
;						jg==
;						) ; ZSK; alg = ECDSAP256SHA256 ; key id = 59354

;com.			6446	IN	DNSKEY	257 3 13 (
;						tx8EZRAd2+K/DJRV0S+hbBzaRPS/
;						G6JVNBitHzqpsGlz8huE61Ms9ANe
;						6NSDLKJtiTBqfTJWDAywEp1FCsEI
;						NQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 19718

вопрос - эта цифровая подпись она сделана над обоими или над одной. тогда какой?

вобщем берем KSK публичный ключ key id = 19718 расшифровыаем цифр подпись с key id = 19718
и проверяем аутентичность ZSK ключа  key id = 59354

теперь надо проверить аутенчтисночть KSK публичного ключа key id = 19718
для этого идем в еще более высокий  парент домен "."
и там скачиваем DS который должен иметь key id = 19718


;; fetch: com/DS

;; QUESTION SECTION:
;com.				IN	DS

;; ANSWER SECTION:
;com.			80172	IN	DS	19718 13 2 (
;						8ACBB0CD28F41250A80A49138942
;						4D341522D946B0DA0C0291F2D3D7
;						71D7805A )

;com.			80172	IN	RRSIG	DS 8 1 86400 (
;						20240916050000 20240903040000 20038 .
;						U+7Ld9NKovBpKn81lajP/oKkGkAS
;						+TG32uqCIw2bZBjrcHYhgMQg7Glg
;						MWodrSrxKDFoQ8QgtiZkgaPS0XBv
;						5tm41oulu6rCaiaJU8uLnsCzU4Ff
;						unhKwVFy/Egkz8Xm3jmlsZpOQLPN
;						Ke6d+JpiY+onZAEBt4RaPBJBZl4y
;						dfVtFeWdQcdkMSWJ2yAuL2NCoTOl
;						dSIhNCmzFBIJN0UxL0IkqBCGpZcX
;						RHxED7pce3DNa3S9Ol2bI8Zpfj8A
;						3wNJfnWKvFxr4cYHvIw7TutGQlyL
;						vKFZQAjIwFL+75N8w7BiEbi+SiJu
;						mk0YJAqD7cjLR38/2mh3tglyQ2MF
;						XjRFyg== )

ненадо смущаться что имя DS записи ".com" сама запись скачивается с "." домена.
а имя записи ".com" у DS означает что она относится  к ".com" домену.
и вот мы видим что эта DS запись имеет  key id = 19718 точно как нам надо


;com.			80172	IN	DS	19718 13 2 (
;						8ACBB0CD28F41250A80A49138942
;						4D341522D946B0DA0C0291F2D3D7
;						71D7805A )


дело в  том что получается что на серверре "." домена хранится целая туча записей
типа DS от всего доменов нижнего уровня. тоесть условно говоря 

 ".com"  DS ....
 ".net"  DS ....
 ".ru"   DS ....

 тоесть на серере коренвгого домена куча DS записей а не одна


значит мы скачали ".com" DS запись. открыли ее. там хеш от KSK публичного ключа 
домена ".com" мы взяли DNSKEY он же публ KSK ключ домена ".com" он имеет тот же
key id=19718 что и DS запись

;com.			6446	IN	DNSKEY	257 3 13 (
;						tx8EZRAd2+K/DJRV0S+hbBzaRPS/
;						G6JVNBitHzqpsGlz8huE61Ms9ANe
;						6NSDLKJtiTBqfTJWDAywEp1FCsEI
;						NQ==
;						) ; KSK; alg = ECDSAP256SHA256 ; key id = 19718

вычисли хеш. сравнили  с DS записью.
установили что public KSK ключ подлинный.

теперь нам надо уствноить что DS ".com" подлинный.
значит нам надо на сервере корненого домена найти цифроую подпись сделанную над этим DS
а вот мы уже ее скачали на самом деле



;com.			80172	IN	RRSIG	DS 8 1 86400 (
;						20240916050000 20240903040000 20038 .
;						U+7Ld9NKovBpKn81lajP/oKkGkAS
;						+TG32uqCIw2bZBjrcHYhgMQg7Glg
;						MWodrSrxKDFoQ8QgtiZkgaPS0XBv
;						5tm41oulu6rCaiaJU8uLnsCzU4Ff
;						unhKwVFy/Egkz8Xm3jmlsZpOQLPN
;						Ke6d+JpiY+onZAEBt4RaPBJBZl4y
;						dfVtFeWdQcdkMSWJ2yAuL2NCoTOl
;						dSIhNCmzFBIJN0UxL0IkqBCGpZcX
;						RHxED7pce3DNa3S9Ol2bI8Zpfj8A
;						3wNJfnWKvFxr4cYHvIw7TutGQlyL
;						vKFZQAjIwFL+75N8w7BiEbi+SiJu
;						mk0YJAqD7cjLR38/2mh3tglyQ2MF
;						XjRFyg== )

значит эта цировая подпись сделана над DS записью с иеменем ".com"
и эта цифроая подпсись сделана ключом с key id=20038

качаем с этого срвера этот KSK ключ

;; fetch: ./DNSKEY

;; QUESTION SECTION:
;.				IN	DNSKEY

;; ANSWER SECTION:
;.			12145	IN	DNSKEY	257 3 8 (
;						AwEAAaz/tAm8yTn4Mfeh5eyI96WS
;						VexTBAvkMgJzkKTOiW1vkIbzxeF3
;						+/4RgWOq7HrxRixHlFlExOLAJr5e
;						mLvN7SWXgnLh4+B5xQlNVz8Og8kv
;						ArMtNROxVQuCaSnIDdD5LKyWbRd2
;						n9WGe2R8PzgCmr3EgVLrjyBxWezF
;						0jLHwVN8efS3rCj/EWgvIWgb9tar
;						pVUDK/b58Da+sqqls3eNbuv7pr+e
;						oZG+SrDK6nWeL3c6H5Apxz7LjVc1
;						uTIdsIXxuOLYA4/ilBmSVIzuDWfd
;						RUfhHdY6+cn8HFRm+2hM8AnXGXws
;						9555KrUB5qihylGa8subX2Nn6UwN
;						R1AkUTV74bU=
;						) ; KSK; alg = RSASHA256 ; key id = 20326

;.			12145	IN	DNSKEY	256 3 8 (
;						AwEAAdSiy6sslYrcZSGcuMEK4DtE
;						8DZZY1A08kAsviAD49tocYO5m37A
;						vIOyzeiKBWuPuJ4m9u5HonCM/ntx
;						klZKYFyMftv8XoRwbiXdpSjfdpNH
;						iMYTTV2oDUNMjdLFnF6HYSY48xrP
;						bevQOYbAFGHpxqcXAQT0+BaBiAx3
;						Ls6lXBQ3/hSVOprvDWJCQiI2OT+9
;						+saKLddSIX6DwTVy0S5T4YY4EGg5
;						R3c/eKUb2/8XgKWUzlOIZsVAZZUS
;						TKW0tX54ccAALO7Grvsx/NW62jc1
;						xv6wWAXocOEVgB7+4Lzb7q9p5o30
;						+sYoGpOsKgFvMSy4oCZTQMQx2Sjd
;						/NG2bMMw6nM=
;						) ; ZSK; alg = RSASHA256 ; key id = 20038

;.			12145	IN	RRSIG	DNSKEY 8 0 172800 (
;						20240920000000 20240830000000 20326 .
;						EaIMPt/CkTr3713no0YhuwCSwpn4
;						+CcpVh3w2tezZ9iAft6ynifFTyWe
;						jvJX+61X5XHmvjSbgzGNuPdnveIq
;						2GIeK669S9+NHw0IKUS+KYc14tTg
;						g3I6yVFCuzH89QWigyT7aQdUvxwV
;						AujGflfE0sF2qgiQWlbg+t+iVwiT
;						TGK10rjgHIA/S6BWA0ihoUUI/eCn
;						iojGTUx+sWvqwx4BHSjJT3NsTkfs
;						O44+d9RiDPB277BwHcj11jq3KD44
;						xz2KR24z6dlHJSykYrP7zuLGkeSN
;						wo6/IflA9g7kRZnLYL2ynwrCiz3S
;						wb+EA+gYkN+FIvX0Ud+JGGstmnp8
;						1p+F2g== )




вот он

;.			12145	IN	DNSKEY	256 3 8 (
;						AwEAAdSiy6sslYrcZSGcuMEK4DtE
;						8DZZY1A08kAsviAD49tocYO5m37A
;						vIOyzeiKBWuPuJ4m9u5HonCM/ntx
;						klZKYFyMftv8XoRwbiXdpSjfdpNH
;						iMYTTV2oDUNMjdLFnF6HYSY48xrP
;						bevQOYbAFGHpxqcXAQT0+BaBiAx3
;						Ls6lXBQ3/hSVOprvDWJCQiI2OT+9
;						+saKLddSIX6DwTVy0S5T4YY4EGg5
;						R3c/eKUb2/8XgKWUzlOIZsVAZZUS
;						TKW0tX54ccAALO7Grvsx/NW62jc1
;						xv6wWAXocOEVgB7+4Lzb7q9p5o30
;						+sYoGpOsKgFvMSy4oCZTQMQx2Sjd
;						/NG2bMMw6nM=
;						) ; ZSK; alg = RSASHA256 ; key id = 20038


это ZSK публичный ключ которым сервер кореневого домена шифрует (делает цифровые подпсии
над доменными записями)

значит взяли этот ключ. проверили ту цфироую подпись. выяснили что KSK ключ ".com"
подлинный.

тепрь нам надо вяяснить что ZSK ключ корневого домена подлинный.
ищем цифроую подпись сделанную над этим ключом. 

вот эта подпись

;.			12145	IN	RRSIG	DNSKEY 8 0 172800 (
;						20240920000000 20240830000000 20326 .
;						EaIMPt/CkTr3713no0YhuwCSwpn4
;						+CcpVh3w2tezZ9iAft6ynifFTyWe
;						jvJX+61X5XHmvjSbgzGNuPdnveIq
;						2GIeK669S9+NHw0IKUS+KYc14tTg
;						g3I6yVFCuzH89QWigyT7aQdUvxwV
;						AujGflfE0sF2qgiQWlbg+t+iVwiT
;						TGK10rjgHIA/S6BWA0ihoUUI/eCn
;						iojGTUx+sWvqwx4BHSjJT3NsTkfs
;						O44+d9RiDPB277BwHcj11jq3KD44
;						xz2KR24z6dlHJSykYrP7zuLGkeSN
;						wo6/IflA9g7kRZnLYL2ynwrCiz3S
;						wb+EA+gYkN+FIvX0Ud+JGGstmnp8
;						1p+F2g== )


из названия видно что она сделана над DNSKEY записью с именем "."
правда опятже непонянтно. она сделана над обоими запиясями с таким именем или надо 
одной. ну ладно. она зшифрована KSK ключом кореневого доомеа с номером key id = 20326

а вот он у нас уже скачан

;.			12145	IN	DNSKEY	257 3 8 (
;						AwEAAaz/tAm8yTn4Mfeh5eyI96WS
;						VexTBAvkMgJzkKTOiW1vkIbzxeF3
;						+/4RgWOq7HrxRixHlFlExOLAJr5e
;						mLvN7SWXgnLh4+B5xQlNVz8Og8kv
;						ArMtNROxVQuCaSnIDdD5LKyWbRd2
;						n9WGe2R8PzgCmr3EgVLrjyBxWezF
;						0jLHwVN8efS3rCj/EWgvIWgb9tar
;						pVUDK/b58Da+sqqls3eNbuv7pr+e
;						oZG+SrDK6nWeL3c6H5Apxz7LjVc1
;						uTIdsIXxuOLYA4/ilBmSVIzuDWfd
;						RUfhHdY6+cn8HFRm+2hM8AnXGXws
;						9555KrUB5qihylGa8subX2Nn6UwN
;						R1AkUTV74bU=
;						) ; KSK; alg = RSASHA256 ; key id = 20326

подставляем. проверяем подпись. получаем что ZSK ключ корневого домена настойщий.
осталось проверить что KSK ключ кореневного домена настоящий. а он у нас хранится
на компе 

 - 犙  $ cat /etc/dnssec-trust-anchors.d/root.positive 
. IN DS 20326 8 2 E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D

правда не прямом виде. а в виде DS записи. тоест в виде хеша от DNSKEY
в нем видно по крайней мере что у KSK публичного клча корневого домена key id = 20326
совпдаает с key id =20326 DS записи которая хранится на нашем компе.

значит исходя из этого DNSKEY он же publik KSK ключ корневого домена настоящий. и 
значит все настоящее из того что мы проверяли. и значит наши исходные две А записи 
настойщие. и delv об этом пишет


; fully validated
cloudflare.com.		143	IN	A	104.16.133.229
cloudflare.com.		143	IN	A	104.16.132.229
cloudflare.com.		143	IN	RRSIG	A 13 2 300 20240904093614 20240902073614 34505 cloudflare.com. hPKMQd4ZPoiGCH+Wu2GEAwcuftFcM+miC3/Hj2gIRxKgwNHN2ttXFmoN ICusmo5x+IQuZj/tKvBs0YnIRHBe3A==

вот так работает проверка dnssec. по мне достаочно дебильно все сделано. зато 
без сертификатов.

щас можно прикинуть сколько DNS записей пришлось скачать чтобы проделать всю эту работу

сервер домена "cloudlfre.com"
    A запись 
    A запись
    RRSIG (от А записей) сделана   "cloudflare.com" ZSK ключом
    ZSK ключ
    RRSIG (от ZSK записи) сделана   "cloudflare.com" KSK ключом
    KSK ключ

сервер домена ".com"
    DS запись (хеш KSK ключа домена cloudflare.com)
    RRSIG (от DS записи) сделана   ".com" ZSK ключом
    ZSK ключ
    RRSIG (от ZSK записи) сделана   ".com" KSK ключом
    KSK ключ

сервер домена "."
    DS запись (хеш KSK ключа домена .com)
    RRSIG (от DS записи) сделана   "." ZSK ключом
    ZSK ключ
    RRSIG (от ZSK записи) сделана   "." KSK ключом
    KSK ключ

наш комп
    DS запись (хеш KSK ключа домена .)

итого чтобы проверить наши А записи через DNSSEC пришлось скачать 14 днс записей
плюс иметь запись на компе

ну так конечно когда мы заходим даже на одну веб страницу нам чтобы ее полностью 
открыть приходится делать кучу днс запросов с этой страницы. но все равно 14 запросов
это много. это еще учитывая что мы проверяли домен второго уровня.
уровень домена это сколько у него слов в названии между точками

 	cloudflare.com

у нас два слова между одной точкой

   www.youtube.com

 это домен третьего уровня между двумя точками

 корневой домен 

 "."

 видимо имеет первый уровень

 домен вида

  .com
  .net
  .ru 

 это домен первого уровня

 вроде бы основное по dnssec я закончил описывать


dnssec. я хочу поговорить о том как можно сделать запрос к днс с требованием провести
dnssec проверкку:
 и тут оказалось что открылась просто адовая тема по этому вопросу. щас станет понятно
 о чем я говорю. есть четыре вида днс серверов: рут сервера, авторитивные серверы, TLD
 сервера, рекурсивные сервера. рут днс сервер в нем хранятся все NS записи серверов
 которые обслуживают домены первого уровня (.com, .net, ) , давай еще скажем по дргоуму
 они хранят все NS записи для доменов первого уровня. если направить днс запрос к 
 рут серверу например мы у него спросим  A bbc.co.uk   
 то рут сервер  возьмет этот домен  вычленит из него домен 1-го уровня .uk и вернет
 в качестве ответа NS запись

      NS .uk   ...

показываю

$ dig @h.root-servers.net  bbc.co.uk  

uk.			172800	IN	NS	nsa.nic.uk.

вот это то что умеет и делает рут сервер.
 TLD сервера хранять все NS записи для доменов второго уровня (yandex.ru, vasya.com)
 авторитивные серверы - хранят записи от всех остаьльных доменов. ну тоесть вот  я купил
 домен. и я ставлю сервер на котром будут хранится записи моего домена. мой серервер
 будет авторитивный от моего домена. рекурсивный днс сервер: и тут надо особо сказать - 
 есть два варианта как искать IP от домена. один вариант вот какой - скажем мне
 надо найти ip от google.com я что делаю. я со совего компа через днс клиент обращаюсь
 к корневому серверу и спрашиваю NS для .com он мне дает в ответ 

	 NS	d.gtld-servers.net.

тут кстати ебала в том плане что я не знаю IP от   d.gtld-servers.net.
щас для простоты будем считать что я его как то узнал. 
далее я обращаюсь со своего днс клиента к этому серверу и спраиваю NS запись от google.com
он мне выдает 

	NS	ns2.google.com.

я нашел серер который хранит записи от доамена google.com
наконец я у него спрашиваю  A  google.com.
и он мне выдает 

	google.com.		300	IN	A	142.250.203.20

так вот я этим хотел показать как "по классике"  происходит работа с днс когда я 
хочу найти ip от домена. тоесть - это огоромная адовая работа. нужно сделать кучу 
реквестов. это могу либо делать я руками пользуясь днс клиентом на компе. либо это 
может делать за меня умный днс клиент на моем компе. в любом случае это адовая куча
запросов наружу. насколько  я понял это назыавется делать iterative query к днс
(хотя в терминологии полный ад в случае с днс)
так вот вместо того чтобы мы сами с нашего компа делали вначале запрос к рут серверу,
потом делали запрос к .com серверу,  и потом делали запрос к авториттивному серверу
отвечающему за google.com вместо всего этого можно с днс клиента нашего компа направрить
всего один запрос к рекурсивному днс серверу. и он сделает эту всю грязную работу 
за нас. тоесть мы с кнему делаем 1 запрос. он за нас делает 3 запроса. и нам возвращает
ответ. таким образом рекурсивный днс сервер есть. итеративного днс сервера нету. 
еще скажу что rfc это самые нормально написанные бумажки из всей так назыавемой докментац
ии которую  я встречал. в оппозит маны это одна из самых гнидостных гадостей.
в rfc1034 я нашел про два режима работы днс сервера: нерекурсивны режим и рекурсивный
режим. в нерекурсивном режиме днс сервер в ответ выдает либо ошибку либо ответ из своей
локальной базы либо ссылку на другой днс сервер который знает "лучше". при этом неясно
откуда он знает про тот другой сервер. это тоже в его локальной базе?
рекурсивный режиме - это когда в ответ на запрос от клиента днс сервер выдает либо 
ошибку либо конечный ответ , но никогда не выдает ссылку(реферал) на другой сервер 
который типа знает лучше. мне интересно как в распечатке от dig выглядит секция в которой
указан реферал(тоесть сервер который знает ответ лучше)
в этом же rfc1034 написано что днс сервер  недолжен выполнять запрос рекурсивно 
если его об этом в явноммм виде не попросит клиент. если клиент не просит то запрос
нужно выполнять нерекурсивно то есть выдать что знаешь из своей локальной базы и все,
а только если клиент попросит в явном виде тлоько тогда выполнять запрос рекурсивно. 
клиент для этого выставляет в запросе бит RD(recursion desired) тогда днс сервер
видит это и если на днс сервере актиививрован рекурсивный режим то днс сервер выполняет
запрос рекурсивно и в ответе своем вовзращает два бита устанолвенные это 

  RD(recusrion desired)
  RA (recursion available)

тогда клиент видит эти два бита что они установлены  и понимает что запрос был выполенен как рекурсивный
наскрткр я понял из практики в чем важная особенность нерекурсивного ответа от сервера, 
ему нельзя использовать данные которых у него нет в локальной базе. нельзя использовать
то что в кеше лежит. он может использовать только то что у него есть в локальной базе.
а если запрос рекурсивный то он может использовать как я понял вообще любые источники
тоесть запросы к сторонним серверами или то что у него в кеше. щас покажу. яделаю
нерекурсивный запрос к 8.8.8.8 

	$ dig @8.8.8.8    +qr +norecurse  -t A   google.com

+norecurse   означает что мы сбрасываем бит RD в запросе
+qr          означает что в выводе мы увидим нетолько секцию ответа но и запрос

так вот я делаю нерекурсивный запрос к 8.8.8.8 об записи A google.com
ксаттаии рекурсивный днс сервер еще называется кэширующий днс сервер
судя по nist документу днс клиент на компе зовется stub resolver а рекурсивный днс
сервер зовется резолвер.
если stub резолвер или рекурсивный днс умеют делать dnssec проверку тоесть умеет 
проверять цифровые подписи то он зовется validating resolver
TLD это top level domain
читаю вот это rfc9499: получается резолвер это полноценный днс клиент. тоесть мы ему 
даем запрос а он умеет обратиться к днс серверам и сам полностью выполнить запрос, тоесть
он умеет сам обартиться на корневой днс, потом на TLD DNS , потом на авторитивный. получит
в итоге ответ и нам его вернуть. stub resolver насколько я понял это неполноценный днс
клиент. его неполноценность в том что в ответ на наш запрос он не умеет самостояетельно
разработать дорожную карту и пролазить по нескольким днс серверам начиная с корневного
чтобы в итоге докопаться до ответа. вместо этого ему надо прописать рекурсивный днс
сервер и все что он может это послать запрос на этот рекурсивный днс сервер и ждать 
от него ответа. вот что значит stub resolver. iterative mode of server - это неркурсивный
режим работты сервера. в нем как я понял сервер неможет выдывать ничего кроме того
что у него хранитьься на нем самом неполсередственно в его базе или может выдать 
ссылку на другой днс сервер (где он ее берет незнаю). нетлько сервер но и резолвер
тоже может работать в iterative modeю насколько я понимаю этот режим для резолвера
означает то что резолвер сам лазиит по нерекурсивным серверам начиная от корневого
и выше пытаясь найти ответ на реквест. рекурсивный ржим работы сервера это когда он 
берет от резоолвера запрос и начаинает шариться по другим днс серверам пыатаясь найти
ответ. также он может его выдать из своего кеша.  сервер начинает работать в рекурсивном
режиме тлоько если прилеетел запрос с флагом RD. тогда он исполняет запрос и обратно
шлет ответ с выставленными флагами RD и RA
честно что такое итеративный режим сервера я поняли и реркусивный режим сервера  я понял 
из rfc. а что они имели ввиду под итеративный резолвер и рекурсиный резолвер по мне хуй
знает - как я понимаю рекурсиный резовлер это стаб резолвер тоесть это резолвер который
шлет запрос на рекурсивный серввер и ждет конечного ответа а итеративнйы резовлер это
ткой который сам ашрится по днс серверам пока ненайдет ответ. 
рекурсивный query - кьюри у которого установлен RD бит.
нерукурсивный кьюри - у котрого бит RD сброшен
full service reslver - это резовлер который делает запрос на рекурсивный днс 
и кэширует ответ. оказеся бывает DoQ - dns over quic
security aware resolver - как  я понял это днс клиент который понимает что такое
записи RRSIG,DNSKEY,DS тоесть если он получит инфо об них от днс сервера то он 
сможет их коректно отрисовать на экране. я так понял. 
еще раз хочу коснкуться вот этой темы
	Resolver - полноценный днс клиент. он берет реквест от человека, лезет
	на корневой сервер, потом на TLD сервер . потом на автританый сервер. находит 
	наконец ответ и выждает обратно.

	Stub Resolver - ээто днс клиент но неполноценный. вместо того чтобы самому 
	лезть на корневой сервер, потом на TLD сервер, потом на авторитарный сревер 
	он просто передает запрос на рекурсиный сервер и ждет готовый ответ

	Security-Aware Stub Resolver - это стаб резолвер но у него есть вот что он получив
	ответ от рекурсивного сервера понимает такие типы днс записей как RRSIG, DNSKEY, DS

	Validating Security-Aware Stub Resolver : что такое dnssec , это значит мы беерем
	запрос от человека. и нам надо скачать из днс срверов скажем 14 днс записей и проверить
	среди них цифровые подписи. так вот кто то должен составит план какие днс записи
	скачивать. а скачав эту кучу днс записей нужно их все суметь проверить на основе
	шифрования. тоест dnnsec он состоит из трех задач. задача номер один  - нужно 
	разработать список днс записей которые мы хотим получить. когда этот список 
	готов то нужно эти записи найти в днс системе лазия по разным днс серверамм.
	наконец когда эти записи оказались у нас на компе их нужно проанализировать 
	на основе шифрования в частоности чтобы понять подлинные эти записи или нет. 
	итак три задачи - составить список записей, както их скачать из днс систмы,
	проанализировать их. ттак вот слово stub означает что мы сами эти записи не ищем
	мы просто берем их имена и передаем в рекурсивный сервер а уже он их ищет
	а нам отдает в готовом виде. validaing означает что первую и третью задачу
	делаем мы.

    non-Validating Security-Aware Stub Resolver: эта штука вот что умеет. 
    stub значит эта штука передает запросы на рккурсивный днс сервер и он ищет записи а мы их     только принимаем в готовом виде.  Security-Aware ознааает что если от 
    рекурсивного сервера пришел ответ в котором есть записи с типом DNSKEY, RRSIG, DS
    то нащ клиент сможет их показать на экране. non-Validating означает что мы 
    толко отправляем на рекурсивный сервер исходный запрос. а составляет список какие
    днс записи нужно скаать чтобы проверить dnssec все это делаем не мы а этот рекурсивный
    сервер. нам он выдает готовы ответ. тоесть он проверкой dnssec занимается.


тепер я хочу поговорить о бите AD как в теле запроса от клиента 
так и в ответе от сервера. мол что он значит
что касается всовывания его в тело запроса от клиента то одна рфц писала что 
клиентунив коем случае активировать этот бит нельзя. также в рфц написано что если 
сервер получил от клиента такой запрос то он должен игнорировать этот бит в запросе.
сам же сервер в ответе может активиовать этот бит если сервер проверил и ганарнтирует
что все поля в ответе подтвердженны через dnssec, проверить подчеркну должен сам сервер.
я почему про этот бит упонямянул. потому что dig по деолфту этот бит активирует  в поле
запроса. в rfc6840 они пишут что мол они обновили политику и что клиент может слать
на сервер в поле запроса бит AD и этим он типа среверу сообщает что он этот бит понимает 
и сервер поэтому может если считает нужным  в ответе этот бит установить. 
а сервер когда этот бит присывалает в ответе - когда он хочет нам показать что все 
поля в ответе были им сервером проверены на достоверность через DNSSEC
насколько я понял из практики если днс клиент шлет на сревер в запросе AD бит то 
это как бы просит этот рекурсиный днс сервер сделать dnsssec проверку. и если проверка
будет успешной то днс сервер нам пришлет в ответе выставленный AD бит обратно. 
показывают на примере. вот у нас есть домен cloudflare.com который точно имеет 
нормальный dnssec. доказываю это через delv

$ delv @8.8.8.8  cloudflare.com
; fully validated
cloudflare.com.		300	IN	A	104.16.132.229
cloudflare.com.		300	IN	A	104.16.133.229
cloudflare.com.		300	IN	RRSIG	A 13 2 300 20240904234128 20240902214128 34505 cloudflare.com. O10ZFjvwPlFS6hvwvSV//P2U/meAgObf8E+/EEkZcakBWQc0jRzVDURt 7FKYbXzdGtWsoqGpAfv/NECW1iLcjw==


так вот делаем запрос через dig и в query выставляем флаг AD

	$ dig @1.1.1.1   +qr  +ad      cloudflare.com

;; Sending:
;; flags: rd ad; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1


;; Got answer:
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

видно что у меня в теле запроса выставлен AD флаг. и в теле оответа 
он тоже выставлен. 
тоесть 1.1.1.1 за нас проверил что для cloudfalre.com dnssec проверка 
прошла успешно


сайт usa.gov тоже имеет установленный dnssec

$ delv @8.8.8.8   usa.gov
; fully validated

посмотрим что покажет dig

$ dig @1.1.1.1   +qr  +ad      usa.gov

;; Sending:
;; flags: rd ad; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1



;; Got answer:
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1


сервер в ответе прислал ad флаг. 

а теперь выставим в запросе ad флаг но домен всунем который точно не имеет
dnssec записей

$ delv @8.8.8.8   mail.ru
; unsigned answer


$ dig @1.1.1.1   +qr  +ad      mail.ru

;; Sending:
;; flags: rd ad; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1


;; Got answer:
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1

и вот мы видим что в ответе от днс сервера нет флага ad тоесть
домен проверку на dnssec не прошел!

отсюда мой еше раз вывод - что если мы в теле кьюри устанавлиываем AD флаг то 
мы этим просим днс срвер проверить домен на dnssec коректность.
он проверяет и если ему все нравится то он в ответ пришлет AD флаг


далее будет очень я думаю огромный сложный и важный кусок.
этот кусок будет о том а как же программы резолвят DNS имя в IP адрес. до этого 
момент все внимание было на том что надо в линуксе прописать прпиавльные днс или 
нужно правильно настроить днс клиент systemd-resolved и потом в /etc/resolv.conf 
прописать его сокет 127.0.0.53 и тогда любая программа читает /etc/resolv.conf 
видит там 127.0.0.53 и туда обращается и получаем шоколад. и например тут возникает
вопрос а как программа физически обращается к указанному днс серверу. и тут открывается
новое адовое поле. навскидку как я понимаю в glibc (тоест набор юзерского кода
в форме библиотек которые можно "подключать" к совей программе и получать написанные
кем то фнукции которые умеют делать разные полезны штуки) есть такие функции которые
видимо являются по своей сути stub resolver. тоесть мы укаывазем ip адрес рекурсивного
днс сервера , суем как паарметр в функцию glibc и она уже  умеет разоговаривать на 
днс языке с рекурсивным днс сервером. тоесть в глибц есть функции которые реализуют
фнукционал днс клиента. точнее стаб днс клиента. тоесть в глибц встроен стаб днс
клиент. если программа хочет обратиться  к рекурсивному днс серверу то ей ненужно
самой писать днс клиент. он уже написан как кучка функции в глибц. это как получается
глибц фунция write() она входит в глибц и ползвоялет нашей программы записать чтото 
на диск. нашей программе ненужно писать свой код который бы умел писать чтото на диск.
далее прикол в том что есть огромная куча юзер утилит предназначенных для того чтобы
от юзера принять с клавы имя домена потом пошебуршить в системе и вренуть IP, то
есть я говорю про юзер утилиты которые как бы являются днс клиентами. их в англ литература
называют DNS lookup утилиты. одна из них это 

	 $ host -t A  google.com
		google.com has address 142.250.186.110

пока не ушел в сторону маленькая штучка. в resolv.conf есть директива search
о ней можно почитть в man resolv.conf , она о том что ты в ней прописываешь домен
и тогда когда мы делаем резовлинг то она этот домен дописывает в реквест. например

	/etc/resolv.conf
	search  co.uk

если я будут вводить

	$ ping bbc

то резвовинг будет идти для bbc.co.uk

 ꀲ  $ host -t A   bbc
bbc.com has address 151.101.192.81
bbc.com has address 151.101.64.81
bbc.com has address 151.101.0.81
bbc.com has address 151.101.128.81


 $ nslookup  bbc

Non-authoritative answer:
Name:	bbc.com
Address: 151.101.192.81
Name:	bbc.com
Address: 151.101.64.81
Name:	bbc.com
Address: 151.101.0.81
Name:	bbc.com
Address: 151.101.128.81


можно указат несклько доменов для постановки. их нужно указывать через пробел


   /etc/resolv.conf
   search com co.uk

тогда при вызове bbc резолвер будет пробовать вначале найти bbc.com а потом 
bbc.co.uk

единсвтенная подстава что подстановка идет слева направо, тот хост который первым
найдется то и выиграл. 
по дефолту директива выглядит как 

	search .

тоесть мы пуляем хост vasya а резолвер пытается зарезолвить vasya.
так вот если мы после точки будем ставить любой домен то тогда тупо нихрена ничего 
неработает. просто пишет что ошибка
покаызываю

/etc/resolv.conf
nameserver 127.0.0.53
search  . com co.uk

  $ host -t A   bbc
Host bbc not found: 5(REFUSED)

 $ host -t A   gmail
Host gmail not found: 5(REFUSED)

почему точка так хреново вляеи я не знаю. ее просто нахрен нужно убрать.


search  com co.uk

и все будет отлично

правда опять же прикол. какиеото утилиты почемуто игнориуют эту опцию

 $ host -t A   bbc
bbc.com has address 151.101.192.81
bbc.com has address 151.101.128.81
bbc.com has address 151.101.64.81
bbc.com has address 151.101.0.81


 $ curl bbc
curl: (6) Could not resolve host: bbc

тоесть утилита host с ней все окей. а курл шлет нахрен.
итак директива search в resolv.conf она раобтает только нужно из нее драную точку
убрать. 

кстати еще одну утилиту можно заметить я заюзал это nslookup


так еще отойду в сторону:
qr флаг. если он  устанолвен то это значит что данная секция это ответ.
если он не устанолвен то эта секция это запрос

$ dig @1.1.1.1   +qr  +ad      mail.ru

;; Sending:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 30811
;; flags: rd ad; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1


;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 30811
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1
          /\
          ||
          ||
         вот он где стоит



еще раз про флаги RD RA.
если мы хоим чтобы днс сервер обрабоатал наш запрос в режиме рекурсивном нам 
надо в теле кьюри выставить RD (recursive desirble) и если сервер подержвает этот реэим
то он выоплнит нашу простбу. и в ответе он выставит два флага RD RA (recursive available)
поэтому если в вответе стоит RD RA значит наш запрос обоабатыатьлся сереров в реукрсивном
режиме


так вот далее я говорю про такую хуй  пойми как описанную вещь как 

	Name Service Switch

название хрен пойми какое и описание такого же качества.

значит расказываю как я это все плохо понял - в glibc (набор функций программ которые
ктото когда то написал чтобы можно было их к своей программе подключать и не выдумывать
велоисипед) имеет ряд функций которым для работы нужно лазить в системные конфиги на компе
и читать оттуда данные. и вот людям пришла вот какая идея - предположим такой то фукции
нужно пока что лазить в два файла /etc/hosts и /etc/resolv.conf 
мы можем внутри нее вбить имена этих файлов и все окей. но положим что завтра ей нужно
лазит уже в три файла. значит нужно эту функцию перекомпилировать. давайте вместо 
этого создадим один конфиг. в этом конфиге укажем группы файлов которые имеют одно 
назначение, например групппа файлов отвечающая за резолвинг доменного имени в IP адрес
(назовет эту группу hosts), группа файлов в кторых сидят имена юзеров и их пароли (группа
passwords), они эти группы называют почемуто "базы данных". так вот в каждой группе
можно указывать название плагина - это шаред либрари. в которую можно делать обращение
а она уже сама лезет в те файлы за которые она отвечает и выдает либц функции ответ. тоесть
еще раз как было раньше. если фнукция либц getaddrinfo() она при своей работе чтобы
зарезолвить днс имя в IP адрес лазила в два файла которые были у нее прописаны в ее
коде это файлы /etc/hosts и /etc/resolv.conf  если мы хотим чтобы эта функция искала
ответы еще в одном файле то ее нужно перекомпилировать. (так они говоряи)
поэтому создали конфиг файл /etc/nsswitch.conf в нем указываем группу файлов которая 
отвечает за какое то направление. например группа называется hosts она отвечает за файлы
в которых ест доменные имена и их IP. в этой группе указываем имя плагина. плагин это 
шаред либрари. написанная по стандарту nss. мы ее имя вписываем в эту групппу в этом
файле nsswitch.conf таких плагинов можнеть быть дохуя. каждйы из них умеет лазить в своей
кучке файлов. нашей исходной функции getaddrinfo() типа уже ненадо знать ничего про 
коннтенркетные файлы. она заходить в nsswitch.conf ищет строку hosts, в ней указаны в
строе имена плагинов. она их загружает подключает вызывает. и они уже сами ищут в тех
файлах за которые они отвечают. таиким макаром за счет этих плагинов можно бодро
расширять источкиники поиска. и вот эта вся хрень называется "Name Service Switch
", настраиывается она в файле nsswitch.conf
вглядит он вот так

passwd: files systemd
group: files [SUCCESS=merge] systemd
shadow: files systemd
gshadow: files systemd

publickey: files

hosts: resolve files myhostname dns
networks: files

protocols: files
services: files
ethers: files
rpc: files

netgroup: files


на даный момент в нем нас интерсует одна строка 

hosts: resolve files myhostname dns

она говорит о том что если нашу глибц фунцию интересует резволвинг доменного
имени в IP адрес то нужно загрузить и запустить nss плагины с именами:
	resolve
	files
	myhostname
	dns

обычно рабоает это так. запускется самый левый плагин если он находит ответ то 
дальше следущий плагин не загруажается и поиск прекаращается.

плагины их имена в этом файле имеют прямую связь с именами шаредо либрари на диске
кстати слово lookup означает поиск , ее отличие от search втом что lookup подразу
мевает что то что мы ищем точно есть и есть точный метод как это искать , обычно поиск
lookup означает поиск по какомуто индексу. как слово в словаре по индексу. 

значит плагины все имеют название файла в виде

	libnss_имя_.so.?

все эти плагины лежат вот тут

# ls -1 /usr/lib/libnss_*
/usr/lib/libnss_compat.so
/usr/lib/libnss_compat.so.2
/usr/lib/libnss_db.so
/usr/lib/libnss_db.so.2
/usr/lib/libnss_dns.so.2
/usr/lib/libnss_files.so.2
/usr/lib/libnss_hesiod.so
/usr/lib/libnss_hesiod.so.2
/usr/lib/libnss_mdns4_minimal.so.2
/usr/lib/libnss_mdns4.so.2
/usr/lib/libnss_mdns6_minimal.so.2
/usr/lib/libnss_mdns6.so.2
/usr/lib/libnss_mdns_minimal.so.2
/usr/lib/libnss_mdns.so.2
/usr/lib/libnss_myhostname.so.2
/usr/lib/libnss_mymachines.so.2
/usr/lib/libnss_resolve.so.2
/usr/lib/libnss_systemd.so.2
/usr/lib/libnss_winbind.so.2
/usr/lib/libnss_wins.so.2


как можно видеть на конце либо не стоит ничего либо цифра 2. 
как я понял это для разных версий глибц. какойто в еэтом смысл если на компе
стоит одна версия глибц непонятно
там где цифра 2 это для более последней версии глибц


# ls -1 /usr/lib/libnss_*.so.2
/usr/lib/libnss_compat.so.2
/usr/lib/libnss_db.so.2
/usr/lib/libnss_dns.so.2
/usr/lib/libnss_files.so.2
/usr/lib/libnss_hesiod.so.2
/usr/lib/libnss_mdns4_minimal.so.2
/usr/lib/libnss_mdns4.so.2
/usr/lib/libnss_mdns6_minimal.so.2
/usr/lib/libnss_mdns6.so.2
/usr/lib/libnss_mdns_minimal.so.2
/usr/lib/libnss_mdns.so.2
/usr/lib/libnss_myhostname.so.2
/usr/lib/libnss_mymachines.so.2
/usr/lib/libnss_resolve.so.2
/usr/lib/libnss_systemd.so.2
/usr/lib/libnss_winbind.so.2
/usr/lib/libnss_wins.so.2



соотвесвтенно если я щас напмню как выглядит nsswitch.conf

passwd: files systemd
group: files [SUCCESS=merge] systemd
shadow: files systemd
gshadow: files systemd

publickey: files

hosts: resolve files myhostname dns
networks: files

protocols: files
services: files
ethers: files
rpc: files

netgroup: files

то видно что  в нем имена плагинов вот такие

	files
	systemd
	resolve
	myhostname
	dns


так вот им соовествуют шаред либрари вот такие

	libnss_files.so.2
	libnss_systemd.so.2
	libnss_resolve.so.2
	libnss_myhostname.so.2
	libnss_dns.so.2

тоесть я говорю есть прямое соовпсвтие то как плагин запиывается в nsswitch.conf
и как выглдяит его имя файла на диске

как я нашел определение что такое NSS у этого чувака (https://ldpreload.com/blog/testing-glibc-nsswitch) то NSS это система которая позволила рутины которые делают
различный name lookup (user name lookup, host name lookup, group name lookup) релизовать
в форме внешних  плагинов. внешние имеется ввиду что их код присуствуует не внутри 
фнукций libc а в виде внешних модулей. тоесть можно libc код осталвять нетронутым
а плагины может клепать кто хочет и когда хочет. тоест NSS это программный стандарт
интерфейс который видим в коде си программы подключается вот так 

	#include <nss.h>

который позволяет функциям из glibc выполнять различный *name* ( dns name, user name, host name, group name) поиск в текстовых файлах лежащих на компе через внешние подключаемые 
плагины . имена этих плагинов суются в файл nsswitch.conf каждый плагин умеет искать
там где ему положено. и получается также то что фкнция glibc скажем ей надо найти какой 
id у такого то username она лезет в nsswitch.conf там ищет строку  passwd


passwd: files systemd


тогда она загружает плагин files в виде шаред блиииотеки

		libnss_files.so.2

и както ее там запускает и эта библитека ищет где то где записано внутри этой
библиотеки (наша исходная фнкция об этом не парится) это имя юзера и его id,
если там этого нет то наша глбиц фкнция подгружаем следущий указанный в строке плагин
systemd

	libnss_systemd.so.2

и уже этот плагин ищет эту инфо. 
таким образом если у нас есть куча плагинов по этой теме мы можем их все прописать в это
й строке passwd в nsswitch.conf и они нам автоматом расшиярят те места в которых надо
искать имя юзера. код исходной глибц фнукции при этом не поменялся никак. 
и наей иходной глибц фнукции ненужно уметь нигде искать. эту конечную работу делают
плагины. 

как я уже сказал группы файлов почемуто в nsswitch.conf называются базами данных

passwd:
group: 
shadow: 
gshadow:
publickey: 
hosts: 
networks: 
protocols:
services: 
ethers: 
rpc: 
netgroup: 

по мне название уебищное. при чем тут базы данных. а имена плагинов которые пишутся
справа они называют сервисами. по мне это очередное уебищное название.

рассмотим еще раз строчку hosts:

	hosts: resolve files myhostname dns

к этой базе данных обращается глибц функция getaddrinfo() для того чтобы найти в 
базе данных доменное имя и соотсвтуающий ему IP
тоесть как работает этот getaddinfo() глибц фцнкия. ей надо найти доменное имя и IP
она подключается к NSS  видимо вот так

	#include <nss.h>

и делает  я думаю какойто вызоыв какойто фнкции из этого заголовка .h
и передает это nss фнукции доменное имя которое надо найти и название базы "hosts:"
далее уже эта nss фнукция лезет в nsswitch.conf смотрит какие плагины стоят в строке 
hosts:
видим что первый плагин это resolve
тогда она загружает файл 

		libnss_resolve.so.2

и запускает этот плагин. передавая ему доменное имя. 
далее этот плагин рабтает. ищет там где у него прописано доменное имя. если 
ненаходит. то загружаетя следущий плагин  files тоесть подгружается файл 

	libnss_files.so.2

и запускается. он ищет доменное имя на компе в файле

	/etc/hosts

итак мы проббгеаемся по всем плагинм пока ненайдем заказанный домен 

тут я хочу сказать что изначально плагины искали просто в файлах на компе. 
потом пояивлись плагины которые ищут в сети. 

щас я распишу конкнретно что где и как ищут кокнентно плагины из строки hosts:

	hosts: resolve files myhostname dns

плагин resolve это 		libnss_resolve.so.2   это плагин который ищет доменное имя и ip
через службу systemd-resolved, эта служба это бинарник /usr/lib/systemd/systemd-resolved
плагин общается с этим бинарником через D-bus хотя по мне это уже лищняя подробность.
systemd-resolved это stab днс клиент который будет искать заказанное у него доменное
имя через обращение к рекурсивному внешнему днс серверу. 

плагин files это файл libnss_files.so.2 он ищет заказнный домен в файле /etc/hosts

плагин myhostname это файл libnss_myhostname.so.2  и он предназначен для того чтобы 
найти IP адрес для доменов с именами:

  того который происан в /etc/hostname
  "localhost" and "localhost.localdomain
  _gateway
  _outbound


плагин  dns это файл   libnss_dns.so.2  и этот плагин является "нативным" "встоенным"
днс клиентом от glibc. нассолкьо я понимаю это stab dns клиент. тоесть он сам не будет
делать итеративные кьюри а он будет делать запрос к рекурсивному днс внешнему серверу
который прописан в /etc/resolv.conf  , это значит что кодга этот плагин будет 
азпущен то ОН САМ откроет resolv.conf нам этого руками в нашей программе делать 
ненадо. этот плагин обычно в литератиуре называется glibc resolver. 

вопрос как найти српавшку по каждому из этих плагинов. а вот так 

apropos	libnss_files.so.2
apropos	libnss_systemd.so.2
apropos	libnss_resolve.so.2
apropos	libnss_myhostname.so.2
apropos	libnss_dns.so.2

в итоге есть справка по этим плагинам
	man nss-systemd
	man nss-resolve
	man nss-myhostname

к сожалению для плагинлов files и dns мануал не нашел.
могу скзаать что плагин dns читает конфиг файлы

	/etc/resolv.conf  (man resolv.conf)
	/etc/host.conf    (man host.conf)

плагин file читает 
	
	/etc/hosts  (man hosts)


как на практике проверить что какая то программа юзает систему NSS.
вот так. надо запустиь strace и там обязательно дрлжно быть видно что был 
открыт файл /etc/nsswitch.conf , это обязатеьно должно случиться. 
и после этого программа должна открыть файл с плагином. 
давай убедмимся для программмы ping

 $ strace -e openat -f ping -c1 google.com
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/usr/lib/libnss_resolve.so.2", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/gai.conf", O_RDONLY|O_CLOEXEC) = 5

программа пинг ей нужно зарезолвить днс имя в ip адрес. поэтому она если юзает
NSS то должна обращаться к строке hosts:

	hosts: resolve files myhostname dns

в этой строке первый плагин это resolve. поэтому наш пинг дрлжен открыть файлы
 	"/etc/nsswitch.conf"
 	"/usr/lib/libnss_resolve.so.2"

что как видно на strace он и делает! еиснвтенное не поянтно какого хрена он еще 
открвыает файлы 

	"/etc/host.conf", 
	"/etc/resolv.conf"

по крайней мере если они нужны плагину resolve то они должны открываться уже 
после того как открылся 

 	"/usr/lib/libnss_resolve.so.2"

ну да хрен с ним

система NSS исользуется не тлоько сеетвыми утилитами для резолвинга доменных имен в IP
но и например в утилите ls
так вот как я понимаю она с диска получает только айдишники (цифры) имени юзера
и его группы. а чтобы эти цифры превратить в имена то нужно сделать сопоставление 
резолвинг. и тогда ls для этого вызывает NSS 

	$ strace -e openat -f  ls -l
	openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 4
	openat(AT_FDCWD, "/etc/passwd", O_RDONLY|O_CLOEXEC) = 4`
	openat(AT_FDCWD, "/etc/group", O_RDONLY|O_CLOEXEC) = 4
	openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 4
	openat(AT_FDCWD, "/usr/lib/libnss_systemd.so.2", O_RDONLY|O_CLOEXEC) = 4

спрашивается а зачем? а затем что вот у нас ее вывод

$ ls -l
total 8
drwxr-xr-x   3 root   root     42 авг 29 08:27 backup
drwxr-xr-x   2 noroot noroot    6 июл 26 12:25 Desktop

судя по тому что запгружается плагин systemd то ls запрашиывает доступ в одну
из этих "баз"

passwd: files systemd
group: files [SUCCESS=merge] systemd
shadow: files systemd
gshadow: files systemd



тоесть уттилиты используют NSS гораздо чаще чем кажется!

кстати я хочу скзаать что плагин resolve он кэширует днс запросы. точнее кэширует
их не он а systemd-resolved к которому он обращается а вот  плагин dns он же gibc
resolver этого неделает

а давай ка убедимся что днс резовлингом домена locahost занимается утилита myhostname
для этого делаем вот так


# cat /etc/nsswitch.conf 
hosts: myhostname

 $  ping -c10 localhost
PING localhost (::1) 56 data bytes
64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.114 ms
64 bytes from localhost (::1): icmp_seq=2 ttl=64 time=0.097 ms
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.132 ms


$ strace -e openat -f ping -c1 localhost
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/usr/lib/libnss_myhostname.so.2", O_RDONLY|O_CLOEXEC) = 5

все подтвердилось !

теперь делаю вот так

hosts: files

 $  ping -c3 localhost
PING localhost (::1) 56 data bytes
64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.049 ms
64 bytes from localhost (::1): icmp_seq=2 ttl=64 time=0.105 ms
64 bytes from localhost (::1): icmp_seq=3 ttl=64 time=0.116 ms

 $ strace -e openat -f ping -c1 localhost
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/hosts", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/gai.conf", O_RDONLY|O_CLOEXEC) = 5


тоже работает!


так вот далее далеко не все сетеве утилиты испольщуют NSS. часть из них все делает сама!
я жто определяю по тому моменту что утилита не открывает файл /etc/nsswitch.conf
например утилита dig

 $ strace -e openat -f  dig mail.ru
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY) = 11


тоесть едиснвтеннре что она открыла из того чего бы открыла утилита испольуюящая NSS
это /etc/resolv.conf
все остальное она делает сама без NSS без его плагинов


посольку меня щас больше всего инерсуеют утилиты которые так и ли иначе делают днс
резволинг то узнаем какие из них используют а какие нет NSS


 $ strace -e openat -f  host -t A mail.ru 2>&1 | grep nsswitch

 $ strace -e openat -f  nslookup  mail.ru 2>&1 | grep nsswitch

 $ strace -e openat -f  ping -c 1 mail.ru  2>&1 | grep nsswitch
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 5

 $ strace -e openat -f  dig  mail.ru  2>&1 | grep nsswitch

 $ strace -e openat -f  resolvectl query   mail.ru  2>&1 | grep nsswitch

 $ strace -e openat -f  curl   mail.ru  2>&1 | grep nsswitch
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3


тоесть пока что из всех утилит только ping и curl юзают NSS !

кстати еще утилита getent

 $ strace -e openat -f  getent ahostsv4    mail.ru  2>&1 | grep nsswitch
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3

эта утилита она позволяет сделать lookup используя любую базу не тлоько hosts
я попозже в примерах это покажу


получается если у нас есть утилита которая лезет в сеть и ей нужно сделать резволвинг
домена в IP она может пойти двумя путями. либо она читает /etc/resolv.conf и сама 
делает запрос к рекурсивному днс, либо она использует NSS , подргружает плагины 
который прописаны в nsswtch.conf и просит эти плагины проделать эту работу. я так понимаю.

интересно то что файл /etc/resolv.conf это изначально файл который относится к NSS плагину 
dns. я так понял. это он из него читает свой конфиг и дальше делает запрос к рекурсивному
днс серверу. а щас в этот файл лазиют все утилиты которым не лень.

никога не думал что даже микрозадача резолвинга это такой огромный сложный трабл

получается файл resolv.conf это файл настройки для NSS плагина dns он же встроенный в глибц
днс резовлер. однако как мы уже видим этот файл читает все кому не лень.
c этим resolv.conf получается вот такая странная ситуация как я уже сказал вообще то
изначально это файл откуда читает nss dns плагин. но по факту с этого файла читают тоже 
все проги которые сами делают днс резовлинг без участия NSS.
с этим файлом вообще сложная эпопея. дело в том что его хоят поменять куча программ.
по дефолту NetworkManager его меняет, systemd-resolvd формирует свой такой файл и 
не один 

	/run/systemd/resolve/stub-resolv.conf
	/run/systemd/resolve/resolv.conf

и предлагает сделать /etc/resolv.conf симлинком на один из этих файлов
есть программа resolvconf она вот что предлагает. она как то там предлагает другим 
программам в нее пулять изменения а она как то будет это сама пропихиывать в resolv.conf
тоесть resolv.conf это какое то просто лобное место куда все хотят полазить и все поменять


далее я хотел осветить настройку  "trust-ad"
    $ cat /etc/resolv.conf 
 	...
 	options trust-ad

цитирую о чем она из man resolv.conf

trust-ad (since glibc 2.31)
                     Sets RES_TRUSTAD in _res.options.  This option controls the AD bit behavior of the stub resolver.  If a validating resolver sets the  AD
                     bit in a response, it indicates that the data in the response was verified according to the DNSSEC protocol.  In order to rely on the AD
                     bit,  the  local  system has to trust both the DNSSEC-validating resolver and the network path to it, which is why an explicit opt-in is
                     required.  If the trust-ad option is active, the stub resolver sets the AD bit in outgoing DNS queries (to enable AD bit  support),  and
                     preserves  the  AD bit in responses.  Without this option, the AD bit is not set in queries, and it is always removed from responses be‐
                     fore they are returned to the application.  This means that applications can trust the AD bit in responses if the  trust-ad  option  has
                     been set correctly.

                     In glibc 2.30 and earlier, the AD is not set automatically in queries, and is passed through unchanged to applications in responses.


как я понимаю смысл этого вот какой : файл resolv.conf он изначально предазначен как файл
конфигурирования nss плагина dns который является стаб резолвером и это его конфиг. 
так вот этот флаг в этом конфиге говорит этому резолверу чтобы он когда шлет запрос
на реркусивный внешний днс сервер чтобы он в query вставил флаг ad который как  я обсуждал
уже выше должен привести к тому что рекурсивный днс сервер должнен попробовать наш реквест
проверить через dnnsec и если ему это удастся чтобы он в ответ этот флаг прислал к 
нам тоесть к нашему днс резолверу а он этот флаг передаст приложению которые вызывало 
встроенный резолвер. без этой опции встроенный днс резволвер не будет вставлять флаг ad
в кьюри а если он таковой получит в ответе от рекурсивного днс сервера то он его уберет
из ответа при передаче ответа приложению которое вызывало встроенный днс резолвер
вобшем по факту если эту опцию в resolv.conf вставить

 	options trust-ad

и мы используем программу которая для днс резолвинга юзает nss, и если в nsswitch.conf
указан плагин dns


	/etc/nsswitch.conf

	hosts: dns

то этот плагин пошлет на внешний рекурсивный днс сервер запрос в теле кьюри прописав флаг ad
и таким макааром он попросит внешний рекурсивный днс сервер чтобы он сделал запрос через 
dnssec. и еси днссек проверка будет удачная то он в ответ нам тоже пришлет флаг ad.
таким образом мы добииваемся чтобы рекурсивный днс сервер делал за нас и для нас
dnssec запросы. вот какая практическая польза. теперь а как это проверить? как нам
провреить что ответ имеет ad флаг.  дело в том что если  мы используем dig где мы 
видим как выглдяит ответ  то dig он не использует NSS. 
кстати забавно что даже если мы для диг укажем сами на какой днс сервер ему
стучать он все равно читает resolv.conf

 	$ strace -e openat -f  dig @8.8.8.8  cloudflare.com +tls 2>&1 | grep resolv.conf
 	openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY) = 11

а это еще раз доказательство что он не юзает NSS
 	$ strace -e openat -f  dig @8.8.8.8  cloudflare.com +tls 2>&1 | grep nsswitch
    пусто

так вот - диг он не испльзует NSS, значит nss плагин не открывается не запускается.
значит опция 

	 	options trust-ad

из resolv.conf не учитывается дигом. по кракйней мере он не обязан. потому что файл
resolv.conf рассчитан как файл конфиг для nss dns плагина. и все его фишки в целом
толко для него. 

итак dig он неиспольщует NSS значит он сам формирует dns запрос без участия nss dns 
плагина. 

так вот получается нам нужна программа которая с одной стороны использует NSS
плюс нам надо чтоб в nsswitch.conf была подклчен dns плагин

	hosts: dns

плюс нам надо чтобы наша программа которая юзает NSS чтобы она нам на экране рисовала
ответ. а еще лучше и запрос. тогда мы сможем проверить что реально на основе опции


	 	options trust-ad

и туда улетает флаг ad и обратно он прилетает.
пока что из программа которые юзают nSS я знаю только ping и curl
они информацию о запросе и ответе по днс не показывают. более того да они конечно запрос
и не состалвяют. они кидают в nss имя домена а сам запрос к вншнему рекурсивной днс
серверу составляет плагин nss dns , он это делает сам. и о том как он это делает он
необязан сообщать наверх вызывавшей его программе

как я читал nss dns плагин не делает кэшифрования . не запоминает результат. 
но можно поставит демон nscd который делает но который якобы имеет баги.

также я читал что при изменении nsswitch.conf мгновенно изменения применяются
для нового реквеста к nss. написано что раньше если какойто процесс пользовал nss
то он читал этот файл один раз и больше его не трогал. а щас видимо сразу перечитывает.

щас поделаю запросы через nss через утилиту getent едиснвтенное что она не показывает
как идут запросы. она только показывает ответ. зато с помощью нее можно делать запрос
к любой "базе" NSS

я беру базу aliases. во первых у меня в nsswitch.conf нету ничего для этой базы это значит
что по дефолту будет заюзан плагин files. в мане написано что при использлвании сервиса
files читается файл /etc/aliases
щас проверим.

 $ strace -e openat getent aliases   abuse 
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/aliases", O_RDONLY|O_CLOEXEC) = 3

еще странно то что при использовании плагин files  я не вижу чтобы процесс
открывал этот плагин в виде файла 

	libnss_files.so.2

посмотрим как работает запрос к базе group
у нас в nsswitch.conf идет запись


	group: files [SUCCESS=merge] systemd

  $ strace -e openat getent group   noroot  2>&1
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/group", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libnss_systemd.so.2", O_RDONLY|O_CLOEXEC) = 3

вот видно что он внаале заюзал files правда сам плагин почемуто он не грузит
и залез в /etc/group
а потом залез в плагин systemd

а вот мы лезем в passwd базу

  $ strace -e openat getent passwd    noroot  2>&1
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/passwd", O_RDONLY|O_CLOEXEC) = 3

noroot:x:1000:1000:noroot:/home/noroot:/bin/bash


оказывается есть база protocols и через плагин files она лезет в /etc/protocols файл

  $ strace -e openat getent protocols   trunk-1  2>&1
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/protocols", O_RDONLY|O_CLOEXEC) = 3

trunk-1               23 TRUNK-1


есть база rcp и плагин files лезет в файл /etc/rpc

 $ strace -e openat getent rpc   sprayd  2>&1
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/rpc", O_RDONLY|O_CLOEXEC) = 3

sprayd          100012  spray


есть база services и плагин files лезет в файл /etc/services

⨨  $ strace -e openat getent services  ssh  2>&1
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/services", O_RDONLY|O_CLOEXEC) = 3

ssh                   22/tcp


есть база с паролями shadow и с плагином fules она лезет в файл  /etc/shadow

ну походу все интересное что можно было выжать из getent мы сделали. эта утилита
просто позволяет нам указать базу в которой искать и  ключ который искать и она покажет
что она нашла

еще пример

$  getent hosts  yandex.ru
2a02:6b8:a::a   yandex.ru


 $  getent ahostsv4  yandex.ru
77.88.55.88     STREAM yandex.ru
77.88.55.88     DGRAM  
77.88.55.88     RAW    
5.255.255.77    STREAM 
5.255.255.77    DGRAM  
5.255.255.77    RAW    
77.88.44.55     STREAM 
77.88.44.55     DGRAM  
77.88.44.55     RAW    


  $  getent ahosts  yandex.ru
77.88.55.88     STREAM yandex.ru
77.88.55.88     DGRAM  
77.88.55.88     RAW    
77.88.44.55     STREAM 
77.88.44.55     DGRAM  
77.88.44.55     RAW    
5.255.255.77    STREAM 
5.255.255.77    DGRAM  
5.255.255.77    RAW    
2a02:6b8:a::a   STREAM 
2a02:6b8:a::a   DGRAM  
2a02:6b8:a::a   RAW    

кстати поле TTL для днс  например 

ya.ru.			348	IN	A	77.88.44.242

здесь TTL=348

зачем она? а она затем как я понимаю что когда наш комп прочитает эту запись внутрь 
себя то он наверное ее хранит может быть где то в своих кишках? и TTL указывает
сколько надо хранить  а потом с компа удалить и заново к днс обратиться.


на счет NSS как мне делая код на си использовать этот функционал ?
как я понимаю надо в код подключить чтото типа

incude nss.h
и получишь доступ к функциям (API) это NSS
но это неточно

походу так и есть потому что glibc функция getaddrinfo() она достоверно известно что
она юзает NSS. загляен в код этой функции (https://github.com/lattera/glibc/blob/master/sysdeps/posix/getaddrinfo.c)
и что мы таам видим

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <ifaddrs.h>
#include <netdb.h>
#include <nss.h>     <===== !!!
..


мы видим как раз подключение nss.h
тоесть вот так этот функционал подключается к моему коду

еще там и вот такое есть

#include <nsswitch.h>

а вот как выглядят все строки из кода этой фнукции в которым встречается слово nss

#include <nss.h>
#include <nsswitch.h>
typedef enum nss_status (*nss_gethostbyname4_r)
typedef enum nss_status (*nss_gethostbyname3_r)
typedef enum nss_status (*nss_getcanonname_r)
  nss_getcanonname_r cfct = __nss_lookup_function (nip, "getcanonname_r");
	  enum nss_status inet6_status = NSS_STATUS_UNAVAIL;
	  enum nss_status status = NSS_STATUS_UNAVAIL;
	  if (__nss_not_use_nscd_hosts > 0
	      && ++__nss_not_use_nscd_hosts > NSS_NSCD_RETRY)
	    __nss_not_use_nscd_hosts = 0;
	  if (!__nss_not_use_nscd_hosts
	      && !__nss_database_custom[NSS_DBSIDX_hosts])
	      else if (__nss_not_use_nscd_hosts == 0)
	  if (__nss_hosts_database == NULL)
	    no_more = __nss_database_lookup ("hosts", NULL,
					     &__nss_hosts_database);
	  nip = __nss_hosts_database;
	      nss_gethostbyname4_r fct4 = NULL;
		fct4 = __nss_lookup_function (nip, "gethostbyname4_r");
		  nss_gethostbyname3_r fct = NULL;
		    fct = __nss_lookup_function (nip, "gethostbyname3_r");
		    fct = __nss_lookup_function (nip, "gethostbyname2_r");
			 be listed in /etc/nsswitch.conf).  Assume the
	      if (nss_next_action (nip, status) == NSS_ACTION_RETURN)
nss_interface_function (getaddrinfo)

тоесть если мы хотим юзать NSS то мы должны подключить ее в свой код

	#include <nss.h> 
	#include <nsswitch.h>

и начать юзать те функции которые она предоставляет. 

функция getaddrinfo() прибегает к NSS чтобы зарезолвит dns имя в серию IP но она 
еще потом это все конвертирует в такой тип данных чтобы это можно было потом напрямую
передать в bind() или connect() тоесть это не просто функция которая нам резволит 
днс имя в IP это нечто большее

код с примером исполльзования этой фнкции getaddrinfo() в коде 191.c (ествсвтенно его написал не я. его написали в интернете.)

$ strace  -e openat ./191.exe  
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libnss_resolve.so.2", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/gai.conf", O_RDONLY|O_CLOEXEC) = 3

соотвественно getadrinfo при ее вызове она лезет через nss в базу hosts:
поэтому у нас открывается файл nsswitch.conf  
кстати файлы

	/etc/host.conf
	/etc/resolv.conf

они оба являются конфиг файлами nss dns  плагина он же встроенный в глибц резолвер,
смысла файла host.conf несовсем понятен, ну да ладно, так как у нас плагин nss resolve
тоже является днс клиентом то видимо поэтому перед его открытием открываюься теже
файлы что и при открытии nss dns , поэтому мы видим эту полсдовательность

		"/etc/host.conf"
		"/etc/resolv.conf"
		"/usr/lib/libnss_resolve.so.2"


при этом понятно что в nswitch.conf у меня стоит вот так

	hosts: resolve files myhostname dns

я уверен что если я щас настрою вот так 

	hosts: dns

то уменя откроются вот такие файлы 


		"/etc/host.conf"
		"/etc/resolv.conf"
		"/usr/lib/libnss_dns.so.2"

проверяю, проставил в nsswitch.conf
		hosts: dns


茜  $ strace  -e openat ./191.exe  
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/gai.conf", O_RDONLY|O_CLOEXEC) = 3


кхм.. странно почему небыл открыт файл 

	libnss_dns.so.2

пробую по другому

  $ strace -e openat getent hosts mail.ru
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3

странно почемуто при 

	hosts: dns

и использовании проги которая использует NSS я не вижу того чтобы подгружался 
nss plugin dns 

ну да ладно. из теории известно что вообще то именно он используется

а если верну

	hosts: resolve

то все происходит четко по теории
открывается файл отвечающий за плагин resolve

	$ strace  getent hosts mail.ru  2>&1 | grep nss
	openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
	openat(AT_FDCWD, "/usr/lib/libnss_resolve.so.2", O_RDONLY|O_CLOEXEC) = 3

я кстати иду по этой статье щас ( https://www.gabriel.urdhr.fr/2020/04/20/linux-host-name-resolution/#fn2)
так вот там интересная штука показана. можно взять ELF файл и посмотреть какие функции
определены внутри этого файла. тоест скжаем если это shared библиотека то можно
посмотреть какие функции нам станут доступны при подключении этой библиотеки

возьем некоторые nss плугины и посмтрим на этот счет

  $ ls -1 /usr/lib/libnss_*.so.2
/usr/lib/libnss_compat.so.2
/usr/lib/libnss_db.so.2
/usr/lib/libnss_dns.so.2
/usr/lib/libnss_files.so.2
/usr/lib/libnss_hesiod.so.2
/usr/lib/libnss_mdns4_minimal.so.2
/usr/lib/libnss_mdns4.so.2
/usr/lib/libnss_mdns6_minimal.so.2
/usr/lib/libnss_mdns6.so.2
/usr/lib/libnss_mdns_minimal.so.2
/usr/lib/libnss_mdns.so.2
/usr/lib/libnss_myhostname.so.2
/usr/lib/libnss_mymachines.so.2
/usr/lib/libnss_resolve.so.2
/usr/lib/libnss_systemd.so.2
/usr/lib/libnss_winbind.so.2
/usr/lib/libnss_wins.so.2
 
кстати видно что есть плагин  с именем db
вопрос к какой базе он умеет поключаться. я нашел что вроде как к berkley db
я ее поставил

  # pacman -Sy db

но как я понял это какая то поделка. в том плане что у нее нет ни демона которым
ее стартовать , ни клиента чтобы к ней пдключаться. из того что я увидел обращение
к ней например делают из кода на си. поэтому поигрраться с ней неудалось. я хотел
в нее чтони бду записать а потом через NSS db считать.

итак смотрим внутрь плугинов какие функции они нам дают если их подгрузить

в плугине db этих фнукций просто дохрена
я их все не буду приводит
 $ readelf -Ws /usr/lib/libnss_db.so.2   | grep FUNC  | grep -v UND
    35: 0000000000005cd0   695 FUNC    GLOBAL DEFAULT   13 _nss_db_getrpcbynumber_r@@GLIBC_PRIVATE
    36: 0000000000002940   137 FUNC    GLOBAL DEFAULT   13 _nss_db_setgrent@@GLIBC_PRIVATE
    37: 0000000000005fa0   947 FUNC    GLOBAL DEFAULT   13 _nss_db_initgroups_dyn@@GLIBC_PRIVATE

что странно в плугинах dns и files якобы вообще нет фнкций
 
$ readelf -Ws /usr/lib/libnss_dns.so.2   | grep FUNC  | grep -v UND
$ readelf -Ws /usr/lib/libnss_files.so.2   | grep FUNC  | grep -v UND

$ readelf -Ws /usr/lib/libnss_myhostname.so.2   | grep FUNC  | grep -v UND
   123: 00000000000105b0    27 FUNC    GLOBAL DEFAULT   11 _nss_myhostname_gethostbyname2_r
   124: 0000000000010bd0    28 FUNC    GLOBAL DEFAULT   11 _nss_myhostname_gethostbyaddr_r
   125: 00000000000105d0   153 FUNC    GLOBAL DEFAULT   11 _nss_myhostname_gethostbyname_r
   126: 000000000000f980  1730 FUNC    GLOBAL DEFAULT   11 _nss_myhostname_gethostbyname4_r
   127: 0000000000010670  1376 FUNC    GLOBAL DEFAULT   11 _nss_myhostname_gethostbyaddr2_r
   128: 0000000000010050  1361 FUNC    GLOBAL DEFAULT   11 _nss_myhostname_gethostbyname3_r


$ readelf -Ws /usr/lib/libnss_resolve.so.2   | grep FUNC  | grep -v UND
   113: 000000000000e950  3200 FUNC    GLOBAL DEFAULT   11 _nss_resolve_gethostbyname3_r
   114: 000000000000f690  2831 FUNC    GLOBAL DEFAULT   11 _nss_resolve_gethostbyaddr2_r
   115: 000000000000f5d0    27 FUNC    GLOBAL DEFAULT   11 _nss_resolve_gethostbyname2_r
   116: 000000000000dee0  2662 FUNC    GLOBAL DEFAULT   11 _nss_resolve_gethostbyname4_r
   117: 00000000000101a0    28 FUNC    GLOBAL DEFAULT   11 _nss_resolve_gethostbyaddr_r
   118: 000000000000f5f0   153 FUNC    GLOBAL DEFAULT   11 _nss_resolve_gethostbyname_r

$ readelf -Ws /usr/lib/libnss_systemd.so.2   | grep FUNC  | grep -v UND
   172: 0000000000006a50    27 FUNC    GLOBAL DEFAULT   12 _nss_systemd_endspent
   173: 0000000000007910  1231 FUNC    GLOBAL DEFAULT   12 _nss_systemd_getspent_r
   174: 0000000000011e40  2495 FUNC    GLOBAL DEFAULT   12 _nss_systemd_initgroups_dyn
   175: 000000000000baf0  1978 FUNC    GLOBAL DEFAULT   12 _nss_systemd_getpwuid_r
   ...
   ...


соотвесвтенно в плагине resolve у нас два типа функций gethostbyname и gethostbyaddr
тоесть все логично. он либо ищет IP для домена либо наоборот

тоесть подкючается плагин. а потом я так понимаю в нем вызывается функция

далее статья пишет что пакет glibc поставляет nss плагины files и dns,
пакет systemd поставлет NSS плагины resolve , myhostname, mymachines

mymachines - типа для резволвинга виртуалок которые созданы через systemd короче
никто этим не занимтеся этот плагин неинтересен.

myhostname - это плагин про него можно прочитать тут

	man  nss-myhostname

там написано что он пригоден для днс резолвинга вот таких доменных имен

	local
	localhost
	localhost.localdomain
	_gateway
	_outbound

мне стало интересно а что какой IP он покажет для _gateway и _outbound

 $ getent hosts _gateway
192.168.47.179  _gateway

$ getent hosts _outbound
192.168.47.1    _outbound


а что это за ip адреса?

 $ ip -c r sh
0.0.0.0/1 via 172.16.50.1 dev tun0 
default via 192.168.47.179 dev wlp2s0 proto dhcp src 192.168.47.1 metric 20600 

 $ ip -c a sh  dev wlp2s0
    inet 192.168.47.1/24 brd 192.168.47.255 

получается что _gateway это ip гейтвея того который был до того как включил впн
а _outbound это ip адрес с которого в этот гейтвей мы ходим

убедимся что getent юзал плагин nss myhostname

 $ strace -e openat  getent hosts _gateway
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libnss_resolve.so.2", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/hosts", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libnss_myhostname.so.2", O_RDONLY|O_CLOEXEC) = 3

мы видим что да вконце концов был заюзан

	libnss_myhostname.so.2

про nss плагин resolve можно прочитать через

    man nss-resolve

там в частности написано что он идет как бы на замену nss dns плагину. написано 
что он умеет частично синтезировать то бишь резолвит локальные днс имена но тока
отчасти поэтому он отчасти перекрывает плагин myhostname но тока отчасти поэтому 
плагин myhostname рекомендуется тоже оставлять в nsswitch.conf
также написано что этот плагин это всего лишь фронтенд и он на самом деле обращается
к сервису systemd-resolved который есть ничто иное как бинарник /usr/lib/systemd/systemd-resolved и уже тот делает реально вот эту работу по резолвингу. так вот 
nss плагин resolve он обращается общается с /usr/lib/systemd/systemd-resolved через
сокет  AF_UNIX /run/systemd/resolve/io.systemd.Resolve 

щас я проверю а есть ли он у меня на компе
$ stat /run/systemd/resolve/io.systemd.Resolve
  File: /run/systemd/resolve/io.systemd.Resolve
  Size: 0         	Blocks: 0          IO Block: 4096   socket


правла статья в отличие от мана утверждает что плагин с демном общается через D-Bus.
я вот незнаю сокет который  я привел имеет ли отноение к D-Bus или нет? вмане ничего
про D-Bus не сказано.

длаее говорится что через resolvectl можно обратиться к systemd-resolved чтобы он 
нам зарезолвил днс имя. я посмтрел реаьно resolvectl входит в состав пакета systemd

# pacman -F  $(which resolvectl)
usr/bin/resolvectl is owned by core/systemd 256.5-1

тоесть походу пьемы resolvectl это cli, client доступа к systemd-resolved через
командную строку. 

в мане от resolvectl так и написано что он обращается к systemd-resolved
команла

		$ sudo resolvectl monitor

покажет какие днс запросы к systemd-resolved идут в рил тайме

		$ sudo resolvectl show-cache

покажет что в кеше щас лежит

а вот интерсено что еще можно делать

	$ resolvectl openpgp zbyszek@fedoraproject.org

я попробовал через dig такое не получить

вот еще интересны пример

    $ resolvectl tlsa tcp fedoraproject.org:443
_443._tcp.fedoraproject.org IN TLSA 3 1 1 85dadbdd506853d258213480f8688a7d5821294576195c79616a9dba576a1738
        -- Cert. usage: Domain-issued certificate
        -- Selector: SubjectPublicKeyInfo
        -- Matching type: SHA-256 -- link: wlp2s0

тоесть это днс запись типа TLSA

когда пишут libc resolver это имеют ввиду nss dns плагин

прикол в том что NetworkManager имеет свой сгенерированный как ему кажется resolv.conf
и лежит он в /run/NetworkManager/resolv.conf
об этом на самом деле я писал выше и еще можно прочитать в 

	man 5 NetworkManager.conf


далее еще раз о том что systemd-resolved тооже генерирует несколько resolv.conf 
один из которых можно выбрать чтобы на него направит симлинк /etc/resolv.conf


 $ grep -v '#'  /run/systemd/resolve/stub-resolv.conf 

nameserver 127.0.0.53
options edns0 trust-ad
search com

 $ grep -v '#'  /run/systemd/resolve/resolv.conf 

nameserver 1.1.1.1
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.47.179
search .

 $ grep -v '#'  /lib/systemd/resolv.conf

nameserver 127.0.0.53
options edns0 trust-ad


разница второго файла с первым в том что во втором файле указаны сугубо только 
внешние рекурсивные днс сервера , тоест какой бы днс клиент ни был он сразу направляется
на внешние рекурсивные днс сервера, а первый файл таков что он в качестве внешнего рекур
сивного днс сервера указывает локальный днс сервера установленный на компе а 
именно за адресом 127.0.0.53 сидит systemd-resolved , тоесть наш днс клиент будет
обращаться к нему а уже он будет обращаться к тем внешним рекурсинвынвым днс серверам
которые указанв в кофниге systemd-resoled (конфиг лежит в /etc/systemd/resolved.conf)
фишка такого варианта в том что systemd-resolved он кэширует данные которые через него
проходят. приколв в том что systemd-resolved явялется по своей сути  стаб днс клиентом
с функцией кэшиврования. тоесть тот запрос который на него приходит он перенаравляет
на внешний рекурсивный днс сервер. получает от него ответ и отдает его клиенту.
плюс запрос кэширует. так вот вопрос нахрена он тогда гененрериует  вот этот вариант
resolv.conf

 $ grep -v '#'  /run/systemd/resolve/resolv.conf 

nameserver 1.1.1.1
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.47.179
search .


если при таком вариант systemd-resolved вообще не будет задействован? тоесть программа
генерирует такой конфиг при котором она исползоваться вообще не будет!

разница между первым и третьим в том что в третьем нет строки search,
вот и всяразица. а что мешает туда добавить search ?


еще раз хочу сказать что под "TRADITIONAL GLIBC STUB RESOLVER" понимаю всроенный в 
glibc в его NSS компнент а именно в nss dns плагин днс резовлет или днс клиент.

наопмню что search эта то что мы делаем какоето имя домена в запросе
а днс клиент(резолвер) автоматом добавляет ему в хвост то что стоит в строке search
и уже это имя шлет на внешний рекурсинвый днс сервер. например мы указали

	saearch com

и в клиенте пишем 

	getent hosts   google

тогда getent у нас лезет в nswitch,conf
а там в строке

   hosts: resolver

значит задейстует плагин resover который поидее через локальный сокет обратиться в 
systemd-resolved котоырй прочитает resolv.conf в котором кстати может бывть вот так

	nameserver 127.0.0.53
	search com

и тогда получаетс что клиент днс systemd-resolved обратиться сам к себе (хаха)
и попросит сам себя обрабоать днс запрос, обратившис сам к себе он загляентет
в свой конфиг в /etc/systemd/resolved.conf обнаружит там указанынй внешний днс 
сервер 8.8.8.8 и сделает туда запрос и так как в resolv.conf был указан

   search com

а он понимает что это значит то он добавит к домену который у него запросили в хвост
еще com
тоесть если мы запросили google то он на 8.8.8.8 направиит имя google.com

можно и без getent можно обратиться через resolvectl . это прямой клиент в systemd-resolved

что интересно вариант через getent добавит к google еще и com
а вариант с resolvectl нет!

 : 왟  $ strace -e  openat   getent hosts google
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libnss_resolve.so.2", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/hosts", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/libnss_myhostname.so.2", O_RDONLY|O_CLOEXEC) = 3

2a00:1450:4001:81d::200e google.com

я вот не знаю толи сам getent прочитав resolv.conf и увидев там

	search com

добавляет этот com к google и потом сует в плагин libnss_resolve.so.2
толи плагин добавляет и уже сует в systemd-resolved

а вот resolvectl ничего не добавляет!
он даже resolv.conf нечитает

$ strace -e  openat  resolvectl query google
google: resolve call failed: No appropriate name servers or networks for name found
+++ exited with 1 +++

кстати ping так как он юзает NSS то если я ему задам 

  $ ping google

то он а точнее его запрос к NSS зарезолвить ему доменное имя google как google.com
и вернет ему IP от google.com

  $ ping google
PING google.com (142.250.186.142) 56(84) bytes of data.
64 bytes from fra24s07-in-f14.1e100.net (142.250.186.142): icmp_seq=1 ttl=57 time=248 ms

кстати curl он же тоже резволит доменное имя в IP чрез NSS поэтому

 瀪  $ curl -v google
* Host google:80 was resolved.
* IPv6: 2a00:1450:4001:81c::200e
* IPv4: 216.58.206.46
*   Trying 216.58.206.46:80...

тут видно что я ему скормил домен google он его передал NSS а тот его перевел
в google.com и нарпавл на внешнйи днс сврер и он вернул ip от google.com

* Connected to google (216.58.206.46) port 80
> GET / HTTP/1.1
> Host: google
но воттут прокол. ip то он он нашел.  а хост в протокол HTTP вставил прежний
просто google

> User-Agent: curl/8.9.1
> Accept: */*
> 
* Request completely sent off

поэтому гугл шлет его нахрен. с ошибкой

< HTTP/1.1 404 Not Found  <=====================!
...
...
  <title>Error 404 (Not Found)!!1</title>

поэтому честно говорят вот эта фича "search" в resolv.conf она вроде как 
беды несет.

тоесть получаетс вот как. мы верхнеувроенвой программе подсосываем на самом деле
неверное доменное имя. эта программа его передает вниз в NSS для резволвинга. 
она задним числом молифицирует это доменное имя и находит для него IP. наверх 
она отдает тлько IP а о том что она модифиицировала исходный домен она умалчивает
и верхнеуровенвая программа думает что IP ей дали от исходного домена. но этоже 
брехня. IP ей дали от совершенно другого доаменма. поэтмоу с пинг такой номер
типа успешно проказывает а с курл уже нет.
поэтому пока что я думаю что опция "search" это гадость причинящая ошибки.

еще насолкко я понял systemd-resolved не поддерживает так называемй PER-Interface DNS
тоесть это когда у нас для кажого сетевого интервейса назначааются свои днс 
сервера которые за этим интерфейсом сидят. и также назначаются домены которые за этими
интерфесами сидят. тогда если мы вводим запрос к днс то днс клиент смотрит за каким
интерфейсом сидит домен в запросе и пуляет его в нужный интфрейс в нужный днс
сервер. например

интрфейс 01
DNS 1.1.1. 
domain com

интфрейсе 02
dns 2.2.2.2
домен net

мы делаем ping vasya.com 
тогда для резволвинга этог домена запрос напрвяется через интерфсей01 к 1.1.1.1

это очень актуально кога унас впн коннекты есть а за ним свой локальный домен.

я знаю что так точно можено делать с поомощью dnsmasq, но помоему через systemd-resolved
так несделать. 
кстати dnsmsq можно поставить отдельно а можно использовать dnsmasq плагин к NetworkManager

я уже написал что 

	$ resolvectl

это cli к systemd-resolved 

тоесть мы укаызвамемм домен через resolvectl и он этот реквест напрямую шлет сразу
к systemd-resolved
тоест у нас есть как бы днс резолвер в форме демона systemd-resolved.
к нему есть cli который позволяет запрос из командной строки перенаравить этому демону.
этот cli это resolvectl. нормальная схема клиент-сервер
все понятно

но тут на сцену вылезает еще одна утилита это 

	$ systemd-resolve

а это что такое ?
ОКАЗЫВАЕТСЯ! systemd-resolve это симлинк на resolvectl!!! 

$ stat $(which systemd-resolve)
  File: /usr/bin/systemd-resolve -> resolvectl
  Size: 10        	Blocks: 0          IO Block: 4096   symbolic link

об этом кстати инфо  я нашел в мане! но не мане который идет к моему компу. нееет!
я нашел ее в мане от убунты

resolvectl is a multi-call binary, which previously was named "systemd-resolve" and used
       slightly different parameters. When it is invoked as "systemd-resolve" (generally achieved
       by means of a symbolic link of this name to the resolvectl binary), it runs in
       compatibility mode. For details on the specific parameters and calling syntax, see the
       output from systemd-resolve --help. Calling the binary as "systemd-resolve" is deprecated
       and should only be done for backwards compatibility. All current and new use should call
       the binary as "resolvectl".


что такое multi-call binary. это код который проверяет arg[0] при запуске тоесть он 
смотрит как называется файл под которым его запустили. и если файл называется resolvectl
то он активрует один свой кусок а если файл назыаывали systemd-resolve он актиуирует
другой кусок. и как мы видим написано что раньше файл назывался systemd-resolve
а потом его переимновали в resolvectl но оставили и старое название для совместимости.
в  общем получается про systemd-resolve можно забыть. это старое называние. новое
название resolvectl и его надо юзат. (хотя по мне новое нвазавание более хуеовое)

кстати можно вот такую статитсиику посмотреть
	$ sudo resolvectl statistics

...
...
Cache                                            
                         Current Cache Size:  176
                                 Cache Hits:  706
                               Cache Misses: 1097
                                                 
...
...                                                 
DNSSEC Verdicts                                  
                                     Secure:  490
                                   Insecure: 1325
                                      Bogus:    6
                              Indeterminate:    0


тут ксатти я маолек непонимаю кто занимается dnssec проверкой? именно наш systemd-resolved
или он эту работу поручает тому рекурсивному днс серверу которому он запросы посылвает?
с dig все понятно он это не умеет сам проверяять. с delv все понятно он сам это делает.
я думаю что systemd-resolved тоже проверяет сам потому что - у него в кеше лежат DNSKEY
записи. а зачем они ему нужны только если он их скачивает. а скачивать он их будет
только если онсам делает dnsssec проверку

вот например делаю  я запрос
 $ resolvectl -4  query cloudflare.com
cloudflare.com: 104.16.133.229                 -- link: tun0
                104.16.132.229                 -- link: tun0

-- Information acquired via protocol DNS in 1.7ms.
-- Data is authenticated: yes; Data was acquired via local or encrypted transport: yes
-- Data from: cache

вот эта строка Data is authenticated: yes обозначает что данные подтверждвены по dnssec
а теперь смотрим что лежит в кеше демона

	$ sudo resolvectl show-cache

cloudflare.com IN AAAA 2606:4700::6810:85e5

cloudflare.com IN AAAA 2606:4700::6810:84e5

cloudflare.com IN DS 2371 13 2 32996839a6d808afe3eb4a795a0e6a7a39a76fc52ff228b22b76f6d63826f2b9

cloudflare.com IN DNSKEY 257 3 ECDSAP256SHA256
        mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+GqJxpVXckHAeF+KkxLbxILfDLUT0rA
        K9iUzy1L53eKGQ==
        -- Flags: SEP ZONE_KEY
        -- Key tag: 2371

cloudflare.com IN DNSKEY 256 3 ECDSAP256SHA256
        oJMRESz5E4gYzS/q6XDrvU1qMPYIjCWzJaOau8XNEZeqCYKD5ar0IRd8KqXXFJkqmVfRvMGP
        mM1x8fGAa2XhSA==
        -- Flags: ZONE_KEY
        -- Key tag: 34505

днс записи с типом DNSKEY асболютно не могут попасть на комп чреез обычные запросы 
толко если их не  запрашивал днс клиент с целью проверки по DNSSEC
значит systemd-resolved сам проеряет dnssec! что хорошо!

 я прям помню вот эти keyid = 2371 и 34505 у клаудфлеер 

вопрос тлоько в том какой из них ZSK ключ а какой KSK ключ

 ^ 蚕  $ dig DNSKEY cloudflare.com +multi

;; flags: qr rd ra ad; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; QUESTION SECTION:
;cloudflare.com.		IN DNSKEY


;; ANSWER SECTION:
cloudflare.com.		1721 IN	DNSKEY 256 3 13 (
				oJMRESz5E4gYzS/q6XDrvU1qMPYIjCWzJaOau8XNEZeq
				CYKD5ar0IRd8KqXXFJkqmVfRvMGPmM1x8fGAa2XhSA==
				) ; ZSK; alg = ECDSAP256SHA256 ; key id = 34505
cloudflare.com.		1721 IN	DNSKEY 257 3 13 (
				mdsswUyr3DPW132mOi8V9xESWE8jTo0dxCjjnopKl+Gq
				JxpVXckHAeF+KkxLbxILfDLUT0rAK9iUzy1L53eKGQ==
				) ; KSK; alg = ECDSAP256SHA256 ; key id = 2371

полуаетя key id = 34505 это ZSK 
а key id= 2371 это KSK

у resolvectl это имеет названия

 -- Flags: SEP ZONE_KEY
 -- Key tag: 2371

 -- Flags: ZONE_KEY
 -- Key tag: 34505


понятно!

так значит с разницей между systemd-resolve и resolvectl прояснили!
(кошмар какйото )

парень вот в этой статье (https://www.gabriel.urdhr.fr/2020/04/20/linux-host-name-resolution/#fnref2) указал что обратиться к systemd-resolved
можно и через resolvectl и через systemd-resolve

	resolvectl -4 query www.example.com
	resolvectl -6 query www.example.com
	systemd-resolve -4 www.example.com
	systemd-resolve -6 www.example.com

но он нерасписал какая между ними связь и разница


а есть еще одна фигня это программа resolvconf. что еще хуже она есть в классической
модификации от дебиан а есть в модицифкации от openresolv. на арче стоит openresolv
тоест она называется resolvconf но под капотом openresolv
нахрен она нужна. типа она нужна для того что - если у нас на компе несколько 
прогаимм каждоая из которых хочет менять resolv.conf то вместо этого можно так 
настроить те программы и этот resolvoconf что те прогарммы меняют некие вспомогательные
конфги а resolvconf читает эти конфиги и уже формирует resolv.conf типа так что в нем
отражаются все хотелки тех программ. прикол в том что в списке поддреживаемых программа у resolvconf это 

          nss dns
          dnsmasq
          named
          pdnsd
          unbound

а systemd-resolved в этом списке нет!

значит я обнаружил что у меня нет ничего из этого кроме nss dns
поэтому я захотел удалит openresolv пакет, а он зависит от пакета netctl
а он явялется еще одним менежером сети наряду с NetworkManager который исплоьую
и systemd-networkd который я не использую.  в итоге я удалил 

	openresolv
	netctl

и избавился от утилиты resolvconf котоаямне нахрен не сдалась потму что мне resolv.conf
генериурет systemd-resolved и мне этого достоатчтно

так вот есть еще один прикол. если взять и создать симлинк

  ln -s $(which resolvectl) /usr/bin/resolvconf

то он сможет выполнять ограниченный функционал от "классического " resolvconf.
даже разбтарться не буду. мне это нахрен ненадо.

ад какйтто

вот я нашел синтакс resolv.conf
search
The search option accepts up to six domains, separated by tabs or spaces. This is used if the resolver receives a request without any dots in it. It will then try to resolve the query with the search domain appended, then the original request. For example, if the search domain was example.com, and http://test/index.html was requested, it would first query http://test.example.com/index.html, and then http://test/index.html.

domain
The domain directive is an obsolete name for the search directive that handles one search list entry only. For more syntax options, check man 5 resolv.conf. 


хотя по мне пример с http несработает.

продолдажаю читать статью https://www.gabriel.urdhr.fr/2020/04/20/linux-host-name-resolution/#fnref2

в ней написано 

The /etc/resolv.conf file defines which resolvers are used by the dns NSS module (with the nameserver directive).

я считаю что это не совсем так. файл resolv.conf читает нетолько nss module но и вообще
любая программа которая захочет его прочиать например это делает dig который к NSS
не имеет нкиакого отношения. а так изначально resolv.conf это конфиг файл для 
nss dns модуля и больше ни для кого вобщето.

например systemd-resolved нет

edns0 это такой ресширение dns пакетов. чтобы они было больше размера. иначе
напрмиер dnssec неработает.

временно читаю rfc3225 про DO бит. как я понял когда клиент(резолвер) шлет на сервер
в кьюри флаг DO то он этим сообщает серверу что он пониммает что такое dnssec и 
что клиент способен понимать dnssec RR тоесть cпособен понимать днс типы записей 
DNSKEY, DS, RRSIG
если сервер получает от клиента запрос кьюри в котором флаг DO неустанолвен то 
это сообщает серверу что клиент не понимает что это за днс записи DNSKEY, DS, RRSIG 
и сервер недолжен клиенту полсылать эти записи , хотя дальше идет тупая припска котоаря
все рушит unless DNSSEC security RRs are explicitly queried for. тоесть можно 
запросить эти хрени и без бита DO. а спрашивается нхаер он тогда нужен.
жалее они пишут что если от клиента прилетел на рекурсивный днс сервер запрос и этот
рекусриный днс сервер понимает dnssec то этот рекурсивный сврер в свой запрос в кьюри
должен включить внезависимости от того включал ли его клиент приславщий запрос на 
рекурсивный днс сервер или нет. потом когда эттот рекурсивный сервер будет овтвечать
клиену то он должен все dnnssec RR удлаить из ответа, хотя (суки) они туту же пишут
что если это ответ из кеша (кеша чего кого) то ответ модфиицировать нельзя

если клиент посллал запрос с DO битом а сврер ответил ошибкой то клиент доожен 
повторить запрос но уже без Do бита

если клиент послал запрос с DO битом а в обратку летит запрос без Do бита то такой
ответ клиент не должен принимать.

возвращаюсь к статье (https://www.gabriel.urdhr.fr/2020/04/20/linux-host-name-resolution/#fnref4) в ней пишут что можно вставит в resolv.conf

  options vc

и это типа скажет nss dns плугину (а остальным программам которые будут читать resolv.conf
это уже от них завсит воспримут ли они эту настройку)
чтобы он юзал tcp протоокол в не UDP

далее идет тема про resolv.conf
я ее пока пропускаю. едивнттсвенное что он пишет что есть несколкьо реализаций
resolconf и я это согласен . он их приводит

traditional resolvconf;
openresolv;
systemd-resolve

тут я не согласен. systemd-resolve это не resolvconf. во первых systemd-resolve уже
скажем так не используется , вместо него resolvectl и нужно сделать на него симлинк
вида
  
  ln -s resolvectl resolveconf

и этот симлинк будет работать тогда как резолвконф ограниченного пошиба.

далее вот что. статья (https://www.gabriel.urdhr.fr/2020/03/17/systemd-revolved-dns-configuration-for-vpn/) описывает то что systemd-resolved 
может делать очень нужную вещь - а именно можно задать имя домена и она будет искать
хосты этого домена в своей индивидальной группе днс сереров ну и также через 
опредеелнный интерфейс. значит у меня на компе есть интврейсе br0 я в него воткнул
интерфейс tap0 и на нем запустил виртуалку с ip=172.16.10.11, 
у нас получается что за интерфейсом br0 компа сидит виртуалка IP=172.16.10.11
на этой виртулаке я поднял bind сервис на основе этой инструкции (https://www.digitalocean.com/community/tutorials/how-to-configure-bind-as-a-private-network-dns-server-on-ubuntu-14-04) , этот bind9 
это одновременно и авторитивный сервер и рекурсивный и он хостит зону 

  nyc3.example.com

и в ней прописана запись

  host1.nyc3.example.com   A  172.16.10.11

так вот согласно этой (https://www.gabriel.urdhr.fr/2020/03/17/systemd-revolved-dns-configuration-for-vpn/) статье я делаю вот такую настройку на 
своем компе

я говорю что за br0 сидит днс сервер 172.16.10.11
  $ resolvectl dns br0 172.16.10.11

я говорю что за br0 сидит зона nyc3.example.com, знак ~ означае что запись nyc3.example.com
пыаться не стоит 
  $ resolvectl domain br0 "~nyc3.example.com 

я отклчаю на systemd-resolved конект через интерфейс br0 к днс серверам через DOT
  $ resolvectl dnsovertls br0  no

в итоге я имею статус
  
  $ resolvectl status

  Link 4 (br0)
    Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=yes/supported
   Current DNS Server: 172.16.10.11
       DNS Servers: 172.16.10.11
        DNS Domain: ~nyc3.example.com

теперь при запросе днс записей вида   *.nyc3.example.com у меня systemd-resolved
на компе полезет на днс сервер 172.16.10.11 через br0 интерфейс

это ровно то что надо когда мы имеем конект к впн тонелю и за ним сидит свой домен 
со своими днс серверами. это ровно то что умеет делать dnsmasq а теперь стало
понятно как это настривать для systemd-resolved
там дльше в статье расатривается как можно автаоматизиовать ввод этих команд чтобы автоматом
при поднятии  тонеля а не руками

пишут что dig конечно же неюзает NSS . он просто читает resolv.conf а дальше все 
делает сам

как провреть через какой интрефейс мы полетим на маршрут

# ip route get 8.8.8.8
8.8.8.8 via 172.16.50.1 dev tun0 src 172.16.50.5 uid 0 
    cache 
 

как посмтреть какие nss модули устанолвены 
]# ls -1 /lib/libnss_*.so.2  /lib/*/libnss_*.so.2
ls: cannot access '/lib/*/libnss_*.so.2': No such file or directory
/lib/libnss_compat.so.2
/lib/libnss_db.so.2
/lib/libnss_dns.so.2
/lib/libnss_files.so.2
/lib/libnss_hesiod.so.2
/lib/libnss_mdns4_minimal.so.2
/lib/libnss_mdns4.so.2
/lib/libnss_mdns6_minimal.so.2
/lib/libnss_mdns6.so.2
/lib/libnss_mdns_minimal.so.2
/lib/libnss_mdns.so.2
/lib/libnss_myhostname.so.2
/lib/libnss_mymachines.so.2
/lib/libnss_resolve.so.2
/lib/libnss_systemd.so.2
/lib/libnss_winbind.so.2
/lib/libnss_wins.so.2


кхм.. интересный пример
$ ltrace -e "*gethostbyname*@libnss*" getent ahostsv4  gmail.com
libnss_files.so.2->_nss_files_gethostbyname3_r(0x7ffeece904fa, 10, 0x7fbbb7a6e040, 0x5622738d2a00)                                = 0
libnss_mdns4_minimal.so.2->_nss_mdns4_minimal_gethostbyname3_r(0x7ffeece904fa, 10, 0x7fbbb7a6e040, 0x5622738d2a00)                = 0xffffffff
libnss_resolve.so.2->_nss_resolve_gethostbyname3_r(0x7ffeece904fa, 10, 0x7fbbb7a6e040, 0x5622738d2a00)                            = 1
2606:2800:220:1:248:1893:25c8:1946 www.example.com
+++ exited (status 0) +++

значит в чем фишка ltrace он показывает названия glibc или типа того функций которые
запускаются. его разница с strace в том что стрейс показывает сисколлы которые вызывются
к ядру. а лтрейс показывает не сисколыы а глибц функции которые вызываюься. разницу
понять трудно не будучи в знаниях. но обычно схема такая. мы вызывает глибц функцию
а она уже изнутри своих кишок вызывает сисколл. в программе на си у нас фигурирвую
названия глтбц фнукций. щас покажу пример

берем программу на си

# cat 05.c 

#include<stdio.h>
int main()
{
    int a = 10;
    void *ptr = &a;
    printf("Integer variable is = %d", *( (int*) ptr) );
    return 0;
}


вот ее вывод в стрейс

# strace ./05.exe 
execve("./05.exe", ["./05.exe"], 0x7fff80425380 /* 20 vars */) = 0
brk(NULL)                               = 0x55db68537000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f98c268f000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
...
...
итд

а вот вывод в ltrace
# ltrace ./05.exe 
printf("Integer variable is = %d", 10)                                                           = 24

тоесть стрейс нам аоказывает сисколлы вызываемые к ядру а лтрейс покаызвает 
нам вызовы глибц фнукций. 

так вот огромная наебка в том что лтрейс работет как я понял непонял если файл 
скоиплирован так что у нее есть PLT (неважно что это) так вот в арч\манжаро этого нет
поэтому вызов лтрейс в манжаром НЕПОКАЗЫВАЕТ НИЧЕГО.  а в дебиан12 все работает.

поэтоу в дебиан пример что выше
он нам чтото выдаст

$ ltrace -e "*getaddrinfo**" getent ahostsv4  gmail.com
getent->getaddrinfo("gmail.com", nil, 0x7ffc04d9ad60, 0x7ffc04d9ad58)    

а в манжаром на выходе ноль.

но лтрейс покаывзает запускаемые функции только запускаемые из скажем так тела программы
которую мы запустили. а если эта функция из своего тела внутри запускаем дуииегие функции
то их имена мы неувидим. поэтому мы видим getaddrinfo но то что она изнутри себя
запускаем фнкции вида *nss* мы уже не видим. 
вобщем у меня как встатье

$ ltrace -e "*gethostbyname*@libnss*" getent ahostsv4  gmail.com
libnss_files.so.2->_nss_files_gethostbyname3_r(0x7ffeece904fa, 10, 0x7fbbb7a6e040, 0x5622738d2a00)                                = 0
libnss_mdns4_minimal.so.2->_nss_mdns4_minimal_gethostbyname3_r(0x7ffeece904fa, 10, 0x7fbbb7a6e040, 0x5622738d2a00)                = 0xffffffff
libnss_resolve.so.2->_nss_resolve_gethostbyname3_r(0x7ffeece904fa, 10, 0x7fbbb7a6e040, 0x5622738d2a00)                            = 1
2606:2800:220:1:248:1893:25c8:1946 www.example.com

получить такой вывод даже близко не вышло.
во первых у него показано что были подгружен файл libnss_files.so.2
у меня увидеть подгрузку этого файла невышло НИРАЗУ!!! вроде бы в gentent он вмонтирован
статически? 

вот я взял дебиан

# cat /etc/nsswitch.conf 
hosts:          files dns

я не вижу чтобы подгруался nss dns модуль  в виде файла.

#  strace -e openat   getent  ahostsv4  google.com
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/hosts", O_RDONLY|O_CLOEXEC) = 3

он не подгружается нихуя.
и лтрейс не показывает вызов никаких *nss*

#  ltrace   -C   getent  ahostsv4  google.com
getaddrinfo("google.com", nil, 0x7ffceb51eda0, 0x7ffceb51ed98)     

 в общем лтрейс в целом на помойку

двгаем дальше
вот тут видно что dns resolve плагин подлкючается к systemd-resolved 
через AF_UNIX io.systemd.Resolve сокет

$ strace -e "connect,sendmsg" getent hosts www.example.com
connect(3, {sa_family=AF_UNIX, sun_path="/run/systemd/resolve/io.systemd.Resolve"}, 42) = 0


а вот как работает nss dns плагин

#  strace -e "connect,sendmsg" getent hosts www.example.com

он вначале птывается через AF_UNIX подключаится к nscd демону
которого на компе впомине нет

connect(3, {sa_family=AF_UNIX, sun_path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
connect(3, {sa_family=AF_UNIX, sun_path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)

а когда обламывается то уже лезет в интернет

connect(3, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("8.8.8.8")}, 16) = 0


как мониторить dns трафик по сети

  tcpdump -i any -n "port 53"
  tcpdump -i any -n "port 853"

вобещм эта статья в ней мног ополезной конкрретики - https://www.gabriel.urdhr.fr/2020/04/20/linux-host-name-resolution/#fnref9

типа есть фирма quad9 которая тоже дает реукурсивный днс сервер как гугл  и клаудфлеер


далее я вернусь к NetworkManager, resolv.conf и systemd-resolved. как они взаимодействуют
значит в конфиге NetworkManager есть ключ dns.
если его не прописать то идет дефолтовое поведение. а что это за поведение.а именно
NetworkManager будет апдейтить resolv.conf а то как он будет его апдейтить 
опредлеяет вторая натройка rc-manager
хотя дальше написана (man NetworkManager.conf)
некоторая конфузящая хуйня. написано что дефолтоовое подвеоение не будет работать 
если resolv.conf это симлинк на один из файлов

  /run/systemd/resolve/stub-resolv.conf,
  /run/systemd/resolve/resolv.conf
  /lib/systemd/resolv.conf 
  /usr/lib/systemd/resolv.conf. 


в этом случае они пишут что принимается что 

    dns = systemd-resolved

так у меня сразу вопрос а что если у меня resolv.conf это симлинк на указанные файлы
но при этом я напишу в когнфиге NetworkManager что  к примеру

   dns= none

что тогда? чья настойка победит? ихняя dns=systemd-resolved или моя dns=none ?
нихуя непоянтно

четсно говоря секция про ключи dns и rc-manager в man NetworkManager.conf это 
какой то ебаный нелогинчый ад. щас к этому вернусь . вот еще что хотел сказать

resolvectl это получает клиент командной строки по доступу к серверу который 
является днс клиентом. тоесть systemd-rsolved это сервер который умеет делать днс
запросы. и мы можем общаться с этим сервером тоесть мы можем давать ему задания
можем получать ответы. можем получать статусы, можем менять параетмерры работы 
сервера и все это через клиент доступа к этому серверу resolvectl
например можно через клиент поменять уровень логиварния этого сервера

    $ sudo resolvectl  log-level   debug


далее можно смотреть логи через

    $ journalctl -u systemd-resolved -f

чтобы поменять обратно лог левел эт уебки говорят посмотрит в man systemd 
так вот оказывается уровня логирования вот такие заебаляа искать

  emerg, alert, crit, err, warning, notice, info, debug

так вот я скажем вернул обратно вот так

  $ sudo resolvectl  log-level   alert


когда мы юзаем 

  $ resolvectl status

то получется что эта команда она связывается с серевром и показывает статус этого
сервера. 

вопрос - где правильнее прописывать днс рекурсивный сервер в нетворк менеджере
или в днс клиенте. ответ неясен.


возвращаюсь к NetworkManager.conf и его настройкам dns и rc-manager они влияют на то 
что будет ли NetworkManager перезаписывать resolv.conf файл 
я подумал я не буду их анализировать скорей всего потому что то как они работтают
это просто ебануто

на счет конфиг файла от systemd-resolved а именно /etc/systemd/resolved.conf
в нем можно внести параметр

  Domains=

так вот если в нем указать домены через пробелы например вот так

  Domains=net vasya kukuruza co.uk

то тогда будет вот что. если мы будем через systemd-resolved делать днс запросы
состоящие из одного слова то он будет к ним добавлять домены указанные в "Domains"
и уже это посылать выше на рекурсивны внешний днс сервер. и также systemd-resolved
пропишет эти домены в "свои" resolve*.conf файлы после перезагрузки службы.
тоесть у нас вот тут будет вот так

  $ cat /run/systemd/resolve/resolv.conf | grep -v '#'
  ...
  ...
  search net vasya kukuruza co.uk

  $ cat /run/systemd/resolve/stub-resolv.conf | grep -v '#'
  ...
  ...
  search net vasya kukuruza co.uk


соотвестенно если мы какйто из этих фйалов засимлинкаем в /etc/resolv.conf
то тогда эта "хрень" search будет использоваться не тлько systemd-resolved
но и всеми nss плагинами 

resolvectl конечно же не юзает NSS потому что ему ненужно. он же вообще то не днс
клиент. он просто напросто клиент от своего сервера который уже явлтся днс клиентом
поэтому resolvect не открывает nsswitch.conf и не открывает никакие nss плагины
зато resolvctl связывается со своим сервером через  socket AF_UNIX 


$ strace -e "connect,sendmsg"  resolvectl query  mail.ru
connect(3, {sa_family=AF_UNIX, sun_path="/run/dbus/system_bus_socket"}, 30) = 0

правда стремно то что он связывается с сервером через сокет d-bus 
а не через сокет самого сервера systemd-resolved который лежит вот тут

  /run/systemd/resolve/io.systemd.Resolve

тоесть родной клиент звонит на сервер не через нативный сокет сервера  а через левый
сокет дбас. 
в тоже время nss плагин resolve обращается к systemd-resolved уже не через dbus сокет
а уже через родной сокет

 $ strace -e "connect,sendmsg"   getent  ahostsv4    mail.ru
connect(3, {sa_family=AF_UNIX, sun_path="/run/systemd/resolve/io.systemd.Resolve"}, 42) = 0

так вот важно то что resolvectl нихрена не испльзует ни nss также он 
не открывает  /etc/resolv.conf он просто тупо свзявыается через д-бас со своим
серервером и передает ему реквест. и при этом реально если мы передаим одно слово
то к нему будет добавлен домен указанный в /etc/systemd/resolved.conf


$ resolvectl -4 query cloudflare
cloudflare: 104.17.156.85                      -- link: tun0
            104.16.208.90                      -- link: tun0
            (cloudflare.net)


тоесть видно что я указал домен cloudflare а в итоге systemd-resolved нам вернул
IP для домена coudflare.net

далее я вот что сделал. я 

  # kill -HUP 23120

где 23120 это номер процесса под котрым крутится systemd-resolved
также я сидел слушал этот процесс через strace
сигнал HUP затславяляет systemd-resolved  перечитать все свои конфиги. таким макаром
я хотел посмотреть читает ли демон /etc/resolv.conf для своей работы
и вот что оказалось он читает вот эти файлы

  /etc/systemd/resolved.conf

тоесть он читает свой прямой конфиг. 
и я увидел абсолютно точно что systemd-resolved не читает 

  /etc/resolv.conf

ему абсолюно плевать на этот файл

далее я вот что проверил - я взял стер /etc/resolv.conf который был симлиноком
на /run/systemd/resolve/stub-resolv.conf

и создал обычный /etc/resolv.conf с контентом

  nameserver 25.25.25.25

далее я рестратов демона. если бы он каким то макаром читал /etc/resolv.conf
то инфо об 25.25.25.25 попала бы в 

  $ resolvectl status

но там инфо об 25.25.25.25 не было и в помине. 

вообще это по всем статья логично что systemd-resolved (далее демон или сервер)
не читает /etc/resolv.conf потому что этот файл может быть симлинком например на
/run/systemd/resolv/stub-resolv.conf тоесть на свой собственно порождленный конфиг
а понятно что демоне не может читать инфо из конифига который может указывать на его
же собсвтенный конфиг. это был бы бред. 

поэтому по всем фронтам я консаттирую что демон неиспользует /etc/resolv.conf
для того чтобы узнать на какие рекурсивные днс сервера ему потом  делать запросы
он для этого использует файл /etc/systemd/resolved.conf  
получсется забавно обычно любой днс клиент\резолвер для того чтобы узнать на какой
рекурсивный днс сервер делать запрос читает /etc/resolv.conf но systemd-resolved
клал на этот файл. он узнает эту информацию из совершенно другого места /etc/systemd/resolved.conf это удивттельно. потому что я привык что все днс клиенты лиукнскса 
читаю инфо о днс серерах из /etc/resolv.conf
более того еслимы делаем симлинк

   ln -s /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf

то в этом файле стоит
 
    nameserver 127.0.0.53

тоесть таким макаром наш демон организует что все другие лоховские днс клиенты
будут считать 127.0.0.53 тем самым внешним рекурсивным сервером. 

далее удивительнешая вещь я думал что если я застоплю этот демон то исчезнут
файлы в папке /run/systemd/resolve однако они там лежат и в ус не дуют.
странно обычно если демон создает файлы в папке /run то при остановке он их удаляет.

так вот в man systemd-resolved написано что если  /etc/resolv.conf это обычный файл
то якобы systemd-resolved тогда прочитает /etc/resolv.conf и засосет из него 
указанные днс сервера. однако я проверил это неоднократно этого нихрена не происходит.
ровно также как я писал об этом и выше. тоест это брехня. для systemd-resolved 
нет никого дела до resolv.conf абсолютно
я даже полносьтью удалил /etc/resolv.conf перегрузил демона и после этого без 
какой либо проблемы зарезолвил mail.ru через

   $ resolvectl query mail.ru

поэтому я совершенно убедительно говорю что для днс клиента systemd-resolved файл
/etc/resolv.conf НАХРЕН не имеет никкого значения. он им не ползуется. он его не читает.
демон читает свои настройки в том числе и ip адреса внешних рекурсивных серверов 
из файла /etc/systemd/resolved.conf поэтому демон прекрасно резолвит доменные имена 
и без сущестовавания /etc/resolv.conf а если он ест то его демон нечитае. ему на 
этот файл плевать. и это забавно.   при этом демон порождает три своих аналога resolv.conf

    /run/systemd/resolve/resolv.conf
    /run/systemd/resolve/stub-resolv.conf
    /usr/lib/systemd/resolv.conf

в двух из них прописан внейшний днс сервер как 

    nameserver 127.0.0.53

на этом адресе сидит и слушает наш демон 
и предлагается для других лоховских днс клиентов которые в своей работе опираются на
файл /etc/resolv.conf  подсунуть  один из этих двух файлов через симлинк в /etc/resolv.conf
чтобы заставить этих другие лоховские днс клиенты обращаться к нашему демону в качестве
"внешнего " рекурсивного днс сервера. таким макаром нащ демон в файле /etc/resolv.conf
ненуждлается потому что у него другой конфиг файл. мало того что наш демон это клиент днс
он еще раотает как рекурсивный днс сервер и он хочет что его адрес был подставлен в 
/etc/resolv.conf чтобы другие днс клиенты делали запрсы через него. вот какой это 
хитрый демон.

посмотрим на эти файлы .
первый из них

  # grep -v '#' stub-resolv.conf 

  nameserver 127.0.0.53
  options edns0 trust-ad
  search net vasya kukuruza co.uk


получается если мы сделаем симлинк этого файла на /etc/resolv.conf 
то все днс клиенты которые не nss они прочитают этот файл и через строчку 

  nameserver 127.0.0.53

попадут на наш демон как в ловушку. поэтому смысл этого конфина понятен.

смотрим второй файл

 # grep -v '#' resolv.conf 

nameserver 1.1.1.1
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.47.179
search net vasya kukuruza co.uk

внем уже нет 127.0.0.53 это значит что если мы это залинкуем на /etc/resolv.conf
то nss клиенты все равно попрежнему попадут на наш демон. а вот НЕ NSS клиенты 
получается будут уже наравлять запросы на внешние днс сервера. тогда спрашивается
нафига этот конфиг нужен если в ряде случаев он не заворачивает днс клиенты на себя. 
тоесь получается как бы бессмысленно. мы заводим на компе рекурсивный днс сервер
а потом создаем конфиг который приведет к тому что ряд днс клиентов не будет на 
него попадать. что за бред? тоеть мы ставим программу. она генерирут конфиг который
приветдет к тому что в ряде случаев этой программой не будет пользоваться. это бред


далее представим что /etc/resolv.conf отсуствтует 
теперь представим что nsswitch.conf имеет вид

  hosts: resolve

дале запускаем NSS прогрммму

  $ getent ahostv4 mail.ru

а точнее вот так

# strace -e openat getent  ahostsv4 usa.gov
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/usr/lib/libnss_resolve.so.2", O_RDONLY|O_CLOEXEC) = 3


видно что это NSS прога и видно что исползуется плагин resolve (который перенарпавляет
запросы на демона) и что getent открывает файл /etc/resolv.conf но его у нас щас на 
компе нет. однако в итоге запрос успешно отработает. это мне говорит о том что я раньше
думал неверно о том что nss плаги читает адреса внешних днс серверов и направляет
к демону запрос нетлоько с именем домена но и через какой сервер его исполнять. 
оказалось это полная хрень. systemd-resolved либо игнориует направляет ему 
адрес днс сервера либо либо nss плагин нешлет адреса из /etc/resolv.conf 
к демону. потому что раньше я не понимал как же так к демону шлется что надо исполнять
реквест через 127.0.0.53 тоесть через самого себя. все это оказалосьь хрень.
получается что если у нас неNSS днс клиент такой как resolvectl то при остуствии
resolv.conf запрос отработает отлично. если у нас неNSS клиент такой как dig 
то запрос

    $ dig @127.0.0.53 -4 mail.ru

тоже отработает отлично.

если  у нас NSS клиент c плагином resolve то запрос тоже отработает отлично при 
остуствии /etc/resolv.conf 
я говорю о том что если программа юзает nss плагин resolve то хотя четко видно 
запрашиывается файл /etc/resolv.conf он никаким образом не влияет на то через какой
днс сервер systemd-resolved будет исполнять запрос. так что вся эта связка она не предает
на демон адрес днс сервера чрез который исполнять запрос. она предает толкьо запрос. 
вот что прикольно и важно. учитывая что изначально resolv.conf предназначен для 
nss dns плагина который уже реально использует инфо из resolv.conf чтобы значть чреез
какой днс сервер исполнять запрос. но для nss resolve + systemd resolved в этом 
нет необходимости.
вобщем как обычно пиздец. сплошные особенности.
получаетя что 
  
    nameserver 127.0.0.53

в /etc/resolv.conf
нужен только для того  чтобы если мы хотим чтобы днс клиенты резолвили днс запросы 
через нашего демона. сам демон для успешного резолвинга ни в чем ненуждается.
resolvectl который неисопльзует /etc/resolv.conf ему вообще насрать на этот файл 
он и так будет работать успешно. dig по деолфту лезет в resolv.conf но если ему
указать @127.0.0.53 то ему тоже этот файл нахрен ненужен

таким макаром демону ненужен файл /etc/resolv.conf чтобы успешно резволить. 
и ему ненужны файлы

    /run/systemd/resolve/resolv.conf
    /run/systemd/resolve/stub-resolv.conf
    /usr/lib/systemd/resolv.conf

чтобы успешно резолвить!
вся эта шняга нужна только для помощи другим днс клиентам чтобы либо их направить
на этого демона. либо подскзаать им какйото другой днс сервер. вот такая хрень.
просто прикол в том что обычно конфини нужны программе чтобы она успешно
заработала. а наш демон генерирует конфиги не для себя а для помощи другим программам
это пиздец какой необычный вынос мозга. мозгоебтво


что еще непонятно. если демон читает внешние днс сервера из файла /etc/systemd/resolved.conf
а там  у меня прописаны вот такие

    DNS=1.1.1.1
    FallbackDNS=8.8.4.4

то вопрос как другие днс сервера которые я вижу  в resolvectl status


Global
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4


Link 3 (wlp2s0)
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179



а именно 8.8.8.8 8.8.4.4 192.168.47.179 которых нет в /etc/systemd/resolved.conf
попадают внутрь демона.

в частности получается революционная вещь - считается чтобы на компе задать внешние 
днс сервера нужно залезть в resolv.conf и там их прописать. а вслучае systemd-resolved
это полная хуйня. нужно залезть в соверешенно другой файл /etc/systemd/resolved.conf
и задать это там!!!
остается только понять как в настройки systemd-resolved попадали настройки днс серверов
из NetworkManager

с точки зрения можно ли обойтись без systemd-resolved на компе чтобы работал dns 
резволвинг - конечно можно nss dns клиент тоже можнет отлично резволвить. он только 
не умеет кэшировать (хотя сервис nscd это умеет) и не умеет делать dnssec проверку.
поэтому в целом можно резолвд отключит а только в resolv.conf указать внешний
рекурсивный днс сервер и в nsswitch.conf указать nss dns плагин.
если поставить dnsmasq то он может и не иметь nss плагина. эту роль будет играть nss
dns плагин. тогда гавное в resolv.conf постваить nameserver IP_dnsmask


но все таки я возвращаюсь к прлблеме - как мне запретить sd(systemd-resolved) засасывать
конфиг из нетворкменеджера.

так еще раз возвращаюсь к конфигу sdr (systemd-resolved /etc/resolved.conf)
в нем есть ключ
  
    Domains =

в него мы включаем имена доменов которые будут делать вот что

Any domains not prefixed with "~" are used as search suffixes when resolving single-label hostnames (domain names which contain no dot), in order
to qualify them into fully-qualified domain names (FQDNs). These "search domains" are strictly processed in the order they are specified in, until
the name with the suffix appended is found. For compatibility reasons, if this setting is not specified, the search domains listed in
/etc/resolv.conf with the search keyword are used instead, if that file exists and any domains are configured in it.

или по русски - если я вбиваю в клиенте домен A из одного слова то его вначале надо
прервраить в нормального вида домен FQDN=A.B и тогда к моему слову A добавлвяется 
тот домен который указан в строке Domains
напрмиер если я укажу

  Domains = com

и в кленте укажу

    $ resolvectl vasya

то в итоге sd пошлет запрос про домен  vasya.com
resolvectl это клиент командной строки к sd. а как же резолвят домены программы которые
незапрашивают домен с командной строки. например браузер. они резовлят домены
вот как - либо подключая к себе nss библиотеку и потом юзают nss glibc функции которые
обращаются к файлу nsswitch.conf в котором прописан nss плагин например у меня это 
плагин resolve. тогда он берет ззапрошенный домен от программы и через d-bus сокет
шлет его к sd. тоесть если программа юзает nss то nss плагин берет реквест и пересылает
его к sd. файл /etc/resolv.conf (далее erc) при этом может вобще неиспользватся. если же программа неюзает nss систему то она обычно считывает erc и сама делает запрос к
nameserver указанный в erc. если в erc записано что 

  nameserver 127.0.0.53

то запрос попадает к sd

также когда мы указываем чтото в 
  
    Domains = com

то sd добавляет в erc параметр search com для того чтобы те программы которые будут
читать erc увидели как хозяин компа хочет чтобы обрабатывались однословные домены. 
тут кстати вопрос если мы указали в конфиге sdr параметр 

  Domains = com

то нафиг его доавлять в erc. ведь sd уже знает как интерпетироовать однословные домены.
ведь я так понимаю не клиент добавляет к реевесту клиента этот хвост com а сам sd
добавляет. тогда добавление 

  search com

в erc по иедее не играет никакой роли. ну может быть вот такой вариант. мы можем заюзать
dig который читает erc и в диге мы можем указать днс сервер 8.8.8.8 тогда диг обратиьтся
не к sd а к 8.8.8.8 но также он увидит что в erc есть запись

  search com

и он направл к 8.8.8.8 запрос не виде vasya а в виде vasya.com  щас проверим.

вот у меня какой erc

  ..
  ..
  search net vasya kukuruza co.uk


и я запускаю 
    
    $ dig @8.8.8.8  vasya

и что я вижу?

$ dig @8.8.8.8 vasya +tls +qr

;; QUESTION SECTION:
;vasya.       IN  A


;; Got answer:
;; OPT PSEUDOSECTION:
;; QUESTION SECTION:
;vasya.       IN  A


тоесть получает диг  открывает erc
  $ strace -e  openat  dig @8.8.8.8 vasya +tls +qr 2>&1 | grep resolv
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY) = 11

и видит там

  search net vasya kukuruza co.uk

но он при этом эту строку совершенно игнориует!
получается что? получается что dig читает erc только для того чтобы там прочитать
названия 

  nameserver X.Y.X.Z

но опять же справшивается если у указал для диг неймсервер зачем тогда он лезет
читать IP днс сервера в erc. ему было бы логичнее лезть туда читать опции. 
а мы как видим он опцию search просто иногнориутет

пошлем запрос через диг к sd

$ dig @127.0.0.53  vasya  +qr

;; QUESTION SECTION:
;vasya.       IN  A


;; Got answer:
;; OPT PSEUDOSECTION:
;; QUESTION SECTION:
;vasya.       IN  A

тоже самое. получается хотя sd знает про настройку ведь у нее в sdr есть запист

    Domains = net vasya kukuruza co.uk

но почему то sd тоже ее игнориует!

единственное как работает это либо через resolvectl либо через программу
кооторая юзает nss

$   resolvectl query vasya 
vasya: 3.64.163.50                             -- link: tun0
       (vasya.net)


$ getent ahostsv4 vasya
3.64.163.50     STREAM vasya.net


я точно знаю что resolvctl он не открывает erc значит добавку .net делает 
сам sd. но почему он тогда ее неделает когда  к нему обращается диг?

getent открывает erc и он юзает nss.

исходя из этого у меня нет точно ответа кто должен добавлять хвост домена к однословному
домену из изначального реквеста?  первичная программа? nss плагин? сам sd ? 
в случае использования resolvect добавляет сам sd потому что он же знает про этому настройку
ибо она у него конфиге sdr прописана. ему чиать erc вобще нет нужды. 
в случае nss программы я так понимаю добавление .com делает nss плагин и шлет к sd
уже vasya.com запрос, как я понял диг хотя и читает erc но .com недобавляет и почемуто
sd тоже недобавляет. 
вобщем загадка кто из : изначальная программа, nss плагин (если используется), sd демон - 
кто из них должен заниматься добавлением .com к изначальному реквесту.
как обычно все через гадню сделано.
поэтому я бы сказал так если программа самого верхенго уровня сама непрочитает erc
и сама не модифицирует изначльный однословный реквеест то большой шанс что те компоненты
которые пойдут ниже они тоже этого не сделают.
на самом деле изначально получается вот что - если программа незнает что такое nss
то для нее запись

  nameserver 127.0.0.53

выглядит так что сервер 127.0.0.53 это уже сервер сидящий в интернете который к нашему
erc неимеет никакого достуа и понятия о нем. поэтому запрос к внешнему рекурсивному днс
серверу должен идти уже в конечном виде подгттоовленный поносстью. поэтому по идее 
sd вобщем то недолжен заниматься модифицикаией однослвовного домена. ему должны уже
представить полностю сформированный запрос. потому что еще раз на месте записи

  nameserver 127.0.0.53

может быть запись

  nameserver 8.8.8.8

и понятно что этот сервер неимеет понятия ни о каком erc и парметре search net

поэтому по хорошему то что мы указыаем в файле sdr параметр

  Domains = net

должно бы приваодить к тому что sd модицифрует erc пропсиывая там 

  search net

и на этом его роль в этом плане заканчивается. а дальше это уже проблема программы
верхенго уровня чтобы она считала erc , счиатал параметр search и либо его использвала
либо нет и чтобы к sd запрос уже шел в конечном модифициованном виде vasya.com

вобщем мура тут потому что - изначально файл erc это был конфиг файл для nss dns
плагина. он его читал. и он исполнял днс запросы. а потом все кому не лень начали
читать erc файл.  в итоге я бы скаал так что если прогармма юзает NSS и в ней указан
либо плагин resolve либо dns то эти плагины считают erc считают оттуда search 
модфицируют реквест  и настройка search сработает. внезависимости от того как поведет
себя программа верхеннего уровня. с другой стороны - представим что прогармма верхенго уровня
считала erc, модфиицировала vasya на vasya.net потом она ывазывает nss подсистема,
там плагин nss dns еще раз читает erc видит search - БА! но он небудет модифицировать
запрос еще раз потому что он что НЕОДНОСЛОВНЫЙ! все номррально всеработает. тоесть
если программа юзает NSS то лиобо програма верхенего уровня может модицифицровать запрос
либо за нее это сделает NSS плагин. все круто. все надежно.
предположим что sd модифиурет запрос помуто что она видит что реквест ей прислал
тупой клиент resolvectl по d-bus поэтому sd знает что всю работу нужно делать ей
и модцифировать рекест.  непонятно только почему диг читает erc но при этом полностью
игнориует опцию search

кстати можно очень круто с другой стороны проверить какой реквест шлет диг к sd
вот так

  $ dig vasya

  $ sudo resolvectl monitor
→ Q: vasya IN A
← S: no-servers

то есть sd нам рапортует что у него спросили домен=vasya

а вот как с resolvectl

  $ resolvectl -4 query vasya
  $ sudo resolvectl monitor

→ Q: vasya IN A
← S: success
← A: vasya.net IN A 3.64.163.50

тоесть четко видно что от resolvect к sd лелит запрос в виде vasya
потом очеивдно сам sd его модифицирует понимая что resolvectl это тупой клиент. за него
надо делать все самому. потому что он значет что resolvectl не просматрвиает erc.

странно еще то что в диге есть опция чтобы кастомно задавать search
 +domain=somename
              This  option sets the search list to contain the single domain somename, as if specified in a domain directive in /etc/resolv.conf, and enables
              search list processing as if the +search option were given.

так какого хрена он не читает серч из erc ???

короче я понял!!! по дефолту диг читает erc но не читает оттуда опцию search!
а чтобы он оттуда ее начал читать это надо задать чере ключ +search !!!
тоесть этот ключ незадает домены которые надо прибавтлять! он задает то чтобы диг 
начал из erc читать seaarch ключ.
показываю

$ dig vasya +search

;; QUESTION SECTION:
;vasya.net.     IN  A

;; ANSWER SECTION:
vasya.net.    7200  IN  A 3.64.163.50

и вот что показывает sd монитор

→ Q: vasya.net IN A
← S: success
← A: vasya.net IN A 3.64.163.50


тоесть диг считат search из erc , модифицировал реквест и наравил к sd уже  vasya.net

получается что если к sd идет запрос через 127.0.0.53 то он реквест не модифиуирует
он ведет себя также как вел бы внешний интернет днс рекурисвный севрер. если  к нему
приелетел запрос для vasya то он для него и ищет iP.
а если к sd приелетел запрос через локальрный сокет - по всей видимости тогда он 
модифицирует реквест при условии что реквест состоит из одного слова

а мы щас проверим как обстоят дела  в случае nss программы 

 $ getent ahosts4 vasya

 $ resolvectl monitor
→ Q: vasya IN A
← S: success
← A: vasya.net IN A 3.64.163.50

это доказывает вот что - программа верхнено уровня getnent передатет в nss плагин 
домен=vasya, nss плагин resolve хотя он и читает erc (это я показывал ранее) но он 
не модифицирует реквест! незнаю почему! он через сокет передает исходный немодицифированный
запрос domain=vasya на sd. а уже sd модифицрует его в domain=vasya.net

ТАКИМ ОБРАЗОМ я делаю вывод = демон sd он модифицирет однословный запрос только если 
запрос пришел через локальный сокет! а если запрос пришел через 127.0.0.53 то он 
однословный запрос НЕМОДИФИЦИРУЕТ. также практика показала что nss resolve плагин
НЕМОДИФИЦИРУЕТ исходный запрос. поэтому если программа верхнего уровня хочет чтобы
однословный запрос был модифицирован то его должга модифицировать либо сама программа
верхнего уровня, либо программа верхнено уровня должна сделать запрос к sd 
через локальный сокет. тогда sd модифициурет однословный запрос.  также nss resolve запрос не модиифицирует но так как nss resolve связыватся  с sd по локальнмому сокету то 
в итоге sd модифицириует запрос. итого финальная таблица.
у нас есть програма верхнего уровня. если она обращается к sd через локальный сокет
либо через nss то ей ничего делать ненадо, сам sd модифицрует однословный запрос.
а если программа верхенго уровня обраащается к sd через 127.0.0.53 (по сети) то ттогда
она сама должна прочитать erc, прочиать оттуда search опцию, модифицировать исходный запрос
и только потом послать его на sd. потому что в случае коода к sd запрос идет не через
локальный сокет а через сетевой сокет 127.0.0.53 то sd однослвные реквесты не 
модифицирует !!!
dig по дефолту опцию search из erc нечитает. чтобы он ее читал надо делать +search

  $ dig vasya +search

также разагадан закадка о том что если у нас search выглядит вот так

  search . com net

то вот что происходит. у нас при запросе domain=vasya диг превратит его в 
  domain=vasya.

по идее этот запрос должен закочнится ошибкой. тогда диг долен взять следущий домен
и праервтить vasya в vasya.net который уже есть. проверяем

# dig @8.8.8.8 +search vasya +tls


;; QUESTION SECTION:
;vasya.net.     IN  A

;; ANSWER SECTION:
vasya.net.    7200  IN  A 3.64.163.50


все верно!

а тперь направим такой же запрос к sd

[lenovo etc]# 
[lenovo etc]# dig  +search vasya +qr

;; QUESTION SECTION:
;vasya.       IN  A


;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: REFUSED, id: 22973

и что мы видим наш дин наравил domain=vasya.  и sd ответил статусом status: REFUSED
мне тут непоняно почему диг не продоолжил и непнаврил следущий запрос 
domain=vasya.net
вопрос а каким статусом отвечал 8.8.8.8 что диг продолжил и направил запрос domain=vasya.net

тоесть диг в своем выводе на экран
# dig @8.8.8.8 +search vasya +tls  

;; QUESTION SECTION:
;vasya.net.     IN  A

;; ANSWER SECTION:
vasya.net.    6977  IN  A 3.64.163.50

он почему то скрывает тот кусок когда он слал на 8.8.8.8 запрос в виде domain=vasya.
он нам парит мозг что якобы он сразу слал vasya.net а это брехня.

ксатти как уже стало понятно все же есть разница то как обаращаться к sd через 
локальный сокет или сетевой адрес, потому что sd обрабаывает запросы по разному
в зависимосити как на него обратились. в случае диг без разрницы если мы обрааемся
вот так

  $ dig vasya

или вот так

  $ dig @127.0.0.53 vasya

просто в первом случае он прочитает адрем 127.0.0.53 из erc и фактически 
сделает вызов sd как во втором случае

из того что dig почемто не продолжаает бомбить sd после того как он ему направил 
vasya. я считаю что из search надо точку убирать. 

я думаю с опцией search разобрались. когда она работает когда она неработает. 
почему она неработает. хотя конечно это ад на пустом месте.

итак если в sdr(systemd-resolved /etc/systemd/resolved.conf) вставить

  Domains= net com co.uk

то при перезапуске sd он вставить в erc 

  search net com co.uk

далее если запрос к sd идет через локальный сокет (в том числе через nss) то сам 
демон sd будет модфицировать однослованые запросы согласно тому что указанов search
тоесть пртбавляяя .net или .com итд.
если же запрос к sd идеет через сеть через 127.0.0.53 то sd модифицировать однослваные
запросы не будет. это тогда задача вызывающей его программе верхенго уровня!
получается кстати в линуксе по дефолту днс запросы резволвит не ядро а юзер код в
виде глибц библиотеки из nss библиотеки.ядро только создает ipv4 сокет и все и сам
протокол tcp\udp делает. а днс резволвер он же nss dns он работает в юзер спейсе.
и наша программа должна его к себе подгрузить подключить на стадии выполеннения. 
так что днс резволинг это юзер спейс хрень  а не сидит в ядре.
получается что линукс все такие это нетлоько ядро. это еще обязательно набор супер
базовых хреней в юзерспейсе в виде glibc. это уже не ядро. но это я бы сказал и не 
юзер код не юзер программы. это системный код только он работает не в привилинированном
режиме цпу а в непривлигированном режиме. формально glibc это юзерская програмаа
но по факту это системный линукс код работающий в юзер спейс режиме. поэтому 
я бы скзаал что линукс это обяазтельно ядро+глибц. без глибц ядро это как мозг но 
без тела. а глибц это тело без мозга. только они вместе могут дать рабоающую систему.
а уже поверх этого накодывается реальный юзер код.
поэтому важны нетлоко новые релизы ядра но и новые релизы глибц. это два столба
на которых стоит линукс. а уже треять припизочка сбоку это юзерские программы.
ябы так сравниал . ядро это движок. глибц это корпус машины. двери ручки руль. 
а юзер код это человек за рулем. 

в итоге получается интерсно вот что - на компе чтобы работал днс резолвинг
никакой доп днс резовлер ненужен. ибо nss dns уже встроен. для работы nss dns
ему ненужно висеть в системе в форме демона ненужно сидеть не сетевом сокете. 
он работает через локальный сокет. тоесть нам ненужна никккая служба которая 
виисит на сет карточке на 53 порту. это ненужно необязательно. доступ к днс резволверу
nss dns идет тупо через вызов nss dns функции! даже сокет ненужен. а вот уже этот
nss dns код он через сетевой сокет связывается  с внешним интернет днс сервером. 
поэтому ненеужен на компе чтобы была служба которая висит на 53 порту.
также получается что так как код резолвера вынесен за ядро. тоесть по сути это 
просто программа которая лезет в сеть. ровно также как программа бразуер через 
такой же сетевой сокет лезет в сеть на 443 порт. а днс резовлер это такой же 
условно браузер только леезет он на 53 или 853 порт. тоесть никакой загадки
особенности в днс резволвере нет. диг это такой же nss dns только написан дуриими 
людьдьми. вобщем я о том что так как днс резволе вынесен в юзер спейс то у нас на компе
можно ставить самые разные днс резволверы. у нас плный выбор ядру все равно. это как
какой браузер ты поставишь на компе. единсвтенное то что многие программы они к коду
днс резволвера обращаются через nss. поэтому днс резволвер должен иметь nss плагин. 
ну или если у днс резволвера не nss плагина то тогда надо чтобы днс резволвер
на компе сел на сетевой сокет , потом происать его в erc

  nameserver IP

и обращаться к этому днс резволверу через прокладку в виде nss dns резволвера


 программа --->> nss dns --->> наш днс резволвер

чем плох nss dns у него слабый фукционал. он неумеет кэшировать. он не умеет
в зависисмости от домена лазить на кастомный днс сервер. 

тоесть он встроен. он надежный. ему ненужен сеетевой сокет на компе чтобы до него
достучаться - по факту если программа умеет работаьт с днс только через nss
то никакой сетевой сокет не поможет нужен nss плагин. но nss dns беден на функционал.
это типа как встроенный блокнот. писать можно . но и толко то.

если программа сама не умеет днс реквесты делать а знает только nss то тогда
без наличияи nss плагина на компе хрен она днс зарезволвит. но  к счатсью на 
компе всегда есть nss dns плагин

кстати dnsmasq он выполеннен как в отдеьном пакете так и в форме плагина у NetworkManager

на дебиан есть systemd но sd там выключен. и комп юзает nss dns
  
  /etc/nsswitch.conf
  hosts:          files dns

после таого как поставли пакет systemd-resolved
он сам автоаматом меняет nsswotch.conf на такой

hosts:          files myhostname resolve [!UNAVAIL=return] dns


также он сам убирает старый erc и делает новый в виде симлинка на /run/systemd/resolve/stab-dns.conf
едисннветтенная какая то хуня в дебиан что нужно зайти в sdr и там руками 
указать внешние днс сврервера 

  # grep -v '#'  /etc/systemd/resolved.conf 

  [Resolve]
  DNS=1.1.1.1

иначе он незнает куда ему обрашаться. дебил.
тоесть этот пакет он полноценно переключает все нужные хрени в системе на новый резолвер.
это хорошо. это радует
получется что если бы все программы умели работать через nss то демону sd ему ненужно
было бы поднимать сетевой сокет на ip адреа 127.0.0.53 , ему было бы достоточно 
плагина resolv и локального AF_UNIX сокета 
посмотрим какие сокеты имеет открытыми наш sd демон
для этого удобно посмотреть его номер процесса и юзнуть lsof

# lsof -n  -p 1053 | grep -E "unix|IP"
11u     IPv4              17741      0t0    UDP *:5355 
12u     IPv4              17742      0t0    TCP *:5355 (LISTEN)
13u     IPv6              17749      0t0    UDP *:5355 
14u     IPv6              17750      0t0    TCP *:5355 (LISTEN)
18u     IPv4              17752      0t0    UDP 127.0.0.53:domain 
19u     IPv4              17753      0t0    TCP 127.0.0.53:domain (LISTEN)
20u     IPv4              17754      0t0    UDP 127.0.0.54:domain 
21u     IPv4              17755      0t0    TCP 127.0.0.54:domain (LISTEN)
22u     unix 0x0000000067e240b0      0t0  17756 /run/systemd/resolve/io.systemd.Resolve
23u     unix 0x0000000068a42ba6      0t0  17757 /run/systemd/resolve/io.systemd.Resolve.Monitor


видно что демон имеет открытми сокеты UDP/TCP на 53 и 54 порту. это я еще 
понимаю. но зачем ему UDP\TCP сокеты на 5355 порту? 
и еще он имеет локальные AF_UNIX сокеты через файлы io.systemd.Resolve
и io.systemd.Resolve.Monitor

через сокет io.systemd.Resolve.Monitor скорей всего работает resolvectl monitor
щас проверю
да все верно

# strace -e connect  resolvectl monitor
connect(3, {sa_family=AF_UNIX, sun_path="/run/dbus/system_bus_socket"}, 30) = 0
connect(7, {sa_family=AF_UNIX, sun_path="/run/systemd/resolve/io.systemd.Resolve.Monitor"}, 50) = 0

правда зачем он еще открывает сокет д-бас непонятно. 
я думал что через сокет io.systemd.Resolve программа resolvectl связывается с демоном
когда делает просто query запрос
кхм... не нихрена
он связываетс с демоном через д-бас сокет
# strace -e connect  resolvectl -4 query mail.ru
connect(3, {sa_family=AF_UNIX, sun_path="/run/dbus/system_bus_socket"}, 30) = 0

прикол. а вот getent точнее nss resolve через этот сокет связватся с демоном
# strace -e connect  getent ahostsv4  mail.ru
connect(3, {sa_family=AF_UNIX, sun_path="/run/systemd/resolve/io.systemd.Resolve"}, 42) = 0
в общем конечно это такой ад... 

а вот что ltrace на дебиан покызвает
  # ltrace  getent ahostsv4  mail.ru
getaddrinfo("mail.ru", nil, 0x7ffcfee17e10,  cfee17e08) = -3
тоесть внутри этого addrinfo уже идет подклчение к nss и вызов nss
фукнкций

а вот я добавил com в 

    Domains = com

и щас мы увидим на дебиане как getent (nss aware программа ) обращается внутрь nss

# ltrace  -e getaddr*  getent ahostsv4  mail
getent->getaddrinfo("mail", nil, 0x7ffe5faa75b0, 0x7ffe5faa75a8)                                 = 0

тоесть здесь четко видно что gentent обращается внутрь nss шарманки передвая 
ей немодифициованный реквест просто mail

далее я повторил команду и пососведству я запустил монитор

 # resolvectl monitor
→ Q: mail IN A
← S: success
← A: mail.com IN A 82.165.229.87

он показывает что мало того что внутрь nss реквест передается не модифициваорованным,
далее сам nss плагин resolve тоже передает в демоне НЕМОДИЦИИРОВНЫЙ РЕКВЕСТ.


→ Q: mail IN A

и только сам демон sd меняет реквест

← A: mail.com IN A 82.165.229.87

таким образом еще раз найден ответ на вопрос кто меняет исходный реквест когда мы 
работаем через nss: верхняя прогармма? nss плагин? sd демон? 
ответ sd демон!




итак я расматривал какое значение  имеет насторйка

  Domains=  net com co.uk

в sdr

c этим как бы разобрались.


ксатти эта настройка втсупает в силу при выполеннии прочих условий также только в том
случае если днс реквест состоит ИЗ ОДНОГО СЛОВА. тоеесть

   # ping vasya
   # ping mail

если запрос состоит из хотя бы двух слов

  # ping vasya.com

то эта настройка НЕИМЕЕТ НИКАКОГО ЗНАЧЕНИЕ!!!!!
то есть она по факту ничего неломает. 
у нас по определению доменное имя должно состоять из двух частей мимниум!

    vasya.com

пэтому когда мы вводим доменое имя из одного слова мы уже нарушаем тип запроса. 
и ключ search типа пытается наш уродский запрос превратить в правльный.

еще раз скажу на счет строки
    
    Domains = .  com

или

    search . com

как он работает. 

во первых если мы вставим

  Domains = . com

и перегрузим демона то у нас erc не превратится в 

  sesrch . com

он будет 
  
  search com

если мы сразу в stab-resolv.conf поставим 

  search . com

а потом перегрузтим демона то он перетет файл и снова мы увидим

  search com

если мы сразу в stab-resolv.conf поставим 

  search . com

и не перегрузим демона 
исделаем запрос через resolvectl то отработает как надо

# resolvectl -4 query mail
mail: 82.165.229.87                            -- link: enp0s3
      (mail.com)


через getent тоже
# getent ahostsv4 mail
82.165.229.87   STREAM mail.com

тоесть внаале отрабатывается домен mail. он выдает ошибку потом он посдтавляет
следущий домен mail.com

с дигом тоже все окей

# dig +search  mail

;; QUESTION SECTION:
;mail.com.      IN  A

;; ANSWER SECTION:
mail.com.   114 IN  A 82.165.229.87


далее еще интерснее если  я ставлю

 Domains=.

перегружают демоана то в erc получаю

  search .

если  я ставлю

 Domains=. com 

перегружают демоана то в erc получаю

  search com

в общем сплошные особенности исключения и прочий ад

в общем я не рекомендую ставит в stab-resolv.conf точку самому руками. 
нужно ставит все настройки в sdr (/etc/systemd/resolved.conf ) а он сам уже что 
считает нужным ставит в /etc/resolv.conf
тогда не будет никаких непоняток. для sd файл erc он вторичный информационный. а не 
конфиграционый. если мы чтот вобщем напряую в stab-resolv.conf то мы обманем сами
себя потому что по факту демон sd работаем по тем настройкам что он отобразил 
в оригиальном stab-resolv.conf а от того что мы чтот поменяли руками  в нем от этог
настройки sd не поменялись. 

не стои менять руками stab-resolv.conf потому что в этом файле он нам покаызает 
свои настройки. но от тооо что мы его поменяе мруками от этого режим работы демона sd
непоменется. еалимы мы хотим поменя настройки демона надо менять файл sdr
и перегружат демона. также если мы поменяем erc то после перезугрузки демона наши
настройки перетурктся. максимум на кого повлияют наши ручные правки erc это прогарммы
типа dig. 

дальше про опцию Domains если мы в ней пропишем домен с тильдой

    Domains = ~com

то такой домен называется "route-only domain"
насколко  я понял домены которые вписаны в Domains без тильды называются в терминах "search domains" в темринах sd
еше раз напомню что добавление "search домена" в изначальный реквест происходит толко 
вслучае если изначальный реквест состоит ИЗ ОДНОГО СЛОВА. если изначлаьный реквест 
имеет два слова и больше то  подстановка идет нахрен.
дальше они пишут что если мы задали серч домен или роут-онли домен то вообще то эта
настройка может быть привязана к конкретному интерфейсу а не быть глобальной. и это
значит что строка Domains перестает играть рояль только для случая запрса из одного
слова. если у нас в запросе уже есть домен указанный в Domains и этот домейнс
навешен на какото интерфейс то для sd это знак того что данный днс реквест нужно 
кинуть на днс сервера этого интерфейса. щас все покажу на примере.
у меня в коннфиге sdr написано

 $ grep -v '#' /etc/systemd/resolved.conf 

[Resolve]
Domains=com

смотрим статус демона

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
    resolv.conf mode: stub
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4
          DNS Domain: com       <========  !

Link 3 (wlp2s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179

тоесть у меня на данный момент настройка "DNS Domain:" глобальная не привязання
ник какому интерфейсу. пока что это мало интересно. пока что эта настройка 
работает только для случая когда в запросе домен имеет одно слово. это уже все 
было обсуждено. 

так вот смотрим что у нас показвает resolvectl для интерфейса br0



Link 4 (br0)
    Current Scopes: none
    Protocols: -DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported


теперь я ввожу команду через resolvctl которая подкрутит настройки у демана sd
я подкркчиваю то что я устанавливаю Domains=nyc3.example.com но не глобально 
а только для интерфейса br0

    # resolvectl domain  br0 nyc3.example.com

смотрим как поменялись настройки на демоне sd


Link 4 (br0)
    Current Scopes: none
         Protocols: -DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
        DNS Domain: nyc3.example.com


значит я считаю что на данный моент эта настройка говорит вот что так как Domains
указан не глоабально а для интерфеса то это значит что если в исходном реквесте
будет фигурировать домен nyc3.example.com то  sd посмотрит на список днс серверов
прописанных у него глобально 

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
    resolv.conf mode: stub
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4


и если какйото из глобальных днс серверов лежит за br0 то sd пошлет запрос именно
к днс серверу лежащему за br0 интерфейсом. насколько я понимаю настройка Domains
сделанная не глобально а присобаченная к интерфейсу теряет тот смысл которая она несет
когда она устанолвена глобально. тоесть если мы введем односложный запрос то 
я так понимаю что подстановка домена будет идти из Domains указанного глобально , 
и постановка не будет идти из Domains присоабвенного к кокнертному интерфейсу.может
я ошибкаюсь ибо тут все ебануто сделано.

далее я вставляю еще одну команду которая пропишет днс сервера не глобально 
а именно сидящие за этим интерфейсом

  # resolvectl dns   br0  172.16.10.11

проеряем статус демона


Link 4 (br0)
    Current Scopes: DNS
         Protocols: -DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 172.16.10.11
       DNS Servers: 172.16.10.11
        DNS Domain: nyc3.example.com


теперь это будет работтать вот как.
если я запульну реквест для nyc3.example.com
то sd запустить этот реквест через br0 к днс серверу 172.16.10.11
проверим , знначит я все вроде правилно настроил но получил сразу отлуп

# resolvectl query ns1.nyc3.example.com
ns1.nyc3.example.com: resolve call failed: All attempts to contact name servers or networks failed

и тут очень поможет нам вот что (https://www.gabriel.urdhr.fr/2020/04/20/linux-host-name-resolution/) очень толковая с подробностями статья

так вот в ней подсказано что можно поменят уровень логирования у sd

    # resolvectl log-level debug

напомню какиы бываю уровни логирования это либо числа 0..7 либо слова
emerg, alert, crit, err, warning, notice, info, debug

запускаем еще раз траназцаакцию 

 $ resolvectl query ns1.nyc3.example.com

и смотрим логи

    # journalctl -f -u systemd-resolved

и что я там вижу


Got message type=method_call sender=:1.527 destination=org.freedesktop.resolve1 path=/org/freedesktop/resolve1 interface=org.freedesktop.resolve1.Manager member=ResolveHostname  cookie=2 reply_cookie=0 signature=isit error-name=n/a error-message=n/a

idn2_lookup_u8: ns1.nyc3.example.com → ns1.nyc3.example.com

Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=GetConnectionCredentials cookie=245 reply_cookie=0 signature=s error-name=n/a error-message=n/a

Got message type=method_return sender=org.freedesktop.DBus destination=:1.480 path=n/a interface=n/a member=n/a  cookie=4294967295 reply_cookie=245 signature=a{sv} error-name=n/a error-message=n/a

D-Bus hostname resolution request from client PID 61654 (resolvectl) with UID 0

Looking up RR for ns1.nyc3.example.com IN A.

Looking up RR for ns1.nyc3.example.com IN AAAA.

Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=AddMatch cookie=246 reply_cookie=0 signature=s error-name=n/a error-message=n/a

Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=GetNameOwner cookie=247 reply_cookie=0 signature=s error-name=n/a error-message=n/a

Got message type=method_return sender=org.freedesktop.DBus destination=:1.480 path=n/a interface=n/a member=n/a  cookie=4294967295 reply_cookie=247 signature=s error-name=n/a error-message=n/a

Cache miss for ns1.nyc3.example.com IN AAAA

тоесть к этому моменту он написал что получил реквет через дбас и что посмотрел в
кеше а вкеше ничего нет


Firing regular transaction 45369 for <ns1.nyc3.example.com IN AAAA> scope dns on br0/* (validate=yes).

Using feature level TLS+EDNS0+DO for transaction 45369.

Using DNS server 172.16.10.11 for transaction 45369.
сен 10 15:44:13 lenovo systemd-resolved[60609]: Sending query via TCP since UDP isn't supported or DNS-over-TLS is selected.

далее он нпаспиал что запускает "стандартную" транзацию и что для нее он будет
использвать TLS + EDNS0 + DO то бишь он будет стучать по TLS через 853 порт и еще 
будет делать DSSNEC. так вот у меня днс сервер 172.16.10.11 у него нет ни TLS
ни DSNSSEC  это надо все отключить . правда отключит это конкретно для этого срвера
не получиться. отключается все на уровне интерфейса. тоесть для всех днс 
серверов которые лежат за этим интфрейсом. 
делаю это так

  # resolvectl dnsovertls br0 off
  # resolvectl dnssec  br0 off


проверяею как изменились настройки демона  sd

    $ resolvectl status


Link 4 (br0)
         Current Scopes: DNS
         Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 172.16.10.11
        DNS Servers: 172.16.10.11
        DNS Domain: nyc3.example.com

видно что для реквестов через br0 у нас и TLS и DNSSEC выключены
  -DNSOverTLS 
  DNSSEC=no/unsupported

запускаю повторно мой реквест

  # resolvectl query ns1.nyc3.example.com
  ns1.nyc3.example.com: 172.16.10.11             -- link: br0
  -- Data is authenticated: no; Data was acquired via local or encrypted transport: no
  -- Data from: cache

успех. вот он написал что делал реквест через интерфейс br0  это главное. 
тоесть это у нас отработала настройка

Link 4 (br0)
        DNS Domain: nyc3.example.com

тоесть мы указали sd чтобы он обрабатывал реквесты для домена nyc3.example.com
чеерз днс серверы лежащие за интерфейсом br0 и он так и сделал. 
ну и попутно он нписал что реквест был сделан без TLS (encrypted transport: no)
и что реквест был сделан без dnssec (Data is authenticated: no;)
я смотрб в логах какая там ифно есть


Got message type=method_call sender=:1.534 destination=org.freedesktop.resolve1 path=/org/freedesktop/resolve1 interface=org.freedesktop.resolve1.Manager member=ResolveHostname  cookie=2 reply_cookie=0 signature=isit error-name=n/a error-message=n/a

idn2_lookup_u8: ns1.nyc3.example.com → ns1.nyc3.example.com

Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=GetConnectionCredentials cookie=365 reply_cookie=0 signature=s error-name=n/a error-message=n/a

Got message type=method_return sender=org.freedesktop.DBus destination=:1.480 path=n/a interface=n/a member=n/a  cookie=4294967295 reply_cookie=365 signature=a{sv} error-name=n/a error-message=n/a

D-Bus hostname resolution request from client PID 61950 (resolvectl) with UID 0

Looking up RR for ns1.nyc3.example.com IN A.

Looking up RR for ns1.nyc3.example.com IN AAAA.

Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=AddMatch cookie=366 reply_cookie=0 signature=s error-name=n/a error-message=n/a

Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=GetNameOwner cookie=367 reply_cookie=0 signature=s error-name=n/a error-message=n/a

Got message type=method_return sender=org.freedesktop.DBus destination=:1.480 path=n/a interface=n/a member=n/a  cookie=4294967295 reply_cookie=367 signature=s error-name=n/a error-message=n/a

NODATA cache hit for ns1.nyc3.example.com IN AAAA

Regular transaction 9888 for <ns1.nyc3.example.com IN AAAA> on scope dns on br0/* now complete with <success> from cache (unsigned; non-confidential).

Positive cache hit for ns1.nyc3.example.com IN A

Regular transaction 34454 for <ns1.nyc3.example.com IN A> on scope dns on br0/* now complete with <success> from cache (unsigned; non-confidential).

Freeing transaction 9888.

Freeing transaction 34454.


значит он написал что получил запрос по дбасу. что ищется две записи

  ns1.nyc3.example.com IN A.
  ns1.nyc3.example.com IN AAAA.


далее он написал что для обоих записей есть инфо в кеше , что для AAAA инфо нет от днс
сервера. а для A она есть
также он написал что информация была ранее получена через br0
и то что конец обоих транзакций

я полагаю но нехочу проверять что если бы я запустил свежий реквест то влогах он бы
отразил и адрес DNS сервера к котрму он посылал запрос.

я возвращаю уровень логирования sd демаона до минимума

    # resolvectl log-level 0


еще я хочу поймать этот запрос через tcpdump

  # tcpdump -i any -n "port 53"

и я его поймал

br0   Out IP 172.16.10.1.51586 > 172.16.10.11.53:  A? ns2.nyc3.example.com. 
br0   Out IP 172.16.10.1.54490 > 172.16.10.11.53: AAAA? ns2.nyc3.example.com.
br0   In  IP 172.16.10.11.53 > 172.16.10.1.51586: 18585* 1/0/1 A 172.16.10.3 (65)
br0   In  IP 172.16.10.11.53 > 172.16.10.1.54490: 14037* 0/1/1 (95)

тоесть видно что через br0 к 172.16.10.11 было послано два запроса 
и получено оттуда два ответа.
все как я и хотел добиться от ds демона!

еще приведу эти команды

    # resolvectl domain  br0 nyc3.example.com
    # resolvectl dns   br0  172.16.10.11
    # resolvectl dnsovertls br0 off
    # resolvectl dnssec  br0 off
 
теперь вопрос , как добитьс чтобы это можно было занейсти в конфиг sdr
а не вводить руками ?

я пока незнаю как это сделать но я скажу еще одну важную вещь. 
конфиг sdr /etc/systemd/resolved.conf его не рекомендуется править. это можно 
но не рекомендуется. ибо в нем типа записны дефолтовые устанвоки которые были сделаны
на стадии комплирования этого демона. вместо этого рекмоедуется создать новый файл
в папке

  /etc/systemd/resolved.conf.d

  например 

  $ > /etc/systemd/resolved.conf.d/custom.conf

и туда засунуть наши настройки

# cat custom.conf 

[Resolve]
DNS=1.1.1.1
FallbackDNS=8.8.4.4

DNSSEC=on
DNSOverTLS=yes
Domains=com

MulticastDNS=no
LLMNR=no

по мне лишняя усложняющая хрень. хотя наверно они имеют ввиду что когда 
демон обнвоится то его файл с дефолтами безболелзнено обвновится а мой кастом файл
при этом останетя и ничего не затреться. ну незнаю. 

так вот имея такую гроздь из конфигов они предалгаю вот как   в итоге смотреть
все это на одном экране

 # systemd-analyze cat-config systemd/resolved.conf

во первых эта комада приколно все подсвечивает. 
воо вторых она мне соберет единый конфиг из исходного sdr и моего кастомного.
нормал но как то заморочно на пустом месте.

кстати моя версия systemd-resolved
      $ systemd-resolve --version
        systemd 256 (256.4-1-manjaro)


так вот у меня щас два вопроса 
  1) как венсти изменения в конфиг чтобы не вбивать руками каждый раз
    # resolvectl domain  br0 nyc3.example.com
    # resolvectl dns   br0  172.16.10.11
    # resolvectl dnsovertls br0 off
    # resolvectl dnssec  br0 off
    # resolvectl  domain  br0 nyc3.example.com  dns   br0  172.16.10.11  dnsovertls br0 off dnssec  br0 off

  2) что значат "route-only domains" с тильдой в Domains ?

(бл никода не думал что systemd-reslved это целый мир.)


по поводу превого вопроса как я понял заснуть эти настройки в конфи невозможно.
это реально прикол. настройки как я понял в sdr они глобальные. а для интерфейсов
туда ничего засунуть нельзя. они завялвют в мане к resolved.conf
что для ключа

  DNS=

можно вот такое заюзать

Each address can optionally take a port number separated with ":",
a network interface name or index separated with "%", and a Server Name Indication (SNI) separated with "#"
That is, the acceptable full formats are 
      "11.22.33.44:9953%ifname#example.com"

я пробовал - эта хрень неработает вообще никак. работает только вот так
    11.22.33.44:9953#example.com

этот днс добавлется имено в секцию Global. и мое впечатление что example.com это не домен
для котрого он предназачен а это доменное имя самого этого днс сервера! вобщем это не 
рабочая хрень и не то что мне нужно

из тго что я пока нашел что днс сервера пер интвфейс можно вставит в sd либо через
resovelctl cli, либо через настроки systemd-networkd но это мне нахрен ненадо у меня
для этого NetworkManager, либо (я еще непонял как) всостать настройки от NetworkMAnager

хочу замтеит еще вот что по поводу как работает конфиг sdr
если  я укажу вот так 

  [Resolve] 
  DNS=1.1.1.1 
  DNS=2.2.2.2

то вторая настройка не перебьет первую они сложаться и оба сервера добавятся. 
кстати эквивалентом яялется 

  [Resolve]
  DNS=1.1.1.1  2.2.2.2


так что первый вопрос пока висит в воздухе
  1) как венсти изменения в конфиг чтобы не вбивать руками каждый раз
    # resolvectl domain  br0 nyc3.example.com
    # resolvectl dns   br0  172.16.10.11
    # resolvectl dnsovertls br0 off
    # resolvectl dnssec  br0 off


перехожу пока к вопросу номер два
  2) что значат "route-only domains" с тильдой в Domains ?


значит я читаю портянку из 

    $ man resolved.conf


 A space-separated list of domains, optionally prefixed with "~", used for two distinct purposes described below. Defaults to the empty list.

           Any domains not prefixed with "~" are used as search suffixes when resolving single-label hostnames (domain names which contain no dot), in order
           to qualify them into fully-qualified domain names (FQDNs). These "search domains" are strictly processed in the order they are specified in, until
           the name with the suffix appended is found. For compatibility reasons, if this setting is not specified, the search domains listed in
           /etc/resolv.conf with the search keyword are used instead, if that file exists and any domains are configured in it.

           The domains prefixed with "~" are called "route-only domains". All domains listed here (both search domains and route-only domains after removing
           the "~" prefix) define a search path that preferably directs DNS queries to this interface. This search path has an effect only when suitable
           per-link DNS servers are known. Such servers may be defined through the DNS= setting (see above) and dynamically at run time, for example from
           DHCP leases. If no per-link DNS servers are known, route-only domains have no effect.

           Use the construct "~."  (which is composed from "~" to indicate a route-only domain and "."  to indicate the DNS root domain that is the implied
           suffix of all DNS domains) to use the DNS servers defined for this link preferably for all domains.

           See "Protocols and Routing" in systemd-resolved.service(8) for details of how search and route-only domains are used.

           Note that configuring the MulticastDNS domain "local" as search or routing domain has the effect of routing lookups for this domain to classic
           unicast DNS. This may be used to provide compatibility with legacy installations that use this domain in a unicast DNS context, against the IANA
           assignment of this domain to pure MulticastDNS purposes. Search and routing domains are a unicast DNS concept, they cannot be used to resolve
           single-label lookups via MulticastDNS.

           Added in version 229.

ВАЖНО - тут я хочу сказать по поводу настройки "Domains=~."
я дальше про нее много хуйни написал. потому что незнал. но исправлят забеешься
поэтому я пишуздесь наверху как только идет первое упоминание. я хочу сказать что эта
настройка не панацея. она не во всех случаях заставлять идти запросы тольько через
секцию с ней. ЭТО НЕТАК, это верно только в ряде случаев.!!!!!
если у меня есть Global секция и пер-интерфейс секция

Global
         Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=allow-downgrade/supported
  resolv.conf mode: stub
Current DNS Server: 172.16.10.1
        DNS Servers 172.16.10.1
        DNS Domain: ~.   <=============  (1)

Link 2 (enp0s3)
    Current Scopes: DNS
         Protocols: +DefaultRoute <===============  (2)
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8
        DNS Domain: co.uk  <============== (3)

то от того чему равны вот эти три параметра будет завситеть какой днс сервер 
или даже оба этих днс сервера будут использованы для выполенеия реквеста!!!! сука!!!
параметр DNS Domain может принимать четыре интересных значения
   DNS Domain ~.     (означает любой домен)
   DNS Domain пусто
   DNS Domain co.uk
   DNS Domain ~.co.uk
причем еще важно в какой секции оно стоит в глобальной или пер-интерфейс


DefaultRoute может принмать два занчнеия
  -DefaultRoute
  +DefaultRoute

и вот исходя из этого получается вся эта страшная ЕБАЛА!
я щас попытаюсь найти закон чтобы быстро понять по какому "роуту" пойдет днс
реквест при разных значениях "DNS Domain:" в Global секции и пер-интерфейс секции
и параметру DefaultRoute

исходя из мана systemd-resolved написано следущее:
кьюри шлется на все домены в тех сециях где будет совпадение с параметр Domains
если совпадения нет то кьюри шлется на интерфейсы с флагом +DefaultRoute и на днс из
Global section , если в глобаьной секции несконфиргровано нихрена днс сервераов ни 
одного и если нет  +DefaultRoute интерфейсов то тогда запрос идет на днс который 
зашит по дефолту в бинарник.(они указаны в файле resolved.conf через коментарии #)
Если я хочу гарнатировать что днс из пер-интефейс секции никогда не будет использован
кроме как для резволинвгга домена котоырй указан в свойствах сеции то нужно в этой
секции нужно устнвоит -DefaultRoute
Значит написано что для того чтобы все запросы которые не попадают в какито интерфейс 
секции явно на основе параметра Domains то нужно на каком то интерейсе указать 
Domains=~. , тогда все что явно непопало в другие секции пойдет на этот интерфейс
Еще вариант на этот интерфейс вместо Domains=~. захреначить опцию +DefaultRoute



смортрим варианты


    Global 
      DNS Domain:

    Link 2 (enp0s3)
      -DefaultRoute
      DNS Domain:

запрос идет сразу через Global секцию
тут сработало правило если нет прямого совпадения в секциях по строке  "DNS Domain:="
то тогда поиск идет через днс сервер в глобальной секции и через интерфейс(ы)
с флагом  +DefaultRoute. так как у нас второго нет то поиск идет только через 
глобальную секцию



    Global 
      DNS Domain:=

    Link 2 (enp0s3)
      +DefaultRoute
      DNS Domain:=

запрос идет сразу через две секции
тут сработало правило если нет прямого совпадения в секциях по строке  "DNS Domain:="
то тогда поиск идет через днс сервер в глобальной секции и через интерфейс(ы)
с флагом  +DefaultRoute. тут у нас так и есть глобаьльная секция и секция enp0s3






    Global 
      DNS Domain:= ~.

    Link 2 (enp0s3)
      -+DefaultRoute
      DNS Domain:= ~.

запрос идет через два сервера как вслучае -DefaultRoute так и в +DefaultRoute
это совпадает с теорией, что запрос пойдет через секции где запрос совпдаает с
секцией "DNS Domain". кстати ~. это как * . поэтому задействуется две секции. 
поэтому тут даже неважно чему равно DefaultRoute



    Global 
      DNS Domain:= com

    Link 2 (enp0s3)
      -DefaultRoute
      DNS Domain:= com

запрос rambler.ru идет через Global секцию
это совпадает с теорией. о том что если запрос не попал ни в одну секцию я так 
понимаю и даже глоабную по строке "DNS Domain" то запрос идет через глоабную секцию
и интерфейс(ы) с флагом +DefaultRoute, у меня такого интерейса нет. остается только
глобальная секция.

запрос yahoo.com идет через два сервера 
тут тоже по теории. все секции в которых получается совпадение по строке DOMAINS 
на их всех шлется запрос. у меня две сеекции с "com" поэтому и будем чрез две секции.


    Global 
      DNS Domain:= com

    Link 2 (enp0s3)
      +DefaultRoute
      DNS Domain:= com

запрос yahoo.net идет через два сервера
тут по теории. так как нет совпадения по строке Domain. то запрос идете через 
днс глобальной секции и через секции где выставлен флаг +DefaultRoute

запрос yahoo.com идет через два сервера
тут тоже по теории. все секции в которых получается совпадение по строке DOMAINS 
на их всех шлется запрос. у меня две сеекции с "com" поэтому и будем чрез две секции.



    Global 
      DNS Domain:= 

    Link 2 (enp0s3)
      -DefaultRoute
      DNS Domain:= com

запрос yahoo.net идет через Global секцию
это совпадает с теорией

запрос yahoo.com идет через пер-интерфейм секцию
это совпадет с теорией


    Global 
      DNS Domain:= 

    Link 2 (enp0s3)
      +DefaultRoute
      DNS Domain:= com

запрос yahoo.net идет через два сервера - это по теории
запрос yahoo.com идет через пер-интерфейм секцию - это по теории





    Global 
      DNS Domain:= ~.

    Link 2 (enp0s3)
      -DefaultRoute
      DNS Domain:=

запрос идет через General секцию  как вслучае -DefaultRoute так и в +DefaultRoute
это совпадает с теорией. у нас тупо идет совпадение по строке Domain. потому что 
~. = *



    Global 
      DNS Domain:= 

    Link 2 (enp0s3)
      +DefaultRoute
      DNS Domain:= ~.

запрос идет через per-interface секцию как вслучае -DefaultRoute так и в +DefaultRoute
это совпадает с теорией. у нас совпадение по строке "DNS Domain"




Ответ на главный вопрос - можно ли прописать чтото в Global section чтобы 
внезависиости от того что прописано будет в per-interface секции у нас запросы
шли только чеерз глобаьную секцию. ответ такой настройки нет! если в секциях 
per-interface не будет прописана строка  DNS Domain тоесть она будет пустая
тогда да в глобальной прописываем 

      DNS Domain:= ~.

и это поможет.
а если в пер-интерейс секции заснууть хотя бы один домен. 



    Link 2 (enp0s3)
      DNS Domain:  com

тогда как ни крути запросы на com домен будут идти чрез днс этого линка!




еще момент. 
я уже писал а может и неписал что сам демон systemd-resolved ОН НЕЧИТАЕТ НАСТРОЙКИ
ДЛЯ СЕБЯ ИЗ ФАЙЛА /ETC/RESOLV.CONF 
реально он этого неделает. он свои настройки читает из resolved.conf также
из /etc/systemd/resolv.conf.d/*.conf и из /run/systemd/resolve/...
и его настройки можно поменять на лету через resolvectl или через сокет d-bus
или черего его собвтенный сокет. поэтому думать что я щас чтото изменю в /etc/resolv.conf
укажу там другие днс сервера и это повлияет на sr это ошибка! единственное что делает
sr это он гененрирует свои версии этого файла , туда sr публикует свои настройки 
чтобы дургие программы которые неиспользуют NSS для запросов или которые не используют resolvectl для запросов или которые неиспользуют d-bus для запросов а которые ищут
названия днс серверов сами в /etc/resolv.conf чтобы эти программы прочитав /etc/resolv.conf
получили ПОВОЗМОЖНОСТИ теже самые настройки днс серверов что использует сама программа sr,
также в каких то файла sr указывает саму себя как днс сервер 127.0.0.53 чтобы те 
другие программы все равно заставит делать днс запросы через саму эту sr программу.
поэтому еще раз sr неиспользует erc файл для своих настроек. программа sr публикует в
erc файл свои настройки по днс серверам которые она использует. чтобы другие программы
использовали такие же днс сервера. она как бы через erc файл говорит : эй! другие программы
я использую вот эти днс сервера! у меня такие! и вы тоже их используйте! поэтому она 
только сообщает свои днс сервера в этот файл. а не читает из него настройки для себя.
так вот демон sr создает несколько вариантов файла resolv.conf они лежат в разных местах.
а далее наша задача выбрать один из этих файлов и сделать на него симлинк из /etc/resolv.conf
если же мы сами создали обычный regular файл /etc/resolv.conf то на него непосредственно
sr никак не влияет. не корректирует. еще раз sr создает в своих папках несколько вариантов
resolv.conf файла. и говорит - если хочешь используй один из них как resolv.conf
а что значит исполлзуй? это значит сделай на один из них симлинк в /etc/resolv.conf
если же файл /etc/resolv.conf (erc) уже создан и он обычный то в него sr невлезает
как это делает например NetworkManager.  так как настройки sr можно менять на лету
через resolvectl то после таких изменений sr также сразу меняет вот эти свои варианты
resolv.conf файлов. также понятно что режим работы sr гораздо более сложный чем 
это можно законфигурировать через erc. потому что erc не поддерживает per-interface
dns кониугацию. поэтому erc это жалкое подобие конфигурации sr демона. 
в мане они пишут что если у нас erc это обычный ррегуляр файл который мы сооздали 
и там насовали руками днс сервера то якобы sr он тогда прочитает оттуда днс сервера
и  в себя их пропишет - наглейшая ложь. sr это несделает. ему в этом случае плевать
на этот файл. ПЛЕВАТЬ. ничего оттуда он в себя читать не будет.
итак sr создает три варианта erc файла. они лежат вот тут 

   /run/systemd/resolve/stub-resolv.conf
   /run/systemd/resolve/resolv.conf
   /usr/lib/systemd/resolv.conf


что у них внутри
вначале я покажу какая у меня щас конфигурация демаона sr

# resolvectl 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: foreign
      DNS Servers 172.16.10.1
       DNS Domain net

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: +DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: co.uk


а теперь посмотрим какие resolv.conf файлы он навваял на основе этой конфигурации
# grep -v '#'  /run/systemd/resolve/stub-resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search net co.uk


# grep -v '#'   /run/systemd/resolve/resolv.conf
nameserver 172.16.10.1
nameserver 8.8.8.8
search net co.uk


# grep -v '#'   /usr/lib/systemd/resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search .

во первых видно что конечноже в люом из этих файов нет никакой пер-интерфейс
конфигурации. потому что и неможет быть. далее видно что в каких то файлах 
у нас идет заворот в качестве днс сервера на сам sr. он заворачивает программы которые
будут читать такой файл в итоге на сам себя. в каких то он пееренаправоляет их
на внешние днс севрвера которые сам использует. только он их исользует умно а здесь
он их тупо собирает в одну кучу. и видно что в каких то файлах он непрописывает 
search домены вообще. а где то он их тупо опять же собирает в кучу и всатлвяет в файл.

у меня сразу возник вопрос. а если у меня в живом sr заданы не серч домена а роут-онли
домены тогда как будет?

# resolvectl 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: foreign
      DNS Servers 172.16.10.1
       DNS Domain ~net  <============

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8 
    DNS Domain: ~co.uk  <==============

а будет вот как. так как серч домен это роут-онли домен. то получается у нас в живом
sr нет ни одного указаннного серч домена! а роут-онли домены синтаксиси файла resolv.conf
не поддерживает. значит у нас в итоге в файлоах будет вот так

# grep -v '#'  /run/systemd/resolve/stub-resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search .   <========

# grep -v '#'   /run/systemd/resolve/resolv.conf
nameserver 172.16.10.1
search .   <=========

# grep -v '#'   /usr/lib/systemd/resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search .   <==========


резулььтат логичен. напомню разинцу между роут-онли доменном и серч доменом. 
если в демоне sr указан на интерфейсе route-only домен (обозначается ттильдой)

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: ~co.uk  <============

то запрос содеражащий этот домен будет направлен на днс сервер этого интерфейса. 
в данном случае на 8.8.8.8

search домен работает точно также!

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: co.uk  <============

но серч домен делает еще одну штуку. если в запросе домен состоиит из одного слова
то к этому слову добалвяет в хвост наш серч домен и уже этот запрос направляется на 
8.8.8.8
например в ориг нальном запросе было 
   
     # resolvectl -4 query   vasya

тогда vasya будет заменен на vasya.co.uk и уже этот запрос будет направлен на 8.8.8.8
так делает только серч домен. роут-онли домен так не делает.

далее важный момент про эти серч домены, возвращаюсь к прежней конфиграции
демона и сгенерированным им файлам

# resolvectl 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: foreign
      DNS Servers 172.16.10.1
       DNS Domain net

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: +DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: co.uk


а теперь посмотрим какие resolv.conf файлы он навваял на основе этой конфигурации
# grep -v '#'  /run/systemd/resolve/stub-resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search net co.uk


# grep -v '#'   /run/systemd/resolve/resolv.conf
nameserver 172.16.10.1
nameserver 8.8.8.8
search net co.uk


# grep -v '#'   /usr/lib/systemd/resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search .

так вот вопрос - кто модифицирует исходный однословный запрос в многословный путем
добавляение в хвост серч домена? это делает сам демон? или это должна делать исходная
юзерская программа? или кто? это очень важный и хитрый вопрос.
так вот работает это так - если мы обратились к демону sr чеерез локальный сокет. 
тоесть через d-bus сокет или у самого демона тоже есть свой персоанальный UNIX сокет
то в этом случае если в демона через сокет прилетел однословный запрос ОН САМ смодифицирует
этот однослонвый запрос в многословный. так происходит когда мы делаем запрос через 
программу resolvectl потому что она обращается  к sr через d-bus сокет либо  если
обращание идет через любую программу которая resolvit dns запрос 
через использование NSS библиотеки glibc правда при условии что в файла nsswitch.conf
указан плагин resolve

    $ cat /etc/nsswitch.conf | grep reso
    hosts: resolve files myhostname dns
            /\
            ||
            ||

            плагин

в этом случае програма обращается к nss , nss подключает плагин resolve а он через
локальный сокет обращается к sr и пересылает без изменений оригинальный запрос от 
юзерской программы и в этом случае sr смотрит что запрос прилетел через локальный сокет
и заменяет однословный реквест на многословный на основе присоединения серч домена

если же программа обращается к sr через сетевой сокет тоесть через адрес 127.0.0.53
то sr рассматривет это обращение так как бутто sr это днс сервер сидящий гдето там 
далеко в интернете а не лоакально на компе и откуда то снаружи прилетел запрос. 
и в этом случае sr немодифицирует прилетевший запрос никак. потому что внешний днс 
сервер типа 8.8.8.8 у себя внутри не имеет никаких серч доменов. он принимает прилетевший
запрос и резолвит его как он есть. 
я это в частности  к чему веду - как правило(но не всегда) программа которая обращется
к sr чеерз локальные сокеты либо через nss она вообще не читет /etc/resolv.conf 
или если читает то потом его игнориует то есть считай не читает а полностью полностью
полагается на всю ту подсистему которая лежит ниже что она сама все полностью 
сделает что положено в плане резволвинга днс реквеста. скажу огрубленно - програмы
испольующие локальный сокет для обращения к sr либо испольщующие nss они /etc/resolv.conf
нечитают. а читают его те программы которые сами являются днс клиентами умеют разговаривать
с днс им только дайте адрес внешнего днс сервера и они его ищут в /etc/resolv.conf
так вот таким программам  прочитавщим /etc/resolv.conf нужно самими делать замену
однословного реквеста на многословный потому что , вот эта программа прочитала /etc/resolv.conf там указан днс сервер 127.0.0.53 , программа делает реквест на 127.0.0.53 
в виде слова vasya. демон sr получив реквест "по сети" небудет менять реквест vasya
(подставляя в него серч домен) на скажем vasya.com или vasya.net  это задача исходной
программы сделать эту замену. sr не будет делать эту замену хотя он может потому что 
реквест прилетел "по сети". вот почему sr хоть и может но не будет делать замену.
если бы реквест прилетел через локальный сокет он конечно бы это сделал.
а так как запрос прилетел  по сети то sr поступает также как сервер 8.8.8. он не 
модифицирует исходный запрос. 

теперь  я возвращаюсь к файлам 

# grep -v '#'  /run/systemd/resolve/stub-resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search net co.uk

поэтому если программа считает этот файл то она сама обязана сделать подстановку
добавление .net или .co.uk в однословный реквест а уже потом пихать этот реквест 
в 127.0.0.53 , если сама программа этого несделает то sr за нее менять ничег не будет.
он просто верент ошибку. то есть при этом файле замену серч домена  должна делать сама программа. а уже сам реквест сделает на внешние сервера sr, 
опят же я так понимаю что 
    options edns0
это указание для юзерской программы как ей надо составлять реквест. потому что 
юзерская программа реально должна понимать днс протокол и сама должна составить
полностью днс реквест со всеми регалиями. потому что вместо 127.0.0.53 может 
стоять 8.8.8.8 а он требует чтобы ему прислали днс реквест со всеми флагами и 
регалиями. вобщем этот resolv.conf он как бы говорит юзер программе - слушай
если ты мне однословный реквест собираешься посылать то сама его преобразуй в .net
или в .co.uk ибо я этим заниматься не буду. также сама в запросе используй edns0 
опцию. и свой готовый реквест кидай на 127.0.0.53 а sr получив реквест его
ни в коем случае неменяет. он только его "роутит" на тот или иной днс сервер
тоесть если бы программа обращалась к sr через сокет ей бы нихрена ненужно было
делать за нее все бы сделала сама sr. а раз она читает resolv.conf то ей выкатывается
сразу целая гора заданий а именно - сама преобразуй однословные запросы в многословные,
сама вставляй в запрос edns0(все таки надо будет посмотреть что дает эта опция. 
я знаю что она расширяет размер udp пакета под днс типа того. это дает 
возможность передвать dnssec записи например. а что еще дает?) опцию, и потом уже 
бросай этот реквест в 127.0.0.53 
изначально файл erc предназначен для glibc dns резолвера (днс клиента) 
он ему предписывает директивы которым он должен слушаться. потому что изанчально схема
была какая. юзер программа обрашается к glibc резолверу он читает erc файл и неукоснительно
выполняет его директивы. а теперь у нас юзер программы читают erc файл и хотят выполняют
директивы хотят не выполняют. поэтому erc файл это не файл информационный хочу делаю
хочу неделаю. это файл с строгими директивами. например директива
  
    search net com

говорит программе. если в тебя ввели слово vasya то обязатеьно его переделай в 
vasya.net а программа dig например по дефолту этого не делает. поэтому этот файл он таков
что тот кто его читает обязан выполнять то что он говорит. а если программа не выполняет
то она нарушает. 

итак еще раз что этот файл нам говорит
# grep -v '#'  /run/systemd/resolve/stub-resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search net co.uk

он предписывает программме читающий этот файл однословный реквест передалать добавив
в него на конце .net , также использовать опции edns0 и trust-ad я так понимаю
это означает что в днс ревесте который составляет программа нужно выставить какието
флаги. и только потом этот реквест передавать на указнный днс сервер 127.0.0.53

в этом конфиге мне вот что странно. если запрос все равно улетит на sr нахрена она
нагружает лишней работой программу. ведь если в конце концов сама sr будет обрабатывать
реквест она может это все сделать сама. на мой взгляд если в унас 

nameserver 127.0.0.53

то больше ничего в этом файле ненужно чтобы было а sr в свою очередь должен 
все остальное делать сам. но увы.

значит я еще раз проверил. если реквест прилетает на sr через сетевой сокет то он 
его обрабатываеи точно также как когда он прилетает через локлаьный сокет за исклчючением
одной вещи - несмотря на то что в свойствах sr могут стоять search домены он демон sr
неделает превращение однословных доменов в многословные. он это перестает делать. 
серч домены указанные в свойствах демона превращаются в route-only домены. 
поэтому функцию превращения однословных доменов в многословные он вынес на плечи
самой юзер программы. поэтому этот файл подходит для случая когда мы хотим чтобы юзер
программа которая незнает что такое NSS и незнает что такое d-bus сокет. чтобы запрос
от этой программы был обработан практически ровно также как он будет обработан если
днс запрос будет послан через NSS подсистему. при условии что сама программа будет
преобразоывать однословные реквесты в многословные сама. поэтому этот файл нам позволяет
обработать реквест от "тупой" программы которая неиспользует NSS или неиспользует d-bus
практически также как для "хорошей" программы которая использует. 


следущий файл

# grep -v '#'   /run/systemd/resolve/resolv.conf
nameserver 172.16.10.1
nameserver 8.8.8.8
search net co.uk

он таков что мы исключаем sr из процесса резолвинга. он просто накидал в кучу те 
днс сервера которые у него есть. и мы хотим заставит программу перед реквестом 
трансформировать однословные реквесты в .net и .co.uk
этот файл подойдет для случая когда мы хотим чтобы "тупая" программа которая не исполь
зует NSS и d-bus чтобы она сама полностью и целиком все решала и делаал сама. 
такая программа читает все директивы а дальше она должн сама решать через какой днс
сервер ей слать реквест и как ей обрабатывать однословные запросы. 
тоесть грубо говоря sr весь свой конфиг сбраывает в кучу в erc файл. и говорит - ну
юзер программа вот тебе все карты. сама все делай и все решай.



# grep -v '#'   /usr/lib/systemd/resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search .
 
третий файл таков что реквест от "тупой" программы обрабатывает полностью sr
но ни sr не будет заниматься преврашением однословных реквестов ни сама программа
этим заниматься не будут. только в первом файле программа тоже могла этим не заниматься
а могла и заниматься а здесь мы даже программе не оставляем такой вариант.
я проерил если этот файл через симлинк сделаьт erc то логика работы sr неменяется.
тоесть sr неделает подстановку в односложный домен несмотря что у нее настроены
серч домены. а программа не может этого сделать потому что она понятие неимеет что
на компе есть какието серч домены.
честно говоря я не понимаю зачем может понадобтится этот файл. более того я даже не
понимаю зачем может понадобится второй файл. ведь если мы в /etc/resolv.conf суем второй
или третий файл то у наас получается пиздец. потому что - часть программа на компе
которые юзают d-bus или NSS их реветы будут обрабатьывася по одному алгоритму на одних
днс сереверах итд итп. а часть программ которая не знает что такое nSS и d-bus их реквесты
будут обрабатьыватся по совершенно другому алгоритму!!!!! ЗАЧЕМ ЭТОТ ВИНИГРЕТ !?!??!!?!?
ЯНЕПОНИМАЮ

могу еще вот что добавить. если у нас /etc/resolv.conf (erc) это ссылка 
на первый файл то в статусе resolvectl будет написано 

Global
  resolv.conf mode: stub  <=====

если erc это ссылка на второй файл то в статусе resolvectl будет 
написано

Global
  resolv.conf mode: uplink  <=====


если он ссылка на третий файл то в статусе resolvectl будет написано

Global
  resolv.conf mode: static  <=====

а если erc это не симлинк ни на один из этих файлов а какотой другой файл
неважно он регуляр или симлинк на какойто левый файл главное что erc это не 
симлинк ни на один из трех указанных файло в то в статусе resolvectl 
будет написано

Global
  resolv.conf mode: foreign  <=====

таким гляда на эту строку в resovectl мы сразу можем сказать как у нас выглдяит
файл /etc/resolv.conf

я считаю что из указанных трех файлов единственный смысл имеет файл первый. 
все остальное это полная хуйня. которая как я уже сказал приведет к тому что
NSS aware программы и d-bus aware программы  их ние днс реквесты будут обрабатьывася
по одному алгоритму. а программы все другие "тупые" они будут обрабатьыватся по другому
алгоритму. у нас небудет единообразия. у нас на компе будет бардак и каша. 
вопрос - зачем зачем зачем они дебилы так сделали? для тестовых целей можно. 
но для повседневной ежденевной обычной детлелности оно нафиг ненужно!







продолжение про Domains.
так вот из нее следует что якобы если я указывают в resolved.conf опцию Domains 
без тильды

      Domains = com

то этот домен com служит для того чтобы если я ввел реквест в виде одного слова то
к этому домену добавляется на хвост .com превращая неполноценный реквест домена 
в полноценный (полноценный реквест должен запрашивать домен хотя бы второго уровня)

напомню что из того что я выяснил все опции в resolved.conf имеют относятся к 
Global настройкам демона и ни в коем случае не относятся к per-interface настройкам
ибо невозможно через sdr указать настройки для интейрейфса отдельного эти дэбилы
это не предусмотрели. если хочешь добавить настройки  под интерфейс пользуйуся командной
строкой resolvectl. итак 

      Domains = com

оно настраивает секцию Global в демоне.  так вот в мане эти дебилы пишут премилую вещь

           The domains prefixed with "~" are called "route-only domains". All domains listed here (both search domains and route-only domains after removing
           the "~" prefix) define a search path that preferably directs DNS queries to this interface.

о том что если я укажу  домен с тильдой


  Domains = ~com

то это влияет на ЭТОТ ИНТЕРФЕЙС, у меня вопрос на какой это бл* интерфейс? если 
я читаю мануал от sdr в которой ниодна настройка не может быть опредеелена ни для
какого интерфейса! так что значит фраза этот интерфейс дебилы?

итак еще раз оо о чем они пишут

Any domains not prefixed with "~" are used as search suffixes when resolving single-label hostnames (domain names which contain no dot), in order
           to qualify them into fully-qualified domain names (FQDNs). 

если   я в Domains засуну домен без тильды

    Domains = com net ru

то все эти доммены они пшут исплользуются только для того чтобы однословные домены
в рекквесте превратить в полноценные домены путем добалавения им в хвост домена
из "Domains"
окей. я это понял я это принял. они пишут что ни для чего другого эти домены
не используются которые без тильды.

так вот я что хочу сказат даже в этому куске уэе как бы  и ест наебалово. 
а может его и нет. дело вот в чем. если они имеют ввиду настройку 
Domains которую мы делаем в файле resolved.conf то она глобальная ни к какому 
интерфейсу не привязанная и я согласен что если в ней происать домены без тильды
то они влияют только на преврашение однословного домена в реквесте в многословный.
НО! если  мы говорим про настройку Domains которую можно сделать per-interface 
через resolvectl то ихняя инфомрация полная хуйня. щас покажу   я запукскю серию
команд

  resolvectl domain  br0 nyc3.example.com
  resolvectl dns   br0  172.16.10.11
  resolvectl dnsovertls br0 off
  resolvectl dnssec  br0 off


и получаю в sd настроку Domains НЕ ГЛОБАЛЬНУЮ а per-interface

Link 4 (br0)
    Current Scopes: none
    Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
    DNS Servers: 172.16.10.11
    DNS Domain: nyc3.example.com  <======= 


так вот в этом случае этот домен указаный без тильды он не служит для
превращения однословного домена в многословный. как они пиздят. он служит для 
того что если я введу в запросе домен nyc3.example.com то sd запустить реквест
на днс сервер указанный для интерфейса br0

описание доменов с тильдой ~ это порсто пиздец
  The domains prefixed with "~" are called "route-only domains". All domains listed here (both search domains and route-only domains after removing
           the "~" prefix) define a search path that preferably directs DNS queries to this interface. This search path has an effect only when suitable
           per-link DNS servers are known. Such servers may be defined through the DNS= setting (see above) and dynamically at run time, for example from
           DHCP leases. If no per-link DNS servers are known, route-only domains have no effect.

потому что если в абзаце про домены без тильды они написали что такие домены
используются исклчетльно для превращения однословного домена в реквесте в многословынй
то уже в доменах с тильдами они пишут 

both search domains and route-only domains after removing
           the "~" prefix) define a search path that preferably directs DNS queries to this interface.

тоесть они пишут что и домены с тильдой (route-only domains) и домены без тильды (search domains ) испольщуются для тогочтобы "сроутить" днс запрос чреез интерфейс на 
котором они заданы. так я бл* не понял серч домены они только для превраещения 
однословнх доменов в многословыне или все таки они тоже участвуют в "роутинге"?
НИХУЯ СУКИ ОНИ НЕ ОБЯСНЯЮТ НОРМАЬНО.

в первом абзаце они четко определяюь что такое serch domain - это домен который указан 
без тильды

Any domains not prefixed with "~" are used as search suffixes when resolving single-label hostnames (domain names which contain no dot), in order
           to qualify them into fully-qualified domain names (FQDNs). These "search domains"

а во втором они говорят что домен с тильдой это route-only domain

пока что я понял еще вот что. если я в sdr укажу

    DNS=1.1.1.1
    Domains=~.

то "." это корневой домен который невидимо стоит справа у любого домена 
  yandex.ru  = на самом деле yandex.ru.

так вот такая настройка приведет к тому что sd будет направлять ВСЕ днс запросы для 
всех доменов к реквестах через DNS 1.1.1.1 и будет срать на per-interface настроенные
днс сервера и на per-interaface настроенные Domains . все благодаря настройке 
Domains=~. в sdr
да эта настрока неплоха когда мы хотим чтобы несмотря на любые инидицальные
настройки DNS и Domains per-interface у нас железно все днс запросы шли только 
через те днс сервера которые мы указали в resolved.conf
дело в том что на данный момент какимто макаром networkmanager срет мне в sr (systemd-resolved) и настраивает per-interface DNS 

поговрим пока о практике
в sdr у меня Domains закоментирован то есть он по дефолту. при этом я в статусе sr
имеют картину

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4 8.8.8.8


Link 3 (wlp2s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179


как видно у меня есть и глобальные DNS и per-interface DNS но нигде не указаны
Domains поэтому хуй знает к каким доменам это относится. 
я включил логгин и что я вижу
я вижу что он хуярит запросы и через глобаьный днс сервер 1.1.1.1 и через пер-интерфейс
днс 8.8.8.8 
такое оущщение что когда он один запрос послал на один сервер то пока тот не ответчает
он второй запрос для друого домена отправляет на другой днс. заебись.

тогда я в resolved.conf поставил

Domains=.
рестартовал демона и получил в статусе


Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4 8.8.8.8
          DNS Domain: ~.  <========


Link 3 (wlp2s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179

вобщемто забавно я вконфиге укзала "." а он в демоне включил "~." что соверешнно
не то. 
еще при рестарте срвера обратно сбарсывктся режим логирования на минимальный поэтому
надо при кажом рестарте сервера если мы хооиим мотреть подробыне логи сразу
выставлять заново

    # resolvectl log-level debug

так вот так как у меня теперь в глобальной секции появилось "DNS Domain: ~."
это значит что теперь все реквесты днс будут идти исклчтетльно через DNS сервера
этой секции тоесть через 1.1.1.1 и реально так и есть судя по логам

Using DNS server 1.1.1.1 for transaction 56356.
Using DNS server 1.1.1.1 for transaction 53690.
Using DNS server 1.1.1.1 for transaction 53959.
Using DNS server 1.1.1.1 for transaction 54332.
Using DNS server 1.1.1.1 for transaction 33129.
Using DNS server 1.1.1.1 for transaction 26541.
Using DNS server 1.1.1.1 for transaction 37273.
Using DNS server 1.1.1.1 for transaction 35464.
Using DNS server 1.1.1.1 for transaction 45799.
Using DNS server 1.1.1.1 for transaction 52274.
Using DNS server 1.1.1.1 for transaction 679.
Using DNS server 1.1.1.1 for transaction 19867.


используется железно только 1.1.1.1 и идите нахуй со своими пер-интерфейс настройками
как я понимаю если я вставлю в любую секцию sd тоест хоть в глоаббаьльную секцию
хоть в скцию какогото интерфейса строчку

   Domains=~.

то все запросы будут идти иключетельно через днс сервера этой секци.
в данном случае такая насторйка была сунутв в  в глоабальную секцию и поэтому все 
днс рквесты идут через днс севрер глоальной скции тоест 1.1.1.1
кстати меня удивляет что днс резовлер это даже не бразуер у него фнукционал простой
и убогий но как же эти дебилы усложнили конфинурирование такой прстой программы.


в чем же разница вот такого статуса

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4 8.8.8.8


Link 3 (wlp2s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179


и вот такого

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4 8.8.8.8
          DNS Domain: ~.  <========


Link 3 (wlp2s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179


разница в том как я понимаю что в первом случае все днс серверы в каждой 
сеции не имели привязи ни к каким доменам. поэтому как я понимаю потому что эти 
суки ниего нормально описали что все днс сервера со всемх секций они все неприкаянные
и подходят для резолвинга любых доменов. поэтмоу в первом случае днс серевер 8.8.8.8 
из секции wlp2s0 он тоже как бы становится глоьальным. поэтому sr использует 
как в пушке с мноеством ствоолов то один то второй то один то второй.

а вот очередная странная хуйня
я сделал вот так

# resolvectl status
Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
         DNS Servers: 1.1.1.1 8.8.4.4
Fallback DNS Servers: 8.8.8.8
          DNS Domain: ~.



казалось бы sr долже юзать оба сервера поочереди. но нихуя.
лог показывает что он юзает только 8.8.4.4
я сделал вот так

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
         DNS Servers: 8.8.8.8 1.1.1.1 8.8.4.4
Fallback DNS Servers: 9.9.9.9
          DNS Domain: ~.


у меня написано что все запросы идут через 8.8.8.8
я сделал вот так 

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
         DNS Servers: 1.1.1.1 8.8.8.8 8.8.4.4
Fallback DNS Servers: 9.9.9.9
          DNS Domain: ~.

у меня пара запросов прошла через 1.1.1.1 а все остальные через 8.8.8.8
у меня вот какое подозрение. что он кадхдый запрос пуляет сразу на все 
днс сврера. а с того с которого первее прилетел ответ в логах рисует что 
он толко на него посылал.
щас проверю через tcpdump. а ксатти он мне нихуя не покажет потмоу что у меня
трафик шифрованный. но я щас в дебиане эту хуню прверю там трафик не шифрованный
в общем что я выяснил в итоге. я могу указать несколько DNS серверов скажем  в 
глобальной секции

    DNS=1.1.1.1 8.8.4.4

если я перезагружу демона и посмтрю статус то вначале будет вот так

Global
         DNS Servers: 1.1.1.1 8.8.4.4

и не будет строки "Current DNS Server"
на этом этапе демон может послать запрос со всех указанных днс серверов. 
но через пару запросов он выитоге выберет один какйото. 
и в статусе появяится сттрока "Current DNS Server"

Global
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1 8.8.4.4


и я проверил через tcpdump что демон будет слать запросы толлько реально через 
этот днс серевер. и если активировать логи то в логах получается тоже правда написана
он ровно через какой сервер посылает запросы ровно такой сервер он в логах и указывает.

поэтому как мне щас видится что ест смысла указать парочку днс серверов в ключе DNS
и один два в разделе FallbackDNS

DNS=1.1.1.1 8.8.4.4
FallbackDNS=8.8.8.8

тогда будет вот что. он пошлет по одному два реквеста через 1.1.1.1 8.8.4.4
выберет тот который более быстрый и будет шарашить запросы только через него. 
и на случай если два сломаются то один запасной в FallbackDNS
забивать 100 днс севреров в ключе "DNS=" нет смысла. он их все протыкает но выберет
один. можно указать две три штуки исходя из того чтобы он выбрал один но самый 
быстрый. но использовать их как револьвер он не будет. будет юзать только один.
я это все чрез tcpdump проверил. и в логах он тоже не врет. я проверил. полное 
совдпанеие с tcpdump

тогда какая у нас будет ситуция  в случае такой картины

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
  Current DNS Server: 8.8.4.4
         DNS Servers: 1.1.1.1 8.8.4.4
Fallback DNS Servers: 8.8.8.8
          DNS Domain: ~.


Link 3 (wlp2s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179


поскольку у нас есть строчка "DNS Domain: ~." в секции глобал то все реквесты будут 
идти через DNS сервер из секции Global . что там в других скциях нас теперь 
асболютно не волнует. так что ситация вырождается до вот такой

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
  Current DNS Server: 8.8.4.4
         DNS Servers: 1.1.1.1 8.8.4.4
Fallback DNS Servers: 8.8.8.8
          DNS Domain: ~.

у нас в конфине указано два основных днс серввера 1.1.1.1 8.8.4.4 
в итоге изних двоих он выбрал один 8.8.4.4 и все заросы он бдует шарашить только 
через него! вот как это будет работать

если трафик шифрованный то чрез tcpdump уже не посмтришт. тогда выход только такой
что активировать лог левел дебаг. и смотреть там вот так

      # journalctl -f -u systemd-resolved | grep "Using DNS server"


АН НЕТ! оказалось что при шифрованном трфике очень даже можно через tcpdump dns
трафик посмотреть. всего навсего надо поставит в качестве интфрейса tun0  вкоторый
и из котрого трафик вылетает и влетает еще незашифованный! и все отлично видно!

хотя нет. не видно нихрена

IP 172.16.50.5.36652 > 8.8.4.4.853: Flags [P.], seq 253:277, ack 1644, win 490, options [nop,nop,TS val 178317776 ecr 2059310932], length 24

IP 8.8.4.4.853 > 172.16.50.5.36652: Flags [F.], seq 1644, ack 277, win 256, options [nop,nop,TS val 2059321293 ecr 178317776], length 0
0

хотя нет! то что нужно видно!
потому что мои dns транзакации идут через TLS. так что они даже в tun0 который от впн
влетают уже заифровнные! правда мен всеравно этот метод подходит ! потому что мне нена
до видеть соержимое пакета! мне надо видеть куда он летит. четко видно что в 
сторону 8.8.4.4 и этого достатчно

в обшем далее  я выяснил еще раз и точно то что если  унас вот такая 
ситуация 

Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/unsupported
    resolv.conf mode: stub
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4 8.8.8.8


Link 3 (wlp2s0)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8 8.8.4.4 192.168.47.179


тоест у нас есть две секции. и в обоих нет параметра Domains
то для sr как я понял это днс серверы из одной секции как бы становятся. 
они не привязаны ни к каким доменам. ТАК ВОТ - он начинает запускать реквесты
через днс сервера из обоих секций. в даннмо случае это 1.1.1.1 и 8.8.8.8 и он 
не будет среди этих двух искать один более быстрый. он часть транзакций
шлет через один а часть через другой.
ЕДИНСТВННОЕ что я не могу понять он что реальрно на 8.8.8.8 шлет через wlp2s0
интерфейс? я в это не верю у меня через этот интфрейс все что летит летит на впн сервер.
тоест то что домены привязываются к днс серверам. а какая может быть привязка 
днс сереров их IP к карточкам? мне кажется карточка выбиыварается на основе таблицы
маршрутизации но не этой таблицы

вобшем вроде бы пока что из того что я увидел нет никакой привязки днс сервера 
к интерфейсу. тоесть такого нетчто если написано что 


Link 3 (wlp2s0)
Current DNS Server: 8.8.8.8

то это не значит что пакет с dst_ip=8.8.8.8 вылетит  в сеть из карточки wlp2s0
нет. пакет с dst_ip=8.8.8.8 вылетит из той карточки которая выбирается исходя
из таблицы маршрутизации а не тому на каком интфрейсе прописан этот днс
сервер в systemd-resolved . 
вот что я хотел донести!

это в рамках вопроса я пытаюсь разобраться с доменами с тильдой

еще малек в сторону если активиовать лог левел уровня дебаг или под другому 
уровня 7 то видно что имеенно сам sr запрашивает DNSSEC записи для того чтобы
самому проверить

  # resolvectl log-level 7
  # journalctl -f -u systemd-resolved


Announcing packet size 1472 in egress EDNS(0) packet.
Using feature level TLS+EDNS0+DO for transaction 56097.
Using DNS server 1.1.1.1 for transaction 56097.
Sending query via TCP since UDP isn't supported or DNS-over-TLS is selected.
Using feature level TLS+EDNS0+DO for transaction 56097.
Announcing packet size 1472 in egress EDNS(0) packet.
Using feature level TLS+EDNS0+DO for transaction 49226.
Using DNS server 1.1.1.1 for transaction 49226.
Sending query via TCP since UDP isn't supported or DNS-over-TLS is selected.
Using feature level TLS+EDNS0+DO for transaction 49226.
Announcing packet size 1472 in egress EDNS(0) packet.
Requesting DNSKEY to validate transaction 49226 (ru, RRSIG with key tag: 35739).
Positive cache hit for ru IN DNSKEY


кстати одну проблему я уже вобщем то решил. а именно - как сделать так чтобы
я задал DNS сервер в resolved.conf  и уже никакая сука не могла поменять этот факт
чтобы нетворкменеджер не мог сменить эти настройки чтобы настройка DNS сервера в 
resolved.conf была железно термоядерно надежной. чтоб ни одна сука не могла перебить
эту настройку. так вот это я уже научился делать. для этого в resolved.conf
надо прописать

    [ Resolve ]
    DNS=1.1.1.1
    Domains=.

тогда sr будет использовать 1.1.1.1 а днс сервера в других секциях игнорировать

как я понимаю когда раньше в сетевых файлах я настраивал также и dns сервер то 
это приводило к тому что скрипт который обрабаывал этот конф файл видимо совал
адрес укаазанного днс сервера в файл /etc/resolv.conf он же erc
тоесть я хочу сказать что старые сетевые менеджеры когда им указывали в их конфигах
адрес днс сервера то этот сетевой менеджер всего навсего брал указаный днс адрес 
и вставлял его в resolv.conf

в дебиан12 сеть настраивается и управляется вот как.
есть сервис
        networking.service

внутри него указано запустить вот такие бинарники

    ExecStart=/sbin/ifup -a --read-environment
    ExecStart=-/bin/sh -c 'if [ -f /run/network/restart-hotplug ]; then /sbin/ifup -a --read-environment --allow=hotplug; fi'

ifup это бинарник. и "$ ifup -a" поднимает все интерфейсы указанные  в  /etc/network/interfaces

тоесть схема работы сети в дебиан12 вот такая. запускается systemd и он запускает сервис
networking.service который по факту запускает ifup бинарник который читает файл
/etc/network/interfaces и из него поднимает сеть. насколько я понял через этот 
файл interfaces мы неможем задать адрес dns  сервера и это очень хорошо. это хорошо
что сетевой менеджер нелезет в дела днс клиента. а адрес днс сервера как я понял 
в дебиан 12 задается не через ручную правку erc а через запуск команды resolvconf
которая где то там конфиугурирвется а уже она лезет и делает настройки в erc.
я посмотрел по факту этот resolvconf это всего навсего симлинк на resolvectl
тоесть этот resolvconf это скажем так огрызок от resolvconf тоесть это неполноценный 
resolvconf. мне его испльзовать нахрен ненужно потому что  я просто сделал что erc
это симлинк на stab-resolv.conf 

в дебиан12 версия sr 
   systemd-resolved              252.3


далее  я открыл интереснейшую вещь про sr, во первых если остановить эту службу

  # systemctl stop systemd-resolved

и потом сделать к ней реквест через resolvectl

  $ resolvectl status

то sr сразу же стартует! 
и вторая интереснейшая вещь - предположим  я налету сделал пер-интерфейс 
настройку например 

    # resolvectl dns tun0 12.12.12.12

которая привела к 

Link 3 (tun0)
Current Scopes: DNS
     Protocols: +DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 12.12.12.12


так как эта настройка по идее нехранится нив каком файле то логично предпожить
что если я перезагружку sr то эта настройка пропадет. так вот хрен там. она останется!
можно остановить sr а потом запустить. можно перзагрузит sr - настройка все 
равно останется! но как это возможно?! а вот как - оказывается пер-интфрейс настройки
sr сохраняет в папку

  # ls -1 /run/systemd/resolve/netif
  2
  3

так вот в этой папке лежат файлы имена которых составлены из индексов сетевых карт
тоесть что такое 2 или 3. а вот что

# ip -c a

2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether ba:ec:24:5c:80:3f brd ff:ff:ff:ff:ff:ff
    inet 172.16.10.11/24 brd 172.16.10.255 scope global enp0s3
    ...
    ...

3: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UNKNOWN 
group default qlen 500
    link/none 
    inet 172.16.30.1 peer 172.16.30.2/32 scope global tun0
    ...
    ....

обрати внимание цифра 2 и 3 слева. оно показывает так называемый индекс сеетеовй
карты. 

так вот - если мы делаем пер-интерфейс настройки в systemd-resolved то он создает
файл в папке который я указал , имя файла это индекс сетевой карты, замечу что 
карта tun0 имеет индекс 3. ранее мы над этой картой сделали модификацию , мы к ней
прилепили днс сервер. так вот посмотрим что находится в файле 3

# cat 3 
# This is private data. Do not parse.
LLMNR=yes
MDNS=no
SERVERS=12.12.12.12

как я и сказал - оказывается в этой папке  /run/systemd/resolve/netif 
и в файле 3 наш sr сохраняет те самые пер-интерфейс настройки! 
также оказывается что если я остановлю службу sr то обычно служты при этом удаляют
все файлы которые они создали в папке /run но только не sr! он эти файлы оставляет!
поэтому когда мы стартуем обратно эту службу sr то она читает свои же файлы 
и в итоге sr узнает какие были пер-интерфейс настройки до того как ее остановили!
таким образом перезагрузка сервиса неприводит к тому что пер-интерфейс настройки
терялись. они нетеряются. потому что они сохранены в файлах! просто эти файлы
лежат не в /etc/... а в /run/...
да конечно - если перегрузить комп то все файлы в /run будут потеряны.но если
перегрузить только службу  то файлы нихрена нетеряются. потому что как я уже 
сказал sr при своей остановке нестирает свои файлы в /run/... папке.еще раз 
подчеркну что в /run/systemd/resolve/... sr сохраняет пер-интерфейс настройки!

теперь я вовзращаюсь несколько обратно по теме. я теперь знаю как работает менеджер
сети  который опирается на файл /etc/network/interfaces. 
мне надо застопить сервис networking.service
и стартануть systemd-networkd, правда надо еще к нему конфиги написать.
есть и еще одна проблема - дело в том что каждлая служба она зависиит от каких то 
служб и какието зависят от нее. поэтому скажем когда я гашу службу networking 
то вопрос - а какие еще нужно вместе с ней погасить службы.

# cat networking.service | grep After
After=
      apparmor.service
      ifupdown-pre.service
      local-fs.target 
      network-pre.target <======
      systemd-modules-load.service
      systemd-sysctl.service <======

# cat systemd-networkd.service | grep After
After=
      systemd-networkd.socket 
      network-pre.target <========
      systemd-sysctl.service <======
      systemd-sysusers.service 
      systemd-udevd.service 
      
через "<====" я указал общие службы.
вобщем я пока решил только остановить службу networking.service
не трогая службы от которых он зависит.

  # systemctl disable networking 

перезагрузился. но к моему удивлению все карточки были подняты и у них
были IP. ! значит застоитьэту службу этого мало!

я задизейблил еще одну службу
  # systemctl disable ifupdown-pre

перезагрузился но все по прежнему. карточки подняты. ip адреса на них есть!
тут я понял что сделал ошиибку! оказывается слово "After=" имеет нето значение 
которое я думал. слово "After" означает службы которые будут запущены ПОСЛЕ старта
данного юнита. значит мне надо смотреть не юниты "After=" а юниты "Before="!!

итак networking.service имеет свойства
  Before=*network.target *shutdown.target network-online.target

а юнит systemd-networkd имеет свойства
  Before=*network.target multi-user.target *shutdown.target initrd-switch-root.target

звездами я обозначил те которые общие для обоих. 
я задизейблил 
    # systemctl disable network-online.target

но сеть по прежнему есть!

далее я вот что увидел. в файле interfaces можно указать днс сервера. и там написано
что они будут законфигуииованы если в системе есть пакет resolvconf.
у меня в системе он есть по факту это симлинк на rsolvconf то есть это компонент sr
это такаая наебка.да. это не настоящий resolvocnf это такая еще раз скажу подделка
входящая в состав resolvectl, у нашего недоделанного resolvconf  входные ключи как у настоящего resolvonf а по факту это resolvectl. тоесть суть в том что когда мы вызываем resolvconf тоэто симлине на resolvctl и   resolvectl это мультибинарный файл и он это понимает и понимает новые ключи такие же как у оригинального resolvocnf, часть ключей.
так вот как это работает в итоге. когда мы вызываем это resolvconf то мы вызываем его 
вот так

    # echo "nameserver 12.12.12.12 " | resolvconf -a tun0

а по факту эта комагда в точности отработает как бутто я вызвал вот такую команду

    # resolvectl dns tun0 12.12.12.12

тоесть всего наввсего в демеоне sr для интерфейса tun0 добавится днс 12.12.12.12 
тоесть вот так было

Link 3 (tun0)
Current Scopes: none
     Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported


вот так станет

Link 3 (tun0)
Current Scopes: DNS
     Protocols: +DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 12.12.12.12


тоесть этот недоделанный "resolvconf" на лету поменяет кусок работы демона sr

также будет создан файл во временной папке /run

# cat /run/systemd/resolve/netif/3 
# This is private data. Do not parse.
LLMNR=yes
MDNS=no
SERVERS=12.12.12.12


и еще будет изменен вот этот опять же временный файл
будет добавлена строка с 12.12.12.12

# grep -v '#' /run/systemd/resolve/resolv.conf 

nameserver 1.1.1.1
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 12.12.12.12   <======== !!!!!
search .


если файл /run/systemd/resolve/resolv.conf не уходит через симлинк в /etc/resolv.conf
то кроме systemd-resolved никакие другие днс клиенты которые не юзают NSS 
незаметят этого изменения. если только у нас в /etc/resolv.conf не указан сам 
же этот systemd-resolved через 127.0.0.53 тогда да. 

вобщем я хочу сказать что вот этот недоделанный resolvconf который ссылается 
как симлинк на resolvectl когда мы его запускаем то пофакту его работа состоит в том
что пофакту в итоге запускается 

    # resolvectl dns .... 

а как эта команда работает  я уже знаю
итак еще раз скажу что вот эат команда

    # echo "nameserver 12.12.12.12 " | resolvconf -a tun0

по факту запускает вот эту команду

    # resolvectl dns tun0 12.12.12.12

описание этого недодалелнного resolvconf можно найти в 

    # man resolvectl 

если промотать вниз до слов
  COMPATIBILITY WITH RESOLVCONF(8)

причем я хочу тут подчеркнуть что слово "компатибилити  с resolvconf" имеет тот смысл
что сравнивается этот недоделанный resolvconf и настоящий полноценный resolvoconf
который ставится из совершенно другого пакета. 
тоесть еще раз systemd-resolved потавляет некую имитация программы программы 
resolvconf. корявую имитацию. она приимает ряд ключей таких же как настоящий resolvconf
так вот в мане написано что эта параша понимает ключ nameserver  и это так. и что
также она понимает ключ search/domain так вот как бы я ни старался она их нихуя 
не понимает

# echo "domain  vasya.com " | resolvconf -a tun0
No DNS servers specified, refusing operation.

# echo "search  vasya.com " | resolvconf -a tun0
No DNS servers specified, refusing operation.

и насколько я понял просматривая файл interfaces  и читая man interfaces что 
в файле interfaces нельзя прописать домен а только адреса днс серверов. 
насолько я понял файл interfaces это на самом деле часть пакета ifupdown 
это написано в man interfaces а этот ман это часть файлов из пакета ifupdown
плюс в пакете ifupdown есть вот такие папки

$ dpkg -L ifupdown
...
/etc/network/interfaces.d

в этот пакет входят бинарники 

  ifup
  ifdown
  ifquery

я ранее говорил что сеть на дебиан12 поднимается через службу networking
так вот в ней как раз идут эти бинарники

ExecStart=/sbin/ifup -a --read-environment
ExecStart=-/bin/sh -c 'if [ -f /run/network/restart-hotplug ]; then /sbin/ifup -a --read-environment --allow=hotplug; fi'


тоесть по факту подьем интерфейсов сетевых в дебиан 12 основано целиком
и полностью на бинарниках ifup\ifdown , а автоматизатором их запуска служит
системд юнит networking. но он чисто автоматизатор. а так получается вся хрень 
по поднятию сеетвых интерфейсов лежит на ifup\ifdown вот на чем держится вся "сеть"
в дебиан12

так вот этот ifup он читает файл interfaces и на основе него "поднимает " сетевые
интерейсы тоесть дает интфрейсу IP, маску, пропиывает роут на основе укаанного 
гейтвея. и еще ifup он запускает скрипты из папки 
    
      /etc/network/if-up.d

там есть скрипт

      /etc/network/if-up.d/resolved

наскоколь я понимаю ifup до запуска этого скрипта он парсит файл interfaces
потом из того что он там начитал он это все преобазует в переменные. 
и он вызывает этот скрипт скрмиливая ему значения переменных. потому что 
в скрипте есть куча переменных. его нет смысла вызывать если этому скрипту 
не скормить знаения переменных.

так вот скрипт 
он проверяет запущен ли на компе сервис systemd-resolved 
и если да то происходит вот что , он берет название сетевой карты  котоую скормили 
скрипту например eth0 и находит для нее ееный индекс через чтение

   /sys/class/net/eth0/ifindex

потом он для этой карты создает файл 

    /run/network/ifupdown-inet-eth0

в этом файле он пропиывает был ли для нее в /etc/network/interfaces укаазаны 
адреса днс серверов и search домены, выглядит это так
в /etc/network/interfaces

iface eth0 inet static
  address ...
  gateway ...
  dns-nameservers 8.8.8.8 8.8.4.4
  dns-search com co.uk ru

так вот ifup это читает и сует в скрипт переменные IFACE=eth0
NEW_DNS="8.8.8.8 8.8.4.4"  NEW_DOMAINS="com co.uk ru"
чтото типа того 

и тогда в /run/network/ifupdown-inet-eth0 будет записано
"DNS"="8.8.8.8 8.8.4.4"
"DOMAINS"="com co.uk ru"

я проверил так и есть. перезапускаем

    # systemctl restart networking

и получаем 
 # cat  /run/network/ifupdown-inet-eth0
"DNS"="8.8.8.8 8.8.4.4"
"DOMAINS"="com co.uk ru"



четсно говорят нахрена вообще эта папка /run/network нужна незнаю  кроме как
для отчетности чтобы показать что ifup успешно прочитаь конфиг карты eth0 из 
файла interfaces и обработал его.типа как бы этот файло говорит : эй! смотри
я успешно пропарсил файл interfaces! я вычленил из него такой то днс IP
и такой то домен!
далее происходит в этом скрипте вот что. он берет и читает тот файл
который созал в /run/network/ifupdown-inet-eth0
и получается скрипт в себя всасывет переенные

DNS="8.8.8.8 8.8.4.4"
DOMAINS="com co.uk ru"


и если пеерменная $DNS непустая  то он пишет в файл  /run/systemd/resolve/netif/2
(где 2 это индекс сет картчоки eth0) вот такой контент

LLMNR=yes
MDNS=no
SERVERS=$(echo $DNS6 $DNS)
DOMAINS=$(echo $DOMAINS6 $DOMAINS)


тоесть если в interfaces мы зададим только ключ

    dns-search com co.uk ru
который потом породит переенную DOMAINS то файл  /run/systemd/resolve/netif/2
создаваться не будет. 
а вот если в interafaces задан ключ

  dns-nameservers 8.8.8.8 8.8.4.4

который потом передет в переенную DNS то тогда будет создан файл /run/systemd/resolve/netif/2
и в него будет записан и DNS и DOMAINS

# cat 2 
# This is private data. Do not parse.
LLMNR=yes
MDNS=no
SERVERS=8.8.8.8
DOMAINS=com co.uk ru


ксати в этом скрипте баг ошибка.
вот так было 
...
"$DNS"="$NEW_DNS"
...
"$DOMAINS"="$NEW_DOMAINS"



а вот так надо
...
$DNS="$NEW_DNS"
...
$DOMAINS="$NEW_DOMAINS"

иначе он нихуя неработает как надо . об этом и вот тут написано (https://unix.stackexchange.com/questions/714901/dns-broken-when-using-ifupdown-and-systemd-resolved-after-upgrade-to-ubuntu-22-0)


причем мы видим что скрипт пишет в ту папку systemd-resolved  в которую systemd-resolved
пишет пер-интерфейс измененния. обычно это делается через запуск resolvctl
так вот скрипт пишет туда тупо через echo > ... 
а потом в скрипте они пишут мол както нехоророшо получается что мы взяли и вот так
руками туда записали файл, давайте ка мы теперь как положено сделаем тоже самое
но через вызов resolvectl !! охренеет!

                resolvectl llmnr "$ifindex" yes || resolvectl_failed=$?
                resolvectl mdns  "$ifindex" no || resolvectl_failed=$?
                resolvectl domain "$ifindex" $DOMAINS6 $DOMAINS || resolvectl_failed=$?
                resolvectl dns "$ifindex" $DNS6 $DNS || resolvectl_failed=$?

тогда спраиывается нахрена было до этого писать в папку /run/systemd/resolve/netif/2
руками?? а потом делать как положено через вызов resolvectl

вобщем в итоге как это ратаеь. мы имеем файл interfaces. так мы указываем 
ключи для днс и для search доменов.
потом запускаем службу networking.service  она запускает ifup
он парсит interfaces и запускат скрипт resolved
а этот скрипт в конце концов запускает resolvectl с параметрами. 
таким макамрром у нас systemd-resolved получает per-interface параметры 
про  днс !!

еще в чем наебка - пакет ifupdown внутри него есть вот такие маны

# dpkg -L ifupdown | grep gz | grep man
/usr/share/man/man5/interfaces.5.gz
/usr/share/man/man8/ifup.8.gz
/usr/share/man/man8/ifdown.8.gz
/usr/share/man/man8/ifquery.8.gz

так вот ни водном из этих манов нерасписано по человечески все те ключи
которые можно юзать в interfaces тоесть я ни водном из манов ненашел ключи

    dns-nameservers 
    dns-search com 

единсвтенное где я это нашел это вот тут (https://unix.stackexchange.com/questions/128439/good-detailed-explanation-of-etc-network-interfaces-syntax) 
это пипец. что есть пакет. есть конф файлы.  а в манах от этого пакета нихрена
нет инфо! мне что код исходный читать чтоли

кстати вот еще какая наебка. в файле interfaces есть вот такая запись

# cat interfaces
allow-hotplug enp0s3
   ...
   ...
  # dns-* options are implemented by the resolvconf package, if installed
  dns-nameservers 8.8.8.8
  dns-search com co.uk ru

я имею ввиду вот эту строчку
    # dns-* options are implemented by the resolvconf package, if installed

она оказывается полная брехня. полнейшая. потому что получается по факту что
вот эти две настройки из interfaces

  dns-nameservers 8.8.8.8
  dns-search com co.uk ru


они попадают в systemd-resolved нихуя не через пакет resolvconf!
они туда попадают через сервис networking который запускает ifup который входит в пакет ifupdown который запускает свой баш скрипт resolved внутри которого запускается команда
resolvectl которая является частью пакета systemd-resolved !!!!!! охренет! 
в этой цепочке нету нихрнена никакого участия пакета или команды resolvconf
вот в чем их огромнйшая брехня!


( небольшая заметка в сторону - на хостиенге достаточно хитрая сеть. там нетплан. в нем настройки а он уже 
влияет на systemd-networkd ппц прчием я непонял как нетплан влияет на systemd-network
то ли нет план создает конфиги для systemd-networkd то ли он конфинуетрует 
на лету systemd-networkd без составления егоных конфигов)


также хочу уопнямть что помиме сервисе networking есть еще сервис
ifup@enp3s0 он тоже участвует в "поднятии " сети


ВОБЩЕМ - как бы я ни старался - я задищеблил сервис networking и серрвис
ifup@enp0s3 = все равно после перезагрузки интерфейс enp0s3 имел IP адрес!
это немиыслимо! единственное как мне удалось сделать так чтобы интерфейс наконец 
то остался незаконфигурироывнным это УДАЛИТЬ пакет ifupdown !!!
только после этого наконц то мне удалось "остановить" сеть на дебиан12.



теперь берем конфиг от старого менеджера сети ifupdown 
потому что нам надо его воспросизвести в новом менеджере сети
# cat /etc/network/interfaces

source /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

allow-hotplug enp0s3
iface enp0s3 inet static
  address 172.16.10.11/24
  gateway 172.16.10.1
  # dns-* options are implemented by the resolvconf package, if installed
  dns-nameservers 8.8.8.8


итак я смогу освободиться от влияния ifupdown менеджера сети только удалив его
пакет. возможно если бы я очистил /etc/network/interfaces то я добился бы того же .
незнаю.

ксатти 
  $ cat /proc/sys/kernel/hostname 
    lenovo


и теперь надо тоже самое законфигурировать через systemd-networkd


на этом месте я начал писать файл "local-address.txt" , читай его. 

далее. если прочитал то продолжаю тему.

еще раз убедился что после того как установил пакет
  systemd-resolved

нужно проверить что есть запись в nsswitch


что правльная ссылка на stub файл

что в resolved указан 8.8.8.8 

запустить resolvectl



пример interfaces файла
source /etc/network/interfaces.d/*

auto lo
iface lo inet loopback

allow-hotplug enp0s3
iface enp0s3 inet static
  address 172.16.10.11/24
  gateway 172.16.10.1
  dns-nameservers 8.8.8.8
        dns-search com co.uk ru



пример пер-интерфейс задавания насроек для sr через resolvectl

resolvectl domain  br0 nyc3.example.com
resolvectl dns   br0  172.16.10.11
resolvectl dnsovertls br0 off
resolvectl dnssec  br0 off



далее
прикольная мысль - вот ты слазил в dns чрез tls 
и значит никто пока незнает куда ты соираешься лазить.
а потом ты уже лезеш туда через бразуер и https и то куда ты лезешь ввысвчеено в SNI 
который не криптуется. гоча. и вся секретность в жопе.

поэтому и надо весь трафик совать в впн. там уже никто ничего не уивдиьт

у меня вопрос нахер нужен этот SNI. вот у меня есть веб серер процесс на порту 443.
тоесть это 

    IP= 12.12.12.12 TCP 443

и на этом сокете сидит веб сервер. 
вот я с одного компа клиента стучу на этот сервер на сайт www1.ru 
у нас используется tls шифрование. которое выполняет юзер код этого сервера 
поутем подключения библиотеки. значит от клиента втекает шифрованный трафик. 
его процесс веб сервера декриптует. получает на выходе HTTP трафик. там четко 
написано что host: www1.ru  , все веб серверу процессу четко понятно куда ломился
клиент. 
потом другой клиент ломиться на этот же сокет этого же веб сервера но на сайт www2.ru
в этом нет проблемы. у нас просто теперь в этот сокет влетает два шифрованных потока
но каждй пакет этого потока имеет уникальное сочетание src_ip src_port 
и сервер дешифрвет этот поток через tls в юзер спейсе то есть он сам это декриптует
при этом он понимает что это другой поток от другого клиента. и получает другой http 
поток где указан ксатти другой host: www2.ru  
поэтому я непонимаю нахуй нужен SNI.



далее
такой прикол если за сеть отвечает на компе не systemd-networkd.service а NetworkManager
то он по дефолту меняет /etc/resolv.conf
во первых он сам это пишет

# cat /etc/resolv.conf
# Generated by NetworkManager    <======== !!!!!!!!
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.47.179


во вторых об этом написано в 

  $ man 5 NetworkManager.conf




а ведь у нас на компе уже есть система которая отвечает за настройки  в resolv.conf это
systemd-resolved !!!!! и это в общем то пиздец. 
потому что systemd-resolved она создает файл 

    /run/systemd/resolve/stub-resolv.conf

# cat stub-resolv.conf  | grep -v '#'

nameserver 127.0.0.53
options edns0 trust-ad
search .

 
и также тогда systemd-resolved создает симлинк на этот файл 

  # ln -s   /run/systemd/resolve/stub-resolv.conf   /etc/resolv.conf


но тут влезает наш ебаный NetworkManager стирает этот симлинк и создает resolv.conf
с нуля вот такого вида

# cat /etc/resolv.conf
# Generated by NetworkManager 
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.47.179


при этом имена днс севрером он берет вот тут 

# cat  /etc/NetworkManager/system-connections/iphone.nmconnection 

[ipv4]
dns=8.8.8.8;8.8.4.4;  <=======
method=auto



и тогда получется что наш локальный systemd-resolved просто оказвыаттся отключен 
от процесса резолвинга. потому что он висит на 127.0.0.1:53 
а в нашем resolv.conf висят совершенно другие днс серерра!

nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.47.179

это пиздец.

единственное что sustemd-resolved все таки принимает участие в резолвинге в этой
ситуации если приложение для резолвиноа использует NSS подсистему у глибц. 
и в nsswitch.conf в секции hosts: (у nss секция называется база) прописан nss
плагин resolve который напралввяет прилетевлшие на него запросы в systemd-resolved

        hosts: resolve files myhostname dns


получается когда настраиываешь systemd-resolved через /etc/systemd/resolved.conf
то нужно еще ОБЯЗАТЕЛЬНО ПРОВЕРИТЬ куда у нас ведет /etc/resolve.conf сука!!!

в итоге как я сделал. 
я в настройках NetworkManager указал чтобы он сука resolv.conf нетрогал
через настройку


        # cat /etc/NetworkManager/NetworkManager.conf 
            [main]
            dns = none
            rc-manager = unmanaged

и сделал симлинк резолв конфа сооздаваемый systemd-resolved 

        # ln -s /run/systemd/resolve/stub-resolv.conf  /etc/resolv.conf



ксати еще один пиздец это то что файл назвыется /etc/resolv.conf
а не /etc/resolve.conf  



далее про вот эту строку

# resolvectl
Global
           Protocols: -LLMNR -mDNS +DNSOverTLS DNSSEC=yes/supported
    resolv.conf mode: stub      <==============  !!!!!
  Current DNS Server: 1.1.1.1
         DNS Servers: 1.1.1.1
Fallback DNS Servers: 8.8.4.4


я выделилил строку

  resolv.conf mode: stub


так вот эта строка покзвыает и намекает на то как был создан /etc/resolv.conf
если указано stub это значит что /etc/resolv.conf создан путем того что это симлинк
на файл /run/systemd/resolve/stub-resolv.conf

остальные варианты создания resolv.conf они это зовут "режим работы" 
systemd-resolved с  resolv.conf, по мне термина полная хуйня расписны в 
  man systemd-resolved
ищем со слов "Four modes of handling"

значит четыре режима работы


это "stub" режим работы
 •   systemd-resolved maintains the /run/systemd/resolve/stub-resolv.conf file for compatibility with traditional Linux programs. This file lists the
           127.0.0.53 DNS stub (see above) as the only DNS server. It also contains a list of search domains that are in use by systemd-resolved. The list of
           search domains is always kept up-to-date. Note that /run/systemd/resolve/stub-resolv.conf should not be used directly by applications, but only
           through a symlink from /etc/resolv.conf. This file may be symlinked from /etc/resolv.conf in order to connect all local clients that bypass local
           DNS APIs to systemd-resolved with correct search domains settings. This mode of 
           operation is recommended.


это "static" режим работы
 •   A static file /usr/lib/systemd/resolv.conf is provided that lists the 127.0.0.53 DNS stub (see above) as only DNS server. This file may be
           symlinked from /etc/resolv.conf in order to connect all local clients that bypass local DNS APIs to systemd-resolved. This file does not contain
           any search domains.

       •   systemd-resolved maintains the /run/systemd/resolve/resolv.conf file for compatibility with traditional Linux programs. This file may be symlinked
           from /etc/resolv.conf and is always kept up-to-date, containing information about all known DNS servers. Note the file format's limitations: it
           does not know a concept of per-interface DNS servers and hence only contains system-wide DNS server definitions. Note that
           /run/systemd/resolve/resolv.conf should not be used directly by applications, but only through a symlink from /etc/resolv.conf. If this mode of
           operation is used local clients that bypass any local DNS API will also bypass systemd-resolved and will talk directly to the known DNS servers.

       •   Alternatively, /etc/resolv.conf may be managed by other packages, in which case systemd-resolved will read it for DNS configuration data. In this
           mode of operation systemd-resolved is consumer rather than provider of this configuration file.

       Note that the selected mode of operation for this file is detected fully automatically, depending on whether /etc/resolv.conf is a symlink to
       /run/systemd/resolve/resolv.conf or lists 127.0.0.53 as DNS server.



далее в манах написано что в resolved.conf 
можно вставит днс сервер не в виде ip адреса а в таком виде

      172.16.10.11:53%br0#nyc3.example.com

на самом деел нихуя. макимум можно вставить вот так

    172.16.10.11:53#nyc3.example.com

и вот этот домен как я понимаю это именно днс имя этого днс сервера.
и я не понимаю  а какой нам толк от днс имени днс сервера?

далее
гугул днс сервер адрес ipv6  DNS=2001:4860:4860::8888

далее я вот какую полезную опцию узнал 

    DNSStubListenerExtra=172.16.10.1

что он дает. по дефолту sr слушает днс реквесты чеерез 127.0.0.53 
а если мне надо чтобы он принимал реквесты еще через другой ip адрес.
например. у меня есть бридж интерфейс br0 он имеет адрес 172.16.10.1
за ним сидят вируалки. скажем с адресами 172.16.10.11
и я хочу чтобы днс клиент виртуалки не на 8.8.8.8 обращался а на этот же sr
на моем хосте компе. потому что он же кэширует реквесты. зачем мне два раза 
кэшироваьт одни и теже реквесты - на хосте компа и внутри виртуалки. но с 
виртулки никак не достучаться до 127.0.0.53 хоста компа. зато можно достуаться
до IP бриджа. поэтмоу мне надо чтобы sr слушал реквесты дополнительно на 172.16.10.11
вот для этого и есть настройка 

    DNSStubListenerExtra=172.16.10.1

только чтобы она заработала непоможет просто попросить перечитать конфиг 
у демона sr. он почемуто не умеет открывать сетевой новый сокет через 
   
     # kill -HUP $(pidof systemd-resolved)

его обязательно сука надо перегрузить
     # systemct restart systemd-resolved

тога он помимо 127.0.0.53 начнет слушать 172.16.10.1 
и я могу на виртулках прописать что днс сервер это 172.16.10.1 
а это прикольно как удобноу!!!


вот пример. у меня на компе стоит named и сидит на сокете 172.16.10.11
и он обсллуживает домен\зону nyc3.example.com
я вот так запрограммировал 

вот так sr его глобальную секцию

# cat global.conf 

[Resolve]

MulticastDNS=no
LLMNR=no

DNS=172.16.10.1


Domains=~.

DNSSEC=no


а вот так через systemd-networkd я запрограммировал  интерфейс секцию

k# cat 50-static.network 
[Match]
Name=enp0s3

[Network]
Gateway=172.16.10.1
DNS=172.16.10.11
Domains=nyc3.example.com
LLMNR=false
MulticastDNS=false

[Address]
Address=172.16.10.11/24
Label=vasya
#Scope=link



в итоге имею

k# resolvectl 
Global
         Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 172.16.10.1
        DNS Servers 172.16.10.1
         DNS Domain ~.

Link 2 (enp0s3)
    Current Scopes: DNS
         Protocols: +DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 172.16.10.11
       DNS Servers: 172.16.10.11
        DNS Domain: nyc3.example.com

тоесть все домены у меня буудт обслуживаться вот этим сервером 172.16.10.1
а домен  nyc3.example.com будет обслуживаться 172.16.10.11 


и мы делаем реквест 

   # resolvectl -4 query   ns1.nyc3.example.com 



IP 172.16.10.11.56722 > 172.16.10.11.53: 12232+ [1au] A? ns1.nyc3.example.com. (49)
IP 172.16.10.11.53 > 172.16.10.11.56722: 12232*- 1/0/1 A 172.16.10.11 (65)

тоесть видно что домен ns1.nyc3.example.com  резволвится через 172.16.10.11
который указан в секции интерфейса
все как запрограммировано



далее  такой момент. как уже стало понятно у systemd-resolved (sr) неимеет
в конфиге настроек для секции интерфейсов. и это можно сделать через конфиг другого
сервиса systemd-networkd.
так вот у sr есть опция DefaultRoute. и чтобы ее настроить через systemd-networkd
то это делается вот так

# cat 50-static.network 
[Match]
Name=enp0s3

[Network]
Gateway=172.16.10.1
DNS=
DNSDefaultRoute=False  <============ !!!!!
Domains=
LLMNR=False
MulticastDNS=False

[Address]
Address=172.16.10.12/24
label=vasya

интересно было бы все это уметь настраивать через NeteworkManager, птому что на 
компе у меня стоит именно он . и он автоматом как и systemd-networkd пушит
свои настройки в sr. 



<><><><><><><><><><><><><><><><><><><><><><><><><>
значит я щас занимаюсь несколькими вопросами

разобартсья с route-only доменами
разобраться со скоупами
разбоарться с mdns настройкой
разобраться с link-local ip адресами и роутами
как запреить NEtworkManager пихать свои данные в sr
systemd-networkd похоу автоматом пихает свои данные через resolvectl в sr


что такое DefaultRoute?

воопрос - как нетворк менеджер просоывает свою конфиуррацию внутрь sr? 
я думаю он взывает resolvectl. я думаю он так действтует

debian networkd там вбить dns посмреть влияние на resolved
попрбовть в дебиан подключить LLNR или mDNS



значит я щас занимаюсь вопросом о том что дает тильда в названии домена в опции
Domains.
также у меня вопрос если у меня прописан dns сервер в секции от такойто карточки
сетевой что это реально значит? ведь отправка пакета на этот днс пойдет через
ту карточку которая подходит согласно таблице маршрутизации а не дурацкой записи в 
sr.
также у меня взник вопрос что значит строка Scope в resolvectl

  Link 2 (enp0s3)
  Current Scopes: LLMNR/IPv4 LLMNR/IPv6   <======
       Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
      DNS Domain: DOMAINS

насколько я сам понял (доки хуйня) в скоупе может стоят три хрени LLMNRS, mDNS, DNS
где mDNS это мультикастDNS а DNS это UnicastDNS тот самый нас привычный
вот я взял все активировал
    resolvectl dns tun0 172.16.17.1
    resolvectl mdns tun0 on
    resolvectl llmnr tun0 on
    resolvectl domain tun0 vasya.com
    resolvectl default-route tun0 true
    resolvectl dnssec tun0 true
    resolvectl dnsovertls tun0 true
    resolvectl nta tun0 bbc.co.uk

и у меня получилось

  $ resolvectl status 

Link 3 (tun0)
    Current Scopes: DNS LLMNR/IPv4 LLMNR/IPv6 mDNS/IPv4 mDNS/IPv6   <=========  !!!!!
       Protocols: +DefaultRoute +LLMNR +mDNS +DNSOverTLS DNSSEC=yes/supported
    Current DNS Server: 172.16.17.1
       DNS Servers: 172.16.17.1
        DNS Domain: vasya.com


вот видно что секция tun0 содержит в себе СКОУПЫ  DNS, mDNS, LLMNR
тоесть это не один скоуп у секции а их несколко скоупов 

    Current Scopes: DNS LLMNR/IPv4 LLMNR/IPv6 mDNS/IPv4 mDNS/IPv6

тоесть сеекция всебе содержит не один скоуп в котором много всего
а она содержит много скоупов в кототором одна хрень сидит
вобщето кадждый скоуп по своей сути это протокол. тогда зачем делать отдельную строку
Protocols. и почему тогда эти две строки не совпадают? хотя наверно я доагадываюсь.
в строке протоколы указаны все протоколы активированные но эти проотоколы можно 
сгруппировать в три кучки - протооколы связанныые с UnicastDNS - это DNSOverTLS и DNSSEC
проткол связанный с LLMNR это LLMNR, и протокол связнный  с mDNS это mDNS
тоесть походу скоуп показывают группу протоколов активированную на интерфейсе.
то есть скоуп это не протокол это группа проткоолов. поэтому эти две строки не 
совпдаают. как актвивизиоровать скоуп? вот так

для активации DNS скоупа
    resolvectl dns tun0 172.16.17.1
для активиации mDNS скоупа
    resolvectl mdns tun0 on
для активации LLMNR скоупа
    resolvectl llmnr tun0 on

теперь вопрос а что это дает на практкие?

вот эта секция 

   Current DNS Server: 172.16.17.1
       DNS Servers: 172.16.17.1
        DNS Domain: vasya.com

она относится к настройке DNS скоупа


<><><><><><><><><><><><><><><><><><><><><><><><><><>

| RESOLVCONF
| DNSMASQ
| IFUPDOWN


тут я хотел расказать про эти три программы. 
на самом деле главная задача разобраться как работает resolvconf.
сразу скажу что есть как классический resolvoconf который появился в дебиане
я именно его поставил. а есть например openresolv это уже другая раелиазация внутри
а снаружи якобы такие же ключи. но чтоб понять как она работтает нужно еще 
копаться в ifupdown и в dnsmasq

значит у resolvconf две задачи. первая задача это отвечать за контент файла /etc/resolv.conf
как это происходит , если человек из командной строки или программа  вызывает resolveconf с ключами и делает запрос к resolvconf на удаление днс сервера либо его добавление то он
делает себе пометки внутри скажем так своих конф файлов о том что вот такой то днс
сервер типа нужно добавить, потом он может  модифицировать  /etc/resolv.conf но может 
решить его не модифицировать. а вторая его задача после того как в него поступил реквест
на удаление или добавление днс сервера состоит в том что  
он (как я понимаю) обращается ко всем программмам с котрым он может 
работать и так или иначе их уведомляет или модифицирует их файлы чтобы в конечном итоге
эти программы узнали о том реквесте который к нему направили. тут важно подсветить 
то что в конечном итоге resolvocnf может несмодифицировать файл /etc/resolv.conf
тоесть не добавить новый днс серевер, но зато он его добавит в конфиги всех тех программ
с которыми он умеет работать. 

демон у resolvconf есть но он просто однакратно стартует и останаливется. его задача
на основе внутрнней базы создать актуальный /etc/resolv.conf (erc) и также пробежаться
по всем ему знакомым прогам и им подкрутить мозги. а потом он останавливется

тоесть 

щас на пратике буду обьяснять. 
есть нетворк менеджер ifupdown у него консольные утилиты которые запускаются
чеерз systemd unit networking, так вот утилита ifup из этого пакета которая поднимает все сетевые интерфейсы   она же читает файл /etc/network/interfaces в котором есть 
вот такая строка
    
    dns-nameservers 8.8.8.8 1.1.1.1

и имея это она  также запускает скрипт 

      /etc/network/if-up.d/000resolvconf 

а в этом скрипте идет запуск resolvoconf которрму передаются как параметры 8.8.8.8 1.1.1.1
и в итоге эти два днс сервера попадают внутрь resolvconf а он их уже сует в файл 
/etc/resolv.conf , если пакета resolvocnf нет в системе то /etc/resolv.conf 
при старте ifupdown непроизойдет. такиим образом получаетя делая настройки в конфиге 
ifupdown пакета и старте сервиса networking он запускает resolvconf , передает ему
прописанные днс сервера 1.1.1.1 и 8.8.8.8 а он их сует уже в erc файл. 
это как бы первый этап когда сетевой менеджер через resolvoconf влияет на erc
далее происходит второй важный этап , когда resolvconf полученные изменеия снаружи пихает
в другие программы. у resolvconf есть папка со скриптами 

        /etc/resolvconf/update.d

там например есть файл dnsmasq
так вот на втором этапе resolvonf запускает в частности этот скрипт , а скррипт делает
вот что он сканирует внутреннюю базу resolvconf( далее rc) она находится в 

    /run/resolv.conf/interface

и\или 

    /etc/resolvconf/resolv.conf.d

и он берет оттуда днс сервера и пихает их  в файл 

    /run/dnsmasq/resolv.conf 

причем важно понять что составил файла erc и файла /run/dnsmasq/resolv.conf  могут
оказаться в итоге разными. причем создание\модификация файла  /run/dnsmasq/resolv.conf
идет в незавсиимости запущен щас демон dnsmasq или остановлен. 
а dnsmasq он стартует вот как его systemd юнит запускает скрипт

      /etc/init.d/dnsmasq

этот скрипт он запускает днсмаск так чтобы демон при старте прочитал не erc файл 
а файл /run/dnsmasq/resolv.conf , возожмно так происходит только при наличии пакета 
resolvconf  на компе иначе ведь понятно что нужно читать erc файл. в итоге
днсмаск вот так запущенный процесс выглядит

/usr/sbin/dnsmasq -x /run/dnsmasq/dnsmasq.pid -u dnsmasq -r /run/dnsmasq/resolv.conf -7 /etc/dnsmasq.d,.dpkg-dist,.dpkg-old,.dpkg-new --local-service --trust-anchor=.,20326,8,2,e06d44b80b8f1d39a95c0b0d7c65d08458e880409bbc683457104237c7f8ec8d

и вот этот параметр  -r /run/dnsmasq/resolv.conf который говорит откуда читать адреса 
внашних днс серверов. потому что в мане днсмаск написано что он точно не итеративный что
он только может передать реквест другому рекурсивному серверу и получиить ответ и все. 
что еще интерсно отметить что скрипт который старутет днсмаск  /etc/init.d/dnsmasq 
он при старте также запусакает rc и говорит ему мол добавь днс сервер 127.0.0.1 
на котором будет вещать сам днс маск. тогда rc добалявяляет этот днс в свою базу
модиифицирует erc и еще раз модииицирует /run/dnsmasq/resolv.conf в итоге из erc
исчезают все днс севрера кроме 127.0.0.1 но зато они все остаются в файле /run/dnsmasq/resolv.conf и также они остаются во внутрнейнней базе dnsmasq. понятно что rc он 
не будет доабваволять 127.0.0.1  в файл /run/dnsmasq/resolv.conf потому что получится
что днсмакс в качестве апстрим сервера обратится сам к себе. уберет либо 
не уберет из erc наш rc все днс сервера при добавлении 127.0.0.1 зависит от того что 
в файле 

      # cat /etc/default/resolvconf 
TRUNCATE_NAMESERVER_LIST_AFTER_LOOPBACK_ADDRESS=yes

если тут стоит yes то при добавлении в rc днс 127.0.0.1 он вырежет из erc 
все остальные днс сервера. 

также нужно вот еще что пояснить. у rc есть спец файл 

      # cat /etc/resolvconf/interface-order 
lo.inet6
lo.inet
lo.@(dnsmasq|pdnsd)
lo.!(pdns|pdns-recursor)
lo
tun*
...
...

он о чем?  дело вот в чем. когда мы через rc добавляем ip днс сервера внешнего то 
rc оценивает через какую сет карту придется к этому днс обращаться. и вот в этом файле
указан список интерфейсов. внутри себя внутри своей базы данных (котрая лежит в /run/resolvconf/interfaces) rc хранит списочек днс серверов в виде 

      ip адрес - интрфейс компа. 

ну точнее чуть по дргому. файл имеет имя сет карты.а внутри днс сервера до которых 
можно достучаться через этот интфрейс например

# cat /run/resolvconf/interface/enp0s3.inet 
nameserver 172.16.10.1
nameserver 1.1.1.1

# cat /run/resolvconf/interface/lo.dnsmasq 
nameserver 127.0.0.1


а далее вот что происходит. он смотрит какие файлы(с названиями интерфейсов) у него  в 
базе есть. и выбирает самый верхний интерфейс согласно файлу /etc/resolvconf/interface-order 
в данном случае это lo.dnsmasq и он пихает днс сервер который прописан внутри эого 
файла в erc, солль в том что во внутрнейеей базе данных может быть дохрена указано 
днс серверов но в итоге в erc файл будет записано только 3 штуки. это будут 3 штуки
которые лежали в самых верхних интерфейсах. насколько я понимаю чем выше интерфейс 
тем rc считает что днс сидящий за ним до него связь будет быстрее и ближе. и это логично
потому что днс сидящий за lo интерфейсом реально сидит близко , потому что на самом 
компе значиит его днс адрес нужно пихать в erc файл в первюу очередь. следущим 
в списке интфрейсов идем tun интерфейс. кхмм... хотя он по факту в плане сети сидит
далеко зато это получается днс сервер из "локальной " сети. возможно на этом 
основана приоритезация в файле 

      # cat /etc/resolvconf/interface-order 

такмим образом с одной стороны разные программы при старте могут пихать в rc новые
днс сервера и другие параметры которые обычно мы прописывали раньше сами руками в erc
файл. а rc потом сам меняет erс файл а также лазиит в разные программы и там меняет 
у них днс сконфиг. 

в мане сказано что rc поддерживает ткакие прогарммы как

   glibc resolver (nss dns)
   dnsmaq
   ifupdonw
   NetworkManager
   dhclient
   pppd

заметим что в списке нет systemd-resolved
поддерживает это значит что он умеет в них лазить и менять их днс настройки на лету.
и они тоже могут иметь скрипты котоыре при старте этих сервисов пушат днс когфиг в rc

так как же он раотает в случае если несклько программ шллют ему свои разные данные. 
одни шлют одни днс сервера, вторые шлют другие. во первых я замечу что все что ему
шлют это erc конфиг его параметры. тоесть там нет никаких пер-интерфейс насртроек. 
просто каждоая прога присылает ему свой вариант erc файла. он это все сохраняет в своей
внутрнейрней базе (папка /run/resolveconf/...) а в базе оно сохраняется в интересном
виде. каждый днс сврер который ему снаружи присыалают - он анализирует через какую сет
карту он до него может достучаться. и он запиывывает IP в файл с названием карту.
таким орахом в одном файле у него могут быть днс сверера присланыне от разных программ. 
а потом он идет в файл ранжирования сетевых карт  /etc/resolvconf/interface-order  
выбирает оттуда первую карту которая сверху и смотррт есть у него в базе такой файл.
если да то он берет оттуда днс срвера и пишет их в erc. если их меньше 3 , то он берет
следущую крату из списка в файле /etc/resolvconf/interface-order  ищет ее у себя 
в базе и оттуда днс срвера доавляет в erc. и так пока их нестанет 3 штуки.
вот скажем пример базы

# cat /run/resolvconf/interface/enp0s3.inet 
nameserver 172.16.10.1
nameserver 1.1.1.1

# cat /run/resolvconf/interface/lo.dnsmasq 
nameserver 127.0.0.1

он смотртит в файл interface-order и видит что первый интерфейс это lo..
тогда он берет файл lo.dnsmasq читает его и сует 

nameserver 127.0.0.1

в erc

после этого смотрит что остался файл enp0s3.inet и оттуда берет 

nameserver 172.16.10.1
nameserver 1.1.1.1

и сует в erc. 
хотя конкнетно в случае когда у нас в erc оказался днс из lo* файла 
если установлена переменная 

# cat /etc/default/resolvconf 
TRUNCATE_NAMESERVER_LIST_AFTER_LOOPBACK_ADDRESS=yes

то он после обрабоки lo* файла остановится

таикми образом если куча программ напихала в rc кучу днс серверов в erc окажется 
1-3 серервера согласно ранжирования на осноове файла    /etc/resolvconf/interface-order
в итоге результатом рабоы rc явлется то что он составить конекретный вид erc файла.
а формат erc файла не прдразумевает пер-интерфейс настроек. так то если что. это 
просто коловой файл. и какойто аналог erc файла будет на втором шаге просунуть 
в программы 


   glibc resolver (nss dns)
   dnsmaq
   ifupdonw
   NetworkManager
   dhclient
   pppd

на примере днсмаск кокнеретно будет сделано то что будет модифициован файл 
/run/dnsmsq/resolv.conf и я проверил если днсмаск процесс работает то он сразу заме
чает изменнеие в этом файле. тоесть демоне ненужно переагуружаь он сразу замечает.

неочень понятно а как старутет днсмаск если на компе нет rc программы. типа нам надо 
вставить в erc руками строку 127.0.0.1 а прежние днс сервера оставить а он стартует 
и читает erc файл и 127.00.0.1 игнориует и читает тольк остальные днс свреерра? незнаю.

на счет работы руками 
  как посмотреть текущую внутреннюю базу

# resolvconf -l
вывод на экран

# resolv.conf from lo.dnsmasq
nameserver 127.0.0.1

# resolv.conf from enp0s3.inet
nameserver 172.16.10.1
nameserver 1.1.1.1


как перегенеировать erc и все проги тоже туда постучать и там все обвновить
 
 # resolveconf -u

как добавит днс сервер руками

    # echo "nameserver 2.2.2.2" | resolvconf -a enp0s3

под enp0s3 мы указываем что 2.2.2.2 сидит за этой картой

получаем

# resolvconf -l
вывод
# resolv.conf from lo.dnsmasq
nameserver 127.0.0.1

# resolv.conf from enp0s3.inet
nameserver 172.16.10.1
nameserver 1.1.1.1

# resolv.conf from enp0s3
nameserver 2.2.2.2

этиже файлы лежат тут
# ls -1 /run/resolvconf/interface/
enp0s3
enp0s3.inet
lo.dnsmasq

вид erc

# cat /etc/resolv.conf 
nameserver 127.0.0.1


тут только однин днс сервер потому что 
# cat /etc/default/resolvconf 
TRUNCATE_NAMESERVER_LIST_AFTER_LOOPBACK_ADDRESS=yes


однако resolv.conf для днсмаск уже выглдяит вот так
# cat /run/dnsmasq/resolv.conf 
nameserver 172.16.10.1
nameserver 1.1.1.1
nameserver 2.2.2.2  <===========

тоест как только мы добавили руками 2.2.2.2 то rc его добавил в "кишки " днс маск

кстти днсмаск он умеет делать пер-интерфейс днс роутинг

  # grep -v '#' /etc/dnsmasq.conf 
    domain-needed
    server=/nyc3.example.com/172.16.10.11


в отличие от systemd-resolved наш днсмаск через rc невсосывает пер-интерфейс
днс сервер 172.16.10.11 в erc файл. по мне это приавльно. 

вот как рабоатет rc. как он кокнретно что делает.

приколкно что днсмаск он в отичие от systemd-resolved не имеет nss плагина. и схема
работает так  в nsswitch указан nss dns плагин

 hosts:  file dns

в /etc/resolv.conf через rc пропсиано 

nameserver 127.0.0.53

и все.

получается nss приложение через nss dns плагин прочитает erc и попадет на днсмаск
а если приложение не NSS то оно тоже прочитает erc и попадет на днсмаск
плюс nss плагине resolv в том что он связывается с со своим серрвером через лоаклаьный сокет   а nss dns плагин как  я понимаю свзывается с срвером днс маск уже через сетевой
сокет а это другие наклдывнывае расходы. более высокие. 

как я понял днсмаск градо более навроченная штука чем sr и описан лучше а  sr 
он проше а описан хуево. 
как я понял если у нас sr испольуетя то нужно удалять rc. а если днсмаск исползуется
то тогда rc очень даже в кассу!

как я понял glibc resolver это группа Си функций 
тоесть это неодна функция а группа , кучка.   (man 3 resolver , если этго мана нет
в линуксе то он есть в интернете https://man7.org/linux/man-pages/man3/resolver.3.html)

его конфниг с директивами это erc.  опции и диркеивы внутри erc это 

  $ man resolv.conf



далее
вот эта штука

# strace -e connect getent ahostsv4 mail.ru
connect(3, {sa_family=AF_UNIX, sun_path="/run/systemd/resolve/io.systemd.Resolve"}, 42) = 0

при конфиге 
# cat /etc/nsswitch.conf  |  grep hosts
hosts:          files myhostname mdns4_minimal [NOTFOUND=return] resolve

она покзывает то что nss resolve плагин связывается с systemd-resolved через 
сокет /run/systemd/resolve/io.systemd.Resolve

а вот эта штука
# strace -e connect  resolvectl -4 query  mail.ru
connect(3, {sa_family=AF_UNIX, sun_path="/run/dbus/system_bus_socket"}, 30) = 0

показывает что resolvectl свзяется с systemd-resolved чеерез d-bus

пизнаком того что прога юзает NSS это то что она октрвыает файл nsswitch,conf

# strace -e openat getent ahostsv4 mail.ru 2>&1 | grep nssw
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 3

# strace -e openat  resolvectl -4 query  mail.ru  2>&1 | grep nssw
 пусто

значит getent использует NSS а resolvectl не использует NSS !


есть dnsmasq и он сходу выглядит горазло более лучше чем sr потому что у ненадо
мудить чтобы задать домен и днс сервер через который его резолвить. но оказыается 
днсмаск имеет огромаднейший минус - он умеет рабоать с dnnssec но не умеет работать
с dns over tls. и чтобы этого добиться то нужно ставит еше прогу stubby. 
тогда связка такая - запрос идет на днсмаск нешифрованный. он обращается к stubby
а он уже умеет dns over tls. по мне это пиздец. что sr имеет сеьрезнешие недоработки
и днсмаск имеет серьезнейшую недорработку. это просто пиздец.
я остаюсь пока на sr.

далее
dig - как его заставить его работать в итеративном режиме (когда он сам
все ищет начиная с рут днс серверов) это флаг +trace 

    $ dig -4 +trace  mail.ru


далее. 
как работает resolvconf я разобрался. либо в этом файле.
либо в link-local.txt файле




нерешенные вопросы:

> далее я не рассмотрел опцию -DefaultRoute в sr нет времени

> старт openvpn конект не через systemd unit а через NetworkManager


> как венсти изменения в конфиг чтобы не вбивать руками каждый раз
    # resolvectl domain  br0 nyc3.example.com
    # resolvectl dns   br0  172.16.10.11
    # resolvectl dnsovertls br0 off
    # resolvectl dnssec  br0 off
    # resolvectl  domain  br0 nyc3.example.com  dns   br0  172.16.10.11  dnsovertls br0 off dnssec  br0 off


 > вопрос обычно днс клиент на линуксе он такой что он сам ничего искать не хочет
он делает запрос к рекурсивному днс серверу и ждет готтовый ответ от него. таким
макаром наш днс клиент зависит от этого ркурсивного сверере который про нас собирает
логи. возникает вопрос а какой днс клиент можно поставиь на свой комп чтобы этот 
днс клиент делал сам все итеративные запросы. и чтот на вскидку не вижу ответа

> netplan он гененриирует конфиги для systemd-networkd или он налету через сокет в демона
  передает задание?
  


полезные ссылки:


DNS, dig etc
https://www.adityathebe.com/systemd-resolved-dns-over-tls/
https://datatracker.ietf.org/doc/html/rfc6891
https://www.gabriel.urdhr.fr/2020/04/20/linux-host-name-resolution/
https://ldpreload.com/blog/testing-glibc-nsswitch
 https://www.cloudflare.com/learning/dns/dns-server-types/#:~:text=All%20DNS%20servers%20fall%20into,TLD%20nameservers%2C%20and%20authoritative%20nameservers.
 https://serverfault.com/questions/729025/what-are-all-the-flags-in-a-dig-response
 https://www.ietf.org/rfc/rfc1035.txt
 https://www.ietf.org/rfc/rfc1035.txt
 https://www.ietf.org/rfc/rfc4035.txt
 https://datatracker.ietf.org/doc/html/rfc4033
 https://datatracker.ietf.org/doc/html/rfc1034#section-5.3.1
 https://datatracker.ietf.org/doc/html/rfc2929
 https://www.ietf.org/rfc/rfc4035.txt
 https://stackoverflow.com/questions/70735787/what-is-the-ad-flag-in-a-dns-query
 https://datatracker.ietf.org/doc/html/rfc6840#page-10
 rfc1034
 rfc4033
 https://datatracker.ietf.org/doc/html/rfc6840#section-5.7
 https://www.ietf.org/rfc/rfc4035.txt
 https://www.cloudflare.com/learning/dns/dns-records/dnskey-ds-records/
https://people.redhat.com/pladd/HVOpen-resolved.pdf
https://wiki.archlinux.org/title/Domain_name_resolution#Glibc_resolver
https://www.gabriel.urdhr.fr/2015/02/14/recursive-dns-over-tls-over-tcp-443/
https://zwischenzugs.com/2018/06/08/anatomy-of-a-linux-dns-lookup-part-i/
https://wiki.archlinux.org/title/Domain_name_resolution
https://www.cloudflare.com/learning/dns/dns-records/dns-ns-record/
https://serverfault.com/questions/1150916/what-is-the-difference-between-ns-record-and-soa-record-in-dns-entry
https://serverfault.com/questions/688837/how-do-registrars-register-authoritative-name-servers-with-root-name-servers/689852#689852
https://superuser.com/questions/1193930/where-is-authoritative-ns-record-for-a-domain-stored-and-how-can-you-change-it
https://www.baeldung.com/cs/dns-authoritative-server-ip
https://www.cloudflare.com/learning/dns/dns-server-types/#authoritative-nameserver
https://stackoverflow.com/questions/22440582/difference-between-a-dns-zone-and-dns-domain
https://en.wikipedia.org/wiki/List_of_DNS_record_types#DS
https://metebalci.com/blog/a-minimum-complete-tutorial-of-dnssec/
https://metebalci.com/blog/a-short-practical-tutorial-of-dig-dns-and-dnssec/
https://serverfault.com/questions/1060543/dns-forwarder-vs-dns-resolver
https://discourse.pi-hole.net/t/can-dig-show-recursive-vs-forwarding-nameserver/59510
https://blog.apnic.net/2018/08/20/dnssec-and-dns-over-tls/



DNSSEC
https://en.wikipedia.org/wiki/Extension_Mechanisms_for_DNS
https://serverfault.com/questions/729025/what-are-all-the-flags-in-a-dig-response
https://dnsinstitute.com/documentation/dnssec-guide/ch03s02.html#using-dig-to-verify
https://textbook.cs161.org/network/dnssec.html#:~:text=The%20key%20signing%20key%20(KSK,(endorsed%20by%20the%20parent).
https://www.google.com/search?q=rrsig+type+13&oq=rrsig+type+13&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIKCAEQABgPGBYYHjIICAIQABgWGB4yCggDEAAYCBgNGB4yDQgEEAAYhgMYgAQYigUyDQgFEAAYhgMYgAQYigUyDQgGEAAYhgMYgAQYigXSAQg0NTc1ajBqN6gCALACAA&sourceid=chrome&ie=UTF-8
https://datatracker.ietf.org/doc/html/rfc4034#page-16
https://www.cloudflare.com/learning/dns/dns-records/dnskey-ds-records/
https://datatracker.ietf.org/doc/html/rfc4034#page-15
https://data.iana.org/root-anchors/root-anchors.xml
https://manpages.debian.org/experimental/systemd/dnssec-trust-anchors.d.5.en.html
https://www.freedesktop.org/software/systemd/man/latest/dnssec-trust-anchors.d.html
https://datatracker.ietf.org/doc/html/rfc7958#page-9
https://www.iana.org/dnssec/files
https://www.iana.org/dnssec/files
https://www.cloudflare.com/learning/dns/dns-records/dnskey-ds-records/
https://security.stackexchange.com/questions/111454/how-to-acquire-dnssec-root-trust-anchor-from-iana
https://gist.github.com/sandeeprenjith/5d85aa0cf418cc1eb999bb10097c1a03
https://www.digitalocean.com/community/tutorials/how-to-setup-dnssec-on-an-authoritative-bind-dns-server-2
https://www.ietf.org/rfc/rfc4034.txt
https://www.cyberciti.biz/faq/unix-linux-test-and-validate-dnssec-using-dig-command-line/
https://security.stackexchange.com/questions/200897/why-use-dns-over-tls-https-if-isp-could-find-out-target-domain-by-other-means
https://weberblog.net/dive-into-delv-dnssec-validation/
https://bugs.gentoo.org/836341
https://superuser.com/questions/1493634/is-dnssec-that-commonly-broken-or-is-systemd-resolved-overzealous
https://github.com/systemd/systemd/issues/25676
https://github.com/systemd/systemd/issues/18821
https://www.cloudflare.com/dns/dnssec/how-dnssec-works/
https://metebalci.com/blog/a-short-practical-tutorial-of-dig-dns-and-dnssec/
https://medium.com/iocscan/how-dnssec-works-9c652257be0
https://www.akamai.com/blog/trends/dnssec-how-it-works-key-considerations
https://serverfault.com/questions/1143090/understanding-rrsig-dns-query
https://www.cyberciti.biz/faq/unix-linux-test-and-validate-dnssec-using-dig-command-line/
https://www.cloudflare.com/dns/dnssec/how-dnssec-works/
https://github.com/systemd/systemd/issues/25676
https://serverfault.com/questions/1074377/is-dnssec-useful



NSS
https://developers.redhat.com/blog/2018/11/26/etc-nsswitch-conf-non-complexity
https://gist.githubusercontent.com/jirihnidek/bf7a2363e480491da72301b228b35d5d/raw/e9f7c43ad32ae490755129be463490db30854e1f/getaddrinfo_example.c
https://habr.com/ru/articles/352300/
https://man7.org/linux/man-pages/man3/gethostbyname.3.html
https://man7.org/linux/man-pages/man1/getent.1.html
https://man7.org/linux/man-pages/man5/nsswitch.conf.5.html
https://nelsonslog.wordpress.com/2016/10/29/ubuntu-name-lookup-dns-vs-nss/
https://man.archlinux.org/man/nss-resolve.8.en
https://unix.stackexchange.com/questions/596434/what-is-the-difference-between-resolvconf-systemd-resolve-and-avahi/783799#783799


SYSTEMD-RESOLVED, SYSTEMD-NETWORKD:
https://www.gabriel.urdhr.fr/2020/03/17/systemd-revolved-dns-configuration-for-vpn/
https://www.linuxinsider.com/story/be-it-resolved-systemd-shall-serve-dns-177275.html
https://www.linuxinsider.com/story/crafting-advanced-dns-configurations-on-linux-177298.html
https://askubuntu.com/questions/1378168/systemd-resolve-not-apply-settings-based-on-network-interface
https://wiki.archlinux.org/title/Systemd-resolved
вот тут написано нерправильно они не поняли как натраивать systemd-resolved = https://gist.github.com/brasey/fa2277a6d7242cdf4e4b7c720d42b567 они не всекли
фищки настроки systemd-resolved
https://superuser.com/questions/1322045/how-to-persist-systemd-resolve-configuration-for-a-particular-network-interfac
https://unix.stackexchange.com/questions/442598/how-to-configure-systemd-resolved-and-systemd-networkd-to-use-local-dns-server-f/783645#783645   = в этом вопросе указано как сделать когда унас появляется новая 
сетевая карточка созданная openvpn а за опенвпн сидит свой днс сервер со своим 
доменом. соовевтенно нам надо чтобы когда тнель поднялся и карта появилась чтобы
у нас автоматом добавлялся резолвинг через тот днс сервер для того домена. у
меня пока так руки и не дошли опробоваьт это решение. даже его прочитать
https://superuser.com/questions/1687861/domain-based-routing-with-systemd-resolved/1856070#1856070
https://unix.stackexchange.com/questions/404917/what-are-link-scopes-in-systemd-resolved/783639#783639
https://unix.stackexchange.com/questions/754132/how-to-get-systemd-to-not-override-dns-settings-for-a-network-interface/783712#783712
https://www.gabriel.urdhr.fr/2020/03/17/systemd-revolved-dns-configuration-for-vpn/
https://habr.com/ru/articles/547830/
https://blogs.gnome.org/mcatanzaro/2020/12/17/understanding-systemd-resolved-split-dns-and-vpn-configuration/
https://news.ycombinator.com/item?id=19436613
https://wiki.archlinux.org/title/Systemd-resolved
https://github.com/systemd/systemd/issues/2683
https://superuser.com/questions/1586471/linux-mint-20-systemd-networkd-is-ignoring-dhclient-conf-by-not-calling-dhclie#:~:text=systemd%2Dnetworkd%20has%20never%20used,in%20the%20%5Bmain%5D%20section.
https://unix.stackexchange.com/questions/548830/whats-the-difference-between-run-systemd-resolve-stub-resolv-conf-and-run-sys/783931#783931
https://unix.stackexchange.com/questions/431870/clarifying-four-modes-of-handling-etc-resolv-conf-in-systemd-resolved/783832#783832



BIND
https://www.digitalocean.com/community/tutorials/how-to-configure-bind-as-a-private-network-dns-server-on-ubuntu-14-04


DNSMASK
https://www.tecmint.com/setup-a-dns-dhcp-server-using-dnsmasq-on-centos-rhel/
