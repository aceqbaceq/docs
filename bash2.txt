| bash
| export
| var
| execve


если мы создали переменную
	$ A=1
а потом запустили новый процесс даже пусть это будет баш
	$ bash
то  в новом процессе не будет этой переменной. тоесть баш при своем клонировании
новую переменную  недопускает до ее экспортрования дальше.
именно для этого и нужен builtin export,
он говорит башу что эту переенную НУЖНО экспортировать.

поэтому если мы хотим чтобы переменная A в баше при запуске другой
програмы та программа получила эту переменную то надо делать вот так
	$ export A=1
гоча!

когда мы в баше запускаем новый бинарник пусть даже сам новый bash
то он как делает он делает fork() тоесть созддает дочерний процесс. 
при fork() у нас в чайлд процессе вся память ровно такаяже как и у парента.
поэтому там есть все. и в том числе и наща переменная A
но далее баш выполянет execve() а вот при его выполеннии уже ядро подчищает память
я точно пока еще не смотрел что именно он подчищает но переенные окружения
они совершенно точно незря передаются в этой функции в третьем аргументе

 int execve(const char *pathname, char *const argv[],
                  char *const envp[]);

и вот тут уже момент истинны. как я понимаю баш при вызывае этой фукнции туда насует
только теперпенные коорые имеют свойствао "export"
больше инфо о execve ищи по "| execve"

