| ssh 
| bash
| alias

основная цель я хочу через ssh запустить алиас на удаленом
компе 
по деолту это не рабоатет опшел нахуй.

поехали:

алиас пропсиывется в .bashrc


если идем запускаем клиент ssh то как я понял демон sshd на удаленном компе
он прежде всего запускает bash процесс! и ему передает ту команду которую мы 
сказаили ему выполинть. наеример

$ ssh thinkpad ls 

он удаленный комп sshd запустит bash с некоторымм ключами в которых указано
чтобы баш уже запустил ls. 
в итоге баш небуедт себя форкать а сразу вместо себя запустить execve.
как я это узнал? я создал файл на компе 

$ cat ~/.bash_profile 
if [ -f ~/.bashrc ]; then
  source ~/.bashrc
fi

он заставляет баш при запуске прочтать .bashrc

далее в .bashrc я убрал проверку егоную насчет того если баш запущен в неинтерактивной
сессии

$ cat ~/.bashrc 
...
...
#case $- in
#    *i*) ;;
#      *) return;;
#esac

ксати а что это за ебанутая перменная $_
цитуую

	$_
	Special variable set to final argument of previous command executed.

я понял что он значит. он равен (внимание) последнему аргументы предыдущей выполеннной
в баше команды. тоесть у нас запущен баш мы в нем сидим мы в нем суем команды с аргументами.
и баш у себ каждый раз модицифрует эту перменную записывая в нее какой был прседний аргумент
последней комды которую мы в этом баше вызывали. 
примеры

 $ echo 123 456 789 1>/dev/null ; echo $_
789

тость баш запонил себе 789 так как это посдений аргумент последнй команлы которую мы 
запоустили в этом баше

возникает вопрос а чему эта хрень равна когда мы толко заустили новый бащ процесс

$ bash -c "echo $_"
PS1

вовзращаюсь к кодув вверху


#case $- in
#    *i*) ;;
#      *) return;;
#esac


он проверяет что послдедний аргумент в последней команде запущенной в этом баш процессе
содержит в себе букву i
таким макаром он опредляет что баш запушен в интерактивном режиме
ну так  я всераво непонял. я поместил в самом верху .bashrc команду
	echo "$_"
заходу на комп
	$ ssh thinkpad
он мне печаатате на экране
	]

тоесть я вобще непонимаю как тогда пройти эту проверку даже елси баш старатнут в 
инетрактивном режиме.

крче говрря я этот кусок из .bashrc закблокировал.

так вот я вврху .bashrc разместил коанду

	$ echo "privet is bashrc!"

далее я запускаю

 $ ssh thinkpad  /bin/ls
]
 hello from .bashrc!


эта мне говоит о том что не сморетя на то мчто /bin/ls это бинарник котоырый
к баш не имет никого отггшения но демон sshd он все таким запускает то что мы ему
указали но все таки через баш посредника

вот еще пример 

 $ ssh thinkpad  /bin/sleep 150
]
 hello from .bashrc!

а вот дерево процесов на том удаленном компе
$ pstree -AspT 1759006
systemd(1)---sshd(893)---sshd(1758878)---sshd(1758983)---sleep(1759006)

тоест баша мы невидим. но он конечно был как раз внутри процесса 1759006
просто он нестал форкаться  а выполнил execve в  саммом себе и в целом это имет смысла.
зачем бащу форкаться если обычно он это даелает чтобы управлеие вернулось терминала к
нему после того как чайлд закончи. а так как у нас неинеративная сессия то башу ненужно
с нами взаимосдейтсвтовать кодга sleep выйдет.
другое дело что я непонмиаю нахрена sshd запускает sleep через баш когда мыожно 
было это сделать сразу и напрямую ????? непоянтно.

но в любом случае я еще не сказал то что на самом деле у нас если мы запускаем
	$ ssh thinkpad ls
то у нас хотя баш процесс и будет запушен но он не будет даже старатся 
прочиать .bashrc а чтбы он его начл читать надо создать файл

$ cat ~/.bash_profile 
if [ -f ~/.bashrc ]; then
  source ~/.bashrc
fi

вот в чем еще прикол.
тоеть в итоге какая схема - неважно какую комнаду мы запускаем через ssh
в любом случае sshd запустить баш процесс и ему передаст в кавестве парамтра 
ту комнду которую мы просиим его выоплнить. баш процесс по деофолту нечитает .bashrc 
в таком режиме. и чтобы он это начал делать надо созаоть фаайл

$ cat ~/.bash_profile 
if [ -f ~/.bashrc ]; then
  source ~/.bashrc
fi

но этого мало надо зайти в .bashrc
и заблокировать вот этот блок

#case $- in
#    *i*) ;;
#      *) return;;
#esac



ответ (как застсвить баш считывать .bashrc при заупуске через ssh )я нашел вот тут 
	https://stackoverflow.com/questions/820517/bashrc-at-ssh-login/78525394#78525394


после тго как я все это сделал то все равно просто так нерабооате.
а рабтает толко вот так

$ ssh -t  thinkpad bash -i  -c gitpull

если убрать хотябы один ключ то пошел нахуй

вот эти ключи нашел тут 
	https://askubuntu.com/questions/810098/why-doesnt-my-alias-work-over-ssh

но фишка в том что с этмии ключами оказалось что и ненадо чтобы .basrhrc 
зставлять работьт через ssh. тоест так как ключ -i заставляет баш чтать файл
.bashrc без манипуляции с файлами

тоест в итоге убрал чьение .bashrc через ssh и просто заюзал команду

	$ ssh -t  thinkpad bash -i  -c gitpull

и нахрен

вобщем загащка. что за хуйня. непонятно почему работает только так.
разбораться
