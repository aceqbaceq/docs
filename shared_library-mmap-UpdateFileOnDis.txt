| shared library
| mmap


изначальный вопрос. вот  у нас есть шаред либрари
которая открыта кучей процессов. далее мы заменяем
файл на диске в которой хранится эта шаред либрари.
вопрос - увидят ли процессы изменения в своей 
памяти или нет? тоесть если мы обновим пакет 
который содержит файлы которые являются собой 
шаред либрари то как это отразится на рабоающих 
в данный момент на компе процессах которые имеют
загжоуенными в их память контент из файла этой
шаред либрари. 

как  у нас работает маппинг файла в память.
у нас процесс фрмально обращается к куску памяти
далее у цпу происходит пейж фолт и ос читает из файла
кусок и кладет в этот адрес памяти. тоесть процес
обращается по адресу к памяти. а там волшебным образом
окзвыается кусок данных из файла.

мой первый вопрос - если я открывал файл, замапил
его в память. прочитал половину файла через мапинг,
потом я заменяю контент файла на диске. далее
я читаю из процесса далее замапленную память со 
второй половины то что я увижу? ответ - я увижу
второую полвину обновленного файла. ну это логично.
а вот вопрос - если потом я повторно лезу в память
с самого начала то какой контент я там увижу? 
увижу ли я там контент старого файла или нового? 
я думал что я там увижу контет старого файла. ведь
мы же его ранее прочитали. ненужно лазить на диск.
нет пейж фолта. НО! почемуто окаалось что это будет
нетак. при чтении из мапленной памяти сначала я
увижу контент ообновленного файла.

вот пример  400.c

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <string.h>

#define SIZE 1024*1024*1024

int main() {
    // Открываем /dev/zero
    int fd = open("/dev/zero", O_RDWR);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // Маппируем его в память с флагом MAP_SHARED
    void *p = mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (p == MAP_FAILED) {
        perror("mmap");
        close(fd);
        exit(EXIT_FAILURE);
    }

    // Клонируем процесс
    pid_t pid = fork();
    
    if (pid == 0) {
        // Дочерний процесс
        printf("Child process: Before memset, first byte: 0x%02x\n", *(unsigned char*)p);
        memset(p, 0x10, SIZE); // Записываем 0x10 в первый байт
        printf("Child process: After memset, first byte: 0x%02x\n", *(unsigned char*)p);
        sleep(120);
        close(fd);
        exit(EXIT_SUCCESS);
    } else {
        // Родительский процесс
        sleep(3);  // Ждем, чтобы дочерний процесс успел записать
     volatile unsigned char *volatile_ptr = (volatile unsigned char *)p;
        for (size_t i = 0; i < SIZE; i++) {
            volatile_ptr[i]; // Чтение данных для их активации
        }
        sleep(120);
        close(fd);
    }

    return 0;
}




я запускаю  и скармливаю файл с контентом 

 aaabbb

он мне выдаст 50% файла тоесть

 aaa

длаее паузка 15с.
в это время я меняю контет файла на 

cccddd

прога читает память дальше и я увижу

ddd

далее я читаю память сначала и до конца
и я увижу

cccddd

а я ведь ожидал 

aaaddd

получается как только контент файл на диске
меняется 

и наша прога обращается к замапленной памяти то
неважно что там лежало до этого - ядро нам возвратит
обновленное содержимо файла. тоесть после обновления
файла на диске наш процесс мгновенно увидит это
обновление

также есть 401.c
он читает файл целиком. 
потом пауза 15с.
потом заново чтение файла целиком.

получается странная вещь. ладно когда у нас
замаплен просто файл  с данными но когда у нас
замапен шаред либрари тоесть файл в котором 
есть код на исполение то получается же жопа. 
потому что когда динамический линковщик пдклчает
такой файл он же в коде делает вставки на адреса
функций в памяти. если же у нас файл попменялся
то по тем адресам уже могут лежать просто рандонмые
куски кода. и все наши процессы которые юзают
эту либрари при обращении - просто в итоге будут
делать какуюто херню. 

как зашитть память процесса чтобы имзеения в файле
никак не отражались на памяти процесса если он уже
данный файл считал - хрен знает. 

флаг MAP_PRIVATE


mmap(NULL, SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);


он влияет на то чтобы если процесс чтото измнеить 
в памяти чтобы эти изменнения не были записаны
ядром в файл на диске. тоесть он защишает файл
от влияния со стороны процесса.
а нам надо наоброт защиттить процесс от влияния
изменнеия данных в файле на диске.


вот такая интересная тема
