| local-address
| local 
| global
| host
| multicast
| mDNS

огроманая часть этой порятнки посвящена mDNS 


все началось с того что увидел в свойтвах сет карты а точнее  в свойствах
IP адреса стоит свойство global
и я всопнмил эту эпопею про global , link-local, host свойства в свойствах 
сетевой карты. что эта за хрень?

во первых это не свойство сетевой карты это свойства IP адреса. это его 
характеристика.

в строону - что такое unicast адрес - это значит что этот адрес обозначает
ОДИН хост, (или один сетевой интерфейс). как следствие если ктото пошлет
кусок информации НА этот юникаст адрес - то получаетелем будет ОДИН комп.
в конрраст мультикаст адрес или броадкаст адрес - его имеет сразу много компов. 
тоесть куча компов и все юмеют этот один и тот же адрес. и если ктото пошлет
на этот адрес то информация прилетит на ОГРОМНУЮ ТУЧУ АДРЕСОВ. например 
сеть 172.16.10.10\24 у нее бродакаст адрес это 172.16.10.255 как бы незримо
каждый комп этой сети имеет в добавок к своему юникаст адресу еще и этот броадкаст
адрес. поэтому если ктото шлет пакет на 172.16.10.255 то этот пакет получат 
все участники сети. потому каждый из них имеет этот адрес. 
итак что такое юникаст адрес стало пболее понятно.

как работает  передача пакета в котором dst_ip=юникаст адрес. 

ipv4      = 4 байта =  8 hex букв = aa:bb:cc:dd
mac адрес = 6 байт  = 12 hex букв = aa:bb:cc:dd:ee:ff

легко увидеть вот что. ровно сколько байт в хрени ровно столько секций 
разделенных символом ":", в ipv4 у нас 4 байта и 4 секции. в мак адресе 6 байт
и 6 секций.

и тут тоже хитрый момент - при передаче пакета в локальной эзернет сети у нас
участвует и IP и MAC адрес. я бы даже сказал что ip адрес почти что не участвует.
а участвует тольк MAC адрес. тоесть это двух слойная система. а изначально дело вот
в чем. у нас есть инфомрация она такова что предназначена для отдельного компа.
назовем ее юникаст информация. а есть инфомрация которая предназначена для сразу кучи
компов. например я хочу вещать радио в локальной сети. в этом радио нет ничего что 
было бы предназнаено конкрентному компу. эта информция такова что она предназначена
сразу для кучу компов. и вот я беру пакет сетевой. в него сую кусок радиопрограммы.
теперь мне надо передать этот пакет сразу на кучу компов. можно пойти по пути
юникаста. это значит что нужно будет на моем компе сгенерировать пакет и отправить
его через сетевую карту в сеть через провод на свич. а свич его переправить первому
получателю. а если в сети 100 получаателей то моему компу нужно будет сгенерировать 
100 одинаковых пакетов по содержимому просто у кжадого пакета будет разный dest_IP
и dest_mac. полуается неклево. надо както так изьебнуться чтобы я со своего компа
послал 1 пакет. и он прилетев на свич был там размножен(отклонирован) и передан 
сразу всем 100 получателям. щас я примерно раскажу как это работает. на саомм деле
система достаточно заморочная. 
как работает отправка и прием юникаст трафика в локальной сети: мой комп А некоторым образом
узнает MAC адрес другого компа Б и также мой комп-А узнает IP-Б адрес того другого компа-Б
тогда мой комп плюет через сет карту в провода пакет в котором стоит
    dst_IP=IP-Б dst_MAC=MAC-Б   ( также у этого пакета есть src_IP=IP-A src_MAC=MAC-A
но это щас неважно)

этот пакет прилетает в свич. свич умеет впакете видеть только MAC адреса. он с ними 
работает. этот как письмо в деревянном ящике. на деервянном ящике написаны MAC адреса.
а внутри ящика лежит письмо на котором написаны IP адреса. свич раотает только с надпи
сями на ящике. так вот что касается свича он когда видит на пакете src_MAC именно
сорс мак то он делает в своей таблице пометку что через такой то порт eth/10 к нему
прилетел MAC-A . тоесть свич теперь знает что за портом eth/10 сидит комп с MAC=MAC-A
это значит что если котот потом пришлет пакет который имеет dst_MAC=MAC-A то свич
сразу знает в какой порт надо плеавть этот пакет.  
так вот прилетел наш пакет. свич смотритв таблицу за каким портом сидит комп
котоырй имеет MAC=dst_MAC=MAC-Б положим свич имеет такой порт. и он направляет этот пакет
в тот порт. если у свича нет в таблице порта с MAC-Б то клонирует пакет и плюет его
во все свои порты. положим так и произошло. 
за каждым портом сидит комп со своей сет картой. каждая сет карта
принимает этот пакет и сравнивает dst_MAC со своим MAC если они не совпадают то карта
(или драйвер сет карты то бишь кусок кода ядра) отбарсывет этот пакет. ибо он недля нее
предназначен. но одна карта этот пакет примет. ровно та карта у которой MAC=MAC-Б
итак пакет влетает в ядро. а там еше теперь идет проверка чтобы dst_IP в пакете был
равен IP-Б компа точнее некомпа а сет карты в который пакет влетел. если он совадает
то ядро продолжает обработку этого пакета. значит в этой юникаст передаче участвовал
юникаст MAC тоесть такой MAC реально есть в сети. им обладает какая то карточка в сети.
и участовал юникаст IP адрес. какойто из компво реаьно имеет этот IP.

теперь про броадкаст передачу. она строится на броадкаст IP и броадкаст MAC.
карточка на компе когда мы его включили уже имеет юникаст MAC адрес. Юникаст MAC 
означает что этот мак адрес в сети по крайней мере в локальной он уникален. он однозначно
идентифицирует именно нашу карточку. этот как паспорт. один пасопорт одно лицо. 

	link/ether 02:42:72:68:0e:62

если котоо в сети пошлет на dst_MAC=02:42:72:68:0e:62 то придет именно на нашу карточку.
хотя как я уже сказал свич может направить во все свои дырки пакет и он прилетит 
на все карточки в сети. но все остальные обязаны отбросить этот пакет ибо они увидят
что dst_MAC не совпадает с ихним. юникаст мак адрес не гарантирует что если мы пошлем
пакет с ним то он прилетит только на одну карточку адресат. но всем "порядочным" карточкам
будет точно понятно что пакет не предназначен для них , он предназначен для той самой
другой карточки и они вобще то обязаны его отбросить. это похоже на конверь с письмом
и адресом. и его размножили и засунули в подьезде в каждый ящик. каджоый порядочный 
человек получив такое письмо четко понимает что оно непредназначено ему и он типа 
его должен отбросить. юникаст мак означает что где то в сети точно есть карточка с таким
маком. и других карточек с таким маком нет. но сменая вещь что при этом пакет с таким
dst_MAC может запросто долететь до карточек не стаикм маком и они могут этот пакет
запросто прочитать (если карту влкючить в промискуус моде), хотя он для них не предна
значен. так вот есть еще броадкаст MAC. он равен ff:ff:ff:ff:ff:ff его не имеет ни одна
карточка в сети формально. но по факту его "как бы " имеет каждая карточка  в сети.
поэтому если я создам пакет с dst_MAC=ff:ff:ff:ff:ff:ff то во первых получив такой
пакет свич переправит  его во все порты. дальше его получит каждая карточка сети. 
и увидев такой dst_MAC они все его примут. потому что такой МАC он как бы обозначает
"это пакет для всех карточек". получаетс удобно - я со своего компа отправил 1 пакет
а в итоге его получили все 200 компов в сети. классс!  возникает вопрос если так 
классно работает передача пакетов в сети на основе MAC адресов и свичей нахрен
на сдалось еще вводить TCP\IP ?  у нас каждый комп в сети имеет свой юникаст MAC адрес.
я могу туда прямо слать. а если надо послать всем то есть броадкаст MAC адрес. 
все классно. адресация есть. свич есть . карты есть. все - передавай данные и отлично.
но тут случается очень неприятный момент - до этого моменты мы гвоорили про сеть
в которой технология передачи данных была одна и таже для всех участников. тоесть
мы все имели одинаковые сет карточки. и передавали данные по однму стадарту
между ними. условно говоря - мы все сидели на эзернет карточках.  я это сравню
вот с чем - я имею ящик на котором адрес написан на французском. и этот ящик
передается между почтами говоряими на французском. ну или говорю - все участники
сети имеют эзернет карточки. это значит что все карточки должны иметь адрес 
подчиняющийся одному закону и пеередача данных между двумя любыими картами
должна идти по одному закону. у нас неможет такоо быть что 5 карт имеют мак адрес
из 6-ти байт а одна карта имеет адрес мак из 7-ми байт. нужна юниформность. чтобы 
карты имели мак адрес подчинайющися одному закону - размер 6 байт. тогда используя
пакет одного размера можно его послать любому участнику. и свич котрый умет обрабатьывать
мак адреса размером 6 байт полученный пакет сможет отправить люому участнику. 
так вот у нас появляется еще одна группа компов и карт на них которые имеют  карты
которые работают по другой технологии. для простоты пусть у них мак адрес сотавляет
7 байт. тогда получается они друг с другом могут общаться  а с нашим сегментом
никак! и тут появвляется устройство сопряжения - роутер. у него часть карточек
пусть даже одна такая же как в нашем сгементе имеет 6 байт. а вторая карточка имеет
7 байт как в том сегменте , тоггда если роутер получит пакет от карты в нашей сети
то он может с него содрать  6-ти байтовый мак адрес. вычленит дата данные из пакета
налепить на пакет 7-ми байтовый адрес и переслать какотому копу в той сети. круто!
получеается 6-ти байтовый мак адрес  он подходит для того чтобы обмениваться
пакетами в нашем сегменте сети. а 7-ми байтовый мак адрес подходит чтобы обмениваться
пакетами в том сегменте сети. тоесть если я хочу переслать пакет от моего компа
другому компу в моем сегменте сети то достаточно использовать мак адрес. когда
карточка получает пакет в котором указан dst_mac и src_mac то мой комп понимает что 
этот пакет был послан от какойто такойже типовой карточки сидящей в моем сегменте сети. 
какая то карточка из моего сегмента сети прислала мне пакет. вот что означает 
пакет с мак адресацией. но если я хочу обмениваться пакетами к компами из той сети 
то можно конено как сделать. я могу както узнать какой 7-ми байтовый мак адрес
у компа из той сети. и составить пакет в котором будет два мак адреса. один это 
6-ти байтовый мак адрес роутера. и внутри 7-ми байтовый мак адрес компа в той сети.
роутер получит. посмотрит. перебьет мак адреса и переправит. но сделали по другому. 
взяли и над этой системой мак адресации сверху добавили новую систему адресации
из 4-ех байт которая одинаковая что для моего сегмента что для того сегмента. 
тоесть я щас сутрирую но скажем такая интерпретация. у меня есть комп и у него есть
сетевая карта. сетевая карта имеет MAC адрес. а комп сидящий на этой карте имеет IP 
адрес. ну и получаетс что сегменты сетей бывают разные. в одной мак адрес может
иметь 6 байт  в другой 7 байт в третьей 10 байт. а вот компы сидящие на этих картах 
имеют одинаковый формат ip адреса 4 байта. тогда получается если я в своем сегменте на 
своем компе хочу послать пакет компу в другом сегемнте то я узнаю его IP адрес. 
адальше делаю вот как я составляют вот такой пакет

       dst_IP=IP-Б  dst_MAC=MAC_g

в этом пакете IP адрес назначения того компа в другом сегменте.  а мак адрес
назначения роутера в моем сегменте.  я плююю пакет в сеть. он улетает на свич.
свич либо знает за каким портом сидит карточка с MAC_g либо он плюет пакет во все
порты. в итоге за каким то портом сидит комп с MAC_g он принимает этот пакет.
остальные компы в нашем сегменте должны отбросить этот пакет. роуте всасывает 
пакет в себя. если свич умеет понимать только мак адреса то роутер умеет понимать
уже и IP адреса. роутер видит что хотя мак адрес был предназначен для роутера
но ip адрес предназначен недля руотера а для друого компа. роутер смотрит в своей 
роуте  таблице маршрутизации что комп с таиким IP адресом сидит за портом номер 2 который
ведет в другой сегмент сети в котором мак адреса имеют 7 байт. роутер сдирает с пакета
оболочку касающуюся мак адресов из исходного сегмента и нахлобучивает на пакет 
мак адреса нового сегмента. он заменяет MAC_g на MAC_f компа в том сегменте


dst_IP=IP-Б  dst_MAC=MAC_f

и плючет этот пакет через свой порт ведущий в тот сегмент.
а если на моем роутере нет инфо про то какой мак адрес имеет комп с dst_IP=IP-Б
то роутер пошлет мой пакет на другой роутер где как считает мой роутер такая 
информация может быть. таким макаром мне на моем компе надо знать только мак адрес
роутера моего сегмента и IP адрес удаленного компа который сидит хрен знает в каком
сегменте. а там уже прыгая с роутера на роутер с сегмента в сегмент пакет както уже 
долетит. это похоже на то что чтобы отправит пистмо мне надо напиать конечный адрес
и знать адрес ближайшей почты и дойти туда и кинуть письмо. а они пусть там 
сами разбиараются каким дорогами самолетами параходами его доставлять какими 
заграницами.

получается ради доставки пакетов между сегментами был доьавлен доп слой адресациии
из 4 байт. IP адресация. я бы сказал просто - доп слой адресации из 4 байт.
кстати 6 байт в мак адресе - это в сет карточках на основе эзернет. в других техно
логиях свои стандарты длинны мак адреса. в стандартах типа point-to-point я не
знаю есть ли там мак адрес или он на уровне одного бита. потому что есть только 
приемщик и передатчик. 

окей. вернемся обратно к компам моего сегмента. внутри моего сегмента нам вроде как
IP адреса нахрен ненужны. мы отлично видим друг друга напрямую через mac адреса
а свич это невидимое средство  содениения моей сет карточки с картой моего
соседа. свич не имеет мак адреса. он типа как провод работает. но пошли по пути
унификации - неважно в нашем сегменте сидит комп на который я стучу или в другом
сегменте - везде будет использовать эти доп 4 байта ip адресации. 
получается если я шлю на комп в моем сегменте то мне надо в пакете указать не
только мак адрес соседа но и его IP. тогда комп который примет мой пакет смотрит
что и мак совпадает с егоным и IP совпадает. получается при предаче инфо в одном
сегмента роутер не участвует. участвует только две карты и свич. и все.
дальше сделали вот что - мы уже имеем броадкаст мак адрес MAC_br=ff:ff:ff:ff:ff:ff который 
дает то что если пакет с 
 
     dst_MAC=MAC_br

попадает в свич то свичу это дает сигнал что такой пакет нужно плюнуть во все свои порты.
это приводит к тому что такой пакет поступает ко всем компам нашего сегмента. и 
компы принимая такаой пакет и видя такой dst_MAC они понимают что данный пакет является
как бы групповым. что он был послан на данный комп не в рамках индивидуальной передачи
а в рамках "групповой" передачи. и они его принимают. тоесть такой мак дает то что свич
его перешлет в каждый порт и таким макаром этот пакет увидит каждый комп сегмента. 
ну и компы полуив такой пакет они понимают что он к ним прилетел не потому что свич не
знал в какой порт плюнуть в рамках когда в свич прилетел пакет с юникаст мак
а он незнал за каким портом сидит карта с таким мак а потому что некий комп хотел 
чтобы этот пакет реально увидел каждый комп в сегменте. вот что дает броадкаст мак.
ну и вот если броадкаст мак это средтство заставит свич доставить этот пакет до каждого
компа в сети а каждый комп помимом мак еще и имеет и IP адрес то наверное логично
при использовании броадккаст мака исипользовать и некий броадкаст IP адрес в этом 
пакете. что еще раз обьяснит компу что прилетевший пакет предназначен для этого компа
но не лично а в рамках "групповой" рассылки.
поэтому если у нас есть сегмент сети то помимо броадкаст мак еще есть и броадкаст IP.
если комп получает пакет с броадкаст мак и броадкаст IP он понимает что пакет 
предназанчен ему но не врамках персноальной адресации а  в рамках групповой рассылки.
также комп понимает что пакет послал какйото комп из этого же сегмента сети а не 
комп из другого сегмента сети. полуается если я хочу слать радио всем участникам моего 
сегмента сети то мне надо составлять такой пакет

   dst_IP=IP-br       dst_MAC=MAC-br

и получается что я шлю один такой пакет но он за счет свича клонируется и прилетает 
на все компы сети. ну круто. круто потому что если бы не было броадкаст мак адреса.
если бы свич не понимал что это такое то мне вместо одного пакета пришлось бы 
генерировать 100 пакетов чтобы каждый комп в моей сети получил один пакет моего радио.
это похоже на то что учитель чтобы обьяснить урок говорит слово и его слышит не весь
класс а то что учителлю нужно подходить к кждому ученику и рассказыать материал 
индиивидуально. тоесть так мы имеем что 30 учеников за один урок учитель материал 
передаст . а так нужно учитлю 30 уроков провестичтобы каждому индивиудулаьно это донести.
тоесть это была бы большая нагрузка на исходный комп.
как выглядит пакет при броадкаст передаче

   dst_IP=IP-br       dst_MAC=MAC-br

мы указываем IP адрес которым ни один комп в сегменте не обладает. или наоборот можно
скзаат что  им обладает кадый комп в сенементе. и мак адрес которым ни одна карта
в сегменте необладает или наорборот что ей обладает каждая карта в сегменте. 
и также пакет имеет

   src_IP=IP-моего компа       src_MAC=MAC-моего компа


так как обратный адрес в пакете указывает юникаст IP и юникаст MAC то все компы
в сети получил такой пакет могут ответить моему компу без проблем. они составят пакет 
вида 

   dst_IP=IP-моего компа       dst_MAC=MAC-моего компа

и мой комп без проблем получит такой пакет. 


теперь вопрос как сделат так чтобы слать мое радио не на все компы моего сегмента сети 
а на некторые но чтобы при этом  мой комп опять же слал всего 1 пакет а он при этом 
волшебным образом клонировался и долетал до кучи компов не не всех. и тут приходит
на помощь мультикаст МАК адрес. есть свичи которое более интеллектуальные и понимают что 
такое мультикаст трафик а есть которые нет. но! даже самый тупой свич для него 
броадкастный мак адрес является броадкастным не вслучае если он 
равен 
   ff:ff:ff:ff:ff:ff

а в случае если у dst_MAC установлен младший бит старшего байта!
тоесть берем самый левый байт у мак адреса

   ff:ff:ff:ff:ff:ff
   /|\
   |||
   |||

и вот самое главное чтобы у него был устанолвен вот этот бит

 00000001

 тоесть вот такой mac адрес с точки зрения любого свича является 
 броадкастным

 xxxxxxx1: xxxxxxxxxxxxxxxxxxxxxxxxx ...

там где x неважно что стоит. важно чтобы стояло 1 там где оно стоит.

так вот с точки зрения любого свича мак адреса делятся на две группы - юникстные
маки и броадкастные. если мак юникастный то свич ищет его в таблице и если находит
то шлет этот пакет тольк в один порт. а если мак адрес броадкастный то он пакет по 
любому шлет во все порты. 
так вот есть еще мультикастные мак адреса. они тоже выглядят как броадкастные тоесть
у них выставлен в 1 вот этот бит. но у них в мак адресе ест и другие хрени. если 
свич тупой и непонимает что такое мультикастный мак то для него такой мак просто
напросто броадкастный. поэтому пакет с dst_MAC=MAC_m(мультикаст) прилетев на такой свич
будет по любому доставлен все компам во всех портах. но если  свич раззбирается в маках
покруче то он поймет что это непросто броадкастный мак а это мультикастный мак
и он доставит этот пакет не во все порты а только в те за которыми сидят компы 
входящие в данную мультикастную группу. я не знаю как но компы могут сигнализировать
свичу о том что они входят в такую то мультикаст группу. я щас к этому вернусь

поэтому все юникаст мак адреса имеют этот бит НЕУСТАНОЛВЕННЫМ а все
броадкаст и мультикаст мак адреса имеют этот бит устанолвенным.

поэтому в мультикаст мак адресе этот бит устанолвен и в худшем случае если между моим
компом и компами моего сегмента стоит простецкий свич которые не понимает что такое
мультикаст - он мой пакет пошлет во все порты как броадкаст.

компы которые получат пакет от меня они уже конечно должны понимать что такое 
мультикаст мак адрес. они должны понимать что это не просто броадкаст мак адрес.
хотя первую часть задачи мы уже решили - мы добились чтобы пакет прорвался через 
свич в худшем случае на все порты. и значит был доставлен до всех компов в сегменте.

также я хочу сказать что мультикаст трафик он как я понял всегда UDP
вчем кстати прикол UDP . если мы с нашего хоста послали такой пакет в сеть то дальше
мы понятия не имеем долетел он или нет. если мы пошлем tcp пакет то оттуда обязателно
прилетит ответ подрверждение. если мы послали udp пакет в ответ нихрена не прилетит. 
и гадай толи долетел толи недолетел. 

тут я опять возвращаюсь к вопросу - как на свиче настроить мультикаст группу 
портов. чтоб получив наш пакет он его переслылал не на все порты а толко на часть
туда куда надо. насколько я понял ( а читать надо гору) что есть доп протокол L3 уровня
IGMP. L3 это значит что в его пакетах уже присутсвтуют не мак адреса а чтото поглубже.
тоесть железка должна в пакете понимать нетолько мак адреса а еще и кое что поглубже.
так вот как я понял есть свичи с поддержкой IGMP. и тогда шарманка примерно выглядит
так - хост со своей карты шлет IGMP пакет в котором указывает как я понимаю к какой
мультикаст группе он хочет присоединиться то бишь как я понимаю хост указывает 
мультикастный IP адрес который будет содеражться в пакете который он хочет получать. 
и тогда свич с поддержкой IGMP получает такую "заявку " от компа и включает у себя 
порт с которого прилеела завявка в группу портов в которую он пересылает мультикаст
пакет с таким то мультикастным IP адресом. также в пакете "заявке" от компа содержится
TTL=1 и это дает то что как я понял этот пакет "заявка" от компа он влетает  в свич
и внутри него же и умирает. тоест никуда дальше она не летит. таким образом другие
компы в сегменте не видят этот пакет. как конкнено выглядят эти IGMP пакеты завяки
я не знаю и думаю выяснять не буду. если же свич не поддерживает IGMP то как я уже
сказал если в свич влетает мультикаст пакет то для него он выглядит как броадкаст
пакет. и он его пиханет во все порты. поэтому чтобы сеть классно работала с мультикастом
нужны свичи с IGMP поддержкой.если такое есть. то комп может поалсть на свич IGMP 
пакет и свич добавиит порт за которым сидит комп в мультикаст  группу тоесть он 
будет и этому компу слать мулььтикаст пакет. а порты с которых не прилетел такой 
запрос свич на них мультикаст пкет не шлет. заявка IGMP она от компа влетает в свич 
только он ее видит. он ее убивает и в другие порты он ее непереслывает. тоесть
эту завявку видит только свич. 

и вот  я только что упомянул такой момент что мультикаст пакет он в себя включает
не только мультикаст мак адрес (о нем щас поговрим) но и мультикаст IP адрес. тоесть 
опятже система построена нетолько на мак адресах но и на IP адресах тоже.
получается что на компе линукс должен сетевой карте назначить мультикаст IP адрес
и какую то службу посадить слушать на этот IP адресе еще и какойто порт (протокол UDP)
получется как я понимаю мультикаст пакет должен иметь :

    мультикаст МАC
    мультиксст IP
    протокол UDP
    порт udp

и на компе должны быть служба которая сидит и слушает протокол UDP, мультикаст IP адрес
и порт udp. напрмер

    systemd-resolved слушает сокет IP=224.0.0.251 UDP:5353  
где 224.0.0.251 это мультикастный адрес. 

и поэтому если в комп прилетит пакет с аткими параметрами то линукс его воспримет.
а если в комп влетит пакет dst_IP=224.0.0.251 UDP:5353 а на компе такой сокет 
никто не слушает то этот мультикаст пакет просто будет проигнорирован. тоесть я хочу
сказать что мультикаст трафик мультикаст пакет в себя включает не только мультикаст
мас адрес, не только мультикаст IP адрес. но еше и UDP порт. и мало доставить такой
пакет от компа отправителя через свич на какйото комп. нужно чтобы на этом компе
какая то служба слушала такой сокет. если на компе нет службы которая сидит и ждет 
этот пакет сидя на сокете то пакет просто буде проигнорирован!

итак мультикаст пакет имеет мултикаст мак адрес. внутри мультикаст IP адрес
внутри протокол UDP +порт

как на примере выглядит такой пакет

dst:
  mac  01:00:5e:00:00:fb
  IP   224.0.0.251
  UDP порт 5353

src: 
  mac  ba:ec:24:5c:80:3a
  ip   172.16.10.12
  UDP порт 5353


значит смотрим на dst mac , у него в первом байте 01 = 0000 0001 мы имеем выставленный младщий
бит. тоесть это точно мас который отноится как минимум к классу броадкаст
dst ip относится к классу мультикаст (об этом классе ип позже скажу)
udp порт 5353. раз udp то такой пакет не требует ответа. хост его получает и в ответ 
может молчать. с таким маком свич этот пакет разошлет либо во все порты либо в
часть портов где поработал IGMP.
при этом у нас src mac это юникаст мак потому что ba = 10111010 видно что младший бит
равен 0. ip тоже юникастовый. и раз в dst стоит udp то и в src стоит udp

зачит как я уже сказа с таким dst mac этот пакет прилетит на все нужные компы. 
если комп разбиаретс что такое мультикаст то он этот пакет примет.  потому что понятно 
что мак 01:00:5e:00:00:fb его не будет имть ни один комп. потому что это мультикаст 
мак а не юникаст мак. но если комп понимает что такое мулитикаст макми то он его примет.
далее dst ip = 224.0.0.251, UDP порт 5353 , если на компе стоит служба которая слушает 
такой сокет то комп этот пакет направит в эту службу иначе он его грохнет. если
комп примет этот пакет то он знает как отправить ответ компу который послал этот пакет
потому что мы знаем юникаст мак и юникаст IP отправителя. проблем нет. мы также 
знаем src порт. единственное что если прогамма на компе отправителя уже закрылась 
то на компе отправителя может не быть службы которая слушает сокет 172.16.10.12 udp порт 5353
данный мульитикаст пакет относится к рассылке вида one-to many поэтому скажем 
обратный пакет будет иметь вид


dst: 
  mac  ba:ec:24:5c:80:3a
  ip   172.16.10.12
  UDP порт 5353

src:
  mac  ba:ec:24:5c:80:3b
  ip   172.16.10.11
  UDP порт 5353

так вот свич в свою таблицу заносит порты и маки которые он берет из src mac пакета
поэтому при пролете пакета туда мультикастовго и ответа юникастового в свиче 
будет вот такая инфо



  mac  ba:ec:24:5c:80:3a   свич порт 01
  mac  ba:ec:24:5c:80:3b   свич порт 02

тоесть  у него в таблице попадут толкко юникастовые маки. при мультикаст рассылке
мултикаст мак всегда стоит в dst части пакета и никогда в src части пакета



немножко отойду в сторону 
но тоже важная вещь.
как проверить что до udp порта реально с другого компа долетает инфо.
на компе который destination (dest) мы запускаем tcpdump


   (dst)     # tcpdump -n 'udp port 5353' -i enp0s3 -e

на компе который source(src) мы запускаем 

   (src)     # nc -zv -u 172.16.10.11 5353
то что будет здесь написано в вывод неважно. потому что внезависимости долетел пакет
или нет. тут всегда написано что все отлично. 
идем на dst комп и смотриим словил ли что tcpdummp



17:50:17.782377 ba:ec:24:5c:80:3a > ba:ec:24:5c:80:3f, ethertype IPv4 (0x0800), length 43: 172.16.10.12.59991 > 172.16.10.11.5353: domain [length 1 < 12] (invalid)

17:50:17.784078 ba:ec:24:5c:80:3a > ba:ec:24:5c:80:3f, ethertype IPv4 (0x0800), length 43: 172.16.10.12.59991 > 172.16.10.11.5353: domain [length 1 < 12] (invalid)

в данном случае словил. значит реально инфо долетает. значит порт udp 5353 реально 
открыт. 

ключ -e в tcpdump он дает то что нам показывают макс. тоест показывают src mac и dst mac
что круто.

по такой технолггии монжно проверить открыт ли UDP порт на удаленном компе 
или долетате ли до него инфо незакрыт ли файрволл. правда для этого нужен доступ
на dst комп

итак при мультикаст рассылке у нас мультикаст мак дает то что при пролете через свич
этот свич его в худшем случае склонирует во все свои порты. а влучшем случае только 
за те порты из которых прилетели igmp заявки и свич понимает igmp. вот что дает мультткиаст
мак для чего он нужен. мультикаст ip дает что что отправитель недолжен знать ip адреса
компов которым он шлет. он ставит один мультикаст ip и пакет долетев до компов 
и когда он в них засосался сообщает своим ip в частности что это мультикаст пакет. то 
есть групповой. поскольку мультикастов может быть много то этот конкрретный мультикаст ip
позволяет компу понять пришел ли нужный мультикаст пакет или это мультикаст пакет 
от другой групповой рассылки. вот что дает мультикаст ip
тость еще раз он позволяет компу отправителю незнать ip клиентво а поставить некий фиктивный
ip. а коммпам получаелям понять что это групповая рассылка и понять эта рассылка которая
им нужна или другая. далее посолльку пакет снаружи выглядит как пакет формата ip
а я как понял пакет формата ip эта всегда тлько транспортная оболочка для какогото 
пакета внутри. тоесть не бывает просто пакета ip и чтобы внутри небыло пакета другого
формата. такого небывает. нельзя отправит просто ip пакет а внутри пусто как я понимаю.
самый привычный пакет это ip а внутри icmp. ICMP лежит внутри IP. icmp ксатти
имеет внутри себя секции 
  -  тип icmp пакета (например тип 0 это эхо реквест а 8 это эхо  реплай) 
  -  код ( непонятно что этот код значит)
  -  контрольная сумма (нам это неинтересно)
  -  последнее поле его контент зависит от типа icmp тоесть от первого поля
     я так понимаю в этом поле кроется самый уже контент полезный

кстати traceroute может работаь как основе UDP так и на основе icmp
если на оснвое icmp то работает это так. 
мы пишем 
        $ traceroute -M icmp -n 8.8.8.8  -q1 -m 2
тогда выстреливается серия ip+icmp пакетов таких что 
у них у всех одинаковый 
     src_IP=ip компа dst_ip=8.8.8.8 
но разный TTL тоест первый пакет будет иметь

     src_IP=ip компа dst_ip=8.8.8.8  TTL=1

второй пакет будет иметь

     src_IP=ip компа dst_ip=8.8.8.8  TTL=2


ключ -m 2 означает какой максимльный TTL будет иметь последний пакет

ключ -q1 означает сколько пакетов с одним и темже TTL надо шмалять. 
в данном случае всего один. 

а далее происходт вот что. берем первый пакет 

     src_IP=ip компа dst_ip=8.8.8.8  TTL=1

он начинает прыгать по компам (по роутерам) , при проходждении каждого роутера этот
роутер у этого пакета уменьшает TTL на 1 и если TTl стал равен 0 то ротуер должен этот
пакет убить. а обратно отправить ip+icmp пакет с icmp типа type 11 (первое поле) "time exceeded" и еще этот роутер должен по идее в этом icmp type 11должен  вставить инфо более
детальную по этому поводу. насколько я понял при TTL=0 абсолютно все роутеры грохают
такой пакет но далеко не все посылают обратно icmp type 11. вообще если пакета TTL стал 0
то это какбы значит что он слишком долго шатался по роутерам но не достиг цели. и поэтому
чтобы он бесконечно не шатался по инету его уничтожают. соовтевтенно когда такой роутер
шлет обратно icmp type 11 он же его вкладывает в IP пакет. а занчит у этого пакета будет
dst_ip и src_ip.  dst_ip будет нашего компа а src_ip будет того рутера который грохнул
наш пакет. таким маккаром запуская пакеты с разным TTL можно узнать по каким рутером
он проходит пока он идет до цели 8.8.8.8
так вот трейсроут запускает целую груду однотипнвых пакетов 

     src_IP=ip компа dst_ip=8.8.8.8  TTL=N

но с разным TTL. и в ответ ждет столько же ответов icmp type 11. потом он в них парсит 
src_ip и нам его рисует. А ЕСЛИ НА КАКОЙТО ПОСЛАННЫЙ ПАКЕТ ОН НЕ ПОЛУЧАЕТ ОТВЕТА ТО 
ОН В ТАБЛИЦЕ В ЭТОМ МЕСТЕ РИСУЕТ "*" . это значит что тут рутер который принял пакет
с этим TTL. он пакет убил а ответ сука не прислал. вот что значит * в таблице traceroute


вот пример

# traceroute -M icmp -n 8.8.8.8  -q1 -m 2
traceroute to 8.8.8.8 (8.8.8.8), 2 hops max, 60 byte packets
 1  172.16.10.1  0.817 ms
 2  172.16.50.1  131.336 ms


вот его tcpdump
вот он заупускает пакет  172.16.10.12 > 8.8.8.8  c TTL=1

 19:27:15.568215 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 1, id 12782, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 1, length 40


вот еще он запускает такой же с TTL=2

19:27:15.568253 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 2, id 12783, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 2, length 40


вот он получает ответ на первый пакет TTL=1
 а именно получает  ICMP тип time exceeded от компа 172.16.10.1

19:27:15.568879 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 64, id 42860, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.10.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12782, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 1, length 40


вот он получает ответ на первый пакет TTL=2
 а именно получает  ICMP тип time exceeded от компа 172.16.50.1


19:27:15.693490 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 63, id 56833, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.50.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12783, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 2, length 40



и вот что нам в итоге выводит traceroute

traceroute to 8.8.8.8 (8.8.8.8), 2 hops max, 60 byte packets
 1  172.16.10.1  0.817 ms
 2  172.16.50.1  131.336 ms


если я запушу с макс TTL=3

# traceroute -M icmp -n 8.8.8.8  -q1 -m 3
traceroute to 8.8.8.8 (8.8.8.8), 3 hops max, 60 byte packets
 1  172.16.10.1  0.891 ms
 2  172.16.50.1  125.450 ms
 3  *

то третий рутер он пакет убил но в ответ нихрена не присла icmp 
поэтому на этом месте traceroute рисует звездочку потому что неизветсен Ip того 
рутера мы от него нихрена не получили

я уже сказал что просто пакета ip небывает. внутри него всегда закапуслирован 
пакет другого протокола. только что мы посыллаи ip пакет внутри которого был icmp 
пакет засунут. в ответ нам присыллали ip+icmp но не потмоу что мы слали icmp 
туда а потому что TTL истекал в 0 на рутерах. 
так вот в трейсроут можно "туда" слать не icmp пакет а например udp пакет. 
вобще я считаю что роли не игарает какой протокол будет всунут внутрь ip пакета туда.
потому что ответ нам приходит исходя из друого. из того что TTL стал равен нулю.
итак трейсроут может туда слать UDP пакеты. вот пример

# traceroute -M udp  -n 8.8.8.8  -q1 -m 3

# tcpdump -n 'udp or icmp ' -i enp0s3 -e -v

вот он шлет три udp пакета на порт 53 с TTL=1,2,3
19:36:33.028858 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 1, id 12414, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.59981 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

19:36:33.028889 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 2, id 12400, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.53647 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

19:36:33.028902 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 3, id 37820, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.57116 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]


в ответ прилетает два пакета icmp "ICMP time exceeded" от 172.16.10.1 и 
172.16.50.1  а на третий пакет с TTL=3 нихрена не прилетает

19:36:33.029117 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 64, id 58490, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.10.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12414, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.59981 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

19:36:33.149972 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 63, id 21170, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.50.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12400, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.53647 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

итак четко видно что похеру каой потокол будет всунуть внутрт ip пакета летящего
туда. когда он приетает на рутер и у него станвоится TTL=3 то рутер убивает пакет
и внезависиомсти какой протокол был нвутри этого пакета он  в ответ шлет icmp type 13
пакет. или вобще нихрена не шлет.

спраивается нахрена тогда эти опции в traceroute - из за файрволла. тоесть либо 
файрвоолл на моем компе может не выпускать наружу скажем icmp (для примера) или на 
том роутере может быть закрыт кайото протокол на файрвоолле. тогда проскочить фарвойллы
помогут опции icmp либо udp . еше tracroute может вкалдывать внутрь ip пакета tcp пакет.
вобщем читай man traceroute

как  я понял ip протокол придумаи для того чтобы доставлят пакеты от одного хоста 
до другого. но хост имеет до хрена сервисов внутри. поэтому доставит до хоста это
значит доставить до ядра того хоста. а после этого надо ответиь себе на вопрос а для 
какого сервиса этого хоста этот пакет теперь доставлять ? вот протколы tcp\udp 
они указывают порт который как бы обозначает для какого сервиса на том хосте предназначен
этот пакет.  как я понял проткол icmp придумали для того чтобы когда рутеры обащются
друг с другом по протоколу ip (хотя я этого не предтавляю ибо голый ip пакет без нихера
внутри не отсылвается) и возникают проблемы то тот роутер в ответ может отпправит типа
полезную диангностиечкую ифномоарцию через icmp пакет. ксати получается что на стороне
отправителя пакет icmp может просит сгенеирировать юзер сервис а на той стороне ответный
icmp пакет шлет ядро компа и никкакйо юзер процесс на той стороне вобще об этом не знает
неучаствует и не вызывается при прилете icmp пакета с нашего компа. тоесть там 
его принимает ядро и само вответ шлет icmp пакет без какого либо участия каких 
либо юзер процессов. 


вбщем я ухщел в сторону. возвращаюсь к мультикаст пакету. хотя он ip снаружи но нужно 
какйто проткол внутрь вложить. и вкладывается UDP протокол. а значит какйото порт.
значит чтобы принять мультикаст пакет на нашем компе должен быть каойто юзер сервис
который сидит и слушает сокет UDP на этом порту на этом IP. итак в отличие от icmp 
трафика который может приять ядро на той стоороне и само ответить чтобы  принять 
мультикаст трафик на той стороне должен быть юзер сервис  который сидит и слушает 
на udp сокете некоторый порт на мультикаст IP адресе котоыйр должен быть повеешен 
на некоторую сетевюу карту.

есть такая организация IANA. и она закрепила что мульиксаст IP адреса могут 
принадлежать только диапазону 224.0.0.0 to 239.255.255.255

как  я уже говорил из того что уже прочитал что якобы при использовании мультикаст IP
адреса надо обязательно юзать UDP протокол, тоесть IP адрес у нас это параметр пакета
IP. но так как внутри IP пакета обязателно должжен быть инкапуслирован какйтто еще 
протокол то сказано что им длжден быть UDP проткол. однак и тут наебка. можно 
заюзать ip+icmp проткол для ip=224.0.0.1  при этом линукс умный он в пакете вставит
dest mac мультикастовый а не юникастовый. потому что нет воможности вставиьть какйото
юникастоый мак адрес. мы же как узнаем юникаовые мак адреса. мы шлем арп пакет на все 
хосты и спрашивает привет скажем мне свой юникаст мак если твой IP=224.0.0.1, 
c одной стороны если комп хочет принимать мультикаст у него будет сет карта с таким
IP но комп понимает что это мультктоый IP и поэтому глупо отвечать юникастовым маком на 
арп запрос. поэтому мы никогда не полуичим ответ от компов в сети и никакой мак
мы неузнаем поэтому линукс вставит в пинг dest_mac мультикастовый. и получается пинг 
пошлет ip(мультикастоый)+icmp+мак мультикастоый  в сеть. и всегда пинг был инстурментов
для юникаст запроса но в этом случае он сработает как мультикаст запрос!  
вобщм короче говоря если шлем в пакете мультикаст IP то и мак доолжен быть мультикастовый.
мы же хотим достчиь целой группы компов а через свич это можно сделать только если ему
подсунуть мулььтикаст мак но никак не юникаст мак. в итоге из сети ответят все
компы у которых данный мультикаст адрес установлен
причем они ответят и в ip пакете ответа вставят свой юникаст IP адрес !!

# ping 224.0.0.1
PING 224.0.0.1 (224.0.0.1) 56(84) bytes of data.
64 bytes from 172.16.10.11: icmp_seq=1 ttl=64 time=1.29 ms

вот в данном сулчае на ответил комп с юникаст адресом 172.16.10.11

как убедиться что на его компе ест ip адрес 224.0.0.1 хоть на какойто сет карте.
        $ ip a sh 
нихуя не покажет
а покажет вот такая команда!

# ip -4 -o maddr show
1:  lo\ inet  224.0.0.1
2:  enp0s3\ inet  224.0.0.251
2:  enp0s3\ inet  224.0.0.1
4:  tun1\   inet  224.0.0.1
8:  tun0\   inet  224.0.0.1



вот мы видим что на карте enp0s3 присвоен ip=224.0.0.1
причем можно убедиться что типа ни один процесс не сидит на этом IP

# lsof -n -P | grep "224.0."
# ss -lpn4 | grep 224

ну хорошо у нас есть карта. и ей присвоен IP. в целом необязательно чтобы кайото
процесс сидел на сокете на этом IP. 

ксатти iptables и tcpdump. какая между ними сввязь. tcpdump показывает трафик который 
если входящий то до обработки iptables а если исходящий то уже после обработки через iptables


еще про мультикст IP адреса на компе можно вот так посмотреть

# netstat -gn
IPv6/IPv4 Group Memberships
Interface       RefCnt Group
--------------- ------ ---------------------
lo              1      224.0.0.1
enp0s3          1      224.0.0.251
enp0s3          1      224.0.0.1
tun1            1      224.0.0.1
tun0            1      224.0.0.1


адлее станно то что я точно знаю что процесс systemd-resolved у меня слущает 
этот мулькаст адрес 224.0.0.251 на UDP сокете порту 5353 но почемуто lsof 
покзывает вот такой сокет

# lsof -n -P -p 265 | grep UDP
IPv4              28880      0t0    UDP *:5353 
IPv6              28881      0t0    UDP *:5353 
 

тоесть он показыает что якобы процесс слушает  UDP 5353 порт не на IP адресе 224.0.0.251
а на всех IP адресах компа.  щас проверю.


на удаленном компе есть IP=172.16.10.11 и я вклчю на sr дебаг лог левел

    (remote) # resolvectl log-level debug


шлю с локального компа запрос на 5353 UDP порт на IP 172.16.10.11 

    (local) # # nc -zv -u  172.16.10.11  5353

смотрю что в логах remote компа

systemd-resolved[265]: Received mdns UDP packet of size 1, ifindex=2, ttl=64, fragsize=0, sender=172.16.10.12, destination=172.16.10.11

systemd-resolved[265]: Invalid mDNS UDP packet.

systemd-resolved[265]: Received mdns UDP packet of size 1, ifindex=2, ttl=64, fragsize=0, sender=172.16.10.12, destination=172.16.10.11

systemd-resolved[265]: Invalid mDNS UDP packet.


получается что да. что sr он слушает 5353 UDp порт нетллько на мультикст IP адресе 224.0.0.251
как это положено но и на всех остальных IP адресах этого компа!!


а вот кстати я понял как nc опреедляет дошел ли UDP пакет до цели. если в ответ не 
прилетел ICMP отлуп значит дошел
вот я зупумпускаю такую команду

    # nc -zv -u  172.16.10.11  5354

и получаю вот вет на мой комп вот такой отлуп

вот мой запрос

ba:ec:24:5c:80:3a > ba:ec:24:5c:80:3f, ethertype IPv4 (0x0800), length 43: (tos 0x0, ttl 64, id 19168, offset 0, flags [DF], proto UDP (17), length 29)
    172.16.10.12.57282 > 172.16.10.11.5354: UDP, length 1

а вот он icmp отлуп с удаленного компа "ICMP 172.16.10.11 udp port 5354 unreachable"

ba:ec:24:5c:80:3f > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 71: (tos 0xc0, ttl 64, id 7055, offset 0, flags [none], proto ICMP (1), length 57)
    172.16.10.11 > 172.16.10.12: ICMP 172.16.10.11 udp port 5354 unreachable, length 37
    (tos 0x0, ttl 64, id 19168, offset 0, flags [DF], proto UDP (17), length 29)
    172.16.10.12.57282 > 172.16.10.11.5354: UDP, length 1

приколно!


а вот  еще на счет пинга на на мулььтикаст адрес
оказыается этот пинг работет не только на IP=224.0.0.1 
но на например IP=224.0.0.251
главное чтобы на удаленном компе был такой ip

# ping 224.0.0.251 -c 3
PING 224.0.0.251 (224.0.0.251) 56(84) bytes of data.
64 bytes from 172.16.10.11: icmp_seq=1 ttl=64 time=1.19 ms
64 bytes from 172.16.10.11: icmp_seq=2 ttl=64 time=1.60 ms
64 bytes from 172.16.10.11: icmp_seq=3 ttl=64 time=1.97 ms

так вот оветный icmp пакет прилетит  с удаленного хоста только если на том уделнном
хосте активирована вот такая хрень

       # echo 0 > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts

иначе ответных пингов не видать как ушей !!

и  я потихоньку добрался вот до какой темы - есть такой протокол mDNS (rfc6762)
от 2013 года. фишка его втом что на компе с этим протоколом поднимаетя демон который 
актирует на компе мультикаст IP=224.0.0.251 и на нем слушает UDP порт 5353
и при старте этого демона он посылвает мультикаст пакет на 224.0.0.251 UDP 5353
он разлетается по всему сегменту сетевому. и в этом пакете этот демон с этого хоста
всем сообщает свой хостнейм в виде 

        хостнейм.local

вот как выглядит этот поток на компе который принял этот млультикаст пакет.
точне серию пакетов. ксатти почему то расылка идет и на IP=224.0.0.251 
и на IP=224.0.0.252 но 252 никто неимеет и никто не слушает


ba:ec:24:5c:80:3a > 01:00:5e:00:00:fc, ethertype IPv4 (0x0800), length 71: (tos 0x0, ttl 255, id 47258, offset 0, flags [none], proto UDP (17), length 57)
    172.16.10.12.5355 > 224.0.0.252.5355: UDP, length 29


ba:ec:24:5c:80:3a > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 93: (tos 0x0, ttl 255, id 62679, offset 0, flags [none], proto UDP (17), length 79)
    172.16.10.12.5353 > 224.0.0.251.5353: 0 [1n] ANY (QM)? debian12-c2.local. (51)


ba:ec:24:5c:80:3a > 01:00:5e:00:00:fc, ethertype IPv4 (0x0800), length 71: (tos 0x0, ttl 255, id 47290, offset 0, flags [none], proto UDP (17), length 57)
    172.16.10.12.5355 > 224.0.0.252.5355: UDP, length 29


ba:ec:24:5c:80:3a > 01:00:5e:00:00:fc, ethertype IPv4 (0x0800), length 71: (tos 0x0, ttl 255, id 47332, offset 0, flags [none], proto UDP (17), length 57)
    172.16.10.12.5355 > 224.0.0.252.5355: UDP, length 29


ba:ec:24:5c:80:3a > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 93: (tos 0x0, ttl 255, id 62784, offset 0, flags [none], proto UDP (17), length 79)
    172.16.10.12.5353 > 224.0.0.251.5353: 0 [1n] ANY (QM)? debian12-c2.local. (51)


ba:ec:24:5c:80:3a > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 93: (tos 0x0, ttl 255, id 62854, offset 0, flags [none], proto UDP (17), length 79)
    172.16.10.12.5353 > 224.0.0.251.5353: 0 [1n] ANY (QM)? debian12-c2.local. (51)


ba:ec:24:5c:80:3a > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 126: (tos 0x0, ttl 255, id 62956, offset 0, flags [none], proto UDP (17), length 112)
    172.16.10.12.5353 > 224.0.0.251.5353: 0*- [0q] 2/0/0 debian12-c2.local. (Cache flush) A 172.16.10.12, 12.10.16.172.in-addr.arpa. (Cache flush) PTR debian12-c2.local. (84)


20:57:28.175039 ba:ec:24:5c:80:3a > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 126: (tos 0x0, ttl 255, id 63264, offset 0, flags [none], proto UDP (17), length 112)
    172.16.10.12.5353 > 224.0.0.251.5353: 0*- [0q] 2/0/0 debian12-c2.local. (Cache flush) A 172.16.10.12, 12.10.16.172.in-addr.arpa. (Cache flush) PTR debian12-c2.local. (84)



и все узнают это у кого стоит это демон через мультикаст пакет.
тоесть мультикаст служит как инстурумент доставки инфо для всех в сегменте кто входит
в мульиьикаст группу. и у кого на компе стоит такой же демон

таким демоном успешно яявляется systemd-resolved  и ненужен нам никакой ни avahi 
ни mdnsresponder. systemd-resolved отлично с этой задачей справляется. как его для
этого законфигурироваь я раскажу завтра.
если же к sr идет запрос разыскать комп с именем

        vasya.local

то он понимает что искать надо через mdns протокол. и он тогда опять же делает мульикаст
рассылку на IP=224.0.0.251 UDP порт 5353
и тот комп у которого хостнейм vasya и стоит sr с активированой фкнцией mdns отвечает 
в ответ и говорит - этоя имею такое mdns имя. и вот мой ip. 
и все это без  цетрализванного днс сервера. и прочих сложных настроек. 

вот как выглядит этот запрос и ответ
я на локлаьном компе запускаю 

 (local 172.16.10.12) # # dig -4 debian12-c1.local


на уадленном ловю такой тарфик

(remote 172.16.10.11)  # tcpdump -n 'udp' -i enp0s3 -e  -v

реквест 
ba:ec:24:5c:80:3a > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 77: (tos 0x0, ttl 255, id 10121, offset 0, flags [none], proto UDP (17), length 63)
    172.16.10.12.5353 > 224.0.0.251.5353: 0 A (QM)? debian12-c1.local. (35)

ответ
ba:ec:24:5c:80:3f > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 87: (tos 0x0, ttl 255, id 55975, offset 0, flags [none], proto UDP (17), length 73)
    172.16.10.11.5353 > 224.0.0.251.5353: 0*- [0q] 1/0/0 debian12-c1.local. (Cache flush) A 172.16.10.11 (45)


причем ответ шлется не по юникасту компу который запросил а сразу всем в гурппе
по мультикасту

что удивительно когда пишут про mdns на лиукнсе то всегда пишут про долбаный avahi
или mdnsresponder. но нахер они нужны. когда это уже есть в sr!

остется показать как на практике настрить этот mdns на sr

значит берем комп с sr.
в resolved.conf который заадает глоальные настройки непривзянные к конкретной сет
карте или говоряи их ним языком задает настройки в global секции пишем настройку
а точнее мы в resolved.conf ничего неменяем. там находятся дефолтовые настройки
заданные при комлиилияции демона. вместо этого создаем папку

        /etc/systemd/resolved.conf.d/

и в ней файл 
    
            global.conf

название папки важно именно такое (об этом написано в man resolved.conf)
а навзание файла имя любое а расшироение .conf

и в этом файле мы указываем настройки. дроп-ин файл он такой что он преебиывает 
дефолтовые настройки. плюс его в в том что при обновлении демона наверное
файл resolved.conf может быть перетерт новым пакетом. а дроп-ин файл нет. поэтому
типа умнее задавать натройски в дроп-ин файлах кооа мы имеем дело с деонами системд
итак в этом файле заадем глобальную настройку



        [Resolve]

        MulticastDNS=yes


это приводит к тому что sr демон начинает слушать все IP адреса на протоколе UDP порт 5353
щас покажу
теость если у нас в конфиге стоит вот так

        MulticastDNS=yes

то процесс на протоколе UDP будет слушать только вот такие сокеты

    # lsof -n -P  -p $(pidof systemd-resolved) | grep UDP
        UDP 127.0.0.53:53 
        UDP 127.0.0.54:53 


так вот при настройке 

        MulticastDNS=yes

у нас демон начинает слушать вот такой сокет

                UDP *:5353 
                UDP *:5353 


это еще нихрена не мультикаст трафик. это пока просто "слушать все IP адреса на компе
на прртоколе UDP и порту 5353"

тут же проверяем у нас на компе этот демон  добавил мультикаст IP на какойнибудь
интерфейс

вот так выглядит сутуация при настройке 

    MulticastDNS=no


1:  lo
    inet  224.0.0.1

2:  enp0s3
    inet  224.0.0.1

4:  tun1
    inet  224.0.0.1

8:  tun0
    inet  224.0.0.1


вот так ситуация выглядит при натсройке 

    MulticastDNS=yes


# ip -4 maddr
1:  lo
    inet  224.0.0.1

2:  enp0s3
    inet  224.0.0.1

4:  tun1
    inet  224.0.0.1

8:  tun0
    inet  224.0.0.1

тоест тоже самое. никакой мультикаст адрес добавлен не был. с этой настройкой 
только добавляется что демон слушает на уже имеющихся адресах UDP порт 5353 протокол


                UDP *:5353 
                UDP *:5353 


таким макаром я показал к чему приводит активация mdns глобально или в глобальной секции

теперь я активирую mdns в пер-интфрейс секции
как я уже говорил по какойто дебильной мысли это нельзя сделать в конфиге это
можно сделать толко налету через cli

     # resolvectl mdns enp0s3   yes

кстати еси я хочу обратно отклчить эту настройку то делатся это вот так

     # resolvectl mdns enp0s3   ""
или
     # resolvectl mdns enp0s3   no

также наод помнить что пер-интерфейс настройки демон записывает в временную папку
        /run/systemd/resolve/...

и когда демон останаливется прегружается то он эту папку не стирает. поэтому 
если мы через кли откорерктровали пер-интерейс настройки то они сохрантся после пере
загрузки демона. а если конечно перегрузить комп то они исчезнут

итак я активирую mdns на интфрейсе 

     # resolvectl mdns enp0s3   yes

и проверяем поаяился ли  у нас в систмеме новый мультикаст ip адрес

# ip -4 maddr

1:  lo
    inet  224.0.0.1

2:  enp0s3
    inet  224.0.0.251  <=====
    inet  224.0.0.1

4:  tun1
    inet  224.0.0.1

8:  tun0
    inet  224.0.0.1


как видно да пояивлся как раз на том интфрейсе на котором я менял пер интерфейс 
настроуйку

и так как у нас до этого уже демон слушал вот такой сокет

   *:UDP 5353

то получается щас в итоге у нас в часности слушается сокет

       IPv4 224.0.0.251 UDP 5353

это значит если в комп влетит пакет ip с dst_ip=224.0.0.251 и внутри будет UDP пакет
с порттом 5353 то наш sr его в себя заглотит

также примтчально что через ip -c a s мы неувидим мультикаст ip адреса

в rfc6762 написано что пакеты протокола mdns должны иметь dst_IP=224.0.0.251
так что наш демон тоочно обслуживает mdns протокол

в rfc6762 написано что 
    The most basic kind of Multicast DNS client may simply send standard
   DNS queries blindly to 224.0.0.251:5353
итам также написано про UDP
таким образом я делаю вывод что mdns протокол он работает на IP=224.0.0.251 но это
всего лишь пустая оболочка письмо с адресом и пустотой внутри. а внутри должен быть
протокол UDP на порт 5353

таким макаром я делаб вывод что наш sr точно обслуживает mdns протокол

ксатти  я проверил - можно ли послать с обычного днс клиента типа dig запрос на
mdns сервер IP 224.0.0.251 UDP 5353  и получить ответ. и я обнаружил что сервер 
понимает обычный днс запрос и отправляет ответ. проблема в том что обычный днс клиент
нихрена не понимает этот ответ. показываю

# dig @224.0.0.251 -p 5353   debian12-c1.local
;; UDP setup with 224.0.0.251#5353(224.0.0.251) for debian12-c1.local failed: network unreachable.
;; no servers could be reached

а вот тцпдамп с компа где сервер mdns крутится

тоесть прилетает запрос какой IP у debian12-c1.local ?
ba:ec:24:5c:80:3a > 01:00:5e:00:00:fb, ethertype IPv4 (0x0800), length 100: (tos 0x0, ttl 1, id 40814, offset 0, flags [none], proto UDP (17), length 86)
    172.16.10.12.47088 > 224.0.0.251.5353: 16252+ [1au] A (QM)? debian12-c1.local. (58)

сервер дает ответ мол вот какой debian12-c1.local. A 172.16.10.11
ba:ec:24:5c:80:3f > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 93: (tos 0x0, ttl 255, id 63888, offset 0, flags [none], proto UDP (17), length 79)
    172.16.10.11.5353 > 172.16.10.12.47088: 16252*- 1/0/0 debian12-c1.local. A 172.16.10.11 (51)

но клиент dig непонимает ответ. хотя сервер mdns реквест понял и ответ отправил
тоесьт можно на локальном компе запутсить диг плюс тцпдамп и по нему разглядеть ответ 

таким образом можно имя класический днс клиент делать запросы к mdns серверам
и полуать информацию.


другой путь иметь возможоность получить mdns клиент это sr. если мы на нем активировали
mdns то через sr можно делать mdns запросы. работает этотак  - если мы делаем запрос
к домену *.local либо через NSS либо через 127.0.0.53  то sr понимает что у него
просят сделать поиск домена который ослуживатся через mdns и он делает именно mdns
запрос на мультикаст а не обычный юникаст dns запрос к внешним днс серврерам. и
возвраащает нам ответ.

я написал пост на эту тему еще вот тут  - https://askubuntu.com/questions/972630/what-is-mdns-is-it-possible-to-make-mdns-query-without-mdns-service-running/1526875#1526875

кстати можно заметить что когда я обычными утилитами типа dig напрмиер делаю 
запрос на 224.0.0.251 то четко видно что такой запрос формирует dst_MAC в форме
мультикаст мак адреса автоматом. тоесть я так понимаю у нас формирование IPv4 пакета
занимается само ядро. и когда оно видит что это мультикаст IP адрес то оно понимает
что такой пакет нужно на уровне эзернета создавать используя мульттикаст мак адрес.

таким образом протокол mdns использует мультикаст IP адрес. потому что какойто IP
адрес то нужно все равно ставит в IP пакет. плюс я думаю этот IP адрес все рутеры
знают что он неможет выходить за локальный сегмент то есть они его не роутят. клиенты
видя такой dst_IP при получении понимают что это групповой мульттикаст пакет. 
ядро при создании эзернет кадра\пакета вдя такой dst_IP понимает что нужно юзать
мультикаст мак мак адрес. и это дает тогда то что свичи этот пакет направят либо 
по всем портам либо в группу портов IGMP. так как внутри UDP то получатель недолжлен
ничего на этот пакет отвечать. это кстаи удобно. если бы был tcp то все получатели
завалили бы отправителя своими tcp ответами. а нам это ненадо.
и таким образом sr в своем коде реализует и mdns клиент и mdns сервер.

теперь про смысл  увеомления mDNS в статусе resolvectl в глобальной секции и в секции
интрфейса

# resolvectl status
Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
...
...

Link 2 (enp0s3)
    Current Scopes: DNS mDNS/IPv4 mDNS/IPv6
         Protocols: +DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
...
...


по мне сделано достатоноч дебильно. почму то в глобальной секции нет 
сроки "Current Scopes". она есть толкоо в секции интерфейсов
а строка protocols есть в обоих секциях.
значит если я делаю настройку в resolved.conf либо в /etc/systemd/resolved.conf.d/*.conf


    [Resolve]
    MulticastDNS=yes

то тогда в глобальной секции появляется +mDNS

Global
         Protocols: ...  +mDNS  ...

если же настройка будет 

    [Resolve]
    MulticastDNS=no

то в глобальной секции будет 

Global
         Protocols: ...  -mDNS  ...

к чему это приовдит на бекенде. к тому что процесс systemd-resolved 
начинает слушать вот такой сокет

        * UDP 5353

по мне уведомление в секции глобал достаточно дебилное. оно ничего на не обьясняет. 
типа мы глобально актиивировали протокол mdns. ну а что это значит? 
по идее наш демон уже принимает запросы на mdns порту на всех IP адресах нашего
компа. едиснвтенное что в системе не установлен мультикаст IP адрес. мне приходит
идея - раз наш демон в теории уже слушает на всех картах всех IP по сути mdns трафик
то возможно если я напрпавлю mdns запрос на любой IP моего компа на UDP 5353
то наш демон ответит? я активировал дебаш лог левел и через диг направил запрос

   (клиент) # dig -4 @172.16.10.11  -p 5353  debian12-c1.local

смоьрю логи sr на сервере

systemd-resolved[1933]: Received mdns UDP packet of size 58, ifindex=2, ttl=64, fragsize=0, sender=172.16.10.12, destination=172.16.10.11

systemd-resolved[1933]: Got mDNS UDP packet on unknown scope. Ignoring.


тоесть принять сервер запрос принял. тут вопросов нет. но отвечать не стал. 
написал что принял mdns запрос но (как я понимаю запись "Got mDNS UDP packet on unknown scope") написал что на карточке сетевой на которой прилетел этот запрос mdns 
в секции "scope" нет. а значит запрос обрабатьывать ненадо. 
итак как сервер mdns он неработает с активированной mdns в глобальной секции.
тогда я подумал может он сможет как клиент делать mdns запросы. и я на сервере вызвал

    #resolvectl query debian12-c2.local
получил
    resolve call failed: All attempts to contact name servers or networks failed

а в логах демона я вижу что он пытался зарезолвить этот запрос обращаясь на обыкновенные
юникаст днс сервера поочереди на все что были прописаны в глобальном конфиге типа 8.8.8.8 итд
и видимо от них получать отлуп. по мне такое повдеение очень тупое. потому что если в
rfc6762 сказано что mdns протокол работает тольк на dst_IP=224.0.0.251 
то как то тупо лезать резволить mdns реквест на другие IP.
тогда я подумал а дай ка я в глобаьльной секции запишу днс сервер 224.0.0.251
это привело вот к чему. в логах демон пишет что он обращается на 224.0.0.251 но пофакту
тцпдамп показывает что ни на комме где демон ни на компе втором где тоже есть sr
никакой трафик не генерируется и не прилетает. это тоже дебильно в том плане что если
ты влогах пишешь что ты обращается кудато то надо реально обращаться или не писать в ло
гах такую хуйню.
кстати деибильно то что через resolvectl нельзя налету помнять настроки в 
глоаблной секции. надо менятькогфиг и перегружать сервис
тогда я в глобальной секции поставил  юникаст IP адрес второго сервера. 172.16.10.12
и перезагрузил sr.
делаю запрос
    #resolvectl query debian12-c2.local
и вижу в логах что трафик гененериурется но он шлет запрос на 53 порт 

        IP 172.16.10.12 UDP 53

а на уаделнном компе sr 53 порт слущает исключтельно на IP=127.0.0.53
из чего я делаю ФИНАЬЛЬНЫЙ ВЫВОД - что активация mdns в глобальной секции
по факту недает нихрена. ни на этот сервер нельзя сделать mdns запрос снаружи.
он конечно дойдет но sr в ответ отвечать ничо не будет только в логах напишет и все.
и нельзя наружу через sr делать клиентские запросы. тоесть да демон начинает слушать
сокет

    IP=*, UDP 5353

но в конечно выхлопе это недает нихрена

ксати вот при такой конфигурации

[Resolve]

MulticastDNS=no
DNS=


мы будем иметь вот такое

# resolvectl 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
       DNS Domain ~.

Link 2 (enp0s3)
Current Scopes: none
     Protocols: -DefaultRoute -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
    DNS Domain: 

тоесть никаких внешних внешних днс сереров наш демон не знает.
однако он принимает юникаст dns запросы вот на таких сокетах

d# ss -4 -nlp | grep 53
udp   UNCONN 0      0         127.0.0.54:53                            
udp   UNCONN 0      0      127.0.0.53%lo:53                                 
tcp   LISTEN 0      4096      127.0.0.54:53                                 
tcp   LISTEN 0      4096   127.0.0.53%lo:53

спрашивается заччем принимать реквесты если ты их неможешь зарезволить. хотя
насколько я помню sr может сам резолвить локальные реквесты типа localhost

если установка mdns в глобальной секции ничего недает  то убираение этой настройки
и попытака чтото получить тоже тем более ничего недаст.

тогда я шас буду пробовать вот какое - я в глобальной удалю а в пер-интерфейс 
активириую

тоеть


[Resolve]

MulticastDNS=no
DNS=8.8.8.8
Domains=~.


и 

       #  resolvectl mdns enp0s3 yes

в итоге имеем

# resolvectl 
Global
         Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8
         DNS Domain ~.

Link 2 (enp0s3)
Current Scopes: none
     Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported


итак видно что в глобаной секции -mDNS а в секции интфрейса enp0s3 стоит +mDNS

при таком раскладе   я пробую выполнить mdns кьюри. 
# resolvectl query debian12-c2.local
debian12-c2.local: resolve call failed: All attempts to contact name servers or networks failed

в логах sr он пишет что типа пытается вполнить запрос на 8.8.8.8 
но по  факту никккоой тарфик исходящий судя по тцпдамп не гененртруется. тоесть логи
пиздят. я думаю он видит что домен .local значит надо делать запрос через mdns
но так как он дезавткирован в глобаной секции то в итоге он НИХУЯ НЕДЕЛАЕТ
соовтветственно как клиент mdns он в такой конейигцрации неработает. а ведь могбы
а как сервер mdns он не будет работать и подавно потому что у него ни сокет
не слущается
    * UDP 5353

ни мультикаст ip адрес 224.0.0.251 на enp0s3 неподнят.

из чего я делаю вывод что активация  в глоабальной секции +mDNS через

        MulticastDNS=yes

в конфиге  , активириует mdns "в приниципе". то есть по факту ни клиентские
запросы mdns ни запросы к серверу по mdns работать не будут еще пока. но протокол
активириуется "в приниципе". хотя на бекенде сервис начинает принимать UDP 5353 
запросы по всем IP. но отвечать сука он на них не собирается. он толко в логах 
будет писать мол приелел запрос но  я отвеать на него не буду. это все реально ебануто. 
активация mDNS после этого на интерфейсе per-interface дает то что на этом интерфейсе
поднимается мультикаст IP 224.0.0.251 итеперь если на этот интерфейс на этот IP
прилетит mdns запрос UDP 5353 то сервер на него ответит. тоесть через этот интфрейс
он начинает работать как сервер.  также через этот интфреейс теперь sr будет делать
клиентские mdns запросы наружу используя dst_IP=224.0.0.251   
я щас покажу как он будет делать. 

и сразу скажу свой вывод об этом всем деле.
активация +mDNS в глобальной секции активирует mDNS "вообще". тоесть на практкие это 
ничего недает на данный момент но без этого небудет рабоать вообще. а активация +mDNS
на интфрейсе дает то что на данном интерфейсе активируется сервер mdns то есть принимаются
запросы. и активириуется клиент mdns тоесть из данного интререйса разрещаются клиентские
запросы mdns наружу. активация +mDNS только на интерефейсе надаст нихрена. она начинает
работать только если активиована +mDNS в глобальной секции. то есть логика анализа 
вывода resolvectl такова



# resolvectl status
Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8
         DNS Domain ~.

Link 2 (enp0s3)
Current Scopes: mDNS/IPv4 mDNS/IPv6
     Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported



я смотрю на интерфейс вижу на нем настройку +mDNS значит на этом интерфейсе активирован
и сервер mdns и клиент mdns. тоесть если на этот интрефейс послать запрос mdns то 
полуичим ответ. и из этого  интерфейса sr может посылать клиентские mdns  запросы
но! это работает только и только если дополниетлельно в глобаьной секции активирован +mDNS

также еси +mDNS активиован только в глоальной секции но ни в одном интрфейсе не активован
то это нихрена не дает ничего.

причем +mDNS мы смотрим в каждой секции в разделе "Protocols"

также если +mDNS активиоррован в глобальной секции и в секции интерфейса тогда 
mDNS появляется в секции интерфейса нетолько в разделе Protocols но и  в секции 
"Scopes"

        Current Scopes: mDNS/IPv4 mDNS/IPv6

тоесть если мы видим в разделе интерфейса в строке Scopes слово mDNS 
то оно как бы нам по русски намекает на то что "Эй! +mDNS активирован и на этом интерфейсе
и глобально!"

поэтому можно чтобы понять работает ли раельно mDNS через интерфейс ( и как клиент и как 
сервер ) то можно в разделе интфрейса смотреть сразу в строку "Scopes". если там 
ест mDNS значит все окей. а если там нету. то значит либо mDNS не активорвано в глоабальной
секции через конфиг файл, либо он не активрован в секции этого интерфрейса через 
resolvectl. это просто пиздец как все "классно" придумано
по мне не архитертура а пиздец. очень "понятная   и логичная".

тоесть на практике строка Scopes в секции интерфейса показвыает через какой прооокол
через этот интерфейс разрешается принимать реквесты и отправлять реквесты. 
если в  Scopes указан mDNS значит mDNS.

еще раз скажу что на бекенде при активаиции mDNS в глоьальнрой секции происходит
то что процесс sr начинает слушать UDP сокет

            * UDP 5353

но слушает он его хитро. он реквесты принимает , в логи об этом записывает. но ответ
обратно не посылает. он там типа намекает что ни через одну сет карту неразрешено 
работать по mDNS. 

а активация mDNS на интерфейсе дает то что на бекенде  происходит вот что - на этом
интерфейсе создается IP адрес 224.0.0.251

вот я активрован на двух интерфейсах mdnS

    #resolvectl mdns enp0s3 yes
    #resolvectl mdns tun0 yes

и 224.0.0.251 появился на обоих

# ip -4 maddr

2:  enp0s3
    inet  224.0.0.251  <======
    inet  224.0.0.1

8:  tun0
    inet  224.0.0.251  <=======
    inet  224.0.0.1


насколько я понимаю (непровяерял). получается что запросы как к mdns серверу будут приим
аться на обоих картах.  а если sr делает клиентский запрос то как я думаю он будет
его выстреливать однорврменно с обоих карт.


насколкьо я понимю настроить на sr чтобы он рабоатал только как клиент либо только 
как сервер = НЕВОЗМОЖНО. он либо вобще неработает  с mdns либо сразу работает клиент+сервер

а щас я покажу как дейтсвует sr когда его нужно сделать mdns клиент запрос

    # resolvectl -4  query debian12-c2.local

тогда на сервере в сеть вот такой трафик гененируется

enp0s3 Out IP 172.16.10.11.5353 > 224.0.0.251.5353: 0 A (QM)? debian12-c2.local. (35)

enp0s3 M   IP 172.16.10.12.5353 > 224.0.0.251.5353: 0*- [0q] 1/0/0 (Cache flush) A 172.16.10.12 (45)

тоесть он делает мультикаст выброс (причем там стоит нетолько мультикаст dst_IP но
и мульттикаст DST_MAC этого в выводе не видно но это так. я раньше провереял)
на IP 224.0.0.251 UDP 5353

в ответ сервер который имеет данное днс имя  шлет тоже на мулььитикаст ответ

        172.16.10.12.5353 > 224.0.0.251.5353

а в логах sr 
будет видно вот что 

внчалае он пишет что через дбас получил рекввест

 Got message type=method_call sender=:1.148 destination=org.freedesktop.resolve1 path=/org/freedesktop/resolve1 interface=org.freedesktop.resolve1.Manager member=ResolveHostname cookie=2 reply_cookie=0 signature=isit error-name=n/a error-message=n/a
 idn2_lookup_u8: debian12-c2.local → debian12-c2.local
 Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=GetConnectionUnixProcessID cookie=6 reply_cookie=0 signature=s error-name=n/a error-message=n/a
 Got message type=method_return sender=org.freedesktop.DBus destination=:1.146 path=n/a interface=n/a member=n/a cookie=7 reply_cookie=6 signature=u error-name=n/a error-message=n/a
 D-Bus hostname resolution request from client PID 2335 (n/a) with UID 4294967295

тут понятно

 Looking up RR for debian12-c2.local IN A.


опять возьнтя по дбас

 Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=AddMatch cookie=7 reply_cookie=0 signature=s error-name=n/a error-message=n/a
 Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=GetNameOwner cookie=8 reply_cookie=0 signature=s error-name=n/a error-message=n/a
 Got message type=method_return sender=org.freedesktop.DBus destination=:1.146 path=n/a interface=n/a member=n/a cookie=9 reply_cookie=8 signature=s error-name=n/a error-message=n/a


зачем то чтото пытается делать через юникаст днс сервер. но пофакту на него
никакого трафика не посылает судя по тцпдамп

 Switching to system DNS server 8.8.8.8.

 Sent message type=signal sender=n/a destination=n/a path=/org/freedesktop/resolve1 interface=org.freedesktop.DBus.Properties member=PropertiesChanged cookie=9 reply_cookie=0 signature=sa{sv}as error-name=n/a error-message=n/a
 

а вот наконец пишет что собрается делалть mdns запрос через картчоку enp0s3
вот эта фраза "scope mdns on enp0s3" по мне означает что он собирается делать mdns
запрос через карточку enp0s3
и вначале он вроде как ищет запись в кэше

 Firing regular transaction 45710 for <debian12-c2.local IN A> scope mdns on enp0s3/INET (validate=yes).
 Delaying mdns transaction 45710 for 0us.
 Initial jitter phase for transaction 45710 elapsed.
 Retrying transaction 45710.
 Cache miss for debian12-c2.local IN A

тепер вроде как ненайдя в кэше наонец то собирается делать рельный запрос в сеть
и делает его

 Firing regular transaction 45710 for <debian12-c2.local IN A> scope mdns on enp0s3/INET (validate=yes).
 Sending query packet with id 0 on interface 2/AF_INET of size 35.


 и вот оон пишет что получил ответ
хотя какой это нахрен ответ если sender=172.16.10.11 это IP адрес этого же сервера
тоесть по идее это не ответ  акак раз таки пакет запроса. почему он его называет 
ответ хрен знает

 Received mdns UDP packet of size 35, ifindex=2, ttl=255, fragsize=0, sender=172.16.10.11, destination=224.0.0.251

опять возьня с дбас

 Got message type=method_return sender=org.freedesktop.DBus destination=:1.146 path=n/a interface=n/a member=n/a cookie=8 reply_cookie=7 signature=n/a error-name=n/a error-message=n/a
 Match type='signal',sender='org.freedesktop.DBus',path='/org/freedesktop/DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged',arg0=':1.148' successfully installed.

а вот он уже получил релный ответ. потому что сендер 172.16.10.12 это уже реально 
сервер ответа

 Received mdns UDP packet of size 45, ifindex=2, ttl=255, fragsize=0, sender=172.16.10.12, destination=224.0.0.251
 Got mDNS reply packet
 Checking for conflicts...
 Processing incoming packet of size 45 on transaction 45710 (rcode=SUCCESS).
 
 и вот он пишет что обработал пакетответа и он ему понравился

 Regular transaction 45710 for <debian12-c2.local IN A> on scope mdns on enp0s3/INET now complete with <success> from network (unsigned; non-confidential).

 это виимо он по дбас шлет инфо в резолвцтл

 Sent message type=method_return sender=n/a destination=:1.148 path=n/a interface=n/a member=n/a cookie=10 reply_cookie=2 signature=a(iiay)st error-name=n/a error-message=n/a
 Sent message type=method_call sender=n/a destination=org.freedesktop.DBus path=/org/freedesktop/DBus interface=org.freedesktop.DBus member=RemoveMatch cookie=11 reply_cookie=0 signature=s error-name=n/a error-message=n/a
 

это он вычищает мусор от транзации в своей памтяти я так понимаю

 Freeing transaction 45710.

это он добавил инфо в свой кэш

 Added positive unauthenticated non-confidential cache entry for debian12-c2.local IN A 120s on enp0s3/INET/172.16.10.12

таким макаром я рассмотрел mDNS в целом и как он релизован в сервисе sr

значит далее я хочу расшифровать значение "Current Scopes" в свойствах секции
связанной с сет картой. 
значит если в этой секции указано mDNS

        Current Scopes: mDNS/IPv4 mDNS/IPv6

то как я сказал это озачает что через данный интерфейс обслуживаются запросы извне
как к серверу mDNS и из этой карты наружу демону можно запускать mDNS запросы вовне.

так вот если в этой строке написано DNS вот так 

        Current Scopes: DNS

то это значит что для данной сетевой карты задан днс сервер

Link 2 (enp0s3)
Current Scopes: DNS 
   DNS Servers: 12.12.12.12

а что это значит на практике?
а вот что если у нас задан днс сервер в глобальной секции
и задан днс сервер на карточке


Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8

Link 2 (enp0s3)
    Current Scopes: DNS mDNS/IPv4 mDNS/IPv6
         Protocols: +DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 8.8.4.4
       DNS Servers: 8.8.4.4


то запросы будут делаться СРАЗУ НА ОБА СЕРВЕРА!. 

systemd-resolved[2558]: Using DNS server 8.8.8.8 for transaction 3808.
systemd-resolved[2558]: Using DNS server 8.8.4.4 for transaction 59562.

systemd-resolved[2558]: Using DNS server 8.8.4.4 for transaction 34271.
systemd-resolved[2558]: Using DNS server 8.8.8.8 for transaction 5613.

systemd-resolved[2558]: Using DNS server 8.8.4.4 for transaction 29693.
systemd-resolved[2558]: Using DNS server 8.8.8.8 for transaction 48764.

тоесть один и тот же реквест будет пуляться сразу и на 8.8.8.8 и на 8.8.4.4 !!

если я добавлю в генеральную секцию парамтер 

Domains=~.
то тогда все днс сервера указанные пер-интфрейс будут игнорироваться и 
будет исползоваться только днс сервер уазнный в генеральной секции

а ДАЛЬШЕ ПОЛНЫЙ ПРИКОЛ. я то думал что "Domains=~." добавленный в General секцию
заставляет игнорировать пер-интерфейс настройки. ОКАЗЫВАЕТСЯ НИХРЕНА! это верно
тоолько если в per-interfcae секциях не прописан паараметр Domains. 
а если он прописан то поведение совершенно другое! 
вот пример

вот конфигурация

Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 172.16.10.1
        DNS Servers 172.16.10.1
         DNS Domain ~.

Link 2 (enp0s3)
    Current Scopes: DNS mDNS/IPv4 mDNS/IPv6
         Protocols: +DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8
        DNS Domain: com ru

она будет работать вот как - если запрос содержит com или ru тоода огн будет
наравлен через 8.8.8.8 а еесли не содержит тогда через 172.16.10.1
а если " DNS Domain: com ru" будет убран то тогда да все реквесты подйут через 
172.16.10.1, а если еще убрать и  "DNS Domain ~." то каждый запрос будет послыаться
одноврменно на оба и 8.8.8.8 и 172.16.10.1 
еще раз скажу я почему удивлен. я то удумал что если вставить в Geenneral сукцию
настройку   "DNS Domain ~."  то это засавит  все запросы проходит через днс 
генеральной секции и плевать на днс  в интерфейсах. оказывается нет. нихрена.
если запрос содрежржрит com или ru то запрос пойдет чрез 8.8.8.8 и плевать на 
эту тильду в генеральной секции!

чем resolvectl крут. он позволяет поменять налету оператвино легко и просто
пер интерфейс настройки у демона не засавляяя его перегружаться. кроме изменений
глобальной секции. что ксатти дебильно





если я добавляю домен с тильдой (route-only домен) в интерфейс

     # resolvectl domain enp0s3 ~co.uk



Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8

Link 2 (enp0s3)
    Current Scopes: DNS mDNS/IPv4 mDNS/IPv6
         Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 8.8.4.4
       DNS Servers: 8.8.4.4
        DNS Domain: ~co.uk  <======= 


то тоггда это работает так. если я делаю запрос для доомена *.co.uk то он исполняется
через 8.8.4.4  а для всех остальных доменов через 8.8.8.8
единственное я не знаю если днс сервер указанный в интерфейсе нележит за данным 
интерфейсом то что? тоесть когда днс сервер лежит за интерфейсом тога все просто
при создании реквесте у пакета убдет указан src_IP=IP интерфейса а dest_IP=8.8.8.8
а мне интересно если на основе таблицы маршрутизации получается расхождение что 
если на основе табицы маршутизации получается что маршрут до 8.8.8.8 лежит через другую
карту и тоесть src_IP будет другой и пакет будет высран в сеть через другую карту.?
тоесть я не могу понять через какуб карту и какой src_ip будет использован для создания
пакета который должен лететь к 8.8.8.8 на оснвое таблицы мрауртизации или на основе
таблицы что выше?
я кстати еще раз почитал man NetworkManager.conf и его две наатрройки dns и rc-manager
и как я понял они в основном касаются будет ли модифициован /etc/resolv.conf (erc)
а как настроить чтобы NetworkManager не пушил свои настройки на интерфейс через 
resolvectl в systemd-resolved этого вообще нет. и как я понял он их будет пушить 
всегда.
далее я проэкспериментировал и пришел к выводу что домены с тильдой (роут-онли домены)
они не используются для  превращения запросов из одного слова в запросы полноценные
хотя бы из двух слов. тоесть домены с тильдой не дописываются в хвост однословного 
запроса.
теперь я заменю на интерфейсе домен с тильдой на домен без тильды.

        # resolvectl  domain  enp0s3  ""
        # resolvectl  domain  enp0s3  com


Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8

Link 2 (enp0s3)
Current Scopes: DNS mDNS/IPv4 mDNS/IPv6
     Protocols: +DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.4.4
    DNS Domain: com   <======

это так называемый search домен. 
вначале я проверю что он используется для для подставновку в домен из одного слова
и преварщения неполноценного днс запроса в полноценный


# resolvectl -4 query     vasya
vasya: 76.223.54.146                           -- link: enp0s3
       13.248.169.48                           -- link: enp0s3
       (vasya.com) <=====


и в логах 

    systemd-resolved[2558]: Using DNS server 8.8.4.4 for transaction 53367

тоесть мало того что vasya был превращен в vasya.com при этом еще и далее
запрос был запущен на сервер 8.8.4.4 этого интрфейса. тоесть если запрос попал 
под обработку серч домена то он нетлько будет дополнен в хвост этим серч  доменом
но еще и после этого реквест будет направлен на днс сервер из этой же секции
а если домен  в реквесте неоднословный тогда как такой запрос будет обслужен?
ответ - он будет осблужен точно также как если бы небыло вобще этого серч домена.
тоесть тогда запрос будет направлен сразу на оба сервера и того который в глобальной
секции и того который на интерфейсе прписан.

далее при этой же конфигурации 


Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8

Link 2 (enp0s3)
Current Scopes: DNS mDNS/IPv4 mDNS/IPv6
     Protocols: +DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.4.4
    DNS Domain: com   <======

у меня возник вопрос. а что если я задам реквест в котором уже есть .com ?
типа vasya.com , этот реквест ненужно дополнять. но он попадает под шаблон *.com
какой днс сервер его обслужит?  оказалось что в этом случае его обслужит 8.8.4.4
тоесть серч домен com он еще работает и как route-only домен ~.com !
итак получается что серч домен он также автоматом является и роут-онли доменом!

итак домен стильдой "~.com" (роут-онли ) домен он действует так. если в запросе есть такой
же домен то запрос будет направлен на днс сервер из той же секции где прописан этот
роут онли домен.  и роут онли домен не участвует в превращении запроса из одного
слова в запрос из несклоьких слов. тоесть он недописывается в конец домена в запросе
из одного слова. 

серч домен - домен без тильды "com" он автоматом работает также как и 
роут онли домен "~.com" но также он еще участвует в превращении запроса состяоящего
из одного слова в запрос такой что к этому слову в конце приписывается серч домен.
было vasya стало vasya.com , и после этого так как серч домен еще и автоматом роут 
онли домен то тогда запрос vasya.com будет послан  на днс серввер прописанный в этой 
же секции где и серч домен.

исходя из конфигурации выше. если зпрос состоит из одного слова "word" то запрос 
будет дополнен до word.com и направлен на 8.8.4.4
если запрос уже имеет .com напрмиер  vasya.com то он будет тоже направлен на 8.8.4.4
остальные запросы будут нпарвлены одноврмененно и на 8.8.8.8 и на 8.8.4.4


если я в секции интерфейса удалю днс сервер 8.8.4.4

        # resolvectl  dns  enp0s3 ""

получим вот так

# resolvectl 
Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8

Link 2 (enp0s3)
Current Scopes: mDNS/IPv4 mDNS/IPv6
     Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
    DNS Domain: com


то не смотря на то что у нас есть серч домен у нас однословные запросы не буудут
модифицироваться и дополняться .com , тоесть без адреса днс сервера на интерфейсе
настройка "DNS Domain" неработает. ее как бутто нет.

тоесть днс добавленнй в интерфейс без добавления  "DNS Domain"  - рабооатает. дает эфект
а добавление на интрфейс "DNS Domain" без добавления днс на интереефейс нихрена 
ничего недает

вернемся к этой конфигурации

Global
         Protocols: -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 8.8.8.8
        DNS Servers 8.8.8.8

Link 2 (enp0s3)
Current Scopes: DNS mDNS/IPv4 mDNS/IPv6
     Protocols: +DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.4.4
    DNS Domain: com


если запрос состоит из одного слова то к нему будет добавлен .com 
а потом запрос будет запущен на 8.8.4.4
если в запросе уже есть .com то он будет запущен на 8.8.4.4
для всех остаьных запросов - запрос будет запущен сразу на и на 8.8.8.8 и на 8.8.4.4


ксати настройка +DefaultRoute как обычно в мане описание ужасное.
я взял вот такую кофнигурацию

Global
         Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 172.16.10.1
        DNS Servers 172.16.10.1

Link 2 (enp0s3)
    Current Scopes: DNS
         Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8


и я в секции пер-интерфейс игрался. я делал то  -DefaultRoute то делал +DefaultRoute
ксатти важно заметить что генеральной секции нет настройки Domains=~.
что я открыл. если выставить -DefaultRoute то запросы идут только через 172.16.10.1
если выставит +DefaultRoute то запрос идет и через 172.16.10.1 и через 8.8.8.8
это рындец какойто

как я уже сказал если сделать вот так

Global
         Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 172.16.10.1
        DNS Servers 172.16.10.1
        Domains: ~.

Link 2 (enp0s3)
    Current Scopes: DNS
         Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8
       Domains: com

и запросить  vasya.com то реквест пойдет через 8.8.8.8 


если вот так
тоесть в глобаьльной секции Doamins незаадан
в пер-интфрейс секции задан Domains = com
и в пер интрфрейс -DefaultRoute

Global
         Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
  resolv.conf mode: stub
Current DNS Server: 172.16.10.1
        DNS Servers 172.16.10.1

Link 2 (enp0s3)
    Current Scopes: DNS
         Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 8.8.8.8
       DNS Servers: 8.8.8.8
        DNS Domain: com

и запрос к valya.ru то он идет через ..10.1

если активировать +DefaultRoute  он идет через оба днс

если я добаволю в генеарильно секции Domains="~."

Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain ~.

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: com


то запрос к valya.ru пойдет по уже через один днс ...10.1
если изменить на +DefaultRoute и сделать petya.ru то запрос пойдет опять же
чрез 10.1

есть еще вариант когда вот такой

Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub
      DNS Servers 172.16.10.1
       DNS Domain ~.

Link 2 (enp0s3)
Current Scopes: DNS
     Protocols: -DefaultRoute -LLMNR +mDNS -DNSOverTLS DNSSEC=no/unsupported
   DNS Servers: 8.8.8.8
    DNS Domain: ~.

в этой ситауции запрос к valya.ru буедети идти через оба днс вензавсисимости 
от знака DefaultRoute




о чем говорит если в скоупе интерфейса есть слово DNS ?

        Current Scopes: DNS

оно говорит о том что для данного интерфейса прописан идивидуальный адрес днс сервера.
в отличии от слова mDNS в скоупе слово DNS совершенно не значит что на данную сет
карту можно присылать DNS запросы и они будут обработаны. этого нет. 
отсуствтие слова DNS совершенно не означает что через эту карту демеону нельзя 
отправляь юникаст днс запросы. этого тоже нет. 
тоесть архитекутара просто дебилоидная. слово mDNS в скоупе значит что на данный
интерфейс можно присылать mDNS запросы и они будут обработаны и отвечены (тоесть что на
данном интерфейсе висит mdns сервер) и также то что с данного интерфейса демону
разрешено направлять во вне mdns запросы. а если в скоупе mDNS слова нет то ничего
что касается mdns через этот интерфейс пропускать не получится.
так вот слово DNS в скоупе значит СОВЕРШЕННО ДУРГОЕ. если оно есть то это всего 
навсего значит что для данного интерфейса прописан индвидуальный днс сервер. 
что это дает на практие завсиит еще от нескольких факторов.
а именно если от того чему равно слово Domains в генеральной секции. 
в пер-интерфейс секции. чему равно DefaultRoute  в пер-интерфейс секции.



что такое LLMNR пожалуй я изучать не буду.

в общем на этом я пока щас буду ставить точку. ибо надо начать 
заниматься другими делами. увы.

ксатти насколько я узнал узнать привязан ли (назнчен ли) мультикст IP адрес на 
сетевой карте можно через ip -c a и должен быть выставлен флаг MULTICAST

3: wlp2s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 ...
    link/ether 80:30:49:b2:85:cf brd ff:ff:ff:ff:ff:ff
    inet 192.168.211.1/24 brd 192.168.211.255 scope global ...

вот в первой строке крупно написано MULTICAST
значит к нему приавязан и мультикст ip который уже можно узнать через

   # ip -4 maddr



на счет типов ip адресов. то с чего я наверху начал. 
есть global , есть local , есть host ip адреса 

lo: <LOOPBACK,UP,LOWER_UP> 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
                            /\
                            ||
                            ||

                           слово host


tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> 
    link/none 
    inet 172.16.50.5 peer 172.16.50.1/32 scope global tun0
                                                 /\
                                                 ||
                                                 ||

                                              слово  global

  inet6 fe80::3fa3:799e:1e93:5c7/64 scope link stable-privacy proto kernel_ll 
                                           /\
                                           ||
                                           ||

                                       слово  link

этот тип ip адреса назначает ядро. назнчает оно исходя из диапазона в который 
входит этот ip адрес.
можно его поменять. щас не буду углубляться. но в целом соль в чем. 
если ip адрес имеет тип host это значит что он виден только процессам внутри хоста.
с другого хоста до этого ip адреса не достучаться. возникает вопрос а почему не 
достучаться. давайте назначим его на реальную сетевую карту и пинганем. для пакета
в эзернет сети какая разница какой там внутри ip адрес. ведь все работает на 
уровен мак адресов. я не проверял но скорей всего само ядро недаст назначить
такой адрес на реалбную сеевую карту. вобщем нет времени проверять. 
говорю лишь вывод - такой ип адрес доступен и виден только внутри хоста. снаружи нет.

link ип адрес - он виден только между компами внутри сегмента. тесть между компаи
локалки. роутер такой ip адрес пропускать наружу недолжен.

global - самый коызрный. его через себя наружу пропускает роутер.

в man systemd.network 
нашел
scope адреса:
      The scope of the address, which can be "global" (valid everywhere on the network, even through a gateway), "link" (only valid on this device, will
           not traverse a gateway) or "host" (only valid within the device itself, e.g. 127.0.0.1) or an integer in the range 0...255. Defaults to "global".
           IPv4 only - IPv6 scope is automatically assigned by the kernel and cannot be set manually.

           Added in version 235.

оказываетя что есть не только global, host, link  ip адреса. 
есть похожая хрень и для маршрутов.

про scope маршрута:
  Scope=
           The scope of the IPv4 route, which can be "global", "site", "link", "host", or "nowhere":

           •   "global" means the route can reach hosts more than one hop away.

           •   "site" means an interior route in the local autonomous system.

           •   "link" means the route can only reach hosts on the local network (one hop away).

           •   "host" means the route will not leave the local machine (used for internal addresses like 127.0.0.1).

           •   "nowhere" means the destination doesn't exist.

           For IPv4 route, defaults to "host" if Type= is "local" or "nat", and "link" if Type= is "broadcast", "multicast", "anycast", or "unicast". In
           other cases, defaults to "global". The value is not used for IPv6.

           Added in version 219.

у меня не хватило времени с этим разобраться. пока оставил.









прикольная мысль - вот ты слазил в dns чрез tls 
и значит никто пока незнает куда ты соираешься лазить.
а потом ты уже лезеш туда через бразуер и https и то куда ты лезешь ввысвчеено в SNI 
который не криптуется. гоча. и вся секретность в жопе.

поэтому и надо весь трафик совать в впн. там уже никто ничего не уивдиьт

у меня вопрос нахер нужен этот SNI. вот у меня есть веб серер процесс на порту 443.
тоесть это 

    IP= 12.12.12.12 TCP 443

и на этом сокете сидит веб сервер. 
вот я с одного компа клиента стучу на этот сервер на сайт www1.ru 
у нас используется tls шифрование. которое выполняет юзер код этого сервера 
поутем подключения библиотеки. значит от клиента втекает шифрованный трафик. 
его процесс веб сервера декриптует. получает на выходе HTTP трафик. там четко 
написано что host: www1.ru  , все веб серверу процессу четко понятно куда ломился
клиент. 
потом другой клиент ломиться на этот же сокет этого же веб сервера но на сайт www2.ru
в этом нет проблемы. у нас просто теперь в этот сокет влетает два шифрованных потока
но каждй пакет этого потока имеет уникальное сочетание src_ip src_port 
и сервер дешифрвет этот поток через tls в юзер спейсе то есть он сам это декриптует
при этом он понимает что это другой поток от другого клиента. и получает другой http 
поток где указан ксатти другой host: www2.ru  
поэтому я непонимаю нахуй нужен SNI.

рассматривая mDNS я еще не рассмотрел как у него выглядит мультикаст MAC потому
что он формируется исходя из того какой мультикаст IP мы собираемся юзать



также мне тут открылось что почемуто chrome браузер сидит и слушает 
mDNS мультикаст трафик

# ss -nlp4
Local Address:Port              Peer Address:Port      Process                                         
224.0.0.251:5353                   0.0.0.0:*          users:(("chromium",pid=2669,fd=184))           
224.0.0.251:5353                   0.0.0.0:*          users:(("chromium",pid=2669,fd=179))           
224.0.0.251:5353                   0.0.0.0:*          users:(("chromium",pid=2669,fd=143))           
224.0.0.251:5353                   0.0.0.0:*          users:(("chromium",pid=2710,fd=712))           
224.0.0.251:5353                   0.0.0.0:*          users:(("chromium",pid=2710,fd=685))  
  
тоесть получается если у меня  в сети есть компы на которых есть mDNS то они
шлют свои хостнеймы  в виде server-01.local на мультикаст адрес IP 224.0.0.251  UDP 5353
и получается хром это слушает и собирает эти данные. нахуя он это делает?
если они вставитли это в хром чтобы он мог заходить на сайты вида 

  http://server-01.local/

то по мне это остой потому что резволвином доменов должен заниматься днс клиент
но никак не конечное приложение. 
в инетет пишут что мало того . хром еще решулярно шлет по всем сет картам IGMP 
трафик чтобы типа его свичи включили в мульттикаст группу. (вот тут пишут https://gist.github.com/mzpqnxow/ff88b5a519f5c3303ef8bc9de0245179)
поэтому очень поолезно получается на файврроолле закрывать не тлоько он траифка извне
но и от трафика изнутри. закрвая все по дефолту кроме того что явно сам разрешил

я ксати четко проверил что это не systemd-resolved как то там читает конфиг или 
чтото там у systemd-networkd. нихрена.
именно systemd-networkd при старте пушит в systemd-resolved (через сокет d-bus 
или resolvectl свои хотели про днс настройки пер интерфейс)
как я это прверил. у меня был конфиг systemd-netowrkd. я его перезапустил. получил
обвноленный статус интфрейсов в rsolvectl . потом я вручную изменил настроки пер-интерфефс
для одной из карточек. потом я перегрузил systemd-resolved. как известно при его
перезагрузке он нетрогает свои файлы в /run/... папке а тупо их обратно их обратно
счтыатвает. в частности там лежат файл в которых записана пер-интерфейс информация. 
ия перегрузил syetemd-resilbved и у меня пер интерйефйс информация не изменилась.
а если бы он чтото там читал запрашивал у systemd-networkd она должна была изменится.
зато когда я после этого ппрерузил systemd-networkd то сразу у меня в resolvedctl
изменилась обратная конфигурция пер-интрейс. это все значит что именно syyemd-networkd
при старте пушит свои хотелки в systemd-resolved. но никак не наоброт. когда 
sytemd-resolved стартует он ни к кому необращается на тему своих пер-интерфейс
настроек ни к sysytemd-networkd ни к NetworkManager. он единственное что читает
это свои файлы из папки /run/ssytemd/resolve/... и все. поэтому если какая то
программа хочет просунуь свои днс настрйоки на systemd-resolved она должна сама 
это сделаь. запушить их либо через d-bus либо через resolvectl . 





Ссылки:
IFUPDOWN(/etc/network/interfaces)
https://www.debian.org/doc/manuals/debian-reference/ch05.en.html
https://unix.stackexchange.com/questions/71062/ubuntu-how-to-configure-dns-servers-in-etc-network-interfaces-correctly-for-re



LINK-LOCAL
https://www.linux.com/news/zero-configuration-networking-linux/
https://en.wikipedia.org/wiki/Zero-configuration_networking
https://en.wikipedia.org/wiki/Zero-configuration_networking
https://www.iana.org/assignments/iana-ipv4-special-registry/iana-ipv4-special-registry.xhtml
https://www.rfc-editor.org/info/rfc3927
https://serverfault.com/questions/118324/what-is-a-link-local-address
https://en.wikipedia.org/wiki/Link-local_address#cite_note-rfc3927-1
https://serverfault.com/questions/63014/ip-address-scope-parameter/1035326#1035326



mDNS и мультикаст
https://datatracker.ietf.org/doc/html/rfc6762#appendix-B
https://askubuntu.com/questions/972630/what-is-mdns-is-it-possible-to-make-mdns-query-without-mdns-service-running/1526875#1526875
https://wlog.viltstigen.se/articles/2021/05/02/mdns-for-linux/
https://stackoverflow.com/questions/68540755/can-linux-mdns-client-be-pure-client
https://superuser.com/questions/1453910/linux-command-to-get-mdns-service-discovery-and-to-get-its-ip-address
https://unix.stackexchange.com/questions/745609/ss-or-ip-equivalent-to-netstat-gn-to-show-multicast-memberships
https://stackoverflow.com/questions/63381026/ss-and-netstat-show-different-multicast-groups
https://unix.stackexchange.com/questions/25872/how-can-i-know-if-ip-multicast-is-enabled
https://unix.stackexchange.com/questions/25872/how-can-i-know-if-ip-multicast-is-enabled
https://stackoverflow.com/questions/15892675/listing-multicast-sockets
https://www.auvik.com/franklyit/blog/multicast-networking/
https://support.biamp.com/General/Networking/Multicast_traffic_and_IGMP
https://www.firewall.cx/networking/network-fundamentals/network-multicast.html
https://superuser.com/questions/306065/what-is-icmp-broadcast-good-for
https://docs.datadoghq.com/security/default_rules/xccdf-org-ssgproject-content-rule-sysctl-net-ipv4-icmp-echo-ignore-broadcasts/
https://0x657573.wordpress.com/2010/11/22/localhost-does-not-response-to-ping-to-multicast-address-224-0-0-1/
https://stackoverflow.com/questions/21574463/no-reply-on-ping-224-0-0-1
https://access.redhat.com/solutions/110013
https://www.poweradmin.com/blog/how-to-configure-a-multicast-linux-network/
https://jameshfisher.com/2018/03/04/create-udp-connection-with-netcat/
https://unix.stackexchange.com/questions/459991/how-to-configure-systemd-resolved-for-mdns-multicast-dns-on-local-network
https://en.wikipedia.org/wiki/Multicast_DNS
https://www.networkacademy.io/ccie-enterprise/multicast/introducing-multicast
https://networklessons.com/multicast/multicast-ip-address-to-mac-address-mapping
https://serverfault.com/questions/881644/do-all-ethernet-switches-support-multicast
https://www.poweradmin.com/blog/how-to-configure-a-multicast-linux-network/
https://www.pynetlabs.com/difference-between-broadcast-and-multicast/#:~:text=The%20main%20difference%20between%20broadcast,it%20as%20the%20intended%20receivers.
https://0pointer.de/lennart/projects/nss-mdns/
https://wiki.archlinux.org/title/Avahi
https://unix.stackexchange.com/questions/404917/what-are-link-scopes-in-systemd-resolved/783639#783639


ICMP
https://en.wikipedia.org/wiki/Traceroute#:~:text=On%20Unix%2Dlike%20operating%20systems,to%20use%20ICMP%20Echo%20Request
https://www.ibm.com/docs/en/zos-basic-skills?topic=nll3-internet-control-message-protocol-icmp-other-layer-3-protocols
https://networklessons.com/cisco/ccie-routing-switching-written/icmp-internet-control-message-protocol#:~:text=ICMP%20messages%20are%20encapsulated%20in,considered%20a%20layer%203%20protocol.&text=The%20first%20byte%20specifies%20the%20type%20of%20ICMP%20message.
https://www.cloudflare.com/learning/ddos/glossary/internet-control-message-protocol-icmp/
https://datatracker.ietf.org/doc/html/rfc792


LLMNR
https://datatracker.ietf.org/doc/html/rfc4795
https://www.eiman.tv/blog/posts/lannames/#the-ietf-debacle
https://learn.microsoft.com/en-us/previous-versions//bb878128(v=technet.10)?redirectedfrom=MSDN
https://en.wikipedia.org/wiki/Link-Local_Multicast_Name_Resolution
