| local-address
| local 
| global
| host
| multicast



все началось с того что увидел в свойтвах сет карты а точнее  в свойствах
IP адреса стоит свойство global
и я всопнмил эту эпопею про global , link-local, host свойства в свойствах 
сетевой карты. что эта за хрень?

во первых это не свойство сетевой карты это свойства IP адреса. это его 
характеристика.

в строону - что такое unicast адрес - это значит что этот адрес обозначает
ОДИН хост, (или один сетевой интерфейс). как следствие если ктото пошлет
кусок информации НА этот юникаст адрес - то получаетелем будет ОДИН комп.
в конрраст мультикаст адрес или броадкаст адрес - его имеет сразу много компов. 
тоесть куча компов и все юмеют этот один и тот же адрес. и если ктото пошлет
на этот адрес то информация прилетит на ОГРОМНУЮ ТУЧУ АДРЕСОВ. например 
сеть 172.16.10.10\24 у нее бродакаст адрес это 172.16.10.255 как бы незримо
каждый комп этой сети имеет в добавок к своему юникаст адресу еще и этот броадкаст
адрес. поэтому если ктото шлет пакет на 172.16.10.255 то этот пакет получат 
все участники сети. потому каждый из них имеет этот адрес. 
итак что такое юникаст адрес стало пболее понятно.

как работает  передача пакета в котором dst_ip=юникаст адрес. 

ipv4      = 4 байта =  8 hex букв = aa:bb:cc:dd
mac адрес = 6 байт  = 12 hex букв = aa:bb:cc:dd:ee:ff

легко увидеть вот что. ровно сколько байт в хрени ровно столько секций 
разделенных символом ":", в ipv4 у нас 4 байта и 4 секции. в мак адресе 6 байт
и 6 секций.

и тут тоже хитрый момент - при передаче пакета в локальной эзернет сети у нас
участвует и IP и MAC адрес. я бы даже сказал что ip адрес почти что не участвует.
а участвует тольк MAC адрес. тоесть это двух слойная система. а изначально дело вот
в чем. у нас есть инфомрация она такова что предназначена для отдельного компа.
назовем ее юникаст информация. а есть инфомрация которая предназначена для сразу кучи
компов. например я хочу вещать радио в локальной сети. в этом радио нет ничего что 
было бы предназнаено конкрентному компу. эта информция такова что она предназначена
сразу для кучу компов. и вот я беру пакет сетевой. в него сую кусок радиопрограммы.
теперь мне надо передать этот пакет сразу на кучу компов. можно пойти по пути
юникаста. это значит что нужно будет на моем компе сгенерировать пакет и отправить
его через сетевую карту в сеть через провод на свич. а свич его переправить первому
получателю. а если в сети 100 получаателей то моему компу нужно будет сгенерировать 
100 одинаковых пакетов по содержимому просто у кжадого пакета будет разный dest_IP
и dest_mac. полуается неклево. надо както так изьебнуться чтобы я со своего компа
послал 1 пакет. и он прилетев на свич был там размножен(отклонирован) и передан 
сразу всем 100 получателям. щас я примерно раскажу как это работает. на саомм деле
система достаточно заморочная. 
как работает отправка и прием юникаст трафика в локальной сети: мой комп А некоторым образом
узнает MAC адрес другого компа Б и также мой комп-А узнает IP-Б адрес того другого компа-Б
тогда мой комп плюет через сет карту в провода пакет в котором стоит
    dst_IP=IP-Б dst_MAC=MAC-Б   ( также у этого пакета есть src_IP=IP-A src_MAC=MAC-A
но это щас неважно)

этот пакет прилетает в свич. свич умеет впакете видеть только MAC адреса. он с ними 
работает. этот как письмо в деревянном ящике. на деервянном ящике написаны MAC адреса.
а внутри ящика лежит письмо на котором написаны IP адреса. свич раотает только с надпи
сями на ящике. так вот что касается свича он когда видит на пакете src_MAC именно
сорс мак то он делает в своей таблице пометку что через такой то порт eth/10 к нему
прилетел MAC-A . тоесть свич теперь знает что за портом eth/10 сидит комп с MAC=MAC-A
это значит что если котот потом пришлет пакет который имеет dst_MAC=MAC-A то свич
сразу знает в какой порт надо плеавть этот пакет.  
так вот прилетел наш пакет. свич смотритв таблицу за каким портом сидит комп
котоырй имеет MAC=dst_MAC=MAC-Б положим свич имеет такой порт. и он направляет этот пакет
в тот порт. если у свича нет в таблице порта с MAC-Б то клонирует пакет и плюет его
во все свои порты. положим так и произошло. 
за каждым портом сидит комп со своей сет картой. каждая сет карта
принимает этот пакет и сравнивает dst_MAC со своим MAC если они не совпадают то карта
(или драйвер сет карты то бишь кусок кода ядра) отбарсывет этот пакет. ибо он недля нее
предназначен. но одна карта этот пакет примет. ровно та карта у которой MAC=MAC-Б
итак пакет влетает в ядро. а там еше теперь идет проверка чтобы dst_IP в пакете был
равен IP-Б компа точнее некомпа а сет карты в который пакет влетел. если он совадает
то ядро продолжает обработку этого пакета. значит в этой юникаст передаче участвовал
юникаст MAC тоесть такой MAC реально есть в сети. им обладает какая то карточка в сети.
и участовал юникаст IP адрес. какойто из компво реаьно имеет этот IP.

теперь про броадкаст передачу. она строится на броадкаст IP и броадкаст MAC.
карточка на компе когда мы его включили уже имеет юникаст MAC адрес. Юникаст MAC 
означает что этот мак адрес в сети по крайней мере в локальной он уникален. он однозначно
идентифицирует именно нашу карточку. этот как паспорт. один пасопорт одно лицо. 

	link/ether 02:42:72:68:0e:62

если котоо в сети пошлет на dst_MAC=02:42:72:68:0e:62 то придет именно на нашу карточку.
хотя как я уже сказал свич может направить во все свои дырки пакет и он прилетит 
на все карточки в сети. но все остальные обязаны отбросить этот пакет ибо они увидят
что dst_MAC не совпадает с ихним. юникаст мак адрес не гарантирует что если мы пошлем
пакет с ним то он прилетит только на одну карточку адресат. но всем "порядочным" карточкам
будет точно понятно что пакет не предназначен для них , он предназначен для той самой
другой карточки и они вобще то обязаны его отбросить. это похоже на конверь с письмом
и адресом. и его размножили и засунули в подьезде в каждый ящик. каджоый порядочный 
человек получив такое письмо четко понимает что оно непредназначено ему и он типа 
его должен отбросить. юникаст мак означает что где то в сети точно есть карточка с таким
маком. и других карточек с таким маком нет. но сменая вещь что при этом пакет с таким
dst_MAC может запросто долететь до карточек не стаикм маком и они могут этот пакет
запросто прочитать (если карту влкючить в промискуус моде), хотя он для них не предна
значен. так вот есть еще броадкаст MAC. он равен ff:ff:ff:ff:ff:ff его не имеет ни одна
карточка в сети формально. но по факту его "как бы " имеет каждая карточка  в сети.
поэтому если я создам пакет с dst_MAC=ff:ff:ff:ff:ff:ff то во первых получив такой
пакет свич переправит  его во все порты. дальше его получит каждая карточка сети. 
и увидев такой dst_MAC они все его примут. потому что такой МАC он как бы обозначает
"это пакет для всех карточек". получаетс удобно - я со своего компа отправил 1 пакет
а в итоге его получили все 200 компов в сети. классс!  возникает вопрос если так 
классно работает передача пакетов в сети на основе MAC адресов и свичей нахрен
на сдалось еще вводить TCP\IP ?  у нас каждый комп в сети имеет свой юникаст MAC адрес.
я могу туда прямо слать. а если надо послать всем то есть броадкаст MAC адрес. 
все классно. адресация есть. свич есть . карты есть. все - передавай данные и отлично.
но тут случается очень неприятный момент - до этого моменты мы гвоорили про сеть
в которой технология передачи данных была одна и таже для всех участников. тоесть
мы все имели одинаковые сет карточки. и передавали данные по однму стадарту
между ними. условно говоря - мы все сидели на эзернет карточках.  я это сравню
вот с чем - я имею ящик на котором адрес написан на французском. и этот ящик
передается между почтами говоряими на французском. ну или говорю - все участники
сети имеют эзернет карточки. это значит что все карточки должны иметь адрес 
подчиняющийся одному закону и пеередача данных между двумя любыими картами
должна идти по одному закону. у нас неможет такоо быть что 5 карт имеют мак адрес
из 6-ти байт а одна карта имеет адрес мак из 7-ми байт. нужна юниформность. чтобы 
карты имели мак адрес подчинайющися одному закону - размер 6 байт. тогда используя
пакет одного размера можно его послать любому участнику. и свич котрый умет обрабатьывать
мак адреса размером 6 байт полученный пакет сможет отправить люому участнику. 
так вот у нас появляется еще одна группа компов и карт на них которые имеют  карты
которые работают по другой технологии. для простоты пусть у них мак адрес сотавляет
7 байт. тогда получается они друг с другом могут общаться  а с нашим сегментом
никак! и тут появвляется устройство сопряжения - роутер. у него часть карточек
пусть даже одна такая же как в нашем сгементе имеет 6 байт. а вторая карточка имеет
7 байт как в том сегменте , тоггда если роутер получит пакет от карты в нашей сети
то он может с него содрать  6-ти байтовый мак адрес. вычленит дата данные из пакета
налепить на пакет 7-ми байтовый адрес и переслать какотому копу в той сети. круто!
получеается 6-ти байтовый мак адрес  он подходит для того чтобы обмениваться
пакетами в нашем сегменте сети. а 7-ми байтовый мак адрес подходит чтобы обмениваться
пакетами в том сегменте сети. тоесть если я хочу переслать пакет от моего компа
другому компу в моем сегменте сети то достаточно использовать мак адрес. когда
карточка получает пакет в котором указан dst_mac и src_mac то мой комп понимает что 
этот пакет был послан от какойто такойже типовой карточки сидящей в моем сегменте сети. 
какая то карточка из моего сегмента сети прислала мне пакет. вот что означает 
пакет с мак адресацией. но если я хочу обмениваться пакетами к компами из той сети 
то можно конено как сделать. я могу както узнать какой 7-ми байтовый мак адрес
у компа из той сети. и составить пакет в котором будет два мак адреса. один это 
6-ти байтовый мак адрес роутера. и внутри 7-ми байтовый мак адрес компа в той сети.
роутер получит. посмотрит. перебьет мак адреса и переправит. но сделали по другому. 
взяли и над этой системой мак адресации сверху добавили новую систему адресации
из 4-ех байт которая одинаковая что для моего сегмента что для того сегмента. 
тоесть я щас сутрирую но скажем такая интерпретация. у меня есть комп и у него есть
сетевая карта. сетевая карта имеет MAC адрес. а комп сидящий на этой карте имеет IP 
адрес. ну и получаетс что сегменты сетей бывают разные. в одной мак адрес может
иметь 6 байт  в другой 7 байт в третьей 10 байт. а вот компы сидящие на этих картах 
имеют одинаковый формат ip адреса 4 байта. тогда получается если я в своем сегменте на 
своем компе хочу послать пакет компу в другом сегемнте то я узнаю его IP адрес. 
адальше делаю вот как я составляют вот такой пакет

       dst_IP=IP-Б  dst_MAC=MAC_g

в этом пакете IP адрес назначения того компа в другом сегменте.  а мак адрес
назначения роутера в моем сегменте.  я плююю пакет в сеть. он улетает на свич.
свич либо знает за каким портом сидит карточка с MAC_g либо он плюет пакет во все
порты. в итоге за каким то портом сидит комп с MAC_g он принимает этот пакет.
остальные компы в нашем сегменте должны отбросить этот пакет. роуте всасывает 
пакет в себя. если свич умеет понимать только мак адреса то роутер умеет понимать
уже и IP адреса. роутер видит что хотя мак адрес был предназначен для роутера
но ip адрес предназначен недля руотера а для друого компа. роутер смотрит в своей 
роуте  таблице маршрутизации что комп с таиким IP адресом сидит за портом номер 2 который
ведет в другой сегмент сети в котором мак адреса имеют 7 байт. роутер сдирает с пакета
оболочку касающуюся мак адресов из исходного сегмента и нахлобучивает на пакет 
мак адреса нового сегмента. он заменяет MAC_g на MAC_f компа в том сегменте


dst_IP=IP-Б  dst_MAC=MAC_f

и плючет этот пакет через свой порт ведущий в тот сегмент.
а если на моем роутере нет инфо про то какой мак адрес имеет комп с dst_IP=IP-Б
то роутер пошлет мой пакет на другой роутер где как считает мой роутер такая 
информация может быть. таким макаром мне на моем компе надо знать только мак адрес
роутера моего сегмента и IP адрес удаленного компа который сидит хрен знает в каком
сегменте. а там уже прыгая с роутера на роутер с сегмента в сегмент пакет както уже 
долетит. это похоже на то что чтобы отправит пистмо мне надо напиать конечный адрес
и знать адрес ближайшей почты и дойти туда и кинуть письмо. а они пусть там 
сами разбиараются каким дорогами самолетами параходами его доставлять какими 
заграницами.

получается ради доставки пакетов между сегментами был доьавлен доп слой адресациии
из 4 байт. IP адресация. я бы сказал просто - доп слой адресации из 4 байт.
кстати 6 байт в мак адресе - это в сет карточках на основе эзернет. в других техно
логиях свои стандарты длинны мак адреса. в стандартах типа point-to-point я не
знаю есть ли там мак адрес или он на уровне одного бита. потому что есть только 
приемщик и передатчик. 

окей. вернемся обратно к компам моего сегмента. внутри моего сегмента нам вроде как
IP адреса нахрен ненужны. мы отлично видим друг друга напрямую через mac адреса
а свич это невидимое средство  содениения моей сет карточки с картой моего
соседа. свич не имеет мак адреса. он типа как провод работает. но пошли по пути
унификации - неважно в нашем сегменте сидит комп на который я стучу или в другом
сегменте - везде будет использовать эти доп 4 байта ip адресации. 
получается если я шлю на комп в моем сегменте то мне надо в пакете указать не
только мак адрес соседа но и его IP. тогда комп который примет мой пакет смотрит
что и мак совпадает с егоным и IP совпадает. получается при предаче инфо в одном
сегмента роутер не участвует. участвует только две карты и свич. и все.
дальше сделали вот что - мы уже имеем броадкаст мак адрес MAC_br=ff:ff:ff:ff:ff:ff который 
дает то что если пакет с 
 
     dst_MAC=MAC_br

попадает в свич то свичу это дает сигнал что такой пакет нужно плюнуть во все свои порты.
это приводит к тому что такой пакет поступает ко всем компам нашего сегмента. и 
компы принимая такаой пакет и видя такой dst_MAC они понимают что данный пакет является
как бы групповым. что он был послан на данный комп не в рамках индивидуальной передачи
а в рамках "групповой" передачи. и они его принимают. тоесть такой мак дает то что свич
его перешлет в каждый порт и таким макаром этот пакет увидит каждый комп сегмента. 
ну и компы полуив такой пакет они понимают что он к ним прилетел не потому что свич не
знал в какой порт плюнуть в рамках когда в свич прилетел пакет с юникаст мак
а он незнал за каким портом сидит карта с таким мак а потому что некий комп хотел 
чтобы этот пакет реально увидел каждый комп в сегменте. вот что дает броадкаст мак.
ну и вот если броадкаст мак это средтство заставит свич доставить этот пакет до каждого
компа в сети а каждый комп помимом мак еще и имеет и IP адрес то наверное логично
при использовании броадккаст мака исипользовать и некий броадкаст IP адрес в этом 
пакете. что еще раз обьяснит компу что прилетевший пакет предназначен для этого компа
но не лично а в рамках "групповой" рассылки.
поэтому если у нас есть сегмент сети то помимо броадкаст мак еще есть и броадкаст IP.
если комп получает пакет с броадкаст мак и броадкаст IP он понимает что пакет 
предназанчен ему но не врамках персноальной адресации а  в рамках групповой рассылки.
также комп понимает что пакет послал какйото комп из этого же сегмента сети а не 
комп из другого сегмента сети. полуается если я хочу слать радио всем участникам моего 
сегмента сети то мне надо составлять такой пакет

   dst_IP=IP-br       dst_MAC=MAC-br

и получается что я шлю один такой пакет но он за счет свича клонируется и прилетает 
на все компы сети. ну круто. круто потому что если бы не было броадкаст мак адреса.
если бы свич не понимал что это такое то мне вместо одного пакета пришлось бы 
генерировать 100 пакетов чтобы каждый комп в моей сети получил один пакет моего радио.
это похоже на то что учитель чтобы обьяснить урок говорит слово и его слышит не весь
класс а то что учителлю нужно подходить к кждому ученику и рассказыать материал 
индиивидуально. тоесть так мы имеем что 30 учеников за один урок учитель материал 
передаст . а так нужно учитлю 30 уроков провестичтобы каждому индивиудулаьно это донести.
тоесть это была бы большая нагрузка на исходный комп.
как выглядит пакет при броадкаст передаче

   dst_IP=IP-br       dst_MAC=MAC-br

мы указываем IP адрес которым ни один комп в сегменте не обладает. или наоборот можно
скзаат что  им обладает кадый комп в сенементе. и мак адрес которым ни одна карта
в сегменте необладает или наорборот что ей обладает каждая карта в сегменте. 
и также пакет имеет

   src_IP=IP-моего компа       src_MAC=MAC-моего компа


так как обратный адрес в пакете указывает юникаст IP и юникаст MAC то все компы
в сети получил такой пакет могут ответить моему компу без проблем. они составят пакет 
вида 

   dst_IP=IP-моего компа       dst_MAC=MAC-моего компа

и мой комп без проблем получит такой пакет. 


теперь вопрос как сделат так чтобы слать мое радио не на все компы моего сегмента сети 
а на некторые но чтобы при этом  мой комп опять же слал всего 1 пакет а он при этом 
волшебным образом клонировался и долетал до кучи компов не не всех. и тут приходит
на помощь мультикаст МАК адрес. есть свичи которое более интеллектуальные и понимают что 
такое мультикаст трафик а есть которые нет. но! даже самый тупой свич для него 
броадкастный мак адрес является броадкастным не вслучае если он 
равен 
   ff:ff:ff:ff:ff:ff

а в случае если у dst_MAC установлен младший бит старшего байта!
тоесть берем самый левый байт у мак адреса

   ff:ff:ff:ff:ff:ff
   /|\
   |||
   |||

и вот самое главное чтобы у него был устанолвен вот этот бит

 00000001

 тоесть вот такой mac адрес с точки зрения любого свича является 
 броадкастным

 xxxxxxx1: xxxxxxxxxxxxxxxxxxxxxxxxx ...

там где x неважно что стоит. важно чтобы стояло 1 там где оно стоит.

так вот с точки зрения любого свича мак адреса делятся на две группы - юникстные
маки и броадкастные. если мак юникастный то свич ищет его в таблице и если находит
то шлет этот пакет тольк в один порт. а если мак адрес броадкастный то он пакет по 
любому шлет во все порты. 
так вот есть еще мультикастные мак адреса. они тоже выглядят как броадкастные тоесть
у них выставлен в 1 вот этот бит. но у них в мак адресе ест и другие хрени. если 
свич тупой и непонимает что такое мультикастный мак то для него такой мак просто
напросто броадкастный. поэтому пакет с dst_MAC=MAC_m(мультикаст) прилетев на такой свич
будет по любому доставлен все компам во всех портах. но если  свич раззбирается в маках
покруче то он поймет что это непросто броадкастный мак а это мультикастный мак
и он доставит этот пакет не во все порты а только в те за которыми сидят компы 
входящие в данную мультикастную группу. я не знаю как но компы могут сигнализировать
свичу о том что они входят в такую то мультикаст группу. я щас к этому вернусь

поэтому все юникаст мак адреса имеют этот бит НЕУСТАНОЛВЕННЫМ а все
броадкаст и мультикаст мак адреса имеют этот бит устанолвенным.

поэтому в мультикаст мак адресе этот бит устанолвен и в худшем случае если между моим
компом и компами моего сегмента стоит простецкий свич которые не понимает что такое
мультикаст - он мой пакет пошлет во все порты как броадкаст.

компы которые получат пакет от меня они уже конечно должны понимать что такое 
мультикаст мак адрес. они должны понимать что это не просто броадкаст мак адрес.
хотя первую часть задачи мы уже решили - мы добились чтобы пакет прорвался через 
свич в худшем случае на все порты. и значит был доставлен до всех компов в сегменте.

также я хочу сказать что мультикаст трафик он как я понял всегда UDP
вчем кстати прикол UDP . если мы с нашего хоста послали такой пакет в сеть то дальше
мы понятия не имеем долетел он или нет. если мы пошлем tcp пакет то оттуда обязателно
прилетит ответ подрверждение. если мы послали udp пакет в ответ нихрена не прилетит. 
и гадай толи долетел толи недолетел. 

тут я опять возвращаюсь к вопросу - как на свиче настроить мультикаст группу 
портов. чтоб получив наш пакет он его переслылал не на все порты а толко на часть
туда куда надо. насколько я понял ( а читать надо гору) что есть доп протокол L3 уровня
IGMP. L3 это значит что в его пакетах уже присутсвтуют не мак адреса а чтото поглубже.
тоесть железка должна в пакете понимать нетолько мак адреса а еще и кое что поглубже.
так вот как я понял есть свичи с поддержкой IGMP. и тогда шарманка примерно выглядит
так - хост со своей карты шлет IGMP пакет в котором указывает как я понимаю к какой
мультикаст группе он хочет присоединиться то бишь как я понимаю хост указывает 
мультикастный IP адрес который будет содеражться в пакете который он хочет получать. 
и тогда свич с поддержкой IGMP получает такую "заявку " от компа и включает у себя 
порт с которого прилеела завявка в группу портов в которую он пересылает мультикаст
пакет с таким то мультикастным IP адресом. также в пакете "заявке" от компа содержится
TTL=1 и это дает то что как я понял этот пакет "заявка" от компа он влетает  в свич
и внутри него же и умирает. тоест никуда дальше она не летит. таким образом другие
компы в сегменте не видят этот пакет. как конкнено выглядят эти IGMP пакеты завяки
я не знаю и думаю выяснять не буду. если же свич не поддерживает IGMP то как я уже
сказал если в свич влетает мультикаст пакет то для него он выглядит как броадкаст
пакет. и он его пиханет во все порты. поэтому чтобы сеть классно работала с мультикастом
нужны свичи с IGMP поддержкой.если такое есть. то комп может поалсть на свич IGMP 
пакет и свич добавиит порт за которым сидит комп в мультикаст  группу тоесть он 
будет и этому компу слать мулььтикаст пакет. а порты с которых не прилетел такой 
запрос свич на них мультикаст пкет не шлет. заявка IGMP она от компа влетает в свич 
только он ее видит. он ее убивает и в другие порты он ее непереслывает. тоесть
эту завявку видит только свич. 

и вот  я только что упомянул такой момент что мультикаст пакет он в себя включает
не только мультикаст мак адрес (о нем щас поговрим) но и мультикаст IP адрес. тоесть 
опятже система построена нетолько на мак адресах но и на IP адресах тоже.
получается что на компе линукс должен сетевой карте назначить мультикаст IP адрес
и какую то службу посадить слушать на этот IP адресе еще и какойто порт (протокол UDP)
получется как я понимаю мультикаст пакет должен иметь :

    мультикаст МАC
    мультиксст IP
    протокол UDP
    порт udp

и на компе должны быть служба которая сидит и слушает протокол UDP, мультикаст IP адрес
и порт udp. напрмер

    systemd-resolved слушает сокет IP=224.0.0.251 UDP:5353  
где 224.0.0.251 это мультикастный адрес. 

и поэтому если в комп прилетит пакет с аткими параметрами то линукс его воспримет.
а если в комп влетит пакет dst_IP=224.0.0.251 UDP:5353 а на компе такой сокет 
никто не слушает то этот мультикаст пакет просто будет проигнорирован. тоесть я хочу
сказать что мультикаст трафик мультикаст пакет в себя включает не только мультикаст
мас адрес, не только мультикаст IP адрес. но еше и UDP порт. и мало доставить такой
пакет от компа отправителя через свич на какйото комп. нужно чтобы на этом компе
какая то служба слушала такой сокет. если на компе нет службы которая сидит и ждет 
этот пакет сидя на сокете то пакет просто буде проигнорирован!

итак мультикаст пакет имеет мултикаст мак адрес. внутри мультикаст IP адрес
внутри протокол UDP +порт

как на примере выглядит такой пакет

dst:
  mac  01:00:5e:00:00:fb
  IP   224.0.0.251
  UDP порт 5353

src: 
  mac  ba:ec:24:5c:80:3a
  ip   172.16.10.12
  UDP порт 5353


значит смотрим на dst mac , у него в первом байте 01 = 0000 0001 мы имеем выставленный младщий
бит. тоесть это точно мас который отноится как минимум к классу броадкаст
dst ip относится к классу мультикаст (об этом классе ип позже скажу)
udp порт 5353. раз udp то такой пакет не требует ответа. хост его получает и в ответ 
может молчать. с таким маком свич этот пакет разошлет либо во все порты либо в
часть портов где поработал IGMP.
при этом у нас src mac это юникаст мак потому что ba = 10111010 видно что младший бит
равен 0. ip тоже юникастовый. и раз в dst стоит udp то и в src стоит udp

зачит как я уже сказа с таким dst mac этот пакет прилетит на все нужные компы. 
если комп разбиаретс что такое мультикаст то он этот пакет примет.  потому что понятно 
что мак 01:00:5e:00:00:fb его не будет имть ни один комп. потому что это мультикаст 
мак а не юникаст мак. но если комп понимает что такое мулитикаст макми то он его примет.
далее dst ip = 224.0.0.251, UDP порт 5353 , если на компе стоит служба которая слушает 
такой сокет то комп этот пакет направит в эту службу иначе он его грохнет. если
комп примет этот пакет то он знает как отправить ответ компу который послал этот пакет
потому что мы знаем юникаст мак и юникаст IP отправителя. проблем нет. мы также 
знаем src порт. единственное что если прогамма на компе отправителя уже закрылась 
то на компе отправителя может не быть службы которая слушает сокет 172.16.10.12 udp порт 5353
данный мульитикаст пакет относится к рассылке вида one-to many поэтому скажем 
обратный пакет будет иметь вид


dst: 
  mac  ba:ec:24:5c:80:3a
  ip   172.16.10.12
  UDP порт 5353

src:
  mac  ba:ec:24:5c:80:3b
  ip   172.16.10.11
  UDP порт 5353

так вот свич в свою таблицу заносит порты и маки которые он берет из src mac пакета
поэтому при пролете пакета туда мультикастовго и ответа юникастового в свиче 
будет вот такая инфо



  mac  ba:ec:24:5c:80:3a   свич порт 01
  mac  ba:ec:24:5c:80:3b   свич порт 02

тоесть  у него в таблице попадут толкко юникастовые маки. при мультикаст рассылке
мултикаст мак всегда стоит в dst части пакета и никогда в src части пакета



немножко отойду в сторону 
но тоже важная вещь.
как проверить что до udp порта реально с другого компа долетает инфо.
на компе который destination (dest) мы запускаем tcpdump


   (dst)     # tcpdump -n 'udp port 5353' -i enp0s3 -e

на компе который source(src) мы запускаем 

   (src)     # nc -zv -u 172.16.10.11 5353
то что будет здесь написано в вывод неважно. потому что внезависимости долетел пакет
или нет. тут всегда написано что все отлично. 
идем на dst комп и смотриим словил ли что tcpdummp



17:50:17.782377 ba:ec:24:5c:80:3a > ba:ec:24:5c:80:3f, ethertype IPv4 (0x0800), length 43: 172.16.10.12.59991 > 172.16.10.11.5353: domain [length 1 < 12] (invalid)

17:50:17.784078 ba:ec:24:5c:80:3a > ba:ec:24:5c:80:3f, ethertype IPv4 (0x0800), length 43: 172.16.10.12.59991 > 172.16.10.11.5353: domain [length 1 < 12] (invalid)

в данном случае словил. значит реально инфо долетает. значит порт udp 5353 реально 
открыт. 

ключ -e в tcpdump он дает то что нам показывают макс. тоест показывают src mac и dst mac
что круто.

по такой технолггии монжно проверить открыт ли UDP порт на удаленном компе 
или долетате ли до него инфо незакрыт ли файрволл. правда для этого нужен доступ
на dst комп

итак при мультикаст рассылке у нас мультикаст мак дает то что при пролете через свич
этот свич его в худшем случае склонирует во все свои порты. а влучшем случае только 
за те порты из которых прилетели igmp заявки и свич понимает igmp. вот что дает мультткиаст
мак для чего он нужен. мультикаст ip дает что что отправитель недолжен знать ip адреса
компов которым он шлет. он ставит один мультикаст ip и пакет долетев до компов 
и когда он в них засосался сообщает своим ip в частности что это мультикаст пакет. то 
есть групповой. поскольку мультикастов может быть много то этот конкрретный мультикаст ip
позволяет компу понять пришел ли нужный мультикаст пакет или это мультикаст пакет 
от другой групповой рассылки. вот что дает мультикаст ip
тость еще раз он позволяет компу отправителю незнать ip клиентво а поставить некий фиктивный
ip. а коммпам получаелям понять что это групповая рассылка и понять эта рассылка которая
им нужна или другая. далее посолльку пакет снаружи выглядит как пакет формата ip
а я как понял пакет формата ip эта всегда тлько транспортная оболочка для какогото 
пакета внутри. тоесть не бывает просто пакета ip и чтобы внутри небыло пакета другого
формата. такого небывает. нельзя отправит просто ip пакет а внутри пусто как я понимаю.
самый привычный пакет это ip а внутри icmp. ICMP лежит внутри IP. icmp ксатти
имеет внутри себя секции 
  -  тип icmp пакета (например тип 0 это эхо реквест а 8 это эхо  реплай) 
  -  код ( непонятно что этот код значит)
  -  контрольная сумма (нам это неинтересно)
  -  последнее поле его контент зависит от типа icmp тоесть от первого поля
     я так понимаю в этом поле кроется самый уже контент полезный

кстати traceroute может работаь как основе UDP так и на основе icmp
если на оснвое icmp то работает это так. 
мы пишем 
        $ traceroute -M icmp -n 8.8.8.8  -q1 -m 2
тогда выстреливается серия ip+icmp пакетов таких что 
у них у всех одинаковый 
     src_IP=ip компа dst_ip=8.8.8.8 
но разный TTL тоест первый пакет будет иметь

     src_IP=ip компа dst_ip=8.8.8.8  TTL=1

второй пакет будет иметь

     src_IP=ip компа dst_ip=8.8.8.8  TTL=2


ключ -m 2 означает какой максимльный TTL будет иметь последний пакет

ключ -q1 означает сколько пакетов с одним и темже TTL надо шмалять. 
в данном случае всего один. 

а далее происходт вот что. берем первый пакет 

     src_IP=ip компа dst_ip=8.8.8.8  TTL=1

он начинает прыгать по компам (по роутерам) , при проходждении каждого роутера этот
роутер у этого пакета уменьшает TTL на 1 и если TTl стал равен 0 то ротуер должен этот
пакет убить. а обратно отправить ip+icmp пакет с icmp типа type 11 (первое поле) "time exceeded" и еще этот роутер должен по идее в этом icmp type 11должен  вставить инфо более
детальную по этому поводу. насколько я понял при TTL=0 абсолютно все роутеры грохают
такой пакет но далеко не все посылают обратно icmp type 11. вообще если пакета TTL стал 0
то это какбы значит что он слишком долго шатался по роутерам но не достиг цели. и поэтому
чтобы он бесконечно не шатался по инету его уничтожают. соовтевтенно когда такой роутер
шлет обратно icmp type 11 он же его вкладывает в IP пакет. а занчит у этого пакета будет
dst_ip и src_ip.  dst_ip будет нашего компа а src_ip будет того рутера который грохнул
наш пакет. таким маккаром запуская пакеты с разным TTL можно узнать по каким рутером
он проходит пока он идет до цели 8.8.8.8
так вот трейсроут запускает целую груду однотипнвых пакетов 

     src_IP=ip компа dst_ip=8.8.8.8  TTL=N

но с разным TTL. и в ответ ждет столько же ответов icmp type 11. потом он в них парсит 
src_ip и нам его рисует. А ЕСЛИ НА КАКОЙТО ПОСЛАННЫЙ ПАКЕТ ОН НЕ ПОЛУЧАЕТ ОТВЕТА ТО 
ОН В ТАБЛИЦЕ В ЭТОМ МЕСТЕ РИСУЕТ "*" . это значит что тут рутер который принял пакет
с этим TTL. он пакет убил а ответ сука не прислал. вот что значит * в таблице traceroute


вот пример

# traceroute -M icmp -n 8.8.8.8  -q1 -m 2
traceroute to 8.8.8.8 (8.8.8.8), 2 hops max, 60 byte packets
 1  172.16.10.1  0.817 ms
 2  172.16.50.1  131.336 ms


вот его tcpdump
вот он заупускает пакет  172.16.10.12 > 8.8.8.8  c TTL=1

 19:27:15.568215 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 1, id 12782, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 1, length 40


вот еще он запускает такой же с TTL=2

19:27:15.568253 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 2, id 12783, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 2, length 40


вот он получает ответ на первый пакет TTL=1
 а именно получает  ICMP тип time exceeded от компа 172.16.10.1

19:27:15.568879 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 64, id 42860, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.10.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12782, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 1, length 40


вот он получает ответ на первый пакет TTL=2
 а именно получает  ICMP тип time exceeded от компа 172.16.50.1


19:27:15.693490 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 63, id 56833, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.50.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12783, offset 0, flags [none], proto ICMP (1), length 60)
    172.16.10.12 > 8.8.8.8: ICMP echo request, id 5589, seq 2, length 40



и вот что нам в итоге выводит traceroute

traceroute to 8.8.8.8 (8.8.8.8), 2 hops max, 60 byte packets
 1  172.16.10.1  0.817 ms
 2  172.16.50.1  131.336 ms


если я запушу с макс TTL=3

# traceroute -M icmp -n 8.8.8.8  -q1 -m 3
traceroute to 8.8.8.8 (8.8.8.8), 3 hops max, 60 byte packets
 1  172.16.10.1  0.891 ms
 2  172.16.50.1  125.450 ms
 3  *

то третий рутер он пакет убил но в ответ нихрена не присла icmp 
поэтому на этом месте traceroute рисует звездочку потому что неизветсен Ip того 
рутера мы от него нихрена не получили

я уже сказал что просто пакета ip небывает. внутри него всегда закапуслирован 
пакет другого протокола. только что мы посыллаи ip пакет внутри которого был icmp 
пакет засунут. в ответ нам присыллали ip+icmp но не потмоу что мы слали icmp 
туда а потому что TTL истекал в 0 на рутерах. 
так вот в трейсроут можно "туда" слать не icmp пакет а например udp пакет. 
вобще я считаю что роли не игарает какой протокол будет всунут внутрь ip пакета туда.
потому что ответ нам приходит исходя из друого. из того что TTL стал равен нулю.
итак трейсроут может туда слать UDP пакеты. вот пример

# traceroute -M udp  -n 8.8.8.8  -q1 -m 3

# tcpdump -n 'udp or icmp ' -i enp0s3 -e -v

вот он шлет три udp пакета на порт 53 с TTL=1,2,3
19:36:33.028858 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 1, id 12414, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.59981 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

19:36:33.028889 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 2, id 12400, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.53647 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

19:36:33.028902 ba:ec:24:5c:80:3a > f6:72:b2:f6:dd:ce, ethertype IPv4 (0x0800), length 74: (tos 0x0, ttl 3, id 37820, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.57116 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]


в ответ прилетает два пакета icmp "ICMP time exceeded" от 172.16.10.1 и 
172.16.50.1  а на третий пакет с TTL=3 нихрена не прилетает

19:36:33.029117 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 64, id 58490, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.10.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12414, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.59981 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

19:36:33.149972 f6:72:b2:f6:dd:ce > ba:ec:24:5c:80:3a, ethertype IPv4 (0x0800), length 102: (tos 0xc0, ttl 63, id 21170, offset 0, flags [none], proto ICMP (1), length 88)
    172.16.50.1 > 172.16.10.12: ICMP time exceeded in-transit, length 68
    (tos 0x0, ttl 1, id 12400, offset 0, flags [none], proto UDP (17), length 60)
    172.16.10.12.53647 > 8.8.8.8.53: 16449 op8 [b2&3=0x4243] [17991a] [17477q] [18505n] [19019au] [|domain]

итак четко видно что похеру каой потокол будет всунуть внутрт ip пакета летящего
туда. когда он приетает на рутер и у него станвоится TTL=3 то рутер убивает пакет
и внезависиомсти какой протокол был нвутри этого пакета он  в ответ шлет icmp type 13
пакет. или вобще нихрена не шлет.

спраивается нахрена тогда эти опции в traceroute - из за файрволла. тоесть либо 
файрвоолл на моем компе может не выпускать наружу скажем icmp (для примера) или на 
том роутере может быть закрыт кайото протокол на файрвоолле. тогда проскочить фарвойллы
помогут опции icmp либо udp . еше tracroute может вкалдывать внутрь ip пакета tcp пакет.
вобщем читай man traceroute

как  я понял ip протокол придумаи для того чтобы доставлят пакеты от одного хоста 
до другого. но хост имеет до хрена сервисов внутри. поэтому доставит до хоста это
значит доставить до ядра того хоста. а после этого надо ответиь себе на вопрос а для 
какого сервиса этого хоста этот пакет теперь доставлять ? вот протколы tcp\udp 
они указывают порт который как бы обозначает для какого сервиса на том хосте предназначен
этот пакет.  как я понял проткол icmp придумали для того чтобы когда рутеры обащются
друг с другом по протоколу ip (хотя я этого не предтавляю ибо голый ip пакет без нихера
внутри не отсылвается) и возникают проблемы то тот роутер в ответ может отпправит типа
полезную диангностиечкую ифномоарцию через icmp пакет. ксати получается что на стороне
отправителя пакет icmp может просит сгенеирировать юзер сервис а на той стороне ответный
icmp пакет шлет ядро компа и никкакйо юзер процесс на той стороне вобще об этом не знает
неучаствует и не вызывается при прилете icmp пакета с нашего компа. тоесть там 
его принимает ядро и само вответ шлет icmp пакет без какого либо участия каких 
либо юзер процессов. 


вбщем я ухщел в сторону. возвращаюсь к мультикаст пакету. хотя он ip снаружи но нужно 
какйто проткол внутрь вложить. и вкладывается UDP протокол. а значит какйото порт.
значит чтобы принять мультикаст пакет на нашем компе должен быть каойто юзер сервис
который сидит и слушает сокет UDP на этом порту на этом IP. итак в отличие от icmp 
трафика который может приять ядро на той стоороне и само ответить чтобы  принять 
мультикаст трафик на той стороне должен быть юзер сервис  который сидит и слушает 
на udp сокете некоторый порт на мультикаст IP адресе котоыйр должен быть повеешен 
на некоторую сетевюу карту.

есть такая организация IANA. и она закрепила что мульиксаст IP адреса могут 
принадлежать только диапазону 224.0.0.0 to 239.255.255.255

как  я уже говорил из того что уже прочитал что якобы при использовании мультикаст IP
адреса надо обязательно юзать UDP протокол, тоесть IP адрес у нас это параметр пакета
IP. но так как внутри IP пакета обязателно должжен быть инкапуслирован какйтто еще 
протокол то сказано что им длжден быть UDP проткол. однак и тут наебка. можно 
заюзать ip+icmp проткол для ip=224.0.0.1  при этом линукс умный он в пакете вставит
dest mac мультикастовый а не юникастовый. потому что нет воможности вставиьть какйото
юникастоый мак адрес. мы же как узнаем юникаовые мак адреса. мы шлем арп пакет на все 
хосты и спрашивает привет скажем мне свой юникаст мак если твой IP=224.0.0.1, 
c одной стороны если комп хочет принимать мультикаст у него будет сет карта с таким
IP но комп понимает что это мультктоый IP и поэтому глупо отвечать юникастовым маком на 
арп запрос. поэтому мы никогда не полуичим ответ от компов в сети и никакой мак
мы неузнаем поэтому линукс вставит в пинг dest_mac мультикастовый. и получается пинг 
пошлет ip(мультикастоый)+icmp+мак мультикастоый  в сеть. и всегда пинг был инстурментов
для юникаст запроса но в этом случае он сработает как мультикаст запрос!  
вобщм короче говоря если шлем в пакете мультикаст IP то и мак доолжен быть мультикастовый.
мы же хотим достчиь целой группы компов а через свич это можно сделать только если ему
подсунуть мулььтикаст мак но никак не юникаст мак. в итоге из сети ответят все
компы у которых данный мультикаст адрес установлен
причем они ответят и в ip пакете ответа вставят свой юникаст IP адрес !!

# ping 224.0.0.1
PING 224.0.0.1 (224.0.0.1) 56(84) bytes of data.
64 bytes from 172.16.10.11: icmp_seq=1 ttl=64 time=1.29 ms

вот в данном сулчае на ответил комп с юникаст адресом 172.16.10.11

как убедиться что на его компе ест ip адрес 224.0.0.1 хоть на какойто сет карте.
        $ ip a sh 
нихуя не покажет
а покажет вот такая команда!

# ip -4 -o maddr show
1:  lo\ inet  224.0.0.1
2:  enp0s3\ inet  224.0.0.251
2:  enp0s3\ inet  224.0.0.1
4:  tun1\   inet  224.0.0.1
8:  tun0\   inet  224.0.0.1



вот мы видим что на карте enp0s3 присвоен ip=224.0.0.1
причем можно убедиться что типа ни один процесс не сидит на этом IP

# lsof -n -P | grep "224.0."
# ss -lpn4 | grep 224

ну хорошо у нас есть карта. и ей присвоен IP. в целом необязательно чтобы кайото
процесс сидел на сокете на этом IP. 

ксатти iptables и tcpdump. какая между ними сввязь. tcpdump показывает трафик который 
если входящий то до обработки iptables а если исходящий то уже после обработки через iptables


еще про мультикст IP адреса на компе можно вот так посмотреть

# netstat -gn
IPv6/IPv4 Group Memberships
Interface       RefCnt Group
--------------- ------ ---------------------
lo              1      224.0.0.1
enp0s3          1      224.0.0.251
enp0s3          1      224.0.0.1
tun1            1      224.0.0.1
tun0            1      224.0.0.1


