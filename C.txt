C - programming language
=============================

обьявление переменных
int vasya

это обьявляет переменную vasya типа integer

далее можно присвоить знаение
vasya = 15

можно сразу сделать два дела и обьвявить перееменную и присвоить ей значение
int vasya = 15

int = это целоый тип
float = это с точкой
char = это литеры ascii я так понял





====

// my first program on C
#include <stdio.h>
#include <unistd.h>

int main ()
{

int vasya = 15;
int *pvasya = &vasya;

printf ( "$vasya = %d\n", vasya  );
printf ( "$vasya = %d\n", *pvasya );

vasya = 16;
printf ( "new $vasya = %d\n", vasya );

*pvasya = 17;
printf ( "new $vasya = %d\n", *pvasya );


return 0;
}

===
printf
%x - позволяет распечатать только 32 битное hex число максимум, а
%lx - уже позволяет распечатать 64 битное hex число !

===

тип переменной определяет для компилятора и проги сколько байт надо выделять под нее 
в памяти и в каком формате туда писать и  как интерпретировать  байты при считывании.
условно говоря если переменная целого типа значит при считывании и печати числа и нее
просто печатать число на экране а если переменная типа char то считанное число 
интерпретировать в литеру.  переменная типа поинтер хранит не значение а адрес памяти по которому
лежит значение тоесть в переменной мы храним незначение а ссылку в памяти где лежит значение 
этой переменной. почему то принято считать что поинтер указывать на память где хранится
значение другой переменной. а на самом деле в поинтере хранится значение самой переменного поинтера.
пример

int a = 1;
int *pA = &a;

получсется мы имеем две переменные которые имеют одинаковый бекенд. и как тут сказать 
какая из них на самом деле владее значением.   походу поинтер это как хардлинк на фс на файл.
несколко хардлинков указвают на один бекенд. 

когда программа напарывается на поинтер то она понимает что в этой переменной pA хранится незначение
переменной а ссылка на то где искать это значение. а значит некоторые операции доступные для обычных
переменных недоступны для переменной типа поинтер а ннекоторые новые операции зато доступны
для переменной поинтер которые недоступны для обычных переменных.

==================

printf

коогда мыхотим напечатать переменную то нужно в явном виде сказать принтф 
какой тип у переменной хотя ведь мы при созании перееменной это явно прописываем.

теме неменее это так  увы


#include <stdio.h>

int main () {

   int  var1 = 500;


printf( "var1=%d\n", var1 );
printf( "octal form=%#o\n", var1 );
printf( "hex form=%#x\n", var1 );
printf( "HEX form=%#X\n", var1 );

printf ( "\n"  );


float var2 = 600.5;
printf( "var2=%f\n", var2 );
printf( "var2=%#A\n", var2 );
printf( "var2=%#a\n", var2 );
printf( "var2=%#g\n", var2 );



   return 0;
}



в этом примере обьявляется переменная var1 с типом int
так вот что интересно что принтф позволяет при распечатке ее конвертировать ее вывод
из дефолтового (десятичного)  в другие виды. что существенно и в чем подьебка что конвертация
доступны не во все виды а только в некоторые

вот такой будет вывод на экран

var1=500
octal form=0764
hex form=0x1f4
HEX form=0X1F4

var2=600.500000
var2=0X1.2C4P+9
var2=0x1.2c4p+9
var2=600.5


таким образом int переменную можно при распечатке вывести в восьемричном виде, hex виде и 
на этом и все.  тоесть например нельзя переменную int типа вывести в виде с плавающей точкой
почему непонятно в чем проблема.


тоже самое касается переменной var2 типа float. 
ее можно при печати вывести в hex виде, но попытка выести ее в виде целочисленном
выдаст ошибку. 

если дефолтовая форма как обьяснить принтф какой тип имеет печатаемая переменная это 
%d
%x
%f

итп, то алтернативный вида задается в виде %#x. вобщем я бы сказал бы что просто напросто
 целочисленныую переменную можно ввывести в dec,hex,oct формате тоесть это блять никакое 
 не преобразование как об этом пишут в man это всего навсего меняется система счисления.
 а переменную с точкой можно вывести в dec,hex форматах. вот и все что касается %# в принтф.

 итак при выводе с помощью %# целое остаетс целым а с точкой осается с точкой 
 просто вывод идет по разным система счисления.

 а если мы хотим целое вывести как с точки или с точкой вывести как целое то для этого
 надо  на переменную натраваить функцию которая ее преобразует. пример

float var2 = 600.5;
printf( "var2=%i\n", ( int ) var2 );

вывод на экране
var2=600.500000
var2=600

вообще я непонима смысл этой решетки %# потому что - тип данных имеет скажем целый тип.
тоесть число без точки. от того что мы печаатем его в hex или dec или oct или bin виде 
от этого тип данных неменяется. поэтому на мой взгляд 

%x = %#x
%X = %#X

непойму нахуя вобще этот оператор # .

потому что и без него все рабоатет.

еть у нас var1 с типом int. окей. теперьмы для себя определяемся в какой системе исчисления
мы хотим распечатать переменную. еси в dec виде то 

printf ("%i", var1);

если в hex виде то 

printf ("%x", var1);

если в HEX виде то 

printf ("%X", var1);

нахуя нам тогда этот #  ??????????? он ничего непреобрзует. и никаких новых возможностей недает!




 =============


еще интерснейщие пример
он про указатели. 
про принтф


#include <stdio.h>

int main () {

   int  var1 = 500;
   printf( "var1 = %i\n", var1  );


   int *pVar1;
   pVar1 = &var1;
   printf( "Address of var1 variable in memory(hex) =  %p bytes\n", pVar1  );
   printf( "Address of var1 variable in memory(dec) =  %li bytes\n", ( long int ) pVar1  );
   printf( "Address of var1 variable in memory(dec) =  %li TB\n",( ( long int ) pVar1 ) /1024 /1024 /1024 /1024);


   printf( "var1 = %i\n", *pVar1 );


   char var2 = 'a';
   printf ( "var2=%c\n", var2 );
   printf ( "var2=%d\n", ( int ) var2 );






   return 0;
}


вывод на экран:
var1 = 500
Address of var1 variable in memory(hex) =  0x7ffe4bbe0c1c bytes
Address of var1 variable in memory(dec) =  140730169166876 bytes
Address of var1 variable in memory(dec) =  127 TB
var1 = 500
var2=a
var2=97



разберем


   int  var1 = 500;
   printf( "var1 = %i\n", var1  );

  наэкране
  var1 = 500

  обьявляет целую переменную и печатает ее обьясняя принтф что мы собираемся печатать 
  перменуую целого типа. все таки непонятно если мы уже указали что перменная целого типа зачем
  еще раз это прописывать в принтф





   int *pVar1;

   обявляем поинтер переменную которая укащывает на ячеку памяти в которой лежит значение
   целого типа, 


   pVar1 = &var1;

   записываем в pVar1 адрес ячейки памяти от переменной var1




   printf( "Address of var1 variable in memory(hex) =  %p bytes\n", pVar1  );

   на экране
   Address of var1 variable in memory(hex) =  0x7ffe4bbe0c1c bytes


   печатаем адрес ячейки памяти который хранится в поинтере. получается в принтф переменная
   типа поинтер указывается как %p.
   заметим что pVar1 указывается без всяких *
   таким образом если мы хотим заглянуть в сам поинтер то просто указвыаем его имя pVar1
   никаких звезд ненадо. как видно по дефолту значение поинтер переменной тоесть адрес ячейки памяти  печается на экране в виде hex.


   printf( "var1 = %i\n", *pVar1 );

   на экране
   var1 = 500


   а тут мы печатаем не поинтер а значение ячейки на которую он указывает. поскольку значение
   в ячейке имеет целоый тип то для принтф указываем %i
   поскольку мы хотим посмотреть не в значение поинтера а по адресу который в нем хранится 
   то импользуем звезду *pVar1

   вот такая большая разница в смысле pVar1 и *pVar1

   pVar1 = 0x7789798798dc  тоесть адрес ячейки памяти
   *pVar1 = 500  значение которое лежит по адресу втой ячейке памяти

   соотвестенно для принтф
   %p = указывает что печатаем переменную поинтер типа
   %i = указываем что печаатем переенную целого типа

прикольно то что нет просто переменной понинтер типа. помимо поинтер типа этот тип еще 
дожен иметь некий классический тип

	int * pVar1 = переменная поинтер типа + целого типа





   printf( "Address of var1 variable in memory(dec) =  %li bytes\n", ( long int ) pVar1  );
   printf( "Address of var1 variable in memory(dec) =  %li TB\n",( ( long int ) pVar1 ) /1024 /1024 /1024 /1024);

   на экране
	Address of var1 variable in memory(dec) =  140730169166876 bytes
	Address of var1 variable in memory(dec) =  127 TB

 здесь интересно то что я хотел распечатать поинтер на экране не в дефолтовом виде hex 
 а в десятичном виде. если переводить адрес памяти в из hex в dec то он очень большой и влезает 
 только в тип данных long int  поэтому я преобразовал hex в long int для этого я заюзал функцию  ( long int )  которую натрваил на pVar1. в английских книгах преобразование одного типа данных в 
 другой называется type casting  или просто casting. 
 в принтф я тоже указал что мы печатаем на экране тип данных %li.
 во второй строке  я применили арифмтические операции и перевоел байты в терабайты при этом получается число которое влезает в тип данных integer поэтому для принтф я указал %i

получается про принтф. в нем мы укаваем какой тип данных имеет переменная а потом указываем
эту переменную

printf ( "%тип_данных_у_переменной", имя_переменной)

вот так эта хрень работает.


или в более сложном вариенте принтф вместо переменной мы можем указать функцию которая берет пременную ее значение и тип и пребразует
ее значение вдругой тип

printf ( "%тип_данных_у_переменной",  (функция ) имя_переменной)

на выходе функции должны полчаться данные ровно того типа что мы указали в %.

теперь вспомним что написано в man 3 printf. там написано что если мы в принтф юзаем %p
то принтф ожидает увидеть переменну с типом void *. тоеть переменную котора была обьявлена 
вот так 

void * pVasya

тоесть перменная должна быть поинтером да непросто какого то там типа а воид типа.
если же мы посмотрим как унас вверху заюзано

	int *pVar1;
	pVar1 = &var1;

	printf( "Address of var1 variable in memory(hex) =  %p bytes\n", pVar1  );

   	на экране
   	Address of var1 variable in memory(hex) =  0x7ffe4bbe0c1c byte


то мы увидим что в принтф мы подставили перменную pVar1 которая да поинтер 
но она не воид типа а int типа. хм... почему же компилятор незаругался и у нас все сработало?
тоесть моя практика показывает что принтф если указать %p то в качестве переменной он принимает
переменую типа поинтер абсолютно любого типа ему пострать это int * или void * или long * 
абсолютно похер. главное чтобы был тип поинтер неважно какого типа.
ключ %p печаатает адрес который хранится в поинтере. поэтому ему как бы похер на какой 
тип данных этот адрес ссылается.
 
 я считаю вот эта мудота с обозначением поиинтера как int * или void * это полный идиотизм
 вместо этого надо было ввести обозначениее для создания поинтера чтото типа  такого 

 int * var1  ----> pointer_i  var1
 void * var1 ----> pointer_v  var2

 вместо этих дурацкий звезд. а то сиди иломай мозг разгадывая смысл этих звезд.



=================

потихоньку начинает вырсиываотся смысл

ssize_t read(int fd, void *buf, size_t count);

получается функция read резульаттом является данные с типом ssize_t ( об этом потом) там отличие 
ssize_t от size_t  в том что может вернуться -1 

int fd = тип переменной целое, смысл переменной это файловый дескриптор (файл) из которого читаем
void *buf =  тип переменной поинтер, тип у поинтера void. смысла ее это буфер в который пишем что прочитали
size_t count = тип переменной size_t . смысл ее это размер читаемого в байтах


какой смысл у поинтера который указыаем на ячейку в котрой хранятся данные типа void.
воид это значит что тип данных неизвестен. я так поимаю что запись в поинтер который указывет 
на ячейку с неизвестным типмо данных дает нам взможность типа того что писать туда данные в raw формате. 

но void * var1 поинтер будем подрообнее анализивать и обсуждать ниже.

===========


соатновился на задаче как счиатть 1 символ с клавы
а потом выести на экран

вот этот код считыает с клавы 1 символ

#include <stdio.h>
#include <unistd.h>

int main () {

    int klava = 0;

    void * bufer;
    char k[1];
    bufer = &k;

    printf ( "void address = %p\n", bufer );

    size_t count;
    count = 1;

    read( klava, bufer, count);

   return 0;
}


что здесь существенно. 
если просто обьявить void поинтер 

void * bufer;

то как показал практика в реале он неиницилизируется и ни на какую ячейку памяти
непоказывает. поэтому нужна вот такя комбианация чтобы bufer начал релаьно укзатьвыа на
ячеку в памяти

void * bufer;
char k[1];
bufer = &k;


ну а эта строчка

printf ( "void address = %p\n", bufer );

это просто проверка что ячейка понинтер кудато реально указывает.

поопутно как я понимаю тип char это 1 байт в памяти под каждый char обьект. по факту 
это число от 0 до 255. целое.
поэтому наша воид поинтер по факту указыает на ячейку 1 байт длинной.



правлная инциализация void - то что он сам по себе никуда незукывает.
его плюс в том что его можно директить на соврешенно разные типы бекенд ячеек

int a = 10;
char b = 'x';

void *p 
p = &a;  
p = &b; 


минус в том что с этой поинтера нельзя напрямую печатать

int main()
{
    int a = 10;
    void *ptr = &a;
    printf("%d", *ptr);
    return 0;
}

если даже на бекенде сидит у нас int то получаетс что по определению void поинтер указывает 
на ячейку памяти в которой сидит занчение перменной у котроой нет типа!!!! а раз нет типа
то ее нельзя распечатать.

поэтому воид поинтер надо конвертить ( и он конвертирится в любой тип без проблем) в тот 
тип данных что мы хоим печатать

int main()
{
    int a = 10;
    void *ptr = &a;
    printf("%d", *(int *)ptr);
    return 0;
}

на счет вот этой хрени  *(int *)ptr


(int *)ptr  = создает поинтер нового типа. адрес в нем такой же а вот тип данных который лежит в
 ячейке по адреу поинтера утверждоаетс что новый тоесть

 int a = 1;
 void * vasya;
 vasya =  &a;

 хотя мы знаем что в ячеке пойинтереа лежит целое но C этого незнает.
 пожтому что мы заявили что по адресу поинтера vasya лежат какието данные но их тип определить
 невозможно.

 поэтому

 int * petya;
 petya = ( int *) vasya;

 тоест мы сконевертировали воид поинтер в int поинтер и подсунули адрес а petya

 теперь petya смотрит тудаже куда и вася но для C уже понятрно что бекенд пети это интеджер.

 поэтому его можно печатать.

 printf ( "%c", *petya  );



так вот я про вотэту команду

*(int *)ptr

она преобразует воид поинтер и вызывает значение по его адресу.

пример

#include <stdio.h>
#include <unistd.h>

int main () {

    void * pVasya;
    char a = 'a';
    pVasya = &a;

    printf ( "pointer pVasya = %p\n", pVasya   );

    char * pa;
    pa = (char *) pVasya;

    printf ( "pointer pa = %p\n", pa);

    printf ( "char = %c\n", *pa  );

   return 0;
}

вывод на экран:
pointer pVasya = 0x7fff5d948237
pointer pa = 0x7fff5d948237
char = a



видно что поинтеры указывают на одну ячейку.

так ну пока я невижу какогот то полезного смысла в воид поинтер
кроме такого что  его указатель можно менять на любые типы препеменных.


int a = 10;
char b = 'x';

void *p;
p = &a;  
p = &b; 

прикольно. но какой в этом болшой смысла на практкие хер его знает


ясно одно кога мы создаем воид поинтер то мы четко заявляен стстеме что тип данных у ячейки остуствует. его нет. мы неможем его определит. данные есть но их тип неопреелим. несущетсвует.
поэтому принтф для воид поинтера неработает. 
для самого адреса %p конечно работает а вот для занчения перменной в ячейке нет.



==========
cast
type cast
type conversion

это все слова о том что можно натравливать на переменную одного типа функцию
которая превратит данные этой переменной в другой тип и эти новыве данные нового типа
можно будет присвоить новой переменной

(type_name) expression

из этого получается что в выражении void * vasya кусок void * является одним целым
и означает тип данных.

тоесть 

int
double 
float
char
int *
void *

это все так обозначаются типы данных. но меня больше всего тут заинтересовало int * и void *

==

#include <stdio.h>


int main () {

    int a;
    printf ("%p\n", &a );

    int * pVasya;
    printf ( "%p\n", pVasya );


    void * pVasya2;
    printf ( "%p\n", pVasya2 );


   return 0;
}

vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~/C$ gcc -o 15 15.c; ./15
0x7fff55d56584
0x5570162325a0
0x7fff55d56680


странно.
переменным неприсовено никакого значения но под них 
уже зарезервированы ячейки в памяти.
===

вот еще пример


#include <stdio.h>


int main () {

    int a;
    printf ("variable \"a\" memory address = %p\n", &a );
    printf ("var a = %i\n", a );


    int * pVasya;
    printf ( "variable pVasya points to memory address = %p\n", pVasya );
    printf ( "*pVasya = %i\n", *pVasya );



    void * pVasya2;
    printf ( "pointer pVasya2 points to memory address = %p\n", pVasya2 );


   return 0;
}


$ gcc -o 15 15.c; ./15
variable "a" memory address = 0x7ffe1165e0c4
var a = 21881
variable pVasya points to memory address = 0x5579416f95a0
*pVasya = -1991643855
pointer pVasya2 points to memory address = 0x7ffe1165e1c0


видно что мы обьявили пермеменные но не присвоили значения
однако значения у них уже есть! это чтото !

=========

пример cast преоббразования одних типпов данных в другие


#include <stdio.h>


int main () {

int a = 10;
int b = 2;

double count;


count = (double ) a / b;

printf ( "%i / %i = %f\n", a, b, count    );


   return 0;
}


vasya@vasya-Lenovo-IdeaPad-L340-15IWL:~/C$ ./15
10 / 2 = 5.000000

======

поговорим про ascii
станадартк кодирования символов. типа есть текст с байтами их надо 
как то транслировать в символы. man ascii
кодирование сосотоит из 128 символов. на него хватвает 7 бит.
часть кодов это несимволы а упправляющие сигналы. кодировка уходит
во времена печаатающих маштнок ( typewriter). и электрических печатных машин ( teletype writer)
так вот хочу про два спец символа сказать

CR - carriage return это когда на печатной машинке мы беремся за железную такую ручку
и тащим налево это приводит к тому что печатная гооловка оказывается опять в левом крайнем
положении. что важно отметить что при этом мы остаемся в тойже строке тоесть бумага при этом
на прокручивается вверх вертикально. ( хотя как я помню из своего опыта печатания на печатной
машинке то при перенеосе головки влево и бумага автоматом прокручивается вверх на одну линию)

LF - line feed. прокрутка листа бумаги на одну линию вверх. при этом с головкой ничего непросиходит
так что печать начнется с тойже позициив строке а не с левой крайней.

поэтому получается что на классическом матричном принтере если закончилась строка то чтобы
начать печатать с новой строки надо подать два сигнала оба тоесть CR + LF либо LF + CR
более того я прочитал что якобы для матричных принтеров нужно было дать несколько таких
сигналов типа CR + CR +CR +LF потому что якобы они неусмевали дотащить головку влево 
за время одного CR что по мне бред ведь они печатают из буфера а не стой скоростью с которой
 в них прилетают сигналы.

 тем не менее теперь понятна разница между CR и LF.
 LF часто называют "new line". а так тепер стало понянто. CR это перметсить печатную голову влево
 а LF это прокруттить рулон бумаги вверх.

 итак вся эта хрень относилась к элетрическим печатным машикам по которым по проводам телеграммы
 летели.  а когда перешли к  теримналам с электронными экранами то ( как я понял ) необходимость
 для переноса строки юзать два символа типа пропала. поэтому в файлах начали изать для этой цели
 обычно один символ либо CR либо LF и  терминалу стало понятно что надо сделать CR + LF.

 поэтому в линуксе в текстовых файлах знаком конца строки и начла новой строки является символ
 LF тоесть байт который в себе несет значение 10 (dec) или 0A (hex)

 тут еще раз важно отметить что символ LF формально должен только пркручиваь бумагу на 1 строку 
 вверх а голвка при этом остается на том же месте. но в линуксе в его терминале это приводит к тому
 что экран прркучиватеся на 1 строку вверх и также при этом и гооловка печаатающая возвращается
 в левое крайнее положение

 вот программа

 $ cat 1.bash 
#!/bin/bash

sleep 1; 

echo -n "v"; 
sleep 1; 

echo -n  "a"; 
sleep 1; 

echo -n "s"; 
sleep 1; 

echo -n "y"; 
sleep 1; 

echo  -n "a"; 
sleep 1;

echo -n -e "\x0D"; 
sleep 2; 



echo -n "*"
sleep 1;

echo -n "*"
sleep 1;

echo -n -e  "\x0A"
sleep 1;


echo -n "!"
sleep 1;

echo -n -e  "\x0A"
sleep 5;

вот ее вывод

**sya
!

теперь разберем.
вначале програ печаате по буквам слово vasya

vasya

печатется оно буквам в одной строке. ключ -n  в echo дает то что при выводе буквы после 
нее непроисходит прокрутки бумаги и возврата головки(курсора) в левое положение ( условно говоря
не вставляется enter)

потом печатная головка (курсор мигающий) возвращаетмя в начало строки (без прокрутки бумаги).
за это отвечает команда echo -n -e "\x0D".  0D это символ CR (возврат головки влево) в hex 
формате. здесь важно отметить еще раз что при возврате каретки бумага непрокручивается. так что 
печать остается в тойже строке.
и далее начинает затираться строка печатая две звездочки. так что мы увидим вот такое

**sya

этим я хотел еще раз подчеркуть что при поступлении в терминал ( котрорый можно сравнить с матричным принтером) символа CR ( 0D hex ) происходит возрат головки вначало строки и не происходит
прокрутка бумаги. так что печать начинает затирать ранее набранные символы.

далее в
 бумага прокручивается вверх  потому что на терминал поступает байт 0A (hex ).
это делается командой echo -n -e  "\x0A"
0A (hex) этот байт это  символ LF - line feed - прокрутка  бумаги наверх. но помимо покрутки бумаги также происходит и возврат головки
 вначало строки. здесь уже 0A ни причем это чисто отсебятина linux терминала.

терминал можно сравнить с матричным принтером. а байты которые в него влетают с управляющими командами. если прилетает байт 76(hex) то принтер печаатает головкой литеру "v"
если прилетает байт 61 (hex) то принтер печатает литеру "a"
а если прилетает байт 0D (hex) то принтер ничего непечаатает он возвращает головку в левое положение
в начало строки.
а если прилетает байт 0A (hex) то принтер пррокручивает бумагу на одну строку вверх. и еще добавляет  от себя возврат головки в начало строки.



так вот когда напечаатся **sya то происходит пркрутка бумаги и  возврат в начало строки 
и печается !

**sya
!

далее происходит опять пркоуркртка бумаги и возврат в начало строки.

ключ -e позволяет через echo передвать байты в hex виде.
ключ -n засталвяет echo невставлять автоматом LF в конце команды. так что мы имеем полный контроль
над выводом в терминал.

такми мккаром мы изучили влияние и работу CR и LF.

также полчается если у нас есть файл и мы запустим его вывод на терминал 

$ cat vasya.txt

то файл содержит байты. так вот терминал (ядро линукса) он как матричный принтер рассматривает каждй байт в файле как 
литеру ascii таблицы и либо печатает сооветвующую литеру или если это нелитера а управляющая команда
такая как CR или LF то прокручивает бумагу (то бишь экран) или возвращает головку (курсор) в начало
строки. таким образом голые байты в файле превращаются  в набор литер на экране. (ну или на бумаге) есл бы это был принтер.

таким образом в файле никакие литеры нехранятся ( как это могло бы интуитивно показаться). 
файл это не бумага. в файле литер нет. там только голые байты.


далее. что инересно.
если мы откроем скажем в mcedit файл в котлром есть байты которые в таблице asccii отвечают 
за упраляющие команды то на экране  в определенных местах будут стремные символы например для 
байта CR на экране в тексте будет что то типа ^M

вообще это интересно. потому что при просто выводе на экран такого ничего нет.
курсор терминала просто делает что ему предписано прокручивает бумагу или возвращает курсор 
в начало строки. так что при просмотре файла никаких стремных символов нет. потому что просмотр файла  это аналогично печати на принтер. где каждый байт это либо литера либо управляющая команда
для головки принтера (курсор)

вобще полчучется файл это поток байтов которй по проводам предавался от одгной электро печатной машинки на другую и использоваолся чтобы набрать текст в автоматическом режиме.


типа это как рецепт изготовления пирога.

принтер является поваром а файл рецептом.

терминал выступает в роли принтера.

когда мы открваем файл на редактирование то получается в определеннымх местах нам надо 
как то показывать что здесь сохранен непросто литера а управляющая команда. 
это как открыть файл ворда. там помимо голого текста еще напихана куча управляющей информации.
таким образом это власть текстового редактора показывать каким либо одразом управляющие символы
ascii или их скрывать.

mcedit например байт CR показывает как ^M

===

ascii

рассмотрим следущий байт

00 (hex)

он означает то что при получении этого байта терминал ничего неделает. ни печатает и с головой
ничего неделает.


пример

$ echo -n -e "\x00v\x00a\x00s\x00y\x00a"

здесь получается слово vasya и между буквами вставлены байты 00 (hex) 
на экране мы увидим просто слово 

vasya

между буквами ничего небудет никаких лишних символов.
возможно в teletype writeer машиных этот символ вставляли для того чтобы у принимащей
машины были паузы при печати незнаю для чего эти паузы. чтобы машины не перегревались.

этот как в процессоре команда nope которая ничего неделает 1 цикл.


что при этом существенно что если мы направим вывод в файл 

echo -n -e "\x00v\x00a\x00s\x00y\x00a" > ./vasya2.txt

то конечно внутри него попимо байтов отвечающих за литеры vasya еще будут байты 00 (hex)

делаем следущий экспримент

$ cat /dev/zero

на экране терминала небудет отображаться ничего. потому что в темринал поступают байты у которых
значение 00 (hex) поэтому драйвер терминала  ( ака виртуальный матричный принтер) интерпретурует
данную команду как ничего непечатать и неделать.

(а совсем не так как казалось бы интуитивно раз поступают байты с нуля то на экране побегут нули. хаха)

в тоже время если направить эту штуку в файл то конечно файл забьется байтами 00 (hex)
и это можно отлично посмотрет в hex редакторе файлов.


итак с 00 (hex) байтом в ascii разоборались
===

ascii

написано что в бинарном виде заглавная буква отличается от маленькой буквы только одним битом.
я проверил это так.

например

dec 87 = 'W'
dec 119 = 'w'

$ echo 'obase=2;87' | bc
1010111

$ echo 'obase=2;119' | bc
1110111

напписано что на мехаических teletypewriter такая схема облегачала 
их програмирование их контсрукции

===


