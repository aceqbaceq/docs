
| ARP
| OSI

вопрос к какому лейеру отнсоитя ARP протокол. и 
по каким признакаам относят протокол к тому или иному лейеру?? (смотри
запись на диктофроне). - ха запись я стер. но вроде как к layer 2.5
тоесть уже не 2 но еще и не 3



| ARP
| ssh
| connect

тут я распишу как работает ARP
а дальше я укажу интересный случай который меня привел к ARP

значит оснонвая цель этго протокола это узнать MAC  хоста если мы знаем IP.
он прияменяется нетлко в etherenet сетях но и в других сетях второго уровня.
например wifi это не ethernet но в них также есть mac адреса и он там тоже применяется

так вот у нас снаружи идет ethernet frame в котором есть dest mac и src mac
а внутри вложен уже пейлоад в котором и сидит arp пакет. 

	(etherneet frame[dest mac|source mac] [payload ARP]  )


так вот так как наш комп незнает dest mac то он при составлении эзернет фрейма 
подставлвяет dst mac  = FF:FF:FF...:FF  тоесть такой дест мак адрес котооырый будет
эзернет свичем доставлен ко всем хостам сегмента. такой мак назыается броадкаст мак. 
когда такой фрейм прилетает на любой комп то он засаывается внутрь ядром хоста. 
далее ядро смотрит есть ли у него на его сет карточках такой IP . если нет то хост
тихо дискардит этот фрейм. а хост у которого есть такой IP он в ответ шлет свой arp  ответ.
причем так как в арп запросе есть соурс мак то в обрабтку уже летит юникаст эзернет фрейм.

так вот юникаст эзернет фреймы   при arp запросах  воозникают нетолько в случае arp ответа.
также юникаст эзернет фреймы в арп случаются и при запросах. а как ттак ты спросишь в каком
случчае? а вот в каком. когда наш комп через броадкаст запрос получил ответ что такой то IP
имеет такой то мак то наше ядро заосит эту ифно в arp таблицу. 


$ arp -env
Address                  HWtype  HWaddress           Flags Mask            Iface
172.16.10.12                     (incomplete)                              br0
172.16.10.11             ether   ba:ec:24:5c:80:3a   C                     br0
192.168.58.81            ether   06:7f:c6:b9:18:cd   C                     wlp2s0
172.16.10.100                    (incomplete)                              br0
Entries: 4	Skipped: 0	Found: 4


так вот записи в этой таблице они протухают. и их нужно периодически перепровреверять.  к
сожалению в таблице невидно через сколько протухнет эта запись. но она протухнет это точно.
как чсто это надо проверять валиднсть записи настрваиется где то в 

		/proc/sys/net/ipv4/neigh/br0

$ ls
anycast_delay        base_reachable_time_ms  interval_probe_time_ms  mcast_solicit  retrans_time     unres_qlen
app_solicit          delay_first_probe_time  locktime                proxy_delay    retrans_time_ms  unres_qlen_bytes
base_reachable_time  gc_stale_time           mcast_resolicit         proxy_qlen     ucast_solicit


так вот кода ядро решает проверить валидность записи то ядру нет смысла посылать arp запрос
через броадкаст эзернет запрос. зачем? ведь мы уже знаем дест мак. и ВОТ В ЭТОМ СЛУЧАЕ
ядро формирует юнкаст эзернет запрос. ! вот когда у нас есть юникаст эзернет арп запрос.
об этом механзме укзано в rfc про arp

	https://www.rfc-editor.org/rfc/rfc1122#page-22


                 (2)  Unicast Poll -- Actively poll the remote host by
                      periodically sending a point-to-point ARP Request
                      to it, and delete the entry if no ARP Reply is
                      received from N successive polls.  Again, the
                      timeout should be on the order of a minute, and
                      typically N is 2.



вот как можно поймать arp в tcpdump причем ключ -XX нам покажет даже тело запроса


  $ sudo tcpdump -i br0 arp  -e -vvvv -n -XX 
tcpdump: listening on br0, link-type EN10MB (Ethernet), snapshot length 262144 bytes
16:55:44.876122 f6:72:b2:f6:dd:ce > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Ethernet (len 6), IPv4 (len 4), Request who-has 172.16.10.100 tell 172.16.10.1, length 28
	0x0000:  ffff ffff ffff f672 b2f6 ddce 0806 0001  .......r........
	0x0010:  0800 0604 0001 f672 b2f6 ddce ac10 0a01  .......r........
	0x0020:  0000 0000 0000 ac10 0a64                 .........d


здесь ffff ffff ffff это дест мак
f672 b2f6 ddce это сорс мак
0806 признак того что внутри эзернет фрейма в пейлоад вложен arp пакет



далее. 
значит когда ядро шлет обычный эзернет брокдаст арп запрос 

$ sudo tcpdump -i br0 arp  -e -vvv -n
tcpdump: listening on br0, link-type EN10MB (Ethernet), snapshot length 262144 bytes


16:53:16.992780 f6:72:b2:f6:dd:ce > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Ethernet (len 6), IPv4 (len 4), Request who-has 172.16.10.100 tell 172.16.10.1, length 28

16:53:18.019195 f6:72:b2:f6:dd:ce > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Ethernet (len 6), IPv4 (len 4), Request who-has 172.16.10.100 tell 172.16.10.1, length 28

16:53:19.032460 f6:72:b2:f6:dd:ce > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Ethernet (len 6), IPv4 (len 4), Request who-has 172.16.10.100 tell 172.16.10.1, length 28

то ядро если не получает ответа то оно повтоярет этот запрос НЕСКОЛЬКО РАЗ.
то сколько раз нужно повторит безотвыетный запрос прописвыается тут 


	/proc/sys/net/ipv4/neigh/br0/mcast_solicit

обычно по дефолту это равно 3

эту хрень можно менять налету.  однако я так и непонял прикол. если ставишь одни цифры
то ядро в точности соблюдает эту цифру. и повтоярет безответный запрос ровно столько раз
а если стваить другую цифру то ядро делает число безответных повтоярений КРАТНО БОЛЬШЕ. например 
если поставь 1  либо 2 либо 3. то число повторов будет 3. а если посавить 6 то число повторов
будет 12!

вот стоит унас скжажем 3. 
ядро шлет три запроса в ответ ничего. что делает ядро? а вот что. дело в том что в arp запросе
у нас есть IP адрес. откуда он берется? а берется оттуда что юзер программа обычно запускает
в своем коде команду чтото типа такого 


connect(3, {sa_family=AF_INET, sin_port=htons(22), sin_addr=inet_addr("172.16.10.100")}, 16) 


тоесть юзер спейс программа просит создать тцп конект на порт 22  хоста с ip=172.16.10.100
так вот ядру чтобы выполнить этот запрос нужно же создать нетлоько tcp пакет и ip пакет но
и эзернет пакет. поэтому ядро уже от себя формирует в сеть arp реквест  с ip=172.16.10.100
так вот когда ядро в ответ на свои три запроса arp неполучит нихерна то оно вернет в юзер 
спейс ошибку -1 в коде возврата команды

connect(3, {sa_family=AF_INET, sin_port=htons(22), sin_addr=inet_addr("172.16.10.100")}, 16) = -1 

а в деталях eerrno этой ошибки ядро укажет более точную причину

				EHOSTUNREACH

вот!!  вот как у нас ядро выстреливает в юзер спейс облом с ARP реквестом.!!

в итоге на экране в стрейс это будет выглядеть так

connect(3, {sa_family=AF_INET, sin_port=htons(22), sin_addr=inet_addr("172.16.10.100")}, 16) = -1 EHOSTUNREACH (No route to host)

вот откуда берется арп реквесты. вот от чего зависит сколько раз они повторяются. вот к чему
это приводит нашу программу в юзер спейсе!

я еще не упомаянул такой момент что чтобы ядро могло сделать арп реквест оно должно понимать
через какой сет итерфейс ей нужно высрать арп пакет.  для этого ядро при выполнении connect() 
лезет в ТАБЛИЦУ МАРШРУТИЗАЦИИ! и имея на руках dest ip 172.16.10.100 шарится по таблице 
маршрутиацзии  и ищет маршрут. когда ядро его находит то в строке  маршрута будет указано имя
сетеовой карты

  $ ip -c r sh
172.16.10.0/24 dev br0 proto kernel scope link src 172.16.10.1 metric 425 

соотвестенно тода ядро понимает что арп рекест нужно высирать из br0 карты.
также ядро тогда знает какой src mac нужно подставит в эзернет фрейм этого пакета.

  $ ip -c link show dev br0
9: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000
    link/ether f6:72:b2:f6:dd:ce brd ff:ff:ff:ff:ff:ff

а именно f6:72:b2:f6:dd:ce

что сосбвтенно и видно в дампе тцпдамп

$ sudo tcpdump -i br0 arp  -e -vvv -n

16:53:16.992780 f6:72:b2:f6:dd:ce > ff:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Ethernet (len 6), IPv4 (len 4), Request who-has 172.16.10.100 tell 172.16.10.1, length 28

тоесть наш тцп дамп слушает трафик на br0  и в  пойманном арп рекесте мы видим
src mac = f6:72:b2:f6:dd:ce
dest mac = ff:ff:ff:ff:ff:ff
request ip = 172.16.10.100

ксатти из запроса видно что арп реквест влукючает в себя нетлко  реквест ip но 
также и ip нашего хоста 172.16.10.1  . этого я незнал

таким образом я рассмотрел важные моенты  обеспечения оргаизации работы арп проткоола со  стороны
ядра. и как  резулттатыт работы ядро сообщает в юзер программу

таким образом  юзер спейс  дает сетевую команду обычно напрямую не связанную с арп протоколом.
например дает команду свяжись ка ты с удаленным хостом по tcp\ip через connect()


connect(3, {sa_family=AF_INET, sin_port=htons(22), sin_addr=inet_addr("172.16.10.100")}, 16) = -1 EHOSTUNREACH (No route to host)


ядру осущесвтить тцпъ\ип реквест нужно создать тцп\ип\эзернет пакеты. каждйы из которых нужно
заполнить нужной инфо. да еще нужно этот приготовленный пакет высрать из непонятно какого 
сетевого интерфейса. поэтому для начала ядру  приходится заюзать вспомогательный проткол  арп и делать арп реквест. но чтобы даже сделать арп реквест  ядру приходится заалазит в таблицу маршрутиации. прояснив для себя с какого интерфейса и с  каким сорс мак высирать эзернет
фрейм с арп запросом ядро высирает эзернет арп пакет в сеть  и ждет ответа. 
если ответа нет то ядро делает неклько потвоных  таких же рекестов.  число этих повтоых рекестов
пропсиыватьеся тут 

	/proc/sys/net/ipv4/neigh/br0/mcast_solicit

не получив ответа  ядро понимает что дальше делать нечего. и возвращается в юзер спейс с кодом
возврата -1 тоест ошибка.   и в переменной errno ядро укзывает точную причину ошибки ее 
расшифроку  


		EHOSTUNREACH (No route to host)

вот такие пироги.

так вот теперь я вовзращаюсь к случаю котоырй меня привел к рассмотнению ARP.
значит я на компе запускаю команду

  $ ssh 172.16.10.100

при этом я щас точно знаю что  на данный момент этот хост выключен. и вот что
я вижу на экране от ssh

  $ ssh 172.16.10.100
ssh: connect to host 172.16.10.100 port 22: No route to host


я делаю стрейс чтоы посмреть как это вылядит там

  $ strace ssh ...
  connect(3, {sa_family=AF_INET, sin_port=htons(22), sin_addr=inet_addr("172.16.10.100")}, 16) = -1 EHOSTUNREACH (No route to host)

причем из трейса видно что возврат с ошибкой происходит не моновенно значит ядро чтото там реаьно
делает.
тогда то мне и стало интересно а как ядро на практкике через какие меры определяет что 
хост недоступен!!

и вот теперь все стало ясно. делает это ядро через  просмотр табицы маршрутиазации и далее
отсылок арп реквестов. а таймайт по вермени между тем как мы запустили connect() и возвратом
оттуда с ошибкой происходит потому что ядро пускает несклоько арп реквестов. и потом ядро
ждет некоторый тамаут межуду их запусками. а это все время
также в зависомтсти от настойки

	/proc/sys/net/ipv4/neigh/br0/mcast_solicit

у нас таких рекувков может быть 1-3 а может быть и 33. поэтому таймайт может быть разным.

что еще важно и интерсно. 
если сделали

 socket()
 connect(ip=172.16.10.100)

то ядро леезет в таблицу маршутиацзии. причем даже не ради самого tcp\ip пакета а для арп 
пакета для начала, точнее эзернет пакета, потому что как составит арп пакет ядро знает
а вот как сотавить эзернет пакет в который будет вложен арп пакет ядро незнает. нужен 
src mac и нужно имя интерфейса через который будет выпллюнут эзернет пакет+арп пакет и еще
в арп пакете нужно вставить src ip нашего хоста тоже ккак ни странно. все это ядро
берет из таблицы машрутизации. из маршрута 

	172.16.10.0/24 dev br0 proto kernel scope link src 172.16.10.1 metric 425

из этого маршрута ядро возьмет - что сетевая карта это br0. из нее ядро будет высирать 
арп запрос. src ip ядро возьмет как 172.16.10.1 и src mac ядро возьмем залезши в 
свойства br0 

$ ip -c link show dev br0
9: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000
    link/ether f6:72:b2:f6:dd:ce brd ff:ff:ff:ff:ff:ff


вот сколько всего нужно ядру узнать. и все это он ухнает из таблицы маршуртаицзии.


так вот если мы добавим bind()

 socket()
 bind(12.12.12.12)
 connect(ip=172.16.10.100)

то тогда src ip из таблицы маршрутиазации искать ненадо! мы его уже сразу задали.
так что bind() вот как на что он влияет. он нетлоко исползуется в случаях создания слушающих
сокетов нет. если перед connect() не задали бинд ядро все равено делает бинд только делает
оно это уже сама автоматом из своих соображений. по факту bind() заносит ядрес source ip
в свойства сокета. дело в том что именно с сокета начианется путь сетвеого пакета внутри ядра.
в сокете указываются параметры севтовго соеднения. на оснвое него создается новый сетевой 
пакет. и именно в сокете находится буфер отправки. в который этот приготовлыенный пакет суется
ядром как буфер прежде чем он далее будет направлен в netfilter а оттуда уже в сеть!
но от того что мы задали в явном виде source ip пакета через bind() это не значит что 
ядру не придется заглядывать в таблицу маршраутизации. приедтся. потому что ядру надо понять
через какой сет интерфейс высирать будущий пакет. ршение принимается на оснвове dest ip и 
куда оно лучше подходит в таблице маррушутиацзии. в какой мррщрут оно лучше подходит.
итак решенеи через какую сет карту высирать арп реквест принмиается на освное dest ip 
и  на основе него поиска налучшего подходязего к нему маршрута в таблице маршрутиацзии. 
если мы незадаем source ip то таковой берется из  ip интерфейса котоырй мы нашли из 
таблицы маршрудтиацзии. если же соурс ип мы задали в явном виде через bind() то ядро высрет
из сет карты пакет у которого соурс ип  не сооствтуует ип адресу сет карты через которую
пакет был высран в сеть. 

есть и еще тонкость. вернеся к случаю когда мы bind() не задали


 socket()
 connect(ip=172.16.10.100)

ядро залезло в табицу маршрутиацзии и на оснвое dest ip нашло  маршрут
	172.16.10.0/24 dev br0 proto kernel scope link src 172.16.10.1 metric 425

значит ядро будет бросать арп пакет в сеть через br0.
и далее уже tcp\ip пакет тоже будет брость в сеть именно чрез br0.
и будет в этом пакете посдтавлять src ip  какой? и тут очердная тонкость. дело в том
что на самом интерфесе br0 может быть куча ип адресов. и также в маршруте есть парметр src

		src 172.16.10.1

так вотесли в маршруте есть параметр src то ядро не смотрит какие у интфрейса br0 ест 
ип адреса. ядро тупо будет подствлвть в пакет src ip = 172.16.10.1
а вот если  в маршруте не указан параметр src тогда ядро лезет в своства сетевой карты
br0 ищет там каикие у нее ип адрес и если их много то ядро на основе некоторых соображений
выибирает один из  его ип адресов и  исползует его для подставновки в свой арп пакет
и в tcp\ip пакет  в поле src ip ! во какая ебала!

более подробно ебалу по вопросы выбора какой src ip нужно подствлять в tcp\ip пакет
для исходящего с компа пакета я рассматриваю отдельно в local-global-host.txt


а щас я хочу посто акцентировать внимание вот какой механизм у ядра при вызове 

		connect()

есть для определения что удаленный хост недоступен.

