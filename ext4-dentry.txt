| ext4
| dir

 

хотел на счет каталогов рассказать. 
началось вот с чего. я зашел в каталог 

  /lib

и в нем я начал смотреть файл 

	ld-linux.so.2

тоесть полный путь к файлу

	/lib/ld-linux.so.2

и вот смотрю его свойства

 $ stat /lib/ld-linux.so.2
  File: /lib/ld-linux.so.2 -> ../lib32/ld-linux.so.2
  Size: 22        	Blocks: 0          IO Block: 4096   symbolic link
Device: 254,0	Inode: 3453425     Links: 1

вижу что это симлинк. 
и указывает он на файл 

	../lib32/ld-linux.so.2

и я такой  а ну значит надо перейти на уровень каталога выше и там надо искать каталог /lib32.
мой текущий уровень это /lib значит более верхний каталог это / 
я перехожу туда и ищу там каталог lib32
но там такого каталога нет! нет в корневом каталоге каталога lib32 ! я такой что 
за нахуй?! так где же файл то лежит?

оказывается - дело в том что у меня каталог /lib это не каталог а ебная симлинк! 
 stat /lib
  File: /lib -> usr/lib
  Size: 7         	Blocks: 0          IO Block: 4096   symbolic link


поэтому окзывается что мой файл 

 	/lib/ld-linux.so.2

он на самом деле лежит в 

 	/usr/lib/ld-linux.so.2

и так как это симлинк который указывает на  ../lib32/ld-linux.so.2
то значит папка ".." это папка "/usr" и значит папка lib32 она лежит не в "/" 
а лежит внутри "/usr" и значит на смомом деле файл искомый лежит в 

	  /usr/lib32/ld-linux.so.2

еще раз  -  я зашел в папку /lib и там лежал файл симлинк ld-linux.so.2
и он указывал что он указывает на файл  ../lib32/ld-linux.so.2
соотсввтенно я вижу что мне нужно перейти в папку ".." так как моя текущая папка /lib
то я получается мне нужно перейти в "/" и там искать папку "lib32".  я перешел в "/"
но там папки "lib32" нет. и я не понял. а прикол в том что исходная папка "/lib" в которую
я вошел это не папка а симлинк на папку! симлинк на папку /usr/lib  

    /lib --->  /usr/lib  


поэтому когда   я вошел в папку /lib то я не вошел в папку /lib а я на самом деле 
вошел в папку /usr/lib ! и тогда папка ".." это будет папка "/usr" !
и поэтому папка lib32 она лежит внутри папки /usr

а все дело в чем - в том что как работает ОС когда мы просим открыть файл который не файл 
а файл-симлинк  или я открываю не папку а папку-симлинк  - так вот ОС что делает - она 
считвает симлинк и смотрит куда он смотрит. а потом в итоге ОС открывает тот файл или папку
на который укзывает симлинк. поэтому я когда "вошел" в папку-симлинк  /lib то я  по факту
вошел в папку /usr/lib а ято думал что вошел в папку /lib. но ос то об этом не сообщает!
поэтому когда мне стало нужно перейти в папку ".." то мне надо было перейти в папку /usr 
но никак не "/"

И ЗНАЕШЬ В ЧЕМ ЕЩЕ ОГРОМНОЕ НАЕБАЛОВО - КАК ТЫ ОПРЕДЕЛЯЕШЬ В КАКОЙ ПАПКЕ ТЫ СИДИШЬ СЕЙЧАС?
ПРАВИЛЬНО - МЫ ЮЗАЕМ КОМАНДУ 

   $ pwd

ТАК ВОТ ! - ЕСЛИ Я ИМЕЮ ПАПКУ СИМЛИНК /LIB КОТОРАЯ УКАЗЫВАЕТ В ПАПКУ /USR/LIB  И Я ВХОЖУ
В ПАПКУ /LIB А ПО ФАКТУ ТО Я ВОШЕЛ В ПАПКУ /USR/LIB НО ЕСЛИ Я СПРОШУ PWD В КАКОЙ ПАПКЕ Я СИЖУ
ТО ОН МНЕ СУКА ПОКАЖЕТ ЧТО Я СИЖУ В ПАПКЕ /LIB !!!! И В ЭТОМ ОГРОМНЫЙ ПИЗДЕЦ - О Г Р О М Н Ы Й 
П И З Д Е Ц ! 

поэтому я когда вошел в симлинк-папку /lib а ято этого незаметил и по факут ос то меня засунула
в /usr/lib папку. и я спросил у ос в какой я щас папке? и мне ос сука сказала что я сижу в папке
/lib !!! это просото пиздец. ведь по факту я сижу в папке /usr/lib! поэтому утилита pwd это утилита
пиздежник. оне сука НЕ СООБЩАЕТ в какой ты папке реально сидишь! сука!

еще раз покаываю как все это воспроизвести:
  1) создаем симлинк на папку

      #  ln -s /var/log   /vasya

проверяем

 stat /vasya
  File: /vasya -> /var/log
  Size: 8         	Blocks: 0          IO Block: 4096   symbolic link

  2) теперь переходим в эту папку-симлинк 

     $ cd /vasya

  3) пытаюсь понять в какойже папке я сижу

	    $ pwd
		/vasya

	нихуя себе! по факту я щас сижу в папке /var/log а мне pwd показывает сука
	что я щас сижу в папке /vasya 
	это просто пиздец
	то что я сижу имено в папке /var/log я щас докажу. вот как я это сделаю.
	во первых посмотрим список файлов в текущей папке

		$ ls -1 *.log
		pacman.log
		socks.log
		Xorg.0.log
		Xorg.1.log


	тоесть видно что я сижу в лог папке. 
но я щас еще по другому докажу:
только вначале нужно сделать введение.
вот у нас есть имя папки. а что это такое? это такой параметр который записан внутри 
такой хрени как дентри. каждый денти содержит параметр имя в форме символов и параметр инода


  дентри 345
     имя = vasya
     номер иноды = 7345 

так вот где этот дентри хранится? он хранится внутри иноды-папка. инода-папка это такая инода
которая хранится на фс. зачем нам нужна инода-папка. потому что именно к иноде-папке обращаются
утилиты для того чтобы узнать какие файлы хранятся внутри фс. дело в том что файлы на фс
идентифицируются на осноче инод. их номеров. тоесть файлы созданые на фс представляют собой
в какой то степени кучу занятых инод. это не совсем так. но дрйаверу фс для того чтобы начать
работать с файлом нужно всего навсего указать номер иноды этого файла. но все таки для внешнего
мира фс нехочет предоставлять файлы в виде кучи номеров инод. номера инод это типа как внуьрнееняя
кухня драйвера фс при работе с файлами на фс. наружу для юзера для юзер спйеса для утилит юзер 
спейса драйвер фс выставляет файлы через несклко другой механизм. и механизм вот какой.  на фс
создаются другой тип инод. это иноды-папки. эти иноды не предназначены для сохранения через них
файлов. это иноды заводятся для другого. заводится первая особая инода-папка. она на ext имеет
всегда один и тот же номер inode=2 . она имеет фиксиованный размер. так вот мы берем эту иноду
и внутри нее начинаем сохранять список так назвыаемых dentry. каждый дентри состоит минимум
из двух полей. одно поле это номер иноды которая лежит на фс которая отвечает за какйото файл.
и второе поле это символный стринг. таким образом в этом дентри происходит привязка между
символным стрингом "vasya" и инодой которая отвечает за храненеие некоторого файла. таким
образом у нас в дентри файл "получает" свое имя. у нас в дентри происходит маппинг между инодой
которая отвечает за некоторый файл хранящийся на фс и некоторым символьным именем. еще
раз подчеркну что на фс создается два типа инод. одни иноды - файловые иноды в себе хранят информацию о файле. другой тип инод - это иноды-папки они хранят в себе список дентри хреней.
внутри одной иноды-папки может быть огромное количество дентри айтемов. каждый дентри нам позволяет
"присвоить" замапить номер какйото файловой иноды на символьное имя. ничего не мешает чтобы
у нас внутри одной иноды-папки были дентри которые указывают на одну и туже файловую иноду
но с разными стрингами. поазываю на примере пусть у нас нс фс создано два файла 

 		*файловая инода номер 134
 		*файловая инода номер 135



и пусть у нас на фс  создана одна инода-папка


 		*инода-папка номер 2
 		   **дентри номер 1
 		       номер файловой иноды 134
 		       стринг 'vasya'
 		   **дентри номер 2
 		       номер файловой иноды 134
 		       стринг 'petya'
 		   **дентри номер 3
 		       номер файловой иноды 135
 		       стринг 'kolya'


таким образом что нам дает инода-папка. если мы в нее каким то макаром заглянем то 
мы получим список дентри каждый из которых "подсвечивает" нам какой файл кроется внутри фс! 
тоесть драйвер фс он нам в юзер спейс не хочет в штатном режиме выдавать список файлов которые
хранятся на фс  в виде списка иноды котоыре заняты. нет драйвер фс так не хочет. нет. драйвер
фс так не хочет. если мы через драйвер фс создаем файл то помимо создания файла , помимо записи
информации о файле в иноду драйвер фс обяательно создает дентри про этот файл в иноду-папку.
в нашем случае это инода-папка N2. итак если мы создаем новый файл на фс то драйвер фс после
того как оформит инфо о файле в иноде-134 то драйве фс обязательно создаст +1 дентри внутри 
иноды-папки. и если мы со стороны юзер спейс программы хотим получить информацию о списке
созданных на фс файлов то мы должны  обратиться к иноде-папке N2 , считать список дентри
который хранится внутри и тогда получив список дентри мы узнаем какие файлы  у нас созданы на фс.
такого что файл создан и занимает иноду на фс и при этом у этого файла нет дентри внутри 
иноды-папки  = такого быть неможет. такого быть не может. если файл на фс создан он обязан 
он обязан иметь дентри внутри иноды-папки. поэтому есть прямое соотвесвтие - если файл сидит
внутри фс то у него есть дентри. если есть дентри значит внутри фс сидит файл. 
то есть вот мы смонтировали фс. и мы хотим узнать сколько и какие файлы сидят спрятанные внутри
этой фс. как это узнать? драйвер фс предлагает вот что -  открывай иноду-папку N2 и читай оттуда
список дентри. все файлы которые сидят спрятанные внутри фс об них обо всех будет инфо в этих 
дентри. это гарантирует драйвер фс. из каждого дентри мы узнаем номер иноды за которой кроется
файл.  и мы узнаем "имя файла". номер иноды нам особо ненужен он нам чисто для справки.
а вот "имя файла"  нам нужно затем что драйвер фс предлагает нашему юзер процессу имя файла 
как тот самый метод идентификации файла от юзера к драйверу фс. тоесть  юзер процесс читает список
дентри из иноды-папки . берет отдельный дентри. берет оттуда поле "имя файла" и далее процесс 
предьявляет это "имя файла"  к драйверу фс как метод идентификации файла. чтобы обьяснить 
драйверу фс с каким файлом мы просим его чтото сделать - прочитать его или изменить. а сам
драйвер фс получая скормленное ему "имя файла" делает тоже самое  - он читает все дентри 
из иноды-папки N2 . ищет там тот самый дентри который имеет поле с именем равное "имя файла"
и найдя этот дентри драйвер фс там прочитает в поле номер иноды которая отвечает за этот файл.
и далее драйвер фс имея номер иноды пойдет работать с этим файлом.  далее такой момент получается
используя дентри которая хранится внутри иноды-папки у нас  инода файла "получает" имя в форме
символов. говоря короче получает имя. так вот наша инода-папка она тоже имеет имя . это имя
равно "/" . это имя зашито внутри драйвера фс. тоесть если я пошлю запрос opendir()


		 DIR *p_dir = opendir("/");

тип DIR это так называемый стрим. не буду углубляться. 
вот синтаксис этой libc фнкции  

       # define  _POSIX_C_SOURCE  200809L
       #include <sys/types.h>
       #include <dirent.h>

       DIR *opendir(const char *name);


так вот когда мы из юзер спейса делаем запрос к ФС открыть папку ( используя специализированную libc функцию ) то мы указываем (согласно доктрине предписанной драйвером фс) в качестве идентифи
катора папки ее "имя" в данном случае "имя"="/"
поэтому мы формулируем запрос вот так


				opendir("/")


тоесть я пытаюсь выразить то что если мы хотим обратиться к иноде-папке N2 то мы драйверу фс
обьянсяем нашу просьбу выражая   какую-иноду папку мы просим его открыть не через номер иноды
а через "имя". в данном случае "/" потому что еще раз скажу что инода-папка 2 имеет заранее
известное фиксированное "имя" равное "/"

тоесть еще раз логика какая. я смонтировал фс. я хочу узнать какие там файлы на ней созданы.
для этого согласно доактирине ФС я должен зайти в иноду-папку , открыть ее. скачать список 
дентри. и тогда я увижу "имена" файлов которые созданы на этой фс. эти имена  я буду далее 
сообщать драйверу фс для того чтобы обьяснить драйверу фс  с каким файлом  я хочу далее 
работать. но для того чтобы открыть иноду-папку нужно драйверу фс сообщить иденитификатор
этой иноды-папки тоже в форме символного имени. тоесть иноды-папки они тоже имеют не только 
номер иноды где они хранят свои дентри но и "имя".  инода-папка номер 2 она имеет фиксированное
имя вшитое в драйвер фс это имя="/" поэтому если я хочу посмтреть список файлов существующих
на фс используем вот такой вызов


				opendir("/")


а вот пример программы которая показыает список всех файлов о которых есть записи внутри папки

 $ cat 281.c
#include <stdio.h>
#include <dirent.h>
#include <stdlib.h>

int main(int argc, char *argv[])  {




    // проверяю что программы была запущена с 1 аргументом
        if(argc != 2)
    {
    printf("\n Usage: %s </path/to/file> \n",argv[0]);
    return (1);
    }

    // печатаю считанные аргументы
    for (int i=0; i<argc; i++)
    {
    printf("argv[%d] = %s\n", i, argv[i]);
    }



    const char *dirpath = argv[1];  // Замените на путь к вашему каталогу
    DIR *dir = opendir(dirpath);  // Открываем каталог
    if (dir == NULL) {
        perror("opendir");
        return 1;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        printf("Name: %s\n", entry->d_name);  // Выводим имя каждого файла/каталога
    }

    closedir(dir);  // Закрываем каталог
    return 0;
}


$ gcc -o 281.exe 281.c

заупскаем

	$ ./281.exe /
argv[0] = ./281.exe
argv[1] = /
Name: .
Name: ..
Name: boot
Name: dev
Name: proc
Name: run
Name: sys
Name: bin
Name: lib
Name: lib64
Name: sbin
Name: etc
Name: home
Name: mnt
Name: opt
Name: root
Name: srv
Name: tmp
Name: usr
Name: var
Name: snap
Name: org
Name: vasya


подрбности кода этой программы я пока не буду обсуждать. главное это суть
что я использую по факту вот этот вызов

	opendir("/")

чеез который я прошу драйвер фс открыть иноду-папку 2 и выдать нам все дентри
которые там хранятся. а на экран я вывожу от этих дентри только поле "имя"

далее. значит если бы у нас на фс был бы только один инода-папка N2 в которую бы драйвер
фс создавал новый дентри +1 при создания нового файла то у нас бы в этой папке хранился бы
список всех файлов созданных на фс. но такой подход не удобен. потому что у нас на фс могут
быть миллионы файлов. поэтому удобно на фс создать много инод-папок. и в каждую папку
заносить инфо только о части файлов на фс. тоеть мы инфо обо всех файлах созданных на фс
распределим по целой куче инод-папок. можно было бы сделать как - можно было бы каждую
иноду папку сделать независимой от другой иноды папки. например. пусть у нас три иноды папки.

   инода-папка N2
   инода-папка N3
   инода-папка N4

каждой такой папке дать имя . причем инода с номером 2 у нас уже имеет имя это "/"

   инода-папка N2 
      имя="/"
   инода-папка N3
      имя="folder1"
   инода-папка N4
      имя="folder2"


далее мы создаем дентри про все файлы на фс равномерно в трех этих инодах-папках.
все хорошо. получается если мы хотим узнать инфо про одну треть файлов хранящихся на фс
то нам нужно будет вот такие сделать вызовы функций

		opendir("/")

либо

		opendir("folder1")

либо

		opendir("folder2")


для имени "/" драйве фс уже знает номер иноды на фс который отвечает за эту иноду-папку.
а вот вопрос как драйвер фс будет знать какой номер иноды отвечает за хранение
иноды-папки "folder1" либо иноды-папки "folder2"
один из подходов захардкодить номера инод в драйвере фс. скажем пусть это будут иноды 3 и 4
но в дррайвере фс тогда надо вшивать нетолько номера инод 3 и 4 но и названия папок символьные
"folder1"  "folder2". вобщем это неклеово. тем более если мы хотим иметь на диске не три папки
а миллионы папок. и тогда пошли другим путем. у нас только одна папка имеет фиксированное 
захардкоженное имя "/" и захардкоженный номер иноды это 2.  а имена других папок это вещь 
будет гибкая. и в каких инодах они хранятся это тоже все будет гибко. как же они сделали - 
мы даем к драйверу фс запрос на создания новой папки , так вот каждая новая папка она обя
зательно "увязывается" "привязывается" к другой папке которая уже существует на фс. привязка
новой папки к старой выражается через символный ряд. положим я хочу создать новую папку
с именем "vasya" у нас пока что есть на фс тлько одна папка "/" так вот  папка "vasya" она 
будет увязна привязана к папке "/"
поскольку папка "/" уже существует она назыается "родительская" а новая папка называется "дочерняя". и эта связь между ними в символольном виде выржается вот так 

 	  "/vasya"

тоесть имя родтельской папки ставится слева. а имя дочерней папки ставится справа.
и мы такое хитрое символьное название пихаем в функцию libc  которая попросит драйвер 
фс создать новую папку


        mkdir ("/vasya", 0666)

синтаксис 
    #define  POSIX_C_SOURCE 200809L
	#include <sys/stat.h>
    int mkdir(const char *pathname, mode_t mode);
углубляться в него не буду


важно то что произойдет при вызове такой функции

        mkdir ("/vasya", 0666)

значит драйвер фс распарсит наш "/vasya" выделит "/" и поймет что эта папка уже есть.
а "vasya" такой папки нет. ее нужно создать. драйвер фс выделить одну иноду из пула свободных.
напмример инода=14 заполнит  ее  чтобы она отвечала терованияем иноды-папки а теперь самый 
интересный процесс на счет сохранения имени.  дрйавер фс пойуде в родртельскую папку "/"
тоесть в иноду=2 и там создаст +1 дентри вот с таким содержанием

    дентри
      имя="vasya"
      инода="14"
      тип файла="папка"

тоесть информация о вновь созданной папке у нас записана и существует в "родительской" папке.
таким образом мы если сомнтируем нашу фс то мы узнаем о папке "vasya" только подключившись 
к папке "/" и там прочитав список дентри и его проанализирововвав. таикм образом в родртельской
папке есть информация об ее дочерних папках. но это еще не конец , драйвер фс также 
зайдет в иноду=14 и там создаст два дентри вот такие


    дентри
      имя="."
      инода="14"
      тип файла="папка"
    дентри
      имя=".."
      инода="2"
      тип файла="папка"


тоесть в дочерней папке будет записано что есть на фс две папки. папка с именем ".." содержит
иноду родительской папки. и папка с именем "." содержит иноду текущей папки. 
когда мы обращаемся к какойто папке. когда хотим открыть ее иноду то драйверу фс нужно 
сообщать полный путь от корневой папки "/" до нашей папки с полным указанием все папок на пути
тоесть если у нас есть папка "petya" у которой родтельская папка "vasya " у котоорой 
родитльская папка "/"  тогда если я хочу открыть иноду папки petya то  я должен указать полный 
путь от корневой папки до petya при подстановке в функцию 

        mkdir ("/vasya/petya", 0666)

зачем драйверу фс нужно предоставит все эти отношения кто кому родитель. потому что мы 
записывая строку "/vasya/petya" мы сообщаем драйверу фс вот такой текст:
  эй драйвер фс открой мне иноду папки "petya" у которой есть родитель папка "vasya" у
  которой есть родитель папка "/"

ксати у каждой папки есть толко один родитель. такого нет что папка имеет несколько родителей.
тут я поясню это такими словами - если для файла можно создать кучу хардлинков как в одной
папке таки в разных то для папки нельзя создаст хардлинк. он толлько один и только тот который
создал сам драйвер фс.

так вот эта история кто кому родртель включая вплоть до "/" папки нужна драйверу фс лдя 
того чтобы он мог найти номер иноды конечной нашей папки. потому что драйер фс работает с файлоами
и папками через номер иноды. и дрйвер фс как делает. он берет папки "/" он знает ее иноду=2
это всегда так. он открыает эту иоду. скачивает все дентри. и ищет срединих тот дентири который
имеет имя "petya". нашел этот денти. смотритт какой нмоер иноды указан в теле этого дентри.
пусть это инода=20. дале драйвер фс открыает иноду=20 оттуда скачивает все дентри. ищет там
тот в ктором имя=petya. нахдодит этот дентри и ищет там номер иноды. например это инода=33
и вот тольо благодаря всем этии указанным детям родителям драйвер фс смог найти номер иноды-папки.
замечу что имя "vasya" иноды-папки в которую мы хотим попасть не хранится в иноде которая 
отвечает за эту папку вот вернеися к этому примеру

        mkdir ("/vasya", 0666)

у нас инода=2 имя="/" это имя нехранитс на диске нигде потому что это особая папка.
имя хранится толко в драйвере фс.
инода=15 имя="vasya" и это имя хранится внутри инод=2


    инода=2
      дентри
        имя="vasya"
        тип=папка
        номер иноды=15


содержимое иноды=15
      дентри
        имя="."
        тип=папка
        номер иноды=15
      дентри
        имя=".."
        тип=папка
        номер иноды=2


тоесть внутри самой иноды=15 у нас имя "vasya" нехранится. драйвер фс такого неделает.
и руками такого он тоже недаст сдлать.  внутри самой иноды 15 ссылка на иноду 15 идет 
под именем "."  
тоесть я хочу скзаать что если мы  открыли иноду=15 то мы из ее контента хер узнаем в какой
папке мы щас находиимя. нам для этого нужно открыть родтельсукую иноду-папку которую мы
опрееделим из дентри с именем ".."
      дентри
        имя=".."
        тип=папка
        номер иноды=2
 
ттгда мы подуем в иноду=2
и там мы будем искать дентри у которого будет поле инода= тому же самому что у 
нас  в текущкй иноде хранится в дентри с имнеем "."

      дентри
        имя="."
        тип=папка
        номер иноды=15

тоесть мы внутри инод=2 будем искать дентри с записью "номер иноды=15"


    инода=2
      дентри
        имя="vasya"
        тип=папка
        номер иноды=15

и только там мы поймем что папка в которой мы сидим это окзаватеся имеет имя "vasya"

вот плюс минус зачем нужно драйверу фс создавать эти нпепонятные дентри с "." и ".."

так вот я возвращаюсь к вопросу о том что вот мы зашли внутрь папки "/lib"
котоаря на самом деле естьпапка "/usr/lib" но как это доказать? доказать можно
через номер иноды. 

посмотрим на вид типичной папки


содержимое иноды=15
      дентри
        имя="."
        тип=папка
        номер иноды=15
      дентри
        имя=".."
        тип=папка
        номер иноды=2

если я хочу узнать иноду котоаря хранит инфо о текущей папке то нужно запросить информацию
из дентри с именем "."

  $ cd /lib
  $ stat .
  File: .
  Size: 159744    	Blocks: 448        IO Block: 4096   directory
Device: 254,0	Inode: 166         Links: 210

мы видим что папка в которую мы перешли имеет иноду 166

теперь перейдем в папку /usr/lib и проверим какая у нее инода
 $ cd /usr/lib
 $ stat .
  File: .
  Size: 159744    	Blocks: 448        IO Block: 4096   directory
Device: 254,0	Inode: 166         Links: 210


как видим та же самая а двух папок как и врочем двух файлов с одинаковыми инодами не бывает
поэтоу когда мы через cd переходим в папку которая символьая сссылка то на самомо
деле мы попадаем в ту паку на котторую покзывает эта симлваная сссылка

насчет утилиты pwd
у нее есть две опции
  

   -L
   -P 


если мы запускаем 

   # pwd -L 

то эта утилита определяет в какйо папке мы щас сидим считвая переменную окружения PWD=
из баша. тоесть запрос к дайрверу фс даже не происходит. и практика показал что если 
я делаю переход
  
  $ cd /lib

где lib это символьаня ссылка то переменан окружения PWD= будет равна PWD=/lib
и мы полуим на экране

  /lib 

что херная полная! и кстати запуск pwd без параметров походу так и делает.

а если мы запустим

  $ pwd -P 

то уже у нас эта прого определит именно настоящую папку которой мы сидим. 
поазыавваю на прмирее

	 $ stat /lib
  File: /lib -> usr/lib
  Size: 7         	Blocks: 0          IO Block: 4096   symbolic link

  	$ cd /lib

	$ /usr/bin/pwd -L
		/lib                  <==== БРЕХНЯ

	$ /usr/bin/pwd -P
		/usr/lib              <==== ПРАВДА



в иттге  я чтобв такую хуйню уже больше не ппопадать я сделал алиас для pwd

		 $ grep pwd < ~/.bashrc
			alias pwd='pwd -P'

и теперь у меня pwd заупскается всегда с ключом -P


