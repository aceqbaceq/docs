| udp

udp поток принимется через SOCK_DGRAM сокет.
а tcp поток принимается через SOCK_STREAM

так вот в чем DGRAM отличается от STREAM ?

в частности вот в чем. - если я посылаю из хоста1 из программы1  в tcp сокет вначале 10 байт
а потом 5 байт то они прилетают в сокет хоста2 то ядро хоста2 оно расппкаоывавает пакеты
и выбрасывает их а их контент тупо складывает в сокет в виде 15 байт. и программа2 может 
читать из сокета любыми кусками. хоть по 1-му байту. хоть вначале 8 а потом 7 байтов. все байты
будут в итооге переданы в программму.


а если у нас прогармма1 через сокет udp шлет в ядро хоста1 вначале 10 байт а потом 5 байт
то на хоста2 прилетает два пакета 10 байт и 5 байт пейлоад. и в отличии от tcp потока где
все пакеты считаются что они составляют часть чегто целого( как дольки яблока или страницы
книжки) то в udp потоке каждый пакет(датаграмма) СОВЕРШЕННО НЕЗАВИИСИМ от друогого пакета. 
поэтому будет фундаментально дрнуая кариитина а именно.  положим в буфере udp сокета 
сверху лежит пакет 10 байт. и мы через программу2 задааем команду на чтение. и в этой команде
мы указываем что размер переенной в котрорую мы просим ядро положит данные равен 4 байта.
то ядро положит нам 4 байта из датаграммы размером 10 байт. а дальше самое интерсное.
если мы дадим команду на повторонео чтение 4 байта то эти 4 байта уже буудут считываться из 
второй датаграммы размером 5 байт. а контент первой датаграммы уже будет ядро выкинут 
унитожен. поэтому мы безвовратанопотеряли 6 байт которые мы непрочитали за первую команду.
тоесть при запросе на чтение из udp сокета мы обязаны задать такой размер перменной чтобы ее
хватило засосать контент udp датаграммы за 1 присест. все те байты которые мы не прочитаем 
за 1 присест из датагарммы будут потеряны и уничтожены. каждая сдледущая команда чтения читает
данные ИЗ СЛЕДУЮЩЕЙ ДАТАГАРРРАММЫ. в этом фунтадмтельнешая разница между чтением из udp сокета
и tcp сокета. 


итак еще раз. у нас на компе-А tcp сокет. и на компе-Б tcp сокет. мы на компе-А делаем
две команды на запись. размер 10 байт и 5 байт. какого размера будет пакет которй ядро отошлет
неивестно. наверное он будет в итоге один. а может и не один. 
а если у нас бы бы udp сокет  то  у нас бы точно комп-А послал два udp пакета. в одном
в пейолоаад было бы 10 байт. а во втором было бы 5 байт. 
так вот принимающая сторона комп-Б она запускает два раза подряд команду на чтение и размер
переменной на примем имеем размер 4 байта. коода мы читаем из tcp сокета то у нас в сокете
лежит 15 байт вместе слепленых. и первое чтение выдаст на первые 4 байт. а второе чтенеине
нам выдаст вторые 4 байт.
если же мы читаем из udp сокета то первое чтение нам выдаст 4 байта из первой датаграммы.
а вторе чтение нам выдаст 4 байта из второй датагарммы. после певрого чтения первая датаграмма
будет уничтожена ядром и все ее байты котоыре мы недочитали будут потеряны. вторео чтение
нам выдаст 4 байта из второй датаграммы. при этом после этого сразу эта датаграмма будет 
уничтожена. и все байты коорые в ней лежали а мы их не успкли прочитать будут потеряны. 

ксттаи команды read() write() они неработают на udp сокете. эти команы только работают на 
conection oriented протоколах. тоест на tcp. а на udp они неработают. вместо них используются
коанды recv() recvfrom() sendto()


теерь пример двух программ. это udp сервер и udp клиент.


серверная часть
 $ cat 375.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#define MSGSIZE 12  


int main() {
    int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sockfd < 0) {
        perror("socket");
        exit(1);
    }

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9090);
    if ( inet_aton("127.0.0.1", &addr.sin_addr) == 0 ){
           perror("aton error");
           return 1;
    };

    if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        close(sockfd);
        exit(1);
    }

    printf("UDP Server running.\n");

    char buffer[MSGSIZE];
    memset(buffer, 0, sizeof(buffer));
    ssize_t rv;

for (int j=0; j<2; j++){
    if (   (rv = recv(sockfd, &buffer, sizeof(buffer)-1, MSG_TRUNC|MSG_WAITALL))  < 0  ){
         perror("recv error");
    };
    buffer[MSGSIZE-1] = 0x00;
    printf("\nRead datagram from kernel\n");
    printf("the message is  %s \n", buffer);
    printf("the length of the the message is  %i \n", strlen(buffer));
    printf("Original datagram Size = %i bytes.\n", rv);

}

    pause();  // Ожидаем завершения
    close(sockfd);
    return 0;
}




значит создаем сокет udp

    int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);



далее мы заносим ip адрес и порт 127.0.0.1:9090 который будем слушать ядро на udp протколе

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9090);
    if ( inet_aton("127.0.0.1", &addr.sin_addr) == 0 ){
           perror("aton error");
           return 1;
    };


и чрез bind() мы засосвыаем эти параметры в сокет в настройку каасающуюся столбика 
"local IP:local_port"

    if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
        perror("bind");
        close(sockfd);
        exit(1);
    }

так как это udp тоу нас нет деления сокетов на слушающий и обрабатывающий. поэтому 
listen() тут не ненужен. тоесть если бы мы работали с tcp то нужно было бы запустить

  socket()
  bind()
  listen()
  accept()

то в случае udp нужно всего лишь

	socket()
	bind()

и все. уже это у нас сервер. и можно принимать датаграммы.


дальше на этом сокете я принимаю udp датаграммы

    rv = recv(sockfd, &buffer, sizeof(buffer)-1, MSG_TRUNC|MSG_WAITALL)) 



комана recv() она читает из udp сокета. по дефолту это блокирующая фнкция. тоесть если в сокете
нет ни одной датаграмы то процесс наш спит. 
первый параметр это дескриптор сокета из которого читаем
вторйо прараметр это поинтер на переменую куда ядро запишет пейлоад из датаграммы
треятий параметр это размер нашей переенной
если пейлоад датагарраммы больше чем размер нашей перменной то просто напросто ядро сколько 
сможет сколько и запишет в нашу переменную. если размер нашей перменной блоьше чем размер
датаграмы то все тело датаграммы будет записано в тело нашей пеерменнй. 


флаг MSG_TRUNC он делате то что в нас в rv ядро запишет размер датаграммы в ядре. 
это нам дает то что мы можем сравнить склько байт у нас лежит в переменной. с размером rv 
и тогда если rv > размер нашей переенной то это значит что мы счттали толкьо часть из 
датаграмы. а остальное мы просто безвозвратно потеряли. 

почему я делаю sizeof(buffer)-1  , потому что я преетсраховыаюсь и в поледний байт
моей перменной я ниже сую 0 байт 

    buffer[MSGSIZE-1] = 0x00;

потому что далее я буду эту перееменную печатать через printf %s и мне обязатено нужно чтобы
на конец моей пееренной гарантиовано стоял 0х00 байт. 

у нас макс размер udp пелоад может быть 65КБ. оэтому если я хочу 100% быть уверенным что
все тело датаграммы я проитаю за одну команду на чтение то мне надо сделать чтобы размер
моей пееренной было 65КБ или чуть больше. 

флаг MSG_WAITALL дает то что там где это возможно ядро не будет возвращаться из этой
фкнции пока ядро не заполнит всю нашу переменную до конца. однако в рамках udp сокета
она в общем то не имеет занчения на саоммом деле. она имеет смысл больше для tcp сокета.
потому что если у нас скажем рзмер меерменной 1МБ. то ядро пока не накачает этот 1МБ данными
из сокета оно управление обратно невернет. так вот работает этт флаг только в случаях кода
это имеет смысл. так вот в случае udp он нерабоате. потому что. если у нас прилетел udp дата
грамма размеро 10 байт пейлоад. а у меня скажем размер перменной 1МБ то у меня будет считано
10 байт из ядра и положено в пеерменную buffer. и тут же ядро верентся из recv() почему.
поьому что хоят переменая наша незаполена до краев данными но так как каждая датаграмма 
независит отдругой то данные из следущей датаграммы не имеют отншения к ткущим 10 байтам.
следуюащая датагармма она может приелеть вообще от другого отправлиетелся. поэтому следущи
байты не имет отноения к текущим 10 байтам. поэтому возврат будет сделано мгнвоенно. и 
плевать на этот флаг. 

итак если отправитель делает sendto() и сует 10 байт. то ядро сразу сформиурет датаграмму
и пошлет ее.  если отправитель потому сует в sendto()  5 байт то это будел слещудщая 
жатаграмма котоаря независит от предыдущей. эти обе датаграмы прилетят на наш комп
и во время каждого запроса на чтение у нас будут данные ядром переносистя в нашу перменную
только в рамках одной датаграммы. и все что мы за 1 присест не считали будет потеряено.


далее я 
печатаю байты котоыре мы вернул recv()
я печатаю сколько по факту байт у меня было засунуть в buffer
я печатаю какая по факту была длинна датаграммы из котоорой мы получили данные

    printf("the message is  %s \n", buffer);
    printf("the length of the the message is  %i \n", strlen(buffer));
    printf("Original datagram Size = %i bytes.\n", rv);







теперь код клиента UDP

$ cat 376.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <arpa/inet.h>



int main() {
    int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sockfd < 0) {
        perror("socket");
        exit(1);
    }

    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9090);
    if ( inet_aton("127.0.0.1", &addr.sin_addr) == 0 ){
           perror("aton error");
           return 1;
    };
    printf("UDP Client running \n" );


    char buffer1[20] = "123456789ABCDEFGHIJ";
    ssize_t sv;
        sv = sendto(sockfd, &buffer1, sizeof(buffer1), 0, 
                        (struct sockaddr*)&addr, sizeof(addr));
        if ( sv  < 0 ){
	       perror ("send error");
    	       return 1;
        };
    printf("Sent %i bytes, message = %s \n", sv, buffer1 );
    sleep(10);



    char buffer2[20] = "ABCDEFGHIJ123456789";
        sv = sendto(sockfd, &buffer2, sizeof(buffer2), 0, 
                        (struct sockaddr*)&addr, sizeof(addr));
        if ( sv  < 0 ){
	       perror ("send error");
    	       return 1;
        };
    printf("Sent %i bytes, message = %s \n", sv, buffer2 );
    sleep(10);
    




    sleep(1);  // Ожидаем завершения
    close(sockfd);
    return 0;
}




здесь мы
создаем сокет udp

    int sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sockfd < 0) {
        perror("socket");
        exit(1);
    }



потом я заполняю структ в который сую ip:port на котоырй мы будем слать данные
это 127.0.0.1:9090
кстати  у меня нестаданртно.обычно клиент стучит на сервер чтобы чтото прочитаьу
у меня по ругому . я стучу на сервер чтобы туда чтото пеедать


    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(9090);
    if ( inet_aton("127.0.0.1", &addr.sin_addr) == 0 ){
           perror("aton error");
           return 1;
    };
    printf("UDP Client running \n" );





далее я пихаю в udp сокет строку   "123456789ABCDEFGHIJ" через sendto()


    char buffer1[20] = "123456789ABCDEFGHIJ";
    ssize_t sv;
        sv = sendto(sockfd, &buffer1, sizeof(buffer1), 0, 
                        (struct sockaddr*)&addr, sizeof(addr));



где
sockfd = это дескриптор сокета
&buffer1, sizeof(buffer1) = это поинтер на переенную из которой ядро берет байты чтобы
совать их всеть. именно в теле этой перменно и сидит строка "123456789ABCDEFGHIJ"
и это размер нашей пеерменной
(struct sockaddr*)&addr, sizeof(addr)  = это поинтер на структуру которая обяьсняет sendto()
на какой udp IP:port нужно слать данные в сеть. и размер тела переменной на которую укаызает
этот поинтер. ну и еще исползется casting чтобы наврать си прогармме что якобы потинтер указывает
на переменную другого типа. не sockaddr_in а sockaddr. это ебанистическая тема подробно
расссаана в ффайле "c-array-pointer.txt"

таким макаром мы указали куда слать и что слать.


второй кусочек

    char buffer2[20] = "ABCDEFGHIJ123456789";
        sv = sendto(sockfd, &buffer2, sizeof(buffer2), 0, 
                        (struct sockaddr*)&addr, sizeof(addr));
        if ( sv  < 0 ){
	       perror ("send error");
    	       return 1;
        };

делает тоже самое что предыдущий. шлет 20 байт в сокет. просто строка имеет другой
конент "ABCDEFGHIJ123456789"


итак у нас по факту на udp 127.0.0.1:9090 шлется две строки

	"123456789ABCDEFGHIJ"
	"ABCDEFGHIJ123456789"


длина каждой строчки 20 байт. поэтому на ут сторону прилетит 2 датаграммы у кажой тело
пейлоад имеет 20 байт длиной.


значит запускаем сервер. в нем я делаю чтение в пеерменную длиной 12 байт.
но последний байт  я в него ничего не пишу он  у меня 0х00 поэтому по факту я читаю
из сокета по 11 байт. тоесть мне из сети приелает две датаграмы по 20 байт но я за одну 
команду на чтение recv() читаю только 11 байт. 
при таком подходе я хочу доказать проверить убедиться что во время второго чтения у меня
будет счиываться контент уже из другой датаграммы. а не предудыдущей . не смотря на то что
я не счиатал все тело датаграмы. 

запускаем сервер . запускаем клиент.

клиент на экарне нарисует
	./376.exe
	UDP Client running 
	Sent 20 bytes, message = 123456789ABCDEFGHIJ 
	Sent 20 bytes, message = ABCDEFGHIJ123456789 




сервер на экране нарисует
	UDP Server running.

	Read datagram from kernel
	the message is  123456789AB 
	the length of the the message is  11 
	Original datagram Size = 20 bytes.

	Read datagram from kernel
	the message is  ABCDEFGHIJ1 
	the length of the the message is  11 
	Original datagram Size = 20 bytes.



и вот мы видим что клиент нам прислал через датаграму 123456789ABCDEFGHIJ
но я из нее прочитал 11 байт и ядро положило мне в память программы байты 123456789AB
если мы их посчитаем то их 11 как я и заказал.

и вот самая соль во второй части вывода на экран

	Read datagram from kernel
	the message is  ABCDEFGHIJ1 
	the length of the the message is  11 
	Original datagram Size = 20 bytes.


это у мен результаты второй команды на чтение. если бы ядро продолжало читать из первой
датаграмы то оно мы бы увиели на экране чтото типа такого
 

   CDEFGHIJ

 но мы видим на экране сосвем другое

 ABCDEFGHIJ1


потому что ядро нам уже сует в нагу прогарммы данные ИЗ ВТОРОЙ ДАТАГРАММЫ!  а то что мы не прочиали
из первой уже в помойке. оно пропало. потеряно. егоуже нет. вот в чем соль SOCK_DGRAM протоколов
в частности udp в отичие от tcp(SOCK_STREAM)

и мы видим кдый раз строчку

	Original datagram Size = 20 bytes.


котоаря сообает что вообще то тело датаграммы пейлоад часть была 20 байт. а ято 
читал по 11 байт. 


вот в чем офигенная разница между udp и tcp


еще насколко я понимаю что в tcp если мы сдеали слушаюзий сокет через listen() то 
насклоько я понимаю дескриптор данного сокета не получится использовать для исходящего 
конекта. потому что это уже слушающий сокет. все.
а в udp у нас нет слушающего сокета. и поэтому я сокет котоырй созал в серверной пргамме
я могу его использовать однроменно и для приходящих udp датаграм. и для исходящих от меня
датаграм.










