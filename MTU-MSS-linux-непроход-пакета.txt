случай. кейс.

есть комп-А он сидит за гейтвеем. так вот по ссш связь с ним связь с других
компов которые сидят в той же сети = нет проблем. тоесть связь по локале между компами проблем нет.
но если мы идем по ссш на комп-А через гейтвей то у нас проблемы. а имеенно.
вот мы зашли по ссш вроде норм.  но если я запускаю какую нибулдь команду  в баше которая 
имеет массированный листинг например 

  # iptables-save

но  у меня связь по ссш подвисает. не отваливается а именно зависает.

сразу скажу в чем было дело. дело оказалось в том что гейтвей оказался ни причем.
а за гейтвеем был свич на котором на портах был установлен маленький MTU на портах. 
и получалось так что ссш пересылает пакеты разной длины есть и короткие 
есьт и длинные. пока пакеты летят короткие то их тот свич пропускает а когда 
летят пакеты длинные то их свич не пропускает а режет.


а теперь все подробно.


вот у нас есть эзернет фрейм. 
он имеет формат 

14 байт заголовок
 4 байта CRC сумма на конце ( я нашел инфо что формально CRC сумма не относится к заголовку)
 и остается пейлоад. 


также если у нас фрейм тегрованный то добавляется 4 байта на вилан шнягу.
и если у нас пакет Q-in-Q то добавляется еще 4 байта.

забавно то что в одних источниках CRC 4 байта пишут что он тоже входит
в заголовок а в других пишут что он конечно входит в состав фрейма
но к загловку не отосится.

макмимальный пейлоад опрееделнный стандартом эзернет это 1500 байт.
как я понимаю джамбо фреймы с 9000 пейлоадом это некий исключительный эксклюзив.

так вот эзернет payload его максимальный размер называется в обиходе MTU.
понятно что у нас пейлоады бывают разного размера. (минимальный врде бы 46 байта чтоли).
так вот именно размер максимального пейлоада в эзернет фрейме называется MTU

он в итоге может быть и меньше чем 1500 байт , зависит видимо от того свича к которому
подключается порт компа.  

итак MTU этот макс размер байтов который может в себе нести один эзернет фрейм
в данной сети. 

обычно внутри эзернет пейлоада летит IP пакет.  поэтому из этого получается
что MTU ограничиывает какой макс длины ип пакет можно передать в одном
эзернет фрейме.

длина хидера ип пакета это 20 байт.
внутри ип пакета часто лежит tcp пакет. хидер тцп пакета может иметь разную 
длину 20 - 60 байт. в зависимсти от. но он всегда кратен четырем байтам.

тогда получается вот что . положим мту 1500. положим что тцп хидер это 20 байт
тогда получается что 

   1500 - 20  - 20 = 1460 байт

это макс размер дннных которые можно всунуть внутрь тцп пакета в один эзернет фрейме  в данной L2 сети


так вот  этот макмисмльный тцп пейлоад назыается MSS
вот кстати хорошая вырезка про mss

   https://www.cloudflare.com/learning/network-layer/what-is-mss/



теперь я расскажу как работает связь между двумя приложениями через tcp.
с точки зрения приложения тцп конект это просто переменная (сокет) куда прилоение пихает 
запиывает байты. причем за одну запись можно совать кусок байтов любой длины.
данные запимсыаются в буфер в ядре. который лежит в сокете.  а потом ядро берет эти байты
и уже само решает какого размера взять кусок из буфера, запоковать его в тцп пакет, потом 
запоковать его в ип пакет. и потом  в эзернет фрейм. тоесьт кусками какого размера
пихать пакеты в сеть решает само ядро. приложение никак на это не влияет. 
условно говорят приложение пишет байты разными кусками как буттто в вобычсный 
файл на диске. а уже потом ядро нарезает этот "файл" разными кусками и шлет 
его по сети  в форме пакетов разной длины.
так вот как это работает на практике. 
вот ядро видит что в сокете/буфере появились данные. ядро смотрит на свойства сокета
там указан dest ip. ядро смотрит на табилцу маршрутиации. находит там тот порт
через который совать данные в сеть.
далее ядро (внимание) смотрит какой MTU мы задали на этом порту


 enp5s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether a8:a1:59:00:0f:2c brd ff:ff:ff:ff:ff:ff
    altname enxa8a159000f2c

этот мту мы можем легко менять на лету.
в данном случае мту равен 1500.
тоесть ядро понимает что л2 сеть такова что в одном фрейме можно с этой карты
отослать пейлоад размером 1500 байт. значит ип пакет макс длины может быть 1500 байт.
далее ядро отнимает от него 20 байт тоесть 1480 и понимает что такого макс размера может быть
пейлоад в ип пакете. далее несмотря на то что хидер у тцп пакета вобще то имеет разную длину 20-60 байт
но ядро отнимает  именно 20 от 1480 тоесть получает 1460 байт и считает что вот это есть макс размер
пейлоада который можно всунуть внутрь тцп пакета так что это все уместться внутри одного эзернет
фрейма. тоесть ядро получает чему равен mss.
тоесть ядро высчитало mss, mss=1460 байт
и ядро формирует IP+TCP пакет с флагом SYN (тот самый SYN пакет) и  в нем же ядро указывает mss=1460
и отслывает его на дестинейшн комп.
таким образом наше ядро сообщает удаленному ядру какой mss имеет его сет карта.
таким макаром наше ядро сообщает удаленному компу какой MTU имеет его сет карта. это ксати значит что 
скорее всего такой же MTU имеет и свич к которому эта карта поключена. а чем прикол если у нас есть 
порт и на него прилетает каким то образом эзернет фрейм у котрого размер больше чем (MTU+заголовок эзернет фрейма)
а будет то что наш порт такой фрейм отбросит. 
еше вот какой вариант возможен.
скжаем наш комп подклчен к роутеру. у роутера два порта. один L3 обрашен в инет имеет большой MTU скажем 9000
а второй порт L2 обращен уже на наш комп и имеет mtu 1500
так вот если из инета влетит фрейм то он с него оболочку l2 сдирает.
видит ип пакет такогото размера. и этот размер явно больше чем mtu=1500 тогда этот роутер начнет фрагментировать
исходный ип пакет. он его разрежет на куски. создаст кадому куску новые ип хидеры. запакует в новые л2 фреймы
и засунет в л2 порт. в чем при этом проблема. во первых юзер приожение которое шлет данные может попрсить ядро
чтобы оно постаило на ип пакете флаг DF - do not fragment , тогда роутер не будет резать исходный ип пакет 
а просто его отбросит так как он не влезает в mtu порты в который он его должен смаршрутизировать. 
если же флага DF нет и роутер порезал исходный ип пакет на куски . то нашему комп ядру нужно получив все куски
их обратно собрать воедино. проблема в том что это грузит наш цпу и в том что не все куски могут долететь 
а это значит что нужно повторять всю отправку заново целиком. поэтому если мы не хотим всех этих проблем
то мы сообщаем удаленному компу какой mss а значит mtu есть на нашем порту и скорее всего на вышестоящем
роутере. и если удаленный комп пошлет ип пакет размером mtu то скорее всего всех этих описанных проблем
удастся избежать.
вот как выглядит этот SYN пакет в тцпдамп


12:16:08.388573 IP (tos 0x0, ttl 64, id 30291, offset 0, flags [DF], proto TCP (6), length 60)
    127.0.0.1.60292 > 127.0.0.1.5050: Flags [S], cksum 0xfe30 (incorrect -> 0x7e74), seq 4125489000, win 65495, options [mss 65495,sackOK,TS val 982297209 ecr 0,nop,wscale 1], length 0


Flags [S]  = это покзывает что это syn пакет
mss 65495  = а вот это соощает какой mss а значит можно посчитать mtu  тоесть какой макс по размеру ип пакет мы предлагаем
             использовать удаленной стороне для отправки нам


в данном случае огромный mss потому что это дамп связи через LO порт.  а  у него mtu=65536

$ ip -c l sh dev lo
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00


возьму пример SYN пакета когда он летит через обычный физ порт эзернета

$ ip -c l sh dev enp5s0
2: enp5s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether a8:a1:59:00:0f:2c brd ff:ff:ff:ff:ff:ff
    altname enxa8a159000f2c

тоесть мы видим что mtu=1500

$ sudo tcpdump -i enp5s0 -n 'tcp[tcpflags] & (tcp-syn) != 0' -n -p -v

12:08:09.503047 IP (tos 0x48, ttl 64, id 61474, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.0.225.45502 > 192.168.143.240.22: Flags [S], cksum 0x1251 (incorrect -> 0x1fbb), seq 1023223525, win 64240, options [mss 1460,sackOK,TS val 992725583 ecr 0,nop,wscale 7], length 0



мы видим что наш комп предлагает удаленному компу mss 1460
еще раз. важен не сам mss. просто через него можно высчитать mtu. а он позволяет нам понять какого макс размера ип пакет
мы можем создать так чтобы он влез в один эзернет фрейм


в ответ тот комп на основе своего mtu нам шлет свой mss. (вопрос конечно почему бы сразу не слать mtu)
через SYN+ACK пакет


12:35:10.210604 IP (tos 0x0, ttl 63, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    192.168.143.240.22 > 192.168.0.225.43110: Flags [S.], cksum 0xcb99 (correct), seq 2603450557, ack 725891939, win 28960, options [mss 1460,sackOK,TS val 3335866041 ecr 994346289,nop,wscale 7], length 0


Flags [S.] = показывает что пакет имеет флаги SYN+ACK 
в дампе в явном виде присутствует инфо об флаге ack в пакете 
    ack 725891939

и вот видно что удаленный комп нам сообщает свой mss
   mss 1460

далее оба компа используют тот mss который наименьший из двух

так вот на обоих компах было mtu=1500
оба они написали друг другу что mss=1460
и начали его использовать. 

мы уже знаем что mtu по сути покзывает какого размера макс ип пакет может быть вложен в эзернет фрейм в один.
если у нас между нашими компами есть несклкьо роутеров то они сдирают л2 оболочки с входящего фрейма а ип пакет у нас
осатется все время каким был. если же у нас на пути есть свичи то они эзернет фрейм скажем так не меняют.
ну или добавляют удаляют вилан теги. так вот между моим компом и удаленным компом был один гейтвей и один свич.
так вот. как я уже сказал пакет от моего компа влетает в роутер и там с него сдирается л2 оболочка.
остатеся тлько ип пакет. далее роутер смотрт в какой порт его сунуть. смотрит какой мту на этом выходном
порту. и если мту меньше чем размер ип порта то при остусвтиии флага DF в пакете этот роутер
разрезает этот ип пакет на куски чтобы они пролезли в этот мту. но это не случай ссш потому что он 
добавляет DF флаг. тогда в этом случае роутер просто отбраысывает такой ип пакет. но на нашем роутере
был нормальный мту и он не был причиной проблемы. прблема была в свиче. на нем было установлено маленькое
значение MTU для порта. и ссш когда слал мелкие пакеты они пролетали успешно а когда ссш слал жирные пакеты
то они в этом свиче и дропались. вот такой секрет фирмы.


как я это проверил. 
я  на моем компе генерировал tcp поток и смотрел дамп через тцпдамп. 
и также я на удаленном компе смотрел трафик через тцпдамп. 
и в целом получалась вот такая картина - если я гененрирую пакет мелкий то он до того компа
долетает.
а если я генерирую на моем компе пакет крупнее чем такойто размер то он в тот комп не долетает.
так я нащупал какой mss и mtu "пролезает" с моего компа на удаленный комп.
позже был найден и свич который был виновником (потому что изначально думали что сам удаленный комп
виноват либо гейтвей)


итак как я тестирвал,
на моем компе порт br0  и на нем я поставил mtu 1400

# ip -c l set dev br0 mtu 1400
# ip -c l show  dev br0 
15: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1400 ...


на удаленном компе там стоит mtu 1500

# ip -c l sh dev enp0s3
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500




на удаленном компе я запускаю вот такое

(удаленный комп)# nc -k -l 49001  2>&1 1>/dev/null



на моем компе я запускал вот такое

(мой комп) # dd if=/dev/zero bs=1448 count=1 | nc -w 1  удаленный_комп  49001


это приводит  к тому что в сокет поступает 1448 байт.
далее ядро  запускает с удаленным компом инциацию тцп конекта и идет обмен
обмена SYN,   SYN+ACK,   ACK



09:53:57.076998 IP (tos 0x48, ttl 64, id 13579, offset 0, flags [DF], proto TCP (6), length 60)
    172.16.10.1.55598 > 172.16.10.10.22: Flags [S], cksum 0x6c5a (incorrect -> 0x378f), seq 3173215900, win 65280, options [mss 1360,sackOK,TS val 3967988768 ecr 0,nop,wscale 7], length 0

09:53:57.086092 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    172.16.10.10.22 > 172.16.10.1.55598: Flags [S.], cksum 0x6c5a (incorrect -> 0x2346), seq 3237319174, ack 3173215901, win 65160, options [mss 1460,sackOK,TS val 2472029687 ecr 3967988768,nop,wscale 7], length 0

09:53:57.086148 IP (tos 0x48, ttl 64, id 13580, offset 0, flags [DF], proto TCP (6), length 52)
    172.16.10.1.55598 > 172.16.10.10.22: Flags [.], cksum 0x6c52 (incorrect -> 0x4e94), ack 1, win 510, options [nop,nop,TS val 3967988777 ecr 2472029687], length 0




видим первый пакет Flags [S] и вот  у него указано mss 1360 
в ответ удаленный комп присылает Flags [S.] mss 1460 

и потом оба ядра по идее будут юзать мсс наименьший тоесть 1360



значит еще раз откуда такие цифры 1360. это ядро берет мту 1400. тоесть это макс размер пейлоад который
может нести на этом порту эзернет фрейм. и так как мы в нем собираемся нести ип пакет то это будет макс 
разрешенный размер ип пакета. далее ядро отнимает 20 байт это размер ип хидера.
далее ядро отнимает 20 байтов считая что это будет такой размер тцп хидера. (хотя он может быть до 60 байтов)
и то что получает это макс размер тцп пейлоад. тоесть мсс и он его шлет.
в ответ удаленный комп берет свой мту 1500 и отнимает от него 40 байт и шлет свой.

при этом я хочу еще расшифрвать некоторые поля тцп дамп

09:53:57.076998 IP (tos 0x48, ttl 64, id 13579, offset 0, flags [DF], proto TCP (6), length 60)
    172.16.10.1.55598 > 172.16.10.10.22: Flags [S], cksum 0x6c5a (incorrect -> 0x378f), seq 3173215900, win 65280, options [mss 1360,sackOK,TS val 3967988768 ecr 0,nop,wscale 7], length 0


length 60 - это указан размер ип пакета !
length 0 - это указан размер тцп пейлоад! (да! вот так хитро!)

получается SYN пакет имеет размер ип пакета 60 байт и тцп пейлоад 0 байт
пакет SYN+ACK имеет размер ип пакета 60 байт и 0 байт размер тцп пейлоад
трейти пакет имеет размер ип пакета 52 байта и 0 байтов размер тцп пейлоад

как видно ип пакеты у нас летают по сети разного размера!

итак компы обеменялись мссами. и будут юзать наименьший 1360 байт. 
( при этом я не понимаю то что если ядро возьмет тцп пейлоад 1360 байт и навесит на него тцп заголовок
не 20 байт длиной а 60 байт то итоговый ип пакет первысит мту! поэтому я не понимаю почему ядро выбирая мсс
отнимает от мту 20 байт а не 60!)

далее уже начинает происходит обмен данными . посмотрим на него
и тут ожидает ряд приколов.
огромный ряд приколов.

один момент это технология LRO 
что она делает. делает она вот что. у нас в сет карту влетают  из сети фреймы. 
далее они попадают в драйвер. он эти фреймы вскрывает.  вытаскивает из них л3 пакеты. тоесьт например это 
ип пакет. далее он вскрвыает эти ип пакеты. вытаскивает то что там лежит. например это тцп пакеты.
далее он 



один момент это то что в настройках сет карты может быть активирован TSO (tcp segmentation offload)
он состоит  в том что ядро если видит что эта фишка на карте активирована то оно может пихать в драйвер карты
(или в саму карту тут хер точно знает) тцп сегменты гораздо большего размера чем было договрено в мсс!!!
а уже сама сетевая карта 









==
показать вариант с пингом вместо nc

====
убедиться что пейлоад не превышает мсс

====
mtu это параметр который влияет нетолько на отправку но и на прием пакетов. если влетающий пакет будет иметь
мту больше чем указано на порту то ОС этот пакет отбросит!

====
mtu на вирит портах учитывется не всегда
GRO на вирт порту не работает

==
менять gso lro tso 

# ethtool -k enp5s0
Features for enp5s0:
rx-checksumming: on
tx-checksumming: on
	tx-checksum-ipv4: on
	tx-checksum-ip-generic: off [fixed]
	tx-checksum-ipv6: on
	tx-checksum-fcoe-crc: off [fixed]
	tx-checksum-sctp: off [fixed]
scatter-gather: on
	tx-scatter-gather: on
	tx-scatter-gather-fraglist: off [fixed]
tcp-segmentation-offload: on
	tx-tcp-segmentation: on
	tx-tcp-ecn-segmentation: off [fixed]
	tx-tcp-mangleid-segmentation: on
	tx-tcp6-segmentation: on
generic-segmentation-offload: on
generic-receive-offload: on
large-receive-offload: off [fixed]
rx-vlan-offload: on
tx-vlan-offload: on
ntuple-filters: off [fixed]
receive-hashing: off [fixed]
highdma: on [fixed]
rx-vlan-filter: off [fixed]
vlan-challenged: off [fixed]
tx-gso-robust: off [fixed]
tx-fcoe-segmentation: off [fixed]
tx-gre-segmentation: off [fixed]
tx-gre-csum-segmentation: off [fixed]
tx-ipxip4-segmentation: off [fixed]
tx-ipxip6-segmentation: off [fixed]
tx-udp_tnl-segmentation: off [fixed]
tx-udp_tnl-csum-segmentation: off [fixed]
tx-gso-partial: off [fixed]
tx-tunnel-remcsum-segmentation: off [fixed]
tx-sctp-segmentation: off [fixed]
tx-esp-segmentation: off [fixed]
tx-udp-segmentation: off [fixed]
tx-gso-list: off [fixed]
tx-nocache-copy: off
loopback: off [fixed]
rx-fcs: off
rx-all: off
tx-vlan-stag-hw-insert: off [fixed]
rx-vlan-stag-hw-parse: off [fixed]
rx-vlan-stag-filter: off [fixed]
l2-fwd-offload: off [fixed]
hw-tc-offload: off [fixed]
esp-hw-offload: off [fixed]
esp-tx-csum-hw-offload: off [fixed]
rx-udp_tunnel-port-offload: off [fixed]
tls-hw-tx-offload: off [fixed]
tls-hw-rx-offload: off [fixed]
rx-gro-hw: off [fixed]
tls-hw-record: off [fixed]
rx-gro-list: off
macsec-hw-offload: off [fixed]
rx-udp-gro-forwarding: off
hsr-tag-ins-offload: off [fixed]
hsr-tag-rm-offload: off [fixed]
hsr-fwd-offload: off [fixed]

===
iptables имеет -mss ключ  (man iptables-extenions )

===
https://sandilands.info/sgordon/segmentation-offloading-with-wireshark-and-ethtool
===

11:26:07.309765 IP (tos 0x10, ttl 63, id 48311, offset 0, flags [DF], proto TCP (6), length 152)
    192.168.143.240.22 > 192.168.0.225.38358: Flags [P.], cksum 0xdeec (correct), seq 5798:5898, ack 5183, win 324, options [nop,nop,TS val 3418123059 ecr 1076603383], length 100

11:26:07.309793 IP (tos 0x48, ttl 64, id 33848, offset 0, flags [DF], proto TCP (6), length 52)
    192.168.0.225.38358 > 192.168.143.240.22: Flags [.], cksum 0x1249 (incorrect -> 0xdb8f), ack 5898, win 590, options [nop,nop,TS val 1076603390 ecr 3418123059], length 0


где в первом пакете 

    seq 5798:5898

он сообщает что он отправляет байты с номерами 5798-5897

во втором пакете удаленный комп 

   ack 5898

подтверждает что он поучил на данный момент байты с номерами 0-5897

====
прикол tcpdump в том что он  если ключ -s юзать там где он размер эзернет фрейма
покзывает так вот он в этом размере не учитывает последние 4 байта там где CRC хранится


mtu - размер фрейма

фрейм это

14 байт хедер
4 байта влан
4 байта второй влан
4 байта crc
пейлоад


пейлоад это ип пакет 
               20 байт хедер
               пейлоад (tcp пакет) 
                       хедер 20-60 байт (кратно 4 байта)


тцпдамп непокзвыает в ленгф 4 байта crc


если влан нет то иппакет + 18 байт




====
В ИТОГЕ НЕДОПИСАЛ!

