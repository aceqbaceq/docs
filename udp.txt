| udp

я с udp через си язык не отрабаотывал. я только разбирал программу на си
по конекту через tcp

поэтому я не понимал можем ли мы как понять - если мы шлем udp IP:port пакет
то с той стороны ктото есть? ктото слушает этот udp порт?

значит в интернете на лоховском уровне всегда пишу что udp он такой что мы кидаем
пакет из сетевой карты и навсегда забываем о нем. и дальше мы нихрена незнаем долетел
пакет или не долетел. 

ОКАЗЫВАЕТСЯ как обычно это все полный пиздеж. 
оказывается если мы послали пакет и он долетел до того хоста то ядру на той стороне
не составляет никого труда посмотреть в свои кишки и увидеть что ни один процесс не забинден
на этом удаленном компе на данный IP:port UDP ! действительно это же так просто!
и согласно RFC 1122 секция  4.1.3.1
	If a datagram arrives addressed to a UDP port for which
            there is no pending LISTEN call, UDP SHOULD send an ICMP
            Port Unreachable message.

мы видим что ядро в этом случае ОБЯЗАНО обратно отправить ICMP пакет c ошибкой о том что
на данном UDP порту никто не сидит и не слушает! гениально!
да он до нас обратно может не долететь. потому что icmp он неимеет механизма котроля долетел
не долетел. но тем не менее. 
поэтому насклько я понимаю получается что вот мы высрали дата пакет UDP из сетеовй карты
и он не долетел. и мы об этом не узнаем. именно средствами UDP. это юзер код процесса на той стороне
должен сидеть и следить проверять прилетел ли к нему такой то кусок байтов который доставляет
нижележащий UDP слой или нет. а если юзер код за этим своими силами не следит то мы как отправи
тель не узнаем долетел ли пакет или нет туда. мы не узнаем о том что он НЕдолетел. и также мы
не узнаем что он долетел. средствами UDP мы этого незнаем. но если пакет долетел и на том компе
никакой процесс не слушает UDP порт из пакета то ядро обратно ОБЯЗАНО отправвть соотвествюущий 
ICMP пакет. который к нам тоже может не долететь. но если он до нас все таки долетел то 
тот же рфц пункт  4.1.3.3
	 UDP MUST pass to the application layer all ICMP error
            messages that it receives from the IP layer.  Conceptually
            at least, this may be accomplished with an upcall to the
            ERROR_REPORT routine (see Section 4.2.4.1).

тоесть говоря по русски то ядро получив такой ICMP пакет должно както об этом просигнали
зиооровать юзер процессу который запустил тот UDP пакет. у меня на практике сигнализация 
происходит вот как , я запускаю команду write

   write(,...)

котора пишет байты в файл декриптор за которым сидит UDP сокет и код возврата получаю -1
от ядра. 

write(3, "X", 1)                        = -1 ECONNREFUSED (Connection refused)

при том что man 2 write ничего об ошибке ECONNREFUSED в манжаро нихернеа не пишет. но 
об этой ошибке есть в 
	
	$ man 3 errno

притом прикол состоит в том что мы можем уже запульнуть в сеть кучу UDP пакетов в том направлении
и только через какоето время мы получим первый отлуп ICMP с той стороны. наверно он содержит 
в себе все детали именно того UDP пакета чтобы мы могли его идентифицировать среди отправленных
с нашей стороны. незнаю . но думаю что так. 
на практкие это выглядит так что моя прога делает несколкьо операций write() и код возврата
нормальный. а потом я делаю очередной write() и код возврата ECONNREFUSED

тут приходит вопрос а если  я буду делать UDP конект через прокси. ведь в этом случае 
icmp пакет прилетит на удаленный прокси сервер и как эта прокси программа будет понимать что 
прилетел icmp что получается udp какойто пакет оказыается не долетел. хотя я думаю нет проблем.
прокси процесс будет делать write() очередной раз. и получит от ядра вот этот отлуп 

	write(3, "X", 1)                        = -1 ECONNREFUSED


ну и должен мне прислать например даже какой нибуд текстовое уведомление. однако прикол 
в том что например программа nc откзывается пересылать UDP пакеты через прокси. даже через
SOCKS5 прокси который вобще то UDP поддерживает

 	$ nc -n -u -t  -v  google.com 555 -X 5 -x 172.16.10.11:2080
		nc: no proxy support for UDP mode



ТАК ЧТО ЭТО очень революционно крутая инфомрация что окзазывается отсылая UDP пакеты
мы очень даже можем узнать о том что на той стороне их никто не ждет!

Значит именно на этом основана проверка у программы nc того что на том конце "открыт" UDP порт N.
значит у nc есть опция -z

	 -z      Only scan for listening daemons, without sending any data to them.  Cannot be used together with -l.

тоесть если мы ее юзаем то nc понимает что щас он буедет использован не для работы и переслыки
данных а только длоя проверки ооктрыт ли порт на той стороне или нет. 
по факту для UDP он делает вот что. он несколько раз через паузу  шлет "X" через write()
и если на той стороне никто неждет наши пакеты то с той сторны в ядро прилетает icmp 
а как следствие на втором третьем write() мы получаем код возврата  ECONNREFUSED от 
ядра. тогда nc понимает что на той стороны UDP порт этот никакой процесс не слушает. 
еще раз замечу что прием и обработку icmp пакета об ошибке от того хоста принимает ядро 
нашего компа и обрабатываеи его. наш юзер код ничего об этом не знает. наш код лишь как след
ствие видит что очередной write() имеет ошибку в коде возврата. эту ошибку как раз таки 
генериурет ядро получив icmp и проанализровав его!
вот как выгляят сисколлыы в программе nc


socket(AF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_UDP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(55), sin_addr=inet_addr("127.0.0.53")}, 16) = 0
write(3, "X", 1)                        = 1
write(3, "X", 1)                        = -1 ECONNREFUSED (Connection refused)
close(3)                                = 0



значит тут еще прикол всплыл что если использовать оцию -v то программа раобтает по однму
а если ее не использовать то по другому. да еще и в зависисмости от версии программы nc
щас покажу показываю
во первых nc это программа netcat и она бывает разных реализаций. у меня на обоих компах
стоит версия в модификации от bsd. и еще важно что обычно ее я вызывают как nc
но это долбаный симлинк.
покащзываю:

Ubuntu:
$ which nc
/usr/bin/nc

$ stat $(which nc)
  File: /usr/bin/nc -> /etc/alternatives/nc
  Size: 20        	Blocks: 0          IO Block: 4096   symbolic link

$ stat /etc/alternatives/nc
  File: /etc/alternatives/nc -> /bin/nc.openbsd
  Size: 15        	Blocks: 0          IO Block: 4096   symbolic link

$ stat /bin/nc.openbsd
  File: /bin/nc.openbsd
  Size: 39560     	Blocks: 80         IO Block: 4096   regular file

$ sudo dpkg -S /bin/nc.openbsd
netcat-openbsd: /bin/nc.openbsd

на счет версии нетката. в самой программе нет ключа чтобы узнать ее версию. поэтому
можно узнать только через пакетный менеджер

$ sudo dpkg -l | grep netcat-openbsd
netcat-openbsd       1.218-4ubuntu1  


Manjaro:
  $ which nc
/usr/bin/nc

 $ stat $(which nc)
  File: /usr/bin/nc
  Size: 39352     	Blocks: 80         IO Block: 4096   regular file

 $ pacman --query  netcat
openbsd-netcat 1.226_1-2


теперь я покажу что ключ -v работает совершенно по разному на этих двух версиях.
даже чисто визуально

версия 1.218
	с ключом -v
		UDP
		# nc -z -v -u  -n 8.8.8.8 443
		Connection to 8.8.8.8 443 port [udp/*] succeeded!

		TCP
		# nc -z -v   -n 8.8.8.8 443
		Connection to 8.8.8.8 443 port [tcp/*] succeeded!

		видно что с ключом -v вылезает табличка 'Connection to 8.8.8.8 443 port [tcp/*] succeeded!'
 

	без ключа -v
		UDP
    	# nc -z -u   -n 8.8.8.8 443
    	TCP
		# nc -z   -n 8.8.8.8 443

		видно что без ключа -v табличка не вылезает	хотя порт на той стороне открыт по край
		ней мере с точки зрения программы. а то что она считает что порты открыты подтрвеждается
		тем что код возврата 0
		UDP
		# nc -z -u   -n 8.8.8.8 443; echo $?
		0
		TCP
		# nc -z      -n 8.8.8.8 443; echo $?
		0

        ну логика логична. так как флаг -v убран то программа табличку и не выводит. 
        это логично. а свой рещультат она сообщает через код возврата



версия 1.226

		с ключом -v
			UDP
			# nc -n -z -u -v   127.0.0.1 8282
			Connection to 127.0.0.1 8282 port [udp/*] succeeded!
			TCP
			# nc -n -z    -v  127.0.0.1 8888
			Connection to 127.0.0.1 8888 port [tcp/*] succeeded!


		без ключа -v
			UDP
			# nc -n -z -u   127.0.0.1 8282
			Connection to 127.0.0.1 8282 port [udp/*] succeeded!
			TCP
			# nc -n -z    127.0.0.1 8888
			Connection to 127.0.0.1 8888 port [tcp/*] succeeded!


в видно что здесь табличка выводится программой всегда независимо от того есть флаг -v
или нет. по моему это дебильно. какой тогда смысла добавлять флаг -v если плашка
вылезает внезависиомсти от этооо флага.


далее я рассатриваю только версию 1.26 программы.
также  я буду ее рассативать при исполтзовании обоих ключей -z -v 
но при разных протоколах. хочу увидеть в чем разница как програ проверяет открытость порта
TCP  версус открыть порта UDP

	UDP
 	# strace  nc -nzv   -u     127.0.0.53 559
socket(AF_INET, SOCK_DGRAM|SOCK_NONBLOCK, IPPROTO_UDP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(559), sin_addr=inet_addr("127.0.0.53")}, 16) = 0
write(3, "X", 1)                        = 1
write(3, "X", 1)                        = -1 ECONNREFUSED (Connection refused)
close(3)                                = 0
exit_group(1)                           = ?
+++ exited with 1 +++

при этом смотрю трафик по сети

# tcpdump udp port 555  -n   -i lo
14:40:44.302563 IP 127.0.0.1.54753 > 127.0.0.53.555: UDP, length 1

у нас из сет карты по сети улетел udp пакет  вследствие вот этой команды 
	write(3, "X", 1) = 1
как видно ядро вернуло код возврата 1. тоест оно гвоорит нам что оно высрало 1 байт
из сетевой карты  в сеть. типа все окей

и также по сети обратно нам прилеает ICMP с ошибкой
	# tcpdump icmp  -n   -i lo
14:40:44.302592 IP 127.0.0.53 > 127.0.0.1: ICMP 127.0.0.53 udp port 555 unreachable, length 37

ядро этот пакет приняло и при попытке еще один udp пакет в этот конект записать
нам ядро возрващает ошибку

	write(3, "X", 1)                        = -1 ECONNREFUSED (Connection refused)

причем -1 это не код ошибка. это в целом означает что ошибка. а тип ошибки там где
то отделно записывается а нам уже выводится результат

так что проверка открытости UDP порта идет через то что неткат несоклько раз сует в udp конект
символ 'X' и смотрит вернет ли ядро ошибку или нет.

я непомню но при каких трейсах  явидел что неткат между write() сисколлами вставляет 
паузу в 1секунду. только не могу понять иногда вставляет иногда нет. 

теперь посмотрим как TCP порт проверяется открытьость

	TCP
	# strace  nc -nzv       127.0.0.53 555
socket(AF_INET, SOCK_STREAM|SOCK_NONBLOCK, IPPROTO_TCP) = 3
connect(3, {sa_family=AF_INET, sin_port=htons(555), sin_addr=inet_addr("127.0.0.53")}, 16) = -1 EINPROGRESS (Operation now in progress)
pselect6(4, NULL, [3], NULL, NULL, NULL) = 1 (out [3])
getsockopt(3, SOL_SOCKET, SO_ERROR, [ECONNREFUSED], [4]) = 0
write(2, "nc: ", 4nc: )                     = 4
write(2, "connect to 127.0.0.53 port 555 ("..., 43connect to 127.0.0.53 port 555 (tcp) failed) = 43
write(2, ": Connection refused\n", 21: Connection refused
)  = 21
close(3)                                = 0
exit_group(1)                           = ?
+++ exited with 1 +++

видно что когда TCP порт закрыт то прога наэкране рисует плашку а когда закрыт UDP порт
эта же прога нихрена плашку невыводит. еиснвтенное что она при этом код возврата делает.
поэтому я бы рекомедовал ориентрровться не на плашку на экране а на код возврата что дебильно
конечно.

тем не менее проверка открытости TCP порта не очень понятно как делается.
создается сетевой сокет причем указано что он должен быть неблокирующий. 
это значит что когда вызывается connect() то ядро сразу нам возвращает управление 
не дожидаясь пока конект полностью прокрутится. а крутится он долго потому что при протооколе
TCP кргда мы вызываем connect() то наше ядро и удаленное обменивабтся трех шаговым хендшейки
пакетами. учитвыая что обычно по сети они летят 60-100мс то три пакета надо ждать 300мс
что долго поэтому и выгоднее неблокируюий сокет делать. чтобы он инцилизиролвал connect() 
в бекграунд режиме. 
дальше идет pselect6() я вот знаю что он должен срабаывать если на файл дескриптор данные
прилетели а вот срабатывает ли он если connect() отработал до конца незнаю. как видно 
код его возврата без ошибки то есть 0.
потом идет getsockopt() который запрашивает параметры самочусвтвия в сокете через его
файл дескприптор. судя по синтаксису

       int getsockopt(int socket, int level, int option_name,
           void *restrict option_value, socklen_t *restrict option_len);

я полагаю что в скобках задаются аргументы а результат это код возврата. 
видно что код возврата 0. значит все якобы окей.
поэтом я не понимаю откуда прога узнает что все такие конекта нет.
потому что видно что код возврата 1. 
тем не менее видно что прога сама ничего не пытается пихать в сетевой конект для проверки.
как я понимаю у нас ошибку должен возвращать connect() ибо трехшаговый хендшейк неуспешный.
но так как мы неждем пока он отработает я не поимаю как наша прога в итоге узнает о том
был ли успешный connect() или нет.


далее на счет UDP я хочу провеоить что реально nc шлет в конект символы X
для этого  я собираю схему


  nc ----> socat ----> nc -l 

тоесть я поднимаю nc -l на протоколе udp чтобы он тупо сидел и принимал конект.
далее я делаю что сокат слушает юдп трафик на одном порту и перенарпвлеи на  наш nc -l
далее я через дургой nc стучу на socat а он форварит на nc -l
таким обраом я увижу на экране соката что за тарфик который юзерский который выше UDP 
шлется по сети

(терминал1)#  socat -v udp4-listen:8282,fork udp:127.0.0.1:5656
(терминал2)#  nc -k -l -u -v  127.0.0.1 5656
(терминал3)# #  nc -nzvu       127.0.0.1 8282 ; echo $?
Connection to 127.0.0.1 8282 port [udp/*] succeeded!
0

что видно на терминалсе с сокатом
> 2024/11/10 15:04:39.000172616  length=1 from=0 to=0
X> 2024/11/10 15:04:39.000172745  length=1 from=1 to=1
X> 2024/11/10 15:04:40.000172353  length=1 from=2 to=2
X> 2024/11/10 15:04:41.000172507  length=1 from=3 to=3
X> 2024/11/10 15:04:42.000172620  length=1 from=4 to=4
X

тоесть реально nc шлет через UDP в качестве пейлоада символы ASCII 'X' 

также на терминале2 там где сидит слующий nc там на экране тоже будут символы
		
		XXXXX



а вот следущий пример который интеерсный. 
я запускаю сокат который перенарплволяет udp трафик на порт кторый никако процесс не прослушивает.

	#  socat -v udp4-listen:8282,fork udp:127.0.0.1:5657

теперьь запускаю nc чтобы он постучал на сокат

	#  nc -nzvu       127.0.0.1 8282 ; echo $?
	Connection to 127.0.0.1 8282 port [udp/*] succeeded!
	0

как видим он нам пишет что все прошло прекрасно
хотя на экране сокат мы увидим

> 2024/11/10 15:12:08.000094865  length=1 from=0 to=0
X> 2024/11/10 15:12:08.000095025  length=1 from=1 to=1
X2024/11/10 15:12:08 socat[1734884] E write(6, 0x5ccc6a7a8000, 1): Connection refused
> 2024/11/10 15:12:09.000095013  length=1 from=0 to=0
X2024/11/10 15:12:09 socat[1734893] E read(6, 0x5ccc6a7a8000, 8192): Connection refused
> 2024/11/10 15:12:10.000095279  length=1 from=0 to=0
X2024/11/10 15:12:10 socat[1734899] E read(6, 0x5ccc6a7a8000, 8192): Connection refused
> 2024/11/10 15:12:11.000095506  length=1 from=0 to=0
X2024/11/10 15:12:11 socat[1734903] E read(6, 0x5ccc6a7a8000, 8192): Connection refused

вот я еще раз с strace запущу nc

# strace -e write  nc -nzvu       127.0.0.1 8282 ; echo $?
write(3, "X", 1)                        = 1
write(3, "X", 1)                        = 1
write(3, "X", 1)                        = 1
write(3, "X", 1)                        = 1
write(3, "X", 1)                        = 1

тоесть видно что наш nc отлично смог записать все что хотел в udp конект к socat
а тот это все получается отлично внутрь себя принял. тоесть сокат неотказался принять 
ни один пакет что и видно на терминале. тоесть сокат принял все что ему прислал nc
поэтому так как у нас udp конект идет от nc на socat то с точки зрения этого udp конекта
дейсиивтельно все отлично бинд 127.0.0.1:8282 работает!
это вот сокату неудалось то что он получил отправит на уже свой udp конект с биндом 127.0.0.1 8282
жалко толдко что он об этом nc не сообщает. он мог бы прекратить принимать от него пакеты.
а сдругой строны может это временная ошибка передачи в сети . ну по любому надо об этом както сооб
щать я считаю той проге которая ему данные шлет. ну а так коенчно понятно - формально все данные
от nc до socat дошли. это да. это уже у соката не удалось преедать данные в свой udp конект.
тем не мнее получатс на практике если я форвардирую udp трафик через сокат то так как он 
ничего не сообщает проге котоая в него шлет данные о проблемах передачи то моя программа будет
думать что все окей а на самом деле хрен знает и нужно смотеть логи соката что там на счет
успешности передачи данных



также
иногда в трейсах я вижу вот такое

clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7ffcedf99d50) = 0
write(3, "X", 1)                        = 1
clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7ffcedf99d50) = 0
write(3, "X", 1)                        = 1
clock_nanosleep(CLOCK_REALTIME, 0, {tv_sec=1, tv_nsec=0}, 0x7ffcedf99d50) = 0
write(3, "X", 1)          

тоесть что при проверке UDP порта у нас между write() он вставляет паузу. типа sleep
но я непонимаю когда то он ее всталвяет а когда то нет.


получсется прикольный момент - вот говрят у UDP нет контроля о доставке. а на самом деле
она частично есть. есл мы выплюнули пакет в сеть то наше ядро на write() сообщает что все окей.
далее если пакет вобще не долетел а погиб в инете да мы этого не узнаем чрез UDP
но если он долетел а на том хосте никакая прогармма на этом порту не сидит то мы об этом узнаем
потому что то ядро обзано нам вответ послать icmp уведомление. если оно долетит то наше
ядро узнает. и оно на наш очередной write() или read()  в этот udp конект нам выренет ошиьку
в коде возврата. вот и мы и узнали !

ИТОГО
так с UDP с проверкой открыт ли порт UDP через прогу nc разобрались.
также с тем что если udp пакет долетел до той стороны то там ядро легкоможет проверить
есть ли процесс который слушает этот порт. и если нет то ядро обязано ообратноотослать
icmp пакет об ошибке. а наше ядро должно как то проинфорировать через код врзврата 
юзер функции напрмиер очередного write() о том что произошла ошибка . при этом такой механзм
асинхронный тоесть ошибка вылезет не на том write() от ктого реально отлупи произошел а на другом
write()  потому что мы усппеем в сеть послать кучу udp пакетов прежде чем с той стороны к нам
долетит icmp пакет и ядро наше его оработает.
=====

