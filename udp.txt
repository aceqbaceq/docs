| udp

я с udp через си язык не отрабаотывал. я только разбирал программу на си
по конекту через tcp

поэтому я не понимал можем ли мы как понять - если мы шлем udp IP:port пакет
то с той стороны ктото есть? ктото слушает этот udp порт?

значит в интернете на лоховском уровне всегда пишу что udp он такой что мы кидаем
пакет из сетевой карты и навсегда забываем о нем. и дальше мы нихрена незнаем долетел
пакет или не долетел. 

ОКАЗЫВАЕТСЯ как обычно это все полный пиздеж. 
оказывается если мы послали пакет и он долетел до того хоста то ядру на той стороне
не составляет никого труда посмотреть в свои кишки и увидеть что ни один процесс не забинден
на этом удаленном компе на данный IP:port UDP ! действительно это же так просто!
и согласно RFC 1122 секция  4.1.3.1
	If a datagram arrives addressed to a UDP port for which
            there is no pending LISTEN call, UDP SHOULD send an ICMP
            Port Unreachable message.

мы видим что ядро в этом случае ОБЯЗАНО обратно отправить ICMP пакет c ошибкой о том что
на данном UDP порту никто не сидит и не слушает! гениально!
да он до нас обратно может не долететь. потому что icmp он неимеет механизма котроля долетел
не долетел. но тем не менее. 
поэтому насклько я понимаю получается что вот мы высрали дата пакет UDP из сетеовй карты
и он не долетел. и мы об этом не узнаем. именно средствами UDP. это юзер код процесса на той стороне
должен сидеть и следить проверять прилетел ли к нему такой то кусок байтов который доставляет
нижележащий UDP слой или нет. а если юзер код за этим своими силами не следит то мы как отправи
тель не узнаем долетел ли пакет или нет туда. мы не узнаем о том что он НЕдолетел. и также мы
не узнаем что он долетел. средствами UDP мы этого незнаем. но если пакет долетел и на том компе
никакой процесс не слушает UDP порт из пакета то ядро обратно ОБЯЗАНО отправвть соотвествюущий 
ICMP пакет. который к нам тоже может не долететь. но если он до нас все таки долетел то 
тот же рфц пункт  4.1.3.3
	 UDP MUST pass to the application layer all ICMP error
            messages that it receives from the IP layer.  Conceptually
            at least, this may be accomplished with an upcall to the
            ERROR_REPORT routine (see Section 4.2.4.1).

тоесть говоря по русски то ядро получив такой ICMP пакет должно както об этом просигнали
зиооровать юзер процессу который запустил тот UDP пакет. у меня на практике сигнализация 
происходит вот как , я запускаю команду write

   write(,...)

котора пишет байты в файл декриптор за которым сидит UDP сокет и код возврата получаю -1
от ядра. 

write(3, "X", 1)                        = -1 ECONNREFUSED (Connection refused)

при том что man 2 write ничего об ошибке ECONNREFUSED в манжаро нихернеа не пишет. но 
об этой ошибке есть в 
	
	$ man 3 errno

притом прикол состоит в том что мы можем уже запульнуть в сеть кучу UDP пакетов в том направлении
и только через какоето время мы получим первый отлуп ICMP с той стороны. наверно он содержит 
в себе все детали именно того UDP пакета чтобы мы могли его идентифицировать среди отправленных
с нашей стороны. незнаю . но думаю что так. 
на практкие это выглядит так что моя прога делает несколкьо операций write() и код возврата
нормальный. а потом я делаю очередной write() и код возврата ECONNREFUSED

тут приходит вопрос а если  я буду делать UDP конект через прокси. ведь в этом случае 
icmp пакет прилетит на удаленный прокси сервер и как эта прокси программа будет понимать что 
прилетел icmp что получается udp какойто пакет оказыается не долетел. хотя я думаю нет проблем.
прокси процесс будет делать write() очередной раз. и получит от ядра вот этот отлуп 

	write(3, "X", 1)                        = -1 ECONNREFUSED


ну и должен мне прислать например даже какой нибуд текстовое уведомление. однако прикол 
в том что например программа nc откзывается пересылать UDP пакеты через прокси. даже через
SOCKS5 прокси который вобще то UDP поддерживает

 	$ nc -n -u -t  -v  google.com 555 -X 5 -x 172.16.10.11:2080
		nc: no proxy support for UDP mode



ТАК ЧТО ЭТО очень революционно крутая инфомрация что окзазывается отсылая UDP пакеты
мы очень даже можем узнать о том что на той стороне их никто не ждет!

Значит именно на этом основана проверка у программы nc того что на том конце "открыт" UDP порт N.
значит у nc есть опция -z

	 -z      Only scan for listening daemons, without sending any data to them.  Cannot be used together with -l.

тоесть если мы ее юзаем то nc понимает что щас он буедет использован не для работы и переслыки
данных а только длоя проверки ооктрыт ли порт на той стороне или нет. 
по факту для UDP он делает вот что. он несколько раз через паузу  шлет "X" через write()
и если на той стороне никто неждет наши пакеты то с той сторны в ядро прилетает icmp 
а как следствие на втором третьем write() мы получаем код возврата  ECONNREFUSED от 
ядра. тогда nc понимает что на той стороны UDP порт этот никакой процесс не слушает. 
еще раз замечу что прием и обработку icmp пакета об ошибке от того хоста принимает ядро 
нашего компа и обрабатываеи его. наш юзер код ничего об этом не знает. наш код лишь как след
ствие видит что очередной write() имеет ошибку в коде возврата. эту ошибку как раз таки 
генериурет ядро получив icmp и проанализровав его!




когда делаем connect() по tcp то ядро при этом делает 3-хенд шейк
а если это делать в udp то ядро ничего неделает

write() если пишем в tcp fd то ядро возврашает число байтов зпианных толко на основе
как я понимаю пакетов подтвержения пришедщих пакеов а если стоит fd udp то меряется
тоьлько тем что пакет вылетел из сетевой карты!

