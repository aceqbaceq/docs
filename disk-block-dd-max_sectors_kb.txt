значит о чем речь

у нас есть диск. скажем sda

ксатии замечу что /dev/sda это не прямое окно  к железке диск. нихуя.
это окно заказок в ДРАЙВЕРУ который обслуживает диск.

                             |
программа ------> /dev/sda --|--->  драйвер диска ------> диск
                             |

палкой я показал что слева от палки юзерсепейс . справа от ядра прорстранство ядра

но всетаки акцент не наэтом а на том что /dev/sda это не окно доступа к диску. 
ни к какому диску доступа у нас нет. это окно заказов к драйверу в ядре который обслуживает диск
а уже он приняв наш заказ думает что он будет делать из нашего заказа а что нет и как он 
будет это делать. 

в этом свете забавны такая штука что /dev/sda1 это доступ к столку заказов к тому же драйверу
просто таким макаром нам драйвер показывает что в этом окне принимаются заказы по досутпу
к партишену 1 на диске. тоесть это тоже доступ к диску просто начиная с некоторого сектора от 
начала. тоесть если sda это доступ к диску с LBA=0 то sda1 это доступ к диску начиная
с какогто LBA=100500 
с точки зрения юзер спейс программы /dev/sda это доступ к файлу. который характиеризуется
тем что нам надо открыть файл через open() потом туда можно начать писать через write()
и еще можно ядру указать через lseek() с какого оффсета надо начать писать в этот файл
вот стрейс от dd. 
 $ sudo strace dd  if=/dev/sda of=/dev/null bs=120k count=1

openat(AT_FDCWD, "/dev/sda", O_RDONLY)  = 3
dup2(3, 0)                              = 0
close(3)                                = 0
lseek(0, 0, SEEK_CUR)                   = 0
openat(AT_FDCWD, "/dev/null", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
dup2(3, 1)                              = 1
close(3)                                = 0
read(0, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 122880) = 122880
write(1, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 122880) = 122880
close(0)                                = 0
close(1)                                = 0

значит мы открываем файл , открвыает второй файл , читаем из  одного и пишем в другой.


вместо dd можно было бы легко заюзать 

  # echo "123" > /dev/sda 

это без разницы

параметр bs=120k у команды dd ей говорит о том какой размер буфера указать для read() write()
тоесть dd в частнотси запульнет запрос read() из файла /dev/sda размером 120KByte
что мы и видим

read(0, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 122880) = 122880

но! это всего наша просьба к ядру. но ядро совершенно не факт что выполнит этот запрос так
как мы его попросили. а именно : мы говрим ядру - прочитай из файла fd/0 (/dev/sda) нам 120 кило
байт. но ядро еще не факт что будет к железке запускать запрос в виде - ей диск выдай мне
120Килобайт начиная с оффсета 0! ядро может к диску сделать зпапрос в виде = эй диск выдай
мне 64 килобайт данных! получит эти 64 килобайта. потом скажет эй диск ! выдай мне еше 64 
килобайта данных начиная с оффсета 64к ! потом соединит эти два куска данных и скопирует 
этот 128КБ кусок в область памяти юзер программы! если еще быть точнее ядро к диску обращается
вообще в другой форме. это мы из юзер программы делаем к ядру запрос в виде

  read (0, ...., 128KB)

  ssize_t read(int fd, void *buf, size_t count);


тоесть мы говоими ядру - прочти нам из файла fd/0 (/dev/sda) 128КБ и отдай их нам . точнее засунь эти байты в нашу область памяти. 

пытливый ум заметит и скажет а где же в запросе указан офффсет? для каждого открытого
файла ядро всвоих кишках еще хранит текущий оффсет. если мы считали 5 байт то офффсет 
сдивгаетя на +5. и следушая операция чтения будет с тоого места где мы закончили в тот раз.
этот оффсет можно руками посмртреть вот тут 

  /proc/PID/fdinfo/N


если у нас в /fd/N это дескиптор файла который мы щас читаем то в 

  /proc/PID/fdinfo/N

монжно посмтеть какой оффсет сейчас для этгого файла в ядре указан
например

pos:  18921986          <============= офффсет текущий
flags:  02100000
mnt_id: 32


поэтому когда мы длеаем read()


  read (0, ...., 128KB)

  ssize_t read(int fd, void *buf, size_t count);


то чтение идет с текущего офсета.
если мы хотим сменить оффсет то мы юзаем 

 off_t lseek(int fd, off_t offset, int whence);


но так все выглядит кода мы читаем из юзерспейса из файла.


ядро же к диску обращается совсем по другому. как я понимаю диск наружу тоесть к ядру 
предоставляет возможность делать запросы в виде того что мы указыаем номер сектора (блока)
с кторого хотим прочитать данные . и сколько блоков мы хотим прочитать тоесть ядро к диску 
обращается в виде

   эй диск! прочти мне 10 блоков начиная с блока 100. 

это назыавется сделать к диску IO реквест. размер блока\сектора на диске обычно имеет размер
512 байт или 4килобайта. (в разной литератутуре одну и туже хуйню все время называют по разному
где то это сектор где то это блок). 







$ cat /sys/block/sda/queue/max_sectors_kb 
32767

$ cat /sys/block/sda/queue/max_hw_sectors_kb 
32767
 






# total_read_GiB="1"; for i in $(seq 1 13 ); do  bs="$(( 2*(2**$i) ))"; echo "bs=$bs"k; count=$( echo "$total_read_GiB*1024*1024 /  $bs " | bc) && dd if=/dev/sda  of=/dev/null bs="$bs"k count=$count  iflag=direct  status=progress 2>&1 | grep GiB; done

bs=4k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 19.4914 s, 55.1 MB/s
bs=8k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 10.7953 s, 99.5 MB/s
bs=16k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 6.69757 s, 160 MB/s
bs=32k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.56354 s, 235 MB/s
bs=64k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 3.50849 s, 306 MB/s
bs=128k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 3.3725 s, 318 MB/s
bs=256k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.84377 s, 378 MB/s
bs=512k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.5217 s, 426 MB/s
bs=1024k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.35215 s, 456 MB/s
bs=2048k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.05888 s, 522 MB/s
bs=4096k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2 s, 536 MB/s
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 2.00342 s, 536 MB/s
bs=8192k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 1.95462 s, 549 MB/s
bs=16384k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 1.94004 s, 553 MB/s


# lsblk -S
NAME HCTL       TYPE VENDOR   MODEL                       REV SERIAL           TRAN
sda  0:0:0:0    disk ATA      KINGSTON SV300S37A240G 603ABBF0 50026B725506D960 sata
sdb  1:0:0:0    disk ATA      SanDisk SSD U110 16GB   U21B001 143230407760     sata
sdd  7:0:0:0    disk          USB DISK 2.0               PMAP 071C29CE048E5254 usb



# lsblk
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS
loop0    7:0    0 140.2M  1 loop /run/miso/sfs/livefs
loop1    7:1    0 971.5M  1 loop /run/miso/sfs/mhwdfs
loop2    7:2    0   1.3G  1 loop /run/miso/sfs/desktopfs
loop3    7:3    0 791.9M  1 loop /run/miso/sfs/rootfs
sda      8:0    0 223.6G  0 disk 
sdb      8:16   0  14.9G  0 disk 
sdd      8:48   1  14.5G  0 disk 
├─sdd1   8:49   1   3.3G  0 part 
└─sdd2   8:50   1     4M  0 part 



# lsblk -S
NAME HCTL       TYPE VENDOR   MODEL                       REV SERIAL           TRAN
sda  0:0:0:0    disk ATA      KINGSTON SV300S37A240G 603ABBF0 50026B725506D960 sata
sdb  1:0:0:0    disk ATA      SanDisk SSD U110 16GB   U21B001 143230407760     sata
sdd  7:0:0:0    disk          USB DISK 2.0               PMAP 071C29CE048E5254 usb



# disk="sdb"; total_read_GiB="1"; for i in $(seq 1 13 ); do  bs="$(( 2*(2**$i) ))"; echo "bs=$bs"k; count=$( echo "$total_read_GiB*1024*1024 /  $bs " | bc) && dd if=/dev/sdb  of=/dev/null bs="$bs"k count=$count  iflag=direct  status=progress 2>&1 | grep GiB; done
bs=4k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 23.7303 s, 45.2 MB/s
bs=8k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 12.9357 s, 83.0 MB/s
bs=16k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.69586 s, 140 MB/s
bs=32k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 5.24944 s, 205 MB/s
bs=64k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.46181 s, 241 MB/s
bs=128k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.25376 s, 252 MB/s
bs=256k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21551 s, 255 MB/s
bs=512k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21529 s, 255 MB/s
bs=1024k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21609 s, 255 MB/s
bs=2048k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21506 s, 255 MB/s
bs=4096k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21641 s, 255 MB/s
bs=8192k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21805 s, 255 MB/s
bs=16384k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.22263 s, 254 MB/s



# cat /sys/block/sdb/queue/max_hw_sectors_kb 
32767


# cat /sys/block/sdb/queue/max_sectors_kb 
1280

# echo "32767"  > /sys/block/sdb/queue/max_sectors_kb 


# disk="sdb"; total_read_GiB="1"; for i in $(seq 1 13 ); do  bs="$(( 2*(2**$i) ))"; echo "bs=$bs"k; count=$( echo "$total_read_GiB*1024*1024 /  $bs " | bc) && dd if=/dev/sdb  of=/dev/null bs="$bs"k count=$count  iflag=direct  status=progress 2>&1 | grep GiB; done
bs=4k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 23.9826 s, 44.8 MB/s
bs=8k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 13.119 s, 81.8 MB/s
bs=16k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 7.74873 s, 139 MB/s
bs=32k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 5.24054 s, 205 MB/s
bs=64k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.39802 s, 244 MB/s
bs=128k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.23244 s, 254 MB/s
bs=256k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21546 s, 255 MB/s
bs=512k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21503 s, 255 MB/s
bs=1024k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21656 s, 255 MB/s
bs=2048k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.216 s, 255 MB/s
bs=4096k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.21715 s, 255 MB/s
bs=8192k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.22019 s, 254 MB/s
bs=16384k
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 4.22215 s, 254 MB/s


