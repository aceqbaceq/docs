| iptables-baza
| baza

здесь будет база по iptables 
ибо хрень это реально мудотная




как посмотреть список всех правил

 # iptables-save > ~/rules-ip.txt



заглянем в этот файл


# Generated by iptables-save v1.8.10 on Thu Jan 30 12:33:24 2025
*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

-A INPUT -i lo -j ACCEPT
-A INPUT -j DROP

-A FORWARD -i lo -o lo -j ACCEPT
-A FORWARD -j DROP

-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -j DROP
COMMIT
# Completed on Thu Jan 30 12:33:24 2025


# Generated by iptables-save v1.8.10 on Thu Jan 30 12:33:24 2025
*nat
:PREROUTING ACCEPT [26:4145]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [34:3312]
:POSTROUTING ACCEPT [16:968]
:REDSOCKS - [0:0]

-A OUTPUT -p tcp -m tcp --dport 443 -j LOG --log-prefix "[NAT-OUTPUT 443:port] "

-A POSTROUTING -s 172.16.10.0/24 -o wlp2s0 -j MASQUERADE

-A REDSOCKS -d 0.0.0.0/8 -j RETURN

COMMIT
# Completed on Thu Jan 30 12:33:24 2025


из чего он состоит. 
он состоит прежде всего из таблиц. в данном случае две таблицы filter и nat


*filter
...
...	
COMMIT


*nat
...
...	
COMMIT


в конец секции про таблицу обязательно нужно слово COMMIT это конец таблицы.
тепер пострим на структуруту таблицы


*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

...
...

COMMIT



внутри нее есть головная часть

	:INPUT DROP [0:0]
	:FORWARD DROP [0:0]
	:OUTPUT DROP [0:0]


она показывает какие ЦЕПОЧКИ  есть в этой таблице.
есть цепочки которые автоматом уже созданы ядром. 
также в этом месте указвыается дефоолтовое действие с пакетом который не подойдет ни под 
одного правило внутри этой цепочки
можно добавляь свои цепочки тоже . делаем это вот так

	:INPUT DROP [0:0]
	:FORWARD DROP [0:0]
	:OUTPUT DROP [0:0]
    :VASYA - [0:0]

мы добавили цепочку VASYA
кстати тут важно сказать что при добавлении цепочки мы указываем нетолько имя для нее
но и деолфтовое действие которое нужно делать с пакетом если он не подойдет ни под одно
поиавло этой цепочки. правда для кастомных цепочек тут только один вариант это указать "-"
это означает что дефолтового дейсвтия для этой цепочки нет. если поставит ACCEPT или DROP
то ядро напишет ошибку. 


следущая часть таблицы это RULES или правила

-A INPUT -i lo -j ACCEPT
-A INPUT -j DROP

-A FORWARD -i lo -o lo -j ACCEPT
-A FORWARD -j DROP

-A OUTPUT -o lo -j ACCEPT
-A OUTPUT -j DROP


привила входя в состав цепочек. в данном случае показны правила из цепочек INPUT, FORWARD, OUTPUT

итак iptales сосоит из таблиц, таблицы состоят из цепочек, а цепочки состояит из правил.
если пакет попал в цепочку то его ядро протащит по всем правилам в этой цепочке пока
ненайдется праивло под кторое этот пакет подходит. тогда ядро применить действие которое
в этом првило указано. как правило при этом дейсвтии пакет тут же покидает эту цеопчку и эту
таблицу. правила в цепочке приняеются по порядку сверху вниз как они записаны в текствоом 
файле. если в цепочке нет ни одного приалвила куда пакет подпадает то к пакету применяются то
дефолтовое дейсвтие (DROP, ACCEPT) которое указано в спсике цепочек для этой цпочки.
важно - в конце цеопочки лучше встаит правло которое охывает все пакеты и указать дейстие.
таким оразом мы не будем полагаться на дефолтовое праивло. нарпиер 

  -A INPUT -j ACCEPT

значит если пакет дошел до конца то его нужно пропустить. ACCPET значит что проход пакета
одобрен в этой таблце в этой цепочке и пакет мгвноенно покидует эту таблицу

  -A INPUT -j DROP

это дропает пакет.
что касается поледленего праивла для встроенных цеоппочек то я в нем дублиую то действие
ктооторое я указал в дефолтовом дейсвтии. тоесть елси у нас для цепоки INPUT указано вот так

	:INPUT DROP [0:0]

то в ослденем правиле для этоц цепочки я вставюлю правило

  -A INPUT -j DROP

про кастмоные цепочки - так как в касмтомые цепочки ядро само никогда не вставлвяет пакеты а вместо этого в них
юзер через правила  в дургих цепочках пихает пакеты то послденне праивло в кастомной цепочке
обычно делают вот таким

  -A INPUT -j RETURN

тоесть мы возвращаем пакет на обработку в ту цеопку из которой нам его прислали

вставка поделеднего правила в цепочку очень важна потому что у нас так может получится
что у нас пакет проетит все правила в цепочке ни под одного не попдает а дефолтовое правило
у нас кажем ACCEPT и какионибудет левыый пакет будет пропущен дальше. хотя сосвтенно
это поведение и мы же и запрограмировали в дефолтовом дейсвтии. но об этом можно забыть.
можно ошибкочно думать что деолтвое дейтвие стоит DROP и считать что все пакеты которые
непошли ни под одно праивлоа будут дропнуты. и можно жескттокоого опешиться поэтому 
лушче вставлять в цепочке в явном виде дубликат дефолтового дейстия тоесть


	:INPUT DROP [0:0]  <== **

    -A INPUT rule1
    -A INPUT rule2
    ...
    -A INPUT -j DROP  <== **


или 

	:INPUT ACCEPT [0:0]  <== **

    -A INPUT rule1
    -A INPUT rule2
    ...
    -A INPUT -j ACCEPT  <== **

таким образом мы дуболиуем действие. и когда мы будем глазами анализирвать поток
праивлв в цепочке а их может быть мегадхера то в дойдя до конца мы будем четко видет
какое итоговое дейстие ждет пакет в конце цепочки. мы сразу явно и чтетко это увидим.
и нам ненужно глазами лезить наверх и искать строку  :INPUT ACCEPT [0:0] которая моетжет
быть очень далеко или измеена неожиданно.

значит пакет когда он ходит в ядре то ядро его сует в iptables код. и код иптейбл начинает
пакет прогонять по таблицам , а внутри них по цепочкам, внутри них по праивлам этих цепочек.
причем важно  -  пакет когда влетает в иптейбл то он влетает в одну и туже захардкженную  заданную таблицу. тоесть это не опреяделяется юзером это так уже прписано в ядре. 
попав в таблицу пакет суется в захардкоженную цепочку. в этой цепочке пакет прогоняетя 
по всем правилам этой цеопчки. если в конце концов он подпдает под правило то к нему применяется
то дейтие которое указанов цепочке и после этого он как правило в следствие этого действия
покидает эту таблицу и эту цепочку и далее он либо прогоняется церез таблицу маршутизации
(об этом еще поговрим) и после этого суется в следующую таблицу либо сразу суется в следующую
таблицу. но есть всякие и моменты. напрмиер в цепочке может быть указано в качестве дейтсвия
что пакет нужно засунуть в другую цепочку этой таблицы и тогда пакет перелаезает в другую 
цеопчку этой таблицы. если же такого действия пакет не встречает то что важно в таблице
проходит только одну цепочку. еще раз  - в какую цеопчку ядро засунет пакет при влетании
его в таблицу это задает само ядро. если же пакет прходит по всем правилам цепочки но 
не подходит ни под одно праивло то для каждой цеппочки задается дефолтовое дейсвтяие которое
надо сделать для пакета который не подощел ни под одно праивло целопки, это указывается
в списке цепочек
вот пример

	:INPUT DROP [0:0]
	:FORWARD DROP [0:0]
	:OUTPUT DROP [0:0]

тоесть здес для этих цепочек укаазано что дефолтое действивие для пакета из этой цеопки 
это DROP тоесть уничтожить.

еще раз важно например понять что вот мы видим таблицу 
в ней список цепочек (плюс дефтолвые действия)

*filter
:INPUT DROP [0:0]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]

...
...

COMMIT


и важно понять что пакет при попадании в эту таблицу не пройдет по всем цепочкам. этого
не будет. он пройдет только через одну цепочку. через какую это решает ядро в зависимости от
обстоятельств при которых пакет попадает в эту таблицу(об этом далее). так что только через
одну цеопчку пойдет пакет. остальные его не коснутся. единсвтвенный вариант чтобы пакет 
прошел через несколкьо цепочек это если мы спецаильно так укажем. показываю
вот таблица NAT
в ней есть цепочки prerouting, input, output, postrouting, redsocks
все цепочки дефолтовые встроенные а redsocks это кастомная цепочка
*nat
:PREROUTING ACCEPT [26:4145]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [34:3312]
:POSTROUTING ACCEPT [16:968]
:REDSOCKS - [0:0]

-A OUTPUT -p tcp -m tcp --dport 443 -j LOG --log-prefix "[NAT-OUTPUT 443:port] "
-A POSTROUTING -s 172.16.10.0/24 -o wlp2s0 -j MASQUERADE
-A REDSOCKS -d 0.0.0.0/8 -j RETURN

COMMIT

насколко я понимаю при заполеннии таблицы нет никакого значения в каком порядке 
мы укажем цепочки. тоесть либо вот так 

:PREROUTING ACCEPT [26:4145]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [34:3312]
:POSTROUTING ACCEPT [16:968]
:REDSOCKS - [0:0]

либо вот так

:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [34:3312]
:PREROUTING ACCEPT [26:4145]
:POSTROUTING ACCEPT [16:968]
:REDSOCKS - [0:0]

это никак ни начто не влияет. потому что в какую цеопчку суунть пакет решается ядро не 
на этом основании.
также неважно в каком порядке указаны правила принадлежащие разным цепочкам.
тоесть
либо вот так

-A OUTPUT -p tcp -m tcp --dport 443 -j LOG --log-prefix "[NAT-OUTPUT 443:port] "
-A POSTROUTING -s 172.16.10.0/24 -o wlp2s0 -j MASQUERADE
-A REDSOCKS -d 0.0.0.0/8 -j RETURN

либо вот так

-A REDSOCKS -d 0.0.0.0/8 -j RETURN
-A POSTROUTING -s 172.16.10.0/24 -o wlp2s0 -j MASQUERADE
-A OUTPUT -p tcp -m tcp --dport 443 -j LOG --log-prefix "[NAT-OUTPUT 443:port] "

тоесть все три приавла принадлеажат разным цеопчкам. и поэтому их тасовать в списке
можно как угодно. это ни на что не влияет. 
ЗАТО. важно в каком порядке првила указаны котоыре принадлежат ТОЙЖЕСАМОЙ цепочке

тоесть если я напишу

-A OUTPUT rule1
-A OUTPUT rule2
-A OUTPUT rule3

то они обарабютвыася в порядке сверху вниз. 
поэтому если я укажу эти праивла вот так

-A OUTPUT rule3
-A OUTPUT rule2
-A OUTPUT rule1

то пакет пройдет по цепокчкам в пордядке rule3, rule2, rule1
тоесть вот вэтом случае порядок важен при заполении таблицы

возвращаемся к правилам 

-A OUTPUT -p tcp -m tcp --dport 443 -j REDSOCKS
-A POSTROUTING -s 172.16.10.0/24 -o wlp2s0 -j MASQUERADE
-A REDSOCKS -d 0.0.0.0/8 -j RETURN

так вот если наш пакет ядро изначально засунет в OUTPUT цепочку то у нас отработатет
праивило

-A OUTPUT -p tcp -m tcp --dport 443 -j REDSOCKS

а внем указано что если пакет подпдает под это правило то пакет нужно сунуть в цепочку REDSOCKS
таким образом он попадет в правиало

-A REDSOCKS -d 0.0.0.0/8 -j RETURN

действие RETURN возвратит пакет обратно  в ту цеопчку из которой пакет в эту цепочку сунули
в следующее правило из которого его туда сунули


таким образом у нас может быть вот такое

:INPUT DROP [0:0]
:REDSOCKS - [0:0]


 -A INPUT rule1
 -A INPUT ... -j REDSOCKS
 -A INPUT rule3
 -A INPUT rule4
 -A INPUT -j DROP


 -A REDSOCKS rule1
 -A REDSOCKS rule2
 -A REDSOCKS rule3
 -A REDSOCKS rule4
 -A REDSOCKS -j RETURN

таким образом пакет ядро сует в таблицу эту. и сует в цеопчку INPUT
пакет проходит rule1 и неподпадает под него.
входит в rule2 , подпадает и ядро его пихает в цеопчку REDSOCKS
он влетает в эту цпочку  , если попдадает хоть под одно праивло то пакет покинут
эту цеопчку и эту таблицу. и на этом орработка это пакета в этйо талцеице закконится.
а если он в цеоке redsocks ни под одно правло не прпал то он попдает на последнее 
правлоа которое зачепрывает оюбые пакеты и получае дейтсвие RETURN
и он вовраается в цеопчку INPUT в праивло rule3
если он в цеопочке INPUT подадет под правило то он покинует таблицу а еси нет
то он попдадет точно под полсденне правило 

 -A INPUT -j DROP

и будет уничтжен.

вот так это работает


по поводу действий. котоорые идует после -j 
стадартные дейвтия это DROP и ACCEPT.





