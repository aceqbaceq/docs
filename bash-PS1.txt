| bash PS1

это конечно полная хуета на счет этой PS1.

я щас пока распиывать не буду. я только дам уже коенчный вариант 
без распмывания.

нужно поместить в конец .bashrc

ПЕРВЫЙ ВАРИАНТ

if [ "$LOGNAME" = root ] || [ "`id -u`" -eq 0 ] ; then
        export PS1="\[\e[38;5;11;48;5;214m\][\h]\[\e[38;5;11;48;5;1m\]#\[\e[0;m\] "

    else
        export PS1="\[\e[38;5;11;48;5;214m\][\h]>\[\e[38;5;16;48;5;82m\] \[\e[0;m\] "

fi



ВТОРОЙ ВАРИАНТ

if [ "$LOGNAME" = root ] || [ "`id -u`" -eq 0 ] ; then
                export PS1='\[\e[01;31m\][root \[\e[38;5;21;48;5;16m\]\h \[\e[01;31m\]]#\[\e[00m\] '
        else
                export PS1='\[\e[01;32m\][\u@ \[\e[38;5;21;48;5;16m\]\h \[\e[01;38;5;32m\]]\$\[\e[00m\] '
        fi





ТРЕТИЙ ВАРИАНТ (еще кручу)

if [ "$LOGNAME" = root ] || [ "`id -u`" -eq 0 ] ; then
        export PS1="\[\e[38;5;11;48;5;214m\] \h \[\e[38;5;11;48;5;1m\]#\[\e[0;m\] "

    else
      export PS1='\[\e[01;32m\][\u@ \[\e[01;38;5;$(( $RANDOM  %  255  ));48;5;16m\]\h \[\e[01;38;5;32m\]]\$\[\e[00m\] '
fi



суть третьего варианта вот в чем. когда мы тыкаем Enter на клаве то баш всасывает то что мы натыкали 
оценивает или либо запускает либо выводит ошибку либо если мы просто Ennter пустой нажали то 
он просто выводит PROMPT так вот вобщем так или иначе при каждом нажатии Enter баш прокручивает терминал вверх
на одну строку и башу нужно заново в новой строке вывести так назваемый PROMPT. для того чтобы ему вывести его
он КАЖДЫЙ РАЗ при нажатии ENTER вычиляет значение переменной PS1 !!!! это значит что если в перменной стоит 
другая переменная то занчение PS1 может меняться ! при кажом нажати ENter! значит при кажом нажатии Enter в теории
мы можем получать на экране совершенно разный PROMPT! тоест он может стать прям живым!!
у меня данном случае цвет шрифта котооым печаатетмся имя хоста  прописано через перменную $RANDOM это встроенная
в баш перменная которая выдает рандомные числа. поэтому при кажом нажатии Enter у меня в prompt название 
хоста печатается новым рандомным цветом!!!! это очень мило!!!! очень круто!!!
ну а если нажали sudo то там уже все статическое . типа там все серьезно



ЧЕТВЕРТЫЙ ВАРИАНТ (ТЕРМОЯДЕРНЫЙ)


if [ "$LOGNAME" = root ] || [ "`id -u`" -eq 0 ] ; then
        export PS1="\[\e[01;23;38;5;11;48;5;214m\] \[\e[01;31m\]$(/bin/hostname | tr "[:lower:]" "[:upper:]") \[\e[38;5;11;48;5;1m\]#\[\e[22;38;5;196;48;5;16m\] "

    else
        export PS1=' \[\e[01;32m\]\[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]$(echo -e "\0$(echo -e "obase=8;ibase=10;$(( 33 + ($RANDOM % 92)   ))" | bc)") $(printf "\U0000$(   echo "obase=16;$(($RANDOM % 252))" | bc  )$(   echo "obase=16;$(( $RANDOM % 252))" | bc  )")  \[\e[00m\]\$ '
#       export PS1=' \[\e[01;32m\]\[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]$(echo -e "\0$(echo -e "obase=8;ibase=10;$(( 33 + ($RANDOM % 92)   ))" | bc)") $(printf "\U0000$(   echo "obase=16;$(($RANDOM % 252))" | bc  )$(   echo "obase=16;$(( $RANDOM % 252))" | bc  )") \[\e[23;01;31m\]$(/bin/hostname | tr "[:lower:]" "[:upper:]") \[\e[00m\]\$ '
#       export PS1=" \[\e[01;32m\]\[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]$(echo -e "\0$(echo -e "obase=8;ibase=10;$(( 33 + ($RANDOM % 92)   ))" | bc)") $(printf "\U0000$(   echo "obase=16;$(($RANDOM % 252))" | bc  )$(   echo "obase=16;$(( $RANDOM % 252))" | bc  )") \[\e[23;01;31m\]$(/bin/hostname | tr "[:lower:]" "[:upper:]") \[\e[00m\]\$ "
#       export PS1='\[\e[01;32m\][ \[\e[23;01;31m\]$(/bin/hostname | tr "[:lower:]" "[:upper:]") \[\e[01;32m\]]\[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]\$$(echo -e "(\0$(echo -e "obase=8;ibase=10;$(( 33 + ($RANDOM % 92) ))" | bc))")\[\e[00m\]'
#       export PS1='\[\e[01;32m\][ \[\e[23;01;31m\]$(/bin/hostname | tr "[:lower:]" "[:upper:]") \[\e[01;32m\]]\[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]\$ \[\e[00m\]'
#       export PS1='\[\e[01;32m\][ \[\e[22;31m\]$(/bin/hostname) \[\e[01;32m\]]\[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]\$ \[\e[00m\]'


fi



здесь сразу указано несколько вариантов таки и сяких.
тоесть одну линию надо раскоментироовать. это вобще мегавариант.
что он делает - он печаатет хостнейм. но еще он печатает при каждом нажатии Enter
новый симвло ASCII рандомный и (вниание!) новый рандомный символ UTF
причем я не очень разобрался почему но (долго подбирал кавычки) если линия написана вот так
        export PS1='.....'
то новые символы валятся при кажом нажатии Enter
а если линия написана вот так
        export PS1="....."
то при нажатии на ENter символы не будут обновляться. но они буудут новые в новом окне терминала
также прикол в том что пробовал испольовать printf \u.....
но баш в PS1 комбинацию \u рассматривает как свой макрос по ообозначению username и принтф в пролете
поэтому я заюзал printf \U.... потому что у PS1 у баша на \U нет никакого макроса.
вобщем интересная история. я доконца непонял. я конечно понимаю что если юзать
        $ cmd 'arg1 arg2'
то баш при вызове execve подтсавть аргументы как есть без раскрытия
        execve (cmd, 'arg1, arg2...' )
а если делать 
        $ cmd "arg1 arg2"
то бащ будет делать globbing преед вызовом execve
шас покажу на примере

 * 몖  $ a=10
 , 싱  $ b=20
   ऑ  $ strace -e execve echo "$a+$b"
execve("/bin/echo", ["echo", "10+20"], 0x7fffe9e43378 /* 69 vars */) = 0
10+20

 5 ���  $ strace -e execve echo '$a+$b'
execve("/bin/echo", ["echo", "$a+$b"], 0x7ffe5ab39b18 /* 69 vars */) = 0
$a+$b

но все равно  не совсемпонятно как там баш все загоняет в PS1


далее
вместо $RANDOM я вначале заюзал самописный рандом генератор только он почему то ошибку 
выдает время от времени я так и непонял почему
        echo $(( $(tr -cd "[:digit:]" < /dev/urandom | head -c3)  %  255  )) 
в самом низу статьи я понял почему. подсмотрел в интернете. так что смотри в самом низу.

на счет опция \u и \U принтф это отдельно расписал в файле "printf+UTF.txt" 
коротко скажу что в обоих случаях аргументом является CodePoint. Код поинт символа
одинаковый во всех UTF-8 UTF-16 UTF-32
теперь в чем разница \u и \U только в том что \u позволяет печатаать символы у которых код поинт
маквимум 2 байта по размеру (в hex виде) а \U позволяет печатать любой код поинте хоть  1 байт
длинной хоть 4 байта длинной. нахер они огород гордили не знаю. в итое всегда чтоб не паритсяь
можно юзуть \U и непарится какая там длинна у код поинта. он печатает все!



короткая заметка на счет цветов в темрианале.
цвета в терминале меняются за счет того наш процесс шлет в pts/10 непросто ASCII печатные символы как 
обычно а некие управляющие байты и тоггда (тут я незнаю) либо дсициплина терминала либо xterm\gnome-terminal-server
меняют цвета в граф окне. скорее всего именно xterm\gnome-terminal-server шлют через клиент X11 нужные граф
хрени. кстати эта штука цветовая работает и в xterm и в tty экране!
так вот что это за супер управляющие байты. вначале нужно послать признак того что
мы щас будем слать управляющие байты. и это два байта  
        \033 и \133   (это октальный формат байта)
или в hex виде 
        0x1B и 0x5C
если это выражать в форме печатных символов то \033 нимеет печатного символа (так называемый ESC байт)
а второй байт это символ [

через echo мы можем это отправит вот так

        $ echo -e "\033["
или 
        $ echo -e "\033\0133"

да. дело в том что man echo он четко описывает как комнада echo обрабатывает аргумент свой. 
тоесть баш через execev он в echo шлет ascii символы для кажого символа что мы вставли тоеть

$ strace -e execve /bin/echo -e "\033\013332m 34"
execve("/bin/echo", ["/bin/echo", "-e", "\\033\\013332m 34"], 0x7ffec6ce8040 /* 69 vars */) = 0

или
$ strace -e execve /bin/echo -e "\033[32m 34"
execve("/bin/echo", ["/bin/echo", "-e", "\\033[32m 34"], 0x7ffd31352020 /* 69 vars */) = 0

тоесть в эхо из баш влтеают ascii символы для кажого симовла. тоесть 
    
    вот  у нас так echo -e "\033["
значиь баш передаст в echo найбор байтов
       \ = \0134
       0 = \060
       3 = \066
       3 = \066
       [ = \0133

тоесть поток байтов при влете в echo будет
 0134 060 066 066 0133

тоесь я хочу сказать что баш в echo преедаст отдеьный печатный символы. символ "\" + символ "0"
+ символ "3"  + символ "3" плюс символ "["

но эхе можно обьяснить кода мы ей просто печатные симыолы передаем ктторые ей просто надо напечатать 
тупо ничего не меняя. а когда мы ей чрез перчатные симыволы хотим донести о какихто других байтах.
это ключ -e

$ echo -n '\033' | od -t o1
134 060 063 063

$ echo -en '\033' | od -t o1
033

в обоих случаях у нас баш передает  в эху один и тотже наборр байтов как аргументы.
но эха их транслирует уже на экран сосвем по разному.

$ strace -e execve echo -n '\033' 
execve("/bin/echo", ["echo", "-n", "\\033"], 0x7ffc70cf3e80 /* 69 vars */) = 0
$ strace -e execve echo -en '\033' 
execve("/bin/echo", ["echo", "-en", "\\033"], 0x7fff15a52eb0 /* 69 vars */) = 0

вот видно что баш в эху прееает один и тотже поток байтов как аургмент.

можно эхе "обьяснять" про байты (что мы хтим чтоы она принятые asscii символы сконервретиовала в байты
которые уже надо напечатать) через octal фоормат \0NNN
а можно ряд байтов ей обьяснить через спец обозначаение .
например 
байт \033 можно передать в эху нетолко как \033 но и как \e
она этотоеже понимает в ней это защито. смотри man echo 

$ echo -en '\033' | od -t o1
033
$ echo -en '\e' | od -t o1
033

одно итоже навыходе. хотя формално арумент разный!

вобщем я возвращаюсь кому что через echo надо передать в терминал pts/10
два байт
         \033 и \133
сказав об этом echo как нам удобно гавлнео чтобы эха поняла.  это может быть вотак
        $ echo -en "\033\0133"
либо    $ echo -en "\033["
        $ echo -en "\e["

на выходе в stdout котоыйр смотрит в pts/10 будет одно итоеже
$ echo -en '\e[' | od -t o1
033 133

$ echo -en '\033[' | od -t o1
 033 133

$ echo -en '\033\0133' | od -t o1
033 133

главое когда мы в октальйо формет доносим до эхи форму байта то надо ПОМНИТЬ что обяатеьнл
ставить 0 вначале числа!!!!

вот так правильно
$ echo -en '\033\0133' | od -t o1
033 133

а вот атк уже хуйня
$ echo -en '\033\133' | od -t o1
033 134 061 063 063


у анс вместо байта \0133 эхе мы скзали чтобы она напечатала три символа "1" + "3" + "3"

итак . чтобы начать перчатаьт цвета в терминале. надо ему передать два байта
        \033 и \0133
после этого ему уже можно предвать команды. 
команды это тоже байты но уже совпдаающие с asccii символами котоые разделяются точкм с запятой
и на конец ставится будква "m" 
например 

        \e[31m
тоесть это 
    \033 + \0133 = управляющая комбинация 
затем уже два символа 31 тоесть чисто asccii "3" и "1" и наконце "m"
символ m означает для термианал что мы закончили ему передвать управлябщие символы. 
31 означает что весь следущий текст надо печатать красным цветом.
далее
команда  1 гвооит термианлу что нунжно петчатать последущий текст жирно
         \e[1m

так вот если я хочу печать текст разынми цветами то надо просто поискать какие символы типа 31 или 45
отвечают за цвета. но это скучный споосб потому что другие смволы скажем 50 условно они терминалу говортя
уже прочтото свсоем дургое не про цвета а скажем типа это символ табуляции. и вылалвать цвета 
среи дургих уарвлябщих команд нехочется. ест другой спосособ

        \e[38;5;N;m]  
где N это символ от 0 до 255
        $ echo -e "\e[38;5;21m" "1233" 
если так вести то это нам тоже напеатает текст тоже цветной. 
N это номер цвета . и их 256 оттенков. можно вот так вот запустит 

        $ for i in $(seq  0 255 ); do echo -e  "\e[38;5;"$i"m  $(hostname)  $i"; done 
и на экране у нас имя хоста напеваается всеми возможныии цветаими! можно выбрать и использовать.
главно о чем надо помнить это между аргументами ставить ";" и  в конце поставить "m"
иначе хуйня будет на экране вместо цветов!
также можно менять фон при печати внутри квардратиука это команда \e[48;5;N;m]
тоесть
        $ for i in $(seq  0 255 ); do echo -e  "\e[48;5;"$i"m  $(hostname)  $i"; done 
сбрсоить найторкаи термианал это 
        \e[0;m


как видно я в .bashrc использваол оба подхода
  export PS1='\[\e[01;32m\][\u@ \[\e[01;38;5;$(( $RANDOM  %  255  ));48;5;16m\]\h \[\e[01;38;5;32m\]]\$\[\e[00m\] '

и вот такой
        \e[01;32m
и вот такой
        \e[01;38;5;32m

далее поьебки не закончились. дело в том что это команда echo имела свой синтаксис как ей обьяснить 
что через печатные симыолы мы хотим ей донести байты. так и у баша тоже есть свой синкаксис. так вот 
в при подставноке в PS1 он такойже как у echo НО! у баща еще обящательно именно при подставновке в PS1 
переенную нужно вот эту "управляющую комбинацию " обраить дополниеьно в 
                \[  ....... \]
тоесть если в эхо мы подствляем в вивде
        echo -e "\e[01;38;5;32m  vasya"
то в PS1 надо подсвлять в виде 
        export PS1="\[\e[01;38;5;32m\]  vasya"
иначе он пошлет нахцуй
именно из за этого если мы в баше напечатает PS1 текущий 
        $ echo $PS1
        \[\e[01;32m\][\u@ \[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]\h \[\e[01;38;5;32m\]]\$\[\e[00m\]
а потом скопируем и пошлем в echo 

  $ echo -e '\[\e[01;32m\][\u@ \[\e[01;38;5;$(( $RANDOM % 255 ));48;5;16m\]\h \[\e[01;38;5;32m\]]\$\[\e[00m\]'
то эхо нас пошлет нахуй.
потому что с его точки зрения в аргументе насовано лишнего тоесть расмотрим голову этого гроба

        \[\e[01;32m\]

с точки зрения эхо  мы печатаем "\" + "[" далее идем спец комабинация "\e[01;32m" далее "\" + "]"
это приведет к тому что пофакту смиволы  "\]" напечатаются дефолтовым цветом а символы "\]" наечататся
уже желтым цветом. а с точки зрения баша кокнетно именно когда мы посвляем в PS1 переменную то у него
потовторрюсь символы "\[" означают начало упровяляющих байтов или непечатных симвлолов котоыре он должен 
проинтерпертировать в упроалящие байты. а не тупо  в ascii символы.
тоесть я к чему если мы напишем
        $ a="\e[01m"
то баш просто нпросто так и запомнить эту комбинацию как набор ascii символов
тоест как  "\" + "e" + "[" + "0" + "1" + "m"
а если вот так
        $ a="\[\e[01m\]"
то баш вместо "\"+"e" запомнть это у себя уже как \033 !
он поймет что \e это "\"+"e" а  это  \033 !

тут еще вот какой прикол есть. точнее ОГРОМНАЯ ПОДЬЕБКА ! баш он понимает octal формат
иесть соблазн вот так напаисать 
        PS1='\033[31m vasya'
вместо 
        PS1=\[\e31m\] vasya' 
типа того что думаешь наверное каниель с 
        \] ... \]
она видимо ради \e обозачения. дай как я его в \033 засуну и избаавлюсь от доп гроба в виде 
        \] ... \]
но ниухя. 
если так сделать то будет две проблемы. я тоже та сделал вначале и поебалася знатно.
первая прлема в тмо что если начать печатаь в терминале то кога доайдешь до конца строки то 
баш он неперерведет печать на новую строку.  а начнет затирвать символы сначала строки. второй пизда 
в том что если начать листать историю через "стрелка вверх" "стрелка вниз" то будет затираться prompt
слева. тоесть тоже будет полная хуйня.
поэтмоу с башем с его PS1 надо четко соблаюдать как они сказали. что если ты всатвляешь внутри кусок 
из управлябщих терминалом символово то надо их оградить конструцией
        \[......\]
тода все будет заебсиь!!!


на этом пока все. и так тохуя написал.


терперь посмтрим почему вот эта штука

                $ echo $(( $(tr -cd "[:digit:]" < /dev/urandom | head -c3)  %  255  ))  <===== ??????
возаршает ошиику порой
        bash: 078: value too great for base (error token is "078")
посмотрет в инет и нащел ответ!!!
у нас внутри $(( ....   ))
получается стринг "078"
и так как $((..)) это хрень которая считает математику то 078 для нее это число записаное В ВОСЬМЕРИЧНОМ
ФОРМАТЕ ! а раз так то нервеное число так как восьмерчиный формат это цифрв 0-7 у нас 
заюзана цифра 8!!!
все стало понятно!
вот ровно такоже пример в явном виде!!
        $ echo $(( 078 ))
bash: 078: value too great for base (error token is "078")
ну тогда просто  я огарничу цифры [0;7] и все. и поэтмоу даже если будет стринг в виде 006
то это будет как octal. и все окей

                echo $(( $(tr -cd "0-5" < /dev/urandom | head -c3) % 255 ))

вот можно в цикле провериить что ни разу больше ошибки не выдает 
$ for i in $(seq 0 1000 ); do echo $(( $(tr -cd "0-5" < /dev/urandom | head -c3) % 255 ));  done
отлично!



============
вот еще вариант

 PS1='\[\033[01;31m\][PROD]\[\033[00m\]\[\e]0;\u@\h: \w\a\]\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h:\[\033[01;34m\]\w\[\033[00m\]\$ '



============


