ext4
https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout

создадим файл и сделаем из него блочное устройство

первый шаг
$ dd if=/dev/zero of=./01.block bs=2k count=100000


на следущем шаге используем losetup
прогармма позвяолет взять файл и организовать к нему доступ как к блочному утсройству
через /dev/loopX файл.

поговорим о флагах команды ибо они описаны дебильно.




losetup без флагов или с флагом -a показывает инфо о том какие /dev/looop заняты
щас и на какие файлы они привязаны. 


$ sudo losetup
NAME        SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE
/dev/loop9          0      0         1  1 /var/lib/snapd/snaps/gnome-characters_741.snap
/dev/loop7          0      0         0  0 /root/block-devices/01.block

siezelimit и offset это хрень какая то потому что они задают то что: 
sizelimit ограничивает доступ внутри файла до какогто предела. зачем это надо?
если мы завели файл то хотим там лазить везде внутри
offset задает что доступ начинается не с нулевого байта файла а с какогото 
отступа. тоже нахер это надо?
RO - рид онли доступ. ну понятяно

вобщем в итоге нас интерусет только NAME и BACK-FILE
$ sudo losetup
NAME         RO BACK-FILE
/dev/loop9   1 /var/lib/snapd/snaps/gnome-characters_741.snap
/dev/loop7   0  0 /root/block-devices/01.block

итак losetup позволяет иметь доступ к бекенд файлу как блочному устройству через
/dev/loop9 спецфайл. тоесть имели файл получили блочное устройство в котором файл 
это бекенд.






ключ -f (--find) = описание у ключа полностью дебильное. если других ключей в добавок к ключу -f неиспользуется в команде то ключ -f показывает свободный /dev/loopX на данный момент

$ losetup  -f
/dev/loop15

но более того (и об этом несказано в мануале) это то что если свободного loop нет то в ответ
на эту команду система создает +1 новый свободный loop. правда и тут не без ососбенностей
это произодйет олько если мы запусккаем losetup -f с правами рута. показываю:

$ losetup -f
losetup: cannot find an unused loop device: Permission denied
$ sudo losetup -f
/dev/loop28

тоесть в системе небыло свободных loop. я заустил losetup -f без прав рута и он об этом 
просто написал. а вот когда запустил под рутом то система в ответ создала новый свобдрный loop

у этого ключа дебильная расшифровка я продолжаю об этом,  по своему смыслу этот ключ совсем не "find" как написано в мануале а более похож по смыслу на "loop file"
потому что когда мы создаем связь между бекенд файлом и /dev/loopX то ключ -f используется
для того чтобы указать какой /dev/loopX мы хотим использовать. так что -f обозначает /dev/loopX файл. если мы неукажем конкетный /dev/loopX файл то система автоматом подставит первый свободный. тоесть

$ sudo losetup -f  ~/01.img   
эта команда найдет свободный /dev/loopX и привяжет его к файлу 01.img

хотя можно как я сказал указать /dev/loopX руками
$ sudo losetup -f /dev/loop12  ~/01.img

таким образом видно что -f указывает имя /dev/loop файла. так что какой нахер find ? -f по своему смыслу это никакой нахер не --find а  file по своему смыслу.

еще раз скажу что указывать руками -f /dev/loop12 нет смысла. во первых потому что этот /dev/loop12 уже 
должен быть в системе более того  надо проверять свободен ли он.

также еще важный момент скажу. если у нас в системе исчерапались все доступные loop устройства
то при вызове losetup -f с правами рута система создаст +1 свободный loop. отсюда ответ 
на вопрос откуда беретуся новые свободные loop-ы.
пример я щас заюзаю последний свободный loop27: 

$ losetup -f
/dev/loop27

создаем бекенд файл 
$ touch ~/block-devices/01.img

привязываем 01.img к блочному loop27
$ sudo losetup /home/vasya/block-devices/01.img  -f /dev/loop27

таикм образом теперь доступ к 01.img можно делать как к блочному устройству чеерез /dev/loop27
В данном случае я указал loop руками но можно было сделать и по другому без ручного указания:

$ sudo losetup /home/vasya/block-devices/01.img  -f

далее я проверяю появился ли новый loop.
$ losetup -f
losetup: cannot find an unused loop device: Permission denied

как видно непоявился.


но  далее я запуска команду  под рутом и система создает новый!
$ sudo losetup -f
/dev/loop28

таким обоазом я резюмирую что ключ -f дает и делает.
1. он показывает какой свободный loop есть (при запуске не под рутом)
$ losetup -f
/dev/loop28

2. если свободного loop нет но мы запустили под рутом то система создаст новый свободный 
loop
$ sudo losetup -f
/dev/loop28


3. указввает loop который использовать при создании связи между бекенд файлом и loop файлом
	$ sudo losetup /home/vasya/block-devices/01.img  -f /dev/loop27
если после -f неуказан loop то система сама найдет свободный и подставит.  я даже
поозреваю что если свободного неокажется то система создаст новый loop автоматом
тоесть вот такая команда тоже работает
	$ sudo losetup /home/vasya/block-devices/01.img  -f
причем я считаю что это и есть более практически удобная команда


Итак создаем блочное устройство из файла 01.block
# losetup --sector-size 4k /home/vasya/block-devices/01.block -f

проверяем:
$ losetup | grep -E "OFFSET|01.block"
NAME         RO BACK-FILE                                          DIO LOG-SEC
/dev/loop28   0 /home/vasya/block-devices/01.block                   0    4096


LOG-SEC это logical sector size это сектор 4к который мы выставили ранее.
что такое logical sector и чем он отличается от physical sector мы поговорим ниже.



создаем файловую систему ext4 с дефолтовыми настройками:

$ sudo mkfs.ext4 /dev/loop28
mke2fs 1.44.1 (24-Mar-2018)
Discarding device blocks: done                            
Creating filesystem with 50000 4k blocks and 50048 inodes
Filesystem UUID: d70e8847-c2a9-4ca5-9d03-a42fb6c454a9
Superblock backups stored on blocks: 
	32768

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done


теперь начинаем изучать ext4.

теперь посморим что про фс напишет утилита:
$ sudo tune2fs -l /dev/loop28
tune2fs 1.44.1 (24-Mar-2018)
Filesystem volume name:   <none>
Last mounted on:          <not available>
Filesystem UUID:          d70e8847-c2a9-4ca5-9d03-a42fb6c454a9
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Filesystem flags:         signed_directory_hash 
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              50048
Block count:              50000
Reserved block count:     2500
Free blocks:              44278
Free inodes:              50037
First block:              0
Block size:               4096
Fragment size:            4096
Group descriptor size:    64
Reserved GDT blocks:      24
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         25024
Inode blocks per group:   782
Flex block group size:    16
Filesystem created:       Thu Jul 14 20:17:44 2022
Last mount time:          n/a
Last write time:          Thu Jul 14 20:17:44 2022
Mount count:              0
Maximum mount count:      -1
Last checked:             Thu Jul 14 20:17:44 2022
Check interval:           0 (<none>)
Lifetime writes:          16 MB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:	          128
Journal inode:            8
Default directory hash:   half_md4
Directory Hash Seed:      785a7c2b-e142-432b-b4d9-7ae4b3399411
Journal backup:           inode blocks
Checksum type:            crc32c
Checksum:                 0x97a880be

пока двигаем дальше.

ФС ее драйвер делит диск на blocks. это не сектора диска нет. это логическая структура 
с точки зрения драйвера фс. насколко я понимаю это минимальная стркуткура которую можно
прочитать и записать на фс через драйвер. но я пока непонимаю это внутренняя кухня
только для драйвера фс или эти блоки они както наружу выставляются для сторонних внешних
потребителей. пока я этого не понимаю. пока двигаем дальше.

блоки обьединяются в block group. ее размер опредеяется через 
	sb.s_blocks_per_group
либо как 
	8 * block_size_in_bytes

All fields in ext4 are written to disk in little-endian order. HOWEVER, all fields in jbd2 (the journal) are written to disk in big-endian order.

немного поговорим про рейды. что такое stripe size и chunk size.
у IBM нашел такое определение - A stripe, which can also be referred to as a redundancy unit, is the smallest amount of data that can be addressed. сокращаю их выражение до:
 A stripe is the smallest amount of data that can be addressed


что такое chunk size. важно отметить что этот термин
имеет смысл ТОЛЬКО ДЛЯ ОПРЕДЕЛЕННЫХ ТИПОВ RAID А НЕ ДЛЯ ВСЕХ ПОДРЯД.
из man mdadm я читаю:
 -c, --chunk=
              Specify  chunk  size of kilobytes.  The default when creating an array is 512KB.  To ensure compatibility with earlier versions, the default when building an array with no persistent metadata is 64KB.  This is only meaningful for RAID0, RAID4, RAID5, RAID6, and RAID10.
              RAID4, RAID5, RAID6, and RAID10 require the chunk size to be a power of 2.  In any case it must be a multiple of 4KB.
по своей сути chunk означает сколько байт будет записано на отдельный диск если мы на весь 
массив послали X KB данных за 1 IO. читаю у орейли - An array's chunk-size defines the smallest amount of data per write operation that should be written to each individual disk.



- о чем это ?
cat /sys/block/loop0/queue/physical_block_size 
cat /sys/block/loop0/queue/logical_block_size

во первых эти хрени это результат того что firmware диска доакладывает драйверу.
тоесть это незадается из линукса это типа как бы свойства самой железки 
которые она сообщает о себе. якобы hdparm может просить firmware железки чтобы
она поменяла свой logical_block_size и иногда она меняет.

тееперь о значении этих хреней
physical_block_size = походу это типа каким блоками информация сохраняется
	внутри железки по факту.

logical_block_size = это какими минимальными блоками железка принимает от драйвера информацию на запись.(вроде бы оттуда же LBA - logical block addressing произошло название). тоесть 
я так понимаю что вот для драйвера железка сообщает что у нее есть 1 000 000 LBA блоков размером по 512 байт. соотвесвтенно драйвер может подать на запись команду вида - запиши 
ка в 15-ый блок LBA 512 байт такого то вида. тоесть идея в чем что для драйвера диск 
выглядит как коробка у которой два параметра - число блоков (LBA) и размер блока. 
и драйвер может либо читать из блока либо писать в блок. соотвественно можно либо 
целиком прочитать блок либо целиком записать в блок. частичная операция диском не поддерживатеся поэтому драйверу надо знать размер блока обязательно. 
 иттогда операция чтения со стороны драйвера выглядит как:
 READ блок 15 размер 512 байт
 WRITE блок 17 размер 512 байт.

 если же ядро хочет записать 1 байт то ему нужно с помощью драйвера 
 1. считать блок LBA 12 размером 512 байт с помозью драйвера
 2. поменять один байт в RAM в этом куске 512байтном 
 3. записать обартно 512 байт (модифицированных ) с помозью драйвера в LBA 12


 так вот 512 байт это logical_block_size.

 еще раз драйверу кгда он хочет считать инфо с диска ему нужно передать какой номер блока
 драйвер хочет чтобы диск считал. я незнаю передает ли драйвер в диск размер сектора
 или просто драйвер вслпую получает байты от диска пока он незактнется  и тогда важно
 чтобы размер буфера чтения оказался ни больше ни меньше. но я думаю что точно что при записи на диск нужно указать номер блока и нужно чтобы размер данных которые мы пихаем на диск 
 был в точности совпадал с размером сектора потому что если мы попробуем сунуть в сектор инфомрации болше чем сектор по размеру то диск выдаст ошибку. вот почеу важен размер сектора.
 и вот этот вот размер сектора который мы получаем при чтении сдиска указав его номер 
 и размер который можно запихать в диск указав номер блока как раз равен logical_block_size
 который диск сообзает драйверу. тоесть если мы заказли чтение с диска lBA блока 12 то 
 мы можем смоело ожидаь что диск на передаст ровно logical_block_size байт.
 а если мы хотим запистьа на диск в блок 12 LBA то диск ждет от нас logical_block_size байт.
 вот каков физический смысл logical_block_size.

 а смысл physical_block_size состоит в том что таков размер блока записи на диске внутри 
 по факту. он может неосовпата с logical_block_size. к чему это приводит. если унас 
 physcal_block_sie=4K а logical_block_size=512байт то когда мы пишем на диск 512 байт
 то по факту диск внутри себя считывает 4к модифицирует его и записывает обратно модифицироыванный 4к.  что конечно же ведет к сумашедшему потере скорости. 
 логично предполжить что если мы заказали запись восьми блоков LBA по 512 байт то 
 диск понимает что весь его физичесмы кий блок 4к нужно  переписать поэтому читать уже его ненужно его можно сразу перезапиывать. и потери скрорости нет вообще!
 поэтмоу что наам дает знание  physical_block_size. поменять мы его неомжем но мы можем
 на файловой системе сделать размер блока равынй или кратный physical_block_size.
 что это дает - мы в программе в линуксе даем команду 

  write(1, const void *buf, 12КБ);

запускается ядро и сисколл берет наши 12КБ данных и передает драйверу ФС. 
драйвер ФС разбивает нащи 12Кб на куски по 4КБ(размер блока на ФС) насколько я пнинимаю
далее дайрвер фс делает вот что. он переводит каждый кусок 4КБ в блоки LBA и передает
драйвер диска типа такой команды - мол блоки LBA c 1 по 8 (суммарно 4КБ) надо записать кучкой
далее мол блоки с 9 по 16(4КБ) тоже надо записать кучкой. драйвер диска его специифика то что
он знает какие конктенотно сигналы надо послать в диск чтобы передать ему что  LBA 1-8 надо
записать кучкой. это приводит  к тому что диск видит что надо записать 8 втртуальных блоков LBA фактически которые укладываются в один физический блок и диск понимаает что это перепывает
весь физ блок целиком и он это делает и сокрость нетеряется. вместо того чтобы прочитать блок 
поменять на наем первый байт записать обратно . потом считать заново поменять второй баайт
записать заноово. имеем  непотерю скоорости. 

в чем разница если бы на ФС были бы блоки по 512байт ( тоесть мы есл бы незнали что физ блок 4К а думали что он 512байт). было бы то что мы дали команду write(1, const void *buf, 12КБ);
она долетела до ФС. она взяла и 12КБ разделила по 512байтовым LBA кусочкам. и далее фс
будет требовать от драйвера диска чтобы он просто записал LBA блоки в любом порядке.
и  в этом то жопа потому что тогда как раз может получатьс ситцаия на диске что он 
читает 4к сектор. меняет в нем один или два байта. пишет обратно. потому опять читает
меняет один два байта и пишет обратно. огромная потеря сокрости.  вслучае е когда  у нас на фс 4Кб блоки это приводит к тому что у нас на ываходе тоже куча полукиолбтаный LBA блоков но
фм будет требовать от дравера диска чтобы группа LBA от 1 по 8 была записана в одном порыве.
или друг за другом. и значит диск небует читать 4к блок а сразу будет его переписывать. в этом 
и есть смысл нам знать о внутрнеейней размере физ диска на диске и на оснвое этого задавать 
размер блока на фс. иначе я не вижу смысла в блоках ФС.

насколько я понимаю про страйп на рейде. это минимальная логическая структура размером которой
он читает и пишет. если она скажем 64КБ это значит что если мы задаем запись 1КБ то он прочитает с жиска кусок 64Кб изменит его и потом запишет обратно. тоест идет чтение+запись 
вмест записи. 


- у нас рейд и страйп size =64k значит ли этом что при запитсь 1к у нас всегда будет
вначале чтние и только потом запись. то есть бещеное падание скоокрсти.

на сайте редхата читаю: 
	Storage vendors can also supply "I/O hints" about a device's preferred
minimum unit for random I/O ('minimum_io_size') and streaming I/O
('optimal_io_size').  For example, these hints may correspond to a RAID
device's chunk size and stripe size respectively.


что такое direct i\o = Direct I/O is a feature of the file system whereby file reads and writes go directly from the applications to the storage device, bypassing the operating system read and write caches. Direct I/O is used only by applications (such as databases) that manage their own caches.
An application invokes direct I/O by opening a file with the O_DIRECT flag.
дествииельно читаю man 2 open:
O_DIRECT (since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will degrade performance, but it is useful in special situations, such  as  when  applica‐
              tions  do  their own caching.  File I/O is done directly to/from user-space buffers.  The O_DIRECT flag on its own makes an effort to transfer data synchronously, but does
              not give the guarantees of the O_SYNC flag that data and necessary metadata are transferred.  To guarantee synchronous I/O, O_SYNC must be used in  addition  to  O_DIRECT.
              See NOTES below for further discussion.
еще таеаы добавка идет:
When a file is opened with O_DIRECT, or when a GFS direct I/O attribute is attached to a file, all I/O operations must be done in block-size multiples of 512 bytes. The memory being read from or written to must also be 512-byte aligned.

кстати посмотреть список scsi устрйоств:
$ apt-get install lsscsi

пакет чтобы посылать команы на scsi устройства:
$ sudo apt-get -y install sg3-utils

здесь нащел https://people.redhat.com/msnitzer/docs/io-limits.txt :
Linux filesystems are not allowed to be
formatted to use a block size that is smaller than the underlying
storage's 'logical_block_size'.

в доке от ibm нашел:
logical_block_size Smallest possible unit in bytes that is addressable in a request.
physical_block_size Smallest unit in bytes handled without read-modify-write.

тоесть logical_block_device это с каким размером сектора диск себя презентует в user space.
как он видится для юзер программ.

physuica_block_size это его размер сектора изнутри внутри. если совать в диск данные размером
меньше чем physuica_block_size то диску придется вначале считать physuica_block_size изменить его а потом только заисать обратно. что ведет к беешеной перфоманс деградации.

Тут я напоролся на тему linux kernel i\o scheduler:
Simply sending out requests to the block devices in the order that the kernel issues them, as soon as it issues them, results in awful performance. One of the slowest operations in a modern computer is disk seeks. Each seekpositioning the hard disk's head at the location of a specific blocktakes many milliseconds. Minimizing seeks is absolutely crucial to the system's performance.

Therefore, the kernel does not issue block I/O requests to the disk in the order they are received or as soon as they are received. Instead, it performs operations called merging and sorting to greatly improve the performance of the system as a whole[2]. The subsystem of the kernel that performs these operations is called the I/O scheduler.

io scheduler называт еще elevator.
потмоу что его задача ( по крайней мере для шппненльных дисков) в тмо чтобы 
головка шла ровно и нескакала постоянно.

на праатике есть дефолтовый шедулер в системе. как его поменять.
надо в grub примненмть опцию elevator

/boot/grub/menu.lst :

title CentOS (2.6.18-128.4.1.el5)
root (hd0,0)
kernel /vmlinuz-2.6.18-128.4.1.el5 ro root=/dev/VolGroup00/LogVol00 elevator=noop
initrd /initrd-2.6.18-128.4.1.el5.img

это по деолфту выставит для всех блочных устройств io шедулер = noop

провеоить прям щас какой шедулер работает на кокнктеном блочном устрйостве можно так:
$ cat /sys/block/nvme0n1/queue/scheduler 
[none] mq-deadline 
 

его на лету можно переклчить. через 
echo mq-deadline > /sys/block/disk/queue/scheduler

если хотим для оотдельного диска кастомный и чтобы после перегазуруки осталось 
перманентно то надо заюзать правила для udev.

vmware пишет что для линуксов втруталок надо бы ставить none шедулер потому что 
в конечном итоге каждля виртуалка незнает о других вируалках поэтому надо оставит 
задачу реэрейнждмента порядка счтывания LBA блоков гипервизору. тоесть надо на виртуалках
проставить шедулер = noop

раньше до появления nvme дисков да и вообще в эру шпиндельных дисков
были такие шедулеры:
noop
Completely Fair Queuing (cfq)
Anticipatory
Deadline

потом появился еще bfq

основная  цель оптимизации у шедулеров была уменьшить прыганье головки на шпинеделях.
а когда пошли ssd то это все отпало. 
на данный момент для nvme считается самым отличным шедуелером это none шедулер.  тоесть
в устроство подается вобщмто просто поток запросов а вся оптиамизация переклдывадется на 
сам nvme диск.

- закончил на том что есть старый io шедулер. у него там разные есть элеавторы.
но их общая фигня в том что в конечном итоге реквесты от всех процессов к блочному устройству
как я понял обрабатываться в рамках одной очереди. и эта одна очередь обрабабтыватеся
всего одиним ядром цпу. поэтому скорость одного ядра цпу это ровно то место узкое
которое мещает выжмать иопсы. поэтому был придуман новый шедулер механизм. 
в котором во первых очередь разбивается на две части. в первой части находтся софт очереди
во вторйо части хард очереди. софт очередй много столько скольк ядер. в этих очередях
происходит перегруппирова запросов и так далее.  уаждого ядра есть своя софт очередь доя блочного устрйоства. тоеть если 10 ядер то для конкретногого блочного /dev/nvme у нас будет 10 софт очередей. если процесс сидит на ядре 1 и он на этом ядре вызывал read() и далее 
цпу перешел в режим ядра то этот реквест будет попмщен в софт очередь этого цпу. и ответ
от железкт придет именно на это цпу. окей получаетя запросы к /dev/sda от процессовна разных
цпу начали обрабаывться на разных цпу (распараллелились). эта вся хрень с очередями 
работает на уровне block layer в ядре. ина данном этапе мы никак не связаны с конкретикой
драйвера /dev/sda. вся мудота с группировой перемшиванием ркевестов в очереди идет именно
в софт очереди. я неочень понимаю как долго работает block layer по времени. пока я вижу это так. процесс на цпу запустил read() если еще тайм слайст незакончился то цпу переходит в режим 
ядра и запускает сисколл то выполняет код ядра с очередями. и в какойто момент происхоит
таймер интеррапт запускается процесс шедулер. и он выдавливает block layer код с цпу и запускае другой процесс. потом опять доходит очередь до этого проецесса и код ядра block layer наконец заканчивает там манипулиции с софт очередью и далее видимо первый с начала запрос 
из софт очереи передается в хард очередь если в ней нет места то там есть промежуточная 
хрень для храннеия. хард очередь это очереь в которой уже непроисходит никаких перестановок
запросов  в ней. она чисто я так понял FIFO. и из нее запросы уже передаются в драйвер /dev/sda
на исполнение. число хард очередей равно числу очередей которые поддеживает железка.
и тут мне непонятно то что какой цпу обратвает хард очередь конкретную. если софт очередл 
каждя четко привязана к кокнкретному цпу то как выбирается цпу для обработки для продивджения реквестов по хард очереди. ведь очереь это просто кусок памяти. а чтобы она работал нужен цпу
которй будет по ней двигать реквесты. вот это непооятно. а так запрос из хард очереди передается в low level драйвер /dev/sda и тот уже как то там конкретно пихает запрос в железку
все это время тайм слайс может закончится и шедулеор выдавить этот код с цпу. потом обратно 
засунет. а ответ в систему прилетает уже вот как - когда железка прочитала сектора то она
гененирует интеррапт и доставку от железки до ядра куска инфомрации уже идет по интерапту.через оарботчик интерапта. щас для меня все вынгляди так что если процесс 
однотредовый то скорость иопсов для него все равно зависит от скорости одного ядра цпу.
хотя конечно процесс шедулер может случайно перемещать процес между цпу и он успееет насовать
свои рекветы во всех софт очереди на всех цпу. тогда да мы неупелис в одно ядро. но 
по прежнему неонятнен вопрос какие цпу обслуживают хард очереди. 

двигаем дальше. я понял что при запросе на чтение\запись read(), write() можно исполовать
флаu O_DIRECT (называется Direct I\O операция). он дает то что мы говорим ядру что мы нехотим использовать page cache а мы 
хотим читать и писать сразу на железку.

вот картинка про i\o систему в ядре. = https://www.thomas-krenn.com/de/wikiDE/images/e/e0/Linux-storage-stack-diagram_v4.10.png

ищем там I\O scheduler и blmk.
I\O shceduler это старая версия i\o шедулера а blmk это новая.
на схеме мало что понятно но видно что у старого шедулера была одна штука hardware 
dispatch queue а у нового blmk их несколько. hardware dispatch queue это очередь 
запросов на чтение запиьс которая идет от block layer(общий абстрактный уровень работающий с очердями на запросы ) к драйверу кокретного блочного утсройства /dev/sda.
так вот эту очередь  hardware dispatch queue в итоге обслуживает некоторый кокретный цпу
так вот когда раньше она была одна ( персональная для кажого блочного устрйоства)
то как я понимаю поскоьку продивжением запросов по ней и передачей запросов из нее в 
драйвер блочного устройства занимался один цпу и поэтому скорость работы на блочном устройстве
упиралась в скорость одного ядра цпу (при этом непонятно а что сам драйвер блочного устройства
он что неупирался в ядро одного цпу?) а с новым blmk таких очередей hardware 
dispatch queue уже несколько (их число зависит от числа очередей поддерживаемых железкой)
и поэтому как бы теперь число iops которые мы снимаем с железки неупирается в скокрость одного
ядра цпу.(при этом непонятно а что сам драйвер блочного устройства
он что неупирался в ядро одного цпу?)
том кренн пишет - Blk-mq allows for over 15 million IOPS with high-performance flash devices (e.g. PCIe SSDs) on 8-socket servers
Вот еще картинка про blmq - https://www.thomas-krenn.com/en/wiki/File:Blkmq-two-level-Linux-block-layer-design.png

насколко я примерно понял запрос от проги read() поступает в ядро в vfs. 
она обращается  к драйверу конкретной File system оно делает обращение в block layer коду
а тот к драйверу конкртеного блочного устройства /dev/sda (ествственно это все внутри ядра
и там нет никакого /dev/sda ведь это точка входа к блочному утсройству для юзерских программ.)

тут я еще чтото хочу сказать. есть две проблемы. одна это собрать все запросы на чтение\запись 
от всех процессов перегруппироват их и сунуть в блочное устройство. большая работа и большая 
мудота  при этом в том чтобы все это правильно перегруппировать. 
вторая часть работы это обратно доставить к процессу данные которые прилетели наконец
от диска. это две разные проблемы. обратная доставка вроде проще. надо просто взять то
что поступило и сунуть в процесс. значит про первую про первую часть проблемы. как я понял 
со старым планировщиком было так что была одна софт очередь и одна хард очередь на весь комп ( для одного блочного устройства. у каждого блочного устройства своя инивиудальная 
софт+хард очередь. мы щас рассматриваем отдельное блочное устройство и проблему высокосростного доступа к нему). так вот если на пяти цпу крутится пять процессов и каджый из них щас хочет прочитать из одного /dev/sda то каждый из них переходит в режим ядра и пять экземпляров кусков ядра хотят получит доступ к одной и тойже стркутуре в памяти ядра софт очереди и хард очереди. эта структура защищена спинлоком то есть в однин момент времени 
только с одного цпу один кусок кода ядра может с ней рабоатть. незнаю насколко это проблема большая но это проблема. в новом планирщвике каждый код ядра на каждом цпу имеет свою индфивидуаьную софт очередь. ну хорошо. и есть несколько ( в зависимости сколько прддеживает железка /de/sda) хард очередей.это безусловно позволяет более бодро принимать от процессов
запросы IO к /dev/sda. ну хорошо. а драйвер /dev/sda он позвояляет запускаться в несколльких 
экземплярах чтобы бодро принимать увеличивешееся количество запросов с нескольких хард очередей? ведь как это походу работает по мне: процесс на цпу юзерский запускает read (/dev/sda) цпу переклюается в режим ядра. там код ядра пихает запрос в софт очередь ( тут проблем и пересечений с другими процессами и ядрами цпу нет). далее код ядра беррет чтото из софт очереди
и пытается впихнуть в хард очередь . и тут уже есть проелма так как число хард очередей может 
быьт меньше чем число цпу. тоесть там должен стоять спин лок. итак мы тут уже ждем. потом 
наконец мы получили доступ к хард очереди . пихнули туда запрос. далее как я понимаю мы запускаем уже драйвер /dev/sda и из хард очереди он забирает кусок и пихает на железку.
так вот в этот момент надругом цпу может быть ровно такая же ситуация и вопрос когда на первом
цпу запущен драйвер /dev/sda то на дургом цпу может ли быть запущена +1 копия драйвера 
/dev/sda или надо ждать?  если надо ждлат то тогда эта новая модель шедулера всего навсего
нам дала доп буфер в виде софт очередей ( по одному на цпу) и только то а в конечной точке
у нас попрежнему узкое место. непонятно. ну и опять же на старой модели шедулера. ну была у нас одна софт и хард очередь на весь комп ну и что. пока на одном цпу пихает запросы в очередь
на других цпу код ядра неможет этого сделать. типа он ждет ну и что. дело в том что 
даже если код ядра весело запихал на всех цпу запросы в очередь все равно юзерское приложение
спит пока неполучит ответ с диска. непонятно. непонятно также то что очереди конечно 
же предназначены чтобы двигать запросы от приложений к диску. а как доставляются ответы от диска к процессам ? совершенно понятно что когда диск нашел ответ  на запрос он запускает 
интеррапт. выывается интеррапт обработчик. он берет этот ответ от диска и тут вопрос
как обрботчик знает какие куски ответа к какому процессу надо доставить? это вобще непонятно.
также еще вот что непонятно. вот нащ интерапт хендлер забрал ответ от диска и сунул пока в
 память ядра и начал разбраться какому процессу какие байты сунуть. пока он это делает 
 может ли диск выставиь еще интеррапт чтобы его на другом цпу обработали или нет? если нет 
 то получается что ответы от диска завязаны на скости работы одного ядра!
 так что одни вопросы. ответов в инете нет. 
но так в целом они прям усираются о том что раньше мол была одна софт очередь и одна хард 
очередь а теперь их несколько и это мол чудо. мол это снимает ботлнек как бутто там других
ботлнеков нет в этой цепи от read() до запроса в диск.
так вот непонятно вот когда мы в iometer задавали скажем  число потоков в 10.
то ведь они же все равно все уходили в одну очередь на старом шедулере поэтому непонятно
как же эти потоки в юзерской программе трансформировались в потоки к диску ведь в диск
уходил все равно один поток который сумма просто напросто этих десяти потоков.
непонятно.
но они щас на что напирают мол раньше были шпиндели поэтому мол посылать на диск
следущий реквест когда он невернул ответ по текущему реквесту типа небыло смысла ( не знаю
неуверен в верности этого заявления) поэтому старый шедулер имел только один поток ведущий
в драйвер. а щас мол так как у нас ssd\nvme то они могу спокойно искать одновременно 
неоколько независимых реквестов.

очереди зовутся как software queues и hardware queues( синонимы hardware contexts queues\hardware dispatch queues).

далее я щас пытаюсь выяснить сколько hardware queues поддерживает мой текущий 
nvme диск.

$ sudo nvme smart-log  /dev/nvme0n1 
Smart Log for NVME device:nvme0n1 namespace-id:ffffffff
critical_warning                    : 0
temperature                         : 33 C
available_spare                     : 100%
available_spare_threshold           : 10%
percentage_used                     : 1%
data_units_read                     : 10 169 142
data_units_written                  : 14 999 997
host_read_commands                  : 134 639 775
host_write_commands                 : 340 324 085
controller_busy_time                : 399
power_cycles                        : 1 609
power_on_hours                      : 2 318
unsafe_shutdowns                    : 31
media_errors                        : 0
num_err_log_entries                 : 0
Warning Temperature Time            : 0
Critical Composite Temperature Time : 0
Thermal Management T1 Trans Count   : 0
Thermal Management T2 Trans Count   : 0
Thermal Management T1 Total Time    : 0
Thermal Management T2 Total Time    : 0

посмотреть какие nvme неймспейсы есть на диске (это не линукс неймпесейсы а чисто хрень nvme)
$ sudo nvme list-ns  /dev/nvme0n1 
[   0]:0x1

видим что есть один неймспейс.

а теперь более интересная хрень.
выяснить какой размер LBA сектора nvme диск экспортирует наружу в ядро:

$ sudo nvme id-ns  /dev/nvme0n1  -n 1 -H  | grep "LBA Format" | grep Metadata
LBA Format  0 : Metadata Size: 0   bytes - Data Size: 512 bytes - Relative Performance: 0x2 Good (in use)
LBA Format  1 : Metadata Size: 0   bytes - Data Size: 4096 bytes - Relative Performance: 0x1 Better 

отсюда видно что для линукса диск сообщает что у него как бы размер сектора LBA равен 512 байт.
но лучше бы нам ппреключить железку (правда при этом все данные сдохнут) чтобы она стала 
для внешнего мира как устрйоства с размером LBA сектора равным 4KB.
меньше будет запиливаться и больше будет перформанс.

также можно без ключа -n 1 чтобы получить эту инфо
$ sudo nvme id-ns  /dev/nvme0n1   -H  | grep "LBA Format" | grep Metadata

чтобы перкключить диск в режим LBA 4K надо его отформатировать
$ nvme format --lbaf=1 /dev/nvme0n1   
ключ --lbaf=1 его цифра 1 означает то что выше написано тоесть 
0 = LBA Format  0 = 512 байт
1 = LBA Format  1 = 4K 

==========================================================================
- далее я пытас выяснить сколько hardware queues поддерживает мой диск
$ sudo nvme get-feature /dev/nvme0n1 --feature-id=7 -H
get-feature:0x7 (Number of Queues), Current value:0x0f000f
	Number of IO Completion Queues Allocated (NCQA): 16
	Number of IO Submission Queues Allocated (NSQA): 16


pci vs pci-e vs sata vs ahci
что такое шина. шина это набор проводов, разьем и стандарт передачи по проводам.
шина имеет скорость. 
шина содеиняет чтото слева с чем то справа.

pci: это шина и разьем на матплате. одним концом на мат плате она представлена разьемом(куда мы втыкаем внешнее устройство контроллер чегото) другим концом шина уходит в южный мост например ICH9. шина многопроводковая тоесть паралельная. паралельность еще заключается и в том 
что все устройства все разьемы на плате в итоге разделяют одну шину. поэтому они все конкурируют и делят пропускную способность шины. для параеллельных шин обычно
указывают частоту. у pci это 33 Mhz , размерность шины 32 бита. скорость при этом 132МБ\с(33Mhz*4байта=132МБ\с). 
разьемов на плате можте быть несколько скажем пять но все эти разьемы сидят на общей шине
так что либо одна плата будет выжимать 133МБ\с а остальные ноль. Либо все пять будут делить 
133МБ\с.( а не так что каждый разьем будет иметь 133МБ\с). это был основной стандарт.
где то там в конце жизни pci была модификация 66MHZ и 64бита и она выдавала 532МБ\с.
(оно и логично в 2 раза боьше разрядность и в 2 раза болбше частота итого 133МБ\с *2 *2 = 532МБ\ч). итак если мы рассмотрим все же обычную шину PCI 33Mhz,32bit то скорость суммарная
на все устрйоства которые к ней поключены 132МБ\с, они все ее делят между собой.
32битная шина имеет 124 провода (62 по одну сторону от разьема и 62 по другую) в архитектуре. из них данные и адрес используется 64 провода(32 используются под сигнал а 32 для второго конца провода. условно говоря 32 провода это фаза и 32 провода это ноль).
тоесть 4 байта можно передать за раз.  поскольку под передачу данных используется 32 пары
проводов ( остальные под какито доп обеспечительные нужды) то это означает что 4 байта можно 
передавать либо в одну сторону либо в другую , либо туда либо обратно. поэтому шина pci она 
half-duplex. для того чтобы она была полностью дуплексная нужно было добавлять еще 32 пары проводов. для сравннеия ethernet 100. там 2 пары проводов тоест 4 штуки в итоге. по одной паре сигнал идет на отправку по второй на принятие. поэтому там полный дуплекс. зато за один раз можно передать только 1 бит. тоеть еще раз у pci у нее 32 пары проводов и все пары предназначены для отправки только в одну сторону либо туда либо обратно. а у ethernet 100 две пары прием одна строго для отправки а другая строго на прием.  так вот оказалось что 
когда у нас много пар используется для отправки в одну сторону то это типа очень плохо потому что по одной паре сигнал придет чуть позже по другой чуть раньше а поскольку мы дожны принять 
по всем парам в итоге то нам приходится ждать и там наверное еще какието проблемы с влиянием
сигнаа  в однйо паре на другие пары короче оказалось что наращивать частоту сигнала когда у нас
много пар работает в одну сторону очень хреновая перспектива , оказалось что горазло более проще взять вместо 32 пар всего одну пару и по ней охиренно поднять частоту и на выходе мы сможем получить гораздо более высокую скорость пропускную. поэтому отказались от дальнейшего развития многожильной pci шины в сторону маложильных шин в которых скажем 2 или 4 провода. 
прием если 4 то это два в одну сторону и два в другую тоест они друг от друга независят. 
Забегу впреед pci-e шина. у нее есть понятие линия. линия это 4 провода . где одна пара идет
на отправку вторая на принятие. поэтому она фулл дуплекс. и скорость у нее на  данный момент чтото типа 15GB\s ( по сравнению с 133МБ\с у обычной pci). я продолжаю сранивать pci и pci-e.
у pci на ее 32 парах линий сидели сразу все устройства  и делили ее межу собой. у pci-e 
выгляди по другому. условно говоря на мат плате разведено 50 пар линий pci-e. и скажем там первые четыре линии выходят на разьем. потом следущие 4 линии на матплате выходят на разьем.
потом еще 8 линий выходят на разьем. и фишка в том что если мы воткнули карточки в первый и второй разьем то так как линии независимые от устройства невлияют друг на друга. это как 
если бы у pci первые 4 линии выходили на разьем и вторые 4 линии  выходили на свой разьем. 
тогда бы два устройства невлияли друг на друга в плане конкуренции за пропусную способность по через шину. если сказано что разем pci-e x16 это значит что 16 линий выведены на данный разьем.
совестенно если 1 линия выжиаем 15GB то суммарно 16 линий могут выжать 16*15GB\s.
Возвращаемся к PCI. значит из ich9 выходило 62 пары проводов и они уходили на мат плату на разьемы. эти разьемы все сидели на этих 62 парах делили их. получаетс что в каждй момент времени из pci в ich9 прилетало 4 байта инфо только от одного устройства. остальные сидели и ждали когда им дадут тайм слот. но в ICH9 приходили линии нетолько с pci шины но и из других
шин. это и usb контроллер и ethernet контроллер и звуковая карта они тоже приходят 
с мат платы на ich9. тоесть к примеру говоря на плате есть разьем sata и он 
по отдельно распаянной sata шине на мат плане входит  в ICH9. значит ICH9 далее соединяется
с северным мостом по шине DMI. для ICH10 эта шина была по скорости 1GB\s и полный дуплекс.
северный мост уже соединяется с цпу через FSB шину. вот наконец картинка как это выглядело
https://en.wikipedia.org/wiki/File:Motherboard_diagram.svg
на ней видно что все разьемы pci делят между собой одну шину. про FSB шину ну скажем что 
она имела скорость 3.2GB\s. возникает вопрос а  как цпу  обращался к pci шине. 
нужны либо отдельные на цпу адресные линии которые можно выставлять которые должны вести 
в pci линии. либо нужен memory map chip который будет делать то что при выставлении н
на стадартной шине адреса для памяти на цпу некоторого адреса чтобы этот чип переключал
на адресные линии pci. ответа незнаю как это было сделано. потому что в целом варианта у цпу
еще раз повторю два. либо у него должные быть отдельные ножки адреса\данных для ообращения
к шине либо он должен юзать ножки предназначеные для памяти а спец мемори чип должен 
в это время перехватывать и мапить на шину. также видно что dmi шина точно неузкое
место тоесть всем периферийным устройствам хватит ее ширины для обращения наверх.
но возникает интересный вопрос - из картинки видно что слева от цпу видеокарта
справа память снизу южный мост с периферичнымт устройствами так вот фишка втом насколько я понимаю что в каждый момент времени цпу может обращаться тольк к одному устройству. 
тоесть либо к памяти. либо в к видеокарте либо к pci устройству. тоест неможет одновременно
читаь и из видеокрта и из памяти и из pci шины поэтому неочень понятно скажем зачем DMI размером 1GB\s если в любом случае ... хотя на картинке от ICH9 изображен 1GB сеетвой контроллер поэтому да чтобы его сокрость раскрыть нужен наверх шина 1GB\s . я к тому что 
на DMI нужна скорость несуммарная от всех периферийных устройств сидящих на ICH9 а только 
скорость самого быстрого. потому что цпу неможет обращаться более чем к 1 устройству на текущий  момент. едиснвтенное что возможно еще играет роль это DMA. тоесть 
DMA контроллер может качать данные из периферийного устройства в память через ich9 и северный мост и однрвемнно цпу в это время может качать данные скажем с сетевого контроллера. тогда 
да получается что через DMI в момент времени будет протекать потоки от двух периферийных устройств одноврменно и тогда DMI должен быть шире чем пропускная споосбность этих двух 
и более устройств. вот еще картинка для схемы северный мост-южный мост 
https://en.wikipedia.org/wiki/File:Intel_4_Series_arch.png
кстати когда бала схема севеный+южный мост то контроллер памяти сидел в северном мосту.
далее вместо и южного появилась схема одного моста PCH (platform controller hub)
который соединяется с цпу по DMI. а контроллер памяти сидит в цпу. память уже содеиняется
напрямую с цпу без участия мостов. схема - https://en.wikipedia.org/wiki/File:Intel_5_Series_architecture.png

Возврашаемся к PCI.
итак байти от нее летел в ICH мост южный. далее через DMI летет в северный мост и далее
через FSB летел в цпу. вот стока переходов. 
это нам пригодится когда щас будет рассматривать PCI-e. насколько там сократился этот путь.

а пока рассматриваем PCI и ее связь с дисками. диск в pci напрямую не воткнуть.
в PCI втыкался контроллер дисковый . на нем находился PATA контроллер.одним концом
эта плата воткнут в pci шину. на контрллере находится разьем PATA. воткнут кабель PATA
и он уже уходит в диск с разьемом PATA. либо контроллер распаян на плате и тут я незнаю
он был подключен к шине PCI либо он был подлкючен к ICH мосту напрямую минуя PCI. 
скорость PATA шины это 133МБ\с.
PATA шина она тоже как и PCI много проводковая. она также полудуплекс. 
шина имела 40 либо 80 проводков. ширина 16бит то есть 2 байта. значит 16 проводков под дата
3 под адрес ( на щине могло сидеть максимум 2 устройства). с обратный проводками там как то более хитро чем у PCI. но главное что 40 жильный разьем и 80 жильный отличались тем что 
доп 40 жил это все типа ЗЕМЛЯ предназначенная для того чтобы можно было повысить частоту 
шины до 66MHz. тоесть доп 40 жил они были не для того чтобы добавить полный дуплекс. 
они были служебные чтобы можно было добавить частоту. да и смысла небыло в полном дуплексе
ибо крутящиеся диски могли либо читать либо писать. одновременно там бы упала скорость сильно.
получается схема выглядела в лучем случае байтик который летел от диска его путь 
выглядел так:

диск - PATA шина - (PATA контроллер в ICH9) - DMI щина - north bridge - FSB шина - цпу

или еще хуже


диск - PATA шина - PATA контроллер - PCI шина - ICH9 - DMI щина - north bridge - FSB шина - цпу

так значит с PCI и PATA разобрались.

переходим к SATA:
Sata это шина и разьем. SATA в отличие от PATA или PCI неимеет множества проводов.
в этом плане sata шина она очень узкая. в плане скорости выдает SATA 3 выдает 6Gbit/s или еще пишут так что выдает 6GT/s это одно и тоже. но фишка в чем, нахера тексели ввели, фишка втом что на каждые 8 переданных бит добавляется 2 служебных бита(обозначается 8b/10b) поэтому 6Gbit\s это полный поток
а поток полезной информации это 6(Gbit\s) * 8\10 = 4.8 Gbit\s или ~600MB/s 
Далее важно сказат что sata это полудуплексный шина тоесть данные в момент времени
по шине летят либо только туда либо только обратно но не одновременно. 600MB\s это скорость
либо туда либо обратно. 
теперь возвращемся к очень интересному моменту. в проводе SATA между контроллером и диском
4 провода а наконцах этого провода 7 пинов. И это для меня загадка. Единственное что 
4 пина это для передачи данных , тоесть эти пины это как провода что мы видим в проводе
а 3 пина это GROUND и я непонимаю а что ground нетребует наличия проводов в проводе?
вот это мне непонятно. переходим к тому почему 4 провода в кабеле. как я понял смысл такой - 
эти четыре провода это две пары обычных контуров электрических. тоесть в одной паре ток входит
в один провод и возвращается через другой и во второй паре тоже самое. возникает идея что 
по одной паре передается инфо туда а по другой обратно. тоесть один бит пераедается по одной паре туда а другой бит передатеся по другой паре обратно. типа мы имеем полнодуплексную шину шириной 1 бит. ну или это шина шириной 2 бита в одну сторону полудуплексная. однако все совсем
нихера нетак все устроено у SATA. значит у SATA применяеся differential signaling. что это значит. для него нужно 4 провода (например). далее я пока непонимаю как физически передается сигнал и как он фиксируется но примерно так: у нас есть первая пара проводов которая является
классической электрической парой (типа как два провода из розетки и лампочка, один провод это фаза второй это ноль). так вот на первой паре на первом проводе на фазе мы дергаем по времени 
Voltage. например было там +0 а мы на короткое время дернули его на +12V. и это возмущение
побежало по проводу. Что ловят на том конце я незнаю. То ли изменнеие волттаджа во врмени
то ли появление тока. я незнаю. но возмущение долетит до второго конца и там словят условно говоря появление +12V. и через ноль эта хрень улетает обратно. Теперь берем вторую пару 
проводов и в фазу подаем в тотже момент времени -12V. и это вомзущение побежало по проводу.
А теперь самая главная хрень зачем мы это мутили - если на провода снаружи идет наводка электромагнитная то она и в первом контуре скажем для примера исказит сигнал и прибавит  к нему условно говоря +1V и во втором контуре она сделает тоже самое. так вот на той стороне
стоит электрический (незнаю как это на практике выглядит) дифференциатор. и тогда вот что 
он там получает 

+12V+1V - ( -12V +1V) = +12V + 1V +12V -1V = 24V

тоесть наводка будет полностью уничтожена этим дифференциатором исходя из того что она дала 
одинаковое возмущение на оба контура. а наш исходный сигнал получен с удвоенной амплитудой.
вот эта вся схема и называется differential signaling. а используется она для защиты от внешних наводок. сотвественно логично что обе фазы обоих контуров надо в кабеле расположить максимально близко чтобы внешнее воздействие на обе фазы было по амплитуде максимаьльно одинаковое. Итак по сути у нас через два канал передается всего один бит информации. но зато мы имеем помехаозащищенность. для сравнения посмотрим что было бы если бы мы использовали 
одну пару проводов и single ended signaling. тоесть у нас есть одна пара проводов и мы
на фазе дергаем и выставляем имупульс +12V.
возмущение летит по проводу и тут снаружи у нас помеха и она дает -13V
тогда на втором конце мы вместо +12V получим -1V тоесть бит информации абсоллютно потерян.
когда же у нас differential signaling то мы будем иметь

+12V-13V - ( -12V -13V) = +12V - 13V +12V +13V = 24V

как видно бит непотерян ( ну тоесть если у нас будет делитель сигнала на два то мы получим
на втором конце теже самые +12V). вот что знчит differential signaling, вот зачем он нужен
и вот почему в sata кабеле четыре провода и при этом по факту шина полудуплексаная и имеет ширину 1 бит. 

Единственное что мне непонятно. для differential signaling надо иметь 4 провода в кабеле
и экранировать вроде их получается ненадо это плюс. но зато они должны идти друг от друга 
на постоянном расстоянии. это минус.  а если мы гвооими про защиту от помех то можно было бы
взять просто два провода с single ended signaling и просто на них наложить железный экран
снаружи и тогда тоже небудут помехти снаружи влиять. так в чем проблема? неужели 
изговтовить кабель  с двумя экранрованными проводами сложнее чем изготоввить кабель с четырьмя 
неэкранированными проводами но идущих на одинаковом расстоянии? непонятно

но зато хотя бы стало понятно почему в sata кабеле 4 провода при том что передается всего 
1 бит и сввязь полудуплексаная.


- компексные числа и сигналы.
компдексное число это (по определению) всего навсего пара чисел. обозначается вот так
(x,y).  и сразу видно что компл число в точности выглядит как координата точки на какойто
плоскости.

еще (по определению ) комплексное число обозначается как z. тоесть
(x,y) и z это одно и тоже.

для комлпесного числа (по определению) определены операции сложения, умножения, равенства.

равенство:
 это когда
z1=(x1,y1)
z2=(x2,y2) 
тогда z1=z2 если x1=x2 и y1=y2

cсложение:
z3=z1+z2
z1=(x1,y1), z2=(x2,y2)
z3=(x1+x2,y1+y2)

умножение:
z3=z1*z2 = (x1*x2-y1*y2, x1*y2+x2*y1)
физичекий смысла неочень понятен.

далее рассматриваются числа вида (x,0)

z1+z2 = (x1,0) + (x2,0) = (x1+x2, 0)
z1*z2 = (x1*x2,0)

ну видно что получаемое компл число тоже имеет вид (x,0)

дальше они пишут стремную вещь что (x,0) поэтому можно обозначать как просто x 
тоесть

(x,0)=x

по мне это равенство это хрень какаято. обьекты справа и слева это разные штуки.
а именно слева находится пара чисел x и 0 а справа одно число x и как 
это можно приравнивать? ведь комплексное число по опредеению это ПАРА чисел! пара!
поэтому пара никак не может быть эквивалентна одному числу!. два числа никак не могут
быть эквивалентны одному числу! поэтому я пока могу эту хрень только вот так 
интерпретировать: если у нас указано x то это типа такое типографское сокращение
для обозначения (x,0). итак еще раз
если указано просто x то мы пониммаем что это сокращение обозначений ( считай что по факту
это некоректное обозначение) и по факту это некоректное обоначение обозначает (x,0).
опять же еще раз - определение комплексного числа это всегда пара чисел. (x,y)
нет никаких комплесных чисел вида x. что еще интеренее что есть определение о том как 
сложить два компелксных числа и как умножить два комплеатных числа но совсем нет 
инфо о том как сложить или умножить комлпексное число и некомплексное число!


(тут еще набор пространных рассуждений. - по мне хрень полная. слева координата а справа число. совершенно разные обьекты.
хотя можно вот так рассматривать что число x оно может быть обозначено на числовой прямой.
если у нас есь числовая прямая то координата числа x это x или вот так (x) просто обычно
никто не использует координаты для числовой прямой. числовая прямая это одна из осей плоскости в которой есть две оси координат. как только мы добавляем вторую ось то все числа
на исходной числовой прямой автоматом приобретают вид (x,0) а если третью ось добавим 
то приобретают вид (x,0,0) таким образом в какойто степени (x,0)=x хотя это как бы и хрень хотя как сказать. что является первичным число или числовая прямая. если числовая прямая то число это всего лишь ее свойство тогда скорее (x,0) явялется коректной записью числа а запись 
вида x это некий колхоз ибо небывает просто чисел числа все сидят на числовой прямой. вобщем хрен знает. ясно по крайней мере то что между числом x и точкой на оси (x,0) можно установить однозначное соотвествие. это точно. тоесть нет такого числа x которого бы небыло на (x,0)
и нет такой точки (x,0) на оси для которого бы несуществовало бы числа x. а так в целом непонятно что первично числа которые уже затем образуют числовую ось или ось внутри которой содержатся числа. поидее ось первична а числа это ее свойство. типа как  космос и пространство первича а атомы это их просто свойства. типа нет ни одного числа которые бы было рождено вне числовой прямой. наверно как то так. так.. хотя... что такое число если взять
напримере натуральных чисел. число это кучка яиц куриных или горка песка морского. хотя опять же это несамо число это его форма визуализации. что такое само число непонятно. чтото 
нематериальное чтото неведомое. типа как тепло. есть некая форма носителя или форма восприятия на теле но что такое тепло само неясно. так и число. если начать выкладывать 
в ряд числа в форме песка то это будет ряд горок от маленьких до больших. это будет 
альтернативный аналог числовой прямой. поэтому все таки вначале числа а числовая ось это форма визализации.. пока про это все.

далее рассматривается 

(x,0)*(1,0)=(x*1,0)=(x,0)
мы видим что умножение дало тот же результат что и исходное число
тоесть 
(x,0)*(1,0)=(x,0)

далее они еще раз пытаются установить связь между обычными числами и комплексными
они говорят что обычное число А и комплексное число (A,0) это одно и тоже ( у меня шок)
с одной стороны как число и пара чисел может быть одним и тем же. вот для примера 
прдеставим обычную трехмерную систему координат ( несвязанную с комплексным числом никак).
далее берем число 1. вопрос  (1,0,0) (0,1,0) (0,0,1) и 1 это одно и тоже число ? или может
вообще нельзя сравнивать обьекты разной природы. что такое (1,0,0) = есть три множества
чисел ( каждая ось это множество) и мы берем по одному числу из каждого множества 
и создаем новое множество из трех чисел 1,0,0 . множество из трех чисел. как можно множество
из трех чисел приравнивать к числу? поэтому я считаю что говорить что число А и множество
из двух чисел А,0 одно и тоже это некоректно. однако далее я принимаю эту их точку зрения
и считаю что если написано А то это типографское сокращение для комплексного числа (А,0)
Так вот далее они говорят что мы щас мол введем операцию умножения обычного реального числа
на комплексное число ибо к данному моменту мы такого рода операцию не определелили.

А- обычное число . но мы себе понимаем что на самом деле это комплекс число (A,0)
z - комплексное число
тогда
A*z это будет умножение не обычного числа на комплексное а комплексного на комплексное (а это мы уже умеем делать) а именно

A*z=(A,0)*(x,y)=(А*х, А*y)

итак еще раз если мы видим в одной строке комлпксное число и обычное число то мы сразу
понимаем что никакого обычного числа нет а это просто типографское сокрашение для комлпексного числа (А,0)



Далее рассмотрим умножение  (x,0)на  (0,1)

(x,0)*(0,1)=(x1*x2-y1*y2, x1*y2+x2*y1)=(0-0,x)=(0,x)
тоесть
(q,0)*(0,1)=(0,q) 
если мы заменим (q,0) типографским сокращением на q то получаем
q*(0,1)=(0,q)
или
(0,y)=y*(0,1)
еще раз подчеркну что y это просто сокращение типографское для комплксного числа (y,0)
потому что у нас операции определены только для комлпксных чисел поэтмоу все числа 
в строке дожны быть строго комлексные.
комплексное число (0,1) называется мнимой единицой(чисто такой у нее позывной). это 
число так называют потому что
(0,1)*(0,1)=(0-1,0)=(-1,0)
если мы обозначим число 0,1 как i то получаем
i*i=(-1,0)
или
i^2=(-1,0)
далее заменяем (-1,0) на типографское сокращение -1
получем
i^2=-1
еще раз хочу подчернуть что -1 в данном случае это не -1 а сокращение для комлпксного числа (-1,0) так что ненадо путать -1 и (-1,0)

двигаем дальше:
z=(x,y)=(x,0)+(0,y)
вышем мы получали что (0,y)=(y,0)*(0,1)
заменяем (0,1) на ее обозначение через i получаем 
(0,y)=(y,0)*i=i*(y,0) подставляем в z

z=(x,y)=(x,0)+(0,y)=(x,0)+i*(y,0)

пока все строго пока все четко.

дальше применяем типографское сокращение что (x,0) это x тогда

z=(x,0)+i*(y,0)=x+iy

z=x+iy 
это типа алгебраическая форма обозначения комлпкексного числа.
еще раз хочу подчеркнуть что эта форма это фикция. на самом деле нет в этой формул никакого
x и y болтающихся свободно в строке. это просто сокращение. реальная формула коректная это

z=(x,0)+i*(y,0)

где опять же i  это (0,1)


еще раз итак мы имеем
z=(x,y)=x+iy
отсюда мы чисто на глаз видим важную полезняшку
когда мы имеем алгабраическую форму комлпексного числа то то что стоит за буквой i
это вторая компоенента а то что стоит без буквы i то это первая компонента.тоест 
пример
z=3-i6 это значит что z=(3,-6)
тоесть мы можем мгновенно переводить одну форму записи коплексного числа в другую





рассмотрим
z1+z2=(по определению)=(x1+x2,y1+y2)
теперь рассмотрим в новой форме z1+z2=(x1+iy1)+(x2+iy2) , теперь приравниваем
(x1+x2,y1+y2) = (x1+iy1)+(x2+iy2)
раскроем правую часть и проверим что получим то что слева
(x1+iy1)+(x2+iy2)=(x1,0)+i*(y1,0)+(x2,0)+i*(y2,0)=(x1+x2,0)+(0,y1)+(0,y2)=
=(x1+x2,0)+(0,y1+y2)=(x1+x2,y1+y2)
сравниваем с тем что слева
(x1+x2,y1+y2)=(x1+x2,y1+y2)
совпало ну а как же оно могло несовпасть.
я думаю что из алгеабраической формы для операции сложения тут важно
заметить что походу мы можем(чисто на пальцах) вынести правило такое что :
 z1+z2=(x1+iy1)+(x2+iy2)=(x1+x2)+i(y1+y2)



ну и для операции умножения: 
z1*z2=(x1,y1)*(x2,y2)
c одной стороны(по определению) 
z1*z2=(x1*x2-y1*y2, x1*y2+x2*y1)
с другой стороны используем новую форму записи комплексного числа 
z1*z2=(x1+iy1)*(x2+iy2)
получеаем:
(x1*x2-y1*y2, x1*y2+x2*y1)=(x1+iy1)*(x2+iy2)
исходя из этой штуки мы можем взять дерзость смелость применяя к правой части
колхозные методы работы с обыкновенными числами получить то что слева.тоесть раскрыть скобки
как мы бы это делали с обыкновенными числами. (хотя такой подход это чисто наш неподекрепленны математически метод). поехали раскрываем скобки:
(x1+iy1)*(x2+iy2)=x1x2+i*x1y2+i*y1x2+i*i*y1*y2
группируем и используем то что i*i=(-1,0)=-1
x1x2+i*x1y2+i*y1x2+i*i*y1*y2=x1x2+i(x1y2+y1x2)-y1y2=(x1x2-y1y2)+i(x1y2+y1x2)
сравниваем левую часть которая точно верна потому что по определению
и правую которую мы вывели колхозным пальцевым некоректным методом
(x1*x2-y1*y2, x1*y2+x2*y1) = (x1x2-y1y2)+i(x1y2+y1x2)
и как бы да все совпало. откуда я чисто из пальца делаю вывод
что в алгебраической форме с компоентами комплексного числа можно работать ровно также
в плане раскртия скобок сложения и умножения так же как мы это делаем для простых чисел.
это удобно. в этом плюс алгабраической формы. хотя строгого доказтельсва у меня нет.

далее.
комплксно сопряженное число.
число (x,-y)=x-iy является комплесно сопряженным числу (x,y)=x+iy

далее.
модуль комплексного числа ( по определению) обозначается как |z| и оно равно sqrt(x^2+y^2)
тоесть
|z|=sqrt(x^2+y^2)
теперь тоже самое в других формах
|z|=|(x,y)|
|z|=|x+iy|

теперь смотрим когда же |z|=0. это будет когда sqrt(x^2+y^2)=0 а это будет когда 
x=0 и y=0.
подставим x=0 и y=0 в алгебраическу форму
|z|=|0+i*0|=|i*0|=|(0,1)*(0,0)|=|(0,0)|=sqrt(0+0)=0

далее расматривается случай коплексного числа (x,0)
|z|=sqrt(x^2+0)=|x|
таким образом |z| для (x,0) совпадаеь с модулем обычного числа |x|

далее
z=x1+iy1
(сопряженное)z=x1-iy1
z*(сопряженное)z=(x1+iy1)(x1-iy1)=(x1,y1)*(x1,-y1)=(x1*x1+y1*y1, 0)=(x1^2+y1^2,0)
получаем(используем алгебраическую форму)
z*(сопряженное)z=x1^2+y1^2
теперь вспоминаем что |z|= sqrt(x^2+y^2).
возведем в квадрат
|z|^2= (sqrt(x^2+y^2))^2=x^2+y^2
теперь сравниваем:
z*(сопряженное)z=x1^2+y1^2
|z|^2= (sqrt(x^2+y^2))^2=x^2+y^2
видим что получаем одно и тоже .значит:
z*(сопряженное)z = |z|^2


далее. 
замечают что модуль |z| и модуль |сопряженный z| совпадают.
тоесть
|z|=sqrt(x^2+y^2)
|сопряженный z| = sqrt(x^2+(-y)^2)

далее они доказывают что
(z1*z2)*z3 = z1*(z2*z3)
и то что
(z1+z2)*z3 = z1*z3 + z2*z3
ну понятно как доказывается. 
и в книжке написано что благодаря этому доказывается что можно выполнять операции
с комплекными числами как бутто это обыкновенные числа и i  в том числе. то чем я занимался
там выше.

далее рассматриваются числа 1=(1,0) и 0=(0,0) и их свойства
z+0=z+(0,0)=z
z*1=(x+iy)*(1+i*0)=x+iy=z


далее.
разность z1-z2 называется такой z3 что z3+z2=z1

найдем 0-z
пусть z=(x,y)
искомый z3=(x3,y3)
0=(0,0)
тогда
(x3,y3)+(x,y)=(x3+x,y3+y)=(0,0)
значит
|x3+x=0
|y3+y=0

значит
|x3=-x
|y3=-y

значит
z3=(-x,-y)

найдем теперь общий случай z1-z2=z3
(x3+x2,y3+y2)=(x1,y1)

значит
|x1=x3+x2
|y1=y3+y2

значит
|x3=x1-x2
|y3=y1-y2

значит общее правило как выполнять отнимание:
z1-z2=(x1-x2, y1-y2)


далее
посмотрим чему равно 
-1*z= (-1+0i)(x+iy)=-x-iy=(-x,-y)
сравниваем и замечаем что 
0-z=-1*z
интересно.


далее
определяем что такое операция деления. z1:z2=z3
так вот z3 по определению это такое число что z3*z2 должно дать z1
итак ищем z3 пользуясь выражением z3*z2=z1
умножаем левую и правую часть на (сопряженное)z2

(сопряженное)z2*z3*z2=(сопряженное)z2*z1
тут мы пользуем формулу что раньше получили (сопряженное)z2*z2=x2^2+y2^2
значит
(x2^2+y2^2)*z3=(x2-iy2)(x1+iy1)
двигаем дальше
работаем с правой частью
(x2-iy2)(x1+iy1)=x2*x1+i(y1*x2)-i(y2*x1)-i^2*y2*y1=x2*x1+i(y1*x2-y2*x1)+y2*y1=
=(x2*x1+y2*y1)+i(y1*x2-y2*x1)=(x2*x1+y2*y1, y1*x2-y2*x1 )
подставляем
(x2^2+y2^2)*z3 = (x2*x1+y2*y1, y1*x2-y2*x1 )
работаем с левой частью
(x2^2+y2^2)*z3=(x2^2+y2^2)*(x3+i*y3)=x3*(x2^2+y2^2)+i*y3*(x2^2+y2^2)=
= ( x3*(x2^2+y2^2),  y3*(x2^2+y2^2)   ) 
подставляем
( x3*(x2^2+y2^2),  y3*(x2^2+y2^2)   ) = (x2*x1+y2*y1, y1*x2-y2*x1 )
значит чтобы было равенство то значит должно выполняться:
| x3*(x2^2+y2^2) = x2*x1+y2*y1
| y3*(x2^2+y2^2) = y1*x2-y2*x1

значит
x3= (x2*x1+y2*y1)
    --------------
    (x2^2+y2^2)

y3= y1*x2-y2*x1
    ------------
    (x2^2+y2^2)



значит
z1     (  x2*x1+y2*y1     y1*x2-y2*x1  )
--- =  ( --------------,  ------------ )
z2     (  (x2^2+y2^2)     (x2^2+y2^2)  )


выполним пример
1+i     2*1+(-3)*1       1*2-(-3)*1     -1       5
---- = ------------ + i*------------ = ---- + i*----
2-3i    4+9               13            13       13


далее смотрим на счет |z1*z2| = |z1|*|z2| проверяем
берем левую часть
z1*z2 = (x1+iy1)*(x2+iy2) = x1*x2+x1*i*y2+i*y1*x2-y1*y2 = (x1*x2-y1*y2)+i(x1*y2+y1*x2)
далее 
|z1*z2|=sqrt[(x1*x2-y1*y2)^2+(x1*y2+y1*x2)^2]
тут давай упростим выражение в скобках
(x1*x2-y1*y2)^2+(x1*y2+y1*x2)^2=(x1*x2)^2 + (y1*y2)^2 - 2*(x1*x2)(y1*y2) +
+ (x1*y2)^2 + (y1*x2)^2 + 2*(x1*y2)(y1*x2) = (x1*x2)^2 + (y1*y2)^2 +  (x1*y2)^2 + 
+ (y1*x2)^2 = x1^2*(x2^2+y2^2)+y1^2*(y2^2+x2^2) = (x2^2+y2^2)*(x1^2+y1^2)
подсталяем 
|z1*z2|=sqrt[ (x2^2+y2^2)*(x1^2+y1^2) ]

теперь работаем с правой стороной
|z1|*|z2|=sqrt(x1^2+y1^2)*sqrt(x2^2+y2^2)=sqrt[ (x1^2+y1^2)*(x2^2+y2^2) ]

теперь сравниваем
|z1*z2|   = sqrt[ (x2^2+y2^2)*(x1^2+y1^2) ]
|z1|*|z2| = sqrt[ (x1^2+y1^2)*(x2^2+y2^2) ]
получили одно и тоже, значит
|z1*z2| = |z1|*|z2| 

теперь проверяем то что:
|z1|   |z1|
|--| = ----
|z2|   |z2|

используем то что (z1\z2)*z2 =z1
действительно z1\z2= (по определению) z3 такой что z3*z2=z1
далее накладываем на них модуль.
|(z1\z2)*z2| = |z1|
теперь используем выше доказанное свойство :
|z1*z2| = |z1|*|z2|
значит
 |(z1\z2)*z2|=|(z1\z2)| * |z2| . подставляем это вверх

|(z1\z2)| * |z2| = |z1|
далее поскольку модуль это уже чисто обыкновенное число то мы можем с ними 
делать классические алгебраические операции , значит:
|(z1\z2)| = |z1| \ |z2|

или более красиво
|z1|   |z1|
|--| = ----
|z2|   |z2|


далее. 
переходим к геометрической интерретации комплексного числа.
значит по определению комплексное число это пара действительных чисел. тоесть
(x,y). так вот ровно тоже самое это координаты точки на прямоугольной системе координат. (x,y). координаты это тоже пара действительных чисел. а что такое координата точки более подробно?- это разложение вектора по двум другим векторам (1,0) и (0,1) тоесть

{x,y}=x*{1,0}+y*{0,1}

заметим что комплксное число ровно так и выглядит в алгераичкской записи

(x,y)=x*(1,0)+y*(0,1)

мы теперь понимаем что компкс число (x,y) можно интепретировать и как точку
на плоскости и как вектор. что же это за вектора (1,0) и (0,1) какой у них физический смысл в плане комплексного числа: (0,1) это компл число i, таким образом
компонента y комплексного числа это разложение по вектору i(который лежит на вертикальной оси). (1,0) это одиночный вектор на гор оси. 


интересно каково определение обратного числа у комплексного числа. у действительного  числа это число (как я понимаю) такое что оно получается путем
умножения на -1, то есть -x это такое число которое можно найти путем операции -1*x.
наверное для комплексного это тоже так(только мы умножаем не на -1 а на комплексное число (-1,0) ? тогда

-z=-1*z=(-1,0)*z=(-1,0)*(x,y)=(-1+i*0)(x+iy)=-x-iy+0+0=(-x,-y)
-z=(-x,-y)

значит в геометрической интерпретации число -z относительно числа z получается 
путем зеркально отражения относительно обоих осей.

числа z и (сопряженное z) друг относиельно друга отличаются тем что симметрично отражены относительно горизонтальной оси.

модуль |z| интерперетируется как длинна вектора или как расстояние от точки z до 
начала координат (что одно и тоже)

сложение и вычитание z1 и z2 имеет смысла правила сложения вычитания векторов z1 и z2

|z1-z2| приобретает смысл расстояния между двумя точками.

дальше немного прикольного:
точки z такие что |z-z0|=R0 это окружность радиуса R0 в центре z0
точки z такие что  |z-z1|=|z-z2| это серединный перпендикуляр к отрезку с концами 
в z1 и z2

забавно и дебильно то что все эти вот понты на счет комплексных чисел это все
на самом деле всего навсего старые добрые вектора и точки на плоскости но поданные
под понтовой оберткой под названием комлпексное число. да уж...

тоесть зачем было придумывать новую сущность когда она по факту является старыми
сущностями. 

уравнеение эллипса:
|z-z1|+|z-z2|=2a 
это эллипс с фокусами в z1 и z2 и большой полуосью 2a


далее.
тригонометрическая форма комплексного числа.

оступление:
реально прикольно что клмпелксное число это всего навсего точка на плоскости.(ну или вектора)
к чемутогда все эти понты. единственное что непонятно каков физический смысл 
операции умножения. если он имеет конкретный геометрический смысл то вообще незачем
было городить огород.

продолжим:
в декартовых координатах мы выражаем положение нашей точки на плоскости
через два отрезка под углом 90 градусов друг к другу.  а тепрь рассмотрим новую 
фишку полярные координаты. тут у нас есть точка. называется полюс.и есть из нее
луч или ось. так вот положение точки на плоскости определяется через расстояние 
до полюса и угла между осью. если совмещать декартовы координаты и полярные
то обычно полюс лежит в точке (0,0) декартовых координат а луч полярных координат
лежит на оси x декартовых координат. если в декартовых координатах у нас 
координатами являются x,y то в полярных кординатах у нас таковыми являются r и phi.
где r это расстояние от точки до полюса а phi это угол. 

в полярных координатах логично что |z|=r

что касается взаимосвязи декартовых координат x,y и полярных координат r,phi
то связь такая:

| x=r*cos phi
| y=r*sin phi

тогда теппрь берем определение комплксного числа тоесть что
z=(x,y)
и подставляем в него и получаем
z=(r*cos phi, r*sin phi)

по факту у нас ничего нового и страшного не прозошло. опредеение ненарушено
у нас как и прежде комплс число это пара дейтсивтельных чисел.

если мы возьмем алегеабраичечкую форму комплкс числа

z=x+iy

причем мы помним что в этой формуле x это совсем не число x а это дебильное
типографское сокращение (x,0) что совсем разные вещи. тоже самое мы помним что y
это непросто число а это типографское сокращение (y,0) , тоесть что на самом деле

z=(x,0)+i(y,0)

и подставим то что выше с r и phi то получим

z=(r*cos phi,0) + i*(r*sin phi,0)

далее используем что 
(r,0)*(cos phi,0)=(r*cos phi,0)

тогда
z=(r,0)*(cos phi,0) + i*(r,0)*(sin phi,0)

далее используем ранее выведенное что z1*z2=z2*z1 тогда 
i*(r,0)*(sin phi,0) = (r,0)*i*(sin phi,0)
подставляем

z=(r,0)*(cos phi,0) + (r,0)*i*(sin phi,0)

далее испольpуем доказанное ранее что 
z1*z2+z1*z3=z1*(z2+z3)

тогда:
z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ]

далее они используют опять вот это вот типографское дебильное сокращение 
(которое с точки зрения математики некоректно) о том что дескать давайте
обозначать (x,0) как x но будем помнить об этом в голове. 
тогда:

z(r,a)=r*[ cos(a) + i*sin(a) ]    #тригонометрическая форма компл числа
 
это так называемая тригонометрическая форма обозначения комплексного числа.( я бы конечно называл комплексный обьект но никак не комплексное число. дебильная терминология)

еще раз вспомним алгебраическую форму
z(x,y)=x+iy  # алгебраическая форма

и вспомним форму компл числа которая дается по определению:
z(x,y)=(x,y)

Но еще раз хочу сказать что также как в алгебраической форме мы помним что 
то как она записана это некое дебильное сокращение и по факту формула другая
также и в тригонометрической формуле мы должны помнить что это всего лишь дебилное
типографское сокращение а по факту формула коректая с математической точки 
зрения выглядит совсем по другому:

z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ]

это надо обязательно помнить.

далее
что еще дебильно это то что угол phi обозначают и как phi и как arg z.
дада это одно и тоже. поэтому если где то видим arg z то понимаем что это всего навсего phi и больше ничего.

Теперь рассмотрим случай когда r=1,
тогда

z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ] = (1,0)*[ (cos phi,0) + i*(sin phi,0) ] =
=  (cos phi,0) + i*(sin phi,0)
или
z=(cos phi,0) + i*(sin phi,0)
в данном случае мы получили что z зависит только от phi. 
тоесть было z(r,phi) а стало z(1,phi).окей.
теперь посмотрим а что будет если заменим phi=a+b. тоесть 
у нас станет z=z(1,a+b)

z(1,a+b)=[cos (a+b),0] + i*[sin (a+b),0]

далее используем формулы хорошо известные
cos (a + b) = cos a cos b - sin a sin b
sin (a + b) = sin a cos b + cos a sin b

подставляем:

z= (cos a*cos b,0) - (sin a*sin b,0) +i*(sin a*cos b,0) +i*(cos a*sin b,0)
рассмотрим его кусочки:
первый кусочек
(cos a*cos b,0)+i*(cos a*sin b,0)=(cos a,0)*[ (cos b,0) + i*(sin b,0) ]
второй кусочек
- (sin a*sin b,0)+i*(sin a*cos b,0)= (sin a,0)* [ -(sin b,0)+i*(cos b,0) ]
далее юзаем что -1=(-1,0)=i*i, 
подставлем:
(sin a,0)* [ -(sin b,0)+i*(cos b,0) ] = (sin a,0)* [ i*i*(sin b,0)+i*(cos b,0) ]=
=(sin a,0)*i*[ i*(sin b,0)+(cos b,0) ]
подставляем кусочки обратно:
z= (cos a,0)*[ (cos b,0) + i*(sin b,0) ] + (sin a,0)*i*[ i*(sin b,0)+(cos b,0) ]=
=[ i*(sin b,0)+(cos b,0) ]*[(cos a,0) + (sin a,0)*i] 

или в чуть более красивом виде
z=[ (cos b,0) + i*(sin b,0)+ ]*[(cos a,0) + i*(sin a,0)]

вспоминаем что наш z это z(1,a+b)
тогда
z(1,a+b)=[ (cos b,0) + i*(sin b,0) ]*[(cos a,0) + i*(sin a,0)]

вспоминаем тригонтметрическую форму записи
z(r,phi)=(r*cos phi,0) + i*(r*sin phi,0)
берем r=1 подставляем
z(1,phi)=(cos phi,0) + i*(sin phi,0)

и теперь используя эту формулу мы можем преобразовать формулу z(1,a+b)
z(1,a+b)=[ z(1,b) ]*[ z(1,a) ]

интересное свойство! тока надо помнить что оно верно только для случая r=1.
при других r все будет подругому.

далее они выводят что 
          z(1,a)
z(1,a-b)=-------
          z(1,b)













далее я рассмаотрю очень интересуню тему: выразить тригонметрическую форму
через алгебраическую форму.
задача. у нас есть комлексное число 
в алгебраоичской форме

z=x+iy

нужно найти r и phi (через x и y) которые нам позволят записать тоже 
самое число в тригонометрической форме:

z=r(cos phi + i*sin phi)

итак дано x,y нужно найти r,phi.

имеем систему:

|x=r*cos phi
|y=r*sin phi

ясно что:

r=sqrt(x^2+y^2)

итак r мы нашли. 

теперь ищем phi.
ясно что:

|cos phi=x/r = x/sqrt(x^2+y^2)
|sin phi=y/r = y/sqrt(x^2+y^2)


эта система уравнний однозначно определяет phi.  действтельно. взяли отмеряли на 
гор оси известное нам значение x/sqrt(x^2+y^2) это косинус. 
данному косинусу соотвествуют два угла. проводим из точки на гор оси(которая равна косинусу) верт черту до пересечения с окружностью. получаем две точки
пересечения с окружностью над гор осью и под гор осью. 
мы получили два угла для каждого из которых косинус угла равен нашему косинусу. тоесть у нас два угла 
кандидата. чтобы убрать лишнего кандидата надо заюзать синус. у нас  есть известный синус y/sqrt(x^2+y^2) . если  знак синуса с плюсом 
то наша искомая точка над осью X если синус со знаком минус то наша искомая точка
под осью X. когда нашли точку на окружности то мы нашли и угол. нашли его однозначно.

правда их углов все же  будет бесконечное множетсво ибо
если наш надйенный угол =phi0 то решением системы будет любой угол такой что: 
phi=phi0+2*pi*k, k=0,1,2...

насколько я понял какойто красивой формулы решения верхней
системы нет. мы находим угол как арккосинус . получаем два угла. далее
отрасываем один ориентируясь на знак синуса. я так понимаю.

кстати напоминаю что тригонометрическая форма она вводится на основе полярных
координат. а в них точка z=0+i*0 исключена ибо в этой точке неопределен угол.
тоесть это когда r=0. замечаю что исключается только случай когда оба и x и y одновмременно равны нулю. по отдельности они могут спокойно быть равны нулю.

исходя из вышесказанного тригонометрическая форма числа z будет иметь вид:
z=sqrt(x^2+y^2)*(cos (phi)+ i*sin (phi))

где phi равен любому из углов:
phi=phi0+2*pi*k, k=0,1,2...

к сожалению phi0 как я понял какйото красивой формулой невыразить.
поэтому задача для конкретных x,y имеет конкретный решенный вид а вот в общем
виде она неимеет красивого решения. я так понял.

ну точнее они обычно пишут так: phi=argz(x+iy)
тогда конечный вид тринонометрической формы через алгебраическую:

z=sqrt(x^2+y^2)*[ cos (argz(x+i*y)) + i*sin (argz(x+i*y)) ]

ну и таким же макаром показательная форма через алгебраическую:

z=sqrt(x^2+y^2) * e^(i*argz(x+i*y))

Единсвтенное что остается непонятным:
та система что наверху:

|cos phi=x/r = x/sqrt(x^2+y^2)
|sin phi=y/r = y/sqrt(x^2+y^2)
| r<>0 (тоесть x и y одновременн не могут быть равный нулю)

послденнее усолвие появляется из за полярных координат в которые при r=0 неопределен
угол.

берем строчку с синусом и делим обе части на косинус. получаем:

|cos phi=x/r = x/sqrt(x^2+y^2)
|tan phi=y/r = y/x, x<>0
| r<>0 (тоесть x и y одновременн не могут быть равный нулю)

мы получили почти эквивалентную систему уравнений за исключением случая когда
x=0. потому что в нашей исходной системе x может быть равен нулю без проблем а в нашей новой нет. ну пока необращаем а на это внимание.  замечу что x<>0 и r<>0 это разные условия.

далее можно решать исходную систему урвоенения. а можно решать поученную.
можно найти угол из тангенса но мы получим лишние корни. потом мы подставоляем
полученные корни в уравнение с косинусом и выкидываем лишние.
для известного тангенса на окружности будет всегда две точки с одинаковым тангенсом.
проверка на косинусе позволит исключить лищнюю точку. ( тангенс в этом плане неункиален. синус и косинус тоже каждый из низ при заданном значении имеет две точки
на окружности. но только одна из них удолвтевтворяет обоим уравненеиям. поэтому в итоге точка находится однозначно.)

вместо тангенса можно заюзать котангенс. но это проблемы нерешает. он тоже имеет
две точки на окружности при задннром значении.поэтому его корни тоже нужно проверять
на втором уравеннии системы.

пример:
z=-1+i (x=-1, y=1)

решим через синус косинус

|-1=sqrt2*cos phi, phi=3*pi/4+2*pi*k или phi=5*pi/4+2*pi*k
| 1=sqrt2*sin phi, phi=pi/4+2*pi*n или phi=3*pi/4+2*pi*n

отсюда находим общий phi удовлетвоярющий обоим уровеннеияем и это
phi=3*pi/4+2*pi*k

решаем через вторую систему:
|-1=sqrt2*cos phi, phi=3*pi/4+2*pi*k или phi=5*pi/4+2*pi*k
|-1=tan phi, phi=3*pi/4+pi*n

находим общий корень
phi=3*pi/4+2*pi*k


конец темы: "выразить тригонметрическую форму
через алгебраическую форму."













далее
очень крутая тема.
формула эйлера.
дело в том что ее строгое доказательство хрен найдешь.
но нашлось. ура.
во первых что такое e^z. да дейтсивтельно что это за хрень. ведь по сути
это запись  вида 2.7^z . так вот совершенно непонятно какой смысл имеет 
тот случай когда степень у нас комплексное число. действиетельно какой смысл вот 
этой записи 2.7^(2,1) - что это за хрень? так вот нашел то что вводят по определению что 
            z^n
e^z=summa ------- при n=0..infinity
             n!

 если то что слева от равно хрен знает что значит
 то то что справа имеет абсолютно четкое значение.
 что такое n! - абсолютно понятно.
 что такое z^n тоже понятно при n=натуральные числа. тоесть

 z^1=z
 Z^2=z*z  # мы умеем это вычислять
 z^3=z*z*z # никаких проблем при вычислении

кстати вопрос что такое z^0.... наверно по определению это 1=(1,0)?

 возьмем для примера z=(1,0) и распишем что такое 

 e^(1,0)=[ 1 + (1,0) + (1,0)*(1,0)/2 + (1,0)*(1,0)*(1,0)/6 + ... ]

 теперь заметим что (1,0)*(1,0)*.... (1,0)= всегда (1,0) тогда

 e^(1,0)=[ (1,0) + (1,0) + (1,0)/2 + (1,0)/6 +.... (1,0)/n!] =
 = (1,0)* summa [2+1/n!] при n=1...infinity = (summa [2+1/n!],0) при n=1...infinity
 или
 e^(1,0)= (summa [2+1/n!],0) +i*0, при n=1...infinity

насколько я понимаю этот ряд 
summa [2+1/n!], при n=1...infinit  он равен = e^1
итого

e^(1,0)=(e^1,0)

 мы рассмотрели случай когда z=(1,0)

далее рассматривается случай когда z=0+i*a=(0,a), где a=[0:2pi]
тогда

              z^n
e^(0,a)=summa ------- при n=0..infinity
               n!


z^n     (0,a)^n
---- = -------- = [(n!)^-1,0]*[ (0,a)^n ]
n!        n!


рассмотрим по кускам.
(0,a)^n=?

n=0| (0,a)^0=(0+i*1)^0=i*1^0=i=(0,1)
n=1| (0,a)^1=(0,a)

форула умножения : z1*z2=(x1*x2-y1*y2, x1*y2+x2*y1)

n=2| (0,a)^2=(0,a)*(0,a)=(0-a*a, 0)= (-a^2, 0)
n=2| (0,a)^2=(-a^2, 0)

n=3| (0,a)^3=(0,a)*(0,a)*(0,a)= (-a^2, 0)*(0,a)= (0, -a^2*a+0) = (0,-a^3)
n=3| (0,a)^3=(0,-a^3)
интересно....
продолжаем дальше смотреть
n=4| (0,a)^4=(0,-a^3)*(0,a)=(0+a^3*a, 0)=(a^4,0)
n=4| (0,a)^4=(a^4,0)

n=5| (0,a)^5=(a^4,0)*(0,a)=(0, a^4*a)=(0,a^5)
n=5| (0,a)^5=(0,a^5)

выписыаваю:
n=0| (0,1)

n=1| (0, a)
n=2| (-a^2, 0)
n=3| (0, -a^3)
n=4| (a^4, 0)
n=5| (0, a^5)

перегруппирую:
n=0| (0,1)


n=1| (0, a)
n=3| (0, -a^3)
n=5| (0, a^5)


n=2| (-a^2, 0)
n=4| (a^4, 0)

тогда для нечетных n=1,3,5, .. infinity имеем:

сразу подменяем n=1+2k, где k=0,1,2...)

           (0,a)       (0,-a^3)    (0,a^5)        ( 0, (-1)^(k)*a^(1+2k) )
summa(n)= -------  +  ---------- + -----   +     ----------------------- + ... 
             1!          3!          5!               (1+2k)!                


 факториал можно внести внутрь, потому что
(p,0)*(0,y)=(0-0, p*y)=(0,py)
(p,0)*(y,0)=(py-0, 0)=(py,0)
также можно заюзать запись через i
тогда собирая все в кучу:

           a^(2k+1)
s(1+2k)=  i* ---------- * (-1)^k     , k=0,1,2...inf
            (2k+1)!

так вот внимательно посмотрев на сумму мы вдруг неожиданно
понимаем что это ничто иное как ряд Маклорена для функции sin a.(ряд маклорена это чатный случай ряда тейлора если что).
таким образом сумма всех членов при нечетных n=1+2k , где k=0,1,3 равна
summa (s(1+2k))= i*sin(a)

если еще помудить с четными членами то поймем что сумма всех четных членов
сходится к  
summa(s(2k)) = cos(a)

ну а полная сумма всех членов равна

cos(a)+i*sin(a)

тогда получаем формулу Эйлера:

в алгебраическом виде:
e^(ia)=cos(a)+i*sin(a)

в более коректном виде
e^(ia)=(cos a, sin a)

тут важно сказать что a это вооще говоря любое число потому что z=0+i*a
но если a любое число то тогда под косинусом и синусом надо его преобразовыать
в радианы. а если мы нехотим мудежом заниматься то тогда надо сразу a преобразоывать
в радианы чтобы внутри косинуса и синуса непришлось этого делать. но еще раз 
это необзятльено. это лишь удобняшка. если мы берем любое a то просто надо понимать
что внутри синуса и косинуса нам надо будет это произволтное a преобразовать
в радианы иначе синус и косинус будуь неправльно высчитаны.

тут важно понять очень важную вещь что слева и справа стоят совершенно разные
функции. это очень важно понять потому то возникает чуство как бутто то что справа
оно как бы является определением того что слева. а это еще раз абсолютно две разные
функции просто так получилось что они оказалось дают один и тот же результат.
слева это степенной ряд а справа ну чтото другое.

и теперь вот еще проанализируем, берем формулу эйлера
e^(ia)=(cos a, sin a)

что интересно в этой формуле. я бы ее переписал в другом виде:
z2=f(z1)=(cos a, sin a)

вспоминаем тригонометрический вид компл числа:
z(r,b)=r*[ cos(b) + i*sin(b) ]

сравниваем правую часть формулы эейлера и тригонометрический вид компл числа
(cos a, sin a)
[r*cos(b), r*sin(b) ]

откуда я делаю вывод что на компл плоскости все числа принадлежащие (cos a, sin a)
это окружность единичного радиуса! Тоесть функция f(z) которая равна e^(ia) все что она делает она берет аргумент ia и отображает его в точку на единичной окружности единичного радиуса. еще раз то что функция f(ia)=e^(ia) отображает аргумент в 
окружность единичного радиуса это прикол. еще раз графически это выглядит так.
мы берем точку на оси Y(мнимая ось) и начинаем по ней таскать точку (это аргумент он сугубо мнимый потому что z=0+i*y) и как результат происходит отображение на 
некоторую компл плоскость в окружность единичного радиуса! наша функция e^ia отображает аргумент в окружность единичного радиуса. и это прикол.
жестокий прикол еще и втом что навскидку когда виддишь формулу эйлера то интутивно
думаешь(совершенно ошибочно) что якобы (cos a+i*sin a) это якобы определение что
такое e^ia. а это неверно. e^ia это степенной ряд. а то что он равен  (cos a+i*sin a) это просто совпадение! и больше ничего. (cos a+i*sin a) не является определением
e^ia.

что еще итересно:
вот смоирим на форулу эейлера:
e^(ia)=(cos a, sin a)

совершенно понятно что (cos a, sin a) это запись компелксного числа  в тригонометрическом виде когда r=1. тоесть  (cos a, sin a)=q(1,a)
тоесть
e^(ia)=q(1,a)
почему я и говорю что e^*(ia) отображает аргумент в компл число которое лежит
на окружности одиночного радиуса!

ну и вот как то хочется связать аргумент и результат ну как то еще более тесно.
если a очень мало. то тогда можно использовать разложение cos a и sin a в нуле.
тогда

cos a ~ 1-(a^2)/2
sin a ~ a-(a^3)/6
тогда

при малых a->0 :
               (a^2)       a-(a^3)
e^(ia) ~  1 - ------- + i*----------
                 2            6


вобщем это интересно что степенной ряд который зовется функция эйлера отображает
аргумент в окружность единичного радиуса.

наскольк я понимаю если рисовать график этого дела то выглядит это дело так:
если у нас есть на бумаге горизонтальная ось X на которой мы будем откладывать наш аргумент ia , и у нас есть вертикльная ось Y и есть ось Z которая нас протыкает
из листа бумаги то графиком e^(ia) будет спираль! мы двигаемся по оси X а при этом 
в плоскости YZ у нас окружность. все это в сумме дает спираль. спираль распостроняется вдоль оси X а в плоскости YZ мы видим окружность!
удвиитено!




 также заметим что что такое e^z по своему смыслу - это функция комплексного переменного . тоесть когда у нас есть закон который берет комплексное число как аргумент и ставим ему в соотвествие другое компексное число.
 тоесть к примеру

 e^(1,0) = (условно говоря) (6,7)

 тоесть комплк числу (1,0) поставлено всоотвствие другое комплксное число (6,7)
 если это пробовать представить через декартовы координаты то получается что 
 точке на плоскости ставится в соотвествие точка на другой плоскости 
 тоесть типа такого 

 (a,b)=f(c,d)

 ну что тут сказать. обычно график трехмерной фигуры это функция вида

 (z)=f(x,y)

 ну а здесь (a,b)=f(c,d) чуть сложнее. ибо мы имеем четырхмерное просранство а не привычное
 трехмерное. вот и все. если b всегда = 0 то функция комлпекснго переменного
 будет выглядеть как трехмерная фигура.
а так посути что такое график или трехмерная фигура или чтото посложнее - у нас есть одна или несколько осей, каждая ось это переменная или множество. мы берем
точку на каждой из осей и тогда на последней оси по некоторму правилу тоже 
выбирается точка. вот и все.
тоесть к примеру. имеем график двумерный y=f(x) это всего навсего у нас две оси.
мы берем точку на первой оси и по некоторому закону на второй оси у нее есть пара. 
вот и все. вот и весь смысл графика двумерного.

таким макаром e^z это всего навсего вот такая хрень

z1=f(z), где f(z)=e^z
вот и все. 
а e^z поскольку это некая непонятная хрень всего навсего это ряд. а что такое 
ряд вот такого вида

            z^n
e^z=summa ------- при n=0..infinity
             n!

 члены этого ряда имеет прекрасно понятное значение даже в случае когда переменная
 комплексная.


как уже вывел выше в частном случае когда z=0+i*a
данный ряд сходится к 

e^(i*a)=cos a+i*sin a 

или
e^(i*a)=(cos a, sin a)

Что примечательно что формула эйлера верно только и только водном супечастном
случае когда x=0. а не просто вобщем случае z=x+iy.

опять же очень важно пнимать что там где написано e^z там надо мысленно рисовать
степенной ряд вместо вот этой хрени  с буквой e.

Далее они в книжках пишут что :
так как

e^(ia)=cos a+i*sin a
то
e^(i*(-a))=cos a-i*sin a

складываем их:
e^(ia) + e^(i*(-a)) = cos a + i*sin a + cos a-i*sin a = 2*cos(a)
откуда получаем:
cos a = [ e^ia + e^(-ia) ] * 0.5

отнимаем их:
e^(ia) - e^(i*(-a)) = cos a + i*sin a - cos a + i*sin a = 2*i*sin(a)
получаем:
         [ e^ia - e^(-ia) ]
sin a = --------------------
                 2i


итого получили:
cos a = [ e^ia + e^(-ia) ] * 0.5


         [ e^ia - e^(-ia) ]
sin a = --------------------
                 2i


если честно я енпонимаю почему из за этих формул так ссут кипятком.
невижу никакого практического смысла потом что функции эейлера это ряды. 
так что какой от этого практический толк непонятно.


Далее берем тригонометричкую форму и смооим что будет при
умножении:
z1*z2=[(r1*cos a,0) + i*(r1*sin a,0)] * [(r2*cos b,0) + i*(r2*sin b,0)]=
=r1*r2*cos(a)*cos(b) + i*r1*r2*cos(a)*sin(b) + i*r1*r2*sin(a)*cos(b) - r1*r2*sin(a)*sin(b)=
=r1*r2*[cos(a)*cos(b)-sin(a)*sin(b)] + i*r1*r2*[cos(a)*sin(b) + sin(a)*cos(b)]=
=r1*r2*cos(a+b)+i*r1*r2*sin(a+b)=r1*r2*[cos(a+b)+i*sin(a+b)]

итого:
z1(r1,a)*z2(r2,b)=r1*r2*[cos(a+b)+i*sin(a+b)]

значит:
z(r,a)^2=r^2*[cos(2a)+i*sin(2a)]

если мы хотим вычислить z^3 то
это равно z^2*z тоесть

z^3=z^2*z=r^2*[cos(2a)+i*sin(2a)]*r*[cos(a)+i*sin(a)]
если мы заменим b=2a и r^2=r2 то мы получим
r2*[cos(b)+i*sin(b)]*r*[cos(a)+i*sin(a)]
и отсюда видно что что получаем формуулу аналогичную той что выше 
значит:
r2*[cos(b)+i*sin(b)]*r*[cos(a)+i*sin(a)] = r*r2*[cos(a+b)+i*sin(a+b)] =
= r^3*[cos(3a)+i*sin(3a)]

отсюда уже можно получить важную формулу, что 
для натуральных n иммеем:
z(r,a)^n=r^n*[cos(na)+i*sin(na)]

очень важно что эта формула получена абсолютно шататными способами
бещ применения формулы эйлера. эйлер тут вообще никаким боком ненужен!

и из форомулы при r=1 получаем частный случай под названием формула муавра:
z(1,a)^n = cos(na) + i*sin(na)

еще раз подчеркну что формулу муавара можно получить из общих соображений
без участия фооромулы эйлера

Далее еще прикол. 
новая форма записи компл числа. показательна форма.
берем тригонометричекую форму

z=r*cos(a)+i*r*sin(a)=r(cos(a)+i*sin(a))
далее вспоминаем формулу эйелера:
e^ia=cos(a)+i*sin(a)
подставляем ее выше получаем:
z=r(e^ia)=r*e^(ia)
z=r*e^(ia)
эта форма называется показательная форма.

кстати я еще допер чем примечательна экспонента эйлера.

e^ia=cos(a)+i*sin(a)

в качестве аргумента берется отрезок кратный длинне вектора i тоесть кратный
единице и в ходе отображения он отображается в такой вектор на плоскости который
повернут относительно начала координат ровно на такойже угол в радианах.тоесть прикольно что длинна отрезка как бы транфсормируется в величину угла. это и прикольно. тоесть пример.
берем z=0+i*5, значит сточки зрения числа z он имеет длинну 5 единиц.
и этот вектор отображается в вектор единичной длинны в новой комплексной плоскости
и повернут он в этой плоскости относительно начала координат на угол в 5 радиан.
это ли не чудо. длинна отрезка изначального вектора z=0+i*a отображается в угол поворота единичного вектора в новой комплексной плоскости. если мы возьмем
z=0+i*pi/2 по длинне то этот отрезок длинной pi\2 (примерно 1.7) будет отображен
в вектор единичной длинны и повернутый на угол pi\2 то есть на 90 градусов.
прикольно. еще как это можно представить. у нас есть горизонтальный ползунок
и мы по нему двигаем точку и у нас есть экран на котором нарисована единичная окружность и по мере движения поозунка у нас на экране по окружности двигается точка. угол поворота точки по окружности прямо пропорционален величине насколько 
мы перевдинули ползунок. удивительно.

показательная форма она полезна для: Показательная форма удобна для таких операций, как умножение, деление, возведение в степень и извлечение корня

Тут я нашел лекцию в которой обььясняется откуда взялся вот этот ряд который
по определению выражает экспоненту коплексную. оказывается подумали так что
вещественная экспонента обладает двумя свойствами которые нам важны первое
это f(0)=1 и второй что f'(x)=f(x). далее сказали давайте те как возьмем ряд

f(z)=summa(a(n)*z^n)  n=0,1,2,

, далее они пишут что там где ряд сходится можно взять 
произвудную

 f'(z)=summa( n*a(n)*z^(n-1) ).   n=1,2,3 (почему не от нуля непонял)

далее неочень понятно но они выводят из этого то что a(0)=1
и то что a(n-1)=n*a(n)
откуда они выводят что 
e^z=summa ( z^n/n!)

кстати там юзалось что 0^0=1 . я посмотреть в вики и типа ... вопрос  открыт
чему это равно но в случае степеных рядов вроде да принимают что такк.

далее:
задача: вывести формулу для e^(x+iy)=?
вобе=щем есть два доказателтства. одно через производные от e^z но я такое 
не рассматривают иоб тогда надо для начала смотреть что такое производная
для колпексной фнукции. есть другое пболее колхозное докааазательство
берут и перемножают две скобки

e^z1 * e^z2=(summa (z1^n\n!)) * summa (z2^k\k!) =

это две большие скобки .. мы их пермножаем друг на друга а потом группируем 
то что получилось и якобы становится видно что можно так сгрупировать что 
мы получаем

= 1 + (z1+z2) + (z1+z2)^2/2! + (z1+z2)^3/3! + ... =
итаким макаром мы видим что это вылиывается в формулу

= summa ( (z1+z2)^n/n!) а это уже очевидно e^(z1+z2)

таким макаром выводим формулу

e^(z1+z2) = e^z1 * e^z2

ну отсюда получаем

e^(x+iy) = e^x * e*iy = e^x(cos y + i*sin y)
если мы сравним то что справа с тригонометрической формой клмп числа
z=r(cos y + i*sin y)
то мы увидим что то число которое справа имеет длинну r=e^x а уголо поворота y.
значит мы получили что если у нас исходное число z=x+iy то оно отображается 
функцией e^z в вектор у которого длинна равна x а угол поворота равен y
из чего я делаю вывод что увеличение x в аргументе приводит к тому что полученная точка имеет все большую длиннну а увеличение y в аргументе приводит к повороту вектора(вектор , точка  смысл один). 

далее. 
ранее мы получили что

cos x = (e^ix + e^-ix)*0.5

где x это вещественное число. аналогичное для sin x.
так вот незнаю почему нестал разбираться но таким точно макаром вводят и 
комплексные функции cos z и sin z

cos z = (e^iz + e^-iz)*0.5 и это равно  = cos x * ch y - i* sin x * sh y

где sh y = sinh y (гиперболический синус)
ch y = cosh y (гиперболический косинус)

чему они равны:
sh y = (e^y - e^-y) * 0.5
ch y = (e^y + e^-y) * 0.5

ксати они получают что
1\i=-i


далее.
еще раз о показательной форме числа:
берем тригонмтеричкескую форму
z=r(cos a + i*sin a)

из формулы эйлера имеем что e^ia=cos a + i*sina
подствляем
z(r,a)=r*e^ia

эта форма дает удобную штуку как умножать и как делить z1 на z2

z1*z2=r1*e^ia * r2*e^ib = (r1*r2)*e^(i[a+b])

z1/z2=(r1/r2)*e^(i[a-b])

задача:
повернули систему координат на угол a , вопрос какая связь между старыми 
и новыми координатами.

вот у нас есть вектор в старых координатах его вид имеет вид
z1=r*e^ib

когда мы повернули координаты то в новых координатах угол вектора уменьшился 
на угол a значит в новых кооддинатах его вид имеет вид

z2=r*e^i(b-a)

это то как изменились координаты в полярных координатах.
а мы хотим как изменились в декартовых, тогда

 в старых коодиинатах
|x1=r*cos b
|y1=r*sin b


в новых коодинатах
|x2=r*cos(b-a)
|y2=r*sin(b-a)


из первого выражаем 
|cos b=x1\r
|sin b=y1\r

во втором исползуем формулы
cos (a - b) = cos a cos b + sin a sin b
sin (a - b) = sin a cos b - cos a sin b
подствляем во второе

|x2=r*cos(b-a) = r*(cos a cos b + sin a sin b)
|y2=r*sin(b-a) = r*(sin a cos b - cos a sin b)

теперь сюда еще вот это подставляем
|cos b=x1\r
|sin b=y1\r


|x2=r*cos(b-a) = r*(cos a * x1\r + sin a * y1\r) = x1*cos a + y1*sin a
|y2=r*sin(b-a) = r*(sin a * x1\r - cos a * y1\r) = x1*sin a - y1*cos a

итого
|x2=x1*cos a + y1*sin a
|y2=x1*sin a - y1*cos a


итак тема тфкп закончена.
переходим к статье по сигналам: https://www.dsprelated.com/showarticle/192.php

рассматриваем квадратурные сигналы , еще их зовут complex signals.

по факту квадратурными сигналами называют сигналы: 
e^ia
e^-ia

где a=a(t)


если a=(2*pi*f0)*t
e^ia=cos a + i*sin a
и конечно же одчеивдно что
Re (e^ia)=cos a
Im (e^ia)=sin a

если строить график в плоскости где одна ось это "a" а вторая ось это Re (e^ia)
то это будет график косинуса cos a
если сроить график по где гор ось это "a" а верт ось это Im(e^ia) то это будет 
график синуса sin a

тоесть если строить график a от Re (e^ia) то есть будет чисто график cos(x)
тоесть по оси x  у нас чисто x а по оси y будет cos(x)

то же самое для Im(e^ia)

а если мы вводим что "a" это непросто a  а функция времени 
тоесть a=a(t)=(2*pi*f0)*t и еслимы будем по оси x откладывать "t"
тогда у нас будет график не просто cos x а будет уже косинус вида cos kx. тоесть
будем график t, cos[(2*pi*f0)*t]


так..  а если мы рассмотрим функцию z= e^ia + e^(-ia)
тогда будет вот что

e^ia + e^(-ia) = cos a + i*sin a + cos (-a) + i*sin (-a) =
= 2*cos(a) + i*sin a - i*sin (-a) = 2*cos a

итого
e^ia + e^(-ia) = 2*cos a = 2*cos a + i*0 = (2*cos a)e^(i*0)
e^ia + e^(-ia) = 2*cos a + i*0

получается что функция z= e^ia + e^(-ia) она берет аргумент 0+i*a(отрезок на мнимой оси)
 и отображает его в новую комплексную плоскость в отрезок на вещественной оси.
тоесть если функция e^ia она отображает отрезок в точку лежащую на одинарной
окружности то наша новая функция она отображает тот же аргумент но в другое - в точку лежащую на отрезке  который лежит на вешественной оси исключетельно на вещественной оси.
если рисовать график когда будем по гор оси откладывать "a" а на верт оси откладывать e^ia + e^(-ia) то это будет график 2*cos(a). еще раз обращу внимание почему мы можем откладывать функцию e^ia + e^(-ia) всего лишь на одной оси (ведь результат этой функции это комплексное число у которого всегда две координаты тоесть комлпесаня функция это всегда плоскость комплпксаная плоськость то есть там две оси но никак не одна. так вот в нашем конкретном случае мы выяснили что результатом данной функции всегда будет число вида x+i*0 поэтмоу в этом конкретном случае нам хватит одной оси.). итак график e^ia + e^(-ia) от "a" это график 2*cos x от x.
а если у нас a=f(t) и мы хотми по гор оси откладывать время t а не a то это будет график по гор оси будет "t"  а на верт оси будет откладывать 2*cos(a[t])

далее. 
так вот в статье написано что 
если мы еще раз посмотрим на функцию

e^ia + e^(-ia) = 2*cos a + i*0

то мы конечно заметим то что результат это сугубо вещественное число. с нулевой 
комплексной частью. и вот статья говорит что : Implementations of modern-day digital communications systems are based on this property!
пока непонятно что такого крутого в этом. но будет дальше смотреть.

далее еще вспомним другую формулу. 
         [ e^ia - e^(-ia) ]
sin a = -------------------- 
                 2i

тогда:
e^ia - e^(-ia) = i* (2*sin a) 
                 

тоесть компл число 0+ia наша функция маппит в мнимую ось и на ней мы откладываем
отрезок длинной 2*sin a

итак еще раз соберем две наши функции рядышком:

e^ia + e^(-ia) = 2*cos a + i*0
e^ia - e^(-ia) = i* (2*sin a) + 0

итак видно что сумма наших экспонент мапиится в точку исключительно на вещественной оси ( длинаа отрезка 2*cos a )
а разница экспонент маппится в точку исключительно на вещественной оси ( длинна отрезка 2*sin a ).

дальше они пишут мол во классно теперь знаем как наш  косинус от обычного действииельного числа раскладывается в комплексный вид в функцию на комплексной
плокости и даже более того в комплексные экспоненты. (че класного пока непонятно).
тоесть мы сразу теперь знаем что:
cos a = [ e^ia + e^(-ia) ]*0.5
бам! и наш косинус перелез комплексную плоскость

далее.
замечу про связь w и f0:
cos a = тут все понятно. аргумент "a" в радианах.
далее заменяем a=f(t)=w*t
cos wt = посольку аргумент коинуса  в радианах то если a=f(t)= wt
в этой формуле w- это частота в радианах в секунду.а если мы хотим перейти к
к классичсесекой частоте Гц=1\с то  
w=2*pi*f0, в самом деле. по определению периодической функции y(t+T)=y(t).
берем t=0 и T=1\f0 тогда

cos (0+T) = cos (2*pi*f0*(0+1/f0))=cos (2*pi*f0*(1/f0) = cos (2*pi)=1
cos (0)= cos (2*pi*f0*0)=cos (0) =1
1=1 
значит все верно значит доказали что 
w=2*pi*f0 в радианах в сек
f0 в 1\с=Гц

так я о чем. о том что аргумент косинуса можно задвать двумя путями 
через круговую частоту или через герцовую частоту:
cos (wt)
cos (2*pi*f0*t)
конечно w тоже может быть функцией от t. но мы такое нерассматриваем. 
считаем что w постоянная от времени.

далее. 
заметим одну очень инересную вещь.
вот у нас есть сигнал от времени 
y=cos(kt)
мы строим граифк. по гор оси кладем t по верт оси кладем cos(kt).
если у нас разные k то график t,y(t) будем разный. он будет то сжиматься 
то разжиматься вдоль горизонтальной оси. 
действительно, графики от t для функций

y=cos(k1*t)
y=cos(k2*t)
y=cos(k3*t)

они будут все разные. это первый момент.
второй момент  что это графики сигнала (функции) от времени.
поскольку k1,k2,k3 задают частоту сигнала то получается что косинус при 
разных часототах на графике от времени t все время будет разный. однако! и тут
самое главное если мы для первого графика y=cos(k1*t) начнем по оси X откладывать
не время а величину k1*t то мы получим график классического cos x графика.
тоже самое и для y=cos(k2*t) и y=cos(k3*t) если мы будем откладывать на гор оси 
не время а величины k2*t и k3*t то все три графика будут ОДИНАКОВЫЕ! абослютно
одинаковые три графика. по горизонтальной оси мы будем откладыывать так называемую 
фазу а не время как мы делали до этого. фаза это полный аргумент стоящий под косинусом. тоесть y(a)=cos (a), где a это полный аргумент косинуса. этот полный
аргумент зовется фаза, такое вот заумное слово, на самом деле означает всего навсего полный аргумент косинуса и всегото. для примера y(t)=cos(k*t)
в этом случае аргумент "t" но как видно этот аргумент состалвяет лишь часть полного
аргумента косинуса поэтому t  это не фаза. фаза косинуса в данном случае это k*t.
таким образом когда мы слышим слово фаза косинуса равна 0.5 это означает что 
мы знаем полный аргумент косинуса то есть мы можем его сразу подставить 
и узнать чему же косинус равен при этой фазе тоесть cos(0.5). таким образом
дебильое слово фаза наконец стало понятно что это такое - это полный аргумент 
косинуса. если мы знаем фазу то мы мгновенно можем посчитать чему равен косинус
y=cos(фаза). какая связь между фазой и временем. в общем ответ такой что связь 
какая угодно. ее может небыть вообще. в общем случае связь такая 

фаза=фаза(t)  

главное что надо понять что фаза это полный аргумент под косинусом. тоесть
cos(фаза). если нам сказали что фаза=0.6 то это значит что мы знаем все что необходимо чтобы теперь выяснить чему равен косинус  а именно косинус=cos(0.6)

если мы всоппомним что такое косинус по определению  - что это величина катета для точки на окружности единичного радиуса. как мы там пытаемся вычислить этот катет.
мы говорим что 

катет=1*f(x)

где 1 это длинна гипотенузы.
f(x) это некая функция от угла треугольника. таким образом x это угол треугольника
заданный в радианах. так вот эту функцию называют косинус или f(x)=cos(x)
таким образом x это угол! и также как мы уже знаем это фаза. таким образом 
физ смысл фазы это угол , заданный в радианах. понятие фазы имеет смысл только 
когда мы говорим про косинусы(синусы тангенсы итп). полный аргумент какой либо 
другой функции y=f(x)=x^3 абсолютно незовется никакой фазой.

итак мы поняли что фаза это просто синоним для слова "полный аргумент для функции косинус". его физический смысл это угол в радианах. если мы знаем фазу (например фаза =0.1) то мы знаем полный аргумент и значит можем вычислить значение функции
при фазе=0.1 косинус=cos(0.1)
так как фаза это угол то как видно в нем нет никакого времени. откуда же оно берется. если у нас точка ездит по окружности в соовествиии с каким то законом
от времени тоесть x=x(t) то тогда зная время t0 и зная закон x(t) мы можем
вычислить чему равен угол прям щас а именно x(t0). вот так появляется время.
а когда вычислили угол x(t0) то мы вычисили фазу то мы вычислили полный аргумент 
косинуса то мы можем узгнать чему косинус равен cos(x[t0])
закон движения точки по окружноси от времени может быть самый любой нпример
x(t)=e^(35t). тогда угол в момент времени t=10 будет равен x=e^(35*10).
тогда косинус будет равен cos(e^(35*10))
фаза=e^(35*10)

Если мы строим график косинуса не от времени а от угла (то есть от фазы) то есть мы 
откладываем по оси X не время а фазу то никакого времени на графике нет и график 
будет выглядеть всегда ровно одинаково как cos(x). неважно как меняется угол от времени , как бы он неменялся на все равно что угол=0.3 в момент времени t0=10 или в момент времени t0=20. когда по оси x откладываем угол(фазу) cos(угол) всегда всегда всегда один и тот же. и плевать нам на время. 

итак что такое фаза. это угол. еще это полный аргумент для функции косинус.
чем она хороша. для заданной фазы косинус всегда один и тотже! если мы строим
график косинуса от фазы то этот график всегда один и тотже и на нем нет времени. никак. фаза еще хороша там что зная фазу мы сразу вычисляем чему равен косинус 
для этой фазы.

к сожалению в придурковатой школе косинус начинают обьяснять с направления жопы.
тоесть с обратной стороны. берут некий физ процесс типа качающийся маятник. 
далее снимают координату которая меняется от времени. тоесть момент в том что
наш сигнал он изначально завиисит от времени но никак не от фазы. например

x=cos(10*t)

далее рисуют график x(t) , у ученика возникает четкая привязка косинуса к времени.
тоесть человек думает что косинус происходит от времени. и дальше эти придурки 
пытаются впихнуть перевести разговор на фазу. и тут возникает чудовищное непониние
что это за хуета под названием фаза и нахуя она нужна ? если бы эти дебилы 
сказали давайте мы будем немаятник ебаный снимать а точку которая движется по окружности у которой угол поворота меняется по закону phi=10*t
далее мол меряем чему равен косинус при движении этой точки. получаем

x=cos(10*t)

а далее бы эти дебилы бы сказали что давайте нахер теперт забудем провремя. а поступим вот как. мы берем время t0=0, смотрим чему равен угол и чему равен косинус. и далее начинаем строить хитрй график. на гор оси откладываем угол 
на верт косинус. для t0=0  угол=10*t=0 а косинус = cos (0)=1
итак на оси x откладыаем 0 а на оси y откладываем 1 и ставим точку на графике.
теперь берем t0=1, тогда угол=10*1=10, тогда косинус=cos(10)=0.4
ставим на оси x угол 10 и на оси y ставим 0.4 и рисусем еще одну точку. и соединяем сосдение точки.  и вот аллилуйя мы получли гоафик косинуса  в завимости от угла.
и это блядь и называется график косинуса от угла то есть от фазы. и вот что такое 
фаза и какой ее смысл и какая связь с косинусом! но нет эти дебилы так неделают.
фаза это натуральный по приоде родной аргумент для косинуса. но эти дебилы строят
косинус от времени. а потом пытаются принятнуть за уши какую то фазу. 

теперь когда разобрались с фазой переходим к сопряженной следующей теме.
поговоим про ряд фурье.
если есть периодическая функция f(x)=f(x+T) ( и еще там ряд условий на эту функцию налагается)
то она может быть представлена через бесконечную сумму (ряд) синусов и косинусов.
тоесть

f(x)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ]
где n=1 до inf
a(0)..a(n), b(n) это коэфициенты

где 
a(0)=(1/pi)*integral( f(x)dx ) на отрезке [-pi,pi]
a(n)=(1/pi)*integral( f(x)*cos(nx)dx ) на отрезке [-pi,pi]
b(n)=(1/pi)*integral( f(x)*sin(nx)dx ) на отрезке [-pi,pi]



замечу что x - это любая переменная необязатлеьно время. вообще любая переменная

также замечу что для синусов\косинусов в скобках 

фаза=n*x, где n=1,2,3..

тоесть мы раскалдываем функцию по синусам косинусам вида
cos x, sin x
cos 2x, sin 2x
cos 3x, sin 3x
итд


если x у нас это время. тоесть t. тогда
фаза=w*t=2*pi*f*t
с другой стороны мы имеем что 
фаза=n*t
тогда
2*pi*f*t=n*t
тгда
f=n\(2*pi) Гц
если 2*pi~6 тогда мы раскладываем функцию по частотам
f=n\6
тоесть
1\6 Гц, 2\6 Гц, 3\6 Гц, ... 100\6 ГЦ .... 100000\6 Гц

в данном случае видно что 
фаза=w*t ( по поердеению)
и что фаза=n*t (согласно формуле)
получается что w=n
так вот в другом места  я встретил инфо о том что  якобы можно использовать 
непросто w=n а w=w0*n

тоесть класическй фурье раскладывает функцию по 
sinx, cosx, sin2x, cos2x, sin3x,cos3x
а в одном месте я встретли что можно расклдывать по
sin kx, cos kx, sin 2kx, cos2ks, sin 3kx, cos 4kx
незнаю верно ли это.

далее пишут что 
чем больше членов ряда мы возьмем и обсчитаем тем более точное прибижение
мы получим.

замечу мы пока что рассматриваем функцию периодическую относительно x. 
если x это время то сигнал периодический по времени. 
так вот что существенно - то что нам нужно высчитаь коэффициенты a(n) и b(n)
только один раз. они верны для всех x. тоесть нам для каждого x ненужно 
выситывать коэфициенты a(n) и b(n) снова.

приведу разложение в ряд фурье некоео сигнала от балды:

f(x)=0.5 + summa [ cos(n*x) - sin(n*x) ]
или
f(t)=0.5 + summa [ cos(nt) - sin(nt) ]

где n=1.. inf

значит что мы имеем на данный момент. мы имеем то что сигнал имеет
бесконечное количество гармоник. 

получается интересно ( в целом если заметить ) что с точки зрения функции f(x)
все что внутри справа это все числа а переменная только x, а с точки зрения суммы
x это некая константа а переменные это все что с n. 
также получается что каждая точка на графике f(x0) в точке x0 это на самом деле
результат огромной бесконечной по количеству суммы членов. тоесть
например постоили мы график по оси X  у нас x по оси Y у нас f(x)
берем x0=1 на графике ему соовтествует всего лишь маленькая точка (x0,f(x0))
а на самом деле за этой маленькой точкой скрывается огромный рой членов ряда. тоесть

f(1)=0.5+ [ cos 1 - sin 1 + cos 2 -sin 2 + cos 3 - sin 3 ...]

это реальный прикол. что всего каждя маленькая точка функции ее значение 
это по факту сумма огромного ряда членов суммы. это напоминает вот что. лежит на прилавке куча телефонов. но каждый телефон это непросто маленкая коробочка это труд
огромного числа людей на огромном заводе. но на прилавке для человека это ничего 
невидно, для него это всего лишь маленькая коробочка. еще пример.
лежит в магазине хлеб в куче других хлебов на полке. и человеку невидно что этот 
хлеб это результат огромного труда людей и процессов с момента как зерно упало в землю. так и точка на графике этой функции это труд огромного числа синусов и косинусов которые стоят в сумме. функцию можно представит как магазин с его полками.
точки функции это булки хлеба. функция их продает или показывает. а ряд синусов и косинусов это невидимый труд миллиардов синусов и косинусов которые кропотливо создавали каждую точку этой функции но этого совсем невидно том кто смотрим на график этой функции. для него это прото маленькая точка на графике а график это просто маленькая черная ниточка на картинке.

окей. возвращемся обратно. существенно еще раз подчеркнуть
что для периодической функции коэфициенты a(n) и b(n) надо высчтывать только 
один раз. и они верны для всех x. для каждого x ненужно вычитывать коэфициенты
кажоый раз заново.

а рассмотрим как пример
f(x)=sin(x)

sin(x)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ]


высчитаем коэфициенты:
где 
a(0)=(1/pi)*integral( f(x)dx ) на отрезке [-pi,pi]
a(n)=(1/pi)*integral( f(x)*cos(nx)dx ) на отрезке [-pi,pi]
b(n)=(1/pi)*integral( f(x)*sin(nx)dx ) на отрезке [-pi,pi]

тогда
a(0)=(1/pi)* (-cos(pi)--cos(-pi))=(1/pi)*(1-1)=0
a(n)=(1/pi)*integral( sin(x)*cos(nx)dx ) на отрезке [-pi,pi] 
b(n)=(1/pi)*integral( sin(x)*sin(nx)dx ) на отрезке [-pi,pi]


integral( sin(x)*cos(nx)dx )= 0.5( - cos(x+nx)/(1+n) - cos(x-nx)/(1-n)) +Const
integral( sin(x)*sin(nx)dx )= 0.5( - sin(x+nx)/(1+n) + sin(x-nx)/(1-n)) +Const

0.5( - cos(x+nx)/(1+n) - cos(x-nx)/(1-n)) [от -pi до pi]=
=0.5( - cos(pi+n*pi)/(1+n) - cos(pi-n*pi)/(1-n)) - 
- 0.5( - cos(-pi-n*pi)/(1+n) - cos(-pi+npi)/(1-n)) =
= 0.5( - cos(pi(1+n))/(1+n) - cos(pi(1-n))/(1-n)) - 
- 0.5( - cos(pi(1+n))/(1+n) - cos(pi(1-n)/(1-n)) = 
= 0.5 ( - cos(pi(1+n))/(1+n) - cos(pi(1-n))/(1-n) + cos(pi(1+n))/(1+n) +
+ cos(pi(1-n)/(1-n)  ) = 0
значит a(n)=0

 sin(pi(1-n))/(1-n) - sin(pi(1+n))/(1+n)   = 
а далее прикол. поскольку n=1,2,3, то фазы под синусами это либо pi либо -pi
как ни крути. и значит что синусы равны 0. но! данная формула верна только 
для случая когда n!=1 а когда n=1 то надо (как я прочитал ) брать и считаьт 
интеграл руками конкнетно для этого n. 
итак n=1: 
integral( sin(x)*sin(x)dx )=integral( sin^2(x)dx )= 0.5* (x-0.5*sin(2x)) [от -pi до pi] = 0.5* ( pi-0.5*sin(2pi) ) - 0.5* ( -pi-0.5*sin(-2pi) ) = 
= 0.5* ( pi ) - 0.5* ( -pi ) = pi
значит 
b(n=1)=(1/pi)*(pi)=1
значит:
b(n)=0 кроме случая n=1, при n=1 b(1)=1
итого:
для sin(x)
a(0)=0
b(1)=1
b(n!=1)=0

итого разложение в ряд фурье sin(x):
sin(x)=0+summa (0*0+1*sin(x))=sin(x)
sin(x)=sin(x)
ура.

что еще существенно про коэффициенты ряда a(n) и b(n) что они абсолютно независят 
от переменной x. это очень важно отметить.

получается некая функция раскладываться в сумму синусов косинусов в виде:
f(x)=2 + 3*sin(x) + 5*cos(x) - 1*sin(2x) - 6*cos(2x) + ...
тоесть видно что коэфициенты от x независят. и получается наша функция это 
суперпозиция кучи синусоид косиснусоид. как бутто плывет стая рыб мелких разнообразных и она взяла сложилась одна в другую и вдруг вместо стаи рыб мы получили одного большого кита.  это похоже на белый свет и радугу. тоесть 
то что видимый белый свет это суперпозиция стаи цветов разного цвета.
как призма может разложить белый свет на всю стаю так и наверно какойто инструмент
может разложить звук на стаю синусоид. прям трансформер какойто. как бутто звук 
это как тело человека состоящее из армады клеток. армада образует одно целое но 
если захотеть то можно увидеть не единое тело а рой клеток. жалко что звук или свет туда сюда можно раскладыать на составные из целого и обратно в целое из составных а с телом человека так не получится.

так ну это был ряд фурье для через вещественные косинусы синусы. 
щас вывеем ряд фурье через комплкнсные экспоененты:
берем
cos a = ( e^ia+e^(-ia) )*0.5
sin a = ( e^(-ia) -e^ia )*0.5

тогда 
cos (n*a) =   ( e^ina + e^(-ina) )*0.5
sin (n*a) = j*( e^(-ina) - e^ina )*0.5

подставляем в ряд фурье:
(f(x), 0)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ] = 
= a(0)*0.5 + 0.5*summa [  (a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx)  ] 

кстати что в этой формуле полезно еще раз отметмить - формула имеет вид
f(x)=A0*0.5 + 0.5 (A1*e^inx + B1*e^(-inx) + A2*e^inx + B2*e^(-inx)...)
тоесть у нас переменную 


получаем ряд фурье выраженный через комплесные экспоненты.
также слева будем использовать алгебраическую форму комлксного числа 
тоесть то что (f(x), 0) = f(x)+i*0 тогда

ряд фурье выраженный через комплекстные экспоенты:
f(x) = a(0)*0.5 + 0.5*summa [ (a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx) ]

далее я вспоминаю формулу которая позволяет перевести алгебраическую форму
числа в показтельную:
z=sqrt(x^2+y^2) * e^(i*argz(x+i*y))
тогда:
a(n)+j*b(n)= sqrt(a^2+b^2) * e^(i*argz(a+i*b))
a(n)-j*b(n)= sqrt(a^2+b^2) * e^(i*argz(a-i*b))

далее обозначим argz(a+i*b) как phi(n), тогда

a(n)+j*b(n)= sqrt(a^2+b^2) * e^(i*phi(n))
a(n)-j*b(n)= sqrt(a^2+b^2) * e^(-i*phi(n))

подставляем сюда:
(a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx) = sqrt(a^2+b^2) * [
 e^(-i*phi(n)) * e^(inx) + e^(i*phi(n)) * e^(-inx) ] = 
 = sqrt(a^2+b^2) * [ e^(inx-i*phi(n)) +  e^(-inx+ i*phi(n)) ] = 
 = sqrt(a^2+b^2) * [ e^(i(nx-phi(n))) +  e^(-i(nx-phi(n)) ] = 
 = sqrt(a^2+b^2) * [ e^(i(nx-phi(n))) +  e^(i(-nx+phi(n)) ] 

тогда ряд фурье:
f(x) = a(0)*0.5 + 0.5*summa [ sqrt(a(n)^2+b(n)^2) * [ e^(i(nx-phi(n))) +  
+ e^(i(-nx+phi(n)) ]

где phi(n)=argz(a+i*b)

прикольно что в книжках за phi(n) берут argz(a-ib) ттгда соотвеатвенно наш
phi(n) превратиться в -phi(n) 

тогда в итоге в книжках ряд фурье расписыают вот так:

f(x) = a(0)*0.5 + summa [ 0.5 * sqrt(a(n)^2+b(n)^2) * [ e^(i(nx+phi(n))) +  
+ e^(i(-nx-phi(n)) ]

где phi(n)=argz(a-i*b)

далее они еще делают замену и получают вот такой вид:

f(x) = a(0)*0.5 + summa [ c(n) * [ e^(i(nx+phi(n))) +  
+ e^(i(-nx-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)


поговорим о том почему ряд фурье в комплексном виде всегда будет давать точки 
на комплексной плоскости исключтетльно на вещественном луче:
экспоненты как результат на компл проскости они 
дают вектора единичного радиуса и повернутые один на угол 
nx-phi(n) а второй на угол -nx+phi(n). это к чему приводит - это приводит к тому
что сумманый вектор всегда будет лежать на оси X тоесть на вещественной оси
тоесть сумма этих экспонент всегда дает вещественный результат,значит и полная
сумма этих слагаемых даст всегда сугубо вещественный результат.


далее вот что рассмотрим  формулу ейлера:
e^i*x=cos (x) + i*sin(x)

косинуса и синуса у нас классические вещественные. аргумент внутри 
косинуса и синуса это угол. причем он задается в радианах.
значит размерность аргумента вних должны быть радианы.
вообще это интереснрый момент кгда мы обычно рассматриваем формулу в математике
то у нее обычно нет ниаких размерностей хоть тугрики хоть киолграмы хоть безразмерно  а синус и косинус стоят отдельно. у них аргумент имеет размерность.
такая вот подстава. так вот x обязан иметь размерность в радианах по крайней мере
не сам x(тоесть остальная часть формулы может иметь x любой размерности) но то что стоит в скобках  в качестве аргумента у синуса и косинуса дожлно быть преобразовано в радианы.
предположим что x у нас это t время в секундах тогда внутри синуса и косинуса
надо ставить не t а t умноженное на некий коэфициент который переводит секунды в
радианы. назовет этот коэфициент w (радиан\секунду) тогда формула эйлера
кгда у нас переменная x это время t  превратится в 

e^i*(w*t)=cos (w*t) + i*sin(w*t)

далее надо выяснить а чемуже равен этот сраный коэфициент. значит что такое синус 
и косинус с точки зрения физики. это точка движется по окружности по некоторому закону изменения угла phi=phi(t) (хотя может же и сложнее например закон phi=phi(t,x,y) ну не знаю наверно рассматривается более простой случай когда phi=phi(t))
тогда 
если мы говорим что phi=w(t)*t
то w(t)=d(phi)
        -------  (производная от угла по времени)
        dt

Если phi   в радианах то w получается в радиан\с

Тогда ( в случае когда x это у нас t время в секундах) то ряд фурье 
получаем имеет вид:

f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(nt+phi(n))) +  
+ e^(i(-nt-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
где n*t=n*w1*t

w1- некая базовая круговая частота которую мы задаем сами вначале. какую захотим.
с этой w1 реальная мудота для понимания.
об этом ниже.

они почему то постулируют что w от t независит. что w=const от t.
непонятно. ведь w может быть функцией не только от t но и от x вообщето.
ну ладно...

также важно то что аргумент при экспоненте имеет вид i*nt только в случае 
если при нахождении коэфициентов a(n) и b(n) мы там юзаем иниеграл и у него
пределы интегрирования указываются так вот если в экспоненте стоит i*nt то в интеграле должно стять от -pi до pi. если пределы другие например от -pi\2 до
pi\2 то у эксопненты будет другой вид типа i*w1*n*t
где w1- некая константа.  ну суть такая что мы можем разлагать фунцию в ряд
по круговым частотам вида 

1,2,3,4,5,6 

а можем по частотам

w1*1, w1*2, w1*3, w1*4...
вобщем мудота та еще с этим рядом фурье. реально.

тоесть в ряду фурье можно задавать некую базовую круговую частоту и раскладыать 
функцию по синусам\косинусам которые кратные этой частоте.
в моем случае вверху ряд фурье указан для разложения когда w1=1(рад\с)


тогда ряд фурье в более общем случае когда у нас базис синусов косиуснов
выбирается такой что sin w1*t, cos w1*t, sin 2*w1*t, cos 2*w1*t бдует иметь вид


f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)

в заввимимости какую w1 мы берем изначально от этого будут меняться a(n) и b(n)
еще раз w1 откуда мы ее берем. мы берем ее из ниоткуда в том плане что ее вычилсять
ненадо. мы ее сами задаем какой хотим изначаьно и от этого уже ряд фурье пляшем.
выбор w1 влияет на то какими будут a(n) b(n) c(n) phi(n)
 
теперь наконец двигаем дальше - когда высчитали a(n), b(n) то автоматом высчитаем и
c(n) и высчитаем phi(n), нам на выходе нужны c(n) и phi(n). когда мы их вычситали
то строят два графика.
первый график по оси X откладывают 1*w1, 2*w1, 3*w1, 4*w1 по оси Y откладывают c(n)
таким образом мы показываем чему равна амплитуда вектора для каждого n-го члена 
внутри суммы.

второй график по оси X тклывают опять же 1*w1, 2*w1, 3*w1, 4*w1 а по оси Y откладывают phi(n) таким образом для каждого n-го члена внутри суммы мы показываем
чему равно смещение угла(фазы). 

таким макаром из этих графиков мы можем быстро составит чему равен ряд фурье.
например.

w1=1,
c(n)=2*n
phi(n)=1*n

также насколко я понимаю то a0=c0/2

тогда ряд фурье будет такой:

f(t) = 0*0.5 + summa [ (2*n) * [ e^(i(n*1*t+1*n)) +  
+ e^(i(-n*1*t-1*n)    ] =   0*0.5 + summa [ (2*n) * (   e^(nt+n) + e^(-nt-n)   ) ] =
=  summa [ (2*n) * (  e^(t+1) + e^(-t-1)  + e^(2t+2) + e^(-2t-2) + ...) ]
 

еще раз посмотрим на ряд фурье:


f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)


значит по сути здесь  по суммой складывается каждый раз два вектора. 
у каждого из них длинна c(n)
и у одного угол n*w1*t+phi(n) а у другого угол -n*w1*t-phi(n)
по мне для того чтобы построить оба этих вектора перед сложением аболютно достаточно
на графиках phi(n) и c(n) откладвать по оси X только положительные значения такие как 0, 1*w1, 2*w1, 3*w1, 4*w1 итд. этой информации аболютно достаточно
для построения этих двух векторов. При этой частота w1*1, w1*2,w1*3 имеет прямой 
и четкий и понятный физ смысл. но эти придурки как я понимаю чисто для математического выебона делают следующее. они говорят знаете - давайте частоты
1*w1, 2*w1, 3*w1, 4*w1 и вообще все такие положительные чатсоты мы будем их с графика подставлять исключительно только в первую экспоненту  e^(i(n*w1*t+phi(n)))
а во вторую экспоненту мы это подставлять небудем (хотя это полная хуйня), они 
говорят давайте для второй экспоненты мы будем откладывать -1*w1, -2*w1, -3*w1,
-4*w1 итл и соотвественно для графика c(n) будем рисовать ровно тоже самое
что мы рисовали для положительных n*w1. тоесть если было что
c(1*w1)=1 то для  c(-1*w1) откладываем тоже 1
а если было для phi(1*w1)=1 то для phi(-1*w1) откладываем -1

ну тоесть я говорб в чем суть их этой ебнутой придумки. они для 
члена 
c(n) *  e^(i(n*w1*t+phi(n)))  
подставляют значения с графиков c(w1*n) и phi(w1*n)
с правой части этого гарфика когда w1*n>0

а для члена 
c(n) * e^(i(-n*w1*t-phi(n))
они подставляют c(n) и phi(n)
 слевой части графика когда w1*n<0

по мне это полностью искусттвенная ненужная хуйня которой они занялись потому что
абсолютно для обоих векторов достаточно графиков c(n) и phi(n) при w1*n>0 то правой 
части этих графиков. и у нас нет никаких этих сраных отрицательных частот.
то что они делают это сугубо искуственная ненужная хуйня. отсоюда у них и берутся
несущесвтвующие неимеютщие никакого смысла отрциательные частоты.
таково мое мнение.

итак еще раз. зачем нужен график c(n) от (w1*n) и график phi(n) от (w1*n)
они нужны чтобы глядя на них мы могли восстаовить как выглядит рядь фурье. его члены
внутри суммы. при этом графиков при n>0 асболютно для этого достаточно.
то что они русют графики также и для n<0 это аобсолютно ненужная искуственная хуйня.
Это типа так сказать типа у них такая удобняшка что для члена 
c(n) *  e^(i(n*w1*t+phi(n))) 
брать коэфициенты с правой части графиков при n>0
а для члена
c(n) * e^(i(-n*w1*t-phi(n))
брать коэфицицента с левой части графиков при n<0
Еще раз хочу подчеркнуть что кожфициенты в левой части на самом деле получаются из 
коэфициентов из правой части так что левая часть нахер невсралась.
Для графика c(n) все что слева при n<0 ровно тоже самое что справа при n>0.
для графика phi(n) все что слева при n<0 равно тому что справа при n>0 только со знаком минус. 

Ну и собсвтенно как называются эти графики 
c(n) назыается амплитудно-спектральный график
phi(n) называется фазово-спектральный график.

также еще подчекрну что графики эти строятся не от n а от w1*n.

график c(w1*n) при n>0 покзаывает амплитуду  для вектора в сумме который вращается по часовой стрелке по времени, при n<0  амплитуду для вектора коорый
врщается против часовой стрелки.

график phi(w1*n) при n>0 покзаывает фазу  для вектора в сумме который вращается по часовой стрелке по времени, при n<0 фазу для вектора коорый
врщается против часовой стрелки.


таким макаром кое как мы вроде наконц поняли откуда берутся у этих придурков 
отрицательные частоты круговые. их нет а они просто придурки.
круговые часоты введены для вещественных функций а они на ходу начинают их прилепливать к функциям комплексным и начинается полный бардак. 
у вещвественных функций никаких отрицательных круговых частот нет.

хотя с другой стороны вот есть у нас phi=-5*t, значит
|x=cos(-5*t)
|y=sin(-5*t)
совершенно понятно что данная точка летает по окружности в сторону против часовой стрелки. так почему бы нам для вещ функций не определить эту самюу отрицательную 
круговую частоту? это ж так очевидно! а они гворят нет - для вещественных косинусов
и синусов никаких отрицательных частот не бывает. что за хуйня?

еще раз подумаю на тему времени t в аргументе у синуса косиунуса.
далее говорим про косинус(с синусом тоже самое.). что такое косинус. рисуем окружно
сть с радиусом 1. откладываем угол на окружности. причем как мы его откладыаем.
мы откладыаем угол в радианах. что такое радианы. если окружность единчиного радиуса
то ее полная длинна примерно 6 или 2*pi. так если мы говорим что мы отложили угол
phi радиан это значит что мы отложили на окружности дугу длинной phi единиц.таким 
образом угол в радианах это длинна дуги - совершенно натуральная штука ( в отличие
от всяких там стремных градусов и транспортиров.). отложили дугу заданной длинны
получили точку на дуге. от этой точки опускаем верти палку на гор ось и получаем
длинну отрезка это косинус для данного угла phi. таким образм косинус это
функция у которогой аргумент это угол в радианах. отложиди угол померяли косинус.
отложиди угол померяли косинус. вопрос - как нам теперь всунут время t внутрь
косинуса. Прежде всего еще раз - косинус это функция от угла. тоесть косинус 
у него аргумент только угол и больше ничего. Предпожим что угол это функция от времени. тоесть phi=phi(t). Теперь подставляем в косинус 

cos phi = cos phi(t)

если мы знаем t то вычилсяем phi в этот момент t. знаем phi вычисляем косинус.
например phi=e^5t+16t+16t^2
тогда

cos(phi)=cos(e^5t+16t+16t^2)

окей мы засунули t внутрь косинуса.

а если угол завиисит еще от каких то переменных типа от x,y,z 
напрмиер

phi=e^5t+2x+3y+6z

замечу только то что итоговый phi должен быть в радианах получаться при подстановке
переменныха не втугриках каких нибудь.

тогда
cos(phi)=cos(e^5t+2x+3y+6z)

ну все таки мы щас рассматривем сигналы которые обычно зависят только от времени
так что от других перпеменных они обычно независят .у нас обычно есть нарисоанный
полученный сигнал картинка график от времени. так что наверное будем считать 
что phi это функция только от времени. phi=phi(t)
далее очень важно и интересно - по определению w (угловая частота) это d(phi)\d(t)
тоесть производная угла по времени. возникает вопрос почему в ряду фурье 
аргумент у косинуса \синуса имеет вид cos (n*w1*t) и sin (n*w1*t),
где n=0,1,2,... и w1 это константа, тоесть

cos (w1*t), cos (w1*2*t), cos (w1*3*t)

ведь это же должно означать  что закон изменения угла от времени имеет линейный вид!
а именно:
phi(t)=w1*t
phi(t)=2*w1*t
phi(t)=3*w1*t

а он и имеет линейный вид!  (щас скажу почему).
и поскольку закон изменнеия угла от времени имеет линейный вид то линейная
функцция имеет всегда вид y=k*t+b, где k это производная dy\dt и у линейной функции
производная константа! поскольку y  у нас это phi то dy\dt это d(phi)\dt и это равно w! b в нашем случае равно нулю. (щас я скажу почему b равно нулю.).
Так вот ответ на вопрос - почему в ряду фурье аргументы под косинусами имеют вид
k*t,2*k*t, 3*k*t, 4*k*t .... где k это некторая константа, так вот ответ почему так состоит в том потому что мы так задали, потому что мы так захотели! Тоесть как
создавался ряд фурье. мы говорим что мы имеем сигнал f(t). сигнал зависит 
только от времени. и мы сказали - что мы хотим узнать как это сигнал можно представить в виде разложения по функциям:

cos(1*w1*t), sin(1*w1*t), cos(2*w1*t), sin(2*w1*t), .... cos(n*w1*t),
sin(n*w1*t)

где:
w1- некая констана которую мы сами задаем изначально. по нашему желанию.
например w1=10;
n-натуральное число 1,2,3,4,5,6.... infinity

таким образом вопрос почему мол под синусами\косинусами угол изменяется 
от времени по закону phi=n*w1*t ответ такой что мы так сами изначально захотели
задали выбрали заказали! это наше желаение. мы ищем ращложение сигнала f(t)
именно через такой набор так выглядящих синусов\косинусов.

теперь ответ на вопрос почему w1 это круговая частота. точнее даже так почему
n*w1 это круговая частота. с чего мы это взяли? взяли мы это с того что : под косинусом то что стоит это всегда угол в радинах и больше это ничего. еще раз под
косинусом всегда стоит исключиельно угол в радианах. значит

cos (n*w1*t) = cos (phi)
значит
phi=n*w1*t

n- это константа
w1- это констата

находим производную d(phi)\dt
d(phi)\dt=n*w1

значит по опредеению w=d(phi)\dt значит  w(t)=n*w1
таким образом мы видим что наша w независит от времени, она постоянная,
значит n*w1 это коэффициент имеет по своему физическому смыслу тот смысл что 
это круговая частота! соотсвтееенно если n=1 то тогда w1 по своему физ
смыслу оказывается круговая частота. а если n неравен 1 то тогда круговая
частота это n*w1 и в этом случае w1 неимеет явного физ смысла.
если мы под косинусом стоял другой закон для phi например

cos(n*w1*t^2)

тогда
phi=n*w1*t^2, тогда d(phi)/dt=2*n*w1*t тогда w(t)=2*n*w1*t
в этом случае n*w1 неимеет никакого физ смысла . это просто коэфиициент.

Так значит о том что w(круговая частота)=n*w1 если у нас угол имеет вид phi=n*w1*t
мы разобрались - тоесть потому что мы так сами задали захотели чтобы угол
в косинусе менялся по закону phi=n*w1*t. мы так захотели сами изначальано.
а w=n*w1 из определения. потому что w=d(phi)\dt а d(phi)\dt=n*w1

Теперь отвечаю на вопрос почему мы хотим ракслкдыать сигнал именно по 
функциям 

cos(1*w1*t), sin(1*w1*t), cos(2*w1*t), sin(2*w1*t), .... cos(n*w1*t),
sin(n*w1*t)

а не каким то другим. значит данные функции являются гармоническими. 
что такое математически означает гармоническая фугкция - хрен знает. я посмотрел 
както там сложно. важное свойство гармонических функций в том что при прохождении
через линейную систему (что такое линейная система тоже отдельный вопрос я незнаю 
но видимо это важные системы), так вот при прохождении гармонического сигнала
через линейную систему сказано что гармонический сигнал это единственная форма сигнала которая сохраняет свою форму меняется только амплитула и образуется сдвиг 
фазы и все. получается что если мы пропустим через линейную систему скажем вначале
один гарм сигнал , посмотрим как у него имзенится амлитуда и сдвиг фазы. потом
запустим второй сигнал, потом третий. а потом мы запустим сигнал который является 
суммой этих трех сигналов то на выходе мы получим предсказуемый сигнал который
будет являться также суммой исходных трех сигналов  в кажом из которых была изменена
амплиутуда и сделан сдвиг фазы. таким образом пропустив через линейную систему
весь набор гармонических сигналов по отдельности и померяв как меняется амлиутуда
и сдвигается фаза а потом разложив наш произволльный сигнал по этим гармоническим 
сигналам мы будем заранее знать какой сигнал мы будем получать на выходе.
Вот походу зачем и почему мы хотим искать разложение нашего исходного сигнала
именно по такому базису функций.

Значит исходя из лекции из томского политех института - там сказано что данный
набор функций является ортгональным на интервале от t0 до t0+T
где T=(2*pi)/w1
Что такое ортогональность. Это типа как скалярное произведение векторов. мы 
требуем чтобы они были друг относительно друга под углом 90 градусов.
для векторов это выглядит как |a|*|b|*cos(ab) это значит что если между ними 90 градуосов то тогда скаляр произвдение будет равно нулю. у ортогональных векторов
скаляр произвдеение равно нулю. потому что они под 90 градуосв друг относиельно 
друга. Тоже самое водится для функций на интервале (a,b) функции ортогональны
если интеграл  f1(t)*f2(t)*dt = 0 на интервале (a,b) 
соотвственно они там показывают что на интервале (t0,t0+T) интегралы
cos(n*w1*t) * cos (m*w1*t)* dt=0
sin(n*w1*t) * sin (m*w1*t)* dt=0
sin(n*w1*t) * cos (m*w1*t)* dt=0

соотвевенно если функция умножается сама на себя в таком же интеграле то 
как и в случае векторов когда |a|*|a|*cos 0 = |a|^2 также и для функций там 
должна получаться константа. они показыват что да получается константа = T\2
вобщем таким макаром доказыаетсся что нащ выбранный набор функций он ортгонален.
также он полон(хрен знает что это значит) , вобще витоге всю эту бодягу товарищ 
фурье проделал и доказал что для периодичекой функции f(t) ее можно представить
как разложение по гармоническим функциям

f(t)=a0/2 + summa ( a(n)*cos (n*w1*t) + b(n)*sin (n*w1*t) )

где 
a(n), b(n) этокофициенты тоесть они независят от t. это чисто константы которые 
вычисляюются по форумулам через интеграл.
w1 - это константа которую мы выбираем изначально какую нам в голову взбредет.

еще раз почему мы ищем ращложение нашей f(t) именно по 
cos (n*w1*t), sin (n*w1*t)
потому что эти сигналы при проходдждении чере линейную сисему сохраняют свою форму
у них менятеся только амплитула и сдвигается фаза. поэтому если мы разложим наш
сигнал на эти функции то мы можем тогда зараннее предсказать какой сигнал мы полуич
на выходе. это удобно это прикольно.

также прикольно что получается что любой звук (перидоический) можно получить
если взять гитару с бесконечным числом струн. далее дернув каждую струну с нужной
амалитудой и фазой на выходе получим наш искомый звук. это тоже прикольно.  тоесть
наш звук являтеся суммой бесконечного числа дернутых струн. это прикольно.

прикольно то что сигнал можно разложить по таким простеньким сигналам. по вибрирующим струнам. ну или по грузикам дергающимся на пружинках. это очень 
просьенькие сигналы. это чтото типа того как человек состоит из клеток или даже атомов. как книжка состоящая из букв. или как данные на диске состоящие из 0 и 1.
интеерсно можно ли звук или сигнал разложить еще по более простецким по своей форме
сигналам. потому что синус и косинус конечно он простой но все же достотаточно еще
сложный. нужно чтото более еще простецкое. было бы прикольно. 
другой дело что я понял что синус и косинус это якобы единственный по форме сигнал
который сохраняет форму при прохождеии линейной системы. а это важно. другой
отртогональный набор базисных функций этим свойством якобы не обладает.

окей. это я вроде как понял. и частности то что почему phi=n*w1*t.


Далее. 
насколко я понял вопрос о том а что мы делаем если функция у нас не регулярная.
что делать тогда. как я понял делать только вот что. берем ее ограниченную 
слева и справа по X тоесть по времени. то есть берем ее какойто кусок за какоето время.  потом мы ее продолжаем налево и направо по времени так чтобы она стала
приеодической. далее получаем разложение фурье. и на нашем ограниченном участке
разложение будет совпдаать с нашим сигналом. 


Далее.
остается вопрос какой смысл городиь комлплексный ряд фурье чем плохо обычный ряд фурье. в обычном ряде фурье наш сигнал разбивается на графики:
 график a(n) от n*w1
 график b(n) от n*w1

в чем преимущество перед комплесным рядом фурье?
в нем сигнал разбиватеся тоже на два графика:
график c(n) от n*w1
график phi(n) от n*w1

так в чем же выгода?
в другом учебнике про ряд фурье я нашел то что выгода от комлпескной формы
состоит якобы в том что она более компактная. и больше никаких выгод
она недает. 

Еще раз более подробно рассмотрим комлексную форму ряда фурье которую вывел я:
f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)

заменим:
c(0)=a(0)*0.5

получаем:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ]

где:
n=1..inf
c(0)=a(0)*0.5
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
phi(n) = argz(a-i*b)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]

расмотрим а чему равно a(-n):
a(-n)=(2/T)* [ integral (f(t)*cos(-n*w1*t)*dt) на отрезке [-T, T] ]
соотвесвтенно поскольку cos(-x)=cos(x) значит:
a(-n)=a(n)

расмотрим а чему равно b(-n):
b(-n)=(2/T)* [ integral (f(t)*sin(-n*w1*t)*dt) на отрезке [-T, T] ]
соотвесвтенно поскольку sin(-x)=-sin(x) значит:
b(-n)=-b(n)

тогда с(-n)=0.5 * sqrt(a(-n)^2+b(-n)^2) = 0.5 * sqrt(a(n)^2+(-b(n))^2)=
=0.5 * sqrt(a(n)^2+b(n)^2) =c(n)
значит
c(-n)=c(n)

далее
 phi(-n)=argz(a(-n)-i*b(-n))=argz(a(n)+i*b(n))=argz(a+i*b)

далиее сраниваем:
phi(n) = argz(a-i*b)
phi(-n)= argz(a+i*b)

мы видим что справа стоят компл сопряженные числа значит:
phi(-n)= -phi(n)
собственно нам вот эта формула и нужна была. щас мы ее применим.
значит берем ряд фурье:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ]

и разбиваем сумму на две суммы:
summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] =
= summa [ c(n) * e^(i(n*w1*t+phi(n))) ] +
+ summa [ c(n) * e^(i(-n*w1*t-phi(n)) ]

где:
n=1..inf

(тоесть я пользуюсь свойством что summa (a+b)=summa(a) + summa(b). )

далее рассматриваем вторую сумму:
summa [ c(n) * e^(i(-n*w1*t-phi(n)) ]
где:
n=1..inf

введем замену переменной:
k=-n, где k=-inf..-1
тогда:
n=-k
тогда подставляем:
summa [ c(n) * e^(i(-n*w1*t-phi(n)) ] = summa [ c(-k) * e^(i(k*w1*t-phi(-k)) ]
где:
k=-inf..-1

поскольку k это просто внутренний индекс (тоесть неважно какая буква k или n)
то мы юзаем полученное выше свйоство что 
c(-k)=c(k)
phi(-k)=-phi(k)

подставляем это в нашу сумму:
summa [ c(k) * e^(i(k*w1*t+phi(k)) ]
где:
k=-inf..-1



тогда подставляем это в сумму что выше:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] = 
= c(0) + summa [ c(n) * e^(i(n*w1*t+phi(n))) ] + summa [ c(k) * e^(i(k*w1*t+phi(k)) ]

где:
n=1..inf
k=-inf..-1

теперь замечаем что в первой сумме и во второй сумме внутри член стоит 
одинаково выглядящий. просто суммы идут от пределов.
и мы заюзаем такое свойство сумм что :
summa ( a(n) ) + summa ( a(k)) = summa (a(f))

где:
n=a..b
k=b+1..d
f=a..d

тоесть две суммы можно обединить в одну если член под суммйо одинаковый. 
суммы обединятся в одну просто путем обьединения пределов суммы. 
например:
summa (n) + summa (k) 
n=1..3
k=4..5
значит:
summa (n) + summa (k) = summa (f)
f=1..5
деййтвиельно:
summa (n)=1+2+3
n=1..3
summa (k)=4+5+6
k=4..6

значит suuma (n)+summa(k)=1+2+3+4+5+6
саравним с суммой по f
summa(f)=1+2+3+4+5+6
f=1..6
видно что 
suuma (n)+summa(k) = 1+2+3+4+5+6 = summa(f)

значит для нашего случая мы получаем то что:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] = 
= c(0) + summa [ c(n) * e^(i(n*w1*t+phi(n))) ] + summa [ c(k) * e^(i(k*w1*t+phi(k)) ] = c(0)+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
n=1..inf
k=-inf..-1
m=-inf..-1, 1..inf

итак мы получилии что:
f(t)= a(0)*0.5+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1, 1..inf

как видно пределы суммы невключают в себя индекс равный ноль.
рассмотрим элемент суммы при m=0
[ c(0) * e^(phi(0))) ]


phi(0)=argz(a(0)+i*b(0))
a(0)=(2/T)* [ integral (f(t)*cos(0)*dt) на отрезке [-T, T] ]=
= (2/T)* [ integral (f(t)*dt) на отрезке [-T, T] ]=
b(0)=(2/T)* [ integral (0*dt) на отрезке [-T, T] ]=0
значит
phi(0)=argz(a(0)+i*0)=0
значит:
при m=0 имеем:
[ c(0) * e^(0))) ] = c(0)

рассмотрим чему равен c(n) по формуле:
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
мы только что получили что b(0)=0 тогда
c(0)= 0.5*sqrt(a(0)^2+0)=0.5*a(0)
итак элемент под суммой при m=0 он равен 0.5*a(0) если считать по нашим 
общим формулам для a(n),b(n),c(n),phi(n)

значит в нашей формуле для ряда фурье:

f(t)= a(0)*0.5+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1, 1..inf

мы выяснили что при m=0 то что внутри суммы равно a(0)*0.5 это значит что 
мы можем убрать из формулы a(0)*0.5 а в границы сумммирования добавить индекс m=0

тогда наша формула для ряда фурье будет выглядеть:

f(t)= summa [  c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1,0,1..inf = -inf..+inf


ну или если теперь заменить m на n то:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

рассмотрим то что мы получили.
c(n) это чисто числовая вещественная константа. тоесть прям число типа как 5,10,100
если мы посмотрим на формулу c(n) то мы увидим что c(n)>=0 всегда тоесть он точно
никогда неотрицательный. таким образом c(n) определяет длинну вектора комлплексной
экспоненты. 
второ сомножитель это комплексная экспоненты которая выглядит на компелкексной
плоскости как вектор единичной длинны лежащий на окружности единичного радиуса 
повернутый на некторый угол. причем для каждого n будет некоторый инидивидуальный 
угол докрутки phi(n). 
таким образом в целом то что стоит внутри под суммой это на комплексной плоскости
вектора длинной c(n) повернутый на угол пропорциональный n и еще подкрученный
на некоторый индивидуальный угол phi(n). если мы зафиксируем n. тоесть рассмотрим
этот индивидуальный вектор и при этом мы незафиксируем t то этот вектор будет 
вращаться в комплексной плоскости по окружности радиусом c(n) с угловой скоростью n*w1 причем если n>0 то он будет вращаться против часовой стрелки а если n<0 то против часовой стрелки. при фиксированнном n  у нас c(n) и phi(n) это константы.
таким образом длинна вектора будет постоянная тоесть как я и сказал что вектора
будет описывать окружность. phi(n) получается задает начальную фазу (если мы рассматриваем на момент времени t=0) или сдвиг фазы. при изменнеии t вектор начнет
вращаться с постоянной угловой скоростью n*w1 (n фиксировано. w1 - начальная константа). 

так. я щас немножко еще перепишу формулу:
f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ] = summa ( s(n) )

так вот если мы зафиксируем t, и рассмотрим s(n) и s(-n)
то мы увидим из того что получали ранее что эти два вектора в компл плоскости
они имеют одну длинну и зеркально относительно гор оси повернуты. тоесть эти компл
числа (вектора)  они сопряженные. это значит что при сложении этих двух векторов
их сумма всегда будет лежать на оси X тоесть результат вещественное число. тоесть
таким макаром мы еще раз доказали что вся сумма это вещественное число.

далее исходя из этой формулы строят два графика:
c=c(n)
phi=phi(n)

хотя не совсем так. еще домножают на изначальную константу w1 тоесть
c=c(n*w1)
phi=phi(n*w1)

поскольку n= -inf..+inf
то это значит что n у нас принимает как положительные так и отрицаттельные
значения на графиках. соотвевтенно при отрицательных n  у нас под суммой генерируются экспоненты (вектора) которые при измении t вращаются против часовой стрелки а при положительных n у нас гененрируеются экспоненты которые вращаются 
при изменнии t по часовой стрелке. 

итак еще раз посмтрим на полученный вид ряда фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

значит для примера скажем для какойто фукции он выглядит вот так:
(я взял w1=1 для примера также):

f(t)= 2*e^(i(-100*t+1)) + 3*e^(i(-99*t+2)) +...+ 6 + 3*e^(i(99*t-2)) +
+ 2*e^(i(100*t+1))+... 

зафиксируем некоторый момент времени t0.
что по факту мы видим в правой части - мы видим кучу векторов постоянной длинны которые складываются по правилам сложения векторов ну и как мы знаем они дадут вектор у которого 
вторая координата ноль, тоесть вектор будет лежать на оси X. и его первая координата
и будет f(t). если мы начнем менять время то конструкция оживет. если мы дадим приращение времени t0+dt то вся эта гирлянда векторов сдвинется , вектора начнут вращаться кто-то по часовой стрелке кто-то против часовой в зависимости от знака
перед t, и они начнут вращаться с постоянными угловыми скоростями равными тому 
что стоит перед t. еще как можно сказать - вот у нас зафиксирован момент t0. все вектора неподвижны. мы находим их сумму. потом мы сдвинули время на t0+dt и у нас
картинка оживет - у нас все вектора повернутся на некоторые углы в зависимости какой
коэфициент стоит перед t и далее конструкция опять остановится замрет. и мы опять посчитаем векторную сумму этих векторов и получим f(t0+dt). Эта красивая картина. 
мне это напоминает часы с шестеренками. каждый вектор это своя шестеренка в часах.
часы стоят. мы берем крутилку сзади у часов и чуть чуть ее крутим (тоесть делаем t0+dt) и тут же все шестеренки приходят в движение и в итоге стрелка на морде часов
передвигается на некоторое расстояние . стрелка на морде часов это и есть f(t0+dt).
Очень красивая получается концепция. Еще и потому что вектора также как и шестеренки
крутятся действительно по окружностям. И еще аналогия красиво совпадает в том плане
что в часах с шестеренками большие шестеренки вращаются медленно а мелкие шестеренки вращаются очень быстро. Также и здесь - есть вектора у которых большая угловая скорость они будут делать за единицу времени очень много оборотов вокруг себя а есть вектора у которых малая угловая скорость и они будут вращаться очень медленно вокруг себя за единицу времени. тоесть когда мы покрутим крутилку то какието вектора повернутся на очень много оборотов а какието еле сдвинутся. это ровно тоже самое как в часах. мы немного поворачиваем крутилку и мелкие шестерни очень много раз повернутся а крупные шестерни еле еле повернутся. Остается понять 
какая аналогия с амплитудами у векторов и шестернями в часах , что у них общего.

далее я пока откладываю тему шестеренок в будильнике на потом.


дальнешие размышления замечания про всю эту тему:
Если мы умножаем комплескное число на комплексное число то что будет
их результатом - будет еще одно компл число у которого длинна вектора будет
произведение длин векторов и угол поворота  сумма углов обоих векторов.
тоесть z1*z2=r1*e^i(a1) * r2*e^i(a2) = (r1*r2)*e^i(a1+a2)
теперь рассмотрим частный случай:
z1*e^ia=r1*e^ib*e^ia=r1*e^i(a+b)
таким образом если мы умножаем компл экспоненту на произвольное компл число то
результат будет вектор который по длинне равенр длине вектора z1 и довернулся
на тот градус который имел вектор z1. тоесть если у нас экспонента это функция 
времени а z1 это константа относительно времени , то чистая экспонента как известно  выглядит как единичный вектор вращающийся по окружности так вот
домножение ее на z1 дает то что это будет не единичный вектор а вектор длинной z1
и он который в момент времени 0 будет иметь начальный повопрот - начальную фазу начальный сдвиг фазы. вот это для понимания. 

далее если мы рассмотрим две экспоненты e^ia и e^-ia то это вектора который сопряжены друг к другу. e^ia это единичный вектор который повернут на угол a, 
а e^-ia это единичный вектор повернутый на угол -a если мы теперь рассмотрим
их сумму 
e^ia + e^-ia то это будет вектор который имеет только вещественную часть. 
если у нас a это функция от времени a=a(t) то первый вектор если смотреть по времени
он будет вращаться по окружности по часовой стрелке а второй против часовой стрелки.

если у нас есть z1 и z2=z1(сопряженное )  и мы рассмотрим такую сумму:
z1*e^ia+z2*e^(-ia) то что это будет. 
первое слагаемое это вектор длинной z1 и он повернут на угол a+b
второй вектор той же самой длинны и повернут он на угол -a-b таким образом
у нас два сопряженных вектора которые нужно сложить. их сумма это всегда 
вещественное число. если a=a(t) то тогда первый векторввращается по часовой стрелке
при изменении t а второй враается против часовой стрелки. теперт вспомним
ряд фурье в форме:
f(t)=a0*0.5+summa [ 0.5*(a(n)-b(n))*e^(i*w1*t) + 0.5*(a(n)+ b(n))*e^(-i*w1*t) ]
так вот если мы присмотрися то то что стоит под суммой это вточности что 
я описал выше
z1*e^ia+z2*e^(-ia)  
где z2=сопряженное от z1

таким образом сумма двух векторов под суммой это вещественное число. длинна
этого вектора это длинна бОльшей диагонали паралеллограмма и она равна
D=sqrt[ |z1|^2+|z1|^2+2*|z1|^2*cos (2*(argz(a-i*b))) ] и вот эти вот диаогонали
под суммой и будут складвыаться в бесконечном ряду.

По сути под суммой складываются два сопряженных вектора z1 и z1(сопряженное)
кажды из которых повернут на доп угол (w1*t), тоесть физический смысл 
того что под суммой это сложение двух сопряженных векторов но они еще чуть чуть
развернуты на дополнительный дельта угол за счет экспонент, по факту после доворота
оба вектора  по отношению друг к другу остаются сопряженными. так что по по факту 
мы изначально имели два сопряженных вектора и после домножения на эксопненты имеем
два сопряженных ветора. которые надо сложить. вот такой физ смысла того что под суммой стоит. тоесть вот теперь то что под суммой из непонятного месива формул
стало понятным. его физ смысла как это выяглядит. 

Далее.
рассмторим 
z=e^ia
где 
a=a(t)=k*t, k-константа
тогда
z=e^i*k*t
пусть k>0 тогда если мы будем сроить вектор z и менять время то вектор z это будет
единичный вектор который вращается по окружности против часовой стрелки 
с круговой частотой относительно времени k.
если же k<0 то все тоже самое только вектор вращается против часовой стрелки.
пусть n=|k| тогда n=-k тогда
z=e^i*k*t=e^i*(-n)*t=cos (-n*t)+i*sin (-n*t)
что я не могу понять это то что они пишут что у вещественых фукций небыавет
отрицательной круговой частоты. что за бред. коэфицицент что стоит при t это формально угловая частота. так что w=-n, где n>0 тоесть мы имеем отрицательную угловую частоту у вещственной функции. посольку w=d(phi)\dt то знак показывает
то что угол со увеличением времени он падает а нерастет. ну и что. что тут такого.
то что производная отриццательрная в этом нет никакого чуда. поэтому  янепонимаю
почему эти придурки пишут что у вещественый фуннкций нет отрицательной угловой частоты. есть она. а что тогда делать с периодом ? ну я думаю что T=2*pi/|w|
поэтому и V=1\T будет положительный даже если w<0 ну и что. да. 

далее.
итак еще раз посмтрим на полученный вид ряда фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

как на практиеке может выглядеть этот ряд:
f(t)= 0.5 + 1*e^(i*2*t+3) +1*e^(-i*2*t-3)...
или
f(t)= 0.5 + e^(i*2t+3) +1*e^(-i*2t-3)...
график АЧХ будет выглядеть:
в  точке w=-2 аплитуда A=1
в  точке w=0 аплитуда A=0.5
в  точке w=2 аплитуда A=1
график ФЧХ будет выглядеть:
в  точке w=-2 фаза phi=-3 рад
в  точке w=0 аплитуда phi=0 рад
в  точке w=2 аплитуда phi=3 рад

Прикольно то что мы бы хотели изобразить нащи экспонеты в графическом виде 
в форме вектров. но проблема в том что время меняется поэтому както конкретно
нарисовать вектора в этом случае невозможно . нам нужно избавится от времени 
в том плане что бы графики независиели от времени. поэтому мы вместо векторов
изображаем на графиках константы с точки зрения времени . тоесть амплитуду и фазу.
как бы врем неменялось ампдитуда и начальная фаза остаются теми же самыми.

хочу подчеркнуть что c(n) у нас всегда вэтой формуле вещественый.это важно отметить
мы имеем сложение кучи векторов. каждый вектор если мы будем его 
рисовать на плоскости компл то он будет вращаться при имзенениии времени t.
угловая частотв вращения вектора будет w1*n. в завимиости от знака он вращается
против либо по часовой стрелке. если мы хотим в некоторый фиксированный момент времени t0 построить вектор на компл плокости то мы должны взять n оно определяет
какой вектор мы хотим строить. и для этого вектора определить его длинну тоесть c(n)
и его угол поворота то есть n*w1*t0+phi(n), посколльку вот это мы знаем n*w1*t0
то нам надо только узнать  phi(n). таким образом для каждого вектора который 
характеризуется n мы должны вычислить\узнать\выяснить c(n),phi(n)
поскольлку  n = -inf..+inf это значит что у нас n<0 есть и n>0 есть. так что
график c(n) и phi(n) будет иметь точки и слева от нуля по оси X и справа. 
графие будет дискретный так n   у нас дискретные. каждая n характериузует
собой значения c(n) и phi(n) для очередного вектора. если знаем n,c(n),phi(n) 
то знаем как построить очередной вектор под суммой. До этого моменты мы фиксировали время t0 но меняли вектора.щас наоборот зафикисруем n но рассмотрим вектор у которого t как переменная тогда наш вектор

c(n) * e^(i(n*w1*t+phi(n))) = с * e^(i*n*w1*t+phi)
где c,phi,w1 константы. а t переменная.  
данный вектор в момоент времени t=0 имеет начальный угол повопрторта (начальная фаза) phi. он вращается (меняет угол)  вокруг начала координат при имзеннеии времени t с уголвой скорость n*w1 по часовой либо против часовй в зависиомти от знака  n. это значит что угол вектора как функция от времени является перидической 
функцией для данного вектора. тоесть если угол это q то q=q(t)=q(t+T) посколльку
T завиит у вектора от угловой частоты а угловая частота вектора это n*w1 
то имеет смысла откладывать графики не в виде c=c(n), phi=phi(n) а в 
виде c=c(n*w1), phi=phi(n*w1) это нам дает то что для каждого n (тоесть для каждого вектора) мы знаем его амплитуду c , мы знаем его начальную фазу phi и знаем 
с какой периодичностью (как быстро ) он вращается по времени (тоесть изменение его угла по времени ) вокруг начала координат(другими словами мы знаем период по времени для данного вектора тоесть через сколько время он совершает полный оборот ну или другими словами сколко оборотов  в секуду он совершает). а что нам это дает?
вот возьмем конкретный вектор:
n=100
w1=1
c=10
phi=0
что тогда мы из этого понимаем:
амплитуда у него 10.
в момент времени t=0 его фаза (угол поворота) =0+0=0 тоесть он лежит на оси X,
фазу знаем угол знаем - значит мы уже его сможем помстроить на компл плоскости, окей
построили. отлично. это нам и надо было. в плане его угловой частоты w=n*w1=1*100
значит этот вектор за секунду поворачиватеся 100=2*pi*V, V~30 раз. вектор за секунду
поворачиватся 30 раз. мы это узнали потому что на графике мы откладывали не просто n а n*w1. тоесть мы сразу из графика видим что у вектора n*w1=100 и сразу из графика понимаем что этот вектор вращается  30 раз в сеунду. если бы мы на графике откладывали по гор оси просто n то чтобы понять как часто вращаетс вектор характеризуемый числом n нам бы надо было лезть смотреть как выялядит ряд находить там w1 и считать. а так нам сразу это видно из графика. 
Итак еще раз у нас есть ряд фуурье в компл виде. предсталвяет собой сумму. под суммой стоит элемент с порядковым номером n. по факту это вектор на компл плоскости. у этого вектора фаза угол это функция от времени а апитуда по времеи постоянная. поэтому если мы будем рисовать этот вектор на компл плоскости
и менять время то он будет вращаться. поскольку он вращается то через какое то время он вернется в исходное положение. тоесть его угол это перидоическая функция или  с другой стороны это значит что он за единицу времени сделает сколько то кругов. поэтому нам для каждого вектора удобно иметь следущую таблицу парметров которая независит от t:
длинна вектора = c
начальная фаза =phi
частота вращения вокруг начала координат = n*w1

зная n,c,phi,w1 из таблицы мы всегда можем построить вектор на компл плоскости 
в для любого моммента времени t, зная n и w1 мы знаем как часто вектор вращается вокруг начала координат.  таблицу для n,c,phi,w1 удобней всего записать в форме
двух графиков :
c=c(n*w1)
phi=phi(n*w1)

Итак параметр n*w1 нам дает инфо какая угловая частота вектора. а зная его угловую частоту ( а мы также знаем что она от времени независит) мы знаем как часто он вращается в секунду. именно для того чттбы можно было из графика определить угловую частоту для вектора n мы на оси X откладываем не n а n*w1. Окей с видом графиков 
разобрались. зачем там n*w1 тоже разобрались.

Разберемся  еще вот с чем - вот у нас есть два вектора s(n,t) из этой суммы.
в чем их разница ? в чем разница вклада одного вектора s(n1,t) по сравнению с вкладом
другого вектора s(n2,t) в конечный вид графика f(t)

положим что w1=1. тогда w=1*n=n 
тогда рассмотрим два вектора

s1=s(10,t) = s1 имеет w=10
s2=s(1000,t) = s2 имеет w=1000

в чем их разница в плане вклада в вид f(t) графика. 
положим для простоты что у нас под суммой не бесконечное множество векторов а всего два. это значит что финальный вектор тот который и будет (f(t),0) он будет скалдываться всего из векторной суммы двух векторов s1+s2. совершенно очевидно что 
в завиимости от момента времени данные два вектора будут друг относииелно друга
иметь какойто угол. а это значит что в завимости от времени суммарный вектор будет 
по длинне от |c1-c2| до |c1+c2|. где c1,c2 это амплитуды s1,s2.
пусть c1=100, c2=1 тогда суммарный вектор по длинне будет меняться от 99 до 101.
( да мы при этом помним что на самом деле под суммой не два а туча векторов и то что они там на пары разбиваются и это дает то что суммарный вектор будет лежать на оси X но это щас все неважно). так вот в чем разница между s1 и s2 в плане их влияния на суммарный вектор s3 тот который нам и дает (f(t),0).  возьмем время t0
отложим вектор s1, отложим\построим вектор s2 и найдем их векторную сумму s3=s1+s2
теперь немного сдвинем время  t0+dt,  мы увидим что за время dt вектор s1 сместится на плоскости слабо потому что у него w маленькая. а вектор s2 сместится на очень большой угол потому что у него w очень большая. получим новый s1' и s2' 
построим новый s3'=s1'+s2' так вот вознкикает вопрос какой из данных векторов s1 и s2 внес бОльший вклад в изменений амплитуды вектора s3? ответ конечно s2 потому что он меняет свое простанственное положение намного более резко чем s1. а нам суммарный s3 вектор его длинна очень как раз зависит от простсранстевенного положения векторов s1, s2 относиельно друг друга. ну опять же мы помним что что 
под сумммой стоит не два вектора а туча и то что в конечном итоге их вертикальные 
компоненты дадут ноль при векторном сложении и останутся только горизонтальные компоненты таким образом на f(t) влияет горизонтальная проекция всех векторов их сумма поэтому чем сильнее за вермя dt вектор помено свое пространственное положениетем сильнее у него поменлась его горизонталная проекция и тем сильнее этот вектор влияет на изменнеие конечной суммы всех проекций. в итоге я бы сказал так ч
что чем меньше частота у вектора тем его амплитуда на отрезке времени играет роль как бы базово несущей в форму графика f(t) а чем выше частота вектора тем его амплитуда играет основную роль в изменение формы f(t).  скажем 
если вектор имеет маленькую частоту то он на отрезке времени [t0,t+dt] будет 
давать вклад в f(t) скажем как число 5 которое почти неменяется. а вектор
который высокочастоный он будет на этом участке по 1000 раз менять эту пятерку на величину 5+[-1,+1]. тоесть он будет придавать волнистость этой пятерке. 
пока на этом пауза.

Немного отодйем в сторону:
амплитудная модуляция. 
по определению что такое амлплитудная модуляция. Это когда у нас есть исходный сигнал который нужно передаь по радио. Исходны сигнал это голос. 
Что мы делаем - радио волна имеет частоту намного больше чем голосовая волна. Щас
 я обьясню. Мы берем микрофон и колебание мембраны в микрофоне формирует в проводах от микрофона колебания напряжения в контуре микрофона с той же частотой что и колебаия воздуха от голоса. Эти колебания это типа 100Герц-20,000 Герц.
 Далее в чем проблема отослать  в эфир радиоволну частотой скажем 10,000 Герц. 
 Проблема следущая - проблема в длинне волны.
 То есть Если у нас частота V=10,000 герц. То период T=1/10,000 секунд. А длинна волны это растояние которое пробегает воолна за периол. значит 
 lambda=c*T=3*10^8 * 10^(-4)=3*10^4 метров = 30км. 
 30 км пролетает волна за период. это ее длинна. длиннна радиоволны. так вот
 известно что размер антенны должен быть равен половине длинны волны. значит надл
 ставить антенну размером 15км. Поэтому передать голос на тойже частоте радиволны
 нереально. (прикольно что по проводам коротким без проблем передавать элекртрическую вполну волны блядь длинны при этом. Тоесть через провод длтнной 1метро можно спокойно передать волну длинной 30км). Поэтому электросигнал 
 в проводе от микрофона непередают на тех же частотах которые имеет сигнал от голоса в проводах микрофона. Вместо этого берут радивоолну у которой частота 
 услоно говоря в милллионы раз больше и передают через нее. Так вот что такое по 
 опредеению амплитудная модуляция. Если у нас есть исходный сигнал  U1 то мы его 
 используем как амплитуду на частоте радиволны. тоесть.
 wr- частота радиволны. Тогда амплитудно смодулировыннй сигнал это 

 U2(t)=U1(t)*cos(wr*t)
При этом мы помним что что энергия из батарейки радиостанции тратится на образование
апмлитуды. так вот в этом случае видно что вся энергия тратися искоючительно на 
передачу именно полезной информации. так вот эти долбоебы они делают не так . Они делают по другому. Они делают вот так

U2(t)=cos(wr*t)+U1(t)*cos(wr*t)

при этом получается что батарейка радиостанации тратит энергию на образование 
амплитуды так называемого несущего сигнала. и на образование аплитуды уже полезного сигнала. Захуя так делать я вобще непонимаю. Преобразуем формулу:

U2(t)=[1+U1(t)]*cos(wr*t)

Тоесть видно что к нашей полезной аплитуде которая перадеает информцию добавлятся
некая ебануто беспооезная константа несущего синнала. нахуя? она просто выжирает доп энегию из батарейки радисотавннции а ничего полезного в себе ненесет.

Единственное что я могу прдположить почему так ебануто делат потому что чисто физически на уровне микросхем дешевле генерировать волну именно вторым способом
не вплане энергозатрат а в каких то других электротехнических планах в том числе
например в том плане что на приемнике техника которая будет декодировать сигнал 
она будет стоить дешевле.Я только так этот ебанизм могу обьяснить. 




- Так - тут целая огромная куча вопросов вылезла:
Если мы берем звуковые волны которые за речь отвечают то непонятно зачем 
динамик который излучает должен быть каких то там опредееленных геометрических
размеров я вообще нихуя не пойму. Предпожоим у нас есть точечное тело. Мы его дергаем по закону y(t)=10*cos (2*pi*1*t) Это точечное тело ударяет окружающий воздух
. Воздух считаем некими упругими шариками поэтому вот это смещение оно смещает 
соседа а тот своего соседа  и у нас вот этот вот удар полетел по воздуху. фронт удара фронт волны полетел в стороны со скоростью звука. и данный удар долетает 
до уха и отклоняет перепонку ну или точку в ухе на такое же смещение грубо говоря
наша ушная перепонка начинает колебаться ровно по такому же закону. 
тоесть у нас есть источик звука некаая точка которая колбелется по закону

y(t)=10*cos(2*pi*1*t)

и у нас с некоторым отставанием ровно по тому же закону колбелется точка в ухе

q(t)=10*cos(2*pi*1*(t+phi0)

phi0-смещение фазы из за того что удар от источника звука смещение точки 
немгновенно попадает в ухо а через некоторое время обусловленное временем за которое воздух передает возмущение от источника в ухо. 
как бы получается что у нас есть два грузика колеблящихся на пружинке .
один грузик это исчоник звука а второй это ухо. воздух играет роль передатчика.

Это мы рассмотрели передачу волны 1Гц. 
Речь это суперпозиция кучи волна от 20Гц до 20Кгц.
Что значит суперпозиция на практие с точки зрения двигающегося грузика. Этовсего навсего значит что закон смещение грузика от времени y(t)более сложный чем 
y(t)=10*cos(2*pi*1*t)

он будет выглядеть как ряд фурье:
y(t)=summa ( a(n)*cos(w(n)*t+phi(n) ) )

по факту на практие это просто точка которая дергается вдоль линии в пространстве
по какомуто сложному закону y(t)

так вот что я нихуя непойму где здесь требования на размер излучателя?
Если есть точка которая дергается вдоль линии с частотой 20Гц то она должна излучать
звук частотой 20Гц тоесть бас.  я непонимаю почему это неможет быть точка а должна
быть мембрана некоторой площади? что за нахуй?

Что еще реально ебануто и поразительно. Вот есть два вариант волны.
Если дует сильный ветер то как я понимаю он выдувает некое углубление в воде
за углублением получается возвышенност холм ровно также как если взять лопату
воткнуть ее в землю и начать толкать лопату вперед и получается что ветер
он как бы берет верхний кусок воды и пытается эти частицы вытолкнуть туда вперед далье и эти частицы реально передвигаются вдоль горизнтальной плоскости как бутто их гарпуном зацерили или плугом и тащат вперед. тоесть реально верхний слой воды
под дуновением ветра он двигается как автомобиль по дороге. и мы видим волну которая
двигается. совершенно другая волна если кинуть камень в воду. нам кажется что частицы верхнего слоя воды как бутто стартуют от камня и потом их тащит по воде
наружу. но это полная хуйня это совсем нетак. происходит совсем другое. происходит как если бы вода была простыней и какотой бежит мужик под простыней и там где 
он бежит он эту простыну вверх задирает. таким образом в каждой плоскости воды частица она по горизонту никуда несдивигается она только поднимается вверх на какоето время и пото обратно возвращается вниз. волна же бежит потому что под водой бежит невидимый мужик и постоянно над собой поднимает простыни. 

Я посмотрел как выглядит генератор волн в басейне. Это просто один из торцов басейна
который просто толкает воду - чем чаще он толкает тем более частотная волна чем реже
тем менее частотная. так что там вообще остуствует понятие какого то размера 
генератора волн. размером генератора посто служим ширина басейна и его высота. 
собственно может быть любая ширина и высота этого басейна. 

Если у нас скорость передачи фронта это c а период это T то получается что 
расстояние между пиками на воде это lambda=c*T.
тоесть вот мы ладонб удаоили по воде и пик фронт побежал по воде. если скорость
его бега равна C то за время t он убежит от нас на расстояние C*t.
если мы ударяем по воде ладонью каждые T секунд то через время T тот пик убежит 
от нас на расстояние c*T=lambda= длинна волны.  Когда смотришь на график y(t)=cos(t)
то интуитивно кажется что Период T на графике это длинна волны ибо мы же видим что
T это расстояние между пиками на графике. Но это опять же полная хуйня , интуитиция опять наебала. Ибо T это время измеряемое  в секундах а если у нас график y=cos x 
то расстояние в PI это даже не время в секундах это период в радианах. Ммммм. тоесть я что хочу сказать формально период это если у нас ест график функции 
y=y(x) где x люая величина это может быть время в секундах, это может быть градусы в радианах это могут быть метры. Нам похуй. ТАк вот перид это наименьшая хрень такая что x(t)=x(t+T) так что период может измеряться в любых величинах. в радианах , секундах, метрах. все зависит от размерности х. Если мы нарисуем график профиля 
воды в басейне в момент времени t0 тоесть y=y(x,t0) то то что мы называем длинна волны это есть период на это графике и он измеряется в метрах. это пиздец это просто поразительно. 

ДАлее. походу  я что еще понял.
как у человека генерируется звук. в горле стоят связки голосовые. сквозь них продуваем мы воздух. когда он сковзь них протелает то они автоматом начинают вибрировать. И полученный на выходе звук идет как несущая. Как я понимаю 
в ряду фурье это будут первые гармоники которые задают некую несущую низких частот.
а уже ртом языком мы добавляем высокочастотные гармоники. хотя по идее все выглядит 
на оборот - связки дают высоко частотные гармоники а язык с челюстями добавляет низкочастотные. вобщем хуй знает как речь формируется. в вики я прочел что связки 
дают 60-300Гц колебания. тогда вопрос а чем тогда мы генерируем высокие частоты ? ответ ничем.
получается что мы связками делаем несущую. тоесть сразу за горлом в рот летит 
моно звук (ну или смесь низкочастотных гармонических колебаний) на слух это выглядит так что из горла летит некий монтонный звук. вопрос что дальше
происходит во рту с точки зрения частоы, аплитуды, фазы.
Я пока вот как все это вижу. Из горла вылетает низкочастотный звук - этот звук
будет выглядеть как первые гармоники если вылетевший звук раскладывать в ряд фурье.
Ксати про раскладку в ряд фурье - во первых наша речь состоит из букв - например слово "мама" это четыре отдельных буквы мы произносим. каждая буква это некий короткий импульс по времени. а далее вот что - чем более короткий по времени импульс и чем более у него сложная форма фронта сигнала тем более широкий
спектральный ряд гармоник нужен чтобы через ряд фурье его сформировать. как я понимаю гласные звуки имеет более короткий спектр гармоник. а вот согласные
уже имеют широкий спектр гармоник. что же делает рот когда звук в него влетел из горла когда мы хотим сказать согласную букву - я думаю что рот берет условно говоря гармоническое колебание из горла и рот уродует у него форму. и чем более мы изуродовали форму колебания тем больше высокочастотных гармоник нужно в ряду фурье подключить чтобы такую форму сформировать. насколько я понимаю рот это делает таким образом что он гасит резко амплитуду колебания получаются резки обрывы фронта.
так чтобы такой рваный сложный фронт организовать из гармоник то нужно дохера гармоник высшего порядка. я к чему - как можно формировать звук - можно его формировать из неких генераторов звука разной частоты -то есть можно работать со стороны генераторов колебаний. а можно работать из конца тоеть можно брать уже колеблящийся звук во рту и гасить его тогда график f(t) будет адово уродоваться что
эквивалентно тому как если бы во рту стояла куча высокочастотных генераторов. но их там нет. Тость еще раз - на форму звуковой волны f(t) можно влиять с двух концов - 
один конец можно формировать график за счет запуска кучи осцилляторов которые будут складываться в некий суммарный f(t) так работает оркестр из кучи муз инстрементов.
а можно еще действтовать с другой стороны - можно брать уже готовое колебания воздуха и .... я полагаю что может быть у нас буквы это  с точки зрения сигнала то что очень по разному амплитуда меняется у сигнала. тоесть мое пока предположение что из горла вылетает примерно говоря гармонический моносигнал там одной частоты
или узкой полосы низких частот. а буква нашим мозгом воспринимается как то что 
мы своим ртом умудряемся сильно менять амплитуду. более точно ее как то хитрожопо
гасить ртом. и вот эта рваная амплитуда воспринимается как буква. тоесть я к тому 
что рот неменяет часту он меняем очень сильно амплитуду путе того что он ее 
видимо поглощает и всякую там доп микроформу на нее навешивает. 
хм.. еще вот такую идею прочитал - что из голосовых связок идет именно некий спектр частот. так вот измение обьема рта и прочие фокусы язяка и шевеления челюсти приводит к тому что рот становится типа резонатором определнных частот. 
но вот что еще интересно  - звук "к" или "п" можно сформировать вообще с выключенными связками голосовыми тоесть нет несущей частоты. тоестьт это похоже на удар молотком по столу тоесть процесс образования звука похож на то что мы имеем во рту плотно сомкнутую щель. мы в нее нагнетаем воздух ( связи вообще неучаствуют)
и потом мы эту щель резко откравыаем , воздух резко вырывается и возникает некий звук. точно так работает образоывание звуков "к" "п" "т" 
звук "щ" это тоже продувание воздуха сквозь щель во рту. 

звук "б" это тот же звук "п" но при подключении несущей частоты связок.
тоесть по мне вобщем похоже звук получается вот как - для гласных звуков которые простенькие звук образуется за счет связок то ест тупо гармоническое колебание на узком диапазоне из горла. а согласные звуки по мне образуются путем того что
нагнетается воздух во рту в закрытый рот а потом он резко открывается газ резко 
начинает вылетать и получается некий звук но он с колебанием из связок никак не связан это условно говоря звуки которые можно получать путем ударом молотком или карандашом по столу. или если у нас есть банка дихлофоса мы нажали на кнопку и газ вылетает и дает звук. вот по мне согласные звуки в основном там во рту образуются тоесть без участия несущих частот их глотки. глотка нужна только для гласных звуков в основном.  я бы сказал что гласные звуки из глотки это некая внатуре несущая которая никакой информации ненесет. а только как бы сообщает мозгу что началась передача звуковой информации. и можно заметить что кога мы произносим согласную то 
наща глотка прекращает работать и раздается согласный звук как удар молотком например. таким образом гласные это как старт стоп биты. это как фоновая музыка 
на радио когда ктото говорит. согласные это что то обычно либо свистящее либо шипящее либо типа как маленький ударчик молотком. тоесть все эти звуки они с глоткой неимеют никакой связи. буква "р" например глотка вобще выключена это чисто колебание языка во рту от того что летит воздух и язык начинает дергаться. чтобы понять физику образования звука согласного надо понять как формиурется звук при ударе пальцем по доске. вот та же самая физика.  я как раз неисключаю что при ударе молотком по столу возникают как раз таки высок. вобщем звук можно формировать нетолько через колебания струны как это делается в горле. но и совершенно подругому
через удар по предмету. 

Возращаемся обратно: 
вопрос - какой смысл имеют  амплиутдно частотный график и  фазово частотный график. Это график сугубо завязанный на ряд фурье. то есть мы на этих графиках 
расписываем параметры членов внутри суммы. Тоесть по этим графикам мы можем
восстановить вид членов внутри суммы ряда фурье. На этих графиках мы изображаем
эти самые члены под суммой. Поэтому эти графики имеют применение только в связке с рядом фурье. Эти графики неимеют никакого самостоятельного применения. Еще раз на них изоаржаются члены суммы формулы ряда фурье. Когда мы смотрим на графикии 
то по ним мы можем восстановить вид этих членов под суммой. итак смотрим на графиик
и и их смысл такой что мы на них видим как выглядят члены под суммой из ряда фурье.
Эти графики предназначены чтобы по ним можно было восстановить вид ряда фурье. 
Другого самотсотелльного какогото применнеия эти графиик неимеют. Что нужно у себя спросить когда смотрим на эти графиик - вопрос такой что я вижу? ответ - если я вижу
какую то частоту и амплитуду для нее то я понимаю что соответвующий член под суммой в ряду фурье имеет такую частоту и такую амплитуду. В исходном сигнале f(t) ни таких частот ни таких амплитуд нет. Эти графиики это графическое представление
математической формулы суммы в ряду фурье. Я хочу подчернкуть что есть графики 
котоыре имеют самостоятельное значение например график ускорения тела. 
графиик АХЧ и ФЧХ неимеют такого самостоятельного значения. Они жестко привязаны 
к некоей мат формуле - а именно сумме в ряду фурье. и показывают члены стоящие под суммой не вивде формулы а в виде картинок. Это важно понять хотя это вроде как 
очевиедно. Если мы видим некую картинку на которой изобаржены частоты и ампитуды
мы сразу дожоны понять что это показаны члены ряда фурье и ничего другого этот 
график неможет значить. Повторять как заклинание  - на  графике  я вижу члены под 
суммой в формуле для ряда фурье, больше ничего другого на графике я невижу.

Ксати - также надо утоянчть к какой формуле про ряд фурье нарисоываны графики.
к форме вещественной или к комплексной форме. Это тоже важно.
Итак еще раз видим АЧХ и ФЧХ спрашиваем себя что он нам показывает? показывает 
ли он нам исходндую функцию f(t). ответ нет. он нам показывает ряд фурье. точнее
его члены под суммой. в графическом виде. зачем нам это? чтобы из графика 
восстанрвить вид этих членов в виде формулы.




Еще важный момент:
видим запись e^(i*2*pi*f0*t)
вопрос что мы видим?
ответ - мы видим функцию от компллекснного числа. 
что такое функция комплксного числа. это такая хрень которая берет 
компл число и ставит ему в соотвествие другое комплексное число.
поэтому функция это всегда тоже комплексное
число на выходе. значит это некий вектор на комплексной плоскости. 
значит это некая точка на комплексной плоскости.
значит мы видим другими словами вот такое:
(x,y)
x+i*y
r*e^ia
r**cos phi+i*sin phi)

это все одно и тоже.

конкретно это фуннкция берет  компл число причем не произволтное а только такое что 
z=0+i*a и ставит ему в соотвесвтие число cos a+i*sin a
которое является всегда вектором единичной
длинны которые лежит на окружности.
тоесть если аргумент имеет длинну a то ему ставится в соответвие единичный вектор
который поверут на угол a (угол a считается задан в радианах а не в градусах).

в полярных коодринататах e^ia=(1,a)
в декаровых коодинаатах e^ia=(cos a, sin a)

графически это вектор единичной длинны который повернут на угол a.
если меняем a в аргументе то меняется угол поворота функции.

теперь представим что a это функция от времени тоесть
a=2*pi*f0*t.
тут все константы кроме t.

найдем производную da/dt=2*pi*f0
по опредеднию da/dt это угловая скорость w
значит при даннном законе имзенени угла по времени у нас как видно
w=2*pi*f0
как видно она ненавзисит от врмени . згачит w у нас константа. значит скорость 
поворота угла постоянна. Если w это угловая частота то по опредеелению 
w/(2*pi) это линейная чатсота.  тогда мы видим что w/(2*pi)=f0
значит f0 оказывается имеет смысл линной частоты. Исходя из того что ясказал
если мы видим вот такую хрень

e^(i*2*pi*f0*t)

то мы теперь плнимаем что это значит. 
а имеено: это функция от клмпл аргумента.
это комл число.
это вектор.
это единичный вектор на компл плоскости. повернутый на угол 2*pi*f0*t  (угол задан в радианах) в момент времени t. f0 это линейная частота. при изменений времени 
t у нас вектор будет поворачиваться. 

потом они гвооря а давайте рассмотрим такух хрень:
0.5* e^(i*2*pi*f0*t) + 0.5* e^(-i*2*pi*f0*t)

что мы можем про это сказать:
слева у нас векторв компл плокости длинной 0.5 его угол поворота зависит от t.
вращается он по окружности против часовой стрелки. относительно t он вращается 
с уголовой скорость 2*pi*f0. если время t0 то текущий угол наклона у него это 
2*pi*f0*t в радианах.
второе слагаемое тоже самое только вектор наклонен под углом -2*pi*f0*t
по факту это два сопряженных компл числа. и они как видно складываются. 
складывать их можно по правилу векторов. 

Ксати. вместо графиков АЧХ и ФЧХ можно рисовать табличку с тремя строками
n:
c(n):
phi(n):


Главный вопрос который остался это что за хрень отрицательные
частоты. смотрим на ряд фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)


под суммой стоит куча векторов.
рассмотрим один из них ( при некотором фискированном n):

c(n) * e^(i(n*w1*t+phi(n)))


с точки зрения времени t все остальное внутри это константы тоесть


k1 * e^(i(k2*t+k3))


это вектор длинной k1 который наклонен к оси под углом phi=k2*t+k3 в радианах
поскольку t у нас меняется то угол наклона меняется. 
при изменний времени t вектор будет вращасять по окружности с угловой сокрстью k2.
откуда я это взял. угловая скорсть по опредеднию это d(phi)\dt.
в нашем случае d(phi)\dt=k2.
значит w=k2. 
видим что w независит от рвемнеи. значит угловая скорость константа значит векто
вращается равномено. значит мы помним что k2=n*w1.
w1 - это константа которую мы сами выбираем при создании ряда фурье. 
n - это номер члена под суммой. 
сумма у нас идет для n от минус бесконечности до плюс бесконечности.
значит унас будут n>0 и n<0 значит мы будем иметь w>0 и w<0. 
тут то и появляются отрицательные частоты. и если честно я невижу абсолютно нахуй с ними никаких проблем. знак всего навсего означает в какую сторону вращается вектор.
если w>0 то против часовой если w<0 то по часовой. ну и хуйле тут удивительного ?
вот забудем щас про коплексность. 
возьмем точку на декартойо плоскости. начнем ее вращать по закону
phi=-2*t

теперь вычислим угловую скорстлсть :
d(phi)\dt=-2 
получаем w=-2 
ну и хуйле тут удивительного? еслт w отрицальено это просто означает что тело
врщается по часовой стрелке ну и что?

возьмем функцию обычную:

y=sin (-pi*t)
w=-pi

я считаю что ошиибка состоит в том что 
w!=(2*pi)/T
я считаю что 
|w|=(2*pi)/T=2*pi*V,
V=|w|/(2*pi)

тогда у нас небудет отрицательных периодов и отрицательных частот при отрицательых
w. вот и все.

проверяем. 
T=(2*pi)/|w|=2*pi/pi=2
проверяем

sin(-pi*t)?=sin(-pi*(t+2))=sin (-pi*t-2*pi)=sin(-pi*t)
sin(-pi*t)=sin(-pi*t)
вроде совпало.
значит формула верна что 

T=(2*pi)/|w|
V=|w|/(2*pi)

и нет нахуй никаких отрицатлеьных линейных частот и периоодов.
Отрицательная круговая частота может быть и это абсолютно нормально.


На этом тему волн и компл переменного пока заканчиваю.

Оставшиеся вопросы:
- почему колонки для басов
дооожны иметь  большой диаметр? откуда это берется ?

- понять почему антенна должны быть половина длинны радиволны.
- понять какого размера доожны быть связки голосовые. почему колонки для басов
имеют большой диаметр.
- подумать что такое скорость волны?
- додумать этот момент. w<0 а что с T и V=1\T ?



- на графика мы откладываем не n а n*w1 потому что именно n*w1 это угловая 
частота каждой гармоники. тоесть не n не w1 не являются частотой гармоник
именно n*w1 является частотой очередной гармоники. поэтому на графиках именно n*w1
- ряд фурье в вещественной форме помимо класического вида:
f(t)=a(0)*0.5+summa(a(n)cos(t*w1*n)+b(n)sin(t*w1*n))
имеет и другой более компактный вид:
f(t)=a(0)*0.5+summa ( c(n)*cos(w1*t+phi(n) )
где n=1..inf

я почти уверен что эту формулу можно свернуть в:
f(t)=summa ( c(n)*cos(w1*t+phi(n) )
где n=0..inf

таким образом мне совершенно непонятно чем эта формула хуже чем 
комплккссный вид ряда фурье:
f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]
n=-inf..+inf

дело в том что на данный момент то что я нашел насчет того что нахера 
вводить комлпексный вид то это было сказано что в комлпксном виде ряд выглядит
более компактно. так вот получается что это чушь. в веественном виде он 
тоже выглядит также. ровно также. 



- как устроены часы. почему много шестеренок?
также - какая аналогия с амплитудами у векторов и шестернями в часах , что у них общего

- так  теперь надо понять откуда берутся отрицательные частоты
что такое частота. это величина обратная к периоду. что такое период. 
это период колебаний. определяется для периодического колебательного 
сигнала. 
это такое минимальное положительное число что f(x)=f(x+T). а частота
это frequency=1\T. Физический смысл частоты это сколько колебаний в секунду
имеет сигнал.
исходя из этого непонятно как вообще может быть отрицательная частота?


- напоминаю что на данный момент мы можем через ряд фурье выражать фнукции
которые периодические. щас мы поймем а как же прдсетставлять через ряд фурье
непериодичекую функцию.?
- так ну фурье это хорошо но нам надо понять на счет тех столбиков из статьи?

- замечу мы пока что рассматриваем функцию периодическую относительно x. 
если x это время то сигнал периодический по времени. 
что делать с сигналом неприодическим пока неясно.




- frequency domain representation - амплитудно частотная характеристика.
состоит из набора частот и амплутуд этих частот.
идея такая что сигнал можно разложить в ряд. 


- baseband
что это такое в вики дается очень мутное определение.
у одного индуса я нашел такое определение - A baseband signal is one which has spectrum from 0 Hz to some fc Hz where fc is the cut off frequency (necessary to have spectrum around 0Hz to qualify for baseband signals).

но сразу упомяну такую штуку - Ethernet protocol, which transfers data using the original baseband signal. In fact, the word "BASE" in "10BASE-T," "100BASE-T," and "1000BASE-T" Ethernet refers to baseband transmission. These Ethernet protocols do not require signal modulation. 

Еще полезняшка по этой теме:
So, summing up, the base band signals modulated with higher frequencies have the following benefits:
More number of baseband signals can be accommodated over a single wire or channel
Signals can be transmitted over long distances without amplifier.
You can also encrypt the communication for privacy and security
Costs much less.
Еще полезнящка: телефонный проводной телефон это пример baseband communication.

baseband сигнал через кабель можно пускать а через радиоканал нет потому что 
антенна на передачу радиосигнала должна быть размером примерно с половину волны.
для волны 20KHz размер волны измеряется километрами. а именно вот формула f = 𝜈 / λ
где f это частота в герцах, 𝜈 это скорость волны. для радиоволны 𝜈 = 3*10^8 m\s
подставляем λ = (3*10^8 m\s)/(20 000 Hz)= 15 000m , тоесть 15км. значит антенна
должна быть 7.5км что нереально для размера антенны.

также полезняшка low pass filter это такой фильтр который пропускает чеерз себя
только частоты ниже какойто. high pass filer это фильтр который пропускает частоты
выше заданной а band pass filter это фильтр который пропускает частоты между f1 и f2.

чем выше частота радиосигнала тем меньше антенна на передачу и прием и тем меньше 
по размеру вся требуха в приемнике. 



- coaxial cable означает кабедь в котором провода лежат на одной линии потому что 
axi это типа ось, а coaxi на одной оси. тоесть токи текут в обоих направлениях
вдоль одной оси.



- типа очен полезная книга по связи:
Modern digital and analog communication by B.P. Lathi


- attenuation. что это . а это attenuation (also known as signal loss).


- infrared излучение. что там за фишки

- фундаментальный вопрос ( я там ниже рассмотрел что такое цифровой и аналоговый сигнал).
так вот вопрос как генерируется цифровой сигнал. так как в природе обычно все величины аналоговые (кроме квантового мира где есть четко дифференцированные фискированные квантовые состояния) а будем даже более конкретными в электрическом мире мире напряжения и силы тока
мы неможем сгененировать скажем первую секунду 100% U=5V а потом вторую секунду U=0V.
окей если 0V мы еще можем сделать то мы неможем обеспечить 100% 5V он будет все равно меняться
и плавать в течение этой секунды. тоесть он все равно будет аналоговый так как же генерируется
цифровой сигнал?


- balanced cable

- непонятно вот у нас есть несколько разьемов на плате (пусть будет 4) под SATA провод. каждый разьем ведет к одному диску. вопрос сколько контроллеров SATA на плате четыре или один.
далее было сказано что SATA AHCI имеет одну очередь на 32 запроса. вопрос это 
на все четыре диска или на каждый диск своя очередь.
- надо переходить от SATA к AHCI SATA  а потом к NVME 
- NVME очереди (65 535 очередей с глубиной 65 535 команд)


- analogues signal vs digital signal
analogues означает аналогичный,  чтото аналогичное чемто другому.
что такое сигнал - согласно вики это некая величина чегонибудь (масса, напряжение, величина светового потока,величина тока, положение рук регулировщика) которая для наблюдателя (кудаж без него) меняется во времени и\или в пространстве. итак именно некая величина+время+наблюдатель образуют сигнал.
если честно я чтото непредставляю
что за сигнал который неменяется во времени но меняется в пространстве. если величина
меняется во времени тут вопросов нет что это сигнал. например фонарь был темный стал светлый. 
это сигнал. летающая тарелка ее координата она поменялась во времени это сигнал. светофор
погас зеленый и в другом месте пронстранства загорелся красный - поменялся и во времени в 
пространстве тоже сигнал. непонимаю какой пример сигнала (некоторая величина) которая неменяется во времени но меняется в пространсве. все таки по мне это величина меняющаяся
во времени. 
насколко я понимаю когдамы говорим про сигнал - значит должен быть генератор сигнала
его источник, должен быть носитель сигнала , должна быть некая величина которая переносится в этом носителе, и должен быть приемник сигнала и должен быть наблюдатель сигнала.
переходим к электрическим сигналам. величина наблюдаемая тут это либо ток 
либо напряжение. аналоговый сигнал( как я понял ) что это означает - вот мы начали мерять сигнал и снимаем с прибора величину с некоторым шагом например снимаем виличину напряжения каждую секунду. меряли 10 секунд. получили 10 величин. потом мы повторяем сигнал и меряем
его опять 10 секунд но уже каждые пол секунды получим 20 величин. потом мы повтоярем сигнал
и меряем его каждую треть секунды получили 30 величина. далее мы возьмем полученные 10 величин и выкинем из них все повторяющиеся получим множества A. потом возьмем 20 величин и выкинем из них повторяющиеся получим множество B, 
потом возьмем 30 величин и выкинем повтоярющиеся получим множество C, так вот
если сигнал аналоговый то множество C будет больше чем множество B а оно бльше чем множество A.
и чем чаще мы будем снимать сигнал и выкидываь из полученного множества дубли тем суммарное
множество будет больше ( вштуках) чем прердыдущее множество которое было получено путем фиксации сигнала при большем интервале времени. хотя максимум и минимум сигнала конечные
но на отрезке времени количество велиичин сигнала бесконечно какой бы маленький шаг 
фиксации величины мы бы ни взяли. на него непохож цифровой сигнал - если мы возьмем отрезок времени то мы можем найти такой минимальный шаг фиксации величин сигнала что при уменьшении времени снятия сигнала (другими словами при увечличении частоты фиксации сигнала) мы будем получать одно и тоже множество величина сигнала (после того как мы выкинем из него дубликаты.)
пример аналогового сигнала и цифрого:
положим что вольты в проводе меняются по закону U=t
будем фиксировать вольты первые 2 секунды.
вначале инетрвал фиксации 1 секунда.
U(1)=1
U(2)=2

дублей нету. значит наше множество это {1,2}

далее фикируем каждые 0.5 секунды
U(0.5)=0.5
U(1)=1
U(1.5)=1.5
U(2)=2
дублей нету. конечное множество {0.5, 1, 1.5, 2}
фиксируем сигнал каждые 0.1с множствео будет {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, ... 2}
так вот видно что чем чаще мы снимаем сигнал тем множстве значений растет растет и растет 
и при любой частоте снятия сигнала мы можем взять еще более частое снятие сигнала и множество
будет еще больше. это аналоговый сигнал. множество значений увеличивается до бесконечности
при уменьшении времени снятия сигнала ( даже после выкидывания дублей . хотя в данном случае дублей просто нет).
цифровой сигнал.
положим что сигнал вот по такому закону генерируется
U=1(при t=[0,1) )
U=0(при t=[1,2] )

снимаем сигнал каждые 0.5с
U(0.5)=1
U(1)=0
U(1.5)=0
U(2)=0

выкидываем дубли(это важно выкидывать дубли) получем множество {1,0}

снимаем сигнал каждые 0.25с
U(0.25)=1
U(0.5)=1
U(0.75)=1
U(1)=0
U(1.25)=0
U(1.5)=0
U(1.75)=0
U(2)=0

выкидываем дубли получаем ножество {1,0}

так вот что более часто сигнал снимать нет смысла. какой бы мы ни взяли шаг еще меьше
после выкидыаний дублей мы получим все тоже множество {1,0} 
это и показыает нам что сигнал цифровой.

еще раз аналоговый сигнал - чем чаще мы снимаем его значение (на одном и том же конечном
промежутке времени) и потом выкидываем дубли то полученное множество будет все расти и расти
и расти оно будет бесконечно при уменьшении шага снятия величины.
цифровой сигнал - его множество значений не растет бесконечно (после выкидываений дублей) при уменьшении шага фиксации величины сигнала. начиная с определенного шага  фиксации величины сигнала S0 полученное множество значений (после выыкидываний дублей) будет одно и тоже для любого сколь угодно малого S1<S0.
Обычно в природе величины(сигналы) являются аналоговыми. например температура 
у тела имеет аналоговый характер. цифровой же сигнал обычно искусственным образом создается генерируется людьми. 
амплитудная модуляция я узнал как она выглядит через математику. если 
низкоачастотный сигнал это y1=f(t) и если у нас высокочастотный носитель это y2=A*Sin(bt)
то амплитудная модуляция выглядит как y3=f(t)*Sin(bt).



- а ethernet 100 он тоже исплзует differential signaling ?
из того что я прочитал нет. эзернет НЕиспользует differential signaling.
у них в одну сторону используется пара проводов и в другую сторогу использутеся пара проводов.
итак еще раз в SATA в одну сторону исползуется 4 провода.  а в ethenet 100 в одну сторону
исползуется 2 провода. кручение кабеля испольуется для того чтобы защититться от влияния
одного кабеля на другой. оно тем больше чем длиннее кабели а скрутка это убирает. от внешнего 
влияния из вне скртка никак не помогает. получается что  SATA каелбелть он короткий скажем 1метр. на такой длинне влияние одного провода на другой видимо еще маленькое ( потому что я читал что чем длинее провода тем они в в коце друг на другна сильнее влиятют) а более 
влияет помехи снаружи. поэтому satat не скручивают зато используют differential signaling.
ethernet же прводо длинной 100метров поэтому влияне одного проводоника на другой уже
на такой длинне накапливается и провод крутят . скорость у satat 600MB\s а у эзернет
10MB\s и поэтому видимо у него неиспользуют differential signaling тоеть небоятться внешних 
помех.  ятолько в одной сттье нащел что 10Gb ethernet использует differential signaling
 

- амплитудная модуляция. это когда унас есть какойто высокочастотоный сигнал (радиоволна)
и мы меняем у него амплитуду так что если мы соединим линией все его амплитудные точки
то получим волну низкочастотную котору мы и хотели закодировать через этот выскочастотоный сигнал ( картирнка https://en.wikipedia.org/wiki/File:Amfm3-en-de.gif)
еще  я непонял вот что. если мы возьмем наш низкочастоный сигнал разложим его в ряд фурье
тоесть представим наш сигнал как сумму синусоид с индивидуальными амплитудами то мы получим некоторый спектр. это понятно. ксатии вобще то ряд фурье он для периодических функций
а если непериодическая? ну как я понял тогда берем кусок функции и потом ее как то там продолжаем и вот для нее строится ряд фурье и он на заданном куске совпадает с с функцией.
так вот ( как я понял) если мы возьмем наш промодулированный сигнал (тоесть  выскочастотный несущий синал который по амплитуде промудирован низкочастостным сигналом ) возьмем кусок
этого сигнала ибо он же нерегулярный поэтому как я понял для всего сигнала построить 
ряд фурье вот так единой формулой нельзя. поэтому мы берем кусок сигнала потом хитро его там
продолжаем (как написано в вики) и строим для него ряд фурье который на заданном куске 
совпадает с сигналом так вот утверждается что промудулироваронный сигнал в виде ряда фурье
будет иметь спектр в два раза шире чем спектр исходного низкочастоного сигнала на данном куске. хотя чисто интуитивно мне непонятно то что промодулированный сигнал имеет в себе 
всего одну частоту (ту самую высокочастотную) изменилась всего лишь амплиутда то там то здесь
непонятно как это может влиять на появление новых частот в интеграел фурье. но тем не менее надо двигать дальше.
далее такая хрень еще встречается как baseband bandwidth и passband bandwidth.
и тут я тоже замучался разбираться и неразобрался. 




- почему у коаксиала гораздо выше и экранирование и полоса пропускания чем у витой
пары а скорость передачи данных цифровых гораздо ниже чем у витой пары. я вот думал 
что коаксимал неиспользуют только потмоу что его дороже исзготавливать и он гораздо
хуже монтировать. (типа его нельзя гнуть и так далее). так что если забыть что его метр
стоит дороже и что его монтировать недоубно мне непонятно почему его цифровая скорость 
ниже чем у витой пары что за фигня. 
- baseband bandwidth vs passband bandwidth  vs broadband
я всегда часто думал что эти фразы больше как маркетинговый булшит а оказывается
они имеют типа рельный смысл. 

- alexanderson alternator
- электронные лампы. как работают в чем фишка
- как максимально простыми методами можно генерировать радио волны
- катушка румкорфа она юзается при генерации искры. как она работает
- как передается сигнал в проводах через меняющийся ток или меняющееся напряжение
и как это ловят на том конце
- в чем фишка коаксиального кабеля почему он такой и для чего
- в чем фишка витой пары почему она такая и для чего
- сигнал передается через дергание Вольтов? и это породжает дергающийся ток или что?
- почему в sata разьеме 7 пинов а в проводе всего 4 провода
- рассссмотрим SATA диск ( с AHCI и без) и путь от него байта до цпу










главный вопрос как найти число очередей на своем nvme диске.
как на sysfs посмотреть число hardware queues о которых выше написано
get-feature:0x7 (Number of Queues), Current value:0x0f00g0f
	Number of IO Completion Queues Allocated (NCQA): 16
	Number of IO Submission Queues Allocated (NSQA): 16
что такое AHCI как он отличается от sata
когда идет ahci то как там идет связь между диском и цпу
nvme это через какой интерфейс и какую шину оно втыкается. как идет связь
между цпу и диском.

нашел в pdf от сигейта(у кингстона тоже самое написано) что AHCI(контроллер наверно) имеет только один command queue с глубиной depth на 32 команды. а nvme (диск наверно контроллера то нет ) может иметь до 65 535 command queue с глубиной depth команд до 65 535.
в чем разница между AHCI и NVME интерфейсом (из той же брошюры сигейта) - когда у нас

==================================================================================



- как выглядит прочесть 1 байт из файла на ассемблере? куда ядро сует ответ с диска процессу ?

- block devices vs character devices?
разница вроде бы в том что из character device можно читать и писать но тупо напрямую в 
/dev/name но нельзя задать какойто поиск какойто сдвиг. либо читаешь то что есть 
либо пишешь туда напрямую. а у block  device можно задать некий offset и данные будут
записаны\считаны изнутри кишок где то там начиная с offset.
еще такая добавка что якобы FreeBSD doesn’t use block devices at all.


- bfq, linux i\o scheduler ?

- 165.pdf стр 8 ?


- $ dd if=/dev/zero of=/dev/null bs=514 count=1
вот инеерсено заупускаю я эту команду. диск у нас 512байт сектор.
на стороне юезоер спейса будет написано что была только запись а вот на стороне
ядра и доно быьт и чтение и запись чего конечно небудет видно из юзер спейса через iostat
но должно быть в итоге идно по перфомансу конечному на диске.
как бы проверить?

- 
$ lsblk -o  NAME,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC  /dev/nvme0n1
NAME       1MENT MIN-IO OPT-IO 12КБSEC
запускается ядро и сисколл берет наши 12КБ данных и смотрит а какой размер блока на фс. 
ага 4КБ. он режет наши 12КБ на три куска
nvme0n1             0    512    512     512    
 512
├─nvme0n1p1         0    512    512     512     512
└─nvme0n1p2         0    512    512     512     512



- фс блоки. это внутренняя кухня  внутри драйвера фс или наружу тоже както 
это выставляется для внешних потребителей? тоесть непонятно нам то внешнему потребителю 
какая разница на эти блоки нахер это нам дает? мы хотим записать считать файл и только то.
какое нам дело до этих блоков ?


- https://www.opennet.ru/base/sys/info_diag_tools.txt.html







