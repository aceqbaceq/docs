ext4

| как определить версию FS

# blkid -o value -s TYPE ./5G-ext3.txt 
ext3

# file -Ls ./5G-ext3.txt 
./5G-ext3.txt: Linux rev 1.0 ext3 filesystem data, UUID=75949a85-488f-49dc-a73b-bde95da9ae0e (large files)

просто охуеынй способ


|
https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout

создадим файл и сделаем из него блочное устройство

первый шаг
$ dd if=/dev/zero of=./01.block bs=2k count=100000


на следущем шаге используем losetup
прогармма позвяолет взять файл и организовать к нему доступ как к блочному утсройству
через /dev/loopX файл.

поговорим о флагах команды ибо они описаны дебильно.




losetup без флагов или с флагом -a показывает инфо о том какие /dev/looop заняты
щас и на какие файлы они привязаны. 


$ sudo losetup
NAME        SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE
/dev/loop9          0      0         1  1 /var/lib/snapd/snaps/gnome-characters_741.snap
/dev/loop7          0      0         0  0 /root/block-devices/01.block

siezelimit и offset это хрень какая то потому что они задают то что: 
sizelimit ограничивает доступ внутри файла до какогто предела. зачем это надо?
если мы завели файл то хотим там лазить везде внутри
offset задает что доступ начинается не с нулевого байта файла а с какогото 
отступа. тоже нахер это надо?
RO - рид онли доступ. ну понятяно

вобщем в итоге нас интерусет только NAME и BACK-FILE
$ sudo losetup
NAME         RO BACK-FILE
/dev/loop9   1 /var/lib/snapd/snaps/gnome-characters_741.snap
/dev/loop7   0  0 /root/block-devices/01.block

итак losetup позволяет иметь доступ к бекенд файлу как блочному устройству через
/dev/loop9 спецфайл. тоесть имели файл получили блочное устройство в котором файл 
это бекенд.






ключ -f (--find) = описание у ключа полностью дебильное. если других ключей в добавок к ключу -f неиспользуется в команде то ключ -f показывает свободный /dev/loopX на данный момент

$ losetup  -f
/dev/loop15

но более того (и об этом несказано в мануале) это то что если свободного loop нет то в ответ
на эту команду система создает +1 новый свободный loop. правда и тут не без ососбенностей
это произодйет олько если мы запусккаем losetup -f с правами рута. показываю:

$ losetup -f
losetup: cannot find an unused loop device: Permission denied
$ sudo losetup -f
/dev/loop28

тоесть в системе небыло свободных loop. я заустил losetup -f без прав рута и он об этом 
просто написал. а вот когда запустил под рутом то система в ответ создала новый свобдрный loop

у этого ключа дебильная расшифровка я продолжаю об этом,  по своему смыслу этот ключ совсем не "find" как написано в мануале а более похож по смыслу на "loop file"
потому что когда мы создаем связь между бекенд файлом и /dev/loopX то ключ -f используется
для того чтобы указать какой /dev/loopX мы хотим использовать. так что -f обозначает /dev/loopX файл. если мы неукажем конкетный /dev/loopX файл то система автоматом подставит первый свободный. тоесть

$ sudo losetup -f  ~/01.img   
эта команда найдет свободный /dev/loopX и привяжет его к файлу 01.img

хотя можно как я сказал указать /dev/loopX руками
$ sudo losetup -f /dev/loop12  ~/01.img

таким образом видно что -f указывает имя /dev/loop файла. так что какой нахер find ? -f по своему смыслу это никакой нахер не --find а  file по своему смыслу.

еще раз скажу что указывать руками -f /dev/loop12 нет смысла. во первых потому что этот /dev/loop12 уже 
должен быть в системе более того  надо проверять свободен ли он.

также еще важный момент скажу. если у нас в системе исчерапались все доступные loop устройства
то при вызове losetup -f с правами рута система создаст +1 свободный loop. отсюда ответ 
на вопрос откуда беретуся новые свободные loop-ы.
пример я щас заюзаю последний свободный loop27: 

$ losetup -f
/dev/loop27

создаем бекенд файл 
$ touch ~/block-devices/01.img

привязываем 01.img к блочному loop27
$ sudo losetup /home/vasya/block-devices/01.img  -f /dev/loop27

таикм образом теперь доступ к 01.img можно делать как к блочному устройству чеерез /dev/loop27
В данном случае я указал loop руками но можно было сделать и по другому без ручного указания:

$ sudo losetup /home/vasya/block-devices/01.img  -f

далее я проверяю появился ли новый loop.
$ losetup -f
losetup: cannot find an unused loop device: Permission denied

как видно непоявился.


но  далее я запуска команду  под рутом и система создает новый!
$ sudo losetup -f
/dev/loop28

таким обоазом я резюмирую что ключ -f дает и делает.
1. он показывает какой свободный loop есть (при запуске не под рутом)
$ losetup -f
/dev/loop28

2. если свободного loop нет но мы запустили под рутом то система создаст новый свободный 
loop
$ sudo losetup -f
/dev/loop28


3. указввает loop который использовать при создании связи между бекенд файлом и loop файлом
	$ sudo losetup /home/vasya/block-devices/01.img  -f /dev/loop27
если после -f неуказан loop то система сама найдет свободный и подставит.  я даже
поозреваю что если свободного неокажется то система создаст новый loop автоматом
тоесть вот такая команда тоже работает
	$ sudo losetup /home/vasya/block-devices/01.img  -f
причем я считаю что это и есть более практически удобная команда


Итак создаем блочное устройство из файла 01.block
# losetup --sector-size 4k /home/vasya/block-devices/01.block -f

проверяем:
$ losetup | grep -E "OFFSET|01.block"
NAME         RO BACK-FILE                                          DIO LOG-SEC
/dev/loop28   0 /home/vasya/block-devices/01.block                   0    4096


LOG-SEC это logical sector size это сектор 4к который мы выставили ранее.
что такое logical sector и чем он отличается от physical sector мы поговорим ниже.



создаем файловую систему ext4 с дефолтовыми настройками:

$ sudo mkfs.ext4 /dev/loop28
mke2fs 1.44.1 (24-Mar-2018)
Discarding device blocks: done                            
Creating filesystem with 50000 4k blocks and 50048 inodes
Filesystem UUID: d70e8847-c2a9-4ca5-9d03-a42fb6c454a9
Superblock backups stored on blocks: 
	32768

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done


теперь начинаем изучать ext4.

теперь посморим что про фс напишет утилита:
$ sudo tune2fs -l /dev/loop28
tune2fs 1.44.1 (24-Mar-2018)
Filesystem volume name:   <none>
Last mounted on:          <not available>
Filesystem UUID:          d70e8847-c2a9-4ca5-9d03-a42fb6c454a9
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Filesystem flags:         signed_directory_hash 
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              50048
Block count:              50000
Reserved block count:     2500
Free blocks:              44278
Free inodes:              50037
First block:              0
Block size:               4096
Fragment size:            4096
Group descriptor size:    64
Reserved GDT blocks:      24
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         25024
Inode blocks per group:   782
Flex block group size:    16
Filesystem created:       Thu Jul 14 20:17:44 2022
Last mount time:          n/a
Last write time:          Thu Jul 14 20:17:44 2022
Mount count:              0
Maximum mount count:      -1
Last checked:             Thu Jul 14 20:17:44 2022
Check interval:           0 (<none>)
Lifetime writes:          16 MB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:	          128
Journal inode:            8
Default directory hash:   half_md4
Directory Hash Seed:      785a7c2b-e142-432b-b4d9-7ae4b3399411
Journal backup:           inode blocks
Checksum type:            crc32c
Checksum:                 0x97a880be

пока двигаем дальше.

ФС ее драйвер делит диск на blocks. это не сектора диска нет. это логическая структура 
с точки зрения драйвера фс. насколко я понимаю это минимальная стркуткура которую можно
прочитать и записать на фс через драйвер. но я пока непонимаю это внутренняя кухня
только для драйвера фс или эти блоки они както наружу выставляются для сторонних внешних
потребителей. пока я этого не понимаю. пока двигаем дальше.

блоки обьединяются в block group. ее размер опредеяется через 
	sb.s_blocks_per_group
либо как 
	8 * block_size_in_bytes

All fields in ext4 are written to disk in little-endian order. HOWEVER, all fields in jbd2 (the journal) are written to disk in big-endian order.

немного поговорим про рейды. что такое stripe size и chunk size.
у IBM нашел такое определение - A stripe, which can also be referred to as a redundancy unit, is the smallest amount of data that can be addressed. сокращаю их выражение до:
 A stripe is the smallest amount of data that can be addressed


что такое chunk size. важно отметить что этот термин
имеет смысл ТОЛЬКО ДЛЯ ОПРЕДЕЛЕННЫХ ТИПОВ RAID А НЕ ДЛЯ ВСЕХ ПОДРЯД.
из man mdadm я читаю:
 -c, --chunk=
              Specify  chunk  size of kilobytes.  The default when creating an array is 512KB.  To ensure compatibility with earlier versions, the default when building an array with no persistent metadata is 64KB.  This is only meaningful for RAID0, RAID4, RAID5, RAID6, and RAID10.
              RAID4, RAID5, RAID6, and RAID10 require the chunk size to be a power of 2.  In any case it must be a multiple of 4KB.
по своей сути chunk означает сколько байт будет записано на отдельный диск если мы на весь 
массив послали X KB данных за 1 IO. читаю у орейли - An array's chunk-size defines the smallest amount of data per write operation that should be written to each individual disk.



- о чем это ?
cat /sys/block/loop0/queue/physical_block_size 
cat /sys/block/loop0/queue/logical_block_size

во первых эти хрени это результат того что firmware диска доакладывает драйверу.
тоесть это незадается из линукса это типа как бы свойства самой железки 
которые она сообщает о себе. якобы hdparm может просить firmware железки чтобы
она поменяла свой logical_block_size и иногда она меняет.

тееперь о значении этих хреней
physical_block_size = походу это типа каким блоками информация сохраняется
	внутри железки по факту.

logical_block_size = это какими минимальными блоками железка принимает от драйвера информацию на запись.(вроде бы оттуда же LBA - logical block addressing произошло название). тоесть 
я так понимаю что вот для драйвера железка сообщает что у нее есть 1 000 000 LBA блоков размером по 512 байт. соотвесвтенно драйвер может подать на запись команду вида - запиши 
ка в 15-ый блок LBA 512 байт такого то вида. тоесть идея в чем что для драйвера диск 
выглядит как коробка у которой два параметра - число блоков (LBA) и размер блока. 
и драйвер может либо читать из блока либо писать в блок. соотвественно можно либо 
целиком прочитать блок либо целиком записать в блок. частичная операция диском не поддерживатеся поэтому драйверу надо знать размер блока обязательно. 
 иттогда операция чтения со стороны драйвера выглядит как:
 READ блок 15 размер 512 байт
 WRITE блок 17 размер 512 байт.

 если же ядро хочет записать 1 байт то ему нужно с помощью драйвера 
 1. считать блок LBA 12 размером 512 байт с помозью драйвера
 2. поменять один байт в RAM в этом куске 512байтном 
 3. записать обартно 512 байт (модифицированных ) с помозью драйвера в LBA 12


 так вот 512 байт это logical_block_size.

 еще раз драйверу кгда он хочет считать инфо с диска ему нужно передать какой номер блока
 драйвер хочет чтобы диск считал. я незнаю передает ли драйвер в диск размер сектора
 или просто драйвер вслпую получает байты от диска пока он незактнется  и тогда важно
 чтобы размер буфера чтения оказался ни больше ни меньше. но я думаю что точно что при записи на диск нужно указать номер блока и нужно чтобы размер данных которые мы пихаем на диск 
 был в точности совпадал с размером сектора потому что если мы попробуем сунуть в сектор инфомрации болше чем сектор по размеру то диск выдаст ошибку. вот почеу важен размер сектора.
 и вот этот вот размер сектора который мы получаем при чтении сдиска указав его номер 
 и размер который можно запихать в диск указав номер блока как раз равен logical_block_size
 который диск сообзает драйверу. тоесть если мы заказли чтение с диска lBA блока 12 то 
 мы можем смоело ожидаь что диск на передаст ровно logical_block_size байт.
 а если мы хотим запистьа на диск в блок 12 LBA то диск ждет от нас logical_block_size байт.
 вот каков физический смысл logical_block_size.

 а смысл physical_block_size состоит в том что таков размер блока записи на диске внутри 
 по факту. он может неосовпата с logical_block_size. к чему это приводит. если унас 
 physcal_block_sie=4K а logical_block_size=512байт то когда мы пишем на диск 512 байт
 то по факту диск внутри себя считывает 4к модифицирует его и записывает обратно модифицироыванный 4к.  что конечно же ведет к сумашедшему потере скорости. 
 логично предполжить что если мы заказали запись восьми блоков LBA по 512 байт то 
 диск понимает что весь его физичесмы кий блок 4к нужно  переписать поэтому читать уже его ненужно его можно сразу перезапиывать. и потери скрорости нет вообще!
 поэтмоу что наам дает знание  physical_block_size. поменять мы его неомжем но мы можем
 на файловой системе сделать размер блока равынй или кратный physical_block_size.
 что это дает - мы в программе в линуксе даем команду 

  write(1, const void *buf, 12КБ);

запускается ядро и сисколл берет наши 12КБ данных и передает драйверу ФС. 
драйвер ФС разбивает нащи 12Кб на куски по 4КБ(размер блока на ФС) насколько я пнинимаю
далее дайрвер фс делает вот что. он переводит каждый кусок 4КБ в блоки LBA и передает
драйвер диска типа такой команды - мол блоки LBA c 1 по 8 (суммарно 4КБ) надо записать кучкой
далее мол блоки с 9 по 16(4КБ) тоже надо записать кучкой. драйвер диска его специифика то что
он знает какие конктенотно сигналы надо послать в диск чтобы передать ему что  LBA 1-8 надо
записать кучкой. это приводит  к тому что диск видит что надо записать 8 втртуальных блоков LBA фактически которые укладываются в один физический блок и диск понимаает что это перепывает
весь физ блок целиком и он это делает и сокрость нетеряется. вместо того чтобы прочитать блок 
поменять на наем первый байт записать обратно . потом считать заново поменять второй баайт
записать заноово. имеем  непотерю скоорости. 

в чем разница если бы на ФС были бы блоки по 512байт ( тоесть мы есл бы незнали что физ блок 4К а думали что он 512байт). было бы то что мы дали команду write(1, const void *buf, 12КБ);
она долетела до ФС. она взяла и 12КБ разделила по 512байтовым LBA кусочкам. и далее фс
будет требовать от драйвера диска чтобы он просто записал LBA блоки в любом порядке.
и  в этом то жопа потому что тогда как раз может получатьс ситцаия на диске что он 
читает 4к сектор. меняет в нем один или два байта. пишет обратно. потому опять читает
меняет один два байта и пишет обратно. огромная потеря сокрости.  вслучае е когда  у нас на фс 4Кб блоки это приводит к тому что у нас на ываходе тоже куча полукиолбтаный LBA блоков но
фм будет требовать от дравера диска чтобы группа LBA от 1 по 8 была записана в одном порыве.
или друг за другом. и значит диск небует читать 4к блок а сразу будет его переписывать. в этом 
и есть смысл нам знать о внутрнеейней размере физ диска на диске и на оснвое этого задавать 
размер блока на фс. иначе я не вижу смысла в блоках ФС.

насколько я понимаю про страйп на рейде. это минимальная логическая структура размером которой
он читает и пишет. если она скажем 64КБ это значит что если мы задаем запись 1КБ то он прочитает с жиска кусок 64Кб изменит его и потом запишет обратно. тоест идет чтение+запись 
вмест записи. 


- у нас рейд и страйп size =64k значит ли этом что при запитсь 1к у нас всегда будет
вначале чтние и только потом запись. то есть бещеное падание скоокрсти.

на сайте редхата читаю: 
	Storage vendors can also supply "I/O hints" about a device's preferred
minimum unit for random I/O ('minimum_io_size') and streaming I/O
('optimal_io_size').  For example, these hints may correspond to a RAID
device's chunk size and stripe size respectively.


что такое direct i\o = Direct I/O is a feature of the file system whereby file reads and writes go directly from the applications to the storage device, bypassing the operating system read and write caches. Direct I/O is used only by applications (such as databases) that manage their own caches.
An application invokes direct I/O by opening a file with the O_DIRECT flag.
дествииельно читаю man 2 open:
O_DIRECT (since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will degrade performance, but it is useful in special situations, such  as  when  applica‐
              tions  do  their own caching.  File I/O is done directly to/from user-space buffers.  The O_DIRECT flag on its own makes an effort to transfer data synchronously, but does
              not give the guarantees of the O_SYNC flag that data and necessary metadata are transferred.  To guarantee synchronous I/O, O_SYNC must be used in  addition  to  O_DIRECT.
              See NOTES below for further discussion.
еще таеаы добавка идет:
When a file is opened with O_DIRECT, or when a GFS direct I/O attribute is attached to a file, all I/O operations must be done in block-size multiples of 512 bytes. The memory being read from or written to must also be 512-byte aligned.

кстати посмотреть список scsi устрйоств:
$ apt-get install lsscsi

пакет чтобы посылать команы на scsi устройства:
$ sudo apt-get -y install sg3-utils

здесь нащел https://people.redhat.com/msnitzer/docs/io-limits.txt :
Linux filesystems are not allowed to be
formatted to use a block size that is smaller than the underlying
storage's 'logical_block_size'.

в доке от ibm нашел:
logical_block_size Smallest possible unit in bytes that is addressable in a request.
physical_block_size Smallest unit in bytes handled without read-modify-write.

тоесть logical_block_device это с каким размером сектора диск себя презентует в user space.
как он видится для юзер программ.

physuica_block_size это его размер сектора изнутри внутри. если совать в диск данные размером
меньше чем physuica_block_size то диску придется вначале считать physuica_block_size изменить его а потом только заисать обратно. что ведет к беешеной перфоманс деградации.

Тут я напоролся на тему linux kernel i\o scheduler:
Simply sending out requests to the block devices in the order that the kernel issues them, as soon as it issues them, results in awful performance. One of the slowest operations in a modern computer is disk seeks. Each seekpositioning the hard disk's head at the location of a specific blocktakes many milliseconds. Minimizing seeks is absolutely crucial to the system's performance.

Therefore, the kernel does not issue block I/O requests to the disk in the order they are received or as soon as they are received. Instead, it performs operations called merging and sorting to greatly improve the performance of the system as a whole[2]. The subsystem of the kernel that performs these operations is called the I/O scheduler.

io scheduler называт еще elevator.
потмоу что его задача ( по крайней мере для шппненльных дисков) в тмо чтобы 
головка шла ровно и нескакала постоянно.

на праатике есть дефолтовый шедулер в системе. как его поменять.
надо в grub примненмть опцию elevator

/boot/grub/menu.lst :

title CentOS (2.6.18-128.4.1.el5)
root (hd0,0)
kernel /vmlinuz-2.6.18-128.4.1.el5 ro root=/dev/VolGroup00/LogVol00 elevator=noop
initrd /initrd-2.6.18-128.4.1.el5.img

это по деолфту выставит для всех блочных устройств io шедулер = noop

провеоить прям щас какой шедулер работает на кокнктеном блочном устрйостве можно так:
$ cat /sys/block/nvme0n1/queue/scheduler 
[none] mq-deadline 
 

его на лету можно переклчить. через 
echo mq-deadline > /sys/block/disk/queue/scheduler

если хотим для оотдельного диска кастомный и чтобы после перегазуруки осталось 
перманентно то надо заюзать правила для udev.

vmware пишет что для линуксов втруталок надо бы ставить none шедулер потому что 
в конечном итоге каждля виртуалка незнает о других вируалках поэтому надо оставит 
задачу реэрейнждмента порядка счтывания LBA блоков гипервизору. тоесть надо на виртуалках
проставить шедулер = noop

раньше до появления nvme дисков да и вообще в эру шпиндельных дисков
были такие шедулеры:
noop
Completely Fair Queuing (cfq)
Anticipatory
Deadline

потом появился еще bfq

основная  цель оптимизации у шедулеров была уменьшить прыганье головки на шпинеделях.
а когда пошли ssd то это все отпало. 
на данный момент для nvme считается самым отличным шедуелером это none шедулер.  тоесть
в устроство подается вобщмто просто поток запросов а вся оптиамизация переклдывадется на 
сам nvme диск.

- закончил на том что есть старый io шедулер. у него там разные есть элеавторы.
но их общая фигня в том что в конечном итоге реквесты от всех процессов к блочному устройству
как я понял обрабатываться в рамках одной очереди. и эта одна очередь обрабабтыватеся
всего одиним ядром цпу. поэтому скорость одного ядра цпу это ровно то место узкое
которое мещает выжмать иопсы. поэтому был придуман новый шедулер механизм. 
в котором во первых очередь разбивается на две части. в первой части находтся софт очереди
во вторйо части хард очереди. софт очередй много столько скольк ядер. в этих очередях
происходит перегруппирова запросов и так далее.  уаждого ядра есть своя софт очередь доя блочного устрйоства. тоеть если 10 ядер то для конкретногого блочного /dev/nvme у нас будет 10 софт очередей. если процесс сидит на ядре 1 и он на этом ядре вызывал read() и далее 
цпу перешел в режим ядра то этот реквест будет попмщен в софт очередь этого цпу. и ответ
от железкт придет именно на это цпу. окей получаетя запросы к /dev/sda от процессовна разных
цпу начали обрабаывться на разных цпу (распараллелились). эта вся хрень с очередями 
работает на уровне block layer в ядре. ина данном этапе мы никак не связаны с конкретикой
драйвера /dev/sda. вся мудота с группировой перемшиванием ркевестов в очереди идет именно
в софт очереди. я неочень понимаю как долго работает block layer по времени. пока я вижу это так. процесс на цпу запустил read() если еще тайм слайст незакончился то цпу переходит в режим 
ядра и запускает сисколл то выполняет код ядра с очередями. и в какойто момент происхоит
таймер интеррапт запускается процесс шедулер. и он выдавливает block layer код с цпу и запускае другой процесс. потом опять доходит очередь до этого проецесса и код ядра block layer наконец заканчивает там манипулиции с софт очередью и далее видимо первый с начала запрос 
из софт очереи передается в хард очередь если в ней нет места то там есть промежуточная 
хрень для храннеия. хард очередь это очереь в которой уже непроисходит никаких перестановок
запросов  в ней. она чисто я так понял FIFO. и из нее запросы уже передаются в драйвер /dev/sda
на исполнение. число хард очередей равно числу очередей которые поддеживает железка.
и тут мне непонятно то что какой цпу обратвает хард очередь конкретную. если софт очередл 
каждя четко привязана к кокнкретному цпу то как выбирается цпу для обработки для продивджения реквестов по хард очереди. ведь очереь это просто кусок памяти. а чтобы она работал нужен цпу
которй будет по ней двигать реквесты. вот это непооятно. а так запрос из хард очереди передается в low level драйвер /dev/sda и тот уже как то там конкретно пихает запрос в железку
все это время тайм слайс может закончится и шедулеор выдавить этот код с цпу. потом обратно 
засунет. а ответ в систему прилетает уже вот как - когда железка прочитала сектора то она
гененирует интеррапт и доставку от железки до ядра куска инфомрации уже идет по интерапту.через оарботчик интерапта. щас для меня все вынгляди так что если процесс 
однотредовый то скорость иопсов для него все равно зависит от скорости одного ядра цпу.
хотя конечно процесс шедулер может случайно перемещать процес между цпу и он успееет насовать
свои рекветы во всех софт очереди на всех цпу. тогда да мы неупелис в одно ядро. но 
по прежнему неонятнен вопрос какие цпу обслуживают хард очереди. 

двигаем дальше. я понял что при запросе на чтение\запись read(), write() можно исполовать
флаu O_DIRECT (называется Direct I\O операция). он дает то что мы говорим ядру что мы нехотим использовать page cache а мы 
хотим читать и писать сразу на железку.

вот картинка про i\o систему в ядре. = https://www.thomas-krenn.com/de/wikiDE/images/e/e0/Linux-storage-stack-diagram_v4.10.png

ищем там I\O scheduler и blmk.
I\O shceduler это старая версия i\o шедулера а blmk это новая.
на схеме мало что понятно но видно что у старого шедулера была одна штука hardware 
dispatch queue а у нового blmk их несколько. hardware dispatch queue это очередь 
запросов на чтение запиьс которая идет от block layer(общий абстрактный уровень работающий с очердями на запросы ) к драйверу кокретного блочного утсройства /dev/sda.
так вот эту очередь  hardware dispatch queue в итоге обслуживает некоторый кокретный цпу
так вот когда раньше она была одна ( персональная для кажого блочного устрйоства)
то как я понимаю поскоьку продивжением запросов по ней и передачей запросов из нее в 
драйвер блочного устройства занимался один цпу и поэтому скорость работы на блочном устройстве
упиралась в скорость одного ядра цпу (при этом непонятно а что сам драйвер блочного устройства
он что неупирался в ядро одного цпу?) а с новым blmk таких очередей hardware 
dispatch queue уже несколько (их число зависит от числа очередей поддерживаемых железкой)
и поэтому как бы теперь число iops которые мы снимаем с железки неупирается в скокрость одного
ядра цпу.(при этом непонятно а что сам драйвер блочного устройства
он что неупирался в ядро одного цпу?)
том кренн пишет - Blk-mq allows for over 15 million IOPS with high-performance flash devices (e.g. PCIe SSDs) on 8-socket servers
Вот еще картинка про blmq - https://www.thomas-krenn.com/en/wiki/File:Blkmq-two-level-Linux-block-layer-design.png

насколко я примерно понял запрос от проги read() поступает в ядро в vfs. 
она обращается  к драйверу конкретной File system оно делает обращение в block layer коду
а тот к драйверу конкртеного блочного устройства /dev/sda (ествственно это все внутри ядра
и там нет никакого /dev/sda ведь это точка входа к блочному утсройству для юзерских программ.)

тут я еще чтото хочу сказать. есть две проблемы. одна это собрать все запросы на чтение\запись 
от всех процессов перегруппироват их и сунуть в блочное устройство. большая работа и большая 
мудота  при этом в том чтобы все это правильно перегруппировать. 
вторая часть работы это обратно доставить к процессу данные которые прилетели наконец
от диска. это две разные проблемы. обратная доставка вроде проще. надо просто взять то
что поступило и сунуть в процесс. значит про первую про первую часть проблемы. как я понял 
со старым планировщиком было так что была одна софт очередь и одна хард очередь на весь комп ( для одного блочного устройства. у каждого блочного устройства своя инивиудальная 
софт+хард очередь. мы щас рассматриваем отдельное блочное устройство и проблему высокосростного доступа к нему). так вот если на пяти цпу крутится пять процессов и каджый из них щас хочет прочитать из одного /dev/sda то каждый из них переходит в режим ядра и пять экземпляров кусков ядра хотят получит доступ к одной и тойже стркутуре в памяти ядра софт очереди и хард очереди. эта структура защищена спинлоком то есть в однин момент времени 
только с одного цпу один кусок кода ядра может с ней рабоатть. незнаю насколко это проблема большая но это проблема. в новом планирщвике каждый код ядра на каждом цпу имеет свою индфивидуаьную софт очередь. ну хорошо. и есть несколько ( в зависимости сколько прддеживает железка /de/sda) хард очередей.это безусловно позволяет более бодро принимать от процессов
запросы IO к /dev/sda. ну хорошо. а драйвер /dev/sda он позвояляет запускаться в несколльких 
экземплярах чтобы бодро принимать увеличивешееся количество запросов с нескольких хард очередей? ведь как это походу работает по мне: процесс на цпу юзерский запускает read (/dev/sda) цпу переклюается в режим ядра. там код ядра пихает запрос в софт очередь ( тут проблем и пересечений с другими процессами и ядрами цпу нет). далее код ядра беррет чтото из софт очереди
и пытается впихнуть в хард очередь . и тут уже есть проелма так как число хард очередей может 
быьт меньше чем число цпу. тоесть там должен стоять спин лок. итак мы тут уже ждем. потом 
наконец мы получили доступ к хард очереди . пихнули туда запрос. далее как я понимаю мы запускаем уже драйвер /dev/sda и из хард очереди он забирает кусок и пихает на железку.
так вот в этот момент надругом цпу может быть ровно такая же ситуация и вопрос когда на первом
цпу запущен драйвер /dev/sda то на дургом цпу может ли быть запущена +1 копия драйвера 
/dev/sda или надо ждать?  если надо ждлат то тогда эта новая модель шедулера всего навсего
нам дала доп буфер в виде софт очередей ( по одному на цпу) и только то а в конечной точке
у нас попрежнему узкое место. непонятно. ну и опять же на старой модели шедулера. ну была у нас одна софт и хард очередь на весь комп ну и что. пока на одном цпу пихает запросы в очередь
на других цпу код ядра неможет этого сделать. типа он ждет ну и что. дело в том что 
даже если код ядра весело запихал на всех цпу запросы в очередь все равно юзерское приложение
спит пока неполучит ответ с диска. непонятно. непонятно также то что очереди конечно 
же предназначены чтобы двигать запросы от приложений к диску. а как доставляются ответы от диска к процессам ? совершенно понятно что когда диск нашел ответ  на запрос он запускает 
интеррапт. выывается интеррапт обработчик. он берет этот ответ от диска и тут вопрос
как обрботчик знает какие куски ответа к какому процессу надо доставить? это вобще непонятно.
также еще вот что непонятно. вот нащ интерапт хендлер забрал ответ от диска и сунул пока в
 память ядра и начал разбраться какому процессу какие байты сунуть. пока он это делает 
 может ли диск выставиь еще интеррапт чтобы его на другом цпу обработали или нет? если нет 
 то получается что ответы от диска завязаны на скости работы одного ядра!
 так что одни вопросы. ответов в инете нет. 
но так в целом они прям усираются о том что раньше мол была одна софт очередь и одна хард 
очередь а теперь их несколько и это мол чудо. мол это снимает ботлнек как бутто там других
ботлнеков нет в этой цепи от read() до запроса в диск.
так вот непонятно вот когда мы в iometer задавали скажем  число потоков в 10.
то ведь они же все равно все уходили в одну очередь на старом шедулере поэтому непонятно
как же эти потоки в юзерской программе трансформировались в потоки к диску ведь в диск
уходил все равно один поток который сумма просто напросто этих десяти потоков.
непонятно.
но они щас на что напирают мол раньше были шпиндели поэтому мол посылать на диск
следущий реквест когда он невернул ответ по текущему реквесту типа небыло смысла ( не знаю
неуверен в верности этого заявления) поэтому старый шедулер имел только один поток ведущий
в драйвер. а щас мол так как у нас ssd\nvme то они могу спокойно искать одновременно 
неоколько независимых реквестов.

очереди зовутся как software queues и hardware queues( синонимы hardware contexts queues\hardware dispatch queues).

далее я щас пытаюсь выяснить сколько hardware queues поддерживает мой текущий 
nvme диск.

$ sudo nvme smart-log  /dev/nvme0n1 
Smart Log for NVME device:nvme0n1 namespace-id:ffffffff
critical_warning                    : 0
temperature                         : 33 C
available_spare                     : 100%
available_spare_threshold           : 10%
percentage_used                     : 1%
data_units_read                     : 10 169 142
data_units_written                  : 14 999 997
host_read_commands                  : 134 639 775
host_write_commands                 : 340 324 085
controller_busy_time                : 399
power_cycles                        : 1 609
power_on_hours                      : 2 318
unsafe_shutdowns                    : 31
media_errors                        : 0
num_err_log_entries                 : 0
Warning Temperature Time            : 0
Critical Composite Temperature Time : 0
Thermal Management T1 Trans Count   : 0
Thermal Management T2 Trans Count   : 0
Thermal Management T1 Total Time    : 0
Thermal Management T2 Total Time    : 0

посмотреть какие nvme неймспейсы есть на диске (это не линукс неймпесейсы а чисто хрень nvme)
$ sudo nvme list-ns  /dev/nvme0n1 
[   0]:0x1

видим что есть один неймспейс.

а теперь более интересная хрень.
выяснить какой размер LBA сектора nvme диск экспортирует наружу в ядро:

$ sudo nvme id-ns  /dev/nvme0n1  -n 1 -H  | grep "LBA Format" | grep Metadata
LBA Format  0 : Metadata Size: 0   bytes - Data Size: 512 bytes - Relative Performance: 0x2 Good (in use)
LBA Format  1 : Metadata Size: 0   bytes - Data Size: 4096 bytes - Relative Performance: 0x1 Better 

отсюда видно что для линукса диск сообщает что у него как бы размер сектора LBA равен 512 байт.
но лучше бы нам ппреключить железку (правда при этом все данные сдохнут) чтобы она стала 
для внешнего мира как устрйоства с размером LBA сектора равным 4KB.
меньше будет запиливаться и больше будет перформанс.

также можно без ключа -n 1 чтобы получить эту инфо
$ sudo nvme id-ns  /dev/nvme0n1   -H  | grep "LBA Format" | grep Metadata

чтобы перкключить диск в режим LBA 4K надо его отформатировать
$ nvme format --lbaf=1 /dev/nvme0n1   
ключ --lbaf=1 его цифра 1 означает то что выше написано тоесть 
0 = LBA Format  0 = 512 байт
1 = LBA Format  1 = 4K 

==========================================================================
- далее я пытас выяснить сколько hardware queues поддерживает мой диск
$ sudo nvme get-feature /dev/nvme0n1 --feature-id=7 -H
get-feature:0x7 (Number of Queues), Current value:0x0f000f
	Number of IO Completion Queues Allocated (NCQA): 16
	Number of IO Submission Queues Allocated (NSQA): 16


pci vs pci-e vs sata vs ahci
что такое шина. шина это набор проводов, разьем и стандарт передачи по проводам.
шина имеет скорость. 
шина содеиняет чтото слева с чем то справа.

pci: это шина и разьем на матплате. одним концом на мат плате она представлена разьемом(куда мы втыкаем внешнее устройство контроллер чегото) другим концом шина уходит в южный мост например ICH9. шина многопроводковая тоесть паралельная. паралельность еще заключается и в том 
что все устройства все разьемы на плате в итоге разделяют одну шину. поэтому они все конкурируют и делят пропускную способность шины. для параеллельных шин обычно
указывают частоту. у pci это 33 Mhz , размерность шины 32 бита. скорость при этом 132МБ\с(33Mhz*4байта=132МБ\с). 
разьемов на плате можте быть несколько скажем пять но все эти разьемы сидят на общей шине
так что либо одна плата будет выжимать 133МБ\с а остальные ноль. Либо все пять будут делить 
133МБ\с.( а не так что каждый разьем будет иметь 133МБ\с). это был основной стандарт.
где то там в конце жизни pci была модификация 66MHZ и 64бита и она выдавала 532МБ\с.
(оно и логично в 2 раза боьше разрядность и в 2 раза болбше частота итого 133МБ\с *2 *2 = 532МБ\ч). итак если мы рассмотрим все же обычную шину PCI 33Mhz,32bit то скорость суммарная
на все устрйоства которые к ней поключены 132МБ\с, они все ее делят между собой.
32битная шина имеет 124 провода (62 по одну сторону от разьема и 62 по другую) в архитектуре. из них данные и адрес используется 64 провода(32 используются под сигнал а 32 для второго конца провода. условно говоря 32 провода это фаза и 32 провода это ноль).
тоесть 4 байта можно передать за раз.  поскольку под передачу данных используется 32 пары
проводов ( остальные под какито доп обеспечительные нужды) то это означает что 4 байта можно 
передавать либо в одну сторону либо в другую , либо туда либо обратно. поэтому шина pci она 
half-duplex. для того чтобы она была полностью дуплексная нужно было добавлять еще 32 пары проводов. для сравннеия ethernet 100. там 2 пары проводов тоест 4 штуки в итоге. по одной паре сигнал идет на отправку по второй на принятие. поэтому там полный дуплекс. зато за один раз можно передать только 1 бит. тоеть еще раз у pci у нее 32 пары проводов и все пары предназначены для отправки только в одну сторону либо туда либо обратно. а у ethernet 100 две пары прием одна строго для отправки а другая строго на прием.  так вот оказалось что 
когда у нас много пар используется для отправки в одну сторону то это типа очень плохо потому что по одной паре сигнал придет чуть позже по другой чуть раньше а поскольку мы дожны принять 
по всем парам в итоге то нам приходится ждать и там наверное еще какието проблемы с влиянием
сигнаа  в однйо паре на другие пары короче оказалось что наращивать частоту сигнала когда у нас
много пар работает в одну сторону очень хреновая перспектива , оказалось что горазло более проще взять вместо 32 пар всего одну пару и по ней охиренно поднять частоту и на выходе мы сможем получить гораздо более высокую скорость пропускную. поэтому отказались от дальнейшего развития многожильной pci шины в сторону маложильных шин в которых скажем 2 или 4 провода. 
прием если 4 то это два в одну сторону и два в другую тоест они друг от друга независят. 
Забегу впреед pci-e шина. у нее есть понятие линия. линия это 4 провода . где одна пара идет
на отправку вторая на принятие. поэтому она фулл дуплекс. и скорость у нее на  данный момент чтото типа 15GB\s ( по сравнению с 133МБ\с у обычной pci). я продолжаю сранивать pci и pci-e.
у pci на ее 32 парах линий сидели сразу все устройства  и делили ее межу собой. у pci-e 
выгляди по другому. условно говоря на мат плате разведено 50 пар линий pci-e. и скажем там первые четыре линии выходят на разьем. потом следущие 4 линии на матплате выходят на разьем.
потом еще 8 линий выходят на разьем. и фишка в том что если мы воткнули карточки в первый и второй разьем то так как линии независимые от устройства невлияют друг на друга. это как 
если бы у pci первые 4 линии выходили на разьем и вторые 4 линии  выходили на свой разьем. 
тогда бы два устройства невлияли друг на друга в плане конкуренции за пропусную способность по через шину. если сказано что разем pci-e x16 это значит что 16 линий выведены на данный разьем.
совестенно если 1 линия выжиаем 15GB то суммарно 16 линий могут выжать 16*15GB\s.
Возвращаемся к PCI. значит из ich9 выходило 62 пары проводов и они уходили на мат плату на разьемы. эти разьемы все сидели на этих 62 парах делили их. получаетс что в каждй момент времени из pci в ich9 прилетало 4 байта инфо только от одного устройства. остальные сидели и ждали когда им дадут тайм слот. но в ICH9 приходили линии нетолько с pci шины но и из других
шин. это и usb контроллер и ethernet контроллер и звуковая карта они тоже приходят 
с мат платы на ich9. тоесть к примеру говоря на плате есть разьем sata и он 
по отдельно распаянной sata шине на мат плане входит  в ICH9. значит ICH9 далее соединяется
с северным мостом по шине DMI. для ICH10 эта шина была по скорости 1GB\s и полный дуплекс.
северный мост уже соединяется с цпу через FSB шину. вот наконец картинка как это выглядело
https://en.wikipedia.org/wiki/File:Motherboard_diagram.svg
на ней видно что все разьемы pci делят между собой одну шину. про FSB шину ну скажем что 
она имела скорость 3.2GB\s. возникает вопрос а  как цпу  обращался к pci шине. 
нужны либо отдельные на цпу адресные линии которые можно выставлять которые должны вести 
в pci линии. либо нужен memory map chip который будет делать то что при выставлении н
на стадартной шине адреса для памяти на цпу некоторого адреса чтобы этот чип переключал
на адресные линии pci. ответа незнаю как это было сделано. потому что в целом варианта у цпу
еще раз повторю два. либо у него должные быть отдельные ножки адреса\данных для ообращения
к шине либо он должен юзать ножки предназначеные для памяти а спец мемори чип должен 
в это время перехватывать и мапить на шину. также видно что dmi шина точно неузкое
место тоесть всем периферийным устройствам хватит ее ширины для обращения наверх.
но возникает интересный вопрос - из картинки видно что слева от цпу видеокарта
справа память снизу южный мост с периферичнымт устройствами так вот фишка втом насколько я понимаю что в каждый момент времени цпу может обращаться тольк к одному устройству. 
тоесть либо к памяти. либо в к видеокарте либо к pci устройству. тоест неможет одновременно
читаь и из видеокрта и из памяти и из pci шины поэтому неочень понятно скажем зачем DMI размером 1GB\s если в любом случае ... хотя на картинке от ICH9 изображен 1GB сеетвой контроллер поэтому да чтобы его сокрость раскрыть нужен наверх шина 1GB\s . я к тому что 
на DMI нужна скорость несуммарная от всех периферийных устройств сидящих на ICH9 а только 
скорость самого быстрого. потому что цпу неможет обращаться более чем к 1 устройству на текущий  момент. едиснвтенное что возможно еще играет роль это DMA. тоесть 
DMA контроллер может качать данные из периферийного устройства в память через ich9 и северный мост и однрвемнно цпу в это время может качать данные скажем с сетевого контроллера. тогда 
да получается что через DMI в момент времени будет протекать потоки от двух периферийных устройств одноврменно и тогда DMI должен быть шире чем пропускная споосбность этих двух 
и более устройств. вот еще картинка для схемы северный мост-южный мост 
https://en.wikipedia.org/wiki/File:Intel_4_Series_arch.png
кстати когда бала схема севеный+южный мост то контроллер памяти сидел в северном мосту.
далее вместо и южного появилась схема одного моста PCH (platform controller hub)
который соединяется с цпу по DMI. а контроллер памяти сидит в цпу. память уже содеиняется
напрямую с цпу без участия мостов. схема - https://en.wikipedia.org/wiki/File:Intel_5_Series_architecture.png

Возврашаемся к PCI.
итак байти от нее летел в ICH мост южный. далее через DMI летет в северный мост и далее
через FSB летел в цпу. вот стока переходов. 
это нам пригодится когда щас будет рассматривать PCI-e. насколько там сократился этот путь.

а пока рассматриваем PCI и ее связь с дисками. диск в pci напрямую не воткнуть.
в PCI втыкался контроллер дисковый . на нем находился PATA контроллер.одним концом
эта плата воткнут в pci шину. на контрллере находится разьем PATA. воткнут кабель PATA
и он уже уходит в диск с разьемом PATA. либо контроллер распаян на плате и тут я незнаю
он был подключен к шине PCI либо он был подлкючен к ICH мосту напрямую минуя PCI. 
скорость PATA шины это 133МБ\с.
PATA шина она тоже как и PCI много проводковая. она также полудуплекс. 
шина имела 40 либо 80 проводков. ширина 16бит то есть 2 байта. значит 16 проводков под дата
3 под адрес ( на щине могло сидеть максимум 2 устройства). с обратный проводками там как то более хитро чем у PCI. но главное что 40 жильный разьем и 80 жильный отличались тем что 
доп 40 жил это все типа ЗЕМЛЯ предназначенная для того чтобы можно было повысить частоту 
шины до 66MHz. тоесть доп 40 жил они были не для того чтобы добавить полный дуплекс. 
они были служебные чтобы можно было добавить частоту. да и смысла небыло в полном дуплексе
ибо крутящиеся диски могли либо читать либо писать. одновременно там бы упала скорость сильно.
получается схема выглядела в лучем случае байтик который летел от диска его путь 
выглядел так:

диск - PATA шина - (PATA контроллер в ICH9) - DMI щина - north bridge - FSB шина - цпу

или еще хуже


диск - PATA шина - PATA контроллер - PCI шина - ICH9 - DMI щина - north bridge - FSB шина - цпу

так значит с PCI и PATA разобрались.

переходим к SATA:
Sata это шина и разьем. SATA в отличие от PATA или PCI неимеет множества проводов.
в этом плане sata шина она очень узкая. в плане скорости выдает SATA 3 выдает 6Gbit/s или еще пишут так что выдает 6GT/s это одно и тоже. но фишка в чем, нахера тексели ввели, фишка втом что на каждые 8 переданных бит добавляется 2 служебных бита(обозначается 8b/10b) поэтому 6Gbit\s это полный поток
а поток полезной информации это 6(Gbit\s) * 8\10 = 4.8 Gbit\s или ~600MB/s 
Далее важно сказат что sata это полудуплексный шина тоесть данные в момент времени
по шине летят либо только туда либо только обратно но не одновременно. 600MB\s это скорость
либо туда либо обратно. 
теперь возвращемся к очень интересному моменту. в проводе SATA между контроллером и диском
4 провода а наконцах этого провода 7 пинов. И это для меня загадка. Единственное что 
4 пина это для передачи данных , тоесть эти пины это как провода что мы видим в проводе
а 3 пина это GROUND и я непонимаю а что ground нетребует наличия проводов в проводе?
вот это мне непонятно. переходим к тому почему 4 провода в кабеле. как я понял смысл такой - 
эти четыре провода это две пары обычных контуров электрических. тоесть в одной паре ток входит
в один провод и возвращается через другой и во второй паре тоже самое. возникает идея что 
по одной паре передается инфо туда а по другой обратно. тоесть один бит пераедается по одной паре туда а другой бит передатеся по другой паре обратно. типа мы имеем полнодуплексную шину шириной 1 бит. ну или это шина шириной 2 бита в одну сторону полудуплексная. однако все совсем
нихера нетак все устроено у SATA. значит у SATA применяеся differential signaling. что это значит. для него нужно 4 провода (например). далее я пока непонимаю как физически передается сигнал и как он фиксируется но примерно так: у нас есть первая пара проводов которая является
классической электрической парой (типа как два провода из розетки и лампочка, один провод это фаза второй это ноль). так вот на первой паре на первом проводе на фазе мы дергаем по времени 
Voltage. например было там +0 а мы на короткое время дернули его на +12V. и это возмущение
побежало по проводу. Что ловят на том конце я незнаю. То ли изменнеие волттаджа во врмени
то ли появление тока. я незнаю. но возмущение долетит до второго конца и там словят условно говоря появление +12V. и через ноль эта хрень улетает обратно. Теперь берем вторую пару 
проводов и в фазу подаем в тотже момент времени -12V. и это вомзущение побежало по проводу.
А теперь самая главная хрень зачем мы это мутили - если на провода снаружи идет наводка электромагнитная то она и в первом контуре скажем для примера исказит сигнал и прибавит  к нему условно говоря +1V и во втором контуре она сделает тоже самое. так вот на той стороне
стоит электрический (незнаю как это на практике выглядит) дифференциатор. и тогда вот что 
он там получает 

+12V+1V - ( -12V +1V) = +12V + 1V +12V -1V = 24V

тоесть наводка будет полностью уничтожена этим дифференциатором исходя из того что она дала 
одинаковое возмущение на оба контура. а наш исходный сигнал получен с удвоенной амплитудой.
вот эта вся схема и называется differential signaling. а используется она для защиты от внешних наводок. сотвественно логично что обе фазы обоих контуров надо в кабеле расположить максимально близко чтобы внешнее воздействие на обе фазы было по амплитуде максимаьльно одинаковое. Итак по сути у нас через два канал передается всего один бит информации. но зато мы имеем помехаозащищенность. для сравнения посмотрим что было бы если бы мы использовали 
одну пару проводов и single ended signaling. тоесть у нас есть одна пара проводов и мы
на фазе дергаем и выставляем имупульс +12V.
возмущение летит по проводу и тут снаружи у нас помеха и она дает -13V
тогда на втором конце мы вместо +12V получим -1V тоесть бит информации абсоллютно потерян.
когда же у нас differential signaling то мы будем иметь

+12V-13V - ( -12V -13V) = +12V - 13V +12V +13V = 24V

как видно бит непотерян ( ну тоесть если у нас будет делитель сигнала на два то мы получим
на втором конце теже самые +12V). вот что знчит differential signaling, вот зачем он нужен
и вот почему в sata кабеле четыре провода и при этом по факту шина полудуплексаная и имеет ширину 1 бит. 

Единственное что мне непонятно. для differential signaling надо иметь 4 провода в кабеле
и экранировать вроде их получается ненадо это плюс. но зато они должны идти друг от друга 
на постоянном расстоянии. это минус.  а если мы гвооими про защиту от помех то можно было бы
взять просто два провода с single ended signaling и просто на них наложить железный экран
снаружи и тогда тоже небудут помехти снаружи влиять. так в чем проблема? неужели 
изговтовить кабель  с двумя экранрованными проводами сложнее чем изготоввить кабель с четырьмя 
неэкранированными проводами но идущих на одинаковом расстоянии? непонятно

но зато хотя бы стало понятно почему в sata кабеле 4 провода при том что передается всего 
1 бит и сввязь полудуплексаная.


- компексные числа и сигналы.
компдексное число это (по определению) всего навсего пара чисел. обозначается вот так
(x,y).  и сразу видно что компл число в точности выглядит как координата точки на какойто
плоскости.

еще (по определению ) комплексное число обозначается как z. тоесть
(x,y) и z это одно и тоже.

для комлпесного числа (по определению) определены операции сложения, умножения, равенства.

равенство:
 это когда
z1=(x1,y1)
z2=(x2,y2) 
тогда z1=z2 если x1=x2 и y1=y2

cсложение:
z3=z1+z2
z1=(x1,y1), z2=(x2,y2)
z3=(x1+x2,y1+y2)

умножение:
z3=z1*z2 = (x1*x2-y1*y2, x1*y2+x2*y1)
физичекий смысла неочень понятен.

далее рассматриваются числа вида (x,0)

z1+z2 = (x1,0) + (x2,0) = (x1+x2, 0)
z1*z2 = (x1*x2,0)

ну видно что получаемое компл число тоже имеет вид (x,0)

дальше они пишут стремную вещь что (x,0) поэтому можно обозначать как просто x 
тоесть

(x,0)=x

по мне это равенство это хрень какаято. обьекты справа и слева это разные штуки.
а именно слева находится пара чисел x и 0 а справа одно число x и как 
это можно приравнивать? ведь комплексное число по опредеению это ПАРА чисел! пара!
поэтому пара никак не может быть эквивалентна одному числу!. два числа никак не могут
быть эквивалентны одному числу! поэтому я пока могу эту хрень только вот так 
интерпретировать: если у нас указано x то это типа такое типографское сокращение
для обозначения (x,0). итак еще раз
если указано просто x то мы пониммаем что это сокращение обозначений ( считай что по факту
это некоректное обозначение) и по факту это некоректное обоначение обозначает (x,0).
опять же еще раз - определение комплексного числа это всегда пара чисел. (x,y)
нет никаких комплесных чисел вида x. что еще интеренее что есть определение о том как 
сложить два компелксных числа и как умножить два комплеатных числа но совсем нет 
инфо о том как сложить или умножить комлпексное число и некомплексное число!


(тут еще набор пространных рассуждений. - по мне хрень полная. слева координата а справа число. совершенно разные обьекты.
хотя можно вот так рассматривать что число x оно может быть обозначено на числовой прямой.
если у нас есь числовая прямая то координата числа x это x или вот так (x) просто обычно
никто не использует координаты для числовой прямой. числовая прямая это одна из осей плоскости в которой есть две оси координат. как только мы добавляем вторую ось то все числа
на исходной числовой прямой автоматом приобретают вид (x,0) а если третью ось добавим 
то приобретают вид (x,0,0) таким образом в какойто степени (x,0)=x хотя это как бы и хрень хотя как сказать. что является первичным число или числовая прямая. если числовая прямая то число это всего лишь ее свойство тогда скорее (x,0) явялется коректной записью числа а запись 
вида x это некий колхоз ибо небывает просто чисел числа все сидят на числовой прямой. вобщем хрен знает. ясно по крайней мере то что между числом x и точкой на оси (x,0) можно установить однозначное соотвествие. это точно. тоесть нет такого числа x которого бы небыло на (x,0)
и нет такой точки (x,0) на оси для которого бы несуществовало бы числа x. а так в целом непонятно что первично числа которые уже затем образуют числовую ось или ось внутри которой содержатся числа. поидее ось первична а числа это ее свойство. типа как  космос и пространство первича а атомы это их просто свойства. типа нет ни одного числа которые бы было рождено вне числовой прямой. наверно как то так. так.. хотя... что такое число если взять
напримере натуральных чисел. число это кучка яиц куриных или горка песка морского. хотя опять же это несамо число это его форма визуализации. что такое само число непонятно. чтото 
нематериальное чтото неведомое. типа как тепло. есть некая форма носителя или форма восприятия на теле но что такое тепло само неясно. так и число. если начать выкладывать 
в ряд числа в форме песка то это будет ряд горок от маленьких до больших. это будет 
альтернативный аналог числовой прямой. поэтому все таки вначале числа а числовая ось это форма визализации.. пока про это все.

далее рассматривается 

(x,0)*(1,0)=(x*1,0)=(x,0)
мы видим что умножение дало тот же результат что и исходное число
тоесть 
(x,0)*(1,0)=(x,0)

далее они еще раз пытаются установить связь между обычными числами и комплексными
они говорят что обычное число А и комплексное число (A,0) это одно и тоже ( у меня шок)
с одной стороны как число и пара чисел может быть одним и тем же. вот для примера 
прдеставим обычную трехмерную систему координат ( несвязанную с комплексным числом никак).
далее берем число 1. вопрос  (1,0,0) (0,1,0) (0,0,1) и 1 это одно и тоже число ? или может
вообще нельзя сравнивать обьекты разной природы. что такое (1,0,0) = есть три множества
чисел ( каждая ось это множество) и мы берем по одному числу из каждого множества 
и создаем новое множество из трех чисел 1,0,0 . множество из трех чисел. как можно множество
из трех чисел приравнивать к числу? поэтому я считаю что говорить что число А и множество
из двух чисел А,0 одно и тоже это некоректно. однако далее я принимаю эту их точку зрения
и считаю что если написано А то это типографское сокращение для комплексного числа (А,0)
Так вот далее они говорят что мы щас мол введем операцию умножения обычного реального числа
на комплексное число ибо к данному моменту мы такого рода операцию не определелили.

А- обычное число . но мы себе понимаем что на самом деле это комплекс число (A,0)
z - комплексное число
тогда
A*z это будет умножение не обычного числа на комплексное а комплексного на комплексное (а это мы уже умеем делать) а именно

A*z=(A,0)*(x,y)=(А*х, А*y)

итак еще раз если мы видим в одной строке комлпксное число и обычное число то мы сразу
понимаем что никакого обычного числа нет а это просто типографское сокрашение для комлпексного числа (А,0)



Далее рассмотрим умножение  (x,0)на  (0,1)

(x,0)*(0,1)=(x1*x2-y1*y2, x1*y2+x2*y1)=(0-0,x)=(0,x)
тоесть
(q,0)*(0,1)=(0,q) 
если мы заменим (q,0) типографским сокращением на q то получаем
q*(0,1)=(0,q)
или
(0,y)=y*(0,1)
еще раз подчеркну что y это просто сокращение типографское для комплксного числа (y,0)
потому что у нас операции определены только для комлпксных чисел поэтмоу все числа 
в строке дожны быть строго комлексные.
комплексное число (0,1) называется мнимой единицой(чисто такой у нее позывной). это 
число так называют потому что
(0,1)*(0,1)=(0-1,0)=(-1,0)
если мы обозначим число 0,1 как i то получаем
i*i=(-1,0)
или
i^2=(-1,0)
далее заменяем (-1,0) на типографское сокращение -1
получем
i^2=-1
еще раз хочу подчернуть что -1 в данном случае это не -1 а сокращение для комлпксного числа (-1,0) так что ненадо путать -1 и (-1,0)

двигаем дальше:
z=(x,y)=(x,0)+(0,y)
вышем мы получали что (0,y)=(y,0)*(0,1)
заменяем (0,1) на ее обозначение через i получаем 
(0,y)=(y,0)*i=i*(y,0) подставляем в z

z=(x,y)=(x,0)+(0,y)=(x,0)+i*(y,0)

пока все строго пока все четко.

дальше применяем типографское сокращение что (x,0) это x тогда

z=(x,0)+i*(y,0)=x+iy

z=x+iy 
это типа алгебраическая форма обозначения комлпкексного числа.
еще раз хочу подчеркнуть что эта форма это фикция. на самом деле нет в этой формул никакого
x и y болтающихся свободно в строке. это просто сокращение. реальная формула коректная это

z=(x,0)+i*(y,0)

где опять же i  это (0,1)


еще раз итак мы имеем
z=(x,y)=x+iy
отсюда мы чисто на глаз видим важную полезняшку
когда мы имеем алгабраическую форму комлпексного числа то то что стоит за буквой i
это вторая компоенента а то что стоит без буквы i то это первая компонента.тоест 
пример
z=3-i6 это значит что z=(3,-6)
тоесть мы можем мгновенно переводить одну форму записи коплексного числа в другую





рассмотрим
z1+z2=(по определению)=(x1+x2,y1+y2)
теперь рассмотрим в новой форме z1+z2=(x1+iy1)+(x2+iy2) , теперь приравниваем
(x1+x2,y1+y2) = (x1+iy1)+(x2+iy2)
раскроем правую часть и проверим что получим то что слева
(x1+iy1)+(x2+iy2)=(x1,0)+i*(y1,0)+(x2,0)+i*(y2,0)=(x1+x2,0)+(0,y1)+(0,y2)=
=(x1+x2,0)+(0,y1+y2)=(x1+x2,y1+y2)
сравниваем с тем что слева
(x1+x2,y1+y2)=(x1+x2,y1+y2)
совпало ну а как же оно могло несовпасть.
я думаю что из алгеабраической формы для операции сложения тут важно
заметить что походу мы можем(чисто на пальцах) вынести правило такое что :
 z1+z2=(x1+iy1)+(x2+iy2)=(x1+x2)+i(y1+y2)



ну и для операции умножения: 
z1*z2=(x1,y1)*(x2,y2)
c одной стороны(по определению) 
z1*z2=(x1*x2-y1*y2, x1*y2+x2*y1)
с другой стороны используем новую форму записи комплексного числа 
z1*z2=(x1+iy1)*(x2+iy2)
получеаем:
(x1*x2-y1*y2, x1*y2+x2*y1)=(x1+iy1)*(x2+iy2)
исходя из этой штуки мы можем взять дерзость смелость применяя к правой части
колхозные методы работы с обыкновенными числами получить то что слева.тоесть раскрыть скобки
как мы бы это делали с обыкновенными числами. (хотя такой подход это чисто наш неподекрепленны математически метод). поехали раскрываем скобки:
(x1+iy1)*(x2+iy2)=x1x2+i*x1y2+i*y1x2+i*i*y1*y2
группируем и используем то что i*i=(-1,0)=-1
x1x2+i*x1y2+i*y1x2+i*i*y1*y2=x1x2+i(x1y2+y1x2)-y1y2=(x1x2-y1y2)+i(x1y2+y1x2)
сравниваем левую часть которая точно верна потому что по определению
и правую которую мы вывели колхозным пальцевым некоректным методом
(x1*x2-y1*y2, x1*y2+x2*y1) = (x1x2-y1y2)+i(x1y2+y1x2)
и как бы да все совпало. откуда я чисто из пальца делаю вывод
что в алгебраической форме с компоентами комплексного числа можно работать ровно также
в плане раскртия скобок сложения и умножения так же как мы это делаем для простых чисел.
это удобно. в этом плюс алгабраической формы. хотя строгого доказтельсва у меня нет.

далее.
комплксно сопряженное число.
число (x,-y)=x-iy является комплесно сопряженным числу (x,y)=x+iy

далее.
модуль комплексного числа ( по определению) обозначается как |z| и оно равно sqrt(x^2+y^2)
тоесть
|z|=sqrt(x^2+y^2)
теперь тоже самое в других формах
|z|=|(x,y)|
|z|=|x+iy|

теперь смотрим когда же |z|=0. это будет когда sqrt(x^2+y^2)=0 а это будет когда 
x=0 и y=0.
подставим x=0 и y=0 в алгебраическу форму
|z|=|0+i*0|=|i*0|=|(0,1)*(0,0)|=|(0,0)|=sqrt(0+0)=0

далее расматривается случай коплексного числа (x,0)
|z|=sqrt(x^2+0)=|x|
таким образом |z| для (x,0) совпадаеь с модулем обычного числа |x|

далее
z=x1+iy1
(сопряженное)z=x1-iy1
z*(сопряженное)z=(x1+iy1)(x1-iy1)=(x1,y1)*(x1,-y1)=(x1*x1+y1*y1, 0)=(x1^2+y1^2,0)
получаем(используем алгебраическую форму)
z*(сопряженное)z=x1^2+y1^2
теперь вспоминаем что |z|= sqrt(x^2+y^2).
возведем в квадрат
|z|^2= (sqrt(x^2+y^2))^2=x^2+y^2
теперь сравниваем:
z*(сопряженное)z=x1^2+y1^2
|z|^2= (sqrt(x^2+y^2))^2=x^2+y^2
видим что получаем одно и тоже .значит:
z*(сопряженное)z = |z|^2


далее. 
замечают что модуль |z| и модуль |сопряженный z| совпадают.
тоесть
|z|=sqrt(x^2+y^2)
|сопряженный z| = sqrt(x^2+(-y)^2)

далее они доказывают что
(z1*z2)*z3 = z1*(z2*z3)
и то что
(z1+z2)*z3 = z1*z3 + z2*z3
ну понятно как доказывается. 
и в книжке написано что благодаря этому доказывается что можно выполнять операции
с комплекными числами как бутто это обыкновенные числа и i  в том числе. то чем я занимался
там выше.

далее рассматриваются числа 1=(1,0) и 0=(0,0) и их свойства
z+0=z+(0,0)=z
z*1=(x+iy)*(1+i*0)=x+iy=z


далее.
разность z1-z2 называется такой z3 что z3+z2=z1

найдем 0-z
пусть z=(x,y)
искомый z3=(x3,y3)
0=(0,0)
тогда
(x3,y3)+(x,y)=(x3+x,y3+y)=(0,0)
значит
|x3+x=0
|y3+y=0

значит
|x3=-x
|y3=-y

значит
z3=(-x,-y)

найдем теперь общий случай z1-z2=z3
(x3+x2,y3+y2)=(x1,y1)

значит
|x1=x3+x2
|y1=y3+y2

значит
|x3=x1-x2
|y3=y1-y2

значит общее правило как выполнять отнимание:
z1-z2=(x1-x2, y1-y2)


далее
посмотрим чему равно 
-1*z= (-1+0i)(x+iy)=-x-iy=(-x,-y)
сравниваем и замечаем что 
0-z=-1*z
интересно.


далее
определяем что такое операция деления. z1:z2=z3
так вот z3 по определению это такое число что z3*z2 должно дать z1
итак ищем z3 пользуясь выражением z3*z2=z1
умножаем левую и правую часть на (сопряженное)z2

(сопряженное)z2*z3*z2=(сопряженное)z2*z1
тут мы пользуем формулу что раньше получили (сопряженное)z2*z2=x2^2+y2^2
значит
(x2^2+y2^2)*z3=(x2-iy2)(x1+iy1)
двигаем дальше
работаем с правой частью
(x2-iy2)(x1+iy1)=x2*x1+i(y1*x2)-i(y2*x1)-i^2*y2*y1=x2*x1+i(y1*x2-y2*x1)+y2*y1=
=(x2*x1+y2*y1)+i(y1*x2-y2*x1)=(x2*x1+y2*y1, y1*x2-y2*x1 )
подставляем
(x2^2+y2^2)*z3 = (x2*x1+y2*y1, y1*x2-y2*x1 )
работаем с левой частью
(x2^2+y2^2)*z3=(x2^2+y2^2)*(x3+i*y3)=x3*(x2^2+y2^2)+i*y3*(x2^2+y2^2)=
= ( x3*(x2^2+y2^2),  y3*(x2^2+y2^2)   ) 
подставляем
( x3*(x2^2+y2^2),  y3*(x2^2+y2^2)   ) = (x2*x1+y2*y1, y1*x2-y2*x1 )
значит чтобы было равенство то значит должно выполняться:
| x3*(x2^2+y2^2) = x2*x1+y2*y1
| y3*(x2^2+y2^2) = y1*x2-y2*x1

значит
x3= (x2*x1+y2*y1)
    --------------
    (x2^2+y2^2)

y3= y1*x2-y2*x1
    ------------
    (x2^2+y2^2)



значит
z1     (  x2*x1+y2*y1     y1*x2-y2*x1  )
--- =  ( --------------,  ------------ )
z2     (  (x2^2+y2^2)     (x2^2+y2^2)  )


выполним пример
1+i     2*1+(-3)*1       1*2-(-3)*1     -1       5
---- = ------------ + i*------------ = ---- + i*----
2-3i    4+9               13            13       13


далее смотрим на счет |z1*z2| = |z1|*|z2| проверяем
берем левую часть
z1*z2 = (x1+iy1)*(x2+iy2) = x1*x2+x1*i*y2+i*y1*x2-y1*y2 = (x1*x2-y1*y2)+i(x1*y2+y1*x2)
далее 
|z1*z2|=sqrt[(x1*x2-y1*y2)^2+(x1*y2+y1*x2)^2]
тут давай упростим выражение в скобках
(x1*x2-y1*y2)^2+(x1*y2+y1*x2)^2=(x1*x2)^2 + (y1*y2)^2 - 2*(x1*x2)(y1*y2) +
+ (x1*y2)^2 + (y1*x2)^2 + 2*(x1*y2)(y1*x2) = (x1*x2)^2 + (y1*y2)^2 +  (x1*y2)^2 + 
+ (y1*x2)^2 = x1^2*(x2^2+y2^2)+y1^2*(y2^2+x2^2) = (x2^2+y2^2)*(x1^2+y1^2)
подсталяем 
|z1*z2|=sqrt[ (x2^2+y2^2)*(x1^2+y1^2) ]

теперь работаем с правой стороной
|z1|*|z2|=sqrt(x1^2+y1^2)*sqrt(x2^2+y2^2)=sqrt[ (x1^2+y1^2)*(x2^2+y2^2) ]

теперь сравниваем
|z1*z2|   = sqrt[ (x2^2+y2^2)*(x1^2+y1^2) ]
|z1|*|z2| = sqrt[ (x1^2+y1^2)*(x2^2+y2^2) ]
получили одно и тоже, значит
|z1*z2| = |z1|*|z2| 

теперь проверяем то что:
|z1|   |z1|
|--| = ----
|z2|   |z2|

используем то что (z1\z2)*z2 =z1
действительно z1\z2= (по определению) z3 такой что z3*z2=z1
далее накладываем на них модуль.
|(z1\z2)*z2| = |z1|
теперь используем выше доказанное свойство :
|z1*z2| = |z1|*|z2|
значит
 |(z1\z2)*z2|=|(z1\z2)| * |z2| . подставляем это вверх

|(z1\z2)| * |z2| = |z1|
далее поскольку модуль это уже чисто обыкновенное число то мы можем с ними 
делать классические алгебраические операции , значит:
|(z1\z2)| = |z1| \ |z2|

или более красиво
|z1|   |z1|
|--| = ----
|z2|   |z2|


далее. 
переходим к геометрической интерретации комплексного числа.
значит по определению комплексное число это пара действительных чисел. тоесть
(x,y). так вот ровно тоже самое это координаты точки на прямоугольной системе координат. (x,y). координаты это тоже пара действительных чисел. а что такое координата точки более подробно?- это разложение вектора по двум другим векторам (1,0) и (0,1) тоесть

{x,y}=x*{1,0}+y*{0,1}

заметим что комплксное число ровно так и выглядит в алгераичкской записи

(x,y)=x*(1,0)+y*(0,1)

мы теперь понимаем что компкс число (x,y) можно интепретировать и как точку
на плоскости и как вектор. что же это за вектора (1,0) и (0,1) какой у них физический смысл в плане комплексного числа: (0,1) это компл число i, таким образом
компонента y комплексного числа это разложение по вектору i(который лежит на вертикальной оси). (1,0) это одиночный вектор на гор оси. 


интересно каково определение обратного числа у комплексного числа. у действительного  числа это число (как я понимаю) такое что оно получается путем
умножения на -1, то есть -x это такое число которое можно найти путем операции -1*x.
наверное для комплексного это тоже так(только мы умножаем не на -1 а на комплексное число (-1,0) ? тогда

-z=-1*z=(-1,0)*z=(-1,0)*(x,y)=(-1+i*0)(x+iy)=-x-iy+0+0=(-x,-y)
-z=(-x,-y)

значит в геометрической интерпретации число -z относительно числа z получается 
путем зеркально отражения относительно обоих осей.

числа z и (сопряженное z) друг относиельно друга отличаются тем что симметрично отражены относительно горизонтальной оси.

модуль |z| интерперетируется как длинна вектора или как расстояние от точки z до 
начала координат (что одно и тоже)

сложение и вычитание z1 и z2 имеет смысла правила сложения вычитания векторов z1 и z2

|z1-z2| приобретает смысл расстояния между двумя точками.

дальше немного прикольного:
точки z такие что |z-z0|=R0 это окружность радиуса R0 в центре z0
точки z такие что  |z-z1|=|z-z2| это серединный перпендикуляр к отрезку с концами 
в z1 и z2

забавно и дебильно то что все эти вот понты на счет комплексных чисел это все
на самом деле всего навсего старые добрые вектора и точки на плоскости но поданные
под понтовой оберткой под названием комлпексное число. да уж...

тоесть зачем было придумывать новую сущность когда она по факту является старыми
сущностями. 

уравнеение эллипса:
|z-z1|+|z-z2|=2a 
это эллипс с фокусами в z1 и z2 и большой полуосью 2a


далее.
тригонометрическая форма комплексного числа.

оступление:
реально прикольно что клмпелксное число это всего навсего точка на плоскости.(ну или вектора)
к чемутогда все эти понты. единственное что непонятно каков физический смысл 
операции умножения. если он имеет конкретный геометрический смысл то вообще незачем
было городить огород.

продолжим:
в декартовых координатах мы выражаем положение нашей точки на плоскости
через два отрезка под углом 90 градусов друг к другу.  а тепрь рассмотрим новую 
фишку полярные координаты. тут у нас есть точка. называется полюс.и есть из нее
луч или ось. так вот положение точки на плоскости определяется через расстояние 
до полюса и угла между осью. если совмещать декартовы координаты и полярные
то обычно полюс лежит в точке (0,0) декартовых координат а луч полярных координат
лежит на оси x декартовых координат. если в декартовых координатах у нас 
координатами являются x,y то в полярных кординатах у нас таковыми являются r и phi.
где r это расстояние от точки до полюса а phi это угол. 

в полярных координатах логично что |z|=r

что касается взаимосвязи декартовых координат x,y и полярных координат r,phi
то связь такая:

| x=r*cos phi
| y=r*sin phi

тогда теппрь берем определение комплксного числа тоесть что
z=(x,y)
и подставляем в него и получаем
z=(r*cos phi, r*sin phi)

по факту у нас ничего нового и страшного не прозошло. опредеение ненарушено
у нас как и прежде комплс число это пара дейтсивтельных чисел.

если мы возьмем алегеабраичечкую форму комплкс числа

z=x+iy

причем мы помним что в этой формуле x это совсем не число x а это дебильное
типографское сокращение (x,0) что совсем разные вещи. тоже самое мы помним что y
это непросто число а это типографское сокращение (y,0) , тоесть что на самом деле

z=(x,0)+i(y,0)

и подставим то что выше с r и phi то получим

z=(r*cos phi,0) + i*(r*sin phi,0)

далее используем что 
(r,0)*(cos phi,0)=(r*cos phi,0)

тогда
z=(r,0)*(cos phi,0) + i*(r,0)*(sin phi,0)

далее используем ранее выведенное что z1*z2=z2*z1 тогда 
i*(r,0)*(sin phi,0) = (r,0)*i*(sin phi,0)
подставляем

z=(r,0)*(cos phi,0) + (r,0)*i*(sin phi,0)

далее испольpуем доказанное ранее что 
z1*z2+z1*z3=z1*(z2+z3)

тогда:
z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ]

далее они используют опять вот это вот типографское дебильное сокращение 
(которое с точки зрения математики некоректно) о том что дескать давайте
обозначать (x,0) как x но будем помнить об этом в голове. 
тогда:

z(r,a)=r*[ cos(a) + i*sin(a) ]    #тригонометрическая форма компл числа
 
это так называемая тригонометрическая форма обозначения комплексного числа.( я бы конечно называл комплексный обьект но никак не комплексное число. дебильная терминология)

еще раз вспомним алгебраическую форму
z(x,y)=x+iy  # алгебраическая форма

и вспомним форму компл числа которая дается по определению:
z(x,y)=(x,y)

Но еще раз хочу сказать что также как в алгебраической форме мы помним что 
то как она записана это некое дебильное сокращение и по факту формула другая
также и в тригонометрической формуле мы должны помнить что это всего лишь дебилное
типографское сокращение а по факту формула коректая с математической точки 
зрения выглядит совсем по другому:

z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ]

это надо обязательно помнить.

далее
что еще дебильно это то что угол phi обозначают и как phi и как arg z.
дада это одно и тоже. поэтому если где то видим arg z то понимаем что это всего навсего phi и больше ничего.

Теперь рассмотрим случай когда r=1,
тогда

z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ] = (1,0)*[ (cos phi,0) + i*(sin phi,0) ] =
=  (cos phi,0) + i*(sin phi,0)
или
z=(cos phi,0) + i*(sin phi,0)
в данном случае мы получили что z зависит только от phi. 
тоесть было z(r,phi) а стало z(1,phi).окей.
теперь посмотрим а что будет если заменим phi=a+b. тоесть 
у нас станет z=z(1,a+b)

z(1,a+b)=[cos (a+b),0] + i*[sin (a+b),0]

далее используем формулы хорошо известные
cos (a + b) = cos a cos b - sin a sin b
sin (a + b) = sin a cos b + cos a sin b

подставляем:

z= (cos a*cos b,0) - (sin a*sin b,0) +i*(sin a*cos b,0) +i*(cos a*sin b,0)
рассмотрим его кусочки:
первый кусочек
(cos a*cos b,0)+i*(cos a*sin b,0)=(cos a,0)*[ (cos b,0) + i*(sin b,0) ]
второй кусочек
- (sin a*sin b,0)+i*(sin a*cos b,0)= (sin a,0)* [ -(sin b,0)+i*(cos b,0) ]
далее юзаем что -1=(-1,0)=i*i, 
подставлем:
(sin a,0)* [ -(sin b,0)+i*(cos b,0) ] = (sin a,0)* [ i*i*(sin b,0)+i*(cos b,0) ]=
=(sin a,0)*i*[ i*(sin b,0)+(cos b,0) ]
подставляем кусочки обратно:
z= (cos a,0)*[ (cos b,0) + i*(sin b,0) ] + (sin a,0)*i*[ i*(sin b,0)+(cos b,0) ]=
=[ i*(sin b,0)+(cos b,0) ]*[(cos a,0) + (sin a,0)*i] 

или в чуть более красивом виде
z=[ (cos b,0) + i*(sin b,0)+ ]*[(cos a,0) + i*(sin a,0)]

вспоминаем что наш z это z(1,a+b)
тогда
z(1,a+b)=[ (cos b,0) + i*(sin b,0) ]*[(cos a,0) + i*(sin a,0)]

вспоминаем тригонтметрическую форму записи
z(r,phi)=(r*cos phi,0) + i*(r*sin phi,0)
берем r=1 подставляем
z(1,phi)=(cos phi,0) + i*(sin phi,0)

и теперь используя эту формулу мы можем преобразовать формулу z(1,a+b)
z(1,a+b)=[ z(1,b) ]*[ z(1,a) ]

интересное свойство! тока надо помнить что оно верно только для случая r=1.
при других r все будет подругому.

далее они выводят что 
          z(1,a)
z(1,a-b)=-------
          z(1,b)













далее я рассмаотрю очень интересуню тему: выразить тригонметрическую форму
через алгебраическую форму.
задача. у нас есть комлексное число 
в алгебраоичской форме

z=x+iy

нужно найти r и phi (через x и y) которые нам позволят записать тоже 
самое число в тригонометрической форме:

z=r(cos phi + i*sin phi)

итак дано x,y нужно найти r,phi.

имеем систему:

|x=r*cos phi
|y=r*sin phi

ясно что:

r=sqrt(x^2+y^2)

итак r мы нашли. 

теперь ищем phi.
ясно что:

|cos phi=x/r = x/sqrt(x^2+y^2)
|sin phi=y/r = y/sqrt(x^2+y^2)


эта система уравнний однозначно определяет phi.  действтельно. взяли отмеряли на 
гор оси известное нам значение x/sqrt(x^2+y^2) это косинус. 
данному косинусу соотвествуют два угла. проводим из точки на гор оси(которая равна косинусу) верт черту до пересечения с окружностью. получаем две точки
пересечения с окружностью над гор осью и под гор осью. 
мы получили два угла для каждого из которых косинус угла равен нашему косинусу. тоесть у нас два угла 
кандидата. чтобы убрать лишнего кандидата надо заюзать синус. у нас  есть известный синус y/sqrt(x^2+y^2) . если  знак синуса с плюсом 
то наша искомая точка над осью X если синус со знаком минус то наша искомая точка
под осью X. когда нашли точку на окружности то мы нашли и угол. нашли его однозначно.

правда их углов все же  будет бесконечное множетсво ибо
если наш надйенный угол =phi0 то решением системы будет любой угол такой что: 
phi=phi0+2*pi*k, k=0,1,2...

насколько я понял какойто красивой формулы решения верхней
системы нет. мы находим угол как арккосинус . получаем два угла. далее
отрасываем один ориентируясь на знак синуса. я так понимаю.

кстати напоминаю что тригонометрическая форма она вводится на основе полярных
координат. а в них точка z=0+i*0 исключена ибо в этой точке неопределен угол.
тоесть это когда r=0. замечаю что исключается только случай когда оба и x и y одновмременно равны нулю. по отдельности они могут спокойно быть равны нулю.

исходя из вышесказанного тригонометрическая форма числа z будет иметь вид:
z=sqrt(x^2+y^2)*(cos (phi)+ i*sin (phi))

где phi равен любому из углов:
phi=phi0+2*pi*k, k=0,1,2...

к сожалению phi0 как я понял какйото красивой формулой невыразить.
поэтому задача для конкретных x,y имеет конкретный решенный вид а вот в общем
виде она неимеет красивого решения. я так понял.

ну точнее они обычно пишут так: phi=argz(x+iy)
тогда конечный вид тринонометрической формы через алгебраическую:

z=sqrt(x^2+y^2)*[ cos (argz(x+i*y)) + i*sin (argz(x+i*y)) ]

ну и таким же макаром показательная форма через алгебраическую:

z=sqrt(x^2+y^2) * e^(i*argz(x+i*y))

Единсвтенное что остается непонятным:
та система что наверху:

|cos phi=x/r = x/sqrt(x^2+y^2)
|sin phi=y/r = y/sqrt(x^2+y^2)
| r<>0 (тоесть x и y одновременн не могут быть равный нулю)

послденнее усолвие появляется из за полярных координат в которые при r=0 неопределен
угол.

берем строчку с синусом и делим обе части на косинус. получаем:

|cos phi=x/r = x/sqrt(x^2+y^2)
|tan phi=y/r = y/x, x<>0
| r<>0 (тоесть x и y одновременн не могут быть равный нулю)

мы получили почти эквивалентную систему уравнений за исключением случая когда
x=0. потому что в нашей исходной системе x может быть равен нулю без проблем а в нашей новой нет. ну пока необращаем а на это внимание.  замечу что x<>0 и r<>0 это разные условия.

далее можно решать исходную систему урвоенения. а можно решать поученную.
можно найти угол из тангенса но мы получим лишние корни. потом мы подставоляем
полученные корни в уравнение с косинусом и выкидываем лишние.
для известного тангенса на окружности будет всегда две точки с одинаковым тангенсом.
проверка на косинусе позволит исключить лищнюю точку. ( тангенс в этом плане неункиален. синус и косинус тоже каждый из низ при заданном значении имеет две точки
на окружности. но только одна из них удолвтевтворяет обоим уравненеиям. поэтому в итоге точка находится однозначно.)

вместо тангенса можно заюзать котангенс. но это проблемы нерешает. он тоже имеет
две точки на окружности при задннром значении.поэтому его корни тоже нужно проверять
на втором уравеннии системы.

пример:
z=-1+i (x=-1, y=1)

решим через синус косинус

|-1=sqrt2*cos phi, phi=3*pi/4+2*pi*k или phi=5*pi/4+2*pi*k
| 1=sqrt2*sin phi, phi=pi/4+2*pi*n или phi=3*pi/4+2*pi*n

отсюда находим общий phi удовлетвоярющий обоим уровеннеияем и это
phi=3*pi/4+2*pi*k

решаем через вторую систему:
|-1=sqrt2*cos phi, phi=3*pi/4+2*pi*k или phi=5*pi/4+2*pi*k
|-1=tan phi, phi=3*pi/4+pi*n

находим общий корень
phi=3*pi/4+2*pi*k


конец темы: "выразить тригонметрическую форму
через алгебраическую форму."













далее
очень крутая тема.
формула эйлера.
дело в том что ее строгое доказательство хрен найдешь.
но нашлось. ура.
во первых что такое e^z. да дейтсивтельно что это за хрень. ведь по сути
это запись  вида 2.7^z . так вот совершенно непонятно какой смысл имеет 
тот случай когда степень у нас комплексное число. действиетельно какой смысл вот 
этой записи 2.7^(2,1) - что это за хрень? так вот нашел то что вводят по определению что 
            z^n
e^z=summa ------- при n=0..infinity
             n!

 если то что слева от равно хрен знает что значит
 то то что справа имеет абсолютно четкое значение.
 что такое n! - абсолютно понятно.
 что такое z^n тоже понятно при n=натуральные числа. тоесть

 z^1=z
 Z^2=z*z  # мы умеем это вычислять
 z^3=z*z*z # никаких проблем при вычислении

кстати вопрос что такое z^0.... наверно по определению это 1=(1,0)?

 возьмем для примера z=(1,0) и распишем что такое 

 e^(1,0)=[ 1 + (1,0) + (1,0)*(1,0)/2 + (1,0)*(1,0)*(1,0)/6 + ... ]

 теперь заметим что (1,0)*(1,0)*.... (1,0)= всегда (1,0) тогда

 e^(1,0)=[ (1,0) + (1,0) + (1,0)/2 + (1,0)/6 +.... (1,0)/n!] =
 = (1,0)* summa [2+1/n!] при n=1...infinity = (summa [2+1/n!],0) при n=1...infinity
 или
 e^(1,0)= (summa [2+1/n!],0) +i*0, при n=1...infinity

насколько я понимаю этот ряд 
summa [2+1/n!], при n=1...infinit  он равен = e^1
итого

e^(1,0)=(e^1,0)

 мы рассмотрели случай когда z=(1,0)

далее рассматривается случай когда z=0+i*a=(0,a), где a=[0:2pi]
тогда

              z^n
e^(0,a)=summa ------- при n=0..infinity
               n!


z^n     (0,a)^n
---- = -------- = [(n!)^-1,0]*[ (0,a)^n ]
n!        n!


рассмотрим по кускам.
(0,a)^n=?

n=0| (0,a)^0=(0+i*1)^0=i*1^0=i=(0,1)
n=1| (0,a)^1=(0,a)

форула умножения : z1*z2=(x1*x2-y1*y2, x1*y2+x2*y1)

n=2| (0,a)^2=(0,a)*(0,a)=(0-a*a, 0)= (-a^2, 0)
n=2| (0,a)^2=(-a^2, 0)

n=3| (0,a)^3=(0,a)*(0,a)*(0,a)= (-a^2, 0)*(0,a)= (0, -a^2*a+0) = (0,-a^3)
n=3| (0,a)^3=(0,-a^3)
интересно....
продолжаем дальше смотреть
n=4| (0,a)^4=(0,-a^3)*(0,a)=(0+a^3*a, 0)=(a^4,0)
n=4| (0,a)^4=(a^4,0)

n=5| (0,a)^5=(a^4,0)*(0,a)=(0, a^4*a)=(0,a^5)
n=5| (0,a)^5=(0,a^5)

выписыаваю:
n=0| (0,1)

n=1| (0, a)
n=2| (-a^2, 0)
n=3| (0, -a^3)
n=4| (a^4, 0)
n=5| (0, a^5)

перегруппирую:
n=0| (0,1)


n=1| (0, a)
n=3| (0, -a^3)
n=5| (0, a^5)


n=2| (-a^2, 0)
n=4| (a^4, 0)

тогда для нечетных n=1,3,5, .. infinity имеем:

сразу подменяем n=1+2k, где k=0,1,2...)

           (0,a)       (0,-a^3)    (0,a^5)        ( 0, (-1)^(k)*a^(1+2k) )
summa(n)= -------  +  ---------- + -----   +     ----------------------- + ... 
             1!          3!          5!               (1+2k)!                


 факториал можно внести внутрь, потому что
(p,0)*(0,y)=(0-0, p*y)=(0,py)
(p,0)*(y,0)=(py-0, 0)=(py,0)
также можно заюзать запись через i
тогда собирая все в кучу:

           a^(2k+1)
s(1+2k)=  i* ---------- * (-1)^k     , k=0,1,2...inf
            (2k+1)!

так вот внимательно посмотрев на сумму мы вдруг неожиданно
понимаем что это ничто иное как ряд Маклорена для функции sin a.(ряд маклорена это чатный случай ряда тейлора если что).
таким образом сумма всех членов при нечетных n=1+2k , где k=0,1,3 равна
summa (s(1+2k))= i*sin(a)

если еще помудить с четными членами то поймем что сумма всех четных членов
сходится к  
summa(s(2k)) = cos(a)

ну а полная сумма всех членов равна

cos(a)+i*sin(a)

тогда получаем формулу Эйлера:

в алгебраическом виде:
e^(ia)=cos(a)+i*sin(a)

в более коректном виде
e^(ia)=(cos a, sin a)

тут важно сказать что a это вооще говоря любое число потому что z=0+i*a
но если a любое число то тогда под косинусом и синусом надо его преобразовыать
в радианы. а если мы нехотим мудежом заниматься то тогда надо сразу a преобразоывать
в радианы чтобы внутри косинуса и синуса непришлось этого делать. но еще раз 
это необзятльено. это лишь удобняшка. если мы берем любое a то просто надо понимать
что внутри синуса и косинуса нам надо будет это произволтное a преобразовать
в радианы иначе синус и косинус будуь неправльно высчитаны.

тут важно понять очень важную вещь что слева и справа стоят совершенно разные
функции. это очень важно понять потому то возникает чуство как бутто то что справа
оно как бы является определением того что слева. а это еще раз абсолютно две разные
функции просто так получилось что они оказалось дают один и тот же результат.
слева это степенной ряд а справа ну чтото другое.

и теперь вот еще проанализируем, берем формулу эйлера
e^(ia)=(cos a, sin a)

что интересно в этой формуле. я бы ее переписал в другом виде:
z2=f(z1)=(cos a, sin a)

вспоминаем тригонометрический вид компл числа:
z(r,b)=r*[ cos(b) + i*sin(b) ]

сравниваем правую часть формулы эейлера и тригонометрический вид компл числа
(cos a, sin a)
[r*cos(b), r*sin(b) ]

откуда я делаю вывод что на компл плоскости все числа принадлежащие (cos a, sin a)
это окружность единичного радиуса! Тоесть функция f(z) которая равна e^(ia) все что она делает она берет аргумент ia и отображает его в точку на единичной окружности единичного радиуса. еще раз то что функция f(ia)=e^(ia) отображает аргумент в 
окружность единичного радиуса это прикол. еще раз графически это выглядит так.
мы берем точку на оси Y(мнимая ось) и начинаем по ней таскать точку (это аргумент он сугубо мнимый потому что z=0+i*y) и как результат происходит отображение на 
некоторую компл плоскость в окружность единичного радиуса! наша функция e^ia отображает аргумент в окружность единичного радиуса. и это прикол.
жестокий прикол еще и втом что навскидку когда виддишь формулу эйлера то интутивно
думаешь(совершенно ошибочно) что якобы (cos a+i*sin a) это якобы определение что
такое e^ia. а это неверно. e^ia это степенной ряд. а то что он равен  (cos a+i*sin a) это просто совпадение! и больше ничего. (cos a+i*sin a) не является определением
e^ia.

что еще итересно:
вот смоирим на форулу эейлера:
e^(ia)=(cos a, sin a)

совершенно понятно что (cos a, sin a) это запись компелксного числа  в тригонометрическом виде когда r=1. тоесть  (cos a, sin a)=q(1,a)
тоесть
e^(ia)=q(1,a)
почему я и говорю что e^*(ia) отображает аргумент в компл число которое лежит
на окружности одиночного радиуса!

ну и вот как то хочется связать аргумент и результат ну как то еще более тесно.
если a очень мало. то тогда можно использовать разложение cos a и sin a в нуле.
тогда

cos a ~ 1-(a^2)/2
sin a ~ a-(a^3)/6
тогда

при малых a->0 :
               (a^2)       a-(a^3)
e^(ia) ~  1 - ------- + i*----------
                 2            6


вобщем это интересно что степенной ряд который зовется функция эйлера отображает
аргумент в окружность единичного радиуса.

наскольк я понимаю если рисовать график этого дела то выглядит это дело так:
если у нас есть на бумаге горизонтальная ось X на которой мы будем откладывать наш аргумент ia , и у нас есть вертикльная ось Y и есть ось Z которая нас протыкает
из листа бумаги то графиком e^(ia) будет спираль! мы двигаемся по оси X а при этом 
в плоскости YZ у нас окружность. все это в сумме дает спираль. спираль распостроняется вдоль оси X а в плоскости YZ мы видим окружность!
удвиитено!




 также заметим что что такое e^z по своему смыслу - это функция комплексного переменного . тоесть когда у нас есть закон который берет комплексное число как аргумент и ставим ему в соотвествие другое компексное число.
 тоесть к примеру

 e^(1,0) = (условно говоря) (6,7)

 тоесть комплк числу (1,0) поставлено всоотвствие другое комплксное число (6,7)
 если это пробовать представить через декартовы координаты то получается что 
 точке на плоскости ставится в соотвествие точка на другой плоскости 
 тоесть типа такого 

 (a,b)=f(c,d)

 ну что тут сказать. обычно график трехмерной фигуры это функция вида

 (z)=f(x,y)

 ну а здесь (a,b)=f(c,d) чуть сложнее. ибо мы имеем четырхмерное просранство а не привычное
 трехмерное. вот и все. если b всегда = 0 то функция комлпекснго переменного
 будет выглядеть как трехмерная фигура.
а так посути что такое график или трехмерная фигура или чтото посложнее - у нас есть одна или несколько осей, каждая ось это переменная или множество. мы берем
точку на каждой из осей и тогда на последней оси по некоторму правилу тоже 
выбирается точка. вот и все.
тоесть к примеру. имеем график двумерный y=f(x) это всего навсего у нас две оси.
мы берем точку на первой оси и по некоторому закону на второй оси у нее есть пара. 
вот и все. вот и весь смысл графика двумерного.

таким макаром e^z это всего навсего вот такая хрень

z1=f(z), где f(z)=e^z
вот и все. 
а e^z поскольку это некая непонятная хрень всего навсего это ряд. а что такое 
ряд вот такого вида

            z^n
e^z=summa ------- при n=0..infinity
             n!

 члены этого ряда имеет прекрасно понятное значение даже в случае когда переменная
 комплексная.


как уже вывел выше в частном случае когда z=0+i*a
данный ряд сходится к 

e^(i*a)=cos a+i*sin a 

или
e^(i*a)=(cos a, sin a)

Что примечательно что формула эйлера верно только и только водном супечастном
случае когда x=0. а не просто вобщем случае z=x+iy.

опять же очень важно пнимать что там где написано e^z там надо мысленно рисовать
степенной ряд вместо вот этой хрени  с буквой e.

Далее они в книжках пишут что :
так как

e^(ia)=cos a+i*sin a
то
e^(i*(-a))=cos a-i*sin a

складываем их:
e^(ia) + e^(i*(-a)) = cos a + i*sin a + cos a-i*sin a = 2*cos(a)
откуда получаем:
cos a = [ e^ia + e^(-ia) ] * 0.5

отнимаем их:
e^(ia) - e^(i*(-a)) = cos a + i*sin a - cos a + i*sin a = 2*i*sin(a)
получаем:
         [ e^ia - e^(-ia) ]
sin a = --------------------
                 2i


итого получили:
cos a = [ e^ia + e^(-ia) ] * 0.5


         [ e^ia - e^(-ia) ]
sin a = --------------------
                 2i


если честно я енпонимаю почему из за этих формул так ссут кипятком.
невижу никакого практического смысла потом что функции эейлера это ряды. 
так что какой от этого практический толк непонятно.


Далее берем тригонометричкую форму и смооим что будет при
умножении:
z1*z2=[(r1*cos a,0) + i*(r1*sin a,0)] * [(r2*cos b,0) + i*(r2*sin b,0)]=
=r1*r2*cos(a)*cos(b) + i*r1*r2*cos(a)*sin(b) + i*r1*r2*sin(a)*cos(b) - r1*r2*sin(a)*sin(b)=
=r1*r2*[cos(a)*cos(b)-sin(a)*sin(b)] + i*r1*r2*[cos(a)*sin(b) + sin(a)*cos(b)]=
=r1*r2*cos(a+b)+i*r1*r2*sin(a+b)=r1*r2*[cos(a+b)+i*sin(a+b)]

итого:
z1(r1,a)*z2(r2,b)=r1*r2*[cos(a+b)+i*sin(a+b)]

значит:
z(r,a)^2=r^2*[cos(2a)+i*sin(2a)]

если мы хотим вычислить z^3 то
это равно z^2*z тоесть

z^3=z^2*z=r^2*[cos(2a)+i*sin(2a)]*r*[cos(a)+i*sin(a)]
если мы заменим b=2a и r^2=r2 то мы получим
r2*[cos(b)+i*sin(b)]*r*[cos(a)+i*sin(a)]
и отсюда видно что что получаем формуулу аналогичную той что выше 
значит:
r2*[cos(b)+i*sin(b)]*r*[cos(a)+i*sin(a)] = r*r2*[cos(a+b)+i*sin(a+b)] =
= r^3*[cos(3a)+i*sin(3a)]

отсюда уже можно получить важную формулу, что 
для натуральных n иммеем:
z(r,a)^n=r^n*[cos(na)+i*sin(na)]

очень важно что эта формула получена абсолютно шататными способами
бещ применения формулы эйлера. эйлер тут вообще никаким боком ненужен!

и из форомулы при r=1 получаем частный случай под названием формула муавра:
z(1,a)^n = cos(na) + i*sin(na)

еще раз подчеркну что формулу муавара можно получить из общих соображений
без участия фооромулы эйлера

Далее еще прикол. 
новая форма записи компл числа. показательна форма.
берем тригонометричекую форму

z=r*cos(a)+i*r*sin(a)=r(cos(a)+i*sin(a))
далее вспоминаем формулу эйелера:
e^ia=cos(a)+i*sin(a)
подставляем ее выше получаем:
z=r(e^ia)=r*e^(ia)
z=r*e^(ia)
эта форма называется показательная форма.

кстати я еще допер чем примечательна экспонента эйлера.

e^ia=cos(a)+i*sin(a)

в качестве аргумента берется отрезок кратный длинне вектора i тоесть кратный
единице и в ходе отображения он отображается в такой вектор на плоскости который
повернут относительно начала координат ровно на такойже угол в радианах.тоесть прикольно что длинна отрезка как бы транфсормируется в величину угла. это и прикольно. тоесть пример.
берем z=0+i*5, значит сточки зрения числа z он имеет длинну 5 единиц.
и этот вектор отображается в вектор единичной длинны в новой комплексной плоскости
и повернут он в этой плоскости относительно начала координат на угол в 5 радиан.
это ли не чудо. длинна отрезка изначального вектора z=0+i*a отображается в угол поворота единичного вектора в новой комплексной плоскости. если мы возьмем
z=0+i*pi/2 по длинне то этот отрезок длинной pi\2 (примерно 1.7) будет отображен
в вектор единичной длинны и повернутый на угол pi\2 то есть на 90 градусов.
прикольно. еще как это можно представить. у нас есть горизонтальный ползунок
и мы по нему двигаем точку и у нас есть экран на котором нарисована единичная окружность и по мере движения поозунка у нас на экране по окружности двигается точка. угол поворота точки по окружности прямо пропорционален величине насколько 
мы перевдинули ползунок. удивительно.

показательная форма она полезна для: Показательная форма удобна для таких операций, как умножение, деление, возведение в степень и извлечение корня

Тут я нашел лекцию в которой обььясняется откуда взялся вот этот ряд который
по определению выражает экспоненту коплексную. оказывается подумали так что
вещественная экспонента обладает двумя свойствами которые нам важны первое
это f(0)=1 и второй что f'(x)=f(x). далее сказали давайте те как возьмем ряд

f(z)=summa(a(n)*z^n)  n=0,1,2,

, далее они пишут что там где ряд сходится можно взять 
произвудную

 f'(z)=summa( n*a(n)*z^(n-1) ).   n=1,2,3 (почему не от нуля непонял)

далее неочень понятно но они выводят из этого то что a(0)=1
и то что a(n-1)=n*a(n)
откуда они выводят что 
e^z=summa ( z^n/n!)

кстати там юзалось что 0^0=1 . я посмотреть в вики и типа ... вопрос  открыт
чему это равно но в случае степеных рядов вроде да принимают что такк.

далее:
задача: вывести формулу для e^(x+iy)=?
вобе=щем есть два доказателтства. одно через производные от e^z но я такое 
не рассматривают иоб тогда надо для начала смотреть что такое производная
для колпексной фнукции. есть другое пболее колхозное докааазательство
берут и перемножают две скобки

e^z1 * e^z2=(summa (z1^n\n!)) * summa (z2^k\k!) =

это две большие скобки .. мы их пермножаем друг на друга а потом группируем 
то что получилось и якобы становится видно что можно так сгрупировать что 
мы получаем

= 1 + (z1+z2) + (z1+z2)^2/2! + (z1+z2)^3/3! + ... =
итаким макаром мы видим что это вылиывается в формулу

= summa ( (z1+z2)^n/n!) а это уже очевидно e^(z1+z2)

таким макаром выводим формулу

e^(z1+z2) = e^z1 * e^z2

ну отсюда получаем

e^(x+iy) = e^x * e*iy = e^x(cos y + i*sin y)
если мы сравним то что справа с тригонометрической формой клмп числа
z=r(cos y + i*sin y)
то мы увидим что то число которое справа имеет длинну r=e^x а уголо поворота y.
значит мы получили что если у нас исходное число z=x+iy то оно отображается 
функцией e^z в вектор у которого длинна равна x а угол поворота равен y
из чего я делаю вывод что увеличение x в аргументе приводит к тому что полученная точка имеет все большую длиннну а увеличение y в аргументе приводит к повороту вектора(вектор , точка  смысл один). 

далее. 
ранее мы получили что

cos x = (e^ix + e^-ix)*0.5

где x это вещественное число. аналогичное для sin x.
так вот незнаю почему нестал разбираться но таким точно макаром вводят и 
комплексные функции cos z и sin z

cos z = (e^iz + e^-iz)*0.5 и это равно  = cos x * ch y - i* sin x * sh y

где sh y = sinh y (гиперболический синус)
ch y = cosh y (гиперболический косинус)

чему они равны:
sh y = (e^y - e^-y) * 0.5
ch y = (e^y + e^-y) * 0.5

ксати они получают что
1\i=-i


далее.
еще раз о показательной форме числа:
берем тригонмтеричкескую форму
z=r(cos a + i*sin a)

из формулы эйлера имеем что e^ia=cos a + i*sina
подствляем
z(r,a)=r*e^ia

эта форма дает удобную штуку как умножать и как делить z1 на z2

z1*z2=r1*e^ia * r2*e^ib = (r1*r2)*e^(i[a+b])

z1/z2=(r1/r2)*e^(i[a-b])

задача:
повернули систему координат на угол a , вопрос какая связь между старыми 
и новыми координатами.

вот у нас есть вектор в старых координатах его вид имеет вид
z1=r*e^ib

когда мы повернули координаты то в новых координатах угол вектора уменьшился 
на угол a значит в новых кооддинатах его вид имеет вид

z2=r*e^i(b-a)

это то как изменились координаты в полярных координатах.
а мы хотим как изменились в декартовых, тогда

 в старых коодиинатах
|x1=r*cos b
|y1=r*sin b


в новых коодинатах
|x2=r*cos(b-a)
|y2=r*sin(b-a)


из первого выражаем 
|cos b=x1\r
|sin b=y1\r

во втором исползуем формулы
cos (a - b) = cos a cos b + sin a sin b
sin (a - b) = sin a cos b - cos a sin b
подствляем во второе

|x2=r*cos(b-a) = r*(cos a cos b + sin a sin b)
|y2=r*sin(b-a) = r*(sin a cos b - cos a sin b)

теперь сюда еще вот это подставляем
|cos b=x1\r
|sin b=y1\r


|x2=r*cos(b-a) = r*(cos a * x1\r + sin a * y1\r) = x1*cos a + y1*sin a
|y2=r*sin(b-a) = r*(sin a * x1\r - cos a * y1\r) = x1*sin a - y1*cos a

итого
|x2=x1*cos a + y1*sin a
|y2=x1*sin a - y1*cos a


итак тема тфкп закончена.
переходим к статье по сигналам: https://www.dsprelated.com/showarticle/192.php

рассматриваем квадратурные сигналы , еще их зовут complex signals.

по факту квадратурными сигналами называют сигналы: 
e^ia
e^-ia

где a=a(t)


если a=(2*pi*f0)*t
e^ia=cos a + i*sin a
и конечно же одчеивдно что
Re (e^ia)=cos a
Im (e^ia)=sin a

если строить график в плоскости где одна ось это "a" а вторая ось это Re (e^ia)
то это будет график косинуса cos a
если сроить график по где гор ось это "a" а верт ось это Im(e^ia) то это будет 
график синуса sin a

тоесть если строить график a от Re (e^ia) то есть будет чисто график cos(x)
тоесть по оси x  у нас чисто x а по оси y будет cos(x)

то же самое для Im(e^ia)

а если мы вводим что "a" это непросто a  а функция времени 
тоесть a=a(t)=(2*pi*f0)*t и еслимы будем по оси x откладывать "t"
тогда у нас будет график не просто cos x а будет уже косинус вида cos kx. тоесть
будем график t, cos[(2*pi*f0)*t]


так..  а если мы рассмотрим функцию z= e^ia + e^(-ia)
тогда будет вот что

e^ia + e^(-ia) = cos a + i*sin a + cos (-a) + i*sin (-a) =
= 2*cos(a) + i*sin a - i*sin (-a) = 2*cos a

итого
e^ia + e^(-ia) = 2*cos a = 2*cos a + i*0 = (2*cos a)e^(i*0)
e^ia + e^(-ia) = 2*cos a + i*0

получается что функция z= e^ia + e^(-ia) она берет аргумент 0+i*a(отрезок на мнимой оси)
 и отображает его в новую комплексную плоскость в отрезок на вещественной оси.
тоесть если функция e^ia она отображает отрезок в точку лежащую на одинарной
окружности то наша новая функция она отображает тот же аргумент но в другое - в точку лежащую на отрезке  который лежит на вешественной оси исключетельно на вещественной оси.
если рисовать график когда будем по гор оси откладывать "a" а на верт оси откладывать e^ia + e^(-ia) то это будет график 2*cos(a). еще раз обращу внимание почему мы можем откладывать функцию e^ia + e^(-ia) всего лишь на одной оси (ведь результат этой функции это комплексное число у которого всегда две координаты тоесть комлпесаня функция это всегда плоскость комплпксаная плоськость то есть там две оси но никак не одна. так вот в нашем конкретном случае мы выяснили что результатом данной функции всегда будет число вида x+i*0 поэтмоу в этом конкретном случае нам хватит одной оси.). итак график e^ia + e^(-ia) от "a" это график 2*cos x от x.
а если у нас a=f(t) и мы хотми по гор оси откладывать время t а не a то это будет график по гор оси будет "t"  а на верт оси будет откладывать 2*cos(a[t])

далее. 
так вот в статье написано что 
если мы еще раз посмотрим на функцию

e^ia + e^(-ia) = 2*cos a + i*0

то мы конечно заметим то что результат это сугубо вещественное число. с нулевой 
комплексной частью. и вот статья говорит что : Implementations of modern-day digital communications systems are based on this property!
пока непонятно что такого крутого в этом. но будет дальше смотреть.

далее еще вспомним другую формулу. 
         [ e^ia - e^(-ia) ]
sin a = -------------------- 
                 2i

тогда:
e^ia - e^(-ia) = i* (2*sin a) 
                 

тоесть компл число 0+ia наша функция маппит в мнимую ось и на ней мы откладываем
отрезок длинной 2*sin a

итак еще раз соберем две наши функции рядышком:

e^ia + e^(-ia) = 2*cos a + i*0
e^ia - e^(-ia) = i* (2*sin a) + 0

итак видно что сумма наших экспонент мапиится в точку исключительно на вещественной оси ( длинаа отрезка 2*cos a )
а разница экспонент маппится в точку исключительно на вещественной оси ( длинна отрезка 2*sin a ).

дальше они пишут мол во классно теперь знаем как наш  косинус от обычного действииельного числа раскладывается в комплексный вид в функцию на комплексной
плокости и даже более того в комплексные экспоненты. (че класного пока непонятно).
тоесть мы сразу теперь знаем что:
cos a = [ e^ia + e^(-ia) ]*0.5
бам! и наш косинус перелез комплексную плоскость

далее.
замечу про связь w и f0:
cos a = тут все понятно. аргумент "a" в радианах.
далее заменяем a=f(t)=w*t
cos wt = посольку аргумент коинуса  в радианах то если a=f(t)= wt
в этой формуле w- это частота в радианах в секунду.а если мы хотим перейти к
к классичсесекой частоте Гц=1\с то  
w=2*pi*f0, в самом деле. по определению периодической функции y(t+T)=y(t).
берем t=0 и T=1\f0 тогда

cos (0+T) = cos (2*pi*f0*(0+1/f0))=cos (2*pi*f0*(1/f0) = cos (2*pi)=1
cos (0)= cos (2*pi*f0*0)=cos (0) =1
1=1 
значит все верно значит доказали что 
w=2*pi*f0 в радианах в сек
f0 в 1\с=Гц

так я о чем. о том что аргумент косинуса можно задвать двумя путями 
через круговую частоту или через герцовую частоту:
cos (wt)
cos (2*pi*f0*t)
конечно w тоже может быть функцией от t. но мы такое нерассматриваем. 
считаем что w постоянная от времени.

далее. 
заметим одну очень инересную вещь.
вот у нас есть сигнал от времени 
y=cos(kt)
мы строим граифк. по гор оси кладем t по верт оси кладем cos(kt).
если у нас разные k то график t,y(t) будем разный. он будет то сжиматься 
то разжиматься вдоль горизонтальной оси. 
действительно, графики от t для функций

y=cos(k1*t)
y=cos(k2*t)
y=cos(k3*t)

они будут все разные. это первый момент.
второй момент  что это графики сигнала (функции) от времени.
поскольку k1,k2,k3 задают частоту сигнала то получается что косинус при 
разных часототах на графике от времени t все время будет разный. однако! и тут
самое главное если мы для первого графика y=cos(k1*t) начнем по оси X откладывать
не время а величину k1*t то мы получим график классического cos x графика.
тоже самое и для y=cos(k2*t) и y=cos(k3*t) если мы будем откладывать на гор оси 
не время а величины k2*t и k3*t то все три графика будут ОДИНАКОВЫЕ! абослютно
одинаковые три графика. по горизонтальной оси мы будем откладыывать так называемую 
фазу а не время как мы делали до этого. фаза это полный аргумент стоящий под косинусом. тоесть y(a)=cos (a), где a это полный аргумент косинуса. этот полный
аргумент зовется фаза, такое вот заумное слово, на самом деле означает всего навсего полный аргумент косинуса и всегото. для примера y(t)=cos(k*t)
в этом случае аргумент "t" но как видно этот аргумент состалвяет лишь часть полного
аргумента косинуса поэтому t  это не фаза. фаза косинуса в данном случае это k*t.
таким образом когда мы слышим слово фаза косинуса равна 0.5 это означает что 
мы знаем полный аргумент косинуса то есть мы можем его сразу подставить 
и узнать чему же косинус равен при этой фазе тоесть cos(0.5). таким образом
дебильое слово фаза наконец стало понятно что это такое - это полный аргумент 
косинуса. если мы знаем фазу то мы мгновенно можем посчитать чему равен косинус
y=cos(фаза). какая связь между фазой и временем. в общем ответ такой что связь 
какая угодно. ее может небыть вообще. в общем случае связь такая 

фаза=фаза(t)  

главное что надо понять что фаза это полный аргумент под косинусом. тоесть
cos(фаза). если нам сказали что фаза=0.6 то это значит что мы знаем все что необходимо чтобы теперь выяснить чему равен косинус  а именно косинус=cos(0.6)

если мы всоппомним что такое косинус по определению  - что это величина катета для точки на окружности единичного радиуса. как мы там пытаемся вычислить этот катет.
мы говорим что 

катет=1*f(x)

где 1 это длинна гипотенузы.
f(x) это некая функция от угла треугольника. таким образом x это угол треугольника
заданный в радианах. так вот эту функцию называют косинус или f(x)=cos(x)
таким образом x это угол! и также как мы уже знаем это фаза. таким образом 
физ смысл фазы это угол , заданный в радианах. понятие фазы имеет смысл только 
когда мы говорим про косинусы(синусы тангенсы итп). полный аргумент какой либо 
другой функции y=f(x)=x^3 абсолютно незовется никакой фазой.

итак мы поняли что фаза это просто синоним для слова "полный аргумент для функции косинус". его физический смысл это угол в радианах. если мы знаем фазу (например фаза =0.1) то мы знаем полный аргумент и значит можем вычислить значение функции
при фазе=0.1 косинус=cos(0.1)
так как фаза это угол то как видно в нем нет никакого времени. откуда же оно берется. если у нас точка ездит по окружности в соовествиии с каким то законом
от времени тоесть x=x(t) то тогда зная время t0 и зная закон x(t) мы можем
вычислить чему равен угол прям щас а именно x(t0). вот так появляется время.
а когда вычислили угол x(t0) то мы вычисили фазу то мы вычислили полный аргумент 
косинуса то мы можем узгнать чему косинус равен cos(x[t0])
закон движения точки по окружноси от времени может быть самый любой нпример
x(t)=e^(35t). тогда угол в момент времени t=10 будет равен x=e^(35*10).
тогда косинус будет равен cos(e^(35*10))
фаза=e^(35*10)

Если мы строим график косинуса не от времени а от угла (то есть от фазы) то есть мы 
откладываем по оси X не время а фазу то никакого времени на графике нет и график 
будет выглядеть всегда ровно одинаково как cos(x). неважно как меняется угол от времени , как бы он неменялся на все равно что угол=0.3 в момент времени t0=10 или в момент времени t0=20. когда по оси x откладываем угол(фазу) cos(угол) всегда всегда всегда один и тот же. и плевать нам на время. 

итак что такое фаза. это угол. еще это полный аргумент для функции косинус.
чем она хороша. для заданной фазы косинус всегда один и тотже! если мы строим
график косинуса от фазы то этот график всегда один и тотже и на нем нет времени. никак. фаза еще хороша там что зная фазу мы сразу вычисляем чему равен косинус 
для этой фазы.

к сожалению в придурковатой школе косинус начинают обьяснять с направления жопы.
тоесть с обратной стороны. берут некий физ процесс типа качающийся маятник. 
далее снимают координату которая меняется от времени. тоесть момент в том что
наш сигнал он изначально завиисит от времени но никак не от фазы. например

x=cos(10*t)

далее рисуют график x(t) , у ученика возникает четкая привязка косинуса к времени.
тоесть человек думает что косинус происходит от времени. и дальше эти придурки 
пытаются впихнуть перевести разговор на фазу. и тут возникает чудовищное непониние
что это за хуета под названием фаза и нахуя она нужна ? если бы эти дебилы 
сказали давайте мы будем немаятник ебаный снимать а точку которая движется по окружности у которой угол поворота меняется по закону phi=10*t
далее мол меряем чему равен косинус при движении этой точки. получаем

x=cos(10*t)

а далее бы эти дебилы бы сказали что давайте нахер теперт забудем провремя. а поступим вот как. мы берем время t0=0, смотрим чему равен угол и чему равен косинус. и далее начинаем строить хитрй график. на гор оси откладываем угол 
на верт косинус. для t0=0  угол=10*t=0 а косинус = cos (0)=1
итак на оси x откладыаем 0 а на оси y откладываем 1 и ставим точку на графике.
теперь берем t0=1, тогда угол=10*1=10, тогда косинус=cos(10)=0.4
ставим на оси x угол 10 и на оси y ставим 0.4 и рисусем еще одну точку. и соединяем сосдение точки.  и вот аллилуйя мы получли гоафик косинуса  в завимости от угла.
и это блядь и называется график косинуса от угла то есть от фазы. и вот что такое 
фаза и какой ее смысл и какая связь с косинусом! но нет эти дебилы так неделают.
фаза это натуральный по приоде родной аргумент для косинуса. но эти дебилы строят
косинус от времени. а потом пытаются принятнуть за уши какую то фазу. 

теперь когда разобрались с фазой переходим к сопряженной следующей теме.
поговоим про ряд фурье.
если есть периодическая функция f(x)=f(x+T) ( и еще там ряд условий на эту функцию налагается)
то она может быть представлена через бесконечную сумму (ряд) синусов и косинусов.
тоесть

f(x)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ]
где n=1 до inf
a(0)..a(n), b(n) это коэфициенты

где 
a(0)=(1/pi)*integral( f(x)dx ) на отрезке [-pi,pi]
a(n)=(1/pi)*integral( f(x)*cos(nx)dx ) на отрезке [-pi,pi]
b(n)=(1/pi)*integral( f(x)*sin(nx)dx ) на отрезке [-pi,pi]



замечу что x - это любая переменная необязатлеьно время. вообще любая переменная

также замечу что для синусов\косинусов в скобках 

фаза=n*x, где n=1,2,3..

тоесть мы раскалдываем функцию по синусам косинусам вида
cos x, sin x
cos 2x, sin 2x
cos 3x, sin 3x
итд


если x у нас это время. тоесть t. тогда
фаза=w*t=2*pi*f*t
с другой стороны мы имеем что 
фаза=n*t
тогда
2*pi*f*t=n*t
тгда
f=n\(2*pi) Гц
если 2*pi~6 тогда мы раскладываем функцию по частотам
f=n\6
тоесть
1\6 Гц, 2\6 Гц, 3\6 Гц, ... 100\6 ГЦ .... 100000\6 Гц

в данном случае видно что 
фаза=w*t ( по поердеению)
и что фаза=n*t (согласно формуле)
получается что w=n
так вот в другом места  я встретил инфо о том что  якобы можно использовать 
непросто w=n а w=w0*n

тоесть класическй фурье раскладывает функцию по 
sinx, cosx, sin2x, cos2x, sin3x,cos3x
а в одном месте я встретли что можно расклдывать по
sin kx, cos kx, sin 2kx, cos2ks, sin 3kx, cos 4kx
незнаю верно ли это.

далее пишут что 
чем больше членов ряда мы возьмем и обсчитаем тем более точное прибижение
мы получим.

замечу мы пока что рассматриваем функцию периодическую относительно x. 
если x это время то сигнал периодический по времени. 
так вот что существенно - то что нам нужно высчитаь коэффициенты a(n) и b(n)
только один раз. они верны для всех x. тоесть нам для каждого x ненужно 
выситывать коэфициенты a(n) и b(n) снова.

приведу разложение в ряд фурье некоео сигнала от балды:

f(x)=0.5 + summa [ cos(n*x) - sin(n*x) ]
или
f(t)=0.5 + summa [ cos(nt) - sin(nt) ]

где n=1.. inf

значит что мы имеем на данный момент. мы имеем то что сигнал имеет
бесконечное количество гармоник. 

получается интересно ( в целом если заметить ) что с точки зрения функции f(x)
все что внутри справа это все числа а переменная только x, а с точки зрения суммы
x это некая константа а переменные это все что с n. 
также получается что каждая точка на графике f(x0) в точке x0 это на самом деле
результат огромной бесконечной по количеству суммы членов. тоесть
например постоили мы график по оси X  у нас x по оси Y у нас f(x)
берем x0=1 на графике ему соовтествует всего лишь маленькая точка (x0,f(x0))
а на самом деле за этой маленькой точкой скрывается огромный рой членов ряда. тоесть

f(1)=0.5+ [ cos 1 - sin 1 + cos 2 -sin 2 + cos 3 - sin 3 ...]

это реальный прикол. что всего каждя маленькая точка функции ее значение 
это по факту сумма огромного ряда членов суммы. это напоминает вот что. лежит на прилавке куча телефонов. но каждый телефон это непросто маленкая коробочка это труд
огромного числа людей на огромном заводе. но на прилавке для человека это ничего 
невидно, для него это всего лишь маленькая коробочка. еще пример.
лежит в магазине хлеб в куче других хлебов на полке. и человеку невидно что этот 
хлеб это результат огромного труда людей и процессов с момента как зерно упало в землю. так и точка на графике этой функции это труд огромного числа синусов и косинусов которые стоят в сумме. функцию можно представит как магазин с его полками.
точки функции это булки хлеба. функция их продает или показывает. а ряд синусов и косинусов это невидимый труд миллиардов синусов и косинусов которые кропотливо создавали каждую точку этой функции но этого совсем невидно том кто смотрим на график этой функции. для него это прото маленькая точка на графике а график это просто маленькая черная ниточка на картинке.

окей. возвращемся обратно. существенно еще раз подчеркнуть
что для периодической функции коэфициенты a(n) и b(n) надо высчтывать только 
один раз. и они верны для всех x. для каждого x ненужно вычитывать коэфициенты
кажоый раз заново.

а рассмотрим как пример
f(x)=sin(x)

sin(x)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ]


высчитаем коэфициенты:
где 
a(0)=(1/pi)*integral( f(x)dx ) на отрезке [-pi,pi]
a(n)=(1/pi)*integral( f(x)*cos(nx)dx ) на отрезке [-pi,pi]
b(n)=(1/pi)*integral( f(x)*sin(nx)dx ) на отрезке [-pi,pi]

тогда
a(0)=(1/pi)* (-cos(pi)--cos(-pi))=(1/pi)*(1-1)=0
a(n)=(1/pi)*integral( sin(x)*cos(nx)dx ) на отрезке [-pi,pi] 
b(n)=(1/pi)*integral( sin(x)*sin(nx)dx ) на отрезке [-pi,pi]


integral( sin(x)*cos(nx)dx )= 0.5( - cos(x+nx)/(1+n) - cos(x-nx)/(1-n)) +Const
integral( sin(x)*sin(nx)dx )= 0.5( - sin(x+nx)/(1+n) + sin(x-nx)/(1-n)) +Const

0.5( - cos(x+nx)/(1+n) - cos(x-nx)/(1-n)) [от -pi до pi]=
=0.5( - cos(pi+n*pi)/(1+n) - cos(pi-n*pi)/(1-n)) - 
- 0.5( - cos(-pi-n*pi)/(1+n) - cos(-pi+npi)/(1-n)) =
= 0.5( - cos(pi(1+n))/(1+n) - cos(pi(1-n))/(1-n)) - 
- 0.5( - cos(pi(1+n))/(1+n) - cos(pi(1-n)/(1-n)) = 
= 0.5 ( - cos(pi(1+n))/(1+n) - cos(pi(1-n))/(1-n) + cos(pi(1+n))/(1+n) +
+ cos(pi(1-n)/(1-n)  ) = 0
значит a(n)=0

 sin(pi(1-n))/(1-n) - sin(pi(1+n))/(1+n)   = 
а далее прикол. поскольку n=1,2,3, то фазы под синусами это либо pi либо -pi
как ни крути. и значит что синусы равны 0. но! данная формула верна только 
для случая когда n!=1 а когда n=1 то надо (как я прочитал ) брать и считаьт 
интеграл руками конкнетно для этого n. 
итак n=1: 
integral( sin(x)*sin(x)dx )=integral( sin^2(x)dx )= 0.5* (x-0.5*sin(2x)) [от -pi до pi] = 0.5* ( pi-0.5*sin(2pi) ) - 0.5* ( -pi-0.5*sin(-2pi) ) = 
= 0.5* ( pi ) - 0.5* ( -pi ) = pi
значит 
b(n=1)=(1/pi)*(pi)=1
значит:
b(n)=0 кроме случая n=1, при n=1 b(1)=1
итого:
для sin(x)
a(0)=0
b(1)=1
b(n!=1)=0

итого разложение в ряд фурье sin(x):
sin(x)=0+summa (0*0+1*sin(x))=sin(x)
sin(x)=sin(x)
ура.

что еще существенно про коэффициенты ряда a(n) и b(n) что они абсолютно независят 
от переменной x. это очень важно отметить.

получается некая функция раскладываться в сумму синусов косинусов в виде:
f(x)=2 + 3*sin(x) + 5*cos(x) - 1*sin(2x) - 6*cos(2x) + ...
тоесть видно что коэфициенты от x независят. и получается наша функция это 
суперпозиция кучи синусоид косиснусоид. как бутто плывет стая рыб мелких разнообразных и она взяла сложилась одна в другую и вдруг вместо стаи рыб мы получили одного большого кита.  это похоже на белый свет и радугу. тоесть 
то что видимый белый свет это суперпозиция стаи цветов разного цвета.
как призма может разложить белый свет на всю стаю так и наверно какойто инструмент
может разложить звук на стаю синусоид. прям трансформер какойто. как бутто звук 
это как тело человека состоящее из армады клеток. армада образует одно целое но 
если захотеть то можно увидеть не единое тело а рой клеток. жалко что звук или свет туда сюда можно раскладыать на составные из целого и обратно в целое из составных а с телом человека так не получится.

так ну это был ряд фурье для через вещественные косинусы синусы. 
щас вывеем ряд фурье через комплкнсные экспоененты:
берем
cos a = ( e^ia+e^(-ia) )*0.5
sin a = ( e^(-ia) -e^ia )*0.5

тогда 
cos (n*a) =   ( e^ina + e^(-ina) )*0.5
sin (n*a) = j*( e^(-ina) - e^ina )*0.5

подставляем в ряд фурье:
(f(x), 0)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ] = 
= a(0)*0.5 + 0.5*summa [  (a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx)  ] 

кстати что в этой формуле полезно еще раз отметмить - формула имеет вид
f(x)=A0*0.5 + 0.5 (A1*e^inx + B1*e^(-inx) + A2*e^inx + B2*e^(-inx)...)
тоесть у нас переменную 


получаем ряд фурье выраженный через комплесные экспоненты.
также слева будем использовать алгебраическую форму комлксного числа 
тоесть то что (f(x), 0) = f(x)+i*0 тогда

ряд фурье выраженный через комплекстные экспоенты:
f(x) = a(0)*0.5 + 0.5*summa [ (a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx) ]

далее я вспоминаю формулу которая позволяет перевести алгебраическую форму
числа в показтельную:
z=sqrt(x^2+y^2) * e^(i*argz(x+i*y))
тогда:
a(n)+j*b(n)= sqrt(a^2+b^2) * e^(i*argz(a+i*b))
a(n)-j*b(n)= sqrt(a^2+b^2) * e^(i*argz(a-i*b))

далее обозначим argz(a+i*b) как phi(n), тогда

a(n)+j*b(n)= sqrt(a^2+b^2) * e^(i*phi(n))
a(n)-j*b(n)= sqrt(a^2+b^2) * e^(-i*phi(n))

подставляем сюда:
(a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx) = sqrt(a^2+b^2) * [
 e^(-i*phi(n)) * e^(inx) + e^(i*phi(n)) * e^(-inx) ] = 
 = sqrt(a^2+b^2) * [ e^(inx-i*phi(n)) +  e^(-inx+ i*phi(n)) ] = 
 = sqrt(a^2+b^2) * [ e^(i(nx-phi(n))) +  e^(-i(nx-phi(n)) ] = 
 = sqrt(a^2+b^2) * [ e^(i(nx-phi(n))) +  e^(i(-nx+phi(n)) ] 

тогда ряд фурье:
f(x) = a(0)*0.5 + 0.5*summa [ sqrt(a(n)^2+b(n)^2) * [ e^(i(nx-phi(n))) +  
+ e^(i(-nx+phi(n)) ]

где phi(n)=argz(a+i*b)

прикольно что в книжках за phi(n) берут argz(a-ib) ттгда соотвеатвенно наш
phi(n) превратиться в -phi(n) 

тогда в итоге в книжках ряд фурье расписыают вот так:

f(x) = a(0)*0.5 + summa [ 0.5 * sqrt(a(n)^2+b(n)^2) * [ e^(i(nx+phi(n))) +  
+ e^(i(-nx-phi(n)) ]

где phi(n)=argz(a-i*b)

далее они еще делают замену и получают вот такой вид:

f(x) = a(0)*0.5 + summa [ c(n) * [ e^(i(nx+phi(n))) +  
+ e^(i(-nx-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)


поговорим о том почему ряд фурье в комплексном виде всегда будет давать точки 
на комплексной плоскости исключтетльно на вещественном луче:
экспоненты как результат на компл проскости они 
дают вектора единичного радиуса и повернутые один на угол 
nx-phi(n) а второй на угол -nx+phi(n). это к чему приводит - это приводит к тому
что сумманый вектор всегда будет лежать на оси X тоесть на вещественной оси
тоесть сумма этих экспонент всегда дает вещественный результат,значит и полная
сумма этих слагаемых даст всегда сугубо вещественный результат.


далее вот что рассмотрим  формулу ейлера:
e^i*x=cos (x) + i*sin(x)

косинуса и синуса у нас классические вещественные. аргумент внутри 
косинуса и синуса это угол. причем он задается в радианах.
значит размерность аргумента вних должны быть радианы.
вообще это интереснрый момент кгда мы обычно рассматриваем формулу в математике
то у нее обычно нет ниаких размерностей хоть тугрики хоть киолграмы хоть безразмерно  а синус и косинус стоят отдельно. у них аргумент имеет размерность.
такая вот подстава. так вот x обязан иметь размерность в радианах по крайней мере
не сам x(тоесть остальная часть формулы может иметь x любой размерности) но то что стоит в скобках  в качестве аргумента у синуса и косинуса дожлно быть преобразовано в радианы.
предположим что x у нас это t время в секундах тогда внутри синуса и косинуса
надо ставить не t а t умноженное на некий коэфициент который переводит секунды в
радианы. назовет этот коэфициент w (радиан\секунду) тогда формула эйлера
кгда у нас переменная x это время t  превратится в 

e^i*(w*t)=cos (w*t) + i*sin(w*t)

далее надо выяснить а чемуже равен этот сраный коэфициент. значит что такое синус 
и косинус с точки зрения физики. это точка движется по окружности по некоторому закону изменения угла phi=phi(t) (хотя может же и сложнее например закон phi=phi(t,x,y) ну не знаю наверно рассматривается более простой случай когда phi=phi(t))
тогда 
если мы говорим что phi=w(t)*t
то w(t)=d(phi)
        -------  (производная от угла по времени)
        dt

Если phi   в радианах то w получается в радиан\с

Тогда ( в случае когда x это у нас t время в секундах) то ряд фурье 
получаем имеет вид:

f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(nt+phi(n))) +  
+ e^(i(-nt-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
где n*t=n*w1*t

w1- некая базовая круговая частота которую мы задаем сами вначале. какую захотим.
с этой w1 реальная мудота для понимания.
об этом ниже.

они почему то постулируют что w от t независит. что w=const от t.
непонятно. ведь w может быть функцией не только от t но и от x вообщето.
ну ладно...

также важно то что аргумент при экспоненте имеет вид i*nt только в случае 
если при нахождении коэфициентов a(n) и b(n) мы там юзаем иниеграл и у него
пределы интегрирования указываются так вот если в экспоненте стоит i*nt то в интеграле должно стять от -pi до pi. если пределы другие например от -pi\2 до
pi\2 то у эксопненты будет другой вид типа i*w1*n*t
где w1- некая константа.  ну суть такая что мы можем разлагать фунцию в ряд
по круговым частотам вида 

1,2,3,4,5,6 

а можем по частотам

w1*1, w1*2, w1*3, w1*4...
вобщем мудота та еще с этим рядом фурье. реально.

тоесть в ряду фурье можно задавать некую базовую круговую частоту и раскладыать 
функцию по синусам\косинусам которые кратные этой частоте.
в моем случае вверху ряд фурье указан для разложения когда w1=1(рад\с)


тогда ряд фурье в более общем случае когда у нас базис синусов косиуснов
выбирается такой что sin w1*t, cos w1*t, sin 2*w1*t, cos 2*w1*t бдует иметь вид


f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)

в заввимимости какую w1 мы берем изначально от этого будут меняться a(n) и b(n)
еще раз w1 откуда мы ее берем. мы берем ее из ниоткуда в том плане что ее вычилсять
ненадо. мы ее сами задаем какой хотим изначаьно и от этого уже ряд фурье пляшем.
выбор w1 влияет на то какими будут a(n) b(n) c(n) phi(n)
 
теперь наконец двигаем дальше - когда высчитали a(n), b(n) то автоматом высчитаем и
c(n) и высчитаем phi(n), нам на выходе нужны c(n) и phi(n). когда мы их вычситали
то строят два графика.
первый график по оси X откладывают 1*w1, 2*w1, 3*w1, 4*w1 по оси Y откладывают c(n)
таким образом мы показываем чему равна амплитуда вектора для каждого n-го члена 
внутри суммы.

второй график по оси X тклывают опять же 1*w1, 2*w1, 3*w1, 4*w1 а по оси Y откладывают phi(n) таким образом для каждого n-го члена внутри суммы мы показываем
чему равно смещение угла(фазы). 

таким макаром из этих графиков мы можем быстро составит чему равен ряд фурье.
например.

w1=1,
c(n)=2*n
phi(n)=1*n

также насколко я понимаю то a0=c0/2

тогда ряд фурье будет такой:

f(t) = 0*0.5 + summa [ (2*n) * [ e^(i(n*1*t+1*n)) +  
+ e^(i(-n*1*t-1*n)    ] =   0*0.5 + summa [ (2*n) * (   e^(nt+n) + e^(-nt-n)   ) ] =
=  summa [ (2*n) * (  e^(t+1) + e^(-t-1)  + e^(2t+2) + e^(-2t-2) + ...) ]
 

еще раз посмотрим на ряд фурье:


f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)


значит по сути здесь  по суммой складывается каждый раз два вектора. 
у каждого из них длинна c(n)
и у одного угол n*w1*t+phi(n) а у другого угол -n*w1*t-phi(n)
по мне для того чтобы построить оба этих вектора перед сложением аболютно достаточно
на графиках phi(n) и c(n) откладвать по оси X только положительные значения такие как 0, 1*w1, 2*w1, 3*w1, 4*w1 итд. этой информации аболютно достаточно
для построения этих двух векторов. При этой частота w1*1, w1*2,w1*3 имеет прямой 
и четкий и понятный физ смысл. но эти придурки как я понимаю чисто для математического выебона делают следующее. они говорят знаете - давайте частоты
1*w1, 2*w1, 3*w1, 4*w1 и вообще все такие положительные чатсоты мы будем их с графика подставлять исключительно только в первую экспоненту  e^(i(n*w1*t+phi(n)))
а во вторую экспоненту мы это подставлять небудем (хотя это полная хуйня), они 
говорят давайте для второй экспоненты мы будем откладывать -1*w1, -2*w1, -3*w1,
-4*w1 итл и соотвественно для графика c(n) будем рисовать ровно тоже самое
что мы рисовали для положительных n*w1. тоесть если было что
c(1*w1)=1 то для  c(-1*w1) откладываем тоже 1
а если было для phi(1*w1)=1 то для phi(-1*w1) откладываем -1

ну тоесть я говорб в чем суть их этой ебнутой придумки. они для 
члена 
c(n) *  e^(i(n*w1*t+phi(n)))  
подставляют значения с графиков c(w1*n) и phi(w1*n)
с правой части этого гарфика когда w1*n>0

а для члена 
c(n) * e^(i(-n*w1*t-phi(n))
они подставляют c(n) и phi(n)
 слевой части графика когда w1*n<0

по мне это полностью искусттвенная ненужная хуйня которой они занялись потому что
абсолютно для обоих векторов достаточно графиков c(n) и phi(n) при w1*n>0 то правой 
части этих графиков. и у нас нет никаких этих сраных отрицательных частот.
то что они делают это сугубо искуственная ненужная хуйня. отсоюда у них и берутся
несущесвтвующие неимеютщие никакого смысла отрциательные частоты.
таково мое мнение.

итак еще раз. зачем нужен график c(n) от (w1*n) и график phi(n) от (w1*n)
они нужны чтобы глядя на них мы могли восстаовить как выглядит рядь фурье. его члены
внутри суммы. при этом графиков при n>0 асболютно для этого достаточно.
то что они русют графики также и для n<0 это аобсолютно ненужная искуственная хуйня.
Это типа так сказать типа у них такая удобняшка что для члена 
c(n) *  e^(i(n*w1*t+phi(n))) 
брать коэфициенты с правой части графиков при n>0
а для члена
c(n) * e^(i(-n*w1*t-phi(n))
брать коэфицицента с левой части графиков при n<0
Еще раз хочу подчеркнуть что кожфициенты в левой части на самом деле получаются из 
коэфициентов из правой части так что левая часть нахер невсралась.
Для графика c(n) все что слева при n<0 ровно тоже самое что справа при n>0.
для графика phi(n) все что слева при n<0 равно тому что справа при n>0 только со знаком минус. 

Ну и собсвтенно как называются эти графики 
c(n) назыается амплитудно-спектральный график
phi(n) называется фазово-спектральный график.

также еще подчекрну что графики эти строятся не от n а от w1*n.

график c(w1*n) при n>0 покзаывает амплитуду  для вектора в сумме который вращается по часовой стрелке по времени, при n<0  амплитуду для вектора коорый
врщается против часовой стрелки.

график phi(w1*n) при n>0 покзаывает фазу  для вектора в сумме который вращается по часовой стрелке по времени, при n<0 фазу для вектора коорый
врщается против часовой стрелки.


таким макаром кое как мы вроде наконц поняли откуда берутся у этих придурков 
отрицательные частоты круговые. их нет а они просто придурки.
круговые часоты введены для вещественных функций а они на ходу начинают их прилепливать к функциям комплексным и начинается полный бардак. 
у вещвественных функций никаких отрицательных круговых частот нет.

хотя с другой стороны вот есть у нас phi=-5*t, значит
|x=cos(-5*t)
|y=sin(-5*t)
совершенно понятно что данная точка летает по окружности в сторону против часовой стрелки. так почему бы нам для вещ функций не определить эту самюу отрицательную 
круговую частоту? это ж так очевидно! а они гворят нет - для вещественных косинусов
и синусов никаких отрицательных частот не бывает. что за хуйня?

еще раз подумаю на тему времени t в аргументе у синуса косиунуса.
далее говорим про косинус(с синусом тоже самое.). что такое косинус. рисуем окружно
сть с радиусом 1. откладываем угол на окружности. причем как мы его откладыаем.
мы откладыаем угол в радианах. что такое радианы. если окружность единчиного радиуса
то ее полная длинна примерно 6 или 2*pi. так если мы говорим что мы отложили угол
phi радиан это значит что мы отложили на окружности дугу длинной phi единиц.таким 
образом угол в радианах это длинна дуги - совершенно натуральная штука ( в отличие
от всяких там стремных градусов и транспортиров.). отложили дугу заданной длинны
получили точку на дуге. от этой точки опускаем верти палку на гор ось и получаем
длинну отрезка это косинус для данного угла phi. таким образм косинус это
функция у которогой аргумент это угол в радианах. отложиди угол померяли косинус.
отложиди угол померяли косинус. вопрос - как нам теперь всунут время t внутрь
косинуса. Прежде всего еще раз - косинус это функция от угла. тоесть косинус 
у него аргумент только угол и больше ничего. Предпожим что угол это функция от времени. тоесть phi=phi(t). Теперь подставляем в косинус 

cos phi = cos phi(t)

если мы знаем t то вычилсяем phi в этот момент t. знаем phi вычисляем косинус.
например phi=e^5t+16t+16t^2
тогда

cos(phi)=cos(e^5t+16t+16t^2)

окей мы засунули t внутрь косинуса.

а если угол завиисит еще от каких то переменных типа от x,y,z 
напрмиер

phi=e^5t+2x+3y+6z

замечу только то что итоговый phi должен быть в радианах получаться при подстановке
переменныха не втугриках каких нибудь.

тогда
cos(phi)=cos(e^5t+2x+3y+6z)

ну все таки мы щас рассматривем сигналы которые обычно зависят только от времени
так что от других перпеменных они обычно независят .у нас обычно есть нарисоанный
полученный сигнал картинка график от времени. так что наверное будем считать 
что phi это функция только от времени. phi=phi(t)
далее очень важно и интересно - по определению w (угловая частота) это d(phi)\d(t)
тоесть производная угла по времени. возникает вопрос почему в ряду фурье 
аргумент у косинуса \синуса имеет вид cos (n*w1*t) и sin (n*w1*t),
где n=0,1,2,... и w1 это константа, тоесть

cos (w1*t), cos (w1*2*t), cos (w1*3*t)

ведь это же должно означать  что закон изменения угла от времени имеет линейный вид!
а именно:
phi(t)=w1*t
phi(t)=2*w1*t
phi(t)=3*w1*t

а он и имеет линейный вид!  (щас скажу почему).
и поскольку закон изменнеия угла от времени имеет линейный вид то линейная
функцция имеет всегда вид y=k*t+b, где k это производная dy\dt и у линейной функции
производная константа! поскольку y  у нас это phi то dy\dt это d(phi)\dt и это равно w! b в нашем случае равно нулю. (щас я скажу почему b равно нулю.).
Так вот ответ на вопрос - почему в ряду фурье аргументы под косинусами имеют вид
k*t,2*k*t, 3*k*t, 4*k*t .... где k это некторая константа, так вот ответ почему так состоит в том потому что мы так задали, потому что мы так захотели! Тоесть как
создавался ряд фурье. мы говорим что мы имеем сигнал f(t). сигнал зависит 
только от времени. и мы сказали - что мы хотим узнать как это сигнал можно представить в виде разложения по функциям:

cos(1*w1*t), sin(1*w1*t), cos(2*w1*t), sin(2*w1*t), .... cos(n*w1*t),
sin(n*w1*t)

где:
w1- некая констана которую мы сами задаем изначально. по нашему желанию.
например w1=10;
n-натуральное число 1,2,3,4,5,6.... infinity

таким образом вопрос почему мол под синусами\косинусами угол изменяется 
от времени по закону phi=n*w1*t ответ такой что мы так сами изначально захотели
задали выбрали заказали! это наше желаение. мы ищем ращложение сигнала f(t)
именно через такой набор так выглядящих синусов\косинусов.

теперь ответ на вопрос почему w1 это круговая частота. точнее даже так почему
n*w1 это круговая частота. с чего мы это взяли? взяли мы это с того что : под косинусом то что стоит это всегда угол в радинах и больше это ничего. еще раз под
косинусом всегда стоит исключиельно угол в радианах. значит

cos (n*w1*t) = cos (phi)
значит
phi=n*w1*t

n- это константа
w1- это констата

находим производную d(phi)\dt
d(phi)\dt=n*w1

значит по опредеению w=d(phi)\dt значит  w(t)=n*w1
таким образом мы видим что наша w независит от времени, она постоянная,
значит n*w1 это коэффициент имеет по своему физическому смыслу тот смысл что 
это круговая частота! соотсвтееенно если n=1 то тогда w1 по своему физ
смыслу оказывается круговая частота. а если n неравен 1 то тогда круговая
частота это n*w1 и в этом случае w1 неимеет явного физ смысла.
если мы под косинусом стоял другой закон для phi например

cos(n*w1*t^2)

тогда
phi=n*w1*t^2, тогда d(phi)/dt=2*n*w1*t тогда w(t)=2*n*w1*t
в этом случае n*w1 неимеет никакого физ смысла . это просто коэфиициент.

Так значит о том что w(круговая частота)=n*w1 если у нас угол имеет вид phi=n*w1*t
мы разобрались - тоесть потому что мы так сами задали захотели чтобы угол
в косинусе менялся по закону phi=n*w1*t. мы так захотели сами изначальано.
а w=n*w1 из определения. потому что w=d(phi)\dt а d(phi)\dt=n*w1

Теперь отвечаю на вопрос почему мы хотим ракслкдыать сигнал именно по 
функциям 

cos(1*w1*t), sin(1*w1*t), cos(2*w1*t), sin(2*w1*t), .... cos(n*w1*t),
sin(n*w1*t)

а не каким то другим. значит данные функции являются гармоническими. 
что такое математически означает гармоническая фугкция - хрен знает. я посмотрел 
както там сложно. важное свойство гармонических функций в том что при прохождении
через линейную систему (что такое линейная система тоже отдельный вопрос я незнаю 
но видимо это важные системы), так вот при прохождении гармонического сигнала
через линейную систему сказано что гармонический сигнал это единственная форма сигнала которая сохраняет свою форму меняется только амплитула и образуется сдвиг 
фазы и все. получается что если мы пропустим через линейную систему скажем вначале
один гарм сигнал , посмотрим как у него имзенится амлитуда и сдвиг фазы. потом
запустим второй сигнал, потом третий. а потом мы запустим сигнал который является 
суммой этих трех сигналов то на выходе мы получим предсказуемый сигнал который
будет являться также суммой исходных трех сигналов  в кажом из которых была изменена
амплиутуда и сделан сдвиг фазы. таким образом пропустив через линейную систему
весь набор гармонических сигналов по отдельности и померяв как меняется амлиутуда
и сдвигается фаза а потом разложив наш произволльный сигнал по этим гармоническим 
сигналам мы будем заранее знать какой сигнал мы будем получать на выходе.
Вот походу зачем и почему мы хотим искать разложение нашего исходного сигнала
именно по такому базису функций.

Значит исходя из лекции из томского политех института - там сказано что данный
набор функций является ортгональным на интервале от t0 до t0+T
где T=(2*pi)/w1
Что такое ортогональность. Это типа как скалярное произведение векторов. мы 
требуем чтобы они были друг относительно друга под углом 90 градусов.
для векторов это выглядит как |a|*|b|*cos(ab) это значит что если между ними 90 градуосов то тогда скаляр произвдение будет равно нулю. у ортогональных векторов
скаляр произвдеение равно нулю. потому что они под 90 градуосв друг относиельно 
друга. Тоже самое водится для функций на интервале (a,b) функции ортогональны
если интеграл  f1(t)*f2(t)*dt = 0 на интервале (a,b) 
соотвственно они там показывают что на интервале (t0,t0+T) интегралы
cos(n*w1*t) * cos (m*w1*t)* dt=0
sin(n*w1*t) * sin (m*w1*t)* dt=0
sin(n*w1*t) * cos (m*w1*t)* dt=0

соотвевенно если функция умножается сама на себя в таком же интеграле то 
как и в случае векторов когда |a|*|a|*cos 0 = |a|^2 также и для функций там 
должна получаться константа. они показыват что да получается константа = T\2
вобщем таким макаром доказыаетсся что нащ выбранный набор функций он ортгонален.
также он полон(хрен знает что это значит) , вобще витоге всю эту бодягу товарищ 
фурье проделал и доказал что для периодичекой функции f(t) ее можно представить
как разложение по гармоническим функциям

f(t)=a0/2 + summa ( a(n)*cos (n*w1*t) + b(n)*sin (n*w1*t) )

где 
a(n), b(n) этокофициенты тоесть они независят от t. это чисто константы которые 
вычисляюются по форумулам через интеграл.
w1 - это константа которую мы выбираем изначально какую нам в голову взбредет.

еще раз почему мы ищем ращложение нашей f(t) именно по 
cos (n*w1*t), sin (n*w1*t)
потому что эти сигналы при проходдждении чере линейную сисему сохраняют свою форму
у них менятеся только амплитула и сдвигается фаза. поэтому если мы разложим наш
сигнал на эти функции то мы можем тогда зараннее предсказать какой сигнал мы полуич
на выходе. это удобно это прикольно.

также прикольно что получается что любой звук (перидоический) можно получить
если взять гитару с бесконечным числом струн. далее дернув каждую струну с нужной
амалитудой и фазой на выходе получим наш искомый звук. это тоже прикольно.  тоесть
наш звук являтеся суммой бесконечного числа дернутых струн. это прикольно.

прикольно то что сигнал можно разложить по таким простеньким сигналам. по вибрирующим струнам. ну или по грузикам дергающимся на пружинках. это очень 
просьенькие сигналы. это чтото типа того как человек состоит из клеток или даже атомов. как книжка состоящая из букв. или как данные на диске состоящие из 0 и 1.
интеерсно можно ли звук или сигнал разложить еще по более простецким по своей форме
сигналам. потому что синус и косинус конечно он простой но все же достотаточно еще
сложный. нужно чтото более еще простецкое. было бы прикольно. 
другой дело что я понял что синус и косинус это якобы единственный по форме сигнал
который сохраняет форму при прохождеии линейной системы. а это важно. другой
отртогональный набор базисных функций этим свойством якобы не обладает.

окей. это я вроде как понял. и частности то что почему phi=n*w1*t.


Далее. 
насколко я понял вопрос о том а что мы делаем если функция у нас не регулярная.
что делать тогда. как я понял делать только вот что. берем ее ограниченную 
слева и справа по X тоесть по времени. то есть берем ее какойто кусок за какоето время.  потом мы ее продолжаем налево и направо по времени так чтобы она стала
приеодической. далее получаем разложение фурье. и на нашем ограниченном участке
разложение будет совпдаать с нашим сигналом. 


Далее.
остается вопрос какой смысл городиь комлплексный ряд фурье чем плохо обычный ряд фурье. в обычном ряде фурье наш сигнал разбивается на графики:
 график a(n) от n*w1
 график b(n) от n*w1

в чем преимущество перед комплесным рядом фурье?
в нем сигнал разбиватеся тоже на два графика:
график c(n) от n*w1
график phi(n) от n*w1

так в чем же выгода?
в другом учебнике про ряд фурье я нашел то что выгода от комлпескной формы
состоит якобы в том что она более компактная. и больше никаких выгод
она недает. 

Еще раз более подробно рассмотрим комлексную форму ряда фурье которую вывел я:
f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)

заменим:
c(0)=a(0)*0.5

получаем:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ]

где:
n=1..inf
c(0)=a(0)*0.5
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
phi(n) = argz(a-i*b)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]

расмотрим а чему равно a(-n):
a(-n)=(2/T)* [ integral (f(t)*cos(-n*w1*t)*dt) на отрезке [-T, T] ]
соотвесвтенно поскольку cos(-x)=cos(x) значит:
a(-n)=a(n)

расмотрим а чему равно b(-n):
b(-n)=(2/T)* [ integral (f(t)*sin(-n*w1*t)*dt) на отрезке [-T, T] ]
соотвесвтенно поскольку sin(-x)=-sin(x) значит:
b(-n)=-b(n)

тогда с(-n)=0.5 * sqrt(a(-n)^2+b(-n)^2) = 0.5 * sqrt(a(n)^2+(-b(n))^2)=
=0.5 * sqrt(a(n)^2+b(n)^2) =c(n)
значит
c(-n)=c(n)

далее
 phi(-n)=argz(a(-n)-i*b(-n))=argz(a(n)+i*b(n))=argz(a+i*b)

далиее сраниваем:
phi(n) = argz(a-i*b)
phi(-n)= argz(a+i*b)

мы видим что справа стоят компл сопряженные числа значит:
phi(-n)= -phi(n)
собственно нам вот эта формула и нужна была. щас мы ее применим.
значит берем ряд фурье:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ]

и разбиваем сумму на две суммы:
summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] =
= summa [ c(n) * e^(i(n*w1*t+phi(n))) ] +
+ summa [ c(n) * e^(i(-n*w1*t-phi(n)) ]

где:
n=1..inf

(тоесть я пользуюсь свойством что summa (a+b)=summa(a) + summa(b). )

далее рассматриваем вторую сумму:
summa [ c(n) * e^(i(-n*w1*t-phi(n)) ]
где:
n=1..inf

введем замену переменной:
k=-n, где k=-inf..-1
тогда:
n=-k
тогда подставляем:
summa [ c(n) * e^(i(-n*w1*t-phi(n)) ] = summa [ c(-k) * e^(i(k*w1*t-phi(-k)) ]
где:
k=-inf..-1

поскольку k это просто внутренний индекс (тоесть неважно какая буква k или n)
то мы юзаем полученное выше свйоство что 
c(-k)=c(k)
phi(-k)=-phi(k)

подставляем это в нашу сумму:
summa [ c(k) * e^(i(k*w1*t+phi(k)) ]
где:
k=-inf..-1



тогда подставляем это в сумму что выше:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] = 
= c(0) + summa [ c(n) * e^(i(n*w1*t+phi(n))) ] + summa [ c(k) * e^(i(k*w1*t+phi(k)) ]

где:
n=1..inf
k=-inf..-1

теперь замечаем что в первой сумме и во второй сумме внутри член стоит 
одинаково выглядящий. просто суммы идут от пределов.
и мы заюзаем такое свойство сумм что :
summa ( a(n) ) + summa ( a(k)) = summa (a(f))

где:
n=a..b
k=b+1..d
f=a..d

тоесть две суммы можно обединить в одну если член под суммйо одинаковый. 
суммы обединятся в одну просто путем обьединения пределов суммы. 
например:
summa (n) + summa (k) 
n=1..3
k=4..5
значит:
summa (n) + summa (k) = summa (f)
f=1..5
деййтвиельно:
summa (n)=1+2+3
n=1..3
summa (k)=4+5+6
k=4..6

значит suuma (n)+summa(k)=1+2+3+4+5+6
саравним с суммой по f
summa(f)=1+2+3+4+5+6
f=1..6
видно что 
suuma (n)+summa(k) = 1+2+3+4+5+6 = summa(f)

значит для нашего случая мы получаем то что:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] = 
= c(0) + summa [ c(n) * e^(i(n*w1*t+phi(n))) ] + summa [ c(k) * e^(i(k*w1*t+phi(k)) ] = c(0)+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
n=1..inf
k=-inf..-1
m=-inf..-1, 1..inf

итак мы получилии что:
f(t)= a(0)*0.5+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1, 1..inf

как видно пределы суммы невключают в себя индекс равный ноль.
рассмотрим элемент суммы при m=0
[ c(0) * e^(phi(0))) ]


phi(0)=argz(a(0)+i*b(0))
a(0)=(2/T)* [ integral (f(t)*cos(0)*dt) на отрезке [-T, T] ]=
= (2/T)* [ integral (f(t)*dt) на отрезке [-T, T] ]=
b(0)=(2/T)* [ integral (0*dt) на отрезке [-T, T] ]=0
значит
phi(0)=argz(a(0)+i*0)=0
значит:
при m=0 имеем:
[ c(0) * e^(0))) ] = c(0)

рассмотрим чему равен c(n) по формуле:
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
мы только что получили что b(0)=0 тогда
c(0)= 0.5*sqrt(a(0)^2+0)=0.5*a(0)
итак элемент под суммой при m=0 он равен 0.5*a(0) если считать по нашим 
общим формулам для a(n),b(n),c(n),phi(n)

значит в нашей формуле для ряда фурье:

f(t)= a(0)*0.5+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1, 1..inf

мы выяснили что при m=0 то что внутри суммы равно a(0)*0.5 это значит что 
мы можем убрать из формулы a(0)*0.5 а в границы сумммирования добавить индекс m=0

тогда наша формула для ряда фурье будет выглядеть:

f(t)= summa [  c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1,0,1..inf = -inf..+inf


ну или если теперь заменить m на n то:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

рассмотрим то что мы получили.
c(n) это чисто числовая вещественная константа. тоесть прям число типа как 5,10,100
если мы посмотрим на формулу c(n) то мы увидим что c(n)>=0 всегда тоесть он точно
никогда неотрицательный. таким образом c(n) определяет длинну вектора комлплексной
экспоненты. 
второ сомножитель это комплексная экспоненты которая выглядит на компелкексной
плоскости как вектор единичной длинны лежащий на окружности единичного радиуса 
повернутый на некторый угол. причем для каждого n будет некоторый инидивидуальный 
угол докрутки phi(n). 
таким образом в целом то что стоит внутри под суммой это на комплексной плоскости
вектора длинной c(n) повернутый на угол пропорциональный n и еще подкрученный
на некоторый индивидуальный угол phi(n). если мы зафиксируем n. тоесть рассмотрим
этот индивидуальный вектор и при этом мы незафиксируем t то этот вектор будет 
вращаться в комплексной плоскости по окружности радиусом c(n) с угловой скоростью n*w1 причем если n>0 то он будет вращаться против часовой стрелки а если n<0 то против часовой стрелки. при фиксированнном n  у нас c(n) и phi(n) это константы.
таким образом длинна вектора будет постоянная тоесть как я и сказал что вектора
будет описывать окружность. phi(n) получается задает начальную фазу (если мы рассматриваем на момент времени t=0) или сдвиг фазы. при изменнеии t вектор начнет
вращаться с постоянной угловой скоростью n*w1 (n фиксировано. w1 - начальная константа). 

так. я щас немножко еще перепишу формулу:
f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ] = summa ( s(n) )

так вот если мы зафиксируем t, и рассмотрим s(n) и s(-n)
то мы увидим из того что получали ранее что эти два вектора в компл плоскости
они имеют одну длинну и зеркально относительно гор оси повернуты. тоесть эти компл
числа (вектора)  они сопряженные. это значит что при сложении этих двух векторов
их сумма всегда будет лежать на оси X тоесть результат вещественное число. тоесть
таким макаром мы еще раз доказали что вся сумма это вещественное число.

далее исходя из этой формулы строят два графика:
c=c(n)
phi=phi(n)

хотя не совсем так. еще домножают на изначальную константу w1 тоесть
c=c(n*w1)
phi=phi(n*w1)

поскольку n= -inf..+inf
то это значит что n у нас принимает как положительные так и отрицаттельные
значения на графиках. соотвевтенно при отрицательных n  у нас под суммой генерируются экспоненты (вектора) которые при измении t вращаются против часовой стрелки а при положительных n у нас гененрируеются экспоненты которые вращаются 
при изменнии t по часовой стрелке. 

итак еще раз посмтрим на полученный вид ряда фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

значит для примера скажем для какойто фукции он выглядит вот так:
(я взял w1=1 для примера также):

f(t)= 2*e^(i(-100*t+1)) + 3*e^(i(-99*t+2)) +...+ 6 + 3*e^(i(99*t-2)) +
+ 2*e^(i(100*t+1))+... 

зафиксируем некоторый момент времени t0.
что по факту мы видим в правой части - мы видим кучу векторов постоянной длинны которые складываются по правилам сложения векторов ну и как мы знаем они дадут вектор у которого 
вторая координата ноль, тоесть вектор будет лежать на оси X. и его первая координата
и будет f(t). если мы начнем менять время то конструкция оживет. если мы дадим приращение времени t0+dt то вся эта гирлянда векторов сдвинется , вектора начнут вращаться кто-то по часовой стрелке кто-то против часовой в зависимости от знака
перед t, и они начнут вращаться с постоянными угловыми скоростями равными тому 
что стоит перед t. еще как можно сказать - вот у нас зафиксирован момент t0. все вектора неподвижны. мы находим их сумму. потом мы сдвинули время на t0+dt и у нас
картинка оживет - у нас все вектора повернутся на некоторые углы в зависимости какой
коэфициент стоит перед t и далее конструкция опять остановится замрет. и мы опять посчитаем векторную сумму этих векторов и получим f(t0+dt). Эта красивая картина. 
мне это напоминает часы с шестеренками. каждый вектор это своя шестеренка в часах.
часы стоят. мы берем крутилку сзади у часов и чуть чуть ее крутим (тоесть делаем t0+dt) и тут же все шестеренки приходят в движение и в итоге стрелка на морде часов
передвигается на некоторое расстояние . стрелка на морде часов это и есть f(t0+dt).
Очень красивая получается концепция. Еще и потому что вектора также как и шестеренки
крутятся действительно по окружностям. И еще аналогия красиво совпадает в том плане
что в часах с шестеренками большие шестеренки вращаются медленно а мелкие шестеренки вращаются очень быстро. Также и здесь - есть вектора у которых большая угловая скорость они будут делать за единицу времени очень много оборотов вокруг себя а есть вектора у которых малая угловая скорость и они будут вращаться очень медленно вокруг себя за единицу времени. тоесть когда мы покрутим крутилку то какието вектора повернутся на очень много оборотов а какието еле сдвинутся. это ровно тоже самое как в часах. мы немного поворачиваем крутилку и мелкие шестерни очень много раз повернутся а крупные шестерни еле еле повернутся. Остается понять 
какая аналогия с амплитудами у векторов и шестернями в часах , что у них общего.

далее я пока откладываю тему шестеренок в будильнике на потом.


дальнешие размышления замечания про всю эту тему:
Если мы умножаем комплескное число на комплексное число то что будет
их результатом - будет еще одно компл число у которого длинна вектора будет
произведение длин векторов и угол поворота  сумма углов обоих векторов.
тоесть z1*z2=r1*e^i(a1) * r2*e^i(a2) = (r1*r2)*e^i(a1+a2)
теперь рассмотрим частный случай:
z1*e^ia=r1*e^ib*e^ia=r1*e^i(a+b)
таким образом если мы умножаем компл экспоненту на произвольное компл число то
результат будет вектор который по длинне равенр длине вектора z1 и довернулся
на тот градус который имел вектор z1. тоесть если у нас экспонента это функция 
времени а z1 это константа относительно времени , то чистая экспонента как известно  выглядит как единичный вектор вращающийся по окружности так вот
домножение ее на z1 дает то что это будет не единичный вектор а вектор длинной z1
и он который в момент времени 0 будет иметь начальный повопрот - начальную фазу начальный сдвиг фазы. вот это для понимания. 

далее если мы рассмотрим две экспоненты e^ia и e^-ia то это вектора который сопряжены друг к другу. e^ia это единичный вектор который повернут на угол a, 
а e^-ia это единичный вектор повернутый на угол -a если мы теперь рассмотрим
их сумму 
e^ia + e^-ia то это будет вектор который имеет только вещественную часть. 
если у нас a это функция от времени a=a(t) то первый вектор если смотреть по времени
он будет вращаться по окружности по часовой стрелке а второй против часовой стрелки.

если у нас есть z1 и z2=z1(сопряженное )  и мы рассмотрим такую сумму:
z1*e^ia+z2*e^(-ia) то что это будет. 
первое слагаемое это вектор длинной z1 и он повернут на угол a+b
второй вектор той же самой длинны и повернут он на угол -a-b таким образом
у нас два сопряженных вектора которые нужно сложить. их сумма это всегда 
вещественное число. если a=a(t) то тогда первый векторввращается по часовой стрелке
при изменении t а второй враается против часовой стрелки. теперт вспомним
ряд фурье в форме:
f(t)=a0*0.5+summa [ 0.5*(a(n)-b(n))*e^(i*w1*t) + 0.5*(a(n)+ b(n))*e^(-i*w1*t) ]
так вот если мы присмотрися то то что стоит под суммой это вточности что 
я описал выше
z1*e^ia+z2*e^(-ia)  
где z2=сопряженное от z1

таким образом сумма двух векторов под суммой это вещественное число. длинна
этого вектора это длинна бОльшей диагонали паралеллограмма и она равна
D=sqrt[ |z1|^2+|z1|^2+2*|z1|^2*cos (2*(argz(a-i*b))) ] и вот эти вот диаогонали
под суммой и будут складвыаться в бесконечном ряду.

По сути под суммой складываются два сопряженных вектора z1 и z1(сопряженное)
кажды из которых повернут на доп угол (w1*t), тоесть физический смысл 
того что под суммой это сложение двух сопряженных векторов но они еще чуть чуть
развернуты на дополнительный дельта угол за счет экспонент, по факту после доворота
оба вектора  по отношению друг к другу остаются сопряженными. так что по по факту 
мы изначально имели два сопряженных вектора и после домножения на эксопненты имеем
два сопряженных ветора. которые надо сложить. вот такой физ смысла того что под суммой стоит. тоесть вот теперь то что под суммой из непонятного месива формул
стало понятным. его физ смысла как это выяглядит. 

Далее.
рассмторим 
z=e^ia
где 
a=a(t)=k*t, k-константа
тогда
z=e^i*k*t
пусть k>0 тогда если мы будем сроить вектор z и менять время то вектор z это будет
единичный вектор который вращается по окружности против часовой стрелки 
с круговой частотой относительно времени k.
если же k<0 то все тоже самое только вектор вращается против часовой стрелки.
пусть n=|k| тогда n=-k тогда
z=e^i*k*t=e^i*(-n)*t=cos (-n*t)+i*sin (-n*t)
что я не могу понять это то что они пишут что у вещественых фукций небыавет
отрицательной круговой частоты. что за бред. коэфицицент что стоит при t это формально угловая частота. так что w=-n, где n>0 тоесть мы имеем отрицательную угловую частоту у вещственной функции. посольку w=d(phi)\dt то знак показывает
то что угол со увеличением времени он падает а нерастет. ну и что. что тут такого.
то что производная отриццательрная в этом нет никакого чуда. поэтому  янепонимаю
почему эти придурки пишут что у вещественый фуннкций нет отрицательной угловой частоты. есть она. а что тогда делать с периодом ? ну я думаю что T=2*pi/|w|
поэтому и V=1\T будет положительный даже если w<0 ну и что. да. 

далее.
итак еще раз посмтрим на полученный вид ряда фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

как на практиеке может выглядеть этот ряд:
f(t)= 0.5 + 1*e^(i*2*t+3) +1*e^(-i*2*t-3)...
или
f(t)= 0.5 + e^(i*2t+3) +1*e^(-i*2t-3)...
график АЧХ будет выглядеть:
в  точке w=-2 аплитуда A=1
в  точке w=0 аплитуда A=0.5
в  точке w=2 аплитуда A=1
график ФЧХ будет выглядеть:
в  точке w=-2 фаза phi=-3 рад
в  точке w=0 аплитуда phi=0 рад
в  точке w=2 аплитуда phi=3 рад

Прикольно то что мы бы хотели изобразить нащи экспонеты в графическом виде 
в форме вектров. но проблема в том что время меняется поэтому както конкретно
нарисовать вектора в этом случае невозможно . нам нужно избавится от времени 
в том плане что бы графики независиели от времени. поэтому мы вместо векторов
изображаем на графиках константы с точки зрения времени . тоесть амплитуду и фазу.
как бы врем неменялось ампдитуда и начальная фаза остаются теми же самыми.

хочу подчеркнуть что c(n) у нас всегда вэтой формуле вещественый.это важно отметить
мы имеем сложение кучи векторов. каждый вектор если мы будем его 
рисовать на плоскости компл то он будет вращаться при имзенениии времени t.
угловая частотв вращения вектора будет w1*n. в завимиости от знака он вращается
против либо по часовой стрелке. если мы хотим в некоторый фиксированный момент времени t0 построить вектор на компл плокости то мы должны взять n оно определяет
какой вектор мы хотим строить. и для этого вектора определить его длинну тоесть c(n)
и его угол поворота то есть n*w1*t0+phi(n), посколльку вот это мы знаем n*w1*t0
то нам надо только узнать  phi(n). таким образом для каждого вектора который 
характеризуется n мы должны вычислить\узнать\выяснить c(n),phi(n)
поскольлку  n = -inf..+inf это значит что у нас n<0 есть и n>0 есть. так что
график c(n) и phi(n) будет иметь точки и слева от нуля по оси X и справа. 
графие будет дискретный так n   у нас дискретные. каждая n характериузует
собой значения c(n) и phi(n) для очередного вектора. если знаем n,c(n),phi(n) 
то знаем как построить очередной вектор под суммой. До этого моменты мы фиксировали время t0 но меняли вектора.щас наоборот зафикисруем n но рассмотрим вектор у которого t как переменная тогда наш вектор

c(n) * e^(i(n*w1*t+phi(n))) = с * e^(i*n*w1*t+phi)
где c,phi,w1 константы. а t переменная.  
данный вектор в момоент времени t=0 имеет начальный угол повопрторта (начальная фаза) phi. он вращается (меняет угол)  вокруг начала координат при имзеннеии времени t с уголвой скорость n*w1 по часовой либо против часовй в зависиомти от знака  n. это значит что угол вектора как функция от времени является перидической 
функцией для данного вектора. тоесть если угол это q то q=q(t)=q(t+T) посколльку
T завиит у вектора от угловой частоты а угловая частота вектора это n*w1 
то имеет смысла откладывать графики не в виде c=c(n), phi=phi(n) а в 
виде c=c(n*w1), phi=phi(n*w1) это нам дает то что для каждого n (тоесть для каждого вектора) мы знаем его амплитуду c , мы знаем его начальную фазу phi и знаем 
с какой периодичностью (как быстро ) он вращается по времени (тоесть изменение его угла по времени ) вокруг начала координат(другими словами мы знаем период по времени для данного вектора тоесть через сколько время он совершает полный оборот ну или другими словами сколко оборотов  в секуду он совершает). а что нам это дает?
вот возьмем конкретный вектор:
n=100
w1=1
c=10
phi=0
что тогда мы из этого понимаем:
амплитуда у него 10.
в момент времени t=0 его фаза (угол поворота) =0+0=0 тоесть он лежит на оси X,
фазу знаем угол знаем - значит мы уже его сможем помстроить на компл плоскости, окей
построили. отлично. это нам и надо было. в плане его угловой частоты w=n*w1=1*100
значит этот вектор за секунду поворачиватеся 100=2*pi*V, V~30 раз. вектор за секунду
поворачиватся 30 раз. мы это узнали потому что на графике мы откладывали не просто n а n*w1. тоесть мы сразу из графика видим что у вектора n*w1=100 и сразу из графика понимаем что этот вектор вращается  30 раз в сеунду. если бы мы на графике откладывали по гор оси просто n то чтобы понять как часто вращаетс вектор характеризуемый числом n нам бы надо было лезть смотреть как выялядит ряд находить там w1 и считать. а так нам сразу это видно из графика. 
Итак еще раз у нас есть ряд фуурье в компл виде. предсталвяет собой сумму. под суммой стоит элемент с порядковым номером n. по факту это вектор на компл плоскости. у этого вектора фаза угол это функция от времени а апитуда по времеи постоянная. поэтому если мы будем рисовать этот вектор на компл плоскости
и менять время то он будет вращаться. поскольку он вращается то через какое то время он вернется в исходное положение. тоесть его угол это перидоическая функция или  с другой стороны это значит что он за единицу времени сделает сколько то кругов. поэтому нам для каждого вектора удобно иметь следущую таблицу парметров которая независит от t:
длинна вектора = c
начальная фаза =phi
частота вращения вокруг начала координат = n*w1

зная n,c,phi,w1 из таблицы мы всегда можем построить вектор на компл плоскости 
в для любого моммента времени t, зная n и w1 мы знаем как часто вектор вращается вокруг начала координат.  таблицу для n,c,phi,w1 удобней всего записать в форме
двух графиков :
c=c(n*w1)
phi=phi(n*w1)

Итак параметр n*w1 нам дает инфо какая угловая частота вектора. а зная его угловую частоту ( а мы также знаем что она от времени независит) мы знаем как часто он вращается в секунду. именно для того чттбы можно было из графика определить угловую частоту для вектора n мы на оси X откладываем не n а n*w1. Окей с видом графиков 
разобрались. зачем там n*w1 тоже разобрались.

Разберемся  еще вот с чем - вот у нас есть два вектора s(n,t) из этой суммы.
в чем их разница ? в чем разница вклада одного вектора s(n1,t) по сравнению с вкладом
другого вектора s(n2,t) в конечный вид графика f(t)

положим что w1=1. тогда w=1*n=n 
тогда рассмотрим два вектора

s1=s(10,t) = s1 имеет w=10
s2=s(1000,t) = s2 имеет w=1000

в чем их разница в плане вклада в вид f(t) графика. 
положим для простоты что у нас под суммой не бесконечное множество векторов а всего два. это значит что финальный вектор тот который и будет (f(t),0) он будет скалдываться всего из векторной суммы двух векторов s1+s2. совершенно очевидно что 
в завиимости от момента времени данные два вектора будут друг относииелно друга
иметь какойто угол. а это значит что в завимости от времени суммарный вектор будет 
по длинне от |c1-c2| до |c1+c2|. где c1,c2 это амплитуды s1,s2.
пусть c1=100, c2=1 тогда суммарный вектор по длинне будет меняться от 99 до 101.
( да мы при этом помним что на самом деле под суммой не два а туча векторов и то что они там на пары разбиваются и это дает то что суммарный вектор будет лежать на оси X но это щас все неважно). так вот в чем разница между s1 и s2 в плане их влияния на суммарный вектор s3 тот который нам и дает (f(t),0).  возьмем время t0
отложим вектор s1, отложим\построим вектор s2 и найдем их векторную сумму s3=s1+s2
теперь немного сдвинем время  t0+dt,  мы увидим что за время dt вектор s1 сместится на плоскости слабо потому что у него w маленькая. а вектор s2 сместится на очень большой угол потому что у него w очень большая. получим новый s1' и s2' 
построим новый s3'=s1'+s2' так вот вознкикает вопрос какой из данных векторов s1 и s2 внес бОльший вклад в изменений амплитуды вектора s3? ответ конечно s2 потому что он меняет свое простанственное положение намного более резко чем s1. а нам суммарный s3 вектор его длинна очень как раз зависит от простсранстевенного положения векторов s1, s2 относиельно друг друга. ну опять же мы помним что что 
под сумммой стоит не два вектора а туча и то что в конечном итоге их вертикальные 
компоненты дадут ноль при векторном сложении и останутся только горизонтальные компоненты таким образом на f(t) влияет горизонтальная проекция всех векторов их сумма поэтому чем сильнее за вермя dt вектор помено свое пространственное положениетем сильнее у него поменлась его горизонталная проекция и тем сильнее этот вектор влияет на изменнеие конечной суммы всех проекций. в итоге я бы сказал так ч
что чем меньше частота у вектора тем его амплитуда на отрезке времени играет роль как бы базово несущей в форму графика f(t) а чем выше частота вектора тем его амплитуда играет основную роль в изменение формы f(t).  скажем 
если вектор имеет маленькую частоту то он на отрезке времени [t0,t+dt] будет 
давать вклад в f(t) скажем как число 5 которое почти неменяется. а вектор
который высокочастоный он будет на этом участке по 1000 раз менять эту пятерку на величину 5+[-1,+1]. тоесть он будет придавать волнистость этой пятерке. 
пока на этом пауза.

Немного отодйем в сторону:
амплитудная модуляция. 
по определению что такое амлплитудная модуляция. Это когда у нас есть исходный сигнал который нужно передаь по радио. Исходны сигнал это голос. 
Что мы делаем - радио волна имеет частоту намного больше чем голосовая волна. Щас
 я обьясню. Мы берем микрофон и колебание мембраны в микрофоне формирует в проводах от микрофона колебания напряжения в контуре микрофона с той же частотой что и колебаия воздуха от голоса. Эти колебания это типа 100Герц-20,000 Герц.
 Далее в чем проблема отослать  в эфир радиоволну частотой скажем 10,000 Герц. 
 Проблема следущая - проблема в длинне волны.
 То есть Если у нас частота V=10,000 герц. То период T=1/10,000 секунд. А длинна волны это растояние которое пробегает воолна за периол. значит 
 lambda=c*T=3*10^8 * 10^(-4)=3*10^4 метров = 30км. 
 30 км пролетает волна за период. это ее длинна. длиннна радиоволны. так вот
 известно что размер антенны должен быть равен половине длинны волны. значит надл
 ставить антенну размером 15км. Поэтому передать голос на тойже частоте радиволны
 нереально. (прикольно что по проводам коротким без проблем передавать элекртрическую вполну волны блядь длинны при этом. Тоесть через провод длтнной 1метро можно спокойно передать волну длинной 30км). Поэтому электросигнал 
 в проводе от микрофона непередают на тех же частотах которые имеет сигнал от голоса в проводах микрофона. Вместо этого берут радивоолну у которой частота 
 услоно говоря в милллионы раз больше и передают через нее. Так вот что такое по 
 опредеению амплитудная модуляция. Если у нас есть исходный сигнал  U1 то мы его 
 используем как амплитуду на частоте радиволны. тоесть.
 wr- частота радиволны. Тогда амплитудно смодулировыннй сигнал это 

 U2(t)=U1(t)*cos(wr*t)
При этом мы помним что что энергия из батарейки радиостанции тратится на образование
апмлитуды. так вот в этом случае видно что вся энергия тратися искоючительно на 
передачу именно полезной информации. так вот эти долбоебы они делают не так . Они делают по другому. Они делают вот так

U2(t)=cos(wr*t)+U1(t)*cos(wr*t)

при этом получается что батарейка радиостанации тратит энергию на образование 
амплитуды так называемого несущего сигнала. и на образование аплитуды уже полезного сигнала. Захуя так делать я вобще непонимаю. Преобразуем формулу:

U2(t)=[1+U1(t)]*cos(wr*t)

Тоесть видно что к нашей полезной аплитуде которая перадеает информцию добавлятся
некая ебануто беспооезная константа несущего синнала. нахуя? она просто выжирает доп энегию из батарейки радисотавннции а ничего полезного в себе ненесет.

Единственное что я могу прдположить почему так ебануто делат потому что чисто физически на уровне микросхем дешевле генерировать волну именно вторым способом
не вплане энергозатрат а в каких то других электротехнических планах в том числе
например в том плане что на приемнике техника которая будет декодировать сигнал 
она будет стоить дешевле.Я только так этот ебанизм могу обьяснить. 




- Так - тут целая огромная куча вопросов вылезла:
Если мы берем звуковые волны которые за речь отвечают то непонятно зачем 
динамик который излучает должен быть каких то там опредееленных геометрических
размеров я вообще нихуя не пойму. Предпожоим у нас есть точечное тело. Мы его дергаем по закону y(t)=10*cos (2*pi*1*t) Это точечное тело ударяет окружающий воздух
. Воздух считаем некими упругими шариками поэтому вот это смещение оно смещает 
соседа а тот своего соседа  и у нас вот этот вот удар полетел по воздуху. фронт удара фронт волны полетел в стороны со скоростью звука. и данный удар долетает 
до уха и отклоняет перепонку ну или точку в ухе на такое же смещение грубо говоря
наша ушная перепонка начинает колебаться ровно по такому же закону. 
тоесть у нас есть источик звука некаая точка которая колбелется по закону

y(t)=10*cos(2*pi*1*t)

и у нас с некоторым отставанием ровно по тому же закону колбелется точка в ухе

q(t)=10*cos(2*pi*1*(t+phi0)

phi0-смещение фазы из за того что удар от источника звука смещение точки 
немгновенно попадает в ухо а через некоторое время обусловленное временем за которое воздух передает возмущение от источника в ухо. 
как бы получается что у нас есть два грузика колеблящихся на пружинке .
один грузик это исчоник звука а второй это ухо. воздух играет роль передатчика.

Это мы рассмотрели передачу волны 1Гц. 
Речь это суперпозиция кучи волна от 20Гц до 20Кгц.
Что значит суперпозиция на практие с точки зрения двигающегося грузика. Этовсего навсего значит что закон смещение грузика от времени y(t)более сложный чем 
y(t)=10*cos(2*pi*1*t)

он будет выглядеть как ряд фурье:
y(t)=summa ( a(n)*cos(w(n)*t+phi(n) ) )

по факту на практие это просто точка которая дергается вдоль линии в пространстве
по какомуто сложному закону y(t)

так вот что я нихуя непойму где здесь требования на размер излучателя?
Если есть точка которая дергается вдоль линии с частотой 20Гц то она должна излучать
звук частотой 20Гц тоесть бас.  я непонимаю почему это неможет быть точка а должна
быть мембрана некоторой площади? что за нахуй?

Что еще реально ебануто и поразительно. Вот есть два вариант волны.
Если дует сильный ветер то как я понимаю он выдувает некое углубление в воде
за углублением получается возвышенност холм ровно также как если взять лопату
воткнуть ее в землю и начать толкать лопату вперед и получается что ветер
он как бы берет верхний кусок воды и пытается эти частицы вытолкнуть туда вперед далье и эти частицы реально передвигаются вдоль горизнтальной плоскости как бутто их гарпуном зацерили или плугом и тащат вперед. тоесть реально верхний слой воды
под дуновением ветра он двигается как автомобиль по дороге. и мы видим волну которая
двигается. совершенно другая волна если кинуть камень в воду. нам кажется что частицы верхнего слоя воды как бутто стартуют от камня и потом их тащит по воде
наружу. но это полная хуйня это совсем нетак. происходит совсем другое. происходит как если бы вода была простыней и какотой бежит мужик под простыней и там где 
он бежит он эту простыну вверх задирает. таким образом в каждой плоскости воды частица она по горизонту никуда несдивигается она только поднимается вверх на какоето время и пото обратно возвращается вниз. волна же бежит потому что под водой бежит невидимый мужик и постоянно над собой поднимает простыни. 

Я посмотрел как выглядит генератор волн в басейне. Это просто один из торцов басейна
который просто толкает воду - чем чаще он толкает тем более частотная волна чем реже
тем менее частотная. так что там вообще остуствует понятие какого то размера 
генератора волн. размером генератора посто служим ширина басейна и его высота. 
собственно может быть любая ширина и высота этого басейна. 

Если у нас скорость передачи фронта это c а период это T то получается что 
расстояние между пиками на воде это lambda=c*T.
тоесть вот мы ладонб удаоили по воде и пик фронт побежал по воде. если скорость
его бега равна C то за время t он убежит от нас на расстояние C*t.
если мы ударяем по воде ладонью каждые T секунд то через время T тот пик убежит 
от нас на расстояние c*T=lambda= длинна волны.  Когда смотришь на график y(t)=cos(t)
то интуитивно кажется что Период T на графике это длинна волны ибо мы же видим что
T это расстояние между пиками на графике. Но это опять же полная хуйня , интуитиция опять наебала. Ибо T это время измеряемое  в секундах а если у нас график y=cos x 
то расстояние в PI это даже не время в секундах это период в радианах. Ммммм. тоесть я что хочу сказать формально период это если у нас ест график функции 
y=y(x) где x люая величина это может быть время в секундах, это может быть градусы в радианах это могут быть метры. Нам похуй. ТАк вот перид это наименьшая хрень такая что x(t)=x(t+T) так что период может измеряться в любых величинах. в радианах , секундах, метрах. все зависит от размерности х. Если мы нарисуем график профиля 
воды в басейне в момент времени t0 тоесть y=y(x,t0) то то что мы называем длинна волны это есть период на это графике и он измеряется в метрах. это пиздец это просто поразительно. 

ДАлее. походу  я что еще понял.
как у человека генерируется звук. в горле стоят связки голосовые. сквозь них продуваем мы воздух. когда он сковзь них протелает то они автоматом начинают вибрировать. И полученный на выходе звук идет как несущая. Как я понимаю 
в ряду фурье это будут первые гармоники которые задают некую несущую низких частот.
а уже ртом языком мы добавляем высокочастотные гармоники. хотя по идее все выглядит 
на оборот - связки дают высоко частотные гармоники а язык с челюстями добавляет низкочастотные. вобщем хуй знает как речь формируется. в вики я прочел что связки 
дают 60-300Гц колебания. тогда вопрос а чем тогда мы генерируем высокие частоты ? ответ ничем.
получается что мы связками делаем несущую. тоесть сразу за горлом в рот летит 
моно звук (ну или смесь низкочастотных гармонических колебаний) на слух это выглядит так что из горла летит некий монтонный звук. вопрос что дальше
происходит во рту с точки зрения частоы, аплитуды, фазы.
Я пока вот как все это вижу. Из горла вылетает низкочастотный звук - этот звук
будет выглядеть как первые гармоники если вылетевший звук раскладывать в ряд фурье.
Ксати про раскладку в ряд фурье - во первых наша речь состоит из букв - например слово "мама" это четыре отдельных буквы мы произносим. каждая буква это некий короткий импульс по времени. а далее вот что - чем более короткий по времени импульс и чем более у него сложная форма фронта сигнала тем более широкий
спектральный ряд гармоник нужен чтобы через ряд фурье его сформировать. как я понимаю гласные звуки имеет более короткий спектр гармоник. а вот согласные
уже имеют широкий спектр гармоник. что же делает рот когда звук в него влетел из горла когда мы хотим сказать согласную букву - я думаю что рот берет условно говоря гармоническое колебание из горла и рот уродует у него форму. и чем более мы изуродовали форму колебания тем больше высокочастотных гармоник нужно в ряду фурье подключить чтобы такую форму сформировать. насколько я понимаю рот это делает таким образом что он гасит резко амплитуду колебания получаются резки обрывы фронта.
так чтобы такой рваный сложный фронт организовать из гармоник то нужно дохера гармоник высшего порядка. я к чему - как можно формировать звук - можно его формировать из неких генераторов звука разной частоты -то есть можно работать со стороны генераторов колебаний. а можно работать из конца тоеть можно брать уже колеблящийся звук во рту и гасить его тогда график f(t) будет адово уродоваться что
эквивалентно тому как если бы во рту стояла куча высокочастотных генераторов. но их там нет. Тость еще раз - на форму звуковой волны f(t) можно влиять с двух концов - 
один конец можно формировать график за счет запуска кучи осцилляторов которые будут складываться в некий суммарный f(t) так работает оркестр из кучи муз инстрементов.
а можно еще действтовать с другой стороны - можно брать уже готовое колебания воздуха и .... я полагаю что может быть у нас буквы это  с точки зрения сигнала то что очень по разному амплитуда меняется у сигнала. тоесть мое пока предположение что из горла вылетает примерно говоря гармонический моносигнал там одной частоты
или узкой полосы низких частот. а буква нашим мозгом воспринимается как то что 
мы своим ртом умудряемся сильно менять амплитуду. более точно ее как то хитрожопо
гасить ртом. и вот эта рваная амплитуда воспринимается как буква. тоесть я к тому 
что рот неменяет часту он меняем очень сильно амплитуду путе того что он ее 
видимо поглощает и всякую там доп микроформу на нее навешивает. 
хм.. еще вот такую идею прочитал - что из голосовых связок идет именно некий спектр частот. так вот измение обьема рта и прочие фокусы язяка и шевеления челюсти приводит к тому что рот становится типа резонатором определнных частот. 
но вот что еще интересно  - звук "к" или "п" можно сформировать вообще с выключенными связками голосовыми тоесть нет несущей частоты. тоестьт это похоже на удар молотком по столу тоесть процесс образования звука похож на то что мы имеем во рту плотно сомкнутую щель. мы в нее нагнетаем воздух ( связи вообще неучаствуют)
и потом мы эту щель резко откравыаем , воздух резко вырывается и возникает некий звук. точно так работает образоывание звуков "к" "п" "т" 
звук "щ" это тоже продувание воздуха сквозь щель во рту. 

звук "б" это тот же звук "п" но при подключении несущей частоты связок.
тоесть по мне вобщем похоже звук получается вот как - для гласных звуков которые простенькие звук образуется за счет связок то ест тупо гармоническое колебание на узком диапазоне из горла. а согласные звуки по мне образуются путем того что
нагнетается воздух во рту в закрытый рот а потом он резко открывается газ резко 
начинает вылетать и получается некий звук но он с колебанием из связок никак не связан это условно говоря звуки которые можно получать путем ударом молотком или карандашом по столу. или если у нас есть банка дихлофоса мы нажали на кнопку и газ вылетает и дает звук. вот по мне согласные звуки в основном там во рту образуются тоесть без участия несущих частот их глотки. глотка нужна только для гласных звуков в основном.  я бы сказал что гласные звуки из глотки это некая внатуре несущая которая никакой информации ненесет. а только как бы сообщает мозгу что началась передача звуковой информации. и можно заметить что кога мы произносим согласную то 
наща глотка прекращает работать и раздается согласный звук как удар молотком например. таким образом гласные это как старт стоп биты. это как фоновая музыка 
на радио когда ктото говорит. согласные это что то обычно либо свистящее либо шипящее либо типа как маленький ударчик молотком. тоесть все эти звуки они с глоткой неимеют никакой связи. буква "р" например глотка вобще выключена это чисто колебание языка во рту от того что летит воздух и язык начинает дергаться. чтобы понять физику образования звука согласного надо понять как формиурется звук при ударе пальцем по доске. вот та же самая физика.  я как раз неисключаю что при ударе молотком по столу возникают как раз таки высок. вобщем звук можно формировать нетолько через колебания струны как это делается в горле. но и совершенно подругому
через удар по предмету. 

Возращаемся обратно: 
вопрос - какой смысл имеют  амплиутдно частотный график и  фазово частотный график. Это график сугубо завязанный на ряд фурье. то есть мы на этих графиках 
расписываем параметры членов внутри суммы. Тоесть по этим графикам мы можем
восстановить вид членов внутри суммы ряда фурье. На этих графиках мы изображаем
эти самые члены под суммой. Поэтому эти графики имеют применение только в связке с рядом фурье. Эти графики неимеют никакого самостоятельного применения. Еще раз на них изоаржаются члены суммы формулы ряда фурье. Когда мы смотрим на графикии 
то по ним мы можем восстановить вид этих членов под суммой. итак смотрим на графиик
и и их смысл такой что мы на них видим как выглядят члены под суммой из ряда фурье.
Эти графики предназначены чтобы по ним можно было восстановить вид ряда фурье. 
Другого самотсотелльного какогото применнеия эти графиик неимеют. Что нужно у себя спросить когда смотрим на эти графиик - вопрос такой что я вижу? ответ - если я вижу
какую то частоту и амплитуду для нее то я понимаю что соответвующий член под суммой в ряду фурье имеет такую частоту и такую амплитуду. В исходном сигнале f(t) ни таких частот ни таких амплитуд нет. Эти графиики это графическое представление
математической формулы суммы в ряду фурье. Я хочу подчернкуть что есть графики 
котоыре имеют самостоятельное значение например график ускорения тела. 
графиик АХЧ и ФЧХ неимеют такого самостоятельного значения. Они жестко привязаны 
к некоей мат формуле - а именно сумме в ряду фурье. и показывают члены стоящие под суммой не вивде формулы а в виде картинок. Это важно понять хотя это вроде как 
очевиедно. Если мы видим некую картинку на которой изобаржены частоты и ампитуды
мы сразу дожоны понять что это показаны члены ряда фурье и ничего другого этот 
график неможет значить. Повторять как заклинание  - на  графике  я вижу члены под 
суммой в формуле для ряда фурье, больше ничего другого на графике я невижу.

Ксати - также надо утоянчть к какой формуле про ряд фурье нарисоываны графики.
к форме вещественной или к комплексной форме. Это тоже важно.
Итак еще раз видим АЧХ и ФЧХ спрашиваем себя что он нам показывает? показывает 
ли он нам исходндую функцию f(t). ответ нет. он нам показывает ряд фурье. точнее
его члены под суммой. в графическом виде. зачем нам это? чтобы из графика 
восстанрвить вид этих членов в виде формулы.




Еще важный момент:
видим запись e^(i*2*pi*f0*t)
вопрос что мы видим?
ответ - мы видим функцию от компллекснного числа. 
что такое функция комплксного числа. это такая хрень которая берет 
компл число и ставит ему в соотвествие другое комплексное число.
поэтому функция это всегда тоже комплексное
число на выходе. значит это некий вектор на комплексной плоскости. 
значит это некая точка на комплексной плоскости.
значит мы видим другими словами вот такое:
(x,y)
x+i*y
r*e^ia
r**cos phi+i*sin phi)

это все одно и тоже.

конкретно это фуннкция берет  компл число причем не произволтное а только такое что 
z=0+i*a и ставит ему в соотвесвтие число cos a+i*sin a
которое является всегда вектором единичной
длинны которые лежит на окружности.
тоесть если аргумент имеет длинну a то ему ставится в соответвие единичный вектор
который поверут на угол a (угол a считается задан в радианах а не в градусах).

в полярных коодринататах e^ia=(1,a)
в декаровых коодинаатах e^ia=(cos a, sin a)

графически это вектор единичной длинны который повернут на угол a.
если меняем a в аргументе то меняется угол поворота функции.

теперь представим что a это функция от времени тоесть
a=2*pi*f0*t.
тут все константы кроме t.

найдем производную da/dt=2*pi*f0
по опредеднию da/dt это угловая скорость w
значит при даннном законе имзенени угла по времени у нас как видно
w=2*pi*f0
как видно она ненавзисит от врмени . згачит w у нас константа. значит скорость 
поворота угла постоянна. Если w это угловая частота то по опредеелению 
w/(2*pi) это линейная чатсота.  тогда мы видим что w/(2*pi)=f0
значит f0 оказывается имеет смысл линной частоты. Исходя из того что ясказал
если мы видим вот такую хрень

e^(i*2*pi*f0*t)

то мы теперь плнимаем что это значит. 
а имеено: это функция от клмпл аргумента.
это комл число.
это вектор.
это единичный вектор на компл плоскости. повернутый на угол 2*pi*f0*t  (угол задан в радианах) в момент времени t. f0 это линейная частота. при изменений времени 
t у нас вектор будет поворачиваться. 

потом они гвооря а давайте рассмотрим такух хрень:
0.5* e^(i*2*pi*f0*t) + 0.5* e^(-i*2*pi*f0*t)

что мы можем про это сказать:
слева у нас векторв компл плокости длинной 0.5 его угол поворота зависит от t.
вращается он по окружности против часовой стрелки. относительно t он вращается 
с уголовой скорость 2*pi*f0. если время t0 то текущий угол наклона у него это 
2*pi*f0*t в радианах.
второе слагаемое тоже самое только вектор наклонен под углом -2*pi*f0*t
по факту это два сопряженных компл числа. и они как видно складываются. 
складывать их можно по правилу векторов. 

Ксати. вместо графиков АЧХ и ФЧХ можно рисовать табличку с тремя строками
n:
c(n):
phi(n):


Главный вопрос который остался это что за хрень отрицательные
частоты. смотрим на ряд фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)


под суммой стоит куча векторов.
рассмотрим один из них ( при некотором фискированном n):

c(n) * e^(i(n*w1*t+phi(n)))


с точки зрения времени t все остальное внутри это константы тоесть


k1 * e^(i(k2*t+k3))


это вектор длинной k1 который наклонен к оси под углом phi=k2*t+k3 в радианах
поскольку t у нас меняется то угол наклона меняется. 
при изменний времени t вектор будет вращасять по окружности с угловой сокрстью k2.
откуда я это взял. угловая скорсть по опредеднию это d(phi)\dt.
в нашем случае d(phi)\dt=k2.
значит w=k2. 
видим что w независит от рвемнеи. значит угловая скорость константа значит векто
вращается равномено. значит мы помним что k2=n*w1.
w1 - это константа которую мы сами выбираем при создании ряда фурье. 
n - это номер члена под суммой. 
сумма у нас идет для n от минус бесконечности до плюс бесконечности.
значит унас будут n>0 и n<0 значит мы будем иметь w>0 и w<0. 
тут то и появляются отрицательные частоты. и если честно я невижу абсолютно нахуй с ними никаких проблем. знак всего навсего означает в какую сторону вращается вектор.
если w>0 то против часовой если w<0 то по часовой. ну и хуйле тут удивительного ?
вот забудем щас про коплексность. 
возьмем точку на декартойо плоскости. начнем ее вращать по закону
phi=-2*t

теперь вычислим угловую скорстлсть :
d(phi)\dt=-2 
получаем w=-2 
ну и хуйле тут удивительного? еслт w отрицальено это просто означает что тело
врщается по часовой стрелке ну и что?

возьмем функцию обычную:

y=sin (-pi*t)
w=-pi

я считаю что ошиибка состоит в том что 
w!=(2*pi)/T
я считаю что 
|w|=(2*pi)/T=2*pi*V,
V=|w|/(2*pi)

тогда у нас небудет отрицательных периодов и отрицательных частот при отрицательых
w. вот и все.

проверяем. 
T=(2*pi)/|w|=2*pi/pi=2
проверяем

sin(-pi*t)?=sin(-pi*(t+2))=sin (-pi*t-2*pi)=sin(-pi*t)
sin(-pi*t)=sin(-pi*t)
вроде совпало.
значит формула верна что 

T=(2*pi)/|w|
V=|w|/(2*pi)

и нет нахуй никаких отрицатлеьных линейных частот и периоодов.
Отрицательная круговая частота может быть и это абсолютно нормально.


На этом тему волн и компл переменного пока заканчиваю.

Оставшиеся вопросы:
- почему колонки для басов
дооожны иметь  большой диаметр? откуда это берется ?

- понять почему антенна должны быть половина длинны радиволны.
- понять какого размера доожны быть связки голосовые. почему колонки для басов
имеют большой диаметр.
- подумать что такое скорость волны?
- додумать этот момент. w<0 а что с T и V=1\T ?



- на графика мы откладываем не n а n*w1 потому что именно n*w1 это угловая 
частота каждой гармоники. тоесть не n не w1 не являются частотой гармоник
именно n*w1 является частотой очередной гармоники. поэтому на графиках именно n*w1
- ряд фурье в вещественной форме помимо класического вида:
f(t)=a(0)*0.5+summa(a(n)cos(t*w1*n)+b(n)sin(t*w1*n))
имеет и другой более компактный вид:
f(t)=a(0)*0.5+summa ( c(n)*cos(w1*t+phi(n) )
где n=1..inf

я почти уверен что эту формулу можно свернуть в:
f(t)=summa ( c(n)*cos(w1*t+phi(n) )
где n=0..inf

таким образом мне совершенно непонятно чем эта формула хуже чем 
комплккссный вид ряда фурье:
f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]
n=-inf..+inf

дело в том что на данный момент то что я нашел насчет того что нахера 
вводить комлпексный вид то это было сказано что в комлпксном виде ряд выглядит
более компактно. так вот получается что это чушь. в веественном виде он 
тоже выглядит также. ровно также. 



- как устроены часы. почему много шестеренок?
также - какая аналогия с амплитудами у векторов и шестернями в часах , что у них общего

- так  теперь надо понять откуда берутся отрицательные частоты
что такое частота. это величина обратная к периоду. что такое период. 
это период колебаний. определяется для периодического колебательного 
сигнала. 
это такое минимальное положительное число что f(x)=f(x+T). а частота
это frequency=1\T. Физический смысл частоты это сколько колебаний в секунду
имеет сигнал.
исходя из этого непонятно как вообще может быть отрицательная частота?


- напоминаю что на данный момент мы можем через ряд фурье выражать фнукции
которые периодические. щас мы поймем а как же прдсетставлять через ряд фурье
непериодичекую функцию.?
- так ну фурье это хорошо но нам надо понять на счет тех столбиков из статьи?

- замечу мы пока что рассматриваем функцию периодическую относительно x. 
если x это время то сигнал периодический по времени. 
что делать с сигналом неприодическим пока неясно.




- frequency domain representation - амплитудно частотная характеристика.
состоит из набора частот и амплутуд этих частот.
идея такая что сигнал можно разложить в ряд. 


- baseband
что это такое в вики дается очень мутное определение.
у одного индуса я нашел такое определение - A baseband signal is one which has spectrum from 0 Hz to some fc Hz where fc is the cut off frequency (necessary to have spectrum around 0Hz to qualify for baseband signals).

но сразу упомяну такую штуку - Ethernet protocol, which transfers data using the original baseband signal. In fact, the word "BASE" in "10BASE-T," "100BASE-T," and "1000BASE-T" Ethernet refers to baseband transmission. These Ethernet protocols do not require signal modulation. 

Еще полезняшка по этой теме:
So, summing up, the base band signals modulated with higher frequencies have the following benefits:
More number of baseband signals can be accommodated over a single wire or channel
Signals can be transmitted over long distances without amplifier.
You can also encrypt the communication for privacy and security
Costs much less.
Еще полезнящка: телефонный проводной телефон это пример baseband communication.

baseband сигнал через кабель можно пускать а через радиоканал нет потому что 
антенна на передачу радиосигнала должна быть размером примерно с половину волны.
для волны 20KHz размер волны измеряется километрами. а именно вот формула f = 𝜈 / λ
где f это частота в герцах, 𝜈 это скорость волны. для радиоволны 𝜈 = 3*10^8 m\s
подставляем λ = (3*10^8 m\s)/(20 000 Hz)= 15 000m , тоесть 15км. значит антенна
должна быть 7.5км что нереально для размера антенны.

также полезняшка low pass filter это такой фильтр который пропускает чеерз себя
только частоты ниже какойто. high pass filer это фильтр который пропускает частоты
выше заданной а band pass filter это фильтр который пропускает частоты между f1 и f2.

чем выше частота радиосигнала тем меньше антенна на передачу и прием и тем меньше 
по размеру вся требуха в приемнике. 



- coaxial cable означает кабедь в котором провода лежат на одной линии потому что 
axi это типа ось, а coaxi на одной оси. тоесть токи текут в обоих направлениях
вдоль одной оси.



- типа очен полезная книга по связи:
Modern digital and analog communication by B.P. Lathi


- attenuation. что это . а это attenuation (also known as signal loss).


- infrared излучение. что там за фишки

- фундаментальный вопрос ( я там ниже рассмотрел что такое цифровой и аналоговый сигнал).
так вот вопрос как генерируется цифровой сигнал. так как в природе обычно все величины аналоговые (кроме квантового мира где есть четко дифференцированные фискированные квантовые состояния) а будем даже более конкретными в электрическом мире мире напряжения и силы тока
мы неможем сгененировать скажем первую секунду 100% U=5V а потом вторую секунду U=0V.
окей если 0V мы еще можем сделать то мы неможем обеспечить 100% 5V он будет все равно меняться
и плавать в течение этой секунды. тоесть он все равно будет аналоговый так как же генерируется
цифровой сигнал?


- balanced cable

- непонятно вот у нас есть несколько разьемов на плате (пусть будет 4) под SATA провод. каждый разьем ведет к одному диску. вопрос сколько контроллеров SATA на плате четыре или один.
далее было сказано что SATA AHCI имеет одну очередь на 32 запроса. вопрос это 
на все четыре диска или на каждый диск своя очередь.
- надо переходить от SATA к AHCI SATA  а потом к NVME 
- NVME очереди (65 535 очередей с глубиной 65 535 команд)


- analogues signal vs digital signal
analogues означает аналогичный,  чтото аналогичное чемто другому.
что такое сигнал - согласно вики это некая величина чегонибудь (масса, напряжение, величина светового потока,величина тока, положение рук регулировщика) которая для наблюдателя (кудаж без него) меняется во времени и\или в пространстве. итак именно некая величина+время+наблюдатель образуют сигнал.
если честно я чтото непредставляю
что за сигнал который неменяется во времени но меняется в пространстве. если величина
меняется во времени тут вопросов нет что это сигнал. например фонарь был темный стал светлый. 
это сигнал. летающая тарелка ее координата она поменялась во времени это сигнал. светофор
погас зеленый и в другом месте пронстранства загорелся красный - поменялся и во времени в 
пространстве тоже сигнал. непонимаю какой пример сигнала (некоторая величина) которая неменяется во времени но меняется в пространсве. все таки по мне это величина меняющаяся
во времени. 
насколко я понимаю когдамы говорим про сигнал - значит должен быть генератор сигнала
его источник, должен быть носитель сигнала , должна быть некая величина которая переносится в этом носителе, и должен быть приемник сигнала и должен быть наблюдатель сигнала.
переходим к электрическим сигналам. величина наблюдаемая тут это либо ток 
либо напряжение. аналоговый сигнал( как я понял ) что это означает - вот мы начали мерять сигнал и снимаем с прибора величину с некоторым шагом например снимаем виличину напряжения каждую секунду. меряли 10 секунд. получили 10 величин. потом мы повторяем сигнал и меряем
его опять 10 секунд но уже каждые пол секунды получим 20 величин. потом мы повтоярем сигнал
и меряем его каждую треть секунды получили 30 величина. далее мы возьмем полученные 10 величин и выкинем из них все повторяющиеся получим множества A. потом возьмем 20 величин и выкинем из них повторяющиеся получим множество B, 
потом возьмем 30 величин и выкинем повтоярющиеся получим множество C, так вот
если сигнал аналоговый то множество C будет больше чем множество B а оно бльше чем множество A.
и чем чаще мы будем снимать сигнал и выкидываь из полученного множества дубли тем суммарное
множество будет больше ( вштуках) чем прердыдущее множество которое было получено путем фиксации сигнала при большем интервале времени. хотя максимум и минимум сигнала конечные
но на отрезке времени количество велиичин сигнала бесконечно какой бы маленький шаг 
фиксации величины мы бы ни взяли. на него непохож цифровой сигнал - если мы возьмем отрезок времени то мы можем найти такой минимальный шаг фиксации величин сигнала что при уменьшении времени снятия сигнала (другими словами при увечличении частоты фиксации сигнала) мы будем получать одно и тоже множество величина сигнала (после того как мы выкинем из него дубликаты.)
пример аналогового сигнала и цифрого:
положим что вольты в проводе меняются по закону U=t
будем фиксировать вольты первые 2 секунды.
вначале инетрвал фиксации 1 секунда.
U(1)=1
U(2)=2

дублей нету. значит наше множество это {1,2}

далее фикируем каждые 0.5 секунды
U(0.5)=0.5
U(1)=1
U(1.5)=1.5
U(2)=2
дублей нету. конечное множество {0.5, 1, 1.5, 2}
фиксируем сигнал каждые 0.1с множствео будет {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, ... 2}
так вот видно что чем чаще мы снимаем сигнал тем множстве значений растет растет и растет 
и при любой частоте снятия сигнала мы можем взять еще более частое снятие сигнала и множество
будет еще больше. это аналоговый сигнал. множество значений увеличивается до бесконечности
при уменьшении времени снятия сигнала ( даже после выкидывания дублей . хотя в данном случае дублей просто нет).
цифровой сигнал.
положим что сигнал вот по такому закону генерируется
U=1(при t=[0,1) )
U=0(при t=[1,2] )

снимаем сигнал каждые 0.5с
U(0.5)=1
U(1)=0
U(1.5)=0
U(2)=0

выкидываем дубли(это важно выкидывать дубли) получем множество {1,0}

снимаем сигнал каждые 0.25с
U(0.25)=1
U(0.5)=1
U(0.75)=1
U(1)=0
U(1.25)=0
U(1.5)=0
U(1.75)=0
U(2)=0

выкидываем дубли получаем ножество {1,0}

так вот что более часто сигнал снимать нет смысла. какой бы мы ни взяли шаг еще меьше
после выкидыаний дублей мы получим все тоже множество {1,0} 
это и показыает нам что сигнал цифровой.

еще раз аналоговый сигнал - чем чаще мы снимаем его значение (на одном и том же конечном
промежутке времени) и потом выкидываем дубли то полученное множество будет все расти и расти
и расти оно будет бесконечно при уменьшении шага снятия величины.
цифровой сигнал - его множество значений не растет бесконечно (после выкидываений дублей) при уменьшении шага фиксации величины сигнала. начиная с определенного шага  фиксации величины сигнала S0 полученное множество значений (после выыкидываний дублей) будет одно и тоже для любого сколь угодно малого S1<S0.
Обычно в природе величины(сигналы) являются аналоговыми. например температура 
у тела имеет аналоговый характер. цифровой же сигнал обычно искусственным образом создается генерируется людьми. 
амплитудная модуляция я узнал как она выглядит через математику. если 
низкоачастотный сигнал это y1=f(t) и если у нас высокочастотный носитель это y2=A*Sin(bt)
то амплитудная модуляция выглядит как y3=f(t)*Sin(bt).



- а ethernet 100 он тоже исплзует differential signaling ?
из того что я прочитал нет. эзернет НЕиспользует differential signaling.
у них в одну сторону используется пара проводов и в другую сторогу использутеся пара проводов.
итак еще раз в SATA в одну сторону исползуется 4 провода.  а в ethenet 100 в одну сторону
исползуется 2 провода. кручение кабеля испольуется для того чтобы защититться от влияния
одного кабеля на другой. оно тем больше чем длиннее кабели а скрутка это убирает. от внешнего 
влияния из вне скртка никак не помогает. получается что  SATA каелбелть он короткий скажем 1метр. на такой длинне влияние одного провода на другой видимо еще маленькое ( потому что я читал что чем длинее провода тем они в в коце друг на другна сильнее влиятют) а более 
влияет помехи снаружи. поэтому satat не скручивают зато используют differential signaling.
ethernet же прводо длинной 100метров поэтому влияне одного проводоника на другой уже
на такой длинне накапливается и провод крутят . скорость у satat 600MB\s а у эзернет
10MB\s и поэтому видимо у него неиспользуют differential signaling тоеть небоятться внешних 
помех.  ятолько в одной сттье нащел что 10Gb ethernet использует differential signaling
 

- амплитудная модуляция. это когда унас есть какойто высокочастотоный сигнал (радиоволна)
и мы меняем у него амплитуду так что если мы соединим линией все его амплитудные точки
то получим волну низкочастотную котору мы и хотели закодировать через этот выскочастотоный сигнал ( картирнка https://en.wikipedia.org/wiki/File:Amfm3-en-de.gif)
еще  я непонял вот что. если мы возьмем наш низкочастоный сигнал разложим его в ряд фурье
тоесть представим наш сигнал как сумму синусоид с индивидуальными амплитудами то мы получим некоторый спектр. это понятно. ксатии вобще то ряд фурье он для периодических функций
а если непериодическая? ну как я понял тогда берем кусок функции и потом ее как то там продолжаем и вот для нее строится ряд фурье и он на заданном куске совпадает с с функцией.
так вот ( как я понял) если мы возьмем наш промодулированный сигнал (тоесть  выскочастотный несущий синал который по амплитуде промудирован низкочастостным сигналом ) возьмем кусок
этого сигнала ибо он же нерегулярный поэтому как я понял для всего сигнала построить 
ряд фурье вот так единой формулой нельзя. поэтому мы берем кусок сигнала потом хитро его там
продолжаем (как написано в вики) и строим для него ряд фурье который на заданном куске 
совпадает с сигналом так вот утверждается что промудулироваронный сигнал в виде ряда фурье
будет иметь спектр в два раза шире чем спектр исходного низкочастоного сигнала на данном куске. хотя чисто интуитивно мне непонятно то что промодулированный сигнал имеет в себе 
всего одну частоту (ту самую высокочастотную) изменилась всего лишь амплиутда то там то здесь
непонятно как это может влиять на появление новых частот в интеграел фурье. но тем не менее надо двигать дальше.
далее такая хрень еще встречается как baseband bandwidth и passband bandwidth.
и тут я тоже замучался разбираться и неразобрался. 




- почему у коаксиала гораздо выше и экранирование и полоса пропускания чем у витой
пары а скорость передачи данных цифровых гораздо ниже чем у витой пары. я вот думал 
что коаксимал неиспользуют только потмоу что его дороже исзготавливать и он гораздо
хуже монтировать. (типа его нельзя гнуть и так далее). так что если забыть что его метр
стоит дороже и что его монтировать недоубно мне непонятно почему его цифровая скорость 
ниже чем у витой пары что за фигня. 
- baseband bandwidth vs passband bandwidth  vs broadband
я всегда часто думал что эти фразы больше как маркетинговый булшит а оказывается
они имеют типа рельный смысл. 

- alexanderson alternator
- электронные лампы. как работают в чем фишка
- как максимально простыми методами можно генерировать радио волны
- катушка румкорфа она юзается при генерации искры. как она работает
- как передается сигнал в проводах через меняющийся ток или меняющееся напряжение
и как это ловят на том конце
- в чем фишка коаксиального кабеля почему он такой и для чего
- в чем фишка витой пары почему она такая и для чего
- сигнал передается через дергание Вольтов? и это породжает дергающийся ток или что?
- почему в sata разьеме 7 пинов а в проводе всего 4 провода
- рассссмотрим SATA диск ( с AHCI и без) и путь от него байта до цпу










главный вопрос как найти число очередей на своем nvme диске.
как на sysfs посмотреть число hardware queues о которых выше написано
get-feature:0x7 (Number of Queues), Current value:0x0f00g0f
	Number of IO Completion Queues Allocated (NCQA): 16
	Number of IO Submission Queues Allocated (NSQA): 16
что такое AHCI как он отличается от sata
когда идет ahci то как там идет связь между диском и цпу
nvme это через какой интерфейс и какую шину оно втыкается. как идет связь
между цпу и диском.

нашел в pdf от сигейта(у кингстона тоже самое написано) что AHCI(контроллер наверно) имеет только один command queue с глубиной depth на 32 команды. а nvme (диск наверно контроллера то нет ) может иметь до 65 535 command queue с глубиной depth команд до 65 535.
в чем разница между AHCI и NVME интерфейсом (из той же брошюры сигейта) - когда у нас

==================================================================================



- как выглядит прочесть 1 байт из файла на ассемблере? куда ядро сует ответ с диска процессу ?

- block devices vs character devices?
разница вроде бы в том что из character device можно читать и писать но тупо напрямую в 
/dev/name но нельзя задать какойто поиск какойто сдвиг. либо читаешь то что есть 
либо пишешь туда напрямую. а у block  device можно задать некий offset и данные будут
записаны\считаны изнутри кишок где то там начиная с offset.
еще такая добавка что якобы FreeBSD doesn’t use block devices at all.


- bfq, linux i\o scheduler ?

- 165.pdf стр 8 ?


- $ dd if=/dev/zero of=/dev/null bs=514 count=1
вот инеерсено заупускаю я эту команду. диск у нас 512байт сектор.
на стороне юезоер спейса будет написано что была только запись а вот на стороне
ядра и доно быьт и чтение и запись чего конечно небудет видно из юзер спейса через iostat
но должно быть в итоге идно по перфомансу конечному на диске.
как бы проверить?

- 
$ lsblk -o  NAME,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC  /dev/nvme0n1
NAME       1MENT MIN-IO OPT-IO 12КБSEC
запускается ядро и сисколл берет наши 12КБ данных и смотрит а какой размер блока на фс. 
ага 4КБ. он режет наши 12КБ на три куска
nvme0n1             0    512    512     512    
 512
├─nvme0n1p1         0    512    512     512     512
└─nvme0n1p2         0    512    512     512     512



- фс блоки. это внутренняя кухня  внутри драйвера фс или наружу тоже както 
это выставляется для внешних потребителей? тоесть непонятно нам то внешнему потребителю 
какая разница на эти блоки нахер это нам дает? мы хотим записать считать файл и только то.
какое нам дело до этих блоков ?


- https://www.opennet.ru/base/sys/info_diag_tools.txt.html


==================

| truncate
| ext
| architecture
| fallocate
| sparse

| truncate
| ext
| inode 
| ext2
| ext4

тема изначально возникла вот откуда - на приудурошных собеседованиях 
любят задавать вопрос. вот закончилось место на диске. выяснялется что 
некий лог файл все засрал. как освободить место. приложение которое пишет 
в лог перезгружать нельзя.

решение  - использовать команду truncate.

#  truncate -s 10M имя_файла

и она на лету вырежет\освободит\удалит у него дата блоки и файл станет заданного размера

еще вернемся к truncate.

поговорим про EXT2 ее устройство.
без этого нам много чего непонять про truncate

далее внизу я использую слово блок. так вот
фс работает не с блоками диска тоесть секторами. фс работает
со своими собственными фс блоками. поэтому внизу если я говорю block
это значит фс блок а не физ диск сектор.

ext2 разбивает диск на блоки размером 1KB либо 2KB либо 4KB.
и фс оперрирует этими блоками. (источник https://www.landley.net/code/toybox/doc/ext2.html)
весь диск разбивается непросто на фс блокаи а на группы блоков.
группа блоков включает в себя то количество блоков сколько может в себя вместить 
bitmap блоков вмещающийся в один фс блок. тоесть - во первых что такое битмап.
у нас есть какито сущности например блоки фс и мы хотим закодировать на уровне 
1 бита информацию о том что один блок на фс имеет какое то свойствао нпример то что
блок используется или он свободен от использования. получается ест у нас скажем 10 блоков
на ФС. и мы берем и начинаем с помощью битов кодировать свободен блок фс или используется
это буде выглядеть так 1101010001 . полуили 10 бит. это битмап.
далее если  унас блок ФС имеет размер 1КБ (тоесть 1024 байта тоесть это 1024*8=8192 бита
то) то мы с помощью этого 1КБ может на уровне битом(битмап) можем закодирвать состояние
8192 блока ФС. таким образом теперь понять почему если у нас размер блока ФС = 1КБ
то логично группировать блоки ФС в количестве 8912 блока в одну группу. и тогда битмап
какогто свойства этих блоков будет влезать ровно в 1 блок ФС. что красиво. 
поэтому понятно что если размер блока ФС = 4КБ то  при таком выборе размера блока при форматировании ФС все блки будут разбиты на группы размером 4096*8=32768 блоков на группу.
а битмап этой группы будет влезать водин  блок ФС размером 4КБ.

посмотреть размер блока ФС можно через

# dumpe2fs /dev/sdb1 -h | grep "Block size"
dumpe2fs 1.46.5 (30-Dec-2021)
Block size:               4096

поэтому я ниже когда пишу что размер блока = 4КБ то я там ошибочно думал
что мы говорим про размер сектора на физ диске. а мы на самом деле
говорим про размер блока ФС.вообще же на самом деле документация херня
там бывает намешаны и фс блоки и физ диска блоки. и хер поймешь какой они 
имеют ввиду.

например в доке(https://www.nongnu.org/ext2-doc/ext2.html#i-block) написано
Note: the 2TiB file size is limited by the i_blocks value in the inode which indicates the number of 512-bytes sector rather than the actual number of ext2 blocks allocated.

а потом в другой доке нарисано что потом это исправили и уже в i_block
испоьзуют не физ сектора диска а фс блок. и поэтому ограничение 4ТБ на размерфайла
при размере фс блока 4К.
пздец





тот же dumpe2fs покажет и все группы блоков. например

Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-128
  Block bitmap at 129 (+129)
  Inode bitmap at 130 (+130)
  Inode table at 131-640 (+131)
  32120 free blocks, 8148 free inodes, 2 directories
  Free blocks: 647-1023, 1025-32767
  Free inodes: 13-8160

видно что так как у нас размер блока ФС 4К то 
количество блоков в группе 32768

двигаем дальше

я вот читаю вот этот источник ( https://www.nongnu.org/ext2-doc/ext2.html#i-block)
там есть таблицы "Table 2.1. Impact of Block Sizes"

там написано что нважно какого размера блок ФС выбран 1К\2К\4К\8K
во всех случаях максимальное число блоков ФС может  быть 2147483647
я решил проверть асолько  в двоичном формате это число составляет

echo "obase=2;ibase=10; 2147483647" | bc  | awk '{print length}'
31

оказалось 31 бит. вот тут я непонимаю почему 31 бит а не 32 бита.
и вот в той таблице указано что число фс блоков макимальное число это 2147483647
. при размере фс блока 4К они пишут что размер файловой системы будет 16TB.
откуда???  если мы умножим число блоков фс 2147483647 на 4КБ то мы получаем 8ТБ,
откуда они берут 16ТБ?
вобщем эта табица походу устарела.
ясно другое - если мы форматируем ext2 (ext4) то чем больший размер ФС блока мы выберем
тем у нас ограничение на макс размер файла будет больше и на макс размер партишена тоже 
будет больше.

далее. 
про битмапы я нашел что они кодируют - Each bit represent the current state of a block within that block group, where 1 means “used” and 0 “free/available”.



далее
поговорим о том как ext например для простоты ext2 хранит файлы у себя.
файл состоит из тела где собственно хранятся данные и из обертки служебной
информации тоесть из метаданных.

по моим понятиям файл состоит из трех частей на фс. 
первая часть это его тело , его дата блоки. 
вторая часть это инода - это спец область на фс где хранятся метаданные об этом файле.
какие именно щас покажу. 
и третья часть это область где хранится список блоков от тела файла.потому что тело
файла хранися в каких то блоках но нам же надо где то держать этот список блоков.
важно отметить что если файл по размеру маленкий то список его блоков хранися внутри иноды.
а если он больше такогто размера то этот список он хранится уже вне иноды. это важно.
потому что эти суки везде пишу что в иноде хранятся все метаданные. это брехня.
для большого файла список блоков его тела хранится вне иноды.
есть и еще одна часть от файла это его имя. имя файла нехранися внутри иноды.
оно хранися внутри иноды которая отвечает за папку. в папке указано буквенное имя файла
и ссылка на иноду файла.
таким оббразом файл по составным частям разбросан по нескольким структурам.

еще раз отмечу важную вещь что если файл больше такогото размера то список его блоков
нехранится в иноде. он хранится отдельно  в другом месте. это важно понимать.

итак тело файла хранится в дата блоках.
почти все метаданные о файле хранятся в иноде. инода одна на файл.
ифомрация в каких блоках лежит тело файла чучуть ханится в иноде а остальное вне иноды
в отдельно месте. как оно назыается хрен знает
название файла хранися отдельно в папке.

откуда берутся иноды. они создаются на момент форматирования раздела. общее количство
блоков делится на "block groups".и внутри каждой группы блоков создается каоето количество
инодов. инода изначально была 128 байт длинной. щас по момему она имеет вариативный размер.
я пока незнаю инода которая внутри группы блоков она только эту группу блоков обслуживает
или вобще ей пофиг. как я понялр изначально иноды все пустые внутри.

теперь интерсный вопрос о том как фс напримере ext2 хранит информаци о блоках в которых
лежит тело файла. для маленького файла эта инфо хранися внутри иноды.
в иноде есть 12 полей поле по омему раньше было 32 бита длинной а щас вроде бы 64 бита
длинной или 48.  каждое поле содержит в себе номер блока в котором лежит кусочек тела
файла. размер блока это физ размер сектора на диске как я понял тоесть это 4KB.
получется что если  у нас 12 указателй на 12 блоков по 4КБ то значит можно таким макаром
опимсать тело файла размером 12*4КБ=48КБ
если тело файла более длинное то есть 13-е поле в иноде но оно указывает не на блок 
в котором лежит тело файла а на некоторый другой блок и уже этот  "другой блок" содержит 
в себе адрес блока в котором лежит тело файла. и за этим "другим блоком" соседние блоки 
каждый из них содержит в себе адрес блока на диске где лежит тело файла. количество 
этих других блоков раавно 1024 штуки. 13-е поле в иноде указывает на первый такой "другой блок".
получается что с помощью 1024 штуки * 4КБ = 4МБ. тоесть таким макаром мы уже можем
сохрнаить список блоков для файла размером 48КБ+4МБ.
а что если файл его тело еще длинее. тогда вступает в бой 14-е поле в иноде.
оно указывает на группу блоков в количестве 1024 штуки каждый из которых указывает на
группу из 1024 штук. каждый уже из которых несет в себе адрес блока в котором лежит тело
файла. тогда 1024*1024*4 = 4 GiB тогда мы уже получается можем хранить список блоков
файла размером 48КБ+4МБ+4ГБ. ну файл размером больше 4ГБ это не редкость. как тогда.
тогда вступает в бой последнее 15-поле в иноде. оно уже имеет три степени вложенности.
оно указыавает на таблицу из 1024 блоков каждый из которых укзывает на таблицу из 1024 блоков
каждый из которых уукаызвает на таблицу из 1024 блоков  каждый из которых несет  в себе
адрес блока на диске с телом файла. это нам дает возможность храниться инфо о файле размером
4ТБ. 
прикинем если диск размером 40ТБ и у него блок 4КБ. значит такой диск
имеет  число секторов = 10,737,418,240  в двоичном виде это 
10,10000000,00000000,00000000,00000000 
это получается 36 бит. по моему бывает либо 32bit lba либо 48 бит lba.
48 бит это 6 байт. значит по идее одно поле в иноде должно быть длинной 6 байт.

получается если файл длинной 4ГБ то у него секторов ~ 1 000  000 получается чтобы 
эти все сектора запомнить то нужно   6байт * 1 000 000 = 6 000 000 байт = 5.7MB
на жестком диске. а ну это норм. 5.7MB накладных расходов для файла размером 4GB 
это норм. 

далее как я понял например на ext4  там не описывают каждый блок на диске содержащий
тело файла это накладно все равно. вместо этого скажем фс знает что тело файла сохранено
на диске непрерывнми кусками. скажем в блоках с 10,000-20,000 и 30,000-40,000
эти непрервыные с точки зрения адресации блоков куски где хранится тело файла называются
экстентами (extent) так вот когда мы храним инфо в экстертах нам нет смысла 
описывать кажый блок в коттором лежит тело файла. нам выгоднее экономнее описать 
первый блок в эксптенте и его длинну. потом следущий первый блок в следущем экстенте
и его длинну. как я понял что ext4 уже так делает.

как я понял когда файла удаляется на фс то просто напросто у него обнуляется его инода.

как называется группа блоков в которых записаны ссылки на блоки либо экстенты тела файла
я пока незнаю.


покажу какая инфо хранится в иноде
берем файл

1# stat txt1
  File: txt1
  Size: 10          Blocks: 8          IO Block: 4096   regular file
Device: 811h/2065d  Inode: 12          Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2023-07-05 19:16:36.925297134 +0000
Modify: 2023-07-05 19:17:03.775173524 +0000
Change: 2023-07-05 19:17:03.775173524 +0000
 Birth: 2023-07-05 19:16:36.925297134 +0000


видим что за файл отвечает inode=12
что тело файла занимает 8 дата блоков

ставим вот такой пакет
# apt-get -y install  sleuthkit
тгда можем наконец посмотреть содержимое иноды

# istat /dev/sdb1 12
inode: 12
Allocated
Group: 0
Generation Id: 1265727633
uid / gid: 0 / 0
mode: rrw-r--r--
size: 10
num of links: 1

Inode Times:
Accessed:   2023-07-05 19:16:36 (UTC)
File Modified:  2023-07-05 19:17:03 (UTC)
Inode Modified: 2023-07-05 19:17:03 (UTC)

Direct Blocks:
1024 


видим что в иноде прописыаются: владелец, права доступа, размер, и 
последня строка это блоки в которых лежит тело

Direct Blocks:
1024 


итак нахер нам нужна инода. в ней написано в каких блоках надо искать само собственно
тело файла, владелец, права доступа, размер.

инода похожа на каталог в библиотеке только мы ищем не книгу на полке а библиотека
имеет 1 000 000 000 ящичков. в кажом лежит листочек. так вот книгу можно прочиать тлько 
бегая с каталогом открывая нужные ящички и читая оттуда очередной листочек. вот что такое инода.

структура иноды = https://www.nongnu.org/ext2-doc/ext2.html#inode-table

я попытался руками найти иноду на диске чтобы ее можно было прочитать ее 
напрямую чтоб убедиться воочию в ее составе особенно в ее строках по адресам
блоков  в которых хранится тело файла. но найти иноду где она лежит на диске
на вскидку не понятно как. поэтому я юзаю istat

вопросы почему при размере блока ФС 4КБ у нас количество 
индирект блоков равно 1024.
дума что здесь логика такая. если у нас например блок фс на диске идентифициурется
через 32битное число. это 4 байта. вопрос сколько таких 4 байтовых идентификаторов
помещается в одном ФС размером 4КБ. поссчитаем 4096 / 4 = 1024 штуки.
получается что в одном ФС размером 4КБ мы можем разместить 1024 идентификатора блоков ФС
получается что  наш 13-ый параметр в иноде который ссылается на массив из блоков ФС индирект
он в итоге ссылаетс всего навсего на 1 ФС блок. тоесть нужно прочитать всего один ФС блок
на который ссылается 13-ый параметр иноды и мы сразу узнаем все блоки ФС в которых находится
тело файла. тоесть я говорю что first level indirect block array это всего навсего 1 ФС 
блок на диске на который ссылается 13-ое поле в иноде котрое относится к опианию тела файла.

далее получается что двухслойный arrays indirect блоков выглядит так  :
14-е поле в иноде ссылается на всего навсего 1 блок ФС на диске. а там  каждые 4 байта (коих 1024) ссылаются еще на один фс блок на диске. поэтому  двухслоаная структура предстаялет собой в итоге 1 блок на диске + 1024 блока на диске


еше раз разжую эту тему подробно.
пусть у нас на ФС размер блока ФС = 4КБ.
в иноде есть 15 полей которые описыывают где искать тело файла на ФС. в каких ФС блоках
его искать.

первое поле содержит в себе идентификатор первого ФС блока тела файла.
длинна идентификатора задающего номер ФС блока состаоялет 4 байта (32бита).
второе поле , третье поле. и тд двенадцатое поле каждй из них содержит номер блока 
в котором сидит часть тела файла. (ещераз скажу что номер блока ФС имеет длину 4 байта).

получается что если файл имеет разме 48КБ  и размер ФС блока 4КБ то файл занимает на диске его тело 48КБ\4КБ = 12 ФС блоков. поэтому номера этих блоков умещаются в двенадцати полях иноды.

а что делать если размер файла больше чем 48КБ.
в дело вступает 13-е поле иноды которое тоже кодирует тело файла для файлов большей 
длиныы. но делает это особым образом.  13-е поле ссылается на один блок ФС который находится вне иноды в котором закодировано 1024 номеров блоков ФС где находится тело файла.
еще раз повторю 13-ое поле иноды оно не содержит в себе номер блока в котором лежит
очередной кусок тела файла. 13-е поле ссылкается на некий блок на ФС который несодержит в себе
тело фала а содержит служеюную информацию которая невлезает в иноду. этот ФС блок содержит 
в себе информацию о 1024 номерах блоков где сидит тело файла. итак один блок ФС в себе
кодирует информацию о 1024 блоках ФС где сидит тело файла. почему так. 
потому что номер блока ФС кодируется четырься байтами. если размер блока ФС равен 4КБ то 
в 4КБ влазиит 1024 штуки по 4 байта. 

1024 номера блока ФС * размер блока ФС (4КБ) = нам дает взможность кодировать тело файла
длинной 4МБ.

если длинна файла больше чем 48КБ+4МБ то вступает в дело 14-ое поле иноды
оно ссылается на блок на ФС который в себе содержит кодирует инфо о 1024 блоках на фс 
и каждый из этих 1024  блоков ссылается на некий блок на ФС каждый из которых содержит 
1024 номера блока на ФС уже где находится тело файла. полуается такая хрень может 
нам закодирвать список блоков на ФС размером

1024*1024*4КБ = 4ГБ.

15-е поле содежит три степеи вложенности
1024*1024*1024*4KB = 4TB размер тела файла так можно закодирвать.

итого если у нас на ФС при форматировании выбран блок ФС размером 4КБ
то максимльный размр файла на таком разделе будет 48КБ+4МБ+4ГБ+4ТБ
я так понимаю.

а вот для примера как выглдяит вся эта шарманка если у нас при формативоании выбран блок ФС размером 1КБ.

первые 12 полей в иноде закодируют тело файла размером

12*1KB = 12KB.

13-е поле закодирует тело файла длинной вот какой - 13-е поле ссылается на один блок на ФС.
он у нас длинной 1КБ. в него влезает 1024Б/4Б = 256 штук номеров ФС.

поэтому 13-е поле позволяет закодировать тело файла размером 256 номеров блокнов ФС * 
размер одного блока ФС (1КБ) = 256КБ

14-е поле в себе может закодировать такое количество номеров блоков что по размеру
они кодируеют файл длинной:
256*256*1KB = 64MB

15-е поле позвролит закодировать такое колчество номеров блоков ФС что суммарно 
по обьему это будет:
256*256*256*1KB=16GB
получаетс по моим расчетам если ФС имеет размер блока 1КБ
то макс размер файла будет 16GB+64MB+256KB+12KB

 впринципе я тоже самое нашел здесь = https://www.nongnu.org/ext2-doc/ext2.html#i-block
 цитирую
 The 14th entry in this array is the block number of the first doubly-indirect block; which is a block containing an array of indirect block IDs, with each of those indirect blocks containing an array of blocks containing the data. In a 1KiB block size, there would be 256 indirect blocks per doubly-indirect block, with 256 direct blocks per indirect block for a total of 65536 blocks per doubly-indirect block.

The 15th entry in this array is the block number of the triply-indirect block; which is a block containing an array of doubly-indrect block IDs, with each of those doubly-indrect block containing an array of indrect block, and each of those indirect block containing an array of direct block. In a 1KiB file system, this would be a total of 16777216 blocks per triply-indirect block.


возвращаясь к truncate - походу он как работает - он в таблицах в которых прописаны 
блоки с телом файла  - он там просто удаляет записи о блоках , таким образом файл
лишается части своего тела.  и место на диске (блоки) освобождаюся.


далее следущий момент - когда мы отркваем файл на запись то мы линуксу говорим о том
как мы хотиим писать в файл. первый вариант это мы хотим писать так что данные будут 
записываться в линукс page cache а уже потом когда то линукс их будет сбрасывать на диск,
например это будет происходить когда мы будем закрывать дескриптор файла.
в чем прикол этого метода - в том что наша программа будет писать данные но если 
при этом мы будем запрашивать информацию о файле через #stat то нам будет возвращаться
что размер файла не меняется. второй вариант мы при открытии файла на запист говорим
линуксу что мы не хотим пользоваться пейлж кешем мы хотим чтобы при запист в декскриптор
данные сразу лились на диск. тогда при запси в дескриптор если мы запросим статистику
по файлу чеерез #stat то мы будем видеть что действительно размер файла растет.
еще раз скажу что если пользоваться пейдж кешем то размер файла на диске вырастет 
только тогда когда когда мы в нашей программе закроем дескриптор. потому что до этого данные
просто будут литься в кэш в оперативке а на диске ничего меняться не будет. 

получется очень интересна и непонятная ситуация. 

далее я выяснил еще один непонятный и ебанутый момент.
я взял создал файл с изначлаьным контентом.  я его открыл на запись на добавление в хвост (append) далее я начинаю туда писать при этом я незакрывают файловый дескриптом
после записи.  и я паралельно из этого же процесса читаю содержимое файла. 
пишу я в файл через питон.  по  дефолту запись идет в режме page cache тоесть данные 
льются не на диск а в оперативку. так вот прикол в том что при попытке чтения из 
того же самого процесса я нихуя невижу данные которые записал. линукс возвраащает 
только тот контент который был в файле на момент его открытия.


# cat p1.py 
#!/usr/bin/python2

import time
from datetime import datetime



f = open("demo.txt", "a")



while True:
  time.sleep(1)
  now = datetime.now()
  print ("===========")
  print ("write to file => date=%s") % (now)
  f.write(repr(now))
  print ("===========")


  print ("read from file :")
  f2 = open("demo.txt", "r")
  print(f2.read())
  f2.close()




f.close()




запускаем смотрим

# ./p1.py 
===========
write to file => date=2023-07-06 14:23:14.611576
===========
read from file :
Initial content!

===========
write to file => date=2023-07-06 14:23:15.613440
===========
read from file :
Initial content!

===========
write to file => date=2023-07-06 14:23:16.616518
===========
read from file :
Initial content!

===========
write to file => date=2023-07-06 14:23:17.618961
===========
read from file :
Initial content!



строка  "Initial content!" это то что было в файле на момент его открытия в питоне.
поразительная вещь. тот же самый процесс который пишет в файл а по факту линукс данные
пихает в пейж кеш не может увидть свои же записанные данные. 
при чтении мы видим только изначалльное содрежимое файла.
это пиздец какойто.  получаеся что после каждой операции записи по крайней из пиитона
надо закрывать файловый дескритор. только тогда данные попадут на диск и только тогда
мы их увидим при чтении.

я также невижу новые данные если буду пытатся читать файл из какогто внешнего процесса.


как видно из скрита  я открываю файл через

f = open("demo.txt", "a")

вместо режима "a" можно указать какие конерктные флаги я хочу юзать при 
открытии файла.

их целая прорва
os.O_RDONLY − open for reading only

os.O_WRONLY − open for writing only

os.O_RDWR − open for reading and writing

os.O_NONBLOCK − do not block on open

os.O_APPEND − append on each write

os.O_CREAT − create file if it does not exist

os.O_TRUNC − truncate size to 0

os.O_EXCL − error if create and file exists

os.O_SHLOCK − atomically obtain a shared lock

os.O_EXLOCK − atomically obtain an exclusive lock

os.O_DIRECT − eliminate or reduce cache effects

os.O_FSYNC − synchronous writes

os.O_NOFOLLOW − do not follow symlinks


тоесть "a" это предустановленный режим. а вот если руками открывать файл 
то тогда например вот так

fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )

 я проверил когда в питоне я задаю режим "a"
 то по факту в линуксе отарбаывает сисколл вида

 openat(AT_FDCWD, "demofile2.txt", O_WRONLY|O_CREAT|O_APPEND, 0666) = 3

 тоесть используется три флага
 O_WRONLY|O_CREAT|O_APPEND

 по мне в целом это какйто пиздец. мы открыли файл на запись (append) скажем логер 
 какйони будь линукса или мускула .
 если при записи строки в лог он незакрывает файл то по идее мы в файле нихкя не увидим
 данные будут висеть в пейдж кеш и для нас они будут невидимы.

 можно конечно октывать файл на запис с флагами O_Direct или O_FSYNC
 тоогда при каждой записи у нас данные не будут попадать в пейдж кеш
 а будут лететь сразу на диск и закрывать дескриптор файловый нам для этго ненадо.

 кстати хуй поймешь в чем разница этих двух флагов. судя по стековефлоу народ 
 сам мало понимает. как я прмиерно понял что флаг O_DIRECT говорт линуксу 
 чтобы он сразу писал на диск а не пихал в пейдж кеш.
 а флаг O_FSYNC говорт что надо записть в пейж кеш и тутже синкнуть на диск.
 вобщем малопонятная мудота.в чем прикол в чем разница.


 поэтому вопрос  о том что мы пишем на диск из процесса и видит ли эти изменения этот же 
 процесс или другой   - это еще больощой вопрос. если данные льются в пейдж кеш 
 то нихуя их никто не видит. ни чужой процесс ни даже тот же процесс что льет эти 
 данные. 


 вот пример питона кода мы пишем в файл  юзая флаг O_DIRECT
прр этом надо дполнительно изьебнутся

 #!/usr/bin/python

import os, sys, mmap

# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT|os.O_DIRECT)
m = mmap.mmap(-1, 1024)
s = ' ' * 1024
m.write(s)
# Write one string
os.write(fd, m)
# Close opened file
os.close( fd )


кстати в том списке флагов много всяких интересных непонятных например
os.O_EXLOCK − atomically obtain an exclusive lock
что это значит?
если честно то заебешься разбираться. нет на это время щас.


я модифицировал программа ту что выше.
она в цикле добавляет данные в файл незакрыая его. при этом она пишет не в пейджкеш
а на диск напрямую. когда программа запущена то через stat можно видеть как размер 
файла растет 


# cat p2.py 
#!/usr/bin/python2

import os, sys, mmap
import time


from datetime import datetime

now = datetime.now()


# Open a file
fd = os.open( "demo.txt", os.O_RDWR|os.O_CREAT|os.O_DIRECT|os.O_APPEND)


while True:
  time.sleep(10)
  print ("===========")
  now = datetime.now()
  s = str(now)
  s = s + '\n'
  m = mmap.mmap(-1, 4096)
  m.seek(0)
  m.write(s)
  m.seek(0)
  print(m.readline())


  # Write one string
  bytes=os.write(fd, m)
  print ("bytes=%s") %(bytes) 



  print ("===========")


  # Close opened file
os.close( fd )


здесь хочу подчеркнут что если мы открыли файл с O_Direct
то в файл можно писать только блоками кратными блоку LBA тоесть в моем случае 
это кратно 512 поэтому вот эта строка

m = mmap.mmap(-1, 4096)

в ней только могут быть числа 512,1024, 2048, 4096 итак далее.

запускаем программу. на экране увидим

===========
===========
2023-07-17 03:06:19.049705

bytes=4096
===========
===========
2023-07-17 03:06:29.062738

bytes=4096
===========
===========
2023-07-17 03:06:39.074320

bytes=4096
===========


 в другом терминале заускаем 

# watch stat /mnt/ext4/demo.txt

и наблюдаем как растет файл

а в третьем терминале заупскаем команду

# : > /mnt/ext4/demo.txt
либо
#  true > /mnt/ext4/demo.txt
либо
#  echo "" > /mnt/ext4/demo.txt

любая из них должна мгновенно обнулять размер файла на сторадже (число блоков колонка Blocks:) это будет видно в stat статистике файла. при этом наша основаня программа она не прерывается она продолжает успешно 
писать.

здесь ключ не в том что стоит слева от ">" а именно фишка в ">" он то и засталввяет
осваободить дата блоки в теле файла

четко видно в stat что у файла падает из поле "Size:" но что самое 
главное у файла падает поле "Blocks:" которое показывает сколько релаьно файл 
заниммает на сторадже.

итак я знаю теперь три способа уменьшить размер тела файла на сторадже.
1) truncate ... demo.txt
2) dd (об этом способе ищи ниже)
3) echo "" > ./demo.txt
4) : > ./demo.txt
5) true >  ./demo.txt

я нашел в инете вот еще такой пример. если у нас открыт файл и он исполгяется
а мы полезем его править то лиукнс пошлет на хуй.

тоесть

# cp /usr/bin/bash /tmp/bash1
запусксем 
# /tmp/bash1

пытаемся его изменить из другой консоли
# echo "1212" >> /tmp/bash1
bash: ./bash1: Text file busy

но при этом якобы "удалить" его конечно же можно. 
по мне вот эта проблема с мнимым удалением файла из фс это просто пизец 
 в линуксе. тоесть инода от файла не вычищается а правится инода папки в которой
 этот файл был прописан. ну что за ебанаты. не могли нормально дописать что
 нельзя удалять запись о файле из папки если на данный момент есть десприкторы
 отыкрытые для иноды этого файла. просто добоебы космичесого масштаба.







возвращаемся к truncate 
получается намешанная ситуация.
открыт файл на запись . запись сорей всего идет в пейж кеш а не сразу  в файл.
мы натарвливаем truncate он как я понимаю лезет на диск и в иноде правит таблицу
гнде написано в каких блоках лежит тело файла. и он удаляет часть записей про эти блоки.
таки макаром высвобождая часть блоков на диске. далее надо данные которые висят  в пейж 
кеше занести на диск. не знаю есть ли какая то тут сложность но морока точно есть.


также мне непонятно как усторены спарс файлы. как это сделано на уровне вот этой таблицы
занятых блоков под тело файла. я ненашел.


также непонятно как в иноде вычисляется размер файла. такое ощущение что 
параметр размер файла указанный в иноде он содвершенно не связан с колчиеством
фактически занятых блоков на ФС. мы это щас увидим.
эта мысль подтверждается тем что у нас могут быть спарс файлы. и у них file_size
будет большим прописан в иноде.  а по факту число блоков будет маленкое.
я нигде ненашел по какой фрмуле высчиытвается file_size когда он суется в иноду.

параллельно выянилась некоторая хуйня с выводом команды stat.

# stat 1
  File: 1
  Size: 2           Blocks: 2          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 12          Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2023-07-06 20:14:24.740163442 +0000
Modify: 2023-07-06 20:00:18.272607045 +0000
Change: 2023-07-06 20:03:36.091826053 +0000
 Birth: 2023-07-06 20:03:36.091826053 +0000


 что значат поля 
 
 IO Block:

 Blocks: 

правда оказалась такова - для простых фс как ext2\3\4 где размер  блока ФС (не путать с размером сектора на диске) постоянна это поле показывает размер блока ФС

соотевтвественно так как 
IO Block: 1024
то это значит что ext4 была отформатирована с ключом -b 4096 
тоесть размер ФС блока равно 4K. тоесть этот параметр это не параметр файла
это параметр фс на которой он лежит.
что он показывает на сложных фс как zfs где размер блока фс переменный хуй знает

следующее поле "Blocks:" показывает размер файла но в отличие от поля "Size:" котооое по
казыает размер файла в байтах это поле показывает размер файла в блоках. 
прикол втом что этих блоков в природе несущетсвует. это некие виртуальные блоки размером
512 байт. всегда это блоки размером 512. почему 512? почму всегда? а просто так. 
это константа. так было исторически.  поэтому я бы  в итоге сказал бы так. оба эти
поля можно игнорировать потому что они моут показывать полную неимеющую никакого 
смысла на практкие хуйню.

итак еще раз "Blocks:" показывает размер файла в блоках. блоки чего? блоки фс или блоки
диска. ответа нет. блоки ничего. поотому что размер этого блока константа 512.
"IO Block:" покаывзает размер блока фс. но какой это имеет смысл если блок фс переменный
то это тоже какято хуйня. 

зато четко видно вот что. по кракйней мере для ext файловых систем. 
покажу напримере

# stat 1
  File: 1
  Size: 2           Blocks: 2          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 12          Links: 1


фа1л имеет размер 2 байта. 
если мы умножим "Blocks: 2" на 512 то получим что размер равен 1024 байта.
однако у нас же указано что "Size: 2" так в чем же прикол. типа размер файла 2 байта
а надиске он занимает 1024 байта. ответ в том что "IO Block: 1024" тоестразмер 
блока фс  = 1K а это значит что файл не может занимать размер некратный блоку фс.
так как 2байта ментше чем 1 блок фс равный 1К то в итогге по факту файл занимает один 
фс блок 1K.

тоеть я говорю о том что поле "Blocks: " у stat это некая хуйня. это типа сколкьо блоков
непонятно на чеего то ли блоков фс то либлоков физ диска занимает файл на сторадже.
при этом размер этого мифического блока всегда константа 512 байт.  почему 512 байт? 
а просто так захотели. и не меняют это дела со временем царя гороха.

тут  я  хочу добавить что почему stat выводит такую хуйню. потому что он делает 
через сисколл запрос и ему в ответ вылетает прям готовый массив данных. и он его просто
выводит. так что константа 512 вбита где то в  коде ядра. окей ядро мы менят не хотим.
но могли же они подкрутить юзер спейс код самой утидиты stat чтобы он делала коректировку.
это же так прсто. дебилы.


возвращаемся к sparse файлам
и тут я открыл целое новое море которое многое из того что писал выше перечеркивает.

что такое спарс файл типа в общих словах - если у нас есть файл у которого в теле
очень много значений равных "0" то типа того что это значение можно и не записывать 
в блок на диске не тратить на него блок. тоесть все значения в файле байтов которые 
несут какое то другое значение можно записать на диск в сектора а ноль типа чего его 
записывать. и вот как то в метаданных файла кодируются оффсеты (смещение относительно
начала файла , адреса) в которых значение должно быть ноль таким образом что на диске
дата блоки вообще не задействуются а просто вот где то в метаданных делают какуюто пометку
что такойто блок он имеет значние ноль. поэтому когда идет считывание по этому офсету 
внутри файла то драйвер фс видит в метаданыхх не сслыку на какйото блок на диске а видит
пометку что данный офсет это офссет у котрого значение равно нулю. и он возврашает этот ноль 
обратно. условно говоря я же писал сверху что еслиу нас какйто офссет имеет какоето значение
то как выглядит доступ к этому значению - у нас 4 байта в метаданных (неважно в иноде или вне ее ) содержит номер блока ФС размером 4КБ. это если мы говорим про первый индирект 
блок в иноде. тоесть у нас 4 байта метаданных позволяют закодировать 4КБ данных. (вот какая экономия.) ну даже отбросим мы индирект схему. всопмним что в иноде есть блок из 12-ти
полей кажый из которых содержит адреса первых 12-ти фс блоков тела файла. 
я думаю что каждый из 12-ти блоков имеет размер 4 байта. а указывает на блок на фс который
уже имеет размер 4КБ. так вот это я просто походу ещераз напомнил. так вот прдтставим себе
что первые 4КБ в файле это сплошные нули. вместо того чтобы траить на диске 4байта + 4КБ 
мы можем просто напросто в этих 4 байтах прописать четыре нулевых байта и освободит 4КБ на диске под чтото другое полезное. и тогда если у нас идет обращение к первым 4КБ тела файла
то у нас драйвер фс лезет в этот 1-ый блок в иноде который опиысвает тело файла. видит 
что там вместо адреса на блок на диске идут просто нули и драйвер понимает что надо 
программе вернуть псто напросто 4КБ нулей. вобще это гениально. мы израсходлвали всего 4 байта на диске чтобы закодировать 4КБ данных. огророная экономия места на диске. 
опять же отслюда вытекает что чтобы спарс файл реально работал и экономил место это надо 
чтобы в файле были непрервыные куски размера по 4КБ только тогда можно делаь такйо фокус.
или надо уеньшать размер ФС блока скажем до 1КБ  при форматировании. тогда  у нас в файле
чтобы работали фокусы с экономией места на диске уже могуть быть более маленкие куски 
по 1КБ. получается что спарс файл его несозать если у нас в файле много нулей но они 
не имеют непрервыных участков размером с блок ФС.

получется что программе которая должан понять если в файле спарс  куски или нет работать 
очень просто  - она берет метаданые файла и начинает искать в блоке который отвечает за 
список блоков на диске где хранится тело файла он там ищет блоки у которых вместо адреса 
блока на дике просто нули. раз в адресе блока стоит ноль значит это уже файл со спарс кусками
(их еще назыают дырки). 

плюс спарс файла состоит в том что если у нас файл 100G имеет половину внутри себя нулей
кусками по 4КБ скажем то количество места которое надо потратит на сторадже чтобы его 
там записать будет всего 50GB. для приложения будет видно 100G а по факту на сторадже
будет 50g. это как бутто мы применяем к файлу сжатие на лету условно говоря.

минус спарс файлв в том что если в процссе рабоы у нас число нулей будет все менше и менше
то этот файл начнет на сторадже потреблять все больше и больше места и получаетя что 
если у нас на сторадже размером 100G лежит два спарс файла по 100G каждый из которых по фатку
занимает 40GB (итого 80) по мере потерри нулей они начнут расти на сторадже и в итоге
им понадбится 200GB а у нас сторадж на 100. так что вроде как изачально мы смогли вместить
в сторадж данных больше чем у него размер а потом надо будет дергаться и както расгирять 
сторадж. с обычными файлами (непарс) такой проблемы нет. если ты записал два файла по 40ГБ
то они вседа будут занимать 80ГБ и нет прблем.

итак спарс файл все его блоки по 4КБ в которых сплошняком нули - они незанимают 
ни единого блока под тело на диске. все что он занимет это олько его метаданные. и все.
как я уже сказал как я понимаю в метаданных в таблице в которой запиываются адреса блоков
на сторадже где икать тело файла там нули. так выгдлдяит техническая реализация 
спарс файла. понтно что не все его блокт обязаны быть нулями. какието с нуляи какието без.
чем больше нулей тем мноше он занимает на сторадже. чем мегше нулей тем больше занимает 
дата блоков на сторадже.

что еще важно сказать - что параметр size в иноде файла он указывает 
не то сколкьо места тело файла занимает на диске . НЕТ! он показывает сколько 
виртуальных байтов составляет файл. поскольку файл это набор байтов  к которым можно обращаться
через оффсет(адрес смещения к байту), то size описывает сколько виртуальных байтов наш 
файл имеет. но это незначит что на сторадже тело файла занимает такое количеатво байтов.
если сравниить с zip архивом то size файла это как бы размер архива в разжатом состоянии
а обьем который файл занимает на сторадже это как бы размер архива в сжатом состоянии. вот
такаая аналогия. тоесть полу size в иноде оно указывает максимальный размер офссета (в байтах)
по которому клиент может обратиться к этому файлу через драйвер фс и драйвер фс обяазан вернуть
какоето значение по этму адресу оффсета. тоест size это размер файла для внешней программы
для клиенского запроса. и еще раз скажу что size совсем не показывает сколько же байтов
занимает этот файл его тело на бекенд сторадже. это соверщенно отдельный вопрос.

переходим к пракитике
как создать спарс файл у которого все блоки с нулями. ответ через dd

# dd if=/dev/zero of=sparse_file bs=1 count=0 seek=16K

кстати еще один вариант dd чтобы создать sparse файл

# dd if=/dev/zero of=output2 bs=1G seek=0 count=0

видимо весь секрет в count=0

чтобы создать спарс файл вместо утомительного dd можно юзать truncate 

# truncate -s 1G  vasya.txt


мы создали файл у которого виртуалный размер , размер для внешнего клиента
будет выглядеть как 16KB. полувчается что мы с клиентсой прогарммы можем обращаться с 
запросом на чтение\запись к любому байту в пределах от 0 до 16384 (оффсет) и туда чтото
писать или отттуда чтото получать в ответ (читать).


псмотрим сколько реально этот файл занимает на физ диске. 
имеется опять же ввиду сколько занимает тело файла. потому что сколько занимают
его метаданные обычно утилиты это не показвыают. 


# stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 15          Links: 1




замечу что поле File: sparse_file это всего навсего имя файла а не его тип.
не путай. тип файла regular file. тоесть обычный файл. 

тоесть у линукса у него нет формально такого типа файла как спарс файл. 
спарс файл это бычный файл с точки зрения лиунус. просто у него там внутри немножко
есть специфических свойств. так что вопрос как определить спрас файл или не спарс  я покажу чуть ниже.

важно дургое

Size: 16384 = это покзывает вирт размер файла. 

Blocks: 0  = а вот это поле (внимание) показывает сколко реально места надиске
занимает тело файла. опять эе повторю именно тело. про метаданные вобще ни слова.
размер тела на диске покзывается в таких дебильных единицках как блок по 512 байт.
никаких блоков по 512 байт на диске нет. таких блоков там нет. просто нам надо взять 
512 умножить на число стоящее в графе Blocks и тогда мы узнаем солкьо же байт 
физически занимает тело файла на диске. тоесть число блоков в этой графе это брехня полная.
а вот число умноженное на 512 и полученный редультат в байтах это уже реальное
настоящее число. имеющее физ смысл.

тоесть я пояню на не спарс файле еще раз смысл поля Blocks:

# stat /swapfile
  File: /swapfile
  Size: 2147483648  Blocks: 4194312    IO Block: 4096   regular file
Device: 10302h/66306d   Inode: 12          Links: 1

мы берем  Blocks: 4194312
он говоритт что якобы тело файла на дсике занимает 4194312 блоков по 512 байт размером.
это брхня полная. никакиз блоков по 512 байт на диске нет. ни секторов на диске размером
512 байт нет. ни на фс блоков по 512 байт нет. это брехня полная. кодга то давно
были диски с физ секторами по 512 байт. вот он тогда это и показывал. щас такого ничего
в реангсти нет. а что есть умнжожаем 4194312 на 512 получаем 2147487744 байт.вот 
это число ужее имеет физ смысл. оно говорит что на физ диске тело файла (метаданные отедный вопрос) занимает столько то байт.   параметр Blocks можно понять на примере бумажной
книги и электронного варианта этой книги.  а еще лучше на прмиере сравнит библиотку из бумажых книг и элктроннного вариант этой библиотки.   мы берем суем все книги в элктронном формает в ноубук. и тогда библиотк чисто физиски в квартире занимает всего обьем размерсо с корпус ноубука. а праметр Size:  он показвает сколько бумажных страниц этих книг можно будет пролистать  если эти книги открыть на ноутбуке. тоесть что буманая библиотеека имеет размер
миллион страниц. что элетронная. и там и там size будет один и тот же. но 
влсучае бумажной бибилиотки парметр Blocks будет 1 000 0000 (тоесть книжный шкаф)
а слувае элктронной билиотки это будет всего Blocks 1 потому что все влезло в маленкий
ноубук.

итак на этом примере стала понятен физ смысл и разнциа между таким параметрами 
ноды как Size и Blocks коорые покаызвает утидита stat. котоаяр беерет эти цфиры из иноды.плюс
минус. 


вохварщаемя к нашему спарс файлу


# stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 15          Links: 1


итак мы создали файл с вирт размером 16K
и это видно в  Size: 16384 
тоесть прилоение может напихаь в это файл 16К байтов.
на данный момент на бекенд сторлаже тело файла занимает Blocks: 0  , 0*512=0 байт

какие у нас еще есть утилиыт для получения инфо о структуре файла
есть

# du -sh sparse_file
0   sparse_file


видим ноль. тоесть на сторадже тело файла занимает 0 байт.
в чем прелесть du она всегда по дефолту поуказывает именно
не дутый виртуальный размер файла. а именно сколько байт занимает файла
физически на физ сторадже.

а если мы хотим посмореть вирт размер файла то надо добавить ключ

1# du -sh  --apparent-size    sparse_file
16K sparse_file

это он покзывает вирт размер файл на диске. котооый соверешенно не отражает
сколкьо же байт фактически занимает файл на диске.

таким образом можно используя stat либо du получаьт ответ а файл у нас sparse
или нет.

посмотрим еще один файл 


# stat /var/log/lastlog 
  File: /var/log/lastlog
  Size: 292292      Blocks: 8          IO Block: 4096   regular file


вирт размер файла 292292 байт
а фактически он заниает на диске  8 * 512 = 4096 байт.
очеивдно что соверщенно не совпдаает . пэтому файл однозанчно спарс.

да конечно Blocks * 512 может немного не совпдатаь с Size когда файл не спарс
по соверщенно дургой причине что файл неможет занимать обьем не кратный размеру блока ФС.
например

# echo "2" > 2 
root@vm1:/mnt/sdb1# stat 2
  File: 2
  Size: 2           Blocks: 2          IO Block: 1024   regular file

  вирт размер файла 2 байта
  занимает на диске 2*512 = 1024 байта. 
  разница не потому что файл спарс. а потому что размер блока ФС = 1024байта (IO Block: 1024)
  оэтому файл размером 2 байта неможет занимать места на диске меньше чем 1 ФС блок.
но к спарс это неимеет никакого отношения.


утилита find якобы тоже позволяет опледелять спарс файл или нет. 

# find /var/log -type f  -name "lastlog"  -printf "%S\t%p\n"
0.0140134   /var/log/lastlog


если число меньше 1 
то это значит что в файле есть спарс куски.

посмоотрим на этот lastlog

# stat /var/log/lastlog 
  File: /var/log/lastlog
  Size: 292292      Blocks: 8          IO Block: 4096   regular file

у него вирт размер 292292
а размер который он по факту занимате на стораже равен 8*512= 4096 байт

4,096 << 292,292  ( 4096 намрного менше чем 292 тыши)

поэтому конечно это спарс файл.

разберем find

-printf "%S\t%p\n"

printf это просто опци утилиты find которая описывает в каком формате выводить
на экране результаты поиска. 

\n - означает перенос строки
\t означает сделать табуляцию
%p - означает напечаать имя файла
%S - самая важный ключ . означает что нужно файла расчитаьт вот такую хрень
(BLOCKSIZE*st_blocks / st_size) и вывести ее на экран. откуда find берет данные 
для рачсета это йхрени я незнаю. мне кажется что find исполует тот же самый сиколл
что и команда stat. как я пониаю "BLOCKSIZE" это ничто иное как 512 а "st_blocks" это "Blocks:" из команды stat тоесть

(BLOCKSIZE*st_blocks) = (512*"Blocks:")

а    "st_size" это "Size:" из команды stat.

и вот он это вычитывает и выводит на экран. тоесть это коэффициент 
отношения сколько реально байт на диске занимает тело файла к виртульному размеру файла.

проверим

# stat /var/log/lastlog 
  File: /var/log/lastlog
  Size: 292292      Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d  Inode: 72225       Links: 1


# echo "scale=10; 8*512/292292" | bc
.0140133838

сверяем с тем что покзыает find

# find /var/log -type f  -name "lastlog"  -printf "%S\t%p\n"
0.0140134   /var/log/lastlog

полнейшее совпадение

итак мы рассмотрели утилиты :
 - stat
 - du
 - find

 кстаи посмотрим что покажет du

#  du -sh /var/log/lastlog 
4.0K    /var/log/lastlog

полное совпдаение с тем что покзывает stat!

таким обрзаом мы через find можем найти все файлы котоыре спарс.
а через stat или du мы можем проверить тоже спарс файл или не спарс.
и узнать сколко же точно занимает на сторадже файл.

кстаи проверим наш файл "2"

# stat 2
  File: 2
  Size: 2           Blocks: 2          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 20          Links: 1

# find ./  -type f  -name "2"  -printf "%S\t%p\n"
512 ./2


512 намного больше 1. конечно же этот файл аболсютно не спарс.

поулчается если число менше чем 1. то это спарс файл. он занимает на диске 
места менше чем его вирт размер.

а если коэфициуент болше 1 то файл на диске занимает гораздо болше места 
чем его вирт размер. тоесть он попусту разбазаривает место на сторадже.


какова схема чтобы спарс файлы давали реузльат. например на mysql 
при создании таблцы надо указа что она будет "сжатая" тогда 
когда муслку будет рбоатать с этой таблцей не диске то он будет при записи
записывать данные так что скажем там где нули то он не просто тупо будет 
пихать нули а будет их пихаьт так чтобы они были спарс. дело в том что
даже для юзеров есть команда чтобы взять файл полный нулей натравить на 
него команду и файл превратитлся в спарс. в случае приложения которое юзает 
файл надо чтобы оно постояно так делало. потому что если мы будем руками 
файл первравать в спарс а приожение будет просто тупо по старому нули пихать 
в файл то он будет преврашаться не в спарс. 
преварение обычноо файла в спарс называется "punch holes" пробивать дырки.


пример
созаем класический не спарс файл у которого занчения только нули

# dd if=/dev/zero of=./t1 bs=1M count=1


провеяем сколько он занимет места на диске

$ du -sh t1
1,0M    t1

или так

$ stat t1
  File: t1
  Size: 1048576     Blocks: 2048       IO Block: 4096   regular file


512*2048 =  1048576 байт


теперь натравливает на него fallocate

# fallocate --dig-holes  t1

он ищет блоки с нулями. отвязывает эти блоки от файла. возвращает их в сторадж.
и как я уже писал выше в таблице которая указывает адреса блоков с телом файла вставляет
нули. и драйвер фс уже понимает что для такогото блока ФС у нас весь блок это сплоншные нули.
получается для 4К блока данных тела файла надо заюзать всего лишь 4 байта в таблице блоков 
в метаданных

$ du -sh t1
0   t1

вуля. файл на сторлалже занимает  0 байт

$ stat t1
  File: t1
  Size: 1048576     Blocks: 0          IO Block: 4096   regular file


попробуем еще чего нибудь сделать как спарс. осбенно какит остатические файлы
из downloads

$ du -sh alpine-standard-3.17.3-x86_64.iso
154M    alpine-standard-3.17.3-x86_64.iso
$ fallocate -d alpine-standard-3.17.3-x86_64.iso
$ du -sh alpine-standard-3.17.3-x86_64.iso
152M    alpine-standard-3.17.3-x86_64.iso

видно что некоторый эфект есть

еще пример

$ du -sh geo_title_index.ibd
297M    geo_title_index.ibd


$ fallocate -d geo_title_index.ibd
$ du -sh geo_title_index.ibd
259M    geo_title_index.ibd

видно что какйотт эфект есть


а вот еще пример

# find ./ -type f -printf "%S\t%p\t%s\n" | awk '$1 < 1.0 {print}' | sort

он выводит только файлы у которых цисло %S<1 тоест толлько спарс файлы.
выводит вируальный размер файл и имя файла. и сортирует вывод так что 
вверху выводятся самый спарс файлы.


итак ключ -d или --dig-holes у fallocate позвяет  обычные файлы трансфорировать
в спарс файлы

# fallocate -d alpine-standard-3.17.3-x86_64.iso

с помощью fallocate можно брать готорые файлы искать там дырки. и замещать их спарс кусками.


как же dd изготваливает спарс файл? через сисколлы lseek и ftruncate.
читать оних не буду нет время.

расмотрим  еще одну утилиту для анализа фа1лов
# filefrag -e sparse_file
Filesystem type is: ef53
Filesystem cylinder groups approximately 251
File size of sparse_file is 16384 (16 blocks of 1024 bytes)
sparse_file: 0 extents found


ее основное предназначение это показать из скольких экстентов
реально на диске состоит файл. экстент это непрервыный набор блоков ФС. непрервыный кусок.

у данного спарс файла экстентов нет. поому что  у него вобще ФС блоков нет.

ксатии походу куча программа юзет stat сисколл. 

еще пример 

# filefrag -e vmlinuz-5.15.0-1035-kvm 
Filesystem type is: ef53
File size of vmlinuz-5.15.0-1035-kvm is 6946312 (1696 blocks of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..    1695:     314368..    316063:   1696:             last,eof
vmlinuz-5.15.0-1035-kvm: 1 extent found



а вот что показывает debugfs

Inode: 60572   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 3649225635    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 6946312
File ACL: 0
Links: 1   Blockcount: 13568
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x648bc4dd:d638f9d8 -- Fri Jun 16 02:11:41 2023
 atime: 0x64a6b853:a0f5d88c -- Thu Jul  6 12:49:23 2023
 mtime: 0x646f76aa:00000000 -- Thu May 25 14:54:34 2023
crtime: 0x648bc4dd:cac74578 -- Fri Jun 16 02:11:41 2023
Size of extra inode fields: 32
Inode checksum: 0x06d3898a
EXTENTS:
(0-1695):314368-316063



и еще третья команда на десерт

# hdparm --fibmap ./vmlinuz-5.15.0-1035-kvm

./vmlinuz-5.15.0-1035-kvm:
 filesystem blocksize 4096, begins at LBA 227328; assuming 512 byte sectors.
 byte_offset  begin_LBA    end_LBA    sectors
           0    2742272    2755839      13568




получается сравнивая  эти команды я  прихожу к выводу что 
314368-316063  это не LBA сектора на физ диске как об этом пишет filefrag в колонке 
"physical_offset" а это блоки ФС. (зацени разницу LBA сектор физ диска и блок ФС).


а (0-1695) это офссет набор. офссет это смешение внутри файла для адресаации байта 
когда мы обращаемся из клиента к файлу. внутри файла при обращении через клиент 
все байтики как бы лежат рядом . нет разрывов. и оффсет позволяет заать адрес того байта
который мы хотим считать

еще момент. как я уже сказал вся эта спарс механика работает только изнутри на уровне бекенда
а с точки зрения клиента это обычный файл. поэтому еси скажем мы копируем спарс файл
то дестинейшн файл будет обычный. если нам надо чтобы и дестинейшн файл был спарс 
проги имеют спец ключи:

tar --sparse 
rsync --sparse
cp --sparse=always
dd  conv=sparse

проверяем

# stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file

# du -sh sparse_file
0   sparse_file

# cp --sparse=always sparse_file cp_sparse

# du -sh cp_sparse 
0   cp_sparse

типа да. типа работает.


далее отойдем в сторону. есть утилиты у ext для того чтобы склонировать партишн (ФС)
To clone a partition from physical disk /dev/sda, partition 1, to physical disk /dev/sdb, partition 1 with e2image, run

# e2image -ra -p /dev/sda1 /dev/sdb1

понятно что чтобы было все чик пибабум надо отмонтировать фс.
также e2image может копироват в файл в формат QCOW тоест мы можем таким макаром
железную машину превратить в виртуалку. прикольно.

естьи еще всякие приколные утилтиты для копировани партишенов. клонирования.
( ссылки по теме:
- https://wiki.archlinux.org/title/disk_cloning
- https://superuser.com/questions/641903/e2image-restore-file-system-metadata
- https://serverfault.com/questions/981766/
- https://serverfault.com/questions/981766/how-to-write-a-sparse-linux-ext4-disk-image-without-writing-gigabytes-of-zeros
)

еще способо создания спарс файла
$ truncate -s 512M file.img

а вот еще один сопосб как типа задетектить что файл спарс

# ls -ls 
total 18
 1 -rw-r--r-- 1 root root           2 Jul  6 20:00 1
 0 -rw-r--r-- 1 root root           0 Jul  6 21:29 10k
 1 -rw-r--r-- 1 root root           2 Jul  6 23:33 2
 0 -rw-r--r-- 1 root root       16384 Jul  7 13:03 cp_sparse
 1 -rw-r--r-- 1 root root         213 Jul  6 14:23 demo.txt
12 drwx------ 2 root root       12288 Jul  6 20:03 lost+found
 0 -rw-r--r-- 1 root root           0 Jul  7 12:42 output2
 1 -rwxr-xr-x 1 root root         368 Jul  6 14:40 p1.py
 0 -rw-r--r-- 1 root root       16384 Jul  6 23:28 sparse_file
 2 -rw-r--r-- 1 root root        2046 Jul  6 21:03 sparse_file2
 0 -rw-r--r-- 1 root root 10737418240 Jul  6 20:50 sparse_file3
 0 -rw-r--r-- 1 root root     5242880 Jul  6 20:52 sparse_file5

 левая колонка это сколко файл занимает на диске.
 а правая колонка какой вирт размер файла


 далее еще интерсно. как увеличить размер файла - неважно спарс он или не спарс
делаем это через dd

имеем исх файл с 16K вирт размер

 # stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file

# dd if=/dev/zero of=sparse_file   bs=1 count=0 seek=32K

проверяем
# stat sparse_file
  File: sparse_file
  Size: 32768       Blocks: 0          IO Block: 1024   regular file


вирт размер стал 32K. контен файла незатронут


теперь малек откатися назад. поговорим опыть про структуру как устроена фс
только не ext2 а ext4

фс разбивает раздел на блоки ФС. причем не просто на блоки. а на группу блоков.
сколько блоков в группе блоков - вот сколько -> берем блок ФС ( тот который задается при форматировании. например 4КБ размером.) и каждый бит этого блока байтов отвечает за один блок ФС. тоесть 4КБ это 4096 байт это 4096*8= 32768 бит. вот значит при ФС с размером блока 4К у нас в каждой группе 32768 блоков.  а если унас блок ФС имеет размер 64К. значит это 
524,288 штук блоков в группе блоков.

далее очень интеерсно - согласно доке по ext4 ( https://www.infradead.org/~mchehab/rst_conversion/filesystems/ext4/overview.html) видно что максимльный размер ФС блока 64KiB.
однако! наебка состоит в том что в реальности смонтировать такую ФС  неполучится. потому что 
незна точно кто виноват толи ядро толи код ФС ext4 но макс размер блока на ФС должен быть 
равен cpu page size тоесть размеру той хрени которой оперирует цпу когда работае с память.
тоест цпу обычно может из памяти таскать блоки по 4KB.вобщем cpu page size это отдельная эпоппея которою я щас не буду читать. это некая хараектиристика процессора.
пока что фишка в том что в процессеоре есть блок MMU. он то и определяет какой размер 
page size. как я понимаю через mmu идеь преоборазование вирт мемори у процесса в физ мемори компа. этим занимается mmu. и как я понял когда процесс хочет себе +1 кусок памяти получит
то он делает запрс к ядру. и вобщем в итоге процесс может получать из памяти куски только 
кратные размеру page size. в итоге RAM преврщается как бы в блочное устрйство. 
в памяти ядра поддерэивается таблица в которой прописывается какой процесс какие пейджы имеют.
в итоге когда процесс хочет прочитать чтото их памяти по адресу то MMU пользуяюсь таблицей пейджей лезет в память. также как ФС c его ФС блоками позволяет отформтаировать раздел.
также MMU  + page table с пейджами позвволяет отформатровать память для потом выдачи процессам.

пэтому можно офтртиовать раздел с -b 64K но смонтировать его не пуолчится. так как 
все по каким то причинам упираетс в page size cpu котоырй у интела 4К.

еть другая фишка у ext4 bigalloc. она задется при форматирваоии. и состоит в том что 
в битмап файле который находится в группе блоков и сидит в одном ФС блоке и каджый его бит
мапит один блок в группе блоков на предмет блок свободен или юзается . и вот bigalloc менет то что у нас 1 бит в битмапе (который сидит в одном блоке ФС) мапит уже не на 1 блок на 
сразу группу блоков. это дает то что в одной группе блоков может быть дохера бблоков
а вот нахер это нам надо в итоге непонятно.


в общем рассмтоиим ext4 с 4K размером ФС блока.
тогда макс аколичетво блоков 2^32 (для 32 битный цпу). блок по 4КБ. в итоге
раздел 16ТБ.

макс колво инод 2^32

число блоков на гурппу 4096*8=32768 блоков это 128MB

макс число блоков которые можно заюзать для одного файла 
# echo "12+1024+1024*1024+1024*1024*1024" | bc
1,074,791,436

это 4TB получается макс размер одного файла при условии что он в своем block map
указывает на блоки ФС.

а если он юзает экстенты (как это там пропграмируется не знаю ) то соласно таблице 
такой файл может занять весь раздел ФС.

если файл меньше 60 байт то он сохранятеся внутри иноды


хотел упонмянть утилиту istat.
она типа дает взможность посмотреть содрежимое иноды 
потому что руками найти эту иноду и помсотреть ее слишком пока сложно

$ stat user.frm
  File: user.frm
  Size: 3159        Blocks: 8          IO Block: 4096   regular file
Device: 10302h/66306d   Inode: 9866215     Links: 1




$ sudo istat /dev/nvme0n1p2 9866215
inode: 9866215
Allocated
Group: 1204
Generation Id: 2125201302
uid / gid: 1000 / 1000
mode: rrw-rw----
Flags: Extents, 
size: 3159
num of links: 1

Inode Times:
Accessed:   2023-07-07 06:16:15.046144629 (+06)
File Modified:  2023-06-27 17:03:25.565822956 (+06)
Inode Modified: 2023-06-27 17:03:25.565822956 (+06)
File Created:   2023-06-27 17:03:25.565822956 (+06)

Direct Blocks:
42371581 


видим флаг Extents,
и вот еще интересный блок

Direct Blocks:
42371581 



$ filefrag -e user.frm
Filesystem type is: ef53
File size of user.frm is 3159 (1 block of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..       0:   42371581..  42371581:      1:             last,eof
user.frm: 1 extent found


поэтому  42371581  это адрес ФС блока.


далее про debugfs. в чем пиздец этого интсрумента что он показывает offset
в OCT формате ссука!!
пример

$ sudo debugfs /dev/nvme0n1p2
debugfs 1.44.1 (24-Mar-2018)
debugfs:  inode_dump <9866215>
0000  b081 e803 570c 0000 4f59 a764 fdc1 9a64  ....W...OY.d...d
0020  fdc1 9a64 0000 0000 e803 0100 0800 0000  ...d............
0040  0000 0800 0100 0000 0af3 0100 0400 0000  ................
0060  0000 0000 0000 0000 0100 0000 fd89 8602  ................
0100  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 96ff ab7e 0000 0000 0000 0000  .......~........
0160  0000 0000 0000 0000 0000 0000 505a 0000  ............PZ..
0200  2000 6fe1 b017 e786 b017 e786 d471 000b   .o..........q..
0220  fdc1 9a64 b017 e786 0000 0000 0000 0000  ...d............
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*



0020 = это OCT число. в десятичном формате это 16.
что совершенно совпадает с тем что мы видим. я  ахуе нахуя ты показываешь 
hex дамп а смещение показываешь в OCT формате. ебнутые долбоемы


эта команда в debugfs она показыает содержимое иноды.



ссылка  - как вручную восстановить удаленный файл (https://tldp.org/HOWTO/archived/Ext2fs-Undeletion-Dir-Struct/index.html) на ext фс.


еще ссылка - про устйроство ext4 (https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout)


debugfs посмртеть статистику по файлу

> debugfs:  stat <9866215>
Inode: 9866215   Type: regular    Mode:  0660   Flags: 0x80000
Generation: 2125201302    Version: 0x00000000:00000001
User:  1000   Group:  1000   Project:     0   Size: 3159
File ACL: 0
Links: 1   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x649ac1fd:86e717b0 -- Tue Jun 27 17:03:25 2023
 atime: 0x64a7594f:0b0071d4 -- Fri Jul  7 06:16:15 2023
 mtime: 0x649ac1fd:86e717b0 -- Tue Jun 27 17:03:25 2023
crtime: 0x649ac1fd:86e717b0 -- Tue Jun 27 17:03:25 2023
Size of extra inode fields: 32
Inode checksum: 0xe16f5a50
EXTENTS:
(0):42371581

видно что файл состоит из одного экстента. (0) = номер экстента
42371581 = экстент состоит из одного ФС блока

а вот как выглядит эта же инфа для файла подкачки


Inode: 12   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 22243306    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 2147483648
File ACL: 0
Links: 1   Blockcount: 4194312
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x61bff7ed:96ba0c00 -- Mon Dec 20 09:26:37 2021
 atime: 0x61cd0783:9688a5b4 -- Thu Dec 30 07:12:35 2021
 mtime: 0x61bff7ed:96ba0c00 -- Mon Dec 20 09:26:37 2021
crtime: 0x61bff7e7:7fd2af8c -- Mon Dec 20 09:26:31 2021
Size of extra inode fields: 32
Inode checksum: 0xef5641ee
EXTENTS:
(ETB0):33853, (0-32767):34816-67583, (32768-63487):67584-98303, (63488-96255):100352-133119, (96256-126975):133120-163839, (126976-159743):165888-198655, (159744-190463):198656-229375, (190464-223231):231424-264191, (223232-253951):264192-294911, (253952-286719):296960-329727, (286720-319487):329728-362495, (319488-352255):362496-395263, (352256-385023):395264-428031, (385024-417791):428032-460799, (417792-450559):460800-493567, (450560-481279):493568-524287, (481280-514047):557056-589823, (514048-524287):589824-600063
(END)

видно что много экстентнтов.

кстати строка
Size of extra inode fields: 32
говорит о том что в саму иноду можно запихать 32 байта если файл мелкий

сравнпиваем со списокм экстентов через другую утилиту
# filefrag -e /swapfile
Filesystem type is: ef53
File size of /swapfile is 2147483648 (524288 blocks of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..   32767:      34816..     67583:  32768:            
   1:    32768..   63487:      67584..     98303:  30720:            
   2:    63488..  126975:     100352..    163839:  63488:      98304:
   3:   126976..  190463:     165888..    229375:  63488:     163840:
   4:   190464..  253951:     231424..    294911:  63488:     229376:
   5:   253952..  481279:     296960..    524287: 227328:     294912:
   6:   481280..  524287:     557056..    600063:  43008:     524288: last,eof
/swapfile: 6 extents found



а вот тут я нашел формат иноды в ext2.
(дело в том что в ext4 формат иноды значиельно сложнее)

https://wiki.osdev.org/Ext2

удвиетлеьно как я понял инода в себе не содержит номер иноды.
это как?

соласно таблице в 40-43 байтах(надо помнить что байту нумеруются с НУЛЯ!) содержится номер первого блока в котором 
хранится первый блок тела файла.

ксати как узнать версию ext.
ответ через
# lsbkl -f



посмотрим на практике:

# echo "123" > ./t1.txt

# stat t1.txt 
  File: t1.txt
  Size: 4           Blocks: 8          IO Block: 4096   regular file
Device: 821h/2081d  Inode: 14          Links: 1


# filefrag -e t1.txt 
Filesystem type is: ef53
Filesystem cylinder groups approximately 16
File size of t1.txt is 4 (1 block of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..       0:       1027..      1027:      1:             last,merged,eof

видим что тело файла лежит в одном экстенте в блоке ФС по адресу 1027

теперь возьмем и считаем напрямую через dd контент файла зная в каком ФС блоке
лежит тело файла

# dd if=/dev/sdc1  bs=4K count=1 skip=1027  
123

получилось !


смотрим содержимое иноды
# istat /dev/sdc1 14
inode: 14
Allocated
Group: 0
Generation Id: 818513347
uid / gid: 0 / 0
mode: rrw-r--r--
size: 4
num of links: 1

Inode Times:
Accessed:   2023-07-07 21:11:37 (UTC)
File Modified:  2023-07-07 21:21:15 (UTC)
Inode Modified: 2023-07-07 21:21:15 (UTC)

Direct Blocks:
1027 

видим что опять же указано что ФС блок с телом файла лежит в 1027 блоке ФС


посмотрим на иноду в hex виде

# debugfs /dev/sdc1 
debugfs 1.46.5 (30-Dec-2021)
debugfs:  inode_dump <14>
0000  a481 0000 0400 0000 897f a864 cb81 a864  ...........d...d
0020  cb81 a864 0000 0000 0000 0100 0800 0000  ...d............
0040  0000 0000 0100 0000 0304 0000 0000 0000  ................
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 c385 c930 0000 0000 0000 0000  .......0........
0160  0000 0000 0000 0000 0000 0000 0000 0000  ................
0200  2000 0000 8067 8a78 8067 8a78 acd7 02c3   ....g.x.g.x....
0220  897f a864 acd7 02c3 0000 0000 0000 0000  ...d............
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

осчиывтываем 40 байтов (первый байт нулевой) и берем 4 байта

итак байты 40-43 выглядят как 0304 0000
значит согласно debugfs адрес первого блока с телом файла равен 0304 0000

мы знаем из верхних команд что  адрес ФС блока где лежит файл это 1027 
однако  hex (03 04 00 00) совершенно не дает цифру 1027
в чем же дело.


далее еще прикол. 
если в свойтсвах суперблока укзана фича под названием super_sparse

# dumpe2fs /dev/sdc1 -h | grep -i  features
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file

это значит что копии суперблока сохраняются не в каждой группе блоков 
а только в группе 0 и в групппах которые делятся нацело на 3, 5 и 7.
прикольно. 
для примера такими группами блоков являются группы с номерами

1 3 5 7 9 25 27 49 81

если у нас размер фс блока 4К а в группе блоков тогда 32768 блоков
то умножаем 32768 на эти номера и получаем номер фс блока где лежит копия суперблока.

32768 98304 163840 229376 294912 819200 884736 1605632 2654208

прикольно (взял отсбюда https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/)



возвращаемся к 1027 и (03 04 00 00)
сравниваем то что мы видим из debugfs

0000 0403  (1027 в hex виде  на бумаге)
0304 0000  ( то что видим в  debugfs )

почему же они не совпадают. разберемся.

во первых разберемс что такое endianness. little endian. big endian.
небольшое отступление скажу что вместо hexdump рекомендую hexyl и od об этом  смотри файл hex.txt
возвращаемся к endan.
от чего она зависит - если мы говорим про запись в память то зависит от 
цпу. его модели. 
теперь о чем эта хрень - если мы записываем в память поток битов который имеет длинну
несколько байтов то возникает вопрос в ячейку памяти у которой адрес меньше какой 
байт будет записан который в себе несет более значительную часть или менее значительную часть?

тоесть если мы представим два байта как целое число
например число FF AA где 
FF определяет условно говоря тысячи   у числа а AA определяет только его десятки 
и единицы. то такая запись FF AA называется Big Endian и кстати она совпадает с тем как 
мы записываем числа на бумаге или печатной машинке. у нас более значительная часть числа (его тысячи) идет левее (или еще можно сказать
что мы ее пишем рукой первее во времени) а незначительная часть скажем десятки и единицы мы пишем правее (или еще можно сказать более позднее во времени)
тоесть скажем число 35000. мы рукой вначале напишем 35 а уже только потом 000. 
35000
на бумаге у нас 35 идет левее а 000 правее. эта запись называется BiG Endian
тоже самое касается шестнадацатиричной системы обозначения чисел если FF это условно тысячи а AA это десятки то запись
FF AA это Big Endian
а запись 
AA FF это Little Endian
в любом случае  FF байт назыается MSB (most significant byte) а AA байт называется LSB(leat significatn byte)

аналогично для целого числа из четырех байтов

FF CC BB AA  - это Big Endian тип записи
AA BB CC FF  - это Little Endian тип записи

FF = MSB
AA = LSB

так вот прикол в том что на бумаге мы используем Big Endian тип записи
а в оперативке числа записываются в Little Endian записи 
и на диске в файл числа записываются тоже в Little Endian

если наше число FF CC BB AA на бумаге то  в памяти оно будет записано как 

0   1  2  3    <== адрес ячейки в RAM
AA  BB CC FF

litlle endian схема.

little endian запись чисел в оперативку характерна для Intel и ему подобных цпу  
есть другие цпу которые используют Big Endian но нам на них настрать

еще раз скажу что в случае записи в память это завсит от модели цпу.

интелы они little endian пишут в память.

еще важно сказать что endianness говорит о порядке записи БАЙТОВ 
но ничего не говорит о порядке записи битов. в каком порядке будут записаны биты байта 
в память - об endianness ничего не говорит. это не оговаривается. не регламентируется.

итак еще раз endiannes это об порядке записи байтов. она оперирует байтами как единицей.
как при этом биты записываются внутри байта это не оговаривается.

далее. поговорим про считывание байтов из памяти когда они туда засунуты в little
endian и отображении их на экране.
если у нас little endian система записи в память то  мы счиытываем
из памяти байты вначале с меньшим адресом и согласно little endian мы при этом считываем менее значительные байты LSB
пусть у нас в памяти для примера лежит число AA(LSB) BB(MSB) оно лежит следущим образом
адрес 001RAM = AA
адрес 002RAM = BB

мы считали эти два байта. начинаем их печатать на экране. первым мы считали AA и напечатли его на экране
> AA
далее мы считали BB где он будет напечатан на экране? экран как и печатная машинка и как и ручная запись работает так что то что было считано 
первее печатается слева а то что было считано после этого печатается правее от того что слева . значит на экране будет
> AA BB
также упомяну что на экране то что слева имеет меньший оффсет а то что справа имеет больший оффсет.
таким образом приходим к очень важному выводу что если у нас в памяти байты записаны как little endian то при считывании на экране их порядок
будет ровно такой же самый! тоесть слева LSB справа MSB! байт на экране у которого меньший офсет соотвествует байту в оперативной памяти у которого 
меньший адрес RAM !

еще пример

у нас есть на бумаге 4 байтовое число FF CC BB AA. FF это MSB а AA это LSB. на бумаге у нас Big Endian.
мы его записали в память. он там лежит в таком виде

0   1  2 3   <== адрес в памяти
AA BB CC FF

если мы считаем только из ячейки 0 то на экране будет
AA

если мы считаем дополиниельно теперь из ячейки 1 то на экране будет
AA BB

потому что печать на экране работает также как на печатной машинке. то что печатается первым то печатается слева. все что печатается дальше печается
правее. ровно также как при письме ручкой на бумаге.

если считаем из ячейки 2 то на экране бует
AA BB CC

если считаем из ячейки 3 то на экране будет
AA BB CC FF

тоесть сравним еще раз как выглядит дамп памяти 
и как будет выгдяедеть результат на экране

дамп:
0   1  2  3  4  5  
AA BB CC DD EE FF

на экране:
AA BB CC DD EE FF

мы видим что порядок байтов в памяти и порядок байтов на экране полностью совпадают

тоесть байт которы на экране записан левее (имеет меньший оффсет) в памяти тоже имеет меньший адрес RAM 
таким образом на экране мы видим прямое отображение памяти

возвращаемся  к нашему примеру с debugfs. мы имеем дамп:

03 04 00 00

причем 

03 это LSB
00 это MSB

тоесть

LSB -> 03 04 00 00 <- MSB

потому что как я уже сказал у нас на экране полное соотвествие порядка байтов как в памяти. 
тоесть то что слева имеет LSB то что справа MSB

далее чтобы нам понять а что же это за число нам надо его превратить в запись которую мы используем при обозначении чисел на бумаге 
а на бумаге мы юзаем Big Endian а он требует чтобы MSB байт имел меньший оффсет  а LSB байт имел больший оффсет. тоесть
BiG Endian = MSB ...... LSB

как видим на экране у нас все наоборот. значит преврашаем Little Endian в BigEndian

MSB -> 00 00 04 03 <- LSB

а это равно 0403 а это равно 1027 dec

все совпало!

замечу тут ряд важных моментов:
1) для того чтобы нам из дампа восстановить исходное число нам прежде всего
надо знать какая была длинаа в байтах у исходного числа.

вот мы знаем из доки что номер блока ФС кодируется через 4 байта. и тогда все понятно.

а то представим что у нас есть набор байтов из дампа

00 00 11 AA 34 45 67 ...

как нам отсюда восстановить оригинальное число не зная его длинну в байтах? никак

это может быть
67
или

67 45
или

67 45 34
и так далее

2) endianness влияет только на уровне байта. но никак не влияет на уровне битов
внутри байта. 

это дает то что если у нас есть байтовая последовательность из дампа

45 34 00 11 12 AB AC FA

и если мы незнаем по какой схеме у нас записывались эти байты в память или на диск
но при этом если мы знаем что интересующее нас число имеет длину 1 байт 
то нам это дает то что  при любой схеме  оригинальное число длинной 1 байт
будет иметь ровно то же значение что и в дампе. тоесть

если мы видим в дампе 45 то  при любой схеме оригинальое число перед записью тоже
было 45 а не 54 или какоето другое число. 
если в дампе мы видим FA то при любой схеме оригинальный байт перед записью 
тоже был FA а не FA или какое то другое число

тоесть endanness никак не изменяет число при записи если оно длинной 1 байт.
оно что в дампе что в жизни одинаково выглядит не меняется.

поэтому endianess оно влияет только на взаимое расположение байтов относительно 
друг друга в памяти , на диске или на бумаге. а на вид самих байтов никак не влияет.

поэтому если в дампе мы видим  45 34 
и мы знаем что оригинальное число было длинной два байта 
то тогда оригинальное число было либо

45 34
либо
34 45

и больше никак. в завиисомости была ли схема записи little endian или big endian.
меняется только взаимое расположение байтов друг относительно друга они меняется
местами. а сами байты остаются неизменными. это очень важное свойство.

пэтому есди у нас есть последовательность байтов из дампа
то нам чтобы восстановить оригинальное число надо знать endianness и длинну оригинального 
числа.  для ext4 мы знаем что драйвер этой фс пишет байты на диск в little endian.
тогда остается только значть длинну оригинальных чисел. например:

имеем дамп

0200 0000 0c00 0102 2e00 0000 0200 0000

первые 4 байта это номер иноды.
значит номер иноды = 00 00 00 02 = 2(dec)

следущие 2 байта это record length, значит
record length = 00 0c = 12 bytes

и так далее. 
еще раз поскольку endiannes при записи не влияет на сам байт а байт кодируется в 
hex виде двумя цифрами то когда мы восстанавливаем исходное число из дампа  у нас
комбинация из двух цифр никогда не меняется. тоесть как в первом примере мы имеем

0200 0000 . разбиваем на группы из двух цифр  (тоесть разбиваем биты по байтам) 
получаем (02)(00)(00)(00)
мы четко знаем что в оригинальном числе байт (группа из двух цифр) было ровно таким же самым.
поэтому 02 в дампе  приведет к тому что на бумаге тоже будет 02 а не чтото другое например 20.
единтсвенное что будет другое в оригинальном числе которое мы хотим восстановить на основе 
дампа это взаимное расположение байтов друг относительно друга. для литтл ендиан 
будет обратный поряок байтов. (малек уходя в стоону добавлю что мы даже не можем узнать и посмотреть в в каком же порядке по факту записаны биты на диск в прямом порядке или обратном потому что мы читая с диска можем получить в качетве минимальной единицы только байт. поэтому его битовая карта нам остается неизвестной)

итак это полная мудота с этими эндинесс

непонтно про bigalloc. он якобы позволяет в  секторе котоырй делает битмап (один бит 
кодирует один фс блок испольуеся он или нет) так вот bigalloc при форматировании 
позволяет сделат чтобы в битмап секторе мапился вместо одного блок фс целая куча блоков.
по идее что это дает - ну можно файл больше по размеру создать.
но что я не пойму в чем разница между бигаллоками и экстентами?

если блок 4К то размер фс макс это 16ТБ. макс размер файла 4ТБ (1024x1024x1024 *4K) если юзать
блоки. и макс размер файла 16ТБ если юзать экстенты (как юзать экстенты неясно пока)

в описании red hat 7 пишкт что размер фс макс это 50ТБ. откуда они это высрали
непонятно - https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-ext4

также ext4 also labels unallocated block groups and inode table sections accordingly, which allows them to be skipped during a file system check.



еше малек откатиммся. посмотрим что показывает формтирование


Discarding device blocks: done                            
Filesystem label=
OS type: Linux
Block size=4096 (log=2)                 # размер ФС блока 4K
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks  # stride= измеряется в блоках ФС
                                        # применяется если у нас ext4 сидит поверх
                                        # md устройства тоесть софт рейда.
                                        # каким то макаром это обьясняет незнаю кому
                                        # что stride количество блоков писать на один
                                        # физ диск. а все остльное на другой диск.
                                        # какая то чущь собачья
                                        # stripe= измерятеся в блоках ФС
                                        # обычно выставляется как stride*N
                                        # где N это число дисков в нижележащем рейде.
                                        # чушь собачья.  
                                        #  с помощью tune2fs можно это менять
                                        # tune2fs -E stride=32,stripe-width=96 -O dir_index /dev/mapper/UUIDofext4fspartition
                                        # еще раз подчеркну что stride и stripe
                                        # обозначает колчество блоков. а не байты
                                        # физ смысл их мне непонятен.
                                        # как дело фс до нижележащей архитектуры дисков?
                                        # как фс может на это влять? бред


130560 inodes, 521472 blocks            # на каждые 4 блока одна инода
26073 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=534773760     # это просто показан макс размер возможного раздела
                                        # получется 2ТБ...кхмм. маловато
16 block groups                         # 16 блок групп. 521472 блоков поделить на 32768
                                        # получаем 16 групп
32768 blocks per group, 32768 fragments per group # что таоке фрагменты хуй знает
8160 inodes per group
Filesystem UUID: 083390f6-70cf-4bab-9f50-6828fd00e6a2
Superblock backups stored on blocks: 
    32768, 98304, 163840, 229376, 294912  # суперблоки хранятся в группах блоков с номерами
                                          # 0 и кратные 3,5,7
                                          # если в группе 32768 блоков то суперблок хранися
                                          # в первом блоке группы блоков. блоки нумеруются 
                                          # с нулевого блока. получается группа блоков "0"
                                          # имеет номера 0-32767. тогда группа блоков с номером "1" имеет блоки 32768-65535. и копия 
                                          # суперблока сидит в 32768. вобщем  98304/32768=3
                                          # тоесть мы знаем номер группы блоков и в спске
                                          # мы видим адреса блоков фс в которых сидит бэкап
                                          # суперблока


Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done 


кстати что касаается тех же бэкапов суперлока. можно их посмотреть 
и по другому

# dumpe2fs ...

Group 0: (Blocks 0-32767) csum 0x558a [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-255
  Block bitmap at 256 (+256), csum 0x1ffc106e
  Inode bitmap at 272 (+272), csum 0x1a403b57
  Inode table at 288-797 (+288)
  24314 free blocks, 8149 free inodes, 2 directories, 8149 unused inodes
  Free blocks: 8454-32767
  Free inodes: 12-8160
Group 1: (Blocks 32768-65535) csum 0x6b7a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Reserved GDT blocks at 32770-33023
  Block bitmap at 257 (bg #0 + 257), csum 0x00000000
  Inode bitmap at 273 (bg #0 + 273), csum 0x00000000
  Inode table at 798-1307 (bg #0 + 798)
  32512 free blocks, 8160 free inodes, 0 directories, 8160 unused inodes
  Free blocks: 33024-65535
  Free inodes: 8161-16320




далее

Group 1: (Blocks 32768-65535) csum 0x6b7a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Reserved GDT blocks at 32770-33023
  Block bitmap at 257 (bg #0 + 257), csum 0x00000000
  Inode bitmap at 273 (bg #0 + 273), csum 0x00000000
  Inode table at 798-1307 (bg #0 + 798)
  32512 free blocks, 8160 free inodes, 0 directories, 8160 unused inodes
  Free blocks: 33024-65535
  Free inodes: 8161-16320

  прикольно то что видно бувакльно все
  в каком блоке block bitmap
  в каком блоке inode bitmap
  в каком блоке начинается таблица инодов
  ктатсти отично видно из чего состоит каждлая блок группа

  видно что ели еть ьэкап суперлока то он сидит в перовом блоке группы блоков

также видно что например Group descriptors at 32769-32769
тоесть в этих блоках находися Group Descriptors

  также важно понять что иноды хранятся пачками в блоках фс
  получается чтобы руками прочитать иноду надо найти ее блок. считать блок
  и внутри этого блока найти кусок длинной 256 байт.


  далее. прикол в том что ext4 при формтировании можно активировать фичи

# dumpe2fs /dev/sdb1 -h  | grep -i "Filesystem features"
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      
  has_journal 
  ext_attr 
  resize_inode 
  dir_index 
  filetype 
  needs_recovery 
  extent 
  64bit 
  flex_bg 
  sparse_super 
  large_file 
  huge_file 
  dir_nlink 
  extra_isize 
  metadata_csum


resize_inode фича дает то что как раз таки на фс резервируются блоки в "Reserved GDT blocks"
и за счет них можно на лету расширять ФС. 


также я думаю что tune2fs может какието фиичи активировать после того как фс отформатирована





свойства будушей фс для утилиты форматиования прописаны по дфеолту в
файле. тоесть их ненужно руками вбиват при форматиорвании раздела

$ cat mke2fs.conf 
[defaults]
    base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr
    default_mntopts = acl,user_xattr
    enable_periodic_fsck = 0
    blocksize = 4096
    inode_size = 256
    inode_ratio = 16384

[fs_types]
    ext3 = {
        features = has_journal
    }
    ext4 = {
        features = has_journal,extent,huge_file,flex_bg,metadata_csum,64bit,dir_nlink,extra_isize
        inode_size = 256
    }
    small = {
        blocksize = 1024
        inode_size = 128
        inode_ratio = 4096
    }
    floppy = {
        blocksize = 1024
        inode_size = 128
        inode_ratio = 8192
    }
    big = {
        inode_ratio = 32768
    }
    huge = {
        inode_ratio = 65536
    }
    news = {
        inode_ratio = 4096
    }
    largefile = {
        inode_ratio = 1048576
        blocksize = -1
    }
    largefile4 = {
        inode_ratio = 4194304
        blocksize = -1
    }
    hurd = {
         blocksize = 4096
         inode_size = 128
    }
[vasya@lenovo etc]$ 


параметр сколько инодов создавать в зависиомсти от размера раздела 
mkfs берет из этого файла. параматр inode_ratio
"big" , "huge", "floppy" это типа размер раздела. в зависимости от него mkfs
выбирает параметры. про "big" , "huge", "floppy" читай в man mkf.ext4 параметр -T

если честно не могу понять в чем важность суперблока.  я смотрел в него
и не вижу там ничего полезного одни общие стат данные.


группа блоков содержит в себе:
- супер блок\ копию супер блока \ (не во всех блок группах)
- group descriptor 
- reserved group descritpor blocks
- data block bitmap
- inode bitmap 
- inode table
- data blocks

приклокно что битмап для блоков и битмап для инод это отделные хрени
как я понял group descritpor содержит инфо где в блоке групп искать остальные хрени 
(data blocck bitmap и прочих) тоесть если супер блок он он содержит металанные вообще об фс
то group descriptor содержит метаданные о том что творится внутри конкртеного block group
чтоб драйвер мог ориеонтироваттся внутри блок группы.

на счет reserved group descritpor blocks непонятно нахуй он нужен. они пишут мол
это делаестся с учетом что фс может быть расширена в будущем. то что мне непонятно это то что
если фс расшириться то внутри существующей группы блоков нахуй ненужно нчиего менять.
на новом куске диск и буду создаваться ноые блок группы. поэтому что это за хуета и нахуй
она нужна непоятно. 

data block bitmap это один фс блок. в нем кждый бит показывает занят ли тот или оной блок
в группе или нет. расположение этой структуры нефиксировано. его адрес как раз хранисяя в
GT

inode bitmap - один блок. покзывает какие иноды в группе заняты. положение не фиксировано.
 адрес блока хранится в GT

походу прикл в том что информация о занятости блока дублируется в двух местах  в 
 data block biitnap и в inode bitmap

что еще непонятно - обязана ли инода в группе содержать в себе инфо о дата блоках
лежащих тлько в этой группе блоков или может содержать в себе и ссылки на дата блоки
из других групп блоков.

если посмотрим суперблок то полуим взаимсвязные цифры про иноды

Inodes per group:         8160
Inode size:           256
Inode blocks per group:   510
Block size:               4096

8160* 256 / 4096 = 510 (Inode blocks per group)


следущая хрень это flex groups

# dumpe2fs /dev/sdb1 -h | grep Flex
dumpe2fs 1.46.5 (30-Dec-2021)
Flex block group size:    16


есть так назвыаемые Flexible Block Groups
прблема в том что dummp2fs нихера ничего о них не показывает.



возвращаемся к группам блоков

Group 0: (Blocks 0-32767) csum 0x8d0b
  Primary superblock at 0, Group descriptor at 1
  Block bitmap at 2 (+2), csum 0xdd0693be
  Inode bitmap at 10 (+10), csum 0x224da69c
  Inode table at 18-527 (+18)
  28665 free blocks, 8149 free inodes, 2 directories, 8149 unused inodes
  Free blocks: 4103-32767
  Free inodes: 12-8160


вот приколная команда. покаызает в каком блоке и  в каком оффсете нахрлится
инода с таким то номером

> debugfs:  imap <2>
Inode 2 is part of block group 0
    located at block 18, offset 0x0100


а вот пикьная комана показать дамп блока фс
посмотрим дамп блока 1. в группе блоков "0" там находится "Group descriptor"

>debugfs:  block_dump 1
0000:  0200 0000 0a00 0000 1200 0000 f96f d51f
       0200 0000 1200 0000 2200 0000 f95f d51

якобы в первых трех 32 битных числах указаны блоки где лежат 
Data Block Bitmap, inode Bitmap and inode Table

0200 0000 , мы помним что надо пребобразовать из little endian, значит
00 00 00 02 = 2(dec) <== адрес блока фс с Data Block Bitmap

следущий клиент. 0a00 0000 преобраузуем из литтл ендиан 
00 00 00 0a = 10 (dec) <=== адрес блока фс с inode Bitmap

следущий лиент. 1200 0000 преобразуем из литтл ендиан.
00 00 00 12 = 18 (dec) <=== адрс блока фс с inode Table


сарниваем с вверху  с тем что нам прказал dumpe2fs
все совапало!
причем что важно полученные цифры 2,10,18 это не абсолютный адрес блока
а относиетльное смещение , относительно адреса первого блока в группе блоков.

важно сказать что если в группе блоков есть бэкап суперблока то это первый блок
в группе. а далее идет 1 блок Group Descrptor. Только эти два блока имеют фиксированное
положение в группе блоков. остальные блоки имеют плавающие адреса.

вот еще пример
имеем группу блоков

Group 3: (Blocks 98304-131071)
  Backup superblock at 98304, Group descriptors at 98305-98305
  Reserved GDT blocks at 98306-98432
  Block bitmap at 98433 (+129)
  Inode bitmap at 98434 (+130)
  Inode table at 98435-98944 (+131)
  32127 free blocks, 8160 free inodes, 0 directories
  Free blocks: 98945-131071
  Free inodes: 24481-32640


# debugfs /dev/sdc1
debugfs 1.46.5 (30-Dec-2021)
debugfs:  block_dump 98305
0000:  8100 0000 8200 0000 8300 0000 797d d51f

8100 0000 => (обртаное преобразование из little-endian)==>  81 00 00 00  = 129(dec)
значит Block bitmap имеет оффсет +129 
смотрим наверх все совпало

8200 0000 = 130(dec)значит Inode bitmap имеет офссет +130
смотри наверх совпало

8300 0000 = 131(dec) значит Inode table имеет офссет +131
смотрим наверх совпало

причем вот что интересно и важно про Block Group Descriptor:
1) он содержит в себе описание не только той группы в которой он содержится а всех групп.
2) адрес блока указывается в абсолютном значении. тоесть прям адерс блока а не относительное
смещение относительно блока начала группы 


важный вывод из этого - что если попорится один блок дескриптор то нужную информацию
всегда можно взять из любого друого групп дескриптора

еще я не очень понял то что они же должны быть идентичны. а они почемуто не идентичны.
это я щас покажу ниже.


для простоты я покажу на примере ext2 потому что у нее все проще.

структура Block Group Descripto для одной группы блоков

Offset (bytes)  Size (bytes)    Description
0               4               bg_block_bitmap
4               4               bg_inode_bitmap
8               4               bg_inode_table
12              2               bg_free_blocks_count
14              2               bg_free_inodes_count
16              2               bg_used_dirs_count
18              2               bg_pad
20              12              bg_reserved


как видно описание для одной группы блоков занимает 32 байта.

я беру dumpe2fs для ext2 раздела

Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-128
  Block bitmap at 129 (+129)
  Inode bitmap at 130 (+130)
  Inode table at 131-640 (+131)
  32111 free blocks, 8144 free inodes, 2 directories
  Free blocks: 647-1026, 1030, 1032-1036, 1039-1536, 1538-1541, 1545-32767
  Free inodes: 17-8160
Group 1: (Blocks 32768-65535)
  Backup superblock at 32768, Group descriptors at 32769-32769
  Reserved GDT blocks at 32770-32896
  Block bitmap at 32897 (+129)
  Inode bitmap at 32898 (+130)
  Inode table at 32899-33408 (+131)
  32127 free blocks, 8160 free inodes, 0 directories
  Free blocks: 33409-65535
  Free inodes: 8161-16320
Group 2: (Blocks 65536-98303)
  Block bitmap at 65536 (+0)
  Inode bitmap at 65537 (+1)
  Inode table at 65538-66047 (+2)
  32256 free blocks, 8160 free inodes, 0 directories
  Free blocks: 66048-98303
  Free inodes: 16321-24480
Group 3: (Blocks 98304-131071)
  Backup superblock at 98304, Group descriptors at 98305-98305
  Reserved GDT blocks at 98306-98432
  Block bitmap at 98433 (+129)
  Inode bitmap at 98434 (+130)
  Inode table at 98435-98944 (+131)
  32127 free blocks, 8160 free inodes, 0 directories
  Free blocks: 98945-131071
  Free inodes: 24481-32640


я буду проверять групп дескриптор на примере поля "Block bitmap"
поэому прогреплю то что выше

Group 0: (Blocks 0-32767)
  Block bitmap at 129 (+129)

Group 1: (Blocks 32768-65535)
  Block bitmap at 32897 (+129)

Group 2: (Blocks 65536-98303)
  Block bitmap at 65536 (+0)

Group 3: (Blocks 98304-131071)
  Block bitmap at 98433 (+129)



я беру дамп group descriptor из ФС блока 1

debugfs:  block_dump 1
0000:  8100 0000 8200 0000 8300 0000 6f7d d01f  ............o}..
0020:  0200 0400 0000 0000 0000 0000 0000 0000  ................

0040:  8180 0000 8280 0000 8380 0000 7f7d e01f  .............}..
0060:  0000 0400 0000 0000 0000 0000 0000 0000  ................

0100:  0000 0100 0100 0100 0200 0100 007e e01f  .............~..
0120:  0000 0400 0000 0000 0000 0000 0000 0000  ................

0140:  8180 0100 8280 0100 8380 0100 7f7d e01f  .............}..
0160:  0000 0400 0000 0000 0000 0000 0000 0000  ................

поскольку описание для одной группы блоков занимает 32 байта
то я отделил каждые 32 байта. чтобы четко было видно куски дампа
отвечающие за разные группы блоков


8100 0000 (преобразую из литтл ендиан) 00000081 = 129(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "0" равен 129 (dec)
смотрим вверх да совпало.


8180 0000 (преобразую из литтл ендиан) 00008081 = 32897(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "1" равен 32897 (dec)
смотрим вверх да совпало.


0000 0100 (преобразую из литтл ендиан) 00010000 = 65536(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "2" равен 65536 (dec)
смотрим вверх да совпало.




8180 0100 (преобразую из литтл ендиан) 00018081 = 98433(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "3" равен 98433 (dec)
смотрим вверх да совпало.

все абсолно совпало.



а теперь покаж странную вещь о том что  Block Descritor 
его дампы из разных копий они не совпадают


debugfs:  block_dump 1
0000  8100 0000 8200 0000 8300 0000 6f7d d01f  ............o}..
0020  0200 0400 0000 0000 0000 0000 0000 0000  ................

0040  8180 0000 8280 0000 8380 0000 7f7d e01f  .............}..
0060  0000 0400 0000 0000 0000 0000 0000 0000  ................

0100  0000 0100 0100 0100 0200 0100 007e e01f  .............~..
0120  0000 0400 0000 0000 0000 0000 0000 0000  ................




debugfs:  block_dump 32769
0000  8100 0000 8200 0000 8300 0000 797d d51f  ............y}..
0020  0200 0000 0000 0000 0000 0000 0000 0000  ................

0040  8180 0000 8280 0000 8380 0000 7f7d e01f  .............}..
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................

0100  0000 0100 0100 0100 0200 0100 007e e01f  .............~..
0120  0000 0000 0000 0000 0000 0000 0000 0000  ................



видно что в разых дампах для Block Group "0"
параметр "bg_free_blocks_count" отличается в одном
дампе он равен 6f7d а в другом он равен 797d
как же так? это же инфо про одну и туже групппу.
дампы же должны совпдаать. непонятно..

в любом случае адрес Block bitmap везде совпдаает.
так что будем считать что можно взять любой Block Descriptor
и получить адекватную инфомраацию об группах блоков любых.

далее 

Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-128
  Block bitmap at 129 (+129)
  Inode bitmap at 130 (+130)
  Inode table at 131-640 (+131)
  32111 free blocks, 8144 free inodes, 2 directories
  Free blocks: 647-1026, 1030, 1032-1036, 1039-1536, 1538-1541, 1545-32767
  Free inodes: 17-8160


что из этого можно сказать интетенсого - что вначале группы блоков идут блоки посвященные
ичключиетльно метаданным.  а только когда метаданные заканчиыватся только тогда и начинаются
дата блоки. тоесть дата блоки идут только после метаданных. также важно уточнить что 
блоки занятые под метаанные это тоже вобщемто дата блоки. по крайней мере в битмап файле
помечаются как занятые все блоки в группе неважно что они в сеебе несут метаданные
или уже живые пользователськие данные. все равно.

видно с блока 0 по блок 640 идут метаданные. а уже все остальное свбодно под 
юзерские данные. 

видно что част дата блоков занята. правда почемуто неравномерно.

Free blocks: 647-1026, 1030, 1032-1036, 1039-1536, 1538-1541, 1545-32767

возможно чтото было записано а потом стерто.


в случае ext2 что касатся таким метаданных как 
block bitmap
inode bitmap
inode table 
все очень просто - эти штуки есть в каждой группе блоков.

в ext4 ситуация уже намного сложнее
есть такая фича у ext4 назватется flex block group
причем эта фича по умолчаию активрвана в файле /etc/mke2fs.conf
поэтому при форматиовании она аткивируется автомтом. 

значит я ее щас отключу. и покажу как выглядит картинка для блок групп


# dumpe2fs /dev/sdb1 | grep -E "Group|Block bitmap|Inode bitmap"
dumpe2fs 1.46.5 (30-Dec-2021)
Group descriptor size:    64

Group 0: (Blocks 0-32767) csum 0x3835
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xa091049a
  Inode bitmap at 3 (+3), csum 0xdca3f573

Group 1: (Blocks 32768-65535) csum 0x6619 [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 32770 (+2), csum 0x00000000
  Inode bitmap at 32771 (+3), csum 0x00000000

Group 2: (Blocks 65536-98303) csum 0x5c5f [INODE_UNINIT, BLOCK_UNINIT]
  Block bitmap at 65536 (+0), csum 0x00000000
  Inode bitmap at 65537 (+1), csum 0x00000000

Group 3: (Blocks 98304-131071) csum 0x4d94 [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 98304, Group descriptors at 98305-98305
  Block bitmap at 98306 (+2), csum 0x00000000
  Inode bitmap at 98307 (+3), csum 0x00000000


значит пока что все выглядит также как в случае ext2.
битмапы имеют абсолютные значения. и каждый из них сидит   в прееделах 
своей группы блоков


теперь идем в /etc/mke2fs.conf
там обратно возвраащаем фичу flex_bg
и форматируем фс и выставляем флаг -G 

# mkfs.ext4 /dev/sdb1 -G 4

проверяем
# dumpe2fs /dev/sdb1 | grep -i flex
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum

# dumpe2fs /dev/sdb1 -h | grep Flex
dumpe2fs 1.46.5 (30-Dec-2021)
Flex block group size:    4

значит что такое флекс группы. это когда берется несколько групп блоков и они типа 
обьединяются в одну более большую группу.  я спецально акцентирую внимание на слове
типа обьединяются. как это выяглядит. что касается бэкапов суперблока и бэкапов
Block Group Descritor то тут все по старому - там где им пложено быть они все равно повятся.
эфффект для группы блоков проявялется в таких метаданных как 

block bitmap
inode bitmap
inode table 

они переносятся со всех групп блоков в головной блок. там для этого уширяются
соотсвтетующие куски метаданных

-G 4 = гвоорит сколько группп блоков таким макаром обьединять. 

итак да . часть метаданных переезжает  в головную группу блоков. вэтом плане как бы
есть обьединение. тоест мы как бы часть метаданных переносим в головную часть и у нас 
как бы обьединяется блок блоков где юзерские даные будут хостится. загвоздка только в том
что как уже сказал суперблок его копия и копиия Blocl Group Descriptor
все равно там где поожено оно появится в группах блоков. 
выхлоп от этой флекс группы типа такой то что для более больших файлов  меньше будет 
разрывность их тела и метаднные лежат более кучно.


смотрим результат
согласно моим выщесделаным настройкам у меня 4 группы блоков типа должно слится в одну

Group 0: (Blocks 0-32767) csum 0x8f22
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0x628d98e6
  Inode bitmap at 6 (+6), csum 0x89d426df
  Inode table at 10-519 (+10)

Group 1: (Blocks 32768-65535) csum 0x76aa [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 3 (bg #0 + 3), csum 0x00000000
  Inode bitmap at 7 (bg #0 + 7), csum 0x00000000
  Inode table at 520-1029 (bg #0 + 520)

Group 2: (Blocks 65536-98303) csum 0x2085 [INODE_UNINIT, BLOCK_UNINIT]
  Block bitmap at 4 (bg #0 + 4), csum 0x00000000
  Inode bitmap at 8 (bg #0 + 8), csum 0x00000000
  Inode table at 1030-1539 (bg #0 + 1030)

Group 3: (Blocks 98304-131071) csum 0x06a4 [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 98304, Group descriptors at 98305-98305
  Block bitmap at 5 (bg #0 + 5), csum 0x00000000
  Inode bitmap at 9 (bg #0 + 9), csum 0x00000000
  Inode table at 1540-2049 (bg #0 + 1540)


что можно заметить. только в группе блоков "0"  у нас Block bitmap, inode bitmap,
Inode table имеют абсолютное значение адреса фс блока где их искать

  Block bitmap at 2
  Inode bitmap at 6
  Inode table at 10-519 

для остальых члоенов этой флекс группы видим вот такое

  Block bitmap at 3 (bg #0 + 3)
  Inode bitmap at 7 (bg #0 + 7)
  Inode table at 520-1029 (bg #0 + 520)


вот эта хрень (bg #0 + 3) означает что адрес указан не абсолютный а относииельный.
относиетльно насколько я понимаю адреса первого блока в группе блоков "0"

выхлоп от этой хрени тлко такой что еси у нас файлы больше 128МБ то их тело будет иметь
меньше разрывов.  эти ухищрения делают потому что мы неможем увелчить размер блока фс 4КБ потомучто он завязан на размер page size в mmu цпу. вот и извращаются


посмтрим что следущий флекс группа блоков имеет такую же схему

Group 4: (Blocks 131072-163839) csum 0x3f9c [INODE_UNINIT]
  Block bitmap at 131072 (+0), csum 0xafb9b452
  Inode bitmap at 131076 (+4), csum 0x00000000
  Inode table at 131080-131589 (+8)
Group 5: (Blocks 163840-196607) csum 0xe73d [INODE_UNINIT]
  Backup superblock at 163840, Group descriptors at 163841-163841
  Block bitmap at 131073 (bg #4 + 1), csum 0x9b7b32e8
  Inode bitmap at 131077 (bg #4 + 5), csum 0x00000000
  Inode table at 131590-132099 (bg #4 + 518)


головная группа "4" имеет абсолюьные значения блоков для битмапов.
а дочерняя группа "5" уже сслыается на головную группу "4" (bg #4 + 1)

прикольно. с этимиф флекс группами.

 сточки зрения выживучести данные конечно это хуже. лучше чтобы метаданные были более 
 распылены по диску. если файл большой то ка бы похеру невлиает  флекс схема
 на выжиывучесть. а еси файлы маленкие то выжиывучест становистя хуже

 как они сами пишут нахер это надо:
 This improves meta-data
              locality and performance on meta-data heavy workloads.



получается по дефолту по краенй мере в ext2 или в ext4 с выключенными флекс группами
у нас метаданные от файла хранятся рядышком с телом файла. во первых это дает больше выживучести файлам. потому что есди  унас метеданные лежат в куче скжем вначае диска то 
повреждение начал диска убивает нам все файлы на всем диске. а если у нас метданные рсплыены
по всему диску то уничтожение куска дикска вначале убивает тлоько файлы внчалае диска.
плюс когда метданные лежат рядом с данными то и перфоманс в плюсе.

коенчно когда  унас вклюен журнал и он лежит на том же диске то пуолается что надо 
метаданные (а порой и сами данные) внале заптсать в журнал а потом второй раз на диск.
причем в дургое место.  ssd дискам это похер. а шпиндельным это уже грустно. потому что 
жунал лежит в одной части диска а реальные данные овсем в другой части. надо дергаться.


выше я расмаотрел фичу flex groups котораф по дефолут активрована при форматировании. 
по дефолту число групп блоков входящих в флекс гурппу равно 4. 
это позволяет перетащить 
block bitmap
inode bimap
inode table
в головную группу блоков. таким образом собрав часть метаданныех в кучу  с нескольких
групп блоков.это дает кучность метаданных (ненадо шариться по всему диску из за них)
и то что длиныые файлы будут иметь меньше разрывов на диске. для ссд мне кажется это похеру
а для шпиндельных наверно имеет смысл. 

так вот мжно пойти еще дальше - можно собрать все метаданные со всех групп блоков  в 
начало диска. один вариант это создать мегаогромную флекс группу. тоесть она 
обьединит кучу групп блоков в типа один.

# mkfs.ext3 /dev/sdv1 -G 100000000

  
есть еще вариант это заюзать опцию 

  packed_meta_blocks[= <0 to disable, 1 to enable>]
                          Place the allocation bitmaps and the inode table at the beginning of the disk.  This option requires that the flex_bg file system  feature  to  be  enabled  in
                          order  for it to have effect, and will also create the journal at the beginning of the file system.  This option is useful for flash devices that use SLC flash
                          at the beginning of the disk.  It also maximizes the range of contiguous data blocks, which can be useful for certain specialized use cases, such as  supported
                          Shingled Drives.


# mkfs.ext4   ./10T.txt  -E packed_meta_blocks

@@@@@@@@@@@@@@@@@@

далее я делаю исседование на тему - в каких блоках хранится журнал.
а также в чем разница межде

flex группы vs packed_meta_blocks

в чем разница между использованием просто флекс групп
и использованием опции -E packed_meta_blocks

сразу скажу вывод исследования:  флекс группы перетаскивают в голову 
такие метаданные как (block bitmap, inode bitmap, inode table) с других блок групп
но при этом журнал он нетрогается. в ext3 журнал хранится в голове диска
а в ext4 он хранится в серединедиска.
опция -E packed_meta_blocks по сравнениб с фоекс группами дает то что она еще
претаскивает журнал в голову диска. если спросить а что хранится ближе к голове диска
битмап метаданные или журнал? ответ - журнал переносится самым последним. он в самом сзади
по сравнени с друними металанными.
также из мелочей если юзаем опцию -E packed_meta_blocks то у нас создается одна флекс группа
которая вокчает в себя все блоки групп а количество флекс групп которое можно посмотреть 
в супер блоке через dumpe2fs там будет написано вранье. то число которое там указано 
оно не бдует озанчать ничего. по факту еще раз скажу все блок группы будут включены в состав
одной единой и единстенной флекс гурппы.

поехали


инода журнала 8.
но блоки журнала лежат в жопе диска.
а еще в dumpe2fs покывазются не блоки на диске а офссет
и еще походу журнал пишется с конца и стремится к началу.


# dumpe2fs -h ./5G-ext3.txt  | grep -i journal
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype sparse_super large_file
Journal inode:            8
Journal backup:           inode blocks
Journal features:         (none)
Total journal size:       64M
Total journal blocks:     16384
Journal sequence:         0x00000001
Journal start:            0
root@vm1:/mnt# 



ext3 + journal (раздел 5G) \ параметры форматрования дефолтовые

Inode: 8   Type: regular    Mode:  0600   Flags: 0x0
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131208
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
 atime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
 mtime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
crtime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
Size of extra inode fields: 32
BLOCKS:
(0-11):518-529, (IND):530, (12-1035):531-1554, (DIND):1555, (IND):1556, (1036-2059):1557-2580, (IND):2581, (2060-3083):2582-3605, (IND):3606, (3084-4107):3607-4630, (IND):4631, (4108-5131):4632-5655, (IND):5656, (5132-6155):5657-6680, (IND):6681, (6156-7179):6682-7705, (IND):7706, (7180-8203):7707-8730, (IND):8731, (8204-9227):8732-9755, (IND):9756, (9228-10251):9757-10780, (IND):10781, (10252-11275):10782-11805, (IND):11806, (11276-12299):11807-12830, (IND):12831, (12300-13323):12832-13855, (IND):13856, (13324-14347):13857-14880, (IND):14881, (14348-15371):14882-15905, (IND):15906, (15372-16383):15907-16918
TOTAL: 16401

кстати в debugfs вот этот параметр 
Blockcount: 131208
эта такаяже хуйня как и в команде stat из баша. 
это типа вот этот виртуалные ебанутый блок равный всегда 512. тоесть это не блок Фс.
это пиздец. тоесть его в приоде нет этого блока . просто его уножае на 512 и получаем
сколько байт на диске по факту занимает файл.  в данном случае файл журнала
офигенно misleading штучка. суки. 

поэтому полное совдпание из dumpe2fs мыимеем что журнал 64M

из debugfs мы имеем 
Size: 67108864    
это виртальный размер файла (такакже как утилите stat из баш) который
к реальному размеру файла на стораже отношения не имеет
а вот это
Blockcount: 131208
это уже реальный размер на диске тольо его надо уножить на 512. получаем
67178496 вобщем теже самые 64МБ.


но нас интерсуе другое - в каких блоках ФС хранится тело файла журнала

здесь что важно увидеть. вот то что в скобках 
(0-11):518-529
это офссет внутри файла тоесть
мы из dumpe2fs уже знаем что 
Total journal blocks:     16384
аткже мы это можем и высчиать из debugfs. вычисляем сколько байт на диске физически
занимает файл (Blockcount: 131208 ) * 512 / 4K(размер фс блока) = 16401 блоков.

короче 16384 блока ФС занимает файл журнал. это значит что его офссет меняется от 0 до 16383.
так вот в этой записи (0-11):518-529
(0-11) это офссет внутри файла. тесть его номера его байтов если бы мы их читали из 
клиента ос задавая параметр seek\skip тоесть это то как файл выглядит изнутри. он же незнает
что его тело на диске по частям записано. изнутри файла он монолитный. короче то что в скбоках
это оффсет. а то что дальше это адрес блока на ФС где хранится этот офсссет!
ext3 не поддерживает эксетенты. поэтому это прям блоки ФС их адерса.

ты спросишь как это проверить? а в дебагфс есть супер команда.
задаемшь ей офссет и она пишет адрес блока 

debugfs:  bmap <8> 12
531

смотрим наверх
(12-1035):531-1554
дейтвительно офссет 12 имеет адрес фс блока 531


тогда получается что у нас файл журнала на ext3 хранится в блока ФС  518-16918
причем непрерывно.
эти блоки принадлжеат Block Group "0"
мы полчили исчерапывающую информацию.
получется ext3 хранит файл журала единым куском в своем головном нулевом блоке групп.

все прсто и понятно. мы ответили на вопрос - а где же на фс ext3 лежит хранится
файл журнала.







ext4 раздел 5G опцииф формтания деолфтовые

# file ./5G.txt
./5G.txt: Linux rev 1.0 ext4 filesystem data, UUID=7de15353-748d-44fe-88e3-225c5b3a9b78 (extents) (64bit) (large files) (huge files)


# dumpe2fs -h  ./5G.txt  | grep -i journal
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Journal inode:            8
Journal backup:           inode blocks
Journal features:         (none)
Total journal size:       64M
Total journal blocks:     16384
Journal sequence:         0x00000001
Journal start:            0


видим что размер файла журнала 64МБ
за негоотвечает инода 8
занимает 16384 фс блока

# debugfs
> stat <8>
Inode: 8   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131072
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
 atime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
 mtime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
crtime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
Size of extra inode fields: 32
Inode checksum: 0x3ba509ea
EXTENTS:
(0-16383):557056-573439

опятд же 
(0-16383):557056-573439

то что в скоблках это офссет файла. от 0 до 16383 . тоесть 16383 блока ФС он занимает.
однако то что после двоеточия это уже не адреса фс блоков это уже экстенты указаны.


>debugfs:  bmap <8> 0
557056


вводим еще одну интерсуную команду
>debugfs:  dump_extents <8>
Level Entries       Logical          Physical Length Flags
 0/ 0   1/  1     0 - 16383  557056 -  573439  16384 

кхм.. получется что эти экстенты они в данном случае равны блокам ФС.
получаетс что файл журнала лежит в блоках

557056 -  573439

выясним какой это блок группа. предварительно это 17 блока группа

всего у меня блок групп 0-39 тоесть 40 штук.

17-я блок группа выглядит вот так

Group 17: (Blocks 557056-589823) csum 0x4682 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 524289 (bg #16 + 1), csum 0xbdfbed1a
  Inode bitmap at 524305 (bg #16 + 17), csum 0x00000000
  Inode table at 524832-525343 (bg #16 + 544)
  16384 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 573440-589823
  Free inodes: 139265-147456

отсюда мы видим что блок битмап, инода битмап, инода тейбл они все на самом деле
нележат в этой блок группе они все лежат в группе #16. потому что по  дфеолту на ext4
при фортватировании активируются флек группы с парамертром 4. тесть в одной флекс группе
4 блок группы. поэтому эта блок группа она полность пустая от метаанных. поэтому в ней
с превого блока можно заимаеть блоки под даные. вот фс и заняла блоки 557056 -  573439
под файл журнала. кстати видно что первый своодный блок это 573440
    Free blocks: 573440-589823
тость ровно следущий после последнего блока журанала 573439
видно что журна лежит одним куском на диске по середине. я думаб логика тут такая
что так как запись метаанных идет два раза  - вначале в журнал а потом уже на диск там где реально будут лежать метаданные  то логично что по теории статистики если мы поместим  журнал
посередине он будет равноудален от всех точек диска. если это шпиндельный диск то 
головке диска придется дергаться мегьше всего. чем если бы журнал лежал ндето в другом
месте диска. удивительно!!!!






ext4, тот же раздел 5G (отфратмтирован с опцией -E packed_meta_blocks)
# dd if=/dev/zero of=./5G-ext4-2.txt bs=1M count=0 seek=5120
# mkfs.ext4 ./5G-ext4-2.txt -E packed_meta_blocks

> stat <8>
Inode: 8   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131072
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 atime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 mtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
crtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
Size of extra inode fields: 32
Inode checksum: 0x08a0aed8
EXTENTS:
(0-12200):20567-32767, (12201-16383):32770-36952
(END)

> dump_extents <8>
Level Entries       Logical          Physical Length Flags
 0/ 0   1/  2     0 - 12200   20567 -   32767  12201 
 0/ 0   2/  2 12201 - 16383   32770 -   36952   4183 

 видим что файл журнала разбит на две части но они лежат совсем рядом.
 вот эти блоки 20567 - 32767 лежат в группе блоков "0"
 вот эти блоки 32770 - 36952 лежат в группе блоков "1"

 ага.!! итак да! мы видим вот что . если мы заюзаем фичу flexible групп
 то у нас метаданные (block bitmap, inode bitmap  . inode _table) переползают
 из блок групп в головную блок группу. есди мы заддим очень большое число -G при форматиорвании
 то у нас все метаданные со всех блок групп переползут в головной блок групп. но!
 это ниак не повлияет на то куда будет засунут журнал. мы это увидели в прошлом примере.
 там актироыван флекс группы а журнал лежит по середине диска.

 а вот опция -E packed_meta_blocks она нетлоко метаданные (block bitmap, inode bitmap  . inode _table) перетаскивает в голову диска но и перетаскивает журнал файл тоже в голову диска.
причем что еще интересно. что число групп указанное в настойке flex group 
оно игнриуеся при создании фс

показываю 

# dumpe2fs  ./5G-ext4-2.txt  -h | grep -i flex
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Flex block group size:    16

тоесть ичсло групп в флекс группе 16. это значит что 0-15 группы сидят в одной флекс гурппе
а группы 16-31 должны сиеть в дрйгоу флекс группе. однако


# dumpe2fs  ./5G-ext4-2.txt  | grep -E "^Group |Block bitmap at"
dumpe2fs 1.46.5 (30-Dec-2021)
Group descriptor size:    64
Group 0: (Blocks 0-32767) csum 0x6e73 [ITABLE_ZEROED]
  Block bitmap at 2 (+2), csum 0xef300295
Group 1: (Blocks 32768-65535) csum 0x0ae9 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6
Group 2: (Blocks 65536-98303) csum 0xa502 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 4 (bg #0 + 4), csum 0x00000000
Group 3: (Blocks 98304-131071) csum 0x4e22 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 5 (bg #0 + 5), csum 0x00000000
Group 4: (Blocks 131072-163839) csum 0x578f [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 6 (bg #0 + 6), csum 0x00000000
Group 5: (Blocks 163840-196607) csum 0xbcaf [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 7 (bg #0 + 7), csum 0x00000000
Group 6: (Blocks 196608-229375) csum 0x6fe3 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 8 (bg #0 + 8), csum 0x00000000
Group 7: (Blocks 229376-262143) csum 0x84c3 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 9 (bg #0 + 9), csum 0x00000000
Group 8: (Blocks 262144-294911) csum 0x9bcb [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 10 (bg #0 + 10), csum 0x00000000
Group 9: (Blocks 294912-327679) csum 0x70eb [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 11 (bg #0 + 11), csum 0x00000000
Group 10: (Blocks 327680-360447) csum 0xfc08 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 12 (bg #0 + 12), csum 0x00000000
Group 11: (Blocks 360448-393215) csum 0xe223 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 13 (bg #0 + 13), csum 0x00000000
Group 12: (Blocks 393216-425983) csum 0x0e85 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 14 (bg #0 + 14), csum 0x00000000
Group 13: (Blocks 425984-458751) csum 0x10ae [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 15 (bg #0 + 15), csum 0x00000000
Group 14: (Blocks 458752-491519) csum 0x8379 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 16 (bg #0 + 16), csum 0x00000000
Group 15: (Blocks 491520-524287) csum 0x9d52 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 17 (bg #0 + 17), csum 0x00000000
Group 16: (Blocks 524288-557055) csum 0x7a1b [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 18 (bg #0 + 18), csum 0x00000000
Group 17: (Blocks 557056-589823) csum 0x6430 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 19 (bg #0 + 19), csum 0x00000000
Group 18: (Blocks 589824-622591) csum 0x1dd8 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 20 (bg #0 + 20), csum 0x00000000
Group 19: (Blocks 622592-655359) csum 0x03f3 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 21 (bg #0 + 21), csum 0x00000000
Group 20: (Blocks 655360-688127) csum 0xef55 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 22 (bg #0 + 22), csum 0x00000000
Group 21: (Blocks 688128-720895) csum 0xf17e [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 23 (bg #0 + 23), csum 0x00000000
Group 22: (Blocks 720896-753663) csum 0xbe9a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 24 (bg #0 + 24), csum 0x00000000
Group 23: (Blocks 753664-786431) csum 0xa0b1 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 25 (bg #0 + 25), csum 0x00000000
Group 24: (Blocks 786432-819199) csum 0x4ab2 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 26 (bg #0 + 26), csum 0x00000000
Group 25: (Blocks 819200-851967) csum 0xa192 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 27 (bg #0 + 27), csum 0x00000000
Group 26: (Blocks 851968-884735) csum 0x2d71 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 28 (bg #0 + 28), csum 0x00000000
Group 27: (Blocks 884736-917503) csum 0xc651 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 29 (bg #0 + 29), csum 0x00000000
Group 28: (Blocks 917504-950271) csum 0xdffc [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 30 (bg #0 + 30), csum 0x00000000
Group 29: (Blocks 950272-983039) csum 0xc1d7 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 31 (bg #0 + 31), csum 0x00000000
Group 30: (Blocks 983040-1015807) csum 0x33ee [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 32 (bg #0 + 32), csum 0x00000000
Group 31: (Blocks 1015808-1048575) csum 0x2dc5 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 33 (bg #0 + 33), csum 0x00000000
Group 32: (Blocks 1048576-1081343) csum 0xa6e9 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 34 (bg #0 + 34), csum 0x00000000
Group 33: (Blocks 1081344-1114111) csum 0xb8c2 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 35 (bg #0 + 35), csum 0x00000000
Group 34: (Blocks 1114112-1146879) csum 0xc12a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 36 (bg #0 + 36), csum 0x00000000
Group 35: (Blocks 1146880-1179647) csum 0xdf01 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 37 (bg #0 + 37), csum 0x00000000
Group 36: (Blocks 1179648-1212415) csum 0x33a7 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 38 (bg #0 + 38), csum 0x00000000
Group 37: (Blocks 1212416-1245183) csum 0x2d8c [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 39 (bg #0 + 39), csum 0x00000000
Group 38: (Blocks 1245184-1277951) csum 0x0bcb [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 40 (bg #0 + 40), csum 0x00000000
Group 39: (Blocks 1277952-1310719) csum 0xc876 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 41 (bg #0 + 41), csum 0x5208bd0f


видно что во всех блок группах для block bitmap идет воттакая запист

(bg #0 + 9)

которая говорит о том что метаданные хранятся в нулевой блок группе для всех блок груп!!
а как яуже сказал если у нас задано что во флекс группу входит 16 блок групп
то начиная с 17-ой блок группы метданные должны хранится в 16-ой блок группе.

поэтому я и говрю что при форматиорвании с опцией -E packed_meta_blocks
у нас параметр колько групп входит во флекс групу игнориуется. и все блок группы
входят в первую флекс группу.


так вот еще один прикол если мы возмьем большой диск , отфоформатируем
его с параметром -E packed_meta_blocks то фс нужно метаданные со всемх блок групп
записать в первой блок группе. но у нас же число блоков 
в каждой группе так и останеся 32768 , а метаданных будет сктолько много
что они не влезут не только в группу блоков "0" но и еще и дальнейшие группы тоже.
тоесть я хочу сказать что метаданные котоыре будут собраны со всего диска 
они будут занимать огромную кучу первых групп блоков. щас покажу на примере.

делаем диск размером 10TB чеерз спарс файлы

# dd if=/dev/zero of=./10T.txt bs=1G count=0  seek=10000
# mkfs.ext4 ./10T.txt -E packed_meta_blocks

# dumpe2fs  ./10T.txt |   grep -E "^Group |Block bitmap at|Free blocks" | less
Group 0: (Blocks 0-32767) csum 0xbe8e [ITABLE_ZEROED]
  Block bitmap at 1251 (+1251), csum 0x62a284df
  Free blocks: 
Group 1: (Blocks 32768-65535) csum 0x8b16 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1252 (bg #0 + 1252), csum 0x62a284df
  Free blocks: 
Group 2: (Blocks 65536-98303) csum 0x4877 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1253 (bg #0 + 1253), csum 0x62a284df
  Free blocks: 
Group 3: (Blocks 98304-131071) csum 0x7acd [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1254 (bg #0 + 1254), csum 0x62a284df
  Free blocks: 
Group 4: (Blocks 131072-163839) csum 0xcbb3 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1255 (bg #0 + 1255), csum 0x62a284df
  Free blocks: 
...

видно что фри блоков просто нет. все забито метаданными
и так будет очень долго до 637 группы блоков

...

Group 637: (Blocks 20873216-20905983) csum 0x3d42 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1888 (bg #0 + 1888), csum 0x62a284df
  Free blocks: 
Group 638: (Blocks 20905984-20938751) csum 0x40eb [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1889 (bg #0 + 1889), csum 0xa38fbe72
  Free blocks: 20919664-20938751

тогда толко появяттся свободные блоки.
группы блоков с 0 по 637 это 638 групп по 32768 блоков это ~ 80GB метаданных породил
раздел на 10T

причем например все блок битмапы будут смотреть в групу блоков "0".
а например инод битмапы будут все смотреть на группу блоков "2"

Group 1: (Blocks 32768-65535) csum 0x8b16 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1252 (bg #0 + 1252), csum 0x62a284df
  Inode bitmap at 82503 (bg #2 + 16967), csum 0x00000000

посмотрим где  лежит файл журнала

> dump_extents <8>
Level Entries         Logical                Physical Length Flags
 0/ 1   1/  1      0 - 262143    1605603              262144
 1/ 1   1/ 19      0 -     81     163758 -     163839     82 
 1/ 1   2/ 19     82 -    110     229347 -     229375     29 
 1/ 1   3/ 19    111 -    139     294883 -     294911     29 
 1/ 1   4/ 19    140 -    168     819171 -     819199     29 
 1/ 1   5/ 19    169 -    197     884707 -     884735     29 
 1/ 1   6/ 19    198 -    225    1605604 -    1605631     28 
 1/ 1   7/ 19    226 -    254    2654179 -    2654207     29 
 1/ 1   8/ 19    255 -    283    4095971 -    4095999     29 
 1/ 1   9/ 19    284 -    312    7962595 -    7962623     29 
 1/ 1  10/ 19    313 -    341   11239395 -   11239423     29 
 1/ 1  11/ 19    342 -    370   20479971 -   20479999     29 
 1/ 1  12/ 19    371 -  33138   20657891 -   20690658  32768 
 1/ 1  13/ 19  33139 -  65906   20690659 -   20723426  32768 
 1/ 1  14/ 19  65907 -  98674   20723427 -   20756194  32768 
 1/ 1  15/ 19  98675 - 131442   20756195 -   20788962  32768 
 1/ 1  16/ 19 131443 - 164210   20788963 -   20821730  32768 
 1/ 1  17/ 19 164211 - 196978   20821731 -   20854498  32768 
 1/ 1  18/ 19 196979 - 229746   20854499 -   20887266  32768 
 1/ 1  19/ 19 229747 - 262143   20887267 -   20919663  32397 

насколько можно судить журнал размазан но основаня часть лежит
в группах блоков 631-638

моя идея такая - кога мы юзаем опцию -E packed_meta_blocks
то вначале в голову перетаскиваются block битмапы, заними инод битмаапы,
за ними инод тейблы. а уже самым последним идет файл журнала.
поэтому он как бы в голове диска но не в самой голове. 
он в самом хвосте из тех метаанных котоые перетаскиватся в голову диска

ксатии эта мысль подтверждается на примере когда унас был раздел всего 5G
когда у нас все метаданные с диска умещались в одну блок группу нулевую

напоминаю
ext4, тот же раздел 5G (отфратмтирован с опцией -E packed_meta_blocks)
# dd if=/dev/zero of=./5G-ext4-2.txt bs=1M count=0 seek=5120
# mkfs.ext4 ./5G-ext4-2.txt -E packed_meta_blocks

> stat <8>
Inode: 8   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131072
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 atime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 mtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
crtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
Size of extra inode fields: 32
Inode checksum: 0x08a0aed8
EXTENTS:
(0-12200):20567-32767, (12201-16383):32770-36952
(END)

видно что в нулевой  блок группе  файл журнала лежит в самом хвосте нулевой блок группы
 20567-32767  и даже он в первую блок группу залезает  32770-36952

это еще раз подтверждает ту мысль что  при исползовании опции -E packed_meta_blocks
вначале перетаскиваются в голову диска другие метаданые а  файл журнала перетасиквается
последним. и он как бы да - он уже не в цетре диска. но по сравненеи с друними метааданными
он в самом хвосте.

кстати неудвилттельно что файл журнала идет в самом хвосте. потому что 
журнал это всего навсего файл. хоть у него и нет хардинка то есть его нет ни в одном
каталоге. но это всего лишь файл.  а файлы их тела конечно же в блок группах 
сидят только после группы блоков отвечающих за метаданные.
потому что кажая группа блоков по крайней мере классическая
группа блоков она же имеет известный вид:
-суперблок или его копия или его нет
- group descriptor или его копия или его нет
- data block bitmap или его нет (если он хранится в другой блок группе)
- inode bitmap или его нет (если он хранится в другой блок группе)
- inode table или его нет (если он хранится в другой блок группе)
- дата блоки

правда неочень понятно а где хрантяс метаданные флекс группы.
тем не менее. соласно этой схеме файл журнала его тело может хранится только в дата блоках
а дата блоки они всегда находятся в жопе по отношению к метаанным. пэтмоу журнал его тело
всегда лежит позади блока метаданных в группе блоков.
также понятно что видно из схемы что после груп дескриптра идет data block bitmap 
и если у нас флекс группа то туда будут зансены все датаблоки всех битматов всех групп
входящтих  в флекс группу и поэтому если таких блоков много то дата блоки группы могут 
законитться и инод битмапы будут идти уже тлько после того как собраны все дата блок битмапы.
также мне кажется что метаданные флекс гурппы они вобщемто нетребуются потомучто 
метаданные (битмапы и инод тейблы) их место сохранения неимеет никакого значения потому
что в них хранятся абсолютные занчегия адресов блоков. поэтому будут ли метаданные
лежат в одном месте или разбросаны по всему диску без разницы. надо лишь 
поправить занчения в GDT (group descritpor table) типа того.




конец исселедования
@@@@@@@@@@@@@@


посмотрим еще один прикол


изготовим спарс файл 2Т
# dd if=/dev/zero of=./2T.txt bs=1G count=0 seek=2048

форматироуем файл с параметром 16 групп в флекс группе
# mkfs.ext4 ./2T.txt -G 16

проверяем что в группе флекс нахрится 16 групп 
# dumpe2fs ./2T.txt -h | grep -i flex
Flex block group size:    16

смотрим что там с инодами
# dumpe2fs ./2T.txt  -h | grep -i inode
dumpe2fs 1.46.5 (30-Dec-2021)
Inode count:              134217728
Free inodes:              134217717
Inodes per group:         8192
Inode blocks per group:   512
First inode:              11
Inode size:           256
Journal inode:            8
Journal backup:           inode blocks

видим что в одной блок группе у нас занимается 512 блоков ФС 

также мы юзаем флекс группы. это значит что метаданные с других групп будут
пееремещены в головную группу. так вот посмотрим какая инфо об этом будет в описании
головной группы об этом. тоест будет ли там инфо о битмапах со всех групп
или только о битмапах этой группы. 

#  dumpe2fs ./2T.txt  | less

Group 0: (Blocks 0-32767) csum 0x7440 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-256
  Block bitmap at 257 (+257), csum 0x55eb7455
  Inode bitmap at 273 (+273), csum 0x75ad3ccb
  Inode table at 289-800 (+289)
  24282 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes
  Free blocks: 8486-32767
  Free inodes: 12-8192

пощитаем сколько у нас в 2ТБ содержится групп блоков
(2*1024*1024*1024)/4 = 536870912 блоков.
значит групп блоков 536870912:32768=16384 группы блоков

что мы видим из дампа?
0 блок = суперблок
1-256 блок  = это груп дескриптор. груп дескриптор это структура которая содержит
в себе описание всех групп блоков а не толлько 16-ти групп блоков которые мы указали
как параметр флекс группы. тоестьгурпп дескриптор содержит описаниа всех 16384  групп
блоков. согласно описанию ext4  в таблице GDT запись для одной группы блоков по длине
равно 64 байта (при условии что фс создана с фичей 64bit  а так обычно и есть. фича 64бит дает то что макс колво блоков на фс опредяется число 64бит длинной. проверяется наличие этой фичи через dumpe2fs строчка features). кстати то что одна запись для группы блоков в таблице
GDT заниает 64 байта можно увидеть тжое через dumpe2fs

# dumpe2fs ./2T.txt -h | grep -i  descriptor
dumpe2fs 1.46.5 (30-Dec-2021)
Group descriptor size:    64

так вот если унас 16384 группы блоков и на одну группу у нас надо 64 байта в таблице GDT
этозначит что суммарно таблицаа GDT будет заниать (16384 * 64) / 1024 /4 =  256 блоков
что собственно мы и видим из дампа. 
    Group descriptors at 1-256
далее двигаем
    Block bitmap at 257 (+257), csum 0x55eb7455
блок битмап нахордится по адресу 257 и для одной группы блоков занимает 1 блок
далее мы видим что 
    Inode bitmap at 273
инода битмап начинается с блока 273
и вот тут я вижу подставу которую и хотел обозначить.
возникает вопрос а что находится в блоках между 257 где 
лежит битмап от этой группы блоков до блока 273 где лежит
битмап инодов от этой группы блоков.
чтоэто за провал? а ответ такой что там лежат битмапы еще от 15-ти групп блоков
действиетлно в 257 лежит датаблок битмап от этой группы блоков. плюс 15 блоков котоыре
отвечают за дата блок битмапы еще 15-ти групп блоков это будет блок 272.
и следущий блок 273 это уже битмап инодов от этой группы блоков.

почему в этой группе блоков хранится еще 15 битмапов от других групп блоков? потому
что мы юзаем фичу флес группы. мы указали при формтировании -G 16 это значит
что  датаблок битмапы , инода битмапы, инода тейблы от 16 групп будут собраны 
в головной группе. а в дочернмх группах этого ничего не будет(там тлоько будут дата блоки
и копии суперблока и копии GDT). поэтому у нас туту битмапы от чужих групп блоков.
поэтому битмап инодов начинается не в 258 а в 273.
разобрались.
так вот  я считаю что это свинство что dumpe2fs это не выводит на экране. об этом надо 
догадываться. тоесть он выводит на экране что якбоы в этой группе блоков у нас только 
один битмап даат блоков
  Block bitmap at 257 (+257), csum 0x55eb7455
  Inode bitmap at 273 (+273), csum 0x75ad3ccb
и только приглядывась  к тому что инода битмап начинается с какогто стрмногоадреса
мы врдуг узнаем что в этой группе блоков есть еще битмапы. я считаю что это свиноство
со стороны dumpe2fs. об этом я и хотел сказать.

сотственнно смотрим дальше
  Inode bitmap at 273 (+273), csum 0x75ad3ccb
  Inode table at 289-800 (+289)
мы понимаем что инода битмап в 273 это инода битмап от этой группы блоков.
но между 273 и 289 сидят еще 15 инода битмапов от друних групп блоков
в блоках 289-800 у нас сидит инода тейбл от этой группы блоков. подчеркиваю именно 
от этой группы блоков. хотя опять ж вопрос что значит от этой группы блоков? ничто немешает
этим инодам иметь в себе ссылки на датаблоки из других групп блоков. на самом деле.
как уже мы видели выше в дамп2фс указано сколько блоков занимает инод тейбл в для каждой
группы блоков (512 блоков)

    # dumpe2fs ./2T.txt -h | grep -i  "Inode blocks per group"
    dumpe2fs 1.46.5 (30-Dec-2021)
    Inode blocks per group:   512

проверяем 800-289+1=512 блоков
кстати размер иноды 256 байт у нас

    # dumpe2fs ./2T.txt -h | grep -i  "Inode size"
    dumpe2fs 1.46.5 (30-Dec-2021)
    Inode size:           256

значит в одной группе блоков у нас 512×4096÷256 = 8192 иноды
таки есть

    # dumpe2fs ./2T.txt -h | grep -i  "Inodes per"
    dumpe2fs 1.46.5 (30-Dec-2021)
    Inodes per group:         8192

так я это к чему что у нас же после таблицы индов нашей группы блоков дальше идут
таблицы инодов оставщихся 15-ти групп блоков каждяа из которых по 512 блоков итого

    512*15=7680 блоков


значит сморим в дамп
 Inode table at 289-800 (+289)
  24282 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes
  Free blocks: 8486-32767
  Free inodes: 12-8192

значии инода таблица  у нас не заканчивыатеся на 800-ом блоке а
идет до блока 
    800+7680=8480 
значит первый свободный блок у на 8481
однако мы видим что первый свободный блок это 8486
значит мы ошиблись в расчетах ? нет.
просто эти дата блоки действиельно уже заняты чем то полезным.
щас мы узнаем чем

команда icheck позволяет узнать к каой иноде относится такой то фс блок.
это очень круто!

debugfs:  icheck 8481
Block   Inode number
8481    2

получатется что блок 8481 отноистя к телу иноды 2. а инода 2 это всегда иноду "/" коневого
каталога ! вот и разгадка!

проверим остальные блоки.

debugfs:  icheck 8482
Block   Inode number
8482    11

11 инода это обычно каталог "lost+found"
это спец каталог в который fsck создает хадлиники для тех инод котоыре есть на 
фс но на них нет никаких хардлинков ни в какой каталог. приколно.
если удаить этот катлог. то его как пишут (поему?) нелтзя созвать руками. видимо
потомучто будет не та инода отвечать за этот каталог. а надо пересоздавать с помщью 
утилиты  mklost+found
    mklost+found  is  used  to create a lost+found directory in the current working directory on a Linux second extended file system.  There is normally a lost+found directory in the
    root directory of each filesystem.
    mklost+found pre-allocates disk blocks to the lost+found directory so that when e2fsck(8) is being run to recover a filesystem, it  does  not  need  to  allocate  blocks  in  the
    filesystem to store a large number of unlinked files.  This ensures that e2fsck will not have to allocate data blocks in the filesystem during recovery.
обаделдт. все рано непонятно. зачем так условжнять. почему бы просто руками несоздаьт ивсе.
что значит pre-allocate блоки для папки lost+found?

а вот и частичный ответ
>debugfs:  icheck 8483
Block   Inode number
8483    11
>debugfs:  icheck 8484
Block   Inode number
8484    11
>debugfs:  icheck 8485
Block   Inode number
8485    11

прям несколько блоков принадлежит каталогу lost+found

и как указано в дампе 8486 уже свободный блок
>debugfs:  icheck 8486
Block   Inode number
8486    <block not found>

вот и решилась загадка почему свободный бок начианается с 8486


| чуть уйду в сторону

как узнать все блоки которыми заведут инода (это удбнее чем это смотреть в stat)
    >debugfs:  blocks <12>
    66048 

как посмотреть hex\ascii дамп блока ФС (очень удобно)
    >debugfs:  block_dump 66048
    0000  6578 7434 2031 2e74 7874 0a00 0000 0000  ext4 1.txt......
    0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
    *

тока надо помнить что почему то левая колнока котоаря покзыват оффсет 
 у этих дебилов в OCT(востмеричном) формате


| восстановление удаленного файла
| rm
| unlink
@@@@@@@@@@@@@@@@ начало  блока

если мы сделали файлу unlink или rm (тоест по факту мы удалили хардлинк )
но при этом если у нас есть хотя бы одна прога которая это файл 
держит открытым то сама инода еще не обнулена (подробнее чторельано просиходит
при unlink rm смотри ниже) то можно все исправить.

если у нас есть проога которая держит файл открытым.
и в тоже время мы через консоль сделаои 

# rm /mnt/ext3/45.txt 

то по факту происходит следущее - ядро удаляет entry в иноде которая отвечает 
за каталог и  уменьшает значение "link" в иноде которая отвечает за тело файла.
поле "link" в иноде отвечает за количество хардлинков ведущих к иноде отвечающей
за файл.

вот как это выглядит
пусть инода отвечающая за файл = 12

> debugfs:  mi  <12>
                          Mode    [0100644] 
                       User ID    [0] 
                      Group ID    [0] 
                          Size    [7] 
                 Creation time    [1688964796] 
             Modification time    [1688963968] 
                   Access time    [1688964788] 
                 Deletion time    [0] 
                    Link count    [0]    <===== было [1] стало [0]
              Block count high    [0] 
                   Block count    [8] 
                    File flags    [0x0] 
                    Generation    [0x6a53ea95] 
                      File acl    [0] 
           High 32bits of size    [0] 
              Fragment address    [0] 
               Direct Block #0    [17408] 
               Direct Block #1    [0] 
               Direct Block #2    [0] 
               Direct Block #3    [0] 
               Direct Block #4    [0] 
               Direct Block #5    [0] 
               Direct Block #6    [0] 
               Direct Block #7    [0] 
               Direct Block #8    [0] 
               Direct Block #9    [0] 
              Direct Block #10    [0] 
              Direct Block #11    [0] 
                Indirect Block    [0] 
         Double Indirect Block    [0] 
         Triple Indirect Block    [0] 


тоесть если файл открыт кемто. но другой процесс запустил rm
то поле "link" уменьшится на 1. было 1 станет 0.

также важно что поле "Deletion time"    [0] не будет изменено. какбыло 
0 так и останется 0.

также важно что указатели на  блоки где лежит тело файла они пока еще не будут
обнулены я говорб про "Direct Block" и "Indirect Block"
тоесть укатели на тело файла пока еще не потеряны.

мы можем через debugfs прибавит link обратно на [1] но это нам не поможет.
об это щас поясню далее.

также у иноды будет сброшен "in-use" флаг (команлы testi\clri\seti)

так вот 
как только мы закроем программу которая имела открытым наш файл
то произодйет следущая перетрубация с инодой


> debugfs:  mi <12>
                          Mode    [0100644] 
                       User ID    [0] 
                      Group ID    [0] 
                          Size    [0] 
                 Creation time    [1688964953] 
             Modification time    [1688964953] 
                   Access time    [1688964788] 
                 Deletion time    [1688964953] 
                    Link count    [0] 
              Block count high    [0] 
                   Block count    [0] 
                    File flags    [0x0] 
                    Generation    [0x6a53ea95] 
                      File acl    [0] 
           High 32bits of size    [0] 
              Fragment address    [0] 
               Direct Block #0    [0] 
               Direct Block #1    [0] 
               Direct Block #2    [0] 
               Direct Block #3    [0] 
               Direct Block #4    [0] 
               Direct Block #5    [0] 
               Direct Block #6    [0] 
               Direct Block #7    [0] 
               Direct Block #8    [0] 
               Direct Block #9    [0] 
              Direct Block #10    [0] 
              Direct Block #11    [0] 
                Indirect Block    [0] 
         Double Indirect Block    [0] 
         Triple Indirect Block    [0] 

у нее опять будет уменьшен "link" с 1 до нуля. тоесть наша правка на предудыщуем
этапе не помогает. 
у нее будет Deletion time    изменен с [0]
до чегонибудь     [1688964953]   ( у нормальной инды которая обслуживает файл deleteion должен быть равен нулю. так что это плохо)

и самое ужасное что будут обнулены все поля "Direct Block" и "indirect block"
тоесть мы потеряли спсок блоков с телом файла. при этом  если мы знаем блоки (записали на бмуажке) то сами блоки с телом нетронуты. но их список потерян.

поэтому я предлагаю не мудить с попыткой оживить иноду которая будет потерта системой.

я выбираю другой путь восстанолвения доступа к файлу.
алгоритм такой:
во првых важно чтобы файл по прежнему был открыт хотть какойто программой. потому что 
если сичезнет последний откртый дескриптор то инода файл будет обнулена. 
далее- заходим в debugfs, копируем тело иноды в другую иноду, правим эту другую иноду,
выставляем ей флаг "in-use", создаем entry в папке (создаем хардлинк)
выходим из debugfs. отстаналвиливает программу которая делржала файл открытым.
отмонтируем фс (потому что не знаю почему но измеенения в папках появятся только после ремаунта фс), запускаем принудтельную проверку фс, потому что с инодами то мы помудили
но там еще надо исрпавлять другие метаданные , руками это невозможно а e2fsck все поправит.
монтрируем обратно фс.  файл должен быть на месте. поехали

# echo "12232" /mnt/ext3/45.txt

открываем его на чтение скажем в mcedit
удаляем его хардлинк

# rm /mnt/ext3/45.txt

заходим в дебагфс с флагом на запись

# debugfs -w /mnt/5G-ext3.txt

в другой консоли смотрим какой был номер иноды для этого файла

# lsof | grep 45.txt
mc         722                           root   12r      REG                7,5           7         12 /mnt/ext3/45.txt (deleted)

получется номер иноды = 12

debugfs:  copy_inode <12> <30>    # копириуем спец иноды 12 в новую иноду 30
debugfs:  mi <30>                 # редактируем иноду 30
                          Mode    [0100644] 
                       User ID    [0] 
                      Group ID    [0] 
                          Size    [7] 
                 Creation time    [1688966519] 
             Modification time    [1688963968] 
                   Access time    [1688966473] 
                 Deletion time    [0] 0   # на всякий случай прям еще руками проставляем 0
                    Link count    [0] 1   # меняем число хардлинков на 1
              Block count high    [0] 
                   Block count    [8] 
                    File flags    [0x0] 
                    Generation    [0xc3c52c67] 
                      File acl    [0] 
           High 32bits of size    [0] 
              Fragment address    [0] 
               Direct Block #0    [17408] 
               Direct Block #1    [0] 
               Direct Block #2    [0] 
               Direct Block #3    [0] 
               Direct Block #4    [0] 
               Direct Block #5    [0] 
               Direct Block #6    [0] 
               Direct Block #7    [0] 
               Direct Block #8    [0] 
               Direct Block #9    [0] 
              Direct Block #10    [0] 
              Direct Block #11    [0] 
                Indirect Block    [0] 
         Double Indirect Block    [0] 
         Triple Indirect Block    [0] 
debugfs:  
debugfs:  seti <30>        # активируем флаг "in-use" для новой иноды
debugfs:  ln <30> /45.txt  # создаем хардлинк entry в папке фс
debugfs: quit

выходим из mcedit который дераж открытым файл 45.txt

# umount   /mnt/ext3   # отмонтируем фс

# e2fsck -f /mnt/5G-ext3.txt    # запускаем принудительную проверку ФС
e2fsck 1.46.5 (30-Dec-2021)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
Block bitmap differences:  +17408
Fix<y>? yes
Free blocks count wrong for group #0 (15849, counted=15848).
Fix<y>? yes
Free blocks count wrong (3793485, counted=3793484).
Fix<y>? yes
Inode bitmap differences:  +30
Fix<y>? yes
Free inodes count wrong for group #0 (8133, counted=8132).
Fix<y>? yes
Free inodes count wrong (969125, counted=969124).
Fix<y>? yes

/mnt/5G-ext3.txt: ***** FILE SYSTEM WAS MODIFIED *****
/mnt/5G-ext3.txt: 12/969136 files (0.0% non-contiguous), 77236/3870720 blocks


# mount -o loop /mnt/5G-ext3.txt  /mnt/ext3     # монтируем обратно фс
# cat /mnt/ext3/45.txt      # проверяем что файл на фс есть и с ним все окей
443534

# journalctl -f  | grep -i ext     # также проверяем в логах что нет ругани от ядра на ФС

я проверил. восстанволение удаленного фалай работает и на ext3 и на ext4

@@@@@@@@@@@@@@@@ конец блока


ксати по поводу вывода на экран e2fsck
вот это 
    12/969136 files
означает что на данной фс всего инод есть 969136 
а на данный момент занято 12 штук  (это все можно посмтрет через dumpe2fs -h  в параметрах
суперблока)

а вот это 
    77236/3870720 blocks
означает сколко всего блоков ФС  есть на ФС и сколько из них занято.
блоки ествественно не физ сектора диска а блоки ФС (тоже можно проверить эти цифры через dumpe2fs -h  в параметрах суперблока) 

а вот это 
    (0.0% non-contiguous)
означает фрагментировать тел файлов. только я поканенаю как он это высчитывает


ксати вот как выглядит пустая инода

# debugfs
> stat
Inode: 12   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 330651343    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 0
File ACL: 0
Links: 0   Blockcount: 0
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab5e4e:03970ccc -- Mon Jul 10 01:26:38 2023
 atime: 0x64ab5d85:503a04d4 -- Mon Jul 10 01:23:17 2023
 mtime: 0x64ab5e4e:03970ccc -- Mon Jul 10 01:26:38 2023
crtime: 0x64ab5d85:503a04d4 -- Mon Jul 10 01:23:17 2023
 dtime: 0x64ab5e4e:(03970ccc) -- Mon Jul 10 01:26:38 2023
Size of extra inode fields: 32
Inode checksum: 0x83dc3b3b
EXTENTS:
(END)


а вот блок на диске (номер которого я запоминил ) на который инода указыала по прежнему содержит данные

> block_dump 66048
0000  6578 7434 2031 2e74 7874 0a00 0000 0000  ext4 1.txt......
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

unlink работает плюс минус также как и rm.
так что после него восстаналивем по тому же алгоритму

далее в свойтвах суперлока есть такая фишка 
Lifetime writes:          9 MB
покзывает сколько было записнао данных с момента СОЗДАНИЯ фс!!
прикольная фишка!

еще в свойствах суперблока бывает такая запист
    First orphan inode:       24914761
орфан инода это вот что - был файл у которого удалили хардлинк. тоесть 
файлу либо сделали rm либо unlink. но файл при этом остается открытым 
каким то процессом. получается ни одного хардллинка у файла уже нет
а инода незатертая пока что есть. вот такая инода называется орфан инода.
когда процесс закроет эту иноду то код фс\ядра ее затрет. и она перестанет 
быть орфан инодой.


двигаю дальше
 разбиараю  дальше статью ==>  https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/


хотел сказать что dumpe2fs и debugfs это незаменимые глаза и ущи для 
анализа фс.


также хотел сказать на счет расшфировки смысла того что выводит dumpe2fs
пример

Group 0: (Blocks 0-32767) csum 0xd6b8 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xef300295
  Inode bitmap at 42 (+42), csum 0x06136e48
  Inode table at 82-593 (+82)
  0 free blocks, 8180 free inodes, 2 directories, 8172 unused inodes
  Free blocks: 
  Free inodes: 12-19, 21-8192
Group 1: (Blocks 32768-65535) csum 0x0ae9 [INODE_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6
  Inode bitmap at 43 (bg #0 + 43), csum 0x00000000
  Inode table at 594-1105 (bg #0 + 594)
  28583 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 36953-65535
  Free inodes: 8193-16384
Group 2: (Blocks 65536-98303) csum 0x03c2 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 4 (bg #0 + 4), csum 0x90ad0b51
  Inode bitmap at 44 (bg #0 + 44), csum 0x00000000
  Inode table at 1106-1617 (bg #0 + 1106)
  32767 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 65537-98303
  Free inodes: 16385-24576

так вот важно сказать две вещи:
1) дамп2фс кода описывает каждую группу блоков а точнее описывает метаданные
котоыре хранятся в этой группе блоков то дамп2фс указывает только параметры
метаданных для этой группы блоков.тоесть  дело вот в чем . раньше наример на ext3
метаданыне котоыре лежали внутри группы блоков они относились только к этой 
группе блокво. все было просто. на ext4 в  конкретной группе блоков могут лежать 
метаданные от другой группы блоков. так вот я говорю о том что дамп2фс когда рисует 
на экране инфомрацию по группе блоков точнее по метаданным лежащим в этой группе блоков
то дамп2фс рисует инфо толкьо по метаданным отнсосяищимся к этйо грппеу блоков несморя
на то что в группе есть метданные от других гурпп блоков. 
как это выглядит


Group 0: (Blocks 0-32767) csum 0xd6b8 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xef300295
  Inode bitmap at 42 (+42), csum 0x06136e48
  Inode table at 82-593 (+82)
  0 free blocks, 8180 free inodes, 2 directories, 8172 unused inodes
  Free blocks: 
  Free inodes: 12-19, 21-8192

Group 1: (Blocks 32768-65535) csum 0x0ae9 [INODE_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6
  Inode bitmap at 43 (bg #0 + 43), csum 0x00000000
  Inode table at 594-1105 (bg #0 + 594)
  28583 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 36953-65535
  Free inodes: 8193-16384



вот такого рода записи (bg #0 + 3) означают то что метаданное в этой строке
его нет в этой группе блоков. вместо этого данное метданные хранится в другой групе
блоков . в данном метаданное хранися в групе блоков #0
тоесть

Group 1: (Blocks 32768-65535) csum 0x0ae9 [INODE_UNINIT, ITABLE_ZEROED]
   ....
  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6

это означае что блок битмап не лежит в группе блоков "1". вместо этого 
блок битмап от этой группы хранится в групе блоков "0"

зато в описании группы блоков "0" ничего не будет сказано что внутри нее 
хранится блок битмап от группы "1".

таким макаром яхотел обоначить эти две вещи.
что с одной стороны дамп2фс непокзывает инфо обо всех метаданных харнящихяс в группе блоков.
тоесть они там есть но дамп2фс в описании группы блоков ничего об этом не говоит.
как напримере гурппы 0


Group 0: (Blocks 0-32767) csum 0xd6b8 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xef300295
  Inode bitmap at 42 (+42), csum 0x06136e48
  Inode table at 82-593 (+82)
  0 free blocks, 8180 free inodes, 2 directories, 8172 unused inodes
  Free blocks: 
  Free inodes: 12-19, 21-8192



в этой группе есть другие метаданные. об этом здесь не сказано. с дной тороны в этом минус.
но плюс состоит в том что те метаданные (адреса их блоков) которые указаны описании 
они отвечают именно за этот блок. в этом фишка. и плюс


вот другая группа

Group 1: (Blocks 32768-65535) csum 0x0ae9 [INODE_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6
  Inode bitmap at 43 (bg #0 + 43), csum 0x00000000
  Inode table at 594-1105 (bg #0 + 594)
  28583 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 36953-65535
  Free inodes: 8193-16384


  здесь все наоброот. здесь указаные метаданные которых в этой группе нет.физически.
  метаднные ответсвнные за эту группу блоков.
  но злесь есть указание где их искать

  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6
  Inode bitmap at 43 (bg #0 + 43), csum 0x00000000
  Inode table at 594-1105 (bg #0 + 594)


тоесть этих метданных в этой групе блоков нет! но указание состоит в том что 
они есть в группе "0" !! и указан адрес где их искать в той группе !

bg #0 = означает что искать надо в группе блоков #0
длаьше указыается смещение где искать.

вот на этом я хоетел  сакцентировать внимание
о том как дешфировать вывод дамп2фс


двигаем дальше.
опять же про вывод в дамп2фс

Group 0: (Blocks 0-32767) csum 0xd6b8 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xef300295
  Inode bitmap at 42 (+42), csum 0x06136e48
  Inode table at 82-593 (+82)
  0 free blocks, 8180 free inodes, 2 directories, 8172 unused inodes
  Free blocks: 
  Free inodes: 12-19, 21-8192

Group 1: (Blocks 32768-65535) csum 0x0ae9 [INODE_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6
  Inode bitmap at 43 (bg #0 + 43), csum 0x00000000
  Inode table at 594-1105 (bg #0 + 594)
  28583 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 36953-65535
  Free inodes: 8193-16384

как можн замеитить есть интересные поля вида
[ITABLE_ZEROED]
[INODE_UNINIT]


они означают флаги которые выставлены в Block Group Descriptir таблице в ее entry
для данной группы блоков. тоест еще раз флаги хрантся в Block Group Descriptor таблице.
для каждй группы блоков таместь entry. и в нем есть место для флагов.как их проставлять?
по сути опосредованно - коода при формтировании мы указаем в опцииях фичи котоыре
мы хотим активиовать на фс то эти фичи и вляиют на эти флаги.
таким макаром дамп2фс показывает нам для каждой группы еть ли выставленные для нее флаги в
Block Group Descriptir 

теперт повгорим о смысле этих флагов
вот описание этих флагов из вики про ext4

inode table and bitmap are not initialized (EXT4_BG_INODE_UNINIT).
block bitmap is not initialized (EXT4_BG_BLOCK_UNINIT).
inode table is zeroed (EXT4_BG_INODE_ZEROED).

ятакже нашел то что 
(EXT4_BG_INODE_UNINIT) сокрашенно наывается INODE_UNINIT
(EXT4_BG_BLOCK_UNINIT) сокашенно называется BLOCK_UNINIT

походу INODE_UNINIT значит что mkfs не должен при создании фс ициализировать ни инода битмап, ни таблица инодов
BLOCK_UNINIT значит что mkfs не доллжен при создании фс иницлизировать блок битмап
INODE_ZEROED - а вот это наоборот странный флаг.походу озанчает что мкфс на стадии
создания фс должен иницлизировать таблицу инодов. походу перывй и тертий флаг
взаимоисключающие... пока одни догадки



значит что значат эти флаги. 

сттранно то что дампфс выводит несколько друние названия чем указано в описании ext4

походу INODE_UNINIT = EXT4_BG_INODE_UNINIT = inode table and bitmap are not initialized
флаг ITABLE_ZEROED котоырй покаызвает дампфс я не вижу описании ext4.
в описании есть тоолько этот флаг EXT4_BG_INODE_ZEROED похожий


так вот продолжает изучение этих загадочных флагов.
я нашел в мануале что вот эти три флага про которые я сказал выше
они заставляют mkfs не инициализировать (тоесть не тратить время на заполнение блоков метаданных начальными данными ) львиную долю метаданных в группе блоков.таким макаром
эконоится время на форматирование фс. 


я цитриую что напиано во писании ext4 про эти три флага: а написана какаято чущь:
A new feature for ext4 are three block group descriptor flags that enable mkfs to skip initializing other parts of the block group metadata. Specifically, the INODE_UNINIT and BLOCK_UNINIT flags mean that the inode and block bitmaps for that group can be calculated and therefore the on-disk bitmap blocks are not initialized. This is generally the case for an empty block group or a block group containing only fixed-location block group metadata. The INODE_ZEROED flag means that the inode table has been initialized; mkfs will unset this flag and rely on the kernel to initialize the inode tables in the background.

далее идет какято непонятная хуйня о том что якобы толи все эти три флага то ли часть
устанавалиется если мы при формате фс укажем фичу "uninit_bg"
вот ее описание 
 This  ext4  file  system feature indicates that the block group descriptors will be protected using checksums, making it safe for mke2fs(8) to create a file system without
              initializing all of the block groups.  The kernel will keep a high watermark of unused inodes, and initialize inode tables and blocks lazily.  This feature speeds  up  the
              time to check the file system using e2fsck(8), and it also speeds up the time required for mke2fs(8) to create the file system.

тоесть эта фича дает то что для блок груп дескрипторов вычисляются контольные суммы 
и я не понимаю при чем здесь те три флага.

собирая всю эту хуевую документацию я полагаю что установка этой фичи дает установку тех флагов и это дает то что помимо добавления контрльных сумм в груп дескрипторы еще дает 
то что или для всех блок гурпп или для части блок групп при форматировании толи все их 
метадданные неиницилизирубтся то ли часть метаданныех неиницализируеися. поэтому скорость 
форматитвания вырастает.

охуеть коасная доукментация.

также методом тыка я нашел то что не только фича "uninit_bg" приводит к таким последствиям.
есть фича еще болшее мощная и она делает тоже самое.  вот эта фича
 metadata_csum
              This ext4 feature enables metadata checksumming.  This feature stores checksums for all of the filesystem metadata (superblock, group descriptor blocks,  inode  and  block
              bitmaps, directories, and extent tree blocks).  The checksum algorithm used for the metadata blocks is different than the one used for group descriptors with the uninit_bg
              feature.  These two features are incompatible and metadata_csum will be used preferentially instead of uninit_bg.
она не толко доблаяет контрол суммы к блок дескрпитоарм а вообще ко всему.

теперь я буду ставить эксперименты и смотреь что получается.

форматируб ФС вот так:
# mkfs.ext4 ./1G.txt -O ^metadata_csum -O ^"uninit_bg" -O ^flex_bg

проверяем что этих фич нет в суперблоке
# dumpe2fs ./1G.txt  -h  | grep -i "Filesystem features:"
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit sparse_super large_file huge_file dir_nlink extra_isize


далее смотрю проверяю что у нас наши группы не имеют установленных тех 
трех волшебных флагов (ведь фичи то мы деактивировали)


Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2)
  Inode bitmap at 3 (+3)
  Inode table at 4-515 (+4)
  32247 free blocks, 8181 free inodes, 2 directories
  Free blocks: 521-32767
  Free inodes: 12-8192
Group 1: (Blocks 32768-65535)
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 32770 (+2)
  Inode bitmap at 32771 (+3)
  Inode table at 32772-33283 (+4)
  32252 free blocks, 8192 free inodes, 0 directories
  Free blocks: 33284-65535
  Free inodes: 8193-16384
Group 2: (Blocks 65536-98303)
  Block bitmap at 65536 (+0)
  Inode bitmap at 65537 (+1)
  Inode table at 65538-66049 (+2)
  32254 free blocks, 8192 free inodes, 0 directories
  Free blocks: 66050-98303
  Free inodes: 16385-24576


видно что да. ниаких флагов нет.

теперь форматрую с фичеей

# mkfs.ext4 ./1G.txt -O metadata_csum -O ^uninit_bg -O ^flex_bg
# dumpe2fs ./1G.txt  -h  | grep -i "Filesystem features:"
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit sparse_super large_file huge_file dir_nlink extra_isize metadata_csum

фича есть.

смотрим что там с группами


Group 0: (Blocks 0-32767) csum 0xf4b9 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xafee6643
  Inode bitmap at 3 (+3), csum 0x4ee70545
  Inode table at 4-515 (+4)
  32247 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes
  Free blocks: 521-32767
  Free inodes: 12-8192
Group 1: (Blocks 32768-65535) csum 0xf022 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 32770 (+2), csum 0x00000000
  Inode bitmap at 32771 (+3), csum 0x00000000
  Inode table at 32772-33283 (+4)
  32252 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 33284-65535
  Free inodes: 8193-16384
Group 2: (Blocks 65536-98303) csum 0xab05 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 65536 (+0), csum 0x00000000
  Inode bitmap at 65537 (+1), csum 0x00000000
  Inode table at 65538-66049 (+2)
  32254 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 66050-98303
  Free inodes: 16385-24576

ввидим что ситуация поменялась.
повылезали флаги
[INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]


ТАК - я вот щас прочитал информацию новую про эти флаги  - я тогда не будут стирать
то что выше писал.  а просто изложу считай заново.

значит если мы посмотрим на дамп2фс то мы увидим у групп блоков в ext4 
интересные поля

Group 0: (Blocks 0-32767) csum 0xf4b9 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xafee6643
  Inode bitmap at 3 (+3), csum 0x4ee70545
  Inode table at 4-515 (+4)
  32247 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes
  Free blocks: 521-32767
  Free inodes: 12-8192
Group 1: (Blocks 32768-65535) csum 0xf022 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 32770 (+2), csum 0x00000000
  Inode bitmap at 32771 (+3), csum 0x00000000
  Inode table at 32772-33283 (+4)
  32252 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 33284-65535
  Free inodes: 8193-16384

а именно
[ITABLE_ZEROED]
[INODE_UNINIT]
[BLOCK_UNINIT]

это так назвыаемые флаги. их три штуки. у каждой группы блоков в ext4 есть три флага.
они хранятся в GDT. для каждой группы блоков есть свои три флага.

что они значат согласно докам от ext4:
inode table and bitmap are not initialized (EXT4_BG_INODE_UNINIT).
block bitmap is not initialized (EXT4_BG_BLOCK_UNINIT).
inode table is zeroed (EXT4_BG_INODE_ZEROED).

я тут сразу замечу то что флаг INODE_ZEROED программа dumpe2fs отображает как ITABLE_ZEROED


теперь поясню какой смысл этих флагов. при создании фс (тоесть ее форматировании)
драйверу нужно на диске записать все метаданные.  тоесть суперблок, копии суперблока,
GDT, все копии GDT, все битмапы блоков, все битмапы инод. какие то метаданные нужно 
занулить например нужно все таблицы инодов занулить. так вот это будет  занимать 
много время если раздел большой. тогда придумали вот что - а дайате при форматировании
будем на диск записывать только мнимальный обьем метаданных.  а остальной обьем будем
создавать уже после того как диск примонтировали. и будем это делать в фоновом режиме. 
так и порешили. это называется lazy ext4 initializtion. выглядит это так мы запускаем
mkfs.ext4 со спец флагами. и он очень быстро форматируем раздел. потом мы монтируем первый раз
раздел со спец флагами и в линукс ядре запускается тред который начинает в фоновом режиме
доделывать то что было не додделано. возвращаюсь к флагам.

флаг  (EXT4_BG_BLOCK_UNINIT) проставляется для группы блоков если в этой группе незанят
незайдейстован ни один блок группы. 
пример

Group 3: (Blocks 98304-131071) csum 0xdbaf [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 98304, Group descriptors at 98305-98305
  Block bitmap at 98306 (+2), csum 0x00000000
  Inode bitmap at 98307 (+3), csum 0x00000000
  Inode table at 98308-98819 (+4)
  32252 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 98820-131071
  Free inodes: 24577-32768

точнее получается так что это флаг выставляется для группы если в этой группе заняты блоки 
тольлко метаданными. тоесть нелья сказать что ни один блок групппы незанят. это не так.
но блоки которые заняты они заняты метаданными. а вот дальше ни один блок незанят.
тогда выставляется этот флаг


следущий флаг EXT4_BG_INODE_UNINIT если выставлен то это означает что в этой группе
блоков ни один из инодов не зайдействтован. 
пример

Group 3: (Blocks 98304-131071) csum 0xdbaf [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 98304, Group descriptors at 98305-98305
  Block bitmap at 98306 (+2), csum 0x00000000
  Inode bitmap at 98307 (+3), csum 0x00000000
  Inode table at 98308-98819 (+4)
  32252 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 98820-131071
  Free inodes: 24577-32768

в своствах супеблока можно помотреть сколько инодов на группу есть на этой фс. 
значит я посмотрел и вижу
    Inodes per group:         8192
так вот видно что 8192 free inodes
тоесь ни одна инода незадейстована. если это так то выставляется этот флаг.

третий флаг EXT4_BG_INODE_ZEROED . как я уже сказал что если мы задействовали lazy initialzation при форматировании. то часть метаданных на фс после форматирования отсутствует.
потом мы когда монтируем фс то сразу же в кернеле поднимается тред который начинает допиливать
метаданные. так вот этот тред проходит по группа блоков и зануляет таблицу инодов. если честно мне непонятно нахйя это делать. если у нас в битмапе инода написано что он свободен
а система хочет заюзать этот инод то перед этим она может пойти в таблицу инодов и занулить
там все. это будет штучная работа в нужное время в нужно месте. нахера их заранее занулять
неясно. если инод у нас занят и мы хотим его освободиь нам опяьть же так и так его нужно
будет загнулять в тадице инодов. поэтому для меня этот шаг выгдядит как перестраховка.
так вот когда кернел тред полностью загуляет таблицу инодов для группы блоков то выставляет
этот флаг. 

теперт нахераэти флаги нужны. где они используются. 
первый аспект это следствие быстрого форматирования. если ядро 
заходит в группу блоков и встречает там выставленные флаги INODE_UNINIT либо
BLOCK_UNINIT то оно понимает что фс была создана через быстрое формаитиование.
и значит... как потом размышляет ядро незнаю. дело в том что я незнаю что делает 
быстрое формативаия с битмап блоками для инод и дата блоков. оно их зануляет
или оно их вобще не трогает?  поидее занулять блок битмап оно не должно потому что в
группе блоков будут заняты блоки под метаданные поэтому в блок битмапе скажем так по 
любому это должно быть отражено. поэтому блоковый битмап не может быть ни нялями ни мусором.
непонятно как выглядит инодовый битмап после ыстроого формтиорвания. он занулен
или его просто не трогает форматировщик. флаг INODE_UNINIT выставляется если ни одна
инода из группы незадействована. что это дает ядру непонятно. по идее быстрый 
форматировщик не должен трогать битмап инод потому что если он его при формате зануляет
тогда нахер нам флаг который показывает это свойство. флаг BLOCK_UNINIT выставляется
не когда у нас в группе ни один блок незайдейстовован. нет. а когда блоки заняты только метаданными. это значит что блоковый битмап обязательно должен отображать что такие то
блоки заняты под метаданные. зачем нужно было лепить флаг если можно просто в файле блокового
битмапа проставить все нули кроме битов отвечающих за блоки с метаданными. ценность флага
EXT4_BG_INODE_ZEROED тоже под вопросом. понятно что тред который занляет таблицы инодов
таким макаром поиммает какие группы он уже обработал а какие нет. но вопрос нахер вообще
занулять таблицы инодов заранее. если мы хотим использовать иноду мы проверяем чрез 
битмап инод что он свободна. потом мы ее конкетную зануляем. и все. зачем заранее
все таддицы инодов занулть непонятно. 

что дают эти флаги для программы e2fsck. она начинает сканировать группы блоков 
и если видит флаг INODE_UNINIT то онимает что в этой группе блоков ни одной иноды
прверяеь ненадо и идет дальше. а как напиано в иенте - время проверки инодов это львиная
доля работы e2fsck. если хоть одна инода  вгруппе заюзана то этот флаг убирается но в
GDT есть доп поле "bg_itable_unused" которые указывает не совсем понятно что.
как я понял оно указывает самый маленький по номеру номер иноды которая никогда 
в этой группе блоков не была использована. скажем иноды больше 5000 никогдане были
испоьзованы в этой группе. тогда это поле будет хранить 5000.дело в том что 
ядро выдает иноды от меньшего к большему. если инода 5000 никогда не была использована
значит все иноды > 5000 тоже не были использованы.
так вот как я понял e2fsck она не проверяет иноды которые были никогда не использованы.
прикол в том что если инода была использована а потом ее освободили то она уже никогда не вернется в статус неиспользованной. я провел эксперимент. я создал разде с 65535 инодами.
потом я создал на нем 65535 файлов. потом я их стер. и в дамп2фс видно четко что 
свободных инод полно. но ни одна из них не является неиспользованной. отсюда получается вывод
что был у нас диск. мы его забили файлами. потом мы их стерли. иноды освободились 
но по скольку они были коогда то заюзаны то теперь e2fsck будет всегда их проверять.
поэтому диск может быть пустой а время проверки его будет большое как бутто он забит
файлами. единствнное что как я понимаю что свободные иноды они не указвают ни на какие блоки
данных поэтому такие иноды по идее доожны быстро проверяться.

пример группы 

Group 3777: (Blocks 123764736-123797503) csum 0x72af [ITABLE_ZEROED]
  Block bitmap at 123731969 (bg #3776 + 1), csum 0xebc165b2
  Inode bitmap at 123731985 (bg #3776 + 17), csum 0x324ccace
  Inode table at 123732512-123733023 (bg #3776 + 544)
  18754 free blocks, 8192 free inodes, 0 directories, 5470 unused inodes

видно что свободно 8192 иноды, из них 5470 инод никодга не использовалось. 
как я прнммаю число unused dump2fs вычисляяет на основе поля "bg_itable_unused"

вобще в GDT bg_itable_unused состоит из двух полей
если не активирован режим 64bit то 
    bg_itable_unused_lo = определеяет младший 16 бит  
а если активирован то добаялется еще 16бит
    bg_itable_unused_hi = определяет старшией 16 бит  



теперь я скажу про то  о чем сигнализируеют флаги
    EXT4_BG_INODE_UNINIT
    EXT4_BG_BLOCK_UNINIT
    EXT4_BG_INODE_ZEROED
лично для нас когда мы смотрим на вывод дамп2фс
1) если они вообще есть то значит фс была форматирована в ленивом режиме.
потому что если флагов нет то есл я правильно помню это значит что раздел
форматоавлся в неленивом режиме
2)  EXT4_BG_INODE_ZEROED флаг нам гвоорит о том что инициализатор ext4 прошелся
по этой группе и занулил инода тейбл в свое время. это не значит что она сейчас
зануленная.это значит что когда то это было. 
3)  EXT4_BG_BLOCK_UNINIT говорт нам о том том в этой группе блоков никаких тел файлов нет.
блоки заняты толлько под метаданные. тоеть эта группа еще незадействована под файлы.
более того это значит в этой группе никогда не было тел файлов. потому что если мы напихаем
файлов в эту группу то флаг сбросится. а если мы потом файлы удалим то флаг обратно
уже не появится
4)     EXT4_BG_BLOCK_UNINIT гвооит нам о том что в этой группе все иноды свободные.
более того с момента создания группы ниразу ни одной иноды отсюда не задейстовали.

смтотрим на пример групп блоков  с моего ноубука

Group 0: (Blocks 0-32767) csum 0xfa22 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-60
  Reserved GDT blocks at 61-1084
  Block bitmap at 1085 (+1085), csum 0xda8d78f3
  Inode bitmap at 1101 (+1101), csum 0x7bc68aa2
  Inode table at 1117-1628 (+1117)
  20876 free blocks, 8173 free inodes, 2 directories, 8172 unused inodes
  Free blocks: 9315-13408, 15985-16399, 16401-32767
  Free inodes: 19, 21-8192

[ITABLE_ZEROED]  = когда то таблица инодов была занулена. ну окей.


Group 1: (Blocks 32768-65535) csum 0x2418 [INODE_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32828
  Reserved GDT blocks at 32829-33852
  Block bitmap at 1086 (bg #0 + 1086), csum 0x3029e78c
  Inode bitmap at 1102 (bg #0 + 1102), csum 0x00000000
  Inode table at 1629-2140 (bg #0 + 1629)
  585 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 33855, 33878-33919, 33982-34047, 34261-34303, 34306-34394, 34396-34401, 34403-34408, 34410-34415, 34417-34427, 34429-34507, 34509-34515, 34518-34529, 34531-34554, 34556-34572, 34574-34596, 34598-34614, 34617-34623, 34687-34815
  Free inodes: 8193-16384

INODE_UNINIT = с момента создания группы ни одна инода с этой группы не была задействована.
и действиетльно 
    585 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
у нас 8192 unused (незайдейстованных никогда ) inodes из 8192 free inodes


Group 2: (Blocks 65536-98303) csum 0x13a3 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1087 (bg #0 + 1087), csum 0x94cfaca3
  Inode bitmap at 1103 (bg #0 + 1103), csum 0x00000000
  Inode table at 2141-2652 (bg #0 + 2141)
  0 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 
  Free inodes: 16385-24576

аналгично предыдущей группе

Group 48: (Blocks 1572864-1605631) csum 0x1cb1 [ITABLE_ZEROED]
  Block bitmap at 1572864 (+0), csum 0xd24b0207
  Inode bitmap at 1572880 (+16), csum 0xd07c322d
  Inode table at 1572896-1573407 (+32)
  22127 free blocks, 2192 free inodes, 1133 directories, 1410 unused inodes
  Free blocks: 1581908-1581909, 1582079, 1582186-1582187, 1582257-1590781, 1591279-1600511, 1601268-1605631
  Free inodes: 397747-397754, 398914-398920, 398959, 399233-401408

[ITABLE_ZEROED]  = вобще мто этот флаг можно просто игнорировать
других флагов нет. это значит что иноды и блоки под файлы из этой группы когда то 
брались. идействитеьно видно что и даже сейчас и  блоки заняты под файлы и иноды заняты.

вывод такой : если говорить про флаги в целом то они либо показают что данная
группа никогда не "распечатывалась" либо в плане блоков под тела файлов либо под иноды.
либо показывает что когда то таблица инодов была занулена инициализатором ext4.

важно ткже сказать что все эти флаги активирууются только при указании 
при форматиорвании опций:
 # mkfs.ext4 .... -E lazy_itable_init= 1 -O uninit_bg
 
также при монтировании надо указать
 # mount -o init_itable=X ...

где X это число миллисекунд между паузой когда кернел инициализатор закончил занулять 
таблицу инодов предыддущей группы блоков и собиратеся переходить на новую группу блоков

часть этих опций вроде как активиованы по дефолту

так на данном этапе со значением флагом разобрались.

далее
я теперь понял зачем нужны Reserved GDT Blocks.
дело в том что одна запись для одной группы блоков в GDT таблице занимает 64 байта.
блок ФС у нас размером 4К это значит что в один блок ФС влезет записей об 64-ех группах блоков. это получается раздел размером (64*32768*4)/1024=8192 MB .это 8ГБ.
если размер ФС больше чем 8ГБ то записи об этой группах блоков уже не помещаются в
одном ФС блоке поэтому нао переходит на другой блок. Поэтому непрсредственно за GDT блоком
резервируют сколько то блоков на тот случай если мы будем динамически расшиярять раздел и как 
следтсиве наш GDT тоже потребует больше места.

как пример мой раздел на компе состоит из 124895488 числа блоков.
это 3812 групп блоков. в GDT запись обо всех группах занимает 3812*64/4096=60 блоков ФС
смотрим что покажет дамп2фс


Group 0: (Blocks 0-32767) csum 0xfa22 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-60
  Reserved GDT blocks at 61-1084

видно что так и есть GDT занимает 60 блоков
тажке видно что зарещезривировано 1024 блока. 
насколько я помню в доке написано что резевируется столкьо блоков чтобы можно было
динамически расшрирть фс в 1000 раз. если у нас щас 60 блоков значит надо +600 
и еще там написано что полченное число округляют до ближайшего кратного двум.
ближайшее кратное двум это 1024. все совпало.

очень хорошая картинка https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/  о том что нахрлится внутри группы 
блоков. и что находится внутри флекс группы.


далее насколко я понимаю тела экстентов хранятся в дата блоках.
то есть понятно все блоки дата блоки. но я имею ввду в тех блоках которые сидят 
после блоков с метадатами. те блоки где хранятся тела файлов. тоесть блоки на которые
указывают индирект поля в иноде они указывают на дата блоки. вот и разгадка где же
на фс хранятся экстенты.


далее. что прикольно - если мы создаем новый файл - то этот файл создается в иноде
которая имеет минимальный номер из пула возможных. а вот папка создается   в иноде 
с хрен знает каким большим номером. пример

# touch 01.txt
# stat 01.txt 
  File: 01.txt
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: 706h/1798d  Inode: 12          Links: 1

файл 01.txt ,инода 12


# touch 02.txt
root@vm1:/mnt/ext4# stat 02.txt 
  File: 02.txt
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: 706h/1798d  Inode: 13          Links: 1

файл 02.txt, инода 13


# mkdir dir-01
root@vm1:/mnt/ext4# stat dir-01/
  File: dir-01/
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: 706h/1798d  Inode: 131073      Links: 2

папка dir-01, инода 131073


# mkdir dir-02
root@vm1:/mnt/ext4# stat dir-02/
  File: dir-02/
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: 706h/1798d  Inode: 131074      Links: 2

папка dir-02, инода 131074


посмотрим а какой номер имеет самая последняя нода
# dumpe2fs -h /mnt/5G-ext4-2.txt | grep -i inode
dumpe2fs 1.46.5 (30-Dec-2021)
Inode count:              327680


получется что возможно папке выдается инода примерно где то из середины пула инод.


видно что для папки "Links: 2" это значит что в иноде отвечающей за эту папку
прописан параметр "links=2" это значит что есть два хардлинка которые ссылаются
на эту иноду. что значит есть два хардлинка - это значит есть либо одна какаято 
папка в которой есть две ссылки на эту иноду. либо есть две папки  в кажой
из которых ест ссылка на эту иноду. по факту получается что у нас в текущей папке
есть запись вида ".", и у головной папки есть ссылка на эту папку.
вернусь к этому позже

далее. в суперблоке написано какая инода является первой свободной
First inode:              11
обычно (как я понимаю mkfs ) создат папку lost+found которая как раз будет иметь 11 иноду

далее
корневая папка всегда имеет inode=2


далее
посмотрми вот такой интерсный момент.  про приколы с ентри ".."

имеем папку /mnt
# stat /mnt
  File: /mnt
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: 801h/2049d  Inode: 1524        Links: 8


монтируем в нее диск
# mount /mnt/1G.txt  /mnt/2
# cd  /mnt/2
root@vm1:/mnt/2# ll -i
total 1952
   2 drwxr-xr-x 2 root root 1994752 Jul 11 20:00 ./
1524 drwxr-xr-x 8 root root    4096 Jul 11 19:44 ../


получается что /mnt2 имеет инода=2 это понятно. 
а вот далее внимание - как так поулчется что ".." в /mnt/2/ имеет иноду 1524 непонятно.
ведь елси я примонтирую раздел в друну папаку то ".." дожен поменяться.
получается ".." не надиске записан в в оператике както присовывается ?

а вот рассмотрим чуть более другой пример.
вот беру раздел который не смонтирован и смотрю его root entry
особенно на какую иноду ссылкается ".." запись.

      2   40755 (2)      0      0    4096 11-Jul-2023 22:47 .
      2   40755 (2)      0      0    4096 11-Jul-2023 22:47 ..
     11   40700 (2)      0      0   16384 11-Jul-2023 22:46 lost+found
     12  100644 (1)      0      0       4 11-Jul-2023 22:47 45.txt

и вот что мы имеемм ".. " в иноде от <2> (корнеовй каталог) ведет нас обратно в корневой
каталог. все отлично. все логично. тоесть чисто физически в ".." записана инода 2.

а вот щас мы этот диск примонтируем к другому диску. и дебагфс покажет что 
в этой же иноде запись ".." показвает не на иноду 2  а на совсем друную иноду

# mkdir /mnt/3
# mount -o loop /mnt/2G.txt  /mnt/3
# ll -i /mnt/3
total 28
   2 drwxr-xr-x  3 root root  4096 Jul 11 22:47 ./
1524 drwxr-xr-x 13 root root  4096 Jul 11 23:02 ../
  12 -rw-r--r--  1 root root     4 Jul 11 22:47 45.txt
  11 drwx------  2 root root 16384 Jul 11 22:46 lost+found/

видим что ".." указывает не на 2 иноду а на 1524.

а теперь еще раз зайдет в дебагфс п смотрим в содержимое иноды 2. ее ".." entry.

      2   40755 (2)      0      0    4096 11-Jul-2023 22:47 .
      2   40755 (2)      0      0    4096 11-Jul-2023 22:47 ..
     11   40700 (2)      0      0   16384 11-Jul-2023 22:46 lost+found
     12  100644 (1)      0      0       4 11-Jul-2023 22:47 45.txt

по преженму ".." указывает на иноду 2. тоесть ядро както динамически влияет 
на ".." это поразительно!!!!

буду потом с этим разбираться. 

еще хочу сказать что папки с именами "." и ".." по сути их имена это не чтото
особое. можно таким макаром самомму насоздавать папок вида "....", ".....",
"..23...", итд.
тоесть папки вида "." и ".." это просто маркетинговый необычный вид который 
будоражит лохов.  получается когд мы создаем папку то система сама внутри нее
создает две папки - самые обычные папки. просто у них чуть необычне имена "."
и ".."
если честно то мне непонтно нахуй они нужны . какой их практический смысл.
ксаььт из за этих ебнутых спец папок можно вот такие приколы вытворять

# cd /mnt/./././2/34/././..
# pwd
/mnt/2

соотвесвтенно так как "." ведет в туже папку тоесть не ведет к смене папки 
то одинарные точки не ведту к смене папки и их можно просто игнориовать. и тогда мы передйем
в папку 2 . а затем в папку 34. а затем мы перейдет в папку ".." котоаря нас приведет на уровень наверх. поэтому в итоге мы окахется в папке 2. что и видно на практкике.
зачем это ебанаство не понятно. 

вобще можнр разные диковыеиные сивмолы юзать в имена файло и впапок 
например #

# mkdir  "#"
# ll
total 36
drwxr-xr-x  2 root root  4096 Jul 11 23:59 '#'/

# cd "#"

прикол!



кстати с папками "." и ".." можно приколы делать.

# cd /mnt/
# pwd
/mnt
# cd /mnt/.
# pwd
/mnt

ну это понятно. а вот как вот такой прикол

# cd /mnt
# pwd
/mnt
# cd /mnt/..
# pwd
/

прикол

я в прпктике папки ". " и ".." почти неипользую. 
в чем их реальный практичесеий смысл?

я это будут изучать далее . а пока двигаем дальше.

далее. 
debugfs ее команлда stat
там есть поле флаг Flags: 0x80000
так вот этот конкетны флаг означает что инода юзает екстенты

# debugfs -R "stat <11>" /mnt/1G.txt
Inode: 11   Type: regular    Mode:  0644   Flags: 0x80000

кстати дебагфс как видно может работать и в неинтерактивном режиме


далее. есть еще поля gemeration,version

# debugfs -R "stat <11>" /mnt/1G.txt 
Inode: 11   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 1465898575    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 0
File ACL: 0
Links: 1   Blockcount: 0
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64add565:4885d3c8 -- Tue Jul 11 22:19:17 2023
 atime: 0x64add565:4885d3c8 -- Tue Jul 11 22:19:17 2023
 mtime: 0x64add565:4885d3c8 -- Tue Jul 11 22:19:17 2023
crtime: 0x64add565:4885d3c8 -- Tue Jul 11 22:19:17 2023
Size of extra inode fields: 32
Inode checksum: 0xe152e080
EXTENTS:
(END)

я говорю об этих полях
Generation: 1465898575    Version: 0x00000000:00000001

так вот они нужны для NFS. подробности неясны. ну и хер с ним.
кому щас нужна эта nfs


далее. опции монтирования для ext4 можно все найти в man ext4
там много полезного




далее. я хочу пощупать руками как же устрона директори нода изунтри. а точнее 
содержимое дата блоков на которые она сслыается. ведь сама инода которая за папку отвечает
она самая обычная такая же как у файла. а вот ее дата блоки это самый смак. 
 смотрим какие блоки занимает директори инода на примере кореневого каталога
debugfs:  blocks <2>
8226 

понятно что все entry они записаны именно в датаблоках.
посмотрим что же там в дата блоке записано

# debugfs ./2G.txt -R "cat <2>" | hexyl
debugfs 1.46.5 (30-Dec-2021)
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 02 00 00 00 0c 00 01 02 ┊ 2e 00 00 00 02 00 00 00 │•000_0••┊.000•000│
│00000010│ 0c 00 02 02 2e 2e 00 00 ┊ 0b 00 00 00 14 00 0a 02 │_0••..00┊•000•0_•│
│00000020│ 6c 6f 73 74 2b 66 6f 75 ┊ 6e 64 00 00 0c 00 00 00 │lost+fou┊nd00_000│
│00000030│ 10 00 06 01 34 35 2e 74 ┊ 78 74 00 00 01 20 00 00 │•0••45.t┊xt00• 00│
│00000040│ b8 0f 02 02 33 34 00 00 ┊ 00 00 00 00 00 00 00 00 │×•••3400┊00000000│
│00000050│ 00 00 00 00 00 00 00 00 ┊ 00 00 00 00 00 00 00 00 │00000000┊00000000│
│*       │                         ┊                         │        ┊        │
│00000ff0│ 00 00 00 00 00 00 00 00 ┊ 0c 00 00 de fc 89 96 dd │00000000┊_00×××××│
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

далее  я вспомина с каким фичами создан суперблок
# dumpe2fs -h /mnt/2G.txt | grep feature
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum

злесь видим фичу filetype
что она дает:
filetype
              This feature enables the storage of file type information in directory entries. 
онадает то что в entry для файл или папки котоырй хранится в дата блока директори ноды
указывается тип файла или папки. и в целом формат entry будет вот такой тгда

"entry format":
struct ext4_dir_entry_2 {
 1576     __le32  inode;          /* Inode number */
 1577     __le16  rec_len;        /* Directory entry length */
 1578     __u8    name_len;       /* Name length */
 1579     __u8    file_type;
 1580     char    name[EXT4_NAME_LEN];    /* File name */
 
первые 4 байта причем в литл ендиан это номер иноды на которую ссылается ентри
потом 2 байта литтл ендиан это длинна всей  ентри 
один байт это дллинна имени ентри (длинна имени файла или папки)  (вопрс в какой кодировке?
ответ никакой кодиовки нет. просто любой набоо байтов. макс длина имени 255 байт)
один байт это тип файла\папки
имя файла\папкм

значит что тут сразу интересно - это то что имя фала\папки неимеет никакого енкодинга.
это просто набор байтов. фс плевать что это за байты.  их интерпретация в буковки 
ложится на какито другие структуры. хотя я не очень понимаю вот у нас есть команда ls
на основе чего она преобразует байты из поля char в буквы. на вскиду иде ятакая что 
ls преобоазует байты в вбуквы на основе локале. но так как что такое локале хуй знает 
то пока что осталвяет этот вопрос.

возникает вопрос а как создать файл чтобы его имя можно было указать в форме потока байтов.
ну так чото на вскидку незнаю. зато можно сделать вот так

# echo -e "\xE2\x98\xA0"
☠

# touch $(echo -e "\xE2\x98\xA0").txt

и тогда будем иметь файл вот с таким именем
# ls -1
☠.txt

удивительно поразтеильно. и прикольно.

а еще вот такой прикол

# ls -1 | grep ☠
☠.txt

авсе из за того что фс насрать на имя файла. это просто набор байтов и все.
их интепретация в символы идет уже со стороны програмы которая получает от фс данные. 
хотя конечно как это раттботает на прааткие неочень понятно. надо брать strace и 
смотреть как работает ls. а потом читать свойства сисколлл.а корче не в этой жизнию


причем эти мисволы я их в граф консоли копирую и вставляю. а как с ними работаеть в 
чисто текстовой коносоли хуй знает.



2# ls -1a .
'#'
.
..
01.txt
34
45.txt
lost+found
''$'\177''.txt'
☠.txt
 


посмтрим как эти entry закодированы в дата блоках от иноды этого каталога


2# debugfs -R "cat <2>" /mnt/2G.txt | hexyl
debugfs 1.46.5 (30-Dec-2021)
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 02 00 00 00 0c 00 01 02 ┊ 2e 00 00 00 02 00 00 00 │•000_0••┊.000•000│
│00000010│ 0c 00 02 02 2e 2e 00 00 ┊ 0b 00 00 00 14 00 0a 02 │_0••..00┊•000•0_•│
│00000020│ 6c 6f 73 74 2b 66 6f 75 ┊ 6e 64 00 00 0c 00 00 00 │lost+fou┊nd00_000│
│00000030│ 10 00 06 01 34 35 2e 74 ┊ 78 74 00 00 01 20 00 00 │•0••45.t┊xt00• 00│
│00000040│ 0c 00 02 02 33 34 00 00 ┊ 0d 00 00 00 10 00 05 01 │_0••3400┊_000•0••│
│00000050│ 7f 2e 74 78 74 00 00 00 ┊ 02 20 00 00 18 00 01 02 │•.txt000┊• 00•0••│
│00000060│ 23 00 00 00 00 00 00 00 ┊ 00 00 00 00 00 00 00 00 │#0000000┊00000000│
│00000070│ 0f 00 00 00 10 00 07 01 ┊ e2 98 a0 2e 74 78 74 00 │•000•0••┊×××.txt0│
│00000080│ 0e 00 00 00 74 0f 06 01 ┊ 30 31 2e 74 78 74 00 00 │•000t•••┊01.txt00│
│00000090│ 00 00 00 00 00 00 00 00 ┊ 00 00 00 00 00 00 00 00 │00000000┊00000000│
│*       │                         ┊                         │        ┊        │
│00000ff0│ 00 00 00 00 00 00 00 00 ┊ 0c 00 00 de ff 26 0f f5 │00000000┊_00××&•×│
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

отталкивамся от формата

"entry format":
struct ext4_dir_entry_2 {
 1576     __le32  inode;          /* Inode number */
 1577     __le16  rec_len;        /* Directory entry length */
 1578     __u8    name_len;       /* Name length */
 1579     __u8    file_type;
 1580     char    name[EXT4_NAME_LEN];    /* File name */


длина первого entry равно 0c 00 (litele endian) = 00 0c = 12 байт.
вытаскиваем 12 байт

02 00 00 00 0c 00 01 02 ┊ 2e 00 00 00

02 00 00 00 = адрес иноды в лит ендиан = 00 00 00 02 = 2(dec)
итак ссылкается на иноду 2

0c 00 (litele endian) = длирнна всего ентри в литл ендиан 00 0c = 12 байт

01 = длинна имени = 1 байт

02 = тип файла = и тут вопрос какая цфира какой типа файла кодирует.
ответ нашео тут

https://www.kernel.org/doc/html/latest/filesystems/ext4/directory.html#ftype

Value Description
0x0    Unknown.
0x1    Regular file.
0x2    Directory.
0x3    Character device file.
0x4    Block device file.
0x5    FIFO.
0x6    Socket.
0x7    Symbolic link


у нас 2 поэтому это папка


2e = имя файла = что же это за имя?
ответ :
# echo -e "\x2e"
.

это "."

итак первый entry это  "." --> inode=2

непоянно зачем еще три байта с нулевыми занчения. нахуй это паддинг нужен??

смотрю следующи ентри. первые 4 байта это адрес иноды на которую ссылается ентри.
следущий два байта это длинна всего ентри. как и в прошлом случае это 0c 00 тоесть 12 байт.
и тогда весь ентри вынглядит как

02 00 00 00  | 0c 00 | 02 | 02 | 2e 2e 00 00

адрес иноды 00 00 00 02  = 2 
длина ентри 00 0с = 12
длина имени 02 = 2 байта
ттипа файла = 2  = папка
имя файла = 2e 2e лит ендиан  
# echo -e "\x2e\x2e"
..

значит второй ентри это  ".." (папка) ---> инода 2

следущий ентри его лдлина 14 00 лит ендинан = 00 14 = 20 байт

0b 00 00 00 | 14 00 | 0a |  02 |  6c 6f 73 74 2b 66 6f 75  6e 64 | 00 00

адрес иноды = 0b 00 00 00(le) = 0b = 11
14 00 le  = 14 = 20 байт (длинна всего ентри)
0a  = 10байт (длина имени)
02  = тип ф айла  = папка
6c 6f 73 74 2b 66 6f 75  6e 64 = имя 

$ echo -e "\x6c\x6f\x73\x74\x2b\x66\x6f\x75\x6e\x64";
lost+found

ага значит следущий entry это 

"lost+found" (папка )  ---> инода 11

тут интересный вопрос возникает.  имя файла сохранятеся в ентри в LE формате
или в BE.
для начал ответим на другой вопрос. вот у нас ест на экране слово
Vasya

воросы - мы слова зписываем в LE или в BE формате? 
во первых что такое LE формат. он включает в себя две сущности. одна сущность 
это носитель информации. и у него есть оффсет. ( для RAM это адрес ячекйи памяти.)
и есть сама информация. причем она представлена в виде байтов. и никак иначе.
причем LE\BE имеет смысл только тогда когда число состоит хотя бы из двух байтов.
если оно состоит из одного байта то понятие LE\BE теряет смысл.
вот у нас число = 256*FF + 1*0A
старший байт это FF потому что его измннеие драматически повлияет на число.
младщий байт это 0A потому что его изменнеие меньше повляиеи на число.

тогда LE формат записи на носитель инфомации состоит в тмо что мы в более маленький офсет
пишем младщий байт числа. а вболее старший офсет носится информации пишем более старший 
байт числа. тоесть

0A FF (LE формат)
FF 0A (BE формат)

значит для тго чтобы при считывании восствноить исодное число нам надо знать в формет 
lE заисано число на носительи или в формате BE 

вот мы знаем что на нсоиетеле записано двух байтное число.
значит оно вот такой имеет вид

число = 256*X + 1*Y
где с точки зрения числа x это старщий байт
а y это младщий байт.

а сточки зрения носителя иформации x,y это числа записанные на нем.

если мы занем что число состоит из двху байт и что на носител ифномрации число 
записано в LE формате . значит мы читаем два числа с носителя

0A - первое прочитанное число
FF - второе провченое число

и мы занеч что в младщем офсете сохранне младщий байт занчит Y . знаит Y=0A
а в стаошем офсете сохранене старщий байт то есть x. значии X=FF
подставлям в число

число = 256*FF + 1*0A

ели же на носиете мы знаем что число сохраен в формате BE тогда 
число = 256*0A + 1*FF

тааим макаром при счиыватии с носителя иформации нас чтобы восстановить ориинальное 
число нам надо знаьт скоько байт составляла длинна числа и в какой формате LE 
или BE оно записано на носииель. исходяи из этого один и тотже поток байтов
приведет к сорвершенно разным числам!!!!


взвращаемся к нашму исходному вопроус. 
слово 
Vasya
на экране 
оно в формате LE или BE?

экран этоноситель информации. у него самая левая позиция это младщий офсет.
а самая правая позиция это самй старшийофсет.

теперь проблема в то что слово это не число. окей. замним васю на число 1234

1234

пусьт у нас каждую цифру на экране задает один байт. тогда у нас посдеодтельность из 
 четырех байтов. причем байт "1" он самй старщий для этого числа а байт "4" он самвй 
 младщий для этого числа. тогда что мы видим в саомй левой позиции которая для носитселя
 инфомрации "экран" имеет самый маленкий офссет в ней запиан самый старший байт "1"
 тогда получается число 1234 записано на наш носиель информации экран в формате BE

 поулчтся и на бумаге (как носителе информации) людт пишут числа в формате BE - вначале строки мы запиывем старщий бацты числа а в коце младщий. я бы сказал что мы записываем числа сзада на перед тоечть если бы это была лошадь то мы ее на бумае ставим вот так

 (голова)--(тело)--(хвост)

 возвращемся к слову. как опрделить для слова какой байт у него старший 
 а какой младщий. ...  я бы сказал что та буква которую мы читаем первую она старшая потому что она имеет самое болшое значение по ссмыслу. а та буквы которую мы читаем поледнй
 это младщий байт потому что он имеет самое мелкое значение. пример.

 слова "чаша" и слово "маша"
 мы поменли первую букву и у нас кардинально ихменился смысла 
 и слова "мама" и "мамаы" мы поменяли последнюю букву но обьект остался тотже.
 поэтому получется что написание слов на бумаге у нас идет тоже в формате BE

 ЧАША  

 слева у нас самый младщий офсет нашего носителя информации ( бумага или экран) а мы в него
 суем букву (байт) самый старший

 получаетс на комп экране и на бумаге люди запиывают числа и слова в формате BE.
 удвительно.

а теперь самое интереное. - берем слово "lost+found"
заменяем каждую букву в той же позиции на hex байт acii. получаем
lost+found = \x6c \x6f \x73 \x74 \x2b \x66 \x6f \x75 \x6e \x64
 у нас получилось мультибайтовое число.  в нотации BE

а теперь посмотрим в какой формате BE или LE сохранятея это число в дата блоках иноды
директори entry


выше я приводил полный ентри их хексдампа. 

0b 00 00 00 | 14 00 | 0a |  02 |  6c 6f 73 74 2b 66 6f 75  6e 64 | 00 00

здесь байт который левее имеет меньший офсет а байт котоырй правее больший офсет.
так вот имя здесь закодировано байтами 


(младщий офссет)|  6c 6f 73 74 2b 66 6f 75  6e 64 |(старший офсет)

сравиваем с нашим исходным числом
lost+found(в формате BE) = (младший офсет)\x6c \x6f \x73 \x74 \x2b \x66 \x6f \x75 \x6e \x64 (старший офсет)
из чего я делаю вывод что имя файла в дата блоках entry сохраняется в формате BE

на практике это означает то что вот как на бумаге мы пишем название
"во саду ли в огороде бегала собачка" то в таком же формате сохраняются буквы
в entry. при условии что каждая буква  кодируется ровно через один байт.
если же у нас буква будет кодироватьс через 2 байта или 3 байта. то тогда последовательость
букв будет тоже кодирорваться через BE формат. я это нижу покажу
проверим:

# mkdir 03
root@vm1:/mnt/2# stat 03
  File: 03
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: 705h/1797d  Inode: 16385       Links: 2

# touch $(echo -e "\xE2\x98\xA0").txt

# ls -1a
.
..
☠.txt


# debugfs -R "cat <16385>" /mnt/2G.txt | hexyl
debugfs 1.46.5 (30-Dec-2021)
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 01 40 00 00 0c 00 01 02 ┊ 2e 00 00 00 02 00 00 00 │•@00_0••┊.000•000│
│00000010│ 0c 00 02 02 2e 2e 00 00 ┊ 10 00 00 00 dc 0f 07 01 │_0••..00┊•000×•••│
│00000020│ e2 98 a0 2e 74 78 74 00 ┊ 00 00 00 00 00 00 00 00 │×××.txt0┊00000000│
│00000030│ 00 00 00 00 00 00 00 00 ┊ 00 00 00 00 00 00 00 00 │00000000┊00000000│
│*       │                         ┊                         │        ┊        │
│00000ff0│ 00 00 00 00 00 00 00 00 ┊ 0c 00 00 de a6 25 59 f9 │00000000┊_00××%Y×│
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

по идее первые два ентри это "." и ".." их мы сразу пропускаем.
это значит первые 24 байты мы пропускаем

dc 0f (длина третьего ентри . литл ендиан) = of dc = 4060 байт

получается  ентри это 

10 00 00 00| dc 0f| 07| 01 | e2 98 a0 2e 74 78 74 00 ┊ 00 00 00 00 00 00 00 00 
 00 00 00 00 00 00 00 00 ┊ 00 00 00 00 00 00 00 00 
...
00 00 00 00 00 00 00 00 ┊ 


номер иноды 10 00 00 00 = 10 = 16

проверяем

# ls -i
16 ☠.txt

действиельно 16

dc 0f (длина третьего ентри . литл ендиан) = of dc = 4060 байт

07 = длинна имени 
01 = типа файла (regular file)  = да все правилно

имя файла (7 байт как уже выснсили ) = e2 98 a0 2e 74 78 74

сравнивем с нашими исхоными байтами = touch $(echo -e "\xE2\x98\xA0").txt
.txt = это 2E 74 78 74 значит наш исхоный набор бтайтов это 

# touch $(echo -e "\xE2\x98\xA0\x2E\x74\x78\x74")
проверим на экране
echo -e "\xE2\x98\xA0\x2E\x74\x78\x74"
☠.txt
да все верно значит наш исхоный набор байтов это 
(младщрй офсет) "\xE2\x98\xA0\x2E\x74\x78\x74" (старший офсет)
а этот же набор байтов вунтри дата блока 
(младщий офсет )  e2 98 a0 2e 74 78 74 (старший офсет)
как видно они полностью совпдают.

так берем вот этот символ
 DEX     Unicode    Utf-8 hex    symbol
11136   U+2B80       E2 AE 80       ⮀   

значит E2 AE 80 это hex запись в формате BE это 100%
слева у нас офссет самый мелкий а байт самый старщий. так чтоэто BE формат

печатаем на экране

$ echo -e "\xE2\xAE\x81"
⮁

кстаии в команде echo "...."
левая позиция это малый офсет. а правая позиция это старщий офсет.
согласно офссету символы и послыются в ядро. 
получатеся что в команде echo мы записали наше число в формате записи BE.
потому что на бумаге наше число выглядит как E2 AE 80  где слева старший байт
а офссет младщий. и в комаде echo слева младщий офссет а байт записан у нас старший

проверим что в ентри имя файла сохранено тоже в BE.

# touch $(echo -e "\xE2\xAE\x81")
root@vm1:/mnt/2/03# ls -1a
.
..
☠.txt
⮁

снимаем хекс дамп дата блока овесвтенного за иноду для этой папки

посмтрим как все поменялос


# debugfs -R "cat <16385>" /mnt/2G.txt | hexyl
debugfs 1.46.5 (30-Dec-2021)
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 01 40 00 00 0c 00 01 02 ┊ 2e 00 00 00 02 00 00 00 │•@00_0••┊.000•000│
│00000010│ 0c 00 02 02 2e 2e 00 00 ┊ 10 00 00 00 10 00 07 01 │_0••..00┊•000•0••│
│00000020│ e2 98 a0 2e 74 78 74 00 ┊ 11 00 00 00 cc 0f 03 01 │×××.txt0┊•000×•••│
│00000030│ e2 ae 81 00 00 00 00 00 ┊ 00 00 00 00 00 00 00 00 │×××00000┊00000000│
│00000040│ 00 00 00 00 00 00 00 00 ┊ 00 00 00 00 00 00 00 00 │00000000┊00000000│
│*       │                         ┊                         │        ┊        │
│00000ff0│ 00 00 00 00 00 00 00 00 ┊ 0c 00 00 de 17 d6 ec 51 │00000000┊_00×•××Q│
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘
первые 24 байта пропускаем. там указаны "." и ".." entry


берем следущий  6 байт

10 00 00 00 |10 00 
здесь первые 4 байта это номер индоы на которую ссылается етри.
а два следщих байта 10 00  это длина ентри LE = 10  = 16 байт.
значит енти выглядит как

10 00 00 00 | 10 00 | 07 |01 | e2 98 a0 2e 74 78 74 | 00

это уже знакомый нам ☠.txt
заметим что так как ентри этот у нас не последний то  у него была заменена длина ентри.


берем следущий 6 байт

11 00 00 00 | cc 0f | 03 

длоина ентри = cc 0F (LE) = 0F cc = 4044 байт
ну понятно . поледний ентри всегда имеет сумашедшую длину до конца ФС блока.

03 = длина названия файла .  

значит ентри выгдяит как

11 00 00 00 |  cc 0f | 03 | 01 |  e2 ae 81 | 00 ........ 00

11 00 00 00 LE = 11 hex = 17 номер иноды 
cc 0f  = понятно
03 = длина имени файла
01= тип файла = обычный
e2 ae 81  = имя файла

сравнаием набой боайтов в имени файла и в исходной числе


исходное число (запись на бумаге) E2 AE 80   (BE)
это же число в команде echo  # touch $(echo -e "\xE2\xAE\x81") (BE)
это же число в дата блоке  e2 ae 81

посколтку в дата блоке (меньший офсет ) e2 ae 81 (больший оффсет)
а на бумаге (меньший оффсет) E2 AE 80 (большрй офссет)

то яделаю вывод что в дата блоке имя файла пропиывается на основе правила BE (Big Endian)
это важно поимать. потмо что остальные структуры в ext4 запмватся обычно в LE.
только структуры журнала запиываются в BE.

ктаи проверим что номер ироды на которую ссылается хардлинк мы правилльно дешифровали

# ls -1i
16 ☠.txt
17 ⮁

получатсяда правилно. 17-я инода

получается что ентри в дата блоке для файла от иноды папки состоит из 

4 байта номер иноды + 2 байта длина ентри + 1 байт длина имени файла  + 1 байт тип файла +
до 255 байт имя файла 

также интеересно что в иноде пропиывается какой у нее тип.
# debugfs -R "stat <16385>" /mnt/2G.txt
Inode: 16385   Type: directory    Mode:  0755   Flags: 0x80000
Generation: 645041793    Version: 0x00000000:00000003
User:     0   Group:     0   Project:     0   Size: 4096
File ACL: 0
Links: 2   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ae080c:739c0b2c -- Wed Jul 12 01:55:24 2023
 atime: 0x64ae0811:748f2f68 -- Wed Jul 12 01:55:29 2023
 mtime: 0x64ae080c:739c0b2c -- Wed Jul 12 01:55:24 2023
crtime: 0x64ae012b:50bd2750 -- Wed Jul 12 01:26:03 2023
Size of extra inode fields: 32
Inode checksum: 0x21b424fa
EXTENTS:
(0):8232

инода отвечающая за папку имеет Type: directory
иноа отвчающая за файл имеет    Type: regular

Inode: 17   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 3351427405    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 0
File ACL: 0
Links: 1   Blockcount: 0
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ae080c:74902ef8 -- Wed Jul 12 01:55:24 2023
 atime: 0x64ae080c:74902ef8 -- Wed Jul 12 01:55:24 2023
 mtime: 0x64ae080c:74902ef8 -- Wed Jul 12 01:55:24 2023
crtime: 0x64ae080c:739c0b2c -- Wed Jul 12 01:55:24 2023
Size of extra inode fields: 32
Inode checksum: 0xd7b0b7e5
EXTENTS:
(END)


интересно

обратим внимание еще раз на поля

Links: 2   Blockcount: 8

блоккаунт надо умножиь на 512 и мы узнаем солко байт на диске реально занимает
нет не инода (инода занимает 256 байт) а скоько занимет файл! файл а не инода. 
8*512\4096 = 1 блок ФС
если инода у нас отвечает за директори. это это значит что тело дата блоков где 
хранятся интри загимает 1 фс блок. понятно что 1 блок это минимум. если ентри будет
много то и блоков будет много.  можно примерно прикинуть сколько нужно иметь 
в папке файлов скажем каждый по 8 байт длинной имя чтобы они заняли весь блок.

длина ентри будет 4 байта (адрес иноды ) + 2 байта длина ентри + 1 байт длина имени
 +1 байт тип файла  + 8 байт длина имени = 4+2+1+1+8 = 16 байт.
+24 байта это на ("." и "..") = 40 байт . получается где то 253 entry для  файла
займут уже весь 4К фс блок. 

links для иноды котоая отвечает за папку обозначает сколько хардлинков ведет на эту папку.
каждый хардлинк . хардлинки могут все лежать в одной папке а могут в разных.

надо понимать еще что links это скорее показатель не иноды самой а скорее показетель
насколко много из других мест ссылаются на эту иноду. наколько много entry есть 
в датаблоках других инод отвечающих за другие папки которые ссылают я н аэту иноду.
хотя можно и в этой же папке нашарашить кучу хардлинков которые ведут в эту же иноду.
нет проблем.

получается елси мы удаляем хардлинк - то его надо вычистть из дата блока какойто иноды 
(когда я говорю дата блок иоды я неимею ввиду что эти блоки хранятся в теле иноды которая лежит в таблице инодов . нет. дата блоки иноды лежат вне тела иноды. вне тела таблицы инодов. дата блоки на котоыре сслыается инода лежат там же где тела все файлов. тоесть в "дата блоках" которые располагаются вне зоны метаданных у группы блоков. ).
при вычищении ентри из дата блока скорей всего надо считать дата блок. убрать из него ентри. 
и наскоко я понимаю сдвинуь остальыные ентри внутри блока ФС, и поменять длину ентри
для последего ентри в блоке. кроме того надо зайти в иноду на которую ссылался хардлинк
и уменьшить там параметр links. перечитать crc суммы для иноды в коорой был хардлинк прописан. для иноды на которую хардлинк ссылался. если хардлинк был едиснвтеным то нужно
занулить иноду на котру он сслыался. пересчитать контрльные суммы. изментить в метаданыех
параметр что столько то блоков освободилось в группе блоков. опять переачитать контрльные суммы. в общем порядочно работы для фс при удалении хардльинка.

наскоько я понял еси у ext4 не активрована приформатировании фича "filetype"
то entry будет такой же самй по формату толкьо у него не будет поля размером 1байт
обозначающего типа файла. 

 я кстати нашел то что padding у entry такой что он дллжен быть кратным 4 байтам.
 ну что это удобно

 далее кситати нашел подвтерждение про поледний ентри. что он дожен быть до самого
 конца блока Фс = The last entry consumes all the block, that is why the record length is more than we normally expect

 я и говор полчаетс что когда дата болок модифициурется. например мы удаляем entry
 то нужно для последнего ентри пересчятывать его длину.

кстати. если число ентри в папке преывшает както число то ext4 меняет структуру записи
ентри в блоках иноды отвечающей за папку. вместо линейного списка ентри формат сохранениея
меняется на tree. подроности пока непонятны.
суть примерно вот в чем - вот мы хотим прочитать файл который лежит в папке 
в которой дрхрена файлов. как унас работает чтение файла - в команде мы укызваем папку
из которой мы хотим  прочитать файл и его имя. драйвер отркывает иноду <2> которая отвечает
за корневой раздел. и начинает читать его ентри в дата блоках. находит название
папки и ссылку на иноду той папки. переходит в ту иноду и начинает читаь ентри в той папке
таким макаром драйвер фс доходит до папки в которой лежит файл , отркывает дата блоки в которых начинает чиаттать ентри. находит ентри в котором указано имя файла указанное в
закаанном имени файла и находит наконец какая инода отвечает за файл. 
так вот проблема в том что если в папке мрного файлов то поиск нашего файла внутри 
папки среди ентри будет занимать очень много время если мы будем тупо перебирать сверху
вниз все ентри. тут на помощь приходит дерево.  дерево работает примерно так -
у нас есть 33 буквы. мы имеет 33 входа. каждый вход обозначает отделную букву.
нижележащий слой имеет тоже 33 разветвлеения и так далее. таким макаром мы движемся
по дереву и быстро находим файл по имени.  хэш трии тоюе саоме только там не буквы
участвуют а хэши. вычичляется хэщ от имени файла и далее мы скачем по дереву
отфильтроватвыая по каждой букве и цифре в имени хэша.

детали неизвестны. 
но можно через дебагфс посмотреть кое что про папку в котой заюзан метод записи 
ентри через дерево:

debugfs
> htree <2>
Root node dump:
         Reserved zero: 0
         Hash Version: 1
         Info length: 8
         Indirect levels: 0
         Flags: 0
Number of entries (count): 486
Number of entries (limit): 507
Checksum: 0xd92454df
Entry #0: Hash 0x00000000, block 1
Entry #1: Hash 0x00aa4d38, block 235
Entry #2: Hash 0x0118d100, block 463
Entry #3: Hash 0x017e74b2, block 112
Entry #4: Hash 0x022f3902, block 231
Entry #5: Hash 0x02ba5bdc, block 455
Entry #6: Hash 0x03138042, block 60
Entry #7: Hash 0x0391d84c, block 449

видно как идет упорядоченный хэш список. возможно это вариант деерева плоского.
что это чисто упорядоченный список на оснвое хэша
наскокьо я понимаю если мы добавляем новый ентри в такую папку
то новый ентри добавляется не в конец а в строго определенное место.
пока на этом все по этмоу поводу



кстати создать новый файл можно через

$ > 1.txt

далее. 
раздел в иноде в котором пропиывается в каких блоках хранится тело файла называется
i_block 


двигаем дальге. если унас актифрованва фича "extents" то инода указывает не на дата
блоки фс а на экстенты. они хрантся в виде дерева. у этого дерева может быть 
5 уровней вложенностии и на кажом уровне может быт как  я понял 2^16 разветвлений.


про экстенты. 

> debugfs:  dump_extents  <21>
Level Entries      Logical        Physical          Length   Flags
 0/ 0   1/  1      0 - 25599      98306 - 123905    25600    Uninit
(END)





неочень понимаю как они физ там прописываются в иноде. но по факту
команда dump_extents покажет список блоков ФС. 

кстати запись 
Flags
Uninit

означает что блоки преаллоцированы на уровне метаданных. тоесть в таблице блоков
они укзааны. с точки зрения ФС они заняты. но в них при этом небыло ничего записано.
блоки allocated но не initialized.

вот еще пример из статьи шевейцарца

$ sudo debugfs -R "dump_extents <13>" /dev/sda1

Level Entries           Logical          Physical Length Flags
0/ 1   1/  1       0 - 2621439   33724           2621440
1/ 1   1/ 92       0 -   30719   34816 -   65535  30720 Uninit
1/ 1   2/ 92   30720 -   61439   65536 -   96255  30720 Uninit
...
...
...
1/ 1  92/ 92 2592768 - 2621439 2840576 - 2869247  28672 Uninit



Level показывает сколько уровней (depth) есть у дерева. 
уэтого дерева два левела.




это можено еще проверить проверить через

> blocks <21>

покажет блоки. причем тем же самые.



а вот кусок дампа эестентов другого файла
Level Entries     Logical         Physical              Length      Flags
 0/ 1   1/  4     0 - 2047        33854                 2048
 0/ 1   2/  4     2048 - 9545727  605451                9543680
 
 1/ 1   1/  2     0 - 0           610304 - 610304       1 
 1/ 1   2/  2     1 - 2047        610305 - 612351       2047        Uninit
 
 1/ 1   1/339     2048 - 8191     616448 - 622591       6144        Uninit

неочен опнятно пока. по какому прицнипу он группирует строки
понтяно что укзааны куски непрерывных блоков.
непонятно почему логический оффсет (адрес внутри файла) повторяется
почему лоагический адрес повтояерсят?


пока отложим и посмотрим еще пример

это экстенты для файла 300М размером

Level Entries       Logical        Physical     Length      Flags
 0/ 0   1/  4     0 - 30719 131072 - 161791     30720       Uninit
 0/ 0   2/  4 30720 - 32767 161792 - 163839     2048        Uninit
 0/ 0   3/  4 32768 - 63487 165888 - 196607     30720       Uninit
 0/ 0   4/  4 63488 - 76799 196608 - 209919     13312       Uninit




листинг 500М

Level Entries         Logical                Physical Length Flags
 0/ 1   1/  1      0 - 127999   20938097              128000

 1/ 1   1/  5      0 -  30719   21176320 -   21207039  30720 Uninit
 1/ 1   2/  5  30720 -  61439   21207040 -   21237759  30720 Uninit
 1/ 1   3/  5  61440 -  92159   21237760 -   21268479  30720 Uninit
 1/ 1   4/  5  92160 - 122879   21268480 -   21299199  30720 Uninit
 1/ 1   5/  5 122880 - 127999   21299200 -   21304319   5120 Uninit
(END)




листинг экснтентов для файла 600М
> debugfs -R "dump_extents <12>" /mnt/10T.txt

Level | Entries |  Logical         |          Physical              |      Length |    Flags
 0/ 1 |  1/  1  |    0 - 153599    |          21168128              |      153600 |
 1/ 1 |  1/  5  |    0 -  30719    |          21305344 -   21336063 |      30720  |    Uninit
 1/ 1 |  2/  5  | 30720 -  61439   |          21336064 -   21366783 |      30720  |    Uninit
 1/ 1 |  3/  5  | 61440 -  92159   |          21366784 -   21397503 |      30720  |    Uninit
 1/ 1 |  4/  5  | 92160 - 122879   |          21397504 -   21428223 |      30720  |    Uninit
 1/ 1 |  5/  5  | 122880 - 153599  |          21428224 -   21458943 |      30720  |    Uninit


> debugfs -R "blocks <12>" /mnt/10T.txt
блоки этого файла
21168128 21305344 21305345 21305346 21305347 21305348 21305349 21305350 21305351 21305352 21305353 21305354 21305355...

значит мы видим чтото странное - колонка "Logical" показыает какой оффсет внутри файла
закодирован через колонку "Physical" в блоках на диске. так вот мы видим странное
то что у нас есть продублированные офссеты. тоесть в первой строке 
указан оффсет 
  Logical
 0 - 153599

а потом остальные 5 строк описывают опять эти же оффсеты
  Logical
 0 -  30719
30720 -  61439
61440 -  92159
92160 - 122879
122880 - 153599


что за прикол? а прикол как я понял (проверив через эксперимент) состоит в том что 
если у нас на бекенде используются блоки то там каждый блок содержит именно тело файла.
так вот походу когда у нас на бекенде используются экстенты то там не каждый блок
хранит тело файла а видимо ряд блоков хранит некие опять же метаданные видимо описывающие 
само устройство дерево эксентов.


так вот я сделал запись в этот файл
# printf '\x31\x32\x33' | dd of=/mnt/ext4/600M.txt  bs=1 count=3 conv=notrunc 
(я записал 123 в голову этого файла)

далее  я начал искать в каком же блоке  ФС хранится этот контент?

я посмтрел содержимое первго блока ФС указанно в таблице экстентов
# dd if=/mnt/10T.txt  bs=4K count=1 skip=21168128
на экране получил мусор

пррверил второй блок ФС указаный в таблице экстентов
# dd if=/mnt/10T.txt  bs=4K count=1 skip=21305344
123

(на счет skip пояснение. эта хрень которая позволяет пропусть блоки в файле
источнике. так вот если указано skip=10 то это значит что надо прпустить 10 блоков
из файла источника . так как блоки нумеруются с 0. то если мы укажем skip=10 то 
значит будут пропущены блоки 0...9 всумме это 10 штук значит чтение будет начато с блока
с номером 10. тоесть  если мы хотим чтобы в исходном файле чтение началось с блока 
 с номером N то значит нужно указать skip=N )


тоесть из эксперимента стало видно что в блоке 21168128 нужного нам контента "123"
неоказалось хотя я записвал эту инфо в самую голову файла а оказался этот контент
во втором по счету блоке ФС указанном в таблице экстентов.

из чего я делаю вывод что когда мы видим стремную таблицу экстентов где оффсеты
одни и теже указыватся несколько раз это значит что в части экстентов хранится тело
файла а в части эксентов хранится метаинформация об строении дерева экстентов

взгляенм еще раз на эту табицу эксентов
Level | Entries |  Logical         |          Physical              |      Length |    Flags
 0/ 1 |  1/  1  |    0 - 153599    |          21168128              |      153600 |
 1/ 1 |  1/  5  |    0 -  30719    |          21305344 -   21336063 |      30720  |    Uninit
 1/ 1 |  2/  5  | 30720 -  61439   |          21336064 -   21366783 |      30720  |    Uninit
 1/ 1 |  3/  5  | 61440 -  92159   |          21366784 -   21397503 |      30720  |    Uninit
 1/ 1 |  4/  5  | 92160 - 122879   |          21397504 -   21428223 |      30720  |    Uninit
 1/ 1 |  5/  5  | 122880 - 153599  |          21428224 -   21458943 |      30720  |    Uninit


 это типа дерево. у него есть Level=0 и Level=1
Level =0 это 

Level | Entries |  Logical         |          Physical              |      Length |    Flags
 0/ 1 |  1/  1  |    0 - 153599    |          21168128              |      153600 |

а level=1 это 

Level | Entries |  Logical         |          Physical              |      Length |    Flags
 1/ 1 |  1/  5  |    0 -  30719    |          21305344 -   21336063 |      30720  |    Uninit
 1/ 1 |  2/  5  | 30720 -  61439   |          21336064 -   21366783 |      30720  |    Uninit
 1/ 1 |  3/  5  | 61440 -  92159   |          21366784 -   21397503 |      30720  |    Uninit
 1/ 1 |  4/  5  | 92160 - 122879   |          21397504 -   21428223 |      30720  |    Uninit
 1/ 1 |  5/  5  | 122880 - 153599  |          21428224 -   21458943 |      30720  |    Uninit

насколко я понимаю тут схема такая же как в случае индирект блоков. в level0
хранится маппинг (ссылки) на level1 но не тело файла. как  я думаю в level0 в фс блоке 21168128 хранится инфо вида = что оффсет "0 -  30719" файла хранится в левел1 дерева
в его entry1. а оффсет файла  "30720 -  61439" файла хранится в левел1 дерева в  его
entry2.  ну а в level1 entre1 написано в каких блоках фс хранится тело "21305344 -   2133606"
итак далее.

полчается в level0 , entry1 хранистя метаинфо о том как устроен level1 его ентри. и уже 
в тех ентри хранится тело файла!


щас я это проверю создам файл у которого екстенты сидят в дерево с одним левелом
# debugfs -R "dump_extents  <14>" /mnt/10T.txt
Level Entries       Logical                Physical Length Flags
 0/ 0   1/  3     0 - 30719   21458944 -   21489663  30720 Uninit
 0/ 0   2/  3 30720 - 61439   21489664 -   21520383  30720 Uninit
 0/ 0   3/  3 61440 - 76799   21520384 -   21535743  15360 Uninit

запишем "123" в офссет 0 файла. и потом ожидаю я его прочитать в первом дата блоке 21458944
указанном в таблице эксентов

# printf '\x31\x32\x33' | dd of=/mnt/ext4/300M.txt  bs=1 count=3 conv=notrunc

# dd if=/mnt/10T.txt   bs=4K count=1 skip=21458944
123

все верно! все верно  рассчитано.

получается у нас если экстенты имеет дерево с одним уровнем глубины (только level=0)
то да все блоки хранят только тело файла. 

а вот если эксенты хрантся в дереве с двумя уровняди глубины (level0 и level1)
то level0 хранит информцию о самом устройстве дерева а только level1 хранит тело файла.


также хочу сказат что значит conv=notrunc в крманде dd. если мы пишем файл и мы 
неуказем эту опцию то перед тем как туда чтото писаь то весь файл будет стерт. в том смысле
что прям размер файла станет равен нулю прям на диске! 
а с этим  флагом предварительного стирания нет.

и это мне дает новый способ как можно уменьшить размер файла при условии что файл 
открыт другим процессом. это с помощью dd пуолчаетс что если мы пишем через dd в файл
и неисполуем флаг conv=notrunc то dd уберет все дата блоки у файла и он начнет мгновенно 
занимать на диске ноль байт. я проверил работает

я взял файл

# stat /mnt/ext4/01.txt 
  File: /mnt/ext4/01.txt
  Size: 15015       Blocks: 32         IO Block: 4096   regular file
Device: 706h/1798d  Inode: 15          Links: 1

он заимает 32*512 байт на диске .  яоткрыл его на чтение. 

адалее я натрваил на этот файл dd

# echo "1" | dd of=/mnt/ext4/01.txt bs=1 count=1

и проверил сколко стал занимать на диске

# stat /mnt/ext4/01.txt 
  File: /mnt/ext4/01.txt
  Size: 1           Blocks: 8          IO Block: 4096   regular file
Device: 706h/1798d  Inode: 15          Links: 1

файл стал занимать 8*512 байт.
при условии что тот наш процесс все это время держит этот файл открытым.
так что dd пощволяет уменьшить размер файла на диске вместо truncate.
очень хорошо.



я взял еще один пример . взял большой файл. и вот какая у него схема
дерева для экстентов. я его покажу по частям
 в

Level Entries             Logical              Physical Length Flags
 0/ 1   1/  4        0 -     2047     33854               2048
 1/ 1   1/  2        0 -        0    610304 -    610304      1 
 1/ 1   2/  2        1 -     2047    610305 -    612351   2047 Uninit


видно что дерео имеет два словая глубины. левел0 и левел1. 
причем левел0 имеет 4 ентри. в данном куске показан левел0 ентри1 в нем очеивдно
хранится инфо о структуре дерева в левел1 в его двух ентри 1 и 2 в которых уже 
и хранится тело файла (оффсет 0 - 2047)




 0/ 1   2/  4     2048 -  9545727    605451             9543680
 1/ 1   1/339     2048 -     8191    616448 -    622591   6144 Uninit
 1/ 1   2/339     8192 -    24575    630784 -    647167  16384 Uninit
 ...
 1/ 1 338/339  9484288 -  9515007  14716928 -  14747647  30720 Uninit
 1/ 1 339/339  9515008 -  9545727  14747648 -  14778367  30720 Uninit

в этом куске показан еше один ентри2 в левел0 в котором указана инфо о левел1 
и его ентри 1-339 в котором уже лежит тело файла. (оффсет файла 2048 - 9545727)


 0/ 1   3/  4  9545728 - 19816447  14780416             10270720
 1/ 1   1/340  9545728 -  9547775  14778368 -  14780415   2048 Uninit
 ...
 1/ 1 340/340 19785728 - 19816447  25815040 -  25845759  30720 Uninit

третий кусок. опять же видим левел0 ентри3 в коором хранися метаинфомрация о левел1
и его ентри 1-340 в которм уже хранится тело файла (офсет 9545728 - 19816447)


 0/ 1   4/  4 19816448 - 26214399  25847808             6397952
 1/ 1   1/210 19816448 - 19818495  25845760 -  25847807   2048 Uninit
 1/ 1   2/210 19818496 - 19849215  25849856 -  25880575  30720 Uninit
 ...
 1/ 1 209/210 26173440 - 26204159  32630784 -  32661503  30720 Uninit
 1/ 1 210/210 26204160 - 26214399  32661504 -  32671743  10240 Uninit


четвертый кусок. аналогично

получается левел0 имеет 4 ентри. котоырй хранит стрктуруту левел1 в которм
уже хранится тело файла.

понятно что в каждом куске ентри повторяются левел1 повторяются. но это не потомучто 
это одни и теже. нет. это индивиудьные ентри относящиеся к своему куску в левел0.

вобщем напомню дерево экстентов может иметь глубину 5.
еще скажу что в тблице экснетонов мы видим не экстенты мы видим сразу блоки ФС.
что конечно очень удобно. 

а где же в таблице увидить экстент. экстент это строчка. в которой указан непрервынй
блок фс блоков.

тоесть скжаем экстент это вот это
Level Entries             Logical              Physical Length Flags
1/ 1 209/210 26173440 - 26204159  32630784 -  32661503  30720 Uninit

и этот экстент всебе содержит непрывный кусок блоков фс 32630784 -  32661503


кстати вот один из кусков какова струаткрура экстента

struct ext4_extent_idx {
   97     __le32  ei_block;   /* index covers logical blocks from 'block' */
   98     __le32  ei_leaf_lo; /* pointer to the physical block of the next *
   99                  * level. leaf or next index could be there */
  100     __le16  ei_leaf_hi; /* high 16 bits of physical block */
  101     __u16   ei_unused;
  102 };

в статье швейцарца ятоже нашел подтвержение что если у нас глубина дерева равна 2 (левел0 и левел1) то в левел0 хранится метаданные о деревер. а уже в левел1 хрантся дата блоки тела фс
цитирую

Now we have a tree of depth=2 (level 0 and level 1). Level 0 is the indirect addressing page, then there are 92 pages with addresses of blocks.


значит я хочу посморть иноду для файла 600M.txt
тот который я выше рассмтривал таблицу эестентов

> debugfs -R "dump_extents <12>" /mnt/10T.txt

Level | Entries |  Logical         |          Physical              |      Length |    Flags
 0/ 1 |  1/  1  |    0 - 153599    |          21168128              |      153600 |
 1/ 1 |  1/  5  |    0 -  30719    |          21305344 -   21336063 |      30720  |    Uninit
 1/ 1 |  2/  5  | 30720 -  61439   |          21336064 -   21366783 |      30720  |    Uninit
 1/ 1 |  3/  5  | 61440 -  92159   |          21366784 -   21397503 |      30720  |    Uninit
 1/ 1 |  4/  5  | 92160 - 122879   |          21397504 -   21428223 |      30720  |    Uninit
 1/ 1 |  5/  5  | 122880 - 153599  |          21428224 -   21458943 |      30720  |    Uninit


так вот я хочу для этого файла посмтреть его иноду .ее дамп

есть замечательная комада которая позвляет узнать где лежит инода 

debugfs:  imap <12>
Inode 12 is part of block group 0
    located at block 165091, offset 0x0b00
debugfs:  

это блок 165091


# debugfs /mnt/10T.txt  -R "block_dump  165091" | dd bs=1 skip=2816 count=256 | hexyl
debugfs 1.46.5 (30-Dec-2021)
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 20 30 30 30 30 20 20 2e ┊ 2e 2e 2e 2e 2e 2e 2e 2e │ 0000  .┊........│
│00000010│ 2e 2e 2e 2e 2e 2e 2e 0a ┊ 2a 0a 35 31 36 30 20 20 │......._┊*_5160  │
│00000020│ 30 30 30 30 20 30 30 30 ┊ 30 20 30 30 30 30 20 30 │0000 000┊0 0000 0│
│00000030│ 30 30 30 20 30 30 30 30 ┊ 20 30 30 30 30 20 30 63 │000 0000┊ 0000 0c│
│00000040│ 33 64 20 30 30 30 30 20 ┊ 20 2e 2e 2e 2e 2e 2e 2e │3d 0000 ┊ .......│
│00000050│ 2e 2e 2e 2e 2e 2e 3d 2e ┊ 2e 0a 35 32 30 30 20 20 │......=.┊._5200  │
│00000060│ 32 30 30 30 20 36 64 64 ┊ 62 20 30 30 30 30 20 30 │2000 6dd┊b 0000 0│
│00000070│ 30 30 30 20 30 30 30 30 ┊ 20 30 30 30 30 20 30 30 │000 0000┊ 0000 00│
│00000080│ 30 30 20 30 30 30 30 20 ┊ 20 20 2e 6d 2e 2e 2e 2e │00 0000 ┊  .m....│
│00000090│ 2e 2e 2e 2e 2e 2e 2e 2e ┊ 2e 0a 35 32 32 30 20 20 │........┊._5220  │
│000000a0│ 36 31 32 65 20 61 62 36 ┊ 34 20 30 30 30 30 20 30 │612e ab6┊4 0000 0│
│000000b0│ 30 30 30 20 30 30 30 30 ┊ 20 30 30 30 30 20 30 30 │000 0000┊ 0000 00│
│000000c0│ 30 30 20 30 30 30 30 20 ┊ 20 61 2e 2e 64 2e 2e 2e │00 0000 ┊ a..d...│
│000000d0│ 2e 2e 2e 2e 2e 2e 2e 2e ┊ 2e 0a 35 32 34 30 20 20 │........┊._5240  │
│000000e0│ 30 30 30 30 20 30 30 30 ┊ 30 20 30 30 30 30 20 30 │0000 000┊0 0000 0│
│000000f0│ 30 30 30 20 30 30 30 30 ┊ 20 30 30 30 30 20 30 30 │000 0000┊ 0000 00│
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

но тут я понял что в ex4 уже нет (как я понимаю ) вот этого блока как было на ext3
вот эти 15 ентри  которые указывали там на блоки. на ext4 ссылка на экстенты 
более хитро закодирована.  как я непонял. поэтому как это посмотерть в иноде 
непонятно пока.

с экстентами пока что все.

далее.
погвооим про симлинки.
для начала поговорим про хардлинки.
когда создается файл то занимаается инода которая будет хранить метаднные файла и в ней
сохранятес список блоков ФС или список экстентов фс и в которых записыется тело файла 
и на последнем этапе созздактся хардлинк тоесть ентри в дата блоках другой иноды той иноды
которая отвечает за папку . и в свойствах иноды отвечающей за файл пррпсывается что колчетсво "Links" =1. если мы еще один хардлинк создем через # ln новоея_имя старое_имя то всего навсего создается +1 ентри в датаблоках иноды отвечающей за папку и в иноде отвечающей
за файл увелчивается поле "Links" на +1


я хочу найти где и как на диске в файле симлинке хранится запись на файл на который
он ссылается.
вначале я вернусь и начну с рассмаотрения классического файла.

рассматриваю ext3 потому что она неюзает экстенты. поэтому нам будет просто
найти руками дата блоки которые юзает файл.

беру регуляр файл
# cat 45.txt 
443534

# stat 45.txt 
  File: 45.txt
  Size: 7           Blocks: 8          IO Block: 4096   regular file
Device: 707h/1799d  Inode: 30          Links: 1

значит номер иноды=30
тип файл = регуляр


debugfs:  dump_extents <30>
<30>: does not uses extent block maps
ага инода не юзает экстенты

найдем в каких блоках сидит тело файла

# debugfs /mnt/5G-ext3.txt
debugfs:  blocks <30>
17408 


посмотрим что в этом блоке

debugfs:  block_dump 17408
0000  3434 3335 3334 0a00 0000 0000 0000 0000  443534..........
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

видим что действтельно 443534 сидит в этом блоке

таким образом мы найшли номер ноды. по ее номеру нашли дата блок в котором сидит
тело файла и посмотрели дамп этого файла и нашли что да там и сидит 443534 контент.

тепрь зайдем немного с другой стороны. посмотрим тело иноды и в ней руками 
найдем список дата блоков руками

смотрим дамп тела иноды

debugfs:  inode_dump <30>
0000  a481 0000 0700 0000 3866 b164 7795 ab64  ........8f.dw..d
0020  808b ab64 0000 0000 0000 0100 0800 0000  ...d............
0040  0000 0000 0100 0000 0044 0000 0000 0000  .........D......
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 672c c5c3 0000 0000 0000 0000  ....g,..........
0160  0000 0000 0000 0000 0000 0000 0000 0000  ................
0200  2000 0000 149e ef24 c48a 40de 88b9 6a59   ......$..@...jY
0220  4795 ab64 a43b 2b2b 0000 0000 0000 0000  G..d.;++........
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

а теперь найдем этот дамп даже руками

debugfs:  imap <30>
Inode 30 is part of block group 0
    located at block 5, offset 0x0d00

мы видим блок фс и офссет где сидит тело иноды
тут обращаю внимание на дебильнейший момент у дебагфс. в данном случае оффсет
указан в шестнадцатиричном формате.(а номер датаблока указан в десятичном формате)
а вот щас мы начнем смотреть дамп этого блока и там смешение будет указано в БЛЯДЬ восьме
ричном формате

поэтому нам надо перевести офссет шетнсдацитирного фората в воьсмеричный формат
$ echo "obase=8; ibase=16; 0D00" | bc
6400


смотрим дамп этого фс датаблока и ищем кусок с оффсета 6400

debugfs:  block_dump 5
0000  a481 0000 0000 0000 338d ab64 6c90 ab64  ........3..dl..d
0020  6c90 ab64 6c90 ab64 0000 0000 0000 0000  l..dl..d........
0040  0000 0000 0100 0000 0000 0000 0000 0000  ................
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 aafa 9806 0000 0000 0000 0000  ................
0160  0000 0000 0000 0000 0000 0000 0000 0000  ................
0200  2000 0000 7857 9b55 7857 9b55 6048 64d4   ...xW.UxW.U`Hd.
0220  b58c ab64 7498 7ed9 0000 0000 0000 0000  ...dt.~.........
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
1000  a481 0000 0000 0000 d88d ab64 6c90 ab64  ...........dl..d
1020  6c90 ab64 6c90 ab64 0000 0000 0000 0000  l..dl..d........
1040  0000 0000 0100 0000 0000 0000 0000 0000  ................
1060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
1140  0000 0000 32c0 62ff 0000 0000 0000 0000  ....2.b.........
1160  0000 0000 0000 0000 0000 0000 0000 0000  ................
1200  2000 0000 7857 9b55 7857 9b55 1ccb f781   ...xW.UxW.U....
1220  6c8d ab64 80db 722b 0000 0000 0000 0000  l..d..r+........
1240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
1400  a481 0000 0000 0000 4790 ab64 6c90 ab64  ........G..dl..d
1420  6c90 ab64 6c90 ab64 0000 0000 0000 0000  l..dl..d........
1440  0000 0000 0100 0000 0000 0000 0000 0000  ................
1460  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
1540  0000 0000 95ea 536a 0000 0000 0000 0000  ......Sj........
1560  0000 0000 0000 0000 0000 0000 0000 0000  ................
1600  2000 0000 7857 9b55 7857 9b55 90c5 5cec   ...xW.UxW.U..\.
1620  b28e ab64 fc5f fdc8 0000 0000 0000 0000  ...d._..........
1640  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
6400  a481 0000 0700 0000 3866 b164 7795 ab64  ........8f.dw..d
6420  808b ab64 0000 0000 0000 0100 0800 0000  ...d............
6440  0000 0000 0100 0000 0044 0000 0000 0000  .........D......
6460  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
6540  0000 0000 672c c5c3 0000 0000 0000 0000  ....g,..........
6560  0000 0000 0000 0000 0000 0000 0000 0000  ................
6600  2000 0000 149e ef24 c48a 40de 88b9 6a59   ......$..@...jY
6620  4795 ab64 a43b 2b2b 0000 0000 0000 0000  G..d.;++........
6640  0000 0000 0000 0000 0000 0000 0000 0000  ................
*


и мы находим кусок (оффсет 6400)

6400  a481 0000 0700 0000 3866 b164 7795 ab64  ........8f.dw..d
6420  808b ab64 0000 0000 0000 0100 0800 0000  ...d............
6440  0000 0000 0100 0000 0044 0000 0000 0000  .........D......
6460  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
6540  0000 0000 672c c5c3 0000 0000 0000 0000  ....g,..........
6560  0000 0000 0000 0000 0000 0000 0000 0000  ................
6600  2000 0000 149e ef24 c48a 40de 88b9 6a59   ......$..@...jY
6620  4795 ab64 a43b 2b2b 0000 0000 0000 0000  G..d.;++........
6640  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

сравниваем с дампом иноды котоорый мы получили выше


debugfs:  inode_dump <30>
0000  a481 0000 0700 0000 3866 b164 7795 ab64  ........8f.dw..d
0020  808b ab64 0000 0000 0000 0100 0800 0000  ...d............
0040  0000 0000 0100 0000 0044 0000 0000 0000  .........D......
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 672c c5c3 0000 0000 0000 0000  ....g,..........
0160  0000 0000 0000 0000 0000 0000 0000 0000  ................
0200  2000 0000 149e ef24 c48a 40de 88b9 6a59   ......$..@...jY
0220  4795 ab64 a43b 2b2b 0000 0000 0000 0000  G..d.;++........
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

видим что это одно и тоже. значт мы руками нашли тело иноды верно

теперь внутри тела иноды ищем список дата блоков 

для этого я заебался искать формат иноды от ext3.
еле нашел в книжке

0–1 File mode 
2–3 Lower 16 bits of user ID No
4–7 Lower 32 bits of size in bytes Yes
8–11 Access Time No
12–15 Change Time No
16–19 Modification time No
20–23 Deletion time No
24–25 Lower 16 bits of group ID No
26–27 Link count No
28–31 Sector count No
32–35 Flags (see Table 15.14) No
36–39 Unused No
40–87 12 direct block pointers Yes
88–91 1 single indirect block pointer Yes
92–95 1 double indirect block pointer Yes
96–99 1 triple indirect block pointer Yes
100–103 Generation number (NFS) No
104–107 Extended attribute block (File ACL) No
108–111 Upper 32 bits of size / Directory ACL Yes / No
112–115 Block address of fragment No
116–116 Fragment index in block No
117–117 Fragment size No
118–119 Unused No
120–121 Upper 16 bits of user ID No
122–123 Upper 16 bits of group ID No
124–127 Unused N


в этой таблице вот они байты которые хранят список дата блоков где же хранится 
тело файла

40–87 12 direct block pointers Yes
88–91 1 single indirect block pointer Yes
92–95 1 double indirect block pointer Yes
96–99 1 triple indirect block pointer Yes

в байтах 40-87 хранится адреса двенадцати блоков. адрес каждого блока хранится в четерыех
байтах. смотрим что хранится в иноде по этим оффсетам

 0044 0000 0000 0000  0000 0000 0000 0000 
 0000 0000 0000 0000  0000 0000 0000 0000

кстати сравним этот блок тем что покажет нам утилита

debugfs:  inode_dump -b <30>
0000  0044 0000 0000 0000 0000 0000 0000 0000  .D..............
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

левая колонка в дебагфс это не контент а оффсеты поэтому видим что это совпало! 


берем адрес первого дата блока . это 

0044 0000 (LE) = 0000 4400 (BE) =  17408 (десятичный)

итак мы нашли адрес дата блока где лежит тело файла 
нашли его руками. сравниваем этот адрес с тем что мы нашли через утилиту


> debugfs:  blocks <30>
17408 

совпадает



теперт кога научиились работать с индой ее телом , списком дата
блоков с телом файла мы переходим к файлу типа симлинк


хочу найти где в каких дата блоках хранися тело симликнка его контент 
на что он ссылается

# l -1il
total 20
30 -rw-r--r-- 1 root root     7 Jul 10 04:39 45.txt
11 drwx------ 2 root root 16384 Jul 10 04:18 lost+found/
12 lrwxrwxrwx 1 root root     8 Jul 14 14:26 sym1 -> ./45.txt


# stat sym1
  File: sym1 -> ./45.txt
  Size: 8           Blocks: 0          IO Block: 4096   symbolic link
Device: 707h/1799d  Inode: 12          Links: 1


мы щас сразу заюзаем команду которая покаызвает дамп блоков в теле иноды
который отвечает за сохранение списка (адресов) дата блоков где хранится тело 
файла. (тоесть не будем делать это руками а сразу заюзаем нужную команду)

debugfs:  inode_dump -b <12>
0000  2e2f 3435 2e74 7874 0000 0000 0000 0000  ./45.txt........
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

вау! окзывается что тело файла симлинка хранится в самом теле иноды. там где
должен храниися список адресов дата блоков где хранится тело обычного файла
так вот случае файла симлинка там хранится тело самого файла!!!! 

тепер я знаю где и как хранися тело симлин файла! но пока тлько для ext3
попробуем посмотреть как обстоит дело с файлом симлинком но на ext4

теперь я перешел в папку которая базируется на основе ext4
и создал два симлинка

# ll -h
total 1.4G
drwxr-xr-x  3 root root 4.0K Jul 14 15:58 ./
drwxr-xr-x 13 root root 4.0K Jul 11 23:02 ../
-rw-r--r--  1 root root    1 Jul 13 22:40 01.txt
-rw-r--r--  1 root root 300M Jul 13 22:27 300M.txt
-rw-r--r--  1 root root 500M Jul 13 20:29 500M.txt
-rw-r--r--  1 root root 600M Jul 13 21:26 600M.txt
drwx------  2 root root  16K Jul  9 22:02 lost+found/
lrwxrwxrwx  1 root root   10 Jul 14 13:40 sym1 -> ./600M.txt
lrwxrwxrwx  1 root root   18 Jul 14 15:58 sym2 -> /mnt/ext4/300M.txt


находим номера инод для симлинков

# stat sym1
  File: sym1 -> ./600M.txt
  Size: 10          Blocks: 0          IO Block: 4096   symbolic link
Device: 706h/1798d  Inode: 16          Links: 1

# stat sym2
  File: sym2 -> /mnt/ext4/300M.txt
  Size: 18          Blocks: 0          IO Block: 4096   symbolic link
Device: 706h/1798d  Inode: 17          Links: 1


debugfs:  inode_dump -b <16>
0000  2e2f 3630 304d 2e74 7874 0000 0000 0000  ./600M.txt......
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

debugfs:  inode_dump -b <17>
0000  2f6d 6e74 2f65 7874 342f 3330 304d 2e74  /mnt/ext4/300M.t
0020  7874 0000 0000 0000 0000 0000 0000 0000  xt..............
0040  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

видим что на ext4 также как на ext3 тело файла симлинка хранится там где у обычного
файла хранится списк адресов дата блоков где уже хранится тело файла.
тоесть все совпдаадает с тем как это есть у ext3

вопрос список дата блоков в иноде формата ext4 тоже харнится начиная с 40-го байта(как 
это мы видели у иноды ext3)?

посмрим полный дамп иноды 17

debugfs:  inode_dump <17>
0000  ffa1 0000 1200 0000 8e70 b164 8b70 b164  .........p.d.p.d
0020  8b70 b164 0000 0000 0000 0100 0000 0000  .p.d............
0040  0000 0000 0100 0000 2f6d 6e74 2f65 7874  ......../mnt/ext
0060  342f 3330 304d 2e74 7874 0000 0000 0000  4/300M.txt......
0100  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 38f1 7983 0000 0000 0000 0000  ....8.y.........
0160  0000 0000 0000 0000 0000 0000 55a8 0000  ............U...
0200  2000 aa9b 9c13 fc2e 9c13 fc2e e411 5151   .............QQ
0220  8b70 b164 9c13 fc2e 0000 0000 0000 0000  .p.d............
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

вычленяем кусок начиная с оффсета 40. офссет измеряется в байтах. и начаинается с 
байто номер ноль. поэтому офссет 40 это по факту 41-ый байт от начала
2f6d 6e74 2f65 7874
мы видим что дебагфм уже декодировал для нас байты в ascii (срправа) но 
мы их еще раз руками декодируем через echo 

$ echo -e "\x2f\x6d\x6e\x74\x2f\x65\x78\x74"
/mnt/ext

отсюда получаем что в ext4 в иноде тело симлинка хранится ровно тамже где и и у иноды ext3
тоесть начиная с 41 байта от начала иноды. или с 40-го оффсета.

приколно.

ксатии в свойствах иноды 17 видно что  у нее неактииивиован флаг отвечающий
за экстенты

Inode: 17   Type: symlink    Mode:  0777   Flags: 0x0
Generation: 2205806904    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 18
File ACL: 0

тоесть
Flags: 0x0

поэтому i_block(тоеместо где в иноде пропиывается где хранится тело файла) он видимо классический то етсть как у ext3.


а вот для примера обычный файл на ext4 
обычны файл в иноде 12
debugfs: stat <12>
Inode: 12   Type: regular    Mode:  0644   Flags: 0x80000

мы видим что  у него флаг указывает что актииорованы экстенты 
Flags: 0x80000



еще раз хочу убедиться и показать что i_block для инод на ext3 
совершенно оттилчается от i_block на ext4


ext4 
я сделал файл длинной 1 фс блок

# echo "12" > 1B.txt

# stat 1B.txt 
  File: 1B.txt
  Size: 3           Blocks: 8          IO Block: 4096   regular file
Device: 706h/1798d  Inode: 19          Links: 1

инода 19

смотрим в каком блоке фс она сидит
у нас один екстент и он состоит из одного блока фс

debugfs:  dump_extents <19>
Level Entries       Logical                Physical Length Flags
 0/ 0   1/  1     0 -     0   21304325 -   21304325      1 


блок ФС = 21304325
посмотрим чем равен адрес 21304325 в hex представлении
в litle endian виде получаем
 0514 4501

ищу эти байты в зоне i_block

debugfs:  inode_dump -b <19>
0000  0af3 0100 0400 0000 0000 0000 0000 0000  ................
0020  0100 0000 0514 4501 0000 0000 0000 0000  ......E.........
0040  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

в приниципе я нашел. лежит середине i_block


посмотрим когда файл на ext4 занимает 3 фс блока

я создал файл и он лежит  в одном экстенте 
который состоит из трех фс блоков

21304844 -   21304846

преобразуем их адреса в LE формат

0145 160C (BE) = 160C  4501 (LE)

0145 160D (BE) = 160D  4501 (LE)

0145 160E (BE) = 160E  4501 (LE)

ищем эти адреса в i_block

debugfs:  inode_dump -b <22>
0000  0af3 0100 0400 0000 0000 0000 0000 0000  ................
0020  0380 0000 0c16 4501 0000 0000 0000 0000  ......E.........
0040  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

да . мы нашли самый первый блок в середине i_block

на этом я постулирую что искать блоки с телом файла руками в иноде
это бесполезная трудная задача. надо просто юзать dump_extents <22> 
и получать готовый набор фс блоков.

а вот 
для сравнения i_block для иноды на ext3

debugfs:  blocks <30>
17408 

debugfs:  inode_dumps -b <30>
debugfs: Unknown request "inode_dumps".  Type "?" for a request list.
debugfs:  inode_dump -b <30>
0000  0044 0000 0000 0000 0000 0000 0000 0000  .D..............
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

тут все просто и понятно. экстентов нет. 
в первом же офссете мы видим 
0044 0000 (LE) =  0000 4400 = 17408

ну и я напомню на всякий случай что в случае ext3 у нас в иблоке есть первые 12 записей
(по 4 байта на запись) в который указываются адреса фс в которых лежит тело файла.
в данном случае файл уместился в один фс блок поэтому и занята токьо одна запись (первые 4 байта в i_block). если файл длинее чем 12 *(размер блока ФС) то 13-я запись в i_block
указывает на ФС блок котрый лежит уже вне тела иноды . этот блок уже лежит вне области метаданных группы блоков там где лежат все остальные блоки где будут хранится тела файлов.
тоесть получается что часть метаданных ext хранит вне области метаданных. она это хранит
там же где хранятся тела файлов. это прикол. так вот в том блоке уже хрантся адреса осталтной части тела файла. это блок он 1 блок по размеру. если блок ФС размером 4К то в нем поместится 
4096 / 4 байта = в этом блоке можно записать 1024 адреса для блоков ФС . там так и сделано.
он хранится 1024 адреса блоков ФС уже в которых хранится тело файла. таким образом
используя связку 13-я запись в i_block --> блок ФС (1024 адреса ФС ) можно сохраниить 
1024 * 4K = 4MB тело файла.  если блок фс по размеру 1K то получается 13-ый блок будет ссылаться на блок фс размером 1К . в 1К можно записать 1024 / 4b = 256 адресов блоков на ФС и таким макаром закодировать телоа файла размером 256 * 1K = 256 KB тело файла.
 щас покажу на практике.

имеем ext3
раземер ФС блока 4КБ
создем файл размером 56KB 

кстати fallocate неработает на ext3 
пишет 
fallocate: fallocate failed: Operation not supported
думаю из за тогото в ext3 нет  возможности преаллокейта когда мы
помечает в i_block что такие то блоки заняты но по факту мы туда ничо не пишем.

поэтому создаем файл вот так
# dd if=/dev/zero of=./56k.txt bs=4k count=14

# stat 56k.txt 
  File: 56k.txt
  Size: 57344       Blocks: 120        IO Block: 4096   regular file
Device: 707h/1799d  Inode: 13          Links: 1


(Blocks: 120) * 512 = 60KB занимает файл на диске.
но что за фигня? файл должен занимать 56К на диске должен занимать 14 блоков ФС
а он занимает 60К
это 15 ФС блоков. на один дата блок больше. дело вот в чем.
12 адресов этих блоков будут сохранены в первых 12-ти записях  внутри иноды в i_block
секции а последние 2 фс блока их адреса будут сохранены через связку 13-ый блок указывает на 
некоторый блок вне тела иноды там где хранятся все остальные тела файлов (отсюда и дополнитльный блок в отчете по файлу) и внутри этого блока ФС будет 2 адреса фс каждый по 4 байта. ! во как !
проверяем руками:


debugfs:  blocks <13>
17920 17921 17922 17923 17924 17925 17926 17927 17928 17929 17930 17931 16919 17932 17933


debugfs:  inode_dump  -b <13>
0000:  0046 0000 | 0146 0000 | 0246 0000 | 0346 0000 | .F...F...F...F..
0020:  0446 0000 | 0546 0000 | 0646 0000 | 0746 0000 | .F...F...F...F..
0040:  0846 0000 | 0946 0000 | 0a46 0000 | 0b46 0000 | .F...F...F...F..
0060:  1742 0000 | 0000 0000 | 0000 0000 |           | .B..........


ключ -b показывет нам дамп иноды касающийся именно части описывающей i_block

берем первые 4 байта. это адрес первого фс блока
0046 0000 (LE) = 0000 4600 = 17920

совпадает с тем что показывает block <13>

берем двенадацатую запись 

0b46 0000 (LE) =  0000 460B (BE)= 17931

это полностью совпдаатет с адресом 12блока из  block <13>

а дальше самое интересное.


команда block <13> показыает что последние три блока в которых хранится тело фс 
это блоки с адресами 16919 17932 17933

берем 13-ю запись из i_block

1742 0000 (LE) = 0000 4217 (BE) = 16919 

мы виим что это 16919. тот самый блок который остался среди трех последних.
это то блок в котором лежит нетело файла а лежат метаданные. лежат адреса двух последних блоков.

смотрим контент блока 16919

debugfs:  block_dump 16919
0000:  0c46 0000 0d46 0000 0000 0000 0000 0000  .F...F..........
0020:  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

0c46 0000 (LE) = 0000 460C = 17932 
бинго это первый из оставщихся двух дата блоков

0d46 0000 (LE) = 0000 460D = 17933

все готоово! и так  у нас получается что тело файла занимает 12 
дата блоков и еще один блок находится в зоне дата блоков в нем хранится часть метаданных
которая невходит в тело иноды. в это м блоке ФС хранятся адреса последних двух 
дата блоков фс тела файла.!!!
вау!!


схема которая выносит запись о списке блоков тела файла из тела иноды тоесть из таблицы инодов дает то что у нас таблица инодов всегда будет иметь некий предсказуемый размер
внезависмости от обьема тела файлов. ведь инода он то занимается одним файлом . потом
если файл стерли то инода освобождается и потом опять занимается другим фалом и размеры
этих файлов зарнее неизвестыне. поэтому если бы список блоков тела файла всегда целиком
хранился внутри иноды то приходилось как то перемещать иноды по диску они бы мешали 
друг другу. схема нормал по архтерктуре.


получается в иноде в ее теле в i_block разделе хранятся адреса первых 12-ти блоков фс тела файла.
тринадцатая запись в i_block  указывает на блок на фс вне тела иноды и в этом блоке 
хранится 1024 адреса блока фс кодируя тело файла размером 4МБ.

если файл еще длинее то вступает в дело 14-я запись в разделе i_block
она ссылает на блок вне тела иноды который харнится в зоне дата блоков в котором каждый
запись по 4 байта указывает на блок тоже лежащий вне зоны таблицы инодов в котором 
содержится 1024 адреса блоков фс. таким образом общее число адресов закодированных
составляет 1024*1024 что кодирует 1024*1024*4K = 4GiB данных. это все верно при размере
блока фс в 4К. если блок 2К или 1К то число адресов блоков закодивароных внутри будет меньше.
тоесть

при размере блока фс 2K получаем число адресов (2024/4) * (2024/4) 
и размер сумарный этих блоков (2024/4) * (2024/4) * 2K = 512 MB

при размере блока фс в 1К получаем получаем число адресов (1024/4) * (1024/4) 
и размер сумарный этих блоков (1024/4) * (1024/4) * 1K = 64 MB

возврашаемся к блоку фс размеро 4К. так вот на данный момент мы закодиовали
файл с ддлинной тела 48К+4МБ+4ГБ. если и этоого мало в дело вступает 15-я запись в
зоне i_block в иноде. она уже имеет три степени вложенности. 
число закодиоровнных адресов блоков составит 1024*1024*1024
а обьем этих блоков 1024*1024*1024*4K = 4TB

надо при этом еще раз подчеркнуть что вот адреса этих блоков всунутые по 1024 штуки
в блок ФС будут лежать  в зоне датаблоков в группе блоков. и они будут добавлять обьем
к обьему файла. и это будет отражаться в stat имя_файла.

прикинем сколько блоков на ФС займет вот эта вот схема  вложенными таблицами.

12-я запись лежащая в иноде указвыает на 1 блок фс котрый лежит в зоне датаблоков.
значит эта схема отьедает 1 дата блок в зоне датаблоков. тоесть к телу файла 
прибавляет 1 блок фс. это будет будет зафикировано в комаде stat

13-я запись лежащя в иноде указывает на 1 блок фс котоырй лежит в зоне датаблоков.
и от этого блока идут связи к 1024 блокам на фс в зоне дата блоков. это сожрет
1+1024 дата блоков в зоне дата блоков и они будут прибавлены к размеру тела файла.
1025 дата блоков по 4К это 4МБ при том что это кодирует 4ГБ. это 0.001 от общего размера файла.

15-ый блок внутри иоды ссылается на 1 блок ФС в зоне датаблоков который ссылается 
на 1024 блока в зоне дата блоков каждый из которых ссылается на 1024 блока на фс
это уже порядка миллиона дата блоков это по размеру отожрет 4ГБ. но закодирует 4ТБ.
это тоже одна тысячная от размера тела файла. 
с этим все двигаем дальше.





далее
рассмотрим такой вопрос
копка на клаве - байтовй поток - симовл на экране - байтовый поток в файл. (между ними
кодировка).

мы тыкаем кнопку на клаве и в программу котоорая щас активна на чее stdin прилетает
некий поток байтов. пусть это будет терминал+bash (что отделная тема ) в иттге
у нас на экране терминала возникает символ. фишка в том что приложение+терминал а может 
и сам терминал без приложения преобразует тот поток байтов с клавы в некий графический
символ на экране терминала. и тут важно заметить что в и с клавы летят не буквы а байты
и в файлы сохраняются не символы а байты. и очень центральный вопрос о том что надо преобразоывать байты в символы по какомуто закону. обычно закон это так называемая кодировка.
откуда баш или терминал знаю какую кодировку использовать. это пока непонятно. 
будет считать что все приложения и терминал (который вирт устройство) считают что все байты
надо декодировать по закону кодировки UTF-8.
кодировка UTF-8 в чем ее схема. один символ кодириуется разной длинной байтов. 
от одного байта на символ до четырех байтов на символ.  самые часто используемые 
символы имеют длину кодировки один байт. причем для этих символов параельно кодиовка совпдаает с кодрровйо ASCII. самые редко испозуемые символы кодируются четырьмя байтами.
примеры:

кодировка :  21(hex) = "!"
пример
$ echo -e "\x21"
!

кодровка : D09A(hex) = "К"  (русская заглавная К)
$ echo -e "\xD0\x9A"
К

кодирвка :  E2 8C A8 (hex) = ⌨  (знак клавиатуры)
пример
 echo -e "\xE2\x8C\xA8"
⌨


кодиовка :  F0 92 85 84
пример
$ echo -e "\xF0\x92\x85\x84"
𒅄


это все одна кодровка. кодиррвка UTF-8. один символ может быть закодирован от 1 до 4 байтами.


значит я думаю схема работает так рассмотрим что баш процесс плюет поток байтов на свой stdout. тогда этот поток ядро перебрасывает на устройство терминал. это такое же полноценное
устройство железное как жестуий диск и usb порт. только это устройство реализовано в виде кода в виде виртальной железки. но для простоты будем считаь ее железной реальной железкой.
этот поток байтов прилетает на терминал. и он преобразует этот поток байтов в символы на 
своем экране. преобразует поток байтов в символы в начертания в черточки и точки на основе
таблицы кодировки UTF-8.
почему именно UTF-8 а не UTF-16 или еще что. это оставляем за кадром.

важно понять что между башем и терминалом ходят только байты. ниаких символов по проводам
нелетает. все время идет процесс преобразования байты прилетающие от баша преврашабтся перкодируктся в символы. а то что мы тыкаем на клаве в форме байтов летит от терминала который
принимает эти байты с клвы летит на stdin баша. как я понимаю байт коды с клавы они терминалом преобразуются в байты коды utf8 и они летят в баш. потому что возикает такая иллюзия что между клавой терминалом башем файлами летатют граф символы. это не так. они
все общаются только через поток байтов. это для нас терминал преобрадует нативный реальный  (язык на котором они друг с другом общаются ) в наш вторичный для компа язык - язык граф
символов. аналогия такая что звук из колонки вылетает в форме звка но внутри компа это поток байтов.

тут я немножоко отойду в сторону и расскажу о команде баша ":".
это встроенная команда в баш

# type :
: is a shell builtin

баш билтин значит что это команда встроенная в бинарника /bin/bash 
тоесть когда мы ее пишем то башу ненадо грузить какойто внешний файл как например в случае
/bin/ls

так первое что я хотел сказать - у баша ест такая дебильная манера использовать в качестве
имени команды не слова а ебутые символы. это сбивает с толку. но сбиваться ненадо. 
мы привыкли что символы обычно имеют смысл операторов между командами. но этот тут не так.
данный символ ":" является командой полноценная команда. просто она имеет не буквенное имя
 а дебилоидное символотное имя. у баша есть еще такие аналогии. например у баща есть
 билтин "source" так вот вместо буквенноого имени команды можно юзать символный вид
 этой команды в виде "."  это одна и таже команда. просто вместо буквенного имени 
 "source" исполуется ебнутое имя команды в виде точки. про баш встроенные команды
 можно прочитать в man bash и надо искать по строке "SHELL BUILTIN COMMANDS"

так вот встроенная команда ":" она неделает нихуя. она всегда возвращает 0 в коде
возврата. еще прикол в том что если справа от нее навставлять аргументов то ей плевать.
опять же ничего не произойдет. что вставляй что не вставляй

# let b=1
# echo $b
1
# : let c=1
# echo $c

# : wekrjwelrkjwrklwej #234lj234 []wer[we wekrjw

зачем эта команда нужна я так и непонял. читал тут - https://stackoverflow.com/questions/3224878/what-is-the-purpose-of-the-colon-gnu-bash-builtin

единсвтенное что я понял она повиялас в баше когда в нем еще небыло встроенныэ команд
"true" и "false".

поскольку комагнда ":" ничего не выводит в  stdout  то 

$ : > ./demo.txt

приведет к тому что на диске будет создан файл с размером 0 байт на диске. в теле которого
не будет содержаться нихуя. потому что оператор ">" он что делает. он береет команду
которая стоит слева от него точнее он берет то что высирает команда слева на свой stdout
и напрвляет этот байтовый поток в файл на диске в тело файла. поскольку ":" ничего не высирает в stdout то в тело файла ничего не вставляется.
соовствтенно если на диске уже есть файл с таким именем то файл не создается. но все
его дата блоки его тела они освбобождаются перед тем как в тело файла начнется запись
из stdout команды слева от ">"

ровно поэтому если напишем

$ echo "vasya" > ./demo.txt 
на диске в теле файла будет сохранено "vasya". потому что команда echo высирает "vasya"
на свой stdout но так как стоит оператор ">" он перехыватывает этот байтовй поток 
и сует его в тело файла.

итак оператор ">" берет stdout процесса слева и сует его в файл на диске.

команда "|" (пайп) работает совсем по другому. пайп трубует чтобы и слева была команда (процесс) и справа была команда (процесс). пайп делает вот что. он создает два процесса
тот который слева и тот который справа. и он stdout процесса слева направляет на stdin 
процесса справа. сооствтенно процессов стало два. а файла на диске никакого нет. в этом разница.

# echo "vasya" | cat
vasya

stdout от команды echo суется на stdin команды cat. ну а программа cat то что получила на stdin сама уже перенаравляет на stdout а ядро из ееного stdout сует поток на терминал. а он 
рисует буквы на экране.

соотвсвтенно оператор "<" работает так. он читает файл который у него записан справа 
и сует его байты на stdin процесса который указан от него слева. 

# cat < demo.txt


таким макаром я здесь осветил несколько моментов про баш: то что у баша есть встроенные
команды, что ряд этих встроенных команд имеет ебнутый вид не виде букв а в виде спецсимволов (точки, скобочки , двоеточия и прочая хуйня) что спервого взгляда сбивает столку. потоу что 
нас приучили что спецсимволы это не команды а операторы между командами. я осветил операторы
"<",  ">", "|"
я осветил встроенную бесполезную комнду ":" баша.

ксати. так как имя файла у ext это любой набор байтов (похуй каких) то мы сами
можем на фс создавать файлы с ебнутыми названиями. а внутр пихать баш скрипты. пример

$ cat << EOF  > ./:
#!/bin/bash
ls -1
EOF


$ cat :
#!/bin/bash
ls -1

$ chmod +x :

теперь мы имеем файл  с именем ":" который просто файл с ебнутым названием.
внутри обычный баш скрипт. запускаем его

$ ./:
01.txt
12K.txt
1B.txt
24K.txt
300M.txt
3B.txt


вот и все. нет ничего особого. просто бащ имеет встроенные команды которые имеют не привычное
буквенное название а ебнутое название через спецсимволы.
также фс ext позвоялет создавать файлы с диковыииными назвыаниями. но вэтом 
нет ничего осбенного.


теперь пеерходим ближе к тому что  я хотел осветить.
к созданию файлов на ext с непривычными названиями из символов которых нет на клавиуатуре.
дело в том что ext ей плевать на имя файла. для нее это просто набор байтов. 
так давайте создадим файл на фс с набором хрен пойми каких байтов.

как происходит создаие файла в баше:
1) либо touch имя_файла
2) либо команда > имя_файла

вобоих случаях мы в командной строке символами с клавы 
пропиывваем название будущего файла.
$ touch vasya.txt
$ > vasya.txt

этот спосбо нам неинтересен потому что таким макаром мы можем создавать файлы
с именами только из тех символов которые есть на клавиатуре. а нам нужен 
спосою который позволит указать имя файла в виде байтов.

далее мы используем следущий трюк. у баша есть такая конструкция

# $(ls)

команда которая внутри скобок запускается и ее stdout возвращается к нам 

# echo $(ls)
01.txt 12K.txt 1B.txt 24K.txt 300M.txt 3B.txt 500M.txt 50M.txt 56k.txt 600M.txt : demo.txt lost+found p1.py p2.py sym1 sym2

как рабоает эта команда. вначале запускается комада "ls" из ее stdout считывается байт поток
который она высирает далее запускается команда echo а байт поток который был высран 
подсоывается ей как блок аргументов. получается что хрень $(команда) может быть использована
как аргумент для команды. значит любой поток байтов который высрет вывод команды внутри 
скобок будет подсунуть как аргумент для команды. в частности для команды которая создает файл. а поток байтов будет использован как имя для файла.

немного отойдя в сторону хотел вот что показать

# cat b2.bash 
#!/bin/bash
echo $#

где "$#" это спец переменная она показывает сколько штук аргументов было передано скрипту.
потому что интересно вывод от ls будет подснуть в скрипт как один большой аргумент
или как куча аргументов. проверяем

# ls
01.txt  12K.txt  1B.txt  24K.txt  300M.txt  3B.txt  500M.txt  50M.txt  56k.txt  600M.txt  :  b2.bash  demo.txt  lost+found  p1.py  p2.py  sym1  sym2

# ./b2.bash $(ls)
18

интересно..

начнем с создания вот такого файла

$ : > $(echo "vasya.txt")

# ls
vasya.txt

у команды echo есть опция чтобы в качестве аргумента ему можно было 
указать байты в hex формате и он эти hex байты и сунет на stdout.

поехали с более интересными случаями

# echo -e "\x3A\x45\xC2\xA3"
:E£

рассмтоим более подробно: 3A(hex) (utf8) = ":"
45(hex) (utf8) = "E"
C2A3 (hex) = "£"


# : > $( echo -e "\x3A\x45\xC2\xA3" )
# ls -1
:E£

проверим еще  с другой стороны что имя файла сформтровано как поток байтов "\x3A\x45\xC2\xA3"

# ls -1 | hexyl
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 3a 45 c2 a3 0a          ┊                         │:E××_   ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

0A - это символ "enter" он неимеет отношения к названию файла хранящееся
на ext. это уже сам ls добавляет. 
так что на фс имя файла сохраннео как найбор байтов 3a 45 c2 a3

провреим еще через debugfs

найдем иноду для папки в которой у нас лежит файл. потому что 
имя файла у нас хранится в иноде папки а не в иноде файла

# ls -1ai
222560257 .
        2 ..
222560258 :E£

значит инода папки 222560257

имена файла (ентри) хрантся в дата блоках тела файла иноды папки

debugfs:  dump_extents <222560257>
Level Entries       Logical                Physical Length Flags
 0/ 0   1/  1     0 -     0 1780482048 - 1780482048      1 
(END)

debugfs:  block_dump 1780482048
0000  0100 440d 0c00 0102 2e00 0000 0200 0000  ..D.............
0020  0c00 0202 2e2e 0000 0200 440d dc0f 0401  ..........D.....
0040  3a45 c2a3 0000 0000 0000 0000 0000 0000  :E..............
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
7760  0000 0000 0000 0000 0c00 00de 0e14 1aef  ................


значит напомню мы ищем 3a 45 c2 a3
и мы их видим в дампе.
значит мы точно убедились что имя файла физически на фс хрансят в виде 
потока байтов "3a45 c2a3"

что меня поражает в баще . это то что абсолютно нет инстументов командной
строки чтобы можно было указать поток байтов в удобном виде "3a45c2a3" который
бы какая нибудь утилита бы была готова кидать на свой stdout.
и единственная форма чтобы это сделать является уродливая утилита echo
# echo -e "\x3A\x45\xC2\xA3"
что реаьно неудобно и уродливо

далее я хочу подчекнуть что команда ls пулчает от фс имя файла в виде потока
голвых байтов. далее как я понимаю утилита ls берет этот поток байтов и ничего с ним
не делает (ну там зависит от флагов) но скажем вот в таком виде команды ls
она только символ новой строки добавляет. что однозначно нам подтверждает hexdump того что вылезает из ls

# ls -1 | hexyl
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 3a 45 c2 a3 0a          ┊                         │:E××_   ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

а далее терминал и имено терминал и никто кроме терминала преобразует этот поток 
байтов в символы на основе кодировки utf. самой команде ls глубоко плевать 
каким символами кодируются байты в названиях файлов. симваолами занимается терминал
просто на стадии отображения.

удалим файл
# rm  $( echo -e "\x3A\x45\xC2\xA3" )
# ls

удалили успешно. 
здест видна очень важная вещь. как у нас бы работал стандартный rm

# rm 1.txt

мы набили эту команду в терминале. тыкаем enter. терминал перекодирует 1.txt в 
поток байтов в виде 

# echo "1.txt" | hexyl
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 31 2e 74 78 74 0a       ┊                         │1.txt_  ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

тоесть термина перекодировал бы 1.txt в поток байтов 31 2e 74 78 74  и именно 
этот поток отдается команде rm как аргумент ( а не какито там абстрактные граф символы).
комнада берет этот поток и передает его фс . и та ищет и удаляет файл у котрого 
имя имеет такой набор байтов в этой папке.

коода же мы заюзали эту форму

#rm  $( echo -e "\x3A\x45\xC2\xA3" )

то терминалу ненадо ничего преобразоваывать. в rm уже поступает готовый поток байтов.

это дает нам ответ а как можно удалить файл имя котрого (набор байтов) состоит из 
символов которых нет на клавиуатуре. и мы не графическом режиме. в графическом режиме
поняно - копируешь в буфер вставляемшь готоов. в чисто текстовом режиме мы просто
берем запускаем комаду ls направяояем ее вывод на hexyl получаем имя файла в виде байтового
потока (ровно так как он и хранистя на фс) и ппеедаем как параметр этот поток на команду 
удаления. 

ровно такойжее подход можно применить скажем для команды grep
пример

# echo -e "\xE2\xAD\x95"
⭕

# : > $(echo -n  -e "\xE2\xAD\x95")
# ls -1
⭕


(ключ -n у echo это чтбобы он не добавлял символ перевода строки в конце вывода. он 
же нам ненужен в названии файла)

# ls -1 | grep  $(echo -n  -e "\xE2\xAD\x95")
⭕

вот тоесть в обычной ситуации мы в греп прописываем символы с клавы которые 
терминал преобразует в байтовый код используя таблицу кодировки и далее команда греп
использует это как аргумент. здесь же в греп в качестве аргумента подсталвяется вывод
из стандартного вывода от исполнения команды echo. таким образом мы можем грепнуть имя
файла символов которого у нас нет на кнопках клавы.

покажу еще момент. в UTF-8 символы котыре кодируются одним байтом заканчиваыются на 7F(hex)
поэтому еси мы будем юзать скажем байт 89(hex) то при передаче от команды ls на терминал
этого байта у терминала вобщето должна ехать крыша потому что такого символа в кодировке
нет. проверим

# echo -e "\x89"
�

вот он вывел некую хрень.
создаем файл с таким именем. потому что фс плевать. она работает с байтами
а не символами. никак не связана  скодироваками
# : > $(echo -n -e "\x89")
# ls -1 | hexyl
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 89 0a                   ┊                         │×_      ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘
видим что все верн. имя файла состоит в байтовом виде из 89(hex)
а 0a(hex) это уже ls добавил от себя знак перевод строки чтобы кстати терминау было понятно 
как форматировать текст !!! 

# ls -1
''$'\211'

а вот получается как "интеересно " проинтерпретирвал терминал имя файла из байтовго вида
в символьный. видмо такой вид означает ошибку. 
тут важно понять что ls к этому неимеет никакго отношения. ls чисто получила имя файла
в виде байтов и таки передала на терминал устройствао. едиснвенрео что ls добивила
перенос строки. это сугубо терминал так проконевертировал байт 89 полученный в 
набор вот таких символов.


насколтко я понял из эксперимтов что то ли терминал виноват то ли фс недает но 
скажем непуолчится создать файл  у котрого имя имеет в первом байте байт 00
тоесть какието все таки ограничения есть толи со стороны теринала толи со стороны фс
на имя файла.

таким образом в этом куске текста была рассмотрена и проврена напрактике 
очент важная вещь это то что на фс имя файла хранися в виде набора байтов и никак
к кодировке непривязана. показано как вбаш можно передать имя файла именно в виде 
потока байтов абсолютно насрав на кодировку и на символы имеющиеся на клаве. 
с таким файлом можно абсолютно козырно работать - создавать удалять грепать.
единственая косметическая проблема это то что если поток байтов не попадает в utf8 кодировку
то у терминала возникают непонятки как этот байтовый поток отобразить на черном экране
через граф символы. 

удивило что в лиуксе нет утилит чтобы можно было удобно закодировать hex поток байтов
не мучаясь с echo


двигаем дальше
как создать ln -s для файла с диковинным именем 

# : > $( echo -n -e "\xE2\xAD\x95" )
# ls
⭕

# ln -s $( echo -n -e "\xE2\xAD\x95" )  ./vasya.txt

# ls -1l
total 0
lrwxrwxrwx 1 root root 3 Jul 16 00:44 vasya.txt -> ⭕
-rw-r--r-- 1 root root 0 Jul 16 00:44 ⭕

нет проблем.
мы создали файл с "диковиным" именем. 
и создали симлинк не него.

отлично.




далее 
хардлинк для папки запрещен
попроуем создать хардлинк для папки

# ll
total 12
drwxr-xr-x 3 root root 4096 Jul 16 00:53 ./
drwxr-xr-x 6 root root 4096 Jul 16 00:52 ../
drwxr-xr-x 2 root root 4096 Jul 16 00:53 76/
root@vm1:/mnt/ext4/12# ln 76 77
ln: 76: hard link not allowed for directory

кстати есть ключ попробовать все таки с делать это 

  -d, -F, --directory
              allow the superuser to attempt to hard link directories (note: will probably fail due to system restrictions, even for the superuser)


прбуем 
# ln -d /usr/bin /mnt/45
ln: failed to create hard link '/mnt/45/bin' => '/usr/bin': Operation not permitted

окей

кстати вот эта ошибка
# ln -d /bin ./vasya
ln: failed to create hard link './vasya' => '/bin': Invalid cross-device link

она о другом она о том что мы пытаемся создать хардлинк (ентри в дата блоках иноды папки)
для файла который лежит на другой ФС (надругом разделе либо на другом диске)а так нельзя
потому что ентри в хардлинке должно укзывать на номер иноды которая конечноже приандлежит
этой ФС. указыать на иноду на другой фс такого конечно же не подразумевается.
тоесть драйвер фс это проверяет.

симлинк может указываь куда угодно. на любую несуществующую фигню. там это не проверяется.
поэтому симоинк можут указывать на файл\папку на другой фс








далее
формы ln (три формы)

у ln ест три формы использования

первая форма:
# touch 45.txt
# ln 45.txt 46.txt

это кодга мы прописывем и исходник и таргет.
это понятно.

вторая форма:
# ln ../50M.txt  
# ll
total 51208
drwxr-xr-x 2 root root     4096 Jul 16 00:56 ./
drwxr-xr-x 7 root root     4096 Jul 16 00:55 ../
-rw-r--r-- 2 root root 52428800 Jul 15 00:03 50M.txt

это когда мы указываем исходник из другой папки а имя таргера неукаываем
тогда в текущей папке будет создан линк (хардлинк или симлинк в зависимости поставили мы ключ -s или нет) с таким же именем

третья форма:
# ln /usr/bin/ls /mnt/45
# ll
total 144
-rwxr-xr-x  2 root root 138208 Feb  7  2022 ls*

третья форма состоит в том что мы указыаем source и указываем dest папку 
но не указываем какое имя дать линку в этой папке.

от прерыдущей формы отичается тем что во второй форме линк делается в текущую папку
а в третьей форме в любую указанную папку.

в првой форме мы пропиывем имя линка. во вторйо и третьей мы его неуказыаем 
оно берется такое же как у исходного источника

причем меня вот это прикололо

# ln /usr/bin/* /mnt/45

эта команда создаст линк ДЛЯ КАЖДОГО ФАЙЛА из /usr/bin/ в папку /mnt/45
тоесть нам ненужно руками указывать каждое название файла из /usr/bin/
это супер удобно.


при удалении "файла" из какойто папки тоесть хардлинка (тоесть мы должны указать папку и имя файла в ней)  у нас удаляется ентри (запись ) из дата блоков иноды папки. и в иноде которая отвечает за файл у нас уменьшаетс количество  в поле "Links" на один. если это было последний хардлинк на иноду файла то эта инода вычищается в частности в ней стирается
список дата блоков\экстентов в которых лежит тело файла. при этом сами дата блоки не трогаются так что если у нас есть список дата блоков этого файла на бумажке то мы можем
руками через dd контент этого файла куда то перекопировать.  инода файла вычищается 
при усвлоии что нет открытого дисекриптора который работает с этим файлом. пока есть хотя
бы один дескриптор инода не трогается не обнуляется. хотя хардлинка на фс уже нет. тоесть
комагда ls уже покажет что файла якобы уже нет в живых.

если какимто макаром у нас на фс есть иноды необнуленные и в том же время для них 
на фс нет ниодного хардлинка команда e2fsck при ее запуске это заметит и спросить че делать
то ли обнулить эти иноды то ли ... по моему предложить создать для этих инод хардлинки в папку lost+fouund


далее
ext2 опиание layout = https://www.nongnu.org/ext2-doc/ext2.html


про symbolic lynks  у мужика из швейцарии (https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/) читаю - For the symbolic link, I said the name of the target is kept at data blocks.

это не так. имя таргета тоесть путь к файлу в символьной ссылке хранися не дата блоках
иноды нет. оно хранится в i_block иноды. это разные вещи. тоесть оно хранится не в дата блоках файла тела а в теле иноды в блоке в котором обычно прописывабтся адреса блоков ФС 
в которых уже regular file содержит свое тело. так что эторазные вещи. говоря другими словами
мужик оутвержает что путь симвльной сслыки хранисят вне зоны метаданных в тех блоках где 
обычно у обычных фалов хранится тело файла. а на самом деле путь прописанный в символльной
сслыке хранится внутри тела иноды. так что это совем разыне вещи.


еще разница межу хард линк и симлинк.

что такое файл. это набор компонентов. это хардлинк ( ентри харнящийся в дата блоках файла котоырй отвечает за папку ) + инода от файла  + тело файла хранящеся вне зоны метаданных группы блоков + если файл большой это доп блоки хранящие часть метаданных но лежащие вне
зоны метаданных и лежащие в зоне дата блоков которые хранят адреса дата блоков в которых лежит тело файла. эти дополнтельные дата блоки лежащие вне зоны метаданных это как бы кусок 
иноды но хранящийся вне тела иноды. 

в хардлинке хранится имя файла непривязанное ни какоой кодировке а просто это набор
практически люыбых байтов и номер иноды в которой хранится этот файл.

если мы создаем +1 хардлинк скажем к файлу уже есть то у нас создатеся +1 ентри 
в какой то иноде в ее дата блоках где мы записыем имя файла новое и иноду в которой хранися
вся остальная метадата инфмрмация по файлу.
что сущесвтенно при создании хардоинка это то что при этом не занимается и не расходуется
новая инода. это значит что с точки зрения фс у нас несоздается новый файл.

если мы создаем симликн то прежде всего разница в том что у нас на фс обязательно создатеся
новый файл. занимается до этого пустая инода.  в папке какой то в ее иноде  у нас создается
ентри который ссылается на эту новозанятую иноду. если у хардлинка  в ентри идет ссылка на индоду где хранится тело файла имя котрого указано в иноде то у смилинка в ентри идет ссылка
на иноду где хранится тело файла самого симлинка а не на иноду файла на который она будет 
указывать. путь же  к файлу на который она укаызвает хранится в теле дата блоков ееной
иноды в виде байтового потока где байтовый поток это вот что 
вот мы написал в строке

ln -s /file1  ./file2
так вот терминал преобразует /file1 на основе кодировки utf8 в поток байтов и передает
как аргумент  к команде ln. и вот ровно тот поток байтов который ей преедали ( в данном случае передал терминал) будет сохранен в дата блоках иноды отвечающей за симлинк.

получется интересный момент что фс драйверу все равно какие байты будут записаны 
в дата блоки иноды симлинка. да хоть любой мусор бессмысленный. команда ln 
она сама символьный путь "/file1" не получает и не преобразоывает в байты. нет
она получает уже гооыве байты и просто их пихает на фс. за процесс преобразования 
отвечает терминал котоырй преобразует наши вбитыве символы в поток байтов. 

да мы можем обойти терминал и передать команде ln подгтовленный лично нами 
поток байтов который мы сами перекодировали из символього вида в поток байтов

# ln -s $( echo -n -e "\xE2\xAD\x95" )  ./vasya.txt

команде ln когда она создает сиваольну ссылку ей плевать что замусор мы ей передали.
она просто создать иноду для симв сылки и в ее дата блоки засунет этот поток байтов
неважно имеет ли он какйто смысл или нет. единсвтенное что я неверно гвоорю поток 
байтов бдет записан не на дата блоки иноды а в тело иноды в ее i_block кусок.

правда мне вот что непонятно - как потом сама фс работает с симвоольной ссылкой?
забуем пока про символьнуд ссылку. расммотрим просто пример

# cat /1/vasya.txt

мы записали команду в терминале. тыкнули ентер. терминал перекодировал /1/vasya.txt
в поток байтов согласно utf-8 и заупстил кманду cat и передаел ей как аргумент поток 
байтов. команда cat примет этот поток байтов и сделает сисколл в который засуенет этот поток
байтов и попросит через сисколл ядро прочитать файл и вернуть его контент в область памяти
команды cat. сисколл передаст этот байтовый аргумент на драйвер фс. так вот вопрос в том 
что драйвер фс возьмем этот поток байтов и должен понять какой же симольный путь 
имеел ввиду юзер в терминале. тоеть драйвер фс условного говорят должен взять и перекодировать обратно поток голвый байтов в символьный вид чтобы понять к какой папке и  каому файлу мы стучимся. когда он поймет что мы ищем папку "/1/" то понятно как он будет
дествоать. он поудет в иноду <2> которая всегд а отвечает за корневой радлел. там среди 
списка ентри в датаблоках иноды 2 он найдет ентри с именем 1 коорй укзывает на иноду 
отвечающую за папку 1. пойдет в эту иноду там зайдет в дата блоки этой иноды и там надйет
ентри с именем vasya.txt в байтовм представлнии. увидит на какую иноду указвыает эта ентри
и в итоге наконец попадает  в файл вася  сможем его прочитать. так вот я говрю что драйверу фс когда он получит изначлаьно просто поток байтов надо будет в них увидеть путь от корня до той папки в которой лежит файл. и здесь однозначно ядро длжжно будет пользоваться кодировкой
utf8. без нее никак. тоесть ядро как то должно знать какая кодроовка была уюзера в терминале
иначе полученый путь к файлу в байтовом виде никак не дешифроваь в символьный вид.
 и это очень интересны и тонкий момент. 

возрашяаясь к симлинку и команде cat

# cat ./petya

где petya это символаная ссылка на /1/vasya.txt

я думаю что работает шарамка вот как - команда cat передает ядру чтобы он прочиал
файл petya. ядро находит этот файл petya. доходит до его иноды. там видит что инода содержит в себе инфо о файле тип которого симлинк . потому что да 
в иноде самое первое поле которое у нее стоит это поле длинной два байта называется
i_mode . в этом поле много чего пропиывается но в частности проыпиывается тип файла
который закодирован вэтой иноде

EXT2_S_IFSOCK   0xC000  socket
EXT2_S_IFLNK    0xA000  symbolic link
EXT2_S_IFREG    0x8000  regular file
EXT2_S_IFBLK    0x6000  block device
EXT2_S_IFDIR    0x4000  directory
EXT2_S_IFCHR    0x2000  character device
EXT2_S_IFIFO    0x1000  fifo

поэтому я считаю что драйвер понимает что это еще не конец. читает то что сидит 
в i_block этой иноды. а там находится в байтовом виде закоодироывнный символьный путь
к истиному файлу. он его декодррирует через utf8 получает новый путь и начинает 
искать файл с самго начала. так я удмаю этоработает.
так вот если в i_block символльной ссылки харнится какйото мусор то есть
несузетвующий путь то видимо драйвер фс понимает это и останаливается.

но вот это меня поражает - мы в терминале указывае мв символьном виде путь к файлу.
терминал его кодирует в байтовый вид и пихает в команду ls, cat , cd итп.
далее эти команды передают эти байты в ядро. ядро передает драйверу фс. и он 
вынужден перекодировать обратно байты типа в симвлольный вид при этом он должен знать
ту кодировку которая использовалась при кодирваии этих байтов иначе он поулчит мусор.
и вот вопрос откуда дрйвер фс узнает исходную коодиовку??? непояннто.

оказалось это все очень даже нпростой вопрос. 
вот ссылки
https://unix.stackexchange.com/questions/39175/understanding-unix-file-name-encoding
https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html
там нашел что за linux  path name lookup отвечает в ядре 
функция namei()

вот ее код  https://elixir.bootlin.com/linux/latest/source/fs/namei.c
я там даже вот такое нашел

/*
         * If it wasn't NUL, we know it was '/'. Skip that
         * slash, and continue until no more slashes.
         */
        do {
            name++;
        } while (unlikely(*name == '/'));
        if (unlikely(!*name)) {

мы видим здесь указан в явном виде slash '/'
прикол в том что в оперативной памяти не будет никакго '/' там будет последователность
байтов. вопрос каких? на оснве какой кодировки?

так вот из того что я нашел по ссылке на стекэксчендж это то что в ядре якобы
захардокожено (видимо в этой namei.c) что имя файла\папки не может содержать
байты вида 00(hex) и 2F(hex) 
якобы первый это NUL символ а второй это slash символ. и похуй какая там у тебя
кодировака в твоем терминале. это якобы захардкожено. и тода я кобы ядро действеи так - оно берет поток байтов который ты ей сунул где нарисован путь к файлу и ищет в нем 2F
и принимает что это знак слешей тоесть это признак разделителя между папками. ну после
этого все понятно дальше. 
однако говрю что в коде  я этого 2F ненашел в namei.c
только со слов людей со стекэксчендж.
у меня возникает вопрос - если 2F захардкожен в ядре то как на мбыть с компами 
на которых устанолвен utf-16 или utf-32 там. ведь дело вот  в чем. мы в терминале пишем
# cd /1
тыкаем enter. термиал берет и эту строку кодирует на основе кодировки указанной на компе
(предположим это utf-16 или utf-32) в поток байтов и отсылает в баш который за этим
терминалом крутится. баш в коненом итоге вызывает сисколл и передает ему этот поток байтов.
в итоге это прилетает в ядро. и оно начинает анализиоваьт присланный поток байтов в котором
закодирован наш путь "/1"
так вот когда терминал кодировал "/1" в поток байтов он закодирует слэш как 002F (UTF-16) или
0000002F (UTF-32) и как бы окей если мы считаем что 2F разделяет названия папок это работает
даже в этом случае но тогда получится что нуль байты будут отнесены к названияем папок, 
но как я сказал выше в линуксе также закодировано что нуль байты 00 не могут входит в названия файов  и папок и по идее линукс выдаст ошибку что мы ему подсунули путь с нуль байтами в именах файлов. так как тогда это работает в ядре лиукса в случае коогда 
у юзера в терминале указан utf-16 или utf-32.????
в случае когда на компе в терминале исползуется ASCII или UTF-8 проблем нет
потому что в этом случае знак слэша кодирвется через 2F(hex) тоесь все окей вэтих сдучаях.

из того что я сказал выше вытекает правило что имя файла\папки не может содержать нуль байты 00(hex) и слэш 2F(hex)

я провел эксеоимент

# echo -n -e "/home" | hexyl
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 2f 68 6f 6d 65          ┊                         │/home   ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

пееркодировал путь к файлу в hex
и сделал переход на основе указания пути сразу в hex формате
отраблотало отлично
# cd  $( echo -n -e "\x2F\x68\x6f\x6d\x65" )
# pwd
/home



теперь я добавил 00 перед 2F сэмулировав как бутто  уменя на компе utf-16

# cd  $( echo -n -e "\x00\x2F\x68\x6f\x6d\x65" )
bash: warning: command substitution: ignored null byte in input
# pwd
/home

сработал но ругается

вобщем пока так как на линукса в целом стоит взде utf-8 буду считать
что фс драйвер получает байты и там ищет 2F. основе этого он разрезает 
последовательность и все что между считает названиями папок и файлов.
окей пока на этом оставновимся.


далее.
команда у дебагфс покызвает поля в иноде

debugfs: sif -l
Inode fields supported by the set_inode command:
        mode                            unsigned integer
        uid[_hi|_lo]                    unsigned integer
        size[_hi|_lo]                   unsigned integer
        atime[_hi|_lo]                  date/time
        ctime[_hi|_lo]                  date/time
        mtime[_hi|_lo]                  date/time
        dtime                           date/time
        gid[_hi|_lo]                    unsigned integer
        links_count                     unsigned integer
        blocks[_hi|_lo]                 unsigned integer
        flags                           unsigned integer
        version[_hi|_lo]                unsigned integer
        translator                      unsigned integer
        block[12]                       unsigned integer
        block[IND]                      unsigned integer
        block[DIND]                     unsigned integer
        block[TIND]                     unsigned integer
        generation                      unsigned integer
        file_acl[_hi|_lo]               unsigned integer
        faddr                           unsigned integer
        frag                            unsigned integer
        fsize                           unsigned integer
        checksum[_hi|_lo]               unknown
        author                          unsigned integer
        extra_isize                     unsigned integer
        ctime_extra                     unsigned integer
        mtime_extra                     unsigned integer
        atime_extra                     unsigned integer
        crtime[_hi|_lo]                 date/time
        crtime_extra                    unsigned integer
        projid                          unsigned integer
        bmap[]                          set physical->logical block map




далее. 
поле "Links:" в иноде показыает сколько хардлинков есть которые 
ссылатся на эту иноду. как только число хардлинков станет ноль 
драйвер фс зачистить иноду








далее. у нас есть фичи которые акитивируются когда форматируется фс. так вот 
эти фичи это флаги котоыре будут записаны в суперблоке.
все доступные фичи суперблока котоыре потцениально можно активировать можно
посмотреть в дебагфс

debugfs:  supported_features 
Supported features: dir_prealloc imagic_inodes has_journal ext_attr resize_inode dir_index sparse_super2 fast_commit stable_inodes filetype needs_recovery journal_dev meta_bg extent 64bit mmp flex_bg ea_inode metadata_csum_seed large_dir inline_data encrypt casefold sparse_super large_file huge_file uninit_bg dir_nlink extra_isize quota bigalloc metadata_csum read-only project shared_blocks verity
 journal_incompat_revoke journal_64bit journal_async_commit journal_checksum_v2 journal_checksum_v3 FEATURE_I5


при форматировании (по факту в суперблоке ) можно указать фичу "dir_index"

# mkfs.ext4 .... -O dir_index
либо tune2fs
либо через debugfs активировать 

это дает то что в теории можно чтобы в иноде котоорая отвечает за папку
там ентри были записаны не в формате линейного списка
а формате hash tree.

для этого еще нужно персонально в иноде которая отвечает за папку
нужно персонально еще актививоровать флаг (EXT4_INDEX_FL)
что такое флаг в иноде - да в иноде есть поле 32 (LE) бита длинной. в нем можно
выставлять флаги котоыре тоже активируеют фичи. 
кстати ext драйвер сам активирует этот флаг в иноде если число ентри в папке
начнет зашкаливать


0x1000  Directory has hashed indexes (EXT4_INDEX_FL).

0x1000(hex) это покаано куда надо выставлять бит. = 1000000000000
вопрос как активировать флаг в иноде.


создаю папку. смотрю ее свойства иноды
Inode: 246022145   Type: directory    Mode:  0755   Flags: 0x80000

этот флаг говорит о том что инода юзает экстенты.

значит нам надо добавить флаг 0x1000 
расклаыдваем в бинарный вид 0x1000 и 0x80000 и складываем. а далее
самое интересное надоб результат преобразваовать в dec вид. потому что 
дебагфс сука покаывзает значение флага в hex виде а позволыет менять этот флаг 
принимая аргумент в десятичном виде. 

$ echo "obase=10; ibase=16;  80000 + 1000" | bc
528384


debugfs:  sif   <246022145> flags  528384

проверяем резулаттат

debugfs: stat   <246022145> 
Inode: 246022145   Type: directory    Mode:  0755   Flags: 0x81000
Generation: 1096749310    Version: 0x00000000:00000001

единсвтенное то что установив флаг EXT4_INDEX_FL руками
у нас же приэтом в иноде структура енри  осталась прежняя линейная
поэтому если мы натравим e2fsck то увидим

# e2fsck -f /mnt/10T.txt 
e2fsck 1.46.5 (30-Dec-2021)
Pass 1: Checking inodes, blocks, and sizes
HTREE directory inode 246022145 has an invalid root node.
Clear HTree index<y>? 

кстати после проверки бит EXT4_INDEX_FL будет сброшен.
тоесть e2fsck отменит наши ручные действия

смотрим
debugfs: stat <...>
Inode: 246022145   Type: directory    Mode:  0755   Flags: 0x80000
Generation: 1096749310    Version: 0x00000000:00000001


имеем флаг 0x80000 
флаг имеет 32 бита длинной значит 0x80000(BE) = 0008 0000 (BE) =
 = 0000 0800 (LE)

флаг на ext запиывается в формате LE.
ищем его в дампе иноды. у него офссет 0x20 это 32байт но помним что офссет начинается
 с нулевого байта поэтому надо искать c 33-ий байт ( и длинна 32 байта)

:  inode_dump <246022145>
0000  ed41 0000 0010 0000 2330 b464 702b b464  .A......#0.dp+.d
0020  702b b464 0000 0000 0000 0200 0800 0000  p+.d............
0040  0000 0800 0100 0000 0af3 0100 0400 0000  ................
0060  0000 0000 0000 0000 0100 0000 0000 5075  ..............Pu
0100  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 fe10 5f41 0000 0000 0000 0000  ......_A........
0160  0000 0000 0000 0000 0000 0000 6451 0000  ............dQ..
0200  2000 661e e033 12c7 e033 12c7 504b 6e7e   .f..3...3..PKn~
0220  702b b464 e033 12c7 0000 0000 0000 0000  p+.d.3..........
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

из дампа видим что начиная с 33-его байта кусок длтннной 4 байта это 

0000 0800 что совпадает с расчетами 0000 0800 (LE)


так с флагом в супер блоке dir_index и с флагом в иноде EXT4_INDEX_FL
и как ставить флаги в иноде руками - разобрались







далее
поговрим про подпапки.
создаем пустую папку /mnt/01
у нее будет инода 3345
инода 3345 содержит два хардлинка
"." -> указывает на 3345
".."-> указвыает на иноду 4567 от родительской папки "/mnt" 

в родительской папке "/mnt" есть ентри
"/mnt" --> указеат на иноду папки "/mnt/01"  3345

таким образом создавая "пустую" у нас уже есть два хардлинка
(один в иноде от нашей папки второй в иноде рдительской папки)
которые укаызают на иноду нашей "пустой " папки. 
это значит что в свойствах иноды 3345 нашей пустой папки 
в поле "Links" будет стоять число 2 

далее мы создаем подпапку "/mnt/01/a" при этом занимается новая  инода 6667 
при этом в иноде 3345 создается новый ентри . он нас щас мало интересует

в иноде 6667 создается два ентри
"." --> 6667
".." --> 3345

это дает то что у нас на ФС пояилися +1 хардлинк который ведет на 3345 "/mnt/01"
занчит в иноде 3345 "Links" станет равным 3.

таким образом каждый раз создаавя подпапку  в папке /mnt/01/
у нас будет увелчитваться Links в иноде 3345

возникает вопрос насколько много может увеличиваться поле Links
ответ поле Links хранится в формате 16 бит. значит в целом число подпаппок
макс может быть ~ 65 000 штук 

а вот дальге непонятно если мы  при формтаровании активруем фичу "dir_nlink"
то после того как у нас число подпапок превысит 65535 щтук (16бит) то это поле станет 
равным 1 и далее ext4 не будет как я понял прибавлять это поле при дальнейшем увеличении
числа подпапок. окей это ладно. вопрос в другом если мы в обратную сторону начнем
удалять подпапки то что будет с этим полем? ведь это поле являтся главынм критерием 
что иноду надо обнулять. как фс опредяет что быд удален последний хардлинк если оно 
перестает менять это поле?

проверим на практике.
поверим что фича "dir_nlink" активрована
# debugfs /mnt/10T.txt 
debugfs 1.46.5 (30-Dec-2021)
debugfs:  feature
Filesystem features: has_journal ext_attr dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum

создаем тучу подпапок
# for i in {1..65530}; do mkdir $i; echo -n -e  ">>> $i\r"; done

# ls -1 /mnt/ext4/09 | wc -l
65532

проверыем параметр "Links"

# stat /mnt/ext4/09
  File: /mnt/ext4/09
  Size: 1437696     Blocks: 2816       IO Block: 4096   directory
Device: 705h/1797d  Inode: 161480705   Links: 1

вилим что "Links" =1 

додовдоим число подппакок до 80000
# ls -1 /mnt/ext4/09 | wc -l
80002

проврыяем Links

# stat /mnt/ext4/09
  File: /mnt/ext4/09
  Size: 1966080     Blocks: 3848       IO Block: 4096   directory
Device: 705h/1797d  Inode: 161480705   Links: 1

по прежнему 1.

кстаи что происхдодит при создании папки:  на фс занимается новая инода. в этой иноде
создается два ентри один на текущйю папку второй на родительскую
"."  -> текущая инода
".." -> инода  родитеслькой папкм
число Links в нойо иноде высталяет =2

в родитесоктй папке создается ентри
"имя_новой папки"  -> инода новой папки
число links в родитеслкой иноде высталяется +1

кстати обратый процесс очень забввный. мы хотим удалить хардлинк для "/mnt/01"
для этого мы идем в иноду "/mnt" находим там ентри но мы неможем его так вот взять и удалить
как это было бы в случае файла. надо пойти в иноду "/mnt/01" зайти в ее тело
найти все entry но их тоже удалять нельазя. надо пойти в кажду иноду на которую ссылаются те ентри и если это файл то их можно уадлить а если это папка то надо опят идти дальше 
и глубже. таким образом пока мы все не вычистим у детей нельзя будет удалить хардлинк "/mnt/01" в иноде "/mnt". это прикол.
если мы просто удалим харддинк "/mnt/01" в иноде "/mnt" то у нас будет вот какая проблема - у нас на ФС останется целая огромная куча инод занятых. это важно подчеркнуть занятых 
инод всеми теми дочерними файлами и подпапками что сидят внутри /mnt/01
мы о них уже знать ничего не будем потому что ниточка к ним их родтельская папка /mnt/01 ее хардлинк уничтожен. а все дочерние обьекты по факту в потерянном состоянии будут занимать иноды на ФС. поэтому надо перед уалением родиельской папки условно говоря освободить 
все иноды и все дата блоки котоыре заняты дочерними обьектами. удивительно. я только щас понял зачем мы вычищаем дочерние обьекты перед тем как удалить родителький. ведь вроде как кажется зачем мучаться удалнеием дочерних обьектов в явном виде давайте просто удалим
головной хардлинк они все потеряются ну и хорошо. будет очень быстрый процесс удалеием
папки с массой подпапок. да это так. но нам надо освободить все иноды и все датаблоки
каотоыре занимают дочерние обьекты.
удвительно.

тепрь начинаем обартный процесс. начинаем уменьшать число подпапок /mnt/09

# for i in {80000..65530}; do rmdir $i; echo -n -e  ">>> $i\r"; done

зачему что секвенсы в баше можно укывазть как в стороу увеличение шага
так и вс торону уменьшения щага

# ls -1 /mnt/ext4/09 | wc -l
65531
root@vm1:/mnt/ext4# stat /mnt/ext4/09
  File: /mnt/ext4/09
  Size: 1966080     Blocks: 3848       IO Block: 4096   directory
Device: 705h/1797d  Inode: 161480705   Links: 1

пока что Links=1

продолжим удалять подпаки дальше
# for i in {65530..32769}; do rmdir  $i; echo -n -e  ">>> $i\r"; done

# ls -1 /mnt/ext4/09 | wc -l
32769
root@vm1:/mnt/ext4# stat /mnt/ext4/09
  File: /mnt/ext4/09
  Size: 1966080     Blocks: 3848       IO Block: 4096   directory
Device: 705h/1797d  Inode: 161480705   Links: 1

продолжаем удалять дальше
# for i in {32769..100}; do rmdir  $i; echo -n -e  ">>> $i\r"; done

# ls -1 /mnt/ext4/09 | wc -l
100
root@vm1:/mnt/ext4# 
root@vm1:/mnt/ext4# stat /mnt/ext4/09
  File: /mnt/ext4/09
  Size: 1966080     Blocks: 3848       IO Block: 4096   directory
Device: 705h/1797d  Inode: 161480705   Links: 1


# for i in {100..10}; do rmdir  $i; echo -n -e  ">>> $i\r"; done

# stat /mnt/ext4/09
  File: /mnt/ext4/09
  Size: 1966080     Blocks: 3848       IO Block: 4096   directory
Device: 705h/1797d  Inode: 161480705   Links: 1


# cd /mnt/ext4/09
root@vm1:/mnt/ext4/09# ls -1al
total 1928
drwxr-xr-x 1 root root 1966080 Jul 16 20:05 .
drwxr-xr-x 9 root root    4096 Jul 16 18:36 ..

# stat /mnt/ext4/09
  File: /mnt/ext4/09
  Size: 1966080     Blocks: 3848       IO Block: 4096   directory
Device: 705h/1797d  Inode: 161480705   Links: 1


вот мы видим пустую папку. а число links=1
хотя как мы помним пустая папка имеем два хардлинка. тоесть как только links=1
то он перестал отображать число хардлинков.

кстати отходим в сторону 
# rmdir  -v ./.
rmdir: removing directory, './.'
rmdir: failed to remove './.': Invalid argument

# rmdir  -v  "/mnt/ext4/10/."
rmdir: removing directory, '/mnt/ext4/10/.'
rmdir: failed to remove '/mnt/ext4/10/.': Invalid argument


видно что rmdir почемуто неумеет удалять папку "."

вобщем я витоге просто удалил папку
# rmdir  -v  "/mnt/ext4/10"
rmdir: removing directory, '/mnt/ext4/10'

так как даже пустая папка имеет два хардлинка то Links всегда >=2
а если Links=1 это невозмодная ситация. если это так. значит в какойто момент 
число хардлинков на эту папку превзошло 65535 и после этого поле линкс драйвер 
приравнивает к 1. и далее это поле уже никаокго физ смысла не несет.

я думаю что поле links ненесет той важной функции которую несет это поле в случае
иноды для файла. для файла эта функция важно покаызает можно иноду занулять или нет.
процесс зануления иноды для папки она в любом случае совершенно другая - драйвер 
должен пройти по всем ентри этой папки и удалить все что ниже всех детей.  такого не может
быть такого чтобы была папка которая ссылается на нашу папку а в нашей папке небыло бы 
ентри на ту папку. поэтому если мы занулили все ентри для всех дочерних обьектов то 
тогда можно удалять иноду папки. поэтому для процесса удаления папки поле Links 
роли неиграет. поэтому можно поставит в links=1 и это никакой роли неиграет. да мы незнаем
сколько хардлинков указывает при этом на нашу папку. но это не критично. 
 янашел в интернете (https://gitlab.sdu.dk/sdurobotics/linux-kernels/kernel/-/blob/focal/Ubuntu-5.4.0-31.35/Documentation/filesystems/ext4/inodes.rst) обьяснение что если Links=1
это означает что число хардлинков НЕИЗВЕСТНО. так надо расшифроварвывать это.


далее. 
отойдя в сторону хотел описать еще раз как работает 
связь между утилитами консоли и терминалом. 

- описать потрясабщую вещь
for i in {32769..100}; do rmdir  $i; echo -n -e  ">>> $i\r"; done

что к примеру коамнда echo да вообще любая команда косоли она никакие смиволы из себя
не высирает. они высирают на stdout поток байтов. этот поток передается на физ устройство
терминал. и ему надо понять а какже эти символы отрисовать на экране, нужна разметка.
так вот консольные команды они в поток байтов котоыре содержат информацию вставляют
специальные байты которые подсказывают терминалу что мол в данном месте нужно 
перейти на новую строку. таким макамро конс утилиты вместе с информацией передают еще и разметку. только благодаря ей терминал понимает по какому шаблону надо размещать символы
на экране. без этих спец байтов он бы просто принимал байты из stdout косольной утилиты 
рисовал символ за символом до конца строки а потом переходил бы сам на другую строку
и начинал опять символ за символом. на экране бы была сплошная монолитная стена.

берем пример 
$ echo "1"
1

# echo "1" | hexyl
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 31 0a                   ┊                         │1_      ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

черех хексил мы видим какой по факту байтовый поток летит из echo на терминал.
летит два байта 31 и 0a
в UTF-8 31 означает "1" а 0a означает перейти в новую строку (на одну строку вниз отмотать как на печатной машинке и плюс возвратить печаатающую головку каретку в начало строки).
так вот терминал так и делает. у него по дефолту печатная головка находится в начале строки.
он получает 31 и рисует в начале строки знак "1" далее он получает 0a и понимает намек. 
и он прокручитвает сторку на однувверх и возвращает печатную головку в начало строки.
термина это как принтер. если им нерукводоить то он просто будет щарашить буквы одну за одной
превращая байтовый входящий поток в кашу из букв. управляющиебайтй подсказааывают теминалу
куда кога и как нужно перемещать печатную головку перед печатью следущего символа.

сейас я закодирую напрямую через байты тот поток который  я хочу преедать от echo к
терминалу

# echo -n -e "\x31\x0A\x20\x20\x31\x20\x0A" | hexyl
┌────────┬─────────────────────────┬─────────────────────────┬────────┬────────┐
│00000000│ 31 0a 20 20 31 20 0a    ┊                         │1_  1 _ ┊        │
└────────┴─────────────────────────┴─────────────────────────┴────────┴────────┘

hexyl подтверждает что поток будет ровно такой какой я заказал

запускаем поток на терминал .посмотрим как он его "напечататет"

# echo -n -e "\x31\x0A\x20\x20\x31\x20\x0A" 
1
  1 

все верно. я заказал напечатать 1 и перейти в новую строку (при переходе в новую строку
печатная головка возвращается в левопе положение).
далее я заказал апечатать два пробела , далее печаатем единицу, далее перенос строки.
терминал так все и сделал.

в какйото степени это поразительно что консольне команды они шлют только поток байтов.
плюс добавляют туда управляющие байты и терминад как принтер интерпретирует эти байты
и преврашает их на экране в графическую картинку.
итак утилиты консоли они ничего не рисуеют на экране. они грубо говоря шлют электирические
сигналы на принтер он же терминал. и терминал превращает байты(элеакические сигналы)
в графическую картинку.
чудо..





далее.
экстент согласно статье из LWN это:
  extents (first block, number of blocks)





далее
разбираю что такое "huge_file"
тоесть
что нам дает фича "huge_file" в суперблоке 

во первых что странно что вроде как это фича ext4 но яя могу активирвать даже
на ext2. проверяю через e2fsck и никаких ошибок.. непоннятно.

# debugfs -w /mnt/1G-ext2.txt
debugfs:  features huge_file
Filesystem features: ext_attr dir_index filetype sparse_super large_file huge_file

# e2fsck -f /mnt/1G-ext2.txt 
e2fsck 1.46.5 (30-Dec-2021)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
/mnt/1G-ext2.txt: 11/65536 files (0.0% non-contiguous), 4127/262144 blocks

 dumpe2fs -h /mnt/1G-ext2.txt  | grep feature
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      ext_attr dir_index filetype sparse_super large_file huge_file

непонянтно.

также попутно еще раз подчкеркиваю что непонятно как руками проверить какая же у нас
ФС на  диске = ext2/3/4

почемуто дебагфс никакойтакой инфо не предоставляет.
в суперблоке тоже такой инфо нет.

единсвтенный способ это 
# lsblk -f  если хотим унать какая фс на блочном устройстве
либо 
# parted и его команда print
если фс создана на базе обычного файла то версию фс мжоно узнать через команду
$ file ./имя_файла


ладно. возврашаемся к "huge_file"  фиче супрблока


вот здесь ( https://gitlab.sdu.dk/sdurobotics/linux-kernels/kernel/-/blob/focal/Ubuntu-5.4.0-31.35/Documentation/filesystems/ext4/inodes.rst ) читаю: 

Lower 32-bits of “block” count. If the huge_file feature flag is not
set on the filesystem, the file consumes i_blocks_lo 512-byte blocks
on disk. If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in
inode.i_flags, then the file consumes i_blocks_lo + (i_blocks_hi
<< 32) 512-byte blocks on disk. If huge_file is set and
EXT4_HUGE_FILE_FL IS set in inode.i_flags, then this file
consumes (i_blocks_lo + i_blocks_hi << 32) filesystem blocks on
disk.


я все никак не мог понять что за i_block_lo(32bit) и i_block_hi(16bit)
а потом нашел статью - https://lwn.net/Articles/254535/
из нее становится понятно что они запилили поддержку чтобы количество блоков (пока только непонял блоков чего? на диске те котоыре LBA или блоков ФС? или каких нахер блоков) было
48-бит. тоесть адрес блока составляет число длинной 48бит. 
если блок имеет размео 1KB то суммарный размер такого числа блоков будет
2^48(штук блоков) * 1 / (2^10 * 2^10 * 2^10) = 2^18 = 262144 TB
если размер блока 0,5KB то суммарный размер блоков даст 131072 TB

так вот i_block_lo это младшие 32 бита адреса блока из 48 бит. 
i_block_hi это старшие 16 бит адреса блока из 48 бит. 
они распилили 48битное число на две группы битов. и положили их в разные 
части иноды.

i_block_lo лежит в иноде в оффсете 0x1C в формате 32(LE)
i_block_hi лжет в иноде в оффссете 0x74 в формате 16(LE)

0x1C= 28
0x74=116

помним что офссет начинается с нулевого оффсета. 


далее опять смотрим на запись
Lower 32-bits of “block” count. If the huge_file feature flag is not
set on the filesystem, the file consumes i_blocks_lo 512-byte blocks
on disk. If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in
inode.i_flags, then the file consumes i_blocks_lo + (i_blocks_hi
<< 32) 512-byte blocks on disk. If huge_file is set and
EXT4_HUGE_FILE_FL IS set in inode.i_flags, then this file
consumes (i_blocks_lo + i_blocks_hi << 32) filesystem blocks on
disk.


у меня на ext4 фича "huge_file" активирована. однако я создам небольшой файл 
у которого в иноде флаг "EXT4_HUGE_FILE_FL" не будет активирован. значит
нам тогда подходит строчка

If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in
inode.i_flags, then the file consumes i_blocks_lo + (i_blocks_hi
<< 32) 512-byte blocks on disk.

временно отойду в строну и скажу что диск состоит из блоков.
они имеют адреса (LBA адреса).с диска можно считать данные не в формет отденого
байта а толко в форме целого блока байтов. мы задаем номер LBA блока и просим 
его считать. диск читает блок и выдает нам его. наример

# dd if=/dev/nvme0n1p2  bs=512 count=1 skip=$( echo "32811520 * 8" | bc  ) | xxd
1+0 records in
1+0 records out
512 bytes copied, 5,5691e-05 s, 9,2 MB/s

00000000: 0d0a d0a3 d0a1 d0a2 d090 d09d d09e d092  ................
00000010: d09a d090 204b 5542 4552 4e45 5445 530d  .... KUBERNETES.
00000020: 0a0d 0a0d 0a0d 0ad0 bed0 b1d1 89d0 b0d1  ................
...

как узнать количество блоков на разделе диска
ответ на пойти на /sys
# cat /sys/block/nvme0n1/nvme0n1p2/size
999163904


как узнать размер сектора на диске.
один вариант зайти в parted и там набрать print

другой вариант опять же зайти на /sys

# ls -1 /sys/block/nvme0n1/queue | grep size
hw_sector_size
logical_block_size
max_segment_size
minimum_io_size
optimal_io_size
physical_block_size

# cat  /sys/block/nvme0n1/queue/*size 
512
512
4294967295
512
0
512


как видно указана какая токуча сайзов. какой именно из них отвечат 
за LBA размер блока надо уточнять. в данном сулчае по любому размер блока 512 байт.
и таких  блоков на разделе  в  штуках 999163904 (число которое мы получили ранее выше)


возвращаеся обратно к нашим баранам
у меня на ext4 фича "huge_file" активирована. однако я создам небольшой файл 
у которого в иноде флаг "EXT4_HUGE_FILE_FL" не будет активирован. значит
нам тогда подходит строчка

If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in
inode.i_flags, then the file consumes i_blocks_lo + (i_blocks_hi
<< 32) 512-byte blocks on disk.



# fallocate -l 1G 1G.txt
# stat 1G.txt 
  File: 1G.txt
  Size: 1073741824  Blocks: 2097160    IO Block: 4096   regular file
Device: 705h/1797d  Inode: 161480707   Links: 1


debugfs:  inode_dump  <161480707>
0000  a481 0000 0000 0040 4479 b464 4479 b464  .......@Dy.dDy.d
0020  4479 b464 0000 0000 0000 0100 0800 2000  Dy.d.......... .
0040  0000 0800 0100 0000 0af3 0100 0400 0100  ................
0060  0000 0000 0000 0000 0180 004d 0000 6c4d  ...........M..lM
0100  0078 0000 00f8 0000 0078 6c4d 00f0 0000  .x.......xlM....
0120  00f8 0000 00f0 6c4d 0068 0100 00f8 0000  ......lM.h......
0140  0068 6d4d 67bc b9fe 0000 0000 0000 0000  .hmMg...........
0160  0000 0000 0000 0000 0000 0000 9835 0000  .............5..
0200  2000 a600 1485 11d2 1485 11d2 f060 1dd1   ............`..
0220  4479 b464 f060 1dd1 0000 0000 0000 0000  Dy.d.`..........
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*



смотрим вот это 

i_block_lo лежит в иноде в оффсете 0x1C в формате 32(LE)
i_block_hi лжет в иноде в оффссете 0x74 в формате 16(LE)

0x1C= 28
0x74=116

помним что оффсет начинаетс я с нуля занчит надо смотеть 29-ый и 117-ый байт

значит 
i_block_lo = 0800 2000 (32LE) =  0020 0008 (BE)  
i_block_hi = 0000 (16LE) =  0000 (BE)

тогда у нас полное 48 битное число  будет 
0000 0020 0008 = 2097160

это ровно то число которое в stat отображатеся в колонке

Blocks: 2097160

получается что  i_block_hi+i_block_lo (48 битное число) обозначает размер файла на диске
в блоках. как видно из вот этого текста


Lower 32-bits of “block” count. If the huge_file feature flag is not
set on the filesystem, the file consumes i_blocks_lo 512-byte blocks
on disk. If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in
inode.i_flags, then the file consumes i_blocks_lo + (i_blocks_hi
<< 32) 512-byte blocks on disk. If huge_file is set and
EXT4_HUGE_FILE_FL IS set in inode.i_flags, then this file
consumes (i_blocks_lo + i_blocks_hi << 32) filesystem blocks on
disk.


в ряде случаев под блоком подразмуевается хрень размером 512 байт.
а других случаях под блоком подразумевается хрень равна размеру ФС блока.

посольку i_block_hi+i_block_lo описывает не виртуальный размер файла (который видит приложеие) а реаьный размер файла на диск бекенде (правда описывает его не байтах а вблоках)
то получается что (i_block_hi+i_block_lo) являются неким фактором который позволяет сказать 
каков верхний предел для размера файла. потому что файл не может быть по размеру больше
чем то число блоков которое может в себе закодировать  (i_block_hi+i_block_lo)
так вот возврашаемся к нашему вопросу. что дает фича huge_file.
смоирим что говорит текст для случая когда у нас эта фича неактивирована


If the huge_file feature flag is not
set on the filesystem, the file consumes i_blocks_lo 512-byte blocks
on disk.

тоесть число блоков которые файл занимает на диске в этом случае будет кодирваться 
через i_block_lo. поскольку он размером 32 бита то макс возможный размер файла в
таком случае это 2^32 блоков причем каждый блок размером 512 байт жестко подразумевается.
512 байт это 2^9 байт.
значит макс размер файла это 2^32 * (2^9) байт = 2^41 / (2^10 * 2^10 * 2^10 * 2^10) = 
= 2^41 / 2^40 = 2^1 = 2 ТБ 

тоесть мы можем сказать что при остуствиии фичи "huge_file" макс размер файла
котрый мы можем создать это 2 ТБ.

соотвественно если мы активируем эту фичу huge_file при форматиорваинии ФС в суперблоке.
и при этом мы в иноде не выставляем флаг EXT4_HUGE_FILE_FL
то у нас ситуация другая

If huge_file is set and EXT4_HUGE_FILE_FL is NOT set in
inode.i_flags, then the file consumes i_blocks_lo + (i_blocks_hi
<< 32) 512-byte blocks on disk.

наш размер файла задается уже 48битной цифрой (i_block_hi...i_block_lo)
и макс размер файла тогда будет в блоках состалвять 2^48 штук. 
при этом жестко поразумевается что размер блока 512 байт это 2^9 байт.
тогда макс размер файла в байтах будет 2^48*2^9
а размер файла в терабайтах будет 2^48*2^9 / 2^40 = 2^17 терабайт. = 131072 терабайт.
это просто дофига.

тоесть активация huge_file рещает все проблемы с ограничеием на макс размер файла
в настоящий момент. его просто за глаза.

есть и еще одна опция EXT4_HUGE_FILE_FL IS set.  я ее рассмотрю позже.

а щас рассмотрим вопрос
 i_block он показывает размер тела файла на диске или еще и метаданные включает в себя?
выше я создавал файл разамером 1G

# fallocate -l 1G 1G.txt
# stat 1G.txt 
  File: 1G.txt
  Size: 1073741824  Blocks: 2097160    IO Block: 4096   regular file
Device: 705h/1797d  Inode: 161480707   Links: 1

я получил что i_block* в себе содержит число 2097160
ровно то число которое показывает stat в "Blocks: 2097160"

мы знаем что файлы на ФС сохраняются кратно блоку ФС. у нас он 4К.
значит перевдем эти ебнутые вирт блоки в блоки ФС  2097160 * 512 /4096 = 262145 блоков фс (размеро 4К)

а теперь возьмем наш исходный заказанный нами 1G и переведем его тоже в 4K блоки =
= 1024×1024÷4 = 262144

получается тело файла дожно было занимать 262144 блоков ФС а оно занимает 262145
тоесть больше. почему?
вспомним из чего состоит файл => запись ентри в папке директори иноды + инода в таблице инодов + метаданные иноды которые в иноду не влезли (дерево экстентов) которые сохраняются 
в зону дата блоков вне зоны метаданных вне зоны таблицы инодов + чистые данные файла тоесть его тело. 

так вот вопрос что создатели ext вкладывают в понятие размер файла в блоках в
переменной i_block_* 
я полагаю что они туда суммируют чистое тело файла + те блоки метаданных которые не влезли в иноду в которых хранится дерево экстентов (эти блоки метаданных сохраняются в туже область блоков что и тело файла). 

по моей прикидке дерево экстентов для этого файла суммарно видимо и занимает 1 блок ФС (4К)
почему я так думаю. потому что вроде как сам экстент по размеру занимает всего 12 байт

ext4_extent Struct
Data Fields
__le32  ee_block
__le16  ee_len
__le16  ee_start_hi
__le32  ee_start_lo

или еще чуть подробнее

struct ext4_extent {
   86     __le32  ee_block;   /* first logical block extent covers */
   87     __le16  ee_len;     /* number of blocks covered by extent */
   88     __le16  ee_start_hi;    /* high 16 bits of physical block */
   89     __le32  ee_start_lo;    /* low 32 bits of physical block */
   90 };


насколко я понимаю ee_block это некое внутрнее число обобзначающее номер экстента 
в дереве. ee_len это длинна экстента  в  блоках судя по всему размером 512 байт.
они называют это физический блок. хотя на диске физ блок может быть 4К размером. 
ну ладно.
ee_start_hi и ee_start_lo это старшие 16 и младшие 32 бита котроые в сумме дают число длиинной 48 бит и обозначают начала экстента тоесть адрес первого блока который размером 
512 байт.

ну вот вобщем размер экстента 12 байт. судя по тому что говории дебаг фс
таких экстентов у файла вот сколько 

> dump_extents <161480707>
Level Entries         Logical                Physical Length Flags
 0/ 1   1/  1      0 - 262143 1291878401              262144
 1/ 1   1/  9      0 -  30719 1298923520 - 1298954239  30720 Uninit
 1/ 1   2/  9  30720 -  61439 1298954240 - 1298984959  30720 Uninit
 1/ 1   3/  9  61440 -  92159 1298984960 - 1299015679  30720 Uninit
 1/ 1   4/  9  92160 - 122879 1299015680 - 1299046399  30720 Uninit
 1/ 1   5/  9 122880 - 153599 1299046400 - 1299077119  30720 Uninit
 1/ 1   6/  9 153600 - 184319 1299077120 - 1299107839  30720 Uninit
 1/ 1   7/  9 184320 - 215039 1299107840 - 1299138559  30720 Uninit
 1/ 1   8/  9 215040 - 245759 1299138560 - 1299169279  30720 Uninit
 1/ 1   9/  9 245760 - 262143 1299169280 - 1299185663  16384 Uninit
(END)


тоесть 9 штук плюс служебная информация по организации дерева. в любом случае это 
все занимает копейки и точно влезет в 4К блок ФС. так что я думаю что лишшний блок 
в колонке Blocks: у stat это блок который хранит дерево экстентов и хранится вне иноды вне зоны метаданных в зоне дата блоков.

прикольно конечно как то странно. получается что изнутри экстент оперирует адресацей на уровне LBA блоков или чтото типа того. а debugfs показывает нам инфо об экстентах 
через блоки ФС (а не LBA блоки).

кстати LBA расшифрывоыватся как Logical Block addressing или сокращенно logical block
так что непутать logical block (lba ) с FS block.

что еще интересно- интересно то что самый большой файл по размеру это тот который
занял все блоки LBA с певрого до посоледнего. так вот что интересно что при этом 
порядковый адрес последнего блока показывает сумму блоков тоесть размер. поэтому
если у нас номер последнего блока равен 2^32 то значит что и количество этих блоков
у нас 2^32.(потому что в глове возникал вопрос о том а вдруг количество блоков выражается
через число которое больше по размеру чем 2^32 а нет). тоже самое верно для 2^48
таким образом разрядоность числа (2^48 либо 2^32) показывает и количество блоков.


читаю у швейцарца ответ по вопоорсу что такое huge_file

huge_file: If huge_file is not set, the maximum size a file can have is 2³² Logical Blocks. If it is set, but EXT4_HUGE_FILE_FL is not set on the inode, that it is possible to have file size of 2⁴⁸ Logical Blocks (very large number). If also EXT4_HUGE_FILE_FL is set, then maximum file size is 2⁴⁸ File System Blocks. 2⁴⁸ Logical Blocks is already a very large number and I think it is not possible because maximum Extent Tree is smaller, so I am not sure why there is a possibility of such a flag on inode.


здесь кажое слово брильянт. во первых надо четко заметить и отличать когда речь идет 
о LBA блоках (logocal block) а когда о File system block.
атак он все точно выразил. если huge_file не активирован при формтровании фс то макс размер 
файла в блоках LBA (logical block) размер которого у создателе фс захардкоден как 512 байт 
будет равен 2^32 блоков. если умножим на 512 байт то получим 2ТБ.
кстати ровно также пишет man ext4
смотрим
# man ext4
huge_file
              This ext4 feature allows files to be larger than 2 terabytes in size.

теперь нам понятно откуда взялась цифра 2ТБ.

если же huge_file активовано то размер файла в блоках макс будет 2^48 блоков.
умножаем на 512 байт получаем 131072 терабайт что мегадохрена.

если же еще активировать  уже в иноде флаг EXT4_HUGE_FILE_FL то 
i_block_* всебе будет содержать цифру отобрающую размер в блоках но не в блоках LBA
а в блоках ФС. так как блок ФС скажем на процессорах интел макс это 4К
 и 4К больше 512 в 8 раз это значит что в этмо случае файл будет иметь макс размер
 как  8*131072 терабайт тоесть ну практически в 10 раз. еще у нас же ext4 подрежваеи 
 размер блока фс в 64К но этонадо иеметь диковинный процессор. тогда размер файла макс 
 уже будет не 10 раз больше а раз в 50.

думаю что в первом приближении я про фичу "huge_file" ответил. что она дает.
хотя осталоась куча вопрососв







у меня остаютс вопросы:
- надо разобраться EXT4_HUGE_FILE_FL для чего
If huge_file is set and
EXT4_HUGE_FILE_FL IS set in inode.i_flags, then this file
consumes (i_blocks_lo + i_blocks_hi << 32) filesystem blocks on
disk.
- зачем они в i_block_* переменной которая указывает размер файл на стораже
привязюыватся к виртуальному размеру непойми какого блока размером 512 байт
- меня смущает что все остальные поля у ext4 оперируют блоками ФС. 
а i_block почемуто оперирует чемто другим









далее.
продолжаю прорабоывать статью швейцарца (https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/)
отличная статья конечно. не плохая
вспоминаю определения - Data Block Bitmap  - это блок ФС в котором каждый битик если он проставлен
он обозначает что соотвествующий блок ФС в группе блоков ииспользуется \ занят.
а если он не выставлен то он свободен \ незанят

далее вспомню как нам искать контент файла на диске 
берем файл
# head p1.py 
#!/usr/bin/python2

import time
from datetime import datetime



f = open("demo.txt", "a")



выясняем его иноду
# stat p1.py 
  File: p1.py
  Size: 368         Blocks: 8          IO Block: 4096   regular file
Device: 705h/1797d  Inode: 24          Links: 1


зная иноду выясняем какие блоки занимает тело файла
# debugfs -R "blocks <24>" /mnt/10T.txt  
debugfs 1.46.5 (30-Dec-2021)
21304348 


зная номер блока фс можем прочитать тело файла напрямую с диска.
блоки фс нумеруются с нуля. тоесть {0....}
значит если мы хотим прочитать блок номер 10. значит нам надо пропустить 
блоки (0,1,2,3,4,5,6,7,8,9) получается что нам нужно пропустить 10 блоков.
получается если нам нужно прочитать блок с номером N, то нам нужно пропустить
блоков в количестве N. 
значит если мы хотим с диска считать блок с номером 21304348 то нам нужно 
пропустить блоков в количестве 21304348
это очень удобно. ненужно ни добавлять ни прибавлять единицу.
# dd    if=/mnt/10T.txt     bs=4K     count=1     skip=21304348    status=none  
#!/usr/bin/python2

import time
from datetime import datetime



f = open("demo.txt", "a")



while True:
  time.sleep(1)
  now = datetime.now()
  print ("===========")
  print ("write to file => date=%s") % (now)
  f.write(repr(now))
  print ("===========")


  print ("read from file :")
  f2 = open("demo.txt", "r")
  print(f2.read())
  f2.close()




f.close()




или можно зная номер блока фс найти для него номер LBA (logica block ) 
и подтсавить в dd номер блока LBA.
LBA адресация тоже начинается с блока номер ноль {0,.....}
получается будет такая схема:
ФС блок {0} состоит из LBA блоков {0,1,2,3,4,5,6,7}
ФС блок {1} состоит из LBA блоков {8,9,10,11,12,13,14,15}

получается если мы хотим прочитать ФС блок {0} то нам нужно в команде dd пропустить 0 LBA
блоков.

если мы хотим прочитать ФС блок {1} то нам нужно в команде dd пропустить 8 LBA блоков 
попробуем формулу N*4096/512 = N*8 где N это номер блока 
f(N=0)=0*8=0  
f(N=1)=1*8=8

тоесть схема работает. если нам нужно прочитать ФС  блок с номером N то в  блоках LBA
нужно пропустить N*8
проверяем
# dd    if=/mnt/10T.txt     bs=512     count=1     skip=$(echo "21304348*8"|bc)    status=none

#!/usr/bin/python2

import time
from datetime import datetime



f = open("demo.txt", "a")



while True:
  time.sleep(1)
  now = datetime.now()
  print ("===========")
  print ("write to file => date=%s") % (now)
  f.write(repr(now))
  print ("===========")


  print ("read from file :")
  f2 = open("demo.txt", "r")
  print(f2.read())
  f2.close()




f.close()



итак если мы запускаем dd и там пишем skip=N  то это значит что в итоге будет 
прочитан блок с номером N (так происходит из за того что блоки что ФС что LBA оба начина
ются с нулевого номера).


теперь я потренируюсь проверять что блок занят но проверять мы будем через Data Block Bitmap
(тоесть через блок ФС в котором на уровне битов закодирована карта блоков которые заняты 
в группе блоков)

найдем какую иноду имеет файл
# stat p1.py
  File: p1.py
  Size: 368         Blocks: 8          IO Block: 4096   regular file
Device: 705h/1797d  Inode: 24          Links: 1


по номеру иноды найдет какие блоки  закодированы в иноде
# debugfs -R " blocks <24> " /mnt/10T.txt 
debugfs 1.46.5 (30-Dec-2021)
21304348 


теперь выполним обратную операцию по номеру блока найдем к какой иноде
блок относится
# debugfs -R " icheck 21304348 " /mnt/10T.txt 
debugfs 1.46.5 (30-Dec-2021)
Block   Inode number
21304348    24


прикинем к какой группе блоков относится блок 21304348 = 21,304,348
в каждую группу блоков входит 32768 блоков при ФС = 4К 
(в группу блоков входит столько блоков сколько битов есть внутри блока ФС. тоесть 
если блок ФС = 4К = 4096 байт * 8 = 32768 бит . поэтому в групу блоков входит 32768 блока )

21304348 / 32768 = 650 + остаток

650*32768 = 21299200 = 21,299,200

значит блок  21304348 входит группу блоков 650. 
проверяем
# dumpe2fs ...
...
Group 650: (Blocks 21299200-21331967) csum 0x68af [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1901 (bg #0 + 1901), csum 0x4d130885
  Inode bitmap at 83152 (bg #2 + 17616), csum 0x00000000
  Inode table at 334051-334306 (bg #10 + 6371)
  996 free blocks, 4096 free inodes, 0 directories, 4096 unused inodes
  Free blocks: 21304320-21304324, 21304347, 21304349-21304376, 21304378-21304843, 21304847-21304877, 21304879-21305343
  Free inodes: 2662401-2666496


видим что Block bitmap этой группы блоков лежит в (внимание) группе блоков 0 (потому что в свойтвах ФС активиована фича флекс групп   "flex_bg" иначе бы block bitmap блок хранился
бы в самой группе блоков) в блоке  1901 (адрес фс блока абсолютный и это очень удобно)


в битмапе каждый бит мапит байт. далее нужно учесть что из битмапа длинной 4К байт
удобно прочитать какойто отдельный байт и уже внутри него искать бит. 
xxd хексдамп нам позволит считать любой байт внутри поток байтов при этом xxd
задает адрес байта внутри потока через офссет. тоесть если у нас есть поток байтов
скажем три байта  00 01 02 то первый байт будет иметь офссет 0, второй байт будет иметь
оффсет 2, третий байт будет иметь офссет 3. 

значит двигаем дальше. 
у нас первый байт в потоке имеет офсет 0 и кодирует внутри себя через биты байты из группы блоков с номерами N...N+7 где N это номер первого байта группы блоков.

у нас второй байт в потоке имеет оффсет 1 и кодирует внутри себя через биты байты из группы
блоков с номерами (N+7)+1... (N+7)+1+7


распишем

оффсет 0 (кодирует)  N..N+7 
оффсет 1 (кодирует)  (N+7+1)..(N+7+1)+7 = N+8..N+15
оффсет 2 (кодирует)  (N+7+1)+7+1 ..(N+7+1)+7+1+7 = N+16..N+23

получается 
оффсет k (кодирует)   N+k*8..N+k*8+7

значит нам чтобы внутри битмапа найти нужный нам офссет k для искмого номера блока ФС
то нужно чтобы удовлетоврялось условие

N+k*8 <  номер нашего блока ФС < N+k*8+7

номер нашего блока ФС 21304348

N = 21299200 потому что это номер первого блока фс в нашей группе блоков

берем k=643 тогда

21,304,344 < 21,304,348 < 21,304,351

видим что выполеняется. значит офссет k=643 это наш искомый оффсет.
xxd позовляет задавать офссет чеерз опцию -s 643

тогда
считываем block bitmap и внутри него считываем 1 байт по адресу офссет 643 
# dd  if=/mnt/10T.txt  bs=4K count=1 skip=1901 status=none | xxd -l1 -s643 -b
00000283: 00010111 (BE) 

наш офссет 643 в битмапе кодирует в себе 8 блоков ФС таких как 

21,304,344 ... 21,304,351

значит наш искомый блок ФС 21,304,348 он является пятым по счету относительно 
блока ФС 21,304,344 значит он закодирован пятым битом в этом байте. 
еще раз смотрим на байт
00010111  (BE)

и дейтвительно пятый бит у нас выставлен. значит мы все верно расчитали на счет
битмапа.

проверим с другой стороны что мы нашли правильный байт внутри битмапа.

# debugfs -R "icheck   21304344  21304345  21304346   21304347   21304348   21304349  21304350  21304351     " /mnt/10T.txt 
debugfs 1.46.5 (30-Dec-2021)
Block   Inode number
21304344    23
21304345    23
21304346    23
21304347    <block not found>
21304348    24
21304349    <block not found>
21304350    <block not found>
21304351    <block not found>


отсюда видно что блоки ФС образуют туже самую битовую последовательность.
знчит мы все рассчитали правильно.



значит в итоге правило такое. считываем битмап файл. далее нам в нем нужно вычлениить 
нужный байт. для этого надо расчитать какой оффсет внутри битмап блока отвечает 
за наш искомый блок ФС для этого юзаем вот это

оффсет k (кодирует)   N+k*8..N+k*8+7

тоесть офссет с номером к внутри блока битмапа кодирует восемь байтов с номерами
N+k*8..N+k*8+7,  где N номер первого блока в группе блоков. таким образом мы ищем номер
офссета исходя из того что у нас известен N и у нас есть наш блок фс  m
и они должны удовлетворять формуле

N+k*8 < m < N+k*8+7

N,m мы знаем. отсюда вычисляем k тоесть номер_офссета мы считываем нужный байт 
внутри битмапа

# dd    if=/mnt/10T.txt    bs=4K    count=1    skip=<номер_блока_ФС_где_лежит_битмап> status=none | xxd   -l1    -s <номер_оффсета>  -b

00000283: 00010111 (BE) 


когда мы получили на экране наш искомый байт то мы знаем что его биты кодируют 
блоки ФС с номерами

N+k*8..m..N+k*8+7

отсюда мы можем проверить установлен ли нужный бит или нет.


швейцарец предлагает такой способ получить тоже самое:
вот  у нас есть наш блок ФС 21304348
и у нас есть первый блок ФС в группе 21299200
отнимаем от одного другое  21304348 - 21299200 = 5148

далее делим на 8 на цело это будет офссет
 и еще смотрим какой остаток и прибавляем к нему один это будет номер бита
 внутри байта

5148/8=643 и 4 в остатке
значит тогда офссет 643  и внутри этого байта нас интересует бит 4+1 тоесть 5

# dd  if=/mnt/10T.txt  bs=4K count=1 skip=1901 status=none | xxd -l1 -s643 -b
00000283: 00010111 (BE) 

в целом совпало. бит номер 5 установлен.


====

| pipe

хочется понять как выглядит файл пайпа на диске.
для этого я взял ext2 потому что на ней проще посмотреть
вот тут указано какой формат имеет inode для ext2

смотрии формат хрени i_mode
она занимает первые 16 бит в иноде записана она конечно как little endian (младший байт впереди)
я заглянул в формат i_mode и декодировал его

старшие 4 бита этих 16 бит кодируют тип файла.
вот как это выглядит

$ echo "ibase=16;obase=2; C000"|bc
1100000000000000

$ echo "ibase=16;obase=2; A000"|bc
1010000000000000

$ echo "ibase=16;obase=2; 8000"|bc
1000000000000000

$ echo "ibase=16;obase=2; 6000"|bc
110000000000000

$ echo "ibase=16;obase=2; 4000"|bc
100000000000000

$ echo "ibase=16;obase=2; 2000"|bc
10000000000000

$ echo "ibase=16;obase=2; 1000"|bc
1000000000000


или уже в более наглядном битовом виде
тип файла:
1100 **** **** **** socket
1010 **** **** **** symbol link
1000 **** **** **** regular file
0110 **** **** **** block device
0100 **** **** **** directory
0010 **** **** **** char device
0001 **** **** **** fifo(pipe)

далее кодируется вот что 
**** 1*** **** **** SUID bit
**** *1** **** **** SGID bit
**** **1* **** **** sticky bit


далее кодируются пермишнсы
**** ***1 **** **** user read perm
**** **** 1*** **** user write perm
**** **** *1** **** user execute perm
**** **** **1* **** group read
**** **** ***1 **** group write
**** **** **** 1*** group execute
**** **** **** *1** other read
**** **** **** **1* other write
**** **** **** ***1 other execute


а теперь берем конкретный файл, смотрим его иноду, и декодируем ее
$ ls -1al
prw-r--r--   1 root  root        0 окт  6 07:17 pipe1
srwxr-xr-x   1 root  root        0 окт  6 07:27 socket1

$ ls -1ai
     12 pipe1
     13 socket1


нас интересует пайп файл pipe1
его инода как видно 12

$ sudo debugfs ~/temp/1G-ext2.txt 
debugfs 1.44.1 (24-Mar-2018)
debugfs:  inode_dump <12>
0000  a411 0000 0000 0000 4560 1f65 4560 1f65  ........E`.eE`.e
0020  4560 1f65 0000 0000 0000 0100 0000 0000  E`.e............
0040  0000 0000 0100 0000 0000 0000 0000 0000  ................
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 7c2d 2b07 0000 0000 0000 0000  ....|-+.........
0160  0000 0000 0000 0000 0000 0000 0000 0000  ................
0200  2000 0000 d4bd 7c5c d4bd 7c5c d4bd 7c5c   .....|\..|\..|\
0220  4560 1f65 d4bd 7c5c 0000 0000 0000 0000  E`.e..|\........
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................

первые 16 бит = a4 11 
преобразуем в BigEndian = 11 a4

преобразуем в битовый вид
0001 0001 1010 0100

смотрим вверх в нашу таблицу и определяем что оно значит
0001 0001 1010 0100 | 
тип файла = fifo
пермишнсы =  ur,uw,gr,or =(rw-r--r--)

ссмотрим опять же наверх. все совпало.

дата блоков (тела файла) у этой иноды нет
доказываю:
> blocks <12>
пусто

имя файла ясен банан хранится в файле-директория тоесть его надо проверять отдельно но я не буду.

таким образом инода под пайп физически на физ диске есть. у нее нет дата блоков, нет тела файла.
весь файл состоит только из иноды. в иноде указано что файл является пайпом. получаается как то там устроено 
что при обращении к этому файлу через драйвер ext2 его дата блоки берутся из оперативки в области ядра а не с 
диска. тоесть башка файла на диске есть а тела нет. тело как то из памяти ядра пробрасываются. загадочно...



===
| find

с его помощью можно искать файлы на диске по номеру иноды.
а не по имени файла. ключ -inum

===

| inode 
| dumpe2fs
| debugfs
| O_TMPFILE
| proc
| fd 
| fdinfo

известно что узнать номер иноды который стоит за именем
файла можно двумя путями

$ stat имя_файла
илм
$ ls -i имя файла

а если у нас файл это симлинк?  если мы натравим эти два сособа
на симлинк то нам покажут иноду симлинка а не того файла на 
который она ссылается. пример
есть обычнчй файл
$ stat README.txt 
  File: README.txt
  Size: 3614        Blocks: 8          IO Block: 4096   regular file
Device: 10302h/66306d   Inode: 28582149    Links: 1

а вот на него симлинк на proc
$ ls -1ali /proc/8683/fd
total 0
82287407 dr-x------ 2 vasya vasya  0 мая 16 04:12 .
82496541 dr-xr-xr-x 9 vasya vasya  0 мая 16 04:12 ..
82287408 lr-x------ 1 vasya vasya 64 мая 16 04:12 0 -> /home/vasya/git/docs/README.txt

соотвсвтенно вот это число 82287408 это инода симлинка 
но это не инода файла README.txt !!!



но как на узнать иноду файла
на которйы ссылается симлинк? ответ если силинк ссылается
на regular file то беерем путь к этому файлу и определяем
как выше указано. а вот если симлинк укзывает на хуй знает что
то нихрнеена ты иноду того файла не узнаешт. пример


$ ls -1ali /proc/30394/fd/
...
82729911 lrwx------ ... -> '/dev/shm/.com.google.Chrome.na6g (deleted)'

вот это число 82729911 это инода самого симлинка а не того файла
что справа.

НО! оказалось что есть споособ узнать иноду того файла
правда только в некоторых случаях.
нужно зайьти в /proc/pid/fdinfo! для некоторых типов файлов 
там указывается инода а для некоторых нет.
если мы открыли простой файл то номера иноды не будет

$ cat /proc/$(pidof 188.exe)/fdinfo/3
pos:    5
flags:  0100000
mnt_id: 32

первый паарметр это тккущий офссет "курсор"
второй параметр это с какими флагами open() открыл этот файл
третий парметр это номер точки монтиования на которой типа лежит
этот файл. точки монтрования перечислены в /proc/pid/mountinfo
вообще про fdinfo смотри в man proc описание

но есть случай  интересный когда в fdinfi указана инода файла
на который ссылается симлинк.
есть такой интересный тип файла как TMP файл.
в proc он выглядит вот так

# ls -1ali /proc/$(pidof 187.exe)/fd/
...
44302 lrwx------ 1 root root 64 May 15 22:06 3 -> '/tmp/#320 (deleted)'

число 44302 это инода самого симлинка. а не файла того 
что справа на который он ссылается.
так вот справа показан непросто файл которого якобы уже нет на
фс. нет! показан интересный случай. это так называемый TMP файл.
у него есть дата блоки. у него есть инода. но у него нет хардлинка.
тоесть у него нету ни в одной папке записи с именем файла и номером
иноды!

этот файл создается на ФС (правда не все фс поддерживают его создание)
через open() с флагом O_TMPFILE так написано в man 2 open
но это наглейший пиздеж потому что с таким флагом тебя gcc пошлет
нахуй со следущей формулировкой

 error: ‘O_TMPFILE’ undeclared (first use in this function)

потому что оказывается нужно использовать флаг
    __O_TMPFILE

вот программа которая создает этот TMP файл



#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#define SLT 300

char const f_path[] = "/tmp";


int main()
{

    int fd = open(f_path, O_RDWR|__O_TMPFILE, 0666);

    if (fd == -1)
    {
        perror("open");
        return 1;
    }

    char const buff[] = "123\n";
    write(fd, buff, sizeof(buff));
    int e = SLT;
    printf("sleep for %isec\n", e);
    sleep(e);

    int ret =close(fd);
    if (ret != 0)
    {
        perror("close");
        return 1;
    }


    return 0;
}


ксати если мы юзаем флаг  __O_TMPFILE 
то вместе сним уже юзать флаг O_CREAT неьльзя 
gcc пошле нахуй.

итак у нас фс драйвер аллоцирует иноду на фс. и аллоцирует
дата блоки. все как положено. тлько в иноде папки не создатеся
никакая запись с именем никаго файла. и к этой иноде ядро
подллюкчает дескприор файла в процессе.

как можно замтить так где указывается путь так указывается
путь только к папке без имени файла

char const f_path[] = "/tmp";
int fd = open(f_path, O_RDWR|__O_TMPFILE, 0666);

у меня возник вопросы
  (?)можно ли узнать номер иноды такого файла
  (?)удаляется ли этот файл псоле того как прцоесс закроет дескриптор
  (?) удаляются ли блоки этого файла (тело)
  (?)можно ли как то прочитать этот файл пока он открыт этим
     процессом

итак отвчаю на эти вопросы
(?)   можно ли узнать номер иноды такого файла
да можно.
во первых можно его увидет вот тут
# ls -1ali /proc/$(pidof 187.exe)/fd/
46221 lrwx------ 1 root root 64 May 15 22:42 3 -> '/tmp/#308 (deleted)'

число #308 это и есть номер иноды знак # указывает что число
указано в HEX формате.

также этот же номер иноды можно узнать вот так 
# cat  /proc/$(pidof 187.exe)/fdinfo/3
pos:    5
flags:  020300002
mnt_id: 31
ino:    308   <==== вот он

охренеть!

(?)удаляется ли этот файл псоле того как прцоесс закроет дескриптор
отвечаю. тут надо себя спросить а что значит файл удаляется?
что происходит когда мы удаляем обычнй файл через rm или unlink.
когда мы делаем 
    $ rm
у нас по факту запускается
    unlinkat(AT_FDCWD, "/tmp/10.txt", 0)    = 0
когда мы делаем 
    $ unlink
у нас по факту запускется
    unlink("/tmp/10.txt")                   = 0

я почитал есть ли разница между unlink() и unlinkat() си 
функциями. уже устал. вот так навскидку нет там какойто разницы.
обе они всего навсего удаляем тот самый хардлинк. тоест запись
в иноде папке там где
    имя файла --> номер иноды
там написано что если мы удалиили все хардлинки то дисковое простан
ство доступно для reuse. а если у нас все еще есть процесс 
у котрго есть дескпритор который ведет еще на иноду от этого файла
то хардьнков конечно уже нет. но инода и дата блоки этого уже 
"недофайла" остаютсся неприкосновенными пока этот процесс незкроет
дескриптор этот. когда мы удаяем очередной хардлинк то драйвер
фс делает коректировку иноды точнее ее полятам где указано
число хардлинков. и как я понимаю когда процесс запустит 
    close(fd)
то драйвер фс автоматом проверяет при этом скоько хардилинков 
записано в иноде и если там указано что их число 0 то происходит
интересная вещь - я проверил - в свойтсвах фс эта инода помечается
как "свободная". но ее содержимое нетрогается не стирается!
и дата блоки на которые она указывала они тоже не трогаются!
поэтому если мы знаем номер иноды то мы можем на нее зайти
без всяких проблем через debugfs и получить полную инфо 
о ее содерэимом. и мы можем зайти на всего дата блоки
и прочитать информацию которая там лежала. !!!
тоесть кода мы "удаляем" файл через rm/unlink то кроме
как хардлинк запись больше нихрена  у файла ничего не удаляется!
и если нам повезло и на диске много места и дата блоки не были
заюзаны уже для других файлов то можем спокойно прочатть весь 
этот "удаленный" файл. поэтому отвеаю на вопрос - когда у нас
процесс закроет дескприор через    
    close(fd)
для TMP файла то этот недофайл будет удален  с ФС? ответ - 
в том смысле как это происходит для обычных файлов  - да. 
ровно тоже самое ос делает с обычным файолм когда мы его удаляем
через rm\unlink. тоест всего навсего будет удален хардлинк. НО ВСЕ
ОСТАЛЬНОЕ КОНЕЧНО ОСТАНЕТСЯ НЕТРОУНТУТЫМ! получется мы когда 
якобы удаляем файл на диске через rm\unlink мы нихрена файлы
НЕУДЛЯАЯЕМ!!! мы удаляем сраные хардлинки. тоесть записи в
инодах-папках . записи где хранится имя файла и его номер иноды.
и мы это назыаем Я УДАЛИЛ ФАЙЛ. это пиздец! это совершенно не являтся
удалением файла. это удалением маленькой части от файла!

а теперь показывают все на классной большой практтике.
вот мы откмпоилвали программу и запустили ее. 
она создала TMP файл потом она в него записала "123\n" и впала в sleep надолго.
посмотрим что происходит

вот так этот файл выглядит в /proc
# ls -1ali /proc/$(pidof 187.exe)/fd/
...
46221 lrwx------ 1 root root 64 May 15 22:42 3 -> '/tmp/#308 (deleted)'

мы понимаем что у файла инода 0x308

вот еще что мы видим в proc
# cat  /proc/$(pidof 187.exe)/fdinfo/3
pos:    5
flags:  020300002
mnt_id: 31
ino:    308
мы видим опять что инода = 0x308

вот сколько было свободных инод до запука пограммы
# df -i /
Filesystem      Inodes IUsed   IFree IUse% Mounted on
/dev/sda1      1179648 83473 1096175    8% /

а вот сколько стало после
# df -i /
Filesystem      Inodes IUsed   IFree IUse% Mounted on
/dev/sda1      1179648 83474 1096174    8% /

тоесть мы четко видим что число свободных инод уменьшилось на 1!

также можно этот файл прочитать из другого процесса
воо таким образом!!
$ cat  /proc/$(pidof 187.exe)/fd/3
123

теперь идем  в debugfs
и смотрим какой блок указан в иноде 0x308
# debugfs /dev/sda1
debugfs 1.47.0 (5-Feb-2023)
debugfs:  blocks <308>
41442 

теперь смоотрим а что там за контент лежит  в этом фс блоке?
debugfs:  block_dump 41442
0000  3132 330a 0000 0000 0000 0000 0000 0000  123.............
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

тоесть ровно тот же самый "123" !! тоесть все совпало!

вот список свободных инод до того как  я запустил процесс
# dumpe2fs /dev/sda1 | grep "Group 0" -A8 | grep "Free inodes"
  Free inodes: 308, 320, 1946, 1949-1950, 4621, 5997, 6002
мы видим здесь иноду 0x308 она свободна

после запуска процесса она исчезает из 
списка своодбоных


# dumpe2fs /dev/sda1 | grep "Group 0" -A8 |  grep "Free inodes"
  Free inodes: 320, 1946, 1949-1950, 4621, 5997, 6002

мы видим что ближайшая свободоная инода это 0x320

тоесть все совпало мы все нашли все посмотрели!

теперь я останаливаю процесс. и смотрим какие элементы
этих хрейней у нас останутся нетроунтыми.

во первых у нас df снова покажет что число инод прибавилось 
обртано на +1
# df -i /
Filesystem      Inodes IUsed   IFree IUse% Mounted on
/dev/sda1      1179648 83473 1096175    8% /

тоесть 308 инода обратно вернулсь в строй

dumpe2fs покажет что 308 инода свнова своободна
# dumpe2fs /dev/sda1 | grep "Group 0" -A8 | grep "Free inodes"
  Free inodes: 308, 320, 1946, 1949-1950, 4621, 5997, 6002


однако по факту наша инода данныее ее нетронуты.
по прежнему она показвыает на тот же самый ФС блок
>>>debugfs:  blocks <308>
41442 

по прежнему у нее есть полный набор всей инморации которая
в нее была засунута

>>>> debugfs: stat <308>
Inode: 308   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 1870099220    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 5
File ACL: 0
Links: 0   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x664539e1:395a0550 -- Wed May 15 22:40:33 2024
 atime: 0x664539e1:395a0550 -- Wed May 15 22:40:33 2024
 mtime: 0x664539e1:395a0550 -- Wed May 15 22:40:33 2024
crtime: 0x664539e1:395a0550 -- Wed May 15 22:40:33 2024
 dtime: 0x00001785:(395a0550) -- Thu Jan  1 01:40:21 1970
Size of extra inode fields: 32
Inode checksum: 0x9f00f421
EXTENTS:
(0):41442

что примечатльно у нее например это вот это полей
    Links: 0
тоест да. хардлинков у нее ноль.
а вот это поле
    EXTENTS:
(0):41442
прекрасно сохранилось

и дамп дата блока по прежнему показывает нетронутые данные
debugfs:  block_dump 41442
0000  3132 330a 0000 0000 0000 0000 0000 0000  123.............
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

ВОТ ТАКАЯ СХЕМОТЕХНИКА. вот так работает мехагннизм "удаления"
файлов. вот тако работает механизм TMP файлов.

интеерно то что при "удалении" файла точнее при удалении всех 
хардлиноков файла ни его инода и ни дата блоки вообще никак не 
иницилизруются и не страдаются не портятся. едиснвтенное что
происходит эт удаление хардлинков что копейки семечки. и 
в иноде делается пометка что число хардлинков ноль.
и тогда возикает вопрос - а как же тогда драйвер фс вычитвает 
количество пустого свбодонного места на диске? он по быстрому 
пробегает все иноды и для тех которые имеют 
    LINKS <> 0 
суммирует блоки которые указаны в них за которые они отвеачают? 
врятли это было бы долго. скорей всего у него есть перменная в которой
хранится размер "свободного" места и при кажой модификации каждой
иноды он эту перменную коректурет. поэтому при закрытии файла 
когда он вдиит что links=0 то он понимает что все блоки за которые
отвечает эта инода они потенциально свободны. и он тогда далеает
коректировку пременной которая отвечает за свобонное место. может так?
я просто щас уже позабыл как в иноде хранится инфо о блоках данных.
я помню там потом вроде как идут эксетнты а не блоки. и идут они кусками
типа с 1 по 1000 . с 5000 по 10000 тоесть исползуется какйото 
компатнй вид храния инфо о списке дата блоков. но все равно
иноада имеет по моему фикс размер. и где то там еще идет продолжение
списка блоков которые составляют тело файла. но че то  я забыл 
где и как они хранятся.

а так эта тема с TMP файлами доастаточно эпичекая

при каждой модификации иноды

на счет удаления файла еще пара слов. получатеся удаляется
hardlink тоесть удаляется entry внутри "каталога" 
мне непонятно почему при сисколле который "удаляет файл"
типа rm или unllink 
ядро не проверяет что по данному пути какойто процесс имеет файл 
открытым это же можно сделать
например   вот  я открыл файл
	 $  sleep 120 < ~/.bashrc
вот его дскприпторы
	$ ls -1al /proc/2196277/fd/
 		0 -> /home/vasya/.bashrc
 		1 -> /dev/pts/0
 		2 -> /dev/pts/0

тоесть ядру четко видно что есть процесс котоырй открыл файл 
по некоторму пути. и при этом друой прцесс пытается удалить
хардлинк на этот путь в товремя как первый процесс имеет 
файл открытым через этот хардлинк.
это жебезобразие даваь втоому процесссу удалить этот харлинк.

они могли бы сделать  что при удалении это проверяется. 
ну да наверно надо будет прошерстить какоето количсество файл дескприоров.
ну буде удалеие не такой быстрой операцией. так и что. 
у нас что триллиард файлов чтли открыт все время.
непонятно. в виловсе же как то смогли проверять. и все олично.
а так ебала какаято.
реально.
===























