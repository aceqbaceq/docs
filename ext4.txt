ext4

| как определить версию FS

# blkid -o value -s TYPE ./5G-ext3.txt 
ext3

# file -Ls ./5G-ext3.txt 
./5G-ext3.txt: Linux rev 1.0 ext3 filesystem data, UUID=75949a85-488f-49dc-a73b-bde95da9ae0e (large files)

просто охуеынй способ


|
https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout

создадим файл и сделаем из него блочное устройство

первый шаг
$ dd if=/dev/zero of=./01.block bs=2k count=100000


на следущем шаге используем losetup
прогармма позвяолет взять файл и организовать к нему доступ как к блочному утсройству
через /dev/loopX файл.

поговорим о флагах команды ибо они описаны дебильно.




losetup без флагов или с флагом -a показывает инфо о том какие /dev/looop заняты
щас и на какие файлы они привязаны. 


$ sudo losetup
NAME        SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE
/dev/loop9          0      0         1  1 /var/lib/snapd/snaps/gnome-characters_741.snap
/dev/loop7          0      0         0  0 /root/block-devices/01.block

siezelimit и offset это хрень какая то потому что они задают то что: 
sizelimit ограничивает доступ внутри файла до какогто предела. зачем это надо?
если мы завели файл то хотим там лазить везде внутри
offset задает что доступ начинается не с нулевого байта файла а с какогото 
отступа. тоже нахер это надо?
RO - рид онли доступ. ну понятяно

вобщем в итоге нас интерусет только NAME и BACK-FILE
$ sudo losetup
NAME         RO BACK-FILE
/dev/loop9   1 /var/lib/snapd/snaps/gnome-characters_741.snap
/dev/loop7   0  0 /root/block-devices/01.block

итак losetup позволяет иметь доступ к бекенд файлу как блочному устройству через
/dev/loop9 спецфайл. тоесть имели файл получили блочное устройство в котором файл 
это бекенд.






ключ -f (--find) = описание у ключа полностью дебильное. если других ключей в добавок к ключу -f неиспользуется в команде то ключ -f показывает свободный /dev/loopX на данный момент

$ losetup  -f
/dev/loop15

но более того (и об этом несказано в мануале) это то что если свободного loop нет то в ответ
на эту команду система создает +1 новый свободный loop. правда и тут не без ососбенностей
это произодйет олько если мы запусккаем losetup -f с правами рута. показываю:

$ losetup -f
losetup: cannot find an unused loop device: Permission denied
$ sudo losetup -f
/dev/loop28

тоесть в системе небыло свободных loop. я заустил losetup -f без прав рута и он об этом 
просто написал. а вот когда запустил под рутом то система в ответ создала новый свобдрный loop

у этого ключа дебильная расшифровка я продолжаю об этом,  по своему смыслу этот ключ совсем не "find" как написано в мануале а более похож по смыслу на "loop file"
потому что когда мы создаем связь между бекенд файлом и /dev/loopX то ключ -f используется
для того чтобы указать какой /dev/loopX мы хотим использовать. так что -f обозначает /dev/loopX файл. если мы неукажем конкетный /dev/loopX файл то система автоматом подставит первый свободный. тоесть

$ sudo losetup -f  ~/01.img   
эта команда найдет свободный /dev/loopX и привяжет его к файлу 01.img

хотя можно как я сказал указать /dev/loopX руками
$ sudo losetup -f /dev/loop12  ~/01.img

таким образом видно что -f указывает имя /dev/loop файла. так что какой нахер find ? -f по своему смыслу это никакой нахер не --find а  file по своему смыслу.

еще раз скажу что указывать руками -f /dev/loop12 нет смысла. во первых потому что этот /dev/loop12 уже 
должен быть в системе более того  надо проверять свободен ли он.

также еще важный момент скажу. если у нас в системе исчерапались все доступные loop устройства
то при вызове losetup -f с правами рута система создаст +1 свободный loop. отсюда ответ 
на вопрос откуда беретуся новые свободные loop-ы.
пример я щас заюзаю последний свободный loop27: 

$ losetup -f
/dev/loop27

создаем бекенд файл 
$ touch ~/block-devices/01.img

привязываем 01.img к блочному loop27
$ sudo losetup /home/vasya/block-devices/01.img  -f /dev/loop27

таикм образом теперь доступ к 01.img можно делать как к блочному устройству чеерез /dev/loop27
В данном случае я указал loop руками но можно было сделать и по другому без ручного указания:

$ sudo losetup /home/vasya/block-devices/01.img  -f

далее я проверяю появился ли новый loop.
$ losetup -f
losetup: cannot find an unused loop device: Permission denied

как видно непоявился.


но  далее я запуска команду  под рутом и система создает новый!
$ sudo losetup -f
/dev/loop28

таким обоазом я резюмирую что ключ -f дает и делает.
1. он показывает какой свободный loop есть (при запуске не под рутом)
$ losetup -f
/dev/loop28

2. если свободного loop нет но мы запустили под рутом то система создаст новый свободный 
loop
$ sudo losetup -f
/dev/loop28


3. указввает loop который использовать при создании связи между бекенд файлом и loop файлом
	$ sudo losetup /home/vasya/block-devices/01.img  -f /dev/loop27
если после -f неуказан loop то система сама найдет свободный и подставит.  я даже
поозреваю что если свободного неокажется то система создаст новый loop автоматом
тоесть вот такая команда тоже работает
	$ sudo losetup /home/vasya/block-devices/01.img  -f
причем я считаю что это и есть более практически удобная команда


Итак создаем блочное устройство из файла 01.block
# losetup --sector-size 4k /home/vasya/block-devices/01.block -f

проверяем:
$ losetup | grep -E "OFFSET|01.block"
NAME         RO BACK-FILE                                          DIO LOG-SEC
/dev/loop28   0 /home/vasya/block-devices/01.block                   0    4096


LOG-SEC это logical sector size это сектор 4к который мы выставили ранее.
что такое logical sector и чем он отличается от physical sector мы поговорим ниже.



создаем файловую систему ext4 с дефолтовыми настройками:

$ sudo mkfs.ext4 /dev/loop28
mke2fs 1.44.1 (24-Mar-2018)
Discarding device blocks: done                            
Creating filesystem with 50000 4k blocks and 50048 inodes
Filesystem UUID: d70e8847-c2a9-4ca5-9d03-a42fb6c454a9
Superblock backups stored on blocks: 
	32768

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done


теперь начинаем изучать ext4.

теперь посморим что про фс напишет утилита:
$ sudo tune2fs -l /dev/loop28
tune2fs 1.44.1 (24-Mar-2018)
Filesystem volume name:   <none>
Last mounted on:          <not available>
Filesystem UUID:          d70e8847-c2a9-4ca5-9d03-a42fb6c454a9
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Filesystem flags:         signed_directory_hash 
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              50048
Block count:              50000
Reserved block count:     2500
Free blocks:              44278
Free inodes:              50037
First block:              0
Block size:               4096
Fragment size:            4096
Group descriptor size:    64
Reserved GDT blocks:      24
Blocks per group:         32768
Fragments per group:      32768
Inodes per group:         25024
Inode blocks per group:   782
Flex block group size:    16
Filesystem created:       Thu Jul 14 20:17:44 2022
Last mount time:          n/a
Last write time:          Thu Jul 14 20:17:44 2022
Mount count:              0
Maximum mount count:      -1
Last checked:             Thu Jul 14 20:17:44 2022
Check interval:           0 (<none>)
Lifetime writes:          16 MB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:	          128
Journal inode:            8
Default directory hash:   half_md4
Directory Hash Seed:      785a7c2b-e142-432b-b4d9-7ae4b3399411
Journal backup:           inode blocks
Checksum type:            crc32c
Checksum:                 0x97a880be

пока двигаем дальше.

ФС ее драйвер делит диск на blocks. это не сектора диска нет. это логическая структура 
с точки зрения драйвера фс. насколко я понимаю это минимальная стркуткура которую можно
прочитать и записать на фс через драйвер. но я пока непонимаю это внутренняя кухня
только для драйвера фс или эти блоки они както наружу выставляются для сторонних внешних
потребителей. пока я этого не понимаю. пока двигаем дальше.

блоки обьединяются в block group. ее размер опредеяется через 
	sb.s_blocks_per_group
либо как 
	8 * block_size_in_bytes

All fields in ext4 are written to disk in little-endian order. HOWEVER, all fields in jbd2 (the journal) are written to disk in big-endian order.

немного поговорим про рейды. что такое stripe size и chunk size.
у IBM нашел такое определение - A stripe, which can also be referred to as a redundancy unit, is the smallest amount of data that can be addressed. сокращаю их выражение до:
 A stripe is the smallest amount of data that can be addressed


что такое chunk size. важно отметить что этот термин
имеет смысл ТОЛЬКО ДЛЯ ОПРЕДЕЛЕННЫХ ТИПОВ RAID А НЕ ДЛЯ ВСЕХ ПОДРЯД.
из man mdadm я читаю:
 -c, --chunk=
              Specify  chunk  size of kilobytes.  The default when creating an array is 512KB.  To ensure compatibility with earlier versions, the default when building an array with no persistent metadata is 64KB.  This is only meaningful for RAID0, RAID4, RAID5, RAID6, and RAID10.
              RAID4, RAID5, RAID6, and RAID10 require the chunk size to be a power of 2.  In any case it must be a multiple of 4KB.
по своей сути chunk означает сколько байт будет записано на отдельный диск если мы на весь 
массив послали X KB данных за 1 IO. читаю у орейли - An array's chunk-size defines the smallest amount of data per write operation that should be written to each individual disk.



- о чем это ?
cat /sys/block/loop0/queue/physical_block_size 
cat /sys/block/loop0/queue/logical_block_size

во первых эти хрени это результат того что firmware диска доакладывает драйверу.
тоесть это незадается из линукса это типа как бы свойства самой железки 
которые она сообщает о себе. якобы hdparm может просить firmware железки чтобы
она поменяла свой logical_block_size и иногда она меняет.

тееперь о значении этих хреней
physical_block_size = походу это типа каким блоками информация сохраняется
	внутри железки по факту.

logical_block_size = это какими минимальными блоками железка принимает от драйвера информацию на запись.(вроде бы оттуда же LBA - logical block addressing произошло название). тоесть 
я так понимаю что вот для драйвера железка сообщает что у нее есть 1 000 000 LBA блоков размером по 512 байт. соотвесвтенно драйвер может подать на запись команду вида - запиши 
ка в 15-ый блок LBA 512 байт такого то вида. тоесть идея в чем что для драйвера диск 
выглядит как коробка у которой два параметра - число блоков (LBA) и размер блока. 
и драйвер может либо читать из блока либо писать в блок. соотвественно можно либо 
целиком прочитать блок либо целиком записать в блок. частичная операция диском не поддерживатеся поэтому драйверу надо знать размер блока обязательно. 
 иттогда операция чтения со стороны драйвера выглядит как:
 READ блок 15 размер 512 байт
 WRITE блок 17 размер 512 байт.

 если же ядро хочет записать 1 байт то ему нужно с помощью драйвера 
 1. считать блок LBA 12 размером 512 байт с помозью драйвера
 2. поменять один байт в RAM в этом куске 512байтном 
 3. записать обартно 512 байт (модифицированных ) с помозью драйвера в LBA 12


 так вот 512 байт это logical_block_size.

 еще раз драйверу кгда он хочет считать инфо с диска ему нужно передать какой номер блока
 драйвер хочет чтобы диск считал. я незнаю передает ли драйвер в диск размер сектора
 или просто драйвер вслпую получает байты от диска пока он незактнется  и тогда важно
 чтобы размер буфера чтения оказался ни больше ни меньше. но я думаю что точно что при записи на диск нужно указать номер блока и нужно чтобы размер данных которые мы пихаем на диск 
 был в точности совпадал с размером сектора потому что если мы попробуем сунуть в сектор инфомрации болше чем сектор по размеру то диск выдаст ошибку. вот почеу важен размер сектора.
 и вот этот вот размер сектора который мы получаем при чтении сдиска указав его номер 
 и размер который можно запихать в диск указав номер блока как раз равен logical_block_size
 который диск сообзает драйверу. тоесть если мы заказли чтение с диска lBA блока 12 то 
 мы можем смоело ожидаь что диск на передаст ровно logical_block_size байт.
 а если мы хотим запистьа на диск в блок 12 LBA то диск ждет от нас logical_block_size байт.
 вот каков физический смысл logical_block_size.

 а смысл physical_block_size состоит в том что таков размер блока записи на диске внутри 
 по факту. он может неосовпата с logical_block_size. к чему это приводит. если унас 
 physcal_block_sie=4K а logical_block_size=512байт то когда мы пишем на диск 512 байт
 то по факту диск внутри себя считывает 4к модифицирует его и записывает обратно модифицироыванный 4к.  что конечно же ведет к сумашедшему потере скорости. 
 логично предполжить что если мы заказали запись восьми блоков LBA по 512 байт то 
 диск понимает что весь его физичесмы кий блок 4к нужно  переписать поэтому читать уже его ненужно его можно сразу перезапиывать. и потери скрорости нет вообще!
 поэтмоу что наам дает знание  physical_block_size. поменять мы его неомжем но мы можем
 на файловой системе сделать размер блока равынй или кратный physical_block_size.
 что это дает - мы в программе в линуксе даем команду 

  write(1, const void *buf, 12КБ);

запускается ядро и сисколл берет наши 12КБ данных и передает драйверу ФС. 
драйвер ФС разбивает нащи 12Кб на куски по 4КБ(размер блока на ФС) насколько я пнинимаю
далее дайрвер фс делает вот что. он переводит каждый кусок 4КБ в блоки LBA и передает
драйвер диска типа такой команды - мол блоки LBA c 1 по 8 (суммарно 4КБ) надо записать кучкой
далее мол блоки с 9 по 16(4КБ) тоже надо записать кучкой. драйвер диска его специифика то что
он знает какие конктенотно сигналы надо послать в диск чтобы передать ему что  LBA 1-8 надо
записать кучкой. это приводит  к тому что диск видит что надо записать 8 втртуальных блоков LBA фактически которые укладываются в один физический блок и диск понимаает что это перепывает
весь физ блок целиком и он это делает и сокрость нетеряется. вместо того чтобы прочитать блок 
поменять на наем первый байт записать обратно . потом считать заново поменять второй баайт
записать заноово. имеем  непотерю скоорости. 

в чем разница если бы на ФС были бы блоки по 512байт ( тоесть мы есл бы незнали что физ блок 4К а думали что он 512байт). было бы то что мы дали команду write(1, const void *buf, 12КБ);
она долетела до ФС. она взяла и 12КБ разделила по 512байтовым LBA кусочкам. и далее фс
будет требовать от драйвера диска чтобы он просто записал LBA блоки в любом порядке.
и  в этом то жопа потому что тогда как раз может получатьс ситцаия на диске что он 
читает 4к сектор. меняет в нем один или два байта. пишет обратно. потому опять читает
меняет один два байта и пишет обратно. огромная потеря сокрости.  вслучае е когда  у нас на фс 4Кб блоки это приводит к тому что у нас на ываходе тоже куча полукиолбтаный LBA блоков но
фм будет требовать от дравера диска чтобы группа LBA от 1 по 8 была записана в одном порыве.
или друг за другом. и значит диск небует читать 4к блок а сразу будет его переписывать. в этом 
и есть смысл нам знать о внутрнеейней размере физ диска на диске и на оснвое этого задавать 
размер блока на фс. иначе я не вижу смысла в блоках ФС.

насколько я понимаю про страйп на рейде. это минимальная логическая структура размером которой
он читает и пишет. если она скажем 64КБ это значит что если мы задаем запись 1КБ то он прочитает с жиска кусок 64Кб изменит его и потом запишет обратно. тоест идет чтение+запись 
вмест записи. 


- у нас рейд и страйп size =64k значит ли этом что при запитсь 1к у нас всегда будет
вначале чтние и только потом запись. то есть бещеное падание скоокрсти.

на сайте редхата читаю: 
	Storage vendors can also supply "I/O hints" about a device's preferred
minimum unit for random I/O ('minimum_io_size') and streaming I/O
('optimal_io_size').  For example, these hints may correspond to a RAID
device's chunk size and stripe size respectively.


что такое direct i\o = Direct I/O is a feature of the file system whereby file reads and writes go directly from the applications to the storage device, bypassing the operating system read and write caches. Direct I/O is used only by applications (such as databases) that manage their own caches.
An application invokes direct I/O by opening a file with the O_DIRECT flag.
дествииельно читаю man 2 open:
O_DIRECT (since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will degrade performance, but it is useful in special situations, such  as  when  applica‐
              tions  do  their own caching.  File I/O is done directly to/from user-space buffers.  The O_DIRECT flag on its own makes an effort to transfer data synchronously, but does
              not give the guarantees of the O_SYNC flag that data and necessary metadata are transferred.  To guarantee synchronous I/O, O_SYNC must be used in  addition  to  O_DIRECT.
              See NOTES below for further discussion.
еще таеаы добавка идет:
When a file is opened with O_DIRECT, or when a GFS direct I/O attribute is attached to a file, all I/O operations must be done in block-size multiples of 512 bytes. The memory being read from or written to must also be 512-byte aligned.

кстати посмотреть список scsi устрйоств:
$ apt-get install lsscsi

пакет чтобы посылать команы на scsi устройства:
$ sudo apt-get -y install sg3-utils

здесь нащел https://people.redhat.com/msnitzer/docs/io-limits.txt :
Linux filesystems are not allowed to be
formatted to use a block size that is smaller than the underlying
storage's 'logical_block_size'.

в доке от ibm нашел:
logical_block_size Smallest possible unit in bytes that is addressable in a request.
physical_block_size Smallest unit in bytes handled without read-modify-write.

тоесть logical_block_device это с каким размером сектора диск себя презентует в user space.
как он видится для юзер программ.

physuica_block_size это его размер сектора изнутри внутри. если совать в диск данные размером
меньше чем physuica_block_size то диску придется вначале считать physuica_block_size изменить его а потом только заисать обратно. что ведет к беешеной перфоманс деградации.

Тут я напоролся на тему linux kernel i\o scheduler:
Simply sending out requests to the block devices in the order that the kernel issues them, as soon as it issues them, results in awful performance. One of the slowest operations in a modern computer is disk seeks. Each seekpositioning the hard disk's head at the location of a specific blocktakes many milliseconds. Minimizing seeks is absolutely crucial to the system's performance.

Therefore, the kernel does not issue block I/O requests to the disk in the order they are received or as soon as they are received. Instead, it performs operations called merging and sorting to greatly improve the performance of the system as a whole[2]. The subsystem of the kernel that performs these operations is called the I/O scheduler.

io scheduler называт еще elevator.
потмоу что его задача ( по крайней мере для шппненльных дисков) в тмо чтобы 
головка шла ровно и нескакала постоянно.

на праатике есть дефолтовый шедулер в системе. как его поменять.
надо в grub примненмть опцию elevator

/boot/grub/menu.lst :

title CentOS (2.6.18-128.4.1.el5)
root (hd0,0)
kernel /vmlinuz-2.6.18-128.4.1.el5 ro root=/dev/VolGroup00/LogVol00 elevator=noop
initrd /initrd-2.6.18-128.4.1.el5.img

это по деолфту выставит для всех блочных устройств io шедулер = noop

провеоить прям щас какой шедулер работает на кокнктеном блочном устрйостве можно так:
$ cat /sys/block/nvme0n1/queue/scheduler 
[none] mq-deadline 
 

его на лету можно переклчить. через 
echo mq-deadline > /sys/block/disk/queue/scheduler

если хотим для оотдельного диска кастомный и чтобы после перегазуруки осталось 
перманентно то надо заюзать правила для udev.

vmware пишет что для линуксов втруталок надо бы ставить none шедулер потому что 
в конечном итоге каждля виртуалка незнает о других вируалках поэтому надо оставит 
задачу реэрейнждмента порядка счтывания LBA блоков гипервизору. тоесть надо на виртуалках
проставить шедулер = noop

раньше до появления nvme дисков да и вообще в эру шпиндельных дисков
были такие шедулеры:
noop
Completely Fair Queuing (cfq)
Anticipatory
Deadline

потом появился еще bfq

основная  цель оптимизации у шедулеров была уменьшить прыганье головки на шпинеделях.
а когда пошли ssd то это все отпало. 
на данный момент для nvme считается самым отличным шедуелером это none шедулер.  тоесть
в устроство подается вобщмто просто поток запросов а вся оптиамизация переклдывадется на 
сам nvme диск.

- закончил на том что есть старый io шедулер. у него там разные есть элеавторы.
но их общая фигня в том что в конечном итоге реквесты от всех процессов к блочному устройству
как я понял обрабатываться в рамках одной очереди. и эта одна очередь обрабабтыватеся
всего одиним ядром цпу. поэтому скорость одного ядра цпу это ровно то место узкое
которое мещает выжмать иопсы. поэтому был придуман новый шедулер механизм. 
в котором во первых очередь разбивается на две части. в первой части находтся софт очереди
во вторйо части хард очереди. софт очередй много столько скольк ядер. в этих очередях
происходит перегруппирова запросов и так далее.  уаждого ядра есть своя софт очередь доя блочного устрйоства. тоеть если 10 ядер то для конкретногого блочного /dev/nvme у нас будет 10 софт очередей. если процесс сидит на ядре 1 и он на этом ядре вызывал read() и далее 
цпу перешел в режим ядра то этот реквест будет попмщен в софт очередь этого цпу. и ответ
от железкт придет именно на это цпу. окей получаетя запросы к /dev/sda от процессовна разных
цпу начали обрабаывться на разных цпу (распараллелились). эта вся хрень с очередями 
работает на уровне block layer в ядре. ина данном этапе мы никак не связаны с конкретикой
драйвера /dev/sda. вся мудота с группировой перемшиванием ркевестов в очереди идет именно
в софт очереди. я неочень понимаю как долго работает block layer по времени. пока я вижу это так. процесс на цпу запустил read() если еще тайм слайст незакончился то цпу переходит в режим 
ядра и запускает сисколл то выполняет код ядра с очередями. и в какойто момент происхоит
таймер интеррапт запускается процесс шедулер. и он выдавливает block layer код с цпу и запускае другой процесс. потом опять доходит очередь до этого проецесса и код ядра block layer наконец заканчивает там манипулиции с софт очередью и далее видимо первый с начала запрос 
из софт очереи передается в хард очередь если в ней нет места то там есть промежуточная 
хрень для храннеия. хард очередь это очереь в которой уже непроисходит никаких перестановок
запросов  в ней. она чисто я так понял FIFO. и из нее запросы уже передаются в драйвер /dev/sda
на исполнение. число хард очередей равно числу очередей которые поддеживает железка.
и тут мне непонятно то что какой цпу обратвает хард очередь конкретную. если софт очередл 
каждя четко привязана к кокнкретному цпу то как выбирается цпу для обработки для продивджения реквестов по хард очереди. ведь очереь это просто кусок памяти. а чтобы она работал нужен цпу
которй будет по ней двигать реквесты. вот это непооятно. а так запрос из хард очереди передается в low level драйвер /dev/sda и тот уже как то там конкретно пихает запрос в железку
все это время тайм слайс может закончится и шедулеор выдавить этот код с цпу. потом обратно 
засунет. а ответ в систему прилетает уже вот как - когда железка прочитала сектора то она
гененирует интеррапт и доставку от железки до ядра куска инфомрации уже идет по интерапту.через оарботчик интерапта. щас для меня все вынгляди так что если процесс 
однотредовый то скорость иопсов для него все равно зависит от скорости одного ядра цпу.
хотя конечно процесс шедулер может случайно перемещать процес между цпу и он успееет насовать
свои рекветы во всех софт очереди на всех цпу. тогда да мы неупелис в одно ядро. но 
по прежнему неонятнен вопрос какие цпу обслуживают хард очереди. 

двигаем дальше. я понял что при запросе на чтение\запись read(), write() можно исполовать
флаu O_DIRECT (называется Direct I\O операция). он дает то что мы говорим ядру что мы нехотим использовать page cache а мы 
хотим читать и писать сразу на железку.

вот картинка про i\o систему в ядре. = https://www.thomas-krenn.com/de/wikiDE/images/e/e0/Linux-storage-stack-diagram_v4.10.png

ищем там I\O scheduler и blmk.
I\O shceduler это старая версия i\o шедулера а blmk это новая.
на схеме мало что понятно но видно что у старого шедулера была одна штука hardware 
dispatch queue а у нового blmk их несколько. hardware dispatch queue это очередь 
запросов на чтение запиьс которая идет от block layer(общий абстрактный уровень работающий с очердями на запросы ) к драйверу кокретного блочного утсройства /dev/sda.
так вот эту очередь  hardware dispatch queue в итоге обслуживает некоторый кокретный цпу
так вот когда раньше она была одна ( персональная для кажого блочного устрйоства)
то как я понимаю поскоьку продивжением запросов по ней и передачей запросов из нее в 
драйвер блочного устройства занимался один цпу и поэтому скорость работы на блочном устройстве
упиралась в скорость одного ядра цпу (при этом непонятно а что сам драйвер блочного устройства
он что неупирался в ядро одного цпу?) а с новым blmk таких очередей hardware 
dispatch queue уже несколько (их число зависит от числа очередей поддерживаемых железкой)
и поэтому как бы теперь число iops которые мы снимаем с железки неупирается в скокрость одного
ядра цпу.(при этом непонятно а что сам драйвер блочного устройства
он что неупирался в ядро одного цпу?)
том кренн пишет - Blk-mq allows for over 15 million IOPS with high-performance flash devices (e.g. PCIe SSDs) on 8-socket servers
Вот еще картинка про blmq - https://www.thomas-krenn.com/en/wiki/File:Blkmq-two-level-Linux-block-layer-design.png

насколко я примерно понял запрос от проги read() поступает в ядро в vfs. 
она обращается  к драйверу конкретной File system оно делает обращение в block layer коду
а тот к драйверу конкртеного блочного устройства /dev/sda (ествственно это все внутри ядра
и там нет никакого /dev/sda ведь это точка входа к блочному утсройству для юзерских программ.)

тут я еще чтото хочу сказать. есть две проблемы. одна это собрать все запросы на чтение\запись 
от всех процессов перегруппироват их и сунуть в блочное устройство. большая работа и большая 
мудота  при этом в том чтобы все это правильно перегруппировать. 
вторая часть работы это обратно доставить к процессу данные которые прилетели наконец
от диска. это две разные проблемы. обратная доставка вроде проще. надо просто взять то
что поступило и сунуть в процесс. значит про первую про первую часть проблемы. как я понял 
со старым планировщиком было так что была одна софт очередь и одна хард очередь на весь комп ( для одного блочного устройства. у каждого блочного устройства своя инивиудальная 
софт+хард очередь. мы щас рассматриваем отдельное блочное устройство и проблему высокосростного доступа к нему). так вот если на пяти цпу крутится пять процессов и каджый из них щас хочет прочитать из одного /dev/sda то каждый из них переходит в режим ядра и пять экземпляров кусков ядра хотят получит доступ к одной и тойже стркутуре в памяти ядра софт очереди и хард очереди. эта структура защищена спинлоком то есть в однин момент времени 
только с одного цпу один кусок кода ядра может с ней рабоатть. незнаю насколко это проблема большая но это проблема. в новом планирщвике каждый код ядра на каждом цпу имеет свою индфивидуаьную софт очередь. ну хорошо. и есть несколько ( в зависимости сколько прддеживает железка /de/sda) хард очередей.это безусловно позволяет более бодро принимать от процессов
запросы IO к /dev/sda. ну хорошо. а драйвер /dev/sda он позвояляет запускаться в несколльких 
экземплярах чтобы бодро принимать увеличивешееся количество запросов с нескольких хард очередей? ведь как это походу работает по мне: процесс на цпу юзерский запускает read (/dev/sda) цпу переклюается в режим ядра. там код ядра пихает запрос в софт очередь ( тут проблем и пересечений с другими процессами и ядрами цпу нет). далее код ядра беррет чтото из софт очереди
и пытается впихнуть в хард очередь . и тут уже есть проелма так как число хард очередей может 
быьт меньше чем число цпу. тоесть там должен стоять спин лок. итак мы тут уже ждем. потом 
наконец мы получили доступ к хард очереди . пихнули туда запрос. далее как я понимаю мы запускаем уже драйвер /dev/sda и из хард очереди он забирает кусок и пихает на железку.
так вот в этот момент надругом цпу может быть ровно такая же ситуация и вопрос когда на первом
цпу запущен драйвер /dev/sda то на дургом цпу может ли быть запущена +1 копия драйвера 
/dev/sda или надо ждать?  если надо ждлат то тогда эта новая модель шедулера всего навсего
нам дала доп буфер в виде софт очередей ( по одному на цпу) и только то а в конечной точке
у нас попрежнему узкое место. непонятно. ну и опять же на старой модели шедулера. ну была у нас одна софт и хард очередь на весь комп ну и что. пока на одном цпу пихает запросы в очередь
на других цпу код ядра неможет этого сделать. типа он ждет ну и что. дело в том что 
даже если код ядра весело запихал на всех цпу запросы в очередь все равно юзерское приложение
спит пока неполучит ответ с диска. непонятно. непонятно также то что очереди конечно 
же предназначены чтобы двигать запросы от приложений к диску. а как доставляются ответы от диска к процессам ? совершенно понятно что когда диск нашел ответ  на запрос он запускает 
интеррапт. выывается интеррапт обработчик. он берет этот ответ от диска и тут вопрос
как обрботчик знает какие куски ответа к какому процессу надо доставить? это вобще непонятно.
также еще вот что непонятно. вот нащ интерапт хендлер забрал ответ от диска и сунул пока в
 память ядра и начал разбраться какому процессу какие байты сунуть. пока он это делает 
 может ли диск выставиь еще интеррапт чтобы его на другом цпу обработали или нет? если нет 
 то получается что ответы от диска завязаны на скости работы одного ядра!
 так что одни вопросы. ответов в инете нет. 
но так в целом они прям усираются о том что раньше мол была одна софт очередь и одна хард 
очередь а теперь их несколько и это мол чудо. мол это снимает ботлнек как бутто там других
ботлнеков нет в этой цепи от read() до запроса в диск.
так вот непонятно вот когда мы в iometer задавали скажем  число потоков в 10.
то ведь они же все равно все уходили в одну очередь на старом шедулере поэтому непонятно
как же эти потоки в юзерской программе трансформировались в потоки к диску ведь в диск
уходил все равно один поток который сумма просто напросто этих десяти потоков.
непонятно.
но они щас на что напирают мол раньше были шпиндели поэтому мол посылать на диск
следущий реквест когда он невернул ответ по текущему реквесту типа небыло смысла ( не знаю
неуверен в верности этого заявления) поэтому старый шедулер имел только один поток ведущий
в драйвер. а щас мол так как у нас ssd\nvme то они могу спокойно искать одновременно 
неоколько независимых реквестов.

очереди зовутся как software queues и hardware queues( синонимы hardware contexts queues\hardware dispatch queues).

далее я щас пытаюсь выяснить сколько hardware queues поддерживает мой текущий 
nvme диск.

$ sudo nvme smart-log  /dev/nvme0n1 
Smart Log for NVME device:nvme0n1 namespace-id:ffffffff
critical_warning                    : 0
temperature                         : 33 C
available_spare                     : 100%
available_spare_threshold           : 10%
percentage_used                     : 1%
data_units_read                     : 10 169 142
data_units_written                  : 14 999 997
host_read_commands                  : 134 639 775
host_write_commands                 : 340 324 085
controller_busy_time                : 399
power_cycles                        : 1 609
power_on_hours                      : 2 318
unsafe_shutdowns                    : 31
media_errors                        : 0
num_err_log_entries                 : 0
Warning Temperature Time            : 0
Critical Composite Temperature Time : 0
Thermal Management T1 Trans Count   : 0
Thermal Management T2 Trans Count   : 0
Thermal Management T1 Total Time    : 0
Thermal Management T2 Total Time    : 0

посмотреть какие nvme неймспейсы есть на диске (это не линукс неймпесейсы а чисто хрень nvme)
$ sudo nvme list-ns  /dev/nvme0n1 
[   0]:0x1

видим что есть один неймспейс.

а теперь более интересная хрень.
выяснить какой размер LBA сектора nvme диск экспортирует наружу в ядро:

$ sudo nvme id-ns  /dev/nvme0n1  -n 1 -H  | grep "LBA Format" | grep Metadata
LBA Format  0 : Metadata Size: 0   bytes - Data Size: 512 bytes - Relative Performance: 0x2 Good (in use)
LBA Format  1 : Metadata Size: 0   bytes - Data Size: 4096 bytes - Relative Performance: 0x1 Better 

отсюда видно что для линукса диск сообщает что у него как бы размер сектора LBA равен 512 байт.
но лучше бы нам ппреключить железку (правда при этом все данные сдохнут) чтобы она стала 
для внешнего мира как устрйоства с размером LBA сектора равным 4KB.
меньше будет запиливаться и больше будет перформанс.

также можно без ключа -n 1 чтобы получить эту инфо
$ sudo nvme id-ns  /dev/nvme0n1   -H  | grep "LBA Format" | grep Metadata

чтобы перкключить диск в режим LBA 4K надо его отформатировать
$ nvme format --lbaf=1 /dev/nvme0n1   
ключ --lbaf=1 его цифра 1 означает то что выше написано тоесть 
0 = LBA Format  0 = 512 байт
1 = LBA Format  1 = 4K 

==========================================================================
- далее я пытас выяснить сколько hardware queues поддерживает мой диск
$ sudo nvme get-feature /dev/nvme0n1 --feature-id=7 -H
get-feature:0x7 (Number of Queues), Current value:0x0f000f
	Number of IO Completion Queues Allocated (NCQA): 16
	Number of IO Submission Queues Allocated (NSQA): 16


pci vs pci-e vs sata vs ahci
что такое шина. шина это набор проводов, разьем и стандарт передачи по проводам.
шина имеет скорость. 
шина содеиняет чтото слева с чем то справа.

pci: это шина и разьем на матплате. одним концом на мат плате она представлена разьемом(куда мы втыкаем внешнее устройство контроллер чегото) другим концом шина уходит в южный мост например ICH9. шина многопроводковая тоесть паралельная. паралельность еще заключается и в том 
что все устройства все разьемы на плате в итоге разделяют одну шину. поэтому они все конкурируют и делят пропускную способность шины. для параеллельных шин обычно
указывают частоту. у pci это 33 Mhz , размерность шины 32 бита. скорость при этом 132МБ\с(33Mhz*4байта=132МБ\с). 
разьемов на плате можте быть несколько скажем пять но все эти разьемы сидят на общей шине
так что либо одна плата будет выжимать 133МБ\с а остальные ноль. Либо все пять будут делить 
133МБ\с.( а не так что каждый разьем будет иметь 133МБ\с). это был основной стандарт.
где то там в конце жизни pci была модификация 66MHZ и 64бита и она выдавала 532МБ\с.
(оно и логично в 2 раза боьше разрядность и в 2 раза болбше частота итого 133МБ\с *2 *2 = 532МБ\ч). итак если мы рассмотрим все же обычную шину PCI 33Mhz,32bit то скорость суммарная
на все устрйоства которые к ней поключены 132МБ\с, они все ее делят между собой.
32битная шина имеет 124 провода (62 по одну сторону от разьема и 62 по другую) в архитектуре. из них данные и адрес используется 64 провода(32 используются под сигнал а 32 для второго конца провода. условно говоря 32 провода это фаза и 32 провода это ноль).
тоесть 4 байта можно передать за раз.  поскольку под передачу данных используется 32 пары
проводов ( остальные под какито доп обеспечительные нужды) то это означает что 4 байта можно 
передавать либо в одну сторону либо в другую , либо туда либо обратно. поэтому шина pci она 
half-duplex. для того чтобы она была полностью дуплексная нужно было добавлять еще 32 пары проводов. для сравннеия ethernet 100. там 2 пары проводов тоест 4 штуки в итоге. по одной паре сигнал идет на отправку по второй на принятие. поэтому там полный дуплекс. зато за один раз можно передать только 1 бит. тоеть еще раз у pci у нее 32 пары проводов и все пары предназначены для отправки только в одну сторону либо туда либо обратно. а у ethernet 100 две пары прием одна строго для отправки а другая строго на прием.  так вот оказалось что 
когда у нас много пар используется для отправки в одну сторону то это типа очень плохо потому что по одной паре сигнал придет чуть позже по другой чуть раньше а поскольку мы дожны принять 
по всем парам в итоге то нам приходится ждать и там наверное еще какието проблемы с влиянием
сигнаа  в однйо паре на другие пары короче оказалось что наращивать частоту сигнала когда у нас
много пар работает в одну сторону очень хреновая перспектива , оказалось что горазло более проще взять вместо 32 пар всего одну пару и по ней охиренно поднять частоту и на выходе мы сможем получить гораздо более высокую скорость пропускную. поэтому отказались от дальнейшего развития многожильной pci шины в сторону маложильных шин в которых скажем 2 или 4 провода. 
прием если 4 то это два в одну сторону и два в другую тоест они друг от друга независят. 
Забегу впреед pci-e шина. у нее есть понятие линия. линия это 4 провода . где одна пара идет
на отправку вторая на принятие. поэтому она фулл дуплекс. и скорость у нее на  данный момент чтото типа 15GB\s ( по сравнению с 133МБ\с у обычной pci). я продолжаю сранивать pci и pci-e.
у pci на ее 32 парах линий сидели сразу все устройства  и делили ее межу собой. у pci-e 
выгляди по другому. условно говоря на мат плате разведено 50 пар линий pci-e. и скажем там первые четыре линии выходят на разьем. потом следущие 4 линии на матплате выходят на разьем.
потом еще 8 линий выходят на разьем. и фишка в том что если мы воткнули карточки в первый и второй разьем то так как линии независимые от устройства невлияют друг на друга. это как 
если бы у pci первые 4 линии выходили на разьем и вторые 4 линии  выходили на свой разьем. 
тогда бы два устройства невлияли друг на друга в плане конкуренции за пропусную способность по через шину. если сказано что разем pci-e x16 это значит что 16 линий выведены на данный разьем.
совестенно если 1 линия выжиаем 15GB то суммарно 16 линий могут выжать 16*15GB\s.
Возвращаемся к PCI. значит из ich9 выходило 62 пары проводов и они уходили на мат плату на разьемы. эти разьемы все сидели на этих 62 парах делили их. получаетс что в каждй момент времени из pci в ich9 прилетало 4 байта инфо только от одного устройства. остальные сидели и ждали когда им дадут тайм слот. но в ICH9 приходили линии нетолько с pci шины но и из других
шин. это и usb контроллер и ethernet контроллер и звуковая карта они тоже приходят 
с мат платы на ich9. тоесть к примеру говоря на плате есть разьем sata и он 
по отдельно распаянной sata шине на мат плане входит  в ICH9. значит ICH9 далее соединяется
с северным мостом по шине DMI. для ICH10 эта шина была по скорости 1GB\s и полный дуплекс.
северный мост уже соединяется с цпу через FSB шину. вот наконец картинка как это выглядело
https://en.wikipedia.org/wiki/File:Motherboard_diagram.svg
на ней видно что все разьемы pci делят между собой одну шину. про FSB шину ну скажем что 
она имела скорость 3.2GB\s. возникает вопрос а  как цпу  обращался к pci шине. 
нужны либо отдельные на цпу адресные линии которые можно выставлять которые должны вести 
в pci линии. либо нужен memory map chip который будет делать то что при выставлении н
на стадартной шине адреса для памяти на цпу некоторого адреса чтобы этот чип переключал
на адресные линии pci. ответа незнаю как это было сделано. потому что в целом варианта у цпу
еще раз повторю два. либо у него должные быть отдельные ножки адреса\данных для ообращения
к шине либо он должен юзать ножки предназначеные для памяти а спец мемори чип должен 
в это время перехватывать и мапить на шину. также видно что dmi шина точно неузкое
место тоесть всем периферийным устройствам хватит ее ширины для обращения наверх.
но возникает интересный вопрос - из картинки видно что слева от цпу видеокарта
справа память снизу южный мост с периферичнымт устройствами так вот фишка втом насколько я понимаю что в каждый момент времени цпу может обращаться тольк к одному устройству. 
тоесть либо к памяти. либо в к видеокарте либо к pci устройству. тоест неможет одновременно
читаь и из видеокрта и из памяти и из pci шины поэтому неочень понятно скажем зачем DMI размером 1GB\s если в любом случае ... хотя на картинке от ICH9 изображен 1GB сеетвой контроллер поэтому да чтобы его сокрость раскрыть нужен наверх шина 1GB\s . я к тому что 
на DMI нужна скорость несуммарная от всех периферийных устройств сидящих на ICH9 а только 
скорость самого быстрого. потому что цпу неможет обращаться более чем к 1 устройству на текущий  момент. едиснвтенное что возможно еще играет роль это DMA. тоесть 
DMA контроллер может качать данные из периферийного устройства в память через ich9 и северный мост и однрвемнно цпу в это время может качать данные скажем с сетевого контроллера. тогда 
да получается что через DMI в момент времени будет протекать потоки от двух периферийных устройств одноврменно и тогда DMI должен быть шире чем пропускная споосбность этих двух 
и более устройств. вот еще картинка для схемы северный мост-южный мост 
https://en.wikipedia.org/wiki/File:Intel_4_Series_arch.png
кстати когда бала схема севеный+южный мост то контроллер памяти сидел в северном мосту.
далее вместо и южного появилась схема одного моста PCH (platform controller hub)
который соединяется с цпу по DMI. а контроллер памяти сидит в цпу. память уже содеиняется
напрямую с цпу без участия мостов. схема - https://en.wikipedia.org/wiki/File:Intel_5_Series_architecture.png

Возврашаемся к PCI.
итак байти от нее летел в ICH мост южный. далее через DMI летет в северный мост и далее
через FSB летел в цпу. вот стока переходов. 
это нам пригодится когда щас будет рассматривать PCI-e. насколько там сократился этот путь.

а пока рассматриваем PCI и ее связь с дисками. диск в pci напрямую не воткнуть.
в PCI втыкался контроллер дисковый . на нем находился PATA контроллер.одним концом
эта плата воткнут в pci шину. на контрллере находится разьем PATA. воткнут кабель PATA
и он уже уходит в диск с разьемом PATA. либо контроллер распаян на плате и тут я незнаю
он был подключен к шине PCI либо он был подлкючен к ICH мосту напрямую минуя PCI. 
скорость PATA шины это 133МБ\с.
PATA шина она тоже как и PCI много проводковая. она также полудуплекс. 
шина имела 40 либо 80 проводков. ширина 16бит то есть 2 байта. значит 16 проводков под дата
3 под адрес ( на щине могло сидеть максимум 2 устройства). с обратный проводками там как то более хитро чем у PCI. но главное что 40 жильный разьем и 80 жильный отличались тем что 
доп 40 жил это все типа ЗЕМЛЯ предназначенная для того чтобы можно было повысить частоту 
шины до 66MHz. тоесть доп 40 жил они были не для того чтобы добавить полный дуплекс. 
они были служебные чтобы можно было добавить частоту. да и смысла небыло в полном дуплексе
ибо крутящиеся диски могли либо читать либо писать. одновременно там бы упала скорость сильно.
получается схема выглядела в лучем случае байтик который летел от диска его путь 
выглядел так:

диск - PATA шина - (PATA контроллер в ICH9) - DMI щина - north bridge - FSB шина - цпу

или еще хуже


диск - PATA шина - PATA контроллер - PCI шина - ICH9 - DMI щина - north bridge - FSB шина - цпу

так значит с PCI и PATA разобрались.

переходим к SATA:
Sata это шина и разьем. SATA в отличие от PATA или PCI неимеет множества проводов.
в этом плане sata шина она очень узкая. в плане скорости выдает SATA 3 выдает 6Gbit/s или еще пишут так что выдает 6GT/s это одно и тоже. но фишка в чем, нахера тексели ввели, фишка втом что на каждые 8 переданных бит добавляется 2 служебных бита(обозначается 8b/10b) поэтому 6Gbit\s это полный поток
а поток полезной информации это 6(Gbit\s) * 8\10 = 4.8 Gbit\s или ~600MB/s 
Далее важно сказат что sata это полудуплексный шина тоесть данные в момент времени
по шине летят либо только туда либо только обратно но не одновременно. 600MB\s это скорость
либо туда либо обратно. 
теперь возвращемся к очень интересному моменту. в проводе SATA между контроллером и диском
4 провода а наконцах этого провода 7 пинов. И это для меня загадка. Единственное что 
4 пина это для передачи данных , тоесть эти пины это как провода что мы видим в проводе
а 3 пина это GROUND и я непонимаю а что ground нетребует наличия проводов в проводе?
вот это мне непонятно. переходим к тому почему 4 провода в кабеле. как я понял смысл такой - 
эти четыре провода это две пары обычных контуров электрических. тоесть в одной паре ток входит
в один провод и возвращается через другой и во второй паре тоже самое. возникает идея что 
по одной паре передается инфо туда а по другой обратно. тоесть один бит пераедается по одной паре туда а другой бит передатеся по другой паре обратно. типа мы имеем полнодуплексную шину шириной 1 бит. ну или это шина шириной 2 бита в одну сторону полудуплексная. однако все совсем
нихера нетак все устроено у SATA. значит у SATA применяеся differential signaling. что это значит. для него нужно 4 провода (например). далее я пока непонимаю как физически передается сигнал и как он фиксируется но примерно так: у нас есть первая пара проводов которая является
классической электрической парой (типа как два провода из розетки и лампочка, один провод это фаза второй это ноль). так вот на первой паре на первом проводе на фазе мы дергаем по времени 
Voltage. например было там +0 а мы на короткое время дернули его на +12V. и это возмущение
побежало по проводу. Что ловят на том конце я незнаю. То ли изменнеие волттаджа во врмени
то ли появление тока. я незнаю. но возмущение долетит до второго конца и там словят условно говоря появление +12V. и через ноль эта хрень улетает обратно. Теперь берем вторую пару 
проводов и в фазу подаем в тотже момент времени -12V. и это вомзущение побежало по проводу.
А теперь самая главная хрень зачем мы это мутили - если на провода снаружи идет наводка электромагнитная то она и в первом контуре скажем для примера исказит сигнал и прибавит  к нему условно говоря +1V и во втором контуре она сделает тоже самое. так вот на той стороне
стоит электрический (незнаю как это на практике выглядит) дифференциатор. и тогда вот что 
он там получает 

+12V+1V - ( -12V +1V) = +12V + 1V +12V -1V = 24V

тоесть наводка будет полностью уничтожена этим дифференциатором исходя из того что она дала 
одинаковое возмущение на оба контура. а наш исходный сигнал получен с удвоенной амплитудой.
вот эта вся схема и называется differential signaling. а используется она для защиты от внешних наводок. сотвественно логично что обе фазы обоих контуров надо в кабеле расположить максимально близко чтобы внешнее воздействие на обе фазы было по амплитуде максимаьльно одинаковое. Итак по сути у нас через два канал передается всего один бит информации. но зато мы имеем помехаозащищенность. для сравнения посмотрим что было бы если бы мы использовали 
одну пару проводов и single ended signaling. тоесть у нас есть одна пара проводов и мы
на фазе дергаем и выставляем имупульс +12V.
возмущение летит по проводу и тут снаружи у нас помеха и она дает -13V
тогда на втором конце мы вместо +12V получим -1V тоесть бит информации абсоллютно потерян.
когда же у нас differential signaling то мы будем иметь

+12V-13V - ( -12V -13V) = +12V - 13V +12V +13V = 24V

как видно бит непотерян ( ну тоесть если у нас будет делитель сигнала на два то мы получим
на втором конце теже самые +12V). вот что знчит differential signaling, вот зачем он нужен
и вот почему в sata кабеле четыре провода и при этом по факту шина полудуплексаная и имеет ширину 1 бит. 

Единственное что мне непонятно. для differential signaling надо иметь 4 провода в кабеле
и экранировать вроде их получается ненадо это плюс. но зато они должны идти друг от друга 
на постоянном расстоянии. это минус.  а если мы гвооими про защиту от помех то можно было бы
взять просто два провода с single ended signaling и просто на них наложить железный экран
снаружи и тогда тоже небудут помехти снаружи влиять. так в чем проблема? неужели 
изговтовить кабель  с двумя экранрованными проводами сложнее чем изготоввить кабель с четырьмя 
неэкранированными проводами но идущих на одинаковом расстоянии? непонятно

но зато хотя бы стало понятно почему в sata кабеле 4 провода при том что передается всего 
1 бит и сввязь полудуплексаная.


- компексные числа и сигналы.
компдексное число это (по определению) всего навсего пара чисел. обозначается вот так
(x,y).  и сразу видно что компл число в точности выглядит как координата точки на какойто
плоскости.

еще (по определению ) комплексное число обозначается как z. тоесть
(x,y) и z это одно и тоже.

для комлпесного числа (по определению) определены операции сложения, умножения, равенства.

равенство:
 это когда
z1=(x1,y1)
z2=(x2,y2) 
тогда z1=z2 если x1=x2 и y1=y2

cсложение:
z3=z1+z2
z1=(x1,y1), z2=(x2,y2)
z3=(x1+x2,y1+y2)

умножение:
z3=z1*z2 = (x1*x2-y1*y2, x1*y2+x2*y1)
физичекий смысла неочень понятен.

далее рассматриваются числа вида (x,0)

z1+z2 = (x1,0) + (x2,0) = (x1+x2, 0)
z1*z2 = (x1*x2,0)

ну видно что получаемое компл число тоже имеет вид (x,0)

дальше они пишут стремную вещь что (x,0) поэтому можно обозначать как просто x 
тоесть

(x,0)=x

по мне это равенство это хрень какаято. обьекты справа и слева это разные штуки.
а именно слева находится пара чисел x и 0 а справа одно число x и как 
это можно приравнивать? ведь комплексное число по опредеению это ПАРА чисел! пара!
поэтому пара никак не может быть эквивалентна одному числу!. два числа никак не могут
быть эквивалентны одному числу! поэтому я пока могу эту хрень только вот так 
интерпретировать: если у нас указано x то это типа такое типографское сокращение
для обозначения (x,0). итак еще раз
если указано просто x то мы пониммаем что это сокращение обозначений ( считай что по факту
это некоректное обозначение) и по факту это некоректное обоначение обозначает (x,0).
опять же еще раз - определение комплексного числа это всегда пара чисел. (x,y)
нет никаких комплесных чисел вида x. что еще интеренее что есть определение о том как 
сложить два компелксных числа и как умножить два комплеатных числа но совсем нет 
инфо о том как сложить или умножить комлпексное число и некомплексное число!


(тут еще набор пространных рассуждений. - по мне хрень полная. слева координата а справа число. совершенно разные обьекты.
хотя можно вот так рассматривать что число x оно может быть обозначено на числовой прямой.
если у нас есь числовая прямая то координата числа x это x или вот так (x) просто обычно
никто не использует координаты для числовой прямой. числовая прямая это одна из осей плоскости в которой есть две оси координат. как только мы добавляем вторую ось то все числа
на исходной числовой прямой автоматом приобретают вид (x,0) а если третью ось добавим 
то приобретают вид (x,0,0) таким образом в какойто степени (x,0)=x хотя это как бы и хрень хотя как сказать. что является первичным число или числовая прямая. если числовая прямая то число это всего лишь ее свойство тогда скорее (x,0) явялется коректной записью числа а запись 
вида x это некий колхоз ибо небывает просто чисел числа все сидят на числовой прямой. вобщем хрен знает. ясно по крайней мере то что между числом x и точкой на оси (x,0) можно установить однозначное соотвествие. это точно. тоесть нет такого числа x которого бы небыло на (x,0)
и нет такой точки (x,0) на оси для которого бы несуществовало бы числа x. а так в целом непонятно что первично числа которые уже затем образуют числовую ось или ось внутри которой содержатся числа. поидее ось первична а числа это ее свойство. типа как  космос и пространство первича а атомы это их просто свойства. типа нет ни одного числа которые бы было рождено вне числовой прямой. наверно как то так. так.. хотя... что такое число если взять
напримере натуральных чисел. число это кучка яиц куриных или горка песка морского. хотя опять же это несамо число это его форма визуализации. что такое само число непонятно. чтото 
нематериальное чтото неведомое. типа как тепло. есть некая форма носителя или форма восприятия на теле но что такое тепло само неясно. так и число. если начать выкладывать 
в ряд числа в форме песка то это будет ряд горок от маленьких до больших. это будет 
альтернативный аналог числовой прямой. поэтому все таки вначале числа а числовая ось это форма визализации.. пока про это все.

далее рассматривается 

(x,0)*(1,0)=(x*1,0)=(x,0)
мы видим что умножение дало тот же результат что и исходное число
тоесть 
(x,0)*(1,0)=(x,0)

далее они еще раз пытаются установить связь между обычными числами и комплексными
они говорят что обычное число А и комплексное число (A,0) это одно и тоже ( у меня шок)
с одной стороны как число и пара чисел может быть одним и тем же. вот для примера 
прдеставим обычную трехмерную систему координат ( несвязанную с комплексным числом никак).
далее берем число 1. вопрос  (1,0,0) (0,1,0) (0,0,1) и 1 это одно и тоже число ? или может
вообще нельзя сравнивать обьекты разной природы. что такое (1,0,0) = есть три множества
чисел ( каждая ось это множество) и мы берем по одному числу из каждого множества 
и создаем новое множество из трех чисел 1,0,0 . множество из трех чисел. как можно множество
из трех чисел приравнивать к числу? поэтому я считаю что говорить что число А и множество
из двух чисел А,0 одно и тоже это некоректно. однако далее я принимаю эту их точку зрения
и считаю что если написано А то это типографское сокращение для комплексного числа (А,0)
Так вот далее они говорят что мы щас мол введем операцию умножения обычного реального числа
на комплексное число ибо к данному моменту мы такого рода операцию не определелили.

А- обычное число . но мы себе понимаем что на самом деле это комплекс число (A,0)
z - комплексное число
тогда
A*z это будет умножение не обычного числа на комплексное а комплексного на комплексное (а это мы уже умеем делать) а именно

A*z=(A,0)*(x,y)=(А*х, А*y)

итак еще раз если мы видим в одной строке комлпксное число и обычное число то мы сразу
понимаем что никакого обычного числа нет а это просто типографское сокрашение для комлпексного числа (А,0)



Далее рассмотрим умножение  (x,0)на  (0,1)

(x,0)*(0,1)=(x1*x2-y1*y2, x1*y2+x2*y1)=(0-0,x)=(0,x)
тоесть
(q,0)*(0,1)=(0,q) 
если мы заменим (q,0) типографским сокращением на q то получаем
q*(0,1)=(0,q)
или
(0,y)=y*(0,1)
еще раз подчеркну что y это просто сокращение типографское для комплксного числа (y,0)
потому что у нас операции определены только для комлпксных чисел поэтмоу все числа 
в строке дожны быть строго комлексные.
комплексное число (0,1) называется мнимой единицой(чисто такой у нее позывной). это 
число так называют потому что
(0,1)*(0,1)=(0-1,0)=(-1,0)
если мы обозначим число 0,1 как i то получаем
i*i=(-1,0)
или
i^2=(-1,0)
далее заменяем (-1,0) на типографское сокращение -1
получем
i^2=-1
еще раз хочу подчернуть что -1 в данном случае это не -1 а сокращение для комлпксного числа (-1,0) так что ненадо путать -1 и (-1,0)

двигаем дальше:
z=(x,y)=(x,0)+(0,y)
вышем мы получали что (0,y)=(y,0)*(0,1)
заменяем (0,1) на ее обозначение через i получаем 
(0,y)=(y,0)*i=i*(y,0) подставляем в z

z=(x,y)=(x,0)+(0,y)=(x,0)+i*(y,0)

пока все строго пока все четко.

дальше применяем типографское сокращение что (x,0) это x тогда

z=(x,0)+i*(y,0)=x+iy

z=x+iy 
это типа алгебраическая форма обозначения комлпкексного числа.
еще раз хочу подчеркнуть что эта форма это фикция. на самом деле нет в этой формул никакого
x и y болтающихся свободно в строке. это просто сокращение. реальная формула коректная это

z=(x,0)+i*(y,0)

где опять же i  это (0,1)


еще раз итак мы имеем
z=(x,y)=x+iy
отсюда мы чисто на глаз видим важную полезняшку
когда мы имеем алгабраическую форму комлпексного числа то то что стоит за буквой i
это вторая компоенента а то что стоит без буквы i то это первая компонента.тоест 
пример
z=3-i6 это значит что z=(3,-6)
тоесть мы можем мгновенно переводить одну форму записи коплексного числа в другую





рассмотрим
z1+z2=(по определению)=(x1+x2,y1+y2)
теперь рассмотрим в новой форме z1+z2=(x1+iy1)+(x2+iy2) , теперь приравниваем
(x1+x2,y1+y2) = (x1+iy1)+(x2+iy2)
раскроем правую часть и проверим что получим то что слева
(x1+iy1)+(x2+iy2)=(x1,0)+i*(y1,0)+(x2,0)+i*(y2,0)=(x1+x2,0)+(0,y1)+(0,y2)=
=(x1+x2,0)+(0,y1+y2)=(x1+x2,y1+y2)
сравниваем с тем что слева
(x1+x2,y1+y2)=(x1+x2,y1+y2)
совпало ну а как же оно могло несовпасть.
я думаю что из алгеабраической формы для операции сложения тут важно
заметить что походу мы можем(чисто на пальцах) вынести правило такое что :
 z1+z2=(x1+iy1)+(x2+iy2)=(x1+x2)+i(y1+y2)



ну и для операции умножения: 
z1*z2=(x1,y1)*(x2,y2)
c одной стороны(по определению) 
z1*z2=(x1*x2-y1*y2, x1*y2+x2*y1)
с другой стороны используем новую форму записи комплексного числа 
z1*z2=(x1+iy1)*(x2+iy2)
получеаем:
(x1*x2-y1*y2, x1*y2+x2*y1)=(x1+iy1)*(x2+iy2)
исходя из этой штуки мы можем взять дерзость смелость применяя к правой части
колхозные методы работы с обыкновенными числами получить то что слева.тоесть раскрыть скобки
как мы бы это делали с обыкновенными числами. (хотя такой подход это чисто наш неподекрепленны математически метод). поехали раскрываем скобки:
(x1+iy1)*(x2+iy2)=x1x2+i*x1y2+i*y1x2+i*i*y1*y2
группируем и используем то что i*i=(-1,0)=-1
x1x2+i*x1y2+i*y1x2+i*i*y1*y2=x1x2+i(x1y2+y1x2)-y1y2=(x1x2-y1y2)+i(x1y2+y1x2)
сравниваем левую часть которая точно верна потому что по определению
и правую которую мы вывели колхозным пальцевым некоректным методом
(x1*x2-y1*y2, x1*y2+x2*y1) = (x1x2-y1y2)+i(x1y2+y1x2)
и как бы да все совпало. откуда я чисто из пальца делаю вывод
что в алгебраической форме с компоентами комплексного числа можно работать ровно также
в плане раскртия скобок сложения и умножения так же как мы это делаем для простых чисел.
это удобно. в этом плюс алгабраической формы. хотя строгого доказтельсва у меня нет.

далее.
комплксно сопряженное число.
число (x,-y)=x-iy является комплесно сопряженным числу (x,y)=x+iy

далее.
модуль комплексного числа ( по определению) обозначается как |z| и оно равно sqrt(x^2+y^2)
тоесть
|z|=sqrt(x^2+y^2)
теперь тоже самое в других формах
|z|=|(x,y)|
|z|=|x+iy|

теперь смотрим когда же |z|=0. это будет когда sqrt(x^2+y^2)=0 а это будет когда 
x=0 и y=0.
подставим x=0 и y=0 в алгебраическу форму
|z|=|0+i*0|=|i*0|=|(0,1)*(0,0)|=|(0,0)|=sqrt(0+0)=0

далее расматривается случай коплексного числа (x,0)
|z|=sqrt(x^2+0)=|x|
таким образом |z| для (x,0) совпадаеь с модулем обычного числа |x|

далее
z=x1+iy1
(сопряженное)z=x1-iy1
z*(сопряженное)z=(x1+iy1)(x1-iy1)=(x1,y1)*(x1,-y1)=(x1*x1+y1*y1, 0)=(x1^2+y1^2,0)
получаем(используем алгебраическую форму)
z*(сопряженное)z=x1^2+y1^2
теперь вспоминаем что |z|= sqrt(x^2+y^2).
возведем в квадрат
|z|^2= (sqrt(x^2+y^2))^2=x^2+y^2
теперь сравниваем:
z*(сопряженное)z=x1^2+y1^2
|z|^2= (sqrt(x^2+y^2))^2=x^2+y^2
видим что получаем одно и тоже .значит:
z*(сопряженное)z = |z|^2


далее. 
замечают что модуль |z| и модуль |сопряженный z| совпадают.
тоесть
|z|=sqrt(x^2+y^2)
|сопряженный z| = sqrt(x^2+(-y)^2)

далее они доказывают что
(z1*z2)*z3 = z1*(z2*z3)
и то что
(z1+z2)*z3 = z1*z3 + z2*z3
ну понятно как доказывается. 
и в книжке написано что благодаря этому доказывается что можно выполнять операции
с комплекными числами как бутто это обыкновенные числа и i  в том числе. то чем я занимался
там выше.

далее рассматриваются числа 1=(1,0) и 0=(0,0) и их свойства
z+0=z+(0,0)=z
z*1=(x+iy)*(1+i*0)=x+iy=z


далее.
разность z1-z2 называется такой z3 что z3+z2=z1

найдем 0-z
пусть z=(x,y)
искомый z3=(x3,y3)
0=(0,0)
тогда
(x3,y3)+(x,y)=(x3+x,y3+y)=(0,0)
значит
|x3+x=0
|y3+y=0

значит
|x3=-x
|y3=-y

значит
z3=(-x,-y)

найдем теперь общий случай z1-z2=z3
(x3+x2,y3+y2)=(x1,y1)

значит
|x1=x3+x2
|y1=y3+y2

значит
|x3=x1-x2
|y3=y1-y2

значит общее правило как выполнять отнимание:
z1-z2=(x1-x2, y1-y2)


далее
посмотрим чему равно 
-1*z= (-1+0i)(x+iy)=-x-iy=(-x,-y)
сравниваем и замечаем что 
0-z=-1*z
интересно.


далее
определяем что такое операция деления. z1:z2=z3
так вот z3 по определению это такое число что z3*z2 должно дать z1
итак ищем z3 пользуясь выражением z3*z2=z1
умножаем левую и правую часть на (сопряженное)z2

(сопряженное)z2*z3*z2=(сопряженное)z2*z1
тут мы пользуем формулу что раньше получили (сопряженное)z2*z2=x2^2+y2^2
значит
(x2^2+y2^2)*z3=(x2-iy2)(x1+iy1)
двигаем дальше
работаем с правой частью
(x2-iy2)(x1+iy1)=x2*x1+i(y1*x2)-i(y2*x1)-i^2*y2*y1=x2*x1+i(y1*x2-y2*x1)+y2*y1=
=(x2*x1+y2*y1)+i(y1*x2-y2*x1)=(x2*x1+y2*y1, y1*x2-y2*x1 )
подставляем
(x2^2+y2^2)*z3 = (x2*x1+y2*y1, y1*x2-y2*x1 )
работаем с левой частью
(x2^2+y2^2)*z3=(x2^2+y2^2)*(x3+i*y3)=x3*(x2^2+y2^2)+i*y3*(x2^2+y2^2)=
= ( x3*(x2^2+y2^2),  y3*(x2^2+y2^2)   ) 
подставляем
( x3*(x2^2+y2^2),  y3*(x2^2+y2^2)   ) = (x2*x1+y2*y1, y1*x2-y2*x1 )
значит чтобы было равенство то значит должно выполняться:
| x3*(x2^2+y2^2) = x2*x1+y2*y1
| y3*(x2^2+y2^2) = y1*x2-y2*x1

значит
x3= (x2*x1+y2*y1)
    --------------
    (x2^2+y2^2)

y3= y1*x2-y2*x1
    ------------
    (x2^2+y2^2)



значит
z1     (  x2*x1+y2*y1     y1*x2-y2*x1  )
--- =  ( --------------,  ------------ )
z2     (  (x2^2+y2^2)     (x2^2+y2^2)  )


выполним пример
1+i     2*1+(-3)*1       1*2-(-3)*1     -1       5
---- = ------------ + i*------------ = ---- + i*----
2-3i    4+9               13            13       13


далее смотрим на счет |z1*z2| = |z1|*|z2| проверяем
берем левую часть
z1*z2 = (x1+iy1)*(x2+iy2) = x1*x2+x1*i*y2+i*y1*x2-y1*y2 = (x1*x2-y1*y2)+i(x1*y2+y1*x2)
далее 
|z1*z2|=sqrt[(x1*x2-y1*y2)^2+(x1*y2+y1*x2)^2]
тут давай упростим выражение в скобках
(x1*x2-y1*y2)^2+(x1*y2+y1*x2)^2=(x1*x2)^2 + (y1*y2)^2 - 2*(x1*x2)(y1*y2) +
+ (x1*y2)^2 + (y1*x2)^2 + 2*(x1*y2)(y1*x2) = (x1*x2)^2 + (y1*y2)^2 +  (x1*y2)^2 + 
+ (y1*x2)^2 = x1^2*(x2^2+y2^2)+y1^2*(y2^2+x2^2) = (x2^2+y2^2)*(x1^2+y1^2)
подсталяем 
|z1*z2|=sqrt[ (x2^2+y2^2)*(x1^2+y1^2) ]

теперь работаем с правой стороной
|z1|*|z2|=sqrt(x1^2+y1^2)*sqrt(x2^2+y2^2)=sqrt[ (x1^2+y1^2)*(x2^2+y2^2) ]

теперь сравниваем
|z1*z2|   = sqrt[ (x2^2+y2^2)*(x1^2+y1^2) ]
|z1|*|z2| = sqrt[ (x1^2+y1^2)*(x2^2+y2^2) ]
получили одно и тоже, значит
|z1*z2| = |z1|*|z2| 

теперь проверяем то что:
|z1|   |z1|
|--| = ----
|z2|   |z2|

используем то что (z1\z2)*z2 =z1
действительно z1\z2= (по определению) z3 такой что z3*z2=z1
далее накладываем на них модуль.
|(z1\z2)*z2| = |z1|
теперь используем выше доказанное свойство :
|z1*z2| = |z1|*|z2|
значит
 |(z1\z2)*z2|=|(z1\z2)| * |z2| . подставляем это вверх

|(z1\z2)| * |z2| = |z1|
далее поскольку модуль это уже чисто обыкновенное число то мы можем с ними 
делать классические алгебраические операции , значит:
|(z1\z2)| = |z1| \ |z2|

или более красиво
|z1|   |z1|
|--| = ----
|z2|   |z2|


далее. 
переходим к геометрической интерретации комплексного числа.
значит по определению комплексное число это пара действительных чисел. тоесть
(x,y). так вот ровно тоже самое это координаты точки на прямоугольной системе координат. (x,y). координаты это тоже пара действительных чисел. а что такое координата точки более подробно?- это разложение вектора по двум другим векторам (1,0) и (0,1) тоесть

{x,y}=x*{1,0}+y*{0,1}

заметим что комплксное число ровно так и выглядит в алгераичкской записи

(x,y)=x*(1,0)+y*(0,1)

мы теперь понимаем что компкс число (x,y) можно интепретировать и как точку
на плоскости и как вектор. что же это за вектора (1,0) и (0,1) какой у них физический смысл в плане комплексного числа: (0,1) это компл число i, таким образом
компонента y комплексного числа это разложение по вектору i(который лежит на вертикальной оси). (1,0) это одиночный вектор на гор оси. 


интересно каково определение обратного числа у комплексного числа. у действительного  числа это число (как я понимаю) такое что оно получается путем
умножения на -1, то есть -x это такое число которое можно найти путем операции -1*x.
наверное для комплексного это тоже так(только мы умножаем не на -1 а на комплексное число (-1,0) ? тогда

-z=-1*z=(-1,0)*z=(-1,0)*(x,y)=(-1+i*0)(x+iy)=-x-iy+0+0=(-x,-y)
-z=(-x,-y)

значит в геометрической интерпретации число -z относительно числа z получается 
путем зеркально отражения относительно обоих осей.

числа z и (сопряженное z) друг относиельно друга отличаются тем что симметрично отражены относительно горизонтальной оси.

модуль |z| интерперетируется как длинна вектора или как расстояние от точки z до 
начала координат (что одно и тоже)

сложение и вычитание z1 и z2 имеет смысла правила сложения вычитания векторов z1 и z2

|z1-z2| приобретает смысл расстояния между двумя точками.

дальше немного прикольного:
точки z такие что |z-z0|=R0 это окружность радиуса R0 в центре z0
точки z такие что  |z-z1|=|z-z2| это серединный перпендикуляр к отрезку с концами 
в z1 и z2

забавно и дебильно то что все эти вот понты на счет комплексных чисел это все
на самом деле всего навсего старые добрые вектора и точки на плоскости но поданные
под понтовой оберткой под названием комлпексное число. да уж...

тоесть зачем было придумывать новую сущность когда она по факту является старыми
сущностями. 

уравнеение эллипса:
|z-z1|+|z-z2|=2a 
это эллипс с фокусами в z1 и z2 и большой полуосью 2a


далее.
тригонометрическая форма комплексного числа.

оступление:
реально прикольно что клмпелксное число это всего навсего точка на плоскости.(ну или вектора)
к чемутогда все эти понты. единственное что непонятно каков физический смысл 
операции умножения. если он имеет конкретный геометрический смысл то вообще незачем
было городить огород.

продолжим:
в декартовых координатах мы выражаем положение нашей точки на плоскости
через два отрезка под углом 90 градусов друг к другу.  а тепрь рассмотрим новую 
фишку полярные координаты. тут у нас есть точка. называется полюс.и есть из нее
луч или ось. так вот положение точки на плоскости определяется через расстояние 
до полюса и угла между осью. если совмещать декартовы координаты и полярные
то обычно полюс лежит в точке (0,0) декартовых координат а луч полярных координат
лежит на оси x декартовых координат. если в декартовых координатах у нас 
координатами являются x,y то в полярных кординатах у нас таковыми являются r и phi.
где r это расстояние от точки до полюса а phi это угол. 

в полярных координатах логично что |z|=r

что касается взаимосвязи декартовых координат x,y и полярных координат r,phi
то связь такая:

| x=r*cos phi
| y=r*sin phi

тогда теппрь берем определение комплксного числа тоесть что
z=(x,y)
и подставляем в него и получаем
z=(r*cos phi, r*sin phi)

по факту у нас ничего нового и страшного не прозошло. опредеение ненарушено
у нас как и прежде комплс число это пара дейтсивтельных чисел.

если мы возьмем алегеабраичечкую форму комплкс числа

z=x+iy

причем мы помним что в этой формуле x это совсем не число x а это дебильное
типографское сокращение (x,0) что совсем разные вещи. тоже самое мы помним что y
это непросто число а это типографское сокращение (y,0) , тоесть что на самом деле

z=(x,0)+i(y,0)

и подставим то что выше с r и phi то получим

z=(r*cos phi,0) + i*(r*sin phi,0)

далее используем что 
(r,0)*(cos phi,0)=(r*cos phi,0)

тогда
z=(r,0)*(cos phi,0) + i*(r,0)*(sin phi,0)

далее используем ранее выведенное что z1*z2=z2*z1 тогда 
i*(r,0)*(sin phi,0) = (r,0)*i*(sin phi,0)
подставляем

z=(r,0)*(cos phi,0) + (r,0)*i*(sin phi,0)

далее испольpуем доказанное ранее что 
z1*z2+z1*z3=z1*(z2+z3)

тогда:
z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ]

далее они используют опять вот это вот типографское дебильное сокращение 
(которое с точки зрения математики некоректно) о том что дескать давайте
обозначать (x,0) как x но будем помнить об этом в голове. 
тогда:

z(r,a)=r*[ cos(a) + i*sin(a) ]    #тригонометрическая форма компл числа
 
это так называемая тригонометрическая форма обозначения комплексного числа.( я бы конечно называл комплексный обьект но никак не комплексное число. дебильная терминология)

еще раз вспомним алгебраическую форму
z(x,y)=x+iy  # алгебраическая форма

и вспомним форму компл числа которая дается по определению:
z(x,y)=(x,y)

Но еще раз хочу сказать что также как в алгебраической форме мы помним что 
то как она записана это некое дебильное сокращение и по факту формула другая
также и в тригонометрической формуле мы должны помнить что это всего лишь дебилное
типографское сокращение а по факту формула коректая с математической точки 
зрения выглядит совсем по другому:

z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ]

это надо обязательно помнить.

далее
что еще дебильно это то что угол phi обозначают и как phi и как arg z.
дада это одно и тоже. поэтому если где то видим arg z то понимаем что это всего навсего phi и больше ничего.

Теперь рассмотрим случай когда r=1,
тогда

z=(r,0)*[ (cos phi,0) + i*(sin phi,0) ] = (1,0)*[ (cos phi,0) + i*(sin phi,0) ] =
=  (cos phi,0) + i*(sin phi,0)
или
z=(cos phi,0) + i*(sin phi,0)
в данном случае мы получили что z зависит только от phi. 
тоесть было z(r,phi) а стало z(1,phi).окей.
теперь посмотрим а что будет если заменим phi=a+b. тоесть 
у нас станет z=z(1,a+b)

z(1,a+b)=[cos (a+b),0] + i*[sin (a+b),0]

далее используем формулы хорошо известные
cos (a + b) = cos a cos b - sin a sin b
sin (a + b) = sin a cos b + cos a sin b

подставляем:

z= (cos a*cos b,0) - (sin a*sin b,0) +i*(sin a*cos b,0) +i*(cos a*sin b,0)
рассмотрим его кусочки:
первый кусочек
(cos a*cos b,0)+i*(cos a*sin b,0)=(cos a,0)*[ (cos b,0) + i*(sin b,0) ]
второй кусочек
- (sin a*sin b,0)+i*(sin a*cos b,0)= (sin a,0)* [ -(sin b,0)+i*(cos b,0) ]
далее юзаем что -1=(-1,0)=i*i, 
подставлем:
(sin a,0)* [ -(sin b,0)+i*(cos b,0) ] = (sin a,0)* [ i*i*(sin b,0)+i*(cos b,0) ]=
=(sin a,0)*i*[ i*(sin b,0)+(cos b,0) ]
подставляем кусочки обратно:
z= (cos a,0)*[ (cos b,0) + i*(sin b,0) ] + (sin a,0)*i*[ i*(sin b,0)+(cos b,0) ]=
=[ i*(sin b,0)+(cos b,0) ]*[(cos a,0) + (sin a,0)*i] 

или в чуть более красивом виде
z=[ (cos b,0) + i*(sin b,0)+ ]*[(cos a,0) + i*(sin a,0)]

вспоминаем что наш z это z(1,a+b)
тогда
z(1,a+b)=[ (cos b,0) + i*(sin b,0) ]*[(cos a,0) + i*(sin a,0)]

вспоминаем тригонтметрическую форму записи
z(r,phi)=(r*cos phi,0) + i*(r*sin phi,0)
берем r=1 подставляем
z(1,phi)=(cos phi,0) + i*(sin phi,0)

и теперь используя эту формулу мы можем преобразовать формулу z(1,a+b)
z(1,a+b)=[ z(1,b) ]*[ z(1,a) ]

интересное свойство! тока надо помнить что оно верно только для случая r=1.
при других r все будет подругому.

далее они выводят что 
          z(1,a)
z(1,a-b)=-------
          z(1,b)













далее я рассмаотрю очень интересуню тему: выразить тригонметрическую форму
через алгебраическую форму.
задача. у нас есть комлексное число 
в алгебраоичской форме

z=x+iy

нужно найти r и phi (через x и y) которые нам позволят записать тоже 
самое число в тригонометрической форме:

z=r(cos phi + i*sin phi)

итак дано x,y нужно найти r,phi.

имеем систему:

|x=r*cos phi
|y=r*sin phi

ясно что:

r=sqrt(x^2+y^2)

итак r мы нашли. 

теперь ищем phi.
ясно что:

|cos phi=x/r = x/sqrt(x^2+y^2)
|sin phi=y/r = y/sqrt(x^2+y^2)


эта система уравнний однозначно определяет phi.  действтельно. взяли отмеряли на 
гор оси известное нам значение x/sqrt(x^2+y^2) это косинус. 
данному косинусу соотвествуют два угла. проводим из точки на гор оси(которая равна косинусу) верт черту до пересечения с окружностью. получаем две точки
пересечения с окружностью над гор осью и под гор осью. 
мы получили два угла для каждого из которых косинус угла равен нашему косинусу. тоесть у нас два угла 
кандидата. чтобы убрать лишнего кандидата надо заюзать синус. у нас  есть известный синус y/sqrt(x^2+y^2) . если  знак синуса с плюсом 
то наша искомая точка над осью X если синус со знаком минус то наша искомая точка
под осью X. когда нашли точку на окружности то мы нашли и угол. нашли его однозначно.

правда их углов все же  будет бесконечное множетсво ибо
если наш надйенный угол =phi0 то решением системы будет любой угол такой что: 
phi=phi0+2*pi*k, k=0,1,2...

насколько я понял какойто красивой формулы решения верхней
системы нет. мы находим угол как арккосинус . получаем два угла. далее
отрасываем один ориентируясь на знак синуса. я так понимаю.

кстати напоминаю что тригонометрическая форма она вводится на основе полярных
координат. а в них точка z=0+i*0 исключена ибо в этой точке неопределен угол.
тоесть это когда r=0. замечаю что исключается только случай когда оба и x и y одновмременно равны нулю. по отдельности они могут спокойно быть равны нулю.

исходя из вышесказанного тригонометрическая форма числа z будет иметь вид:
z=sqrt(x^2+y^2)*(cos (phi)+ i*sin (phi))

где phi равен любому из углов:
phi=phi0+2*pi*k, k=0,1,2...

к сожалению phi0 как я понял какйото красивой формулой невыразить.
поэтому задача для конкретных x,y имеет конкретный решенный вид а вот в общем
виде она неимеет красивого решения. я так понял.

ну точнее они обычно пишут так: phi=argz(x+iy)
тогда конечный вид тринонометрической формы через алгебраическую:

z=sqrt(x^2+y^2)*[ cos (argz(x+i*y)) + i*sin (argz(x+i*y)) ]

ну и таким же макаром показательная форма через алгебраическую:

z=sqrt(x^2+y^2) * e^(i*argz(x+i*y))

Единсвтенное что остается непонятным:
та система что наверху:

|cos phi=x/r = x/sqrt(x^2+y^2)
|sin phi=y/r = y/sqrt(x^2+y^2)
| r<>0 (тоесть x и y одновременн не могут быть равный нулю)

послденнее усолвие появляется из за полярных координат в которые при r=0 неопределен
угол.

берем строчку с синусом и делим обе части на косинус. получаем:

|cos phi=x/r = x/sqrt(x^2+y^2)
|tan phi=y/r = y/x, x<>0
| r<>0 (тоесть x и y одновременн не могут быть равный нулю)

мы получили почти эквивалентную систему уравнений за исключением случая когда
x=0. потому что в нашей исходной системе x может быть равен нулю без проблем а в нашей новой нет. ну пока необращаем а на это внимание.  замечу что x<>0 и r<>0 это разные условия.

далее можно решать исходную систему урвоенения. а можно решать поученную.
можно найти угол из тангенса но мы получим лишние корни. потом мы подставоляем
полученные корни в уравнение с косинусом и выкидываем лишние.
для известного тангенса на окружности будет всегда две точки с одинаковым тангенсом.
проверка на косинусе позволит исключить лищнюю точку. ( тангенс в этом плане неункиален. синус и косинус тоже каждый из низ при заданном значении имеет две точки
на окружности. но только одна из них удолвтевтворяет обоим уравненеиям. поэтому в итоге точка находится однозначно.)

вместо тангенса можно заюзать котангенс. но это проблемы нерешает. он тоже имеет
две точки на окружности при задннром значении.поэтому его корни тоже нужно проверять
на втором уравеннии системы.

пример:
z=-1+i (x=-1, y=1)

решим через синус косинус

|-1=sqrt2*cos phi, phi=3*pi/4+2*pi*k или phi=5*pi/4+2*pi*k
| 1=sqrt2*sin phi, phi=pi/4+2*pi*n или phi=3*pi/4+2*pi*n

отсюда находим общий phi удовлетвоярющий обоим уровеннеияем и это
phi=3*pi/4+2*pi*k

решаем через вторую систему:
|-1=sqrt2*cos phi, phi=3*pi/4+2*pi*k или phi=5*pi/4+2*pi*k
|-1=tan phi, phi=3*pi/4+pi*n

находим общий корень
phi=3*pi/4+2*pi*k


конец темы: "выразить тригонметрическую форму
через алгебраическую форму."













далее
очень крутая тема.
формула эйлера.
дело в том что ее строгое доказательство хрен найдешь.
но нашлось. ура.
во первых что такое e^z. да дейтсивтельно что это за хрень. ведь по сути
это запись  вида 2.7^z . так вот совершенно непонятно какой смысл имеет 
тот случай когда степень у нас комплексное число. действиетельно какой смысл вот 
этой записи 2.7^(2,1) - что это за хрень? так вот нашел то что вводят по определению что 
            z^n
e^z=summa ------- при n=0..infinity
             n!

 если то что слева от равно хрен знает что значит
 то то что справа имеет абсолютно четкое значение.
 что такое n! - абсолютно понятно.
 что такое z^n тоже понятно при n=натуральные числа. тоесть

 z^1=z
 Z^2=z*z  # мы умеем это вычислять
 z^3=z*z*z # никаких проблем при вычислении

кстати вопрос что такое z^0.... наверно по определению это 1=(1,0)?

 возьмем для примера z=(1,0) и распишем что такое 

 e^(1,0)=[ 1 + (1,0) + (1,0)*(1,0)/2 + (1,0)*(1,0)*(1,0)/6 + ... ]

 теперь заметим что (1,0)*(1,0)*.... (1,0)= всегда (1,0) тогда

 e^(1,0)=[ (1,0) + (1,0) + (1,0)/2 + (1,0)/6 +.... (1,0)/n!] =
 = (1,0)* summa [2+1/n!] при n=1...infinity = (summa [2+1/n!],0) при n=1...infinity
 или
 e^(1,0)= (summa [2+1/n!],0) +i*0, при n=1...infinity

насколько я понимаю этот ряд 
summa [2+1/n!], при n=1...infinit  он равен = e^1
итого

e^(1,0)=(e^1,0)

 мы рассмотрели случай когда z=(1,0)

далее рассматривается случай когда z=0+i*a=(0,a), где a=[0:2pi]
тогда

              z^n
e^(0,a)=summa ------- при n=0..infinity
               n!


z^n     (0,a)^n
---- = -------- = [(n!)^-1,0]*[ (0,a)^n ]
n!        n!


рассмотрим по кускам.
(0,a)^n=?

n=0| (0,a)^0=(0+i*1)^0=i*1^0=i=(0,1)
n=1| (0,a)^1=(0,a)

форула умножения : z1*z2=(x1*x2-y1*y2, x1*y2+x2*y1)

n=2| (0,a)^2=(0,a)*(0,a)=(0-a*a, 0)= (-a^2, 0)
n=2| (0,a)^2=(-a^2, 0)

n=3| (0,a)^3=(0,a)*(0,a)*(0,a)= (-a^2, 0)*(0,a)= (0, -a^2*a+0) = (0,-a^3)
n=3| (0,a)^3=(0,-a^3)
интересно....
продолжаем дальше смотреть
n=4| (0,a)^4=(0,-a^3)*(0,a)=(0+a^3*a, 0)=(a^4,0)
n=4| (0,a)^4=(a^4,0)

n=5| (0,a)^5=(a^4,0)*(0,a)=(0, a^4*a)=(0,a^5)
n=5| (0,a)^5=(0,a^5)

выписыаваю:
n=0| (0,1)

n=1| (0, a)
n=2| (-a^2, 0)
n=3| (0, -a^3)
n=4| (a^4, 0)
n=5| (0, a^5)

перегруппирую:
n=0| (0,1)


n=1| (0, a)
n=3| (0, -a^3)
n=5| (0, a^5)


n=2| (-a^2, 0)
n=4| (a^4, 0)

тогда для нечетных n=1,3,5, .. infinity имеем:

сразу подменяем n=1+2k, где k=0,1,2...)

           (0,a)       (0,-a^3)    (0,a^5)        ( 0, (-1)^(k)*a^(1+2k) )
summa(n)= -------  +  ---------- + -----   +     ----------------------- + ... 
             1!          3!          5!               (1+2k)!                


 факториал можно внести внутрь, потому что
(p,0)*(0,y)=(0-0, p*y)=(0,py)
(p,0)*(y,0)=(py-0, 0)=(py,0)
также можно заюзать запись через i
тогда собирая все в кучу:

           a^(2k+1)
s(1+2k)=  i* ---------- * (-1)^k     , k=0,1,2...inf
            (2k+1)!

так вот внимательно посмотрев на сумму мы вдруг неожиданно
понимаем что это ничто иное как ряд Маклорена для функции sin a.(ряд маклорена это чатный случай ряда тейлора если что).
таким образом сумма всех членов при нечетных n=1+2k , где k=0,1,3 равна
summa (s(1+2k))= i*sin(a)

если еще помудить с четными членами то поймем что сумма всех четных членов
сходится к  
summa(s(2k)) = cos(a)

ну а полная сумма всех членов равна

cos(a)+i*sin(a)

тогда получаем формулу Эйлера:

в алгебраическом виде:
e^(ia)=cos(a)+i*sin(a)

в более коректном виде
e^(ia)=(cos a, sin a)

тут важно сказать что a это вооще говоря любое число потому что z=0+i*a
но если a любое число то тогда под косинусом и синусом надо его преобразовыать
в радианы. а если мы нехотим мудежом заниматься то тогда надо сразу a преобразоывать
в радианы чтобы внутри косинуса и синуса непришлось этого делать. но еще раз 
это необзятльено. это лишь удобняшка. если мы берем любое a то просто надо понимать
что внутри синуса и косинуса нам надо будет это произволтное a преобразовать
в радианы иначе синус и косинус будуь неправльно высчитаны.

тут важно понять очень важную вещь что слева и справа стоят совершенно разные
функции. это очень важно понять потому то возникает чуство как бутто то что справа
оно как бы является определением того что слева. а это еще раз абсолютно две разные
функции просто так получилось что они оказалось дают один и тот же результат.
слева это степенной ряд а справа ну чтото другое.

и теперь вот еще проанализируем, берем формулу эйлера
e^(ia)=(cos a, sin a)

что интересно в этой формуле. я бы ее переписал в другом виде:
z2=f(z1)=(cos a, sin a)

вспоминаем тригонометрический вид компл числа:
z(r,b)=r*[ cos(b) + i*sin(b) ]

сравниваем правую часть формулы эейлера и тригонометрический вид компл числа
(cos a, sin a)
[r*cos(b), r*sin(b) ]

откуда я делаю вывод что на компл плоскости все числа принадлежащие (cos a, sin a)
это окружность единичного радиуса! Тоесть функция f(z) которая равна e^(ia) все что она делает она берет аргумент ia и отображает его в точку на единичной окружности единичного радиуса. еще раз то что функция f(ia)=e^(ia) отображает аргумент в 
окружность единичного радиуса это прикол. еще раз графически это выглядит так.
мы берем точку на оси Y(мнимая ось) и начинаем по ней таскать точку (это аргумент он сугубо мнимый потому что z=0+i*y) и как результат происходит отображение на 
некоторую компл плоскость в окружность единичного радиуса! наша функция e^ia отображает аргумент в окружность единичного радиуса. и это прикол.
жестокий прикол еще и втом что навскидку когда виддишь формулу эйлера то интутивно
думаешь(совершенно ошибочно) что якобы (cos a+i*sin a) это якобы определение что
такое e^ia. а это неверно. e^ia это степенной ряд. а то что он равен  (cos a+i*sin a) это просто совпадение! и больше ничего. (cos a+i*sin a) не является определением
e^ia.

что еще итересно:
вот смоирим на форулу эейлера:
e^(ia)=(cos a, sin a)

совершенно понятно что (cos a, sin a) это запись компелксного числа  в тригонометрическом виде когда r=1. тоесть  (cos a, sin a)=q(1,a)
тоесть
e^(ia)=q(1,a)
почему я и говорю что e^*(ia) отображает аргумент в компл число которое лежит
на окружности одиночного радиуса!

ну и вот как то хочется связать аргумент и результат ну как то еще более тесно.
если a очень мало. то тогда можно использовать разложение cos a и sin a в нуле.
тогда

cos a ~ 1-(a^2)/2
sin a ~ a-(a^3)/6
тогда

при малых a->0 :
               (a^2)       a-(a^3)
e^(ia) ~  1 - ------- + i*----------
                 2            6


вобщем это интересно что степенной ряд который зовется функция эйлера отображает
аргумент в окружность единичного радиуса.

наскольк я понимаю если рисовать график этого дела то выглядит это дело так:
если у нас есть на бумаге горизонтальная ось X на которой мы будем откладывать наш аргумент ia , и у нас есть вертикльная ось Y и есть ось Z которая нас протыкает
из листа бумаги то графиком e^(ia) будет спираль! мы двигаемся по оси X а при этом 
в плоскости YZ у нас окружность. все это в сумме дает спираль. спираль распостроняется вдоль оси X а в плоскости YZ мы видим окружность!
удвиитено!




 также заметим что что такое e^z по своему смыслу - это функция комплексного переменного . тоесть когда у нас есть закон который берет комплексное число как аргумент и ставим ему в соотвествие другое компексное число.
 тоесть к примеру

 e^(1,0) = (условно говоря) (6,7)

 тоесть комплк числу (1,0) поставлено всоотвствие другое комплксное число (6,7)
 если это пробовать представить через декартовы координаты то получается что 
 точке на плоскости ставится в соотвествие точка на другой плоскости 
 тоесть типа такого 

 (a,b)=f(c,d)

 ну что тут сказать. обычно график трехмерной фигуры это функция вида

 (z)=f(x,y)

 ну а здесь (a,b)=f(c,d) чуть сложнее. ибо мы имеем четырхмерное просранство а не привычное
 трехмерное. вот и все. если b всегда = 0 то функция комлпекснго переменного
 будет выглядеть как трехмерная фигура.
а так посути что такое график или трехмерная фигура или чтото посложнее - у нас есть одна или несколько осей, каждая ось это переменная или множество. мы берем
точку на каждой из осей и тогда на последней оси по некоторму правилу тоже 
выбирается точка. вот и все.
тоесть к примеру. имеем график двумерный y=f(x) это всего навсего у нас две оси.
мы берем точку на первой оси и по некоторому закону на второй оси у нее есть пара. 
вот и все. вот и весь смысл графика двумерного.

таким макаром e^z это всего навсего вот такая хрень

z1=f(z), где f(z)=e^z
вот и все. 
а e^z поскольку это некая непонятная хрень всего навсего это ряд. а что такое 
ряд вот такого вида

            z^n
e^z=summa ------- при n=0..infinity
             n!

 члены этого ряда имеет прекрасно понятное значение даже в случае когда переменная
 комплексная.


как уже вывел выше в частном случае когда z=0+i*a
данный ряд сходится к 

e^(i*a)=cos a+i*sin a 

или
e^(i*a)=(cos a, sin a)

Что примечательно что формула эйлера верно только и только водном супечастном
случае когда x=0. а не просто вобщем случае z=x+iy.

опять же очень важно пнимать что там где написано e^z там надо мысленно рисовать
степенной ряд вместо вот этой хрени  с буквой e.

Далее они в книжках пишут что :
так как

e^(ia)=cos a+i*sin a
то
e^(i*(-a))=cos a-i*sin a

складываем их:
e^(ia) + e^(i*(-a)) = cos a + i*sin a + cos a-i*sin a = 2*cos(a)
откуда получаем:
cos a = [ e^ia + e^(-ia) ] * 0.5

отнимаем их:
e^(ia) - e^(i*(-a)) = cos a + i*sin a - cos a + i*sin a = 2*i*sin(a)
получаем:
         [ e^ia - e^(-ia) ]
sin a = --------------------
                 2i


итого получили:
cos a = [ e^ia + e^(-ia) ] * 0.5


         [ e^ia - e^(-ia) ]
sin a = --------------------
                 2i


если честно я енпонимаю почему из за этих формул так ссут кипятком.
невижу никакого практического смысла потом что функции эейлера это ряды. 
так что какой от этого практический толк непонятно.


Далее берем тригонометричкую форму и смооим что будет при
умножении:
z1*z2=[(r1*cos a,0) + i*(r1*sin a,0)] * [(r2*cos b,0) + i*(r2*sin b,0)]=
=r1*r2*cos(a)*cos(b) + i*r1*r2*cos(a)*sin(b) + i*r1*r2*sin(a)*cos(b) - r1*r2*sin(a)*sin(b)=
=r1*r2*[cos(a)*cos(b)-sin(a)*sin(b)] + i*r1*r2*[cos(a)*sin(b) + sin(a)*cos(b)]=
=r1*r2*cos(a+b)+i*r1*r2*sin(a+b)=r1*r2*[cos(a+b)+i*sin(a+b)]

итого:
z1(r1,a)*z2(r2,b)=r1*r2*[cos(a+b)+i*sin(a+b)]

значит:
z(r,a)^2=r^2*[cos(2a)+i*sin(2a)]

если мы хотим вычислить z^3 то
это равно z^2*z тоесть

z^3=z^2*z=r^2*[cos(2a)+i*sin(2a)]*r*[cos(a)+i*sin(a)]
если мы заменим b=2a и r^2=r2 то мы получим
r2*[cos(b)+i*sin(b)]*r*[cos(a)+i*sin(a)]
и отсюда видно что что получаем формуулу аналогичную той что выше 
значит:
r2*[cos(b)+i*sin(b)]*r*[cos(a)+i*sin(a)] = r*r2*[cos(a+b)+i*sin(a+b)] =
= r^3*[cos(3a)+i*sin(3a)]

отсюда уже можно получить важную формулу, что 
для натуральных n иммеем:
z(r,a)^n=r^n*[cos(na)+i*sin(na)]

очень важно что эта формула получена абсолютно шататными способами
бещ применения формулы эйлера. эйлер тут вообще никаким боком ненужен!

и из форомулы при r=1 получаем частный случай под названием формула муавра:
z(1,a)^n = cos(na) + i*sin(na)

еще раз подчеркну что формулу муавара можно получить из общих соображений
без участия фооромулы эйлера

Далее еще прикол. 
новая форма записи компл числа. показательна форма.
берем тригонометричекую форму

z=r*cos(a)+i*r*sin(a)=r(cos(a)+i*sin(a))
далее вспоминаем формулу эйелера:
e^ia=cos(a)+i*sin(a)
подставляем ее выше получаем:
z=r(e^ia)=r*e^(ia)
z=r*e^(ia)
эта форма называется показательная форма.

кстати я еще допер чем примечательна экспонента эйлера.

e^ia=cos(a)+i*sin(a)

в качестве аргумента берется отрезок кратный длинне вектора i тоесть кратный
единице и в ходе отображения он отображается в такой вектор на плоскости который
повернут относительно начала координат ровно на такойже угол в радианах.тоесть прикольно что длинна отрезка как бы транфсормируется в величину угла. это и прикольно. тоесть пример.
берем z=0+i*5, значит сточки зрения числа z он имеет длинну 5 единиц.
и этот вектор отображается в вектор единичной длинны в новой комплексной плоскости
и повернут он в этой плоскости относительно начала координат на угол в 5 радиан.
это ли не чудо. длинна отрезка изначального вектора z=0+i*a отображается в угол поворота единичного вектора в новой комплексной плоскости. если мы возьмем
z=0+i*pi/2 по длинне то этот отрезок длинной pi\2 (примерно 1.7) будет отображен
в вектор единичной длинны и повернутый на угол pi\2 то есть на 90 градусов.
прикольно. еще как это можно представить. у нас есть горизонтальный ползунок
и мы по нему двигаем точку и у нас есть экран на котором нарисована единичная окружность и по мере движения поозунка у нас на экране по окружности двигается точка. угол поворота точки по окружности прямо пропорционален величине насколько 
мы перевдинули ползунок. удивительно.

показательная форма она полезна для: Показательная форма удобна для таких операций, как умножение, деление, возведение в степень и извлечение корня

Тут я нашел лекцию в которой обььясняется откуда взялся вот этот ряд который
по определению выражает экспоненту коплексную. оказывается подумали так что
вещественная экспонента обладает двумя свойствами которые нам важны первое
это f(0)=1 и второй что f'(x)=f(x). далее сказали давайте те как возьмем ряд

f(z)=summa(a(n)*z^n)  n=0,1,2,

, далее они пишут что там где ряд сходится можно взять 
произвудную

 f'(z)=summa( n*a(n)*z^(n-1) ).   n=1,2,3 (почему не от нуля непонял)

далее неочень понятно но они выводят из этого то что a(0)=1
и то что a(n-1)=n*a(n)
откуда они выводят что 
e^z=summa ( z^n/n!)

кстати там юзалось что 0^0=1 . я посмотреть в вики и типа ... вопрос  открыт
чему это равно но в случае степеных рядов вроде да принимают что такк.

далее:
задача: вывести формулу для e^(x+iy)=?
вобе=щем есть два доказателтства. одно через производные от e^z но я такое 
не рассматривают иоб тогда надо для начала смотреть что такое производная
для колпексной фнукции. есть другое пболее колхозное докааазательство
берут и перемножают две скобки

e^z1 * e^z2=(summa (z1^n\n!)) * summa (z2^k\k!) =

это две большие скобки .. мы их пермножаем друг на друга а потом группируем 
то что получилось и якобы становится видно что можно так сгрупировать что 
мы получаем

= 1 + (z1+z2) + (z1+z2)^2/2! + (z1+z2)^3/3! + ... =
итаким макаром мы видим что это вылиывается в формулу

= summa ( (z1+z2)^n/n!) а это уже очевидно e^(z1+z2)

таким макаром выводим формулу

e^(z1+z2) = e^z1 * e^z2

ну отсюда получаем

e^(x+iy) = e^x * e*iy = e^x(cos y + i*sin y)
если мы сравним то что справа с тригонометрической формой клмп числа
z=r(cos y + i*sin y)
то мы увидим что то число которое справа имеет длинну r=e^x а уголо поворота y.
значит мы получили что если у нас исходное число z=x+iy то оно отображается 
функцией e^z в вектор у которого длинна равна x а угол поворота равен y
из чего я делаю вывод что увеличение x в аргументе приводит к тому что полученная точка имеет все большую длиннну а увеличение y в аргументе приводит к повороту вектора(вектор , точка  смысл один). 

далее. 
ранее мы получили что

cos x = (e^ix + e^-ix)*0.5

где x это вещественное число. аналогичное для sin x.
так вот незнаю почему нестал разбираться но таким точно макаром вводят и 
комплексные функции cos z и sin z

cos z = (e^iz + e^-iz)*0.5 и это равно  = cos x * ch y - i* sin x * sh y

где sh y = sinh y (гиперболический синус)
ch y = cosh y (гиперболический косинус)

чему они равны:
sh y = (e^y - e^-y) * 0.5
ch y = (e^y + e^-y) * 0.5

ксати они получают что
1\i=-i


далее.
еще раз о показательной форме числа:
берем тригонмтеричкескую форму
z=r(cos a + i*sin a)

из формулы эйлера имеем что e^ia=cos a + i*sina
подствляем
z(r,a)=r*e^ia

эта форма дает удобную штуку как умножать и как делить z1 на z2

z1*z2=r1*e^ia * r2*e^ib = (r1*r2)*e^(i[a+b])

z1/z2=(r1/r2)*e^(i[a-b])

задача:
повернули систему координат на угол a , вопрос какая связь между старыми 
и новыми координатами.

вот у нас есть вектор в старых координатах его вид имеет вид
z1=r*e^ib

когда мы повернули координаты то в новых координатах угол вектора уменьшился 
на угол a значит в новых кооддинатах его вид имеет вид

z2=r*e^i(b-a)

это то как изменились координаты в полярных координатах.
а мы хотим как изменились в декартовых, тогда

 в старых коодиинатах
|x1=r*cos b
|y1=r*sin b


в новых коодинатах
|x2=r*cos(b-a)
|y2=r*sin(b-a)


из первого выражаем 
|cos b=x1\r
|sin b=y1\r

во втором исползуем формулы
cos (a - b) = cos a cos b + sin a sin b
sin (a - b) = sin a cos b - cos a sin b
подствляем во второе

|x2=r*cos(b-a) = r*(cos a cos b + sin a sin b)
|y2=r*sin(b-a) = r*(sin a cos b - cos a sin b)

теперь сюда еще вот это подставляем
|cos b=x1\r
|sin b=y1\r


|x2=r*cos(b-a) = r*(cos a * x1\r + sin a * y1\r) = x1*cos a + y1*sin a
|y2=r*sin(b-a) = r*(sin a * x1\r - cos a * y1\r) = x1*sin a - y1*cos a

итого
|x2=x1*cos a + y1*sin a
|y2=x1*sin a - y1*cos a


итак тема тфкп закончена.
переходим к статье по сигналам: https://www.dsprelated.com/showarticle/192.php

рассматриваем квадратурные сигналы , еще их зовут complex signals.

по факту квадратурными сигналами называют сигналы: 
e^ia
e^-ia

где a=a(t)


если a=(2*pi*f0)*t
e^ia=cos a + i*sin a
и конечно же одчеивдно что
Re (e^ia)=cos a
Im (e^ia)=sin a

если строить график в плоскости где одна ось это "a" а вторая ось это Re (e^ia)
то это будет график косинуса cos a
если сроить график по где гор ось это "a" а верт ось это Im(e^ia) то это будет 
график синуса sin a

тоесть если строить график a от Re (e^ia) то есть будет чисто график cos(x)
тоесть по оси x  у нас чисто x а по оси y будет cos(x)

то же самое для Im(e^ia)

а если мы вводим что "a" это непросто a  а функция времени 
тоесть a=a(t)=(2*pi*f0)*t и еслимы будем по оси x откладывать "t"
тогда у нас будет график не просто cos x а будет уже косинус вида cos kx. тоесть
будем график t, cos[(2*pi*f0)*t]


так..  а если мы рассмотрим функцию z= e^ia + e^(-ia)
тогда будет вот что

e^ia + e^(-ia) = cos a + i*sin a + cos (-a) + i*sin (-a) =
= 2*cos(a) + i*sin a - i*sin (-a) = 2*cos a

итого
e^ia + e^(-ia) = 2*cos a = 2*cos a + i*0 = (2*cos a)e^(i*0)
e^ia + e^(-ia) = 2*cos a + i*0

получается что функция z= e^ia + e^(-ia) она берет аргумент 0+i*a(отрезок на мнимой оси)
 и отображает его в новую комплексную плоскость в отрезок на вещественной оси.
тоесть если функция e^ia она отображает отрезок в точку лежащую на одинарной
окружности то наша новая функция она отображает тот же аргумент но в другое - в точку лежащую на отрезке  который лежит на вешественной оси исключетельно на вещественной оси.
если рисовать график когда будем по гор оси откладывать "a" а на верт оси откладывать e^ia + e^(-ia) то это будет график 2*cos(a). еще раз обращу внимание почему мы можем откладывать функцию e^ia + e^(-ia) всего лишь на одной оси (ведь результат этой функции это комплексное число у которого всегда две координаты тоесть комлпесаня функция это всегда плоскость комплпксаная плоськость то есть там две оси но никак не одна. так вот в нашем конкретном случае мы выяснили что результатом данной функции всегда будет число вида x+i*0 поэтмоу в этом конкретном случае нам хватит одной оси.). итак график e^ia + e^(-ia) от "a" это график 2*cos x от x.
а если у нас a=f(t) и мы хотми по гор оси откладывать время t а не a то это будет график по гор оси будет "t"  а на верт оси будет откладывать 2*cos(a[t])

далее. 
так вот в статье написано что 
если мы еще раз посмотрим на функцию

e^ia + e^(-ia) = 2*cos a + i*0

то мы конечно заметим то что результат это сугубо вещественное число. с нулевой 
комплексной частью. и вот статья говорит что : Implementations of modern-day digital communications systems are based on this property!
пока непонятно что такого крутого в этом. но будет дальше смотреть.

далее еще вспомним другую формулу. 
         [ e^ia - e^(-ia) ]
sin a = -------------------- 
                 2i

тогда:
e^ia - e^(-ia) = i* (2*sin a) 
                 

тоесть компл число 0+ia наша функция маппит в мнимую ось и на ней мы откладываем
отрезок длинной 2*sin a

итак еще раз соберем две наши функции рядышком:

e^ia + e^(-ia) = 2*cos a + i*0
e^ia - e^(-ia) = i* (2*sin a) + 0

итак видно что сумма наших экспонент мапиится в точку исключительно на вещественной оси ( длинаа отрезка 2*cos a )
а разница экспонент маппится в точку исключительно на вещественной оси ( длинна отрезка 2*sin a ).

дальше они пишут мол во классно теперь знаем как наш  косинус от обычного действииельного числа раскладывается в комплексный вид в функцию на комплексной
плокости и даже более того в комплексные экспоненты. (че класного пока непонятно).
тоесть мы сразу теперь знаем что:
cos a = [ e^ia + e^(-ia) ]*0.5
бам! и наш косинус перелез комплексную плоскость

далее.
замечу про связь w и f0:
cos a = тут все понятно. аргумент "a" в радианах.
далее заменяем a=f(t)=w*t
cos wt = посольку аргумент коинуса  в радианах то если a=f(t)= wt
в этой формуле w- это частота в радианах в секунду.а если мы хотим перейти к
к классичсесекой частоте Гц=1\с то  
w=2*pi*f0, в самом деле. по определению периодической функции y(t+T)=y(t).
берем t=0 и T=1\f0 тогда

cos (0+T) = cos (2*pi*f0*(0+1/f0))=cos (2*pi*f0*(1/f0) = cos (2*pi)=1
cos (0)= cos (2*pi*f0*0)=cos (0) =1
1=1 
значит все верно значит доказали что 
w=2*pi*f0 в радианах в сек
f0 в 1\с=Гц

так я о чем. о том что аргумент косинуса можно задвать двумя путями 
через круговую частоту или через герцовую частоту:
cos (wt)
cos (2*pi*f0*t)
конечно w тоже может быть функцией от t. но мы такое нерассматриваем. 
считаем что w постоянная от времени.

далее. 
заметим одну очень инересную вещь.
вот у нас есть сигнал от времени 
y=cos(kt)
мы строим граифк. по гор оси кладем t по верт оси кладем cos(kt).
если у нас разные k то график t,y(t) будем разный. он будет то сжиматься 
то разжиматься вдоль горизонтальной оси. 
действительно, графики от t для функций

y=cos(k1*t)
y=cos(k2*t)
y=cos(k3*t)

они будут все разные. это первый момент.
второй момент  что это графики сигнала (функции) от времени.
поскольку k1,k2,k3 задают частоту сигнала то получается что косинус при 
разных часототах на графике от времени t все время будет разный. однако! и тут
самое главное если мы для первого графика y=cos(k1*t) начнем по оси X откладывать
не время а величину k1*t то мы получим график классического cos x графика.
тоже самое и для y=cos(k2*t) и y=cos(k3*t) если мы будем откладывать на гор оси 
не время а величины k2*t и k3*t то все три графика будут ОДИНАКОВЫЕ! абослютно
одинаковые три графика. по горизонтальной оси мы будем откладыывать так называемую 
фазу а не время как мы делали до этого. фаза это полный аргумент стоящий под косинусом. тоесть y(a)=cos (a), где a это полный аргумент косинуса. этот полный
аргумент зовется фаза, такое вот заумное слово, на самом деле означает всего навсего полный аргумент косинуса и всегото. для примера y(t)=cos(k*t)
в этом случае аргумент "t" но как видно этот аргумент состалвяет лишь часть полного
аргумента косинуса поэтому t  это не фаза. фаза косинуса в данном случае это k*t.
таким образом когда мы слышим слово фаза косинуса равна 0.5 это означает что 
мы знаем полный аргумент косинуса то есть мы можем его сразу подставить 
и узнать чему же косинус равен при этой фазе тоесть cos(0.5). таким образом
дебильое слово фаза наконец стало понятно что это такое - это полный аргумент 
косинуса. если мы знаем фазу то мы мгновенно можем посчитать чему равен косинус
y=cos(фаза). какая связь между фазой и временем. в общем ответ такой что связь 
какая угодно. ее может небыть вообще. в общем случае связь такая 

фаза=фаза(t)  

главное что надо понять что фаза это полный аргумент под косинусом. тоесть
cos(фаза). если нам сказали что фаза=0.6 то это значит что мы знаем все что необходимо чтобы теперь выяснить чему равен косинус  а именно косинус=cos(0.6)

если мы всоппомним что такое косинус по определению  - что это величина катета для точки на окружности единичного радиуса. как мы там пытаемся вычислить этот катет.
мы говорим что 

катет=1*f(x)

где 1 это длинна гипотенузы.
f(x) это некая функция от угла треугольника. таким образом x это угол треугольника
заданный в радианах. так вот эту функцию называют косинус или f(x)=cos(x)
таким образом x это угол! и также как мы уже знаем это фаза. таким образом 
физ смысл фазы это угол , заданный в радианах. понятие фазы имеет смысл только 
когда мы говорим про косинусы(синусы тангенсы итп). полный аргумент какой либо 
другой функции y=f(x)=x^3 абсолютно незовется никакой фазой.

итак мы поняли что фаза это просто синоним для слова "полный аргумент для функции косинус". его физический смысл это угол в радианах. если мы знаем фазу (например фаза =0.1) то мы знаем полный аргумент и значит можем вычислить значение функции
при фазе=0.1 косинус=cos(0.1)
так как фаза это угол то как видно в нем нет никакого времени. откуда же оно берется. если у нас точка ездит по окружности в соовествиии с каким то законом
от времени тоесть x=x(t) то тогда зная время t0 и зная закон x(t) мы можем
вычислить чему равен угол прям щас а именно x(t0). вот так появляется время.
а когда вычислили угол x(t0) то мы вычисили фазу то мы вычислили полный аргумент 
косинуса то мы можем узгнать чему косинус равен cos(x[t0])
закон движения точки по окружноси от времени может быть самый любой нпример
x(t)=e^(35t). тогда угол в момент времени t=10 будет равен x=e^(35*10).
тогда косинус будет равен cos(e^(35*10))
фаза=e^(35*10)

Если мы строим график косинуса не от времени а от угла (то есть от фазы) то есть мы 
откладываем по оси X не время а фазу то никакого времени на графике нет и график 
будет выглядеть всегда ровно одинаково как cos(x). неважно как меняется угол от времени , как бы он неменялся на все равно что угол=0.3 в момент времени t0=10 или в момент времени t0=20. когда по оси x откладываем угол(фазу) cos(угол) всегда всегда всегда один и тот же. и плевать нам на время. 

итак что такое фаза. это угол. еще это полный аргумент для функции косинус.
чем она хороша. для заданной фазы косинус всегда один и тотже! если мы строим
график косинуса от фазы то этот график всегда один и тотже и на нем нет времени. никак. фаза еще хороша там что зная фазу мы сразу вычисляем чему равен косинус 
для этой фазы.

к сожалению в придурковатой школе косинус начинают обьяснять с направления жопы.
тоесть с обратной стороны. берут некий физ процесс типа качающийся маятник. 
далее снимают координату которая меняется от времени. тоесть момент в том что
наш сигнал он изначально завиисит от времени но никак не от фазы. например

x=cos(10*t)

далее рисуют график x(t) , у ученика возникает четкая привязка косинуса к времени.
тоесть человек думает что косинус происходит от времени. и дальше эти придурки 
пытаются впихнуть перевести разговор на фазу. и тут возникает чудовищное непониние
что это за хуета под названием фаза и нахуя она нужна ? если бы эти дебилы 
сказали давайте мы будем немаятник ебаный снимать а точку которая движется по окружности у которой угол поворота меняется по закону phi=10*t
далее мол меряем чему равен косинус при движении этой точки. получаем

x=cos(10*t)

а далее бы эти дебилы бы сказали что давайте нахер теперт забудем провремя. а поступим вот как. мы берем время t0=0, смотрим чему равен угол и чему равен косинус. и далее начинаем строить хитрй график. на гор оси откладываем угол 
на верт косинус. для t0=0  угол=10*t=0 а косинус = cos (0)=1
итак на оси x откладыаем 0 а на оси y откладываем 1 и ставим точку на графике.
теперь берем t0=1, тогда угол=10*1=10, тогда косинус=cos(10)=0.4
ставим на оси x угол 10 и на оси y ставим 0.4 и рисусем еще одну точку. и соединяем сосдение точки.  и вот аллилуйя мы получли гоафик косинуса  в завимости от угла.
и это блядь и называется график косинуса от угла то есть от фазы. и вот что такое 
фаза и какой ее смысл и какая связь с косинусом! но нет эти дебилы так неделают.
фаза это натуральный по приоде родной аргумент для косинуса. но эти дебилы строят
косинус от времени. а потом пытаются принятнуть за уши какую то фазу. 

теперь когда разобрались с фазой переходим к сопряженной следующей теме.
поговоим про ряд фурье.
если есть периодическая функция f(x)=f(x+T) ( и еще там ряд условий на эту функцию налагается)
то она может быть представлена через бесконечную сумму (ряд) синусов и косинусов.
тоесть

f(x)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ]
где n=1 до inf
a(0)..a(n), b(n) это коэфициенты

где 
a(0)=(1/pi)*integral( f(x)dx ) на отрезке [-pi,pi]
a(n)=(1/pi)*integral( f(x)*cos(nx)dx ) на отрезке [-pi,pi]
b(n)=(1/pi)*integral( f(x)*sin(nx)dx ) на отрезке [-pi,pi]



замечу что x - это любая переменная необязатлеьно время. вообще любая переменная

также замечу что для синусов\косинусов в скобках 

фаза=n*x, где n=1,2,3..

тоесть мы раскалдываем функцию по синусам косинусам вида
cos x, sin x
cos 2x, sin 2x
cos 3x, sin 3x
итд


если x у нас это время. тоесть t. тогда
фаза=w*t=2*pi*f*t
с другой стороны мы имеем что 
фаза=n*t
тогда
2*pi*f*t=n*t
тгда
f=n\(2*pi) Гц
если 2*pi~6 тогда мы раскладываем функцию по частотам
f=n\6
тоесть
1\6 Гц, 2\6 Гц, 3\6 Гц, ... 100\6 ГЦ .... 100000\6 Гц

в данном случае видно что 
фаза=w*t ( по поердеению)
и что фаза=n*t (согласно формуле)
получается что w=n
так вот в другом места  я встретил инфо о том что  якобы можно использовать 
непросто w=n а w=w0*n

тоесть класическй фурье раскладывает функцию по 
sinx, cosx, sin2x, cos2x, sin3x,cos3x
а в одном месте я встретли что можно расклдывать по
sin kx, cos kx, sin 2kx, cos2ks, sin 3kx, cos 4kx
незнаю верно ли это.

далее пишут что 
чем больше членов ряда мы возьмем и обсчитаем тем более точное прибижение
мы получим.

замечу мы пока что рассматриваем функцию периодическую относительно x. 
если x это время то сигнал периодический по времени. 
так вот что существенно - то что нам нужно высчитаь коэффициенты a(n) и b(n)
только один раз. они верны для всех x. тоесть нам для каждого x ненужно 
выситывать коэфициенты a(n) и b(n) снова.

приведу разложение в ряд фурье некоео сигнала от балды:

f(x)=0.5 + summa [ cos(n*x) - sin(n*x) ]
или
f(t)=0.5 + summa [ cos(nt) - sin(nt) ]

где n=1.. inf

значит что мы имеем на данный момент. мы имеем то что сигнал имеет
бесконечное количество гармоник. 

получается интересно ( в целом если заметить ) что с точки зрения функции f(x)
все что внутри справа это все числа а переменная только x, а с точки зрения суммы
x это некая константа а переменные это все что с n. 
также получается что каждая точка на графике f(x0) в точке x0 это на самом деле
результат огромной бесконечной по количеству суммы членов. тоесть
например постоили мы график по оси X  у нас x по оси Y у нас f(x)
берем x0=1 на графике ему соовтествует всего лишь маленькая точка (x0,f(x0))
а на самом деле за этой маленькой точкой скрывается огромный рой членов ряда. тоесть

f(1)=0.5+ [ cos 1 - sin 1 + cos 2 -sin 2 + cos 3 - sin 3 ...]

это реальный прикол. что всего каждя маленькая точка функции ее значение 
это по факту сумма огромного ряда членов суммы. это напоминает вот что. лежит на прилавке куча телефонов. но каждый телефон это непросто маленкая коробочка это труд
огромного числа людей на огромном заводе. но на прилавке для человека это ничего 
невидно, для него это всего лишь маленькая коробочка. еще пример.
лежит в магазине хлеб в куче других хлебов на полке. и человеку невидно что этот 
хлеб это результат огромного труда людей и процессов с момента как зерно упало в землю. так и точка на графике этой функции это труд огромного числа синусов и косинусов которые стоят в сумме. функцию можно представит как магазин с его полками.
точки функции это булки хлеба. функция их продает или показывает. а ряд синусов и косинусов это невидимый труд миллиардов синусов и косинусов которые кропотливо создавали каждую точку этой функции но этого совсем невидно том кто смотрим на график этой функции. для него это прото маленькая точка на графике а график это просто маленькая черная ниточка на картинке.

окей. возвращемся обратно. существенно еще раз подчеркнуть
что для периодической функции коэфициенты a(n) и b(n) надо высчтывать только 
один раз. и они верны для всех x. для каждого x ненужно вычитывать коэфициенты
кажоый раз заново.

а рассмотрим как пример
f(x)=sin(x)

sin(x)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ]


высчитаем коэфициенты:
где 
a(0)=(1/pi)*integral( f(x)dx ) на отрезке [-pi,pi]
a(n)=(1/pi)*integral( f(x)*cos(nx)dx ) на отрезке [-pi,pi]
b(n)=(1/pi)*integral( f(x)*sin(nx)dx ) на отрезке [-pi,pi]

тогда
a(0)=(1/pi)* (-cos(pi)--cos(-pi))=(1/pi)*(1-1)=0
a(n)=(1/pi)*integral( sin(x)*cos(nx)dx ) на отрезке [-pi,pi] 
b(n)=(1/pi)*integral( sin(x)*sin(nx)dx ) на отрезке [-pi,pi]


integral( sin(x)*cos(nx)dx )= 0.5( - cos(x+nx)/(1+n) - cos(x-nx)/(1-n)) +Const
integral( sin(x)*sin(nx)dx )= 0.5( - sin(x+nx)/(1+n) + sin(x-nx)/(1-n)) +Const

0.5( - cos(x+nx)/(1+n) - cos(x-nx)/(1-n)) [от -pi до pi]=
=0.5( - cos(pi+n*pi)/(1+n) - cos(pi-n*pi)/(1-n)) - 
- 0.5( - cos(-pi-n*pi)/(1+n) - cos(-pi+npi)/(1-n)) =
= 0.5( - cos(pi(1+n))/(1+n) - cos(pi(1-n))/(1-n)) - 
- 0.5( - cos(pi(1+n))/(1+n) - cos(pi(1-n)/(1-n)) = 
= 0.5 ( - cos(pi(1+n))/(1+n) - cos(pi(1-n))/(1-n) + cos(pi(1+n))/(1+n) +
+ cos(pi(1-n)/(1-n)  ) = 0
значит a(n)=0

 sin(pi(1-n))/(1-n) - sin(pi(1+n))/(1+n)   = 
а далее прикол. поскольку n=1,2,3, то фазы под синусами это либо pi либо -pi
как ни крути. и значит что синусы равны 0. но! данная формула верна только 
для случая когда n!=1 а когда n=1 то надо (как я прочитал ) брать и считаьт 
интеграл руками конкнетно для этого n. 
итак n=1: 
integral( sin(x)*sin(x)dx )=integral( sin^2(x)dx )= 0.5* (x-0.5*sin(2x)) [от -pi до pi] = 0.5* ( pi-0.5*sin(2pi) ) - 0.5* ( -pi-0.5*sin(-2pi) ) = 
= 0.5* ( pi ) - 0.5* ( -pi ) = pi
значит 
b(n=1)=(1/pi)*(pi)=1
значит:
b(n)=0 кроме случая n=1, при n=1 b(1)=1
итого:
для sin(x)
a(0)=0
b(1)=1
b(n!=1)=0

итого разложение в ряд фурье sin(x):
sin(x)=0+summa (0*0+1*sin(x))=sin(x)
sin(x)=sin(x)
ура.

что еще существенно про коэффициенты ряда a(n) и b(n) что они абсолютно независят 
от переменной x. это очень важно отметить.

получается некая функция раскладываться в сумму синусов косинусов в виде:
f(x)=2 + 3*sin(x) + 5*cos(x) - 1*sin(2x) - 6*cos(2x) + ...
тоесть видно что коэфициенты от x независят. и получается наша функция это 
суперпозиция кучи синусоид косиснусоид. как бутто плывет стая рыб мелких разнообразных и она взяла сложилась одна в другую и вдруг вместо стаи рыб мы получили одного большого кита.  это похоже на белый свет и радугу. тоесть 
то что видимый белый свет это суперпозиция стаи цветов разного цвета.
как призма может разложить белый свет на всю стаю так и наверно какойто инструмент
может разложить звук на стаю синусоид. прям трансформер какойто. как бутто звук 
это как тело человека состоящее из армады клеток. армада образует одно целое но 
если захотеть то можно увидеть не единое тело а рой клеток. жалко что звук или свет туда сюда можно раскладыать на составные из целого и обратно в целое из составных а с телом человека так не получится.

так ну это был ряд фурье для через вещественные косинусы синусы. 
щас вывеем ряд фурье через комплкнсные экспоененты:
берем
cos a = ( e^ia+e^(-ia) )*0.5
sin a = ( e^(-ia) -e^ia )*0.5

тогда 
cos (n*a) =   ( e^ina + e^(-ina) )*0.5
sin (n*a) = j*( e^(-ina) - e^ina )*0.5

подставляем в ряд фурье:
(f(x), 0)=a(0)*0.5 + summa [ a(n)*cos(n*x) + b(n)*sin(n*x) ] = 
= a(0)*0.5 + 0.5*summa [  (a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx)  ] 

кстати что в этой формуле полезно еще раз отметмить - формула имеет вид
f(x)=A0*0.5 + 0.5 (A1*e^inx + B1*e^(-inx) + A2*e^inx + B2*e^(-inx)...)
тоесть у нас переменную 


получаем ряд фурье выраженный через комплесные экспоненты.
также слева будем использовать алгебраическую форму комлксного числа 
тоесть то что (f(x), 0) = f(x)+i*0 тогда

ряд фурье выраженный через комплекстные экспоенты:
f(x) = a(0)*0.5 + 0.5*summa [ (a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx) ]

далее я вспоминаю формулу которая позволяет перевести алгебраическую форму
числа в показтельную:
z=sqrt(x^2+y^2) * e^(i*argz(x+i*y))
тогда:
a(n)+j*b(n)= sqrt(a^2+b^2) * e^(i*argz(a+i*b))
a(n)-j*b(n)= sqrt(a^2+b^2) * e^(i*argz(a-i*b))

далее обозначим argz(a+i*b) как phi(n), тогда

a(n)+j*b(n)= sqrt(a^2+b^2) * e^(i*phi(n))
a(n)-j*b(n)= sqrt(a^2+b^2) * e^(-i*phi(n))

подставляем сюда:
(a(n)-j*b(n)) * e^(inx) + (a(n)+j*b(n)) * e^(-inx) = sqrt(a^2+b^2) * [
 e^(-i*phi(n)) * e^(inx) + e^(i*phi(n)) * e^(-inx) ] = 
 = sqrt(a^2+b^2) * [ e^(inx-i*phi(n)) +  e^(-inx+ i*phi(n)) ] = 
 = sqrt(a^2+b^2) * [ e^(i(nx-phi(n))) +  e^(-i(nx-phi(n)) ] = 
 = sqrt(a^2+b^2) * [ e^(i(nx-phi(n))) +  e^(i(-nx+phi(n)) ] 

тогда ряд фурье:
f(x) = a(0)*0.5 + 0.5*summa [ sqrt(a(n)^2+b(n)^2) * [ e^(i(nx-phi(n))) +  
+ e^(i(-nx+phi(n)) ]

где phi(n)=argz(a+i*b)

прикольно что в книжках за phi(n) берут argz(a-ib) ттгда соотвеатвенно наш
phi(n) превратиться в -phi(n) 

тогда в итоге в книжках ряд фурье расписыают вот так:

f(x) = a(0)*0.5 + summa [ 0.5 * sqrt(a(n)^2+b(n)^2) * [ e^(i(nx+phi(n))) +  
+ e^(i(-nx-phi(n)) ]

где phi(n)=argz(a-i*b)

далее они еще делают замену и получают вот такой вид:

f(x) = a(0)*0.5 + summa [ c(n) * [ e^(i(nx+phi(n))) +  
+ e^(i(-nx-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)


поговорим о том почему ряд фурье в комплексном виде всегда будет давать точки 
на комплексной плоскости исключтетльно на вещественном луче:
экспоненты как результат на компл проскости они 
дают вектора единичного радиуса и повернутые один на угол 
nx-phi(n) а второй на угол -nx+phi(n). это к чему приводит - это приводит к тому
что сумманый вектор всегда будет лежать на оси X тоесть на вещественной оси
тоесть сумма этих экспонент всегда дает вещественный результат,значит и полная
сумма этих слагаемых даст всегда сугубо вещественный результат.


далее вот что рассмотрим  формулу ейлера:
e^i*x=cos (x) + i*sin(x)

косинуса и синуса у нас классические вещественные. аргумент внутри 
косинуса и синуса это угол. причем он задается в радианах.
значит размерность аргумента вних должны быть радианы.
вообще это интереснрый момент кгда мы обычно рассматриваем формулу в математике
то у нее обычно нет ниаких размерностей хоть тугрики хоть киолграмы хоть безразмерно  а синус и косинус стоят отдельно. у них аргумент имеет размерность.
такая вот подстава. так вот x обязан иметь размерность в радианах по крайней мере
не сам x(тоесть остальная часть формулы может иметь x любой размерности) но то что стоит в скобках  в качестве аргумента у синуса и косинуса дожлно быть преобразовано в радианы.
предположим что x у нас это t время в секундах тогда внутри синуса и косинуса
надо ставить не t а t умноженное на некий коэфициент который переводит секунды в
радианы. назовет этот коэфициент w (радиан\секунду) тогда формула эйлера
кгда у нас переменная x это время t  превратится в 

e^i*(w*t)=cos (w*t) + i*sin(w*t)

далее надо выяснить а чемуже равен этот сраный коэфициент. значит что такое синус 
и косинус с точки зрения физики. это точка движется по окружности по некоторому закону изменения угла phi=phi(t) (хотя может же и сложнее например закон phi=phi(t,x,y) ну не знаю наверно рассматривается более простой случай когда phi=phi(t))
тогда 
если мы говорим что phi=w(t)*t
то w(t)=d(phi)
        -------  (производная от угла по времени)
        dt

Если phi   в радианах то w получается в радиан\с

Тогда ( в случае когда x это у нас t время в секундах) то ряд фурье 
получаем имеет вид:

f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(nt+phi(n))) +  
+ e^(i(-nt-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
где n*t=n*w1*t

w1- некая базовая круговая частота которую мы задаем сами вначале. какую захотим.
с этой w1 реальная мудота для понимания.
об этом ниже.

они почему то постулируют что w от t независит. что w=const от t.
непонятно. ведь w может быть функцией не только от t но и от x вообщето.
ну ладно...

также важно то что аргумент при экспоненте имеет вид i*nt только в случае 
если при нахождении коэфициентов a(n) и b(n) мы там юзаем иниеграл и у него
пределы интегрирования указываются так вот если в экспоненте стоит i*nt то в интеграле должно стять от -pi до pi. если пределы другие например от -pi\2 до
pi\2 то у эксопненты будет другой вид типа i*w1*n*t
где w1- некая константа.  ну суть такая что мы можем разлагать фунцию в ряд
по круговым частотам вида 

1,2,3,4,5,6 

а можем по частотам

w1*1, w1*2, w1*3, w1*4...
вобщем мудота та еще с этим рядом фурье. реально.

тоесть в ряду фурье можно задавать некую базовую круговую частоту и раскладыать 
функцию по синусам\косинусам которые кратные этой частоте.
в моем случае вверху ряд фурье указан для разложения когда w1=1(рад\с)


тогда ряд фурье в более общем случае когда у нас базис синусов косиуснов
выбирается такой что sin w1*t, cos w1*t, sin 2*w1*t, cos 2*w1*t бдует иметь вид


f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)

в заввимимости какую w1 мы берем изначально от этого будут меняться a(n) и b(n)
еще раз w1 откуда мы ее берем. мы берем ее из ниоткуда в том плане что ее вычилсять
ненадо. мы ее сами задаем какой хотим изначаьно и от этого уже ряд фурье пляшем.
выбор w1 влияет на то какими будут a(n) b(n) c(n) phi(n)
 
теперь наконец двигаем дальше - когда высчитали a(n), b(n) то автоматом высчитаем и
c(n) и высчитаем phi(n), нам на выходе нужны c(n) и phi(n). когда мы их вычситали
то строят два графика.
первый график по оси X откладывают 1*w1, 2*w1, 3*w1, 4*w1 по оси Y откладывают c(n)
таким образом мы показываем чему равна амплитуда вектора для каждого n-го члена 
внутри суммы.

второй график по оси X тклывают опять же 1*w1, 2*w1, 3*w1, 4*w1 а по оси Y откладывают phi(n) таким образом для каждого n-го члена внутри суммы мы показываем
чему равно смещение угла(фазы). 

таким макаром из этих графиков мы можем быстро составит чему равен ряд фурье.
например.

w1=1,
c(n)=2*n
phi(n)=1*n

также насколко я понимаю то a0=c0/2

тогда ряд фурье будет такой:

f(t) = 0*0.5 + summa [ (2*n) * [ e^(i(n*1*t+1*n)) +  
+ e^(i(-n*1*t-1*n)    ] =   0*0.5 + summa [ (2*n) * (   e^(nt+n) + e^(-nt-n)   ) ] =
=  summa [ (2*n) * (  e^(t+1) + e^(-t-1)  + e^(2t+2) + e^(-2t-2) + ...) ]
 

еще раз посмотрим на ряд фурье:


f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)


значит по сути здесь  по суммой складывается каждый раз два вектора. 
у каждого из них длинна c(n)
и у одного угол n*w1*t+phi(n) а у другого угол -n*w1*t-phi(n)
по мне для того чтобы построить оба этих вектора перед сложением аболютно достаточно
на графиках phi(n) и c(n) откладвать по оси X только положительные значения такие как 0, 1*w1, 2*w1, 3*w1, 4*w1 итд. этой информации аболютно достаточно
для построения этих двух векторов. При этой частота w1*1, w1*2,w1*3 имеет прямой 
и четкий и понятный физ смысл. но эти придурки как я понимаю чисто для математического выебона делают следующее. они говорят знаете - давайте частоты
1*w1, 2*w1, 3*w1, 4*w1 и вообще все такие положительные чатсоты мы будем их с графика подставлять исключительно только в первую экспоненту  e^(i(n*w1*t+phi(n)))
а во вторую экспоненту мы это подставлять небудем (хотя это полная хуйня), они 
говорят давайте для второй экспоненты мы будем откладывать -1*w1, -2*w1, -3*w1,
-4*w1 итл и соотвественно для графика c(n) будем рисовать ровно тоже самое
что мы рисовали для положительных n*w1. тоесть если было что
c(1*w1)=1 то для  c(-1*w1) откладываем тоже 1
а если было для phi(1*w1)=1 то для phi(-1*w1) откладываем -1

ну тоесть я говорб в чем суть их этой ебнутой придумки. они для 
члена 
c(n) *  e^(i(n*w1*t+phi(n)))  
подставляют значения с графиков c(w1*n) и phi(w1*n)
с правой части этого гарфика когда w1*n>0

а для члена 
c(n) * e^(i(-n*w1*t-phi(n))
они подставляют c(n) и phi(n)
 слевой части графика когда w1*n<0

по мне это полностью искусттвенная ненужная хуйня которой они занялись потому что
абсолютно для обоих векторов достаточно графиков c(n) и phi(n) при w1*n>0 то правой 
части этих графиков. и у нас нет никаких этих сраных отрицательных частот.
то что они делают это сугубо искуственная ненужная хуйня. отсоюда у них и берутся
несущесвтвующие неимеютщие никакого смысла отрциательные частоты.
таково мое мнение.

итак еще раз. зачем нужен график c(n) от (w1*n) и график phi(n) от (w1*n)
они нужны чтобы глядя на них мы могли восстаовить как выглядит рядь фурье. его члены
внутри суммы. при этом графиков при n>0 асболютно для этого достаточно.
то что они русют графики также и для n<0 это аобсолютно ненужная искуственная хуйня.
Это типа так сказать типа у них такая удобняшка что для члена 
c(n) *  e^(i(n*w1*t+phi(n))) 
брать коэфициенты с правой части графиков при n>0
а для члена
c(n) * e^(i(-n*w1*t-phi(n))
брать коэфицицента с левой части графиков при n<0
Еще раз хочу подчеркнуть что кожфициенты в левой части на самом деле получаются из 
коэфициентов из правой части так что левая часть нахер невсралась.
Для графика c(n) все что слева при n<0 ровно тоже самое что справа при n>0.
для графика phi(n) все что слева при n<0 равно тому что справа при n>0 только со знаком минус. 

Ну и собсвтенно как называются эти графики 
c(n) назыается амплитудно-спектральный график
phi(n) называется фазово-спектральный график.

также еще подчекрну что графики эти строятся не от n а от w1*n.

график c(w1*n) при n>0 покзаывает амплитуду  для вектора в сумме который вращается по часовой стрелке по времени, при n<0  амплитуду для вектора коорый
врщается против часовой стрелки.

график phi(w1*n) при n>0 покзаывает фазу  для вектора в сумме который вращается по часовой стрелке по времени, при n<0 фазу для вектора коорый
врщается против часовой стрелки.


таким макаром кое как мы вроде наконц поняли откуда берутся у этих придурков 
отрицательные частоты круговые. их нет а они просто придурки.
круговые часоты введены для вещественных функций а они на ходу начинают их прилепливать к функциям комплексным и начинается полный бардак. 
у вещвественных функций никаких отрицательных круговых частот нет.

хотя с другой стороны вот есть у нас phi=-5*t, значит
|x=cos(-5*t)
|y=sin(-5*t)
совершенно понятно что данная точка летает по окружности в сторону против часовой стрелки. так почему бы нам для вещ функций не определить эту самюу отрицательную 
круговую частоту? это ж так очевидно! а они гворят нет - для вещественных косинусов
и синусов никаких отрицательных частот не бывает. что за хуйня?

еще раз подумаю на тему времени t в аргументе у синуса косиунуса.
далее говорим про косинус(с синусом тоже самое.). что такое косинус. рисуем окружно
сть с радиусом 1. откладываем угол на окружности. причем как мы его откладыаем.
мы откладыаем угол в радианах. что такое радианы. если окружность единчиного радиуса
то ее полная длинна примерно 6 или 2*pi. так если мы говорим что мы отложили угол
phi радиан это значит что мы отложили на окружности дугу длинной phi единиц.таким 
образом угол в радианах это длинна дуги - совершенно натуральная штука ( в отличие
от всяких там стремных градусов и транспортиров.). отложили дугу заданной длинны
получили точку на дуге. от этой точки опускаем верти палку на гор ось и получаем
длинну отрезка это косинус для данного угла phi. таким образм косинус это
функция у которогой аргумент это угол в радианах. отложиди угол померяли косинус.
отложиди угол померяли косинус. вопрос - как нам теперь всунут время t внутрь
косинуса. Прежде всего еще раз - косинус это функция от угла. тоесть косинус 
у него аргумент только угол и больше ничего. Предпожим что угол это функция от времени. тоесть phi=phi(t). Теперь подставляем в косинус 

cos phi = cos phi(t)

если мы знаем t то вычилсяем phi в этот момент t. знаем phi вычисляем косинус.
например phi=e^5t+16t+16t^2
тогда

cos(phi)=cos(e^5t+16t+16t^2)

окей мы засунули t внутрь косинуса.

а если угол завиисит еще от каких то переменных типа от x,y,z 
напрмиер

phi=e^5t+2x+3y+6z

замечу только то что итоговый phi должен быть в радианах получаться при подстановке
переменныха не втугриках каких нибудь.

тогда
cos(phi)=cos(e^5t+2x+3y+6z)

ну все таки мы щас рассматривем сигналы которые обычно зависят только от времени
так что от других перпеменных они обычно независят .у нас обычно есть нарисоанный
полученный сигнал картинка график от времени. так что наверное будем считать 
что phi это функция только от времени. phi=phi(t)
далее очень важно и интересно - по определению w (угловая частота) это d(phi)\d(t)
тоесть производная угла по времени. возникает вопрос почему в ряду фурье 
аргумент у косинуса \синуса имеет вид cos (n*w1*t) и sin (n*w1*t),
где n=0,1,2,... и w1 это константа, тоесть

cos (w1*t), cos (w1*2*t), cos (w1*3*t)

ведь это же должно означать  что закон изменения угла от времени имеет линейный вид!
а именно:
phi(t)=w1*t
phi(t)=2*w1*t
phi(t)=3*w1*t

а он и имеет линейный вид!  (щас скажу почему).
и поскольку закон изменнеия угла от времени имеет линейный вид то линейная
функцция имеет всегда вид y=k*t+b, где k это производная dy\dt и у линейной функции
производная константа! поскольку y  у нас это phi то dy\dt это d(phi)\dt и это равно w! b в нашем случае равно нулю. (щас я скажу почему b равно нулю.).
Так вот ответ на вопрос - почему в ряду фурье аргументы под косинусами имеют вид
k*t,2*k*t, 3*k*t, 4*k*t .... где k это некторая константа, так вот ответ почему так состоит в том потому что мы так задали, потому что мы так захотели! Тоесть как
создавался ряд фурье. мы говорим что мы имеем сигнал f(t). сигнал зависит 
только от времени. и мы сказали - что мы хотим узнать как это сигнал можно представить в виде разложения по функциям:

cos(1*w1*t), sin(1*w1*t), cos(2*w1*t), sin(2*w1*t), .... cos(n*w1*t),
sin(n*w1*t)

где:
w1- некая констана которую мы сами задаем изначально. по нашему желанию.
например w1=10;
n-натуральное число 1,2,3,4,5,6.... infinity

таким образом вопрос почему мол под синусами\косинусами угол изменяется 
от времени по закону phi=n*w1*t ответ такой что мы так сами изначально захотели
задали выбрали заказали! это наше желаение. мы ищем ращложение сигнала f(t)
именно через такой набор так выглядящих синусов\косинусов.

теперь ответ на вопрос почему w1 это круговая частота. точнее даже так почему
n*w1 это круговая частота. с чего мы это взяли? взяли мы это с того что : под косинусом то что стоит это всегда угол в радинах и больше это ничего. еще раз под
косинусом всегда стоит исключиельно угол в радианах. значит

cos (n*w1*t) = cos (phi)
значит
phi=n*w1*t

n- это константа
w1- это констата

находим производную d(phi)\dt
d(phi)\dt=n*w1

значит по опредеению w=d(phi)\dt значит  w(t)=n*w1
таким образом мы видим что наша w независит от времени, она постоянная,
значит n*w1 это коэффициент имеет по своему физическому смыслу тот смысл что 
это круговая частота! соотсвтееенно если n=1 то тогда w1 по своему физ
смыслу оказывается круговая частота. а если n неравен 1 то тогда круговая
частота это n*w1 и в этом случае w1 неимеет явного физ смысла.
если мы под косинусом стоял другой закон для phi например

cos(n*w1*t^2)

тогда
phi=n*w1*t^2, тогда d(phi)/dt=2*n*w1*t тогда w(t)=2*n*w1*t
в этом случае n*w1 неимеет никакого физ смысла . это просто коэфиициент.

Так значит о том что w(круговая частота)=n*w1 если у нас угол имеет вид phi=n*w1*t
мы разобрались - тоесть потому что мы так сами задали захотели чтобы угол
в косинусе менялся по закону phi=n*w1*t. мы так захотели сами изначальано.
а w=n*w1 из определения. потому что w=d(phi)\dt а d(phi)\dt=n*w1

Теперь отвечаю на вопрос почему мы хотим ракслкдыать сигнал именно по 
функциям 

cos(1*w1*t), sin(1*w1*t), cos(2*w1*t), sin(2*w1*t), .... cos(n*w1*t),
sin(n*w1*t)

а не каким то другим. значит данные функции являются гармоническими. 
что такое математически означает гармоническая фугкция - хрен знает. я посмотрел 
както там сложно. важное свойство гармонических функций в том что при прохождении
через линейную систему (что такое линейная система тоже отдельный вопрос я незнаю 
но видимо это важные системы), так вот при прохождении гармонического сигнала
через линейную систему сказано что гармонический сигнал это единственная форма сигнала которая сохраняет свою форму меняется только амплитула и образуется сдвиг 
фазы и все. получается что если мы пропустим через линейную систему скажем вначале
один гарм сигнал , посмотрим как у него имзенится амлитуда и сдвиг фазы. потом
запустим второй сигнал, потом третий. а потом мы запустим сигнал который является 
суммой этих трех сигналов то на выходе мы получим предсказуемый сигнал который
будет являться также суммой исходных трех сигналов  в кажом из которых была изменена
амплиутуда и сделан сдвиг фазы. таким образом пропустив через линейную систему
весь набор гармонических сигналов по отдельности и померяв как меняется амлиутуда
и сдвигается фаза а потом разложив наш произволльный сигнал по этим гармоническим 
сигналам мы будем заранее знать какой сигнал мы будем получать на выходе.
Вот походу зачем и почему мы хотим искать разложение нашего исходного сигнала
именно по такому базису функций.

Значит исходя из лекции из томского политех института - там сказано что данный
набор функций является ортгональным на интервале от t0 до t0+T
где T=(2*pi)/w1
Что такое ортогональность. Это типа как скалярное произведение векторов. мы 
требуем чтобы они были друг относительно друга под углом 90 градусов.
для векторов это выглядит как |a|*|b|*cos(ab) это значит что если между ними 90 градуосов то тогда скаляр произвдение будет равно нулю. у ортогональных векторов
скаляр произвдеение равно нулю. потому что они под 90 градуосв друг относиельно 
друга. Тоже самое водится для функций на интервале (a,b) функции ортогональны
если интеграл  f1(t)*f2(t)*dt = 0 на интервале (a,b) 
соотвственно они там показывают что на интервале (t0,t0+T) интегралы
cos(n*w1*t) * cos (m*w1*t)* dt=0
sin(n*w1*t) * sin (m*w1*t)* dt=0
sin(n*w1*t) * cos (m*w1*t)* dt=0

соотвевенно если функция умножается сама на себя в таком же интеграле то 
как и в случае векторов когда |a|*|a|*cos 0 = |a|^2 также и для функций там 
должна получаться константа. они показыват что да получается константа = T\2
вобщем таким макаром доказыаетсся что нащ выбранный набор функций он ортгонален.
также он полон(хрен знает что это значит) , вобще витоге всю эту бодягу товарищ 
фурье проделал и доказал что для периодичекой функции f(t) ее можно представить
как разложение по гармоническим функциям

f(t)=a0/2 + summa ( a(n)*cos (n*w1*t) + b(n)*sin (n*w1*t) )

где 
a(n), b(n) этокофициенты тоесть они независят от t. это чисто константы которые 
вычисляюются по форумулам через интеграл.
w1 - это константа которую мы выбираем изначально какую нам в голову взбредет.

еще раз почему мы ищем ращложение нашей f(t) именно по 
cos (n*w1*t), sin (n*w1*t)
потому что эти сигналы при проходдждении чере линейную сисему сохраняют свою форму
у них менятеся только амплитула и сдвигается фаза. поэтому если мы разложим наш
сигнал на эти функции то мы можем тогда зараннее предсказать какой сигнал мы полуич
на выходе. это удобно это прикольно.

также прикольно что получается что любой звук (перидоический) можно получить
если взять гитару с бесконечным числом струн. далее дернув каждую струну с нужной
амалитудой и фазой на выходе получим наш искомый звук. это тоже прикольно.  тоесть
наш звук являтеся суммой бесконечного числа дернутых струн. это прикольно.

прикольно то что сигнал можно разложить по таким простеньким сигналам. по вибрирующим струнам. ну или по грузикам дергающимся на пружинках. это очень 
просьенькие сигналы. это чтото типа того как человек состоит из клеток или даже атомов. как книжка состоящая из букв. или как данные на диске состоящие из 0 и 1.
интеерсно можно ли звук или сигнал разложить еще по более простецким по своей форме
сигналам. потому что синус и косинус конечно он простой но все же достотаточно еще
сложный. нужно чтото более еще простецкое. было бы прикольно. 
другой дело что я понял что синус и косинус это якобы единственный по форме сигнал
который сохраняет форму при прохождеии линейной системы. а это важно. другой
отртогональный набор базисных функций этим свойством якобы не обладает.

окей. это я вроде как понял. и частности то что почему phi=n*w1*t.


Далее. 
насколко я понял вопрос о том а что мы делаем если функция у нас не регулярная.
что делать тогда. как я понял делать только вот что. берем ее ограниченную 
слева и справа по X тоесть по времени. то есть берем ее какойто кусок за какоето время.  потом мы ее продолжаем налево и направо по времени так чтобы она стала
приеодической. далее получаем разложение фурье. и на нашем ограниченном участке
разложение будет совпдаать с нашим сигналом. 


Далее.
остается вопрос какой смысл городиь комлплексный ряд фурье чем плохо обычный ряд фурье. в обычном ряде фурье наш сигнал разбивается на графики:
 график a(n) от n*w1
 график b(n) от n*w1

в чем преимущество перед комплесным рядом фурье?
в нем сигнал разбиватеся тоже на два графика:
график c(n) от n*w1
график phi(n) от n*w1

так в чем же выгода?
в другом учебнике про ряд фурье я нашел то что выгода от комлпескной формы
состоит якобы в том что она более компактная. и больше никаких выгод
она недает. 

Еще раз более подробно рассмотрим комлексную форму ряда фурье которую вывел я:
f(t) = a(0)*0.5 + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  
+ e^(i(-n*w1*t-phi(n)) ]

где phi(n) = argz(a-i*b)
где   c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)

заменим:
c(0)=a(0)*0.5

получаем:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ]

где:
n=1..inf
c(0)=a(0)*0.5
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
phi(n) = argz(a-i*b)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]

расмотрим а чему равно a(-n):
a(-n)=(2/T)* [ integral (f(t)*cos(-n*w1*t)*dt) на отрезке [-T, T] ]
соотвесвтенно поскольку cos(-x)=cos(x) значит:
a(-n)=a(n)

расмотрим а чему равно b(-n):
b(-n)=(2/T)* [ integral (f(t)*sin(-n*w1*t)*dt) на отрезке [-T, T] ]
соотвесвтенно поскольку sin(-x)=-sin(x) значит:
b(-n)=-b(n)

тогда с(-n)=0.5 * sqrt(a(-n)^2+b(-n)^2) = 0.5 * sqrt(a(n)^2+(-b(n))^2)=
=0.5 * sqrt(a(n)^2+b(n)^2) =c(n)
значит
c(-n)=c(n)

далее
 phi(-n)=argz(a(-n)-i*b(-n))=argz(a(n)+i*b(n))=argz(a+i*b)

далиее сраниваем:
phi(n) = argz(a-i*b)
phi(-n)= argz(a+i*b)

мы видим что справа стоят компл сопряженные числа значит:
phi(-n)= -phi(n)
собственно нам вот эта формула и нужна была. щас мы ее применим.
значит берем ряд фурье:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ]

и разбиваем сумму на две суммы:
summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] =
= summa [ c(n) * e^(i(n*w1*t+phi(n))) ] +
+ summa [ c(n) * e^(i(-n*w1*t-phi(n)) ]

где:
n=1..inf

(тоесть я пользуюсь свойством что summa (a+b)=summa(a) + summa(b). )

далее рассматриваем вторую сумму:
summa [ c(n) * e^(i(-n*w1*t-phi(n)) ]
где:
n=1..inf

введем замену переменной:
k=-n, где k=-inf..-1
тогда:
n=-k
тогда подставляем:
summa [ c(n) * e^(i(-n*w1*t-phi(n)) ] = summa [ c(-k) * e^(i(k*w1*t-phi(-k)) ]
где:
k=-inf..-1

поскольку k это просто внутренний индекс (тоесть неважно какая буква k или n)
то мы юзаем полученное выше свйоство что 
c(-k)=c(k)
phi(-k)=-phi(k)

подставляем это в нашу сумму:
summa [ c(k) * e^(i(k*w1*t+phi(k)) ]
где:
k=-inf..-1



тогда подставляем это в сумму что выше:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] = 
= c(0) + summa [ c(n) * e^(i(n*w1*t+phi(n))) ] + summa [ c(k) * e^(i(k*w1*t+phi(k)) ]

где:
n=1..inf
k=-inf..-1

теперь замечаем что в первой сумме и во второй сумме внутри член стоит 
одинаково выглядящий. просто суммы идут от пределов.
и мы заюзаем такое свойство сумм что :
summa ( a(n) ) + summa ( a(k)) = summa (a(f))

где:
n=a..b
k=b+1..d
f=a..d

тоесть две суммы можно обединить в одну если член под суммйо одинаковый. 
суммы обединятся в одну просто путем обьединения пределов суммы. 
например:
summa (n) + summa (k) 
n=1..3
k=4..5
значит:
summa (n) + summa (k) = summa (f)
f=1..5
деййтвиельно:
summa (n)=1+2+3
n=1..3
summa (k)=4+5+6
k=4..6

значит suuma (n)+summa(k)=1+2+3+4+5+6
саравним с суммой по f
summa(f)=1+2+3+4+5+6
f=1..6
видно что 
suuma (n)+summa(k) = 1+2+3+4+5+6 = summa(f)

значит для нашего случая мы получаем то что:
f(t) = c(0) + summa [ c(n) * [ e^(i(n*w1*t+phi(n))) +  + e^(i(-n*w1*t-phi(n)) ] = 
= c(0) + summa [ c(n) * e^(i(n*w1*t+phi(n))) ] + summa [ c(k) * e^(i(k*w1*t+phi(k)) ] = c(0)+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
n=1..inf
k=-inf..-1
m=-inf..-1, 1..inf

итак мы получилии что:
f(t)= a(0)*0.5+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1, 1..inf

как видно пределы суммы невключают в себя индекс равный ноль.
рассмотрим элемент суммы при m=0
[ c(0) * e^(phi(0))) ]


phi(0)=argz(a(0)+i*b(0))
a(0)=(2/T)* [ integral (f(t)*cos(0)*dt) на отрезке [-T, T] ]=
= (2/T)* [ integral (f(t)*dt) на отрезке [-T, T] ]=
b(0)=(2/T)* [ integral (0*dt) на отрезке [-T, T] ]=0
значит
phi(0)=argz(a(0)+i*0)=0
значит:
при m=0 имеем:
[ c(0) * e^(0))) ] = c(0)

рассмотрим чему равен c(n) по формуле:
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
мы только что получили что b(0)=0 тогда
c(0)= 0.5*sqrt(a(0)^2+0)=0.5*a(0)
итак элемент под суммой при m=0 он равен 0.5*a(0) если считать по нашим 
общим формулам для a(n),b(n),c(n),phi(n)

значит в нашей формуле для ряда фурье:

f(t)= a(0)*0.5+ summa [ c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1, 1..inf

мы выяснили что при m=0 то что внутри суммы равно a(0)*0.5 это значит что 
мы можем убрать из формулы a(0)*0.5 а в границы сумммирования добавить индекс m=0

тогда наша формула для ряда фурье будет выглядеть:

f(t)= summa [  c(m) * e^(i(m*w1*t+phi(m))) ]

где:
m=-inf..-1,0,1..inf = -inf..+inf


ну или если теперь заменить m на n то:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

рассмотрим то что мы получили.
c(n) это чисто числовая вещественная константа. тоесть прям число типа как 5,10,100
если мы посмотрим на формулу c(n) то мы увидим что c(n)>=0 всегда тоесть он точно
никогда неотрицательный. таким образом c(n) определяет длинну вектора комлплексной
экспоненты. 
второ сомножитель это комплексная экспоненты которая выглядит на компелкексной
плоскости как вектор единичной длинны лежащий на окружности единичного радиуса 
повернутый на некторый угол. причем для каждого n будет некоторый инидивидуальный 
угол докрутки phi(n). 
таким образом в целом то что стоит внутри под суммой это на комплексной плоскости
вектора длинной c(n) повернутый на угол пропорциональный n и еще подкрученный
на некоторый индивидуальный угол phi(n). если мы зафиксируем n. тоесть рассмотрим
этот индивидуальный вектор и при этом мы незафиксируем t то этот вектор будет 
вращаться в комплексной плоскости по окружности радиусом c(n) с угловой скоростью n*w1 причем если n>0 то он будет вращаться против часовой стрелки а если n<0 то против часовой стрелки. при фиксированнном n  у нас c(n) и phi(n) это константы.
таким образом длинна вектора будет постоянная тоесть как я и сказал что вектора
будет описывать окружность. phi(n) получается задает начальную фазу (если мы рассматриваем на момент времени t=0) или сдвиг фазы. при изменнеии t вектор начнет
вращаться с постоянной угловой скоростью n*w1 (n фиксировано. w1 - начальная константа). 

так. я щас немножко еще перепишу формулу:
f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ] = summa ( s(n) )

так вот если мы зафиксируем t, и рассмотрим s(n) и s(-n)
то мы увидим из того что получали ранее что эти два вектора в компл плоскости
они имеют одну длинну и зеркально относительно гор оси повернуты. тоесть эти компл
числа (вектора)  они сопряженные. это значит что при сложении этих двух векторов
их сумма всегда будет лежать на оси X тоесть результат вещественное число. тоесть
таким макаром мы еще раз доказали что вся сумма это вещественное число.

далее исходя из этой формулы строят два графика:
c=c(n)
phi=phi(n)

хотя не совсем так. еще домножают на изначальную константу w1 тоесть
c=c(n*w1)
phi=phi(n*w1)

поскольку n= -inf..+inf
то это значит что n у нас принимает как положительные так и отрицаттельные
значения на графиках. соотвевтенно при отрицательных n  у нас под суммой генерируются экспоненты (вектора) которые при измении t вращаются против часовой стрелки а при положительных n у нас гененрируеются экспоненты которые вращаются 
при изменнии t по часовой стрелке. 

итак еще раз посмтрим на полученный вид ряда фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

значит для примера скажем для какойто фукции он выглядит вот так:
(я взял w1=1 для примера также):

f(t)= 2*e^(i(-100*t+1)) + 3*e^(i(-99*t+2)) +...+ 6 + 3*e^(i(99*t-2)) +
+ 2*e^(i(100*t+1))+... 

зафиксируем некоторый момент времени t0.
что по факту мы видим в правой части - мы видим кучу векторов постоянной длинны которые складываются по правилам сложения векторов ну и как мы знаем они дадут вектор у которого 
вторая координата ноль, тоесть вектор будет лежать на оси X. и его первая координата
и будет f(t). если мы начнем менять время то конструкция оживет. если мы дадим приращение времени t0+dt то вся эта гирлянда векторов сдвинется , вектора начнут вращаться кто-то по часовой стрелке кто-то против часовой в зависимости от знака
перед t, и они начнут вращаться с постоянными угловыми скоростями равными тому 
что стоит перед t. еще как можно сказать - вот у нас зафиксирован момент t0. все вектора неподвижны. мы находим их сумму. потом мы сдвинули время на t0+dt и у нас
картинка оживет - у нас все вектора повернутся на некоторые углы в зависимости какой
коэфициент стоит перед t и далее конструкция опять остановится замрет. и мы опять посчитаем векторную сумму этих векторов и получим f(t0+dt). Эта красивая картина. 
мне это напоминает часы с шестеренками. каждый вектор это своя шестеренка в часах.
часы стоят. мы берем крутилку сзади у часов и чуть чуть ее крутим (тоесть делаем t0+dt) и тут же все шестеренки приходят в движение и в итоге стрелка на морде часов
передвигается на некоторое расстояние . стрелка на морде часов это и есть f(t0+dt).
Очень красивая получается концепция. Еще и потому что вектора также как и шестеренки
крутятся действительно по окружностям. И еще аналогия красиво совпадает в том плане
что в часах с шестеренками большие шестеренки вращаются медленно а мелкие шестеренки вращаются очень быстро. Также и здесь - есть вектора у которых большая угловая скорость они будут делать за единицу времени очень много оборотов вокруг себя а есть вектора у которых малая угловая скорость и они будут вращаться очень медленно вокруг себя за единицу времени. тоесть когда мы покрутим крутилку то какието вектора повернутся на очень много оборотов а какието еле сдвинутся. это ровно тоже самое как в часах. мы немного поворачиваем крутилку и мелкие шестерни очень много раз повернутся а крупные шестерни еле еле повернутся. Остается понять 
какая аналогия с амплитудами у векторов и шестернями в часах , что у них общего.

далее я пока откладываю тему шестеренок в будильнике на потом.


дальнешие размышления замечания про всю эту тему:
Если мы умножаем комплескное число на комплексное число то что будет
их результатом - будет еще одно компл число у которого длинна вектора будет
произведение длин векторов и угол поворота  сумма углов обоих векторов.
тоесть z1*z2=r1*e^i(a1) * r2*e^i(a2) = (r1*r2)*e^i(a1+a2)
теперь рассмотрим частный случай:
z1*e^ia=r1*e^ib*e^ia=r1*e^i(a+b)
таким образом если мы умножаем компл экспоненту на произвольное компл число то
результат будет вектор который по длинне равенр длине вектора z1 и довернулся
на тот градус который имел вектор z1. тоесть если у нас экспонента это функция 
времени а z1 это константа относительно времени , то чистая экспонента как известно  выглядит как единичный вектор вращающийся по окружности так вот
домножение ее на z1 дает то что это будет не единичный вектор а вектор длинной z1
и он который в момент времени 0 будет иметь начальный повопрот - начальную фазу начальный сдвиг фазы. вот это для понимания. 

далее если мы рассмотрим две экспоненты e^ia и e^-ia то это вектора который сопряжены друг к другу. e^ia это единичный вектор который повернут на угол a, 
а e^-ia это единичный вектор повернутый на угол -a если мы теперь рассмотрим
их сумму 
e^ia + e^-ia то это будет вектор который имеет только вещественную часть. 
если у нас a это функция от времени a=a(t) то первый вектор если смотреть по времени
он будет вращаться по окружности по часовой стрелке а второй против часовой стрелки.

если у нас есть z1 и z2=z1(сопряженное )  и мы рассмотрим такую сумму:
z1*e^ia+z2*e^(-ia) то что это будет. 
первое слагаемое это вектор длинной z1 и он повернут на угол a+b
второй вектор той же самой длинны и повернут он на угол -a-b таким образом
у нас два сопряженных вектора которые нужно сложить. их сумма это всегда 
вещественное число. если a=a(t) то тогда первый векторввращается по часовой стрелке
при изменении t а второй враается против часовой стрелки. теперт вспомним
ряд фурье в форме:
f(t)=a0*0.5+summa [ 0.5*(a(n)-b(n))*e^(i*w1*t) + 0.5*(a(n)+ b(n))*e^(-i*w1*t) ]
так вот если мы присмотрися то то что стоит под суммой это вточности что 
я описал выше
z1*e^ia+z2*e^(-ia)  
где z2=сопряженное от z1

таким образом сумма двух векторов под суммой это вещественное число. длинна
этого вектора это длинна бОльшей диагонали паралеллограмма и она равна
D=sqrt[ |z1|^2+|z1|^2+2*|z1|^2*cos (2*(argz(a-i*b))) ] и вот эти вот диаогонали
под суммой и будут складвыаться в бесконечном ряду.

По сути под суммой складываются два сопряженных вектора z1 и z1(сопряженное)
кажды из которых повернут на доп угол (w1*t), тоесть физический смысл 
того что под суммой это сложение двух сопряженных векторов но они еще чуть чуть
развернуты на дополнительный дельта угол за счет экспонент, по факту после доворота
оба вектора  по отношению друг к другу остаются сопряженными. так что по по факту 
мы изначально имели два сопряженных вектора и после домножения на эксопненты имеем
два сопряженных ветора. которые надо сложить. вот такой физ смысла того что под суммой стоит. тоесть вот теперь то что под суммой из непонятного месива формул
стало понятным. его физ смысла как это выяглядит. 

Далее.
рассмторим 
z=e^ia
где 
a=a(t)=k*t, k-константа
тогда
z=e^i*k*t
пусть k>0 тогда если мы будем сроить вектор z и менять время то вектор z это будет
единичный вектор который вращается по окружности против часовой стрелки 
с круговой частотой относительно времени k.
если же k<0 то все тоже самое только вектор вращается против часовой стрелки.
пусть n=|k| тогда n=-k тогда
z=e^i*k*t=e^i*(-n)*t=cos (-n*t)+i*sin (-n*t)
что я не могу понять это то что они пишут что у вещественых фукций небыавет
отрицательной круговой частоты. что за бред. коэфицицент что стоит при t это формально угловая частота. так что w=-n, где n>0 тоесть мы имеем отрицательную угловую частоту у вещственной функции. посольку w=d(phi)\dt то знак показывает
то что угол со увеличением времени он падает а нерастет. ну и что. что тут такого.
то что производная отриццательрная в этом нет никакого чуда. поэтому  янепонимаю
почему эти придурки пишут что у вещественый фуннкций нет отрицательной угловой частоты. есть она. а что тогда делать с периодом ? ну я думаю что T=2*pi/|w|
поэтому и V=1\T будет положительный даже если w<0 ну и что. да. 

далее.
итак еще раз посмтрим на полученный вид ряда фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)

как на практиеке может выглядеть этот ряд:
f(t)= 0.5 + 1*e^(i*2*t+3) +1*e^(-i*2*t-3)...
или
f(t)= 0.5 + e^(i*2t+3) +1*e^(-i*2t-3)...
график АЧХ будет выглядеть:
в  точке w=-2 аплитуда A=1
в  точке w=0 аплитуда A=0.5
в  точке w=2 аплитуда A=1
график ФЧХ будет выглядеть:
в  точке w=-2 фаза phi=-3 рад
в  точке w=0 аплитуда phi=0 рад
в  точке w=2 аплитуда phi=3 рад

Прикольно то что мы бы хотели изобразить нащи экспонеты в графическом виде 
в форме вектров. но проблема в том что время меняется поэтому както конкретно
нарисовать вектора в этом случае невозможно . нам нужно избавится от времени 
в том плане что бы графики независиели от времени. поэтому мы вместо векторов
изображаем на графиках константы с точки зрения времени . тоесть амплитуду и фазу.
как бы врем неменялось ампдитуда и начальная фаза остаются теми же самыми.

хочу подчеркнуть что c(n) у нас всегда вэтой формуле вещественый.это важно отметить
мы имеем сложение кучи векторов. каждый вектор если мы будем его 
рисовать на плоскости компл то он будет вращаться при имзенениии времени t.
угловая частотв вращения вектора будет w1*n. в завимиости от знака он вращается
против либо по часовой стрелке. если мы хотим в некоторый фиксированный момент времени t0 построить вектор на компл плокости то мы должны взять n оно определяет
какой вектор мы хотим строить. и для этого вектора определить его длинну тоесть c(n)
и его угол поворота то есть n*w1*t0+phi(n), посколльку вот это мы знаем n*w1*t0
то нам надо только узнать  phi(n). таким образом для каждого вектора который 
характеризуется n мы должны вычислить\узнать\выяснить c(n),phi(n)
поскольлку  n = -inf..+inf это значит что у нас n<0 есть и n>0 есть. так что
график c(n) и phi(n) будет иметь точки и слева от нуля по оси X и справа. 
графие будет дискретный так n   у нас дискретные. каждая n характериузует
собой значения c(n) и phi(n) для очередного вектора. если знаем n,c(n),phi(n) 
то знаем как построить очередной вектор под суммой. До этого моменты мы фиксировали время t0 но меняли вектора.щас наоборот зафикисруем n но рассмотрим вектор у которого t как переменная тогда наш вектор

c(n) * e^(i(n*w1*t+phi(n))) = с * e^(i*n*w1*t+phi)
где c,phi,w1 константы. а t переменная.  
данный вектор в момоент времени t=0 имеет начальный угол повопрторта (начальная фаза) phi. он вращается (меняет угол)  вокруг начала координат при имзеннеии времени t с уголвой скорость n*w1 по часовой либо против часовй в зависиомти от знака  n. это значит что угол вектора как функция от времени является перидической 
функцией для данного вектора. тоесть если угол это q то q=q(t)=q(t+T) посколльку
T завиит у вектора от угловой частоты а угловая частота вектора это n*w1 
то имеет смысла откладывать графики не в виде c=c(n), phi=phi(n) а в 
виде c=c(n*w1), phi=phi(n*w1) это нам дает то что для каждого n (тоесть для каждого вектора) мы знаем его амплитуду c , мы знаем его начальную фазу phi и знаем 
с какой периодичностью (как быстро ) он вращается по времени (тоесть изменение его угла по времени ) вокруг начала координат(другими словами мы знаем период по времени для данного вектора тоесть через сколько время он совершает полный оборот ну или другими словами сколко оборотов  в секуду он совершает). а что нам это дает?
вот возьмем конкретный вектор:
n=100
w1=1
c=10
phi=0
что тогда мы из этого понимаем:
амплитуда у него 10.
в момент времени t=0 его фаза (угол поворота) =0+0=0 тоесть он лежит на оси X,
фазу знаем угол знаем - значит мы уже его сможем помстроить на компл плоскости, окей
построили. отлично. это нам и надо было. в плане его угловой частоты w=n*w1=1*100
значит этот вектор за секунду поворачиватеся 100=2*pi*V, V~30 раз. вектор за секунду
поворачиватся 30 раз. мы это узнали потому что на графике мы откладывали не просто n а n*w1. тоесть мы сразу из графика видим что у вектора n*w1=100 и сразу из графика понимаем что этот вектор вращается  30 раз в сеунду. если бы мы на графике откладывали по гор оси просто n то чтобы понять как часто вращаетс вектор характеризуемый числом n нам бы надо было лезть смотреть как выялядит ряд находить там w1 и считать. а так нам сразу это видно из графика. 
Итак еще раз у нас есть ряд фуурье в компл виде. предсталвяет собой сумму. под суммой стоит элемент с порядковым номером n. по факту это вектор на компл плоскости. у этого вектора фаза угол это функция от времени а апитуда по времеи постоянная. поэтому если мы будем рисовать этот вектор на компл плоскости
и менять время то он будет вращаться. поскольку он вращается то через какое то время он вернется в исходное положение. тоесть его угол это перидоическая функция или  с другой стороны это значит что он за единицу времени сделает сколько то кругов. поэтому нам для каждого вектора удобно иметь следущую таблицу парметров которая независит от t:
длинна вектора = c
начальная фаза =phi
частота вращения вокруг начала координат = n*w1

зная n,c,phi,w1 из таблицы мы всегда можем построить вектор на компл плоскости 
в для любого моммента времени t, зная n и w1 мы знаем как часто вектор вращается вокруг начала координат.  таблицу для n,c,phi,w1 удобней всего записать в форме
двух графиков :
c=c(n*w1)
phi=phi(n*w1)

Итак параметр n*w1 нам дает инфо какая угловая частота вектора. а зная его угловую частоту ( а мы также знаем что она от времени независит) мы знаем как часто он вращается в секунду. именно для того чттбы можно было из графика определить угловую частоту для вектора n мы на оси X откладываем не n а n*w1. Окей с видом графиков 
разобрались. зачем там n*w1 тоже разобрались.

Разберемся  еще вот с чем - вот у нас есть два вектора s(n,t) из этой суммы.
в чем их разница ? в чем разница вклада одного вектора s(n1,t) по сравнению с вкладом
другого вектора s(n2,t) в конечный вид графика f(t)

положим что w1=1. тогда w=1*n=n 
тогда рассмотрим два вектора

s1=s(10,t) = s1 имеет w=10
s2=s(1000,t) = s2 имеет w=1000

в чем их разница в плане вклада в вид f(t) графика. 
положим для простоты что у нас под суммой не бесконечное множество векторов а всего два. это значит что финальный вектор тот который и будет (f(t),0) он будет скалдываться всего из векторной суммы двух векторов s1+s2. совершенно очевидно что 
в завиимости от момента времени данные два вектора будут друг относииелно друга
иметь какойто угол. а это значит что в завимости от времени суммарный вектор будет 
по длинне от |c1-c2| до |c1+c2|. где c1,c2 это амплитуды s1,s2.
пусть c1=100, c2=1 тогда суммарный вектор по длинне будет меняться от 99 до 101.
( да мы при этом помним что на самом деле под суммой не два а туча векторов и то что они там на пары разбиваются и это дает то что суммарный вектор будет лежать на оси X но это щас все неважно). так вот в чем разница между s1 и s2 в плане их влияния на суммарный вектор s3 тот который нам и дает (f(t),0).  возьмем время t0
отложим вектор s1, отложим\построим вектор s2 и найдем их векторную сумму s3=s1+s2
теперь немного сдвинем время  t0+dt,  мы увидим что за время dt вектор s1 сместится на плоскости слабо потому что у него w маленькая. а вектор s2 сместится на очень большой угол потому что у него w очень большая. получим новый s1' и s2' 
построим новый s3'=s1'+s2' так вот вознкикает вопрос какой из данных векторов s1 и s2 внес бОльший вклад в изменений амплитуды вектора s3? ответ конечно s2 потому что он меняет свое простанственное положение намного более резко чем s1. а нам суммарный s3 вектор его длинна очень как раз зависит от простсранстевенного положения векторов s1, s2 относиельно друг друга. ну опять же мы помним что что 
под сумммой стоит не два вектора а туча и то что в конечном итоге их вертикальные 
компоненты дадут ноль при векторном сложении и останутся только горизонтальные компоненты таким образом на f(t) влияет горизонтальная проекция всех векторов их сумма поэтому чем сильнее за вермя dt вектор помено свое пространственное положениетем сильнее у него поменлась его горизонталная проекция и тем сильнее этот вектор влияет на изменнеие конечной суммы всех проекций. в итоге я бы сказал так ч
что чем меньше частота у вектора тем его амплитуда на отрезке времени играет роль как бы базово несущей в форму графика f(t) а чем выше частота вектора тем его амплитуда играет основную роль в изменение формы f(t).  скажем 
если вектор имеет маленькую частоту то он на отрезке времени [t0,t+dt] будет 
давать вклад в f(t) скажем как число 5 которое почти неменяется. а вектор
который высокочастоный он будет на этом участке по 1000 раз менять эту пятерку на величину 5+[-1,+1]. тоесть он будет придавать волнистость этой пятерке. 
пока на этом пауза.

Немного отодйем в сторону:
амплитудная модуляция. 
по определению что такое амлплитудная модуляция. Это когда у нас есть исходный сигнал который нужно передаь по радио. Исходны сигнал это голос. 
Что мы делаем - радио волна имеет частоту намного больше чем голосовая волна. Щас
 я обьясню. Мы берем микрофон и колебание мембраны в микрофоне формирует в проводах от микрофона колебания напряжения в контуре микрофона с той же частотой что и колебаия воздуха от голоса. Эти колебания это типа 100Герц-20,000 Герц.
 Далее в чем проблема отослать  в эфир радиоволну частотой скажем 10,000 Герц. 
 Проблема следущая - проблема в длинне волны.
 То есть Если у нас частота V=10,000 герц. То период T=1/10,000 секунд. А длинна волны это растояние которое пробегает воолна за периол. значит 
 lambda=c*T=3*10^8 * 10^(-4)=3*10^4 метров = 30км. 
 30 км пролетает волна за период. это ее длинна. длиннна радиоволны. так вот
 известно что размер антенны должен быть равен половине длинны волны. значит надл
 ставить антенну размером 15км. Поэтому передать голос на тойже частоте радиволны
 нереально. (прикольно что по проводам коротким без проблем передавать элекртрическую вполну волны блядь длинны при этом. Тоесть через провод длтнной 1метро можно спокойно передать волну длинной 30км). Поэтому электросигнал 
 в проводе от микрофона непередают на тех же частотах которые имеет сигнал от голоса в проводах микрофона. Вместо этого берут радивоолну у которой частота 
 услоно говоря в милллионы раз больше и передают через нее. Так вот что такое по 
 опредеению амплитудная модуляция. Если у нас есть исходный сигнал  U1 то мы его 
 используем как амплитуду на частоте радиволны. тоесть.
 wr- частота радиволны. Тогда амплитудно смодулировыннй сигнал это 

 U2(t)=U1(t)*cos(wr*t)
При этом мы помним что что энергия из батарейки радиостанции тратится на образование
апмлитуды. так вот в этом случае видно что вся энергия тратися искоючительно на 
передачу именно полезной информации. так вот эти долбоебы они делают не так . Они делают по другому. Они делают вот так

U2(t)=cos(wr*t)+U1(t)*cos(wr*t)

при этом получается что батарейка радиостанации тратит энергию на образование 
амплитуды так называемого несущего сигнала. и на образование аплитуды уже полезного сигнала. Захуя так делать я вобще непонимаю. Преобразуем формулу:

U2(t)=[1+U1(t)]*cos(wr*t)

Тоесть видно что к нашей полезной аплитуде которая перадеает информцию добавлятся
некая ебануто беспооезная константа несущего синнала. нахуя? она просто выжирает доп энегию из батарейки радисотавннции а ничего полезного в себе ненесет.

Единственное что я могу прдположить почему так ебануто делат потому что чисто физически на уровне микросхем дешевле генерировать волну именно вторым способом
не вплане энергозатрат а в каких то других электротехнических планах в том числе
например в том плане что на приемнике техника которая будет декодировать сигнал 
она будет стоить дешевле.Я только так этот ебанизм могу обьяснить. 




- Так - тут целая огромная куча вопросов вылезла:
Если мы берем звуковые волны которые за речь отвечают то непонятно зачем 
динамик который излучает должен быть каких то там опредееленных геометрических
размеров я вообще нихуя не пойму. Предпожоим у нас есть точечное тело. Мы его дергаем по закону y(t)=10*cos (2*pi*1*t) Это точечное тело ударяет окружающий воздух
. Воздух считаем некими упругими шариками поэтому вот это смещение оно смещает 
соседа а тот своего соседа  и у нас вот этот вот удар полетел по воздуху. фронт удара фронт волны полетел в стороны со скоростью звука. и данный удар долетает 
до уха и отклоняет перепонку ну или точку в ухе на такое же смещение грубо говоря
наша ушная перепонка начинает колебаться ровно по такому же закону. 
тоесть у нас есть источик звука некаая точка которая колбелется по закону

y(t)=10*cos(2*pi*1*t)

и у нас с некоторым отставанием ровно по тому же закону колбелется точка в ухе

q(t)=10*cos(2*pi*1*(t+phi0)

phi0-смещение фазы из за того что удар от источника звука смещение точки 
немгновенно попадает в ухо а через некоторое время обусловленное временем за которое воздух передает возмущение от источника в ухо. 
как бы получается что у нас есть два грузика колеблящихся на пружинке .
один грузик это исчоник звука а второй это ухо. воздух играет роль передатчика.

Это мы рассмотрели передачу волны 1Гц. 
Речь это суперпозиция кучи волна от 20Гц до 20Кгц.
Что значит суперпозиция на практие с точки зрения двигающегося грузика. Этовсего навсего значит что закон смещение грузика от времени y(t)более сложный чем 
y(t)=10*cos(2*pi*1*t)

он будет выглядеть как ряд фурье:
y(t)=summa ( a(n)*cos(w(n)*t+phi(n) ) )

по факту на практие это просто точка которая дергается вдоль линии в пространстве
по какомуто сложному закону y(t)

так вот что я нихуя непойму где здесь требования на размер излучателя?
Если есть точка которая дергается вдоль линии с частотой 20Гц то она должна излучать
звук частотой 20Гц тоесть бас.  я непонимаю почему это неможет быть точка а должна
быть мембрана некоторой площади? что за нахуй?

Что еще реально ебануто и поразительно. Вот есть два вариант волны.
Если дует сильный ветер то как я понимаю он выдувает некое углубление в воде
за углублением получается возвышенност холм ровно также как если взять лопату
воткнуть ее в землю и начать толкать лопату вперед и получается что ветер
он как бы берет верхний кусок воды и пытается эти частицы вытолкнуть туда вперед далье и эти частицы реально передвигаются вдоль горизнтальной плоскости как бутто их гарпуном зацерили или плугом и тащат вперед. тоесть реально верхний слой воды
под дуновением ветра он двигается как автомобиль по дороге. и мы видим волну которая
двигается. совершенно другая волна если кинуть камень в воду. нам кажется что частицы верхнего слоя воды как бутто стартуют от камня и потом их тащит по воде
наружу. но это полная хуйня это совсем нетак. происходит совсем другое. происходит как если бы вода была простыней и какотой бежит мужик под простыней и там где 
он бежит он эту простыну вверх задирает. таким образом в каждой плоскости воды частица она по горизонту никуда несдивигается она только поднимается вверх на какоето время и пото обратно возвращается вниз. волна же бежит потому что под водой бежит невидимый мужик и постоянно над собой поднимает простыни. 

Я посмотрел как выглядит генератор волн в басейне. Это просто один из торцов басейна
который просто толкает воду - чем чаще он толкает тем более частотная волна чем реже
тем менее частотная. так что там вообще остуствует понятие какого то размера 
генератора волн. размером генератора посто служим ширина басейна и его высота. 
собственно может быть любая ширина и высота этого басейна. 

Если у нас скорость передачи фронта это c а период это T то получается что 
расстояние между пиками на воде это lambda=c*T.
тоесть вот мы ладонб удаоили по воде и пик фронт побежал по воде. если скорость
его бега равна C то за время t он убежит от нас на расстояние C*t.
если мы ударяем по воде ладонью каждые T секунд то через время T тот пик убежит 
от нас на расстояние c*T=lambda= длинна волны.  Когда смотришь на график y(t)=cos(t)
то интуитивно кажется что Период T на графике это длинна волны ибо мы же видим что
T это расстояние между пиками на графике. Но это опять же полная хуйня , интуитиция опять наебала. Ибо T это время измеряемое  в секундах а если у нас график y=cos x 
то расстояние в PI это даже не время в секундах это период в радианах. Ммммм. тоесть я что хочу сказать формально период это если у нас ест график функции 
y=y(x) где x люая величина это может быть время в секундах, это может быть градусы в радианах это могут быть метры. Нам похуй. ТАк вот перид это наименьшая хрень такая что x(t)=x(t+T) так что период может измеряться в любых величинах. в радианах , секундах, метрах. все зависит от размерности х. Если мы нарисуем график профиля 
воды в басейне в момент времени t0 тоесть y=y(x,t0) то то что мы называем длинна волны это есть период на это графике и он измеряется в метрах. это пиздец это просто поразительно. 

ДАлее. походу  я что еще понял.
как у человека генерируется звук. в горле стоят связки голосовые. сквозь них продуваем мы воздух. когда он сковзь них протелает то они автоматом начинают вибрировать. И полученный на выходе звук идет как несущая. Как я понимаю 
в ряду фурье это будут первые гармоники которые задают некую несущую низких частот.
а уже ртом языком мы добавляем высокочастотные гармоники. хотя по идее все выглядит 
на оборот - связки дают высоко частотные гармоники а язык с челюстями добавляет низкочастотные. вобщем хуй знает как речь формируется. в вики я прочел что связки 
дают 60-300Гц колебания. тогда вопрос а чем тогда мы генерируем высокие частоты ? ответ ничем.
получается что мы связками делаем несущую. тоесть сразу за горлом в рот летит 
моно звук (ну или смесь низкочастотных гармонических колебаний) на слух это выглядит так что из горла летит некий монтонный звук. вопрос что дальше
происходит во рту с точки зрения частоы, аплитуды, фазы.
Я пока вот как все это вижу. Из горла вылетает низкочастотный звук - этот звук
будет выглядеть как первые гармоники если вылетевший звук раскладывать в ряд фурье.
Ксати про раскладку в ряд фурье - во первых наша речь состоит из букв - например слово "мама" это четыре отдельных буквы мы произносим. каждая буква это некий короткий импульс по времени. а далее вот что - чем более короткий по времени импульс и чем более у него сложная форма фронта сигнала тем более широкий
спектральный ряд гармоник нужен чтобы через ряд фурье его сформировать. как я понимаю гласные звуки имеет более короткий спектр гармоник. а вот согласные
уже имеют широкий спектр гармоник. что же делает рот когда звук в него влетел из горла когда мы хотим сказать согласную букву - я думаю что рот берет условно говоря гармоническое колебание из горла и рот уродует у него форму. и чем более мы изуродовали форму колебания тем больше высокочастотных гармоник нужно в ряду фурье подключить чтобы такую форму сформировать. насколько я понимаю рот это делает таким образом что он гасит резко амплитуду колебания получаются резки обрывы фронта.
так чтобы такой рваный сложный фронт организовать из гармоник то нужно дохера гармоник высшего порядка. я к чему - как можно формировать звук - можно его формировать из неких генераторов звука разной частоты -то есть можно работать со стороны генераторов колебаний. а можно работать из конца тоеть можно брать уже колеблящийся звук во рту и гасить его тогда график f(t) будет адово уродоваться что
эквивалентно тому как если бы во рту стояла куча высокочастотных генераторов. но их там нет. Тость еще раз - на форму звуковой волны f(t) можно влиять с двух концов - 
один конец можно формировать график за счет запуска кучи осцилляторов которые будут складываться в некий суммарный f(t) так работает оркестр из кучи муз инстрементов.
а можно еще действтовать с другой стороны - можно брать уже готовое колебания воздуха и .... я полагаю что может быть у нас буквы это  с точки зрения сигнала то что очень по разному амплитуда меняется у сигнала. тоесть мое пока предположение что из горла вылетает примерно говоря гармонический моносигнал там одной частоты
или узкой полосы низких частот. а буква нашим мозгом воспринимается как то что 
мы своим ртом умудряемся сильно менять амплитуду. более точно ее как то хитрожопо
гасить ртом. и вот эта рваная амплитуда воспринимается как буква. тоесть я к тому 
что рот неменяет часту он меняем очень сильно амплитуду путе того что он ее 
видимо поглощает и всякую там доп микроформу на нее навешивает. 
хм.. еще вот такую идею прочитал - что из голосовых связок идет именно некий спектр частот. так вот измение обьема рта и прочие фокусы язяка и шевеления челюсти приводит к тому что рот становится типа резонатором определнных частот. 
но вот что еще интересно  - звук "к" или "п" можно сформировать вообще с выключенными связками голосовыми тоесть нет несущей частоты. тоестьт это похоже на удар молотком по столу тоесть процесс образования звука похож на то что мы имеем во рту плотно сомкнутую щель. мы в нее нагнетаем воздух ( связи вообще неучаствуют)
и потом мы эту щель резко откравыаем , воздух резко вырывается и возникает некий звук. точно так работает образоывание звуков "к" "п" "т" 
звук "щ" это тоже продувание воздуха сквозь щель во рту. 

звук "б" это тот же звук "п" но при подключении несущей частоты связок.
тоесть по мне вобщем похоже звук получается вот как - для гласных звуков которые простенькие звук образуется за счет связок то ест тупо гармоническое колебание на узком диапазоне из горла. а согласные звуки по мне образуются путем того что
нагнетается воздух во рту в закрытый рот а потом он резко открывается газ резко 
начинает вылетать и получается некий звук но он с колебанием из связок никак не связан это условно говоря звуки которые можно получать путем ударом молотком или карандашом по столу. или если у нас есть банка дихлофоса мы нажали на кнопку и газ вылетает и дает звук. вот по мне согласные звуки в основном там во рту образуются тоесть без участия несущих частот их глотки. глотка нужна только для гласных звуков в основном.  я бы сказал что гласные звуки из глотки это некая внатуре несущая которая никакой информации ненесет. а только как бы сообщает мозгу что началась передача звуковой информации. и можно заметить что кога мы произносим согласную то 
наща глотка прекращает работать и раздается согласный звук как удар молотком например. таким образом гласные это как старт стоп биты. это как фоновая музыка 
на радио когда ктото говорит. согласные это что то обычно либо свистящее либо шипящее либо типа как маленький ударчик молотком. тоесть все эти звуки они с глоткой неимеют никакой связи. буква "р" например глотка вобще выключена это чисто колебание языка во рту от того что летит воздух и язык начинает дергаться. чтобы понять физику образования звука согласного надо понять как формиурется звук при ударе пальцем по доске. вот та же самая физика.  я как раз неисключаю что при ударе молотком по столу возникают как раз таки высок. вобщем звук можно формировать нетолько через колебания струны как это делается в горле. но и совершенно подругому
через удар по предмету. 

Возращаемся обратно: 
вопрос - какой смысл имеют  амплиутдно частотный график и  фазово частотный график. Это график сугубо завязанный на ряд фурье. то есть мы на этих графиках 
расписываем параметры членов внутри суммы. Тоесть по этим графикам мы можем
восстановить вид членов внутри суммы ряда фурье. На этих графиках мы изображаем
эти самые члены под суммой. Поэтому эти графики имеют применение только в связке с рядом фурье. Эти графики неимеют никакого самостоятельного применения. Еще раз на них изоаржаются члены суммы формулы ряда фурье. Когда мы смотрим на графикии 
то по ним мы можем восстановить вид этих членов под суммой. итак смотрим на графиик
и и их смысл такой что мы на них видим как выглядят члены под суммой из ряда фурье.
Эти графики предназначены чтобы по ним можно было восстановить вид ряда фурье. 
Другого самотсотелльного какогото применнеия эти графиик неимеют. Что нужно у себя спросить когда смотрим на эти графиик - вопрос такой что я вижу? ответ - если я вижу
какую то частоту и амплитуду для нее то я понимаю что соответвующий член под суммой в ряду фурье имеет такую частоту и такую амплитуду. В исходном сигнале f(t) ни таких частот ни таких амплитуд нет. Эти графиики это графическое представление
математической формулы суммы в ряду фурье. Я хочу подчернкуть что есть графики 
котоыре имеют самостоятельное значение например график ускорения тела. 
графиик АХЧ и ФЧХ неимеют такого самостоятельного значения. Они жестко привязаны 
к некоей мат формуле - а именно сумме в ряду фурье. и показывают члены стоящие под суммой не вивде формулы а в виде картинок. Это важно понять хотя это вроде как 
очевиедно. Если мы видим некую картинку на которой изобаржены частоты и ампитуды
мы сразу дожоны понять что это показаны члены ряда фурье и ничего другого этот 
график неможет значить. Повторять как заклинание  - на  графике  я вижу члены под 
суммой в формуле для ряда фурье, больше ничего другого на графике я невижу.

Ксати - также надо утоянчть к какой формуле про ряд фурье нарисоываны графики.
к форме вещественной или к комплексной форме. Это тоже важно.
Итак еще раз видим АЧХ и ФЧХ спрашиваем себя что он нам показывает? показывает 
ли он нам исходндую функцию f(t). ответ нет. он нам показывает ряд фурье. точнее
его члены под суммой. в графическом виде. зачем нам это? чтобы из графика 
восстанрвить вид этих членов в виде формулы.




Еще важный момент:
видим запись e^(i*2*pi*f0*t)
вопрос что мы видим?
ответ - мы видим функцию от компллекснного числа. 
что такое функция комплксного числа. это такая хрень которая берет 
компл число и ставит ему в соотвествие другое комплексное число.
поэтому функция это всегда тоже комплексное
число на выходе. значит это некий вектор на комплексной плоскости. 
значит это некая точка на комплексной плоскости.
значит мы видим другими словами вот такое:
(x,y)
x+i*y
r*e^ia
r**cos phi+i*sin phi)

это все одно и тоже.

конкретно это фуннкция берет  компл число причем не произволтное а только такое что 
z=0+i*a и ставит ему в соотвесвтие число cos a+i*sin a
которое является всегда вектором единичной
длинны которые лежит на окружности.
тоесть если аргумент имеет длинну a то ему ставится в соответвие единичный вектор
который поверут на угол a (угол a считается задан в радианах а не в градусах).

в полярных коодринататах e^ia=(1,a)
в декаровых коодинаатах e^ia=(cos a, sin a)

графически это вектор единичной длинны который повернут на угол a.
если меняем a в аргументе то меняется угол поворота функции.

теперь представим что a это функция от времени тоесть
a=2*pi*f0*t.
тут все константы кроме t.

найдем производную da/dt=2*pi*f0
по опредеднию da/dt это угловая скорость w
значит при даннном законе имзенени угла по времени у нас как видно
w=2*pi*f0
как видно она ненавзисит от врмени . згачит w у нас константа. значит скорость 
поворота угла постоянна. Если w это угловая частота то по опредеелению 
w/(2*pi) это линейная чатсота.  тогда мы видим что w/(2*pi)=f0
значит f0 оказывается имеет смысл линной частоты. Исходя из того что ясказал
если мы видим вот такую хрень

e^(i*2*pi*f0*t)

то мы теперь плнимаем что это значит. 
а имеено: это функция от клмпл аргумента.
это комл число.
это вектор.
это единичный вектор на компл плоскости. повернутый на угол 2*pi*f0*t  (угол задан в радианах) в момент времени t. f0 это линейная частота. при изменений времени 
t у нас вектор будет поворачиваться. 

потом они гвооря а давайте рассмотрим такух хрень:
0.5* e^(i*2*pi*f0*t) + 0.5* e^(-i*2*pi*f0*t)

что мы можем про это сказать:
слева у нас векторв компл плокости длинной 0.5 его угол поворота зависит от t.
вращается он по окружности против часовой стрелки. относительно t он вращается 
с уголовой скорость 2*pi*f0. если время t0 то текущий угол наклона у него это 
2*pi*f0*t в радианах.
второе слагаемое тоже самое только вектор наклонен под углом -2*pi*f0*t
по факту это два сопряженных компл числа. и они как видно складываются. 
складывать их можно по правилу векторов. 

Ксати. вместо графиков АЧХ и ФЧХ можно рисовать табличку с тремя строками
n:
c(n):
phi(n):


Главный вопрос который остался это что за хрень отрицательные
частоты. смотрим на ряд фурье:

f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]

где:
n= -inf..+inf
c(n) = 0.5 * sqrt(a(n)^2+b(n)^2)
a(n)=(2/T)* [ integral (f(t)*cos(n*w1*t)*dt) на отрезке [-T, T] ]
b(n)=(2/T)* [ integral (f(t)*sin(n*w1*t)*dt) на отрезке [-T, T] ]
phi(n) = argz(a-i*b)


под суммой стоит куча векторов.
рассмотрим один из них ( при некотором фискированном n):

c(n) * e^(i(n*w1*t+phi(n)))


с точки зрения времени t все остальное внутри это константы тоесть


k1 * e^(i(k2*t+k3))


это вектор длинной k1 который наклонен к оси под углом phi=k2*t+k3 в радианах
поскольку t у нас меняется то угол наклона меняется. 
при изменний времени t вектор будет вращасять по окружности с угловой сокрстью k2.
откуда я это взял. угловая скорсть по опредеднию это d(phi)\dt.
в нашем случае d(phi)\dt=k2.
значит w=k2. 
видим что w независит от рвемнеи. значит угловая скорость константа значит векто
вращается равномено. значит мы помним что k2=n*w1.
w1 - это константа которую мы сами выбираем при создании ряда фурье. 
n - это номер члена под суммой. 
сумма у нас идет для n от минус бесконечности до плюс бесконечности.
значит унас будут n>0 и n<0 значит мы будем иметь w>0 и w<0. 
тут то и появляются отрицательные частоты. и если честно я невижу абсолютно нахуй с ними никаких проблем. знак всего навсего означает в какую сторону вращается вектор.
если w>0 то против часовой если w<0 то по часовой. ну и хуйле тут удивительного ?
вот забудем щас про коплексность. 
возьмем точку на декартойо плоскости. начнем ее вращать по закону
phi=-2*t

теперь вычислим угловую скорстлсть :
d(phi)\dt=-2 
получаем w=-2 
ну и хуйле тут удивительного? еслт w отрицальено это просто означает что тело
врщается по часовой стрелке ну и что?

возьмем функцию обычную:

y=sin (-pi*t)
w=-pi

я считаю что ошиибка состоит в том что 
w!=(2*pi)/T
я считаю что 
|w|=(2*pi)/T=2*pi*V,
V=|w|/(2*pi)

тогда у нас небудет отрицательных периодов и отрицательных частот при отрицательых
w. вот и все.

проверяем. 
T=(2*pi)/|w|=2*pi/pi=2
проверяем

sin(-pi*t)?=sin(-pi*(t+2))=sin (-pi*t-2*pi)=sin(-pi*t)
sin(-pi*t)=sin(-pi*t)
вроде совпало.
значит формула верна что 

T=(2*pi)/|w|
V=|w|/(2*pi)

и нет нахуй никаких отрицатлеьных линейных частот и периоодов.
Отрицательная круговая частота может быть и это абсолютно нормально.


На этом тему волн и компл переменного пока заканчиваю.

Оставшиеся вопросы:
- почему колонки для басов
дооожны иметь  большой диаметр? откуда это берется ?

- понять почему антенна должны быть половина длинны радиволны.
- понять какого размера доожны быть связки голосовые. почему колонки для басов
имеют большой диаметр.
- подумать что такое скорость волны?
- додумать этот момент. w<0 а что с T и V=1\T ?



- на графика мы откладываем не n а n*w1 потому что именно n*w1 это угловая 
частота каждой гармоники. тоесть не n не w1 не являются частотой гармоник
именно n*w1 является частотой очередной гармоники. поэтому на графиках именно n*w1
- ряд фурье в вещественной форме помимо класического вида:
f(t)=a(0)*0.5+summa(a(n)cos(t*w1*n)+b(n)sin(t*w1*n))
имеет и другой более компактный вид:
f(t)=a(0)*0.5+summa ( c(n)*cos(w1*t+phi(n) )
где n=1..inf

я почти уверен что эту формулу можно свернуть в:
f(t)=summa ( c(n)*cos(w1*t+phi(n) )
где n=0..inf

таким образом мне совершенно непонятно чем эта формула хуже чем 
комплккссный вид ряда фурье:
f(t)= summa [  c(n) * e^(i(n*w1*t+phi(n))) ]
n=-inf..+inf

дело в том что на данный момент то что я нашел насчет того что нахера 
вводить комлпексный вид то это было сказано что в комлпксном виде ряд выглядит
более компактно. так вот получается что это чушь. в веественном виде он 
тоже выглядит также. ровно также. 



- как устроены часы. почему много шестеренок?
также - какая аналогия с амплитудами у векторов и шестернями в часах , что у них общего

- так  теперь надо понять откуда берутся отрицательные частоты
что такое частота. это величина обратная к периоду. что такое период. 
это период колебаний. определяется для периодического колебательного 
сигнала. 
это такое минимальное положительное число что f(x)=f(x+T). а частота
это frequency=1\T. Физический смысл частоты это сколько колебаний в секунду
имеет сигнал.
исходя из этого непонятно как вообще может быть отрицательная частота?


- напоминаю что на данный момент мы можем через ряд фурье выражать фнукции
которые периодические. щас мы поймем а как же прдсетставлять через ряд фурье
непериодичекую функцию.?
- так ну фурье это хорошо но нам надо понять на счет тех столбиков из статьи?

- замечу мы пока что рассматриваем функцию периодическую относительно x. 
если x это время то сигнал периодический по времени. 
что делать с сигналом неприодическим пока неясно.




- frequency domain representation - амплитудно частотная характеристика.
состоит из набора частот и амплутуд этих частот.
идея такая что сигнал можно разложить в ряд. 


- baseband
что это такое в вики дается очень мутное определение.
у одного индуса я нашел такое определение - A baseband signal is one which has spectrum from 0 Hz to some fc Hz where fc is the cut off frequency (necessary to have spectrum around 0Hz to qualify for baseband signals).

но сразу упомяну такую штуку - Ethernet protocol, which transfers data using the original baseband signal. In fact, the word "BASE" in "10BASE-T," "100BASE-T," and "1000BASE-T" Ethernet refers to baseband transmission. These Ethernet protocols do not require signal modulation. 

Еще полезняшка по этой теме:
So, summing up, the base band signals modulated with higher frequencies have the following benefits:
More number of baseband signals can be accommodated over a single wire or channel
Signals can be transmitted over long distances without amplifier.
You can also encrypt the communication for privacy and security
Costs much less.
Еще полезнящка: телефонный проводной телефон это пример baseband communication.

baseband сигнал через кабель можно пускать а через радиоканал нет потому что 
антенна на передачу радиосигнала должна быть размером примерно с половину волны.
для волны 20KHz размер волны измеряется километрами. а именно вот формула f = 𝜈 / λ
где f это частота в герцах, 𝜈 это скорость волны. для радиоволны 𝜈 = 3*10^8 m\s
подставляем λ = (3*10^8 m\s)/(20 000 Hz)= 15 000m , тоесть 15км. значит антенна
должна быть 7.5км что нереально для размера антенны.

также полезняшка low pass filter это такой фильтр который пропускает чеерз себя
только частоты ниже какойто. high pass filer это фильтр который пропускает частоты
выше заданной а band pass filter это фильтр который пропускает частоты между f1 и f2.

чем выше частота радиосигнала тем меньше антенна на передачу и прием и тем меньше 
по размеру вся требуха в приемнике. 



- coaxial cable означает кабедь в котором провода лежат на одной линии потому что 
axi это типа ось, а coaxi на одной оси. тоесть токи текут в обоих направлениях
вдоль одной оси.



- типа очен полезная книга по связи:
Modern digital and analog communication by B.P. Lathi


- attenuation. что это . а это attenuation (also known as signal loss).


- infrared излучение. что там за фишки

- фундаментальный вопрос ( я там ниже рассмотрел что такое цифровой и аналоговый сигнал).
так вот вопрос как генерируется цифровой сигнал. так как в природе обычно все величины аналоговые (кроме квантового мира где есть четко дифференцированные фискированные квантовые состояния) а будем даже более конкретными в электрическом мире мире напряжения и силы тока
мы неможем сгененировать скажем первую секунду 100% U=5V а потом вторую секунду U=0V.
окей если 0V мы еще можем сделать то мы неможем обеспечить 100% 5V он будет все равно меняться
и плавать в течение этой секунды. тоесть он все равно будет аналоговый так как же генерируется
цифровой сигнал?


- balanced cable

- непонятно вот у нас есть несколько разьемов на плате (пусть будет 4) под SATA провод. каждый разьем ведет к одному диску. вопрос сколько контроллеров SATA на плате четыре или один.
далее было сказано что SATA AHCI имеет одну очередь на 32 запроса. вопрос это 
на все четыре диска или на каждый диск своя очередь.
- надо переходить от SATA к AHCI SATA  а потом к NVME 
- NVME очереди (65 535 очередей с глубиной 65 535 команд)


- analogues signal vs digital signal
analogues означает аналогичный,  чтото аналогичное чемто другому.
что такое сигнал - согласно вики это некая величина чегонибудь (масса, напряжение, величина светового потока,величина тока, положение рук регулировщика) которая для наблюдателя (кудаж без него) меняется во времени и\или в пространстве. итак именно некая величина+время+наблюдатель образуют сигнал.
если честно я чтото непредставляю
что за сигнал который неменяется во времени но меняется в пространстве. если величина
меняется во времени тут вопросов нет что это сигнал. например фонарь был темный стал светлый. 
это сигнал. летающая тарелка ее координата она поменялась во времени это сигнал. светофор
погас зеленый и в другом месте пронстранства загорелся красный - поменялся и во времени в 
пространстве тоже сигнал. непонимаю какой пример сигнала (некоторая величина) которая неменяется во времени но меняется в пространсве. все таки по мне это величина меняющаяся
во времени. 
насколко я понимаю когдамы говорим про сигнал - значит должен быть генератор сигнала
его источник, должен быть носитель сигнала , должна быть некая величина которая переносится в этом носителе, и должен быть приемник сигнала и должен быть наблюдатель сигнала.
переходим к электрическим сигналам. величина наблюдаемая тут это либо ток 
либо напряжение. аналоговый сигнал( как я понял ) что это означает - вот мы начали мерять сигнал и снимаем с прибора величину с некоторым шагом например снимаем виличину напряжения каждую секунду. меряли 10 секунд. получили 10 величин. потом мы повторяем сигнал и меряем
его опять 10 секунд но уже каждые пол секунды получим 20 величин. потом мы повтоярем сигнал
и меряем его каждую треть секунды получили 30 величина. далее мы возьмем полученные 10 величин и выкинем из них все повторяющиеся получим множества A. потом возьмем 20 величин и выкинем из них повторяющиеся получим множество B, 
потом возьмем 30 величин и выкинем повтоярющиеся получим множество C, так вот
если сигнал аналоговый то множество C будет больше чем множество B а оно бльше чем множество A.
и чем чаще мы будем снимать сигнал и выкидываь из полученного множества дубли тем суммарное
множество будет больше ( вштуках) чем прердыдущее множество которое было получено путем фиксации сигнала при большем интервале времени. хотя максимум и минимум сигнала конечные
но на отрезке времени количество велиичин сигнала бесконечно какой бы маленький шаг 
фиксации величины мы бы ни взяли. на него непохож цифровой сигнал - если мы возьмем отрезок времени то мы можем найти такой минимальный шаг фиксации величин сигнала что при уменьшении времени снятия сигнала (другими словами при увечличении частоты фиксации сигнала) мы будем получать одно и тоже множество величина сигнала (после того как мы выкинем из него дубликаты.)
пример аналогового сигнала и цифрого:
положим что вольты в проводе меняются по закону U=t
будем фиксировать вольты первые 2 секунды.
вначале инетрвал фиксации 1 секунда.
U(1)=1
U(2)=2

дублей нету. значит наше множество это {1,2}

далее фикируем каждые 0.5 секунды
U(0.5)=0.5
U(1)=1
U(1.5)=1.5
U(2)=2
дублей нету. конечное множество {0.5, 1, 1.5, 2}
фиксируем сигнал каждые 0.1с множствео будет {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, ... 2}
так вот видно что чем чаще мы снимаем сигнал тем множстве значений растет растет и растет 
и при любой частоте снятия сигнала мы можем взять еще более частое снятие сигнала и множество
будет еще больше. это аналоговый сигнал. множество значений увеличивается до бесконечности
при уменьшении времени снятия сигнала ( даже после выкидывания дублей . хотя в данном случае дублей просто нет).
цифровой сигнал.
положим что сигнал вот по такому закону генерируется
U=1(при t=[0,1) )
U=0(при t=[1,2] )

снимаем сигнал каждые 0.5с
U(0.5)=1
U(1)=0
U(1.5)=0
U(2)=0

выкидываем дубли(это важно выкидывать дубли) получем множество {1,0}

снимаем сигнал каждые 0.25с
U(0.25)=1
U(0.5)=1
U(0.75)=1
U(1)=0
U(1.25)=0
U(1.5)=0
U(1.75)=0
U(2)=0

выкидываем дубли получаем ножество {1,0}

так вот что более часто сигнал снимать нет смысла. какой бы мы ни взяли шаг еще меьше
после выкидыаний дублей мы получим все тоже множество {1,0} 
это и показыает нам что сигнал цифровой.

еще раз аналоговый сигнал - чем чаще мы снимаем его значение (на одном и том же конечном
промежутке времени) и потом выкидываем дубли то полученное множество будет все расти и расти
и расти оно будет бесконечно при уменьшении шага снятия величины.
цифровой сигнал - его множество значений не растет бесконечно (после выкидываений дублей) при уменьшении шага фиксации величины сигнала. начиная с определенного шага  фиксации величины сигнала S0 полученное множество значений (после выыкидываний дублей) будет одно и тоже для любого сколь угодно малого S1<S0.
Обычно в природе величины(сигналы) являются аналоговыми. например температура 
у тела имеет аналоговый характер. цифровой же сигнал обычно искусственным образом создается генерируется людьми. 
амплитудная модуляция я узнал как она выглядит через математику. если 
низкоачастотный сигнал это y1=f(t) и если у нас высокочастотный носитель это y2=A*Sin(bt)
то амплитудная модуляция выглядит как y3=f(t)*Sin(bt).



- а ethernet 100 он тоже исплзует differential signaling ?
из того что я прочитал нет. эзернет НЕиспользует differential signaling.
у них в одну сторону используется пара проводов и в другую сторогу использутеся пара проводов.
итак еще раз в SATA в одну сторону исползуется 4 провода.  а в ethenet 100 в одну сторону
исползуется 2 провода. кручение кабеля испольуется для того чтобы защититться от влияния
одного кабеля на другой. оно тем больше чем длиннее кабели а скрутка это убирает. от внешнего 
влияния из вне скртка никак не помогает. получается что  SATA каелбелть он короткий скажем 1метр. на такой длинне влияние одного провода на другой видимо еще маленькое ( потому что я читал что чем длинее провода тем они в в коце друг на другна сильнее влиятют) а более 
влияет помехи снаружи. поэтому satat не скручивают зато используют differential signaling.
ethernet же прводо длинной 100метров поэтому влияне одного проводоника на другой уже
на такой длинне накапливается и провод крутят . скорость у satat 600MB\s а у эзернет
10MB\s и поэтому видимо у него неиспользуют differential signaling тоеть небоятться внешних 
помех.  ятолько в одной сттье нащел что 10Gb ethernet использует differential signaling
 

- амплитудная модуляция. это когда унас есть какойто высокочастотоный сигнал (радиоволна)
и мы меняем у него амплитуду так что если мы соединим линией все его амплитудные точки
то получим волну низкочастотную котору мы и хотели закодировать через этот выскочастотоный сигнал ( картирнка https://en.wikipedia.org/wiki/File:Amfm3-en-de.gif)
еще  я непонял вот что. если мы возьмем наш низкочастоный сигнал разложим его в ряд фурье
тоесть представим наш сигнал как сумму синусоид с индивидуальными амплитудами то мы получим некоторый спектр. это понятно. ксатии вобще то ряд фурье он для периодических функций
а если непериодическая? ну как я понял тогда берем кусок функции и потом ее как то там продолжаем и вот для нее строится ряд фурье и он на заданном куске совпадает с с функцией.
так вот ( как я понял) если мы возьмем наш промодулированный сигнал (тоесть  выскочастотный несущий синал который по амплитуде промудирован низкочастостным сигналом ) возьмем кусок
этого сигнала ибо он же нерегулярный поэтому как я понял для всего сигнала построить 
ряд фурье вот так единой формулой нельзя. поэтому мы берем кусок сигнала потом хитро его там
продолжаем (как написано в вики) и строим для него ряд фурье который на заданном куске 
совпадает с сигналом так вот утверждается что промудулироваронный сигнал в виде ряда фурье
будет иметь спектр в два раза шире чем спектр исходного низкочастоного сигнала на данном куске. хотя чисто интуитивно мне непонятно то что промодулированный сигнал имеет в себе 
всего одну частоту (ту самую высокочастотную) изменилась всего лишь амплиутда то там то здесь
непонятно как это может влиять на появление новых частот в интеграел фурье. но тем не менее надо двигать дальше.
далее такая хрень еще встречается как baseband bandwidth и passband bandwidth.
и тут я тоже замучался разбираться и неразобрался. 




- почему у коаксиала гораздо выше и экранирование и полоса пропускания чем у витой
пары а скорость передачи данных цифровых гораздо ниже чем у витой пары. я вот думал 
что коаксимал неиспользуют только потмоу что его дороже исзготавливать и он гораздо
хуже монтировать. (типа его нельзя гнуть и так далее). так что если забыть что его метр
стоит дороже и что его монтировать недоубно мне непонятно почему его цифровая скорость 
ниже чем у витой пары что за фигня. 
- baseband bandwidth vs passband bandwidth  vs broadband
я всегда часто думал что эти фразы больше как маркетинговый булшит а оказывается
они имеют типа рельный смысл. 

- alexanderson alternator
- электронные лампы. как работают в чем фишка
- как максимально простыми методами можно генерировать радио волны
- катушка румкорфа она юзается при генерации искры. как она работает
- как передается сигнал в проводах через меняющийся ток или меняющееся напряжение
и как это ловят на том конце
- в чем фишка коаксиального кабеля почему он такой и для чего
- в чем фишка витой пары почему она такая и для чего
- сигнал передается через дергание Вольтов? и это породжает дергающийся ток или что?
- почему в sata разьеме 7 пинов а в проводе всего 4 провода
- рассссмотрим SATA диск ( с AHCI и без) и путь от него байта до цпу










главный вопрос как найти число очередей на своем nvme диске.
как на sysfs посмотреть число hardware queues о которых выше написано
get-feature:0x7 (Number of Queues), Current value:0x0f00g0f
	Number of IO Completion Queues Allocated (NCQA): 16
	Number of IO Submission Queues Allocated (NSQA): 16
что такое AHCI как он отличается от sata
когда идет ahci то как там идет связь между диском и цпу
nvme это через какой интерфейс и какую шину оно втыкается. как идет связь
между цпу и диском.

нашел в pdf от сигейта(у кингстона тоже самое написано) что AHCI(контроллер наверно) имеет только один command queue с глубиной depth на 32 команды. а nvme (диск наверно контроллера то нет ) может иметь до 65 535 command queue с глубиной depth команд до 65 535.
в чем разница между AHCI и NVME интерфейсом (из той же брошюры сигейта) - когда у нас

==================================================================================



- как выглядит прочесть 1 байт из файла на ассемблере? куда ядро сует ответ с диска процессу ?

- block devices vs character devices?
разница вроде бы в том что из character device можно читать и писать но тупо напрямую в 
/dev/name но нельзя задать какойто поиск какойто сдвиг. либо читаешь то что есть 
либо пишешь туда напрямую. а у block  device можно задать некий offset и данные будут
записаны\считаны изнутри кишок где то там начиная с offset.
еще такая добавка что якобы FreeBSD doesn’t use block devices at all.


- bfq, linux i\o scheduler ?

- 165.pdf стр 8 ?


- $ dd if=/dev/zero of=/dev/null bs=514 count=1
вот инеерсено заупускаю я эту команду. диск у нас 512байт сектор.
на стороне юезоер спейса будет написано что была только запись а вот на стороне
ядра и доно быьт и чтение и запись чего конечно небудет видно из юзер спейса через iostat
но должно быть в итоге идно по перфомансу конечному на диске.
как бы проверить?

- 
$ lsblk -o  NAME,ALIGNMENT,MIN-IO,OPT-IO,PHY-SEC,LOG-SEC  /dev/nvme0n1
NAME       1MENT MIN-IO OPT-IO 12КБSEC
запускается ядро и сисколл берет наши 12КБ данных и смотрит а какой размер блока на фс. 
ага 4КБ. он режет наши 12КБ на три куска
nvme0n1             0    512    512     512    
 512
├─nvme0n1p1         0    512    512     512     512
└─nvme0n1p2         0    512    512     512     512



- фс блоки. это внутренняя кухня  внутри драйвера фс или наружу тоже както 
это выставляется для внешних потребителей? тоесть непонятно нам то внешнему потребителю 
какая разница на эти блоки нахер это нам дает? мы хотим записать считать файл и только то.
какое нам дело до этих блоков ?


- https://www.opennet.ru/base/sys/info_diag_tools.txt.html


==================

| truncate
| ext
| architecture
| fallocate
| sparse

| truncate
| ext
| inode 
| ext2
| ext4

тема изначально возникла вот откуда - на приудурошных собеседованиях 
любят задавать вопрос. вот закончилось место на диске. выяснялется что 
некий лог файл все засрал. как освободить место. приложение которое пишет 
в лог перезгружать нельзя.

решение  - использовать команду truncate.

#  truncate -s 10M имя_файла

и она на лету вырежет\освободит\удалит у него дата блоки и файл станет заданного размера

еще вернемся к truncate.

поговорим про EXT2 ее устройство.
без этого нам много чего непонять про truncate

далее внизу я использую слово блок. так вот
фс работает не с блоками диска тоесть секторами. фс работает
со своими собственными фс блоками. поэтому внизу если я говорю block
это значит фс блок а не физ диск сектор.

ext2 разбивает диск на блоки размером 1KB либо 2KB либо 4KB.
и фс оперрирует этими блоками. (источник https://www.landley.net/code/toybox/doc/ext2.html)
весь диск разбивается непросто на фс блокаи а на группы блоков.
группа блоков включает в себя то количество блоков сколько может в себя вместить 
bitmap блоков вмещающийся в один фс блок. тоесть - во первых что такое битмап.
у нас есть какито сущности например блоки фс и мы хотим закодировать на уровне 
1 бита информацию о том что один блок на фс имеет какое то свойствао нпример то что
блок используется или он свободен от использования. получается ест у нас скажем 10 блоков
на ФС. и мы берем и начинаем с помощью битов кодировать свободен блок фс или используется
это буде выглядеть так 1101010001 . полуили 10 бит. это битмап.
далее если  унас блок ФС имеет размер 1КБ (тоесть 1024 байта тоесть это 1024*8=8192 бита
то) то мы с помощью этого 1КБ может на уровне битом(битмап) можем закодирвать состояние
8192 блока ФС. таким образом теперь понять почему если у нас размер блока ФС = 1КБ
то логично группировать блоки ФС в количестве 8912 блока в одну группу. и тогда битмап
какогто свойства этих блоков будет влезать ровно в 1 блок ФС. что красиво. 
поэтому понятно что если размер блока ФС = 4КБ то  при таком выборе размера блока при форматировании ФС все блки будут разбиты на группы размером 4096*8=32768 блоков на группу.
а битмап этой группы будет влезать водин  блок ФС размером 4КБ.

посмотреть размер блока ФС можно через

# dumpe2fs /dev/sdb1 -h | grep "Block size"
dumpe2fs 1.46.5 (30-Dec-2021)
Block size:               4096

поэтому я ниже когда пишу что размер блока = 4КБ то я там ошибочно думал
что мы говорим про размер сектора на физ диске. а мы на самом деле
говорим про размер блока ФС.вообще же на самом деле документация херня
там бывает намешаны и фс блоки и физ диска блоки. и хер поймешь какой они 
имеют ввиду.

например в доке(https://www.nongnu.org/ext2-doc/ext2.html#i-block) написано
Note: the 2TiB file size is limited by the i_blocks value in the inode which indicates the number of 512-bytes sector rather than the actual number of ext2 blocks allocated.

а потом в другой доке нарисано что потом это исправили и уже в i_block
испоьзуют не физ сектора диска а фс блок. и поэтому ограничение 4ТБ на размерфайла
при размере фс блока 4К.
пздец





тот же dumpe2fs покажет и все группы блоков. например

Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-128
  Block bitmap at 129 (+129)
  Inode bitmap at 130 (+130)
  Inode table at 131-640 (+131)
  32120 free blocks, 8148 free inodes, 2 directories
  Free blocks: 647-1023, 1025-32767
  Free inodes: 13-8160

видно что так как у нас размер блока ФС 4К то 
количество блоков в группе 32768

двигаем дальше

я вот читаю вот этот источник ( https://www.nongnu.org/ext2-doc/ext2.html#i-block)
там есть таблицы "Table 2.1. Impact of Block Sizes"

там написано что нважно какого размера блок ФС выбран 1К\2К\4К\8K
во всех случаях максимальное число блоков ФС может  быть 2147483647
я решил проверть асолько  в двоичном формате это число составляет

echo "obase=2;ibase=10; 2147483647" | bc  | awk '{print length}'
31

оказалось 31 бит. вот тут я непонимаю почему 31 бит а не 32 бита.
и вот в той таблице указано что число фс блоков макимальное число это 2147483647
. при размере фс блока 4К они пишут что размер файловой системы будет 16TB.
откуда???  если мы умножим число блоков фс 2147483647 на 4КБ то мы получаем 8ТБ,
откуда они берут 16ТБ?
вобщем эта табица походу устарела.
ясно другое - если мы форматируем ext2 (ext4) то чем больший размер ФС блока мы выберем
тем у нас ограничение на макс размер файла будет больше и на макс размер партишена тоже 
будет больше.

далее. 
про битмапы я нашел что они кодируют - Each bit represent the current state of a block within that block group, where 1 means “used” and 0 “free/available”.



далее
поговорим о том как ext например для простоты ext2 хранит файлы у себя.
файл состоит из тела где собственно хранятся данные и из обертки служебной
информации тоесть из метаданных.

по моим понятиям файл состоит из трех частей на фс. 
первая часть это его тело , его дата блоки. 
вторая часть это инода - это спец область на фс где хранятся метаданные об этом файле.
какие именно щас покажу. 
и третья часть это область где хранится список блоков от тела файла.потому что тело
файла хранися в каких то блоках но нам же надо где то держать этот список блоков.
важно отметить что если файл по размеру маленкий то список его блоков хранися внутри иноды.
а если он больше такогто размера то этот список он хранится уже вне иноды. это важно.
потому что эти суки везде пишу что в иноде хранятся все метаданные. это брехня.
для большого файла список блоков его тела хранится вне иноды.
есть и еще одна часть от файла это его имя. имя файла нехранися внутри иноды.
оно хранися внутри иноды которая отвечает за папку. в папке указано буквенное имя файла
и ссылка на иноду файла.
таким оббразом файл по составным частям разбросан по нескольким структурам.

еще раз отмечу важную вещь что если файл больше такогото размера то список его блоков
нехранится в иноде. он хранится отдельно  в другом месте. это важно понимать.

итак тело файла хранится в дата блоках.
почти все метаданные о файле хранятся в иноде. инода одна на файл.
ифомрация в каких блоках лежит тело файла чучуть ханится в иноде а остальное вне иноды
в отдельно месте. как оно назыается хрен знает
название файла хранися отдельно в папке.

откуда берутся иноды. они создаются на момент форматирования раздела. общее количство
блоков делится на "block groups".и внутри каждой группы блоков создается каоето количество
инодов. инода изначально была 128 байт длинной. щас по момему она имеет вариативный размер.
я пока незнаю инода которая внутри группы блоков она только эту группу блоков обслуживает
или вобще ей пофиг. как я понялр изначально иноды все пустые внутри.

теперь интерсный вопрос о том как фс напримере ext2 хранит информаци о блоках в которых
лежит тело файла. для маленького файла эта инфо хранися внутри иноды.
в иноде есть 12 полей поле по омему раньше было 32 бита длинной а щас вроде бы 64 бита
длинной или 48.  каждое поле содержит в себе номер блока в котором лежит кусочек тела
файла. размер блока это физ размер сектора на диске как я понял тоесть это 4KB.
получется что если  у нас 12 указателй на 12 блоков по 4КБ то значит можно таким макаром
опимсать тело файла размером 12*4КБ=48КБ
если тело файла более длинное то есть 13-е поле в иноде но оно указывает не на блок 
в котором лежит тело файла а на некоторый другой блок и уже этот  "другой блок" содержит 
в себе адрес блока в котором лежит тело файла. и за этим "другим блоком" соседние блоки 
каждый из них содержит в себе адрес блока на диске где лежит тело файла. количество 
этих других блоков раавно 1024 штуки. 13-е поле в иноде указывает на первый такой "другой блок".
получается что с помощью 1024 штуки * 4КБ = 4МБ. тоесть таким макаром мы уже можем
сохрнаить список блоков для файла размером 48КБ+4МБ.
а что если файл его тело еще длинее. тогда вступает в бой 14-е поле в иноде.
оно указывает на группу блоков в количестве 1024 штуки каждый из которых указывает на
группу из 1024 штук. каждый уже из которых несет в себе адрес блока в котором лежит тело
файла. тогда 1024*1024*4 = 4 GiB тогда мы уже получается можем хранить список блоков
файла размером 48КБ+4МБ+4ГБ. ну файл размером больше 4ГБ это не редкость. как тогда.
тогда вступает в бой последнее 15-поле в иноде. оно уже имеет три степени вложенности.
оно указыавает на таблицу из 1024 блоков каждый из которых укзывает на таблицу из 1024 блоков
каждый из которых уукаызвает на таблицу из 1024 блоков  каждый из которых несет  в себе
адрес блока на диске с телом файла. это нам дает возможность храниться инфо о файле размером
4ТБ. 
прикинем если диск размером 40ТБ и у него блок 4КБ. значит такой диск
имеет  число секторов = 10,737,418,240  в двоичном виде это 
10,10000000,00000000,00000000,00000000 
это получается 36 бит. по моему бывает либо 32bit lba либо 48 бит lba.
48 бит это 6 байт. значит по идее одно поле в иноде должно быть длинной 6 байт.

получается если файл длинной 4ГБ то у него секторов ~ 1 000  000 получается чтобы 
эти все сектора запомнить то нужно   6байт * 1 000 000 = 6 000 000 байт = 5.7MB
на жестком диске. а ну это норм. 5.7MB накладных расходов для файла размером 4GB 
это норм. 

далее как я понял например на ext4  там не описывают каждый блок на диске содержащий
тело файла это накладно все равно. вместо этого скажем фс знает что тело файла сохранено
на диске непрерывнми кусками. скажем в блоках с 10,000-20,000 и 30,000-40,000
эти непрервыные с точки зрения адресации блоков куски где хранится тело файла называются
экстентами (extent) так вот когда мы храним инфо в экстертах нам нет смысла 
описывать кажый блок в коттором лежит тело файла. нам выгоднее экономнее описать 
первый блок в эксптенте и его длинну. потом следущий первый блок в следущем экстенте
и его длинну. как я понял что ext4 уже так делает.

как я понял когда файла удаляется на фс то просто напросто у него обнуляется его инода.

как называется группа блоков в которых записаны ссылки на блоки либо экстенты тела файла
я пока незнаю.


покажу какая инфо хранится в иноде
берем файл

1# stat txt1
  File: txt1
  Size: 10          Blocks: 8          IO Block: 4096   regular file
Device: 811h/2065d  Inode: 12          Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2023-07-05 19:16:36.925297134 +0000
Modify: 2023-07-05 19:17:03.775173524 +0000
Change: 2023-07-05 19:17:03.775173524 +0000
 Birth: 2023-07-05 19:16:36.925297134 +0000


видим что за файл отвечает inode=12
что тело файла занимает 8 дата блоков

ставим вот такой пакет
# apt-get -y install  sleuthkit
тгда можем наконец посмотреть содержимое иноды

# istat /dev/sdb1 12
inode: 12
Allocated
Group: 0
Generation Id: 1265727633
uid / gid: 0 / 0
mode: rrw-r--r--
size: 10
num of links: 1

Inode Times:
Accessed:   2023-07-05 19:16:36 (UTC)
File Modified:  2023-07-05 19:17:03 (UTC)
Inode Modified: 2023-07-05 19:17:03 (UTC)

Direct Blocks:
1024 


видим что в иноде прописыаются: владелец, права доступа, размер, и 
последня строка это блоки в которых лежит тело

Direct Blocks:
1024 


итак нахер нам нужна инода. в ней написано в каких блоках надо искать само собственно
тело файла, владелец, права доступа, размер.

инода похожа на каталог в библиотеке только мы ищем не книгу на полке а библиотека
имеет 1 000 000 000 ящичков. в кажом лежит листочек. так вот книгу можно прочиать тлько 
бегая с каталогом открывая нужные ящички и читая оттуда очередной листочек. вот что такое инода.

структура иноды = https://www.nongnu.org/ext2-doc/ext2.html#inode-table

я попытался руками найти иноду на диске чтобы ее можно было прочитать ее 
напрямую чтоб убедиться воочию в ее составе особенно в ее строках по адресам
блоков  в которых хранится тело файла. но найти иноду где она лежит на диске
на вскидку не понятно как. поэтому я юзаю istat

вопросы почему при размере блока ФС 4КБ у нас количество 
индирект блоков равно 1024.
дума что здесь логика такая. если у нас например блок фс на диске идентифициурется
через 32битное число. это 4 байта. вопрос сколько таких 4 байтовых идентификаторов
помещается в одном ФС размером 4КБ. поссчитаем 4096 / 4 = 1024 штуки.
получается что в одном ФС размером 4КБ мы можем разместить 1024 идентификатора блоков ФС
получается что  наш 13-ый параметр в иноде который ссылается на массив из блоков ФС индирект
он в итоге ссылаетс всего навсего на 1 ФС блок. тоесть нужно прочитать всего один ФС блок
на который ссылается 13-ый параметр иноды и мы сразу узнаем все блоки ФС в которых находится
тело файла. тоесть я говорю что first level indirect block array это всего навсего 1 ФС 
блок на диске на который ссылается 13-ое поле в иноде котрое относится к опианию тела файла.

далее получается что двухслойный arrays indirect блоков выглядит так  :
14-е поле в иноде ссылается на всего навсего 1 блок ФС на диске. а там  каждые 4 байта (коих 1024) ссылаются еще на один фс блок на диске. поэтому  двухслоаная структура предстаялет собой в итоге 1 блок на диске + 1024 блока на диске


еше раз разжую эту тему подробно.
пусть у нас на ФС размер блока ФС = 4КБ.
в иноде есть 15 полей которые описыывают где искать тело файла на ФС. в каких ФС блоках
его искать.

первое поле содержит в себе идентификатор первого ФС блока тела файла.
длинна идентификатора задающего номер ФС блока состаоялет 4 байта (32бита).
второе поле , третье поле. и тд двенадцатое поле каждй из них содержит номер блока 
в котором сидит часть тела файла. (ещераз скажу что номер блока ФС имеет длину 4 байта).

получается что если файл имеет разме 48КБ  и размер ФС блока 4КБ то файл занимает на диске его тело 48КБ\4КБ = 12 ФС блоков. поэтому номера этих блоков умещаются в двенадцати полях иноды.

а что делать если размер файла больше чем 48КБ.
в дело вступает 13-е поле иноды которое тоже кодирует тело файла для файлов большей 
длиныы. но делает это особым образом.  13-е поле ссылается на один блок ФС который находится вне иноды в котором закодировано 1024 номеров блоков ФС где находится тело файла.
еще раз повторю 13-ое поле иноды оно не содержит в себе номер блока в котором лежит
очередной кусок тела файла. 13-е поле ссылкается на некий блок на ФС который несодержит в себе
тело фала а содержит служеюную информацию которая невлезает в иноду. этот ФС блок содержит 
в себе информацию о 1024 номерах блоков где сидит тело файла. итак один блок ФС в себе
кодирует информацию о 1024 блоках ФС где сидит тело файла. почему так. 
потому что номер блока ФС кодируется четырься байтами. если размер блока ФС равен 4КБ то 
в 4КБ влазиит 1024 штуки по 4 байта. 

1024 номера блока ФС * размер блока ФС (4КБ) = нам дает взможность кодировать тело файла
длинной 4МБ.

если длинна файла больше чем 48КБ+4МБ то вступает в дело 14-ое поле иноды
оно ссылается на блок на ФС который в себе содержит кодирует инфо о 1024 блоках на фс 
и каждый из этих 1024  блоков ссылается на некий блок на ФС каждый из которых содержит 
1024 номера блока на ФС уже где находится тело файла. полуается такая хрень может 
нам закодирвать список блоков на ФС размером

1024*1024*4КБ = 4ГБ.

15-е поле содежит три степеи вложенности
1024*1024*1024*4KB = 4TB размер тела файла так можно закодирвать.

итого если у нас на ФС при форматировании выбран блок ФС размером 4КБ
то максимльный размр файла на таком разделе будет 48КБ+4МБ+4ГБ+4ТБ
я так понимаю.

а вот для примера как выглдяит вся эта шарманка если у нас при формативоании выбран блок ФС размером 1КБ.

первые 12 полей в иноде закодируют тело файла размером

12*1KB = 12KB.

13-е поле закодирует тело файла длинной вот какой - 13-е поле ссылается на один блок на ФС.
он у нас длинной 1КБ. в него влезает 1024Б/4Б = 256 штук номеров ФС.

поэтому 13-е поле позволяет закодировать тело файла размером 256 номеров блокнов ФС * 
размер одного блока ФС (1КБ) = 256КБ

14-е поле в себе может закодировать такое количество номеров блоков что по размеру
они кодируеют файл длинной:
256*256*1KB = 64MB

15-е поле позвролит закодировать такое колчество номеров блоков ФС что суммарно 
по обьему это будет:
256*256*256*1KB=16GB
получаетс по моим расчетам если ФС имеет размер блока 1КБ
то макс размер файла будет 16GB+64MB+256KB+12KB

 впринципе я тоже самое нашел здесь = https://www.nongnu.org/ext2-doc/ext2.html#i-block
 цитирую
 The 14th entry in this array is the block number of the first doubly-indirect block; which is a block containing an array of indirect block IDs, with each of those indirect blocks containing an array of blocks containing the data. In a 1KiB block size, there would be 256 indirect blocks per doubly-indirect block, with 256 direct blocks per indirect block for a total of 65536 blocks per doubly-indirect block.

The 15th entry in this array is the block number of the triply-indirect block; which is a block containing an array of doubly-indrect block IDs, with each of those doubly-indrect block containing an array of indrect block, and each of those indirect block containing an array of direct block. In a 1KiB file system, this would be a total of 16777216 blocks per triply-indirect block.


возвращаясь к truncate - походу он как работает - он в таблицах в которых прописаны 
блоки с телом файла  - он там просто удаляет записи о блоках , таким образом файл
лишается части своего тела.  и место на диске (блоки) освобождаюся.


далее следущий момент - когда мы отркваем файл на запись то мы линуксу говорим о том
как мы хотиим писать в файл. первый вариант это мы хотим писать так что данные будут 
записываться в линукс page cache а уже потом когда то линукс их будет сбрасывать на диск,
например это будет происходить когда мы будем закрывать дескриптор файла.
в чем прикол этого метода - в том что наша программа будет писать данные но если 
при этом мы будем запрашивать информацию о файле через #stat то нам будет возвращаться
что размер файла не меняется. второй вариант мы при открытии файла на запист говорим
линуксу что мы не хотим пользоваться пейлж кешем мы хотим чтобы при запист в декскриптор
данные сразу лились на диск. тогда при запси в дескриптор если мы запросим статистику
по файлу чеерез #stat то мы будем видеть что действительно размер файла растет.
еще раз скажу что если пользоваться пейдж кешем то размер файла на диске вырастет 
только тогда когда когда мы в нашей программе закроем дескриптор. потому что до этого данные
просто будут литься в кэш в оперативке а на диске ничего меняться не будет. 

получется очень интересна и непонятная ситуация. 

далее я выяснил еще один непонятный и ебанутый момент.
я взял создал файл с изначлаьным контентом.  я его открыл на запись на добавление в хвост (append) далее я начинаю туда писать при этом я незакрывают файловый дескриптом
после записи.  и я паралельно из этого же процесса читаю содержимое файла. 
пишу я в файл через питон.  по  дефолту запись идет в режме page cache тоесть данные 
льются не на диск а в оперативку. так вот прикол в том что при попытке чтения из 
того же самого процесса я нихуя невижу данные которые записал. линукс возвраащает 
только тот контент который был в файле на момент его открытия.


# cat p1.py 
#!/usr/bin/python2

import time
from datetime import datetime



f = open("demo.txt", "a")



while True:
  time.sleep(1)
  now = datetime.now()
  print ("===========")
  print ("write to file => date=%s") % (now)
  f.write(repr(now))
  print ("===========")


  print ("read from file :")
  f2 = open("demo.txt", "r")
  print(f2.read())
  f2.close()




f.close()




запускаем смотрим

# ./p1.py 
===========
write to file => date=2023-07-06 14:23:14.611576
===========
read from file :
Initial content!

===========
write to file => date=2023-07-06 14:23:15.613440
===========
read from file :
Initial content!

===========
write to file => date=2023-07-06 14:23:16.616518
===========
read from file :
Initial content!

===========
write to file => date=2023-07-06 14:23:17.618961
===========
read from file :
Initial content!



строка  "Initial content!" это то что было в файле на момент его открытия в питоне.
поразительная вещь. тот же самый процесс который пишет в файл а по факту линукс данные
пихает в пейж кеш не может увидть свои же записанные данные. 
при чтении мы видим только изначалльное содрежимое файла.
это пиздец какойто.  получаеся что после каждой операции записи по крайней из пиитона
надо закрывать файловый дескритор. только тогда данные попадут на диск и только тогда
мы их увидим при чтении.

я также невижу новые данные если буду пытатся читать файл из какогто внешнего процесса.


как видно из скрита  я открываю файл через

f = open("demo.txt", "a")

вместо режима "a" можно указать какие конерктные флаги я хочу юзать при 
открытии файла.

их целая прорва
os.O_RDONLY − open for reading only

os.O_WRONLY − open for writing only

os.O_RDWR − open for reading and writing

os.O_NONBLOCK − do not block on open

os.O_APPEND − append on each write

os.O_CREAT − create file if it does not exist

os.O_TRUNC − truncate size to 0

os.O_EXCL − error if create and file exists

os.O_SHLOCK − atomically obtain a shared lock

os.O_EXLOCK − atomically obtain an exclusive lock

os.O_DIRECT − eliminate or reduce cache effects

os.O_FSYNC − synchronous writes

os.O_NOFOLLOW − do not follow symlinks


тоесть "a" это предустановленный режим. а вот если руками открывать файл 
то тогда например вот так

fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT )

 я проверил когда в питоне я задаю режим "a"
 то по факту в линуксе отарбаывает сисколл вида

 openat(AT_FDCWD, "demofile2.txt", O_WRONLY|O_CREAT|O_APPEND, 0666) = 3

 тоесть используется три флага
 O_WRONLY|O_CREAT|O_APPEND

 по мне в целом это какйто пиздец. мы открыли файл на запись (append) скажем логер 
 какйони будь линукса или мускула .
 если при записи строки в лог он незакрывает файл то по идее мы в файле нихкя не увидим
 данные будут висеть в пейдж кеш и для нас они будут невидимы.

 можно конечно октывать файл на запис с флагами O_Direct или O_FSYNC
 тоогда при каждой записи у нас данные не будут попадать в пейдж кеш
 а будут лететь сразу на диск и закрывать дескриптор файловый нам для этго ненадо.

 кстати хуй поймешь в чем разница этих двух флагов. судя по стековефлоу народ 
 сам мало понимает. как я прмиерно понял что флаг O_DIRECT говорт линуксу 
 чтобы он сразу писал на диск а не пихал в пейдж кеш.
 а флаг O_FSYNC говорт что надо записть в пейж кеш и тутже синкнуть на диск.
 вобщем малопонятная мудота.в чем прикол в чем разница.


 поэтому вопрос  о том что мы пишем на диск из процесса и видит ли эти изменения этот же 
 процесс или другой   - это еще больощой вопрос. если данные льются в пейдж кеш 
 то нихуя их никто не видит. ни чужой процесс ни даже тот же процесс что льет эти 
 данные. 


 вот пример питона кода мы пишем в файл  юзая флаг O_DIRECT
прр этом надо дполнительно изьебнутся

 #!/usr/bin/python

import os, sys, mmap

# Open a file
fd = os.open( "foo.txt", os.O_RDWR|os.O_CREAT|os.O_DIRECT)
m = mmap.mmap(-1, 1024)
s = ' ' * 1024
m.write(s)
# Write one string
os.write(fd, m)
# Close opened file
os.close( fd )


кстати в том списке флагов много всяких интересных непонятных например
os.O_EXLOCK − atomically obtain an exclusive lock
что это значит?
если честно то заебешься разбираться. нет на это время щас.


я нашел в инете вот еще такой пример. если у нас открыт файл и он исполгяется
а мы полезем его править то лиукнс пошлет на хуй.

тоесть

# cp /usr/bin/bash /tmp/bash1
запусксем 
# /tmp/bash1

пытаемся его изменить из другой консоли
# echo "1212" >> /tmp/bash1
bash: ./bash1: Text file busy

но при этом якобы "удалить" его конечно же можно. 
по мне вот эта проблема с мнимым удалением файла из фс это просто пизец 
 в линуксе. тоесть инода от файла не вычищается а правится инода папки в которой
 этот файл был прописан. ну что за ебанаты. не могли нормально дописать что
 нельзя удалять запись о файле из папки если на данный момент есть десприкторы
 отыкрытые для иноды этого файла. просто добоебы космичесого масштаба.







возвращаемся к truncate 
получается намешанная ситуация.
открыт файл на запись . запись сорей всего идет в пейж кеш а не сразу  в файл.
мы натарвливаем truncate он как я понимаю лезет на диск и в иноде правит таблицу
гнде написано в каких блоках лежит тело файла. и он удаляет часть записей про эти блоки.
таки макаром высвобождая часть блоков на диске. далее надо данные которые висят  в пейж 
кеше занести на диск. не знаю есть ли какая то тут сложность но морока точно есть.


также мне непонятно как усторены спарс файлы. как это сделано на уровне вот этой таблицы
занятых блоков под тело файла. я ненашел.


также непонятно как в иноде вычисляется размер файла. такое ощущение что 
параметр размер файла указанный в иноде он содвершенно не связан с колчиеством
фактически занятых блоков на ФС. мы это щас увидим.
эта мысль подтверждается тем что у нас могут быть спарс файлы. и у них file_size
будет большим прописан в иноде.  а по факту число блоков будет маленкое.
я нигде ненашел по какой фрмуле высчиытвается file_size когда он суется в иноду.

параллельно выянилась некоторая хуйня с выводом команды stat.

# stat 1
  File: 1
  Size: 2           Blocks: 2          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 12          Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2023-07-06 20:14:24.740163442 +0000
Modify: 2023-07-06 20:00:18.272607045 +0000
Change: 2023-07-06 20:03:36.091826053 +0000
 Birth: 2023-07-06 20:03:36.091826053 +0000


 что значат поля 
 
 IO Block:

 Blocks: 

правда оказалась такова - для простых фс как ext2\3\4 где размер  блока ФС (не путать с размером сектора на диске) постоянна это поле показывает размер блока ФС

соотевтвественно так как 
IO Block: 1024
то это значит что ext4 была отформатирована с ключом -b 4096 
тоесть размер ФС блока равно 4K. тоесть этот параметр это не параметр файла
это параметр фс на которой он лежит.
что он показывает на сложных фс как zfs где размер блока фс переменный хуй знает

следующее поле "Blocks:" показывает размер файла но в отличие от поля "Size:" котооое по
казыает размер файла в байтах это поле показывает размер файла в блоках. 
прикол втом что этих блоков в природе несущетсвует. это некие виртуальные блоки размером
512 байт. всегда это блоки размером 512. почему 512? почму всегда? а просто так. 
это константа. так было исторически.  поэтому я бы  в итоге сказал бы так. оба эти
поля можно игнорировать потому что они моут показывать полную неимеющую никакого 
смысла на практкие хуйню.

итак еще раз "Blocks:" показывает размер файла в блоках. блоки чего? блоки фс или блоки
диска. ответа нет. блоки ничего. поотому что размер этого блока константа 512.
"IO Block:" покаывзает размер блока фс. но какой это имеет смысл если блок фс переменный
то это тоже какято хуйня. 

зато четко видно вот что. по кракйней мере для ext файловых систем. 
покажу напримере

# stat 1
  File: 1
  Size: 2           Blocks: 2          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 12          Links: 1


фа1л имеет размер 2 байта. 
если мы умножим "Blocks: 2" на 512 то получим что размер равен 1024 байта.
однако у нас же указано что "Size: 2" так в чем же прикол. типа размер файла 2 байта
а надиске он занимает 1024 байта. ответ в том что "IO Block: 1024" тоестразмер 
блока фс  = 1K а это значит что файл не может занимать размер некратный блоку фс.
так как 2байта ментше чем 1 блок фс равный 1К то в итогге по факту файл занимает один 
фс блок 1K.

тоеть я говорю о том что поле "Blocks: " у stat это некая хуйня. это типа сколкьо блоков
непонятно на чеего то ли блоков фс то либлоков физ диска занимает файл на сторадже.
при этом размер этого мифического блока всегда константа 512 байт.  почему 512 байт? 
а просто так захотели. и не меняют это дела со временем царя гороха.

тут  я  хочу добавить что почему stat выводит такую хуйню. потому что он делает 
через сисколл запрос и ему в ответ вылетает прям готовый массив данных. и он его просто
выводит. так что константа 512 вбита где то в  коде ядра. окей ядро мы менят не хотим.
но могли же они подкрутить юзер спейс код самой утидиты stat чтобы он делала коректировку.
это же так прсто. дебилы.


возвращаемся к sparse файлам
и тут я открыл целое новое море которое многое из того что писал выше перечеркивает.

что такое спарс файл типа в общих словах - если у нас есть файл у которого в теле
очень много значений равных "0" то типа того что это значение можно и не записывать 
в блок на диске не тратить на него блок. тоесть все значения в файле байтов которые 
несут какое то другое значение можно записать на диск в сектора а ноль типа чего его 
записывать. и вот как то в метаданных файла кодируются оффсеты (смещение относительно
начала файла , адреса) в которых значение должно быть ноль таким образом что на диске
дата блоки вообще не задействуются а просто вот где то в метаданных делают какуюто пометку
что такойто блок он имеет значние ноль. поэтому когда идет считывание по этому офсету 
внутри файла то драйвер фс видит в метаданыхх не сслыку на какйото блок на диске а видит
пометку что данный офсет это офссет у котрого значение равно нулю. и он возврашает этот ноль 
обратно. условно говоря я же писал сверху что еслиу нас какйто офссет имеет какоето значение
то как выглядит доступ к этому значению - у нас 4 байта в метаданных (неважно в иноде или вне ее ) содержит номер блока ФС размером 4КБ. это если мы говорим про первый индирект 
блок в иноде. тоесть у нас 4 байта метаданных позволяют закодировать 4КБ данных. (вот какая экономия.) ну даже отбросим мы индирект схему. всопмним что в иноде есть блок из 12-ти
полей кажый из которых содержит адреса первых 12-ти фс блоков тела файла. 
я думаю что каждый из 12-ти блоков имеет размер 4 байта. а указывает на блок на фс который
уже имеет размер 4КБ. так вот это я просто походу ещераз напомнил. так вот прдтставим себе
что первые 4КБ в файле это сплошные нули. вместо того чтобы траить на диске 4байта + 4КБ 
мы можем просто напросто в этих 4 байтах прописать четыре нулевых байта и освободит 4КБ на диске под чтото другое полезное. и тогда если у нас идет обращение к первым 4КБ тела файла
то у нас драйвер фс лезет в этот 1-ый блок в иноде который опиысвает тело файла. видит 
что там вместо адреса на блок на диске идут просто нули и драйвер понимает что надо 
программе вернуть псто напросто 4КБ нулей. вобще это гениально. мы израсходлвали всего 4 байта на диске чтобы закодировать 4КБ данных. огророная экономия места на диске. 
опять же отслюда вытекает что чтобы спарс файл реально работал и экономил место это надо 
чтобы в файле были непрервыные куски размера по 4КБ только тогда можно делаь такйо фокус.
или надо уеньшать размер ФС блока скажем до 1КБ  при форматировании. тогда  у нас в файле
чтобы работали фокусы с экономией места на диске уже могуть быть более маленкие куски 
по 1КБ. получается что спарс файл его несозать если у нас в файле много нулей но они 
не имеют непрервыных участков размером с блок ФС.

получется что программе которая должан понять если в файле спарс  куски или нет работать 
очень просто  - она берет метаданые файла и начинает искать в блоке который отвечает за 
список блоков на диске где хранится тело файла он там ищет блоки у которых вместо адреса 
блока на дике просто нули. раз в адресе блока стоит ноль значит это уже файл со спарс кусками
(их еще назыают дырки). 

плюс спарс файла состоит в том что если у нас файл 100G имеет половину внутри себя нулей
кусками по 4КБ скажем то количество места которое надо потратит на сторадже чтобы его 
там записать будет всего 50GB. для приложения будет видно 100G а по факту на сторадже
будет 50g. это как бутто мы применяем к файлу сжатие на лету условно говоря.

минус спарс файлв в том что если в процссе рабоы у нас число нулей будет все менше и менше
то этот файл начнет на сторадже потреблять все больше и больше места и получаетя что 
если у нас на сторадже размером 100G лежит два спарс файла по 100G каждый из которых по фатку
занимает 40GB (итого 80) по мере потерри нулей они начнут расти на сторадже и в итоге
им понадбится 200GB а у нас сторадж на 100. так что вроде как изачально мы смогли вместить
в сторадж данных больше чем у него размер а потом надо будет дергаться и както расгирять 
сторадж. с обычными файлами (непарс) такой проблемы нет. если ты записал два файла по 40ГБ
то они вседа будут занимать 80ГБ и нет прблем.

итак спарс файл все его блоки по 4КБ в которых сплошняком нули - они незанимают 
ни единого блока под тело на диске. все что он занимет это олько его метаданные. и все.
как я уже сказал как я понимаю в метаданных в таблице в которой запиываются адреса блоков
на сторадже где икать тело файла там нули. так выгдлдяит техническая реализация 
спарс файла. понтно что не все его блокт обязаны быть нулями. какието с нуляи какието без.
чем больше нулей тем мноше он занимает на сторадже. чем мегше нулей тем больше занимает 
дата блоков на сторадже.

что еще важно сказать - что параметр size в иноде файла он указывает 
не то сколкьо места тело файла занимает на диске . НЕТ! он показывает сколько 
виртуальных байтов составляет файл. поскольку файл это набор байтов  к которым можно обращаться
через оффсет(адрес смещения к байту), то size описывает сколько виртуальных байтов наш 
файл имеет. но это незначит что на сторадже тело файла занимает такое количеатво байтов.
если сравниить с zip архивом то size файла это как бы размер архива в разжатом состоянии
а обьем который файл занимает на сторадже это как бы размер архива в сжатом состоянии. вот
такаая аналогия. тоесть полу size в иноде оно указывает максимальный размер офссета (в байтах)
по которому клиент может обратиться к этому файлу через драйвер фс и драйвер фс обяазан вернуть
какоето значение по этму адресу оффсета. тоест size это размер файла для внешней программы
для клиенского запроса. и еще раз скажу что size совсем не показывает сколько же байтов
занимает этот файл его тело на бекенд сторадже. это соверщенно отдельный вопрос.

переходим к пракитике
как создать спарс файл у которого все блоки с нулями. ответ через dd

# dd if=/dev/zero of=sparse_file bs=1 count=0 seek=16K

кстати еще один вариант dd чтобы создать sparse файл

# dd if=/dev/zero of=output2 bs=1G seek=0 count=0

видимо весь секрет в count=0

мы создали файл у которого виртуалный размер , размер для внешнего клиента
будет выглядеть как 16KB. полувчается что мы с клиентсой прогарммы можем обращаться с 
запросом на чтение\запись к любому байту в пределах от 0 до 16384 (оффсет) и туда чтото
писать или отттуда чтото получать в ответ (читать).


псмотрим сколько реально этот файл занимает на физ диске. 
имеется опять же ввиду сколько занимает тело файла. потому что сколько занимают
его метаданные обычно утилиты это не показвыают. 


# stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 15          Links: 1




замечу что поле File: sparse_file это всего навсего имя файла а не его тип.
не путай. тип файла regular file. тоесть обычный файл. 

тоесть у линукса у него нет формально такого типа файла как спарс файл. 
спарс файл это бычный файл с точки зрения лиунус. просто у него там внутри немножко
есть специфических свойств. так что вопрос как определить спрас файл или не спарс  я покажу чуть ниже.

важно дургое

Size: 16384 = это покзывает вирт размер файла. 

Blocks: 0  = а вот это поле (внимание) показывает сколко реально места надиске
занимает тело файла. опять эе повторю именно тело. про метаданные вобще ни слова.
размер тела на диске покзывается в таких дебильных единицках как блок по 512 байт.
никаких блоков по 512 байт на диске нет. таких блоков там нет. просто нам надо взять 
512 умножить на число стоящее в графе Blocks и тогда мы узнаем солкьо же байт 
физически занимает тело файла на диске. тоесть число блоков в этой графе это брехня полная.
а вот число умноженное на 512 и полученный редультат в байтах это уже реальное
настоящее число. имеющее физ смысл.

тоесть я пояню на не спарс файле еще раз смысл поля Blocks:

# stat /swapfile
  File: /swapfile
  Size: 2147483648  Blocks: 4194312    IO Block: 4096   regular file
Device: 10302h/66306d   Inode: 12          Links: 1

мы берем  Blocks: 4194312
он говоритт что якобы тело файла на дсике занимает 4194312 блоков по 512 байт размером.
это брхня полная. никакиз блоков по 512 байт на диске нет. ни секторов на диске размером
512 байт нет. ни на фс блоков по 512 байт нет. это брехня полная. кодга то давно
были диски с физ секторами по 512 байт. вот он тогда это и показывал. щас такого ничего
в реангсти нет. а что есть умнжожаем 4194312 на 512 получаем 2147487744 байт.вот 
это число ужее имеет физ смысл. оно говорит что на физ диске тело файла (метаданные отедный вопрос) занимает столько то байт.   параметр Blocks можно понять на примере бумажной
книги и электронного варианта этой книги.  а еще лучше на прмиере сравнит библиотку из бумажых книг и элктроннного вариант этой библиотки.   мы берем суем все книги в элктронном формает в ноубук. и тогда библиотк чисто физиски в квартире занимает всего обьем размерсо с корпус ноубука. а праметр Size:  он показвает сколько бумажных страниц этих книг можно будет пролистать  если эти книги открыть на ноутбуке. тоесть что буманая библиотеека имеет размер
миллион страниц. что элетронная. и там и там size будет один и тот же. но 
влсучае бумажной бибилиотки парметр Blocks будет 1 000 0000 (тоесть книжный шкаф)
а слувае элктронной билиотки это будет всего Blocks 1 потому что все влезло в маленкий
ноубук.

итак на этом примере стала понятен физ смысл и разнциа между таким параметрами 
ноды как Size и Blocks коорые покаызвает утидита stat. котоаяр беерет эти цфиры из иноды.плюс
минус. 


вохварщаемя к нашему спарс файлу


# stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 15          Links: 1


итак мы создали файл с вирт размером 16K
и это видно в  Size: 16384 
тоесть прилоение может напихаь в это файл 16К байтов.
на данный момент на бекенд сторлаже тело файла занимает Blocks: 0  , 0*512=0 байт

какие у нас еще есть утилиыт для получения инфо о структуре файла
есть

# du -sh sparse_file
0   sparse_file


видим ноль. тоесть на сторадже тело файла занимает 0 байт.
в чем прелесть du она всегда по дефолту поуказывает именно
не дутый виртуальный размер файла. а именно сколько байт занимает файла
физически на физ сторадже.

а если мы хотим посмореть вирт размер файла то надо добавить ключ

1# du -sh  --apparent-size    sparse_file
16K sparse_file

это он покзывает вирт размер файл на диске. котооый соверешенно не отражает
сколкьо же байт фактически занимает файл на диске.

таким образом можно используя stat либо du получаьт ответ а файл у нас sparse
или нет.

посмотрим еще один файл 


# stat /var/log/lastlog 
  File: /var/log/lastlog
  Size: 292292      Blocks: 8          IO Block: 4096   regular file


вирт размер файла 292292 байт
а фактически он заниает на диске  8 * 512 = 4096 байт.
очеивдно что соверщенно не совпдаает . пэтому файл однозанчно спарс.

да конечно Blocks * 512 может немного не совпдатаь с Size когда файл не спарс
по соверщенно дургой причине что файл неможет занимать обьем не кратный размеру блока ФС.
например

# echo "2" > 2 
root@vm1:/mnt/sdb1# stat 2
  File: 2
  Size: 2           Blocks: 2          IO Block: 1024   regular file

  вирт размер файла 2 байта
  занимает на диске 2*512 = 1024 байта. 
  разница не потому что файл спарс. а потому что размер блока ФС = 1024байта (IO Block: 1024)
  оэтому файл размером 2 байта неможет занимать места на диске меньше чем 1 ФС блок.
но к спарс это неимеет никакого отношения.


утилита find якобы тоже позволяет опледелять спарс файл или нет. 

# find /var/log -type f  -name "lastlog"  -printf "%S\t%p\n"
0.0140134   /var/log/lastlog


если число меньше 1 
то это значит что в файле есть спарс куски.

посмоотрим на этот lastlog

# stat /var/log/lastlog 
  File: /var/log/lastlog
  Size: 292292      Blocks: 8          IO Block: 4096   regular file

у него вирт размер 292292
а размер который он по факту занимате на стораже равен 8*512= 4096 байт

4,096 << 292,292  ( 4096 намрного менше чем 292 тыши)

поэтому конечно это спарс файл.

разберем find

-printf "%S\t%p\n"

printf это просто опци утилиты find которая описывает в каком формате выводить
на экране результаты поиска. 

\n - означает перенос строки
\t означает сделать табуляцию
%p - означает напечаать имя файла
%S - самая важный ключ . означает что нужно файла расчитаьт вот такую хрень
(BLOCKSIZE*st_blocks / st_size) и вывести ее на экран. откуда find берет данные 
для рачсета это йхрени я незнаю. мне кажется что find исполует тот же самый сиколл
что и команда stat. как я пониаю "BLOCKSIZE" это ничто иное как 512 а "st_blocks" это "Blocks:" из команды stat тоесть

(BLOCKSIZE*st_blocks) = (512*"Blocks:")

а    "st_size" это "Size:" из команды stat.

и вот он это вычитывает и выводит на экран. тоесть это коэффициент 
отношения сколько реально байт на диске занимает тело файла к виртульному размеру файла.

проверим

# stat /var/log/lastlog 
  File: /var/log/lastlog
  Size: 292292      Blocks: 8          IO Block: 4096   regular file
Device: 801h/2049d  Inode: 72225       Links: 1


# echo "scale=10; 8*512/292292" | bc
.0140133838

сверяем с тем что покзыает find

# find /var/log -type f  -name "lastlog"  -printf "%S\t%p\n"
0.0140134   /var/log/lastlog

полнейшее совпадение

итак мы рассмотрели утилиты :
 - stat
 - du
 - find

 кстаи посмотрим что покажет du

#  du -sh /var/log/lastlog 
4.0K    /var/log/lastlog

полное совпдаение с тем что покзывает stat!

таким обрзаом мы через find можем найти все файлы котоыре спарс.
а через stat или du мы можем проверить тоже спарс файл или не спарс.
и узнать сколко же точно занимает на сторадже файл.

кстаи проверим наш файл "2"

# stat 2
  File: 2
  Size: 2           Blocks: 2          IO Block: 1024   regular file
Device: 811h/2065d  Inode: 20          Links: 1

# find ./  -type f  -name "2"  -printf "%S\t%p\n"
512 ./2


512 намного больше 1. конечно же этот файл аболсютно не спарс.

поулчается если число менше чем 1. то это спарс файл. он занимает на диске 
места менше чем его вирт размер.

а если коэфициуент болше 1 то файл на диске занимает гораздо болше места 
чем его вирт размер. тоесть он попусту разбазаривает место на сторадже.


какова схема чтобы спарс файлы давали реузльат. например на mysql 
при создании таблцы надо указа что она будет "сжатая" тогда 
когда муслку будет рбоатать с этой таблцей не диске то он будет при записи
записывать данные так что скажем там где нули то он не просто тупо будет 
пихать нули а будет их пихаьт так чтобы они были спарс. дело в том что
даже для юзеров есть команда чтобы взять файл полный нулей натравить на 
него команду и файл превратитлся в спарс. в случае приложения которое юзает 
файл надо чтобы оно постояно так делало. потому что если мы будем руками 
файл первравать в спарс а приожение будет просто тупо по старому нули пихать 
в файл то он будет преврашаться не в спарс. 
преварение обычноо файла в спарс называется "punch holes" пробивать дырки.


пример
созаем класический не спарс файл у которого занчения только нули

# dd if=/dev/zero of=./t1 bs=1M count=1


провеяем сколько он занимет места на диске

$ du -sh t1
1,0M    t1

или так

$ stat t1
  File: t1
  Size: 1048576     Blocks: 2048       IO Block: 4096   regular file


512*2048 =  1048576 байт


теперь натравливает на него fallocate

# fallocate --dig-holes  t1

он ищет блоки с нулями. отвязывает эти блоки от файла. возвращает их в сторадж.
и как я уже писал выше в таблице которая указывает адреса блоков с телом файла вставляет
нули. и драйвер фс уже понимает что для такогото блока ФС у нас весь блок это сплоншные нули.
получается для 4К блока данных тела файла надо заюзать всего лишь 4 байта в таблице блоков 
в метаданных

$ du -sh t1
0   t1

вуля. файл на сторлалже занимает  0 байт

$ stat t1
  File: t1
  Size: 1048576     Blocks: 0          IO Block: 4096   regular file


попробуем еще чего нибудь сделать как спарс. осбенно какит остатические файлы
из downloads

$ du -sh alpine-standard-3.17.3-x86_64.iso
154M    alpine-standard-3.17.3-x86_64.iso
$ fallocate -d alpine-standard-3.17.3-x86_64.iso
$ du -sh alpine-standard-3.17.3-x86_64.iso
152M    alpine-standard-3.17.3-x86_64.iso

видно что некоторый эфект есть

еще пример

$ du -sh geo_title_index.ibd
297M    geo_title_index.ibd


$ fallocate -d geo_title_index.ibd
$ du -sh geo_title_index.ibd
259M    geo_title_index.ibd

видно что какйотт эфект есть


а вот еще пример

# find ./ -type f -printf "%S\t%p\t%s\n" | awk '$1 < 1.0 {print}' | sort

он выводит только файлы у которых цисло %S<1 тоест толлько спарс файлы.
выводит вируальный размер файл и имя файла. и сортирует вывод так что 
вверху выводятся самый спарс файлы.


итак ключ -d или --dig-holes у fallocate позвяет  обычные файлы трансфорировать
в спарс файлы

# fallocate -d alpine-standard-3.17.3-x86_64.iso

с помощью fallocate можно брать готорые файлы искать там дырки. и замещать их спарс кусками.


как же dd изготваливает спарс файл? через сисколлы lseek и ftruncate.
читать оних не буду нет время.

расмотрим  еще одну утилиту для анализа фа1лов
# filefrag -e sparse_file
Filesystem type is: ef53
Filesystem cylinder groups approximately 251
File size of sparse_file is 16384 (16 blocks of 1024 bytes)
sparse_file: 0 extents found


ее основное предназначение это показать из скольких экстентов
реально на диске состоит файл. экстент это непрервыный набор блоков ФС. непрервыный кусок.

у данного спарс файла экстентов нет. поому что  у него вобще ФС блоков нет.

ксатии походу куча программа юзет stat сисколл. 

еще пример 

# filefrag -e vmlinuz-5.15.0-1035-kvm 
Filesystem type is: ef53
File size of vmlinuz-5.15.0-1035-kvm is 6946312 (1696 blocks of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..    1695:     314368..    316063:   1696:             last,eof
vmlinuz-5.15.0-1035-kvm: 1 extent found



а вот что показывает debugfs

Inode: 60572   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 3649225635    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 6946312
File ACL: 0
Links: 1   Blockcount: 13568
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x648bc4dd:d638f9d8 -- Fri Jun 16 02:11:41 2023
 atime: 0x64a6b853:a0f5d88c -- Thu Jul  6 12:49:23 2023
 mtime: 0x646f76aa:00000000 -- Thu May 25 14:54:34 2023
crtime: 0x648bc4dd:cac74578 -- Fri Jun 16 02:11:41 2023
Size of extra inode fields: 32
Inode checksum: 0x06d3898a
EXTENTS:
(0-1695):314368-316063



и еще третья команда на десерт

# hdparm --fibmap ./vmlinuz-5.15.0-1035-kvm

./vmlinuz-5.15.0-1035-kvm:
 filesystem blocksize 4096, begins at LBA 227328; assuming 512 byte sectors.
 byte_offset  begin_LBA    end_LBA    sectors
           0    2742272    2755839      13568




получается сравнивая  эти команды я  прихожу к выводу что 
314368-316063  это не LBA сектора на физ диске как об этом пишет filefrag в колонке 
"physical_offset" а это блоки ФС. (зацени разницу LBA сектор физ диска и блок ФС).


а (0-1695) это офссет набор. офссет это смешение внутри файла для адресаации байта 
когда мы обращаемся из клиента к файлу. внутри файла при обращении через клиент 
все байтики как бы лежат рядом . нет разрывов. и оффсет позволяет заать адрес того байта
который мы хотим считать

еще момент. как я уже сказал вся эта спарс механика работает только изнутри на уровне бекенда
а с точки зрения клиента это обычный файл. поэтому еси скажем мы копируем спарс файл
то дестинейшн файл будет обычный. если нам надо чтобы и дестинейшн файл был спарс 
проги имеют спец ключи:

tar --sparse 
rsync --sparse
cp --sparse=always
dd  conv=sparse

проверяем

# stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file

# du -sh sparse_file
0   sparse_file

# cp --sparse=always sparse_file cp_sparse

# du -sh cp_sparse 
0   cp_sparse

типа да. типа работает.


далее отойдем в сторону. есть утилиты у ext для того чтобы склонировать партишн (ФС)
To clone a partition from physical disk /dev/sda, partition 1, to physical disk /dev/sdb, partition 1 with e2image, run

# e2image -ra -p /dev/sda1 /dev/sdb1

понятно что чтобы было все чик пибабум надо отмонтировать фс.
также e2image может копироват в файл в формат QCOW тоест мы можем таким макаром
железную машину превратить в виртуалку. прикольно.

естьи еще всякие приколные утилтиты для копировани партишенов. клонирования.
( ссылки по теме:
- https://wiki.archlinux.org/title/disk_cloning
- https://superuser.com/questions/641903/e2image-restore-file-system-metadata
- https://serverfault.com/questions/981766/
- https://serverfault.com/questions/981766/how-to-write-a-sparse-linux-ext4-disk-image-without-writing-gigabytes-of-zeros
)

еще способо создания спарс файла
$ truncate -s 512M file.img

а вот еще один сопосб как типа задетектить что файл спарс

# ls -ls 
total 18
 1 -rw-r--r-- 1 root root           2 Jul  6 20:00 1
 0 -rw-r--r-- 1 root root           0 Jul  6 21:29 10k
 1 -rw-r--r-- 1 root root           2 Jul  6 23:33 2
 0 -rw-r--r-- 1 root root       16384 Jul  7 13:03 cp_sparse
 1 -rw-r--r-- 1 root root         213 Jul  6 14:23 demo.txt
12 drwx------ 2 root root       12288 Jul  6 20:03 lost+found
 0 -rw-r--r-- 1 root root           0 Jul  7 12:42 output2
 1 -rwxr-xr-x 1 root root         368 Jul  6 14:40 p1.py
 0 -rw-r--r-- 1 root root       16384 Jul  6 23:28 sparse_file
 2 -rw-r--r-- 1 root root        2046 Jul  6 21:03 sparse_file2
 0 -rw-r--r-- 1 root root 10737418240 Jul  6 20:50 sparse_file3
 0 -rw-r--r-- 1 root root     5242880 Jul  6 20:52 sparse_file5

 левая колонка это сколко файл занимает на диске.
 а правая колонка какой вирт размер файла


 далее еще интерсно. как увеличить размер файла - неважно спарс он или не спарс
делаем это через dd

имеем исх файл с 16K вирт размер

 # stat sparse_file
  File: sparse_file
  Size: 16384       Blocks: 0          IO Block: 1024   regular file

# dd if=/dev/zero of=sparse_file   bs=1 count=0 seek=32K

проверяем
# stat sparse_file
  File: sparse_file
  Size: 32768       Blocks: 0          IO Block: 1024   regular file


вирт размер стал 32K. контен файла незатронут


теперь малек откатися назад. поговорим опыть про структуру как устроена фс
только не ext2 а ext4

фс разбивает раздел на блоки ФС. причем не просто на блоки. а на группу блоков.
сколько блоков в группе блоков - вот сколько -> берем блок ФС ( тот который задается при форматировании. например 4КБ размером.) и каждый бит этого блока байтов отвечает за один блок ФС. тоесть 4КБ это 4096 байт это 4096*8= 32768 бит. вот значит при ФС с размером блока 4К у нас в каждой группе 32768 блоков.  а если унас блок ФС имеет размер 64К. значит это 
524,288 штук блоков в группе блоков.

далее очень интеерсно - согласно доке по ext4 ( https://www.infradead.org/~mchehab/rst_conversion/filesystems/ext4/overview.html) видно что максимльный размер ФС блока 64KiB.
однако! наебка состоит в том что в реальности смонтировать такую ФС  неполучится. потому что 
незна точно кто виноват толи ядро толи код ФС ext4 но макс размер блока на ФС должен быть 
равен cpu page size тоесть размеру той хрени которой оперирует цпу когда работае с память.
тоест цпу обычно может из памяти таскать блоки по 4KB.вобщем cpu page size это отдельная эпоппея которою я щас не буду читать. это некая хараектиристика процессора.
пока что фишка в том что в процессеоре есть блок MMU. он то и определяет какой размер 
page size. как я понимаю через mmu идеь преоборазование вирт мемори у процесса в физ мемори компа. этим занимается mmu. и как я понял когда процесс хочет себе +1 кусок памяти получит
то он делает запрс к ядру. и вобщем в итоге процесс может получать из памяти куски только 
кратные размеру page size. в итоге RAM преврщается как бы в блочное устрйство. 
в памяти ядра поддерэивается таблица в которой прописывается какой процесс какие пейджы имеют.
в итоге когда процесс хочет прочитать чтото их памяти по адресу то MMU пользуяюсь таблицей пейджей лезет в память. также как ФС c его ФС блоками позволяет отформтаировать раздел.
также MMU  + page table с пейджами позвволяет отформатровать память для потом выдачи процессам.

пэтому можно офтртиовать раздел с -b 64K но смонтировать его не пуолчится. так как 
все по каким то причинам упираетс в page size cpu котоырй у интела 4К.

еть другая фишка у ext4 bigalloc. она задется при форматирваоии. и состоит в том что 
в битмап файле который находится в группе блоков и сидит в одном ФС блоке и каджый его бит
мапит один блок в группе блоков на предмет блок свободен или юзается . и вот bigalloc менет то что у нас 1 бит в битмапе (который сидит в одном блоке ФС) мапит уже не на 1 блок на 
сразу группу блоков. это дает то что в одной группе блоков может быть дохера бблоков
а вот нахер это нам надо в итоге непонятно.


в общем рассмтоиим ext4 с 4K размером ФС блока.
тогда макс аколичетво блоков 2^32 (для 32 битный цпу). блок по 4КБ. в итоге
раздел 16ТБ.

макс колво инод 2^32

число блоков на гурппу 4096*8=32768 блоков это 128MB

макс число блоков которые можно заюзать для одного файла 
# echo "12+1024+1024*1024+1024*1024*1024" | bc
1,074,791,436

это 4TB получается макс размер одного файла при условии что он в своем block map
указывает на блоки ФС.

а если он юзает экстенты (как это там пропграмируется не знаю ) то соласно таблице 
такой файл может занять весь раздел ФС.

если файл меньше 60 байт то он сохранятеся внутри иноды


хотел упонмянть утилиту istat.
она типа дает взможность посмотреть содрежимое иноды 
потому что руками найти эту иноду и помсотреть ее слишком пока сложно

$ stat user.frm
  File: user.frm
  Size: 3159        Blocks: 8          IO Block: 4096   regular file
Device: 10302h/66306d   Inode: 9866215     Links: 1




$ sudo istat /dev/nvme0n1p2 9866215
inode: 9866215
Allocated
Group: 1204
Generation Id: 2125201302
uid / gid: 1000 / 1000
mode: rrw-rw----
Flags: Extents, 
size: 3159
num of links: 1

Inode Times:
Accessed:   2023-07-07 06:16:15.046144629 (+06)
File Modified:  2023-06-27 17:03:25.565822956 (+06)
Inode Modified: 2023-06-27 17:03:25.565822956 (+06)
File Created:   2023-06-27 17:03:25.565822956 (+06)

Direct Blocks:
42371581 


видим флаг Extents,
и вот еще интересный блок

Direct Blocks:
42371581 



$ filefrag -e user.frm
Filesystem type is: ef53
File size of user.frm is 3159 (1 block of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..       0:   42371581..  42371581:      1:             last,eof
user.frm: 1 extent found


поэтому  42371581  это адрес ФС блока.


далее про debugfs. в чем пиздец этого интсрумента что он показывает offset
в OCT формате ссука!!
пример

$ sudo debugfs /dev/nvme0n1p2
debugfs 1.44.1 (24-Mar-2018)
debugfs:  inode_dump <9866215>
0000  b081 e803 570c 0000 4f59 a764 fdc1 9a64  ....W...OY.d...d
0020  fdc1 9a64 0000 0000 e803 0100 0800 0000  ...d............
0040  0000 0800 0100 0000 0af3 0100 0400 0000  ................
0060  0000 0000 0000 0000 0100 0000 fd89 8602  ................
0100  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 96ff ab7e 0000 0000 0000 0000  .......~........
0160  0000 0000 0000 0000 0000 0000 505a 0000  ............PZ..
0200  2000 6fe1 b017 e786 b017 e786 d471 000b   .o..........q..
0220  fdc1 9a64 b017 e786 0000 0000 0000 0000  ...d............
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*



0020 = это OCT число. в десятичном формате это 16.
что совершенно совпадает с тем что мы видим. я  ахуе нахуя ты показываешь 
hex дамп а смещение показываешь в OCT формате. ебнутые долбоемы


эта команда в debugfs она показыает содержимое иноды.



ссылка  - как вручную восстановить удаленный файл (https://tldp.org/HOWTO/archived/Ext2fs-Undeletion-Dir-Struct/index.html) на ext фс.


еще ссылка - про устйроство ext4 (https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout)


debugfs посмртеть статистику по файлу

> debugfs:  stat <9866215>
Inode: 9866215   Type: regular    Mode:  0660   Flags: 0x80000
Generation: 2125201302    Version: 0x00000000:00000001
User:  1000   Group:  1000   Project:     0   Size: 3159
File ACL: 0
Links: 1   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x649ac1fd:86e717b0 -- Tue Jun 27 17:03:25 2023
 atime: 0x64a7594f:0b0071d4 -- Fri Jul  7 06:16:15 2023
 mtime: 0x649ac1fd:86e717b0 -- Tue Jun 27 17:03:25 2023
crtime: 0x649ac1fd:86e717b0 -- Tue Jun 27 17:03:25 2023
Size of extra inode fields: 32
Inode checksum: 0xe16f5a50
EXTENTS:
(0):42371581

видно что файл состоит из одного экстента. (0) = номер экстента
42371581 = экстент состоит из одного ФС блока

а вот как выглядит эта же инфа для файла подкачки


Inode: 12   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 22243306    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 2147483648
File ACL: 0
Links: 1   Blockcount: 4194312
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x61bff7ed:96ba0c00 -- Mon Dec 20 09:26:37 2021
 atime: 0x61cd0783:9688a5b4 -- Thu Dec 30 07:12:35 2021
 mtime: 0x61bff7ed:96ba0c00 -- Mon Dec 20 09:26:37 2021
crtime: 0x61bff7e7:7fd2af8c -- Mon Dec 20 09:26:31 2021
Size of extra inode fields: 32
Inode checksum: 0xef5641ee
EXTENTS:
(ETB0):33853, (0-32767):34816-67583, (32768-63487):67584-98303, (63488-96255):100352-133119, (96256-126975):133120-163839, (126976-159743):165888-198655, (159744-190463):198656-229375, (190464-223231):231424-264191, (223232-253951):264192-294911, (253952-286719):296960-329727, (286720-319487):329728-362495, (319488-352255):362496-395263, (352256-385023):395264-428031, (385024-417791):428032-460799, (417792-450559):460800-493567, (450560-481279):493568-524287, (481280-514047):557056-589823, (514048-524287):589824-600063
(END)

видно что много экстентнтов.

кстати строка
Size of extra inode fields: 32
говорит о том что в саму иноду можно запихать 32 байта если файл мелкий

сравнпиваем со списокм экстентов через другую утилиту
# filefrag -e /swapfile
Filesystem type is: ef53
File size of /swapfile is 2147483648 (524288 blocks of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..   32767:      34816..     67583:  32768:            
   1:    32768..   63487:      67584..     98303:  30720:            
   2:    63488..  126975:     100352..    163839:  63488:      98304:
   3:   126976..  190463:     165888..    229375:  63488:     163840:
   4:   190464..  253951:     231424..    294911:  63488:     229376:
   5:   253952..  481279:     296960..    524287: 227328:     294912:
   6:   481280..  524287:     557056..    600063:  43008:     524288: last,eof
/swapfile: 6 extents found



а вот тут я нашел формат иноды в ext2.
(дело в том что в ext4 формат иноды значиельно сложнее)

https://wiki.osdev.org/Ext2

удвиетлеьно как я понял инода в себе не содержит номер иноды.
это как?

соласно таблице в 40-43 байтах(надо помнить что байту нумеруются с НУЛЯ!) содержится номер первого блока в котором 
хранится первый блок тела файла.

ксати как узнать версию ext.
ответ через
# lsbkl -f



посмотрим на практике:

# echo "123" > ./t1.txt

# stat t1.txt 
  File: t1.txt
  Size: 4           Blocks: 8          IO Block: 4096   regular file
Device: 821h/2081d  Inode: 14          Links: 1


# filefrag -e t1.txt 
Filesystem type is: ef53
Filesystem cylinder groups approximately 16
File size of t1.txt is 4 (1 block of 4096 bytes)
 ext:     logical_offset:        physical_offset: length:   expected: flags:
   0:        0..       0:       1027..      1027:      1:             last,merged,eof

видим что тело файла лежит в одном экстенте в блоке ФС по адресу 1027

теперь возьмем и считаем напрямую через dd контент файла зная в каком ФС блоке
лежит тело файла

# dd if=/dev/sdc1  bs=4K count=1 skip=1027  
123

получилось !


смотрим содержимое иноды
# istat /dev/sdc1 14
inode: 14
Allocated
Group: 0
Generation Id: 818513347
uid / gid: 0 / 0
mode: rrw-r--r--
size: 4
num of links: 1

Inode Times:
Accessed:   2023-07-07 21:11:37 (UTC)
File Modified:  2023-07-07 21:21:15 (UTC)
Inode Modified: 2023-07-07 21:21:15 (UTC)

Direct Blocks:
1027 

видим что опять же указано что ФС блок с телом файла лежит в 1027 блоке ФС


посмотрим на иноду в hex виде

# debugfs /dev/sdc1 
debugfs 1.46.5 (30-Dec-2021)
debugfs:  inode_dump <14>
0000  a481 0000 0400 0000 897f a864 cb81 a864  ...........d...d
0020  cb81 a864 0000 0000 0000 0100 0800 0000  ...d............
0040  0000 0000 0100 0000 0304 0000 0000 0000  ................
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................
*
0140  0000 0000 c385 c930 0000 0000 0000 0000  .......0........
0160  0000 0000 0000 0000 0000 0000 0000 0000  ................
0200  2000 0000 8067 8a78 8067 8a78 acd7 02c3   ....g.x.g.x....
0220  897f a864 acd7 02c3 0000 0000 0000 0000  ...d............
0240  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

осчиывтываем 40 байтов (первый байт нулевой) и берем 4 байта

итак байты 40-43 выглядят как 0304 0000
значит согласно debugfs адрес первого блока с телом файла равен 0304 0000

мы знаем из верхних команд что  адрес ФС блока где лежит файл это 1027 
однако  hex (03 04 00 00) совершенно не дает цифру 1027
в чем же дело.


далее еще прикол. 
если в свойтсвах суперблока укзана фича под названием super_sparse

# dumpe2fs /dev/sdc1 -h | grep -i  features
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file

это значит что копии суперблока сохраняются не в каждой группе блоков 
а только в группе 0 и в групппах которые делятся нацело на 3, 5 и 7.
прикольно. 
для примера такими группами блоков являются группы с номерами

1 3 5 7 9 25 27 49 81

если у нас размер фс блока 4К а в группе блоков тогда 32768 блоков
то умножаем 32768 на эти номера и получаем номер фс блока где лежит копия суперблока.

32768 98304 163840 229376 294912 819200 884736 1605632 2654208

прикольно (взял отсбюда https://metebalci.com/blog/a-minimum-complete-tutorial-of-linux-ext4-file-system/)






сравниваем то что мы видим из debugfs

0000 0403  (1027 в hex виде          )
0304 0000  ( то что видим в  debugfs )

почему же они не совпадают. разберемся.

во первых разберемс что такое endianness. little endian. big endian.
от чего она зависит - если мы говорим про запись в память то зависит от 
цпу. его модели. 
теперь о чем эта хрень - если мы записываем в память поток битов который имеет длинну
несколько байтов то возникает вопрос в ячейку памяти у которой адрес меньше какой 
байт будет записан который в себе несет более значительную часть или менее значительную часть?

тоесть еси мы представим два байта как целое число

FF AA то FF определяет условно говоря тысячи у числа а AA определяет только его десятки 
и единицы. поэтому FF байт назыается MSB (most significant byte) а AA байт называется LSB(leat significatn byte)

аналогично для целого из четырех байтой

FF CC BB AA 

FF = MSB
AA = LSB

так вот если наше число FF CC BB AA будет схраннено в памяти по схеме

0   1  2  3    <== адрес ячейки в RAM
FF CC BB AA 

то это Big endian схема

а если


0   1  2  3    <== адрес ячейки в RAM
AA  BB CC FF

то это litlle endian схема.

еще раз скажу что в случае запист в память это завсит от модели цпу.

интелы они little endian пишут в память.

еще важно сказать что endianness говорит о порядке записи БАЙТОВ 
но ничего не говорит о порядке записи битов. в каком порядке будут записаны биты байта 
в память - об endianness ничего не говорит. это не оговаривается. не регламентируется.

итак еще раз endiannes это об порядке записи байтов. она оперирует байтами как единицей.
как при этом биты записываются внутри байта это не оговаривается.

далее. если у нас little endian система записи в память то если мы счиытываем 
из памяти не сразу все байты которые нам нужны а байт за байтом то на экране 
будет результат расти не слева направо а справа налево. пример

у нас есть число FF CC BB AA
мы его записали в память. он там лежит в таком виде

0   1  2 3   <== адрес в памяти
AA BB CC FF

если мы считаем только из ячейки 0 то на экране будет
AA

если мы считаем дополиниельно теперь из ячейки 1 то на экане будет
BB AA

если считаем из ячейки 2 то на экране бует
CC BB AA

если считаем из ячейки 3 то на экране будет
FF CC BB AA

тоесть сравним еще раз как выглядит дамп памяти 
и как будет выгдяедеть результат на экране

дамп:
0   1  2  3  4  5  
AA BB CC DD EE FF

на экране:
FF EE DD CC BB AA

тоесть то число которое мы в реалности записали в память в дампе 
памяти оно идет  в обратном порядке. поэтмоу когда мы смотрим в дамп
памяти и хотим понять какое же число было изначально записано надо 
дамп читать в обратном порядке

возвращаемся  к нашему примеру с debugfs. мы имеем дамп:

0304 0000

поскольку мы знаем что debugfs нам рисует на экране байты в зависимости от оффсета.
а оффсет это аналог адреса в памяти и посколку мы знаем что драйвер ext он пишет
байты в файл по схеме little endian тоесть в обратном порядке то нам чтобы восставноить
исходное число надо байты на бумагу записываь в обратном порядке тоесть

00 00 04 03 = 0403 = 403 = 1027(dec)

все совпало!

замечу тут ряд важных моментов:
1) для того чтобы нам из дампа восстановить исходное число нам прежде всего
надо знать какая была длинаа в байтах у исходного числа.

вот мы знаем из доки что номер блока ФС кодируется через 4 байта. и тогда все понятно.

а то представим что у нас есть набор байтов из дампа

00 00 11 AA 34 45 67 ...

как нам отсюда восстановить оригинальное число не зная его длинну в байтах? никак

это может быть
67
или

67 45
или

67 45 34
и так далее

2) endianness влияет только на уровне байта. но никак не влияет на уровне битов
внутри байта. 

это дает то что если у нас есть байтовая последовательность из дампа

45 34 00 11 12 AB AC FA

и если мы незнаем по какой схеме у нас записывались эти байты в память или на диск
но при этом если мы знаем что интересующее нас число имеет длину 1 байт 
то нам это дает то что  при любой схеме  оригинальное число длинной 1 байт
будет иметь ровно то же значение что и в дампе. тоесть

если мы видим в дампе 45 то  при любой схеме оригинальое число перед записью тоже
было 45 а не 54 или какоето другое число. 
если в дампе мы видим FA то при любой схеме оригинальный байт перед записью 
тоже был FA а не FA или какое то другое число

тоесть endanness никак не изменяет число при записи если оно длинной 1 байт.
оно что в дампе что в жизни одинаково выглядит не меняется.

поэтому endianess оно влияет только на взаимое расположение байтов относительно 
друг друга в памяти , на диске или на бумаге. а на вид самих байтов никак не влияет.

поэтому если в дампе мы видим  45 34 
и мы знаем что оригинальное число было длинной два байта 
то тогда оригинальное число было либо

45 34
либо
34 45

и больше никак. в завиисомости была ли схема записи little endian или big endian.
меняется только взаимое расположение байтов друг относительно друга они меняется
местами. а сами байты остаются неизменными. это очень важное свойство.

пэтому есди у нас есть последовательность байтов из дампа
то нам чтобы восстановить оригинальное число надо знать endianness и длинну оригинального 
числа.  для ext4 мы знаем что драйвер этой фс пишет байты на диск в little endian.
тогда остается только значть длинну оригинальных чисел. например:

имеем дамп

0200 0000 0c00 0102 2e00 0000 0200 0000

первые 4 байта это номер иноды.
значит номер иноды = 00 00 00 02 = 2(dec)

следущие 2 байта это record length, значит
record length = 00 0c = 12 bytes

и так далее. 
еще раз поскольку endiannes при записи не влияет на сам байт а байт кодируется в 
hex виде двумя цифрами то когда мы восстанавливаем исходное число из дампа  у нас
комбинация из двух цифр никогда не меняется. тоесть как в первом примере мы имеем

0200 0000 . разбиваем на группы из двух цифр  (тоесть разбиваем биты по байтам) 
получаем (02)(00)(00)(00)
мы четко знаем что в оригинальном числе байт (группа из двух цифр) было ровно таким же самым.
поэтому 02 в дампе  приведет к тому что на бумаге тоже будет 02 а не чтото другое например 20.
единтсвенное что будет другое в оригинальном числе которое мы хотим восстановить на основе 
дампа это взаимное расположение байтов друг относительно друга. для литтл ендиан 
будет обратный поряок байтов. (малек уходя в стоону добавлю что мы даже не можем узнать и посмотреть в в каком же порядке по факту записаны биты на диск в прямом порядке или обратном потому что мы читая с диска можем получить в качетве минимальной единицы только байт. поэтому его битовая карта нам остается неизвестной)

итак это полная мудота с этими эндинесс

непонтно про bigalloc. он якобы позволяет в  секторе котоырй делает битмап (один бит 
кодирует один фс блок испольуеся он или нет) так вот bigalloc при форматировании 
позволяет сделат чтобы в битмап секторе мапился вместо одного блок фс целая куча блоков.
по идее что это дает - ну можно файл больше по размеру создать.
но что я не пойму в чем разница между бигаллоками и экстентами?

если блок 4К то размер фс макс это 16ТБ. макс размер файла 4ТБ (1024x1024x1024 *4K) если юзать
блоки. и макс размер файла 16ТБ если юзать экстенты (как юзать экстенты неясно пока)

в описании red hat 7 пишкт что размер фс макс это 50ТБ. откуда они это высрали
непонятно - https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-ext4

также ext4 also labels unallocated block groups and inode table sections accordingly, which allows them to be skipped during a file system check.



еше малек откатиммся. посмотрим что показывает формтирование


Discarding device blocks: done                            
Filesystem label=
OS type: Linux
Block size=4096 (log=2)                 # размер ФС блока 4K
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks  # stride= измеряется в блоках ФС
                                        # применяется если у нас ext4 сидит поверх
                                        # md устройства тоесть софт рейда.
                                        # каким то макаром это обьясняет незнаю кому
                                        # что stride количество блоков писать на один
                                        # физ диск. а все остльное на другой диск.
                                        # какая то чущь собачья
                                        # stripe= измерятеся в блоках ФС
                                        # обычно выставляется как stride*N
                                        # где N это число дисков в нижележащем рейде.
                                        # чушь собачья.  
                                        #  с помощью tune2fs можно это менять
                                        # tune2fs -E stride=32,stripe-width=96 -O dir_index /dev/mapper/UUIDofext4fspartition
                                        # еще раз подчеркну что stride и stripe
                                        # обозначает колчество блоков. а не байты
                                        # физ смысл их мне непонятен.
                                        # как дело фс до нижележащей архитектуры дисков?
                                        # как фс может на это влять? бред


130560 inodes, 521472 blocks            # на каждые 4 блока одна инода
26073 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=534773760     # это просто показан макс размер возможного раздела
                                        # получется 2ТБ...кхмм. маловато
16 block groups                         # 16 блок групп. 521472 блоков поделить на 32768
                                        # получаем 16 групп
32768 blocks per group, 32768 fragments per group # что таоке фрагменты хуй знает
8160 inodes per group
Filesystem UUID: 083390f6-70cf-4bab-9f50-6828fd00e6a2
Superblock backups stored on blocks: 
    32768, 98304, 163840, 229376, 294912  # суперблоки хранятся в группах блоков с номерами
                                          # 0 и кратные 3,5,7
                                          # если в группе 32768 блоков то суперблок хранися
                                          # в первом блоке группы блоков. блоки нумеруются 
                                          # с нулевого блока. получается группа блоков "0"
                                          # имеет номера 0-32767. тогда группа блоков с номером "1" имеет блоки 32768-65535. и копия 
                                          # суперблока сидит в 32768. вобщем  98304/32768=3
                                          # тоесть мы знаем номер группы блоков и в спске
                                          # мы видим адреса блоков фс в которых сидит бэкап
                                          # суперблока


Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done 


кстати что касаается тех же бэкапов суперлока. можно их посмотреть 
и по другому

# dumpe2fs ...

Group 0: (Blocks 0-32767) csum 0x558a [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-255
  Block bitmap at 256 (+256), csum 0x1ffc106e
  Inode bitmap at 272 (+272), csum 0x1a403b57
  Inode table at 288-797 (+288)
  24314 free blocks, 8149 free inodes, 2 directories, 8149 unused inodes
  Free blocks: 8454-32767
  Free inodes: 12-8160
Group 1: (Blocks 32768-65535) csum 0x6b7a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Reserved GDT blocks at 32770-33023
  Block bitmap at 257 (bg #0 + 257), csum 0x00000000
  Inode bitmap at 273 (bg #0 + 273), csum 0x00000000
  Inode table at 798-1307 (bg #0 + 798)
  32512 free blocks, 8160 free inodes, 0 directories, 8160 unused inodes
  Free blocks: 33024-65535
  Free inodes: 8161-16320




далее

Group 1: (Blocks 32768-65535) csum 0x6b7a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Reserved GDT blocks at 32770-33023
  Block bitmap at 257 (bg #0 + 257), csum 0x00000000
  Inode bitmap at 273 (bg #0 + 273), csum 0x00000000
  Inode table at 798-1307 (bg #0 + 798)
  32512 free blocks, 8160 free inodes, 0 directories, 8160 unused inodes
  Free blocks: 33024-65535
  Free inodes: 8161-16320

  прикольно то что видно бувакльно все
  в каком блоке block bitmap
  в каком блоке inode bitmap
  в каком блоке начинается таблица инодов
  ктатсти отично видно из чего состоит каждлая блок группа

  видно что ели еть ьэкап суперлока то он сидит в перовом блоке группы блоков

также видно что например Group descriptors at 32769-32769
тоесть в этих блоках находися Group Descriptors

  также важно понять что иноды хранятся пачками в блоках фс
  получается чтобы руками прочитать иноду надо найти ее блок. считать блок
  и внутри этого блока найти кусок длинной 256 байт.


  далее. прикол в том что ext4 при формтировании можно активировать фичи

# dumpe2fs /dev/sdb1 -h  | grep -i "Filesystem features"
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      
  has_journal 
  ext_attr 
  resize_inode 
  dir_index 
  filetype 
  needs_recovery 
  extent 
  64bit 
  flex_bg 
  sparse_super 
  large_file 
  huge_file 
  dir_nlink 
  extra_isize 
  metadata_csum


resize_inode фича дает то что как раз таки на фс резервируются блоки в "Reserved GDT blocks"
и за счет них можно на лету расширять ФС. 


также я думаю что tune2fs может какието фиичи активировать после того как фс отформатирована





свойства будушей фс для утилиты форматиования прописаны по дфеолту в
файле. тоесть их ненужно руками вбиват при форматиорвании раздела

$ cat mke2fs.conf 
[defaults]
    base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr
    default_mntopts = acl,user_xattr
    enable_periodic_fsck = 0
    blocksize = 4096
    inode_size = 256
    inode_ratio = 16384

[fs_types]
    ext3 = {
        features = has_journal
    }
    ext4 = {
        features = has_journal,extent,huge_file,flex_bg,metadata_csum,64bit,dir_nlink,extra_isize
        inode_size = 256
    }
    small = {
        blocksize = 1024
        inode_size = 128
        inode_ratio = 4096
    }
    floppy = {
        blocksize = 1024
        inode_size = 128
        inode_ratio = 8192
    }
    big = {
        inode_ratio = 32768
    }
    huge = {
        inode_ratio = 65536
    }
    news = {
        inode_ratio = 4096
    }
    largefile = {
        inode_ratio = 1048576
        blocksize = -1
    }
    largefile4 = {
        inode_ratio = 4194304
        blocksize = -1
    }
    hurd = {
         blocksize = 4096
         inode_size = 128
    }
[vasya@lenovo etc]$ 


параметр сколько инодов создавать в зависиомсти от размера раздела 
mkfs берет из этого файла. параматр inode_ratio
"big" , "huge", "floppy" это типа размер раздела. в зависимости от него mkfs
выбирает параметры. про "big" , "huge", "floppy" читай в man mkf.ext4 параметр -T

если честно не могу понять в чем важность суперблока.  я смотрел в него
и не вижу там ничего полезного одни общие стат данные.


группа блоков содержит в себе:
- супер блок\ копию супер блока \ (не во всех блок группах)
- group descriptor 
- reserved group descritpor blocks
- data block bitmap
- inode bitmap 
- inode table
- data blocks

приклокно что битмап для блоков и битмап для инод это отделные хрени
как я понял group descritpor содержит инфо где в блоке групп искать остальные хрени 
(data blocck bitmap и прочих) тоесть если супер блок он он содержит металанные вообще об фс
то group descriptor содержит метаданные о том что творится внутри конкртеного block group
чтоб драйвер мог ориеонтироваттся внутри блок группы.

на счет reserved group descritpor blocks непонятно нахуй он нужен. они пишут мол
это делаестся с учетом что фс может быть расширена в будущем. то что мне непонятно это то что
если фс расшириться то внутри существующей группы блоков нахуй ненужно нчиего менять.
на новом куске диск и буду создаваться ноые блок группы. поэтому что это за хуета и нахуй
она нужна непоятно. 

data block bitmap это один фс блок. в нем кждый бит показывает занят ли тот или оной блок
в группе или нет. расположение этой структуры нефиксировано. его адрес как раз хранисяя в
GT

inode bitmap - один блок. покзывает какие иноды в группе заняты. положение не фиксировано.
 адрес блока хранится в GT

походу прикл в том что информация о занятости блока дублируется в двух местах  в 
 data block biitnap и в inode bitmap

что еще непонятно - обязана ли инода в группе содержать в себе инфо о дата блоках
лежащих тлько в этой группе блоков или может содержать в себе и ссылки на дата блоки
из других групп блоков.

если посмотрим суперблок то полуим взаимсвязные цифры про иноды

Inodes per group:         8160
Inode size:           256
Inode blocks per group:   510
Block size:               4096

8160* 256 / 4096 = 510 (Inode blocks per group)


следущая хрень это flex groups

# dumpe2fs /dev/sdb1 -h | grep Flex
dumpe2fs 1.46.5 (30-Dec-2021)
Flex block group size:    16


есть так назвыаемые Flexible Block Groups
прблема в том что dummp2fs нихера ничего о них не показывает.



возвращаемся к группам блоков

Group 0: (Blocks 0-32767) csum 0x8d0b
  Primary superblock at 0, Group descriptor at 1
  Block bitmap at 2 (+2), csum 0xdd0693be
  Inode bitmap at 10 (+10), csum 0x224da69c
  Inode table at 18-527 (+18)
  28665 free blocks, 8149 free inodes, 2 directories, 8149 unused inodes
  Free blocks: 4103-32767
  Free inodes: 12-8160


вот приколная команда. покаызает в каком блоке и  в каком оффсете нахрлится
инода с таким то номером

> debugfs:  imap <2>
Inode 2 is part of block group 0
    located at block 18, offset 0x0100


а вот пикьная комана показать дамп блока фс
посмотрим дамп блока 1. в группе блоков "0" там находится "Group descriptor"

>debugfs:  block_dump 1
0000:  0200 0000 0a00 0000 1200 0000 f96f d51f
       0200 0000 1200 0000 2200 0000 f95f d51

якобы в первых трех 32 битных числах указаны блоки где лежат 
Data Block Bitmap, inode Bitmap and inode Table

0200 0000 , мы помним что надо пребобразовать из little endian, значит
00 00 00 02 = 2(dec) <== адрес блока фс с Data Block Bitmap

следущий клиент. 0a00 0000 преобраузуем из литтл ендиан 
00 00 00 0a = 10 (dec) <=== адрес блока фс с inode Bitmap

следущий лиент. 1200 0000 преобразуем из литтл ендиан.
00 00 00 12 = 18 (dec) <=== адрс блока фс с inode Table


сарниваем с вверху  с тем что нам прказал dumpe2fs
все совапало!
причем что важно полученные цифры 2,10,18 это не абсолютный адрес блока
а относиетльное смещение , относительно адреса первого блока в группе блоков.

важно сказать что если в группе блоков есть бэкап суперблока то это первый блок
в группе. а далее идет 1 блок Group Descrptor. Только эти два блока имеют фиксированное
положение в группе блоков. остальные блоки имеют плавающие адреса.

вот еще пример
имеем группу блоков

Group 3: (Blocks 98304-131071)
  Backup superblock at 98304, Group descriptors at 98305-98305
  Reserved GDT blocks at 98306-98432
  Block bitmap at 98433 (+129)
  Inode bitmap at 98434 (+130)
  Inode table at 98435-98944 (+131)
  32127 free blocks, 8160 free inodes, 0 directories
  Free blocks: 98945-131071
  Free inodes: 24481-32640


# debugfs /dev/sdc1
debugfs 1.46.5 (30-Dec-2021)
debugfs:  block_dump 98305
0000:  8100 0000 8200 0000 8300 0000 797d d51f

8100 0000 => (обртаное преобразование из little-endian)==>  81 00 00 00  = 129(dec)
значит Block bitmap имеет оффсет +129 
смотрим наверх все совпало

8200 0000 = 130(dec)значит Inode bitmap имеет офссет +130
смотри наверх совпало

8300 0000 = 131(dec) значит Inode table имеет офссет +131
смотрим наверх совпало

причем вот что интересно и важно про Block Group Descriptor:
1) он содержит в себе описание не только той группы в которой он содержится а всех групп.
2) адрес блока указывается в абсолютном значении. тоесть прям адерс блока а не относительное
смещение относительно блока начала группы 


важный вывод из этого - что если попорится один блок дескриптор то нужную информацию
всегда можно взять из любого друого групп дескриптора

еще я не очень понял то что они же должны быть идентичны. а они почемуто не идентичны.
это я щас покажу ниже.


для простоты я покажу на примере ext2 потому что у нее все проще.

структура Block Group Descripto для одной группы блоков

Offset (bytes)  Size (bytes)    Description
0               4               bg_block_bitmap
4               4               bg_inode_bitmap
8               4               bg_inode_table
12              2               bg_free_blocks_count
14              2               bg_free_inodes_count
16              2               bg_used_dirs_count
18              2               bg_pad
20              12              bg_reserved


как видно описание для одной группы блоков занимает 32 байта.

я беру dumpe2fs для ext2 раздела

Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-128
  Block bitmap at 129 (+129)
  Inode bitmap at 130 (+130)
  Inode table at 131-640 (+131)
  32111 free blocks, 8144 free inodes, 2 directories
  Free blocks: 647-1026, 1030, 1032-1036, 1039-1536, 1538-1541, 1545-32767
  Free inodes: 17-8160
Group 1: (Blocks 32768-65535)
  Backup superblock at 32768, Group descriptors at 32769-32769
  Reserved GDT blocks at 32770-32896
  Block bitmap at 32897 (+129)
  Inode bitmap at 32898 (+130)
  Inode table at 32899-33408 (+131)
  32127 free blocks, 8160 free inodes, 0 directories
  Free blocks: 33409-65535
  Free inodes: 8161-16320
Group 2: (Blocks 65536-98303)
  Block bitmap at 65536 (+0)
  Inode bitmap at 65537 (+1)
  Inode table at 65538-66047 (+2)
  32256 free blocks, 8160 free inodes, 0 directories
  Free blocks: 66048-98303
  Free inodes: 16321-24480
Group 3: (Blocks 98304-131071)
  Backup superblock at 98304, Group descriptors at 98305-98305
  Reserved GDT blocks at 98306-98432
  Block bitmap at 98433 (+129)
  Inode bitmap at 98434 (+130)
  Inode table at 98435-98944 (+131)
  32127 free blocks, 8160 free inodes, 0 directories
  Free blocks: 98945-131071
  Free inodes: 24481-32640


я буду проверять групп дескриптор на примере поля "Block bitmap"
поэому прогреплю то что выше

Group 0: (Blocks 0-32767)
  Block bitmap at 129 (+129)

Group 1: (Blocks 32768-65535)
  Block bitmap at 32897 (+129)

Group 2: (Blocks 65536-98303)
  Block bitmap at 65536 (+0)

Group 3: (Blocks 98304-131071)
  Block bitmap at 98433 (+129)



я беру дамп group descriptor из ФС блока 1

debugfs:  block_dump 1
0000:  8100 0000 8200 0000 8300 0000 6f7d d01f  ............o}..
0020:  0200 0400 0000 0000 0000 0000 0000 0000  ................

0040:  8180 0000 8280 0000 8380 0000 7f7d e01f  .............}..
0060:  0000 0400 0000 0000 0000 0000 0000 0000  ................

0100:  0000 0100 0100 0100 0200 0100 007e e01f  .............~..
0120:  0000 0400 0000 0000 0000 0000 0000 0000  ................

0140:  8180 0100 8280 0100 8380 0100 7f7d e01f  .............}..
0160:  0000 0400 0000 0000 0000 0000 0000 0000  ................

поскольку описание для одной группы блоков занимает 32 байта
то я отделил каждые 32 байта. чтобы четко было видно куски дампа
отвечающие за разные группы блоков


8100 0000 (преобразую из литтл ендиан) 00000081 = 129(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "0" равен 129 (dec)
смотрим вверх да совпало.


8180 0000 (преобразую из литтл ендиан) 00008081 = 32897(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "1" равен 32897 (dec)
смотрим вверх да совпало.


0000 0100 (преобразую из литтл ендиан) 00010000 = 65536(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "2" равен 65536 (dec)
смотрим вверх да совпало.




8180 0100 (преобразую из литтл ендиан) 00018081 = 98433(dec)
получается на основе данных из block group descruptor адрес фс блока
где лежит "Block bitmap" для Block group "3" равен 98433 (dec)
смотрим вверх да совпало.

все абсолно совпало.



а теперь покаж странную вещь о том что  Block Descritor 
его дампы из разных копий они не совпадают


debugfs:  block_dump 1
0000  8100 0000 8200 0000 8300 0000 6f7d d01f  ............o}..
0020  0200 0400 0000 0000 0000 0000 0000 0000  ................

0040  8180 0000 8280 0000 8380 0000 7f7d e01f  .............}..
0060  0000 0400 0000 0000 0000 0000 0000 0000  ................

0100  0000 0100 0100 0100 0200 0100 007e e01f  .............~..
0120  0000 0400 0000 0000 0000 0000 0000 0000  ................




debugfs:  block_dump 32769
0000  8100 0000 8200 0000 8300 0000 797d d51f  ............y}..
0020  0200 0000 0000 0000 0000 0000 0000 0000  ................

0040  8180 0000 8280 0000 8380 0000 7f7d e01f  .............}..
0060  0000 0000 0000 0000 0000 0000 0000 0000  ................

0100  0000 0100 0100 0100 0200 0100 007e e01f  .............~..
0120  0000 0000 0000 0000 0000 0000 0000 0000  ................



видно что в разых дампах для Block Group "0"
параметр "bg_free_blocks_count" отличается в одном
дампе он равен 6f7d а в другом он равен 797d
как же так? это же инфо про одну и туже групппу.
дампы же должны совпдаать. непонятно..

в любом случае адрес Block bitmap везде совпдаает.
так что будем считать что можно взять любой Block Descriptor
и получить адекватную инфомраацию об группах блоков любых.

далее 

Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-1
  Reserved GDT blocks at 2-128
  Block bitmap at 129 (+129)
  Inode bitmap at 130 (+130)
  Inode table at 131-640 (+131)
  32111 free blocks, 8144 free inodes, 2 directories
  Free blocks: 647-1026, 1030, 1032-1036, 1039-1536, 1538-1541, 1545-32767
  Free inodes: 17-8160


что из этого можно сказать интетенсого - что вначале группы блоков идут блоки посвященные
ичключиетльно метаданным.  а только когда метаданные заканчиыватся только тогда и начинаются
дата блоки. тоесть дата блоки идут только после метаданных. также важно уточнить что 
блоки занятые под метаанные это тоже вобщемто дата блоки. по крайней мере в битмап файле
помечаются как занятые все блоки в группе неважно что они в сеебе несут метаданные
или уже живые пользователськие данные. все равно.

видно с блока 0 по блок 640 идут метаданные. а уже все остальное свбодно под 
юзерские данные. 

видно что част дата блоков занята. правда почемуто неравномерно.

Free blocks: 647-1026, 1030, 1032-1036, 1039-1536, 1538-1541, 1545-32767

возможно чтото было записано а потом стерто.


в случае ext2 что касатся таким метаданных как 
block bitmap
inode bitmap
inode table 
все очень просто - эти штуки есть в каждой группе блоков.

в ext4 ситуация уже намного сложнее
есть такая фича у ext4 назватется flex block group
причем эта фича по умолчаию активрвана в файле /etc/mke2fs.conf
поэтому при форматиовании она аткивируется автомтом. 

значит я ее щас отключу. и покажу как выглядит картинка для блок групп


# dumpe2fs /dev/sdb1 | grep -E "Group|Block bitmap|Inode bitmap"
dumpe2fs 1.46.5 (30-Dec-2021)
Group descriptor size:    64

Group 0: (Blocks 0-32767) csum 0x3835
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0xa091049a
  Inode bitmap at 3 (+3), csum 0xdca3f573

Group 1: (Blocks 32768-65535) csum 0x6619 [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 32770 (+2), csum 0x00000000
  Inode bitmap at 32771 (+3), csum 0x00000000

Group 2: (Blocks 65536-98303) csum 0x5c5f [INODE_UNINIT, BLOCK_UNINIT]
  Block bitmap at 65536 (+0), csum 0x00000000
  Inode bitmap at 65537 (+1), csum 0x00000000

Group 3: (Blocks 98304-131071) csum 0x4d94 [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 98304, Group descriptors at 98305-98305
  Block bitmap at 98306 (+2), csum 0x00000000
  Inode bitmap at 98307 (+3), csum 0x00000000


значит пока что все выглядит также как в случае ext2.
битмапы имеют абсолютные значения. и каждый из них сидит   в прееделах 
своей группы блоков


теперь идем в /etc/mke2fs.conf
там обратно возвраащаем фичу flex_bg
и форматируем фс и выставляем флаг -G 

# mkfs.ext4 /dev/sdb1 -G 4

проверяем
# dumpe2fs /dev/sdb1 | grep -i flex
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum

# dumpe2fs /dev/sdb1 -h | grep Flex
dumpe2fs 1.46.5 (30-Dec-2021)
Flex block group size:    4

значит что такое флекс группы. это когда берется несколько групп блоков и они типа 
обьединяются в одну более большую группу.  я спецально акцентирую внимание на слове
типа обьединяются. как это выяглядит. что касается бэкапов суперблока и бэкапов
Block Group Descritor то тут все по старому - там где им пложено быть они все равно повятся.
эфффект для группы блоков проявялется в таких метаданных как 

block bitmap
inode bitmap
inode table 

они переносятся со всех групп блоков в головной блок. там для этого уширяются
соотсвтетующие куски метаданных

-G 4 = гвоорит сколько группп блоков таким макаром обьединять. 

итак да . часть метаданных переезжает  в головную группу блоков. вэтом плане как бы
есть обьединение. тоест мы как бы часть метаданных переносим в головную часть и у нас 
как бы обьединяется блок блоков где юзерские даные будут хостится. загвоздка только в том
что как уже сказал суперблок его копия и копиия Blocl Group Descriptor
все равно там где поожено оно появится в группах блоков. 
выхлоп от этой флекс группы типа такой то что для более больших файлов  меньше будет 
разрывность их тела и метаднные лежат более кучно.


смотрим результат
согласно моим выщесделаным настройкам у меня 4 группы блоков типа должно слится в одну

Group 0: (Blocks 0-32767) csum 0x8f22
  Primary superblock at 0, Group descriptors at 1-1
  Block bitmap at 2 (+2), csum 0x628d98e6
  Inode bitmap at 6 (+6), csum 0x89d426df
  Inode table at 10-519 (+10)

Group 1: (Blocks 32768-65535) csum 0x76aa [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 32768, Group descriptors at 32769-32769
  Block bitmap at 3 (bg #0 + 3), csum 0x00000000
  Inode bitmap at 7 (bg #0 + 7), csum 0x00000000
  Inode table at 520-1029 (bg #0 + 520)

Group 2: (Blocks 65536-98303) csum 0x2085 [INODE_UNINIT, BLOCK_UNINIT]
  Block bitmap at 4 (bg #0 + 4), csum 0x00000000
  Inode bitmap at 8 (bg #0 + 8), csum 0x00000000
  Inode table at 1030-1539 (bg #0 + 1030)

Group 3: (Blocks 98304-131071) csum 0x06a4 [INODE_UNINIT, BLOCK_UNINIT]
  Backup superblock at 98304, Group descriptors at 98305-98305
  Block bitmap at 5 (bg #0 + 5), csum 0x00000000
  Inode bitmap at 9 (bg #0 + 9), csum 0x00000000
  Inode table at 1540-2049 (bg #0 + 1540)


что можно заметить. только в группе блоков "0"  у нас Block bitmap, inode bitmap,
Inode table имеют абсолютное значение адреса фс блока где их искать

  Block bitmap at 2
  Inode bitmap at 6
  Inode table at 10-519 

для остальых члоенов этой флекс группы видим вот такое

  Block bitmap at 3 (bg #0 + 3)
  Inode bitmap at 7 (bg #0 + 7)
  Inode table at 520-1029 (bg #0 + 520)


вот эта хрень (bg #0 + 3) означает что адрес указан не абсолютный а относииельный.
относиетльно насколько я понимаю адреса первого блока в группе блоков "0"

выхлоп от этой хрени тлко такой что еси у нас файлы больше 128МБ то их тело будет иметь
меньше разрывов.  эти ухищрения делают потому что мы неможем увелчить размер блока фс 4КБ потомучто он завязан на размер page size в mmu цпу. вот и извращаются


посмтрим что следущий флекс группа блоков имеет такую же схему

Group 4: (Blocks 131072-163839) csum 0x3f9c [INODE_UNINIT]
  Block bitmap at 131072 (+0), csum 0xafb9b452
  Inode bitmap at 131076 (+4), csum 0x00000000
  Inode table at 131080-131589 (+8)
Group 5: (Blocks 163840-196607) csum 0xe73d [INODE_UNINIT]
  Backup superblock at 163840, Group descriptors at 163841-163841
  Block bitmap at 131073 (bg #4 + 1), csum 0x9b7b32e8
  Inode bitmap at 131077 (bg #4 + 5), csum 0x00000000
  Inode table at 131590-132099 (bg #4 + 518)


головная группа "4" имеет абсолюьные значения блоков для битмапов.
а дочерняя группа "5" уже сслыается на головную группу "4" (bg #4 + 1)

прикольно. с этимиф флекс группами.

 сточки зрения выживучести данные конечно это хуже. лучше чтобы метаданные были более 
 распылены по диску. если файл большой то ка бы похеру невлиает  флекс схема
 на выжиывучесть. а еси файлы маленкие то выжиывучест становистя хуже

 как они сами пишут нахер это надо:
 This improves meta-data
              locality and performance on meta-data heavy workloads.



получается по дефолту по краенй мере в ext2 или в ext4 с выключенными флекс группами
у нас метаданные от файла хранятся рядышком с телом файла. во первых это дает больше выживучести файлам. потому что есди  унас метеданные лежат в куче скжем вначае диска то 
повреждение начал диска убивает нам все файлы на всем диске. а если у нас метданные рсплыены
по всему диску то уничтожение куска дикска вначале убивает тлоько файлы внчалае диска.
плюс когда метданные лежат рядом с данными то и перфоманс в плюсе.

коенчно когда  унас вклюен журнал и он лежит на том же диске то пуолается что надо 
метаданные (а порой и сами данные) внале заптсать в журнал а потом второй раз на диск.
причем в дургое место.  ssd дискам это похер. а шпиндельным это уже грустно. потому что 
жунал лежит в одной части диска а реальные данные овсем в другой части. надо дергаться.


выше я расмаотрел фичу flex groups котораф по дефолут активрована при форматировании. 
по дефолту число групп блоков входящих в флекс гурппу равно 4. 
это позволяет перетащить 
block bitmap
inode bimap
inode table
в головную группу блоков. таким образом собрав часть метаданныех в кучу  с нескольких
групп блоков.это дает кучность метаданных (ненадо шариться по всему диску из за них)
и то что длиныые файлы будут иметь меньше разрывов на диске. для ссд мне кажется это похеру
а для шпиндельных наверно имеет смысл. 

так вот мжно пойти еще дальше - можно собрать все метаданные со всех групп блоков  в 
начало диска. один вариант это создать мегаогромную флекс группу. тоесть она 
обьединит кучу групп блоков в типа один.

# mkfs.ext3 /dev/sdv1 -G 100000000

  
есть еще вариант это заюзать опцию 

  packed_meta_blocks[= <0 to disable, 1 to enable>]
                          Place the allocation bitmaps and the inode table at the beginning of the disk.  This option requires that the flex_bg file system  feature  to  be  enabled  in
                          order  for it to have effect, and will also create the journal at the beginning of the file system.  This option is useful for flash devices that use SLC flash
                          at the beginning of the disk.  It also maximizes the range of contiguous data blocks, which can be useful for certain specialized use cases, such as  supported
                          Shingled Drives.


# mkfs.ext4   ./10T.txt  -E packed_meta_blocks

@@@@@@@@@@@@@@@@@@

далее я делаю исседование на тему - в каких блоках хранится журнал.
а также в чем разница межде

flex группы vs packed_meta_blocks

в чем разница между использованием просто флекс групп
и использованием опции -E packed_meta_blocks

сразу скажу вывод исследования:  флекс группы перетаскивают в голову 
такие метаданные как (block bitmap, inode bitmap, inode table) с других блок групп
но при этом журнал он нетрогается. в ext3 журнал хранится в голове диска
а в ext4 он хранится в серединедиска.
опция -E packed_meta_blocks по сравнениб с фоекс группами дает то что она еще
претаскивает журнал в голову диска. если спросить а что хранится ближе к голове диска
битмап метаданные или журнал? ответ - журнал переносится самым последним. он в самом сзади
по сравнени с друними металанными.
также из мелочей если юзаем опцию -E packed_meta_blocks то у нас создается одна флекс группа
которая вокчает в себя все блоки групп а количество флекс групп которое можно посмотреть 
в супер блоке через dumpe2fs там будет написано вранье. то число которое там указано 
оно не бдует озанчать ничего. по факту еще раз скажу все блок группы будут включены в состав
одной единой и единстенной флекс гурппы.

поехали


инода журнала 8.
но блоки журнала лежат в жопе диска.
а еще в dumpe2fs покывазются не блоки на диске а офссет
и еще походу журнал пишется с конца и стремится к началу.


# dumpe2fs -h ./5G-ext3.txt  | grep -i journal
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype sparse_super large_file
Journal inode:            8
Journal backup:           inode blocks
Journal features:         (none)
Total journal size:       64M
Total journal blocks:     16384
Journal sequence:         0x00000001
Journal start:            0
root@vm1:/mnt# 



ext3 + journal (раздел 5G) \ параметры форматрования дефолтовые

Inode: 8   Type: regular    Mode:  0600   Flags: 0x0
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131208
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
 atime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
 mtime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
crtime: 0x64ab150e:00000000 -- Sun Jul  9 20:14:06 2023
Size of extra inode fields: 32
BLOCKS:
(0-11):518-529, (IND):530, (12-1035):531-1554, (DIND):1555, (IND):1556, (1036-2059):1557-2580, (IND):2581, (2060-3083):2582-3605, (IND):3606, (3084-4107):3607-4630, (IND):4631, (4108-5131):4632-5655, (IND):5656, (5132-6155):5657-6680, (IND):6681, (6156-7179):6682-7705, (IND):7706, (7180-8203):7707-8730, (IND):8731, (8204-9227):8732-9755, (IND):9756, (9228-10251):9757-10780, (IND):10781, (10252-11275):10782-11805, (IND):11806, (11276-12299):11807-12830, (IND):12831, (12300-13323):12832-13855, (IND):13856, (13324-14347):13857-14880, (IND):14881, (14348-15371):14882-15905, (IND):15906, (15372-16383):15907-16918
TOTAL: 16401

кстати в debugfs вот этот параметр 
Blockcount: 131208
эта такаяже хуйня как и в команде stat из баша. 
это типа вот этот виртуалные ебанутый блок равный всегда 512. тоесть это не блок Фс.
это пиздец. тоесть его в приоде нет этого блока . просто его уножае на 512 и получаем
сколько байт на диске по факту занимает файл.  в данном случае файл журнала
офигенно misleading штучка. суки. 

поэтому полное совдпание из dumpe2fs мыимеем что журнал 64M

из debugfs мы имеем 
Size: 67108864    
это виртальный размер файла (такакже как утилите stat из баш) который
к реальному размеру файла на стораже отношения не имеет
а вот это
Blockcount: 131208
это уже реальный размер на диске тольо его надо уножить на 512. получаем
67178496 вобщем теже самые 64МБ.


но нас интерсуе другое - в каких блоках ФС хранится тело файла журнала

здесь что важно увидеть. вот то что в скобках 
(0-11):518-529
это офссет внутри файла тоесть
мы из dumpe2fs уже знаем что 
Total journal blocks:     16384
аткже мы это можем и высчиать из debugfs. вычисляем сколько байт на диске физически
занимает файл (Blockcount: 131208 ) * 512 / 4K(размер фс блока) = 16401 блоков.

короче 16384 блока ФС занимает файл журнал. это значит что его офссет меняется от 0 до 16383.
так вот в этой записи (0-11):518-529
(0-11) это офссет внутри файла. тесть его номера его байтов если бы мы их читали из 
клиента ос задавая параметр seek\skip тоесть это то как файл выглядит изнутри. он же незнает
что его тело на диске по частям записано. изнутри файла он монолитный. короче то что в скбоках
это оффсет. а то что дальше это адрес блока на ФС где хранится этот офсссет!
ext3 не поддерживает эксетенты. поэтому это прям блоки ФС их адерса.

ты спросишь как это проверить? а в дебагфс есть супер команда.
задаемшь ей офссет и она пишет адрес блока 

debugfs:  bmap <8> 12
531

смотрим наверх
(12-1035):531-1554
дейтвительно офссет 12 имеет адрес фс блока 531


тогда получается что у нас файл журнала на ext3 хранится в блока ФС  518-16918
причем непрерывно.
эти блоки принадлжеат Block Group "0"
мы полчили исчерапывающую информацию.
получется ext3 хранит файл журала единым куском в своем головном нулевом блоке групп.

все прсто и понятно. мы ответили на вопрос - а где же на фс ext3 лежит хранится
файл журнала.







ext4 раздел 5G опцииф формтания деолфтовые

# file ./5G.txt
./5G.txt: Linux rev 1.0 ext4 filesystem data, UUID=7de15353-748d-44fe-88e3-225c5b3a9b78 (extents) (64bit) (large files) (huge files)


# dumpe2fs -h  ./5G.txt  | grep -i journal
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Journal inode:            8
Journal backup:           inode blocks
Journal features:         (none)
Total journal size:       64M
Total journal blocks:     16384
Journal sequence:         0x00000001
Journal start:            0


видим что размер файла журнала 64МБ
за негоотвечает инода 8
занимает 16384 фс блока

# debugfs
> stat <8>
Inode: 8   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131072
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
 atime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
 mtime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
crtime: 0x64ab15ff:00000000 -- Sun Jul  9 20:18:07 2023
Size of extra inode fields: 32
Inode checksum: 0x3ba509ea
EXTENTS:
(0-16383):557056-573439

опятд же 
(0-16383):557056-573439

то что в скоблках это офссет файла. от 0 до 16383 . тоесть 16383 блока ФС он занимает.
однако то что после двоеточия это уже не адреса фс блоков это уже экстенты указаны.


>debugfs:  bmap <8> 0
557056


вводим еще одну интерсуную команду
>debugfs:  dump_extents <8>
Level Entries       Logical          Physical Length Flags
 0/ 0   1/  1     0 - 16383  557056 -  573439  16384 

кхм.. получется что эти экстенты они в данном случае равны блокам ФС.
получаетс что файл журнала лежит в блоках

557056 -  573439

выясним какой это блок группа. предварительно это 17 блока группа

всего у меня блок групп 0-39 тоесть 40 штук.

17-я блок группа выглядит вот так

Group 17: (Blocks 557056-589823) csum 0x4682 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 524289 (bg #16 + 1), csum 0xbdfbed1a
  Inode bitmap at 524305 (bg #16 + 17), csum 0x00000000
  Inode table at 524832-525343 (bg #16 + 544)
  16384 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes
  Free blocks: 573440-589823
  Free inodes: 139265-147456

отсюда мы видим что блок битмап, инода битмап, инода тейбл они все на самом деле
нележат в этой блок группе они все лежат в группе #16. потому что по  дфеолту на ext4
при фортватировании активируются флек группы с парамертром 4. тесть в одной флекс группе
4 блок группы. поэтому эта блок группа она полность пустая от метаанных. поэтому в ней
с превого блока можно заимаеть блоки под даные. вот фс и заняла блоки 557056 -  573439
под файл журнала. кстати видно что первый своодный блок это 573440
    Free blocks: 573440-589823
тость ровно следущий после последнего блока журанала 573439
видно что журна лежит одним куском на диске по середине. я думаб логика тут такая
что так как запись метаанных идет два раза  - вначале в журнал а потом уже на диск там где реально будут лежать метаданные  то логично что по теории статистики если мы поместим  журнал
посередине он будет равноудален от всех точек диска. если это шпиндельный диск то 
головке диска придется дергаться мегьше всего. чем если бы журнал лежал ндето в другом
месте диска. удивительно!!!!






ext4, тот же раздел 5G (отфратмтирован с опцией -E packed_meta_blocks)
# dd if=/dev/zero of=./5G-ext4-2.txt bs=1M count=0 seek=5120
# mkfs.ext4 ./5G-ext4-2.txt -E packed_meta_blocks

> stat <8>
Inode: 8   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131072
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 atime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 mtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
crtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
Size of extra inode fields: 32
Inode checksum: 0x08a0aed8
EXTENTS:
(0-12200):20567-32767, (12201-16383):32770-36952
(END)

> dump_extents <8>
Level Entries       Logical          Physical Length Flags
 0/ 0   1/  2     0 - 12200   20567 -   32767  12201 
 0/ 0   2/  2 12201 - 16383   32770 -   36952   4183 

 видим что файл журнала разбит на две части но они лежат совсем рядом.
 вот эти блоки 20567 - 32767 лежат в группе блоков "0"
 вот эти блоки 32770 - 36952 лежат в группе блоков "1"

 ага.!! итак да! мы видим вот что . если мы заюзаем фичу flexible групп
 то у нас метаданные (block bitmap, inode bitmap  . inode _table) переползают
 из блок групп в головную блок группу. есди мы заддим очень большое число -G при форматиорвании
 то у нас все метаданные со всех блок групп переползут в головной блок групп. но!
 это ниак не повлияет на то куда будет засунут журнал. мы это увидели в прошлом примере.
 там актироыван флекс группы а журнал лежит по середине диска.

 а вот опция -E packed_meta_blocks она нетлоко метаданные (block bitmap, inode bitmap  . inode _table) перетаскивает в голову диска но и перетаскивает журнал файл тоже в голову диска.
причем что еще интересно. что число групп указанное в настойке flex group 
оно игнриуеся при создании фс

показываю 

# dumpe2fs  ./5G-ext4-2.txt  -h | grep -i flex
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem features:      has_journal ext_attr dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Flex block group size:    16

тоесть ичсло групп в флекс группе 16. это значит что 0-15 группы сидят в одной флекс гурппе
а группы 16-31 должны сиеть в дрйгоу флекс группе. однако


# dumpe2fs  ./5G-ext4-2.txt  | grep -E "^Group |Block bitmap at"
dumpe2fs 1.46.5 (30-Dec-2021)
Group descriptor size:    64
Group 0: (Blocks 0-32767) csum 0x6e73 [ITABLE_ZEROED]
  Block bitmap at 2 (+2), csum 0xef300295
Group 1: (Blocks 32768-65535) csum 0x0ae9 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 3 (bg #0 + 3), csum 0x93cd52b6
Group 2: (Blocks 65536-98303) csum 0xa502 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 4 (bg #0 + 4), csum 0x00000000
Group 3: (Blocks 98304-131071) csum 0x4e22 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 5 (bg #0 + 5), csum 0x00000000
Group 4: (Blocks 131072-163839) csum 0x578f [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 6 (bg #0 + 6), csum 0x00000000
Group 5: (Blocks 163840-196607) csum 0xbcaf [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 7 (bg #0 + 7), csum 0x00000000
Group 6: (Blocks 196608-229375) csum 0x6fe3 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 8 (bg #0 + 8), csum 0x00000000
Group 7: (Blocks 229376-262143) csum 0x84c3 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 9 (bg #0 + 9), csum 0x00000000
Group 8: (Blocks 262144-294911) csum 0x9bcb [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 10 (bg #0 + 10), csum 0x00000000
Group 9: (Blocks 294912-327679) csum 0x70eb [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 11 (bg #0 + 11), csum 0x00000000
Group 10: (Blocks 327680-360447) csum 0xfc08 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 12 (bg #0 + 12), csum 0x00000000
Group 11: (Blocks 360448-393215) csum 0xe223 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 13 (bg #0 + 13), csum 0x00000000
Group 12: (Blocks 393216-425983) csum 0x0e85 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 14 (bg #0 + 14), csum 0x00000000
Group 13: (Blocks 425984-458751) csum 0x10ae [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 15 (bg #0 + 15), csum 0x00000000
Group 14: (Blocks 458752-491519) csum 0x8379 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 16 (bg #0 + 16), csum 0x00000000
Group 15: (Blocks 491520-524287) csum 0x9d52 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 17 (bg #0 + 17), csum 0x00000000
Group 16: (Blocks 524288-557055) csum 0x7a1b [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 18 (bg #0 + 18), csum 0x00000000
Group 17: (Blocks 557056-589823) csum 0x6430 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 19 (bg #0 + 19), csum 0x00000000
Group 18: (Blocks 589824-622591) csum 0x1dd8 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 20 (bg #0 + 20), csum 0x00000000
Group 19: (Blocks 622592-655359) csum 0x03f3 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 21 (bg #0 + 21), csum 0x00000000
Group 20: (Blocks 655360-688127) csum 0xef55 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 22 (bg #0 + 22), csum 0x00000000
Group 21: (Blocks 688128-720895) csum 0xf17e [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 23 (bg #0 + 23), csum 0x00000000
Group 22: (Blocks 720896-753663) csum 0xbe9a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 24 (bg #0 + 24), csum 0x00000000
Group 23: (Blocks 753664-786431) csum 0xa0b1 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 25 (bg #0 + 25), csum 0x00000000
Group 24: (Blocks 786432-819199) csum 0x4ab2 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 26 (bg #0 + 26), csum 0x00000000
Group 25: (Blocks 819200-851967) csum 0xa192 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 27 (bg #0 + 27), csum 0x00000000
Group 26: (Blocks 851968-884735) csum 0x2d71 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 28 (bg #0 + 28), csum 0x00000000
Group 27: (Blocks 884736-917503) csum 0xc651 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 29 (bg #0 + 29), csum 0x00000000
Group 28: (Blocks 917504-950271) csum 0xdffc [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 30 (bg #0 + 30), csum 0x00000000
Group 29: (Blocks 950272-983039) csum 0xc1d7 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 31 (bg #0 + 31), csum 0x00000000
Group 30: (Blocks 983040-1015807) csum 0x33ee [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 32 (bg #0 + 32), csum 0x00000000
Group 31: (Blocks 1015808-1048575) csum 0x2dc5 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 33 (bg #0 + 33), csum 0x00000000
Group 32: (Blocks 1048576-1081343) csum 0xa6e9 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 34 (bg #0 + 34), csum 0x00000000
Group 33: (Blocks 1081344-1114111) csum 0xb8c2 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 35 (bg #0 + 35), csum 0x00000000
Group 34: (Blocks 1114112-1146879) csum 0xc12a [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 36 (bg #0 + 36), csum 0x00000000
Group 35: (Blocks 1146880-1179647) csum 0xdf01 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 37 (bg #0 + 37), csum 0x00000000
Group 36: (Blocks 1179648-1212415) csum 0x33a7 [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 38 (bg #0 + 38), csum 0x00000000
Group 37: (Blocks 1212416-1245183) csum 0x2d8c [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 39 (bg #0 + 39), csum 0x00000000
Group 38: (Blocks 1245184-1277951) csum 0x0bcb [INODE_UNINIT, BLOCK_UNINIT, ITABLE_ZEROED]
  Block bitmap at 40 (bg #0 + 40), csum 0x00000000
Group 39: (Blocks 1277952-1310719) csum 0xc876 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 41 (bg #0 + 41), csum 0x5208bd0f


видно что во всех блок группах для block bitmap идет воттакая запист

(bg #0 + 9)

которая говорит о том что метаданные хранятся в нулевой блок группе для всех блок груп!!
а как яуже сказал если у нас задано что во флекс группу входит 16 блок групп
то начиная с 17-ой блок группы метданные должны хранится в 16-ой блок группе.

поэтому я и говрю что при форматиорвании с опцией -E packed_meta_blocks
у нас параметр колько групп входит во флекс групу игнориуется. и все блок группы
входят в первую флекс группу.


так вот еще один прикол если мы возмьем большой диск , отфоформатируем
его с параметром -E packed_meta_blocks то фс нужно метаданные со всемх блок групп
записать в первой блок группе. но у нас же число блоков 
в каждой группе так и останеся 32768 , а метаданных будет сктолько много
что они не влезут не только в группу блоков "0" но и еще и дальнейшие группы тоже.
тоесть я хочу сказать что метаданные котоыре будут собраны со всего диска 
они будут занимать огромную кучу первых групп блоков. щас покажу на примере.

делаем диск размером 10TB чеерз спарс файлы

# dd if=/dev/zero of=./10T.txt bs=1G count=0  seek=10000
# mkfs.ext4 ./10T.txt -E packed_meta_blocks

# dumpe2fs  ./10T.txt |   grep -E "^Group |Block bitmap at|Free blocks" | less
Group 0: (Blocks 0-32767) csum 0xbe8e [ITABLE_ZEROED]
  Block bitmap at 1251 (+1251), csum 0x62a284df
  Free blocks: 
Group 1: (Blocks 32768-65535) csum 0x8b16 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1252 (bg #0 + 1252), csum 0x62a284df
  Free blocks: 
Group 2: (Blocks 65536-98303) csum 0x4877 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1253 (bg #0 + 1253), csum 0x62a284df
  Free blocks: 
Group 3: (Blocks 98304-131071) csum 0x7acd [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1254 (bg #0 + 1254), csum 0x62a284df
  Free blocks: 
Group 4: (Blocks 131072-163839) csum 0xcbb3 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1255 (bg #0 + 1255), csum 0x62a284df
  Free blocks: 
...

видно что фри блоков просто нет. все забито метаданными
и так будет очень долго до 637 группы блоков

...

Group 637: (Blocks 20873216-20905983) csum 0x3d42 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1888 (bg #0 + 1888), csum 0x62a284df
  Free blocks: 
Group 638: (Blocks 20905984-20938751) csum 0x40eb [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1889 (bg #0 + 1889), csum 0xa38fbe72
  Free blocks: 20919664-20938751

тогда толко появяттся свободные блоки.
группы блоков с 0 по 637 это 638 групп по 32768 блоков это ~ 80GB метаданных породил
раздел на 10T

причем например все блок битмапы будут смотреть в групу блоков "0".
а например инод битмапы будут все смотреть на группу блоков "2"

Group 1: (Blocks 32768-65535) csum 0x8b16 [INODE_UNINIT, ITABLE_ZEROED]
  Block bitmap at 1252 (bg #0 + 1252), csum 0x62a284df
  Inode bitmap at 82503 (bg #2 + 16967), csum 0x00000000

посмотрим где  лежит файл журнала

> dump_extents <8>
Level Entries         Logical                Physical Length Flags
 0/ 1   1/  1      0 - 262143    1605603              262144
 1/ 1   1/ 19      0 -     81     163758 -     163839     82 
 1/ 1   2/ 19     82 -    110     229347 -     229375     29 
 1/ 1   3/ 19    111 -    139     294883 -     294911     29 
 1/ 1   4/ 19    140 -    168     819171 -     819199     29 
 1/ 1   5/ 19    169 -    197     884707 -     884735     29 
 1/ 1   6/ 19    198 -    225    1605604 -    1605631     28 
 1/ 1   7/ 19    226 -    254    2654179 -    2654207     29 
 1/ 1   8/ 19    255 -    283    4095971 -    4095999     29 
 1/ 1   9/ 19    284 -    312    7962595 -    7962623     29 
 1/ 1  10/ 19    313 -    341   11239395 -   11239423     29 
 1/ 1  11/ 19    342 -    370   20479971 -   20479999     29 
 1/ 1  12/ 19    371 -  33138   20657891 -   20690658  32768 
 1/ 1  13/ 19  33139 -  65906   20690659 -   20723426  32768 
 1/ 1  14/ 19  65907 -  98674   20723427 -   20756194  32768 
 1/ 1  15/ 19  98675 - 131442   20756195 -   20788962  32768 
 1/ 1  16/ 19 131443 - 164210   20788963 -   20821730  32768 
 1/ 1  17/ 19 164211 - 196978   20821731 -   20854498  32768 
 1/ 1  18/ 19 196979 - 229746   20854499 -   20887266  32768 
 1/ 1  19/ 19 229747 - 262143   20887267 -   20919663  32397 

насколько можно судить журнал размазан но основаня часть лежит
в группах блоков 631-638

моя идея такая - кога мы юзаем опцию -E packed_meta_blocks
то вначале в голову перетаскиваются block битмапы, заними инод битмаапы,
за ними инод тейблы. а уже самым последним идет файл журнала.
поэтому он как бы в голове диска но не в самой голове. 
он в самом хвосте из тех метаанных котоые перетаскиватся в голову диска

ксатии эта мысль подтверждается на примере когда унас был раздел всего 5G
когда у нас все метаданные с диска умещались в одну блок группу нулевую

напоминаю
ext4, тот же раздел 5G (отфратмтирован с опцией -E packed_meta_blocks)
# dd if=/dev/zero of=./5G-ext4-2.txt bs=1M count=0 seek=5120
# mkfs.ext4 ./5G-ext4-2.txt -E packed_meta_blocks

> stat <8>
Inode: 8   Type: regular    Mode:  0600   Flags: 0x80000
Generation: 0    Version: 0x00000000:00000000
User:     0   Group:     0   Project:     0   Size: 67108864
File ACL: 0
Links: 1   Blockcount: 131072
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 atime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
 mtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
crtime: 0x64ab294e:00000000 -- Sun Jul  9 21:40:30 2023
Size of extra inode fields: 32
Inode checksum: 0x08a0aed8
EXTENTS:
(0-12200):20567-32767, (12201-16383):32770-36952
(END)

видно что в нулевой  блок группе  файл журнала лежит в самом хвосте нулевой блок группы
 20567-32767  и даже он в первую блок группу залезает  32770-36952

это еще раз подтверждает ту мысль что  при исползовании опции -E packed_meta_blocks
вначале перетаскиваются в голову диска другие метаданые а  файл журнала перетасиквается
последним. и он как бы да - он уже не в цетре диска. но по сравненеи с друними метааданными
он в самом хвосте.

кстати неудвилттельно что файл журнала идет в самом хвосте. потому что 
журнал это всего навсего файл. хоть у него и нет хардинка то есть его нет ни в одном
каталоге. но это всего лишь файл.  а файлы их тела конечно же в блок группах 
сидят только после группы блоков отвечающих за метаданные.
потому что кажая группа блоков по крайней мере классическая
группа блоков она же имеет известный вид:
-суперблок или его копия или его нет
- group descriptor или его копия или его нет
- data block bitmap или его нет (если он хранится в другой блок группе)
- inode bitmap или его нет (если он хранится в другой блок группе)
- inode table или его нет (если он хранится в другой блок группе)
- дата блоки

правда неочень понятно а где хрантяс метаданные флекс группы.
тем не менее. соласно этой схеме файл журнала его тело может хранится только в дата блоках
а дата блоки они всегда находятся в жопе по отношению к метаанным. пэтмоу журнал его тело
всегда лежит позади блока метаданных в группе блоков.
также понятно что видно из схемы что после груп дескриптра идет data block bitmap 
и если у нас флекс группа то туда будут зансены все датаблоки всех битматов всех групп
входящтих  в флекс группу и поэтому если таких блоков много то дата блоки группы могут 
законитться и инод битмапы будут идти уже тлько после того как собраны все дата блок битмапы.
также мне кажется что метаданные флекс гурппы они вобщемто нетребуются потомучто 
метаданные (битмапы и инод тейблы) их место сохранения неимеет никакого значения потому
что в них хранятся абсолютные занчегия адресов блоков. поэтому будут ли метаданные
лежат в одном месте или разбросаны по всему диску без разницы. надо лишь 
поправить занчения в GDT (group descritpor table) типа того.




конец исселедования
@@@@@@@@@@@@@@


посмотрим еще один прикол


изготовим спарс файл 2Т
# dd if=/dev/zero of=./2T.txt bs=1G count=0 seek=2048

форматироуем файл с параметром 16 групп в флекс группе
# mkfs.ext4 ./2T.txt -G 16

проверяем что в группе флекс нахрится 16 групп 
# dumpe2fs ./2T.txt -h | grep -i flex
Flex block group size:    16

смотрим что там с инодами
# dumpe2fs ./2T.txt  -h | grep -i inode
dumpe2fs 1.46.5 (30-Dec-2021)
Inode count:              134217728
Free inodes:              134217717
Inodes per group:         8192
Inode blocks per group:   512
First inode:              11
Inode size:           256
Journal inode:            8
Journal backup:           inode blocks

видим что в одной блок группе у нас занимается 512 блоков ФС 

также мы юзаем флекс группы. это значит что метаданные с других групп будут
пееремещены в головную группу. так вот посмотрим какая инфо об этом будет в описании
головной группы об этом. тоест будет ли там инфо о битмапах со всех групп
или только о битмапах этой группы. 

#  dumpe2fs ./2T.txt  | less

Group 0: (Blocks 0-32767) csum 0x7440 [ITABLE_ZEROED]
  Primary superblock at 0, Group descriptors at 1-256
  Block bitmap at 257 (+257), csum 0x55eb7455
  Inode bitmap at 273 (+273), csum 0x75ad3ccb
  Inode table at 289-800 (+289)
  24282 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes
  Free blocks: 8486-32767
  Free inodes: 12-8192

пощитаем сколько у нас в 2ТБ содержится групп блоков
(2*1024*1024*1024)/4 = 536870912 блоков.
значит групп блоков 536870912:32768=16384 группы блоков

что мы видим из дампа?
0 блок = суперблок
1-256 блок  = это груп дескриптор. груп дескриптор это структура которая содержит
в себе описание всех групп блоков а не толлько 16-ти групп блоков которые мы указали
как параметр флекс группы. тоестьгурпп дескриптор содержит описаниа всех 16384  групп
блоков. согласно описанию ext4  в таблице GDT запись для одной группы блоков по длине
равно 64 байта (при условии что фс создана с фичей 64bit  а так обычно и есть. фича 64бит дает то что макс колво блоков на фс опредяется число 64бит длинной. проверяется наличие этой фичи через dumpe2fs строчка features). кстати то что одна запись для группы блоков в таблице
GDT заниает 64 байта можно увидеть тжое через dumpe2fs

# dumpe2fs ./2T.txt -h | grep -i  descriptor
dumpe2fs 1.46.5 (30-Dec-2021)
Group descriptor size:    64

так вот если унас 16384 группы блоков и на одну группу у нас надо 64 байта в таблице GDT
этозначит что суммарно таблицаа GDT будет заниать (16384 * 64) / 1024 /4 =  256 блоков
что собственно мы и видим из дампа. 
    Group descriptors at 1-256
далее двигаем
    Block bitmap at 257 (+257), csum 0x55eb7455
блок битмап нахордится по адресу 257 и для одной группы блоков занимает 1 блок
далее мы видим что 
    Inode bitmap at 273
инода битмап начинается с блока 273
и вот тут я вижу подставу которую и хотел обозначить.
возникает вопрос а что находится в блоках между 257 где 
лежит битмап от этой группы блоков до блока 273 где лежит
битмап инодов от этой группы блоков.
чтоэто за провал? а ответ такой что там лежат битмапы еще от 15-ти групп блоков
действиетлно в 257 лежит датаблок битмап от этой группы блоков. плюс 15 блоков котоыре
отвечают за дата блок битмапы еще 15-ти групп блоков это будет блок 272.
и следущий блок 273 это уже битмап инодов от этой группы блоков.

почему в этой группе блоков хранится еще 15 битмапов от других групп блоков? потому
что мы юзаем фичу флес группы. мы указали при формтировании -G 16 это значит
что  датаблок битмапы , инода битмапы, инода тейблы от 16 групп будут собраны 
в головной группе. а в дочернмх группах этого ничего не будет(там тлоько будут дата блоки
и копии суперблока и копии GDT). поэтому у нас туту битмапы от чужих групп блоков.
поэтому битмап инодов начинается не в 258 а в 273.
разобрались.
так вот  я считаю что это свинство что dumpe2fs это не выводит на экране. об этом надо 
догадываться. тоесть он выводит на экране что якбоы в этой группе блоков у нас только 
один битмап даат блоков
  Block bitmap at 257 (+257), csum 0x55eb7455
  Inode bitmap at 273 (+273), csum 0x75ad3ccb
и только приглядывась  к тому что инода битмап начинается с какогто стрмногоадреса
мы врдуг узнаем что в этой группе блоков есть еще битмапы. я считаю что это свиноство
со стороны dumpe2fs. об этом я и хотел сказать.

сотственнно смотрим дальше
  Inode bitmap at 273 (+273), csum 0x75ad3ccb
  Inode table at 289-800 (+289)
мы понимаем что инода битмап в 273 это инода битмап от этой группы блоков.
но между 273 и 289 сидят еще 15 инода битмапов от друних групп блоков
в блоках 289-800 у нас сидит инода тейбл от этой группы блоков. подчеркиваю именно 
от этой группы блоков. хотя опять ж вопрос что значит от этой группы блоков? ничто немешает
этим инодам иметь в себе ссылки на датаблоки из других групп блоков. на самом деле.
как уже мы видели выше в дамп2фс указано сколько блоков занимает инод тейбл в для каждой
группы блоков (512 блоков)

    # dumpe2fs ./2T.txt -h | grep -i  "Inode blocks per group"
    dumpe2fs 1.46.5 (30-Dec-2021)
    Inode blocks per group:   512

проверяем 800-289+1=512 блоков
кстати размер иноды 256 байт у нас

    # dumpe2fs ./2T.txt -h | grep -i  "Inode size"
    dumpe2fs 1.46.5 (30-Dec-2021)
    Inode size:           256

значит в одной группе блоков у нас 512×4096÷256 = 8192 иноды
таки есть

    # dumpe2fs ./2T.txt -h | grep -i  "Inodes per"
    dumpe2fs 1.46.5 (30-Dec-2021)
    Inodes per group:         8192

так я это к чему что у нас же после таблицы индов нашей группы блоков дальше идут
таблицы инодов оставщихся 15-ти групп блоков каждяа из которых по 512 блоков итого

    512*15=7680 блоков


значит сморим в дамп
 Inode table at 289-800 (+289)
  24282 free blocks, 8181 free inodes, 2 directories, 8181 unused inodes
  Free blocks: 8486-32767
  Free inodes: 12-8192

значии инода таблица  у нас не заканчивыатеся на 800-ом блоке а
идет до блока 
    800+7680=8480 
значит первый свободный блок у на 8481
однако мы видим что первый свободный блок это 8486
значит мы ошиблись в расчетах ? нет.
просто эти дата блоки действиельно уже заняты чем то полезным.
щас мы узнаем чем

команда icheck позволяет узнать к каой иноде относится такой то фс блок.
это очень круто!

debugfs:  icheck 8481
Block   Inode number
8481    2

получатется что блок 8481 отноистя к телу иноды 2. а инода 2 это всегда иноду "/" коневого
каталога ! вот и разгадка!

проверим остальные блоки.

debugfs:  icheck 8482
Block   Inode number
8482    11

11 инода это обычно каталог "lost+found"
это спец каталог в который fsck создает хадлиники для тех инод котоыре есть на 
фс но на них нет никаких хардлинков ни в какой каталог. приколно.
если удаить этот катлог. то его как пишут (поему?) нелтзя созвать руками. видимо
потомучто будет не та инода отвечать за этот каталог. а надо пересоздавать с помщью 
утилиты  mklost+found
    mklost+found  is  used  to create a lost+found directory in the current working directory on a Linux second extended file system.  There is normally a lost+found directory in the
    root directory of each filesystem.
    mklost+found pre-allocates disk blocks to the lost+found directory so that when e2fsck(8) is being run to recover a filesystem, it  does  not  need  to  allocate  blocks  in  the
    filesystem to store a large number of unlinked files.  This ensures that e2fsck will not have to allocate data blocks in the filesystem during recovery.
обаделдт. все рано непонятно. зачем так условжнять. почему бы просто руками несоздаьт ивсе.
что значит pre-allocate блоки для папки lost+found?

а вот и частичный ответ
>debugfs:  icheck 8483
Block   Inode number
8483    11
>debugfs:  icheck 8484
Block   Inode number
8484    11
>debugfs:  icheck 8485
Block   Inode number
8485    11

прям несколько блоков принадлежит каталогу lost+found

и как указано в дампе 8486 уже свободный блок
>debugfs:  icheck 8486
Block   Inode number
8486    <block not found>

вот и решилась загадка почему свободный бок начианается с 8486


| чуть уйду в сторону

как узнать все блоки которыми заведут инода (это удбнее чем это смотреть в stat)
    >debugfs:  blocks <12>
    66048 

как посмотреть hex\ascii дамп блока ФС (очень удобно)
    >debugfs:  block_dump 66048
    0000  6578 7434 2031 2e74 7874 0a00 0000 0000  ext4 1.txt......
    0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
    *

тока надо помнить что почему то левая колнока котоаря покзыват оффсет 
 у этих дебилов в OCT(востмеричном) формате


| восстановление удаленного файла
| rm
| unlink

если мы сделали файлу unlink или rm (тоест по факту мы удалили хардлинк )
но при этом если у нас есть хотя бы одна прога которая это файл 
держит открытым то сама инода еще не обнулена (подробнее чторельано просиходит
при unlink rm смотри ниже) то можно все исправить.

если у нас есть проога которая держит файл открытым.
и в тоже время мы через консоль сделаои 

# rm /mnt/ext3/45.txt 

то по факту происходит следущее - ядро удаляет entry в иноде которая отвечает 
за каталог и  уменьшает значение "link" в иноде которая отвечает за тело файла.
поле "link" в иноде отвечает за количество хардлинков ведущих к иноде отвечающей
за файл.

вот как это выглядит
пусть инода отвечающая за файл = 12

> debugfs:  mi  <12>
                          Mode    [0100644] 
                       User ID    [0] 
                      Group ID    [0] 
                          Size    [7] 
                 Creation time    [1688964796] 
             Modification time    [1688963968] 
                   Access time    [1688964788] 
                 Deletion time    [0] 
                    Link count    [0]    <===== было [1] стало [0]
              Block count high    [0] 
                   Block count    [8] 
                    File flags    [0x0] 
                    Generation    [0x6a53ea95] 
                      File acl    [0] 
           High 32bits of size    [0] 
              Fragment address    [0] 
               Direct Block #0    [17408] 
               Direct Block #1    [0] 
               Direct Block #2    [0] 
               Direct Block #3    [0] 
               Direct Block #4    [0] 
               Direct Block #5    [0] 
               Direct Block #6    [0] 
               Direct Block #7    [0] 
               Direct Block #8    [0] 
               Direct Block #9    [0] 
              Direct Block #10    [0] 
              Direct Block #11    [0] 
                Indirect Block    [0] 
         Double Indirect Block    [0] 
         Triple Indirect Block    [0] 


тоесть если файл открыт кемто. но другой процесс запустил rm
то поле "link" уменьшится на 1. было 1 станет 0.

также важно что поле "Deletion time"    [0] не будет изменено. какбыло 
0 так и останется 0.

также важно что указатели на  блоки где лежит тело файла они пока еще не будут
обнулены я говорб про "Direct Block" и "Indirect Block"
тоесть укатели на тело файла пока еще не потеряны.

мы можем через debugfs прибавит link обратно на [1] но это нам не поможет.
об это щас поясню далее.

также у иноды будет сброшен "in-use" флаг (команлы testi\clri\seti)

так вот 
как только мы закроем программу которая имела открытым наш файл
то произодйет следущая перетрубация с инодой


> debugfs:  mi <12>
                          Mode    [0100644] 
                       User ID    [0] 
                      Group ID    [0] 
                          Size    [0] 
                 Creation time    [1688964953] 
             Modification time    [1688964953] 
                   Access time    [1688964788] 
                 Deletion time    [1688964953] 
                    Link count    [0] 
              Block count high    [0] 
                   Block count    [0] 
                    File flags    [0x0] 
                    Generation    [0x6a53ea95] 
                      File acl    [0] 
           High 32bits of size    [0] 
              Fragment address    [0] 
               Direct Block #0    [0] 
               Direct Block #1    [0] 
               Direct Block #2    [0] 
               Direct Block #3    [0] 
               Direct Block #4    [0] 
               Direct Block #5    [0] 
               Direct Block #6    [0] 
               Direct Block #7    [0] 
               Direct Block #8    [0] 
               Direct Block #9    [0] 
              Direct Block #10    [0] 
              Direct Block #11    [0] 
                Indirect Block    [0] 
         Double Indirect Block    [0] 
         Triple Indirect Block    [0] 

у нее опять будет уменьшен "link" с 1 до нуля. тоесть наша правка на предудыщуем
этапе не помогает. 
у нее будет Deletion time    изменен с [0]
до чегонибудь     [1688964953]   ( у нормальной инды которая обслуживает файл deleteion должен быть равен нулю. так что это плохо)

и самое ужасное что будут обнулены все поля "Direct Block" и "indirect block"
тоесть мы потеряли спсок блоков с телом файла. при этом  если мы знаем блоки (записали на бмуажке) то сами блоки с телом нетронуты. но их список потерян.

поэтому я предлагаю не мудить с попыткой оживить иноду которая будет потерта системой.

я выбираю другой путь восстанолвения доступа к файлу.
алгоритм такой:
во првых важно чтобы файл по прежнему был открыт хотть какойто программой. потому что 
если сичезнет последний откртый дескриптор то инода файл будет обнулена. 
далее- заходим в debugfs, копируем тело иноды в другую иноду, правим эту другую иноду,
выставляем ей флаг "in-use", создаем entry в папке (создаем хардлинк)
выходим из debugfs. отстаналвиливает программу которая делржала файл открытым.
отмонтируем фс (потому что не знаю почему но измеенения в папках появятся только после ремаунта фс), запускаем принудтельную проверку фс, потому что с инодами то мы помудили
но там еще надо исрпавлять другие метаданные , руками это невозможно а e2fsck все поправит.
монтрируем обратно фс.  файл должен быть на месте. поехали

# echo "12232" /mnt/ext3/45.txt

открываем его на чтение скажем в mcedit
удаляем его хардлинк

# rm /mnt/ext3/45.txt

заходим в дебагфс с флагом на запись

# debugfs -w /mnt/5G-ext3.txt

в другой консоли смотрим какой был номер иноды для этого файла

# lsof | grep 45.txt
mc         722                           root   12r      REG                7,5           7         12 /mnt/ext3/45.txt (deleted)

получется номер иноды = 12

debugfs:  copy_inode <12> <30>    # копириуем спец иноды 12 в новую иноду 30
debugfs:  mi <30>                 # редактируем иноду 30
                          Mode    [0100644] 
                       User ID    [0] 
                      Group ID    [0] 
                          Size    [7] 
                 Creation time    [1688966519] 
             Modification time    [1688963968] 
                   Access time    [1688966473] 
                 Deletion time    [0] 0   # на всякий случай прям еще руками проставляем 0
                    Link count    [0] 1   # меняем число хардлинков на 1
              Block count high    [0] 
                   Block count    [8] 
                    File flags    [0x0] 
                    Generation    [0xc3c52c67] 
                      File acl    [0] 
           High 32bits of size    [0] 
              Fragment address    [0] 
               Direct Block #0    [17408] 
               Direct Block #1    [0] 
               Direct Block #2    [0] 
               Direct Block #3    [0] 
               Direct Block #4    [0] 
               Direct Block #5    [0] 
               Direct Block #6    [0] 
               Direct Block #7    [0] 
               Direct Block #8    [0] 
               Direct Block #9    [0] 
              Direct Block #10    [0] 
              Direct Block #11    [0] 
                Indirect Block    [0] 
         Double Indirect Block    [0] 
         Triple Indirect Block    [0] 
debugfs:  
debugfs:  seti <30>        # активируем флаг "in-use" для новой иноды
debugfs:  ln <30> /45.txt  # создаем хардлинк entry в папке фс
debugfs: quit

выходим из mcedit который дераж открытым файл 45.txt

# umount   /mnt/ext3   # отмонтируем фс

# e2fsck -f /mnt/5G-ext3.txt    # запускаем принудительную проверку ФС
e2fsck 1.46.5 (30-Dec-2021)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
Block bitmap differences:  +17408
Fix<y>? yes
Free blocks count wrong for group #0 (15849, counted=15848).
Fix<y>? yes
Free blocks count wrong (3793485, counted=3793484).
Fix<y>? yes
Inode bitmap differences:  +30
Fix<y>? yes
Free inodes count wrong for group #0 (8133, counted=8132).
Fix<y>? yes
Free inodes count wrong (969125, counted=969124).
Fix<y>? yes

/mnt/5G-ext3.txt: ***** FILE SYSTEM WAS MODIFIED *****
/mnt/5G-ext3.txt: 12/969136 files (0.0% non-contiguous), 77236/3870720 blocks


# mount -o loop /mnt/5G-ext3.txt  /mnt/ext3     # монтируем обратно фс
# cat /mnt/ext3/45.txt      # проверяем что файл на фс есть и с ним все окей
443534

# journalctl -f  | grep -i ext     # также проверяем в логах что нет ругани от ядра на ФС


ксати по поводу вывода на экран e2fsck
вот это 
    12/969136 files
означает что на данной фс всего инод есть 969136 
а на данный момент занято 12 штук  (это все можно посмтрет через dumpe2fs -h  в параметрах
суперблока)

а вот это 
    77236/3870720 blocks
означает сколко всего блоков ФС  есть на ФС и сколько из них занято.
блоки ествественно не физ сектора диска а блоки ФС (тоже можно проверить эти цифры через dumpe2fs -h  в параметрах суперблока) 

а вот это 
    (0.0% non-contiguous)
означает фрагментировать тел файлов. только я поканенаю как он это высчитывает


ксати вот как выглядит пустая инода

# debugfs
> stat
Inode: 12   Type: regular    Mode:  0644   Flags: 0x80000
Generation: 330651343    Version: 0x00000000:00000001
User:     0   Group:     0   Project:     0   Size: 0
File ACL: 0
Links: 0   Blockcount: 0
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64ab5e4e:03970ccc -- Mon Jul 10 01:26:38 2023
 atime: 0x64ab5d85:503a04d4 -- Mon Jul 10 01:23:17 2023
 mtime: 0x64ab5e4e:03970ccc -- Mon Jul 10 01:26:38 2023
crtime: 0x64ab5d85:503a04d4 -- Mon Jul 10 01:23:17 2023
 dtime: 0x64ab5e4e:(03970ccc) -- Mon Jul 10 01:26:38 2023
Size of extra inode fields: 32
Inode checksum: 0x83dc3b3b
EXTENTS:
(END)


а вот блок на диске (номер которого я запоминил ) на который инода указыала по прежнему содержит данные

> block_dump 66048
0000  6578 7434 2031 2e74 7874 0a00 0000 0000  ext4 1.txt......
0020  0000 0000 0000 0000 0000 0000 0000 0000  ................
*

unlink работает плюс минус также как и rm.
так что после него восстаналивем по тому же алгоритму






- что значит pre-allocate блоки для папки ?
  из каких полей состоит инода каталога . и его тело.
  сколко записей влезает в один 4К блок в дата блок каталога? таким макаром
  можно будет понять сколко записей влезет в 5 блоков по 4К преалоциорванных для
  lost+found

- научиться погимать как устроен inode котоаря за папку отввечает
- вккакой кодировке хранисят имя файла
- посмтреть реаьно ли обнуляется инода файла при удалении хардлинака
- если файл открыть а хардлину удален. как оратно создать харждлинк
- хардльнкс софтлинк разница



- ext можно наткатыват на диск без разделов. это прикол
ей неважно раздел не раздел. любой блочное устрйоствао - файл, диск , раздел, пофиг.
фс можно нактаить на любое чблочное устройство. в этом плане фс драйверу пофиг.
разел это sdc1 а диск это sdc разницы никакой. можно формтровать файл. потому что
файл это тоже блочноеутстустройствао


- из чего состоит оздание файла, удалеие файла, запись в файл 32 битного числа
и utf8 буквы(проверить little endian).

- если файл открыт. а мы удалили его хардлинк. как нам обратно создать хардлинк


- hard link vs symlink
хардлинк это запись в иноде отвечающей за папку. в нем присутстуует название 
файла и ссылка на иноду которая уже занята. есть команда создающая хардлинк. кгда мы создаем файл
то автоматом создается и хардлинк. число харлинков системой указывается в иноде.
когда число хардлинков становится равно ноль система ресетит иноду(если нет открытыъ
дескрипторов). при создании хардлинка новые иноды не занимаются. 
симлинк это тоже ентри в иноде отвеачающей за папки. там тоже есть имя и тоже есть ссылка на
иноду. но в той иноде вместо дата блоков  прописан символьный путь до другого файла (посмортеть как это на практике выглядит)



- расмотреть fallocate -s . тоесьт создаем пусто файл но у него полнй size
преаллокейтед блоков на диске


- а с помощтью truncate можно просто вырезать куски из обычных файлов с потеерей
данных естесвтено

- копировавоание спарс файлов




# istat


- преаллокейтед файл (fallocate) (truncate тоже саое делает)

- сравнить
dd ...
fallocte
truncate







