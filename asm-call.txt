| asm
| call
| objdump


CALL

расаотрим ассембле команду

  call XXX

дело в том что ее опкод e8  а далее идут 4 байта которые обозначают ОТНОСИТЕЛНОЕ СМЕЩЕНИЕ
а не абсолютный адрес! причем таккак это литл ендиан опертиввка то байты буудут идти начная
с младшего. например  хотим мы смтеиться на 4 байта то гда смещение выглядит как 

   04 00 00 00 

а полный опкод будет выгдеть как 

  e8 04 00 00 

есть и еще одна деьилная тонкость. это относииельное смеееещение. но относииельно какого адерса?
думаешь наверное относиельно текущего? НИХУЯ! смещение относиельно адреса следующей команды!
тоесть если байт e8 имеет адрес 0x1234 то следущая команда находится по адресу 0x1234+4=0x1238
и тогда адрес на который перепгрыгент call это будет адерс 0x1238+4=0x123C

таикмим образом два важным момент про команду CALL 
   1) у нее в аргументе указано относиелное смещение а не абсолюный адрес!
   2) смещение относительно адреса следущей команды а не адреса текущей команды

из этоо получается правило практиеческое  если мы хотим узнать на какой адрес прыгнет наш 
call то нужно к смещеению прибавить +5 

на наебки с этой команды еще не закочнислились. дело в том что дизасемблер программы они 
в качестве аргумента уазываеют НЕ смещение! НИХУЯ! они для удобства человек указывают абсолютный 
адрес куда прыгнет этот call. да это искажение этой команды. но человеку абсолютно было бы 
недоубно видеть смещение а потом сидеть и руками считать куда же эта комада прыгнет? 
ПОЭТОМУ вот что мы будем видеть в итоге


$  objdump  -d -M intel hello.exe



0000000000401126 <f>:
  401126:	55                   	push   rbp
  401127:	48 89 e5             	mov    rbp,rsp
  40112a:	48 8d 05 d3 0e 00 00 	lea    rax,[rip+0xed3]        # 402004 <_IO_stdin_used+0x4>
  401131:	48 89 c7             	mov    rdi,rax
  401134:	e8 f7 fe ff ff       	call   401030 <puts@plt>
  401139:	90                   	nop
  40113a:	5d                   	pop    rbp
  40113b:	c3                   	ret

000000000040113c <main>:
  40113c:	55                   	push   rbp
  40113d:	48 89 e5             	mov    rbp,rsp
  401140:	e8 e1 ff ff ff       	call   401126 <f>
  401145:	b8 00 00 00 00       	mov    eax,0x0
  40114a:	5d                   	pop    rbp
  40114b:	c3                   	ret


вот мы видим 

    401140:	e8 e1 ff ff ff       	call   401126 <f>

мы видим опкод

 e8 e1 ff ff ff

он на самом деле значит  CALL 0xffffffe1. далее если первеодить на дестичное число то это CALL -31
тоесть прыгни на -31 байт относиельно адреса следщей команды. седущая команда имеет адрес 401145

401145:	b8 00 00 00 00       	mov    eax,0x0

значит адрес куда пргыает call это  401139 - 31 байт = 401126

а что у нас по этому адресу нахродистя?

   0000000000401126 <f>:

праивлно фукия <f>

ТАК ВОТ чтобы нам ненужно было мудить и считать это все руками лдя нас objdump это высчитывает 
за нас и покызвает нам на экране не 

  call 0xffffffe1

а показывает 

	call   401126 <f>

тоесть objdump для нашего удоаства показывает  не смещение  А ПОКАЗЫАЕТ АБСОЛЮТНЫЙ АДРЕС.  и 
делает это для нащего удоства но в нарушение ассмеблера.

такая подсатаава

