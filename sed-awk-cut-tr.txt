sed-awk-cut


здесь все про эти хрени


|как сделать так чтобы каждое слово обрамить в кавычки

$ sed 's/[^ ][^ ]*/"&"/g' filename

$ cat 1.txt
john Doe

$ sed 's/[^ ][^ ]*/"&"/g' 1.txt 
"john" "Doe"


| как заменить все "enter" (\n) на пробелы

$ cat 1.txt 
john 
Doe

$ tr '\n' ' ' < 1.txt 
john  Doe 


| как вставть неколько пробелов  в кажой строке

sed -i -e 's/^/     /' <file>



| curl 

интересный кейс


человек на маке делал git clone https://
и ему писало что мол  сертификат неверный.

что оказалось - что у человека на ноутбуке в файле который хранит сертификаты от 
корневых центров сертфиикации хуеввый. его заменили и все заколосилось.

как это можно проверить


набираем curl

$ curl -I -v https://ya.ru
* Rebuilt URL to: https://ya.ru/
*   Trying 5.255.255.242...
* TCP_NODELAY set
* Connected to ya.ru (5.255.255.242) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
* successfully set certificate verify locations:
*   CAfile: /etc/ssl/certs/ca-certificates.crt
  CApath: /etc/ssl/certs
* TLSv1.3 (OUT), TLS handshake, Client hello (1):
* TLSv1.3 (IN), TLS handshake, Server hello (2):
* TLSv1.3 (IN), TLS Unknown, Certificate Status (22):
* TLSv1.3 (IN), TLS handshake, Unknown (8):
* TLSv1.3 (IN), TLS Unknown, Certificate Status (22):
* TLSv1.3 (IN), TLS handshake, Certificate (11):
* TLSv1.3 (IN), TLS Unknown, Certificate Status (22):
* TLSv1.3 (IN), TLS handshake, CERT verify (15):
* TLSv1.3 (IN), TLS Unknown, Certificate Status (22):
* TLSv1.3 (IN), TLS handshake, Finished (20):
* TLSv1.3 (OUT), TLS change cipher, Client hello (1):
* TLSv1.3 (OUT), TLS Unknown, Certificate Status (22):
* TLSv1.3 (OUT), TLS handshake, Finished (20):
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
* ALPN, server accepted to use h2
* Server certificate:
*  subject: C=RU; ST=Moscow; L=Moscow; O=Yandex LLC; CN=*.xn--d1acpjx3f.xn--p1ai
*  start date: Feb  1 12:45:35 2023 GMT
*  expire date: Aug  1 20:59:59 2023 GMT
*  subjectAltName: host "ya.ru" matched cert's "ya.ru"
*  issuer: C=BE; O=GlobalSign nv-sa; CN=GlobalSign ECC OV SSL CA 2018
*  SSL certificate verify ok.


и вот  унего написано какой файл он юзает с корневыми центрами сертификации и какую папку

*   CAfile: /etc/ssl/certs/ca-certificates.crt
  CApath: /etc/ssl/certs


на маке эта строка выглядит даже еще проще

*   CAfile: /etc/ssl/cert.pem
  CApath: none


тоесть мак юзает вообще только один файл.


берем curl и прям ему говорим что мол для корневых центров сертификаци юзай такой то файл


$ curl -I -v https://ya.ru  --cacert /tmp/23/cert.pem --capath none
* Rebuilt URL to: https://ya.ru/
*   Trying 77.88.55.242...
* TCP_NODELAY set
* Connected to ya.ru (77.88.55.242) port 443 (#0)
* ALPN, offering h2
* ALPN, offering http/1.1
* successfully set certificate verify locations:
*   CAfile: /tmp/23/cert.pem
  CApath: none



вот ради этих опций козырных

--cacert
--capath

я  и написал.

тоесть берем с того говнняого компа его файлы и папки подсовываем в наш курл и проверяем
релально ли там качественные файлы с ертфикиатами коренвых центров или нет.

в мое случае подвердилось что там было гавно

----
| sed

как заменить в папке во всех *.py файлах SELECT на SELECT SQL_NO_CACHE
причем неважно каким буквами написано слово select маленькими или большими

вот команда для замены в одном файле
# sed -i 's/[s,S][e,E][l,L][e,E][c,C][t,T] /SELECT SQL_NO_CACHE /g' ./module_cargo.py

а вот как поменять в целой папке
# find /folder  -type f  -name "*.py" -exec    sed -i 's/[s,S][e,E][l,L][e,E][c,C][t,T] /SELECT SQL_NO_CACHE /g'  {} \;

---

| sed
поговорим про это чудо юдо

как эта хрень выглядит
  $ sed 's/паттерн что мы ищем/паттерн на что мы найденное меняем/доп флаги'


рассмотрим первый паттерн это '.' точка
это аналог в баше ? тоесть любой символ
    $ echo "12345" | sed 's/.//'
    2345
ключ s означает что нужно найти некий паттерн и его заменить.
в данном случае точка означает один символ. любой. 
у нас первый символ это 1. он подошел под паттерн и эта единичка была заменена 
на то что указано на что заменить. у указано заменить на ничего. вот она и стерлась

можно добавить ключ и он  будет означать что нужно не останавливаться когда мы нашли
паттерн первый раз, а искать паттерны столько раз пока конца файла не достигнем.
это ключ g
  $ echo "12345" | sed 's/.//g'

и тогда sed найдет первое вхождение тоесть 1. потом он продолжит поиск и найдет следущий
любой символ тоесть 2. и так до бесконечности. поэтому поиск паттерна будут продолжать много кратно
а не один раз как это было в прошлом случае. и каждое вхождение конечно будет заменено на то что указано.
на ничего. поэтому вывод этой команды пустой.

далее.
следущий паттерн поиска это $
эта хрень означает символ окончания строки точнее символ при считывании которого терминал или принтер
должен прокрутить все строку на 1 строку наверх так называемый символ новой строки.
у линукса это символ LF или '\n' или в байтовом виде 0x0A,
либо если файл состоит всего из одной строки то это окончание файла. правда прикол в том что у линукса 
нет такого символа как окончание файла. показывают на примере
  $ cat 15.txt 
  1 
  $ cat 15.txt | od -t x1 
  0000000 31
  0000001

тоесть файл состоит из одного символа "1" который в хекс формате равен 0x31
а далее в файле ничего нет. нет никакого символа который бы обозначал что файл закончился.
поэтому строго говоря в данном случае "$" не имеет под собой никакого символа в файле. существенно понять 
что в обоих случаях символ '$' не означает печатного на экране символа. тоесть 
если мы имеем
  $ echo "12345"
то символ $ в sed не означает 5 он означает символ новой строки либо конец файла. причем символ конец
файла это просто мысленное измышление нет такого символа физически на диске в отличии от символ новой строки
который физически есть в файле. так вот важно понять что в случае
  $ echo '12345'
то для символа $ результат поиска это виртуальный символ поэтому если мы зададим в sed замену этого символа
то ничего не будет заменено. ничего  тоесть
  $ echo "12345" | sed 's/$//'
  12345
тоесть sed ищет "символ новой строки" либо если файл состоит из одной строки то мы ищем виртуальный символ
"конец файла". и в случае поиска "конец файла" мы физически не найдем такой символ.  поэтому замены
никакого символа не будет  в случае файла из одной строки! что мы и видим в данном примере.

переходим к следущему примеру
паттерн '.$' означает что мы два символа. один символ это символ новой строки либо символ "конец файла"
и символ стоящий перед ним. тогда
  $ echo "12345" | sed 's/.$//'
  1234
тоесть у нас как бы файл состоит не из "12345"  а "12345(виртуальный символ конца файла)"
тогда паттерн '.$' найдет '5(виртуальный символ конца файла)' ну и данный паттерн указано должен быть 
заменен на "ничего". что мы в итоге и видим

еще пример
  $ echo "12345" | sed 's/..$//'
  123
тоесть паттерн найдет символ новой строки\виртуальный символ конца файла и перед ним два любых символа
тоесть паттерн найдет '45(виртуальный символ конец файла'
и заменит его как указано на "ничего". что мы и видим

далее. противоположный символ для $ это ^ тоесть
символ "^" для sed означает искать "виртуальный символ начала строки ,  а если файл состоит из одной строки
то виртуальный символ начала файла". хотя физически данного символа данного байта абсолютно 
физически в файле нет! поэтому если мы укажем что мы хотим заменить этот "символ" на чтото другое то ничего 
заменено не будет. потому что раз наден виртуальный символ которого физически нет то замена его ничего 
физически не даст.

показываю пример
  $ echo "12345" | sed 's/^//'
12345
тоесть у нас как бы файл состоит не из "12345" а "(виртуальный символ начала строки)12345"
поэтому будет найден исходя из паттерна символ "(виртуальный символ начала строки)"
и он будет заменен на "ничего". а так как найденного символа физически не существует то по факту результат
ни коим образом не отличается от исходного файла!

зато следующий пример уже приведет к фактическому изменению файла
  $ echo "12345" | sed 's/^.//'
  2345
тоесть у нас паттер "^." означает найти два символа. первый символ это "виртуальный символ начала строки"
и второй символ это любой символ идущий после первого символа. поэтому символы которые попадут под паттерн
это "(виртуальный символ начала строки)1"
и это будет заменено на "ничего"
поэтому получаем то что получили

далее надо заметить паттерн для поиска который мы задаем он 
должен выражать непрерывный поток символов. тоесть скажем есть у нас файл
"123456" то паттерн должен вырезать непрервный набор символов. например "123" или "345" или "456"
но совершенно неправильно пытаться вырезать "12" и "6"  . не ну там есть конечно нюансы например если 
у нас файл "123425627289" то можно из него вырезать прерывный набор символов скажем в таком виде
"2" и "2" и "2" и "2" потому что они однотипные.
  $ echo "123425627289" | sed 's/2//g'
  13456789
но говоря в целом набор вырезаемых символов через паттерн должен быть обычно непрерывен. 
нафиг я это говорю . потому что вот такой паттерн неверный не сработает "^.$" потому что он означает
что мы просим найти  "виртуальный символ начала строки"+"любой символ за ним"+"вирт символ новой строки"
соотвественно что это будет непрерывный поток символов если в файле всего один символ.
    $ echo "1" | sed 's/^.$/2/'
    2
а если уже два символа то пошел нахер
    $ echo "13" | sed 's/^.$/2/'
    13
потому что под паттерн попадает разрывный набор символов
(начало строки)1 + (конец строки)
а между ними стоит тройка.

далее я хочу сказать что можно в паттернах поиска задавать группы для того чтобы
можно было при замене указывать эту группу. тоесть можно вставлять кусок из поиска в 
замену.

группа для поиска в паттерне задается через \(группа поиска\)
тоесть группа поиска задается через скобки. внутри скобок задаем паттерн для поиска.
поскольку скобки по дефолту это символы для поиска то чтобы обьяснить sed что мы не скобки ищем а 
ищем то что внутри скобок, поэтому скобки экранируем.


пример
  $ echo "12345" | sed 's/\(.\)\(.\)/\2\1/'
  21345
как это работает 
\(.\)  = группа поиска.  внутри группы то что мы ищем. а ищем мы "." тоесть любой символ
вторая группа поиска тоже ищет тоже самое. получается выглядит так
    sed 's/(группа1=найти любой символ)(группа2=найти любой символ)/.../'
спрашивается нахрен это надо. нахрен нам эти группы.а дело в том что далее мы можем использовать
эти группы в блоке в котором мы указываем на что менять найденный блок
ссылка на найденный блок делается через '\номер_группы' например '\1' означает подставить группу номер 1.
таким макаром эта хрень
  sed 's/\(.\)\(.\)/\2\1/' = sed 's/   \(.\)   \(.\)  /  \2\1   /'
означает то что в первой группе мы ищем любой символ , далее во второй группе мы ищем любой символ
далее в блоке который отвечает за замену говорим что нужно вначале вставить то что мы нашли во второй 
группе поиска а после этого этого вставить то что мы наши в первой группе
в первой группе поиска мы нашли 1

\(.\) = 1

во второй группе поиска мы нашли 

\(.\) = 2

поэтому мы нашли "12"  и заменяем это на "21"
что собственно мы и видим в итоге

вот еще пример на группы
  $ echo "1-2-3" | sed 's/\(.\)\(.\)\(.\)\(.\)\(.\)/\5\2\3\4\1/'
  3-2-1

первая группа  (.\) = 1 (первая группа найдет 1)
вторая группа  (.\) = - (вторая группа найдет -)
третья группа     (.\) = 2 (третья группа найдет 2)
четвертая группа  (.\) = - (четвертая группа найдет -)
пятая     группа  (.\) = 3 (пятая     группа найдет 3)

и потом мы переставляем то что нашли в группе замены
получаем красивый результат



двигаем дальше
этот пример находит конец строки и там выбирает последний символ 
и меняет его на ничего
    $ echo "1234" | sed 's/.$//'
    123


этот пример находит конец строки и в нем выбирает три последних символа
и меняет их на ничего
надо отметить что третий с конца символ выбирается с помощью группы , так вот в целом она там нахрен 
ненужна потому что при замене она не используется. а раз группы при замене неиспольщуется зачем тогда 
вобще создавать группу
    $ echo "1234" | sed 's/\(.\)..$//'
    1
аналогичный пример без группы
    $ echo "1234" | sed 's/...$//'
    1

насколько я понял по дефолту паттерн у sed ищет символы начиная с начала строки
только если в паттерне не указан $ , тогда он ищет начиная с конца строки.
это важно кстати. потому что когда мы говорим первый попавшийся символ то возникает вопрос
первый попавшийся начиная с какого конца поиска?

этот пример ищем первый любой символ с начала строки. 
при этом используется группы. при этом в целом группа нахрен не нужна потому что она 
не используется при замене
  $ echo "1234" | sed 's/\(.\)//'
  234


этот пример аналогичный предыдущему. 
разница только в том что из за ключа "g" когда мы нашли первое совпадение паттерна то программа
не успокаивается а продолжает искать все остальные совпадения паттерна до самого конца строки.
поэтому по факту в итоге будут выбраны абсолютно все символы в строке. и заменены как и в предыдущем 
случае на ничто
  $ echo "1234" | sed 's/\(.\)//g'



этот пример с помощью группы ищет первый символ с начала строки
находит его и меняет его на точку
хотя смысла использовать группу тут опять же нет никакого
  $ echo "1234" | sed 's/\(.\)/./'
  .234

этот пример ищет с начала строки первый символ, запоминает его в первую группу.
и далее меняет то что нашел в паттерне на символ - плюс то что в первой группе
тоесть в паттерне будет найдено "1" а вместо него будет вставлено "-1"
  $ echo "1234" | sed 's/\(.\)/-\1/'
  -1234


еще пример
паттерн зацепит первых два символа с начала строки тоесть "12" причем запомнит "1" в первую группу
и заменит паттерн на точку и то что в первой группе тоесть на ".1"
  $ echo "1234" | sed 's/\(.\)./.\1/'
  .134


еще пример
паттерн начнет искать с конца (потому что $) и будет искать два последних символа.
найдет "34" и запомнит "3" в группу 1. далее он заменит этот паттерн на то что в группе 1 тоесть на "3"
  $ echo "1234" | sed 's/\(.\).$/\1/'
  123



пример.
паттерн ищет с конца три символа. это будет "234" и меняет их на ".°C"
$ echo "1234" | sed 's/...$/.°C/'
1.°C


пример
последние три символа "000" меняет на "." плюс то что находится в первой группе + "°C",
в группе будет запомен "0" поэтому в итоге "000" будет заменен на ".0°C" 
$ echo "20000" | sed 's/\(.\)..$/.\1°C/'
20.0°C



