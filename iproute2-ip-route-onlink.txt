| ip 
| route 
| onlink

что за хрень onlink в маршруте
наример 


# ip -c r sh
default via 172.16.100.1 dev enp0s3 onlink 



ищем что значит этот onlink
поищем это в справке из пакета в котором лежит 
команда ip


# dpkg -S ip | grep '/ip$'
iproute2: /bin/ip
bash-completion: /usr/share/bash-completion/completions/ip
iproute2: /sbin/ip

итак ip принажеит пакету iproute2
посмотрим какие есть справки у этого пакета

$  dpkg -L iproute2 | grep man | grep route
/usr/share/man/man8/ip-mroute.8.gz
/usr/share/man/man8/ip-route.8.gz
/usr/share/man/man8/routel.8.gz
/usr/share/man/man8/tc-route.8.gz


приколно что выясрислос что вместо команды

  ip -c r sh

можно заюзать команду

  routel


далее прикол в том что когда мы назначем ip адрес
для порта то это нам не позволяет ничего отправлять
с компа!! это нам только пзволяет принимать входящий
трафик на комп. тоеть в порт прилетате пакет. 
и ядро смотрит совпдаает ли dest IP у входящего
пакета с IP адресом порта. тогда он такой пакет
неотбрасывает. вот что дает назначение ип адреса
порту! а чтобы отарапвлять трафик наружу то для
этого нужна совсем другая хрень - нужна таблица
маршрутизации! вот такой пиздец

чтобы продолжить дальше   я порассуждаю.
вот у нас есть порт. когда его настраиваем то мы 
обычно указываем

  ИП адрес 
  маску
  гейтвей
  днс сервер

например 


iface enp0s3 inet static
	address 172.16.100.25
    netmask 255.255.255.0
    scope global
    gateway 172.16.100.1
    dns-nameserver 172.16.100.1


возникает вопрос какие настройки из этих реаьно
относятся к настройкам порта? оказывается не все
из этих настроек относятся к настройкам порта.
ип адрес действительно явлеяется настройкой порта.
что он дает? казалось бы он дает то что если мы
его зададим то потом можем ОТСЫЛАТЬ пакеты во вне.
но это нетак. присовение порту ип адреса этого не 
позволяет. вместо этого оно позволяет нечто совсем
другое. оно позволяет ядру принимать ВХОДЯЩИЕ пакеты
которые приелетели к нам из сети. к нас влетатет
пакет и ядро сравнивает какой ип адрес назначен 
порту с тем dest IP который записан внутри пакеты.
и так ядро понимает предназначен пакет нам или кому
то другому. итак ип адрес позволяет принимать входящий
трафик. но никак не отправлять обратно!
итак эту настройку я разобрал

	address 172.16.100.25


далее переходим к такой настройке как маска

    netmask 255.255.255.0

что она дает. мы должны наложит маску на ип адрес
порта через битовый AND


  172.16.100.25  AND
  255.255.255.0  
 ----------------
  172.16.100.0

и что же нам это дает? это так называемый Network ID
что он дает?  он обьясняет ядру какие ип адреса
имеют компьютеры в сети сидящие ЗА(ВОВНЕ) портом enp0s3

тоесть эта характиристика она не явялется характери
стикой нашего компа и нашего порта. эта хараектери
стика описывает нашему ядру об окружающем мире.
если ип адрес сообщает нашему ядру какой адрес
имеет наш комп наш порт. то маска\network id 
сообщает ядру о том какие ип адреса имеют другие
компы. там. вовне. за сеетевой картой.
а что физически сообщает нам нетворк ид. он сообщает
нам часть ип адреса которая у всех компов там 
во внешней сети одна и таже. тоесть. 
вот этот нетворк ид 

     172.16.100.0

он на самом деле выглядит вот так

   172.16.100.x

тоесть 0 на самом деле шифрует под собой X
где X это любой набор битов возможный. ведь
у нас ип адрес на самомо деле это набор битов
числом 32 штуки. а запись A.B.C.D это всего лишь
нотация которая позволяет людям более легко
понимать этот набор. то есть пофаку ип адрес
физически выглядит вот так

  1010 1010   1010 1010    1010 1010   1010 1010 

так вот X обозначает что в данном блоке битов
длиной 8 штук у нас биты могут быть любые

  1010 1010   1010 1010    1010 1010   xxxx xxxx

так вот НЕТВОРК ИД утверждает что какой бы комп мы не взяли в сети за нашим портом то у этого компа будет
ИП выглядеть так что первые 24 бита у него всегда
будут равны

     172.16.100.


эта часть ип адреса у этих компов будет одна и таже.
вот в чем смысл нетворк ид. и только оставшаяся
часть в размере 8 бит уже будет у этих компов 
индивидуальная.

тоесть в чем суть. у нас компы в сети имеют разыне
ип адреса. мы их выписываем на бумажке

     172.16.100.5
     172.16.100.10
     172.16.100.100
     172.16.100.16
     172.16.100.20



и начинаем анализировать их.
и замечаем что у всех у них оказывется есть общая
часть.  172.16.100.
вот этот факт и утверждает нетворк ид.
тоесть когда мы сообщаем нашему компу нетворк ид.
то этим способом мы сообщаем нашему компу о том
как выглядят ип адреса копов во внешней сети.
а именно мы сообщаем что у всех этих компов ип
адрес имеет некую общую часть. которая одна и таже
у них у всех. и только оставашаяся часть у этих
компов индивидуальная для кжаого компа. соотвевтеннно
чтобы сообщаить нашему компу нетворк ид мы должны
знать все ип всех компов во внешней сети. выписать
их на бумажку. найти у них общую часть. и только 
тогда ее сообщаить нашему компу.

и тут важно понять что сам по себе порт компа
в качестве индентификатора имеет только ИП адрес.
это идентификатор. он самодатдостаточный. больше 
кнему ничего ненадо. дейстиеитльно в ип пакете
в его заголовке в качестве идентификатора дестинейшен
компа стоит только ип адрес и там нет никакой
маски сети нет никакого нетворк ид. нетворк
ид это некая внешняя хрень которая позволяет 
нашему компу обьяснить какие ип адреса имеют компы
во внешней сети в более короткой форме. тоесть
мы могли бы на нашем компе составить таблицу
в которую вписать каждый ип адрес компов из внегней
сети


     172.16.100.5
     172.16.100.10
     172.16.100.100
     172.16.100.16
     172.16.100.20

но очевидно что это очень громоздкий способ.
и тогда придумали другой способ - давайте анализирова
ть все эти ип адреса и искать в них некую общую часть.
которую будем называть нетворк ид. хотя в природе
никакого нетворк ид с точки зрения заголовка ип
пакета НЕТ! это чисто искуственная абстракция!
которая позволяет вболее короткой форме нам на компе
зашифровать таблицу адресов всех компов. в данном
случае это будет 

    172.16.100.х


исходя из этой записи наш комп понимает все множество
как выглядят ип адреса компов сидящих за нашим портом.

    172.16.100.1
    172.16.100.15
    172.16.100.125


итак с точки зрения идентификации порта. есть только
ип адрес. и нет никаких ни масок. ни нетворк ид.
ест просто куча компов каждый из которых имеет 
ип адрес и все. окей.

а что дает на практике эта таблица


    172.16.100.1
    172.16.100.2
    ...  
    172.16.100.254

или в форме нетворк ид

    172.16.100.х

она дает вот что - зная ее ядро создает запись
(маршрут) в таблице маршрутизации


 172.16.100.0/24 ..... dev em1


тоесть замечаем сразу что маска в итоге эта хрень
которая влияет не на настройку порта а на другую
сущность  - на таблицу маршрутизации. окей поняли
зафискифровали осознали.
а что нам даеттаблица маршрутизации? а она нам помогает при формаировании ИСХОДЯЩЕГО трафика!
она нам помгает если мы хотим ПОСЛАТЬ пакет.

тоесть еще раз. ИП адрес назначенный порту он 
помогает ядру ПРИНЯТЬ пакет. 
а таблица маршутизации помогает ядру ОТПРАВИТЬ 
пакет. 

это соверщенно разные ситуации. хотя в рамках связи
с другим компом как раз таки мы имеем сумму двух
событий - прием пакета и отправка пакета. но 
обеспечение работы этих двух событий совершенно
разное!
если в наш комп влетает пакет то ядро не смотрит
в таблице маршурутиацзии. это тут ненадо. ядро
смотрит имеет данный порт такойто ип адрес который
заисан в грфае dest ip у влееиевшего пакета.
если есть совпадение то ппакет принимается. вот 
что дает и зачем нужен ип адрес на порту.

если же комп хочет отравить пакет вовне то он в целом
пофиг какой ип адрес назначает порту. он делает
чтото совсем дургое. ядро леезет  в таблицу маршути
зациию там ищет запись. исходя из нее ядро ищет
название порта в который нужно исодящий пакет
тиснуть. и также ядро ищет в записи маршрута номер
ип адреса который нужно вствить в пакет исходящий
в графу src ip.
дело в том что вот моя прога говорит ядру отправь
пакет по адресу 172.16.10.100
ядру для этого нужно знать три вещи.

 dest IP - мы его уже знаем. это ядру собщила
 программа. он равен  172.16.10.100

далее ядру нужно знать в какой порт сунуть пакет.
и ип пакет должен иметь поле src ip который ядру
приложение несообщает это ядро должно само както
оределить. ядро оба этих параметра ищет в таблице
маршрутизации!! вот зачем она нужна. вот что она
дает. замечу что при этом чему равен ип порта
в который будет сунут пакет неимеет никакого значения!
это никак не влияет ни на отправку пакета ни на 
паарметры этого пакета!

вот таким образом ип адрес порта и таблица маршру
тизации играют две совершенно разные роли. одна
хрень нужна для приема пакета а вторая для отправки
пакета. и это совешенно разные вещи. и их работу
обеспеивают два разых мехагизма.

на самом деле ип адрес порта может играть роль в 
мехаизме отправки пакета. в том случае если 
маршрут в талцеи маршуртизации неимеет в себе
парметра src ip. если он не указан например вот 
два случая
вот тут src ip в маршрут указан

172.16.80.0/24 dev bondV2.2 proto kernel scope link src 172.16.80.1 metric 400


все круто

а вот тут 

default via 172.16.10.1 dev enp0s3 proto static

параметр src ip не указан.

так вот если он в маршруте не указан то ядру нужно
все равно опрееддить src ip каким то другим способом.

тогда вступает в силу другой алгоритм. кажоый 
маршрут имеет параметр SCOPE. он может быть 
указан в явном виде в маршруте
как вот здесь


172.16.80.0/24 dev bondV2.2 proto kernel scope link src 172.16.80.1 metric 400


а может быть не указан  как здесь

default via 172.16.10.1 dev enp0s3 proto static

тогда он автоматом подразуметвается что он равен
GLOBAL.

так вот ядро смотрит какой скоуп есть у маршрута.
потом ядро смотрит какой порт указан в маршруте.
в данном случае enp0s3
далее ядро лезет на этот порт и сканирует список
ип которые этому порту назначены. а дело в томчто
один порт может иметь дохрена наанченных ему ип 
адресов. 
так вот когда мы назанчаем порту ип то также 
мы при этом назначаем какой SCOPE имеет этот ип!
мы это можем сделать в явном виде а если мы этого
не делаем то ядро это делает за нас автоматом само!
но это всегда происходит. узнать какой список ип
имеет порт и какой у них скоуп очень просто

   $ ip -c a sh dev enp0s3


2: enp0s3: ... 
    link/ether ba:ec:24:5c:00:05 ...
    inet 172.16.100.25/24 brd 172.16.100.255 scope global enp0s3

вот видно что у нас ип  172.16.100.25 и что
есть скоуп равен  global

вот я добавлю еще один ип на этот порт с другим
скоупом

# ip addr add 192.18.10.25/24 scope link dev enp0s3 

вот мы получим

2: enp0s3: ...
    inet 192.18.10.25/24 scope link enp0s3
    inet 172.16.100.25/24 brd 172.16.100.255 scope global enp0s3

получается у нас порт имеет два ип. один имеет
скоуп глобал а второй имеет скоуп линк.

так вот еще раз. мы через программу говррим ядру -
пошли пакет на комп с ип=172.16.100.100
это с точки зрения ип пакета dest ip
ядро леезет в таблицу маршртуизации и ищет в
ней маршрут в котором будет написано - в какой порт
сунуть исходящий пакет. и какой срс ип в этот пакет
нужно записать. параметр src ip может отстусотвать
в маршруте. выходной порт как я понимаю (чтобы 
точно узнать нужно читать man ip-route) всегда
указан в маршруте. 
так. если ядро знает срс ип, выходной порт, из маршру
та и знает дест ип из инфо от программы. то ядро
знает как составить ип пакет и знает в какой порт
его сунуть. ядро все знает. так вот если срс ип
остсутвует в марррте то ядро смотрит какой скоуп
ест у маршурта. потом идет на порт который указан 
на маршуртуе и берет список ип этого порта.
иначинает по нему идти. и выбирает тот ип который
имеет тот же самый скоуп что и у маршрута.
если у маршурута указано что скоуп равен глобал

2: enp0s3: ...
    inet 192.18.10.25/24 scope link enp0s3
    inet 172.16.100.25/24 brd 172.16.100.255 scope global enp0s3

то среди этих двух ип ядро выберет ип=172.16.100.25
и именно этот ип ядро вставит в исходящий пакет
в качеств src IP !!!!! тоесть при данном стечении
обстоятельств ип назначенный для порта уже играет
роль не только для входящих пакетов но также и
начинает играть роль для исходящих пакетов! 
а что если в списке ип у проорта нет такого ип
котоырй бы имел тот же самый скоуп что и у маршрута?
в этом случае ядро всавит в исходящий пакет

   src ip = 0.0.0.0 

соовсвтенно такой пакет долетит до удаленного компа.
но получается тот комп не сможет нам ответить потому
что обратный ип неимеет никакого смысла!

исходя из того что я сказал - получается чтобы небыло
ебалы лучше всего чтобы в маршруте всегда был 
указан src ip. тодга все будет четко и ясно и не будет
никакой нежданной ебалы.

что касается какие бывают виды скоупов
читаю в man ip-route

scope SCOPE_VAL
the scope of the destinations covered by the route prefix.  SCOPE_VAL may be a num‐
ber  or a string from /usr/share/iproute2/rt_scopes or /etc/iproute2/rt_scopes (has
precedence if exists).  If this parameter is omitted, ip assumes scope  global  for
all  gatewayed  unicast  routes, scope link for direct unicast and broadcast routes
and scope host for local routes.

смотрим что в этих файлах

$ cat /usr/share/iproute2/rt_scopes  | grep -v '#'
0	global
255	nowhere
254	host
253	link
200	site

$ cat /etc/iproute2/rt_scopes | grep -v '#'
cat: /etc/iproute2/rt_scopes: No such file or directory

чтобы понять разницу между скоупами (тоесть почему
в  одном случае нужно назначить такой то скоуп
этому ип адресу и этому маршруту и в другом случае
другой скоуп ) нужно вначале поговриить в целом
про таблицу маршрутизации. пока что будем считать
что маршрут имеет src ip указанный и в этом случае
можно сразу забыть про скоупы. их можно игнорировать
они ни на что не влияют. и вернуься к ним потом.

так вот я возвращаюсь к нетворк ид.
когда я сообщаю ип адрес порта и маску в нетворк
менеджер то нетворе менеджер это всего навсего
автоматизатор надстройка который за нас делает
часть ручной работы. по факту он всего навсего
за нас запускает автоматом команду 

  $ ip ....

из пакета iproute2
тоесть никакой магии в нетвор менедже нет.
просто он за нас при загрузке компа запускает
команду 

  $ ip ...

и подставляет в нее значения указанные в конфиге
нетворе менеджера.
так вот  если я буду руками добавлять ип адрес
на порт например вот так


# ip addr add 192.18.10.25/24 scope link dev enp0s3 

то при этом ядро нетолько добавит ип адрес на порт
НО! ядро также автмоатом создаст +1 маршрут!
(можно добавить опцию noprefixroute 
   (см man ip-addresses)  )

и вэтот маршурут ядро впишет нетворк ид. 
в терминах таблицы маршрутизации он зовется ПРЕФИКС.
тоеть маршрут выглядит так


  ПРЕФИКС ..... выходной порт

например 


   192.18.10.0/24 .... dev enp0s3


итак в "префиксе" маршрута на самом деле зашифрован
нетворк ид. 

когда мы указываем маску вместе с ип мы таким
макаром передаем увтерждение ядру о том  что 
вот такой то дипазон ип есть у компов которые сидят
в сети за данных портом. 
тоесть когда я пишу

# ip addr add 192.18.10.25/24 scope link dev enp0s3 

то я говорю ядру. данный порт имеет ип=192.18.10.25
и за этим портом сидят компы которые имеют
ип лежащие в диапазоне 192.18.10.1-192.18.10.254
или другими словами что все эти ип имеют общую 
часть 192.18.10.

комп информацию об компах котоыре сидят за портом
запмывает в виде маршрута в таблице маршрутизации


   192.18.10.0/24 .... dev enp0s3

эта запись как раз обозначает то что мы собщили
компу. что за портом enp0s3 у нас сидят компы
которые имеют ип такие что каждый их ип
имеет общую часть    192.18.10.
и уже оставшаяся часть у таких ип явлесятся индивиду
альной для каждого того компа

         192.18.10.N

вот какой смысла у маршрута как такоовго
и вот какой физ смысл у префикса 192.18.10.0/24 
в маршруте
эта наша овтественность чтобы сообщить ядру 
коректный префикс. 

как на праактике ядро испольщует маршрут.
если мы в программе пишем что хотим достучаться
до ип=192.18.10.120  тоесть мы собщаем ядру 
что dest ip = 192.18.10.120 то далее ядро
идет в таблицу маршрутизации и начинает шерстить
маршруты. ядро берет маршрут у которого самый 
длинный префикс. имеется ввиду тот у котрого
самая большая длинная маска. в данном случае
у нас всего один маршрут в таблице поэтому еще проще

   192.18.10.0/24 .... dev enp0s3


далее ядро берет dest ip  192.18.10.120 который
мы задали ему и проверяет совпадает ли у этого 
ип адреса та часть нетворк ид которая указана
в этом маршруте. тоесть вот у нас префикс
192.18.10.0/24
что в себе шифрует нетворк ид

   192.18.10.

и он смортрит есть такие же биты в нашем ип
192.18.10.120
видим есть.

значит комп с данным ип лежит сидит как раз в той
сети которая лежит за портом enp0s3 который
указан в маршрруте!
тоесть наше ядро узнает за каким портом сидит
комп с тем ип что мы указали в программе.
тоесть табица машртутизации по своей сути
содержит инфо о том какие компы с каким ип сидят
за какими портами нашего компа. нашему ядру
нужно знать за каким портом находится тот комп
до  которого мы хотим досттучаться отправить пакет.
информация эта зашифрована в маршруте за счет 
того что в префиксе маршрута указана часть ип адреса
дестинешн компа. есть эта часть ип адреса совпдадает
с нашим ип адресом то комп делает вывод что нужный
нам комп сидит за портом указанным в маршруте.

это похоже вот на что ип адрес это полный адрес
например  ип = чикаго, ул сидорова 17, кв 40.
так вот префикс в маршруте он хранит часть этого 
адреса. та часть которая общая для некоторой группы
ип адресов.
тоесть 
  ип1 = чикаго, ул сидорова 17, кв 40
  ип2 = чикаго, ул иванова  40, кв 15

и в префиксе мы указыаем "чикаго" тоесть

 чикаго .... dev enp0s3

тогда если я хочу отправит пакет на ип1 = чикаго, ул сидорова 17, кв 40  ядро лезет в табице маршрутиацзии
видит там строку

 чикаго .... dev enp0s3


видит что ип1 в себе содержит "чикаго" и понимает
что пакет нужно сунуть в порт  enp0s3

скажем префикс=нетворк ид = 01010101010101010110
а наш дест ип = 01010101010101010110 010101010

соовесвтенно вот у нас маршрут

01010101010101010110  .... dev enp0s3

я хочу отправить пакет на ип = 01010101010101010110 010101010

ядро видит что нетворк ид 01010101010101010110
содержится в ип. и делает вывод что данный комп
сидит в сети за dev enp0s3 и что выходной пакет
нужно пихать в этот порт.

если бы не было мудежа с нетворк ид то 
таблица маршрутизации в себе содрержаала бы 
записи к кадому кокнрертному компу вот в таком 
виде

   192.18.10.120 .... dev enp0s3

было бы так просто.  я укыва в программе что
дест ип = 192.18.10.120
ядро лезет в табл маршуртиз. видит там

   192.18.10.120 .... dev enp0s3

и понимает что этот комп сидит за портом enp0s3

нетворк ид эта такая искусственная хрень чтобы
размер таблицы маршрутизации был поменьше.
вместо полного ип дест компа мы указываем только
часть его ип. а оставшаяся часть может быть какой
угодно. 

от чего же зависит выбор network id. он зависит
от архитектуры сети. тот кто проектирует сеть
должен решить скоько будет в сети компов и какие
у компов будут ип адреса. можно конечно взять кучу
компов и выдать кажому рандомные ип адреса тоесть


 комп1 порт ем1  ип=1.1.1.1
 комп2 порт ем1  ип=2.2.2.2
 комп3 порт ем1  ип=3.3.3.3
 ...
 компN порт ем1  ип=254.254.254.254


тогда получается чтобы я с компа1 мог связаться
со всеми компами я должен буду в таблицу маршру
тизации записать дохрена маршрутов

 2.2.2.2/32 ... dev em1
 3.3.3.3/32 ... dev em1
 ...
 254.254.254.254/32 ... dev em1

но этовсе мудеж. 

более разумано выдать компам в сети такие ип
адреса которые будут между собой иметь некую
общую часть
  
 комп1 порт ем1  ип=192.168.10.1
 комп2 порт ем1  ип=192.168.10.2
 комп3 порт ем1  ип=192.168.10.3
 ...
 комп254 порт ем1  ип=192.168.10.254


тогда на компе1 я могу записать всего один 
маршрут


192.168.10.0/24 .... dev em1


он сообщает моему ядру что комп с любым ип 
в которого часть в себе содержит кусок 192.168.10.
лежит за портом em1

таким образом если у меня есть сеть то я могу 
назначить раздать компам в сети рандонмые ип адреса
окей. но это сделает таблицы машрутизации очень
большого размера что плохо для скорости тупо.
вместо этого можно раздать компам ип адреса которые
имеют некую общую часть. на суть дела не влияет
зато этот трюк позволяет сделать талицу машрутизации
очень маленкую! 

этим я все пытаюсь передать какой смысл у маски,
нетворк ид. и как оно работает  в связке с таблицей
маошрутизации. 

это чтото типа нумерации домов в городе. можно
кажодому дому назначить свою улицу личную и номер.
но это накладно. выгоднее обьединить дома в 
группы в которой все дома в группе принадлежат
одной улице. это существено сократить таблицу
адресов домов в городе. 

в итоге получается что чисто физически нетворк ид который якобы идентифицирует некую "сеть" - то
это не так. нет никакой "сети" на уровне ип на 
самом деле. каждый хост имеет свой ип который его
однозначно идентифицирует.  по факту все эти
хосты с точки зрения ип адресации являются НЕЗАВИСИ
МЫМИ и не входят ни в какую "сеть". еще раз 
хосты имеют ип адреса которые их однозначно
идентифицируют друг между другом. и эти хосты
они все незавиисимые и не входят ни в какую "сеть".
нет никакогой сети. нет никаого обьединения в сеть.
все хосты незавиисимые.

я хочу скзаать что сам по себе протокол IP ни о 
каких обтединениях группы айпи адресов в сети 
понятия не имеет! в нем этого нет!
это все придумка таблицы маршрутизации! для того
чтобы можно было сокраить в ней колчесво записей!
вот еще пример. у меня есть куча людей. они все
чужие друг другу. так получилось что все эти люи
имеют фамилии которе начинаются на две теже
самые буквы 

  Иванов
  Ивугод
  Иваров
  Ивытуп
  Ившаков


От того что все эти люди имеют фамиллии такие что
они имеют две одинакоые буквы не делаеет этих
людей родствтенниками НИРАЗУ!! 
От того что я возьму карточки с этим фаимлиями
и положу их в ящик и напишу на ящике "Ив*"
несделает этих людей родсвтениками или както
свзанными друг с другом по факту. 

тоже самое с кучкой компов котоыре имеют такие 
ип адреса котоые так совпало имеют некую общую часть.

  1.1.1.1
  1.1.1.2
  1.1.1.3
  1.1.1.4

с точки зрения ип технологии все эти хосты независимые
не входящими ни в какую "айпи сеть". такого нет!
с точки зрения протокол айпи у них нет никакой
ни маски ни нетворк ид - нихуя этогонет. с точки
зрения проокола ип такого не сущестует. что четко
видно в заголвке ип пакета. там есть только 
ип адрес назначения и  ип адрес источника и все !!!
нет ни маски , ни нетворк ид , нихуя этого нет!

маска, нетворк ид - это все придумка таблицы 
маршрутизации! которая прямого отношения к айпи
протоколу не имеет никакого отношения!
таблица маршрутизации это локалная для ос удобншяка
инсрумент для того чтобы хранить информацию о том
за каким портом якобы лежит комп с таким то айпи!

дефлотолыая табица маршрутиацзии выглядела бы так
я укаываю полный айпи удаленного компа (его иденти
фикатор с точки зрения айпй) и порт за которым он 
лежит.


  1.1.1.1   .... dev em1
  2.3.4.5   .... dev em1
  1.1.1.10   .... dev em1
  1.1.1.17   .... dev em1


и при таком подходе нужны табоицы громадного 
размера. что тупо и нудобно. и решили этот
моент ИСКУССТЕВЕННО оптимизировать.

мы проанализруем полный список всех хостов
о которых мы знаем. потом искусственно обьединим
их в несколко списков(чисто только на бумаге).
в кажом списке будут компы у которых их ип адреса
имеют какойто кусочек общий для них всех.
тоест



  1.1.1.1   .... dev em1
  1.1.1.10   .... dev em1
  1.1.1.17   .... dev em1

  2.3.4.5   .... dev em1


далее мы выделяем в каждом списке эту общую часть
ее мы чисто толко с тчоки зрения таблицы маршру
тизации назовем нетворк айди. далее мы заменем
классические записи в таблице маршрутизации 
в модернизированные. заменяя несклько записей 
в одну. в ней я вместо полного ип хоста встваляю
только куосочек от полного ип адреса который
представляет собой ту общую часть ип адеса которая
есть во всех этих хостах.
тоесть было


  
  1.1.1.1   .... dev em1
  1.1.1.10   .... dev em1
  1.1.1.17   .... dev em1


стало

  1.1.1.0/24   .... dev em1

рабтает это так. я беру ип

   1.1.1.0

потом я от него отрезаю слева столько бит
сколко указано в маске
тоесть полный ип

  0000 0001. 0000 0001. 0000 0001. 0000 0000

обрезаю 24 бита слева


  0000 0001. 0000 0001. 0000 0001.

и это значит что за портом em1 лежат хосты
такие что все их ип имеют одинаковую часть
такую что первые 24 бита слева имеют

  0000 0001. 0000 0001. 0000 0001.

ну а оставшиеся биты уже могут быть какие угодно
любые.

тоесть такая запись она кодирует вот такой
набор полных ип

  1.1.1.1   .... dev em1
  1.1.1.2   .... dev em1
  ...
  1.1.1.254   .... dev em1

нет нкиакой айпи сети в реланости. это всего
навсего мат подход трюк удобняшка со стороны
таблица маршртизации. которая всего навсего
является обычно таблицей которая хранит в себе
информацию за каким портом какой ип адрес лежит.

итак нет в релаьности никакой ай пи сети.
есть всего навсего  некая договренность в системе
обозначений внутри таблицы маршрутизации которая
позволяет в сокраенной форме в одной строке
зашифрвовать сразу целую кучу отдельых полных ип
адресов. вот и все.


от того что у меня есть хосты с ип адресами

  1.1.1.1
  1.1.1.2
  1.1.1.3

неделает их никак связанными. никоми образом.
это все назвисимые сущности.

вот еще аналогия
от того что у меня есть люди с именами  маша, саща, даша, глаша неделает этих людей связанными друг с другом никоми образом. я могу все их имена засунуть в ящик на котором написать "*ша" но это никак по факту в жизни неделает их связанным друг с другом.  от того что их карточки лежат в шкафу в одном ящике неделает между ними никакой связи. 

есть только связь их карточек на уровен шкафа. вот ивсе


я вот щас докажу что нет никаких айпи сетей.
и что нет никакой проблемы связать хост 1.1.1.1
и хост 2.2.2.2 напрямую. без всяких гейтвеев и 
прочее.

хост1
его айпи
inet 1.1.1.1/32 scope global enp0s3

хост1
его айпи
inet 2.2.2.2/32 scope global enp0s3

на хосте1
маршрут
2.2.2.2 dev enp0s3 scope link src 1.1.1.1


на хосте2
маршрут
1.1.1.1 dev enp0s3 scope link src 2.2.2.2


далее я на хосте2 делаю пинг
# ping 1.1.1.1
PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.
64 bytes from 1.1.1.1: icmp_seq=1 ttl=64 time=2.34 ms
64 bytes from 1.1.1.1: icmp_seq=2 ttl=64 time=1.52 ms


все заебись!

логика такая. на хосте2 я говорю кинь 
пакет на 1.1.1.1
ядро идет в маршруты и находит такой маршрут
1.1.1.1 dev enp0s3 scope link src 2.2.2.2


тогда ядро создает пакет с 
срс ип=2.2.2.2 дест ип=1.1.1.1 и кидает его
в порт enp0s3

тот легко долетает до хоста1
то его принимает.
и формирует обратный пакет.
дест ип=2.2.2.2
идет в маршруты
видит там
2.2.2.2 dev enp0s3 scope link src 1.1.1.1
и подстлавяет срс ип=1.1.1.1
и кидат пакет в enp0s3

поэтому пинги работаютт отлично между 1.1.1.1
и 2.2.2.2


фактически когда мы добавляем маршрут то мы всего
навсего нашему ядру сообщаем список тех ип адресов
(хостов компов) которые мы утверждаем есть существуют
за таким то портом. когда мы назначаем ип адрес
то мы всего навсего сообщаем ядру идентификтор
нашего компа. но чтобы связатся с другим компом
ядру нужно знать за каким портом он сидит.
ибо пролема в том что если наша прога говорит
отправь ип пакет до компа с ип=1.2.3.4
и получается у протокола ип нет механизма
чтобы наше ядро могло "налету" узнать за каким
портом лежит данный комп с таким ип.

далее я решил почитать про протокол IP за что
он реально отвечает. в любой литературе они суки
пишут что он отвечает за доставку ип пакета от одного
хоста до другого. но по мне это ХУЙНЯ ПОЛНАЯ. нихуя
ип протокол за это не отвечает. я открыл основной
rfc 791 об ип протоколе. там описано только две
вещи которые ип протокол делает. первое - он пакет
данные в ип пакеты. там указан формат ип пакета.
и там указано как нужно фрагментировать пакеты.
и все!!!! сука!! там написано что после того как
ип пакет составлен то дальше его нужно преедать
модулю более низкого уровня (условно говоря
эзернет модулю) который уже и будет доставлять 
наш ип пакет по сети. тоесть я хочу сказать что 
ип протокол ничего не делает кроме того что
облезкает данные в ип пакет. на этом все! самой
доставкой занимаетя проткол L2 уровня! но!
прикол в том что чтобы л2 протокол занялся доставкой
нужно ядру знать в какой порт сунуть этот пакет.
как выбрать этот порт в рфц 791 нихуя не сказано.
выбор порта это есть роутинг. как этот роутинг
сделать на компе в рфц 791 не скзаано нихуя. 
тоесть наш ип протокол соталавят ип пакет. 
и все. а что делать дальше хуй знает. нужно
мол предать пакет модулю более низкого уровня
и он пусть со всем разбирается. низуя себе. и 
это все что ип протокол умеет делать?
я не нашел в рфц 791 ничего о роутинге. ничего
о табицах машрутизации ни о том как ими ползоваться.
загадка бляль. и после этого они утвреждают что
ип протокол занимется доставкой от хоста 
до хоста. хуйня полная.
в рфц уазано что каждый ип пакет явлется незавии
симым от всех других. тоесть нет ниаких ни потоков
ни конектов ничего. отдельный пакет это отеная
самосттяетльная незавиисмая сущность.


вобщем я вовраащаюсь к нашему вопросу.
когда ядро создало ип пакет. то ему надо знать 
в какой порт его пихать. когда ядро берет 
инфо из сокета и принимае решение в какой порт
пихать этот пакет назыается роутинг. также если
пакет был создан не локально а прилететл на комп
из сетевой карты и далее нужно принять реение
в какую карту его дальше пихать - тоже называется
роутинг. так вот походу у ип протокола и уядра
нет механизма как это узнать самому. ядро 
требует чтобы на компе была кем то заранее 
запоненнная таблица марршрутизации. ее можно
запронить самому руками или можно на компе
активировать протоколы RIP/OSPF которые подсосут
маршруты с внешнего источника и заполнят
таблицу маршрутизации. также у протокола DHCP
есть вомзожсность тоже насовать на комп маршруты.
итак на компе должны быть созанная так или иначе
таблица маошрутизации. туда лезет ядро и ишет
маршрут в котором указано за каким портом
находится тот ип для котрого предназначен созданный
ранее ип пакет. и вот туда ядро и сунет этот
пакет. без соданной заранее табица маошрутизации
ядро не способно понять определить за каким портом
находится тот комп для кторого создан пакет.
и ядро не сможет этот пакет отправить.  как я
еще раз подчерну понял - к созданию таблицы маршру
тизации проткол ип неимеет нкиакого отношения.
как я понял протокол ип все что он описывает как
делаьт этот как создать ип пакет. а вопросами
доставки этго пакета занимаются соверешенно друние
проткоолы службы и хрени. 


далее у нас есть два вида маршрутов - один вид
маршрута увтерджает нашему ядру что такой то
IP доступен "напрямую" за таким то портом.
"напрямую" это значит что наш комп может послать
в этот порт ARP запрос с dest IP и в ответ
мы получим мак этого компа. тоесть термин
"напрямую" означает что хост с таким ип при этом
доступен на уровне L2 конекта через такойто
порт с нашего компа. тоеть то что я могу со своего
компа связаться с тем компом непрсдресвтенно через
Л2 коммуникацию. что я могу со своего компа с такого
то порта с тем компом закоммуницировать через Л2
канал связи. это означает что я могу свой Л3 пакет
передать на тот комп через Л2 канал связи через 
один из портов моего компа.

а есть маршруты с гейтвеем. это значит то что
у моего компа нет прямого Л2 канал связи с тем
компом.  а вместо этого у моего компа есть Л2
канал связи с компом посредником. котроому 
я через Л2 канал связт переам мой Л3 пакет а 
уже тот посредник займется проблемой связи с тем
конечным компом котрому и нужно передать Л3 пакет.
это значит что мой комп пошлет АРП запрос в порт
о том "кто имеет ИП посрденика? соообщим мне свой
Л2 МАК". посредник сообщит свой мак. и мой комп
через Л2 порт пошлет посреднику Л2 пакет в котром
указан мак адрес компа посреника. а внутри этого
пакета вложен ип пакет. таким образом мой комп
передаст по Л2 каналу пакет не на комп адресат
а на комп посредник. вот что значит маршрут с 
гейтвеем.

еще раз
хотел поговрить про два типа маршрутов.

первый тип маршруов - которые без гейтвея.

это значит что если у меня есть ип пакеет и он походит по такой маршрут то это значит что мой комп имеет с тем конечным компом прямой Л2 канал связи. тоеть  я из своей л2 карты
могу связаться  тем конеысным компом и его л2 картой. и поэтому л2 каналу связи переадать ему ип пакет.
выгдяит это так. мой комп шлет арп запрос с дест ип из ип пакета. в ответ я получаю л2 мак адрес конечного компа.
далее я через л2 канал связи шлю на тот комп ип пакет обрный в л2 оболочку.

есть маршрут с гейтвееем. это значит что мой комп не имеет прямого л2 канала связи с конечным компом. вместо этого мой комп имеет л2 прямой канал связи с компом посредником.
мой комп шлет арп запрос с ип компа посрденика. тот прислыает обратно свой мак. я по л2 каналу связи шлю на комп посреник ип пакет и далее проблема доаставик этого пакета до коненого компа становися проблемой того компа посрденика.


в маршруте у нас  кодируется имя порта и полный
ип который доступен (сидит) за данным портом.
таким образом если комп хочет послать выходной
пакет на IP1 и у нас в  таблице маршрутизации
указан IP1 ... dev em1
то ядро знает что данный ип доступен (сидит) 
за портом em1 и туда и нужно пихать пакет.

но так как пихать кучу полных ип в таблицу маршрути
зации это наклданая вещь потому что таблица будет
огромного размера то есть вариант когда мы 
одной строчкой может зашифровать сразу кучу 
разных ип. делается это через запись вида

  IP/маска

и имеет это смысл такой. мы берем этот ip и начиная
слева( с самого старшего бита) отрезаем ровно
столкьо бит сколько напиано в маске. а далее мы 
говорим что эта строка она под  собой кодирует
все те ип у которых отрезанная часть одна и таже
о отброшеннная часть любая. 
таким образом маска это такой способ кодирования
кучки разных ип в более короткую запись.
та часть которая отрезается условно назвыается
network id. но я хочу подчеркнуть что и маска
и network id это всего навсего хрени которые 
существуют только в голове у таблицы маршрутизации
это ее "сущности". в ип протоколе в ип пакете
нет никаких ни масок ни нетворк id.

далее я хочу подчеркнуть такую вещь что мы 
когда конфинурируем сетевой порт то мы обычно
либо в конфиге нетворк мендежера либо в утилите
ip указываем при этом

   ip адрес
   маску
   гейтвей

(гейтвей мы не укзываем в утилите ip но укаызвам
в настройках порта в сетевых менежерах)

так вот я хочу скаазать что НА САМОМ ДЕЛЕ только
ип адрес явлется настройкой порта!
а маска и гейтвей это уже нстройки таблицы
марщрутизации а не порта! просто суки они все
это засталвяют пихать вместе. а это некоректно!
гейтвей неимеет никакого отношения к настрокйам
порта. гетвей это комп который суется в маршрут
по умолчанию. а маска тоже неимеет отншения к 
настройкам порта. маска служит ядру как подсказка
для автоматического создавания +1 маршрута. 

тоеть вот нарпимер я конфиугурироую порт
#  ip addr add  local 13.13.13.13/24 dev enp0s3

по факту порту /24 маска нахрен ненжна. просто
это позволяет ядру сразу автоматом создаь 
маршрут вида

13.13.13.0/24  .... dev enp0s3

хотя по мне лучше было бы если бы люди это делали
сами руками. 

и тогда мы можем и принимать входящие пакеты
предназначеные для 13.13.13.13
и отправлять пакеты для компов с ип лежащими в
диапазоне 13.13.13.1 - 13.13.13.254

тоесть мы можем и принимать и отправлять.
если бы ядро не добавило мршрут то мы бы могли
только принимать но не могли бы открправлять. 
а для связи с компом нам нужно чтобы и прием
работал и передача. поэтму мы вроде как конуигури
руем порт а по факту и таблицу маррушрутизации
заодно (в неявном виде). 

ксатти в сететвом менджере мы обычно в графе
насройки порта еще и днс серврера всталвяем. 
совреенно очеивдно что они к порту неимеют
никкого отншения. 

таким оборазом нам втюътвают мысль о том что 
мы делали настройки сетевой карты. 
а по факту мы делаем в этом месте настройки
сетевой карты и таблицы марщрутизации и днс
сервера для резолвера. и это все разные сущности
мы настраиваем.

а вот еще прикол - броадкаст ип адрес.
по факту это может быть любой ип адрес 
асболютно любой. реално абсолютно любой
а не "последний адрес в ип сети". так как никаких
ип сетей нет ибо это просто хрень придуманная
внутри таблицы маршрутизации то нет никакого
такого ОБЯЗАТЕЛЬНОГО правила что броадкаст
ип адрес может быть только вот таким или таким.
броадкаст ип адрес может быть любой. дело вот в 
чем когда я назначаю ип адрес на карту то ядро
сразу же при этом автоматом назначает этой же 
карте второй дополнительный ип адрес котрый называе
тся броадкастовый. как оно это делает и что это
дает.

если я пишу

ip addr add local 1.1.1.1/24  dev em1

то ядро делает следущее

1. назначает карте em1 ип адрес 1.1.1.1
2. создает маршрут
   1.1.1.0/24  .... dev em1
который по сути является сверткой вот такой кучи
маршрутов
   1.1.1.0/32  .... dev em1
   1.1.1.1/32  .... dev em1
   1.1.1.2/32  .... dev em1
   ...
   1.1.1.255/24  .... dev em1

3. ядро берет последний ип из этой кучи 1.1.1.255 
   и присваивает его тоже карте но не просто как
   ип адрес а как ип адрес с особенностями.

в чем его особенность. если ко мне прилетит
пакет с таким dest ip то ядро примет этот пакет.
в целом это обычное повдеение на входящий пакет
если у нас есть такой ип на карте.
а вот второе свойство такое - если я из программы
дам комагду на отправку пакета на этот ип адрес 
то :
   если бы это был обычный ип назначенный на 
   карту компа то ядро такой пакет бы кинуло
   не на реальный порт а на LO порт.
   но так как этот ип ядро назначает броадкатовым
   то ядро кидает этот пакет реально на порт em1
   и при этом оно не делает арп запрос в сеть 
   чтобы узнать мак адрес а всталвляет броадкастовый
   мак адрес ff:ff:ff....ff
вот в чем прикол броадкастовго ип адреса.
работает  он в связке с броадкастовым мак адресом.
и нужен он для того чтобы мы с нашего компа
могли нарпавить такой ип пакет ( а каждый ип пакет
требует чтобы у него был указан dest ip) который
бы долетел до всех компов в Л2 сегменте (ну это 
достигается за счет броадкаст мак адреса) и чтобы
далее ip стек удаленных компов не отбросил бы
такой ип пакет а принял бы его и начал обрабатывать.
это кстати сработает только если все компы на которые
этот пакет долетит также у себя прописали что 
именно этот ип и для них является броадкастовым.
что это в итоге дает - я на своем компе генерирую
только один ип пакет(прям одну штуку) и сую его в сеть а в итоге он будет клонирован и долетит до
миллиона компов. тоесть моему компу ненужно 
генеирировать миллион отдельных пакетов для каждого
компа л2 сегмента.  конечно - я могу бы добавиться
того же самого если я создам л2 фрейм с 
броадкаст дест маком но я же туда длжен вставить 
ип пакет с каким то дест ип. если бы  я туда 
вставил обычный юникаст ип то конечно фрейм бы
размножился. пакет долетел бы до каждого из
миллиона компов. но когда л2 обоолочка была бы
сорвана и уже ип пакет влетает в ип стек удаленных
компов то они все такой пакет отбросили бы кроме
того едиснвенного компа котоырй бы имел тот 
самый юникаст ип. а это нам мало что дает.

так вот когда я назначаю ип моему порту
то при этом я могу назначить вобще любой ип как
бродакаст. пример который шокирует

  # ip addr add  
      local 1.1.1.1/32 
      broadcast 2.2.2.2
      noprefixroute dev enp0s3

соовтственно 1.1.1.1 и 2.2.2.2 никак не связаны
да и ненадо. 

если в меня влетит пакет для 2.2.2.2 то мое
ядро его примет.
если я буду отсылать на 2.2.2.2 то мое ядро
подставит дест мак = ff:ff:ff...ff
вот и все.

это конечно очень нелогично и не привычно
что я конфигурирую параметры порта но при этом
я обязан указать маску 1.1.1.1/32 которая к 
параметры порта неимет смысла. то есть это насильное
конфигуирование еще и таблицы маршрутизации.
а если я не поодставлю маску то комп автоматом
считает что там стоит маска /32 тоест никк я немогу
от маски избаавиться тут. едиснвтенное что я могу
при этом это запреить автоматом на основе этой
маски создаваьт маршрут 

  noprefixroute

ну и еще получается на основе маски ядро автоматом
присваивает порту броадкаст ип адрес при условии
если я его в команде сам явно не задам.

в плане брокаст ип адреса получается что 
ядро считает что если мы назначили ип адрес порту
значит у нас за пртом тоже сидят ип хосты
и что при такой ситации должен быть хотть один
ип адрес такой чтобы чрез него можно было доставлять
пакет до всех хостов в л2 сегменте сразу. 
типа без этого никак. 

ну хорошо - я еще могу поняьт что при кофигу
риовании порта они меня обязывать вставлять и 
маску чтобы таким макаром заствить меня еще и 
хаконфигурировать таблицу марщрутизации. и также
чтобы автоматом законфиуировать броадккаст ип 
адрес. окей.
но что я не понимаю почему когда я смотрю 
уже настронный порт то нахер он мне там 
покзывает в свойствах порта нетолько его ип
но и его маску. какое отноение маска которая
ялвятся искочеитлно частью таблица маршрутизации
делает в свойоствах порта? какое свойство 
порта она при этом отображает? ну я могу
только вот как обьяснить. типа я смотрю своства
порта и при этом хочу представлять какой маршрут
был добавлен при назначении этого ип этом порту
например типа я вижу


 $ ip -c a sh dev wlan0
2: wlan0: 
    inet 192.168.129.1/24 brd 192.168.129.255 scope global 

тоесть я вижу вот это 
   192.168.129.1/24
и из этого понимаю что у меня в таблце марщрути
зации длжен быть маршрут вида

  192.168.129.0/24  ..... dev wlan0

ну и детсвиельно 
  
  # ip -c r sh 
  192.168.129.0/24 dev wlan0 

но по мне это дебилизм. а именно - показывать
в свойствах порта нетолько ип а еще и маску.
потому что повторюсь - маска не имеет отношнеиия
ни к ип адресу ни к свойствам порта . это 
исклюетельно искустевенная хараектиестика таблцы
маршрутизации. что она делает в свойствах порта
я нихкя не понимаю!






такой еще момент. так как никаких ип которые
являются network id с точки зрения ип протокола 
несущстует а есть только лишь как некая хрень 
сточки зрения табицы маршрутиацзии это дает то 
что я могу аослютно спокойно назначит порту
например вот такой адрес


   1.1.1.0

и с другого компа2 с этим компом1 иметь прекрасно
связь. тоесть

комп1
  # ip addr add  
      local 1.1.1.0/24 dev enp0s3


комп2
  # ip addr add  
      local 1.1.1.1/24 dev enp0s3


получаю что на компе1 ип=1.1.1.0
на компе2 ип=1.1.1.1
на обоих компах у меня маршрут

1.1.1.0/24 ... dev enp0s3


и я с компа2 спокойно пингую себе комп1

  # ping -c2 1.1.1.0 

И НИКАКИХ ПРОБЛЕМ!




длаее такой момент default префикс
вот у нас кадый маоршрут в таице машрутизации
имеет параметр каотоырй азывается префикс. по факту
это просто хрень которая в себе кодирует один
или несколко ип адресов которые согласно этой
маршрутной записи сидят за таким то портом. 
напрмиер вот примеры префиксов

 1.1.1.1/32 ... dev em1

префикс 1.1.1.1/32 говорит о том что комп
с ип 1.1.1.1  срывается за портом em1

 1.1.1.0/24 ... dev em1

префкис 1.1.1.0/24 говотрит о том что целый рой
компов с им адресами в диапзаоне  1.1.1.0-1.1.1.255
скрывается за поортом em1
ксатаи еще раз хочу скзатаь что 1.1.1.255 не обязан
быть бррдадкаст ип адресом. этот ип споекойно
может идентицифвать обвчгый комп. надо просто
чобвы все компы в л2 сегменте договгорились что
тогда ккойто другой ип адрес явлется бродкастовым
вот и все. 
так вот есть еще один особый префикс назвается
default

default via 192.168.129.229 dev wlan0 ...

по факту он  в точности равен вот такому

 0/0

который как я поимаю в точности равен вот такому

 0.0.0.0/0


тоесть вот эти три строки это одно и тоже

default via 192.168.129.229 dev wlan0 ...
0/0 via 192.168.129.229 dev wlan0 ...
0.0.0.0/0 via 192.168.129.229 dev wlan0 ...

опять же зачем было заебвыать мозги на пустом
месте непоняно. тоесть надо было просто оставить
вот такое

0.0.0.0/0 via 192.168.129.229 dev wlan0 ...

и не запутывать мозги. (кстаи об этом написано
в man ip-route)


на самом деле опять же если у нас маска равна 0
тоесть /0 то какой у нас ип неимеет значения.
тоест вот это все одно и тоже

1.1.1.1/0
255.255.255.255/0
1.0.1.13/0

почему? как у нас работает префикс. я беру 
указный ип адрес и потом справа отрезаю от него 
столько бит сколко указно в маске. и вот эти 
биты должны в том виде чему они равны должны содер
жаться в дестинейшн ип адресе. а все остальыне биты
могу быть какие угодно. так вот так как у нас
маска равно 0 то у нас никаких обязательных битов
в ип адресе нет. поэтому все "остальные" тоесть
в итоге вообще все 32 бита могут быть какие угодно.
поэтому неважно какой ип адрес указан в префиксе
если у нас маска равно 0

к соажеадению линукс это не понимает поэтому
вот так он выдает ошику

# ip -c r add 12.12.12.12/0 via 1.1.1.4 dev enp0s3
Error: Invalid prefix for given prefix length.

но зато вот так уже все нормально
# ip -c r add 0.0.0.0/0 via 1.1.1.4 dev enp0s3

а в талице он по любому это уже заменит
на дефолт
# ip -c r
default via 1.1.1.4 dev enp0s3 

тоесть это я обясниил про что за странный
префикс default

при поиске марщрута ядро прежде всего начинает
преебирвать маршруты с максмиально длинным 
префиксом. поэтому маршурут с префиксом /0
анализируется самым последним. ну и так как 
под него попдадают вобще все возможные ип адреса
то он срабывает всегда.


тепрь наконец на счет парметра ONLINK 
в маршруте. 
дело вот в чем. что нам собщает маршрут.
он нам сообщает что за таким то портом сидит
комп с таким то ип адресом. но еще марщрут сообщает
о том есть ли с этим компом прямая Л2 связь через
данный Л2 порт. потому что порт это канал связи
уровня Л2. тоест мы хотим с компом устаноить связт
уровня Л3 но устанвливыае мы ее через канал 
связи уровня Л2. так вот прикол в том что 
у нас ест два вида маршрутов. первый вид 
маршрута нам говрит о том что через такойто
порт есть связь с компом с таким то ИП напрямую
непосдерственно через его Л2 карту связи и нашу
Л2 карту связи. тоесть на том компе есть Л2
карта связи и намоем компе есть Л2 карта связи.
и эти карты видят друг друга. 
вот пример такого маршурута

1.1.1.0/24 dev enp0s3 ...
ну или еще проще
2.2.2.2/32 dev enp0s3 

тоесть этот маршурт собщает  что моя Л2 карта
enp0s3 видит Л2 карту удаленого компа который
имеет ип адрес 2.2.2.2, Л2 мак адрес этого
компа будет выяснен в процессе арп запроса.
тоесть мы смеожем выясить мак адрес карты того
компа и моя л2 карта сможет увидеть его л2 карта
а она сможет увидеь мою л2 карту. они смогут
друг до друга достучаться по л2 каналу.
и соотсвтенно через него и можно будет отправить
ип пакет с нашего компа до  того. 
чтобы такой марршрут имел реально смысла 
всего навсего надо чтобы релаьно в Л2 брокаст
домене сидел такой комп.  у котрого нам 
видна его Л2 карта. и его ОС назначла этой карте
ип=2.2.2.2



а есть второй тип маршрута . он говорит о том что
чреез мой Л2 порт нет связи с Л2 картой удаленного
компа с таким то ИП. НО! есть прямая Л2 связь 
с другим компом - компом посредником. таким что
если я на него отправлю пакет то он обещает 
предать его тому самому удаленному компу. 
это называется маршрут с гейтвеем. 
так вот еще раз скажу что с данным посредником
обязателно между моей Л2 картой и его Л2 картой
должна быть связь. они должны видеть друг
друга. 
вот пример такого маршрута

  3.3.3.3/32 via 1.1.1.1 dev em1 ....

маршрут говрит о том что с моей л2 карты em1
не видна л2 карта компа который имеет ип 3.3.3.3
но! с моей л2 карты "видна" л2 карта другого компа
который имеет ип 1.1.1.1 и якообы это такой 
волшеный комп что если я на него пошлю ип 
пакет с dest ip=3.3.3.3 то тот комп посредник
сможет передать мой ип пакет до того компа.
все в целом хорошо но при добавлении этого 
маршрута ядро будет проверять а дейсивтельно ли 
моя Л2 карта em1 имеет прямую связь видимость 
с Л2 картой компа с ип 1.1.1.1 - как ядро это 
проверяет. нет оно не пытается пинговать 
ип 1.1.1.1 с порта em1 нет.
вместо этого ядро ишет в таблице маоршутизации
маршрут для ип 1.1.1.1
это должен быть такой маршрут который утвеждает
что до хоста 1.1.1.1 через порт em1 у нас есть
прямая Л2 связь. тоесть ядро ищет в тблице
например вот такого вида маршрут

1.1.1.1/32  dev em1

или вот такой маршрут

1.1.1.0/24  dev em1

если таких маршурутов нет то ядро при 
попытке дбавить этот марршрут (маршрут с гейтвеем)

  3.3.3.3/32 via 1.1.1.1 dev em1 ....

пошлет нас нахер
потому что логика такая. мы горим ядру - чтобы
отослать пакет до компа с 3.3.3.3 создай Л2
канал связи чрез л2 карту em1  с компом который имеет ип 1.1.1.1
что значит создай л2 канал связи - это значит 
выясни какой л2 адрес имеет комп с ип 1.1.1.1 
и устнови с ним связь через карту em1
и чтобы ядро могло это сделать ему нужно от нас
доказатлетство что с карты em1 можно будет 
связаться с Л3 картой компа с ип 1.1.1.1
если мы ядру о такой возможности неоособщили
то ядро тот маршрут с 3.3.3.3 добавляеьт не будет.
потому что мы его просим сделать чтото  о чем
у него нет доказателсьв что он сможет это сделать.
тоеть мы говоим чтобы связаться с васей позвони
пете. но ядру нужны докатещтства что он сможет
связаться  с петей. хотя по сути проблема высосана
из пльца. на саоммо деле ядру при вводе команды

  3.3.3.3/32 via 1.1.1.1 dev em1 ....

досточно послаь арп запрос в порт em1 
с ип адресом 1.1.1.1 и ели он в ответ мак адрес
получит то значит связт с 1.1.1.1 по Л2 есть
и значит маршрут можно дбавлять. а елси не полчит
то значит сввязи нет и добавлять нельзя. 
а он мозги ебет на пустом месте. мол говрит
предоствать мне докзаельсва что у меня есть 
связь с 1.1.1.1
при это замечу когда я создаю маршрут без гейтвея
любой причем например простейщий

1.1.1.1/32  dev em1

то ядро поемуто не требует докаьлеств что оно
указнную связь реально може осудществить. тоесть
за em1 никакого коампа с ип 1.1.1.1 может не 
существоать. однако он это никак не првееряет
и тупо дбавляет успещно этот маршурт. 
а в случае с маршрутом гейтвеем чеотоо начинает 
выебтваться. нелогично . несимметрчно.

так вот если я добавлю слово ONLINK

  3.3.3.3/32 via 1.1.1.1 dev em1 onlink

то ядро никаких проверок в табице марщутизации
на счет наличия маршрутов

1.1.1.1/32  dev em1

или 

1.1.1.0/24  dev em1


делать не будет. вот какой физ смысл слова ONLINK

когда эта штука в реальности встречается?
я чаще всего это видел в случае маршрутов котрые
идут чреез интфрейсы котоыре создает FLANNEL.
поэтому я к этому воросу еще вернусь.




еще бы хорошо рассмотреть скоупы
но как ни будт в следющий раз.



