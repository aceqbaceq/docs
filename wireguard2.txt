| wireguard
| в целом как оно работает

на счет того как примерно эта шарманка работает.
на клиенте хранится публичный ключ сервера PRIV_SER и приватный+публичный ключ клиента
PRIV_CL, PUB_CL

на сервере хранится публичный+приватный ключ сервера и публичный ключ клиента. PRIV_SER, PUB_SER,
PUB_CL

клиент берет свой публичный ключ шифрует его публичным ключом сервера и посылает серверу. 
по сеердине может сидеть злодей но он в пролете. злодей неможет узнать
публичный ключ клиента потому что расшифровать может только сервер. сервер смотрит в конфиг
ищет есть ли у него такой публичный ключ клиента. если есть значит пакет прислан валидным
клиентом а не левым клиентом. сервер шифрует ответ публичным ключом клиента который был прислан.
и шлет обратно. расшифровать может только клиент. скорее всего через такой обмен сервер
и клиент договариваются о сеансовом ключе симметричного шфирования так как шфирвать вест поток
через приватный\публичный ключи типа очень ресурсодорогое занятие. поэтому через него обычно
обмениваются сеансовым ключом симметричного шифрвания. 

получается ключи несимм широфвания они служат и для аутентициаации и для шифрования (на начальной
стадии).

также в pdf с сайта wireguard написано что как доп мера можно еще добавить pre-shared key 
который харнится и на сервере и на клиенте. этот прешаред кей он 256 бит по длинне.(это 32 байта
это 32 ascii символа если что)
и написано что это как доп мера. скорей всего это доп шифрование которое накадывается сверху
вторым шагом. мера опциоальная необязательная.

далее на счет того как шарманка работает. это не какойто там юзерский процесс. нет.
это модуль ядра который все и обслуживает 
	# lsmod | grep wire
	wireguard              94208  0


добавление этого модуля дает то что мы теперь можем через команду ip создавать 
интерфейс с новым типом wireguard
	
		# ip link add dev wg0 type wireguard

как ни странно хорошо все описано на сайте саомй программы https://www.wireguard.com/quickstart/
чувак не стал писать ебнутые бесполезные километры макулатуры а сразу пошел от живой практики.

и получается что чтобы впн заработал то надо на сервере создать L3 интерейс типа wiregurard
дать ему IP адрес и прочее. как бутто это просто обычный ethernet интерфейс.
и нужно еще задат параметры клиетов котрые будут подкчаться сообщить их ядру. если сам
интерйфейс создатеся через утилиту ip то  конфиг в ядро передается из тескстового файла
через команду wg 

и тут тонкий момент. всего есть две команды wg и wg-quick
как пишет автом wg-quick это некий типа скрипт который позволяет делать одновременно две вещи
и интерфейс создать и конфиг в ядро передать. как  я понимаю wg-quick он работает так.
он читает конфиг. все то что относится к тому что должен делать утилита ip он ей скармливает.
а то что в когфинге относится к утилите wg он ей ту часть конфига скармливает.
тоесть можно пользоваться утилитами ip + wg а можно  в простых случаях воспользоваться
wg-quick которая их сама вызоывает и все что им надо подсунет.
поэтому конфиг он может содеражть часть инфы которая предназнчаена для ip а часть 
для wg поэтому неудивтельна вот такая команда напрмиер когда мы обновили конфиг
и хотим чтобы он был обновлен и внутри ядра


	# wg syncconf wg0 <(wg-quick strip wg0)

(тут я отдельно хочу выделить что вот эта хрень <(wg-quick strip wg0)  это не 
file\io redirect это нечто совершенно другое это тот самый долбаный process substitution
о нем можно прочитать портянку в bash.txt ищи по фразе "process substitution")

wg-quick strip wg0 дает то что  wg-quick ищет конфиг с именем /etc/default/wg0.conf
далее он его читает и выкидывает из него все что не отночится к конфугирования модуля ядра
и передает это уже предается на вход в wg утилиту.

тоесть еще раз какая система. нам нужно вначале создать в линуксе интерфейс типа wireguard
это делается через утилиту ip.

далее нужно ядру передать конфиг со списком клиентов. это делается через конфиг файл
и утилиту wg

но можно эти два процесса соединить в один. 
можно написать конфиг который влключает в себя как настройки предназнчаченные для утилиты ip
так и настройки преданзчнаыенные для утилиты wg и потом все это вместе запустить через 
утилиту wg-quick, она прочитает конфиг. выееберет оттуда все то что предназанчаено для ip
и скормить ей. потом выберет все то что преначено для wg-quick и скормит ей. 

если у нас интрейс уже создан но мы изменили конфиг клиентов то его передать в ядро
можно двумя путями. если когфиг содержит настроки только относящиеся к ядру то 

	# wg syncconf wg0 < /etc/default/wg0.conf

а если в нем есть постороние строчки то их нужно оттуда вычленить через

	# wg syncconf wg0 <(wg-quick strip wg0)

(тут я отдельно хочу выделить что вот эта хрень <(wg-quick strip wg0)  это не 
file\io redirect это нечто совершенно другое это тот самый долбаный process substitution
о нем можно прочитать портянку в bash.txt ищи по фразе "process substitution")



ксатти вот можно убедиться что wg0 имеет тип wireguard

$ ip -c -d l  sh wg0
76: wg0: <POINTOPOINT,NOARP,UP,LOWER_UP> mtu 1420 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/none  promiscuity 0 
    wireguard addrgenmode none numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 
     /\
     ||




| wireguard
| как добавить клиента

поехали на практкие

для того чтобы мы могли добавить клиента то нужно
сгенерировать для клиента:
	приватный ключ
	публичный ключ
	preshared key

прешаред кей будет хранится на сервере и клиенте. 
приватный ключ будет хранится на клиенте. 
публичный ключ будет хранится и на клиенте и на сервере

генерацию этих хреней можно делать хоть на сервере хоть на клиенте

генерируем прешаред кей
	$ umask 077; wg genpsk
    VE+QfnKXbVuoI9k7ShCiFmwPfruvd1PR/dUFCPb2uVg=       <==== занчение для примера

как видим на экране прешаред кей выводиться в base64 кодировке
чтобы посмотреть чему он равен в виде исходных байтов то 

	$ echo 'VE+QfnKXbVuoI9k7ShCiFmwPfruvd1PR/dUFCPb2uVg=' | base64 -d | od -t x1
	54 4f 90 7e 72 97 6d 5b a8 23 d9 3b 4a 10 a2 16
	6c 0f 7e bb af 77 53 d1 fd d5 05 08 f6 f6 b9 58

тоесть здесь четко видно что дейтсивтелно прешаред кей это 32 байта или 256 бит


гененрируем приватный и публичный ключ 

	$ umask 077; wg genkey | tee private.key | wg pubkey > public.key

 	$ ls -1al *
	-rw------- 1 vasya vasya 45 июн  3 16:19 private.key
	-rw------- 1 vasya vasya 45 июн  3 16:19 public.key

пусть private.key = 2222222222222222222222222=
пусть public.key  = 1111111111111111111111111=
пусть прешаред кей = 5555555555555555555555555

теперь можно составит конфиг на клиенте
$ cat  ~/wireguard/wg0.conf 
[Interface]
PrivateKey = 2222222222222222222222222=         # приватный ключ эттого компа 
Address = 10.66.66.5/32                         # VPN LAN этого компа
DNS = 1.1.1.1

[Peer]
PublicKey = 3333333333333333333333333H0=        # публиый ключ удаленного VPN сервера
PresharedKey = 55555555555555555555555555       # прешаред кей 
Endpoint = 14.14.14.14:60805                    # WAN IP удаленного VPN сервера
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25






на удаленном сервере 
добавляем в конфиг
### newClient
[Peer]
PublicKey = 111111111111111111111111111111=     # публичный ключ удаленного клиента
PresharedKey = 5555555555555555555555555555=
AllowedIPs = 10.66.66.5/32,fd42:42:42::5/128  # VPN LAN такой же как в конфиге клиента

ОБРАЩАЮ ВНИМАНИЕ что в конфиге на сервере для этого клиента в строке 
PublicKey нужно вставить паблик кей клиента! а не сервера!


после того как добавили в конфиг на сервере
то на сервере надо выполнить либо

	(сервер)# systemctl reload wg-quick@wg0.service

либо можно сделать вручную то как написано в файле 
# cat /lib/systemd/system/wg-quick@.service
...
ExecReload=/bin/bash -c 'exec /usr/bin/wg syncconf %i <(exec /usr/bin/wg-quick strip %i)'

тоесть
	(сервер)# wg syncconf wg0 <(wg-quick strip wg0)

(тут я отдельно хочу выделить что вот эта хрень <(wg-quick strip wg0)  это не 
file\io redirect это нечто совершенно другое это тот самый долбаный process substitution
о нем можно прочитать портянку в bash.txt ищи по фразе "process substitution")


теперь на сервере можно проверить что новый клиент добавился в конфиг

	(сервер)$ wg show
	...
	peer: 1111111111111111111111111111111111111111=
    preshared key: (hidden)
    allowed ips: 10.66.66.3/32,

тость появится строчка  с публичныым ключом нашего клиента.
при том что наш клиент еще не подключался


теперь идем на клиент
берем наш конфиг клиенсткий

$ cat  ~/wireguard/wg0.conf 
[Interface]
PrivateKey = 2222222222222222222222222=         # приватный ключ эттого компа 
Address = 10.66.66.5/32                         # VPN LAN этого компа
DNS = 1.1.1.1

[Peer]
PublicKey = 3333333333333333333333333H0=        # публиый ключ удаленного VPN сервера
PresharedKey = 55555555555555555555555555       # прешаред кей 
Endpoint = 14.14.14.14:60805                    # WAN IP удаленного VPN сервера
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25


и если клиент это телефон то надо этот конфиг превратить в QR код
либо вот так

	$ qrencode -t ASCIIi < ~/wireguard/wg0.conf

либо вот так

	$ qrencode -t ansiutf8  <  ~/wireguard/wg0.conf

ВНИМАНИЕ программа qrencode тупая. и ей нужно скормить файл именно через галочку "<"
иначе этот дебил не понимает.
фишка флагов 
	-t ASCIIi
	-t ansiutf8
в том что qr код будет напечатан прям в терминале. тоесть в текстовом виде!
ненужен никакой графический режим! для qr кода самое главное чтобы были темные участки
и светлые и все! очень удобно!

теперь на теелефоне можно сфоткать этот qr код и "впитать" конфиг. готоово.

далее включаем впн на телефоне. идем на сервер 
и смотрим пошла ли статистика

	(сервер)$ wg show
  peer: 11111111111111111111111111111111111=
  latest handshake: 1 minute, 38 seconds ago
  transfer: 1.33 MiB received, 73.43 MiB sent

сеанс окончен. все окей.

в целом на теелефоне там где впн добавляется там можно выбрать справа вверху в трех точках
чтобы засосать конфиг не через QR код а вручную вбивая параметры. (это на случай если 
с qr кодом траблы).


| wireguard
| wg-quick


когда мы его азпускаем то он нам прям на экране покзывает
какие команды wg-quick заупскает. еще раз доазказывая что wg-quick это чтото
типа фронтенд скрипта

  $ wg-quick up  ~/wireguard/wg0.conf
[#] ip link add wg0 type wireguard
[#] wg setconf wg0 /dev/fd/63
[#] ip -4 address add 10.66.66.5/32 dev wg0
[#] ip link set mtu 1420 up dev wg0
[#] resolvconf -a tun.wg0 -m 0 -x
[#] wg set wg0 fwmark 51820
[#] ip -4 route add 0.0.0.0/0 dev wg0 table 51820
[#] ip -4 rule add not fwmark 51820 table 51820
[#] ip -4 rule add table main suppress_prefixlength 0
[#] sysctl -q net.ipv4.conf.all.src_valid_mark=1
[#] iptables-restore -n

надо эти команды изучить понять че они делают


| wireguard nmcli
| nmcli
| Network Manager

как имея конфиг wiregueard его импртировать в Network manager

	$ nmcli conn import type wireguard file ~/wireguard/wg0.conf

только это работает начиная с нетворк манаджер какйто версии. 
на убунту18 это не работает. а на арч это работает

в каких то версиях нужен был плагин а как пишут в инете с какйо то вресии нетворк
манагер поддерживает импорт конфига от вайргард уже без всяких плагинов а просто так.

