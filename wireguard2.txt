| wireguard
| install
| setup
| установка


как поставить

обпираюсб на 
	https://www.digitalocean.com/community/tutorials/how-to-set-up-wireguard-on-debian-11

а также конфиг с уже раобтающего сервера


	$ sudo apt update
  $ sudo apt install wireguard

	$ wg genkey | sudo tee /etc/wireguard/private.key
	$ sudo chmod go= /etc/wireguard/private.key

	$ sudo cat /etc/wireguard/private.key | wg pubkey | sudo tee /etc/wireguard/public.key
	$ sudo chmod go= /etc/wireguard/public.key

на счет chmod отсылаю прочитаь "chmod.txt"
в итоге мы получаем вот такие прмишнсы

	$ sudo ls -1al /etc/wireguard/
	drwx------  2 root root 4096 июн 11 11:16 .
	-rw-------  1 root root   45 июн 11 11:14 private.key
	-rw-------  1 root root   45 июн 11 11:16 public.key


из чего видно что ключи могут читать писать только root более того в папку 
может зайти только root и больше никто

вот эти файлы с ключами мы их создаем для себя для справки
потому что по факту вайргард эти файл использовать в своей работе 
не будет!
он будет исползвать только файл котоырй мы создадим следущим.
в него то как раз и нужно будет вставить значение из файла private.key
а значение из файла public.key нам нужно будет вставлять на клиентский комп

далее создаем конфиг для сервера

	# > wg0.conf
	# chmod go= ./wg0.conf


	/etc/wireguard/wg0.conf
	[Interface]
	PrivateKey = base64_encoded_private_key_goes_here
	Address = 172.16.10.1/24
	ListenPort = 51820
	SaveConfig = true


далее
	/etc/sysctl.conf
	net.ipv4.ip_forward=1

	# sysctl -p


далее добавляем  в wg0.conf кусок
PostUp = iptables -I INPUT -p udp --dport 51820 -j ACCEPT
PostUp = iptables -I FORWARD -i eth0 -o wg0 -j ACCEPT
PostUp = iptables -I FORWARD -i wg0 -j ACCEPT
PostUp = iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D INPUT -p udp --dport 51820 -j ACCEPT
PostDown = iptables -D FORWARD -i eth0 -o wg0 -j ACCEPT
PostDown = iptables -D FORWARD -i wg0 -j ACCEPT
PostDown = iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE



в итоге мы имеем wg0.conf
	/etc/wireguard/wg0.conf
	[Interface]
	PrivateKey = base64_encoded_private_key_goes_here
	Address = 172.16.10.1/24
	ListenPort = 51820
	SaveConfig = true
  PostUp = iptables -I INPUT -p udp --dport 51820 -j ACCEPT
  PostUp = iptables -I FORWARD -i eth0 -o wg0 -j ACCEPT
  PostUp = iptables -I FORWARD -i wg0 -j ACCEPT
  PostUp = iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
  PostDown = iptables -D INPUT -p udp --dport 51820 -j ACCEPT
  PostDown = iptables -D FORWARD -i eth0 -o wg0 -j ACCEPT
  PostDown = iptables -D FORWARD -i wg0 -j ACCEPT
  PostDown = iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE


далее пока запускать вайргард. через systemd
в пакете вайргард входит юнит. который лежит вот тут 

					/lib/systemd/systemwg-quick@.service


	# systemctl enable wg-quick@wg0.service  --now


в чем прикол варгард о чем я будут говоить ниже в сеции описывающей как он работает
это то что мы привыкли что когда мы запустили юнит через systemd то мы ждем что появится
юзерский процесс так называемый сервис или демон.  а у вайргарда такого нихрена нет!
дело в том что вайргард сидит в ядре! он как модуль ядра сидит в ядре! и поэтому после 
запуска системд юнита никакого вайргард юзер процесса в списке процессов не появится!
все что делает системд юнит вайргарда это он через утилиты wg-quick и wg просовывается
конфиг  в ядро в модуль вайргард.


далее мне пришла мысль что вайргард раотает не по модели клиент сервер а я бы сказал 
по модели peer-to-peer потому что клиент от сервера по настройке мало чем отличается. 
ХА-ХА-ХА! 

посмтреть статистику можно через 

	# wg show wg0
	# wg showconf wg0


тут я хочу скзать что по факту конфи настройки что сервера что клиента
сосоттоит из одинаковых двух частей это 

	/etc/wireguard/wg0.conf
	[Interface]
  ...
  ...

  [Peer]
  ...
  ...


пока что мы на серверер создали только сецию [Interface]
секцию [Peer] мы добавим чуть позже

на сервере нужно в iptables открыть UDP порт  который происиан в конфиге серервера 
в строке

		ListenPort = 51820






переходим к настйроке клиента

также генерриуем приватный и публичный ключ
ксати вместо chmod можно заюзать umask

	$ mkdir ~/wireguard
	$ umask 077; wg genkey | sudo tee ~/wireguard/private.key
	$ umask 077; cat ~/wireguard/private.key | wg pubkey | tee ~/wireguard/public.key


создаем конфиг для клиента
	$ umask 077; true > ~/wireguard/wg1.conf

	$ cat wg1.conf 
	[Interface]
	PrivateKey = 1111111111111111111111=
	Address = 172.16.10.3/32
	DNS = 1.1.1.1

	[Peer]
	PublicKey = 2222222222222222222222222=
	PresharedKey = 333333333333333333333333=
	Endpoint = 3.3.3.3:51820
	AllowedIPs = 0.0.0.0/0
	PersistentKeepalive = 25


приватный ключ  всталяем клиента который сгенрировали
Address всталвяем из той же сети что и на серврее только конец меняем
publickey это пира тоесть сервера поэтому серверный
endpoint это пира тоесь сервера его WAN IP



далее надо добавить секцию [peer] на сверрвер

	/etc/wireguard/wg0.conf
	[Interface]
	PrivateKey = base64_encoded_private_key_goes_here
	Address = 172.16.10.1/24
	ListenPort = 51820
	SaveConfig = true
  PostUp = iptables -I INPUT -p udp --dport 51820 -j ACCEPT
  PostUp = iptables -I FORWARD -i eth0 -o wg0 -j ACCEPT
  PostUp = iptables -I FORWARD -i wg0 -j ACCEPT
  PostUp = iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
  PostDown = iptables -D INPUT -p udp --dport 51820 -j ACCEPT
  PostDown = iptables -D FORWARD -i eth0 -o wg0 -j ACCEPT
  PostDown = iptables -D FORWARD -i wg0 -j ACCEPT
  PostDown = iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE

	### Client 	
	[Peer]
	PublicKey = 55555555555555555555555555555555555555=
	PresharedKey = 66666666666666666666666666666666666=
	AllowedIPs = 172.16.10.3/32


пабликкей и прешаредкей нужно вставить взяв данные с клиента
ip адрес дожен совпалать с тем что на клиенте

накатываем конфиг на сервере

	# wg setconf wg0 <(wg-quick strip /etc/wireguard/wg0.conf wg0)

проверяем что накатлся

	# wg show wg0

дожен появится пир
но не в том плане что он подключился а втом плане что он о нем заранее знает теперь
о пире котоырй бует к нему пдключаться.

идем обратно нак лииент и поднимает туннель

	$ wg-quick up ~/wireguard/wg0.conf


профит!










| wireguard
| в целом как оно работает


его работа похожа на iptables. есть ядро , есть его модули. так вот iptables
это набор модулей ядра
типа вот таких

iptable_raw            16384  1
iptable_mangle         16384  1
iptable_nat            16384  1
ipt_REJECT             16384  3
nf_reject_ipv4         16384  1 ipt_REJECT
nf_log_ipv4            16384  8
nf_log_common          16384  1 nf_log_ipv4
nf_nat                 40960  3 nf_nat_ftp,iptable_nat,xt_MASQUERADE
nf_defrag_ipv6         24576  1 nf_conntrack
nf_defrag_ipv4         16384  1 nf_conntrack
iptable_filter         16384  1
ip_tables              32768  27 iptable_filter,iptable_raw,iptable_nat,iptable_mangle
x_tables               45056  19 ebtables,ip6table_filter,xt_conntrack,iptable_filter,xt_LOG,xt_tcpu


они и выполняют функционал работы iptables. 
через юзер спейс утилиту мы пропижиываем конфиг то что мы хотим в ядро.
и как одно из следствий это то что в юзер спейсе нет никакого демона который бы
реализовывл  функционал . потому что весь код сидит в ядре.

так вот ровно такую же ситацию мы имеем и с вайргард.
его код сидит в ядре. в модуле

		$ lsmod | grep wire
		wireguard             221184  0
	
этот модуль и херачит весь фнукционал работы вайргарда. 
в тоже время у нас есть варгард юнит systemd 

			/lib/systemd/system/wg-quick@.service

он всего навсего делает то что при его запуске запускается утилита wg-quick
которая читает конфиг и этот конфиг сует в ядро. вот и все что делает этот модудль.
тоесть он не создает демона как мы привыкли а то что этот юнит он всего навсего
передает конфиг в модуль ядра. вот и все. демона никакого несозадается.
тогда взниуактает впорос а как понять что вайргард работает? если демона то нет.
мы привыкли что если демон среди процессов есть значит хрень работает а если домена
нет то и хрень неработает. так вот проверки их две

первая проверка
это проверить загружен ли модуль вайргарда
			$ lsmod | grep wire
			wireguard             221184  0


вторая проверка это вот такая команда
причем на клиенте который подкючен к серверу вайргарда вывод будет
примерно такой

	$ sudo wg show
interface: wg0
  public key: 11111111111111111111111=
  private key: (hidden)
  listening port: 43001
  fwmark: 0xca6c

peer: 22222222222222222222222222222222222222=
  preshared key: (hidden)
  endpoint: 1.1.1.1:51820
  allowed ips: 0.0.0.0/0
  latest handshake: 1 minute, 40 seconds ago
  transfer: 1.49 GiB received, 23.52 GiB sent
  persistent keepalive: every 25 seconds


на сервере вайргарда будет вывод вот такой прмиерно

	# wg  show
interface: wg0
  public key: 33333333333333333333333333333333=
  private key: (hidden)
  listening port: 51820

peer: 444444444444444444444444444444444444444=
  preshared key: (hidden)
  endpoint: 9.9.9.9:41932
  allowed ips: 10.66.66.5/32, fd42:42:42::5/128
  latest handshake: 4 seconds ago
  transfer: 187.93 GiB received, 19.69 GiB sent


тогда мы четко понимает что ваайргард "работает". и мы видим его "конфиг"
также приколно что в каокто степени что сервер что клиент одна хрень

если у нас ни модуля ядра не загружен и\или если  # wg show
покзаывает пусто. значит конфиг в модуль не передан. и модуль просто 
болтается пустой.

что еще интересно это то что когда мы работаем чреез этот впн то 
что на сервере что на клиенте у нас не будет в сетевых конектах видны 
конекты между клинетом и серверром впн. у нас сервер впн принимает пакеты по UDP порт 51820
но это все раобтает уже внутри пространство ядра. юзер спейс этого ничего не видит.
поэтому в netstat что на сервере что на клиенте мы не увидим никаких сокетов ведущих
на UDP 51820
щас обьясню.

как у нас работает обычная отправка по сети. без впн. у нас есть процесс он говорит
через сисколл ядру открой мне сет сокет на удаленный tcp сервер 8.8.8.8 порт 1234
ядро открывает в своих недрах внутри сокет а процессу оно возрващает файловый дескриптор.
который ведет в ядре на стркутуру называемую сет сокет.

пример я зуппукаю программу 
	
	$ ping -4 8.8.8.8

смотрим какие файло декрипторы имеет этот процесс

	$ sudo ls -1al  /proc/26182/fd
			0 -> /dev/pts/19
			1 -> /dev/pts/19
			2 -> /dev/pts/19
			3 -> 'socket:[361993541]'
 

мы видим что помимо терминал файлов у нас открыл файл сокет. процесс пишет данные
в этот фаайл дескриптор 4. а ядро уже пихает эти данные в сетевую карту. 
так вот утилиты которые позуывают статистику по сет сокетам они как работают ( как я поимаю)
они сканируют /proc ищут те файл дескрипторы которые ведут  в сокеты. тоесть мне кажется что
с точки зрения юзер спейс утилит если сокет есть это значит что ест какойто процесс 
который имеет файл дескриптор который в ядре ведет в сокет. а сокет это некая ядерная структура
которая "доступна" процессу через файл дескриптор. как я понимаю само ядро может тоже 
открывать сокеты. но с точки зрения юзер спейса этих сокетов нет. незнаю может 
какото сисколл можно сделать который показывает все сокеты внутри ядра. хрен знает.

ксати пинг он открывает не tcp и не udp сокет а raw сеетеовой сокет.
и вот как его можно отловить в netstat 

	$ sudo netstat -n -p -a | grep -E "Proto|26182"
Proto    Recv-Q   Send-Q   Local Address     Foreign Address    State   PID/Program name    
raw      0        0        0.0.0.0:1         0.0.0.0:*          7       26182/ping          

а вот как через ss

$ sudo ss -4 -n -p -w | grep -E "Recv|26182"
State    Recv-Q   Send-Q  Local Address:Port    Peer Address:Port                                                                                    
UNCONN   0        0       0.0.0.0:1             0.0.0.0:*            users:(("ping",pid=26182,fd=3))                                                


далее  я посмотрел  в man proc и выяснил что на самомо деле у каждого процесса в 
				/proc/self/net/.... 
доступна инфо из ядра о сотоянии севеого стекка в целом для данного сетевого неймспейса
в котором сидит процесс.  в частности 

	/proc/self/net/raw
	/proc/self/net/tcp
	/proc/self/net/udp
	/proc/self/net/unix

в этих хренях содерится инфо о сетевых и локальных сокетах от всех процессов котоыре 
сидят в одном и том же сетевом неймспейсе! поэтому netsatt и ss они не сканируюу все 
дереро в /proc они тупа анализируеют содержимое этих файлов!

щас покажу на примере raw файла

$ cat /proc/self/net/raw
sl   local_address rem_address   st ... uid   inode ref pointer drops
1:   00000000:0001 00000000:0000 07 ... 1000  361993541 2 0000000000000000 0
255: 00000000:00FF 00000000:0000 07 ... 0     358940395 2 0000000000000000 0


и вот выше в процессе который пинг у нас дескриптор 3 ведет в ядро на иноду

	3 -> 'socket:[361993541]'

и вот мы видим совпдаение 361993541 
жалко что в этой таблице ядро не показывает какой процесс создал этот процесс.
но в этой таблице есть uid юзера который заказал у ядра создание этого сокета

ну по идее тогда надо брать из этой таблицы значение иноды а потом все равно сканировать
всю /proc и искать в каком процессе открыт дескриптор этот дескиптор который ведет в эту 
иноды.

например будем искать вот так

$ sudo find /proc -type l -name "[0-9]" -exec  bash -c '  echo -n "  {}    "; readlink "{}" '    ";" 2>/dev/null  | grep 361993541

  /proc/26182/fd/3    socket:[361993541]

итак мы нашли руками процесс. это 26182. что же это за процесс?
㷇  $ ps aux | grep 26182
vasya    26182  0.0  0.0  16320  1080 pts/19   S+   июн11   0:03 ping -4 8.8.8.8

а это наш тот самый пинг!

теперь  я замечу вот что. что таблица сокетов в каждой строке содержит uid юзера который
у ядра заказал создание этого сокета. получается что если в самом ядре есть код который
хочет в сеетвую карту чтото сунуть (правда я не знаю он при этмо создает сокет в памяти ядра
или нет) то это в этой таблице сокетов не будет отражено! во первых потому что неизсветно 
само ядро если оно чето шлет от себя создает ли оно сокеты у себя в памяти и во вторых
для такого сокета нет никаоко юзера. потому что его создало само ядро. а в ядре нет
никаких юзеров.
и тут надо рассмотреть как у нас создается сокет в приложении когда у нас связт идет 
без впн и когда с впн. в чем разница в плане сокета который получается. вот у нас
ssh клиент говорит ядру - эй ядро откроой создай мне TCP сокет у котоого 
	remote ip address = 1.2.3.4 и 
	tcp remote port = 22

ядро смотрит в таблицу маршрутизаиции и находит ту сетевую карточку через которую 
у нас идет подходящий марушрут в данном случае это будет сет карточка через котрую 
проходит default route. пусть это будет карточка eth0 с IP=192.168.0.10 
тогда ядро создает в своей памяти сетевой tcp сокет 
с паараметрами

	socket №23 local_ip=192.168.0.10 tcp_port=23456 remote_ip=1.2.3.4 tcp_port=22

для этого сокета и данного процесса ядро создает файл дескриптор. и возвращает его 
процессу юзера. 
также ядро через эту  карту шлет в сеть пакет SYN
и мы этот сокет видим в списке сокетов в /proc/self/net/tcp

теперь преставим что мы подняли вайргард. он создал сет карту wg0 и он там хитро
добавляет маршрут в таблицу марушрутизации причем он его доабвляем в отедельную таблицу
еще и в iptabels таблице он в мангл добавляет метку. (как это в точности работает я пока не понял)
в итоге у нас вот что происходит когда у нас процесс делает тоже самое как в предыдущем
примере то ядро выбиирает в качестве карточки виртуальную карту wg0
и если процесс попросить ядро открыт tcp сокет  с
	remote ip address = 1.2.3.4 и 
	tcp remote port = 22
и если wg0 имеет local_ip=10.0.0.6 то ядро создаст вот такой сокет

	socket №24 local_ip=10.0.0.6 tcp_port=23457 remote_ip=1.2.3.4 tcp_port=22


и вернет процессу дескриптор скажем fd/5 который ведет на этот сокет.  а дальше 
будет интересно. в случае когда карта была реальная физическая то ядро высирало 
через ту карту пакет IP реалбно сразу  в сеть и этот ip пакет имел паарметры как мы
закзаали 

 [ IP: local_ip=192.168.0.10 remote_ip=1.2.3.4 [TCP: tcp_port=23456 tcp_port=22] ]


в нашем же случае карта wg0 поэтому пакет выглядит вот так

 [ IP: local_ip=10.0.0.6 remote_ip=1.2.3.4 [TCP: tcp_port=23456 tcp_port=22] ]

итак у нас в таблице сокетов которые видны из юзер спейса создана строка c сокетом вида

	socket №24 local_ip=10.0.0.6 tcp_port=23457 remote_ip=1.2.3.4 tcp_port=22


я пока мало рублю в сокетах как с ними работать из си. тоесть вопрос юзеркская программа
когда открыла сокет она может просто брать и пихать только payload тоесть полезные байты
в этот сокет? скажем текст "мама мыла раму" или наша юзер программа должна пихать в файл
дескрпитор какието параметры заголовка tcp хидера еще? или этой этой грязной работой
уже ядро только занимается? это я пока не знаю. полагаю что всей грязной работой в плане
звголовоков заниммается прозрачно ядро а юзер прогармма ничего об этом не знает а просто
пихает в сокет толко полезный пейлоад.  тогда вот что когда у нас сокет был связан 
с реальной физ картой то у нас бы в сеть улетел пакет с загловкаами

 [ IP: local_ip=10.0.0.6 remote_ip=1.2.3.4 [TCP: tcp_port=23456 tcp_port=22] ]

но так как у нас wg0 карта виртуальная. и обсбуживает ее драйвер вайргарда. то он 
берет наш пейлоад. шифрует его. а потом он уже сам еще раз смотрит в таблицу маршутиацзии
находит физ карту. и создает новый IP UDP пакет который уже реально высирается в сеть
и будет иметь вид

 [ IP: local_ip=192.168.0.10 remote_ip=1.2.3.4 [UDP: udp_port=5678 udp_port=51820] ]

где 51820 это udp порт wirefuard сервера удаленного.
создает ли при этом ядро доп сокет чтобы отслеживать это сетевое соедиение  я не знаю.
но в списке созданных сокетов в файле /proc/self/net/udp ничего не будет! 


но так как это непросто карта а виртуальная карта которую обслуживает и поэтому
подсистеме ядра которая осблуживает эту карту она берет наш пакет шифрует его. 
далее ядро еще раз смотрит в таблицу мрашрутизации выбирает реальную сет карту
и обрачивает наш шифровннй пакет в новый пакет IP + UDP пакет с парамтрами

 [ IP: local_ip=192.168.0.10 remote_ip=1.2.3.4 [TCP: tcp_port=23456 tcp_port=22] ]

я подытожу.
вот такой у нас будет висеть параметр сокета в таблице сокетов  в юзер спейс

	socket №24 local_ip=10.0.0.6  remote_ip=1.2.3.4 tcp_port=23457 tcp_port=22

а вот такой пакет по факту улетит в сеть

 [ IP: local_ip=192.168.0.10 remote_ip=1.2.3.4 [TCP: tcp_port=23456 tcp_port=22] ]

в итоге получается очень интересная ситуация. согласно записи в сокете то у нас пакет
вылетел из ядра в сеть через карту wg0 а на самом деле у нас пакет вылетел из ядра
в сеть через карту eth0. согасно записи в сокете у нас ip пакет имел параметры

	source_ip=10.0.0.6 dest_ip=1.2.3.4

а на самом деел реальный пакет имел парметры


	source_ip=192.168.0.10 dest_ip=1.2.3.4

согласно сокету внутри был tcp пакет
а по факту внутри был udp пакет

и это реально трындец. в прицнипе процесс юзерский вообще не колыше какие парметры
имеет сокет потмоу что сокет это структура в ядре и процсс к ней неимет доступа.
процесс всго нвсего пишет в дескриптор и читает из него. а сокет это уже внутненняя
кухня ядра которая к процессу неимеет отгшения. 

получется что записи в сокете в части протокола + dest_IP  + dest_port они соотсветвуют тому 
как мы заказали когда обратились к ядру .  записи вида source_ip и source_port 
это то как нам ядро пояснило через какую карту якобы пакет был высран в сеть. 
но что по факту произошло внутри ядра мы нихуя не знаем! мы только можем доагдыаться!
если мы даже забудем про впн то вспонмиим iptables и SNAT. скажем нам ядро обещает что 
пакет при вылете будет иметь source_ip=192.168.0.10 а на самом деле у нас внутри ядра 
может iptables поменять source ip на какойто другой. дальше пока мне все мутно видится.
вобщем парамтеры сокета это то с какимм параметрами якобы пакет улеетел в сеть. но 
по факту это может быть сильно нетак. мы согласно таблице сокетов можем думать что 
у нас пакет улетел в сеть в видее IP+TCP а по факту ядро перехуярило пакет и в сеть
его может отпрвть в виде IP+UDP и все такое! ХАХАХАХАХАХАХ! исходя из этого мы думаем 
ой у меня неработает потому что на файровлле надо открыть таки то порты и протколы
а на самом деле другие порты и протколы! это очень забавно.

исходя из этого если у нас поднят вайргард мы никогда не увидим в списке сокетов
через netstat или ss или cat /proc/self/net/udp сокеты которые работают на порту удаленного
вайргад сервера. хАХАХАХАХА! солгасно списку сокетов никаого сетевого обмена с удаленным 
вайргард сервером небудет!  с точки зраения сокетов нам будет казастся что мы вдеедем 
сетевой обмен со всякими там веб серверами ютубами. а на самом деле все идет же
на удаленный вайргард сервер. а уже оттуда он это перенправляет на заказные нами 
веб сервера. это назыается прозрачное проксирование. таким мккаром наш трафик проходя
по сети может заворачиываться на ментовский сервер и там просматриваться поэтому так важно
чтобы вес трафик был шифорванный чтобы заворчивакй на заворачивай хуй там что увидел!
но в целом мое это длинное обьяснение было посвязщено тому что если у нас заработала
связь через вайргад мы не увидим в списке сокетов сетевых через netstat или ss
чтобы у нас была связь с удаленным вайргард сервером. ее как бы нет. потому что сокеты
они показывают нам сететвую связь которцю мы заказываем у ядра. а какая свызь у нас по факту
ядро устравивает это уже от нас скрыто. так как наш сетевой поток прехываетывает вайргард 
в ядре то от нас скрыто это и встатистику сокетов это ниак не попадает!
получается это только частично мжоно увидеть через
		
		# wg show

и еще может быть через tcdump 



далее продожим 
на счет того как примерно эта шарманка работает.
на клиенте хранится публичный ключ сервера PRIV_SER и приватный+публичный ключ клиента
PRIV_CL, PUB_CL

на сервере хранится публичный+приватный ключ сервера и публичный ключ клиента. PRIV_SER, PUB_SER,
PUB_CL

клиент берет свой публичный ключ шифрует его публичным ключом сервера и посылает серверу. 
по сеердине может сидеть злодей но он в пролете. злодей неможет узнать
публичный ключ клиента потому что расшифровать может только сервер. сервер смотрит в конфиг
ищет есть ли у него такой публичный ключ клиента. если есть значит пакет прислан валидным
клиентом а не левым клиентом. сервер шифрует ответ публичным ключом клиента который был прислан.
и шлет обратно. расшифровать может только клиент. скорее всего через такой обмен сервер
и клиент договариваются о сеансовом ключе симметричного шфирования так как шфирвать вест поток
через приватный\публичный ключи типа очень ресурсодорогое занятие. поэтому через него обычно
обмениваются сеансовым ключом симметричного шифрвания. 

получается ключи несимм широфвания они служат и для аутентициаации и для шифрования (на начальной
стадии).

также в pdf с сайта wireguard написано что как доп мера можно еще добавить pre-shared key 
который харнится и на сервере и на клиенте. этот прешаред кей он 256 бит по длинне.(это 32 байта
это 32 ascii символа если что)
и написано что это как доп мера. скорей всего это доп шифрование которое накадывается сверху
вторым шагом. мера опциоальная необязательная.

далее на счет того как шарманка работает. это не какойто там юзерский процесс. нет.
это модуль ядра который все и обслуживает 
	# lsmod | grep wire
	wireguard              94208  0


добавление этого модуля дает то что мы теперь можем через команду ip создавать 
интерфейс с новым типом wireguard
	
		# ip link add dev wg0 type wireguard

как ни странно хорошо все описано на сайте саомй программы https://www.wireguard.com/quickstart/
чувак не стал писать ебнутые бесполезные километры макулатуры а сразу пошел от живой практики.

и получается что чтобы впн заработал то надо на сервере создать L3 интерейс типа wiregurard
дать ему IP адрес и прочее. как бутто это просто обычный ethernet интерфейс.
и нужно еще задат параметры клиетов котрые будут подкчаться сообщить их ядру. если сам
интерйфейс создатеся через утилиту ip то  конфиг в ядро передается из тескстового файла
через команду wg 

и тут тонкий момент. всего есть две команды wg и wg-quick
как пишет автом wg-quick это некий типа скрипт который позволяет делать одновременно две вещи
и интерфейс создать и конфиг в ядро передать. как  я понимаю wg-quick он работает так.
он читает конфиг. все то что относится к тому что должен делать утилита ip он ей скармливает.
а то что в когфинге относится к утилите wg он ей ту часть конфига скармливает.
тоесть можно пользоваться утилитами ip + wg а можно  в простых случаях воспользоваться
wg-quick которая их сама вызоывает и все что им надо подсунет.
поэтому конфиг он может содеражть часть инфы которая предназнчаена для ip а часть 
для wg поэтому неудивтельна вот такая команда напрмиер когда мы обновили конфиг
и хотим чтобы он был обновлен и внутри ядра


	# wg syncconf wg0 <(wg-quick strip wg0)

(тут я отдельно хочу выделить что вот эта хрень <(wg-quick strip wg0)  это не 
file\io redirect это нечто совершенно другое это тот самый долбаный process substitution
о нем можно прочитать портянку в bash.txt ищи по фразе "process substitution")

wg-quick strip wg0 дает то что  wg-quick ищет конфиг с именем /etc/default/wg0.conf
далее он его читает и выкидывает из него все что не отночится к конфугирования модуля ядра
и передает это уже предается на вход в wg утилиту.

тоесть еще раз какая система. нам нужно вначале создать в линуксе интерфейс типа wireguard
это делается через утилиту ip.

далее нужно ядру передать конфиг со списком клиентов. это делается через конфиг файл
и утилиту wg

но можно эти два процесса соединить в один. 
можно написать конфиг который влключает в себя как настройки предназнчаченные для утилиты ip
так и настройки преданзчнаыенные для утилиты wg и потом все это вместе запустить через 
утилиту wg-quick, она прочитает конфиг. выееберет оттуда все то что предназанчаено для ip
и скормить ей. потом выберет все то что преначено для wg-quick и скормит ей. 

если у нас интрейс уже создан но мы изменили конфиг клиентов то его передать в ядро
можно двумя путями. если когфиг содержит настроки только относящиеся к ядру то 

	# wg syncconf wg0 < /etc/default/wg0.conf

а если в нем есть постороние строчки то их нужно оттуда вычленить через

	# wg syncconf wg0 <(wg-quick strip wg0)

(тут я отдельно хочу выделить что вот эта хрень <(wg-quick strip wg0)  это не 
file\io redirect это нечто совершенно другое это тот самый долбаный process substitution
о нем можно прочитать портянку в bash.txt ищи по фразе "process substitution")



ксатти вот можно убедиться что wg0 имеет тип wireguard

$ ip -c -d l  sh wg0
76: wg0: <POINTOPOINT,NOARP,UP,LOWER_UP> mtu 1420 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/none  promiscuity 0 
    wireguard addrgenmode none numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 
     /\
     ||




| wireguard
| как добавить клиента

поехали на практкие

для того чтобы мы могли добавить клиента то нужно
сгенерировать для клиента:
	приватный ключ
	публичный ключ
	preshared key

прешаред кей будет хранится на сервере и клиенте. 
приватный ключ будет хранится на клиенте. 
публичный ключ будет хранится и на клиенте и на сервере

генерацию этих хреней можно делать хоть на сервере хоть на клиенте

генерируем прешаред кей
	$ umask 077; wg genpsk
    VE+QfnKXbVuoI9k7ShCiFmwPfruvd1PR/dUFCPb2uVg=       <==== занчение для примера

как видим на экране прешаред кей выводиться в base64 кодировке
чтобы посмотреть чему он равен в виде исходных байтов то 

	$ echo 'VE+QfnKXbVuoI9k7ShCiFmwPfruvd1PR/dUFCPb2uVg=' | base64 -d | od -t x1
	54 4f 90 7e 72 97 6d 5b a8 23 d9 3b 4a 10 a2 16
	6c 0f 7e bb af 77 53 d1 fd d5 05 08 f6 f6 b9 58

тоесть здесь четко видно что дейтсивтелно прешаред кей это 32 байта или 256 бит


гененрируем приватный и публичный ключ 

	$ umask 077; wg genkey | tee private.key | wg pubkey > public.key

 	$ ls -1al *
	-rw------- 1 vasya vasya 45 июн  3 16:19 private.key
	-rw------- 1 vasya vasya 45 июн  3 16:19 public.key

пусть private.key = 2222222222222222222222222=
пусть public.key  = 1111111111111111111111111=
пусть прешаред кей = 5555555555555555555555555

теперь можно составит конфиг на клиенте
$ cat  ~/wireguard/wg0.conf 
[Interface]
PrivateKey = 2222222222222222222222222=         # приватный ключ эттого компа 
Address = 10.66.66.5/32                         # VPN LAN этого компа
DNS = 1.1.1.1

[Peer]
PublicKey = 3333333333333333333333333H0=        # публиый ключ удаленного VPN сервера
PresharedKey = 55555555555555555555555555       # прешаред кей 
Endpoint = 14.14.14.14:51820                    # WAN IP удаленного VPN сервера
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25






на удаленном сервере 
добавляем в конфиг
### newClient
[Peer]
PublicKey = 111111111111111111111111111111=     # публичный ключ удаленного клиента
PresharedKey = 5555555555555555555555555555=
AllowedIPs = 10.66.66.5/32,fd42:42:42::5/128  # VPN LAN такой же как в конфиге клиента

ОБРАЩАЮ ВНИМАНИЕ что в конфиге на сервере для этого клиента в строке 
PublicKey нужно вставить паблик кей клиента! а не сервера!


после того как добавили в конфиг на сервере
то на сервере надо выполнить либо

	(сервер)# systemctl reload wg-quick@wg0.service

либо можно сделать вручную то как написано в файле 
# cat /lib/systemd/system/wg-quick@.service
...
ExecReload=/bin/bash -c 'exec /usr/bin/wg syncconf %i <(exec /usr/bin/wg-quick strip %i)'

тоесть
	(сервер)# wg syncconf wg0 <(wg-quick strip wg0)

(тут я отдельно хочу выделить что вот эта хрень <(wg-quick strip wg0)  это не 
file\io redirect это нечто совершенно другое это тот самый долбаный process substitution
о нем можно прочитать портянку в bash.txt ищи по фразе "process substitution")


теперь на сервере можно проверить что новый клиент добавился в конфиг

	(сервер)$ wg show
	...
	peer: 1111111111111111111111111111111111111111=
    preshared key: (hidden)
    allowed ips: 10.66.66.3/32,

тость появится строчка  с публичныым ключом нашего клиента.
при том что наш клиент еще не подключался


теперь идем на клиент
берем наш конфиг клиенсткий

$ cat  ~/wireguard/wg0.conf 
[Interface]
PrivateKey = 2222222222222222222222222=         # приватный ключ эттого компа 
Address = 10.66.66.5/32                         # VPN LAN этого компа
DNS = 1.1.1.1

[Peer]
PublicKey = 3333333333333333333333333H0=        # публиый ключ удаленного VPN сервера
PresharedKey = 55555555555555555555555555       # прешаред кей 
Endpoint = 14.14.14.14:51820                    # WAN IP удаленного VPN сервера
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25


и если клиент это телефон то надо этот конфиг превратить в QR код
либо вот так

	$ qrencode -t ASCIIi < ~/wireguard/wg0.conf

либо вот так

	$ qrencode -t ansiutf8  <  ~/wireguard/wg0.conf

ВНИМАНИЕ программа qrencode тупая. и ей нужно скормить файл именно через галочку "<"
иначе этот дебил не понимает.
фишка флагов 
	-t ASCIIi
	-t ansiutf8
в том что qr код будет напечатан прям в терминале. тоесть в текстовом виде!
ненужен никакой графический режим! для qr кода самое главное чтобы были темные участки
и светлые и все! очень удобно!

теперь на теелефоне можно сфоткать этот qr код и "впитать" конфиг. готоово.

далее включаем впн на телефоне. идем на сервер 
и смотрим пошла ли статистика

	(сервер)$ wg show
  peer: 11111111111111111111111111111111111=
  latest handshake: 1 minute, 38 seconds ago
  transfer: 1.33 MiB received, 73.43 MiB sent

сеанс окончен. все окей.

в целом на теелефоне там где впн добавляется там можно выбрать справа вверху в трех точках
чтобы засосать конфиг не через QR код а вручную вбивая параметры. (это на случай если 
с qr кодом траблы).


| wireguard
| wg-quick


когда мы его азпускаем то он нам прям на экране покзывает
какие команды wg-quick заупскает. еще раз доазказывая что wg-quick это чтото
типа фронтенд скрипта

  $ wg-quick up  ~/wireguard/wg0.conf
[#] ip link add wg0 type wireguard
[#] wg setconf wg0 /dev/fd/63
[#] ip -4 address add 10.66.66.5/32 dev wg0
[#] ip link set mtu 1420 up dev wg0
[#] resolvconf -a tun.wg0 -m 0 -x
[#] wg set wg0 fwmark 51820
[#] ip -4 route add 0.0.0.0/0 dev wg0 table 51820
[#] ip -4 rule add not fwmark 51820 table 51820
[#] ip -4 rule add table main suppress_prefixlength 0
[#] sysctl -q net.ipv4.conf.all.src_valid_mark=1
[#] iptables-restore -n

надо эти команды изучить понять че они делают


| wireguard nmcli
| nmcli
| Network Manager

как имея конфиг wiregueard его импртировать в Network manager

	$ nmcli conn import type wireguard file ~/wireguard/wg0.conf

только это работает начиная с нетворк манаджер какйто версии. 
на убунту18 это не работает. а на арч это работает

в каких то версиях нужен был плагин а как пишут в инете с какйо то вресии нетворк
манагер поддерживает импорт конфига от вайргард уже без всяких плагинов а просто так.

