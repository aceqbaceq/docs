]$ LC_NUMERIC=de_DE.UTF-8  printf '%f\n' 1233.14
bash: warning: setlocale: LC_NUMERIC: cannot change locale (de_DE.UTF-8)
1233.140000
[vasya@ thinkpad ]$ env LC_NUMERIC=de_DE.UTF-8  printf '%f\n' 1233.14
1233,140000
[vasya@ thinkpad ]$ env LC_NUMERIC=C.UTF-8  printf '%f\n' 1233.14
1233.140000
[vasya@ thinkpad ]$ env LC_NUMERIC=de_DE.UTF-8  printf '%f\n' 1233.14
1233,140000
[vasya@ thinkpad ]$ env LC_NUMERIC=en_US.UTF-8  printf '%f\n' 1233.14
1233.140000
[vasya@ thinkpad ]$ env LC_NUMERIC=ru_RU.UTF-8  printf '%f\n' 1233.14
1233,140000


только чрез env можно смнеить локале! охеренеть!

как ралотает поиск по path?
а нкиак . ядро начнатен туппо поэттим путям запускать open()
и пербиарем пока код врвзарата не стнеент 0 !!

[pid 87935] execve("/usr/local/sbin/sleep", ["sleep", "120"], 0x7ffdb855fd60 /* 49 vars */) = -1 ENOENT (No such file or directory)
[pid 87935] execve("/usr/local/bin/sleep", ["sleep", "120"], 0x7ffdb855fd60 /* 49 vars */) = -1 ENOENT (No such file or directory)
[pid 87935] execve("/usr/sbin/sleep", ["sleep", "120"], 0x7ffdb855fd60 /* 49 vars */) = -1 ENOENT (No such file or directory)
[pid 87935] execve("/usr/bin/sleep", ["sleep", "120"], 0x7ffdb855fd60 /* 49 vars */) = 0
[

==
програма при запумке тербует внешние библротеки.
и это защито в бинарнике ( в эльфе)

возмьмем пдля примера баш
$ readelf -d $(which bash) | grep lib
 0x0000000000000001 (NEEDED)             Shared library: [libtinfo.so.6]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]


а  вот как пофакту!
$ cat /proc/$$/maps | awk '{print $6}' | grep "/usr/lib" | sort | uniq
/usr/lib/locale/C.utf8/LC_ADDRESS
/usr/lib/locale/C.utf8/LC_COLLATE
/usr/lib/locale/C.utf8/LC_CTYPE
/usr/lib/locale/C.utf8/LC_IDENTIFICATION
/usr/lib/locale/C.utf8/LC_MEASUREMENT
/usr/lib/locale/C.utf8/LC_MESSAGES/SYS_LC_MESSAGES
/usr/lib/locale/C.utf8/LC_MONETARY
/usr/lib/locale/C.utf8/LC_NAME
/usr/lib/locale/C.utf8/LC_NUMERIC
/usr/lib/locale/C.utf8/LC_PAPER
/usr/lib/locale/C.utf8/LC_TELEPHONE
/usr/lib/locale/C.utf8/LC_TIME
/usr/lib/locale/locale-archive
/usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
/usr/lib/x86_64-linux-gnu/libc.so.6
/usr/lib/x86_64-linux-gnu/libtinfo.so.6.3

тут немного непонятно. почему в элтфе одно а по факту другое
но ясно одно - без этих балилблиотект программа стартанутт не сможет!

==

locale vs localectl status ???? отличаются их покзаания?

$ locale
LANG=C.UTF-8
LANGUAGE=
LC_CTYPE="C.UTF-8"
LC_NUMERIC=C.UTF-8
LC_TIME=C.UTF-8
LC_COLLATE="C.UTF-8"
LC_MONETARY=C.UTF-8
LC_MESSAGES="C.UTF-8"
LC_PAPER=C.UTF-8
LC_NAME=C.UTF-8
LC_ADDRESS=C.UTF-8
LC_TELEPHONE=C.UTF-8
LC_MEASUREMENT=C.UTF-8
LC_IDENTIFICATION=C.UTF-8
LC_ALL=
[vasya@ thinkpad ]$ 
[vasya@ thinkpad ]$ 
[vasya@ thinkpad ]$ localectl status
   System Locale: LANG=en_US.UTF-8
                  LC_NUMERIC=ky_KG
                  LC_TIME=ky_KG
                  LC_MONETARY=ky_KG
                  LC_PAPER=ky_KG
                  LC_NAME=ky_KG
                  LC_ADDRESS=ky_KG
                  LC_TELEPHONE=ky_KG
                  LC_MEASUREMENT=ky_KG
                  LC_IDENTIFICATION=ky_KG
       VC Keymap: us
      X11 Layout: us
       X11 Model: pc105+inet
     X11 Options: terminate:ctrl_alt_bksp
[vasya@ thinkpad ]$ 


==
оузенная вещь что содержиимое locale по факту 
можно посмтреть нетолько всмотрря в /usrs/sharee/i18

а еще из через команду

причем можно посмтрет ьввобще полный пакет

$ locale -k LC_TIME
abday="Sun;Mon;Tue;Wed;Thu;Fri;Sat"
day="Sunday;Monday;Tuesday;Wednesday;Thursday;Friday;Saturday"
abmon="Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec"
mon="January;February;March;April;May;June;July;August;September;October;November;December"
am_pm="AM;PM"
d_t_fmt="%a %b %e %H:%M:%S %Y"
d_fmt="%m/%d/%y"
t_fmt="%H:%M:%S"
t_fmt_ampm="%I:%M:%S %p"
era=
era_year=""
era_d_fmt=""
alt_digits=
era_d_t_fmt=""
era_t_fmt=""
time-era-num-entries=0
time-era-entries="S"
week-ndays=7
week-1stday=19971130
week-1stweek=4
first_weekday=1
first_workday=2
cal_direction=1
timezone=""
date_fmt="%a %b %e %H:%M:%S %Z %Y"
time-codeset="UTF-8"
alt_mon="January;February;March;April;May;June;July;August;September;October;November;December"
ab_alt_mon="Jan;Feb;Mar;Apr;May;Jun;Jul;Aug;Sep;Oct;Nov;Dec"


а можноотдебную хрень
$ locale -k d_t_fmt
d_t_fmt="%a %b %e %H:%M:%S %Y"
[vasya@ thinkpad ]$ 


ОХРЕНЕНЕНЕНЕРТТТЬТ!Т!Т!

       $ locale -k date_fmt
       date_fmt="%a %b %e %H:%M:%S %Z %Y"

       $ locale -ck date_fmt
       LC_TIME
       date_fmt="%a %b %e %H:%M:%S %Z %Y"

       $ locale LC_TELEPHONE
       +%c (%a) %l
       (%a) %l
       11
       1
       UTF-8


===
loaale vs localectl status покывают разное!
а как же уанть 100% наежно как же для тещкушего процесса 
узнать эту насфтрокуц?!?!!?
а вот как!!


$ cat /proc/self/environ | strings | grep LC_
LC_ADDRESS=C.UTF-8
LC_NAME=C.UTF-8
LC_MONETARY=C.UTF-8
LC_PAPER=C.UTF-8
LC_IDENTIFICATION=C.UTF-8
LC_TELEPHONE=C.UTF-8
LC_MEASUREMENT=C.UTF-8
LC_TIME=C.UTF-8
LC_NUMERIC=C.UTF-8

===
оказывается locale это всего навсего набор рееконмдаци для программы!
это рекомандация! она пе редается программе через перменные кокружжения 
вида 
	LC_*
предаетмч оно через третий памретре 
	execve(...., ....., env)
и поорграмма может использовать эти перменные а аможет неет.
и они эти перменные покаывают программе ЧТО от неее ожидают на выходе 
программы когда она печаатает на экран!
и оно покзывает в каком виде программе будут скармоиваться данные!
напрмер 

возьмем числа с плвавающей точкой

$ cat /proc/self/environ |strings| grep LC_NUMERIC
LC_NUMERIC=C.UTF-8

смотррим какие насйтроки есть в этйо локаи про числа с плавающей
точкой



$ locale -k LC_NUMERIC
decimal_point="."
thousands_sep=""
grouping=-1
numeric-decimal-point-wc=46
numeric-thousands-sep-wc=0
numeric-codeset="UTF-8"

==
непонимаю
man locale
>> To display the current character  set  for  the  locale,  use  locale  -c
              charmap.

нихрена нерабоатет
===
непонимаю.
естьь локали

/usr/share/i18n/locales

напрмиер там есть en_ZW


в нем условно написано что для числе с точки нужно юзать 

есть файл в нем нахожу

$ cat /usr/share/i18n/SUPPORTED | grep en | grep ZW
en_ZW.UTF-8 UTF-8
en_ZW ISO-8859-1


есть непонятная папка charset тамже
$ ls -1 /usr/share/i18n/charmaps/ | grep -Ei "ISO-8859-1|UTF-8"
ISO-8859-1.gz
UTF-8.gz


$ cat /etc/locale.gen | grep en | grep ZW
# en_ZW ISO-8859-1
# en_ZW.UTF-8 UTF-8



в locale нужно вот тчо вводить как аругмент
$ locale  
LANG=C.UTF-8
LANGUAGE=
LC_CTYPE="C.UTF-8"
LC_NUMERIC=C.UTF-8
LC_TIME=C.UTF-8
LC_COLLATE="C.UTF-8"
LC_MONETARY=C.UTF-8
LC_MESSAGES="C.UTF-8"
LC_PAPER=C.UTF-8
LC_NAME=C.UTF-8
LC_ADDRESS=C.UTF-8
LC_TELEPHONE=C.UTF-8
LC_MEASUREMENT=C.UTF-8
LC_IDENTIFICATION=C.UTF-8
LC_ALL=

$ locale  LC_NUMERIC  <=== вот какйо аргмумент принимает канмала locale
.

-1
46
0
UTF-8

что это за хуйня? 
а вот что

$ locale  LC_NUMERIC -c
LC_NUMERIC
.

-1
46
0
UTF-8

$ locale  LC_NUMERIC -c -k
LC_NUMERIC
decimal_point="."
thousands_sep=""
grouping=-1
numeric-decimal-point-wc=46
numeric-thousands-sep-wc=0
numeric-codeset="UTF-8"

помне команда locale апокзывает содержимое файла локали
из папки
cat /usr/share/i18n/locales/en_ZW
вот ив се что она делате. нахуя она при этом заикквается
про charмапы я нихуя не понимаю. реаьно!

запустил locale-gen через стерей
там есть  куски
["localedef", "-i", "en_US", "-c", "-f", "UTF-8", "-A", "/usr/share/locale/locale.alias", "en_US.UTF-8"], 0x565286f90a20 /* 31 vars */) = 0

-i", "en_US" = >
$ ls -1al /usr/share/i18n/locales/en_US
-rw-r--r-- 1 root root 3629 Jul  7  2022 /usr/share/i18n/locales/en_US

 "-f", "UTF-8" = >
$  ls -1al /usr/share/i18n/charmaps/UTF-8.gz 
-rw-r--r-- 1 root root 443053 Jul  7  2022 /usr/share/i18n/charmaps/UTF-8.gz

"-A", "/usr/share/locale/locale.alias"  = >
"/usr/share/locale/locale.alias

en_US.UTF-8 ==> видимо навание "локали " коорое будет присовено.
фишка в том что коагды мы "генерируем"  локаль то мы не толко локаль
генериурем мы еше чттото делаем с ЧАРМПАПОМ!

вот содержрмое файла чармапа

$ zcat  /usr/share/i18n/charmaps/UTF-8.gz  | head -n 20
...
...
CHARMAP
<U0000>     /x00         NULL
<U0001>     /x01         START OF HEADING
<U0002>     /x02         START OF TEXT
<U0003>     /x03         END OF TEXT
<U0004>     /x04         END OF TRANSMISSION
<U0005>     /x05         ENQUIRY
<U0006>     /x06         ACKNOWLEDGE
<U0007>     /x07         BELL
<U0008>     /x08         BACKSPACE
<U0009>     /x09         CHARACTER TABULATION
<U000A>     /x0a         LINE FEED (LF)

очеивдно слева стоит unicode code point. в центар стоит его 
байтовое представление. а справа обьясннее что это за символ. я вот 
нихуя не понимаю как комп испоьзует эту правую конлонку. или в шрифтах
как раз стоит эта правая колонка и соотвствубщий ему глиф ?!?!!?

и еще - при чем тут локаль и чармап? это же разные хуевины!!

также непонятно как идет печать на экран. я шлю в xterm байты в его
stdin и он что ? он лезет в файл с чармапом чтобы найти строку и найти 
правую конлонку и чтобы потом найти в файле шрфитов букву?!?!?!?
или это ядро делает или как и что!?!? или xterm через сокет перслыает
байт в xorg сервер а он уже это делает ?!?! 

походу locale-gen запимывает  эту самую новую локаль в файл
  /usr/lib/locale/locale-archive и больше никуда
и записываает не через write() а через mmap()

вот что в итоге можно нацти в этом файле 
$ strings /usr/lib/locale/locale-archive  | grep ru_RU -B10 -A10
de_DE.utf8
en_GB
en_GB.iso88591
en_US.utf8
ru_RU.utf8

я посмотрел что там внутри
я пришел к выводу что там точно есть содержимое файла локали
/usr/share/i18n/locales/en_ZW

оно туда записано. 
на счет засунут ли туда чаармап файл... вороде бы нет. 


]$ locale -a
C
C.utf8
POSIX
de_DE.utf8
en_GB
en_GB.iso88591
en_US.utf8
ru_RU.utf8

я не понимаю нахуя при "генерации " локали а по факту копировния тексоговго
файла в бинарный файл так вот нахуя при этом нужен charmap файл.
цепочку невижу

==\

текущая локаль у процесса
$ cat /proc/self/environ | strings | grep LC
LC_ADDRESS=C.UTF-8
LC_NAME=C.UTF-8
LC_MONETARY=C.UTF-8
LC_PAPER=C.UTF-8
LC_IDENTIFICATION=C.UTF-8
LC_TELEPHONE=C.UTF-8
LC_MEASUREMENT=C.UTF-8
LC_TIME=C.UTF-8
LC_NUMERIC=C.UTF-8


$ env LC_NUMERIC=C.UTF-8  locale -c -k LC_NUMERIC
LC_NUMERIC
decimal_point="."  <=====
thousands_sep=""
grouping=-1
numeric-decimal-point-wc=46
numeric-thousands-sep-wc=0
numeric-codeset="UTF-8" <=====

видм что в этой локали числа дробные отделлются точкой

$ env env LC_NUMERIC=C.UTF-8  printf "%f\n" "1.234"
1.234000
$ env env LC_NUMERIC=C.UTF-8  printf "%f\n" "1,234"
printf: ‘1,234’: value not completely converted
1.000000

и вот видно что принтф это использует и шлет нас нахер
когда мы ему подсвавем число с запятой


$ env LC_NUMERIC=ru_RU.UTF-8  locale -c -k LC_NUMERIC
LC_NUMERIC
decimal_point=","
thousands_sep=" "
grouping=3;3
numeric-decimal-point-wc=44
numeric-thousands-sep-wc=8239
numeric-codeset="UTF-8"

$ env LC_NUMERIC=ru_RU.UTF-8  printf "%f\n" "1,234"
1,234000
$ env LC_NUMERIC=ru_RU.UTF-8  printf "%f\n" "1.234"
1,234000

а почему то тут нихрена не сралотало. странно!

$ env LC_NUMERIC=en_GB.iso88591   locale -c -k LC_NUMERIC
LC_NUMERIC
decimal_point="."
thousands_sep=","
grouping=3;3
numeric-decimal-point-wc=46
numeric-thousands-sep-wc=44
numeric-codeset="ISO-8859-1"

$ env LC_NUMERIC=en_GB.iso88591  printf "%f\n" '1.234'
1.234000
[vasya@ thinkpad ]$ env LC_NUMERIC=en_GB.iso88591  printf "%f\n" '1,234'
printf: ‘1,234’: value not completely converted
1.000000

а тут опять сработало!


зная этухрень я смог запустьи свою прогу
	$ env LC_NUMERIC=ru_RU.utf8 ./r_sr_za_1min.bash


я теперь как работает "задание"\измненеие локали для процесса!
оноработает так что при запуске execve оно меняет третий параметр
и в нем убирает старый LC_NUMERIC а вствляет нужный !!!

$ strace -f -s 80 -a 50 -e execve env LC_NUMERIC=ru_RU.utf8 sleep 120
execve("/usr/bin/env", ["env", "LC_NUMERIC=ru_RU.utf8", "sleep", "120"], 0x7ffd18b33920 /* 45 vars */) = 0
execve("/usr/bin/sleep", ["sleep", "120"], 0x7ffd50dd4c40 /* 45 vars */) = 0

ксаити подчреркну что чтобы стрйс он показал третий аргумент в exedve его надо 
запускт с ключами -s N -v

вот у нас запускется вначале /usr/bin/env но это нам ниентсено
а потом он уже запускает /usr/bin/sleep
и щая я покажу что в этом execve указано в массиве перменных 
в  тертеьм ругменте



execve("/usr/bin/sleep", ["sleep", "120"], ["SHELL=/bin/bash", "QT_ACCESSIBILITY=1", ...
..."LC_NUMERIC=ru_RU.utf8", "_])

        /|||||||||||||\
        |||||||||||||||
          вот оно !

вот такое работает изменеие локале на лоу левел уровне!
кстати env это билтин баща это внешний бианарник
	/usr/bin/env

так окзваетс я кстати что можно и без env!!!!!
без внешенго ьбинарника можно это решить . вот как
чисто средствами баша!
	$ LC_NUMERIC=ru_RU.utf8 sleep 150

$ cat /proc/209635/environ  | strings | grep LC_
LC_NUMERIC=ru_RU.utf8   <===== ****
LC_ADDRESS=C.UTF-8
LC_NAME=C.UTF-8
LC_MONETARY=C.UTF-8
LC_PAPER=C.UTF-8
LC_IDENTIFICATION=C.UTF-8
LC_TELEPHONE=C.UTF-8
LC_MEASUREMENT=C.UTF-8
LC_TIME=C.UTF-8


ксати strings это бинаркник (тоесть небаш) котоырй позвояет 
чиатть файлы баинаные и он выводит на stdout тлоко печатные символы!
так что очень удоблно смотреть что там есть в этом плане.

я нконкц ууидел практ пользу от локале. 
идем в папку с мануалами 

$ ls /usr/share/man/
ca  da  el  et  fr            fr.UTF-8  hr  id  ja  man1  man3  man5  man7  nb  pl  pt_BR  ru  sl  sv  uk  zh_CN
cs  de  es  fi  fr.ISO8859-1  gl        hu  it  ko  man2  man4  man6  man8  nl  pt  ro     sk  sr  tr  zh  zh_TW


здесь видно что мнула именются на разных языах так  а как их 
посмтеь ? а вот так! мы прогорамме man передаем через локакле 
какой "язык" в нашей системе

$ LC_MESSAGES="ru_RU.UTF-8" man man | head -10
...
...
  man  —  это пейджер справочных страниц системы. Каждый параметр страница, переданный man, обычно является названием программы, утилиты или функции.

вау! маны на русском !

а как на немецком?

	$  LC_MESSAGES="de_DE.UTF-8" man 1 acpi
    ...
    acpi  Liest  Informationen aus dem /proc-Dateisystem oder aus dem /sys-Dateisystem wie z.B. den Batteriestatus und die Temperatur aus und zeigt sie


а на испаснском?
]$ locale -a
C
C.utf8
POSIX
de_DE.utf8
en_GB
en_GB.iso88591
en_US.utf8
es_AR
es_AR.iso88591
ru_RU.utf8

		$ LC_MESSAGES=es_AR  man apropos
       Una  palabraclave  normalmente  es  una  expresión regular, como si (-r) fuera empleada, o quizá contenga comodines (-w), o coincida con la palabra
       clave exacta (-e).  Utilizando estas opciones, quizá sea necesario 

замечу что яказал более короткое имя локали. 
также я поробовал и вот что обнаружил. если в мане есть мана на какотом
языке то вот это метод он несраотае если у нас эта локаль не сгененррована!
поэтому приложение может говриь на ругом языке но надо чтобы локаль была
у нас сгеннирована. 





как работает tmux? он запршвает у ядра терминалы ptmx\pts/N
а потом зпусакает прцоесы и увызывает их stdout\stdin на себя 
на свой ptmx  и прокирует вс что они срут на себя а потом уже пернарпвлет 
от себя на экран. я так считаю.









===
чтобы больше понять про "локаль" нунжно проватт создать свою 
локаль.  тогде еще боле будет понятно.

"localedef", "-i", "en_US", "-c", "-f", "UTF-8", "-A", "/usr/share/locale/locale.alias", "en_US.UTF-8"], 0x565286f90a20 /* 31 vars */) = 0

localedef -f CP1252 -i de_DE /usr/lib/locale/de_DE.cp1252