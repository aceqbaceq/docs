| python

| основы

поговорим щас для начала как этот питон устроен. 
ибо это песня. без этого не понять как нам праивльно поставить ансибль.
эту главу надо прочитать перед тем как ставить ансибль

итак я хочу описать как ставить ансибль.

сначала может показаться что описание слишком длинное. но на самом деле
чтобы понять всю хуйню целиком рекомендую все таки все прочитать целиком

значит начну вот с чего. ансибль это всего навсего на 100% кучка сраных скриптов
на python.

так вот вначале нам нужно несклько разобраться как все устроено у такой помойки 
как питон.

вначале нам нужно поставить питон через пакетный менеджер. очень часто
питон уже устанолвен в системе по дефолту сразу.


  $ stat $(which python)
  File: /usr/bin/python -> python3

итак это симлинк

$ stat $(which /usr/bin/python3)
  File: /usr/bin/python3 -> python3.12

а он тоже симлинк

 $ stat $(which /usr/bin/python3.12)
  File: /usr/bin/python3.12

наконец обычный файл

  $ file /usr/bin/python3.12
  /usr/bin/python3.12: ELF 64-bit 

и он эльф. тоесть питон это эльф бинарник. окей питон интепретатор устанолвен.


итак есть бинаик питона. он может работаьт в косольном режиме. ровно также как работает 
бинарник баш. а можно написать текстовый скрипт. и на ненго натравить интепретатор.
точно ктакже как в баш файлы скриптов.


как войти в питоне в режиме консоли

  $ python
  >>>


далее как я понял изнутри питона с его точки зрения у нас есть неймспейсы. это такой уровень
изоляции обьектов. обьектами являются переенные и фнукции. какие еще есть обьекты хуй знает.
итак у нас есть разные неймспейсы. а внутри каждого нейспейса есть кучка пеерменыных и функций.

вопрос - как создать новый неймспейс в консоли.
ответ хуй знает. но можно создать новый неймсейс если мы создадим файл vasya.py
и внутри него напихаем переменных и функкций. далее идем в консоль и "импортируем" этот файл.
правда питон дебил. он не умеет импортировать нихуя если указать путь. нужно добавить 
путь в спец переменную. и только тогда можно импортировать файл 

создаю папку

  /home/noroot/temp/21

создаю в ней файл

  $ cat p1.py 
  #!/usr/bin/python3

  y = 10


далее в консоли делаю так

  >>> import sys
  >>> sys.path.append("/home/noroot/temp/21/")

теперь можно ипортиовать наш файл

  >>> import p1

при этом питон создась неймсппейс p1
как получить список всех неймспейсов у питона прям щас.
походу вот так

>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'p1', 'pip', 'pprint', 'sys', 'venv']


зато знаю как получить список всех обьектов сущеностей внутри неймспейса если 
мы знаем его имя

  >>> dir(p1)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'y']

как можно заметить в p1.py  я не создавал ничего кроме переменной "y"

откуда же в p1 нейспейсе взялась целая куча других обьектов. а их создал сам питон
интепретер когда проитал файл и создавал неймспеейс.

посмотрим какой тип у кажого обьекта. и что там внутри этих обьектов

>>> type(p1.__builtins__)
<class 'dict'>

это дикшонари. чтобы красиво напечаать дикшонари на экране нужно импортировать еще
одну хрень

>>> import pprint

тогда любой дикшонари можно красиво напечататьв вот так

>>> pprint.pprint (p1.__builtins__)
{'ArithmeticError': <class 'ArithmeticError'>,
 'AssertionError': <class 'AssertionError'>,
 'AttributeError': <class 'AttributeError'>,
...
...

хрень неинтресеная.
следущий обьект

>>> type(p1.__cached__)
<class 'str'>

>>> print (p1.__cached__)
/home/noroot/temp/21/__pycache__/p1.cpython-312.pyc

он показывает где лежит откомпилированный файл 


следущий оьект
>>> type(p1.__doc__)
<class 'NoneType'>

по идее в нем должно быть описание неймспейса

>>> print (p1.__doc__)
None

пусто. псмотрим как в других неймспейсах

>>> import venv
>>> print (venv.__doc__)

Virtual environment (venv) package for Python. Based on PEP 405.


>>> import pip
>>> print (pip.__doc__)
None


>>> type(p1.__file__)
<class 'str'>
>>> print (p1.__file__)
/home/noroot/temp/21/p1.py




>>> type(p1.__loader__)
<class '_frozen_importlib_external.SourceFileLoader'>
>>> print (p1.__loader__)
<_frozen_importlib_external.SourceFileLoader object at 0x76203cc7f530>


>>> type(p1.__name__)
<class 'str'>
>>> 
>>> print (p1.__name__)
p1


>>> type(p1.__package__)
<class 'str'>
>>> print (p1.__package__)



>>> type(p1.__spec__)
<class '_frozen_importlib.ModuleSpec'>
>>> 
>>> print (p1.__spec__)
ModuleSpec(name='p1', loader=<_frozen_importlib_external.SourceFileLoader object at 0x76203cc7f530>, origin='/home/noroot/temp/21/p1.py')



>>> type(p1.y)
<class 'int'>
>>> print (p1.y)
10


итак я посмотрел  на все обекты внутри неймсейса. в том числе и пеерменная "y"
она как ожидалось равна 10


так вот еще раз обрисую картину - директива "import" она импортирует обьекты из модуля. 
и потом создает новый неймспейс и сует туда эти обьекты.
теперь нам важно понять что такое модуль в питоне.

источником модуля может быть две хрени. либо либо. 
одним источником модуля может быть файл с диска. внутри файла питон скрипт.
это ровно то что я сделал выше. через файл p1.py

беререм любую папку на компе

  /home/noroot/temp/21/

внутри нее создаем файл *.py
внутрь файла накидываем питон сущностей - фкнкции, переменные.

чтобы питон нашел модуль основанный на файле нужно ему добавить в спец переменную путь К ПАПКЕ в которой лежит этот файл. тоесть нужно не путь к файлу указать а путь к папке в котором лежит
этот файл 

  >>> import sys
  >>> sys.path.append("/home/noroot/temp/21/")

(на конце 21 можно ставить слэш можно не ставить пофиг работает  и так и так)

и теперь можно импортиовать этот файл-модуль

  >>> import p1

питон будет исктаь файл p1 во всех своих пропсианных папка в том числе и в папке 

  /home/noroot/temp/21/

питон создаст неймспейс p1 и напихает в него все сущности из файл p1.py


так вот вторым источником для модуля при импорте может быть папка. и такой тип модуля называется - пакет. модуль-пакет.
хочу подчеркнуть что пакет это не отдельная сущность в питоне а это бекенд для модуля. 
тоесть нет такого в питоне что есть модули а есть пакеты. это хуйня.  пакет это бекенд для модуля. пакет является источником для модуля. носителем пакета явялется папка на диске . тоесть эти дебилы в народе они обычно говорят
я импортирую модуль. или я импортирую пакет. на самом деле это подразумевает то что 
когда говорят я импортировал модуль имеется ввиду что был импортиррован модуль с источником
файл. а если говорят импртирировал пакет это значит что импортировал модуль где источником была
папка. 

команда import всегда импортррует модуль. а его носителем может быть либо файл как в пре
дыдщум случае либо папка как в этом случае. когда папка то такой модуль называют пакет. хотя
более точно сказать модуль имеет тип пакет.

теперь разберем что это за модуль когда у него источник папка. 
значит сами питоновцы нихуя не понимают что такое пакет это отлично видно вот тут

  https://stackoverflow.com/questions/7948494/whats-the-difference-between-a-module-and-package-in-python



как создать модуль-пакет из папки. 
берем папку любую

  /home/noroot/temp/pip2

в ней создаем ПУСТОЙ файл 

    __init__.py 

название дебилоидное конечно

все мы создали модуль-пакет.

названием модуля будет папка pip2

чтобы модуль pip2 импортировать ВАЖНО указать путь не к pip2 как я это сделал вначале

    sys.path.append("/home/noroot/temp/pip2")

это огромандая ошибка !

нужно указать путь к папке на один уровень выше!

  sys.path.append("/home/noroot/temp/")


ну или более точно

  >>> import sys
  >>> sys.path.append("/home/noroot/temp/")

и теперь можно импортироват омдуль pip2

  >>> import pip2

тоесть когда мы пишем пиотону 
  
  >>> import vasya

то он берет все папки которые у него указаны в переменной где хранться пути к модулям
и ищет в каждой папке либо файл vasya.py либо ищет в каждой папке подпапку ./vasya и  в 
этой подпапке обязательно одолжен быть файл __init__.py

поэтому когда я указывать папку

  /home/noroot/temp/pip2

а потом писал

  import pip2

то он брал папку   /home/noroot/temp/pip2 и искал внутри нее либо файл pip2.py
либо подпапку /home/noroot/temp/pip2/pip2 внутри которой был бы файл __init__.py
понятно что ни того ни другого не было! вот какможно наебатся на пустом месте в этом
прекрасно питоне

теперь вопрос а что же за обьекты в итоге будут созданы в неймспейсе pip2 ?
ведь мой модуль pip2 нихрена не содержит !
ответ - только системные 

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__']


а теперь сделаем поинтереснее. 
создадим внутри pip2 папки два .py файла

../pip2
├── __init__.py
├── p1.py
├── p2.py

вот их контент

 $ cat p1.py 
  a = 1

 $ cat p2.py 
  b = 2

импортируем модуль pip2 снова. 
неужели ничего из этих .py файло наш питон не загрузит внутрь себя?

>>> import sys
>>> sys.path.append("/home/noroot/temp")
>>> 
>>> import pip2
>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__']

>>> from pip2 import *
>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__']

как видно нет - автоматом неимпортировалось нихрена!


если мы хотим импортировать обьекты из p1 то это надо сделать руками в явном виде воттак

>>> import pip2.p1

и тогда в неймспейсе pip2
появится обьект p1

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1']

где p1 имеет тип модуль

>>> type (pip2.p1)
<class 'module'>


>>> print(pip2.p1.a)
1

как видно сработало


щас я скажу то что все прояснит. когда мы пишем 

  >>> import pip2

то по факту питон грузит в себя ровно то что указано в  __init__.py
а так как там нихрена нет то он нихерна и не грузит. только создает нейммсейс pip2 
и там свои систенмые обьекты сует. 
так вот если мы хотим чтобы у нас при загрузке pip2 загрузились автоматом сущности из p1.py
и p2.py то это НАДО ПРОПИСАТЬ В __INIT__.PY  и все будет!


  $ cat __init__.py 
  from . import p1
  from . import p2



пробуем теперь импортиовать наш модуль-пакет

$ python
>>> import sys
>>> sys.path.append("/home/noroot/temp")

>>> import pip2

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1', 'p2']


вот видно что автоматом при импорте pip2 засосались обькты p1 и p2

  >>> print(pip2.p1.a)
    1

  >>> print(pip2.p2.b)
    2

таким образом при правильно настроенном __init__.py  и команде import pip2
нам ненужено руками испортирвать p1 и p2. они уже тоже импортррованы. 

теперь я добавлю функцию hello() в p1.py

  $ cat p1.py 
    a = 1

    def hello():
        print("hello")


заново импортирую pip2 модуль.
состав обьектов в неймспейсе тот же самый


>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1', 'p2']

а вот как  я запускаю эту фнуциию

  ...
  >>> import pip2
  >>> pip2.p1.hello()
  hello


при понимании модулей-пакетов мне помогли статьи
  https://www.freecodecamp.org/news/module-not-found-error-in-python-solved/
  https://martinxpn.medium.com/what-are-packages-in-python-and-what-is-the-role-of-init-py-files-82-100-days-of-python-325a992b2b13
  https://medium.com/@nydas/how-to-create-and-publish-your-own-python-package-8e4f3fd70506
  https://stackoverflow.com/questions/15746675/how-to-write-a-python-module-package
кстати вот родная статья от питон сайта тоже небесполезная но не супер
  https://docs.python.org/3/tutorial/modules.html


теперь я для себя ответил на вопрос - а что же импортируется в питон при импорте модуля-пакета
тоесть модуля-папки я так его бы назвал - ответ все то что прописано в __init__.py если там
нихрена не прописано то неимпортруется нихерна

возьмем для примера модуль venv
это модуль-пакет. у него бекенд папка. 

>>> import venv

посмтрим какие обьекты лежат в его нейсмпейсе
>>> dir(venv)
['CORE_VENV_DEPS', 'EnvBuilder', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'create', 'logger', 'logging', 'main', 'os', 'shutil', 'subprocess', 'sys', 'sysconfig', 'types']

посмотрим из какого файла он создан
>>> print(venv.__file__)
/usr/lib/python3.12/venv/__init__.py

ага четко видно что это модуль-пакет\модуль-папка

среди обьектов неймсейса кроме системных __*__ мы видим вот такие

CORE_VENV_DEPS
EnvBuilder
create
logger 
logging 
main
os 
shutil 
subprocess 
sys
sysconfig
types

эти обьекты должны както быть импортированы в тексте __init__.py через import

проверим

  $ cd /usr/lib/python3.12/venv/
  $ cat __init__.py | grep import
import logging
import os
import shutil
import subprocess
import sys
import sysconfig
import types
import _winapi
import argparse

ну и как бы видно что есть соовтесвтие. 
тоесть обьекты которые выше образовались при импорте модуля pip потому что они были в явной
форме импортированы в теле __init__.py через import директиву. только поэтому

а вотт ееще в пакете есть файл __main__.py зачем он нужен незнаю и щас разбираться не бууду.

для себя я так скажу - в чем прикол модуля-пакета. в том что импортируя только его тоесть
через одну строку

  import pip

мы фактически импортируем сразу адовое количество модулей-файлов. а это реально удобно. 
тоесть предаставиим у нас есть папка VASYA в ней 10 модулей-файлов

  p1.py
  ...
  p10.py

чтобы их импортировать это надо писать 10 раз

  import p1
  import p2
  ...
  import p10

а так мы создаем в папке файл __init__.py 
с контентом
    import p1
    import p2
    ..
    import p10

и тогда в нашей основной программе мы пишем одну строку

  import VASYA

и все. готово. все p1-p10 у нас будут импортированы автоматом
вот в чем прикол модуля-пакета. и также стало понятно какие модули файлы будут импотрированы
при импорте модуля-пакета.


далее из мелочи
как узнать какая версия питона щас стоит на компе

>>> import sys
>>> sys.version
'3.12.6 (main, Sep  8 2024, 13:18:56) [GCC 14.2.1 20240805]'


ксатти удобняшка. если у нас есть глобальная перменная в файле-модуле внутри модуля-папки
то ее можно напечатать без применения команды print()


../pip2
├── __init__.py
├── p1.py
├── p2.py

вот имеем модуль-папку pip2
внутри нее файл-модуль p1.py с контентом

 $ cat p1.py 
  a = 1

импортруем модуль

  import pip2

и печатаем перменную "a" просто вот так

  >>> pip2.p1.a
  1

тоест нет необходимости делать вот так
  >>> print (pip2.p1.a)
      1

конечно это срботает только если в __init__.py у нас вот так

  ఻  $ cat __init__.py 
    from . import p1
    from . import p2

кстати вот  у нас нееймспейс модуля pip2

>>> dir(pip2)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__path__', '__spec__', 'p1', 'p2']

а так как p1 по совему типу это тоже  модуль

>>> type(pip2.p1)
<class 'module'>

то  чреез dir() можно постмреть его конентент
>>> dir(pip2.p1)
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'hello']

и вот нам прекрасно видна его перменная "a"


так вот когда мы делаем

>>> sys.version
'3.12.6 (main, Sep  8 2024, 13:18:56) [GCC 14.2.1 20240805]'

то это экивлатентно 

>>> print(sys.version)

и мы смотрим чему равна пременная version внутри файл-модуля sys
правда едиснверннное что у модуля sys носетелем явялется не питон скрипт файл 
а elf бинарник самого интпретатора питона. 
потому что 

  
>>> dir(sys)
['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__', '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__', '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__' ...


не имеет __file__ обьекта.

также об этом пишет 

  >>> help(sys)
  ...

  FILE
      (built-in)

замечу что dir() надо юзать обязательо БЕЗ кавычек. а вот help() обаязательно  с кавыяками!


найдем сам бинарник питона

насколько я понимаю этот модуль встроен в сам бинарник питона
 $ which python3
/usr/bin/python3
 $ file $(which python3)
/usr/bin/python3: symbolic link to python3.12

 $ stat $(which python3)
  File: /usr/bin/python3 -> python3.12
 $ file $(which python3.12)
/usr/bin/python3.12: ELF 64-bit 



теперь когда разобрались с модулями-файлами и модулями-пакетами питтона
надо выяснить у нас модуль venv установлен или нет
далее если мы вводим dir() без имени то он покзывает список всех неймсейсов щас имеющися
в питон интерптретатторе

>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']


псмотрим какой тип у неймспейса  __builtins__
  >>> type(__builtins__)
  <class 'module'>

ага это модуль. посмотрим он встроенный в бинарник питона или он загружается через 
питон-скрипт файл или папку

  >>> help(__builtins__)
    ...
    ....
    FILE
      (built-in)

тоесть этот модуль содержится в питон бинарнике. 
посмотрмим что за обьекты внутри этого модуля


>>> dir(__builtins__)
[.... , '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', ..., 'hash', 'help', 'hex', 'id', ...'zip']

посмотрим какйо тип  у обьектов help , id , hash

>>> type(__builtins__.help)
<class '_sitebuiltins._Helper'>
>>> type(__builtins__.id)
<class 'builtin_function_or_method'>
>>> type(__builtins__.hash)
<class 'builtin_function_or_method'>


можно посмтреть справку по help, id, hash
ну а применяем вот так

>>> a=1

>>> id(a)
125298215205576

>>> hash(a)
1
>>> hash(123)
123

>>> hash('12334')
-5531871577535261644


тоесть кода мы вошли в консоль. то все функции\команды которые мы в ней юзаем это все
обьекты из неймспейса  __builtins__ 
и походу если это обьект оттуда то название модуля\неймспейса вводит необязательно

  >>> id(a)
  125298215205576 
  >>> __builtins__.id(a)
  125298215205576

видим что да . это одно и тоже.

прикол.

ксатти когда я создал "a" в консоли то это стало вот так выглядть с точки зрения
неймспейсов

>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a']

далее я псомтрел модуль venv не входит  в список обьектов в неймсейсе __builtins__
а его нужно загружать 

>>> import venv
>>> 
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'venv']

>>> type(venv)
<class 'module'>


вот у нас откуда этот модуль грузится

>>> venv.__file__
'/usr/lib/python3.12/venv/__init__.py'

тоесть это модуль-пакет



а теперь я хочу выяснить какой pacman пакет установил этот файл 

  $ pacman -F usr/lib/python3.12/venv/__init__.py
    usr/lib/python3.12/venv/__init__.py is owned by core/python 3.12.5-1

а! понятно

изнутри питона список установленных  модулей можно вот так посмотреь
  
  >>> help('modules')
  ...
  venv

нам важно чтобы этот модуль был устанолвен в питоне.
посмотрим от него справку. к сожалению из консоли справка гавно

 >>> help(venv)

а вот в таком режиме

 $ pythom -m venv -h
толку больше

usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps]
            ENV_DIR [ENV_DIR ...]

по факту нам нужен тлоько один ключ это ENV_DIR он укаывает в какую папку надо поставить
все хрени чтобы это была как бы автономаная инсталляция питон интерперетатора.
это суперважная штука потому что так часто бывает что мы ставим питон модуль-пакет а он требует
наличия других модулей-пакетов привем опредеелнных версий. а это может нахрен сломать всю эту
питона шарманку. потому что часто разные модули треюуют в системе наличчие разных версий одного
и того же модуля. например  я ставлю модуль-пакет А  и требует наличия в системе модуль-Б версии 1.1
и потом ставлю модуль-пакет C а он трбует налиичия в системе модуль-Б версии 1.2 и полчается
конфликт. поэтому такая дебиьная сситема. -- если я ставлю в систему какойто питон модуль не
через pacman менедже а руками или через pip менеджер ( о нем дальше) то нужно делать 
автномную инсталляицю питон интрпетатора в одельную папку. и там уже ставить все что заблаго
расудится. это никак не отарзится на питоне общесистмном.

делаем автоному инсталляицю вот так

  $ python -m venv ~/.venv/ansible1

запустить интпререатор питона в из этой папки можно вот так

  $ source  ~/.venv/ansible2/bin/activate
  (ansible2)$ 

  (ansible2)$  python
  >>> hepl ('modules')
  ...
  pip


чем нам важен этот модуль. тем что он лезет в центарльный репозиторий питона и оттуда 
устанавливает модуль котоырй мы скажем. так вот ансибль это тоже модуль-пакет питона!
и ставим мы его вот так

  (ansible2)$ pip install ansible

а лучше вот так

  (ansible2)$  pythom -m pip install ansible

проверяем

   $ python -m pip list | grep ansible
  ansible      10.5.0
  ansible-core 2.17.5

правда потом почему то вот так хреново срабатывает

 $ python -m ansible "--version"
usage: python -m ansible {adhoc,config,connection,console,doc,galaxy,inventory,playbook,pull,vault,test}
python -m ansible: error: the following arguments are required: entry_point

только вот так

$ ansible --version
ansible [core 2.17.5]
  config file = None
  configured module search path = ['/home/noroot/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /home/noroot/.venv/ansible2/lib/python3.12/site-packages/ansible
  ansible collection location = /home/noroot/.ansible/collections:/usr/share/ansible/collections
  executable location = /home/noroot/.venv/ansible2/bin/ansible
  python version = 3.12.6 (main, Sep  8 2024, 13:18:56) [GCC 14.2.1 20240805] (/home/noroot/.venv/ansible2/bin/python)
  jinja version = 3.1.4
  libyaml = True

хотя наверное я понимаю. может быть. 
в итоге у нас есть модуль питона ansible
лежит вот здесь

>>> import ansible
>>> ansible.__file__
'/home/noroot/.venv/ansible2/lib/python3.12/site-packages/ansible/__init__.py'

а есть фронт-енд файл который с этим модулем работат. тоже на питоне написан.
но лежит вот тут

$ which ansible
  ~/.venv/ansible2/bin/ansible

 $ file  $(which ansible)
/home/noroot/.venv/ansible2/bin/ansible: Python script, ASCII text executable

тоесть это тоже питон скрипт. но это модуль-файл. а тот ансибль это модуль-папка.
это разные вещи.










теперь проверим устанолвен ли модуль pip

>>> help('modules')

ищем в списке pip

если его там нет то нужно через пакетный менеджер поставить пакет в котором будет 
два слова python и pip

  $ pacman -Q | grep python | grep pip
  python-pip 24.2-1
  python-pipx 1.6.0-1


далее к сожалению нихера не понял как сидя в питон консоли запустить модуль питона.
но что значит запустить модуль. на самом деле это означает как я понимаю что нужно запустить
некотоую функцию из этого модуля с параметрами. нокак это сделать из консоли питона я 
непонял.

вот список функций которые выставлены наружу в модуле

>>> help('pip')

Help on package pip:

NAME
    pip

PACKAGE CONTENTS
    __main__
    __pip-runner__
    _internal (package)
    _vendor (package)

FUNCTIONS
    main(args: Optional[List[str]] = None) -> int


тоесть есл я понял то модуль нам при импторте дает функцию main()
но ее вызов нихера недает

 >>> pip.main()

но можно запусить код модуля неиз консоли а неинтерактивно

   $ python3  -m pip help


и через этот модуль pip можно ставить модули питона которые лежат в интернете в центральном
репозитории питона.
для начала можно посмотреть какие модули устанолвены в питоне но чтобы нам показала это не 
консоль питона а этот модуль

   $ python3  -m pip  list 2>/dev/null | grep pip
    pip                 24.2

это именно список модулей питона а не какието там пакеты самого pip. нет нихуя.
сам pip слава богу своего формата модулей не придумал. 

однако странно. если я ищу модуль venv через pip то покажет что такого модуля нет

  $ python3  -m pip  list 2>/dev/null | grep venv
    пусто

 а если  я ищу через консоль питона

  $ python3
  >>> help ('modules')
  ...
  venv

если я запущу
  
    >>> help('venv')
  NAME
      venv - Virtual environment (venv) package for Python. Based on PEP 405.

  MODULE REFERENCE
      https://docs.python.org/3.12/library/venv.html

    ...

  FILE
    /usr/lib/python3.12/venv/__init__.py

видно где этот мтдуль лежит

значит что удивтельно - через консоль питона хуй посмотришь доки от модуля. 
это можно сделать толкько вне консоли вот так


 $ python3 -m venv -h
usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear] [--upgrade] [--without-pip] [--prompt PROMPT] [--upgrade-deps]
            ENV_DIR [ENV_DIR ...]

Creates virtual Python environments in one or more target directories.

positional arguments:
  ENV_DIR               A directory to create the environment in.

...
...


модуль venv он нам очень щас будет полезен. потому что он создает в отдельной папке отдельный
автономный питон интепретатор. и модули питона тоже туда сует. и у нас появялется как бы
автономно установленный питон. плюс  в том что далее можно ставить модули питона в эту автоном
ную папку и соотвесвтенно никак не "ломать" не изменять модули питона в системных папках 
линукса. 
типа устанвоить "инстанс" питон интепретатора
в отдельную папку. и далее в этуже папку ставить модули питона. таким образом она будет 
независима от системных файло и папок питона на системе. немешая друг другу. 
потому что дело в том что модули питона можно устанавливать тремя как минимум путями.
можно прям руками копировать файлы с портянками на питоне в нужные папки. можно это делать
через пакетный менеджер на операционной системе (например pacman) , можно ставить модули 
через модуль pip. так вот тут у нас будет конфликт. если мы с одной стороны будем ставить
модули питона через пакман , а потом ставить модули через pip а потом опять ставить через
пакман то будет бардак и пиздец.  также проблема с питоном в том что очень часто модули зави
сят друг от друга. и если мы хотим поставить модуль-А версии  то ему нужно чтобы был
установлен модуль-Б версии 5.1 , потом мы хотим поставить модуль-Ц а он хочет чтобы был
устанолвен модуль-Б версии 3.1 , получаем конфликт. эта хуйня как я понимаю строого
решена если мы ставим модули через пакетный менеджер ОС (как пакман). но если мы
хотим чтото поставить через pip (а его фишка в том что он может нам поставить не одну версию 
какогто пакета а можно выбрать из многих версий. а через пакман мы можем поставить только
одну версию пакета) то у нас быстро все поломается в питоне. короче - если мы собираемся
ставить чтото через pip то лучше всего через модуль venv создать автономную версию питона
и туда ставить что угодно неломая питон в систпмных папках ос. вот зачем нам нужен venv
и делается это так


    $ python -m venv /folder

где folder это папка куда будет устанолвен автономная копия питона
обычно это делают вот  так

    $ python -m venv  ~/.venv/Name

далее надо актиировать этот питон

    $ source ~/.venv/Name/bin/activate

все мы "запустили" автономный питон. если мы хотим попасть в консоль то 

    $ python
    >>> 

если мы хотим поставить прогу через pip то 

    $ python -m pip install module_name

ксаттаи если у нас есть текстовый файл в котором укаазано какие модули и какие версии
поставит то можно поставит сразу кучу вот так

    $ python3 -m pip install -r requirements.txt


ансибль хранися в центральном репозитории питона как питон модуль может даже более 
точнее как питон пакет. а пакет мы уже знаем что это тоже модуль. о том как устанавливать
ансибль читай ansible-setup.txt



конец главы

=============

| старое описание установки ансибля
читать необязательно.
ниже я обсуждаю установку ансибль. это более старый текст чем тот что изложен
в ansible-setup.txt и он оставлен тлько для того что там много кусков про то 
как устроен питон.
также в kubespray-ansible.txt тоже есть про питон и ансибль если что.

теперь длиннный ответ

$ pip install ansible
$ pip3 install ansible
$ sudo -H pip install ansible
$ sudo -H pip3 install ansible
$ pip\pip3 venv ansible
$ apt-get -y install ansible

в чем разница этих установок. что будет если их намешать однрвеменно.
прежде всего про питон.
у него есть модули и пакеты.
A module is a file containing Python definitions and statements.
любой файл с кодом питона внутри это и есть модуль. модуль должен иметь 
расширение .py с точки зрения названия файла. например vasya.py

как посмотреть список модулей которые "видит" питон.
заходим в питон
$python3
>>>> 

далее вводим

>>> help('modules')


и получим список модулей которые видит питон.

питон ищет модули (файлы с расширением .py) в каталогах которые прописаны в sys.path

>>> import sys
>>> sys.path

['', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/home/vasya/.local/lib/python3.6/site-packages', '/usr/local/lib/python3.6/dist-packages', '/usr/lib/python3/dist-packages']

прокомментирую эти папки

/usr/lib/python36.zip   
этой папки вобще на компе нет

/usr/lib/python3.6 
первая основная системная папка

/usr/local/lib/python3.6/dist-packages
вторая основная системная папка

именно в эти две папки обычно и ставит пакеты pip и pip3 

/usr/lib/python3.6/lib-dynload 
в этой папке лежат .so файлы. so файлы это shared
libraries (посмотреть какие so файлы  юзает любой бинарник можно через ldd имя_бинарника)

/home/vasya/.local/lib/python3.6/site-packages
сюда питон ставит новые модули в случае если мы запускаем процесс установки 
модуля без прав суперюзера а значит у питона нет прав чтобы ставить модули
в папки что выше. тогда он ставит модули в папку /home/vasya/.local/...



так вот чтобы питон увидел новый модуль file.py его надо всего лишь поместить в одну 
из папок что выше 
и help('modules') покажет новый модуль в списке.


причем что еще интересно. если поместить модуль в подпапку например в 
/usr/local/lib/python3.6/dist-packages/01/file.py 
то питон этот модуль тоже увидит. тоесть питон ищет нетолько в указанных папках
но и подпапках.

далее. как сидя в питоне узнать путь к файлу в котором хранится модуль.

>>> import kuku
>>> print(kuku.__file__)
/usr/local/lib/python3.6/dist-packages/kuku.py

(подсмотрел здесь https://www.devdungeon.com/content/get-module-file-information-python)


итак модуль это всегонавсего файл с кодом питона. а установка модуля так чтобы 
питон его видел это всегонавсего скопировать файл в определенную папку.

теперь про пакеты питона.
пакет это группа модулей. пакет имеет вид папки в которой лежит куча питон модулей(которые 
как логично все посвящены какойто общей задаче).
чтобы питон отличил просто папку с кучей несвязанных друг с другом разнородных 
модулей от папки которая является пакетом в такой папке должен лежать файл __init__.py
если в папке лежит такой файл то питон понимает что это непросто папка с кучей модулей
друг с другом несвязанных а это папка с кучей модулей друг с другом связанных
являющаяся пакетом.
 как я понял пакет (папка) обычно также содержит подпапку __pycache__
в которой лежат уже откомпилированые модули этого пакета. захера они нужны.
как я понял при загрузке пакета питон вначале ищет pyc файлы и если они есть грузит их.
а если нет тогда py файлы. разница между py  и pyc файлами в том что прежде чем начать
исполнять код питон должен откомпилировать py файл в pyc  а если это уже сделано 
то это экономит сколько то времени.

внутри пакета могут быть без пролем другие пакеты. главное чтобы папка с субпакетом 
имела файл __init__.py

также. и модуль при импорте и пакет оба они получат один статус в питоге. - статус модуля.

хотя os это пакет а kuku это модуль 

>>> import os
>>> type(os)
<class 'module'>
>>> import kuku
>>> type(kuku)
<class 'module'>

они оба получают одинаковый класс module 

далее. прикол в том что чрез команду import мы формально испортируем модуль.
вобщем люди пишут что пакеты это тоже модули. просто типа они офомлены другим образом.
вобщем непонятный идиотизм. также модуль это в конечно итоге обьект в памяти питона.
пакет это модуль который должен иметь атрибут __path__ а просто модуль этого атрибута
неимеет.
прикол еще в том что якобы питона пакеты и pypi пакеты это совсем разные пакеты.
идиоиизм.


тем не менее. двигаем дальше.
пакет поскольку он модуль то установенный пакет он тоже отображается командой
>>> help('modules')
имя пакет будет такое же как называется папка с пакетом.
поэтому если мы хотим посмотреть какие пакеты видит питон то надо искать 
имя пакета в списке модулей.
пакеты ставятся в туже папку что и модули.
как они ставятся?
можно ставить руками.

идем на сайт с питон пакетами. выбираем пакет
https://pypi.org/project/wa-cli/#files

тыкаем в "downloaded files"
скачиаем файл tar.gz с пакетом

дальше запускаем
$ python3 setup.py  install

но скорей всего при этом установщик заругается что нехватает прав записи в в системные
папки

  [Errno 13] Permission denied: '/usr/local/lib/python3.6/dist-packages/test-easy-install-1515.write-test'

тут два выхода.
первый это запустить установку с повышенными правами

$ sudo -H python3 setup.py  install

но этот метод вызывает вопросы потому что в питоне каждый модуль может быть установлен
только какой то версии. а прикол в том что разные проги могут нуждатся в модуле определенной
версии поэтому модифцируя системные папки питона мы можем  изменить версию какого то 
модуля\пакеты и тогда какая то программа незаработае после этого.
вобще пока что дело темное.

есть другой путь. поставить модуль локально только для нашего юзера в папку .local

$ python3 setup.py  install   --user

тогда пакет будет устанолвен в папку 

~/.local/lib/python3.6/site-packages/wa_cli-0.0.0-py3.6.egg
 
далее его можно увидеть через 

>>>> help('modules')
wa_cli

после установки его можно ипортнуть и юзать

>>>> import wa_cli

далее прикол в том что при устаноаке пакета он ставит свои запчасти нетлоько 
в папки прописанные в sys.path но и в папки : 

~/.local/bin
/usr/bin
/usr/local/bin

а это уже дает то что файлы по данным путям уже видит нетолько сам питон
но и баш. таким образом после установки пакета у нас может появится в д оступе
новый питон скрипт которые можно запустить сразу с баш строки. таким образом установка пакета
питона становится конкурентом пакетного менеджера apt !

например!  ansible это нечто иное как питон пакет. так вот ансибль можно скачать с сайта pypi
и поставить как пакет: распоковать и sudo -H python3 setup.py  install

опа! тоесть мы скажем проверяем есть ли у нас ансибль в системе через sudo dpkg -l | grep ansible
и видим что deb пакета такогонет. зато ансибль вместо этого может быть установлен через пакеты питона!  вот это жопа!!

боле того ! по факту apt-get -y insyall ansible он на самом деле делаем тоже самое что мы бы 
делали руками - он ставит пакет питона только за нас !!!!!  

тут я еще скажу вот что - руками ставить пакеты питона это идиотизм также как руками ставить
deb пакеты через dpkg. аналогом apt-get у питона является пакет pip3 (для питона 3) и pip (для питона2)

ставим pip3

$ sudo apt-get update && sudo apt-get -y install python3-pip

данный пакет ставит документашки в /usr/share/doc и /usr/share/man
ставит wrapper скрипт (запускашку) в  /usr/bin/pip3 ( про вызове этого скрипта сам питон 
потом ругается что мол это устаревший метод вызова пакета pip3 и вместо него надо юзать 
python3 -m pip команду). и ставит кучу файлов в /usr/lib/python3/dist-packages/pip/ это та папка 
куда для питона надо ставить файлы от модулей или пакетов.

все теперь про ручную усатновку пакетов питора можно забыть.


после установки у нас питон3 увидит новый модуль pip

>>> help('modules')
pip

>>> import pip

>>> print(pip.__file__)
/usr/lib/python3/dist-packages/pip/__init__.py

итак через apt у нас будут скопированы файлы в папку /usr/lib/python3/dist-packages/pip/
и также будет создан файл /usr/bin/pip3

таким образом с точки зрения питона у него появился пакет с именем pip!
а если запускать через баш то нам надо обращаться к файлу pip3 !

тогда уже юзая pip3 мы можем посмотреть какие пакеты ( пакеты а не модули!) установлены 
в системе

$ pip3 list
...
pip (9.0.1)
...

в частности увидим что он покажет сам себя что пакет pip установлен.

далее можем посмотреть инфо об этом пакете через pip3

$ pip3  show pip

Name: pip
Version: 9.0.1
Summary: The PyPA recommended tool for installing Python packages.
Home-page: https://pip.pypa.io/
Author: The pip developers
Author-email: python-virtualenv@groups.google.com
License: MIT
Location: /usr/lib/python3/dist-packages
Requires: 


далее теперь уже средстваами pip ( а не apt ) мы можем заапгредйить пакет pip

$ pip3 install --upgrade pip
Collecting pip
  Downloading https://files.pythonhosted.org/packages/a4/6d/6463d49a933f547439d6b5b98b46af8742cc03ae83543e4d7688c2420f8b/pip-21.3.1-py3-none-any.whl (1.7MB)
    100% |████████████████████████████████| 1.7MB 428kB/s 
Installing collected packages: pip
Successfully installed pip-21.3.1

итак была унас версия 9.0.1 а стала 21.3.1

а куда же он ее поставил ведь мы запустили без права админа

$ pip3  show pip
WARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.
Please see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.
To avoid this problem you can invoke Python with '-m pip' instead of running pip directly.
Name: pip
Version: 21.3.1
Summary: The PyPA recommended tool for installing Python packages.
Home-page: https://pip.pypa.io/
Author: The pip developers
Author-email: distutils-sig@python.org
License: MIT
Location: /home/vagrant/.local/lib/python3.6/site-packages
Requires: 
Required-by: 

ага понятно. поставл он ее локально в папку $/.local/

помимо sudo и без sudo есть еще один вараинт установки пакетов через venv.(об этом позже)

есть еще такой способ работы с pip3

$  python3 -m pip install --upgrade pip


теперь поставим ансибль через pip3

$ python3 -m pip install ansible

поставится он только для данного юзера в .local

$ python3 -m pip  show ansible
Name: ansible
Version: 4.10.0
Summary: Radically simple IT automation
Home-page: https://ansible.com/
Author: Ansible, Inc.
Author-email: info@ansible.com
License: GPLv3+
Location: /home/vagrant/.local/lib/python3.6/site-packages
Requires: ansible-core
Required-by: 


что интересно если юзать pip3 ... то питон ругается что модуль pip вызывается через 
старый wrapper и сам питон рекомедует юзаьть вызов pip через нотацию $ python3 -m pip

что интерсно. ансибль это тоже модуль\пакет который виден через help('modules')
но к ансиблю вот в такой форме уже неподуступиться

$ python3 -m ansible --version
/usr/bin/python3: No module named ansible.__main__; 'ansible' is a package and cannot be directly executed

итак мы поставили ансибль через менеджер пакетов питона

$ python3 -m pip install ansible

ансибль это питон пакет.

поставили мы его без админских прав.

и он поставился в папку ~/.local/lib/...

таким образом если мы будем накатывать ансибль через apt-get то он конешно тожн будет по факту
пакет от питона но будем установлен в /usr/lib либо /usr/local/lib и никакого конфликта
с ансиблем который лежит в ~/.local/lib/... невызовет.

тут еще важно отметить про ансибль. с какогото момента он теперь состоит из двух 
питон пакетов.

- ansible
- ansible-core

$ python3 -m pip list | grep ansible
ansible                       4.10.0
ansible-core                  2.11.7

(стоит упомнять что ансибль чуть более старый имел второй пакет ansible-base вместо ansible-core )

также стоить упомнуть что файл из ~/.local/bin/ansible
он исходит из пакета ansible-core

пруф
$ python3 -m pip show -f ansible-core | grep 'bin/ansible'
  ../../../bin/ansible

пакет ansible-core обеспечивает некий базовый функционал ансибля.
над ним работют как я понял более продвинутые програмисты. а пакет ansible 
там уже куча модулей (ансибля) над которыми работают уже кто попало из комьюнити ансибля.

поэтому для устаовки ансиля в целом достаточно установить пакет ansible-core

$ python3 -m pip install ansible-core

а пакет ansible уже опционален.


также понятно что питон модули глобальрно лучше неставить через pip3 
чтобы небыло разногласий с apt-get

еще момент дебилистический. если мы у самого ансибля спросим какая у него версия
он напишет полную хуйню

$ ./ansible --version
ansible [core 2.11.7] 

он напишет версию пакета core. а нас интересует какая версия у пакета ansible
так вот чтобы это узнать надо спрашивать не уансибля а у питона

$ python3 -m pip list | grep ansible
ansible                       4.10.0
ansible-core                  2.11.7

теперь мы видим что коммунити кусок имеет версию 4.10 а уже ядро имеет версию 2.11.7

все таким поставим анстбдь из apt-get чтоы посмотреть в какие папки apt засунет модуль 
ансибль

$ sudo apt-get update && sudo apt-get -y install ansible

$ sudo dpkg -L ansible | grep 'bin/ansible'
/usr/bin/ansible

итак апт засунул запускающий скрипт ансибля в /usr/bin/ansible

ну и если еще посмотреть на dplg -L ansible 
то увидим что сам питон пакет apt засунул в /usr/lib/python2.7/dist-packages/ansible/

итак получаетс что apt ставит пакет ансибля не для python3 а для python2

проверяем версию ансибля
$ /usr/bin/ansible --version
ansible 2.5.1

получается это еще старая версия ансибля та которая была еще до разделения его на 
core модуль и коммьюнити модуль

поставим pip для второго питона

$ sudo apt-get -y install python-pip

и посмотрим какую он инфо покажет насчет этого ансибля

$ pip list | grep ansible
ansible (2.5.1)

$ pip show ansible
Name: ansible
Version: 2.5.1
Location: /usr/lib/python2.7/dist-packages


воникает вопрс  а если мы для питон3 поставим ансибль то в какой папке будет bin/ansible ?


sudo -H python3 -m pip show -f  ansible-core | grep 'bin/ansible'
  ../../../bin/ansible

поскольку пакет был установлен в папку /usr/local/lib/python3.6/dist-packages/
$ sudo -H python3 -m pip show  ansible-core 
Name: ansible-core
Location: /usr/local/lib/python3.6/dist-packages

то папка ../../../ будет иметь путь  = /usr/local

значит ../../../bin/ansible = /usr/local/bin/ansible


теперь сравниваем apt поставил ansible (файл) от питона2 в папку /usr/bin/ansible
а sudo pip3 поставил файл ansible от питона3 в папку /usr/local/bin/ansible

получается впринициепе что два ансибля могут спокойно типа существовать на компе
одновременно. ( но опять же это до поры до времени пока apt неначнет ставить ту версию ансибля
которая для версии от питона3)

осатетя вопрос - так кау версию ансибля будет запускат баш из командной строки

$ ansble --version

если у нас аж три ансибля установлено.
ответ баш запустить ансибль тот который лежит в ~/.local/bin

теперь можно возвоаратиться к исходному вопросу
в чем разница установки ансибля всеми этими способами
и будут ли они мешать друг другу

$ pip install ansible
$ pip3 install ansible
$ sudo -H pip install ansible
$ sudo -H pip3 install ansible
$ pip\pip3 venv ansible
$ apt-get -y install ansible

во первых я бы скзаал что строки 
$ pip install ansible
$ sudo -H pip install ansible

я бы вобще исключил. ибо ненаоб ставить ансибль на питон2 который уже 
ансибль нехочет юзать и хочет от него избавиться


вот этот способ
$ pip\pip3 venv ansible
мы нерассмотрели. ну и хер с ним. там ничего интересного.

остаются строки
$ pip3 install ansible
$ sudo -H pip3 install ansible
$ apt-get -y install ansible


тут я скажу так. apt-get -y install ansible =  этот метод поставит ансибль для второго питона.
этот метод никак неперескеется и немешает установке ансибля через оставишиеся строки
$ pip3 install ansible
$ sudo -H pip3 install ansible

если сранвить оставшиеся строки . то первая ставит ансибль в папку ~/.local
а вторая в папку /usr/local/lib/python3.6/
эти две установки друг другу никак немешают.

и  в целом поучается эти три способа усатновки друг другу никак немешают.
единсвтенное что: в будущем apt может начать ставить ансибль уже не для второго питона 
а для третьего и тогда уже конфликт становится очевиден.  и тогда получается что надо 
решатт либо ставить ансибль чеерез 

$ sudo -H pip3 install ansible
либо
$ sudo -H apt-get -y install ansible

но чтото одно. 

и еще замечаение что (пока в целом непонятно ) но ставить модули питона в системную папку 
под sudo pip3 вроде как плохой тон. ибо можно поломать чтото из за того что будут обновлены
версии пакетов. это пока непонятно. тоесть безопаснее ставить pip3 под лкальными правами
чтобы установка шла в локальну папку ~/.local

возгикает общий вопрос - так а как луче всего ставиь ансибль. каким способом.

тут вилка в том что через apt можно поставить будет какую то древнюю версию а через 
pip поставить ульрасовременную.  поэтому наверно суммарно  я за вот этот способ

$ pip3 install ansible
или 
$ python3 -m pip install ansible

оба способа равнозначны. этим способом мы ставим ультрасоверменную версию ансибль 
только локально для себя. ничего неломая и ничем нерискуя.



далее мне ставло интеересно а каку версию ансибля поставит pip для второго питона

vagrant@test2:~$ ansible --version
ansible [core 2.11.7] 
  python version = 2.7.17 (default, Feb 27 2021, 15:10:58) [GCC 7.5.0]

очевидно что явно нестарую версию.

vagrant@test2:~$ python -m pip list | grep ansible
ansible (4.10.0)
ansible-core (2.11.7)


и там в варнинге написано что со следущего релиза ансибль комнда програмисто 
прекращает поддержку питона2

а вот проверим а каку версию ансибля ставит apt для ubuntu21.10 тот который самый 
распоследний. при установке через вагрант вылезает ошибка вида
bash: line 4: /sbin/ifdown: No such file or directory
и прочая поебень.
но отчаиваться рано. решение такое. все равно можно зайти на ВМ. и там просто 
надо накатить пакет ifupdown

$ vagrant ssh
$ sudo apt-get install ifupdown

далее. ставим ансибль через apt

теперь смотрим что у него за версия

$ ansible --version
ansible 2.10.8
  ansible python module location = /usr/lib/python3/dist-packages/ansible
  executable location = /usr/bin/ansible

видим что версия уже точно для питон3.
значит смешивать установку ансибля через pip3 и через apt нельзя. чтото одно.

видим что версия 2.10.8


$ python3 -m pip list | grep ansible
ansible-base           2.10.8

забавно. еще нет никакого разеления на пакеты ansible и ansible-core. а по прежнему
один пакет.

$ python3 -m pip show ansible-base
Name: ansible-base
Version: 2.10.8

посмотрим что еще dpkg покажет

$ sudo dpkg -l | grep ansible
ansible                         2.10.7+merged+base+2.10.8+dfsg-1 

прикол. версия deb пакета толи 2.10.7 толи 2.10.8 хуй поймешь


удаляем ansible через apt

ставим ансибль через pip3
$ python3 -m pip install ansible-core

получаем 
$ ~/.local/bin/ansible --version

ansible [core 2.12.1]
  ansible python module location = /home/vagrant/.local/lib/python3.9/site-packages/ansible
  executable location = /home/vagrant/.local/bin/ansible

ставим коммьюнити пакет.

$ python3 -m pip install ansible

в итоге получаем

~$ python3 -m pip  list | grep ansible
ansible                5.1.0
ansible-core           2.12.1


ансибль версия пятая потому что в убунту21 уже стоит питон 3.9 
а в убунту 18 который у меня на первой тестовой машине там стоит всего лищь питон 3.6

заметки:
установка в $HOME/.local = если у pip\pip3 нехватает прав чтобы записывать в папки
/usr/lib/python3.6 /usr/local/lib/python3.6/dist-packages то ставит пакет в папку $HOME/.local.
эта папка входит в sys.path так что питон прекрасно там находит пакеты. единственное что установ
ленный пакет будет доступен толькьо для теекущего юзера зато незатрагиваются системные папки питона.

далее. версии современного ансибля.
раньше ансибль шел в форме одного пиитон пакета. с недавнего времени он разделен на два пакета.
ansible-core ( который вначале назывался еще ansible-base) и пакета ansible.
ansible-core является пакетом исходным и основным над его поддержкой работают самые крутые 
програмисты. пакет отвечает за самые основные функции ансибля в часьтности в неми и находится
файлик ansible. а второй пакет ansible за его поддержку ответчает уже комьюнити пионеров програмистов. там находятся уже всяко разные модули ансибля. 
дебилизм еще в том что скажем релиз ансибля имеет например номер 4.1.2 так вот это номер релиза 
именно пакета ansible который поддерживает комьюнити пионеров. а номер релиза ansible-core 
при этом скажем 2.10.17 так вот в  чем дебилизм это то что если у ансибля спросить мол какая у тебя версия 
$ ansible --version 
то он сука выдаст именно версию ядра а не самого ансибля. разве недебилизм?
и чтобы узанть версию ансибля надо обращаться к питону к модулю pip3
$ python3 -m pip list | grep ansible 
либо 
$ python3 -m pip show ansible

далее. при установке пакета через pip3 ( и pip далее всегда если пишу pip3 то автоматом это же верно  и для pip) он копирует файлы нетлько в системные папки питона /usr/lib/python3.6 /usr/local/lib/python3.6/dist-packages но также и в папки /usr/bin/ либо /usr/local/bin. туда он ставит файлы обертки для запуска модулей. например файл-обертка ansible. так вот установка в /usr/local/bin
либо в /usr/bin дает то что файлы обертки видит баш.

далее. поскольку мы можем ставить модули питона и через pip3 и через apt то получется жопа
у нас на компе потому что у нас получается две системы пакетов одновременно хотя и касающихся только
питона. тоесть можно поставить пакет через apt а потом его обновить через pip3 и получается отстой.

далее. в убунту18 apt ставит ансибль для питона2. а начиная с убунту20 apt уже ставит ансибль для 
питона 3.

далее. если apt ставит какой то пакет питона то этот пакет будет конечено же виден и через 
pip3 list и через help('modules') тоесть apt устанавливая пакеты питона неделает никаких чудес.


далее. как я понял есть с  пакетами питона проблема. каждый пакет имеет какую то версию.
далее вот у нас есть какойто питон скрипт либо какойто питон модуль ( кстати скрипт питона 
становится модулем если его всего навсего скопироват в системную папку питона вот и вся разница) и 
этот скрипт или модуль требует для себя какойто другой модуль определенной версии либо нениже 
какойто версии. так вот как  я примерно понимаю что в любой момент в ОС может быть устанолена 
только одна версия модуля путем того что этот модуль лежит в системной питон папке. так вот 
если мы обновляем модуль питона либо ставим +1 модудь питона который обновляет другой модуль 
который уже есть в системе то может получится ситуация что другой модуль уже перестанет работаьт
из за обновления вресии модуля. например мы ставим модуль А который требует для себя модуль Б версии  Y, тогда pip3 обновить модуль Б до версии Y а у нас в системе есть модуль C который тоже 
юзает модуль Б но ему надо чтобы модудь Б был версии X. 
таким макаром навскидку с питоном получается дебилистическая ситуация. наверное когда мы ставим
модули питона через apt то они ( секретные они ) заботятся чтобы проверить совместимость всех модулей а когда мы ставим\обновляем модуль питона через pip3 то это становится нашей головной болью.
дебилизм какойто в питоне однако. поэтому получается что если мы ставим какой то модуль сами 
через pip3 то лучше и безопаснее неделать это через sudo pip3 чтбоы нетрогать системные папки
с модулями питона а делать это через pip3 с понимженными правами тогда все имзенения с модулями
будут каcаться только папки $HOME/.local/ а еще наверное более надежно делать установку через связку pip3 + venv тогда точно ничего несломается.


далее. команда which ansible где и как она находит ansible. which ansible - он его ищет в папках которые прописаны в $PATH в том порядке как там папки указаны.
и в какой первой находит ткую и выдает.   а вот когда мы уже запускаем в баше ансибль то он 
почему то ищет в папках по другому порядку. по какому я так и непонял. 
 поэтотому если у нас ансибль есть и  в /usr/bin и в /usr/loca/bin/
то which absible выдвет что ансибль лежит в /usr/loca/bin/ а по факту бащ запускает бинаник из /usr/bin. это надо еще разбирать. 

далее. если у нас на компе стоит милион версий ансибль как нам об этом узнать. 
можно проверить через apt, можно через pip3. но опять же pip3 покажет только одну версию ансибля.
а если скажем у нас один модуль стоит в папке 
/usr/lib/python3.6 а другой модуль стоит в папке $HOME/.local тот pip3 покажет только 
ансибль модуль в папке $HOME/.local так что самый надежный способ это через find найти все 
файлы на компе с именем ansible и ключом +x у него. это дебилизм.

далее. если мы запускаем pip3   с повышенными правами то неважно как запускать 
sudo или sudo -H , так как домашняя папка неважна ибо установка будет идти не в домашнюю
папку а в папки /usr/lib/python3.6  либо /usr/local/lib/python3.6


далее.итак наконец как же коректно поставить ансибль для проекта kubespray
смотри в kubespray-ansible.txt
=============================================================================
ubuntu 18
pip
pip3


# sudo apt install python-pip
# sudo apt install python3-pip


====

|mysql connector

$ pip install mysql-connector-python

==
| список модулей

$ pip list

либо

>>>  help("modules")


===

| mysql connector

значит пишу что его надо ставит как 

$ pip install mysql-connector-python

мне так где то сработало а где то нет.

на ubuntu 18 не сработало. при запуске питон скрипта 
мне писало ошибку


"MySQL Connector C Extension not available"

как ее поорбоить непонятно.

поэтому сносим нахуй этот модуль в pip (если уже установили)

$ pip uninstall mysql-connector-python

а далее ставим пакеты

# apt-get -i install
libmysql6.4-cil
libmysqlclient20:amd64
python-mysql.connector
python-mysqldb
python3-mysqldb


не могу точно сказать какой паеет прям спасает но мне кажетс что это libmysql6.4-cil

только после этого доступ к мускула через питон заработает сука

====

| mysql connect

скрипт



он лезет в таблицу waybill.
берет оттуда самый старый waybill_id
потом его ищет в дочерних таблицах.
удаляет если там есть строки и потом удаляет уже в головной таблице waybill



# cat 1.py 
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     

date_end = datetime.date(2011, 1, 1)
j_max=5000


mydb = mysql.connector.connect(
host="172.17.0.1",
user="root",
password="rootpass",
database="db",
port=3306
)
     
mycursor = mydb.cursor()
     


#
# waybill
#
query = ("SELECT waybill_id, date  FROM waybill "
       "WHERE date <= %s order by date asc limit 1")

mycursor.execute(query, (date_end, ))
myresult2 = mycursor.fetchall()
     
for x in myresult2:
       l = len(myresult2)
       




j=1

while l > 0:
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill WHERE date <= %s   order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult = mycursor.fetchall()

     if len(myresult) == 0:
        break

     for x in myresult:
         d=x[0]
         waybill_data=x[1]
         
     
     
     
     
     #
     #   order_profit
     #
     query = ("select waybill_id  from order_profit where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()


     
     if myresult:
        query = ("delete from  order_profit where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
          # Verify using select query (optional)
        query = ("select waybill_id  from order_profit where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     
     #
     #   category_waybill
     #
     query = ("select waybill_id  from category_waybill where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  category_waybill where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
        #print('number of rows deleted', mycursor.rowcount)
          # Verify using select query (optional)
        query = ("select waybill_id  from category_waybill where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     
     #
     #   storage_service
     #
     query = ("select waybill_id  from storage_service where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  storage_service where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
          # Verify using select query (optional)
        query = ("select waybill_id  from storage_service where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     #
     #   trip_contents
     #
     query = ("select waybill_id  from trip_contents where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        #print "trip_contents has waybill_id=",d
        query = ("delete from  trip_contents where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
        #print('number of rows deleted', mycursor.rowcount)
          # Verify using select query (optional)
        query = ("select waybill_id  from trip_contents where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     
     #
     #   waybill
     #
     #print "waybill has waybill_id=",d
     query = ("delete from  waybill where waybill_id = %s")
     mycursor.execute(query, (d,))
     mydb.commit()
     #print('number of rows deleted', mycursor.rowcount)
     
     
     query = ("select waybill_id  from waybill where waybill_id = %s")
     # Verify using select query (optional)
     mycursor.execute(query, (d,))
     records = mycursor.fetchall()
     
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill "
               "WHERE date <= %s order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult2 = mycursor.fetchall()
     if len(myresult2) == 0:
        break

     
     for x in myresult2:
         #print "111 waybill_id=",x[0]
         #print ""
         l = len(myresult2)


     if j == j_max:


         from datetime import datetime
         now = datetime.now()
         current_time = now.strftime("%H:%M:%S")
         print("Current Time =", current_time)

         print "waybill_data=", waybill_data
         print j_max," rows has been proceeded\n"

         j = 0
     else:
        j+=1


print "the program has finished"
     
     
mycursor.close()
mydb.close()

----------------------------

а вот несклоько изменная версия этого же скрипта


# cat 2.py

                                                                                                                                                                                              
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     

date_end = datetime.date(2019, 1, 1)
j_max=5000


mydb = mysql.connector.connect(
host="172.17.0.1",
user="root",
password="rootpass",
database="db",
port=3306
)
     
mycursor = mydb.cursor()
     


#
# waybill
#
query = ("SELECT waybill_id, date  FROM waybill "
       "WHERE date <= %s order by date asc limit 1")

mycursor.execute(query, (date_end, ))
myresult2 = mycursor.fetchall()
     
for x in myresult2:
       l = len(myresult2)
       




j=1

while l > 0:
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill WHERE date <= %s   order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult = mycursor.fetchall()

     if len(myresult) == 0:
        break

     for x in myresult:
         d=x[0]
         waybill_data=x[1]
         
     
     
     
     
     #
     #   order_profit
     #
     query = ("select waybill_id  from order_profit where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  order_profit where waybill_id = %s")
        mycursor.execute(query, (d,))
     
     
     
     
     
     #
     #   category_waybill
     #
     query = ("select waybill_id  from category_waybill where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  category_waybill where waybill_id = %s")
        mycursor.execute(query, (d,))
 
     
     
     
     
     #
     #   storage_service
     #
     query = ("select waybill_id  from storage_service where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  storage_service where waybill_id = %s")
        mycursor.execute(query, (d,))
 

     
     
     
     #
     #   trip_contents
     #
     query = ("select waybill_id  from trip_contents where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  trip_contents where waybill_id = %s")
        mycursor.execute(query, (d,))
 
     
     
     
     
     
     #
     #   waybill
     #
     #print "waybill has waybill_id=",d
     query = ("delete from  waybill where waybill_id = %s")
     mycursor.execute(query, (d,))

     
     
     
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill "
               "WHERE date <= %s order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult2 = mycursor.fetchall()
     if len(myresult2) == 0:
        mydb.commit()
        break

     
     for x in myresult2:
         #print "111 waybill_id=",x[0]
         #print ""
         l = len(myresult2)


     if j == j_max:
         # commit to DB every j_max cycles
         mydb.commit()
         # print current time
         from datetime import datetime
         now = datetime.now()
         current_time = now.strftime("%H:%M:%S")
         print "Current Time =", current_time
         print "waybill_data=",waybill_data
         print j_max," rows has been proceeded\n"
         # reset j counter
         j = 0
     else:
        j+=1


print "the program has finished"
     

mydb.commit()
mycursor.close()
mydb.close()

---------

| print

по поводу распечатки 


создаем три переменные.
а потом хотим их вставиь в распечатку.

print "table %s, order_id=%s, order_mark_id=%s" % (A_table,p,q)

разберем по частям

"table %s, order_id=%s, order_mark_id=%s"

через %s указывается очередная стринг перменная . какое именно имя
переменной мы пропишем позже.
таким образом у нас укзаано что есть три стринг перпенных.

% (A_table,p,q)

это кусок как раз укащзываем имена переменных которые надо подставить внутрь.
а вот поный листинг програрммыы


# cat 4.py

#!/usr/bin/python
import sys


A_table="vasya"
p=1
q=2


print "table %s, order_id=%s, order_mark_id=%s" % (A_table,p,q)

прочитал я об этом вот здесь

https://www.learnpython.org/en/String_Formatting#:~:text=Python%20uses%20C%2Dstyle%20string,%22%20and%20%22%25d%22.

помогла фраза:
Python uses C-style string formatting to create new, formatted strings. The "%" operator is used to format a set of variables enclosed in a "tuple" (a fixed size list), together with a format string, which contains normal text together with "argument specifiers", special symbols like "%s" and "%d".

и пример

# This prints out "John is 23 years old."
name = "John"
age = 23
print("%s is %d years old." % (name, age))

----
| mysql connect


вроде бы сто раз напиано как  раотать с мукулом через питон.
но на практике там хуйня.
дело вот в чем


методе .execute() который и пуляет запросы на мускул он умеет юзать переменные в выражении 
только для параметров НО СУКА он неумеет использовать переенные для имени базы сука.
поэтму если мы хотим имя базы в запросе прописать через перменную а не константу то надо изголиться


пример работюащейго листинка



#!/usr/bin/python

import sys


A_table="vasya"
p=1
q=2


print "table %s, order_id=%s, order_mark_id=%s" % (A_table,p,q)

[vasya@lenovo order]$ cat temp3.py 
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     


mydb = mysql.connector.connect(
host="localhost",
user="root",
password="rootpass",
database="db",
port="3308"
)
     
mycursor = mydb.cursor()
     

# order_id from A1 table
a1_order_id="1"


# set table names
tb="A1"



#   A1 (order_id,order_mark_id)
#
query = ("SELECT order_id,order_mark_id FROM `%s` WHERE  order_id = %%s") %(tb,)
mycursor.execute(query, (1,))
myresult2 = mycursor.fetchall()

print "the program has finished"
     

mydb.commit()
mycursor.close()
mydb.close()


значит самая фишка вот в этих двух строках


query = ("SELECT order_id,order_mark_id FROM `%s` WHERE  order_id = %%s") %(tb,)
mycursor.execute(query, (1,))


как я уже сказал если мы подставляем вмест имени базы пременуб то execute() метод будет 
сука как ни изголыйя выкидвать ошибку.  поэтому  как пишу умные люди  надо вставить имя 
базы в стринг до того как оно поступит в метод execute. делается это через кусок


query = ("  блаблабла  `%s` блаблабла") %(tb,)

вот эта хуйня соощает питону что надо в стринге query замениь %s на то что лежит в переменной tb
и эта замена происходит до того как query поступит в .execute

далее для того чтобы все нееперепуталось то уже для переменных которые умеет юзать execute 
используется %%s

таким образом в execute поступает query вида


query = ("SELECT order_id,order_mark_id FROM `A1` WHERE  order_id = %%s")

видим что A1 уже вставлен  ввиде константы. 

кстати вроде и такой вариант тоже рабоатет 

query = ("SELECT order_id,order_mark_id FROM `%s` WHERE  order_id = %%s") %(tb)


 яимею ввиду что было  %(tb,)  а стало %(tb)

 что это вобще за хуйня? а это идет из правил для print (смотри предыдущий вопрос).


 теперь что такое  mycursor.execute(query, (1,))
 а именно (1,)

 эта хуйня называется tuple в питоне. по руски переводится "кортеж". в любом слоучае ниуя непонянтно в плане
 первода.

 скажу точто в чем отличие tuple от list.
 в list порядок элементов (строк) неважен. так они пишут. якобы нваерно они имеют вввиду что если 
 создать список

 a= [1,2,3]
 то он при считыавании может якобы выдываься в любом порядке. 
 наверно это они имеюи ввиду.

 а tuple это как бы спсок но с четко строгим порядком элементов

 a= (1,2,3,4)
 вот как указали так и буедет выдавыться на считыавании.

 так вот хуйня вида

 a=(1,)
 она озанчает tuple только из одног элемента.

 так вот execute() метод от mysql connector он принимает на вход только tuple
 поэтому когда мы хотим передать чему равно order_id =1

 query = ("SELECT order_id,order_mark_id FROM `A1` WHERE  order_id = %%s")
 mycursor.execute(query, (1,))

то мы юзаем тупл вида (1,)

вот такая хует со всем этим дело.

супер ползыне ссылки откуда я узнал такак же сука подставял ять имя базы в виде перменнеой
а не виде хардлодка


https://stackoverflow.com/questions/6618344/python-mysqldb-and-escaping-table-names
https://stackoverflow.com/questions/9394291/python-and-mysqldb-substitution-of-table-resulting-in-syntax-error/9394450#9394450

вот еще пример оттуда

selectQ ="""SELECT * FROM  %s WHERE %s = %%s;""" % (self.table,self.columnSpecName)
self.db.execute(selectQ,(idKey,))

сразу замечу что """ xxx """ эквавалетент ("")
так что это эквивлаетно


selectQ =("SELECT * FROM  %s WHERE %s = %%s;") % (self.table,self.columnSpecName)
self.db.execute(selectQ,(idKey,))


значит что здесь и как работает.
мы видим два %s . они будут подставлены из  self.table и  self.columnSpecName переменных.

эквивалент


selectQ =("SELECT * FROM  %s WHERE %s = %%s;") % (A,B)
self.db.execute(selectQ,(idKey,))


если A="vasya" а B="petya"
то оно подставться как 

selectQ =("SELECT * FROM  vasya WHERE petya = %%s;") 

вот такая хуйня будет сделана с этим стрингом до того как он поуступит в .execute()
метод.

а когда оно туда поступит то .execute() увидит внутри переменную уже для себя %%s.
и он туда подставит то что находится в тупле (idKey,)
если idKey=1 то он подставит 1 и в итоге будет

"SELECT * FROM  vasya WHERE petya = 1;"
и такой запрос улетит в мускул.


вот такая хуйня.

таким образом перед тем как стринг улетит в мускул  его обрабыает с двух сторон 
с оной стороны сам питон   через конструкцию

selectQ =("блаблабля  %s блаблабла %s блаблабла") % (A,B)
а затем метод .execute() для которого это выглядит как

("блаблаблббла  %%s")
self.db.execute(selectQ,(idKey,))

и вместо %%s он подставить  (idKey,) а точнее idKey

пиздец полный этот питономастерсоздаетль

======
| tuple list

у питона есть виды данных

есть list

a= [1,3,4,5,5]

а есть tuple

a=(1,2,3)

или 

a=(1,)

это когда тупл из одного элемнта.

тупл в отличие от спска имеетт строгий поряок элементов.

так вот быает вот такой еще хрень на выходе

[(1,)]
что это ? 
это список

у котрого один элемент. и этот элемент это тупл.


возгикает ворос как добраться до этой единицы внутри

а вот так

$ cat 5.py 
#!/usr/bin/python
import sys


a=[(1,)]

print a

print a[0]

print a[0][0]

b=a[0][0]

print "b=%s" % (b)




$ ./5.py 
[(1,)]
(1,)
1
b=1


интеерсно да?

пздц

===================
|mysql connect


у нас есть две таблицы

A1 (order_id, order_mark_id) 
B1 (order_mark_id)

B1 это дочерняя таблица для A1 по полю  (order_mark_id)


мы делаем селект (order_mark_id) из `A1`  при заданом (order_id)
потом мы в таблице `B1` удаляем все строки с этим (order_mark_id)
и затем уже мы удалеяем в `A1` строку с этим (order_id)



стои обратить внимание как делается query

query = ("delete from  %s  where order_mark_id = %%s;") %(B_table,)
mycursor.execute(query, (y[0],))


дело в том что только при такой технологии мы можем передаваь в запрос имя таблицы
через переменную (ищи об этом подробнее чуть вы ше  в предыдущих вопросах . это пиздец)




[vasya@lenovo order]$ cat order_mark.py 
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     

mydb = mysql.connector.connect(
host="localhost",
user="root",
password="rootpass",
database="db",
port="3308"
)
     
mycursor = mydb.cursor()
     

# order_id from A table
A_order_id="1"




#
#   A1 (order_id,order_mark_id)
#

# set table names
A_table="A1"
B_table="B1"

query = ("SELECT order_id,order_mark_id FROM  `%s`  WHERE  order_id = %%s;")  %(A_table,)
mycursor.execute(query, (A_order_id,))
A_result = mycursor.fetchall()


 
if A_result:
       # clear B1 for order_id and order_mark_id
       print "---------------------------------------"
       for x in A_result:
               # x[0] is order_id | x[1] is order_mark_id
               print "table %s  (order_id,order_mark_id) = (%s,%s)" % (A_table,x[0],x[1])
               B_order_mark_id=x[1]

               #
               #   B1  (order_mark_id)
               #
               query = ("SELECT order_mark_id FROM %s  WHERE  order_mark_id = %%s limit 1;") %(B_table,)
               mycursor.execute(query, (B_order_mark_id,))
               B_result = mycursor.fetchall()

               if B_result:
                   for y in B_result:
                      #print "y[0]=%s" % (y[0])
                      print "table %s (order_mark_id) = %s" % (B_table,y[0])
                      query = ("delete from  %s  where order_mark_id = %%s;") %(B_table,)
                      mycursor.execute(query, (y[0],))

       # clear A1 for order_id 
       query = ("delete from  %s  where order_id = %%s;")  %(A_table,)
       A_order_id=x[0]
       mycursor.execute(query, (A_order_id,))
       print "---------------------------------------"
  


 
     

print "the program has finished"
     

mydb.commit()
mycursor.close()
mydb.close()


-----

| pip


вот мы написали в скрите

import termcolor

а он в ответ ошиьку

ImportError: No module named termcolor

это значит что у нас неустанолвен модуль питона termcolor



установка модулей.

можно ставить глобально через # apt-get install -y python-имя_модуля

а можно ставить локально 

$ pip install имя_модуля


обычно pip это для установки модулей для python-2
а pip3 для устанвок модулей для python-3

но надо проверять что показывает

$ pip --version
pip 20.3.4 from /home/vasya/.local/lib/python2.7/site-packages/pip (python 2.7)

потому что ыает что pip покзывает что он для python-3

----
| list
| intersect

задача есть list и надо найти есть ли пересечения со списком

!/usr/bin/python

import sys
import collections


i_min=50000          
bad_account_id=[
4005556,
4005550,
4005544,
4005538,
4005533,
3992314,
3992313,
3990514,
3990507,
3990501,
3990494,
3990489,
3990482,
3990472,
3989891,
3989890,
3989883,
3896752,
3896751,
3072203,
3026365,
2719223,
2682160,
2678435,
2661899,
2661588,
2640027,
2630711,
2630525,
2630359,
2630345,
2630222,
2630208,
2630145,
2630132,
2629869,
2291738,
2255326,
2255212,
2255165,
2061990,
1955250,
1955249,
1946305,
1938712,
1928827,
1651887,
1651886,
1646097,
1646096
]  # bad_account_id == accounts that intersect payment_gateway table




  result = collections.Counter([i]) & collections.Counter(bad_account_id)
  if len(result) != 0:
     print "intersection exists"



тут полезно заметиь как обьявить большой спмсок в виде столбика
также полезно то что когда мы ссмотрим пересечение переменной i и списка 
то пременную надо тоже превратить в список через [i]

===

| запись в файл

$ cat 1.py 

#!/usr/bin/python
import sys
import os.path





current_dir = os.getcwd()
suffix = "/account.settings"
path = current_dir
path += suffix
print "settings file path = %s" % (path)
check_file = os.path.isfile(path)

if check_file== True:
  print "settings file is found"
  f = open("%s" % path, "w")
  f.write("111")
  f.close()


else:
  print "settings file is not found"
  f = open('%s' % path, 'w')
  f.write("222")

  #open and read the file after the appending:
  f = open('%s' % path, "r") 
  print(f.read())
  f.close()



===

| как импортировать переменную из файла

ответ через модуль.
создаем файл

$ cat vasya.py
i = 15.5



тогда уже в нашем main.py


from vasya import *
print "i= %s" %(i)


===

| query mysql

как делать много строчный query
ответ надо юзать три двойные кавычки


query  = ("""INSERT INTO %s " % cfg['mysql.table']
              "('hostname', 'timestamp', 'metric', 'average', 'peakhigh', 'peaklow', 'gsamp', 'zsamp', 'nsamp')"
              "VALUES ( %s, %s, %s, %s, %s, %s, %s, %s, %s )"""
             ) 

===

| pipx

лусше его неиспользовать. лучше заморочиться и заюзать
руками pip

что касается юзания ибоих этих утилит через прокси то
ест засавить их ходить в инет через прокси то нужно
всего навсего

  export http_proxy="http://IP:port"
  export https_proxy="http://IP:port"

замечу что вобоих случаях то что внутри кавычек то 
В ОБОИХ СЛУЧАЯХ нужно ставит HTTP без S !!
