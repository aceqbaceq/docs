python

====

поговорим про установку ansible через 

$ pip install ansible
$ pip3 install ansible
$ sudo -H pip install ansible
$ sudo -H pip3 install ansible
$ pip\pip3 venv ansible
$ apt-get -y install ansible

в чем разница этих установок. что будет если их намешать однрвеменно.

TLDR: если хочешь сразу узнать ответ то смотри  kubespray-ansible.txt


далее длинный подробный ответ:
прежде всего про питон.
у него есть модули и пакеты.
A module is a file containing Python definitions and statements.
любой файл с кодом питона внутри это и есть модуль. модуль должен иметь 
расширение .py с точки зрения названия файла. например vasya.py

как посмотреть список модулей которые "видит" питон.
заходим в питон
$python3
>>>> 

далее вводим

>>> help('modules')


и получим список модулей которые видит питон.

питон ищет модули (файлы с расширением .py) в каталогах которые прописаны в sys.path

>>> import sys
>>> sys.path

['', '/usr/lib/python36.zip', '/usr/lib/python3.6', '/usr/lib/python3.6/lib-dynload', '/home/vasya/.local/lib/python3.6/site-packages', '/usr/local/lib/python3.6/dist-packages', '/usr/lib/python3/dist-packages']

прокомментирую эти папки

/usr/lib/python36.zip   
этой папки вобще на компе нет

/usr/lib/python3.6 
первая основная системная папка

/usr/local/lib/python3.6/dist-packages
вторая основная системная папка

именно в эти две папки обычно и ставит пакеты pip и pip3 

/usr/lib/python3.6/lib-dynload 
в этой папке лежат .so файлы. so файлы это shared
libraries (посмотреть какие so файлы  юзает любой бинарник можно через ldd имя_бинарника)

/home/vasya/.local/lib/python3.6/site-packages
сюда питон ставит новые модули в случае если мы запускаем процесс установки 
модуля без прав суперюзера а значит у питона нет прав чтобы ставить модули
в папки что выше. тогда он ставит модули в папку /home/vasya/.local/...



так вот чтобы питон увидел новый модуль file.py его надо всего лишь поместить в одну 
из папок что выше 
и help('modules') покажет новый модуль в списке.


причем что еще интересно. если поместить модуль в подпапку например в 
/usr/local/lib/python3.6/dist-packages/01/file.py 
то питон этот модуль тоже увидит. тоесть питон ищет нетолько в указанных папках
но и подпапках.

далее. как сидя в питоне узнать путь к файлу в котором хранится модуль.

>>> import kuku
>>> print(kuku.__file__)
/usr/local/lib/python3.6/dist-packages/kuku.py

(подсмотрел здесь https://www.devdungeon.com/content/get-module-file-information-python)


итак модуль это всегонавсего файл с кодом питона. а установка модуля так чтобы 
питон его видел это всегонавсего скопировать файл в определенную папку.

теперь про пакеты питона.
пакет это группа модулей. пакет имеет вид папки в которой лежит куча питон модулей(которые 
как логично все посвящены какойто общей задаче).
чтобы питон отличил просто папку с кучей несвязанных друг с другом разнородных 
модулей от папки которая является пакетом в такой папке должен лежать файл __init__.py
если в папке лежит такой файл то питон понимает что это непросто папка с кучей модулей
друг с другом несвязанных а это папка с кучей модулей друг с другом связанных
являющаяся пакетом.
 как я понял пакет (папка) обычно также содержит подпапку __pycache__
в которой лежат уже откомпилированые модули этого пакета. захера они нужны.
как я понял при загрузке пакета питон вначале ищет pyc файлы и если они есть грузит их.
а если нет тогда py файлы. разница между py  и pyc файлами в том что прежде чем начать
исполнять код питон должен откомпилировать py файл в pyc  а если это уже сделано 
то это экономит сколько то времени.

внутри пакета могут быть без пролем другие пакеты. главное чтобы папка с субпакетом 
имела файл __init__.py

также. и модуль при импорте и пакет оба они получат один статус в питоге. - статус модуля.

хотя os это пакет а kuku это модуль 

>>> import os
>>> type(os)
<class 'module'>
>>> import kuku
>>> type(kuku)
<class 'module'>

они оба получают одинаковый класс module 

далее. прикол в том что чрез команду import мы формально испортируем модуль.
вобщем люди пишут что пакеты это тоже модули. просто типа они офомлены другим образом.
вобщем непонятный идиотизм. также модуль это в конечно итоге обьект в памяти питона.
пакет это модуль который должен иметь атрибут __path__ а просто модуль этого атрибута
неимеет.
прикол еще в том что якобы питона пакеты и pypi пакеты это совсем разные пакеты.
идиоиизм.


тем не менее. двигаем дальше.
пакет поскольку он модуль то установенный пакет он тоже отображается командой
>>> help('modules')
имя пакет будет такое же как называется папка с пакетом.
поэтому если мы хотим посмотреть какие пакеты видит питон то надо искать 
имя пакета в списке модулей.
пакеты ставятся в туже папку что и модули.
как они ставятся?
можно ставить руками.

идем на сайт с питон пакетами. выбираем пакет
https://pypi.org/project/wa-cli/#files

тыкаем в "downloaded files"
скачиаем файл tar.gz с пакетом

дальше запускаем
$ python3 setup.py  install

но скорей всего при этом установщик заругается что нехватает прав записи в в системные
папки

  [Errno 13] Permission denied: '/usr/local/lib/python3.6/dist-packages/test-easy-install-1515.write-test'

тут два выхода.
первый это запустить установку с повышенными правами

$ sudo -H python3 setup.py  install

но этот метод вызывает вопросы потому что в питоне каждый модуль может быть установлен
только какой то версии. а прикол в том что разные проги могут нуждатся в модуле определенной
версии поэтому модифцируя системные папки питона мы можем  изменить версию какого то 
модуля\пакеты и тогда какая то программа незаработае после этого.
вобще пока что дело темное.

есть другой путь. поставить модуль локально только для нашего юзера в папку .local

$ python3 setup.py  install   --user

тогда пакет будет устанолвен в папку 

~/.local/lib/python3.6/site-packages/wa_cli-0.0.0-py3.6.egg
 
далее его можно увидеть через 

>>>> help('modules')
wa_cli

после установки его можно ипортнуть и юзать

>>>> import wa_cli

далее прикол в том что при устаноаке пакета он ставит свои запчасти нетлоько 
в папки прописанные в sys.path но и в папки : 

~/.local/bin
/usr/bin
/usr/local/bin

а это уже дает то что файлы по данным путям уже видит нетолько сам питон
но и баш. таким образом после установки пакета у нас может появится в д оступе
новый питон скрипт которые можно запустить сразу с баш строки. таким образом установка пакета
питона становится конкурентом пакетного менеджера apt !

например!  ansible это нечто иное как питон пакет. так вот ансибль можно скачать с сайта pypi
и поставить как пакет: распоковать и sudo -H python3 setup.py  install

опа! тоесть мы скажем проверяем есть ли у нас ансибль в системе через sudo dpkg -l | grep ansible
и видим что deb пакета такогонет. зато ансибль вместо этого может быть установлен через пакеты питона!  вот это жопа!!

боле того ! по факту apt-get -y insyall ansible он на самом деле делаем тоже самое что мы бы 
делали руками - он ставит пакет питона только за нас !!!!!  

тут я еще скажу вот что - руками ставить пакеты питона это идиотизм также как руками ставить
deb пакеты через dpkg. аналогом apt-get у питона является пакет pip3 (для питона 3) и pip (для питона2)

ставим pip3

$ sudo apt-get update && sudo apt-get -y install python3-pip

данный пакет ставит документашки в /usr/share/doc и /usr/share/man
ставит wrapper скрипт (запускашку) в  /usr/bin/pip3 ( про вызове этого скрипта сам питон 
потом ругается что мол это устаревший метод вызова пакета pip3 и вместо него надо юзать 
python3 -m pip команду). и ставит кучу файлов в /usr/lib/python3/dist-packages/pip/ это та папка 
куда для питона надо ставить файлы от модулей или пакетов.

все теперь про ручную усатновку пакетов питора можно забыть.


после установки у нас питон3 увидит новый модуль pip

>>> help('modules')
pip

>>> import pip

>>> print(pip.__file__)
/usr/lib/python3/dist-packages/pip/__init__.py

итак через apt у нас будут скопированы файлы в папку /usr/lib/python3/dist-packages/pip/
и также будет создан файл /usr/bin/pip3

таким образом с точки зрения питона у него появился пакет с именем pip!
а если запускать через баш то нам надо обращаться к файлу pip3 !

тогда уже юзая pip3 мы можем посмотреть какие пакеты ( пакеты а не модули!) установлены 
в системе

$ pip3 list
...
pip (9.0.1)
...

в частности увидим что он покажет сам себя что пакет pip установлен.

далее можем посмотреть инфо об этом пакете через pip3

$ pip3  show pip

Name: pip
Version: 9.0.1
Summary: The PyPA recommended tool for installing Python packages.
Home-page: https://pip.pypa.io/
Author: The pip developers
Author-email: python-virtualenv@groups.google.com
License: MIT
Location: /usr/lib/python3/dist-packages
Requires: 


далее теперь уже средстваами pip ( а не apt ) мы можем заапгредйить пакет pip

$ pip3 install --upgrade pip
Collecting pip
  Downloading https://files.pythonhosted.org/packages/a4/6d/6463d49a933f547439d6b5b98b46af8742cc03ae83543e4d7688c2420f8b/pip-21.3.1-py3-none-any.whl (1.7MB)
    100% |████████████████████████████████| 1.7MB 428kB/s 
Installing collected packages: pip
Successfully installed pip-21.3.1

итак была унас версия 9.0.1 а стала 21.3.1

а куда же он ее поставил ведь мы запустили без права админа

$ pip3  show pip
WARNING: pip is being invoked by an old script wrapper. This will fail in a future version of pip.
Please see https://github.com/pypa/pip/issues/5599 for advice on fixing the underlying issue.
To avoid this problem you can invoke Python with '-m pip' instead of running pip directly.
Name: pip
Version: 21.3.1
Summary: The PyPA recommended tool for installing Python packages.
Home-page: https://pip.pypa.io/
Author: The pip developers
Author-email: distutils-sig@python.org
License: MIT
Location: /home/vagrant/.local/lib/python3.6/site-packages
Requires: 
Required-by: 

ага понятно. поставл он ее локально в папку $/.local/

помимо sudo и без sudo есть еще один вараинт установки пакетов через venv.(об этом позже)

есть еще такой способ работы с pip3

$  python3 -m pip install --upgrade pip


теперь поставим ансибль через pip3

$ python3 -m pip install ansible

поставится он только для данного юзера в .local

$ python3 -m pip  show ansible
Name: ansible
Version: 4.10.0
Summary: Radically simple IT automation
Home-page: https://ansible.com/
Author: Ansible, Inc.
Author-email: info@ansible.com
License: GPLv3+
Location: /home/vagrant/.local/lib/python3.6/site-packages
Requires: ansible-core
Required-by: 


что интересно если юзать pip3 ... то питон ругается что модуль pip вызывается через 
старый wrapper и сам питон рекомедует юзаьть вызов pip через нотацию $ python3 -m pip

что интерсно. ансибль это тоже модуль\пакет который виден через help('modules')
но к ансиблю вот в такой форме уже неподуступиться

$ python3 -m ansible --version
/usr/bin/python3: No module named ansible.__main__; 'ansible' is a package and cannot be directly executed

итак мы поставили ансибль через менеджер пакетов питона

$ python3 -m pip install ansible

ансибль это питон пакет.

поставили мы его без админских прав.

и он поставился в папку ~/.local/lib/...

таким образом если мы будем накатывать ансибль через apt-get то он конешно тожн будет по факту
пакет от питона но будем установлен в /usr/lib либо /usr/local/lib и никакого конфликта
с ансиблем который лежит в ~/.local/lib/... невызовет.

тут еще важно отметить про ансибль. с какогото момента он теперь состоит из двух 
питон пакетов.

- ansible
- ansible-core

$ python3 -m pip list | grep ansible
ansible                       4.10.0
ansible-core                  2.11.7

(стоит упомнять что ансибль чуть более старый имел второй пакет ansible-base вместо ansible-core )

также стоить упомнуть что файл из ~/.local/bin/ansible
он исходит из пакета ansible-core

пруф
$ python3 -m pip show -f ansible-core | grep 'bin/ansible'
  ../../../bin/ansible

пакет ansible-core обеспечивает некий базовый функционал ансибля.
над ним работют как я понял более продвинутые програмисты. а пакет ansible 
там уже куча модулей (ансибля) над которыми работают уже кто попало из комьюнити ансибля.

поэтому для устаовки ансиля в целом достаточно установить пакет ansible-core

$ python3 -m pip install ansible-core

а пакет ansible уже опционален.


также понятно что питон модули глобальрно лучше неставить через pip3 
чтобы небыло разногласий с apt-get

еще момент дебилистический. если мы у самого ансибля спросим какая у него версия
он напишет полную хуйню

$ ./ansible --version
ansible [core 2.11.7] 

он напишет версию пакета core. а нас интересует какая версия у пакета ansible
так вот чтобы это узнать надо спрашивать не уансибля а у питона

$ python3 -m pip list | grep ansible
ansible                       4.10.0
ansible-core                  2.11.7

теперь мы видим что коммунити кусок имеет версию 4.10 а уже ядро имеет версию 2.11.7

все таким поставим анстбдь из apt-get чтоы посмотреть в какие папки apt засунет модуль 
ансибль

$ sudo apt-get update && sudo apt-get -y install ansible

$ sudo dpkg -L ansible | grep 'bin/ansible'
/usr/bin/ansible

итак апт засунул запускающий скрипт ансибля в /usr/bin/ansible

ну и если еще посмотреть на dplg -L ansible 
то увидим что сам питон пакет apt засунул в /usr/lib/python2.7/dist-packages/ansible/

итак получаетс что apt ставит пакет ансибля не для python3 а для python2

проверяем версию ансибля
$ /usr/bin/ansible --version
ansible 2.5.1

получается это еще старая версия ансибля та которая была еще до разделения его на 
core модуль и коммьюнити модуль

поставим pip для второго питона

$ sudo apt-get -y install python-pip

и посмотрим какую он инфо покажет насчет этого ансибля

$ pip list | grep ansible
ansible (2.5.1)

$ pip show ansible
Name: ansible
Version: 2.5.1
Location: /usr/lib/python2.7/dist-packages


воникает вопрс  а если мы для питон3 поставим ансибль то в какой папке будет bin/ansible ?


sudo -H python3 -m pip show -f  ansible-core | grep 'bin/ansible'
  ../../../bin/ansible

поскольку пакет был установлен в папку /usr/local/lib/python3.6/dist-packages/
$ sudo -H python3 -m pip show  ansible-core 
Name: ansible-core
Location: /usr/local/lib/python3.6/dist-packages

то папка ../../../ будет иметь путь  = /usr/local

значит ../../../bin/ansible = /usr/local/bin/ansible


теперь сравниваем apt поставил ansible (файл) от питона2 в папку /usr/bin/ansible
а sudo pip3 поставил файл ansible от питона3 в папку /usr/local/bin/ansible

получается впринициепе что два ансибля могут спокойно типа существовать на компе
одновременно. ( но опять же это до поры до времени пока apt неначнет ставить ту версию ансибля
которая для версии от питона3)

осатетя вопрос - так кау версию ансибля будет запускат баш из командной строки

$ ansble --version

если у нас аж три ансибля установлено.
ответ баш запустить ансибль тот который лежит в ~/.local/bin

теперь можно возвоаратиться к исходному вопросу
в чем разница установки ансибля всеми этими способами
и будут ли они мешать друг другу

$ pip install ansible
$ pip3 install ansible
$ sudo -H pip install ansible
$ sudo -H pip3 install ansible
$ pip\pip3 venv ansible
$ apt-get -y install ansible

во первых я бы скзаал что строки 
$ pip install ansible
$ sudo -H pip install ansible

я бы вобще исключил. ибо ненаоб ставить ансибль на питон2 который уже 
ансибль нехочет юзать и хочет от него избавиться


вот этот способ
$ pip\pip3 venv ansible
мы нерассмотрели. ну и хер с ним. там ничего интересного.

остаются строки
$ pip3 install ansible
$ sudo -H pip3 install ansible
$ apt-get -y install ansible


тут я скажу так. apt-get -y install ansible =  этот метод поставит ансибль для второго питона.
этот метод никак неперескеется и немешает установке ансибля через оставишиеся строки
$ pip3 install ansible
$ sudo -H pip3 install ansible

если сранвить оставшиеся строки . то первая ставит ансибль в папку ~/.local
а вторая в папку /usr/local/lib/python3.6/
эти две установки друг другу никак немешают.

и  в целом поучается эти три способа усатновки друг другу никак немешают.
единсвтенное что: в будущем apt может начать ставить ансибль уже не для второго питона 
а для третьего и тогда уже конфликт становится очевиден.  и тогда получается что надо 
решатт либо ставить ансибль чеерез 

$ sudo -H pip3 install ansible
либо
$ sudo -H apt-get -y install ansible

но чтото одно. 

и еще замечаение что (пока в целом непонятно ) но ставить модули питона в системную папку 
под sudo pip3 вроде как плохой тон. ибо можно поломать чтото из за того что будут обновлены
версии пакетов. это пока непонятно. тоесть безопаснее ставить pip3 под лкальными правами
чтобы установка шла в локальну папку ~/.local

возгикает общий вопрос - так а как луче всего ставиь ансибль. каким способом.

тут вилка в том что через apt можно поставить будет какую то древнюю версию а через 
pip поставить ульрасовременную.  поэтому наверно суммарно  я за вот этот способ

$ pip3 install ansible
или 
$ python3 -m pip install ansible

оба способа равнозначны. этим способом мы ставим ультрасоверменную версию ансибль 
только локально для себя. ничего неломая и ничем нерискуя.



далее мне ставло интеересно а каку версию ансибля поставит pip для второго питона

vagrant@test2:~$ ansible --version
ansible [core 2.11.7] 
  python version = 2.7.17 (default, Feb 27 2021, 15:10:58) [GCC 7.5.0]

очевидно что явно нестарую версию.

vagrant@test2:~$ python -m pip list | grep ansible
ansible (4.10.0)
ansible-core (2.11.7)


и там в варнинге написано что со следущего релиза ансибль комнда програмисто 
прекращает поддержку питона2

а вот проверим а каку версию ансибля ставит apt для ubuntu21.10 тот который самый 
распоследний. при установке через вагрант вылезает ошибка вида
bash: line 4: /sbin/ifdown: No such file or directory
и прочая поебень.
но отчаиваться рано. решение такое. все равно можно зайти на ВМ. и там просто 
надо накатить пакет ifupdown

$ vagrant ssh
$ sudo apt-get install ifupdown

далее. ставим ансибль через apt

теперь смотрим что у него за версия

$ ansible --version
ansible 2.10.8
  ansible python module location = /usr/lib/python3/dist-packages/ansible
  executable location = /usr/bin/ansible

видим что версия уже точно для питон3.
значит смешивать установку ансибля через pip3 и через apt нельзя. чтото одно.

видим что версия 2.10.8


$ python3 -m pip list | grep ansible
ansible-base           2.10.8

забавно. еще нет никакого разеления на пакеты ansible и ansible-core. а по прежнему
один пакет.

$ python3 -m pip show ansible-base
Name: ansible-base
Version: 2.10.8

посмотрим что еще dpkg покажет

$ sudo dpkg -l | grep ansible
ansible                         2.10.7+merged+base+2.10.8+dfsg-1 

прикол. версия deb пакета толи 2.10.7 толи 2.10.8 хуй поймешь


удаляем ansible через apt

ставим ансибль через pip3
$ python3 -m pip install ansible-core

получаем 
$ ~/.local/bin/ansible --version

ansible [core 2.12.1]
  ansible python module location = /home/vagrant/.local/lib/python3.9/site-packages/ansible
  executable location = /home/vagrant/.local/bin/ansible

ставим коммьюнити пакет.

$ python3 -m pip install ansible

в итоге получаем

~$ python3 -m pip  list | grep ansible
ansible                5.1.0
ansible-core           2.12.1


ансибль версия пятая потому что в убунту21 уже стоит питон 3.9 
а в убунту 18 который у меня на первой тестовой машине там стоит всего лищь питон 3.6

заметки:
установка в $HOME/.local = если у pip\pip3 нехватает прав чтобы записывать в папки
/usr/lib/python3.6 /usr/local/lib/python3.6/dist-packages то ставит пакет в папку $HOME/.local.
эта папка входит в sys.path так что питон прекрасно там находит пакеты. единственное что установ
ленный пакет будет доступен толькьо для теекущего юзера зато незатрагиваются системные папки питона.

далее. версии современного ансибля.
раньше ансибль шел в форме одного пиитон пакета. с недавнего времени он разделен на два пакета.
ansible-core ( который вначале назывался еще ansible-base) и пакета ansible.
ansible-core является пакетом исходным и основным над его поддержкой работают самые крутые 
програмисты. пакет отвечает за самые основные функции ансибля в часьтности в неми и находится
файлик ansible. а второй пакет ansible за его поддержку ответчает уже комьюнити пионеров програмистов. там находятся уже всяко разные модули ансибля. 
дебилизм еще в том что скажем релиз ансибля имеет например номер 4.1.2 так вот это номер релиза 
именно пакета ansible который поддерживает комьюнити пионеров. а номер релиза ansible-core 
при этом скажем 2.10.17 так вот в  чем дебилизм это то что если у ансибля спросить мол какая у тебя версия 
$ ansible --version 
то он сука выдаст именно версию ядра а не самого ансибля. разве недебилизм?
и чтобы узанть версию ансибля надо обращаться к питону к модулю pip3
$ python3 -m pip list | grep ansible 
либо 
$ python3 -m pip show ansible

далее. при установке пакета через pip3 ( и pip далее всегда если пишу pip3 то автоматом это же верно  и для pip) он копирует файлы нетлько в системные папки питона /usr/lib/python3.6 /usr/local/lib/python3.6/dist-packages но также и в папки /usr/bin/ либо /usr/local/bin. туда он ставит файлы обертки для запуска модулей. например файл-обертка ansible. так вот установка в /usr/local/bin
либо в /usr/bin дает то что файлы обертки видит баш.

далее. поскольку мы можем ставить модули питона и через pip3 и через apt то получется жопа
у нас на компе потому что у нас получается две системы пакетов одновременно хотя и касающихся только
питона. тоесть можно поставить пакет через apt а потом его обновить через pip3 и получается отстой.

далее. в убунту18 apt ставит ансибль для питона2. а начиная с убунту20 apt уже ставит ансибль для 
питона 3.

далее. если apt ставит какой то пакет питона то этот пакет будет конечено же виден и через 
pip3 list и через help('modules') тоесть apt устанавливая пакеты питона неделает никаких чудес.


далее. как я понял есть с  пакетами питона проблема. каждый пакет имеет какую то версию.
далее вот у нас есть какойто питон скрипт либо какойто питон модуль ( кстати скрипт питона 
становится модулем если его всего навсего скопироват в системную папку питона вот и вся разница) и 
этот скрипт или модуль требует для себя какойто другой модуль определенной версии либо нениже 
какойто версии. так вот как  я примерно понимаю что в любой момент в ОС может быть устанолена 
только одна версия модуля путем того что этот модуль лежит в системной питон папке. так вот 
если мы обновляем модуль питона либо ставим +1 модудь питона который обновляет другой модуль 
который уже есть в системе то может получится ситуация что другой модуль уже перестанет работаьт
из за обновления вресии модуля. например мы ставим модуль А который требует для себя модуль Б версии  Y, тогда pip3 обновить модуль Б до версии Y а у нас в системе есть модуль C который тоже 
юзает модуль Б но ему надо чтобы модудь Б был версии X. 
таким макаром навскидку с питоном получается дебилистическая ситуация. наверное когда мы ставим
модули питона через apt то они ( секретные они ) заботятся чтобы проверить совместимость всех модулей а когда мы ставим\обновляем модуль питона через pip3 то это становится нашей головной болью.
дебилизм какойто в питоне однако. поэтому получается что если мы ставим какой то модуль сами 
через pip3 то лучше и безопаснее неделать это через sudo pip3 чтбоы нетрогать системные папки
с модулями питона а делать это через pip3 с понимженными правами тогда все имзенения с модулями
будут каcаться только папки $HOME/.local/ а еще наверное более надежно делать установку через связку pip3 + venv тогда точно ничего несломается.


далее. команда which ansible где и как она находит ansible. which ansible - он его ищет в папках которые прописаны в $PATH в том порядке как там папки указаны.
и в какой первой находит ткую и выдает.   а вот когда мы уже запускаем в баше ансибль то он 
почему то ищет в папках по другому порядку. по какому я так и непонял. 
 поэтотому если у нас ансибль есть и  в /usr/bin и в /usr/loca/bin/
то which absible выдвет что ансибль лежит в /usr/loca/bin/ а по факту бащ запускает бинаник из /usr/bin. это надо еще разбирать. 

далее. если у нас на компе стоит милион версий ансибль как нам об этом узнать. 
можно проверить через apt, можно через pip3. но опять же pip3 покажет только одну версию ансибля.
а если скажем у нас один модуль стоит в папке 
/usr/lib/python3.6 а другой модуль стоит в папке $HOME/.local тот pip3 покажет только 
ансибль модуль в папке $HOME/.local так что самый надежный способ это через find найти все 
файлы на компе с именем ansible и ключом +x у него. это дебилизм.

далее. если мы запускаем pip3   с повышенными правами то неважно как запускать 
sudo или sudo -H , так как домашняя папка неважна ибо установка будет идти не в домашнюю
папку а в папки /usr/lib/python3.6  либо /usr/local/lib/python3.6


далее.итак наконец как же коректно поставить ансибль для проекта kubespray
смотри в kubespray-ansible.txt
=============================================================================
ubuntu 18
pip
pip3


# sudo apt install python-pip
# sudo apt install python3-pip


====

|mysql connector

$ pip install mysql-connector-python

==
| список модулей

$ pip list

либо

>>>  help("modules")


===

| mysql connector

значит пишу что его надо ставит как 

$ pip install mysql-connector-python

мне так где то сработало а где то нет.

на ubuntu 18 не сработало. при запуске питон скрипта 
мне писало ошибку


"MySQL Connector C Extension not available"

как ее поорбоить непонятно.

поэтому сносим нахуй этот модуль в pip (если уже установили)

$ pip uninstall mysql-connector-python

а далее ставим пакеты

# apt-get -i install
libmysql6.4-cil
libmysqlclient20:amd64
python-mysql.connector
python-mysqldb
python3-mysqldb


не могу точно сказать какой паеет прям спасает но мне кажетс что это libmysql6.4-cil

только после этого доступ к мускула через питон заработает сука

====

| mysql connect

скрипт



он лезет в таблицу waybill.
берет оттуда самый старый waybill_id
потом его ищет в дочерних таблицах.
удаляет если там есть строки и потом удаляет уже в головной таблице waybill



# cat 1.py 
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     

date_end = datetime.date(2011, 1, 1)
j_max=5000


mydb = mysql.connector.connect(
host="172.17.0.1",
user="root",
password="rootpass",
database="db",
port=3306
)
     
mycursor = mydb.cursor()
     


#
# waybill
#
query = ("SELECT waybill_id, date  FROM waybill "
       "WHERE date <= %s order by date asc limit 1")

mycursor.execute(query, (date_end, ))
myresult2 = mycursor.fetchall()
     
for x in myresult2:
       l = len(myresult2)
       




j=1

while l > 0:
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill WHERE date <= %s   order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult = mycursor.fetchall()

     if len(myresult) == 0:
        break

     for x in myresult:
         d=x[0]
         waybill_data=x[1]
         
     
     
     
     
     #
     #   order_profit
     #
     query = ("select waybill_id  from order_profit where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()


     
     if myresult:
        query = ("delete from  order_profit where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
          # Verify using select query (optional)
        query = ("select waybill_id  from order_profit where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     
     #
     #   category_waybill
     #
     query = ("select waybill_id  from category_waybill where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  category_waybill where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
        #print('number of rows deleted', mycursor.rowcount)
          # Verify using select query (optional)
        query = ("select waybill_id  from category_waybill where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     
     #
     #   storage_service
     #
     query = ("select waybill_id  from storage_service where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  storage_service where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
          # Verify using select query (optional)
        query = ("select waybill_id  from storage_service where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     #
     #   trip_contents
     #
     query = ("select waybill_id  from trip_contents where waybill_id = %s")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        #print "trip_contents has waybill_id=",d
        query = ("delete from  trip_contents where waybill_id = %s")
        mycursor.execute(query, (d,))
        mydb.commit()
        #print('number of rows deleted', mycursor.rowcount)
          # Verify using select query (optional)
        query = ("select waybill_id  from trip_contents where waybill_id = %s")
        mycursor.execute(query, (d,))
        records = mycursor.fetchall()
     
     
     
     
     
     #
     #   waybill
     #
     #print "waybill has waybill_id=",d
     query = ("delete from  waybill where waybill_id = %s")
     mycursor.execute(query, (d,))
     mydb.commit()
     #print('number of rows deleted', mycursor.rowcount)
     
     
     query = ("select waybill_id  from waybill where waybill_id = %s")
     # Verify using select query (optional)
     mycursor.execute(query, (d,))
     records = mycursor.fetchall()
     
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill "
               "WHERE date <= %s order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult2 = mycursor.fetchall()
     if len(myresult2) == 0:
        break

     
     for x in myresult2:
         #print "111 waybill_id=",x[0]
         #print ""
         l = len(myresult2)


     if j == j_max:


         from datetime import datetime
         now = datetime.now()
         current_time = now.strftime("%H:%M:%S")
         print("Current Time =", current_time)

         print "waybill_data=", waybill_data
         print j_max," rows has been proceeded\n"

         j = 0
     else:
        j+=1


print "the program has finished"
     
     
mycursor.close()
mydb.close()

----------------------------

а вот несклоько изменная версия этого же скрипта


# cat 2.py

                                                                                                                                                                                              
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     

date_end = datetime.date(2019, 1, 1)
j_max=5000


mydb = mysql.connector.connect(
host="172.17.0.1",
user="root",
password="rootpass",
database="db",
port=3306
)
     
mycursor = mydb.cursor()
     


#
# waybill
#
query = ("SELECT waybill_id, date  FROM waybill "
       "WHERE date <= %s order by date asc limit 1")

mycursor.execute(query, (date_end, ))
myresult2 = mycursor.fetchall()
     
for x in myresult2:
       l = len(myresult2)
       




j=1

while l > 0:
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill WHERE date <= %s   order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult = mycursor.fetchall()

     if len(myresult) == 0:
        break

     for x in myresult:
         d=x[0]
         waybill_data=x[1]
         
     
     
     
     
     #
     #   order_profit
     #
     query = ("select waybill_id  from order_profit where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  order_profit where waybill_id = %s")
        mycursor.execute(query, (d,))
     
     
     
     
     
     #
     #   category_waybill
     #
     query = ("select waybill_id  from category_waybill where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  category_waybill where waybill_id = %s")
        mycursor.execute(query, (d,))
 
     
     
     
     
     #
     #   storage_service
     #
     query = ("select waybill_id  from storage_service where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  storage_service where waybill_id = %s")
        mycursor.execute(query, (d,))
 

     
     
     
     #
     #   trip_contents
     #
     query = ("select waybill_id  from trip_contents where waybill_id = %s limit 1")
     mycursor.execute(query, (d,))
     myresult = mycursor.fetchall()
     
     if myresult:
        query = ("delete from  trip_contents where waybill_id = %s")
        mycursor.execute(query, (d,))
 
     
     
     
     
     
     #
     #   waybill
     #
     #print "waybill has waybill_id=",d
     query = ("delete from  waybill where waybill_id = %s")
     mycursor.execute(query, (d,))

     
     
     
     
     
     #
     # waybill
     #
     query = ("SELECT waybill_id, date  FROM waybill "
               "WHERE date <= %s order by date asc limit 1")
     mycursor.execute(query, (date_end, ))
     myresult2 = mycursor.fetchall()
     if len(myresult2) == 0:
        mydb.commit()
        break

     
     for x in myresult2:
         #print "111 waybill_id=",x[0]
         #print ""
         l = len(myresult2)


     if j == j_max:
         # commit to DB every j_max cycles
         mydb.commit()
         # print current time
         from datetime import datetime
         now = datetime.now()
         current_time = now.strftime("%H:%M:%S")
         print "Current Time =", current_time
         print "waybill_data=",waybill_data
         print j_max," rows has been proceeded\n"
         # reset j counter
         j = 0
     else:
        j+=1


print "the program has finished"
     

mydb.commit()
mycursor.close()
mydb.close()

---------

| print

по поводу распечатки 


создаем три переменные.
а потом хотим их вставиь в распечатку.

print "table %s, order_id=%s, order_mark_id=%s" % (A_table,p,q)

разберем по частям

"table %s, order_id=%s, order_mark_id=%s"

через %s указывается очередная стринг перменная . какое именно имя
переменной мы пропишем позже.
таким образом у нас укзаано что есть три стринг перпенных.

% (A_table,p,q)

это кусок как раз укащзываем имена переменных которые надо подставить внутрь.
а вот поный листинг програрммыы


# cat 4.py

#!/usr/bin/python
import sys


A_table="vasya"
p=1
q=2


print "table %s, order_id=%s, order_mark_id=%s" % (A_table,p,q)

прочитал я об этом вот здесь

https://www.learnpython.org/en/String_Formatting#:~:text=Python%20uses%20C%2Dstyle%20string,%22%20and%20%22%25d%22.

помогла фраза:
Python uses C-style string formatting to create new, formatted strings. The "%" operator is used to format a set of variables enclosed in a "tuple" (a fixed size list), together with a format string, which contains normal text together with "argument specifiers", special symbols like "%s" and "%d".

и пример

# This prints out "John is 23 years old."
name = "John"
age = 23
print("%s is %d years old." % (name, age))

----
| mysql connect


вроде бы сто раз напиано как  раотать с мукулом через питон.
но на практике там хуйня.
дело вот в чем


методе .execute() который и пуляет запросы на мускул он умеет юзать переменные в выражении 
только для параметров НО СУКА он неумеет использовать переенные для имени базы сука.
поэтму если мы хотим имя базы в запросе прописать через перменную а не константу то надо изголиться


пример работюащейго листинка



#!/usr/bin/python

import sys


A_table="vasya"
p=1
q=2


print "table %s, order_id=%s, order_mark_id=%s" % (A_table,p,q)

[vasya@lenovo order]$ cat temp3.py 
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     


mydb = mysql.connector.connect(
host="localhost",
user="root",
password="rootpass",
database="db",
port="3308"
)
     
mycursor = mydb.cursor()
     

# order_id from A1 table
a1_order_id="1"


# set table names
tb="A1"



#   A1 (order_id,order_mark_id)
#
query = ("SELECT order_id,order_mark_id FROM `%s` WHERE  order_id = %%s") %(tb,)
mycursor.execute(query, (1,))
myresult2 = mycursor.fetchall()

print "the program has finished"
     

mydb.commit()
mycursor.close()
mydb.close()


значит самая фишка вот в этих двух строках


query = ("SELECT order_id,order_mark_id FROM `%s` WHERE  order_id = %%s") %(tb,)
mycursor.execute(query, (1,))


как я уже сказал если мы подставляем вмест имени базы пременуб то execute() метод будет 
сука как ни изголыйя выкидвать ошибку.  поэтому  как пишу умные люди  надо вставить имя 
базы в стринг до того как оно поступит в метод execute. делается это через кусок


query = ("  блаблабла  `%s` блаблабла") %(tb,)

вот эта хуйня соощает питону что надо в стринге query замениь %s на то что лежит в переменной tb
и эта замена происходит до того как query поступит в .execute

далее для того чтобы все нееперепуталось то уже для переменных которые умеет юзать execute 
используется %%s

таким образом в execute поступает query вида


query = ("SELECT order_id,order_mark_id FROM `A1` WHERE  order_id = %%s")

видим что A1 уже вставлен  ввиде константы. 

кстати вроде и такой вариант тоже рабоатет 

query = ("SELECT order_id,order_mark_id FROM `%s` WHERE  order_id = %%s") %(tb)


 яимею ввиду что было  %(tb,)  а стало %(tb)

 что это вобще за хуйня? а это идет из правил для print (смотри предыдущий вопрос).


 теперь что такое  mycursor.execute(query, (1,))
 а именно (1,)

 эта хуйня называется tuple в питоне. по руски переводится "кортеж". в любом слоучае ниуя непонянтно в плане
 первода.

 скажу точто в чем отличие tuple от list.
 в list порядок элементов (строк) неважен. так они пишут. якобы нваерно они имеют вввиду что если 
 создать список

 a= [1,2,3]
 то он при считыавании может якобы выдываься в любом порядке. 
 наверно это они имеюи ввиду.

 а tuple это как бы спсок но с четко строгим порядком элементов

 a= (1,2,3,4)
 вот как указали так и буедет выдавыться на считыавании.

 так вот хуйня вида

 a=(1,)
 она озанчает tuple только из одног элемента.

 так вот execute() метод от mysql connector он принимает на вход только tuple
 поэтому когда мы хотим передать чему равно order_id =1

 query = ("SELECT order_id,order_mark_id FROM `A1` WHERE  order_id = %%s")
 mycursor.execute(query, (1,))

то мы юзаем тупл вида (1,)

вот такая хует со всем этим дело.

супер ползыне ссылки откуда я узнал такак же сука подставял ять имя базы в виде перменнеой
а не виде хардлодка


https://stackoverflow.com/questions/6618344/python-mysqldb-and-escaping-table-names
https://stackoverflow.com/questions/9394291/python-and-mysqldb-substitution-of-table-resulting-in-syntax-error/9394450#9394450

вот еще пример оттуда

selectQ ="""SELECT * FROM  %s WHERE %s = %%s;""" % (self.table,self.columnSpecName)
self.db.execute(selectQ,(idKey,))

сразу замечу что """ xxx """ эквавалетент ("")
так что это эквивлаетно


selectQ =("SELECT * FROM  %s WHERE %s = %%s;") % (self.table,self.columnSpecName)
self.db.execute(selectQ,(idKey,))


значит что здесь и как работает.
мы видим два %s . они будут подставлены из  self.table и  self.columnSpecName переменных.

эквивалент


selectQ =("SELECT * FROM  %s WHERE %s = %%s;") % (A,B)
self.db.execute(selectQ,(idKey,))


если A="vasya" а B="petya"
то оно подставться как 

selectQ =("SELECT * FROM  vasya WHERE petya = %%s;") 

вот такая хуйня будет сделана с этим стрингом до того как он поуступит в .execute()
метод.

а когда оно туда поступит то .execute() увидит внутри переменную уже для себя %%s.
и он туда подставит то что находится в тупле (idKey,)
если idKey=1 то он подставит 1 и в итоге будет

"SELECT * FROM  vasya WHERE petya = 1;"
и такой запрос улетит в мускул.


вот такая хуйня.

таким образом перед тем как стринг улетит в мускул  его обрабыает с двух сторон 
с оной стороны сам питон   через конструкцию

selectQ =("блаблабля  %s блаблабла %s блаблабла") % (A,B)
а затем метод .execute() для которого это выглядит как

("блаблаблббла  %%s")
self.db.execute(selectQ,(idKey,))

и вместо %%s он подставить  (idKey,) а точнее idKey

пиздец полный этот питономастерсоздаетль

======
| tuple list

у питона есть виды данных

есть list

a= [1,3,4,5,5]

а есть tuple

a=(1,2,3)

или 

a=(1,)

это когда тупл из одного элемнта.

тупл в отличие от спска имеетт строгий поряок элементов.

так вот быает вот такой еще хрень на выходе

[(1,)]
что это ? 
это список

у котрого один элемент. и этот элемент это тупл.


возгикает ворос как добраться до этой единицы внутри

а вот так

$ cat 5.py 
#!/usr/bin/python
import sys


a=[(1,)]

print a

print a[0]

print a[0][0]

b=a[0][0]

print "b=%s" % (b)




$ ./5.py 
[(1,)]
(1,)
1
b=1


интеерсно да?

пздц

===================
|mysql connect


у нас есть две таблицы

A1 (order_id, order_mark_id) 
B1 (order_mark_id)

B1 это дочерняя таблица для A1 по полю  (order_mark_id)


мы делаем селект (order_mark_id) из `A1`  при заданом (order_id)
потом мы в таблице `B1` удаляем все строки с этим (order_mark_id)
и затем уже мы удалеяем в `A1` строку с этим (order_id)



стои обратить внимание как делается query

query = ("delete from  %s  where order_mark_id = %%s;") %(B_table,)
mycursor.execute(query, (y[0],))


дело в том что только при такой технологии мы можем передаваь в запрос имя таблицы
через переменную (ищи об этом подробнее чуть вы ше  в предыдущих вопросах . это пиздец)




[vasya@lenovo order]$ cat order_mark.py 
#!/usr/bin/python
import sys
import datetime
import mysql.connector
     
     

mydb = mysql.connector.connect(
host="localhost",
user="root",
password="rootpass",
database="db",
port="3308"
)
     
mycursor = mydb.cursor()
     

# order_id from A table
A_order_id="1"




#
#   A1 (order_id,order_mark_id)
#

# set table names
A_table="A1"
B_table="B1"

query = ("SELECT order_id,order_mark_id FROM  `%s`  WHERE  order_id = %%s;")  %(A_table,)
mycursor.execute(query, (A_order_id,))
A_result = mycursor.fetchall()


 
if A_result:
       # clear B1 for order_id and order_mark_id
       print "---------------------------------------"
       for x in A_result:
               # x[0] is order_id | x[1] is order_mark_id
               print "table %s  (order_id,order_mark_id) = (%s,%s)" % (A_table,x[0],x[1])
               B_order_mark_id=x[1]

               #
               #   B1  (order_mark_id)
               #
               query = ("SELECT order_mark_id FROM %s  WHERE  order_mark_id = %%s limit 1;") %(B_table,)
               mycursor.execute(query, (B_order_mark_id,))
               B_result = mycursor.fetchall()

               if B_result:
                   for y in B_result:
                      #print "y[0]=%s" % (y[0])
                      print "table %s (order_mark_id) = %s" % (B_table,y[0])
                      query = ("delete from  %s  where order_mark_id = %%s;") %(B_table,)
                      mycursor.execute(query, (y[0],))

       # clear A1 for order_id 
       query = ("delete from  %s  where order_id = %%s;")  %(A_table,)
       A_order_id=x[0]
       mycursor.execute(query, (A_order_id,))
       print "---------------------------------------"
  


 
     

print "the program has finished"
     

mydb.commit()
mycursor.close()
mydb.close()


-----

| pip


вот мы написали в скрите

import termcolor

а он в ответ ошиьку

ImportError: No module named termcolor

это значит что у нас неустанолвен модуль питона termcolor



установка модулей.

можно ставить глобально через # apt-get install -y python-имя_модуля

а можно ставить локально 

$ pip install имя_модуля


обычно pip это для установки модулей для python-2
а pip3 для устанвок модулей для python-3

но надо проверять что показывает

$ pip --version
pip 20.3.4 from /home/vasya/.local/lib/python2.7/site-packages/pip (python 2.7)

потому что ыает что pip покзывает что он для python-3

----
| list
| intersect

задача есть list и надо найти есть ли пересечения со списком

!/usr/bin/python

import sys
import collections


i_min=50000          
bad_account_id=[
4005556,
4005550,
4005544,
4005538,
4005533,
3992314,
3992313,
3990514,
3990507,
3990501,
3990494,
3990489,
3990482,
3990472,
3989891,
3989890,
3989883,
3896752,
3896751,
3072203,
3026365,
2719223,
2682160,
2678435,
2661899,
2661588,
2640027,
2630711,
2630525,
2630359,
2630345,
2630222,
2630208,
2630145,
2630132,
2629869,
2291738,
2255326,
2255212,
2255165,
2061990,
1955250,
1955249,
1946305,
1938712,
1928827,
1651887,
1651886,
1646097,
1646096
]  # bad_account_id == accounts that intersect payment_gateway table




  result = collections.Counter([i]) & collections.Counter(bad_account_id)
  if len(result) != 0:
     print "intersection exists"



тут полезно заметиь как обьявить большой спмсок в виде столбика
также полезно то что когда мы ссмотрим пересечение переменной i и списка 
то пременную надо тоже превратить в список через [i]

===

| запись в файл

$ cat 1.py 

#!/usr/bin/python
import sys
import os.path





current_dir = os.getcwd()
suffix = "/account.settings"
path = current_dir
path += suffix
print "settings file path = %s" % (path)
check_file = os.path.isfile(path)

if check_file== True:
  print "settings file is found"
  f = open("%s" % path, "w")
  f.write("111")
  f.close()


else:
  print "settings file is not found"
  f = open('%s' % path, 'w')
  f.write("222")

  #open and read the file after the appending:
  f = open('%s' % path, "r") 
  print(f.read())
  f.close()



===

| как импортировать переменную из файла

ответ через модуль.
создаем файл

$ cat vasya.py
i = 15.5



тогда уже в нашем main.py


from vasya import *
print "i= %s" %(i)


===

| query mysql

как делать много строчный query
ответ надо юзать три двойные кавычки


query  = ("""INSERT INTO %s " % cfg['mysql.table']
              "('hostname', 'timestamp', 'metric', 'average', 'peakhigh', 'peaklow', 'gsamp', 'zsamp', 'nsamp')"
              "VALUES ( %s, %s, %s, %s, %s, %s, %s, %s, %s )"""
             ) 

===
